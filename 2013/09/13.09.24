00:14:32 <Ghoul_> is there some standard thing for seconds/nanoseconds/microseconds ?
00:15:06 <leroux> Standard time unit out of those?
00:15:07 <leroux> Ghoul_:
00:15:08 <Taneb> I'd use Data.Time.Clock.NominalDiffTime
00:15:15 <leroux> Oh.
00:15:19 <Ghoul_> some package that exports functions which convert things into those
00:15:20 <Taneb> Or something in Data.Fix
00:15:26 <Taneb> *Data.Fixed
00:15:58 <Ghoul_> hmm the library im using uses Int
00:16:06 <Ghoul_> this looks like too much trouble, but thanks anyway.
00:16:35 <Ghoul_> I'll just have to multiply by 10^6 manually
00:16:42 <Taneb> (to me, using Int or Double for time is kind of really wrong)
00:23:56 * hackagebot rethinkdb 1.8.0.1 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-1.8.0.1 (EtienneLaurin)
00:25:31 <bergmark> wagle: yes fay is very interesting! :D don't listen to luite :(
00:31:35 <luite> bergmark: well you're right, i'm even going to show fay at my talk at the haskell symposium tomorrow
00:35:12 <bergmark> luite: oh right! forgot about that one
00:35:21 <bergmark> luite: good luck!
00:55:15 <haasn> but what if time is continuous!?
00:55:35 <haasn> clearly we want something like CReal
00:56:30 * ksf wants a way to influence the strictness of type functions
00:56:31 <Taneb> haasn, in that case the flying arrow is motionless
00:56:40 <ksf> seq on the type level if you will.
00:57:02 <haasn> Taneb: but what if reality is, like, running on a zeno machine
00:57:04 <haasn> or something
00:57:40 <Taneb> Anyway, it's impossible to measure time beyond a certain precision
00:58:25 <Taneb> So while a CReal is in principle optimum, I don't think I should think about this before breakfast
00:59:48 <Ghoul_> how do I use the put monad?
00:59:55 <Ghoul_> from Data.Binary.. there's no examples.
01:00:03 <haasn> Ghoul_: runPut or whatever
01:00:17 <haasn> Or uh.. I don't think I understand the question
01:00:21 <Ghoul_> Hmm, I have that part down. I can't get my function right though
01:00:23 <Ghoul_> sec, I'll gist
01:00:34 <haasn> you'd probably use the Monad instance to construct your Put out of smaller Puts
01:01:17 <Ghoul_> I can't figure out how that works, because I need a thing of the type I'm trying to put to know what to do
01:01:19 <Ghoul_> https://gist.github.com/kvanberendonck/6681683#file-server-hs-L28
01:01:22 <Taneb> Or you could use the builder monoid
01:01:30 <Ghoul_> but when I add an argument there, it doesn't satisfy a type of just `Put`
01:02:00 <Ghoul_> (the type is just me mucking around, but I actually need just :: Put)
01:02:16 <Taneb> Ghoul_, Put = PutM ()
01:03:21 <Ghoul_> I noticed that on haddock, but it's not telling me anything
01:03:44 <Ghoul_> for example, where do I get the thing I'm supposed to encode from?
01:04:01 <Taneb> In the Binary class, "put :: t -> Put"
01:04:17 <Taneb> /that/ is where you get the thing
01:04:23 <Ghoul_> what about when my things can only be put and not gotten
01:04:36 <Ghoul_> and vice-verca. Is that allowed?
01:04:42 <Taneb> It's allowed
01:04:51 <Taneb> Then make a function Thing -> Put
01:04:53 <Ghoul_> ok.
01:19:26 <divyansr> @ <*>
01:19:39 <divyansr> :t <*>
01:19:40 <lambdabot> parse error on input `<*>'
01:19:47 <divyansr> :t (<*>)
01:19:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:22:20 <divyansr> @hoggle [a] -> a
01:22:37 <divyansr> @hoogle [a] -> a
01:22:42 <lambdabot> Prelude head :: [a] -> a
01:22:43 <lambdabot> Data.List head :: [a] -> a
01:22:43 <lambdabot> Prelude last :: [a] -> a
01:22:43 <lambdabot> Prelude head :: [a] -> a
01:22:43 <lambdabot> Data.List head :: [a] -> a
01:22:44 <lambdabot> Prelude last :: [a] -> a
01:23:06 <divyansr> > take 5 [1..]
01:23:08 <lambdabot>   [1,2,3,4,5]
01:23:18 <arkeet> divyansr: what are you looking for?
01:23:51 <divyansr> @arkeet : Just testing features of lambdabot :)
01:23:51 <lambdabot> Unknown command, try @list
01:23:57 <arkeet> ok
01:24:02 <arkeet> don't address people with @ ;)
01:24:11 <arkeet> this isn't twitter ;)
01:24:15 <zhulikas> :D
01:32:54 <kqr> if i have a "data Car a = Car a String Int" is it possible to limit that to specific a (namely to valid values of "data Make = Ford | Mercedes | BMW")? the reason i'm asking is that it would be awesome to have type safety based on car make, and not having to worry about comparing different car makes
01:34:28 <ksf> kqr, yes and no.
01:34:39 <kqr> that's the answer i was looking for! please elaborate
01:35:04 <ksf> with -XDataKinds you can promote Make to the type level and write foo :: Car Ford
01:35:19 <haasn> Ghoul_: looks like your put function is fine, save for the type
01:35:31 <ksf> but that doesn't gain you much, or rather anything. as then the a in your Car wouldn't be able to have any value.
01:35:47 <kqr> ah right
01:35:56 <ksf> kqr, you might want to turn Make into a type class.
01:36:24 <kqr> i was trying that, but i ended up with a mess! i'm probably going wrong about it somewhere
01:36:37 <Ghoul_> haasn: heh, I just threw it out and used the Binary class. Easier, I guess. Thanks for the help.
01:37:27 <shachaf> kqr: I don't understand the question here.
01:37:40 <shachaf> You're using "a" as a value, so this doesn't look like a DataKinds situation.
01:37:55 <shachaf> If you always want "a" to be Make, why not write data Car = Car Make String Int?
01:38:38 <kqr> shachaf, because that doesn't give me type safety on car makes. i want "f :: Car a -> Car a -> g" to only compare cars of the same make, for example
01:38:59 <kqr> shachaf, i could do that with Left or whatever, but if I can get it statically checked that would be awesome
01:38:59 <shachaf> OK, so what are you using the value "a" for?
01:39:03 <kqr> nothing
01:39:06 <kqr> never mind that
01:39:10 <shachaf> OK, then it's phantom?
01:39:10 <kqr> i'm not sure why i thought that was a good idea
01:39:12 <ibotty> phantom type?
01:39:49 <kqr> that's the first time i hear that term, but it sounds about right
01:40:05 <shachaf> Then maybe DataKinds is what you want.
01:40:23 <shachaf> Of course, you can also do the same thing without DataKinds.
01:40:31 <shachaf> Well, sort of.
01:41:17 <kqr> how?
01:41:24 <kqr> or is it even something you want to do?
01:41:35 <ksf> it would allow you to write "overtakes :: Car BMW -> Car Ford -> Autobahn ()" and make sure Fords don't overtake BMWs.
01:41:52 <ksf> but you'd have to write data Car a = Car String Int
01:42:20 <kqr> data Car a = Car String int is perfectly acceptable
01:42:32 <ksf> or even data Car (a :: Make) = ...
01:42:33 <kqr> but how can i do it cleanly with type classes? or is DataKinds the way to go?
01:42:44 <ksf> DataKinds is the way to go, there.
01:43:12 <ksf> you might scatter the one or other ' onto your code, just as a heads-up
01:43:21 <ksf> Ford /= 'Ford
01:43:56 <kqr> right. one is a type and the other is a value?
01:44:13 <ksf> well forget that that was the wrong example. Make /= 'Make.
01:44:19 <ksf> the first is a type, the second a kind.
01:44:25 <kqr> aha
01:44:55 <ksf> sometimes ghc can infer what you mean, sometimes not.
01:45:19 <kqr> data Car (a :: Make) requires KindSignatures as well?
01:45:23 <ksf> yep
01:45:34 <divyansr> @index
01:45:34 <lambdabot> bzzt
01:45:37 <ksf> but it'll make sure that noone does things like Car Int
01:46:08 <divyansr> @index
01:46:08 <lambdabot> bzzt
01:46:17 <kqr> can't you put several language pragmas on one line separated by comma? like {-# LANGUAGE x,y,z #-}?
01:46:38 <ksf> divyansr, she's tasering you, you're not supposed to try it twice :)
01:46:58 <ksf> kqr, with or without commas I don't recall.
01:47:08 <ksf> I let vim do it and always get multiple LANGUAGE pragmas.
01:47:15 <ksf> easier to edit, too.
01:47:37 <kqr> well, either way i'm doing something wrong because i don't get it to work with separate lines either!
01:47:48 <wojtekM_> Is there a HashMap implementation, that would store values only once?
01:48:36 <ksf> wojtekM_, what do you mean by "only once"?
01:48:55 <ksf> there's always one value associated to any defined key.
01:49:17 <wojtekM_> ksf: real world, you know, memory usage
01:49:33 <ksf> the old value is forgotten when you overwrite it.
01:50:34 <wojtekM_> ksf: with (k1,v), (k2,v) use memory for v once
01:50:57 <ksf> oh, it does that if possible.
01:51:21 <ksf> it stores pointers to boxes, it doesn't copy stuff..
01:51:42 <wojtekM_> Right out of the box? I don't think so. values would have to be Ord, and they are not.
01:51:57 <tdammers> they would have to be Eq
01:52:29 <tdammers> but only if they are not the same object
01:52:32 <wojtekM_> tdammers: In practice Ord, with Eq you'd have to check them all for duplication
01:53:03 <ksf> there's a possible difference between let x = "foo" in insert x (insert x empty) and insert "foo" (insert "foo" empty, yes.
01:53:31 <divyansr> @help
01:53:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:53:37 <divyansr> @list
01:53:37 <lambdabot> What module?  Try @listmodules for some ideas.
01:55:14 <quchen> ksf: A semantic difference (which would surprise me), or are you just referring to the sharing in the first example?
01:55:26 <ksf> wojtekM_, I think you can build what you want to have reasonably fast with an additional Map.
01:55:37 <ksf> quchen, only sharing, yes. runtime semantics.
01:55:38 <tdammers> divyansr: you can /msg lambdabot
01:56:02 <wojtekM_> ksf: Yes, I think this is going to be a nice excersise.
01:56:21 <ibotty> is there a cleaner way to parse a complete bytestring with attoparsec then
01:56:31 <ibotty> > runIdentity . parseWith (return B.empty) rational $ "1.2" :: Result Rational
01:56:33 <lambdabot>   Not in scope: `parseWith'Not in scope: `B.empty'
01:56:33 <lambdabot>  Perhaps you meant one of ...
01:57:30 <divyansr> tdammers : Thanks :)
01:57:40 <ksf> ibotty, simpleParse p = runIdentity . parseWith (return B.empty) p
01:57:46 <wojtekM_> ksf: But I thought maybe there is a quality implementation alredy
01:57:58 <ksf> not that I know of
01:58:14 <ibotty> where is simpleParse defined? or is that just what i wrote?
01:58:16 <ibotty> :)
01:58:31 <ksf> ibotty, just write it yourself
01:58:47 <ibotty> ehm...  yeah, i kind of did.
01:58:52 <ibotty> thank you
01:58:53 <ibotty> :)
01:58:58 * hackagebot hpaco-lib 0.24.1.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.24.1.0 (TobiasDammers)
01:59:14 <ksf> wojtekM_, but then hackage got quite big and I guess I'm only pretending to have an idea of what's on there for at least two years now :)
02:00:12 <wojtekM_> ksf: yeah... Fortunately there is hayoo and hoogle
02:02:34 * ksf thinks he's missing something from the "Type Theory in Colour" paper, and that's colour.
02:06:20 <merijn> Ok, this is probably the wrong time to ask with everyone at ICFP, but here goes
02:06:50 <t7> ksf reading in black?
02:07:15 <merijn> I was reading about how the natural numbers are categories, with 0 being the category with no objects, 1 the category with the object 0 and the identity of 0, 2 the category with objects 0 and 1, a morphism from 0 to 1 and identities of 0 and 1
02:08:07 <merijn> My question is: why does the category 2 only have a morphism from 0 to 1 and not the other way around?
02:08:07 <ksf> t7, It's the only version I could get my hands on.
02:08:07 <t7> i pasted a colour PDF yesterday
02:08:13 <t7> in #-blah
02:09:12 <ksf> ahh,h I see.
02:09:22 <ksf> wait it's got no colour either.
02:09:42 <ksf> I *do* know that my okular can do colour.
02:11:21 <merijn> bleh, I knew all the category theorists were at ICFP >.>
02:11:38 <quchen> ICFP hasn't even started yet.
02:12:39 <ksf> too many papers to read, not enough videos online :)
02:14:47 <Taneb> ksf, there's one solution to that
02:15:02 <merijn> quchen: Doesn't mean people can't be there slacking off in Boston
02:15:11 <quchen> merijn: You can't map to 0 because there's nothing to map to in it? Something along those lines maybe?
02:15:20 <quchen> I'm a bad substitute for a category theorist
02:16:08 <merijn> quchen: 1 also doesn't have anything in it, it's an object, it doesn't contain anything
02:16:28 <jartur> Hello. Is there any way to call GHC as a library from, say, C? I am writing an IDE for Haskell (mostly for self-improvement now) and although I will be implementing type-inference on my own it would be awesome to be able to call GHC to do it for me later on.
02:16:45 <quchen> merijn: Well it contains that object for example.
02:16:50 <merijn> jartur: Well, there is GHC as a library and haskell has a C FFI, so yes
02:16:55 <quchen> And the identity of that object. That's hell of a lot more than 0 contains.
02:16:59 <ksf> jartur, you should get a fishing line.
02:17:11 <jartur> ksf: ?
02:17:12 <ksf> to use up all those worms that can is going to bring forth.
02:17:35 <merijn> jartur: In fact, it should be pretty simple to call GHC as a library from C.
02:18:10 <jartur> I am actually using JVM as a platform, so I will have to use JNI + GHC FFI
02:18:27 <jartur> With some glue code in C probably
02:18:54 <merijn> jartur: I have no experience with JNI, but in my experience calling haskell from C is pretty simple, so I wouldn't worry about that part
02:19:01 <jartur> Or maybe it would be interesting to write a GHC-interface server? Like gocode?
02:19:23 <jartur> So it can be reused by any projects from any language
02:19:33 <merijn> jartur: You might be interested in hdevtools? It runs a GHC server process and sends things to it using a unix socket to get type/error info
02:19:41 <jartur> Aha
02:19:51 <jartur> I knew there is something like that already
02:19:58 <merijn> jartur: https://github.com/bitc/hdevtools
02:20:23 <jartur> merijn: Thank you much, sir!
02:20:44 <jartur> That looks good
02:21:57 <jartur> The only downside is that I will probably be too lazy to implement type-checking myself now, so I will never get any deep understanding of the process and will forever be doomed to ignorance.
02:22:19 <merijn> jartur: Even that can be solved, you'll want Types and Programming Languages
02:22:22 <merijn> @where tapl
02:22:22 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:22:40 <jartur> I've read it. I have to do it again couple of times.
02:22:50 <jartur> But reading and implementing are two different things =)
02:22:52 <merijn> oh, then you're already way ahead of the curve :)
02:23:19 <merijn> You might wanna google for lambda pi? It's a tutorial on how to implement dependently typed lambda calc
02:23:58 <jartur> Hmm, sounds interesting. Dependent types are still beyond me (I get some of the ideas but not how to use them in practice)
02:24:02 <merijn> http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
02:24:20 <jartur> Cool, thank you.
02:24:52 <merijn> jartur: Conor McBride's thesis "Dependently Typed Functional Programs and their Proofs" is pretty interesting too
02:25:29 <jartur> I think I will still have a lot to do with Haskell's type system to write a decent IDE
02:25:38 <jartur> I mean a lot
02:25:56 <merijn> jartur: And while I'm throwing out recommendations, check out https://github.com/Peaker/lamdu
02:26:02 <jartur> So I will be able to concentrate on other parts instead of writing my own type checking
02:26:15 <jartur> Okay
02:26:22 <merijn> jartur: That might do all what you imagine a functional editor doing and possibly more ;)
02:26:36 <merijn> Well, except actually compile code, I guess
02:26:41 <merijn> But that's and implementation detail!
02:26:44 <jartur> It might, but it's may be a little too far
02:27:41 <jartur> I'm thinking of a more conventional approach.
02:27:54 <jartur> And as a plugin for IDEA actually.
02:28:18 <jartur> And I know there is one, but I want to learn to write IDEA plugins
02:28:21 <jartur> And some Haskell
02:28:24 <merijn> jartur: You should check it out anyway, it's cool! ;)
02:28:29 <jartur> Of course
02:28:31 <jartur> Thank you
02:28:59 <jartur> Maybe one day I will be smart enough to actually contribute to some project of actual value
02:29:17 <jartur> While still writing Java at work, hehe
02:35:52 <exicer> why in record syntax are things often called "runX" ?
02:35:59 <boothead> morning all. Is there a way to use cabal repl outside of the directory the .cabal file is in? I ran cabal sandbox --init a couple of directroies up?
02:37:05 <boothead> exicer, often this is done in the context of monad transformers, where you're kind of running each layer to get the next layer. it's just convention i think
02:37:19 <oddsignals> boothead: cabal-dev --sandbox=DIR ?
02:37:54 <mr-> exicer: with monads you sometimes build computations that you then run
02:38:00 <boothead> oddsignals, I'm using the new cabal sandbox stuff and that doesn't seem to work
02:38:37 <exicer> mr-:, boothead: Hmm okay. I don't really get monad transformers yet ;s
02:39:08 <mr-> exicer: it's not only transformers. Just look at the State monad
02:39:26 <exicer> Okay, will do
02:39:50 <boothead> exicer, they're just yolomorphisms in the category of turbofunctors. What's the problem?
02:39:57 <boothead> :-)
02:40:12 <rootnode> yolomorphisms? :D
02:40:32 <companion_cube> rootnode: do want!
02:41:07 <exicer> :p
02:41:08 <oddsignals> boothead: I see - haven't tried that yet, but according to help "cabal sandbox --sandbox=DIR" should work
02:41:10 <rootnode> yolomorphism: converting from Swag a to Swag b?
02:43:16 <boothead> oddsignals, that works, thanks!
02:44:34 <boothead> rootnode, I believe you actually go from a Swag a to a (Swag a, IO (PunchInTheFace b)). The semantics are unclear :-)
02:44:54 <rootnode> :D
02:46:12 <merijn> exicer: Because it lets you use runStateT (for example) to unpack
02:46:16 <merijn> :t runStateT
02:46:17 <lambdabot> StateT s m a -> s -> m (a, s)
02:52:40 <rootnode> states are still a bit of a mystery to me...
02:54:18 <merijn> rootnode: Do you understand how you can (conceptually) fake state in a function "a -> b" by making the function "(a, s) -> (b, s)" where s is the state?
02:54:31 <haasn> Is there some abstraction I can use for container-like things that I can merge? ie. something that has a Monoid instance and also a function that will give me a -> s
02:54:33 <haasn> for whatever that s is
02:54:40 <haasn> think ‘pure’ but with actual semantics
02:54:54 <rootnode> merijn: do you have some sort of small real world example? works better for me
02:55:34 <merijn> rootnode: Imagine 's' is a stack and you have a function "a -> b" that does something based on a stack
02:55:41 <merijn> (or should do something based on a stack)
02:55:42 <rootnode> ok
02:56:54 <merijn> i.e. something like "getElementAfter :: Eq a => a -> Maybe a" returns the element on the stack after the argument element, except there needs to be a stack somewhere, right?
02:57:01 <ksf> \o/ I got rid of a type signature!
02:57:13 <merijn> So you could write it "getElementAfter :: Eq a => (a, Stack) -> (Maybe a, Stack)"
02:57:21 <jartur> rootnode: fWithCounter (x, c) = (if isOdd c then something x else other x, c + 1)
02:57:40 <merijn> (although I can't continue this explanation, I have an appointment in a few mins)
02:58:05 <rootnode> thanks anyways, got me a lot further than before
02:58:56 <merijn> rootnode: The "State s" monad is basicall a monad that hides the extra input argument and extra output argument (of type 's') for you and takes care of passing it from function to function
02:59:04 * hackagebot amqp 0.6.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.6.0 (HolgerReinhardt)
02:59:26 <merijn> rootnode: It can be very enlightening to try and implement it yourself
03:00:00 <merijn> rootnode: Just use "data MyState s a = MyState (s -> (a, s))" and try to implement "instance Monad (MyState s) where return = ??; (>>=) = ??"
03:00:13 <wojtekM_> Is it possible to override hidden status for package? I need to import Data.Set.Base
03:00:14 <haasn> Hmm in particular I want to try and generalize ‘nub’ to different constraints, eg. Eq, Ord and Hashable; I could do it by overloading on [a], Set a and HashSet a -- if I had some common abstraction for them
03:00:15 <wojtekM_> ?
03:00:24 <merijn> "return :: a -> MyState s a"
03:00:42 <merijn> "(>>=) :: MyState s a -> (a -> MyState s b) -> MyState s b"
03:03:08 <merijn> rootnode: I think there's only one way (not counting undefined, etc.) to define return in a way that typechecks and I think there's only like 2 or 3 ways to implement >>= only one of which makes sense :)
03:03:25 <rootnode> thanks, will try it
03:03:37 <quchen> merijn: For what?
03:03:38 <quchen> State?
03:03:43 <merijn> If you get stuck probably someone else here can help
03:03:45 <merijn> quchen: Yeah
03:04:12 <eevar> how do I collect 100 values from getData :: IO Int that satisfy myFilter :: Int -> Bool ?
03:04:19 <quchen> merijn: I agree that reverse state doesn't make much sense (but it's interesting)
03:05:23 <quchen> eevar: take 100 . filter myFilter <$> repeatM getData -- something along those lines
03:06:22 <quchen> repeatM won't work well for IO though I think. If it doesn't use explicit recursion ("get new number, add to result if it's a good number)
03:10:24 <Flonk> > 4
03:10:43 <lambdabot>   4
03:11:03 <Flonk> Whew, thought I broke lambdabot there for a second
03:11:47 <chrisdone> > fix fix
03:12:02 <chrisdone> that should fix it
03:12:25 <quchen> inb4 fix error
03:12:33 <Flonk> :D
03:12:51 <lambdabot>   can't find file: L.hs
03:12:58 <merijn> eevar: monad-loops!
03:13:01 <merijn> @hackage monad-loops
03:13:01 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:13:13 <merijn> eevar: Thank me later
03:14:05 <quchen> Or use monad-loops! :-)
03:14:06 <merijn> quchen: Shame on you for not mentioning monad-loops!
03:14:34 * quchen is *very* ashamed
03:14:40 <eevar> thanks guys
03:16:08 <Flonk> Haskell continues to blow my mind every day
03:16:26 <Flonk> Just when you thought you kind of got the hang with Applicative, @pl comes up with this: (<*>) =<< ([(,)] <*>)
03:16:34 <Flonk> And I have no idea what's going on
03:16:52 <quicksilver> I think you're playing an ascii art version of star trek
03:16:55 <quicksilver> does that help?
03:17:37 <Flonk> I'm not sure
03:17:44 <rootnode> generating a list of tuples (a,a) from a list of a's?...
03:18:02 <Flonk> rootnode: yup
03:18:15 <quchen> rootnode: Depends on how you want to create the tuples.
03:18:27 <quchen> :t map (\x → (x,x))
03:18:28 <lambdabot> lexical error at character '\134'
03:18:32 <quchen> :t map (\x -> (x,x))
03:18:33 <lambdabot> [t] -> [(t, t)]
03:19:01 <danr> > ((map snd *** map snd) . partition (even . fst) . zip [0..]) "aoeuidhtns"
03:19:02 <lambdabot>   ("aeihn","oudts")
03:19:05 <quchen> :t zip`ap`tail
03:19:06 <lambdabot> [b] -> [(b, b)]
03:19:15 <danr> wait, that's not the one I thought of :P
03:19:22 <kqr> :t map (join (,))
03:19:23 <lambdabot> [a] -> [(a, a)]
03:20:31 <chrisdone> ReinH: request for podcast special guests: don't interrupt them please =)
03:20:54 <quchen> chrisdone: That was mentioned in the Reddit comments already
03:21:02 <chrisdone> good
03:22:18 <chrisdone> reddit isn't serving pages for me, god must be doing an AMA or something
03:23:05 <quchen> God is always doing an AMA. It's called prayer, and like every other AMA, noting good comes from it.
03:23:25 <rootnode> God's AMA: "I'm retiring, edward is taking over"
03:23:25 <kqr> seconded. i felt the pacing of the first episode was great but dons was hurried along way too much
03:23:57 <rootnode> only thing he needs is a lens for the universe
03:25:40 <haasn> Oh, there's a new episode of the haskell podcast?
03:25:55 <kqr> haasn, as per yesterday i believe
03:26:11 <quchen> With video this time!
03:26:17 <quchen> http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/
03:26:20 <haasn> With video? The other one had video!
03:26:22 <kqr> there was video the last time as well
03:26:25 <rootnode> yup, listened to it on my way back from work today
03:26:37 <haasn> Ugh, my backlog is growing exponentially ;; I'll have to sleep before watching it
03:26:39 <kqr> only it was marked private on youtube for a while after release
03:26:42 <quchen> Oh, I didn't see the video the first time!
03:27:09 <SrPx> What is up with the Haskell community it is so good in comparison to everything else?
03:27:18 <quchen> Wait, who is this person with Edwardk's face there
03:27:55 <rootnode> suddenly, chuck testa
03:27:55 <kqr> SrPx, we are made of love and fluffy teddy bear stuffing
03:27:56 <chrisdone> every time rein interrupts dons i'm all  ლ(ಠ益ಠლ)
03:27:58 <kqr> SrPx, that's how!
03:28:16 <SrPx> ok that makes sense for me
03:29:28 * haasn is scared of watching it now, with all of these negative comments ;;
03:29:51 <quchen> haasn: I don't think it's as bad as chrisd makes it sound.
03:29:52 <chrisdone> oh god damn
03:29:55 <chrisdone> i can't listen to this
03:29:59 <quchen> ಠ_ಠ
03:30:31 <haasn> quchen: but all the potential information! just.. lost
03:30:33 <haasn> due to interruptions
03:30:41 <haasn> It sounds scary!
03:30:43 <chrisdone> seriously, either have a conversation, or interview. don't ask questions like an interview and then interrupt him when he's mid-sentence
03:31:22 <rootnode> it was quite nice to listen to
03:31:25 <chrisdone> haasn: lost… like tears… in… rain
03:31:45 <quicksilver> not lost! the potential is still there in don's brain
03:31:53 <quchen> chrisdone: Is the second half worse? I only listened to it up until around 35 mins
03:31:53 <haasn> chrisdone: lost like questions in an obscure IRC buffer everybody has detached..
03:31:54 <quicksilver> someone grab him and remove the top of his skull, quick
03:32:26 <haasn> Oh god.
03:32:32 * haasn makes a mental note to cycle through all his idle buffers regularly
03:32:47 <chrisdone> quchen: i'm 50% through and now every time dons gets interrupted i get agitated. i'll wait for the next podcast
03:32:49 <quchen> quicksilver: Careful, the uncertainty principle applies to dons' brain: if you observe it you alter its state :-(
03:32:57 <quchen> Damn you macroscopic quantum principles!
03:34:05 * hackagebot packed-dawg 0.2.0.0 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.0 (AndrasKovacs)
03:34:18 <merijn> Flonk: For what it's worth, I can't figure out what "(<*>) =<< ([(,)] <*>)" does either
03:34:34 <merijn> Flonk: Well, I mean, not without manually expanding things t see what's going on
03:34:36 <Lethalman> :t do x <- (,); x
03:34:36 <lambdabot> a -> (a, a)
03:34:38 * Lethalman confused
03:34:42 <Lethalman> is that -> monad?
03:35:02 <Flonk> merijn: Well, that's kind of comforting I guess!
03:35:13 <merijn> @undo do { x <- (,); x }
03:35:13 <lambdabot> (,) >>= \ x -> x
03:35:30 <Flonk> merijn: (crossproduct of a set with itself)
03:35:50 <merijn> Which is "(,) >>= id" and "x >>= id" is "join x"
03:35:59 <merijn> :t join
03:36:00 <lambdabot> Monad m => m (m a) -> m a
03:36:07 <merijn> :t join (,)
03:36:08 <lambdabot> a -> (a, a)
03:36:24 <merijn> So there you go, it's just join on the "(->) r" monad
03:37:14 <merijn> For some values of "just"
03:37:51 <DMcGill> What's the difference between primitive vectors and unboxed ones? It looks like the code for Primitive just calls all the code for Unboxed.
03:38:02 <Lethalman> merijn, so I'm confused on how the (->) monad behaves
03:38:06 <merijn> Flonk: Expressions like the earlier one are really just for code golfing/obfuscation no one writes code like that for reall
03:38:14 <merijn> Lethalman: It's Reader :)
03:38:20 <Lethalman> :t (,)
03:38:22 <lambdabot> a -> b -> (a, b)
03:38:24 <merijn> Flonk: And if they do, fire/lynch them :)
03:38:26 <Lethalman> :t (,) >>= id
03:38:27 <lambdabot> a -> (a, a)
03:39:03 <merijn> Lethalman: "(>>=) :: (->) r a -> (a -> ((->) r b) -> (->) r b
03:39:17 <merijn> (r -> a) -> (a -> r -> b) -> r -> b
03:39:34 <merijn> join :: (r -> r -> a) -> r -> a
03:40:22 <Lethalman> somehow understand, it's a little hard to grasp
03:40:41 <Lethalman> I mean to get the head around it
03:40:57 <ksf> flip map  [fLeft +: "left", fRight +: 1] (`match` ((fLeft *= length) .*. (fRight *= (+1))))  <-- evaluates to [4,2] without any type sigs
03:41:02 <ksf> I think I'm getting somewhere here.
03:41:48 <ksf> the bad news is, to develop further I think I need an example application, and I have one, but I need to parse xml for that.
03:42:06 <ksf> which necessitates xml-conduit, which doesn't build with 7.7
03:42:29 <ksf> or rather, unordered-containers doesn't.
03:51:47 <nominolo> wagle: what kind of example are you looking for?
03:58:04 <DMcGill> what's the best way to fold over a MVector? Both for pure and impure operations. There's always `forM_ (range (bounds arr)) onElement'
04:00:15 <DMcGill> actually that won't work. "forM_ (range (bounds arr)) $ \i -> onIndex (index (bounds arr) i)" should be better since Vectors are only indexed by Ints,
04:05:19 <isomorphic> What might cause ghc to generate errors on multiple line {-# LANGUAGE pragmas?   I thought it might be a ghc version thing - but I'm using 7.6.3 and the code appears to be compilable by 7.0.1
04:07:03 <ksf> wrong line endings?
04:07:09 <ksf> @paste
04:07:09 <lambdabot> Haskell pastebin: http://lpaste.net/
04:07:47 <isomorphic> ksf:  Possibly.  But unlikely.  An example that breaks is cabal install monad-control … :/
04:07:50 <ocharles> mmathis: is
04:07:52 <ocharles> erm
04:08:03 <isomorphic> So i suspect it's something peculiar to my configuration
04:08:05 <ocharles> mm_freak: is the ommision of integral1 in netwire 5 intentional, or simply because it's not written?
04:09:51 <monoidal> isomorphic: cabal install monad-control works for me, both 7.6 and HEAD
04:10:28 <isomorphic> monoidal:  Thanks.  Something messed up on mine ;)
04:18:32 <exicer> someone please tell me that as you understand more monads, it becomes easier to understand new monads ;s
04:18:49 <exicer> I've spent the past hour looking at the state monad, and I'm not even sure I get it ;s
04:18:56 <ocharles> exicer: how are you looking at it?
04:19:03 <ocharles> The best way to learn about a monad is to implement it yourself
04:19:16 <ocharles> so - write the data type yourself, then close the book, and write the monad instance yourself
04:19:18 <exicer> I have been working through https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
04:19:23 <ocharles> not copying code - trying to do it yourself
04:19:46 <ocharles> and also, it's worth writing things in the monad, and then replacing (>>=) by its actual definition
04:19:47 <exicer> I suppose I could give that a go..
04:19:55 <ocharles> that can help you understand what >>= is really doing
04:20:09 <exicer> yeah, to be honest that is the main problem
04:20:10 <ocharles> just like how you don't learn maths by reading equations, you don't learn haskell by reading monads
04:20:17 <int-e> > flip runState 1 $ do it <- get; put (it+1)
04:20:18 <lambdabot>   ((),2)
04:20:29 <exicer> int-e: Oh, but of course ;p
04:20:33 <ziman> I found myself writing a retry monad; is there something similar in the stdlib? http://lpaste.net/93336
04:20:42 <ziman> if I understand correctly, I can't do IO in STM
04:21:07 <opqdonut> that's kinda the point
04:21:08 <int-e> ziman: not safely anyway.
04:22:37 <ziman> int-e, well, yes, but my understanding is that I shouldn't, anyway
04:23:31 <hpc> ziman: usually when you find that you can't do something in haskell, you also shouldn't be doing it ;)
04:24:05 <Chousuke> Or you should be writing a paper on how it's done :P
04:25:15 <ziman> especially when you can rewrap an error monad to do the work cleanly ;)
04:25:19 <int-e> ziman: right. http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc-Sync.html#v:unsafeIOToSTM lists several reasons why
04:26:28 <int-e> ziman: the right thing to do is to run something 'atomically' and evaluate its result (which may, for example, be an IO action, so the approach is quite versatile)
04:28:44 <quicksilver> although, it would be useful to be able to add primitives to STM - IO actions with an attached 'rollback' action to be used when appropraite.
04:28:50 <ziman> my program is a http downloader, which is (simplifying) a do-block in which, at several places (in case-expressions and the like), the program may decide to retry the download
04:29:17 * hackagebot ac-machine 0.2.0.2 - Aho-Corasick string matching algorithm in Haskell  http://hackage.haskell.org/package/ac-machine-0.2.0.2 (YutaTaniguchi)
04:30:06 <ziman> which is a bit inconvenient to refactor into the form "return content to continue or error to retry"
04:39:18 <DMcGill> Does anybody have a link to Conor McBride's article about using triples of triples to represent sudoku puzzles?
04:52:42 <ocharles> mm_freak: bah, I can't get 'rec' to work with collision detection. I always end up with one frame passing collisions, and the next frame showing the collisions
04:52:54 <ocharles> I can't work out how to only output the fixed version
04:52:56 <ocharles> darn arrow loops
04:55:48 <ocharles> I mean, why it does that makes sense - it seems I'm trying to do two steps at a single instant - one step to apply velocity, and then another step to correct for collisions - so the second time is a delta of 0 seconds
05:07:14 <ibotty> is someone in contact with jon fairbairne (or is he even here)?
05:12:34 <merijn> Right, maybe there's a bit more category theory people around now, so let's try my question again
05:13:02 <merijn> I was reading about how the natural numbers are categories, with 0 being the category with no objects, 1 the category with the object 0 and the identity of 0, 2 the category with objects 0 and 1, a morphism from 0 to 1 and identities of 0 and 1
05:13:26 <merijn> My question is: Why does the category 2 only have a morphism 0 to 1 and not 1 to 0 too?
05:13:55 <Cale> merijn: There are a bunch of variations on 2 :)
05:13:56 <notdan> merijn: well I guess it's because we also want it to be the orer category
05:13:57 <notdan> order*
05:14:06 <pcapriotti> merijn: because it's common to think of 2 as a finite ordinal, and then regard it as a category
05:14:20 <Cale> But if it had an arrow from 1 to 0, then it would make 0 and 1 isomorphic, which usually isn't what you want.
05:14:43 <notdan> oh, I haven't thought of that
05:14:45 <merijn> Cale: Right, so basically the answer is "because that was the one arbitrarily picked by the presenter out of all possible categorisations of the natural numbers"?
05:14:47 <pcapriotti> another way to think of natural numbers as categories is to think of them as discrete categories (i.e. with no non-identity arrows at all)
05:14:49 <notdan> nice, Cale :)
05:15:25 <pcapriotti> merijn: yeah, but it's a very common one
05:15:35 <pcapriotti> it's useful, for example, when dealing with simplicial sets
05:15:39 <merijn> pcapriotti: I only just started reading Awodey (like, I'm at page 5) and only got a few basics before that, so that's not too helpful an observation for me (the discrete categories bit)
05:16:03 <pcapriotti> merijn: hm?
05:16:13 <exFalso1> Hi, is there any reason why (ResourceT m) doesnt have a MonadFix instance?
05:16:17 <Cale> merijn: Yeah. For any set X, there's always the discrete category on X which just has the identity arrows and no others, and the indiscrete category on X which has exactly one arrow between every pair of objects (in each direction), making all the objects isomorphic to each other.
05:16:22 <merijn> pcapriotti: That I don't know what a "discrete category" is :)
05:16:28 <pcapriotti> I explained what discrete means, it's just a category without any non-identity arrows
05:16:50 <merijn> pcapriotti: oh, I missed that.
05:16:51 <Cale> merijn: and then if X is (pre-)ordered in any other way, then you can define which arrows exist based on the ordering
05:17:02 <merijn> pcapriotti: That's not a particular interesting category, though, is it?
05:17:13 <Cale> merijn: In this case, we're thinking of 2 the ordinal, as pcapriotti pointed out
05:17:13 <pcapriotti> merijn: well, it depends
05:17:33 <pcapriotti> sometimes, it's useful to think of sets (without any structure) as categories
05:17:35 <Cale> merijn: It's boring but useful
05:17:36 <merijn> Of course, it always does ;)
05:18:01 <pcapriotti> in that case, regarding them as discrete categories is one of essentially two options
05:18:15 <pcapriotti> the other one is indiscrete categories, as Cale mentioned
05:18:47 <merijn> Anyhoo, that answers my question, then
05:19:00 <Cale> merijn: If X is a set, then a preorder <= is a relation on X which is reflexive and transitive, i.e. for any a in X, a <= a and for any a, b, c in X, if a <= b and b <= c then a <= c.
05:19:29 <merijn> Relatedly, the phrasing "unique up to isomorphism" just means "things are unique, but some of the might behave in a convertible way", right?
05:19:35 <Cale> merijn: Given a preordered set (X,<=), we can define a category whose objects are the elements of X, and where there is an arrow a -> b exactly when a <= b.
05:19:59 <Cale> merijn: It means that any two solutions are isomorphic to each other.
05:20:14 <Cale> (usually in a canonical or unique way)
05:20:23 <merijn> right
05:21:28 <exFalso1> ah now is the opportunity: Cale do you know of any good resources on adjoints? just looking at the definition is not very hepful:)
05:21:50 <Cale> sure...
05:21:58 <Cale> exFalso1: Do you have Awodey's book?
05:22:22 <Cale> There are a bunch of good videos on YouTube by the Catsters
05:22:22 <exFalso1> Cale: heard of it
05:22:55 <Cale> (sent you a link in PM)
05:23:24 <Cale> http://www.youtube.com/user/TheCatsters -- these guys have lots of good short videos on many categorical topics
05:23:33 <rootnode> nice
05:23:38 <exFalso1> thank you that helps!
05:23:52 <Cale> Also, there's a short lecture series I want to link... let me dig it up
05:25:14 <Cale> http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html -- the "Category theory foundations" lectures
05:26:19 <Cale> He takes a bit of a different approach to introducing category theory there than I've seen elsewhere, it's sort of tuned for CS people, and takes a beeline for stuff which is relevant to PL semantics and categorical logic.
05:26:56 <kognitiva> Hello
05:27:02 <Cale> hello
05:27:07 <kognitiva> you pro?
05:27:13 <kognitiva> @haskell :P?
05:27:13 <lambdabot> http://www.haskellers.com/
05:27:35 <exFalso1> Cale: that whole curriculum looks very interesting
05:28:52 <Cale> But yeah, his explanation of adjoints there is pretty good.
05:30:46 <Cale> kognitiva: I am actually a professional Haskeller, as it happens :)
05:31:04 <Cale> kognitiva: I'm working for skedge.me on their web application backend in Haskell.
05:34:20 <t7> i thought you made vidya games ?
05:34:35 <merijn> t7: The game is on hiatus due to lack of funding, I believe
05:34:41 <Cale> That's right
05:35:42 <Cale> I'm working for the same guy as before (Ryan Trinkle) but the pay is a good deal better.
05:36:06 <Cale> (but the work is a little less fun)
05:36:23 <gienah> \o/
05:36:33 <gienah> oops wrong channel sorry
05:37:35 <tobygoodwin> aaarrgh! cabal has screwed me over yet again
05:38:12 <tobygoodwin> i've got code to write, but now i need to spend *hours* trying to work out why cabal has decided my package is impossible today
05:38:31 <ocharles> Cale: woah, I had no idea all the summer schools were recorded
05:38:36 <ocharles> that's awesome
05:38:39 <merijn> tobygoodwin: Try using cabal's new sandbox stuff?
05:38:58 <tobygoodwin> i'm using cabal-dev, but somehow i've confused that too
05:39:00 <Cale> tobygoodwin: Maybe try with -v or something?
05:42:40 <applicativ_> tobygoodwin: what are you building, something with 100 dependencies?
05:43:20 <tobygoodwin> yeah, it's got quite a few - it's a yesod app
05:43:55 <tobygoodwin> cabal has decided it needs an ancient version of http-wget, which fails to build
05:43:57 <applicativ_> tobygoodwin: but the project built before?
05:44:24 <hiji> hi all, I'm relatively new to Haskell (haven't grokked monads, if that is any indicator) and I want to learn to write a computer vision library like OpenCV in Haskell. I know it makes no sense reinventing the wheel, but I want to get a good feel for repa and parallel processing. Any pointers/suggestions?
05:45:01 <tobygoodwin> yeah, it was working fine a day or two ago
05:45:33 <merijn> hiji: Don't worry about "grokking monads", you should focus on understanding types and typeclasses and monads will be obvious. IMO most of the confusion comes from people being obsessed with monads without properly learning types/typeclasses
05:45:34 <applicativ_> hiji: http://chimera.labs.oreilly.com/books/1230000000929/ch05.html and surrounding material
05:45:45 <AfC> hiji: Haskell has a steep learning curve. You might consider finding something small and achievable to work on to develop some [pragmatic] skills first.
05:46:01 * applicativ_ totally groks monads; lot of good it's done him....
05:46:11 <AfC> heh
05:46:34 <bgamari> tobygoodwin, highlight-versions is nice
05:47:35 <tobygoodwin> here's where i'm at at the moment: http://lpaste.net/93341
05:47:47 <hiji> yes, I saw the oreilly book, but don't understand yet how it works with repa
05:48:19 <tobygoodwin> bgamari: thanks for the tip
05:48:28 <hiji> I am of the understanding that I must have a grasp of repa to first load images etc. and do simple operations (eg. thresholding) on them
05:48:44 <tobygoodwin> if only cabal could build it... :-( oh, ok, cabal-dev can
05:49:06 <applicativ_> hiji: there are more convenient ways of 'loading images' of standard sorts, yes
05:49:25 <boothead> First foray into prisms, and it seems I don't understand what's going on!
05:49:26 <bgamari> tobygoodwin, But, yeah, typically if I want to get a package building I'll use cabal install -v3 --dry-run
05:49:37 <applicativ_> tobygoodwin: maybe you should 'cabal sandbox hc-pkg unregister xxxx' for some stuff in your sandbox
05:49:42 <bgamari> tobygoodwin, the output isn't so great
05:49:49 <applicativ_> oh he pasted
05:50:04 <bgamari> tobygoodwin, but all of the information you need to deduce the issue is there
05:50:05 <kognitiva> can someoen take a look at my code?
05:50:11 <kognitiva> its just like 5 lines
05:50:19 <hiji> applicativ_, how would I go about doing that and what type will the data be stored as?
05:50:23 <kognitiva> http://lpaste.net/93335
05:50:25 <bgamari> kognitiva, feel free to hpast it
05:50:27 <bgamari> ahh
05:50:36 <kognitiva> thanks bgamari
05:50:38 <kognitiva> : )
05:50:45 <applicativ_> hiji see juicy-pixels and if you are interested in repa  juicypixels repa
05:51:13 <bgamari> kognitiva, Is there something wrong with it or are you just seeking feedback?
05:51:13 <lamefun> can I define record first and make unions later, eg. define Ellipse, Circle, Polygon and then SmoothShape = Ellipse | Circle, Shape = Ellipse | Circle | Polygon?
05:51:23 <boothead> given _last_event :: Maybe X where X has a _timestamp :: UTCTime, why can I not do  "last_event . _Just . timestamp" I'd expect that to got from the type that has a last_event to a Maybe UTCTime, but it compains that UTCTime isn't a Monoid?
05:51:31 <Cale> lamefun: You'll have to name the data constructors
05:51:33 <bgamari> lamefun, you'd need to define a data constructor for each type
05:51:36 <applicativ_> lamefun: not just like that, no
05:51:57 <hiji> AfC, sorry I just saw your comment about starting with something more achievable. Why do you think a basic compvis library would be hard? I'm just aiming for image operations and filters at first
05:52:01 <kognitiva> bgamari:  I cant get it to compile. theres somethign wrong : )
05:52:04 <lamefun> Why not?
05:52:11 <bgamari> kognitiva, Let me try
05:52:30 <applicativ_> tobygoodwin: there's a lot of stuff you have two version of
05:52:38 <Cale> If you wrote that as-is, you'd get a complaint that you'd defined Ellipse more than once, because you'd have defined SmoothShape and Shape as simple enumeration types, and the names of their data constructors overlap, which isn't allowed.
05:53:06 <bgamari> kognitiva, I see, you need to align the body of the do block after the end of the "do" keyword
05:53:26 <bgamari> kognitiva, or move the first putStrLn onto a new lie
05:53:35 <Cale> kognitiva: The first non-whitespace character after 'do' sets the column which the block is aligned to
05:53:39 <bgamari> kognitiva, Haskell is a bit alignment sensitive
05:53:55 <lamefun> Can I use an element of a union all by itself, eg. Shape = Ellipse | Polygon   and then function :: Polygon -> ...?
05:53:57 <applicativ_> tobygoodwin: clearly, you need to do ghc-pkg unregister transformers-0.2.2.0 ; this will of course tell you what might break first
05:53:58 <kognitiva> bgamari, ok thanks
05:54:00 <kognitiva> thanks both of you : )
05:54:13 <merijn> lamefun: No, that's not possible
05:54:16 <bgamari> kognitiva, also, you might be surprised by the behavior of that code
05:54:24 * hackagebot hlint 1.8.52 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.52 (NeilMitchell)
05:55:06 <kognitiva> darn I'm at a lecture thanks all I should have waited til I got home with this : P but thanks bgamari : )
05:55:12 <lamefun> Why not, I think haskell would be much nicer if it could do that.
05:55:13 <kognitiva> :P
05:55:14 <bgamari> kognitiva, heh, fair enough
05:55:22 <bgamari> I won't tempt you any further
05:55:31 <kognitiva> ^^d
05:55:32 <AfC> hiji: the application may not be hard, but it takes a bit of doing to be productive in Haskell. I'd encourage you to get comfortable with coding a bit on something a little less critical before embarking on The One True Thing that you need
05:55:52 <merijn> lamefun: Oh, I agree and so do many others, which is why dependently typed languages exist :)
05:56:36 <merijn> lamefun: You can kinda/sorta fake it using GADTs and DataKinds (which lets you encode the union on the type level), but it's a bit painful, unlike in dependently typed languages where it's much easier to do this sort of thing
05:57:49 * applicativ_ was about to say something about a question merijn asked last night, but notice then that it was last night
05:57:55 <jophish> Yo yo yo
05:58:01 <hiji> AfC: I tried working through the exercises in Programming in Haskell, but I got bored of trying to concatenate lists with recursion etc. I keep wondering when I will get to the meat of Haskell.
05:58:44 <merijn> lamefun: btw, to get back to your original question of defining unions of existing types, you can create heterogeneous lists (with some extensions) which kinda let you do that. But whether you *should* depends on what you're doing
05:58:48 <applicativ_> hiji: oh, use ++ to concatenate lists, then you'll really be in the meat of it ;)
05:59:10 <merijn> lamefun: If your learning/exploring it'll be a useful and interesting exercise, if you're doing something practical, you probably shouldn't
05:59:17 <jophish> I've written a little program to find the distance between vocabulary histograms in different texts. the usage is ./words hamlet.txt romeo.txt winters.txt. I was hoping that some people here could take a quick look and point out anything which isn't idiomatic Haskell, I'm still a little new to this.
05:59:22 <jophish> The code is here: http://lpaste.net/93342
06:00:04 <jophish> The performance isn't great, I've profiled and most of the time (90%) is in Map.unionWith, Using Data.HashMap makes it a little slower
06:00:06 <hiji> applicativ_: haha :D How important is it to learn how to solve every problem with recursion? Can I not just get away with using higher order functions in Real Life TM?
06:00:35 <lamefun> what's a dependently typed language?
06:00:39 <applicativ_> hiji: half the point of haskell is to spare us writing explicit recursive definitions
06:00:46 <merijn> hiji: Oh, sure, you should use higher order functions
06:00:59 <merijn> hiji: The problem is, that it's hard to callibrate the difficulty on these teaching books
06:00:59 <Cale> lamefun: One in which you have types that depend on values.
06:01:17 <merijn> hiji: Some people have unbelievable difficulty with basic recursion
06:01:18 <applicativ_> lamefun: one where families of types are indexed by values of another
06:01:28 <merijn> hiji: Other people see it once and go like "oh, that's really easy"
06:01:37 <Cale> lamefun: In Haskell, we can have types parameterised by other types, but not types which are parameterised on values of a given type.
06:01:46 <hiji> merijn: Well I saw it and thought it was easy but still do get stuck sometimes
06:01:47 <merijn> hiji: If you feel the exercises are more boring than interesting, just skip exercises until you reach something challenging
06:02:06 <applicativ_> lamefun: thus to use the tedious textbook example Vector-of-length-n of a's is a family of types over the natural numbers
06:02:25 <merijn> hiji: Ah, but that's exactly where you wanna practice then. Not so much because you want/have to write the explicit recursion. But as practice in thinking about how to decompose using recursion
06:02:28 <lamefun> I don't see how unions are this
06:02:53 <AfC> hiji: so forget exercises, and do something real. For example, parse some interesting blob of JSON you mined out of a web service somewhere.
06:02:53 <jophish> The text is of the format found here: http://www.textfiles.com/etext/AUTHORS/SHAKESPEARE/ stage directions in square brackets, names in uppercase.
06:03:08 <Cale> lamefun: They're not...
06:03:11 <merijn> lamefun: In dependent types you can have types depend on values. You can write functions where the return type is different, depending on whether the argument is 2 or 3
06:03:31 <merijn> lamefun: Or whether the argument is a Rectangle or Circle constructor
06:03:42 <Cale> lamefun: But to get to your original question, the reason we don't have arbitrary union types is because they break type inference (or make it exponential-time in the common case)
06:03:47 <merijn> lamefun: This means it also lets you define types that only accept Circle constructors as argument
06:04:21 <merijn> lamefun: In haskell the types can't inspect the *value* of an argument, so it's possible to write a type that inspect whether the argument is a Circle
06:04:24 * hackagebot hlint 1.8.53 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.53 (NeilMitchell)
06:04:26 <Cale> lamefun: Same goes for subtyping.
06:04:39 <hiji> AfC: Yes, that should be a good start. I will mix what merijn said and parse json with a recursive function (parsec?) Thanks for the tips :)
06:04:39 <merijn> lamefun: But in dependently typed languages types like that *are* allowed
06:05:00 <merijn> hiji: Parsec is pretty neat for parsing. Real World Haskell has a chapter on it
06:05:21 <AfC> hiji: no no, don't try and do it yourself from first principles; learn how to use something called Aeson
06:05:36 <merijn> hiji: It's slightly out of date (it covers Parsec 2, instead of 3), but the general idea and most of the example code is still ok
06:05:55 <merijn> AfC: I disagree, I think implementing parser is one of the best "first real projects" to do
06:06:05 <AfC> merijn: {groan}
06:06:15 <hiji> AfC, merijn: why?
06:06:15 <merijn> Parsing is much nicer than haskell than in other languages. It shows of one of Haskell's strengths
06:06:40 <Cale> Well, yeah, you can do lots of subtyping-like things with dependent types, but then you also lose type inference.
06:07:17 <merijn> hiji: Aeson is a high speed existing json parser. I agree that you should use aeson if you want to write "real code" that works with json. But in terms of "seeing a good example that illustrates haskell's strengths", I think implementing a parser is a good project
06:07:22 <Cale> Haskell has been sort of developing in the direction of being dependently typed, while trying to maintain as much as possible type inference for anything not-too-fancily-typed.
06:07:33 <merijn> hiji: And if you implement a parser, why not for json if you're familiar with json
06:07:52 <hiji> merijn, I'm already familiar with json, yes.
06:08:19 <AfC> hiji: anyway, my point was go learn something about what it's like to do *pragmatic* development in Haskell, which is as much about figuring out how to build code, use others' libraries, and navigate documentation as anything else. Once you're feeling comfortable there you'll be better equipped to return to working with (say) an OpenCV binding.
06:08:36 <merijn> hiji: I suspect AfC objects to implementing a json parser out of a "don't reinvent the wheel" principle
06:08:49 <merijn> AfC: And implementing parsers is not pragmatic?
06:09:15 <merijn> 70% of the haskell code I wrote in the past month was parsing!
06:09:23 <hiji> merijn: while you support it because it gives one a chance to get familiar with the fundamentals of the Haskell way of thinking.
06:09:39 <AfC> merijn: more that you will learn from studying (via attempting to use) the work of experienced programmers rather than bumbling around making basic mistakes in classroom example settings.
06:09:56 <tobygoodwin> ok, i now have a cabal that does sandboxes, which is nice
06:10:08 <merijn> hiji: Yes
06:10:16 <tobygoodwin> highlight-versions doesn't seem to do anything :-(
06:10:34 <hiji> merijn, AfC: dammit you both sound correct :D
06:11:52 <merijn> hiji: It's a matter of personal preference :) I believe one of the major challenges is that you have 1) a completely new language/way of doing things and 2) then *also* have to learn a bunch of more advanced style/design approaches used in "real" libraries, people can get overwhelmed by doing both at once
06:13:00 <merijn> hiji: Essentially, AfC recommends diving into pragmatic code in order to get productive fast, at the cost of potentially getting overwhelmed and confused. My personal recommendation is to focus on the basics and get comfortable there before moving on to more advanced things, at the cost of making you feel unproductive/unable to write real/production code
06:13:09 <t7> is oauth good?
06:13:31 <merijn> hiji: In the end, you should pick the approach that you feel suits you best and will lead to the least amount of frustration
06:13:31 <AfC> merijn: I agree with that
06:14:14 <hiji> merijn, AfC: Thanks a lot! I'll experiment a bit and find out :)
06:14:37 <AfC> hiji: by all means spend as much time as you can on the basics. Just be aware that there is a large gulf between what merijn is describing and writing pragmatic performant industrial day to day code. At some point you will have to make that jump, and it's not easy.
06:15:13 <bartavelle> not easy but much more motivating than writing toy programs
06:15:50 <AfC> [and my guess is that using a library like OpenCV would fall into that category; unfortunately a lot of Haskell libraries are written to the assumption that the user already knows what they're doing. So the art of Figuring Out What The Fuck takes a bit of fine tuning]
06:16:35 <merijn> AfC: True, but being comfortable with types/typeclasses and higher order code helps the jump, I think :)
06:16:50 <hiji> AfC: Is writing CPU-intensive numerical code harder in Haskell than say in Numpy?
06:17:24 <AfC> hiji: as an example, my first non-toy program was a short URL redirector. Sure there are plenty of those out there so indeed I was re-inventing that wheel. But it was a pragmatic case I happened to need which taught me Snap (a web server framework) and also how to use Hedis (a great Redis binding).
06:18:13 <hiji> AfC: Given that way of starting, would you feel comfortable attacking problems like the ones merijn described?
06:18:32 <merijn> hiji: Well, I think mostly writing intensive numerical code is, like most things in haskell, mostly *different* from things like NumPy
06:18:43 <AfC> yeah
06:18:45 <tobygoodwin> bgamari: (or anyone) so one conflict is that http-wget wants transformers-2, but other things in my program want transformers-3... how can I handle that?
06:19:16 <merijn> hiji: Many things are not particularly hard, but because haskell libraries tend to attack problems entirely differently from frameworks/libraries in other languages, it *feels* more difficult
06:19:17 <AfC> tobygoodwin: switch to using a different HTTP client library? Like, oh, say http-streams? :)
06:19:51 <merijn> tobygoodwin: That, or "cabal get" http-wget, edit the cabal file to allow transformers-3, and then run "cabal install" to see if that works :)
06:20:24 <merijn> tobygoodwin: Sometime maintainers are way too conservative in their upper bounds, simply editing the bound will frequently fix things to work
06:21:13 <applicativ_> tobygoodwin: i wonder if http-wget has been deprecated
06:21:15 <hiji> merijn: Logical that it must be different in Haskell. Time to get feet wet and report back if things go south :)
06:21:35 <applicativ_> snoyberg would have updated the deps if he was paying any attention to it
06:21:39 <hiji> AfC, merijn, applicativ_: Thank you for your suggestions :)
06:21:45 <Cale> Well, often the conservative upper bounds are because that was the newest version at the time that the package was released, but it hasn't been updated
06:21:50 <merijn> hiji: I usually recommend things like parsing and concurrent network servers as first pragmatic projects, since concurrency and parsing are two things were haskell is much better than other languages
06:22:00 <applicativ_> tobygoodwin: just do cabal unpack http-wget and delete <0.3
06:22:11 <tobygoodwin> yeah, that's worked so far
06:22:16 <Cale> Upper bounds on package versions are hard to ever set correctly without prescience about how those packages will change in the future.
06:22:34 <merijn> hiji: So experienced programmers get to see some direct value in haskell's differentness, where (maybe) in other libraries the benefit may not be as immediately obvious
06:23:00 <applicativ_> tobygoodwin: he seems to have scrapped the github repo https://github.com/snoyberg?tab=repositories
06:23:03 <Cale> (Personally, I don't think upper bounds should be set unless the package is known not to work with versions above a given bound)
06:23:14 <merijn> Cale: Agreed
06:23:19 <applicativ_> in which case it should be repaired...
06:23:42 <Cale> But hackage will complain at you if you don't set the upper bounds, so people end up setting them essentially randomly.
06:24:05 <Gracenotes> Cale: counterfactual build bots would be very nice here
06:24:19 <applicativ_> tobygoodwin: oh indeed it says 'deprecated' at the top of the page
06:24:19 <chrisdone> what's a counterfactual build bot?
06:24:28 <Gracenotes> I just made up the phrase
06:24:45 <tobygoodwin> applicativ_: damn, i'll have to fix that then :-(
06:24:53 <applicativ_> tobygoodwin: why do you need it though?
06:25:10 <applicativ_> tobygoodwin: the usual conduit way does https
06:25:11 <hiji> merijn: Reading about STM (assuming that is what you mean by concurrency), it sounds fascinating.
06:25:15 <Gracenotes> build configs with loosened dependencies to try to make failing builds succeed
06:25:33 <Gracenotes> "if this bound were higher"
06:25:35 <tobygoodwin> err, to fetch a web page without thinking too hard about it :-)
06:25:49 <applicativ_> tobygoodwin: i think http-wget was written for https since the Http package doesnt.
06:26:27 <applicativ_> tobygoodwin: doesn't do https
06:26:34 <merijn> hiji: Well, I also meant just threads, MVars and Chans. But yes, STM is also *really* cool
06:27:27 <Gracenotes> well, with new hackage supporting editing Cabal files of existing packages, the conceptual cost of bounds-mucking might decrease (hopefully not too much).
06:27:42 <applicativ_> toby http://hackage.haskell.org/packages/archive/http-conduit/1.9.5.1/doc/html/Network-HTTP-Conduit.html or http://hackage.haskell.org/package/HTTP-4000.2.8 see the examples at the top of each page?
06:28:32 <tobygoodwin> applicativ_: tvm
06:29:06 <merijn> I support http-conduit for downloading webpages, it plays nicely with html-conduit for parsing html, I was rather pleased with how it worked
06:29:39 <Cale> Gracenotes: of course, it might in some cases compile and then not work :(
06:30:01 <Cale> But this is Haskell, so that would probably be quite rare :)
06:30:21 <merijn> Once this Haskell TravisCI stuff gets sorted we can just test that with that!
06:30:41 <merijn> I should look into that again, someone was working on it, but I haven't heard much since
06:31:06 <Gracenotes> Cale: GHC is pretty conservative about what it lets compile, exact-versions-matching-transitively-wise
06:31:23 <Cale> The first time I heard of continuous integration, I thought people were talking about real analysis, and then I was disappointed.
06:31:24 <Gracenotes> er, as far as bugs, I'm not aware of any in Haskell
06:31:50 <mdmkolbe> I remember there being some sort of flag that tells GHC to run the simplification/optimizations more than one time, but I can't find it.  Anyone know what that flag is?
06:32:18 <bartavelle> Cale :)
06:32:30 <Cale> Gracenotes: well, all it would take is some package maintainer changing the semantics of something without changing the type
06:32:31 <kqr> Cale, lol
06:33:50 <Cale> Of course, integration is usually a continuous operator :)
06:34:17 <Cale> (while differentiation is usually horribly discontinuous)
06:35:27 <applicativ_> mdmkolbe: there are several flags that take a number
06:35:30 <AfC> applicativ_: you're reminding me to have another look at the examples "at the top" of my library
06:35:40 <fizbin> Cale: That just makes things like the Dirac delta more interesting.
06:36:42 <applicativ_> AfC: how do you mean?
06:37:00 <applicativ_> AfC: they make for excellent advertising...
06:37:42 <AfC> applicativ_: oh, just that you were citing my two competitors. About time I had a look to make sure I was still approachable.
06:38:20 <applicativ_> AfC: oh i figured out who you are; oddly i was just trying to figure out how he could do it with yours
06:38:43 <applicativ_> AfC: where's *your* `simpleHttp`??
06:38:53 <applicativ_> hah
06:39:20 * tobygoodwin doesn't think $$+- is a good name for... well, anything
06:39:34 <applicativ_> AfC when merijn praised http-conduit (rightly) I was about to say 'i'm http-streams man m'self'
06:39:46 <applicativ_> but then got confused...
06:40:12 * applicativ_ is with tobygoodwin 
06:41:25 <AfC> tobygoodwin: heh
06:41:31 <AfC> applicativ_: I guess it would be `get` :)
06:41:57 <applicativ_> AfC yes I  was thinking
06:42:19 <AfC> applicativ_: anyway, always a balance to put code examples up front versus needing to get on with documenting things
06:42:21 <applicativ_>  get "http://www.bbc.co.uk/news/" concatHandler was what i was about to run
06:43:14 <AfC> That'll work
06:46:07 <AfC> Unfortunately the requirement to call `withOpenSSL $ ` before hitting an https URL is unavoidable. I need to finish my patch to  make that safe to be called multiple times; then I can just whack it into the library and do away with the need for the user to put it in main
06:47:42 <exicer> AfC: What package is this you are talking about ?
06:48:05 <exicer> I've been experimenting with http-conduit, would be good to look at alternatives
06:48:26 <applicativ_> http-streams is AfC 's library
06:48:37 * applicativ_ is waiting for http-pipes of course ;)
06:49:10 <applicativ_> wasnt there a little blog post about http-streams? it was extremely helpful in my blurry memory
06:49:47 <AfC> applicativ_: http://blogs.operationaldynamics.com/andrew/software/haskell/http-streams-introduction
06:50:06 <AfC> applicativ_: and yes, I'm working in pipes-http
06:50:58 <mm_freak> ocharles: integral1 wouldn't be very useful…  it wouldn't support feedback, so you would be delaying it all the time
06:51:07 <mm_freak> ocharles: also the first time delta is 0 anyway
06:52:06 <donri> AfC: are you planning on using http-types for that? which tls package?
06:52:53 <AfC> donri: no, I'm going to splice the common types out of http-streams and share them between it and pipes-http.
06:53:14 <donri> AfC: oh. why not http-types?
06:54:27 <AfC> donri: and it'll have to be openssl until people 'way smarter than me sign off that it's ok to use anything but openssl in the real world.
06:54:42 <AfC> donri: {shrug} it's pretty underwhelming
06:54:53 <AfC> donri: at least it was when I evaluated it a year or two ago
06:55:10 <AfC> didn't even have an ADT for HTTP method. Pretty weak.
06:55:17 <donri> it does now
06:55:21 <AfC> Too late
06:55:24 <donri> :)
06:55:47 <AfC> I filed a bug about it at the time, Michael told me to get lost. So I did, and wrote http-streams.
06:55:59 <donri> huh
06:57:02 <AfC> type Method = ByteString
06:57:34 <donri> well it has StdMethod for, well, standard methods
06:57:48 <donri> there are things that use non-standard methods, like WebDAV IIRC
06:58:11 <AfC> {sigh}
06:58:11 <AfC> next
06:59:34 <theorbtwo> WebDAV's methods are standard ... but possibly only in the sense that webdav is a standard.
06:59:41 <AfC> heh
07:00:32 <bgamari> tobygoodwin, Have you solved your troubles?
07:00:48 <tobygoodwin> thank you, yes
07:01:03 <tobygoodwin> well, substituted them for different troubles, anyway :-)
07:02:07 <acomar> just substitute Void, problem solved ;)
07:02:12 <tobygoodwin> as suggested, i threw out http-wget, which is what cabal was getting so cross about (although it definitely managed to build that code yesterday)
07:02:24 <mbrock> the HTTP spec has a nice sum type for methods: http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1
07:02:57 <mbrock> enumerating the eight standard methods plus a constructor for "extension methods" being any token :)
07:04:03 <applicativ_> AfC: well, if the common http types are used by two libraries, http-streams and http-pipes, then it will immediately win over the http-types library
07:05:02 <applicativ_> tobygoodwin: but how could possibly decide between http-conduit, HTTP and http-streams??
07:05:17 <tobygoodwin> so given a ByteString (by simpleHttp as it happens), what's the canonical way to turn it into a String or Text?
07:05:45 <klugez> AfC: Which bug report was that?
07:05:47 <applicativ_> tobygoodwin: there are transformers in Data.Text.Encoding and in bytestring
07:05:50 <donri> tobygoodwin: decode it
07:05:55 <mbrock> is there any way to follow the development of pipes-http?
07:06:05 <donri> tobygoodwin: you have to know or decide on an encoding
07:06:12 <AfC> applicativ_: one of the unusual design decisions I made (which you may have noticed and/or wondered about) was that [unlike, say, the server libraries] the Request and Response types do _not_ have the entity body buried in them.
07:06:23 <applicativ_> mbrock: you're putting a lot of pressure on AfC ;)
07:06:58 <tobygoodwin> donri: no problem, all the world's UTF8, right? :-)
07:07:02 <xpika_> quit
07:07:17 <mbrock> when there's any kind of release I'll probably have to stay up all night and code stuff with it :/
07:07:20 <applicativ_> tobygoodwin: import qualified Data.Text.Encoding as T ; use T.decodeUtf8/T.decodeUtf8, crudely
07:07:21 <donri> tobygoodwin: there's Data.Text.Encoding.decodeUtf8
07:07:22 <AfC> applicativ_: the idea behind that was largely to allow using the same types on the server side, should anyone care to [certainly I do in my own wrapper around Snap]
07:07:53 <tobygoodwin> donri, applicativ_: yep, got it - thanks again!
07:07:59 <AfC> mbrock: I'm just getting started. It won't take long, but I had to wait on pipes 4 to stabilize (trying to keep up with tekmo is a nightmare :))
07:08:21 <AfC> mbrock: and for pipes-bytestring to land. I have enough to publish the API now
07:08:24 <AfC> hopefully this weekend
07:08:27 <merijn> tobygoodwin: There's "decodeUtf8With lenientDecode" it replaces all invalid byte (sequences) with unicode "unknown symbol"
07:08:31 <mbrock> AfC: oh cool
07:08:53 <mbrock> AfC: then I could get started doing some mock coding :)
07:09:05 <AfC> mbrock: it will most decidedly be 0.0.1 for a little while; I need to run it past the pipes hackers at that point.
07:09:42 <tobygoodwin> merijn: thanks, i'll bear that in mind (in this instance, i happen to own the server, so i can fix it if it spits out bad utf8)
07:09:43 <applicativ_> tobygoodwin: if you have more control over the construction take a look at the utf8 material in Data.ByteString.Lazy.Builder
07:10:10 <AfC> mbrock: but I've committed to Greg and Gabriel that I'm going to maintain the two in parallel with the same API (names, anyway) so that examples work in one or the other.
07:10:49 <applicativ_> AfC: but there aren't any examples
07:13:53 <AfC> early morning meeting. Got to get some rack.
07:24:35 <tobygoodwin> hooray! hurrah! w00t! my code compiles again - thanks all
07:26:08 <tobygoodwin> this seems pretty ugly, but my platform has bytestring-0.9 which lacks toStrict:
07:26:14 <tobygoodwin> import qualified Data.ByteString as Bs
07:26:14 <tobygoodwin> import qualified Data.ByteString.Lazy as Lbs
07:26:14 <tobygoodwin> let x' = decodeUtf8 $ Bs.concat $ Lbs.toChunks x
07:27:17 <applicativ_> yes that was the old version of toStrict concat . toChunks
07:27:26 <applicativ_> i mean concat . toChunks was
07:28:40 <applicativ_> omigod a new conduits vs. pipes war
07:29:05 <applicativ_> we need to supply snoyberg and Tekmo with immense foam mallets to hit each other over the head with
07:29:14 <geekosaur> time to spawn another 3 or 4 alternatives :p
07:29:23 <exicer> applicativ_: could you summarise to a noob what are the points for against each ? :P
07:29:47 <applicativ_> exicer: still studying ;)
07:29:52 <haasn> does conduits have equivalents to stuff like pipes-attoparsec?
07:30:04 <exicer> applicativ_: Hah, fair enough :)
07:30:18 <donri> @hackage attoparsec-conduit
07:30:18 <lambdabot> http://hackage.haskell.org/package/attoparsec-conduit
07:30:27 <applicativ_> haasn: they all have a replica of enumerator-attoparsec ;)
07:30:36 <applicativ_> or was it attoparsec-enumerator
07:30:51 <donri> attorator-enumarsec
07:31:08 <applicativ_> right! how could i forget?
07:31:11 <donri> attoratees?
07:31:14 <gienah> atsomethun-iteratee
07:32:02 <applicativ_> exicer: actually i'm a pipe partisan, so my view wouldn't matter anyway ')
07:34:46 <exicer> applicativ_: I will have to come up with some way of deciding which I am :p
07:35:09 <haasn> write code using each, see which one results in fewer lines
07:35:12 <chrisdone> exicer: Team Edward or Team Jacob?
07:35:23 <merijn> chrisdone: Ha!
07:44:02 <acomar> I don't really get the argument that's going on... what's snoyberg saying pipes can't do that conduit can do? push based semantics?
07:47:23 <applicativ_> acomar: yeah i'm not following yet kamatsu was convinced by http://www.reddit.com/r/haskell/comments/1n0i29/folding_lines_in_conduit/ccee549 so i'm trying to figure that out
07:48:36 <acomar> applicativ_: yea, that's where I'm stuck too
07:48:41 <DMcGill> applicativ_: have you lost weight recently?
07:48:57 <DMcGill> I've just spotted your new name
07:49:12 <ocharles> mm_freak: I thought I need integral1 *for* feedback
07:49:16 <ocharles> but..
07:49:20 <applicative> irssi sometimes gives me trouble because i can't remember my password
07:49:30 <ocharles> what I ended up using was an integralWith variant that returns the corrected and uncorrected versions
07:49:38 <merijn> applicative: Why not store your password in your irssi config?
07:50:17 <merijn> applicative: You can store a server password and freenode can use that to pre-authenticate your account
07:50:46 <applicative> merijn: oh wait, it occurs to me, on another, i have that config
07:50:49 <applicative> i think
07:50:57 <applicative> on another machine i do , I mean
07:51:28 <applicative> is this in like an .irssi file?
07:51:38 <merijn> .irssi/config
07:52:07 <donri> i auth with SASL so it'll auth even if there's a ghost donri online, and then i REGAIN on connect :) you can't force me to not be donri!
07:59:33 <quchen> Is there any timeframe for the next Platform release?
08:02:34 <Flonk> .
08:03:45 <ptek> Hi, did anyone try to build a static binary with postgresql-simple on debian wheezy?
08:03:45 <FreeFull> Oh, GHC got a -j flag
08:03:47 <FreeFull> That is very nice
08:04:14 <ptek> I get a linking problem
08:04:19 <ptek> https://gist.github.com/ptek/d2d779f12e999f49c00b
08:05:53 <geekosaur> you are missing a bunch of libraries
08:05:58 <FreeFull> ptek: Looks like a missing -l flag to me
08:06:07 <geekosaur> -lldap -lkrb5 -lopenssl (at minimum(
08:06:19 <geekosaur> oh and -lgssapi
08:06:22 <ptek> oh
08:07:35 <geekosaur> although postgresql-simple should really be finding that out from the postgres config
08:07:50 <ocharles> mm_freak: anyway, http://lpaste.net/7462789294965391360 is what I ended up with - which isn't using feedback at all
08:07:55 <FreeFull> quchen: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
08:08:00 <FreeFull> Says November 4th
08:08:09 <FreeFull> So one day before Guy Fawkes
08:08:51 <quchen> Oh, I didn't know that page was updated, thanks.
08:13:08 <FreeFull> The haskell-platform mail list is getting spam ):
08:13:20 <FreeFull> http://projects.haskell.org/pipermail/haskell-platform/2013-September/002663.html
08:16:15 <JordiGH> So what's more idiomatic, sin.cos $ 5 or (sin.cos) 5 ?
08:16:15 <Ankhers> But, they won a half million pounds... isn't that a good thing?
08:16:25 <DMcGill> What is a tuple with 9 elements in? I'm tempted to call my triple of a triple a 'nipple'
08:16:29 <JordiGH> After reading LYAHFGG I got the impression that it's preferrable to avoid parens.
08:18:23 <acomar> JordiGH: I tend to prefer sin . cos $ 5, it's generally friendlier when I inevitably need to change the code
08:18:45 <JordiGH> And spaces around the function composition?
08:19:20 <acomar> I put spaces around all my operators, keeps everything easy to read
08:19:23 <ptek> FreeFull: where did you see the -j option for GHC?
08:19:57 <acomar> ptek: http://ghc.haskell.org/trac/ghc/ticket/910
08:20:17 <FreeFull> ptek: ^
08:20:39 <swistak35> Hi, can I, in some way, say to ghc: "I know, that function Foo will be executed tremendous amount of times. Please, cache every single call and don't remove these results from cache"
08:20:49 <ptek> FreeFull, oh wow! That is great news indeed :)
08:21:11 <JordiGH> acomar: Really? You find e.g. 3 * 5 + 2 easier to read than 3*5 + 2?
08:22:05 <acomar> JordiGH: I've had order of operations drilled into me since I was a child, that's kinda second nature to me. I do see the appeal of 3*5 + 2 though.
08:23:08 <zeroXten> whats wrong with this? 10_elems lst = take 10 lst
08:23:45 <FreeFull> JordiGH: My personal preference is to have the spaces
08:24:13 <acomar> zeroXten: that's an invalid identifier, you can't start with a number like that
08:24:15 <otulp> zeroXten: Function name starts with a digit.
08:24:17 <DMcGill> swistak35: you're asking about memoization. There are a few packages that provide this, one is http://hackage.haskell.org/packages/archive/memoize/0.6/doc/html/Data-Function-Memoize.html
08:25:25 <DMcGill> then you just call 'memoize f' where you would call 'f' and it'll save the results. You can easily do this yourself by making a list of pairs or a map of (x, f x).
08:25:39 <swistak35> DMcGill: thank you : )
08:25:57 <FreeFull> swistak35: If you're interested in how it works, memoization in Haskell tends to be a combination of laziness and sharing
08:26:57 <zeroXten> heh thanks otulp and acomar ... was just following http://acm.wustl.edu/functional/hs-breads.php
08:27:02 <swistak35> FreeFull: sharing what? Yes, I'm curious how 'memoize' function works, it seems, like it should have some external, "global" variable to store there results
08:27:47 <FreeFull> swistak35: So you fill a data structure with a monomorphic type (so it gets shared) with all the possible results for a function. Thanks to laziness the function will get executed once when you try to get the result, and thanks to sharing the next time you want the result you'll get it from the data structure
08:28:06 <TallerGhostWalt> So if I wa10:25 *** BeardedCoder JOIN
08:28:32 <TallerGhostWalt> Are there any plans to make a default Comonad instance for IO ?
08:28:41 <acomar> swistak35: you're asking about how a specific memoization package is implemented -- you'll have to look at each package's documentation and source code to determine that
08:28:43 <swistak35> FreeFull: not sure what do you mean by monomorphic type. You mean kind "*"?
08:28:46 <acomar> there are several approaches
08:29:02 <DMcGill> often a table is saved behind the scenes
08:29:04 <FreeFull> swistak35: I mean no type variables
08:29:15 <FreeFull> So it can't be   Num a => [a]
08:29:19 <FreeFull> But can be [Integer]
08:29:36 <DMcGill> using some slightly cheaty methods that are nontheless justified since, well, that's very specifically the required behaviour
08:30:46 <FreeFull> swistak35: There is also another, impure approach to memoization that involves unsafePerformIO. I don't know how that works
08:30:48 <acomar> DMcGill -- it's not really cheaty is it? referential transparency and denotational semantics are preserved with the use of unsafePerformIO (in this case), it's just being used for performance
08:31:02 <acomar> I think that's the whole reason unsafePerformIO exists
08:31:22 <swistak35> well, thank all of you : )
08:31:26 <FreeFull> unsafePerformIO exists because of the FFI I think
08:32:03 <FreeFull> If you have some C function that you know is pure, you don't want its result to be an IO something
08:32:15 <DMcGill> 'cheaty' was a poor choice of word perhaps. I was mostly using to mean 'has unsafePerformIO'. For example I once used it to cache a "background :: Image; background = unsafePerformIO $ readImage loc"
08:32:29 <DMcGill> as the alternative was to pass that image around throughout my entire program
08:32:58 <acomar> that's one use case, but I thought the other was to improve performance via referentially transparent functions that make use of IO
08:33:27 <FreeFull> unsafePerformIO is fine as long as you use it responsibly (and understand how things can go wrong when you do use it)
08:34:11 <ocharles> FreeFull: that's a pretty big requirement
08:34:24 <DMcGill> yes, yes it is
08:34:39 <DMcGill> that it is a strict requirement is sort of the point
08:35:09 <ocharles> yes, but when people say "oh it's fine as long as x", they inadvertly significantly downplay how specific and limited x is
08:35:12 <ocharles> imo
08:35:25 <DMcGill> “Look, that's why there's rules, understand? So that you think before you break 'em.”
08:35:39 <DMcGill> - Pratchett
08:35:40 <FreeFull> void* is fine as long as you use it responsibly
08:36:14 <FreeFull> DMcGill: Which book was that?
08:36:21 <DMcGill> Thief of Time
08:36:47 <FreeFull> Ah, that's the one where that guy builds a clock?
08:37:19 <DMcGill> Yes, but the quote is in the context of the monk Lu-Tze lecturing his apprentice
08:42:47 <TallerGhostWalt> I was listening to the haskell cast ep. 1 and ekemmet was talking about using co-monads b/c they result in smaller functions
08:43:07 <TallerGhostWalt> That is something I have noticed about monads.  I end up with huge blocky defs.  (probably cause I suck)
08:43:31 <TallerGhostWalt> Co-monads seemed like a nice way of dealing with this.
08:43:48 <TallerGhostWalt> If I want to use them are there instances defined somewhere for IO?
08:44:00 <DMcGill> Co-monads aren't usually suitable for the same thing that monads are. You might find that Applicative style does what you want.
08:44:39 <TallerGhostWalt> And that is why I ask these questions.
08:44:46 <DMcGill> do {x <- getX; y <- getY, doZ; return (f x y)} === f <$> getX <*> getY <* doZ
08:45:19 <DMcGill> you can think of Applicative style as point-free programming for Monads (or indeed Applicatives)
08:46:03 <DMcGill> and, in the same way, it can sometimes make things easier but if things are too monolithic you end up being incomprehensible and you should just name things
08:46:52 <TallerGhostWalt> Also, I heard Don Stewart talking about partials on the latest Haskell Cast.
08:47:10 <TallerGhostWalt> Is that something different than passing around a function?
08:47:36 <Taneb> TallerGhostWalt, a partial function is a function not defined on all inputs
08:47:51 <Taneb> They are Bad, but unfortunately often the easiest option
08:48:21 <DMcGill> head (a:_) = a; head [] = error "noooo"
08:48:50 <DMcGill> is an example of a partial function - it "crashes"*
08:49:20 <DMcGill> *: of course, by "crashes" I mean it returns the special error value, _|_ (pronounced "bottom")
08:49:47 <DMcGill> ⊥ in unicode
08:52:55 <DMcGill> compare that to a total version of the same function: safeHead (a:_) = Just a; safeHead [] = Nothing
08:53:04 <TallerGhostWalt> I see
08:53:27 <DMcGill> not only is it longer to write, you still have to deal with the case of failure somewhere when you try to use the value from that Maybe
08:53:31 <Maior> yay total functions
08:53:38 <ocharles> <3 totality
08:53:40 <DMcGill> (this is the usual motivation for partial functions anyway)
08:53:55 <TallerGhostWalt> So this is different than a partially applied function which is what I was thinking of right?
08:54:03 <DMcGill> yes, completely unrelated
08:54:05 <ghorn> why is this overlapping instances? http://lpaste.net/93343
08:54:16 <ocharles> note that you can be partial in other ways though. for example f x = f x is also not total, because it never produces a value (it just loops forever)
08:55:05 <TallerGhostWalt> GHC warns on most partial functions then right?
08:55:08 <geekosaur> ghorn, the context has nothing whatsoever to do with instance selection
08:55:17 <ocharles> TallerGhostWalt: only some
08:55:31 <ocharles> f x = 1 / x is partial when x = 0, because 1/0 is not defined. GHC can't help you about that
08:55:43 <TallerGhostWalt> I see
08:56:18 <TallerGhostWalt> The partiality is hidden in a different function sort of
08:56:37 <Maior> now, if you have a type system that has NonZeroReal...
08:56:41 <ghorn> geekosaur: I don't know what you mean by "the context"
08:56:48 <ghorn> ... in this context, heh
08:56:52 <DMcGill> TallerGhostWalt: GHC is good about warning about not pattern matching totally but remember that only helps for some partial functions
08:57:01 <geekosaur> `instance ForeignPtrWrapper a b => Marshall a (Ptr b)' the part before the => is the context
08:57:15 <geekosaur> it doesn't matter what you have there when ghc is picking an instance
08:57:23 <ghorn> ooh
08:57:46 <DMcGill> and what you said is why partial functions are bad: your program will just crash one day and you just have to hope that it's with a good error message
08:58:09 <DMcGill> having a multiple thousand like program crash with "head called on empty list" is not exactly what you want
08:58:17 <DMcGill> multiple thousand line*
08:58:35 <geekosaur> anyone know where that haskellwiki page is about why the context isn't used?
09:01:00 <TallerGhostWalt> yeah I have seen stuff like that already
09:01:03 <av> hello there, I'm going mad with ByteStrings, can anyone help please: I'm trying to a run a program using JuicyPixels (in fact, one from the project's git repository), and keep getting this error:
09:01:19 <av> "Couldn't match expected type `LB.ByteString' with actual type `bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString'"
09:01:19 <TallerGhostWalt> DMcGill: It was not fun to figure out at all
09:01:33 <DMcGill> Debug.Trace is your friend
09:01:35 <TallerGhostWalt> lot of traceShow
09:01:38 <DMcGill> yeah
09:02:13 <DMcGill> av: what version of bytestring do you have installed?
09:02:14 <geekosaur> av: the fact that the second type has a versioned package on it means that you are mixing two different versions of the bytestring package
09:02:20 <ptek> av, is the bytesting library is of the correct version?
09:02:22 <TallerGhostWalt> Thanks all
09:02:25 <DMcGill> you can find out by running "ghc-pkg list" on the command line
09:02:39 <av> any ideas?  I think my install is at fault (0.9.2.1 was installed with debian's haskell-platform, and a newer version was pulled in by some cabal packages I installed
09:02:59 <av> yes, two versions of bytestring, I'm aware of that
09:03:13 <av> but my own code using bytestring works fine
09:03:20 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml
09:03:38 <geekosaur> bytestring is a ghc boot library, you can't safely have multiple versions installed
09:04:21 <DMcGill> ooh, looks like a good read
09:04:28 <FreeFull> ocharles: 1 / 0 is defined for Float and Double though. Gives you +Inf
09:05:03 <FreeFull> Maior: You could look at LiquidHaskell
09:06:20 <haasn> This really isn't the right domain immature boy like me... (.).(.) = fmap fmap fmap, everybody here likes Coq, GHC now has holes (it can shove its type signatures onto), thanks to edwardk it's even possible to unzip and have a tug or two...
09:06:23 <ocharles> Maior: I'm not convinced 'NonZeroReal' is the best way to go, but I don't know what the options are there
09:06:24 <haasn> domain for an*
09:06:54 <DMcGill> TallerGhostWalt: to go back to our previous discussion I'd still recommend looking into comonads. Among other things they're good for thinking of "values with contexts" i.e. cells in an array.
09:07:06 <av> geekosaur: OK, but how do I get rid of them? As I said, one was installed by the Debian package, the other pulled in by repa, gloss, etc., which I also need.
09:07:18 <DMcGill> ocharles: be in Agda
09:07:36 <ocharles> DMcGill: I know about Agda... but just whacking something in a custom type is not always the best/only solution
09:07:59 * geekosaur points to http://www.vex.net/~trebla/haskell/sicp.xhtml again
09:08:13 <ocharles> Agda is not this magically language that makes everything safer while being just as concise/pragmatic
09:08:16 <ocharles> magical*
09:08:24 <Maior> ocharles: same
09:08:26 <DMcGill> I don't know how much luck you're going to have when programming with dependant types in Haskell. It's possible but it's really not designed for it
09:08:27 <TallerGhostWalt> DMcGill: i found the cell Automata paper and will probably try and work through it this weekend.
09:08:37 <DMcGill> that's what I mean - the extra safety always comes at a cost
09:08:50 <Maior> ocharles: I'd be inclined to just type it as f :: Real -> Maybe Real
09:08:57 <TallerGhostWalt> DMcGill: By paper I mean blog post
09:09:09 <mm_freak> ocharles: i considered simplifying the interface such that a wire always depends on now or doesn't depend at all
09:10:06 <ocharles> mm_freak: hm?
09:10:42 <mm_freak> ocharles: you can always go from strict to nonstrict (delay), but there is no reverse way
09:10:53 <mm_freak> ocharles: i thought that i'll make all wires signal-strict
09:11:12 <ocharles> right, just not sure what your comment is response to
09:11:24 <ocharles> integral1, or something else?L
09:11:25 <mm_freak> ocharles: about integral1
09:11:26 <ocharles> right
09:12:10 <mm_freak> ocharles: and yes, for mario you don't need feedback
09:12:31 <ocharles> mm_freak: well, you don't *need* it, but it seems it could greatly simplify things
09:12:40 <mm_freak> ocharles: strictly speaking you never need feedback…  it's just convenient =)
09:12:56 <ocharles> for example, I only want to jump when I'm touching with the floor... and that can be derived from determining if I was intersecting with the floor
09:13:17 <thirsteh> Just launched ghci by accident with some key combination in emacs haskell-mode. Anyone know what that combination is?
09:13:19 <ocharles> just checking my distance from the tile below doesn't work, because instantaneously after jumping I will be an infinitely small distance away from the floor
09:13:29 <mm_freak> ocharles: you need it when two things depend on each other…  in this case mario depends on the walls, but the walls don't depend on mario
09:13:32 <ocharles> so then I start having to fudge things by checking my velocity explicitly
09:13:43 <mm_freak> ocharles: so this is a simple feed-forward data dependency
09:14:13 <otulp> thirsteh: C-c C-l while in haskell-mode
09:14:48 <mm_freak> ocharles: well, you need a small tolerance value
09:14:55 <ocharles> mm_freak: well having velocity depend on collisions, position depend on velocity and collisions and collisions depending on position felt like a nice way to lay things out
09:15:00 <thirsteh> otulp: perfect, thank you
09:15:19 <ocharles> mm_freak: I just can't see a way to do a feedback loop that avoids ever producing intersections outside the loop
09:15:36 <mm_freak> ocharles: well, since mario is not physically correct you can use whatever data layout you want =)
09:15:39 <ocharles> I seem to always have an "intersecting" instant followed by a "not intersecting" period
09:16:00 <mm_freak> ocharles: that's because when you use feedback you depend on a slightly outdated world
09:16:12 <ocharles> right. so what I want it to step twice, locally
09:16:21 <mm_freak> so instead of feedback, be more explicit about your data dependencies
09:16:22 <ocharles> what I want is to*
09:16:25 <ocharles> hm
09:16:52 <mm_freak> note that integral itself is slightly outdated…  the contribution from this instant will only be observed in the next instant
09:16:54 <ocharles> well infact, that's what I did actually - and that ends up with integralWith that gives out correct and non-corrected parts
09:17:09 <mm_freak> ocharles: that's why i'm thinking of getting rid of pre-delaying wires
09:17:18 <ocharles> I think that will help
09:17:30 <ocharles> I had a hard time understanding the dependencies when I was working in ArrowLoop
09:17:42 <mm_freak> yeah, that should simplify things a lot
09:17:50 <mm_freak> if you want feedback, delay, period
09:18:03 <ocharles> I generally like to start from a blackhole, and then remove it. So I was confused when I couldn't even get that
09:18:50 <mm_freak> i'll do that
09:19:00 <ocharles> ok. what do you think about the double-output variant of integral?
09:19:16 <ocharles> should I keep that for myself, or does it seem more widely useful?
09:19:27 <mm_freak> ocharles: i think i can make a more flexible version of that
09:19:49 <mm_freak> ocharles: integralWith :: (a -> (b, a)) -> Wire s e m a b
09:19:57 <mm_freak> (add the usual constraints)
09:20:13 <mm_freak> ocharles: that's basically a time-scaling unfold
09:20:19 * ocharles ponders
09:20:43 <ocharles> you're integrating a, but the result of that doesn't appear to be visible
09:20:45 <mm_freak> if you want the regular integral wire, pass (\x -> (x, x))
09:20:50 <ocharles> or are you integrating b?
09:20:55 <av> geekosaur: thanks for the pointer, that makes sense.  BUT: what the author suggests as the first safe way of using distro and cabal installs together is exactly what I did -- so I'm still puzzled
09:21:00 <mm_freak> you're integrating 'a'
09:21:18 <mm_freak> 'b' can be (a, a) giving both the corrected and the original value
09:21:32 <ocharles> right. but now you've lost the ability to correct from an outside environment
09:21:44 <mm_freak> well, yeah
09:21:54 <ocharles> the way I had things working was the 'corrected' version depended on whether or not there was a collision, but that depends on only the uncorrected version
09:21:57 <ocharles> so everything is productive
09:21:58 <mm_freak> ocharles: integralWith :: (w -> a -> (b, a)) -> Wire s e m (a, w) b
09:22:05 <ocharles> that'd be perfect
09:22:22 <ocharles> though I find (a -> w -> (b, a)) to be more useful btw, because then you can combine corrections with >=>
09:22:28 <ocharles> (the underlying monad being (w ->)
09:22:32 <mm_freak> indeed
09:22:51 <mm_freak> it's a compromise between (w ->) and State a
09:23:16 <mm_freak> both could be useful…  which one did you end up using more?
09:24:11 <mm_freak> here is a fun idea:  (forall m. (MonadReader w m, MonadState a m) => m b)
09:24:24 <mm_freak> integralWith :: (forall m. (MonadReader w m, MonadState a m) => m b) -> Wire s e m (a, w) b
09:24:31 <mm_freak> that way you could even use your lenses right away
09:24:33 <ocharles> today I ended up using MonadReader w m
09:24:40 <ocharles> I am using lenses too :)
09:24:53 <ocharles> integralWith (terminalVelocity terminalSpeed >=> views _1 . setVelocity >=> views _2 . zeroOnGround)
09:25:10 <ocharles> with an environment of (horizontalVelocity, isOnGround)
09:25:49 <ocharles> but if we can get the more general integral stuff, then I'd like to go back to a ArrowLoop - so 'isOnGround' would be 'collisionsOccured' or something
09:25:51 <ksf_> http://lpaste.net/93344     <--- anyone can tell me if there's *any* way to avoid type signature explosion in the inferred type for "foo" (ghc HEAD required)
09:26:05 <ski> mm_freak : rank-2 polymorphism ftw !
09:26:07 <ksf_> the good news, OTOH, is that all types *do* get inferred.
09:26:30 <ocharles> mm_freak: but I like the idea of generalising to type classes if that's possible
09:27:24 <mm_freak> ocharles: are there any others you'd like to see generalized?
09:27:45 <ocharles> nope, integral is my work horse for now
09:27:51 <mm_freak> ocharles: originally i started with a type class:  class (Category w) => Reactive w
09:28:04 <mm_freak> but that turned out to be awkward to work with and not really useful either
09:28:49 <ksf_> (bijective type families surely would help)
09:29:11 <ksf_> but some trick to evaluate them early would work too, I guess.
09:29:24 <mm_freak> ski: was that sarcastic?
09:29:39 <ski> no ?
09:29:46 <ocharles> mm_freak: ok, I like where integralWith is going. do you want to write that, or shall I?
09:29:58 <ocharles> I'm about to leave the office and have a commute, so I could write it during that if you're busy
09:30:32 <mm_freak> ski: ok =)
09:31:05 <haasn> Is it bad that I read “have a commute” and thought you were flipping some sort of symmetry?
09:31:07 <mm_freak> ocharles: right now i'm busy…  if you don't write it today (it's 6:30 PM here), i'll write it tonight
09:32:28 <ocharles> mm_freak: ok, i'll give it a shot!
09:32:32 <kuribas> Is there an unboxed, strict tuple type?
09:32:53 <mm_freak> kuribas: not predefined
09:33:15 <kuribas> Do you need to define one yourself?
09:33:42 <mm_freak> kuribas: data Tuple' a b = Tuple' { fst' :: {-# UNPACK #-} !a, snd' :: {-# UNPACK #-} !b }
09:33:48 <mm_freak> something like that
09:33:55 <kuribas> Hm, I see.
09:34:01 <elliott> that does not work
09:34:05 <elliott> can't unpack polymorphic fields
09:34:13 <mm_freak> oh, indeed
09:34:20 <kuribas> double would be enough.
09:34:35 <mm_freak> kuribas: if both are Double, you could use an unboxed Vector
09:34:43 <applicat1ve> snoyberg at least has this, that Pipes take 4 >> drop 5 >> take 6 isn't quite what one expects
09:35:06 <kuribas> mm_freak: Then I don't have pattern matching, and overhead because of bounds checking.
09:35:21 <ocharles> applicat1ve: hm?
09:35:23 <ski> (nitpick : fields aren't polymorphic)
09:35:31 <ocharles> applicat1ve: that doesn't take 4 elements, then drop 5, then take 6?
09:35:39 <applicat1ve> oh wait, it's drop 5 >> take 5 >> drop 5 >> take 5
09:35:45 <mm_freak> kuribas: how about a more generic type…
09:35:45 <applicat1ve> ocharles: no
09:35:51 <ocharles> is that because of how termination works?
09:36:08 <applicat1ve> ocharles: drop 5 = drop 5 >> cat
09:36:09 <mm_freak> kuribas: type Tuple a b = forall r. (a -> b -> r) -> r
09:36:29 <mm_freak> kuribas: that one can use any representation you want
09:36:52 <kuribas> neat
09:37:05 <applicat1ve> ocharles: after you drop n, youre committed to taking the rest forever
09:37:14 <applicat1ve> its, drop 5 >> take infty
09:37:23 <ocharles> applicat1ve: oh, I see
09:37:28 <applicat1ve> I'm not sure this is wrong
09:37:39 <ocharles> so yes, vertical composition is the wrong operator
09:38:09 <ocharles> anyway, better get home
09:38:19 <applicat1ve> but you can of course define drp so that drp 5 >> take 5 >> drp 5 >> take 5 works as snoyberg wants
09:38:49 <ocharles> can't help but read that as 'derp 5 >> take 5'
09:39:11 <applicat1ve> ha
09:39:44 <donri> i read it as "drip"
09:41:07 <DMcGill> mm_freak: how is that not a read-only type?
09:41:23 <DMcGill> write-only even
09:41:36 <mm_freak> DMcGill: what is that?
09:41:54 <DMcGill> you have such a Tuple a b and then what you actually have is forall r. r which you can't do anything with surely?
09:42:17 <mm_freak> DMcGill: consider fst :: Tuple a b -> a
09:42:30 <mm_freak> DMcGill: that's actually:  (forall r. (a -> b -> r) -> r) -> a
09:42:39 <DMcGill> ooh, you instantiate the r
09:42:47 <mm_freak> yeah
09:42:50 <mm_freak> you set r = a
09:43:11 <mm_freak> so fst f = f (const id)
09:43:18 <mm_freak> and snd f = f const
09:43:59 <mm_freak> finally there is:  fromTuple (x, y) = \f -> f x y
09:43:59 <jartur> mm_freak: So you have just pulled this out of your head?
09:44:01 <DMcGill> is the the Church encoding?
09:44:03 <jartur> Just like that?
09:44:12 <mm_freak> jartur: it's simple church encoding
09:44:44 <mm_freak> jartur: sums in your type correspond to different function arguments, products correspond to a function argument with multiple arguments
09:44:59 <DMcGill> I have studied this stuff, honest
09:44:59 <mm_freak> jartur: a pair is a product type, so it's a function of a function of two arguments
09:47:01 <mm_freak> jartur: another way to look at this is:  you represent a type as its fold
09:47:02 <jartur> mm_freak: Yeah, it makes some sense. Although I still can't follow what is going on with that forall r.
09:47:05 <applicat1ve> newtype Loopy m a = Loopy {runLoopy :: ContT (Loopy m (Loopy m a)) (Loopy (ContT a (Loopy m))) a}
09:47:14 <mm_freak> type Maybe a = forall r. r -> (a -> r) -> r
09:47:25 <mm_freak> compare that to:
09:47:27 <mm_freak> :t maybe
09:47:41 <mm_freak> oh, lambdabot is gone
09:47:56 <mm_freak> compare that to:  maybe :: r -> (a -> r) -> Maybe a -> r
09:48:08 <elliott> sigh
09:48:12 <elliott> why does lambdabot ping out constantly
09:48:20 <chrisdone> elliott: where's it hosted?
09:48:31 <elliott> chrisdone: a linode in london :P
09:48:33 <DMcGill> type Either a b = forall r. (a -> r) -> (b -> r) -> r
09:48:35 <DMcGill> right?
09:48:36 <mm_freak> jartur: a tuple is a function that promises to work "for all" r =)
09:48:38 <elliott> connecting to a freenode server in london.
09:48:41 <mm_freak> DMcGill: yeah
09:48:47 <haasn> DMcGill: if you squint hard enough
09:48:48 <chrisdone> elliott: aha. i also had a linode in london =p
09:48:56 <DMcGill> I do remember my Church encoding!
09:49:01 <chrisdone> but i've never had connectivity issues, that's odd
09:49:05 <mm_freak> hehe
09:49:36 <elliott> chrisdone: I think it's just that lambdabot is sort of crap.
09:49:56 <haasn> DMcGill: or your scott encodings? I can never remember which one is which!
09:50:08 * ski . o O ( `data Conty m a = C (forall n o p. MonadStack m n => (a -> (o -> n p) -> n p) -> (o -> n p) -> n p)' )
09:50:09 <mm_freak> type List a = forall r. a -> (a -> r -> r) -> r
09:50:11 <jartur> mm_freak: Btw why are existential types annotated with forall in Haskell? I forgot all the stuff...
09:50:17 <chrisdone> elliott: ISTR that running lambdabot on our VPS server at work  in the past would also ping out
09:50:17 <mm_freak> foldr f z l = l f z
09:50:17 <mm_freak> =)
09:50:25 <ski> jartur : because the constructor is polymorphic
09:50:28 <DMcGill> haasn: given that I've never studied Scott stuff and knew that I can only assume it's Church.
09:50:46 <mm_freak> jartur: the constructor promises to work "for all" given types
09:50:47 <chrisdone> elliott: a decent solution might be to run lambdabot through a VNC bouncer that handles connectivity/reconnecting and such
09:50:58 <elliott> chrisdone: my decent solution is to restart it when I notice it's gone
09:50:59 <mm_freak> jartur: the type is existential, but the constructor is universal
09:51:13 <chrisdone> elliott: that's rubbish =p
09:51:16 <jartur> mm_freak: Oh...
09:51:23 <elliott> chrisdone: would you like to implement the better way? :p
09:51:32 <chrisdone> hpaste is on vnc, it never leaves
09:51:33 <jartur> mm_freak: Okay, my brain is timing out on me
09:51:34 <haasn> DMcGill: https://en.wikipedia.org/wiki/Scott_encoding#Definition -- I'm too tired to make sense of it right now
09:51:49 <mm_freak> jartur: it's "for all" when constructing values, but "there exists" when destructing them
09:51:55 <mm_freak> that's why the constructor is polymorphic
09:52:06 <chrisdone> elliott: sure. give me shell access?
09:52:24 <jartur> mm_freak: Kinda makes sense. Thanks. I'll meditate on it.
09:52:43 <mm_freak> jartur: i found existentials to be easier to understand in terms of GADTs
09:53:06 <elliott> chrisdone: I could give you ~/.lambdabot :P
09:53:12 <chrisdone> lol
09:53:18 <elliott> it's a shame, the code is much cleaned up compared to in the past but it's still so flaky.
09:53:41 <jartur> mm_freak: I have found existentials hard to understand when reading TAPL, probably because I got too tired by the time I have reached them on my first read, gotta repeat that book.
09:54:01 <mm_freak> jartur: note that existentials are strictly optional
09:54:14 <jartur> mm_freak: Then, I kinda got them for some time. But now I don't get them again =)
09:54:23 <jartur> mm_freak: Too little practice.
09:54:37 <chrisdone> elliott: i'm not sure i can be as responsive to the demands of lambdabot as you
09:54:49 <mm_freak> jartur: consider a constructor:  C :: a -> (a -> Int) -> T
09:55:02 <mm_freak> jartur: it constructs a C, but the 'a' is not an argument of T
09:55:03 <jartur> mm_freak: It's like with co(ntra)variance in systems with subtyping. It took several iterations to get (almost) completely.
09:55:07 <mm_freak> jartur: uhm, it constructs a T
09:55:24 <mm_freak> jartur: now when you pattern-match and find a C, you don't learn anything about 'a'
09:55:32 <mm_freak> so all you know is that "there exists" an 'a'
09:55:35 <elliott> chrisdone: occasionally I have to feed it a baby.
09:55:43 <mm_freak> jartur: and that's about it
09:56:07 <chrisdone> elliott: heh, like the little shop of horrors? =p
09:56:15 <jartur> But how I would use such a constructor?
09:56:22 <elliott> chrisdone: horror is right
09:56:53 <mm_freak> jartur: here is an example:  data Auto a = forall s. Auto s (s -> (a, s))
09:57:15 <mm_freak> jartur: that's an automaton…  it contains an abstract "current state" and a state transition function
09:57:48 <jartur> mm_freak: So if I instantiate it I can use it
09:57:57 <jartur> mm_freak: But not deconstruct up to its state
09:58:13 <mm_freak> you can deconstruct Auto, but you don't learn anything about 's'
09:58:19 <mm_freak> the constructor chose 's'
09:58:34 <jartur> mm_freak: Yeah, I meant this by 'up to its state'
09:58:44 <mm_freak> jartur: yeah
09:58:50 <jartur> mm_freak: State is hidden from me as a consumer of the type
09:58:53 <mm_freak> all you know is that there is a function you can apply to the state
09:59:06 <mm_freak> here is a simple counter:
09:59:11 <mm_freak> counter :: Auto Int
09:59:13 <mm_freak> uhm
09:59:16 <mm_freak> counter :: Int -> Auto Int
09:59:20 <mm_freak> counter with starting value
09:59:46 <mm_freak> counter x0 = Auto x0 (\x -> (x, x + 1))
09:59:59 <mm_freak> it starts from its argument, which is its initial state
10:00:02 <jartur> mm_freak: Ah, you beat me to the implementation
10:00:10 <jartur> mm_freak: Wanted to do it as an exercise =)
10:00:14 <mm_freak> oh, sorry
10:00:17 <mm_freak> but no problem
10:00:20 <mm_freak> write a random number generator
10:00:31 <jartur> mm_freak: Hmmm, pseudo?
10:00:34 <jartur> mm_freak: =)
10:00:42 <mm_freak> rnds :: (Random a, RandomGen g) => g -> Auto a
10:01:12 <ReinH> chrisdone: thanks :p
10:02:21 <c_wraith> mm_freak: isn't that type isomorphic to a stream without an existential?  Hmm, I guess the stream could have more bottoms.
10:02:59 <FreeFull> mm_freak: And then you could have   step :: Auto a -> Auto a; step (Auto x f) = case f x of (_,s) -> Auto s f     right?
10:03:52 <FreeFull> Which would only be useful if you don't care about the value when you step
10:03:56 <mm_freak> c_wraith: it is, including the bottoms
10:04:24 <mm_freak> c_wraith: note that the current state can be bottom
10:05:09 <mm_freak> FreeFull: yes, although you would rather have:  step :: Auto a -> (a, Auto a)
10:05:12 <shock_one> Hi. Why does a predicate for foldl has an accumulator on the left side and for foldr on the right?
10:05:35 <FreeFull> mm_freak: Yeah, then you'd have the value too
10:06:06 <mm_freak> shock_one: that's a good question actually…  i'd prefer foldl to have the same type signature as foldr
10:06:16 <elliott> > foldr f z [a,b,c]
10:06:17 <lambdabot>   f a (f b (f c z))
10:06:18 <elliott> > foldl f z [a,b,c]
10:06:20 <lambdabot>   f (f (f z a) b) c
10:06:27 <elliott> shock_one: same order of elements, just different associativity
10:07:08 <c_wraith> mm_freak: well, I was thinking of the fact that a stream has a bunch of constructors that could also be bottoms - the current state being bottom in that construction doesn't prevent evaluation of the function from succeeding, necessarily. a stream constructor being bottom definitely prevents further traversal
10:07:22 <FreeFull> shock_one: You can think of a fold as replacing constructors with values and functions
10:07:42 <FreeFull> So the : constructor gets replaced with a function, and [] with the value
10:08:33 <mm_freak> c_wraith: you can recover the bottom constructors
10:08:46 <mm_freak> there is a 1:1 mapping between bottom constructors and bottom current states
10:10:50 <shock_one> mm_freak: I can easily imagine foldl like this f c (f b (f a z))
10:11:49 <c_wraith> shock_one: if the operation you're folding isn't associative, you're going to find that ordering really confusing
10:12:01 <blume> i'm reading LYAH about applicative functors right now. is it safe to say that <*> is like (.) and <$> is like ($) ?
10:12:12 <c_wraith> shock_one: oh, nevermind, it'd be fine.  I read it wrong.
10:12:18 <haasn> mm_freak: didn't you write some package combining vty and netwire?
10:12:44 <FreeFull> c_wraith: You mean commutative?
10:12:46 <dwcook> blume, (<*>) is application within the applicative. (<$>) is application of a function outside the applicative to something inside.
10:12:47 <shock_one> FreeFull: I'm not sure I understand it. Can you rephrase it?
10:12:54 <pqmodn> blume: no, <*> is more like $ than .; they're all function application of a sort
10:13:09 <pqmodn> :type (<*>)
10:13:11 <pqmodn> :type (<$>)
10:13:11 <dwcook> @type (<*>)
10:13:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:13:13 <ReinH> shock_one: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
10:13:14 <dwcook> Heh
10:13:15 <pqmodn> :type ($)
10:13:23 <pqmodn> argh
10:13:23 <FreeFull> shock_one:  [1,2,3,4] is syntactic sugar for   1:2:3:4:[]
10:13:25 <c_wraith> FreeFull: as a matter of fact, I did mean commutative.  It's clearly not thinking-clearly-o'clock yet
10:13:28 <dwcook> @type (<$>)
10:13:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:14:11 <shock_one> FreeFull: OK, I understand that part. I didn't quite get the things about constructors.
10:14:17 <FreeFull> pqmodn: :t or @type
10:14:17 <dwcook> (<$>) is the same as fmap, by the way, which can be written the same way for any applicative instance: fmap f x = pure f <*> x
10:14:35 <FreeFull> shock_one: The : and [] are constructors
10:15:58 <blume> i wondered why there's no src for <*>
10:16:00 <FreeFull> shock_one: A fold will replace them with what you provide
10:16:17 <FreeFull> blume: There is if you specify which <*> you want
10:16:22 * ski always thought `<$>' would be a more sensible name for what is currently known as `<*>'
10:16:23 <blume> Oh.
10:16:29 <pqmodn> blume, it's an overloaded method just like fmap, so each instance of Applicative defines the implementation
10:16:39 <FreeFull> ski: That's the way it's in idris
10:16:49 <blume> ahh right, because it's just an instance of Applicative.
10:17:24 <blume> ehhh, needs instances.
10:17:24 <dwcook> values defined inside instances are called methods.
10:17:41 <mr-> ski: really? Why? I like foo <$>.. it works just like foo $ .. ;-)
10:17:41 <dwcook> So (<*>) is a method of Applicative.
10:17:44 <shock_one> FreeFull: That makes sense. But I have to think about it. Thank you.
10:18:03 <inkjetunito> wtf<?>
10:18:07 <ReinH> shock_one: foldr (:) [] [1,2,3] = 1:2:3:[]
10:18:12 <FreeFull> shock_one: You can fold over data structures that aren't lists too
10:18:16 <ReinH> foldr (+) 0 [1,2,3] = 1+2+3+0
10:18:48 <ski> mr- : why not `pure foo <*> ...' ? :)
10:19:11 <blume> dwcook: thanks, it's becoming clearer
10:19:17 <ski> > foldr (+) 0 [1,2,3] :: Expr
10:19:18 <FreeFull> ski: Needs extra brackets sometimes
10:19:19 <lambdabot>   1 + (2 + (3 + 0))
10:19:42 <FreeFull> > const 3 <$> [1,2,3,4]
10:19:43 <lambdabot>   [3,3,3,3]
10:19:49 <ski> FreeFull : ok, so :  foo `liftA` ...
10:19:51 <FreeFull> > pure (const 3) <*> [1,2,3,4]
10:19:52 <lambdabot>   [3,3,3,3]
10:20:00 <joelteon> > [1,2,3] <*> [2,3,4]
10:20:01 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:20:01 <lambdabot>    arising f...
10:20:19 <ReinH> shock_one: the wikipedia page I linked does a good job of explaining it, including pretty diagrams :)
10:20:29 <pqmodn> pure max <*> [3,2,1] <*> [1,3,2]
10:20:33 <pqmodn> > pure max <*> [3,2,1] <*> [1,3,2]
10:20:34 <lambdabot>   [3,3,3,2,3,2,1,3,2]
10:21:06 <shock_one> ReinH: I'll read it, thank you. Sorry, at first I thought that you're trying to show me what fold is.
10:21:19 <blume> > max <$> [3,2,1] <*> [1,3,2]
10:21:20 <lambdabot>   [3,3,3,2,3,2,1,3,2]
10:21:42 <FreeFull> > max <$> ZipList [3,2,1] <*> ZipList [1,3,2]
10:21:43 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList b0))
10:21:43 <lambdabot>    arising...
10:21:52 <FreeFull> > getZipList (max <$> ZipList [3,2,1] <*> ZipList [1,3,2])
10:21:53 <ski> mr- : anyway, i think it fits better with reflective syntax
10:21:53 <lambdabot>   [3,3,2]
10:22:17 <kuribas> I have defined "data Path = Path Point [(PathJoin, Point)]".  Would it be more idiomatic to defined a datatype instead of the tuple?
10:22:24 <FreeFull> @let instance show ZipList where show (ZipList xs) = "ZipList " ++ show xs
10:22:24 <lambdabot>  Parse failed: Illegal instance declaration
10:22:35 <FreeFull> @let instance Show ZipList where show (ZipList xs) = "ZipList " ++ show xs
10:22:35 <lambdabot>  .L.hs:145:15:
10:22:36 <lambdabot>      Expecting one more argument to `ZipList'
10:22:36 <lambdabot>      In the inst...
10:22:42 <pqmodn> ZipList a?
10:22:43 <FreeFull> @let instance Show (ZipList a) where show (ZipList xs) = "ZipList " ++ show xs
10:22:43 <lambdabot>  .L.hs:146:43:
10:22:44 <lambdabot>      No instance for (Show a) arising from a use of `show'
10:22:44 <lambdabot>    ...
10:22:44 <ski> kuribas : maybe
10:22:48 <jartur> mm_freak: Sorry for taking so long. I have spent a lot of time checking it (my Haskell s oh so very rusty)
10:22:51 <jartur> mm_freak: rnds gen = Auto gen random
10:22:52 <FreeFull> @let instance Show a => Show (ZipList a) where show (ZipList xs) = "ZipList " ++ show xs
10:22:53 <lambdabot>  Defined.
10:22:56 <FreeFull> Sorry, sleepy
10:23:03 <dwcook> > ZipList [1, 2, 3]
10:23:07 <ski>   newtype ZipList a = ZipList {getZipList :: [a]}  -- pqmodn
10:23:09 <lambdabot>   ZipList [1,2,3]
10:23:11 <kuribas> Or define "data Path = Path Point Join Path | EndPath Point"
10:23:51 <ski> @undefine
10:23:52 <lambdabot> Undefined.
10:23:55 <ski> @let instance Show a => Show (ZipList a) where showsPrec p (ZipList xs) = showParen (p > 10) $ showString "ZipList " . showsPrec 11 xs
10:23:55 <pqmodn> ski: oops, i meant to suggest to FreeFull why his instance failed (missing the type parameter). thanks though :)
10:23:56 <lambdabot>  Defined.
10:24:08 <ski> FreeFull : that's how you do it
10:24:12 <FreeFull> pqmodn: It failed because I'm half asleep
10:24:12 <mr-> ski: reflective syntax?! ;-)
10:24:15 <jartur> mm_freak: But wouldn't it make more sense as a monad? Like state? Or there are usage patterns for both styles?
10:24:47 <elliott> ski: you can also @let deriving instance Show a => Show (ZipList a)
10:24:49 <ski> mr- : an idea of mine, based on idiom brackets
10:24:53 <FreeFull> ski: Oh come on, "ZipList " isn't that big of a string to traverse =P
10:25:05 <mm_freak> haasn: i don't work on that project right now
10:25:38 <mm_freak> jartur: your 'rnds' implementation is correct
10:25:43 <ski> FreeFull : with your version, `show (Just (ZipList []))' would have produced `"Just ZipList []"'
10:26:06 <mm_freak> jartur: i try to avoid State
10:26:15 <ski> elliott : *nod*
10:26:23 <mm_freak> jartur: but you will find that Auto is actually an applicative functor
10:26:43 <FreeFull> ski: Oh, you're right
10:26:46 <mm_freak> jartur: it's a state functor, too, but the concept of Auto is orthogonal to the one of State
10:27:13 <mm_freak> jartur: in State a computation doesn't have intrinsic state and state flows "downwards"
10:27:30 <ski> mm_freak : .. and "upwards" ?
10:28:03 <mm_freak> jartur: in Auto computations have intrinsic state that only flows when they expose it
10:28:11 <mm_freak> so state is local
10:28:24 <mm_freak> ski: ?
10:28:27 <ReinH> mm_freak: where is Auto?
10:28:48 <ski> <mm_freak> jartur: here is an example:  data Auto a = forall s. Auto s (s -> (a, s))
10:28:52 <mm_freak> ReinH: it's usually an arrow defined by many libraries, including edwardk's 'machines' library
10:29:15 <mm_freak> ski: oh, that's not a state monad
10:29:33 <mm_freak> ski: it was an example for existential types
10:29:37 <ski> mm_freak : i always thought of as the state being threaded both "downwards" and "upwards" in `State s a'
10:29:49 <wagle> nominolo: i found your example, iirc
10:29:57 <ski> (mm_freak : i know. i repasted it for the benefit of ReinH)
10:30:07 <mm_freak> oh, ok
10:30:21 <jartur> mm_freak: Thank you very much.
10:30:30 <mm_freak> ski: in a >>= b, a knows nothing of b, and b knows nothing of a, but (>>=) knows to pass the state on rightwards
10:30:40 <mm_freak> i called that one "downwards"
10:30:56 <ski> but it is passed upwards out of `a' there as well
10:31:05 <mm_freak> how?
10:31:06 <ski> (and downwards into `a', and upwards out of `b')
10:31:17 <mm_freak> or rather in what sense?
10:31:48 <pqmodn> in the sense that Reader can only pass the environment /down/ into subcomputations, but state can pass the environment /up/ from a subcomputation to another?
10:32:13 * FreeFull haskells erkin
10:32:17 <erkin> ;_;
10:32:21 <mm_freak> i don't understand it
10:32:23 <ski>   runState (ma >>= amb) s0 = (b,s2)
10:32:25 <ski>     where
10:32:32 <ski>     (a,s1) = runState ma s0
10:32:37 <ski>     (b,s2) = runState (amb a) s1
10:33:08 <mm_freak> ski: there doesn't seem to be any leftward information flow
10:33:19 <mm_freak> i mean there are RState and Tardis
10:33:35 <mm_freak> for which state flows left and in both directions respectively
10:33:58 <ski> clearly `s0' is being passed ("downwards") into `ma >>= amb', and therefore also into `ma' here, and `s1' is passed ("upwards") out of `ma' and ("downwards") into `amb a', and `s2' is passed ("upwards") out of `amb a' (thus also out of `ma >>= amb')
10:34:26 <mm_freak> ski: you may have a different information flow graph in mind
10:34:26 <ski> yes, leftwards/backwards is of course different
10:35:09 <mm_freak> for a >>= f my mental image looks like this:  ->- a =>= f =>=
10:36:28 <ski> yes
10:36:42 <ski> so, into and out of `a', then into and out of `f'
10:37:42 <FreeFull> a >>= f = join (fmap f a)   obviously
10:37:53 <S_J> Can I do nonblocking receive on a socket?
10:38:16 <mm_freak> S_J: yes, use a concurrent reader
10:38:27 <FreeFull> S_J: I think most people just have a separate thread for networking
10:40:08 <S_J> freefull: yes but then id need a separate thread for receiving...
10:40:26 <S_J> i need to check for timeouts so i cant block on a receive
10:40:30 <FreeFull> S_J: Ah, good point
10:41:00 <mm_freak> S_J: there are two ways to do it
10:41:21 <mm_freak> S_J: write a separate receiver thread and kill it after a timeout (for example using STM, which has a predefined timeout register)
10:41:34 <mm_freak> S_J: or use System.Timeout which basically does this =)
10:41:36 <S_J> basically what im doing is writing a general server that both handles rquests and also sends and receives keepalive msg:s.
10:42:21 <joelteon> except timeout takes an Int
10:42:23 <joelteon> :|
10:42:25 <mm_freak> S_J: for servers you would usually work with client threads
10:42:49 <mm_freak> joelteon: an Int of microseconds
10:43:09 <S_J> mm_freak: i already have a client thread... but each client-servwr connection needs to be checked for timeouts
10:43:28 <mm_freak> S_J: the thread can fire up a timeout thread
10:43:39 <mm_freak> S_J: or, again, use STM
10:43:44 <mm_freak> see registerDelay
10:45:29 <acomar> bleh, anyone know of a way to get ghci to handle a dynamically linked library? I'd like to test a binding to a C/C++ library I'm writing, but I can't actually load it into ghci (unknown symbl __dso_handle)
10:46:45 <S_J> mm_freak: but what if 2 threads use the same socket at the same time? what will happen, will one block waiting for the other or the result will be garbled or it is undefined?
10:47:46 <NemesisD> anyone use cassava in here? i noticed incremental streaming isn't a thing
10:47:57 <mm_freak> S_J: why would that happen?
10:48:01 <mm_freak> S_J: you have a reader thread
10:48:14 <mm_freak> which communicates using an MVar or a TVar
10:48:18 <NemesisD> is the idea to build up vectors in chunks and stream the bytestrings it generates to a file, so that you manage the chunk size?
10:50:37 <NemesisD> actually i can't imagine that working well for csvs with headers...
10:53:10 <S_J> mm_freak: well anyway i want the reader to listen for any messages and i also want to send and receive keepalive msgs on the same socket.
10:53:22 <mm_freak> S_J: are you using any streaming abstractions?  like pipes or conduit
10:55:35 <donri> NemesisD: what do you mean "isn't a thing"
10:56:25 <disgrntld> Hello, can y'all recommend a source to learn about the details of lazy evaluation (specifically how pattern matching seems to happen but evaluation doesn't, what's a thunk, etc.)? I'm trying to understand how foldl, being tail-recursive, can overflow the stack.
10:57:21 <ski> it's not `foldl' itself, but the computation it builds
10:57:32 <ski> (and returns)
10:57:45 <monochrom> disgrntld: see my http://www.vex.net/~trebla/haskell/lazy.xhtml
10:57:53 <monochrom> "thunk" means expression
10:58:10 <S_J> mm_freak: no, im writing my own abstraction over tcp. i know how to do this in C but im trying to figure it out in haskell. id use select in C to for nonblocking action but it does not seem to be in the Socket lib.
10:58:15 <sipa> unevaluated expression
10:58:39 <disgrntld> ski, I guess I don't understand how a foldr on an infinite list can, in certain situations where the second parameter of the function is ignored, _doesn't_ overflow
10:58:42 <joehillen> disgrntld: I found this really helpful https://en.wikibooks.org/wiki/Haskell/Graph_reduction
10:58:50 <mm_freak> S_J: well, one important thing to keep in mind is that not only is it very cheap to create threads, it's also the normal way to do it
10:58:50 <disgrntld> monochrom, I'll check that out
10:58:56 <disgrntld> thanks joehillen, that too
10:58:56 <mm_freak> S_J: a haskell thread is not an OS thread
10:59:00 <donri> disgrntld: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
10:59:00 <shock_one> ReinH: FreeFull: Could you guy recommend a good book about Haskell, please?
10:59:01 <ski> @quote lazy.bottom
10:59:01 <lambdabot> newsham says: lazy bottoms thunk empty thoughts
10:59:06 <shock_one> guys
10:59:09 <mm_freak> S_J: i mean haskell threads are not OS threads
10:59:31 <FreeFull> shock_one: I started with Learn You A Haskell and then went on without any other books
10:59:35 <mm_freak> S_J: in particular two haskell threads blockingly reading from a handle translate to a single epoll on the two handles
10:59:37 <ocharles> mm_freak: i got integralWith rewritten, but unfortunately in a ArrowLoop it appears to destroy laziness. one sec while I paste
10:59:55 <mm_freak> ocharles: if you write it to depend on 'now' you need an explicit delay
11:00:15 <ocharles> it doesn't have any real dependencies
11:00:25 <ocharles> the 'future' binding is just 'returnA -< False'
11:00:30 <mm_freak> ocharles: it certainly depends on the input value, doesn't it?
11:00:31 <shock_one> FreeFull: That's what I'm reading. But it looks like you have some deep knowledge how it works. Maybe, if not a book, some other materials?
11:00:34 <ski> disgrntld : come into #haskell-overflow ?
11:00:41 <S_J> mm_freak: but if i have one sending thread and one reading, can they interfere with each other ont he same socket?
11:00:52 <ocharles> mm_freak: http://lpaste.net/4532338168376066048 is enough to cause it to hang
11:00:57 <mm_freak> S_J: if one strictly sends, the other strictly reads, then no
11:01:12 <ocharles> if I don't observe 'wouldIntersect' (removing the Monad.when), it's fine
11:01:22 <FreeFull> shock_one: If you're interested in the implementation, there is stuff on how GHC works
11:01:25 <ocharles> but 'wouldIntersect' doesn't seem to have any dependencies. should I be delaying that anyway?
11:01:51 <ocharles> (using a State.Lazy for the monad)
11:01:56 * lpsmith is scratching my head,  I'm getting an "unrecognized pragma" warning in GHC 7.6.3 on {-# LANGAUGE FlexibleInstances #-}
11:02:05 <lpsmith> oh nm
11:02:08 <ocharles> lpsmith: :)
11:02:18 <ocharles> lpsmith: #haskell is glad to be your rubber duck
11:02:29 <donri> LANGURGRBLDERP
11:02:50 <shock_one> FreeFull: Oh, what a pleasure. It's written in Haskell. It's the first compiler I know which isn't written in C. Surely I want this stuff.
11:02:57 <FreeFull> lpsmith: Maybe it should give suggestions
11:03:48 <Peaker> shock_one: I think most compilers tend to be written in the language they're compiling (eating own dogfood)
11:04:01 <lpsmith> FreeFull, ehh,  this one was basic enough,  I just wasn't looking at the right thing
11:04:09 <lpsmith> Suggestions aren't always helpful
11:04:25 <FreeFull> Peaker: I know the idris compiler/interpreter is written in Haskell and will probably be never written in idris
11:04:26 <shock_one> Peaker: Java, Python, Ruby, PHP...
11:04:37 <lpsmith> Although I suppose it wouldn't be difficult to give the right suggestion in this *particular* case.
11:05:21 <FUZxxl> Hello!
11:05:33 <prototrout> Hi!
11:05:35 <FreeFull> Peaker: Having a compiler be written in the language it compiles is a big pain if the language is receiving breaking changes
11:05:39 <shock_one> Peaker: OK, javac is written in Java, but JVM is in C.
11:05:44 <Peaker> shock_one: Python's interpreter is written in C, but interpreters tend to be written in differing languages. PyPy is Python's JIT/compiler, written in Python
11:05:45 <ocharles> mm_freak: ok, so 'second (first (delay False)))' does work... so i guess i'm not quite up to scratch on arrow loops :)
11:05:46 <FUZxxl> Someone told me that HM type inference does not work well in imperative languages. Why is that so?
11:06:00 <Peaker> FreeFull: why?
11:06:16 <Peaker> shock_one: it's a recurring theme: interpreters/rts's/vm's written in C, compilers in same-language
11:06:30 <Peaker> shock_one: GHC's RTS (somewhat similar to the role of a VM) is also in C
11:06:57 <FreeFull> Peaker: Because you have to change the compiler to compile the new version of the language, compile that with the old compiler, then change the compiler to be written in the new version, and compile again
11:07:02 <k0001> Peaker: I think PyPy it's not written Python but in RPython, a subset of Python.
11:07:21 <donri> but most of pypy is python, innit
11:07:28 <geekosaur> now consider what FreeFull said in the context of porting to new platforms...
11:07:31 <donri> rpython is their Core, rather? not sure
11:07:56 <monochrom> . o O ( runhugs monochrom's_haskell_interpreter.hs test.hs )
11:08:32 <Peaker> FreeFull: you can use the old version of the compiler to compile the compiler, or fix the compiler, the breaking change aches only as much as fixing broken code, regardless of the fact the compiler is the one that broke
11:08:33 <FreeFull> geekosaur: Yeah, unless you have one compiler that compiles for all possible platforms
11:08:36 <monochrom> in fact, I have an SECD machine written in haskell :)
11:09:02 <FreeFull> Peaker: But the old old compiler isn't compatible with the fixed code anymore
11:09:08 <monochrom> (it uses super-slow haskell lists for stacks :) )
11:09:21 <smith_> FreeFull: So you don't compile the fixed code with the old compiler.
11:09:31 <donri> haskell lists are really fast though
11:09:35 <FreeFull> smith_: So you need the two stages :)
11:09:53 * hackagebot linux-evdev 0.1 - Bindings to Linux evdev input device interface.  http://hackage.haskell.org/package/linux-evdev-0.1 (BenGamari)
11:09:53 <FreeFull> old, seminew, new
11:11:12 <w0rm_x> anyone joining the Haskell eXchange conference?
11:11:25 <int-e> FUZxxl: ML can be used like an imperative language and has a HM type system with a restriction on generalisation ("value restriction"), so I would question the claim and inquire about the features that "imperative" is intended to imply.
11:11:51 <mm_freak> ocharles: something like this should always work:  loop (delay . w)
11:11:52 <shock_one> FreeFull: I think it's very automatizable.
11:12:11 <mm_freak> ocharles: or rather:  loop (second delay . w)
11:12:15 <FUZxxl> int-e: He described that there are problems with assignments but I am a bit fuzzy about the details (that's why I'm asking here)
11:12:15 <int-e> (perhaps people expect implicit conversions? those don't play so nicely with the type system, afaik.)
11:12:22 <ReinH> donri: RPython is a constrained subset of Python that allows compile-time type inference
11:13:02 <shock_one> FreeFull: You can make a builder which would compile compiler three times or so for you .
11:13:05 <mm_freak> ocharles: or rather:  loop (second (delay x0) . w)
11:13:06 <monochrom> FUZxxl: have you tried asking the author?
11:13:25 <FUZxxl> int-e: They don't. Go for instance, has (almost) no implicit type conversions. The only one being automatic conversions between pointers and values.
11:13:27 <mm_freak> ocharles: in arrow notation that corresponds to:  rec (x, y) <- delay something -< (x', y'); …; x' <- …; y' <- …
11:13:30 <FreeFull> shock_one: You still have to modify the compiler's source code twice
11:13:38 <mm_freak> ocharles: in other words, when in doubt you can always delay everything
11:14:05 <FUZxxl> monochrom: I don't know his name. We chatted irl but I don't know him.
11:14:14 <ocharles> mm_freak: yes, but that feels like a rather large hammer
11:14:20 <FreeFull> mm_freak: Pointer value conversions don't sound safe
11:14:24 <monochrom> that's too bad. but I won't speak for the author.
11:14:31 <monochrom> don't you love hearsay
11:14:45 <ocharles> i'd rather know when i need to delay a bit more. but when i wrote 'wasIntersecting <- delay False -< isNowIntersecting' and worked with 'wasIntersecting' instead, it feels like it makes sense
11:14:57 <FUZxxl> monochrom: Yeah, I heard some people do.
11:15:06 <monochrom> and rumours spread in the hallways during ICFP
11:15:52 <monochrom> speaking of which, is hackage switching to new hackage real soon now? they said "during ICFP"
11:16:01 <FreeFull> shock_one: http://ghc.haskell.org/trac/ghc/wiki/Commentary
11:16:12 <mm_freak> FreeFull: ?
11:16:30 <mm_freak> ocharles: that large hammer may become the default when every wire gets strict
11:16:32 <FUZxxl> Anyway; languages w/o gc suck
11:16:42 <donri> but rust!
11:16:52 <FreeFull> mm_freak: Implicit ones, like you said golang has
11:16:58 * FUZxxl is too lazy to bring out his garbage
11:17:11 <mm_freak> FreeFull: what did i say?
11:17:22 <monochrom> for a few years in the past, jhc did not have gc :)
11:17:40 <FreeFull> mm_freak: Oh sorry, I meant FUZxxl >_<
11:17:44 <mm_freak> ah =)
11:17:59 <FUZxxl> monochrom: Yeah, I figured that out the hard way. (Involved holding down my machine's power button for a few secs)
11:18:30 <FUZxxl> FreeFull: The only case where there is an automatic type conversion in golang could be cut out without much pain for anybody.
11:18:32 <mm_freak> ocharles: in fact i might build that delay into 'loop'
11:18:44 <mm_freak> ocharles: no, i won't
11:18:47 <mm_freak> it's not possible =/
11:19:05 <shock_one> FreeFull: Thank you.
11:19:20 <FreeFull> shock_one: I haven't read it myself so I don't know how easy it is to understand
11:19:34 <FUZxxl> It's the special case that methods can have either a call-by-name or a call-by-value receiver. To abstract this away, the language automatically adds the needed & or *
11:19:35 <ocharles> alright, here's what my working code now, mm_freak
11:19:36 <ocharles> http://lpaste.net/5305101285706432512
11:19:39 <ocharles> i'm pretty happy with that
11:19:53 * hackagebot primitive 0.5.1.0 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.1.0 (BryanOSullivan)
11:20:04 <ocharles> the velocity correction stuff feels like it's composable (I can break that up into smaller monadic actions), and I didn't have to invent too much intermediate state
11:21:01 <FreeFull> Any news on sdl 2 haskell bindings?
11:21:13 <ocharles> FreeFull: we're working on it, and have got quite far
11:21:23 <ocharles> FreeFull: http://github.com/Lemmih/hsSDL2 I think is the URL
11:21:40 <ocharles> the code I just pasted is SDL 2 :)
11:22:03 <FreeFull> ocharles: I think it'd be good if the module was Graphics.UI.SDL2
11:22:21 <FreeFull> Since people might want to have both SDL 1 and 2 installed at the same time
11:22:27 <chrisdone> SDL 2: The Renderer Strikes Back
11:22:49 <ocharles> FreeFull: I'd say open an issue for now
11:23:41 <monochrom> (and SDL 3: The Return of Event Loop?)
11:23:42 <Ralith> FreeFull: they can be installed at the same time just fine; one probably wouldn't want to use them both from the same program, though.
11:24:45 <FreeFull> Ralith: How would you disambiguate without passing flags?
11:26:32 <Ralith> FreeFull: by using cabal like a sane person
11:27:36 <mm_freak> ocharles: nice, though later you will want to work with scene deltas instead of closures
11:28:10 <FreeFull> Ralith: What if you're just messing around in ghci?
11:28:12 <cbw> I am pretty new haskell. I have been learning that there are a bunch of ways to do the same things. I wrote some vector and matrices add functions using recursion, list comprehension, and higher order functions. Which is better to use? Is there a rule of thumb?
11:28:16 <cbw> https://gist.github.com/SirEigen/6688948
11:29:03 <mm_freak> FreeFull: would a single haskell program want to use both SDL 1 and SDL 2?
11:29:19 <FreeFull> cbw: Higher order functions tend to be preferred, although use recursion if it looks clearer
11:29:24 <chrisdone> cbw: avoid recursion unless you really need it for performance/best way to express the problem, higher order functions are most often best and extensible, list comprehensions… if you can use the, great. i tend to find most people don't really use them that often but they have their uses
11:29:54 <Ralith> FreeFull: 'cabal repl'
11:30:00 <FreeFull> mm_freak: There is nothing SDL 1 offers that SDL 2 doesn't, so probably not
11:30:12 <MasseR> What are your solutions to emacs + cabal sandbox?
11:30:17 <FreeFull> Ralith: Unrecognised command
11:30:29 <ocharles> mm_freak: sure, just figuring out collisions
11:30:30 <inkjetunito> is recursion fast or slow on haskell?
11:30:31 <mm_freak> FreeFull: then i see no reason to rename the modules
11:30:40 <monochrom> recursion is fast
11:30:48 <inkjetunito> monochrom: thanks
11:30:49 <Ralith> FreeFull: update your cabal
11:30:50 <ocharles> mm_freak: though i'm not even sure if partial rendering really makes sense for platformers
11:30:55 <ocharles> but we'll see later
11:31:03 <chrisdone> FreeFull: it's for a recent cabal.  cabal update ; cabal install cabal-install # if you're confident it won't break everything
11:31:14 <FreeFull> Ralith: My distro doesn't have a newer one yet
11:31:23 <chrisdone> pfft, distros shmistros
11:31:27 <Ralith> FreeFull: don't use a distro-packaged cabal
11:31:30 <monochrom> cbw: follow your heart. write what looks best to you.
11:31:31 <mm_freak> ocharles: think of enemies…  you will want to add and remove a turtle without access to the full scene data structure
11:31:41 <FreeFull> I prefer to use the distros packages over cabal unless what I want isn't available
11:31:42 <chrisdone> monochrom: use the thunk, luke
11:31:47 <mm_freak> ocharles: in fact wires should not know that you are using vertex arrays
11:32:01 <chrisdone> monochrom: embrace the strict side of the force
11:32:04 <cbw> lol, so higher order > list com > recursion.
11:32:18 <chrisdone> i don't remember the last list comprehension i used
11:32:46 <monochrom> "higher order > list com > recursion" is exactly what I disagree with
11:32:52 <FreeFull> Ralith: Well, I suppose it won't hurt to upgrate cabal locally
11:32:58 <FreeFull> upgrade*
11:33:10 <cbw> I like the higher order the best but I am still in the OMG haskell faze so it all looks cool
11:33:18 <mm_freak> cbw: in haskell you use high level abstractions and leave making tight recursions to the compiler
11:33:34 <ocharles> mm_freak: oh, you meant deltas in a different way
11:33:38 <ocharles> i thought you meant deltas for the rendering
11:33:38 <osfameron> list comprehensions are just a convenient syntax for some commonly used higher order functions
11:33:45 <mm_freak> ocharles: scene deltas
11:33:46 <ocharles> when it comes to dynamic collections, i have no idea how i'll do that yet :)
11:34:02 <ocharles> maybe I should start looking at that next
11:34:42 <mm_freak> ocharles: type SceneDelta = [SceneCommand]
11:34:49 <mm_freak> ocharles: which is a convenient monoid, so you can use MonadWriter
11:34:53 <donri> chrisdone: i seem to sometimes favor list comprehensions if a map/filter version would require a lambda or really crazy point-free style
11:35:25 <mm_freak> ocharles: data SceneCommand = AddTri TriId TriData | DelTri TriId | AddTexture TexId TexData | DelTexture TexId | …
11:35:28 <chrisdone> i think the only times i use list comprehensions is if i'm zipping on more than two lists
11:35:47 <mm_freak> ocharles: then leave building vertex arrays and texture names to the outer loop
11:35:47 <donri> yeah, that too
11:35:55 <chrisdone> e.g. [ f x y z | x <- [1..], <- y <- [1..], z <- [1..], x /= z ] or w/e
11:36:01 <monochrom> and http://lpaste.net/edit/40738 is why I disagree with "higher order > list com > recursion"
11:36:03 <ocharles> mm_freak: so you are talking about rendering :P
11:36:11 <mm_freak> ocharles: yes
11:36:11 <c_wraith> I tend to forget haskell has list comprehensions.
11:36:21 <chrisdone> and the "give me a list" trick to deconstruct things
11:36:28 <mm_freak> ocharles: of course =)
11:36:38 <donri> chrisdone: i used to use MonadComprehensions liberally but lens basically replaced most of those uses
11:36:40 <mm_freak> OpenGL is the only ugly thing you need to hack around after all =)
11:36:40 <chrisdone> > [ x*2 | Just x <- [Just 2] ]
11:36:41 <ocharles> mm_freak: well, that stuff is very low level - that gets abstracted away by SDL
11:36:42 <lambdabot>   [4]
11:36:43 <chrisdone> or w/e
11:36:54 <ocharles> it's just 'drawTexture' and stuff
11:37:11 <mm_freak> ocharles: ok, that may be sufficient for a 2D platformer
11:37:37 <shiona> What was the nice way of creating a list of all possible lists of a fixed length and alphabet?
11:37:48 <mm_freak> shiona: replicateM
11:37:48 <ocharles> i think it will be. I was considering having more abstract commands like you say though
11:37:57 <ocharles> and then working out dirty rectangles to minimize redraw
11:37:58 <mm_freak> > replicateM 3 ['a'..'e']
11:37:59 <lambdabot>   ["aaa","aab","aac","aad","aae","aba","abb","abc","abd","abe","aca","acb","a...
11:38:23 <shiona> mm_freak: ah, thanks. I thought that it was replicate or sequence or something
11:38:39 <mm_freak> shiona: you need 'sequence' when the alphabet is different for each position
11:38:42 <chrisdone> > permutations ['a'..'e']
11:38:43 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde","acbde","dcbae","cdbae","cbdae","d...
11:38:53 <mm_freak> > sequence ["Hh", "Ee", "Ll", "Ll", "Oo"]
11:38:54 <lambdabot>   ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","H...
11:38:58 <shiona> chrisdone: that doesn't include "aaaaa"
11:39:06 <shiona> mm_freak: nice, thanks
11:39:20 <ocharles> mm_freak: pushed integralWith changes to my hub. I think it's ok, but you might need to make tweaks
11:39:31 <ocharles> i gotta run now though, friend has arrived
11:39:32 <mm_freak> ocharles: i'll look over it tonight
11:39:33 <ocharles> thanks for the help!
11:39:38 <mm_freak> alright
11:39:41 <mm_freak> see you
11:39:52 <S_J> are all actions on control.concurrent.Chan blocking? I want a channel: readChan :: Chan a -> Maybe a...
11:40:44 <mm_freak> S_J: yes, they're all blocking (i'm lying a bit)
11:40:53 <bearclaw> Hi, noob question: why is  "instance WHAT (Maybe Int)  where ..." failing ie why can  I only pass type constructors or plain types?
11:40:55 <mm_freak> i'm lying to save you from doing Stupid Things =)
11:40:56 <donri> is there any particular reason a syntax like "data kind ..." wasn't used for DataKinds?
11:41:12 <donri> seems it would've reduced namespacing issues and help documentation
11:41:16 <mm_freak> S_J: you should REALLY learn STM
11:41:32 <mm_freak> S_J: http://chimera.labs.oreilly.com/books/1230000000929
11:41:42 <bearclaw> said differently how is Int different from [Char] or (Maybe Int) in their nature?
11:41:52 <donri> bearclaw: what is the error?
11:42:18 <donri> bearclaw: you need extensions to make instances for types like (Maybe Int), but it could also be a kind mismatch
11:42:21 <Cale> bearclaw: Haskell 98 was extremely conservative about the way that it standardised typeclasses (and H2010 didn't change much), so that feature is an extension.
11:42:38 <monochrom> donri: it depends on "WHAT". the class decides what are allowed.
11:42:40 <bearclaw> Illegal instance declaration for `WHAT (Maybe Int)'  (All instance types must be of the form (T a1 ... an) ...
11:42:45 <donri> bearclaw: [Char] is no different
11:42:49 <monochrom> yikes, not donri, sorry
11:42:53 <Cale> The error you got should mention which extension to turn on.
11:42:56 <monochrom> bearclaw: it depends on "WHAT". the class decides what are allowed.
11:43:06 <mm_freak> monochrom: i think the error is missing FlexibleInstances, so it really doesn't depend on WHAT
11:43:07 <donri> bearclaw: you need extensions or tricks in the class to write instances for [Char]
11:43:09 <bearclaw> I did "class a where ..."
11:43:18 <bearclaw> [Int] cannot match that a?
11:43:19 <ReinH> bearclaw: on a more practical note, you would probably be better off creating a newtype wrapper
11:43:30 <Cale> I believe it's FlexibleInstances
11:43:46 <Cale> "class a where ..." would be a syntax error
11:43:53 <donri> you can also use type families and an equality constraint
11:44:10 <donri> that way you get better inference at the expense (or feature) of not being allowed any other Maybe instances
11:44:11 <Cale> Names of type classes must begin with an uppercase letter, and type classes must have at least one parameter.
11:44:13 <bearclaw> I did "class WHAT a where ..." sorry
11:44:23 <Cale> sure, then that's fine
11:44:29 <Cale> Did you read what I wrote before?
11:44:56 * ReinH still thinks a newtype wrapper is a better solution than adding a bunch of extensions
11:44:58 <mm_freak> donri: 'data kind' syntax would require explicit sorts i think
11:45:12 <donri> mm_freak: hm ok
11:45:13 <mm_freak> data kind Nat :: Sort where
11:45:29 <donri> i was thinking it would figure that out from 'kind'?
11:45:31 <bearclaw> yup, indeed it says "Use -XFlexibleInstances if you want to disable this." (apparently my brain only parses the first line of any error message by default)
11:45:57 <mm_freak> donri: but then you couldn't be explicit about sorts
11:46:18 <bearclaw> but I was curious as to why, becauses it means at some level of modeling Int and [Char] are not the same thing
11:46:29 <monochrom> . o O ( error messages are like legalese. it contains complete information so that later lawyers can say "told you so" )
11:46:45 <donri> bearclaw: you need the same tricks or extensions for [Char]
11:46:56 <donri> it's one of the problems of String
11:47:08 <mm_freak> bearclaw: "[Char]" is syntactic sugar for "[] Char", so it's really a type constructor applied to a concrete type
11:47:24 <hiptobecubic> I can't find an example of a .cabal/config file that shows what I want :( Can someone please tell me what is wrong with the "constraint:" field of this http://bpaste.net/show/135044/ ?
11:47:47 <bearclaw> mm_freak: so "a type constructor applied to a concrete type" like [Char] or Maybe Int is not a concrete type?
11:48:11 <mm_freak> bearclaw: it is, but in h98 type class instances must be type constructors applied to type variables, not concrete types
11:48:29 <mm_freak> bearclaw: that's why [a] and 'Maybe a' are fine, but [Char] and Maybe Int are not
11:48:56 <bearclaw> (being a C++ guy, I read that as you can typeclass a template, but not a specific template instanciation)
11:49:02 <donri> hiptobecubic: whawt's the error
11:49:07 <monochrom> "is it a concrete type" is the wrong question. "how is the type written" is the right question.
11:49:08 <acomar_> what's the reasoning for that? It seems like instances for [Char] are just as useful as instances for Maybe a
11:49:30 <ksf_> acomar_, the reasons are historical.
11:49:46 <ksf_> type classes were new ground back then and noone really understood them well.
11:49:54 * hackagebot vector 0.10.9.0 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.9.0 (BryanOSullivan)
11:49:54 <ksf_> so the comitee played safe
11:49:55 <mm_freak> bearclaw: i'm not sure why it's restricted that way, but typically you would /want/ instances to look like that anyway =)
11:50:04 <ksf_> (haskell was designed by a commitee, as might not be apparant)
11:50:18 <bearclaw> but my analogy with c++ is probably why I don't get that, vector<int> is a type, so is char. No concept in the langage can accept one and not the other
11:50:19 <donri> hiptobecubic: gotta run, sorry
11:50:26 <dcoutts_> hiptobecubic: I'm not sure it accepts a list, I think you may have to repeat the field name
11:50:49 <mm_freak> bearclaw: C++ doesn't have anything that corresponds to haskell type classes
11:51:05 <ksf_> acomar_, there's basically the queston of what instance to choose when you have both instances fro [Char] as well as [a].
11:51:06 <mm_freak> bearclaw: note that type classes are type-bound while C++ classes are value-bound
11:51:14 <hiptobecubic> dcoutts_, oh. :( ok
11:51:21 <ski> @remember monochrom . o O ( error messages are like legalese. it contains complete information so that later lawyers can say "told you so" )
11:51:21 <lambdabot> I will remember.
11:51:21 <hiptobecubic> The error is as follows: http://bpaste.net/show/135048/
11:51:24 <mm_freak> bearclaw: so C++ classes correspond to ADTs in haskell
11:51:26 <ksf_> acomar_, that requires a notion of "more precise type" that is hard to put into semantics.
11:51:43 <acomar_> ksf_: ahh, yea. It seems like a lot of stuff involving type classes seem to come back to that
11:51:51 <tac> bearclaw: If you're confused about the difference between Maybe Int and Maybe a..... The "a" there is a free variable (while Int is predefined). A typeclass can only accept a type that has a free variable in it.
11:52:12 <bearclaw> traits seems to me quito close to type classes
11:52:19 <ski> tac : `class' or `instance' ?
11:52:35 <monochrom> I wouldn't be so liberal with analogies. but I am not you.
11:52:48 <tac> err ski I'll defer to you on the correct spelling of my thoughts >_<
11:52:53 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html  #0
11:52:59 <bearclaw> yes, as I've just proven reasoning this way can be misleading
11:53:26 <mm_freak> bearclaw: in any case the restriction you are facing has historical reasons
11:53:44 <acomar_> tac: if that were the case, then you wouldn't be able to give type class instances for Int and Char; it's just that if you want to use a type constructor you have to provide a free variable
11:53:48 <mm_freak> bearclaw: if you're really sure that you need this (think twice!) you can enable the FlexibleInstances extension
11:54:06 <ski> monochrom : is that like "XY problem" ?
11:54:16 <monochrom> hahaha
11:54:47 <mm_freak> bearclaw: note that "instance X (F A)" is usually better written as:  instance (Y a) => X (F a)
11:54:57 <levi> C++ 'concepts', which did not make it into C++11, are probably the most similar thing in the C++ world to type classes. But even those are not exactly the same.
11:55:11 <hiptobecubic> dcoutts_, yes it works by just making multiple constraint: entries. Thanks.
11:55:18 <monochrom> anyway, do you really have a reason to: the Maybe Int instance does one thing, the Maybe Bool instance does an unrelated thing, and there is no Maybe Char instance?
11:55:36 <dcoutts_> hiptobecubic: ok good, sorry about that
11:56:17 <monochrom> because one would hope that you just have a general instance for Maybe t, t arbitrary.
11:56:25 <bearclaw> I think it makes sense to have some typeclass that defines stuff that makes sense with [Int] but not [String] for example
11:56:52 <mm_freak> bearclaw: and in many cases X = Y
11:56:52 <mm_freak> example:  instance (Monoid b) => Monoid (a -> b)
11:56:52 <mm_freak> > (id <> reverse) "abc"
11:56:53 <lambdabot>   "abccba"
11:57:31 <monochrom> I agree with mm_freak's instance (Y a) => X (F a)
11:57:32 <mm_freak> bearclaw: it may make sense in other languages…  it usually doesn't make sense in haskell
11:57:50 <acomar_> so asking again -- anyone know how I can solve my ghci problem (undefined reference to symbol '__dso_handle')?
11:57:55 <mm_freak> bearclaw: you shouldn't try too hard to translate your C++ concepts literally
11:58:12 <acomar_> googling around makes me think it's because ghci can't handle dynamically linked libraries
11:58:13 <mm_freak> bearclaw: a good way to find out how to translate a concept is to ask here =)
11:58:15 <ReinH> mm_freak: well it wouldn't make sense in other languages because other languages don't have type classes
11:58:28 <ReinH> and thinking that other languages' constructs are equivalent is what's getting us into this mess :p
11:58:42 <mm_freak> ReinH: other languages have many ad hoc concepts, and people often try to translate them to haskell and then wonder why it's forbidden
11:58:51 <monochrom> when you say, "has [Int] instance but no [String] instance", you are putting back the ad-hoc into classes, which set out to be less ad-hoc to begin with.
11:58:54 <mm_freak> ReinH: the desire to have these concepts comes from C++-style OOP
11:58:58 <mm_freak> with its subtyping
11:59:23 <ReinH> mm_freak: I'm just responding to "it may make sense in other languages". It wouldn't: they don't have type classes. ;)
11:59:44 <ski> monochrom : perhaps you should add `<a name="0">' or similar ?
11:59:45 <mm_freak> ReinH: the /concepts/ make sense
12:00:11 <mm_freak> haskell just doesn't provide much support in implementing them, because "makes sense" ≠ "is sound" =)
12:00:21 <monochrom> the whole page is too short to benefit from anchors
12:01:07 <ski> heresy !
12:02:07 <ski> mm_freak : .. or maybe from attempting to do logic programming in the type class system
12:02:38 <ReinH> mm_freak: I'm just wary of implying a false equivalence
12:02:52 <bearclaw> come to think of it, what I realy need ultimately is some grasping of the algorithm used by the compiler to "resolve" functions based on arguments types.
12:03:14 <mm_freak> ski: =P
12:03:21 <bearclaw> I believe that's semantically equivalent to "understanding haskell"
12:03:21 <ReinH> bearclaw: there isn't much going on. type classes provide a way for functions at different types to share names
12:03:23 <mm_freak> ReinH: don't worry =)
12:03:33 <ReinH> mm_freak: ok I feel better now thanks ;)
12:03:54 <mm_freak> bearclaw: note that haskell does not have ad hoc polymorphism…  if you write one function, that's really one function
12:04:10 <ReinH> bearclaw: aside from that, the resolution is trivial. You check the name against the (inferred) type(s) of the argument(s).
12:04:18 <mm_freak> bearclaw: that's the main difference to C++ templates:  they discharge into many functions
12:04:39 <bearclaw> not that trivial, this fails for insance: http://pastebin.com/Wq6v5q7f   (typeclass instance on Int, pass 2, bam)
12:04:44 <mauke> I have copied your paste Wq6v5q7f to http://lpaste.net/93345 - pray I don't copy it any further.
12:05:15 <FreeFull> mm_freak: Aren't typeclasses basically have a way to have multiple functions with the same name?
12:05:22 * ski . o O ( `data Zero; data Succ n; class Max m n o | m n -> o; instance Max Zero n n; instance Maz n Zero n; instance Max m n o => Max (Succ m) (Succ n) (Succ o)' )
12:05:28 <ReinH> bearclaw: that has nothing to do with function "resolution"
12:05:39 <ReinH> that has to do with constraints on type class definitions
12:05:40 <monochrom> I am not convinced that knowing instance resolution helps. ok, it tells you what is legal and how legal code behaves. it doesn't tell you what is tasteful.
12:05:54 <bearclaw> mm_freak: hmm, ok, I hadn't understood that
12:05:56 <ski> ReinH : and against the inferred type of the result
12:06:03 <mm_freak> FreeFull: there is no dynamic dispatch, so it's really just multiple functions with similar types
12:06:16 <bearclaw> so it's within that unique function that some dispatching can happen
12:06:33 <mm_freak> FreeFull: note that C++ templates don't correspond to type classes, they simply correspond to quantification
12:06:44 <FreeFull> mm_freak: I've never used C++ templates so I can't really say
12:06:57 <Peaker> mm_freak: with existential types, there is dynamic dispatch
12:07:09 <ReinH> ski: ah, I misread.
12:07:10 <mm_freak> Peaker: how is that dynamic dispatch?
12:07:36 <ski> mm_freak : calling of function arguments is dynamic dispatch
12:07:47 <Peaker> that too, I guess
12:07:59 <Peaker> mm_freak: do you agree C++ vtable dispatch is dynamic dispatch?
12:08:14 <mm_freak> ski: i understand dynamic dispatch as run-time type checking and deciding which function to call based on the result
12:08:26 <mm_freak> Peaker: yes
12:08:47 <Peaker> mm_freak: the difference between C++ vtable dispatch, and   (exists a. Foo a => a) is that the vtable ptr is inside the C++ object, but the existential type there is a tuple of (vtable ptr, object), otherwise the dispatch is the same
12:09:03 <ski> mm_freak : can "run-time type checking and deciding which function to call" simply be "selecting the function at a certain place in a data structure" ?
12:09:25 <mm_freak> the closest thing we have to dynamic dispatch is pattern matching
12:09:55 <bearclaw> I don't get why this fail, I expected (ok the what can be called on the following list of types or type contructors: Int. I have 2 of (Num a)...ah, it can't possibly 'enumerate' the types that 'instanciates' (Num a)
12:10:02 <mm_freak> this is funny
12:10:10 <ski> (sum/variant types are very different from product/record types)
12:10:11 <levi> bearclaw: When you type a number into ghci, the compiler doesn't know what specific type of number it is. If you type '3' the compiler sees 'fromIntegral 3' and needs to know what type to resolve the Num class (which holds the fromIntegral method) with.  So at the ghci prompt, you sometimes need to say (3 :: Int) so it knows what you intend.
12:10:45 <mm_freak> the last time i argued that existentials provide dynamic dispatch almost the whole channel tried to convince me that it's not the same thing
12:10:46 <levi> Because 3 could also be a member of Integer, or Rational, etc.
12:10:54 <bearclaw> I got that, it's not specific to the i in ghci if I get this right
12:10:56 <mm_freak> now that i'm finally convinced you argue the exact opposite =)
12:11:05 <mauke> mm_freak: welcome to the internet
12:11:09 <bearclaw> but I expected it to semohow "resolve" that constant in this case
12:11:21 <mm_freak> the obvious conclusion is:  without a formal definition it's subjective
12:11:27 <S_J> why cant i end a do block with a forkIO? i need an expression...
12:11:35 <ski> (Peaker : s/=>/*>/ :)
12:11:39 <mm_freak> S_J: you can
12:11:41 <levi> bearclaw: What piece of information have you given it to know that 2 is supposed to be an Int instead of a Rational?
12:11:42 <mauke> I,I obj->foo(x) in C++ is basically obj->__vtable.foo(obj, x)
12:11:43 <geekosaur> S_J: show code
12:11:47 <geekosaur> @lpaste
12:11:47 <lambdabot> Haskell pastebin: http://lpaste.net/
12:11:52 <mauke> S_J: forkIO is an expression
12:12:00 <bearclaw> levi: pass it as first argument to  what
12:12:09 <bearclaw> and what can accept Int, 2 can be Int
12:12:14 <bearclaw> seen that way it should work
12:12:15 <bearclaw> :)
12:12:24 <mm_freak> :t forkIO
12:12:25 <lambdabot> Not in scope: `forkIO'
12:12:29 <ski> bearclaw : "it's not specific to the i in ghci" -- right
12:12:31 <levi> bearclaw: You have told it how to resolve the WHAT class in the case of an Int, but type classes are *open* to extension.
12:12:33 <geekosaur> but my guess is you're doing (x <- forkIO ...) and what exactly did you expect that to do?
12:13:04 <mm_freak> S_J: note that 'forkIO' by itself is a computation in the '(->) (IO ())' monad
12:13:08 <mm_freak> S_J: not in the IO monad
12:13:17 <levi> bearclaw: Just because you only defined an Int instance doesn't mean there won't be another one that will get linked into your program later, so it can't assume Int is the only thing it could resolve to.
12:13:41 <mm_freak> S_J: if you did this, you may get a very confusing error message, which really just tells you to apply forkIO to an IO action
12:13:54 <bearclaw> uh? Are you sure this 'later' makes sense?
12:13:57 <ski> bearclaw : try `what (length "no")'
12:14:19 <FreeFull> Yay Reader monad
12:14:23 <levi> bearclaw: It has to be able to resolve a type for the parameter before it can check to see if there is an instance defined on that type. And you have not given it enough information to resolve that.
12:14:34 <bearclaw> :t (length [1, 2]) tells me Int
12:14:35 <lambdabot>     Not in scope: `tells'
12:14:35 <lambdabot>     Perhaps you meant `tell' (imported from Control.Monad.Writer)
12:14:35 <lambdabot>     Not in scope: `me'
12:14:43 <bearclaw> so I expect that to work and so it does
12:14:53 <etrepum> Anyone happen to know what the memory footprint of a Haskell thread is? I remember seeing it somewhere at some point, but I don't recall the source. The additional footprint for a Cloud Haskell process would also be great to know as well
12:15:03 <ReinH> :t 1 -- bearclaw
12:15:04 <lambdabot> Num a => a
12:15:13 <ReinH> :t length
12:15:14 <lambdabot> [a] -> Int
12:15:14 <levi> bearclaw: That's because length does not need to evaluate those numbers at all.
12:15:23 <cschneid> etrepum: a tiny app doing just above nothing for me was a few hundred K of ram I think.
12:15:26 <mm_freak> etrepum: i don't know exactly, but it's a few KiB
12:15:29 <FreeFull> :t genericLength
12:15:30 <lambdabot> Num i => [b] -> i
12:15:39 <monochrom> mm_freak: perhaps "dynamic dispatch" is too low-level
12:15:40 <cschneid> ohh a thread, sorry
12:15:45 <Peaker> mm_freak: I wasn't in those arguments about it being a different thing :)
12:15:45 <ski> bearclaw : now try `let x = length (what x) in x' ?
12:15:54 <cschneid> etrepum: missed you say "thread", that was for app, sorry :)
12:15:57 <ReinH> bearclaw: the behavior of length doesn't affect the type of 1
12:16:04 <Peaker> mm_freak: I think it's different in that the vtable ptr is outside the object, which makes it more useful/powerful.  But other than that, it is the same
12:16:12 <ski> bearclaw : or `let x = 2 in (what x,x == length "foo")'
12:16:33 <mm_freak> Peaker: in any case, i view existentials as unrelated to dynamic dispatch…  but then again we still lack a formal definition, and i don't feel like arguing about this any further =)
12:17:08 <FreeFull> :t let x = length (cycle x) in x
12:17:09 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Int'
12:17:09 <lambdabot>     In the first argument of `cycle', namely `x'
12:17:09 <lambdabot>     In the first argument of `length', namely `(cycle x)'
12:17:14 <etrepum> mm_freak: I know it's on the order of "a few KB" but I really want a more exact number… I'm making some slides about the default footprint for concurrency constructs and want to include Haskell in the comparison (e.g. Erlang is about 2.6KB on 64-bit, Go is about 4KB, Java is 1024KB, etc.)
12:17:18 <FreeFull> :t let x = length (cycle [x]) in x
12:17:19 <lambdabot> Int
12:17:33 <ski> mm_freak : i suppose you could either take "dispatch" here as an indirection, or as a switch
12:17:34 <bearclaw> ok, this works, because putting the result of length in x forces it as an Int
12:18:07 <bearclaw> I get that, what I was unsure is why "what 2" couldn't resolve the only choice in the whole universe that result in anything, that is Int
12:18:08 <ReinH> bearclaw: eh?
12:18:25 <levi> bearclaw: That's not true.
12:18:26 <ReinH> bearclaw: no, in `what 2`, 2 could be any instance of Num
12:18:28 <ReinH> :t 2
12:18:28 <FreeFull> bearclaw: 2 could be an Integer
12:18:28 <lambdabot> Num a => a
12:18:33 <mm_freak> Peaker, ski: example:  data X = forall s. X s (s -> s) (s -> Int)
12:18:33 <FreeFull> It could be a Double
12:18:40 <FreeFull> It could be a Complex or Ratio
12:18:40 <mm_freak> this is really just [Int]
12:18:42 <ReinH> the only thing you know about 2 is that it is a Num
12:18:50 <bearclaw> yes, :t length says -> Int, so any variation around blabla x = length blabla will bound x to Int type
12:18:51 <ski> bearclaw : no, another module could add `instance WHAT Integer where ...', and then `what 2' could also be interpreted as `what (2 :: Integer)'
12:19:05 <mm_freak> and explaining [Int] in terms of dynamic dispatch feels really weird ;)
12:19:11 <levi> bearclaw: '2' is not just '2', it is 'fromIntegral 2'.  Look at :t fromIntegral
12:19:19 <ski> bearclaw : Haskell code is supposed to behave the same, as third parties add such extra instances
12:19:47 <ski> bearclaw : it really is ambiguous, as the error says
12:19:59 <ReinH> bearclaw: did you actually do `what (length [1,2])` somewhere, and if so what was the result?
12:20:02 <ski> (or perhaps one could say it's not an error, but a fault)
12:20:02 <FreeFull> Note that ghci has some extra defaulting so you can't always trust it
12:20:40 <bearclaw> let's see, "let x = length (what x) in x" <-3, "what (length [1,2])" <- "Int"
12:20:53 <mm_freak> bearclaw: type class instances are literally global
12:20:56 <ski> mm_freak : it's isomorphic to `[Int]'
12:20:58 <monochrom> why is it not enough to just agree on the type rules and a semantics of existential types? why must you debate over how existential types are implemented? that debate will never end. https://plus.google.com/102208456519922110915/posts/8vmBpn12z4K
12:21:09 <ReinH> bearclaw: right, when you give what an Int it finds the typeclass for What Int
12:21:17 <S_J> I cant have an IO () and an STM action on different branches of a case? like case x of blah -> IO () ; bleh -> STM; ?
12:21:32 <mm_freak> S_J: you can with atomically
12:21:35 <ReinH> when you don't give it an Int, it can't find the correct instance
12:21:44 <ReinH> *the instance for What Int
12:21:46 <mm_freak> S_J: but only transactions within one atomically application are atomic
12:21:56 <bearclaw> ah, tht's where my analogy with traits breaks: I can't write something that could have it's behavior changed by some later code
12:21:57 <mauke> S_J: what would the type of that expression be?
12:22:04 <ReinH> similarly, `what "foo"` would also fail to typecheck.
12:22:18 <k00mi> bearclaw: keyword is "open world assumption", ghc never thinks "this is the only existing instance, so I'll choose that" because it assumes other instances can be added
12:22:20 <bearclaw> whereas traits depending on the compiler will behave differently in that regard, ordering can be extremely important and tricky to get right
12:22:26 <ReinH> while `what (1:Int)` will work
12:22:32 <ReinH> s/:/::
12:22:55 <S_J> @where atomically
12:22:55 <lambdabot> I know nothing about atomically.
12:23:01 <S_J> @src atomically
12:23:01 <lambdabot> Source not found. I feel much better now.
12:23:02 <mm_freak> bearclaw: in a sense when you write an instance, you write it for everyone, not just yourself
12:23:02 <ski> @index atomically
12:23:02 <lambdabot> GHC.Conc, Control.Concurrent.STM
12:23:10 <ReinH> bearclaw: I don't see what this has to do with traits or ordering
12:23:18 <ReinH> bearclaw: what expects an Int. You did not provide it with an Int.
12:23:25 <ReinH> so it did not typecheck.
12:23:30 <ski> @type Contro.Concurrent.STM.atomically
12:23:31 <lambdabot> Couldn't find qualified module.
12:23:33 <ski> @type Control.Concurrent.STM.atomically
12:23:34 <lambdabot> GHC.Conc.Sync.STM a -> IO a
12:23:44 <mauke> @hoogle atomically
12:23:45 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
12:23:45 <lambdabot> GHC.Conc atomically :: STM a -> IO a
12:23:45 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
12:23:53 <bearclaw> I did provide something that could be an int, there is no such thing as a type (Num a) => a
12:24:04 <ski> @type 2
12:24:05 <lambdabot> Num a => a
12:24:18 <Lethalman> "They take black magic out of continuations and make them comprehensible also to people whose name is not Oleg." lol
12:24:22 <S_J> so how would you do different things on different branches? ery common in imperative programming.
12:24:22 <bearclaw> it has to somehow decide what that 2 is at some point (or error)
12:24:31 <ski> Lethalman : whence ?
12:24:37 <Lethalman> http://www.cl.cam.ac.uk/~ok259/foeh/bauer-pretnar-statement.txt
12:24:52 <ReinH> bearclaw: it did decide what 2 is. 2 is not an Int.
12:25:07 <mm_freak> S_J: example?
12:25:08 * Lethalman can't understand all the papers full of symbols and math :( though I could understand the original monad, monad transformers papers
12:25:19 <Lethalman> and some other
12:25:41 <Lethalman> I'm trying to read about extensible effects
12:25:42 <ReinH> This has as much to do with traits and ordering as the failure of `what "foo"` to find a WHAT instance does.
12:26:24 <S_J> mm_freak: http://lpaste.net/93348
12:26:59 <mm_freak> S_J: did you open the link i gave you?
12:27:02 <ski> Lethalman : i learned to read such papers, by attempting to read them ,,
12:27:14 <Lethalman> ski, good you
12:27:18 <S_J> mm_freak: yes
12:27:26 <mm_freak> S_J: ok, step 2: read it =)
12:27:54 <mm_freak> S_J: the chapters are self-contained, so you can start with the STM chapter
12:27:58 <k0001> Lethalman: they would be harder to read without all those symbols and math. Take it easy, there's no hurry. Get familiar with the basic concepts and the symbols will become familiar too.
12:28:15 <Lethalman> ski, I lack some background, take for example all the arrows and weird symbols in the inference rules here: http://homepages.inf.ed.ac.uk/wadler/papers/classhask/classhask.ps
12:28:23 <monochrom> Lethalman: I disagree with encouraging afterthoughts. (we have enough bugs due to afterthoughts already.) but I agree with handlers being structured continuations.
12:28:25 <ski> Lethalman : the most useful advice i saw (on usenet) was that the horizontal bar means "if all the above things hold, then the thing below also holds"
12:28:29 <Lethalman> k0001, never thought I would have been easier
12:28:31 <ReinH> Lethalman: the symbols and math are the only way to communicate what the paper needs to communicate. Everything else would be imprecise and hand-wavy.
12:28:37 <Lethalman> ski, yes know that
12:28:37 <Lethalman> :P
12:28:46 <ReinH> Lethalman: that said, you don't need to understand everything to get any value at all
12:28:49 <Lethalman> ReinH, again never thought it would have been easier
12:28:58 <ReinH> Lethalman: ok :)
12:28:58 <mm_freak> btw, i was positively surprised to find that book in a german bookstore
12:29:39 <k00mi> mm_freak: marlow's book?
12:29:39 <ReinH> Lethalman: a good practice I find is to take notes and try to translate the symbols and math into your own words as you go. Then check later usages against your current understanding and reevaluate.
12:29:44 <Lethalman> it's just there are too many symbols I don't know where they come from, should read several papers behind that is
12:29:47 <mm_freak> k00mi: Parallel and Concurrent Programming in Haskell
12:29:52 <ReinH> Lethalman: and, if possible, into executable Haskell code is even better
12:29:53 <k00mi> right, cool
12:29:53 <mm_freak> k00mi: so yeah
12:29:55 <ski> Lethalman : it also helps to know BNF
12:30:02 <Lethalman> ski, know bnf
12:30:13 <mm_freak> i found LYAH there as well
12:30:19 <Lethalman> but take that classhask.pdf paper
12:30:48 <ReinH> Lethalman: most of the symbols come from set theory, lambda calculus, and abstract algebra.
12:31:02 <Lethalman> when it starts at the inference rules, I just jump through:P
12:31:11 <k00mi> mm_freak: I prefer ebooks, but it's good to know you can get these books in Germany =)
12:31:11 <ReinH> Lethalman: this is a good general source of "wtf is this symbol" http://en.wikipedia.org/wiki/List_of_mathematical_symbols
12:31:14 <ski> Lethalman : many of the symbols are used as variables, iow given meaning in the paper
12:31:37 <mm_freak> S_J: i recommend reading the whole concurrent programming section though
12:31:50 <mm_freak> you seem to be confused about how concurrency works
12:32:09 <mm_freak> k00mi: yeah
12:32:13 <k0001> Lethalman: sometimes, if you feel the paper you are trying to read is too heavy, you can instead go and read one of the related and referenced papers so that you can get more familiar with the basic concepts.
12:32:13 <Lethalman> ReinH, ah, that's interesting
12:32:42 <ReinH> Lethalman: they will often have different meanings in different contexts, but usually as generalizations or specializations of the given meaning
12:32:57 <Lethalman> ReinH, very nice, now I understood ⊕ without reading 10 referenced papers!
12:33:15 <monochrom> Lethalman: perhaps TaPL may help you how to read type rules.
12:33:16 <ReinH> Lethalman: as k0001 says, and especially the reverse bibliography. Later works often do a good job of summarizing or explaining.
12:34:32 <Lethalman> monochrom, thanks, lately I'm reading Practical Foundations for Programming Languages, somebody here hinted me
12:35:10 <ReinH> good choice :)
12:35:14 <Lethalman> :)
12:35:25 <Lethalman> slowly...
12:35:33 <monochrom> that may also do
12:36:08 <bearclaw> instance Eq (Maybe m)  and  instance (Eq m) => EQ (Maybe m) is not the same thing right? one accepts Maybe on anything, the other Maybe on members of Eq
12:36:08 <monochrom> and I don't mean to read the whole book. I just mean the beginning will tell you enough about the notation and why you need that much information packed.
12:36:27 <ski> Lethalman : did you check out "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.pdf> ?
12:36:41 <Lethalman> ski, no will do thanks
12:36:44 <Lethalman> (one at time :P )
12:37:12 <Lethalman> ski, ah that looks like a good exercise
12:37:51 <ski> that was one of the early papers i read, to better understand typing rules
12:38:57 <monochrom> that may do too :)
12:39:23 <levi> Lethalman: To get familiar with the logical notation, this is a good resource: http://logitext.mit.edu/logitext.fcgi/tutorial
12:40:12 <levi> It is also a cool web app, implemented in Ur/Web, Haskell, and Coq.
12:40:19 <nstdloop> I want to use find to get the first element of a list that meets a certain condition
12:40:25 <nstdloop> But I want the function that I pass to find
12:40:31 <nstdloop> to use the index of the item it is looking at
12:40:36 <nstdloop> how can I do that as efficiently as possible?
12:40:43 <mauke> :t zip [0 ..]
12:40:44 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
12:41:56 <monochrom> ah, unfortunately the sequent calculus does not match well with most type systems (which are built on natural deduction)
12:42:10 <nstdloop> I'm kind of new at this. If I wanted to find the first element that is less than or equal to the element on its right, and get its value and index, how would I do that?
12:42:49 <monochrom> but! some less-known type systems can be written as sequent calculi.
12:43:01 <mm_freak> nstdloop: find p (zip3 xs (tail xs) [0..])
12:43:18 <levi> The notation is similar, though.
12:43:21 <chrisdone> monochrom: is that what qi/shen have?
12:43:30 <monochrom> I don't know
12:43:32 <k00mi> bearclaw: right
12:43:51 <mauke> :t find
12:43:52 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:44:01 <chrisdone> monochrom: yeah, qi/shen have a sequent calculus type system http://en.wikipedia.org/wiki/Qi_%28programming_language%29
12:44:14 <mm_freak> nstdloop: let p (x, y, i) = x < y in find p (zip3 xs (tail xs) [0..])
12:44:18 <mm_freak> nstdloop: assumes that xs is nonempty
12:44:20 <levi> Since they're both due to Gentzen.
12:44:29 <Lethalman> levi, thanks
12:44:38 <chrisdone> Qi compiles sequent calculus to Qi Prolog (which is incorporated into the Qi environment)
12:44:46 <nstdloop> mm_freak: what values will that give back?
12:45:05 <mm_freak> nstdloop: simplified:  Maybe (X, X, Int)
12:45:24 <mm_freak> it will give you the element in question, its right neighbour and its index from 0
12:45:31 <nstdloop> Ah
12:45:33 <nstdloop> Excellent
12:45:37 <nstdloop> Thank you very much
12:45:54 <bearclaw> (hmm, took me a while to see why instance WHAT (Num m) where what _ = "Num"  did not work, I still got it all wrong :)  )
12:46:13 <bearclaw> but there is a disturbing parallel between type constructors and typeclasses, even :k agrees with that statement :)
12:47:45 <monochrom> how does :k agree? I can't see it.
12:48:10 <mm_freak> bearclaw: Num :: * -> Constraint
12:48:12 <bearclaw> * -> Constraint vs * -> * for say Maybe and Num
12:48:18 <bearclaw> (reversed)
12:48:27 <mm_freak> bearclaw: so Num a :: Constraint
12:48:29 <monochrom> I see. that one.
12:48:40 <mm_freak> but WHAT wants a * as its argument
12:48:46 <mm_freak> so i don't see how :k can agree =)
12:50:47 <nstdloop_> mm_freak: I get a whole slew of parse errors on that.
12:51:39 <monochrom> unless you explicitly turn on extensions and write "class WHAT (a :: Constraint) where ...". but then you have just banned "instance WHAT Int"
12:51:46 <mm_freak> nstdloop_:
12:51:47 <mm_freak> @lpaste
12:51:47 <lambdabot> Haskell pastebin: http://lpaste.net/
12:51:54 <mm_freak> paste your code there
12:52:22 <mm_freak> monochrom: GHC supports kind classes?
12:52:30 <mm_freak> ah, no
12:52:34 <mm_freak> but constraint classes?
12:52:56 <monochrom> in fact I have put it into "good" use. :)
12:52:56 <elliott> it sort of does support kind classes
12:53:22 <mm_freak> indeed it does
12:53:23 <bearclaw> ah, so there is support for typeclasses that accepts other typeclasses in an extension, but they only accept typeclasses and not type / type constructors?
12:53:48 <mm_freak> class X (a :: a); instance X Num; instance X Int
12:53:52 <mm_freak> that works
12:53:54 <mm_freak> i'm amazed
12:54:10 <k00mi> you can't :k a not fully applied type family :(
12:54:13 <nstdloop_> mm_freak: http://lpaste.net/93349
12:54:36 <monochrom> in fact I used "class W (t :: *) (cls :: * -> Constraint)" so I can have "instance W Int Num"
12:55:22 <mm_freak> nstdloop_: did you mean (span, i)?
12:55:24 <bearclaw> mm_freak:  parse error on input `a'  on the second a
12:55:24 <bearclaw> with ghci
12:55:35 <mm_freak> bearclaw: you need the PolyKinds extension for that
12:55:53 <nstdloop_> mm_freak: yes
12:55:55 <mm_freak> bearclaw: write {-# LANGUAGE PolyKinds #-} at the top
12:56:02 <mm_freak> nstdloop_: then you have to write it that way
12:56:15 <mm_freak> (span, i) = …
12:56:26 <levi> Lethalman: If you really want to get a handle on how type systems work and learn to use a proof assistant to help you do it, this textbook is free and a great resource to work through: http://www.cis.upenn.edu/~bcpierce/sf/
12:58:17 <bearclaw> doesn't it create a lot of possible ambiguities ?(to accept both typeclasses and types in typeclasses)
12:59:33 <mm_freak> bearclaw: not really…  the kind is determined by context
13:00:09 <mm_freak> (X a, a b) => b -> Y
13:00:18 <mm_freak> it's clear that 'a' must be of kind * -> Constraint
13:00:21 <monochrom> hehe, the interactive sequent calculus tutorial has the Smullyan drinking paradox :)
13:00:43 <bearclaw> but a type can be in two typeclasses, what if I make a typeclasses and provide two instances for the two typeclasses my types instanciates (whatever the correct terminology)?
13:00:45 <levi> bearclaw: I would recommend holding off doing things like that until you have a solid grasp on the standard Haskell type system.
13:01:00 <levi> A type can only be in one typeclass.
13:01:27 <levi> Or rather, you can only have one instance for a type class for each type in a single program.
13:01:37 <mm_freak> levi: that book seems interesting…  to bad it's coq-only, because i use agda =/
13:01:46 <mm_freak> too
13:02:12 <levi> mm_freak: You could try translating the exercises to Agda as you go.
13:02:20 <bearclaw> levi: first statement is false, I don't get the second
13:02:28 <bearclaw> I can duplicate my WHAT in WHAT2 and put Int in it
13:02:43 <mm_freak> levi: are they even compatible?  apparently coq has a different foundation
13:02:55 <levi> I meant a type can only be in a typeclass in one way.
13:03:43 <smith_> as in, each type can only have one instance in each typeclass
13:03:56 <smith_> so you can't have two definitions of `what` for one type
13:04:00 <bearclaw> but you can't enforce this without the possibility of "linker error" that cannot happen without the feature (of typeclasses of typeclasses still)
13:05:02 <levi> It complains as soon as it recognizes you've given two different instances for a type 'a' in typeclass 'F'.
13:05:42 <levi> The standard workaround is to declare a newtype wrapper for each instance.
13:06:06 <ksf_> mm_freak, did you just select the function used to generate the constraints by letting the constraint solver fish for a class instance?
13:06:30 <ksf_> that looks like a cute hack that I might want to use, but I don't see how not to have a be ambigious, there.
13:06:38 <levi> For example, the integers form a monoid with both addition and multiplication. But you can't make Monoid instances for Int both ways; instead, the Monoid instances are made for the newtype wrappers Sum and Product.
13:07:10 <mm_freak> ksf_: again, the kind follows from the context in which you use the X constraint
13:07:28 <levi> Well, you *can* make a Monoid for Int both ways, just not in the same program!
13:07:36 <ksf_> yeah but not a. a is a type function or class.
13:07:43 <ksf_> but which one?
13:08:04 <S_J> Cant I '<-' the Maybe String out of STM.STM (Maybe String) ?
13:08:08 <FreeFull> > take 50 . (0:) . scanl1 (+) . map (+1) . scanl1 (+) $ [0,6..]
13:08:09 <lambdabot>   [0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,58...
13:08:11 <FreeFull> :D
13:08:31 <ksf_> S_J, yes, that's what bind is for.
13:08:36 <FreeFull> That's an infinite list of consecutive cubes
13:08:53 <FreeFull> I don't know if it's faster or slower than map (^3) [0..]
13:10:16 <S_J> ksf_: http://lpaste.net/93352
13:10:22 <Lethalman> levi, ok, the tutorial seems nice... my purpose is only to read the papers of new cool haskell features that is :)
13:10:50 <ksf_> S_J, you need "atomically" to use STM
13:11:06 <Lethalman> I know in general semantics, logic programming, inference rules and such, I'm just unfamiliar with the symbols being used
13:11:11 <ksf_> bind works for both, but they aren't the same.
13:11:34 <ReinH> levi: (this is why I recommended a newtype wrapper to begin with ;)
13:12:12 <levi> mm_freak: I think the mathematical foundations of both Coq and Agda are both derived from the general field of intuitionistic logic, so they should be roughly compatible in the sense that the same things should be provable in both.
13:12:49 <S_J> case blah of Just x -> someIO()_action; Nothing -> (); <<-- () doesnt work there , how do i do nothing in IO () ?
13:13:08 <ksf_> S_J, return ()
13:13:26 <ksf_> :t ()
13:13:27 <lambdabot> ()
13:13:29 <ksf_> :t return ()
13:13:30 <lambdabot> Monad m => m ()
13:13:34 <ksf_> :t return () :: IO ()
13:13:35 <lambdabot> IO ()
13:13:41 <ksf_> :t () :: IO ()
13:13:42 <lambdabot>     Couldn't match expected type `IO ()' with actual type `()'
13:13:42 <lambdabot>     In the expression: () :: IO ()
13:15:08 <ksf_> S_J, there's also "when":
13:15:09 <ksf_> :t when
13:15:10 <lambdabot> Monad m => Bool -> m () -> m ()
13:15:20 <ksf_> erm. that wasn't helpful.
13:15:23 <ksf_> never mind.
13:16:00 <levi> Lethalman: What symbols are you unfamiliar with, then?
13:16:14 <ksf_> @hoogle Monad m -> Maybe a -> (a -> m ()) -> m ()
13:16:14 <lambdabot> Warning: Unknown type Monad
13:16:14 <lambdabot> No results found
13:16:20 <ksf_> @hoogle Monad m => Maybe a -> (a -> m ()) -> m ()
13:16:20 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:16:20 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:16:20 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:16:36 <Lethalman> levi, can't select from the pdf :P
13:16:41 <ksf_> no that't not what I mean, hoogle.
13:17:12 <Lethalman> levi, however weird waved arrows, arrows from up-down and so on
13:17:47 <Lethalman> levi, I'm unfamiliar with the notation
13:20:45 <Lethalman> gtg
13:20:57 <levi> Lethalman: Is this the type classses paper?
13:21:28 <Lethalman> levi, yes though I think I'd skip that part
13:21:46 <Lethalman> there's another paper however by SPJ which describes a whole algorithm using that kind of notation
13:21:48 <Lethalman> let me find it
13:23:33 <Lethalman> levi, this https://www.google.it/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CC0QFjAA&url=http%3A%2F%2Fwww.mpi-sws.org%2F~neelk%2Fpattern-popl09.pdf&ei=qfRBUprjFcKz4ASYv4CYBw&usg=AFQjCNHpjDq3nYpv-p4Oxr_3nt7DAHfTTA&sig2=knsZFZXdIQiO2HM7QDo40Q
13:23:35 <Lethalman> ops
13:23:51 <Lethalman> ah not SPJ sorry
13:23:55 <Lethalman> thought it was
13:24:32 <ski> Lethalman : the `↝' is a relatively common notation for translations of some kind
13:24:34 <Lethalman> however with all the pointers you all gave me I think I will be able to at least grok the basics of those
13:24:54 <Lethalman> don't need deep understanding, just grok the concepts :)
13:25:16 <Lethalman> now reading the extensible effects paper, quite readable
13:25:42 <ski> Lethalman : i'm not sure where the "arrows from up-down" are
13:25:47 <Lethalman> eh
13:25:48 <S_J> if i want an action that is IO () but the last thing it does is fork a thread, how do I fix that?
13:26:21 <dwcook> S_J, return () ?
13:26:33 <dmwit> :t void
13:26:34 <lambdabot> Functor f => f a -> f ()
13:26:36 <levi> Lethalman: The squiggly arrow seems pretty well-described in the text.
13:26:44 <dmwit> :t (() <$)
13:26:44 <lambdabot> Functor f => f b -> f ()
13:26:51 <dmwit> :t (>> return ())
13:26:51 <lambdabot> Monad m => m a -> m ()
13:27:10 <Lethalman> levi, yes that's fine
13:27:29 <Lethalman> ski, a⇓b but now I read it's a has value b
13:27:39 <ski> yes
13:27:47 <Lethalman> that is nothing bad I only have to get the head around those symbols :)
13:28:11 <ski> Lethalman : and `e ⇑' is common for "`e' diverges", iow doesn't evaluate to a value
13:28:31 <bearclaw> multiple definition of the same function uses constraint intersection to get the final function signature, so the only way to accept two different types is through a typeclass
13:30:43 <Lethalman> the extensible effects is interesting
13:30:45 <ubikation> how do I operate on an IO String? I have a function which accepts a string and I was trying to use Control.Monad.liftM but that wasn't working...
13:30:50 <levi> Lethalman: Published papers are generally pretty dense, because the authors have to pack a lot of information into a size-limited format. They're hard to skim even if you know the notation.
13:31:10 <ski> ubikation : what type does this function have ?
13:31:14 <Lethalman> levi, np I like dense stuff :P
13:31:15 <dmwit> ubikation: Show us enough code to reproduce the error you're getting. Then show us the error you're getting anyway. =)
13:31:21 <dmwit> ?hpaste
13:31:21 <lambdabot> Haskell pastebin: http://lpaste.net/
13:31:57 <ubikation> https://gist.github.com/ubikation/6690780
13:32:36 <ubikation> and the error is  Couldn't match expected type `IO t0' with actual type `Either P.ParseError [[String]]'
13:32:41 <ski> try replacing
13:32:42 <ski>   sMem <- parseMeminfo memString
13:32:43 <ski> with
13:32:47 <ski>   let sMem = parseMeminfo memString
13:33:12 <ski> (hint, the type of `parseMeminfo' isn't `... -> IO ...')
13:35:07 * hackagebot idris 0.9.9.2 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.9.2 (EdwinBrady)
13:35:30 <ubikation> ski: thank you! I was getting = and <- mixed up in my rush to understand IO I guess...
13:36:09 <ski> `let' (and `where') just gives a name to the value of an expression
13:36:31 <bearclaw> Am I correct in assuming I can't do different code path from a function on String VS [anything] without FlexibleTypes, or some ugly typeof that will only work if code compiles for both types on both pathes?
13:36:39 <ski> when you do `x <- foo', when `foo' has type `IO X', then `x' will get type `X'
13:37:09 <ski> bearclaw : there's the `showList' kludge
13:38:13 <bearclaw> ski: ok, my question would then be: how could I implement showList in haskell? :)
13:38:39 <bearclaw> if the specific behavior of showList does not suit my need?
13:39:00 <dmwit> ?src showList
13:39:00 <lambdabot> Source not found. I feel much better now.
13:39:02 <dmwit> ?src Show
13:39:02 <lambdabot> class  Show a  where
13:39:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:39:02 <lambdabot>     show      :: a   -> String
13:39:02 <lambdabot>     showList  :: [a] -> ShowS
13:39:54 <bearclaw> heh, probably not written in haskell :)
13:40:22 <Cale> bearclaw: ?
13:40:30 <Cale> bearclaw: What's not written in Haskell?
13:40:37 <bearclaw> (the fact that ?src fails)
13:40:43 <joelteon> ghci
13:40:45 <joelteon> whoops
13:40:47 <ski> bearclaw : it's written in Haskell
13:40:49 <bearclaw> (makes me believe that showList is not in haskell)
13:41:01 <Cale> It is implemented in Haskell.
13:41:14 <bearclaw> I'm curious as to how it does the dispatch then
13:41:16 <Cale> But it's implemented separately for different types
13:41:16 <joelteon> the whole stdlib is implemented in Haskell
13:41:31 <Cale> The ?src command just reads from a hand-crafted text file
13:41:38 <Cale> It has some missing stuff
13:41:39 <bearclaw> (ok)
13:41:57 <k00mi> bearclaw: you make the [a] case part of the typeclass, so you never have to make an instance [a]
13:42:14 <Cale> showList is implemented differently for Char than it is for other types
13:42:30 <kier> Is it possible to link haskell binaries statically? If so, how?
13:42:39 <Cale> and then the instance of show for lists uses the definition of showList on the elements
13:42:46 <joelteon> I too would like to link a binary statically
13:42:54 <ski> the default implementation of `showList' is :
13:42:59 <ski>   showList = shows
13:43:07 <Cale> kier: Isn't the default not to split objects?
13:43:10 <chaoslynx> hi, why does sizeOf give a size of n-1 for newArray applied to a list of n elements?
13:43:11 <acomar> kier: I'm pretty sure that's the default currently (though it's set to change in 7.8)
13:43:34 <ski> and then in the instance for lists, we have :
13:43:39 <Cale> :t sizeOf
13:43:40 <lambdabot>     Not in scope: `sizeOf'
13:43:40 <lambdabot>     Perhaps you meant one of these:
13:43:40 <lambdabot>       `IM.size' (imported from Data.IntMap),
13:43:43 <ski>   instance Show a => Show [a]
13:43:45 <ski>     where
13:43:53 <ski>     showsPrec _ as = showList as
13:44:03 <Cale> chaoslynx: Where is sizeOf defined?
13:44:20 <ski> and then for `Char' we have a special case
13:44:28 <ski>   instance Show Char
13:44:30 <ski>     where
13:44:37 <ski>     showsPrec _ c = ..c..
13:44:44 <Cale> chaoslynx: Are you talking about the one in Foreign.Storable?
13:44:54 <ski>     showList cs = ..code.involving.quotation.marks..
13:44:56 <chaoslynx> Cale in Foreign.Storable
13:45:00 <chaoslynx> Cale, yes
13:45:06 <ski> bearclaw : or something like that
13:45:39 <bearclaw> hmm, but showList is putting the comma
13:46:00 <kier> Maybe this problem is just specific to the foreign package I'm using then, since two of the shared libraries it's looking for are libGLUT and libffi
13:46:32 <ski> bearclaw : er, actually, the default implementation isn't `showList = shows' (that would make it loop for most lists), instead the default `showList' is code to write a list with `[',`,',`]'
13:46:34 <bearclaw> you need a "showInList isLast" called on each element that does show(e) + "," on everything but char, where it does show(e), or something like that
13:46:37 <dmwit> chaoslynx: What instance's newArray are you using? With my current imports, I don't see a Storable instance for any instances...
13:46:56 <ski> bearclaw : so, it's somewhat like binary methods in OO, i suppose ..
13:46:58 <bearclaw> ski: yes, and you need to specialize for list of char, but cant, the specialization must be a method called on the list elements
13:47:27 <ski> bearclaw : well you can, if you delegate every `showsPrec' on lists to `showList' for the element type
13:47:30 <Cale> chaoslynx: Where'd you get the Storable instance from for Array?
13:47:45 <dmwit> Cale: I have the same question. =)
13:48:09 <Cale> (Even StorableArrays are not instances of Storable, they just have Storable elements)
13:48:18 <ski> (which is what `Show' does)
13:48:33 <bearclaw> ski: yes you need to do that, but what if I want to display [1] as [1] and "foo" as <foo> so "" as <>
13:48:44 <bearclaw> how can you call a method using an element when there is no element?
13:48:45 <chaoslynx> dmwit, Cale: I just realized my mistake, there is an instance of Storable for Ptr GLfloat and that happens to be yield 8
13:48:50 <chaoslynx> in my case
13:48:56 <ski> bearclaw : so you make a new class ?
13:49:12 <bearclaw> yes, but on what do I call the class method?
13:49:13 <ski> bearclaw : ok, "how can you call a method using an element when there is no element?" is not a problem
13:49:31 <bearclaw> ah maybe I can call and force a type without an actual object of that type as argument?
13:49:35 <chaoslynx> I naively tried to "port" C-code where sizeof(_) just works
13:49:40 <S_J> Are there debuggers for haskell?
13:49:46 <Cale> S_J: ghci
13:49:48 <dmwit> chaoslynx: ...how are you getting a Ptr out of newArray?
13:49:54 <ski> bearclaw : yes, and if you really need a value (though i doubt it), you can fake it
13:50:07 <S_J> Cale: yes but a real debugger which lets me step through my program
13:50:19 <dmwit> S_J: Yes, ghci has a real debugger that lets you step through your program.
13:50:25 <dmwit> S_J: Read the fine manual. =)
13:50:25 <ski> bearclaw : e.g.  undefined `asTypeOf` head xs  or something similar
13:50:30 <chaoslynx> dmwit: I am using Foreign.Marshal.Array
13:51:07 <Cale> Though, it's less useful to be able to step through your Haskell program than one might expect, because of the sometimes difficult to predict order in which things get done.
13:51:29 <dmwit> chaoslynx: Ah, that's a different newArray. Okay, now I understand; also, the name of that "newArray" is a bit deceptive if you're coming from C, yeah.
13:53:07 <Cale> is it?
13:53:23 <dmwit> Cale: Yes, because in C arrays and pointers are subtly different.
13:54:44 <dmwit> (...and in Haskell, arrays and pointers are blatantly different.)
13:54:51 <Cale> But isn't an array in C represented by a pointer to n contiguous elements, similar to what newArray will give you?
13:54:57 <Cale> (well, this newArray, anyway)
13:55:06 <dmwit> http://c-faq.com/aryptr/aryptr2.html
13:55:27 <dmwit> No, an array allocates the actual space, not a pointer. (Though you can get a pointer to that space.)
13:55:28 <bearclaw> hmm, ok, the price for safety I guess, thanks for all the help, would have taken me forever to figure all that out by myself, I'm starting to see the famous funny language matrix differently (http://imgur.com/P9RnL) :)
13:55:33 <chaoslynx> Cale: in C you can declare some array:  static const float x[] = {1.0f,2.0f} and sizeof will give you the correct size.
13:55:52 <Cale> Oh, I see, right.
13:55:56 <dmwit> One of the practical differences being what chaoslynx just said. =)
13:56:33 <chaoslynx> :)
13:57:14 <ParahSai1in> isnt sizeof really a compile time macro?
13:57:19 <ParahSai1in> in C i mean
13:57:28 <companion_cube> yes
13:57:35 <dmwit> Practically speaking, it is in Haskell, too.
13:58:04 <ParahSai1in> so arrays and pointers are the same in C, just there is syntactic sugar for allocating stack arrays and recalling the size
13:58:05 <dmwit> The important difference is rather that we don't have statically-sized arrays at all in Haskell.
13:58:12 <Cale> Heh, unless you make some weird instances of Storable and use polymorphic recursion just to spite dmwit
13:58:19 <dmwit> right
13:58:33 <donri> to what extent does ghc support dependent types? can I map a promoted data kind between value and type level, say?
13:58:50 <dmwit> donri: There's a fairly recent paper about just that, actually.
13:59:13 <donri> "giving haskell a promotion"?
13:59:58 <dmwit> donri: I was thinking of the follow-up paper, "Dependently typed programming with singletons".
13:59:59 <ski> ParahSai1in : no, you can also do `struct foo { int arr[17]; };'
14:00:16 <donri> ok thanks will look it up
14:01:03 <Peaker> singleton is such an overloaded word
14:01:30 <dmwit> Yes, in this case it means "singleton kinds".
14:02:18 <ParahSai1in> ski: ah good point
14:03:15 <dmwit> Hm, does C have dynamically sized arrays?
14:03:21 <sipa> no
14:03:42 <sipa> C++ has vectors, but those are STL, not C++ itself
14:03:47 <hpc> it has dynamically sized "has the same memory layout as an array"
14:03:55 <dmwit> Okay. Even if I write like int foo(int[] bar) { ... }?
14:03:58 <quicksilver> depends how you choose your words
14:04:00 <donri> i keep seeing "full-spectrum dependent types"; does that have any formal meaning or is it just an idiom?
14:04:16 <quicksilver> C has malloc() and you can use that to implement dynamically sized arrays
14:04:18 <chaoslynx> dmwit, you can implement dynamically sized arrays.
14:04:20 <quicksilver> but they don't know how big they are
14:04:32 <pqmodn> dmwit: { ... } won't know the size of bar, unless you also pass that in
14:04:43 <FreeFull> You can implement most things in C
14:04:49 <dmwit> pqmodn: This I know. It's why I asked.
14:04:56 <dmwit> pqmodn: But is bar an array or a pointer?
14:05:34 <pqmodn> dmwit: i'm not clear on their distinction in C
14:05:49 <FreeFull> Clearly, the type says it's an array
14:06:00 <dmwit> Me neither, I guess. =)
14:06:25 <quicksilver> I don't think the C standard is particularly clear on the difference either.
14:06:48 <quicksilver> I've always thought it showed imprecision of thought that "arr" and "&arr" represented the same thing
14:06:57 <dmwit> Will bar[5] emit code like *(bar+5) or code like *(*bar+5)?
14:07:12 <stevely> the former
14:07:33 <dmwit> Okay. Then I would call bar a dynamically-sized array in the snippet above.
14:08:12 <stevely> well, bar[5] will result in the same thing regardless of whether or not bar is a pointer or an array
14:08:29 <ubikation> How do I check that a call from System.Process.createProcess has finished? I am unsure of how to understand which return handle I am supposed to be checking?
14:08:29 <dmwit> My point is that no it will not.
14:08:38 <ski> dmwit : in C99 you can say `void foo(int n) { int arr[n]; ... }'
14:08:47 <dmwit> See http://c-faq.com/aryptr/aryptr2.html which I linked at the beginning of this discussion.
14:09:03 <dmwit> ski: aha, interesting
14:09:36 <dmwit> ubikation: use waitForProcess
14:10:05 <stevely> that distinction would only hold in your example if the array was passed by value, which it won't be
14:10:11 <donri> heh, this singletons paper seems to be exactly about what i wrote myself, what prompted the question because i didn't like having to write what they're calling the singleton type
14:11:01 <dmwit> donri: Congratulations, you invented singletons. =)
14:11:23 <donri> well at the same time "i have no idea what i'm doing" [insert picture of a dog]
14:11:57 <levi> dmwit: Did you follow the link in that C FAQ article to the one about the formal parameters?
14:11:58 <ski> quicksilver : `arr' and `&arr' doesn't represent the same thing
14:12:17 <dmwit> levi: Just now, yes. Mildly enlightening, mildly confusing.
14:12:20 <ubikation> if I don't care about the result of a function I can just call it and ignore the result, right? I mean should I always do "foo <- P.waitForProcess p" in Haskell code/
14:12:41 <quicksilver> ski: there are contexts in which they do.
14:12:50 <ski> dmwit : in `int foo(int bar[]) { ... }', `bar' is a pointer (since this is sugar for `int foo(int *bar) { ... }')
14:12:55 <levi> dmwit: Indeed.
14:12:57 <dmwit> ubikation: That is a style question on which many people disagree. =)
14:13:10 <quicksilver> ski: assignment or parameter passing to pointer type.
14:13:26 <ski> quicksilver : yes, e.g. the `(...)[i]' context
14:13:39 <quicksilver> ski: (would it be more correct to say that "arr will be implicitly converted to &arr in some contexts")
14:14:06 <quicksilver> ski: part of it is that "pointer-to-array" isn't a real thing
14:14:16 <ski> quicksilver : the types of `arr' (when converted to a pointer) and of `&arr' are different
14:14:16 <ubikation> dmwit: ah, now I am getting to where I can mix ignorance and my opinions for Haskell :P
14:14:16 <zq> how to get all but the last element of a list?
14:14:24 <ski> (e.g. `sizeof' will distinguish)
14:14:34 <dmwit> zq: init
14:14:35 <zq> head (length s) s?
14:14:39 <k00mi> ubikation: you'll get a warning with -Wall
14:14:42 <ski> (or well, can distinguish, i think)
14:14:47 <zq> dmwit: thanks
14:15:12 <dmwit> :t zipWith const <*> drop 1
14:15:13 <lambdabot> [b] -> [b]
14:15:20 <levi> quicksilver and ski: http://c-faq.com/aryptr/aryptrequiv.html
14:15:23 <dmwit> > zipWith const <*> const 1 $ [1..5]
14:15:25 <lambdabot>   Could not deduce (GHC.Num.Num [b0]) arising from the literal `1'
14:15:25 <lambdabot>  from the ...
14:15:41 <dmwit> err
14:15:45 <dmwit> > zipWith const <*> drop 1 $ [1..5]
14:15:46 <lambdabot>   [1,2,3,4]
14:15:59 <dmwit> zq: You may prefer the safety of this version in some circumstances.
14:16:01 <zq> dmwit: okay, how would i drop the last N elements?
14:16:05 <ski> levi : yeah, i've browsed it before
14:16:20 <zq> dmwit: isn't 'drop 1' equivalent to 'tail'?
14:16:32 <ski> @where sneaky  -- zq
14:16:32 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
14:16:34 <dmwit> zq: iterate init; or use drop and reverse twice; or use zipWith const <*> drop n
14:16:37 <dwcook> > drop 1 []
14:16:38 <lambdabot>   []
14:16:43 <dwcook> zq, no.
14:17:18 <dmwit> > (drop 1 [], tail []) -- zq
14:17:19 <lambdabot>   ([],*Exception: Prelude.tail: empty list
14:17:31 <quicksilver> levi: ski : *nod* ah well that's enough esolangs for me tonight :)
14:17:41 <TomWhite> Howdy! I have a quick haskell question if anyone has a moment: I have an infinite list of ints that I know is monotonically increasing; I'd like to be able to filter out values from the list that are less than a value. (Filter (<200) myInfiniteList) . This doesn't work, because it keeps iterating through the list and doesn't stop. Is there some way to tell the type system that the list is infinite and monotonically increasing  and
14:17:45 <zq> > (head [], take 1 [])
14:17:46 <lambdabot>   (*Exception: Prelude.head: empty list
14:17:54 <zq> > (take 1 [], head [])
14:17:55 <lambdabot>   ([],*Exception: Prelude.head: empty list
14:17:59 <levi> ski: When a char[] reference decays to a pointer, it's the same type as char *.
14:18:03 <zq> so take and drop are more forgiving
14:18:10 <dmwit> TomWhite: dropWhile
14:18:58 <dmwit> TomWhite: You might also like to take a look at the data-ordlist package.
14:19:03 <TomWhite> Awesome! Thanks dmwit!
14:19:11 <TomWhite> Okay, I'll give that a check too.
14:19:17 <mm_freak> when the main thread exits, existing threads don't get a chance to clean up…  why is that?
14:19:18 <ski> levi : i know
14:19:23 <elliott> TomWhite: it got cut off after "monotonically increasing  and"
14:19:36 <dmwit> mm_freak: design choice
14:19:48 <levi> ski: I thought you had said something different earlier. Nevermind then.
14:19:48 <dmwit> mm_freak: Use MVar's to synchronize with any threads you want to clean up.
14:20:01 <dmwit> mm_freak: Or whatever other concurrency communication primitive you prefer, of course.
14:20:20 <TomWhite> elliot: the last sentence: "Is there some way to tell the type system that the list is infinite and monotonically increasing, and thus stop once it passes 200"
14:20:32 <mm_freak> dmwit: what was the rationale for that design choice?
14:20:34 <dmwit> mm_freak: Just exiting is simpler, and gives the programmer more control, than trying to do all the cleanup automatically.
14:20:53 <dmwit> mm_freak: Since after all in many cases it's program-specific what "cleanup" even means.
14:21:14 <dmwit> TomWhite: The type system isn't involved once you get to runtime behavior. =)
14:21:47 <dmwit> (This is a statement about Haskell 2010; some extensions and or other languages may modify this claim.)
14:21:47 <mm_freak> hmm
14:21:47 <mm_freak> dmwit: i would expect it to killThread all existing threads and wait for them to die
14:22:01 <mm_freak> the current behavior is really just annoying
14:22:31 <dmwit> mm_freak: Hm. Well, I'm not sure what you want me to do about it. =P
14:22:32 <ski> dmwit : hm, how about finalizers ?
14:23:08 <dmwit> ski: I'm not sure, to be honest. I don't really understand how the FFI stuff works very well.
14:23:16 <dmwit> ski: I suspect finalizers don't run, either.
14:23:35 <dmwit> I wouldn't be surprised if you can construct a single-threaded program in which som efinalizers don't run.
14:23:43 <dmwit> e.g. because a GC never happens
14:24:29 <ski> well, arguably, if the threads disappear, the roots would go away so then finalizers could be argued should happen
14:24:31 <mm_freak> yes, finalizers don't run…  it's like the async exception system is nice and clean everywhere except for the very important case when the main thread exits
14:24:58 <mm_freak> this design choice makes many otherwise simple programs very painful to write
14:24:58 <dmwit> ski: The threads aren't disappearing... the process is. =)
14:25:09 * hackagebot linux-evdev 0.2 - Bindings to Linux evdev input device interface.  http://hackage.haskell.org/package/linux-evdev-0.2 (BenGamari)
14:25:09 <ski> dmwit : and with it, the threads !
14:25:12 <merijn> Two theoretical questions: homomorphism = structure preserving mapping?
14:25:18 <ski> merijn : yes
14:25:21 <dmwit> ski: But in the wrong order!
14:25:25 <ski> (that was one question)
14:26:14 <merijn> Second one: bijective homomorphism between two non-isomorphic posets = two posets of identical size but different ordering?
14:26:15 <ski> dmwit : i don't care about the order, as long as the finalizers get to run ? ;)
14:26:23 <dmwit> I don't think the RTS going, "oh, hey, we're exiting, we should garbage collect" is sane.
14:26:34 <dmwit> exiting is the ultimate garbage collection
14:27:00 <chrisdone> Someone just joined Haskell Trentino!
14:27:00 <chrisdone> You now have 5 members in your Meetup Group!
14:27:00 <merijn> If not, what'd be an example of being able to have a bijective homomorphism between two non-isomorphic posets?
14:27:02 <chrisdone> woot!
14:27:03 <mm_freak> dmwit: not when you want to remove temporary files or gracefully tell your UDP peer that you are no longer available
14:27:14 <dmwit> mm_freak: Yes, I know.
14:27:25 <dmwit> I know the arguments against. I'm aware of them. And I've told you what to do about them, too.
14:28:05 <ski> merijn : hm, not sure whether the inverse of a bijective homomorphism here has to be a homomorphism or not ..
14:29:12 <mm_freak> dmwit: no, you didn't…  you told me to use abstractions ;)
14:29:22 <dmwit> ski: Oh, I see. You are proposing that finalizers be the way of informing the runtime what "cleanup" means.
14:30:21 <ski> interesting
14:31:16 <ski> merijn : hm, i think you can claim the `=>' at least
14:31:30 <kier> I swear half the GCSE maths course is friggin quadratics
14:31:32 <merijn> ski: It was something mentioned in Awodey, showing that an isomorphism is by definition a bijective homomorphism, but the reverse not necessarily
14:31:36 <kier> wrong channel
14:31:46 <ski> merijn : consider the discrete order `{a,b}' vs. the total order `{0,1}'
14:32:08 <ski> merijn : we have a homomorphism from the former to the latter, and it is bijective. but the inverse is not a homomorphism
14:33:30 <merijn> ski: I'm not sure I know what a discrete order is?
14:33:44 <ski> merijn : an order where `a =< b  <=>  a = b'
14:33:53 <ski> (for all `a',`b')
14:33:54 <mm_freak> there was an article about two conflicting philosophies "simple/inconvenient" vs. "more complicated/correct" and how unix follows the former
14:34:00 <mm_freak> but i'm unable to find it
14:34:11 <merijn> mm_freak: worse is better?
14:34:16 <mm_freak> merijn: yeah, exactly!
14:34:17 <mm_freak> thanks
14:34:31 <swistak35> Yet another "Hi" today
14:34:33 <ski> (the free foo over a set is often called a "discrete foo")
14:34:39 <merijn> mm_freak: There's multiple of those, btw :)
14:34:45 <mm_freak> dmwit: http://www.jwz.org/doc/worse-is-better.html
14:34:50 <mm_freak> that's the one i was referring to =)
14:34:52 <merijn> mm_freak: The most iconic one is probably "The rise of worse is better"
14:35:21 <mm_freak> haskell clearly follows the The Right Thing philosophy, but for some odd reason drops to Worse Is Better when the main thread exits
14:35:24 <mm_freak> this seems inconsistent
14:35:43 <swistak35> what are the basic steps for resolving memory isssues? My algorithm takes quite big data (but still, it's only 32KB text file) for knapsack problem, but it uses about 6GB of RAM and then it's killed by OS
14:35:50 <merijn> ski: Right, so the only ordering is equality?
14:35:52 <swistak35> How can I check what's going on?
14:35:58 <ski> merijn : yes
14:35:59 <merijn> swistak35: 32KB text file...are you using String?
14:35:59 <joelteon> what do you guys recommend for working with graphics in haskell?
14:36:17 <swistak35> merijn: yes, shouldn't I?
14:36:26 <joelteon> for example, making a game
14:36:46 <swistak35> merijn: contents <- readFile . head $ args
14:36:46 <merijn> swistak35: No, String is terrible, it takes about 20 bytes per character on some architectures. For file IO you'll want Data.Text
14:36:51 <sm> joelteon: http://joyful.com/fungen !
14:36:59 <dmwit> mm_freak: Well, you're welcome to propose another way to the GHC folks. I suspect it will be a hard battle at this point, though -- not breaking old programs will probably be a bit hard.
14:37:01 <merijn> swistak35: (Which, incidentally provides a readFile too)
14:37:13 <joelteon> oh hey
14:37:15 <joelteon> openGL
14:37:16 <mm_freak> dmwit: indeed
14:37:20 <dmwit> mm_freak: Or rather, not breaking old programs may be easy, but demonstrating that you haven't broken old programs is probably not.
14:37:28 <sm> joelteon: and http://helm-engine.org/ , which is newer but will be harder to install
14:37:39 <joelteon> wow opengl-raw is massive
14:37:52 <mm_freak> dmwit: it could come along with the AMP, which will break a lot of existing code anyway
14:37:56 <merijn> swistak35: Simple taxonomy of Haskell "string" types: ByteString = raw binary bytes, use for network/binary IO, Text = densely packed unicode text, String = linked list of characters
14:38:06 <ski> merijn : for every set `A' and PO `O' : for every function `f : A -> O', we have a unique PO homomorphism `g : D A -> O', and vice versa, where `D A' is `A' equipped with the discrete ordering
14:38:23 <swistak35> merijn: ok, but still I think that this string is not the case - usage of RAM is about 6GB (and it would like to have more) and these file contents I am converting to [(Int, Int)] in the very beginning of my program
14:38:31 <ski> `D' is here a free functor
14:38:39 <merijn> swistak35: You basically only want to use String for small literals/constant as very basic scripts. For anything real you'll want Text
14:38:41 <zq> @sneaky
14:38:41 <lambdabot> Unknown command, try @list
14:38:45 <ski> (not very interesting in this case)
14:38:50 <dmwit> ?where sneaky
14:38:50 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
14:38:57 <zq> i'm so lost
14:39:01 <zq> i thought haskell is lazy
14:39:07 <shachaf> dmwit!
14:39:08 <merijn> swistak35: Oh, I agree with you, that's probably not the only issue, but it's certainly one to take care off. The performance difference between String/Text is dramatic
14:39:19 <dmwit> zq: It is. Ask us a question about your confusion!
14:39:22 <dmwit> shachaf: !
14:39:22 <zq> shouldn't it see that const only calls the first of the two argument thunks
14:39:29 <zq> and automatically ignore evaluation of (drop n xs)?
14:39:31 <merijn> swistak35: As for the rest, Real World Haskell has a chapter on profiling haskell code, which lets you figure out how much memory is used where
14:39:36 <shachaf> hi
14:39:40 <dmwit> zq: const is not applied to the other two arguments
14:39:48 <dmwit> zq: const is applied to elements drawn from the other two arguments
14:39:55 <zq> crap
14:40:01 <ski> @src zipWith
14:40:01 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:40:01 <lambdabot> zipWith _ _      _      = []
14:40:09 <swistak35> merijn: ok, thank you
14:40:27 <dmwit> shachaf: hi
14:40:29 <dmwit> shachaf: bye =)
14:40:40 <zq> now i see, it's a shifted zip
14:40:47 <shachaf> bye dmwit
14:40:52 <zq> dmwit, ski: thanks
14:41:04 <merijn> ski: I think I understand that, probably... :p
14:41:55 <ski> merijn : anyway, i think you can have two POs with same cardinality without there being a bijective homomorphism from one of them to the other
14:42:31 <zq> is it possible to see the native code that ghc outputs from dropFromEnd?
14:43:04 <ski> (two non-iso POs, i.e.)
14:43:50 <ystael> 'PO' ?
14:44:06 <merijn> zq: Yes, but it's probably not very helpful. Usually people look at the generated Core to study code
14:44:08 <merijn> ystael: Preorder
14:44:13 <ystael> ah, thanks, sorry
14:44:44 <merijn> zq: Core being the intermediate language that GHC generates from haskell code, before translating to machine code
14:44:45 <joelteon> sm: does helm use GTK?
14:45:04 <zq> merijn: would -fllvm generate llvm ir instead?
14:45:10 <ski> merijn : oh, i thought you were talking about partial orders
14:45:42 <ssedov> joelteon: afaik it only uses cairo
14:45:43 <merijn> zq: -fllvm generates Core and translates core to llvm ir instead of machine code
14:46:00 <merijn> ski: Oh, partial order then? I dunno, I was guessing :p
14:46:21 <ski> merijn : consider `{a,b,c | a =< b , a =< c}' vs. `{a,b,c | a =< c , b =< c}'
14:46:32 <merijn> ski: Awodey refers to posets for partial ordered sets, but uses PO for Preorder, I think
14:46:34 <ski> merijn : i don't think the distinction matters here, though
14:46:40 <ski> ok
14:46:46 <sm> joelteon: I think the next version will use SDL. #haskell-game will know
14:46:49 <ski> i just abbreviated "poset" to "PO" :)
14:46:59 <merijn> Or maybe he uses poset to refer to preorder sets confusing everyone
14:47:08 <joelteon> oh
14:47:11 <joelteon> well, it's failing to link with SDL
14:47:12 <danilo2> hello! I Want to distribute a binary program, whuch genarates haskell code. I would love to distribute it with the newest GHC and Haskell Platform, both as binaries. I want to ask you if you could give me any hints - how to do it, the most portable way. I know I have to compile it on each platform separatelly, but I would love to hear any hints about staticaly linked libraries in GHC (to work in all linux distros) etc.
14:47:13 <joelteon> huh
14:47:36 <joelteon> but that happens with everything generally
14:47:39 <merijn> danilo2: Static linking is the default for ghc
14:48:55 <danilo2> merij: If so, why when I'm downloadingthe GHC "binary instalator" it complains I've got no libgmp.so.3 in my system? It seems like it looks for this library in my system path.
14:49:01 <danilo2> merijn ^
14:49:14 <rhodesd> zq: here's a really nice diagram of ghc compiler phases: http://www.aosabook.org/en/ghc.html#fig.ghc.pipeline
14:49:52 <stass> joelteon: when using cabal install helm?
14:50:05 <joelteon> no, when running files that import Helm
14:50:07 <merijn> danilo2: Ok, correction, static linking *haskell* libraries is the default, C libraries are dynamically linked by default (i.e. libgmp)
14:50:33 <joelteon> stass: https://gist.github.com/joelteon/444d3e08d1ff15ca82a7
14:51:34 <stass> joelteon: sounds like hs-sdl is build agains the wrong SDL version
14:51:49 <joelteon> i only have one SDL installed
14:52:01 <Taneb> I've just encountered a fabulous runtime error
14:52:04 <stass> joelteon: did you update it by ahy chance?
14:52:08 <joelteon> yeah
14:52:11 <Taneb> "Main: Fatal IO error 4 (Interrupted system call) on X server :0.0."
14:52:14 <joelteon> i reinstalled it right before i ran that
14:52:26 <stass> joelteon: and can you check if it actually has the _SDL_HasSSE2 symbol in it?
14:52:32 <joelteon> i don't know
14:52:35 <joelteon> how do i do that
14:52:50 <joelteon> nm?
14:52:51 <stass> joelteon: on ELF systems you can use nm
14:52:56 <stass> joelteon: on OS X...
14:53:02 <stass> joelteon: probably otool something
14:53:05 <joelteon> yeah, i can use nm as well
14:53:05 <danilo2> merijn: Ok,so do you think I should somehow statically link C libraries also to provide "best installation expirence" on differentlinux platforms or should I go other way around ?
14:53:12 <joelteon> that symbol has a T before it
14:53:14 <joelteon> what does T mean
14:53:22 <stass> joelteon: T means it exports it
14:53:27 <stass> joelteon: so it should be fine
14:53:28 <joelteon> which is what I'd expect, right
14:53:30 <joelteon> okay
14:53:39 <Taneb> Not sure if it's a me bug, a diagrams bug, a gtk2hs bug, a Cairo bug, a GTK bug, or what
14:54:03 <Thulsadum> the System.Plugins.Make from the plugins package cannot handle literate haskell?
14:54:14 <joelteon> hang on, stass, i'll clear out ~/.ghc and try again
14:54:17 <stass> joelteon: might make sense to try to run it under dtruss(1) and see what sdl library it actually loads
14:54:25 <joelteon> okay
14:57:34 <monochrom> the empty poset is an IPO (initial poset) :)
14:58:28 <joelteon> how do I figure out which SDL library it's loading?
14:58:30 <joelteon> dtruss has a lot of output
14:58:54 <stass> joelteon: just grep for SDL and see what's there
14:59:11 <stass> grep -i that is
14:59:11 <joelteon> ok, no results on that
14:59:24 <joelteon> i get a different exception when running the compiled version
14:59:44 <joelteon> and it looks like the compiled one is linked against the correct SDL.
15:00:05 <joelteon> oh, I get the error that's in the issue
15:01:08 <joelteon> oh man, there's a lot of crap you have to do to work around the OSX SDL magic >_<
15:01:18 <stass> heh
15:02:46 <sm> joelteon: yes there is, http://hub.darcs.net/simon/hssdl-osx-template may help
15:03:03 <sm> all this is why I suggested fungen first :)
15:03:09 <joelteon> what does Gloss use?
15:03:24 * stass suggests !OSX
15:03:32 <sm> "Gloss uses OpenGL under the hood"
15:03:40 <joelteon> i'd love to use opengl
15:03:49 <joelteon> gloss isn't really designed for game programming though
15:03:57 <joelteon> I mean, I'd prefer to use opengl anyway
15:04:03 <sm> it has some game loop support built in though
15:04:14 <stevely> if you're looking for an sdl substitute, glfw's a good choice and has haskell bindings
15:04:39 <joelteon> oh, gloss has the animate function
15:05:04 <joelteon> oh and it also has play
15:05:14 <merijn> danilo2: I don't really know what the best approach
15:05:28 <merijn> joelteon, stass: nm works on OSX
15:05:30 <joelteon> gloss looks like it might be the best option
15:05:56 <joelteon> fungen is improperly version-restricted on openGL, it won't build with newer versions of the package
15:06:04 <joelteon> wow, graphics suck :)
15:06:20 <stass> merijn: yeah, I probably confused nm(1) with something else.
15:06:24 <stass> merijn: ldd perhaps
15:06:27 <sm> joelteon: thanks for the report, I'll fix that
15:06:27 <danilo2> merijn: ok, thank you, so I'll try to ask this question one more time, maybe osmebody will notice it and know the answer :)
15:06:33 <joelteon> oh, right
15:06:36 <joelteon> no problem
15:06:39 <ciferkey> So I wanted to install bytestring-lexing but that requires alex and alex requires happy. Happy fails to install because it says it requires happy…. http://lpaste.net/93353
15:06:44 <sm> use --constraint 'OpenGL < ...' for now
15:07:00 <merijn> stass: Yeah, for ldd you want "otool -L" on osx
15:07:17 <sm> separate issue: which is the proper package to use when you need the system locale ? haskell98 ?
15:07:17 <merijn> joelteon: As for graphics sucking
15:07:25 <merijn> @quote revolutionary.ai
15:07:25 <lambdabot> No quotes match. My brain just exploded
15:07:27 <merijn> aww
15:07:38 <joelteon> @quote revolutionary
15:07:38 <lambdabot> No quotes match. It can only be attributed to human error.
15:07:40 <danilo2> So the question was - if I want to distribute my binary application together with GHC compiler (and Haskell platform) - what is the bestapporach to make the installation for the end user the most straigthforward and distribution (Linux) independed? Shoudl I compile GHC with all libraries (especially C libraries) statically linked? do you have any hint?
15:07:48 <sm> (time locale, I mean)
15:08:02 <merijn> lambdabot forgot that quote again >.<
15:09:34 <anakreon> :info (->)
15:10:03 <ski> @kind (->)
15:10:03 <lambdabot> * -> * -> *
15:10:05 <nulllo> http://imgur.com/a/DBix4#jguFHBv
15:10:15 --- mode: ChanServ set +o monochrom
15:10:19 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.194.219.45.56
15:10:20 --- kick: nulllo was kicked by monochrom (nulllo)
15:10:46 <anakreon> Wrong buffer
15:10:56 <tac> Is there a way to tell, in GHCi, where a certain symbol is defined?
15:11:41 <sm> tac: :i SYM
15:11:52 <tac> tyty
15:13:10 <zq> omg, i give up. i can't read core
15:13:52 --- mode: monochrom set -o monochrom
15:15:26 <Peaker> quicksilver: read some backlog, not sure if you got an answer for that, but arr and &arr aren't the same thing
15:16:42 <peteretep> TheJobPost? No relation, just something you might be interested in
15:16:46 <Peaker> quicksilver: there's no imprecision of thinking in C, just a very confusing/silly rule, that when you take the value of an array-expression, you get a pointer to its first element as there are no array-typed (r)values. Along with another rule to desugar array-typed parameters in function param lists to pointers which puts the final nail in the confusion coffin
15:16:53 <Thulsadum> is there an alternative to maybe, where i could pass error messages with nothing? or would that be my first own usefull monad?
15:17:06 <Peaker> Thulsadum: Either String
15:17:25 <Peaker> Thulsadum: or  Either YourErrorType
15:17:39 <Thulsadum> does either autmaticly pass right/left around, like maybe automaticly passes nothing?
15:17:45 <monochrom> ciferkey: I cannot reproduce the problem. builds fine here. I have made sure that I hid away happy and alex before trying.
15:18:06 <Peaker> Thulsadum: yeah
15:18:07 <Thulsadum> i'd like to prevent a huge case of mess.
15:18:31 <Peaker> Thulsadum: "Either e" is a Monad with similar semantics to "Maybe", and the first "e" encountered is propagated
15:18:57 <ski> Thulsadum : this is what `Either e' is for
15:19:01 <Thulsadum> nice :)
15:19:13 <Thulsadum> ok, thanks for the explanation
15:19:31 <merijn> quicksilver, Peaker: For a concrete example off arr and &arr being different (assuming arr is an array): "int arr[10]; int i = sizeof(arr);" <- i = 10*sizeof(int), not sizeof(int*)
15:19:38 <ReinH> you can also use (YourError, a) if you want ;)
15:19:40 <ciferkey> monochrom: thanks, I'll keep digging around. I just found it odd that happy was claiming to need happy to build.
15:20:18 <merijn> quicksilver, Peaker: Of course, once you stuff arr into an int* (for example, when calling a function) this size info is lost
15:21:22 <mauke> POP QUIZ, HOT SHOT!
15:21:35 <mauke> what is the result of (sizeof "??!")?
15:21:50 <merijn> uhoh, mauke is going to language lawyer my c knowledge :(
15:22:00 <stevely> usually 8
15:22:01 <Peaker> mauke: 4?
15:22:07 <merijn> mauke: I "I dunno" an acceptable answer?
15:22:10 <mauke> merijn: yes
15:22:13 <monochrom> that may be the same as sizeof(char*)
15:22:14 <mauke> also, it's 2
15:22:14 <merijn> w00t!
15:22:17 <elliott> mauke: that's a trigraph
15:22:19 <elliott> so 2
15:22:21 <elliott> dammit
15:22:45 <monochrom> sizeof "I dunno"
15:22:50 <merijn> At least mauke didn't correct me, so I'm relatively confident I didn't f- up my explanation
15:22:53 <geekosaur> the C compilers I use will make a snotty comment and ignore your trigraph :)
15:23:07 <geekosaur> (rather, treat it literally)
15:23:07 <mauke> s/C/not-quite-C/
15:23:09 <shachaf> I,I sizeof.c
15:23:46 <merijn> mauke is a contraption for teaching people C by calling bullshit everytime something claims something non-standard about C :>
15:23:50 <elliott> I thought it was 4 but realised it was a trigraph at the last second.
15:23:56 <mauke> http://mauke.hopto.org/stuff/c/sizeof.c
15:23:57 <Peaker> in C, if I'm not forgetting something, &x and sizeof(x) are the only ways to use x as an lvalue, and pretty much any other expression involving x will take its (r)value, which in the case of array/function will degrade to a pointer.  So &x and sizeof(x) are how you view that arrays are in fact not pointers
15:24:57 <merijn> mauke: Does that return "sizeof(char)"? (i.e. 1)
15:25:13 <mauke> merijn: yes
15:25:22 <merijn> \o/
15:25:31 <merijn> I didn't even have to open the standard :)
15:26:02 <elliott> I guess this is a good argument for not treating sizeof like a function.
15:26:18 <elliott> hmm, does return(0)["foo"] work too? I guess it does.
15:26:41 <mauke> yes, but that's different yet again
15:26:50 <mauke> return is a statement; sizeof is an operator
15:27:13 <elliott> right. but people often write both sizeof(foo) and return(foo);, treating them like functiony-type things.
15:27:27 <mauke> "if return was a function, how would it return?"
15:27:49 <int-e> aw, stack pointer magic. or CPS style :)
15:28:08 <mauke> did you mean: longjmp
15:28:13 <monochrom> "the same way exit(0) exits"
15:28:20 <stass> elliott: I usually write return(foo) so I can define it to something else later in case I need to add some tracing.
15:28:29 <merijn> elliott: I suspect "good argument for not treating sizeof like a function" was the reason mauke wrote that :)
15:28:35 <stass> mauke: setcontext/getcontext:)
15:28:41 <mauke> stass: not standard C
15:28:57 <elliott> well, C has functions you can't implement in C, so return could be one if you wanted.
15:29:07 <elliott> or at least, C can have functions you can't implement in C.
15:29:13 <Peaker> how much of C code in the wild is "standard C" as opposed to "POSIX C"?
15:29:15 <elliott> for instance, you can add setcontext/getcontext to C.
15:29:20 <mauke> Peaker: none
15:29:20 <merijn> Peaker: 0%
15:29:44 <mauke> well, I think ploki is pretty standard C
15:29:49 <mauke> modulo a few library functions
15:29:57 <int-e> mauke: hey, one of those hello world programs must be standard C :)
15:30:07 <merijn> Peaker: For shits and giggles, take code that compiles warning free on "-pedantic -Wall -W -std=c99" on gcc and run through icc/suncc
15:30:08 <davean> "< monochrom> "the same way exit(0) exits" Hahaha :)
15:30:08 <Peaker> Better phrasing: how much non-POSIX, standard C exists?  If everything is POSIX anyway, we can do away with some unused genericity/etc
15:30:20 <mauke> int-e: if it involves "main()" or "void main", it's wrong
15:30:44 <mauke> that already eliminates a good part
15:30:47 <merijn> Peaker: Posix mostly only exists in hosted C environments, not standalone, afaik
15:31:05 <Earnestly> mauke: Heh, Plan 9’s libc uses void main()
15:31:08 * monochrom bows
15:31:09 <merijn> mauke: Only if it's hosted C!
15:31:12 <geekosaur> and then of course there's clang... although fewer things that you might expect hide behind -fheinous-gnu-extensions
15:31:24 <merijn> mauke: Doesn't standalone C allow different prototypes for main?
15:31:25 <Peaker> I guess when you're in the kernel, you're writing non-posix C :) But most of the POSIX assumptions (e.g: bytes are 8 bits, sizeof(funcptr)=sizeof(dataptr)) still hold anyway
15:31:33 <elliott> Peaker: people write Windows code in C. people write embedded code in C
15:31:37 <mauke> merijn: I'd like to see you write portable hello world in freestanding C
15:31:57 <merijn> mauke: ssshhh, don't ruin my pedantism!
15:31:57 <Peaker> elliott: embedded nowadays is mostly POSIX too :)
15:32:07 <davean> Peaker: I don't think you are correct.
15:32:12 <mauke> merijn: AFAIK freestanding C doesn't make main special at all
15:32:24 <mauke> i.e. program startup is implementation defined
15:32:32 <danilo2> Hello :) Just a general question - doyou have any expirence iwth cabal-dev or justhub (http://www.justhub.org/overview) ? Is one of these solution superior over the other?
15:32:38 <merijn> mauke: I'm not sure, I'm no well-versed in freestanding C, I only remember that not being specified
15:32:43 <Earnestly> Peaker: Do you know what POSIX is?  (Specifically how it relates to the C programming language)
15:32:48 <merijn> danilo2: cabal has sandboxing built in now
15:33:06 <Peaker> Earnestly: yeah, it's a standard specifying extra things that were left as IB in original C, plus a bunch of APIs and their semantics
15:33:17 <danilo2> merijn: I didnt know about it! Thats nice
15:33:17 <Earnestly> Uh
15:33:19 <merijn> Peaker: huh, no it's not
15:33:48 <Peaker> merijn: how so?
15:33:54 <merijn> Peaker: Posix is a set of standards (set, not a single one! so saying something "is posix" is meaningless if you don't specify which ones)
15:34:13 <merijn> Peaker: It specifies system calls and additional libraries, neither of which are covered by C in the first place
15:34:14 <mauke> poset : set :: posix : six
15:34:17 <Peaker> merijn: Then there's no "the C standard" either
15:34:34 <Peaker> merijn: I said "plus a bunch of APIs and their semantics"
15:34:38 <merijn> Peaker: Sure there is, the ISO C11 standard is the latest version of the C standard
15:34:40 <Earnestly> Peaker: Yes there is?  C98, C99, C11, etc.
15:34:52 <Peaker> Earnestly: those are multiple versions of the C standard, like POSIX has multiple versions
15:34:57 <merijn> Peaker: Unqualified "C standard" refers to the latest one
15:35:00 <geekosaur> Peaker, POSIX is an OS standard, it covers more (and less!) than a C standard
15:35:12 <Peaker> geekosaur: that's what I said above
15:35:16 <geekosaur> OS set of standards really, as noted
15:35:18 <Earnestly> But POSIX isn’t even remotely related to the C language outside of defining a standard API (set of libs)
15:35:20 <merijn> Peaker: There is no such thing as a "latest posix standard" since most of the are orthogonal
15:35:21 <mauke> no, the C standard explicitly invalidates its predecessors
15:35:49 <Peaker> Earnestly: no, POSIX defines things like sizeof func-ptr being sizeof data-ptr, that bytes are 8 bits,  that C leaves implementation-defined
15:36:46 <Peaker> mauke: so -std=c89 would error out as invalidated?
15:37:00 <mauke> no, because gcc gives no fucks
15:37:13 <merijn> gcc hardly qualifies as a C compiler
15:37:16 <Peaker> Well, whether the standard ceases to exist when invalidated is not an interesting question to discuss :)
15:37:27 <merijn> gcc is more of a "something vaguely C-like" compiler
15:37:31 <mauke> merijn: gcc doesn't even claim to be a C compiler! (but gcc -ansi -pedantic does)
15:37:49 <FreeFull> What is a standard's compliant C compiler?
15:38:07 <merijn> mauke: In my experience icc doesn't buy "gcc -ansi -pedantic"'s claim
15:38:09 <Earnestly> FreeFull: gcc and clang support c11
15:38:21 <merijn> FreeFull: I'm not sure one exists, icc and suncc are probably closest
15:38:30 <mauke> merijn: compilers aren't required to detect all errors
15:38:53 <FreeFull> Earnestly: I mean 100% standards compliant, for any of the C standards
15:38:56 <Peaker> POSIX and C have published multiple versions of their standards.  Claiming thus that "POSIX is not a standard" seems like pedantry to me.  Haskell is a language, despite having multiple versions..
15:38:58 <Earnestly> FreeFull: Yes.
15:39:14 <mauke> technically you could make a compiler that starts with fprintf(stderr, "Your program may contain one or more errors.\n"); and you'd be fine
15:39:44 <danilo2> merijn: I've found here info about cabal sandboxes: http://hackage.haskell.org/trac/hackage/wiki/SandboxedBuildsAndIsolatedEnvironments, but the command cabal sandbox-init does not work. Is this feature implemented?
15:39:48 <FreeFull> Apparently  2cos(pi/5) = phi
15:39:54 <mauke> because the standard doesn't require any specific messages and it doesn't forbid diagnostics for "correct" code
15:39:56 <Peaker> "No, Haskell is not a language. Haskell is a set of languages that ..."
15:40:04 <merijn> danilo2: Which cabal version do you have? Did you upgrade to 1.18?
15:40:41 <Earnestly> Peaker: But haskell isn’t a set of languages, posix is a set of standards (not forgetting SUS)
15:40:42 <merijn> Peaker: The problem is people say silly things like "it's portable, because it's posix" but there is wild variance in which posix standards are supported on platforms, so you *need* to know which ones
15:40:44 <danilo2> merijn: I've upgraded to 1.18.1 just a moment ago. Give me a second. I'll check it to be 100% sure
15:40:54 <Peaker> Earnestly: how is POSIX more a "set of standards" than Haskell is a "set of languages"?
15:41:07 <mauke> Peaker: because it's multiple standards?
15:41:08 <hpc> Peaker: it's actually a collection of tools, of which the kernel is just a small part
15:41:13 <hpc> it should be called gnu/haskell
15:41:23 <elliott> mauke: doesn't it require diagnostics for certain things and that's what -pedantic turns on?
15:41:33 <elliott> or is it enough to say something might be up to satisfy that requirement?
15:41:35 <Earnestly> Peaker: Because POSIX is a set of standards :|, POSIX.1-2008, POSIX.1-2001, POSIX.1c, etc.
15:41:51 <FreeFull> Heh, gnu/haskell
15:42:01 <danilo2> merijn: that strange. When I run "cabal install cabal", tha 1.18.1 is installed. but after the installatian "cabal --version" gives me "1.16.0.3". Hmm am I missing something?
15:42:11 <hpc> FreeFull: the world needs more mocking of RMS
15:42:12 <merijn> danilo2: Which shell are you using?
15:42:13 <geekosaur> more to the point is that there is a POSIX standard for shell commands, a POSIX standard for C API, a POSIX standard for ...
15:42:13 <mauke> elliott: AFAIK it just says "case X requires a diagnostic"
15:42:21 <mauke> elliott: "your program may contain an error" is "a diagnostic"
15:42:42 <Earnestly> POSIX.1 which defined stuff like I/O, Signals, Timers, and /included/ the ANSI C standard.
15:42:46 <danilo2> merijn: zsh (if youre asking about system shell). But I rehased the results
15:42:50 <Peaker> The Haskell language is a set of included features or versions, as you want to slice it, similarly to POSIX.  This kind of stuff is not enlightening.  When you hear about a POSIX-compliant system, you want to know which version/features are supported. Same with Haskell compilers.  Yet we don't say "Family of standards" for Haskell
15:42:52 <merijn> danilo2: Also, check where "cabal install cabal" installed it and what your path is
15:43:14 <geekosaur> Peaker, that's because there's only one that matters (ghc)
15:43:19 <merijn> Peaker: Because in reality there is a canonical "haskell" (i.e. ghc)
15:43:23 <geekosaur> if only POSIX were that simple
15:43:32 <merijn> Peaker: There is no "canonical set of portable/supported posix standards"
15:43:39 <danilo2> merijn: it was installed in: /home/<username>/.cabal/lib/x86_64-linux-ghc-7.6.3/Cabal-1.18.1
15:43:47 <merijn> One example, Windows is "posix compliant"
15:44:01 <Earnestly> ._.
15:44:01 <merijn> Try running your fancy "posix supporting, portable software" there
15:44:07 <Clint> 2% posix compliant
15:44:27 <hpc> man, i am so tired after running KILOMETERS today
15:44:31 <hpc> (0.06 kilometers)
15:44:47 <danilo2> merijn: ah, I've got it!
15:45:03 <danilo2> merijn: I've get another cabal installed, system wide in /usr/bin/cabal
15:45:04 <geekosaur> or see how far posix compliance gets you when porting linux software to os x. or to omnios
15:45:04 <danilo2> :)
15:45:13 <danilo2> merijn: thank you :)
15:45:30 <int-e> ... so many posix complainants ...
15:46:28 <merijn> int-e: We're not complaining about posix, but pointing out why saying "posix compliant" is useless without specifying *which* posix standards you comply with
15:47:15 <danilo2> One more question: Is it possible to install "local cabal", in such way, that it will install libraries not to ~/.cabal, but my specified directory? I'm not talking about sandbox. I'm talking about delivering cabal with my custom binary application and I do not want to update users cabal (if user has installed one before)
15:47:15 <joelteon> gloss might be the answer to my question
15:47:47 <monochrom> danilo2: there is --prefix
15:48:18 <monochrom> also, have you read my http://www.vex.net/~trebla/haskell/sicp.xhtml ?
15:48:21 <danilo2> monochrom: Oh, I didnt see it before. Ok if there is such option, its cool, thank you :)
15:48:48 <danilo2> monochrom: no, I didnt, but I'm going to read it now, thanks!
15:49:04 <monochrom> if you think that everything is in ~/.cabal, then you are wrong, and you must read it.
15:52:39 <Ralith> monochrom: love the title
15:53:11 <monochrom> hehe
16:01:05 <Earnestly> I was all excited for a second there
16:04:15 <FreeFull> > sqrtRat (1/2)
16:04:16 <lambdabot>   Not in scope: `sqrtRat'
16:04:31 <FreeFull> @let import Data.Complex.Cyclotomic
16:04:32 <lambdabot>  .L.hs:65:1:
16:04:32 <lambdabot>      Failed to load interface for `Data.Complex.Cyclotomic'
16:04:32 <lambdabot>     ...
16:45:44 <cdk_> names
16:51:17 <jack_rabbit> Can someone help me out with what I'm doing wrong here: http://lpaste.net/93356
16:51:26 <stevejb> newbie question. I have a module which has a data constructor, and I am trying to import this constructor into a different .hs file. I am using the line: "import Nmkg_test (InputSt)" but when trying to run this with runhaskell, I get "    Not in scope: data constructor `InputSt'"
16:55:20 <chrisdone> stevejb: you're just importing the type i expect
16:55:37 <chrisdone> stevejb: you need to write InputSt(InputSt) to import the constructor
16:55:49 <chrisdone> stevejb: or simple InputSt(..)
16:56:27 <stevejb> chrisdone: the code where I defined InputSt currently does not have an export list
16:56:46 <stevejb> do you mean that I need to export it explicitly, or import it differently?
16:57:03 <c_wraith> if no export list is specified, everything is exported implicitly, so that's fine.
16:57:40 <c_wraith> But if you do a limited import, you need to import both the type and its constuctors.
16:57:46 <stevejb> ah, I see, something like: import Nmkg_test (InputSt(..))
16:57:50 <c_wraith> yes
16:57:55 <chrisdone> stevejb: the type and the constructor are two separate things which can be imported separately. by default import Foo (Bar) means Bar the type, not the constructor
16:58:17 <stevejb> whereas Foo (Bar(..)) means both?
16:58:47 <c_wraith> it means the type and all its constructors.  Unless Bar is a class, in which case it means "the class and all its functions"
16:59:12 <stevejb> c_wraith, chrisdone: thanks!
17:02:38 <jack_rabbit> I'm trying to make Char an instance of a typeclass I've created, but I'm getting an error that I don't understand. The paste is here: http://lpaste.net/93356
17:03:09 <c_wraith> jack_rabbit: what type is b supposed to be?
17:03:26 <jack_rabbit> Any type that is in the Eq typeclass.
17:03:36 <ubikation> my definition of 'spaces = P.skipMany1 P.space' is screwing up (and I'm copying it out of scheme in 48 hours). What am I doing wrong?
17:03:41 <c_wraith> jack_rabbit: because the only place it appears in the class definition, it's unbound, making it implicitly universal.
17:03:42 <ubikation> the error is: "    No instance for (Text.Parsec.Prim.Stream s0 m0 Char)
17:03:42 <ubikation>       arising from a use of `P.space'
17:03:42 <ubikation>     Possible fix:
17:03:42 <ubikation>       add an instance declaration for
17:03:42 <ubikation>       (Text.Parsec.Prim.Stream s0 m0 Char)"
17:04:14 <jack_rabbit> c_wraith, Can you explain? I'm new to this.
17:04:15 <shachaf> jack_rabbit: Any type. Who chooses which type?
17:04:23 <c_wraith> jack_rabbit: the Eq class doesn't give you a way to construct a value.  How are you going to produce a value that's of *any* type in the Eq class?
17:04:32 <shachaf> @where any
17:04:32 <lambdabot> http://www.vex.net/~trebla/weblog/any-all-some.html
17:04:55 <jack_rabbit> c_wraith, I assumed that had to be done when creating instances.
17:05:31 <shachaf> jack_rabbit: My question wasn't rhetorical!
17:05:36 <c_wraith> The problem is the type signature promises the result of identifier will be any type the caller wants.  The implementation only provides a character.
17:05:55 <jack_rabbit> ahh. I see.
17:06:07 <jack_rabbit> Is there a way to do what I want?
17:06:46 <c_wraith> well, what is it that you want?  You want the type of Identifier to depend on the type of its argument?
17:06:54 <c_wraith> err, identifier.  Not caps
17:07:24 <jack_rabbit> c_wraith, basically, yes. I want any instance of the NodeData class to be able to produce an "identifier" for itself, as long as that identifier is a member of Eq.
17:07:45 <jack_rabbit> That's all that the classes that use it require.
17:07:53 <jack_rabbit> (as far as I can tell)
17:08:03 <shachaf> You think you want an existential. But it'll turn out you actually don't.
17:08:22 <c_wraith> There are two standard-ish ways to solve that problem.  Functional dependencies and type families.
17:08:30 <jack_rabbit> shachaf, maybe so. I'm trying to write generic code.
17:08:42 <shachaf> c_wraith: I think you're misunderstanding and going for answers that are way overkill.
17:08:50 <shachaf> Or maybe not misunderstanding.
17:09:13 <shachaf> Or maybe I'm misunderstanding.
17:09:36 <jack_rabbit> I think I'm doing this stupidly.
17:10:07 <ubikation> I think scheme in 48 hours fell behind parsec updates?
17:10:23 <jack_rabbit> I'm building a generic Graph data structure, each node of which should be able to contain an arbitrary data structure, as long as that data structure can be considered equal to another of the same type on some basis.
17:10:47 <jack_rabbit> I think I just have to make sure the data contained in the GraphNodes is a member of Eq, and not try all this NodeData nonsense.
17:10:56 <c_wraith> that sounds right.
17:11:23 <c_wraith> ubikation: quite likely.  that tutorial is pretty old, and not in active development as far as I know
17:11:50 <c_wraith> jack_rabbit: really, just throw the Eq constraints on the functions that need them.  Don't bother with them in other cases.
17:13:13 <danilo2> Hi! I've got a question connected to cabal sandboxes. I used to use cabal-dev and moved today over built in cabal sandboxes (cabal-isntall >= 1.18.0). But when I try to rebuild and reinstall a pacage, which other packages depends on I'm getting error. In cabal-dev I could use --force-reinstalls, but now
17:13:34 <ubikation> c_wraith: what do you think I should do? I'm really clueless and the type error is from the high beyond
17:13:36 <danilo2> I'm still getting error, that such action cannot be done. Is there a way to force cabal to reinstlal such package?
17:15:53 <c_wraith> ubikation: Can you put the code that error is coming from (and the error again, too) in a post on lpaste.org? That'd make it easier for us to help out.
17:16:06 <ubikation> c_wraith: sure thing!
17:17:56 <ubikation> http://lpaste.net/93357
17:18:13 <ubikation> and it's from here: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
17:19:03 <danilo2> Is it possible to reinstall a package, which other packages have dependencies on using cabal sandboxes?
17:22:34 <Ooku> wow, big channel
17:23:15 <Iceland_jack> Ooku: Thanks(⁈)
17:23:31 <Ooku> :)
17:30:40 <S11001001> danilo2: can you also request to reinstall those dependent packages?
17:32:44 <leo_33> in your opinion are the jews responsible for most of the evil in the world?
17:33:16 <Kelet> leo_33, define evil
17:33:26 --- mode: ChanServ set +o elliott
17:33:29 --- mode: elliott set +b *!*hejhekj@37.98.192.*
17:33:29 --- kick: leo_33 was kicked by elliott (leo_33)
17:33:32 <Ghoul_> this sounds impossible syntax-wise, but maybe theres a way to do Data = A { someRecord } | B { someRecord } or no...
17:33:46 <Ghoul_> /s/syntax-wise/type safety wise/
17:37:11 <danilo2> S11001001: Can I request the reinstalls automatically?
17:37:12 <pavonia> Ghoul_: You want the same field names for different constructors?
17:37:35 <Ghoul_> I was thinking different field names, since my types are packets
17:37:45 <Ghoul_> easiest way would be with a level of redirection.
17:38:09 <ski> @let data AB = A {ab :: Int , a :: String} | B {ab :: Int, b :: Bool}
17:38:10 <lambdabot>  Defined.
17:38:26 <Ghoul_> o-O how does that work
17:38:35 <ski> > map ab [A 2 "a",B 3 False]
17:38:36 <danilo2> S11001001: Lets imagine I'm developing several libraries: A, B and C. B uses A and C uses B. While  testing how B works after updating A I would like to simply reisntall A and B. C could be broken, but I do not want to waste tame to wait it to recompile.
17:38:39 <spaceships> i am unclear what the monomorphism restriction has to do with monomorphisms
17:38:41 <lambdabot>   [2,3]
17:38:49 <ski> > map a [A 2 "a",B 3 False]
17:38:50 <lambdabot>   Ambiguous occurrence `a'
17:38:50 <lambdabot>  It could refer to either `L.a', defined at L.hs:1...
17:38:54 <ski> > map L.a [A 2 "a",B 3 False]
17:38:57 <lambdabot>   ["a","*Exception: No match in record selector a
17:39:02 <ski> > map L.b [B 3 False,A 2 "a"]
17:39:05 <lambdabot>   [False,*Exception: No match in record selector b
17:39:08 <Ghoul_> ooh thats neat!
17:39:13 <Ghoul_> thanks
17:39:16 <ski> Ghoul_ : use with care !
17:39:20 --- mode: elliott set -o elliott
17:41:09 <ski> > map (\x -> x {L.b = True}) [B 3 False,A 2 "a"]
17:41:12 <lambdabot>   [B {ab = 3, b = True},*Exception: <interactive>:3:12-25: Non-exhaustive pat...
17:42:36 <Ghoul_> ;___; that looks scary
17:42:50 <ski> it's just record update, updating the `b' field
17:42:57 <ski> can't update it if it doesn't exist, though
17:43:08 <shachaf> lens can do it!
17:43:33 <danilo2> Hi! I'm using cabal-install 1.18 and the new built-in feature: sandboxes. I want to ask you how can I recompile a package, that other packaes depend on? Lets say B depends on A and C on B. I want to recompile and test A without wasting time to recompile B and C.
17:44:00 <raphie> I want to do a little project to better learn the language, and I'm thinking of building a reverse-function-lookup service. you give it some input and output, and it finds function(s) that match what you're trying to achieve. before I start, has anyone already built this?
17:44:11 <pqmodn> raphie: hoogle
17:44:33 <pqmodn> raphie: unless you mean something different by "input and output"
17:45:37 <raphie> pqmodn: well what would be awesome is if I could give it (+1) [1,2,3] -> [2,3,4] and it would tell me I'm looking for map
17:45:59 <raphie> it could check the types first, and then actually run the (sandboxed) code
17:46:35 <spaceships> do a lookup on hoogle, try functions one by one till you find a match?
17:46:38 <pqmodn> raphie: i see. i don't know of anything like that with Haskell, but i think the general term for that is synthesis
17:46:58 <bobajett> noob question about function composition. myInt = read (take 2 myString) :: Int  -- can I compose read and take 2 somehow? My naive attempt was ((read :: Int) . take 2) myString -- but that doesn't work.
17:47:19 <raphie> spaceships: well the idea is a fun challenge so I can explore the language :)
17:47:29 <raphie> Haskell seems like an ideal candidate owing to its purity
17:47:50 <pqmodn> raphie: not exactly what you want, but take a look at djinn too
17:48:17 <Ghoul_> hmm, I tried making a  data like this: https://gist.github.com/kvanberendonck/91b6c8a94b912aabf61f , however, the derive (Show ..) isn't *working* properly because when it gets printed I only get `InPHandshake` by itself, and not the names of the record like you would usually
17:48:39 <raphie> pqmodn: looks really cool
17:48:42 * ski . o O ( in a sober space, what you see is actually there (you don't hallucinate), and you don't see double )
17:48:44 <Ghoul_> do I have to do a nested derive or something, or am I forced to define my own boilerplate..
17:49:19 <raphie> > "what does this bot use for sandboxed eval?"
17:49:20 <lambdabot>   "what does this bot use for sandboxed eval?"
17:49:27 <Ghoul_> meuval
17:49:31 <ski> @help eval
17:49:31 <lambdabot> eval. Do nothing (perversely)
17:49:36 <ski> @help run
17:49:36 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:50:15 <raphie> so I guess a quick and dirty implementation of this would be to just run the user's code against every possible function until a match is found
17:50:37 <raphie> or have the user define a special function that returns a test-passing boolean
17:50:40 <pqmodn> raphie: might not be "quick" :)
17:50:46 <raphie> well quick to write :)
17:51:12 <raphie> is there a way to match type signatures when they're parametrized?
17:51:15 <ski> pqmodn : or "abduction"
17:51:26 <raphie> for example, if I find that the user wants a function that is Int -> Int -> Int
17:51:46 <raphie> should I just substitute all the Int's for a's and check for a -> a -> a?
17:52:20 <danilo2> Could somebody tell me please - are the cabal sandboxes very limited in ocmparison to cabal-dev or am I missing osmething? I want simply to force reinstlaling a pacage I'm develiping, but it is not possible ...
17:52:56 <acowley> Out of curiosity, is anyone interested in testing or working on some rather far ranging extensions to the machines package?
17:55:15 * hackagebot iterable 2.0 - API for hierarchical multilevel collections.  http://hackage.haskell.org/package/iterable-2.0 (MichalGajda)
17:55:17 * hackagebot hPDB 0.9999 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-0.9999 (MichalGajda)
17:55:19 * hackagebot hPDB-examples 0.9999 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-0.9999 (MichalGajda)
17:56:54 <bobajett> how can I compose "read" with "take"? ((read :: Int) . take 2) someString ? doesn't work.
17:57:22 <shachaf> Yes, because when you write "a :: b" it means that a has type b.
17:58:24 <bobajett> shachaf: so how can I compose "read"?
17:58:54 <ski> raphie : the book "The Functional Approach to Data Management : modeling, analyzing, and integrating heterogenous data" by Peter M.D. Gray,Larry Kerschberg,Peter J. H. King, Alexandra Poulovassilis (editors) in 2004 mentions a data base with such a search operation
17:59:03 <ion> @type read . take 2
17:59:03 <lambdabot> Read c => [Char] -> c
17:59:04 <ski> raphie : .. just thought you might be interested in it
17:59:13 <ion> Pick a c and it’ll work.
17:59:28 <shachaf> read . take 2 is how.
17:59:30 <ion> @type map read . take 2
17:59:31 <lambdabot> Read b => [String] -> [b]
17:59:37 <ski> bobajett : `read :: String -> Int ' ?
17:59:43 <shachaf> If you want to give it a type annotation, either annotate read or the whole thing or whatever.
17:59:52 <shachaf> But annotate things with the type they actually have.
18:00:26 <ski> bobajett : is only the first two characters of `someString' digits ?
18:00:43 <bobajett> ski: yes
18:00:54 <ski> bobajett : if the next character (if any) after the first initial two is not a digit, consider using `reads' instead
18:00:55 <raphie> ski: oh cool. I think I wanna try my own system out, but I'll take a look. v1 will probably be without any sort of type checking, just running everything, and v2 will do some filtering beforehand
18:01:11 <ski> > (reads :: ReadS Int) "1234 abcd"
18:01:12 <lambdabot>   [(1234," abcd")]
18:01:16 <ski> > (reads :: ReadS Int) "123-abcd"
18:01:17 <lambdabot>   [(123,"-abcd")]
18:01:21 <ski> > (reads :: ReadS Int) "x123-abcd"
18:01:22 <lambdabot>   []
18:01:25 <ski> > (reads :: ReadS Int) "-123-abcd"
18:01:26 <lambdabot>   [(-123,"-abcd")]
18:02:01 <bobajett> ski: cool thanks!
18:02:52 <ion> reads or equivalents (such as readMaybe) are almost always better than read.
18:03:11 <bobajett> shachaf: awesome! Actually thats what I was looking for, I couldn't remember that you could type annotate a function within an expression.
18:03:20 <ion> And readLn/readIO are better than read in IO.
18:03:36 <shachaf> readMaybe isn't equivalent to reads, unless your equivalence relation is on evilness or something.
18:03:49 <ion> Sorry, that came out wrong.
18:04:12 <ion> or other total alternatives
18:23:20 <joelteon> okay, so gloss doesn't do antialiasing
18:31:49 <joelteon> or it might, but I can't find a magic antialiasing option anywhere
18:40:21 * hackagebot sym-plot 0.2.0 - Plot permutations; an addition to the sym package  http://hackage.haskell.org/package/sym-plot-0.2.0 (AndersClaesson)
18:47:30 <TallerGhostWalt> exit
18:47:47 <monochrom> /quit
18:47:55 <monochrom> hehe
18:48:51 <Polarina> Why not have a bot that kicks people that say "exit"?
18:49:53 <monochrom> that does not solve the whole problem :)
18:50:10 <Ghoul_>  grr, I'm slamming my head against a wall with the typechecker
18:50:12 <leroux> Or !exit...
18:50:51 <monochrom> please don't do that. please instead slam the typechecker against a wall with your head :)
18:51:32 <Ghoul_> well, the usual trick of adding `return $` before the thing when it says "Couldn't match SomeMonad (blahblah) with actual type blahblah" isn't working :(
18:53:35 <Ghoul_> I somehow need to turn a `S.StateT ServerGlobals m0 ServerGlobals` into a `Proxy ... (S.StateT ServerGlobals m0) ServerGlobals`
18:53:54 <Ghoul_> note how ServerGlobals is outside the bracket in the 2nd bit -- that's what's confusing me :(
18:57:27 <Ghoul_> oh derp, I forgot a lift somewhere
19:15:04 <byorgey> @ask Taneb yikes, can you file that "Fatal IO error 4" thing on the diagrams-cairo bug tracker (or diagrams-gtk if that's what you're using)?  Whether it's a diagrams bug or not I'd like to have a record in case anyone else runs into it
19:15:05 <lambdabot> Consider it noted.
19:30:29 <haasn> monochrom: Isn't that what oleg does in his spare time? :)
19:31:36 <augur> is higher kind polymorphism just like .. polymorphism over functors, etc.?
19:35:04 <ski> augur : talking about `PolyKinds' or something else ?
19:35:08 <nisstyre> augur: I assume you're talking about the PolyKinds extension
19:35:18 <nisstyre> because otherwise there are no polymorphic kinds in Haskell
19:35:22 <augur> http://twitter.com/pigworker/status/382662549440696320
19:35:26 <augur> i mean what conor means here :)
19:35:47 <nisstyre> I assume he means PolyKinds or maybe the fact that kinds are unityped?
19:35:53 <nisstyre> (in normal Haskell)
19:36:12 <nisstyre> he wouldn't conflate the two though, so, must be PolyKinds
19:38:00 <augur> aha, polykind is kind of weird
19:38:23 <augur> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html#kind-polymorphism
19:38:33 <augur> so the type of proxy
19:38:35 <augur> is like.. what
19:38:42 <nisstyre> augur: https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
19:38:52 <augur> Proxy :: forall k :: kind. k -> *
19:38:54 <augur> ??
19:38:56 <augur> roughly speaking
19:39:01 <augur> which i guess in agda is more or less
19:39:22 <enthropy> why so many ::
19:39:23 <augur> Proxy : forall (K : Set1) -> K -> Set
19:39:24 <nisstyre> augur: the paper I just linked explains it in detail
19:39:48 <enthropy> you just write   data Proxy (a :: k) = Proxy
19:39:49 <augur> enthropy: i wanted to make explicit that k was a kind so i gave it a type
19:39:54 <augur> anyway
19:40:00 <augur> i think thats the right haskell analog
19:40:21 <augur> iinm kinds are Set1's
19:40:54 <augur> cause *, * -> *, * -> * -> *, etc are kinds, right
19:41:03 <augur> and those are Set, Set -> Set, and Set -> Set -> Set in agda
19:41:06 <augur> more or less
19:41:35 <Saizan> augur: higher kinded polymorphism is indeed the ability of being polymorphic over higher kinded types, i.e. forall (f :: * -> *). .. like in the type of fmap
19:41:56 <augur> Saizan: so not polykinds?
19:44:40 <haasn> that's *kind* polymorphism, not higher *kinded* polymorphism, no? :)
19:45:15 <Saizan> augur: nope
19:45:25 <nisstyre> haasn: the wording was "polymorphism at higher kinds"
19:45:35 <nisstyre> so, ambiguous wording
19:45:51 <Saizan> the higher is a giveaway
19:45:59 <nisstyre> yeah I guess
19:48:30 <haasn> enthropy: you can leave the ‘a :: k’ away, too
19:48:39 <haasn> It gets inferred as generally as possible
19:49:05 <haasn> augur: and indeed, asking :k Proxy in GHC will give you Proxy :: k -> *
19:49:27 <augur> haasn: right i know, i got the type from the link
19:49:34 <augur> i just wanted to be clear about what k was
19:49:37 <augur> that is, k :: kind
19:49:49 <haasn> k :: BOX
19:49:55 <haasn> Or something like that, at any rate
19:50:06 <haasn> GHC isn't too explicit about sorts
19:50:11 <augur> right
19:50:12 <haasn> Since there's nothing beside BOX anyway
19:50:33 <augur> so more or less, k : Set1 in agda
19:51:15 <zRecursive> Is kind type's type ?
19:51:24 <haasn> zRecursive: yes
19:51:28 <enthropy> haasn: oh it is generalized.. but not for type families
19:51:30 <haasn> (if I understood you correctly)
19:52:06 <haasn> enthropy: oh, interesting
19:52:13 <haasn> So type *families* get inferred at *
19:52:18 <enthropy> as in you can't leave off the signature with   type family F (a :: k)
19:52:35 <enthropy> and still have   type instance F (); type instance F Maybe -- both work
19:53:06 <zRecursive> sure, kind is NOT type itself
19:53:10 <augur> haskell's type system is getting increasingly baroque
19:53:23 <haasn> augur: it is, isn't it?
19:53:32 <NemesisD> anyone use cassava? trying to see how i could encode CSV data in constant space like it can decode in constant space. it looks like its api takes a vector, and i thought those were strict data structures
19:53:35 <augur> haasn: yeah. i'll still with proper dependent types :)
19:53:53 <enthropy> NemesisD: there's a streaming interface or something
19:54:00 <enthropy> that's probably harder to use
19:54:13 <NemesisD> enthropy: only for parsing by the looks of it
19:54:13 <haasn> augur: I'm sadly unfamiliar with them :( I'd like to learn Agda but it's just something that I can't really find myself fitting into any practical purpose; I don't have any theorems to prove or anything ._.;
19:54:47 <augur> haasn: as far as this is concerned, instead of Nat :: * :: BOX
19:54:56 <augur> you have   Nat : Set : Set1 : Set2 : ...
19:55:01 <haasn> Yeah
19:55:11 <augur> and also they're all values too
19:55:13 <haasn> Or uh
19:55:24 <haasn> 0 :: Nat :: * :: BOX -- instead of 0 : Nat : Set : Set1 ...
19:55:34 <augur> that too :p
19:55:49 <ski> nisstyre,augur : afaik, there are no polymorphic kinds in Haskell, even with the `PolyKinds' extension
19:56:01 <augur> i actually once saw something about having things below the level of values
19:56:02 <NemesisD> enthropy: basically all encoding apis are like ToRecord a => Vector a -> ByteString
19:56:11 <augur> so you could do   whatever : 0
19:56:18 <augur> i cant find it on the web now tho
19:56:20 <haasn> ski: you mean there are no rank 2 types, so to say?
19:56:41 <NemesisD> so i guess i could encode by generating vectors a chunk at a time and manually dump the header out on the first chunk
19:56:49 <ski> haasn : `forall a. (forall s. ST s a) -> a' is a rank-2 type
19:56:57 <haasn> rank 2 kinds*
19:57:07 <enthropy> NemesisD: one row at a time would be good enough? You can   Data.ByteString.Lazy.writeFile ... . map toRecord
19:57:15 <ski> haasn : no, i don't mean that
19:57:29 <NemesisD> Vector Field -> [Vector a] -> [Lazy.ByteString]
19:58:06 <ski> i mean that in `length :: forall a. [a] -> Int', `length' is known as a polymorphic value (function), while `forall a. [a] -> Int' is not known as a polymorphic type (it can be called a univeral type, if you want to)
19:58:07 <applicat1ve> NemesisD: somebody just wrote a pipes/cassava module; but inevitably there is nothing about writing out csv
19:58:27 <NemesisD> enthropy: yeah it just means that i need to make sure i match up field order, which is always a bummer in CSV but its not so bad
19:58:47 <NemesisD> applicat1ve: yeah that was on my first thing to check when i got home, no go
19:58:48 <ski> (also, `Maybe' is not a polymorhic type, nor is `Maybe a'. `Maybe' and `Either e' are parametric types, aka type functions)
19:59:11 <haasn> ski: and what about Proxy :: forall k. k -> * ?
19:59:32 <pqmodn> ski: sorry if i haven't followed along. can you provide an example of a polymorphic type?
19:59:37 <ski> haasn : that `Proxy' is a polymorphic type, with an associated universal kind
20:00:04 <ski> a polymorphic kind would have a univeral "meta-kind" (or whatever you want to call the next level in the typing hierarchy)
20:00:10 <haasn> Oh, right
20:00:14 <pqmodn> oh, i kind of see
20:00:30 <haasn> pqmodn: :|
20:00:45 <ski> pqmodn : `Proxy' is polymorphic since it can have specific instances, of kind `* -> *',`(* -> *) -> *',&c.
20:00:49 <NemesisD> it wouldn't be too hard to write a combinator that streams a lazy list of vector namedrecord to a lazy list of lazy bytestirngs
20:01:13 <NemesisD> except you couldn't generate the first row if the list was empty
20:01:14 <ski> just like `length' is polymorphic because it can have specific instances, of type `[Int] -> Int',`[Bool -> String] -> Int',&c.
20:01:24 <haasn> ski: so the fact that there's no polymorphic *kind* is trivial due to there only being one sort? Or something
20:01:33 <ski> haasn : yes
20:01:55 <pqmodn> is the name of the sort "Box", or is that something else?
20:02:03 <ski> augur,haasn,pqmodn : so imho, `PolyKinds' is a misnomer
20:02:25 * ski str mentioning this to Saizan already
20:02:27 <haasn> ski: I can agree with that
20:02:27 <augur> its kind polymorphism is what it is, surely
20:02:39 <haasn> PolyTypes would be equally fitting
20:02:54 <haasn> augur: KindPoly? :)
20:02:58 <augur> :)
20:03:15 <haasn> GHC 7.8: “PolyKinds” has been renamed “KindPoly” for pedantry
20:03:17 <ski> `Typeable :: forall k. k -> Constraint' is then a polymorphic type class
20:03:42 <ski> (i don't really think `KindPoly' is better)
20:03:50 <Saizan> KindForall
20:04:03 <ski> would be ok, i suppose
20:04:04 <jmcarthur> to be truly fitting with the other extensions it would have to be KindPolymorphism
20:04:27 <ski> jmcarthur : whyfore ?
20:04:33 <haasn> I think PolyTypes would be pretty decent
20:04:39 <applicat1ve> KindPoly, really?
20:04:41 <jmcarthur> most extension names are ridiculously long
20:04:46 <applicat1ve> and KindConstraint?
20:04:57 <haasn> jmcarthur: MultiParamTypeClasses -- could be even longer ;_;
20:05:01 <applicat1ve> its outrageous
20:05:03 <jmcarthur> true
20:05:11 <jmcarthur> KindConstraint? ugh
20:05:22 <jmcarthur> i thought the original names were fine
20:05:24 <haasn> {-# LANGUAGE BetterKinds #-}
20:05:40 <applicat1ve> there was the trouble deciding between singular and plural for ConstraintKind(s)
20:05:40 <jmcarthur> {-# LANGUAGE TheGoodExtensions #-}
20:05:56 <jmcarthur> (e.g. -fglasgow-exts?)
20:06:02 <Makoryu> {-# LANGUAGE HaskellTheGoodParts #-}
20:06:07 <haasn> applicat1ve: I think ConstraintKind(s) makes more sense than KindConstraint, the latter sounds like SortClasses !
20:06:12 * Makoryu shrugs awkwardly
20:06:12 <ski> hm .. when do we get language synonyms ?
20:06:12 <haasn> Or uh.. KindClasses
20:06:17 * haasn scratches head
20:06:19 <applicat1ve> i wouldnt mind a way of importing select groups of them, like -fglasgow-exts
20:06:46 <Makoryu> I guess using default language flags in Cabal files is good enough for now
20:06:48 <haasn> applicat1ve: I'd like more dependencies between language extensions
20:06:57 <ReinH> haasn: {-# LANGUAGE BenevolentConstraint #-}
20:07:04 <ReinH> DownrightNeighborlyConstraint
20:07:11 <jmcarthur> haasn: e.g. fundeps and multiparams?
20:07:28 <applicat1ve> haasn: there is a tendency to keep them more or less independent ?
20:07:40 <haasn> jmcarthur: yes, or importing ‘the good stuff’ like PolyKinds/TypeFamilies should bring with it other extensions you usually pull in alongside
20:07:42 <applicat1ve> occasionally there are entailments
20:08:18 <haasn> applicat1ve: Well, there is a certain class of extensions that do no real ‘harm’, no? They just change the language in ways that make it less backwards compatible (such as accepting a few programs that should fail, or failing to accept programs that should technically work)
20:08:27 <haasn> But without breaking semantics
20:08:30 <applicat1ve> GADTs --> GADTSyntax or whatever its called
20:08:40 <jmcarthur> actually a lot of extensions are backward compatible
20:08:44 <applicat1ve> oh i see yeah
20:08:55 <haasn> But if you're pulling in something really modern (like DataKinds) it's reasonable to assume the programmer will be writing up to date code enough to ignore a bit of backwards compatibility with what haskell98 technically allows/disallows
20:09:18 <haasn> like, say, DataKinds should pull in TypeFamilies, PolyKinds, maybe even MPTCs/FunDeps (because those do no real harm when not used, right?)
20:09:25 <jmcarthur> well, in the sense that they don't change the behavior or builability of existing code, which i now realize is not exactly what haasn meant
20:09:35 <jmcarthur> *buildability
20:10:09 <haasn> I just don't see what the harm in pulling them in more generously is. Does it slow down compiling? I'm sort of under the impression that GHC uses its “most powerful” representation internally one way or the other
20:10:46 <jmcarthur> i think the main reason against enabling more is that they are less well tested and supported
20:10:59 <jmcarthur> kind of a self-fulfilling property though, i guess
20:11:00 <applicat1ve> some unimportant things like LambdaCase would be pleasant not to have to import explicitly
20:11:12 <applicat1ve> or rather if you have to, its not worth it
20:13:57 <haasn> yeah, also MultiWayIf,  ViewPatterns etc.
20:14:25 <haasn> We need a Haskell2013 that will make the good stuff default :(
20:15:10 <haasn> TypeOperators ought to be default too by now..
20:19:37 <elliott> haasn: TypeOperators changed very recently!
20:19:48 <haasn> elliott: Did I miss some change?
20:20:10 <haasn> ‘very recentl’ -> within the past week
20:20:38 <elliott> yes, class Arrow (~>) where ... is no longer valid
20:20:43 <elliott> and type f ~> g = ... is
20:20:45 <elliott> not last week
20:20:50 <haasn> Oh, that. Wasn't that ages ago?
20:21:02 <haasn> Like 7.4 or something
20:21:36 <haasn> To be fair, I've never really known TypeOperators any other way. I just about started using them when the change happened :(
20:21:53 <Saizan> ah, those were the days
20:22:12 <ski> you know you want infix type variable operators
20:22:25 <elliott> haasn: it was 7.6
20:22:42 <elliott> definitely not standardisation-esque timeframes
20:25:39 <johnw> Saizan: are you at ICFP?
20:26:21 <haasn> ski: but I like type (~>) = WireP, too!  Also I don't think I could live without (+), (-), (*) etc. being type names (rather than variables)
20:26:25 <Saizan> johnw: nope
20:28:59 <ski> @type (:+)
20:28:59 <lambdabot> a -> a -> Complex a
20:31:35 <haasn> https://github.com/philipl/pifs haha
20:32:11 <WraithM> haasn: That is hilarious.
20:33:13 <haasn> Would it take more space to store the position of a subsequence in pi than it takes to store that subsequence in the first place?
20:33:16 <haasn> I'm guessing so
20:33:43 <haasn> Trivially due to the pigeonhole principle, even
20:55:12 <spaceships> why
20:55:16 <spaceships> ?
20:55:51 * hackagebot Win32-extras 0.1.0.0 - Provides missing Win32 API  http://hackage.haskell.org/package/Win32-extras-0.1.0.0 (KidoTakahiro)
21:15:57 * hackagebot pandoc-types 1.12.1.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.1.1 (JohnMacFarlane)
21:44:52 <haasn> With NamedFieldPuns and a record type that has a field in common among all constructors, would it be reasonable to allow, say, “f _{field} = ...” ?
21:44:58 <haasn> As oposed to “f x = ... field x ...”
22:11:11 <satc> why is this not an undecidable instance http://lpaste.net/93368
22:17:48 <stevejb`> http://lpaste.net/93369
22:17:57 <stevejb`> hello, I have a basic printing to file question, as shown in my paste
22:18:20 <haasn> putStrLn (show x) = print x
22:18:48 <haasn> stevejb`: you probably want ‘concatMap show’, not mapM show
22:18:49 <haasn> :t mapM
22:18:50 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:18:56 <haasn> yeah that one will sequence the resulting list..
22:19:01 <haasn> > sequence ["foo","bar","bat"]
22:19:02 <lambdabot>   ["fbb","fba","fbt","fab","faa","fat","frb","fra","frt","obb","oba","obt","o...
22:19:06 <haasn> > concat ["foo","bar","bat"]
22:19:08 <lambdabot>   "foobarbat"
22:19:14 <haasn> very different :)
22:19:39 <stevejb`> I see, that is why I was getting infinite output :)
22:19:40 <haasn> stevejb`: you probably even want ‘unlines’ instead of ‘concat’
22:19:46 <haasn> not infinite, just very big :)
22:19:52 <haasn> > unlines $ map show [1..10]
22:19:53 <lambdabot>   "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"
22:20:06 <stevejb`> yeah, that is exactly what I want
22:20:08 <haasn> oh, unlines includes trailing newline? the more you know
22:20:27 <Makoryu> Yeah, that's bitten me a couple times
22:20:37 <pavonia> satc: Doesn't undecidable mean a variable doesn't appear in the head at all?
22:20:46 <Makoryu> > intercalate "\n" (words "the bees on this page")
22:20:47 <lambdabot>   "the\nbees\non\nthis\npage"
22:20:49 <haasn> inter-- yeah
22:21:18 <haasn> pavonia: or appears in the context more often than in the head..; eg. ‘instance Foo a a => Bar a’
22:21:21 <stevejb`> that seems more appropriate
22:21:43 <haasn> stevejb`: well if you want a trailing newline you can use ‘unlines’ and putStr instead of intercalate "\n" and putStrLn :)
22:22:39 <stevejb`> haasn: :) got it. I think I can experiment with this. So, to get a list of strings I can simply do something `map show my_object_list`
22:22:43 <pavonia> haasn: What about (Foo a b, Bar a b) => Baz a b?
22:22:49 <haasn> pavonia: no idea
22:25:48 <pavonia> that seems to count as a flexible context
22:26:10 <pavonia> "for each assertion in the context: a) No type variable has more occurrences in the assertion than in the head"
22:28:15 <pavonia> satc: if I understand correctly, your instance doesn't violate the rules mentioned here http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/type-class-extensions.html#instance-rules
22:29:27 <shachaf> inter++
22:41:06 <satc> pavonia: Got it.
22:51:11 * hackagebot cab 0.2.1 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.1 (KazuYamamoto)
23:00:40 <adelbert_> is there a "function" form of >>= ? i couldve swonr it was called "bind" but cant seem to find it. trying to do something like this:
23:00:42 <adelbert_> > [1, 2, 3] >>= (\t -> replicate 5 t)
23:00:47 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
23:01:26 <haasn> there is for [] in particular, concatMAp
23:01:28 <haasn> concatMap*
23:04:33 <adelbert_> > concatMap (\e -> replicate 5 e) [1, 2, 3]
23:04:35 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
23:04:44 <adelbert_> haasn - thanks!
23:15:05 <Ralith> adelbert_: >>= is a function
23:16:43 <arkeet> Ralith: well, (>>=) is a function.
23:20:33 <Reite> What is >>= then?
23:20:57 <adelbert_> yeah bad wording on my part
23:21:10 <adelbert_> in retrospect it shouldve been
23:21:29 <adelbert_> infix vs. ….. prefix?
23:23:09 <shachaf> "(>>=)" is "prefix", as in "(=<<)".
23:24:12 <joelteon> so I need to convert a (Float, Float) vector into a radian measure and a magnitude
23:24:17 <joelteon> where should I look in the standard library
23:24:21 <adelbert_> > (>>=) [1, 2, 3] (\t -> replicate 5 t)
23:24:22 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
23:24:25 <adelbert_> today i learned
23:24:49 <shachaf> s/in/is/
23:27:23 <joelteon> hoogle is exceedingly useless in this respect.
23:27:58 <Taneb> I want to add a function to the groups library that raises something to a power group-wise
23:28:37 <Taneb> But I can't think of a name
23:28:42 <t4nk595> hello!
23:28:55 <shachaf> Taneb: times1p?
23:29:01 <partycoder> i didn't know hoogle. i've only used dash
23:29:11 <Taneb> So, foo (Sum 8) 4 = Sum (8 * 4)
23:29:21 <Taneb> shachaf, roughly
23:29:49 <Taneb> That's the semigroups name, isn't it?
23:30:01 <t4nk595> um. can I ask this question for ghci?
23:30:04 <shachaf> Yep.
23:30:15 <t4nk595> let mul  0 b = 0
23:30:20 <t4nk595> let mul a b = a * b
23:30:22 <arkeet> Taneb: how about (^^)
23:30:29 <Taneb> arkeet, isn't that taken in Prelude?
23:30:30 <t4nk595> mul 0 (error "no")
23:30:34 <arkeet> why yes
23:30:36 <t4nk595> raises an error
23:30:36 <Taneb> @type (^^)
23:30:37 <lambdabot> (Fractional a, Integral b) => a -> b -> a
23:30:49 <joelteon> hgeometry looks like the wrong package
23:31:04 <Taneb> What I want is (Group a, Integral b) => a -> b -> a
23:31:11 <arkeet> sure
23:31:24 <Taneb> For the Product group, they are almost equivalent, I think
23:31:26 <shachaf> I,I newtype Foo a = Foo { unFoo :: a }; instance Monoid a => Num (Foo a) where Foo x * Foo yf = Foo (x <> y); fromInteger 1 = Foo mempty; timesN n = unFoo . (^ n) . Foo
23:31:31 <arkeet> I don't like how Abelian has a Group constraint
23:31:34 <arkeet> why not abelian monoids?
23:31:38 <shachaf> Just add inverses. Or something.
23:32:23 <Taneb> arkeet, mainly because Wikipedia has an article on the former but not the latter
23:32:31 <arkeet> Taneb: sure, they're called commutative monoids.
23:32:56 <arkeet> abelian groups have a lot of nice structure which is why they deserve their own article.
23:33:11 <arkeet> at least, finitely generated ones do.
23:33:27 <arkeet> well, general ones are still better than nonabelian I guess.
23:33:44 <Taneb> And also I don't feel like groups is the best place to define a Commutative Monoid class
23:33:50 <arkeet> I agree.
23:33:57 <arkeet> I don't think it should be a class though.
23:34:02 <arkeet> unless it provides some new methods.
23:34:08 <shachaf> Taneb: Much better to define a free group type.
23:34:15 <Taneb> arkeet, it's not doing any harm
23:34:35 <Taneb> shachaf, if you can define a Haskell 98 free group type, I think I will actually pay you
23:35:06 <shachaf> Haskell 98? :-(
23:35:27 <arkeet> it's 2010 now.
23:35:44 <Taneb> arkeet, I don't think the FFI would help much
23:35:47 <arkeet> ;)
23:36:07 <arkeet> free group wouldn't be hard.
23:36:28 <shachaf> How do you define it?
23:36:53 <arkeet> the free group on X is the free monoid on (S union S^-1) modulo some relations.
23:36:59 <arkeet> er, X not S.
23:37:13 <shachaf> "modulo some relations"
23:37:24 <arkeet> yes, like deleting adjacent inverse pairs.
23:37:28 <shachaf> Right.
23:37:34 <shachaf> How do you define a type for that?
23:37:38 <arkeet> you don't.
23:37:49 <arkeet> you can't even tell whether you have adjacent inverse pairs without Eq.
23:37:55 <shachaf> Well, you can define it.
23:38:01 <arkeet> but with Eq you can, and then you can reduce things to a normal form.
23:38:06 <arkeet> uniquely.
23:38:09 <shachaf> E.g. newtype FreeGroup a = FG { runFG :: Group r => (a -> r) -> r }
23:38:54 <arkeet> is that really the free group, or are we assuming everything is lawful?
23:49:47 <shachaf> arkeet: Assuming group instances are lawful.
23:49:50 <shachaf> But I'm allowed to assume that.
23:50:16 <arkeet> ok, then my free group thing without reduction satisfies the universal property.
23:50:23 <arkeet> assuming group instances are lawful.
23:50:35 <shachaf> ?
23:50:43 <shachaf> What's the Group instance for your thing?
23:51:18 <arkeet> <> = concatenate words, invert = reverse and invert all the letters
23:51:27 <arkeet> the obvious thing.
23:51:31 <shachaf> What's your type? Something like [(Bool,a)]?
23:51:34 <arkeet> that works.
23:52:07 <shachaf> OK, that's not the free group, since [(False,a),(True,a)] is distinguishable from [].
23:52:52 <arkeet> I challenge you to find any polymorphic thing where mempty is indistinguishable from x <> invert x
23:52:53 <arkeet> without Eq
23:53:18 <shachaf> My FreeGroup type.
23:53:23 <shachaf> Assuming all Group instances are lawful.
23:53:34 <arkeet> that's a big assumption.
23:53:50 <arkeet> if you assume all the group instances are lawful,
23:53:58 <arkeet> then my thing is the free group, because we've assumed it's lawful.
23:54:06 <shachaf> ?
23:54:31 <shachaf> Pretend the class Group had proofs of the laws in it.
23:54:40 <arkeet> =(
23:54:45 <shachaf> Fine, don't.
23:54:49 <arkeet> you can't do that in haskell 98.
23:54:52 <shachaf> I don't understand what point you're making, though.
23:55:01 <arkeet> my point is you can't do any better.
23:55:05 <shachaf> You can't do FG in Haskell 98 because of the forall.
23:55:34 <shachaf> But if you allow RankNTypes and you assume that all Group instances are legal, then that's exactly a free group type. Isn't it?
23:55:55 <arkeet> is it?
23:56:09 <shachaf> Mostly.
23:56:28 <arkeet> how would you tell whether a group instance was legal?
23:56:42 <shachaf> You write a proof when you make the class instance?
23:56:49 <shachaf> Put the proof in the comments if you like.
23:56:50 <arkeet> the proof involves equality.
23:57:10 <shachaf> Sure, but you can do that for a concrete type.
23:57:15 <shachaf> I'm confused.
23:57:23 <arkeet> I'm confused.
23:57:31 <shachaf> Let's go with newtype FM a = FM { runFM :: forall r. Monoid r => (a -> r) -> r } instead.
23:57:56 <Taneb> Can I just say that I still don't have a name for this function
23:57:59 <shachaf> Disregarding infinite lists and annoying things like that, I'd say that it's isomorphic to [].
23:58:12 <shachaf> When you assume that all Monoid instances are valid.
