00:07:15 <latro`a> ...perhaps a silly question, but I have a Color type which has an Enum instance. should [Red..Purple] and such work?
00:07:34 <latro`a> I seem to be required to write [(Red)..(Purple)], which seems redundant
00:07:53 <shachaf> Maybe GHC's error can give you a hint about what's going on.
00:08:01 <latro`a> "failed to load interface for Red"
00:08:12 <shachaf> > [False..True]
00:08:15 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
00:08:25 <shachaf> Hmm.
00:08:29 <latro`a> ...do I just need a space?
00:08:31 <shachaf> Anyway, it's taking Red as a module prefix.
00:08:36 <latro`a> I see
00:08:39 <shachaf> So yes. A space would work.
00:08:53 <haasn> :t (Prelude..Just)
00:08:54 <lambdabot> (Maybe a -> c) -> a -> c
00:08:58 <latro`a> gotcha
00:09:36 <haasn> it actually seems like it would make sense to me for a section to be valid, there
00:09:57 <shachaf> Where? What?
00:10:16 <latro`a> cool, that fixed it
00:10:25 <latro`a> thanks shachaf :)
00:11:38 <latro`a> and with that, hlint shuts up
00:11:41 <latro`a> \o/
00:11:57 <haasn> shachaf: [+2,*3] for example
00:12:24 <arkeet> > [False..True]
00:12:24 <shachaf> Oh. Nothing to do with module prefixes.
00:12:25 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
00:12:36 <arkeet> hah.
00:30:57 <mteverest> why does the expression -5**2 return -25?
00:31:36 <shachaf> Why wouldn't it?
00:31:50 <alpounet> probably parses as -(5**2)
00:32:16 <shachaf> Yes.
00:32:37 <mteverest> ah, ok
01:02:53 <shachaf> hvr: Hooray!
01:03:30 <shachaf> hvr++ # http://ghc.haskell.org/trac/ghc/ticket/7633#comment:28
01:04:56 <hvr> shachaf: I just merged the patch (and wrote some annotations in base/ghc-prim) though :-)
01:05:30 <shachaf> Oh, that was twan's comment about polishing the patch.
01:05:40 <shachaf> twanvl++ # 7633
01:06:10 <shachaf> @tell twanvl Thank you! [#7633]
01:06:10 <lambdabot> Consider it noted.
01:06:39 <shachaf> He even went with the ,-for-and |-for-or syntax.
01:09:00 <hvr> shachaf: being able to write nested and/or expression is necessary for stuff like Bits or Storage
01:09:10 <hvr> otherwise you'd have to write a dozen of lines
01:09:19 <shachaf> Yep.
01:09:39 <shachaf> I suggested DNF because it was the simplest thing, but it's awkward in some cases.
01:09:51 <shachaf> But I'm glad it was ,/| and not AND/OR like someone suggested.
01:10:17 <shachaf> (I think I even suggested the ,/| syntax in IRC at one point. But it makes sense since these characters already have that meaning elsewhere.)
01:10:34 <shachaf> (And also it's backwards compatible with DNF, if multiple MINIMAL pragmas are allowed.)
01:10:52 <shachaf> Anyway, I approve.
01:10:55 <hvr> | , stands out surprisingly well
01:11:31 <hvr> "," and "|" are special in haskell syntax anyway, so there's littel conflict with operators containing them
01:11:40 <shachaf> Right.
01:12:06 <hvr> otoh, I would found unicode symbols ok too :-)
01:12:15 <hvr> like the wedge operators for and/or
01:13:03 * hvr is quite happy with the feature as is
01:13:41 * shachaf is too.
01:13:49 <hvr> I was just surprised there weren't any warnings in GHC's code-base
01:14:00 <hvr> (except for an incomplete Traversable instance in haddock)
01:14:22 <hvr> (and of course a couple of hacks in the test-suite)
01:14:24 <shachaf> At least one person objected to putting join in Monad because GHC wouldn't emit waarnings.
01:14:42 <shachaf> So hopefully some actual library changes will be made as a result of it too.
01:15:02 <hvr> shachaf: for 7.8 or 7.10?
01:15:13 <shachaf> Not 7.8
01:15:41 <hvr> shachaf: is 'join' part of the AMP?
01:16:06 <shachaf> Many things have come up in many discussions.
01:16:36 <monoidal> hvr: Yes, because AMP currently warns if your module exports "join" and does not import selectively Prelude or Prelude hiding (join)
01:17:01 <hvr> monoidal: yeah, but is 'join' planned as class method or just as prelude function?
01:17:17 <shachaf> I hope it's put in as a class method.
01:17:26 <monoidal> hvr: Don't know, I hope the same
01:18:00 <hvr> let's hope together :-)
01:18:43 <monoidal> it is explicitly listed as a class method http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
01:18:57 <hvr> monoidal: I hope somebody on reddit might know an overlooked class benefitting from {-# MINIMAL #-}
01:19:09 <hvr> ah, ok
01:19:15 <shachaf> I know lots of classes, but not in base.
01:19:17 <monoidal> Monad! (after the AMP of course..)
01:19:37 <hvr> shachaf: any other classes in packages bundled w/ GHC?
01:20:14 <shachaf> I don't remember.
01:20:17 <monoidal> hvr: I might have already said that, but Error in transformers
01:20:44 <hvr> monoidal: I must have overhead :-) *noting*
01:21:01 <shachaf> Hmm, Monoid could have mappend/mempty defined in terms of mconcat, but I guess that it doesn't.
01:21:16 <hvr> alas, no transformers release is planned for GHC 7.7, and it
01:21:20 <hvr> 's a 3rd party lib
01:21:53 <shachaf> It could be nice to move liftA2 into Applicative, as long as those things are being moved around... Eh.
01:22:24 <shachaf> I don't remember anymore.
01:23:08 <shachaf> What about Enum?
01:23:19 <hvr> I didn't see anything cyclic in Enum
01:23:31 <shachaf> Oh, I guess not.
01:23:39 <shachaf> Enum is just a hack.
01:24:24 <shachaf> Alternative?
01:24:30 <shachaf> Oh, that has cycles but the defaults are OK.
01:25:03 <shachaf> It does have a "Minimal complete definition" comment -- it might be worth adding the pragma anywhere it's worth adding a comment?
01:25:09 <shachaf> I don't know.
01:25:34 <hvr> shachaf: I'd rather have haddock auto-infer trivial minimal-complete-definition info
01:26:02 <hvr> (and printing it, thus rendering the manual haddock-comment description superflous)
01:26:20 <hvr> so Haddock is the only (low-prio) piece missing for #7633 imho
01:26:21 <shachaf> Fair enough. If it's going to be inferred and always displayed then that's great.
01:27:11 <shachaf> (Though I generally find reading source to be much more usable than reading generated Haddock...)
01:27:49 <hvr> but it's a bit redundant to specify trivial {-# MINIMAL #-} annotations
01:28:04 <shachaf> Yes.
01:28:20 <hvr> (and distracting, as you might expect something non-obvious, and then there's no cycle at all)
01:35:42 <monoidal> #7633 should go to release notes, IMO to highlights
01:36:38 <hvr> strange, I thought the patch added something to the release notes
01:36:54 <hvr> good point
01:39:16 <quchen> monoidal: https://github.com/ghc/ghc/commit/bd42c9dfd1c9ce19672e1d63871a237c268e0212#diff-17
01:39:33 <quchen> Ah, release notes, not docs, sorry
01:39:37 <monoidal> yeah
01:39:54 <hvr> I need to mention the associated changes in base/ghc-prim too anyway
01:40:05 <hvr> I'll just do it now, before I forget
01:40:15 <quchen> hvr = Laarhoven?
01:40:25 <hvr> quchen: nope, hvr = hvr
01:40:31 <haasn> :t interact
01:40:33 <lambdabot> (String -> String) -> IO ()
01:40:48 <hvr> quchen: try /whois on my nick :-)
01:40:57 <quchen> hvr: Oh, from your comments I thought maybe you were the author of 7633
01:41:23 <hvr> quchen: this seems to confuse everybody :-/
01:41:32 <arkeet> twanvl is twanvl.
01:41:33 <quchen> You're just the committer, okaaaay.
01:41:44 <hvr> quchen: I even used an "authored-by:" in the commit message
01:42:01 <quchen> hvr: Yeah it's fairly obvious if you … use your eyes when looking at the commit
01:42:05 <hvr> hehe
01:42:26 <quchen> wanvl authored 8 days ago. hvr committed a day ago. quchen: HVR, DID YOU WRITE THAT PATCH?
01:42:32 <quchen> Good start of a day huh
02:02:31 <arianvp> sup guys
02:04:43 * hackagebot hpaco-lib 0.22.4.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.22.4.0 (TobiasDammers)
02:15:50 <ocharles> aw, `liftA2 (&&)` isn't valid syntax
02:16:57 <monoidal> `...` is valid only if ... is an identifier
02:17:02 <ocharles> yea
02:19:53 <Taneb> If I'm folding over a list strictly to generate a function, will I have to worry about space?
02:28:26 <ocharles> Hum, no MonadPlus for Either. Doesn't Monoid e => Alternative (Either e) make sense?
02:29:49 <Taneb> > Left "" >>= undefined
02:29:51 <lambdabot>   Left ""
02:30:00 <Taneb> > undefined >> Left ""
02:30:01 <lambdabot>   *Exception: Prelude.undefined
02:30:06 <Taneb> > Right () >> Left ""
02:30:08 <lambdabot>   Left ""
02:30:14 <Taneb> > Right undefined >> Left ""
02:30:15 <lambdabot>   Left ""
02:30:26 <Taneb> > Left "hi" >> Left ""
02:30:28 <lambdabot>   Left "hi"
02:30:32 <Taneb> Aha
02:30:35 <Taneb> It breaks that rule
02:30:46 <ocharles> eh?
02:30:46 <Taneb> "v >> mzero   =  mzero"
02:30:56 <ocharles> oh
02:32:26 <Taneb> I don't think there are enough Alternative laws
02:34:03 <shiona> > mzero :: Either String String
02:34:04 <lambdabot>   Left ""
02:34:45 <arkeet> > Left "a" >> mzero
02:34:46 <lambdabot>   Left "a"
02:34:58 <Taneb> The MonadPlus laws imply that mzero `ap` x == mzero
02:35:07 <Taneb> So why not "empty <*> x == empty"?
02:35:41 <arkeet> Alternative doesn't seem to have any laws.
02:35:55 <ocharles> err, why does lambdabot have an instance for MonadPlus on Monoid m => Either m ?
02:36:16 <arkeet> @undefine
02:36:16 <lambdabot> Undefined.
02:36:18 <arkeet> > Left "a" >> mzero
02:36:19 <lambdabot>   Left "a"
02:36:22 <arkeet> hmm.
02:38:02 <ocharles> mm_freak: I think we talked about this before, but what are the implications of (Monoid e, Monoid b) => Alternative (Wire e s m a b) ?
02:38:08 <Taneb> I'd propose add the laws: "empty <*> x = empty", and "x <*> empty = empty"
02:38:37 <arkeet> yes, a semiring object in the category of things.
02:38:44 <ocharles> asum [ (-10) . whileKeyHeld SDL.Left, 10 . whileKeyHeld SDL.Right ] feels like it should be producing '0' if both keys are held. but in this case it will produce -10 due to the left bias
02:38:55 <Taneb> ocharles, it allows you to choose the first wire that doesn't inhibit
02:38:58 <arkeet> er
02:38:59 <ocharles> Taneb: I know that
02:39:06 <ocharles> Taneb: but that's not the only behaviour possible
02:39:17 <Taneb> ocharles, I prefer the behaviour that uses the underlying m
02:39:26 <Taneb> But I know mm_freak doesn't like that
02:39:43 * hackagebot haskintex 0.1.0.1 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.1.0.1 (DanielDiaz)
02:39:55 <ocharles> Taneb: (Monoid e, Alternative m) => Wire s e m a b ?
02:40:04 <arkeet> do Wires get a Monoid instance?
02:40:11 <arkeet> > Just "a" <|> Just "b"
02:40:11 <Taneb> ocharles, you don;t need the monoid on the e
02:40:12 <lambdabot>   Just "a"
02:40:13 <arkeet> > Just "a" <> Just "b"
02:40:14 <lambdabot>   Just "ab"
02:40:25 <Taneb> You do need at least semigroup on the s, though, I think
02:40:40 * arkeet should learn about netwire at some point.
02:40:47 <arkeet> it seems like a thing.
02:41:37 <ocharles> arkeet, they do
02:41:53 <ocharles> but in that case if one inhibits, the whole thing inhibits. at least I think
02:41:54 <yesthisisuser> Hi guys! I'm reading on http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
02:42:00 <yesthisisuser> about semantic approximation order
02:42:54 <yesthisisuser> "As no number is more defined than another, the mathematical relation < is false for any pair of numbers:"
02:43:01 <arkeet> ocharles: hmm :/
02:43:04 <arkeet> > Nothing <> Just "b"
02:43:05 <lambdabot>   Just "b"
02:43:08 <yesthisisuser> "1 < 1 does not hold"
02:43:10 <yesthisisuser> etc..
02:43:19 <ocharles> arkeet: Maybe has a weird monoid instance in base
02:43:23 <arkeet> I know.
02:43:24 <yesthisisuser> but how is it that 1 <= 1 does in fact hold
02:43:26 <ocharles> ok
02:43:26 <arkeet> edwardk doesn't like it.
02:43:30 <ocharles> i also don't like it
02:43:30 <arkeet> yesthisisuser: because 1 is equal to 1.
02:43:45 <ocharles> Semigroup a => Monoid (Maybe a) is much nicer
02:43:51 <arkeet> <= is "less than or equal".
02:44:14 <yesthisisuser> well i am not referring to the normal order
02:44:19 <arkeet> yesthisisuser: I know.
02:44:35 <arkeet> the square things are harder to type.
02:44:40 <yesthisisuser> yes.. hehe
02:44:50 <yesthisisuser> ok. but isn't 1 and 2 equal also in terms of information quantity as they call it
02:45:24 <arkeet> that's kind of a misleading thing to say.
02:45:45 <arkeet> it's probably safe to ignore that part.
02:45:50 <arkeet> that sentence.
02:46:21 <yesthisisuser> ok. yes it did confuse me
02:47:34 <yesthisisuser> but it still feels like 1 is "as much defined" as 2
02:47:59 <yesthisisuser> i can't really ... see the intuition
02:48:52 <arkeet> but the pieces of information contained in 1 and 2 are incompatible.
02:50:11 <yesthisisuser> ok.. maybe if i try to print out the relation on paper
02:52:20 <arkeet> if I give you a 1, then you know it's not 2.
02:52:22 <yesthisisuser> forall x /= _|_ : _|_ < x .. that's pretty clear
02:52:30 <arkeet> but if I give you a bottom, then maybe it could be a 1.
02:52:40 <arkeet> maybe it could be a 2.
02:53:06 <yesthisisuser> right
02:53:40 <arkeet> I tend to think about it in this sort of way http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Powersets
02:54:12 <arkeet> sometimes
02:54:53 <donri> [why] is Category the only class made poly-kinded in HEAD?
02:54:55 <arkeet> maybe another way to think about it, if you know how haskell works:
02:54:56 <yesthisisuser> thanks. let me have a look at that
02:55:11 <arkeet> there is no function () -> Int that takes undefined to 1 and () to 2.
02:55:24 <arkeet> (this is "because" undefined <= (), while 1 </= 2.)
02:55:44 <arkeet> well, by undefined I mean bottom.
02:55:51 <arkeet> which could be undefined, or could be an infinite loop, or something.
02:56:50 <arkeet> so you could of interpret "x <= y" (for x and y in some type T) as "there is a function () -> T that maps bottom to x and () to y"
02:57:05 <arkeet> I dunno if that helps.
02:57:09 <arkeet> feel free to ignore if it doesn't.
02:57:35 <yesthisisuser> i sure does... it's getting a bit more clear now.
02:57:50 <yesthisisuser> thanks
02:57:53 <arkeet> :)
02:58:01 <arkeet> I really better go to bed now...
03:01:12 <JohnnyWho> I am interested in learning Haskell. However I 've got to ask: Is it truly cross-platform?
03:01:50 <tdammers> JohnnyWho: what do you mean, "truly"?
03:02:13 <tuxie_> JohnnyWho, how much cross-platform is truly cross-platform?
03:02:21 <tdammers> it works on Windows, most Linux distros, OS X, and probably any other UNIX-like OS
03:02:31 <tdammers> ghc, that is
03:02:35 <tdammers> not sure about other compilers
03:02:54 <tdammers> not sure about mobile platforms either
03:03:53 <ocharles> Bah, it's not possible to have infinite maps (containers Data.Map strict/lazy), is it?
03:05:00 <ocharles> mm_freak: another question for when you're around. Wanted to use a Timeline to represent the frames of an animation - that animation loops forever, so I thought I'd have an infinite timeline. I don't think I can do this though ,due to it being a newtype over a Map
03:05:38 <ocharles> though I'm now thinking Timeline is probably not what I want, as I don't ever need to go backwards
03:07:22 <supki> ocharles: even lazy maps are strict in the spine, so no, it's not possible, I don't think
03:07:58 <ocharles> supki: right
03:14:04 <haasn> tdammers: don't forget web browsers
03:14:20 <haasn> JohnnyWho: http://ghc.haskell.org/trac/ghc/wiki/Platforms
03:14:33 <tdammers> haasn: hmm, not sure how web programming fits in the platform question
03:14:33 <haasn> note: GHC is just one implementation of Haskell. It's the de-facto standard, though
03:14:53 <tdammers> server-side runs on another platform, really; client-side, I'd consider a platform in its own right
03:15:17 <haasn> tdammers: most people consider the web to be another “platform” these days I guess. Anyway, it compiles down to JS come 7.8 or whatever's merge of ghcjs, so anything that runs a web browser capable of interpreting javascript can effectively “run haskell”
03:15:59 <tdammers> yeah... still, the client side is only one half of the story
03:16:30 <haasn> anecdote: I've written platforms with a single platform in mind (my own) and seen other people compile them for the web, unmodified, despite me never having planned this initially
03:16:38 <haasn> I've written programs*
03:16:47 <tdammers> oh, yes
03:17:12 <tdammers> I just compiled one of my projects for windows, using wine, and it worked without modifications. Also ran perfectly in a windows vm.
03:17:32 <haasn> JohnnyWho: anything that doesn't use FFI will run on basically any platform, and there's a lot you can get away with in “pure Haskell”. I don't know how the FFI changes the situation, exactly
03:19:44 * hackagebot raven-haskell-scotty 0.1.0.2 - Sentry http interface for Scotty web server.  http://hackage.haskell.org/package/raven-haskell-scotty-0.1.0.2 (AlexanderBondarenko)
03:19:46 * hackagebot asn1-encoding 0.8.1.1 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.8.1.1 (VincentHanquez)
03:25:16 <tdammers> hmm, anyone else get compiler errors when trying to install glib-0.12.4 from hackage?
03:26:00 <JohnnyWho> haasn: I mean, I am using linux full-time. Someone has asked me to write some small GUI tools for windows. Can I write my apps on linux, then just recompile for windows?
03:26:15 <haasn> JohnnyWho: what GUI framework are you planning on using?
03:26:34 <Maior> JohnnyWho: I gather Qt and stuff Just Works
03:26:51 <haasn> I thought there are no good bindings for Qt
03:26:59 <JohnnyWho> GTK, which I know. I could use Qt though...
03:27:01 <haasn> And I don't know the status of Gtk support on windows
03:27:08 <haasn> Your best bet is to try it
03:30:29 <wilfredh> I'm looking for a function `Maybe a -> a -> a` that takes a maybe value and a default and returns the default if the first value is Nothing. Surely such a function already exists?
03:30:35 <wilfredh> (although it'd be trivial to write)
03:30:43 <Cale> :t fromMaybe
03:30:44 <lambdabot> a -> Maybe a -> a
03:31:16 <wilfredh> aha, thanks :)
03:31:34 <mr-> @hoogle a -> Maybe a -> a
03:31:34 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
03:31:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
03:31:34 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
03:31:42 <boothead> what are peoples favoured testing frameworks? Looking at hspec and test-framework...
03:33:01 <Cale> Does using QuickCheck directly count?
03:34:56 <Cale> (To be honest though I haven't really tried either of those libraries, they might actually be useful.)
03:35:27 <ocharles> boothead: I use test-framework and like that for the ability to generate Jenkins XML
03:35:39 <ocharles> I would like to move to tasty for the less mental internals, but it doesn't do enough that I want yet
03:35:46 <ocharles> I don't think tasty has test timeouts either, which are important for me
03:38:31 <boothead> ocharles, thanks. Jenkins will definitely be a requirement.. Do any others do that?
03:39:10 <ocharles> boothead: not that i'm aware of. I'm not sure I'd really choose jenkins for other projects now, with my nixos bias...
03:39:19 <boothead> ooo: http://hackage.haskell.org/package/hspec-jenkins-0.1.1
03:39:21 <ocharles> hydra is a CI tool that works with nix expressions, so i'd use that :)
03:41:26 <boothead> ocharles, yes we must have a chat about nix sometime!
03:47:25 <Taneb> Don't you hate it when you write an entirely mathematically correct algorithm that turns out to take longer than the lifetime of the universe to execute?
03:48:54 <Lethalman> Taneb, sometimes it's just a missing base case for a recursive function :P :P
03:49:10 <Taneb> Lethalman, no, I've written an O(n) algorithm
03:49:18 <Taneb> It turns out that n just happens to be...
03:49:25 <Taneb> > 5 ^ (108 * 4)
03:49:27 <lambdabot>   901658068143138259839739332275081390414903683599268753427956938125290057644...
03:50:03 <Lethalman> pseudo polynomial?
03:50:13 <mr-> > length $ show $ 5^(108*4)
03:50:14 <lambdabot>   302
03:53:30 <Taneb> Pseudo exponential, I think
03:56:22 <DMcGill> constant factors are to big-Oh as executing code is to Agda - technically important, usually ignored
03:57:23 <arnsholt> That's different, isn't it? This sounds more like the simplex algorithm: Linear in the number of vertices, but the number of vertices can grow exponentially
03:58:58 <ocharles> mm_freak: getting some really weird behaviour with --> that I can't suss, so give me a ping if you're around at some point
04:04:50 * hackagebot hnetcdf 0.1.0.0 - Haskell NetCDF library  http://hackage.haskell.org/package/hnetcdf-0.1.0.0 (IanRoss)
04:08:21 <kuribas> Do you program top-down or bottom-up?
04:08:42 <kuribas> I normally start bottom-up with the hardest problem first.
04:09:09 <Taneb> My programming style isn't very structured...
04:09:13 <AleXoundOS> kuribas, what Haskell encourages most?
04:09:16 <Taneb> Roughly top-down, though
04:09:25 <haasn> kuribas: start with the types
04:09:26 <DMcGill> depends - if the specification is clear enough from the start I like laying out all the needed functions with undefineds and getting the types right
04:09:32 <Taneb> Although I always start with the parser when relevant
04:09:59 <kuribas> Taneb: I start with the types, but sometimes they will change when I am programming.
04:10:04 <DMcGill> the problem with that is that lots of refectoring is needed when I inevitably change my mind on what I want the program to look like - it does feel more structured than bottom-up though
04:11:18 <kuribas> I don't feel that I am unstructured, because I know that I am going to need the functionality anyway.
04:11:56 <kuribas> But for a complex program I have a general structure in mind (or on paper).
04:12:21 <kuribas> Maybe it's all the same though.
04:26:08 * quchen writes down rough comments or type sigs and then lets the program grow in whatever direction it wants.
04:26:29 <exicer> Can anyone suggest a package to get the current date ?
04:26:42 * quchen then rewrites the program after finding out what the proper way of doing things is. GOTO 1
04:28:50 <kuribas> quchen: That's kind of like my workflow :)
04:29:50 * hackagebot wai-routes 0.3.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.3.1 (AnupamJain)
04:30:37 <ocharles> exicer: 'time'
04:30:46 <ocharles> exicer: which will give you Data.Clock
04:30:54 <ocharles> which has 'getCurrentTime', which gives you a UTCTime
04:31:54 <DMcGill> time is in the haskell package too
04:39:37 <cinimod> Does anyone know if Hamish Mackenzie hangs out here?
04:39:51 * hackagebot pontarius-xmpp 0.3.0.2 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.3.0.2 (JonKristensen)
04:40:38 <cinimod> hamishmack: if this is you and you are around I am trying to fix cairo
04:43:02 <Taneb> The only thing I can think of to make the selection smaller is to take a random sample...
04:45:45 <Taneb> Which will probably do roughly what i want
04:45:56 <Taneb> The question is how to take the sample
04:46:39 <DMcGill> I feel like this is about time to look up some literature
04:49:40 <DMcGill> https://www.youtube.com/watch?v=gENVB6tjq_M
04:51:21 <nomeata> killy9999:
04:51:24 <nomeata> sorry
04:55:50 <hamishmack> cinimod: Hi
04:58:03 <hpaste> tdammers pasted “gtk 0.12.4 build failure” at http://lpaste.net/93171
04:58:25 <tdammers> ^ anyone care to take a look?
04:58:38 <tdammers> I'm trying to install gtk2hs in a clean cabal sandbox, but it fails
05:00:43 <satc> Is there an alternative to showFFloat from Numeric which does not force extra 0 at the end. So for example I would want showFFloat (Just 4) 1.2 "" = "1.2" and not "1.2000"
05:01:22 <DMcGill> you could always use printf
05:02:19 <mauke> DMcGill: how?
05:03:01 <timemage> tdammers, using SetupWrapper.moreRecentFile Distribution.Simple.Utils.moreRecentFile only as search terms i'm finding people talking about a newer cabal conflicting with them.
05:03:09 <cinimod> hamishmack: hi sorry I was trying to fix the problem with programFindLocation
05:03:23 <satc> DMcGill: Thanks
05:03:39 <cinimod> tdammers: I am trying to fix that problem in cairo now
05:05:13 <tdammers> it is a brand new cabal, I can confirm this much
05:05:20 <tdammers> 1.18.0.1
05:05:51 <tdammers> so what should I do? downgrade cabal? (how?)
05:05:54 <timemage> tdammers, right.  they were indicating that's the problem, in as far as one chunk of code is responsible.
05:06:12 <DMcGill> hmm, my mistake: http://stackoverflow.com/questions/277772/avoid-trailing-zeroes-in-printf
05:06:15 <dcoutts> tdammers: build it using --cabal-lib-version=1.6.0.3  or whatever your older Cabal lib version is
05:06:26 <satc> DMcGill: printf also pads with 0 using "%.4f" format
05:08:14 <tdammers> (The package 'cairo' requires Cabal library version ==1.6.0.3 &&
05:08:15 <tdammers> >=1.8 but no suitable version is installed.)
05:08:19 <tdammers> that doesn't work
05:08:26 <boothead> Is there a way to make cabal repl aware of all of your top level Library/Executable/Test sections?
05:08:48 <dcoutts> boothead: you can use cabal repl on any of the components in your package, but only one at once
05:09:20 <dcoutts> tdammers: oh, sorry 1.16, use ghc-pkg list Cabal to see the exact version you want
05:09:21 <DMcGill> yes sorry, see that stackoverflow article. Stripping the trailing zeroes yourself with "dropWhileEnd (== '0')"
05:09:29 <DMcGill> satc: yes sorry, see that stackoverflow article. Stripping the trailing zeroes yourself with "dropWhileEnd (== '0')"
05:09:45 <DMcGill> could work if you can't find a better solution
05:10:03 <dcoutts> boothead: or did I misunderstand what you're asking?
05:10:55 <tdammers> dcoutts: 1.16.0.3 it is, yes
05:11:01 <tdammers> still doesn't compile though
05:11:24 <tdammers> oh wait, this is a different error
05:12:07 <tdammers> I think this could work, thanks
05:12:20 <boothead> dcoutts, that's it :-) I tried to load my Main into the emacs repl and it complained
05:12:43 <cinimod> dcoutts: lol - I just tried that myself and got unrecognized option `--dependency=bytestring=bytestring-0.10.0.2-d89fc6ac23afe3c0f91a3da1f908a56c'
05:12:52 <dcoutts> cinimod: ;-)
05:12:55 <mauke> > showGFloat (Just 4) 1.2 ""
05:12:56 <lambdabot>   "1.2000"
05:13:40 <dcoutts> cinimod: it's a good point though, we will need to make it fall back to using the options that Setup.hs built with older Cabal libs understand
05:14:03 <boothead> Is there a way to make emacs understand which component to use?
05:14:06 <dcoutts> cinimod: we do have that info available, the version of the lib we're targeting
05:14:22 <dcoutts> boothead: I'm afraid I've no idea what emacs is doing, is it calling cabal repl?
05:14:42 <cinimod> dcoutts: I just realised that also
05:15:13 <dcoutts> cinimod: I vaguely recall we mentioned this in passing during the hackathon
05:15:59 <boothead> dcoutts, I believe so, I might have a poke around in haskell-mode if I have time
05:16:20 <cinimod> dcoutts: yes I just forgot about it - I will go and fix but probably not today
05:16:42 <dcoutts> cinimod: no probs
05:17:11 <satc> DMcGill: Not a good way as it will output "1.0" as "1."
05:17:29 <mauke> drop '.' too
05:17:57 <cinimod> dcoutts: I am about 3 layers down a stack: I have to present on automatic differentiation which requires diagrams which requires cairo - I suppose I don't have to use diagrams but I'd like to
05:18:14 <dcoutts> ah
05:18:27 <dcoutts> cinimod: easiest workaround is certainly the --cabal-lib-version= thing
05:18:34 <satc> mauke: No, for "1.0" I want "1.0", for "1.0000" also I want "1.0"
05:19:05 <mauke> that's weird
05:19:11 <tdammers> is there a way to encode the --cabal-lib-version thing in the .cabal file?
05:19:13 <satc> mauke: Why ?
05:19:39 <dcoutts> tdammers: no, but I've been thinking about doing something like that
05:19:44 <satc> mauke: I dont want repetition of 0 at the end which printf "%.4f" usually gives
05:19:58 <mauke> satc: why do you want .0, though?
05:20:00 <dcoutts> tdammers: currently there is no way to specify dependencies of the Setup.hs itself
05:21:01 <satc> mauke: Thats how the output is expected in the problem I am solving.
05:21:21 <hamishmack> cinimod: There is a patch described here… http://sourceforge.net/mailarchive/message.php?msg_id=31418007
05:21:27 <mauke> satc: oh, what problem is that?
05:21:46 <satc> mauke: online judge problem. The input output format is fixed.
05:22:15 <mauke> sphere?
05:22:32 <satc> mauke: And my program is failing because it was outputting 1.0000 in one of the test case instead of 1.0
05:22:42 <tdammers> dcoutts: too bad
05:22:54 <DMcGill> perhaps strip trailing zeroes, then if it ends with a '.' add a '0'. It's not great but it'll do at least
05:23:07 <tdammers> well, I have a stub makefile anyway, so I might as well add the flag to that
05:23:27 <dcoutts> tdammers: it makes sense given the original concept was that Setup.hs was the interface to the package, and you used it by runhaskell Setup.hs
05:24:06 <DMcGill> failing that you could reverse, do "pattern match on s@('0':'.':_) = s; ('0':xs) = xs" and reverse again
05:24:09 <dcoutts> tdammers: and in that situation, there's no way you can have it depend on non-default libs. The user should expect to be able to just use runhaskell Setup.hs
05:24:56 <Janni> Hello.
05:25:00 <DMcGill> to be more formal: reverse . f . reverse where f s@('0':'.':_) = s; f ('0':xs) = f xs
05:25:05 <dcoutts> tdammers: my plan is to revise the Cabal spec so that the Setup.hs is primarily a machine interface not a user interface, and then we can have things like conditional compilation and dependencies for the Setup.hs
05:25:33 <satc> DMcGill: An ugly but working solution for now.
05:25:40 <mauke> DMcGill: fails on 100
05:26:33 <DMcGill> add a "if there is a '.' in the string"
05:26:36 <DMcGill> it's horrible complexity
05:26:46 <DMcGill> but I was under the impression that you don't really care about that
05:26:51 <satc> mauke: My output always is Double so has a . by default
05:26:59 <mauke> ok, fails on 1.2e100
05:28:02 <tdammers> dcoutts: I see.
05:28:10 <DMcGill> does showGFloat or printf give scientific notation output if you don't tell it to?
05:28:34 <mauke> > showGFloat (Just 4) 1.2e100 ""
05:28:36 <lambdabot>   "1.2000e100"
05:29:50 <DMcGill> printf "%.4f" 1.2e100
05:29:53 <DMcGill> > printf "%.4f" 1.2e100
05:29:55 <lambdabot>   Could not deduce (Text.Printf.PrintfType t)
05:29:56 <lambdabot>    arising from the ambiguity c...
05:30:15 <DMcGill> > printf "%.4f" (1.2e100 :: Double) :: String
05:30:16 <lambdabot>   "12000000000000000000000000000000000000000000000000000000000000000000000000...
05:30:42 <khyperia> Is there a "state map" function? Hoogle says nothing for (a -> b -> (c, b)) -> a -> b -> [c]
05:31:15 <khyperia> as in a state is carried along, with first state result passed into second element map
05:31:19 <DMcGill> :t Data.List.mapAccum
05:31:20 <lambdabot>     Not in scope: `Data.List.mapAccum'
05:31:20 <lambdabot>     Perhaps you meant one of these:
05:31:20 <lambdabot>       `Data.List.mapAccumL' (imported from Data.List),
05:31:24 <DMcGill> :t Data.List.mapAccumL
05:31:25 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:31:31 <khyperia> ah, thanks
05:36:39 <copumpkin> (x -> (acc -> (acc, y))) -> [x] -> (acc -> (acc, [y]))
05:36:45 <satc> > showFFloat (Just 4) 1.2e100
05:36:46 <lambdabot>   <[Char] -> [Char]>
05:36:51 <satc> > showFFloat (Just 4) 1.2e100 ""
05:36:52 <lambdabot>   "12000000000000000000000000000000000000000000000000000000000000000000000000...
05:36:55 <copumpkin> (x -> State acc y) -> [x] -> State acc [y]
05:37:02 <copumpkin> :t traverse
05:37:11 <copumpkin> :t Data.Traversable.traverse
05:37:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:49:22 <Reite> How do I make a andM function that will stop executing when it encounters a False?: andM :: (a -> IO Bool) -> [a] -> IO Bool
05:49:48 <Reite> allM*
05:49:55 <ocharles> @hackage monad-loops
05:49:55 <lambdabot> http://hackage.haskell.org/package/monad-loops
05:49:57 <ocharles> Reite ^
05:50:09 <ocharles> someone has already done the work for you :)
05:51:01 <acomar> anyone familiar with bindings-dsl? trying to figure out why I can't use types generated by it in foreign function declarations generated at the same time...
05:51:28 <Reite> ocharles: thanks :(
05:51:30 <Reite> :)
05:52:03 <acomar> #opaque_t Mat leads to "Unacceptable argument type in foreign declaration: C'Mat" when <Mat> is actually used
06:08:59 <Lethalman> is there a topological sort one liner somewhere?
06:12:16 <tromp_> :t topSort
06:12:17 <lambdabot> Graph -> [Vertex]
06:14:01 <Lethalman> tromp_, oh that's in lambdabot, nice thanks
06:14:12 <Lethalman> not in mine though uhm
06:14:16 <Lethalman> @where topSort
06:14:16 <lambdabot> I know nothing about topsort.
06:14:22 <Lethalman> @hoogle topSort
06:14:23 <lambdabot> Data.Graph topSort :: Graph -> [Vertex]
06:14:23 <lambdabot> Data.Graph.Inductive.Query.DFS topsort :: Graph gr => gr a b -> [Node]
06:14:23 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
06:20:49 <daemion> Hello.  Having trouble getting the haskell platform to compile...has to do with fgl and Control.Monad.State from mtl.  Might someone here possibly be able to assist me?
06:22:42 <shiona> daemion: you might want to take a look at the pastebin-thing in the topic and give us the command you are running & the errors
06:22:46 <kwstas> QUESTION: Hi there! We know that an applicative is also a functor. But why is that? Is it something that can be proved? Or is it something that we decided to impose?
06:23:37 <daemion> @shiona Aha.  Sorry.  One moment...
06:23:37 <lambdabot> Unknown command, try @list
06:24:13 <quchen> kwstas: You can show that "pure f <*> x" obeys the Functor laws, only assuming the Applicative laws (try it!).
06:24:21 <shiona> daemion: np, the question was valid. I most likely will be unable to give and relevant help so I thought I might help you get help
06:24:53 * hackagebot case-conversion 0.1 - Convert between different cases  http://hackage.haskell.org/package/case-conversion-0.1 (AlanHawkins)
06:25:08 <quchen> kwstas: Also, Haskell enforces every Applicative to be a Functor, and in addition it states that "instances of Applicative should also obey 'fmap f x = pure f <*> x'".
06:26:16 <DMcGill> would automatically quickchecking such laws be helpful? I suppose it doesn't really prove anything either way
06:26:52 <DMcGill> adds another dependancy too
06:27:39 <DMcGill> and it could only be done for a subset of all instances of typeclasses
06:28:09 <kwstas> quchen: i see. So it may be imposed by the specification of the language, but it is imposed because it can be proved mathematically.
06:28:36 <daemion> alright, the platform is Linux, the command is a simple 'make' following './configure' of the haskell-platform package.  Results here http://pastebin.com/neZphTvD
06:28:45 <mauke> The paste neZphTvD has been copied to http://lpaste.net/93172
06:28:45 <quchen> kwstas: Yes, it's a mathematical fact, and Haskell obeys that. Similarly, you can write an Applicative/Functor for every Monad.
06:29:20 <kwstas> quchen: Ok. Thanks a lot!
06:29:22 <quchen> daemion: It seems you haven't built Base with profiling.
06:29:23 <daemion> mtl is installed, apparently in the package cache, and Control.Monad.State can be accessed with ghci
06:29:54 <quchen> When you're trying to compile something with profiling enabled, all dependencies must support that.
06:30:01 <applicative> oh profiling daemion
06:30:11 <applicative> oh like quchen says
06:30:18 <quchen> Solution: Reinstall *everything*.
06:30:32 <applicative> is mtl in 'base'
06:30:32 <quchen> Well, everything Haskell-related :-)
06:30:49 <quchen> Oh, is a submodule I think.
06:30:55 <quchen> Anyway, it comes with GHC.
06:31:08 <daemion> Well, that sounds reasonable enough, but I'm not familiar enough with what I'm working with here to correct that.  Is 'base' a part of core ghc?
06:31:10 <quchen> OH WAIT.
06:31:13 <applicative> kwstas: what does ghc-pkg list mtl say ; is it globally installed or locally
06:31:25 <quchen> MTL isn't part of GHC, it's Platform. So I guess you just didn't build the Platform with profiling enabled.
06:31:47 <applicative> daemion: there are several distinctions unfortunately
06:31:59 <kwstas> applicative: sorry?
06:33:02 <quchen> kwstas: He meant daemion I think.
06:33:07 <daemion> applicative: I can't tell - it lists a whole mess of things, under /usr/lib/ghc-*/package.conf.d - so globally, I think?
06:33:20 <applicative> quchen: kwstas sorry i didn't prefix properly
06:33:45 <kwstas> applicative: it's ok. mo prob
06:34:01 <applicative> right, is mtl under that or under the other, $HOME/..
06:34:52 <daemion> applicative: everything, including mtl, is under /usr/lib/ghc(etc) - so I guess they're all global?
06:34:55 <applicative> if you got a lot of stuff from your package manager without profiling libraries, this will be unpleasant; but if you installed them all yourself it is likely to be simple
06:35:27 <applicative> daemion: wait, can you say what youre ultimately doing again?
06:35:42 <daemion> applicative: ghc and mtl came from my package manager, such as it is - I'll check on the build options.  The platform, I ran configure with no options aside from locationals (prefix, etc)
06:36:21 <daemion> applicative: I have installed ghc and haskell-mtl from my package manager, and am attempting to compile and install haskell-platform from the official tarball
06:36:38 <applicative> scrap haskell-mtl
06:37:05 <cinimod> hamishmack: I am updating Gtk2HsSetup
06:37:06 <daemion> applicative: I grabbed it because I was receiving that error - you still want me to scrap it?
06:37:25 <applicative> daemion: it is likely to be easier just to download the tarball from the ghc site for 'unknown linux'
06:37:34 <cinimod> hamishmack: in the latest version of cabal we need a ProgramSearchPath
06:37:47 <applicative> daemion: did the old error say 'you don't have mtl' or 'you don't have the profiling libraries', so to speak
06:37:53 <daemion> mtl
06:37:57 <DMcGill> is anybody familiar with the Monoid Function Pearl here? http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
06:38:15 <daemion> applicative: well, Control.Monad.State - it suggested that I didn't have mtl
06:38:35 <DMcGill> to solve the problem of (x1 ++ x2) ++ x3, difference lists are used
06:39:38 <applicative> daemion: lets just think this through. what does ghc-pkg list show installed -- just something like this? http://sprunge.us/DNBF
06:39:53 <DMcGill> i.e. (x1++) . (x2++) . (x3++) $ [] instead. Fair enough. However, when this is generalised to any monoid this same approach is used with 'difference monoids' i.e. (x1 <>) . (x2 <>) $ mempty.
06:40:28 <DMcGill> This assumes that a given monoid wants to associate from the left, like List does. Would it not have been better to use mconcat and let the Monoid specify itself how it associates?
06:40:42 <prophile> monoids are associative
06:40:50 <daemion> applicative: yes.  A bit longer in my case, but essentially the same.
06:40:54 <prophile> so it surely shouldn't make any difference
06:41:12 <DMcGill> (x1 ++ x2) ++ x3 is slower than x1 ++ (x2 ++ x3) for lists
06:41:19 <prophile> point
06:42:06 <daemion> applicative: my distro, sourcemage, compiles packages from scratch - in this case, the source tarball for ghc comes from haskell.org (the unknown linux tarball) and doesn't appear to be compiled with special configure options
06:42:09 <applicative> daemion: what method are you using now to install the haskell platform, just the giant directory of libraries
06:42:53 <applicative> daemion: the standard binary distribution comes with profiling, if I understand
06:43:23 <daemion> applicative: it's compiled from source on my machine - not distributed as a binary, as I believe you are implying?
06:44:27 <applicative> daemion: well, there will be 'make' involved, but it isn't 'compiling ghc from source' which is only done by ... another ghc, to put it crudely
06:44:28 <Taneb> > 300 ^ 5
06:44:29 <lambdabot>   2430000000000
06:44:45 <quchen> Self-compiling the Platform does not build profiling/shared libs by default.
06:44:54 <daemion> applicative: ghc, that is. For the haskell-platform, I have grabbed haskell-platform-2013.2.0.0.tar.gz from haskell.org, and have run ./configure and make
06:45:01 <daemion> applicative: okay, I see.  Fair enough.
06:45:16 <quchen> ./configure --enable-profiling
06:45:20 <quchen>  :-)
06:45:29 <daemion> quchen: I'll give that a go
06:46:47 <quchen> daemion: See also https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md#haskell-platform
06:47:08 <applicative> thats what bugs me, it's as if something was requiring -prof and something wasn't
06:47:08 <applicative> but the ghc main libraries he has, are compiled with prof
06:48:13 <donri> is there a way to get ghc to print the full list of missing patterns for non-exhaustion warnings?
06:48:32 <applicative> daemion: then the next thing that bugs me is that mtl is in the platform and is not needed to build itself, so to say
06:49:28 <daemion> applicative: curious, isn't it?  Well, lets see what it does with profiling enabled...still building.  Will take a few minutes...computer is no spring chicken anymore =)
06:50:30 <applicative> it should work, but there is still the question why the original breakdown, which was in the installation of one of the platform libraries, broke down for lack of profiling, when you hdn't specified it at all
06:52:04 <applicative> daemion: i just install the tarball ghc from http://www.haskell.org/ghc/download_ghc_7_6_3 and build only most of the platform libraries with cabal install x y z w; that things are built with profiling is specified in my cabal config
06:52:40 <daemion> still failing with the same error
06:53:21 <daemion> applicative: same error, though I didn't enable shared as per the instructions on that site.  Doing that now.
06:54:02 <applicative> daemion: oh by 'site' you mean quchen 's page on this.
06:54:19 <daemion> applicative: ah yes, sorry
06:55:20 <daemion> applicative: so you're saying you have access to cabal without haskell-platform?
06:55:49 <applicative> yes, i build it, it's simple; it has a little bootstrap.sh with a few options
06:56:10 <applicative> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml is the skeleton I used to use
06:56:13 <daemion> applicative: ahh.  Well really, that's the main point of this venture; I need cabal
06:56:27 <applicative> it's like quchen 's page but may have some extra stuff
06:56:34 <daemion> applicative: but by this point I'm irritated with yet one more package that won't compile, and want to fix the problem
06:57:01 <applicative> daemion: download the compressed source from the bottom of the hackage page (making sure to get the latest)
06:58:01 <Shin-LaC> applicative: hey, I'm back! regarding making an AVL tree a monad, I think the tree should be seen as a key-value map (since that's the external interface); now, if I have a map from, say, Int to String, and a function String -> Tree Int Char, I can apply the function to each String, but the problem becomes how to merge the different values for the same key...
06:58:15 <Lethalman> is there some paste that executes haskell code other than codepad?
06:58:24 <applicative> ideone
06:58:53 <Lethalman> applicative, thanks
06:59:31 <applicative> http://ideone.com/ijL1Sf
07:00:33 <Shin-LaC> applicative: it seems to me that making the tree an instance of Monad doesn't really make sense
07:00:41 <satc> I want to delete a key from a Map if it exist (return (Just key)) and if it doesn't exist return (Nothing). Is there a way to do better than 2* log(n) for this operation?
07:01:26 <daemion> applicative: is this the hackage page you speak of? http://hackage.haskell.org/packages/hackage.html
07:01:29 <DMcGill> Shin-LaC: that's your choice - Data.Map.insert replaces it, insertWith specifies a combining function or you could use a Monoid instance
07:02:25 <applicative> Shin-LaC: where is your Tree type again? I'm about to run out of power, of course
07:02:52 <Shin-LaC> applicative: http://lpaste.net/6260262172220194816
07:03:25 <Shin-LaC> DMcGill: but Data.Map is not a Monad instance, is it?
07:03:59 <DMcGill> Shin-LacL: nope.
07:05:04 <DMcGill> satc: you want updateLookupWithKey
07:05:50 <applicative> daemion: sorry, no i was thinking of the pages for Cabal and cabal-install
07:06:23 <xpika_> how do i add haddock documentation to my hackage cabal ?
07:06:29 <xpika_> http://hackage.haskell.org/package/case-conversion
07:07:07 <applicative> daemion: but wait, note that you already have the Cabal library as ghc-pkg list Cabal shows
07:07:15 <daemion> applicative: looks like you mean http://hackage.haskell.org/package/cabal-install.  That's really all I need, and then I can use it to install everything else?
07:07:45 <applicative> daemion: to install the cabal-install executable you get the matching version number
07:08:02 <DMcGill> xpika_: annotate your source like so: http://www.haskell.org/haddock/doc/html/markup.html
07:08:09 <applicative> so what does "ghc-pkg list Cabal" say?
07:08:11 <Shin-LaC> applicative: basically, you (I think it was you, at least) suggested making Functor and Monad instances for it, and while I did the former (not shown in that paste), I don't see how the latter makes sense
07:08:35 <daemion> applicative: ..huh...it does indeed show that.  I have no binary to run though... cabal *is* a binary, is it not?
07:08:54 <applicative> daemion: there are two things, it's a little confusing
07:09:09 <DMcGill> xpika_: see also: http://stackoverflow.com/questions/10369710/no-haddock-generated-when-upload-package-to-hackages
07:09:28 <satc> @pl \_ _ -> Nothing
07:09:28 <applicative> daemion: but you have everything you need to enter the cabal-install source directory and do the usual hand build
07:09:28 <lambdabot> const (const Nothing)
07:09:35 <xpika_> DMcGill: thanks
07:09:37 <destsk> Hi guys. I use fadeInactiveLogHook to fade inactive windows in XMonad. Is there any way I can make an exception for some windows, which I would never like to fade?
07:09:50 <destsk> People over at #xmonad aren't responding.
07:10:19 <quchen> Shin-LaC: You can't make a Monad instance for Map because you can't write `return`.
07:10:20 <t7> infixl:  does it look like this     (((1 + 2) + 3) + 4) ?
07:10:42 <quchen> (Same reason for Applicative.)
07:10:55 <daemion> applicative:  Okay - I'll try my luck with that if this latest build fails.  Been running awhile now; maybe it actually got past fgl
07:11:04 <Kinnison> destsk: Given the simplicity of that hook, just copy it into your xmonad.hs and alter it to filter windows as you wish
07:11:08 <applicative> daemion: the ins and outs of it are shown here https://github.com/haskell/cabal/tree/1.18/cabal-install but that page is in the source you get from the cabal-install hackage page
07:11:17 <Shin-LaC> quchen: I'd say that you can write return and you can write >>=, but not in a way that they make sense together
07:11:23 <adnap> What is the threaded runtime and how is a multi-threaded program comiled with the GHC -threaded flag different from the same program comiled without it?
07:11:34 <destsk> Kinnison, I'm a total noob. Could you help me out please?
07:11:45 <destsk> I'd like to filter mplayer, for example.
07:11:52 <quchen> Shin-LaC: You can't write return because that would have type "a → Map k a", and you don't have a "k" value.
07:11:54 <adnap> *compiled
07:12:11 <satc> @pl \a -> show $ foo b
07:12:13 <Kinnison> destsk: Honestly I can't help off the top of my head, I just looked at the code now
07:12:15 <lambdabot> const (show $ foo b)
07:12:15 <lambdabot> optimization suspended, use @pl-resume to continue.
07:12:17 <Kinnison> destsk: Sorry
07:12:29 <kstt> hello
07:12:48 <destsk> Kinnison: If you can have a look at it later or something, I would really appreciate it.
07:13:36 <Kinnison> destsk: Send me an email and I'll see if I have time later
07:13:42 <chrisdone> any vim users?
07:13:43 <Kinnison> destsk: dsilvers@digital-scurf.org
07:13:55 <Shin-LaC> quchen: ah, that's true. I guess you could make an instance for a specific type of Map, like Map Int?
07:14:21 <DMcGill> Shin-LaC: that's no longer return :: a -> m a for the Monad (Map k) though
07:14:30 <quchen> Shin-LaC: You could get around that by requiring Default for k, i.e. "instance Default k ⇒ Monad (Map k); return = singleton default", but then you have another problem: every Map created with return has the same (default) key.
07:14:43 <quchen> Shin-LaC: Having "Map Int" be a "Monad" would be a special case of this.
07:14:54 <quchen> Then there's a new problem: everything 'return'-ed has the same key.
07:15:13 <quchen> Therefore, "m >>= return" would crop the map to a single element (as everything maps to the same key).
07:15:35 <quchen> Hence m >>= return /= m and Haskell is sad.
07:15:54 <DMcGill> whereas Agda would be angry
07:15:56 <chrisdone> more specifically, any vim users interested in using the fp complete ide as a service for their vim?
07:16:17 <Shin-LaC> quchen: or you could have a sort of map with default where you can specify a value for any missing keys. then you'd just do that and have an infinite map with a in all keys. kind of like with ZipList
07:17:06 <mr-> chrisdone: how would that work?
07:18:07 <Shin-LaC> quchen: wait, nm, I think I'm thinking of Applicative
07:18:11 <stelleg> is there any way to know the "size" of an enumerated data type?
07:19:05 <stelleg> the only thing I can think of is doing something like `length $ map toEnum [0..]` and then catching the exception (not sure this would work just a thought)
07:19:26 <DMcGill> stelleg: if you have bounded AND Enum, you can do fromEnum maxBound - fromEnum minBound
07:19:29 <chrisdone> mr-: similar to ghc-mod/hdevtools
07:19:38 <quchen> stelleg: If you also have Bounded you can use `fromEnum . maxBound`, but that feels very hacky.
07:19:51 <stelleg> DMcGill, quchen: thanks guys
07:19:56 <DMcGill> Enums don't have to be bounded though, they may well be infinite
07:20:16 <DMcGill> ah, I guess that's what you meant by "catching the exception" but that won't work I'm afraid
07:20:26 <chrisdone> mr-: (hypothetically) you get an fp co account, get an api token and then cabal install fpco-client. you run fpco-client <your token> which starts a service and then vim talks to it for compilation/type info/hoogle/jump to definition and such
07:20:41 <stelleg> DMcGill: yeah just catch the exception wen it goes out of bounds
07:20:42 <kstt> http-conduit help needed please. My code connects to a https server, and it works fine with direct connect. However, when the connection goes through a HTTPS proxy, I get a TLS error : ERROR_EOF.  Please, has anyone succesfully used http-conduit with HTTPS request and proxy ?
07:20:49 <Shin-LaC> I'm thinking that "try to make it a monad" may not be such a good approach… maybe you should have a meaningful form of sequencing first, and then seeing if that can be framed as a monad
07:20:56 <stelleg> so finite/bounded is a requirement for what I'm doing, so that will work
07:21:03 <stelleg> thanks
07:21:19 <quchen> Shin-LaC: Sequencing is possible in a Map because it's Traversable.
07:21:25 <DMcGill> stelleg: quchen's solution is better than mine since fromEnum minBound === 0
07:21:36 <DMcGill> by the enum laws
07:21:51 <Shin-LaC> quchen: I'm not sure if sequencing is the right word, I mean the >>= part
07:22:01 <quchen> "piping" maybe.
07:22:07 <Eduard_Munteanu> Grr... class declarations should allow variables in the LHS of (=>) that don't occur in the RHS.
07:22:10 <Shin-LaC> ah
07:22:11 <quchen> Or "doing the bindy thingie" ;-)
07:23:04 <Shin-LaC> DMcGill: if I used Agda, would I be able to make it prove that my functions maintain the AVL invariant?
07:25:10 <Eduard_Munteanu> Shin-LaC: Agda's stdlib has an AVL implementation, although I think copumpkin reimplemented that because it wasn't strong enough
07:26:28 <Eduard_Munteanu> (The types didn't prove much.)
07:27:51 <Thulsadum> mh, a question of terminology: if I have a `data Foo`, what are realization during runtime called? instances? this is the analogy to imperative (OO) languages coming into my mind.
07:28:29 <Eduard_Munteanu> Thulsadum: what do you mean "realization"? Values for such a type?
07:28:37 <notdan> Thulsadum: I'd say "terms"
07:28:41 <Thulsadum> Eduard_Munteanu: yep.
07:28:43 <notdan> or "values"
07:28:57 <adnap> Asking again: What is the threaded runtime and how is a multi-threaded program compiled with the GHC -threaded flag different from the same program compiled without it?
07:29:22 <Thulsadum> i guess, simplest example would be 'foo :: Foo'
07:29:30 <Eduard_Munteanu> Thulsadum: "instances" isn't very wrong either if you're making closed "typeclasses" using GADTs.
07:29:47 <Eduard_Munteanu> But terms / values is probably best.
07:30:34 <quchen> notdan: "bindings"?
07:30:52 <Thulsadum> ok, then I'll stick to that. :) thank you two.
07:31:04 <notdan> adnap: multi-threaded runtime allows haskell threads to run concurrently on multiple cores
07:31:19 <adnap> notdan: Without -threaded they wont?
07:31:20 <notdan> s/concurrently/in parallel/;
07:31:30 <notdan> adnap: they would run on a single core
07:31:34 <adnap> notdan: Thanks
07:31:37 <notdan> you'd still get concurrency though
07:31:47 <adnap> I understand
07:32:47 <tdammers> adnap: https://en.wikipedia.org/wiki/Green_threads
07:32:54 <tdammers> Haskell threads are green threads
07:33:01 <tdammers> the runtime dispatches them onto OS threads
07:33:36 <notdan> quchen: hm, maybe, but I wouldn't say that (1 :: Int) is a binding though :)
07:33:51 <quchen> Right.
07:33:57 <tdammers> in the case of a single-threaded runtime, it dispatches them all to the same OS thread
07:34:55 * hackagebot sign 0.1.0 - Arithmetic over signs and sets of signs  http://hackage.haskell.org/package/sign-0.1.0 (MasahiroSakai)
07:35:19 <Eduard_Munteanu> GHC 7.6.1's manual says: "The behavior of the TypeOperator extension has changed: previously, only type operators starting with ":" were considered type constructors, and other operators were treated as type variables. Now type operators are always constructors." -- I'm confused, does it mean stuff like (~>) can't be a variable anymore? :(
07:35:59 <Eduard_Munteanu> That'd sorta suck.
07:36:52 <Eduard_Munteanu> Is there any workaround to keep my cozy type operator variables?
07:37:22 <Eduard_Munteanu> I don't want to write  a `arr` b. :(
07:37:23 <Eduard_Munteanu> @arr
07:37:24 <lambdabot> I'll keel haul ya fer that!
07:38:25 <w0rm_x> Eduard_Munteanu, what's wrong with that
07:38:40 <daemion> quchen & applicative: Platform is still compiling, so clearly it made it past fgl some time ago.  Therefore, the problem in question has been solved - the solution was --enable-shared.  Thanks for all the help.
07:38:44 <bergmark> Eduard_Munteanu: i don't think so
07:39:19 <Eduard_Munteanu> w0rm_x: stuff like generalized functors quickly get unreadable without nice arrow variables.
07:39:26 <bergmark> we had to make a sad commit to xml-arrow that did that replacement :(
07:39:49 <Thulsadum> next question: ist there a abortable/cutable version of map? i intendt to map a function over a list until the function returns a positive result
07:39:56 <Thulsadum> -t
07:40:19 <tromp_> :t takeWhile
07:40:20 <lambdabot> (a -> Bool) -> [a] -> [a]
07:40:48 <Thulsadum> thanks :D
07:40:51 <notdan> Eduard_Munteanu: I don't think it means that. From what I understand it says that (~>) can't be a _type_ variable
07:41:15 <lispy> > takeWhile (<0) (1:repeat 0)
07:41:17 <lambdabot>   []
07:41:17 <notdan> which is confusing because why would you have a type variable named (~>)
07:41:24 <lispy> > takeWhile (>0) (1:repeat 0)
07:41:25 <lambdabot>   [1]
07:41:35 <lispy> yay laziness
07:41:41 <Eduard_Munteanu> notdan: because it makes definition of classes like Category nicer.
07:41:45 <Eduard_Munteanu> @src Category
07:41:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:42:00 <Eduard_Munteanu> id :: cat a a   vs   id :: a ~> a
07:42:14 <lispy> do you mean type constructor?
07:42:32 <Eduard_Munteanu> class Category (~>) where ...
07:42:52 <notdan> Ah, I see, fair enough
07:43:01 <Eduard_Munteanu> lispy: don't know, I'm already confused :)
07:43:23 <lispy> Eduard_Munteanu: a type variable is a place holder and a type constructor is concrete
07:43:32 <mr-> chrisdone: cool, is there a demo for it somewhere?
07:44:03 <lispy> Eduard_Munteanu: Anyway, given your example of "class Category (~>) where ..." I think you mean variable
07:44:11 <Eduard_Munteanu> Yeah.
07:44:13 <chrisdone> mr-: i'm designing it now
07:44:14 <satc> I have a sequence of operations of inserting and deleting an element from a collection. After every operation I have to find the median of the elements in the collection. The operation starts with empty collection. I thought of using Map for this as I can do all the operations efficiently. The problem I am facing is handling duplicate elements. Any suggestions?
07:44:56 <Eduard_Munteanu> Anyway it gets rather interesting when you want to define functors like   class GenFunctor f (-->) g (~~>) where genFmap :: (f a --> f b) -> (g a ~~> g b)
07:45:20 <Eduard_Munteanu> That'd suck with "pirate" variables.
07:46:26 <lispy> arr
07:46:47 <chrisdone> yarr!!
07:46:47 <lispy> It is program like a pirate day, isn't it?
07:46:52 <lispy> @yarr
07:46:52 <lambdabot> Where d' all t' pirates come from?
07:46:52 <lambdabot> Great Yarrmouth!
07:46:56 <chrisdone> :t arr
07:46:57 <lambdabot> Arrow a => (b -> c) -> a b c
07:47:09 <Eduard_Munteanu> Wouldn't surprise me if they did that in anticipation of Talk Like a Pirate Day. :P
07:48:09 <chrisdone> al a t' b'an daan n'arken unto'im
07:48:37 <chrisdone> though, that's yorkshire. not pirate =p
07:49:16 <Eduard_Munteanu> Government-sanctioned buccaneer.
07:49:34 <lispy> How much does a priate charge for corn?
07:49:46 <lispy> A: A buccanear
07:51:04 <prophile> ouch
07:55:15 <benzrf> hiratara:
07:55:20 <benzrf> *hi
07:55:46 <benzrf> i'm running a supybot instance in another channel; is there something I can use to give it a sandboxed haskell execution command?
07:55:57 <benzrf> would there be any way to plug lambdabot's capability for that into it?
08:00:17 <notdan> benzrf: lambdabot uses mueval for that purpose; I use the restricted-workers library and my own wrapper around GHC API for that
08:01:18 <benzrf> hm
08:01:24 <benzrf> no idea how to do any of that
08:01:26 <benzrf> -._
08:01:31 <benzrf> > 3
08:01:32 <lambdabot>   3
08:01:36 <Eduard_Munteanu> I wonder if mueval uses / could use Safe Haskell at all.
08:03:21 <byorgey> DMcGill: you're right.  that code assumes associating the monoid to the right will be the most efficient.
08:03:48 <byorgey> DMcGill: so yes, it might be better to just use a difference list and then mconcat.  It really depends on the situation.
08:04:37 <notdan> Eduard_Munteanu: it doesn't, but Safe Haskell is not a panacea
08:04:57 <notdan> Eduard_Munteanu: you still can write a program that eats a lot of RAM, for example
08:05:15 <quicksilver> geordi seems a better general approach
08:05:33 <Eduard_Munteanu> Yeah, or runs forever.
08:06:29 <benzrf> basically im looking for a way to safely eval hs from python
08:06:54 <benzrf> i was hoping i wouldn't have to resort to spawning a process and reading from its output... looks like it might be the only way though
08:06:57 <benzrf> :I
08:08:10 <notdan> benzrf: well, that's basically what lambdabot does IIRC. At least it was doing exactly that last time I checked. It spwns the mueval proccess
08:08:19 <kstt> hi. http-conduit help needed please. My code connects to a https server, and it works fine with direct connect. However, when the connection goes through a HTTPS proxy, I get a TLS error : ERROR_EOF.  Please, has anyone succesfully used http-conduit with HTTPS request and proxy ?  thank you
08:08:28 <benzrf> hmm, ok
08:08:30 <benzrf> "|
08:08:50 <notdan> There was also some work on the python<->ghc bridge: https://github.com/creswick/ihaskell-notebook maybe you can use this?
08:10:01 <benzrf> thanks :o
08:15:25 <chrisdone> kstt: try asking on stackoverflow, others might see it
08:16:26 <MrPopinjay> Hello all! Newbie here, discovered functional programming this morning, very exciting stuff ;) Is it possible to run a haskell shell? I just want to mess about and see what happens
08:16:36 <Maior> MrPopinjay: ghci
08:16:36 <benzrf> MrPopinjay: ghci
08:16:37 <benzrf> :P
08:16:41 <MrPopinjay> Thanks!
08:16:44 <benzrf> np
08:16:52 <benzrf> there's also runhaskell
08:17:12 <benzrf> which runs your program without polluting your dir and requiring a second command
08:17:21 <benzrf> as though it were interpreted
08:17:38 <MrPopinjay> I see! Thank you
08:19:01 <MrPopinjay> May I ask what the the difference between '=>' and '->' in type signatures is?
08:19:25 <benzrf> MrPopinjay: they are entirely different
08:19:29 <benzrf> -> is an infix type constructor
08:19:43 <benzrf> whereas => separates type constraints from the actual type
08:19:54 <MrPopinjay> I'm clearly out of my depth. I'll go back to reading rathe than bothering you chaps
08:19:58 <Maior> MrPopinjay: a -> b -> c means "takes an a, takes a b, gives a c"; prefixing that with "Foo a =>" means "a is also an instance of typeclass Foo"
08:20:02 <benzrf> no i'm just using fancy langauge
08:20:02 <benzrf> :P
08:20:08 <Maior> MrPopinjay: learnyouahaskell.com
08:20:10 <benzrf> MrPopinjay: do you know what a type constructor isomorphic ?
08:20:11 <benzrf> *is
08:20:20 <benzrf> bash has trained me to press tab after typing anything
08:20:20 <benzrf> >_
08:20:37 <kstt> thank chrisdone
08:20:49 <MrPopinjay> Maior: I've just started reading that. Thanks for the reassurance that it's good!
08:21:24 <Maior> MrPopinjay: lyah, real world haskell, parallel and concurrent programming in Haskell (if that's your thing) => all excellent reads
08:21:35 <MrPopinjay> benzrf: I try to tab complete everything. I was writting a letter in word the other day and my sentences were littered with tabulations...
08:23:55 <benzrf> MrPopinjay: do you know generics in java?
08:24:57 <benzrf> MrPopinjay: for that matter, do you know java at all
08:26:32 <stelleg> is there a "fork" analog to join, e.g. `join (+) . succ $ 4` == `(+) . fork succ $ 4 4`
08:26:53 <benzrf> @type join
08:26:54 <lambdabot> Monad m => m (m a) -> m a
08:27:08 <mauke> stelleg: 4 4 is a type error
08:27:15 <prophile> @type duplicate
08:27:16 <stelleg> mauke: ah sorry
08:27:16 <lambdabot>     Not in scope: `duplicate'
08:27:16 <lambdabot>     Perhaps you meant one of these:
08:27:16 <lambdabot>       `replicate' (imported from Data.List),
08:27:25 <prophile> ah, curses
08:27:48 <prophile> duplicate from Control.Comonad is the dual of join anyway
08:27:56 <stelleg> mauke: ah sorry that wasnt correctly typed
08:28:08 <stelleg> @info duplicate
08:28:08 <lambdabot> duplicate
08:28:16 <edwardk> :t Control.Comonad.duplicate
08:28:18 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
08:28:29 <edwardk> :t Control.Comonad.extend
08:28:30 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
08:29:52 <MrPopinjay> benzrf: Nope. I'm not a very experienced programmer
08:30:03 <MrPopinjay> How do I exit ghci?
08:30:13 <quchen> ^D usually works well
08:30:14 <alexander__b> MrPopinjay: ^D
08:30:19 <int-e> ... :quit
08:30:20 <MrPopinjay> Thank you
08:30:41 <int-e> @quit
08:30:50 <int-e> ...
08:30:55 <mauke> "well" done
08:30:56 <quchen> :q and :quit are for those times where you want to type more than necessary
08:31:28 <mauke> preflex: seen elliott
08:31:28 <shachaf> elliott: ☝
08:31:29 <preflex>  elliott was last seen on #haskell 9 hours, 6 minutes and 42 seconds ago, saying: you could probably write a version of djinn to generate half the library.
08:31:38 <quchen> Wait, this is #haskell, exiting GHCi is OT ;-)
08:31:57 <benzrf> preflex: about
08:31:59 <mauke> did I say exiting? I meant exciting
08:32:15 <quchen> Well played
08:32:40 <jophish> Yo yo yo
08:32:45 <MrPopinjay> Hi
08:32:52 <benzrf> MrPopinjay: do you know java?
08:33:04 <MrPopinjay> benzrf: Nope. I'm not a very experienced programmer
08:33:07 <benzrf> ok
08:33:16 <benzrf> i was just hoping there was something i could use as a base :p
08:33:18 <alexander__b> MrPopinjay: neither are most Java programmers, sa that's OK ;-)
08:33:19 <benzrf> any other langs you know?
08:33:29 <jophish> O lambdabot lambdabot, wherefore art thou, lambdabot!
08:33:39 <lambdabot> right here
08:33:58 <int-e> I'm sorry. Why did that even work ... may have historical reasons.
08:34:00 <quchen> @pl \a b c → [a,b,c]
08:34:02 <quchen> Let's see how that goes
08:34:08 <MrPopinjay> benzrf: I dabble in bits and bobs. More of an enthusiast than anything else. To my eternal shame the language I know best is VBA... I hate my job sometimes. :P
08:34:16 <benzrf> oh dang
08:34:19 <MrPopinjay> ButYeah
08:34:21 <MrPopinjay> Yeah*
08:34:25 <benzrf> well OK
08:34:36 <benzrf> basically in haskell, a type can be 'parameretized'
08:34:39 <benzrf> wait did i spell that right
08:34:40 <benzrf> whatever
08:34:48 <benzrf> MrPopinjay: this means that, for example
08:34:52 <alexander__b> parameterised
08:34:54 <benzrf> you can have a type called 'Foo'
08:34:58 <benzrf> alexander__b: so british
08:35:03 <alexander__b> or paramaterized if you're murican
08:35:30 <MrPopinjay> Parameterised, clearly.
08:35:32 <benzrf> MrPopinjay: and maybe one kind of value of type Foo has a part that's an Int
08:35:36 * MrPopinjay adjusts his bowler hat
08:36:06 <benzrf> now, let's say you want your Foo value to hold 1 Int and 1 <some type you specify later>
08:36:07 <alexander__b> MrPopinjay: actually, Americans (including cowboys) generally wore bowler hats too, so that's moot :-P
08:36:08 <donri> parametric if you're not on the imperial system
08:36:27 <MrPopinjay> True, but I get a real Mr Ben vibe from them
08:36:47 <benzrf> MrPopinjay: you can do something like this
08:36:49 <MrPopinjay> Rather than the dusty saloon dweller vibe
08:36:57 <benzrf> MrPopinjay: data Foo a = Foo Int a
08:37:03 <benzrf> don't worry too much about the syntax here
08:37:05 <benzrf> the point isomorphic
08:37:06 <benzrf> *IS
08:37:07 <MrPopinjay> OK
08:37:19 <stelleg> :t Data.Function.on
08:37:26 <benzrf> a Foo of type Foo String will hold an Int and a String
08:37:37 <benzrf> of type Foo Int will hold an Int and an Int
08:37:44 <mauke> your overloaded use of 'Foo' displeases me
08:37:45 <benzrf> make a little sense?
08:37:45 <argiopeweb> quchen: Apparently lambdabot's down. My local install says (. ((. return) . (:))) . (.) . (:)
08:37:49 <benzrf> mauke: WHATEVER
08:38:23 <MrPopinjay> You know, I think I'll just continue reading this book :P
08:38:27 <benzrf> alright :0
08:38:35 <benzrf> it's a little hard to explain from scratch :p
08:38:39 <benzrf> i wasnt doing a very good jo
08:38:40 <benzrf> b
08:39:45 <quchen> argiopeweb: I was just making a joke when benzrf renamed himself to "lambdabot".
08:40:14 <argiopeweb> quchen: Heh, I totally missed that happening...
08:41:18 <Maior> qqqqqqqwwssssss
08:41:24 <MrPopinjay> Anyway, thanks for being helpful guys!
08:41:25 <quchen> It's my go-to example of something dead simple and has an awful point-free version
08:41:26 <Maior> er, sorry, network fail
08:41:36 <MrPopinjay> Really nice being in a technical channel that isn't visious and difficult
08:41:43 <argiopeweb> quchen: As I've learned. At least I learned something new today.
08:41:47 <wojtekM_>  I'm trying to convert an ADT (tree) to HTML. So I imported Text.XHtml, and created a function toHtml :: MyTree -> Html. And immediately I got a name clash with toHtml from HTML class. So I thought maybe I should make my type an instance of HTML. But I'm getting an error `toHTML' is not a (visible) method of class `HTML'. Is it a bad idea to make additional instances of HTML, that the library prevents it?
08:42:28 <quchen> You can always import the HTML module qualified.
08:42:54 <benzrf> MrPopinjay: no problem :)
08:42:56 <int-e> mauke: lambdabot ships with  admin + freenode:int-e  and I totally forgot.
08:42:59 <satc> data structure in haskell standard libray to efficiently support following operation: insert element, delete element, find the element at position i in the sorted list of elements. Initially I planned on using Data.Map but I also need to be able to hnadle duplicate elements.
08:43:09 <bscarlet> > (-0.0, abs (-0.0))
08:44:00 <donri> int-e: just say @reconnect
08:44:29 <wojtekM_> quchen: or rename my function, but my question runs deeper
08:45:28 <wojtekM_> It is encouraged to provide Show instances, but not HTML instances.
08:48:39 <quchen> wojtekM_: You can write your own HTML instances. http://lpaste.net/93174
08:49:03 <edwardk> preflex: xseen shapr
08:49:06 <preflex>  shapr was last seen on freenode/#haskell-lens 4 days, 14 hours, 5 minutes and 32 seconds ago, saying: aw, too bad
08:51:08 <edwardk> satc: you can do it with a finger tree pretty easily. you can also just make up a supply of unique id's and use a real map, by changing the key to be (Key, Int) pairs and supplying the size of the map as the second Int.
08:51:15 <Eduard_Munteanu> edwardk: oh... I should ask you. What do you think of GHC 7.6's idea of disallowing type operator variables? Any workaround or plans on supporting that later?
08:51:30 <Eduard_Munteanu> You seem like a user of such a thing. :)
08:51:49 <edwardk> Eduard_Munteanu: i think it is ultimately a good idea. local type operator variables always kinda sucked. you couldn't give them precedence
08:52:12 <Eduard_Munteanu> I want my (~>)s back.
08:52:12 <Eduard_Munteanu> Hm, I see.
08:52:21 <edwardk> it let us have (+) and (*) for type operators, it means things like infix type families are _much_ prettier
08:52:41 <edwardk> and you can make a pair of type aliases to get  a -:c:> b to work
08:52:51 <benzrf> ok so
08:52:52 <Eduard_Munteanu> Hm, good idea.
08:52:53 <benzrf> I installed mueval
08:52:58 <benzrf> but it does nothing at all
08:53:09 <benzrf> i run it and nothing happens ever
08:53:28 <edwardk> you can even get that to associate correctly (a -:c:> b) -> f a -:d:> f b
08:53:43 <edwardk> i'm kinda sad that - isn't a valid type operator for some reason
08:53:51 <edwardk> because then that could be a -c> b
08:53:51 <benzrf> type operator/
08:54:09 <edwardk> benzrf: infix type family or typeclass
08:54:50 <edwardk> type family a + b; type instance Z + b = b; type instance S n + m = S (n + m) -- etc
08:54:54 <rootnode> ah, joined for 1 minute and my head is already hurting. love it :D
08:55:01 <Eduard_Munteanu> edwardk: nice, I'll try it, thanks
08:55:10 <quchen> wojtekM_: Oh my, Text.Html is from 2008 and uses HTML 3.2.
08:55:21 <quchen> I'm not sure which one is worse.
08:55:38 <rootnode> that nobody updated it?
08:56:10 <Sculptor> hi
08:56:12 <benzrf> help, mueval is not working
08:56:14 <benzrf> this saddens me
08:56:25 <edwardk> Eduard_Munteanu: anyways my estimate is the benefit of better type variables exceeds the loss of utility from losing the old un-fixityable local infix names
08:56:25 <wojtekM_> quchen: I'm using Text.XHtml, but it is not much different
08:56:36 <edwardk> er better type family names
08:56:54 <edwardk> Eduard_Munteanu: i went and refactored a bunch of code but i don't miss them much
08:57:02 <wojtekM_> quchen: Silly my, the method name is toHtml, not toHTML. Thanks.
08:57:06 <donri> edwardk: i'd like ~ to be the inverse of what : used to be so we can still have Arrow (~>)
08:57:55 <edwardk> donri: i already use ~> for type aliases for natural transformations in lots of code
08:58:25 <edwardk> so you getting that back breaks all my code a second time =P
08:58:44 <donri> :D
09:03:34 <spaceships> programming languages are easy to learn since it is easy to find a way to apply new knowledge... ive been trying to learn category theory, but haven't found a way to apply it. certainly elucidating haskell's abstractions helps, and that's my primary point of reference.. but must I write a lens library to fully understand it?
09:04:18 <edwardk> spaceships: lens kind of bolts on category theoretic concepts at right angles to how they are used in most mathematics
09:04:56 * hackagebot tidal 0.2.2.8 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.2.8 (AlexMcLean)
09:06:41 <edwardk> the main thing to take away from category theory and curry-howard-lambek is it lets you just transfer terminology and tools from logic to your types, proofs to your terms, kinds of categories correspond to flavors of logic, so knowing what you can do in those categories hints at the kinds of programs that can exist in a language that closely approximates one of them, but it also informs what you can write in EDSLs where you are
09:06:41 <edwardk>  more restricted
09:08:11 <edwardk> programming, logic, category theory all focus on different parts of the problem space at a time, category theory focuses entirely on arrows, logic on the types with proofs (programs) being all but irrelevant, programming seems to focus on the objects themselves
09:08:12 <Eduard_Munteanu> edwardk: hm, type (-:) a to = (->) a    type (:>) to b = to b   seems to do fine... can I do any better?
09:08:36 <Eduard_Munteanu> And I do  class Category c where id :: a -:c:> b    to use it
09:09:18 <edwardk> Eduard_Munteanu: i think you need to fix up the fixity too if you want it to have the right associativity to match -> IIRC
09:09:32 <Eduard_Munteanu> Oh, right, thanks.
09:09:55 <edwardk> i think your -: is wrong there
09:10:13 <edwardk> type a -: c = c a
09:10:30 <YayMe> Yay, last night I finally figured out how to use an applicative functor for validation woo! The wikibook article on applicative functors made it clear
09:10:47 <Eduard_Munteanu> edwardk: oh, I see... that way it makes it more difficult to associate wrongly.
09:10:48 <edwardk> type (:>) c = c
09:11:31 <Eduard_Munteanu> Duh! Mine still uses (->), brain glitch.
09:12:00 <edwardk> YayMe: nice!
09:13:06 <YayMe> Next to come up with a take/drop abstraction using applicative functor to get Header string int string from "bla3arr" with something like Header <$> someTakeDropFunc 3 <*> someTakeDropFunc 1 <*> someTakeDropFunc 3
09:14:27 <YayMe> edwardk: I shoudl be able to do what I just suggested to get back a (string -> Header) that I just pass the input into, yeah? that should be doable, just have to define the someTakeDropFunc right...
09:14:28 <Eduard_Munteanu> Hm, this seems nicer: a |~c~> a
09:15:35 <YayMe> stupid F# at work has me writing string instead of String in haskell...grumble..
09:16:00 <edwardk> Eduard_Munteanu: we golfed a bunch of them around back when the type operator thing first went through and conal and folks realized the implication on their code on the mailing list, but i've forgotten the other options folks put forward
09:16:38 <Eduard_Munteanu> edwardk: I suspect yours is compatibile with pre-7.6 versions given the colons
09:16:49 <Eduard_Munteanu> *compatible
09:16:55 <conal> iavor had some nice tricks, iirc
09:16:58 <edwardk> YayMe: yeah that's pretty much a standard parsing combinator trick you may have to have a combinator
09:17:15 <edwardk> Eduard_Munteanu: i used :-  and :> originally in the post i think
09:17:26 <edwardk> for that reason
09:17:57 <scalable> any idea why i get unknown symbol __imp__pcre_compile when compiling with regex-pcre-builtin on windows?
09:17:57 <edwardk> i switched to -: and :> afterwards
09:18:07 <conal> edwardk: btw, i think we could get infix symbolic type variables back if we tried. simon pj sent me a somewhat encouraging note on the topic recently.
09:18:16 <scalable> it even worked couple of days ago
09:18:41 <edwardk> conal: in theory if you wrote an explicit forall for them, then ghc would have enough info to make it unambiguous
09:18:44 <Eduard_Munteanu> TBH, I'd be happy with an extension throwing out everything and getting us Agda-style rules. :P
09:19:21 * Eduard_Munteanu <3 mixfix
09:19:31 <edwardk> conal: then it'd be no worse than scoped type variables
09:19:37 <edwardk> Eduard_Munteanu: i kinda like sectioning ;)
09:19:41 <YayMe> edwardk: Yeah, I'm parsing some fixed-bit data, and I'm using fparsec at work but just for fun I want to define a simpler combinator because fixed-bit data only needs take/drop and doesn't need 95% of a parser combinator library. Plus it's a great exercise for me to understand applicatives better I *think*, because I believe applicatives are a good approach to it
09:20:05 <conal> edwardk: hm. i hadn't considered that angle.
09:20:06 <Eduard_Munteanu> Hm, fair. Also stuff like (x , y) is uglier too.
09:20:51 <conal> edwardk: will you be at icfp next week? i'll be there.
09:21:12 <quicksilver> edwardk: and arguably that wouldn't be a bad thing (explicitly flagging the use of an infix type variable like that)
09:21:18 <YayMe> Perhaps I'll start by writing some applicative conversion combinators because that's another thing I've been trying to work out, all a part of the raw data->Structured data is the separating, converting, then validating. Got validating, perhaps I should tackle converting before separating because separating seems like the hardest part
09:21:23 <quicksilver> certainly not a very big price to pay.
09:21:33 <edwardk> i put forth the forall option to spj back when the simplification of type variables was first proposed. at the time he didn't think it was worth the complexity, but he also didn't expect the hue and cry over the loss of local type operators
09:21:44 <edwardk> conal: yeah i'll be there the whole thing.
09:22:10 <conal> edwardk: great. me too.
09:22:16 <conal> anyone else here going to icfp?
09:23:03 <edwardk> i'm giving two talks on sunday. one at CUFP and one at the Haskell Implementor's Workshop, then i mostly get to coast through on the hallway track talking to folks as long as my voice holds out
09:24:08 <Eduard_Munteanu> edwardk: since you mentioned that, does mixfix really forbid sectioning? Or is it just more involved to implement?
09:25:18 <edwardk> Eduard_Munteanu: it just doesn't play well, the agda 'section' is to use if_then_else_ x y z  instead. you might be able to contort a rule about how _+_ implies you also get _+ and +_ and +
09:25:33 <Eduard_Munteanu> I'm thinking one could use '_' to section out specific things.
09:25:34 <Eduard_Munteanu> (erm, parameters)
09:26:09 <Eduard_Munteanu> I see.
09:26:53 <quicksilver> that thinking applies to prefix functions too
09:27:07 <quicksilver> (foo a _ c) as a shorthand for (\x -> foo a x c)
09:27:18 <Eduard_Munteanu> edwardk: well, in Agda you can't really change the order of the arguments, so that might be a good reason there
09:27:33 <quicksilver> gets discussed from time to time here and/or on the list
09:27:35 <ski> quicksilver : hm, i thought you meant `f' as a shorthand for `\x -> f x'
09:28:03 * ski . o O ( `f_ : ... -> ...' )
09:28:57 <ski> (the problem with `foo a _ c' is where to introduce the lambda)
09:28:58 <Eduard_Munteanu> ski: that's useful when you want application to bind less tightly
09:29:00 <edwardk> quicksilver: the problem with it is that that form of sectioning is god awful to work with in something like scala. what 'delimits' the _'s is awkward and inconsistent and not always what you want, ()'s start picking up delimiting behavior and i'm really not a fan.
09:29:10 <quicksilver> edwardk: I know :)
09:29:14 <quicksilver> but the point is well made.
09:29:18 <ski> Eduard_Munteanu : Prolog has prefix and postfix operators like that
09:29:31 <quicksilver> personally I feel that lambda notation is a rather good notation for this.
09:30:18 <quicksilver> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/24883
09:30:25 <quicksilver> (conor speaks up in that thread too)
09:31:09 <ski> well, isn't `\' weird in that it "resets the precedence level", without needing to use brackets ?
09:31:16 <edwardk> the lens (??) combinator removes most of the pressure i have for such functionality
09:31:26 <Eduard_Munteanu> Might be easier if you still kept operators and names lexically different.
09:31:32 <edwardk> ski: so is
09:31:34 <edwardk> 'do'
09:31:43 <edwardk> > 3 * do 4 + 5
09:31:55 <ski> yes
09:32:06 * edwardk thumps lambdabot.
09:32:19 <ski> i'd want a theory of operators (including mixfix and distfix) which can account for this
09:32:33 <Eduard_Munteanu> ski: whoa, distfix? I should google that.
09:32:51 <ski> it's more or less the same thing
09:32:58 <augur> ski: whats distfix
09:33:07 <augur> :|
09:33:11 <augur> "more or less"?
09:33:28 <Eduard_Munteanu> First link is a turnoff: "Objective C messages are effectively distfix operator applications"  :P
09:35:20 <ski> augur : iirc, some people don't include ones which have an initial or final symbol (before resp. after the first resp. last argument) in one of the categories
09:35:34 * Eduard_Munteanu remembers he thought of '_' for lambdas at some point too, in some places it'd look really nice.
09:35:50 <augur> o_O
09:36:03 <augur> well we can just use boring old CFGs for all of this, ski, so
09:36:10 <Breadmonster> Haskell is really slow for numerics.
09:36:20 <YayMe> Is it acceptable to feel a sincere love for the Either type?
09:36:22 <ski> Eduard_Munteanu : there was someone in here who implemented it in GHC. i raised some problems with it
09:36:25 <Breadmonster> Especially because linked lists are no comparison to arrrays.
09:36:26 <Eduard_Munteanu> It also makes flipping things nicer.
09:36:30 <Breadmonster> Any suggestions, gentlemen?
09:36:42 <inkjetunito> Breadmonster: compared to what?
09:36:44 <Eduard_Munteanu> runState _ initial $ ...
09:36:48 <mauke> Breadmonster: what do linked lists have to do with numerics?
09:36:52 <quchen> Yes. Don't use linked lists for random access and destructive updates.
09:36:56 <Breadmonster> Compared to say MATLAB?
09:37:02 <Eduard_Munteanu> ski: any major complaints?
09:37:13 <Breadmonster> mauke: They don't, but I was doing numerical PDEs.
09:37:13 <quchen> "C is really slow at numerics when I use linked lists for matrices"
09:37:26 <edwardk> Breadmonster: my recommendation is not to use lists in your numerics code
09:37:28 <mauke> s/matrices/numbers/
09:37:30 <applikativ> Breadmonster: what are you doing? what are the lists holding, etc?
09:37:30 <Breadmonster> quchen: Well, what's the alternative in Haskell?
09:37:46 <mauke> Breadmonster: I recommend numeric types for numbers, such as Float and Int
09:37:49 <Breadmonster> applikativ: I was using FDM.
09:37:49 <Eduard_Munteanu> Breadmonster: look at array, vector or repa
09:37:55 <edwardk> Breadmonster: vector, repa, arrays...
09:37:59 <Eduard_Munteanu> @hackage hmatrix
09:38:02 <Breadmonster> Haskell has vectors?
09:38:02 * applikativ recommends Data.Vector.Unboxed as usual
09:38:03 <quchen> Also the Accelerate library.
09:38:13 <ski> btw, it makes me sad that Agda thinks `a + b * c' is ambiguous in the presence of `_+_*_',`_+_',`_*_', the latter two with sensible precedences declared
09:38:27 <Eduard_Munteanu> Breadmonster: also look at http://hackage.haskell.org/package/hmatrix-0.15.0.1
09:38:32 <applikativ> Breadmonster: [Int] is a sign of very bad Haskell, though it is sometimes legitimate
09:38:42 <Breadmonster> applikativ: Why?
09:39:03 <ski> Eduard_Munteanu : the main problem is at which point to introduce the lambdas. another issue is whether (and when) to lift out computations of parts not containing `_'
09:39:16 <edwardk> Breadmonster: accessing the nth element of a list is O(n). accesssing the nth element of an array or vector is O(1)
09:39:32 <applikativ> Breadmonster: for the reasons you already pointed out, except you thought that putting them in lists is The Haskell Way
09:40:51 <ski> Eduard_Munteanu : e.g., this person wanted to be able to write something like `f (g x _ y) (h x)' to mean `\z -> f (g x z y) (h x)' -- but in some cases one'd want `f (\z -> g x z y) (h x)' instead
09:40:54 <Eduard_Munteanu> ski: hm I think I see your point. There is a least arbitrary choice, namely introducing them before the function, no?
09:42:28 <ski> Eduard_Munteanu : also, is `F E0 E1' really meant to be just `(F E0) E1', in that case, if we assume "lambdas inserted innermost", then `f _ y' would possibly be `(\x -> f x) y' instead of `\x -> f x y' -- stated in another fashion : it'd be a pain to distinguish between `F E0 E1' and `(F E0) E1'
09:42:54 <monochrom> guess what? even ACM ICPC contestants using C tend to use an array to store a set of numbers, and linear search to look up a number in that set.
09:43:18 <ski> @wn ICPC
09:43:36 <monochrom> people really have the tendency to cling on to the first data structure they learn in life
09:44:24 <ski> Eduard_Munteanu : there possibly was more, but i don't recall them offhand
09:44:31 <capisce> fibonacci heaps!
09:44:45 <Eduard_Munteanu> ski: shouldn't those two be the same? It could introduce the lambda right after the final application, and at that point it should know it's \x -> F ...
09:44:56 <ski> (.. at least in Scheme, there's a primitive concept of "multi-arity procedure combination")
09:45:39 <threeday1onk> monochrom: I recall some research years ago that gave C programmers and Perl programmers similar tasks to achieve. The Perl programs were faster, because they used hash tables everywhere, wile the C programmers used linear scans because it was the path of least resistance.
09:45:42 <FreeFull> cata is fine if you have access to the type constructors, but is there a way to fold without having access to them?
09:45:51 <ski> Eduard_Munteanu : well, one potential answer to "where to insert" is "at nearest brackets" (sensibly extended to other cases)
09:46:12 <FreeFull> Other than making a specialised fold function for each type
09:46:20 <ski> Eduard_Munteanu : but i assume you were instead walking upwards on applications ?
09:46:24 <edwardk>  FreeFull: you generally need something provided by whoeever wrote it, be it Data, or a custom fold, or GHC.Generics, etc.
09:46:39 <Eduard_Munteanu> ski: yes
09:46:47 <ski> (specifically, walking upwards from the operand subexpression)
09:47:01 <FreeFull> I guess something like that isn't possible without dependent types
09:47:13 <edwardk> FreeFull: you don't need anything so heavy
09:47:24 <edwardk> even a type family would do
09:47:45 <Eduard_Munteanu> ski: so (F _) Y would be \x -> (F x) Y since F is applied even after the first arg has been filled.
09:48:00 <applikativ> Breadmonster: if you have the Haskell Platform, you have the vector library; do import qualified Data.Vector.Unboxed as V; import qualified Data.Vector.Unboxed.Mutable as M; then just use the combinators like V.map and so on
09:48:19 <ski> hm, actually, the first step is from an operand, but the next steps must be from the operator position
09:48:23 <edwardk> Eduard_Munteanu: that sounds like a mess
09:48:46 <FreeFull> I haven't looked at type families
09:48:47 <ski> (or perhaps s/from an/possibly from an/)
09:48:49 <Eduard_Munteanu> edwardk: possibly, I only thought it was a little less arbitrary
09:49:23 <luite> hmm, are IntMap / IntSet the fastest pure containers for Ints or Int -> a? or is something from unordered-containers or similar faster now?
09:49:36 <ski> Eduard_Munteanu : ok. so this means that `F x' and `F $ x' are now different
09:49:42 <applikativ> Breadmonster: to mutate the vectors do breadmonster vec = runST $ do {mvec <- thaw vec; ... mutute ...mutate ....mutate ...; freeze mvec}
09:49:50 <edwardk> Eduard_Munteanu: my main point is that this whole space is littered with incidental complexity for little real gain. i write haskell because it largely gets me away from languages that consistently make bad decisions that introduce arbitrary complexity
09:49:53 <applikativ> Breadmonster: or the like
09:50:31 <Eduard_Munteanu> ski: F _ would be \x -> F x, while F $ _ would be \x -> ($) F x, no?
09:50:54 <ski> Eduard_Munteanu : `x' was an object variable, `F' a meta variable
09:51:12 <applikativ> it's strange that lambdabot doesn't have some elementary parsec and vector in scope or available
09:51:31 <ski> (so you should consider e.g. `f _ x' vs. `f _ $ x')
09:51:32 <edwardk> Vector doesn't pass safeHaskell
09:51:38 <applikativ> ah of course
09:51:41 <Eduard_Munteanu> edwardk: yeah, you're right. For a long time (and even currently), I sort of looked at GADTs, type families etc. as rather arbitrary, considering I've used those in Agda first.
09:51:41 <edwardk> it is easy to crash by using it incorrectly
09:51:48 * applikativ proposes a super unsafe bot!
09:52:23 <applikativ> you invoke it with danger> V.fromList "alphabet"
09:52:48 <Eduard_Munteanu> ski: not sure what you mean by metavariable in Haskell (at least in terms)
09:53:04 * ski gets the "Menace" tune running in head
09:53:27 <luite> applikativ: can be done with notdan's restricted-workers package, if someone supplies a machine or vm with selinux to run the bot in
09:53:28 <ski> Eduard_Munteanu : `F' stood for an arbitrary expression, in this case probably one involving `_'
09:53:35 <monochrom> what will you do with this super unsafe bot?
09:53:36 <Eduard_Munteanu> Ah.
09:53:58 <applikativ> monochrom: explain how to use vector?
09:54:19 <monochrom> but you may accidentally crash it, and it's easy to crash
09:54:55 <applikativ> of course, but there's ways of recovering from a crash.  I don't think freenode need collapse
09:55:12 <int-e> @bot
09:55:12 <lambdacat> :)
09:55:15 <monochrom> ok, then it is not super unsafe, it is just... ephemerally unsafe
09:55:26 <notdan> I actually had a very "unsafe" bot. It restarts itself upon crash/out of memory/infinite loop/etc
09:55:34 <notdan> need to upgrade it to the latest pipes though
09:55:36 <applikativ> oh there's notdan
09:55:43 <notdan> hi :)
09:55:43 <luite> our hero!
09:55:47 <applikativ> oooh it uses pipes awesome
09:55:58 * notdan blushes
09:56:55 <monochrom> programming a bot with pipes, spanners, daggers, and ... where is my Cluedo set so I can look up its weapons?
09:57:04 <int-e> @pl \a b c -> [a,b,c]
09:57:04 <lambdacat> (. ((. return) . (:))) . (.) . (:)
09:57:14 <Eduard_Munteanu> ski: oh, I see what you meant in the f _ $ x case
09:57:18 <monochrom> anyway, "by Miss Scarlet and Col. Mustard"
09:58:40 <monochrom> oh! ropes. that does it.
09:59:01 <applikativ> yes, but do we have spanners?
09:59:09 <ski> Eduard_Munteanu : imo, any suggestion which breaks such basic code equivalences should be weighted carefully, considering whether it's really worth the trouble
09:59:11 <Eduard_Munteanu> ski: re the braces rule, I guess you could limit '_' to applications involving *names* in scope.
09:59:30 <Eduard_Munteanu> Yeah, I guess so. It's still fun to think about it.
09:59:39 <ski> (braces ?)
10:00:14 <Eduard_Munteanu> ski: you said another option is placing the lambda depending on how the expression was parenthesized
10:00:54 <applikativ> the dagger character cant be an operator I guess : generalCategory '†' = OtherPunctuation
10:01:18 <Eduard_Munteanu> Anyway I'm saying you can throw away cases like   (expr) _  and only allow 'name _'
10:02:17 * Eduard_Munteanu should stop boring people with this
10:02:36 <ski> Eduard_Munteanu : yeah, if only to try to dissuade its abetters :)
10:02:55 <ski> (re the fun)
10:06:15 <Eduard_Munteanu> Anyone could recommend a nice way to name a type function composition operator?
10:06:26 * Eduard_Munteanu has been using `O`
10:08:01 <applikativ> hm ideone.com has a shiny new ghc, but no haskell platform ;(
10:08:06 <applikativ> :( rather
10:11:35 <notdan> applikativ: you can try http://paste.hskll.org :) it somewhat unlike ideone.com in the sense that it does not capture the STDOUT, but it captures the result of 'main'
10:12:52 <Taneb> Eduard_Munteanu, I've seen :.: used
10:23:19 <Eduard_Munteanu> Would existential typeclasses make sense? I'm thinking of: class forall a. (Something a) => MyClass b where
10:23:35 <Eduard_Munteanu> Note 'a' isn't mentioned in the RHS of =>.
10:26:21 <Eduard_Munteanu> I wanted to do something like  class forall x. (g (f x) ~ h x) => O (g :: b -> c) (f :: a -> b) (h :: a -> c) where
10:27:23 <applikativ> well i wrote to the ideone people requesting the haskell platform. presumably my email is being treated as an ill-formed cobol program just now...
10:27:36 <Eduard_Munteanu> (g `O` f) h  means let h = g . f (where all of those are type functions)
10:29:08 <Eduard_Munteanu> I could do  class (g (f x) ~ h x) => O (g :: b -> c) (f :: a -> b) (h :: a -> c) (x :: a) where   but that feels a bit too pointwise
10:29:35 <Eduard_Munteanu> (a, b and c are polykinds, could be * instead)
10:30:18 <Eduard_Munteanu> And I also feel it's an analogue to GADT's existentials.
10:31:51 <Eduard_Munteanu> Namely, a closed world equivalent would be   data O g f h where MkO :: forall x. (g (f x) ~ h x) => O g f h
10:34:28 <tomejaguar> Does "data EmptyFunctor a = EmptyFunctor" exist somewhere?
10:34:59 * hackagebot monad-par 0.3.4.5 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.5 (RyanNewton)
10:35:16 <Eduard_Munteanu> tomejaguar: that's sometimes called the Trivial monad, I think
10:37:28 <supki> tomejaguar: Proxy from tagged
10:40:56 <tomejaguar> supki: That is a cool package!
10:45:33 <FreeFull> tomejaguar: Const Identity
10:45:42 <FreeFull> Wait, no
10:46:03 <tomejaguar> Const () is close
10:46:22 <FreeFull> Yeah
10:46:44 <edwardk> tomejaguar: Proxy
10:48:41 <tomejaguar> Hmm I want it to be an instance of Pointed
10:48:48 <tomejaguar> But I'll just roll my own for now
10:51:06 <edwardk> tomejaguar: there is probably an instance of pointed for it in the pointed package, if not, then submit a patch to pointed and i'd take it
10:51:25 <edwardk> i won't increase tagged's deps, but i'm happy to increase pointed's
10:52:04 <edwardk> actually i'll do it now
10:52:06 <tomejaguar> tagged is a cool idea
10:52:10 <tomejaguar> I invented it once too.
10:52:30 <tomejaguar> I got sick of writing "undefined :: Foo"
10:53:04 <elliott> Pointed :(
10:54:30 <tomejaguar> Pointed :)
10:54:36 <FreeFull> Are you sure Proxy isn't an Applicative?
10:54:38 <tomejaguar> Especially in combination with Functor
10:54:46 <tomejaguar> FreeFull: It is an Applicative
10:54:57 <tomejaguar> but Edward said he wouldn't increase the dependencies
10:55:08 <FreeFull> Ah, it probably is a Monad too
10:55:19 <tomejaguar> Yes it's a Monad too
10:56:16 <edwardk> tomejaguar: pointed 3.1 shipped. has tagged/proxy instances.
10:56:25 <danilo2> Hi! Is there any theoretical background, why such expression is not correct in Haskell?: "let ((a,b) :: (Int, a)) =  (5,5)"? Following function signature is correct: "g ((a,b) :: (Int, a)) =  (5,5)" (using -XScopedTypeVariables)
10:56:27 <edwardk> tomejaguar: i'm happy to put deps on pointed, and on my other packages to better support tagged, just not tagged itself
10:56:38 <edwardk> it is one of those 'keep this as close to the base of the stack as possible' packages
10:56:58 <edwardk> because otherwise it requires a ton of refactoring of the hierarchy to do that update
10:57:55 <tomejaguar> edwardk: Cool thanks!
10:58:23 <edwardk> danilo2: there is a subtle distinction between those two things that isnt obvious
10:58:30 <FreeFull> danilo2: 5 isn't an a
10:58:32 <edwardk> 'a' there is an instance of Num
10:58:58 <edwardk> but the first signature dosn't capture that and the second one is just giving a local name to the type it has, and isn't saying it doesn't have such an instance.
10:59:40 <edwardk> if you turn on ImpredicativeTypes and RankNTypes you can write
10:59:46 <edwardk> let ((a,b) ::  (Int, forall a. Num a => a)) =  (5,5)
10:59:59 * hackagebot pointed 3.1 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-3.1 (EdwardKmett)
11:00:00 <edwardk> but that has a different meaning than the local binding in g.
11:00:41 <n-dolio> @type let a :: Int ; b :: forall a. Num a => a ; (a, b) = (5, 5) in b
11:00:42 <lambdabot>     Couldn't match expected type `a'
11:00:43 <lambdabot>                 with actual type `forall a1. Num a1 => a1'
11:00:43 <lambdabot>     When checking that `b'
11:00:57 <n-dolio> Lame.
11:01:03 <edwardk> on is an existential clai there there is some a and we'll call that part of the typ 'a' the other is a universal claim that any such choice of 'a' will do when you go to use the 'a' that is now in top level scope
11:01:18 <edwardk> hah
11:01:25 <tomejaguar> On the Haddock page for Applicative (http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html) it says "As a consequence of these laws, the Functor instance for f will satisfy fmap f x = pure f <*> x".  But how can this be a consequence of the Applicative laws?  The Applicative laws don't mention fmap.  Shouldn't it say "The Applicative instance must satisfy ..."
11:01:42 <danilo2> edwardk: Hmm, ok thank you for the clarification, I see the point now. The syntax is still not "concise for me", bu it is understable why I get such result. Thank you
11:03:30 <ReinH> hai guis
11:08:55 <lispy> tomejaguar: the Applicative class assumes a Functor instance. The docs are state that the Functor instance and the Applicative instance have to agree in a very precise way.
11:09:03 <lispy> stating*
11:09:11 <joneshf-work> edwardk, that folds post has so much info in it
11:09:17 <joneshf-work> edwardk, thanks
11:09:28 <edwardk> joneshf-work: =)
11:09:35 <lispy> tomejaguar: the way that Applicative mentions Functor is by class Functor f => Applicative f where ...
11:10:08 <lispy> tomejaguar: does that help?
11:10:21 <edwardk> joneshf-work: i'm trying to provide sort of snapshots that cover what i'm thinking about individual topics that offer threads that lead back to the research for folks who want to chase after it
11:10:35 <tomejaguar> lispy: The docs state that the Functor instance *will* satisfy the condition
11:10:50 <tomejaguar> That suggests to me that they are claiming that follows automatically
11:10:51 <joneshf-work> edwardk, the only thing i dont like about it, is that it seems like each pdf is longer than the pdf previous to it
11:11:00 <tomejaguar> The law does not follow automatically.
11:11:17 <ReinH> edwardk: my virtual stack of papers to read is growing without bound :(
11:11:19 <edwardk> joneshf-work: basically i'm allowing myself a day or two to think about something and then writing up whatever i've got at the end
11:11:20 <ReinH> I need to read faster
11:11:39 <joneshf-work> ReinH, right?
11:12:11 <ReinH> I need to get organized
11:12:19 <edwardk> joneshf-work: heh. the conquering folds stuff is particularly brutal because you have to go chase down a whole host of origami programming papers to make out the motivations
11:12:42 <joneshf-work> edwardk, where do you find the time?  Are you working, or school or independently wealthy?
11:13:06 <edwardk> joneshf-work: but i'm hopeful that i can eventually get that conquering folds post to where i'd have a library that offers a comonad for dealing with upwards and downwards accumulations on trees that gets to have the O(log n) parallel or O(log h) parallel time on O(n / log n)  or O (n / log h) time
11:14:19 <edwardk> i work. sadly my efforts at becoming independently wealthy hit a speedbump that cost me the fortune i built the first time around, leaving me a bit startup-shy.
11:14:40 <tomejaguar> Ouch
11:14:54 <joelteon> okay, cabal still won't resolve my dependencies with 1G of stack space
11:15:04 <edwardk> i did get the benefit of getting to go binge through academia in a very compressed time table later on in life than most people do, so by the time i got there i had actual uses for all the information i was getting and didn't have any partying distractions ;)
11:15:51 <dcoutts> joelteon: stack overflow?
11:15:56 <joelteon> yeah
11:15:58 <dcoutts> joelteon: can you report it please
11:16:03 <joelteon> better profile it
11:16:13 <dcoutts> with enough detail so someone can reproduce it
11:16:24 <joneshf-work> edwardk, ah, makes sense then.  Also, seems like we're at a similar stage in life, that's refreshing to see
11:16:27 <dcoutts> it shouldn't be using linear stack
11:17:48 <tomejaguar> Ah I was wrong about that Applicative thing.  It must be to do with parametricity.
11:17:49 <n-dolio> @type \f -> (pure f <*>)
11:17:49 <lambdabot> Applicative f => (a -> b) -> f a -> f b
11:18:39 <edwardk> I did have the benefit that basically all through my 20s i got a good mix of very pragmatic systems programming to keep the lights on at my ISP/phone company and on fun game dev/graphics/demo scene stuff, which kept me from getting stuck in a rut writing perl.
11:18:41 <n-dolio> pure id <*> v = v gives you the identity law, which is sufficient to make that fmap given parametricity.
11:19:25 <n-dolio> @free foo :: (a -> b) -> f a -> f b
11:19:26 <lambdabot> Extra stuff at end of line
11:19:27 <joelteon> dcoutts: what flags should i use with -h?
11:19:30 <joelteon> to profile
11:19:57 <dcoutts> joelteon: -xc can help, gives a trace when you get the exception
11:20:19 <dcoutts> joelteon: I don't think you want -h, that's for heap profiling
11:20:22 <tomejaguar> n-dolio: Yes I see.  Parametricity always confuses me.
11:21:16 <n-dolio> @free foo :: (a -> b) -> F a -> F b
11:21:16 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
11:21:57 <joelteon> ok
11:22:38 <n-dolio> g . id = g . id => map_F g . (pure id <*>) = (pure g <*>) . map_F id
11:22:41 <shachaf> n-dolio: What if you have foo :: (a -> b) -> F a -> F b such that foo id = id, but F isn't a functor? Is that situation possible?
11:22:50 <shachaf> That free theorem assumes that F is a functor.
11:22:57 <n-dolio> The free theorem would be different.
11:24:32 <n-dolio> The safest thing to do would be use the relational statement of parametricity and see what all you can derive.
11:25:48 <n-dolio> Presumably if F were a contravariant functor, you could easily get something involving contramap.
11:26:34 <n-dolio> @free foo :: (b -> a) -> F a -> F b
11:26:36 <lambdabot> g . h = k . f => $map_F f . foo h = foo k . $map_F g
11:27:21 <n-dolio> And if it were something less nice, you'd get less interesting specializations.
11:27:31 <n-dolio> @free T
11:27:31 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
11:27:36 <n-dolio> @free t : T
11:27:36 <lambdabot> Extra stuff at end of line
11:27:39 <n-dolio> @free t :: T
11:27:39 <lambdabot> t = t
11:27:48 <n-dolio> That's the least interesting thing you can get.
11:27:59 <joelteon> @free t :: F b
11:27:59 <lambdabot> $map_F f t = t
11:28:46 <joelteon> can someone direct me to an explanation of what @free does
11:29:39 <n-dolio> Theorems for Free! by Philip Wadler.
11:30:42 <shachaf> tomejaguar: Did you see my example in the bug text? Alternative defines some,many which have valid mutually recursive default definitions.
11:30:50 <elliott> n-dolio: yeah, what shachaf says is why I don't think I've ever seen a proof that fmap id = id implies fmap (f . g) = fmap f . fmap g and hence a valid Functor
11:31:02 <elliott> since the reasoning steps I've seen always pull a "real" fmap out of nowhere
11:31:19 <shachaf> Yes.
11:34:01 <monochrom> wait, are you talking about: "if F is a functor, and F id = id, then F is a functor"? :)
11:34:42 <elliott> monochrom: "if F is an endofunctor on Hask, and f :: forall a b. (a -> b) -> F a -> F b; f id = id, then f (g . h) = f g . f h"
11:35:07 <elliott> people use this to claim you only need to prove fmap id = id for a proposed Functor instance and you're done, but that doesn't follow from that argument, AFAICT
11:35:22 <shachaf> Yep.
11:36:05 <joelteon> ok dcoutts i've opened the issue
11:36:10 <dcoutts> thanks
11:37:03 <jfischoff> shachaf: you got your feature request!
11:37:46 <shachaf> jfischoff: Yep.
11:38:37 <monochrom> ok I see, thanks
11:40:07 <Dodek> elliott: is there any example that it doesn't have to hold, though?
11:42:05 <elliott> I believe the stronger statement is true. I have seen no proof of it.
11:43:57 <tomejaguar> What does "F is an endofunctor on Hask" mean?
11:44:06 <tomejaguar> F is a Functor instance?
11:44:29 <Cale> tomejaguar: pretty much
11:44:32 <shachaf> Or could be one.
11:44:57 <mr-> does "F is a Functor instance" mean that it obeys the law?
11:45:07 <Cale> Also, there might be some endofunctors on Hask which aren't implementable in Haskell.
11:45:18 <Cale> (as instances of Functor)
11:45:19 <shachaf> mr-: It had better.
11:45:29 <tomejaguar> Then surely it doesn't matter if fmap is pulled out of thin air.
11:45:44 <Cale> tomejaguar: there are laws which fmap is required to satisfy
11:46:00 <tomejaguar> elliott said "the reasoning steps I've seen always pull a "real" fmap out of nowhere"
11:46:14 <tomejaguar> but if F is required to have a valid Functor instance, than that doesn't matter
11:46:23 <shachaf> tomejaguar: Yes, that's his point.
11:46:26 <shachaf> 11:34 <elliott> people use this to claim you only need to prove fmap id = id for a proposed Functor instance and you're done, but that doesn't follow from that argument,   │·············· AFAICT                                                                                                                                                      │··············
11:46:28 <elliott> this has nothing to do with typeclasses.
11:46:32 <shachaf> Er, oops.
11:46:41 <elliott> it's probably best to pretend they don't exist to understand the objection here
11:46:48 <tomejaguar> Sure, well it doesn't matter.
11:47:40 <tomejaguar> By "if F is an endofunctor on Hask" I think you mean "F is of kind * -> *, and there exists a map foo :: (a -> b) -> f a -> f b, satisfying foo (f . g) = foo f . foo g, for all f, g of the correct types"
11:47:52 <shachaf> tomejaguar: And also foo id = id
11:47:54 <Cale> I'm pretty sure you can strengthen it a bit, and let F just be an arbitrary type constructor
11:48:05 <tomejaguar> In which case it doesn't matter if a proof pulls a "real" fmap out of nowhere, because it's just foo.
11:48:06 <shachaf> The point is that people say: "for any type F, if f :: (a -> b) -> F a -> F b, and foo id = id, then foo (f . g) = foo f . foo g"
11:48:15 <Cale> tomejaguar: why?
11:48:20 <shachaf> And in their justification they use $map_F, which might not exist for an arbitrary type constructor.
11:48:22 <n-dolio> Who says that?
11:48:27 <Cale> tomejaguar: How do you get f = foo?
11:48:38 <shachaf> People have said it.
11:48:50 <tomejaguar> shachaf: Do they?  Doesn't the trivial counterexample "foo = const id" dissuade them?
11:49:02 <tomejaguar> Err
11:49:05 <tomejaguar> I take that back!
11:49:08 <mr-> :-)
11:49:20 <shachaf> I even think it's probably true.
11:49:27 <n-dolio> The argument is that if F is a functor, then any type correct foo you write such that foo id = id is equal to map_F.
11:49:40 <n-dolio> Possibly ignoring strictness and bottoms.
11:49:50 <shachaf> Yes, that's the argument that has that @free proof.
11:50:05 <shachaf> But people also say that it's true for any type constructor.
11:50:23 <n-dolio> I haven't seen anyone say that.
11:50:36 <Cale> I think it's probably true for any type constructor
11:50:44 <shachaf> People say "you only need to check the identity law when implementing fmap, because the other one is a free theorem"
11:50:50 <shachaf> Which is the same thing.
11:51:17 <shachaf> Cale: I think so too.
11:51:18 <n-dolio> Cale: What does that even mean? map_F isn't well-defined for non-functors.
11:51:44 <shachaf> Er, I think that it means that foo (f . g) = foo f . foo g
11:51:47 <Cale> n-dolio: Replace the claim that it's equal to map_F with a claim that you get a valid functor
11:52:10 <elliott> my intuition about parametricity firmly believes in the stronger statement
11:52:13 <elliott> I just know of no proof.
11:52:17 <elliott> I suspect one exists.
11:52:33 <joelteon> how do you show how long it takes to evaluate an expression in cabal?
11:52:36 <joelteon> uhhh, ghci
11:52:46 <S11001001> fmap id = id, id . id = id, fmap id . fmap id = id
11:52:46 <Cale> It turns out to be really hard to prove things involving parametricity in Coq for some reason.
11:52:53 <monochrom> must you use ghci?
11:52:58 <dcoutts> joelteon: :set +s
11:53:03 <joelteon> it's easier than setting up a benchmark at the moment, monochrom
11:53:23 <shachaf> elliott: Well, you can probably use the fact that all Haskell 98 types are built out of sums/products/functions or something.
11:53:26 <monochrom> ok, but beware that the data collected will have nothing to do with compiled code
11:54:03 <monochrom> to a large extent you are saying "not ready to benchmark on ghc, so I benchmark on hugs first"
11:54:13 <joelteon> but i should be able to identify whether a function takes quadratic time, shouldn't I?
11:54:28 <shachaf> Not ready to benchmark in GHC, so I get a stopwatch and execute by hand first.
11:54:30 <monochrom> well, that one yes
11:54:45 <joelteon> yeah, and it clearly does
11:54:46 <shachaf> Some GHC optimizations change asymptotic complexity.
11:54:47 <joelteon> damn it
11:54:53 <joelteon> ok, time to run a benchmark then
11:55:52 <monochrom> that happens more rarely. so I didn't mention it. mentioning hugs already ruins enough of your day :)
11:56:24 <NickeNyfiken42> I have a parallelization question, what way of parallelization is suitable for a search algorithm when I want several cores to race and have the first found value returned?
11:56:50 <NickeNyfiken42> I want to paralleilize a function that return an n-bit prime number
11:57:35 <n-dolio> shachaf: One issue is, I don't remember what the relational version of parametricity is for things involving some concrete F.
11:58:12 <n-dolio> And I have enough of an issue just writing it down in general.
11:58:45 <ParahSai1in> does anyone think Text.Printf is kinda bad?
11:58:53 <ReinH> NickeNyfiken42: perhaps waitAnyCancel?
11:59:09 <ReinH> @hackage async
11:59:09 <lambdabot> http://hackage.haskell.org/package/async
11:59:37 <elliott> shachaf: let's say F is an invariant functor. then all we have to do is prove that having f :: (a -> b) -> F a -> F b and f id = id implies F is a Functor, and we can use invmap.
11:59:45 <elliott> since every "normal" F is an invariant functor in Haskell.
11:59:47 <tomejaguar> ParahSai1in: Yes it's very bad.
12:00:39 <NickeNyfiken42> ReinH: Sounds promising, I will read up on it
12:00:56 <shachaf> elliott: Not with RankNTypes etc., of course.
12:01:06 <ParahSai1in> tomejaguar: yet i find myself using it to save on the "'s and ++'s i have to type otherwise
12:01:44 <MitchellSalad> are there any online courses or youtube video series that specifically teach or use haskell?
12:02:33 <Clint> yes
12:02:34 <tomejaguar> ParahSai1in: I don't know why nobody wrote a typesafe version.
12:02:40 <NickeNyfiken42> But is Async parallel or just concurrent?
12:02:48 <shachaf> tomejaguar: Many people did.
12:02:49 <bennofs> tomejaguar: I think there exists type-safe printf in haskell
12:03:02 <ReinH> NickeNyfiken42: concurrent, you can't do this without concurrency
12:03:05 <bennofs> tomejaguar: There are also template-haskell versions, that check the string at compile time
12:03:11 <ReinH> NickeNyfiken42: as you need to communicate with other threads
12:03:12 <koala_man> is there a mathematical term for functions  a -> [a] ?
12:03:30 <shachaf> What makes a term mathematical?
12:03:39 <shachaf> (And how is a quantified?)
12:03:49 <NickeNyfiken42> I mean, do the threads execute on several cores, or interleaved?
12:03:58 <NickeNyfiken42> I want true parallelism
12:04:01 <tomejaguar> shachaf: Any links?
12:04:04 <ReinH> NickeNyfiken42: that's not what "concurrent" means
12:04:10 <bennofs> Aren't there only two possible functions of that type? (const [] and return?)
12:04:13 <ParahSai1in> ah it uses TH
12:04:17 <MitchellSalad_> oops, my kernel just panicked. are there any online classes that use haskell?
12:04:24 <NickeNyfiken42> I know
12:04:32 <ReinH> MitchellSalad_: http://youtube.com/jekor http://youtube.com/haskelllivetv
12:04:32 <shachaf> tomejaguar: http://hackage.haskell.org/packages/archive/printf-mauke/0.5.2/doc/html/Text-Printf-Mauke-TH.html
12:04:46 <shachaf> tomejaguar: http://okmij.org/ftp/typed-formatting/index.html#C-like
12:04:52 <ReinH> NickeNyfiken42: concurrency in haskell uses multiple cores
12:05:08 <shachaf> Those are both TH, I guess.
12:05:14 <bennofs> tomejaguar: haven't used it myself, but this is without TH: http://hackage.haskell.org/package/holey-format-1.2.0/docs/Text-Format.html
12:05:17 <shachaf> It depends on how far away you're willing to get from printf.
12:05:37 <shachaf> bennofs: Weird, I'm listed as an author of that.
12:05:57 <NickeNyfiken42> Ok, so then Async is indeed parallel as well
12:06:10 <ReinH> NickeNyfiken42: yes
12:06:11 <tomejaguar> Yes I like the holeymonoid approach
12:06:22 <ReinH> by that definition of parallel, yes
12:06:28 <ReinH> but that is not how the terms are usually used
12:06:57 <NickeNyfiken42> for me parallel = execution on several cores/processors at the same time
12:07:00 <elliott> bennofs: that's a 404.
12:07:20 <shachaf> Yes, bennofs probably meant http://hackage.haskell.org/packages/archive/holey-format/1.2.0/doc/html/Text-Format.html
12:07:33 <elliott> ugh, it's bad.
12:07:36 <elliott> takes rank-2 stuff contravariantly.
12:07:43 <elliott> :(
12:07:57 <ReinH> NickeNyfiken42: ah, I know that definition. Yes, Haskell concurrency is true parallelism (assuming your program is compiled and run with multi-core support)
12:08:47 <NickeNyfiken42> That's what I want to hear :) Then waitAny is my friend to find a prime faster
12:08:58 <tomejaguar> elliott: Why's that bad?
12:09:01 <NickeNyfiken42> Thx ReinH
12:09:29 <ReinH> NickeNyfiken42: right, but you probably want waitAnyCancel to abort other async tasks after the first result
12:09:31 <elliott> tomejaguar: it's unnecessarily restrictive and bad for inference.
12:09:43 <elliott> you should return polymorphic stuff and accept monomorphic stuff, lens-style.
12:10:13 <ReinH> NickeNyfiken42: waitAnyCancel is literally just waitAny `finally` mapM_ cancel asyncs, which does what it sounds like.
12:10:20 <NickeNyfiken42> Aha ok
12:10:20 <tomejaguar> elliott: do you mean by adding another type variable to the type?
12:10:48 <elliott> tomejaguar: yes, or making another type for the accepting position
12:10:52 <NickeNyfiken42> I assumed it was waitAny with a timeout
12:10:53 <elliott> like lens's Getting, ALens, that kind of thing
12:13:03 <ReinH> NickeNyfiken42: nope :) also btw this book is free http://chimera.labs.oreilly.com/books/1230000000929
12:13:42 <ReinH> (and is by async author and GHC developer Simon Marlow)
12:14:08 <NickeNyfiken42> ReinH: Cool, but it was greated being directed to the right parallelization technique directly, there are so many approached in haskell
12:14:19 <ReinH> NickeNyfiken42: sure :)
12:15:23 <NickeNyfiken42> ReinH: I will read the relevant parts of the book though, Table of Contents looks great
12:15:37 <ReinH> NickeNyfiken42: it's a great introduction to the current state of the art
12:15:56 <ReinH> Although imo we should be doing more, smarter forms of parallelism
12:16:59 <ReinH> for instance a significant part of Cilk++/Intel TBB could be implemented as a task sharing monad (https://github.com/ekmett/tasks)
12:17:13 <NickeNyfiken42> I think the basic idea of a multitude of approaches is the right way to go, though
12:17:21 <ReinH> NickeNyfiken42: absolutely
12:17:41 <ReinH> as long as you have a good choice heuristic ;)
12:17:51 <NickeNyfiken42> hehe
12:39:20 <Eduard_Munteanu> Hrmpf... are there kind synonyms or kind equality constraints?
12:40:44 <joelteon> yep, so my parser has quadratic time complexity :<
12:42:03 <chrisdone> every day is leg day
12:42:12 <monoidal> Eduard_Munteanu: GHC internally uses kind equalities, but I doubt you can write your own ones
12:42:35 <Eduard_Munteanu> I see. I thought that might document some kind sigs better.
12:42:44 <monoidal> Eduard_Munteanu: it might get better when datakinds are merged, but I don't know what will they bring
12:43:08 <Eduard_Munteanu> monoidal: mm, I'm using those
12:43:13 <Eduard_Munteanu> monoidal: they're there since GHC 7.4 I think
12:43:18 <monoidal> Eduard_Munteanu: I mean, kinds without data
12:43:45 <johnw> chrisdone: hallo!
12:43:51 <monoidal> Eduard_Munteanu: the plan is that you will be able to write data kind A x = T (x -> *) | Y * or something like that
12:44:05 <chrisdone> johnw: given up on gchat? =p
12:44:16 <johnw> this feels friendlier sometimes
12:44:42 <mr-> Does anyone know if there is a more idiomatic way to do that? http://lpaste.net/93177 It is about evaluating a State a action inside a StateT ..
12:45:05 <monoidal> Eduard_Munteanu: Omega has a nice kind system for such types
12:45:19 <chrisdone> johnw: /j #fpcomplete!
12:45:31 <johnw> i'm there
12:45:36 <chrisdone> liar!
12:45:40 <Eduard_Munteanu> monoidal: cool, so basically it's type-level datatypes
12:45:48 <monoidal> Eduard_Munteanu: yes
12:45:57 <chrisdone> oh, i mean on this network
12:46:53 <monoidal> mr-: UIState a is State UI a for some type UI?
12:48:57 <mr-> monoidal: no, it is, say type UIState = Integer
12:49:38 <monoidal> mr-: so you want a function StateT UIState Identity a -> StateT UIState (InputT IO) a
12:49:46 <MitchellSalad_> hi, could someone please explain to me why this computation hangs: http://lpaste.net/93179
12:50:00 <MitchellSalad_> it seems like <|> doesn't short circuit
12:51:08 <mr-> monoidal: Ah, I've seen something like that before... using mapState?
12:51:33 <mr-> +T
12:51:48 <monoidal> mr-: Yes
12:52:20 <nobla> what are the things I'm doing wrong here: http://lpaste.net/93181
12:52:56 <monochrom> MitchellSalad_: right, perhaps it doesn't. perhaps =~ must build the actual regex first. well, trying to build an actual regex from "loop = loop" is not going to work.
12:54:04 <monochrom> and trying to an actual regex from p<|>q requires building actual regexes for p and for q, without saying "maybe we don't need q"
12:54:28 <benmachine> :t state . runState
12:54:30 <lambdabot> MonadState s m => State s a -> m a
12:54:33 <monoidal> :t mapStateT (return . runIdentity)
12:54:37 <lambdabot> Monad n => StateT s Identity b -> StateT s n b
12:54:40 <MitchellSalad_> i see. then I guess it's not so straightforward to make a regex parser for a recursive datatype?
12:54:44 <pavonia> nobla: there's no recursive call of collatz
12:54:47 <monoidal> mr-: ^
12:54:49 <MitchellSalad_> i.e. Expression = Const Int | Sum Expression Expression
12:55:28 <pavonia> nobla: and instead of / you probably want `div`
12:55:35 <monochrom> I don't know. which package has Text.Regex.Applicative?
12:55:36 <mr-> Ah, I had mapStateT return .. forgot that Identity is not quite just Identity..
12:55:40 <MitchellSalad_> regex-applicative
12:55:44 <mr-> monoidal: thanks!
12:55:46 <nobla> :pavonia thank you
12:55:46 <monoidal> mr-: benmachine's version is better IMO
12:55:50 <quchen> I don't think it's straightforward to make a regex parser.
12:56:09 <quchen> Why not use (Atto-) Parsec?
12:56:19 <benmachine> monoidal: although mine uses mtl and not just transformers, I believe
12:56:20 <monochrom> "Expression = Const Int | Sum Expression Expression" is unlikely doable by a regex. it looks non-regular
12:56:22 <pavonia> nobla: and there already is a function "even" in the Prelude
12:56:26 <pavonia> @ty even
12:56:27 <lambdabot> Integral a => a -> Bool
12:56:48 <monoidal> benmachine: it works on transformers
12:57:02 <MitchellSalad_> quechen: i'm just working my way through this blog http://blog.econify.com/2013/08/fun-with-applicative-functors-pt-i.html which happens to use regex-applicative
12:57:25 <benmachine> monoidal: ah, right, state still exists there but is leess polymorphic
12:57:36 <MitchellSalad_> alright, thanks monochrom
12:58:00 <nobla> :pavonia good to know, i am liking haskell better than clisp and dr racket
12:58:01 <mr-> monoidal: I think I prefer yours - I understand it, at least ;-)
12:58:29 <benmachine> I never understood the map* functions from transformers
12:58:39 <benmachine> they all seemed similar but not quite the same
12:59:04 <monoidal> mr-: "runState" gives you a function s -> (a,s) and "state" inserts it into any monad that supports notion of state for s, so it can be StateT s deeply hidden
12:59:16 <monochrom> MitchellSalad_: I don't think you're meant to write your own recursive RE. it seems you're meant to use reFoldl or few
13:00:02 <MitchellSalad_> monochrom: hm, I'll check those out. in the blog post I linked above he does fold the Sum constructor over a list of atoms
13:00:10 <mr-> Bummer.. cabal-install doesn't depend on transformers yet
13:00:18 <MitchellSalad_> so you're probably right
13:01:27 <monochrom> oh, and "many" and "some"
13:04:46 <monochrom> this looks like a pretty nice API. I mean, Applicative and stuff
13:05:00 <monochrom> and above all, "it is not a string" :)
13:05:21 <MitchellSalad_> :D
13:10:27 <shachaf> "This is not a String"
13:20:24 <chrisdone> @src filterM
13:20:24 <lambdabot> Source not found.
13:20:29 <chrisdone> outrageous
13:30:18 <quchen> What do you guys think about issuing warnings if the code contains "undefined"? I'm thinking -fwarn-undefined could be a good addition to -W.
13:30:59 <MitchellSalad_> sort of like a todo, isn't it?
13:30:59 <donri> quchen: duno, that's rather brittle
13:31:30 <quchen> Hm?
13:31:44 <donri> quchen: if you just use "undefined" for prototyping, type holes are a much better solution
13:31:47 <chrisdone> in classy-prelude i got snoyman to add a deprecation warning to undefined
13:31:48 <quchen> MitchellSalad_: Yes, 'undefined' is pretty much Haskell's TODO feature.
13:32:04 <donri> quchen: if you worry about actual bottoms, those are gonna be hard to detect with any sort of reliability
13:32:06 <quchen> donri: What I have in mind here is avoiding to forget filling in certain "undefined"s.
13:32:20 <quchen> With undefined I mean Prelude.undefined.
13:32:22 <chrisdone> yeah, a deprecation warning sorts that out
13:32:29 <shachaf> Better to use the new holes in 7.whatever.
13:32:35 <donri> yes, you want holes
13:32:48 <chrisdone> you want to upgrade your compiler infrastructure!
13:33:00 <chrisdone> "but-real world!" "nah"
13:33:03 <donri> well if you're asking for a new warning flag that's gonna be a new ghc version too
13:33:05 <acowley> undefined is used not as a placeholder quite often
13:33:12 <quchen> Holes for prototyping? I mean for growing code based on types, yes, but to fill in the gaps?
13:33:36 <quchen> Wait that sentence didn't make much sense.
13:34:05 <quchen> Anyway, not a good idea, nevermind.
13:34:22 <chrisdone> i think it's a good idea =)
13:34:32 <donri> chrisdone: does that give source locations as well? (that point to where it's used, not where it's defined)
13:34:53 <chrisdone> i don't remember, doesn't matter much
13:36:32 <donri> otherwise you can go the TH route ;) http://hackage.haskell.org/packages/archive/file-location/0.4.5.2/doc/html/FileLocation.html
13:37:10 <donri> hm no wait this isn't what you're talking about here
13:37:21 <chrisdone> those don't have deprecation annotations
13:37:21 <donri> although you could do it with TH too and reportWarning
13:37:52 <donri> why deprecation though? isn't there a WARNING pragma
13:37:53 <troii> haskell is shit
13:38:20 <donri> i think you meant for those i's to be upper cased, troII
13:38:52 <chrisdone> donri: here it is in classyprelude http://hackage.haskell.org/packages/archive/classy-prelude/0.5.8/doc/html/src/ClassyPrelude.html#undefined
13:39:18 <donri> yeah it's a cute trick
13:41:12 <donri> chrisdone: the irony though is my undefineds are usually there to silence incorrect warnings for non-exhaustive patterns ;) needs moar "catch"
13:42:39 <ReinH> most pathetic troll ever
13:42:42 <ReinH> they're getting so lazy
13:42:53 <donri> but they're lazy with class!
13:42:58 <monochrom> you can define todo = error "TODO". then you can use that for holes, stubs, this-site-is-under-construction
13:43:26 <troii> boring language
13:43:36 <ReinH> Have we mentioned ImplicitParams yet?
13:43:40 <ReinH> troii: boring troll
13:43:43 --- mode: ChanServ set +o shachaf
13:43:46 --- mode: shachaf set +b *!*c242af59@*.194.66.175.89
13:43:47 --- kick: troii was kicked by shachaf (troii)
13:43:49 --- mode: shachaf set -o shachaf
13:44:20 <chrisdone> monochrom: △ UNDER CONSTRUCTION △
13:44:25 <chrisdone> 90's style
13:44:29 <donri> {-# OPTIONS_GHC -fdefer-type-errors #-}; data Hole; __ = error "hole" :: Hole
13:44:31 <donri> ;)
13:44:36 <monochrom> but there is this problem: if at runtime you actually hit "TODO", it gives you little information which one you hit
13:44:56 <lpsmith> ugh,  the exact format that binary produces by default depends on whether you are using 32 or 64 bit GHC
13:45:10 <shachaf> #define TODO (error (__FILE__ ++ ":" ++ show __LINE__))
13:45:51 <donri> @hackage pseudomacros ;)
13:45:51 <lambdabot> http://hackage.haskell.org/package/pseudomacros ;)
13:46:13 <chrisdone> donri: that's good
13:46:28 <donri> chrisdone: what is?
13:46:30 <Eduard_Munteanu> What's a good way to represent a non-Hask category? The best I could think of is   f :: i -> k   where i and k are polykinds. If I want a subcategory of Hask, i, k = *.
13:46:34 <chrisdone> donri: what you just linked
13:46:44 <donri> heh
13:46:48 <acomar> The hole appraoch also gives you the type of the hole you hit in 7.8, right?
13:47:04 <Eduard_Munteanu> But is there a way to avoid the functorial thing?
13:47:04 <donri> acomar: yes
13:47:11 <donri> acomar: as does my "poor man's hole" above
13:47:15 <donri> works in 7.6
13:47:21 <acomar> awesome!
13:47:36 <monoidal> Eduard_Munteanu: I think the normal Category with polykinds (as in HEAD) is ok
13:47:47 <Saizan>  Eduard_Munteanu f :: k -> k -> *, no?
13:48:10 <monochrom> donri: how do I use it? do I write unfinished types like joy :: Hole -> Int ?
13:48:13 <Eduard_Munteanu> Saizan: no, I was talking about objects, your 'f' is for the hom.
13:48:46 <donri> monochrom: you use __ just like you would use _ in 7.8
13:49:05 <shachaf> Represent objects as identity arrows.
13:49:06 <monochrom> but I don't know what _ does in 7.8
13:49:06 <donri> monochrom: you never mention "Hole" yourself
13:49:24 <chrisdone> that's a "noisy" hole
13:49:25 <monoidal> class Hole where hole :: a -- woho nullary typeclasses
13:49:37 <donri> > "hole" + 3 -- will tell you the hole should be Num
13:49:38 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:49:38 <lambdabot>    arising from a use of `GH...
13:50:37 <ReinH> So... ImplicitParams? No?
13:50:39 <chrisdone> > ?hole + 3
13:50:40 <Eduard_Munteanu> What do you call the class / set of things that can be object, for all categories?
13:50:40 <Eduard_Munteanu> Universe?
13:50:44 <lambdabot>   mueval-core: internal error: PAP object entered!
13:50:44 <lambdabot>      (GHC version 7.6.3 fo...
13:50:48 <chrisdone> lol wat
13:50:57 <donri> ReinH: those only work as holes with :t
13:51:02 <donri> :t ?hole + 3
13:51:03 <lambdabot> (Num a, ?hole::a) => a
13:51:14 <Eduard_Munteanu> shachaf: hm, I think I remember that approach, I'll try, thanks.
13:51:25 <ReinH> donri: uh...
13:51:25 <shachaf> Eduard_Munteanu: Look in -- data-category, I think? -- for an example.
13:51:31 <chrisdone> donri: which makes it a bit useless =(
13:51:37 <shachaf> Eduard_Munteanu: Well, that example doesn't use polykinds.
13:51:41 <Eduard_Munteanu> monoidal: anyway, Category would use * as the universe
13:51:43 <donri> chrisdone: yeah. still i have it on in ghci
13:51:54 <Eduard_Munteanu> monoidal: not sure if that's enough
13:52:22 <Eduard_Munteanu> e.g. in   id :: cat a a  a :: *
13:52:55 <monoidal> Eduard_Munteanu: by universe you mean objects?
13:53:15 <monoidal> Eduard_Munteanu: with polykinds the definition of Category gives you Category :: (k -> k -> *) -> Constraint
13:53:30 <Eduard_Munteanu> monoidal: take Ob(C) for all categories C, what's the union of all those?
13:53:47 <monoidal> Eduard_Munteanu: all Haskell kinds
13:54:02 <monoidal> Eduard_Munteanu: um, I mean types
13:54:33 <Eduard_Munteanu> Yeah, from different kinds. But I wanted a word for the math thing.
13:54:42 <monochrom> ok I guess I forgot that __ is a valid identifier
13:54:49 <Eduard_Munteanu> Anyway, * looks smaller than that "set".
13:55:49 <Eduard_Munteanu> E.g. *  <  * -> *   I think
13:56:44 <nobla_> when I want to create a block of code in an if statement do I use a parenthesis or just indent the code?
13:57:02 <Eduard_Munteanu> nobla_: indent, or just avoid if-then-else
13:57:22 <Eduard_Munteanu> In many cases, a case statement looks nicer.
13:57:34 <monochrom> you likely do need parentheses altogether
13:57:43 <monochrom> err
13:57:47 <monochrom> you likely don't need parentheses altogether
13:58:49 <Eduard_Munteanu> I'm thinking of something like   class GenCategory (arr :: ob -> ob -> hom) where  type Repr :: hom -> *  gId :: Repr (a |~arr~> a)   gCompose :: Repr (b |~arr~> c) -> Repr (a |~arr~> b) -> Repr (a |~arr~> c)
13:59:23 <Eduard_Munteanu> Now, I'm not sure how to make the objects set more flexible.
14:00:26 <nobla_> :Eduard_Munteanu thanks
14:00:58 <Eduard_Munteanu> I guess I still want a functor to define my Ob.
14:07:23 <chrisdone> banseljaj: coi
14:11:29 <chrisdone> hmph. a load of lojbanners just joined at once
14:12:29 <clahey> chrisdone: Joined where?
14:12:46 <chrisdone> banseljaj, djanatyn, Tene, ByronJohnson just joined within the minute
14:13:04 <chrisdone> it's either a fun coincidence or they're discussing haskell in the lojban channels =)
14:13:28 <clahey> Ah.  I guess I was just unclear on how you knew they all spoke lojban.
14:13:39 <chrisdone> banseljaj and djanatyn are lojbanic names
14:13:41 <Tene> chrisdone: We're all connecting from the same host.
14:13:50 <chrisdone> aha
14:13:56 <chrisdone> a server from lojbanistan ;)
14:14:02 <Taneb> chrisdone has the magical ability to work out what languages people speak from their IRC nick
14:14:31 <Tene> chrisdone: Yes, exactly; sf bay area is as close to lojbanistan as you can get.
14:14:37 <clahey> Now that he pointed it out, I see it with djanatyn, but I'm not sure why with banseljaj.
14:16:22 <chrisdone> clahey: it's uhh.. ban- as in language, sel as in flip the next arg, jaj as in gathering/crowding. so, i guess "location of language congregation" or something
14:17:35 <clahey> chrisdone, Ah, cool.
14:18:20 <Tene> Pretty much, yeah.
14:18:55 <clahey> Tene, What would you say is the best way to learn lojban?
14:19:05 <haasn> try asking #lojban
14:19:34 <haasn> this is very off-topic here, not that I wish to spoil the fun
14:19:49 <Tene> clahey: read Lojban For Beginners, and then follow conversations in #lojban with a dictionary reference, optionally doing flash-card reviews of vocabulary.
14:20:03 <shachaf> Spoiling the fun is my job, obviously.
14:20:04 <shachaf> @yarr
14:20:15 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
14:20:43 <chrisdone> oo er!
14:35:47 <schell_> any tips for running ghc HEAD next to the current stable ghc?
14:36:13 <joelteon> hsvm
14:36:23 <joelteon> I need beta testers
14:36:57 <quchen> schell_: Multiple versions of GHC work alongside fine
14:37:31 <schell_> so just ./configure; make; make install as usual?
14:38:04 <quchen> You'll want to set a different prefix in ./configure, but apart from that: yes
14:38:33 <monochrom> ./configure --prefix=/different
14:39:03 <schell_> ok, thanks
14:39:26 <monochrom> then you will have to play games with PATH :)
14:40:19 <quchen> Or put a softlink in ~/bin
14:40:36 <quchen> … which isn't really "playing games" (which sounds painful)
14:43:32 <schell_> joelteon: can you link me to hsvm?
14:43:42 <joelteon> schell_: https://github.com/joelteon/hsvm
14:44:51 <schell> joelteon: i use the fish shell - do you think that will play nice with hsvm?
14:44:58 <joelteon> yeah
14:45:00 <joelteon> hopefully
14:46:35 <schell> okay - i'll try it
14:47:04 <schell> though your github jenkins says it's not compiling (you probably know that, huh?)
14:47:52 <k0001_> joelteon: so, hsvm is supposed to be something like Ruby's rvm or OCaml's opam? Sounds nice.
14:48:01 <joelteon> it's supposed to be like rbenv
14:48:05 <joelteon> schell: it's compiling, a test suite is failing
14:48:09 <joelteon> because of a library issue on ubuntu
14:48:20 <schell> ahh - cool
14:48:21 <schell> :)
14:48:26 <k0001_> (Well, opam's «switch» functionality at least)
14:48:29 <joelteon> generally i spend 10% of my time writing tests, 10% of my time fixing tests, and 80% of my time fixing things that shouldn't be broken, but are on travis
14:49:02 <schell> oh right, that's travis, not jenkins
14:54:27 <schell> joelteon: bummer, it seems that fish syntax for setting path is totally different
14:54:45 <joelteon> oh, right
14:54:47 <joelteon> yeah, fish is pretty weird
14:54:50 <joelteon> ddddd
14:55:00 <joelteon> schell: file an issue, i haven't used fish in AGES
14:55:02 <edwardk> fish?
14:55:03 <joelteon> but i should be able to get it working
14:55:12 <edwardk> oh shell
14:55:32 <schell> right
15:04:14 <ParahSailin> optparse-applicative stumbles if you have both optional positional arguments and options
15:04:40 <chrisdone> don't options just ignore anything not prefixed by -?
15:05:34 <ParahSailin> yeah, its the optional positional argument that trips up
15:06:15 <ParahSailin> it eats a -arg and returns Nothing
15:07:26 <mp> what's the easiest way to do str.replace (as in Python) in Haskell on Data.ByteString.Lazy.Char8?
15:09:19 <osxorgate> trying to understand the syntax, what's the deal with the $ and what's its relation to the last line? https://gist.github.com/anonymous/6630545
15:09:35 <Maior> :t $
15:09:36 <lambdabot> parse error on input `$'
15:09:41 <Maior> :t ($)
15:09:42 <lambdabot> (a -> b) -> a -> b
15:09:58 <Maior> osxorgate: "hack" to avoid parentheses ;)
15:10:22 <Cale> mp: I'd probably just write it myself in terms of breakSubstring -- there are a couple subtly different possible semantics for such a thing
15:10:26 <osxorgate> not sure what just happened.. but ok
15:10:34 <Maior> osxorgate: otherwise you'd need "print (sq (sqrt (7 + 9))"
15:10:43 <elliott> @src ($)
15:10:43 <lambdabot> f $ x = f x
15:10:43 <geekosaur> it's just an operator that applies a parameter. but, where normal parameter application is highest precedence, $ is lowest
15:11:04 <geekosaur> so it often lets you skip parentheses
15:11:07 <dwcook> You could also write print $ sq $ sqrt $ 7 + 9 to get rid of all those parens
15:11:17 <osxorgate> maior i tried: main = print sq $ (sqrt (7 + 9))   why is that invalid?
15:11:34 <dwcook> osxorgate, because you are trying to pass two arguments to print
15:11:43 <dwcook> sq is one, sqrt (7 + 9) is the other
15:11:46 <mp> osxorgate: in very simple words: foo bar baz normally tries to do f = foo(bar), and then f(baz); so $ changes order of evaluation to x = bar(baz) and then foo(x)
15:11:57 <Maior> osxorgate: what dwcook said (left associativity)
15:12:05 <Maior> osxorgate: another way of writing main: main = print $ sq $ sqrt $ 7 + 9
15:12:52 <elliott> ($) doesn't change order of evaluation at all.
15:13:09 <osxorgate> hm i dont understand, i thought $ was supposed to apply the right part to the left part, yielding 1 result (which is passed to print)
15:13:25 <dwcook> osxorgate, that's correct
15:13:45 <dwcook> but you are applying sqrt (7 + 9) to print sq in this case
15:13:57 <dwcook> print sq is what's on the left, sqrt (7 + 9) the right
15:14:10 <dwcook> which fails to work because print sq is not a function
15:14:13 <osxorgate> ok that makes sense
15:14:34 <osxorgate> on with the tut, thanks fellas ;)
15:14:43 <dwcook> \o/
15:16:46 <Cale> Or:  print . sq . sqrt $ 7 + 9
15:17:29 <Cale> (.) is properly associative, so you don't have to worry about which direction ($) associates in
15:17:34 <quchen> osxorgate: "$ is like an opening parenthesis that reaches to the end of the line"
15:17:44 <Cale> in both directions
15:17:58 <quchen> I didn't say which line ;-P
15:18:23 <Cale> "what if the expression is split across multiple lines????"
15:18:32 <Cale> ;)
15:18:37 <dagano> > foldr (*) 1 [1..64]
15:18:38 <lambdabot>   126886932185884164103433389335161480802865516174545192198801894375214704230...
15:18:40 <quchen> Syntax error. Submitting ticket now!
15:19:31 <dagano> why in ghci when i do 64! are there so many zeroes at the end of the result?  is this an 'overflow' issue or is this an actual characteristic of the result?
15:19:45 <quchen> dagano: It's the result.
15:19:46 <elliott> factorials are big.
15:20:07 <quchen> dagano: Every time you multiply a number with something that contains 10 as a factor, you get an additional trailing zero.
15:20:10 <ciaranm> because 64! includes 10, and 2 * 5, and 20, and lots of other things have have a 0 on the end
15:20:17 <dagano> oh durrrr
15:20:23 <dagano> why is everyone here smarter than me?
15:20:47 <osa1> is there a way to tell cabal to put resulting binary to the ./ instead of dist/bin/... or do I have to do this in a Makefile or something like that? in my project I'll only use Haskell to parse some files and I don't want to install parser binary to system.
15:20:52 <S_J> > 5!
15:20:54 <lambdabot>   <hint>:1:3:
15:20:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
15:20:57 <S_J> > 20!
15:20:58 <lambdabot>   <hint>:1:4:
15:20:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
15:21:43 <geekosaur> S_J: we don't have PostfixOperators enabled, or whatever the extension is
15:21:57 <dagano> :t (!)
15:21:58 <lambdabot> Ix i => Array i e -> i -> e
15:22:04 <geekosaur> and almost certainly don;t have the right (!) in scope, yeh
15:22:09 <mauke> even then you need parens
15:22:30 <quchen>  > let faculty 0 = 1; faculty n = n * faculty (n-1) in (3 `faculty`)
15:22:47 <mauke> *factorial
15:22:51 <ciaranm> that's a silly way to count your faculties
15:22:53 <mauke> (german detected)
15:22:57 <psii> osa1: maybe symbolic links are fine?
15:22:59 <quchen> Woops.
15:23:13 <FreeFull> > let faculty 0 = 1; faculty n = n * faculty (n-1) in (3 `faculty`)
15:23:14 <lambdabot>   6
15:23:25 <quchen> Ha, ze German is spredding
15:23:33 <det> Does lazy evaluation have much effect on parallelism? Do typically implementations have to resort to locking/atomics when they evaluate thunks?
15:23:46 <FreeFull> > let (!) 0 = 1; (!) n = n * (!) (n-1) in (31)
15:23:47 <lambdabot>   31
15:23:48 <FreeFull> > let (!) 0 = 1; (!) n = n * (!) (n-1) in (3!)
15:23:49 <lambdabot>   6
15:24:06 <S_J> > let fac n = scanl (*) 1 [1..n] in map fac [1..6]
15:24:08 <lambdabot>   [[1,1],[1,1,2],[1,1,2,6],[1,1,2,6,24],[1,1,2,6,24,120],[1,1,2,6,24,120,720]]
15:24:11 <FreeFull> You can do postfix unary as long as you use brackets it seems
15:24:17 <S_J> > let fac n = foldl (*) 1 [1..n] in map fac [1..6]
15:24:18 <lambdabot>   [1,2,6,24,120,720]
15:24:28 <S_J> > let fac n = foldl (*) 1 [1..n] in map fac [0..10]
15:24:29 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
15:24:32 <quchen> det: Laziness doesn't affect parallelism very much I would say, but I can see how you could make a case either way. Locking is unnecessary due to purity.
15:24:36 <FreeFull> Oh, lambdabot must be using some extension
15:24:42 <FreeFull> Because it's not working in ghci for me
15:25:09 <quchen> det: If you want to have side-effects (I/O, inter-thread communication etc.) the situation changes of course, but that's unrelated to laziness.
15:25:20 <FreeFull> S_J: foldl (*) 1 is fully equivalent to product
15:25:21 <pavonia> FreeFull: I think it's only working because of Num (a -> b) in lambdabot
15:25:32 <FreeFull> You probably want foldl' though
15:25:35 <FreeFull> pavonia: That could be it
15:25:36 <det> quchen, Im not sure you are understanding my question or I am misunderstanding your answer
15:26:06 <shachaf> det: When a thread starts evaluating a thunk, it replaces it with code so that other threads wait for the result before continuing.
15:26:41 <det> shachaf, Is this a problem for parallelism in practice ?
15:26:44 <shachaf> det: In some cases multiple threads do it at the same time, and some work is wasted. But that's not a disaster because they're all computing the same thing.
15:26:58 <shachaf> (unsafePerformIO has a special guard against this happening.)
15:27:20 <det> I see, so instead of locking, they just accept they might evaluate the same thunk many times in a race ?
15:27:36 <shachaf> Right, in the worst case.
15:27:42 <shachaf> But that doesn't happen that often.
15:27:58 <elliott> is there a name for (unsafePerformIO . return) somewhere to avoid that duplication when the thunk is really expensive?
15:28:07 <det> Thanks for the explanation
15:28:10 <shachaf> unsafePerformIO is defined in terms of noDuplicate
15:28:28 <shachaf> kmc's post at http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html might clear some things up.
15:28:48 <elliott> noDuplicate is an IO action though, isn't it?
15:28:57 <elliott> so there's no safe (a -> a) provided anywhere for it.
15:29:00 <shachaf> Yes.
15:29:01 <shachaf> Oh.
15:29:06 <elliott> once :: a -> a
15:29:07 <shachaf> Are you sure you want that?
15:29:10 <elliott> maybe.
15:29:13 <shachaf> What's an example of a really expensive thunk?
15:29:24 <elliott> once computeSomeGiganticInteger
15:29:31 <osa1> which type is appropriate for generating big amounts of text by concatenating? Text? Doc?
15:29:49 <shachaf> I guess it might not be built out of other thunks.
15:29:52 <shachaf> Anyway, I don't know.
15:29:58 <shachaf> I don't think there's a name for it.
15:33:59 <quchen> osa1: Lazy text has somewhat efficient appending. If that's still to slow consider a DList-like approach.
15:34:34 <ciaranm> consider creating your text backwards
15:34:53 <quchen> Lazy text is a list of strict text chunks, so if you don't repeatedly add single characters it's pretty efficient to append bigger chunks to each other.
15:35:37 <osa1> what about ByteString's Builder?
15:35:50 <quchen> ByteString isn't for text.
15:40:18 * hackagebot idris 0.9.9.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.9.1 (EdwinBrady)
15:40:39 <shachaf> Now that hpaste.org is working again, can we call it hpaste again?
15:40:50 <shachaf> chrisdone: ☝
15:41:11 <geekosaur> ppaste, upaste...
15:41:13 <ciaranm> does what we call it alter what it does?
15:52:25 <jfischoff> is there an easy way to make a global variable unsafePerformIO $ newIORef False that no will only allocate once?
15:52:43 <jfischoff> I want to make the eqivalent of c global variable
15:53:27 <chrisdone> can you rephrase that so it's grammatical?
15:53:36 <jfischoff> never
15:53:41 <chrisdone> =(
15:54:03 <jfischoff> alternatively is there a way to check your app has a file handle already open
15:54:04 <jfischoff> ?
15:55:17 <niteria> /proc/pid/fd ;p
15:55:22 <benmachine> jfischoff: what do you mean by a file handle?
15:56:02 <jfischoff> benmachine: /dev/random specifically
15:56:25 <shachaf> You should probably use /dev/urandom
15:56:25 <jfischoff> crypto-random endless opens /dev/random until your app stops working
15:56:57 <jfischoff> I'm not looking for the best solution
15:57:13 <jfischoff> I'm looking for a way to make a work around
15:57:43 <shachaf> Well, the unsafePerformIO thing you mentioned should work.
15:57:50 <shachaf> Mark it NOINLINE.
15:58:08 <jfischoff> and then it only gets evaluated once right?
15:58:16 <shachaf> What does?
15:58:34 <jfischoff> the thunk
15:58:36 <shachaf> (I'm not sure why False helps you, but I guess you'll figure something out.)
15:58:54 <shachaf> No, it gets evaluated many times. That's the point of a thunk. :-) But only one IORef will be created.
15:59:06 <jfischoff> hehe
16:02:48 <chrisdone> i wonder whether there's a wiki entry on this. everyone does it at some point
16:03:12 <chrisdone> here we go: http://www.haskell.org/haskellwiki/Top_level_mutable_state
16:03:17 <haasn> Is ‘unsafePerformIO getArgs’ considered bad? It's constant across invocations of the program, no?
16:04:33 <jfischoff> chrisdone: thianks
16:04:48 <ski> @wiki Top level mutable state
16:04:48 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
16:04:48 <jfischoff> um whoops
16:04:54 <ski> jfischoff ^ ?
16:05:00 <ciaranm> haasn: unsafePerformIO is admitting you don't understand monads
16:05:04 <monoidal> haasn: technically, you can use withArgs to change getArgs
16:05:11 <ski> oh, chrisdone said it
16:05:17 <jfischoff> thanks anyway ski
16:05:26 <monoidal> haasn: it might be tempting, but it's generally not recommended
16:06:09 <haasn> ciaranm/monoidal: I'm not planning on using it, I was just curious to see if defining getArgs :: [String] would have made sense
16:06:14 <haasn> in the first place, that is
16:06:19 <ski> haasn : doing that kind of thing will probably make it harder for mobile code to happen
16:08:17 <chrisdone> getArgs :: [String] would be a bit funky, e.g. in GHCi you'd get getArgs = [], but :main foo bar would mean getArgs = ["foo","bar"]. like an implicit param, but not
16:08:48 <nik_89> is there a native GUI that has been made or being made in haskell?
16:09:00 <chrisdone> native in what sense?
16:09:12 <nik_89> as in made in haskell from scratch
16:11:14 <haasn> GUI in what sense?
16:12:11 <sm> http://en.wikipedia.org/wiki/House_%28operating_system%29 sounds like it includes one
16:12:29 <sleepynate> i don't think there's a popular "native gui" in any language that doesn't fall back on a C binding except maybe Swing?
16:12:51 <chrisdone> nik_89: so e.g. using opengl/sdl or xorg or direct3d or win32 api? not using a gui toolkit like gtk/qt/win32?
16:13:16 <haasn> or wayland! *ducks*
16:13:50 <chrisdone> lamdu the IDE uses its own ui built on opengl, for example
16:16:01 <sm> sleepynate: squeak smalltalk is one
16:16:12 <sleepynate> good call
16:16:26 <sleepynate> i always forget about squeak and its derivatives
16:16:28 <nik_89> well last I checked gtk support was pretty sparse, I never noticed that qt had a foreign interface project. The only viable solution seemed to be the C++ one wxwidget
16:16:41 <ciaranm> qt isn't c++!
16:17:00 <sleepynate> gtk support in haskell is ok
16:17:11 <sleepynate> leksah uses it pretty successfull
16:17:28 <Tordek> hi, a couple of question wrt boolean ops
16:18:49 <Tordek> is there some sort of "andLift"? e.g., instead of "isGood x && isLong x", something like "isGood `andthen` isLong x"?
16:18:52 <nik_89> chrisdone: are you telling me there are decent game engines that have been done in haskell?
16:19:09 <chrisdone> sleepynate: you mean C binding as in gtk/qt toolkit, or even xlib or win32/opengl?
16:19:21 <monoidal> Tordek: liftM2 (&&)
16:19:22 <Iceland_jack> Tordek: liftM2 (&&) ?
16:19:35 <sleepynate> chrisdone: sure
16:19:49 <chrisdone> sleepynate: huh
16:19:55 <sleepynate> can you think of others?
16:20:01 <Tordek> is there an "implies"? (e.g., isLetter x `implies` isUpper x, to avoid "not (isLetter x) || isUpper x"?
16:20:06 <Tordek> cool, thanks
16:20:10 <sleepynate> like one that's really "native" to another language?
16:20:19 <monoidal> Tordek: <=
16:20:20 <chrisdone> sleepynate: you answered sure to an OR question, i'm still not sure what you mean
16:20:35 <haasn> monoidal: cute
16:20:44 <chrisdone> nik_89: no. there is Frag, an FPS written in haskell with opengl, but it was a one-man phd project or so
16:20:45 <Iceland_jack> ((&&) <$> isUpper <*> isLower) ≡ (liftM2 (&&) isUpper isLower) ≡ (\x -> isUpper x && isLower x)
16:20:48 <chrisdone> @wiki Frag
16:20:48 <lambdabot> http://www.haskell.org/haskellwiki/Frag
16:20:51 <sleepynate> chrisdone: well it was "or even", which colloquially i would take as "including"
16:21:09 <chrisdone> oh
16:21:20 <haasn> I think the most ‘game dev’ I have seen in Haskell is using SDL/FRP or gloss
16:21:25 <chrisdone> well CLIM is written in lisp, but i don't know whether its backends are using xlib or not
16:21:45 <sleepynate> right. i was thinking of Tk too, but i think it's backed by C
16:22:51 <pavonia> implies = (<=)  -- the direction of the arrow is kind of misleading for what you actually want :P
16:22:52 <chrisdone> you could implement the xorg protocol directly i guess
16:23:03 <chrisdone> common lisp has an xgl protocol implementation, so that's pure lisp
16:23:20 <sleepynate> naturally, half the links on cliki are out of date :/
16:23:56 <Tordek> monoidal: hmm, interesting... although it's weird because the arrow is backwards :/
16:23:59 <sm> it would be interesting to try and replicate the smalltalk graphics system in haskell
16:24:19 <Iceland_jack> Tordek: (It's not meant to be ‘implies’, it's comparison)
16:24:34 <Tordek> Iceland_jack: yeah, it's cool anyways
16:24:39 <pavonia> Tordek: you can define "(=>) = (<=)"
16:24:42 <ciaranm> > (=>) = flip (<=)
16:24:43 <lambdabot>   <hint>:1:2: parse error on input `=>'
16:24:49 <chrisdone> sleepynate: search anything for lisp and you'll get five results, the first doesn't work on your OS, the second is proprietary, the third is a dead link, the fourth has bitrotted and was last updated in 2002, the fifth works but doesn't have any features
16:24:52 <monoidal> pavonia: => is reserved for contexts
16:25:01 <monoidal> you can have ==> though
16:25:13 <pavonia> ah, right >.<
16:25:21 <sleepynate> chrisdone: reminds me of haskell 6 :D
16:25:26 <sleepynate> ghci*
16:25:29 <sleepynate> ghc*
16:25:30 <sleepynate> fuck
16:25:34 <Iceland_jack> Tordek: You may want to read this: http://programmers.stackexchange.com/questions/184089/why-dont-languages-include-implication-as-a-logical-operator
16:25:39 <sleepynate> i need calories in my face to make my brain work
16:26:29 <chrisdone> sleepynate: are you like L from death note?
16:29:47 <Tordek> cool, thanks, people
16:33:29 <sleepynate> chrisdone: i haven't seen that, but probably.
16:33:52 <Clint> chrisdone: is your scotty-scrobble source up somewhere?
16:46:13 <mangaba_leitosa> can someone point me to a working example (ready to run with GHC) of tree traversal using Data.Traversable? All examples I try lack correct import directives or use non-standard modules
16:47:02 <mangaba_leitosa> ... or lack proper derive directives...
16:47:06 <mangaba_leitosa> "deriving"
16:47:06 <edwardk> you want to just write one for some data structure?
16:47:35 <mangaba_leitosa> edwardk: I want to traverse a tree replacing some nodes with new trees
16:47:55 <edwardk> grafting in new trees isn't 'traverse' that sounds like (>>=)
16:48:24 <mangaba_leitosa> edwardk: or I want to map (+ 10) an interger tree
16:48:33 <edwardk> fmap (+10)
16:48:54 <edwardk> > fmap (+10) $ Node 1 [Node 2 [], Node 3 []]
16:48:55 <lambdabot>   Node {rootLabel = 11, subForest = [Node {rootLabel = 12, subForest = []},No...
16:49:45 <mangaba_leitosa> edwardk:
16:49:46 <mangaba_leitosa> Prelude> data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) deriving Show
16:49:46 <mangaba_leitosa> Prelude> let t = Node (Node Empty (Leaf 1) Empty) (Leaf 2) (Node Empty (Leaf 2) Empty)
16:49:49 <mangaba_leitosa> Prelude> fmap (+10) t
16:49:52 <mangaba_leitosa> <interactive>:7:1: No instance for (Functor Tree) arising from a use of `fmap'
16:49:55 <mangaba_leitosa> edwardk: what about my own Tree type?
16:50:08 <ciaranm> deriving Functor
16:50:21 <edwardk> instance Functor Tree where fmap _ Empty = Empty; fmap f (Leaf a) = Leaf (f a); fmap f (Node l a r) = Node (fmap f l) (f a) fmap f r)
16:50:21 <monochrom> wrtie a Functor instance
16:50:58 <mangaba_leitosa> monochrom: yeah, that's why am asking for an URL with a working example:-)
16:51:06 <monochrom> if you think "Traversable will help", you are not escaping from: write your own Traversable instance. it's circular logic.
16:51:07 <monoidal> > getConst $ traverse (Const . Sum) $ Node 1 [Node 2 [], Node 3 []]
16:51:08 <lambdabot>   Sum {getSum = 6}
16:51:16 <ciaranm> deriving Traversable!
16:51:18 <edwardk> or use {-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-} import Data.Foldable; import Data.Traversable; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) deriving (Show, Functor, Foldable, Traversable)
16:51:36 <mangaba_leitosa> monochrom: sure, but first I need a working example with those instances to study
16:51:49 <monochrom> ok, but edwardk wrote one
16:52:32 <mangaba_leitosa> monochrom: it doesn't work as is as I showed, so I'm goignt to try and add derivings etc... may be I succeed
16:52:50 <edwardk> mangaba_leitosa: the version i just wrote above gives you the instances
16:52:50 <spaceships> pure a = Node (pure a) a (pure a) -- ???
16:53:07 <edwardk> spaceships: that type doesn't have a nice Applicative.
16:53:22 <edwardk> you can make one, but it is lame =)
16:53:32 <spaceships> edwardk: oh =( pure a = Node Empty a Empty then?
16:53:32 <edwardk> it zips the trees
16:53:54 <mangaba_leitosa> edwardk: I'm not sure where your 'Node' comes from. with my Node it doesn't work
16:53:56 <edwardk> spaceships: the one with the infinite tree you gave is the only valid applicative bcause of the values in the nodes
16:54:03 <edwardk> mangaba_leitosa: mine is Data.Tree from containers
16:54:15 <edwardk> mangaba_leitosa: i provided above the change to your code
16:54:18 <spaceships> edwardk: oh i see - TREE is not a nice applicative
16:54:32 <mangaba_leitosa> edwardk: thanks, analyzing now :-)
16:55:34 <edwardk> spaceships: yeah the applicative is just a zippy applicative
16:56:10 <mangaba_leitosa> edwardk:     No instance for (Num (Tree Integer)) arising from a use of `+'
16:56:19 <spaceships> there was talk yesterday of making a Monad instance of Tree - I came up with two - one (>>=) :: Foldable b => Tree a -> (a -> Tree b) -> Tree b, and the other just throws away the rest of the tree from (a -> m b) ...?
16:56:30 <edwardk> mangaba_leitosa: show me the code using +
16:56:42 <mangaba_leitosa> edwardk: ok, I'll paste it to lpaste now
16:56:46 <spaceships> ... which seems silly
16:57:44 <khyperia> ... only after playing with haskell for a while do I realize how much I write (\x -> x != null) in other languages, and how painful it is.
16:57:58 <edwardk> spaceships: it seems very likely to not be a legal monad too ;)
16:58:00 <khyperia> because one, checking for null, and two, (!= null)
16:58:02 <mangaba_leitosa> edwardk: http://lpaste.net/93188
16:58:13 <spaceships> edwardk: ah okay =)
16:58:21 <ciaranm> call the monad police
16:58:33 <edwardk> t = Node (Node Empty (Leaf 1) Empty) (Leaf 2) (Node Empty (Leaf 2) Empty)  should be t = Node (Node Empty (Leaf 1) Empty) 2 (Node Empty (Leaf 2) Empty)
16:58:36 <edwardk> you have a Tree (Tree a)
16:58:42 <edwardk> if you look at the type of 't'
16:58:46 <spaceships> Yeah, what's join
16:58:47 <edwardk> er
16:59:01 <edwardk> t = Node (Node Empty 1 Empty) 2 (Node Empty 2 Empty)
17:00:10 <mangaba_leitosa> edwardk: the last version works. thanks a lot! at least I have a starting point now
17:01:17 <mangaba_leitosa> edwardk: it's amazing no working example can be easily googled. the example from Data.Traversable standard doc does not work either (lacks imports and deriving directives) :-)
17:01:38 <mangaba_leitosa> edwardk: so you really helped :-)
17:02:07 <edwardk> mangaba_leitosa: the on from Data.Traversable doesn't need deriving directives. that is what the manual instance is for
17:02:17 <edwardk> it does however, need two other instances =)
17:02:38 <edwardk> instance Functor Tree where fmap = fmapDefault; instance Foldable Tree where foldMap = foldMapDefault
17:02:44 <mangaba_leitosa> edwardk: it uses <*> which doesn't work without proper imports etc. :-)
17:02:53 <edwardk> and you need to import Data.Foldable and Control.Applicative as well as Data.Traversable
17:03:13 <mangaba_leitosa> edwardk: right. that's why I say that the example is not working as is :-)
17:03:29 <edwardk> i admit the example kind of assumes you know where to find those things, yeah
17:04:06 <Eugenn> >(+1) 4
17:05:03 <chrisdone> Clint: pok
17:05:33 <chrisdone> clint: you still there? my nick complete doesn't think you exist but i don't see a quit, part or nick change
17:05:57 <mangaba_leitosa> edwardk: now, can I use Functor, Foldable or Traversable for easier transformation of a tree replacing some leaves with new trees? I can do this with my own recursive function that doesn't use any of this stuff, but I wonder if this can be done easier
17:06:22 <Clint> chrisdone: i exist!
17:06:36 <edwardk> here you have a problem. what does it mean to replace 'a' with a new tree when the a is a value danging off a node, not a leaf?
17:06:47 <edwardk> if you change your types a bit we can fix this, but it uses Monad, not any of those classes
17:06:51 <Rarrikins> Clint: No, i is imaginary.
17:07:03 * Clint disappears in a cloud of punnery.
17:07:21 <chrisdone> clint: so this is a proper scrobble server and client: http://hackage.haskell.org/package/scrobble
17:07:51 <mangaba_leitosa> edwardk: yes, I think I need to change Node (Tree a) a (Tree a) to Node (Tree a) (Tree a). I'm not sure why the example I found inserts Int directly instead of via a Leaf
17:08:11 <edwardk> mangaba_leitosa: removing 'a' from Node, lets us make a Monad.
17:08:21 <Clint> chrisdone: but that's not what http://chrisdone.com/music is?
17:08:25 <chrisdone> client: client: but re my latest blog post about a scotty-based server, i just made my own little server that accepted a POST submission and made a wee greasemonkey script that used jQuery.ajax(). the scrobble protocol was unnecessary
17:08:43 <edwardk> mangaba_leitosa: instance Monad Tree where return = Single; Empty >>= _ = Empty; Single a >>= f = f a; Node l r >>= f = Node (l >>= f) (r >>= f)
17:08:46 <chrisdone> clint: yeah, that's here: https://github.com/chrisdone/blah i don't even have a name for it yet =p
17:08:46 <Clint> oh, i see
17:09:09 <edwardk> node you can take a tree and >>= it to a function that takes a value and builds a tree
17:09:15 <Clint> chrisdone: ok, thanks
17:09:17 <edwardk> er now you can
17:09:32 <spaceships> edwardk: (>>=) = fmap?
17:09:39 <edwardk> spaceships: (>>=) = bind
17:09:41 <edwardk> (<$>) = fmap
17:09:49 <chrisdone> clint: if you want the script i can paste it too. let me know if you need help setting it up. it's not polished ready for consumption but it works
17:09:51 <spaceships> i meant in that case, sorry.
17:09:57 <ciaranm> (<$>) looks like a spaceship
17:10:04 <spaceships> it is awfully cute
17:10:34 <edwardk> spaceships: (>>=) and fmap differ a bit notice, that Single a >>= f = f a   but fmap f (Single a) = Single (f a)
17:10:39 <mangaba_leitosa> edwardk: thanks, will try to apply this now
17:10:50 <spaceships> edwardk: ah okay\
17:11:05 <Clint> chrisdone: nah, i'm not much into in-browser audio
17:11:28 <edwardk> :t (>>=)
17:11:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:11:30 <edwardk> :t (<$>)
17:11:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:11:52 <edwardk> you can make them look a little more alike by using
17:11:55 <edwardk> :t (=<<)
17:11:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:12:14 <chrisdone> clint: gotcha. well i can add a scrobble server to it with the scrobble library, it'd be only a few lines, if you're interested in using it too
17:13:00 <chrisdone> clint: probably the hardest bit is getting whatever music player you like to use to use another server other than last.fm. some are configurable (e.g. quod libet), some are PITAs (clementine required me to recompile the liblastfm library iirc)
17:13:32 <Clint> chrisdone: yeah, i'd be interested.. client-side is not a problem; i use zomg and mpdscribble
17:14:49 <chrisdone> clint: so with those you can specify http://localhost:1234 or w/e to scrobble to?
17:15:14 <Clint> chrisdone: yeah, i actually submit to several different servers "simultaneously"
17:15:49 <chrisdone> gotcha. which of those is most light-weight? i'll use it for testing
17:16:05 <chrisdone> you submit to lastfm and librefm i guess?
17:16:32 <Clint> yeah
17:16:38 <Clint> zomg is more lightweight but could be a pain in the ass to use
17:17:14 <Clint> mpdscribble requires you to have an mpd server
17:18:34 <chrisdone> hmm, k. i'll go quodlibet for now
17:24:08 <mangaba_leitosa> aha, so I came up with Node (Tree a) (Tree a) (Tree a) to be able to label a node yet use a Tree value for this purpose
17:24:29 <mangaba_leitosa> now will try to apply the monad instance :-)
17:27:21 <chrisdone> Clint: did you install the scrobble package?
17:29:58 <chrisdone> Clint: please try running "scrobble-server 6666" and configure your music player to also submit to http://localhost:6666/ username/pass whatever, doesn't matter. you should see output like:
17:29:59 <chrisdone> New session: Session {sesHandshake = True, sesVersion = "1.2", sesClientId = "qlb", sesClientVer = "0.10.1", sesUser = "chrisdone", sesTimestamp = 2013-09-20 00:28:31 UTC, sesToken = "192405d385b6ce95e202cd1e6fd2dbe9"}
17:29:59 <chrisdone> Now playing: NowPlaying {npArtist = "Fleetwood Mac", npTrack = "Rhiannon", npAlbum = Just "The Very Best of Fleetwood Mac", npLength = Just 227, npPosition = Just 8, npMusicBrainz = Nothing}
17:30:03 <mm_freak> i'm impressed…  Sing seems to have zero cost
17:31:06 <chrisdone> clint: to confirm that it works =)
17:33:27 <mm_freak> hah!
17:33:57 <mm_freak> previously i used to write this type:  data Mod n = Mod { modulus :: Integer, residue :: Integer }
17:34:19 <elliott> reflection can do that with about the same overhead.
17:34:24 <elliott> as Sing, that is.
17:34:34 <mm_freak> a few minutes ago i tried this:  data Mod n = Mod { modulus :: Sing n, residue :: Integer }
17:34:39 <mm_freak> turned out to have exactly the same cost
17:34:45 <mm_freak> but now comes the really surprising thing
17:34:54 <mm_freak> newtype Mod n = Mod { residue :: Integer }
17:34:58 <mm_freak> is even faster than the other two
17:35:16 <mm_freak> so using fromSing (sing :: Sing n) is actually better than having the box around the number
17:37:01 <mm_freak> elliott: reflection has a small cost…  that's basically why i used the caching
17:37:15 <mm_freak> you notice the cost when performing a heavy operation like (^) with a large exponent
17:38:51 <edwardk> mm_freak: Sing and reflection should have the same cost
17:39:01 <edwardk> interesting that your experience differs
17:39:21 <zomg> > zomg is more lightweight but could be a pain in the ass to use
17:39:22 <lambdabot>   <hint>:1:46: parse error on input `in'
17:39:23 <zomg> Wut.
17:39:26 <mm_freak> edwardk: 'fromSing sing' seems to be a no-op…  perhaps there is some optimization at work here
17:40:02 <mm_freak> edwardk: type literals are more convenient anyway…  i'll still use reflection for stuff other than strings and nats
17:40:05 <elliott> reflection's cost should be one-time
17:40:16 <edwardk> mm_freak: note you get reflection for type literals =)
17:40:20 <elliott> you can use type literals with reflection
17:40:40 <edwardk> 5 `Reifies` Int
17:40:47 <elliott> you can even make Foo $(5) work to be portable to pre-typelits versions
17:41:02 <mm_freak> when would i use them together?
17:41:23 <mm_freak> (ignoring portability for now)
17:41:48 <edwardk> i use it to enable you to use the same type, say, HyperLogLog n    with a literal when you know it at compile time, and with a reified Int when you don't know it at compile tim
17:42:04 * ski . o O ( `deriving Differentiable T' )
17:42:06 <mm_freak> makes sense
17:42:15 <edwardk> i similarly use it with a modulus for a galois field, which is very similar to your usecase
17:42:25 <edwardk> hence why your statement about the performance difference troubles me
17:42:48 <Clint> chrisdone: Now playing: NowPlaying {npArtist = "Johnny Cash", npTrack = "Highway Patrolman", npAlbum = Just "The Very Best of Johnny Cash: Walk the Line", npLength = Just 320, npPosition = Nothing, npMusicBrainz = Just "5457616f-77bc-4e84-9e10-8926249222f2"}
17:42:52 <mm_freak> edwardk: i didn't actually compare to reflection
17:42:57 <edwardk> whew
17:43:09 <edwardk> i feel better then
17:43:21 <edwardk> because we went and tried damn hard to erase all the overhead! =)
17:43:22 <mm_freak> edwardk: i merely noticed that it's safe to use Sing instead of the value itself =)
17:43:29 <mm_freak> (for performance)
17:43:52 <mm_freak> furthermore i noticed that fromSing sing is very cheap
17:43:57 <edwardk> sure
17:44:00 <mm_freak> which i didn't really expect
17:44:02 <edwardk> sing is the dictionary, so its just a value
17:44:28 <edwardk> when you have a dictionary with one member and no superclasses it has a trivial representation as its only inhabitant
17:44:37 <edwardk> this is the same observation we use for reflection
17:44:54 <mm_freak> edwardk: is that one of the cases when you actually want to write a Reifies instance?
17:44:55 <elliott> edwardk: hmm, can we construct an evil Natural-kinded type using reflection?
17:45:00 <elliott> one that doesn't correspond to any actual natural.
17:45:04 <elliott> I guess it'd just end up being Any.
17:45:40 <edwardk> mm_freak: well, i write a few Reifies instances here and ther. like the one that lifts type-nats to Reifies n Int
17:46:03 <edwardk> and whenever i want to export a constant knowable thing into the global scope
17:46:06 <chrisdone> clint: excellent. once the track ends you'll get "Listened"
17:46:19 <edwardk> and there are instances that are used by $(n)  on old ghcs
17:46:28 <chrisdone> clint: so then it looks like i should add a scrobble server to 'blah' =)
17:46:50 <Clint> i'm not saying that you shouldn't
17:46:56 <edwardk> there are also instances provided inside of lens that are used to mak a typeable form of Reflection that can be used to define a custom Handler for Control.Exception.Lens
17:47:13 <elliott> edwardk: how do we do that with new typeable?
17:47:15 <edwardk> that was necessary because of the Typeable changeover and the Control.Exception API
17:47:18 <elliott> I never got around to asking.
17:47:22 <edwardk> elliott: slow path + Typeable
17:47:25 <mm_freak> edwardk: alright…  previously it felt wrong to write Reifies instances
17:47:34 <mm_freak> but i guess for type literals it's appropriate
17:47:34 <elliott> edwardk: hmm, what do you mean?
17:47:36 <edwardk> mm_freak: i don't feel guilty about them =)
17:47:51 <elliott> Reifies instances are good.
17:47:59 <edwardk> elliott: its the same code as the old slow path, just with Typeable instances added to them all
17:48:04 <chrisdone> clint: yeah i know? you're saying i *should*! what i wanted to confirm was that the scrobble library actually worked with your music player. i guess they're all using liblastfm anyways, so that's good =)
17:48:12 <edwardk> and with a reifyTypeable   that also lets you know the 's' is Typable.
17:48:38 <elliott> edwardk: yuck
17:48:40 <edwardk> reifyTypeable :: Typeable a => a -> (forall s. (Typeable s, Reifies s a) => Proxy s -> r) -> r
17:48:47 <elliott> can't we do that with the fast path?
17:48:50 <edwardk> elliott: it is the only way to make it work
17:48:53 <Clint> chrisdone: Listened and next NowPlaying confirmed.. and no, zomg uses wget
17:48:53 <edwardk> nope
17:49:05 <edwardk> because we can't make up a whole type that is Typeable.
17:49:09 <elliott> edwardk: also, doesn't that cause issues if pointers ever get reused?
17:49:28 <chrisdone> clint: woot!
17:49:49 <edwardk> the Typeable constraint is never used except to silence some guts in Control.Exception
17:49:50 <Clint> i'll package scrobble up for debian a bit later
17:49:58 <chrisdone> cool! =)
17:50:10 <edwardk> we never remarshal something with that type
17:50:23 <edwardk> so we can't have to catch with it
17:50:48 <elliott> hmm.
17:51:41 <edwardk> it exists because there is sort of a secret side-channel in Exception that is used to catch by the Typeable instance, as basically SomeException is Dynamic in disguise with an extra Show constraint
17:52:00 <MitchellSalad> hi all, i'm trying to format console output using Text.PrettyPrint: http://lpaste.net/93189
17:52:05 <elliott> I know that much :)
17:52:06 <edwardk> but we only need a legal Typeable instance for our type.
17:52:27 <edwardk> i could in theory use something more like Given to force a local type to have the instance i want it to, etc.
17:52:30 <edwardk> but this was less bad
17:52:33 <MitchellSalad> unfortunately "sizedText" obviously does not do what I think it does -- is there another way?
17:52:46 <edwardk> and its only ever used when making a custom handler from a fold
17:53:49 <mangaba_leitosa> edwardk: sorry, I got distracted... So, I created the Monad instance and now I can do e. g. 'Leaf 1 >>= return . (+ 10)'. But how can it help me to write a function like 'replace all (Leaf 10) with (Node (Leaf 11) (Leaf 12) (Leaf 13))'?
17:54:44 <edwardk> mangaba_leitosa: t >>= \ x -> if x == 10 then Node (Leaf 11) 12 (Leaf 13) else return x
17:55:11 <mangaba_leitosa> edwardk: and I apply it using fmap?
17:55:17 <edwardk> mangaba_leitosa: no that applied it
17:55:22 <edwardk> see the t >>=  at the front
17:55:26 <edwardk> t was the starting tree
17:55:34 <mangaba_leitosa> or really :-) trying now
17:56:25 <mangaba_leitosa> edwardk: why, that's works!!! thanks a lot!!
17:56:30 <edwardk> mangaba_leitosa: np =)
17:56:56 <mangaba_leitosa> edwardk: before, I had to write recursive function for manually traversing all Nodes and Leafs
17:57:11 <edwardk> mangaba_leitosa: (>>=) is that bundled up once and for all
17:58:00 <mangaba_leitosa> edwardk: and since I use tree only as an example to figure out the approach, the recusrive function for my actual type was very long with copy/paste for each type constuctor
17:58:06 <edwardk> mangaba_leitosa: this is commonly referred to as the observation that 'monads are about substitution' (and renormalization)
17:58:33 <mangaba_leitosa> edwardk: my actual type is Term for a built-in prolog interpreter, so it has predicates, atoms and lists
17:58:37 <edwardk> the monad we have here is 'free', so it has no renormalization step
17:59:00 <mangaba_leitosa> edwardk: and I need the transformation that you helped me to figure out to bind variables to values (other terms)
17:59:51 <edwardk> mangaba_leitosa: https://www.fpcomplete.com/user/edwardk/bound talks about how to write capture avoiding substitution using Monad and Traversable and some helpers from a library of mine, but it may be a bigger jump than you're ready for if you're just getting started
18:00:07 <mangaba_leitosa> edwardk: the current implementation has a long 'case' statement to apply variable binding recurively for Lists, Predicates etc... it was very annoying
18:00:10 <edwardk> mangaba_leitosa: it has been used to drive a datalog and prolog before
18:00:18 <mangaba_leitosa> edwardk: thanks!
18:01:21 <mangaba_leitosa> edwardk: no I will just write this >>= call to traverse the entire program tree in one step :_)
18:01:38 <edwardk> https://github.com/deviant-logic/hokeylog is a small datalog implementation you may want to explore as well
18:02:02 <mangaba_leitosa> s/no/now/
18:02:09 <edwardk> hah
18:02:43 <mangaba_leitosa> edwardk: will check those links out :-)
18:02:53 <edwardk> as you progress, the observation that your expression type is free leads to other insights about how to make the interpreter more efficient as well.
18:03:15 <edwardk> http://www.iai.uni-bonn.de/~jv/mpc08.pdf talks about how, and i have several blog posts on the topic on comonad.com
18:03:30 <edwardk> but don't get lost in them just now, just know the rabbit hole goes deeper =)
18:04:03 <mangaba_leitosa> edwardk: and what does 'capture-avoiding substituion'?
18:04:07 <mangaba_leitosa> mean
18:05:26 <edwardk> if you have the expression \x -> \ y -> z         and you go to substitute in z = y    then if you expand that to \x -> \y -> y you 'captured' a name that was bound locally that should have been irrelevant. it should expand to \x -> \w -> y  -- renaming the local y out of th way
18:05:44 <edwardk> this is one of the common mistakes with naive substitution
18:06:11 <mangaba_leitosa> aha...
18:06:13 <haasn> @hoogle [Bool] -> Word8
18:06:13 <lambdabot> Data.List genericLength :: Num i => [b] -> i
18:06:13 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
18:06:13 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:06:18 <tibbe> @tell edwardk remind me to ask you to describe how you do unboxing in your container type
18:06:18 <lambdabot> Consider it noted.
18:06:27 <edwardk> tibbe: here
18:06:29 <haasn> isn't there a neater way to do this than set (partsOf bits) ?? 0
18:06:49 <edwardk> tibbe: if you've got time i can dive into it
18:07:25 <edwardk> tibbe: i'm also going to do a talk on it down in california in october, if nothing else ;)
18:07:51 <tibbe> edwardk: getting off shuttle in a min so we'll have to do it later
18:10:02 <RoboTeddy> does haskell do any automatic memoization? e.g. does (f x) + (f x) evaluate f twice?
18:10:38 <edwardk> RoboTeddy: that will typically get evaluated twice unless it does common subexpression elimination
18:11:15 <edwardk> iirc, ghc doesn't really try all that hard or at all for CSE
18:12:57 <jmcarthur> RoboTeddy: well, actually, the answer to the question as worded is literally "no, f will only be evaluated once." however, "f x" occurs twice and therefore will be evaluated twice, unless, as edwardk pointed out, ghc does CSE to it
18:13:25 <RoboTeddy> edwardk, jmcarthur: OK, thanks
18:14:40 <mangaba_leitosa> edwardk: I'm going to bed now, thanks again! will take out dozens of [now useless] copy/paste lines from my variable resolution function :-)
18:14:56 <edwardk> =)
18:22:56 <haasn> edwardk: can't figure out a simple lensy way to write ‘unbits’ http://lpaste.net/93190
18:23:32 <edwardk> > 0 & partsOf bits .~ [True,False,True]
18:23:39 <lambdabot>   mueval-core: Time limit exceeded
18:23:41 <edwardk> > 0 & partsOf bits .~ [True,False,True]
18:23:44 <edwardk> > 0 & partsOf bits .~ [True,False,True] :: Int
18:23:45 <lambdabot>   5
18:23:48 <lambdabot>   mueval-core: Time limit exceeded
18:24:19 <haasn> edwardk: the logic is quite specific. The inputs are bits to a 64-bit word, greatest first
18:24:26 <haasn> and it has to be variable-length, too
18:24:32 <haasn> so I can't just ‘backwards/reverse’ and call it a day
18:24:49 <haasn> ‘bits’ and stuff has the least significant bit first
18:24:52 <edwardk> well, then you have a more annoying zip
18:25:05 <haasn> zips are something lens is bad at it seems
18:25:46 <edwardk> > 0 & partsOf (backwards (taking 6 bits)) .~ [True,False,True]
18:25:53 <lambdabot>   mueval-core: Time limit exceeded
18:25:57 <edwardk> > 0 & partsOf (backwards (taking 6 bits)) .~ [True,False,True] :: Int
18:25:59 <lambdabot>   40
18:26:10 <edwardk> > 0 & partsOf (backwards (taking 6 bits)) .~ [True] :: Int
18:26:12 <lambdabot>   32
18:26:19 <edwardk> > 0 & partsOf (backwards (taking 6 bits)) .~ [False,True] :: Int
18:26:20 <lambdabot>   16
18:26:24 <edwardk> like that?
18:27:01 <haasn> oh, ‘taking’ works on traversals too
18:27:06 <edwardk> yep
18:27:26 <haasn> yeah I thought of something like that but thought it wouldn't work (I actually just realized that I tested with folded instead of traversed, no wonder it didn't work)
18:27:50 <edwardk> heh
18:29:14 <haasn> http://lpaste.net/6413523433023340544
18:29:16 <haasn> now fully lens-approved
18:29:24 <jhickner> I often use a function like this: "mwhen m f = maybe (return ()) f m". Is there something like this in the standard libs already?
18:30:02 <shachaf> jhickner: Data.Traversable.forM_
18:30:10 <shachaf> Hmm, no. Data.Foldable.
18:30:25 <monoidal> :t \m f -> maybe (return ()) f m
18:30:27 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
18:30:55 <jhickner> ok thanks, I'll check that out
18:31:26 <haasn> edwardk: oh, I can make it even lensier by fusing the ‘enc’ into the fold
18:31:33 <haasn> and using ‘view’ instead of toListOf
18:31:34 <haasn> perfect!
18:31:42 <haasn> less parens that way, too
18:33:32 <edwardk> partsOf . backwards $ taking 6 bits  -- is much happier making
18:34:05 <edwardk> but cute
18:34:07 <haasn> good point, 2 less chars
18:35:37 <haasn> edwardk: http://lpaste.net/93191 even more reduced!
18:35:46 <haasn> not quite a one-liner yet
18:36:18 <edwardk> clearly we need to make an _Bits prism or something
18:36:40 <haasn> _Base64
18:36:44 <edwardk> that too
18:36:56 <edwardk> or just upgrade base to go out to 64 ;)
18:37:36 <haasn> Won't have the same semantics either way
18:37:38 <edwardk> not a terribly serious proposal, as it would have pretty awkward encoding changes
18:37:39 <edwardk> yeah
18:39:25 <haasn> now all that's missing is the inverse base64dec :: String -> Maybe ByteString and we'll have ourselves a fully working Prism'
18:40:34 <elliott> edwardk: are we going to rename base to _Base?
18:40:41 <edwardk> =(
18:40:47 <edwardk> that would make me sad
18:40:52 <haasn> me too
18:40:53 <edwardk> maybe eventually though
18:40:53 <elliott> hey, it's your convention.
18:40:59 <edwardk> its shachaf's convention
18:41:15 <haasn> I thought _ followed by uppercase is used for prisms that directly correspond to constructors
18:41:17 <haasn> like _Just
18:41:21 <elliott> haasn: _Cons
18:41:22 <edwardk> i hated it at first, but he browbeat me into it
18:41:22 <haasn> But then again, we use it for stuff like _Cons
18:41:24 <haasn> yeah
18:46:11 <shachaf> help
18:58:06 <joelteon> how should I debug infinite loops I can't track down?
18:58:38 <mm_freak> why doesn't GHC.TypeLits provide the usual Num interface for Nat?
18:59:04 <haasn> mm_freak: what are you trying to do?
18:59:23 <mm_freak> haasn: i'm doing a few number theory tests
19:00:15 <haasn> I don't follow why you need an instance Num Nat
19:00:21 <sclv> joelteon: one approach is to use debug.trace
19:00:33 <sclv> another is to use profiling
19:00:42 <haasn> Nat doesn't even have any constructors does it
19:00:46 <sclv> you can run until you loop, kill out of the loop
19:00:54 <sclv> then look at your .prof file and see where it was spinning
19:00:56 <mm_freak> haasn: firstly since Nat can't be negative its operations could be much faster, secondly i don't really see a reason why not
19:01:16 <joelteon> ok
19:02:17 <mm_freak> for example Integer multiplication needs two branches just for handling the negative cases
19:02:17 <mm_freak> which can be a waste
19:02:23 <joelteon> this is a yesod site, is profiling still gonna be effective?
19:02:24 <haasn> well Nat is for type-level naturals. It doesn't have any constructors or other useful things associated with it on the value level, though you can use fromSing to get a static Integer out of it
19:02:26 <sclv> joelteon: also make sure to compile with all warnings
19:02:32 <mm_freak> well, actually multiplication doesn't, but addition does
19:02:33 <joelteon> because to get to the loop, I have to start the app and try to upload an image
19:02:50 <mm_freak> haasn: Nat is also a perfectly fine type
19:02:52 <sclv> if its something stupid like referring to x instead of x'
19:02:59 <sclv> then you might get an unused variable warning
19:02:59 <joelteon> ok
19:03:16 <sclv> yeah profiling still works -- depending on how you kill out of the loop you might not get a usable profile is the only problem.
19:03:17 <haasn> mm_freak: which Nat are you referring to? This one http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-TypeLits.html#Nat
19:03:22 <mm_freak> haasn: yes
19:03:35 <joelteon> yeah, profiling is a massive pain is the thing
19:03:37 <sclv> so most reliably you need to send that thread an async exception then shut down the app prpoperly
19:03:46 <sclv> then traces probably work fine :-)
19:04:01 <mm_freak> haasn: let me put it this way:  withNat :: Nat -> (forall (n :: Nat). Proxy n -> r) -> r
19:04:09 <sclv> toss enough in and you'll see soon enough where things stop happening
19:04:11 <mm_freak> haasn: it's just stupid to have to use Integer there
19:04:50 <elliott> I am baffled. isn't Nat a kind, not a type?
19:04:59 <haasn> elliott: both, technically
19:05:00 <elliott> it says so right there.
19:05:12 <joelteon> sclv: ok, it still builds with Werror
19:05:13 <elliott> haasn: I think that's just a weirdness of GHC.
19:05:16 <shachaf> * is kind of a type.
19:05:17 <joelteon> so i guess it's time to start profiling
19:05:24 <sclv> now -Werror, -Wall
19:05:29 <sclv> to make sure you get all warnings
19:05:43 <sclv> s/now/not
19:05:53 <joelteon> yeah, using both
19:05:58 <joelteon> still builds
19:06:02 <sclv> ah, nevermind then:-)
19:06:06 <mm_freak> elliott: GHC could make Nat not look much different from any other promoted type
19:06:40 <mm_freak> currently it works only as a kind, but i argue that there should be a corresponding type Nat
19:06:43 <joelteon> but now i get to build yesod with profiling
19:06:45 <joelteon> woohooooo
19:06:52 <mm_freak> with more efficient unsigned arithmetic operations
19:11:08 <haasn> mm_freak: I'm not sure how that function would even be implemented :: Nat -> (forall (n :: Nat). Proxy n -> r) -> r
19:11:42 <haasn> seems like it requires compiler magic to me
19:12:28 <mm_freak> haasn: reflection
19:12:37 <mm_freak> it's missing a Reifies constraint though
19:12:47 <haasn> oh, yes
19:12:50 <haasn> makes sense with reflection
19:27:04 <augur_> what is Proxy n
19:27:19 <augur_> haasn: ^
19:29:32 <haasn> Data.Proxy.Proxy?
19:43:44 <shachaf> Control.Lens.Lens.Lens
19:44:34 <ion> > intercalate "." ("Control" : repeat "Lens")
19:44:35 <lambdabot>   "Control.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.Lens.L...
19:45:44 * hackagebot push-notify 0.1.0.0 - A server-side library for sending push notifications.  http://hackage.haskell.org/package/push-notify-0.1.0.0 (MarcosPividori)
19:57:46 <osa1> do we have any tutorials for this http://hackage.haskell.org/package/derive ?
20:00:38 <argiopeweb> osa1: You checked its home page, yes?
20:00:41 <osa1> I have some data type declarations and I want to make them instances of a class. This class is similar to Show but with some differences, most generation part are syntax-driven, i.e. it should be possible to derive instances with a program. is there a way to do this using TemplateHaskell or do I need to use "derive" like tools
20:00:45 <osa1> argiopeweb: yep
20:02:21 <argiopeweb>  I want to say Derive is just a collection of TH wrappers, so it might be easiest to use the code as an example and roll your own. On the other hand, I could be totally off my rocker.
20:02:53 <argiopeweb> I have an informative prior that implies the latter.
20:14:16 <ParahSail1n> hm, Text.Printf.Mauke.TH seems safe
20:24:28 * haasn aspires to one day have a module named after him
20:30:26 <shachaf> It's not very difficult.
20:41:44 <joelteon> ok, this is the profiling output I get when trying to debug the infinite loop in my yesod app: http://i.joelt.io/joelteon.prof.txt
20:41:48 <joelteon> it doesn't seem very helpful to me
20:43:03 <argiopeweb> That's a lot of 0's...
20:43:18 <joelteon> yes, it's a lot of zeros
20:43:55 <argiopeweb> Apparently lots of zeroes sums to 100 now.
20:43:57 <joelteon> maybe i should strace
20:44:40 <ParahSail1n> is it a limitation of the type system that TH needs to be used to make a type-safe printf?
20:44:43 <argiopeweb> Possibly. That doesn't seem like a complete profile though.
20:45:02 <joelteon> strace is useless
20:45:11 <joelteon> how do i make a complete profile?
20:45:43 <enthropy> ParahSail1n: no, but the format strings are slightly uglier if you don't use TH
20:45:46 <argiopeweb> joelteon: It should Just Work...
20:45:48 <enthropy> @hackage xformat
20:45:48 <monoidal> ParahSail1n: if you allow an ugly version of the string, it is possible
20:45:49 <joelteon> yeah it should
20:46:00 <lambdabot> http://hackage.haskell.org/package/xformat
20:46:20 <argiopeweb> joelteon: But still, there should be some calling function above encode and >>=
20:46:49 <argiopeweb> joelteon: How did you compile?
20:47:02 <joelteon> cabal install --enable-library-profiling --enable-executable-profiling
20:47:35 <argiopeweb> And ran with +RTS -p. Hmmm...
20:47:37 <ParahSail1n> i have no idea whats going on in xformat
20:48:06 <haasn> ParahSail1n: that module desperately needs some usage examples
20:48:19 <ParahSail1n> glad its not just me
20:48:47 <ParahSail1n> ill probably be using that TH printf just because its concise
20:48:48 <argiopeweb> joelteon: It's possible some of the dynamic reloading stuff in Development is messing with the profiling report. Can you try Release (or one of the other non-Development options)?
20:48:55 <joelteon> sure
20:49:15 <argiopeweb> ParahSail1n: Doesn't Text.Printf do compile time checks?
20:49:40 <argiopeweb> (TH under the hood, of course, but it's pretty standard from my understanding)
20:49:43 <ParahSail1n> argiopeweb, nope
20:49:49 <argiopeweb> Ich.
20:51:16 <haasn> ParahSail1n: digging through the haddock, looks like the usage is eg. showf ("hello " :%: Show :%: " world") 3
20:51:26 <joelteon> argiopeweb: http://i.joelt.io/joelteon.prof.staging.txt
20:51:28 <joelteon> looks the same
20:51:29 <haasn> or s/Show/Int/ if you want to accept an Int in that position
20:51:47 <haasn> it lists a few format descriptors and you can make your own
20:52:42 <haasn> ParahSail1n: showf (Align R 8 Num) 0.12  ==>  "    0.12"
20:52:56 <argiopeweb> joelteon: Indeed. I'm not sure what to tell you. Perhaps some of the folks in #yesod would have some tips on how they profile.
20:53:16 <ParahSail1n> argiopeweb, Text.Printf checks if all of the arguments you feed it are possible valid types, it just doesnt care which ones, or how many
20:54:04 <argiopeweb> ParahSail1n: Well, I suppose something's better than nothing...
20:54:09 <ParahSail1n> haasn, ah
20:54:26 <argiopeweb> And printf is more than a bit of a trick to do properly.
20:54:40 <ParahSail1n> haasn, but at that level of verbosity, i might as well use ++ and show
20:54:55 <t4nk329> hi
20:54:59 <ParahSail1n> argiopeweb, Text.Printf.Mauke.TH does it properly, just requires TH
20:55:12 <haasn> ParahSail1n: I guess so
20:55:16 <t4nk329> doubt in program
20:56:16 <ParahSail1n> hm, i suppose TH is not language smell in this instance, its just compile-time code transformation
20:56:38 <argiopeweb> ParahSail1n: Everything's easy when you can evaluate arbitrary code (from the compiler's viewpoint) at compile time!
20:57:14 <ParahSail1n> haasn, and for runtime, i guess the type system allows for safe "variadic" stuff in xformat
21:10:44 <ParahSail1n> @hoogle pipes-http
21:10:44 <lambdabot> No results found
21:12:23 <Shin-LaC> lpaste gives me some warnings that I don't get from ghci
21:12:29 <Shin-LaC> e.g. "redundant bracket"
21:12:33 <Shin-LaC> how do I get them locally?
21:12:37 <ReinH> Shin-LaC: hlint
21:12:43 <ReinH> and -Wall of course
21:12:45 <Shin-LaC> thanks
21:32:24 <carter> latermuse: np
21:32:29 <carter> nothing may happen mind you
21:35:07 <td123> I'm writing bindings to a c library, and I have a function called char * error_message(int code) which converts a code to a text representation of an error message
21:35:38 <td123> my question is, would it be a good use case for unsafePerformIO
21:36:08 <johnw> yes
21:36:17 <johnw> that's kind of what it was intended for
21:36:48 <johnw> by using unsafePerformIO, you're essentially declaring that the C function really is pure, even if IO is required to call it
21:37:00 <td123> right, so long as it doesn't do any memory changes, it's ok to use performIO
21:37:29 <td123> thanks
21:38:19 <elliott> td123: you can just omit the IO in the return type too with the ffi
21:38:24 <elliott> which constitutes an assertion of purity.
21:39:17 <td123> elliott: cool, thanks for the tip
21:39:19 <carter> td123: what elliott  said
21:39:25 <carter> the haskell ffi is greeatttt
21:40:12 <td123> my current implementation of these bindings includes a thin wrapper around the c lib, and then another library providing a haskell interface which really just means translating the types to haskell types
21:40:52 * hackagebot pipes-bytestring 1.0.0 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-1.0.0 (GabrielGonzalez)
21:41:25 <td123> carter: and I agree, the hs ffi is quite painless once you learn it
21:41:50 <td123> although I would argue some more resources for people wanting to learn might be nice :)
21:42:35 <carter> true
21:42:53 <carter> otoh: comfy with c and comfy with haskell and wanting ot mix em means you're pretty comfy at learning already!
21:46:19 <MedDev> td123, make those resources then! please do
21:52:01 <haasn> the FFI is mainly as painful as the underlying C APIs are, which tends to be very much in my experience
21:52:23 <johnw> i find FFI pretty straightforward
21:52:51 <johnw> but it's also one of the only ways I'm able to get a Haskell executable to core dump
21:53:20 <MedDev> or reliably segfault :) "doc it hurts when i do this. well don't do that"
21:57:49 <carter> johnw: that or tasteful unsafe coerce
21:58:20 <carter> johnw: i'm sad that my  crazy :: a -> Int# crashed so easily
22:09:30 <t4nk329> hi guys
22:09:45 <t4nk329> can someone help me in a program i got
22:10:17 <elifrey> t4nk329: i'm sure
22:11:04 <sleepynate> is it like a baseball program? show you who the players are?
22:13:37 <shachaf> elifrey looks way too much like elliott
22:15:41 <haasn> shachaf: b-but they have different colors
22:17:10 <elifrey> in shachaf-lang, comparison is lazy. If the first two elements of a compound datatype are the same, it just compares length and calls it good :P
22:18:09 <dalaing> there was a Windows networking security flaw a few years back where only the first 3 characters of a password were being used in the check
22:18:35 <shachaf> You know what compound interest is? Yes, well, jolly good thing to enjoy, compound interest. Well, that's the sort of thing a compound is.
22:18:39 <dalaing> truncated comparisons are being used in production!
22:18:47 <elifrey> dalaing: I am crying happy tears
22:19:40 <kazagistar> that sounds terrible
22:19:58 <mmutuyu> what r u guys talking about
22:20:45 <dalaing> I think we're all just waiting for t4nk329 to tell us more about the program he or she wants help with
22:21:11 <shachaf> Eh. I don't know much about baseball.
22:21:13 <dalaing> my face has gotten itchy at the mere thought of procrastotunity
22:21:18 <joelteon> christ this is frustrating
22:21:24 <joelteon> haskell sucks for debugging
22:21:51 <elifrey> joelteon: yeah but |
22:22:08 <elifrey> join traceShow| is fun to write
22:22:18 <elifrey> :t join traceShow
22:22:18 <lambdabot> Not in scope: `traceShow'
22:22:47 <elifrey> drats
22:23:04 <elifrey> :t join Debug.Trace.traceShow
22:23:05 <lambdabot> Show a => a -> a
22:24:10 * haasn wonders why exactly traceIO uses debugBelch in GHC, and more importantly, what debugBelch is/does
22:24:13 <kazagistar> debug? I thought the type system prevented bugs
22:24:23 <haasn> the type system can't prevent all bugs
22:32:41 <johnw> shachaf: I think the correct Par instance for Comonad would be extend f m = get =<< spawn (return (f m)), except that this would need a restricted Comonad, since there is an NFData constraint on the return value
22:47:09 <tko> Are there any accelerate tutorials? I did a quick google search and didn't seem to find any
22:47:22 <johnw> Marlow's new book discusses it and shows examples
22:47:52 <shachaf> He also has slides.
22:48:20 <shachaf> Slides at http://community.haskell.org/~simonmar/
22:49:50 <tko> I guess this gives me an excuse to buy the book. Thanks
22:54:45 <haasn> You can read the book for free online
22:55:11 <haasn> tko: http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
22:56:18 <tko> haasn: thank you, but I think Ill buy it
22:56:34 <ParahSail1n> @src traceShow
22:56:34 <lambdabot> Source not found. :(
23:12:22 <elifrey> @src Debug.Trace.traceShow
23:12:22 <lambdabot> Source not found. My pet ferret can type better than you!
23:14:13 <shiona> @hoogle traceShow
23:14:13 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
23:14:48 <FreeFull> traceShow = trace . show
23:16:46 <tearful> I am new to conduits and am having trouble understanding how to properly read a file as a source and then manipulate the contents. Could anybody point me to an example of this?
23:18:36 <adnap> If a package exports a type with a Monad instance but no Functor or Applicative instance, can I automatically dervie them. If so, how?/
23:22:26 <arkeet> adnap: I don't think so.
23:22:32 <arkeet> maybe WrappedMonad would work for you though.
23:25:28 <Dacto> Anyone use haskellmode with (g)vim and has run into "Error detected while processing C:\Program Files (x86)\Vim\vimfiles\ftplugin\haskell_doc.vim:" which doesn't give any line numbers or other useful information?
23:26:18 <adnap> I wonder if I'm allowed to use bind in a Functor instance if I already have a Monad instance.
23:26:44 <ion> sure
23:27:31 <johnw> when you're writing the Functor instance, you're working with the concrete type, so you can do anything that that type allows; it's users of "Functor f => f a" that only know about fmap
23:27:53 <adnap> Well, here we go then: fmap f m = m >>= (\x -> return (f x))
23:28:10 <johnw> why not just fmap = liftM?
23:28:20 <adnap> I didn't think of that
23:28:26 <adnap> Thanks
23:29:09 <johnw> it's mainly the same as what you wrote:
23:29:11 <johnw> @src liftM
23:29:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:29:25 <ion> s/mainly //
23:29:36 <johnw> well, modulo sugaring :)
23:29:46 <adnap> semantically but not syntactically?
23:30:08 <johnw> exactly
23:32:01 <arkeet> fmap = liftM; pure = return; (<*>) = ap
23:32:13 <adnap> Is there any relationship between the defintion of "modulo" and modular arithmetic?
23:32:29 <adnap> Or the modulo operator
23:32:32 <arkeet> modular arithmetic ignores multiples of n.
23:32:39 <arkeet> differences by multiples of n.
23:32:47 <arkeet> modulo sugaring ignores differences in sugaring.
23:32:49 <arkeet> :p
23:33:19 <arkeet> see: http://en.wikipedia.org/wiki/Up_to
23:33:24 <adnap> http://www.thefreedictionary.com/modulo: "Correcting or adjusting for something, as by leaving something out of account"
23:33:38 <arkeet> no, just read this.
23:33:50 <johnw> I meant it in the sense of "if you take sugaring out of the picture, the two definitions are identical"
23:34:00 <johnw> or, "they are identical up to sugaring"
23:34:13 <arkeet> yes.
23:34:15 <adnap> I understood you
23:34:32 <ion> and alpha equivalence :-P
23:34:44 <arkeet> it's all the same, just that the equivalence relation is different.
23:36:56 <adnap> Can someone do prettier than this: f <*> x = f >>= (\g -> fmap g x)
23:37:21 <johnw> arkeet: could I also say the definitions are members of the same quotient set?
23:37:33 <johnw> if I quotient over sugaring
23:37:38 <arkeet> they become the same in the quotient.
23:37:47 <scshunt> adnap: is the fmap lifting into the monad?
23:37:52 <arkeet> (the thing you said is sort of trivial/meaningless.)
23:37:59 <dolio> f >>= (`fmap` x)
23:38:00 <johnw> ok
23:38:02 <adnap> scshunt: I don't know what you mean
23:38:02 <johnw> i'm new to quotients
23:38:15 <arkeet> quotient set = set of equivalence classes
23:38:42 <ion> adnap: <arkeet> fmap = liftM; pure = return; (<*>) = ap
23:39:08 <adnap> :t ap
23:39:11 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:39:19 <adnap> Oh, neat
23:39:23 <adnap> @src ap
23:39:23 <lambdabot> ap = liftM2 id
23:39:38 <adnap> That's...
23:39:46 <adnap> :t liftM2
23:39:46 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:39:47 <arkeet> think of it as liftM2 ($)
23:39:55 <adnap> @src liftM2
23:39:55 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:40:48 <adnap> Ahh
23:40:55 <adnap> > id (+2) 40
23:40:56 <lambdabot>   42
23:47:31 <mrotondo> So, I have a little interactive program with some little circles that move around and I'd like to give them commands like "follow this other guy", or "move to X, pick up Y, and bring it to Z" and I'd like to give those commands with mouse clicks and keystrokes, e.g. select a circle with the mouse, press f for Follow, then select another circle and the first will follow the second. I'd like to represent these commands with partially
23:47:31 <mrotondo> applied constructors, but I'm not sure quite how to represent that with a type/typeclass I could stick in my state. (Total noob here of course). Anyone have a think? Should I be using a reactive library?
23:48:12 <mrotondo> *represent during the intermediate bit of time while I'm giving the command
23:51:07 <arkeet> I like parsers.
23:51:13 <johnw> parsers are pretty awesome
23:51:35 <johnw> they've been my longest love, actually
23:51:44 * arkeet thinks of mrotondo's thing as sort of a parsing problem.
23:52:23 <jgross> Is there a variant of Control.Exception.evaluate that forces the entire expression, and not just the head?
23:52:38 <johnw> jgross: you can use deepseq
23:52:39 <mrotondo> hm! arkeet can you say how so?
23:53:00 <arkeet> mrotondo: you're converting a sequence of inputs into a command, right?
23:53:00 <johnw> evaluate $ force x
23:53:06 <arkeet> (instead of a sequence of characters)
23:53:13 <mrotondo> as in I have a grammar and the type I hold on to would be a possible statement in that grammar?
23:53:15 <mrotondo> right
23:53:24 <arkeet> I have no idea if it's helpful.
23:53:33 <mrotondo> no, I like that
23:54:00 <mrotondo> it lets me store the commands in a general type and figure out what was "said" as a separate step/piece of functionality
23:54:11 <arkeet> :)
23:54:13 <mrotondo> the inputs, that is
23:54:15 <mrotondo> the commands emerge from parsing the inputs
23:54:18 <johnw> if you used pipes, you could build an input -> commands stream, using pipes-parse
23:54:30 <mrotondo> yay, thanks folks :)
23:55:32 <jgross> johnw: "No instance for (NFData Type)"	(Type is "data Type =	  TBase BaseType   | TVar TVar	 | TArrow Type Type   deriving (Eq, Show) ")
23:55:44 <johnw> just do this: instance NFData Type
23:55:52 <johnw> unless you need special behavior, that should suffice
23:57:16 <jgross> johnw: Great, thanks!
23:59:34 <arkeet> mrotondo: I don't know how feedback for partially entered commands would work with that though...
