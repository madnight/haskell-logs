00:02:25 <identity> found the error! thanks shachaf, -xc really helped :)
00:36:55 * hackagebot acid-state 0.12.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.12.0 (DavidHimmelstrup)
01:06:55 * hackagebot vault 0.3.0.2 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.0.2 (HeinrichApfelmus)
01:31:02 <bitonic-work> what's the fastest way of building a bytestring of known width?  I'd probably imagine allocating, modifying, and then packing a CString to be as good as it gets, but maybe there is an easier way
01:31:56 * hackagebot bdo 1.0.0 - Update CSS in the browser without reloading the page.  http://hackage.haskell.org/package/bdo-1.0.0 (ChrisDone)
01:33:39 <nh2> bitonic-work: http://stackoverflow.com/questions/18682527/how-to-convert-between-bytestring-and-storable-vector
01:34:13 <nh2> going the other way around, Ptr, writing, and then putting the constructor around?
01:38:48 <bitonic-work> nh2: yeah, actually `Data.ByteString.Internal.create' seems to be the right thing
01:39:03 <bitonic-work> although an interface through unboxed vectors or something like that would be nicer
01:41:11 <Taneb> You know the whole "cabal is not a package manager" thing? What would a package manager for Haskell libraries actually involve?
01:41:21 <quchen> Taneb: uninstalling
01:42:17 <quchen> (I still think Cabal is a package manager.)
01:42:24 <Taneb> quchen, could writing a Haskell library package manager be something I could manage? (I'm bored and in a useful mood)
01:43:35 <fylwind> i think the difficulty is the fact that it's somewhat platform dependent
01:43:49 <quchen> Taneb: That would be a Cabal modification. I don't know how hard that specific task is. It sounds easy, but on the other hand if it was, then someone would have done it already.
01:44:47 <quchen> (You could also make your own package manager of course, but that would be a giant project - that starts with reinventing Cabal)
01:45:01 <nh2> bitonic-work: I think Unboxed is not as flexible as Storable, you can't get Ptrs to it so it won't go as well with bytestrings and you can't just use it for interfacing with outside
01:45:46 <bitonic-work> nh2: well I wasn't saying it was, I was saying that having an interface of that kind would be nice
01:46:49 <nh2> Taneb, quchen: Just the fact that it's not been done doesn't necessarily make it hard, especially for Cabal. Making profiling and normal compilation run in parallel took 4 lines (and a bit of interleaved output handling), and I've wanted it for years
01:47:23 <quchen> nh2: Hm. Well I guess academia spoiled me in that respect then ;-)
01:48:11 <quchen> nh2: Got a link to the corresponding 4 lines?
01:48:18 <mero> Is there a way to go from [IO String] to IO String by concatenting all the individual strings (Foldable msum throws everything but the last IO action away)?
01:48:32 <quchen> :t mapM concat -- mero
01:48:33 <lambdabot> [[[b]]] -> [[b]]
01:48:44 <quchen> Eh wait
01:48:58 <identity> foldM concat?
01:49:07 <nh2> quchen: https://github.com/nh2/cabal/commit/f33ed21752c49058079690ae21f19de8827a4fce
01:49:12 <quchen> :t fmap concat . sequence
01:49:13 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
01:49:15 <quchen> Better.
01:49:29 <mero> thanks!
01:49:34 <nh2> (I haven't done the interleaved output handling yet, but they are currently making some convenience for that so I'm waiting)
01:49:51 <mstksg> is there any way i can have the cpp pass read from environment variables?
01:50:26 <quchen> nh2: Ah, that's from the GSOC branch that was merged yesterday?
01:50:46 <nh2> quchen: no, that's my custom things
01:51:00 <nh2> oh wait
01:51:01 <nh2> in https://github.com/haskell/cabal/pull/1413
01:51:18 <quchen> nh2: Ah, I see, it's not building dependencies in parallel, but normal+profiling versions.
01:51:24 <nh2> no I don't think it's part of what 23Skidoo has written so far
01:51:26 <nh2> yes
01:51:35 <quchen> nh2: While you're at it, consider adding another parallel build for shared libs.
01:51:54 <Taneb> @type fmap concat . sequence
01:51:55 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
01:52:03 <quchen> :t (fmap concat . sequence) `asAppliedTo` (undefined :: [IO String])
01:52:03 <nh2> quchen: I was refraining from that because I wasn't sure how it will work with 7.8 when shared is default
01:52:04 <lambdabot> [IO [Char]] -> IO [Char]
01:52:23 <quchen> nh2: Shared is default? Didn't know that
01:52:25 <nh2> quchen: this one is much better for daily use though: https://github.com/haskell/cabal/pull/1410
01:52:31 <identity> quchen: Didn't know about asAppliedTo. Thanks
01:52:51 <mstksg> is anyone here currently working with FRP?  is there a library right now that has emerged as canonical?  which ones are popular/strong?
01:53:14 <quchen> identity: It's a Lambdabot convenience function. It's just `const` with a specalized type.
01:53:48 <nh2> mstksg: I would try netwire and reactive-banana now, there have come some great turorials and examples for those in recent days
01:54:36 <nh2> mstksg: e.g. http://jshaskell.blogspot.jp/2012/11/breakout-improved-and-with-netwire.html
01:54:38 <identity> quchen: Yeah I figured it was a lambdabot convenience function, but it's still handy to know :)
01:54:52 <mstksg> nh2: thanks, i'll check it out :)
02:00:52 <johnw> did anyone see my cafe post just now entitled "Please excuse brief service disruption"?
02:01:14 <Fuuzetsu> yes
02:01:19 <johnw> excellent, thanks!
02:01:48 <t7> i lost with 1 brick left
02:01:51 <t7> i suck
02:05:44 <fylwind> t7: me too :( this game is hard
02:13:28 <fylwind> wait, so this whole thing is Haskell compiled into Javascript?
02:19:16 <Cale> fylwind: which thing?
02:19:33 <fylwind> http://jshaskell.blogspot.jp/2012/11/breakout-improved-and-with-netwire.html
02:20:15 <fylwind> I guess he's using UHC
02:20:31 <donri> fylwind: that's using haste, which uses ghc
02:20:43 <fylwind> ah I see
02:20:51 <donri> https://github.com/valderman/haste-compiler
02:21:11 <fylwind> thanks for the link
02:21:18 <Cale> https://rawgithub.com/RudolfVonKrugstein/jshaskell-blog/master/6_BreakoutImproved/code/compiled/BreakoutImproved.js
02:21:22 <Cale> :D
02:22:06 <Cale> It's like "hey, this isn't so bad... oh wait"
02:22:25 <fylwind> yeah I was "inspecting" the page source and saw like a bunch of JS functions named after haskell stuff
02:22:52 <fylwind> and I missed the blob of minified JS
02:23:16 <donri> i'm guessing the first half is the hand-written "RTS"
02:23:30 <quchen> Cale: After you said that I was like "what does Cale mean this code isn't so bad … oh wait"
02:23:40 <quchen> It's a safe bet to assume everyone does that :-D
02:23:57 <quchen> It's a well-hidden abomination, you have to admit that
02:24:37 <artyomkazak> I fell for it too
02:26:02 <donri> i wonder how the ghc rts code compares to -fvia-c output
02:28:16 <nh2> Cale: any advanced javascripter will have no problem debugging that! :P
02:30:57 <Cale> A different style of abomination here: http://hdiff.luite.com/gloss/styrene/out.js
02:34:41 <quchen> Cale: GHCJS is not a fair comparison!
02:36:20 <Hafydd> Hahah!
02:37:10 <MedDev> Hafydd, I love those moments :)
02:47:20 <gbonobb> Hey guys, anyone able to help me setup sublimehaskell, i got a few issues
02:48:00 <Kaini> gbonobb, ask
02:48:21 <gbonobb> i have the same setup on linux and works perfectly but on a windows machine it does not
02:48:33 <gbonobb> not sure whats the problem really
02:48:43 <gbonobb> it just doesnt build the project
02:48:55 <gbonobb> or do any linting
02:49:14 <gbonobb> if i start REPL prelude loads and builds the project
02:49:29 <gbonobb> but when i save the file building never ends and no linting
02:49:45 <gbonobb> in my path i added the bin under the haskell platform
02:50:00 <gbonobb> and also the bin in %APPDATA%
02:50:18 <gbonobb> also in add path in sublime haskell added them both
02:50:37 <Kaini> gbonobb, how did you set your PATH? Notice that you cannot use SublimeHaskell's "add_to_PATH" since it will always separate directories with ":" while Windows would need ";"
02:50:55 <gbonobb> hmm
02:51:12 <gbonobb> i added the path from user variables
02:51:23 <gbonobb> sp that i can use ghci and cabal from command line
02:51:38 <gbonobb> that explains why cabal never builds the project
02:51:46 <Kaini> and you can invoke hlint from command line as well?
02:51:48 <gbonobb> it cant find it by the looks of it
02:52:06 <gbonobb> so how can i tell sublimehaskell about the exe
02:52:19 <gbonobb> usi guess use ;
02:52:50 <gbonobb> "add_to_PATH": ["C:\\HaskellPlatform2013_2_0_0\\2013.2.0.0\\bin"]
02:53:09 <gbonobb> "add_to_PATH" --> ; ["C:\\HaskellPlatform2013_2_0_0\\2013.2.0.0\\bin",
02:53:16 <gbonobb> is this what you mean
02:53:20 <Kaini> No no
02:53:36 <gbonobb> haha i thought so as that will break python
02:54:41 <gbonobb> "add_to_PATH": ["C:\\HaskellPlatform2013_2_0_0\\2013.2.0.0\\bin", "C:\\Users\\username\\AppData\\Roaming\\cabal\\bin"] } thats what i have
02:55:27 <gbonobb> the platform bin has ghci and stuff whereas the cabal bin holds cabal, ghc-mod exes etc
02:55:43 <Kaini> I haven't investigated this issue any further, but it looks like SublimeHaskell contains code ala ":".join(add_to_PATH) which will not work on Windows. I never managed to get add_to_PATH running on Windows - just don't use this variable. Set your Path in the System Settings (Win+Break, Change settings, environment variables, ...)
02:56:36 <gbonobb> Hmm so the paths under sublimehaskell settings should be emtpy
02:56:40 <Kaini> Yes
02:58:02 <Kaini> If you are able to invoke ghc, cabal and hlint, stylish-haskell in an emtpy powershell, your PATH is set correctly.
02:58:16 <Kaini> (You can print your path with "$env:Path")
02:58:50 <gbonobb> 1 sec trying now
03:02:36 <gbonobb> Kaini: Yeap they all work from command line
03:02:46 <gbonobb> maybe is a sublime haskell windows issue
03:03:05 <Kaini> Did you restart Sublime Text and try again?
03:03:43 <gbonobb> 1 sec i actually removed the plugin and installing now
03:09:32 <gbonobb> ok
03:09:39 <gbonobb> is doing something it was not doing before
03:09:48 <gbonobb> loading standard modules
03:09:53 <gbonobb> this looks promising
03:14:32 <gbonobb> OK no paths set, but unfortunatelly still stays at Building.... indefinitely
03:15:06 <gbonobb> Sublime Haskell: running build commands: [['cabal', 'build'], ['cabal', 'build', '-v0', '--ghc-options=-fforce-recomp -Wall -fno-code']]
03:15:07 <dennis> Hi
03:15:30 <dennis> im trying to benchmark something with criterion
03:15:54 <gbonobb> WindowsError, system cant find file specified
03:15:59 <gbonobb> in the console
03:16:11 <gbonobb> so i am assuming it cant find cabal
03:16:16 <gbonobb> brb
03:16:43 <Kaini> gbonobb, does "cabal build" work in the PowerShell?
03:17:48 <dennis> i used 2 different computers and on one if it i always get an error after a while which says: "\Data\Vector\Generic.hs 244 ((!)): index our of Bounds (-veryBigInt, Count)
03:18:24 <dennis> has this to do something with ghc version or so?
03:19:03 <luite> Cale: ack i should really take those examples offline
03:19:33 <Cale> luite: I like them! :)
03:19:47 <donri> dennis: 64 bit vs 32 bit perhaps?
03:20:05 <Cale> It's just fun to look at the generated output and marvel at how good modern web browsers are at executing javascript
03:20:05 <luite> Cale: hehe well at least update them with something from a recent build
03:20:24 <dennis> Well they are both 64 bit
03:20:43 <nh2> gbonobb: oh a SublimeHaskell windows user!
03:20:56 <nh2> gbonobb: let's try and make it work
03:22:10 <dennis> can i somehow look which version of ghc i installed? 64 or 32?
03:22:38 <donri> dennis: uh actually index out of bounds might not have to do with the architecture. dunno.
03:22:54 <nh2> Kaini: how are paths in windows supposed to be joined?
03:22:58 <nh2> semicolon?
03:23:00 <Kaini> nh2, ;
03:24:00 <Kaini> nh2, os.pathsep in python
03:24:19 <Cale> luite: It would be interesting to see if the newer build performs better.
03:26:21 <luite> Cale: it's probably a bit slower, since it uses function calls for many things to save a bit of space, and js engines don't always inline them reliably
03:26:38 <luite> although the newer builds have some other optimizations
03:26:53 <donri> luite: is it slow on firefox because of firefox or because of ghcjs?
03:27:09 <luite> Int, Char, Word values are all represented by a javascript number now, no boxing anymore
03:27:46 <luite> (works for all single-constructor ADT's with one primitive field that fits in a JS var)
03:28:12 <nh2> Kaini, gbonobb: pushed
03:28:16 <luite> donri: firefox has a poor memory manager, slow allocator and non-generational gc
03:28:21 <luite> that doesn't play well with haskell
03:28:52 <donri> luite: fun!
03:30:34 <luite> donri: if the example was carefully written to run fully in unboxed arrays without allocation, firefox would do much better
03:32:16 <donri> luite: do you know if they're working on those things in firefox at all?
03:32:23 <donri> they seem to be putting all their monies on asm.js
03:33:01 <luite> donri: yeah they've been trying to track down all unsafe memory things in their C (or C++?) library earlir this year
03:33:35 <luite> donri: by using some combination of static analysis with macros that catch lots of common patterns
03:34:23 <donri> luite: and GC?
03:34:28 <luite> problem is that if you want to go to a generational compacting GC, every write suddenly needs to go through a write barrier
03:34:46 <luite> donri: they have an implementation of that somewhere
03:35:08 <luite> donri: of a generational gc
03:35:11 <Hugh__> Hello - what is the difference between cabal and cabal-dev?
03:35:26 <donri> Hugh__: cabal-dev is outdated
03:35:46 <Redz> why does it print only after a endline?
03:35:47 <Redz> main = forever $ getChar >>= print
03:35:47 <donri> Hugh__: latest cabal-install has sandboxes now
03:36:02 <dcoutts_> Hugh__: cabal-dev is/was a wrapper around cabal to provide better sandboxing. The latest release of cabal now has sandboxes natively.
03:36:06 <donri> Hugh__: and a repl
03:36:18 <luite> donri: not sure about the status, the real risk is in the libraries, that's much more code, and more tricky bugs
03:36:23 <Hugh__> ok... so sandboxes keep all packages separate?
03:36:36 <kuribas> Is there a portable version of decodeFloat?
03:36:50 <donri> Hugh__: well, they give you separate environments
03:37:32 <Hugh__> sorry, what is the difference?
03:38:19 <donri> Hugh__: that you can share sandboxes and that you still can't install different builds of the same package version in one sandbox
03:38:46 <donri> Hugh__: but i'm not quite sure what *you* meant by "all packages separate" :)
03:39:10 <donri> Hugh__: when you install into a sandbox, all the dependencies install into that same sandbox, too
03:40:13 <Hugh__> I am trying to really understand where everything is stored on the file system. Let's back up... given a totally clean Ubuntu install, installing the Haskell Platform for the very first time where do all the Prelude packages go?
03:40:13 <nh2> Hugh__: from your sandbox you can still see the system-wide installed packages
03:40:32 <Hugh__> nh2 - ahh! Ok, so those would be Prelude?
03:40:51 <donri> Hugh__: prelude normally comes from the "base" package
03:41:15 <Hugh__> so prelude is not actually a package?
03:41:19 <donri> Hugh__: it's probably in some place like /usr/lib[64]/ghc-*/base-*
03:41:36 <donri> Hugh__: it's a module which is part of a package :)
03:42:26 <merijn> Redz: stdin is line buffered, so getChar doesn't get any input until you input a new line
03:42:40 <merijn> Redz: You need to disable buffering on stdin to stop that
03:42:43 <Hugh__> ok, so Package is synonymous with Jar and module is synonymous with a java Package
03:42:49 <nh2> Hugh__: you can see with dpkg -L ghc
03:43:03 <donri> Hugh__: something like that
03:44:57 <Hugh__> ok, last question I promise... when would it ever not be better to always use sandboxes? In other words, surely the way to go is always use sandboxes for all projects?
03:45:18 <donri> Hugh__: it means builds take longer, at least initially
03:45:23 <Hugh__> then when you delete a project you remove all files
03:45:27 <nh2> Hugh__: the haskell module / java package comparison goes ok, but in java a jar is a real file while a package is like a package on ubuntu: it can deliver you packages, but it is not a file itself (it's a grouping of files)
03:45:48 <Hugh__> got it! thanks nh2
03:45:58 <donri> Hugh__: no need to promise no further questions - ask away!
03:46:16 <nh2> Hugh__: if you install all packages 100 times it'll take disk space and your maintenance time to keep them updated
03:46:50 <nh2> if you are writing projects that work quite independently of dependency versions, you sometimes need not care
03:46:59 <Redz> merijn: i wonder why this works in ghci. did you know how to fix this?
03:47:54 <donri> Redz: possibly ghci isn't line buffered
03:48:05 <Hugh__> btw - I usually cut and paste these conversations for future reference. You guys are giving some very valuable advice - maybe with your permission I could collate them and then open-source them somewhere for others to benefit? Just an idea..
03:48:11 <nh2> Redz: http://www.haskell.org/hoogle/?hoogle=hSetBuffering
03:48:49 <donri> Hugh__: the channel is publicly logged anyway. i don't know what the copyright implications are. feel free to use anything *I* say though.
03:49:12 <Ikarus> I have two Ints, I want to divide them and get the Double out of them, obviously / doesn't just work, what am I supposed to be doing ?
03:49:12 <Hugh__> oh right, is it searchable somewhere?
03:49:26 <nh2> Hugh__: http://tunes.org/~nef/logs/haskell/?C=M;O=D
03:49:27 <donri> Hugh__: http://ircbrowse.net/
03:49:53 <Hugh__> thanks all, great assistance! out
03:50:21 <nh2> Ikarus: first convert them both to Doubles using fromIntegral
03:51:27 <Redz> nh2: thank you.
03:51:52 <nh2> Ikarus: fromIntegral is like a generalized version of a (double) cast in other languages, it can infer the type of what you want to convert to from the environment
03:55:28 <kuribas> Is Int32 or Int64 faster than
03:55:31 <kuribas> integer?
03:55:49 <nh2> kuribas: yes
04:01:07 <kuribas> And the size of Int is platform dependent?
04:05:07 <quchen> kuribas: Yes.
04:05:36 <quchen> kuribas: Try evaluating `maxBound :: Int`.
04:05:41 <quchen> > maxBound :: Int
04:05:43 <lambdabot>   2147483647
04:05:45 <kuribas> Why doesn't decodeFloat return (Int64, Int) instead of (Integer, Int)?  Isn't the first more efficient?
04:06:57 <quchen> I don't think it matters much there. Integer is basically "data Integer = Small Int | Large BigInt".
04:07:13 <quchen> So the overhead you're introducing is one comparison for "largeness" and adding the constructor.
04:07:28 <kuribas> > maxBound :: Int64
04:07:29 <lambdabot>   9223372036854775807
04:07:54 <kuribas>  Int64 is larger than Int.  And I would think Int64 is cheaper than BigNum.
04:08:16 <quchen> Int64 is not necessarily larger than Int.
04:08:30 <quchen> On 64-bit machines they're often identical.
04:08:39 <Fuuzetsu> not everyone is running on 64 bit system
04:08:42 <quchen> And Int64 has a max bound, while Bigint doesn't.
04:09:02 <kuribas> I am running on 64 bit, but 32bit ubuntu...
04:09:34 <kuribas> quchen: True, but a double floating point mantissa is 52 bits.
04:10:10 <quicksilver> the reason is simply historical
04:10:18 <quicksilver> it's not because Int64 is faster or slower than Integer
04:10:33 <quicksilver> it's because decodeFloat was written when Integer was the only sensible option
04:10:54 <kuribas> I see.
04:11:34 <quicksilver> decodeFloat might even be in the standard(?)
04:11:38 <quicksilver> whilst Int64 isn't(?)
04:11:42 <quicksilver> unsure of facts :-)
04:12:40 <quchen> quicksilver: Both decodeFloat and IntX are in the standard
04:13:00 <kuribas> decodeFloat is also in the standard?
04:13:03 <quchen> Yes.
04:13:21 <kuribas> So I can rely on it being portable?
04:13:40 <quchen> It's part of the RealFloat typeclass, which is a standard typeclass mentioned in the report.
04:14:33 <kuribas> Ah, nice!
04:14:51 <quchen> Section 6.4.3 (in the PDF at least)
04:16:08 <quicksilver> quchen: where is Int64?
04:16:30 <quchen> quicksilver: 8.4.2, foreign types
04:16:33 <quicksilver> ah
04:16:34 <quicksilver> http://www.haskell.org/onlinereport/haskell2010/haskellch18.html
04:17:04 <quchen> Or there.
04:17:10 <quchen> That's probably the better hit.
04:17:16 <b__> Anyone familiar with this error? ByteCodeLink.lookupCE During interactive linking, GHCi couldn't find the following symbol: Numuszm0zi1zi0zi0_NumusziTypes_zdfShowEntry_closure
04:17:42 <quchen> "All arithmetic is performed modulo 2ˆn, where n is the number of bits in the type." - So integer overflows are specified by the report? I thought it was undefined
04:18:45 <quicksilver> nope, the report specifies integer arithmetic much better than the C standard
04:18:48 <quicksilver> it's a positive feature
04:18:57 <quicksilver> what it famously doesn't specify is the exact size of Int
04:19:45 <quchen> quicksilver: But it gives a lower bound at least
04:20:00 <quchen> Namely ">= signed Int32"
04:22:02 <kuribas> That's probably for performance reasons?
04:22:27 <int-e> quchen: hmm, really? I thought it was 30 bits. And it is, the minimal range of Int is -2^29 .. 2^29-1.
04:22:52 <quchen> int-e: Oh, right. Premature logarithm.
04:23:11 <quchen> What I tried avoiding to say was "A fixed-precision integer type with at least the range [-2ˆ29 .. 2ˆ29-1]."
04:27:00 <quicksilver> kuribas: they were prepared to assume that efficient 32 bit words existed but they didn't want to exclude implementations which used bit-tagging
04:27:18 <quicksilver> although none of the implementations that we have do use bit-tagging on integer words as far as I know
04:28:44 <int-e> did / does lazy ml use such tags?
04:50:22 <gbonobb> nh2, still here?
04:50:25 <gbonobb> :)
04:50:29 <ccapndave> Hey all - sorry for noob questions, but am trying to get my head properly around recursion at last.  This super-simple minimum function I made at https://gist.github.com/ccapndave/6508299 is different to the examples at http://stackoverflow.com/questions/13792477/recursion-haskell-minimum-value-function but I can't figure out what's wrong with it
04:50:37 <ccapndave> (if indeed anything is wrong with it)
04:50:43 <nh2> gbonobb: yes
04:50:53 <gbonobb> awesome
04:51:00 <gbonobb> any ideas on how to get it working
04:51:08 <nh2> gbonobb: I pushed a change
04:51:15 <nh2> to use ; for windows
04:51:19 <nh2> maybe you can try that
04:51:33 <gbonobb> how exactly
04:51:39 <gbonobb> you mean set the path
04:52:09 <nh2> gbonobb: no I mean I updated sublimehaskell
04:52:52 <nh2> and you how have to install the new version
04:52:53 <gbonobb> ahh cool
04:53:01 <gbonobb> so i can download the zip file
04:53:04 <nh2> I am not sure how/when sublime updates things
04:53:11 <nh2> you can git clone it
04:53:16 <gbonobb> i will manually drop in in packages
04:53:22 <gbonobb> or git clone it yes
04:53:31 <nh2> git clone will be better in case we change more
04:53:35 <gbonobb> so then should i just set the path or
04:53:39 <gbonobb> ok cool
04:54:00 <bergmark> ccapndave: it seems ok, are you sure there's something wrong with it?
04:54:15 <ccapndave> bergmark Not at all, just that it was different to the ones on that page
04:54:20 <gbonobb> i am using sublime 2 by the way
04:54:21 <ccapndave> bergmark Maybe its ok
04:54:42 <nh2> gbonobb: yep I'm using that as well
04:54:48 <ccapndave> bergmark Do you (or anyone) happen to know of an online set of recursion exercises I can work through to train my skills?
04:54:56 <bergmark> ccapndave: 99 haskell problems
04:55:04 <bergmark> @where 99 haskell
04:55:05 <lambdabot> I know nothing about 99.
04:55:10 <bergmark> ep
04:55:19 <bergmark> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:55:19 <gbonobb> haha cool so i will just do a git clone in the packages folder
04:55:28 <ccapndave> Cool
04:55:29 <ccapndave> Thanks
04:56:20 <bergmark> ccapndave: only issue i see with your findMin is that you call findMin xs twice so it could be more efficient
04:56:50 <ccapndave> bergmark Ah right.  I need to use 'where' to assign it, right?
04:58:59 <gbonobb> ok cloned
04:59:08 <gbonobb> and just restarted st2
04:59:16 <gbonobb> loading modules
04:59:57 <bergmark> ccapndave: right
05:05:00 <gbonobb> nh2: Ok now it works much better, i opened an hs file and linting and build occured
05:05:01 <petapetapeta> I am using Alex to lex some text. When it fails lexing I want it to fail gracefully, but right now it simply crashes with the message "Lexical error". How can I prevent this?
05:05:26 <gbonobb> however if i open my cabal progrect it still seems to build forever
05:05:40 <nh2> gbonobb: depending on the cabal project, it might take a while
05:05:52 <nh2> how long does it take if you go there in the terminal and do cabal build?
05:06:05 <gbonobb> pretty quick
05:06:13 <gbonobb> is a simple hello project
05:06:21 <nh2> hmm sounds weird
05:06:25 <gbonobb> 1 sec
05:06:30 <gbonobb> maybe i can make a new one
05:06:36 <nh2> if you look in the settings, there is an option for what it does exactly
05:06:46 <nh2> default is "first build then warnings"
05:06:52 <gbonobb> yes
05:06:55 <nh2> maybe you can change it to build only
05:06:59 <nh2> and see if that is faster
05:07:03 <nh2> that should only do cabal build
05:07:29 <nh2> you could also do Ctrl-Backtick to open the sublime terminal and look if you get any error messages
05:08:06 <nh2> if you find any, you could post them as an issue on the sublimehaskell github
05:08:29 <gbonobb> ok cool
05:08:37 <gbonobb> thanks for your help, really appreciated
05:09:19 <nh2> welcome! I'll go home now, post errors if you encounter any :)
05:09:30 <gbonobb> Will do, thanks man!
05:15:26 <flebron_> Hi. Constructors (say Just) are functions, right?
05:16:03 <m3ga> :t Just
05:16:04 <lambdabot> a -> Maybe a
05:16:08 <ocharles> flebron_: right
05:16:10 <flebron_> Yeah I know the :t.
05:18:38 <shiona> Say I happen to want to code golf. How would I read in data in as succinctly as possible?
05:18:54 <shiona> Like an input row of some floats and a char
05:21:09 <Yuu-chan> shiona: Lazy IO?
05:21:43 <shiona> Yuu-chan: any good text on those?
05:21:50 <shiona> ..or that
05:22:22 <donri> flebron_: they're not *only* functions, though. can't pattern match on functions for one.
05:22:54 <akegalj> how to use uncurryN from tuple package? Do i need to turn some extensions on?
05:22:56 <donri> flebron_: and you can't write a function as a constructor (ie. with an upper case)
05:23:06 <donri> flebron_: but yeah, you can use them as functions
05:23:45 <Yuu-chan> shiona: sorry, but I didn't understand the task right. I imagine of something like map (read :: String -> Float) . words <$> getContents to parse a (possibly) infinite stream of serialized numbers.
05:24:05 <donri> akegalj: looks like it's just type magic
05:25:23 <shiona> Yuu-chan: hmm, I'm not sure what I'm really after myself
05:25:29 <donri> akegalj: ie. just use it like "uncurry"
05:25:43 <shiona> I guess I'd better leave this for a later time
05:26:27 <akegalj> donri: hm, ok i'll try again. GHC was not happy when i tryed using it like uncurry
05:26:44 <donri> @lpaste the code and error, akegalj
05:26:44 <lambdabot> Haskell pastebin: http://lpaste.net/
05:29:12 <akegalj> donri: http://lpaste.net/92822
05:30:21 <flebron_> donri: Yeah, I'm aware, it was a theory qustion :)
05:30:25 <Yuu-chan> shiona: how that Pong would look?
05:30:50 <shiona> ?
05:31:45 <Yuu-chan> Oops :-[ I mean golf.
05:32:28 <Yuu-chan> Mixed things with my friend who tries to write Pong.
05:33:02 <shiona> code golf is a term meaning 'the art of writing short, working programs'
05:33:05 <donri> akegalj: the Num constraint is ambiguous, you need to give it a type signature or more type information
05:33:25 <donri> akegalj: for example this works: uncurryN (+) (1,2) :: Int
05:33:26 <shiona> usually extremely unreadable and hacky, but working code
05:34:34 <akegalj> donri: oh, thank you very much!
05:35:15 <Yuu-chan> One could consider whole Haskell a golf...
05:35:21 <donri> akegalj: that Curry class would work better with an added inverse fundep, i think
05:35:51 <akegalj> donri: don't know what that is :/
05:36:01 <akegalj> donri: i am haskell beginer
05:36:05 <donri> akegalj: class Curry a b | a -> b, b -> a
05:36:15 <akegalj> donri: ah, ok
05:36:19 <donri> but lennart is smarter than me so i might be missing something
05:36:27 <mjboa> Hi guys, if anyone has some extra time i just uploaded a tiny project i made, a redis clone. http://github.com/michaelbeaumont/hatic
05:36:40 <mjboa> would be awesome to get general comments on it
05:36:53 <mjboa> style, tips, ideas for a beginner
05:38:51 <donri> akegalj: yeah nevermind i tried it and ghc goes mad
05:39:04 <udoprog> mjboa: spend more time writing a comprehensive README, it will catch peoples attention. Use another popular project's README as a starting point for how to structure it
05:39:16 <akegalj> donri: can you also explain me what is the "| a -> b" part in class definition?
05:39:26 <merijn> akegalj: It's a functional dependency
05:39:28 <donri> akegalj: that's the fundep, aka. functional dependency
05:39:49 <akegalj> merijn, donri: oh, ok.. il do reading now
05:39:57 <donri> akegalj: it says that for any 'a' there can only be one 'b'
05:41:38 <akegalj> donri: ah ok :)
05:42:54 <donri> akegalj: oh i know why my extra fundep doesn't work: a -> b ~ a -> a' -> b'
05:43:17 <mjboa> udoprog: good idea, that's literally all it can do though. i just wrote it as an exercise. was looking for a sort of quick code review i guess.
05:43:26 <donri> because b can be a' -> b'
05:44:00 <merijn> mjboa: The haskell reddit is also a good place to ask for critiques
05:44:45 <donri> mjboa: needs moar acid-state ;)
05:45:03 <akegalj> donri: yeah, i understand
05:47:50 <mjboa> donri: yeah i realize it's been done and better with acid-state but i was writing to learn more than anything else
05:48:39 <donri> mjboa: oh i meant you could implement it using acid-state. acid-state alone isn't a redis clone.
05:50:03 <mjboa> donri: oh ok
05:59:30 <AfC> Hey, cool, a new acid-state version mere hours ago
06:00:10 <matthiasgoergens> Which is the current lens library of choice?
06:00:16 <donri> AfC: the main new thing i think is you can createArchive on a remote state
06:00:31 <donri> matthiasgoergens: "lens"
06:00:36 <matthiasgoergens> Ok, I'l try that.
06:01:50 <merijn> Isn't the answer to "what is the current X library of choice?" always "lens" :p
06:02:09 <donri> merijn: "lens"
06:02:22 <donri> (ie. it's the answer to *any* question)
06:02:52 <matthiasgoergens> I am working on something similar to regex-applicative.
06:03:03 <matthiasgoergens> But one that gives you all matches (and of course with no backtracking).
06:03:26 <matthiasgoergens> Or rather, not no backtracking, but in at most linear time per match.
06:07:20 <matthiasgoergens> I have a design, but I am scratching my head on how to fit it into types.
06:12:30 <Lethalman> is haskellwiki down?
06:12:41 <Lethalman> the whole haskell.org seems to be
06:13:13 <artyomkazak> I think it went down more than half an hour ago
06:18:44 <lurkorg> Hi all, I'm trying to get keypresses from SDL, but when I try to print out a character nothing gets printed, not even a blank space. http://lpaste.net/92823
06:31:18 <sopvop> so, haskell.org is down?
06:31:44 <sclv_> yes it is
06:31:50 <sclv_> we sent a reboot request to the host.
06:32:03 <sclv_> so hopefully it'll be back shortly, though it may have to fsck
06:32:09 <sopvop> you should set update topic :)
06:32:19 <sclv_> we'll update the channel plus reddit as things progress
06:32:26 <sclv_> if an op is around they can do so
06:32:42 <sopvop> so, any mirrors for ghc-7.6.3?
06:33:25 <ski> @help unshift-topic
06:33:25 <lambdabot> Add a new topic item to the front of the topic list
06:34:18 <luite> sclv_: it's a hetzner server, right?
06:34:45 <sclv_> luite: yah
06:36:52 <luite> sclv_: ah i had some problem where they wouldn't come back up unless i sent them ctrl+alt+del, with nothing about fsck in the log (standard ubuntu 12.04 loaded from their rescue system installer). have you seen something similar?
06:38:05 <sclv_> luite: i'm not doing that portion myself, you can check in on #haskell-infrastructure if you have any ideas/suggestions/etc
06:39:08 <luite> oh ok, nah i don't have suggestions, was just wondering if you had solved it already, sending ctrl+alt+del doesn't feel like a proper solution :)
06:40:32 <sclv_> we sent a hardware reset request but haven't seen an effect yet, also don't know why it happened, so we'll see...
06:41:27 <kaw> What's the state of Haskell on larger "embedded" devices? Is it easy to cross-compile to ARM, and how much memory would a small program need to run effectively?
06:42:07 <quchen> kaw: I run Haskell on my Raspi, the compiler comes in a Raspbian package.
06:42:36 <Earnestea> Would you consider the rpi to be "embedded"?
06:42:50 <kaw> With the scare quotes, certainly
06:42:56 <quchen> Depends on whether you use it to embed it.
06:43:28 <kaw> I read reports on Google that ghc would crash with out-of-memory errors on RPi when installing more complex stuff
06:43:56 <Earnestea> Oh, I really thought you meant embedded programming and I was curious, nevermind :p
06:44:11 <kaw> On the other hand the programs I'm thinking of wouldn't be nearly as complex as ghc, so that might not be a problem
06:44:15 <quchen> I haven't compiled "more complex stuff" on it yet.
06:44:44 <quchen> Compiling GHC on Raspi is not very easy I imagine. Someone said the build fails after a day or so. :-)
06:44:45 <kaw> Earnestea: Well, there's really no hope of getting ghc-based Haskell stuff to run on anything truly tiny, is there?
06:45:08 <Earnestea> kaw: I guess not; that's why it perked my curiosity see heh
06:45:10 <quchen> Wasn't there a post of Haskell running on a 32kb ram machine?
06:46:01 <quchen> (Not GHC though)
06:46:38 <merijn> kaw: Well, I wouldn't say "no hope", but it would require a significant amount of engineering work and building the compiler on the embedded platform is unlikely
06:46:58 <kaw> quchen: That sounds theoretically interesting, but surely it must've been missing some major functionality? I assume there are good reasons ghc is not 32 KiB
06:47:00 <merijn> kaw: Building a specialised runtime for embedded is certaintly not unthinkable, but it's hard to see what the point would be
06:47:20 <quchen> kaw: http://www.youtube.com/watch?v=fOsjEfNmTkY
06:47:21 <merijn> kaw: Well, there's no reason why the compiler has to run on the platform running the code
06:47:35 <merijn> kaw: Most small embedded environments can't run a C compiler either
06:47:50 <kaw> merijn: Right, my question wasn't about running the compiler, it was about running the compiled programs
06:48:01 <kaw> People mentioned the compiler as an example of a program
06:48:38 <merijn> kaw: Anyway, as I said, I don't see a conceptual problem, but you'd need to invest a lot of time in building a different runtime and potentially a different GC approach
06:49:25 <kaw> Right
06:49:28 <sopvop> yay! found mirror! http://www.vislab.uq.edu.au/ag3/distfiles/ghc-7.6.3-x86_64-unknown-linux.tar.bz2
06:49:43 <kaw> But say I have some tens of megabytes of memory, rather than 30 kilobytes?
06:49:51 <quchen> sopvop: Worst comes to worst you can clone from github and build it yourself
06:49:53 <merijn> sopvop: I think johnw is hosting ghc binaries too, but that may just be HEAD
06:50:21 <merijn> kaw: Even then, the runtime system is quite big and complicated
06:50:28 <sopvop> quchen I'm on a completely fresh system. with wiped /home.
06:51:05 <kaw> merijn: Right, I guess that's what I feared
06:51:17 <merijn> kaw: There are minimal runtimes, though
06:51:48 <merijn> kaw: House is runtime for running haskell without OS (i.e. barebones) and there' HaLVM that lets you run code directly in Xen
06:53:14 <kaw> merijn: Oh, okay? Sounds interesting.. would it still be possible to run libraries not specifically tailored for those runtimes on those?
06:53:31 <merijn> kaw: I'm not entirely up-to-date on what is/isn't possible there
06:54:44 <Hugh__> Hi - having just installed yesod ok, when i start it I get ...
06:54:47 <Hugh__> cabal: Cannot find the program 'ghc' at 'yesod-ghc-wrapper' or on the path
06:54:54 <Hugh__> but ghc IS on the Path?
06:55:15 <applikativ> mysterious
06:55:25 <merijn> What's "which ghc" say?
06:55:38 <applikativ> what is 'yesod-ghc-wrapper'? i wonder
06:56:03 <Hugh__> "/usr/bin/ghc"
06:57:22 <Hugh__> no idea what the wrapper is..
06:57:27 <applikativ> this happens when you do 'yesod init'?
06:58:03 <Hugh__> no, yesod init works fine. this is when I do yesod devel to start the server
06:59:19 <applikativ> it might be really simple; i wonder if anyone is awake in #yesod
06:59:59 <applikativ> i'm rooting around the source for the wrapper thing
07:00:06 <Hugh__> thanks..
07:00:15 <applikativ> it seems to be an executable, which is a little odd given the error
07:01:08 <Hugh__> #yesod
07:01:55 <Hugh__> is it me, or is building and packaging and dependency management a real nightmare in Haskell?
07:02:18 <elliott> yes. it's a real nightmare lots of other places too though :p
07:02:42 <Hugh__> sure...
07:03:04 <applikativ> ah the error is from https://github.com/yesodweb/yesod/blob/master/yesod-bin/ghcwrapper.hs#L51
07:03:10 <Hugh__> BASIC never had this problem ;)
07:03:20 <applikativ> i mean, that's the action of writing the error message
07:03:23 <sopvop> static link, and no problems!
07:03:41 <applikativ> Hugh__: i think it's increasing, but yesod is by far the greatest strain
07:03:45 <applikativ> its just immense
07:04:16 <applikativ> it wouldn't be so bad if it were ruby and just a question of getting a pile of files in place, there's this monster labor of compilation
07:04:56 <Hugh__> so why not for most packages just download the binary and link files?
07:05:10 <merijn> Hugh__: And who is responsible for building these binaries?
07:05:11 <Hugh__> why does one need all the source too?
07:05:20 <Hugh__> the developer ?!
07:05:37 <merijn> Hugh__: If you're willing to dedicate the resource to build for all platforms, I'd gladly distribute binaries of my code
07:05:48 <haasn> hpc: any hope for compatibility with newer GHC versions? https://gs1.wac.edgecastcdn.net/8019B6/data.tumblr.com/tumblr_lxixxuK7ia1qdlh1io1_r1_250.gif
07:05:56 <haasn> sorry, wrong link https://github.com/headprogrammingczar/ghc-man-completion/
07:06:02 <haasn> don't know how I managed to screw that up :(
07:06:12 <merijn> Hugh__: Unfortunately, I have 1 Mac and a cheapo VPS host and I'm not gonna pay to build for all possible platforms and architectures and I suspect I'm not the only one
07:06:31 <Hugh__> fair enough.
07:06:33 <merijn> Not to mention the cost of maintaining the infrastructure to do that
07:07:13 * hackagebot statvfs 0.1 - Get unix filesystem statistics with statfs, statvfs  http://hackage.haskell.org/package/statvfs-0.1 (GergelyRisko)
07:07:32 <Hugh__> someone mentioned static link to 'it' above and all will be fine... not sure if that was for my benefit...
07:07:59 <aloiscochard> I'm crying... come back dear haskell.org
07:08:12 <merijn> aloiscochard: We're working on it
07:08:36 <merijn> aloiscochard: The host went down hard
07:08:54 <Hugh__> darn giraffes jinxed it I reckon
07:09:03 <linduxed> is haskell.org running on haskell?
07:09:16 <linduxed> just out of curiosity...
07:09:21 <merijn> linduxed: Define "haskell.org"
07:09:37 <merijn> linduxed: Old hackage is CGI scripts, the wiki is php, new-hackage is haskell
07:10:11 <merijn> linduxed: But in this case the physical machine hosting the various vms has died
07:10:12 <linduxed> ok haha
07:10:21 <linduxed> oh damn
07:10:29 <Hugh__> poor old machine. RIP.
07:10:35 <solirc> merijn: Since when is it done?
07:10:41 <solirc> ^down..
07:11:18 <merijn> solirc: An hour or so ago?
07:11:26 * solirc looks sad.
07:11:53 <Hugh__> going back to my point about binaries versus source, and wearing my devil's advocate hat, surely this is a clear reason to put haskell on the jvm?
07:12:07 <merijn> Hugh__: How so?
07:12:26 <merijn> Hugh__: The JVM is entirely unsuited to the way haskell code compiles
07:12:30 <Hugh__> build once... deploy wherever
07:12:57 <Hugh__> how so?
07:13:10 <merijn> I talked to a few scala guys, they're having huge issues with getting the JVM to work remotely well with their generated code
07:13:12 <Tinned_Tuna> merijn: (I'm not familiar with how GHC operates, but here goes!)
07:13:24 <Hugh__> (btw, I am being facetious)
07:13:35 <Tinned_Tuna> merijn: isn't the JVM a stack machine, and doesn't a G-Machine assume a stack machine to run on?
07:13:39 <merijn> Hugh__: Because memory allocation/GC of haskell follows a very different pattern than Java, so their GC is tuned for entirely different things
07:14:01 <Hugh__> this to do with laziness?
07:14:33 <merijn> Hugh__: Not so much, but haskell allocation rates can sometimes reach up to hundreds of MB per second
07:15:01 <merijn> Hugh__: Because the way GHC GC's it's very cheap to allocate a lot, as long as you don't keep the value around for long
07:15:15 <merijn> Hugh__: In Java GC becomes cheaper if you allocate *less*
07:15:38 <merijn> Hugh__: or at least for longer durations
07:16:16 <Hugh__> ok, so would it not be technically possible - and given a couple of million quid - to build a VM specifically for haskell?
07:16:30 <Tinned_Tuna> Hugh__: that's perfectly possible
07:16:36 <merijn> Hugh__: Sure, but it'd be a better investment to invest in LLVM
07:16:44 <Hugh__> LLVM?
07:16:46 <Tinned_Tuna> I'd have to side with merijn :-)
07:17:10 <Tinned_Tuna> Although, I'd love to see an RPython (aka pypy) Haskell interpreter of some sort.
07:17:12 <merijn> Hugh__: The "Low Level Virtual Machine"
07:17:16 <Hugh__> ah
07:17:35 <merijn> Hugh__: It's basically "machine independent assembly" that comes with a suite of backends/optimisers to compile it to different architecture
07:17:58 <merijn> Hugh__: So basically, any langage that can compile to LLVM can compile to any platform LLVM can compile too
07:18:05 <Hugh__> yeah, nice. Makes a whole bunch of sense. Get as close to the silicon without touching it
07:18:14 <merijn> Hugh__: It's meant to replace C as a low level target language
07:18:51 <merijn> Hugh__: The advantage of LLVM being that it has a lot of industry support (like Apple) that are invested in supporting/maintaining/expanding it
07:19:10 <Tinned_Tuna> merijn: not to mention you get a lot of optimisations for free.
07:19:15 <merijn> So rather than waste a lot of money doing it yourself, it's more efficient to join the winning team ;)
07:19:28 <Hugh__> so with LLVM one would no longer need the jvm
07:19:31 <donri> (but note that llvm isn't really a vm)
07:19:53 <Tinned_Tuna> Hugh__: the JVM would still have its place in the world.
07:19:55 <merijn> Hugh__: You can read more here: http://www.llvm.org/
07:20:56 <Hugh__> OK, thanks
07:21:59 <Hugh__> ... so going back to my yesod problem... someone mentioned to static link it?
07:22:15 <applikativ> well, yesod is wilder than ever, i thought i'd try it with cabal sandbox; now it's up to 110 installed packages; amazing
07:23:26 <Hugh__> it appears to be a beast
07:23:36 <Hugh__> great system though.
07:25:56 <Hugh__> I will stick my question on stackoverflow and for sake of completeness and the logs will report back with an answer
07:26:44 <applikativ> i think stackoverflow may be the best way to get an answer from the yesod crowd
07:26:59 <applikativ> something is really wacked with the most recent vault package
07:27:26 <applikativ> instead of the actual source, each module has cpp stuff saying 'include IO.hs'
07:27:37 <aloiscochard> merijn: thanks, may the force be with you guys!
07:29:52 <applikativ> the first file here is the current 'vault', the second the previous http://lpaste.net/92825
07:30:58 <applikativ> oh its a cpp subtlety after all; i figured hackage was being spammed
07:31:54 <applikativ> oh i chanced to do cabal update in a crucial interval
07:33:09 <Hugh__> yesh, I posted on stackO about the vault and Michael Snoyman answered there was a bug with current vault. He has raised a bug
07:34:02 <Hugh__> http://stackoverflow.com/questions/18702508/cant-install-yesod-on-ubuntu-12-04
07:40:21 <danilo2> Hello :) Is it possible in hasklel to write an instance for a very conrete types and a "default" instance, which will be used if the previous is not matched?
07:40:56 <danr> danilo2: yes with UndecidableInstances
07:40:58 <ski> it's considered evil
07:41:19 <elliott> danilo2: not really, breaks the open world assumption
07:41:21 <ski> danr : rather `OverlappingInstances' and `InconsistentInstances'
07:41:22 <elliott> UndecidableInstances does not help
07:41:36 <danilo2> danr, ski: I know its evil, but I want to use it in one place in generated haskell code - so I'm sure nobady will write additional instaces for it
07:41:54 <applikativ> is this your own type class danilo2 ?
07:41:59 <ski> (sorry, `IncoherentInstances', not `InconsistentInstances')
07:42:05 <danilo2> applikativ: yes
07:42:47 <applikativ> in your own class you can give default implementations though this may not help
07:42:50 <ski> perhaps you can avoid using a type class at all ?
07:42:55 <applikativ> nothing wrong with that, on the contrary
07:43:39 <danilo2> applikativ: Ok, I will try with default implementwation of my class
07:43:54 <danilo2> ski: No, I have to use it
07:44:36 <bigstones> hello, is it me or haskell.org is down?
07:44:37 <ski> why ?
07:44:38 <applikativ> what is special about this concrete type?  you might subtly be able to manage the matter with the original definition of the class
07:44:41 <ski> bigstones : yes
07:45:34 <applikativ> bigstones: if you need hackage nonsense there is the other site...
07:45:57 <applikativ> @hackage-mirror
07:45:57 <lambdabot> Unknown command, try @list
07:46:00 <danilo2> ski: because it defines a common function name :)
07:46:00 <applikativ> almost
07:46:08 <applikativ> @where hackage-mirror
07:46:08 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:46:24 <ystael> What is the standard technique for when you want a different instance implementation of a class at a type?  (like a different ordering on integers or something)
07:46:36 <danilo2> ski: It is very compelx I thing - this is a complex idea connected to this genrated code - I have to make type class because the name of some functions (like this) should be common
07:46:39 <applikativ> newtyping is the standard technique
07:47:15 <bigstones> applikativ: no thanks, I just needed the wiki, but I'll use google cache
07:47:19 <applikativ> you can also make a class that provides for this, but it's usually  more pain
07:47:27 <applikativ> bigstones: ah good
07:47:43 <ski> danilo2 : why can't you take the function as an argument ?
07:47:53 <ystael> applikativ: got it, thank you!
07:53:08 <magneticduck> it seems like the hoogle is down; what's a function that can convert Int to Integer?
07:53:54 <Kinnison> fromIntegral
07:53:55 <Kinnison> ?
07:54:02 <magneticduck> ah k
07:54:18 <magneticduck> I forgot all about the integral side of the number spectrum =P
07:54:21 <magneticduck> thanks
07:55:01 <kuribas> A hilbert R-tree works only with positive coordinates, right?
07:55:55 <kuribas> I have made a space filling curve that fills the space from the origin, not from the bottom left corner like the hilbert curve.
07:55:57 <hpaste> danilo2 pasted “Hacking typeclasses” at http://lpaste.net/92828
07:56:16 <kuribas> I wonder if that could be used instead of the hilbert curve?
07:56:29 <danilo2> could somebody help me please to make it working ? I basically want one instance to be default, while the other to be applied only when it matches: http://lpaste.net/92828
07:58:30 <flazz> how can I change a "Maybe a" into a "MaybeT m b"
07:58:54 <merijn> :t MaybeT
07:58:54 <lambdabot> Not in scope: data constructor `MaybeT'
07:59:01 <ekipan> @type lift
07:59:02 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:59:09 <merijn> :t Control.Monad.Maybe.MaybeT
07:59:09 <lambdabot> Couldn't find qualified module.
07:59:12 <merijn> aww
07:59:19 <merijn> :t Control.Monad.Trans.Maybe.MaybeT
07:59:19 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
07:59:21 <merijn> whoops
07:59:32 <merijn> "MaybeT . return" works
07:59:44 <merijn> I don't think lift is Right
08:00:05 <merijn> :t lift `asAppliedTo` (Just 'c')
08:00:06 <lambdabot> MonadTrans t => Maybe Char -> t Maybe Char
08:00:23 <danilo2> ski: I didnt saw your question - I will think about passing it as argument, but for now I do notsee such possibility
08:00:53 <flazz> merijn: is the maybeness mostly coincidental?
08:01:01 <danilo2> ski, elliott: Could you please look here and give me hint how can I make it working? : http://lpaste.net/92828
08:01:18 <yesthisisuser> Has anyone used HaskellDB? I'm having some trouble figuring out how to define a table...
08:01:49 <merijn> flazz: I'm not sure what you mean by that?
08:02:15 <merijn> flazz: And I just saw you have an 'a' in your first signature, but a 'b' in the second, is that right?
08:02:18 <flazz> i was thing i could lift or something like that
08:02:29 <flazz> merijn: just to say they are different
08:02:41 <merijn> flazz: lift does something else
08:02:57 <flazz> yeah
08:03:04 <merijn> flazz: lift can turn "IO a" into "MaybeT IO a", not "Maybe a" into "MaybeT IO a"
08:03:20 <merijn> But like I said "MaybeT . return" works
08:03:35 <flazz> thanks
08:03:36 <merijn> :t Control.Monad.Trans.Maybe.MaybeT . return
08:03:37 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
08:04:21 <ski> danilo2 : what are the laws of the operation `test'
08:04:22 <ski> ?
08:09:12 <danilo2> ski: the operation test (in the example is useless) but it should generally be able to call "f" on arguments which can be IO a or Pure a. If it gets for example "test (+) (a::IO Int) (b :: Pure Int)" it will result in IO Int
08:10:54 <hpaste> danilo2 pasted “Fun with typeclasses” at http://lpaste.net/92833
08:11:07 <danilo2> ski: look at the working example I've got here: http://lpaste.net/92833
08:11:40 <danilo2> ski: Right now I have to declare ALL possible permutations of Instances, but as you can see, every implementation (aapart of one) has the same body
08:12:43 <danilo2> ski: look at lines 14-17 - the implementation allows you to use function "add" on arguments of types Pure or IO and results appropriate Typed argument
08:13:02 <ski> is there a point to  print'  ?
08:13:07 <flazz> merijn: that worked great thanks
08:13:24 <ekipan> I don't understand why you need to parameterize over all 3 type constructors, if you can let them be the same, then apply2 = liftM2
08:13:35 <ekipan> and your Pure type = Identity
08:13:36 <danilo2> ski: no, sorry for that :)
08:13:54 <hpaste> danilo2 revised “Fun with typeclasses”: “No title” at http://lpaste.net/92833
08:14:18 <danilo2> ski: I've removed the print'
08:14:53 <ski> hm, why `class GetIO a b' rather than `class GetIO a' ?
08:14:56 <danilo2> ekipan: I want to have "Pure" data constructor
08:15:05 <ekipan> @src Identity
08:15:05 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:15:31 <applikativ> Pure and Identity are similar in that neither has a Show instance
08:16:07 <ekipan> Identity x >>= f = Identity (f x)
08:16:27 <applikativ> no, its f x, or am i in a muddle
08:16:42 <ekipan> erm, yes
08:16:49 <applikativ> fmap f (Identity x) = Identity (f x)
08:16:56 <danilo2> ski: I think it is impopsible to write  `class GetIO a' instead of `class GetIO a b' - seriously
08:17:17 <ekipan> Identity x >>= f = f x
08:18:27 <danilo2> ski: Do you have any dea how to do it ?
08:19:03 <applikativ> its Apply2 you are worried about danilo2 ?
08:20:19 <danilo2> applikativ: I want to create Apply3, Apply4 etc - BUT using current implementation (http://lpaste.net/92833) - I have to specify EACH possible permutation of PURE and IO arguments (see lines: 30-34). I want to shorten it, because the implementations are all the same
08:21:02 <fser> hi
08:21:12 <ekipan> so you just want to be able to mix pure and IO computation without doing your own lifting?
08:21:29 <danilo2> ekipan: Some hack like this :)
08:21:34 <ekipan> seems like a lot of work without any real benefit
08:21:35 <fser> suppose I have a function taking a long time to run (f x y = ... complex and time consuming stuff)
08:22:10 <danilo2> ekipan: But I will not use it by hand - really - lets say it is only a hack I want to create to my generated code :)
08:22:31 <fser> is there any optimisation in list comprehension order? I mean [(a,b) | a <- [1..], b <- [1..], f a b, a + b < 50 ] rather than [(a,b) | a <- [1..], b <- [1..], a + b < 50, f a b ] ?
08:22:55 <ekipan> seems it would be easier to generate the fmaps and binds in your generated code
08:23:02 <dolio> fser: No.
08:23:11 <fser> ok thanks :)
08:23:25 <danilo2> applikativ: Is it possible?
08:25:58 <YayMe`> I've designed something that feels similar to a monad to me, but not quite I'm guessing. Curious if anybody here could help me decide if it fits. It's in C# but structural behaviour seems reminiscent. It interacts with hardware/users in a way they can give input and the input goes basically in the form of (hardware, eventInfo) to one of two places on a handler depending on the event, and that place on the handler al
08:25:58 <YayMe`> ways returns a handler that is used for the following (hardware, eventInfo) to be sent to
08:26:54 <danr> YayMe`: is it a functor?
08:27:20 <YayMe`> it feels similar to my intuition about a monad because you always have a current handler, you give it something and it returns a new handler, and moreover it may return a handler that returns a handler; the flatness of it feels monadic
08:27:28 <YayMe`> it never nests like I think of functors as doing
08:27:39 <ekipan> all monads are functors
08:27:46 <ekipan> if it isn't a functor, it's not a monad
08:27:51 <YayMe`> good point
08:28:27 <ski> danilo2 : did you try ?
08:29:23 <danilo2> ski: What did I try? I'm trying all the time :)
08:29:45 <YayMe`> on second thought perhaps it's not. it doesn't really contain information you can act upon, rather it contains continuations that you can step through one by one
08:30:14 <notdan> So, haskell.org is down, as well as ghc.haskell.org and git.haskell.org
08:31:04 <sellout-> notdan: Those all sound like haskell.org to me ;)
08:31:17 <sellout-> notdan: But yes, I too am frustrated by that this morning.
08:31:20 <YayMe`> all possible paths through those continuations could be traced to look like a tree which is a functor, but at each node is simply a decision path through continuations rather than content like a functor..
08:32:02 <applikativ> notdan: "Update: the main box is back up, but now we need to individually manually fsck the VMs. :-(
08:32:36 <YayMe`> give it X continuation returns node A give it Y continuation returns node B, the fact that each node is simply another continuation is what's tripping my intuition about monads
08:32:53 <ski> danilo2 : `class GetIO f where getIO :: f a -> IO a' seems to work fine here
08:33:04 <YayMe`> Does this sound like any known type of structure or am I simply mistaken?
08:34:58 <danilo2> ski: I'm very sorry. I do not know why it didnt work when I was trying... I had to make a mistake. Thank you for pointign this out! :)
08:35:54 <ski> YayMe` : hard to get a good idea about the shape of your type ..
08:36:16 <YayMe`> let's see if I can define a data type... it would be something like
08:37:41 <YayMe`> data Handler = Handler {UserInput = (Hw, Ev) -> Handler, HwEvent = (Hw, Ev) -> Handler}
08:38:37 <YayMe`> one of two event types occur, you hand it to the handler and it hands you the next handler to deal with the next event
08:38:54 <danilo2> ski: Ok, after fixing the GetIO signature I added (GetIO a) constrain to Apply2 instance and it works now :) Thank you! :)
08:39:21 <applikativ> you should presumably lowercase UserInput and HwEvent YayMe`
08:39:38 <YayMe`> Ah yes, I always forget the syntax for record types
08:39:59 <YayMe`> I need to write more haskell...
08:40:06 <applikativ> oh and userInput :: (Hw,Ev) -> Handler
08:41:46 <YayMe`> applikativ: aye. Basically there's a starting handler at the beginning of a session, and then user and hardware events step through various different handlers where each handler has knowledge of a fixed set of next possible handlers that it may branch towards depending on the user or hardware events that occur
08:44:03 <YayMe`> ski: the best guess I can come up with talking through this is that it may be similar to the haskell cont type?
08:44:50 * paolino has done the first hopengl UI with sprite patch and cords 
08:44:59 <applikativ> i'm not seeing why you shouldn't be working with some version of StateT (Hw,Ev) or something?
08:47:17 <applikativ> good work paolino.
08:48:03 <paolino> applikativ, is it ok to put a you tube link here with a small animation of it ?
08:48:05 <ski> YayMe` : and presumably the handler does some `IO' before giving back the next handler
08:48:46 <YayMe`> ski: yeah, that's why the Hw is passed in with the event
08:49:08 <ski> `Hw' being ?
08:49:12 <YayMe`> Hardware
08:49:27 <ski> simulation of some kind of hardware ?
08:49:39 <applikativ> paolino: why not?
08:49:42 <YayMe`> an abstraction over a literal piece of hardware
08:49:53 <YayMe`> gives some facilities for a few simple interactions with the hardware
08:50:20 <ski> and you can use different `Hw' values for each "event call" ?
08:50:35 <YayMe`> Nope
08:51:00 <YayMe`> it's the same abstraction everytime, just a way of accessing the hardware for that IO you guessed I was doing
08:51:37 <hpaste> danilo2 revised “Fun with typeclasses”: “No title” at http://lpaste.net/92833
08:51:40 <YayMe`> the part that changes is the Ev (event), based on the particular event the handler may do X on the hardware or Y on the hardware before returning the next handler
08:52:06 <danilo2> ski: I've updated the example (I was hoping it will work,but still does not work) - is it possible to make lines 33-34 working?
08:52:10 <YayMe`> also the difference in the event may cause it to return handler A or handler B
08:52:17 <danilo2> ski: http://lpaste.net/92833
08:52:26 <paolino> applikativ, dunno . http://www.youtube.com/watch?v=CvEZgLd1zss
08:53:22 <danilo2> applicativ: Could you look please (according to our prevous talk) at: http://lpaste.net/92833? Im talking about the lines (33-34) - the line 33 should be "default"
08:56:28 <ski> YayMe` : well, i was not seeing any `IO' in that type -- perhaps there's a driver/interpreter somewhere that does the I/O ?
08:59:50 * applikativ demands a free fpcomplete FP Haskell IDE account! 
09:00:32 <YayMe`> ski: yes, the HW object effectively allows the handler to send commands to the driver
09:01:22 <YayMe`> (Hw, Ev) goes in, the handler looks at the ev, sends some messages to the driver through the hw based on the ev, and then based on the ev decides the next handler.
09:01:39 <YayMe`> next handler; same thing.
09:04:48 <ski> YayMe` : would general functions be written to accept a `Handler' and return a `Handler' ?
09:05:32 <ski> iow, pass some `Ev'ents to the `Handler, getting a new one, which it returns
09:05:37 <YayMe`> No, there's a higher level point in the stack that's kind of like (Handler, Hw, Ev) -> Handler
09:05:58 <YayMe`> but it's fairly obvious how that's implemented
09:06:37 <flebron> Could one define constructor functions as functions whose normal form does not need to reduce the function to anything?
09:07:43 <ski> flebron : how about `div 1 0', is `div' a constructor function ?
09:07:57 <flebron> No, but that reduces to something, does it not?
09:08:28 <ski> typically, in small-step operational semantics, such terms are said to be "stuck"
09:08:29 <flebron> And even if it's bottom, it's still not an issue.
09:08:37 <ski> they're formalized as not reducing further
09:08:41 <flebron> (Because then the normal form doesn't exist.)
09:09:27 <ski> and one typically singles out a subset of the non-reducing terms as the "values"
09:09:32 <flebron> The way I had understood div 1 0 is that it reduces to bottom, so it doesn' thave a normal form.
09:09:58 <solirc> has anyone got this before (with http-conduit): InternalIOException connect: unsupported operation (Cannot assign requested address)
09:10:00 <ski> "bottom" is a concept from denotational semantics
09:10:42 <flebron> Denotational semantics do have a notion of reduction, correct?
09:10:43 <ski> though if you want, you could say that `div 1 0' reduces to `Wrong' (this is sometimes done)
09:10:50 <ski> flebron : nope
09:11:25 <ski> Denotational semantics maps terms into some "mathematical domain" of "true values"
09:11:35 <ski> usually including a "bottom" value
09:11:53 <ski> it doesn't take into account the steps taken by a machine to compute these values
09:12:15 <ski> reduction belongs to operational semantics
09:12:48 <ski> (if you want, you could think of den. sem. as a compiler from expressions into math)
09:12:57 <flebron> I suppose I've been using a mix, then. I've been assigning the concept of bottom to two things, the things that do not finish reduction successfully.
09:13:08 <flebron> (Which is either those that never finish reducing, or that finish unsuccessfully.)
09:13:17 <flebron> (i.e. bottom = bottom or undefined)
09:14:27 <ski> well, you can relate operational semantics and denotational semantics to each other. but they're separate domains, so to speak
09:16:05 <flebron> So what is the definition in each case of a constructor function, vis. a normal function?
09:16:30 <flebron> (I'm using Haskell as part of a freshman algebra course I'm teaching, and I want to be pedantically correct in case of any questions.)
09:17:34 <ski> in terms of operational semantics, you'd single out s subset of the terms as values (to be distinguished from the den. sem. notion of value)
09:17:39 <ski> so you might have
09:18:19 <ski>   e  ::=  ( e , e )  |  pi_0 e  |  pi_1 e
09:18:54 * Lethalman has to read something for the first time about operational semantics
09:18:55 <ski>        |  iota_0 e  |  iota_1 e  |  case e of iota_0 x -> e | iota_1 x -> e
09:19:04 <Lethalman> ski, could you point me to some paper for absolute beginners? :-)
09:19:15 <ski>        |  \ x . e  |  e e
09:19:22 <ski>        |  x  |  let x = e in e
09:19:25 <ski> or some such
09:19:27 <Lethalman> (ops, sorry broke your output)
09:19:29 <ski> and then perhaps
09:19:41 <ski>   v  ::=  ( v , v )
09:19:53 <ski>        |  iota_0 v  |  iota_1 v
09:20:03 <ski>        |  \ x . e
09:20:22 <flebron> I'm not sure I understand the use of | here.
09:20:35 <ski> alternative
09:20:57 <ski> `e  ::=  X  |  Y' means "an `e' can be of the shape `X', alternatively of the shape `Y'"
09:21:19 <ski> this is (more or less) BNF, used to describe the abstract syntax
09:21:31 <flebron> Oh OK, so every one was | except the one before "case e of".
09:21:38 <flebron> That one was "such that".
09:21:46 <ski> sorry ?
09:22:02 <flebron> "|   iota_0 e  |  iota_1 e  |  case e of iota_0 x -> e | iota_1 x -> e"
09:22:13 <flebron> I can't parse that - "e looks like case e of iota_0 x"?
09:23:26 <lightquake> I have an array that I'm going to be filling in mostly sequentially (i.e., from 0 up to N), but where the maximum size of the array might change and where might be some 'holes' I have to go fill in later
09:23:55 <lightquake> for example, I might fill in 0-19, 21-30, 35-50, and then later fill in 20, 31-34
09:24:05 <lightquake> which array-like structure do I want?
09:24:24 <ski> Lethalman : perhaps try "Practical Foundations for Programming Languages" by Robert Harper in 2013-07-05 (so far) at <http://www.cs.cmu.edu/~rwh/plbook/>
09:24:37 <Lethalman> ski, thanks
09:25:18 <sclv_> w00t most haskell.org services back up now
09:26:07 <Lethalman> ski, ah I was thinking of "A Structural Approach to Operational Semantics"
09:26:12 <ski> flebron : one alternative form for `e' is `iota_0 e' (where `e' is again a placeholder, a nonterminal, to be replaced anew, recursively), another is `iota_1 e', a third is `case e of iota_0 x -> e | iota_1 x -> e'
09:26:45 <flebron> Oh OK e is a type variable, each time it's a different 'e'.
09:27:10 <flebron> Well, type variable in the usual semantics, (a, a) means same type, but could have different values of type a.
09:27:28 <lightquake> ah, sounds like I want Sequence
09:27:30 <ski> flebron : in Haskell, this could correspond to `data Expr = Pair Expr Expr | Pi0 Expr | Pi1 Expr | Iota0 Expr | Iota1 Expr | CaseIota Expr (Ident,Expr) (Ident,Expr) | Abstract Ident Expr | Apply Expr Expr | Var Ident | LetIn Ident Expr Expr'
09:27:35 <flebron> In this case, you use e as a set, and say that elements of e can be "case x of iota_0 y" where x and y are things in e?
09:27:40 <flebron> Right, right.
09:28:05 <flebron> What would the iotas represent here? (I assume pis are projections)
09:28:16 <ski> `Left' and `Right'
09:28:23 <ski> while the `pi's are `fst' and `snd'
09:28:57 <ski> (`pi' and `iota' is the traditional names. sometimes `projl',`projr',`inl',`inr' or similar are used)
09:29:11 <flebron> Right, from products and coproducts.
09:29:20 <flebron> What is Abstract? \ident -> expr?
09:29:27 <ski> lambda abstraction
09:29:45 <flebron> OK, and where would constructor functions fit in this language?
09:30:07 <ski> `iota_0' and `iota_1' would play the role of constructor functions
09:30:27 <ski> and possibly, depending on how you think about it, also `(...,...)'
09:30:59 <flebron> Ah, OK.
09:31:01 <ski> you could instead add a new nonterminal `con' and add `con e' as an alternative
09:31:21 <flebron> OK so it's adding new terms to the language.
09:31:32 <ski> (and assume it's populated with whatever constructors you have in the language)
09:31:39 <flebron> Versus functions which aren't new, they are all the same type of term, "Apply Expr Expr".
09:32:20 <ski> yes, new canonical forms
09:33:08 <flebron> OK, how does this jive with the notion that :t Just is a -> Maybe a?
09:33:22 <ski> anyway, you'd define a binary relation `~>' on `e', and then extend to its reflexive-transitive closure
09:34:06 <ski> well, that's a conventient thing, so we can say `Just' on its own as an expression, rather than having to say `\x -> Just x' (as one has to do in OCaml)
09:34:21 <ski> s/conventient/convenient/
09:34:35 <flebron> So it's not strictly true that ctors are functions?
09:34:48 <ski> *nod*
09:35:05 <ski> well, s/true/necessary/
09:35:14 <flebron> Ah, OK. Cool, the idea seems consistent. Thanks :))
09:35:29 <YayMe`> Is the <- supposed to be the element-of symbol from math?
09:35:44 <ski> probably depends on context
09:35:56 <ski> `<-' as occuring where ?
09:36:02 <merijn> YayMe`: in list comprehensions, yes
09:36:12 <YayMe`> in list comprehensions it makes perfect sense that it would be, the other day it just dawned on me it looks *kind of* similar
09:36:17 <merijn> In do-syntax that doesn't necessarily makes less sense
09:36:24 <merijn> eh
09:36:32 <merijn> doesn't necessarily make sense
09:36:37 <ski> YayMe` : in Miranda, list comprehensions are called "ZF comprehensions"
09:36:40 <flebron> (In fact, the do sintax for the list monad _is_ the <- from list comprehensions :p)
09:36:45 <YayMe`> merijn: true, but it still somewhat makes sense
09:36:52 <ski> (where "ZF" being this common axiom system for set theory ..)
09:36:54 <applikativ> in list comprehensios you can sort of read it that way
09:36:56 <flebron> (And with MonadComprehensions, your lists too can be of any monad!)
09:36:57 <merijn> -XMonadComprehensions :)
09:37:28 <applikativ> what they have to do with ZF in particular God knows; as if it were a syntax
09:37:50 <ski> `MonadComprehensions' : comprehending monads has never been simpler !
09:38:44 <applikativ> [x++y| x <- readFile "a.txt" , y <- readFile "b.txt"] >>= writeFile "c.txt"
09:39:10 <applikativ> need a bit of join syntax
09:39:14 <YayMe`> i.e. x <- randomIO blabla does kind of make sense to say "x element of the set of the return from randomIO blabla
09:39:42 <YayMe`> applikativ: really? That is interesting...
09:39:50 <joelteon> why does cabal repl exit 0 without doing anything?
09:39:54 <applikativ> main = join [writeFile "b.txt" (x++y) | x <- readFile "a.txt" , y <- readFile "b.txt"]
09:40:08 <applikativ> whoops meant to write c.txt
09:40:50 <ski>   [() | x <- readFile "a.txt" , y <- readFile "b.txt" , () <- writeFile "c.txt" (x ++ y)]
09:41:15 <YayMe`> ski / applikativ : So either of you have a sense that the structure I spoke about is (or almost is) a monad/monoid/functor/semigroupoid/hylomorphic arrow or whatever other types of structures there are formal understandings of?
09:41:40 <applikativ> ah, well there you are, still less than ideal ski
09:41:43 <YayMe`> or is it more of just some thing I put together, and good for me.
09:42:03 <ski>   () <- catFiles a b c  =  x <- readFile a , y <- readFile b , () <- writeFile c (x ++ y)   -- ho, hum
09:42:29 <applikativ> it's a menace that we cant use them with parallel comprehensions
09:42:40 <YayMe`> [ writeFile "c.txt" (x ++ y) | x <- readFile "a.txt", y <- readFile "b.txt" ] no?
09:42:46 <ski> YayMe` : i was pondering whether maybe `Cont Handler a' would be useful in your case
09:42:53 <ski> YayMe` : needs `join'
09:43:00 <YayMe`> 10:42 *** rishabhjain_ JOIN
09:43:01 <applikativ> YayMe`: that's an IO (IO ()) so you need join or ski's device
09:43:05 <wojtekM_> > pure case 1 of {1->1; 2->2}
09:43:05 <wojtekM_>  
09:43:06 <lambdabot>   <hint>:1:6: parse error on input `case'
09:43:09 <YayMe`> oops
09:43:12 <wojtekM_> why?
09:43:41 <applikativ> > pure (case 1 of {1->1; 2->2}) :: [Int]
09:43:42 <lambdabot>   [1]
09:43:50 * ski prefers to be left with his own device
09:44:03 <wojtekM_> applikativ: Yes, but why?
09:44:06 <ski> wojtekM_ : no good reason, afaict
09:44:31 <wojtekM_> sometimes $ helps, but not always
09:44:34 <applikativ> > pure do return () :: [[90]]
09:44:35 <lambdabot>   <hint>:1:6: parse error on input `do'
09:44:37 <applikativ> > pure do return () :: [[()]]
09:44:38 <lambdabot>   <hint>:1:6: parse error on input `do'
09:44:49 <applikativ> > pure $ do return () :: [[()]]
09:44:50 <lambdabot>   Couldn't match expected type `[()]' with actual type `()'
09:45:02 <applikativ> oh genuine type idiocy
09:45:03 <YayMe`> ski: where a is (Hw, Ev) ? does it make sense what I said in that it could be seen as a tree of continuations; depending on your input the continuations will return node A or node B which is another continuation
09:45:26 <applikativ> oh no i get it.
09:45:57 <applikativ> wojtekM_: yes i don't know why theres not a caesura before 'case' and 'do'
09:46:30 <wojtekM_> So I should just put braces around my case and move on?
09:46:40 <applikativ> people frequently complain about having to write .... $ do ..., when it seems like the parser can hardly fail to start a mental parens at 'do'
09:46:56 <YayMe`> [ writeFile "c.txt" x | x <- readFile "a.txt" >>= (++) (readFile "b.txt") ]
09:46:57 <YayMe`> no?
09:47:00 <applikativ> > pure $ case 1 of {1->1; 2->2} :: [Int]
09:47:02 <lambdabot>   [1]
09:47:02 <ski> > (`asTypeOf` [[]]) $ pure $ do return ()
09:47:03 <lambdabot>   [[()]]
09:47:12 <applikativ> wojtekM_: you can use $ if you like
09:47:35 <hpaste> wereHamster pasted “getJSON” at http://lpaste.net/92836
09:47:41 <applikativ> frankly it reads better than the proposed alternative syntax or parser rule would
09:47:44 <wojtekM_> applikativ: $ doesn't work in my code, only () works
09:47:48 <ski> YayMe` : not sure if `Handler' is quite continuations, but could be related anyway
09:47:55 <wereHamster> can somebody pleaes have a look at the code ^^^ and tell me if it leaks memory or file descriptors?
09:47:58 <b2coutts> does anyone know what the sanest way is of talking to youtube with haskell?
09:48:06 <applikativ> oh i thought i was writing your code let me look at history
09:48:15 <ski> YayMe` : `Cont Handler a' would be `(a -> Handler) -> Handler'
09:48:26 <applikativ> b2coutts: a dos-attack program?
09:48:38 <b2coutts> as far as I can tell, there's no youtube API for haskell, and right now I'm using the ugly hack of using wget and parsing the HTML directly
09:49:10 <b2coutts> while making very strong assumptions about the structure of the HTML, so whenever youtube decides to change their HTML structure my code will break
09:49:12 <haasn> I'd look for something related to libquvi
09:49:21 <haasn> but I don't see anything on hayoo
09:49:23 <ski> YayMe` : your `[ writeFile "c.txt" x | x <- readFile "a.txt" >>= (++) (readFile "b.txt") ]' both needs `join' and also needs a `liftM',`fmap' for the `(++)'
09:49:43 <exicer> b2coutts: Which library do you use to parse HTML ?
09:49:48 <YayMe`> Oo yeah, I see why I need the join.
09:50:03 <applikativ> b2coutts: man it seems true, the only youtube thing on hackage is a script that uses curl. I wonder if we can vote it off of hackage?
09:50:18 <YayMe`> the liftM is less explicable to me?
09:50:43 <ski> @type readFile "a.txt" >>= (readFile "b.txt" ++)
09:50:44 <lambdabot>     Couldn't match expected type `[Char]' with actual type `IO String'
09:50:44 <lambdabot>     In the return type of a call of `readFile'
09:50:44 <lambdabot>     In the first argument of `(++)', namely `readFile "b.txt"'
09:50:57 <YayMe`> Oo I see it
09:51:06 <YayMe`> ah yeah I forgot about lambdabot
09:51:12 <ski> @type liftM (++) . readFile "b.txt" =<< readFile "a.txt"
09:51:13 <lambdabot>     Couldn't match expected type `String -> IO [a0]'
09:51:13 <lambdabot>                 with actual type `IO String'
09:51:13 <lambdabot>     In the return type of a call of `readFile'
09:51:31 <b2coutts> exicer: I'm basically just using basic string/list functions :P
09:51:34 <applikativ> b2coutts: or are you 'periodic'? https://github.com/periodic/youtube-haskell
09:51:38 <YayMe`> I was thinking String -> IO a but I forget I'm handing ++ an IO String when it needs a String
09:51:48 <YayMe`> or rather needs an [a]
09:52:04 <b2coutts> applikativ: not him; I'm basically making a thing that lets you use the CLI to search youtube and queue up songs from it in MPD
09:52:20 <b2coutts> using quvi to convert youtube URLs into things that MPD understands
09:52:46 <b2coutts> it's at the point where I'm sort of considering uploading/sharing the code, but I don't want to share something that uses an unreliable hack to handle searching
09:53:15 <ski> @type (`liftM` readFile "b.txt") . (++) =<< readFile "a.txt"  -- oh, right
09:53:16 <lambdabot> IO [Char]
09:53:19 <wereHamster> or where can I get help re. conduits?
09:53:44 <YayMe`> b2coutts doesn't youtube have a REST API that would be far more consistent than the HTML? (as well as plausibly returning JSON you could just use a JSON serializer for?)
09:54:35 <YayMe`> https://developers.google.com/youtube/?csw=1
09:54:51 <ski> flebron : anyway, you'd construct this so that no "value" can be reduced, and then a term has a normal form if there is a sequence of reduction steps ending in a value
09:54:58 <b2coutts> YayMe`: I have very limited experience with such things, and the googling I did suggested that google had APIs for major languages like python, but nothing for haskell
09:55:20 <flebron> ski: Those would be operational semantics, correct?
09:55:42 <YayMe`> b2coutts: those are clients not APIs, the API is simple http requests. You're already making simple http requests, you just need to use the REST API URLs instead of the actual html page URLs
09:55:49 <hpaste> wereHamster revised “getJSON”: “No title” at http://lpaste.net/92836
09:56:07 <ski> YayMe` : anyway, i'm still not clear on how `Handler's are used
09:56:16 <b2coutts> YayMe`: ah, I see, so they essentially have pages up that aren't meant to actually be visited by users, but rather read by code?
09:56:20 <mstksg> a package i'm using hides a runReaderT function to unwrap one of their monads and I'd like to use it; however, the environment type is also hidden.  is there anything I can do?
09:56:24 <b2coutts> (and they presumably remain somewhat consistent)
09:57:04 <mstksg> by use it, i mean re-implement it in my own project instead of having to import the hidden function
09:57:19 <mstksg> but i'm having problems because it requires an environment with a hidden data constructor
09:57:33 <YayMe`> ski: there's a current one for your user session, user does some things which fire events (or hardware does), those events are sent to the sessions current handler which returns the next handler which should be your current handler. You can imagine the "current handler" as like being the focal point of a zipper on a continuation tree (the constructor for handlers actually takes a previous handler so the zipper analo
09:57:34 <YayMe`> gy is quite right if that helps any)
09:57:36 <ski> i can imagine `doEvt :: Hw -> Ev -> Handler -> Handler', which could be abstracted to `doEvt :: Ev -> ReaderT Hw (Cont Handler ())' or something, if desired
09:58:17 <ski> @unmtl ReaderT Hw (Cont Handler) ()
09:58:17 <lambdabot> Hw -> (Cont Handler) ()
09:58:22 <ski> @botsmack
09:58:22 <lambdabot> :)
09:58:42 <robindv> Hi, i'm using knuths worst case algorithm for a worst-case solution for mastermind; the statement on line 65 is very slow because it has to evaluate all the reactions. Is there a more clever way to solve this? See http://lpaste.net/3725877265922260992
09:58:52 <YayMe`> @unmtl ReaderT (Hw, Ev) (Cont Handler) ()
09:58:52 <lambdabot> Hw -> Ev -> (Cont Handler) ()
09:59:35 <ski> does the above `doEvt' idea sound right ?
09:59:47 <ski> who decides to "do an `Ev'" ?
09:59:53 <ski> user code, or system code ?
09:59:56 <YayMe`> yes
10:00:28 <ski> iow, does user code decide "i want to do this", and then eventually fires away events to the system ?
10:00:28 <YayMe`> sorry, yes it sounds right, and actually the hardware fires the user code
10:00:40 <ski> or perhaps the system provides the events, and the user code just handles them ?
10:00:43 <ski> or perhaps both ?
10:01:01 <YayMe`> system provides events, user code just handles them
10:01:45 <YayMe`> the hardware specifically kicks out events which my user code picks up and runs with.
10:02:04 <ski> the above caller of `doEvt' fires events could, i think, be done with `Handler' as the "answer"/"final result" type of a continuation monad
10:02:33 <ski> but it sounds like, if present, `doEvt' would be on the system side of things
10:02:41 <YayMe`> yeah, that's exactly right
10:02:51 <ski> so user code would probably then not have much use for `Cont Handler'
10:03:18 <YayMe`> other than knowing it is in the context of one if I've structured it right
10:03:55 <ski> user code would perhaps have use of an operation which polls for the next event (or next event passed to its subsystem)
10:04:01 <ski> or perhaps there is to be no polling
10:04:07 <YayMe`> No polling
10:04:16 <ski> (well, polling or blocking, i.e.)
10:04:37 <YayMe`> no blocking either actually
10:05:06 <ski> what should user code be able to do, in response to it being fired as a result of the system responding to an event ?
10:05:17 <ski> send events of its own ?
10:05:24 <ski> manipulate hardware ?
10:05:31 <YayMe`> manipulate hardware yes
10:05:43 <YayMe`> and then move to the next handler which knows about the next manipulations that need be done
10:06:01 <applikativ> robindv: i cant concentrate adequately to find the klunk in here; but the important point is that colours::[Colour]; colours=[minBound..maxBound] ;)
10:06:31 <ski> so no cascaded event sends ?
10:07:20 <robindv> applikativ: thanks for your look :)
10:08:14 <YayMe`> ski: Right.
10:10:28 * ski would like to see some silly example of how handlers are written
10:12:29 * applikativ , when he hears the word 'knuth' just gets an image of mutually recursive latex macros expanding each other and everything into an obscure error; I think we are supposed to feel some uplift though
10:13:26 <YayMe`> loginHandler = Handler \(hw, ev) -> case attemptLogin (userInputFrom ev) of True -> mainHandler; _ -> sendMessage loginFailed hw >> loginHandler
10:13:35 <YayMe`> ski: tell me if that makes any sense at all
10:14:32 <YayMe`> (i only modeled one of the two event types on the handler, we can ignore that there are two types of events for the moment as their implementations are quite similar)
10:19:28 <ski> hmm, `inputUser :: Cont Handler (Hw,Ev); inputUser = Cont $ \userInput -> Handler userInput someHardwareEventHandler'
10:20:50 <ski> and then `loginHandler = do (hw,ev) <- inputUser; ok <- attemptLogin (userInputFrom ev); if ok then mainHandler else do sendMessage loginFailed hw; loginHandler'
10:21:17 <aegis__> hey! could anyone give me a hit on why this code is throwing me a nasty little error? I understand it comes from the constraint on "b" (if I use Int instead it works), but my code seems to me quite reasonable... http://lpaste.net/92838
10:21:30 * ski ponders what the difference is here
10:21:31 <mauke> :t take
10:21:32 <lambdabot> Int -> [a] -> [a]
10:21:41 <mauke> :t genericTake
10:21:42 <lambdabot> Integral i => i -> [a] -> [a]
10:22:02 <mr-> aegis__: take wants an Int
10:22:21 <mr-> and so does drop
10:22:38 <aegis__> @mr- that makes sense, I should have checked that; sorry for bothering you!
10:22:38 <lambdabot> Maybe you meant: url src rc msg more arr
10:22:55 <mr-> aegis__: no problem at all
10:23:48 <aegis__> mr-: I've a question though: would you lean towards using genericTake or replacing b by Int?
10:24:27 <mr-> aegis__: I would just use an Int, if possible
10:24:46 <ski> YayMe` : i suppose with your `loginHandler', there can't ever happen anything after the `mainHandler'/`loginHandler' invocation in the body
10:24:59 <aegis__> mr-: also, is there a specific reason why take isn't generic by default? It would work on everything it currently does (Ints), and Integers
10:25:01 <cschneid> why is take so specified? is there a downside to using "genericTake" all the time?
10:25:16 <cschneid> other than it's rather annoying name comparatively.
10:25:18 <ski> YayMe` : while with mine, another Handler could call `loginHandler', and then do something after it
10:25:27 <ski> i'm not sure whether this is good or bad
10:25:45 <mr-> aegis__: I don't know. Probably historic reasons
10:26:15 <aegis__> mr-: noted; thanks!
10:28:00 <pratz> Hello guys
10:28:12 <robindv> There is a very slow statement on line 71, http://lpaste.net/1868603359817105408 anyone knowns a better solution?
10:28:19 <pratz> from within ghci, can I know what all types does Integral has ?
10:28:19 <Ikarus> given a list in haskell with many duplicates, is there an easy way to determine the (maximum) number of duplicates (optionally, I have the elements that might be duplicate in a non-duplicate list)
10:29:44 <ski> > logBase 10 1868603359817105408
10:29:45 <lambdabot>   18.27151712538968
10:29:51 <ski> pratz : perhaps try `:info Integral
10:29:52 <ski> '
10:30:57 <pratz> ski: cool, thanks
10:31:08 <edvo> Ikarus: maximum . map length . group . sort
10:31:11 <Kelet> Does anyone know of any SDL bindings for Haskell that are for SDL 2 (and not 1.2)?
10:31:25 <Kelet> Googling is unfruitful
10:31:39 <Yaniel> @hoogle sdl
10:31:39 <lambdabot> package SDL
10:31:40 <lambdabot> package SDL-gfx
10:31:40 <lambdabot> package SDL-image
10:31:52 <leroux> Kelet: I think they're working on that atm.
10:33:11 <mr-> Ikarus: if your elements can be ordered, you could do something like  maximumBy (comparing length) . group . sort
10:33:32 <mr-> (probably hideous complexity, but easy to write ;-)
10:33:46 <Ikarus> mr-: thing is, I am doing this to reduce complexity :)
10:33:53 <Ikarus> and no, they have no natural ordering
10:34:54 <mr-> hmm, sorry then
10:35:10 <aegis__> haskell is all about beauty anyway, isn't it?
10:35:21 <aegis__> complexity, performance, who cares
10:35:26 <aegis__> as long as it's beautiful :3
10:35:40 <mr-> Ikarus: and the elements are not grouped already
10:35:53 <Ikarus> mr-: they are not
10:35:59 <cybee> anyone around?
10:36:57 <cybee> nobody?
10:37:30 <Yaniel> maybe?
10:38:39 <cybee> is there any way to show which programm is open on which workspace?
10:41:25 <danr> cybee: are you using xmonad? xmobar shows at least which workspaces are populated
10:42:05 <cybee> I'm using dzen
10:42:19 <shachaf> cybee: There's a #xmonad channel (but even there, you should just ask your question, not ask if someone is around).
10:42:38 <cybee> thx
10:47:38 * hackagebot basic-prelude 0.3.6.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.6.0 (MichaelSnoyman)
10:49:39 <beaky> hello
10:50:10 <beaky> how do I put a comma between every element in a [String], and then concat the [String] to a string
10:50:14 <applikativ> ah, hi beaky
10:50:42 <applikativ> > concat ["hello"," ","world"]
10:50:44 <lambdabot>   "hello world"
10:50:55 <beaky> > concat $ intersperse ", " $ map show [1..100]
10:50:56 <lambdabot>   "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,...
10:51:04 <applikativ> h
10:52:00 <ski> > intercalate "," (map show [0 .. 99])
10:52:01 <lambdabot>   "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:52:18 <applikativ> is there still a problem?
10:52:28 * ski has no idea
10:52:38 * hackagebot yesod-auth 1.2.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.3 (MichaelSnoyman)
10:52:40 * hackagebot yesod-bin 1.2.3.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.3.3 (MichaelSnoyman)
10:52:42 * hackagebot yesod-core 1.2.4.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.4.3 (MichaelSnoyman)
10:52:44 * hackagebot yesod-form 1.3.2.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.2.2 (MichaelSnoyman)
10:52:48 <applikativ> uhoh
10:53:01 <aegis__> is it ok performance-wise to use and overuse composition in haskell? It's tempting (and good in terms of correctness) to build functions out of smaller functions but I wonder if is doens't affect performance when you have a function that is composed from 3 other functions which are themselves composed...
10:53:32 <ski> it's usually ok, i think
10:53:34 <mstksg> good in terms of correctness = more correct?
10:53:35 <applikativ> there is trouble sometimes.
10:53:41 <jfhall_> aegis__ that's how you should write haskell
10:53:46 <applikativ> but aegis__ there is a compiler
10:53:59 <ski> @wn correctest
10:54:00 <lambdabot> No match for "correctest".
10:54:04 <jfhall_> a lot of the time there is fusion
10:54:07 <aegis__> applikativ: yep, I just wonder if the compiler is smart enough to do a better job than we would
10:54:15 <jfhall_> which will bind function composition
10:54:36 <aegis__> jfhall_: ok, so no worries about this kind of "exponential" composition?
10:55:07 <jfhall_> aegis__: it can be an issue, but in general that shouldn't be your initial concern
10:55:41 <jfhall_> aegis__: the point of haskell is to write correct, composable code, and let the compiler optimize for you
10:55:59 <mstksg> premature optimization is the root of etc. etc.
10:56:06 <elliott> heh, if only it was always so easy though
10:56:12 <jfhall_> as the compiler and libraries get better, there is more "fusion" (plus other optimiszations) that can occur
10:56:17 <donri> aegis__: you know laziness and inlining makes that more or less indistinguishable from writing out the expanded function by hand
10:56:41 <merijn> elliott: The other option is to wait for edwardk, dons or bos to write a high performance library for solving your problem, no? :p
10:57:25 <enthropy> could/should ghc accept duplicate instances whose implementations are duplicate?
10:57:44 <applikativ> aegis__: there are no worries about exponential composition, it is mostly just inlined and vanishes, but there are a million subtleties of course
10:57:50 <enthropy> specifically I think it's sane to allow multiple  `deriving instance Typeable Foo'
10:58:14 <ocharles> composition and everything doesn't stop you from implementing the wrong algorithm, it should be noted
10:58:21 <jfhall_> indeed
10:58:30 <enthropy> this way you don't need CPP to support versions of libraries that have those instances and those that don't
10:58:39 <jfhall_> the idea is that small composable chunks should be more clear
10:58:41 <ocharles> but for the most part, I don't worry about composition that when i'm building programs - that's something for the profiling step
10:59:13 <quchen> enthropy: You can't have multiple instances of the same thing because of the open world assumption.
10:59:16 <aegis__> thanks for the explanations
10:59:21 <quchen> i.e. there are no "qualified instance imports"
10:59:36 <applikativ> enthropy: yes i often wondered why it needs to balk at its own derived instances when they bump into each other
10:59:55 <k0001> ocharles: Hi. Will you need the GZip thing for your talk?
11:00:02 <enthropy> quchen, I mean when I ask ghc to derive an instance in module A, that's going to be the same code as if the instance was derived somewhere else, right?
11:00:21 <quchen> enthropy: I don't know, but I think that's a sane assumption.
11:00:55 <quchen> The only difference I can think of is an orphan warning, but there may be other subtleties (although I don't expect any).
11:01:03 <donri> enthropy: y u orphan instances tho :(
11:01:34 <enthropy> donri: I want to do typeable/generic things with Cabal's datastructures
11:01:50 <ocharles> k0001: oh hey, i didn't know you hung out here!
11:01:52 <enthropy> Generic being GHC.Generics.Generic
11:02:04 <applikativ> send a patch for missing instances enthropy ?
11:02:11 <ocharles> k0001: i'm not really going to be talking about pipes-tar in the talk, i've already got too much to talk about :)
11:02:24 <enthropy> applikativ: the typeable ones are in 1.18
11:02:49 <enthropy> so to support people with Cabal < 1.18, I now need some CPP
11:02:59 <donri> enthropy: http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH.html#g:6 ;)
11:02:59 <applikativ> oh
11:03:28 <enthropy> which makes things more fragile, since now there are two versions of the same file
11:03:39 <enthropy> only one of which really gets tested
11:03:40 <k0001> ocharles: yeah, I'm frequently here, but I don't talk much :)
11:04:15 <enthropy> donri: that's useful, but you can't use a deriving instance Typeable from TH
11:04:58 <enthropy> there's this http://hackage.haskell.org/package/typeable-th, but I think that's going to break for ghc-7.8
11:05:10 <applikativ> why would anyone use Cabal<1.18 ;)
11:05:46 <enthropy> due to this bug http://ghc.haskell.org/trac/ghc/ticket/8100
11:05:46 <AlecTaylor> hi
11:06:33 <enthropy> applikativ: because it breaks people's non-trivial Setup.hs
11:06:36 <applikativ> hi AlecTaylor
11:07:10 <AlecTaylor> Monads are just function workflows utilising lexical closure?
11:07:37 * applikativ advises against propositions beginning 'monads are ..'
11:08:07 * applikativ advises against propositions with '.. are just ..' in the middle
11:08:14 * AlecTaylor requests applikativ to define "monad"
11:08:31 <ocharles> applikativ's suggestions are just like how monads are just monads
11:08:34 * ocharles watches applikativ explode
11:08:51 <enthropy> maybe you've just defined "function workflows utilising lexical closure" as longer way to say monad
11:08:52 * applikativ splat.
11:09:17 * AlecTaylor thought applikativ swallowed
11:09:44 <applikativ> i define monads by listing them, the so-called ostensive definition: List, Maybe, IO, ...
11:10:31 <applikativ> what is it that List, IO, Maybe, BinaryTree, (->) Int etc. all are?
11:10:53 <enthropy> what are types of kind * -> *?
11:10:53 <applikativ> but e.g. Set isn't
11:12:03 <applikativ> not sure what to say about this new definition, AlecTaylor
11:13:44 <AlecTaylor> What's the definition?
11:14:07 <applikativ> "function workflows utilising lexical closure" -- not that i'm not in favor of it.
11:14:13 <quchen> A Monad is something that is an instance of Monad and obeys the Monad laws. (If it doesn't, it's a Nonad.)
11:14:48 * k00mi thinks giving Set as a counterexample is a bad idea, seeing as the reason it isn't one in haskell is pretty stupid
11:15:03 * applikativ agrees, it was pretty haskellcentric
11:15:39 <elliott> Set would actually be a pain to use as a monad in Haskell even if it was allowed, but anyway.
11:16:32 <quchen> How can Set be a Monad?
11:16:37 <applikativ> no, its just icky since the power set functor is basically the paradigmatic monad
11:16:51 <ski> quchen : it's a monad over a different category
11:17:05 <haasn> Nonad :)
11:17:09 <quchen> ski: And which category is that?
11:18:07 <ski> category of ordered types, i think
11:18:31 <ski> though this makes me wonder which ordering on the sets we want here (if any)
11:18:32 <quchen> ski: Oh, you mean the mathematical Set, not Haskell's Set
11:19:29 <ski> i mean finite sets, implemented by referring to total order on elements
11:19:31 <haasn> quchen: wouldn't Haskell's Set be a monad over the subcategory of Hask that has Ord instances?
11:19:38 <haasn> not sure if that makes formal sense
11:20:30 <quchen> That wasn't my question anyway, which was "How can Set be a Monad", and not "how can Set be a monad".
11:21:02 <ski> with current definition of `Monad', it can't
11:21:25 <k00mi> Oleg did it via Cont IIRC
11:21:25 <quchen> That makes things easier. The reason is because >>= can't require Ord I assume.
11:24:13 <haasn> I'm guessing it would be possible to make a Set-like monad that can eventually be flattened down to a Set (with an Ord constraint) using some sort of kan extension?
11:25:02 <ocharles> there's a whole paper on Set Monad's in Haskell
11:25:10 <ocharles> perhaps it was from the Sunroof author's?
11:25:16 <ocharles> or maybe it was kansas lava
11:26:01 <Reite> So what would >>= do in the set monad?
11:27:10 <quchen> Like list I assume
11:27:25 <haasn> that would be my thought as well
11:27:40 <Reite> ah
11:27:41 <haasn> join' :: Ord a => Set (Set a) -> Set a
11:27:43 <Reite> that makes sense
11:27:52 <haasn> there's one really obvious implementation of this
11:27:55 <quchen> Reite: On the other hand, you can't change the order of lists elements by >>=
11:28:34 <shachaf> You can make a monad for Set that doesn't normalize until you lower it, Codensity-style.
11:28:37 <shachaf> But it's a bad idea.
11:29:17 <quchen> shachaf: i.e. newtype wrap Set, define a Monad for that, and do the normalization when extracting the Set again?
11:29:42 <quchen> (Is that codensity style? Spoiler: I'm just guessing.)
11:29:46 <shachaf> Something along those lines.
11:29:47 <haasn> shachaf: why is it a bad idea?
11:30:21 <shachaf> haasn: Because the set can grow but can never shrink.
11:30:47 <shachaf> With normal monads right-association is generally good, but it can easily be the opposite here.
11:30:48 <haasn> (>>= const Set.empty) ?
11:30:56 <ericmoritz> where is the implementation of mzero and mplus for Maybe?
11:31:11 <shachaf> I think we might not be talking about the same thing.
11:31:15 <shachaf> Here, the CoYoneda-style Set is simpler, and lets you define Functor:
11:31:16 <ericmoritz> I don't see it here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html#Maybe
11:31:49 <quchen> ericmoritz: Control.Monad
11:31:53 <shachaf> data Set' a = forall x. Ord x => Set' (Set x) (x -> a)
11:32:16 <shachaf> You can make a Functor instance for that, and write liftSet and lowerSet to turn Set into Set' and back.
11:33:19 <ski> @quote coyoneda
11:33:19 <lambdabot> No quotes match.
11:33:32 <ocharles> dcoutts: ping
11:33:41 <dcoutts> ocharles: mm?
11:33:59 <ocharles> dcoutts: hey, can I convince you to expose http://code.haskell.org/bzlib/Codec/Compression/BZip/Stream.hsc in that library? :)
11:34:11 <quchen> shachaf: Set' is a type that has a "dummy set" whose only purpose is to be mapped to a proper set using the (x → a) field?
11:34:18 <ocharles> dcoutts: I'd like to use it in pipes-bzlib, but the only interface you provide right now works with lazy bytestrings
11:34:27 <enthropy> quchen: http://ghc.haskell.org/trac/ghc/ticket/8263 follows from our discussion earlier
11:34:31 <dcoutts> ocharles: ah yes, same issue as with my zlib package
11:34:45 <quchen> shachaf: Just asking because foralls are still somewhat mysterious to me, so every time I see one I'm trying to make sense of them.
11:34:48 <dcoutts> ocharles: I've been rewriting it to expose an ST/IO-based interface as the lower layer
11:35:01 <dcoutts> ocharles: but I don't want to expose the really ugly parts because that's just so hard to use
11:35:18 <ocharles> dcoutts: that sounds fine
11:35:26 <shachaf> quchen: It does "map fusion" for a Set.
11:35:27 <ocharles> it sounds like it's on your radar, which is good news
11:35:34 <monochrom> quchen: this "forall" makes an existential type, not a universal type.
11:35:39 <shachaf> quchen: This forall is really an exists, if that helps.
11:35:39 <dcoutts> ocharles: yes, problem is it has been for some time :-(
11:36:08 <monochrom> because GHC doesn't want to hijack one more keyword
11:36:15 <ocharles> dcoutts: hum, anything i can help with? or is it still mostly in your head atm?
11:36:24 <dcoutts> ocharles: I was perhaps too ambitious with trying to do it with ST, and I should perhaps simplify and just use IO and then use unsafePerformIO for the existing lazy bytestring interface
11:36:24 <ski> because the constructor really is polymorphic
11:36:42 <dcoutts> ocharles: if you have more time than me, then yes, help would be good
11:37:00 <monochrom> the constructor, of course, can be said to be a universal type
11:37:04 <dcoutts> ocharles: basic idea is to expose an IO interface that makes the demand really clear
11:37:22 <ski> quchen : `data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)' vs. `newtype CoDensity f a = ProjBind (forall b. (a -> f b) -> f b)'
11:37:26 <dcoutts> ocharles: so no tricky rules on when you can call what
11:37:40 <ski> s/to be a/to be of a/
11:37:41 <quchen> monochrom: Oh right, I remember stumbling upon that earlier.
11:38:07 <quchen> monochrom: I also don't remember how I resolved it, time to open up that logic book again ;-)
11:38:11 <dcoutts> ocharles: so it should use types that make it clear when output is available, and when input is demanded
11:38:21 <ocharles> dcoutts: ok, i like that style of programming
11:38:35 <ski> quchen : `forall a. (..a.. -> ...)' is logically equivalent with `(exists a. ..a..) -> ...'
11:38:52 <dcoutts> ocharles: in the spirit of the attoparsec parse type, but in IO (ideally I would do the base in ST and then just lift to IO for the IO version of the interface)
11:38:58 <lilred> How should I represent union types in SQL?
11:39:27 <quchen> ski:  Ah, it's a law that ∀x.(x => y) = (\exists a. a) => y?
11:39:33 <ski> quchen : so `FMapIncl :: forall a. (a -> b) -> f a -> CoYoneda f b' is almost the same as `FMapIncl :: forall a. (a -> b,f a) -> CoYoneda f b' which is logically equivalent with `FMapIncl :: (exists a. (a -> b,f a)) -> CoYoneda f b'
11:39:38 <quchen> That reminds me to get the \exists glyph in my autoreplace. :-)
11:40:00 <ski> quchen : provided `y' doesn't depend on `x', yes
11:40:17 <ocharles> dcoutts: ok, i'm actually not familiar with attoparsec. oddly everything that needs a parser has usually already been written now :)
11:40:40 <dcoutts> ocharles: oh don't worry, I just meant the type
11:40:42 <Freeway-> sombody can
11:40:44 <Freeway->  tell me what
11:40:47 <Freeway-> need to know
11:40:52 <Freeway->  to leanr haskell or lisp
11:40:54 <quchen> ski: Okay, thanks
11:41:07 <ski> quchen : it's also a classical law that `exists a. (..a.. -> ...)' is logically equivalent to `(forall a. ..a..) -> ...' .. but we tend to not use that in Haskell
11:41:11 <Freeway->  what kind of begining knowldge i need to know
11:41:13 <sclv_> ?where lyah
11:41:13 <lambdabot> http://www.learnyouahaskell.com/
11:41:23 <sclv_> Freeway-: you should be able to just go to that site and get going
11:41:27 <sclv_> you need very little knowledge
11:41:51 <ocharles> dcoutts: the IResult type, or Parser?
11:41:56 <Freeway-> dude
11:41:58 <Freeway->  the see
11:42:01 <dcoutts> ocharles: probably IResult
11:42:02 <Freeway->  i need to code in
11:42:02 <quchen> ski: Well if it's a law in natural deduction then it's one in classical logic as well, no?
11:42:04 <Freeway->  C#
11:42:08 <Freeway->  i can code in C#
11:42:12 <Freeway->  just variebels
11:42:15 <Freeway-> i am beginner
11:43:14 <ski> quchen : natural deduction is a specific style in which a logic can be presented in. that logic can be classical logic, intuitionistic logic, modal logic, &c.
11:43:19 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html :)
11:43:39 <quchen> ski: s/natural deduction/intuitionistic logic/ then.
11:44:01 <ocharles> dcoutts: ok, that makes sense. have you got any partial code done, or should i start from the latest version on hackage?
11:44:04 <lilred> Hey guys, how should I represent union types in an SQL database?
11:44:08 <ocharles> not saying i will be able to, but if i were to...
11:44:13 <quchen> lilred: This is not #sql.
11:44:18 <ski> monochrom : i tend to think of it as depending on the polarity of the subphrase in which "any" occurs -- but possibly this doesn't capture all correct uses of it
11:44:34 <lilred> quchen: but SQL guys usually don't know anything about union types
11:44:43 <ski> quchen : still, the latter one above isn't a law in intuitionistic logic
11:45:14 <jfischoff> lilred: depends. you can have extra columns that are NULL sometimes or make seperate tables
11:45:31 <donri> lilred: http://stackoverflow.com/questions/1730665/how-to-emulate-tagged-union-in-a-database random google :p
11:45:40 <Freeway-> can sombody
11:45:45 <Freeway->  explain me why people programm
11:45:46 <lilred> Thank you a lot jfischoff and donri!
11:45:47 <quchen> monochrom: I understand ∀ and ∃, but my understanding scales very bad ;-)
11:46:24 <quchen> ski: Oh, propositional calculus or something along those lines then?
11:47:39 * hackagebot text-locale-encoding 0.1.0.2 - Encode and decode Text to/from ByteString using TextEncoding  http://hackage.haskell.org/package/text-locale-encoding-0.1.0.2 (MikhailKuddah)
11:49:20 * ski . o O ( "Using Algebraic Datatypes as Uniform Representation for Structured Data" by Markus Mottl in 2003-03-10 at <http://web.archive.org/web/20100131042843/http://www.ocaml.info/oefai/papers/algebraic_dts/> )
11:49:43 <ski> quchen : you can't even express it in propositional logic
11:51:02 <Freeway-> guys i want make
11:51:06 <beaky> hello
11:51:06 <Freeway->  a webrowser
11:51:08 <Freeway->  for muslims
11:51:19 <Freeway-> a browser that forbid porn
11:51:24 <beaky> how do I make a sequence like this: [1, 3, 5, ..., n, n - 2, ... 1]
11:52:00 <nichthus> > [1,3..32] ++ [30, 29..1]
11:52:01 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,30,29,28,27,26,25,24,23,22,21,2...
11:52:09 <ski> > let n = 10 in [1,3 .. n] ++ [n - 2,n - 4 .. 1]
11:52:10 <lambdabot>   [1,3,5,7,9,8,6,4,2]
11:52:30 <beaky> wow
11:52:36 <beaky> how do I do that in c++
11:52:56 * ski doesn't know C++
11:53:09 <nichthus> Maybe that's a question for ##c++.
11:53:27 <Taneb> Wait, that's...
11:53:31 <beaky> but the haskell way is so elegant
11:53:44 <beaky> it looks exactly as I defined it :D
11:53:49 <Taneb> > let foo n = [1 .. n] ++ [n -2, n - 4 ..1] in foo 32
11:53:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:53:59 <Taneb> > let foo n = [1, 3 .. n] ++ [n -2, n - 4 ..1] in foo 32
11:54:00 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,30,28,26,24,22,20,18,16,14,12,1...
11:54:08 <Taneb> Or something idk
11:54:14 --- mode: ChanServ set +o monochrom
11:54:19 --- mode: monochrom set +b *!*@546AAAD8.cm-12-3c.dynamic.ziggo.nl
11:54:19 --- kick: Freeway- was kicked by monochrom (Freeway-)
11:54:24 --- mode: monochrom set -o monochrom
11:55:14 <beaky> > let n = 11 in [1, 3..n] ++ [n - 2, n - 4 ..1]
11:55:14 <lambdabot>   [1,3,5,7,9,11,9,7,5,3,1]
11:55:17 <beaky> wow
11:55:38 <monochrom> haven't you learned haskell for a long time?
11:55:48 <beaky> yes
11:56:20 <beaky> i am still a beginner though :(
11:57:01 <inkjetunito> :o beaky
11:57:36 <t4nk222> hello
11:57:50 <t4nk222> i have a      board n = array ((1,1),(n,n)) [((i,j), 0) | i <- [1..n], j <- [1..n]]
11:58:26 <t4nk222> can i use somehow Show for this one or i need to write own function for formatted showing?
11:58:41 <nichthus> ?instances-importing Data.Array Show
11:58:42 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Array a b, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
11:58:49 <Taneb> There is a show instance, but it's not formatted at all
11:58:49 <merijn> t4nk222: Show won't pretty print it as a board, if that's what you're asking
11:58:55 <monochrom> it has a Show instance already. but it's linear.
11:59:04 <merijn> t4nk222: I believe Show will print "fromList [...]"
11:59:09 <quchen> Also Show isn't for prettyprinting.
11:59:15 <monochrom> in fact, let's try
11:59:19 <t4nk222> merijn: well, so, i need to rewrite Show Array?
11:59:37 <merijn> t4nk222: I would just write "prettyPrint :: Array ?? -> String""
11:59:38 <monochrom> > show (array ((1,1),(2,2)) [((i,j), 0) | i <- [1..2], j <- [1..2]])
11:59:39 <lambdabot>   "array ((1,1),(2,2)) [((1,1),0),((1,2),0),((2,1),0),((2,2),0)]"
11:59:41 <nichthus> The impulse to rewrite instances is one you should eliminate. It can only lead to trouble.
11:59:42 <t4nk222> i want to get pretty board
11:59:52 <ski> @let tabulate ix f = array ix [(i,f i) | i <- range ix]
11:59:53 <lambdabot>  Defined.
12:00:04 <quchen> How about "prettyprint :: Array … → String"?
12:00:09 <merijn> t4nk222: Sure, but why would you need to use show for that? You could just write your own pretty print
12:00:28 <t4nk222> merijn: dont like to re-invent the wheel =)
12:00:30 <monochrom> I suggest: write your own code, and give it your own name.
12:00:32 <ski> t4nk222 : if you use something like ^, you could define it as `board n = tabulate ((1,1),(n,n)) $ \(i,j) -> 0'
12:00:37 <nichthus> ?hackage boxes
12:00:37 <lambdabot> http://hackage.haskell.org/package/boxes
12:00:44 <t4nk222> merijn: thought it is already implemented
12:01:30 <t4nk222> thanks
12:01:38 <merijn> t4nk222: If it's a 2 dimensional array you can write it as: unlines . map (map (foo . snd)) . groupBy ((==) `on` (fst . fst)) . assocs
12:01:56 <nichthus> Don't do that...
12:01:58 <merijn> t4nk222: Just replace foo with a function that returns a single character
12:03:03 <nichthus> merijn: You don't like pretty printing libraries?
12:04:27 <merijn> nichthus: I'm not aware of any that render arrays as squares and anything else needs most of that logic to make it work
12:04:45 <nichthus> I linked to one...
12:05:45 <merijn> nichthus: Still needs to groups lists together and filter out the indices
12:07:47 <merijn> So the only thing boxes would remove from that code is replacing foo with something else and changing the unlines into some other concatenation
12:08:00 <nichthus> hcat [vcat [boxFor (arr ! (i, j)) | i <- [0..whatever]] | j <- [0..whatever]]
12:09:40 <nichthus> advantages: elements don't have to render to a single character for this to look good; easy to swap out vcat/hcat for something that does more pretty-printing later
12:12:40 * hackagebot wai-app-static 1.3.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.2 (MichaelSnoyman)
12:13:31 <mjboa> what's the difference between forall a. [a] and [forall a. a] ?
12:14:21 <nichthus> The former says: pick a type; I am a list all of whose elements are that type. The latter says: I am a list; for each element, pick a type, and I am an element of that type.
12:15:13 <geekosaur> of course the latter is useless because you can't retrieve the type afterward
12:15:17 <ocharles> nichthus: but semantically, how is that different? either way, you have a list of elements of any type (though all the same type, when you choose a type)
12:15:20 <ocharles> oh
12:15:21 <mjboa> ok, that was my intuition, thanks
12:15:58 <nichthus> ocharles: I guess you spotted it, but "though all the same type" is the mistake.
12:17:31 <ocharles> nichthus: no, i haven't spotted it
12:17:38 <ocharles> nichthus: it really says each element can be a different type?
12:17:48 <mjboa> ocharles: yeah
12:18:03 <nichthus> well
12:18:05 <ocharles> weird
12:18:07 <nichthus> To be precise, no.
12:18:09 <n-dolio> @type \(x:y:zs) -> (x :: Int, y :: String)
12:18:10 <lambdabot>     Couldn't match type `Int' with `[Char]'
12:18:10 <lambdabot>     Expected type: String
12:18:10 <lambdabot>       Actual type: Int
12:18:15 <nichthus> Each element has the same type, namely, forall a. a.
12:18:41 <nichthus> Whereas in forall a. [a], once you've fixed a type a, the elements are no longer polymorphic. They all have *that* type.
12:19:07 <haasn> the latter can be an instantiation of the former
12:19:11 <haasn> the same is not true in reverse :)
12:19:16 <haasn> I think
12:19:16 <nichthus> So forall a. [a] can be specialized to [Int], [Bool], [Maybe String], etc.
12:19:24 <haasn> wait nvm
12:19:35 * monochrom has a cunning plan! use impredicative types. in "forall a. [a]", put a = forall b. b :)
12:19:38 <nichthus> But in [forall a. a] you have a bunch of elements, and each can independently be specialized as you please -- to Int, Bool, Maybe String, etc.
12:19:47 <haasn> monochrom: yes that's what I meant
12:19:51 <ocharles> oh, i thought that choosing one would still choose all the rest
12:20:00 <nichthus> no
12:20:05 <ocharles> i guess it expands to (forall a. a) : (forall a. a) : ...
12:20:17 <nichthus> And yes, with impredicative types everything goes wonky, as usual.
12:20:55 <haasn> it's possible to write f :: [forall a. a] -> forall b. [b]
12:20:59 <haasn> (with impredicative types)
12:21:04 <haasn> I think they're equivalent
12:21:11 <haasn> they're both equally useless, that is
12:21:26 <haasn> the only thing you can get out of either of them is a length
12:21:33 <nichthus> maybe so :)
12:22:40 <acowley> What is going on with new hackage and documentation? Some packages are missing docs altogether, others have individual missing pages.
12:23:06 <monochrom> do you mean the beta one?
12:23:13 <acowley> Yeah
12:23:15 <elliott> haasn: only [] inhabits [forall a. a] ignoring _|_
12:23:21 <nichthus> to = \xs. /\b. map (@b) xs                fro = \xs -> xs@forall a. a
12:23:25 <nichthus> haasn: Like that?
12:23:26 <elliott> nichthus isn't right, also
12:23:30 <elliott> (forall a. a) doesn't let you pick
12:23:38 <acowley> I know, beta, but the inconsistency is strange
12:24:09 <haasn> I have no idea what that syntax means nichthus but
12:24:14 <monochrom> yeah, definitely report it, you may have saved their lives
12:24:17 <haasn> λ let f :: [forall a. a] -> forall b. [b]; f x = map g x where g :: (forall a. a) -> b; g x = x
12:24:19 <haasn> ^- is what I wrote in GHCi
12:24:51 <nichthus>  /\ for capital lambda, @ for type application
12:25:37 <haasn> elliott: only [] inhabits forall a. [a] too, ignoring _|_
12:26:05 <haasn> and if you stop ignoring ⊥, they both contain lists of arbitrary lengths containing only ⊥s
12:26:50 <n-dolio> And partial lists.
12:27:15 <haasn> yes
12:28:22 <nichthus> elliott: What does "(forall a. a) doesn't let you pick" mean?
12:29:30 <elliott> nichthus: oh, I misread what you said.
12:29:39 <elliott> I thought you thought (forall a. a) was actually (exists a. a), but you didn't.
12:29:57 <nichthus> oh, right, the difference can be a bit subtle, yeah
12:30:24 <ski> i'd say it's more stark than subtle
12:31:15 <nichthus> Well. My explanation at least didn't highlight the difference, because I wasn't careful about differentiating between the guy building the list and the guy consuming it.
12:33:11 <ski> let's add uniformity principles to Haskell
12:33:31 <sclv_> yes, lets have a haskell uniform!
12:33:43 <sclv_> green jumpsuits
12:34:08 <ski> e.g. we should be able to write `(forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)'
12:34:16 <geekosaur> green jumpsuit apparatus = Monad?
12:34:28 <elliott> ski: by parametricity?
12:34:43 <sclv_> i don't believe that proposition
12:34:44 <joe9>  I am running some usb transactions against a device using System.USB : http://codepad.org/C5xBOCZA . In this code, I would get the usb transaction to do and then find and open the device and run that transaction. Now, I want to leverage this code so that I can have multiple similar devices connected and I pick which one I want to run the transaction on.
12:34:45 <ski> elliott : i suspect parametricity doesn't grant us that
12:34:55 <sclv_> its very strong -- what logics allow that?
12:35:00 <elliott> I think it does, for any f and g?
12:35:06 <joe9> To do that, I would have to move the DeviceHandle to a parameter.
12:35:29 <nichthus> Does Haskell even have parametricity?
12:35:32 <sclv_> oh, haha you're right, parametricity is blunt
12:35:32 <elliott> examine the argument at a = (). output the same constructor as you get, and then from{Left,Right} the argument's output when demanded for a specific a
12:35:42 <joe9> I could change the functions to be -> DeviceHandle -> IO () or, I could use a state monad or some such.
12:35:44 <elliott> since it has no way to switch from Left to Right depending on the choice of a because of parametricity
12:35:47 <elliott> no?
12:35:49 <ski> sclv_ : then how about `(forall S : Power Nat. exists n : Nat. R(S,n)) -> (exists n : Nat. forall S : Power Nat. R(S,n))' (which is the original one) ?
12:36:05 <joe9> just wanted to check if there is a better way of going about it.
12:36:52 <joe9> When I start the program, it identifies the multiple devices, prompts me for which one I choose to run the transactions against. and then run different transactions against each such device.
12:36:56 <ski> elliott : in any case, it would be related to parametricity
12:37:07 <ski> (or some readings of it)
12:38:26 <ski> sclv_ : the intuition for the latter one being that there is no way to pick a natural number for *each* subset of the natural numbers, except by picking the same one for all of them
12:39:03 <sclv_> hmm... this feels related to the AoC
12:39:12 <elliott> ski: in essence, my claim is that foo :: (forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a); foo x = case (x :: Either (f ()) (g ())) of Left _ -> Left (fromLeft x); Right _ -> Right (fromRight x) is fully defined
12:39:17 <n-dolio> (forall a. Either a (Not a)) -> Either (forall a. a) (forall a. Not a)
12:39:38 <elliott> right, internalised parametricity contradicts LEM, I think that is widely known?
12:39:52 <ski> and the intuition for `(forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)' would be that a value of type `forall a. Either (f a) (g a)' has to decide whether it is `Left ...' or `Right ...' (or perhaps bottom), without being able to depend on what type is chosen for `a', and because we can choose any type for `a', we should thus be able to extract `Either (forall a. f a) (forall a. g a)'
12:40:13 <ski> sclv_ : how so ?
12:41:17 <sclv_> ski: well you get an ordering and you choose it freely.
12:41:30 <sclv_> ok that's not useful
12:41:35 <ski> ordering ?
12:41:44 <sclv_> i'm not feeling very articulate about this, sorry
12:42:45 <ski> of course, `(forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)' probably wouldn't work in a type-passing implementation
12:42:55 <joe9> I think Reader monad is ideal for my situation
12:42:56 <sclv_> the HoTT book has a description of how to view AoC in terms of exists and forall commute
12:43:10 <sclv_> it seems to translate to this case for me, but i can't quite put it together
12:43:31 <sclv_> it also helps to clarify why there's something nonconstructive about it
12:43:36 <ski> (where you perhaps pass sizes of respective types to enable more unboxing, or perhaps to describe layout of data to GC)
12:43:58 <aristid> joe9: note that Reader r a is "the same" as r -> a
12:44:05 <ski> sclv_ : i'd say "distribute" rather than "commute", no ?
12:44:18 <sclv_> hmm... that might indeed be better.
12:44:35 <joe9> aristid: thanks.
12:45:17 <ski> sclv_ : `(a : A) -> ((b : B) * R a b)' being equivalent to `(f : A -> B) * ((a : A) -> R a b)'
12:45:20 <Thulsadum> good evening
12:46:02 <n-dolio> That one is constructive.
12:46:12 <joe9> aristid: is a Reader monad a good way to pass the device handle around?
12:46:17 <n-dolio> But you probably meant R a (f a).
12:46:37 <joe9> I have functions that do different things using a device handle.
12:46:41 <n-dolio> You get problems when you squash things.
12:47:09 <joe9> I currently have each such function open and close the device. I want to change that to pass the devicehandle to each function instead.
12:47:35 <ski> n-dolio : er, yes
12:47:49 <ski> "squash" being quotients, yes ?
12:48:30 * ski still hasn't accepted LEM following from AoC
12:49:22 <n-dolio> Something of the sort.
12:49:56 <n-dolio> All the truncations that people talk about in HoTT, too, probably.
12:50:24 <n-dolio> It's not terribly clear to me how it creates problems.
12:50:34 <ski> which ?
12:50:54 <n-dolio> Putting squashing in the theorem of choice.
12:51:26 <n-dolio> Like, it'd be simple if it just said, "you've squashed away relevant information and are conjuring it back up."
12:51:39 <n-dolio> But you also resquash out any information you've conjured.
12:51:55 <n-dolio> So it seems kosher at first blush.
12:54:42 <enthropy> could -XRecordWildCards be faked for an extensible record?
12:56:03 <enthropy> you have pattern quasiquotes
13:02:02 <haasn> no it's still statically typed
13:02:08 <haasn> or am I misunderstanding
13:02:14 <haasn> I mean uh
13:02:16 <haasn> monomorphically typed
13:02:41 * hackagebot minimal-configuration 0.1 - Minimal ini like configuration library with a few extras  http://hackage.haskell.org/package/minimal-configuration-0.1 (MariusGhita)
13:02:53 <haasn> oh, are you talking about implementing something similar to RecordWildCards for extensible records?
13:02:59 <ski> let `A' be any proposition, and define `U' and `V' as subsets of `{0,1}' by `U = {x : {0,1} | x = 0 \/ (x = 1 /\ A)}' and `V = {x : {0,1} | (x = 0 /\ A) \/ x = 1}'
13:03:08 <ski> now `forall S : {U,V}. exists x : {0,1}. x \in S', so by AoC, we get `exists f : {U,V} -> {0,1}. forall S : {U,V}. f(S) \in S'
13:03:37 <ski> open this and consider `f(U)' and `f(V)' which are elements of `{0,1}'. if `A' holds then they must be equal (since `U' and `V' then are equal); so if they're not equal, `not A' holds
13:04:28 <ski> alternatively if they are (both) equal (to `0' or to `1'), then both `U' and `V' contain `0', or they both contain `1' (because `f(U) \in U' and `f(V) \in V'), in which case `A' holds
13:04:35 <ski> n-dolio : ok ?
13:05:09 <ski> (note that `{0,1}' here is discrete : has decidable equality)
13:07:26 <scanlonman> Hello everyone, is "Learn You a Haskell for Great Good!" still a recommended book?
13:07:32 <johnw> yes!
13:07:34 <ski> i believe so
13:07:43 <scanlonman> Thank you!
13:13:51 <n-dolio> ski: I've worked through the construction before.
13:14:05 <aleator> How efficient is acidState? I've got terrible performance with hedis and am looking for replacements
13:15:28 <n-dolio> I just don't have a good intuitive sense for where the operation that I would deem non-constructive is happening.
13:17:31 <n-dolio> For instance, I don't think I believe that adding quotient types necessarily lets you prove excluded middle.
13:18:16 <ski> i don't think so either
13:18:29 <Taneb> aleator, it's pretty good, I think
13:18:40 <ski> i think the problem in the above is the (purported) proof of `forall S : {U,V}. exists x : {0,1}. x \in S'
13:18:43 <n-dolio> But I'd have to work through a lot more to figure out where that argument above fails for the formulation of quotient types I'd add.
13:18:46 <enthropy> haasn: yes
13:19:12 <ski> we have to ask, what does `{U,V}' mean here ?
13:19:24 <n-dolio> Yes, that's not even a thing.
13:19:38 <ski> possibly it means `{S : Power {0,1} | S = U \/ S = V}'
13:20:06 <enthropy> haasn: the problem is that when I have     let [wildp| |] = (x .=. 1 .*. y .=. 2 .*. emptyRecord)
13:20:07 <ski> or perhaps something more subtle that doesn't even let us computationally detect whether we got an `U' or a `V'
13:20:31 <enthropy> haasn: the wildp quaisquote doesn't know what's on the right hand side
13:20:46 <haasn> enthropy: I'm not familiar with the new extensible records system, sorry. I haven't looked at them yet
13:21:05 <enthropy> haasn: I mean for HList-type records
13:21:29 <enthropy> I don't think it has anything to do with new things
13:21:42 <ski> assuming the former case, i think `forall S : {S : Power {0,1} | S = U \/ S = V}. exists x : {0,1}. x \in S' oughtn't to work, because the `S = U \/ S = V' condition here ought to be a condition whose information can't be used to "exhibit" any information in the result, here the `\/'
13:22:03 <jfischoff> aleator: what are you seeing with hedis? I ask because I use it, but haven't profiled it
13:22:53 <n-dolio> Was the original Diaconescu (I think) paper using something this set-theory-ish?
13:23:16 <n-dolio> Oh, it was.
13:23:21 <ski> n-dolio : e.g. a cauchy sequence is a sequence of reals satisfying a certain property. we don't want the result of functions from the reals to be able to depend on *how* we have proved this property -- but if we have a function from reals to reals, then we can use the information in this property to prove the corresponding information in the property for the output real
13:23:53 <ski> n-dolio : i'm not sure. <http://en.wikipedia.org/wiki/Diaconescu%27s_theorem> seems to list a variant of the above (i haven't considered it in detail)
13:23:59 <enthropy> haasn: I guess I can do -XRecordPuns though
13:25:19 <ski> (the variant i described above comes from "Elements of Intuitionism" by Michael Dummet. "A Course in Constructive Algebra" also has a (very brief) formulation, but i wasn't able to decide it)
13:25:33 <n-dolio> ski: Anyhow, I thought I saw an article a while back where one of the HoTT guys was talking about this....
13:25:43 <ski> ok ?
13:26:28 <n-dolio> And he was implying that the 'theorem of choice' was what you get with pi and sigma, and the 'axiom' was more like if you insisted that the theorem still held for arbitrary types even when your 'forall' and 'exists' were truncated to propositions.
13:27:13 <DRiKE> anyone successfully compiled ghc for ARM (raspberry pi)? my compilation fails with 'ghc-cabal: /tmp/32486.o: does not exist'
13:27:52 <n-dolio> But I'm not sure I see what's wrong with that, either. Because when I think about squashing things, it tends to be all right to eliminate such that you 'create' information as long as your result squashes it away.
13:28:18 <n-dolio> Which is what the propositional choice thing looks like.
13:28:42 <n-dolio> I may not have fully understood what the article was getting at, though.
13:29:14 <elliott> maybe the problem is that the "exists" info has to be lifted out of a truncation too many? or something.
13:29:18 <elliott> to distribute.
13:29:22 <elliott> hi, I know nothing.
13:31:00 <n-dolio> Like, 'forall a:A. exists b:B. R a b' doesn't have a function from A to B, but neither does 'exists f:A->B. forall a. R a (f a)'.
13:31:03 <n-dolio> If it's squashed.
13:31:28 <n-dolio> So it's okay in that respect.
13:32:01 <zzing> Does anyone know if the new xcode coming is compatible with ghc? It didn't work with one of the betas, but that was about two months ago.
13:32:38 <ski> n-dolio : well, it could be that to compute the result, you need the "squashed" input info, even though the answer doesn't depend on the exact proof of it ?
13:32:41 * hackagebot HaRe 0.7.0.3 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.3 (AlanZimmerman)
13:33:01 <ski> or is this a notion of "squashing" where the info isn't present at run-time ?
13:35:04 <ski> there's also stuff like for every `x' on the "complex unit circle", there is an `y' such that `x = y^2', but you can't make a global continuous choice of `y' given `x'
13:37:47 <n-dolio> I would expect that the information doesn't (need to) exist at runtime.
13:37:58 <ski> or `forall x : |R. exists n : |Z. |x - n| =< 1/2', which i don't think ought to be provable on a constructive interpretation of `exists', but which could be fine for a weak one, as in your last squashing case above
13:38:05 <n-dolio> I don't really know how propositional truncation works in HoTT, though. I need to read the book.
13:39:05 <ski> i think possibly both variants (no run-time info vs. run-time info present, but "real" result may not essentially depend on it (though may depend on its presence)) have merit
13:39:29 <exicer> Oh man, I'm trying to understand conduits - reading the conduits chapter of the yesod book - and I can't even understand the type signatures
13:39:56 <n-dolio> I don't think you could prove the |x - n| <= 1/2 without introducing something that would obviously be the non-constructive culprit.
13:40:11 <exicer> How should I interpret Resource m => Conduit Int m Text ?
13:40:43 <ski> well, i mentioned the `|x - n| <= 1/2' one, because a book suggested it as a refutation of (general) AoC (they assumed the premise above to be evidently true)
13:42:19 <Twey> exicer: That's a Conduit that takes Ints to Text in the m monad, isn't it?
13:43:37 <exicer> Twey: I don't really get the "in the monad m" part (I am still getting to grips with monads).
13:43:46 <exicer> Could you give an example using Maybe ?
13:43:58 <elliott> maybe do that part before conduits :) it's considerably more fundamental
13:44:03 <Twey> exicer: You should probably hold off on Conduit and read the monad chapters of LYAH or something, then
13:44:18 <bitonic> is there a quick way to build a package with an executable target through a sandbox?
13:44:19 <exicer> Oh, no I get the definition of monads, and even (kinda) understand some
13:44:28 <bitonic> so without installing any libraries required globally
13:44:42 <exicer> Does in the monad just mean, using values that are "wrapped" in Just,  or Nothing ?
13:45:11 <exicer> So it takes something like it takes Int to Maybe Text  ?
13:45:16 <Twey> exicer: If m = Maybe, then it's a conduit that takes an Int and eventually produces a Maybe Int (if I remember correctly)
13:45:27 <Twey> Yeah, more or less
13:45:44 <shoret> is there a way (that could be used e.g. in a pre-commit hook) to tell whether ghc -Wall produced any warnings?
13:46:01 <exicer> Right, that actually makes sense then.. all of the stuff in the type signature with a lack of arrow confused me :p
13:47:15 <n-dolio> ski: I don't know. Maybe. I'd have to think a while about what equality of that existential type is.
13:47:57 <donri> Twey: type Conduit i m o = ConduitM i o m () -- so presumably it produces Maybe () in the monad, and yields Text to the next Conduit or Sink
13:48:06 <donri> exicer: ^
13:48:26 <ski> n-dolio : talking about `{S : Power {0,1} | S = U \/ S = V}' or what ?
13:48:45 <n-dolio> ski: No, exists n: |Z. |x - n| <= 1/2.
13:48:51 <ski> ok
13:49:16 <n-dolio> To compute n, you need the representation of r. But to get that, you need to eliminate a quotient, which requires that you produce results that respect the quotient.
13:49:17 <ski> with a strong reading, it means that you can compute `n'
13:50:20 <shoret> answering my own question: use -Werror
13:50:21 <n-dolio> So it would require proving that you produce 'the same proof' for all equivalent representations of r.
13:50:25 <ski> with a weaker reading, it could mean that you can compute an `n', but it may depend not only on the actual real number `x', but also on how it's represented as a cauchy sequence -- but then you only get to open the existential if you promise that your end result won't depend on the actual `n' being computed
13:50:33 <Twey> Yeah
13:50:34 <n-dolio> So you have to decide what 'the same proof' is for that exists.
13:51:49 <ski> (so the end result depends only on the knowledge that there "exists" (in this weak sense) a natural number, but mayn't depend on *which* such natural number is computed)
13:52:04 <donri> exicer: but if you were after an analogy, i guess you could say it's like Int -> IO Text if m = IO. that's not how it's implemented though.
13:52:42 * hackagebot mwc-random 0.13.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.0.0 (BryanOSullivan)
13:53:02 <ski> n-dolio : with strong `exists', it must be the same `n' for equivalent Cauchy sequences, and the same proof of the inequality
13:53:09 <ski> with weaker `exists', hmm
13:53:31 <donri> exicer: (btw did you mean MonadResource not Resource?)
13:54:47 <ski> with the "no run-time" `exists', there is no witness for `n', so only the proofs of the inequality would be compared, i think (whatever that means)
13:55:11 <ski> with "mustn't depend on actual value" `exists', i'm not sure
13:58:18 <donri> exicer: and you should check out pipes too
14:11:51 <d3lxa> with esqueleto, any idea how to filter out maybe/null values when doing a join? I use innerJoin, but still got maybe type
14:13:00 * hackagebot tensor 0.3.0 - A completely type-safe library for linear algebra  http://hackage.haskell.org/package/tensor-0.3.0 (NicolaSquartini)
14:21:54 <applicative> @tell dcoutts It seems the user accounts mail gizmo on beta.hackage.etc is working
14:21:54 <lambdabot> Consider it noted.
14:22:07 <dcoutts> applicative: yep, thanks
14:22:23 <applicative> oh there you are.
14:22:28 * dcoutts also checked it out this morning after johnw fixed the mail setup
14:31:18 <aegis__> hey! what's the naming convention for a "tree" variable? i.e. xs for lists
14:32:07 <donri> "tree"
14:32:10 <shachaf> Lots of conventions. It depends on the tree.
14:32:13 <ocharles> aegis__: depends on the tree doesn't it? In a binary tree, you might use 'l' and 'r'
14:32:17 <shachaf> For example, "l" and "r" for -- yes, that.
14:32:25 * ocharles zooms past shachaf 
14:32:32 <aegis__> I see
14:32:53 <shachaf> You can always use the McBridesque (Tree cs u js)
14:32:56 <donri> don't be afraid to use variable names longer than two characters
14:33:49 <shachaf> I'd be afraid of triggering some strange untested edge case in the GHC parser.
14:33:54 <ski> aegis__ : sometimes i use `at' for a tree of `a's
14:34:04 <ocharles> i find mcbride-notation requires i get out a tome of classic literature
14:35:12 <ocharles> You could also use edwardk notation, and have ATreeLike and then T c k y f g h a
14:35:15 <bgamari> What is the "*" type in a GHC heap profile?
14:38:08 <Twey> ocharles: I think you mean T k i l e v r y o n
14:38:36 <shachaf> Twey: "s t a b" is my fault.
14:38:43 <Twey> shachaf: How's that?
14:38:51 <ocharles> Twey: :)
14:38:54 <shachaf> What do you mean?
14:39:06 <ocharles> Twey: it used to be a b c d
14:39:07 <ocharles> iirc
14:39:12 <Twey> shachaf: Did you drive edwardk to his homicidal rage?  :þ
14:39:14 <Twey> Oh, I see.
14:39:26 <elliott> edwardk notation is bt/seta
14:39:45 <edwardk> no, that should have been 'best eva' but it was a typo
14:39:57 <Twey> Heh
14:40:11 <elliott> types hungarian is (a) proof our tooling sucks; (b) addictive.
14:40:21 <shachaf> Twey: https://github.com/ekmett/lens/commit/495d8c95396132cbad6b56cdf62ca586dd6555ad
14:40:58 <Twey> shachaf: Got it :þ
14:41:52 <shachaf> I think "GeneralizedIndexedRelevantTraversal i m m a s t a b u" was edwardk, though.
14:43:12 <Twey> Haha
14:43:40 <joelteon> the longest english word you can spell with distinct one letter type variables is
14:43:46 <joelteon> u n c o p y r i g h t a b l e
14:43:58 <shachaf> They aren't always distinct.
14:44:12 <joelteon> Yeah, but if you wanted distinct ones.
14:44:17 <monochrom> I don't like hungarian. it doesn't scale to type systems such as HM or above
14:44:39 <Twey> joelteon: I'll bear that in mind next time I'm writing GPL'd code.
14:45:02 <Twey> What is ‘type Hungarian’?
14:45:58 <elliott> Twey: naming variables after their types in very generic code.
14:46:11 <Twey> Ah, like that.
14:46:12 <elliott> along with hole-based programming it simplifies knotty but polymorphic definitions (e.g. Cont's monad instance, say) immensely.
14:46:23 * Twey nods.
14:46:28 <elliott> seta is what we call the (s -> Either t a) functions in prisms
14:46:42 <monochrom> the hungarian notation was invented at a time when you couldn't hover your mouse to a name and have the editor display its type above
14:47:19 <elliott> well, there is something to the immediate visual knowledge that since you have an "ab" and an "a", you can easily satisfy the need for a b
14:47:19 <Twey> Eww, mice.
14:47:33 <sclv_> yeah i agree
14:47:34 <elliott> were the types always displayed alongside the names (and abbreviated to not be cumbersome), then yeah, it would not be so necessary
14:47:53 <sclv_> sometimes when i'm just working through 'how do i write this value given these functions'
14:47:57 <elliott> on the other hand, for code generic enough that it helps a lot, the variables don't often have more useful names than "f" and "x" anyway, so naming after the types does no harm
14:48:04 <sclv_> then the 'type hungarian' names are as expressive as i can be
14:48:09 <elliott> though I draw the line at "fmap ab ..."
14:48:12 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/parallel-crc  -- if anyone wants to take a look through and make sure i don't have any glaring typos/bugs, that would be awesome
14:48:30 <Twey> For concrete types it doesn't make a lot of sense, because the names should already describe their types by what they are… but very generic or abstract values just beg for type-abbreviation, especially since there isn't much other semantic meaning to attach to them
14:48:31 <sclv_> elliott: you can always do a2b or fab
14:49:00 <ocharles> erm, am i being stupid here? Do we a have function that's like a fold over booleans, like maybe for Maybe?
14:49:08 <Twey> ocharles: No.  ☹
14:49:09 <johnw> edwardk: you were taught about CRCs in grade school?
14:49:23 <donri> ocharles: not in base no
14:49:24 <edwardk> long division =P
14:49:32 <ocharles> Twey: gah, i have to bring in a lambda and if just for this!?
14:49:32 <edwardk> and yes. weren't you?
14:49:35 <donri> @hackage cond
14:49:36 <lambdabot> http://hackage.haskell.org/package/cond
14:49:36 <johnw> haha
14:49:45 <ocharles> donri: don't really want to go outside base, this is for a talk
14:49:49 <monochrom> supposedly if' is the fold over booleans
14:49:59 <donri> ocharles: agreed, i want a 'bool' function too
14:49:59 <johnw> nice article!  cant' read it in full now, but I love the subtitles
14:50:01 <Twey> ocharles: I usually define bool : r → r → Bool → r
14:50:01 <monochrom> does lambdabot have if' ?
14:50:07 <edwardk> johnw: that BackEndError thing has been getting worse all day
14:50:08 <monochrom> > if'
14:50:10 <lambdabot>   Not in scope: if'
14:50:10 <lambdabot>  Perhaps you meant f' (imported from Debug.SimpleReflect)
14:50:14 <donri> monochrom: if' has the wrong type, usually, methinks
14:50:16 <Twey> It used to
14:50:16 <johnw> edwardk: which BackEndError thing?
14:50:22 <Twey> But yes, the argument order is backwards
14:50:29 <donri> monochrom: (and name!)
14:50:41 <ocharles> I might suggest this to libraries
14:50:44 <edwardk> johnw: see comment in haskell-lens: [17:45] edwardk:	 johnw: i keep getting errors like "BackendError "Could not lookup 9862062bef330ecc9f8d22790e212a2f6464a14d: Object not found - failed to find pack entry (9862062bef330ecc9f8d22790e212a2f6464a14d)""       on the FP complete site about every 5th or 6th time i do something
14:50:49 <monochrom> alright, if cond floats your boat, all the better
14:50:54 <edwardk> johnw: i'm getting tweets from other people who can't read the post
14:51:05 <edwardk> and its been slowly getting worse all day
14:51:05 <johnw> omg, that's horrific
14:51:19 <ocharles> there is no 'bool' in base, so it's free there
14:51:30 <johnw> let me check the logs
14:51:53 <Twey> I'm not totally happy with naming eliminators after their types, but it's an established tradition now
14:52:16 <ekipan> @define bool t f b = if b then t else f
14:52:17 <lambdabot>  Defined.
14:52:25 <ekipan> er
14:52:28 <shachaf> It should be f t b
14:52:29 <ekipan> @define bool f t b = if b then t else f
14:52:30 <lambdabot>  .L.hs:153:1: Warning:
14:52:30 <lambdabot>      Pattern match(es) are overlapped
14:52:30 <lambdabot>      In an equat...
14:52:32 <donri> ocharles: it should be bool f t b = if b then t else f and it should be in Data.Bool and possibly even Prelude.
14:52:36 <donri> ocharles: IMHO :)
14:52:50 <ekipan> definitely
14:52:55 <ocharles> donri: agreed
14:53:03 <Twey> Aye
14:53:06 <sclv_> edwardk: that crc thing is quite nice
14:53:13 <ekipan> @undef
14:53:14 <lambdabot> Undefined.
14:53:15 <ocharles> donri: searching fpcomplete hoogle show's five (!) equal definitions in different libraries
14:53:16 <edwardk> thanks!
14:53:24 <edwardk> it turned out _way_ more elegant in the end than i expected
14:53:37 <Twey> If we have ‘maybe’ and ‘either’ in Prelude there's no excuse not to have bool as well
14:53:39 <donri> ocharles: people seem to often get this wrong. they want to put the True case first, or even the boolean first too, but that's all inconsistent with the other catamorphisms
14:53:43 <monochrom> Twey: how would you like to name them?
14:53:53 <bgamari> What is the * type in a GHC heap profile?
14:53:55 <ocharles> donri: yea, I figured you put False first because maybe has Nothing first
14:53:59 <donri> ocharles: and doesn't compose as nicely
14:54:00 <bgamari> do I recall correctly that this was a closure?
14:54:01 <ocharles> and either has Left first
14:54:10 <donri> ocharles: yeah
14:54:14 <Twey> monochrom: Probably elimMaybe, elimBool, …
14:54:34 <ocharles> donri: just being consistent seemed good enough, if it makes for better composition - great!
14:54:45 <ekipan> it makes sense that false is "less" than true
14:54:49 <donri> ocharles: well at least putting the boolean last does
14:54:55 <ekipan> and the cases should be in order
14:55:06 <Twey> ‘bool’ makes sense for a Church encoding where the eliminator is the type
14:55:16 <donri> i guess the folds are in the wrong order though?
14:55:18 <donri> :t foldl
14:55:19 <lambdabot> (a -> b -> a) -> a -> [b] -> a
14:55:19 <monochrom> it makes sense that falsehood comes before truth, no? :)
14:55:39 <ocharles> should I be emailing libraries@ for this?
14:55:40 <ekipan> we need a:   list nil cons = foldr cons nil
14:55:43 <donri> ocharles: yes!
14:56:06 <monochrom> no, not foldr please. this is not about argument order
14:56:16 <sclv_> <3 streaming calculations
14:56:18 <Twey> Or you could always get all classy and class Elim a f | a → f where elim ∷ f
14:57:04 <monochrom> the eliminators should have the exact strength of the case-of pattern-matching construct. no more no less.
14:57:33 <Twey> True
14:58:25 <ekipan> is foldr not that for lists?
14:58:36 <monochrom> no
14:58:37 <Twey> It's not the same sort of thing
14:59:03 <Twey> list ∷ r → (a → [a] → r) → r is missing too
14:59:04 <monochrom> case-of doesn't come bundled with a hardwired recursion. therefore list's eliminator should not, too.
14:59:10 <donri> they're all catamorphisms, no?
14:59:22 <ekipan> I see
14:59:32 <Twey> donri: They're all eliminators, to be sure
14:59:59 <monochrom> elimination /= catamorphism. you have to pick one and stick to it. they happen to be equal for boring types such as Bool
15:00:03 <Twey> But you can write foldl with list easily, whereas list with foldr is a pain
15:00:29 <Twey> (statement also holds when made consistent)
15:02:13 <applicative> what are the magic words I put in my ~/.cabal/config if I insist e.g. that my already-installed version of bytestring or pony be used?
15:02:30 <monochrom> constraint: bytestring installed
15:02:36 <monochrom> another line for pony
15:02:47 <applicative> ah thanks, i was close
15:02:48 <ocharles> alright, proposed
15:02:51 <ocharles> lets see what happens
15:03:00 <monochrom> see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
15:03:33 <monochrom> you can also do it on the command line, if you don't want it permanent/pervasive
15:03:39 <applicative> ah yes, monochrom thanks; i want to see how it interacts with the sandbox machinery in particular
15:05:37 <mstksg> is it safe to say that if i use ghc to compile to c, i can just distribute the c and everyone can compile it as native binaries and everyone is happy?
15:05:43 <bgamari> Does Data.Vector.Vector have a Distributive instance somewhere
15:05:52 <monochrom> no, it is unsafe
15:06:36 <ekipan> doesn't ghc require a very specific (bundled) gcc because of the evil mangler?
15:06:45 <bgamari> blarg, need type-sized vectors
15:06:53 <ekipan> I wonder if llvm bitcode would be more useful for your purpose
15:07:02 <bgamari> ekipan, I don't believe the evil mangler does any mangling any more
15:07:22 <applicative> mstksg: ghc only makes c in special circumstances anyway; have you looked at jhc?
15:07:37 <mstksg> applicative: i haven't
15:08:11 <applicative> the appeal of jhc has always been making that simple; it is buildable again as ajhc, but is ahem, a work in progress
15:08:11 <merijn> Also, isn't the C backend deprecated and slated for removal?
15:08:13 <mstksg> i just wonder if there's a way i can produce and distribute haskell software without the end user needing ghc
15:08:27 <merijn> mstksg: Just build binaries and distribute those?
15:08:43 <merijn> mstksg: How did you think windows software was sold?
15:08:44 <arkeet> mstksg: that is sort of how ghc gets ported to new platforms.
15:08:49 <applicative> https://github.com/ajhc/ajhc mstksg
15:08:59 <merijn> mstksg: The only downside is that you need to build for every OS/architecture combination
15:09:07 <mstksg> all windows runs under the same architecture?
15:09:25 <mstksg> or do i need to package multiple binaries
15:09:40 <applicative> merijn: the c backend is used for various purposes still, new platforms ; i guess thats what arkeet was saying; or so it was recently
15:09:42 <Twey> Heheheh
15:09:42 <merijn> mstksg: No, even on windows they need a different version for different architectures, but windows only really supports x86 and x86_64 anyway and the latter can transparently run the former
15:09:42 <mstksg> actually i'm sure this is a general software distribution question and has little to do with haskell
15:09:52 <edwardk> johnw: one thing that may be a factor is i do have a dozen or so extra articles waiting 'in the wings' for me to finish them.
15:10:04 <geekosaur> there is 32 vs. 64 bit, but windows hasn't practically supported anything other than x86 for a long time. (well there is arm win8, but nobody's doing anything serious on that)
15:10:16 <edwardk> johnw: so if you have something that is marginal with regards to timeouts, i may be just pushing you over the edge
15:10:34 <merijn> mstksg: What sort of clients do you have in mind? Will this be inside a company where you have control over the hardware? b2b, consumer software?
15:10:43 <Twey> mstksg: Well, the Windows solution is to ship a ‘side by side configuration’ with your application that contains everything the application needs to run.
15:10:44 <johnw> edwardk: AWS should never be that sensitive in this area
15:11:00 <johnw> I just found one possible problem, going to hotfix production now to see what effect it has
15:11:03 <merijn> mstksg: Consumer software is the biggest problem, for B2B or whatever you can just compile the proper version on-demand
15:11:35 <Twey> Windows tends to grow a bit over time…
15:11:38 <merijn> mstksg: Basically, distributing haskell in binary is exactly the same as shipping C or C++ binaries
15:11:54 <elliott> modulo gmp
15:12:03 <merijn> elliott: That's just another library
15:12:22 <mstksg> merijn: it's mostly a general question, but one in specific right now is technically b2b but i don't have full control over what platforms they use and i'd like to just use a nice tidy package that works for all of theirs.  but yeah, i think i'll read up on C/C++ distribution because i feel like there is nothing unique to haskell in this problem
15:12:25 <merijn> No different from any other library dependency in C/C++
15:12:34 <elliott> merijn: with licensing issues
15:12:41 <elliott> integer-simple etc.
15:12:50 <merijn> elliott: How so? gmp has LGPL with static linking exception
15:13:35 <elliott> uh, or some issue.
15:13:38 <merijn> Actually, I'm not 100% sure on the static linking exception of gmp, but C libraries are by default dynamically linked anyway
15:13:39 <elliott> I forget whether it's licensing or what.
15:13:46 <edwardk> switching to an ipad so i can keep track of what is going on
15:13:48 <merijn> Which means you still comply
15:14:49 <merijn> mstksg: If you're doing B2B you could just call it "specialisation/customisation/install services" and build and test copies specifically for the business that's paying as extra service
15:15:02 <applicative> monochrom: hm, 'cabal sandbox _' balks at the 'constraint: pony installed' fields in the local cabal.config .  I wonder if this is a bug or the nature of the case
15:15:30 <merijn> mstksg: You maybe have to do a bunch of fiddling, but once you do that you can reuse those changes for all future clients with the same platform
15:15:49 <merijn> mstksg: Basically JIT creation of binary packages ;)
15:16:04 <applicative> i need 'constraint: text installed' too keep my machine from melting every 10 min; and constraint: edwardk installed for another reason
15:16:20 <edwardk> :P
15:16:33 <hpc> edwardk obeys no restraints
15:16:42 <monochrom> mstksg: I am not sure whether I agree or disagree with "not language-specifc". even you seem to show a disparity. you're assuming "all computers you care have C compilers, but no Haskell compiler". what is the logical conclusion of that? answer: you can't say that C and Haskell are on equal footing.
15:17:03 <hpc> i have seen systems ship without gcc
15:17:22 <hpc> which makes for some serious awkwardness when they also ship without wireless drivers :(
15:17:52 <merijn> hpc: That'd make me happy, provided they had another compiler for C instead :p
15:18:30 <donri> like visual studio
15:18:56 <hpc> there was nothing
15:19:06 <hpc> no gcc, no make
15:19:12 <merijn> donri: more like clang/icc/whatever sun's compiler is called
15:19:31 <merijn> I'm thoroughly impressed by icc and sun's stuff
15:19:45 <monochrom> applicative: "constraint: pony installed" leads to errors when pony is not present in any database considered.
15:19:49 <donri> or tinycc
15:20:11 <hpc> merijn: i have heard good things about the intel assembler too
15:20:27 <monochrom> therefore, for example, if pony is in --user, and you use sandbox, which suppresses --user, you have a problem
15:21:26 <merijn> hpc: With idb gone we should see a nice increase in gdb quality
15:23:05 <applicative> monochrom: so it is the content of the field, not the field itself; or however you say it
15:24:18 <applicative> monochrom: yes, i want it to look to --user for explicitly mentioned things; but i suppose this is a recipe for disaster.
15:24:38 <applicative> monochrom: or a reason for installing the haskell platform ....
15:25:26 <monochrom> if you want a lib visible to all sandboxes, such as base, you have to put it in --global, such as base is.
15:25:46 <applicative> maybe i should just put a few heavy duty libraries I'm unlikely to have anythign to do with like text and vector in --global
15:25:58 <monochrom> or else, you have to convince sandboxes to include --user. but I am not sure any sandbox providers like it.
15:26:26 <mstksg> monochrom: by that, i meant that the issues i would have to deal with in distributing a binary (and not source code) are not too different in haskell than they are in C++ etc
15:26:35 <Twey> I thought the point of a sandbox was that it was uncontaminated by system configuration.
15:26:58 <applicative> yes, i'm not sure i grasp what would be involved in the latter; but it occurs that rebuilding text -- which presumably has a huge size as built anyway -- is really pissing me off
15:27:11 <applicative> rather, that's whats really pissing me off
15:28:00 <applicative> so i should put it in --global  but this suggests i should decide what all else to put there
15:28:03 * hackagebot cookbook 0.1.3.0 - An independent library of common haskell operations.  http://hackage.haskell.org/package/cookbook-0.1.3.0 (NatePisarski)
15:29:12 * applicative wonders what's in Cookbook.Continuous 
15:30:40 <monochrom> do take inspiration from Haskell Platform
15:30:41 <acowley> applicative: I think what's needed is something like the --sandbox=DIR option for setting a base sandbox
15:31:13 <acowley> applicative: Or maybe a variant of add-source like add-sandbox
15:31:26 <joe9> Is there a ReaderIO monad? I could use ReaderT m IO (), but, just wanted to check if there is a ReaderIO monad instead.
15:31:57 <applicative> acowley: yes, something like that, I keep thinking, but I'm still not sure I understand what the picture Mikhail G wants me to have is, yet
15:32:23 <monochrom> no ReaderIO. go ahead with ReaderT x IO.
15:32:34 <joe9> monochrom: ok, thakns.
15:32:43 <applicative> monochrom: yes, it seems it will be haskell platform minus the gui-ish stuff maybe.
15:33:45 <monochrom> I think there is quite some market of "Haskell Platform sans OpenGL"
15:34:32 <tinyghost> what's wrong with OpenGL in Haskell Platform
15:34:36 <applicative> i guess it is a platitude that this whole thing will morph one's picture of global user sandbox
15:34:48 <applicative> and their relations
15:34:52 <applicative> tinyghost: oh nothing
15:35:15 <acowley> Is OpenGL really that big a problem? I've installed it on Mac, Windows, and Linux without trouble
15:35:44 <mstksg> any way to check for redundant build-depends in my cabal file?
15:35:47 <applicative> acowlaigh i have no trouble on os x
15:36:27 <mstksg> i'm not very organized so i just throw things in there to test but forget to take them out later
15:36:27 <monochrom> there is no relation between market demand and problems
15:36:44 <acowley> mstksg: I don't know of an automated tool to do that, so I usually try pulling things out and rebuilding :/
15:36:54 <donri> mstksg: there's a silly way: move the .cabal file and cabal init to get a list of minimal depends
15:36:55 <applicative> tinyghost: i would end up installing all of it but mostly locally; this is turning out to untenable with sandboxes, since i end up installing a quarter of it in every sandbox
15:37:13 <acowley> monochrom: Why do you think there is a market, then?
15:37:24 <monochrom> because there is free will
15:37:30 <applicative> tinyghost: since as monochrom was saying, the sandboxed ignore your local --user cabal stuff
15:37:39 <edwardk> I continue to just trash my system state as needed ;)
15:37:40 <acowley> applicative: I just bite the bullet and have giant sandboxes everywhere :/
15:37:52 <tinyghost> ah D:
15:37:59 <acowley> edwardk: sanboxes with add-source makes life easier, I find
15:38:02 <monochrom> no wonder everyone is reporting "my sandbox is 2GB" :)
15:38:04 <edwardk> I've yet to figure out a good workflow that includes a sandbox
15:38:07 <ReinH> edwardk: your new SoH article is down :(
15:38:13 <applicative> acowley: yes thats what i have now, it isn't even that i care about that it is building text and vector that kills me
15:38:18 <edwardk> ReinH: It's up just click a lot
15:38:28 <acowley> edwardk: I add-source the handful of my own packages I'm working on, and everything gets pulled in automatically without me having to cabal install everything
15:38:47 <monochrom> text takes a long time to build
15:38:52 <acowley> applicative: I hear ya.
15:39:03 <applicative> all of my hard won conceptions are outdated
15:39:27 <applicative> everything solid melts in the air, everything sacred is profaned, now that we have sandboxes
15:39:31 <edwardk> Maybe I'll sit down with some folks and try to figure out a more productive way to work at ICFP
15:39:53 <acowley> applicative: You should make that a sign for a school playground
15:40:50 <acowley> edwardk: It saves you when you're tweaking one package that's being used as a dep of another. You can tweak, then build the downstream package for testing. When everything's working, push the new versions.
15:41:22 <applicative> criterion should go in --global clearly, and presumably quickcheck  actually that decides quite a few things
15:41:43 <applicative> if its not wrong to begin with
15:41:47 <acowley> Sometimes packages want a particular version of quickcheck. Just sandbox everything and see how it goes!
15:42:07 <applicative> its true
15:42:10 <edwardk> I just tweak, then go build the other stuff. Thrashes maybe a dozen packages
15:42:34 <applicative> edwardk: you mean using --local not a sandbox
15:42:47 <edwardk> I'm sad that I can't benchmark some code on old hash able, due to constraints in criterion
15:43:23 <edwardk> I strongly suspect the reason why the cola can't benefit from the filter is hashable 1.2
15:43:32 <monochrom> rename old hashable to another package name. maybe also rename modules.
15:43:34 <edwardk> applicative: Yes.
15:43:45 <applicative> if you were actually using edwardk-land in your sandboxes you'd know what me and acowley are talking about!
15:44:17 <edwardk> More effort than I was expecting to put in. As it is I'll just write a lighter weight weak hash class
15:44:20 <acowley> Welcome to the sandbox, watch it bring you to your knees
15:44:23 <applicative> Downloading profunctors-x.y.z; Building freefooT-a.b.c
15:45:00 <acowley> applicative: I actually find it pretty satisfying how complicated some of these builds are and how smoothly they come together in the sandbox
15:45:05 <edwardk> I get the experience when I migrate GHC versions
15:45:11 <dcoutts_> edwardk: the right solution to this is private dependencies
15:45:21 <acowley> edwardk: But now you can have it every other day!
15:45:37 <edwardk> Dcoutts: I export instances in almost all of those cases
15:45:43 <applicative> acowley: yes, actually, i take a special pleasure in it too
15:45:51 <edwardk> They are very much part of my public API
15:45:51 <dcoutts_> edwardk: e.g. criterion, does it expose its use of hashable?
15:46:01 <edwardk> Oh. Sorry for that, he's
15:46:03 <edwardk> Er yes
15:46:22 <edwardk> Had switched topics in the meanwhile and was confused :)
15:46:34 <dcoutts_> :-)
15:46:59 <dcoutts_> edwardk: if not then it should not matter what version of hashable it uses, and private deps would let us do that
15:47:03 * applicative knows nothing about 'private dependencies'; it sounds dangerous
15:47:26 <dcoutts_> applicative: it gives enough info to the solver to know when it's safe to use multiple versions of a package
15:47:36 <dcoutts_> we have a design for it worked out
15:47:40 <dcoutts_> but the project
15:47:42 <dcoutts_> erm
15:47:43 <applicative> i see, it is not an existing mechanism.
15:47:52 <dcoutts_> but that bit of the project didn't get completed
15:48:04 * hackagebot hexpat-lens 0.0.4 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.0.4 (JosephAbrahamson)
15:49:44 <edwardk> Now I wonder if I can modify the CRC trick todo Fletcher checksums like Adler32
15:49:49 <acowley> Making cabal-install accept --dependencies-only as well as --only-dependencies is probably my favorite feature addition to any software for 2013
15:52:02 <merijn> acowley: Even more than the fact that "cabal build/test/haddock" now automatically running "cabal configure/build" if needed?
15:52:32 <acowley> merijn: Yes. It's such a long flag to type in that when you get it backwards it's super frustrating.
15:52:51 <donri> acowley: i just tab complete it
15:53:01 <acowley> edwardk: Have you had any more thoughts on resource tracking in machines? The issue on github seemed to go off track and stall.
15:53:15 <donri> acowley: also you can use word transpose to swap those if you get the order wrong
15:53:36 <acowley> donri: I would need a smart shell for that, wouldn't I? Whenever I try another shell, things seem to break.
15:53:55 <donri> acowley: that's all bash
15:54:01 <acowley> donri: I meant backwards in the sense that, when typing it, I would think "No, no, --only-dependencies is the wrong one, --dep-only is the right one!"
15:54:29 <acowley> donri: How can I teach my bash about the ways of the cabal?
15:55:10 <YayMe`> I know of the and function, and all, but I couldn't help letting my imagination get away from myself, is this a terribly stupid use of the maybe monad? http://stackoverflow.com/questions/18729768#18730017
15:56:05 <johnw> cabal 1.18 and pkg-config are driving me nuts
15:56:32 <johnw> i'm getting this: https://gist.github.com/6516930
15:56:34 <donri> acowley: might depend on the OS. on my fedora system it's automatically done. otherwise it might be something like . /etc/bash_completion
15:56:40 <johnw> but it only happens running under Jenkins, not when I run it myself at the shell
15:58:09 * hackagebot data-extra 2.5.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.5.0 (ChrisDone)
15:58:11 * hackagebot data-extra 2.5.1 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.5.1 (ChrisDone)
15:58:15 <donri> acowley: also if you type --only-dependencies and hit M-e it changes it to --dependencies-only
15:58:27 <donri> acowley: sorry, M-t
15:59:05 <acowley> donri: Sounds like sorcery. Wouldn't I need the point to be there, too?
15:59:06 <applicative> YayMe`: it is sort of like doing instance (Eq a , Applicative f) => Eq (f a) where ... . As people sometimes do for Num
15:59:26 <Fuuzetsu> Is there a way to tell GHC to not optimise my modules? I basically want the same optimisation level as if I was loading the module into GHCi (none at all I believe)
15:59:38 <donri> acowley: the cursor needs to be right after it yes
16:00:05 <acowley> Fuuzetsu: -O0
16:00:58 <ekipan> YayMe`: whether it's stupid or not I can't say, but I can shorten the definitions of your "lifted boolean" comparisons:  boolToMaybe True = Just True; boolToMaybe False = Nothing
16:01:05 <acowley> donri: I've installed bash-completion, my bash is still ignorant
16:01:16 <edwardk> acowley: I'm talking to tekmo and Snoyman about exception handling tonight actually
16:01:21 <YayMe`> applicative: That's interesting... they do this as a convenience or you mean because they don't know something (which I probably don't as well)
16:01:30 <YayMe`> ekipan: I thought about that but then you don't get the nice infixity
16:01:32 <acowley> edwardk: Is that a regular thing you guys do?
16:01:34 <ekipan> YayMe`: then   x |!?| y = boolToMaybe (x !? y) -- for each operator !?
16:01:47 <applicative> YayMe`: I think the instance  I mentioned has a pile of downsides
16:01:59 <edwardk> Not so much
16:02:11 <ekipan> I'd actually make that   Just (), since you aren't using False
16:02:15 <acowley> edwardk: I worry that it's easy to overthink this
16:02:16 <YayMe`> ekipan:  it's a difference of mightBe $ bla >= alb vs bla |>=| alb
16:02:22 <edwardk> Working on improving communication though
16:02:29 <donri> acowley: yeah you may need to source something in your bashrc. i forgot how you do it when the system doesn't do it for you.
16:02:39 <YayMe`> applicative: Yeah, sounds like something I'd do.
16:02:45 <ekipan> YayMe`: define your operators based on it:  x |==| y = boolToMaybe (x == y)
16:02:52 <edwardk> acowley: Sure. I just got busy with other things and machines languished
16:03:09 * hackagebot data-extra 2.5.2 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.5.2 (ChrisDone)
16:03:11 <YayMe`> ekipan: I was thinking about that as well, that does actually make more sense. Either way it's a silly nonsense approach to the problem
16:03:19 <applicative> are these definitions the equivalent of liftM2 (>=) and similarly?
16:03:24 <ekipan> {- or even -} (|==|) = (==) `on` boolToMaybe
16:03:48 <YayMe`> applicative: Nah, liftM2 wouldn't automate False->Nothing
16:04:12 <edwardk> guard?
16:04:43 <ekipan> @src guard
16:04:44 <lambdabot> guard True  =  return ()
16:04:44 <lambdabot> guard False =  mzero
16:05:04 <arkeet> > [guard False, guard True] :: Maybe ()
16:05:05 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ()'
16:05:05 <lambdabot>              with actual...
16:05:08 <arkeet> > [guard False, guard True] :: [Maybe ()]
16:05:09 <lambdabot>   [Nothing,Just ()]
16:05:12 <YayMe`> edwardk: Yeah, that would perfectly define my `mightBe` i was imagining
16:05:18 <edwardk> I use it a lot when I need to give back a result or fail conditionally
16:05:36 <ekipan> @src mzero Maybe
16:05:37 <lambdabot> Source not found. I feel much better now.
16:05:43 <edwardk> x <$ guard (p x)
16:05:47 <ekipan> didn't lambdabot used to be able to show methods like that?
16:05:55 <edwardk> ekipan: Nothing
16:05:59 <applicative> > guard (3 == 2) :: Maybe Bool
16:06:00 <lambdabot>   Couldn't match type `()' with `GHC.Types.Bool'
16:06:00 <lambdabot>  Expected type: Data.Maybe.M...
16:06:03 <applicative> bah
16:06:06 <ekipan> well obviously, but the question still stands
16:06:07 <applicative> i never use guard
16:06:23 <YayMe`> > guard $ 3 == 2
16:06:24 <lambdabot>   No instance for (Control.Monad.MonadPlus m0)
16:06:24 <lambdabot>    arising from a use of `e_13...
16:06:30 <edwardk> applicative: You need a version that also returns the art
16:06:35 <ekipan> is there a way to query lambdabot for instance methods?
16:06:36 <mstksg> donri: i guess that's worth a shot haha thanks
16:06:38 <edwardk> Er arg or something
16:06:47 <ekipan> the source of instance methods
16:06:49 <merijn> ekipan: What do you mean by method?
16:07:11 <ekipan> like I could ask lb the src of (>>=) under ((->) r) for instance
16:07:18 <applicative> isnt there @info as in ghci?
16:07:24 <applicative> oh
16:07:37 <merijn> There's @src, but @src is filled with lies
16:07:54 <ekipan> how to you phrase such a question?
16:07:58 <applicative> no, it just uses the hbc implementation
16:08:01 <ekipan> @src (>>=) (->)
16:08:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:08:25 <joe9> any idris users here? do you like Effects?
16:08:29 <merijn> ekipan: Normally I'd just use hoogle to look at the real source
16:08:29 <acowley> How do I use the bash-completion file that comes with cabal-install?
16:08:38 <joe9> not sure if thy are as good as monads. just wanted to check.
16:09:08 <merijn> ekipan: ((->) r) monad instance can be found in Control.Monad.Instances
16:09:32 <YayMe`> I suppose to take the example I wrote to the Nth degree then you could simply define and as \arr mapM_ guard arr == Just ()
16:09:33 <applicative> it would certainly be pleasing to be able to pull of the main trick in Haskell
16:09:34 <merijn> joe9: Effects are competing with monad transformers, not with monads, as far as I understood
16:09:36 <ekipan> well for answering a newbie question I'd like to be able to get lambdabot to just print a method src real quick sometimes
16:09:51 <applicative> joe9: yes, as merijn says.
16:09:57 <joe9> merijn: yes, misspoke that.
16:10:01 <ekipan> I know what ((->) r)'s (>>=) is
16:10:02 <merijn> ekipan: The @src in lambdabot are just handcoded rules and they don't cover all possible sources
16:10:16 <applicative> monad transformers are actually not as bad as these academics think
16:10:18 <merijn> ekipan: The only really reliable way are the source links on Hackage
16:10:24 <merijn> applicative: "these academics"
16:10:28 <joe9> applicative: ok, thanks.
16:10:32 <applicative> haha
16:10:38 <merijn> applicative: The majority is very skeptical about effects
16:10:39 <Twey> Damn academics.  Can't trust 'em.  Trying to turn us against those poor innocent monad transformers.
16:11:06 <applicative> well, the brilliant effects crowd over-rates the difficulty of monad transformers
16:11:08 <merijn> applicative: So unless "these academics" means "the Idriss guys" that seems a bit of an overstatement
16:11:08 <applicative> there
16:11:25 <acowley> I avoided MTs for a long time due to the weirdness with composition
16:11:27 <applicative> oh, this approach has been around for a while
16:11:34 <Twey> I think it's less about difficulty and more about awkwardness
16:11:38 <edwardk> Hah
16:12:05 <edwardk> I find them less awkward and more powerful than the proposed replacements
16:12:07 <merijn> Also, the main problem we discussed was the fact that with Effects you *still* need to provide an ordering to the layering to figure out what's going on
16:12:10 <YayMe`> acowley: I am still succesfully avoiding them! pretty easy when you write C# every day...
16:12:29 <acowley> Now I think we're pretty much able to have foo :: (IElem MyField rs, MonadIO m) => StateT rs m r
16:12:31 <merijn> The only advantage Effects seems to have is that they place nicely with very fine granularity
16:12:41 <applicative> it's strange, i think i believed in the need for fancy effect systems before i actually grasped monad transformers practically.
16:12:49 <merijn> Which doesn't seem to be the case for transformers (given the exponential explosion you'd get in mtl)
16:12:51 <applicative> now i don't know what i was thinking
16:13:29 <merijn> The Idriss example I saw had to manually encode the layering of effects to get the order you (implicitly) get from monad transformers, thus mostly eliminating any benefit
16:13:53 <acowley> I was scared off because in my earliest days of Haskelling we wallowed in the misery of ordering issues with MTs
16:13:53 <edwardk> merijn: Just can't safely define Reader or write lazy Writer at all
16:14:21 <applicative> when i was studying the little Frank language, i remember thinking there was a curious mental regression involved.  he wanted Maybe to be a 'effect', for example
16:14:31 <edwardk> or deal with non Typeable states, ST..
16:14:50 <applicative> everything was turning into something like an exception
16:15:05 <joe9> Is this a good way to go about transforming my code to readerT monad: before:  http://codepad.org/9tqPsX1q  http://codepad.org/yhyTFXQ2 , after: http://codepad.org/3bicnzQr  http://codepad.org/FfscJWNC
16:15:42 <ekipan> why 4 pastes instead of 1?
16:16:03 <joe9> ekipan: you are correct. will post 1 in a minute.
16:16:17 <edwardk> Looks like my CRC trick can be adapted to Fletcher and Adler checksums as well. I guess that means this will be a 2-parter
16:16:27 <johnw> you don't need to nest the runReaderT like that
16:16:32 <joe9>  http://codepad.org/Rk9je0Ui
16:16:36 <johnw> in maintainer2, don't call ask, just call sendTxn1 directly
16:16:42 <johnw> it will inherit the Reader environment from the caller
16:16:56 <joe9> johnw: ok, thanks.
16:17:00 <johnw> otherwise, if you use runReaderT like that, it's not different that just passing it as an argument everywhere
16:17:18 <johnw> the idea is that intermediate functions can ignore the reader environment
16:17:32 <applicative> another curiosity of the algebraic effects crowd is that they follow something like moggi's enumeration of effects / notions of computation, which strangely we dont.  Nobody thinks of the Maybe monad as expressing an 'effect'.
16:17:48 <edwardk> True
16:18:06 <joe9> jjjj:r
16:18:12 <joe9> sorry about the other line.
16:18:15 <applicative> once you enter monad land you drop the moggi account altogether it seems, only IO really fits his picture. everything else is just value manipulation for us. I'm putting this wrong
16:19:06 <applicative> but pigworker is busily working at his maybe effect, his state effect his this effect that effect, when for me they all have, e.g. show instances
16:19:56 <Twey> applicative: Do we not?  The behaviour of (>>=) under Maybe can have the ‘effect’ of ‘stop the computation’
16:20:21 <applicative> yes, of course
16:20:53 <acowley> applicative: I think the idea is to more uniformly account for things
16:20:55 <applicative> similarly concatMap has the 'effect' of making the next indeterministic draw
16:21:04 <Twey> Aye
16:21:27 <applicative> but i feel it is regression to use what is basically an exception system where we use e.g. Maybe as if it were air
16:22:11 <Twey> Perhaps
16:22:12 <joe9> johnw: is this what you meant wrt maintenance2 :  http://codepad.org/oGMOUFo2 . I get this error: http://codepad.org/PRDv32xF
16:22:19 <acowley> Yeah, hmm. We need a proponent of the approach to argue its merits.
16:22:19 <Saizan> separating the uses of Maybe-as-computationa-context vs. Maybe-as-data has its uses
16:22:27 <acowley> Saizan: Why?
16:22:52 <applicative> acowley: I'm making like i'm against it. It's bottomlessly interesting of course.
16:22:56 <johnw> joe9: code is missing, can you show me the whole thing?
16:22:57 <Twey> I usually think of effects as being a specialization — you temporarily put aside some of the power of MTs for nicer composition
16:23:01 <johnw> i don't see where you're calling maintenance2
16:23:02 <acowley> applicative: Yeah :)
16:23:20 <johnw> or what the signature of sleep is
16:23:26 <Saizan> acowley: e.g. things like liftM2 might get automated
16:23:29 <johnw> i think you just need "liftIO (sleep 1)"
16:23:30 <acowley> Twey: It's not clear that it *is* nicer, though, if your still have ordering concerns
16:23:41 <johnw> and also liftIO for readTransactionsShowFilePath
16:23:42 <acowley> Saizan: Ah, now that's a good point
16:23:47 <Twey> Yes
16:24:09 <applicative> somehow i feel like once you get accustomed to haskelly modes of combination, you sort of lose your grip on what they were worrying about under the heading of "Maybe-as-computational-context"
16:24:20 <Saizan> also, the way you specify the semantics of effects is not really more an exception system than the Free monad is
16:24:25 <applicative> it was just an opaque idea that vanishes in the light of day
16:24:50 <Twey> That was always the selling point of DD — that functions like ‘map’ can work on IO &c. just like on pure values, with no need for a separate mapM
16:24:54 <Saizan> it might be a bit more like alpfelmus(?)'s operational
16:25:03 <joe9> johnw: this is the full code: http://codepad.org/Go9zaBYU . Instead of having the device in SendTxn. I want to move the getMyDevice to the main function.
16:25:16 <johnw> see my liftIO comments
16:25:16 <joe9> and, I am thinking of using the ReaderT to do that.
16:25:17 <Twey> ‘apfelmus’
16:25:19 <elliott> Saizan: one too many ls :)
16:25:22 <shachaf> Twey: But mapM has more infromation than map.
16:25:27 <elliott> the opposite of my problem!
16:25:33 <Saizan> acowley, Twey: yeah, having only one "map" isn't bad either
16:26:19 <Saizan> shachaf: Frank has laziness explicit in the types
16:26:31 <applicative> It hadn't occured to me that Heinrich Apfelmus is violating the old hackage requirement for 'real name'
16:26:32 <Twey> shachaf: The extra information in an effect system is carried by the effect
16:26:38 <joe9> johnw, the sleep line is commented out.
16:26:39 <acowley> Saizan: Are these potential benefits realized in any of today's contenders?
16:26:50 <Twey> applicative: I thought he was just blessed with a silly name
16:26:50 <shachaf> OK. So the information is there.
16:27:03 <acowley> applicative: I think we agreed to accept that as his or her real name
16:27:11 <shachaf> That sounds more like "functions like mapM can be used without newtype noise", in that case.
16:27:11 <joe9> jonhw, if you are talking about the sleep in line 91
16:27:20 <johnw> joe9: then how can you have a syntax error on 101 in your paste, when 101 is commented out in your code?
16:27:21 * applicative adopts Johnny Appleseed
16:27:33 <Saizan> shachaf: yeah, it might be more like that
16:27:48 <joe9> johnw, sorry, wrong error. I will paste the error in a second.
16:28:00 * applicative reconsiders in favor of Joe Babyfood
16:28:10 <shachaf> Did you see http://timmaxwell.org/pages/monad-embed/ ?
16:28:13 <Twey> shachaf: But you can write effect-polymorphic functions
16:28:17 <joe9> johnw: http://codepad.org/DOS2UgVb very sorry about that.
16:28:39 <Saizan> acowley: Frank has something, but it's mostly a proof of concept
16:28:43 <shachaf> Twey: Yes, and mapM is monad-polymorphic.
16:28:45 <johnw> it's still complaining about a commented-out line?
16:28:52 <johnw> oh, there's a cat
16:28:54 <shachaf> I don't know much about Frank, so maybe what I'm saying is nonsense.
16:29:00 <applicative> Frank has cool syntax
16:29:15 <johnw> joe9: what is at the real line 91 in your code?
16:29:26 <johnw> it's better now to paste in the "cat" line at the top, but just the file itself
16:29:26 <joe9>     (sendTxn1 txn []) >> return ()
16:29:46 <joe9> johnw, ok, makes sense.
16:30:00 <johnw> liftIO (readTransactionsShowFilePath False)
16:32:38 <Saizan> actually Frank's syntax is too much of an ascii soup for me
16:34:02 <Twey> shachaf: I want to say effect polymorphism isn't restricted to monads, but I'm having a hard time thinking of an example for which that's important (if you wrap everything pure in Identity).
16:34:21 <joe9> johnw: file without the cat line: http://codepad.org/R5BdR6ZG
16:35:01 <joe9> johnw: thanks. that worked.
16:35:25 <joe9> johnw: thanks. that makes it easy to code.
16:35:33 <joe9> just put all the non-reader stuff in liftIO.
16:35:54 <johnw> yep
16:36:04 <Twey> joe9: Seems like you should deal with that Maybe earlier instead of using fromJust later on
16:36:25 <johnw> I added a wrapper to hlint so that uses of fromJust show up as on error
16:36:58 <Twey> johnw: Also head, tail, &c.?
16:37:09 <joe9> Twey, good idea. thanks.
16:37:53 <joe9> twey, I should change this to use safe
16:38:11 <joe9> johnw, let me run this through hlint.
16:38:15 <Twey> Pattern-matching usually suffices
16:38:42 <applicative> Saizan: what you have something against type signatures like: if Bool then {[] X} else {[] X} [] X
16:39:13 <Twey> Generally I find the extra overhead of the Maybes safe returns means I might as well have used a pattern-match or eliminator in the first place
16:39:14 <joe9> johnw, would you mind sharing that wrapper please?
16:39:37 <Twey> applicative: I have a lot against [] being an infix operator :þ
16:40:12 <applicative> Twey, oh it isn't really, it's the substitute for -> but can contain 'effects' or whatever
16:40:21 <applicative> i havent looked at it since it came out
16:40:44 <Twey> applicative: Yep.  But it's infix, and the least infix-looking symbol I've ever seen.
16:41:19 <applicative> i'm looking for an example where it pays off
16:41:20 <Twey> ATS does this thing where it expands the arrowhead: int -> int becomes int -<exn,ntm> int
16:41:52 <joe9> johnw: thanks for your help.
16:42:11 <joe9> http://codepad.org/fZ0WrYug is what I have now.
16:42:36 <applicative> sexp [ReadLine, Abort] SExp
16:43:18 <applicative> here this is like sexp :: MaybeT IO SExp.
16:43:56 <applicative> the bracketed material should look like a modal operator [ ] p -> <> p
16:43:59 <applicative> but marked
16:44:12 <Twey> Oh, is that what it's supposed to be
16:44:50 <applicative> main [Console] SExp is like main :: IO SexP
16:45:00 <applicative> but
16:45:01 <applicative> pop (Stk X) [Console] X
16:45:27 <applicative> is like pop :: Kleisli (Stk X) IO X
16:45:48 <applicative> oh wait not the right order for Kleisli
16:46:12 <Twey> joe9: You can change the sequence in isVendorWrite to mapM (. ctSetupMsg) and remove the redundancy
16:46:20 <applicative> pop takes you from a Stk X to an X in a Console-effectful way
16:47:37 <monochrom> onoes, hpaste disappears
16:47:40 <Twey> joe9: By ‘deal with the Maybe’ I meant to pattern-match and do something on the Nothing case, not move the fromJust further up the file.  :þ  You've got a bunch of ‘head’s in there, too.
16:52:58 * applicative seconds Twey 's judgment without even looking at the file. 
16:57:42 <Thulsadum> nice, first non trivial application written in haskell. i'm so proud. :D
16:59:34 <applicative> oh awesome Thulsadum.
16:59:39 <applicative> but what does it do?
17:00:07 <Thulsadum> applicative: it's n irc bot how greets people joining a channel
17:00:51 <SrPx> what happened to clean?
17:00:53 <applicative> oh an irc bot nice.
17:01:07 <monochrom> good good
17:01:13 <Guest51428> what can you do if cabal install fails on a package (I can see what the bug is, and know how to fix it, and have submitted a bug report, but....  How can I get the package to work for me *now* without having to work outside of cabal)
17:01:54 <geekosaur> cabal unpack <pkgname>, go into the directory, fix it, "cabal install" (no package name)
17:01:55 <shachaf> How "outside" is outside?
17:02:04 <shachaf> "cabal unpack" is now "cabal get"
17:02:08 <Thulsadum> applicative: yep, and i like the elegance of haskell, but i think my solution is not the most elegant one :D
17:02:13 <geekosaur> figures
17:02:13 <applicative> Guest51428: what is the failure
17:02:27 <Guest51428> geekosaur- that sounds like it might do it for me, thanks!
17:03:05 <Guest51428> I assume that cabal will handle the upgrade for me later when it is fixed, correct?
17:03:07 <applicative> cabal unpack still works fine for me; there was a warning for the dev version ?
17:03:35 <geekosaur> cabal's bad at upgrades in general, although I don't know what the latest one might have added to deal with it
17:03:47 <joe9> twey: thanks a lot for your feedback.
17:03:48 <geekosaur> (well, realy, it's hobbled by ghc being bad at upgrades)
17:03:50 <applicative> Guest51428: just use a sandbox!
17:05:14 <monochrom> Guest51428: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for what "upgrade" means. in fact, see the whole thing.
17:05:28 <applicative> in order to install the groom package, which is basically a one liner, i must install cpphs and haskell-src-exts
17:05:40 <Twey> joe9: No problem ☺
17:06:26 <applicative> haskell-src-exts is a major environmental menace. i can feel the heat.
17:09:56 <buckmaster> Hey everyone, quick question - I've read that Yesod didn't support authorisation using a MongoDB backend in 2012. Is that still the case? (I asked in #yesod but it's pretty quiet over there)
17:10:57 <Guest2098> geekosaur- sorry, I was kicked off before I could thank you, so thanks!
17:17:48 <applicative> oh buckmaster I think the most effective venue for yesod questions is StackOverflow
17:18:26 <buckmaster> applicative - cheers, I'll try that!
17:35:28 <hpaste> sdb_ pasted “Euler 14” at http://lpaste.net/5440644775621427200
17:35:49 <hpaste> sdb_ revised “Euler 14”: “No title” at http://lpaste.net/5440644775621427200
17:36:17 <sdb_> I'm trying to do Euler 14 in Haskell.. now in an imperative language I would use memoization.. but my functional approach is taking forever. Am I missing something to make this more performant? see above paste
17:37:53 <tabemann> there's libraries that do memoization out there IIRC; mind you they probably are using unsafePerformIO behind the scenes
17:38:23 <Dodek> sdb_: there are at least three things you could do here
17:38:24 <tabemann> there's also an approach I've seen to doing memoization that *doesn't* use unsafePerformIO
17:38:30 <Dodek> one has just been mentioned by tabemann
17:38:41 <tabemann> that relies on top level partial functions
17:39:03 <Dodek> sdb_: as for the second, you can pass memoization map around in nextCollatz
17:39:05 <tabemann> it's mentioned in an answer on StackOverflow by edwardk
17:39:45 <Dodek> sdb_: just create an empty map from Data.Map, and add memoizations to it as needed, passing it as an argument and returning updated map
17:40:09 <Dodek> sdb_: this is a bit cumbersome, so there's also third solution: you can use State monad to make this memoization map implicit
17:40:22 <Dodek> sdb_: and write memoization just like in imperative programming language
17:40:46 <sdb_> I see
17:40:58 <Dodek> sdb_: btw, a while ago i've tried to do exact the same thing as project euler 14, but for different purpose
17:41:13 <Dodek> sdb_: it turned out that memoization actually slowed down my program
17:41:22 <Dodek> sdb_: (it was in c++, though)
17:41:26 <tabemann> http://stackoverflow.com/questions/3208258/memoization-in-haskell < read this
17:41:51 <tabemann> specifically Edward Kmett's answer
17:41:52 <sdb_> is there a more intelligent way of applying these functions that would not need memoization
17:42:30 <adnap> Is there a way to take something like data F = F Int Int and make Int -> F like "deconstruct (Foo x _) = Foo x" without pattern matching?
17:42:35 <tabemann> the advantage of his approach here is that it requires neither passing around a map nor unsafePerformIO
17:42:49 <arkeet> adnap: pattern matching is the only way to deconstruct things
17:43:04 <adnap> s/Foo/F/g
17:43:18 <sdb_> ahh very interesting tabemann
17:43:20 <arkeet> actually
17:43:28 <tabemann> admap: data F = F { getFoo : Int, getBar : Int }
17:43:32 <arkeet> sure.
17:43:37 <arkeet> record syntax helps.
17:43:47 <arkeet> also, ::
17:44:03 * tabemann is a former MLer...
17:44:16 <adnap> deconstruct f = F (getFoo f)
17:44:23 <adnap> Meh
17:44:27 <arkeet> adnap: uh
17:44:31 <arkeet> F (getFoo f) is a type error.
17:44:37 <arkeet> no wait.
17:44:39 <adnap> I don't think so
17:44:44 <arkeet> well, the type you gave is wrong.
17:44:53 <adnap> getFoo :: F -> Int
17:44:59 <arkeet> that would be deconstruct :: F -> (Int -> F)
17:45:00 <adnap> F :: Int -> Int -> F
17:45:12 <adnap> arkeet: Yes, exactly
17:45:19 <arkeet> ok.
17:45:24 <arkeet> lenses!
17:45:37 <adnap> I never gave a type originally
17:45:59 <adnap> Lenses can help?
17:46:02 <ekipan> I'd rather call deconstruct setBar
17:46:09 <arkeet> ^
17:46:17 <adnap> Oh, I see
17:46:26 <adnap> A setBar lens
17:46:30 <arkeet> a bar lens
17:46:37 <ekipan> a lens is a pair of getter and setter
17:46:48 <adnap> I thought there were "setter lenses"
17:46:50 <ekipan> to, uh, a first approximation
17:47:04 <arkeet> @let data F = F Int Int deriving Show
17:47:05 <lambdabot>  Defined.
17:47:18 <adnap> Anyway, there's also...
17:47:29 <arkeet> @let bar :: Lens' F Int; bar f (Foo x y) = Foo x <$> f y
17:47:30 <lambdabot>  .L.hs:162:8: Not in scope: data constructor `Foo'
17:47:30 <lambdabot>  
17:47:30 <lambdabot>  .L.hs:162:19: Not in sc...
17:47:36 <arkeet> @let bar :: Lens' F Int; bar f (F x y) = F x <$> f y
17:47:36 <lambdabot>  Defined.
17:47:43 <arkeet> :t set bar
17:47:44 <lambdabot> Int -> F -> F
17:47:44 <adnap> setBar f = \x -> f { getBar = x }
17:47:55 <arkeet> > set bar 3 (Foo 1 2)
17:47:56 <lambdabot>   Not in scope: data constructor `Foo'
17:47:59 <arkeet> > set bar 3 (F 1 2)
17:48:00 <arkeet> =(
17:48:06 <lambdabot>   F 1 3
17:48:10 <ekipan> > bar .~ 3 (F 1 2)
17:48:12 <lambdabot>   No instance for (GHC.Num.Num (L.F -> GHC.Types.Int))
17:48:12 <lambdabot>    arising from the li...
17:48:13 <adnap> lol
17:48:19 <adnap> I totally fucked everyone up by mixing Foo and F
17:48:22 <arkeet> yep
17:48:35 <ekipan> I've not actually used 'em, don't know my way around the lens functions
17:48:37 <adnap> Notice: @let bar :: Lens' F Int; bar f (Foo x y) = Foo x <$> f y
17:48:45 <ekipan> what the infix spelling of set?
17:48:49 <arkeet> (.~)
17:48:53 <arkeet> you just have your associativity wrong
17:48:55 <ekipan> oh
17:48:57 <ekipan> right yes
17:48:58 <adnap> I thought you use over
17:49:05 <arkeet> adnap: over is for modifying with a function.
17:49:06 <shachaf> arkeet: Well, precedence. Or something.
17:49:10 <arkeet> set l f = over l (const f)
17:49:14 <arkeet> hm, I shouldn't have called that f.
17:49:19 <arkeet> shachaf: yeah that's the word I was looking for.
17:49:40 <ekipan> (bar %~ (*2)) (F 1 2)
17:49:43 <ekipan> > (bar %~ (*2)) (F 1 2)
17:49:46 <lambdabot>   F 1 4
17:50:11 <arkeet> @let foo :: Lens' F Int; foo f (F x y) = (\x' -> F x' y) <$> f x
17:50:12 <lambdabot>  Defined.
17:52:37 <adnap> arkeet: What is 'f' in foo?
17:52:59 <arkeet> adnap: it's the (a -> f b) in Lens s t a b = Functor f => (a -> f b) -> (s -> f t)
17:54:03 <ekipan> type Lens' s a = Lens s t a b
17:54:07 <ekipan> er
17:54:08 <adnap> akiress: It seems to make a Functor of Int...
17:54:11 <ekipan> = Lens s s a a
17:54:27 <arkeet> :t foo
17:54:28 <lambdabot> Functor f => (Int -> f Int) -> F -> f F
17:54:34 <adnap> Yes
17:54:35 <arkeet> adnap: f :: Int -> f Int
17:54:42 <arkeet> F isn't the functor.
17:54:46 <adnap> I know
17:54:48 <arkeet> ok.
17:54:58 <ekipan> :t set
17:54:58 <lambdabot> ASetter s t a b -> b -> s -> t
17:54:59 <arkeet> adnap: do you know how lens works?
17:55:00 <shachaf> id :: Functor f => (F -> f F) -> F -> f F
17:55:10 <arkeet> just roughly.
17:55:16 <adnap> arkeet: I have studied examples before.
17:55:22 <arkeet> like why the types are what they are.
17:55:50 <adnap> arkeet: I have probably forgotten stuff because I haven't adjusted to using them
17:56:02 <arkeet> > foo (Identity . const 3) (F 1 2)
17:56:05 <lambdabot>   Identity {runIdentity = F 3 2}
17:56:22 <arkeet> > foo Const (F 1 2)
17:56:23 <lambdabot>   No instance for (GHC.Show.Show
17:56:23 <lambdabot>                     (Control.Applicative.Con...
17:56:27 <arkeet> ehh
17:56:56 <arkeet> > getConst $ foo Const (F 1 2)
17:56:59 <lambdabot>   1
17:57:05 <arkeet> :t Const
17:57:05 <lambdabot> a -> Const a b
17:57:34 <arkeet> adnap: the particular Functor that gets used depends on what we're doing with the lens.
17:57:38 <arkeet> getting uses Const. setting uses Identity.
17:57:50 <adnap> arkeet: Okay
17:58:18 <adnap> I'm going to do something else. Thanks for the help
17:59:01 <arkeet> > runIdentity . foo (Identity . (+5)) $ Foo 1 2
17:59:02 <lambdabot>   Not in scope: data constructor `Foo'
17:59:05 <arkeet> > runIdentity . foo (Identity . (+5)) $ F 1 2
17:59:06 <arkeet> arghhh
17:59:08 <lambdabot>   F 6 2
17:59:24 <arkeet> anyway, this is basically how over is implemented.
17:59:30 <arkeet> over l f = runIdentity . l (Identity . f)
17:59:38 <arkeet> view l = getConst . l Const
18:00:03 <arkeet> views l f = getConst . l (Const . f) -- nicer parallel with over
18:00:34 <arkeet> > views traverse Sum [1..5]
18:00:37 <lambdabot>   Sum {getSum = 15}
18:00:51 <arkeet> the Applicative instance for Const gives us foldMap for free from that too :>
18:01:00 <arkeet> > foldMap Sum [1..5]
18:01:01 <lambdabot>   Sum {getSum = 15}
18:01:22 <arkeet> lenstastic!
18:03:12 * hackagebot diagrams-svg 0.8 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.8 (BrentYorgey)
18:03:14 * hackagebot SVGFonts 1.4 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.4 (BrentYorgey)
18:05:28 <peterbb> Hi! :) What is the best way to get something "equivalent" to non-linear patterns? I feel guards are a bit verbose. I have tried using View Patterns, and I'm unsure how successfull I was. Example: https://gist.github.com/peterbb/6517990 Any opinions?
18:08:40 <ski> > let (x,(x ==) -> True) = (3,3) in x
18:08:42 <lambdabot>   3
18:09:28 <arkeet> > let (id &&& id) -> (x, (x==) -> True) = 3 in x
18:09:29 <lambdabot>   <hint>:1:17: parse error on input `->'
18:09:32 <arkeet> hm.
18:09:56 <arkeet> do I forget how view patterns work
18:10:45 <arkeet> :t join (,)
18:10:46 <lambdabot> a -> (a, a)
18:11:38 <elliott> arkeet: what do you expect "let f -> x = y in ..." to do?
18:11:58 <arkeet> x = f y
18:12:12 <arkeet> uh
18:12:16 <arkeet> I don't know!
18:12:57 <peterbb> ski: yes, that's what I've tried.
18:13:36 <ski> > let ((id &&& id) -> (x, (x==) -> True)) = 3 in x  -- la la la
18:13:37 <lambdabot>   3
18:14:39 <ekipan> > let (x,(x ==) -> True) = (3,4) in x
18:14:40 <lambdabot>   *Exception: <interactive>:3:5-30: Irrefutable pattern failed for pattern (x...
18:14:52 <ekipan> > let ~(x,(x ==) -> True) = (3,4) in x
18:14:53 <lambdabot>   *Exception: <interactive>:3:5-31: Irrefutable pattern failed for pattern (x...
18:15:06 <ekipan> I suppose the view would need the ~
18:16:01 <ski> > let (x,(x ==) -> ~True) = (3,4) in x
18:16:02 <lambdabot>   3
18:16:28 <ekipan> an elaborate way of spelling "3" to be sure
18:17:07 <arkeet> > let (x,(x+) -> y) = (3,4) in y
18:17:08 <lambdabot>   7
18:17:23 <arkeet> > let (x,join (,) -> y) = (3,4) in y
18:17:24 <lambdabot>   (4,4)
18:17:24 <ekipan> that's just silly
18:17:32 <arkeet> > let (join (,) -> y) = 3 in y
18:17:33 <lambdabot>   (3,3)
18:17:37 <arkeet> > let join (,) -> y = 3 in y
18:17:38 <lambdabot>   <hint>:1:14: parse error on input `->'
18:17:42 <arkeet> ah, so my problem was parentheses.
18:18:42 <haasn> > let ((x ==) -> True, x) = (3,3) in x
18:18:42 <arkeet> > let (join (,) -> (y,(y==) -> True)) = 3 in y
18:18:43 <lambdabot>   *Exception: <interactive>:3:5-31: Irrefutable pattern failed for pattern ((...
18:18:43 <lambdabot>   3
18:19:00 <arkeet> interesting
18:19:06 <ekipan> views and arrows, needs more lenses
18:19:15 <ekipan> somebody jam some in
18:19:30 <arkeet> > let ((bacon ==) -> True, bacon) = (3,3) in bacon
18:19:31 <lambdabot>   Not in scope: `bacon'
18:19:33 <arkeet> I thought so.
18:19:58 <haasn> > x == 3
18:19:59 <joelteon> > let (bacon, (bacon ==) -> True) = (3,3) in bacon
18:19:59 <lambdabot>   False
18:20:00 <lambdabot>   3
18:20:06 <haasn> oh..
18:20:09 <arkeet> :t x
18:20:09 <lambdabot> Expr
18:20:23 <arkeet> > (x + x) + x = x + (x + x)
18:20:23 <ski> > let (memo (0,12) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib 12
18:20:25 <lambdabot>   <hint>:1:13: parse error on input `='
18:20:26 <arkeet> > (x + x) + x == x + (x + x)
18:20:26 <haasn> so they get bound from left to right, only
18:20:28 <lambdabot>   False
18:20:28 <haasn> sadness :(
18:20:29 <arkeet> yeah
18:20:30 <lambdabot>   144
18:20:58 <arkeet> :t memo
18:20:59 <lambdabot> Ix i => (i, i) -> (i -> e) -> i -> e
18:21:09 <arkeet> huh
18:21:15 <arkeet> @index memo
18:21:15 <lambdabot> bzzt
18:21:17 <ski> you can guess how it's implemented
18:21:25 <arkeet> unsafePerformIO and an array?
18:21:33 <ski> no `unsafePerformIO'
18:21:35 <arkeet> oh.
18:21:37 <arkeet> an array then.
18:21:42 <ski> yes
18:21:47 <arkeet> ok, and laziness.
18:21:52 <haasn> Ix sort of gives it away
18:21:52 <ski> aye
18:22:00 <arkeet> neat
18:22:03 <shachaf> :t ix
18:22:08 <shachaf> :t Control.Lens.ix
18:22:09 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
18:22:34 <shachaf> ix's type is so awe-inspiring that lambdabot won't tell you unless you fully-qualify it.
18:22:52 <ski> too bad you can't write `(memo (0,12) -> fib) 0 = 0; (memo (0,12) -> fib) 1 = 1; (memo (0,12) -> fib) n = fib (n-1) + fib (n-2)' or something similar
18:23:08 <haasn> what's the longest type in ‘lens’, as measured by the output of :t ?
18:23:10 <shachaf> ski: You can't?
18:23:17 * hackagebot diagrams 0.7.1.1 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.7.1.1 (BrentYorgey)
18:23:18 <haasn> of any single value
18:23:19 * hackagebot diagrams-builder 0.4.0.3 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.0.3 (BrentYorgey)
18:23:21 <ski> shachaf : try it ?
18:23:22 <joelteon> well
18:23:25 <arkeet> :t beside
18:23:31 <arkeet> :t Control.Lens.beside
18:23:32 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a
18:23:32 <lambdabot> b
18:23:40 <arkeet> I'm sure there's better.
18:23:42 <shachaf> ski: Oh, I see. I misunderstood.
18:23:44 <ekipan> good gravy
18:23:45 <ski> shachaf : i don't think they thought of `ViewPatterns' being used in the above way
18:23:45 <arkeet> and it will shortly become even longer.
18:23:53 <arkeet> once I submit my change.
18:24:03 <shachaf> yes, you can't define functions that way.
18:24:08 <shachaf> s/y/Y/
18:24:44 <ski> btw, with `f (foo -> Left  x) = ..x..; f (foo -> Right x) = ..x..' do you get a single `foo' call or not ?
18:24:56 <arkeet> I think you do.
18:24:57 <haasn> ski: does (memo (0,12) -> fib) = \case 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)  work?
18:25:00 <shachaf> I think GHC guarantees a single call.
18:25:08 <ski> haasn : should work
18:25:25 <haasn> ski: seems better than repeating the view pattern to me either way
18:25:41 <tnks> I'd learned about monad transformers with respect to monads not composing. . . so curious why StateT constructs with s -> m (a, s) instead of s -> (m a, s)
18:25:43 <ski> shachaf : then i think it could be reasonable to assume the same for the `fib' example above
18:25:51 <shachaf> Yes.
18:26:06 <ski> haasn : depends
18:26:09 <shachaf> That's what I thought you were saying "too bad" about. But then I saw that something else was going on.
18:26:22 <ekipan> > (\case _ x -> x) () -- does lambdacase do multiple arguments?
18:26:23 <lambdabot>   <hint>:1:3: parse error on input `case'
18:26:23 <arkeet> let (memo (0,12) -> fib) = f; f 0 = 0; ...
18:26:38 <arkeet> ekipan: case doesn't do multiple arguments, so no?
18:26:48 <ekipan> lambda does though
18:26:50 <ski> arkeet : but then you need an auxilary name, which this was supposed to get rid of
18:26:51 <elliott> arkeet: that's the wrong way around.
18:26:54 <elliott> or, maybe not.
18:27:12 <elliott> ok, I get it now
18:27:13 <arkeet> ski: well that was my intention.
18:27:32 <arkeet> is memo in some library?
18:27:38 <ski> dunno
18:28:14 <haasn> > uncurry (\case (_,x) -> x) 3 4 -- ekipan
18:28:15 <lambdabot>   <hint>:1:11: parse error on input `case'
18:28:20 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]  -- ought to be in a library
18:28:20 <haasn> err
18:28:21 <lambdabot>  Defined.
18:28:23 <haasn> also s/uncurry/curry/
18:28:32 <ekipan> true
18:28:34 <arkeet> ski: tabulate is already taken by profunctor-extras
18:28:40 <arkeet> =(
18:28:44 <ski> (well, for any `IArray', really, but lambdabot doesn't seem to have that imported)
18:28:54 <ski> arkeet : for what ?
18:28:54 <arkeet> doesn't vector have that sort of thing?
18:29:01 <ekipan> > curry3 (\case (_, _, x) -> x) undefined undefined ()
18:29:02 <lambdabot>   <hint>:1:10: parse error on input `case'
18:29:06 <arkeet> ski: it's one of the isos for representable profunctors
18:29:24 <arkeet> I'm not sure why it's called that.
18:29:26 * ski has been mentioning `tabulate' here on and off for several years
18:29:33 <arkeet> :t tabulate
18:29:34 <lambdabot> Ix i => (i, i) -> (i -> e) -> Array i e
18:29:37 <arkeet> er
18:29:51 <ski> @type Data.Profunctor.Rep.tabulate
18:29:52 <lambdabot> Data.Profunctor.Rep.Representable p => (d -> Data.Profunctor.Rep.Rep p c) -> p d c
18:29:55 <arkeet> yeah.
18:29:58 <haasn> :t Control.Lens.ifailing
18:29:59 <lambdabot> (Applicative f, Indexable i p) => Traversing (Indexed i) f s t a b -> Traversing (Indexed i) f s t a b -> Over p f s t a b
18:30:30 <haasn> beside is much longer
18:30:45 <peterbb> So ... is this (== x) -> True pattern unidiomatic? Do you think I just should use guards? Or is there some other way to achive non-linear pattern matching?
18:31:04 <ski> peterbb : pattern guards, i suppose
18:31:21 <ski> (you probably won't think that is better than ordinary guards in this case, though)
18:31:44 <haasn> arkeet: I guess the biggest ‘type’ in lens is still the context on Conjoined
18:31:53 <peterbb> Its pattern-guards I use at the bottom here, right? (the commented part) https://gist.github.com/peterbb/6517990
18:31:57 <ski> arkeet : i suppose one could ask edwardk about `tabulate'
18:32:30 <sclv> clearly tabulate, as a common name, deserves to be taken by a widely used package such as profunctor-extras
18:32:48 <ski> peterbb : no, just an ordinary guard
18:33:17 <peterbb> ski: oh, ok, I'll look it up then.
18:33:26 <sclv> although actually i think the representable notion of tabulation actually sorta generalizes ski's :-)
18:33:50 <ski> peterbb : it's basically like guards, but instead of only getting `Bool's back, you can also bind variables in the guards
18:34:05 <ski> sclv : yea, i was pondering that
18:34:06 <haasn> I wouldn't mind importing profunctor-extras qualified if I ever needed to use it together with arrays, personally
18:35:16 <arkeet> well, lens uses it internally
18:35:25 <arkeet> I haven't really seen it elsewhere
18:48:28 <napping> well, -fprof-auto-call turned up a nice slow cost centre, but I can't tell which it is
18:49:06 <sellout-> I’m using haskell-ghci-mode in Emacs – wondering if there’s any way to make it possible to :load Alex and Happy files.
18:49:15 <napping> they're all just named after the function, and I don't see any options for getting line numbers or such
18:50:11 <arkeet> would be nice if cabal could build non-profiling and profiling libraries in parallel
18:58:22 <napping> ouch, why is Data.Text.index O(n)?
18:58:35 <shachaf> Because UTF-16.
18:58:37 <arkeet> napping: because utf-
18:58:37 <arkeet> yeah
18:58:51 <arkeet> oh it's 16?
18:58:54 <shachaf> Yep.
18:58:55 <arkeet> oh yeah
18:59:45 <napping> well, that would nicely explain the parser being approximately O(n^2)
19:00:35 <DaveS> why does UTF16 matter?
19:00:53 <arkeet> DaveS: variable-length characters.
19:00:54 <DaveS> ah
19:01:04 <arkeet> some take one code point, some take two.
19:01:06 <arkeet> er
19:01:07 <arkeet> code unit
19:02:03 <monochrom> err, if you write a parser, it should use head and tail, not index. if you use parsec, the Stream instance already does it for you.
19:02:24 <napping> it's currently something like a tabling CYK parser
19:04:44 <napping> I do plan to organize things so it fills in order, but wanted a performance baseline first
19:05:49 <monochrom> if you really like random access, pour your Text into a Vector Char first :)
19:06:02 <shachaf> Or use UCS-2.625!
19:06:13 <napping> Bytestring.Char8 is doing the job for now
19:06:19 <shachaf> napping: :-(
19:06:28 <arkeet> :-(
19:06:33 <napping> I'll have to see about Happy's UTF8-parsing tricks eventually
19:07:06 <monochrom> Char8 is against God's will
19:07:37 <haasn> monochrom: write pipes-text please!
19:08:40 <joelteon> Someone write pipes-HTTP
19:13:35 <meretrix> pipes works pretty well with http-conduit
19:15:14 <joelteon> pipes and conduit sounds like it would kill you
19:16:24 <monochrom> Col. Mustard, pipe, and the dining room? :)
19:27:31 <flebron> Hi. I'm reading the Applicative paper. Why is it true that "Moreover, any expression built from the Applicative combinators can be transformed to a canonical form in which a single pure function is ‘applied’ to the eﬀectful parts in depth-ﬁrst order". It seems true-ish to me, but how can one prove it?
19:29:45 <elliott> repeated application of the laws :)
19:32:26 <flebron> Oh, the interchange one. u <*> pure x = pure (\f -> f x) <*> u
19:38:12 <k0001> joelteon: I'm doing some experiments towards that end right now.
19:40:08 <joelteon> sweet
19:52:27 <chrisdotcode> does -Werror catch *all* warnings, or just the ones that you've explicitly enabled?
19:54:13 <johnw> -Werror does not imply -Wall
19:56:56 <chrisdotcode> johnw: so to get *every* single warning as an error, I'd use:
19:56:56 <chrisdotcode> "-Wall -Werror fwarn-tabs -fwarn-incomplete-record-updates -fwarn-monomorphism-restriction -fwarn-unused-do-bind -fwarn-implicit-prelude"?
19:56:56 <chrisdotcode> (referencing http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/options-sanity.html)
19:57:36 <johnw> looks right to me
19:58:06 <Twey> -Werror makes non-fatal warnings into fatal errors
19:58:20 <sclv> chrisdotcode: i would not recommend such a thing though
19:58:24 <Twey> So wherever your other options produce a warning, -Werror turns it into an error
19:58:33 <chrisdotcode> sclv: well, why not
19:58:33 <chrisdotcode> ?
19:58:45 <sclv> because not every warning is something you may care about
19:59:15 <chrisdotcode> sclv: well for the sake of pendantic-ness, I was just curious...
19:59:27 <sclv> its hard to selectively disable warnings unfortunately
19:59:47 <tikhon> sclv: hard or just tedious?
19:59:51 <sclv> that would be a nice feature to add -- pragmas to selectively turn off warnings where e.g. you know the pattern match is complete but ghc can't see through the gadt
19:59:57 <sclv> tikhon: afaik, hard
20:00:06 <sclv> you can disable warnings with flags
20:00:09 <tikhon> do you mean disabling a particular warning just for one expression?
20:00:12 <sclv> but not like "for this function ony"
20:00:16 <tikhon> ah
20:00:24 <tikhon> yeah, I'm not sure if that's possible
20:00:48 <tikhon> if it isn't, we should be embarassed—even Java has that :P
20:01:02 <sclv> its hard even to say -Wall except for this one file where yes please don't warn orphan instances or etc.
20:01:21 <tikhon> eh, that's not too bad
20:01:31 <tikhon> you just have to have the right magical incantation
20:02:01 <tikhon> but yeah, there are some warnings you really don't want to live without
20:02:02 <sclv> in my experience putting the nowarns in the GHC pragma at the top of the file didn't work
20:02:21 <sclv> like the cmd line/cabal -Wall overrode them
20:02:21 <tikhon> really? that's always worked for me, but I haven't used it too much
20:02:38 <tikhon> I usually either turn a warning off everywhere or fix it everywhere
20:17:31 <sellout-> Well, that was easy enough – in .ghci added :defs for lalex and lhappy (which run the appropriate command, then :loads the result), then modified haskell-ghci.el to use :lalex or :lhappy instead of :load when C-c C-l is run from the appropriate type of file.
20:18:01 <sellout-> But has this really not been done before? Do people just eschew the lex/yacc style stuff? (understandable, if so)
20:18:50 <tikhon> I think it's much less popular than parser combinators
20:19:03 <johnw> it has its niche
20:20:42 <tikhon> hmm, does it?
20:21:09 <elliott> ghc uses it
20:21:16 <johnw> if you know the entire grammar in advance and it can be expressed in LL(1) or LALR(1), then I think happy may be a better choice
20:21:34 <tikhon> yeah, but does it have to be an external tool like that?
20:21:45 <tikhon> I mean, couldn't you implement something like that as a normal Haskell library?
20:21:48 <johnw> yes, you don't want to pay the cost of generating the tables at runtime
20:29:10 <levi> You could do a happy-style parser inline via Template Haskell or a HSX-style preprocessor.
20:57:16 <carter> tikhon yo!
20:57:19 <carter> hows the west?
20:58:08 <shachaf> tikhon is back?
20:59:11 <tikhon> yeah, I'm back in the bay area
20:59:27 <tikhon> it's nice, as ever
21:03:21 * hackagebot yjftp-libs 0.0.2 - CUI FTP client like 'ftp', 'ncftp'  http://hackage.haskell.org/package/yjftp-libs-0.0.2 (YoshikuniJujo)
21:13:42 <carter> anyone know a good Hlist reverse that uses type familes ?
21:14:25 <carter> oh
21:14:26 <carter> i think i got it
21:23:21 * hackagebot xturtle 0.1.12 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.12 (YoshikuniJujo)
22:07:47 <MedDev> Besides sequence is there any way I can append to the right hand side of a Vector/List-esque object in O(1) time vs O(n) time?
22:08:50 <tikhon> have you looked at difference lists?
22:08:57 <MedDev> i will now :)
22:09:50 <adu> hi all
22:09:58 <shachaf> So you can make a "difference category" with e.g. (k a b) <=> (forall r. k b r -> k a r)
22:10:13 <shachaf> (You can also use forall r. k r a -> k r b, I guess...)
22:10:19 * MedDev hears a loud wooshing noise as that concept goes over his head
22:10:33 <shachaf> In what cases are the types actuall equal, rather than "too big" like you get with a "difference monoid"?
22:10:43 <shachaf> y
22:11:57 <MedDev> still new to such concepts as categories
22:12:56 <latro`a_> difference lists are quite nice
22:13:49 <dmj`> MedDev: a category is just a collection of objects and morphisms that can compose.
22:13:51 <shachaf> Difference lists are too big. :-(
22:14:05 <shachaf> But Church (/Boehm-Berarducci lists) are just right.
22:14:19 <shachaf> s/ lists\)/) lists/
22:14:29 <latro`a_> it's a very simple idea: (x:) is a list function, and you can pre- or post-compose it with other list functions. [x,y,z] is then isomorphic to (x:) . (y:) . (z:), where the isomorphism is given by ($ [])
22:16:31 <shachaf> A Haskell "difference list" is a list that abstracts [] (the end of the list) by taking it as an argument.
22:17:02 <MedDev> hmm ok, that doesn't sound all that scary.
22:17:27 <latro`a_> it's actually not; the main thing is that you actually construct the "list" (i.e. the object of type [a]) all at once
22:17:34 <shachaf> For example, the list (1:2:3:[]) becomes the function (\end -> 1:2:3:end)
22:18:38 <shachaf> There are advantages and disadvantages. This is definitely not a panacea, so you should understand the disadvantages before you use it everywhere.
22:19:04 <latro`a_> one application I used this for was adaptive integration
22:19:33 <latro`a_> where it is convenient to have the list of the nodes that get used be in order
22:19:56 <latro`a_> but they are never generated in order
22:23:16 <latro`a_> http://lpaste.net/92842 if you're interested, MedDev
22:23:31 <latro`a_> ah, I missed a couple type synonyms
22:23:43 <MedDev> hmmm, if I'm not concatenating a lot, and always reading the data in a left to right (0..length-1) fashion Sequence should be fine? or do I have to worry about memory? I have a type of Seq (Seq Double) (something like 32-64k sub sequences with 32 doubles each) just wondering if this is an 'insane' thing to do?
22:23:55 <latro`a_> fixed
22:24:25 <johnw> shachaf: what name would you give to (\(cons, end) -> 1 `cons` 2 `cons` 3 `cons` end)?
22:24:42 <latro`a_> the main logic here is in adaptive'
22:24:51 <shachaf> johnw: That's the aforementioned Church (/Boehm-Berarducci, whatever) encoding of a list.
22:24:58 <shachaf> (Except without the tuple.)
22:25:14 <shachaf> newtype List a = List { forall r. (a -> r -> r) -> r -> r }
22:25:18 <johnw> I've also heard it called a "fold function"
22:25:20 <shachaf> The two arguments are cons and end.
22:25:28 <shachaf> It's also a fold, sure.
22:25:57 <johnw> forall r. (a -> r -> r) -> r -> r -- what is the relationship there to Yoneda?
22:26:02 <shachaf> It's Mu of (Foo b = Maybe (a,b))
22:26:11 <shachaf> (Mu of Foo, that is.)
22:26:14 <johnw> sure, that makes sense
22:26:17 <shachaf> Which relationship are you thinking of?
22:26:26 <johnw> i don't have a particular relationship in mind
22:26:39 <latro`a_> any interest in that link, MedDev? if not I'll head off to bed
22:26:40 <johnw> this is an area I've been pondering lately, so I wondered what your thoughts were
22:27:14 <shachaf> It's Codensity Endo but I don't know if that's significant in any way.
22:27:20 <shachaf> (And also not really related to what you asked.)
22:27:30 <johnw> it's something else to think about, thanks
22:27:40 <MedDev> latro`a_, don't wanna keep you up :) I will keep investigating. I think sequence is what I want, but I will try playing with diff lists.
22:27:43 <shachaf> What sort of thing are you thinking of?
22:28:01 <latro`a_> nah, if you have any quick questions about it or something I can answer them
22:28:10 <johnw> wondering how these church encoded lists relate to morphisms in the category of list algebras
22:28:12 <latro`a_> I don't have to be up or anything
22:28:19 <latro`a_> would rather put off sleeping tbh :)
22:28:36 <MedDev> I feel you :) always battle with that feeling of "just twenty more minutes then bed"
22:29:12 <latro`a_> the part that makes this clever is the "nodesa . nodesb" part
22:29:13 <enthropy> latro`a_: maybe it's better to actually build up some data that holds the function values / current estimates
22:29:30 <enthropy> (on the topic of integration, not difference lists)
22:29:31 <latro`a_> maybe; this was not meant to be optimal
22:29:46 <shachaf> johnw: Which category is that again?
22:29:48 <latro`a_> I thought it was kinda elegant, though
22:30:28 <johnw> shachaf: a sub-category of the category of F-Algebras?  i may not know what I'm talking about
22:31:11 <latro`a_> this particular adaptive integration method is rather simple
22:31:14 <shachaf> Now I'm a bit more confused.
22:31:20 <johnw> ok, never mind for now
22:31:21 <shachaf> What are the objects and what are the arrows?
22:31:49 <johnw> oh, right, this church encoded object wouldn't be in that category, only the algebras are there
22:32:07 <enthropy> latro`a_: when you explain the algorithm to people, you might draw a tree I think
22:32:21 <latro`a_> that's true
22:32:24 <johnw> (where by object I meant value)
22:32:39 <latro`a_> but you don't really need the tree
22:32:50 <enthropy> maybe there's no cost for it?
22:32:55 * enthropy dunnos
22:33:00 <latro`a_> there's cost to retaining that data
22:33:08 <shachaf> I think I'm missing some context here. :-) What are the objects involved here?
22:33:12 <latro`a_> this never holds on to a value of f
22:33:21 <shachaf> (This whole area is one that I'd like to understand better.)
22:33:37 <johnw> shachaf: let me finish my phone meeting and then I'll be ready to dig in
22:34:12 <latro`a_> but yes, I could see some potential optimization or such that might be doable with the tree at hand
22:34:20 <latro`a_> at the very least it would generalize better
22:34:32 <latro`a_> it'd deal with overlapping nodes between subintervals as well
22:34:43 <latro`a_> (which was a minor problem with my adaptive Simpson version)
22:48:35 <johnw> shachaf: ok, I have a half hour now
22:48:48 <johnw> shachaf: I assume you are pretty well-versed in F-algebras?
22:51:49 <arkeet> shachaf eats F-algebras for breakfast.
22:51:53 <arkeet> I assume he eats breakfast.
22:52:49 <shachaf> Am I? I don't know.
22:52:57 <johnw> i can't even imagine you not being so
22:53:38 <johnw> what I'm trying to figure out is that a church-encoding for a list is like a "proto-value", to which you can apply any list-algebra
22:53:59 <shachaf> By list-algebra you mean a function of type [A] -> A for some type A?
22:54:14 <johnw> yes
22:54:21 <shachaf> OK.
22:54:36 <shachaf> I'm not sure what the rest means.
22:54:51 <shachaf> Oh, I see.
22:55:01 <johnw> so, where coyoneda abstracts over the arguments to fmap, the fold function for a list seems to abstract over the arguments for any list-algebra, albeit recursively applied
22:55:03 <shachaf> Do I?
22:55:05 <johnw> haha
22:56:04 <shachaf> Let's give a name to Foo a b = Maybe (a,b).
22:56:10 <shachaf> Call it Foo.
22:56:14 <johnw> k
22:57:05 <shachaf> Foo is related to [], because Foo a [a] is isomorphic to a.
22:57:20 <johnw> you mean, to [a]?
22:57:20 <shachaf> But you already know that. I'm not sure what you're getting at with []-algebras, though.
22:57:26 <shachaf> Yes, to [a]
22:58:01 <johnw> take my function \c z -> 1 `c` 2 `c` 3 `c` z
22:58:18 <arkeet> :t \c z -> 1 `c` 2 `c` 3 `c` z
22:58:19 <lambdabot> (Num a, Num a1) => (a -> a1 -> a) -> a1 -> a
22:58:20 <shachaf> OK. That function is :: Mu (Foo a)
22:58:26 <johnw> if I somehow apply the initial []-algebra to this function, I get a list
22:58:28 <shachaf> Or a type isomorphic to it.
22:58:38 <johnw> but I can't just "apply the initial []-
22:58:44 <johnw> algebra", because it is itself a function
22:58:54 <shachaf> Wait, where did []-algebras get into it?
22:59:04 <arkeet> are you talking about Foo-algebras or []-algebras?
22:59:07 <shachaf> We have (Foo a)-algebras.
22:59:10 <arkeet> where [] = Mu Foo
22:59:12 <johnw> oh, I'm still thinking about lists
22:59:13 <arkeet> er,
22:59:17 <arkeet> yeah Foo a.
22:59:23 <johnw> let me adjust to Foos
22:59:47 <johnw> let me take a step back
23:00:24 <shachaf> It might be simpler if you use Maybe instead.
23:00:30 <shachaf> Maybe is nice and simple.
23:00:33 <johnw> good idea
23:00:54 <shachaf> data Nat = Z | S Nat
23:01:06 <johnw> then my abstracted value is \f -> f 1, where f can be Just or () -> Nothing
23:01:17 <shachaf> We know that Maybe Nat is isomorphic to Nat.
23:01:18 <shachaf> ?
23:01:20 <johnw> sorry, forall a. a -> Nothing
23:01:24 <johnw> const Nothing
23:01:27 <shachaf> ?
23:01:34 <shachaf> I'm confused.
23:01:39 <johnw> you know what, I think I'm making no sense at all and now may not be a good time for me to attempt this
23:02:12 <johnw> I know that I can encode a "proto value" for Maybe as a church encoding
23:02:15 <johnw> \f -> f 1
23:02:17 <shachaf> This is a useful thing to attempt, though.
23:02:25 <johnw> now the caller decides whether this is going to become a Just 1, or a Nothing
23:02:28 <shachaf> There's no "1" here.
23:02:38 <johnw> why not?
23:02:44 <shachaf> Or, hmm. We're talking about different things again.
23:02:52 <arkeet> what's (the type of) f?
23:03:02 <johnw> f :: Int -> Maybe Int
23:03:05 <anarcat> > length $ filter (\x -> x) [ True, False ] == 1
23:03:06 <shachaf> I'm talking about Nat, which is the fixed point of Maybe.
23:03:07 <lambdabot>   Couldn't match expected type `[a0]'
23:03:07 <lambdabot>              with actual type `GHC.Type...
23:03:18 <arkeet> ok, f could do a lot of things then.
23:03:28 <arkeet> f :: forall a. a -> Maybe a  could not.
23:03:36 <arkeet> I dunno.
23:03:38 <arkeet> hi
23:03:45 <shachaf> hi arkeet
23:03:50 <johnw> well, so \f -> f 1 is my undecided Maybe value
23:03:54 <shachaf> Maybe we should take this to #haskell-overflow.
23:03:57 <johnw> ok
23:04:49 <anarcat> > (length $ filter (\x -> x) [ True, False ]) == 1
23:04:50 <lambdabot>   True
23:05:13 <anarcat> ^^ is there a better way of doing this? i was banging my head on foldr and figured there was no other way...
23:05:41 <shachaf> anarcat: length (filter (\x -> x) [ True, False ]) == 1 is better.
23:05:51 <shachaf> Syntactically, I mean. No $
23:06:01 <anarcat> ah well, that's not what i meant :)
23:06:07 <anarcat> but okay
23:06:22 <shachaf> Of course, there are many other things that could be improved about that expression. :-) But on syntax, you're pretty stuck with $ being less sticky than ==
23:06:31 <shachaf> (You can change it, but don't.)
23:06:35 <anarcat> oh right
23:06:42 <anarcat> i was using == just to demonstrate the purpose...
23:06:52 <anarcat> i am more looking at improving the expression
23:06:59 <anarcat> that lambda seems kind of silly
23:12:13 <chexxor> How do I test two functions for equivalence? I saw someone here do it a few days ago.
23:12:38 <tikhon> that's not really possible in general
23:12:40 <arkeet> what sort of functions?
23:12:41 <arkeet> and that
23:13:03 <tikhon> also, do you mean test like QuickCheck or like Eq?
23:13:03 <shachaf> reallyUnsafePtrEquality# will not test functions for equivalence.
23:13:05 <shachaf> It's really unsafe.
23:13:07 <chexxor> I reimplemented map as a fold. I want to verify it's correct.
23:13:08 * arkeet . o O ( (Int -> Bool) -> Bool )
23:13:22 <shachaf> arkeet: Make it Integer while you're at it!
23:13:25 <arkeet> chexxor: you can run it on some test inputs.
23:13:27 <arkeet> shachaf: oh, good point.
23:13:34 <chexxor> probably quickcheck
23:13:42 <arkeet> sure.
23:13:59 <tikhon> QuickCheck just generates random inputs to test your function on
23:13:59 <arkeet> then you can get evidence that it's not incorrect.
23:14:12 <tikhon> so it's not a 100% guarantee, but it's pretty good
23:14:34 <tikhon> are you familiar with QuickCheck?
23:14:44 <chexxor> no
23:14:48 <tikhon> oh
23:15:01 <tikhon> the basic idea is simple—just what I said earlier
23:15:12 <arkeet> > check \x -> x*2 = x+x
23:15:13 <lambdabot>   <hint>:1:7: parse error on input `\'
23:15:15 <arkeet> @check \x -> x*2 = x+x
23:15:16 <lambdabot>  <unknown>.hs: 1: 11:Parse error: =
23:15:19 <arkeet> uh
23:15:21 <arkeet> @check \x -> x*2 == x+x
23:15:24 <tikhon> @check \x -> x*2 == x+x
23:15:27 <lambdabot>   +++ OK, passed 100 tests.
23:15:32 <lambdabot>   +++ OK, passed 100 tests.
23:15:42 <chexxor> I can use @check in my .hs file?
23:15:45 <tikhon> so you give QuickCheck a function which returns a boolean
23:15:51 <leroux> chexxor: lambdabot, I think.
23:15:52 <arkeet> chexxor: no, @check is a lambdabot command.
23:15:54 <tikhon> chexxor: no, @check is lambdabot-specific
23:16:49 <tikhon> the general convention is to name the tests prop_*
23:16:59 <tikhon> "prop" is short for property
23:17:14 <chexxor> ok, from ghci, I import Test.QuickCheck, then I use quickCheck function?
23:17:20 <tikhon> so you could have a file with a property like prop_myMap ls = myMap (+1) ls == map (+1) ls
23:17:26 <arkeet> e.g. you might write prop_double :: Int -> Int; prop_double x = x*2 == x+x
23:17:27 <arkeet> or something.
23:17:39 <dmj`> chexxor: http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
23:17:50 <arkeet> hm, I think quickcheck was able to generate functions as well?
23:18:26 <jfischoff> coarbitrary
23:22:44 <leroux> Has anyone had problem with $ cabal install http ?
23:22:54 <leroux> problems*
23:23:20 <tikhon> what sort of problems?
23:23:41 <jfischoff> what version of ghc?
23:23:44 <leroux> Nevermind, I've found... https://github.com/haskell/cabal/issues/1137
23:24:50 <chexxor> so there's no equivalent of @check in ghci?
23:24:56 <leroux> There is.
23:25:03 <leroux> It just calls QuickCheck.
23:25:11 <leroux> chexxor: You can also install lambdabot.
23:25:27 <tikhon> there's just a function you can run, I believe
23:25:33 <chexxor> I don't want to make functions and such, I just want to say "quickCheck map == map' "
23:25:56 <leroux> Sure, you can do that.
23:26:09 <shachaf> Don't install lambdabot to run QuickCheck.
23:26:10 <arkeet> well, quickCheck $ \f x -> map f x == map' f x
23:26:14 <tikhon> quickCheck $ \ ls f -> myMap f ls == map f ls
23:26:16 <arkeet> Don't install lambdabot.
23:26:20 <leroux> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck.html#v:quickCheck
23:27:00 <tikhon> you'll have to do :m + Test.QuickCheck too
23:27:05 <tikhon> to import the QuickCheck module
23:27:24 <arkeet> you'll also have to give better type annotations.
23:27:46 <tikhon> honestly, I'd just hardcode the function to be something like (+ 1)
23:27:52 <arkeet> or that.
23:27:54 <tikhon> (the function being mapped over the list, that is)
23:28:21 <tikhon> given the types, that should be more than good enough
23:29:10 <chexxor>  quickCheck ( map (+1) == map' (+1) )
23:29:14 <tikhon> quickCheck $ \ ls -> myMap (+1) ls == map (+1) ls
23:29:20 <tikhon> no, you want to make the list argument explicit
23:29:29 <tikhon> you could also have a pointfree version, but that's a bit trickier
23:29:31 <shachaf> But then you have to read Wadler's paper.
23:29:53 <tikhon> quickCheck $ \ ls -> (==) <$> map (+1) <*> map' (+1)
23:29:57 <tikhon> I think that should work
23:29:59 <tikhon> erm
23:30:04 <tikhon> without the \ ls -> bit
23:30:09 <tikhon> quickCheck $ (==) <$> map (+1) <*> map' (+1)
23:30:19 <tikhon> but the explicit version is nicer
23:30:24 <shachaf> tikhon: I don't think this is a reasonable recommendation given the context. :-)
23:30:37 <tikhon> no, it probably isn't
23:30:39 <tikhon> and yet
23:30:40 <shachaf> You should only use point-free code if you'd be able to derive it yourself.
23:30:47 <chexxor> Not in scope: `<$>'
23:30:54 <tikhon> chexxor: yeah, don't use that version
23:31:06 <tikhon> just think of it as unholy magic
23:31:25 <chexxor> tikhon: omg, your first version worked
23:31:28 <chexxor> magic!
23:31:35 * arkeet prefers liftA2
23:31:45 * tikhon prefers idiom brackets
23:31:51 * shachaf prefers magic
23:31:56 <tikhon> (| map (+1) == map' (+1) |)
23:32:00 <tikhon> idiom brackets *are* magic
23:32:11 <tikhon> also, I'm not entirely certain that would actually work
23:32:11 <shachaf> They're magic because it decided where to lift there automatically, right?
23:32:16 <tikhon> yes
23:32:21 <shachaf> What to lift and what not to lift.
23:32:44 <tikhon> the rules are actually straightforward, but I haven't used them enough to know them well
23:32:58 <shachaf> "magic" is just another word for "primitive".
23:33:13 <tikhon> or the opposite
23:33:18 <tikhon> sufficiently advanced technology and all that
23:33:26 <shachaf> Hmm?
23:33:35 <tikhon> it's a famous quote by Arthur C. Clarke
23:33:39 <shachaf> Yes, I know.
23:33:48 <tikhon> oh
23:33:48 <shachaf> If technology is sufficiently advanced, you treat it as a primitive rather than understanding it in terms of smaller primitives.
23:33:51 <shachaf> Therefore it's magic.
23:33:53 <tikhon> oh, that'
23:33:59 <tikhon> that's what you meant by "primitive"
23:34:11 <shachaf> Ah. Yes.
23:34:17 <tikhon> I took the opposite meaning
23:34:27 <carter> as did i
23:34:34 <shachaf> I guess that meaning exists. :-(
23:34:48 <arkeet> the indecomposable black box meaning.
23:34:52 <chexxor> omg, thanks. I was banging my head against the wall here. I checked the type signature, saw the "Testable" and "IO ()" and just about gave up
23:34:56 <tikhon> it's usually easy to tell them apart because one is almost always a noun and the other an adjective
23:35:16 <tikhon> but here the part of speech was somewhat ambiguous
23:35:18 <arkeet> chexxor: yeah, quickchec uses a bit of typeclass magic to accept functions with an arbitrary number of arguments.
23:36:01 <chexxor> looks like Testable is just a type synonym for Boolean (among others), correct?
23:36:14 <shachaf> Maybe I should use another word.
23:36:19 <shachaf> "magic" is just another word for "fundamental"?
23:36:29 <shachaf> "atomic"?
23:36:32 <shachaf> I don't know.
23:36:43 <tikhon> chexxor: Testable is a class, just like Show or Read
23:37:17 <tikhon> Bool is one member of the class
23:37:33 <tikhon> but it also includes functions returning booleans, with any number of arguments
23:38:01 <tikhon> as long as QuickCheck knows how to generate the arguments
23:38:29 <arkeet> (you might see it mention Arbitrary. that's how it randomly generates input)
23:39:03 <tikhon> basically, Testable represents any sort of property that QuickCheck knows how to work with
23:40:27 <chexxor> ok, I'll keep that question on the backburner. It's a typeclass topic?
23:40:44 <tikhon> Yes, since Testable is a typeclass
23:40:48 <tikhon> have you not covered those yet?
23:41:10 <arkeet> (Arbitrary is another typeclass. maybe let's not worry about it too much.)
23:42:02 <chexxor> tikhon: not yet, I'm only now working on folds and and writing pointfree functions. Week 4 of my endeavor
23:42:19 <tikhon> oh, typeclasses are a lot of fun
23:42:37 <tikhon> one of the first things I learned about in Haskell, personally
23:44:53 <dissipate_> would it help to study category theory in addition to learning haskell?
23:45:10 <tikhon> help? not *that* much
23:45:18 <tikhon> but it would certainly be fun and happy
23:46:10 <dissipate_> tikhon, have you studied category theory?
23:46:18 <tikhon> hmm, a bit
23:46:25 <shachaf> Well, people who like that sort of thing will find it to be just the sort of thing they like.
23:46:39 <tikhon> tautology
23:46:53 <shachaf> Aren't they all?
23:47:04 <tikhon> see, this is what learning about category theory gets you
23:47:34 <chexxor> before starting Haskell, I studied a bit of set theory and category theory. Their understanding of types, functors, and members of a set is very helpful concepts.
23:47:43 <dissipate_> do the concepts of category theory map directly to the concepts in haskell, or does haskell borrow from other branches?
23:48:01 <chexxor> by studying, I mean watching some youtube video lectures and reading a bit of wikibooks
23:48:23 <dissipate_> chexxor, i'm thinking about getting a book on CT, but don't know which one
23:48:34 <tikhon> dissipate_: that's a bit of a false dichotomy: there's plenty of stuff in Haskell that isn't really from any branch of mathematics
23:48:50 <shachaf> I recommend not worrying about category theory if you're learning Haskell (and vice versa).
23:49:44 <dmj`> dissipate_: Hask is a category, but it is not cartesian-closed
23:49:51 <dmj`> dissipate_: http://www.haskell.org/haskellwiki/Hask
23:50:01 <chexxor> dissipate_: http://en.wikibooks.org/wiki/Haskell/Category_theory
23:50:08 <arkeet> I recommend following shachaf's recommendation.
23:50:21 <arkeet> there is no need to introduce category theory.
23:50:53 <shachaf> tikhon: If you're around, you can come to bacat and learn about adjunctions sometime this month!
23:51:02 <dissipate_> hmm, interesting
23:51:05 <tikhon> any particular time this month?
23:51:36 <dissipate_> arkeet, and what if one wants to develop the next versions of the GHC?
23:52:17 <leroux> dissipate_: http://ghc.haskell.org/trac/ghc/wiki/Newcomers
23:52:29 <tikhon> dissipate_: then you almost definitely do not need to know about category theory
23:52:45 <dissipate_> hmm, this all feels so familiar to my studies of abstract algebra
23:52:52 <tikhon> yes
23:53:02 <tikhon> it's like an abstract version of abstract algebra
23:53:05 <arkeet> category theory is the abstract study of abstractions.
23:53:10 <arkeet> =(
23:54:04 <shachaf> tikhon: Hmm, it's not scheduled yet. I think it's often on the last Wednesday.
23:54:12 <arkeet> it can give some useful insights but there is no need to actually know it to be as productive as you would in any other language
23:54:33 <arkeet> (or even more productive, in fact)
23:54:59 <shachaf> (Or structural. Take your pick.)
23:55:31 <dmj`> dissipate_: These videos are very good (https://www.scss.tcd.ie/Edsko.de.Vries/ct/catsters/linear.php), Just started on initial and terminal objects, Eugenia Cheng is a very good teacher.
23:56:21 <shachaf> The videos are great, but you shouldn't watch them to learn Haskell.
23:56:39 <dissipate_> dmj`, can one use category theory to extend the haskell language?
23:56:56 <arkeet> I don't know what that means, but you shouldn't be concerned with category theory.
23:57:11 <tikhon> category theory guides the *design* of the language (to some extent) and the libraries
23:57:23 <arkeet> (to some extent)
23:57:44 <arkeet> (the extent varies depending on whether your name is edwardk)
23:58:05 <rishi_> I'm wondering about the benefits of non-lazy evaluation for an interpreter (applicative order vs normal order). Why would you want non-lazy evaluation?
23:59:01 <shachaf> Normal order and lazy are not the same thing.
23:59:23 <rishi_> Oh?
