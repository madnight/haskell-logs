00:08:33 <osfameron> bible spam?
00:09:12 <Yaniel> is it just me or is that something new :D
00:10:35 <osfameron> I'd not seen it before.  Usually it seems to be revenge porn
00:11:16 * osfameron makes a note never to date a vindictive script-kiddie
00:38:51 <mm_freak_> i'd like to ask an off-topic question
00:39:47 <mm_freak_> you're stating A -> B to convince me that i need A, without stating anything about Not A…  what's the name of this fallacy?
00:42:13 <opqdonut> mm_freak_: "affirming the consequent"?
00:42:58 <opqdonut> http://en.wikipedia.org/wiki/Affirming_the_consequent
00:44:32 <mm_freak_> opqdonut: no, i'm rather looking for this fallacy:  A -> B, not A, therefore A -> B irrelevant
00:45:12 <ScriptDevil> https://yourlogicalfallacyis.com/false-cause
00:45:30 <opqdonut> mm_freak_: oh, the dual is "denying the antecedent"
00:45:38 <ScriptDevil> However, it is a negated version of false cause.
00:46:14 <mm_freak_> thanks
00:47:06 <ScriptDevil> mm_freak_: I was wrong. In yours a->b is true. In false-cause, that is the false.
00:47:23 <mm_freak_> ScriptDevil: yeah, mine is an informal fallacy
00:47:51 <ScriptDevil> Did you want A -> B to be irrelevant or B to be irrelevant?
00:48:07 <mm_freak_> it's not logically wrong…  example argument:  "if you believe in X you will get Y"
00:48:19 <mm_freak_> without ever saying anything about not believing in X
00:49:13 <mm_freak_> although denying the antecedent seems to be formal, so i'm not sure it applies
00:50:51 <ScriptDevil> I don't think that is a fallacy at all.
00:51:13 <ScriptDevil> Anyway #logic might help.
01:02:49 <Elision> if I was making, like, a bunch of cgi pages for a web app, what would be the nicest way to build them with cabal?
01:03:00 <Elision> multiple executable targets?
01:04:01 <Elision> or, like, a bunch of post-build hooks on the lbirary they interface with?
01:04:10 <c_wraith> multiple executable targets is ok. make sure all the common code is in a library, so they won't each compile the common code
01:04:43 <c_wraith> (best is not using CGI, but I'll assume that was just an example, not your real use case)
01:06:12 <c_wraith> You can put a library and multiple executables all in the same .cabal file, and have the executables depend on the library it defines.
01:06:16 <Elision> okay
01:06:24 <Elision> what do you recommend over cgi?
01:06:50 * Elision has never made any kind of browser crap before
01:07:10 <Maior> Elision: ok let me take you on a short whirlwind trip through The State Of Web App Dev
01:07:14 <Elision> oh boy
01:07:44 <Maior> Elision: CGI's a great interface for compatibility reasons, but isn't ideal for web app developers to code _for_ (escaping issues, etc.)
01:08:29 <c_wraith> any of the main web frameworks if you're doing anything that might become a serious project (in terms of amount of work you'll put into development).  Those are happstack, snap, yesod.  If you want something really minimal (in mental overhead, and in utility), you might check out scotty instead.
01:08:36 <Maior> Elision: approximate "standard" now is to have some kind of interface with some concept of request / response objects, and a daemon that implements that; you write effectively a lib with functions that take request objects and return response objects
01:08:43 <Maior> Elision: see Python's WSGI f/ex
01:08:57 <Maior> Elision: in Haskell...c_wraith gave a good list
01:09:02 <Elision> hm, okay
01:09:06 <RommelVR> argiopeweb: hey hey again :P, https://gist.github.com/RommelVR/8c8a865e9e0f616e2291, what am I missing here? The error is couldn't match [] with IO, I
01:09:35 <Maior> Elision: VERY lightweight example - http://hackage.haskell.org/package/scotty
01:09:43 <aleator> RommelVR: thing on the right of <- should have type IO something
01:09:54 <c_wraith> yeah, scotty is probably best for a complete web beginner - there's just less to learn.
01:10:04 <aleator> RommelVR: If it hasn't, you can say let alist = builder .. instead.
01:10:27 <Maior> Elision: scotty basically says "look, give me a set of (HTTP verb, url path) -> Text functions
01:10:38 <RommelVR> aleator: oh right, thanks :)
01:11:01 <Elision> Maior: heh, I'd definitely say I'm a complete web beginner :p
01:11:19 <RommelVR> aleator: sweet, my program works now :P
01:11:29 <aleator> RommelVR: Congrats.
01:11:53 <RommelVR> so, only do the <- if the right hand side has side effects (aka impure aka IO)
01:12:16 <RommelVR> because right, yeah that makes sense, cheers
01:12:21 <Elision> I'll check out happstack and such. I assume those will have their own build systems, then
01:12:33 <c_wraith> no, they still use cabal
01:12:43 <RommelVR> aleator: and lol, love the enthusiasm
01:12:48 <Elision> oh okay
01:14:42 <ScriptDevil> RommelVR: Not only for side-effects.
01:15:21 <RommelVR> ScriptDevil: lazy eval etc aswell or?
01:15:28 <Elision> thanks!
01:15:55 <ScriptDevil> The do notation do {foo; x <- bar; baz;} is only syntactic sugar for foo >> bar >>= \x -> baz
01:16:35 <RommelVR> ScriptDevil: I've read that enough times, but have no idea what that means
01:16:42 <ScriptDevil> but in super-simple terms, when you have a computation that returns m a, and you want a, use <-
01:16:49 <Maior> :t (>>=)
01:16:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:17:03 <ScriptDevil> Your getLine is of type getline:: IO a
01:17:10 <ScriptDevil> IO string
01:17:28 <ScriptDevil> But you want only a String. So you say x <- getLine
01:17:54 <Maior> RommelVR: "I have a Thing 'inside' a Monad; I have a function that takes a Thing and gives a Thung 'inside' the same Monad; I shall combine them!"
01:18:49 <RommelVR> Maior: yeah I'm sure that'd make sense if the concept of a monad was simple :P
01:19:20 <Maior> RommelVR: so fwiw, I found monads simple when I realised that IO was a very magic monad
01:19:43 <Maior> RommelVR: (i.e. it was the only monad I knew, and it seemed magic, so I assumed that was because monads are magic)
01:20:08 <Elision> IO is such a magic monad
01:20:31 * Maior tries to find the monad tutorial he...Got
01:20:33 <ScriptDevil> RommelVR: Look for this article called "You could have invented Monads" by sigpolyma
01:20:42 <Elision> I still don't entirely know what it does, except magically let IO happen
01:21:02 <ScriptDevil> Elision: IO is only one monad. Your list and Maybe are monads too. And so is State.
01:21:14 <Maior> ScriptDevil: ooh that's a good one
01:21:24 <Maior> ScriptDevil: I swear I saw something like it but with graphics
01:21:44 <RommelVR> ScriptDevil: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html ?
01:21:45 <Elision> ScriptDevil: I totally understand list and Maybe
01:21:49 <Maior> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
01:21:58 <Maior> RommelVR: that's the article yes
01:22:03 <Elision> and at one point I'm pretty sure I understood Parsec's Parser monad
01:22:04 <Maior> RommelVR: try that, and the one I linked above
01:22:11 <ScriptDevil> Elision: I maent to tell RommelVR, sorry.
01:22:15 <Elision> ok :p
01:22:18 <ScriptDevil> Maior: That is the one
01:22:25 <ScriptDevil> :D Bookmarking this time.
01:22:56 <ScriptDevil> RommelVR: You got the right one, but this new one pointed to by Maior is even better
01:23:06 <RommelVR> I'll read them both :)
01:23:16 <ScriptDevil> RommelVR: The second is the first + pretty pictures
01:23:26 <Maior> :t return
01:23:27 <lambdabot> Monad m => a -> m a
01:25:00 <Maior> RommelVR: "A monad is like a box. If something's a monad, it needs to provide two functions, a boxing function (return) and a function that takes a boxed value, and a boxing function, and [crappy wording] temporarily unboxes the value to apply the function [/crappy wording]"
01:26:31 <shachaf> :-(
01:26:39 <Maior> yeah ok, pretend I didn't say that
01:26:40 <shachaf> Don't say things like that, even as a joke.
01:27:02 <Maior> it wasn't meant as a joke...
01:27:27 <Maior> but somewhat of a failure to shift perspective
01:28:42 <Ghoul__> I didnt think I would get affected like everyone else I see coming to this channel complaining they couldn't code C++ after haskell, because I had done it for like 5 years, but crap - I actually can't anymore. Any imperative reasoning for trying to write an algorithm just sends me back into wanting to do a tail recursion, which generally fails. :|
01:30:22 <mstksg> i've had to work in ocaml recently and i have come to the realization that any strict language might as well be imperative to me
01:31:05 <Ghoul__> :|
01:33:18 <ScriptDevil> mstksg: Watch Don Stewart's recent talk. I don't use Haskell in my job, but he said !strict by default and lazy for performance is what they use at Standard Chartered
01:33:51 <ScriptDevil> mstksg: I do not know if all the lure of lazy evaluation is productive or counterproductive.
01:39:13 <haasn> I wish there would be a way to automatically strictify certain data structures/functions
01:39:20 <haasn> Like, say I wanted to use a fully strict Map String Int
01:39:27 <haasn> Right now I'd have to roll my own
01:39:28 <mstksg> ScriptDevil: I am not concerned about productive or counterproductive, i am talking about theoretical idealness
01:39:35 <haasn> (or s/String/Text)
01:39:56 <haasn> But I also sometimes want a lazy map
01:40:16 <haasn> Right now we have to roll our own or provide two versions of every library
01:40:45 <mstksg> in Ocaml, if you have two impure functions one after another, they are executed as they are declared.  chaining IO is as simple as writing them one line after another, and the order of function declaration literally matters.
01:41:21 <ScriptDevil> mstksg: That is not true. It is in the order they are called.
01:41:23 <haasn> Right but I don't think that's relevant in pure languages
01:41:33 <ScriptDevil> mstksg: Could you explain with an example?
01:42:28 <mstksg> ScriptDevil: well, I am being a little lose.  I am talking about something like (print_string "Hello"; print_string "World")
01:43:04 <ScriptDevil> mstksg: Those are function calls. Not declarations. Yes, you are right. That is in order.
01:44:53 <mstksg> maybe i need to re-check my brain. i seem to have lost this concept somewhere
01:45:14 <mstksg> maybe because the idea is so foreign to me now
01:46:03 <mstksg> is the function returning an action, then another action?  an object of two sequential actions?  or well, their type system seems to imply that it returns neither
01:46:11 <mjrosenb> *loose
01:46:22 <mstksg> mjrosenb: thanks
01:47:50 <ScriptDevil> mstksg: I think it is all about your starting point. It took me a bit to get used to Haskell given that I was doing Computer Architecture and was fundamentally tied to the way instructions were processed.
01:48:07 <ScriptDevil> If you come from math, declarative syntax might help.
01:49:02 <mjrosenb> so the way I think about it is if I have x = do {print "hello"; print " world"} :: IO (), then x is a computation that when you evaluate it, and it produces a value of (), has the side effect of printing stuff to stdout.
01:49:45 <mstksg> it seems to me that the function call forces an evaluation/execution of one function, then another.  and that the semicolon is a syntactical construct that forces an order in evaluation/ a strictness.  but it doesn't return anything; the function is not actually a mapping of values to another.
01:51:14 <mjrosenb> mstksg: so this is part of the magic of the do syntax
01:51:25 <mstksg> mjrosenb: well, you can consider x to be an instruction tree for a computer to run.  x returns that 'instruction tree'; a computer/executer (which is a wholly different entity from the function itself, and different from "Haskell" per se) then follows the instruction tree
01:51:47 <mstksg> but really the instruction tree *execution* is not a part of the language at all
01:52:42 <mstksg> what an IO () returns is that instruction tree -- and if there were a way to express it clearly enough, one could really perform the actions by hand, or outsource it to something else.  the execution is fundamentally different from the Haskell language itself, as an entity
01:54:10 <mstksg> the Haskell language creates the instruction tree, and something unrelated to the language (in our case, a computer with a von neumann architecture) executes it in whatever way it knows how.
01:54:20 <shachaf> mjrosenb: The way you think about it doesn't distinguish evaluation from execution. It's important to do that.
01:54:27 <mstksg> i forgot what point i was trying to get at here.
01:54:56 <mjrosenb> mstksg: by 'instruction tree', are you talking about something like an AST?
01:55:03 <shachaf> If nothing else your mental model should explain things like IO (IO a) and what not.
01:55:30 <shachaf> mjrosenb: Probably something like data IO = PutChar Char IO | GetChar (Char -> IO) | Done
01:55:41 <mjrosenb> shachaf: true, but I've never actually used something with that type, and am not entirely sure how I'd interpret it.
01:55:46 <haasn> mjrosenb: do syntax isn't magic
01:56:00 <shachaf> mjrosenb: kmc liked to give the example of spawn. spawn :: IO a -> IO (IO a)
01:56:09 <haasn> It's a literal and very simple transformation
01:56:22 <haasn> do { print 3; print 5}  is just print 3 >> print 5
01:56:23 <mjrosenb> haasn: I think of all syntatic sugar as magic, but this is also true.
01:56:25 <shachaf> It takes an IO action and runs it in a thread and gives you an IO action you can use to wait for the result.
01:57:58 <mstksg> mjrosenb: i consider it more like a step by step list of instructions with branching capabilities, etc..  Just detailed instructions to arrive at what you want in the end (in the case of IO (), a ()).  what x is is a function that generates those instructions, meant for a 'something else' to read and execute.
01:58:04 <mjrosenb> I guess I should say any syntatic sugar that I can't emulate with sed I consider magic.
01:58:34 <haasn> mjrosenb: isn't ‘sed’ turing complete? :)
01:59:19 <shachaf> mjrosenb: Once I wrote http://stackoverflow.com/a/13538351/712548 which incidentally explains what I mean.
02:02:24 <mstksg> maybe what made ocaml feel more imperative than functional to me was this eerieness that came from this lack of separation.  that IO is not a description of an action, but rather magically performed the action on its own during the course of its evaluation.
02:02:54 <mjrosenb> shachaf: so my original statement didn't mention execution at all, but I guess I hinted at it by saying 'as a side effect'
02:03:30 <shachaf> Haskell *has* a meaning for the word "evaluation", though.
02:03:43 <shachaf> print 5 `seq` () -- doesn't print anything
02:03:48 <osfameron> mstksg: that's really interesting.  Considering executing actions as "magical" (as opposed to the other way round, for programmers coming from imperative languages)
02:04:21 <shachaf> It's no more magical than any other language.
02:04:36 <shachaf> Anyway, I need to go to sleep.
02:05:17 <mjrosenb> is evaluation anything other than the process of turning a computation into a value?
02:05:19 <mstksg> and that this ordering can be seen as a "series of function calls", but what does a series of function calls (in the course of a function evaluation) even *mean*, in a mathematical sense?  Except for some object (a list? a monad?) that describes actions.  so this lack of that thing at the end just feels...eerie to me.
02:06:00 <mstksg> it's like the function appears to be returning some object..but all traces of the object seems to have vanished.
02:06:25 <shachaf> like, whoa, dude, and stuff
02:06:58 <mstksg> thank you for indulging in my 5 am ramblings :)
02:07:00 <shachaf> If you want an answer/discussion/whatever about evaluation, ask me tomorrow.
02:07:01 * shachaf vanishes.
02:07:35 * mstksg was referring in the previous statement about ocaml, in case that wasn't clear
02:09:01 <mstksg> osfameron: yeah, i see that irony heh. maybe the real context of this rant is that working in haskell has ruined me of the ability to think in any other way
02:13:19 <yitz> mstksg: most people can still think other ways after learning haskell. in fact, even better than before. it just becomes very painful.
02:14:08 <mjrosenb> I/O abstractions are not the reason I find writing C/C++ painful. :-p
02:25:40 <haasn> I went back to C# and had to write my own monad and pure IO abstractions :(
02:26:34 <quchen> haasn: Hehe, I find myself adding "_IO" to impure functions in other languages now. I guess everyone has his own way of griefing
02:26:51 <haasn> quchen: I prefix unsafe
02:27:16 <Maior> I wouldn't call it griefing...
02:27:49 <haasn> I think he meant grieving
02:28:03 <quchen> I meant "mourning"
02:28:06 <Maior> oh right
02:28:10 <quchen> Woopsie.
02:28:22 <Maior> I'm used to the term griefing from gaming, sorry
02:28:38 <haasn> I thought that might be it :)
02:28:41 <haasn> (I am too)
02:28:49 <quchen> Yeah I just used the wrong word there.
02:29:15 <quchen> Although, in haasn's case - prefixing "unsafe" - kind of goes in the griefing direction :-P
02:30:04 <haasn> I also use “public static const Func<A,B> foo” instead of “public static B foo (A a)” these days..
02:30:31 <quchen> … which means what exactly?
02:31:07 <haasn> quchen: basically, functions instead of methods/procedures
02:31:42 <quchen> haasn: Ah, it's like replacing classes with ADTs
02:31:58 <quchen> (Not sure whether that statement makes sense, pick a suitable interpretation)
02:31:59 <peteretep> You can just use a big hashmap where the input is the key and the output is the value
02:32:23 <peteretep> Guaranteed not to be bigger than 1 Aleph
02:32:32 <haasn> quchen: I do that, too. Immutable by-reference ‘classes’ with (static) fold functions to destruct them, scott-style
02:32:55 <mauke> I,I http://mauke.hopto.org/stuff/java/stress.java
02:33:11 <haasn> Honestly the main problem with it is (lack of) type inferencing
02:33:24 <haasn> I often have to write like 2-3 lines of type annotations just to construct/destruct all of my data..
02:35:02 <haasn> quchen: I also use a trick to get mutually recursive data types/functions this way. C# is surprisingly tolerant :P
02:36:46 <quchen> haasn: I hope you don't tell anyone it's Haskell-inspired if you do, though.
02:37:04 <quchen> They say there is no bad press. They are wrong. ;-)
02:37:41 <haasn> quchen: don't worry, all of my projects contain a 1-2 line equivalent in Haskell
02:38:23 <haasn> If that code size factor doesn't impress them, I don't know what will! :)
02:38:26 <quchen> The first line is // Aaaaand this is how that would look in Haskell
02:38:51 <haasn> quchen: the first line is // import Control.Lens
02:39:50 <quchen> haasn: You don't happen to have examples of that online?
02:40:25 <haasn> quchen: of weird/cool C# stuff? http://hub.darcs.net/nand/csharp/browse/PureIO/PureIO.cs
02:41:00 <haasn> http://hub.darcs.net/nand/csharp/browse/InfEnumerable -- look at how much smaller the Haskell version is \∩/
02:42:02 <quchen> Free ((,) a)  is isomorphic to  []?
02:42:14 <haasn> No
02:42:18 <haasn> Free ((,) a) () is isomorphic to [a] -- ignoring ⊥
02:42:33 <quchen> Close enough.
02:42:44 <haasn> (and the Monad instance works differently)
02:43:37 <quchen> So that program is "mapM_ print [5..]" written in a crazy way?
02:44:04 <haasn> Sort of, the idea was using Void instead of () to basically turn that [a] into Stream a
02:44:06 <haasn> So you know it never terminates
02:44:20 <haasn> I just wrote it to show an example of a use case for ‘Void’ to #csharp ..
02:44:37 <quchen> If that doesn't convince people then I don't know.
02:44:45 <haasn> :)
02:44:57 <quchen> main.unsafePerform()
02:44:59 <quchen> Why not :-D
02:45:43 <quchen> Ah, the Monad instance of your "Stream" is the Monad instance of Free of course
02:45:55 <quchen> So you won't get List-y >>= but simply Free plumbing
02:46:01 <haasn> right
02:46:09 <aleator> Quick security advisory plea: I'm using ghc-api to compile and execute code from the web. a) I use safe haskell and enforce a pure (known) return type for the function, b) I filter out GHC_OPTIONS and CPP pragmas, c) I've got an app-armor profile that limits write access to /tmp for the program and gcc it invokes, but allows reads to .cabal/lib/** and package.conf.d/package.cache, and /usr/local/lib/ghc/**. How would you hack my server?
02:46:16 <haasn> (which will never terminate, of course, in the case of Stream)
02:46:40 <haasn> quchen: but you could do cool stuff like prepending a List to a Stream with (>>) that way :P
02:46:44 <quchen> haasn: If you newtype your Free (...) you could write a proper List though, right?
02:46:51 <haasn> quchen: sure
02:47:20 <yitz> aleator: unsafePerformIO
02:47:27 <haasn> Wait a minute... I wonder if ‘concat’ for Free exists
02:47:28 <quchen> Free Monads are a pretty slow process for me. Intuition is coming slowly.
02:47:42 <quchen> concat = join?
02:48:03 <haasn> quchen: not for Free, ‘join’ on the free-list is like (++)
02:48:14 <merijn> yitz: unsafePerformIO can't happen with SafeHaskell if the uploaded code isn't trusted
02:48:25 <merijn> yitz: It's a compile error to use unsafePerformIO
02:48:28 <quchen> haasn: Yep.
02:48:31 <aleator> yitz: Doesn't safe haskell explicitly not allow that? (also, I limit imports to known libs)
02:48:40 <quchen> haasn: So with "concat" you meant a "concatenation function for FreeF" then?
02:48:45 <yitz> merijn: ok. if so, that's good.
02:48:48 <quchen> s/FreeF/ListF
02:49:00 <haasn> quchen: I mean something like Free (Free f) a -> Free f a
02:49:02 <haasn> If that makes sense
02:49:04 <yitz> aleator: yes limiting imports is good
02:49:38 <merijn> aleator: It sounds reasonably safe, but presumably it can still be broken
02:49:48 <quchen> haasn: Ah okay
02:49:54 <aleator> yitz: If I don't I guess a clever guy can effectively create an unsafecoerce by importing stuff just right.
02:49:56 <merijn> aleator: Clearly you should only run this on servers/machines that aren't critical/important :)
02:50:03 <yitz> merijn, aleator: safe haskell isn't designed to be a security feature though. people can lie and declare that non-safe modules are safe.
02:50:16 <merijn> aleator: Relatedly, which OS are you using and are you open to changing it
02:50:39 <quchen> yitz: Wait, isn't that the entire purpose of safe haskell, trusting code?
02:50:42 <merijn> yitz: Nope, read the safe haskell docs, they can *claim* to be trustworthy, but you can explicitly specify which packages GHC should believe
02:50:52 <aleator> merijn: linux+ubuntu currently. I could change it, but I need stuff like haskell-src-exts that wants unixy stuff.
02:51:07 <benmachine> HSE wants unixy stuff?
02:51:14 <RommelVR> wait, is Haskell whitespace sensitive in how it parses?
02:51:23 <yitz> quchen: trusting in the sense that best effort were made (by trustworthy people) to avoid doing things that could cause a crash.
02:51:25 <quchen> RommelVR: Yes, whitespace matters.
02:51:27 <merijn> aleator: FreeBSD has lightweight jails, for this stuff I'd use one of those
02:51:33 <merijn> yitz: Nope, also for security
02:51:40 <yitz> quchen: not trusting in the sense of blocking potential security holes.
02:51:44 <haasn> quchen: This seems to type check; f (Pure a) = Pure a; f (Free g) = g >>= f
02:51:47 <quchen> yitz: I thought modules compiling as "safe" should explicitly be trusted
02:51:48 <RommelVR> quchen: any reason why using tabs would break my code?
02:51:49 <benmachine> RommelVR: unless you use {;} explicitly (nearly everyone doesn't)
02:51:51 <haasn> And the semantics seem correct
02:51:57 <aleator> benmachine: Hmm. Doesn't. I was almost sure that it did..
02:51:58 <yitz> no
02:52:03 <benmachine> haasn: not Pure (f a)?
02:52:06 <quchen> RommelVR: Exhibit a) - the Haskell police will come and get you
02:52:15 <merijn> yitz: It's explicitly mentioned in the GHC manual to be for that reason
02:52:15 <benmachine> aleator: maybe transitively, but I'd be a little surprised
02:52:23 <haasn> benmachine: I'm not writing fmap :)
02:52:34 <benmachine> haasn: sorry, not really paying attention :P
02:52:35 <RommelVR> quchen: lol, would sooner use {;} before I use spaces :P
02:52:39 <haasn> RommelVR: as long as you treat tabstops as being 8 spaces it's fine
02:52:43 <aleator> benmachine: You're right. Doesn't seem to have. Perhaps I'm confusing it to something else.
02:52:50 <quchen> RommelVR: Many many beginner errors come from using tabs (and especially mixing them with spaces). The Haskell community has decided on using spaces only for pragmatic reasons. I strongly advise you to do that too.
02:52:57 <haasn> and I mean tabstops, not tab characters
02:52:59 <yitz> RommelVR: it's theoretical possible to get code containing tabs to compile, but by far not worth the effort.
02:52:59 <merijn> yitz: According to GHC manual: A module M in a package P is trusted by a client C if and only if:
02:52:59 <quchen> And that's all I'm going to say about tabs-vs-spaces.
02:52:59 <mikeplus32> RommelVR: tabs won't break your code but you can easily write broken code with tabs if your editor treats tabs as anything other than 8 spaces (which many do by default)
02:53:04 <RommelVR> haasn: ugh
02:53:07 <merijn> Both of these hold: 1) The module was compiled with -XSafe 2) All of M's direct imports are trusted by C
02:53:27 <mr-> RommelVR: tabs can lead to rather confusing error messages
02:53:34 <merijn> Or both of these hold 1) The module was compiled with -XTrustworthy 2) All of M's direct safe imports are trusted by C
02:53:42 <yitz> merijn: with the proper interpretation of the word "trust". it doesn't mean "trust" in the sense of security in this context.
02:54:11 <quchen> yitz: Right, "safe" modules can still compute wrong things etc. They just can't do fishy things behind your back.
02:54:11 <aleator> yitz: safe haskell gives me just an additional layer with easy error messages.
02:54:11 <merijn> yitz: Of course it's not all compassing security, but your claim that packages can claim to be safe when they aren't is downright false
02:54:39 <yitz> merijn: no it's absolutely true.
02:54:41 <anakreon> In fgl, for a node n, context n <> (lpre n, n, _, lsuc n). Why is that?
02:54:48 <aleator> yitz: But I'd be interested in seeing how you can get unsafeperformio with that on if I vet the modules that users are allowed to use.
02:54:52 <merijn> yitz: Did you read what I just linked? Tell me how you can claim to be safe
02:55:05 <quchen> haasn: Well if it typechecks it's probably true, eh
02:55:25 <haasn> yitz: oh, the signature I gave isn't what I wanted. I wonder what it's useful for, now
02:55:26 <RommelVR> without going into arguments, I can honestly never understand why people choose spaces over tabs... especially in a hobby where markup is everything
02:55:31 <yitz> merijn: you can write anything you want and declare it to be trustworthy (even though it's in fact evil), then import that in a different module and declare the second module to be safe.
02:55:33 <RommelVR> in a field*
02:55:40 <haasn> s/yitz/quchen/ oops
02:55:47 <merijn> yitz: Except that's not true
02:56:04 <merijn> yitz: Because Trustworhy is ignored when you don't explicitly trust the package using it
02:56:27 <haasn> RommelVR: because it keeps things compatible, consistent and easy to work with
02:56:28 <yitz> merijn: the second module explicitly trusts the first.
02:56:52 <merijn> -XTrustworthy — Means that while this module may invoke unsafe functions internally, the module's author claims that it exports an API that can't be used in an unsafe way. This doesn't enable the safe language or place any restrictions on the allowed Haskell code. The trust guarantee is provided by the module author, not GHC.
02:57:00 <merijn> *An import statement with the safe keyword results in a compilation error if the imported module is not trusted.*
02:57:07 <merijn> yitz: Trust is on a package basis
02:57:25 <merijn> yitz: Trustworthy claims in a module that are in an untrusted package mark the package as unsafe
02:57:34 <RommelVR> haasn: that is in no way true except for editors where you cant define tab width, which would be like getting a browswer that can't display html (useless)
02:57:47 <merijn> You can't launder Trustworthy modules into Safe without explicit trust on the package level
02:57:50 <yitz> merijn: untrusted by whom?
02:57:57 <merijn> yitz: The person calling GHC
02:58:14 <merijn> yitz: You explicitly specify a listed of trusted packages when compiling with -XSafe (at least, you can)
02:58:34 <merijn> Any other package are untrusted unless the two conditions I pasted earlier hold
02:58:56 <merijn> i.e. the package can be compiled with -XSafe and all its dependencies are (transitively) safe and/or truste
02:59:17 <merijn> Or the package is trusted and all it's Trustworthy imports are transitively Safe and/or Trusted
02:59:24 <haasn> RommelVR: I don't think there's a way I can respond to that without this resulting in a pointless war, sorry. At the end of the day, this (spaces everywhere) is the common style in Haskell, for better or for worse
02:59:54 <merijn> See section 7.25.4 of the GHC manual
03:00:21 <yitz> merijn: what it comes down to is that aleator must limit the packages allowed. safe haskell does not provide any guarantees to work around that requirement.
03:00:32 <boothead1> MonadCatchIO - mtl or transformers? and in fact more generally - where are you supposed to import Monad transformers from?
03:00:32 <RommelVR> haasn: fair enough, will have a good and look around, cheers
03:00:39 <aleator> yitz: I do! I do! :)
03:00:41 <merijn> aleator: Relatedly, see that section and make sure you have -distrust-all-packages and explicitly trusted whatever bits of Platform you trust
03:01:01 <aleator> merijn: Check.
03:01:28 <aleator> I've also used HSE to make sure the imports in the code appear in list of allowed imports manually.
03:01:28 <haasn> quchen: type List a = Free ((,) a) (); concat :: List (List a) -> List a; concat (Pure a) = Pure a; concat (x, xs) = x >> concat xs -- well that was easier than expected
03:01:54 <merijn> yitz: Safe Haskell lets you automatically limit packages to anything that is either explicitly trusted OR compiles directly with -XSafe (i.e. it plays within the rules of Safe Haskell), what more do you want?
03:02:49 <merijn> RommelVR: The problem with tabs in haskell is that haskell doesn't work based on indentation, but based on alignment and tab are assumed to jump to the closest tabstop (which are placed ever 8 characters)
03:03:21 <merijn> RommelVR: I always recommend this article for a comprehensive explanation of haskell layout: https://en.wikibooks.org/wiki/Haskell/Indentation
03:03:50 <yitz> merijn: explicitly excluding all but a specified list of packages is equivalent. safe haskell perhaps provides a different syntax that makes it a little more convenient, but in the end it's the same. providing more security is not the reason safe haskell exists.
03:05:03 <merijn> yitz: Section 7.25.1 of the GHC manual, "Uses of Safe Haskell" point 2: "Compiling and executing untrusted code"
03:05:22 <merijn> yitz: It explicitly claims right above that that Safe Haskell was designed for that purpose
03:05:30 <benmachine> Safe Haskell lets you use packages that you don't trust, by only allowing safe-inferred modules to be imported
03:06:37 <merijn> You can be as stubborn as you like about claiming I'm wrong, but don't spread misinformation
03:08:05 <chrisdone> i want TotalHaskell  =p
03:08:12 <merijn> chrisdone: Word.
03:08:36 <yitz> merijn: yes, that paragraph explicitly states that safe haskell does *not* provide any security itself. it does provide a facility which can be useful to someone building a security system around haskell.
03:08:37 <chrisdone> that will only allow me to import code that doesn't use error or have incomplete patterns. infinite loops are an acceptable trade-off
03:08:50 <merijn> yitz: Which is exactly how aleator was using it...
03:09:23 <RommelVR> merijn: ah, that at least makes sense, even if I hate it, lol
03:10:19 <RommelVR> merijn: and explains why my seemingly perfect aligned code wasn't working (in tabs)
03:10:27 <RommelVR> I have my tabwidth at 6 spaces :S
03:10:28 <yitz> merijn: simon marlow, who conceived and implement safe haskell, has stated this many times. his principal motivation was 7.25.1.1. He also realized that it could be a useful tool for what is described in 7.25.1.2.
03:11:12 <merijn> aleator: Anyway, back to the original discussion. As I mentioned, FreeBSD has jails (i.e. a kernel virtualisation interface) where you can have "lightweight virtual machines", basically it creates a copy of kernel datastructures (fairly cheap) and pretends to processes running in that jail that they're on a completely different machine
03:12:05 <merijn> aleator: i.e. from the processes point of view it looks like it's running in a private machine, while in reality it's sharing the same kernel as everything else. Think of it as the lightweight threading equivalent of virtual machines :)
03:13:21 <merijn> aleator: It's really cool for things like this where you want to run untrusted code securely, especially since it's easily possible to have a jail per untrusted process (I've regularly run 1 jail per process and seen stress tests where normal desktop machines can support >100k jails)
03:13:29 <yitz> well, simon writes: "flow control security, capability based security systems and DSLs for working with encrypted data.. etc". i don't think he is referring to what aleator is doing.
03:14:25 <merijn> RommelVR: Which editor are you using? The usual approach is to just use softtabs or something similar
03:16:00 <yitz> merijn: anyway, my point is this. there is a widespread misconception that safe haskell provides security automatically, mainly because of its choice of vocabulary that happens to overlap with security vocabulary. it is important for people to realize that this is far from true.
03:17:16 <RommelVR> merijn: I use vim, and the solution is easy (set expandtabs iirc)
03:17:36 <merijn> RommelVR: Oh, then I have the settings you want
03:17:41 <RommelVR> its just merijn: I use strict tabs for work any every other project, so I'd have to make a special case just for Haskell
03:18:05 <yitz> RommelVR: do you ever program in python?
03:18:17 <merijn> RommelVR: Proper tab settings in vim are: https://github.com/merijn/dotfiles/blob/master/vimrc#L37-L43
03:18:19 <RommelVR> yitz: a lot, again, strict tabs
03:18:50 <merijn> RommelVR: You might be interested in this to: https://github.com/merijn/dotfiles/blob/master/vimrc#L83-L85
03:18:58 <RommelVR> cheers merijn: I'll check it out, just need to remember how to special case based on detected file type
03:19:08 <merijn> RommelVR: The second one selectively changes tab settings for files in a certain subdirectory
03:19:09 <yitz> RommelVR: really? i've been pretty much out of python for a while now, but best practice in python was always - no tabs.
03:19:16 <RommelVR> yitz: its a PIP iirc
03:20:00 <RommelVR> but yeah, I ignore it outright, basically been a standard wherever I've worked that tabs have been more portable due to everyone having their own settings
03:20:24 <RommelVR> thankfully python is on indentation, not alignment, so thats perfectly OK
03:20:32 <merijn> RommelVR: If you look at my second link, just change the path into *.hs and a second entry for *.lhs and you should be set
03:20:52 <RommelVR> sweet, just waiting for github css to stop bugging out haha
03:22:26 <merijn> (Well, you'll want to change the settings being set there too, because those just toggle the tabwidth etc. while you'll want to selectively enable the stuff from the first link)
03:22:49 <RommelVR> afaik haskell enforces tabstop of div 8?
03:23:15 <merijn> RommelVR: Yes
03:23:16 <RommelVR> hmmm, githubs just refusing to load atm, will try again in a few minutes
03:24:56 <aleator> merijn: Are jails like chroot in that I've got to copy the required shareds per jail?
03:26:29 <RommelVR> merijn: I'm assuming your working on Windows? (Given the missing '.' on the files)
03:27:31 <Maior> so I've just had Fun because I had a tab instead of four spaces in my Haskell :(
03:29:00 <lessless> hi folks!  I'm going through tryhaskell and on step 18 task is to upcase word "Chris"
03:29:11 <bartavelle> aleator, yes
03:29:16 <merijn> aleator: Well, the thing is that a chroot can be broken out by someone obtaining root and calling chroot again
03:29:20 <lessless> author suggest to do  map toUpper "Chris"
03:29:22 <yitz> Maior: M-x untabify (if you're in emacs)
03:29:55 <merijn> aleator: In jails you can actually run code as root without it being able to break out. Yes, you do need to make shared files available if you chroot the jail somewhere on the filesystem, BUT
03:30:10 <lessless> but I can't see logic in this  - why do not just to use toUpper on the  whole string?
03:30:22 <bartavelle> merijn, can't you create node devices ?
03:30:24 <Maior> yitz: vivivi ;)
03:30:39 <merijn> aleator: FreeBSD has this filesystem overlay called nullfs, which lets you mount an existing directory as a new filesystem somewhere in your directory tree
03:30:46 <aleator> merijn: Right now I'm doing cost-benefit analysis on moving from apparmor (tricky to get right) to (perhaps) freebsd jails.
03:30:50 <merijn> aleator: And being a new FS you can (for example) mount it readonly
03:31:00 <chrisdone> lessless: toUpper works on characters, not strings! =)
03:31:06 <yitz> lessless: toUpper acts on individual characters.
03:31:10 <yitz> @type toUpper
03:31:11 <lambdabot> Char -> Char
03:31:16 <merijn> aleator: So then you can share readonly global things between jails and have writable scratchpad elsewhere
03:31:18 <chrisdone> lessless: you can  write :t toUpper in the prompt
03:31:23 <aleator> merijn: So to save space I could just mount /usr/bin as r-only?
03:31:50 <yitz> lessless: the type String is just an alias for [Char].
03:31:58 <merijn> aleator: I strongly recommend consulting the FreeBSD handbook for details, it's an amazing piece of documentation: http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/jails.html
03:32:03 <aleator> merijn: The thing I'm doing is this http://functional-programming.it.jyu.fi/exercises/gui/StrangeFoldsExercise
03:32:21 <aleator> So I've got plenty of these, which requires the jails to be quite light
03:32:41 <lessless> chrisdone, well,  than the problem is that the word decomposition  in to chars is not obvious here, right?
03:33:04 <chrisdone> lessless: hm, where?
03:33:06 <aleator> merijn: But anyways. I think I'll be quite seriously considering migration to freebsd.
03:33:13 <merijn> aleator: Well, as I said you can easily run like >100k jails on a single machine (provided they don't actually fill up your CPU/memory), the overhead is rather minimal
03:33:40 <aleator> merijn: Perhaps I'll see if I can make a virtual machine with required freebsd stuff first.
03:33:50 <merijn> aleator: In newer releases you can actually virtualize your entire network stack per jail too, it's cool stuff! But this might be heading into -blah territory :)
03:34:02 <chrisdone> lessless: is it not explained that a string is a list of characters and map works on lists? i don't remember
03:34:09 <aleator> merijn: I want my jails to have no network :)
03:34:36 <aleator> merijn: But thanks for the introduction. I think I'll get benefit from studying freebsd bit further.
03:34:50 <merijn> aleator: Well, that's certainly and option too (although you'll want some form of shared filesystem or network to get stuff in and out of them)
03:34:54 <haasn> tryhaskell doesn't really explain anything iirc
03:34:54 <lessless> chrisdone, hm,  so map is smart enough to interpret a word as a list of characters?
03:35:13 <merijn> lessless: No, Strings *are* lists of characters
03:35:23 <monoidal> > ['a','b'] == "ab"
03:35:24 <merijn> :t "Hello?" :: String
03:35:25 <lambdabot>   True
03:35:25 <lambdabot> String
03:35:31 <merijn> :t "Hello?" :: [Char]
03:35:32 <lambdabot> [Char]
03:35:33 <aleator> merijn: Currently, I'm launching processes and reading their stdout. BTW. is there any overhead in starting processes in jails?
03:35:44 <chrisdone> lessless: actually strings really are lists of characters. maybe that's not explained well in tryhaskell?
03:36:20 <merijn> aleator: Starting the jails has some overhead, running stuff inside shouldn't really
03:36:29 <chrisdone> hmm, it is mentioned, but i guess it's not underscored well enough:
03:36:29 <chrisdone> “Luckily, you can sort lists of characters, or strings, in the same way as numbers! sort "chris"”
03:36:54 <merijn> aleator: btw, #freebsd (or ##freebsd? I forget) on here is a pretty helpful channel too (although their first recommendation will be to read the handbook :))
03:37:23 <yitz> merijn: rtfh?
03:37:38 <chrisdone> lessless: ah, i think perhaps you skipped the syntactic sugar lesson: http://tryhaskell.org/#12 =)
03:37:45 <merijn> yitz: Pretty much :p
03:39:02 <yitz> merijn: just looking at the handbook. yeah, it's nice.
03:40:36 <merijn> yitz: It's existence was my main initial reason for picking FreeBSD over linux years ago. It's nice to have central, well-written documentation that comprehensively covers almost any basic (OS related) stuff you'd want to do :)
03:41:27 <aleator> merijn: How's the Haskell support on freebsd? Any gotchas there?
03:43:58 <lessless> chrisdone, hehe, I perceived Chars and String as different data types =)
03:44:26 <chrisdone> lessless: yeah, String is just an “alias” for [Char] (list of chars)
03:44:41 <chrisdone> =)
03:45:43 <lessless> chrisdone, thank you very much! now everything fit
03:45:45 <merijn> aleator: In the past I just installed ghc via ports without problems, I think there should be a haskell platform port nowadays. Not sure how up to date it is, but it should be easy to manually build a newer version starting from the default
03:46:23 <merijn> aleator: Oh, there's even binaries for it on the GHC homepage
03:46:42 <lessless> there is some enormous joy I'm feeling haking with Haskell :) Never feel so for the entire career
03:47:12 <chrisdone> lessless: wow =)
03:56:25 * hackagebot ac-machine 0.2.0.5 - Aho-Corasick string matching algorithm in Haskell  http://beta.hackage.haskell.org/package/ac-machine-0.2.0.5 (YutaTaniguchi)
03:56:27 * hackagebot ac-machine-conduit 0.1.0.0 - Drive Aho-Corasick machines in Conduit pipelines  http://beta.hackage.haskell.org/package/ac-machine-conduit-0.1.0.0 (YutaTaniguchi)
03:57:51 <RommelVR> merijn: the result https://github.com/RommelVR/dotfiles/blob/master/.vimrc#L72
04:03:16 <merijn> RommelVR: Yeah, that should work
04:03:23 <alpounet> "beta.hackage.haskell.org" ? could be changed now
04:09:13 <ScriptDevil> Ok, mildly off-topic. Who are the top functional-language/Haskell tweeters? I follow quite a few, but would like more feeds when travelling (doing it for quite some time next week)
04:14:15 <gienah> ScriptDevil: pigworker (is one suggestion)
04:18:55 <ocharles> i had to unfollow pigworker, he tweets a lot and I never understand it :P
04:20:19 <ScriptDevil> ocharles: If only I get what "Ult" means
04:20:38 <monoidal> ScriptDevil: that means, answering to previous (ultimate) tweet
04:20:54 <ScriptDevil> Oh! :p Makes a lot of sense now
04:21:13 <arjanb> ScriptDevil: i use both http://haskellnews.org/ and https://twitter.com/donsbot/haskellers to keep track of the haskell world
04:21:18 <ScriptDevil> I follow pigworker, ekmett, puffnfresh, donsbot and several others..
04:21:29 <capisce> ScriptDevil: copumpkin perhaps
04:21:33 <ScriptDevil> arjanb: Good suggestion. I will follow haskellers.
04:21:39 <ScriptDevil> capisce: :) Him too
04:22:07 <ScriptDevil> I should say I learnt more about Haskell in Twitter than anywhere else :P
04:22:20 <ocharles> ScriptDevil: follow meee!
04:22:22 <ocharles> :
04:22:23 <ocharles> :)
04:22:28 <ScriptDevil> Sure
04:22:32 <ocharles> i'm @acid2
04:23:39 <ScriptDevil> I was parallely doing a DFS of known Haskellers and adding more people :P
04:24:54 <ScriptDevil> haskellnews is wonderful. It should be in /topic
04:25:57 <ScriptDevil> Is HaskellWiki not updated that often or is HaskellNews's stream of HaskellWiki broken?
04:26:06 <ScriptDevil> Last update: 3 months ago
04:26:15 <ScriptDevil> The rest are like a day or 2 ago
04:27:27 <ocharles> sounds like the stream is broken
04:27:31 <ocharles> the wiki does tend to change
04:27:51 <yitz> RommelVR: no strip trailing spaces in haskell? no mass comments?
04:29:31 <ScriptDevil> chrisdone: The http://www.haskell.org/haskellwiki/index.php?title=Special:RecentChanges&feed=rss feed isn't reflecting in haskellnews
04:30:24 <danilo2> Hi! I've got very strange problem with RebindableSyntax. Could you pelase look at the short code here? : http://lpaste.net/93643 . The first implementation of "vtest" compiles and works, the second does not compile with an error "Couldn't match expected type `[Char] -> IO () with actual type ()".
04:30:41 <yitz> there's also planet.haskell.org
04:30:42 <RommelVR> yitz: hmmmm?
04:30:55 <danilo2> I was thinking that using rebindable syntax the provided examples are equal, that compiler is translating one to the other - am I wrong?
04:31:09 <RommelVR> oh. I haven't updated that line for .hs... hlol ta
04:31:52 <yitz> RommelVR: np :)
04:33:19 <monoidal> danilo2: it also adds "fail" in case of pattern match failure. of course (d,e) can't fail this way, but GHC does not know this
04:33:36 <monoidal> danilo2: if you have a fail function, change its type to String -> IO ()
04:33:37 <chrisdone> ScriptDevil: yeah, i need to do some maintenance. feeds are unreliable finicky things
04:33:51 <quchen> danilo2: Those two should be equivalent I think. That said, don't use RebindableSyntax.
04:34:05 <benmachine> what's wrong with rebinding syntax?
04:34:19 <quchen> benmachine: Nothing, unless you're not Mauke.
04:34:29 <benmachine> :(
04:34:32 <danilo2> monoidal: Youre right! thank you! :)
04:34:37 <ScriptDevil> chrisdone: Just reporting. Take your time. :)
04:34:53 <danilo2> quchen: monoidal is right, my fail function was implemented in wrong way :)
04:35:53 <chrisdone> dist/build/haskellnews/haskellnews haskellnews.conf import
04:35:53 <chrisdone> ("importHackage","(CurlHttpReturnedError,\"\")")
04:35:53 <chrisdone> ("importHaskellWiki","Unable to parse feed from: http://www.haskell.org/haskellwiki/index.php?title=Special:Recentchanges&feed=rss")
04:35:53 <chrisdone> ("importGithub","Unable to find tag ul.")
04:35:58 <chrisdone> ("importHaskellLive","Unable to extract publish date")
04:36:06 <chrisdone> ScriptDevil: stuff like this is fairly regular. feeds just don't last ;_;
04:36:06 <RommelVR> yitz: fixed :P, happy haha
04:37:00 * chrisdone updates the hackage url
04:37:22 <yitz> chrisdone: i suppose the hackage problem was related to the recent switch to hackage 2
04:38:21 <yitz> chrisdone: there were some recent infrastructure changes to the haskell.org domain. that may have caused some change to the wiki's feed.
04:38:22 <chrisdone> i'd expect so
04:39:11 <chrisdone> k, hackage feed is working
04:39:26 <benmachine> Hackage 2 provides some resources in multiple formats
04:39:45 <benmachine> maybe you can ask for a JSON version or something
04:41:08 <chrisdone> benmachine: the rss feed's fine. it's just changed urls
04:41:29 <benmachine> oh ok cool
04:43:10 <chrisdone> for some reason the feed library can't parse haskellwiki's output
04:50:30 <yitz> chrisdone: it did before, or it never did?
04:51:03 <yitz> chrisdone: it's just a vanilla mediawiki implementation iiuc
04:51:52 <RommelVR> so I have a lambda atm that is like this:     \(r1, g1, b1)(r2, g2, b2) -> (r1 + r2, g1 + g2, b1 + b2), is there a better way to do that :S
04:52:18 <opqdonut> RommelVR: use a type that's not a tuple
04:52:34 <RommelVR> The point is I have a list of [(Int, Int, Int)] and I want to summate them
04:52:54 <opqdonut> you could use a vector type that has a Num instance
04:53:16 <opqdonut> you could also consider writing a function liftTriple :: (a->b->c) -> (a,a,a) -> (b,b,b) -> (c,c,c)
04:53:31 <opqdonut> then you could use liftTriple (+) instead of that lambda
04:53:46 <RommelVR> meaning of lift?
04:54:12 <opqdonut> it usually means taking a function that operates on a type and turning it into a function that operates on some other type
04:54:17 <opqdonut> @type liftM
04:54:18 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
04:54:20 <opqdonut> @type liftA2
04:54:21 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:54:22 <opqdonut> etc.
04:55:03 <yitz> @type (&&&)
04:55:03 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
04:56:52 <chrisdone> yitz: hm,  it seems indeed that it  was due to some wikimedia change
04:57:01 <chrisdone> http://www.haskell.org/haskellwiki/index.php?title=Special:Recentchanges&feed=rss
04:57:01 <chrisdone> now redirects to: http://www.haskell.org/haskellwiki/index.php?title=Special:RecentChanges&feed=rss
04:57:05 * chrisdone updates the url
04:57:14 <donri> > zipWith (+) ((1,2,3) ^. partsOf each) ((4,5,6) ^. partsOf each)
04:57:17 <lambdabot>   [5,7,9]
04:57:36 <benmachine> donri: you get a list?
04:57:42 <donri> lol yeah
04:58:52 <chrisdone> @tell ScriptDev the wiki feed works now
04:58:52 <lambdabot> Consider it noted.
04:59:20 <donri> > sumOf (traverse.each) [(1,2,3),(4,5,6)]
04:59:21 <lambdabot>   21
05:00:06 <donri> > sumOf biplate [(1,2,3),(4,5,6)]
05:00:08 <lambdabot>   21
05:00:51 <donri> RommelVR: ^ with lens
05:01:42 <RommelVR> donri: <--- still new at Haskell, also, sumOf undefined? :S
05:01:50 <RommelVR> fuck
05:01:50 <donri> @hackage lens
05:01:50 <lambdabot> http://hackage.haskell.org/package/lens
05:01:56 <RommelVR> I meant I am , not u
05:02:07 <donri> ;)
05:02:26 <donri> cabal install lens and then import Control.Lens
05:02:45 <donri> also need Data.Data.Lens for biplate, or (folded.each) for a less magical version with no extra imports
05:03:06 <RommelVR> donri: not, this is what I was after: zipWith (+) ((1,2,3) ^. partsOf each) ((4,5,6) ^. partsOf each)
05:03:10 <RommelVR> 12:56 < lambdabot>   [5,7,9]note***
05:03:24 <RommelVR> (sigh, irssi is laggin like anything on my rpi)
05:03:32 <donri> RommelVR: well you have a list of triples and you want the sum of every number?
05:04:12 <RommelVR> vector sum, not chained summ
05:06:50 <donri> > zip <*> tail $ [(1,2,3),(4,5,6),(7,8,9),(10,11,12)] ^.. folded . to (sumOf each)
05:06:52 <lambdabot>   [(6,15),(15,24),(24,33)]
05:07:02 <donri> hmmm
05:07:51 <donri> right no
05:12:59 <RommelVR> donri: https://gist.github.com/RommelVR/b1407256ad8b73ce6735#file-gistfile1-hs-L15-L16, this seems like it'll do for now :S
05:15:57 <RommelVR> donri: not a horrible solution I hope? (what I posted)
05:16:05 <donri> no it's fine :p
05:16:19 <donri> but you probably want to use vector or something
05:17:33 <RommelVR> maybe, I'll have to check that out later, for now just want to figure out how this might work :S, on a side note, is the list building notation used on line 22 idiomatic?
05:18:00 <donri> sure, list comprehensions
05:18:10 <RommelVR> (also, how would I throw random in there... somehow I get the feeling this is all going to get ugly soon lol)
05:18:20 <donri> oh wait line 22
05:18:29 <donri> :t replicate
05:18:30 <lambdabot> Int -> a -> [a]
05:19:07 <donri> replicate 65 (sample x y)
05:19:57 <RommelVR> ah, atm its all the same value, but ideally sample will be doing something abit more and having an element of random added in there
05:20:46 <donri> for randomness you need either IO or pass around a seed or generator
05:20:51 <donri> @hackage random
05:20:51 <lambdabot> http://hackage.haskell.org/package/random
05:21:32 * hackagebot wai-routes 0.3.2 - Typesafe URLs for Wai applications.  http://beta.hackage.haskell.org/package/wai-routes-0.3.2 (AnupamJain)
05:22:26 <RommelVR> tempted to just make a shoddy prng and base it on the x, y and i of the sample (0 .. 6[C) haha4
05:22:59 <RommelVR> basic hash would work :S
05:24:11 <RommelVR> donri: know of any examples for random?
05:24:39 <donri> > random (mkStdGen 123)
05:24:41 <lambdabot>   (-1113545701,970416508 1655838864)
05:26:33 * hackagebot tx 0.1.0.0 - Persistent transactions on top of STM.  http://beta.hackage.haskell.org/package/tx-0.1.0.0 (MichaelSchroeder)
05:28:03 <RommelVR> donri: can I just pass a StdGen all the way down?  Will bthat break purity?
05:28:51 <RommelVR> http://www.haskell.org/haskellwiki/Examples/Random_list seems to make iout that that is possible, which seems odd
05:31:28 <pala2> Why this doesn't cut the given list into a list of lists in which every list contains the elements which follow each other and are the same? http://lpaste.net/2682426957202718720
05:31:57 <pala2> group [1,1,2,1,3,3,3] => [[1,1],[1]]
05:32:27 <pala2> but what I want is: group [1,1,2,1,3,3,3]  => [[1,1], [2], [1], [3,3,3]]
05:32:54 <mauke> > group [1,1,2,1,3,3,3]
05:32:55 <lambdabot>   [[1,1],[2],[1],[3,3,3]]
05:33:11 <mauke> > group []
05:33:12 <lambdabot>   []
05:34:05 <int-e> pala2: [x:ys] ++ group ys <-- something is wrong here :)
05:34:08 <merijn> mauke: He's referring to the lpaste link above, presumably (which has an implementation of group)
05:34:55 <nlogax> Given an Attoparsec parser that parses a substring of the input, is there an easy way to do something like `sepBy thatParser whatever` and get all parsed substrings? Basically skip everything until thatParser succeeds
05:35:27 <int-e> does  span . not  have a name?
05:35:33 <mauke> :t break
05:35:34 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:35:38 <int-e> thanks.
05:35:45 <mauke> @pl span . not
05:35:45 <lambdabot> span . not
05:35:48 <mauke> aww
05:36:08 <int-e> > break even [1,2,3] -- yay, another Haskell pun.
05:36:09 <lambdabot>   ([1],[2,3])
05:36:21 <int-e> (fix error  being my favorite one)
05:37:16 <mauke> > fix fail
05:37:17 <lambdabot>   ""
05:37:35 <kuribas> pala2: group ys, should be group zs?
05:37:52 <pala2> Could you explain why "[x:ys] ++ group ys" is wrong? [x:ys] is of type  [[t]], and "group ys" is of type [[t]], too... isn't it? so ++ should be right?
05:38:06 <int-e> pala2: it's simpler than that.
05:38:16 <pala2> yes...
05:38:29 <pala2> ys should be zs... thanks kuribas
05:38:37 <Phlogistique> int-e: what does "fix error" do?
05:38:43 <Phlogistique> > fix error
05:38:43 <monoidal> > fix error
05:38:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:38:45 <lambdabot>   can't find file: L.hs
05:39:11 <monoidal> > let x = error x in x
05:39:12 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:39:15 <int-e> Phlogistique: about the opposite of what the english language interpretation suggests.
05:39:33 <mauke> recursifail
05:39:53 <int-e> it raises an error that when printed raises an error that when printed raises ... well you get the idea.
05:39:54 <pala2> Where can I find the code for functions described here? http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:group
05:40:00 <kuribas> Often when I find my bug, it's something really stupid, not some deep architectural problem.
05:40:20 <kuribas> pala2: the "source" link to the right.
05:41:45 <kuribas> Like I had A*A / B*B, which should have been A*A / (B*B)
05:41:58 <mauke> A*A/B/B
05:42:08 <kuribas> yeah
05:42:19 <RommelVR> how would I import the Data.bits module?
05:42:23 <pala2> thanks!
05:42:34 <merijn> RommelVR: "import Data.Bits"?
05:42:45 <kuribas> mauke: A*A / (B*B) may be a bit faster.  At least it used to be.
05:43:23 <RommelVR> parse error? :|
05:43:43 <kuribas> mauke: I don't know if division is as fast as multiplication on modern processors.
05:43:54 <merijn> RommelVR: That seems to imply there's something else wrong with your code, put it on lpaste.net?
05:43:59 <RommelVR> oh, k, a capitalization mistake mthrows a mparse error, not a cant find library error :S
05:44:43 <RommelVR> that expected?
05:44:57 <merijn> kuribas: It isn't, but your mistake is assuming that division in a programming language is implemented as division directly on hardware
05:45:11 <merijn> RommelVR: It's a syntax error to have a module name start with lowercase
05:45:22 <danilo2> monoidal: According to my question about rebindablesyntax (you've told me I've got to implement fail the right way) - could you please tell me how exactly is the "do" syntax translated by ghc? Where the fail is exactly used?
05:45:53 <monoidal> danilo2: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
05:46:01 <RommelVR> merijn: ah,  thanks
05:46:04 <monoidal> danilo2: afaik ghc does not deviate from "translation"
05:46:34 <merijn> RommelVR: The benefit of this is that it is never ambiguous whether "foo.bar" is function composition or module qualification
05:46:47 <danilo2> monoidal: thank you very much! :)
05:47:27 <merijn> RommelVR: Since modules would always be "Foo.bar" (bar function from Foo module) vs "foo.bar" (function composition of functions foo and bar)
05:47:40 <quicksilver> monoidal: I think it deviate subtly because it translates straight to core, not to haskell
05:47:53 <quicksilver> I forget what the observable implications of that are, if any at all
05:48:16 <merijn> Things like llvm are supposed to perform optimisations like not using division directly
05:48:48 <merijn> Also, since Int/Integer division is a primitive, it's not clear what the Core division function actually does internally
05:49:04 <merijn> eh
05:49:12 <merijn> I seem to be getting my conversations mixed up
05:49:15 <merijn> Ignore me :p
05:49:59 <kuribas> merijn: You mean embedded hardware?  Division an embedded hardware is even slower!
05:50:28 <kuribas> merijn: Oh, I see...
05:50:56 <kuribas> merijn: It may optimize out the division.
05:51:35 <kuribas> merijn: Still, compilers can be conservative with optimizing floating point, due to subtile differences.
05:51:35 * hackagebot wai-routes 0.3.3 - Typesafe URLs for Wai applications.  http://beta.hackage.haskell.org/package/wai-routes-0.3.3 (AnupamJain)
05:51:45 <donri> RommelVR: might want to put the thing in a state monad and use "state random" to make new random values
05:52:39 <RommelVR> donri: still learning man, no idea how to do that haha
05:52:45 <donri> RommelVR: the PRNG is pure itself, only initializing the seed is impure (unless you use a constant seed)
05:53:04 <donri> RommelVR: no different from reading a string from a file and passing the string to pure functions
05:53:40 <merijn> edwardk: ping?
05:56:20 <RommelVR> true, but the state of where you are up to in the PRNG is stateful...?
05:57:09 <donri> RommelVR: it works by giving you a new StdGen each time
05:57:17 <donri> if you use the old one, you get the same number back
05:58:51 <RommelVR> oh, ok
05:59:31 <donri> RommelVR: and the state monad handles that for you, threading the new generators through
06:01:12 <donri> > evalState (do a <- state random; b <- state random; return (a,b)) (mkStdGen 123)
06:01:13 <lambdabot>   (-1113545701,-1952847176)
06:17:31 <duairc> I want to write 'Data.List.[]' in a Haddock comment, but Haddock doesn't parse this as I'd like it to. Does anybody know a way around that?
06:18:41 <monoidal> duairc: no, but Data.List.[] is not valid haskell syntax. why not just []?
06:19:11 <Maxdamantus> Not even as a type?
06:19:33 <Maxdamantus> Guess not.
06:22:31 <duairc> monoidal: Well that doesn't work either.
06:23:11 <DarkFox> Rarrikins: ping
06:24:53 <pavonia> duairc: What are you trying to do?
06:28:09 <duairc> pavonia: I have this sentence in some haddock documentation: There are monads representing computations capable of statefulness ('Control.Monad.Trans.State.State'), non-determinism ('Data.List.[]'), failure ('Data.Either.Either', 'Data.Maybe.Maybe'), input/output ('System.IO.IO') and many more.
06:28:39 <duairc> pavonia: I can't find anyway to get the list one to link properly
06:29:07 <pavonia> I guess the problem is, there's no target to link to
06:29:37 <Maxdamantus> :info []
06:29:58 <geekosaur> no :info in lambdabot
06:30:21 <Maxdamantus> ghci says GHC.Types.
06:31:36 <Maxdamantus> Maybe the types that involve magic syntax are in GHC.*
06:31:43 * hackagebot free-game 0.9.4 - Cross-platform GUI library based on free monads  http://beta.hackage.haskell.org/package/free-game-0.9.4 (FumiakiKinoshita)
06:32:08 <Maxdamantus> Bool, [], Monad (class), ..
06:32:11 <DarkFox> Rarrikins: http://hub.darcs.net/DarkFox/ChallengeGenerator < Just spent a little with this eariler.
06:32:21 <duairc> I don't think that's the problem, Haddock has no problem linking to types that don't exist, I think it's that Haddock isn't parsing it correctly.
06:32:44 <sinisa123> I'm using Yesod. How do I turn a Route Static into a Text path?
06:33:57 <sinisa123> Ah, the RenderRoute class.
06:44:44 <saml> is yesod good?
06:45:19 <Taneb> saml, depends what you are after
06:45:29 <Taneb> It relies heavily on Template Haskell
06:46:22 <Taneb> But other than that it is considered pretty good
06:46:34 <donri> i haven't actually used yesod myself but i imagine it's good for rapid prototyping of content-focused applications
06:49:17 <saml> i want rest api
06:49:45 <saml> need something that lets me define custom media types and link relations and generate centralized documentation (like man pages)
07:00:07 <chrisdone> saml: yesod are serious business
07:00:29 <saml> whoa. is ghcjs serious , too?
07:00:46 <chrisdone> uhhh i'd ask the authors whether it's ready for production yet
07:01:11 <luite> i only the authors were around
07:01:45 <chrisdone> haha. i'm officially pronouncing conduit with the french pronunciation from now on
07:01:49 <chrisdone> condwaaaa
07:02:22 <dfan> Isn't it more like condwee?
07:02:44 <kranius> /kɔ̃.dɥit/
07:02:59 <kranius> condweet
07:03:26 <geekosaur> final t pronounced, really?
07:03:36 <saml> kan doo wah
07:03:37 <kranius> une conduite
07:03:56 <Maxdamantus> Presumably only when followed be a vowel.
07:04:10 <saml> i know swidish
07:04:22 <saml> > interleave 'f' "conduit"
07:04:23 <lambdabot>   Not in scope: `interleave'
07:04:42 <Maxdamantus> kranius: the ‹n› in your transcription is slightly misleading.
07:04:44 <mr-> :t intercolate
07:04:45 <lambdabot>     Not in scope: `intercolate'
07:04:45 <lambdabot>     Perhaps you meant one of these:
07:04:45 <lambdabot>       `BSC.intercalate' (imported from Data.ByteString.Char8),
07:04:54 <Maxdamantus> (there's no /n/, just a nasalised vowel)
07:04:57 <mr-> :t intersperse
07:04:58 <lambdabot> a -> [a] -> [a]
07:05:00 <mr-> that's it!
07:05:40 <Maxdamantus> :t perkelate
07:05:41 <lambdabot> Not in scope: `perkelate'
07:05:57 <robindv> I'm fighting with the type-system that produces for me unreadable errors; someone? http://lpaste.net/2680911319078535168
07:06:46 <chrisdone> dfan: good point it would be condwee
07:07:01 <chrisdone> and yeah and with the t like suit
07:07:01 <dfan> "the function 'reachable1' is applied to three arguments, but has only two" seems pretty clear
07:07:02 <Maxdamantus> but with a nasalised vowel, and no /n/
07:07:19 <chrisdone> aww. that's not as amusing as condoir would be
07:08:06 <dfan> Err, but I don't see the line it's complaining about in your source
07:08:23 <dfan> Oh, it was from your interactive session
07:08:53 <dfan> Perhaps you meant reachable1 (ex_v, ex_edges) 1
07:09:21 <robindv> dfan: o well, that's a very stupid mistake..
07:10:20 <bartavelle> it is condwee
07:10:29 <dfan> The lesson is: if you read the type error carefully, it's often more understandable than you think
07:11:47 * hackagebot packed-dawg 0.2.0.1 - Generation and traversal of highly compressed directed acyclic word graphs.  http://beta.hackage.haskell.org/package/packed-dawg-0.2.0.1 (AndrasKovacs)
07:14:08 <chrisdone> bartavelle: seems you're right. at least, according to google translate's audio thingie http://translate.google.com/#fr/en/conduit
07:14:22 <bartavelle> well I'm French
07:14:32 <bartavelle> it's easier to get right about that kind of things :)
07:14:33 <chrisdone> hmm. but, but, google
07:14:39 <Apocalisp> Is there a name for ((|||) id) ?
07:15:18 <Iceland_jack> Apocalisp: The identity fence
07:15:25 <donri> :t right
07:15:26 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
07:15:26 <Maxdamantus> Though the ‹n› in English is quite different to the one in French.
07:15:32 <bartavelle> indeed
07:15:33 <donri> :t (id |||)
07:15:34 <lambdabot> (c -> a) -> Either a c -> a
07:15:35 <Apocalisp> Iceland_jack: góður
07:15:42 <Iceland_jack> Apocalisp: :)
07:15:45 <Maxdamantus> in English, it usually denotes a /n/, in French, it usually denotes nasalisation of the preceding vowel.
07:15:59 <chrisdone> madis it nj?
07:16:23 <chrisdone> Maxdamantus: er, is it a nj? you know the n with a curvy leg
07:16:39 <Maxdamantus> Reflexive? No.
07:16:56 <chrisdone> ŋ
07:16:57 <Maxdamantus> in IPA it's a ~ above a vowel letter.
07:17:03 <Maxdamantus> Oh, that's not reflexive.
07:17:06 <Maxdamantus> That's a velar nasal.
07:17:11 <chrisdone> yeah
07:17:16 <Maxdamantus> like on the end of "sing"
07:17:18 <chrisdone> like 'n' in  'song'
07:17:23 <chrisdone> or 'n' in 'anche' (italian)
07:17:53 <chrisdone> ah, apparently french only uses ŋ when it borrows from english
07:18:46 <Maxdamantus> But yeah, it's probably more similar to /ŋ/ than to /n/
07:19:37 <Maxdamantus> You usually articulate the nasalised vowels like the velar nasal consonant.
07:20:01 <chrisdone> i've a friend (also in the haskell community) called corentin dupont and i cannot pronounce his name
07:20:26 <bartavelle> it shouldn't be that hard
07:20:28 <Maxdamantus> His first name or last name?
07:20:59 <chrisdone> 'dupont' 'dupont' 'dupont' 'dupont' 'no, iz not dupONT, iz dupont' 'dupont' 'forget it'
07:21:20 <chrisdone> both really
07:21:38 <chrisdone> he accepted my corentin but i think begrudgingly =p
07:21:40 * Maxdamantus would have to look up the pronunciation of the first name.
07:21:44 * Maxdamantus could have a guess though.
07:22:07 <bscarlet> haskell-blah maybe?
07:22:08 <chrisdone> it sounds like 'coronton' if spelled englishy
07:22:21 <chrisdone> bscarlet: you have a haskell question?
07:22:50 * Maxdamantus guesses it's something like /,kɔ.r3'tẽ/
07:23:16 <bscarlet> chrisdone: No, and I don't want to be nitpicky, but I meant you might take the pronounciation discussion to #haskell-blah, it being somewhat off topic.
07:23:55 <chrisdone> thanks, i was just thinking "i need more policing in my life"
07:26:32 <bscarlet> chrisdone: I can't tell if you mean that sarcastically. Assuming so, I apologize if I've made you feel policed. I actually think your discussion is interesting, but when my window has filled up with a discussion having nothing to do with Haskell, I begin to wonder if the channel would seem somewhat offputting to the newbie's I'd like to draw in. Having made my suggestion, I have nothing further to add.
07:27:11 <chrisdone> donri: seen it? http://www.reddit.com/r/programming/comments/1ndlef/funny_why_haskell_is_great_at_translating_swedish/
07:42:51 <donri> heh
07:47:45 <danr> chrisdone: ehh
07:52:08 <DarkFox> Can anyone see any way to improve the following ?
07:52:25 <DarkFox> > let x = 20, y = 20 in [[ '.' | _ <- [0..x] ] | _ <- [0..y]]
07:52:27 <lambdabot>   <hint>:1:11: parse error on input `,'
07:52:35 <DarkFox> > let x = 20; y = 20 in [[ '.' | _ <- [0..x] ] | _ <- [0..y]]
07:52:37 <lambdabot>   [".....................",".....................",".....................","....
07:52:52 <DarkFox> > let x = 3; y = 3 in [[ '.' | _ <- [0..x] ] | _ <- [0..y]]
07:52:54 <lambdabot>   ["....","....","....","...."]
07:52:58 <DarkFox> Fits here :P
07:53:10 <DarkFox> erm besides the s/0/1/ bug :P
07:53:10 <opqdonut> > replicate 3 (replicate 3 '.')
07:53:11 <lambdabot>   ["...","...","..."]
07:53:20 <DarkFox> Heh
07:53:39 * DarkFox should really really really sleep
07:53:59 <FreeFull> > [(),(),()] >> [(),(),()] >> "."
07:54:00 <lambdabot>   "........."
07:54:08 <DarkFox> Well, mine was still better than what I read    replicate y [ s | s <- (replicate x '#') ]
07:54:08 <FreeFull> Not quite right
07:54:36 <FreeFull> > [(),(),()] >> [[(),(),()] >> "."]
07:54:37 <lambdabot>   ["...","...","..."]
07:54:39 <quchen> Before I send something stupid - does anyone know "Stijn van Drongelen"?
07:54:48 <DarkFox> quchen: Who?
07:54:50 <merijn> DarkFox: "[s | s <- ?]" is guaranteed to be identical to "?", so that seems a bit weird to write :p
07:54:57 <DarkFox> merijn: I know :P
07:55:10 <quchen> DarkFox: A pretty obscure mail just hit the libraries mailing list
07:55:11 <DarkFox> merijn: I didn't write that, but noticed that exact part after pasting here.
07:55:24 <FreeFull> merijn: It guarantees ? is a list
07:55:25 <quchen> And I wrote an answer, but want to make sure I'm not missing something crazy
07:55:26 <DarkFox> quchen: Fair enough
07:55:45 <DarkFox> FreeFull: That type is already infered by replicate
07:56:08 <chrisdone> danr: he's canadian, eh?
07:56:25 <DarkFox> merijn: http://hub.darcs.net/DarkFox/ChallengeGenerator/browse
07:56:25 <DarkFox> erm
07:56:41 <DarkFox> https://github.com/ubiquill/Haskword/blob/master/WordSearch.hs << The source of that madness
07:56:47 <FreeFull> Of course there is no reason to restrain types in code like that
07:57:17 <DarkFox> FreeFull: Crazy :P
07:58:58 <danr> chrisdone: is that so? (I couldn't really discern his accent) why do you think he assumes Swedish is intersperse 'f'? (I'm Swedish btw :) )
07:59:00 <monoidal> quchen: while I agree with your points, it would be much simpler to suggest a different module, GHC.Exts or whatnot
07:59:26 <quchen> monoidal: While I agree with my own points, "no." would have been the more appropriate answer
07:59:41 <monoidal> ?
07:59:56 <DarkFox> merijn: Btw, that haskword exports to a latex file!? I've already removed a lot of it and refactorized so much. Working on a little project to generate challenges, the wordsearch is only one stage for generating such challenges.
07:59:58 <FreeFull> danr: He was just being silly
08:00:06 <quchen> monoidal: Well, that proposal doesn't make sense in any context, that's what I meant
08:00:52 <monoidal> quchen: simplifying meaning of n+k from a strange guard to a view pattern has some merits, IMO
08:01:13 <quchen> monoidal: Such as?
08:01:24 <monoidal> quchen: simplicity is a value in itself.
08:01:28 <FreeFull> View patterns are a simple and kosher extension to haskell
08:01:52 <quchen> n+k-patterns however aren't.
08:02:24 <quchen> I mean they were explicitly removed, and he asked for a language-level modification to support them better.
08:02:37 <DarkFox> merijn: As for my solution not using replicate, I completly forgot about that function despite reading it haha.
08:04:00 <DarkFox> @define rot13
08:04:00 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:04:06 <DarkFox> Gimmeh your @let!
08:04:15 <DarkFox> @where rot13
08:04:16 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
08:04:19 <DarkFox> There we go
08:04:41 <quchen> What a beauty :-)
08:05:07 <DarkFox> Needs moar simplification
08:05:10 <merijn> DarkFox: Also, it can help to Hoogle for type signatures you want
08:05:12 <merijn> like
08:05:19 <merijn> @hoogle Int -> a -> [a]
08:05:19 <lambdabot> Prelude replicate :: Int -> a -> [a]
08:05:19 <lambdabot> Data.List replicate :: Int -> a -> [a]
08:05:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:05:45 <DarkFox> merijn: Yea, I know :) M-s h Int -> a -> [a] <return>
08:05:51 <DarkFox> (XMonad keybinding to search hoogle)
08:06:09 <DarkFox> Last I checked (while ago) hoogle was down. Back up I see though :)
08:06:14 <DarkFox> Hackage too. :)
08:06:40 <merijn> DarkFox: There was a migration of Haskell infrastructure (and recently again of Hackage) a while ago
08:06:42 <DarkFox> And hackage changed..... :P
08:06:48 <ibotty> hi,
08:06:49 <DarkFox> merijn: I've noticed.
08:06:54 <DarkFox> ibotty: ping
08:07:04 <DarkFox> ibotty: Your nick lies, you not botty.
08:07:05 <ibotty> i thought statically linking with ghc would just work
08:07:17 <DarkFox> ibotty: It does.
08:07:32 * geekosaur is reminded to see if hayoo is back yet... yup. fast work for them >.>
08:07:41 <ibotty> but i get linker errors: cannot find -ldl -lpthread -lgmp and a few others
08:08:07 <Sculptor> yo
08:08:07 <DarkFox> Blame the linker? :P
08:08:10 <ibotty> haha
08:08:12 <DarkFox> Sculptor: yoyo
08:08:20 <ibotty> the static libs are installed, the headers are there...
08:08:50 <DarkFox> ibotty: /nick I`mN07B077y
08:09:51 <DarkFox> ibotty: try ghc -static -optl-pthread -optl-static ProgramNameHere
08:10:00 <ibotty> that's what i do
08:10:06 <ibotty> (well cabal does)
08:10:07 <DarkFox> And without those?
08:10:14 <ibotty> without it works
08:10:22 <DarkFox> Which specific errors it?
08:10:30 <DarkFox> -static is default ...
08:10:48 <ibotty> /usr/bin/ld: cannot find -lutil
08:10:49 <ibotty> /usr/bin/ld: cannot find -ldl
08:10:49 <ibotty> /usr/bin/ld: cannot find -lpthread
08:10:49 <ibotty> /usr/bin/ld: cannot find -lffi
08:10:49 <ibotty> /usr/bin/ld: cannot find -lm
08:10:49 <ibotty> /usr/bin/ld: cannot find -lrt
08:10:49 <ibotty> /usr/bin/ld: cannot find -ldl
08:10:50 <ibotty> /usr/bin/ld: cannot find -lpthread
08:10:50 <ibotty> /usr/bin/ld: cannot find -lc
08:11:00 <DarkFox> ibotty: /topic
08:11:00 <quchen> > (let e[a,c]=zip[a..c].drop 13$cycle[a..c]in mapMaybe(`lookup`(e"az"++e"AZ"))) "hello" -- DarkFox
08:11:01 <lambdabot>   "uryyb"
08:11:29 <DarkFox> @where rot13
08:11:29 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
08:12:01 <DarkFox> quchen: Managed to get that smaller....
08:12:45 <quchen> Now it fits in a single editor line. :-D
08:12:47 <DarkFox> e[a,c] looks funny.
08:12:51 <DarkFox> quchen: :O
08:12:54 <DarkFox> Haha
08:13:04 <DarkFox> Looks like ea,ec
08:13:58 <DarkFox> quchen: Now.. remove the let :P
08:14:29 <quchen> You can also write l[o,l] or something.
08:14:39 <DarkFox> loll?
08:15:13 <DarkFox> I think you mean l[o,]
08:15:20 <DarkFox> no
08:15:26 <DarkFox> l{,o,}
08:15:50 <DarkFox> no first ,
08:17:17 <DarkFox> quchen: Try to remove that let...
08:18:22 <DarkFox> @pl (let e[a,c]=zip[a..c].drop 13$cycle[a..c]in mapMaybe(`lookup`(e"az"++e"AZ")))
08:18:22 <lambdabot> (line 1, column 7):
08:18:22 <lambdabot> unexpected "["
08:18:22 <lambdabot> expecting letter or digit, pattern or "="
08:18:25 <DarkFox> Heh
08:18:32 <DarkFox> @pl let a = (let e[a,c]=zip[a..c].drop 13$cycle[a..c]in mapMaybe(`lookup`(e"az"++e"AZ")))
08:18:32 <lambdabot> (line 1, column 15):
08:18:32 <lambdabot> unexpected "["
08:18:32 <lambdabot> expecting letter or digit, pattern or "="
08:18:35 <DarkFox> Fine
08:19:14 <quchen> Enough golfing for today.
08:20:11 <DarkFox> > let rot13=mapMaybe(`lookup`(e"az"++e"AZ"))where e[a,c]=zip[a..c].drop 13$cycle[a..c] in rot13 "Cleaner..."
08:20:12 <lambdabot>   "Pyrnare"
08:21:08 <DarkFox> quchen: Would you agree that the above is cleaner?
08:21:54 <quchen> It's also longer.
08:21:57 <DarkFox> @let rot13 = mapMaybe (`lookup` (e "az" ++ e "AZ" )) where e [a,c] = zip [a..c] . drop 13 $ cycle [a..c]
08:21:58 <lambdabot>  Defined.
08:22:00 <DarkFox> :P
08:22:05 <DarkFox> LONGER
08:22:16 <DarkFox> quchen: Better when split line at the where
08:22:35 <DarkFox> @let rot13 = (let e[a,c]=zip[a..c].drop 13$cycle[a..c]in mapMaybe(`lookup`(e"az"++e"AZ")))
08:22:36 <lambdabot>  .L.hs:150:1:
08:22:36 <lambdabot>      Multiple declarations of `rot13'
08:22:36 <lambdabot>      Declared at: .L.hs:1...
08:22:50 <DarkFox> @unlet rot13
08:22:50 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:22:53 <DarkFox> idk
08:22:59 <DarkFox> @forget rot13
08:22:59 <lambdabot> Incorrect arguments to quote
08:23:05 <DarkFox> !?
08:23:14 <monoidal> let a = (mapMaybe(`lookup`(["az","AZ"]>>=(\[a,c]->zip[a..c].drop 13$cycle[a..c])))) --DarkFox
08:23:23 <alpounet> the @forget command is to forget a quote
08:23:33 <DarkFox> alpounet: Figured
08:23:43 <DarkFox> monoidal: Snaller......
08:23:45 <merijn> You can do @undefine, but that wipes evyerhting
08:23:56 <merijn> (i.e. everything that was @let in the past)
08:23:56 <DarkFox> @undefine rot13
08:23:56 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
08:24:05 <DarkFox> oh
08:24:23 <DarkFox> Well, that's fine too any of those @let's even important?
08:24:33 <merijn> No clue :p
08:24:37 <DarkFox> @undefine
08:24:37 <lambdabot> Undefined.
08:24:38 <monoidal> let a = (mapMaybe(`lookup`(do [a,c]<-["az","AZ"];zip[a..c].drop 13$cycle[a..c]))) --DarkFox
08:24:42 <DarkFox> If so, their fault
08:24:48 <Cale> Usually you can assume that anything people put into @let isn't too important.
08:24:49 <DarkFox> dude
08:25:01 <joelteon> You know what lambdabot could do is just forget everything that has ever been letted and then re-let everything except the one requested
08:25:41 <DarkFox> joelteon: Could but patches are welcome :P
08:25:58 <DarkFox> monoidal: Btw that comment is dead
08:26:09 <DarkFox> I think..
08:26:21 <DarkFox> Or not
08:26:37 <DarkFox> Nvm monoidal. SMALLER !! :P
08:27:45 <DarkFox> > (mapMaybe(`lookup`(do{[a,c]<-["az","AZ"];zip[a..c].drop(13)$cycle[a..c]})))"fcnpryrff"
08:27:46 <lambdabot>   "spaceless"
08:27:48 <DarkFox> monoidal: :P
08:28:06 <dmj`> woa
08:28:14 <mr-> :t mapMaybe
08:28:15 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:28:25 <quchen> And it's the same length as the shortest one.
08:28:36 <quchen> Maybe this is suited better for #haskell-golf or something though.
08:28:49 <DarkFox> quchen: Two less?
08:28:56 <dmj`> #haskell-obfuscation
08:28:57 <DarkFox> more *
08:29:05 <DarkFox> dmj`: THAT EXISTS!?
08:29:16 <DarkFox> No :(
08:29:22 <earthy> ;)
08:29:22 <dmj`> haha :) no... not yet
08:29:22 * DarkFox would live there :D
08:29:29 <mr-> DarkFox: yeah, it's called #haskell-lens
08:29:53 <DarkFox> mr-: ++
08:30:28 <DarkFox> @pl (mapMaybe(`lookup`(do{[a,c]<-["az","AZ"];zip[a..c].drop(13)$cycle[a..c]})))
08:30:28 <lambdabot> (line 1, column 12):
08:30:28 <lambdabot> unexpected '`'
08:30:28 <lambdabot> expecting expression
08:30:31 <dmj`> ^*+~= (super lens operator)
08:30:32 <DarkFox> Screw you too
08:30:42 <DarkFox> dmj`: I hope that doesn't exist *yet*
08:31:14 <DarkFox> @hoogle ^*+~=
08:31:15 <lambdabot> No results found
08:31:17 <DarkFox> :)
08:31:19 <dmj`> :)
08:31:25 <pavonia> > ["az".."AZ"]
08:31:26 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
08:31:26 <lambdabot>    arising from the arithm...
08:31:53 <pavonia> How does that [a..c] work?
08:32:12 <chrisdone> :t enumFromTo
08:32:13 <lambdabot> Enum a => a -> a -> [a]
08:32:13 <applicative> on Enum things. String isn't Enum
08:32:20 <chrisdone> [a..c] is syntactic sugar for enumFromTo
08:32:25 <DarkFox> > let [a,c] = ["az","AZ"]
08:32:26 <lambdabot>   not an expression: `let [a,c] = ["az","AZ"]'
08:32:27 <DarkFox> For a start
08:32:33 <DarkFox> pftt
08:32:33 <bennofs> ^*+~= doesn't exists yet I think, there is <<%%@= though
08:32:40 <DarkFox> > let [a,c] = ["az","AZ"] in [a,c]
08:32:42 <lambdabot>   ["az","AZ"]
08:32:44 <DarkFox> :P
08:33:05 <DarkFox> wait
08:33:09 <mr-> bennofs: beautyful
08:33:44 <DarkFox> > [zip[a..c].drop(13)$cycle[a..c]|[a,c]<-["az","AZ"]]
08:33:45 <lambdabot>   [[('a','n'),('b','o'),('c','p'),('d','q'),('e','r'),('f','s'),('g','t'),('h...
08:33:50 <DarkFox> :)
08:34:01 <chrisdone> > take 10 $ let (x:xs) = 1 : x : map (+1) xs in xs
08:34:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:34:04 <pavonia> > do [a,c] <- ["az","AZ"]; return [a..c]
08:34:06 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ"]
08:34:16 <DarkFox> > (mapMaybe(`lookup`[zip[a..c].drop(13)$cycle[a..c]|[a,c]<-["az","AZ"]]))"test"
08:34:17 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, b0)'
08:34:17 <lambdabot>              with actua...
08:34:19 <DarkFox> naww
08:34:26 <pavonia> Aw, that list monad is confusing ...
08:34:36 <DarkFox> pavonia: Which one?
08:34:48 <pavonia> There's only one, no?
08:34:56 <DarkFox> pavonia: Oh yours
08:35:04 <DarkFox> pavonia: Yea, do / return can loop :P
08:35:24 <DarkFox> > do [a,c] <- ["az","AZ"]
08:35:25 <lambdabot>   The last statement in a 'do' block must be an expression
08:35:26 <lambdabot>    [a, c] <- ["az"...
08:35:50 <DarkFox> do [a,c] <- ["az","AZ"]      [[a..c]|[a,c]<-["az","AZ"]]
08:35:52 <DarkFox> equal
08:35:56 <applicative> > let alphabet = ['a'..'z']++['A'..'Z'] in [[a,b]| a<-alphabet, b<-alphabet]
08:35:57 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
08:36:33 <DarkFox> > let alphabet = [a..z]++[A..Z]
08:36:34 <lambdabot>   not an expression: `let alphabet = [a..z]++[A..Z]'
08:36:44 <DarkFox> > [a..z]++[A..Z]
08:36:46 <lambdabot>   A section must be enclosed in parentheses thus: (A.. Z)Not in scope: `A..'
08:36:46 <lambdabot> ...
08:36:54 * DarkFox should really sleep
08:37:05 <dmj`> sleep? its only 10am
08:37:12 <DarkFox> > ['a'..'z']++['A'..'Z']
08:37:13 <lambdabot>   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
08:37:17 <DarkFox> bamm
08:38:10 <zzzzzz> Hi! How do I generate .chs for GLib-based bindings? I want to port gstreamer Haskell bindings to a newer API version but don't know where to start
08:38:26 <dmj`> > let a = ['a'..'z'] in a ++ map toUpper a
08:38:27 <lambdabot>   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
08:38:34 <zzzzzz> I found ApiGen but not sure if it's still alive
08:38:37 <DarkFox> > [zip[a..c].drop(13)$cycle[a..c]|[a,c]<-["az","AZ"]]
08:38:38 <lambdabot>   [[('a','n'),('b','o'),('c','p'),('d','q'),('e','r'),('f','s'),('g','t'),('h...
08:38:41 <applicative> > filter isAlpha ['A'..'z']
08:38:42 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
08:38:58 <DarkFox> > mapMaybe (`lookup`[zip[a..c].drop(13)$cycle[a..c]|[a,c]<-["az","AZ"]]) "test"
08:38:59 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, b0)'
08:38:59 <lambdabot>              with actua...
08:39:08 * DarkFox moves to ghci
08:40:55 <chrisdone> zzzzzz: asking on the haskell-cafe mailing list might help there
08:41:19 <DarkFox> > let a = do{[a,c]<-["az","AZ"];zip[a..c].drop(13)$cycle[a..c]}; b = [zip[a..c].drop(13)$cycle[a..c]|[a,c]<-["az","AZ"]] in a == b
08:41:21 <lambdabot>   Couldn't match type `[(GHC.Types.Char, GHC.Types.Char)]'
08:41:21 <lambdabot>                wit...
08:41:26 <DarkFox> :C
08:42:03 <monoidal> >  mapMaybe(`lookup`(do[a,c]<-["az","AZ"];zip<*>drop 13.cycle$[a..c])) "hello" -- DarkFox
08:42:04 <lambdabot>   "uryyb"
08:42:06 <zzzzzz> @chrisdone: I asked on gtk2hs already, I thought crossposting wasn't a good idea
08:42:06 <lambdabot> Unknown command, try @list
08:42:08 <monoidal> anyway, I'll do somethine else now
08:42:09 * DarkFox wonders when the difference is created..
08:42:41 <zzzzzz> @chrisdone: I meant on gtk2hs mailing list
08:42:41 <lambdabot> Unknown command, try @list
08:43:02 <zzzzzz> chrisdone: I asked on gtk2hs mailing list already, I thought crossposting wasn't a good idea
08:43:33 <Kevin-_-> is there a reason why Data.List.sort [10 .. 1] == []?
08:43:42 <DarkFox> AH
08:43:48 <Rarrikins> > [10..1]
08:43:49 <lambdabot>   []
08:43:59 <Kevin-_-> that makes sense
08:44:01 <haasn> Kevin-_-: 10 > 1 so it terminates right away
08:44:06 <pavonia> > [10,9..1]
08:44:08 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
08:44:23 <DarkFox> Rarrikins: Hey. Not sure if you got my ping eariler.. http://hub.darcs.net/DarkFox/ChallengeGenerator/browse
08:44:26 <DarkFox> Bettererr
08:44:27 <monoidal> Kevin-_-: the development version of GHC warns about empty enumerations such as [10..1]
08:44:49 <haasn> chrisdone: “applicative functors and monad transformers” hahaha
08:45:16 <Kevin-_-> appreciate it, didn't think to check if [10 .. 1] was valid
08:45:23 <chrisdone> haasn: exsqueeze me?
08:45:32 <Rarrikins> DarkFox: Ahh, cool
08:45:51 <DarkFox> Rarrikins: Been playing with rot13 in here :D
08:46:31 <applicative> zzzzzz: dmwit is sometimes around here, you can ask him for some pointers. else I think the gtk2hs-devel list?
08:46:32 <chrisdone> i think i was writing rot13 when i was 13. i'm a few rotations away from that age now =(
08:46:39 <Rarrikins> DarkFox: Ahh, I see
08:47:14 <haasn> chrisdone: from the video you linked earlier, http://youtu.be/RqvCNb7fKsg
08:47:31 <ReinH> haasn: I love that video
08:47:41 <chrisdone> haasn: ah yeah, lol
08:47:45 <chrisdone> sounds like Snape
08:47:56 <DarkFox> main =putStr=<<mapMaybe(`lookup`(do[a,c]<-["az","AZ"];zip<*>drop 13.cycle$[a..c]))<$>getContents
08:47:57 <chrisdone> applicative … functors … potter
08:47:59 <DarkFox> :P
08:48:12 <ReinH> > intersperse 'f' "chrisdone"
08:48:13 <lambdabot>   "cfhfrfifsfdfofnfe"
08:48:31 <DarkFox> Rarrikins: Worth it's own binary tool or.... ? :P
08:48:46 <Rarrikins> If you want to do it a lot, I suppose.
08:50:19 <dmj`> those background folders though..
08:50:26 * DarkFox still unsure how to manage his challenge payloads... Not sure if I should work from the shell piping output or to make a library and / or automated randomizer for picking different algorithms and stages.
08:50:29 <chrisdone> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
08:50:31 <lambdabot>   "hail satan"
08:50:35 <cschneid> haasn, ReinH: I'm going to use this video to sell my bosses on haskell.
08:50:42 <ReinH> awesome
08:50:43 <zzzzzz> applicative: I already asked on gtk2hs-users few days ago. I wasn't sure it was related to gtk2hs itself.
08:50:48 <DarkFox> chrisdone: ...
08:51:01 * DarkFox wonders why chrisdone did ($)
08:51:14 <DarkFox> > zipWith3 (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
08:51:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char
08:51:15 <lambdabot>                               ...
08:51:20 <DarkFox> > zipWith3 $ (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
08:51:21 <chrisdone> because types and stuff
08:51:21 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
08:51:21 <lambdabot>                             ...
08:51:25 <DarkFox> oh
08:51:41 <chrisdone> apply const or flip const to 'h' and 'y', etc.
08:51:48 <DarkFox> :t (($))
08:51:49 <lambdabot> (a -> b) -> a -> b
08:51:54 <haasn> cschneid: let me know how it works out :)
08:51:56 <DarkFox> I see
08:52:00 * hackagebot HsSVN 0.4.3.3 - Partial Subversion (SVN) binding for Haskell  http://beta.hackage.haskell.org/package/HsSVN-0.4.3.3 (MasatakeDaimon)
08:52:03 <chrisdone> ($) and $ are the same
08:52:15 <cschneid> lol. I'm already obnoxiously enthusiastic about haskell. This wouldn't be any more annoying than I already am
08:52:19 <DarkFox> Seems different when you're using it
08:52:45 <sipa> if X is an operator, (X) is the function form of it
08:52:48 <sipa> > 3 + 5
08:52:49 <lambdabot>   8
08:52:52 <sipa> > (+) 3 5
08:52:53 <lambdabot>   8
08:53:05 <DarkFox> Oh duh
08:53:19 <mr-> > 2 `(+)` 2
08:53:19 <lambdabot>   <hint>:1:4: parse error on input `('
08:53:23 <DarkFox> > 3 `(+)` 2
08:53:24 <lambdabot>   <hint>:1:4: parse error on input `('
08:53:28 * DarkFox o/ mr- 
08:55:02 <pavonia> > let o = (+) in (`o`) 1 2
08:55:03 <lambdabot>   <hint>:1:20: parse error on input `)'
08:55:36 <haasn> chrisdone: further proof that Haskell is the work of the antichrist
08:55:43 <chrisdone> @let reapply n = flip (foldr ($)) . replicate n -- darkfox
08:55:44 <lambdabot>  Defined.
08:55:47 <chrisdone> > reapply 3 (+50) 7
08:55:53 <lambdabot>   157
08:55:57 <applicative> 'so ... check mate atheists'
08:56:00 <FreeFull> Wait
08:56:04 <FreeFull> Why did that parse error
08:56:16 <applicative> that's a pretty good video by mr. frungyking
08:56:38 <chrisdone> yeah he definitely got people talking about (and laughing with) haskell =)
08:57:12 <DarkFox> chrisdone: That doing "3 (+50)" 7 times?
08:57:24 <applicative> soon anyone will be able to afford to pronounce a very very swedish word
08:57:53 <Rarrikins> > reapply 3 . reapply 3 (+50) $ 7
08:57:55 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
08:57:55 <lambdabot>    arising from a use ...
08:58:00 <haasn> :t foldr (.) id .: replicate
08:58:01 <lambdabot>     Not in scope: `.:'
08:58:01 <lambdabot>     Perhaps you meant one of these:
08:58:01 <lambdabot>       `.' (imported from Data.Function),
08:58:16 <haasn> > let f n = foldr (.) id . replicate n in f 3 (+50) 7
08:58:17 <chrisdone> DarkFox: it's doing (+50) 3 times
08:58:17 <ReinH> restricted to lower case:
08:58:18 <lambdabot>   157
08:58:19 <ReinH> > let rot13  = fmap (\c -> chr ((ord c - ord 'a' + 13) `mod` 26 + ord 'a')) in rot13 "foo"
08:58:20 <lambdabot>   "sbb"
08:58:31 <ReinH> sorry I'm late to the ROT13 party
08:58:43 <Rarrikins> > reapply 3 (reapply 3 (+50)) 7
08:58:43 <chrisdone> ReinH: rein13
08:58:46 <lambdabot>   457
08:59:02 <haasn> > let f n g x = scanl g x !! n in f 3 (+50) 7
08:59:04 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [a1]'
08:59:06 <chrisdone> :t reapply 4 (1:)
08:59:07 <haasn> :(
08:59:07 <lambdabot> Num a => [a] -> [a]
08:59:11 <chrisdone> reapply 4 (1:) []
08:59:13 <chrisdone> > reapply 4 (1:) []
08:59:16 <lambdabot>   [1,1,1,1]
08:59:22 <DarkFox> I kinda get that...
08:59:24 <haasn> err
08:59:25 <dmj`> @ty flip intersperse
08:59:26 <lambdabot> [a] -> a -> [a]
08:59:33 <dmj`> @ty (flip `interperse`)
08:59:34 <lambdabot>     Not in scope: `interperse'
08:59:34 <lambdabot>     Perhaps you meant one of these:
08:59:34 <lambdabot>       `BS.intersperse' (imported from Data.ByteString),
08:59:35 <Rarrikins> > (!! 4) . iterate (1:) $ []
08:59:36 <lambdabot>   [1,1,1,1]
08:59:37 <haasn> > let f n g x = iterate g x !! n in f 3 (+50) 7
08:59:38 <lambdabot>   157
08:59:43 <dmj`> @ty (flip `intersperse`)
08:59:44 <lambdabot> [(a -> b -> c) -> b -> a -> c] -> [(a -> b -> c) -> b -> a -> c]
08:59:45 <FreeFull> :t reapply
08:59:45 <DarkFox> I get it
08:59:46 <lambdabot> Int -> (c -> c) -> c -> c
08:59:49 <chrisdone> the magic is in foldr
08:59:49 <chrisdone> :t foldr ($)
08:59:50 <lambdabot> b -> [b -> b] -> b
08:59:54 <DarkFox> I inverted my reading of the function
08:59:55 <DarkFox> :P
09:01:35 <dmj`> haskell is all over hacker news today
09:01:44 <DarkFox> dmj`: Orly?
09:01:55 <sm> hackage 2 has been noticed ?
09:02:10 * DarkFox ^F "Haskell" nothing
09:02:12 <ReinH> we need haskellnews
09:02:19 <DarkFox> dmj`: Which hackernews we talking herE?
09:02:24 <dmj`> https://news.ycombinator.com
09:02:28 <DarkFox> ReinH: see mailinglists
09:02:28 <FreeFull> http://haskellnews.org/
09:02:29 <haasn> :t from enum.subtracting (ord 'a').involuted (`rem` 26) +~ 13 -- this may be the dirtiest lens code I have ever written
09:02:30 <lambdabot>     Not in scope: `subtracting'
09:02:30 <lambdabot>     Perhaps you meant `subtract' (imported from Prelude)
09:02:36 <DarkFox> http://thehackernews.com/
09:02:37 <haasn> blah, somebody needs to update lambdabot :(
09:02:39 * DarkFox searched there
09:02:44 <DarkFox> So many of them :P
09:04:30 <DarkFox> http://thehackernews.com/2013/09/Apple-TouchID-fingerprint-scanner-hacking-unlock-iphone.html
09:04:33 <DarkFox> LOL
09:04:42 <DarkFox> Scanning a whole room of people into the db.
09:09:16 * DarkFox should go back to trying to sleep - night #haskell
09:09:29 <DarkFox> Tue Oct  1 02:09:05 EST 2013
09:09:31 * DarkFox out
09:09:54 <ReinH> are any unsafe* functions in a Haskell langauge spec or are they all implemented by GHC?
09:10:03 <ReinH> *language
09:10:29 <quicksilver> unsafePerformIO is in the language spec
09:10:38 <haasn> it is?
09:10:46 <FreeFull> Yeah, for FFI
09:10:50 <haasn> Oh, right
09:11:04 <quicksilver> technically it's not a function, of course
09:11:11 <quicksilver> so perhaps we can answer no ;)
09:11:20 <haasn> I wonder what the easiest way to implement unsafePerformIO via the FFI would be
09:12:27 <haasn> quicksilver: FFI still allows you to easily write unsafe functions other than unsafePerformIO, though
09:12:37 <quicksilver> yes indeed
09:12:38 <FreeFull> haasn: unsafePerformIO = Foreign.unsafePerformIO
09:12:55 <FreeFull> Clearly the easiest way
09:12:56 <sm> dmj' I think you're referring to these recent HN posts: https://news.ycombinator.com/item?id=6469147 and https://news.ycombinator.com/item?id=6469542 . Out of interest I checked haskellnews.org and it had them both, but via reddit not HN (which revealed more discussion). It might be nice if haskellnews had a HN section as well, but maybe that's impractical chrisdone ?
09:13:40 <haasn> FreeFull: does that actually get exported? (as defined in the haskell 2010 report)
09:14:11 <dmj`> sm: yea haskell at SQream
09:14:32 <applicative> sm: is it easy to isolate the haskell-relevant discussions on HN?
09:15:05 <haasn> FreeFull: oh, I do see unsafeForeignPtrToPtr though
09:15:10 <haasn> So that answers ReinH's question :)
09:15:23 <dmj`> applicative: I just cmd+f 'haskell' on front page
09:15:34 <haasn> also http://www.haskell.org/onlinereport/haskell2010/haskellch30.html#x38-28500030 provides unsafeLocalState
09:15:41 <haasn> Aha! that's unsafePerformIO
09:15:42 * sm votes http://haskellnews.org/grouped for prominent linking at the bottom of haskell.org front page
09:15:58 <haasn> ..except it isn't
09:17:07 <chrisdone> sm: +1 =p
09:18:22 <applicative> i have no idea what the github heading on
09:18:33 <applicative> that page is doing
09:18:34 <FreeFull> haasn: Oh, it's in System.IO.Unsafe now
09:19:35 <chrisdone> applicative: the github heading was showing any updates on github on any haskell projects. it was a cool way to discover new things peopple were working on. github have since removed that page i was scraping. i'm not sure that i can get similar data from it anymore ;_  ;
09:20:40 <applicative> chrisdone: yeah, I used to look at that page, and wondered how to reconstitute it
09:37:05 <leroix> Hi, I'm having a hell of a time getting ghc 7.6.3 installed on ubuntu 13.04
09:37:15 <leroix> Has anybody had any success doing this?
09:37:25 <leroix> I tried to follow http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
09:37:36 <leroix> but now I'm getting this: http://askubuntu.com/questions/351898/building-ghc-7-6-3-on-ubuntu-13-04-leads-to-error-in-dynflags-hs
09:38:13 <quchen> Why do you want to compile GHC yourself?
09:38:19 <quchen> You can just download the binaries
09:38:27 <h007> how to test a binary tree if it has minimum depth of d? checkdepth::Tree -> Bool
09:38:33 <leroix> Is there a binary for Ubuntu 13.04?
09:38:56 <h007> I'm guessing i should deconstruct atleast 2 levels in the tree, is this right?
09:39:17 <quchen> leroix: The binaries I'm talking about are available on the GHC website.
09:39:17 <h007> correction: d levels
09:39:27 <quchen> But there surely is a GHC package in Ubuntu.
09:39:37 <leroix> There is but it's an old version
09:39:50 <ReinH> h007: this is your own tree, not Data.Tree (which is not a binary tree)?
09:39:56 <quchen> leroix: What's "old"?
09:39:58 <leroix> and I think if you try to get the debian binary it won't be dynamically linked against /usr/lib/libgmp.so.3
09:40:17 <leroix> ghc via the Ubuntu package manager is an old version
09:40:20 <Fuz> hey
09:40:21 <leroix> 7.6.2
09:40:27 <merijn> quchen: I believe Ubuntu distributes a 2 or 3 version old platform
09:40:39 <quchen> Well then install it manually and curse Ubuntu.
09:40:46 <h007> ReinH: yes, I'm using a simple tree definition: e.g. data Tree=Node Tree Tree | Leaf Value
09:40:46 <Guest37828> if i were to use list comprehension to count the number of positive integers in a list, what library function could i use?
09:40:57 <ReinH> h007: are these finitary trees?
09:41:05 <merijn> quchen: Every linux distro seems to break the platform in suitably confusingly different subtle ways :)
09:41:20 <quchen> leroix: Here's what I use to run the manual installation. It downloads GHC binaries and builds the Platform manually. https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md
09:41:32 <quchen> merijn: And that's why we hate it when people manage our packages.
09:41:34 <h007> ReinH: not quite sure what finitary trees are?
09:41:39 <ReinH> h007: are your trees infinite?
09:41:53 <leroix> @quchen thanks I'll look into that
09:41:53 <lambdabot> Unknown command, try @list
09:41:54 <dmj`> > length . filter (>0) $ [1,2,3,4,5,(-10)]
09:41:55 <lambdabot>   5
09:41:58 <h007> ReinH: could be... the tree can be randomly generated
09:42:17 <dmj`> Guest37828: length . filter (>0) could work
09:42:29 <ReinH> h007: ok, then you can't use length
09:42:43 <h007> ReinH: nope
09:42:58 <Guest37828> is that using list comprehension, dmj` ?
09:42:58 <ReinH> h007: is this a balanced tree?
09:43:17 <h007> ReinH: very unlikely.
09:43:26 <ReinH> then you have to explore all branches
09:43:27 <dmj`> Guest37828: onlyPos xs = [ x | x <- xs, x > 0 ]
09:43:47 <dmj`> length [ x | x <- [1,2,3,4,5,(-10)], x > 0]
09:43:53 <dmj`> > length [ x | x <- [1,2,3,4,5,(-10)], x > 0]
09:43:54 <lambdabot>   5
09:44:09 <Guest37828> ah
09:44:09 <h007> ReinH:  i was guessing so. but I don't want to go down the whole tree. how to i implement such a function
09:44:14 <dmj`> list comps aren't necessarily necessary
09:44:17 <ReinH> h007: you can use a breadth-first algorithm where you keep track of your current level
09:44:25 <haasn> > lengthOf (each.filtered (>0)) [1,2,3,4,5,(-10)]
09:44:27 <lambdabot>   5
09:44:44 <dmj`> Guest37828: Is this for school?
09:44:53 <Guest37828> yeah it is
09:45:23 <ReinH> h007: keep track of your current level in an accumulator and continue deepening until you either run out of branches or reach your target number
09:45:37 <ReinH> if you run out of branches, your outer function is false, otherwise true
09:46:02 <dmj`> Guest37828: I appreciate your honesty, but next time please give this a concerted effort before asking people to do your homework for you.
09:46:22 <Guest37828> i wasn't looking for a direct answer
09:46:25 <Guest37828> i pmed you
09:46:35 <Guest37828> all i was looking for was a sort of library function
09:47:13 <ReinH> h007: this is O(n) but you can't do any better with an unbalanced tree
09:47:18 <ReinH> afaik
09:50:31 <Guest37828> > take 10 $ cycle [1]
09:50:33 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
09:51:06 <monoidal> Guest37828: you can use replicate 10 1 for this.
09:52:14 <ReinH> h007: your traversal function can take (level, nodes) starting with (1, [root]) and go breadth-first by recursing on (succ level, concatMap children nodes), with base cases go (level, []) = False and go (n, _) = True to break out of the recursion and provide your result
09:53:01 <ReinH> er go (_, []) = False
09:53:01 <h007> ReinH: thanks, i'm trying to come up with a similar solution
09:57:32 <ReinH> er go (level, []) | level == n = False | otherwise = go (succ level, concatMap children nodes)
09:59:50 <h007> ReinH: what is the children function in your code?
10:01:25 <ReinH> h007: children Leaf _ = []; children Node a b = [a,b]
10:01:36 <h007> ReinH: and are you going down the whole tree? I though when you said O(n), n referred to the depth size
10:01:58 <ReinH> n refers to the number of nodes in the tree (worst case)
10:03:11 <ReinH> since you can't assume anything about the shape of the tree, you have to explore all branches. This means worst case traverses all nodes.
10:03:59 <ReinH> oops needs parens: children (Node a b) = [a,b]
10:04:24 <h007> ReinH: but if while traversing, I am at a node and I know I've traversed x node down the tree so far, and this x matches the minimum depth  I want, then I don't need to traverse further, I just return from there
10:04:38 <ReinH> right, but big-O is worst case
10:04:45 <ReinH> average case will be better
10:05:01 <monoidal> big-O is any case
10:05:02 <h007> ReinH: yea, ofc!
10:05:18 <FreeFull> Well, big-O is used to describe both worst, average and best case
10:05:18 <monoidal> you can say "average case is O(n log n), worst case is O(n^2)"
10:05:26 <ReinH> monoidal: ok
10:05:30 <ReinH> worst case is O(n) :)
10:05:33 <Sagi> hello! I'd like to define a type for a function and use a context in that type, e.g. type Criterion = Eq a => Path -> [a]
10:05:35 <h007> ReinH: any chance of seeing the whole code, if you have
10:05:54 <ReinH> h007: I don't have the whole code anywhere but here
10:05:55 <Sagi> that seems not to work, is what I'm trying possible?
10:06:09 <h007> ReinH: ok
10:07:26 <Sagi> ghc hints me to look at -XRankNTypes or -XRank2Types, but I don't really get how to solve my problem :-\
10:07:37 <yitz> Sagi: no. http://www.haskell.org/onlinereport/haskell2010/haskellch4.html (see section 4.2.2).
10:08:07 <Sagi> okay, thanks
10:08:27 <monoidal> Sagi: you can compile with -XRankNTypes, and then Criterion will be a synonym for forall a. Eq a => Path -> [a], not sure if you want that
10:08:39 <yitz> Sagi: with data you can do it with rank2types, but i doubt that's what you really want.
10:09:07 <monoidal> yitz: Sagi's declaration is valid syntax with rank2
10:09:31 <yitz> monoidal: ok. not a very useful type though.
10:09:39 <Sagi> hmm, I'm not really familiar with forall
10:09:51 <monoidal> Sagi: what do you want to do?
10:10:25 <Sagi> I want to pass a function as an argument to a second function, preferably labeled using a type.
10:10:27 <yitz> Sagi: i think you want: type Criterion a = Path -> [a], then include the Eq a constraint where you use the synonym.
10:10:40 <Sagi> yitz: that would work
10:11:31 <Sagi> I'm not sure if that's more readable than just putting in the whole signature without the type though
10:12:04 <yitz> Sagi: depends how important it is to get across to a human reader that this is a Criterion.
10:12:38 <Sagi> pretty important, I will be using the code verbatim in a thesis, so I want all implicit documentation I can get :-)
10:13:00 <yitz> Sagi: ok i'd say go with Criterion then.
10:13:02 <Sagi> if I read forall a. Eq a => Path -> [a] in natural language it kind of sounds what I want
10:13:29 <Sagi> it just means a can be anything as long it's in class Eq, right?
10:13:44 <applicative> no, it can't be though, can it, Sagi.
10:14:06 <applicative> right, but how can a function Int -> [a] , for example, work on any Eq type?
10:14:15 <monoidal> Sagi: the only things you can construct of type [a] are empty lists and undefined values/errors
10:14:16 <applicative> it has to return []
10:14:26 <yitz> Sagi: yes and it guarantees that wherever you use this, you will not be able to do *anything* with elements of a *ever* except test equality.
10:14:40 <Shin-LaC> if I search for "minimum" on Hoogle, the definition minimum :: Ord a => [a] -> a exists in haskell2010-1.1.1.0, haskell98-2.0.0.2, base-4.6.0.1; however, Hoogle knows to link only to base, probably because haskell98 and haskell2010 just reexport the function from base. my question is: how can you tell if a package is just reexporting a symbol?
10:14:47 <tom39341> "The spark pool has a fixed size, and if we try to create sparks when the pool is full, they are dropped and counted as overflowed." http://chimera.labs.oreilly.com/books/1230000000929/ch02.html Does sparks being dropped change the result of a program, or just the speed?
10:15:06 <Sagi> ah
10:15:21 <tom39341> I assume dropped means it .. "falls out of the Eval monad" and is evaluated as normal, rather than... the thunk disappears?
10:15:32 <Sagi> then I should probably use type Criterion a = Path -> [a] and add the Eq constraint later
10:15:46 <Sagi> thanks yitz, applicative, monoidal
10:16:03 <applicative> tom39341: it certainly shouldn't change the result!
10:16:10 <ReinH> tom39341: only the parallelism
10:16:19 <tom39341> applicative, ReinH: Thought so. Thanks. :)
10:16:30 <ReinH> inability to create a spark forces work
10:16:43 <ReinH> (the work that spark would have done)
10:18:26 <ReinH> tom39341: pretty sure someone would have noticed if parMap rpar id [1..someBigNumberThatCausesSparkOverflow] was dropping results ;)
10:20:20 <yitz> Shin-LaC: perhaps the online Hoogle doesn't index haskell2010 or haskell98.
10:20:49 <ReinH> is it safe to update to XCode 5 for OS X yet?
10:20:59 <nejucomo> Every couple of months I forget how to reason about why this is illegal: instance A t => B t — and someone explains it to me on IRC.  Is there a blog post or online reference that describes why this is ambiguous/incoherent ?
10:21:01 <yitz> Shin-LaC: use the :i command in GHCi.
10:21:25 * nejucomo is reading http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-class-extensions.html#instance-overlap
10:21:26 <monoidal> nejucomo: http://stackoverflow.com/a/3216937
10:21:33 <pmade> ReinH: From what I understand, only if you plan on using GHC 7.8
10:21:34 <nejucomo> Thanks.
10:21:51 <ReinH> pmade: Ah. I kinda do though...
10:22:24 <ReinH> Good thing I don't need XCode 5
10:22:31 <yitz> ReinH: a few work-arounds have been posted. don't have the links though. should be pretty easy to find.
10:23:06 <Shin-LaC> yitz: you're right! if I search for RandomGen, which is defined in http://hackage.haskell.org/package/haskell98-2.0.0.2/src/Random.hs , hoogle only finds it in base
10:23:14 <Shin-LaC> so it just skips those two packages entirely
10:24:36 <ReinH> yitz: thanks
10:26:05 <Shin-LaC> wait, that's a bad example, RandomGen is not exported
10:26:14 <Shin-LaC> but StdGen is, and hoogle doesn't find it in haskell98
10:26:15 <Shin-LaC> so yes
10:30:23 <chrisdone> ReinH: any plans for the next podcast?
10:32:22 <ReinH> chrisdone: in addition to our list of "Haskell people doing cool stuff", we're also thinking about maybe inviting a popular speaker from ICFP to talk about their presentation
10:32:32 <chrisdone> nejucomo: class constraints don't really matter for instance resolution so it's equivalent to writing instance B t
10:32:51 <chrisdone> ReinH: ooo. sounds good!
10:33:03 <chrisdone> were any videos of ICFP released?
10:33:05 <nejucomo> chrisdone: That's a concise explanation.  Perhaps I can remember it this time.
10:33:30 <nejucomo> So, is it possible to have a type system which *does* consider the constraints context to allow this kind of instance declaration in a coherent manner?
10:33:42 <ReinH> chrisdone: not sure
10:35:09 <chrisdone> nejucomo: dunno
10:35:25 <thoughtpolice> there were recordings from what I could tell, but who knows when they'll be available
10:35:34 <chrisdone> ah
10:35:49 <chrisdone> some of the talks sounded awesome. would hate to miss out because i wasn't physically there
10:35:49 <thoughtpolice> Haskell Symposium would probably be better IMO, and there were recordings of that as well (again I don't know when they'll be online though)
10:36:18 <ReinH> For attendees, were there any exceptionally interesting/good/etc talks?
10:36:22 <thoughtpolice> i'm not sure if the Implementors Workshop was recorded
10:36:26 <ReinH> (If there are any in here)
10:37:50 <acomar> what extension enables closed type families? i.e. the 'type family F where' syntax
10:38:00 <thoughtpolice> acomar: TypeFamilies in HEAD
10:38:22 <acomar> thoughtpolice: ahh, it's not in 7.6?
10:38:33 <thoughtpolice> yes, it's in 7.8+ only
10:38:43 <haasn> 7.7+
10:39:05 <acomar> :/ someone should add that to the wiki, there's no mention of that
10:39:41 <monoidal> acomar: it's in release notes
10:41:14 <thoughtpolice> ReinH: there were several good talks I saw at the Symposium and ICFP, but mostly I just hung out with people I think.
10:41:51 <thoughtpolice> I enjoyed the "Splittable Pseudorandom Number Generators" talk a lot, and the 'causality of optimized haskell' one too
10:43:11 <ReinH> thoughtpolice: thanks
10:43:14 <thoughtpolice> ReinH: see the intro paragraphs to this paper for a cute code example - http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
10:44:00 <monoidal> nice, maybe http://ghc.haskell.org/trac/ghc/ticket/3575 will be fixed one day
10:44:21 <thoughtpolice> i think they said they found that example (essentially) throug QuickSpec or something
10:44:30 <ReinH> QuickSpec?
10:45:03 <thoughtpolice> ReinH: you give it an API and it derives a set of equations about those functions
10:45:38 <ReinH> thoughtpolice: OOH.
10:45:40 <ReinH> neat
10:45:55 <sclv_> ReinH: Andreas' Mio io manager paper might make a good podcast
10:46:07 <thoughtpolice> yeah i didn't get to see that one :(
10:46:15 <thoughtpolice> paper is great though
10:46:16 <jfischoff> that was pretty awesome
10:46:29 <sclv_> Luite is travelling around a bit but I'm sure he'd be pretty jazzed to present on GHCJS whenever he can be scheduled too
10:46:52 <ReinH> sclv_: Actually that's a great idea. Mio looks amazing and I'm interested in SDN stuff too.
10:47:12 <ReinH> (my day job involves building "clouds" using OpenFlow-switched VLANs)
10:47:30 <ReinH> thanks for the ideas :D
10:47:45 <sclv_> The other supercool idea would be to get richard or stephanie to talk about either closed type families or the new star-in-star stuff they're adding to GHC
10:48:10 <ReinH> sclv_: I am making notes :)
10:48:48 <jfischoff> richard likes to speculate about the future of type system of ghc which is interesting
10:48:58 <jfischoff> I would like to hear that more
10:49:04 <thoughtpolice> yes, i wonder if he's right we will eventually go dependent or whatnot
10:49:21 <ystael> sclv_: "star-in-star" ?
10:49:29 <johnw> sclv_: hello!
10:49:55 <jfischoff> yeah as long as Haskell is still easy to use then great
10:49:57 <thoughtpolice> ystael: basically, it collapses types/kinds together, so you get a richer language with stuff like kind equalities (not just type equalities,) GADKs, etc
10:50:07 <johnw> thoughtpolice: hello! :)
10:50:15 <johnw> so many faces to go with names now
10:50:15 <thoughtpolice> star-in-star refers to the rule that * is its own type, or '*:*'
10:50:19 <thoughtpolice> johnw: heya
10:50:27 <ystael> oh, like saying Type : Type
10:50:32 <thoughtpolice> yep
10:50:47 <jfischoff> is that same thing impredicativity?
10:50:56 <ystael> is it impredicative or with coq/agda style universe polymorphism?
10:51:38 <lispy> impredicativity means that a variable in an expression can be instantiated to the expression. So, yes '*:*' would be impredicative for kinds
10:51:55 * jfischoff nods
10:52:13 <sclv_> johnw: hello!
10:52:29 * hackagebot skein 1.0.7 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://beta.hackage.haskell.org/package/skein-1.0.7 (FelipeLessa)
10:52:31 * hackagebot fb 0.14.11 - Bindings to Facebook's API.  http://beta.hackage.haskell.org/package/fb-0.14.11 (FelipeLessa)
10:52:49 <ReinH> sclv_, thoughtpolice: star-in-star definitely sounds interesting but I'm not sure where that sits relative to our demographic. I suspect too advanced for some/many?
10:53:01 <ReinH> I'd like to make the podcast as accessible for newer Haskellers as possible
10:53:04 <sclv_> its coming to haskell
10:53:26 <sclv_> the argument is that type level programming is painful
10:53:30 <ReinH> sclv_: But how many haskellers even know/care about kinds to begin with?
10:53:42 <sclv_> ReinH: moar after your podcast :-P
10:53:47 <ReinH> sclv_: touche
10:54:07 <sclv_> i agree its a bit advanced, but its also something of general applicability and interest
10:54:30 <sclv_> so if you get a presentation on why this feature is important and ppl can do fun things with it
10:54:32 <sclv_> then that'll be cool
10:54:49 <sclv_> (honestly i think its no harder to grok than e.g. the types for lenses)
10:55:07 <sclv_> if you get a presentation on the tricky research challenges of this feature, then yeah, people won't be interested
11:21:24 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
11:21:24 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Sat Sep 14 23:34:37 2013]
11:21:57 <Shin-LaC> ok, the error is arising in my use of a nested function
11:22:05 <Shin-LaC> where I reference a variable in the outer function
11:22:38 <benmachine> ocharles: ooh, how about [x | p x] with MonadComprehensions?
11:22:43 <Shin-LaC> I guess I need to use "b" instead of "a" as the type variable in the inner function, and then add a context a ~ b?
11:22:56 <ocharles> benmachine: interesting!
11:23:27 <acomar> Is ConstraintKinds in HEAD as well...? I thought that was 7.4? But providing a kind of Constraint leads to an error even with ConstraintKinds enabled.
11:23:30 <Shin-LaC> Illegal equational constraint a ~ b
11:23:32 <Shin-LaC> oh no
11:23:32 <haasn> == might be used for type level equality /witnesses/ though. Or perhaps for a type family :: a -> a -> bool
11:23:35 <haasn> Bool*
11:23:38 <ocharles> benmachine: that looks perfect
11:23:47 <haasn> ~ is stronger than ==
11:23:51 <jfischoff> acomar: it works in 7.6+
11:23:53 <Shin-LaC> is there a way to do this in standard haskell?
11:23:59 <acomar> jfischoff: that's what I'm on :/
11:24:15 <jfischoff> import GHC.Prim I think
11:24:15 <acomar> jfischoff: but I get a Not in scope error
11:24:20 <acomar> oh, thanks
11:24:25 <Cale> Shin-LaC: Do what in standard Haskell?
11:24:31 <jfischoff> or GHC.Constraint I can't remember
11:24:38 <monoidal> acomar: GHC.Prim
11:24:47 <benmachine> Shin-LaC: you're probably overthinking things. GHC is just saying it thinks you want two types to be equal but doesn't think they are
11:24:58 <Cale> Shin-LaC: Sometimes you can introduce equality constraints between types that you can't refer to by name by putting extraneous equations into 'where' clauses.
11:25:04 <acomar> and it requires ghc-prim?
11:25:10 <jfischoff> yeah
11:25:10 <Cale> (in standard Haskell)
11:25:13 <monoidal> Shin-LaC: that error message might be due to the fact that you don't have -XGADTs nor -XTypeFamilies
11:25:17 <Shin-LaC> hm
11:25:31 <benmachine> monoidal: I don't think it's that
11:25:32 <acomar> stackoverflow.com/questions/9450558/whats-the-constraint-kinds-syntax-for-ghc-7-4-1
11:25:34 <Cale> But I don't know what you're trying to do or what problem you're trying to overcome, so that comment may be entirely irrelevant
11:25:35 <acomar> looks like that's the case
11:25:37 <benmachine> oh
11:26:03 <benmachine> Shin-LaC: I suggest you either give more details of your problem, or have a closer look to make sure it's not something silly
11:26:29 <benmachine> Shin-LaC: it's probably just an ordinary, easily-correctable type error
11:26:46 <acomar> ahh, no it doesn't need ghc-prim, that's just ghc-mod being weird or something...
11:26:52 <acomar> just import GHC.prim
11:27:02 <Shin-LaC> Cale: I have a function visitForward that takes a "Node a" argument among others; in a where clause, it defines an inner function visitOne that also takes a "Node a", but also references visitForward's node argument through the closure
11:27:22 <Shin-LaC> and Haskell isn't sure that those are the same types of node
11:27:32 * hackagebot snap 0.13.0.3 - Top-level package for the Snap Web Framework  http://beta.hackage.haskell.org/package/snap-0.13.0.3 (DougBeardsley)
11:27:44 <monoidal> Shin-LaC: you are definitely missing the gadt/type fam flag
11:28:10 <Shin-LaC> monoidal: but that's an extension, right? I am surprised that you need an extension to do this
11:28:13 <Shin-LaC> I think I'm missing something
11:28:30 <monoidal> Shin-LaC: you aren't. Haskell without extensions, H2010, is very limited
11:28:59 <monoidal> (i grepped GHC's source, and "illegal equational constraint" is given only when the flag is missing.)
11:29:25 <Shin-LaC> monoidal: illegal equational constraint popped up when I tried to explicitly state that a ~ b
11:29:37 <monoidal> Shin-LaC: that's right. you need the flag...
11:29:47 <Cale> Shin-LaC: Does the visitOne function have an explicit type signature?
11:29:53 <Shin-LaC> Cale: yes
11:29:55 <pavonia> Shin-LaC: It would probably be easier to help if you would paste an example of your specific problem
11:29:55 <Cale> Shin-LaC: Can you just leave that signature off?
11:30:24 <Shin-LaC> Cale: removing the signature seems to solve it
11:30:28 <monoidal> Shin-LaC: maybe you need scoped type variables
11:30:34 <Shin-LaC> I like signatures for documentation purposes, though
11:30:38 <Shin-LaC> I guess I'll leave it commented
11:30:40 <Cale> There are cases in Haskell 98 where valid definitions in 'where' clauses cannot be given explicit type signatures. The ScopedTypeVariables extension fixes that problem.
11:31:00 <Shin-LaC> I see
11:31:16 <Cale> If you turn on ScopedTypeVariables, and explicitly 'forall' the type variables in the parent's type signature, then you can use those variables in the type signatures in the where.
11:31:24 <Shin-LaC> what is the preferred style in this case? leaving the signature out, or using the extension?
11:31:33 <Cale> I usually don't mind using extensions.
11:31:36 <monoidal> using the extension
11:31:38 <Shin-LaC> ok
11:31:41 <benmachine> Shin-LaC: there's another poosibility
11:31:55 <benmachine> you say that visitOne references the node argument
11:32:02 <benmachine> you could just pass that as an extra parameter
11:32:16 <benmachine> so that visitOne is properly polymorphic, and the signature works
11:32:37 <Shin-LaC> that's true
11:33:04 <benmachine> however, there's not much wrong with ScopedTypeVariables
12:17:56 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:17:56 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Sat Sep 14 23:34:37 2013]
12:17:58 <monoidal> I mean, asking HEAD :k T
12:18:04 <Saizan> though a forall :: (k -> Constraint) -> Constraint would be nice too
12:18:45 <acomar> ahh, I see where I went wrong
12:19:01 <acomar> I was trying to avoid repetition a little too hard
12:19:09 <acomar> all I needed to do was provide each instance separately
12:19:17 <acomar> rather than try to deliver them all at once
12:19:26 <monoidal> Saizan: agreed, however, GHC does not support universal constraints either
12:19:30 <acomar> acowley: thanks, I think I've got it
12:19:36 <acowley> acomar: I just finished
12:19:48 <acomar> acowley: aha! awesome
12:19:59 <carter> anyone ever had this error when trying to boostrap cabal-instal before?
12:20:00 <carter> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/transformers-0.3.0.0.tar.gz
12:20:03 <carter> oops
12:20:08 <acowley> It may not be what you want, though, so I'll paste it and you can take a look
12:20:25 <acomar> sounds good
12:20:42 <acowley> Why wasn't my lpaste announced?
12:20:45 <carter> http://lpaste.net/93662
12:20:54 <acowley> acomar: http://lpaste.net/93661
12:21:22 <acowley> oops, fixed
12:21:37 <carter> http://lpaste.net/93662 anyone seen this before when trying to  bootstrap cabal
12:21:48 <acowley> That's an entire program that demonstrates the technique of indexing into images of various dimensionality and color depth
12:22:57 <acowley> acomar: The way to package this up is of course with a Constraint alias for valid image types
12:23:05 <monoidal> Saizan: e.g. you can define type T = forall a. Ord a, but attempting to write f :: T => a; f = undefined gives an error "illegal constraint"
12:23:59 <acomar> acowley: the way I'd planned to index was to do 1 or 3 look ups at location, location + 1, location + 2 as necessary
12:24:23 <acomar> acowley: one sec, I'll show you what I mean
12:24:29 <acowley> acomar: That's easy to do with a fold over the index type
12:24:45 <quchen> When I spawn something with `withAsync`, e.g. `withAsync loop $ \a -> return ()`, can I be sure that if the parent thread dies the async is cancelled? In other words, what I want is an async that runs forever on its own, but dies with its parent
12:24:46 <acomar> acowley: yea, exactly
12:25:16 <acowley> acomar: I misspoke a bit there, what you want to do is have a type level mapping from Channels to a scalar type
12:25:31 <acowley> acomar: then you know how to load those scalar types
12:25:43 <acowley> acomar: If you use linear, you benefit that they know how to peek themselves
12:25:45 <sclv_> quchen: this is typically the sort of thing that we use frameworks like distributed-process (aka cloud haskell) for
12:25:53 <acowley> acomar: So Storable alone will carry you through
12:25:58 <sclv_> if you just want that, orc has a similar notion
12:26:02 <sclv_> and i think there are a few others
12:26:13 <acowley> acomar: You just have to be careful to keep track of whether you are using byte-based indexing, or element-based indexing
12:26:49 <quchen> sclv_: I think distributed is a little too much. I've basically got this superviser that spawns a couple of sub-services that keep track of one another. Should one of them crash, the entire thing should.
12:27:04 <quchen> So it's pretty local I would say, it's all contained as one unit
12:27:06 <Cale> quchen: I don't think that does what you want it to.
12:27:35 <sclv_> in any case, the point is we don't have that behavior by default
12:27:48 <sclv_> so you need to use _some_ framwork over our standard tools
12:27:49 <acomar> acowley: last suggestion first - peek on a ptr of type Int reads an integer, right? So I'm right in assuming I'm always doing element-based indexing?
12:28:44 <sclv_> quchen: orc is pretty lightweight: http://hackage.haskell.org/package/orc
12:28:51 <saml> !ide
12:28:58 <saml> @wiki ide
12:28:58 <acomar> acowley: and yea, I was trying to provide that mapping from Channels to a Scalar type, but I tried to get too much out of just two instances
12:28:59 <lambdabot> http://www.haskell.org/haskellwiki/ide
12:29:00 <acowley> acomar: The way you do this is to have a void Ptr, this can be a Ptr (), or a Ptr Word8 or whatever, then you castPtr the ptr and peek at an element offset. If the return type is a V2, you'll read two elements starting from 2*sizeOf e
12:29:05 <acomar> acowley: one for Grayscale, one for all the others
12:29:14 <quchen> sclv_, Cale: Out of interest, what does my async version do wrong?
12:29:21 <saml> do you use eclipsefp? I can't get it to work
12:29:25 <acowley> acomar: I think ordered type family instances will solve that
12:29:29 <user123abc> is there a way to have the runtime give me more information about where it detected a loop?
12:29:41 <sclv_> quchen: in fact, http://hackage.haskell.org/package/orc-1.2.1.3/docs/Control-Concurrent-Hierarchical.html
12:29:47 <Cale> quchen: That should terminate the loop immediately once the return () executes.
12:29:50 <acowley> acomar: Then you can just have the Grayscale instance, and the rest are all caught in the last case
12:30:13 <quchen> Cale: Oh snap haha. Of course, withAsync is bracket.
12:30:19 <quchen> … silly me
12:30:29 <Cale> quchen: When the function supplied to withAsync finishes or throws an exception, 'cancel' is called on the async that was created.
12:30:33 <acowley> acomar: One thing that's tricky is that OpenCV will pad rows, so you need to look at stride rather than image size
12:30:49 <acowley> acomar: So computing offsets does need a little care
12:30:54 <quchen> sclv_: Thanks for that module, it looks just like what I want
12:31:38 <acomar> acowley: right, I'd planned to handle that once I'd gotten the more basic stuff working
12:31:43 <acowley> acomar: For ordered type family instances, http://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
12:31:56 <acowley> acomar: So I'd write the ugly code for now, and clean it up when we get 7.8
12:32:13 <acomar> acowley: yea, I'd already settled on that :)
12:32:33 <acowley> I'm glad you're doing this part, this is something that HOpenCV does really nicely
12:32:40 <acowley> If you didn't add it, I would :)
12:33:17 <acomar> yea, it was aleator's suggestion -- he wanted to ensure operations on these matrices weren't as error prone as using the C++ api
12:33:23 <S_J> HOpenCV== a port of the C++ imaging lib?
12:33:41 <acowley> acomar: I've relied on it for quite a while now
12:33:53 <acowley> S_J: bindings to OpenCV, rather than a port
12:34:06 <acowley> S_J: acomar is writing a new binding infratstructure
12:34:09 <acomar> acowley: so is this just in your fork, or is this part of the mainline?
12:34:14 <acowley> acomar: My fork
12:34:25 <acomar> nicely done then :)
12:34:43 <acowley> acomar: All the magic is in my fork. I know it's crappy that I didn't push, but I hated the fact that we had such poor coverage of the library
12:35:15 <acowley> acomar: Anyone who downloaded some OpenCV bindings from hackage was likely to be disappointed, so I'd rather they have their expectations set appropriately by having to get it from github
12:35:21 <acomar> acowley: there's also a chance they wouldn't have been able to incorporate such breaking changes
12:35:22 <acowley> acomar: I'm hoping your efforts will change that
12:35:30 <acomar> yea, I hope so too
12:35:31 <acowley> acomar: Absolutely
12:35:49 <acowley> acomar: I wanted this for myself, so debates about library design didn't seem worthwhile
12:36:18 <S_J> acowley: hmm, will it be fast?
12:36:19 <acomar> acowley: may as well have the debates out now, while I'm in the very early stages of this one :)
12:36:38 <acomar> S_J: I'm hoping to use it for real time work, so that's one of my primary concerns :)
12:36:47 <acowley> S_J: Yes, there's minimal overhead
12:37:11 <acowley> My uses have all been realtime, too
12:37:28 <acowley> acomar: Yeah, it's great
12:37:34 <Eduard_Munteanu> Are there any extensions to the kind system that make types like 'forall a. a' have a different kind like 'something -> *' instead of '*'?
12:38:05 <Eduard_Munteanu> I find the impredicativity of the current one quite disturbing.
12:38:42 <Eduard_Munteanu> (so it would make forall a type-level lambda / binder)
12:40:31 <acomar> acowley: so you're saying this: http://lpaste.net/93657 won't work because OpenCV pads its rows?
12:40:43 <acomar> (before I get too far)
12:40:47 <acowley> acomar: correct
12:42:24 <acowley> acomar: See http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-iscontinuous
12:42:44 <acomar> acowley: Ok, I'll work in your fold and linear suggestions then
12:42:46 <cschneid> is there a function that returns the count of a given thing in a list?  [1,2,3,1] I wan to know that there are two 1s, and one each of 2 and 3?
12:43:01 <acowley> acomar: You're supposed to use Mat::ptr to get a pointer to the start of a row
12:43:34 <jfischoff> > map length . group . sort $ [1,2,3,1]
12:43:36 <lambdabot>   [2,1,1]
12:43:42 <acowley> acomar: rowPtr m >>= peek . castPtr
12:43:44 <acomar> acowley: ahh, I see
12:43:50 <acowley> d'oh
12:44:15 <donri> > length . filter (/= 1) $ [1,2,3,1]
12:44:18 <lambdabot>   2
12:44:19 <cschneid> > map length . group . sort $ [3, 3, 1]
12:44:19 <lambdabot>   [1,2]
12:44:23 <acowley> rowPtr m i >>= flip peekElemOff j . castPtr
12:44:27 <acowley> there
12:44:48 <tearful> How come Data.ByteString.Lazy.readFile doesn't update the files timestamp?
12:44:52 <acomar> acowley: then you can just call the .rowAt method, can't you?
12:45:25 <cschneid> jfischoff: the sort breaks things a bit (see my [3,3,1] example, it should return [2,1] but instead has [1,2] due to the sort)
12:45:31 <donri> > map (head &&& length) . group . sort $ [1,2,3,1]
12:45:32 <lambdabot>   [(1,2),(2,1),(3,1)]
12:45:39 <acomar> rowAt mat row, and peek at the column value
12:45:52 <acowley> acomar: I don't know. I don't see rowAt here http://docs.opencv.org/modules/core/doc/basic_structures.html
12:46:01 <jfischoff> cschneid: that's not the whole story but the solution is a variation on it
12:46:18 <acomar> acowley: ahh, sorry it's row(int y)
12:46:38 <jfischoff> look at donri ^
12:46:40 <donri> cschneid: may want a bag/multiset instead
12:46:41 <acomar> cv_Mat_getRow in my wrapper
12:46:47 <cschneid> ya. Cool.
12:46:53 <acowley> acomar: That gives you a Mat, I had suggested using ptr
12:47:11 <cschneid> donri, jfischoff: we have an interview question I'm trying to turn into a haskell one-liner (we ask it in ruby).
12:47:11 <acomar> acowley: right, but it's a "Mat" around just a given row
12:47:25 <acomar> acowley: so you can take its ptr and peek at the column offset
12:47:38 <acowley> acomar: Yeah, but that will allocate
12:47:43 <acowley> acomar: Mat::ptr won't
12:47:56 <Wai4> donri: What the complexity of that map (head &&& length) . group . sort $ [1,2,3,1] ? (n^2 + n^2 + n*2)?
12:48:21 <acomar> acowley: huh, good point. The docs claim it's O(1), but that's time not space
12:48:24 <acowley> Actually, row is terrible
12:48:36 <jfischoff> cschneid: I had a question like that in a interview, and wrote a haskell onliner, but yeah the complexity is not great
12:48:45 <mauke> Wai4: probably O(n log n)
12:49:06 <cschneid> jfischoff: right. Most everybody answers this question with an n^2 answer, and there's a nice time/space tradeoff that's available, which makes it a good question
12:49:40 <acowley> acomar: I think if we get the pointer from OpenCV, we can do so much more with our types that we don't need much help from the C++ code
12:49:57 <acomar> acowley: yea, true enough
12:50:04 <Wai4> mauke: It can't be lesser than n^2 in worst case.
12:50:19 <mauke> Wai4: why not?
12:50:31 <Wai4> See `sort' complexity.
12:50:36 <monoidal> sort is n log n
12:50:39 <mauke> sort is n log n
12:50:49 <Wai4> In best case?
12:50:54 <monoidal> worst
12:51:06 <mauke> best case probably O(n)
12:51:10 <joelteon> what datatype should I use for a fast heterogeneous map?
12:51:43 <jfischoff> you can do in one pass O(n) is the thing
12:52:42 <Wai4> yeah, its a merge sort, forgot about it.
12:54:00 <Dodek> best case of merge sort is still O(n log n)
12:54:42 <acowley> acomar: I'm going to afk for a bit. Do take a look at my HOpenCV fork and feel free to steal/borrow, and let me know if anything comes up.
12:54:53 <acomar> acowley: will do, see you later
12:55:00 <acomar> acowley: thanks for your help
12:55:10 <joelteon> keys all of the same type, values of different types
12:56:10 <merijn> joelteon: And what you do with the contents?
12:56:45 <magneticduck> hey guys, anybody here from yesterday when I was asking about a weird problem with my audio generation library?
12:56:49 <joelteon> it's a game with a list of on-screen entities (enemies, players, objects) and I want to be able to store some arbitrary metadata along with each
12:56:57 <joelteon> or should I make an ADT?
12:57:16 <Enigmagic> joelteon: ADT is probably the best way
12:58:31 <magneticduck> well it's done! in case anybody's interestedhttps://github.com/MagneticDuck/SoundsOfDuck http://lpaste.net/93670
12:58:49 <magneticduck> if anybody else out there has been itching to make sound with haskell you can have fun with this
12:58:50 <magneticduck> =P
12:58:59 <magneticduck> uh, maybe I should put this in haskell-blah
12:59:25 <edwardk> ocharles: =)
13:00:12 <merijn> edwardk: Ha, gotcha! I asked a few times before, but I don't think you were around to answer
13:00:19 <edwardk> ack
13:00:21 * edwardk hides
13:00:24 <edwardk> pulls the plug
13:00:34 <edwardk> didn't work. its a laptop.
13:00:42 <merijn> edwardk: Your first cellular automata post in School of Haskell mentions implementing comonad instances for Pretext/Bazaar/FunList as exercise
13:00:43 <edwardk> ok. you've got me. what's the question?
13:00:50 <edwardk> merijn: yep
13:01:16 <merijn> edwardk: Is there a version in existence somewhere to compare my version with? I find proving the laws for those instances to be a bit of a pain
13:01:22 <edwardk> yes.
13:01:32 <merijn> I saw lens has those types, but the types looked much scarier :<
13:01:50 <ReinH> edwardk: oh hi there!
13:01:57 <edwardk> the ones in lens just split the state argument up into two pieces. this makes it actually harder to screw up
13:02:16 <edwardk> http://hackage.haskell.org/package/lens-3.9.1/docs/Control-Lens-Internal-Context.html the instance code doesn't change
13:02:24 <edwardk> we just rule out more bad implementations
13:02:29 <cschneid> so what's a fast way to do this? map (head &&& length) . group . sort $ [1,2,3,1]
13:02:40 <edwardk> its _very_ hard to write an illegal but not obviously botched indexed (co)monad
13:02:47 <donri> cschneid: use a multiset ;)
13:02:54 <ReinH> edwardk: I've been going through CGP&P and Zen of Graphics Programming and trying to translate stuff into Haskell. It's fun!
13:02:55 <donri> but it doesn't keep ordering either, i don't think
13:02:57 <edwardk> with an unindexed comonad its easy to screw up and forget something
13:03:03 <edwardk> ReinH: =)
13:03:22 <ReinH> edwardk: I wrote a line drawing algorithm but I cheated and used lerp :) https://gist.github.com/reinh/6710417
13:03:28 <cschneid> donri: the underlying problem is: "find the index of the first non-repeated number". So in the [1,2,3,1] example, the 2 in the array is the first non-repeated, and 1 would be the index.
13:03:30 <merijn> edwardk: ok, I'll just meditate on the version in lens then
13:04:04 <edwardk> ReinH: lerp is in many ways much better than the bresenham algorithm when you can use it
13:05:05 <ReinH> edwardk: but bresenham just uses additions and bit shifts!
13:05:21 <ReinH> edwardk: still, I like the way it came out
13:05:59 <edwardk> ReinH: http://www.youtube.com/watch?v=GNO_CYUjMK8&t=2m45s
13:06:22 <edwardk> vs. http://www.youtube.com/watch?v=GNO_CYUjMK8&t=3m8s
13:07:54 <ReinH> edwardk: well they're both midpoint-based right? I use round.
13:08:06 <ReinH> or am I missing the point?
13:08:10 <ReinH> PUN INTENDED
13:08:36 <edwardk> ReinH: its more about whether you're forced to put your end-points directly on the grid
13:09:04 <joejev> I am debating with my friend, I am arguing that doing an Array a (Array a a) would have an O(n) index time where n is the number of arrays of arrays you have, however he thinks that it would still have an O(1) index time.
13:09:10 <ReinH> edwardk: looks like a cool presentation though!
13:09:42 <ReinH> joejev: what's the complexity to index Array ix a?
13:10:00 <joejev> ReinH: it should be O(1)
13:10:06 <ReinH> joejev: what's O(1*1)?
13:10:15 * edwardk is rather amused by how fast https://twitter.com/kmett/status/384766778062016512 started getting retweeted
13:10:37 <elliott> edwardk: first you steal my folds and now you steal shachaf's classes
13:10:57 <joejev> ReinH: wouln't that be more like n*1 since you need to do that for each array you have?
13:10:58 <edwardk> elliott: well, dolio is writing the article
13:11:07 <ReinH> edwardk: Oh you
13:11:24 <shachaf> edwardk is stealing my classes?
13:11:35 <ReinH> joejev: it's O(1) to index into the first array and then O(1) to index into the array found there
13:11:40 <elliott> edwardk: and now you steal dolio's tweets!
13:12:01 <edwardk> shachaf: the observation about monads being monad-algebras of the free-monad monad from you talking to dolio
13:12:25 <shachaf> Oh, that.
13:12:25 <edwardk> Hence monads are just free-monad monad monad-algebras
13:12:30 <ReinH> joejev: although I'm not sure why you wouldn't use Array (a,a) a
13:12:47 <shachaf> arkeet was the first person to figure out the laws for it, I think.
13:12:49 <joejev> ReinH: right, so what I was thinking was that if you did that like, 1000 times, you need to repeat that indexing 1000 times, which takes some time, more time than just indexing one
13:13:00 <edwardk> and comonads are just comonad-coalgebras of the cofree-comonad comonad
13:13:05 <sclv_> never has the mathematical use of "just" been more appropriate
13:13:12 <ReinH> joejev: more time, yes, because the constant factor is greater, but not more complexity
13:13:28 <edwardk> This is right up there with arrows being just strong monads in the category of profunctors
13:13:32 <ReinH> as in the time doesn't vary with the size(s) of the array(s)
13:13:35 <joejev> ReinH: well, he doesn't  program in haskell, I do just index with tuples, but it was for the discussion
13:14:32 <joelteon> I wish :: and : could be switched
13:14:34 <edwardk> sadly i think dolio and i just worked out that like how all comonoids are boring in Set, all comonads in the category of profunctors are equally boring. profunctors are functors to set after all.
13:15:06 <edwardk> the only one that isn't trivial is like the comonoid of a value
13:16:00 <ReinH> joejev: sure, so for this example, you are nesting one constant-time operation inside another constant-time operation
13:16:07 <ReinH> the result of which is in constant-time
13:16:52 <ReinH> because O(1*1) = O(1)
13:18:03 <joejev> ReinH: maybe I have my idea of O() notation wrong, I am thinking of it as f(x) grows like O(g(x)) iff there exists some k such that k(g(x)) >= f(x) for all values of x, right?
13:18:32 <joejev> ReinH: thus I keep feeling like that O(1^n) should mean more than O(1)
13:18:44 <joejev> ReinH: Maybe I need to read up on it again
13:18:47 <ReinH> Why do you think it is O(1^n)?
13:19:35 <ReinH> joejev: O(n) implies that the cost is proportional to some n. In this case, the cost is constant.
13:19:54 <joejev> ReinH: well, if I nested 1000 arrays, then I need to call the lookup 1000 times to get one element, thus if I nest n arrays, I need to call n lookups
13:20:26 <ReinH> joejev: Yes, it is proportional to the number of nested arrays
13:20:31 <ReinH> which in this case is fixed at 2
13:20:34 <ReinH> and O(2) = O(1)
13:20:41 <c_wraith> joejev: that's all correct - but it only matters if n varies.  if n is constant, then it's absorbed by the constant factor in O() notation
13:20:48 <argiopeweb> So, O(k), where k == the depth of the nested arrays.
13:20:50 <ReinH> if you want to talk about arbitrarily deep nesting then yes, it is O(n) in the depth
13:21:06 <joejev> ReinH: the nest of 2 was just an example, yes we were talking about any depth
13:21:19 <ReinH> joejev: ah, then yes it is O(n) where n = depth
13:22:15 <joejev> ReinH: Okay, basically this started when asked about a 4d array or something and I mentioned that I was indexing it with a (a,a,a,a) as opposed to an Array a (Array a (... for speed
13:22:17 <S_J> is each char a byte in a bytestring?
13:22:18 <ReinH> but for any known fixed n, it is still constant time
13:22:23 <donri> cschneid: how about: let xs = [1,2,3,1] in findIndex (\x -> (length . take 2 . elemIndices x) xs == 1) xs
13:22:36 <joejev> S_J: They are Word8's no?
13:22:44 <ReinH> joejev: that is a good idea but it is because of constant factors, not asymptotic performance
13:23:06 <ReinH> joejev: since your depth is fixed at 4, accessing the inner (deepest) array is still done in constant time
13:23:19 <joejev> ReinH: okay, but if the nesting was an arbitrary length, then it would have a linear growth rate?
13:23:27 <ReinH> yes
13:23:30 <ReinH> it's just that that constant time has a (roughly) 4x constant factor
13:23:52 <ReinH> compared to indexing by (a,a,a,a)
13:23:53 <donri> cschneid: probably far from the fastest you can get, but if you want a one-liner
13:26:18 <ashwins> hey, I've got a quick question about attoparsec and Word8; can someone field it?
13:26:44 <shachaf> ashwins: What do you expect people to say, without even knowing what the question is?
13:26:55 <shachaf> Ask first, ask questions later.
13:26:59 <ReinH> ashwins: (don't ask to ask, just ask) :)
13:27:01 <ashwins> so, 1. is there an idiomatic way to get from [Word8] to Int?
13:27:03 <acomar> what on earth... template haskell is causing a link error in an unrelated package...
13:27:12 <ashwins> (in general, this is not the attoparsec question)
13:27:18 <ReinH> ashwins: depends on how you expect to get to Int.
13:27:22 <ashwins> well, it's like
13:27:27 <ReinH> How does your [Word8] represent an Int?
13:27:31 <ashwins> er
13:27:36 <ashwins> I have a [Word8] of length 4
13:27:37 <ashwins> let's say
13:27:44 <ashwins> and each byte corresponds to a byte in a 32 bit int
13:27:52 <ashwins> the head of my list is the MSB
13:27:53 <ashwins> etc.
13:27:57 <ashwins> (or the LSB, whatever you want)
13:28:03 <shachaf> Ot
13:28:09 <shachaf> It's sort of important which one it is.
13:28:16 <ashwins> fine, let's say it's little-endian
13:28:19 <ashwins> so head is LSB
13:28:21 <ReinH> ashwins: it will be different for various combinations of endianness
13:28:33 <ReinH> what is the endianness of your list and of your Word8's?
13:28:39 <acomar> inserting genSingletons [''MyPromotedType] into my source file (from singletons) breaks a different package I depend on with a link error...
13:28:47 <ashwins> Word8 is just a byte, right
13:28:49 <shachaf> Anyway, you probably won't do better than the obvious fold with the standard library.
13:28:50 <benmachine> ashwins: sounds like you can do a fold
13:28:52 <ashwins> ok
13:28:55 <ashwins> sure, sounds good
13:29:05 <ReinH> +1 fold
13:29:06 <shachaf> I don't know of anything special-purpose for it.
13:29:08 <ashwins> now, on to the attoparsec question
13:29:18 <benmachine> > foldr (\x a -> x `shiftL` 8 .|. a) 0 [1,2,3,4]
13:29:19 <ashwins> is there a better way to read such an Int in the Parser monad
13:29:20 <lambdabot>   1792
13:29:20 <ashwins> than just
13:29:33 <ashwins> <- liftM (the fold you guys mentioned) $ take 4;
13:29:38 <benmachine> hmm that looks too small, I'm probably doing it wrong
13:30:02 <monoidal> acomar: 7.6 or head?
13:30:22 <donri> cschneid: or skip looking for duplicates before the element under consideration, not sure if faster or if tails is expensive :P findIndex (\(y,ys) -> (length . take 2 . elemIndices y) ys == 1) $ zip xs (tails xs)
13:30:30 <monoidal> acomar: in any case, that sounds very suspicious
13:30:46 <ashwins> so, I know that the digit combinator in attoparsec (combined with Prelude read) can read me an integer given as an ASCII string
13:30:55 <ashwins> but what do I do if my int is just represented as bytes?
13:31:44 <benmachine> oh, I'm definitely doing it wrong
13:31:49 <donri> cschneid: although i don't think tails is that bad since it's just recursing on the tail and tail is cheap
13:32:01 <ReinH> ashwins: you might want http://hackage.haskell.org/package/binary-0.4.1/docs/Data-Binary.html
13:32:02 <acomar> monoidal: 7.6
13:32:02 <nycs_> in the functor class, what is this operator called? (<$)
13:32:09 <ReinH> argh old package is old
13:32:13 <ReinH> @hackage binary
13:32:14 <lambdabot> http://hackage.haskell.org/package/binary
13:32:16 <acowley> ashwins: http://hackage.haskell.org/package/attoparsec-binary-0.2/docs/Data-Attoparsec-Binary.html
13:32:25 <ReinH> or that
13:32:28 <ashwins> hmm...OK, this has to be attoparsec for other reasons
13:32:33 <ReinH> seems good
13:32:40 * hackagebot BlogLiterately 0.6.3 - A tool for posting Haskelly articles to blogs  http://beta.hackage.haskell.org/package/BlogLiterately-0.6.3 (BrentYorgey)
13:32:41 <ashwins> and attoparsec-binary can only read ints that are 16, 32, or 64 bits
13:32:53 <ashwins> in principle, i should be able to deal with ints that are (say) 5 bytes
13:33:11 <ashwins> maybe I should just read however many Word8's i need and then use the foldr?
13:33:15 <acowley> If you've got 5 bytes, you might not have an Int
13:33:25 <ashwins> true
13:33:35 <ashwins> Integer is more correct
13:34:26 <acowley> acomar: Did you cabal clean?
13:34:35 <benmachine> ashwins: you can read a single byte with Data.Attoparsec.ByteString.anyWord8
13:34:41 <ashwins> correct
13:34:50 <ashwins> so I do that however many times I need depending on the length of my Integer
13:34:58 <ashwins> and then use the fold that was mentioned to convert [Word8] to Integer
13:35:07 <acomar> acowley: attempting to purge all packages and reinstall them all to see if my sandbox got corrupted or something
13:35:13 <ReinH> ashwins: the source might be illuminating http://hackage.haskell.org/package/attoparsec-binary-0.2/docs/src/Data-Attoparsec-Binary.html#anyWord16be
13:35:21 <ashwins> sounds good, thanks!
13:35:26 <ReinH> benmachine: btw pack is:
13:35:26 <ReinH> pack = B.foldl' (\n h -> (n `shiftL` 8) .|. fromIntegral h) 0
13:35:32 <ReinH> benmachine: *so close* ;)
13:35:37 <benmachine> ReinH: :P
13:36:01 <acowley> acomar: TH demands you bend over backwards when compiling. It can make profiling a pain, static linking a pain, etc. Cabal usually does all the work, but it wouldn't shock me if things went sideways.
13:36:06 * benmachine worries a bit about whether that's LE or BE
13:36:22 <ashwins> ok, thanks for the help!
13:36:42 <acowley> benmachine: This is why even Haskellers have to write tests :)
13:36:57 <ReinH> acowley, acowley: cabal install default should be with library-profiling = True , check your ~/.cabal/config
13:36:59 <acomar> acowley: :/
13:37:11 <ReinH> with TH you just need to compile twice
13:37:15 <acowley> ReinH: Yes, I know.
13:37:29 <ReinH> acowley: one of those was supposed to be acomar
13:38:01 <ReinH> not my fault your most significant difference is 4 bytes
13:38:14 <ReinH> ain't nobody got time to properly tab complete that
13:39:47 <acowley> np, RageOfThou
13:39:59 <acomar> ReinH: lol
13:41:54 <acomar> acowley, monoidal, ReinH: library pofiling is on, and I just finished purging my sandbox and reinstalling all my dependencies, and cleaned out all my local files
13:42:15 <acomar> still get the same link error when the template haskell line is inserted, I don't when it's not
13:42:25 <ReinH> acomar: what is the error? I missed it.
13:42:45 <acomar> ReinH: an unknown symbol error in an unrelated package
13:43:11 <ReinH> oh joy
13:43:23 <ReinH> acomar: nice job breaking it
13:43:30 <acomar> :/
13:43:38 <ReinH> acomar: http://tvtropes.org/pmwiki/pmwiki.php/Main/NiceJobBreakingItHero
13:44:23 <benzrf> would it be correct to say that yesod : haskell :: django : python
13:44:27 <acomar> whooo
13:44:54 <ReinH> benmachine: In that they attempt to solve the same problem? Yes. In terms of *how* they solve that problem? Not really.
13:44:55 <roconnor> is ezyang on IRC?
13:45:01 <ReinH> ezyang: ping
13:45:02 <benzrf> ReinH: think you meant benzrf
13:45:08 <ReinH> I did
13:45:18 <carter> joejev: you actually really want a flat array model
13:45:19 <ReinH> but once again if your MSD is 4 bytes you can't expect me to get it right ;)
13:45:30 <ReinH> 3 bytes is the limit of my autocomplete hinting ability
13:45:31 <carter> bad locality can cost you a 1000x costant factor
13:45:33 <roconnor> ReinH: ha.  tab completion suggests the answer is yes.
13:45:35 <benzrf> ReinH: I meant as in, big, fully featured, a bit complicated, slightly magical, maybe overkill for smaller projects?
13:45:41 <ReinH> carter: also that
13:45:56 <carter> ReinH: didn't get the work done this weekend :(
13:45:59 <carter> too busy with life!
13:46:34 <ReinH> carter: nooooooo
13:46:48 <ReinH> carter: now you have to let me see your code
13:46:52 <revelation> I need mailer
13:46:55 <carter> ReinH: i'll get more work done if i front load sleep + dating + income
13:46:56 <carter> :)
13:46:59 <revelation> who can help
13:47:00 <benmachine> we already have enough people in here to exhaust all the first two letters
13:47:06 <carter> ReinH: the code is hard to share when i'ts not yet written
13:47:08 <ReinH> carter: yeah but I won't have a new array library :p
13:47:11 <carter> well
13:47:13 <carter> not this week
13:47:13 <ReinH> carter: ah. Damn you.
13:47:22 <carter> i want to get it out too
13:47:24 <benzrf> basically what I want to know is
13:47:24 <ReinH> :D
13:47:28 <carter> right now focusing on having income :)
13:47:33 <revelation> hi
13:47:35 <carter> less money worries = more work done
13:47:35 <ReinH> income good
13:47:38 <carter> yusss
13:47:41 * hackagebot acid-state 0.12.1 - Add ACID guarantees to any serializable Haskell data structure.  http://beta.hackage.haskell.org/package/acid-state-0.12.1 (DavidHimmelstrup)
13:47:48 <benzrf> what is a simple, nonmagical, possibly single-file-capable, and quick to start web framework?
13:48:00 <carter> benzrf: whats teh goal?
13:48:03 <carter> static or dynamic site?
13:48:09 <benzrf> dynamic
13:48:17 <benzrf> why would I use a framework for static
13:48:18 <benzrf> ._.
13:48:24 <acomar> acowley: I guess I'll just have to do this manually -- write a typeclass that converts channel -> numChannels
13:48:27 <benzrf> just use apache or something directly
13:48:29 <acomar> and provide individual instances
13:48:48 <ReinH> revelation: do you have a question?
13:48:51 <acowley> acomar: Are you using explicit export/import lists everywhere?
13:49:01 <carter> benzrf: snap is nice
13:49:18 <ReinH> +1 snap
13:49:19 <acomar> acowley: not everywhere, no. just where I need to hide things.
13:49:35 <acowley> acomar: I'm just wondering if TH-generated identifiers are causing trouble
13:49:39 <carter> also no build hell
13:49:44 <carter> i don't like build hells
13:49:57 <acomar> acowley: problem is, the error is showing up in opencv-raw
13:50:06 <sm> benzrf: also scotty, or just wai (see recent post on planet haskell)
13:50:07 <donri> benzrf: happstack-lite, snap, scotty
13:50:21 <acowley> acomar: Ah, now that uses some preprocessor stuff, right?
13:50:33 <acowley> acomar: I bet the double-build TH stuff I was whining about is the problem
13:50:42 <acomar> acowley: yes, but that should already be done since that package is compiled and installed separately
13:50:55 <acowley> Oh, boy
13:51:00 <benzrf> thanks yal
13:51:01 <benzrf> l
13:51:03 <acowley> Can I reproduce this link error?
13:51:24 <acomar> acowley, let me commit then you should be able to
13:53:27 <carter> yeah some peole like scotty as a barebones one
13:53:32 <acomar> acowley: ok, go ahead and pull.
13:54:02 <acomar> acowley: I was working on incorporating your lpaste
13:56:39 <acowley> acomar: I'm getting sandboxes setup now
13:57:43 <acowley> acomar: Is building with clang++ expected to work?
13:58:08 <acowley> well, spoiler alert, it didn't
13:58:43 <acomar> acowley: ahh, yea, I haven't made any attempt to try
13:58:56 <acomar> acowley: I've got gcc and g++ handy
13:59:32 <acowley> It is not impressed with your usage of fputs
13:59:40 <acomar> it's not my usage :/
13:59:48 <acomar> it's a bindings-dsl macro
13:59:57 <acowley> Ah, I've not used bindings-dsl
13:59:57 <acomar> g++ will take it if you make it by passing -fpermissive
14:00:25 <acomar> implicit void conversions are kosher in C, but pretty much nowhere else
14:00:40 <acowley> Does bindings-dsl buy you much? I looked at it once and decided not to bother.
14:01:13 <acomar> aleator suggested it as relatively painless compared to c2hs
14:01:20 <c_wraith> it actually does.  It automates a lot of stuff.
14:01:39 <acowley> It also seems to not work with clang and make lots of warnings with g++
14:01:42 <acomar> c_wraith: I'm not actually sure I'm using any of those automation features
14:01:56 <acomar> acowley: I'll look into switching to c2hs
14:02:02 <acomar> that does work with clang, correct?
14:02:11 <c_wraith> It doesn't matter if the library you're binding to is all types from Foreign.Types, but once things get more interesting, bindings-dsl takes a lot of boilerplate out
14:02:28 <acomar> c_wraith: my types are all declared as #opaque_t
14:02:57 <acowley> I guess I've mostly used hsc2hs
14:03:02 <c_wraith> On the other hand, if you're binding to a library that uses hundreds of structs in its functions, it would be a nightmare to do with plain hsc2hs
14:03:13 <acomar> yea, I can imagine
14:03:28 <acomar> I think for passing raw pointers around though, I might be able to downgrade to just hsc2hs
14:03:38 <carter> what DLS?
14:03:40 <carter> *DSL
14:03:43 <acowley> I would think so
14:03:52 <acowley> carter: It helps with interacting with C structs afaik
14:03:58 <carter> what DSL?
14:04:47 <acowley> carter: https://bitbucket.org/mauricio/bindings-dsl/wiki/Home
14:05:08 <acowley> It's a DSL for interacting with C structs
14:05:23 <carter> whys it ask if you'd like to maintain it
14:05:53 <acowley> I'd guess because nobody is maintaining it
14:06:03 <carter> fair enough
14:06:10 <acomar> hah, I think I looked at that page 4 or 5 times and never noticed that question
14:06:16 * acomar must be blind
14:06:24 <levi> Or the current maintainer would like to no longer maintain it.
14:06:25 <carter> we have tech to fix that now
14:06:32 <acowley> They have a news item for last month, so it's not at all dead
14:06:37 <carter> yeah
14:06:46 <carter> but it says "i'll prevent bitrot but thats about ti"
14:07:12 <acowley> acomar: Okay, I installed all dependencies for revelation including opencv-raw
14:07:26 <acowley> acomar: When I build revelation, I get Revelation/Mat.hs:60:22: Not in scope: `c'cv_Mat_ptr_index'
14:07:27 <acomar> it's also a very poorly documented project... I extrapolated from the tutorial to generate the bindings
14:07:51 <acomar> acowley: ahh, right, I added that locally and didn't push
14:08:25 <acomar> acowley: update opencv-raw and reinstall it
14:08:41 <acomar> acowley: what flag did you need to get around the llvm/fputs issue
14:08:46 <ezyang> reinH: pong
14:08:48 <acowley> acomar: I used g++
14:08:52 <acomar> kk
14:09:11 <ezyang> roconnor: pong?
14:09:12 <acowley> acomar: I don't see any new commits
14:09:18 <acowley> marco!
14:11:47 <carter> polo?
14:12:30 <roconnor> ezyang: Hi, I read your post about Monadic Fixpoints and Heap Offsets.
14:13:09 <roconnor> ezyang: did you ever read my article on Recursive Do for building an assember in the monad reader several years ago?
14:13:24 <ezyang> roconnor: Nope, have not.
14:13:53 <acomar> acowley: it's showing up on my page?
14:13:59 <acomar> try again?
14:14:16 <roconnor> ezyang: http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
14:14:22 <ocharles> any arrow proc gurus around?
14:14:22 <ocharles> http://lpaste.net/93673
14:14:29 <ezyang> wow! What an early TMR issue.
14:14:42 <ocharles> for some reason, even if signum (marioXVelocity m) == -1, the moment it goes back to 0, this whole thing outputs V2 1 0
14:14:49 <acowley> acomar: Did you force push something?
14:14:52 <roconnor> ezyang: I'm kinda interested if my article influenced that development, or if it is independent. :)
14:14:56 <ocharles> but while it's -1, it outputs V2 (-1) 0 as it should
14:15:02 <ocharles> so I can't figure out why that's not being fed back in
14:15:03 <ocharles> cc mm_freak_
14:15:10 <ocharles> :P
14:15:10 <ezyang> roconnor: I think the relevant code has been around for a while
14:15:10 <acomar> acowley:...?
14:15:40 <acomar> acowley: I squashed an edit together
14:15:46 <acomar> acowley: didn't have to force anything
14:15:52 <acowley> acomar: My clone of your repo has more commits than yours
14:16:17 <acowley> acomar: So I can't fast-forward now
14:16:40 <acomar> acowley: tip should be bde4f5e82fdd
14:16:45 <roconnor> ezyang: before 2007 maybe?
14:16:47 <acowley> For example, https://github.com/arjuncomar/opencv-raw vs https://github.com/acowley/opencv-raw
14:16:49 <ReinH> ezyang: hai :)
14:16:58 <acowley> I guess I'll nuke and start again
14:17:28 <acomar> acowley: weird, it should show the squashed commit
14:17:42 * hackagebot doctest 0.9.9 - Test interactive Haskell examples  http://beta.hackage.haskell.org/package/doctest-0.9.9 (SimonHengel)
14:18:43 <ezyang> roconnor: I see, you are using fixpoint to wire up the labels
14:19:21 <roconnor> ezyang: learning to use mdo was like learing recursion all over again.
14:19:57 <ocharles> roconnor: I felt like that when learning ArrowLoop
14:20:01 <ocharles> which i feel has similarities
14:20:06 <roconnor> :)
14:20:07 <ocharles> but mdo still eludes me
14:20:17 <ocharles> this looks like quite a Monad.Reader, in general
14:20:28 <donri> luite: i don't think hdiff is updating since hackage2
14:20:29 <roconnor> ocharles: I get mdo now; as as ususal, I can't understand how I didn't understand it before.
14:20:31 <ocharles> I skim-read the thesis on mdo, should give that a closer read
14:20:46 <ocharles> roconnor: such is the curse of knowledge acquisition
14:21:47 <ocharles> but i still don't get what's going on with that code snippet i pasted above
14:22:19 * roconnor doesn't use the arrow abstraction.
14:22:55 <johnw> donri: I've told luite that he'll need to use the new hackage-mirror binary
14:23:22 <acomar> acowley: Ok, I undid the broken commit and pushed the two separate commits. Your branch should be fine since it should be exactly one commit behind mine.
14:23:40 <acomar> acowley: the squashed commit was just a readme update :/
14:24:35 <m0g> Not sure my message got through, I've been disconnected just after posting it. Sorry if it's a repost: I'm trying to apply a function :: [a] -> [[a]] on a monadic type m [a] and I'd like it to return [m [a]], is there an idiom for that?
14:24:50 <joelteon> can I make cabal tell me what exactly depends on a certain package?
14:25:38 <acowley> acomar: I recloned opencv-raw from you, it builds, but I still get the same error with revelation
14:25:38 <johnw> joelteon: I believe cabal-db can do just that
14:25:40 <donri> joelteon: that you have installed? try ghc-pkg unregister and see what complains :p
14:26:03 <acomar> acowley: installed into the same sandbox and all that?
14:26:21 <roconnor> m0g: that doesn't seem possible.
14:26:41 <acomar> acowley: maybe try deleting the installed version and reinstall it -- the function should definitely exist
14:26:51 <m0g> roconnor: ok :(
14:27:10 <fizruk> m0g: what's the use case?
14:27:12 <roconnor> m0g: beyond trivial and useless implementations.
14:27:47 <joelteon> ok, cabal-db looks somewhat helpful
14:27:49 <m0g> fizruk: I'm trying to split a list of items in Hakyll (Compiler [Item a]) into smaller list of items
14:28:01 <m0g> fizruk: sorry, list of smaller lists of items
14:28:04 <epta> Are there any f# gurus? Could you please take a look http://stackoverflow.com/q/19104114/570689
14:28:11 <joelteon> thing is, I've installed a bunch of deps with aptitude already but cabal wants to reinstall a lot of them for reasons I'm not sure of.
14:28:20 <joelteon> this is for a testsuite, so I'd like to make it take less than 45 minutes
14:28:48 <acowley> acomar: I got an unknown symbol, hooray!
14:29:14 <acowley> She's a beaut, __ZdlPv
14:29:21 <fizruk> m0g: I don't know about Hakyll, but maybe you want m [m [a]] instead? Why would you want to go outside of the monad?
14:29:26 <acowley> It's always __ZdlPv, isn't it?
14:29:36 <monochrom> joelteon: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave . in fact, see the whole thing.
14:29:56 <acomar> acowley: yea, now comment out the genSingletons line, and the lines that depend on it
14:29:56 <haasn> m0g: suppose the case where m ~ IO; there's no way to know how many ‘items’ your resulting list should contain without performing some sort of IO, hence only trivial implementations being possible (eg. always returning one element, or always returning an empty list)
14:30:01 <acomar> acowley and it compiles fine :/
14:30:02 <m0g> fizruk: yup I guess I need either that or Compiler [[Item a]]
14:30:07 <fizruk> m0g: or, simply m [[a]] ?
14:30:09 <acowley> acomar: Note that I get the same error if I try to cabal repl in opencv-raw
14:30:21 <acowley> acomar: So we're linking against something we can't link against
14:30:29 <acomar> acowley: hmm...that's interesting
14:30:31 <m0g> haasn: right
14:30:37 <m0g> thanks for clearing that up :)
14:30:38 <acomar> acowley: try cabal run
14:30:39 <joelteon> okay
14:30:47 <acomar> (once you've editted out the offending bits)
14:30:53 <joelteon> monochrom: i see your point
14:31:24 <haasn> m0g: in general, setting m ~ IO is a good way to sanity check whether your monad function could work :P
14:31:36 <monochrom> also, "ghc-pkg dot" shows dependency edges. combine with grep for specific search.
14:31:42 <joelteon> ok
14:32:00 <m0g> haasn: true :D
14:32:01 <monochrom> you may also like the output of "ghc -v"
14:32:21 <acomar> acowley: and supposedly, the ghci issue that causes that link problem goes away in HEAD
14:32:30 <acowley> acomar: supposedly
14:32:32 <joelteon> well I'm only planning on installing from the distro first
14:32:37 <joelteon> then installing the remaining deps with cabal-install
14:32:43 <monochrom> that's good
14:32:47 <joelteon> the question is *why* cabal wants to reinstall them at all
14:32:52 <acowley> If I add extra-libraries, I get a different link error
14:33:07 <acowley> I think this is going to be a pain
14:33:21 <Eduard_Munteanu> Hrm, why does GHC complain that a predicate is malformed if I use a   type Foo param = forall bar. (someConstraintHere)   ?
14:34:39 <applicative> joelteon: I think you should probably get as few haskell libraries as you can from aptitude if you are installing recent hackage things
14:34:47 <Eduard_Munteanu> type Foo param baz = forall bar. (someConstraintHere) => baz   is a (bad) workaround
14:34:55 <joelteon> well, they don't need to be that recent
14:34:56 <acowley> I have some C++ bindings in another project, but I use clang and libc++ for everything
14:35:00 <joelteon> I just want my build to get under 35 minutes
14:35:20 <fizruk> @pl \x -> g x >>= f
14:35:22 <acowley> So I guess I'd rather sort out the clang issues
14:35:23 <lambdabot> (>>= f) . g
14:35:23 <lambdabot> optimization suspended, use @pl-resume to continue.
14:35:40 <monochrom> "cabal install --dry-run -v3" is a long output, but it gives complete information of why it makes its choices
14:35:50 <joelteon> oh, i like that
14:36:12 <applicative> joelteon: are you building with -j (if it is taking too long)
14:36:44 <acomar> acowley: yuck :/
14:36:45 <joelteon> no, I didn't know cabal supported that
14:36:53 <fizruk> :t \x -> g x >>= f
14:36:54 <monochrom> use --constraint='bytestring < 3.5' to limit versions. use --constraint='bytestring install' to altogether ban adding bytestring
14:36:54 <lambdabot> (Monad m, Show a, FromExpr (t -> m a), FromExpr (m b)) => t -> m b
14:37:23 <fizruk> :t \g f x -> g x >>= f
14:37:24 <lambdabot> Monad m => (t -> m a) -> (a -> m b) -> t -> m b
14:37:30 <elliott> isn't it "installed", or does "install" work too?
14:37:35 <applicative> joelteon: you can announce the number of cores -jN if it matters. ghc will soon have this feature to i heard
14:37:37 <joelteon> i thought it was installed as well
14:37:37 <fizruk> @pl \g f x -> g x >>= f
14:37:37 <lambdabot> flip . ((>>=) .)
14:37:38 <monochrom> oops, installed
14:37:46 <monochrom> --constraint='bytestring installed'
14:37:58 <fizruk> :t (>=>)
14:37:59 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:39:18 <acowley> carter: is 7.8 coming out today or tomorrow? If neither, can you make that happen?
14:39:30 <carter> what?
14:39:35 <carter> you could use head
14:39:37 <acomar> carter: I second that request
14:39:41 <applicative> is 7.8 to appear so soon?
14:39:51 <carter> pester thoughpolice :)
14:39:58 <carter> he's merging like a bajillion patches this week
14:40:17 <acowley> carter: You are more immediately pesterable at the moment
14:40:22 <carter> true
14:40:35 <carter> but i don't have commit bit / tagging version powers
14:40:36 <carter> (yet)
14:40:43 <acowley> My problem with using HEAD is that when things don't work, I can't complain
14:40:43 <carter> just use HEAD
14:40:47 <carter> no
14:40:48 <carter>  you can
14:40:54 <carter> just upstream patches to everyone
14:41:00 <carter> i did it for 7.4 and 7.6
14:41:01 <joelteon> oh, right, so what I can do is constrain each package it's trying to reinstall and see why it breaks
14:41:02 <carter> its your turn
14:41:37 <carter> its better for everyone if every lib has patches landing for 7.8 compat before its in RC / release land
14:41:43 <carter> but there should be an RC this month
14:41:45 <carter> well
14:41:47 <carter> october
14:41:52 <carter> help out by testing
14:42:04 <acowley> I'm in this situation because I'm helping out by testing
14:42:04 <carter> acowley: also lets you have xcode 5 installed :)
14:42:14 <carter> what situation?
14:42:30 <acomar> he's helping me debug a TH/C++ lib linking issue
14:42:35 <acowley> needing 7.8 to link some C++ code
14:42:44 <carter> well
14:42:45 <monochrom> joelteon: in all likelihood, when you finally constrain everything, nothing "breaks" but simply resorts to older versions
14:42:47 <carter> build head and use it!
14:42:50 <acomar> he noticed that the linkage issue is identical the ghci linkage issue
14:42:51 <acowley> It works okay with a pure clang and libc++ setup, but we can't use that atm
14:43:02 <acowley> Where "It" is not exactly this situation
14:43:07 <acowley> but something similar
14:43:13 <carter> build ghc head!
14:43:17 <joelteon> monochrom: of course, but i'm fine with backporting the project, it should already build on GHC 7.4
14:43:20 <acomar> acowley: honestly, for the time being, I'm just going to use a typeclass and avoid singletons
14:43:23 <carter> or use johnw's nightlies
14:43:27 <acowley> acomar: smart move :)
14:44:22 <monochrom> yes. this is why I always say: the real cause of all problems is that --constraint='everything installed' is not the default. the default is to go cavalier in adding latest versions. sandboxing is merely peripheral.
14:44:32 <Eduard_Munteanu> Wow, this is cool... GHC accepts   data MkConstraint :: Constraint -> * where  MkC :: forall c. c => MkConstraint c
14:44:41 <acowley> I keep typing things like "git sandbox …" and "cabal commit ..."
14:44:52 <haasn> Eduard_Munteanu: yep
14:44:53 <monochrom> haha
14:45:03 <monochrom> @remember acowley I keep typing things like "git sandbox …" and "cabal commit ..."
14:45:04 <lambdabot> Okay.
14:45:07 <Eduard_Munteanu> And it also likes  type Test foo = MkConstraint (forall a. (a ~ a))
14:45:17 <Eduard_Munteanu> If you turn on ImpredicativeTypes, that is.
14:45:34 <haasn> Eduard_Munteanu: http://hackage.haskell.org/package/constraints-0.3.3/docs/Data-Constraint.html
14:45:55 <Eduard_Munteanu> haasn: cool, thanks
14:48:58 <johnw> carter: the nightlies have been broken since around 9/8, still working on getting them back up again
14:49:36 <haasn> unsafeApplicative :: forall m a. Monad m => (Applicative m => m a) -> m a -- who needs this superclass nonsense
14:51:40 <carter> haasn:
14:51:40 <carter> ?
14:52:01 <haasn> carter: http://hackage.haskell.org/package/constraints-0.3.3/docs/Data-Constraint-Unsafe.html :)
14:53:47 <acomar> acowley: ok, this compiles: http://lpaste.net/93657
14:54:16 <acomar> acowley: just need to write that rawArrayLookup function now
14:54:35 <acomar> but first, the dog is very upset that I haven't taken her on her walk yet... so I better go do that
14:54:43 <acomar> back in about an hour
15:02:42 <joelteon> applicative: cabal doesn't accept -j8
15:02:44 <joelteon> nor does GHC
15:03:01 <carter> joelteon: it will!
15:03:04 <joelteon> oh
15:03:07 <bergmark> really? :O
15:03:29 <carter> i think so
15:03:32 <bergmark> but my colleagues are always bragging about that they can do -j8 and i can only do -j4 :) :(
15:03:32 <carter> ask parcs
15:03:40 <haasn> cabal accepts -j
15:03:45 <carter> bergmark: well, we'll have HTM in 7.10 mebe
15:03:53 <carter> so they can suck on their slow locky code
15:03:53 <joelteon> oh, I must have an old cabal
15:03:55 <haasn> I don't know what exactly it does with it, though. I think it just enables parallel building of independent libraries
15:04:00 <carter> yup
15:04:11 <haasn> Isn't there a gsoc project for adding actual parallel module building to ghc?
15:04:21 <carter> yup
15:04:22 <carter> parcs
15:04:27 <carter> is the doer of it
15:04:30 <carter> i think its merged in even
15:05:17 <haasn> Is this slated for 7.8? :)
15:06:07 <carter> ghc --make -j?
15:06:08 <carter> yeah
15:06:14 <Polarina> haasn, I believe the patch is already in the repository.
15:06:22 <carter> htm + other concurrency awesome won't land till 7.10
15:06:25 <carter> but should by then
15:06:35 <haasn> carter: htm?
15:06:49 <carter> hardware supported subset of STM
15:06:58 <haasn> carter: for stuff like Haswell?
15:06:59 <carter> with some restrictions
15:07:00 <carter> yes
15:07:01 <carter> those
15:07:05 <haasn> oh okay
15:07:10 <carter> ask fryguybob knows more :)
15:07:14 <haasn> I thought you were talking about some radical new parallel-module-building technology :)
15:07:20 <carter> i hopefully will be helping him hack that out
15:07:21 <carter> well
15:07:27 <carter> the fewer locks the better!
15:08:48 <joliv> !join #python
15:08:50 <joliv> um
15:08:51 <benzrf> hello
15:08:54 <joliv> Wasn't me D:
15:09:07 <benzrf> I have been told that monads are not just for side effects
15:09:18 <haasn> benzrf: monads are an abstraction, for all kinds of things
15:09:18 <benzrf> but other than that, I have no idea of what a monad is meant to represent...
15:09:21 <benzrf> :|
15:09:28 <benzrf> I don't really *get* that abstraction
15:09:31 <benzrf> what do I do
15:09:43 <haasn> benzrf: http://www.haskell.org/haskellwiki/Typeclassopedia#Monad is a good place to start but it might be a little heavy if you're not familiar with HAskell
15:09:45 <fizruk> @seen edwardk
15:09:45 <lambdabot> Ed\/\/ARdx
15:09:51 <benzrf> haasn: i'm pretty familiar
15:09:54 <haasn> @leet fizruk
15:09:54 <lambdabot> phIzRUx
15:10:00 <donri> preflex: seen edwardk
15:10:00 <preflex>  edwardk was last seen on #haskell 1 hour, 54 minutes and 57 seconds ago, saying: the only one that isn't trivial is like the comonoid of a value
15:10:08 <benzrf> preflex: version
15:10:08 <preflex>  9.308
15:10:12 <benzrf> preflex: list
15:10:12 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:
15:10:13 <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
15:10:22 <benzrf> huh
15:10:28 <fizruk> donri: thanks
15:10:34 <chrisdone> that's why preflex is more advanced than lambdabot
15:10:38 <chrisdone> it can do a commands list
15:10:45 <elliott> so can lambdabot
15:10:47 <benzrf> personally I enjoy supybot
15:10:54 <benzrf> IMPERATIVE WOO
15:11:28 <benmachine> preflex: excuse
15:11:32 <preflex>  Cache miss - please take better aim next time
15:11:40 <ReinH> benzrf: try some exercises: write the monad instance for Identity, then for Maybe, then for Writer
15:11:53 <haasn> then ((->) r)
15:12:03 <benzrf> ReinH: don't know about Identity
15:12:08 <ReinH> benzrf: well look it up :D
15:12:11 <benzrf> I understand Maybe and Writer in terms of my side-effect model
15:12:14 <haasn> benzrf: newtype Identity a = Identity { runIdentity :: a }
15:12:18 <haasn> It's... quite trivial
15:12:19 <benzrf> ah
15:12:37 <benzrf> so a monad represents...
15:12:42 <benzrf> something composable?!
15:12:43 * haasn gets popcorn
15:12:49 <benzrf> I do not understand :I
15:12:56 <fizruk> are there free monad experts available? :) http://lpaste.net/93680
15:12:57 <benzrf> brb reading typeclassopedia
15:13:27 <monochrom> benzrf: it is ok if you don't know all uses of arrays, all theories of arrays, and all things under the sun about arrays. likewise, it's ok if you don't know all uses of monads, all theories of monads, and all things under the sun about monads.
15:13:38 <haasn> benzrf: that sounds more like Applicative
15:13:54 <haasn> benzrf: (but every Monad is an Applicative)
15:14:09 <monochrom> if you just know one use of arrays and one use of monads, that's already quite enough for today.
15:14:32 <benzrf> no, i've 'understood' monads through my side-effect model for a few months now
15:14:33 <benzrf> :L
15:14:44 <ReinH> benzrf: Monad is a typeclass that defines some behavior for types that are monads
15:14:46 <benzrf> but i don't actually write a lot of haskelll
15:14:59 <monochrom> after all, people know only one model for arrays, too.
15:15:02 <ReinH> it has some functions with type signatures and some laws about how they should work
15:15:16 <ReinH> and that's about it
15:15:29 <ReinH> any instance defines those functions such that they conform to the laws
15:15:29 * monochrom knows at least 3 models for arrays
15:15:32 <ReinH> and then that instance is a monad
15:15:39 <benzrf|reading> ReinH: oh you
15:15:49 <ReinH> benzrf|reading: no, I'm serious. That's what a monad is.
15:15:53 <benzrf|reading> im aware
15:15:57 <ReinH> You'll gain intuition by defining and using them
15:16:05 <krakrjak> monads are good models of side-effects...  They are also good for encapulation of computation, pure or effectful.
15:16:26 <monochrom> and also what ReinH says, i.e., you learned arrays by using them
15:16:40 <krakrjak> ^^^^this
15:16:47 <ReinH> benzrf|reading: so let's take instance Monad Identity
15:16:54 <dmj`> yea, most people don't roll their own monads from scratch, they just typedef a custom transformer and derive Monad, MonadIO, etc.
15:16:56 <benzrf|reading> reading typeclassopedia P
15:16:58 <benzrf|reading> 8:P
15:17:00 <benzrf|reading> ugh
15:17:06 <ReinH> benzrf|reading: give me a function return a :: a -> m a where m is Identity
15:17:11 <haasn> benzrf|reading: it may interest you to look at the alternative formulation for Monad, ie. with join :: Monad m => m (m a ) -> m a
15:17:33 <haasn> this is not so much ‘computation’ as it is in general a monoid structure on some functor m
15:17:46 <ReinH> haasn: endofunctor :D
15:17:59 <haasn> in this context, a monad changes from “anything that can be bound” to “anything that can be concat'd”
15:18:05 <haasn> (very roughly speaking)
15:18:40 <ReinH> benzrf|reading: if newtype Identity a = Identity { runIdentity :: a }, how do I turn an a into an Identity a?
15:18:57 <krakrjak> haasn: ooohhh...  that's a great way to describe join, thanks!
15:18:59 <haasn> let the poor guy read :P
15:19:03 <ReinH> ok :p
15:19:57 <dmj`> benzrf|reading: All about monads.pdf is good. Rewriting Control.Monad really helped me gain intuition.
15:20:09 * monochrom has a cunning plan! time to add a monad tutorial from the adjunction angle. more theories to make people feel bad \∩/
15:20:14 <haasn> Monad exercises \o/ http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
15:20:31 <dmj`> haasn: Those are very good
15:20:39 <donri> monads are just space suits in the category of endoburritos
15:20:49 <shachaf> donri: Stop it. You're being unhelpful.
15:20:55 <ReinH> haasn: ooh nice
15:20:58 <benzrf|reading> btw my main intuition of monoids are as things that can be 'accumulated', how wrong is that?
15:21:12 <monochrom> not wrong
15:21:15 <ReinH> benzrf|reading: pretty right.
15:21:19 <benzrf|reading> oh good
15:21:30 <ReinH> benzrf|reading: imperative langauges accumulate computations :)
15:21:31 <shachaf> I don't know what "accumulated" means so I can't tell you.
15:21:38 <benzrf|reading> argh
15:21:39 <benzrf|reading> bbiab'
15:21:50 <shachaf> @quote formalist
15:21:50 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
15:22:05 <ReinH> oh lmao that's where Misty banana and unicorn came from
15:22:08 * monochrom is a formalist indeed
15:22:09 <ReinH> now it all makes sense
15:22:12 <haasn> now benzrf|atdinner must undergo a quest to tackle burritos of a very different kind
15:22:17 <benzrf|atdinner> god i hate formalists
15:22:20 <benzrf|atdinner> 8D
15:22:32 * benzrf|atdinner heeds the call of corn on the cob
15:22:44 <haasn> rn on the b
15:22:46 * hackagebot vinyl-gl 0.1.0.1 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://beta.hackage.haskell.org/package/vinyl-gl-0.1.0.1 (AnthonyCowley)
15:22:52 <benzrf|atdinner> (thanks for the "help")
15:22:53 <ReinH>   /win 21
15:22:54 <ReinH> argh
15:23:10 * monochrom does not understand a theory until he can do symbolic calculational proofs in that theory. seriously.
15:23:36 * ReinH does not understand a theory.
15:25:16 <haasn> ReinH: that again sounds more like Applicative :) (re: “accumulating”)
15:26:16 <chrisdone> monochrom: werd
15:26:24 <ReinH> haasn: sounds like join to me :)
15:26:32 <ReinH> fsvo accumulate
15:27:32 <haasn> ReinH: clearly we need to formulate ‘accumulation’ to continue this discussion
15:27:42 <ReinH> accumulate = mappend :p
15:27:57 <ReinH> M x M -> M
15:28:12 <haasn> liftA2 mappend  \o/
15:29:02 <ReinH> I think it makes sense in this context: join combines two monad contexts, providing a single monad context that "accumulates" the effects of each, preserving order.
15:29:29 <haasn> I think the word goes both ways, really
15:29:35 <ReinH> ok :) words suck
15:29:43 <haasn> liftA2 (,) does just as much ‘accumulating of effects, preserving order’
15:29:47 <ReinH> thank goodness we have math and haskell to express concepts
15:30:09 <haasn> clearly, ‘accumulate’ is just sufficiently polymorphic
15:30:13 <ReinH> ok :)
15:30:19 <ReinH> it means whatever you want it to mean!
15:30:29 <haasn> all words do!
15:30:35 <ReinH> I disagree!
15:30:37 <haasn> man, languages are impossible
15:30:38 <ReinH> By which I mean that I agree!
15:31:02 <haasn> How can we possibly communicate? How do I know your words mean the same thing mine do? aaah
15:31:06 <ReinH> haasn: Wittgenstein summed up in a single sentence? :)
15:31:37 * haasn pulls up wikipedia...
15:31:45 <ReinH> Tractatus, or, Language Is Impossible.
15:32:06 <jfischoff> acowley: I like the direction you are taking with vinyl-gl
15:32:14 <haasn> I bet the academic body rejected his works because they found it “impossible to understand”
15:32:17 <acowley> jfischoff: Thanks!
15:32:25 <monochrom> this is why I simply answered "not wrong" period.
15:32:39 <jfischoff> how can I help?
15:32:48 <ReinH> monochrom: you are wise :)
15:33:45 <ReinH> haasn: actually Tractatus is the one where he gave a shit about words and theirmeaning. Philosophical Investigations is the "words are all just stupid games we play with each other" one.
15:34:06 <ReinH> haasn: http://en.wikipedia.org/wiki/Language-game
15:34:22 <ReinH> ("stupid" may be a bit of editorializing on my part)
15:34:42 <haasn> ReinH: interesting! thanks
15:34:47 <monochrom> #haskell is an English Room :)
15:35:21 <acowley> jfischoff: I have a couple ideas, but I'm very much open to input. One is an embedding of GLSL into Haskell, the other is a higher level pygame-type binding (more specifically, something like Codea, if you're familiar with that).
15:35:30 <ReinH> monochrom: English is just a game we play too :p
15:35:36 <haasn> Haskell is a game we play
15:35:38 <acowley> jfischoff: Basically, I want to whittle the vinyl-gl examples down even further
15:35:55 <ReinH> haasn: programming is actually my favorite example of a language game :)
15:36:06 <jfischoff> acowley: I have a few partially complete GLSL parsers written in Haskell. I think that is good idea
15:36:11 <haasn> a GLSL EDSL with syntax magic would be evil but cool
15:36:30 <haasn> I wonder how close you could get it
15:36:51 <acowley> An insanely prosaic concern I have is that I like having syntax highlighting, and don't just want to bung GLSL in with TH
15:37:20 <acowley> It's also nice being able to edit GLSL files without having to relink an executable, but that might be a lost cause.
15:37:36 <ReinH> acowley: I want what you want.
15:37:50 <jfischoff> I think a start would be a GLSL AST, how it gets created is another question
15:37:55 <acowley> What would we hope to gain by writing GLSL in Haskell? In a sense, the entire shader model has already abstracted various loops
15:37:59 <krakrjak> so on the accumulation monoid thing?  Sounds like join because monads are monoids that have join and models the monoid computation using the accumulation properties while adding concatenation?
15:38:08 <acowley> Oh, I want to add instanced geometry to GLUtil, too… but that's orthogonal
15:38:14 <ReinH> acowley: aside from not having to write GLSL?
15:38:58 <jfischoff> I'm okay with writing GLSL. I just want to know if the types of my programs match the input geometry
15:38:59 <stevely> isn't GLSL-in-Haskell what the lambdacube guys are doing?
15:39:00 <acowley> ReinH: GLSL is not all bad
15:39:09 <jfischoff> and that all of the textures are there etc.
15:39:17 <acowley> jfischoff: Yes, that's what vinyl-gl is trying to do
15:39:22 * jfischoff nods
15:39:31 <acowley> jfischoff: I guess I don't check for texture bindings, though, do I?
15:39:39 <acowley> stevely: I think so
15:39:39 <ReinH> acowley: it's actually quite decent, I just don't like context switching
15:39:43 <jfischoff> I just took a quick glance
15:39:59 <acowley> ReinH: I hear you, but I hate it when people abstract GLSL and end up with something that brings its own limitations to the table
15:40:22 <jfischoff> I was trying something similar last year, but I tried to keep track of state changes on the hardware to and that was just stupid crazy
15:40:34 <jfischoff> also I started a job and forgot about it :p
15:40:37 <acowley> ReinH: I also hate losing the benefit of the thousands of pages of text talking about how to do things in GLSL. Having to port all that example code from GLSL to your personal DSL seems like a waste of time to me.
15:40:49 <ReinH> acowley: oh vinyl-gl is based on GLFW-b?
15:41:02 <acowley> jfischoff: The texture binding thing sounds do-able
15:41:10 <ReinH> acowley: both of those things are true.
15:41:21 <acowley> ReinH: It's not dependent on GLFW-b
15:41:27 <jfischoff> the annoying thing about opengl programming is seeing a black screen because of a type error
15:41:57 <ReinH> acowley: ah. https://github.com/acowley/vinyl-gl/blob/master/examples/src/Window.hs is nice :)
15:42:09 <acowley> ReinH: I use it alot
15:42:21 <ReinH> acowley: I think I'm going to be using vinyl-gl soon :)
15:43:05 * haasn has always wanted to try writing a video renderer in Haskell
15:43:09 <jfischoff> yeah I'm going to play with it myself. I'll see if I come up with some feedback
15:43:23 <acowley> jfischoff: I'd love to hear it
15:43:28 <haasn> I wonder if we could find some comonadic embedding of image processing algorithms that can be lifted to GLSL
15:43:30 <haasn> if that makes sense
15:43:47 <acowley> jfischoff: I'm really happy with how it makes OpenGL incrementally more type safe.
15:43:47 <edwardk> acowley: i can sympathize with that position a lot
15:43:48 <edwardk> clearly the dsl should just typecheck glsl at template haskell quasiquote time ;)
15:43:50 <acowley> There's less bath water, but the baby is safe!
15:44:00 <jfischoff> :)
15:44:06 <haasn> would be really cool to write, say, upscaling algorithms that way (but have it run on the GPU)
15:44:13 <acowley> haasn: There's a language that does that
15:44:47 <acowley> haasn: Halide, I think
15:45:02 <acowley> it always takes  me a minute to track it down
15:45:06 <acowley> I've not tried it, though
15:45:28 <haasn> re: taking a minute to track it down <- sounds like me and helium
15:45:52 <acowley> Languages that begin with an "H" are just impossible
15:46:21 <ReinH> acowley: Is the best OpenGL text rendering technique still textured quads a la Valve?
15:46:23 <edwardk> Ha makes it worse
15:46:28 <ReinH> edwardk: hai
15:46:28 <jfischoff> I bet a GLSL AST could be written that accumulated resource usage (uniforms, varyings, samplers) at the type level. I have no idea if one would want to use it …
15:47:44 <acowley> jfischoff: vinyl-gl checks the uniforms at runtime, and the GLSL compiler checks varyings between the VS and FS, so perhaps we could just pick out the samplers ourselves
15:47:51 <haasn> acowley: no, no, HLSL works fine (it's just like GLSL with a typo)
15:48:31 <haasn> acowley: Halide actually does seem interesting. Does it compile down to GLSL or something like that?
15:48:35 <ReinH> > succ 'G'
15:48:36 <lambdabot>   'H'
15:48:44 <benzrf|atdinner> @src succ
15:48:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:48:47 <haasn> > 'G' & from enum +~ 1
15:48:48 <benzrf|atdinner> ah
15:48:48 <lambdabot>   'H'
15:48:54 <benzrf|atdinner> @t succ
15:48:54 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
15:49:05 <benzrf|atdinner> @type succ
15:49:06 <haasn> this is legitimately what I did to test it in GHCi :(
15:49:07 <lambdabot> Enum a => a -> a
15:49:07 <acowley> haasn: Probably CUDA, but I don't know
15:49:10 <haasn> lens has distorted my mind
15:49:29 <ReinH> haasn: :p
15:50:21 <acowley> I still don't understand most of lens
15:50:31 <haasn> acowley: oh, Halide provides its own C++ EDSL and an API to render them out for you
15:50:36 <jfischoff> acowley: yeah we could do that
15:50:42 <acowley> I've been using it for a long time now, but I find I tend to avoid the bits that are really mysterious to me
15:50:50 <haasn> It might be possible to write a cool Haskell FFI for that, it seems like it composes primitives in a very declarative way
15:51:19 <acowley> haasn: Somebody needs to kick the tires to make sure it's usable before we lean on it too heavily
15:54:19 <ocharles> https://plus.google.com/102639662159168879968/posts/R2S3vxvC1YQ you can totally use haskell for games
15:54:30 <haasn> Yes! I use it to write pong all the time
15:54:43 <ocharles> watch out Nikki and the Robots!
15:55:25 <jfischoff> ocharles: cool!
15:55:49 <ocharles> oh that's sad, nikki and the robots didn't make enough money to be a viable endevour :(
15:57:21 <acomar> acowley: so how did you come up with F.product i * nc bit? I can't seem to work out why that's right
15:57:30 <acowley> acomar: It's not
15:57:34 <acomar> acowley: ok, good
15:57:35 <acowley> acomar: There's even a note that says it's not
15:57:40 <acomar> o.O
15:57:48 * hackagebot plotserver-api 0.1 - Plotserver API  http://beta.hackage.haskell.org/package/plotserver-api-0.1 (dtorok)
15:58:04 <acomar> I must be blind or something cause I don't see it
15:58:10 <acowley> http://lpaste.net/93661
15:58:43 <acomar> ahh whoops, I stripped the comments out too soon
15:59:38 <acowley> acomar: Any reason you're not using linear for the pixel types?
15:59:58 <acowley> ScalarT, that is
16:00:35 <acowley> That's an honest question, too. I'd just like to know why people don't use linear when they don't so we don't make things worse.
16:00:36 <ocharles> I read that as ScalaT
16:01:12 <acomar> acowley: nope, just haven't spent time figuring out linear yet
16:01:19 <acomar> acowley: I was planning to read up and switch a bit later
16:01:26 <acowley> Yes, now we're doing Scala at the type level
16:01:37 <acowley> linear is supposed to be really simple
16:02:05 <acomar> 20 simple and different things are pretty complicated in combination :)
16:02:08 <acowley> The biggest problem we have is when it's not simple. It's supposed to be very modest to support the basic, dumb stuff.
16:02:13 <acowley> True
16:03:23 <acomar> this is my first time using data kinds and type families for more than trivial examples, so I'm still on the learning curve -- trying to add other things in one at a time
16:04:09 <acowley> Yeah, understood. But the very top priority of linear really is to be a canonical implementation of dumb things like V2, V3, etc.
16:04:19 <acomar> fair enough
16:04:50 <Maior> :t fix Nothing
16:04:51 <lambdabot>     Couldn't match expected type `a0 -> a0' with actual type `Maybe a1'
16:04:51 <lambdabot>     In the first argument of `fix', namely `Nothing'
16:04:51 <lambdabot>     In the expression: fix Nothing
16:04:56 <Maior> er
16:07:27 <markamber> what works like (:) but with type [[a]] -> [a] -> [[a]]
16:07:31 <acomar> acowley: ok, swapped to V1/V3 for the pixel types
16:07:49 * hackagebot plotserver-api 0.2 - Plotserver API  http://beta.hackage.haskell.org/package/plotserver-api-0.2 (dtorok)
16:08:52 <acowley> acomar: The big win with that is the Storable instances for interop between Mat and Vector. You can now Vector map a lens operation on your pixels!
16:10:48 <acomar> acowley: ahh, and I get back matrix operations for free it looks like
16:10:50 <stevely> markamber: any reason you can't just do "flip (:)"?
16:11:30 <markamber> stevely: because I am new to this! I will try that
16:12:54 <acowley> acomar: Yes!
16:13:04 <mmirman> Anybody have any luck installing ghc-7.6.* on ubuntu-12.04?
16:13:21 <ocharles> acowley: and you can send a M44 straight to opengl :)
16:13:35 <acowley> Yes, and vinyl-gl will make sure GLSL is expecting one
16:13:36 <acomar> acowley: I'm sold :D
16:13:36 <S11001001> mmirman: I've built 1, 2, and 3 on trisquel 6, which is a 12.04 derivative
16:14:46 <benedikt> what is the simplest way to do a http post with haskell?
16:16:21 <S11001001> mmirman: it was completely straightforward, using the deb-packaged ghc to bootstrap
16:17:11 <acowley> ?hackage HTTP
16:17:11 <lambdabot> http://hackage.haskell.org/package/HTTP
16:17:16 <stevely> benedikt: probably http://hackage.haskell.org/package/HTTP-4000.2.8/docs/Network-HTTP.html#v:simpleHTTP
16:17:18 <fizruk> edwardk: hi there! able to discuss wrapT?
16:18:50 <acomar> acowley: so in a 3D matrix, are the columns and...depth? guaranteed to be continuous? i.e. it's just rows that aren't packed?
16:19:03 <acowley> acomar: I don't know
16:19:12 <acowley> acomar: I've not done anything with 3D Mats :/
16:19:12 <benedikt> stevely: it doesn't support https
16:19:13 <acomar> acowley: so a ptr to a row is good enough, we don't also need to get a ptr to the appropriate column in the 3D case
16:19:25 <acomar> yea, I figured :/
16:19:31 <acowley> acomar: The ptr API itself seems pretty 2D biased
16:19:37 <acomar> yea, it really does
16:19:55 <acowley> acomar: It's probably not worth worrying about 3D images at this point
16:20:11 <acomar> not planning to, I was just wondering if you knew
16:20:14 <mmirman> I'm going to try it from source again. The first time it gave me an error: that did not find module: GHC.Classes with any suffix: ["p_hi"]
16:20:15 <acowley> acomar: If you want, you can add a note telling people to blame me when they encounter breakage in that area :P
16:20:24 <acomar> hahaha
16:20:39 <acomar> I'll just assign you to those tickets, problem solved :P
16:22:01 <markamber> Still cannot figgure it out. I would like to prepend a list with a list of lists. To put it another way I would like to append an element to a list, and that element is a list, and the list is full of lists
16:22:31 <ReinH> markamber: you can't prepend list of lists to a list unless that list is also a list of lists
16:23:03 <markamber> ReinH: let me try something here...
16:23:07 <ReinH> [[a]] and [a] are not the same type.
16:23:25 <acowley> :t \xss xs -> xss ++ [xs]
16:23:25 <lambdabot> [a] -> a -> [a]
16:24:03 <haasn> :t (|>)
16:24:03 <lambdabot> Snoc Control.Lens.Internal.Review.Reviewed Identity s s a a => s -> a -> s
16:27:12 <martxel> morning
16:30:18 <edwardk> fizruk: walking home, but still open to the idea
16:31:08 <acowley> edwardk: Did you by any chance ever write a version of ~> for composing Plans in machines?
16:31:12 <acomar> acowley: I'm rapidly becoming convinced opencv's matrix api doesn't actually support anything but 2D matrices despite the documentation's claims that it does
16:31:42 <acowley> acomar: hahaha… future proofing, I guess?
16:31:45 <acomar> oh, and a few uses of matrices as vectors, but they treat that as 2D with only 1 row
16:31:50 <fizruk> edwardk: have you looked at the use case of wrapT in my demarcate library?
16:32:05 <acomar> for example, there's no way to find out what the size of each dimension is...
16:32:14 <acomar> just rows and columns
16:32:32 <acomar> if it's a 3D matrix, you better already know because rows and columns are set to -1
16:32:57 <edwardk> firzuk: just started getting free of my backlog, so not yet.
16:33:08 <fizruk> edwardk: I thought it would be possible to define wrapT differently for a specific case of Demarcate. unfortunately, that supposition turned out wrong
16:33:14 <edwardk> i want to try it with some effectful cases
16:34:26 <edwardk> acomar: i confess to never using it outside 2d myself
16:35:04 <fizruk> edwardk: you mean like t ~ StateT Int and m ~ WriterT String (Free SomethingF) in wrapT :: f (t m a) -> t m a?
16:35:35 <acomar> edwardk: I don't think anyone does, but the documentation claims the matrix type is n-dimensional...
16:35:37 <edwardk> i'll pose it to dolio tomorrow at work and see if he can't bang out a full proof off the top of his head
16:35:45 <edwardk> hah
16:36:01 <edwardk> bitrot?
16:36:16 <acomar> must be
16:36:51 <edwardk> fizruk more using IO and FreeT
16:37:11 <acomar> acowley: any objections to removing the matrix dimensionality type parameter and just treating matrices as 2D?
16:37:12 <edwardk> and seeing if i can't cause a duplicated effect
16:37:13 <acowley> acomar: As you make progress, we should reach out to the OpenCV people, btw. It would be nice to get some official recognition.
16:37:20 <acowley> acomar: None at all
16:37:43 <fizruk> edwardk: oh, I should try that
16:37:45 <acowley> acomar: I can probably get an email to right people
16:37:58 <acomar> acowley: I've been planning to do that -- wanted to finish wrapping all the major types before I went to them so I have something a bit more complete to show them
16:38:14 <acomar> acowley: the mats are still incomplete, and there's no wrapping of points, sizes, etc. yet
16:38:31 <edwardk> fizruk: _that_ is the thing i hesitate about. the pure stuff is largely unobservable
16:38:32 <acowley> acomar: Yeah, it's not worth doing early. But if it works out and you want to make it an ongoing thing, my main collaborator is all buddy buddy with those folks.
16:38:57 <acomar> acowley: awesome, I'll let you know when I'm ready for that then
16:39:51 <edwardk> fizruk: thinking it may be possible using FreeT Bin IO for data Bin a = Bin a a
16:40:49 <acomar> acowley: do you think they'd be interested in incorporating the haskell bindings, or just the c wrappers?
16:41:20 <edwardk> if not careful may get two copies of the action buried deeper in the tree, or may get them moved out
16:41:26 <user123abc> could use a hand with my concatM function
16:41:28 <user123abc> http://lpaste.net/285058194911264768
16:41:31 <fizruk> edwardk: thanks for the direction, I'll try it immediately :)
16:41:40 <user123abc> why is the expected type [[[a]]] ?
16:42:32 <jfischoff> user123abc: add some parens and see if it will compile
16:42:35 <acowley> acomar: I don't know, but both seem interesting.
16:42:41 <user123abc> ah
16:42:59 <pqmodn> what is "observable sharing"?
16:43:35 <user123abc> got it to compile like this: (return . concat) =<< (sequence ms)
16:43:46 <user123abc> the $ vs . still trips me up
16:43:53 <jfischoff> yeah and you can simplify it further
16:44:06 <edwardk> pqmodn: http://www.ittc.ku.edu/~andygill/papers/draft-kansas-lava-ifl09.pdf talks about the issue
16:44:08 <user123abc> indeed
16:44:26 <jfischoff> return . f =<< m ~ fmap f m
16:45:04 <ReinH> jfischoff: what is ~ there?
16:45:07 <user123abc> same question
16:45:09 <jfischoff> equivalent
16:45:15 <ReinH> k
16:45:34 <user123abc> oh, thanks, I was just looking for something like that
16:46:02 <jfischoff> or liftA or liftM should also work
16:46:03 <user123abc> that's why that liftM attempt was there
16:46:13 <acowley> I usually think of observable sharing in terms of referential transparency. RT says we can substitute the definition, OS says, what if we didn't?
16:46:19 <jfischoff> yeah same thing
16:46:23 <user123abc> liftM didn't work for the record
16:46:32 <user123abc> though I should move on
16:46:33 <user123abc> thanks
16:46:34 <jfischoff> oh well
16:48:34 <pqmodn> edwardk: okay, thanks. does your remark that "pure stuff is largely unobservable" have any relation to this term? i think i've seen the word "observable" used with circularity (eg, recursive definitions, cyclic graphs)
16:49:32 <edwardk> pqmodn: no i meant it might duplicate work but it'd be harder to observe in practice compared to doubled up prints
16:49:59 <pqmodn> ok
16:50:21 <acowley> edwardk: Did you see my question about machines earlier?
16:50:29 <edwardk> i'm also writing another post about universal properties and observational equivalence that is -also- unrelated. it is a very overloaded term :)
16:50:37 <edwardk> acowley nope
16:50:46 <acowley> edwardk: Did you ever write something like ~> for Plan?
16:51:08 <edwardk> i hesitate. it leads to time leaks
16:51:17 <acowley> I've written a boat load of machines code, with an emphasis on concurrent pieces
16:51:23 <acowley> oof
16:51:25 <edwardk> thats why we have the phase separation
16:51:44 <acowley> I suck at writing Plans by hand, btw
16:51:45 <user123abc> oh, the liftM didn't work because of associativity issues too
16:51:49 <edwardk> with pipes you just get an asymptotic slowdown
16:52:04 <user123abc> I wound up going with that over fmap, since I didn't have a functor context
16:52:09 <pqmodn> acowley: i'm not sure i grasp it yet. by *not* replacing names with the term they refer to, it's straightforward to see they share an expression?
16:52:10 <edwardk> with machines you can't think the bad thought
16:52:19 <edwardk> not sure which is the worse evil
16:53:06 <acowley> edwardk: I have this chunking code that runs a machine to completion on a chunk, but I end up having to tag yielded values to get useful outputs
16:53:13 <acowley> edwardk: I've also made a mess of my commit history
16:53:24 <edwardk> pqmodn: it lets you work explicitly with a graph tather than expand it to a tree
16:53:32 <pqmodn> edwardk: ah, that makes sense :)
16:53:34 <acowley> edwardk: I'm going to try to clean that up, then push it to my fork on github and you can decide if I should keep it separate or not
16:53:45 <edwardk> k
16:54:04 <edwardk> pchiusano needs to get back into machines.
16:54:30 <edwardk> i haven't been able to draw him into a discussion about it in a while and i want his sink code
16:54:38 <acowley> hm
16:55:25 <acowley> That would possibly break what I've done
16:55:33 <acowley> I just wanted concurrent things
16:55:38 <acowley> then I got carried away
16:55:43 <edwardk> hahahaha
16:55:51 <acowley> It's a lot of code
16:57:07 <enthropy> does anybody know a better workaround for ghc7.7 than here: http://lpaste.net/93681
17:00:00 <user123abc> I'm trying to use haskell's type system to express the "heirarchy" of X64 assembly operand restrictions, and I'd like to avoid nesting constructors because it makes my code hard to read
17:00:10 <user123abc> here's the starting point:
17:00:10 <user123abc> http://lpaste.net/6595773910598287360
17:00:23 <user123abc> here's what I came up with last night
17:00:25 <user123abc> http://lpaste.net/212541812466778112
17:01:22 <user123abc> everything except testpat2 works, though the testpat2 behavior of changing from one type of operand to another is important
17:01:38 <user123abc> does anybody know of any neat tricks that could get me what I want?
17:01:46 <Cale> There are no values of type Val.
17:01:57 <Cale> (you probably meant something different)
17:02:09 <user123abc> let me check
17:02:25 <user123abc> well, that is what I meant
17:02:30 <Cale> (You probably intended for Val to be existential)
17:02:31 <user123abc> though it doesn't work
17:03:01 <user123abc> I'm not sure how that would work - when I toyed with existential types for this problem I didn't get far
17:03:26 <user123abc> but if you comment out testpat2, you can see how the Val a b approach almost works
17:03:32 <Cale> What you wrote means that Operand is applied to polymorphic types, but all the constructors of Operand produce results where Operand is applied to specific types.
17:04:16 <user123abc> yeah, and I want to write functions that only take an Operator applied to certain combinations
17:05:01 <Cale> For instance, Reg 1 :: Val should fail to typecheck.
17:05:07 <Cale> (as it stands)
17:05:34 <user123abc> yeah, but functions don't take Val, they take Val a b
17:05:42 <acomar> acowley: the storable instances for V2 and V3 make this really straight forward!
17:06:00 <user123abc> but oh, the issue is what you said, that I can't make instances of the non-specific types like Val and Loc
17:06:02 <Cale> Val doesn't have any type parameters
17:06:02 <acowley> acomar: great!
17:06:13 <user123abc> did I upload an old version? crap
17:06:16 <Cale> (unless I'm looking at the wrong code)
17:06:36 <user123abc> yeah, sorry!
17:06:46 <user123abc> http://lpaste.net/3768533687105224704
17:07:52 <acomar> acowley: I had started to typeclass the look up until I realized the storable instances and return type polymorphism make it totally unnecessary -- it's the same code either way
17:08:09 <Cale> Doesn't testpat2 produce a result of type Loc R?
17:09:18 <Cale> If I wanted to get a Loc NR from it, say, then I couldn't.
17:09:25 <Cale> (based on its definition)
17:09:40 <acowley> acomar: Yeah, it's an awesome fit.
17:09:50 <Cale> Remember that the *user* of testpat2 will get to decide which types a and b are.
17:09:52 <user123abc> yeah, I think that's another way of spinning the issue
17:10:44 <user123abc> I'm realizing now that that isn't even the same case that I ran into - I had a bit of actual code that was producing values of Loc R and Loc NR
17:11:03 <user123abc> so I guess that I can't really get any further with this approach
17:11:10 <user123abc> any ideas?
17:11:22 <Cale> If there's some kind of functional dependence between what types are produced based on the types of the inputs, then you could use a class with an associated type
17:11:50 <user123abc> reading up now
17:11:51 <user123abc> thanks
17:12:04 <Cale> class Foo a where
17:12:18 <Cale>   type FooResult a
17:12:30 <Cale>   foo :: Loc a -> Loc (FooResult a)
17:12:49 <letrec> Is Network.HTTP.Conduit compatible with forkIO and stuff in Control.Concurrent ? I think so but just want to make sure.
17:13:18 <Cale> letrec: forkIO is compatible with everything.
17:43:00 <redscare> given that the reader monad exists, are there applications for (t->) as a monad?
17:46:02 <fizruk> redscare: isn't (t->) equivallent to ((->) t) and thus to Reader monad?
17:46:26 <fizruk> redscare: did you mean (->t) ?
17:46:29 <shachaf> (t ->) is Reader without the pointless newtype.
17:46:32 <acomar> acowley: pushed greatly simplified indexing code
17:46:44 <shachaf> (-> t) isn't a thing you can express in Haskell without a newtype. And if it was, it wouldn't be a monad.
17:49:44 <redscare> shachaf: so is (t->) somehow preferred over Reader since you call the newtype "Pointless"?
17:50:38 <shachaf> It depends on what you're doing. I don't know.
17:55:55 <acomar> is there a good reason Data.Vector.Storable's Vector doesn't have a Storable e => Storable (Vector e) instance?
17:56:09 <acowley> Yes
17:56:15 <acowley> What would you do for sizeOf
17:56:16 <acowley> ?
17:56:31 <acowley> Storable is for things whose size you statically know
17:56:44 <acomar> hmm... ok, fair
17:57:49 <edwardk> redscare: generally, yes
17:58:31 <enthropy> acomar: there is this however http://hackage.haskell.org/package/storable-static-array
17:59:44 <acomar> enthropy: I'm going to use linear's V type instead since I already have a linear dependency
17:59:46 <acomar> but thanks
18:00:49 <ReinH> edwardk: dude holy shit http://acko.net/blog/animate-your-way-to-glory/
18:01:08 <edwardk> ReinH: yep. that was why i was recommending it =)
18:01:19 <ReinH> edwardk: I didn't realize that was the one you were talking about
18:01:23 <ReinH> but holy shit
18:01:38 <ReinH> edwardk: also this gives me a much better intuition for impule response
18:01:41 <ReinH> which is awesome
18:01:43 <edwardk> yep
18:01:53 <ReinH> OH IT SMOOTHS THINGS DUH
18:02:03 <edwardk> FIR/IIR is a very hard thing for most people without a DSP background to get their head around
18:02:21 <ReinH> edwardk: I've done some DSP, still didn't actually understand what it was
18:02:29 <ReinH> other than a way to manipulate symbols with other symbols
18:02:51 <ReinH> so this is awesome
18:03:07 <edwardk> wittens is looking at doing a writeup on fourier/z/laplace/wavelet transform stuff too
18:03:16 <edwardk> i'm looking forward to that one
18:03:19 <ReinH> orly awesome
18:03:41 <ReinH> edwardk: the z transform stuff was alluded to in the Julia fractals one
18:03:47 <ReinH> I'd love to see a fuller version
18:03:52 <edwardk> ReinH: did you get to part 2 and the deathstar yet?
18:03:52 <ReinH> and wavelets fuck yeah
18:03:58 <ReinH> edwardk: getting there...
18:04:01 <ReinH> no spoilers :p
18:04:05 <edwardk> k =)
18:04:20 <edwardk> good survey of why quaternions are what they are
18:04:23 <monochrom> w00t IIR :)
18:04:49 <monochrom> IIR is mathematically simpler
18:04:51 <edwardk> the summary of why you want the negative lobe in a filter is good too
18:05:13 <edwardk> very good visualization of things that took me years to understand properly
18:06:10 <ReinH> yep
18:14:23 <thoughtpolice> edwardk: btw, what was the name of that geometric algebra paper we were talking about?
18:14:39 <edwardk> http://www.jaapsuter.com/geometric-algebra.pdf
18:14:47 <edwardk> good crash course
18:15:52 <edwardk> it only covers euclidean and homogeneous space though, not conformal GA
18:17:04 <edwardk> if you want to extend it to allow for circles and spheres you need to generalize the quadratic form he plays with a bit
18:17:49 <edwardk> it becomes kinda crazy weird to visualize though
18:21:52 <ReinH> edwardk: I just picked up Computational Geometry Algorithms and Applications :D
18:27:19 <edwardk> i have that in a box here somewhere ;)
18:27:28 <edwardk> i should really unpack my books
18:27:30 <ReinH> I'm sure you do :p
18:27:41 <ReinH> edwardk: and then send me the ones you don't need right now
18:28:04 <ReinH> I will take good care of them and then send them back when I don't need them either :p
18:28:22 <edwardk> ReinH: hah. had you asked me for that a year and a half ago when i was shedding 14 bookshelves. i'd have fired back with an offer to do it for the shipping rate ;)
18:28:30 <ReinH> well shit
18:28:39 <ReinH> I would totally have accepted
18:28:46 <edwardk> now i'm down to more or less what i use
18:29:04 <ReinH> except the ones in boxes somewhere, obv
18:29:10 <edwardk> so just 2 big bookcases full of math and cs
18:29:10 <ReinH> which you should send to me
18:29:16 <edwardk> well, those are the ones in the boxes
18:29:23 <ReinH> which should be on my bookshelf
18:29:27 <edwardk> hah
18:29:30 <ReinH> until you want me to ship them back :p
18:29:37 <johnw> edwardk: have any other good PDFs to recommend?
18:29:44 <edwardk> johnw: re GA?
18:29:46 <ReinH> yes, yes, recommend more pdfs
18:29:50 <johnw> re anything that interests you :)
18:29:55 <ReinH> re anything
18:30:31 <edwardk> http://arxiv.org/pdf/1306.1660v1.pdf talks a bit about analysis in GA
18:30:57 <edwardk> hah. i have er.. a lot of interests =P
18:30:59 <acowley> johnw: You just asked for links to every PDF on the web
18:31:25 <edwardk> acowley++
18:32:46 <edwardk> johnw: it really helps when narrowing the field of study a bit. otherwise you wind up with papers on Rayleigh and multiple Mie atmospheric scattering in the mix =P
18:33:37 <edwardk> http://hal.inria.fr/docs/00/28/87/58/PDF/article.pdf <- told you
18:34:48 <edwardk> johnw: or http://www.paultaylor.eu/ASD/
18:35:01 <johnw> nice
18:35:17 <ski> (:
18:37:12 <edwardk> johnw: i'm also really curious about nice ways to compute montgomery multiplication http://www.csd.uwo.ca/~eschost/Exam/Koc.pdf so i can maybe speed up my parallel crc folds
18:38:24 <edwardk> but that's probably about all i have open at the moment in terms of free association -- other than trying to figure out if there are any non-trivial comonads in the category of profunctors.
18:38:38 <edwardk> i think dolio has me convinced they are all boring
18:38:44 * johnw downloads them all...
18:39:13 <dolio> It definitely looks that way.
18:39:19 <edwardk> johnw: the Koc.pdf one can be understood with the math from the post on parallel CRCs and the links therein
18:39:43 <ReinH> edwardk: oh look, gimbal lock
18:40:09 <ReinH> something something quaternions?
18:40:48 <edwardk> ReinH: of course
18:41:21 <edwardk> its quats or another gimbal. pick your poison ;)
18:41:43 <edwardk> fortunately slerp is easy
18:43:28 <ReinH> yep
18:43:39 <ReinH> edwardk: 3D Math Primer taught me that :D
18:44:19 <edwardk> he does a pretty good job of setting up what quaternions 'look like', but it helps if you've seen the projection he's using for the deathstar before
18:49:16 <BigJ> I am trying to define a function using recursion which will divide a single list into 2 lists as evenly as possible.  I tried to handle the case of the empty list which works but when I input a list of an even number of elements it gets caught at the first restriction...  Anyone help out on how I defined this function wrong?
18:49:18 <BigJ> http://codepad.org/k16yAWgp
18:50:16 <dolio> Why did you define it that way for the empty list?
18:51:40 <BigJ> dolio, I thought that would be the right way to define it
18:52:33 <BigJ> dolio, is this better? divideList [x] = error "Empty List"
18:52:46 <dolio> No, I don't think so. :)
18:52:55 <BigJ> ya that just returned the Tuple with 2 emply lists
18:53:35 <dolio> Yes, but you have a different bug now.
18:55:44 <dolio> Anyhow, if you divide 0 elements amongst 2 lists, I don't see why giving each of the 2 lists 0 elements is not okay.
18:57:00 <BigJ> dolio, yes that is probably a better way to handle it
18:57:53 <dolio> It so happens that if you eliminate  your [] case, that is what the function will do anyway.
18:58:31 <markamber> So I am trying to learn the haskell language, I read lyah and watched some videos and now I am trying to implement a problem in my programming book in haskell. If anyone here has a few moments could you steer me in the right direction. https://gist.github.com/markamber/6767289
19:00:25 <dolio> markamber: Have you learned about list comprehensions yet?
19:00:58 <markamber> dolio: yes I was just uncomfortable using them. But I imagine that can actually be done very ters-ly with one right?
19:01:11 <dolio> Yes, I think they might be nice for this problem.
19:01:34 <dolio> You'd probably have to do the math a little differently, though.
19:05:28 <markamber> dolio: what about something like this from lyah: boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
19:06:54 <dolio> Yes, it would be a lot like that. But since you have nested loops here, you'd have two <- bits.
19:06:56 <dolio> One for each index.
19:07:29 <dolio> Or, actually, I suppose since  you want a list of lists,  you'd nest comprehensions.
19:08:52 <carter> edwardk: ReinH darn thats cool stuff on acko.net
19:13:24 <markamber> dolio: Ok, so I think I know how to do it. Basically I need a list that goes like this [3, 2, 1, 0, 1, 2, 3] How do I use a list comprehension to get one of those? like given a number it has a list of that form of that length
19:15:09 <tromp__> > (\n -> [n,n-1..0]++[1..n]) 3
19:15:10 <lambdabot>   [3,2,1,0,1,2,3]
19:15:45 <markamber> (\n -> [n,n-1..0]++[1..n]) 4
19:15:57 <acomar> anyone familiar with linear: http://lpaste.net/93686
19:15:58 <markamber> how do you get that guy to go
19:16:08 <acomar> not sure how to make reifyDims/reifyVector work
19:16:16 <tromp__> start with >
19:16:19 <markamber> > (\n -> [n,n-1..0]++[1..n]) 3
19:16:20 <lambdabot>   [3,2,1,0,1,2,3]
19:16:27 <markamber> > (\n -> [n,n-1..0]++[1..n]) 4
19:16:28 <lambdabot>   [4,3,2,1,0,1,2,3,4]
19:17:33 <Cale> > (\n -> map abs [-n..n]) 4
19:17:35 <lambdabot>   [4,3,2,1,0,1,2,3,4]
19:18:18 <markamber> so what if I wanted when it was even to be [3, 2, 1, 0, 0, 1, 2, 3] I know I can use pattern matching to isolate that case if need be but would it be like [n-1, n-1..0]++[0..n-1]?
19:18:57 <markamber> > (\n ->[n-1, n-1..0]++[0..n-1]) 4
19:18:59 <lambdabot>   [0,1,2,3]
19:19:40 <markamber> > (\n ->[n-1, n-2..0]++[0..n-1]) 4
19:19:42 <lambdabot>   [3,2,1,0,0,1,2,3]
19:19:58 <markamber> oh ok. Cool thanks for the model
19:20:49 <Cale> only with n in place of the first n-1
19:22:02 <Cale> > [1,1..2]
19:22:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:22:47 <ParaSa1lin> what function are those ranges de-sugared to
19:22:54 <Cale> enumFromThenTo
19:23:11 <ParaSa1lin> @ty enumFromThenTo
19:23:13 <lambdabot> Enum a => a -> a -> a -> [a]
19:23:16 <Cale> enumFrom, enumFromTo, enumFromThen, enumFromThenTo
19:23:20 <ParaSa1lin> ah
19:25:00 <copumpkin> enumThenTo
19:25:02 <copumpkin> enumTo
19:25:46 <startling> how do people feel about this monotraversable thing?
19:26:09 <startling> I feel like lens makes it obsolete, but maybe I'm missing something.
19:26:37 <copumpkin> not a fan at all
19:26:44 <copumpkin> too lazy to get involved though
19:26:57 <edwardk> i think its obsolete in that all of its instances already exist in lens, but meh
19:27:43 <startling> It seems weird and cargo-culty to want to involve typeclasses at all.
19:27:47 <enthropy> redundant might be more appropriate?
19:28:04 <startling> enthropy: yeah, that's would have been better phrasing.
19:28:16 <enthropy> perhaps people who don't use lens will use a monotraversable
19:28:34 <startling> Maybe. But parametrizing things by lenses is more general.
19:28:51 <startling> You don't have to do the stupid newclass multiple-instance trick.
19:29:07 <acomar> edwardk: I'm having some issues making use of reifyDims and reifyVector in Linear.Vector. Do you have some time to take a look? http://lpaste.net/93686
19:29:19 <acomar> *reifyDim
19:30:00 <edwardk> fromMat :: forall c e n m. Mat c e -> CV (V n (V m (ElemT c e)))  -- that doesn't look right to me
19:30:08 <edwardk> that says the result works for all n and m
19:30:13 <edwardk> and i'm betting it works for some n and m
19:30:31 <startling> also the mofu thing makes me giggle.
19:30:32 <edwardk> The answer would be to upgrade your Mat to know about both its dimensions
19:30:32 <acomar> I'm playing with the type to get it to work
19:30:42 <ReinH> edwardk: er. What do reify* do?
19:30:51 <edwardk> Mat m n a -> V m (V n a)   -- or so
19:31:01 <edwardk> :t Data.Reflection.reify
19:31:02 <lambdabot> a -> (forall s. Data.Reflection.Reifies * s a => Data.Proxy.Proxy * s -> r) -> r
19:31:07 <acomar> yea, the problem is that info is only available at runtime :/
19:31:07 <edwardk> :t Data.Reflection.reflect
19:31:08 <lambdabot> Data.Reflection.Reifies * s a => proxy s -> a
19:31:15 <ReinH> huh
19:31:28 <acomar> so one way or another I'm going through reify
19:31:31 <edwardk> acomar: you can model the existential with a continuation passing pattern
19:31:48 <acomar> how so?
19:32:10 <edwardk> acomar: Mat c a -> (forall n m. V n (V m a) -> r) -> r
19:32:20 <edwardk> alternately you can just use Vector. that is what it is for
19:32:23 <acomar> edwardk: ahh, I see
19:32:29 <edwardk> Mat c a -> Vector (Vector a)
19:32:58 <edwardk> ReinH: reify takes a term and makes a type out of it that can be reflected back to get the term
19:33:04 <acomar> can't :/ I'm using Data.Vector.Storable
19:33:24 <edwardk> https://www.fpcomplete.com/user/thoughtpolice/using-reflection
19:33:28 <ReinH> edwardk: I don't really understand that. Will read.
19:33:39 <BMeph> startling: Now go for the trifecta: Make a reifySetter whose type vars spell out ???? s t a b -> a -> m o f u
19:33:44 <edwardk> acomar: use Boxed.Vector (Storable.Vector a)
19:33:56 <acomar> edwardk: I'll look into it, thanks
19:34:44 <edwardk> acomar: that assumes 'import Data.Vector as Boxed'
19:34:47 <ReinH> "On the other hand it's possibly the only Oleg paper I'm aware of which was reduced to, like, 7 lines of code.)"
19:34:50 <ReinH> <3
19:35:03 <acomar> edwardk: right
19:35:09 <BMeph> startling: Or w/e the "mofu" part comes from. ;)
19:35:12 <edwardk> ReinH: it'll soon be reduced to a 'wired-in' in ghc and 3 lines of code
19:35:46 <edwardk> that'll make it guaranteed safe
19:35:47 <ReinH> orly
19:35:52 <ReinH> well that's cool
19:36:32 * thoughtpolice should get on that or something
19:37:19 <ReinH> > import Unsafe.Coerce
19:37:21 <lambdabot>   <hint>:1:1: parse error on input `import'
19:37:22 <ReinH> "And so it begins"
19:38:00 <edwardk> thoughtpolice: i'm willing to take a whack at the wired in
19:38:16 <zbcm_> lol, learning Haskell because I wanted to try functional programming. I love how there is a function called words that does what it does.
19:38:32 <thoughtpolice> edwardk: sure, but I want to as well :P
19:38:35 <edwardk> thoughtpolice: mostly need to figure out if we need to wire in a dictionary type as well.
19:38:54 <thoughtpolice> right, that's kind of what I was wondering
19:38:56 <dwcook> zbcm_, just as well, there's a function called unwords that undoes what it does :)
19:38:59 <edwardk> thoughtpolice: fair nuff. all yours. if you get stuck feel free to fire questions
19:39:04 <BMeph> zbcm_: If you like that, check out "unwords"... ;)
19:39:10 <dwcook> > unwords . words $ "Hey Jude, don't make it bad"
19:39:12 <lambdabot>   "Hey Jude, don't make it bad"
19:39:22 <zbcm_> haha
19:40:35 <startling> zbcm_: there's "lines"/"unlines", too
19:41:17 <markamber> (Ord a) a -> a -> a returns lowest input?
19:41:29 <markamber> (what is the name of it)
19:41:37 <dwcook> > min 5 10
19:41:38 <lambdabot>   5
19:41:57 <dwcook> @type min
19:41:57 <lambdabot> Ord a => a -> a -> a
19:42:02 <markamber> dwcook: thanks, I was searching google for minimum, that one was for lists
19:42:20 <dwcook> markamber, better yet, search Hoogle
19:42:28 <dwcook> @hoogle Ord a => a -> a -> a
19:42:29 <lambdabot> Prelude max :: Ord a => a -> a -> a
19:42:29 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
19:42:29 <lambdabot> Prelude min :: Ord a => a -> a -> a
19:43:14 <startling> hoogle shows the same thing from multiple places? that's so bad.
19:43:30 <dwcook> startling, what should it do instead?
19:44:56 <startling> show the place where it was defined, if that place is not hidden by the package.
19:45:46 <dwcook> startling, the web interface doesn't show separate entries, it simply remarks it can be found in both places.
19:45:54 <dwcook> So it seems a problem with lambdabot's command?
19:45:55 <startling> oh, got it. so it's just @hoogle
19:47:54 <ReinH> edwardk: with (Monoid (+) 0) $ mempty <> Lift 10 <> Lift 12 -- evaluates to 22
19:47:56 <ReinH> wat
19:48:09 <ReinH> well that is magical
19:48:11 * hackagebot th-desugar 1.1.1 - Functions to desugar Template Haskell  http://beta.hackage.haskell.org/package/th-desugar-1.1.1 (RichardEisenberg)
19:48:21 <edwardk> ReinH: yep
19:48:53 <ReinH> oh using
19:48:55 <ReinH> holy crap.
19:49:01 <elliott> DON'T USE USING.
19:49:05 <ReinH> OK.
19:49:09 <ReinH> :(
19:49:09 <elliott> thanks.
19:49:16 <ReinH> why not?
19:49:28 <elliott> well, it's actually unsafe.
19:49:36 <edwardk> its evil. reify/reflect is sound
19:49:41 <ReinH> ah
19:49:57 <edwardk> using was a result of a late night bender
19:49:59 <ReinH> hah
19:50:55 <startling> :t using
19:50:56 <lambdabot> Not in scope: `using'
19:50:56 <edwardk> you know that feeling when you wake up in the morning, and your teeth feel fuzzy, you don't know where you've been, but you strongly suspect in 9 months someone will be calling you for library support?
19:51:09 <ReinH> edwardk: oh god
19:51:16 <startling> oh, I'm thinking of "use"
19:51:47 <sclv> where is using?
19:52:15 <edwardk> oh, its 'give' that i'm thinking of
19:52:22 <edwardk> not using
19:52:53 <sclv> ok where is give?
19:52:55 <startling> where is "give"?
19:52:56 <sclv> where are either?
19:52:57 <startling> yeah.
19:53:00 <startling> :t either
19:53:00 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:53:05 <sclv> ok either i know :-P
19:53:07 <edwardk> using is fine
19:53:07 <startling> :)
19:53:11 * hackagebot hashtables 1.1.2.0 - Mutable hash tables in the ST monad  http://beta.hackage.haskell.org/package/hashtables-1.1.2.0 (GregoryCollins)
19:53:25 <edwardk> sclv: http://hackage.haskell.org/package/reflection-1.3.2/docs/Data-Reflection.html#v:give
19:53:37 <lulzplzkthx> edwardk: hahaha
19:53:53 <lulzplzkthx> the 9 month quote :)
19:53:57 <edwardk> =)
19:54:32 <markamber> what would be the most beautiful version of ((min 5 9) - 1) `div` 2
19:54:50 <sclv> @remember edwardk you know that feeling when you wake up in the morning, and your teeth feel fuzzy, you don't know where you've been, but you strongly suspect in 9 months someone will be calling you for library support?
19:54:51 <lambdabot> Done.
19:54:51 <dwcook> markamber, 2, of course
19:55:08 <markamber> ((min a b) - 1) `div` 2
19:55:13 <dwcook> :)
19:55:19 <markamber> I had my test variables in still
19:55:34 <dwcook> That looks fine to me as it is
19:55:55 <dwcook> Oh, lose the outermost parens
19:56:02 <dwcook> (min a b) - 1 `div` 2
19:56:16 <dwcook> Heck, lose them all
19:56:21 <dwcook> min a b - 1 `div` 2
19:56:27 <markamber> dwcook: Ok. I am just always unsure
19:56:31 <dwcook> woops
19:56:35 <dwcook> Never mind
19:56:56 <dwcook> I was mistaken about the precedence of something
19:57:00 <dwcook> Your original is fine
19:57:24 <dwcook> You *can* lose the inner parens, since function application binds more tightly than any operator
19:57:35 <startling> prec (min a b) `div` 2
19:57:50 <dwcook> s/prec/pred/
19:58:00 <startling> oops, typo
19:59:03 <dwcook> @pl \a b -> prec (min a b) `div` 2 -- just for laughs
19:59:07 <lambdabot> flip (flip . (div .) . (prec .) . min) 2
19:59:07 <lambdabot> optimization suspended, use @pl-resume to continue.
19:59:18 <dwcook> woops
19:59:24 <dwcook> Made the same typo :P
19:59:36 <startling> 8)
20:00:15 <dwcook> @pl-resume
20:00:21 <lambdabot> flip (flip . (div .) . (prec .) . min) 2
20:00:21 <lambdabot> optimization suspended, use @pl-resume to continue.
20:00:32 <dwcook> I guess that won't get any more optimized
20:01:13 <startling> the @pl-resume thing is a bug iirc.
20:01:31 <dwcook> I do wonder why 2 is applied at the end and not directly to div.
20:08:46 <startling> I want a data language to use with Haskell code that has references and, ideally, provides a nice way to deal with data separated across multiple files. Any ideas?
20:08:58 <ReinH> > let f = div (min a b - 1) in f 2
20:09:00 <lambdabot>   (min a b - 1) `div` 2
20:09:20 <ReinH> > let f a b = div (min a b - 1) in f 1 2 3
20:09:22 <lambdabot>   0
20:10:07 <startling> ReinH: fun mistake.
20:10:20 <ReinH> I think div (min a b - 1) 2 is reasonable and makes the precedence more clear
20:12:37 <ReinH> also easy eta reduction to f = div (min a b - 1)
20:12:50 <ReinH> or f a b
20:14:11 <theWinner> can someone explain the difference between lenses and partial lenses
20:14:36 <theWinner> conceptually, that is
20:15:25 <edwardk> using the lens package or something else?
20:15:48 <startling> "partial lens" usually means "this lens follows the lens laws only for specific inputs"
20:15:52 <startling> for the lens package at least
20:15:54 <edwardk> lens doesn't provide a notion of a 'partial lens', it does however provide the notion of a 'traversal', which can play the same role.
20:16:10 <edwardk> classically a partial lens would just blow up in your face when you went to use it in a bad way
20:16:31 <theWinner> so a partial lens is like a lens, but without totality?
20:16:32 <markamber> http://lpaste.net/93688 a problem I am having
20:16:52 <theWinner> EG - it's not a total function
20:17:10 <edwardk> with the lens package, we instead prefer to use the notion of a lens that may have 0 targets. this restores totality, but requires you to use other combinators to manipulate them
20:17:22 <startling> theWinner: it depends on the context I guess
20:17:27 <edwardk> > Left 4 ^? _Left
20:17:28 <lambdabot>   Just 4
20:17:31 <edwardk> > Right 4 ^? _Left
20:17:33 <lambdabot>   Nothing
20:17:38 <edwardk> notice it is total, but it can fail
20:17:40 <startling> it's a similar idea, though
20:17:45 <theWinner> I'm not a haskell user, so I'm just trying to understand the conceptual difference
20:18:05 <theWinner> I did a google trying to find an explanation of partial lenses, and found nothing, interestingly
20:18:08 <startling> I'm not sure you can understand lenses in a useful way without using haskell.
20:18:12 * hackagebot bencoding 0.4.0.0 - A library for encoding and decoding of BEncode data.  http://beta.hackage.haskell.org/package/bencoding-0.4.0.0 (SamTruzjan)
20:18:24 <theWinner> I'm doing pure functional programming in F# with lenses
20:18:28 <edwardk> theWinner: well, other libraries have tried shoe-horning some kind of monad into the mix and then saying Maybe can make it so the monad can fail, but nobody can tell me the laws for what lenses with monads in the middle mean
20:18:32 <Malar> is there any ongoing effort to port ghc to Parallella hardware  [ http://shop.adapteva.com/ ] ?
20:18:48 <edwardk> theWinner: so as far as i'm concerned partial lenses are an ill-defined concept =P
20:19:06 <carter> Malar: nope, you can do it though
20:19:17 <startling> :)
20:19:20 <theWinner> I have a bunch of lenses that throw for bad input, so I'm just wondering if that makes them partial
20:19:30 <arkeet> Malar: ajhc targets arm
20:19:30 <edwardk> the notion of an 'affine traversal' which is a traversal of at most one element, on the other hand is well-defined. it does come with the caveat that the checking of bad input doesn't fit that paradigm
20:19:33 <startling> theWinner: what's "throw" in this case?
20:19:35 <arkeet> Malar: that might interest you
20:19:42 <startling> language-level exceptions?
20:19:51 <carter> Malar: i'm more interested in making sure that ghc runs well on the 50 core intel chips landing in another year or so
20:19:51 <arkeet> well, ghc targets arm too
20:19:56 <carter> lots of llvm things
20:19:59 <arkeet> but ajhc is more for embedded things I guess
20:20:06 <theWinner> ah, hard to explain
20:20:59 <edwardk> theWinner: lots of things fail to meet the condition of 'being a lens' or 'being a traversal'. something that checks conditions on update sadly falls into that territory. you can make combinators that do that that work with lenses/traversals, etc, but something that can check its input can't meet the laws
20:21:13 <theWinner> so, there's no partial lenses, only broken lenses :)
20:21:21 <carter> arkeet: ajhc uses c right?
20:21:44 <arkeet> I believe so
20:21:44 <theWinner> ya, I have lots of lenses with input checks
20:21:52 <edwardk> theWinner: basically. we can have affine traversals, which are 'partial', but only partial on retrieval, but insert
20:22:01 <theWinner> half of them do checking, the others don't and are total
20:22:20 <theWinner> unfortunately, I have no grasp of traversals at this point
20:22:56 <theWinner> coming from  F#
20:23:00 <startling> Do F# programmers usually use concepts like traversal and applicative?
20:23:05 <edwardk> what we do tend to do is to use 'improper lenses' which go and normalize the input for you rather than reject it. those hit a slightly more sensible point on the spectrum of all things lens-like
20:23:08 <theWinner> we use applicatives a lot
20:23:08 <elliott> F# doesn't have HKP.
20:23:16 <edwardk> startling: sadly no
20:23:17 <elliott> traversals sound hard to express.
20:23:19 <Malar> carter: this one is cheaper :P , arkeet: ajhc is interesting
20:23:19 <theWinner> but only in specific ways
20:23:22 <edwardk> startling: they can't write the types down
20:23:27 <theWinner> ya
20:23:33 <startling> edwardk, :/
20:23:47 <startling> what's an F# lens, then?
20:23:52 <edwardk> startling: which means that you can't write anything non-trivial that way. inlining the type checking on works so far
20:23:56 <edwardk> startling: a pile of crap ;)
20:24:03 <monochrom> markamber: you are doing [ [x-xs | x<-joy] | xs<-fun ], which is clearly [[Int]], but you lie that it's [Int]. have you considered: [x-xs | x<-joy, xs<-fun]
20:24:11 <edwardk> startling: you can get about as far as my old scala talk on lenses
20:24:20 <edwardk> startling: you can upgrade it with a few more things, but thats about it
20:24:24 <theWinner> Here's lenses as I use them - http://bugsquash.blogspot.com/2011/11/lenses-in-f.html
20:24:36 <startling> are they just getter/setter pairs with new names?
20:24:48 <theWinner> pretty much
20:24:51 <markamber> monochrom: I think I get it now, one sec while I try
20:25:03 <startling> theWinner: :/
20:25:13 <theWinner> It works fine AFAIK tho
20:25:44 <theWinner> I haven;t _needed_ type classes in F# yet, and I've programmed a lot of F# code
20:26:04 <theWinner> we just do things with slightly less closure
20:26:11 <theWinner> EG - interfaces
20:26:23 <theWinner> well, a lot less closure
20:26:50 <theWinner> still, my program's types are pretty closed for reasoning about
20:27:12 <edwardk> theWinner: i never realized quite how popular my lens stuff in scalaz was. tripping over a lot of tutorials now
20:27:41 <startling> theWinner, OK. so it looks like our concept of lenses is a little different from your concept of lenses. So maybe we're not the best people to ask.
20:28:01 <theWinner> unfortunately, F# room is basically dead :(
20:28:21 <startling> to me, "partial lens" means "fails on some input, or fails to obey the lens laws on some input"
20:28:21 <theWinner> and even if it were lively, few of them understand those concepts
20:28:24 <edwardk> theWinner: probably #scalaz would be a better forum. the notion of a lens-style lens is several orders of magnitude more complicated than the ones i wrote for scalaz that the the fsharpx ones seem to be based on
20:28:42 <theWinner> ew scala :P
20:28:49 <startling> theWinner, do you guys talk about lens laws?
20:29:17 <theWinner> I know of them, haven't talked to many F# programmers that do
20:29:25 <startling> :/
20:29:37 <theWinner> so that's why I usually come to #haskell to ask these types of conceptual questions
20:30:01 <cmears> Speaking of lenses, can someone tell me why Control.Exceptions.Lens.throwing has type "AReview s SomeException a b -> b -> a" and not "AReview s SomeException a b -> b -> anyoldtype" ?
20:30:34 <edwardk> :t Control.Exception.Lens.throwing
20:30:35 <lambdabot> AReview s SomeException a b -> b -> a
20:30:54 <edwardk> cmears: guessing typo
20:30:57 <edwardk> cmears: let me check
20:31:03 <cmears> cool, that's what I thought (hoped)
20:31:32 <cmears> (same for throwingM too)
20:31:52 <theWinner> but in defense of the F#, I guess for me the main thing I need out of a type system is closure, and that's what F# gives me for the most part
20:32:16 <theWinner> but, i'm just a game programmer, so maybe that's not sufficient for other domains
20:32:22 <edwardk> cmears: yep. its just an accidental capture problem
20:33:21 <cmears> edwardk, great, thanks for your help (:
20:33:48 <theWinner> I like linear type systems tho
20:34:13 <theWinner> I am looking forward to a popular language with a type system based on linear logic
20:34:33 <theWinner> at least one that you can opt into where you need it
20:35:04 <startling> Rust sorta does it.
20:35:41 <theWinner> I also like uniqueness types
20:36:20 <markamber> How do I print a list of lists as lines of output?
20:36:27 <theWinner> Rust is so ugly tho :/
20:36:33 <theWinner> and imperative :P
20:37:02 <startling> :t mapM_ putStrLn
20:37:03 <lambdabot> [String] -> IO ()
20:37:17 <theWinner> what do you haskellers thing of rust?
20:37:21 <theWinner> *think
20:38:00 <monochrom> I think of rust as a character name in Ocean's Eleven-Thirteen. actually it may be rusty.
20:38:13 <startling> markamber, is that what you were looking for?
20:38:19 * hackagebot bencoding 0.4.0.1 - A library for encoding and decoding of BEncode data.  http://beta.hackage.haskell.org/package/bencoding-0.4.0.1 (SamTruzjan)
20:38:21 <startling> monochrom, no, no, rust is the iron oxide
20:38:26 <markamber> startling: I think so
20:38:40 <monochrom> that too, but too boring :)
20:39:52 <startling> theWinner: it's a nice step but perhaps not a big enough one.
20:41:40 <theWinner> hm, ya I feel the same way
20:41:47 <theWinner> too much legacy thinking left in it
20:43:33 <__jim__> I have a TCO question
20:44:09 <__jim__> I have been using Scala for a few months, and Haskell more recently, and I typically write my functions in a way that allows the function to be a tail call.
20:44:19 <__jim__> As I understand it, the compiler usually makes this a loop
20:44:40 <__jim__> Does that mean there is some mutable variable in the compiled code then?
20:45:28 <monochrom> there are mutable variables in compiled code, but not meant by TCO.
20:46:34 <edwardk> cmears: shipped 3.9.2 with the throwing/throwingM fixes
20:47:04 <startling> __jim__, TCO has nothing to do with it, but yes, haskell compilers are allowed to create code that uses mutation
20:48:02 <monochrom> mutable variables are used because mutable variables are approximately the only thing the hardware provides. the hardware basically says, "mutable variables or get lost". what could you possibly do.
20:48:19 * hackagebot bencoding 0.4.0.2 - A library for encoding and decoding of BEncode data.  http://beta.hackage.haskell.org/package/bencoding-0.4.0.2 (SamTruzjan)
20:48:21 * hackagebot lens 3.9.2 - Lenses, Folds and Traversals  http://beta.hackage.haskell.org/package/lens-3.9.2 (EdwardKmett)
20:48:32 <joelteon> oo, 3.9.2
20:48:32 <__jim__> that's true
20:48:36 <theWinner> all variables may eventually end up in registers, and registers are always mutable
20:48:44 <__jim__> true true
20:49:00 <edwardk> joelteon: pretty minor bugfix update
20:49:09 <joelteon> aw
20:49:10 <edwardk> joelteon: 3.10 is still waiting n the wings
20:49:16 <__jim__> I guess I am just wondering how the compiler, which provides so many optimzations, guarantees the code to be safe
20:49:18 <monochrom> recall that the stack is yet another huge pile of mutable variables. therefore, not doing TCO does not eliminate mutable variables. far from it.
20:49:26 <__jim__> sure
20:49:51 <cmears> edwardk, great, thanks!
20:49:52 <__jim__> I also suppose at some point you need to trust the compiler implementation as well
20:50:36 <theWinner> so, I'm writing a purely functional 2D game engine
20:50:43 <theWinner> the gui system is also purely functional
20:51:05 <theWinner> kinda neat, but the perf worries me
20:51:12 <startling> __jim__: it's a hard problem.
20:51:15 <theWinner> tho I have not yet run any perf metrics
20:51:24 <theWinner> anyone done anything similar?
20:51:33 <startling> but any non-safe code produced by GHC would be a pretty serious GHC bug.
20:52:41 <__jim__> sure
21:00:34 <markamber> I think the program is done. But would someone look over it and ensure it is minimal and in good haskell form? Like is there somewhere I can cut down or is there a better way to do something. I am just learning this so I want to use the best practices: http://lpaste.net/93691
21:02:34 <startling> markamber, you shouldn't mix your output data with error reporting
21:03:04 <startling> markamber: also line 9 is unreadable. put some spaces around those operators, and I suspect you can avoid repeating yourself some.
21:03:45 <carter> latermuse: yay!
21:04:51 <startling> markamber: wait, why is makeArt's return type [String] and not String?
21:05:05 <startling> Looks like the list always has one member.
21:05:26 <shachaf> Linear lists!
21:05:46 <monochrom> I think one case does not. but that can be easily cured by a concat.
21:06:19 <startling> monochrom: oh, you're right.
21:06:24 <startling> I misparsed.
21:10:00 <markamber> startling: Ok, the type is [string] because it is actually one string per line. I will fix the error thing, and how would you rewrite that line?
21:10:21 <startling> markamber: I don't know, I don't understand it (and I'm not going to put much effort into it)
21:10:38 <markamber> startling: are you sure you didnt mean line 8?
21:10:42 <shachaf> You should write [String] instead of [string] if that's what it is.
21:10:50 <shachaf> Those are very different things.
21:11:49 <startling> markamber: oh, yes, I mean line 8
21:11:52 <monochrom> did you know:
21:12:09 <monochrom> > unlines ["hello", "kitty", "ken"]
21:12:11 <lambdabot>   "hello\nkitty\nken\n"
21:12:31 <pqmodn> markamber: read about the Either data type
21:13:14 <markamber> pqmodn: what would that do? I know kind of what it does.
21:13:33 <pqmodn> markamber: distinguish error results from success results
21:14:26 <markamber> pqmodn: ok, I remember reading that was a use for it before. I will have to look in to that later.
21:16:31 <markamber> startling: so how would you clean up this line [n, n-1..0]++replicate (w-(2*n)-1) 0++[1..n]] that one makes a list that looks something like this [4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4] in that case the replicate was used a few times to make all those zeros
21:17:00 <startling> markamber: to be honest I zoned out at like "clean"
21:17:12 <startling> I am not the best person to be asking this to at this hour.
21:17:48 <copumpkin> > ap (++) reverse [3,2,1,0]
21:17:49 <lambdabot>   [3,2,1,0,0,1,2,3]
21:17:55 <joelteon> maaan, you did it first
21:19:08 <markamber> Then !startling how would you clean it up
21:20:34 <pqmodn> markamber: if you seek a pleasant peninsula, look above you
21:20:37 <argiopeweb> markamber: I'd build the lists in a let block and append them separately.
21:21:05 <argiopeweb> I'd also take advantage of copumpkin's example for the front and back.
21:21:30 <argiopeweb> (though it won't work directly as written)
21:22:34 <markamber> oh so let blabla = 3, 2, 1, 0 let mid = 0, 0, 0 then blabla + mid + reverse blabla?
21:23:38 <markamber> what about the where?
21:24:38 <leroux> markamber: copumpkin pointed out a solution.
21:24:45 <leroux> > ap (++) reverse [3,2,1,0]
21:24:46 <lambdabot>   [3,2,1,0,0,1,2,3]
21:26:12 <markamber> leroux: I don't exactly know if that is what I want because sometimes there are more 0s at the end it is not always just two zeros
21:26:28 <copumpkin> what are you actually trying to do with these palindromes?
21:27:49 <markamber> copumpkin: trying a problem in my java programming book in haskell and attempting to learn haskell. the palindrome basically maps out some ascci art
21:28:22 <copumpkin> I'm just trying to see if there's a better solution that attacks your problem at a higher level than what you've presented to us
21:29:27 <markamber> copumpkin: I bet there is. basically I am making artwork stuff. you can see the gist I made here and look at the desired output. https://gist.github.com/markamber/6767289
21:29:42 <markamber> copumpkin: it is the third gist on that page
21:29:45 <copumpkin> aha, I see
21:31:39 <copumpkin> why are you counting in your haskell stuff though?
21:31:54 <copumpkin> and not just emitting dots and Xs?
21:32:19 <markamber> so those palindromes basically say when there is going to be a . and when an x. if the number is positive it is , and if it is <=0 it is an x. so really I have no idea why I am counting. but it worked in my head
21:32:45 <copumpkin> ah :)
21:34:58 <WingbeatPony> Got a question about cross compiling. I've got a debian install of the haskell platform, and I'd like to target Tiny Core Linux (9MB total!) but I don't know what I need to achieve this
21:35:51 <WingbeatPony> The wiki outlines it all, I'm sure, but I couldn't make much sense of it
21:35:52 <argiopeweb> markamber: As someone who once TA'ed a Java lab for several years, that's an inane problem even by Java lab standards.
21:36:21 <markamber> argiopeweb: what exactly do you mean
21:36:53 <WraithM> Is there a better way of writing this?: update heap a n = heap { objects = M.insert a n (objects heap) }
21:36:58 <WraithM> heap is a record.
21:37:09 <WraithM> with a map element objects
21:37:39 <argiopeweb> markamber: What could one possibly gain from this exercise? It far exceeds the level of complication necessary to teach loops, and it doesn't incorporate any more complicated concepts that I can tell.
21:39:26 <markamber> argiopeweb: I guess I can't argue with that, but I already found out how to do it in java and im having fun learning haskell. It is really stupid. All the rest of our problems are much easier
21:39:30 * monochrom has a cunning plan! render the complete diamond (render the 4 line segments, then fill the polygon), then clip.
21:39:51 <argiopeweb> monochrom: Clever.
21:40:11 <argiopeweb> monochrom: Though it does seem to change size based on width.
21:40:47 <markamber> monochrom: I always wanted to do it that way. I thought of like bringing in little diagonal virtual period thingys untuil they touched. Then I couldnt get it.
21:40:54 * markamber is switching devices
22:05:04 <RommelVR_> hey all :)
22:05:11 <RommelVR_> argiopeweb: you around :P
22:05:12 <RommelVR_> ?
22:05:23 <argiopeweb> RommelVR_: Quite. What's up?
22:06:03 <RommelVR_> argiopeweb: Not sure why this doesn't compile, I'll post an extended error message in the comment of the gist in a sec. Ref https://gist.github.com/RommelVR/e2b9248a83b3d7184e60#file-gistfile1-hs-L26-L27
22:06:44 <RommelVR_> posted comment
22:07:23 <argiopeweb> RommelVR_: Well, that's quite a complexity increase from last night...
22:08:17 <RommelVR_> argiopeweb: haha yeah... I needed it, the vadd (x1,y1,z1)(x2,y2,z2) style functions were not scaling at all :/
22:08:43 <RommelVR_> I needed overloading for the math side of the code to actually be legible
22:09:12 <argiopeweb> RommelVR_: Mmm, they wouldn't tend to. Lenses could probably help you with that by providing Traversible instances for tuples, but that might be a bit extreme at this point.
22:11:58 <argiopeweb> RommelVR_: Removing the type signature gives the error, "No instance for Vector Scalar arising from use of 'vnorm'"
22:14:14 <RommelVR_> Possible fix: add an instance decl. for (Vector Scalar)
22:14:30 <argiopeweb> RommelVR_: Essentially, you need a way to convert a scalar to a vector. Your "works fine" line works fine because it's running through vscale (which takes a Scalar and a Vector and returns a Vector). The other line is trying to multiply a vector and a scalar directly, which doesn't make sense.
22:14:37 <joelteon> why are there octal literals but not binary literals
22:15:05 <RommelVR_> argiopeweb: yet, if I load up ghci, I can do (Vector3 2 2 2) * 5 no problem
22:16:21 <NemesisD> i've got some pure code that uses some unsafe operations: head, unsafe vector lookup, but it has guards that should make it total
22:16:26 <argiopeweb> RommelVR_: Because you gave Vector3 a Num instance and GHCI implicitly wraps all numeric values with "fromInteger"
22:16:31 <argiopeweb> (well, all integer values)
22:16:44 <NemesisD> is there a way i could use quickcheck to verify that my code doesn't error on any input
22:17:50 <RommelVR_> argiopeweb: is there a way I can say that Vector will always have a Num instance?
22:19:15 <NemesisD> the only thing i could think of is property $ \s -> myBoolFunction s || True
22:19:25 <argiopeweb> RommelVR_: class Num v => Vector v where ...
22:19:41 <RommelVR_> sweet, fixed it :S
22:19:55 <RommelVR_> or not nvm (idiot mistake)
22:20:01 <argiopeweb> Though it won't help you in this particular case since you're trying to convert a Double to Vector
22:20:50 <RommelVR_> how is that I'm trying to do convert double to a vector?
22:21:16 <RommelVR_> shouldn't be doing fromRational?
22:22:04 <arkeet> RommelVR: the two arguments to * have to have the same type
22:22:05 <arkeet> :t (*)
22:22:06 <lambdabot> Num a => a -> a -> a
22:22:34 <RommelVR_> arkeet: right, so that is why its converting Double -> Vector3
22:22:39 <arkeet> it's not converting
22:22:43 <argiopeweb> RommelVR_: And in your case they have types Vector3 and Scalar, respectively.
22:23:18 <argiopeweb> (I misspoke regarding Double).
22:23:37 <NemesisD> looks like i could use Control.Spoon... called that for reasons
22:28:34 <RommelVR_> argiopeweb: any suggestions then? I just need to do some vector math :S, I'm open to anything (albeit, less complexity the better so I can learn it haha)
22:30:18 <argiopeweb> RommelVR_: timesScalar = flip vscale
22:30:34 <argiopeweb> RommelVR_: Then you can do v `timesScalar` (1 / vnorm v)
22:31:24 <RommelVR_> right, but what about in my actual code, I don't want to be writing `timeScalar` everywhere :S
22:31:44 <RommelVR_> ideally I need that Vec * Scalar/Num/Literal overload
22:33:00 <argiopeweb> RommelVR_: Off the top of my head, that requires a data Vector = Scalar | Vector1 | Vector2 | Vector3 ...
22:33:41 <argiopeweb> Seems like something that might benefit from data families, but I honestly don't know enough about them to discuss.
22:34:03 <RommelVR_> hmmm, I'll keep googling around then
22:34:34 <RommelVR_> I wouldn't think this is a haskell limitation, seeing as it atleast somewhat possible, just likely my lack of knowledge of how to bend the type system :P
22:35:12 <argiopeweb> RommelVR: Actually... You could make a Real instance for Scalar, then use a wrapper around fromRational . toRational.
22:36:35 <argiopeweb> RommelVR_: Which is in the standard libraries as `fromRealFrac`
22:36:53 <argiopeweb> Still requires an annotation, but it's better than overloading times.
22:37:09 * argiopeweb is tired
22:37:16 <argiopeweb> I mean creating a new timesScalar function.
22:38:28 <RommelVR_> hahaha, argiopeweb: massive help man, I'll check it out, but not sure what you mean by instance for Scalar, afaik its not a class? just a type?
22:40:07 <argiopeweb> RommelVR_: Heh, just noticed that... As mentioned, tired. `v * (fromRational $ toRational $ 1 / vnorm v)` works, though you need vunit :: (Vector v, Fractional v) => v -> v as the type
22:41:10 <RommelVR_> lol, I tried that, ableit withtout the toRational :S
22:41:25 <RommelVR_> I assumed Scalar (aka Double) was a Rational?
22:41:42 <argiopeweb> Nope. Try :i Double in GHCI
22:41:50 <argiopeweb> :i Double
22:42:01 <argiopeweb> Bah, can't remember the lambdabot command.
22:42:15 <pqmodn> @info Double
22:42:15 <lambdabot> Double
22:42:18 <pqmodn> yay!
22:42:22 <argiopeweb> Useful...
22:42:26 <RommelVR_> oh right
22:43:51 <RommelVR_> It says Double is Fractional?
22:44:26 <argiopeweb> RommelVR: Yes. That just gives you fromRational (turn a Ratio into a Double)
22:44:42 <argiopeweb> > fromRational (1 % 2) :: Double
22:44:44 <lambdabot>   0.5
22:45:25 <argiopeweb> RommelVR_: Underscore version, even. Too many versions of you.
22:45:25 <RommelVR_> still not sure why I have to go toRational
22:45:50 <argiopeweb> RommelVR: Because Scalar == Double, and Double isn't a Rational.
22:46:21 <argiopeweb> And the only way you have of turning a Double into a Vector3 to multiply it is to go through Rational.
22:46:25 <ParaSa1lin> @src fromRational
22:46:25 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:46:30 <ParaSa1lin> @src (%)
22:46:30 <lambdabot> x % y = reduce (x * signum y) (abs y)
22:46:36 <argiopeweb> (unless you write something specifically, of course)
22:48:01 <WingbeatPony> Trying again: can anyone help me figure out how to make ghc available in a version of linux there isn't already a build of ghc for?
22:48:31 <begriffs> WingbeatPony: which Linux?
22:48:36 <argiopeweb> WingbeatPony: All I can do is point you to the article on Trak, and I'm pretty sure you mentioned reading it earlier.
22:49:05 <WingbeatPony> Tiny Core linux. It'd be awesome (running stuff on a 9MB system) but I know zilch about cross-compiling
22:49:39 <argiopeweb> WingbeatPony: You realize that most linked executables coming out of GHC are quite a bit larger than 9MB, yes?
22:50:21 <WingbeatPony> argiopeweb: Oh of course. The point is it'd be running on the most minimal system imaginable because I am an insane person
22:50:42 <argiopeweb> WingbeatPony: I run Gentoo on all my systems. I understand that mindset.
22:51:13 <WingbeatPony> And also because, more practically, I'd like to be able to build haskell programs that can fit on embedded systems without ~300MB of what I can cram debian into
22:51:24 <argiopeweb> This said, 9MB must be a 2.4 kernel system, yes?
22:51:46 <WingbeatPony> Without looking it up I'm not sure I'd be able to answer that
22:51:50 <argiopeweb> WingbeatPony: Ah, this I can help with (assuming I can find the link I was reading last week)
22:52:11 <begriffs> Does anyone know how I can set the library search path when compiling with GHC? I am trying to compile cabal and it's all good until I get to the linking stage. "/usr/bin/ld: cannot find -lgmp"
22:52:38 <begriffs> My libgmp.so lives in a nonstandard place (/app/vendor/ghc-libs)
22:52:56 <WingbeatPony> begriffs: not ideal, but you could try symlinking it
22:53:44 <RommelVR_> argiopeweb: is there some way I can just overload the + operator?
22:54:13 <argiopeweb> RommelVR: You can hide Num and override it, but it probably isn't recommended.
22:54:43 <lieven_> begriffs: you can export LD_LIBRARY_PATH
22:56:00 <WingbeatPony> argiopeweb: There's a good chance I'm using kernel 3.8.10 (maybe we should move this conversation to pm?)
22:57:03 <akegalj> WingbeatPony, others: have you heard, used HaLVM https://github.com/GaloisInc/HaLVM ?
22:57:40 <WingbeatPony> not heard of it, I'll take a look
23:01:52 <RommelVR_> argiopeweb: :(
23:03:01 <argiopeweb> RommelVR_: You could look into type families and data families. They might help (though I make no promises). My personal preference would be `timesScalar`, since it makes it clear what you're doing.
23:03:09 <apples> does anyone know of a good explanation of what codata is?
23:04:55 <startling> tac's blog has a nice post
23:05:24 <startling> I can't find it though.
23:05:31 <startling> apples: in haskell it doesn't mean much.
23:05:53 <apples> well, i'm also interested in what it means outside of haskell, if that helps
23:06:38 <startling> apples, there's http://blog.sigfpe.com/2007/07/data-and-codata.html , too
23:07:16 <apples> thanks, i'll give that a read
23:09:48 <letrec> In a do block, I'd like to do an IO operation and then update an internal state. Can I still use runState? Or should I move away from State and handle the state on the fly by passing it back at the end of the do block?
23:10:20 <letrec> I don't understand how the compiler can say whether a do block is related to IO or State or ... ?
23:11:43 <argiopeweb> letrec: Do is just syntactic sugar. It desugars to use >> and >>=, so the standard type inference on typeclasses takes care of it.
23:13:00 <argiopeweb> letrec: As for the rest of your question, that depends a lot on what you're trying to accomplish. I'm honestly too tired to be of much help there at this point.
23:14:06 <startling> letrec, Haskell has an overloading mechanism called "typeclasses"
23:15:06 <pqmodn> @undo do { x <- f ; g x }
23:15:06 <lambdabot> f >>= \ x -> g x
23:16:00 <pqmodn> the types of arguments given to >>= let the compiler resolve the typeclass instance
23:16:13 <pqmodn> @type (>>=)
23:16:14 <MasseR> I recently wrote a simple application that uses sockets for communication. The communication happens with hPutStrLn . show and readMay <$> hReadLine. The grammar is a single adt. I bolt it together like so: {_ <- askHello; _ <- anwerHello; (Foo x) <- askFoo; _ <- answerOk}. show and readMay give me somewhat type assurance, but I have a feeling this could be made better, but I'm not sure where to look at
23:16:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:17:55 <letrec> Ok so from the responses below I understand that a do block will only relate to a single m.. So looks like mixing IO and State isn't easy. I will handle the state manually. Thx
23:18:27 <pqmodn> letrec: read about monad transformers for combining monads (eg IO and State)
23:18:47 <kamatsu> alternatively, in IO there is IORefs, that sometimes are a bit more convenient than StateT IO
23:23:49 <Gracenotes> yeah... with State s, you perform some pure computation and go from old state to new state. with StateT s IO, the computation can be IO instead.
23:24:43 <Gracenotes> but the state management is still pure, so this won't work with multithreading, and generally makes larger programs tricky...
23:27:32 <letrec> The error message that I just got:
23:27:33 <letrec>     Couldn't match kind `* -> *' with `*'     Expected type: Channel                    -> Ack -> [Char] -> Maybe (StateT Msgs IO (LongLongInt, MsgIn))       Actual type: Channel                    -> Ack -> [Char] -> Maybe (StateT Msgs IO (LongLongInt, MsgIn))     Kind incompatibility when matching types:       Channel :: * -> *       Channel :: *     The function `lift'ghc: panic! (the 'impossible' happened)   (GHC version 7.6.3 for
23:28:14 <letrec> The expected type and actual type are same -- difficult to understand what's happening :)
23:28:22 <Gracenotes> well, the impossible happened
23:29:37 <Gracenotes> er.. yeah.. more context?
23:29:39 <Gracenotes> @paste
23:29:39 <lambdabot> Haskell pastebin: http://lpaste.net/
23:32:25 <WingbeatPony> Wait I'm back
23:33:51 <WingbeatPony> I found the solution to my problem, possibly; I'll let you know if it works
23:35:55 <argiopeweb> Outstanding.
23:35:58 * argiopeweb never sleeps
23:37:34 <WingbeatPony> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/code-generators.html seems to hold the key to cross-compilation
23:56:08 <pqmodn> 4
