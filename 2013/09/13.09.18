00:05:52 <ozkar> does anyone does web development with haskell?
00:06:34 <yesthisisuser> ozkar: i am playing around with Happstack right now
00:07:01 <yesthisisuser> there is also Snap Framework and Yesod.. all three of them are pretty solid web frameworks
00:08:14 <yesthisisuser> Blaze is really nice for writing html using native Haskell code: http://jaspervdj.be/blaze/
00:08:54 <yesthisisuser> and HaskellDB is great for working with relational databases using a similar approach: http://hackage.haskell.org/package/haskelldb
00:10:41 <johnw> i prefer persistent and esqueleto to haskelldb
00:13:31 <yesthisisuser> i am also looking for something that works with NoSQL-type of databases. what would you recommend?
00:13:57 <johnw> i have no experience there
00:14:56 <yesthisisuser> i guess there are wrappers for couchDB and similar
00:16:14 <yesthisisuser> johnw: is HaskellDB considered outdated or obsolete?
00:16:45 <johnw> i wouldn't go that far
00:17:03 <johnw> it was last updated 11 months ago
00:17:27 <johnw> i generally use esqueleto for everything these days
00:17:37 <yesthisisuser> is it similar?
00:17:45 <johnw> i never used haskelldb
00:17:58 <johnw> esqueleto is a DSL that looks very similar to the SQL query you'd write
00:18:07 * hackagebot cipher-rc4 0.1.3 - Fast RC4 cipher implementation  http://hackage.haskell.org/package/cipher-rc4-0.1.3 (VincentHanquez)
00:18:12 <yesthisisuser> so it is not using the relational algebra approach?
00:18:21 <johnw> select $ from $ \table -> where_ ( table^.someColumn ==. val 10 ) >> return table
00:18:24 <johnw> no
00:18:56 <yesthisisuser> i kind-of liked that with HaskellDB however :/
00:19:31 <johnw> i've heard it came with performance issues relating to multiple joins
00:19:44 <johnw> but I don't know if that's true of the current state of the art
00:20:13 <pharaun> iirc most of it was for mysql
00:20:20 <pharaun> postgres seemed to be able to handle it better
00:20:20 <johnw> oh yeah
00:20:22 <pharaun> from what i've read
00:20:25 <johnw> chrisdone told me that the other day
00:20:45 <yesthisisuser> yes mysql is a mess with haskellDB
00:20:46 <tdammers> mysql doesn't like joins at all
00:21:16 <yesthisisuser> but again, it feels like No
00:21:21 <yesthisisuser> SQL is the way to go these days
00:21:35 <b__> ghc doesn't like it when I try to define class Category (~>) where ...
00:22:03 <b__> do I need an extension to allow ~> to be used as a type variable?
00:22:26 <monoidal> b__: since 7.6 (if I remember correctly), you cannot have infix type variables
00:22:40 <b__> okay
00:23:21 <monoidal> b__: Category c where id :: c x x etc.
00:23:39 <monoidal> b__: id :: x `c` x might also work
00:23:49 <lcfrs> seen hyperthunk?
00:25:26 <b__> monoidal: I'll go with cat as the type variable
00:25:34 <b__> I want to use c in the definition of (.)
00:31:49 <yesthisisuser> btw, just to follow up
00:32:11 <yesthisisuser> i can't find anything about sprintf in ghci, but there is a :print command
00:32:38 <yesthisisuser> which does show information about unevaluated thunks
00:33:07 * hackagebot pem 0.2.0 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.2.0 (VincentHanquez)
00:36:59 <johnw> yesthisisuser: there's also ghc-heap-view
00:37:24 <yesthisisuser> oh. and there is a "sprint"
00:37:38 <yesthisisuser> Prints a value without forcing its evaluation. :sprint is similar to :print, with the difference that unevaluated subterms are not bound to new variables, they are simply denoted by ‘_’.
00:37:54 <yesthisisuser> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ghci-commands.html
00:40:21 <yesthisisuser> i am looking at ghc-heap-view
00:40:27 <yesthisisuser> "It has been inspired by (and taken code from) the vacuum package and the GHCi debugger, but also allows to investiage thunks and other closures."
00:41:20 <yesthisisuser> i don't understand the meaning of the word closure in this context. I have also seen it used with a similar meaning I suppose in libraries like GLib in C
00:42:17 <b0bbi10> hi, when new to install, should I install ghc or haskell-platform? (under Fedora)
00:42:33 <johnw> an unevaluated block will of necessity need to "close over" variables from its environment, which may themselves be thunks or later evaluatied
00:43:18 <yesthisisuser> ok, so it actually means the same as a normal closure
00:43:24 <johnw> yep
00:44:18 <yesthisisuser> hmm.. installing ghc-heap-view failed with error Could not find module `Data.ByteString.Lazy.Builder.Extras'
00:45:08 <monoidal> b0bbi10: haskell platform includes GHC. if the repository has 2013.2.0.0, it's current
00:46:02 <b0bbi10> so haskell platform = GHC + library and GHC just installs the compiler?
00:46:10 <monoidal> b0bbi10: yes
00:46:24 <b0bbi10> monoidal: ok, thanks
00:58:08 * hackagebot GLUT 2.5.0.1 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.5.0.1 (SvenPanne)
01:03:40 <tdammers> I'm about to descend into very dark regions
01:03:49 <tdammers> installing haskell in wine
01:04:29 <tdammers> brrr
01:04:36 <notdan> D:
01:06:18 <tdammers> well, it doesn't really work anyway
01:06:28 <yesthisisuser> you could try VMware Player
01:06:39 <tdammers> and run what inside that? windows?
01:06:41 <tdammers> I'd rather not
01:06:54 <chexxor> What's my problem? "Not in scope: data constructor `Integer'"
01:07:16 <tdammers> chexxor: explicit Prelude import?
01:07:23 <tdammers> no wait
01:07:31 <chexxor> add a b = Integer (min a b) -- I think "a" and "b" are "newtype MinMax"
01:07:33 <tdammers> you're using Integer as a constructor, not a type
01:07:38 <tdammers> try
01:07:41 <chexxor> -- newtype MinMax = MinMax Integer
01:07:43 <tdammers> add a b = min a b :: Integer
01:07:56 <tdammers> or
01:08:14 <tdammers> add (MinMax a) (MinMax b) = MinMax (min a b)
01:08:27 <tdammers> you have to unwrap and re-wrap the newtype constructor
01:08:28 <chexxor> so, when I use "newtype", I don't have to use MinMax to construct the type before returning it?
01:08:40 <tdammers> you do
01:08:47 <tdammers> but the constructor is called MinMax, not Integer
01:08:53 <chexxor> hmm.. I think I tried the latter case
01:09:07 <tdammers> it helps to add explicit type signatures to your functions
01:09:15 <tdammers> add :: MinMax -> MinMax -> MinMax
01:09:22 <chexxor> ah, no I tried this: "add (Integer a) (Integer b) = MinMax (min a b)"
01:09:37 <tdammers> that doesn't work, because Integer is a type name, not a constructor
01:09:47 <ski> ozkar : function call is flow control
01:09:49 <tdammers> you want to pattern-match on constructor names, not type names
01:09:56 <chexxor> where can I find Integer type constructors?
01:10:00 <tdammers> you can't
01:10:03 <tdammers> and you don't need them
01:10:14 <chexxor> ok
01:10:26 <tdammers> int literals are polymorphic; use them in a context that expects or infers Integer, and they automatically become Integers
01:10:42 <tdammers> e.g.:
01:10:56 <tdammers> let f a = (a + 23 :: Integer)
01:10:59 <Dxtr_> There's a quote floating around the internet that the "next Haskell" will be strict... how serious is that? (i.e. what kind of "next Haskell" is mean there - next language update, or the next-big-thing-in-purely-functional-languages)
01:11:01 <tdammers> f 23
01:11:15 <chexxor> gotcha
01:11:26 <tdammers> 23 in that example is now an Integer
01:11:31 <tdammers> but if I had written this:
01:11:36 <tdammers> let f a = (a + 23 :: Double)
01:11:39 <tdammers> it would be a double
01:13:02 <notdan> Dxtr_: I think this is purely hypothetical
01:13:21 <yesthisisuser> you can start with a type declaration
01:13:22 <Dxtr_> So it wasn't serious?
01:13:27 <yesthisisuser> f :: Double -> Double
01:13:45 <yesthisisuser> f takes a Double and returns a Double
01:13:51 <yesthisisuser> f a = a + 23
01:14:19 <chexxor> tdammers: thanks!
01:15:23 <yesthisisuser> oh never mind. i didn't read the whole conversation
01:17:26 <johnw> Dxtr_: there are already strict variants of Haskell, like Disciple, but I don't think removing laziness from Haskell would be an improvement
01:21:41 <Ghoul_> johnw: it doesn't remove laziness, it makes it explicit for easier transforms
01:22:11 <johnw> I still want it to be the default, not something you opt-in for
01:22:24 <Ghoul_> there will *eventually* be a haskell frontend for ddc which handles that
01:22:30 <Dxtr_> My question is more about whether it's still worth looking at Haskell now; If there's about to be such a big change in the near future, maybe it would be wiser to wait it out (kind of like with Pythong 2-vs-3)
01:22:43 <johnw> Dxtr_: it's definitely worth looking at now
01:23:00 <johnw> languages like Idris are showing great promise, but I think that's still a decade away from being a real contender
01:23:15 <Ghoul_> ddc is more like an optimization engine - what llvm is to clang is what ddc will be to some compiler in the future :)
01:23:17 <yesthisisuser> what big change?
01:23:23 <Dxtr_> isn't idris something different alltogether?
01:23:59 <Dxtr_> yesthisisuser: <Dxtr_> There's a quote floating around the internet that the "next Haskell" will be strict...
01:24:02 <johnw> Idris and Haskell overlap quite a bit
01:24:24 <yesthisisuser> ok.. hmm
01:24:28 <johnw> Dxtr_: https://gist.github.com/jwiegley/6599004
01:24:32 <yesthisisuser> sounds scary
01:24:35 <johnw> that's not Haskell code, even though it looks like it
01:24:35 <Ghoul_> theres so many blog thingies on why haskell wont work if its strict
01:24:48 <Dxtr_> isn't idris about programs being auto-provable, by being non-turing-complete?
01:24:51 <Ghoul_> how do you do tying the knot in a purely functional language like haskell if its strict?
01:25:05 <Ghoul_> you cant have immutability and strictness in the same place
01:25:06 <johnw> Ghoul_: i wouldn't mind a flag to disable lazy I/O, but I really like laziness in pure code
01:25:54 <Ghoul_> When ddc ages a bit, give it a few years, I think you'll find it very impressive
01:26:07 <Ghoul_> it doesnt do as many core passes as GHC right now, but the ones it does do are very impressive
01:26:17 <johnw> Dxtr_: that's one aspect of Idris, but you can use it to write partial functions even and functions which do not terminate
01:26:23 <Ghoul_> and the code it generates is pretty close to C
01:28:23 <monoidal> Dxtr_: there's no chance that Haskell will become strict in near future
01:28:27 <yesthisisuser> hmm.. it seems that the "next haskell will be strict" quote is from 2003
01:29:02 <johnw> yesthisisuser: link?
01:29:22 <Ghoul_> I dont think the person wo made that quote understands what that would mean anyway
01:29:30 <Ghoul_> it does not sound very credible..
01:29:32 <yesthisisuser> there is a link on this page
01:29:34 <yesthisisuser> http://netsuperbrain.com/blog/posts/haskells-evaluation-isnt-magic/
01:29:42 <yesthisisuser> "Note that the “next Haskell will be strict” comment was made 9 years ago, at a talk in 2003 and Haskell is now 50% older, with no strict variation/derivative/counterpoint to Haskell in sight (or is there)?"
01:29:50 <monoidal> Ghoul_: that quote is by Simon PJ if I remember correctly
01:29:59 <yesthisisuser> yes
01:30:11 <yesthisisuser> it seems to be a PPT slide
01:30:18 <Ghoul_> maybe he changed his mind in 9 years
01:30:22 <Ghoul_> or got smarter
01:30:25 * Ghoul_ runs for cover
01:30:40 <yesthisisuser> i hope they don't make such a drastic change to the language at this point
01:31:02 <yesthisisuser> especially since it is already perfectly possible to write strict code already
01:31:31 <monoidal> *if* it is made, it will surely be via some kind of optional pragma
01:31:33 <johnw> that same presentation extols the merits of laziness too
01:32:04 <Ghoul_> theres a thingy on github somewhere
01:32:09 <Ghoul_> which bang patterns every expression
01:32:16 <Ghoul_> its a ghc plugin which claims to make haskell strict
01:32:26 <Ghoul_> I remember seeing it as a mock test plugin for ghc's plugin system
01:32:52 <johnw> that's funny; that quote is in the PPT file, but not in the PDF
01:33:50 <yesthisisuser> remember that SPJ also said that "Haskell is useless": http://www.youtube.com/watch?v=iSmkqocn0oQ
01:33:52 <yesthisisuser> hehe
01:38:35 <quchen> Neat, #7633 was just pushed, checkable minimal complete definitions
01:38:43 <quchen> http://ghc.haskell.org/trac/ghc/ticket/7633
01:42:15 <Ghoul_> lol spj
01:42:18 <quchen> 7.8 will be pretty stuffed with neat and unexpected features :-)
01:42:33 <quchen> (Unexpected for me at least.)
01:42:33 <Ghoul_> I was expecting something more blatant than "haskell is useless, but hey we're going places"
01:42:39 <Ghoul_> misleading title :P
01:42:57 <quchen> Ghoul_: The safety-vs-usefulness graph video?
01:43:08 <Ghoul_> the link yesthisisuser is posted above
01:43:10 <Ghoul_> so yeah
01:43:16 <quchen> Ah I see
01:52:23 <yesthisisuser> they could always add a keyword for strict data types.. so that instead of writing data Foo = Foo !Int, you could do something like strictdata Foo = Foo Int
01:53:48 <Ghoul_> well, or you could just strictify every thing
01:54:08 <Ghoul_> strict data, lazy backbone, is the best imo
01:55:30 <quchen> yesthisisuser: The "!" allows you to have partially strict types like "data Pair a b = Pair a !b".
01:57:07 <quchen> Map is defined like this for example, data Map k a  = Bin !Size !k a !(Map k a) !(Map k a) | Tip
01:57:35 <quchen> Making 'a' strict here wouldn't make much sense.
01:58:15 <yesthisisuser> sometimes I have seen people using that in a datatype with something like data Something !Text !Text Int Bool etc
01:58:30 <yesthisisuser> what is the motivation for NOT making everything strict here
01:59:10 <quchen> In the Map case, strictness could mean unnecessary performance hits.
01:59:25 <quchen> Suppose you have a Map Int Int in which you store n and f(n) of some function.
01:59:41 <quchen> f(n) may be very expensive to compute, so it's handy to insert just the thunks.
02:00:05 <quchen> When you lookup a map entry, you can evaluate thunks selectively.
02:00:32 <quchen> In a strict setting, all the f(n) would be evaluated, no matter whether you needed them or not.
02:01:49 <quchen> The strictness of the Size parameter (type synonym for Int) is because the size of the Map needs to be available in a lot of places, and laziness doesn't help here. For example, the size is a crucial property in order to auto-balance the tree.
02:02:40 <quchen> The ! for the two sub-Maps is so that every Map knows whether its children are tips or other Maps, so the whole Map's "spine" is always there.
02:03:02 <quchen> In other words, you can't have infinite Maps.
02:03:49 <quchen> Lastly, the strictness of the k (Key) parameter I'm not sure about. I'm guessing that one could have been left lazy as well for some obscure corner cases.
02:04:51 <quicksilver> I think the underlying assumption is that Ord instances will strict on both sides
02:05:01 <quicksilver> so having the k strict is a reasonable heuristic
02:05:30 <quicksilver> bearing in mind that strict fields are only WHNF this seems reasonable
02:05:42 <quicksilver> hard to imagine an Ord instance which doesn't at least WHNF both its parameters
02:05:59 <quchen> quicksilver: maxBound >= x = True?
02:06:09 <quchen> eh, min
02:06:18 <quchen> Wait, max. Argh.
02:06:39 <donri> quicksilver: ()? Void? ^_^
02:06:51 <quchen> Void isn't a very good key type though.
02:06:58 <quchen> And neither is () for that matter.
02:07:07 <donri> (i just connected)
02:07:11 <quchen> But still, I wonder why the strictness is necessary here.
02:07:18 <quchen> Or even beneficial.
02:07:55 <quchen> donri: "Why is the 'k' strict in 'data Map k a  = Bin !Size !k a !(Map k a) !(Map k a) | Tip'"?
02:07:56 <quicksilver> quchen: it's beneficial because the compiler might pack the structure a bit smaller
02:08:10 <quicksilver> quchen: it's certainly not necessary.
02:08:24 <quchen> quicksilver: Hm, right, I deleted an UNPACK pragma in the definition there.
02:09:17 <donri> well only Size is unpacked right?
02:09:42 <donri> and also unnecessarily so in ghc HEAD which unpacks !Int anyway by default
02:10:10 <quchen> donri: HEAD unpacks all strict fields, doesn't it?
02:10:22 <quicksilver> it might well be the case that there is no good reason to make k strict there
02:10:33 <quicksilver> there is a fair amount of cargo-culting of strictness annotations
02:10:36 <yesthisisuser> so Int and Bool are always strict or?
02:10:40 <donri> quchen: no, only those smaller than word IIRC
02:10:40 <quicksilver> I don't think it's harmful though
02:11:27 <donri> quchen: there's -funbox-strict-fields though, but don't need HEAD for that (and it's probably a bad idea usually, anyway)
02:11:48 <quchen> yesthisisuser: No, they're not. First of all, you can't have a strict type with no type arguments, like "data Bool = True | False". You need something like "data Maybe' a = Nothing | Just !a".
02:12:06 <quchen> yesthisisuser: Certain operations on Bool/Int may be strict though. For example, (+) is strict in both arguments for Int.
02:12:50 <monoidal> donri: in HEAD that's default
02:13:08 <MasseR> hah. my haskell environment on my laptop is fubared. Safecopy templatehaskell segfaults, and acid-state doesn't recognize types
02:13:16 <ski> quchen : huh, `data Foo = Blah !Int' ?
02:13:18 <donri> monoidal: really? i'm sort of sure -funbox-small-strict-fields is the only new default
02:13:34 <monoidal> donri: ah, sorry
02:13:53 <quchen> ski: That's having Int as a type argument.
02:14:09 <quchen> That's different from "Int is strict" - it's "The Int contained in Blah is strict".
02:14:53 <ski> quchen : i wouldn't describe that as "having Int as a type argument"
02:15:01 <yesthisisuser> I am looking at this tutorial for example: https://www.fpcomplete.com/school/text-manipulation/json
02:15:22 <ski> rather something like "having a constructor with a (value) argument of type `Int'"
02:15:23 <yesthisisuser> making the Int and Bool fields strict here would make no difference or?
02:15:55 <donri> yesthisisuser: making a Bool field strict is different from making Bool itself strict
02:16:55 <yesthisisuser> yes. i was thinking about fields.. sorry. i was not clear in my description
02:17:30 <quchen> ski: That's arguing about about semantics now, isn't it?
02:17:35 <donri> that tutorial seems a bit odd; making every Text strict but no small fields - where it actually matters the most?
02:17:53 <yesthisisuser> that's what i didn't understand also
02:24:43 <ocharles> has hackage recently become broken when using haddock? I keep finding packages that link to file:///
02:28:32 <donri> ocharles: me too :/
02:28:53 <donri> ocharles: maybe something to do with preparations for hackage2? duno
02:30:45 <yesthisisuser> donri: in that example, you would make all fields strict or?
02:31:18 <donri> yesthisisuser: i tend to make all data type fields strict, and UNPACK small ones (for ghc pre-HEAD)
02:31:40 <yesthisisuser> ok
02:32:22 <ski> quchen : is arguing about semantics (iow meaning) bad ?
02:33:28 <ski> quchen : the reason i reacted is that i'd expect the term "type argument/parameter" to be reserved for `a' in `data Maybe a = Nothing | Just a' and for `Int' in `Maybe Int' (but not for the `a' in `Just a' there)
02:33:41 <ocharles> donri: yea, that's what I thought it might be
02:34:05 <ocharles> very annoying because my browser doesn't do anything when I click the links, except bitch in the console which I never look at
02:34:29 <donri> yesthisisuser: http://www.slideshare.net/tibbe/highperformance-haskell
02:35:21 <quchen> ski: I would have said "Just Int" gives a type argument "Int" to the value constructor "Just", similarly to how "add 3" provides the add function with a "value argument" of 3.
02:35:46 <donri> ocharles: yeah :( i think it's fixed though because i don't see it in new packages, only those uploaded within a period of some days some weeks ago?
02:35:49 <ski> (also cf. how some people incorrectly would say that `Maybe' is a "polymorphic type", or that `PolyKinds' enables "kind polymorhism"/"polymorphic kinds")
02:36:04 <ocharles> donri: ok, that sounds good
02:36:24 <ski> quchen : except that it's not similar at all
02:36:38 <yesthisisuser> donri: yes i started looking at that slide a while ago. i will continue reading it
02:36:57 <ski> quchen : you can't actually give a type argument to `Just', because `Just' is a function (on the value level), it can only accept a value as argument, not a type
02:38:09 <ski> the notation `Just Int' (in say `data MaybeInt = Nothing | Just Int') is just a "figure of speech" in the algebraic data type syntax for saying that an actual argument of `Just' must have *type* `Int'
02:38:53 <quchen> Just is something in a type definition and it takes a type as argument in that definition. I don't see how that is wrong to say. "Just is a type-level function" is wrong, yes, but it's also clear from the context that I didn't mean that.
02:40:12 <quchen> Let's settle on "abuse of notation".
02:40:37 <ski> quchen : perhaps not wrong per se, given the context. but misleading nonetheless (because i initially interpreted what you said about "type arguments" as talking about `a' as an argument of `Maybe', not of `Just', in `data Maybe' a = Nothing | Just !a')
02:41:00 <ski> quchen : granted :)
02:41:11 <ski> (or perhaps "abuse of terminology" :)
02:41:22 <quchen> Stop it :P
02:42:16 <ski> sorry, i'm sometimes a pedant at heart
02:57:04 <alexander__b> can someone explain <|> to me as briefly as possible?
02:57:25 <alexander__b> http://www.haskell.org/haskellwiki/Functional_Reactive_Programming -- preferably using these examples
02:57:33 <alexander__b>    myLabel = "yes" . keyDown Space <|> "no"
02:57:43 <alexander__b> "Now let's say you want to display "yes", when the space key is held down and "no" otherwise: "
02:59:51 <ski> alexander__b : in this context, i think you can read it as "or", or possibly "or else"
03:00:54 <alexander__b> ski: so... "if keydown space is true: "yes" else: "no""?
03:05:05 <RichyB> Is there a parallel mapM_? I have a bunch of IO actions that happen to be idempotent and independent and I want to schedule them all at once.
03:05:18 <donri> RichyB: use the async package
03:05:35 <quchen> ^ mapConcurrently it's called I think
03:05:41 <ski> alexander__b : i would assume so
03:05:42 <donri> yep
03:06:08 <RichyB> donri, thank you!
03:06:15 <RichyB> quchen, ta. :)
03:06:55 <donri> RichyB: and of course make sure to use -threaded and +RTS -N
03:09:24 <quchen> RichyB: Also have a look at the Concurrently type (especially its Applicative), which is nice if you need more fine-grained control
03:11:13 <donri> mapConcurrently f = runConcurrently . traverse (Concurrently . f)  -- isn't haskell beautiful :)
03:12:00 <quchen> inb4 edwardk telling us about the corresponding lens ;-)
03:13:35 <quchen> I sometimes wonder whether a "class Wrapped w where wrap :: a → w a; unwrap :: w a → a" would be useful for all this newtype juggling.
03:13:40 <mangaba_leitosa> all, is it possible to configure the Haskell REPL (ghci) to show function types instead of complaining "No instance for (Show (a0 -> a0 -> a0))
03:13:43 <mangaba_leitosa> "?
03:13:50 <quchen> mangaba_leitosa: ":t"?
03:14:08 <mangaba_leitosa> quchen: yes, like do :t automatically when a value is a function
03:14:19 <donri> quchen: http://hackage.haskell.org/packages/archive/lens/3.9.1/doc/html/Control-Lens-Wrapped.html ?
03:14:19 <quchen> > (+) -- like Lambdabot does? I don't think so
03:14:20 <lambdabot>   <Integer -> Integer -> Integer>
03:14:41 <mangaba_leitosa> quchen: exactly
03:14:54 <quchen> donri: But that's a Lens thing, I was wondering about the less lensy version.
03:15:01 <donri> @hackage newtype
03:15:02 <lambdabot> http://hackage.haskell.org/package/newtype
03:15:14 <mangaba_leitosa> quchen: how lambdabot does it then? :-)
03:15:39 <quchen> mangaba_leitosa: I'm not familiar with Lambdabot's internals, but I've heard 'mueval' does most of the magic.
03:16:03 <quchen> donri: Neat. Now add that to Base. :-D
03:16:42 <mangaba_leitosa> quchen: I see... So, not easy with ghci. I though it is something simple, because e. g. ocaml does it by default
03:16:54 <mangaba_leitosa> s/though/thought/
03:17:12 <quchen> mangaba_leitosa: I'm not sure how easy it would be to implement, I think the functionality is in GHC/Base.
03:17:30 <quchen> mangaba_leitosa: Nobody bothered to do it yet though.
03:17:46 <ski> quchen,mangaba_leitosa : isn't it just a matter of `instance (Typeable a,Typeable b) => Show (a -> b) where ...' ?
03:18:20 <mangaba_leitosa> ski: yes, there is Text.Show.Functions which, when used, makes ghc just show the text "function"
03:18:29 <magicman> show id being "<() -> ()>" because defaulting? Typeable doesn't play nice with polymorphism.
03:18:37 <mangaba_leitosa> ski: so I wonder if there is a standard module to show  function type instead of the text "function"
03:18:42 <quchen> > id
03:18:43 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
03:18:43 <lambdabot>    arising from a use ...
03:18:46 <quchen> :-(
03:18:51 <magicman> Oy, not even that. Man.
03:18:54 <ski> (perhaps `showsPrec p f = showParen (p > 0) $ showString "_ :: " . shows (typeOf f)' or somesuch)
03:19:08 <ski> > not
03:19:09 <lambdabot>   <Bool -> Bool>
03:19:13 <ski> mangaba_leitosa : defaulting, yes
03:21:35 <mangaba_leitosa> ski: sorry, I didn't understand the 'defaulting, yes' part
03:21:58 <ski> er, sorry
03:22:02 <ski> magicman ^
03:22:23 <mangaba_leitosa> ah :-)
03:22:29 <Lethalman> nice, seems to be written in haskell: https://bazqux.com/faq
03:22:53 <ski> mangaba_leitosa : not sure whether there's a standard such
03:23:32 <mangaba_leitosa> > \x -> x
03:23:34 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
03:23:34 <lambdabot>    arising from a use ...
03:23:36 <donri> quchen: ghc HEAD has safe coercions, that's cheaper than newtype and automatically inferred
03:23:46 <ski> > ($ "") $ let (p,f) = (0,not) in showParen (p > 0) $ showString "_ :: " . shows (typeOf f)
03:23:48 <lambdabot>   "_ :: Bool -> Bool"
03:23:49 <ski> > ($ "") $ let (p,f) = (1,not) in showParen (p > 0) $ showString "_ :: " . shows (typeOf f)
03:23:51 <lambdabot>   "(_ :: Bool -> Bool)"
03:26:30 <donri> quchen: http://www.joachim-breitner.de/blog/archives/610-Adding-safe-coercions-to-Haskell.html
03:26:50 <Lethalman> donri, why wouldn't you want implicit coercion between Int and some type synonym?
03:27:08 <donri> Lethalman: newtypes aren't synonyms
03:27:30 <donri> and synonym's aren't coerced, they're synonymous :)
03:27:38 <Lethalman> donri, in that post, Int and Age are, why can't you implicitly coerce?
03:27:46 <Lethalman> coerce the newtype
03:28:00 <Lethalman> I mean, what's the point in calling coerce manually when it can implicitly coerce
03:28:02 <donri> Lethalman: newtype Age = MkAge Int -- that's not a synonym
03:28:38 <donri> Lethalman: the whole point of newtype is to get a new type with the same representation; implicit coercion would void that and introduce weak typing
03:28:40 <Lethalman> rerrr
03:29:00 <Lethalman> mh ok
03:29:34 <donri> Lethalman: (well, it's supposed to be implicitly coerced in Core, but you don't want that happening in any way you can "observe")
03:30:02 <Lethalman> is that Coercible implementable for something else that is not newtype or it's something at compiler level
03:31:46 <donri> i think it's supposed to automatically have any instances that you could safely write yourself, and presumably that also means it will prevent you from hand writing any instances
03:32:30 <donri> i mean i'm not even sure it's a real class per se? it's supposed to derive any combination of types ever possible, that would completely explode haddock for example
03:33:11 <donri> (which i agree makes the whole thing a bit weird, but i don't know all the details)
03:37:47 <alexander__b> ski: thanks.
03:38:19 <ski> Lethalman : also to convert from `Foo Age' to `Foo Int'
03:38:23 <Lethalman> donri, ok
03:39:31 <Lethalman> but only for newtypes still
03:39:41 <donri> Lethalman: yes, what else?
03:39:42 <ski> donri : btw, did you see two somewhat related ideas to this i had, "contextual `newtype'" and "multiple `newtype'" ?
03:39:54 <donri> ski: nope
03:40:00 <Lethalman> donri, nothing :-) was thinking of data Foo = Foo Int and data Bar = Bar Int
03:40:11 <Lethalman> but that's indeed too different
03:40:12 <donri> Lethalman: those have different semantics from newtypes
03:40:19 <Lethalman> yes
03:40:37 <ski> the first idea is a way to get from `c Age' to `c Int' (and the other way), for any `c' at all :
03:40:58 <ski>   newtype k Age = WrapAge (k Int)
03:41:01 <ski> gives
03:41:08 <ski>   WrapAge :: k Int -> k Age
03:41:38 <ski> the idea being that this would be safe because of the intended "no run-time representation of `newtype'"
03:42:26 <donri> i may have read about that... is it in the original proposal?
03:42:51 <ski> so you could say `case ... :: [Age] of WrapAge (ns :: [Int]) -> ..ns..'
03:43:14 <ski> donri : not as far as i'm aware
03:43:17 <donri> http://ghc.haskell.org/trac/ghc/wiki/NewtypeWrappers#Proposal1
03:43:28 <donri> ah not exactly the same
03:43:45 * KingsleyT is learning haskell and loving it
03:43:51 <KingsleyT> just needed to say that to someone :3
03:44:08 <ski> right, i define `k Age' for any `k' (just like one can define `Maybe a' for any `a')
03:44:47 <ski> there's two potential problems with this idea : (a) you need to check that `k' in the definiens is used "at the head" of the type (only)
03:45:07 <ski> however, we'd like to be able to delegate the use of `k' to some other type
03:45:56 <ski> and (b) it can get clunky to rearrange `Foo Int Bool' to `Flip Foo Bool Int' only to get it in shape `k Int', so that `WrapAge' can be applied
03:46:47 <ski> donri : the other idea relates to "deep `newtype' hierarchies"
03:46:58 <ski> for simplicity, say we have
03:47:05 <ski>   newtype A = AofB B
03:47:13 <ski>   newtype B = BofC C
03:47:26 <ski> then i'd like to also allow (*simultaneously*)
03:47:33 <ski>   newtype A = AofC C
03:48:20 <ski> (in the presence of parameters, one could allow "special casing" in the obvious sense)
03:48:51 <ski> so, we can then choose whether to regard `A' as being built from an intermediate `B', or directly from a `C'
03:49:42 <ski> (if we could define pattern synonyms, then we could get basically the same effect in another way)
03:51:56 <quicksilver> ski: you'd like that purely to make your case statements prettier?
03:52:02 <quicksilver> (just trying to follow)
03:53:20 <ski> quicksilver : yes, to make constructing and deconstructing stuff simpler
03:53:26 <ski> consider
03:53:47 <ski>   newtype StateT s m a = StateT (s -> m (a,s))
03:54:19 <ski>   newtype State s a = State_of_StateT (StateT s Identity a)
03:54:31 <ski>   newtype State s a = State (s -> (a,s))
03:55:01 <ski> so we could introduce the simpler version, and keep it when adding the complexity
03:55:24 <quchen> donri: So in the future I can just throw "coerce" all over the place, a la "mapConcurrently f = coerce . traverse (coerce . f)"?
03:55:31 <ski> (obviously this also would depend on knowing `newtype Identity a = Identity a')
03:56:56 <quchen> donri: Provided there's a Coercible instance in both directions (which I will have to do manually?)
03:56:58 <donri> quchen: maybe. not sure you want coerce in both cases there though?
03:57:04 <ski> quicksilver : ok ?
03:57:15 <donri> quchen: i think Coercible is supposed to be a hidden implementation detail, and automatic
03:57:20 <donri> not sure
03:58:05 <quicksilver> ski: yes it makes sense but how much of a problem is it? Do you *need* to use the constructors directly?
03:58:12 <quchen> We'll have this figured out until 7.10 for sure :-)
03:58:13 <quicksilver> ski: rather than construction/destruction functions
03:59:17 <quicksilver> constructors aren't very abstract
04:00:25 <ski> well, more abstract constructors would also be nice ;)
04:01:01 <quicksilver> ski: do you need a better answer to more anstract constructors than the answer(s) that lens gives you?
04:01:50 <ski> quicksilver : anyway, i haven't necessarily said that i really want this. just that i have at times desired this (to be able to more easily make sense of some code manipulating types hiding under a forest of `newtype's, e.g.), and for throwing the idea out, for people to consider
04:02:02 <quicksilver> fair enough.
04:02:15 <quicksilver> I have certainly thought about pattern alises
04:02:27 <quicksilver> but I've never convinced myself they pass the power/weight ratio test.
04:04:10 <ski> `(view -> Just pat)' really uglifies stuff, when used not sparingly :( -- the above, or pattern synonyms (or similar) would really help in some cases, i think
04:04:41 <ski> (iow, if it was less ugly, people would possibly use it more, in reasonable cases)
04:05:36 <quicksilver> yes I find view patterns ugly but concede their use.
04:05:47 <quicksilver> If it was down to me they wouldn't be standardised in their current form.
04:05:53 <quicksilver> (it's not down to me ;)
04:06:17 * ski also wonders about axiomatic/declarative semantics for view patterns
04:19:30 <RichyB> quchen, thank you for the recommendation, the Applicative instance for Concurrently is really nice.
04:19:43 <quchen> You're welcome
04:21:58 <RichyB> I have mapM_ (runConcurrently . foldr1 (liftA2 (\_ _ -> ())) . map Concurrently) . splitIntoBatchesOf 500 -- and it works swimmingly. :)
04:23:18 * hackagebot sharedio 0.1.0 - Bundles shared calls to IO functions to perform them only once  http://hackage.haskell.org/package/sharedio-0.1.0 (NiklasHambuechen)
04:23:20 <donri> RichyB: why not mapConcurrently?
04:23:35 <RichyB> > let splitIntoBatchesOf n l = case l of { [] -> []; _ -> let (h,l') = splitAt n l in h : splitIntoBatchesOf n l'; } in splitIntoBatchesOf 5 ['a'..'z']
04:23:36 <lambdabot>   ["abcde","fghij","klmno","pqrst","uvwxy","z"]
04:24:19 <RichyB> donri, I tried that first but it blows up because each of the actions that I'm running concurrently consumes one file descriptor
04:26:02 <RichyB> Doing a fork/join pattern like that above with batches of 500 isn't as efficient a use of threads - it exhibits some unnecessary head-of-line blocking at the ends of batches - but the alternative is to do something silly like have every action wait on a QSem with initial value 500 (probably actually a bottleneck) or something
04:35:16 <lemao> need some directions here. What is the best/recommended way to split Haskell packages into an API package and 1 or more implementation packages. So the implementations are open (created by diff people at different points in time) and I would like the API package to enforce no only types but also the set of functions that define the supported operations. The obvious answer are type classes, but wondering if there are others (e.g. record of function
04:35:17 <lemao> s)?
04:36:01 <donri> lemao: you can hide the constructors of the types
04:37:47 <b__> Functor's are Endofunctors in the category of Hask right?
04:38:10 <hvr> edwardk: ping?
04:39:33 <lemao> donri: right, that makes the types abstract, but what about functions? In OO world I create a one or more interfaces + helper methods and data classes, and there is a common API for finding/loading implementations
04:40:36 <lemao> donri: if package B implements package A, I want to have the compiler enforce that B implements all the API functions
04:40:49 <lemao> donri: the most natural answer to me is a type class
04:43:55 <donri> lemao: yes, but look out for the "existential class" anti-pattern :)
04:44:55 <Lethalman> lemao, if you avoid using classes, this is a neat example of "implementing" interfaces by defining a data types with functions instead http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204
04:45:13 <Lethalman> that is, creating different game objects without type classes
04:45:25 <Lethalman> found that helpful
04:53:07 <lemao> donri, Lethalman: thanks for the pointers. Let me take a closer look at the link and antipattern before I possibly come with more questions.
04:53:19 * hackagebot tf-random 0.1 - High-quality splittable pseudorandom number generator  http://hackage.haskell.org/package/tf-random-0.1 (MichalPalka)
05:07:50 <donri> lemao: in case you didn't find it http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
05:11:55 <donri> lemao: but from what it sounds like your use case is, the typical pattern in haskell is simply to use modules
05:12:13 <donri> lemao: you get compile-time errors if the module doesn't have a function you try to use
05:13:29 <lemao> donri: Yes, I found the link, but thanks anyway.
05:14:27 <lemao> donri: the implementation has to be a separate package and the client modules should only depend on the API modules and the client package's cabal file would specify the impl package.
05:15:37 <lemao> donri: then I would like to have the compiler force the implementor to provide all the required behavior so it is guaranteed that the client of the API will work with it
05:16:22 <donri> lemao: haskell doesn't actually have that except with -Werror, but that might be good enough for you
05:16:25 <deggis> uhh, quick sanity check: (1+1)+(1+1) evaluates 1+1 two times but let x=1+1 in x+x evaluates first x to be 2 and then adds 2+2 ?
05:17:05 <donri> (ie. you can leave out fields of a record or methods in an instance and at best you get a warning which may not even be on by default)
05:17:38 <donri> deggis: ghc does some common subexpression elimination
05:18:14 <quicksilver> still, deggis, that's definitely the right rule of thumb
05:18:24 <lemao> donri: I wouldnt want to depend on a flag to enforce a static contract between packages
05:18:27 <quicksilver> GHC doesn't promise exactly (and the standard doesn't require it)
05:18:43 <deggis> ah of course its compiler specific.. but in case of f x x = x+x with ghc do the x's refer every time to same thunk with ghc and the result of that thunk will be used if available?
05:19:02 <deggis> don't know about terminology especially in "result of that thunk" but anyway :)
05:19:17 <quicksilver> in the "let" case, yes, it's a single thunk which is only reduced once
05:19:24 <quicksilver> after that it's just referred to.
05:19:34 <quicksilver> not sure what you meant by "f x x = x+x" exactly
05:19:37 <quicksilver> (typo?)
05:19:38 <deggis> oh what am i writing, that f x x is nonsense
05:19:52 <deggis> f a b = a+b and calling that with f x x
05:20:21 <quicksilver> yes
05:20:24 <lemao> donri: modules dont seem to be first class and allow me to enforce a contract. So I am back to either a type class solution or a record of functions as pointed out by Lethalman
05:20:26 <donri> lemao: there isn't really any way around it. you could use the record approach but without record syntax, but even then you can pass bottoms to the constructors ;)
05:20:28 <quicksilver> if that is literally 'x' then yes
05:21:05 <deggis> quicksilver: ok, thanks
05:21:09 <quicksilver> (if you called it with f (y+z) (y+z) then there might still be duplicated work)
05:21:16 <quicksilver> but the general rule is - if you name it, it is shared.
05:21:52 <donri> lemao: however i don't think this is a big problem. there's a "social" contract to implement a class or fill a record completely, as documented by haddock
05:22:14 <deggis> okay. i'm not putting your name to any function comment :) i'm just starting scala course and was right away wondering that that sort of machinery seems to be missing in scala
05:23:41 * slack1256 learns how useful is to call haskell code from C with the ffi.
05:23:43 <lemao> donri: yes, I am fine with that limitation :-) I am most interested in having the compiler guarantee that the package B implementing API package A conforms to the contract.
05:24:51 <lemao> donri: I find this to be a limitation when building in the large where different people/teams are building different implementations across different points in time.
05:25:36 <lemao> donri: the social contract is a bit weak imho when considering haskell being statically typed
05:26:20 <lemao> donri: you only know about API/contract problems when someone tries to use the implementation package (unless I am misunderstanding your comment)
05:27:31 <lemao> donri: however, I think that something along the lines can be achieved with type classes and/or record of functions.
05:29:55 <serban> i have a list, what can i use to get elem1 elem2, elem2 elem3, elem3 elem4... zip?
05:32:00 <quchen> serban: zipWith3 (\a b c → f a b b c c) list1 list2 list3?
05:32:47 <bergmark> > let a = [1,2,3,4] in zip a (tail a)
05:32:48 <lambdabot>   [(1,2),(2,3),(3,4)]
05:33:31 <quchen> Oh, the same list.
05:35:20 <serban> thanks
05:40:59 <donri> lemao: well my point is you can write "instance Ord Thing" and you might get a warning but it'll compile. you can write "Just {}" and you might get a warning but it will compile.
05:43:07 <Eduard_Munteanu> Hrm... I sort of wish stuff like skipMany, manyTill etc. from Parsec were defined for Applicatives / Alternatives generally.
05:44:04 <donri> Eduard_Munteanu: parsers package?
05:44:20 <donri> attoparsec also defines those in terms of Alternative
05:44:22 <Eduard_Munteanu> I'll look that up.
05:44:30 <Eduard_Munteanu> Oh. Maybe I should use attoparsec.
05:46:53 <ElectroStatik> hey all
05:47:34 <ElectroStatik> I guess I should ask this on #scala, but Haskell is always more lively
05:48:31 <Eduard_Munteanu> BTW, when building a layered parser, which approach makes more sense: running a Parser on objects generated at the lower level (eventually String/Text), or newtype-wrapping a Parser for String/Text then newtype-wrapping that one etc. and hiding constructors?
05:49:15 <slack1256> ElectroStatik: What is your question?
05:50:42 <Eduard_Munteanu> I guess I should pastebin an example to make myself clear.
05:50:59 <tdammers> Eduard_Munteanu: without the example, I'd assume the first one would be more readable
05:51:07 <tdammers> at least for people with a parsers background
05:51:17 <tdammers> classic separation of lexer and parser and all that
05:51:29 <Eduard_Munteanu> They'd still be separated, except differently.
05:52:23 <tdammers> sure
05:56:19 <kuribas> On which OS X versions does ghc work?
05:58:34 <Maior> kuribas: pass, but wfm on 10.8.4
06:00:42 <kuribas> What's wfm?
06:00:48 <bergmark> kuribas: depends on the ghc version
06:01:00 <bergmark> i think it says on haskell platform
06:02:49 <merijn> kuribas: Anything >10.5 I believe
06:02:49 <merijn> kuribas: Or otherwise 10.6
06:04:57 <dmead> fellas.
06:06:43 <applicative> hi dmead
06:08:42 <Eduard_Munteanu> http://lpaste.net/93126   -- here's what I had in mind
06:08:48 <Eduard_Munteanu> tdammers: ^^
06:09:57 <tdammers> yeah, pretty much what I expected
06:09:57 <Eduard_Munteanu> I think the second one is more powerful, it seems to allow you to decide stuff based on what higher layers say.
06:10:27 <tdammers> I think (2) is more powerful and more parser-combinatory, but (1) will be easier for people coming from more traditional approaches to parsing
06:10:38 <Eduard_Munteanu> I see.
06:11:01 <tdammers> also, and I'm not sure on this one, but I'd expect (1) to make it easier to debug at each individual level
06:11:14 <tdammers> i.e., run the line parser standalone and inspect its output, for example
06:11:25 <tdammers> don't know whether this is interesting anyway
06:12:29 <Eduard_Munteanu> It's a bit harder to lift Parsec stuff into higher levels safely though, it seems you need a polymorphic lift like   lexLift_ :: (forall b. Parser b -> Parser ()) -> Token a -> Lexer ()
06:12:33 <Eduard_Munteanu> Err.
06:13:03 <Eduard_Munteanu> tokenLift_ :: (forall b. Parser b -> Parser ()) -> Token a -> Token ()
06:13:25 <Eduard_Munteanu> to allow you to do stuff like  tokenLift skipMany fooTok
06:14:00 <Eduard_Munteanu> Not sure if that gets all fixed once I define Applicative-generic combinators like that.
06:14:54 <Eduard_Munteanu> (the idea is to let higher layers inspect lower stuff without sidestepping layering altogether)
06:24:33 <Eduard_Munteanu> Grrr... isSpace / space / skipSpace annoyingly insist on matching / skipping newlines as well.
06:25:08 <donri> char ' ' :)
06:25:43 <applicative> char ' ' <|> char '\t'
06:26:30 <Eduard_Munteanu> donri: I'd match newline first then 'space' if that's not satisfied
06:26:59 <Eduard_Munteanu> Makes sense for Unicode.
06:27:13 <pxqr> does new {-# MINIMAL #-} pragma documented somewhere?
06:27:52 <applicative> what is it??
06:27:52 <Lethalman> :t char
06:27:53 <lambdabot> Char -> Doc
06:28:13 <applicative> Lethalman: they mean the Char ->  Parser Char one
06:28:20 <Lethalman> ah
06:28:56 <beaky> hello
06:28:58 <beaky> what does sequence do
06:29:02 <beaky> @src sequence
06:29:02 <lambdabot> sequence []     = return []
06:29:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:29:02 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:29:08 <Eduard_Munteanu> :t sequence
06:29:09 <lambdabot> Monad m => [m a] -> m [a]
06:29:21 <tac> it turns a list of things into a thing of lists.
06:29:23 <applicative> Lethalman: its always found in any 'parser combinator library'
06:29:24 <beaky> is sequence like monadic join?
06:29:28 <Eduard_Munteanu> beaky: read the type... it says it takes a bunch of actions, runs them and collects the results
06:29:30 <geekosaur> isn't that pragma to help the compiler verify an instance has been properly defined by specifying the minimal complete definition?
06:29:37 <pxqr> > sequence $ map print [0..10]
06:29:38 <lambdabot>   <IO [()]>
06:29:51 <beaky> > sequence $ replicate 8 "01"
06:29:52 <lambdabot>   ["00000000","00000001","00000010","00000011","00000100","00000101","0000011...
06:29:53 <donri> "join" *is* monadic
06:29:57 <beaky> oh
06:29:57 <donri> :t join
06:29:58 <lambdabot> Monad m => m (m a) -> m a
06:30:13 <tac> sequence [takeNap, launchMissiles, takeAnotherNap]
06:30:20 <applicative> @type sequenceA
06:30:21 <lambdabot>     Not in scope: `sequenceA'
06:30:21 <lambdabot>     Perhaps you meant one of these:
06:30:21 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
06:30:27 <applicative> @type T.sequenceA
06:30:27 <donri> @src sequence
06:30:28 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:30:28 <lambdabot> sequence []     = return []
06:30:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:30:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:30:34 <donri> @src sequence_
06:30:34 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:30:44 <pxqr> geekosaur: I don't know what it does provide
06:30:56 <pxqr> that's the point of the question
06:31:10 <Eduard_Munteanu> :t Data.Traversable.sequence
06:31:11 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:31:39 <Eduard_Munteanu> sequence gives me strength! :P
06:32:16 <applicative> pxqr: geekosaur 's remark is suggesting a number of google searches to me though...
06:32:55 <applicative> http://ghc.haskell.org/trac/ghc/ticket/7633
06:33:23 <beaky> i love haskell
06:33:37 <pxqr> applicative: yep, now I see
06:33:38 <tdammers> beaky: don't we all?
06:34:22 <donri> beaky: it's so easy!
06:34:35 <applicative> implemented by twanlv; it must be good
06:34:36 <beaky> so monad bind is just join . fmap
06:34:40 <beaky> ?
06:34:49 <applicative> right
06:34:58 <Eduard_Munteanu> :t join . fmap
06:34:58 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
06:34:59 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
06:34:59 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
06:35:05 <Eduard_Munteanu> You want .:
06:35:05 <beaky> :t (>>=)
06:35:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:35:08 <beaky> ah
06:35:11 <applicative> :t (join.) . fmap
06:35:11 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
06:35:20 * Lethalman eeeeeeeeeeeeeek
06:35:25 <donri> @src join
06:35:25 <lambdabot> join x =  x >>= id
06:35:36 <tac> beaky: join+fmap is the definition preferred by category theorists, btw.
06:35:42 <Lethalman> :t join
06:35:43 <lambdabot> Monad m => m (m a) -> m a
06:36:18 <applicative> it seems they couldn't allow it as an alternative to defining >>= in the new formulation of Functor x => Monad f
06:36:21 <applicative> it seems they couldn't allow it as an alternative to defining >>= in the new formulation of Functor x => Monad x
06:36:24 <applicative> rather
06:36:53 <Eduard_Munteanu> No? :/
06:36:55 <applicative> I think join still won't be a method
06:37:32 <donri> i heard it will be
06:37:49 <tac> When is that epic change supposed to be added to GHC?
06:38:03 <donri> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Proposal_contents
06:38:08 <beaky> why does all new version of ghc need recompile previous versions of libs?
06:38:17 <Eduard_Munteanu> I wonder if the join <-> bind equivalence really holds for indexed monads.
06:38:47 <Clint> beaky: because abi compatibility is nonexistent
06:38:51 <Eduard_Munteanu> beaky: because upgrading GHC upgrades a bunch of libraries too
06:38:53 <beaky> ah
06:39:09 <applicative> no, join must hold only at the same index, no Eduard_Munteanu , or am I in a muddle
06:39:16 <beaky> @src zip
06:39:17 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
06:39:17 <lambdabot> zip _      _      = []
06:39:23 <ocharles> i find the join/fmap definition so much easier to understand
06:39:27 <ocharles> wish I started with that one
06:39:43 <applicative> i've never found a case where it wasn't easier to implement
06:39:49 <Eduard_Munteanu> applicative: maybe you mean for return/pure?
06:40:17 <Eduard_Munteanu> return :: a -> m i i a
06:40:30 <applicative> no i wasnt Eduard_Munteanu but now I see my mistake
06:41:16 <applicative> wait, but what would the type of join be, Eduard_Munteanu ?
06:41:53 <applicative> m i j (m j k a) -> m i k a?
06:41:54 <Eduard_Munteanu> applicative: I'm not sure what it should be when defining a monad, but you can derive it from (>>=)'s type.
06:42:34 <Eduard_Munteanu> I think it's j k on the outer m.
06:42:48 <applicative> sorry yes, obvious
06:43:19 <applicative> no, I'm losing my grip again. Havent looked at 'indexed monads' for a while ...
06:44:23 <Eduard_Munteanu> Hm.
06:45:06 <applicative> the wiki page on the Functor-Applicative-Monad proposal puts 'join as a method' in the proposal
06:45:38 <applicative> but I remember in the tide of blather on -libraries there was trouble with implementing it because of a cycle.
06:45:46 <applicative> maybe they got past the problem
06:46:30 <applicative> 3.1 It's the right thing to do™ Math. You've all heard this one, it's good and compelling so I don't need to spell it out.
06:46:43 <Eduard_Munteanu> (>>=) :: m i j a -> (a -> m j k b) -> m i k a, so x >>= id gives a = m j k b, so you get  (x :: m i j (m j k b)) >>= (id :: (m j k b -> m j k b)) :: m i k b,  so I guess you were right.
06:46:56 <applicative> is the first argument; my conviction that this was a demogical campaign for something sensible still stands ;)
06:49:09 <Eduard_Munteanu> For comonads the indexed bind is rather awfully indexed, though I see the duality.
06:49:50 <Eduard_Munteanu> The indices "de-compose", instead of "composing" like above.
06:51:56 <applicative> oh, of course.
06:52:03 <Eduard_Munteanu> I wonder if all this indexed stuff is written down somewhere... like a paper or a book.
06:52:20 <applicative> well, there are the various implementations
06:55:29 <jmcarthur_mobile> Eduard_Munteanu: kleisli arrows of outrageous fortune is worth reading
06:55:31 <Eduard_Munteanu> I'd try getting do notation to work with that. I guess you can trivially make normal monads into indexed monads.
06:55:45 <Eduard_Munteanu> Hm, sounds familiar, I will.
06:58:38 <Eduard_Munteanu> newtype ToIndexed m i j a = ToIndexed (m a), instance Monad (ToIndexed m) where ... -- or through standalone deriving
06:58:42 <applicative> The m i j a monads are rather unlike the kleisli arrows one, though I guess they boil down to the same
07:00:22 <applicative>  ibind   :: (a ~> m b) -> m a ~> m b ; ijoin   :: m (m a) ~> m a;  ibind f = ijoin . imap f
07:01:01 <Eduard_Munteanu> applicative: oh, that's how edwardk explains it too, it's  flip bind  because it makes the involved categories explicit
07:01:06 <applicative> which is ibind :: (forall i. a i -> m b i) -> (forall j. m a j -> m b j) etc
07:01:23 <serban> where am i going wrong with this pattern matching? http://pastebin.com/w7tXJz59 the input is a list of (Point,Point)
07:01:27 <mauke> The paste w7tXJz59 has been copied to http://lpaste.net/93128
07:01:29 <Eduard_Munteanu> I think that's the single index thing he uses too.
07:01:34 <applicative> right
07:02:37 <Eduard_Munteanu> serban: the first and second cases have different types.
07:02:58 <applicative> Eduard_Munteanu: but I take it that the 'At' or 'Atkey' type recovers what we want from the two index ones?
07:03:02 <serban> ah, i forgot the '
07:03:13 <serban> (also)
07:03:15 <Eduard_Munteanu> serban: a list can't be a pair
07:03:17 * applicative thought about this two summers ago; it clearly didn't stick too well
07:03:48 <Eduard_Munteanu> Not sure, I have to read that stuff sometime.
07:04:23 <FreeFull> Ok, I think I understand catamorphisms now
07:05:06 <applicative> edwardk's formulation of the Outrageous Fortune ideas is pretty handsome really
07:05:39 <serban> Eduard_Munteanu: if i remove the 3nd line i still get Couldn't match expected type `(Point, Point)' with actual type `[(Point, Point)$
07:05:53 <applicative> https://github.com/ekmett/indexed
07:06:02 <serban> i can't have a list of pairs?
07:06:24 <ocharles> applicative: hopefully this will be a bit more useful in 7.8 and make it to hackage
07:06:50 <applicative> oh whats the big change?
07:07:01 <Eduard_Munteanu> serban: the second line is problematic, that's the one that doesn't fit the type
07:07:18 <ocharles> i dunno, edward was saying something about it not being doable in 7.6 due to data kinds and Any or something something
07:07:18 <applicative> a couple uglinesses of the implementation were getting in the way, ocharles if I remember,
07:07:21 <ocharles> it went over my head
07:08:09 <serban> so i have to use something like x:[] to get the last element?
07:09:19 <applicative> hm, ocharles one thing I remember discussed on the lists was the feature that leads to crucial 'herp' and 'derp' functions in edward's library https://github.com/ekmett/indexed/blob/master/src/Indexed/Types.hs#L96
07:09:35 <Eduard_Munteanu> serban: how about   coords [] = ...   coords (x:xs) = ...  ? If you need to handle the last one specially, then yeah, do [x] or (x:[])
07:09:43 <geekosaur> serban: what's confusing you is that (x:y) is a list, not a pair
07:09:58 <geekosaur> [x:y] is a list of lists
07:10:19 <applicative> ocharles: it doesn't know that (Fst pr,Snd pr) ~ pr
07:10:39 <ocharles> applicative: oh, is that what it was?
07:10:51 <geekosaur> specifically, (x:y:[]) is another way to write [x,y]
07:11:08 <applicative> oh, I'm just saying that was one of the troubles I know of that does bear on this library
07:11:24 <applicative> ocharles: the library works fine
07:11:56 <applicative> if you dont mind a bit of herp and derp
07:14:01 <ocharles> applicative: haha, I forgot about herp and derp
07:14:32 <applicative> ocharles: it sounded from the discussion -- this was a while ago i was studying it -- that this wasn't simply a mistake, by the way
07:14:45 <ocharles> what, herp and derp?
07:14:51 <applicative> but an optional decision that makes sense in the haskell context
07:15:00 <applicative> the feature that made herp and derp necessary
07:15:38 <ocharles> well it says "work around" in the docs, so perhaps
07:22:29 <applicative> ocharles: here is a bit of the connecting tissue http://www.haskell.org/pipermail/glasgow-haskell-users/2012-September/021336.html
07:23:37 <applicative> continuing the last thread from http://www.haskell.org/pipermail/glasgow-haskell-users/2012-August/
07:30:38 <ElectroStatik> Keep free variables free! Free the free variables. Freedom is the key
07:31:16 <Eduard_Munteanu> Variables in bondage. :P
07:31:33 <ElectroStatik> Haha!
07:31:41 <Gracenotes> There ain't no such thing as a free variable.
07:32:14 <ElectroStatik> so they're all slaves!?
07:32:25 <sleepynate> no, they all come with a price
07:32:31 <sleepynate> to be paid in tears
07:32:32 <sleepynate> usually
07:32:38 <ElectroStatik> haha, how so?
07:32:40 <geekosaur> mercenaries
07:33:08 <sleepynate> every variable is a moving part that could break if tweaked the wrong way
07:33:34 <Gracenotes> Nothing is actually free by the time the GHC runtime sees it.
07:33:52 * Eduard_Munteanu goes invent a genre called BDNF, I'll think of something.
07:33:53 <beaky> http://ideone.com/zYUQwK how do ii improve my code
07:34:04 <beaky> i already don't understand how e.g.  line 97 works
07:34:17 <Gracenotes> Even type variables are bound to a "fresh instance" at their most general.
07:34:47 * applicative used to teach from Montague's elementary text which labors the Freedom and Bondage wit
07:34:52 <ElectroStatik> I know the one thing I did right was the day I start to fight, keep your eyes on prize hol' on hol' on to your free variables
07:35:06 * applicative wont tell you how the great man perished ;)
07:35:46 <applicative> only the LAPD knows for sure, of course
07:36:40 <beaky> liftM2 (>>) print playHangman =<< playHangmanTurn h -- how does this work
07:37:01 <applicative> i think it doesn't
07:37:09 <applicative> oh wait i see the parse
07:37:11 <Eduard_Munteanu> :t liftM2 (>>)
07:37:11 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 b) -> m (m1 b)
07:37:30 <ElectroStatik> unfortunately i'm programming in scala which doesn't hold on to its free variables with shadowing sigh
07:37:39 <applicative> so beaky (liftM2 (>>) print playHangman) is one chunk of it?
07:37:42 <ElectroStatik> is there shadowing in haskell?
07:37:50 <beaky> ah
07:37:51 <Eduard_Munteanu> ElectroStatik: yes
07:38:04 <ElectroStatik> do you guys use it much?
07:38:06 <Gracenotes> would that be holding onto bound variables, then
07:38:14 <applicative> the liftM2 monad is (->)a , not IO
07:38:25 <ElectroStatik> you have to all the time in scala
07:38:32 <ElectroStatik> bound is bound
07:38:32 <Eduard_Munteanu> ElectroStatik: I use it sometimes, not sure if others feel like this is a good idea
07:38:41 <applicative> @type liftM2 (>>) show
07:38:42 <lambdabot> Show a => (a -> [b]) -> a -> [b]
07:39:05 <applicative> @type liftM2 (>>) show chr
07:39:06 <Eduard_Munteanu> E.g. when I have something in a Maybe, I might not feel like giving it a distinct name before and after extracting it.
07:39:06 <lambdabot>     Couldn't match type `Char' with `[b0]'
07:39:06 <lambdabot>     Expected type: Int -> [b0]
07:39:06 <lambdabot>       Actual type: Int -> Char
07:39:19 <applicative> oh that was dumb, pardon
07:39:40 <applicative> @type liftM2 (>>) show (reverse . show)
07:39:41 <lambdabot> Show a => a -> [Char]
07:39:59 <Eduard_Munteanu> That's trickier though.
07:40:05 <applicative> > (liftM2 (>>) show (reverse . show) ) True
07:40:06 <lambdabot>   "eurTeurTeurTeurT"
07:40:31 <applicative> thats the same liftM2 (>>) fwiw , beaky
07:40:35 <beaky> ah'
07:40:49 <beaky> i regret using liftM@
07:40:56 <Eduard_Munteanu> Oh, duh, show... I thought it was the naked reader.
07:40:57 <beaky> now i dont understand my own code :(
07:41:34 <tac-geometry> liftM is just fmap for monads
07:41:40 <beaky> so what is does is "do { s <- playHangmanTurn h; print s; playHangman s }" ?
07:41:46 <applicative> liftM2 was the real topic
07:42:04 <beaky> i love liftM2
07:42:05 <Eduard_Munteanu> And liftM2 is like zipWith.
07:42:08 <applicative> liftM2 is just liftA2 for monads
07:43:00 <applicative> Eduard_Munteanu: with the applicative monad proposal, it's never like zipwith ;)
07:43:06 <beaky> there are applicative monads?
07:43:27 <Eduard_Munteanu> I think he means Applicative being a superclass of Monad.
07:43:29 <applicative> for every Monad instance there is at least one applicative instance
07:43:34 <beaky> I blame hlint for recommending liftM2 (>>) print playHangMan =<< playHangmanTurn s
07:43:44 <applicative> wow, did it??
07:43:49 <beaky> nah :D
07:44:16 <beaky> next time i will not abuse liftm2
07:44:19 <applicative> I was going to say, i hadn't thought it had integrated  `pointfree`
07:44:27 <applicative> liftM2 is good, like Eduard_Munteanu says
07:44:28 <Eduard_Munteanu> It's not really abusive
07:45:09 <applicative> i guess it takes a little getting used to but it tends to be more readable than the alternatives
07:46:39 <beaky> maybe do notation looks more clean
07:46:44 <Eduard_Munteanu> @type \f g -> (>>) <$> f <*> g
07:46:45 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
07:46:59 <applicative> liftM2 (>>) is a little hard to take in because it uses the naked reader monad, whichis a bit of a strain
07:47:51 <applicative> i mean in this case; bah
07:48:15 <applicative> liftM2 (>>) print print
07:48:26 <Eduard_Munteanu> @type \f g -> sequence_ [f, g]
07:48:27 <lambdabot> Monad m => m a -> m a -> m ()
07:49:37 <int-e> @type join (>>) . print
07:49:38 <lambdabot> Show a => a -> IO ()
07:49:49 <int-e> @type liftM2 (>>) print print
07:49:50 <lambdabot> Show a => a -> IO ()
07:50:16 <applicative> > join (>>) . show $ True
07:50:17 <lambdabot>   "TrueTrueTrueTrue"
07:53:24 <ocharles> :t join (>>)
07:53:25 <lambdabot> Monad m => m a -> m a
07:53:39 * hackagebot cabal-macosx 0.2.3 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.2.3 (EricKow)
07:53:53 <ocharles> :t (>>)
07:53:54 <lambdabot> Monad m => m a -> m b -> m b
07:54:01 <ocharles> hum, is that using the Reader monad?
07:57:28 <unK_> hello. does it make sense to create something like "class MonadThrow m where throwM :: Exception e => e -> m a" that works for IO based monad stacks and uses throwIO or just use throw directly? I'm not sure what's the better approach as the difference in semantics of throw and throwIO is quite subtle.
07:57:33 <donri> ocharles: in applicative's example it's using both the function monad and the list monad
07:58:15 <ocharles> donri: I know the list monad is in play, I was trying to figure out wtf 'join (>>)' really means
07:58:20 <ocharles> but I guess the monad being joined is ->
07:58:25 <ocharles> as there are two -> to join in >>
07:58:44 <donri> join (>>) = \x -> x >> x
07:59:19 <ocharles> are you sure? that seems to me to read as join being id for the reader monad
07:59:24 <ocharles> or maybe that is the case
07:59:40 <ocharles> oh wait
07:59:44 * ocharles gets it
07:59:53 <donri> :)
08:00:14 <donri> :t join (,)
08:00:15 <lambdabot> a -> (a, a)
08:02:47 <authchir> hi, I'm new in the haskell world and have a question concerning the use of monad primitives
08:03:29 <Entroacceptor> hello authchir, will you tell us your question concerning the use of monad primitives? :)
08:04:10 <authchir> yep, I am working on a little program that should behave like the UNIX wc command
08:04:17 <authchir> here: https://github.com/authchir/haskell-wc/blob/master/wc.hs
08:04:32 <authchir> and would like to get away with the do-notation in the main function
08:05:07 <authchir> I manage tho put the pure calculation in a local function defined in a where clause
08:05:20 <ocharles> authchir: you should be aware that 'contents <- mapM readFile files' will open 'length files' *at the same time*, btw
08:05:31 <ocharles> so that will crash if you pass a lot of files in
08:05:52 <authchir> ho, good to know
08:06:02 <authchir> was actually testing with 5 files :)
08:06:04 <ocharles> yay lazy io
08:06:15 <authchir> so, the end result is "mapM readFile files >>= \xs -> return (processContents xs) >>= putStrLn"
08:06:28 <authchir> but I don't like the lambda here
08:06:31 <ocharles> foo >>= return . f == fmap f foo
08:06:53 <ocharles> so: fmap processContents (mapM readFile files)
08:06:57 <beaky> how do I catch signals like SIGINT in haskell
08:07:08 <ocharles> but (<$>) == fmap, so: processContents <$> mapM readFile files
08:08:01 <authchir> wonderfull, I was not actually looking ouside of the Monad doc page
08:08:33 <ocharles> authchir: All Monads are Applicative, which means they are all Functors too. so you want to be familiar with at least those three structures
08:08:59 <authchir> yes, still learning
08:09:01 <ocharles> though we didn't use Applicative here :)
08:09:13 <ocharles> sure, just giving you some pointers on where next to focus your studies :)
08:09:23 <authchir> but, upt to know, this is refreshing comparing to my usual C++
08:09:30 <ocharles> authchir: good to hear!
08:09:45 <ocharles> stick with it, it only gets better :)
08:10:42 <applicative> unK_: you've seen Control.Monad.Error throwError :: e -> m a ? or maybe that was implicit in what you said?
08:11:26 <applicative> unK_: http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-Error.html
08:12:43 <beaky> why is my haskell code longer than c++
08:13:07 <applicative> beaky: just internalize the operation of @pl
08:13:16 <beaky> @pl?
08:13:16 <lambdabot> (line 1, column 1):
08:13:16 <lambdabot> unexpected end of input
08:13:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:13:19 <ocharles> Because you pressed more keys on your keyboard than you did when you wrote the C++ code
08:13:48 <doomlord_> is it a rare case of something where mutation helped..
08:13:52 <applicative> @pl beaky f g x y = f x (g x) y
08:13:52 <lambdabot> beaky = ap
08:14:03 <beaky> hmm app looks like the s combinator
08:14:09 <doomlord_> or where you had existing libraries :)
08:14:09 <applicative> it is
08:14:22 <beaky> the C++ one is a big main function
08:14:29 <beaky> the haskell one has separate pure functins
08:14:39 <applicative> ap is the S combinator for the 'naked reader monad'
08:14:42 <beaky> and haskell one is more eficient
08:14:49 <doomlord_> wait, define efficient
08:14:59 <beaky> less memory
08:15:04 <doomlord_> less memory use ?
08:15:07 <beaky> yes
08:15:09 <applicative> well, there's glory for you
08:15:24 <beaky> the haskell one takes longer to start though
08:15:33 <doomlord_> size vs speed tradeoff .. ?
08:15:46 <doomlord_> usually you have a tradeoff... size/speed/complexity.
08:16:01 <unK_> applicative: I'm familiar with MonadError/ErrorT. the thing is, I want to throw "real" exceptions, but without adding whole MonadIO constraint to functions that can throw them and I'm not sure whether just use throw from Control.Exception or pack throwIO in a class
08:17:11 <doomlord_> laziness can do things for memory efficiency that are complex to match in C++
08:17:31 <beaky> ah
08:17:33 <doomlord_> but its usually slower (more indirection)
08:17:49 <doomlord_> you can do anything in C++ manually, it just might be more code..
08:18:03 <beaky> the c++ version is more clean
08:18:19 <beaky> except for one line: auto rng = bind(uniform_int_distribution<vector<string>::size_type>{0u, words.size() - 1u}, mt19937{static_cast<unsigned>(time(nullptr))});
08:18:36 <doomlord_> "except for" .. LOL :)
08:19:23 <beaky> the haskell version is just g <- newPureMT
08:19:52 <beaky> :t =<<
08:19:53 <lambdabot> parse error on input `=<<'
08:19:56 <beaky> :t (=<<)
08:19:57 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:20:02 <doomlord_> you should expect big differences in approach between C++ / haskell, they are very different.
08:20:04 <beaky> :t (<$>)
08:20:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:20:13 <beaky> ah
08:20:26 <beaky> in haskell I was thinking about the relationships between types and values of types
08:20:38 <beaky> and of separating IO into their own functions
08:20:57 <beaky> so i defined a gamestate type, and wrote functions from state to state
08:21:03 <beaky> (is that the wrong way?)
08:21:26 <doomlord_> i can't comment so much, i'm very much a haskell n00b. i know enough to telll you its "very different to C++" :)
08:22:05 <mm_freak> beaky: most people seem to prefer imperative handling of random numbers, but that's not strictly required
08:22:27 <mm_freak> beaky: the haskell version becomes nicer as it becomes more idiomatic
08:22:33 <doomlord_> in c++ you think manually about how things are done, how memory is used.. and may have a lot of shortcuts for doing things.. (templates).
08:22:52 <doomlord_> in haskell you write pure algorithms, reliant on a clever compiler and runtime to make it work.
08:23:28 <beaky> actualy in c++ i didn't think about memory management at all
08:23:36 <beaky> c++ has ways of automagically managing memory
08:23:43 <doomlord_> (well c++ relies on a clever compiler to optimize things out.. but its still a much more direct mapping to low level operations)
08:23:48 <beaky> (but those ways are by default slower than the haskell way)
08:24:06 <doomlord_> you're still thinking about it. does something go on the stack, or the heap? is it single or shared ownership?
08:24:10 <beaky> ah
08:24:25 <beaky> i thought in terms of RAII values
08:24:39 <doomlord_> you have shortcuts (constructors/destructors, templates, ) .. but its still fundementally "manual", IMO.
08:24:49 <doomlord_> as in.. allocation/deallocation is part of the flow of the program
08:25:06 <doomlord_> with GC , its a seperate process, and not even defined as part of the program.
08:25:18 <Hafydd> it's
08:25:49 <doomlord_> to me RAII is just a shortcut
08:26:02 <doomlord_> less typing for patterns you'd have figured out in C
08:26:22 <beaky> i wish haskell had raii
08:26:31 <FreeFull> I do admit GC is a bit magical
08:26:41 <doomlord_> RAII and GC are ...very different :)
08:26:46 <doomlord_> i dont think they fit together.
08:26:52 <FreeFull> Rust went with making GC optional, and opt-in
08:27:04 <doomlord_> they are suffering through this design process now
08:27:16 <doomlord_> if you talk to rust people, they're sort of ashamed of the GC features at the minute :)
08:27:31 <doomlord_> they can't mix ~ and @ code easily, and talk of "de-@ing" their compiler sourcebase.
08:27:38 <FreeFull> I see
08:27:39 <beaky> http://ideone.com/HApkMM this is my c++
08:28:13 <doomlord_> I see GC vs RAII as one of the most  significant dividing lines in languages
08:28:36 <beaky> is @ the gc resources?
08:29:00 <doomlord_> yes correct; and ~T is like C++ unique_ptr<T>
08:29:19 <beaky> hmm i thought @ was unique_ptr<T> and ~ was shared_ptr
08:29:26 <doomlord_> opposite :)
08:29:32 <beaky> :D
08:30:00 <doomlord_> well @ isnt' like shared_ptr, its full GC , but they're considering changing it to @Rc and @Gc for refcounting and GC respectively, or even making it user controlled
08:31:26 <mm_freak> beaky: RAII?
08:32:05 <beaky> RAII is acquiring resources and assigning them to an object on construction, and freeing those resources as soon as the object goes out of scope
08:32:10 <doomlord_>  contructors/destructors used to implement allocation controlled by scope blocks
08:32:38 <beaky> not sure how haskell does the destruction bit
08:32:41 <mm_freak> beaky: class X { Y y; … }
08:32:43 <mm_freak> that?
08:32:47 <mm_freak> (where Y is a class)
08:32:54 <beaky> yes
08:33:00 <quicksilver> the analog to RAII in haskell is the "withBlah" idiom
08:33:02 <beaky> where Y is a RAII class :D
08:33:03 <beaky> ah
08:33:04 <doomlord_> class X {  X(){ allocate stuff }    ~X()  { decallocate stuff.. } }
08:33:09 <quicksilver> withBlah $ \blah -> do stuff
08:33:11 <mm_freak> beaky: yeah, that's with*
08:33:24 <quicksilver> that is scope-based resource control
08:33:25 <mm_freak> beaky: usually a special case of a 'bracket'-like operation
08:33:31 <beaky> ah awesome
08:33:37 <beaky> so I dont need to close files in haskell
08:33:44 <mm_freak> beaky: that would be terrible
08:33:53 <quicksilver> if you use 'withFile' you don't need to close files, no.
08:34:08 <mm_freak> well, you have to close them, just not manually…  and in fact you should actually prefer 'bracket' and with* over manual closing
08:34:12 <quicksilver> it's not always the right way, of course
08:35:28 <beaky> wow this whole time I thought haskell automagically closed files
08:35:31 <ocharles> quicksilver: if you use withFile you usually hit bigger problems :P
08:35:35 <beaky> i have been leaking resources
08:35:48 <quicksilver> ocharles: why?
08:35:49 <mm_freak> beaky: GHC haskell does close them automagically in certain cases
08:36:00 <mm_freak> beaky: for example when the handle is garbage-collected
08:36:04 <mm_freak> beaky: but don't rely on that
08:36:06 <ocharles> quicksilver: well, at least withFile and some lazy IO actions on the file handle
08:36:22 <quicksilver> ocharles: yes, but your 'bigger problem' is using so-called lazy IO
08:36:25 <n-dolio> Just don't use the two together.
08:36:28 <ocharles> quicksilver: ya
08:36:32 <quicksilver> which is a huge program-breaking problem anyway
08:36:36 <ocharles> i know
08:36:37 <quicksilver> and not really withFile's fault
08:36:41 <Eduard_Munteanu> Is there any support for nested modules, even if not first class?
08:36:44 <beaky> if I use Text.readFile, do I need to clos ethe file?
08:36:57 <ocharles> beaky: you can't close the file, because you're not given a file handle
08:37:00 <ocharles> so, no
08:37:01 <beaky> oh
08:37:10 <ocharles> readFile :: FilePath -> IO Text
08:37:11 <mm_freak> Eduard_Munteanu: no
08:37:16 <beaky>   v <- V.fromList . T.lines <$> T.IO.readFile "/usr/share/dict/words"
08:37:29 <Eduard_Munteanu> Grr. I just want a way to restrict scoping and hide some things within the same module.
08:37:30 <geekosaur> more lazy I/O :/
08:37:51 <ocharles> geekosaur: more lazy IO where? Text.readFile uses lazy io?
08:38:12 <beaky> i thought Text.IO was strict
08:38:24 <beaky> or maybe because I am using Data.Vector it is lasy
08:38:26 <mm_freak> Eduard_Munteanu: you can approximate nested modules using data types
08:38:35 <mm_freak> Eduard_Munteanu: record types in particular
08:38:54 <mm_freak> module :: Module A B C;  module = Module { … } where …
08:39:02 <geekosaur> hm, wrong Text.IO
08:39:26 <Eduard_Munteanu> mm_freak: oh, hm... and use a let/where clause for "private" stuff?
08:39:50 <Eduard_Munteanu> Ah, I missed your "where".
08:39:55 <mm_freak> Eduard_Munteanu: yeah…  it's the way to add first class modules…  but they are not really "modules"
08:40:33 <mm_freak> i guess what you really want is agda's module system…  haskell's is very weak compared to that one
08:40:49 <Eduard_Munteanu> mm_freak: hmmm... it shouldn't be hard to instantiate accessors with TH to "open" stuff.
08:40:55 <Eduard_Munteanu> Yeah, Agda's is nice.
08:41:41 <mm_freak> Eduard_Munteanu: you can use record puns to "open" such a "module"
08:41:48 <mm_freak> f Module{..} = …
08:41:52 <beaky> is there an inverse to fmap
08:42:01 <beaky> @pl flip fmap
08:42:01 <lambdabot> flip fmap
08:42:03 <beaky> :(
08:42:04 <mm_freak> beaky: what kind of inverse?
08:42:11 <mm_freak> i.e. what's its type?
08:42:14 <Eduard_Munteanu> Oh, I remember that extension.
08:42:19 <bartavelle> f b -> f a -> (a -> b)
08:42:27 <geekosaur> :p
08:42:37 <beaky> (a -> b) -> (b -> c) -> (a -> c)
08:42:43 <beaky> oh
08:42:45 <Eduard_Munteanu> mm_freak: does it work at the toplevel as well, somehow?
08:42:55 <mm_freak> Eduard_Munteanu: yes
08:42:57 <mm_freak> i think
08:42:57 <beaky> @djinn (a -> b) -> (b -> c) -> (a -> c)
08:42:57 <lambdabot> f a b c = b (a c)
08:43:05 <Eduard_Munteanu> Cool, I'll google for it.
08:43:19 <mm_freak> Eduard_Munteanu: i'm not sure whether the puns work at top level though
08:43:20 <beaky> @djinn f b -> f a -> (a -> b)
08:43:20 <lambdabot> -- f cannot be realized.
08:43:43 <mm_freak> beaky: again, what kind of inverse…  what are you trying to achieve?
08:44:05 <geekosaur> [18 15:42] <beaky> (a -> b) -> (b -> c) -> (a -> c)
08:44:08 <geekosaur> (b . a)
08:44:20 <beaky> :T (>>>)
08:44:22 <beaky> :t (>>>)
08:44:23 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
08:44:24 <mm_freak> fmap (flip f)?
08:44:28 <beaky> aha that is what i want
08:44:30 <geekosaur> or flip (.) if you must
08:44:49 <mm_freak> are you actually abusing fmap as (.)?
08:44:56 <beaky> yes
08:45:02 <geekosaur> yug
08:45:13 <mm_freak> you should generalize (.) to the one from Control.Category
08:45:13 <Eduard_Munteanu> mm_freak: oh, I want RecordWildCards too
08:45:20 <mm_freak> and use (>>>)
08:45:39 <Eduard_Munteanu> Puns themselves don't allow M{..}.
08:45:54 <mm_freak> ah
08:46:04 <Eduard_Munteanu> "Additionally, record wildcards can be used wherever record patterns occur, including in let bindings and at the top-level."
08:46:05 <beaky> wow I never imagined that Control.Category would be sueful :D
08:46:10 <mm_freak> Eduard_Munteanu: i wasn't sure, because i've never used record puns =)
08:46:29 <Eduard_Munteanu> Me neither, but it seems nice.
08:46:32 <mm_freak> beaky: you must have missed a lot then
08:47:44 <beaky> @pl concat $ take (size $ f h) m
08:47:47 <lambdabot> concat (take (size $ f h) m)
08:47:47 <lambdabot> optimization suspended, use @pl-resume to continue.
08:48:28 <beaky> yay i broke lambadbot
08:48:42 * hackagebot haxparse 0.3.0.0 - Readable HaxBall replays  http://hackage.haskell.org/package/haxparse-0.3.0.0 (JoelTaylor)
08:49:01 <geekosaur> it's already broken. but you didnt tell it what points to remove
08:49:40 <geekosaur> "@pl" is mechanical, it does not know that "h" there is any different from "concat" etc.
08:50:11 <geekosaur> @pl \f h m -> concat $ take (size $ f h) m
08:50:14 <lambdabot> (((concat $) .) .) . (take .) . ((size $) .)
08:50:14 <lambdabot> optimization suspended, use @pl-resume to continue.
08:50:26 <beaky> ah
08:50:33 <beaky> ok i will not pointless that
08:50:42 <beaky> sometimes pointless style is more complex
08:50:46 <Eduard_Munteanu> mm_freak: hm, what do I do about types though? Any chance they can be declared in a record?
08:51:15 <mm_freak> Eduard_Munteanu: haskell supports a limited form of indexing
08:51:37 <argiopeweb> The m is easy to eta out.
08:51:41 <mm_freak> Eduard_Munteanu: you'll have to use GADTs for that
08:51:43 <Eduard_Munteanu> You mean the kind promotion?
08:51:56 <Eduard_Munteanu> DataKinds, I mean.
08:52:03 <MitchellSalad> @pl \a -> f (g a) b
08:52:03 <lambdabot> flip f b . g
08:52:04 <argiopeweb> \f h -> concat . take (size $ f h)
08:52:54 <mm_freak> Eduard_Munteanu: give me an example
08:53:40 <beaky> @hoogle [a -> b] -> [a] -> [b]
08:53:41 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:53:41 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
08:53:41 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:53:41 <Eduard_Munteanu> mm_freak: newtype MyHiddenThing a = MyHiddenThing { unMyHiddenThing :: a }
08:53:59 <Eduard_Munteanu> mm_freak: I want to keep the constructor secret
08:54:15 <Eduard_Munteanu> (the data constructor)
08:55:13 <Eduard_Munteanu> Perhaps you mean I should expose the type in a GADT index? But I'm still not sure how to declare it.
08:55:20 <mm_freak> Eduard_Munteanu: no, that would actually require dependent types
08:55:30 <beaky> hello
08:55:37 <mm_freak> Eduard_Munteanu: but wait
08:55:40 <beaky> how do I get dynamic version of a library
08:55:43 <mm_freak> Eduard_Munteanu: it might be possible using existentials
08:55:52 <Eduard_Munteanu> Hm.
08:56:15 <Eduard_Munteanu> Keeping it around, yeah. Not sure about the declaration itself.
08:56:52 <Eduard_Munteanu> Unless you can declare a datatype in a where clause for a normal definition, or somewhere within another datatype.
08:57:00 <argiopeweb> beaky: It's a setting in your cabal config
08:57:01 <mm_freak> Eduard_Munteanu: you would have to use church encoding for that to work…  it guess that's not quite what you want
08:57:11 <beaky> oh
08:57:11 <jhormuz_> There are so many high level GUI libraries, but I have no idea which ones are supported/complete....  I already use gtk2hs, but am contemplating using something higher level, and any guidance would be appreciated....
08:57:15 <Eduard_Munteanu> Type families sort of do that but they're still all public.
08:57:19 <mm_freak> Eduard_Munteanu: for "submodules" with types you should probably use an actual module
08:57:40 <Eduard_Munteanu> Hm, yeah, I guess I should just do that.
08:58:05 <mm_freak> Eduard_Munteanu: there is a convention, if you need an internal submodule in X.Y, you name it X.Y.Internal
08:58:40 <Eduard_Munteanu> Yeah, I've been doing that sometimes.
08:58:55 <mm_freak> jhormuz_: there is work in progress to get FRP GUIs, but nothing you would use in production yet
08:59:56 <Eduard_Munteanu> jhormuz_: besides FRP needs to be understood first.
08:59:57 <jhormuz_> mm_freak- So there really isn't anything good right now?
09:00:08 <argiopeweb> jhormuz_: I tend to prefere wxHaskell when I'm forced to do GUI work. It seems he world is moving toward FRP, but I defer to mm_freak.
09:00:16 <pxqr> mm_freak: what's the most production level FRP GUI today?
09:00:30 <Eduard_Munteanu> Your best bet is still gtk2hs AFAIK.
09:01:03 <argiopeweb> Wow, I must need coffee... I can't spell today.
09:01:05 <jhormuz_> eduard_munteanu- do you mean by the researchers, or programmers at large (ie- as in 'very few programmers understand monads yet, even though they have been around for a while)?
09:01:06 <Eduard_Munteanu> pxqr: I think none is usable except for demonstrating simple things
09:01:26 <Eduard_Munteanu> jhormuz_: for both researchers and programmers
09:01:44 <jhormuz_> eduard_munteanu- ahhh
09:02:16 <argiopeweb> Eduard_Munteanu: I've seen people get good results hand-rolling imperative GUI libraries with netwire, but I'll agree that none of the large packages are currently ready.
09:02:25 <Eduard_Munteanu> jhormuz_: but my main intention was to say it's not some other API you can just start using.
09:02:37 <magneticduck> hey everybody
09:02:50 <Eduard_Munteanu> magneticduck: hi
09:02:56 <magneticduck> I have a little problem.. I'm trying to learn how to usese
09:03:01 <magneticduck> use hommage
09:03:11 <magneticduck> but the haddock docs don't seem to come up on the hackage page
09:03:21 <Eduard_Munteanu> magneticduck: what's that?
09:03:25 <magneticduck> can anybody else recreate the problem? http://hackage.haskell.org/package/hommage
09:03:32 <magneticduck> hommage is a sound synthesis library
09:03:45 <magneticduck> written entirely in pure haskell I believe
09:03:48 <Eduard_Munteanu> magneticduck: it seems only the 0.0.5 docs have been built yet
09:03:56 <mm_freak> Eduard_Munteanu: FRP itself is actually well understood
09:03:58 <jhormuz_> I started using gtk2hs, but it just isn't declarative enough, so now I am trying to write a personal library (which I would be happy to release if there were any interest) where you declare the GUI tree like (like type safe HTML).  But I don't want to reinvent the wheel.  Seems like there is no wheel.
09:04:03 <beaky> what is the best haskell web frameowrk
09:04:05 <bartavelle> magneticduck, if you installed it, you should have the docs built locally
09:04:10 <magneticduck> ah k, 1) how do I access them and 2) why aren't they built? they're in the code!
09:04:11 <jhormuz_> would something like that be of interest to people?
09:04:13 <magneticduck> alright
09:04:14 <mm_freak> pxqr: reactive-banana-wx
09:04:19 <mm_freak> pxqr: for widget-based GUIs that is
09:04:25 <Eduard_Munteanu> mm_freak: I thought there were a few point of contention, that people don't seem to agree on, no?
09:04:26 <mm_freak> when people say "GUI" they usually mean that
09:04:29 <Eduard_Munteanu> *points
09:04:38 <argiopeweb> magneticduck: It hasn't been updated since 7.0, so it's not likely it will currently build. No build, no haddock.
09:04:40 <Eduard_Munteanu> Like discrete vs continuous-time.
09:04:43 <bartavelle> magneticduck, the build failed on hackage (there is a "Build failure" thingie on the page)
09:04:51 <Eduard_Munteanu> But I know very little about FRP. :)
09:04:56 <magneticduck> ahah
09:04:59 <dcoutts> jhormuz_: actually creating the GUI is the easy bit, it's getting the state management right that's interesting
09:05:03 <mm_freak> Eduard_Munteanu: well, yes
09:05:06 <magneticduck> I really know very little about the whole hackage cabal setup
09:05:12 <magneticduck> pretty new to it, anyway thanks
09:05:19 <mm_freak> Eduard_Munteanu: the original FRP as formulated by conal elliot uses continuous time
09:05:30 <magneticduck> oh lol, I can't actually install haddock
09:05:40 <dcoutts> jhormuz_: if you just want a solution for building the gui itself, use the glade graphical designer and load up the files with the Builder module, there are demos/examples you can look at
09:05:43 <Eduard_Munteanu> mm_freak: yeah, I've seen conal taking the continuous side too
09:05:44 <magneticduck> hmm, maybe I'll try a lower version?..?
09:05:50 <conal> mm_freak: two "t"s please. :)
09:05:57 <mm_freak> conal: sorry =)
09:05:58 <Eduard_Munteanu> Heh.
09:06:01 <mm_freak> Eduard_Munteanu: elliott
09:06:03 <pxqr> mm_freak: I'll try that;
09:06:05 <conal> thx.
09:06:20 <argiopeweb> conal: I see you're as picky about that 't' as am I.
09:06:23 <jhormuz_> dcoutts- wouldn't that be an even further layer up....  In other words, just allowing the tree description would be better than gtk2hs, and then you could build state transfer on top of that.
09:06:37 <conal> Eduard_Munteanu: have you read my stackoverflow summaries of FRP?
09:06:43 <argiopeweb> as I am, even. Wow. coffee.
09:07:01 <magneticduck> boy, I have nothing but trouble with the haskell98 package!
09:07:02 <Eduard_Munteanu> conal: not sure, I remember going through a paper but not far enough... any links?
09:07:11 <magneticduck> keep getting ambiguous things when installing libraries
09:07:20 <dcoutts> jhormuz_: I think they're pretty orthogonal really, the visual layout and the state management
09:07:26 <magneticduck> like, "Ambigious module: Prelude" >_>
09:07:32 <jhormuz_> dcoutts- I looked at glade, but didn't like it.  It is not type safe (the description is an xml string).  I was thinking about a full haskell tree.
09:07:32 <conal> Eduard_Munteanu: start with http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#comment9673470_1030631
09:07:45 <Eduard_Munteanu> Thanks.
09:07:46 <dcoutts> jhormuz_: the html-like layout bit is done, just use glade (it actually does use xml much like you're describing)
09:07:54 <mm_freak> well, there is an interesting formulation and implementation of FRP in agda…  it uses linear-time temporal logic, which has a discrete time model
09:07:55 <magneticduck> how do people deal with that? can you only have the base or haskell98 installed at any given moment?
09:08:06 <dcoutts> jhormuz_: so certainly, don't reinvent that particular wheel
09:08:09 <magneticduck> or is there some way to set the scope of a package to only use one of them
09:08:20 <conal> Eduard_Munteanu: then http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language?lq=1 and http://stackoverflow.com/questions/5385377/the-difference-between-reactive-and-functional-reactive-programming?lq=1
09:08:35 <mm_freak> but it's easy to generalize to continuous time, if you view the time set as a topological space
09:08:42 <dcoutts> jhormuz_: it checks the types when you load it up
09:08:51 <magneticduck> hey guys? what do I do when I get the error Ambiguous module name `Prelude':
09:08:53 <magneticduck>       it was found in multiple packages: base haskell98-2.0.0.1
09:08:59 <jhormuz_> dcoutts- Also, more than just type safety, I want to be able to store attributes as functions (like in html, onClick=).  This is easy in haskell, but not with glade.
09:09:02 <mm_freak> i did some experiments using LTL-FRP in haskell, but didn't go very far
09:09:06 <magneticduck> do I have to uninstall haskell98? and how?
09:09:12 <dcoutts> jhormuz_: so sure, loading an external data file can fail, but you only need to test that once to find out if it's working
09:09:14 <Eduard_Munteanu> Alright, I'll read those, thanks.
09:09:30 <jhormuz_> dcoutts- I don't know perhaps I am unique, but I really prefer the compile time checks.
09:09:32 <dcoutts> jhormuz_: yes, you separate the visual design from the logic
09:09:36 <geekosaur> magneticduck, it means you have both haskell98 and base in your required packages, don't do that
09:09:43 <geekosaur> the Prelude is not compatible between them
09:09:49 <dcoutts> jhormuz_: the "onClick" lives in the Haskell code, not the visual part
09:09:49 <magneticduck> yes alright
09:09:52 <magneticduck> but the package isn't mine
09:09:54 <jhormuz_> am I the only one?
09:10:07 <Sculptor> hi
09:10:25 <magneticduck> which is hilarous; the package in question is a well used haskell library, hommage
09:10:29 <magneticduck> what am I doing wrong?
09:10:34 <geekosaur> so you found an older package from when the Prelude-s were compatible and the package maintainer took the cheap way out of making their package "compatible" with newer standards
09:10:43 <dcoutts> jhormuz_: take a look at some of the examples, they just get the named widgets from the glade file and then you do your normal action stuff, event handlers etc
09:10:44 <beaky> how do I be better at haskell
09:10:47 <beaky> my haskell is so ugly
09:10:47 <argiopeweb> magneticduck: You can `cabal fetch` the package, modify the PACKAGE.cabal, and `cabal install`(without the  package name)
09:10:51 <jhormuz_> dcoutts- but then you have to write code to bind the function to the code- It is much easier to just do somthing like "onClick=doit" in the tree.
09:11:01 <mm_freak> beaky: write more code
09:11:02 <geekosaur> (specifically haskell2010 and later uses hierarchical packages)
09:11:12 <dcoutts> jhormuz_: no, you need a reference to the widget anyway
09:11:18 <magneticduck> yes I could manually fix it
09:11:20 <magneticduck> huh.
09:11:22 <jhormuz_> dcoutts- I actually worked with glade for a day or so before I dropped it.
09:11:35 <magneticduck> well I guess I'll do that; I was kind of expecting a big package like this to not have stupid problems
09:11:48 <dcoutts> jhormuz_: also, if you put the handlers directly into the xml/typed-tree whatever, then you would not have the right context available
09:11:58 <mm_freak> IMO glade is a broken concept
09:12:02 <dcoutts> jhormuz_: take a look at a real app, like say ThreadScope to see how this works
09:12:05 <dcoutts> it's quite nice really
09:12:11 <geekosaur> Upload date	Fri Mar 19 15:08:53 UTC 2010
09:12:22 <ocharles> dcoutts: coming to London Haskell today?
09:12:24 <jhormuz_> dcoutts- not it you put it in the tree description (like html, <button onClick="doit();">.... the Haskell equivalant)
09:12:24 <magneticduck> yeah, "Ambiguous module name `Prelude':
09:12:25 <dcoutts> mm_freak: but it's a lot nicer than doing visual design in the code
09:12:26 <magneticduck>       it was found in multiple packages: base haskell98-2.0.0.1
09:12:33 <mm_freak> dcoutts: is it?
09:12:37 <magneticduck> oh sorry about that, paste is working against me today
09:12:39 <dcoutts> ocharles: sadly not, too much stuff to do before icfp
09:12:48 <ocharles> dcoutts: ah yes, I forgot that was coming up
09:12:53 <jhormuz_> dcoutts- context can be put in using state monad.
09:13:00 <ocharles> i look forward to seeing the result of the game programming :)
09:13:09 <dcoutts> ocharles: :-)
09:13:28 <dcoutts> jhormuz_: I've written several gtk2hs apps, so I'm speaking from experience here
09:13:29 <jhormuz_> onClick::event->State DOM
09:13:32 <mm_freak> dcoutts: so far my code GUIs worked much better than graphically designed ones, and they were faster to develop…  glade solves a different problem
09:13:47 <mm_freak> dcoutts: the point of glade is that non-coders can design the GUI
09:14:02 <dcoutts> mm_freak: or people can design one that looks any good
09:14:07 <magneticduck> btw guys, it seems that hpaste.org is down?
09:14:15 <dcoutts> mm_freak: for non-trivial bits of the visual layout, it's no good doing it in code.
09:14:23 <argiopeweb> @where hpaste
09:14:23 <lambdabot> http://lpaste.net/new/haskell
09:14:25 <dcoutts> mm_freak: it's too complex and the feedback process is too slow
09:14:28 <argiopeweb> Just moved
09:14:40 <dcoutts> mm_freak: a mixture works ok though
09:14:44 <magneticduck> ah thanks
09:14:50 <jhormuz_> dcoutts- Are you saying you wouldn't prefer type safety if it already existed?
09:14:57 <magneticduck> anyway, what am I supposed to think when cabal install tells me http://paste.org/67434
09:15:32 <dcoutts> mm_freak: or prototyping with one, and then hard coding it. I've done that where it would not have been possible to work with an external data file
09:15:37 <mm_freak> dcoutts: i can't really agree about that…  code can be modular, so you can always focus…  if that is difficult to do, the resulting GUI may be unfortunate, too
09:15:39 <magneticduck> I've gotten this kind of unspecified "could not resolve dependencies error" once before
09:15:45 <jhormuz_> I guess I am surprised, I would have thought everyone here would prefer adding the type safety....
09:15:48 <magneticduck> trying to install the synthesizer package
09:16:07 <mm_freak> dcoutts: but i'm not really arguing against visual design
09:16:07 <dcoutts> mm_freak: GUI visual design tends not to be modular. If you use one of the modular combinator libs for the visual design then it shows :-)
09:16:09 <geekosaur> magneticduck, your paste site just redirected me to an ad. fail
09:16:14 <mm_freak> dcoutts: i'm arguing against glade
09:16:18 <magneticduck> rofl
09:16:31 <magneticduck> uh, no scroll down
09:16:34 <bergmark> well it was a "please don't block our ads" ad :)
09:16:40 <argiopeweb> Same
09:16:40 <dcoutts> mm_freak: well ok, I'm not claiming glade is a brilliant impl of its concept. But it is the only one for gtk
09:16:45 <magneticduck> www.paste.org seems to be a bit ad-ified xl
09:16:52 <jhormuz_> dcoutts- It is very modular-  time input can be built from smaller components and reused.
09:16:53 <mm_freak> dcoutts: indeed
09:16:54 <geekosaur> as far as I'm concerned it's a "don't bother using us" ad
09:16:54 <magneticduck> I'll use the new hpaste in the future
09:17:02 <dcoutts> jhormuz_: that really isn't the hard problem in gui apps
09:17:05 <argiopeweb> Though, without seeing it, I can tell you that you jsut have found a very old package that expects old versions of libraries.
09:17:38 <magneticduck> well a site with such an obvious domain name is going to get a lot of hits, I imagine the makers felt like exploiting that
09:17:46 <jhormuz_> dcoutts- What is?
09:17:57 <dcoutts> jhormuz_: as I said, the visual aspect of the gui is straightforward, it's the state management that is interesting. The one-time issue of loading the glade file is not a real problem in practice.
09:18:17 <dcoutts> jhormuz_: and saying "state monad" isn't enough
09:18:21 <hpaste> MagneticDuck pasted “dammit cabal” at http://lpaste.net/93134
09:18:30 <magneticduck> there you are
09:19:14 <dcoutts> magneticduck: use section syntax, like it says
09:19:30 <jhormuz_> dcoutts- FRP could be added on top of the tree stuff (it is independent).  As far as how the event handlers know the current state, I think it is enough.
09:19:32 <argiopeweb> And don't make 0.0.5 a requirement of 0.0.6.
09:19:35 <argiopeweb> That's just odd.
09:19:38 <magneticduck> that's a non-fatal warning
09:19:40 <magneticduck> lol guys
09:19:43 <magneticduck> this is not my package!
09:19:53 <magneticduck> this is on haskell, one of the top results for sound synthesizer libraries
09:20:05 <dcoutts> which package?
09:20:11 <magneticduck> this one is called hommage
09:20:20 <magneticduck> but I also tried a package called "synthesizer"
09:20:30 <magneticduck> synthesizer in particular is an extremely big well thought out package
09:20:36 <adnap> Is there a way to add tye annotations on a separate line from variables to the left of <- in do notation?
09:20:37 <magneticduck> but the error I get when I try to cabal install it is in the same format
09:20:47 <adnap> *type
09:21:02 <adnap> Instead of (x :: String) <- getLine
09:21:10 <adnap> x :: String; x <- getLine
09:21:14 <magneticduck> http://hackage.haskell.org/package/synthesizer
09:21:27 <dcoutts> magneticduck: well hommage does indeed appear to be broken and unmaintained
09:21:33 <mauke> x <- getLine; return (x :: String)
09:21:52 <ocharles> adnap: you can determine the type of x when you use it later
09:22:03 <hpaste> MagneticDuck pasted “dammit synthesizer” at http://lpaste.net/93135
09:22:22 <adnap> ocharles: Sometimes the type checker isn't so good at inferring types
09:22:30 <ocharles> adnap: i'm not suggesting inference
09:22:30 <adnap> No instance for (Applicative f0) arising from a use of `pure' The type variable `f0' is ambiguous
09:22:43 <mm_freak> jhormuz_: if you use FRP there is no "current state" anymore
09:22:44 <ocharles> i'm suggesting x <- whatever; ... blah (blah foo (x :: Int )) ...
09:23:09 <geekosaur> Upload date	Mon Jun 8 13:52:28 UTC 2009  <--- even more out of date
09:23:18 <mr-> damn it.. cabal: Map.!: given key is not an element in the map
09:23:21 <mm_freak> jhormuz_: the "current state" becomes an intrinsic run-time property of your declarative GUI description
09:23:32 <jhormuz_> mm_freak- The library I am proposing writing doesn't use FRP....  But you could build an FRP lib on top of it.  So I still need state.
09:23:42 * hackagebot scotty 0.5.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.5.0 (AndrewFarmer)
09:23:53 <jfischoff> So what happens if STM transaction get stucking retrying, and more and more of them are created?
09:23:54 <geekosaur> and its ocnstraint on directory means it requires an older ghc
09:24:02 <jfischoff> does it result in catastrophic failure?
09:24:05 <mm_freak> jhormuz_: why not put FRP on top of GTK/wx/qt/… directly?
09:24:10 <geekosaur> because directory is constraining base, and base is tied to the compiler
09:24:12 <jfischoff> or do just the transactions fail?
09:24:15 <magneticduck> rofl I've been trying to implement a simple synthesizer in haskell for a while now
09:24:26 <magneticduck> I either can't get a library installed or the tool I was using is underpowered
09:24:29 <magneticduck> help me out here please :<
09:25:08 <magneticduck> http://lpaste.net/93135 is the hpaste link in case you guys are working on small screens like I am =P
09:25:18 <fryguybob> jfischoff: Is there some context I'm missing?  Why are they retrying and is this an explicit retry or detected conflict?
09:25:29 <jhormuz_> mm_freak- My library is about something else, it doesn't solve the same problem as FRP, it does something else (let you describe a gui as a tree).  I am just mentioning that it could be compatible with said lib.
09:25:50 <joelteon> overloadedstrings should become a default-on extension :|
09:25:51 <jfischoff> fryguybob: lets say it is explicit
09:26:13 <jhormuz_> mm_freak- ideally you would have both features though, I just am not dealing with the one.
09:26:22 <mm_freak> jhormuz_: all of the major GUI libraries do that, except that you have to use imperative operations to build the tree
09:27:00 <dcoutts> magneticduck: try --dry-run --max-backjumps=-1
09:27:01 <fryguybob> jfischoff: Ok, if some transaction looks for some condition in some collection of TVar's and it isn't met, so it does  retry.  That thread with the transaction will be suspended.
09:27:07 <magneticduck> rofl getting cabal working is a black art isn't it
09:27:08 <thoughtpolice> joelteon: as it stands, it causes ambiguity errors with the current IsString definition. -XOverloadedStrings + 'length "foo"' for example no longer works
09:27:14 <thoughtpolice> even if there are no other IsString instances in scope
09:27:17 <magneticduck> on it, dcoutts and thanks for the response
09:27:28 <jhormuz_> mm_freak- which ones?  The ones I have seen have the imperitive workflow - create widget, add widget, etc.
09:27:41 <fryguybob> jfischoff: When another transaction writes to a TVar that was in the first transactions record, the first transaction will be woken up.
09:27:54 <dcoutts> magneticduck: that one is giving cabal a hard time because it needs to use rather old versions of many packages
09:28:08 <fryguybob> jfischoff: This implies that *some* transaction succeeded.
09:28:09 <dcoutts> magneticduck: it looks like it has not been updated in a while
09:28:25 <magneticduck> maybe I should change some of the dependencies
09:28:28 <magneticduck> no, it hasn't :<
09:28:31 <mm_freak> jhormuz_: yes, as said, you use imperative operations to build a tree
09:28:31 <magneticduck> very sad
09:28:36 <mm_freak> jhormuz_: it's ugly, but it's a tree
09:28:48 <fryguybob> jfischoff: If no transactions are succeeding and they are all hitting retry, then they all block and just sit there, not using CPU.
09:28:55 <magneticduck> it's telling me it needs to reinstall a bunch of packages to lower versions, like it should
09:29:12 <jfischoff> fryguybob: so I am imagining a situation where some threads are succeeding, but most are failing. And new ones are being creating faster then old ones are succeeding
09:29:21 <magneticduck> hmmm
09:29:25 <jhormuz_> jhormuz- I am saying, create the gui like "gui = vbox [button, textview]", etc
09:29:25 <jhormuz_> that is weird, I meant to address that to mm_freak, instead addressed it to myself :)
09:29:30 <dcoutts> magneticduck: right, so that may or may not work in practice. If you do it, use a sandbox.
09:29:36 <fryguybob> jfischoff: If the TVar stops being referenced, GC will find the dead thread and throw a blocked indefinately exception.
09:30:17 <fryguybob> jfischoff: Sure you could create blocked threads faster then they get unblocked.
09:30:19 <hpaste> MagneticDuck pasted “cabal file” at http://lpaste.net/93136
09:30:28 <mm_freak> jhormuz_: that's exactly how you do it with FRP
09:30:38 <magneticduck> it's weird, because I don't see any packages that are required to be in lower versions
09:30:43 <jfischoff> fryguybob: so would I run out of ram from the thread creation or something else?
09:30:54 <fryguybob> jfischoff: Eventually yes.
09:30:55 <dcoutts> magneticduck: that one is just broken. It says it's using cabal-1.2 spec, but it's not using the correct syntax.
09:31:01 <jfischoff> fryguybob: thanks
09:31:01 <magneticduck> huh
09:31:11 <magneticduck> well I'll try something else then
09:31:27 <dcoutts> magneticduck: you can try hacking it, remove the "Cabal-Version:      >=1.2" line
09:31:31 <jhormuz_> mm_freak- which lib, isn't FRP about event handling (ie- you could set up a tree of widgets imperitavely, then create data links)
09:31:41 <dcoutts> magneticduck: ie cabal unpack it, edit it locally, install
09:32:22 <magneticduck> since it's a small package I might even go as far as to salvage it for useful material and use it in my own package
09:32:23 <mm_freak> jhormuz_: why wouldn't you want to go all the way?
09:32:59 <fryguybob> jfischoff: Notice also that as things are now there is a very narrow window where two competing transactions can both fail to commit due to conflict with the other.  Theoretically this could go on forever.
09:33:11 <latro`a> is something like: "f a = do a' <- m; case a of Foo -> return b; Bar -> f a' " a recursion pattern anywhere?
09:33:25 <jfischoff> fryguybob: interesting
09:33:32 <latro`a> erm
09:33:32 <jhormuz_> mm_freak- In my proposed lib?  Eventually I would want to go the whole way.  But for practical considerations I am just modularizing part of the problem out.
09:34:03 <jhormuz_> mm_freak- like I said before, ideally you have both.
09:34:05 <latro`a> "f a = do a' <- g a; case a of Foo -> return (h a'); Bar -> f a' "
09:34:12 <latro`a> gah one more time
09:34:57 <tinyghost> do a what
09:35:00 <latro`a> "f a = do a' <- g a; if p a' then return h a' else f a' "
09:35:34 <latro`a> it's very similar to takeWhile p . iterate g
09:35:45 <latro`a> except monadic
09:35:46 <magneticduck> dcoutts: do you know why cabal thinks it's necessary to install these old packages though?
09:35:55 <magneticduck> because the versions aren't defined in the cabal
09:36:07 <magneticduck> does it look at the code and deduce which versions are necessary?
09:36:12 <dcoutts> magneticduck: you're talking about two different packages I think
09:36:22 <jhormuz_> mm_freak- the two things I am trying to figure out now though (and I think I already have part of my answer) 1). Does said lib already exist in a usable form (the answer is no), and two- would people be interested in said lib (at present, based on the people here, the answer is possibly no)
09:36:39 <magneticduck> really?
09:37:10 <magneticduck> where are the versions in the cabal?
09:37:26 <mm_freak> jhormuz_: well, there is tangible values
09:37:37 <mm_freak> jhormuz_: but it looks unmaintained nowadays
09:37:42 <dcoutts> magneticduck: the one where it needs old versions is the other package, synthesizer, not hommage
09:37:57 <jhormuz_> mm_freak- tangible values = a library?
09:38:05 <magneticduck> ah k, I was getting mixed up
09:38:33 <mm_freak> jhormuz_: yes…  http://www.youtube.com/watch?v=faJ8N0giqzw
09:38:33 <dcoutts> magneticduck: hommage indeed would not need older versions (at least from cabal's point of view, in reality it probably does need older one, it's just not specified properly in the .cabal file)
09:40:46 <magneticduck> hmm
09:40:54 <magneticduck> well I'll work on salvaging some stuff from hommage
09:40:56 <jhormuz_> mm_freak- Oh, yeah, I did see that one.  Actually, there is a huge list of GUI libs at http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries, but it doens't look like any are complete and maintained (of the high level stuff)
09:41:25 <magneticduck> soon I'll have a standalone, functional synthesizer on github.. not that the haskell community seems to do a lot of sound :<
09:41:31 <magneticduck> thanks for your help, gtg now
09:41:38 <jhormuz_> mm_freak - I though someone here would give some insight....  The responses seemed to confirm that to me.
09:42:39 <jhormuz_> mm_freak- I thought perhaps everyone would simultaneously say- you don't know about X, everyone uses X (kind of like gtk2hs or wxWidgets on the low end)
09:44:44 <MitchellSalad> @pl \m a -> m >>= f a
09:44:48 <lambdabot> (. f) . (>>=)
09:44:48 <lambdabot> optimization suspended, use @pl-resume to continue.
09:47:43 <danr> @pl-resume
09:47:49 <lambdabot> (. f) . (>>=)
09:47:49 <lambdabot> optimization suspended, use @pl-resume to continue.
09:47:58 <quchen> (That never works.)
09:48:03 <mm_freak> jhormuz_: i'm sorry, no
09:51:01 <jhormuz_> mm_freak- No problem....  thanks for the info (to you and everyone)
09:54:06 <n-dolio> Do you know about reactive banana?
09:54:23 <n-dolio> And/or threepenny?
09:57:18 <Eduard_Munteanu> Hm, I wish I could write something like a newtype constraint wrapper, like   newtype Parses m = (Functor m, Applicative m, ...) => Parses (MonadError E m, SomethingElseNotPublic m)   , such that the first set of constraints is public and the second one requires explicit "unpacking".
09:57:56 <Eduard_Munteanu> Well, I guess we could break that into a constraint synonym and a questionable part. :)
09:58:37 <Eduard_Munteanu> The idea is to get newtype semantics for stuff like transformers, while keeping things polymorphic.
09:59:42 <augur> whats throw-catch semantics for a Maybe monoid instance?
10:00:42 <Eduard_Munteanu> augur: I guess you want MonadPlus for the monoid to make more sense?
10:01:05 <quicksilver> "catch semantics" for a maybe-like structure is this:
10:01:09 <augur> Eduard_Munteanu: i dont know, conor was griping earlier about Maybe's monad instance not having throw-catch semantics
10:01:24 <quicksilver> Just a `catch` Just b = Just a
10:01:25 <Eduard_Munteanu> Oh, I thought it was related to what I said earlier, somehow.
10:01:29 <augur> the only think i can think of would be if it's essentially left-preferring
10:01:31 <quicksilver> Nothing `catch` Just b = Just b
10:01:36 <augur> yeah, like that quicksilver
10:01:53 <quicksilver> can't do "throw" in something that simple, though
10:02:00 <quicksilver> only catch
10:02:07 <augur> throw is just returning Nothing
10:02:09 <Eduard_Munteanu> Depends on the throw I guess.
10:02:12 <quicksilver> right
10:02:16 <quicksilver> but that doesn't really throw anything
10:02:18 <augur> its a vacuous error but
10:02:24 <quicksilver> anyhow, yes, that's the kind of thing that is meant
10:02:30 <Eduard_Munteanu> MonadError () Maybe  would fit.
10:02:33 <quicksilver> the MonadPlus instance for IO is like that
10:02:36 <augur> Eduard_Munteanu: lol
10:02:41 <augur> yes these things exist
10:02:47 <augur> i was just wondering what conor might have meant
10:03:10 <quicksilver> > Just 1 `mplus` Just 2
10:03:11 <lambdabot>   Just 1
10:03:17 <quicksilver> > Nothing `mplus` Just 2
10:03:18 <lambdabot>   Just 2
10:03:21 <quicksilver> no idea :)
10:03:30 <quicksilver> seems to work, to me.
10:03:33 <augur> i think he wanted that
10:03:40 <augur> but as the Monoid instance, not a monadplus
10:03:48 <quicksilver> oh I see
10:03:54 <quicksilver> right, yes, that's what he meant
10:04:03 <quicksilver> the monoid instance for Maybe is the pass-through one
10:04:12 <augur> pass through?
10:04:16 <Eduard_Munteanu> Well, a monoid doesn't help catch/throw, does it?
10:04:23 <quicksilver> it uses (and requires) a Monoid instance on the contained type
10:04:25 <augur> the monoid instance, afaik, is actually just a lift of an underlying monoid
10:04:30 <quicksilver> yes
10:04:34 <Eduard_Munteanu> You want something more like a zero multiplicative element.
10:04:38 <augur> is that what you mean by pass-through?
10:04:49 <quicksilver> yes it was what I meant.
10:05:16 <quicksilver> I think one reason that that Monoid instance was chosen is that hte other behavoiur is already available via MonadPlus
10:05:19 <quicksilver> not sure though
10:05:47 <augur> actually the docs seem to suggest it was chosen because its nice to be able to turn semigroups into monoids
10:05:53 <n-dolio> It's also nice as the completion of a semigroup into a monoid. Except semigroup didn't exist.
10:05:57 <augur> but there's no semigroup class so monoid will have to do!
10:06:02 <augur> which is hilariously pointless
10:06:06 <Eduard_Munteanu> Not sure what algebra structure describes that best though, an ideal or normal subgroup perhaps?
10:06:51 <n-dolio> Free monoid over a semigroup.
10:07:48 <Eduard_Munteanu> n-dolio: hm, so what's the point of the unit if it leaves the computation unchanged?
10:08:26 <nomeata> Hi. Is anyone of John Wiegley, Sakari Jokinen, or Jacob Stanleyyeah here?
10:08:28 <Eduard_Munteanu> Don't you want throws to collapse the entire computation?
10:08:32 <edwardk> augur: the Monoid instance for Maybe is something I view as one of the big missed opportunities
10:08:38 <edwardk> nomeata: johnw is often around
10:08:40 <Eduard_Munteanu> nomeata: John Wiegley is here
10:08:43 * hackagebot rfc5051 0.1.0.3 - Simple unicode collation as per RFC5051.  http://hackage.haskell.org/package/rfc5051-0.1.0.3 (JohnMacFarlane)
10:08:46 <augur> edwardk: are you with conor on this?
10:08:50 <n-dolio> Eduard_Munteanu: I don't understand the question.
10:08:54 <edwardk> augur: on what?
10:09:04 <augur> edwardk: what the monoid instance ought to have been
10:09:19 <edwardk> augur: i have a semigroups package explicitly so that some day we can fix it ;)
10:09:33 <augur> edwardk: oh, you want an actual semigroup lift?
10:09:43 <edwardk> yes
10:09:45 <nomeata> johnw: Hi. I have a question on libgit2 (and hlibgit2 makes it on topic ;-)): Can I use it to fetch a pack’s index (but not the pack) from a remote, and parse it?
10:09:53 <edwardk> it is the most useful monoid for Maybe
10:10:02 <edwardk> instance Semigroup a => Monoid (Maybe a)
10:10:22 <edwardk> _and_ it is the one that can be changed to without randomly changing semantics
10:11:06 <edwardk> i presume conal wants the pure mempty / liftA2 mappend ?
10:11:14 <Eduard_Munteanu> n-dolio: if you want to model computations that can fail, like Maybe, you want Nothing combined with anything to yield Nothing. I'm wondering if monoids are appropriate for that, or something else, since this looks a lot like e.g. zeros for multiplication.
10:11:35 <augur> edwardk: conor, not conal :D
10:11:37 <edwardk> while that monoid can always be defined it is rarely what i want
10:11:38 <Eduard_Munteanu> n-dolio: and a monoid merely says it has an additive zero and a plus.
10:12:00 <augur> edwardk: conor mcbride, not conal elliot
10:12:01 <Eduard_Munteanu> (identity, that is)
10:12:12 <n-dolio> No, I don't think so. Monoids can do the throw/catch, but they don't have the part that's analogous to sequencing, which would be more like a ring with multiplication, I guess.
10:12:21 <edwardk> sorry, i had just remembered conal saying something, so i misread
10:12:31 <tomejaguar> augur: I get so confused between conor, conol and ro'connor :S
10:12:54 <edwardk> tomejaguar: not to mention we have an elliott  who isn't conal elliott
10:12:56 <n-dolio> Which is what MonadPlus is. You already have the multiplication part (Monad) and you add in the addition part for throw/catch.
10:13:01 <quicksilver> I thought augur said conal too, how odd.
10:13:06 <Eduard_Munteanu> Oh, hm.
10:13:16 <quicksilver> conor has cute names for the various Monoid instances using puns
10:13:25 <quicksilver> Might and Must and stuff
10:13:29 <quicksilver> I can't remember them of course
10:13:58 <n-dolio> And MonadPlus looks kind of like a ring if you squint, although I don't know how you'd actually generalize rings to get it.
10:14:08 <Eduard_Munteanu> n-dolio: it sounds like ideals seem fit for this if you want to generalize that and have an entire class of mzeros.
10:14:13 <n-dolio> Actually, semiring.
10:14:19 <tomejaguar> edwardk: I hope you're ekmett or I'm going to be very confused :D
10:14:33 <edwardk> i am =)
10:14:33 <edwardk> edk, however, is not =)
10:14:34 <elliott> we had someone with a very similar name to edwardk recently too :)
10:14:42 <merijn> tomejaguar: ekmett is his alter ego ;)
10:14:49 * edk beeps
10:14:50 <Eduard_Munteanu> I haven't thought this through though.
10:15:00 <Eduard_Munteanu> Whoa, we have an edk too?
10:15:11 <edwardk> there was also an edwardkk in case i wasn't enough for you.
10:15:16 <n-dolio> And really it's not even semiring for most things.
10:15:17 <Eduard_Munteanu> Heh.
10:15:26 <edk> if me existing weren't enough, my name is actually edward, but i shortened it
10:15:30 <n-dolio> Only seminearring.
10:15:52 <augur> tomejaguar, quicksilver: its a very common mistake :)
10:15:59 * edk has surprisingly never been confused with anyone else before he joined #haskell
10:16:01 <Eduard_Munteanu> n-dolio: heh, is that an actual name? Wouldn't surprise me given stuff like "rig"
10:16:11 <n-dolio> Yeah, it is.
10:16:12 <augur> oh yeah and we have
10:16:13 <edwardk> i'm glad i got in and secured the 'dons'-like nick while i could ;)
10:16:26 <augur> edwardk edk and edvardkk
10:16:27 <augur> or whatever
10:16:36 <edwardk> edvarkk, that's who it was
10:16:43 <Eduard_Munteanu> But people don't ask "what's an edwardk?". :)
10:17:02 <augur> but only one augur! MWAHAHA
10:17:12 <augur> agumonkey and agundry dont help :(
10:17:14 <edwardk> Eduard_Munteanu: i actually work with non-associative right seminearrings quite a bit in parsing
10:17:27 <merijn> I'm just happy that my first name is rare enough that I could just register that :p
10:17:41 <Eduard_Munteanu> edwardk: trifecta?
10:17:47 <quicksilver> augur: you should have called him pigworker :P
10:17:53 <merijn> Although people seem to be intent on continuously misspelling it my swapping the i and j around >.<
10:17:53 <augur> quicksilver: :)
10:17:55 <edwardk> Eduard_Munteanu: not in there yet
10:18:08 <augur> but do people know him as pigworker? maybe. it IS his irc handle
10:18:28 <merijn> augur: And twitter handle, etc.
10:18:29 <Eduard_Munteanu> augur: also e-pig.org is the epigram domain name
10:18:33 <augur> merijn: that too
10:18:37 <Eduard_Munteanu> (IIRC)
10:18:45 <augur> yes, it is indeed, Eduard_Munteanu
10:19:03 <quicksilver> merijn: it's easier to remember if you realise that dijkstra was named after the tensor "D_ijk"
10:19:07 <Eduard_Munteanu> Maybe "epigram" is the origin for his nick.
10:19:10 <tac> Eduard_Munteanu: oh noes D:
10:19:12 <augur> quicksilver: lolololol
10:19:14 <quicksilver> merijn: then you always get the dutch vowels right.
10:19:21 <Eduard_Munteanu> Hah.
10:19:53 <tac> RIP Epigram 2: The greatest vaporware of all of functional programming history :(
10:19:56 <merijn> quicksilver: I was tempted to register my nick with a proper unicode IJ digraph, but freenode doesn't allow unicode nicks :(
10:19:57 <geekosaur> ...whereas I went with this nick (and elsewhere) because I'm the "other" Allbery
10:20:06 <quicksilver> Eduard_Munteanu: yes, he was pigworker because he was working on epigram.
10:20:09 <augur> tac: the source is available
10:20:11 <Eduard_Munteanu> We've got enough edsgers here though.
10:27:56 <FreeFull> merijn: But merijn is completely different from merjin
10:28:23 * mauke is now known as merign
10:29:17 <merijn> FreeFull: You don't have to tell me, but native English speakers like to auto-correct ij, because that can't possibly be right :p
10:30:14 <hpaste> merijn pasted “tail recursion?” at http://lpaste.net/93138
10:30:43 <merijn> What is the best way to do that recursion?
10:31:33 <merijn> This approach isn't tail recursive, so that seems like it might lead to stack overflows, but I dunno how to make it tail recursive in a non-sucky way
10:34:32 <bergey`> Does cabal-install add -XDatatypeContexts?
10:34:58 <merijn> bergey`: Add it to what?
10:35:56 <bergey`> When I try to compile with ghc, it refuses until I add -XDatatypeContexts.  cabal install runs without complaint or warning.
10:36:09 <bergey`> This caught me by surprise.
10:36:20 <dcoutts> bergey`: your cabal package is using Haskell98
10:36:29 <dcoutts> but ghc now defaults to Haskell2010
10:36:37 <merijn> bergey`: You should fix that, DatatypeContexts is terrible
10:36:40 <bergey`> in particular: https://github.com/diagrams/diagrams-lib/blob/master/src/Diagrams/ThreeD/Types.hs
10:37:00 <dcoutts> all new cabal packages have to explicitly indicate if they want to use Haskell98 or Haskell2010
10:37:17 <bergey`> Yeah, I just rewrote it with GADT.  I'm just at risk of doing it again, if cabal doesn't warn me :/
10:37:38 <dcoutts> bergey`: just say you want to use Haskell2010 in your .cabal file
10:37:47 <dcoutts> default-language: Haskell2010
10:37:48 <bergey`> dcoutts: Thank you.
10:38:48 <shachaf> "GADTs" isn't the alternative to "DatatypeContexts" :-(
10:39:00 <FreeFull> merijn: I'm not sure if that will actually ever stack overflow
10:39:25 <FreeFull> merijn: You should run it through ghci's debugger to see what happens
10:39:31 <bergey`> shachaf: Better advice for a type which is parameterized on a type which must belong to a particular type class?
10:39:34 <geekosaur> merijn, remember that tail recursion is a strict evaluation thing, and the stack is a pattern match stack not a call stack
10:39:47 <merijn> geekosaur: I know
10:39:51 <n-dolio> Either whatever you're doing won't work without the GADT version (in which case you'll get errors anyway), or you don't need the data type context at all.
10:40:08 <merijn> geekosaur: But this is a monadic recursion
10:40:09 <n-dolio> In the latter case you just shouldn't write it.
10:40:18 <merijn> geekosaur: So you can't lazy create the list
10:41:02 <shachaf> What n-dolio said.
10:41:48 <bergey`> What sort of errors?
10:41:51 <shachaf> (Well, except it doesn't really have to do with GADTs. You can just write the context with a regular data type declaration, too.)
10:41:54 <mietek> What is the right regex lib to use with Data.Text?
10:42:02 <shachaf> s/except //
10:42:05 <mietek> text-icu?
10:42:23 <mietek> It looks like it has a different UI than Text.Regex.Posix
10:42:31 <merijn> geekosaur: An N element list means the recursion creates N entries on the stack in this code, because it can't return until the last one has succesfully returned
10:43:44 * hackagebot qrcode 0.1.2 - QR Code library in pure Haskell  http://hackage.haskell.org/package/qrcode-0.1.2 (ChrisYuen)
10:45:55 <bennofs> How can I test modules from an executable with cabal?
10:46:18 <bennofs> (I cannot use build-depends: with executables)
10:46:25 <dcoutts> bennofs: use the module directly
10:46:34 <dcoutts> ie other-modules:
10:47:01 <bennofs> dcoutts: with hs-source-dirs?
10:47:07 <merijn> ugh, I might just want to have this recursion discussion another time, my IRC connectivity is depressing >.>
10:47:20 <dcoutts> bennofs: yes, use whatever src dirs path you need so that they're visible to the test
10:47:32 <dcoutts> bennofs: btw, that works with modules used by libs too, if you want to access modules that are internal to the lib
10:47:55 <bennofs> dcoutts: Hmm, but then I need to duplicate deps
10:48:02 <dcoutts> bennofs: yes
10:48:22 <dcoutts> at least the deps used by the modules you're using
10:48:54 <bennofs> dcoutts: ok, thanks
10:51:38 <edwardk> bergey`: the advice is to not bake the constraint in but to move it to the use site. in general by baking it in like that you deny yourself a ton of useful instances.
10:52:36 <edwardk> bergey`: i used to think i wanted to do that all the time. i got better ;)
10:53:05 <bergey`> edwardk: Thanks for clarifying.  I'm pretty sure I want it in this case, but I'll discuss it with byorgey & co.
10:53:53 <bergey`> And I'll try not to get in the habit of such constraints :)
10:55:02 <edwardk> bergey`: all your instances have the Angle a => .. constraint on them. without baking it into Spherical you can then make other instances. consider if you dropped Angle a => Spherical a   then you can have Functor and Applicative.
10:55:30 <edwardk> fromSpherical = fmap convertAngle
10:55:41 <edwardk> (^+^) = liftA2 (+)
10:55:49 <edwardk> negateV = fmap negate
10:55:53 <osfameron> the cat face operator
10:55:59 <edwardk> and most of the code goes away
10:56:08 <bergey`> Mmm.  You are very convincing.
10:56:55 <edwardk> all the places you use it and need the constraint have the constraint anyways
10:57:27 <beaky> hello
10:57:35 <edwardk> containers that are needlessly restricted not to hold things by requiring you to pass dictionaries as unwanted witnesses are just not very useful
10:57:36 <jfischoff> .o.O ((^+^) kitten operator)
10:57:47 <beaky> how do typeclasses work?
10:57:55 <beaky> why do they need an implicit dictionary argument to work
10:58:03 <beaky> so that they can dispatch at runtime?
10:58:08 <beaky> ah
10:58:30 <acomar> beaky, yea they desugar to taking the dispatch dictionary as a parameter
11:00:07 <monochrom> that is not the only way to implement type class. but ok.
11:00:48 <edwardk> beaky: they can be implemented by other means. see jhc
11:01:21 <monochrom> actually, how does jhc do it? I only heard a three-word summary that I don't understand
11:01:39 <acomar> monochrom, edwardk: I'll look up how jhc does it. I'm curious what the other approaches are though.
11:02:05 <monochrom> oleg said "intensional type analysis" and I don't know what it means
11:02:24 <edwardk> they replace parametric polymorphism with bounded polymorphism, then pass in enough of the types as constructor-like things to pattern match on them.
11:02:46 <edwardk> this means that they wind up case analyzing in a pseudo-dependently typed fashion on the types
11:02:56 <osfameron> better than unintentional type analysis presumably
11:03:06 <jfischoff> bounded polymorphism ~ equalitiy constraints?
11:03:21 <thoughtpolice> yeah, JHC's core is a PTS. the compiler basically just formulates dictionary-choice as a case-statement on the type. the whole-program dead code eliminator does the rest
11:03:25 <edwardk> no, they basically make a notion of subtyping
11:03:50 <jfischoff> subtyping implemented how?
11:04:39 <edwardk> they are whole program optimizing, so they can know all the types that instantiate a given class
11:05:28 <edwardk> instead of a dictionary they pass a 'type' for each type 'a' that occurs in the type signature with class constraints on it.
11:05:49 <edwardk> then they can pattern match on it once, and specialize the code block for each possible instance.
11:05:58 <beaky> ah
11:06:12 <edwardk> one typecase per constrained parameter rather than one dictionary per constraint.
11:06:29 <beaky> so its like how c++ templates work?
11:06:49 <acomar> they claim it's more efficient because you pass fewer arguments to a function... does that actually pan out?
11:06:50 <edwardk> a bit better, because it can deal with polymorphic recursion
11:07:12 <edwardk> it can be a win, but it isn't always. MPTCs get more parameters that way
11:07:28 <acomar> interesting
11:08:44 <acomar> are there any other interesting implementations of type classes?
11:09:18 <edwardk> those 2 really are your only two extreme options, anything else would be in the middle
11:09:27 <acomar> ahh, kk
11:09:40 <edwardk> e.g. you can do an open world version of jhc's approach, but then you get worse code, etc.
11:09:49 <acomar> open world?
11:09:58 <edwardk> jhc is a whole program optimizing compiler
11:10:14 <acomar> ohh, right
11:10:17 <edwardk> the 'apply' function that they use internally knows all the possible thunks of a given type that could be passed
11:11:41 <monochrom> yikes, whole-program analysis closes the open world!
11:11:53 <edwardk> yep
11:12:10 <monochrom> or opens the closed world, from another perspective
11:12:44 <edwardk> jitting can be seen as computing successive approximations of the open world as almost-closed worlds
11:12:54 <acomar> jhc's explanation/documentation on the topic is pretty interesting
11:13:31 <acomar> it never occurred to me there was some other way to do it than dictionary passing; dictionary passing is the braindead obvious approach and I never thought past that.
11:14:11 <edwardk> the jhc approach could make other things a lot easier. e.g. type families, but it has other pain points
11:14:58 <acomar> is ghc planning to move towards whole program optimization? Or is that too complicated to consider?
11:15:16 <Eduard_Munteanu> Hm, I think my constraints newtype thingy is just a typeclass.
11:15:59 <Eduard_Munteanu> I'll just make an instance for the concrete newtype I have.
11:16:00 <edwardk> constraints newtype?
11:16:28 * thoughtpolice secretly has a branch of GHC with -fwhole-program, but it has barely gone anywhere, and cannot be evaluated yet.
11:16:31 <Eduard_Munteanu> edwardk: I wanted something like a constraints type synonym except the rhs would be hidden behind something.
11:17:00 <edwardk> like data Dict p where Dict :: p => Dict p ?
11:17:07 <thoughtpolice> edwardk: i believe at one point we talked and you wanted something like this, to do a whole-program core analysis right?
11:17:28 <edwardk> thoughtpolice: my goal has been more on the jitting side to do it post-hoc as i run
11:17:41 <edwardk> but yes, once upon a time that was a goal =)
11:17:45 <thoughtpolice> :P
11:18:33 <Eduard_Munteanu> edwardk: mm, I don't think so. I'm wrapping a Parsec-like parser in a newtype, and only using its Applicative/Alternative stuff. However I'd like to make that even more polymorphic, just like you do with Monad* classes.
11:19:25 <edwardk> not sure i follow
11:21:43 <Eduard_Munteanu> edwardk: let me put it another way: unlike type, newtype lets you make its definition private by hiding the constructor. Similarly, I was curious if I could do an analogous thing for constraint synonyms.
11:22:00 <Eduard_Munteanu> (well not only private, but it's also not transparent)
11:24:50 <Eduard_Munteanu> edwardk: back to the parsing thing, I could write parsers like   fooP :: (Parses m) => m Foo   and export them, where Parses implies Applicative etc., as well as some things I don't want users to use, say perhaps a MonadError constraint.
11:25:40 <edwardk> :t Data.Constraint.Unsafe.unsafeDeriv
11:25:41 <lambdabot> Couldn't find qualified module.
11:25:43 <Eduard_Munteanu> Using a more concrete style you can make a newtype and simply hide its constructor.
11:25:56 <Eduard_Munteanu> But I wanted to keep things more polymorphic in the parsing monad.
11:26:26 <edwardk> unsafeDerive and unsafeUnderive let you borrow instances from your newtype or oldtype for the inner or outer representation
11:26:48 <Eduard_Munteanu> Hm.
11:27:01 <Eduard_Munteanu> I'm glad it makes sense, wasn't really sure about this.
11:27:11 <edwardk> see the implementation of unsafeApplicative
11:27:16 <edwardk> http://hackage.haskell.org/packages/archive/constraints/0.3.3/doc/html/Data-Constraint-Unsafe.html
11:28:26 <Eduard_Munteanu> Hm.
11:28:49 <Eduard_Munteanu> So I'd define the "private" part as instances for said newtype.
11:28:51 <edwardk> not saying that this is a good idea ;)
11:29:06 <merijn> Do binary and/or cereal provide a better way of doing "satisfy :: Serialize a => (a -> Bool) -> Get a; satisfy p = get >>= \x -> if p x then return x else empty"
11:29:06 <merijn> ?
11:29:10 <edwardk> just that it can do what you asked
11:29:37 <edwardk> merijn: you can use the lookaheadMaybe
11:29:43 <ReinH> edwardk: hai
11:29:49 <edwardk> yo
11:30:17 <Eduard_Munteanu> edwardk: still, it means my polymorphic parsers can't use those typeclasses and their methods
11:30:35 <Eduard_Munteanu> Unless I make them concrete.
11:31:09 <edwardk> the not so serious suggestion was to put them on something related, and then bring them into scope locally in your definitions with unsafeDerive or unsafeUnderive
11:31:21 <Eduard_Munteanu> Hm.
11:31:31 <edwardk> foo = unsafeUnderive Blah $ .. program here as if you had the instances ..
11:31:47 <Eduard_Munteanu> Oh, I see.
11:32:00 <edwardk> or unsafeDerive Parser $ .. program here with instances from your underlying type
11:32:30 <edwardk> its a bit messier than that
11:32:34 <edwardk> but its a building block
11:32:49 <Eduard_Munteanu> Maybe I should just make a typeclass and hide its methods?
11:32:50 <edwardk> i think it isn't worth the pain though
11:32:55 <edwardk> blech
11:34:47 <merijn> edwardk: Where is that, I only see "lookAheadM", but that type makes no sense to me
11:35:41 <edwardk> merijn: lookAheadM runs a Get (Maybe a)  if that returns Nothing it pretends it didn't parse anything and resumes
11:35:44 <merijn> The lack of convenient literal parsing in cereal/binary is really tragic :\
11:35:51 <jfischoff> I have a file that has MonomorphismRestriction turned on it builds correctly in ghci but not with ghc, what else should I check?
11:36:52 <merijn> edwardk: Yes, but then I first need to have a "Get (Maybe a)", constructing that is likely less efficient and more code than my original "satisfy" function was
11:37:21 <hpaste> edwardk pasted “PHOAS Revisited: P is for Profunctor” at http://lpaste.net/93142
11:37:26 <monochrom> jfischoff: are you sure it is not as simple as "you lack main"?
11:37:34 <edwardk> er wrong channel for the paste
11:37:42 <edwardk> merijn: probably
11:37:43 <merijn> Because there is no "return Nothing if parse fails" function in the API
11:39:15 <jfischoff> monochrom: I bet its simple. But neither file has a main, and there is a main in the project. The error is that ghc version is specializing something to IO and ghci is specializing to `HandlerT FoundationType IO` as I would expect
11:40:21 <merijn> edwardk: It just seems odd that none of the binary parsing libraries have a notion of parsing l
11:40:27 <monochrom> then I don't know
11:40:33 <merijn> *parsing specific values
11:40:51 <jfischoff> not ExtendedDefaultRules
11:40:52 <edwardk> merijn: well, they aren't geared towards backtracking and peeking ahead
11:40:57 <edwardk> but rather for marching forward
11:41:39 <edwardk> its a difference in intent. a Get instance doesn't constantly fail and retry, but rather parses something successfully at every step and then decides what to parse next
11:41:49 <merijn> edwardk: I don't even want to backtrack, I just have terminal symbols
11:42:38 <edwardk> if you know what the symbol is to Get it then it is kinda silly to put it in the format, no? =)
11:42:46 <merijn> Like in my example, I need to parse a byte that is either 1 through 8 or an error
11:43:21 <edwardk> sure
11:44:59 <merijn> Anyway, I'll just stick with my satisfy function for now
11:47:08 <jfischoff> oh crap. I know why I have this problem. I made a one off executable
11:47:24 <jfischoff> so I have a .hi file in the same directory as my source file
11:47:39 <jfischoff> and ghc is using that first :p
11:50:18 <acyed> hello everyone
11:52:02 <jfischoff> acyed: welcome!
11:52:08 <schell> hi all
11:52:20 <jfischoff> likewise
11:52:35 <acyed> I would like to write a list of strings to a file with (mapM (appendFile "out.txt") flat9spacenewline), how do I do this without running out of memory (the list is huge)? Does it hve something to do with strict evaluation?
11:52:54 <schell> i'm having a weird issue with haskell-platform and cabal
11:53:08 <shachaf> acyed: Probably you want mapM_ instead.
11:53:41 <acyed> so mapM_ will keep the thunks from accumulating in memory?
11:53:46 <schell> after uninstalling using the uninstall script and deleting all traces of any haskell-related stuffs i've made a fresh install of the platform
11:54:09 <schell> then 'cabal install cereal'
11:55:10 <schell> i get this error:  invalid preprocessing directive
11:55:34 <schell> the line and column just refers to a hanging #-}
11:55:50 <schell> it seems to happen with almost any package
11:56:16 <schell> and i'm stumped!
11:56:37 <monochrom> schell, you need to see http://thread.gmane.org/gmane.comp.lang.haskell.cafe/107329
11:56:57 <schell> aaahhh! just the title - what a bummer...
11:56:59 <schell> :(
11:57:06 <schell> monochrom: thanks
11:57:15 <monochrom> the author is in this channel. he's carter
11:57:22 <carter> whats this?
11:57:31 <carter> schell: you have xcode 5 dont yah
11:57:33 <monochrom> it's #-}
11:58:01 <monochrom> #-} is now like a magic number! :)
11:58:02 <carter> the simplestes solution is reinstlal xcode 4.6 cli tools
11:58:10 <carter> monochrom: thats why i included it in the email
11:58:20 <carter> thank monochrom
12:00:00 <schell> yeah - i definitely have Xcode 5
12:00:22 <carter> do you need xcode 5 right now
12:00:24 <carter> or not
12:00:24 <schell> and that's a requirement for my job :( until someone starts paying me to write haskell :)
12:00:27 <carter> ok
12:00:32 <carter> schell: read the rest of the email
12:00:42 <schell> i guess i'll live on the wild side ;)
12:00:42 <carter> i give every possible "sane" workaround
12:00:59 <carter> schell: then you get to email every pkg author patches!
12:01:06 <carter> i've done that for 7.4 and 7.6
12:01:17 <carter> schell: or you can use Darin's brew tap
12:02:20 <schell> does ghc's version increment by 0.2?
12:03:21 <argiopeweb> schell: The odd versions are development.
12:03:23 <Eduard_Munteanu> Huh, why does GHC 7.6.3 complain about  newtype Test a = Test a deriving Functor   even with GeneralizedNewtypeDeriving? The error is...
12:03:29 <LambdaDusk> hi.... I know how I can use WAI to send a full file, but does anyone have a good tutorial on ResourceT or conduit that explains how I can send part of a file (e.g. skip the first x bytes, etc)
12:03:44 <schell> argiopeweb: i see
12:03:44 <Eduard_Munteanu> "Can't make a derived instance of `Functor Test' (even with cunning newtype deriving): You need -XDeriveFunctor to derive an instance for this class"
12:04:18 <Eduard_Munteanu> It's pretty trivial.
12:04:45 <elliott> GeneralizedNewtypeDeriving doesn't work like that.
12:05:04 <elliott> you'd need newtype Test a = Test (F a) for a Functor F
12:06:25 <Eduard_Munteanu> elliott: hm... I see your point. But did that behavior change recently?
12:06:31 <Eduard_Munteanu> For some reason I remember it working.
12:07:44 <Eduard_Munteanu> Maybe I'm just tired. :)
12:09:14 <int-e> newtype Foo a b = Foo (a b) deriving Functor  would work.
12:09:50 <Eduard_Munteanu> Yeah, I know.
12:10:02 <Eduard_Munteanu> I thought it also subsumed the other cases too.
12:15:14 <S_J> what is the preferred way to deal with timing in haskell? i am implementing keepalive messages for tcp so i want to set a timeout with an interval that can be chosen by the user. and on timeout i send a keepalive msg and start a timer and check that the response is received in time.
12:16:59 <dcoutts_> S_J: can just use threadDelay
12:18:11 <dcoutts_> S_J: though beware that it takes an Int, so on 32bit platforms you cannot wait all that long, if you need long waits then you need a helper to do it in a loop
12:19:19 <opqdonut> see also http://hackage.haskell.org/packages/archive/timers/0.2.0.0/doc/html/Control-Concurrent-Timer.html
12:20:34 <tdammers> running haskell-platform with git-bash in wine
12:20:37 <tdammers> quick question:
12:20:55 <tdammers> how do I get bash to use cabal from /c/users/tobias/bin/cabal instead of the one from the platform?
12:21:16 <tdammers> can I dump a .bash_profile in my ~ just like on *nix, or do I have to fiddle with the registry or some such?
12:21:39 <dcoutts_> tdammers: windows uses a %PATH% just like unix does
12:22:05 <koala_man> tdammers: you can use ~/.bash_profile in cygwin, if that's what you're using
12:22:22 <geekosaur> but pretty sure it gets set in the registry, at least if you use cmd.exe (no startup file like unixy shells)
12:23:23 <beaky> are IO functions pure
12:23:34 <Eduard_Munteanu> beaky: mostly
12:23:42 <tdammers> I'm using git-bash, which is basically msys
12:23:51 <tdammers> so ~/.bash_profile should work, yes?
12:23:54 <tdammers> let me try that
12:24:15 <Eduard_Munteanu> beaky: excluding things like unsafe*, it is, it just builds a program for the RTS to execute.
12:24:25 <beaky> so the IO monad is a pure interface to building computation?
12:25:42 <Eduard_Munteanu> beaky: you can say that, depends what you mean by pure. Obviously any program (or invocation of) does impure things at some point.
12:25:43 <beaky> and if we play by its sequencing rules and don't use unsafe*, then its pure?
12:25:46 <beaky> ah
12:26:42 <tdammers> yep, works
12:26:44 <tdammers> nice
12:26:53 <tdammers> (as nice as it gets on windows, that is)
12:33:26 <jaspervdj> My cabal-install is getting timeouts when downloading stuff from hackage right now
12:37:03 <S_J> dcoutts: but i dont want to delay the thread since it is receiving and sending and interacting witht he user...
12:37:13 <Taneb> Best way to take a random element from a set?
12:37:46 <jaspervdj> sorry, my mistake
12:37:53 <monochrom> pour set into an array. pick a random index.
12:40:29 <carter> also generate yoru random numbers in batches
12:40:37 <ezyang> Anyone have any nontrivial functions whose type only use -> and Bool?
12:40:51 <shachaf> What makes a trivial function?
12:41:06 <ezyang> Just, informally speaking
12:41:20 <shachaf> Even informally I'm not sure what you mean.
12:41:23 <shachaf> Is "not" trivial?
12:41:45 <arkeet> :t ap `asAppliedTo` (&&)
12:41:46 <lambdabot> (Bool -> Bool -> Bool) -> (Bool -> Bool) -> Bool -> Bool
12:41:50 <arkeet> is that trivial?
12:41:52 <Tene> shachaf: I'd expect "interesting" or "surprising"; it's a request for entertainment or novelty.
12:41:54 <ezyang> Well, I wrote up a theorem for proving equivalence of programs of this type
12:42:00 <Eduard_Munteanu> edwardk: this typeclasses implementation seems to work for my purpose: http://lpaste.net/93146
12:42:03 <ezyang> So I wanted to find some interesting stuff to use it on
12:42:04 <Eduard_Munteanu> Or anyone else for that matter.
12:42:14 <shachaf> Ah.
12:42:23 <Eduard_Munteanu> Grr, s/parseBool/genericMakesBool/  in that comment
12:42:35 <arkeet> @@ @djinn @type ap `asAppliedTo` (&&)
12:42:36 <lambdabot>  f a b =
12:42:36 <lambdabot>     case a False False of
12:42:36 <lambdabot>     False -> b
12:42:36 <lambdabot>     True -> case a False True of
12:42:36 <lambdabot>             False -> b
12:42:38 <lambdabot>             True -> case a True False of
12:42:39 <Eduard_Munteanu> erm, mkBool, nevermind
12:42:40 <lambdabot>                     False -> b
12:42:42 <lambdabot>                     True -> case a True True of
12:42:44 <lambdabot>                             False -> b
12:42:46 <lambdabot>                             True -> \ c -> c
12:42:54 <ezyang> @src asAppliedTo
12:42:54 <lambdabot> Source not found. stty: unknown mode: doofus
12:43:01 <monochrom> Bool -> Bool consists of a non-trivial habitant
12:43:08 <Taneb> @type asAppliedTo
12:43:09 <lambdabot> (a -> b) -> a -> a -> b
12:43:32 <arkeet> :t join . const
12:43:33 <lambdabot> (b -> a) -> b -> a
12:43:38 <monochrom> Bool consists of 2 non-trivial habitants. Bool wins
12:43:43 <Taneb> @type const id `asType` asAppliedTo
12:43:44 <lambdabot>     Not in scope: `asType'
12:43:44 <lambdabot>     Perhaps you meant one of these:
12:43:44 <lambdabot>       `asTypeOf' (imported from Prelude), `asTypeIn' (line 146)
12:43:45 <ElectroStatik> hey there lamdabot
12:43:48 <Taneb> @type const id `asTypeOf` asAppliedTo
12:43:49 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
12:43:49 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> a0
12:43:49 <lambdabot>       Actual type: (a0 -> b0) -> a0 -> a0 -> b0
12:43:56 <Taneb> @type const `asTypeOf` asAppliedTo
12:43:56 <lambdabot> (b -> b1) -> b -> b -> b1
12:44:04 <ezyang> Oh, P.S. terminating programs only
12:44:08 <arkeet> @let asType = asTypeOf traverse
12:44:09 <lambdabot>  .L.hs:145:19:
12:44:09 <lambdabot>      No instance for (Traversable t0) arising from a use of `t...
12:44:12 <arkeet> oh.
12:44:13 <edwardk> Eduard_Munteanu: fair nuff
12:44:13 <arkeet> @let asType = asTypeOf mapped
12:44:15 <lambdabot>  .L.hs:145:19:
12:44:15 <lambdabot>      No instance for (Settable f1) arising from a use of `mapp...
12:44:18 <arkeet> oh.
12:44:23 <ezyang> cuz I didn't implement step-indexed logical relations
12:44:45 <shachaf> Next you'll say that infinite types aren't allowed either.
12:44:45 <monochrom> why do you get into logical relations!
12:45:08 <ReinH> edwardk: Comonad is so lonely off by itself :( http://www.haskell.org/haskellwiki/File:Typeclassopedia-diagram.png
12:45:17 <Eduard_Munteanu> edwardk: I guess you still think it's a questionable idea. I'm not sure myself either.
12:45:40 <edwardk> ReinH: it has ComonadApply now, and that should connect to Apply and the like logically
12:46:14 <edwardk> Eduard_Munteanu: it was more a 'meh' =) i tend to like to expose a lot of implementation details and console myself by making them as generic as possible
12:46:26 <ezyang> monochrom: It's OPLSS's fault
12:46:37 <quchen> Alternative ⇒ MonadPlus is missing too.
12:46:39 <Eduard_Munteanu> Ah, I see.
12:46:41 <ezyang> I want to write a blog post about this Agda code, but I don't know what people would find interesting
12:46:44 <monochrom> sorry, what is OPLSS?
12:47:00 <edwardk> ReinH: also all the profunctor stuff would make the rigt hand side of that diagram explode
12:47:08 <ezyang> http://www.cs.uoregon.edu/research/summerschool/summer13/curriculum.html
12:47:27 <edwardk> and there aren't near enough semigroupoid variants
12:48:17 <ion> I wish the site used P2P for the videos, downloading them is sssssssssllllllllloooooooowwwwwwwwwww.
12:48:37 <tdammers> ok, so I can now build haskell projects for windows without actually using windows
12:48:40 <tdammers> nice
12:49:12 <mr-> ezyang: cool, thanks for the link
12:53:19 <jfischoff> ezyang: personally I would like help understanding what the type errors in Agda mean
12:54:46 <ezyang> jfischoff: That sounds like a hard topic to write about ^_^
12:54:59 <jfischoff> yeah
12:55:17 <Cale> They mean that you're bad and you should feel bad.
12:55:27 <jfischoff> oh well then I understand
12:55:42 <carter> BDD types
12:55:52 <carter> or
12:55:53 <carter> umm
12:56:01 <carter> whats the name of languages like Eiffel?
12:56:08 <carter> nvm
12:56:53 <carter> schell: which solution are you going for?
12:57:02 <schell> building ghc head
12:57:11 <carter> cool!
12:57:18 <schell> then i can play around with ghc-ios, which i've been meaning to do
12:57:21 <carter> ooo
12:57:27 <carter> btw theres an exmaple ghc io repo
12:57:38 <schell> i've got a lot on my plate though, i'm getting married next month :)
12:57:39 <carter> https://github.com/maxpow4h/hrac
12:57:43 <carter> congrats ?
12:57:53 <schell> thanks!
12:57:59 <schell> and thanks!
12:58:00 <carter> <high five>
12:58:07 <carter> thats one example ghcios proejct
12:58:20 <carter> @hackage sodium was allegedly developed with ios in mind
12:58:21 <lambdabot> http://hackage.haskell.org/package/sodium was allegedly developed with ios in mind
12:58:27 <carter> if you want to mix frp and ios
12:58:47 <schell> oh - is this (hrac) using ReactiveCocoa?
12:59:34 <schell> oh - looks like it's a coincidence
12:59:49 <schell> RACSignal is a class in the reactive cocoa library
12:59:57 <schell> which i use a LOT in my obj-c
13:00:12 <carter> yes
13:00:57 <carter> the main rac contributors are also big haskellers https://github.com/ReactiveCocoa/ReactiveCocoa/graphs/contributors
13:01:03 <carter> really nice
13:01:07 <carter> shockingly young
13:01:17 <carter> like, i thought they were like 30 or something
13:02:34 <schell> i'm always surprised by the relationship between age and quality of code
13:02:42 <schell> (because there really isn't any)
13:02:46 <carter> yeah
13:02:50 <schell> afaik
13:02:56 <carter> theres amazing greybeards, theres amazing younguns
13:03:05 <carter> and  everyone is equally likely to be terrible
13:03:12 <carter> or amazing
13:03:14 <carter> well
13:03:15 <carter> urm
13:03:20 <carter> statistics is hard
13:03:22 <FreeFull> The really amazing greybeards have a boon of experience
13:03:23 <schell> haha
13:03:32 <schell> i was called a greybeard last month
13:03:34 <Cale> carter: Yeah, Sodium was done by Stephen Blackheath (blackh when he's here), who was one of the people I was working with on the iOS game. It's not the FRP system we were using, but likely takes a bit of inspiration from that.
13:03:41 <schell> i didn't know how to take it
13:03:53 <carter> schell: do you have grey in your beard?
13:03:56 <carter> are you over 30?
13:04:13 <carter> greybeard can also just mean "not a noob"
13:04:25 <schell> i can't even grow a beard but no, and not yet
13:04:27 <carter> "has  scars from engineering gone wrong"
13:04:36 <schell> i will be 30 on Oct. 6th
13:04:49 <schell> haha - right
13:04:49 <elliott> looks like sodium got weird since I last looked at it
13:05:07 <carter> "… and that is why we don't upgrade to new software that isn't a bug fix till at least 1 month after the intial release"
13:05:09 <carter> elliott: how so?
13:05:16 <elliott> weird typeclasses and stuff.
13:05:27 <carter> like what?
13:05:41 <elliott> like Context.
13:06:01 <carter> if i'm reading it right, thats for parallelism thigns
13:06:54 <carter> schell: speaking of people focusing on weird things-- i was talking with someone yesterday, and they kept on asking me about what i did in grad school, rather than wha ti've been up to for the past nearly 2 years
13:07:48 <schell> maybe your thesis is 'more official' in their minds?
13:08:18 <sm> carter: just curious, how does lines like objc_import [...] (16) work in https://github.com/maxpow4h/hrac/blob/master/example/app/AppDelegate.hs ?
13:08:29 <schell> i have no clue why people give value to the things they do - most of the time
13:08:37 <carter> https://github.com/maxpow4h/hrac/blob/master/example/app/AppDelegate.hs#L9
13:08:40 <carter> language.inline.c
13:08:48 <FreeFull> sm: Template Haskell
13:08:53 <carter> schell: nope, they thought i was too quantitative for them
13:09:04 <carter> but they didn't ask about ANY of the engineering i've been doing for the past 2 years
13:09:20 <schell> carter: that's odd - engineers are supposed to be quantitative
13:09:30 <sm> carter: ok, but this seems to be at top level, not inside a quasi quoted block.. and I see no custom preprocessor at the top
13:09:42 <carter> sm look at the make file
13:09:46 <schell> carter: i can understand someone coming to that conclusion if they're thinking about dating you, though
13:10:35 <carter> Sm also jsut write a ticket on the tracker
13:10:38 <sm> carter: still not seeing the magic :)
13:10:44 <carter> asking for some explanation
13:11:19 <carter> sm : also https://github.com/mchakravarty/language-c-inline
13:11:27 <carter> schell: this is turning into a -blah topic
13:11:29 <carter> meet yah ove rthere?
13:11:31 <sm> I'll check that out. thanks
13:11:39 <sm> sounds pretty cool
13:14:27 <schell> carter: :)
13:18:57 * hackagebot GenI 0.24 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.24 (EricKow)
13:18:59 * hackagebot geni-gui 0.24 - GenI graphical user interface  http://hackage.haskell.org/package/geni-gui-0.24 (EricKow)
13:19:01 * hackagebot geniserver 0.8 - Simple HTTP server for GenI results  http://hackage.haskell.org/package/geniserver-0.8 (EricKow)
13:22:48 <gamegoblin> Hello all. Imperative programmer here trying to learn Haskell. I'd like to write a function that takes a filename as a string, and returns the contents of that file as a string. Why am I stupid or why is this so difficult for me...?
13:23:07 <elliott> :t readFile
13:23:08 <lambdabot> FilePath -> IO String
13:23:23 <elliott> it doesn't return the contents of the file as a string though.
13:23:29 <gamegoblin> How can I get a regular string for an IO String, is my problem
13:23:32 <koala_man> gamegoblin: you can't write a f :: String -> String for that. you have to run it in the IO monad
13:23:35 <elliott> @where introduction-to-io
13:23:35 <lambdabot> I know nothing about introduction-to-io.
13:23:37 <elliott> @where io
13:23:37 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
13:23:37 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
13:23:39 <elliott> omg.
13:23:40 <shachaf> gamegoblin: The FAQ has a good answer to your question.
13:23:43 <elliott> @wiki Introduction to IO
13:23:43 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:23:43 <shachaf> @where faq
13:23:43 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:23:47 <elliott> gamegoblin: try reading that ^
13:23:54 <elliott> ...uh, the one before what shachaf said. but that one too.
13:24:15 <shachaf> The FAQ has elliott's link in it, I think, and also other useful background.
13:24:51 <gamegoblin> K... thanks. Monads are still voodoo to me... I'll probably be back soon
13:25:41 <tdammers> *cough* burritos *cough*
13:26:04 * tdammers sticks a needle into a burrito that looks suspiciously like a person
13:26:06 <gamegoblin> so just as a general flow what I'll have to do is: go into IO monad, get IO string from my file, do stuff with that string, then leave the monad?
13:26:10 <shachaf> tdammers: Stop it, you're being unhelpful.
13:26:25 <tdammers> sorry
13:26:41 <tdammers> I'll be in -blah
13:26:44 <shachaf> gamegoblin: IO doesn't work the way you think. Look at the FAQ and elliott's link.
13:26:49 <gamegoblin> k, reading now
13:27:28 <Cale> gamegoblin: The IO monad is not a place
13:27:51 <Cale> gamegoblin: Saying that IO is a monad just says that there are certain ways to combine IO actions together.
13:29:18 <Cale> gamegoblin: There isn't a proper function which takes a filename as a String and produces the contents of that file as a String result, because such a thing would have to produce different results for the same input, if the file were to change.
13:30:15 <Cale> gamegoblin: However, there's a function, called readFile, which takes a filename as a String, and gives you an IO action of type IO String, which is like a program you can run as part of any other IO action (and in particular main) in order to get a String.
13:30:44 <khyperia> Cale, yes there is, it's called (unsafePerformIO . readFile) :D
13:30:51 <Cale> gamegoblin: So, you could have, e.g.  main = do contents <- readFile "myFile.txt"; putStrLn contents
13:31:01 <Cale> khyperia: unsafePerformIO isn't a proper function.
13:31:08 <khyperia> heh
13:31:30 <Cale> (it has function type, but it's not a function, it's a low-level primitive that's not meant for casual use)
13:31:59 <khyperia> good point
13:36:47 <exicer> Has anyone got experience using http-conduit ?
13:36:58 <exicer> I can't get my head around how to use httpLbs
13:37:46 <exicer> I don't know what a MonadBaseControl is, nor a MonadResource
13:38:09 <jfischoff> I'm using it right now
13:38:09 <Clint> they are typeclasses
13:38:13 <applicative> i'm not really need to
13:38:17 <applicative> bah
13:38:26 <applicative> i'm not sure you really need to know
13:38:43 <jfischoff> I don't completely understand those type classes either but what applicative said
13:38:46 <exicer> Well, I can see examples of how httpLbs is used, but I don't understand them :[
13:38:56 <jfischoff> what are you trying to do?
13:39:05 <exicer> So far, nothing complicated at all
13:39:24 <exicer> I just want to print the http from some random url
13:39:27 <exicer> what
13:39:29 <exicer> html
13:39:41 <jfischoff> simpleHttp url
13:39:55 <exicer> I know I can do it with simpleHttp, but eventually I will want to do something more complicated
13:40:11 <jfischoff> like what?
13:40:22 <exicer> well, scraping a site, but keeping session information
13:40:28 <exicer> which I understand managers let me do
13:40:35 <exicer> with a cookiejar
13:40:55 <jfischoff> http://hackage.haskell.org/package/http-conduit-browser
13:41:25 <BrianHV> will there be an update to ghc 7.6 that's compatible with xcode 5?
13:41:35 <jfischoff> wait that is not exactly what I thought it was
13:41:43 <sbaugh> Hey, I'm trying to follow this tutorial: http://jonathan.tang.name/files/scheme_in_48/tutorial/parser.html but I'm having trouble with part 2 of Exercise 1, if anyone wants to take a look at it
13:41:50 <jfischoff> yeah when you need that ask, I can help you
13:42:00 <exicer> jfischoff: Yeah, I had seen that. I just thought it might be a good opportunity for me to understand some "real" code
13:42:08 <sbaugh> (I've written a scheme interpreter before so this seemed like a good way to learn haskell)
13:42:15 <exicer> Essentially I have completely failed though :p
13:42:20 <jfischoff> haha
13:42:57 <monoidal> sbaugh: are you doing the question "explicit sequencing with the >>= operator"?
13:43:08 <sbaugh> monoidal: yes
13:43:31 <monoidal> sbaugh: can you write liftM using >>=?
13:43:56 <sbaugh> monoidal: I'm not sure
13:44:17 <applicative> parseNumber = liftM (Number . read) $ many1 digit , with >>=
13:44:29 <monoidal> sbaugh: this is the core. Remember types: liftM :: (a -> b) -> m a -> m b, (>>=) :: m a -> (a -> m b) -> m b (I skipped the monad constraint)
13:44:35 <monoidal> sbaugh: you will also need return :: a -> m a
13:44:47 <monoidal> sbaugh: sorry, let me write it more clearly
13:44:53 <monoidal> liftM :: (a -> b) -> Parser a -> Parser b
13:45:03 <monoidal> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
13:45:10 <monoidal> return :: a -> Parser a
13:45:24 <monoidal> sbaugh: with those types, try implementing liftM in terms of >>= and return
13:45:36 <FreeFull> You can make liftM out of (>>=)
13:46:11 <sbaugh> okay, I'll try it
13:47:21 <applicative> i assume the exercise also wants many1 digit to be done with >>= ?
13:48:52 <FreeFull> I don't see the point of monadic parsing
13:49:59 <sbaugh> applicative: so that was the other kind of basic misunderstanding I had - I tried to replace "many1 digit" from the original with "foo <- many1 digit\n liftM (Number . read) $ foo" but the types didn't match
13:51:17 <monoidal> sbaugh: IMO in this exercise you are not asked to rewrite many1 digit yet
13:51:37 <applicative> do ds <- many1 digit ; return (Number (read ds))
13:52:01 <applicative> i think monoidal must be right
13:53:10 <applicative> you dont have to liftM or fmap or <$> "Number . read" over the digits recovered, since they're just the digits, so to say;  you apply Number . read to them
13:53:26 <applicative> but then you have to use 'return' to stay in the parser monad
13:53:58 <applicative> so the last line would be something like: return $ Number (read dgs)
13:57:18 <sbaugh> so the type of >>= is which of these: (m a) -> ((a -> m b) -> m b) or (m a -> (a -> m b)) -> m b ?
13:57:42 <elliott> former. (->) associates right
14:02:35 <exicer> Okay, so, this is wrong, but I don't know why.. http://lpaste.net/93148
14:02:50 <exicer> Could someone explain why ?
14:04:25 <BrianHV> exicer: are you getting a compiler error?
14:04:32 <exicer> Yes
14:04:57 <BrianHV> exicer: what error are you getting?
14:05:15 <exicer> http://lpaste.net/60736936419000320
14:05:44 <exicer> I haven't been able to work out what a MonadResource IO is though :s
14:06:31 <apples> you might have to use runResourceT
14:06:33 <sbaugh> yay
14:06:52 <exicer> apples: I have seen mention of that..
14:06:56 <monoidal> sbaugh: what did you get?
14:07:18 <sbaugh> applicative: monoidal: hooray, I think I did it: many1 digit >>= (return . read)
14:07:35 <sbaugh> (and then return $ Number on that)
14:07:53 <monoidal> sbaugh: how do you write the whole thing?
14:08:32 <Shin-LaC> I want to define a binary search tree, so I need the keys to be ordered. but it seems that putting an Ord k class constraint on the constructor won't help. I found this page <http://www.haskell.org/haskellwiki/Data_declaration_with_constraint> which hints at using GADTs, but then says "There has been some discussion about whether it is sensible to want this."
14:08:38 <Shin-LaC> so I'm a bit confused
14:09:06 <kylcarte> exicer: The error is reminding you that IO by itself is not sufficient for managing the resource (properly closing it automatically when you're done).
14:09:08 <sbaugh> monoidal: "bar <- many1 digit >>= (return . read); return $ Number bar" was what I was doing
14:09:10 <monoidal> Shin-LaC: what is is discouraged is: data Ord a => Tree a = ..
14:09:26 <kylcarte> Why not use the example the docs give (http://hackage.haskell.org/packages/archive/http-conduit/1.9.5.1/doc/html/Network-HTTP-Conduit.html)
14:09:30 <Shin-LaC> monoidal: why is it discouraged?
14:09:31 <shachaf> I don't know why people ever bring up GADTs.
14:09:34 <monoidal> Shin-Lac: what is encouraged is: data Tree k a where Leaf :: Ord k => Tree k a et
14:09:35 <kylcarte> of 'withManager'?
14:09:59 <monoidal> sbaugh: This is good, but you still have the do-notation.
14:10:15 <exicer> kylcarte: I actually just saw them..
14:10:21 <exicer> So this works: http://lpaste.net/93149
14:10:21 <monoidal> sbaugh: can you place Number inside >>= so it will not be needed?
14:10:29 <shachaf> "data C a => T a = D a" and "data T a = C a => D a" are both valid and neither is a GADT.
14:10:31 <sbaugh> monoidal: I will see
14:10:34 <exicer> I think I don't really get runResourceT
14:10:39 <shachaf> (Well, the former isn't valid anymore in H2010.)
14:10:40 <exicer> Guess I should do some reading
14:11:02 <elliott> I don't think H2010 removed stupid theta
14:11:08 <shachaf> Oh, it didn't?
14:11:09 <elliott> or was it n+k it didn't remove?
14:11:23 <monoidal> they removed n+k. datatypecontexts will be removed in next revision
14:11:24 <shachaf> I guess it didn't remove that.
14:11:28 <shachaf> Oh well.
14:11:39 <shachaf> stupid stupid theta
14:11:40 <kylcarte> exicer: look at the type sig of runResourceT. It doesn't take an 'IO a', it takes a 'ResourceT m a'
14:11:43 <quchen> Wait, *that* is what StupidTheta is? I saw it in the source and was wondering
14:11:47 <kylcarte> as per here: http://hackage.haskell.org/packages/archive/resourcet/0.4.8/doc/html/Control-Monad-Trans-Resource.html
14:11:50 <monoidal> it was announced that there will be no Haskell 2011, but NoDatatypeContexts is accepted
14:12:00 <elliott> an interesting exercise is to try and imagine a language revision more conservative than H2010
14:12:12 <dmj`> why doesn't Data.Graph contain bfs?
14:12:21 <kylcarte> exicer: so, that block that you're passing to runResourceT is of type 'ResourceT IO ()'
14:12:24 <exicer> kylcarte:  Hmm, okay. This is the first time I've really (as in, not looking at rwh etc) come across monad transformers
14:12:40 <monoidal> quchen: yeah, stupid theta is C in data C a => D a = ...
14:12:58 <exicer> It seems that I don't quite get them yet! Thanks for the help, I'll have a read about ResourceT in the docs
14:13:09 <Shin-LaC> monoidal: ok, so basically I should use the GADT syntax because then the constraint works as expected
14:13:16 <kylcarte> exicer: np! good luck.
14:13:32 <Shin-LaC> monoidal: so, unlike what the wiki says, the idea is now noncontroversial?
14:13:38 <quchen> monoidal: But that's not equivalent to "data B a = C a ⇒ D a"?
14:13:43 <monoidal> Shin-Lac: Yes. shachaf pointed in fact you don't need the GADT syntax
14:13:48 <sbaugh> monoidal: many1 digit >>= (return . read) >>= (return . Number)
14:14:00 <monoidal> quchen: It's not equivalent. For example, you can have many constructors with different contexts
14:14:12 <monoidal> sbaugh: Good. Can you use only one >>= ?
14:14:34 <monoidal> Sin-LaC: datatype contexts data C a => D a = ... are still controversial and will probably be removed
14:14:50 <monoidal> Sin-Lac: constraints on constructors data D a = C a => ... | ... are OK
14:15:06 <monoidal> *Shin-LaC
14:15:09 <quchen> "OK"
14:15:23 <Cale> Probably the former should have always meant the latter (distributed across all the constructors)
14:15:36 <Cale> but at the time, that would have been quite a stretch for the language spec to include
14:15:42 <Shin-LaC> monoidal: if I put the constraint on the constructor, will it then affect other functions defined for the type?
14:15:57 <monoidal> quchen: I believe you need context C a to match on stupid theta (while the normal thing to do is providing the context by matching)
14:15:59 <Shin-LaC> for example, when I have an insert function for my tree, will haskell know that the key argument has to be Ord?
14:16:07 <Shin-LaC> or do I need to add the constraint to each function?
14:16:58 <monoidal> Shin-LaC: afaik constraints like Ord k are written for functions such as insert, even if they are not strictly needed
14:17:30 <monoidal> Shin-LaC: or... I'll back the last statement
14:18:08 <monochrom> Map's and Set's insert? they need Ord too :)
14:18:11 <Eduard_Munteanu> Say I have  type FooClass f = (Functor f, Monad f);  newtype Foo f a = Foo (f a);   , can I derive FooClass somehow, without deriving Functor and Monad explicitly?
14:18:15 <quchen> monoidal: I don't understand. Suppose I have "data Ord a ⇒ Id a = Id a". How is "f (Just x) = x; f Nothing = 0" affected? Does that mean I need an Ord instance for the Maybe argument for it to work?
14:18:25 <sbaugh> monoidal: many1 digit >>= (return . Number . read) hooray for purity (although the parentheses count is a little low for my taste :) )
14:18:34 <monoidal> quchen: I think so
14:18:39 <monochrom> otoh singleton and empty don't impose Ord on you :)
14:18:49 <monoidal> quchen: that's why it's called stupid
14:18:59 <monoidal> sbaugh: Yes, this is correct.
14:18:59 <sbaugh> monoidal: thanks for the help
14:19:05 <quchen> monoidal: That is pretty crazy and I'm glad it doesn't exist (... in pratice at least)
14:19:39 <monoidal> quchen: oh wait. I did not understand your example
14:19:42 <quchen> sbaugh: If your taste is violated by that function anyway, just leave away the parenthesis you have there as well. :-)
14:19:48 <Eduard_Munteanu> I tried StandaloneDeriving and that doesn't do it either.
14:19:49 <monoidal> quchen: For f (Id x) = x you need the constraint
14:20:12 <shachaf> Eduard_Munteanu: It's not a class, so I doubt you can derive it.
14:20:14 <quchen> monoidal: "The constraint" is "Ord x ⇒ Id x"?
14:20:24 <monoidal> quchen: your f is unrelated to Id
14:20:34 <quchen> Oh, right. Silly example.
14:20:38 <Eduard_Munteanu> shachaf: sure, I just want to avoid typing out all classes
14:21:28 <quchen> Anyway, instead of requiring Ord for the type argument, the entire type must be Ord, that's the difference then. So "Ord a ⇒ Id a = Id a" requires me to write an Ord instance for Id or it won't work in patterns?
14:22:08 <monoidal> quchen: it requires you to write an instance for X if you want to match on Id x where x :: X
14:22:10 <quchen> It's really hard to come up with this when you know it's called "stupid". It's a constant battle between "this doesn't make much sense" and "hey it's stupid so maybe that's what it is" ;-)
14:23:20 <quchen> monoidal: Ah, and when you have "data Id x = Ord x ⇒ Id x", you can match without the Ord instance. In this scenario, the Ord will only be needed to construct an Id value.
14:23:21 <quchen> ..?
14:23:47 <monoidal> quchen: Yes. But if you have "data Ord x => Id x = Id x", you cannot match without the Ord instance
14:24:12 <quchen> I see, thanks for the explanation.
14:25:07 <quchen> monoidal: New question, why is "data Tree k a where Leaf :: Ord k => Tree k a" encouraged?
14:25:11 <shachaf> You also can't create an Id without the Ord instance.
14:25:17 <quchen> Isn't that quite similar to requiring Ord for the Leaf constructor?
14:25:35 <quchen> Or is the difference that *only* Leaf, not EmptyTree, requires Ord?
14:25:44 <quchen> (If that was added to the type)
14:25:49 * shachaf wonders why people switch to GADT syntax all of a sudden for that.
14:25:55 <n-dolio> Who said it was encouraged?
14:26:26 <quchen> n-dolio: <monoidal> Shin-Lac: what is encouraged is: data Tree k a where Leaf :: Ord k => Tree k a et
14:26:29 <monoidal> I did. and I'm not sure if that was correct
14:26:55 <n-dolio> I don't see why you'd do that particular case.
14:27:06 <monoidal> the goal is to enforce that you cannot construct Leaf without ordering on the keys
14:27:11 <n-dolio> Why?
14:27:16 <ocharles> merijn: any idea why vim2hs has randomly started having a different background colour for function composition and the other substitutions?
14:27:20 <ocharles> (you are the vim2hs dude, right?)
14:27:43 <Shin-LaC> should I try to make my tree type an instance of Data.Collections.Map?
14:27:55 <monoidal> if Leaf is meant to be a BST, it makes no sense to speak about e.g. Leaf not
14:28:32 <n-dolio> Unless you have some plan that gains by getting back the dictionary in the leaf case, I see no reason for it.
14:29:23 <quchen> So what would be the correct GADT approach here that shachaf mentioned?
14:29:35 <shachaf> Correct approach to what?
14:29:47 <n-dolio> And I think it's generally a bad idea to do things like enforcing that trivial cases only work for some specific use case just because.
14:30:07 <shachaf> I agrolio.
14:30:07 <quchen> shachaf: The approach that was not taken, which made you say you wondered why nobody ever suggests GADTs.
14:30:25 <shachaf> ?
14:30:38 <n-dolio> If you want to ensure that a type is a BST, you have to make it abstract, because otherwise you don't know that it's actually a BST, even if it has the Ord constraint enforced.
14:31:27 <n-dolio> And it's probably not inconvenient for most of the BST functions to take the dictionary, rather than packaging it in the leaves.
14:32:26 <monoidal> hm. I'm convinced.
14:32:27 <monochrom> quchen: do you mean this? data Joy a where Ctor :: Ord a => a -> Joy a
14:32:48 <monochrom> this Ctor will insist on having Ord
14:32:59 <shachaf> data Joy a = Ord a => Ctor a -- same thing with the old syntax
14:33:03 <n-dolio> That is the reason that, even if the matching-requires-dictionaries thing weren't true, data type contexts would be a bad idea.
14:33:56 <n-dolio> Because, for instance, they lead to types like Complex, which you can't (couldn't?) use for Gaussian integers, just because.
14:34:03 <quchen> monochrom: monoidal said "what is is discouraged is: data Ord a => Tree a = ...", to which shachaf responded that GADTs might be the way to go here. I wonder what he meant specifically.
14:34:09 <wojtekM_> Will Hayoo be back?
14:34:21 <shachaf> quchen: I don't think I ever said GADTs might be the way to go.
14:34:36 <monoidal> quchen: shachaf meant that I use gadt syntax when normal syntax can be used
14:34:38 <shachaf> I said a few times that I don't see why people bring GADT syntax into it.
14:35:06 <shachaf> If you use it you might as well use it in both examples. Otherwise you're making things look confusing because of the different syntax.
14:35:18 <quchen> Oh, then it's a language issue and I learned something about the use of "ever" by accident.
14:35:27 <quchen> Sorry for the confusion.
14:35:34 <Shin-LaC> shachaf: but if you use GADTs and you pattern-match on Ctor a, then you will be in an Ord a context, right?
14:35:36 <monoidal> n-dolio: I don't think that's the root of the problem with Complex
14:35:44 <Shin-LaC> if you use the non-GADT syntax, you won't be
14:35:49 <Shin-LaC> that's the difference, it seems
14:35:55 <shachaf> Shin-LaC: No, syntax is just syntax.
14:35:57 <quchen> So in other news, "don't put the Ord in a Tree type directly no matter what extensions" is still valid then?
14:36:01 <monoidal> n-dolio: Complex has problems because Num has abs, and abs for Complex Integer is not Integer
14:36:14 <n-dolio> That is a separate problem.
14:36:30 <monoidal> n-dolio: what is the original problem, then?
14:36:41 <monochrom> I will abstain from endorsing any simple rule of thumb.
14:37:06 <Cale> monoidal: It's a separate problem because the Num instance could be qualified
14:37:32 <n-dolio> data RealFloat a => Complex a = Complex a a
14:37:33 <Shin-LaC> shachaf: this seems to disagree: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt-style
14:37:36 <Cale> (though, that probably wouldn't be the most helpful thing)
14:37:44 <n-dolio> You can't put anything but RealFloats in a Complex, because... no reason.
14:37:55 <Shin-LaC> The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching.
14:38:13 <Cale> The fact that there would be a Num instance already would mean that you still couldn't *practically* use the type for Gaussian integers.
14:38:30 <shachaf> Shin-LaC: data Set a = Eq a => MkSet [a]
14:38:43 <Cale> But then you could complain that abs should not be in Num, and you'd probably be right.
14:39:16 <monoidal> n-dolio: as far as I can tell that was removed. But if it was Num a => Complex a, it would not be *that* problematic IMO
14:39:21 <latro`a> where is the Foldable instance for Map exported?
14:39:24 <monoidal> n-dolio: (assuming Num was not broken as it is now)
14:39:32 <n-dolio> It is still a pointless thing to do.
14:39:54 <shachaf> Pointless would be liftA2 (=>) Num Complex
14:39:57 <n-dolio> And maybe I want to use some other numeric hierarchy that's sane.
14:40:12 <n-dolio> But I can't, because you've forced me to only use Nums.
14:40:15 <Shin-LaC> shachaf: but that was not in haskell 98, right?
14:40:25 <shachaf> Shin-LaC: No, but neither are GADTs.
14:40:32 <Shin-LaC> I see
14:40:34 <ReinH> edwardk: what is the best way to say that Option can make any semigroup a monoid? It's not "free" right?
14:40:53 <ReinH> (or, generally, semigroup + arbitrary id element = monoid)
14:40:55 <edwardk> sure it is
14:40:59 <ReinH> ok :)
14:40:59 <monoidal> ReinH: I believe it's adjoint functor to Semigroup -> Monoid
14:41:03 <ReinH> then I was right :)
14:41:03 <quchen> Option? In my Haskell?
14:41:15 <hpc> quchen: Maybe, Maybe not
14:41:18 <edwardk> quchen: i had to call it something
14:41:19 <ReinH> there it is
14:41:26 <shachaf> monoidal: You mean to Monoid -> Semigroup?
14:41:29 <monoidal> ReinH: I mean, adjoint to forgetful Monoid -> Semigroup
14:42:02 <quchen> edwardk: Oh, so Option is edwardk-Maybe with a different Monoid instance?
14:42:05 <ReinH> yep
14:42:10 <edwardk> quchen: yeah
14:42:35 <edwardk> quchen: its Maybe with instance Semigroup a => Monoid (Option a) instead of the retarded one
14:42:38 <unK_> http://lpaste.net/93151 does anyone know why this yields undefined, considering that >>= is lazy?
14:42:54 <ReinH> quchen: quchen http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Option
14:42:59 <quchen> edwardk: I suspected that.
14:43:00 <Cale> Yeah, it's one half of the free/forgetful pair
14:43:06 <ReinH> Cale: yep :)
14:43:15 <monochrom> unK_: perhaps it's IO that breaks it
14:43:24 <ReinH> free functor it is :)
14:43:46 <unK_> monochrom: yeah, but that seems weird
14:44:46 <monoidal> unK_: if it was (liftIO (putStrLn "bar") >> undefined) >>= ... would you expect to see "bar" and "foo"?
14:45:31 <monochrom> undefined >> liftIO p =
14:45:44 <monochrom> oh, I can lpaste the expansion
14:46:03 <kylcarte> unK_: it appears to be lazy in the result value, not the whole StateT () IO ... value
14:46:20 <kylcarte> unK_: try replacing 'undefined' with 'return undefined'
14:46:29 <kylcarte> in your original example
14:46:57 <unK_> monochrom: yeah. is the expectation wrong?
14:47:11 <unK_> oh, sorry, monoidal
14:47:13 <unK_> ^
14:47:41 <monoidal> unK_: but what if the "undefined" was in fact liftIO (putStrLn "baz")? You need to evaluate it to see if there's a possible IO action there
14:48:21 <Hari`> hi again
14:48:39 <kylcarte> monoidal: yes, thank you. better said.
14:49:01 <ocharles> mm_freak: I wrote that between wire, how can I contribute it?
14:49:21 <hpaste> monochrom annotated “No title” with “expansion” at http://lpaste.net/93151#a93152
14:49:39 <monochrom> unK_: http://lpaste.net/93151#a93152, or just reload yours
14:50:41 <quchen> edwardk: By "retarded instance" you meant that a Semigroup a is sufficient to define a Monoid (Maybe a), or am I overlooking something
14:51:47 <ocharles> mm_freak: though I think "between w1 w2" might be better than using (a, Event b, Event c)
14:52:04 <unK_> monochrom: ohh. I see now, thanks.
14:53:51 <edwardk> quchen: exactly that
14:54:04 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/phoas  -- anyone feel like proof-reading?
14:57:20 <kylcarte> edwardk: sure, I'll look it over.
15:04:06 <bitonic> can I use a cabal sandbox without a cabal file?  e.g. compile a file linking it to some packages in the sandbox
15:05:46 <edwardk> kylcarte: thanks =)
15:07:37 <johnw> edwardk: I love Data.Semigroup
15:08:04 <edwardk> it really is quite convenient
15:08:15 <johnw> yeah, I'm going to just drop my use of Data.Monoid from this point
15:08:26 <shachaf> i love data.monoid
15:08:28 <shachaf> it is so easy
15:08:51 <edwardk> i set up Data.Semigroup so you can just import it and get all the Monoid stuff with no conflicts
15:08:54 <bitonic> how come so many links are broken on hackage's haddock?
15:08:56 <johnw> yep, I noticed that
15:08:58 <quchen> That joke's funniness seems to go like tan(time).
15:08:59 <johnw> and super-appreciate it
15:09:09 <bitonic> it links to `file://' stuff
15:09:29 <bitonic> e.g. the link to `Whole' in <http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html>
15:09:53 <edwardk> a year or so after i wrote semigroups folks finally agreed to take (<>) for Data.Monoid, so originally there were no conflicts at all
15:10:13 <johnw> yeah
15:10:30 <johnw> i just changed my prior uses of <> to `mappend`
15:10:36 <johnw> since I'm using semigroups more than monoids most of the time
15:10:49 <xico> hello.
15:10:52 <quchen> Problem is Semigroups (or absence of it) isn't annoying enough for a Semigroup ⇒ Monoid proposal.
15:11:01 <johnw> such a proposal has been suggested
15:11:03 <johnw> by me, in fact
15:11:16 <quchen> Add "successful" to that sentence then.
15:11:18 <johnw> but I was pretty much shot down and full of holes by the endo f it
15:11:19 <xico> what would a nicer way to write: f . g &&& f . h
15:11:30 <johnw> @pl \f g h -> f . g &&& f . h
15:11:33 <lambdabot> ap (flip . ((.) .) . ((&&&) .) . (.)) (.)
15:11:33 <lambdabot> optimization suspended, use @pl-resume to continue.
15:11:42 <johnw> well, not that surely
15:11:46 <xico> :)
15:11:46 <shachaf> No, @pl is not "a nicer way".
15:12:27 <Cale> What non-monoid semigroups are people using?
15:12:37 <johnw> i used Max yesterday
15:12:38 <benmachine> :t \f g h -> over both f . (g &&& h)
15:12:39 <lambdabot> (c' -> b) -> (b1 -> c') -> (b1 -> c') -> b1 -> (b, b)
15:12:40 <quchen> both f . (g && h)
15:12:59 <xico> quchen: is it lens-y?
15:13:00 <quchen> (How many mistakes did I just put in there? Wow)
15:13:11 <shachaf> You might prefer (\f g h -> (f *** f) . (g &&& h))
15:13:15 <shachaf> If you're into "those operators".
15:13:39 <benmachine> tbh I think f . g &&& f . h is already not bad
15:13:50 <quchen> It is not.
15:14:00 <Eduard_Munteanu> Hm, is it me, or parsers are just(tm) store comonads?
15:14:31 <haasn> ‘parsers’?
15:14:54 <Eduard_Munteanu> haasn: think of Parsec
15:14:57 <benmachine> Store is Store s a = Store s (s -> a), right?
15:15:02 <haasn> benmachine: yes
15:15:03 <Eduard_Munteanu> benmachine: yes
15:15:13 <quchen> You mean Parser a = a → [(String, a)]?
15:15:30 <quchen> Isn't there this thing that something can't be both a Comonad and a Monad?
15:15:42 <benmachine> quchen: String → [(String,a)]
15:15:49 <quchen> Woops, yes.
15:15:49 <haasn> quchen: Identity
15:15:51 <Eduard_Munteanu> More like Parsec's Parser type, but same idea.
15:15:58 <quchen> haasn: Something nontrivial then?
15:16:03 <benmachine> quchen: streams
15:16:04 <shachaf> Stream
15:16:05 <haasn> NonEmpty?
15:16:09 <monoidal> quchen: (->) M where M a monoid
15:16:10 <quchen> Hm right.
15:16:18 <benmachine> (,) m where m is a monoid
15:16:23 <Eduard_Munteanu> quchen: it can be both although they don't have to be interchangeable
15:16:24 <shachaf> (,) m where -- sigh.
15:16:36 <benmachine> shachaf: sry :P
15:16:46 <shachaf> Well, the monad instance for (m ->) requires that m is a comonoid!
15:16:50 <shachaf> So there.
15:17:09 <benmachine> shachaf: ...interesting
15:17:26 <latro`a> quchen, my understanding is that though every *categorical* monad induces a comonad, the categories involved for the comonad needn't be Hask
15:17:28 <haasn> good old class Comonoid m where comappend :: m -> (m, m); counit :: m -> ()
15:17:36 <quchen> Weren't comonoids pretty strange ceatures?
15:17:37 <monoidal> ditto with comonad instance for (m,)
15:17:46 <shachaf> Yep.
15:17:46 <hpaste> kingsley pasted “backward functions, y u so cray-cray” at http://lpaste.net/3667715278361329664
15:17:48 <quchen> haasn: Ah yes, that one. Plus some really odd laws.
15:18:00 <KingsleyT> can someone help me out with this?
15:18:07 <latro`a> erm, *needn't be Hask even when the categories for the monad are Hask
15:18:09 <Eduard_Munteanu> Anyway, runParser is just 'extract' and (=>>) is a rather useful combinator that runs a parser and puts the result back into another for further processing.
15:18:16 <KingsleyT> I have a feeling it's simple but I'm just not getting it
15:18:41 <monoidal> KingsleyT: it's pattern matching
15:18:42 <haasn> quchen: just associativity and unit laws, but basically they require that comappend x = (x, x)
15:18:58 <monoidal> KingsleyT: A list [1,2,3] is equivalent to 1:[2,3]
15:18:59 <monochrom> if firstname equals "hello", then f equals 'h'
15:19:16 <monoidal> KingsleyT: you can write case x of h:t -> ... to get h as x's head and t as x's tail
15:19:27 <Eduard_Munteanu> Well, except for the fact a parser's input (or Store's focus) is kept separate.
15:19:29 <monochrom> you are allowed the full "pattern = rhs", not just "var = rhs"
15:19:34 <quchen> haasn: Associativity?
15:19:48 <quchen> haasn: And unit laws, for that matter?
15:19:52 <monoidal> KingsleyT: and you can use patterns in definitions just like in case
15:20:05 <benmachine> Eduard_Munteanu: I in no way understand what you are talking about :P
15:20:10 <monochrom> another example: if you write "(x,y) = (True, 'x')", then x equals True, y equals 'x'
15:20:12 <KingsleyT> monochrom: isn't that kinda 'overloading' the equals sign then?
15:20:21 <KingsleyT> because it's not actually assigning a value/body to a name
15:20:30 <haasn> quchen: distribl . first comappend . comappend  =  distribr . second comappend . comappend where distribl :: ((a,b),c) -> (a,b,c); distribr :: (a,(b,c)) -> (a,b,c) -- or whatever
15:20:30 <shachaf> Other fun sorts of monoids: class Monoid m where mempty :: Void -> a; mappend :: Either a a -> a
15:20:31 <KingsleyT> but it's more like it's passing the rhs as a parameter to the lhs pattern matching
15:20:44 <monochrom> it assigns many values to many names at once
15:20:44 <shachaf> The laws there also require that mempty = absurd (obviously) and mappend = either id id
15:20:46 <KingsleyT> which is what I think I'm getting confused about
15:21:10 <monoidal> > let [x,y,z] = [1,2,3] in x+y++z
15:21:11 <lambdabot>   No instance for (GHC.Show.Show a0)
15:21:11 <lambdabot>    arising from a use of `M1053479854.sh...
15:21:15 <monoidal> > let [x,y,z] = [1,2,3] in x+y+z
15:21:16 <lambdabot>   6
15:21:17 <quchen> haasn: Ah okay. And what's the unit law you mentioned?
15:21:29 <monochrom> I don't know how important it is to think "overlap". there is no inconsistency.
15:21:34 <shachaf> Just look up the monoid laws and reverse them.
15:21:39 <monoidal> KingsleyT: you can match on lists and tuples (and other datatypes) like that
15:21:41 <shachaf> https://en.wikipedia.org/wiki/Monoid_object
15:21:52 <haasn> quchen: first counit $ comappend x = ((), x) -- essentially
15:21:55 <haasn> same for the other side
15:21:58 <monoidal> KingsleyT: it's the same as case [1,2,3] of [x,y,z] -> x+y+z
15:22:03 <monochrom> you write a big pattern on the lhs. that looks strange. but every big pattern boils down to just many names.
15:22:18 <Eduard_Munteanu> benmachine: a parser that always succeeds would provide a function like   parse :: String -> Parser a -> a   and if you uncurry that and remember Parser takes input somewhere, you get a type like   (String, String -> a) -> a.
15:22:25 <KingsleyT> monoidal: alright, I haven't encountered the of syntax, but I think I get your meaning
15:23:01 <benmachine> Eduard_Munteanu: Parser takes input? doesn't it already have input?
15:23:02 <Eduard_Munteanu> benmachine: compare to   type Store = (s, s -> a)
15:23:13 <KingsleyT> monoidal: so why is it surrounded by (), then?
15:23:19 <Eduard_Munteanu> (err, you know what I mean)
15:23:25 <benmachine> Eduard_Munteanu: no I still don't :P
15:23:25 <monoidal> KingsleyT: it doesn't have to be
15:23:32 <KingsleyT> oh really?
15:23:33 * KingsleyT tries
15:23:42 <Eduard_Munteanu> benmachine: you have to feed a parser, that's what a parser runner function does
15:23:54 <Eduard_Munteanu> parse :: String -> Parser a -> a
15:23:56 <benmachine> KingsleyT: pattern matches are surrounded by () in function definitions but that's only because of the context
15:24:13 <benmachine> KingsleyT: f (x:xs) -- the () are necessary to avoid it looking like (f x) : xs
15:24:30 <KingsleyT> I see
15:24:41 <benmachine> Eduard_Munteanu: okay, so what you're saying is that Parser a is roughly String -> a
15:24:57 <benmachine> Eduard_Munteanu: and then String -> Parser a -> a is basically flip id
15:25:18 <shachaf> I think you might be thinking of State, not Store.
15:25:19 <monoidal> KingsleyT: of course you can have those multiple-variable definitions toplevel, not only in "where"
15:25:32 <benmachine> Eduard_Munteanu: well, that's not what you're saying, but it's what's going on in my head :P
15:25:58 <Eduard_Munteanu> benmachine: yes, but   String -> Parser a -> a  looks a lot like   extract :: Store s a -> a  ~  (s, s -> a) -> a  ~  s -> (s -> a) -> a
15:26:03 <KingsleyT> monoidal: aye, I understand that :3
15:26:38 <benmachine> Eduard_Munteanu: okay, sure, but so far you're just doing function application
15:26:39 <Eduard_Munteanu> shachaf: no, that won't be a comonad
15:26:47 <KingsleyT> so basically the idea is, you can assign a value/body to a name, like f = head firstname
15:27:05 <KingsleyT> or you can 'feed' a value/body to a pattern matching..thing, like f:_ = firstname
15:27:12 <monochrom> yes
15:27:18 <KingsleyT> alright, great :D
15:27:18 <Eduard_Munteanu> benmachine: those things needn't be transparent, e.g. a Parser's internal structure can be a lot different.
15:27:20 <monoidal> Eduard_Munteanu: I think you might model the input stream using the store comonad. but the parser itself? I'm not sure
15:27:38 <KingsleyT> would it just be called a pattern, then?
15:27:45 <KingsleyT> just trying to get the wording right now
15:27:49 <monochrom> "f:_" is a pattern
15:27:59 <KingsleyT> 'feed a value to a pattern'?
15:28:00 <Eduard_Munteanu> benmachine: similarly you wouldn't call the Store comonad trivial because it only does application :)
15:28:04 <KingsleyT> assign doesn't seem right..
15:28:10 <monochrom> "f:_ = firstname" you can call it an equation, a binding, whatever
15:28:18 <monoidal> you give a value to a pattern, and it either matches, or not
15:28:22 <KingsleyT> alright
15:28:29 <KingsleyT> awesome, thanks everyone :D
15:28:30 <shachaf> Eduard_Munteanu: I know. Your thing doesn't look like a comonad either.
15:28:33 <monochrom> let me see whether the Haskell 2010 Report gives it a name
15:28:35 <benmachine> Eduard_Munteanu: well, I'm not saying things are trivial as such, just that they're not pointedly parsery to me
15:28:36 <monoidal> for example, the pattern f:_ matches any list except the empty list and binds the head to f
15:28:52 <benmachine> Eduard_Munteanu: there's nothing about what you're saying that says "parser" to me
15:28:57 <KingsleyT> yep, I got what it did, just not the syntax
15:29:08 <monochrom> "pattern binding"
15:29:16 <benmachine> Eduard_Munteanu: maybe it rests in what =>> does, let me think about that a bit
15:29:23 <Eduard_Munteanu> benmachine: right, I don't think it's specific to parsers either, I was arguing the other way around
15:29:45 <Eduard_Munteanu> benmachine: namely that parsers seem to be comonadic
15:30:16 <Eduard_Munteanu> shachaf: how about   data Store s a = Store s (s -> a)    ?
15:30:22 <benmachine> Eduard_Munteanu: but this claim rests on you providing a type and saying "this type is a parser and also a comonad", no?
15:30:34 <benmachine> Eduard_Munteanu: and I'm saying "it's a comonad but I don't see the parser bit"
15:31:32 <shachaf> Eduard_Munteanu: You said Parser is a comonad. That means you have e.g. a function :: Parser a -> a
15:31:45 <shachaf> People were talking about a function :: String -> Parser a -> a, which is very different.
15:32:19 <Eduard_Munteanu> shachaf: yes, that disturbs me as well
15:33:35 * monochrom has a cunning plan! instance Comonad Parser where extract p = parse "" p
15:33:55 <shachaf> Yes, mempty and mappend. But that's not the comonad you want.
15:33:56 <Eduard_Munteanu> benmachine: I think there's more of a connection with (=>>) which basically says you can parse something, then use that something as input to another parser.
15:34:31 <shachaf> Eduard_Munteanu: Ignoring failure and nondeterminism and so on, String -> (a, String) is a pretty standard way to do a parser. Then you have parseWithRemainder :: Parser a -> String -> (a, String), and parse :: Parser a -> String -> a
15:34:39 <shachaf> But I'm not sure what the thing you're going for is.
15:36:53 <Eduard_Munteanu> shachaf: initially I was working on a layered parser and figured it could let higher layers extract and process things safely in the lower levels. E.g. I don't want my expression parser to define new tokens, but I might want to just get a token out and put it back in another parser.
15:38:10 <Eduard_Munteanu> So if I extract a token, I normally can't put it back without leaving that hole open to injecting foreign tokens.
15:38:52 <Eduard_Munteanu> Now looking at  (=>>) :: w a -> (w a -> b) -> w b   seems to do just that.
15:40:13 <Eduard_Munteanu> So if 'w a' is a token parser, I can run it (i.e. =>> id) and place it back into a token parser. Or I could do something more involved than id.
15:42:01 <Eduard_Munteanu> If I had a function like  a -> w a  I could violate the layering.
15:43:17 <Eduard_Munteanu> Anyway, I need some sleep.
15:45:04 <monoidal> is there a notion for things that are simultaneously monads and comonads? like a hopf algebra is a group and a cogroup?
15:56:38 <monoidal> nevermind, I find one. there's "hopf monad" and "bimonad".
15:56:50 <mm_freak> ocharles: do you have an account on hub.darcs.net?
15:59:39 <johnw> the Par monad seems to be pretty trivially comonadic: https://gist.github.com/6616919
16:00:11 <johnw> where =>> has the behavior of wrapping a Par computation around the result of another Par computation
16:00:48 <shachaf> duplicate = return sounds pretty suspicious in general.
16:01:17 <johnw> hmm... that's a good point
16:02:39 <johnw> duplicate :: NFData (Par a) => Par a -> Par (Par a)
16:02:40 <johnw> duplicate m = get =<< spawnP m
16:02:47 <johnw> the NFData instance there is suspicious
16:02:59 <johnw> i wonder if that implies it cannot be done
16:06:21 <ocharles> mm_freak: i do not
16:09:34 <johnw> is there a library for maps with multiple key "views"?  in C++ with Boost it's called multi_index_container
16:10:46 <johnw> hmm.. i wonder if 'tables' is actually what I want here
16:12:37 <johnw> yes, I think so!
16:13:43 <mm_freak> ocharles: well, you could create one, fork netwire there and then send a pull request…  much like on github =)
16:14:07 <ocharles> mm_freak: ok, i'll learn darcs for you then :P
16:14:13 <mm_freak> =)
16:14:16 <ocharles> the things i do for good frp!
16:14:30 <mm_freak> you don't have to, but it's currently the easiest way to contribute
16:15:00 <mm_freak> if you want to hack on netwire, it would be beneficial
16:15:49 <ocharles> yea, i'm only joking. a hub account is worth having
16:23:02 <haasn> Can I write ‘init’ as a fold?
16:24:05 <elliott> sure, you can write any list function as a fold.
16:24:11 <elliott> it might not be efficient.
16:24:40 <shachaf> Maybe haasn means "in the form foldr f z, without a post-processing function".
16:25:18 <shachaf> I wonder what functions you can write in that form.
16:25:23 <haasn> I'm not really sure what I mean. I guess I just want to see what alternatives there are and see if one matches what I was thinking of
16:25:54 <augur> everything is a fold, but not necessarilly a fold of what you think!
16:26:09 <shachaf> Well, you can write (init . foldr (:) []).
16:26:16 <shachaf> I.e. a fold gives you all the information in a list.
16:26:21 <mm_freak> > let f x [y] = x : []; f x xs = x : xs in foldr f [] "abcdef"
16:26:23 <lambdabot>   "a"
16:27:12 <ocharles> mm_freak: i have pushed my change, but i can't figure out how to make a pull request...
16:27:18 <haasn> > let f x [] = []; f x xs = x : xs in foldr f [] "abcdef"
16:27:19 <lambdabot>   ""
16:27:24 <haasn> oh
16:27:25 <mm_freak> ocharles: did you fork netwire?
16:27:40 <augur> i still have yet to master the art of extracting fold-based definitions from pattern matched ones
16:28:02 <ocharles> mm_freak: ya
16:28:06 <ocharles> http://hub.darcs.net/ocharles/netwire/changes
16:28:17 <elliott> shachaf: I guess "as a fold" means (g . foldr f z) to me, where g does not use foldr and we pretend there is no way to analyse a list other than foldr.
16:28:22 <elliott> or something.
16:28:36 <mm_freak> ocharles: apparently you don't even need to request the pull…  i can merge your changes right away =)
16:28:40 <mm_freak> let me check them
16:28:56 <ocharles> oh, ok
16:29:11 <augur> elliott: even if g was foldr f' z', we can use fusion so its ok
16:29:28 <augur> well, maybe
16:29:53 <elliott> shachaf: or maybe I want g to be non-recursive in general, so disallowing all folds of recursive data types or something.
16:30:32 <augur> all computable functions are recursive over _something_!
16:32:06 <mm_freak> ocharles: the only nitpick i have is that you should follow the coding style of the rest of the library =)
16:32:35 <mm_freak> notably regarding spacing, variable names and comment completeness
16:32:39 <ocharles> mm_freak: i did try to...
16:32:41 <haasn> I guess “writing tail as a fold” is pretty much the equivalent question
16:32:49 <ocharles> i couldn't exactly figure out what your style was
16:33:03 <ocharles> variable names may well be wrong though
16:33:42 <mm_freak> ocharles: empty line between comment and function, "Depends and Inhibits" in the comment, "\(x, lEv, rEv)" instead of "\(a, l, r)"
16:33:54 <mm_freak> "Depends" and "Inhibits"
16:34:11 <mm_freak> ocharles: "(Monoid e) =>" instead of "Monoid e =>"
16:34:16 <augur> its a sad and peculiar fact that pattern matching and unconstrained reference to the function is more convenient for programming, but less so for making the type theory
16:34:19 <mm_freak> i'll create a style document
16:34:21 <ocharles> mm_freak: ok, want me to make these?
16:34:27 <ocharles> or are you doing it as you merge
16:34:40 <mm_freak> ocharles: i'll do it this time
16:36:23 <enthropy> > snd $ foldr (\x (b,xs) -> (False, if b then [] else x:xs)) (True, []) "abcde"
16:36:24 <lambdabot>   "abcd"
16:37:03 <enthropy> haasn: I think tail is trickier
16:37:44 <augur> i think tail is probably similar actually
16:37:46 <haasn> > snd $ foldl (\(b,xs) x -> (False, if b then [] else xs++[x])) (True, []) "abcde"
16:37:47 <lambdabot>   "bcde"
16:38:02 <elliott> I think you can use Maybe there.
16:38:04 <enthropy> right but now you have the problem of foldl-in-terms-of-foldr
16:38:05 <augur> you build up a Maybe (a,[a]) or something
16:38:31 <enthropy> also the xs++[x] is kind of unpleasant
16:38:46 <augur> i should figure out this extraction stuff
16:39:36 <danilo2> Hi! Is it possible in Haskell to tell ghc to use instance, which it has found, when it is the only "potential instance"? I'm getting warning: "there is a potential instance available", which lists only one. I know that normally we would add some type signatures, but this occurs in a generated code and I'm sure, there will be no other instances, which will satisfy such situation.
16:40:05 <enthropy> danilo2: I don't think so. You might be able to re-write the instance so that it matches
16:40:10 <augur> hm
16:40:20 <haasn> > foldr (\x m -> fmap (x:) (m <|> Just [])) Nothing "abcde"
16:40:21 <lambdabot>   Just "abcde"
16:40:22 <enthropy> something like     instance (a ~ Int) => C a
16:40:25 <augur> i think it would be beneficial to define case in terms of foldr before doing anything else
16:40:34 <enthropy> where your `potential instance' was C Int
16:40:41 <Shin-LaC> shachaf: apparently I still need to turn on the GADTs extension if I want to have a context on a constructor
16:40:43 <haasn> oh
16:40:49 <haasn> > foldr (\x m -> fmap (x:) m <|> Just []) Nothing "abcde"
16:40:50 <lambdabot>   Just "abcd"
16:40:55 <haasn> there we go
16:42:11 <Shin-LaC> also, it seems that show can only be derived for haskell-98 types
16:43:26 <mm_freak> ocharles: pushed…  click on 'branches' to pull it in
16:44:20 <danilo2> enthropy: hmm, what you've showed is very interesting and indeed it works in my case. What is the ~ ?
16:44:38 <enthropy> danilo2: you have much to learn about ghc it seems
16:44:57 <enthropy> it says that the `a' is equal to Int
16:44:59 <ocharles> mm_freak: great, got it! thanks
16:45:12 <ocharles> now to finish writing some basic Traversals so i can use this in my testbed
16:45:12 <enthropy> but that doesn't apply until after the instance is chosen
16:45:18 <mm_freak> ocharles: you're welcome =)
16:45:20 <enthropy> since contexts aren't used to pick instances
16:45:36 <danilo2> enthropy: Ok, but it is not an "irrefutable" pattern (or wahtsever it is called in Haskell?
16:45:37 <mm_freak> ocharles: the reason i renamed 'waitRight' to 'active' is that an imperative name is weird for a wire =)
16:45:57 <ocharles> mm_freak: yep, makes sense. i don't really think about identifiers when i'm throwing things together
16:45:58 <enthropy> danilo2: I guess it is kind of like ~ in patterns
16:46:08 * enthropy might be squinting a bit too much
16:46:26 <ocharles> mm_freak: but these names do help understanding, so thanks. i'm gradually thinking under these terms :)
16:46:42 <danilo2> enthropy: Ok, but does it have a name? I want to read a documentation aout it. I know I have to learn much more about ghc - I'm learning all the time :)
16:47:12 <enthropy> danilo2: type equality? The extensions to look at are -XTypeFamilies or maybe -XGADTs
16:47:40 <enthropy> the ~ at the pattern level can give you runtime pattern match failures
16:47:41 <danilo2> enthropy: Thank you :)
16:47:51 <mm_freak> ocharles: =)
16:48:05 <enthropy> at the type level, it just gives you worse type errors possibly
16:48:42 <ocharles> mm_freak: much like moving from C# -> Haskell requires a lot of mental rerouting, moving from discrete imperative type programming to reactive programming is requiring quite a bit of slowing down
16:48:46 <ocharles> but it's all good fun
16:49:40 <mm_freak> indeed =)
16:50:35 <ReinH> edwardk: where are your old graphics programming articles / blog posts / whatever again?
16:54:09 <Shin-LaC> uggh
16:54:10 * hackagebot haxparse 0.3.1.0 - Readable HaxBall replays  http://hackage.haskell.org/package/haxparse-0.3.1.0 (JoelTaylor)
16:54:16 <Shin-LaC> how does Ord not imply Eq?
16:54:45 <jfischoff> I am comparing the speeds of streaming a file from disk with apache, and streaming the same bytes from memory in yesod (a single bytestring builder). Is it surprising that apache is faster?
16:55:08 <jfischoff> yesod is about 30% slower
16:55:19 <jfischoff> is that normal? Or am I doing something wrong?
16:56:29 <Shin-LaC> oh wait
16:56:31 <Shin-LaC> I misread
16:56:36 <mm_freak> sm: what does it mean to "build packs" on darcshub?
16:56:39 <shanse> I'd say that is to be expected
16:56:57 <seanparsons> In looking at Thrift, it would appear it generates data types of this kind of ilk for Haskell: data MyDataType = MyDataType{f_MyDataType_myField :: Maybe Bool} deriving (Show,Eq,Typeable)
16:57:08 <jfischoff> would yesod be faster if I streamed the file from disk?
16:57:13 <seanparsons> Does anyone know if there's a sensible justification with Haskell to have that prefix on the field?
16:57:22 <shanse> if you just want to serve static files then there's really no need for yesod
16:57:45 <jfischoff> the are not static files
16:57:47 <enthropy> jfischoff: do you do something to make sure the file isn't cached in memory when you're testing?
16:58:20 <jfischoff> enthropy: which machines memory?
16:58:33 <enthropy> the server
16:58:59 <enthropy> seanparsons: the field accessor is a function in the global namespace
16:59:06 <enthropy> and qualified names are a pain
16:59:18 <enthropy> since you can't export qualified
17:00:00 <schell> i think i have a chicken/egg problem here with building ghc on osx with Xcode 5
17:00:04 <enthropy> there might be other ways to access/modify the field, so maybe that justifies having a long name
17:00:14 <schell> i need happy >= v1.19
17:00:22 <jfischoff> it could be cached  on the server
17:00:26 <schell> but can't cabal install it since i have Xcode 5
17:01:17 <jfischoff> entropy: also the first request time was not really different from other times
17:01:20 <schell> i can't cabal install since i don't have ghc 8, which i'm trying to build!
17:04:05 <seanparsons> enthropy: Ah, good call.
17:05:42 <ocharles> mm_freak: ignoring all the other crap in this file - http://lpaste.net/93156#line109 . not sure 'between' is particularly usable like that. so should I be thinking about making my own 'betweenScancode' type function?
17:05:49 <MrRacoon_> ~/win 28
17:10:29 <hpc> jfischoff: i would do simple stream from file and trust the OS to keep appropriate things paged in
17:10:57 <jfischoff> hpc: I'm going to compare that
17:11:53 <hpc> see also tux, which is the fastest static server in the west
17:12:00 <mm_freak> ocharles: the code seems fine to me
17:12:13 <hpc> and it's basically just file/socket IO
17:12:16 <mm_freak> ocharles: but yeah, if you do this for multiple keys, you should probably factor it out
17:12:32 <mm_freak> call it whileKey
17:12:46 <ocharles> mm_freak: well movement on a single key turned into 3 lines, which kinda sucks
17:12:51 <ocharles> i'll see what i get with factoring
17:13:21 <mm_freak> ocharles: it's not wrong to write a special wire for that
17:13:27 <mm_freak> not in terms of 'between'
17:13:44 <mm_freak> but it should have the same semantics to protect continuous time
17:14:21 <ocharles> i think if you want to release netwire 5, you're going to need to do some writing about what it is that continuous time and what it isn't
17:14:41 <ocharles> because there are clearly assumptions i can and can't make, and using my mm_freak semantics checker won't scale to other people
17:14:54 <mm_freak> hehe yeah
17:15:23 <mm_freak> for now the rule of thumb is:  zero-length intervals do not exist
17:16:18 <ocharles> right, and to i find it helpful to answer that question by saying "if the time delta tends to infinity, where does my interval tend to?"
17:16:50 <ocharles> wait
17:16:53 <ocharles> delta tends to zero :)
17:20:23 <ocharles> http://lpaste.net/93157 alright, abstracting that doesn't make it look so scary. now the scary part is "tile" which is something i need to focus on
17:23:11 <monochrom> oh w00t! new Cartesian Closed Comic! "Cabal 1.18" http://ro-che.info/ccc/22
17:23:48 <augur> monochrom: not THAT new
17:23:53 <augur> like a week old!
17:23:58 <monochrom> yikes
17:24:10 <monochrom> oh well, I lag
17:24:20 <augur> 10 days even!
17:30:54 <applicative> johnw: how is there a difference between instance Comonad Par and instance Comonad Identity; the whole idea is that Par is supposed to behave like the Identity Functor -- sort of
17:37:14 <ocharles> is there really no 'dupe :: a -> (a, a)' in base? I find myself needing that all the time when working with arrows
17:37:24 <applicative> @type join (,)
17:37:25 <lambdabot> a -> (a, a)
17:37:37 <ocharles> neat
17:39:25 <applicative> theres no swap either except (\(x,y)->(y,x)) but its defined in most packages on hackage ...
17:40:12 <monoidal> applicative: swap is in Data.Tuple
17:40:24 <applicative> oh
17:40:25 <applicative> hm
17:40:35 <monoidal> applicative: it's recent addition (7.6?)
17:40:58 <applicative> nice
17:42:15 <applicative> > length "import Data.Tuple" < length "swap(a,b)=(b,a)"
17:42:16 <lambdabot>   False
17:42:46 <applicative> > length "import Data.Tuple" < length "swap (a,b) = (b,a)"
17:42:47 <lambdabot>   True
17:42:58 <applicative> there you go
17:49:11 * hackagebot kure 2.12.2 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.12.2 (NeilSculthorpe)
17:51:30 <Raydiation> what does flatten do? get the result of a map and put it into a monad?
17:52:19 <shachaf> You're the first person to mention flatten in my IRC window. You should tell us.
17:52:29 <djhaskin987> anyone here use biohaskell
17:52:35 <shachaf> (Also, "put it into a monad" is a phrase that doesn't really make sense.)
17:52:37 <djhaskin987> the site is down and I'm trying to find a tutorial
17:52:42 <Raydiation> well im reading the type sigs of map and fmap
17:53:25 <hpc> "get into the monad! no time to explain!"
17:53:28 <Raydiation> and it seems the only difference is that fmap takes a functor with type a and returns a functor of type b which is the result of map
17:53:45 <shachaf> A functor isn't a value. It's a type constructor.
17:54:20 <shachaf> Functions in Haskell don't take functors as arguments.
17:54:21 <shachaf> You'll have an easier time if you learn the terminology. :-)
17:54:40 <hpc> a functor is just a functor in the functor of functors!
17:54:47 <ocharles> "a functor is a type constructor", coming from shachaf?
17:54:49 <ocharles> i expect better.
17:55:21 <shachaf> Hmm?
17:55:32 <hpc> shachaf: plenty of functors are not type constructors
17:55:33 <ocharles> i expected a proper category theory definition :P
17:55:37 <hpc> in fact, most
17:55:46 <shachaf> We're in #haskell.
17:55:48 <haasn> a Functor is a type constructor
17:56:07 <Raydiation> type constructor == interface?
17:56:14 <shachaf> No.
17:56:15 * tabemann facepalms
17:56:17 <haasn> there's no such thing as an interface in Haskell
17:56:44 <Raydiation> ah that was a type class
17:56:56 <shachaf> tabemann: Come on, no need to be rude.
17:57:05 <monochrom> Raydiation, we say "Maybe is a Functor", we don't say "Just True is a Functor". or functor.
17:57:12 <haasn> Haskell doesn't have objects or methods;  Type classes can form abstractions you might implement using an interface in another language
17:57:19 <hpc> Raydiation: there are type classes, which are a way of saying "these things all have the same operations" while simultaneously being confusingly similar to interfaces
17:57:36 * haasn sees type classes as a general way of associating values to types
17:57:40 <shachaf> Raydiation: You might want to read some introduction to Haskell if you're just trying to pick up pieces from random places.
17:57:41 <monochrom> similarly for Monad. "Just True" is not a Monad. or monad. the monad/Monad is "Maybe"
17:57:51 <tabemann> shachaf: okay, that probably wasn't called for, I know
17:57:54 <Raydiation> shachaf: yeah may be for the best
17:58:00 <shachaf> @where faq has some links.
17:58:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:58:06 <hpc> Raydiation: so there's a type class for Num which provides the functions (+), among others
17:58:06 <monochrom> also, "Maybe Bool" is not a functor, Functor, monad, or Monad. "Maybe" alone is.
17:58:33 <shachaf> monochrom++ # clarity
17:58:38 <hpc> Raydiation: many types represent different forms of numbers, so it makes sense for (+) to have a different definition for each
17:58:57 <hpc> Raydiation: Functor is another type class
17:59:29 <hpc> Raydiation: [] is an instance of Functor (that's [] as in the type of lists; let's call it "List")
17:59:37 <haasn> Monoid is a great example of how type classes differentiate from interfaces
17:59:40 <haasn> :t mempty
17:59:41 <lambdabot> Monoid a => a
17:59:55 <hpc> Raydiation: so we would have something like "instance Functor List where fmap :: (a -> b) -> List a -> List b"
17:59:55 <augur> hpc: what is an example of a functor that is not a type constructor..
18:00:07 <hpc> augur: (Either a)
18:00:12 <Raydiation> but fmap is a map function that maps Functor A to Functor B
18:00:15 <augur> Either a is a type constructor
18:00:22 <hpc> augur: a type constructor is Capitalized like a data Constructor
18:00:33 <hpc> augur: unless ((,) 15) is a constructor too
18:00:45 <Raydiation> given a function that takes A and returns B
18:00:46 <augur> ok, i see the distinction you're making
18:00:59 <hpc> it's a type-level function because it takes a type and produces a type
18:01:09 <augur> you mean an atomic thing of kind ... -> *
18:01:30 <augur> or specifically, of kind * -> *
18:01:40 <augur> for the functor/monad/etc cases
18:01:46 <augur> and ... -> * for type constructors
18:02:01 <monochrom> Raydiation: you are right to say, fmap is more general, map is just a special case. if you use fmap all your life and never touch map, you won't be missing anything.
18:02:48 <Raydiation> so if you take Maybe A and map a function over it that gets A and returns B it returns a Maybe B?
18:02:54 <haasn> augur: ‘Either _ b’ perhaps
18:03:11 <haasn> functor, not a Functor
18:03:47 <augur> haasn: yes yes
18:03:55 <hpc> Raydiation: completely remove the word Functor from your brain, for now
18:04:10 <Raydiation> ok
18:04:23 <monochrom> that is correct
18:04:27 <hpc> Raydiation: learn type classes in terms of something less abstract, like the numeric classes
18:04:33 <hpc> Raydiation: so, Int is a numeric type
18:04:38 <hpc> Float, etc
18:04:50 <hpc> 5.603 is a Float
18:05:21 <hpc> and this is kind of falling apart, because i am going to sound like an idiot saying 5.603 is not a number
18:05:31 <hpc> but just bear with me
18:05:38 <Raydiation> you mean like a function that returns that value?
18:06:37 <hpc> i mean like, you have multiple levels of "is"
18:06:53 <haasn> “has type” “is an instance of”
18:06:57 <hpc> and "is" is not precise enough to describe all of them
18:07:05 <hpc> Raydiation: so we have "has type", which is "::"
18:07:10 <hpc> Raydiation: 5.603 :: Float
18:07:27 <Raydiation> ok
18:07:27 <hpc> Raydiation: "is an instance of", we'll use the notation (Num Float)
18:07:32 <hpc> (Float is a Num)
18:07:49 <hpc> Raydiation: now where i think the confusion is coming from, is in combining them
18:08:18 <hpc> Raydiation: so you have the very fuzzy notion of "5.603 is a number"
18:08:35 <hpc> Raydiation: which is better expressed as "5.603 is of some type that is an instance of Num"
18:08:49 <hpc> in haskell, that's written "5.603 :: (Num a) => a"
18:09:09 <hpc> er, doing it myself...
18:09:23 <hpc> "5.603 *has* some type that is an instance of Num"
18:09:35 <ocharles> mm_freak: any reason Integral is ommited for Wire?
18:09:37 <Raydiation> Float is a Num as in float derives from Num?
18:09:45 <Raydiation> Num is a super type?
18:09:55 <ocharles> oh, blah
18:10:01 <ocharles> Real superclass can't be implemented for wires
18:10:18 <hpc> Raydiation: no; there is a separate thing from types which are "type classes"
18:10:36 <hpc> Num is a type class, that is it describes things that types can be
18:10:40 <haasn> hpc: (which doesn't type check, of course)
18:10:42 <hpc> @src Num
18:10:42 <lambdabot> class  (Eq a, Show a) => Num a  where
18:10:42 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:10:42 <lambdabot>     negate, abs, signum     :: a -> a
18:10:42 <lambdabot>     fromInteger             :: Integer -> a
18:10:51 <hpc> haasn: shush
18:11:04 <Raydiation> ok, and Float implements the required functions of Num
18:11:14 <hpc> correct
18:11:14 <augur> Eq and Show are great classes to tell him about
18:11:29 <haasn> Personally I wouldn't say ‘Float’ implements anything. Rather, there exists an instance Num Float which implements those functions
18:11:31 <haasn> Float is just a stupid type
18:11:42 <hpc> Raydiation: and the way that's done is "instance Num Float where (+) = magic primitive operation, (-) = you get the picture"
18:11:47 <haasn> saying ‘Float implements X’ draws from confusing OOP terminology imo
18:11:51 <Raydiation> yeah
18:12:27 <hpc> Raydiation: to be ultra precise, Float is an instance of Num, and it implements the definitions of Num
18:12:49 <hpc> or something like that, there's not really great terminology for what's in a class definition
18:13:09 <hpc> Raydiation: Eq is the type class for equality; it defines (==) and (/=)
18:13:55 <hpc> Raydiation: so now let's get to something non-trivial
18:13:57 <hpc> @src Ord
18:13:57 <lambdabot> class  (Eq a) => Ord a  where
18:13:57 <lambdabot>     compare      :: a -> a -> Ordering
18:13:57 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:13:57 <lambdabot>     max, min         :: a -> a -> a
18:14:17 <hpc> Raydiation: Ord is a class for ordered types (Int, etc)
18:14:33 <hpc> Raydiation: things that can be ordered must necessarily be able to be compared for equality
18:14:54 <hpc> Raydiation: so where it says "(Eq a) => Ord a" means that any instance of Ord must also be an instance of Eq
18:15:15 <hpc> Raydiation: now we can sort anything that can be ordered
18:15:18 <hpc> and the type for sort is
18:15:20 <hpc> :t sort
18:15:20 <lambdabot> Ord a => [a] -> [a]
18:15:35 <Raydiation> ok so you can compose typeclasses from other type classes
18:15:57 <hpc> yeah
18:15:58 <Raydiation> hm, no, require other typeclasses to be there
18:16:06 <hpc> well, it's vaguely composey
18:16:11 <Raydiation> as in takes an instance of Eq?
18:16:26 <augur> you should definitely think of it as requirements
18:16:36 <Raydiation> yeah
18:16:53 <hpc> Raydiation: what you are really composing is constraints, but ignore that for now ;)
18:17:09 <Raydiation> yeah im getthing that :)
18:17:13 <hpc> Raydiation: so you can also get into complicated things, like
18:17:30 <hpc> "i have all these numbers and i want to sort them by whatever the result of cosine on those numbers is"
18:17:38 <thirsteh> two-in-one: Does GHC flush and close handles when terminating (e.g. via sighup)? If not, is there something like "atexit": register a function to run before the program shuts down, so I don't have to install all kinds of signal handlers
18:17:41 <augur> hpc: im not sure "compose" works well here
18:17:46 <haasn> arguably a superclass constraint should exist in cases where the subclass allows you to implement the superclass
18:17:50 <haasn> eg.
18:18:09 <hpc> Raydiation: you can express that more generally as, "i want to sort these by whatever the result of this function is"
18:18:13 <haasn> :t \x y -> case compare x y of EQ -> True; _ -> False
18:18:14 <lambdabot> Ord a => a -> a -> Bool
18:18:22 <hpc> Raydiation: and the way to do that is with sortBy
18:18:24 <hpc> :t sortBy
18:18:25 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
18:18:26 <haasn> this is a suitable definition for (==), based on Ord
18:18:34 <hpc> :t comparing
18:18:35 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
18:18:53 <Raydiation> aah
18:18:58 <hpc> Raydiation: comparing lets you compare two things by the result of them being put into a function
18:19:02 <hpc> so we combine those and get
18:19:07 <hpc> :t \f -> sortBy (comparing f)
18:19:08 <augur> does haskell solve those things, haasn?
18:19:08 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
18:19:14 <Raydiation> so the consine is essential a function that is mapped of them
18:19:18 <augur> if you do   instance Ord a => Eq a where ... ?
18:19:23 <augur> even tho Ord has an Eq constraint?
18:19:24 <hpc> Raydiation: and we get an Ord constraint that's going into a somewhat wonky part of that type
18:19:25 <Raydiation> over*
18:19:35 <augur> it should be possible in a kind of perverse way to do that
18:19:37 <haasn> augur: that's possible but not very useful
18:19:45 <augur> haasn: i could see it as useful
18:19:59 <haasn> you'd need OverlappingInstances for it to be non-nonsensical in the very least
18:20:00 <augur> i mean, if you're going to define an ord, deriving the eq automatically would be convenient
18:20:16 <haasn> and that opens a whole can of worms
18:20:43 <hpc> Raydiation: so now that should hopefully be enough introduction to bring us back to Functor
18:20:46 <hpc> @src Functor
18:20:46 <lambdabot> class  Functor f  where
18:20:46 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:21:10 <hpc> Raydiation: so right away from the type of fmap, we see that 'f' is a type that takes another type as a parameter
18:21:20 <Raydiation> is f a typeclass?
18:21:25 <hpc> Raydiation: that means Maybe, List, IO, etc
18:21:30 <haasn> augur: actually, with OverlappingInstances, it seems to work for the most part. I can define “data Foo = A | B | C deriving Ord” without GHC complaining, and I can use (==) and stuff successfully on it
18:21:49 <hpc> Raydiation: Functor is the type class, f is a type
18:21:57 <Raydiation> ok
18:22:00 <hpc> Raydiation: compare with Num
18:22:02 <hpc> @src Num
18:22:02 <lambdabot> class  (Eq a, Show a) => Num a  where
18:22:02 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:22:02 <lambdabot>     negate, abs, signum     :: a -> a
18:22:02 <lambdabot>     fromInteger             :: Integer -> a
18:22:08 <hpc> 'f' there is the same as 'a'
18:22:16 <Raydiation> ok
18:22:28 <haasn> augur: still, OverlappingInstances can produce weird results in the presence of orphan instances and stuff
18:22:36 <augur> haasn: yeah
18:22:46 <Raydiation> instance then?
18:22:49 <hpc> Raydiation: so we have 'f' being in kind of a weird place in the type, but we can still just mentally substitute things in, same as you are likely used to with numeric types
18:23:04 <hpc> Raydiation: (+) :: Int -> Int -> Int - replacing 'a' with 'Int'
18:23:20 <hpc> Raydiation: fmap :: (a -> b) -> Maybe a -> Maybe b - replacing 'f' with 'Maybe'
18:23:56 <hpc> it's just find/replace
18:24:03 <Raydiation> yeah
18:24:14 <hpc> so now let's write an instance
18:24:18 <hpc> instance Functor Maybe where
18:24:23 <Raydiation> btw thanks for the explanantion
18:24:30 <hpc>   fmap :: (a -> b) -> Maybe a -> Maybe b
18:24:36 <hpc>   fmap f Nothing = Nothing
18:24:43 <hpc>   fmap f (Just a) = Just (f a)
18:24:51 <hpc> and that's the whole thing!
18:24:56 <Raydiation> thats the maybe monad?
18:25:02 <Raydiation> 3 lines?
18:25:08 <hpc> that's the functor
18:25:20 <hpc> *that's the functor instance for maybe
18:25:42 <hpc> there's other instances of Functor
18:26:01 <hpc> and fmap does different things for those instances, same as (+) adds different kinds of numbers differently
18:26:23 <Raydiation> ok, but thats all that you need to define to get Maybe working right?
18:26:23 <hpc> but they all follow the same general rules
18:26:30 <hpc> yeah, that's all
18:26:48 <augur> well hpc
18:26:51 <augur> you should add
18:26:54 <djahandarie> To get Maybe "working" you don't need to define any instances.
18:26:56 <augur> there are constraints on being a functor
18:27:03 <augur> conventional constraints
18:27:06 <hpc> i was getting to that
18:27:09 <augur> :x
18:27:18 <hpc> Raydiation: so, there's obviously things that are not numbers
18:27:38 <hpc> because they don't behave the way numbers are "supposed" to
18:28:02 <hpc> there's a very formal definition of how numbers should behave that's thrown out the window in haskell
18:28:10 <hpc> but for Functor the rules are rock-solid
18:28:22 <hpc> and here's where i must resort to google
18:28:35 <haasn> fmap f = maybe Nothing f
18:28:39 <haasn> fmap = maybe Nothing
18:28:41 <haasn> :t maybe Nothing
18:28:42 <lambdabot> (a -> Maybe a1) -> Maybe a -> Maybe a1
18:28:45 <haasn> h
18:28:46 <haasn> oh*
18:28:53 <haasn> :t maybe Nothing . (Just .)
18:28:54 <lambdabot> (a -> a1) -> Maybe a -> Maybe a1
18:28:56 <hpc> ah, here we go
18:29:07 <hpc> Raydiation: so the first law a Functor instance must follow is
18:29:12 <hpc> fmap id  ==  id
18:29:20 <hpc> Raydiation: we see that followed for the Maybe instance
18:29:24 <hpc> fmap id Nothing = Nothing
18:29:33 <hpc> fmap id (Just a) = Just (id a) = Just a
18:29:33 <Raydiation> ok group theory?
18:29:51 <Raydiation> like neutral element
18:30:31 <hpc> Raydiation: probably; i don't really like the CT side of things because it's really messy to my programmer brain
18:30:38 <hpc> Raydiation: the second Functor law is
18:30:40 <hpc> fmap (f . g)  ==  fmap f . fmap g
18:30:45 <hpc> which we also see followed
18:30:49 <haasn> Raydiation: sort of but not really; categories are like generalizations of monoids, which are weaker than groups
18:31:02 <hpc> fmap (f . g) Nothing = Nothing
18:31:09 <haasn> in this setting, functors are category homomorphisms, so fmap id = id is like the law of preserving identity
18:31:25 <hpc> fmap (f . g) (Just a) = Just (f (g a))
18:32:02 <hpc> fmap f (fmap g (Just a)) = fmap f (Just (g a)) = Just (f (g a))
18:32:07 <hpc> which are the same
18:32:13 <Raydiation> how do you keep this in your mind
18:32:16 <haasn> Raydiation: and fmap f . fmap g = fmap (f . g) is just preserving the category operator (composition)
18:32:17 <hpc> so huzzah, we have verified that our instance actually works
18:32:28 <augur> Raydiation: practice :)
18:32:52 <hpc> Raydiation: so here's an exercise for you
18:33:11 <Raydiation> so basically a no brainer at some point?
18:33:12 <hpc> Raydiation: given the type "data Goober a b = Goober a b"
18:33:22 <hpc> Raydiation: write a Functor instance for "Goober Int"
18:33:26 <monochrom> how I keep this in my mind: opportunity cost. time spent learning functor is time lost for PHP.
18:33:57 <hpc> Raydiation: put it into a .hs file and play with ghci until you get it compiling, then take some time to understand what it does
18:34:31 <Raydiation> hpc: ty
18:34:37 <haasn> write a legal Functor instance*
18:35:02 <hpc> and with that, it's quite late here so time for sleepy-sleep :P
18:35:18 <haasn> (and I'm not sure restricting a ~ Int makes a lot of sense, either way. It won't make the problem easier or harder but it makes it easier to violate laws and harder to check)
18:35:26 <mm_freak> ocharles: toInteger is the reason
18:35:52 <hpc> haasn: it makes the exercise slightly extendable for the person who fills in after me
18:36:02 <Raydiation> monochrom: ? as in i should go to program php xD?
18:36:02 * hpc off!
18:36:07 <Raydiation> gnite!
18:36:42 <monochrom> I don't know. it's up to you.
18:37:12 <monochrom> but the flip side is: time spent learning PHP is time lost for the more awesome Haskell
18:37:25 <Raydiation> i already know PHP so nothing more to gain from that
18:37:53 <monochrom> anyway, I'm just saying, I am good at Haskell because I gave up being good at a million other things, PHP, swimming, tennis, ...
18:38:14 * geekosaur took the comment as meaning that haskell was a good way to get away from being abused by PHP
18:39:12 <Raydiation> i see, well i stopped doing php 5 years ago to do python, then got back into php because of a project and it was able to get into it very fast again
18:39:42 <Raydiation> so not sure if you have to give up something :)
18:40:42 <shachaf> At a rate of 5 years per thing, that's 5 million years to do a million other things.
18:40:51 <applicative> you give up nothing and gain everything by understanding Functor
18:41:09 <applicative> Functor makes you stronger
18:41:19 <Raydiation> hehe
18:41:22 <haasn> monochrom: basic hygienic upkeep, social contact? :)
18:41:55 <shachaf> Is that really necessary?
18:43:19 <applicative> Monads make you even stronger
18:43:22 <applicative> @quote boundless
18:43:22 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
18:44:00 <haasn> applicative: what does Costrong make you?
18:44:11 <augur> hmm hmm
18:44:13 <shachaf> I move to @forget that quote.
18:44:19 <applicative> it's wonderful
18:44:32 <applicative> lets remove all the shachaf quotes instead
18:44:32 * haasn votes to rewrite it as ‘adjunctions’
18:44:47 <augur> is it possible in general to implement a functor f (maybe a monad, maybe not) as some variant of Cont?
18:45:14 <augur> i know to some extent that church encodings are kind of continuation-y things, but
18:45:19 <johnw> augur: you can certainly implement it as a Yoneda embedding
18:45:26 <dolio> Second.
18:45:40 <johnw> so, Cont is (a -> r) -> r, and Yoneda is (a -> r) -> f r.  close, but not exact
18:45:51 <augur> johnw: well.. you can use yoneda to some extent, but you dont get away from having f
18:46:12 <haasn> augur: then what is a ‘variant of Cont’ in this context?
18:46:17 <shachaf> Good enough for me.
18:46:42 <shachaf> Or not. I don't know.
18:46:43 * shachaf sighs.
18:46:44 <augur> haasn: Cont, for some unavoidable other types :p
18:46:58 <augur> i dont know either, haasn!
18:48:30 <joelteon> Yoneda is just pure . Cont
18:52:16 <Shin-LaC> I wrote my first Haskell program (well, module). it's an implementation of AVL trees. I would be grateful if experts could look at it and point out flaws, bad style etc: http://lpaste.net/6260262172220194816
18:53:27 <shachaf> @forget Kukkua They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
18:53:28 <lambdabot> Done.
18:53:36 <augur> lolwut
18:53:40 <applicative> nice
18:53:53 <applicative> @forget shachaf
18:53:53 <lambdabot> Incorrect arguments to quote
18:54:11 <monoidal> Shin-LaC: instead of | k == k' = ..., | k < k' = ... etc., use case compare k k' of EQ -> ...; LT -> ...
18:54:58 <djhaskin987> hello?
18:55:08 <djhaskin987> does anyone here use biohaskell?
18:55:22 <Shin-LaC> monoidal: ok!
18:55:37 <monoidal> Shin-LaC: careful not to confuse LT and GT.
18:56:28 <shachaf> I wonder whether this is a case where GHC would/should do CSE.
18:56:52 <shachaf> Assuming (==) and (<) weren't Ord methods, which makes things more complicated.
18:57:19 <djhaskin987> very well.
18:57:35 <Shin-LaC> cse?
18:57:45 <geekosaur> common subexpression elimination
18:58:16 <geekosaur> basically, noticing that you're calculating the same thing in different parts of a large expression, and factoring it out so it's only computed once
18:58:30 <Shin-LaC> ah
18:58:44 <Makoryu> I forget why CSE would be black magic in Haskell
18:58:45 <geekosaur> (but remeber that everything in Haskell is ultimately a large expression, so CSE would tend to happen more often that might be appropriate)
18:59:15 <geekosaur> even do block "statements" turn into a large expression
18:59:31 <applicative> what's strange about this Shin-LaC is the Ord constraint on the second constructor
19:00:23 <shachaf> If you inline (==) and (<), you get case compare k k' of { EQ -> ...; _ -> case compare k k' of { LT -> ...; ... } }
19:00:37 <dolio> Sometimes it makes things worse.
19:00:56 <Shin-LaC> applicative: I asked the channel about that before proceeding… that was the solution that was suggested. how should I have done it?
19:01:22 <shachaf> Oh, that quote was from Lajla, the Troll with a Thousand Nicks.
19:01:48 <applicative> Shin-LaC: not sure, I'm having trouble interpreting it.
19:01:55 <geekosaur> yes, it can introduce sharing where it's not expected and then you see things that you expect to not hang around (say, large lists) end up staying around
19:02:00 <applicative> Shin-LaC: of course I would just omit it
19:02:03 <shachaf> dolio: In this case you can just turn it into one case, though. It seems like that situation would be strictly an improvement?
19:02:10 <dolio> Right.
19:02:19 <dolio> It might be one of the cases where it does it.
19:02:44 <dolio> Like when monochrom discovered that isJust/fromJust got optimized into a single case.
19:02:57 <shachaf> Right, that's what I was thinking of.
19:03:15 <shachaf> Though (==) and (<) being their own methods can cause a problem there.
19:03:17 <monochrom> \∩/
19:03:26 <Shin-LaC> applicative: but then someone could construct a node with a non-orderable key, no?
19:03:43 <dolio> Right. It'd probably only happen if they got inlined to a definition in terms of compare.
19:04:15 <applicative> Shin-LaC: yes, but they would just be able to stare at it, and not use any of the functions you define
19:05:18 <geekosaur> also that sharing thing is where everthing being a large expression can really bite you, because ghc may decide that things you do not think are common subexpressions are, and bring in unexpected sharing
19:05:20 <applicative> Shin-LaC: even as it is they can define a :: Tree (Int -> Int) Char; a = Empty
19:05:28 <applicative> but that's not too frightening
19:05:55 <Shin-LaC> applicative: originally I hoped to put the Ord k constraint on the type, and not need it on each function
19:05:59 <shachaf> But they don't get inlined in polymorphic code at all, of course.
19:06:04 <Shin-LaC> but I guess that's not possible/desirable?
19:07:23 <Shin-LaC> I've updated the paste to use case compare
19:07:42 <Shin-LaC> the change ended up adding one level of indentation… am I using too much?
19:08:08 <shachaf> So if (<)/(==)/(>) weren't methods but just functions that used compare, it would all turn into one case.
19:08:50 <Raydiation> what IDE do you use? its kinda cumbersome to invoke the combile from bash
19:08:53 <shachaf> Hmm, that doesn't happen when I define lt x y = compare x y == LT etc. :-(
19:09:01 <shachaf> Only with case compare x y of LT -> True; _ -> False
19:09:06 <Raydiation> im on sublime text atm
19:09:21 <applicative> Shin-LaC: http://lpaste.net/8176861714260688896 is without the Ord constraint.  It is true you were able to dispense with Ord constraints on several of the functions.
19:09:34 <Makoryu> Shin-LaC: You can't really constrain the type itself, but you can constrain any function, including a type constructor
19:09:44 <Makoryu> Shin-LaC: There are several ways to do the latter
19:10:29 <elliott> I don't understand the debate, because the case on compare is clearly more elegant anyway.
19:11:00 <dolio> Inferior syntax.
19:11:06 <Shin-LaC> applicative: I think I have the Ord constraints in more places than needed, actually… let's see how many I can remove
19:11:44 <Shin-LaC> or is that a bad idea?
19:13:27 <Shin-LaC> yep, I can also remove the constraints from get, elem, and delete
19:16:17 <Shin-LaC> is there a way to do some formal verification in haskell? ideally I'd like to check that the AVL invariant is preserved by all functions
19:16:48 <Makoryu> Shin-LaC: You can do some really crazy stuff with the type system, actually
19:17:35 <applicative> somehow the module is clearer if I write it in explicit 'GADT' syntax
19:17:37 <applicative> Shin-LaC: data Tree k v where Empty :: Tree k v; Node :: Ord k =>  k -> v -> Int -> Tree k v -> Tree k v -> Tree k v
19:17:40 <Raydiation> is there a reason why cabal isnt bundled with ghc? like npm for node
19:17:58 <monochrom> hrm, that may in fact be a good idea
19:18:23 <Makoryu> Raydiation: It is bundled with the Haskell Platform
19:18:31 <monochrom> I guess the choice made some years ago was: "ghc should be minimal"
19:18:35 <applicative> Shin-LaC: note that then you can put the Ord k constraint on Empty, not that it excludes much ...
19:18:57 <Raydiation> Makoryu: ty
19:19:09 <monochrom> before that, well there was no cabal or hackage anyway, but before that, ghc shipped with a lot of libs. after a while it became a burden
19:19:13 <geekosaur> ghc is still shedding stuff, in fact another round is planned soon
19:19:24 <Shin-LaC> Makoryu: I wouldn't know where to start to express those constraints in the type system, though
19:19:28 <johnw> geekosaur: the splitting up of base sounds interesting
19:19:37 <Makoryu> Shin-LaC: Frankly, neither would I
19:19:38 <geekosaur> the idea is that ghc itself should be small and the interesting stuff should be in the haskell platform
19:20:10 <monochrom> anyway yeah, use Haskell Platform as the, well, platform :)
19:20:15 <Makoryu> Shin-LaC: My only suggestion is "there are some typeclasses and stuff, and, like, some Peano numerals or whatever"
19:20:33 <Raydiation> since cabal is compiling lots of stuff, is there something like -j9 like for make?
19:20:40 <Shin-LaC> applicative: hm, I see… people were suggesting not to use GADT syntax if not needed before, but of course I have no idea about style issues
19:20:46 <monochrom> yes
19:20:50 <Raydiation> or is haskell running so well on multicore that i dont need this
19:21:05 <Shin-LaC> Makoryu: hehe, I see :)
19:21:19 <monochrom> you need it. it's called -j again for cabal
19:21:21 <Shin-LaC> I'll look into unit testing, then
19:21:33 <Raydiation> monochrom: ty
19:21:53 <Shin-LaC> I guess agda might do that sort of formal verification? and it's built on top of haskell or something? there was a presentation at my university a while ago
19:22:26 <Shin-LaC> btw, I'm just writing my code in TextWrangler and running ghci in the terminal
19:22:39 <Shin-LaC> should I be using some sort of IDE or something?
19:22:51 <applicative> you can use whatever you like
19:23:17 <Makoryu> Shin-LaC: I like to run ghci on the file I'm editing, and then use :e to launch an editor
19:23:21 <Shin-LaC> ok
19:23:33 <Makoryu> When I save and quit, ghci detects that I changed the file, reloads, and tells me about any errors
19:23:48 <Raydiation> could it be that lots of packages in hackage(?) are broken? like missing deps
19:23:58 <Raydiation> im getting setup: The program happy version >=1.17 is required but it could not be found.
19:24:01 <applicative> missing deps?
19:24:04 <Shin-LaC> haskell seems to be concise and elegant enough to work fine with a plain editor, indeed
19:24:05 <Raydiation> when trying to install haskell-src-exts
19:24:14 <Makoryu> (I use vim in the terminal, though, and this doesn't work so well with a GUI app)
19:24:17 <Clint> cabal isn't good with deps on programs
19:24:20 <Shin-LaC> it's not like java where you get carpal tunnel if you don't have autocompletion and boilerplate generation
19:24:29 <applicative> Raydiation: doesn't happy come with the haskell platform
19:24:31 <applicative> maybe not
19:24:45 <monochrom> happy is in Haskell Platform
19:24:58 <applicative> so i wonder why its not finding it
19:25:01 <Raydiation> i see
19:25:08 <Raydiation> so i use the archlinux package
19:25:12 <Raydiation> of haskell plattform
19:25:34 <Shin-LaC> should I try to make my type an instance of Data.Collections.Map?
19:25:37 <Raydiation> so haskell plattform can also be installed with cabal?
19:25:43 <monochrom> what does "happy --version" say?
19:25:50 <applicative> oh okay, do 'cabal install happy'
19:26:14 <applicative> Raydiation: yes, see monochrom's page on this.
19:26:37 <Raydiation> ty that fixed it
19:26:45 <applicative> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
19:26:51 <applicative> Raydiation: ^^^
19:27:51 <applicative> cabal is a master at getting libraries and so on; executables needed for building are a different matter.
19:29:54 <applicative> Shin-LaC: I recommend Functor and Monad instances first ;)
19:30:23 <Shin-LaC> applicative: ok!
19:30:37 <Makoryu> A Functor instance should be fun
19:31:16 <Makoryu> > fmap negate [1..10]
19:31:17 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
19:31:23 <monochrom> w00t Haskell Weekly News!
19:31:37 <ion> Funpunctor
19:31:58 <Makoryu> (Though fmap wouldn't touch the keys, so I guess it doesn't matter)
19:32:42 <Ghoul_> if I want to make a server modular so I can `drop things in`, what's a good way to do that?
19:43:48 <ClaudiusMaximus> i want to generate imperative code from a specfication of needed outputs, available inputs, and possible processing steps.  i could use an algorithm similar to 'make' to emit sensible code, but i'm wondering if there's a better way that also handles loops and conditional execution
19:46:12 <slack1256> If another language has a C ffi and targets the llvm, it should relatively easy to ffi with it right?	
19:46:33 <Shin-LaC> ok, I have the functor instance
19:46:43 <ClaudiusMaximus> as a concrete example, suppose my input is a single linked list of numbers, and i want to generate several procedures, each of which outputs a combination of: length, minimum, maximum; and each does no more work than necessary, and only traverses the list once
19:47:35 <applicative> Shin-LaC: oh awesome
19:48:11 <Makoryu> slack1256: That kind of depends. If $OTHER_LANGUAGE exports C bindings for something, and you call them from Haskell (or vice versa) do the GCs interact with each other and mess everything up?
19:49:00 <Shin-LaC> applicative: I'm not sure what the semantics of Monad should be for a tree
19:49:14 <slack1256> I can use a subset of that language that doesn't have GC (rust)
19:49:15 <Shin-LaC> wait, don't tell me
19:50:14 <jmcarthur> Shin-LaC: not intending to spoil the answer, but it depends on the kind of tree, too
19:50:14 <Makoryu> slack1256: Ah, Rust... Can you even call into Rust from C yet?
19:50:41 <Makoryu> Shin-LaC: Might help you to work your way up from Functor to Applicative to Monad
19:51:14 <slack1256> call rust from C?
19:51:45 * slack1256 checking out
19:52:25 <Makoryu> slack1256: If you're gonna have separate runtimes flying around it might be easier to coordinate separate processes via message passing
19:52:44 <Makoryu> Er, I shouldn't call it "message passing"
19:52:50 <Makoryu> But you get the idea
19:53:53 <slack1256> !!, right, that doesn't sound good
19:56:08 <Raydiation> any reason why it warns you if you dont put main :: IO () on top of your main function?
19:56:21 <Raydiation> like     Top-level binding with no type signature: main :: IO ()
19:56:51 <Makoryu> Raydiation: That'd be because you enabled that warning...
19:57:04 <Raydiation> yeah, i mean why is there one?
19:57:31 <Clint> so you can enable it
19:57:37 <Makoryu> Raydiation: For style reasons, mostly, in case you need it
19:57:42 <Makoryu> You don't have to enable it
19:57:45 <Raydiation> i see thanks
19:58:05 <Makoryu> Raydiation: That, and it allows you to see what type GHC *thinks* your function is supposed to be
19:58:20 <Makoryu> So in case you accidentally a different type, you can fix it
19:59:56 <applicative> Raydiation: main can have the type IO Int, though no one seems to know why
20:00:07 <Makoryu> Raydiation: For example, if I define something with the wrong number of arguments for what it needs to do, GHC might not complain until I try to use it in another module, which isn't where the actual problem is
20:00:21 <Makoryu> But if I have that warning turned on, I can discover the problem right away
20:01:07 <applicative> -fno-warn-no-signature-for-main would probably be easy to implement
20:02:37 <thirsteh> is there any way for me to close a file handle when the program dies without installing all kinds of non-cross-platform signal handlers?
20:02:57 <thirsteh> (e.g. when terminated by a sighup signal)
20:03:11 <elliott> Raydiation: because you should give every top-level definition a type signature, generally.
20:04:24 <Raydiation> ok, so as for the type system in general i just have to provide the types in and types out signature for a function, everything will be inerred right?
20:04:55 <applicative> you don't usually need any signatures
20:05:04 <Raydiation> duck typing?
20:05:11 <sclv> no it can infer the signatures too
20:05:15 <applicative> no, inference
20:05:18 <Raydiation> wow
20:05:26 <monoidal> GHC can infer the signatures, however, it's good style to place them.
20:05:31 <sclv> in classic haskell 98 you need no type signatures ever
20:05:36 <Raydiation> as documentation iirc
20:05:38 <applicative> with fancy extensions, inference needs a bit of help
20:05:48 <sclv> yes, was just getting there :-)
20:06:00 <geekosaur> placing signatures, on the other hand, helps with debugging type errors; haskell can infer some unexpected types otherwise
20:06:29 <sclv> often i find it is good practice to first write what you want, then ask for the type, or first write the type, then write a function to match it
20:06:36 <geekosaur> it's very good at inferring surprising types from long chains of related expressions
20:06:43 <sclv> depending on which one of the two you're more 'sure' you know what it should be
20:07:33 <Raydiation> if this can be inferred im sure there are some ides who autogenerate this
20:07:48 <applicative> the other reason to give signatures is to force a concrete type; often the inferred type will be more general than you really want
20:08:10 <Makoryu> Raydiation: There are a whole bunch of tools to do exactly that in many different editors
20:08:15 <applicative> @type let f x y = x * y + 3 in f
20:08:16 <lambdabot> Num a => a -> a -> a
20:08:29 <applicative> @type let f x y = x * y + (3::Int) in f
20:08:30 <lambdabot> Int -> Int -> Int
20:08:34 <applicative> much more sensible
20:11:55 <applicative> + * 1, 2 , 3 can relate to any concrete type with a Num etc. instance; but it's rare that when I use arithmetical symbols that I am thinking of something I mean to make sense for all such types people come up with; usually I'm thinking of Int Integer Float or whatever
20:12:34 <applicative> so if I throw the word Int in somewhere, I put the compiler on my wavelength
20:13:15 <Makoryu> And it might as well be at the top level if it's going to be anywhere at all
20:13:17 <joelteon> did this ever get resolved? http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=671925
20:18:00 <monochrom> I think it's safe to say "no", since even over github there is no continuation
20:18:19 <carter> how many "xcode broke things" inquiries did we get today?
20:18:33 <monochrom> none other than the one you already know
20:18:36 <applicative> hah
20:18:51 <Makoryu> Still fighting with cpp -traditional?
20:19:12 <carter> eh?
20:19:41 <carter> who is?
20:19:54 <Makoryu> Er, everybody, I guess
20:20:09 <carter> Makoryu: i'm just the dude who's been using the work arounds for the past few months
20:20:11 <Makoryu> Unless Xcode broke things in novel and startling ways that I don't know about
20:20:16 * applicative thought carter was fighting the good fight against cpp -traditional
20:20:22 <carter> i am
20:20:39 <carter> applicative: well, more like thoughtpolice wrote the patch
20:20:47 <carter> iv'e just been making sure people know theres issues
20:20:50 <carter> and how to work aroudn them
20:21:15 <applicative> you recommend that we build the developement ghc with thoughtpolice 's patch
20:21:44 <applicative> but can i build ghc with my old ghc + XCode whatvernumber
20:23:40 <applicative> i guess I build the new ghc before installing the dangerous xcode version
20:23:55 <carter> yes
20:24:03 <carter> if you want ghc head
20:24:14 <carter> if you built with with old xcode
20:24:19 <carter> it'd be happy friends with new excode
20:24:21 <carter> xcode
20:24:46 <carter> 7.8 / head shoudl work with xcode 5
20:24:52 <carter> or you MUST file a bug report
20:24:59 <carter> please :)
20:25:34 <applicative> i haven't been installing xcode anyway
20:26:22 <applicative> but i think the plan i have been using won't work in the future anyway
20:26:43 <gentleben> who uses xcode?
20:26:50 <gentleben> and for what?
20:27:00 <gentleben> haskell things?
20:27:22 <Makoryu> gentleben: Think of Xcode as Apple's C family equivalent of the Haskell platform
20:27:22 <applicative> gentleben: i think in the haskell context it just gives you an omnibus of other things; the editor would be hard to use with haskell
20:27:47 <Makoryu> gentleben: In other words, it's not the IDE that's used or needed, but the compiler distribution that comes with it
20:28:03 <Makoryu> (Okay, that was a terrible comparison, but...)
20:28:33 <applicative> i'm not sure what all was needed really apart from a gcc
20:28:58 <Makoryu> Well, gcc + as + ld + cpp + ...
20:29:48 <applicative> i was thinking of cpp as a piece of gcc, but i see
20:30:06 <joelteon> I'm running out of stack space when cabal installing
20:30:08 <joelteon> what should I do
20:30:17 <applicative> what are you installing?
20:30:27 <joelteon> dependencies for my library
20:30:52 <joelteon> this is the file: https://github.com/joelteon/joelt.io.hs/blob/master/joelteon.cabal
20:31:03 <joelteon> but the only dependencies not installed are markdown, esqueleto, yesod-text-markdown, and imagemagick
20:31:09 <Makoryu> applicative: I think it's worth pointing out that the non-C-compiler parts (which are to blame for the current snafu) are specifically depended on
20:31:44 <applicative> yes, the cpp was the thing mentioned everywhere
20:32:03 <carter> Makoryu: nope, its clang
20:32:05 <carter> clang
20:32:06 <carter> clang
20:32:09 <carter> went the cpp
20:32:29 <carter> theres no reason why we coulden't have a backport of the clang compat patches to 7.6
20:32:37 <carter> just… someone has  to do it
20:32:47 <joelteon> and free -b says I have about 2.8GB of RAM free
20:32:51 <joelteon> I can't see cabal being that limited in stack space
20:32:55 <joelteon> unless that's a thing configured by debian?
20:33:00 <Makoryu> carter: http://ghc.haskell.org/trac/ghc/ticket/605 <- Like with this?
20:33:22 <carter> Makoryu: i don't understand your question
20:33:37 <carter> whats your quesiton?
20:33:46 <Cale> Some of the Xcode tools like Shark are actually pretty cool. It's kind of too bad we don't have something similar for Haskell code.
20:33:54 <Cale> (and on other platforms)
20:34:07 <Makoryu> carter: Not really a question. Just an observation of "we could have $THING, but someone has to do the legwork"
20:34:17 <Makoryu> For multiple values of $THING
20:34:25 <carter> Makoryu: oh yeah
20:34:28 <carter> sooo many nice htings
20:34:43 <applicative> awesome pile of dependencies joelteon . I don't know the solution though if it really is running out of stack space
20:34:45 <carter> just someone has to do it
20:34:50 <joelteon> thanks applicative
20:35:01 <joelteon> the top 70% is just yesod stuff
20:36:07 <applicative> so you managed to get highlighting-kate installed with no problem. It used to be the longest  most gruesome install on hackage
20:36:33 <joelteon> well, theoretically yah
20:36:45 <joelteon> but if the solver can't install it, i'm screwed anyway
20:36:57 <joelteon> why is there so little stack space, if I have 2GB free?
20:37:04 <joelteon> "Stack space overflow: current size 8388608 bytes."
20:37:19 <geekosaur> that's going to be increased in the next ghc, I believe
20:37:27 <applicative> this is happening while cabal reasons, or what it is building
20:37:31 <applicative> oh the latter i guess then
20:37:45 <geekosaur> it's artificially limited; try ghc +RTS --help
20:38:01 <joelteon> so I have to build my cabal-install with profiling?
20:38:09 <applicative> no
20:38:20 <geekosaur> what?
20:38:21 <applicative> unless you want to profile the executable?
20:38:27 <carter> joelteon: use sandboxes
20:38:36 <joelteon> no, I just want to increase the stack size
20:39:10 <geekosaur> right, what does that have to do with profiling?
20:39:26 <applicative> geekosaur: can he pass that kind of flag to ghc via cabal
20:39:31 <applicative> it must be possible
20:39:34 <joelteon> oh, wait
20:39:39 <joelteon> cabal needs to be linked with -rtsopts to enable that
20:39:41 <geekosaur> GHCRTS envar at worst
20:39:59 <leroux> cabal help build
20:40:34 <leroux> Actually.
20:40:43 <leroux> cabal help configure
20:41:01 <applicative> but why is joelton having trouble building eg. the markdown package
20:42:07 <joelteon> i'm having trouble resolving the dependencies
20:43:09 <applicative> wait, so it is cabal itself, while reasoning, that is freaking
20:43:33 <joelteon> yeah, if I pass -v, the error is printed after it starts resolving
20:43:41 <applicative> this sounds like a bug, I see
20:44:11 <applicative> that is, if we give it more stack space, it is unlikely to help...
20:46:59 <applicative> your repo gives  me this result http://sprunge.us/hcRJ
20:47:10 <applicative> joelton, I mean, attempting to install it does
20:49:38 <applicative> joelteon: if i scrap the constraint on haxparse, it resolves fine; this is in a sandbox
20:49:58 <joelteon> hmm
20:50:20 <joelteon> that's weird
20:50:30 <joelteon> I specifically update haxparse earlier today to not mess up the dependencies
20:50:51 <Raydiation> how would you implement a binary search tree? like in python id load in a file with words, create a tree structure with node classes and then call the search method on console input
20:51:17 <Raydiation> i mean i need to keep that structure in memory right?
20:51:29 <Raydiation> after it has been sorted
20:51:35 <applicative> joelteon: hm. are you using cabal sandbox?  It could be I have subtly different things in my global ghc-pkg
20:52:49 <applicative> joelteon: here's the result of --dry-run, fwiw http://sprunge.us/PYRS
20:53:44 <applicative> also of course one of us could have done cabal update more recently
20:54:20 * hackagebot type-natural 0.0.3.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.3.0 (HiromiIshii)
20:54:43 <Raydiation> do i simply store it in a function by using partial application?
20:54:44 <argiopeweb> Raydiation: What are you trying to accomplish?
20:55:02 <Raydiation> creating a simple binary search tree example
20:55:30 <applicative> joelteon: if i do 'cabal update' it doesnt interfere
20:55:56 <argiopeweb> Raydiation: Maybe this could help? https://gist.github.com/Kedrigern/1239141
20:56:15 <argiopeweb> Though if you're just trying to use one in an application, I'm sure there's something more useful in Hackage.
20:56:43 <Raydiation> argiopeweb: ty
21:00:40 <joelteon> applicative: i think it might be related that I can't ls the vagrant shared folder
21:01:37 <applicative> wait, which folder joelteon
21:01:50 <joelteon> /vagrant
21:01:54 <joelteon> which is the root dir for my project
21:02:01 <joelteon> i'm trying to set up my own build box
21:02:35 <applicative> but could that affect cabal's reasoning?
21:02:40 <joelteon> I don't know
21:02:47 <joelteon> maybe not
21:03:09 <Shin-LaC> ok, I can think of two ways of implementing applicative for my trees
21:03:53 <applicative> joelteon: it occurs to me, you said 'you already have x y z' installed, which of course does affect cabal-install's thinking
21:04:09 <joelteon> i have all but four of those packages installed
21:04:13 <applicative> joelteon: i was using cabal sandbox so only the things i have globally installed matter
21:04:25 <joelteon> well, same here
21:04:32 <applicative> grr
21:05:13 <applicative> wait. i get it, you have built this inside the sandbox but are now rebuilding
21:05:26 <joelteon> well, I installed most of the dependencies from libghc-*-dev
21:05:37 <applicative> grrrrr
21:06:35 <applicative> and that is installing them globally
21:06:43 <joelteon> yeah
21:07:14 <Raydiation> looking at the binary tree gist at https://gist.github.com/Kedrigern/1239141: data (Ord a, Eq a) => Tree a = Nil | Node (Tree a) a (Tree a)
21:07:15 <applicative> hmm, you can get a lot of this yesod stuff from a package manager?
21:07:23 <Raydiation> can you define a Node without defining it?
21:07:50 <Raydiation> like data Tree = Bool | Node?
21:07:52 <Cale> Whoa, that's deep
21:07:53 <Cale> heh
21:07:57 <applicative> Node Nil 12 Nil
21:08:03 <Cale> Raydiation: no, you can't
21:08:19 <Raydiation> so is Node a predefined type?
21:08:32 <applicative> Node (Node Nil 17 Nil) 37 (Node Nil 20 Nil)
21:08:36 <Cale> Raydiation: also, what you just wrote would be a datatype with two constructors, one of which was *called* "Bool", and the other of which is called "Node"
21:08:42 <applicative> no, its a constructor
21:08:46 <Shin-LaC> 1) pure makes a single-node tree; then <*> applies each function in the first tree to each thing in the second tree; I guess the keys of the resulting tree would be tuples of the original key types. the problem with this is that it does not seem especially useful
21:08:47 <Cale> Node isn't a type at all
21:08:51 <Raydiation> oh ok
21:08:52 <Cale> it's the name of a data constructor
21:08:55 <monochrom> no. it's a new thing you're defining. you can call it Joy or Nod
21:08:56 <Raydiation> i mean its built in :)
21:09:05 <applicative> my God he has data (Ord a) => Tree a = ...
21:09:09 <Cale> It's not built in, but brought into scope by the data declaration
21:09:21 <joelteon> applicative: https://gist.github.com/joelteon/46f5bf74f73dde526cab
21:10:03 <monochrom> data Whee a = May | Joy (Whee a) a (Whee a)  is the same essence with different names
21:10:20 <Shin-LaC> 2) <*> applies each function in the first tree to the object _with the same key_ in the second tree; this seems more useful to me, but the problem is, in which key would pure put the lifted object?
21:10:52 <Raydiation> i see, thanks
21:10:53 <Shin-LaC> it cannot be in "all keys"
21:11:09 <Cale> Raydiation: A data declaration defines not only a new datatype (which is named to the left of the = sign along with possibly some type variables which serve as parameters, but also a bunch of data constructors
21:11:25 <Shin-LaC> you can't have an infinite AVL tree
21:11:33 <monochrom> also, May and Joy will not be types. nothing like that.
21:11:45 <Cale> Each of the data constructor cases is separated by | and each named data constructor is followed by the types of its (value) parameters.
21:12:13 <Cale> So, when you write: data Tree a = Empty | Branch a (Tree a) (Tree a), for instance
21:12:50 <Shin-LaC> applicative: it seems to me that my type is not amenable to becoming an instance of Applicative :(
21:12:54 <Cale> You're not only defining a type constructor Tree :: * -> *, but also value constructors  Empty :: Tree a, and  Branch :: a -> Tree a -> Tree a -> Tree a
21:13:16 <Shin-LaC> there was someone else who had suggested something, but it scrolled past my back buffer and I don't have logs
21:13:17 <Cale> (* here is the kind of all types with ordinary values in them)
21:13:26 <Cale> For instance, Integer :: *
21:13:33 <Cale> :kind Maybe
21:13:35 <Raydiation> ok
21:13:41 <Cale> @kind Maybe
21:13:41 <lambdabot> * -> *
21:13:44 <Cale> @kind Maybe Integer
21:13:44 <lambdabot> *
21:14:53 <Raydiation> so this is shorthand for Branch :: a -> Tree a -> Tree a -> Tree a
21:15:00 <Cale> Raydiation: The data constructor names always start with a capital letter, and have the property that you're allowed to pattern match against them (unlike other functions)
21:15:06 <Cale> Yeah
21:15:06 <Raydiation> instead of writing Tree a = Empty | Branch
21:15:17 <Cale> That's incomplete...
21:15:17 <Raydiation> of a i suppose
21:15:26 <Cale> Well, you could write:
21:15:26 <Raydiation> Empty | Branch a?
21:15:38 <Cale> data Tree a = Empty | Branch a (Tree a) (Tree a)
21:15:53 <Cale> The Branch constructor here takes a value of type a, and two trees as arguments
21:16:01 <Cale> e.g.
21:16:15 <Cale> Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty)
21:16:20 <Cale> :: Tree Integer
21:16:30 <Raydiation> ok, so you cant shorten
21:17:08 <monochrom> "data Tree a = Empty | Branch" is legal but stands for something else. computer is not going to "do what you mean".
21:17:11 <Cale> If you turn on GADT syntax, you can write the data declaration like this though:
21:17:16 <Cale> data Tree :: * -> * where
21:17:20 <Cale>   Empty :: Tree a
21:17:29 <Cale>   Branch :: a -> Tree a -> Tree a -> Tree a
21:17:52 <Raydiation> ok that looks way better
21:18:11 <Cale> Raydiation: If you wrote data Tree a = Empty | Branch, then  Tree Integer  would be isomorphic to Bool.
21:18:17 <applicative> Shin-LaC: did you write a monad instance?
21:18:36 <Cale> indeed:
21:18:37 <Shin-LaC> applicative: no, I tried writing an applicative instance first
21:18:41 <Cale> data Bool = False | True
21:19:02 <Cale> False and True each take no parameters
21:19:09 <Cale> You could also have:
21:19:23 <Raydiation> btw, Empty is also user defined right?
21:19:29 <Raydiation> why Tree a
21:19:31 <Cale> data Colour = RGB Word8 Word8 Word8 | CMYK Float Float Float Float
21:19:33 <applicative> Shin-LaC: well, i take it return is obvious
21:19:49 <Shin-LaC> applicative: wait
21:20:01 <Cale> Raydiation: Well, let's stick to the sane definition:  data Tree a = Empty | Branch a (Tree a) (Tree a)
21:20:15 <Shin-LaC> was I not supposed to do applicative first, then monad?
21:20:20 <Cale> This says that a Tree of values of type a, is either the tree Empty (i.e. an empty tree)
21:20:27 <Raydiation> ah right
21:20:35 <Cale> or it consists of a Branch node applied to a value of type a, and two subtrees of type Tree a
21:20:43 <Cale> (i.e. a left and right subtree)
21:20:44 <applicative> Shin-LaC: you can do it that way, but there will be at least two applicative instances for this type, if there is a monad instance
21:20:58 <Shin-LaC> hm
21:21:07 <Shin-LaC> so I should go for the monad directly instead?
21:21:25 <applicative> if you plan on a monad instance you should write it first
21:21:31 <Shin-LaC> ok
21:21:36 <monochrom> do whatever you can do
21:21:44 <Shin-LaC> I have to leave this location
21:21:54 <Shin-LaC> thanks for all the help guys, I'll be back later
21:22:06 <applicative> the natural applicative instance in this case will not cohere with the monad instance
21:22:45 <monochrom> guess what? when I was learning free monads, I had trouble writing >>= for it. but I found that I could write join for it with ease. so I did that first, then used it to see what >>= looks like
21:22:49 <Cale> and moreover ensures that every value of type Tree a either doesn't terminate (because we can't ensure that it does without solving the halting problem or weakening our programming language), or it is Empty, or it is Branch applied to some arguments of the appropriate types.
21:22:55 <applicative> or anyway, the one that will come to mind most readily
21:23:15 * applicative always writes join first
21:23:17 <monochrom> do what is easy to you first. then use it to help learn the hard ones
21:23:34 <applicative> i was about to recommend that to Shin-Lac
21:23:41 <ParahSail1n> @src join
21:23:41 <lambdabot> join x =  x >>= id
21:23:53 <applicative> but s/he really did vanish
21:24:39 <Raydiation> just quick question: Empty :: Tree a means empty is of type Tree a?
21:25:10 <applicative> joelteon: i think this is a bug in cabal, but I think the problem must be complicated by the stuff from the package manager
21:25:16 <haasn> Raydiation: it means Empty is of type Tree a
21:25:17 <joelteon> hmmm.
21:25:37 <joelteon> applicative: i removed all the apt packages
21:25:37 <applicative> i have a feeling that's going especially badly with cabal sandbox
21:25:39 <joelteon> and same problem
21:25:39 <Raydiation> haasn: ty
21:25:41 <haasn> Raydiation: (alternatively, it means Empty is of kind Tree a, but I guess that's not relevant here :)
21:25:42 <joelteon> not using a sandbox
21:25:44 <applicative> grrrrrrr
21:25:44 <monochrom> join is easier to write under this circumstance: when you plan to write for the type. join's type is shorter, you have fewer things to worry. >>='s type is longer, you have more things to worry.
21:26:02 <Raydiation> the syntax takes some time to get used to
21:26:08 <Cale> (kinds are to types what types are to values)
21:26:17 <ParahSail1n> would it be completely bad and irresponsible to use a ByteArray# to store unboxed data type to eke storage overhead from a data structure?
21:26:18 <applicative> what are values?
21:26:19 <haasn> Raydiation: not that since Empty is starts with a capital E, this being true means ‘Empty’ is a constructor of the ‘Tree a’ type. If you saw that line in actual code, it may have been in a GADT definition
21:26:24 <haasn> s/not that/note that/
21:26:50 <Cale> ParahSail1n: You could, but there are UArrays or unboxed Vectors for that which might be nicer
21:27:08 <monochrom> values are the lowest class labour force in the class struggle :)
21:27:09 <Cale> (and in the case of Vectors, there's a lot of optimisation machinery already there to help things along)
21:27:11 <applicative> joelton what does ghc-pkg check say, or what does ghc-pkg list show in the global registry or whatever they call it
21:27:32 <ParahSail1n> Cale, wouldnt Vector come with the overhead of that constructor?
21:27:52 <joelteon> applicative: the normal haskell platform setup
21:28:00 <applicative> joelteon: grrrrr
21:28:03 <ParahSail1n> Cale, i want to seriously optimize for size minimization
21:28:19 <ParahSail1n> without of course going to c ffi
21:28:45 <Cale> ParahSail1n: It'll *probably* do a better job than you of optimising the code because of stream fusion.
21:29:01 <monochrom> Vector comes with what constructor?
21:29:02 <applicative> joelteon: and this is ghc-7.6 like me, I suppose
21:29:09 <joelteon> yeah
21:29:15 <Cale> and yeah, what constructor are you talking about exactly?
21:29:20 <shachaf> Hmm, so is monad a useful function?
21:29:31 <shachaf> monad :: Monad m => Free m a -> m a
21:29:44 <shachaf> Oh, edwardk calls it retract.
21:29:50 <Cale> shachaf: For a moment there I thought you were trolling
21:30:04 <Cale> @remember shachaf Hmm, so is monad a useful function?
21:30:04 <lambdabot> It is stored.
21:30:10 <shachaf> :-(
21:30:27 <shachaf> class Functor m => Monad m where monad :: Free m a -> m a is a valid definition of Monad.
21:32:04 <ParahSail1n> what does Vector {-# UNPACK #-} !Int {-# UNPACK #-} !Int {-# UNPACK #-} !(Array a) look like in memory
21:32:35 <monochrom> I see. that constructor.
21:32:36 <applicative> like an array with two Ints stuck on it
21:32:37 <Cale> ParahSail1n: You're looking at *boxed* vectors
21:32:59 <Cale> ParahSail1n: Those *will* be arrays of pointers to code for computing the elements
21:33:02 <monochrom> but you still don't know what happens to it after a lot of -O and actual uses
21:33:50 <sclv> shachaf: well you need to equip it with some laws too iirc
21:34:01 <Cale> -- | Unboxed vectors of primitive types
21:34:01 <Cale> data Vector a = Vector {-# UNPACK #-} !Int
21:34:01 <Cale>                        {-# UNPACK #-} !Int
21:34:01 <Cale>                        {-# UNPACK #-} !ByteArray
21:34:01 <Cale>   deriving ( Typeable )
21:34:02 <shachaf> sclv: Sure.
21:34:08 <ParahSail1n> cale arrays of pointers to code?
21:34:17 <shachaf> sclv: What're the laws?
21:34:28 <sclv> its your class, you tell me!
21:34:43 <Cale> ParahSail1n: yep!
21:34:47 <shachaf> monad has to be a free monad monad algebra, or something like that.
21:34:53 <shachaf> That's what arkeet said, I think.
21:34:56 <shachaf> It sounds plausible.
21:35:04 <Cale> ParahSail1n: Boxed vectors/arrays/what-have-you leave the machinery required for lazy evaluation intact
21:35:17 <Cale> ParahSail1n: and so your arrays can have unevaluated expressions in their cells
21:35:31 <Cale> This can be really useful, because it lets you define the elements of an array circularly
21:35:39 <ParahSail1n> cale, ok, but if you have 100 billion of those in memory, you will have overhead for all three parameters of that constructor?
21:35:42 <Cale> But it's also fairly costly
21:35:43 <dolio> shachaf: That's not nearly good enough.
21:35:58 <Cale> no, the first two parameters are Ints
21:36:04 <shachaf> dolio: OK, what should the laws be?
21:36:32 <ParahSail1n> what about for that Array, is there overhead for that constructor?
21:36:34 <dolio> Oh, actually, maybe it is.
21:37:08 <dolio> Yes.
21:37:23 <ParahSail1n> Cale, so would the data of the Array follow those Ints directly, as if it were a c struct?
21:37:24 <Cale> The {-# UNPACK #-} will put information for the constructor for Array directly into the data constructor for Vector
21:37:48 <Cale> yes, but in the unboxed case, you're getting an array of pointers to code which go all over the place
21:37:54 <applicative> it's easy to state the laws just define return and join in terms of monad and so on. Of course, checking them in any case is hopeless
21:38:05 <Cale> (code which computes the value the first time, and then returns it immediately thereafter)
21:38:15 <Cale> er, sorry, the *boxed* case
21:38:40 <sclv> we can take the normal monad laws and replace return with (monad . Pure) and replace join with (monad . Roll) or etc, i'd imagine, to get at the laws another way
21:38:41 <Cale> In the unboxed case, you get a negligible amount of overhead, followed by a tightly packed array of values
21:39:35 <ParahSail1n> cale, so in unboxed, you could have equivalent to the c "struct {int; int; char[n];}"?
21:39:36 <applicative> sclv: yes, they can be stated; but your point in favor of a more familiar Monad class is a good one
21:39:49 <applicative> maybe we can make monad a method of the Monad classs
21:39:50 <shachaf> sclv: Well, you want a law that applies to any level of nesting.
21:39:50 <Cale> ParahSail1n: pretty much, yes
21:39:58 <ParahSail1n> pretty much?
21:40:00 <Cale> ParahSail1n: Of course, these values overall are boxed
21:40:12 <shachaf> sclv: Just like for monoids you can have laws for mempty and mappend or for mconcat.
21:40:12 <Cale> So a value of this type is a pointer to code for computing one of these things
21:40:24 <dolio> It's the same as saying that monoids are algebras of the free monoid.
21:40:31 <dolio> Roughly.
21:40:59 <shachaf> That makes sense.
21:41:07 <Cale> (like the values of every ordinary type)
21:41:12 <dolio> Actually, the direct correspondent...
21:41:18 <ParahSail1n> cale, but if you are storing a couple billion of these in memory, it will get evaluated to the strict storage size similar to the c struct?
21:41:35 <Cale> A couple billion arrays, or a couple billion elements in one array?
21:41:48 <ParahSail1n> a couple billion arrays, yes
21:42:06 <dolio> Is that Free (composed with the forgetful functor) gives you a monad on endofunctors.
21:42:25 <ParahSail1n> ive got a terabyte of ram that i want to put as much into as i can
21:42:26 <dolio> The free monad monad.
21:42:38 <dolio> And monads are the algebras of that monad.
21:43:00 <dolio> (M, monad : Free M => M)
21:43:18 <Cale> Well, each one will end up a pointer to code which will either allocate a new array and compute it, or return the already-computed value immediately.
21:44:04 <Cale> (and in the first case, it will redirect the pointer to point at the shorter code for returning the already computed value)
21:44:29 <carter> ParahSail1n: you probably want unboxed arrays
21:44:36 <carter> else the GC will kill you on 1 TB
21:44:37 <Cale> But if you just have a flat unboxed array, you avoid that
21:44:57 <carter> anyone here know x86 att syntax?
21:44:58 <Cale> and you can still index that array by pairs, for instance (that's just an easy index calculation anyway)
21:45:11 <carter> trying to understand whats wrong with my patch for ghc
21:45:44 <monochrom> yikes, att syntax. is that similar to what gcc produces?
21:45:53 <dolio> shachaf: Monads are algebras of the free monad monad.
21:45:53 <carter> i mean that
21:45:55 <dolio> New slogan.
21:46:00 <carter> monochrom:http://ghc.haskell.org/trac/ghc/ticket/8256
21:46:09 <shachaf> carter: Sure (but you might be better off asking in #-blah?).
21:46:17 <carter> its haskell related
21:46:22 <carter> patch i'm doing for ghc :)
21:46:25 <carter> http://ghc.haskell.org/trac/ghc/ticket/8256
21:46:38 <applicative> i don't see why the free monad monad shouldn't -blah
21:47:23 <monochrom> I only know things like: "movl $0, %eax" means eax:=0, not 0:=eax.
21:49:29 <shachaf> xor %eax,%eax means xor eax and eax and put the result into eax, not into eax.
21:50:51 <elliott> applicative: because haskell is off-topic in -blah? :p
21:53:01 <argiopeweb> elliott: What is on-topic in -blah?
21:53:27 <monochrom> free monad is free to visit both #haskell and #haskell-blah. it's so free. :)
21:54:14 <elliott> free or easy, pick any two. buy one and get one free
21:55:51 <applicative> yes, but the free monad monad is a different topic
21:56:10 <applicative> carter: your patch is off topic on #haskell, try #ghc
21:56:18 <carter> applicative: :P
21:56:23 <carter> no one was there rightnow
21:57:03 <applicative> the question, whether anyone is present on #ghc is off topic on #haskell
21:57:19 <gamegoblin> So I've opened a file into a char8 bytestring, giving me an IO bytestring. Is there any way to write this data to a socket? sendAll expects a bytestring, not an IO bytestring. I am a bit of a haskell newbie, so help is appreciated
21:57:37 <applicative> use >>=
21:57:59 <gamegoblin> so my current line is "sendAll socket my_bytestring"
21:58:04 <gamegoblin> what would it be with that syntax
21:58:10 <jhormuz__> how can you filter by data constuctor using control.lens?  IE- if you have a list of "data Pet = Dog String | Cat Int", how can you get the 4th dog in the list?
21:58:23 <jhormuz__> It string....
21:58:24 <applicative> readFile x >>= \my_bytestring -> sendAll socket my_bytestring
21:58:44 <gamegoblin> ahhhh I see
21:58:46 <gamegoblin> thanks
21:58:50 <argiopeweb> gamegoblin: Also, if you're working with text, Data.Text may be a better choice. Bytestring.char8 has a tendency to butcher UTF text.
21:59:02 <argiopeweb> Though it slightly increases the complexity of sending it to the socket.
21:59:07 <gamegoblin> socket expects bytestring char8 as far as I know
21:59:15 <monoidal> can be simplified to readFile x >>= sendAll socket
21:59:33 <gamegoblin> thanks all. I take it this is some monad voodoo?
21:59:54 <applicative> you're deep into gamegoblin
21:59:55 <argiopeweb> gamegoblin: Indeed. >>= is the monadic bind operator.
21:59:57 <applicative> into it
22:00:13 <gamegoblin> any short explanation?
22:00:19 <gamegoblin> not of monads, just the use here
22:00:39 <argiopeweb> >>= unpacks a monadic context and passes it to a function that operates on and repacks it.
22:00:58 <gamegoblin> alright
22:01:01 <gamegoblin> I think that makes sense
22:01:03 <applicative> do {my_bytestring <- BS.readFile file; sendAll socket my_bytestring} might be as good as anything
22:01:05 <argiopeweb> (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:01:15 <gamegoblin> so it guarantees no side effects I guess?
22:01:30 <applicative> if you put it in a list nothing will happen
22:02:01 <applicative> length [do {my_bytestring <- BS.readFile file; sendAll socket my_bytestring}, do {my_bytestring <- BS.readFile file; sendAll socket my_bytestring}] = 2
22:02:23 <gamegoblin> Ahhhh that code worked perfectly... excellent... I now have a super super simple haskell web server... \o/
22:02:24 <applicative> if you identify it with main then there will be ample side effects
22:02:55 <argiopeweb> gamegoblin: Sending code over a socket is technically a side-effect (even though it's the intended one)
22:03:10 <argiopeweb> All bets are off in IO.
22:03:15 <gamegoblin> Ahh, yes. I guess I mean in-data side effects in my program
22:03:38 <gamegoblin> I will have to read more about this monadic binding business now..
22:03:49 <gamegoblin> I have been fumbling around this problem for some time now and that's all I really needed
22:04:03 <gamegoblin> So thanks for the quick answer
22:08:23 <WraithM> @pl \e1 e2 -> App (App (Var f) e1) e2
22:08:23 <lambdabot> App . App (Var f)
22:22:07 <SrPx> So clean is generally a better language than haskell but the fact nobody uses, there are no libs, no package manager, no nothing, is what makes it a worse choice in general ?
22:22:30 <Makoryu> SrPx: "Better" is probably subjective.... probably...
22:22:58 <SrPx> Makoryu: they said it is **just** haskell with a little modification here or there
22:23:08 <Makoryu> I didn't see who said that
22:23:14 <Makoryu> So
22:23:51 <Makoryu> Anyway, sure, it's in the same (smallish) family of languages based on certain influences
22:24:16 <carter> miranda!!!!!
22:24:17 <carter> :)
22:24:20 <Makoryu> OCaml is a more distant relative, and much better known than Clean
22:24:22 * hackagebot crypto-cipher-types 0.0.6 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.6 (VincentHanquez)
22:24:24 * hackagebot crypto-cipher-tests 0.0.8 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.8 (VincentHanquez)
22:24:25 <Makoryu> Yeah Miranda was like
22:24:26 * hackagebot crypto-cipher-benchmarks 0.0.4 - Generic cryptography cipher benchmarks  http://hackage.haskell.org/package/crypto-cipher-benchmarks-0.0.4 (VincentHanquez)
22:24:33 <Makoryu> The immediate predecessor to Haskell, wasn't it?
22:25:32 <hpaste> latro`a pasted “how bad?” at http://lpaste.net/93159
22:25:39 <latro`a> ^how bad of style is that?
22:25:44 <latro`a> serious question
22:26:31 <latro`a> tl;dr I guarantee a refutable match is not refutable by catching the failure case
22:26:57 <monochrom> I do not pick on the subjectivity of "better". I think everyone here has taste for what "better" means.
22:27:05 <latro`a> true
22:27:07 <monoidal> latro`a: I pasted an annotation
22:27:13 <monoidal> latro`a: refresh the page
22:27:20 <monochrom> I pick on, instead, the subjectivity of "similar", "little difference", things like that
22:27:39 <latro`a> that helps
22:27:43 <latro`a> good catch
22:28:00 <monochrom> I disagree that Clean is Haskell with a "little modification". it has a bloody different type system.
22:31:18 <latro`a> monoidal, I like how you can reason enough about this with almost no context whatsoever to make a suggestion like that
22:31:29 <latro`a> (both generic and specific you, in this case :))
22:32:50 <Makoryu> SrPx: Anyway, you might say, abstractly, that the Haskell plan for world domination isn't to get GHC to take over, so much as to popularize all the stuff that makes Haskell better than the alternatives
22:33:11 <Makoryu> So, in one sense, sure, Clean is most of the way there
22:33:22 <Makoryu> But on the other hand, nobody has ever heard of it, so it doesn't help the plan much ;)
22:34:17 <acomar> does hsc2hs have some kind of timeout on processing? I have a very large set of bindings I've generated in a file and it's erroring out with weird "unacceptable argument" errors at the *very* end of the file, when it accepts equivalent arguments earlier in the file.
22:34:32 <acomar> I guess I can split it out into a couple files and find out, but it's odd
22:38:52 <SrPx> monochrom: is it so different?
22:39:31 <SrPx> Makoryu: /hmms
22:40:17 * SrPx is still looking for a functional language like haskell that is faster than C in general 
22:40:45 <Makoryu> You're not gonna find something like that
22:41:02 <KingsleyT> SrPx: my sides
22:41:04 <Makoryu> If you had a supercompiler, maybe
22:41:10 <monochrom> SrPx, Clean has uniqueness type and uses it for states and effects, Haskell does not have uniqueness type and does not use it for states and effects.
22:41:38 <SrPx> KingsleyT: sides? (non english speaker)
22:41:52 <SrPx> monochrom: yes and that is the only difference right?
22:42:05 <KingsleyT> SrPx: sorry, it's an expression. means I found what you said to be funny
22:42:20 <monochrom> I do not know of other differences
22:42:31 <SrPx> why is it so funny
22:43:10 <Makoryu> SrPx: C and C++ are the most aggressively optimized languages in the world right now
22:43:28 <SrPx> But why, world?
22:43:32 <Makoryu> The compilers available for them are enormously difficult to beat
22:43:40 <monochrom> do not use "only" so easily. the language's effect story completely changes how you use that language.
22:43:40 <KingsleyT> SrPx: because they're the most used
22:43:48 <SrPx> But why, world?
22:44:09 <Makoryu> SrPx: What do you mean?
22:44:39 <monochrom> I mean how you structure your programs in that language, what abstractions you build or don't build
22:44:40 <SrPx> nothing, really, I'm in an eternal denial about that, it is just so wrong.
22:45:17 <KingsleyT> that, and functional languages tend to be higher level than C and require recursion as the main way of interacting, which means they're inherently slower unless the compiler massively modifies your code on compilation, to my understanding
22:45:35 <KingsleyT> although I am a haskell newbie and may be underestimating the prowess of compilers
22:46:12 <SrPx> I just don't get how it is so difficult to compile a "map (*2) [1 2 3 4]" to a "for(int i=0; i<4; ++i) arr[i]*=2"
22:46:23 <KingsleyT> functional languages seem to win out when you need to massively parallelize your code, though?
22:46:48 <Makoryu> KingsleyT: There *are* certain types of functions for which the recursive version is far, far simpler to optimize
22:46:48 <SrPx> KingsleyT: except haskell doesn't do that automatically for some reason
22:46:51 <Makoryu> Just FWIW
22:47:03 <acomar> SrPx: it's much harder than it sounds, though there is some work on that front; check out Repa
22:47:15 <KingsleyT> Makoryu: neat :V
22:47:24 <SrPx> is that a language? acomar
22:47:36 <Makoryu> SrPx: Repa is a Haskell library
22:47:37 <acomar> SrPx: no, it's a haskell library
22:48:45 <peddie> SrPx: one is on a linked list; the other is on an array . . . but maybe you want to read about stream fusion
22:49:52 <SrPx> I'm reading about it, very interesting
22:50:20 <Makoryu> SrPx: The fun thing about Haskell (which you won't find in Clean) is that its design makes it easy to write libraries that add crazy new features to the language
22:50:36 <SrPx> such as?
22:50:36 <Makoryu> And the community takes advantage of this, a lot
22:50:40 <Makoryu> Such as Repa
22:51:10 <acomar> in any case, tail call optimization can turn that map statement into a loop like you want, but it can't turn a bunch of spread out map/fold calls into a nice nested loop like you'd want. That's where stream fusion comes in.
22:57:37 <SrPx> acomar: and does fusion always work to transform maps/folds into a single loop?
22:58:37 <Makoryu> SrPx: It isn't perfect. There are some things that break it.
22:59:02 <lieven_> in general, it's probably equivalent to the halting problem.
22:59:45 <NemesisD> starting to feel like i made the wrong choice using optparse-applicative
22:59:52 <lieven_> funny how long these things take to get done. Waters' SERIES package was an attempt in Common Lisp 30 years ago.
23:01:28 <johnw> NemesisD: why is that?
23:01:38 <acomar> SrPx: the goal isn't really to get it down to a single loop, it's to get it down to a compact set of nested loops and eliminate as many intermediary data structures as possible
23:02:00 <acomar> like if you do map (*2) (map (*2) [1, 2, 3, 4])
23:02:14 <acomar> you don't want to first generate [2, 4, 6, 8] before you apply the second map
23:02:23 <acomar> that's a waste of time and memory
23:02:36 <SrPx> makes sense
23:02:45 <acomar> so you'd like map f (map g xs) to be converted into map (f . g) xs
23:03:00 <shachaf> Just use CoYoneda!
23:03:06 <johnw> yeah, was just going to say :)
23:03:27 <shachaf> (That's a joke, though.)
23:03:34 <acomar> :/ I need to go figure out the yoneda lemma sometime soon
23:03:38 <NemesisD> johnw: man does it have a sprawling API
23:03:47 <NemesisD> and hasn't been updated in 2013
23:04:11 <johnw> lowerYoneda $ fmap (*2) (fmap (*2) (liftYoneda [1,2,3,4]))
23:04:17 <SrPx> I guess `x = [1 2 3 4 5]; y = minimum x; z = maximum x;` this sounds too like a waste of time/memory, if you loop x twice... can ghc detect that you are going to iterate x and thus find maximum/minimum in the same loop?
23:04:23 <johnw> turns into fmap ((*2) . (*2)) [1,2,3,4]
23:04:23 * hackagebot pipes-concurrency 2.0.1 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-2.0.1 (GabrielGonzalez)
23:04:47 <SrPx> I see
23:04:49 <johnw> SrPx: Gabrial has a monadic Foldl library that can do that
23:04:54 <johnw> i mean, Tekmo
23:05:10 <carter> johnw: xcodes happy again?
23:05:17 <johnw> carter: yeah, thank you so much
23:05:23 <carter> np
23:05:24 <SrPx> johnw: really? A lib that does that? I thought that would be a job for the compiler
23:05:24 <johnw> only lost about 2 hours of work to that madness
23:05:37 <carter> i'm so FP complete owes me eh?
23:05:43 <carter> *FP complete owes me eh
23:05:46 <johnw> SrPx: fuse your use of maximum/minimum into a single fold?  hmm
23:05:55 <johnw> i can't say it won't do that some day, but it doesn't now
23:06:14 <carter> ghc is actually pretty dumb
23:06:18 <Makoryu> SrPx: Like I said, Haskell makes it surprisingly easy to implement crazy new language features as a library
23:06:20 <carter> its just every other compliers a bit worse
23:06:33 <monochrom> ghc is dumb. but I'm dumber.
23:06:38 <carter> johnw: btw i'll be icfp
23:06:44 <carter> or at least the first half of the week
23:06:59 <SrPx> Makoryu: can you explain how that would work?
23:07:09 <johnw> carter: I'll be there for the latter half :(
23:07:16 <carter> aroudn wednesday?
23:07:20 <johnw> yes
23:07:22 <carter> ok
23:07:29 <Makoryu> SrPx: Abusing the type system, mostly
23:07:33 <carter> i've not finalized my trip back
23:07:47 <carter> @hackage async SrPx  check it out
23:07:47 <lambdabot> http://hackage.haskell.org/package/async SrPx  check it out
23:08:33 <carter> is a cool example of language feature in a library
23:09:23 * hackagebot asn1-types 0.2.1 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.2.1 (VincentHanquez)
23:09:25 * hackagebot asn1-encoding 0.8.1 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.8.1 (VincentHanquez)
23:11:32 <gli> could somebody help me with using GADT inside GADT? For example, how should I rewrite the following code:
23:11:33 <gli> type Point = (Int,Int)
23:11:33 <gli> data Coord where
23:11:33 <gli>   Vertice :: Point -> Coord
23:11:33 <gli>   Edge :: Point -> Point -> Coord
23:11:33 <gli> data Color = Red | Green | Blue
23:11:34 <gli> data Label where
23:11:35 <gli>   VLabel :: String -> Vertice -> Label
23:11:35 <gli>   ELabel :: Color -> Edge -> Label
23:11:44 <johnw> gli: please use the pasting service linked to in the topic
23:11:44 <shachaf> gli: Please don't paste more than a couple of lines of code in here.
23:11:46 <shachaf> Use hpaste.org
23:11:52 <gli> oh, sorry
23:12:26 <gli> could somebody help me with using GADT inside GADT? For example, how should I rewrite the following code:
23:12:26 <gli> http://lpaste.net/93163
23:12:32 <shachaf> Anyway, in this csae the issue is that Vertice and Edge aren't types.
23:12:36 <shachaf> They're constructors.
23:12:41 <SrPx> carter: checking
23:12:59 <gli> yep, I do understand, but can't see any workable decision
23:13:06 <shachaf> And, by the way, you don't need GADT syntax here. This is equivalent to: "data Coord = Vertice Point | Edge Point Point; data Label = VLabel String Vertice | ELabel Color Edge"
23:13:33 <shachaf> (But of course that's still an error of mixing up types and values.)
23:13:39 <gli> it's simplified version,
23:13:47 <shachaf> OK.
23:14:02 <shachaf> It sounds to me like "Vertice" and "Edge" can be separate types, if that's what you want.
23:14:17 <monoidal> you can write data LabelType = Vertex | Edge; data Label a where VLabel :: String -> Label Vertex; ELabel :: Color -> Label Edge
23:14:33 <monoidal> but is it really what you need? I don't think so
23:14:37 <gli> I need a lot of logic where this should be the same type. Or I have a lot of duplicate code
23:14:56 <monochrom> data Coord = Vertice Point String | Edge Point Point Color. no Label type, terminated. unless you can convince me otherwise.
23:15:15 <haasn> ^- this but parametrize String/Color if you sometimes don't need it
23:15:17 <haasn> is what I thought
23:15:31 <monochrom> yes, I don't mind that
23:17:14 <gli> monoidal: I will try your version, it might help
23:17:27 <gli> monochrom: I need label for my logic :)
23:18:05 <gli> thanks, guys
23:18:06 <monoidal> gli: with monochrom's version you might have label :: Coord -> Either String Color
23:18:58 <latro`a> how do you organize bottom-up-ish code?
23:19:14 <edwardk> kylcarte++ # excellent proof reading feedback
23:19:27 <monochrom> organize it bottom-up, I guess?
23:19:33 <latro`a> I have ~20 top level functions now, and only a vague way in which they're grouped
23:19:49 <latro`a> most of them are small, with a couple big logic chunks that pull together
23:20:02 <gli> monoidal: actually, I have 3 choice logic there, not 2, so Either won't work here
23:20:18 <latro`a> in terms of actually finishing projects I'm mostly used to monolithic things, so bottom-up style is kinda new to me
23:20:34 <edwardk> latro`a: i tend to just taxonomize in the grossest sense, e.g. does this make new things? extract information from them? update them?
23:20:42 <gli> monoidal++
23:20:44 <gli> :)
23:20:53 <latro`a> right now pretty much everything is components of "updaters"
23:21:05 <latro`a> which perhaps suggests that I need to split further
23:21:11 <latro`a> build more "extractors" and then call those
23:21:23 <ReinH> leeeeens
23:21:40 <latro`a> lens would help, but not all of it is as simple as just looking
23:22:01 <ReinH> latro`a: lenses do more than "just look"
23:22:04 <latro`a> true
23:22:09 <latro`a> but I mean the extraction aspect
23:22:34 <ReinH> lenses do that
23:22:41 <johnw> monoidal<>
23:22:46 <johnw> edwardk!
23:22:47 <latro`a> I have things like this:
23:22:48 <edwardk> you can view the notion of the lens package as splitting between 'what to do' and 'what to do it to'.
23:22:56 <johnw> edwardk: i'm using tables in anger today
23:23:07 <hpaste> latro`a pasted “score” at http://lpaste.net/93164
23:23:10 <edwardk> johnw: i find it very anger inducing, let me know how it goes ;)
23:23:14 <latro`a> these are "extraction"
23:23:17 <johnw> very well, in fact
23:23:18 <latro`a> (points is a field)
23:23:28 <latro`a> but at the same time they're "processing"
23:23:32 <johnw> it has exactly the behavior I was needing today, in a nice compact interface
23:23:40 <haasn> edwardk: what's your biggest library in terms of source code? lens?
23:24:01 <WraithM> pAssignments = pAssign `endBy` many1 newline
23:24:14 <edwardk> haasn: released? probably lens. maybe an older released c++ project or three
23:24:21 <elliott> @remember edwardk <johnw> edwardk: i'm using tables in anger today  <edwardk> johnw: i find it very anger inducing, let me know how it goes ;)
23:24:21 <lambdabot> Done.
23:24:26 <WraithM> So, I'm trying to parse many top level assignments and they can be followed by many newlines. Is there a sane way to do that?
23:24:28 <elliott> lens barely counts as code though.
23:24:31 <elliott> it's 90% boilerplate.
23:24:42 <WraithM> in Parsec
23:24:46 <elliott> you could probably write a version of djinn to generate half the library.
23:24:47 <edwardk> sure, it's all about getting ghc to put 'id' in the right place.
23:25:30 <monoidal> latro`a: it might be a matter of taste, but IMO it's better to write it without a pattern guard: score (Just (IslandTile isl)) | mAny ... = points isl; score _ _ = 0
23:25:43 <edwardk> WraithM: are you rquiring only newlines or allowing for trailing whitespace as well?
23:25:51 <latro`a> I had looked at it both ways
23:25:59 <WraithM> edwardk: trailing whitespace is fine
23:25:59 <latro`a> I'm not sure of my preference
23:26:07 <WraithM> Yeah, I should add that too
23:26:32 <acomar> anyone familiar with bindings-dsl?
23:26:49 <latro`a> the only thing is that it seems weird to have the incomplete guard
23:26:50 <monoidal> latro`a: btw, do you use hlint?
23:26:53 <ReinH> Any time I see large guards I feel like there's an important missing function or type
23:26:59 <latro`a> I know of it, but I haven't used it for this project yet
23:27:03 <acomar> trying to figure out why the type names it generates (C'<typename>) are coming up as unacceptable
23:27:29 <WraithM> but if that complicates things a lot, I could just do newlines.
23:27:36 <edwardk> WraithM: typically i'd use a lexeme parser and just have it deal with the trailing space for me
23:27:44 <WraithM> Right
23:28:06 <latro`a> idk, I don't like the f (Foo x) | g x = h x; f _ = y
23:28:10 <latro`a> style
23:28:15 <latro`a> because it has an incomplete guard
23:28:33 <haasn> johnw: I've been using ‘tables’ for all kinds of indexable collections now, it's really nice
23:28:35 <latro`a> which for whatever reason I find harder to reason about
23:28:43 <ReinH> latro`a: I don't like incomplete anything
23:28:58 <latro`a> I see a match of (Foo x) on the left, and I expect to see the return value in that equatino
23:29:00 <latro`a> *equation
23:29:01 <johnw> haasn: I feel like most of my Tabular instance is pure boilerplate, apart from deciding which fields are my indices and of which kind
23:29:12 <latro`a> with the style up there, I may not get it, it may be in the following equation
23:29:23 * hackagebot flower 0.7.2 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.7.2 (KetilMalde)
23:29:34 <latro`a> the downside, of course, is that rather large guard, as was pointed out
23:29:50 <ReinH> latro`a: agree that symmetry is important. Not suggesting that you break symmetry.
23:30:02 <WraithM> edwardk: Thanks, I think this is exactly what I wanted.
23:30:18 <latro`a> perhaps it's more that the two checks in the second part of the guard should be named
23:31:23 <haasn> johnw: I committed some TH to generate (simple) Tabular instances, a week ago or so
23:31:27 <carter> johnw: haasn  cool! i plan on playing with tables oon
23:31:29 <carter> *soon
23:31:31 <haasn> johnw: that might help, if you're on HEAD
23:32:50 <hpaste> latro`a annotated “score” with “score (annotation)” at http://lpaste.net/93164#a93165
23:33:01 <latro`a> ^thoughts on that change?
23:34:27 <acomar> well, guess I'll try and figure it out tomorrow. /msg me if you have any ideas on my bindings-dsl problem. Night all!
23:42:26 <ReinH> latro`a: I would probably write something like this and then work on cleaning up isKing and isDocked https://gist.github.com/reinh/f4b4859abcbea43fc9a7
23:46:49 <ReinH> (which takes some advantage of the free variables defined in the outer function to clean up the where clause)
23:46:58 <johnw> haasn: thanks!
23:47:05 <johnw> i'm not on HEAD, but glad to know it's coming
23:47:50 <haasn> johnw: doesn't work for polymorphic row types yet, though, and the API is clunky. Patches welcome!
23:48:47 <ReinH> (a.k.a. lambda dropping)
23:51:13 <johnw> yeah, I happen to be using a polymorphic row type :)
23:55:32 <edwardk> i can ship tables HEAD if you think it is stableish
23:55:54 <haasn> ‘stableish’ as in “crashes with nondescriptive pattern matching failures if you use it on a noncompatible type”
23:55:57 <joelteon> how do you note people
23:56:09 <haasn> There's a note in the haddock but that's it
23:56:12 <joelteon> @note
23:56:12 <lambdabot> Missing argument. Check @help vote for info.
23:56:12 <edwardk> oh it needs lns HEAD
23:56:16 <joelteon> @help note
23:56:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:56:20 <joelteon> @list
23:56:20 <lambdabot> What module?  Try @listmodules for some ideas.
23:56:29 <joelteon> time to /query
23:56:36 <haasn> edwardk: oh, yes, updated Each
