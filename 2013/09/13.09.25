00:00:18 <Taneb> I've got the code all written out using "times" but I don't like that name
00:02:07 <ill_logic> This tutorial http://en.wikibooks.org/wiki/Haskell/Monad_transformers makes it clear how to do an IO operation within a MaybeT. But what if I want to do a basic Maybe operation?
00:02:27 <Taneb> ill_logic, Nothing is mempty
00:02:30 <Taneb> *mzero
00:02:42 <ill_logic> so I need MonadPlus?
00:03:03 <arkeet> MaybeT is already a MonadPlus.
00:03:04 <Taneb> No
00:03:07 <Taneb> ^
00:03:23 <Taneb> shachaf, arkeet, what do you think of the name "pow" or "power"?
00:03:32 <arkeet> Taneb: I was going to suggest pow, but thought you might not like iut.
00:03:32 <ill_logic> Right but I need to use its MonadPlus capabilities to do something simple like do a maybe operation
00:03:59 <arkeet> ill_logic: what's a maybe operation?
00:04:05 <ill_logic> lookup
00:04:12 <arkeet> :t MaybeT
00:04:12 <lambdabot> Not in scope: data constructor `MaybeT'
00:04:22 <arkeet> MaybeT :: m (Maybe a) -> MaybeT m a
00:04:54 <arkeet> @let import Control.Monad.Trans.Maybe
00:04:55 <lambdabot>  Defined.
00:05:40 <Taneb> Would it be fair enough to define pow (Sum a) n = Sum (a * fromIntegral n)?
00:05:50 <arkeet> sure why not.
00:06:02 <ill_logic> I don't mind doing the studying to fully understand the implications of your response, but I want to make sure I'm heading down the right path.
00:06:04 * arkeet wonders why the Monoid class doesn't have such a thing.
00:06:36 <arkeet> ill_logic: if you have a thing that returns some Maybe type, you can use MaybeT to make it a MaybeT value.
00:06:42 <arkeet> possibly with return for the other monad.
00:06:44 <arkeet> :t MaybeT . return
00:06:45 <lambdabot> Monad m => Maybe a -> MaybeT m a
00:07:05 <ill_logic> oh right. of course.
00:07:26 <ill_logic> Wh did you bring up mzero then
00:07:41 <arkeet> mzero corresponds to Nothing.
00:07:45 <arkeet> (and return corresponds to Just.)
00:07:51 <arkeet> (it wasn't me who brought it up thought.)
00:07:56 <arkeet> though
00:07:56 <ill_logic> oh sorry
00:08:31 <ill_logic> I wonder why there isn't another variant of lift to make this more idiomatic.
00:10:33 <arkeet> well, there ought to be some hoistMaybe :: Maybe a -> MaybeT m a
00:21:01 <k0001> arkeet ill_logic: that one and other similar functions are in the errors package http://hackage.haskell.org/packages/archive/errors/1.4.2/doc/html/Control-Error-Util.html
00:21:17 <arkeet> that's good then
00:21:34 * hackagebot groups 0.4.0.0 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.4.0.0 (NathanVanDoorn)
00:24:28 <ill_logic> ok cool thanks
00:24:43 <ill_logic> I'm a bit surprised it's per-type.
00:25:39 <ill_logic> and not a general function
00:25:56 <arkeet> there could probably be some class for it.
01:50:22 <deathlessgod> \
01:51:48 <ksf> does anyone have information on the (apparently new in 7.7) error "Illegal Illegal instance declaration for ... Multiple uses of this instance may be inconsistent with the functional dependencies of the class."
01:54:00 <quicksilver> ksf: that seems fairly odd. Does it involve putting a type family into an instance of a class controlled by fundeps?
01:55:25 <ksf> no, but an gadt.
01:55:51 <ksf> only gadt syntax ,though, let me fiddle...
01:56:54 <ksf> ...no change.
01:58:05 <aloiscochard> guys, I have hard time seeing how RxJava/Net is actually a FRP framework?
01:58:17 <aloiscochard> I  thought FRP have a notion of value changing over time, but I can't see where this apply to those framework
01:58:29 <aloiscochard> on reactiveprogramming.org they say that "FRP should completely replace the observer pattern." but when I look into those Rx framework it look exactly like the observable pattern!
01:58:40 <quicksilver> ksf: some googling gives me https://github.com/ekmett/lens/issues/318 and http://neilmitchell.blogspot.co.uk/2013/02/shake-links.html I'm nt sure if they seem relevant
01:59:46 <ksf> quicksilver, http://lpaste.net/93373
02:00:33 <ksf> I'm trying to express "xs is ys replacing b with a at sy" in a single predicate.
02:00:49 <ksf> already did it with closed type families, but that's exploding the inferred types.
02:02:26 <quicksilver> ksf: I'm going to have to guess that GHC's fundeps checker can't cope with [*]
02:02:56 <quicksilver> ksf: I don't see how that error message can make sense with a single parametric instance.
02:05:27 <ksf> should I file a bug?
02:05:40 <ksf> or yell at someone in particular?
02:05:44 <quicksilver> I would file a bug
02:06:03 <quicksilver> yell, by all means
02:06:08 <quicksilver> btu I don't know who to :)
02:06:34 <Dakk> anyone=
02:06:38 <Dakk> IS there anyone out there?!
02:07:16 <ksf> \o/ I remembered my trac password
02:07:18 <Dakk> I'm getting an error i simply can't fix
02:07:22 <Dakk> I need help
02:07:30 <haasn> Dakk: there are 1132 people in this channel right now
02:07:41 <Dakk> haasn thx
02:07:44 <Dakk> http://pastebin.com/DBdB7WkE
02:07:46 <mauke> The paste DBdB7WkE has been copied to http://lpaste.net/93374
02:07:51 <Dakk> That code gives me parse error on |
02:07:56 <Dakk> but i don't see the problem with it.
02:10:53 <mjboa> Dakk: Aren't you missing a closing parenthesis on the second to last line?
02:10:57 <Dakk> Anyone? Parse error on | in http://pastebin.com/DBdB7WkE cannot find it :/
02:10:57 <mauke> The paste DBdB7WkE has been copied to http://lpaste.net/93374
02:11:35 <haasn> mjboa: good catch!
02:11:50 <haasn> This is what you get for nesting parentheses :)
02:12:07 <Dakk> mjboa That might've been it! I'm getting other errors now! I'll get back when it's solved! :) Thx alot
02:12:56 <mjboa> parse error on | has often nothing to do with the |, i've noticed :)
02:13:09 <chrisdone> parse errors generally in haskell are crappy
02:13:42 <chrisdone> "um, unexpected $random_symbol" "uhh, bad indentation?"
02:13:58 <chrisdone> i don't even read them
02:14:54 <mjboa> yep, first thing: check indentation
02:15:54 <Dakk> Now i'm getting another error :/
02:16:02 <chrisdone> (╯°□°）╯︵ ┻━┻
02:17:21 <Dakk> Theres something wrong on row 43 with "(rows sudoku) :/ The functions getting the wrong type but i aint seeing how it happends..
02:17:22 <Dakk> http://pastebin.com/kKjPQEga
02:17:24 <mauke> The paste kKjPQEga has been copied to http://lpaste.net/93375
02:18:46 <divyansr> solving sudoku\m/. Check this out https://github.com/rdivyanshu/Haskell/tree/master/Sudoku
02:19:03 <divyansr> comments and criticism are welcome :)
02:19:32 <ollepolle> Does anyone know of an established name for something like this? data WeirdList a b = Cons a (WeirdList a b) | Nil b
02:19:33 <bartavelle> Dakk, you can't use map on something that is not a [list]
02:19:54 <bartavelle> (well, prelude's map)
02:20:07 <ksf> Dakk, r isn't a Maybe, it's a [Maybe Int]
02:20:07 <danr> ollepolle: ([a],b)
02:20:13 <ksf> you've got two levels of lists there.
02:20:20 <Dakk> bartavelle what should i do instead to fix it?
02:20:28 <chrisdone> danr: nope
02:20:29 <bartavelle> (in printSudoku)
02:20:49 <bartavelle> extract the lists with pattern matching
02:20:52 <danr> chrisdone: well, almost :p
02:21:12 <bartavelle> printSudoku (Sudoku lists) = .... (map turnToSymbols lists)
02:21:17 <haasn> ollepolle: Free ((,) a) b
02:21:45 <chrisdone> danr: =)
02:22:31 <bartavelle> Dakk, it seems that turnToSymbols does this already, so printSudoku = putStrLn . turnToSymbols
02:22:35 <mjboa> Free! yes, so excited I recognized that :)
02:22:40 <ksf_> hmmm all the ghc devs are probably at ICFP, doing whatnot instead of dutifully checking the trac in 5 seconds intervals to give me feedback.
02:22:55 <chrisdone> ksf_: outrageous
02:23:16 <ollepolle> Thanks for the alternative definitions! What should I call it?
02:23:29 <haasn> FreeList? :)
02:24:55 <Dakk> bartavelle thanks for the help, it makes somewhat sense to me. BUt i'm still getting the same error :/ It looks like this now
02:24:55 <Dakk> http://pastebin.com/2b2HN24k
02:25:00 <mauke> The paste 2b2HN24k has been copied to http://lpaste.net/93376
02:25:36 <bartavelle> Dakk, translate has type [Maybe Int] -> String, but you feed it a [[Maybe Int]]
02:25:43 <mjboa> Dakk: in translate you're comparing r to Nothing, but r is itself a list
02:27:04 <ollepolle> haasn: Hmm, I was hoping for something more suggestive... I'll have to think about this
02:27:05 <donri> ollepolle: call it 1/(1-a)*b
02:27:39 <ReinH> divyansr: you might enjoy this http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
02:27:51 <Dakk> I've got an idea of what it's about now! Thanks! I'll try to solve it
02:29:59 <ollepolle> donri: ;)
02:30:02 <haasn> donri: you lost me at / :(
02:31:13 <donri> haasn: http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/
02:33:12 <mangaba_leitosa> donri: tables in TeX? :-)
02:33:34 <donri> mangaba_leitosa: ?
02:34:35 <mangaba_leitosa> donri: in the beginning of the URL you gave there is TeX code instead of the table
02:34:51 <donri> mangaba_leitosa: mathjax maybe?
02:35:00 <donri> yep
02:35:09 <mangaba_leitosa> ah :-)
02:35:19 <divyansr> ReinH : Thanks.
02:35:57 <mangaba_leitosa> donri: ah, you are right, I enabled it in NoScript and can see the table :-)
02:36:10 <donri> i was just about to say "don't use noscript, silly"
02:36:18 <mangaba_leitosa> :-)
02:37:14 * mangaba_leitosa didn't know about mathjax. only mathml
02:38:27 <chrisdone> moar liek mathjoke amirite
02:39:50 <haasn> donri: I still have no idea what a difference/quotient/square root of a type actually ‘is’ :(  all I see is playing around with algebraic rearrangements. I guess that's what you were doing?
02:40:03 <donri> yes
02:44:46 <haasn> The only thing I know relating to quotient is ordered pairs
02:45:04 <haasn> And uh.. I think I remember some other blog post that described how to derive something automatically, that related to quotient types
02:45:06 <haasn> or something
02:46:03 <quicksilver> a quotient type is where you get a 'smaller' type by considering some elements to be the same
02:57:05 * hackagebot classy-prelude 0.6.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.6.0 (MichaelSnoyman)
02:57:07 * hackagebot classy-prelude-conduit 0.6.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.6.0 (MichaelSnoyman)
02:57:09 * hackagebot classy-prelude-yesod 0.6.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.6.0 (MichaelSnoyman)
03:11:37 * chrisdone wonders if bronad culture will ever develop in the haskell community
03:18:37 <benj_> chrisdone, bro, do you even liftM?
03:20:14 * benj_ removes the bronomorphism restriction
03:20:40 <quicksilver> :)
03:20:54 <quicksilver> chrisdone: possibly not, but ban pun culture is here to stay.
03:22:28 <chrisdone> quicksilver: ban puns or bad puns? i love puns
03:23:06 <quicksilver> strange typo
03:23:10 <quicksilver> I did mean bad puns :)
03:25:21 <chrisdone> i've got a friend Paolo who loves puns so much that if we're ever hanging out and he's quiet, you know he's thinking of a pun about the conversation. i call him punlo =)
03:37:15 <haasn> > rot13 "badpuns"
03:37:16 <lambdabot>   Not in scope: `rot13'
03:37:38 <donri> @rot13 badpuns
03:37:38 <lambdabot> Unknown command, try @list
03:37:38 <haasn> preflex: rot13 badpuns
03:37:40 <preflex>  onqchaf
03:37:53 <haasn> preflex: rot13 banpuns
03:37:53 <preflex>  onachaf
03:37:55 <donri> preflex: rot13 shachaf
03:37:56 <preflex>  funpuns
03:37:59 <donri> haha
03:39:01 <Flonk> preflex: rot13 /cneg
03:39:02 <preflex>  /part
03:39:05 <Flonk> ._.
03:39:14 <haasn> (as if that would do anything)
03:46:53 <absence> what is positive and negative posision in type signature land? can i read about it somewhere?
03:47:14 <haasn> absence: something like ‘to the left of’ vs ‘to the right of’ a function arrow?
03:47:37 <haasn> eg. consider newtype Foo a = Foo (Int -> a) -- vs. newtype Bar a = Bar (a -> Int)
03:47:45 <haasn> one is a Functor, one is a Contravariant
03:48:50 <quicksilver> yes
03:48:59 <quicksilver> but you have to count the number of arrows that you are to the left of
03:49:07 <quicksilver> n -> n -> p
03:49:11 <quicksilver> (p -> n) -> p
03:49:18 <absence> haasn: so a is in negative or positive position in those two cases
03:49:33 <haasn> judging by what quicksilver just wrote, positive for Foo and negative for Bar :)
03:51:25 <absence> i see. thanks!
03:52:04 <quicksilver> the way to tell, although it's fiddly, is that if you have 'a' in a positive position then you can replace it with 'b' by applying an (a->b)
03:52:10 <quicksilver> like you can with plain 'a's.
03:52:18 <quicksilver> if it's in a negative position you will need a (b->a)
03:52:30 <quicksilver> which, is what haasn said about Functor and Contravariant.
03:55:49 <Flonk> > let meme = (\x -> let v = splitOn " " x in text $ "How do I " ++ head v ++ (if (last.head) v == 'e' then "d " else "ed ") ++ (intercalate " ".tail)v ++ "?") in meme "learn haskell"
03:55:52 <lambdabot>   How do I learned haskell?
03:59:57 <haasn> > "learn haskell" & iso words unwords._head ++~ "ed"
03:59:58 <lambdabot>   Not in scope: `++~'
03:59:59 <lambdabot>  Perhaps you meant one of these:
03:59:59 <lambdabot>    `++' (imported from...
04:00:03 <haasn> > "learn haskell" & iso words unwords._head <>~ "ed"
04:00:04 <lambdabot>   "learned haskell"
04:00:06 * haasn hides
04:00:22 <Flonk> :t (<>~)
04:00:23 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
04:00:36 <Flonk> :t iso
04:01:10 <t7> i need ghc holes before i can use lens
04:01:15 <haasn> Note: If you use ‘iso words unwords’, shachaf will cry
04:01:17 <t7> the types are crazy
04:01:18 <haasn> So don't do that :'(
04:01:32 <Flonk> haasn: whats iso anyway? lambdabot won't tell me
04:01:38 <haasn> :t Control.Lens.iso
04:01:39 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
04:01:51 <haasn> I.. uh.. iso :: (s -> a) -> (b -> t) -> Iso s t a b
04:02:01 <haasn> or more simply iso :: (a -> b) -> (b -> a) -> Iso' a b
04:02:23 <haasn> In other words, it builds an Iso(morphism) from two inverse functions
04:02:41 <Flonk> haasn: okay, I see
04:02:58 <quicksilver> t7: GHC holes will just let you see crazy types in more places.
04:03:08 <quicksilver> t7: it's not clear if that is better for your particular use case :)
04:03:10 <seanparsons> I'm trying to use hspec with quickcheck to write a property where the thing I'm testing would be operating in the IO context.
04:03:17 <haasn> the types aren't so crazy once you wrap your head around them, either way
04:03:25 <haasn> Just gotta keep track of what Overloaded etc. are
04:03:29 <t7> quicksilver: wont there be an automated solver? :3
04:03:38 <seanparsons> Has anyone tried something like this? It looks like the types are fighting me somewhat.
04:06:06 <donri> @hackage quickcheck-io
04:06:06 <lambdabot> http://hackage.haskell.org/package/quickcheck-io
04:06:19 <quicksilver> haasn: if you think the types are no longer crazy, it may be that your brain has already exploded.
04:06:41 <seanparsons> donri: Hmmm.
04:06:57 <haasn> quicksilver: most of the craziness is just overloading due to indexing, which is where all the profunctor nonsense comes from
04:07:35 <haasn> If you can learn to ‘read past’ that it gets a lot simpler
04:11:58 <mcstar> geekosaur: thx for the awk answer from SO
04:16:39 <merijn> edwardk: I remember a post by you explaining how the Store comonad could be used to represent operations on images (like convolutions) by extending operations on individual pixels, but I can't seem to find it again. Am I hallucinating it's existence?
04:17:31 <donri> merijn: did you look here https://www.fpcomplete.com/user/edwardk
04:17:44 <frihd_> hi, is there a "best solution" when defining types that are heavily nested (e.g., appartement > building > block > district > city > country ..) ?
04:17:58 <haasn> “site:comonad.com comonad” doesn't exactly help a lot ¬_¬
04:18:20 <donri> frihd_: what's the problem
04:18:35 <haasn> frihd_: classy lenses?
04:18:44 <merijn> donri: I mostly found the cellular automaton one there, but that's not the one I was thinking off
04:19:03 <frihd_> it's just a design question I had before writing some code, no problem _yet_
04:19:28 <seanparsons> donri: I _think_ the hilariously named morallyDubiousIOProperty from Quickcheck will sort me, but cheers.
04:20:24 <frihd_> i'll probably write "bottom up", but I could see why someone would prefer to define Country = .. cities :: [City] .. ; I was just curious and I won't be able to sleep if I don't get the question out of my mind ^^
04:21:07 <haasn> frihd_: well with classy lenses you get classes for all of your various fields, and then instances for all of your nested data types so don't have to un-nest them manually
04:21:09 <haasn> if that makes sense
04:21:19 <frihd_> yes haasn, thanks
04:21:35 <frihd_> i know about lenses, will check out classy lenses
04:22:23 <haasn> Hmm.. are lens' Has* classes parametrized over the choice of functor?
04:22:34 <haasn> I could see restricting it to an Applicative for some instances being useful!
04:53:11 <bartavelle> is there some fundamental difference between scala traits and haskell typeclasses that I missed ?
04:54:02 <bartavelle> (just watched http://www.infoq.com/presentations/post-functional-scala-clojure-haskell and couldn't understand what is meant my modules)
04:54:07 <bartavelle> s/my/by/
04:55:17 <SaBer_> bartavelle: I also listened to that while working, and I missed the point about what's wrong with haskell modules also... Should probably watch it again and listen more carefully.
04:55:58 <bartavelle> I know people are often complaining about haskell module system here, but I do not understand what the alternatives are
04:57:11 <chrisdone> haskell's module system is barely more than a namespace
04:57:22 <bartavelle> I agree with that
04:57:24 <chrisdone> some module systems would allow you to parametrize things about your module in the module's header
04:58:03 <bartavelle> like "include SomeDatabaseIndependantLibrary(mysql)" ?
04:58:46 <chrisdone> e.g. like module Textish parametrizing (pack,append) where doubleText x = pack "Doubled!" `append` x `append` x
04:58:53 <chrisdone> and then you might do
04:59:08 <chrisdone> import Textish with (Data.Text.pack,Data.Text.append)
04:59:16 <chrisdone> and you would have the Textish module compiled with those definitions
04:59:25 <bartavelle> ah !
04:59:37 <chrisdone> it's similar to type-classes, but modules can be fully resolved at compile time, rather than passing around a dictionary. the types can all be concrete
04:59:55 <chrisdone> that's a rather limited way of describing it, there's a lot more sophistication to it than i'm aware
05:00:12 <bartavelle> I can see how that would be helpful
05:01:11 <bartavelle> thanks
05:01:20 <chrisdone> sure =)
05:01:56 <Guest48471> Someone knows why: printLine [a]  = map (replicate a '-') b isn't working, it says b is out of scope
05:02:25 <chrisdone> Guest48471: where is `b' *in* scope?
05:02:27 <bartavelle> Guest48471, I would say that's because b is out of scope
05:02:55 <CaptainK> you can buy scopes at ##astroonomy
05:03:34 <Guest48471> I need a function to change a list of ints to a string, for instance [5,6,6,6] has to compute to "+-----+------+------+------+"
05:04:16 <bartavelle> what do you thin " printLine [a]  = map (replicate a '-') b" mean ?
05:04:19 <bartavelle> think
05:04:41 <Guest48471> Use the replicate function on all elements in the list
05:05:08 <Guest48471> And use that number as a parameter for replicate so it makes for instance 5x '-'
05:05:14 <int-e> Guest48471: what is the 'b' at the end supposed mean? that's what it is complaining about.
05:05:17 <Apsod> what is a, and what is b, in the function? and what is [a]?
05:05:40 <bartavelle> [a] is pattern matching for a single element list (like [5]), not the whole list
05:06:03 <Guest48471> So it just should be a then
05:06:16 <Guest48471> So it can take a whole list
05:06:34 <bartavelle> that would be probably more what you are looking for, but you must ask yourself what that 'b' was supposed to be/do in the first place
05:07:17 <Guest48471> It has to be a string
05:07:20 <int-e> Guest48471: there is also a mix of concepts there; [a] is matching a singleton list, but then you use map ... on ... something that probably is not a list.
05:07:56 <Guest48471> Because the type declaration of the function is [Int] --> String
05:08:22 <bartavelle> well, what's on the right side of "printLine xxx =" has to be a string
05:09:08 <Guest48471> True
05:09:51 <Guest48471> So know I have it like this printLine a = map (replicate b '-') a
05:10:10 <Guest48471> But b has to be something else, an element of the list
05:10:11 <bartavelle> ok you got the syntax wrong, but that's closer to the point
05:10:18 <bartavelle> map (\b -> replicate b '-') a
05:10:40 <bartavelle> what would be the type of this ?
05:10:40 <Guest48471> So a is [int] and that b must be an int then actually
05:10:51 <bartavelle> yup
05:13:12 <haasn> http://lpaste.net/93377 surely there's a better way to do this with pipes?
05:13:24 <haasn> the foldr is ugly :(
05:13:37 <haasn> isn't there some helper for “foldr (>->) cat” or so forth
05:14:50 <haasn> (and why doesn't pipes-safe have appendFile?)
05:17:57 <Guest48471> Couldn't match expected type 'Char' with actual type '[Char] ' it says when using printLine a = map (\b -> replicate b '-') a
05:19:06 <bartavelle> well, what's the type of \b -> replicate b '-' ?
05:19:56 <Guest48471> It has an int and b as parameter and returns [b]
05:20:13 <bartavelle> erm, it has a single parameter
05:20:24 <bartavelle> so its type is Int -> String
05:20:30 <Guest48471> Or well b is the int in this case I mean
05:20:43 <bartavelle> no what's the type of \a -> map (\b -> replicate b '-') a
05:20:44 <Guest48471> Yes
05:22:51 <bartavelle> s/no/now/
05:23:06 <anakreon> Hello. I want to declare a data type that contains a graph from fgl. This declaration data (DynGraph gr) => A = A (gr Int Int) doesn't typecheck
05:23:44 <Guest48471> [int] --> [string] ?
05:23:59 <bartavelle> yes !
05:24:07 <bartavelle> but you wanted [Int] -> String
05:24:20 <bartavelle> so you still need to find something that does [String] -> String
05:24:27 <Guest48471> Char instead of [string]
05:24:41 <Guest48471> Hmm
05:24:52 <bartavelle> hint: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/base/Data-List.html#v:intercalate
05:25:55 <akegalj> how to convert from Text to Int ?
05:25:55 <Guest48471> I was thinking about unwords
05:26:13 <Guest48471> But that's probably not right here
05:26:16 <Guest48471> Has the good type though
05:26:19 <bartavelle> akegalj, http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text-Lazy-Read.html
05:26:30 <bartavelle> Guest48471, try it
05:26:34 <int-e> anakreon: How about  (GADT syntax) data A where A :: DynGraph gr => gr Int Int -> A   or  (existential datatype syntax) data A = forall gr. DynGraph gr => A (gr Int Int)   or the plain  data A gr = A (gr Int Int)
05:26:34 <akegalj> bartavelle: thnx :)
05:27:20 * hackagebot monoid-extras 0.3.2.1 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.2.1 (BrentYorgey)
05:28:06 <anakreon> int-e: The third suggestion does not work. I'll try the other suggestions
05:34:32 <Guest48471> According to some examples intercalate should idd do the trick, just trying to find out where to place it now, so give me a moment
05:37:52 <Guest48471> Got it :D
05:41:27 <kosc> Why it doesn't works? [x**2 | x <- [1..100], x `mod` 2 == 0]
05:41:30 <Guest48471> bartavalle, [5; 6; 6; 6] gives me -----+------+------+------ now, how can I add a + at the beginning and the end of it now
05:41:43 <quicksilver> :t (***)
05:41:44 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:41:46 <quicksilver> :t (**)
05:41:47 <lambdabot> Floating a => a -> a -> a
05:42:01 <quicksilver> kosc: because ** works on floating numbers while mod works on integers
05:42:12 <quicksilver> > [x^2 | x <- [1..100], x `mod` 2 == 0]
05:42:14 <lambdabot>   [4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,1444...
05:42:15 <kosc> quicksilver: Thank you.
05:42:18 <bartavelle> Guest48471: you can now just use cons and snoc
05:42:35 <bartavelle> or reorganize your function a bit
05:42:37 <bartavelle> like
05:44:51 <bartavelle> http://lpaste.net/93378
05:45:20 <bartavelle> not sure this is really more readable ...
05:47:00 <Guest48471> Hmm
05:47:09 <Guest48471> Yeah it's pretty understandable I think
05:47:17 <Guest48471> Should add some where's to my too, reads better
05:47:22 <Guest48471> Thanks a lot
05:47:36 <bartavelle> np
05:47:41 <zeroXten> is there particular reason why Data.List (sort) isn't in a core function?
05:49:28 <merijn> zeroXten: What do you mean by core function? Prelude exports sort...
05:49:41 <int-e> merijn: doesn't.
05:49:50 <merijn> It doesn't?
05:50:04 <merijn> heh
05:50:07 <bartavelle> Data.List
05:50:08 <merijn> That is weird
05:50:18 <bartavelle> same question for sortWith really
05:50:34 <int-e> zeroXten: I don't think there's any particular reason. However the general reason nowadays seems to be that the prelude exports too much, not too little.
05:50:50 <zeroXten> why too much?
05:51:53 <bartavelle> many function could be more generic
05:51:57 <bartavelle> functions
05:52:28 <merijn> bartavelle: There is a proposal under investigation to move Data.Foldable/Data.Traversable to Prelude and generalise the Prelude versions
05:52:43 <merijn> Although it may have stalled and require some new prodding
05:52:58 <zeroXten> ah ok
05:53:37 <applicat1ve> that still wont put sort on the Prelude
05:55:02 <merijn> applicat1ve: So? That remark was orthogonal to the question about sort
05:55:26 <merijn> applicat1ve: bartavelle was saying many things could be more generic, I just pointed out there is some movement in that direction
05:55:35 <applicat1ve> merijn: yes, i was just noticing it; not making an objection or something
05:56:24 <applicat1ve> zeroXten: I don't know if Data.List.sort is widely praised; there are a lot of other sorts around, of course
05:56:43 <zeroXten> right ok
05:57:02 <merijn> zeroXten: Basically, to get back to your question: mostly historical reasons and no one thought it was a big enough problem to change
05:57:20 <int-e> Ultimately I think the reason is that you have to stop adding stuff to the Prelude *somewhere* and a function being generally useful or not is not a good enough criterion to define the line.
05:57:39 <merijn> applicat1ve: It's a pretty straightforward merge sort that preserves sorted sequences, I believe
05:57:41 <zeroXten> that makes sense
05:57:54 <int-e> We can have a long and fruitless debate about sort, but I find it easier to just import Data.List :)
05:58:03 <zeroXten> int-e: :)
05:58:24 <merijn> zeroXten: There's more stuff that maybe should or shouldn't be in Prelude, but in the end it results in less bikeshedding to just import the module it's originally defined in :)
05:58:25 <applicat1ve> yes, merijn it is suitable for a range of cases, and is a list sort
05:59:53 <exicer> So I think I am starting to understand monad transformers
06:00:17 <exicer> I think I am just too inexperienced to use haskell though
06:00:17 <merijn> exicer: \o/
06:00:21 <exicer> you have too many options
06:00:27 <exicer> how am I supposed to know what is the correct way!
06:00:35 <exicer> e.g. with errors
06:00:56 <merijn> exicer: The answer is, it depends.
06:01:01 <exicer> :p
06:01:01 <applicat1ve> what monad transformer are you using?
06:01:03 <exicer> exactly!
06:01:16 <merijn> exicer: One way is to describe what you want/need and then people here can help you suggest what the right approach is
06:01:27 <exicer> applicat1ve: Thus far, I am not properly using them. Well, I use runResourceT in http-conduit
06:01:37 <exicer> but until now I was just using it, and I didn't really know how it worked
06:01:50 <exicer> so I can see its kind of, wrapping up the errors that can occur
06:02:10 <exicer> It feels like I am quite far from being able to decide when I should use such a thing in my own code though
06:04:14 <applicat1ve> hm, i'm trying to see if ResourceT does anything particular with errors though
06:04:36 <exicer> I assumed it had to, given that it was dealing with IO ?
06:04:56 <exicer> errors was just a general example though, like using maybeT with io
06:05:04 <applicat1ve> newtype ResourceT m a = ResourceT { unResourceT :: I.IORef ReleaseMap -> m a }
06:06:18 <applicat1ve> runResourceT basically supplies the do block with an initial IORef to the (at first empty) collection of 'resources'
06:07:05 <exicer> I don't really know what an IORef is  :/
06:07:13 <exicer> I can guess, but it is just a guess
06:07:43 <zeroXten> woohoo, my first attempt at haskell that hasn't completely failed \o/
06:08:27 <applicat1ve> its just a mutable reference of some sort, to a list of e.g. files you opened and what to do with them etc.
06:08:38 <exicer> applicat1ve: Ah okay..
06:08:59 <exicer> I think I probably just need to keep banging away at things
06:09:35 <zeroXten> prime_filter (x:xs)  = x : [ y | y <- prime_filter xs, y `mod` x /= 0 ]
06:10:14 <applicat1ve> exciser import Data.IORef then do ref <- newIORef 13; writeIORef ref 25; x <- readIORef ref ; print x} prints 25
06:11:41 <exicer> applicat1ve: Oh, that is very understandable
06:11:57 <applicat1ve> a little too understandable maybe ;)
06:12:29 <exicer> I suspect it is actually some monstrosity that I don't at all want to look at :P
06:13:06 <applicat1ve> so with ResourceT the idea is your whole program is wrapped with a quasi-global variable tracking resource use
06:13:24 <acomar> zeroXten: can you make it more efficient now?
06:13:24 <exicer> Stuff like open connections ?
06:13:43 <applicat1ve> exicer: yes
06:14:12 <applicat1ve> exicer: i'm not an adept, but notice how the conduit stuff is forever having you define opening and closing operations
06:15:06 <exicer> I would guess I know less than you about it, and in my flailing I hadn't noticed :s
06:15:26 <exicer> Or perhaps I don't know what you mean by opening and closing operations
06:16:11 <applicat1ve> hm, maybe with http-conduit its not so obvious
06:17:25 <exicer> I think the idea (at least as I understand it) of conduits is pretty cool
06:17:27 <bartavelle> I believe it is mostly hidden in the "sinks" and "sources"
06:17:37 <exicer> but the operators that are used are kinda horrible
06:20:09 <applicat1ve> bartavelle: yes, on reflection, the user doesn't see it, I was remembering the definition of things like 'sinkFile' 'sourceFile' etc
06:20:38 <bartavelle> yeah, as a user you are saved from such details, unless you write your own sinks/sources
06:25:09 <mdmkolbe> I have a GUI definition file that I'm reading in from TH.  How do I get cabel (GHC?) know that I need to rebuild the Haskell file containing the TH when the data file changes?
06:25:27 <int-e> @type (>>=('+':).(`replicate`'-')).(++[0])
06:25:29 <lambdabot> [Int] -> [Char]
06:28:28 <bartavelle> :)
06:28:29 <phaer> I get "GHCi runtime linker: fatal error: I found a duplicate definition for symbol
06:28:29 <phaer>    my_inet_ntoa" as an error. but according to locate, network-2.4.1.2 is installed only once (in .cabal/...) and ghc-pkg check does not print any errors. Any tipps how to solve that?
06:29:26 <supki> phaer: ghc-pkg list network
06:29:47 <monoidal> mdmkolbe: check addDependentFile
06:30:14 <applicat1ve> oh how do you do that monoidal
06:31:16 <mdmkolbe> monoidal: cool, that looks like exactly what I need
06:31:22 <phaer> supki: Gives me one entry for network-2.4.1.2 and one for network-2.3.0.13, that should be no problem, right?
06:31:24 <applicat1ve> oh yeah
06:32:29 <applicat1ve> phaer: what does it tell you will break if you do 'ghc-pkg unregister network-2.4.1.2"
06:33:19 <supki> phaer: if both are loaded and both have that symbol then there is a problem
06:33:23 <phaer> applicat1ve: A lot: hakyll-4.3.3.0 http-conduit-1.9.5.1 pandoc-1.11.1 tls-extra-0.6.5 citeproc-hs-0.3.8 tls-1.1.5 socks-0.5.1 snap-server-0.9.3.4 HTTP-4000.2.8 tls-extra-0.6.1 snap-server-0.9.3.3 tls-1.1.2
06:34:06 <monoidal> mdmkolbe: for more, http://ghc.haskell.org/trac/ghc/ticket/4900
06:34:13 <applicat1ve> is this the current haskell platform -- that you have the older network from?
06:34:20 <applicat1ve> phaer ^^^
06:34:42 <saml> do you like mind bending stuff?
06:35:12 <Taneb> ...this is the fun bit...
06:35:21 <Taneb> install a whole bunch of libraries on my RPi
06:35:53 <Taneb> Right now it's building System.Random
06:36:28 <applicat1ve> phaer: oh wait, it does seem like you have a previous haskell platform?
06:37:01 <ksf> quicksilver, they're adding a (relaxed) coverage condition in with 7.7 even if UndecidableInstances is enabled, to fix http://ghc.haskell.org/trac/ghc/ticket/1241
06:37:04 <applicat1ve> phaer: the more recent one uses network-2.4.1.2
06:37:09 <phaer> applicat1ve: i have 2012.2.0.0, which is in debian testing
06:37:18 <phaer> oh, wait
06:37:34 <ksf> they're probably thrilled that a bug fix yields another bug report because now evil type-level hacking is broken.
06:38:23 <applicat1ve> don't tell me people have been abusing UndecidableInstances
06:38:26 <applicat1ve> !
06:38:43 <ksf> well, there's no StructurallyDecreasingInstances
06:38:56 <phaer> applicat1ve: That seems to be the problem, yes :(
06:39:20 <applicat1ve> phaer: if you do ghc-pkg list bytestring does it list two bytestrings?
06:39:32 <applicat1ve> phaer: that's when you really know it's time to change ;)
06:42:45 <Taneb> ...just run "cabal install diagrams" on my RPi. And now we wait
06:42:53 <applicat1ve> I think that bug should be left in, ksf, he deserved it.
06:43:24 * ksf thinks so, too, because the fix breaks his code.
06:45:50 * phaer starts a ghc & haskell platform upgrade party on a 2mbit connection...
06:46:10 <zomg> See you next week
06:47:23 <haasn> 2mbit is a lot
06:47:29 <haasn> shouldn't take very long
06:48:02 <phaer> haasn: Its not as bad as it could be :)
06:48:06 <merijn> platform and ghc aren't very big...
06:49:09 <argiopeweb> merijn: Till you're on a limited satellite connection. I have 10mbit/s down and 10GB/month to play with.
06:49:32 <argiopeweb> (well, 20GB if you count 2AM to 6AM's bonus time)
06:50:43 <zomg> Are you in australia or something?
06:51:00 <applicat1ve> will the debian haskell platform include pre-build versions of the libraries, or build them from source
06:51:04 <phaer> argiopeweb: Just use a cron job to download big stuff during this time...
06:51:43 <argiopeweb> zomg: Continental US. I'm literally in site of DSL, but the phone company won't run it down my road because it isn't cost effective. No cable option either.
06:52:01 <phaer> haasn: The problem is, as always, it's "up to 2mbit". Currently downloading at 9kb/s,
06:52:21 <argiopeweb> phaer: That's what I do. Starbucks also gets a good bit of my business.
06:52:33 <zomg> argiopeweb: wow, lucky :P tbh if I was in that situation, I'd move :D
06:52:41 <haasn> phaer: okay, that's a lot less :)
06:53:00 <merijn> argiopeweb: Ah, yeah, that's what happens if you live in an internet 3rd world country :p
06:53:19 <phaer> haasn: You people just have to entertain me for the next 1,5h ;)
06:53:23 <argiopeweb> zomg: Well, it makes youtube time-wasting a non-issue, but I'm with you.
06:53:42 <int-e> argiopeweb: you can still spend time on IRC
06:53:47 <argiopeweb> merijn: It wouldn't be as bad if I hadn't just moved from 300mb/s with unlimited bandwidth.
06:53:59 <zomg> you could probably get LTE for your phone
06:54:04 <zomg> and get better rates
06:54:05 <zomg> :P
06:54:05 <argiopeweb> int-e: True that, with the ~1s ping caveat.
06:54:34 <phaer> argiopeweb: I feel your pain. I had had 16mbit down at my old flat but since i have moved to the sea i need to get to a cafe to download podcasts and videos :/
06:54:42 <argiopeweb> zomg: Nope, too far out in the country for that. Great 4g connection in town (20 minutes away), barely anything out here.
06:55:01 <eevar> does it make sense that 'void someIoAction' takes a lot more time than '_ <- someIoAction' ?
06:55:36 <argiopeweb> phaer: Ouch. At least you have the sea though, eh?
06:55:50 <eevar> that little change seems to add aboutt 30% runtime to a benchmark
06:56:37 <phaer> argiopeweb: And the locale climate is far better. All things considered its still a win :)
06:56:39 <merijn> eevar: Is it an IO action or is it in some transformer stack?
06:56:54 <eevar> just a plain io action
06:57:14 <argiopeweb> phaer: Yeah, I'm also much nearer family, so still a win here as well.
06:57:16 <eevar> runs (at most) 10 000k times in 30 sec
06:57:25 <mwu> Hi! I'm trying to update cabal to version 1.18 on Windows 8. I have installed Haskell Platform 2013.2.0.0. After running "cabal install cabal" I'm getting following error: http://lpaste.net/93380
06:57:53 <eevar> s/plain io action/ffi call
06:58:07 <argiopeweb> eevar: I assume you're compiling with optimization. void is defined as `fmap const ()`, so is it possible there's some weird thunking going on?
06:58:17 <argiopeweb> thunk buildup, even. Hit enter intead of delete. :\
06:58:55 <applicat1ve> mwu: hm, the command you probably wanted was 'cabal install cabal-install' but i don't know if that would affect this error
06:59:10 <dcoutts_> mwu: hmm, odd, looks like the Setup.exe failed to link for some reason
07:00:17 <mwu> applicat1ve: running 'cabal install cabal-install' gives me the same error.
07:00:19 <eevar> argiopeweb: no idea what is going on. it's line 319 in this file: https://github.com/ivarnymoen/nanomsg-haskell/blob/master/src/Nanomsg.hsc
07:00:55 <applicat1ve> mwu: yes it seemed likely; dcoutts_ seems to have an idea
07:02:14 <eevar> all I know is that the benchmark runs 30% slower after the final commit
07:02:18 <argiopeweb> eevar: Yeah, that's probably it.
07:02:22 <dcoutts_> applicat1ve: no idea I'm afraid
07:02:28 <applicat1ve> mwu: maybe if you asked for increased 'verbosity' the moment of death would be slightly more illuminating. ;) cabal install cabal-install --verbose=3
07:02:58 <dcoutts_> mwu: but you can try cabal unpack Cabal; cd Cabal; cabal configure -v3
07:03:10 <argiopeweb> eevar: With void it compiles to `fmap const () onBlock >>= \x -> throwIfRetryMayBlock p loc f on_block`, while without it compiles to `fmap const () onBlock >> \x -> throwIfRetryMayBlock p loc f on_block`
07:03:18 <dcoutts_> mwu: and see what is going on with the Setup.exe it's building
07:03:33 <argiopeweb> Though I'm not sure why that's not getting optimized, since x is unused.
07:04:46 <argiopeweb> eevar: What is the b in on_block :: IO b?
07:04:49 <donri> at what point is a type "dependent"? are gadts dependently typed because the type depends on the value constructor?
07:06:08 <Taneb> donri, I think it's when you use values as types
07:06:14 <argiopeweb> eevar: Incidentally, this may be a point where you want to compare Core, if you really really care why void is a performance issue.
07:06:23 <eevar> argiopeweb: an ffi call that fetchas an Fd, I think
07:07:17 <donri> Taneb: but haskell doesn't allow that at all, even promotion is just raising things one level, still people talk about dependent types in haskell...
07:07:26 <absence> what options do i have to give ghc to compile inside a cabal sandbox?
07:07:36 <mwu> dcoutts_: You were right, it is indeed a linking issue. I ran 'cabal install cabal-install --verbose=3' and got the following error: http://lpaste.net/93381
07:07:41 <Taneb> donri, Oh, I don't know then
07:08:29 <dcoutts_> mwu: ohh, odd. Cabal/ghc really should not be picking up a different gcc
07:08:37 <argiopeweb> eevar: Without looking at the Core, I'm not sure what's going on here. The only other alternative I can offer is throw strictness modifiers around haphazard (void $! on_block), but that's not good practice and not even likely to work, IMHO.
07:08:50 <dcoutts_> mwu: since it has its own bundled mingw (32bit obviously)
07:09:39 <eevar> argiopeweb: I'll just go back to '_ <- do_stuff'. thanks for looking into it, though
07:09:51 <mwu> dcoutts_: should I try removing my MinGW from the PATH?
07:09:52 <argiopeweb> eevar: Pleasure. Sorry I couldn't be more help.
07:10:49 <dcoutts_> mwu: that'd be a good workaround
07:11:04 <dcoutts_> mwu: but file a ticket for cabal and/or ghc, since this should not happen
07:11:23 <dcoutts_> mwu: ah, Cabal issue
07:11:25 <dcoutts_> Found ld at C:\MinGW64\bin\ld.exe
07:12:55 <dcoutts_> mwu: check that your ghc does have its mingw installation there, from the Cabal code it does look like it looks for ld first with ghc's bundled mingw
07:15:26 <mwu> dcoutts_: I have added "C:\Program Files (x86)\Haskell Platform\2013.2.0.0\mingw\bin" at the beginning of my PATH and this apparently did help. (still waiting for the compilation result but it got past the error)
07:17:45 <mwu> dcoutts_: It compiled fine, thank you for your help! :)
07:19:26 <mavado> Hmm what is a good way to add some whitespace to a string either left-alligned or right
07:20:05 <Rarrikins> take n . (++ (repeat ' '))
07:20:53 * applicat1ve doesn't recommend this for right alignment
07:21:09 <Rarrikins> :)
07:21:12 <bartavelle> http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text.html#g:9
07:21:19 <bartavelle> (for mavado)
07:21:40 <phaer> Just one hour later my ghc works again :)
07:24:38 <jaya_> haskell is lot of times better then other language;
07:24:51 <magneticduck> .... I have a super weird bug with a very small library I've been working on, I wonder if anybody can help me a bit trying to figure it out
07:24:53 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/tree/master/src/SoundsOfDuck
07:25:16 <magneticduck> it's a very small library, the only file you really need to look at is "Sound.hs"
07:25:33 <magneticduck> I could explain the library, but it shouldn't be too hard to figure out hopefully
07:26:04 <merijn> magneticduck: You seem to have accidentally committed your .swp files :)
07:26:09 <magneticduck> my bug is that when I try to render a waveform (in this case sine) with OscillateSound sinusPhase (const (freqFromString "c4")) 0 5
07:26:14 <magneticduck> it only renders the first phase!
07:26:26 <shergill> what is spine strictness in the context of data types?
07:26:29 <magneticduck> lols, I've been working on it for a bit
07:26:35 <magneticduck> merijn: hehe I have to change that
07:26:42 <shergill> or rather what is a 'spine'?
07:27:03 <magneticduck> I try not to post little problems like this to #haskell too much
07:27:03 <merijn> shergill: Let's take lists as the simplest example
07:27:11 <magneticduck> but I can't get my head around this
07:27:14 <shergill> merijn: sure
07:27:40 <merijn> shergill: Let's say I write "1 : []" then I have a thunk that conses (a thunk producing) 1 to (a thunk producing) [], yes?
07:28:32 <merijn> shergill: i.e. forcing the "1 : []" thunk, doesn't force the thunk for 1
07:28:39 <Rarrikins> > let drop' _ [] = []; drop' [] ys = ys; drop' (_:xs) (_:ys) = drop' xs ys; rJust n xs = drop' xs (replicate n ' ') ++ xs in rJust 8 "Hello"
07:28:40 <magneticduck> omg I figured it out lol
07:28:40 <lambdabot>   "   Hello"
07:28:41 <bennofs> Is there a class for things that are a Group, where a <> b > a iff b > mempty and a <> b < a iff b < mempty?
07:28:54 <magneticduck> sorry about that x|
07:28:58 <DMcGill> using :sprint in GHCi helps with this
07:28:58 <merijn> shergill: Now let's look at "length", clearly length needs to force the entire length of the list, right?
07:29:44 <shergill> merijn: ok so the 'spine' for lists are the series of Conses?
07:29:55 <merijn> shergill: At the same time, since you can write length like "length [] = 0; length (_:xs) = 1 + length xs" it should be clear that length doesn't need to force any of the thunks of things in the list
07:30:01 <merijn> shergill: Yes
07:30:32 <shergill> cool. what about a general data type? how would they be defined? the constructors?
07:30:36 <merijn> shergill: And in general, the spine of a data structure (set, map, etc.) is the "cons" like cells, i.e. the "not data contents" cells
07:30:41 <magneticduck> wait actually I didn't
07:30:51 <DMcGill> bennofs: what do you mean by "<" and ">"? An ordering? Monoids have x <> mempty = mempty <> x = x
07:31:16 <bennofs> DMcGill: Ah right, I meant things that are an instance of Ord and Group
07:31:17 <DMcGill> Monoids being Groups without an inverse for each element
07:31:27 <merijn> shergill: Suppose I have "data Tree a = Leaf a | Branch (Tree a) (Tree a)", being spine strict means that all the branches/leaves are handled strictly, but the a's *inside* are not strict
07:31:50 <merijn> shergill: i.e. "insert tree expensiveComputation" forces the tree insert, but *not* expensiveComputation
07:32:04 <shergill> merijn: right ok that makes sense. thanks
07:33:19 <merijn> shergill: The spine is thus those bits that gives the shape/structure of a datatype, rather than all its contents
07:34:48 <DMcGill> bennofs: the only thing even close to what you're asking for is the data-fin package but I suspect you're going to have to do things yourself - remember that in Haskell you don't have to prove such laws on your types
07:35:53 <DMcGill> typeclasses that don't give any additional operations and just promise to satisfy some more laws aren't usually done in Haskell
07:36:23 <DMcGill> if you really want such a thing then it sounds like Agda or Coq would be a better fit
07:36:44 <mavado> bartavelle is it also possible without Data.Text? That I give the function 2 parameters, an int and a string, and the int should be the 'width' of the whitespace and it returns a string with that whitespace included
07:36:51 <ksf> DMcGill, that's practically all I'm doing right now... in Haskell.
07:37:06 <absence> is anyone using sublimehaskell? can i enable a verbose mode or something that tells me what it's trying to do at all times? right now when i save a file, the console says "not building because it's already being built" which is bogus because there are no cabal or ghc processes running
07:37:16 <DMcGill> ksf: interesting, what are you working on?
07:37:32 <ksf> extensible product and sum types.
07:38:07 <ksf> I *could* just use Data.Trie with Dynamic, but with a couple of constraints I can use unsafeCoerce :)
07:38:44 <ksf> http://lpaste.net/93383  current state
07:40:17 <lpsmith> Hmm,  if I have a template haskell macro that returns a PatQ,  I can't seem to be able to write case blah of { $(macro foo) -> bar }
07:40:43 <lpsmith> any ideas about what I'm doing wrong?
07:41:25 <lpsmith> Instead, I'm getting "Parse error in pattern: $(inlineTypoidP PG.text)"
07:41:45 <mavado> bartavelle because if I try that justifyLeft in ghci it complains about 'Text' doesn't match with [Char]
07:43:29 <eevar> argiopeweb: meh. my benchmarks are just completely non-deterministic. reverting the "bad" commit just added more time, and then applying it again made everything run normally.. -- so nothing wroing with "void" after all
07:44:14 <rck> trying to understand the idomatic way to handle state: assume I have a list of Person where Person = { name :: String, hat :: Hat }, and I have a list of [Hat] that I want to assign based on some criteria to each person in the list. How do I keep track of this assignment? (seems like recreating the person list with a new person that has the correct hat is a ton of work and will be inefficient?)
07:46:58 <haasn> The composition of a fold and an unfold is a ‘hylomorphism’. What's the composition of an unfold and a fold, ie. in the opposite order?
07:47:05 <DMcGill> rck: remember that in immutable languages lots of the old structure can be shared. Going down the list and one at a time changing the hat for each person is pretty idiomatic. Having said that, don't go over the list multiple times with (!!) or anything
07:47:39 <DMcGill> if you're going to remove a randomly accessed hat from the list of hats when you assign it, consider using Data.Set rather than list
07:47:50 <argiopeweb> eevar: That makes more sense. If the optimizer weren't catching that it would be a pretty obvious bug.
07:48:25 <`^_^v> haasn, a lohymorphism
07:49:35 <schell> has anyone else with Xcode 5 and the brew tap ghc had problems linking semigroups 0.11?
07:50:01 <Yaniel> is xcode5 still in beta?
07:50:02 <DMcGill> rck: mapAccumL is a function which you want - map over the list of people while storing the state of the Set of hats
07:50:05 <mavado> bartavelle I got it :D
07:50:22 <schell> Yaniel: no, it's available in the app store
07:50:33 <DMcGill> and then a little further down that rabbit hole is the State monad and mapM.
07:50:37 <lpsmith> schell,  there are some incompatibilities between current versions of GHC and XCode
07:50:44 <lpsmith> err, XCode 5
07:51:05 <lpsmith> You'll have to wait for GHC 7.8 or use an older XCode
07:51:16 <schell> lpsmith: i ran into that last week or so, and was pointed at some homebrew taps that patched ghc and cabal
07:51:24 <schell> but i'm still having that one problem
07:51:42 <lpsmith> ahh, well this isn't a issue I have intimate knowledge of,  just the reports I've heard
07:52:02 <lpsmith> schell, you might ask on #ghc
07:52:15 <schell> the reports are correct - developing with Xcode 5 is a bummer ;)
07:52:22 <schell> wait - i meant ;(
07:52:38 <schell> lpsmith: will do, thanks
07:53:16 <haasn> `^_^v: that's stupid enough to the point where my tired mind could genuinely believe it
07:53:28 <haasn> `^_^v: please tell me that's the actual name (or isn't)
07:53:41 <`^_^v> it's not ;p
07:53:52 <haasn> Then I'll call it that either way :)
07:55:03 <enthropy> haasn: does such a composition have any useful properties? It's not like hylo where you could possibly get rid of that intermediate structure
07:55:32 <haasn> enthropy: you can still get rid of intermediate structure by composing it with other ‘lohymorphisms’
07:55:37 <haasn> (or other folds/unfolds, really)
07:57:09 <`^_^v> haasn: i think its called a metamorphism
07:57:18 <Rarrikins> https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
07:58:04 <haasn> Rarrikins/`^_^v: Thanks, that seems to be it
08:00:42 <Maxdamantus> Is there a language with a type system like Haskell's, but where you have to bind class instances to type variables as type variables are bound to type things?
08:01:43 <acomar> Maxdamantus: you mean constraint kinds?
08:01:50 <t7> == on the end of something indicated base64, right?
08:02:23 <ksf> t7, not really.
08:02:35 <ksf> base64 fills missing stuff with ==, though.
08:02:38 <Maxdamantus> acomar: hmm .. no, I don't think so.
08:03:12 <acomar> Maxdamantus: what are you trying to accomplish?
08:03:21 <ksf> don't ask me for details, though, had to implement it ages ago as an exercise.
08:03:38 <Maxdamantus> I'm not trying to accomplish anything .. just wondering if there's a system that does some certain thing.
08:04:01 <Maxdamantus> if you wrote something like: `foo :: Show a => a -> String; foo = show`, a:Show would be a value argument in the typing environment.
08:04:15 <Maxdamantus> well, an instance argument.
08:04:41 <enthropy> you can write   (a :: Show b => b)
08:04:46 <ksf> do you means something like lexically scoped qualified types?
08:04:59 <Maxdamantus> So you'd only be able to do `foo 4` giving an instance of Show Int
08:04:59 <acomar> So you want access to the dictionary?
08:05:04 * ksf once came across such a calculus in some paper
08:05:44 <Maxdamantus> but `foo = show` works because you're filling in the `a` in show's `Show a => a -> a` with your `a`, which already has a Show instance bound to it.
08:05:46 <ksf> :t foo = show
08:05:47 <lambdabot> parse error on input `='
08:05:55 <ksf> :t let foo = show in foo
08:05:56 <lambdabot> Show a => a -> String
08:05:59 <ksf> works right now.
08:06:03 <acomar> Maxdamantus: Typeclasses are sugar for that in haskell, the dictionaries are passed behind the scenes, but you can get access to the dictionary by passing them around manually if you'd like
08:06:17 <acomar> there was some discussion on /r/haskell a while back about how this was generally preferable
08:06:40 <Maxdamantus> ksf: like that GHC extension that lets you refer to type variables qualified with `forall.`?
08:07:14 <Maxdamantus> ksf: foo :: forall a. a; foo v = let w :: a; w = v in w
08:07:23 <Maxdamantus> (not like that)
08:07:49 <Maxdamantus> acomar: yeah, Haskell basically does that binding in `foo 4` implicitly, selecting a class that matches from the environment.
08:07:50 <ksf> without -XRankNTypes, that's just syntax.
08:08:10 <Maxdamantus> There's another extension that lets you use forall. for the above.
08:08:12 <acomar> Maxdamantus: Right, and nothing is stopping you from doing it explicitly yourself
08:08:21 <Maxdamantus> -XRankNTypes doesn't make that valid.
08:08:38 <Maxdamantus> -XScopedTypeVariables or something.
08:08:56 <mwu> Hi again! I have updated cabal 1.18. However now I am unable to properly run 'cabal update'. It tells me to run... 'cabal update'. http://lpaste.net/93385
08:09:04 <mwu> I had to add "C:\Users\<user>\AppData\Roaming\cabal\bin" at the beginning of the path for the old cabal 1.16 from the Haskell Platform to not be picked.
08:09:11 <Maxdamantus> acomar: so .. how do you do that explicitly?
08:09:55 <Maxdamantus> ksf: indeed, -XScopedTypeVariables: http://www.haskell.org/haskellwiki/Scoped_type_variables
08:10:14 <Maxdamantus> That's basically what SystemF adds to the lambda calculus afaik
08:10:59 <Maxdamantus> Haskell still has those type variables, but you can't refer to them outside of the type expressions that create them (without -XScopedTypeVariables)
08:10:59 <acomar> Maxdamantus: Instead of declaring a typeclass, you declare a data record with the functions you want in it
08:11:13 <acomar> Maxdamantus: an instance is then a value of that data type and you can pass it around the same way
08:11:15 <t7> SystemF adds type variables to the statically typed LC
08:11:16 <Maxdamantus> acomar: but then you have to pass that down in `foo`
08:11:32 <acomar> Maxdamantus: yes, the passing ceases to be automatic
08:11:53 <t7> along with type application etc
08:12:01 <Maxdamantus> It doesn't have to be, if you just require the binding to happen when you bind a type variable to an actual type.
08:12:17 <acomar> I'm not sure what you mean by that
08:12:42 <Maxdamantus> which happens in `show (4 :: Int)` and `fmap succ [1, 2] :: Int`
08:14:09 <acomar> your second example doesn't typecheck?
08:14:29 <Maxdamantus> >> fmap succ [1, 2] :: Int
08:14:35 <Maxdamantus> > fmap succ [1, 2] :: Int
08:14:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:14:37 <lambdabot>              with actual type ...
08:14:56 <acomar> fmap succ [1, 2] :: [Int] works
08:14:59 <Maxdamantus> Eh, need that thing that gives Functor []
08:15:04 <Maxdamantus> er, oops, nvm.
08:15:08 <Maxdamantus> Yeah, that.
08:15:50 <acomar> anyway, what are you trying to bind there?
08:16:20 <acomar> there's an implicit Functor f argument to fmap that you could treat explicitly with your own 'typeclass'
08:16:38 <Maxdamantus> assuming `fmap :: Functor f => (a -> b) -> f a -> f b`, `f` to the instance `Functor []`
08:16:46 * Maxdamantus wonders if he got that type right.
08:16:53 <acomar> right
08:16:54 <Maxdamantus> Yeah.
08:17:06 <acomar> so that Functor f =>
08:17:11 <acomar> is the binding at the type level
08:17:21 <acomar> :: Constraint instead of :: *
08:17:39 <acomar> That's what I meant by constraint kinds
08:17:47 <Maxdamantus> Ah.
08:17:51 * Maxdamantus looks it up again.
08:20:44 <haasn> Is there a compelling reason for ghc to default to -O0 rather than -O1 or -O2?
08:21:10 <Kinnison> Because that's what people expect?
08:21:21 <Kinnison> Certainly I don't expect compilers to be trying hard at optimising unless I ask them to
08:22:13 <d3lxa> how can I proceed some function on a whole list of non-uniform entries? I've tried to put all these things into a list but the type system won't let me do (it's not the first time), a list like: [MyType a] but the mapping function accepts that, any idea?
08:22:14 <acomar> I'm not sure if it's true with ghc, but the usual reason is that higher optimization levels expose bugs that you might not notice at lower optimization levels (and they make debugging harder)
08:23:38 <acomar> Maxdamantus: http://blog.omega-prime.co.uk/?p=127
08:24:03 <Athan> hey guys, what is an "index too large" error?
08:24:26 <acomar> Athan: in what context? list/vector access?
08:28:02 <applicat1ve> > "alphabet" !! 1000
08:28:03 <lambdabot>   *Exception: Prelude.(!!): index too large
08:31:18 <Eduard_Munteanu> Is there a reason foralls are disallowed in asstype instance definition right hand sides?
08:31:20 <applicat1ve> d3lxa: right, you cant make a list of Ints mixed which Chars, but you can make an [Either Int Char] and map over that. Is that too disappointing?
08:31:50 <d3lxa> applicat1ve: yes, each one of the entry has its own a =)
08:32:17 <d3lxa> applicat1ve: it's possible using forall a. right?
08:32:42 <absence> are there any examples that use pipes-binary-0.2.0?
08:33:04 <DMcGill> d3lxa: why do you need the type variable there? It's essentially useless with a forall as you'll lose all information about it.
08:33:09 <Maxdamantus> acomar: hmm .. it doesn't seem to quite do it.
08:33:18 <Eduard_Munteanu> I want to define   class Representable (t :: k) where type Repr t :: *   instance Representable (a :: *) where type Repr a = a    instance Representable (f :: k -> *) where type Repr f = forall (a :: k). f a
08:33:29 <acomar> Maxdamantus: The GADT trick to reify the dictionary doesn't do what you want?
08:33:42 <Maxdamantus> acomar: I guess the main thing in the system I'm wondering about is that there is no association between `Int` and some Show instance.
08:34:05 <applicat1ve> d3lxa: well, it might be, but wont you have trouble writing a function to map over such a list? you have no information about what's inside
08:34:08 <d3lxa> DMcGill: seems I'm still fighting the type system =p can Haskell help me with repetitive things like these?
08:34:30 <larsrh> How can I start debugging linker errors when building a simple Haskell executable with cabal?
08:34:43 <Maxdamantus> acomar: so you'd need to make that association as you use `show`, but if you use `show` on `a` in an environment where `Show a => a` already, you don't need to bind anything.
08:34:48 <Eduard_Munteanu> larsrh: turn on verbosity flags, -v
08:35:28 <acomar> Maxdamantus: Right, but the Show a => a is almost always reflected in the type
08:35:31 <d3lxa> DMcGill: I can copy paste dumbly the lines: one for each entry but what's the point of programming then?
08:35:35 <acomar> that's how ghc knows to pass the right dictionary
08:35:38 <larsrh> Eduard_Munteanu: That doesn't help very much ...
08:35:54 <DMcGill> d3lxa: You have two choices: "[forall a. MyType a]" or "MyType". They're actually the same as the only operations you can perform on either type are ones that ignore the value of a.
08:35:54 <acomar> you can at that point replace show with showish' and pass a different dictionary yourself
08:35:55 <Eduard_Munteanu> larsrh: well what does it say?
08:36:44 <larsrh> Eduard_Munteanu: http://lpaste.net/93386
08:37:23 <Maxdamantus> acomar: so you have definitions for every combination of bound vs. unbound status for each class-qualified variable?
08:37:43 <acomar> Maxdamantus: I'm not sure what you mean
08:37:55 <Eduard_Munteanu> larsrh: looks like libHSgrades is missing a static lib dependency.
08:38:16 <acomar> Maxdamantus: If you want a class constraint on a type variable, it needs to show up in the type of the context or you can't use that class dictionary within the context
08:38:28 <larsrh> Eduard_Munteanu: The problem goes away when I remove an *internal* call inside the library.
08:38:31 <mangaba_leitosa> All, are there library functions (Functor-like or Monad-like) for doing mapping of the type 'a b -> c b' ?
08:38:42 <larsrh> Eduard_Munteanu: So I can rule out the missing dependency problem.
08:39:00 <acomar> Maxdamantus: so you can replace show in that context with your explicit dictionary passing showish' and pass in a different dictionary that pretty prints or something
08:39:12 <d3lxa> DMcGill: seem it won't work "Illegal polymorphic or qualified type: forall a. [SelectOpt a] ; Perhaps you intended to use -XImpredicativeTypes" << ???
08:39:15 <Eduard_Munteanu> larsrh: I don't think so, internal or not it needs the symbol, and it doesn't seem to find it.
08:39:51 <acomar> Maxdamantus: The type looks changes from Show a => a to Dict (Show a) -> a
08:39:54 <Eduard_Munteanu> mangaba_leitosa: can you rephrase that?
08:40:01 <Eduard_Munteanu> mangaba_leitosa: what's a and c?
08:40:09 <larsrh> Eduard_Munteanu: Yes, I can see that the symbol is not there.
08:40:16 <d3lxa> DMcGill: in fact, my function need to know to use the type 'a', so I was wrong, but still, I have to copy/paste then?
08:40:16 <larsrh> Eduard_Munteanu: The question is, why not.
08:40:26 <DMcGill> the forall has to go inside the list brackets - it's not "for one 'a' a list of those 'a's", it's "a list of any 'a's
08:40:26 <mangaba_leitosa> Eduard_Munteanu: a and c are arbitrary types with one type variable
08:40:33 <DMcGill> could you lpaste something?
08:40:36 <larsrh> Eduard_Munteanu: since it's an internal library call and I'm building with cabal, I have no clue what I did wrong
08:40:40 <Eduard_Munteanu> larsrh: probably because a lot of libs don't come with static versions even when you install -dev packages.
08:40:46 <d3lxa> DMcGill: let myTmp :: [ forall a. [SelectOpt a] ] << it's my definition, yes
08:40:54 <mangaba_leitosa> Eduard_Munteanu: e. g. a mapping  'Maybe a -> [a]'
08:41:02 <applicat1ve> d3lxa: its clear you have some type with several cases in mind, shouldn't you just define it?
08:41:24 <applicat1ve> mangaba_leitosa: a natural transformation
08:41:25 <Eduard_Munteanu> mangaba_leitosa: it's not always possible
08:41:36 <larsrh> Eduard_Munteanu: I don't know what you're talking about. I use a cabal sandbox, I don't install OS packages.
08:41:49 <larsrh> Eduard_Munteanu: And even then, it's not a "third-party" symbol which is missing
08:41:55 <mangaba_leitosa> Eduard_Munteanu: sure, so I wonder if there is a type class for types for where it's possible
08:41:56 <larsrh> 'grades' is my own library
08:42:03 <larsrh> which I'm developing at the moment
08:42:11 <mwu> Hi again! I have updated cabal 1.18. However now I am unable to properly run 'cabal update'. It tells me to run... 'cabal update'. http://lpaste.net/93385
08:42:15 <mwu> I had to add "C:\Users\<user>\AppData\Roaming\cabal\bin" at the beginning of the path for the old cabal 1.16 from the Haskell Platform to not be picked.
08:42:22 <Eduard_Munteanu> larsrh: the missing symbol is Git_commit-something
08:42:29 <mangaba_leitosa> applicat1ve: thanks, hoogling it
08:42:36 <geekosaur> mwu: that would be expected, yes
08:42:44 <Eduard_Munteanu> larsrh: are you using a Git-related library?
08:43:00 <mangaba_leitosa> applicat1ve: http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation gives 'Example: maybeToList'. Just my example :-)))
08:43:00 <larsrh> Eduard_Munteanu: Yes. Because my module is called `Git`, and there's a function called `commitFromFiles`.
08:43:05 <larsrh> Eduard_Munteanu: I defined that module and that function.
08:43:13 <geekosaur> cabal is not going to reconfigure your Windows path for you
08:43:18 <Eduard_Munteanu> Oh, nevermind then.
08:43:40 <d3lxa> DMcGill: just a sec, I'm making sure the normal case works
08:44:19 <mwu> geekosaur: Uhm... What exactly is expected? I certainly do not expect "cabal update" to fail and say it requires "cabal update" ...
08:44:24 <Eduard_Munteanu> mangaba_leitosa: it'd be specific to each pair of types
08:44:50 <geekosaur> so you DO expect it to (a) munge the Windows registry (b) somehow restart your cmd.exe out from under you to get the new path?
08:45:00 <geekosaur> frankly I would refuse to let it on my system if it did that
08:45:02 <mwu> geekosaur: (the PATH operation was done before and it didnt solve this issue)
08:45:06 <monoidal> d3lxa: if I understand you correctly, you might want data X = forall a. MyType a and then have a list of [X], given a polymorphic function MyType a -> Int you can map and get [Int]
08:45:19 <monoidal> d3lxa: that's an existential type (not universal)
08:45:21 <Eduard_Munteanu> mangaba_leitosa: however a lot of data structures can be interconverted to lists, usually, if you can take that indirection
08:45:27 <geekosaur> are you using cmd.exe or a cygwin shell?
08:45:29 <mangaba_leitosa> Eduard_Munteanu: whell, I have two types of my own and wonder if I must write a custom mapping function or just make them instances of a class that provides such mapping
08:45:45 <mwu> geekosaur: cmd.exe
08:45:50 <Eduard_Munteanu> mangaba_leitosa: what are those two types?
08:45:57 <geekosaur> shells tend to cache locations, you would need to 'rehash' / 'hash -r' to make it find the newly installed one. I don't know if cmd.exe does caching or how to make it rescan
08:46:12 <applicat1ve> mangaba_leitosa: i'm not sure what you are planning, but here is a library that makes good use of such transformations http://hackage.haskell.org/packages/archive/mmorph/1.0.0/doc/html/Control-Monad-Morph.html
08:46:18 <geekosaur> ...in any case such caching is not something that cabal can control in any way
08:46:27 <Eduard_Munteanu> @hoogle fromList
08:46:27 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
08:46:27 <lambdabot> Data.IntMap.Strict fromList :: [(Key, a)] -> IntMap a
08:46:27 <lambdabot> Data.IntMap.Lazy fromList :: [(Key, a)] -> IntMap a
08:46:32 <danilo2> geekosaur: mwu added the path in system properties, so in "fresh terminal instance" after running "cabal update" he gets following error
08:46:37 <mangaba_leitosa> applicat1ve: thanks, will look at it
08:46:58 <larsrh> D'oh, problem solved. I was missing an `exposed-module` in the cabal file
08:47:11 <larsrh> I do wonder why that's giving me a linker error, and not something complaining earlier
08:47:46 <d3lxa> monoidal: yep that's it
08:47:47 <mangaba_leitosa> Eduard_Munteanu: a sec...
08:47:48 <Eduard_Munteanu> larsrh: sorry for getting in the way then, I thought you used an external git lib or something :)
08:48:25 <larsrh> Eduard_Munteanu: I do, but they are all not very pleasant, so I wrapped one :-)
08:48:34 <d3lxa> monoidal: do you loose the 'a' type when you put them in the [X]?
08:48:56 <applicat1ve> mangaba_leitosa: oh I missed the intervening exchange with Eduard_Munteanu
08:49:59 <DMcGill> d3lxa: yes, that's the point. Things in lists must have the same type and if you have possibly differing 'a's then they can't go in a list together. The 'X' removes that 'a' and gives them the same type.
08:50:39 <monoidal> d3lxa: just a small correction, I meant data X = forall a. X (MyType a). See http://www.haskell.org/haskellwiki/Existential_types#A_short_example
08:51:04 <monoidal> d3lxa: (and to answer the question, the answer is "yes", though strictly speaking, all types are lost runtime)
08:51:11 <DMcGill> and also http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:51:15 <d3lxa> DMcGill: there is one hack I have in mind: create a "list"-tuple (a,(b,(…))) and recurse in it? right? =p
08:51:28 <d3lxa> DMcGill: that's not the first time we talk about it =) already read that hehe
08:51:30 <mwu> When I'm trying to configure a cabal package (after updating cabal to 1.18) I'm getting strange error: http://lpaste.net/93388 . I would be thankful for any hints how to solve this issue :)
08:52:03 <geekosaur> I think hackage is down right now, today is hackage2 upgrade day
08:52:15 <DMcGill> d3lxa: http://hackage.haskell.org/package/HList
08:52:18 <geekosaur> or at least partially down
08:52:26 <DMcGill> d3lxa: or you can use Data.Dynamic
08:52:36 <geekosaur> have not seen the all-clear yet so I assume it is unstable
08:52:47 <mangaba_leitosa> Eduard_Munteanu: http://lpaste.net/93389 -- I want to map between Object fields and Attr values
08:52:50 <DMcGill> but I really do suggest changing your approach to fit the type system rather than changing the type system to fit your approach
08:52:52 <d3lxa> DMcGill: so you think it will work?
08:52:54 <Eduard_Munteanu> About that, is there any notion of existentially-quantified types in a typeclass instance? That is, a type associated with an instance which does not appear in the head or class definition.
08:53:13 <mangaba_leitosa> Eduard_Munteanu: that is, my types are Attr and Object
08:53:15 <d3lxa> DMcGill: I would like to work with the TS but can you give me a hint maybe?
08:53:24 <DMcGill> paste all your code
08:53:42 <d3lxa> DMcGill: prepare for copy pasted code then =)
08:53:44 <DMcGill> it's hard to see what's going on with just 1-line snippets. Use lpaste.net
08:53:48 <DMcGill> Don't paste here!
08:53:52 <Eduard_Munteanu> mangaba_leitosa: just write a function from one to the other
08:53:54 <enthropy> d3lxa, DMcGill that HList is kind of outdated
08:53:56 <mangaba_leitosa> Eduard_Munteanu: they don't have type variables at the moment, though, but if they were, then Attr would be 'Attr a' and Object would be 'Object a b c d'
08:54:28 * Eduard_Munteanu still holds his ground
08:54:35 <DMcGill> enthropy, d3lxa: good, I don't suggest its use at all.
08:54:42 <mangaba_leitosa> Eduard_Munteanu: I will, but doing it I began wondering if there are standard fmap-like functions for such mapping. will now look at what applicat1ve suggested
08:55:40 <applicat1ve> mangaba_leitosa: you probably don't want a class in any case, note this type synonym which comes up from time to time http://lpaste.net/93390
08:55:49 <mwu> geekosaur: I do not think this is the issue. first of all - the packages cache on my disk IS updated after this action. Additional I tried to use hdiff.luite.com:http://hdiff.luite.com/packages/archive instead and I'vre got EXACTLY the same result.
08:55:53 <Eduard_Munteanu> mangaba_leitosa: sure, you *can* define a typeclass even more generic, like   class Convert a b where convert :: a -> b   but it's not a good idea because instances don't share anything at all.
08:56:07 <d3lxa> DMcGill: sorry but can't do anything else than this right now http://sprunge.us/cCAL (don't mind the 'l' variable name, should be all different, by 2-lines pair)
08:57:08 <Eduard_Munteanu> mangaba_leitosa: if you want to convert between two specific types, just give it a name.
08:57:54 <geekosaur> then I cannot help. maybe someone else knows the details of how cabal-install works on windows, or if something is weird/incompatible with the hackage2 package list or something
08:58:04 <mangaba_leitosa> Eduard_Munteanu: makes sense...
08:58:05 <ibotty> hi, can someone please review a flatten function: http://lpaste.net/93387
08:58:05 <ibotty> i'm pretty sure there is a less messy way, but i don't get it now
08:58:08 <mangaba_leitosa> applicat1ve: looking at it...
08:58:18 <DMcGill> d3lxa: what database are you using? It sounds like you should be asking for help with that rather than your objects
09:00:03 <danr> ibotty: did you try to do it with a list comprehension instead?
09:00:10 <danr> or did you specifically want to do it with recursion?
09:00:25 <DMcGill> ibotty: consider using 'map' rather than recursing yourself. If you make a function :: ([a],b) -> [(a,b)] then you can also use concatMap to get a function of type [([a],b)] -> [(a,b)]
09:01:03 <DMcGill> as for the first function (:: ([a],b) -> [(a,b)]) consider what you're doing: for each 'a' in the list, pair it with the 'b'.
09:01:21 <ibotty> DMcGill: good idea
09:01:31 <ibotty> i know how to proceed. thank you
09:02:15 <ibotty> danr: i don't really like list comprehensions, so i tend not to think about them. but that might work as well (i have to look them up again..)
09:02:34 <Eduard_Munteanu> You can @undo them here. :)
09:02:35 <mangaba_leitosa> applicat1ve: yes, the NT type is the type of mapping I wanted, yet I wonder how defining it can makes things any better :_)
09:02:36 <DMcGill> ibotty: [f x | x <- xs] === map f xs
09:02:56 <DMcGill> so any solution you come up with using map, you can also express using list comprehensions.
09:03:08 <ibotty> i know
09:03:09 <ibotty> :)
09:04:07 <danr> ibotty: ok. it's quite concise with a list comprehension.
09:04:23 <DMcGill> they come into their own when combining multiple lists together
09:04:49 <DMcGill> using map and zipWith and stuff can get annoying - using do-notation or list comprehensions is better imo
09:05:09 <Eduard_Munteanu> Data.Traversable.sequence could help with one of those.
09:05:27 <DMcGill> indeed
09:05:46 <mangaba_leitosa> applicat1ve: will now try to play with Control.Monad.Morph :-)
09:06:13 <Eduard_Munteanu> (though it's the opposite of the normal sequence)
09:08:37 <ParahSai1in> can there just be an easy way to import hidden modules from a package?
09:09:21 <ParahSai1in> or is there already an easier way to do it than reinstalling after manually editing the .cabal file
09:12:29 <akegalj_> if i do "data A = B | C | D; data D = F | G" , is valid values for A then {B, C, F, G} ?
09:13:42 <Rarrikins> akegalj_: Nope. For that, use a class perhaps.
09:13:44 <haasn> foldAllS (*) 1 $ fromFunction (Z:.n) (\(Z:.i) -> i) -- this runs nearly an order of magnitude faster than a naive product [1..n]
09:13:46 <haasn> repa is fast!
09:13:51 <Rarrikins> akegalj_: Or use data A = Zomg String
09:13:56 <Rarrikins> akegalj_: Or something like that.
09:14:20 <DMcGill> "data A = B | C | D D; Data F = F | G"
09:14:21 <akegalj_> Rarrikins: oh, ok.
09:14:38 <DMcGill> then expanded, A = B | C | D F | D G
09:14:51 <DMcGill> note the difference between D the data constructor and D the type constructor
09:15:15 <DMcGill> "C | D (data constructor) D (type name)"
09:15:27 <DMcGill> they're in different namespaces
09:15:38 <akegalj_> DMcGill: hm
09:16:14 <akegalj_> DMcGill: ok
09:16:21 <akegalj_> DMcGill: i figured now
09:16:58 <DMcGill> another, less confusing, example. data Maybe a = Just a | Nothing
09:17:17 <DMcGill> Maybe is the type name, Nothing and Just are constructors
09:17:33 <ocharles> mm_freak_: I can't decide if a non-delaying integral makes sense or not. I've managed to fill a sheet of graph paper and am yet to figure it out :)
09:17:37 <DMcGill> it doesn't make any sense to have foo :: Nothing
09:18:07 <ocharles> it seems like if you don't delay, then you assume that the signal has occured for the given instant delta, and as the delta increases, things would get weirder
09:18:26 <HugoDaniel> > 1 + 1
09:18:27 <lambdabot>   2
09:18:28 <ocharles> but I suppose things get weird with large deltas in the delaying integral, they just get weird an instant later
09:18:31 <ocharles> :)
09:23:43 <exicer> Couldn't match expected type `Text.XML.Document' with actual type `xml-conduit-1.1.0.5:Text.XML.Document'
09:23:47 <exicer> What ?
09:23:58 <ocharles> exicer: you have two versions of xml-conduit installed
09:24:08 <ocharles> (and both referenced at the same time)
09:24:11 <ocharles> ghci I assume?
09:24:30 <exicer> Got it from using runhaskell
09:24:47 <ocharles> ok, well check 'ghc-pkg list' to see if you have two xml-conduit packages
09:25:12 <exicer> Ah, yeah it looks like I have two versions
09:26:04 <exicer> What can I do to fix it  ?
09:26:13 <exicer> Presumably just removing one package will arse everything up
09:26:45 <ocharles> exicer: I would ghc-pkg unregister one of them, then 'ghc-pkg check' and see what's broke
09:28:14 <exicer> ocharles: Trying to unregister one actually told me it would break stuff. Anyway, fixed now - thanks!
09:28:21 <ocharles> huzzah
09:29:44 <robindv> Hi, I have a function that requires an Integer as argument, i want to give it (floor $ logBase 2 n) as one of the arguments, but that fails. How can I convert it to an Integer?
09:30:38 <geekosaur> :t floor
09:30:39 <lambdabot> (Integral b, RealFrac a) => a -> b
09:30:43 <Rarrikins> robindv: Is n an integer?
09:30:55 <geekosaur> how is it failing? show actual code?
09:30:56 <robindv> Rarrikins: Yes, n is..
09:30:57 <geekosaur> @lpaste
09:30:57 <lambdabot> Haskell pastebin: http://lpaste.net/
09:31:06 <Rarrikins> robindv: Use (fromIntegral n) in place of n.
09:31:30 <Rarrikins> > floor (logBase 2 (fromIntegral (5 :: Integer)))
09:31:31 <lambdabot>   2
09:31:50 <Rarrikins> > floor . logBase 2 . fromIntegral $ (5 :: Integer) -- or this
09:31:51 <lambdabot>   2
09:32:27 <Rarrikins> You can see from the type of logBase that it needs something other than an integer:
09:32:30 <Rarrikins> @type logBase
09:32:31 <lambdabot> Floating a => a -> a -> a
09:34:02 <robindv> Thanks, its working :)
09:35:29 <Rarrikins> robindv: No problem.
09:36:45 <haasn> am I the only one who thinks ‘enum’ should be the other way around?
09:37:07 <ocharles> haasn: fromEnum and toEnum?
09:37:12 <ocharles> because I always get them the wrong way round
09:37:15 <haasn> ie. iso fromEnum toEnum
09:37:18 <haasn> well
09:37:24 <ocharles> oh, the lens Iso?
09:37:31 <haasn> I find myself doing stuff like ‘from enum +~ 1’ a lot more
09:37:36 <haasn> oh, to be fair, that could be ‘%~ succ’
09:38:28 <maverick_> Could someone explain me what the function uncurry does, I already googled and hoogled it, but I still don't get it
09:38:38 <haasn> :t uncurry
09:38:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:38:56 <Saizan> ?src uncurry
09:38:56 <lambdabot> uncurry f p = f (fst p) (snd p)
09:38:57 <haasn> uncurry f (a,b) = f a b -- not sure what you're confused about
09:39:01 <haasn> ..
09:39:05 <haasn> That source needs to be deleted from history :(
09:39:20 <schell> maverick_: it takes the a and b from a tuple and applies them to the function
09:39:24 <haasn> uncurry f ~(a,b) = f a b -- lazier
09:40:17 <elliott> > uncurry (,) undefined
09:40:18 <lambdabot>   (*Exception: Prelude.undefined
09:40:23 <elliott> > uncurry (,) undefined `seq` ()
09:40:25 <lambdabot>   ()
09:40:31 <elliott> looks like @src is right.
09:41:39 <haasn> > let uncurry f ~(a,b) = f a b in uncurry (,) undefined `seq` ()
09:41:40 <lambdabot>   ()
09:45:53 <vlatkoB> Is there a way to catch "file not found" from readDocument in HXT?
09:46:59 <ocharles> vlatkoB: Control.Exception.catch
09:47:08 <ocharles> I would have thought
09:50:26 <vlatkoB> ocharles no, it can't. readDocument has  IOStateArrow s b XmlTree return type and catch expects IO a
09:50:49 <vlatkoB> same for bracket
09:54:11 <joelteon> is there a num instance for vectors in polar format somewhere
09:56:17 <Rarrikins> joelteon: A Num instance wouldn't work, since you can't multiply vectors.
09:56:53 <joelteon> okay
09:59:05 <haasn> joelteon: do you mean complex numbers or something like that?
09:59:16 <chaoslynx> what is the canonical way to parse a float from a bytestring with say attoparsec?
10:00:24 <chaoslynx> i've seen a library that uses strtof, but that can't be right
10:00:34 <chaoslynx> (i.e. via ffi)
10:03:15 <haasn> chaoslynx: attoparsec exports ‘double’ and ‘rational’ (the latter of which can be converted to a Float)
10:03:51 <haasn> chaoslynx: with behavior similar to ‘read’
10:05:13 <osa1> sorry if this is off-topic -- I don't understand the concurrency/parallelism argument for JVM(probably because I'm not a JVM user), what does it do that we can't do with GHC runtime?
10:05:34 <chaoslynx> haasn, thank you, I did not see that
10:06:02 <chaoslynx> and the source suggests I would have had a hard time replicating the behaviour
10:06:30 <geekosaur> osa1, are you referencing something?
10:07:07 <osa1> geekosaur: I was reading this article www.wired.com/wiredenterprise/2013/09/the-second-coming-of-java/
10:09:32 <geekosaur> (as far as I am concerned, Java is an unmitigated security hole)
10:10:10 <geekosaur> osa1, the likes of Wired would not even consider Haskell. they think it's an esolang with no relevance, Java is as close to a proper concurrency/parallelism platform as they can conceive
10:10:52 <geekosaur> I would expect GHC to work much better, but we gotta support walking security holes as the future of programming...
10:11:15 <osa1> geekosaur: my question is not specific to that article -- I heard similar arguments before (saying "java provides scalable performance" etc.)
10:11:21 <osa1> s/java/jvm
10:11:33 <schell> geekosaur: what is "walking security holes"?
10:11:37 <haasn> ‘we gotta support’ submission is part of the crime
10:12:00 <haasn> we need to protest :(
10:12:20 <haasn> “programmers starve themselves worldwide in unanimous refusal to write java”
10:13:37 <applicat1ve> they seem to be saying, if you are writing the twitter machine, you do better to use java than ruby.
10:13:51 <geekosaur> schell, is your head in the sand? it has massive security holes. Oracle's latest attempt to mitigate them is likely to make them much worse, because they didn't consider how well "ask the user before running untrusted code" and "trust all signed code" and the new proposal "require all ocde to be signed" interact
10:13:57 <joelteon> does atan operate on degrees or radians?
10:14:13 <ashwins> hey, can someone help me with a Data.Binary issue?
10:14:13 <monoidal> > atan 1
10:14:15 <lambdabot>   0.7853981633974483
10:14:31 <stevely> jvm has better real support for concurrency than ghc currently, you'll have a hard time scaling up past 4 cores in haskell, jvm has no troubles saturating cores
10:14:41 <joelteon> looks like radians
10:14:53 <monoidal> joelteon: indeed. it's 45 deg
10:14:56 <solarus> > atan 1 * 4
10:14:57 <lambdabot>   3.141592653589793
10:14:59 <Rarrikins> joelteon: Yeah, just about every programming language uses radians.
10:15:01 <joelteon> ok
10:15:03 <joelteon> good
10:15:46 * ksf wants closed fundeps
10:15:48 <osa1> stevely: what is the current most widely used way of writing concurrent programs in Haskell? (i.e. what libraries?) also, what about parallelism?
10:16:24 <osa1> I almost never write concurrent or parallel code so I don't know this stuff
10:17:22 <Iceland_jack> osa1: Check out Simon Marlow's book
10:17:27 <slack1256> ^ this
10:17:31 <Iceland_jack> http://chimera.labs.oreilly.com/books/1230000000929/index.html
10:17:49 <Iceland_jack> And play around with Control.Concurrent
10:17:51 <osa1> ahh right, I forgot that book
10:18:02 <ksf> actually, what would be even cooler would be fundeps for closed type families.
10:18:12 <Iceland_jack>     forkIO (forever (putStrLn "HI!"))
10:18:12 <Iceland_jack> launches a thread that prints "HI!" forever
10:18:43 <ashwins> quick question: how can I do a monadic computation n number of times, and throw away the return value? (I just want to execute the operations for side effects)
10:18:43 <haasn> That book is really the best resource :)
10:18:50 <haasn> ashwins: replicateM_
10:18:52 <monoidal> ashwins: replicateM_
10:18:52 <Maior> its an _awesome_ book
10:18:56 <ashwins> cool thanks
10:18:57 <applicat1ve> replicateM_
10:19:00 <stevely> osa1: no idea what's mostly used, my only experience is dealing with the web stuff
10:19:00 <slack1256> replicateM_
10:19:03 <Iceland_jack> (where forever comes from Control.Monad, and forkIO can be imported through Control.Concurrent)
10:19:11 <applicat1ve> replicateM_
10:19:13 <Maior> (bought and read it lasdt week)
10:19:21 <haasn> somebody accidentally replicateM_'d (send "#haskell" "replicateM_")
10:19:42 <Iceland_jack> speaking of replicateM_ ;)
10:19:42 <Iceland_jack>     replicateM_ 10 (forkIO (putStrLn "HI!"))
10:19:42 <Iceland_jack> launches 10 threads that all print "HI!
10:19:43 <Iceland_jack> "
10:19:44 <ashwins> hahahahahah
10:20:34 <slack1256> also hoogle/hayoo could have helped in this case
10:21:14 <Iceland_jack> @hoogle Int -> IO a -> IO ()
10:21:14 <lambdabot> Graphics.UI.GLUT.Callbacks.Global addTimerCallback :: Timeout -> TimerCallback -> IO ()
10:21:15 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
10:21:15 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
10:21:40 <Iceland_jack> ashwins: (for future reference)
10:21:45 <ashwins> got it.
10:22:01 <ashwins> how do you know what the type signature is though?
10:22:10 <ashwins> specifically, how do you know it returns m ()?
10:22:16 <ashwins> is that just the convention for ignoring the returned value?
10:22:19 <Iceland_jack> ashwins: Yes
10:22:24 <ashwins> gotcha, will keep that in mind.
10:22:34 <Iceland_jack> You want to repeat an action (IO ()) some number of times (Int)
10:22:34 <haasn> :t void
10:22:35 <lambdabot> Functor f => f a -> f ()
10:22:42 <Iceland_jack> there is also:
10:22:42 <Iceland_jack> @ty replicateM
10:22:43 <lambdabot> Monad m => Int -> m a -> m [a]
10:22:46 <monoidal> ashwins: monadic functions ending in underscore return m ()
10:22:55 <Iceland_jack> which gives you the output of the action in a list
10:23:02 <ashwins> ohh, I see. yeah, I've seen that before with forM_, mapM_
10:23:16 <Iceland_jack> @ty repliateM 5 getLine     -- ashwins: This gets 5 lines and returns them as a list
10:23:17 <lambdabot>     Not in scope: `repliateM'
10:23:17 <lambdabot>     Perhaps you meant one of these:
10:23:17 <lambdabot>       `replicateM' (imported from Control.Monad.Writer),
10:23:22 <Iceland_jack> @ty replicateM 5 getLine     -- ashwins: This gets 5 lines and returns them as a list
10:23:23 <lambdabot> IO [String]
10:23:47 <Iceland_jack> But if you want to ignore the output (like you would with print, …) you use replicateM_
10:24:23 <ashwins> sure, makes sense.
10:29:49 <schell> when using -XRecordWildCards is there a way to escape a wildcard?
10:31:11 <geekosaur> schell, what do you mean by that?
10:32:05 <schell> geekosaur: well i've got a function in which i've used record wildcards and now i have to use the fieldname as a regular function again
10:32:40 <schell> i'm getting a type mismatch because the function is a piece of data, not a function that gets the data
10:32:56 <shachaf> My solution: Don't use RecordWildCards.
10:33:01 <shachaf> The perils of shadowing.
10:33:11 <schell> right? that's what i'm thinking
10:33:34 <schell> i'd use lenses but i'm having some ghc/xcode problems and can't link a dependent module
10:33:46 <Cale> You could just use ordinary record syntax
10:34:01 <schell> Cale: that's what i'm going to do
10:34:15 <schell> it's just a hairy function
10:34:19 <geekosaur> looks like you can use a pattern like (Constructor { field = var, .. })
10:34:50 <shachaf> Yes, that's ordinary record syntax.
10:35:03 <geekosaur> not with the trailing .. it's not; it's a hybrid syntax
10:35:40 <schell> geekosaur: huh, i've never seen that
10:35:49 <schell> is that RecordWildCards or standard?
10:36:28 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
10:36:41 <geekosaur> if it's using ".." in a record pattern then it's RecordWildCards
10:36:52 <schell> cool, thanks
10:39:42 <schell> great, that did it
10:43:44 <Eduard_Munteanu> Is there a notion of existential quantification for typeclasses? By analogy with GADTs, they'd be types which appear in an instance definition as an associated type, but not in the head or class declaration.
10:44:05 <jhormuz_> I like to pipeline data through various functions, using $ and <$> as needed, but the resulting functions can get very messy with parenthesis because of precedence.  Is there some ways to modify things so that I can write something like "a $ b <$> c $ d <$> e" without parenthesis?
10:44:35 <shachaf> jhormuz_: What do you want that to mean?
10:45:37 <ReinH> I generally prefer "pipelining" with . and fmap ala Bird
10:45:55 <haasn> I like to look at my data using a thick pair of lenses
10:46:17 <shachaf> There should be a data type that abstracts a pair of lenses.
10:46:25 <jhormuz_> shachaf- for example, I can write "head $ (1+) <$> [1,2]", but on the other hand "(1+) <$> id $ [1, 2]" fails without parenthesis.
10:46:29 <haasn> data Binoculars = ...
10:46:45 <shachaf> jhormuz_: That's no answer.
10:46:57 <jhormuz_> shachaf- not a big deal with something that small, but with bigger stuff it can be a mess.
10:47:38 <Eduard_Munteanu> jhormuz_: do you just want a variant of '$' that binds tighter than your (<$>)?
10:47:39 <shachaf> I can't read your mind. :-( What do you want "a $ b <$> c $ d <$> e" and "(1+) <$> id $ [1,2]" to mean?
10:47:46 <jhormuz_> schachaf- In bash, I write a | b | c | d all the time, in haskell I haven't found something so easy.
10:48:00 <ReinH> shachaf: presumably the only thing that typechecks? :p
10:48:12 <jhormuz_> eduard_munteanu- the same precidence but right associative across both.
10:48:14 <shachaf> Huh?
10:48:20 <ReinH> I think those are f = head . fmap (+1) and g = fmap (+1) . id
10:48:27 <mjboa> maybe you want left associativity with $?
10:48:46 <shachaf> Yes, that's the first thing I thought of. But I'm not going to guess.
10:48:59 <ReinH> shachaf: as in, try arbitrary parens until something typechecks
10:49:00 <jhormuz_> schchaff- data flows from right to left, e is a value, apply d to it, then c to that , etc
10:49:48 <shachaf> jhormuz_: ...Can you add parentheses to your expression so I can see what the intended meaning is?
10:49:48 <jhormuz_> reinh- I guess it helps to write out the fmap explicitly....
10:49:49 * haasn wants RebindableSyntax to overload list notation to ‘cons’ and ‘nil’ or something :(
10:49:57 <applicat1ve> > let infixr 5 //; f // x = f x in (+) <$> map (+1) // [1..3] ++ [10..14] <*> [1..5]
10:49:58 <lambdabot>   [3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,12,13,14,15,16,13,14,15,16,17,14,15,16,17,18...
10:50:28 <acomar> anyone know if it's possible to declare a polymorphic function through the ffi? I'm trying to wrap a templated c++ function as...smoothly...as possible
10:50:34 <jhormuz_> schachaf- always right associative .... (((a $ (b $ (c $ (d))))
10:50:42 <ReinH> jhormuz_: all your examples so far are easy to write using composition
10:50:44 <shachaf> Huh?
10:50:46 <enthropy> Eduard_Munteanu: is that different from the `a' and `b' i in the type of fmap?
10:50:51 <shachaf> You wrote "a $ b <$> c $ d <$> e"
10:50:59 <shachaf> What should the meaning of that be?
10:51:09 * Taneb puts his hand up
10:51:27 <ReinH> shachaf: I ignored that one
10:51:28 <enthropy> acomar: there are a bunch of tools that try to help with bindings to C++
10:51:46 <acomar> entropy: yea, do any help with templated functions?
10:52:23 <acomar> or am I stuck declaring a function for each type (either automatically or not)
10:52:26 <enthropy> acomar: worst case you have to write a binding of the C++ library in C for a large number of instantiations of the templates (is that the right word?), then import those... then write a haskell class that makes all those individual C functions have a single name
10:52:29 <ReinH> jhormuz_: try writing these using composition instead
10:52:29 <jhormuz_> schachaf - always right associative, data flow from right to left (opposite of bash pipes).... (a $ (b <$> (c $ (d <$> (e)))))
10:52:33 <haasn> hmm...
10:52:52 <Eduard_Munteanu> enthropy: yes, that's merely rank-2-polymorphic if you GADT-ize it.
10:52:53 <acomar> enthropy: I've already written the bindings for most of the library
10:53:02 <shachaf> OK then.
10:53:04 <haasn> It would be cool if there was some way to reflect (<$>) with SimpleReflection!
10:53:07 <acomar> enthropy: I'm just working on a few classes my header parser couldn't handle
10:53:33 <acomar> enthropy: it's basically down to the tricky stuff
10:53:34 <applicat1ve> i think it will be hard to find a fixity for your new $ that does that jhormuz_
10:53:38 <jhormuz_> reinh- if I write fmap explicitly, it works with . or $, just thought there could be a cleaner way with <$>
10:53:47 <ReinH> jhormuz_: I don't think it's cleaner. I think it's line noise
10:54:04 <haasn> jhormuz_: do you come from a perl background? no offense :P
10:54:12 <applicat1ve> all operators are line noise til you learn them
10:54:23 <haasn> applicat1ve: or learn similar ones!
10:54:26 <skypers> hi
10:54:27 <ReinH> applicat1ve: and some operators are more line noise than others
10:54:29 <Eduard_Munteanu> enthropy: data Functor :: (* -> *) -> * where Functor :: forall f. (forall a b. (a -> b) -> (f a -> f b)) -> Functor f
10:54:33 <jhormuz_> applicative- I guess I am asking for something that Haskell doesn't do, two ops with same priority that are right associative together.
10:54:42 * applicat1ve concede to ReinH 
10:55:04 <enthropy> acomar: what tool are you using?
10:55:10 <jhormuz_> haasn- not really, but I get the idea from bash....  piping data from left to right.
10:55:13 <applicat1ve> jhormuz_: <$> <*> have the same priority
10:55:42 <ReinH> jhormuz_: the more idiomatic way to do this sort of thing right-to-left is via function composition
10:55:45 <haasn> ReinH: Like (<#%~)?
10:55:52 <ReinH> jhormuz_: and I think that if you try it a few times you'll get the hang of it and prefer it
10:55:57 <acomar> enthropy: a lot of custom stuff I've written, but it outputs a C wrapper and .hsc files that provide the wrapped functions in haskell
10:55:59 <blume> <*)))<
10:56:10 <blume> >(((*>
10:56:17 <applicat1ve> jhormuz_: nah, you'll just be brainwashed in haskell-style
10:56:17 <jhormuz_> reinh- I do that all the time also, but sometimes I need to use $
10:56:22 <ReinH> jhormuz_: one of the advantages of function composition is that it is easier to see that you are composing potentially reusable units of functionality
10:56:24 <acomar> enthropy: I got lucky because the library I'm wrapping had a header parser that was written to automatically generate the python bindings
10:56:26 <Sonarpulse> is there any ways to do something like classTuple :: (* -> Constraint) -> (* -> Constraint) -> * -> Constraint
10:57:33 <Sonarpulse> I can do type ClassTuple a b arg = (a arg, b arg)
10:57:44 <Sonarpulse> but I can't curry the type synnonym
10:57:46 <applicat1ve> type Tuple c f a = (c a , f a)
10:57:47 <jhormuz_> reinh- but sometimes I just prefer writing a <$> b $ x over (a . fmap b) x
10:57:56 <applicat1ve> oh
10:58:13 <ij> I've got a general question: Does immutability cost more on space(memory)?
10:58:16 <ReinH> jhormuz_: those aren't equivalent
10:58:18 <haasn> thos-- yeah
10:58:27 <ReinH> f = a . fmap b . c is more obviously reusable and contains less line noise than f x = a $ b <$> (c x)
10:58:31 <applicat1ve> ij: yes
10:58:33 <Sonarpulse> I also have type Exists (c :: * -> Constraint) = forall a. c a => Exists a
10:58:34 <applicat1ve> ij no
10:58:38 <jhormuz_> reinh- did I get it wrong....
10:58:38 <ij> ha
10:58:40 <Sonarpulse> and I want to be able to do somthing like
10:58:47 <haasn> ReinH: you mean f x = a $ b <$> c $ x -- clearly :)
10:58:53 <ReinH> jhormuz_: the fact that you are having so much trouble correctly writing statements using $ and ($) should tell you something important
10:59:04 <ReinH> er <$>
10:59:10 <Sonarpulse> Exists (Combine Class1, class2)
10:59:11 <applicat1ve> ij: you can mutate stuff all you want in haskell, if you want to, so dont worry
10:59:49 <ij> Well, how exactly? I can't just say a = 1 in one line, and b = 2 in the other one, can I?
11:00:01 <haasn> ij: if you're writing some algorithm that, say, heavily modifies individual fields of a vector or something; then yeah, expect lots of slowness if you use the immutable interface
11:00:02 <Sonarpulse> ij: STref, IOref, MVar, TVar
11:00:07 <applicat1ve> there are various ways of doing the same as what you actually meant there ij
11:00:20 <shachaf> thos++
11:00:21 <Sonarpulse> also look up Data.Vector
11:00:25 <ksf> Sonarpulse, you can't partially apply type functions.
11:00:50 <ksf> afaiu it's one of those things that make type inference possible.
11:00:51 <ReinH> haasn: I can confirm ;) but that's why `modify` exists
11:00:51 <ij> applicat1ve, Yes, that I know, but I'm talking about the specific — assignment. (I was just really curious)
11:00:56 <ij> Sonarpulse, will do
11:00:58 <Sonarpulse> kdf: any way then to explicitly do (* ->
11:00:58 <Sonarpulse> 	     Constraint) -> (* -> Constraint) -> (* -> Constraint)
11:01:03 <ReinH> ij: there is no assignment
11:01:05 <Sonarpulse> * ksf
11:01:14 <ij> ReinH, So those are function defs, correct?
11:01:19 <Sonarpulse> higher order type functions?
11:01:25 <jhormuz_> reinh- Are you saying you don't see any use for <$> (ie- it shouldn't be in the libs to begin with?)
11:01:41 <haasn> shachaf: oh.. now I finally realize why you keep ++'ing seemingly random names
11:01:45 <ReinH> jhormuz_: I absolutely see a use for <$>, just not your use :)
11:01:59 <jhormuz_> reinh- when?
11:02:18 <ReinH> ij: = is not variable assignment in Haskell. You should not expect it to behave like variable assignment.
11:02:42 <ij> I will definitely look in to what it really is now.
11:02:49 <blume> > f <$> x == pure f <*> x
11:02:50 <lambdabot>   Precedence parsing error
11:02:50 <lambdabot>      cannot mix `Data.Functor.<$>' [infixl 4] and ...
11:03:02 <applicat1ve> you can define x =: 17 as , eg writeIORef x 17, if you;re into that kind of thing ij
11:03:02 <blume> aw
11:03:10 <ReinH> jhormuz_: I like using it for applicative things and when an infix fmap would be more elegant.
11:03:19 <ReinH> I don't like using it to compose 'pipelines'
11:03:28 <ReinH> fmap isn't composable in that way to begin with
11:03:42 <applicat1ve> @type fmap . fmap . fmap
11:03:43 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:03:51 <applicat1ve> highly composable
11:03:58 <jhormuz_> reinh- you mean like f <$> a <*> b?
11:03:58 <ReinH> applicat1ve: yes, but not *in that way*
11:04:02 <ReinH> jhormuz_: yes
11:04:14 <haasn> applicat1ve: fmap f . fmap g . fmap h . fmap i = fmap (f . g . h . i) -- even more highly composable!
11:04:25 <applicat1ve> indeed very
11:04:33 <ReinH> haasn: yes, but not in the way it was being used
11:04:35 <Eduard_Munteanu> Sonarpulse: might be doable with polykinds
11:04:36 <applicat1ve> we need a new fmap though
11:04:37 <haasn> ReinH: I know :)
11:04:46 <applicat1ve> the usual fmap doesn't have 'leftover support'
11:04:55 <haasn> Sonarpulse: you can do that with a type family I think
11:05:09 <ReinH> haasn: and yes, that's part of the reason I prefer f . fmap g to f $ (g <$>). It's easier to see how to properly compose them.
11:05:11 <Sonarpulse> I'll check polykinds first
11:05:16 <Sonarpulse> type family seems overkill
11:05:17 <haasn> I don't think PolyKinds is related
11:05:41 <ReinH> haasn: and also easier to see opportunities to fuse fmap f . fmap g
11:05:45 <haasn> Sonarpulse: you can also do this with type synonyms if you're fully applying them
11:05:54 <haasn> LiberalTypeSynonyms and ConstraintKinds I think
11:05:56 <ReinH> (maybe f . g is a useful expression on its own)
11:06:03 <ReinH> (and maybe it deserves a name)
11:06:28 <Taneb> What does "{-# ANN module "ignore Use section" #-}" mean?
11:06:30 <haasn> :t maybe ?f . ?g
11:06:31 <lambdabot> (?f::b, ?g::a -> a1 -> b) => a -> Maybe a1 -> b
11:06:45 <ReinH> haasn: sigh
11:07:02 <haasn> ..
11:07:04 <haasn> oh
11:07:06 <haasn> Sorry, I'm way too tired! :)
11:07:13 <ReinH> hah
11:07:47 <applicat1ve> ij here's a discussion of the abstract question http://existentialtype.wordpress.com/2011/04/09/persistence-of-memory/
11:08:09 <Rarrikins> Taneb: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/pragmas.html#ann-pragma
11:08:13 <haasn> applicat1ve: clearly we need pipes
11:08:23 <haasn> in Prelude, that is
11:08:31 <Eduard_Munteanu> Sonarpulse, haasn: I was suggesting using polykinded stuff like 'k -> Constraint'
11:08:43 <Sonarpulse> ^ I think that is more ConstraintKinds
11:08:45 <Sonarpulse> which I have
11:09:04 <Sonarpulse> my problem is while I can make a type function that takes a type function
11:09:12 <Sonarpulse> I can't make one that returns a type function
11:09:19 <applicat1ve> fmap should take a function a -> b, an f a, and some leftover a, to an f b
11:09:53 <haasn> Sonarpulse: do you mean you want a type family :: * -> Constraint -- ?
11:09:55 <Eduard_Munteanu> Sonarpulse: you can do that with asstypes
11:10:09 <Eduard_Munteanu> If you mean doing partial application.
11:10:34 <Sonarpulse> yes partial application, or explicit type lambda would work
11:14:14 <Taneb> Rarrikins, thanks
11:15:09 <Sonarpulse> haasn, Eduard_Munteanu, anyideas?
11:16:05 <Eduard_Munteanu> Sonarpulse: anything in particular you want to do?
11:16:15 <Rarrikins> Taneb: No problem.
11:17:36 <Sonarpulse> I want to able to paremetize an existential type with anny additinal classes
11:17:54 <ij> Is data definition syntax special? Or is it a regular function that only does magical stuff?
11:18:34 <Sonarpulse> ^ Data constructors can be passed like functions
11:18:42 <Rarrikins> ij: It's special.
11:18:52 <Sonarpulse> @lambdabot map (:[]) [1..5]
11:18:52 <lambdabot> Unknown command, try @list
11:19:09 <Sonarpulse> lambdabot: map (:[]) [1..5]
11:19:10 <Rarrikins> > map (:[]) [1..5]
11:19:11 <lambdabot>   [[1],[2],[3],[4],[5]]
11:19:16 <geekosaur> did you want @run / "> " ?
11:19:35 <Sonarpulse> ....never used lambdabot much
11:19:37 <Sonarpulse> :)
11:20:00 <Sonarpulse> > map (:[]) [1..5]
11:20:02 <lambdabot>   [[1],[2],[3],[4],[5]]
11:20:05 <Sonarpulse> yay!
11:20:13 <Eduard_Munteanu> 20:58 < Sonarpulse> I also have type Exists (c :: * -> Constraint) = forall a. c a => Exists a    ?
11:20:40 <Sonarpulse> so that works for one clas
11:20:47 <ReinH> ij: data constructors are just functions, but Haskell has (at least) two levels: the value level and the type level.
11:21:00 <ReinH> :t fmap -- this is the type level
11:21:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:21:08 <Sonarpulse> but I need to be able to bundle multiple classes into one (* -> Constraint)
11:21:43 <Eduard_Munteanu> Sonarpulse: that declaration seems wrong, what exactly do you have?
11:22:28 <ReinH> ij: it is a bit confusing at times because [a] at the type level means [] a, which means "list of a", while [a] at the value level means "list containing a single a"
11:22:42 <Sonarpulse> Eduard_Munteanu: data Exists (clazz :: * -> Constraint) = forall a. clazz a => Exists a
11:22:44 <ReinH> ij: but as long as you don't mix the two levels up it's easier
11:22:54 <Sonarpulse> that is compiling already
11:22:56 <Eduard_Munteanu> Oh, I misread.
11:23:08 <Eduard_Munteanu> (or not)
11:23:10 <Sonarpulse> yeah
11:23:14 <Sonarpulse> I typed wrong before
11:23:21 <Sonarpulse> sorry
11:23:26 <ij> ReinH, Hmm, I seemed to be doing good with those.
11:23:33 <ReinH> ij: good :)
11:23:59 <ReinH> ij: as long as you know whether you're currently at the type level or the value level it shouldn't cause too much trouble
11:50:05 <Eduard_Munteanu> Sonarpulse: ok, check this out...
11:50:17 <Eduard_Munteanu> Sonarpulse: http://lpaste.net/93399
11:50:27 <Eduard_Munteanu> A rather big hammer. :)
11:54:48 <Eduard_Munteanu> There are simpler ways if you want to apply them one at a time, e.g. wrapping it in multiple exists layers.
11:57:41 <Eduard_Munteanu> Actually I think you should be able to make a  Constraint -> Constraint -> Constraint  combinator.
11:57:57 <Eduard_Munteanu> Erm, * -> Constraint.
12:00:00 <FreeFull> Eduard_Munteanu: I thought you couldn't have that sort of kind
12:04:38 <Lethalman> are there libraries for dealing with sets as in set theory? like infinite sets, union, membership etc.
12:04:58 <Lethalman> if that even makes sense
12:05:47 <FreeFull> Lethalman: I wouldn't be surprised if there were
12:07:30 <Lethalman> thinking of a set in the general case as a couple of functions, one for membership :: Set -> a -> Bool and one for enumerating :: Set -> [a]
12:07:51 <Lethalman> then various combinators to create Sets from other Sets such as union etc., that don't actually compute them but rather compose those sets
12:07:59 <joelteon> is it a bad idea to export my own (,)
12:08:00 <Lethalman> not sure if that makes sense, just brainstorming
12:08:25 <pqmodn> Lethalman: i don't know of one, but Data.Set has a nice API, it just doesn't deal with infinite sets
12:08:54 <Lethalman> pqmodn: Data.Set is another thing I guess
12:09:03 <Lethalman> it actually stores the data
12:09:07 <joelteon> oh, that's not even possible
12:09:45 <Lethalman> have to write something as a poc for fun :)
12:09:55 <pqmodn> yeah, it sounds kinda fun
12:10:36 <Lethalman> that is the union of two sets should be member set a = member set1 a || member set2 a
12:10:50 <Lethalman> enumerating is a simple nub of the concatenation
12:10:54 <Lethalman> and so on
12:11:09 <Lethalman> then for finite sets, there's Data.Set already
12:11:10 <FreeFull> Lethalman: It'd be interesting if you could get it to say that the integers and the rationals have the same cardinality
12:11:47 <Lethalman> FreeFull: no I don't think so ;)
12:12:08 <Lethalman> FreeFull: what's the cardinality of integers and rationals? infinite?
12:12:25 <FreeFull> Lethalman: There is a difference between infinities
12:12:30 <FreeFull> The set of reals is bigger than the set of integers
12:13:00 <pqmodn> e.g., there are infinitely many real values between the integers 0 and 1
12:13:32 <Lethalman> the point is that it's not possible to compute the cardinality of everything when you specify arbitrary membership and enumeration things
12:13:52 <nooodl> i don't think that's a good argument pqmodn
12:14:07 <pqmodn> neither do i :)
12:14:13 <FreeFull> On the other hand, there are mappings from integers to rationals and vice versa where every integer has a single, corresponding rational, and no rationals are left out or given multiple integers
12:14:34 <Lethalman> such sets I'm thinking of are good only at membership and enumerating.... cardinality is another beast
12:15:30 <kuznero> Hi All!
12:16:09 <edvo> The MonadPlus laws say that v >> mzero == mzero, but (lift (putStrLn "Hello World") >> mzero) /= mzero :: MaybeT IO ()
12:16:26 <edvo> or are IO effects a different story?
12:17:15 <Rarrikins> @hoogle mzero
12:17:15 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
12:17:33 <joelteon> how do you hyperlink to (,) in haddock?
12:17:35 <quchen> edvo: Some transformers don't obey the MonadPlus laws. mzero >>= _ = mzero is usually true, be careful with _ >> mzero.
12:18:02 <Rarrikins> edvo: I get "No instance for (MonadPlus IO) arising from a use of `mzero'"
12:18:06 <quchen> I don't remember the example, but I think there's something with State/Maybe that also doesn't obey the second law.
12:19:10 <edvo> Rarrikins: try "runMaybeT $ lift (putStrLn "Hello World") >> mzero" and "runMaybeT mzero"
12:19:38 <edvo> quchen: that might be the reason. I just found no mention of this in the docs
12:21:07 <Rarrikins> edvo: Ahh, I had it wrong.
12:21:11 <joelteon> what's the fixity of (,)?
12:21:52 <quchen> It's not an infix operator.
12:21:59 <geekosaur> I don't think it has fixity, it's actually syntax
12:22:24 <applicat1ve> but this means that it is very low, basically, no
12:22:30 <Rarrikins> It has the lowest precedence possible!
12:22:33 <applicat1ve> or high, I always get them mixed up
12:22:48 <Rarrikins> It gets done last, so low.
12:23:01 <applicat1ve> > (id $ 1 , id $ 3)
12:23:02 <lambdabot>   (1,3)
12:23:03 <quchen> (,) has the same "fixity" as if..then..else.
12:23:29 <applicat1ve> > if id $ True then 2 else 4
12:23:30 <lambdabot>   2
12:23:57 <Rarrikins> > 2, 4
12:23:58 <lambdabot>   <hint>:1:2: parse error on input `,'
12:24:22 <joelteon> okay, well, I'm exporting an operator and I want to figure out what fixity it should be
12:24:42 <joelteon> it constructs vectors
12:24:46 <FreeFull> > (,) 1 3
12:24:47 <lambdabot>   (1,3)
12:25:00 <joelteon> the ordered-pair variety of vector
12:25:41 <Rarrikins> You can put it just higher than ($).
12:25:48 <pqmodn> perhaps copy (:)'s fixity?
12:25:55 <FreeFull> (,) is infix
12:25:59 <FreeFull> I mean, prefix
12:26:06 <FreeFull> So it's just function application fixity
12:26:07 <joelteon> infixr 1 sounds probably good?
12:26:10 <Rarrikins> (,) is broken. It's not fixed.
12:26:35 <quchen> Why not call the function "pair" and leave it at that
12:26:54 <joelteon> `pair` is pretty long
12:27:04 <quchen> Enormously.
12:27:24 <mauke> (~>) = (,)
12:29:39 <joelteon> is it possible to document top-level declarations that are added by TH
12:36:46 <Umbrall> So has anyone made anything with functors on the category of functors?
12:37:26 <Umbrall> even having nothing to do with haskell
12:37:36 <Eduard_Munteanu> Umbrall: monad transformers?
12:38:04 <Umbrall> Well I guess they're kind of like that
12:38:09 <Umbrall> but they pretty much just have return
12:38:20 <LenGo> Hello, sorry for somewhat unrelated question: is there math trick to make from 0 an 1 and keep numbers the same if they're bigger than 0?
12:38:39 <Umbrall> \x -> if (x == 0) then 1 else x
12:38:57 <LenGo> Umbrall: Thats not a math trick, thats what i'm trying to avoid.
12:39:29 <Clint> what's a "math trick"
12:39:36 <LenGo> Clint: Formuale.
12:39:56 <Iceland_jack> Clint: Probably something with bit-wise operators or something like that
12:40:08 <Eduard_Munteanu> x + !x ?
12:40:27 <Eduard_Munteanu> Assuming C-like negation. :)
12:40:51 <LenGo> Eduard_Munteanu: Awesome, thanks.
12:41:00 <Eduard_Munteanu> x | (!x)  should do as well.
12:41:01 <applicat1ve> > let f 0 = 1; f x = x in map f [1,2,3,1,0,0,0]
12:41:02 <lambdabot>   [1,2,3,1,1,1,1]
12:41:03 <Rarrikins> > map (\x -> 0^x + x) [0..10]
12:41:04 <lambdabot>   [1,1,2,3,4,5,6,7,8,9,10]
12:41:13 <Rarrikins> Take that, Internet!
12:41:15 <Iceland_jack> Umbrall: What ever the trick you might find, you should probably stick with (\x -> if x == 0 then 1 else x)
12:42:29 <LenGo> Rarrikins: Ha-ha, nice.
12:42:30 <Iceland_jack> Sorry Umbrall, that was directed to LenGo
12:42:40 * Eduard_Munteanu wonders if C's inventors were constructivists in disguise given !!x isn't always x   :P
12:43:06 <joelteon> Eduard_Munteanu: !!x frequently isn't x, that's one of the best things about Ruby
12:43:10 <Cale> Umbrall: The Yoneda embedding is a functor into a category of functors.
12:43:12 <Iceland_jack> Eduard_Munteanu: I love when people ask me about the mysterious !! operator in C!
12:43:21 <Eduard_Munteanu> Heh, indeed.
12:45:54 <LenGo> Iceland_jack: No, i like math more than branching.
12:46:13 <ParahSai1in> @seen tekmo
12:46:13 <lambdabot> TEk/\/\o
12:46:24 <ParahSai1in> that was helpful
12:46:37 <geekosaur> can we get a patch to lambdabot that blocks @seen please
12:46:37 <applicat1ve> @leet Tekmo
12:46:37 <lambdabot> 73KMO
12:46:47 <Iceland_jack> LenGo: I don't see how you call that “math”
12:47:06 <geekosaur> or maybe we should just assume bot users cannot deal with edit distances and disable that
12:47:44 <applicat1ve> ParahSai1in: what, you cant follow Producer (Producer m (StateT (Producer a m ()) (Producer m ())
12:48:10 <ParahSai1in> lol, actually had a suggestion for his Pipes.Prelude
12:48:16 <applicat1ve> ah
12:48:54 <quchen> The funny math trick to do this is f(i) = (1-\delta_{0i})*i, where \delta is the Kronecker symbol. (It's not really funny by any stretch of the imagination.)
12:49:29 <applicative> ParahSailin he's around occasionally; you could put an issue on github?
12:50:35 <quchen> ParahSai1in: Or use @tell
12:51:14 <applicative> tell Tekmo: WE DEMAND "LEFTOVER SUPPORT"
12:51:29 <applicative> meatloaf especially
12:51:30 <ibotty> speaking of him... anyone know the status of pipes-text?
12:51:39 <Cale> Interesting, I didn't get a part message or nick change for LenGo, but he doesn't appear in my nick list anymore.
12:51:48 <applicative> ibotty: seems soon, bos was exporting something to make it simple
12:51:50 <ocharles> ibotty: i think we're waiting on some patches to text itself
12:51:55 <Clint> Cale: 19:46 -!- LenGo [~other@94.25.229.25] has left #haskell []
12:52:03 <Rarrikins> It was an empty part message
12:52:27 <applicative> it's childs play to write, all you need to do is cut and paste a couple internal modules of Text... ;)
12:52:36 <Rarrikins> .seen tekmo
12:52:41 <ocharles> applicative: well volunteered!
12:53:00 <applicative> i think bgamari was threatening it this time
12:53:01 <geekosaur> preflex: seen tekmo
12:53:02 <preflex>  tekmo was last seen on #haskell 2 days, 22 hours, 18 minutes and 36 seconds ago, saying: Just rest and try it again tomorrow
12:53:23 <applicative> see Tekmo is always very reasonable
12:53:51 <ibotty> thanks applicative and ocharles
12:55:13 * applicative is getting food poisoning from all the leftover support in conduit
12:56:06 <mm_freak_> pipes supports leftovers as well
12:56:17 <applicative> 'leftovers done right'
12:56:30 <ibotty> :D
12:56:45 <jacco_> can anybody tell me if this is a valid implementation of bind for the Cont monad? m >>= f = runCont m f
12:57:14 <ocharles> evenin' mm_freak_
12:57:22 <jacco_> since it is always explained as: c >>= f = Cont $ \k -> c (\a -> runCont (f a) k)
12:57:23 <applicative> @type let bind m f = runCont m f in bind
12:57:24 <lambdabot> Cont r a -> (a -> r) -> r
12:58:03 <applicative> @type let bind m f = (Cont (runCont m f)) in bind
12:58:04 <lambdabot>     Not in scope: data constructor `Cont'
12:58:04 <lambdabot>     Perhaps you meant one of these:
12:58:04 <lambdabot>       `Const' (imported from Control.Applicative),
12:58:11 <applicative> @type let bind m f = (cont (runCont m f)) in bind
12:58:11 <lambdabot> Cont ((a -> r) -> r) a1 -> (a1 -> (a -> r) -> r) -> Cont r a
12:59:00 <applicative> @pl bind c f = cont $ \k -> c (\a -> runCont (f a) k)
12:59:03 <lambdabot> bind = fix (const (((cont $) .) . (. (flip . (runCont .))) . (.)))
12:59:04 <lambdabot> optimization suspended, use @pl-resume to continue.
12:59:18 <Rarrikins> @pl Cont $ \k -> c (\a -> runCont (f a) k)
12:59:21 <lambdabot> Cont (c . flip (runCont . f))
12:59:21 <lambdabot> optimization suspended, use @pl-resume to continue.
12:59:26 <applicative> there we are
13:00:11 <applicative> i think that's the one i've ended up with, attempt to depointilize it
13:00:45 <jacco_> aha, I see why my implementation is invalid
13:02:23 <applicative> ooh check out this error building ghc head: libraries/hoopl/src/Compiler/Hoopl/Fuel.hs:77:10: Warning: ‛InfiniteFuelMonad’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal.
13:03:01 <FreeFull> InfiniteFulerMonad
13:03:03 <FreeFull> Weird name
13:03:19 <thoughtpolice> it makes more sense if you read the Hoopl paper
13:03:30 <thoughtpolice> also, yes, i need to fix some of the remainders of thos warnings but haven't gotten around to it yet
13:03:52 <applicative> whats wrong with the warnings?
13:04:24 <ocharles> applicative: awesome!
13:04:35 <applicative> looks like its really coming
13:04:44 * ocharles pinches himself
13:05:02 <ocharles> it's crazy how nice it will be to not write (Functor m, Applicative m, Monad m) =>
13:05:18 <ocharles> I guess you don't need Functor if you have Applicative
13:05:19 <ocharles> but whatever
13:06:01 <thoughtpolice> 1) they're annoying 2) i have to use a sledgehammer to make GHC properly ./validate because not all the libraries have been updated wrt the AMP propos applicative-Monad proposal
13:06:10 <applicative> it should be (Functor f, Applicative f, Monad m, f ~ m) =>
13:06:22 <thoughtpolice> gah, lag
13:06:29 <applicative> but i think ~ doesnt work that way...
13:06:54 <FreeFull> ocharles: You could always just use liftM and ap
13:07:06 <ocharles> FreeFull: i know
13:07:17 <applicative> thats what oleg does
13:07:37 <applicative> real men dont use <*>
13:07:39 <FreeFull> > (,) `liftM` [30,1] `ap` [42,12]
13:07:40 <lambdabot>   [(30,42),(30,12),(1,42),(1,12)]
13:07:46 <FreeFull> How beautiful
13:07:59 <ocharles> but that doesn't work if I have something operating on Applicative's and I only have Monad. now I have to WrapMonad and other nonsense
13:09:05 <dwcook> applicative, isn't ~ basically type variable equality? Why would you need that?
13:09:46 <applicative> dwcook: it was a joke, usually one uses m as a variable in a monad constraint, f for the others
13:10:04 <dwcook> Ah, okay :)
13:10:06 <ibotty> i'm looking into pipes-parse. is the so-called list-like approach (split/transform/join) taking care of leftovers?
13:10:24 <ocharles> ibotty: it's to allow us to operate on substreams without giving up streaming
13:11:26 <ocharles> ibotty: and to go further, it allows us to transform a continuous stream into substreams of a different type. for example, I can transform a single ByteString stream into a list of TarEntries in a .tar file
13:11:31 <ocharles> again, without giving up streaming
13:11:39 <ibotty> ehm. yes... obviously i did not ask the right question.
13:11:47 <ibotty> that is something i try to do right now
13:11:59 <ocharles> sure, tell me if i'm going to fast or miss your question
13:12:20 <ibotty> i don't want to wait for parse-text, so i want to write a text-pipe out of a bytestring-pipe
13:12:52 <ocharles> ibotty: what sort of data are you working with, and how much of it?
13:12:53 <ibotty> i don't need long text, only relatively short lines, so i wanted to just yield every line in a pupe
13:13:03 <ibotty> pipe, that is
13:13:07 <ibotty> :)
13:13:26 <ocharles> if you know you have a Producer ByteString that produces lines, you could Pipes.map Text.decodeUtf8, or something
13:13:40 <ocharles> bit you'd have to guarantee every ByteString is valid UTF-8, somehow
13:13:44 <ibotty> hehe. i am writing the lines-aspect and i am kind of stuck there
13:13:56 <ibotty> the rest is obvious
13:14:05 <ibotty> (well. now i like to think so)
13:14:54 <applicative> recent versions of the Free package mysterious lack iterT
13:14:58 <applicative> mysteriously
13:15:16 <ibotty> will concat (pipes.bytestream.split ...) work?
13:16:17 <ibotty> i am noticing now that my following approach was flawed anyway, so i might as well use that...
13:16:41 <applicative> ibotty: your original producer give bytestring chunks
13:16:42 <applicative> ?
13:16:45 <ibotty> yes
13:17:26 <applicative> i guess if yoiu trust the lines function in pipes-bytestring, you could decodeUtf8 after concatenating somehow
13:17:36 <applicative> obviously the breaks in the chunks will be a disaster otherwise
13:19:34 <applicative> hm, bos closed the issue bgamari raised.
13:21:38 <applicative> ibotty: be the first on your block to figure out how to use https://github.com/bos/text/blob/master/Data/Text/Encoding.hs#L218
13:21:58 <ocharles> applicative: they removed iterT?
13:22:26 <applicative> i couldn't figure it out, but was in despair on another point, and gave up thinking why
13:22:28 <ocharles> ibotty: what you probably want to do is parse the Producer ByteString into lines, and then for every layer in FreeT, concat into a single Producer, then concat the whole FreeT
13:22:47 <bgamari> applicative, Basic support for incremental UTF8 decoding was merged
13:22:55 <ocharles> I'm trying to find an iterT type thing for pipes-parse, that lets you only run the continuation to the next layer once
13:23:02 <ocharles> for pipes-tar*
13:23:05 <bgamari> now bos, Tekmo and I are trying to work out the right interface
13:23:13 <bgamari> the plumbing is finished though
13:23:23 <ocharles> because if a TarEntry has a Producer ByteString m (TarEntry m), then running that twice corrupts the stream
13:24:01 <applicative> ocharles: i see it in the most recent version now.
13:24:08 <ocharles> yea, I think you were just on the wrong version
13:24:23 <ibotty> ocharles: yes, that's what i tried the last minutes, but got stuck here:
13:24:24 <ibotty> P.toListM $  PP.concat (PB.split (fromIntegral $ ord ' ') (PB.fromHandle hIn))
13:24:37 <ibotty> that does not return anything sensible
13:25:06 <ibotty> PP is Pipes.Parse, P is Pipes.Prelude, PB is Pipes.ByteString
13:25:34 <applicative> ocharles i see, somehow i had an old version, not that old
13:25:43 <ocharles> oh hey, 'flip Pipes.for f' is a natural transformation I think
13:25:54 <ocharles> so you could use that with transFreeT
13:26:09 <applicative> in place of iterT?
13:26:10 <ocharles> hum, not really what you want though, you need to fold everything first
13:26:27 <ocharles> applicative: not for anything in particular, just an observation
13:27:17 <applicative> no, it just puts me in the confused state of mind I was in yesterday; i decided iterT was removed because anyone with sense would see that it flip hoist lift runAlgebra or something
13:27:23 <ibotty> well. i'll have to go. i'll get to it again tomorrow. thanks for your help :D
13:27:28 <ocharles> ibotty: hold on
13:27:46 <ibotty> yes...
13:27:48 <ibotty> :_
13:27:50 <ibotty> :)
13:28:15 <ocharles> ibotty: hand waving, you want something like PP.concat $ Free.transFreeT (Pipes.yield . Text.decodeUtf 8. Pipes.fold mappend mempty id) $ PB.split (fromIntegral $ ord '\n') (PB.fromHandle hIn)
13:28:35 <ocharles> I think that should give you a Producer Text, where every element produced is a line
13:28:50 <ocharles> though you give up (some) streaming here - loading entire lines into memory
13:29:07 <ibotty> that was expected...
13:29:16 <ocharles> gah, that function to transFreeT is not a natural transformation
13:29:19 <ibotty> (well i was expecting it as least)
13:29:20 <ocharles> I always do this >.<
13:29:58 <applicative> what you think 'Text.decodeUtf 8' spoils naturality ;) ?
13:29:59 <ocharles> pipes, y u no have a way to fold a producer AND get the return value!?
13:31:52 <ocharles> applicative: the naturality comes from the fact that you can't change the return type of the producer in the transformation
13:31:54 <applicative> you mean the value the whole producer folded over would return
13:31:58 <ocharles> si
13:32:26 <applicative> ocharles: there's always ... conduits ...
13:32:49 <ocharles> the transformation can be written, it's just annoying to write and you can't really do it point free
13:33:36 <identity> > all (const False) ""
13:33:37 <lambdabot>   True
13:33:40 <identity> ..
13:33:55 <pqmodn> identity: no elements were false, because there were no elements
13:35:02 <pqmodn> > any (const True) ""
13:35:03 <identity> pqmodn: I guess that way of reasoning works, but I'm basically reading it as "is the following condition true for all elements in the list?" in which case, no list, the answer should be False. In my mind, anyway
13:35:03 <lambdabot>   False
13:35:11 <Cale> > all undefined []
13:35:12 <lambdabot>   True
13:35:20 <Cale> > any undefined []
13:35:21 <lambdabot>   False
13:35:27 <applicative> oh i see yes, transFreeT does what I was imagining
13:35:55 <elliott> identity: think of it in terms of logic
13:36:29 <elliott> identity: all p xs is True if (forall (x in xs), p xs), False otherwise. any p xs is True if (exists (x in xs), p xs), False otherwise.
13:36:52 <applicative> bah. somehow i feel a dedicated type might help here.  I'm convinced now by the StateT (Producer a m r) m () ones
13:36:53 <identity> elliott: INdeed, I just went that way in my mind just now and I can see why
13:37:11 <elliott> then see http://en.wikipedia.org/wiki/Vacuous_truth -- all statements universally quantified over the empty set are true :)
13:37:22 <elliott> identity: you can also think of it in terms of identity elements
13:37:32 <applicative> there was a lot of blood shed historically over that question
13:37:37 <elliott> all p = foldr (\x b -> p x && b) True
13:37:44 <elliott> any p = foldr (\x b -> p x || b) False
13:37:57 <elliott> just like sum [] is 0 and product [] is 1, because those are the identities of the operations
13:38:37 <identity> elliott: Aaah. I hadn't read about vacuous truth before, but I like that.
13:38:38 <identity> thanks.
13:39:50 <elliott> identity: :)
13:40:00 <ocharles> to hammer that point home, the result of all and any on the empty list is the identity element for the monoid being used to fold
13:40:27 <dwcook> @type fold
13:40:29 <elliott> I think it's easier to see in terms of a foldr than a foldMap.
13:40:29 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:40:40 <elliott> well, even easier is
13:40:45 <elliott> all p = and . map p
13:40:48 <elliott> any p = or . map p
13:41:03 <elliott> and = foldr (&&) True; or = foldr (||) False -- True is identity for (&&), False is identity for (||)
13:41:59 <applicative> curses, thoughtpolice i blame you for this failed build! completely unjustly no doubt
13:42:37 <applicative> ooh wait it's a haddock error though
13:45:40 <dmwit> bgamari: ping
13:46:05 <identity> ocharles: Thanks for that tidbit as well. I looked up monoids and I can see how {True, False} with and/or form monoids with different identity elements
13:47:03 <levi> Yay, Monoids!
13:47:38 <peteretep> you're a monoid
13:47:56 <peteretep> I'm not sure what describing someone as a monoid means, but it sounds kinda mean
13:47:56 <noooooob> shit
13:48:02 <Clint> <>
13:48:19 <noooooob> any php dev here?
13:48:26 <noooooob> (dont flame im a haskeller too but i have to deal with this shit)
13:48:27 <hpc> the sequel to Colbert's autobiography, "I am a monoid and so can you"
13:48:34 <Dodek> noooooob: try #php
13:48:34 <dmwit> noooooob: Try ##php or something. This isn't the channel.
13:48:46 <noooooob> Its closed
13:48:48 <noooooob> I need an invite
13:48:55 <noooooob> Sorry.
13:48:58 <hpc> try -blah
13:48:59 <dmwit> That's not our problem.
13:48:59 <peteretep> noooooob: Bet #perl will help
13:49:12 <noooooob> thanks
13:49:14 <dmwit> Don't foist this off on #perl, it's not their problem either.
13:49:27 <Dodek> noooooob: #php is open for me.
13:49:33 <peteretep> They're basically the same language!
13:49:41 <elliott> peteretep: don't troll.
13:49:41 <hpc> you should foist it on #python
13:49:44 <Dodek> noooooob: you probably need to register yout nickname.
13:49:52 <elliott> sigh.
13:49:59 <ibotty> i'm just throwing thinks over the wall, but...
13:50:07 <ibotty> shouldn't the following work:
13:50:17 <elliott> noooooob: questions about how to join a channel are on-topic for #freenode.
13:50:25 <noooooob> I am sorry.
13:50:31 <ibotty> http://lpaste.net/1978311208402419712
13:50:45 <ibotty> textPipe :: Monad m => Pipe ByteString Text m r
13:51:16 <noooooob> BTW If I am here anyone knows of a 'counted' binary tree (or RB tree or whatever) implementation in Haskell?
13:51:28 <dmwit> I don't know much about pipes, but I would be surprised if "Some" was the only constructor for whatever type that is.
13:51:36 <ibotty> it is
13:51:37 <ibotty> :)
13:51:46 <dmwit> What a strange name, then.
13:52:01 <ibotty> it's from Data.Text.Encoding, the constructor of Decoding
13:52:14 <noooooob> dmwit: Today I told my friends there is a Maybe type in Haskell they thought I was joking
13:52:31 <ibotty> i was suprised as well
13:52:31 <noooooob> Strange is in the eye of the beholder I guess
13:52:56 <ibotty> data Decoding = Some Text ByteString (ByteString -> Decoding)
13:53:20 <ibotty> in a certain way Some is nice for continuations...
13:53:32 <ibotty> but so extremely non-specific...
13:54:44 <applicative> ibotty: is it that simple; what is the other field in Some ...
13:54:45 <applicative> hm
13:55:05 <ibotty> it's the rest of the bytestring (that was not decoded)
13:55:22 <ibotty> but that (seems) to also be stored in the state that is implicit in the continuation
13:55:34 <ibotty> at least there are two word32 in it.
13:55:50 <ibotty> the documentation does not even mention that parameter
13:56:00 <applicative> oh
13:56:07 <ibotty> https://github.com/bos/text/blob/master/Data/Text/Encoding.hs#L175
13:56:13 <ibotty> see: one parameter less
13:56:25 <applicative> 'Data.Text' -- now with *leftover support*
13:56:43 <ibotty> leftover support done wrong :D
13:56:46 <ibotty> hehe
13:56:49 <dmwit> Strange. I don't see Some or Decoding in the documentation for Data.Text.Encoding.
13:56:49 <ibotty> i'll file a bug
13:56:57 <ibotty> it's not yet released
13:57:26 <dmwit> I see.
13:57:32 <applicative> it seems the docs haven't caught up with this type
13:57:49 <applicative> dmwit: it's a change for the sake of Pipes.Text
13:58:53 <merijn> @remember BetaZiliani "We escape from monads in the same way that we escape from a building on fire: we run." (#ICFP2013)
13:58:53 <lambdabot> It is forever etched in my memory.
13:59:15 <applicative> but it looks like Some originaly was Some Text (ByteString -> DecoderState) or whatever; I guess the leftover bit of chunk was fused into the function so, to say, then he changed his mind?
13:59:40 <applicative> why did they say that merijn ?
14:00:32 <pqmodn> run, like a synonym for interpret?
14:00:34 <applicative> you can't escape the ambient monad
14:00:38 <applicative> hahah
14:00:41 <ibotty> maybe to know the last non-valid byte when no other package arrives. or to see whether there is still some undecoded part left...
14:01:25 <applicative> ibotty: well i suppose if you feed it bytestrings chunked small enough youll find out soon enough.
14:01:28 <merijn> pqmodn: like runStateT, runReaderT, etc. :p
14:01:41 <applicative> ibotty: preferably chinese
14:01:43 <pqmodn> merijn: hehe, a pun :)
14:02:02 <merijn> applicative: See my examples just now, that's why :p
14:02:17 <applicative> i get it yes
14:02:27 <dmwit> ?forget BetaZiliani "We escape from monads in the same way that we escape from a building on fire: we run." (#ICFP2013)
14:02:27 <lambdabot> Done.
14:02:38 <dmwit> ?remember BetaZiliani We escape from monads in the same way that we escape from a building on fire: we run. (#ICFP2013)
14:02:39 <lambdabot> Nice!
14:02:40 <applicative> we run [them]
14:02:53 <applicative> we run [sc. them]
14:03:14 <merijn> applicative: That ruins the wonderful ambiguity that makes it funny :)
14:03:16 <dmwit> "How do I escape from a building on fire?" "Run them."
14:04:07 <pqmodn> runBurningBuildingT
14:04:20 <applicative> yes
14:04:44 <argiopeweb> "Building Transformers Considered Harmful"
14:04:48 <applicative> dmwit: i was just trying to prove i got the joke, as i didn't the first time around.
14:05:08 <hpc> dmwit: run out of the building and then extinguish yourself
14:05:08 <dmwit> What does "sc." stand for? abbreviations.com has 11 pages of possibilities
14:05:16 <applicative> i figured it was a Scala ite or something
14:05:26 <applicative> scilicet = let it be known
14:05:41 <ibotty> applicative: well, i asked bos in the pull request. but i see the comments from him after he merged the pull request in https://github.com/bos/text/pull/55
14:05:41 <dmwit> hpc: cute =)
14:06:00 <hpc> alternatively, light yourself on fire and then run out of the building
14:06:08 <dmwit> hpc: I was just about to suggest that myself. =D
14:06:10 <pqmodn> ba dum psh!
14:06:36 <applicative> ibotty: it seemed he pulled then rewrote according to his ideas. maybe the haddocked paragraphs are from an in between state?
14:08:29 <ibotty> yes, they are. (git blame for the win!)
14:09:14 <applicative> oh i see your remark; well good luck with it ibotty !
14:10:04 <hpc> remember, commit early and often is only sound advice in programming
14:10:10 <hpc> in marriage there is no rollback, only blame
14:19:39 <ReinH> er
14:20:05 <donri> hpc: there's always bisect, though
14:20:10 * donri sinister laugh
14:20:29 <joelteon> but in marriage, checkout is rarely a good idea
14:21:36 <ReinH> it's not the branching that gets you: it's the merging.
14:23:43 <osfameron> in svn?
14:23:48 <osfameron> svn branching was easy!
14:40:25 <ihm1> does anyone still use haskellmode-vim? It seems it hasn't been updated for quite a while
14:41:40 <merijn> ihm1: There's someone working on an alternative and I (was) working on a lite identation plugin (which works decent enough, but there's plenty of room for polish if you're volunteering ;))
14:46:47 <ocharles> ihm1: what is haskellmode-vim? is it like vim2hs?
14:47:14 <merijn> ocharles: type lookup, auto-indent, hoogle, that type of stuff
14:47:16 <MedDev> how was i not aware of vim2hs
14:47:41 <ocharles> merijn: but doesn't vim2hs have that? :GhcModType, etc
14:47:47 <MedDev> i use haskellmode-vim and being able to see a type by typing _t is useful
14:48:20 <acomar> merijn: what's your alternative called?
14:48:30 <merijn> ocharles: That might be what vim2hs does, not sure what it does
14:48:58 <merijn> acomar: https://github.com/merijn/haskellFoldIndent but it only does indentation, atm
14:49:55 <merijn> acomar: There's 1 bug I'm aware of that I haven't had time to fix yet (let bindings inside where don't indent well), and in general there's just a lot of room for polish like smarter indent/dedent strategies
14:52:25 <acomar> merijn: cool, I'll check it out
14:53:11 <merijn> acomar: Feel free to submit any further patches ;)
14:53:37 <acomar> merijn: :) will do
14:54:04 <acomar> merijn: just need to find some time to spend on my editor again
14:54:15 <acomar> seems like I go through that cycle every couple of weeks, lol
14:54:32 <schoppenhauer> hello.
14:54:57 <schoppenhauer> https://github.com/dasuxullebt/inflate.hs <-- if anybody likes it, would be great to get comments from expierienced haskell-programmers!
14:55:54 <absence> http://lpaste.net/93405 <- trying the pipes-4.0 stack and have some trouble. shouldn't Pipes.Safe prevent problems like this?
14:57:09 <FreeFull> schoppenhauer: That's a lot of code for one module, splitting it into multiple modules might be good (depending on if it makes sense or not)
14:57:48 <schoppenhauer> FreeFull: it doesn't really make much sense, the parts of the standard are weaved together pretty tight
14:58:23 <FreeFull> schoppenhauer: I don't think your bang function actually does anything
14:59:01 <schoppenhauer> FreeFull: wah right ... dammit, this is an older source version I uploaded, wait ...
15:00:41 <schoppenhauer> FreeFull: ok, removed the bang-function. thx.
15:14:38 <donri> absence: what's pipes got to do with locks?
15:21:36 <merijn> absence: How would Pipes.Safe prevent that? Pipes.Safe does two things 1) ensure cleanup steps happen in case of exception (i.e. bracket/onException/etc.) and 2) prevent asynchronous exceptions from happening, unless the pipes is blocked in an await/yield (i.e. all other operations happen atomically w.r.t. async exceptions)
15:21:44 <ReinH> So my 20 year old graphics programming books are totally relevant again for roguelike terminal "graphics" :D
15:21:49 <ReinH> Line drawing, etc.
15:28:48 <james-ubc> hi guys - starting haskell again and I'm getting an error I cant quite figure out - looks like it should work http://pastebin.com/5at4Yra2
15:28:53 <mauke> The paste 5at4Yra2 has been copied to http://lpaste.net/93407
15:29:50 <MedDev> james-ubc, an error to go along with the snippet would be helpful
15:30:01 <james-ubc> parse error on input '='
15:30:41 <MedDev> james-ubc, the indentation looks funny
15:31:13 <MedDev> are you using spaces and not tabs?
15:31:32 <james-ubc> I'm using tabs
15:31:38 <MedDev> you need to use spaces in haskell
15:31:42 <james-ubc> god damn
15:31:44 <MedDev> hehe
15:31:45 <james-ubc> K thanks!
15:31:57 <james-ubc> just wasted an hour trying to figure out what was wrong
15:32:10 <MedDev> i did the same thing when i first started james-ubc. white space is significant in haskell
15:33:22 <absence> merijn: so it doesn't close the file when the pipeline breaks?
15:33:51 <merijn> absence: If you install a finalizer that closes the file, then it will
15:34:26 <merijn> absence: i.e. the withFile of Pipes.Safe should install a finalizer for that
15:34:52 <absence> so it's a bug?
15:35:18 <absence> assuming the lock error is due to the file being kept open
15:35:25 <merijn> absence: Not necessarily, I remember there was some odd behaviour if you opened a file for reading and it was already opened due to something else
15:35:38 <merijn> absence: No, keeping a file open doesn't produce lock errors
15:35:55 <merijn> absence: This is some locking done in the RTS, but I can't remember what and where
15:36:27 <absence> merijn: this is on windows btw
15:36:44 <absence> writing to open files work a lot better on unix than windows
15:41:01 <merijn> oh, on windows I don't dare guarantee anything
15:41:20 <ReinH> files work a lot better on unix full stop :p
16:09:56 <chaoslynx> is there a matrix library, whose matrices are easily marshalled to C and that is fast for small (4x4) and smaller matrices?
16:10:16 * bgamari wonders what dmwit wanted
16:11:01 <bgamari> Text's Decoder type has gone through a few iterations
16:11:10 <bgamari> and it will probably go through more
16:11:48 <bgamari> Changaco, hmatrix but it's not terribly well optimized for small matrices
16:11:50 <bergey> chaoslynx: I would use linear; I know it's being used for marshalling to OpenGL.
16:11:54 <bgamari> will probably be fine though
16:12:21 <bgamari> bergey, Are there Additive, etc. instances for Storable vectors?
16:12:47 * bgamari only sees instances for boxed vectors
16:13:27 <chaoslynx> bergey, that looks like what i was looking for
16:13:32 <chaoslynx> thanks
16:13:54 <bergey> bgamari: I don't know.
16:14:47 <bgamari> chaoslynx, I think you'll need to marshal the structures explicitly, however; I don't believe linear can use Storable Vectors
16:15:21 <bergey> Looks like there are Storable instances on V3, V4, etc.
16:15:34 <bgamari> ahh, true
16:18:39 <chaoslynx> does it still do the right thing for V4 (V4 a), if a is storable?
16:19:43 <ocharles> chaoslynx: V4 (V4 a) is in the wrong order for OpenGL, but otherwise works
16:20:01 <ocharles> distribute someMatrix can be sent to opengl just fine though
16:20:32 <ocharles> chaoslynx: see http://lpaste.net/6074507203195174912 for a fully working example
16:21:22 <chaoslynx> ocharles: thanks, i was looking for something like that
16:21:50 <ocharles> chaoslynx: one gotcha with linear - * does not do what you think
16:22:16 <ocharles> all too easy to type translation * rotation. you _mean_ translation !*! rotation
16:22:20 <ocharles> otherwise I love that library
16:24:09 * ocharles heads to bed
16:48:31 <fragamus> howdy
16:49:46 <fragamus> edwardk
16:56:27 <mangaba_leitosa> 'data T = T { field1:: Type1, field2:: Type }' automatically generates selector functions field1 and field2 that can be used as field1 (T x y) . Is there an extension to also generate update functions. e. g. update_field1 which would do (T x y) {field1=new_value} ?
16:57:18 <mangaba_leitosa> in order not to define manually functions like 'update_field1 record new_value = record {field1 = new_value}
16:57:35 <shachaf> mangaba_leitosa: No, but most lens libraries (such as "lens") have TH code for generating lenses, which you can update with.
16:58:28 <shachaf> E.g. with lens: data T = T { _field1 :: Type1, _field2 :: Type }; makeLenses ''T and then use "set field1 :: Type1 -> T -> T" or "over field1 :: (Type1 -> Type1) -> T -> T".
16:58:52 <mangaba_leitosa> shachaf: which lens library should I use if automatic update and select functions is the only functionality I need?
16:59:09 <shachaf> I'm partial to lens.
16:59:34 <mangaba_leitosa> shachaf: thanks!
16:59:49 <shachaf> But I'm biased.
17:00:51 <mangaba_leitosa> :-)
17:08:08 <mangaba_leitosa> shachaf: hmm, the lens package has about 25 dependencies... I'll try to check if there is something something less complex :-)
17:11:33 <mangaba_leitosa> aha, 'lenses' is much simpler
17:12:02 <shachaf> No, don't use that one. :-(
17:12:04 <shachaf> Try data-lens.
17:12:15 <shachaf> Or lens-family.
17:13:45 <mangaba_leitosa> ah, ok :-)
17:16:39 <mangaba_leitosa> shachaf: data-lens is described as Haskell 98 Lenses, will it work with GHC 'base' (not haskell98)?
17:16:47 <shachaf> Yes.
17:16:51 <mangaba_leitosa> aha, thanks
17:17:04 <shachaf> lens-family is compatible with "lens"; data-lens isn't.
17:17:43 <mangaba_leitosa> shachaf: and why not 'lenses', BTW?
17:17:58 <shachaf> I seem to remember that it used some horrible representation.
17:18:08 <mangaba_leitosa> aha
17:19:01 <skyflash> Anyone know any sample code that uses the ghc api to open a .hi file and parse it into a module definition for enumerating things like functions?
17:20:13 <geekosaur> looked at scion?
17:20:18 <enthropy> skyflash: ghci may be the smallest example?
17:20:59 <enthropy> haddock might be better or worse
17:21:43 <skyflash> hmm, OK I'll look at scion and ghci to see if I can find the relevant stuff.  Thanks.
17:23:18 <MedDev> hmmm is there some way I can zipWithIndex? I have two sequences where the result of the zipWith requires the index of the element i'm currently iterating over
17:23:53 <enthropy> you can zipWith3 f [0 .. ]
17:24:01 <MedDev> thank you :D
17:37:10 <ta479> why has no one tried GHC llvm -> emscripten -> javascript before?
17:37:35 <hpc> it's not that simple
17:37:49 <hpc> try mapping a socket library from FFI to javascript
17:45:17 <identity> What was the name of the library that really made parallelism in haskell a breeze again? Think it's by one of the simons
17:45:23 <identity> but can't recall the name
17:46:15 <Iceland_jack> identity: You can use the Par monad?
17:47:11 <identity> Iceland_jack: that's the one, yes
17:47:13 <identity> thanks!
17:56:42 <stolaruk> I recently finished LYAH and am working through RWH now. I'm trying to write a text adventure game, and I'm having a hard time figuring out how to handle state. I have a top level definition for a bag object, and the player can put an arbitrary object inside the bag. How can I make it so that the player can "put key in bag" and maintain the state of the bag containing the key?
17:57:44 <heatsink> You'd use some computational structure for that, probably a monad
17:58:03 <stolaruk> I was thinking about how to use the State monad for this...
17:58:18 <Iceland_jack> stolaruk: that sounds like a good use of the State monad
17:58:24 <heatsink> You would probably use a state-like monad, but not actually the state monad
17:58:30 <heatsink> because you would also want to do IO
17:58:53 <stolaruk> heatsink: Yes! I am in the IO monad and I was trying to figure out how to juggle the IO monad and the State monad
17:59:00 <Iceland_jack> stolaruk: Are you familiar with monad transformers?
17:59:06 <stolaruk> Iceland_jack: Vaguely
17:59:15 <Iceland_jack> Using monad transformers you can combine different monads
17:59:21 <stolaruk> ok
17:59:23 <Iceland_jack> in this case State and IO
17:59:50 <Iceland_jack> Something like: StateT Conf IO a
17:59:53 <stolaruk> Actually I'm already in a "InputT IO" monad due to the fact that I am using Haskeline library
17:59:57 <Iceland_jack> ah
18:00:28 <Iceland_jack> You can use the more general: MonadState Conf m ⇒ m a
18:00:43 <Iceland_jack> That way you can plug it into every level of the transformer stack
18:00:47 <stolaruk> Iceland_jack: Sorry, what is Conf?
18:01:05 <Iceland_jack> Any configuration data that you want to modify
18:01:14 <stolaruk> ok
18:01:26 <Iceland_jack> but then again if you're already in the IO monad you can alos use mutable references (for example IORef)
18:01:38 <stolaruk> interesting
18:01:50 <Iceland_jack> but using MonadState you can write your configration-changing code purely
18:02:04 <Iceland_jack> even though it's then run on top of the IO monad
18:02:15 <stolaruk> Iceland_jack: Would I be using MonadState inside the IO monad?
18:02:24 <heatsink> It's a good idea to use the MonadState class because it abstracts away from how the state is actually maintained.  You can use pure or impure state under the same interface.
18:02:52 <Iceland_jack> stolaruk: Yes and no, it depends on the monad stack
18:02:54 <stolaruk> heatsink: ok, cool
18:03:05 <Iceland_jack> Like heatsink said, it abstracts away from the stack
18:03:45 <stolaruk> Ok, I'll look into MonadState, thanks
18:06:11 <Ghoul_> anyone know the fastest way to calculate digits of pi lazily?
18:08:30 <ReinH> Ghoul_: fastest? it's almost certain that no one knows that.
18:09:20 <ReinH> @google Haskell calculate pi
18:09:21 <lambdabot> http://en.literateprograms.org/Pi_with_Machin's_formula_(Haskell)
18:09:21 <lambdabot> Title: Pi with Machin's formula (Haskell) - LiteratePrograms
18:10:27 <Rarrikins> http://www.haskell.org/haskellwiki/Shootout/Pidigits
18:11:59 <heatsink> Actually, how do programmers keep track of which side effects are permitted in which contexts in languages without monads or effect types?
18:12:26 <ReinH> heatsink: in meatspace
18:12:51 <ReinH> iow by *thinking really hard*
18:13:01 <Ghoul_> well, maybe someone has used Chudnovsky’s formula in haskell
18:13:08 <ReinH> Ghoul_: you could :)
18:13:16 <Ghoul_> far too complex for me :P
18:14:43 <Makoryu> heatsink: The whole novelty of Haskell is that it allows this to be done at all
18:15:08 <jmcarthur> heatsink: good ones don't. they just assume side effects could be anywhere, but introduce side effects as little as possible
18:15:11 <Makoryu> (Well that and the details of the typeclass system)
18:15:28 <ReinH> If I have a vector-based data type like data Grid a = Grid { _cells :: Vector a }, is there an easy way to generalize that so I can use boxed or unboxed grids at will?
18:15:40 <ReinH> er, let's say Array instead of Vector now since that's what it actually is
18:16:39 <heatsink> Huh.  The side effect management problem is so common, I thought there would be more of a solution than that.
18:17:01 <ReinH> heatsink: there is. It's "ignore it". ;)
18:17:06 <heatsink> heh
18:18:12 <rhodesd> I've seen murmoring of effects systems,  rust was going to implement one IIRC, but ended up trashing it for some reason.
18:18:33 <ReinH> rhodesd: because they have to way to enforce it?
18:18:38 <ReinH> *no
18:19:00 <rhodesd> http://smallcultfollowing.com/babysteps/blog/2012/05/29/simple-effect-system/
18:19:13 <rhodesd> I'm really not sure about the details ReinH
18:30:44 <mangaba_leitosa> shachaf: I installed lens and tried the set/view field_name approach as you showed. It works for 'data Row = R { _field1:: Int, _field2:: Int }', but not for 'R { _field1:: Int, _field2:: Int } | R2 { _field3:: Int, _field4:: Int }'. Is there an easy fix?
18:31:32 <mangaba_leitosa> shachaf: that is, as soon as I add one more constructor, view field1 stops working and gives type error
18:36:47 <Ghoul_> hmm, I can't seem to convert a Double to an Int
18:37:00 <Makoryu> By what means
18:37:12 <Ghoul_> I can't find anything that gives (Real a, Integral b) => a -> b
18:37:22 <Makoryu> Or can you
18:37:26 <Makoryu> :t round
18:37:27 <lambdabot> (Integral b, RealFrac a) => a -> b
18:37:58 <Ghoul_> makes sense I guess.
18:38:23 <Makoryu> Also
18:38:25 <Makoryu> :t floor
18:38:26 <lambdabot> (Integral b, RealFrac a) => a -> b
18:38:27 <Makoryu> :t ceiling
18:38:28 <lambdabot> (Integral b, RealFrac a) => a -> b
18:41:57 <applicative> ReinH: to make your type okay for unboxed vector and 'regular' vector you will need to use the type family in some unpleasant way; data X v a = X {getX :: G.Vector v a} or something like that
18:42:29 <Ghoul_> ugh, I hate numerical stuff in haskell
18:42:33 <Ghoul_> the type safety sends me through hell
18:43:11 <byorgey> Ghoul_: just imagine trying to do numerical stuff *without* type safety!
18:43:36 <Ghoul_> yeah, it would be easier.
18:43:54 <Makoryu> instance Num String where ...
18:44:06 <Ghoul_> it's getting all shitty at me for having doubles and ints in the same room
18:44:20 <Rarrikins> Makoryu: "hello"*"goodbye"
18:45:22 <khyperia> If I want to use llvm in haskell, which package should I use? There's quite a few packages with llvm in their name.
18:45:34 <copumpkin> :O
18:45:56 <applicative> khyperia: what do you mean you want to use it?
18:45:57 <luite> Makoryu: http://hackage.haskell.org/packages/archive/acme-php/0.0.3/doc/html/src/Prelude-PHP.html#line-37
18:45:59 <Cale> Ghoul_: Well, you just have to convert the Int values to Doubles, or do something to round the Doubles to turn them into Ints
18:46:16 <khyperia> I want to make a compiler, so compiling code.
18:46:18 * applicative feigns to know his llvm backwards and forwards'
18:46:21 <applicative> ah
18:46:35 <khyperia> err, "compiling code" as in "compiling llvm... stuff"
18:46:38 <Cale> Ghoul_: So likely one or more of fromIntegral, round, floor, or ceiling is the right thing.
18:46:53 <khyperia> ... I'm not very good at phrasing.
18:47:23 <applicative> khyperia: see what idris is importing
18:48:06 <khyperia> idris does not depend on anything with llvm in its name
18:48:10 <applicative> does so
18:48:13 <khyperia> at least hackage says so
18:48:17 <khyperia> http://hackage.haskell.org/package/idris
18:48:56 <applicative> khyperia: i'm getting contradictory evidences just a sec
18:49:09 <applicative> khyperia: i just mentioned because they keep frettying about it
18:49:29 <Makoryu> luite: I prefer to interpret a string as a base 64 numeral....
18:50:37 <khyperia> I *think* it's llvm-general that I want, but I'm not sure.
18:51:47 <applicative> khyperia: it not showing up because its behind a condition , see https://github.com/edwinb/Idris-dev/blob/master/idris.cabal at the bottom
18:52:35 <khyperia> ah, so llvm-general[-pure]... what's the difference between pure and non-pure? I have no idea.
18:52:45 <applicative> khyperia: and here some code https://github.com/edwinb/Idris-dev/blob/master/src/IRTS/CodegenLLVM.hs
18:53:14 <dalaing> khyperia: here's a discussion of llvm-general, including llvm-general vs llvm-general-pure -> http://llvmtrip.wordpress.com/
18:53:22 <khyperia> thanks
18:54:00 <applicative> Ralith was working on it in connection with idris, he may know some wisdoms if you bump into him here or in #idris
18:54:26 <dalaing> I can't remember whether llvm-general was the one carter was talking about, for some reason I was remembering it as llvm-pretty
18:54:46 * Ralith is summoned
18:54:55 <Ralith> if you are doing llvm things, use llvm-general
18:55:24 <khyperia> alright, thanks for the help!
18:55:31 <Ralith> #haskell-llvm is a good place to hang out
18:55:40 <khyperia> ooh, didn't know about that
18:56:43 <applicative> oh there you are, theres a #haskell-llvm
18:57:27 * applicative looks into #haskell-leftover-support
18:58:13 <Ralith> dalaing: note that llvm-general has a stable release for the last few llvm releases, and llvm-general master on github roughly tracks llvm svn
18:58:42 <MedDev> is there any way to make the length of the result of a zipWith less than the smallest length of one of the input lists?
18:59:14 <MedDev> or should i just use a fold to accumulate values at that point?
18:59:17 <Ralith> dalaing: and one generally shouldn't use llvm svn on principle of stability :P
19:01:37 <Ralith> dalaing: also, llvm-general has extensive FFI functionality, which is a good thing because that is how you access many major features of LLVM.
19:02:06 <applicative> MedVed, i'm not sure i'm following, it sounds like a scan.
19:02:10 <Ralith> dalaing: no external LLVM tools are ever involved...
19:02:18 <applicative> which gives the results of the fold at each point
19:02:27 <applicative> MedDev: to put it crudely
19:02:33 <dalaing> sounds pretty hardcore
19:02:37 <dalaing> by which I mean great
19:03:04 <MedDev> applicative, ok thanks :)
19:03:16 <Ralith> dalaing: your post misrepresents this.
19:03:34 <Ralith> dalaing: also, you should absolutely not be advising people to use cabal install --global
19:03:49 <dalaing> Ralith: ah, not my post, just the first thing I found while trying to track down info on which of the llvm packages was the one to use
19:03:53 <Ralith> oh, okay
19:03:55 <Ralith> sorry for the berating then
19:04:13 * applicative was using cabal install --global for the first time just today
19:04:32 <dalaing> I was wondering why I was getting all that useful info directed directly at me :)
19:05:29 <Ralith> ^^
19:12:54 <Ralith> is there a good writeup of why not to use --global anywhere?
19:13:53 <applicative> not that i know of; there is monochroms attack on using your package manager for too much, which i guess is similar
19:14:31 <applicative> Ralith: it turns out with the new sandboxing, it was (I think) prudent to put a few things in global that i didn't have
19:14:59 <applicative> basically it was a matter of replicating chunks of the haskell platform, which i haven't been using
19:15:43 <applicative> if i don't do this, i end up rebuilding text and vector and the kingdom of edwardk in every sandbox. i left it at rebuilding the kingdom of edwardk
19:15:58 <applicative> since it changes every five minutes anyway
19:17:17 <applicative> what really pisses me off is rebuilding criterion for every sandbox
19:17:20 <Makoryu> I thought Haskell was a republic
19:17:25 <Makoryu> What's this kingdom doing here
19:17:27 <applicative> but i'm presumably missing somethign
19:17:30 <Makoryu> Who put that there
19:17:49 <applicative> okay, the republic of edwardk?
19:18:02 <Ralith> no, it's definitely a kingdom
19:18:02 <Makoryu> I'm just messing around
19:18:04 <Makoryu> Sorry go on
19:18:30 <applicative> no, just justifying my use of cabal install --global to Ralith, though I'm not sure my grounds are good
19:18:51 <Ralith> applicative: I'm not questioning yours; this post was just using it for everything.
19:19:24 <applicative> i see
19:20:54 <Ralith> applicative: I generally assume if a haskell regular is doing something, and exercising selectivity at that, they've got some idea what's going on ^^
19:21:02 <Ralith> honestly sounds like you understand the issues better than me anyway
19:23:10 <applicative> yeah i used to try to get as much locally as possible, so i had convenient control and could debug disaster, but the sandbox skips ~/.cabal, which is basically another sandbox to it, i guess you could say. there's another model one should be using, that i dont quite get yet
19:27:27 <shachaf> mangaba_leitosa: That's because it can crash.
19:27:33 <shachaf> mangaba_leitosa: Try "preview" rather than "view".
19:28:37 <shachaf> mangaba_leitosa: (And "gives a type error" isn't very helpful when you're asking a question. Make people's lives easy when you ask a question like that!)
19:29:12 <shachaf> mangaba_leitosa: I mean, the accessor "field1" as generated by GHC could crash. It's partial.
19:29:13 * spaceships <3 cabal repl
19:31:39 <applicative> spaceships: yes, it such a relief
19:53:21 <zugz> @pl (\x y -> f $ g x y)
19:53:21 <lambdabot> (f .) . g
19:56:22 <zRecursive> After @pl, code becomes VERY ugly
19:58:00 <haasn> f .: g -- if you live in a universe where .: exists
19:58:09 <haasn> or \x -> f . g x
19:58:16 <haasn> or fmap fmap fmap f g -- but don't actaully
20:02:20 <pqmodn> :t (.::::)
20:02:20 <lambdabot> Not in scope: `.::::'
20:07:06 <zugz> (f.).g isn't so ugly... makes sense if you think about it
20:07:46 <zugz> @pl (\x y z -> f $ g x y z)
20:07:49 <lambdabot> (((f $) .) .) . g
20:07:50 <lambdabot> optimization suspended, use @pl-resume to continue.
20:08:04 <zugz> @pl-resume
20:08:10 <lambdabot> (((f $) .) .) . g
20:08:10 <lambdabot> optimization suspended, use @pl-resume to continue.
20:08:22 <zugz> that's less pleasant.
20:09:16 <acomar> so if I want a class constraint on a type variable in a data declaration, I need to upgrade to GADTs?
20:09:31 <acomar> I've never actually used a GADT, any gotchas I should be aware of?
20:09:53 <heatsink> Only if it's an existential type variable
20:09:54 <pqmodn> zugz: i just found Data.Composition which has .:. for that (and eight others)
20:10:29 <acomar> (I need to constrain the type variable to have a Num instance)
20:11:09 <heatsink> There is really no reason to constrain type parameters
20:11:20 <acomar> hmm?
20:11:27 <zugz> pqmodn: ok, though it's actually just ((f.).).g, not sure why pl got confused
20:11:55 <heatsink> the constraint will occur in any code that relies on the Num instance
20:12:19 <heatsink> Adding the constraint to the data type doesn't change its behavior
20:13:52 <pqmodn> acomar: i can't answer your question, but an example of what heatsink is saying is the Data.Map or Data.Set type which have Ord constraints on most functions that use a Map or Set (rather than on the constructors)
20:14:17 <acomar> heatsink: hmm... the problem is that this type is the haskell-marshalled side of an FFI type... nonsensical data would cause runtime errors
20:14:27 <acomar> I guess I could just hide the constructor?
20:15:01 <pqmodn> yep, and export a function that has a class constraint which uses the constructor for you. (eg Map.fromList)
20:15:02 <heatsink> Foreign data is usually monomorphic, or just a pointer
20:15:33 <heatsink> So I don't know what kind of foreign data would be polymoprhic and need a Num constraint
20:15:34 <acomar> yea, except I'm wrapping a C++ class through C wrappers :/
20:15:55 <acomar> the class itself isn't templated but a few of its methods are
20:16:15 <acomar> it's a Matrix with polymorphic element access
20:16:44 <heatsink> The thing is that Haskell classes are resolved dynamically, but template classes are resolved statically
20:16:56 <acomar> having 10 different functions that do the same thing isn't really ideal, and I don't have a way to know until runtime what the type of any given matrix element type is
20:17:01 <heatsink> so you can't make a Num constraint available to the C++ side in the form of ovrerloaded numeric operations
20:17:07 <acomar> right, I don't plan on that
20:17:24 <acomar> I just need a way to track the element type
20:18:02 <acomar> as long as the matrix is constructed through haskell, I can track the element type properly
20:18:18 <acomar> and provide element-wise accessors
20:18:58 <acomar> so this is where things blow up if someone tries to construct a matrix on the haskell side with nonsensical data types
20:19:19 <heatsink> It sounds like a hidden constructor is what you want
20:19:32 <acomar> yea, that about solves my problem
20:22:01 <tolt> Does anyone know of a haskell project that I could help work on that's open source?
20:22:08 <tolt> Or anything that needs improvement
20:22:25 <acomar> I would love some help with my OpenCV wrapper library :)
20:22:44 <acomar>  /kidding, it's not anywhere near ready for release :/
20:23:32 <tolt> I've written two OpenCV wrappers :( not again.
20:23:40 <acomar> o.O really?
20:23:56 <tolt> Well, not in Haskell. C and redone in C
20:24:15 <acomar> hah, part of this job is writing a C binding to the library
20:24:44 <tolt> Huh. Do you have it on a repo anywhere?
20:24:46 <acomar> I'm automatically generating them by reading the header files and spitting out wrapped functions
20:24:47 <acomar> yea
20:24:58 <acomar> www.github.com/arjuncomar/revelation
20:25:00 <tolt> Link me? I'd atleast like to look at it
20:25:14 <acomar> the c wrappers are under cbits
20:25:32 <acomar> the bulk of it is under opencv_generated.hpp/cpp
20:25:51 <acomar> with some stuff my header parser missed in the other headers
20:25:59 <tolt> Alright. I'll look at it. I've wanted to get involved with working on something lately...
20:26:23 <acomar> I don't claim those are *usable* c wrappers by any means, but they're about sufficient to start wrapping the library in Haskell
20:27:16 <acomar> I was planning on writing up a post and asking for help once I'd gotten to a semi-usable state
20:27:38 <acomar> I'm kinda there, but there are still some important types missing (Mat, Point, etc.)
20:29:05 <tolt> Alright. I'm starting to look at it
20:29:09 <tolt> It looks pretty interesting.
20:29:53 <tolt> Uh oh. I don't know any python.
20:30:04 <acomar> nah, that part is pretty squared away
20:30:18 <acomar> it's just reading the headers, and spitting out C/.hsc files
20:30:19 <tolt> Alright
20:30:51 <acomar> we got lucky and found out that the python bindings are automatically generated by parsing the headers
20:31:07 <acomar> so I grabbed that header parser and worked from it, so I was stuck in python for that part
20:33:43 <heatsink> Oh, so it's now a multi-language binding generator
20:33:47 <heatsink> nifty
20:36:00 <enthropy> acomar: there are at least two other opencv bindings
20:36:10 <enthropy> hopefully yours is more complete / less buggy
20:38:42 <acomar> enthropy: yep, that's the idea
20:38:57 <acomar> I'm actually working with the main developer of the CV library
20:39:16 <acomar> everyone who's tried so far has hit a bit of a wall because of the increasingly C++ nature of the library
20:41:22 <acomar> heatsink: yeap. Maybe I should throw in some Java and Ruby just for kicks. Why not, right?
21:01:00 <jfischoff> in general what do people do when they need a data type to have an Eq instance but it has function as member?
21:02:15 <heatsink> Add some additional value as a proxy for the function that you can test for equality
21:02:31 <startling> jfischoff, use something other than a function
21:02:46 <pavonia> you could also write the Eq instance by hand
21:03:19 <startling> if it's, like, Bool -> a you can do it easily.
21:03:32 <jfischoff> right
21:04:19 <startling> jfischoff, what kind of code is it?
21:04:57 <jfischoff> @hpaste
21:04:57 <lambdabot> Haskell pastebin: http://lpaste.net/
21:05:37 <jfischoff> http://lpaste.net/93410
21:05:46 <jfischoff> its like a applicative with a cache
21:06:03 <jfischoff> AVar definition is not too important
21:09:18 <jfischoff> there is really no good way
21:09:58 <startling> I don't see one either. Why do you need Eq?
21:10:46 <jfischoff> I'm sure I need it. I want to create a Set of existentially quantified Expr's
21:10:54 <jfischoff> err not sure I need it
21:11:10 <jfischoff> I'm going to just punt on that for now
21:11:54 <acomar> written out this way, what would it even mean for two 'Expr a's to be equal?
21:12:11 <jfischoff> I have no idea
21:12:58 <jfischoff> part of me just wanted to make use unsafePerformIO and Data.Unique every time I made one
21:13:04 <startling> jfischoff, you can probably write a "quote" function
21:13:41 <elliott> jfischoff: sounds like you want observable sharing or something.
21:13:47 <elliott> maybe.
21:14:19 <acomar> jfischoff: can you evaluate the Expr down to something more concrete, and worry about equality on that? Or is that too inefficient/wasteful?
21:14:25 <jfischoff> I was more curious about what silly things people try when desperate
21:14:47 <jfischoff> I think that really having a Eq instance is an optimization
21:14:55 <jfischoff> I'm not going to worry about it
21:14:59 <acomar> fair enough
21:15:31 <sordina> Hi haskellers :)
21:15:34 <startling> jfischoff, there's http://hackage.haskell.org/package/enumerable ιφ υοθῤε λοοκινγ φορ σιλλυ τηινγσ
21:15:37 <startling> uh
21:15:39 <jfischoff> it won't change the correctness, and maybe something like Data.Reify can speed it up, or using Data.Unique somehow
21:15:49 <startling> *if you're looking for silly things
21:16:05 <jfischoff> heh
21:16:37 <jfischoff> I was wondering if anyone had tried that
21:17:14 <sordina> Has anyone heard of an attempt to build a practical computer, or vm without bytes?
21:25:49 <spaceships> what does that mean "without bytes"?
21:31:55 <sellout-> sordina: The number of bits in a byte has varied, if that’s what you mean. 8 bits is just what everyone sort of ended up agreeing on.
21:32:27 <Pete_> Hi!
21:35:02 <paul__> hey, would it be alright if I ran a quick question by you guys?
21:35:07 <startling> Of course.
21:35:39 <paul__> thanks! So I'm just starting out, and I'm trying to wrap my head around typeclasses/instances of those typeclasses.
21:36:23 <paul__> As far as I understand, typeclasses are a sort of interface/contract which just dictate the functions which an instance must define, and possibly some constraints regarding those functions
21:36:34 <acomar> are Num instances for matrices kosher?
21:36:39 <acomar> (/) would have to use multiplication by a right inverse (which I think always exists?)
21:36:52 <paul__> (as well as the signature)
21:37:07 <Rarrikins> acomar: If you include the size in the type and they're square matrices.
21:37:08 <startling> acomar, right inverses only exist for matrices with determinant 0
21:37:28 <acomar> rarrikins: size will be in the type, but I'm wondering about general matrices
21:37:40 <acomar> obviously true inverses don't exist
21:37:52 <startling> oh, I think I'm wrong.
21:37:53 <acomar> but I *think* you always have pseudo-inverses (they're just not unique)
21:38:19 <acomar> the right inverse should be exactly the true inverse for square matrices of non-zero determinant
21:38:34 <acomar> if my memory of linear algebra isn't screwed up
21:38:35 <Rarrikins> acomar: For nonsquare, addition will be fine, but you'll have trouble with multiplication, since the type is a -> a -> a and the types will differ unless thoy're square.
21:38:44 <sordina> sellout-: That's not quite what I mean. I'm trying to find an example of an architecture that has no inherrent notion of byte-size.
21:38:46 <acomar> Rarrikins: ahh, right
21:38:52 <acomar> I forgot about that issue
21:39:15 <startling> sordina, well, there's lambda calculus
21:39:33 <Rarrikins> paul__: That's right.
21:39:47 <sordina> startling: Yes, there's the turing machine and lambda calculus, but that's why I added "practical" to the question.
21:40:15 <startling> sordina, well, what does "practical" mean? People have written C to brainfuck compilers.
21:40:43 <acomar> sordina: people built actual lisp machines
21:41:09 <startling> acomar, I think lisp machines have words
21:41:20 <acomar> startling: necessarily so?
21:41:32 <startling> I don't know.
21:41:37 <acomar> I don't either :)
21:41:56 <paul__> Awesome! So the problem I'm running into is that I'm defining a class Sequence s, which defines a toList function (of type s -> List b). In my instance declaration, I'm defining a trivial instance of Sequence (via "instance Sequence (List a)") with a few function definitions:
21:42:00 <sordina> startling: That's a good question. I think practicality is pretty subjective and nuanced, but there are certainly high-water marks that everyone could agree are "practical".
21:42:32 <acomar> sordina: you're in #haskell, definitions of practicality vary greatly :)
21:42:39 <sordina> acomar: lol
21:42:50 <paul__> when I define toList Nil = Nil, there's no problem, presumably because there are no types to even matter (since in my data declaration for List,  "List a = Nil | a :- (List a)")
21:43:13 <paul__> (with ":-" as an infix-defined operator)
21:44:12 <startling> paul__, I suspect you wrote a type slightly wrong, but http://lpaste.net/ your code
21:44:12 <paul__> however, when I say "toList (x :- y) = (x :- y), I get the type error that "a" and "b" could not match (with a being from my instance declaration, and b being from the toList type signature)
21:44:30 <paul__> Ahh, will do (sorry about the walls of text :/ )
21:45:01 <startling> paul__: (you should also know that there's already a toList-y class -- it's Foldable in Data.Foldable in base)
21:45:44 <startling> sordina, it strikes me that you might be really asking about unbounded integers
21:46:20 <paul__> http://lpaste.net/93411
21:46:31 <sordina> startling: I can see the connection, but my motivation is purely historical curiosity.
21:46:48 <startling> paul__, aha. you probably want line 6 to say "s a -> List a"
21:46:52 <paul__> startling: I know there is a foldable class, this was just an exercise to try to make sure that I understand typeclasses decently enough
21:48:32 <paul__> startling: aha, that seems to help, though it does mention that I need to enable the environment option for multiple param typeclasses. Is that a standard option to include?
21:48:44 <startling> paul__: as your code stands, toList :: List a -> List b -- that b is "any b", and the only value that can be of type List b for any b is Nil
21:49:01 <startling> paul__, you shouldn't have changed line 5
21:51:39 <startling> paul__, to be clear, you want "class Sequence s where toList :: s a -> List a"
21:51:55 <paul__> startling: ah, my mistake, that explains the compiler issue. However, now I'm getting a warning about the kind of the "instance Sequence (List a)"
21:52:07 <paul__> err, type checking issue
21:52:15 <startling> paul__, aha. You want that to be an "instance Sequence List"
21:52:41 <acomar> hmm... so I'm starting to realize that I'm quite truly stuck in IO for most of this library. I can't unsafePerformIO my way out because that would give the wrong semantics...
21:53:11 <startling> acomar: what's your goal?
21:53:25 <acomar> startling: I'm working on an OpenCV 2 wrapper
21:53:59 <acomar> most functions are well and truly in IO, and not safe to escape out
21:54:07 <paul__> startling: Thanks so much, that got it working! If I may ask, why is it that "List" is sufficient, when the data type is "List a"?
21:54:23 <startling> acomar, one thing you can do is newtype CV a = CV { runCV :: IO a }
21:54:29 <acomar> the interface I intended to provide was via pipes... I might just need to stick to that more thoroughly
21:54:38 <acomar> startling: yea, I definitely plan to do that
21:54:42 <paul__> or does the s just work as a partially applied data constructor?
21:54:55 <startling> paul__, Sequence is a class for types of kind * -> *
21:55:15 <startling> paul__, List has kind * -> *. List a has kind *.
21:55:28 <acomar> I was just hoping to provide an intermediary API that you can write code against, but it looks like even that is stuck in IO
21:55:53 <paul__> startling: Which we know because the end result has to be a concrete type, and in order for s b ->  *, s has to be of form (* -> *)?
21:56:10 <startling> paul__: something like that, yeah.
21:56:30 <paul__> startling: Thanks so much, I really appreciate the help!
21:57:15 <startling> paul__: there's an extension called KindSignatures that lets you write this explicitly, but it's inferred in ordinary Haskell.
21:57:44 <haasn> Does distributed-process have an InfiniBand backend?
21:57:49 <haasn> transfer layer*
21:58:06 <paul__> startling: To manually write the kinds of a function's signature? That sounds very cool, I'll have to check it out, thanks!
21:58:16 <startling> paul__: i.e., you could write "class Sequence (s :: * -> *) where toList :: s a -> List a"
21:58:59 <paul__> startling: My god, that would be beautiful
21:59:38 <startling> paul__: :)
23:02:28 <shachaf> Hmm, Fix is a functor from the category of functors to Hask, right?
23:07:43 <sclv> category of things of kind *->*
23:09:39 <sclv> i guess you need functors tho to talk about arrows
23:09:50 <sclv> since you want to take type constructors to types and natural transformations to arrows
23:12:27 <Taneb> Can anyone help me install the gtk bindings on my RPi?
23:12:40 <Taneb> Don't worry, it's not the normal gtk problems, it's memory issues
23:16:14 <ReinH> Taneb: hah, I was about to say... gtk is bad enough on "normal" hardware...
23:16:44 <startling> Taneb, swap?
23:17:29 <startling> oh, /installing/ encounters memory issues?
23:17:45 <Taneb> My two options are: going past Cabal and compiling it carefully by hand, or compiling it on my main PC in a thingy-virtualbox-thingy
23:17:53 <Taneb> startling, yeah
23:18:05 <startling> can GHC cross-compile libraries?
23:19:01 <Taneb> startling, yes but it's a lot of work
23:20:18 <ReinH> Is there a way to do this without the case statement aside from a second pattern match binding?
23:20:21 <ReinH>   end    = case abs (c - c') of (V2 dx dy) -> max dx dy
23:20:47 <ReinH> Taneb: step 1, cut a hole in the virtualbox
23:21:57 <Taneb> Actually I've just spotted a workaround
23:23:05 <Taneb> Reducing it to a stupid dependency problem
23:24:09 <Taneb> Thanks anyway, though :)
23:24:46 <Taneb> Oh god the easiest way out of this is thrusting myself head first into cabal hell
23:25:37 <Taneb> One last thought
23:26:59 <dpwright> Hey, I've asked this before, and I think the answer was something like applicative, but I can't remember
23:27:50 <dpwright> I quite often end up writing functions like this: "\a b -> something a $ somethingElse a b" / "\a -> something a . somethingElse a"
23:28:27 <dpwright> the latter being an eta-reduction of the former to remove the b variable (unless I mistyped it just then)
23:28:44 <dpwright> so I'm using "a" in both those function calls
23:29:13 <dpwright> I'm wondering if there's some (non-horrible) way to compose them so that I can remove the a variable
23:29:45 <Taneb> :t \a b -> (!!) "Hello" $ (+) a b
23:29:46 <lambdabot> Int -> Int -> Char
23:29:52 <Taneb> :t \a -> (!!) "Hello" . (+) a b
23:29:53 <lambdabot>     Couldn't match expected type `a0 -> Int' with actual type `Expr'
23:29:53 <lambdabot>     In the second argument of `(+)', namely `b'
23:29:53 <lambdabot>     In the second argument of `(.)', namely `(+) a b'
23:29:55 <Taneb> :t \a -> (!!) "Hello" . (+) a
23:29:55 <lambdabot> Int -> Int -> Char
23:30:07 <Taneb> @type liftA2
23:30:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:30:21 <ReinH> liftA2 (.)
23:30:31 <Taneb> @type liftA2 :: (a -> b -> -> c) -> (r -> a) -> (r -> b) -> r -> c
23:30:32 <lambdabot> parse error on input `->'
23:30:53 <Quadrescence> :t \a b -> ((!!) "Hello" .) . (+) a b
23:30:54 <lambdabot> Num (a -> a1 -> Int) => (a -> a1 -> Int) -> (a -> a1 -> Int) -> a -> a1 -> Char
23:31:04 <Quadrescence> :t ((!!) "Hello" .) . (+)
23:31:04 <Taneb> :t liftA2 (.) ((!!) "Hello) (+)
23:31:05 <lambdabot> Int -> Int -> Char
23:31:05 <lambdabot>     lexical error in string/character literal at end of input
23:31:23 <Taneb> :t (.) <$> (!!) "Hello" <*> (+)
23:31:24 <lambdabot>     Couldn't match type `Char' with `Int -> c0'
23:31:25 <lambdabot>     Expected type: Int -> Int -> c0
23:31:25 <lambdabot>       Actual type: Int -> Char
23:31:28 <dpwright> ah... I had a feeling liftA2 might be involved somewhere but I couldn't see it...
23:32:13 <haasn> :t ("Hello"!!) .: (+)
23:32:13 <lambdabot>     Not in scope: `.:'
23:32:14 <lambdabot>     Perhaps you meant one of these:
23:32:16 <lambdabot>       `.' (imported from Data.Function),
23:32:22 <haasn> :t let (.:) = fmap fmap fmap in ("Hello"!!) .: (+)
23:32:22 <lambdabot> Int -> Int -> Char
23:32:47 <Taneb> Nice one, haasn
23:35:31 <MedDev> is there any way to find a user created event in threadscope? I'm throwing one but don't seem to be able to find it and the application doesn't have a find feature as far as i can tell
23:37:00 <startling> "fmap fmap fmap" is so funny.
23:38:52 <ReinH> startling: I will also accept fmap `fmap` fmap
23:39:34 <ReinH> haasn: hey, can you get rid of these `fromIntegral`s with any clever trickery? https://gist.github.com/reinh/6710417
23:41:14 <haasn> well you could use view patterns line (fmap fromIntegral -> c) (fmap fromIntegral -> c') -- maybe with a nicer name, too
23:41:29 <haasn> oh, but then you won't be able to refer to them in line 6 anymore..
23:42:28 <ReinH> haasn: I'll call them c0 and c1 just for you :p
23:42:43 <haasn> I meant a nicer name on fmap fromIntegral
23:43:10 <ReinH> haasn: ah, thought about it, didn't come up with one
23:43:59 <startling> ReinH, ((round <$> lerp (i % end)) `on` (fmap fromIntegral)) c c'
23:44:26 <ReinH> startling: I alsothought there was an `on` in there somewhere but couldn't figure it out
23:44:53 <haasn> startling: that doesn't look right
23:45:02 <haasn> it'd be fmap round .: lerp (i % end) `on` ...
23:45:04 <haasn> or something like that
23:45:18 <haasn> or uh... round <$> (lerp ... `on` fmap ...) c c'
23:45:26 <startling> oh, misparse
23:45:30 <ReinH> startling: also the `on` is too restrictive I think
23:45:56 <startling> ReinH: I think that's the DMR
23:46:03 <Taneb> Right, Plan F
23:46:29 <Taneb> Change the dependencies in diagrams-cairo to accept an earlier version of cairo. See where this goes wrong, try to fix it
23:46:40 <ReinH> startling: DMR?
23:46:43 <haasn> I don't see why the DMR would limit this
23:46:54 <haasn> well, it's not even related to the DMR
23:47:05 <haasn> if `on` would be too restricted it would be related to rank-1 inference
23:47:22 <ReinH> dreaded.
23:47:27 <ReinH> How have I never seen that abbreviation before.
23:47:51 <startling> :t on
23:47:52 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:48:18 <startling> I think that should work. You just need to write the type signature or turn off the MR?
23:48:37 <ReinH> mayhaps.
23:48:37 <startling> oh, but you can't write the type signature since they're not parameters.
23:48:38 <haasn> the MR only takes effect for top level signatures
23:48:50 <ReinH> startling: I don't think the nested parens are an improvement though...
23:48:58 <startling> ReinH: that's fair!
23:50:54 <Taneb> Right, plan G
23:51:02 <ReinH> if there were just a good name for `fmap fromIntegral`
23:51:17 <Taneb> Switch to pushing SVGs to a web server
23:52:16 <Taneb> :(
23:52:41 <Taneb> I think I'm gonna get breakfast then think about it a lot
23:52:56 <startling> frampIntegral
23:53:02 <ReinH> hahaha
23:55:14 <ReinH> I think that's enough bike shedding. It's elegant enough aside from that.
23:55:55 <ReinH> oh I can switch the lerp order and go from [0..end] duh
23:57:12 <startling> ReinH: btw it's sort of weird to use case as a let
23:58:25 <dpwright> this may be a silly question, but that "liftA2 (.)" that ReinH pointed out to me looks so useful I'm slightly surprised there isn't an operator for it, say "<.>" or something.  Am I wrong and there is one?  Or am I wrong and it's not common enough to warrant a special operator?
23:58:45 <haasn> :t liftA2 (.)
23:58:45 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
23:59:00 <startling> :t \f g -> (.) <$> f <*> g
23:59:01 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
23:59:30 <dpwright> aha!
