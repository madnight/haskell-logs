00:00:41 <dmwit> Maybe worth a StackOverflow post.
00:06:20 <ill_logic> thanks for your help all, btw
00:14:17 <dmwit> Hm. What's the etiquette for when you want to ask something on SO, and an old, identical post has upvoted answers that don't actually answer the question?
00:15:52 <Gracenotes> not sure what the etiquette is, but people tend to ask things again
00:15:59 <Gracenotes> maybe ask the diff of what was not answered
00:16:17 <elliott> dmwit: bounty
00:16:25 <dmwit> elliott: ah!
00:16:35 <dmwit> An actual use for these useless points.
00:16:36 <dmwit> good idea
00:17:42 <Taneb> mm_freak, with my Alternative instance, and your example, for a start how can it fail half the time?
00:17:45 * hackagebot ajhc 0.8.0.8 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.8 (KiwamuOkabe)
00:17:51 <Taneb> If it's Nothing there's no way forward
00:18:53 <Taneb> Secondly, with the Maybe Alternative it just branches once, based on the first evaluation
00:19:19 <Taneb> If the left branch is Nothing, it goes onto the Right branch forever, otherwise it sticks with the left branch
00:21:13 <Ghoul_> choCombinators :: CollectedHo
00:21:18 <Ghoul_> Those collected ho's~
00:24:35 <Vertue> Do anyone know how to convert a sql varbinary to string in haskell?
00:25:02 <Vertue> I am trying to get some information out of a xml serialisation from a sql database
00:25:18 <Vertue> one of the fields is a serialised varbinary
00:25:52 <Vertue> I tried to use the encoding library but not having much luck.
00:26:41 <Vertue> Part of the problem is that I can't figure out how to cast the text from the xml to bytestring without any coversion
00:41:28 <mm_freak> Taneb: in netwire 4 terms:  holdFor 0.5 (periodically 1)
00:41:43 <mm_freak> but it's rather the underlying functor's empty we're interested in here
00:41:43 <Taneb> mm_freak, that wasn't your example, though
00:42:04 <Taneb> Having the underlying functor being empty could be a nice way to halt a program
00:42:10 <mm_freak> given w1 <|> w2, w1 is empty every other instant…  for example it checks whether the current time is even
00:42:28 <mm_freak> that's not a nice way to halt a program =)
00:42:30 <Taneb> mm_freak, if the time is odd, w1 can't continue
00:42:47 * hackagebot network-multicast 0.0.10 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.10 (AudreyTang)
00:42:51 <mm_freak> yes, w1 will then be empty, allowing w2 to run
00:43:12 <Taneb> It allows w2 to run, never checking w1 again
00:43:14 <mm_freak> however, in the even seconds w1 ran, so w2 was ignored, so it couldn't switch to a later state
00:43:23 <mm_freak> you don't know that
00:43:27 <Taneb> If w1 ever ran, w2 won't be
00:43:31 <Taneb> Yes I do
00:44:12 <mm_freak> myBolt = Bolt $ \_ _ -> do b <- randomIO; if b then empty else return (Right (), myBolt)
00:44:46 <mm_freak> oh, i understand now…  your (<|>) doesn't even combine the wires
00:44:51 <Taneb> Yeah
00:45:01 <mm_freak> check out (-->) in netwire
00:45:25 <mm_freak> that one is the clean variant of this =)
00:45:31 <mm_freak> w1 . for 3 --> w2
00:45:45 <mm_freak> w1 for three seconds, then w2
00:45:53 <mm_freak> forgets w1 after switching
00:46:39 <Taneb> But with my (<|>), w1 <|> w2 (with the Maybe underlying functor) will forget w1 if w1 is Nothing, and will forget w2 if w1 isn't nothing
00:47:25 <Taneb> It could be more useful with the [] functor, possibly
00:47:41 <mm_freak> i know…  i have tried all this and it's practically redundant
00:47:58 <Taneb> mm_freak, changing the topic can I ask what  you think of ocharles' netwire blog posts?
00:48:03 <mm_freak> also netwire's (<|>) preserves left-catch (netwire 4) or left-distributivity (netwire 5) in relation to Applicative
00:48:16 <mm_freak> i think they are great…  not perfect, but great =)
00:48:33 <mm_freak> netwire 5 will pretty much force his articles to be perfect ;)
00:52:05 <mm_freak> the new (<|>) has a number of very desirable properties
00:52:24 <mm_freak> a . (b <|> c) = a . b <|> a . c
00:52:52 <mm_freak> (a <|> b) . c = a . c <|> b . c
00:53:11 <mm_freak> a <*> (b <|> c) = a <*> b <|> a <*> c
00:53:23 <mm_freak> very useful for reasoning
00:53:42 <Ghoul_> oh wow
00:53:49 <Ghoul_> (a <|> b) . c is really cool
01:17:29 <beardtree> If I reverse the same list twice, will any reversing happen runtime?
01:18:06 <dmwit> yes
01:18:13 <beardtree> Thanks
01:18:25 <Jaxan> > reverse . reverse $ [1..]
01:18:34 <lambdabot>  Terminated
01:21:39 <Moggle> huh, would you even want that to be optimized?
01:21:53 <Moggle> i guess you sort of would, but optimizations should not result in different behaviors
01:22:04 <Moggle> an interesting problem
01:22:15 <Moggle> that only occurs due to laziness
01:24:13 <lpaste> Hari pasted “No title” at http://lpaste.net/92433
01:25:21 <hari_> I want to know, if at all, if the above pseudocode grammar is a good parsing engine for a Text->HTML converter
01:30:27 <daniel-s> Hi, I have a question about functional programming.
01:30:35 <daniel-s> (not specific to Haskell)
01:31:05 <daniel-s> If I have a dictionary, I want a function that takes a reference to that dictionary and adds a value to it.
01:31:27 <daniel-s> If I want to do this in a functional way, I think I need to create a deep copy, then add a value to the deep copy and return it.
01:31:39 <daniel-s> Is that how I'm supposed to do this? It seems very inefficient.
01:32:29 <elliott> no, you can share substructures
01:32:52 <elliott> laziness can also make this more efficient
01:33:35 <ciaranm> also functional doesn't imply immutable
01:35:08 <daniel-s> ciaranm: OK. I thought it did. Isn't that why Haskell doesn't let you change any parameters a function takes?
01:35:17 <hari_> I wanted to know if this pseudo-grammar definition seems sane for a text document parser http://lpaste.net/92433
01:36:09 <ciaranm> daniel-s: not really
01:36:33 <Ghoul_> anyone have a copy of `Listlessness is better than laziness: Lazy evaluation and garbage collection at compile time (1984)` by Philip Wadler ?
01:36:41 <ciaranm> daniel-s: the point is that effects are explicit
01:37:26 <ciaranm> anyone have a copy of a paper by Wadler that doesn't have an amusing title?
01:37:54 <Ghoul_> I don't get it.
01:39:48 <mm_freak> daniel-s: it is rather important whether this is a scheme question or a haskell question
01:39:57 <mm_freak> so this is not an FP question in general
01:40:25 <ciaranm> there's no such thing as "functional programming"
01:40:41 <daniel-s> mm_freak: Well, I'm writing something in Python
01:40:45 <Ghoul_> Thats why all the conferences are abbreviated with FP, right?
01:41:04 <mm_freak> daniel-s: in python you would handle this very differently, more the way you would handle it in scheme
01:41:25 <mm_freak> daniel-s: in python, while your dictionary itself is likely going to be mutable, you can use higher order functions to work with it
01:41:36 <mm_freak> for example to map a function over all elements
01:42:44 <mm_freak> daniel-s: there is also a style, which seems unique to haskell and usually requires immutability:  algebraic programming…  you identify your design patterns with known algebraic structures (most notably monoids) and design your operations based on them
01:43:04 <mm_freak> daniel-s: dictionaries form a monoid with the empty dictionary and the union operation
01:43:23 <daniel-s> I'm in the process of learning about Haskell. I somehow stumbled across it while trying to figure out a problem to the way all of my code was designed. I'm trying to start writing things using smaller, more easily testable components.
01:43:31 <daniel-s> I think I like the "style" of Haskell.
01:44:50 <mm_freak> daniel-s: the problem is, sharing of substructures is quite natural in haskell, so these patterns are elegant to express…  in most other languages you will have to implement sharing explicitly and make sure you don't get it wrong
01:45:11 <mm_freak> that's why immutable data structures aren't very common outside of haskell
01:45:13 <jdoles> What exactly is elegant about this? https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2
01:46:16 <jdoles> I'd think that almost nobody would know what a profunctor is, if I asked them, regardless of the public, perhaps excluding Mr. Kmett himself.
01:46:32 <elliott> I know what a profunctor is.
01:46:45 <elliott> in fact, anyone who knows how lens works knows what a profunctor is.
01:47:15 <quchen> jdoles: Even if you don't know what a profunctor is, you can explain what a Profunctor is to a beginner Haskell programmer in 5 minutes.
01:47:16 <elliott> in fact, the article links to two resources on profunctors.
01:47:42 <mm_freak> jdoles: i know what a profunctor is
01:47:47 <ciaranm> a beginner Haskell programmer in 5 minutes, or an experienced Java programmer in 2 years
01:47:52 <mm_freak> jdoles: and i use them quite a lot actually
01:48:06 <mm_freak> and i don'
01:48:10 <mm_freak> and i don't use lenses much =)
01:48:14 <tarrasch> jdoles, You have to be pro to know what a profunctor is ;p (I have no idea myself)
01:48:14 <jdoles> Explaining the entire program takes 10 seconds. 5 minutes is already 30 times that.
01:48:16 <mm_freak> so yes, they have uses outside of lens
01:48:26 <elliott> jdoles: I'm not really sure what your point is here.
01:48:35 <jdoles> My point is that these abstractions are useless.
01:48:44 <mm_freak> jdoles: your point is invalid
01:48:50 <jdoles> The abstraction of an automaton is useful.
01:48:55 <jdoles> The abstraction
01:49:02 <jdoles> of rendering a graph is also useful.
01:49:15 <Ghoul_> You . re . a . little . bit . pointless
01:49:23 <elliott> I use these abstractions. so I disagree.
01:49:32 <elliott> but you just sound trolly here, frankly
01:49:40 <jdoles> But all the other names giving to arbitrary compositions of functions and types exponentially becomes more useless.
01:49:51 <elliott> you could have at least picked a more complicated and less useful abstraction to criticise than profunctors :P
01:50:01 <mm_freak> jdoles: they are not useless, they just have a steeper learning curve
01:50:03 <elliott> god knows edwardk has plenty in some of his libraries :)
01:50:29 <mm_freak> jdoles: if you don't want to climb it, feel free not to use them
01:50:43 <hari_> Could anybody let me know if this pseudo-grammar seems all right for a text-document (with tags) parser? http://lpaste.net/92433
01:50:46 <elliott> ohh, I remember you...
01:50:51 <elliott> 2013-07-29.log:10:33:36 <jdoles> quchen: if Haskell was so high-performance and even a bit relevant, it would have something which destroyed Eigen.
01:51:14 <mm_freak> luckily #haskell is impossible to troll
01:51:22 <ciaranm> challenge accepted!
01:51:24 <quchen> mm_freak: inb4 that chatlog etc
01:51:40 <jdoles> I can write the same program without using these advanced concepts. I consider using more complex concepts to have higher maintenance costs.
01:51:47 <elliott> it seems like every time you've been in this channel you've either criticised random aspects of haskell unproductively or accused others of trolling :p
01:51:58 <mm_freak> jdoles: higher learning costs, much lower maintainance costs
01:52:01 <jdoles> You apparently think it is cheaper to use such advanced concepts.
01:52:11 <mm_freak> the maintainance and communication costs are exactly what justifies these concepts
01:52:20 <jdoles> I would like to see why it would possibly be the case that it is cheaper.
01:52:23 <elliott> mm_freak: #haskell is pretty easy to troll in my experience, actually
01:52:24 <quchen> I like how Lens is a counterexample to everything that has been wrongly said in the last 5 minutes.
01:52:56 <jdoles> The problem which lens solves can be solved without profunctors too.
01:53:21 <quchen> Proof of work?
01:53:23 <ciaranm> every problem that can be solved can be solved using the lambda calculus. what's your point?
01:53:24 <jdoles> Just because you can name a concept and express it, doesn't mean it is worth doing so.
01:53:32 <mm_freak> jdoles: if you solve it the way lens does, you would invent a structure and call it MappableFromBothDirections
01:53:45 <elliott> you're just arguing with people pointlessly here.
01:53:51 <mm_freak> jdoles: Profunctor is just a shorter name and people familiar with the term can recognize it and immediately know what it means =)
01:53:57 <elliott> what is the goal, to convince everyone to stop using a useful API because you don't like it?
01:54:39 <Ghoul_> Trolling so well that you could prove the reactions are turing complete
01:55:10 <mm_freak> jdoles: my suggestion for your future career: don't use haskell =)
01:55:42 <jdoles> mm_freak: let's say I write a program to generate all possible types and all possible relations between types. Would you argue that all of these structures warrant a name?
01:55:45 <hari_> I believe most modern programming languages can solve most problems. The only thing is which languages are suited to what domains. Haskell seems like a research ground for many advanced techniques of programming not explored in others, so I think one is bound to get more advanced and sometimes useless abstractions
01:55:57 <mm_freak> jdoles: no
01:56:16 <jdoles> mm_freak: then why would these particular ones (same with the zylo prefixed one) warrant one?
01:56:37 <mm_freak> jdoles: because they capture a set of useful laws
01:56:51 <elliott> zygohistomorphic prepromorphisms are (a) completely unrelated to profunctors (they are not even the same type of abstraction) and (b) a joke.
01:56:58 <ciaranm> you give something a name when it shows up often enough that you get bored repeating a long definition over and over again
01:57:02 <elliott> you're arguing against things nobody has said.
01:57:11 <jdoles> mm_freak: a compiler could also rediscover those laws.
01:57:23 <jdoles> mm_freak: that way no user would have to know of their names.
01:57:40 <Ghoul_> Maybe someone should start a wiki page with names that aren't taken, like, Cozylomonoprofunctornoid
01:57:45 <mm_freak> jdoles: even if the compiler could check them, it couldn't define them
01:57:56 <Ghoul_> Then it's easier to give these things names without accidentally reallocating them
01:58:17 <mm_freak> jdoles: would you say that monoids are useless?
01:58:31 <Sonderblade> jdoles: id like to see you write that cellular automata example in a better way without using profunctors :)
01:58:50 <arkeet> a monoid is nothing but a free monoid monad algebra.
01:59:03 <ciaranm> Ghoul_: ncatlab.org, hth
01:59:08 <arkeet> =p
01:59:40 <hari_> Would like some help with this pseudo-grammar - whether it seems OK or not for a simple text-document parsing  http://lpaste.net/92433
02:00:06 <Ghoul_> So many words
02:01:12 <mm_freak> hari_: not exactly answering your question, but you may want to check out pandoc
02:01:49 <osfameron> that definition of profunctors is quite dense
02:02:29 <hari_> mm_freak, I agree, but I wanted a small project to learn some concepts, so thought about writing a simple text document parser myself
02:03:43 <mm_freak> i understood profunctors by looking at the type class
02:03:43 <mm_freak> and by realizing, "ok, what i have here is not a bifunctor, so what could it be?"…  then i found profunctors =)
02:03:58 <gustavn> I'm trying to use the Bullet physics bindings with Haskell. But when trying to run my program through GHCi, it says: "can't load .so/.DLL for: BulletSoftBody.dll (addDLL: could not load DLL)
02:03:58 <gustavn> ". I'm on Windows if it matters.
02:04:01 <quchen> Is a cofree comonad a "co-(free monad)", i.e. the analogon to a free monad in the co world?
02:04:02 <mm_freak> hari_: seems reasonable…  in that case you should probably just try
02:04:27 <elliott> Cofree is just a free comonad, I think.
02:04:42 <hari_> mm_freak, thanks. Yes, I was trying to wrap my head around the Parsec and attoparsec modules. But still not comfortable with them.
02:04:48 <mm_freak> IIRC there is actually a difference between free and cofree
02:08:47 <gustavn> Anyone?
02:10:03 <ciaranm> free and cofree are different. free is a left adjoint to forget, cofree is a right adjoint. or possibly the other way around.
02:10:05 <Cale> gustavn: Do you have the C library installed?
02:10:13 <arkeet> ciaranm: that's right :)
02:10:29 <Cale> gustavn: It seems to be saying that it can't find the .dll for the library that the binding binds to.
02:10:48 <gustavn> Cale: Yes. When I installed the bindings "cabal install bullet", it didn't find it at first. I then used --extra-include-dirs and --extra-lib-dirs to point it to the right folder.
02:10:55 <mm_freak> anyway, in a sense Free : Cofree = Coproduct : Product
02:11:15 <mm_freak> you will notice that Cofree is a product, while Free is a sum
02:11:29 <gustavn> Cale: The library was compiled with VS2012, because it produced the only format that it seemed to recognize. One thing though, Bullet is a static library and shouldn't have any DLLs...
02:12:18 <pqmodn> mm_freak: is Either a coproduct?
02:13:26 <Cale> gustavn: hmm...
02:13:33 <arkeet> pqmodn: yeah
02:13:58 <gustavn> Cale: Probably forgot to mention something important: it works when I compile it with GHC and then run the executable, but it gives me this error when running in GHCi or using runhaskell
02:14:11 <Cale> ah, okay
02:14:20 <Cale> Well, that's hopeful at least
02:14:42 <pqmodn> arkeet: thanks, slowly starting to click
02:15:40 <Vertue> Do anyone know how to convert a sql varbinary to string in haskell?
02:16:37 <gustavn> Cale: Yeah, so it seems that GHCi *thinks* that BulletSoftBody.lib has an associated dll but it doesn't.
02:16:50 <augur> mm_freak: whats cofree :o
02:16:52 <Vertue> I am trying to get some information out of a xml serialisation from a sql database, one of the fields is a serialised varbinary. I tried to use the encoding library but not having much luck. Part of the problem is that I can't figure out how to cast the text from the xml to bytestring without any conversion
02:17:03 <mm_freak> pqmodn: Either a b = a + b
02:17:22 <mm_freak> augur: i don't know, sorry…  i just remember reading that there is a difference =)
02:17:23 <pqmodn> mm_freak: and (a,b) = a * b ?
02:17:27 <mm_freak> pqmodn: yeah
02:19:45 <danr> augur: it's the dual concept http://ncatlab.org/nlab/show/free+functor
02:19:53 <augur> danr: ;P
02:20:22 <danr> obviously :p
02:24:13 <divyansr> join #hasgeek
02:34:37 <mroman> Need help :(
02:34:47 <mroman> I have a cycle in my type synonym declarations.
02:36:23 <mroman> type Foo = Map String Bar
02:36:28 <mroman> type Bar = (Foo, Foo)
02:37:22 <quchen> mroman: Having circular types is to the compiler like having circular definitions at execution (minus laziness) I think.
02:37:41 <donri> mroman: newtype
02:38:15 <mroman> Yeah well
02:38:26 <chaterz> hello
02:38:36 <mroman> I have a Type for my StateT Stufff
02:38:53 <mroman> which contains a Map of Functions
02:39:06 <mroman> whose type is that StateT stuff
02:39:07 <quchen> mroman: Maybe you should post your code.
02:40:03 <mroman> quchen: http://codepad.org/rmZenObs
02:42:30 <quchen> mroman: That's not enough to judge whether there may be a better type representation for what you're trying to accomplish. Anyway, as donri mentioned, you can use a newtype to break the cycle.
02:43:09 <Taneb> mroman, one or both of them needs to be a newtype
02:43:15 <quchen> I wouldn't recommend using 'type' too much anyway, it makes error messages odd and generally isn't as typesafe as using newtype/data.
02:43:19 <Taneb> I would make Bar "data Bar = Bar Foo Foo"
02:43:58 <mroman> ic
02:44:05 <b__> Is GeneralizedNewtypeDeriving bad/unsafe?
02:44:23 <b__> I want Foo Decimal to be an instance of Num
02:44:24 <donri> b__: in current ghc yes
02:44:33 <b__> data Foo = Foo Decimal *
02:44:50 <donri> that won't work anyway, only newtypes
02:44:55 <mroman> Making MahouVerbs a data works
02:44:57 <b__> yeah sorry, newtype*
02:44:58 <b__> :|
02:45:16 <donri> but it's mostly safeish for simple uses
02:45:25 <donri> it breaks down when combined with things like type families
02:45:31 <b__> okay
02:45:33 <donri> fixed in ghc HEAD
02:47:00 <donri> b__: if you're interested http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/
02:47:07 <b__> For newtype Foo = Foo Decimal, I want a function (Decimal -> Decimal) -> Foo -> Foo, do I have to write it myself (as opposed to there being something like fmap for types like these)?
02:47:27 <b__> donri: thanks
02:48:04 <donri> b__: you could use lens and makeIso to get something like "over foo f"
02:48:48 <b__> ah right, my lens-fu is rusty, but that makes sense
02:49:33 <supki> or  newtype Bar a = Bar a; type Foo = Bar Decimal  then derive Functor for Bar with -XDeriveFunctor and use fmap :)
02:50:24 <b__> yeah thought of that
02:50:40 <b__> but that's pretty ugly
02:51:02 <donri> > over enum (+10) "hello"
02:51:03 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[GHC.Types.Char]'
02:51:03 <lambdabot>  Expected type:...
02:51:05 <donri> :(
02:51:29 <donri> > over (from enum) (+10) "hello"
02:51:31 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
02:51:32 <lambdabot>    arising from a use of `...
02:51:54 <donri> > over (from enum . folded) (+10) "hello"
02:51:55 <lambdabot>   Couldn't match type `f0 a0' with `GHC.Types.Int'
02:51:56 <lambdabot>  Expected type: (a0 -> Con...
02:51:57 <chrisdone> b__: that's pretty much what the iso abstrasction in lens is for. you need an isomorphism between Foo and Decimal
02:51:59 <chrisdone> donri: stop failing
02:52:02 <donri> :(
02:52:04 <b__> chrisdone: yeah
02:52:16 <donri> > over (from enum . traverse) (+10) "hello"
02:52:17 <lambdabot>   Couldn't match type `t0 a0' with `GHC.Types.Int'
02:52:17 <lambdabot>  Expected type: (a0 -> Con...
02:52:24 <b__> I'll go with an Iso
02:52:30 * donri goes for some morning coffee
02:53:09 <supki> > over (traverse . from enum) (+ 10) "hello"
02:53:10 <lambdabot>   "rovvy"
02:54:10 <donri> > under (traverse.enum) (+10) "hello"
02:54:11 <lambdabot>   Couldn't match type `t0 a0 -> f0 (t0 b0)'
02:54:11 <lambdabot>                with `Control.Lens...
02:56:36 <donri> b__: so anyway more line "over (from foo)" or "under foo"
02:56:49 <chrisdone> :t over
02:56:50 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
02:57:13 <donri> :t (%~)
02:57:14 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
02:57:30 <chrisdone> yeah, useless type without being able to query on the class and subtypes
02:57:53 <arkeet> :t over `asAppliedTo` both
02:57:54 <lambdabot> Setting (->) (a, a) (b, b) a b -> (a -> b) -> (a, a) -> (b, b)
02:59:02 <arkeet> :t over `asAppliedTo` mapped
02:59:10 <arkeet> ...
02:59:12 <arkeet> :t over `asAppliedTo` traverse
02:59:17 <arkeet> ....
02:59:25 <lambdabot> Functor f => Setting (->) (f a) (f b) a b -> (a -> b) -> f a -> f b
02:59:25 <lambdabot> Traversable t => Setting (->) (t a) (t b) a b -> (a -> b) -> t a -> t b
02:59:31 <donri> @botsnack
02:59:33 <lambdabot> :)
03:04:26 <mr-> :t asAppliedTo
03:04:28 <lambdabot> (a -> b) -> a -> a -> b
03:12:20 <erisco> what exactly is this type class here? http://hackage.haskell.org/packages/archive/generator/0.5.1/doc/html/Data-List-Class.html#t:List
03:13:08 <erisco> by calling it "List" I would guess a generalization of [], but the contraints of MonadPlus and Monad (I don't know what ItemM is) do not make sense
03:13:37 <erisco> > [1,2,3] >>= (:[])
03:13:38 <lambdabot>   [1,2,3]
03:13:53 <erisco> > [1,2,3] >>= (:[9,9,9])
03:13:54 <lambdabot>   [1,9,9,9,2,9,9,9,3,9,9,9]
03:14:06 <erisco> figured as much... this is an overstatement of what [] requires
03:17:01 <erisco> > cons 2 (Just 5)
03:17:02 <lambdabot>   No instance for (Control.Lens.Cons.Cons
03:17:03 <lambdabot>                     Control.Lens.In...
03:17:09 <erisco> :t cons
03:17:24 <supki> @ty Control.Lens.cons
03:17:25 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
03:17:32 <erisco> not the one I want :(
03:17:33 <supki> hth
03:17:57 <erisco> > Data.List.Class.cons 2 (Just 5)
03:17:59 <lambdabot>   Not in scope: `Data.List.Class.cons'
03:18:11 <erisco> > Data.List.Class.List.cons 2 (Just 5)
03:18:13 <lambdabot>   Not in scope: `Data.List.Class.List.cons'
03:18:20 <erisco> I don't know how to qualify it. bleh.
03:18:30 <donri> it doesn't have all of hackage
03:18:33 <supki> I don't think lambdabot has it at all
03:19:11 <erisco> I'm curious about this Data.List.Class is all
03:20:58 <erisco> a class which supposedly has a valid instance for Maybe cannot be a class that captures the properties of []
03:21:18 <erisco> but maybe "List" is being pulled from elsewhere
03:21:57 * erisco sighs
03:22:35 <erisco> trying to find out how I don't need to rewrite my code to use an abstraction on [] merely so I can sometimes have a list with length :P
03:23:03 <donri> Maybe is just [] with no more than one element
03:23:20 <erisco> which is not the same as [], as I was saying
03:23:41 <erisco> if you write an algorithm for [], then you can't use that class as an abstraction
03:23:44 <erisco> it would be erroneous
03:24:39 <donri> that's often the case with these classes without theoretical grounds ;)
03:25:00 <erisco> "without theoretical grounds" what do you mean?
03:25:16 <donri> no formal laws
03:26:00 <erisco> right, well perhaps their meaning of List is different *shrug*
03:26:45 <donri> i took it to mean "list like", like the ListLike package, but haven't studied either closely
03:27:16 <erisco> mm I think the term "Stack" is fairly accurate
03:28:02 * hackagebot labyrinth 0.3.0.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.3.0.0 (AlexeyKotlyarov)
03:28:30 <augur> donri: no formal laws just means no laws at all!
03:28:35 <augur> and thats a perfectly fine class :)
03:28:59 <augur> remember, every monad is a raw monad!
03:29:23 <augur> ~ but not every raw monad is a monad ~
03:29:39 <erisco> augur, what does this mean?
03:29:44 <erisco> "raw monad"?
03:29:53 <augur> monad minus the laws
03:30:05 <augur> so haskell monads, because there are no enorceable laws in haskell
03:30:16 <augur> as opposed to, say, agda monads, which are True Monads
03:31:14 <augur> you literally cant write an agda monad that doesnt obey the monad laws
03:31:32 <erisco> augur, lack of compiler enforcement is not entirely a fair assessment
03:31:46 <augur> erisco: who's assessing?
03:31:57 <erisco> "no enforceable laws"
03:32:13 <augur> thats just a statement of fact about haskell
03:32:37 <erisco> yes... in the most literal of senses :)
03:33:00 <augur> haskell doesnt reeeaaally have monads, it just hopes you wont break the laws. but there's nothing wrong with breaking them, provided you dont rely on them
03:33:17 <augur> im not sure if haskell does anything that actually relies on the monad laws being satisfied. maybe it does.
03:33:36 <laurence_day> you're hurting the equational reasoning part of me ;_;
03:33:44 <augur> laurence_day: why?
03:34:31 <laurence_day> just my own nitpickiness about monads having to be correct: you're right of course
03:34:42 <laurence_day> you don't lose anything if they don't work
03:34:47 <laurence_day> i like the word 'quasimonadic' for that
03:34:49 <laurence_day> :)
03:35:04 <augur> laurence_day: your nitpickiness is correct, just not enforcedly so in haskell
03:35:11 <laurence_day> touché
03:35:37 <erisco> augur the logic machine
03:35:49 <augur> in a sense, by using the monad type class you're declaring that you've done your proofs and checked, but thats a promise you make to the community, not to haskell
03:36:09 <laurence_day> aye, sure
03:36:17 <erisco> augur, slightly different topic, but I wager you'd have some insight...
03:36:22 <augur> violating the monad laws in haskell is "technically ok", but socially disreputable
03:36:41 <augur> sort of like burping loudly!
03:36:55 <augur> its not "immoral" but its certainly not something you do in polite company
03:37:10 <laurence_day> ergo my equational reasoning comment: i've burnt myself many times by doing things in what i thought was a monad and been stopped short
03:37:11 <laurence_day> Heh
03:37:48 <erisco> augur, I need an abstraction of [], evidently, so I started on this: http://lpaste.net/92439  but under "missing stuff" there are a couple things I don't know how to even logically state
03:38:03 * hackagebot bytes 0.11.5 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11.5 (EdwardKmett)
03:38:29 <erisco> augur, is there some sort of induction required?
03:38:40 <augur> what do you mean
03:39:16 <augur> also i think your laws are shady
03:39:29 <erisco> I can't seem to state those properties other than by saying there exists an n \in N such that n applications of oust (unpacking from the Maybe and tuple, of course) will yield x
03:39:30 <augur> well, depending on what oust is "meant" to do
03:39:56 <erisco> augur, supposed to be the pattern match (x:xs)
03:40:08 <augur> oh ok
03:40:40 <augur> why dont you just say you have a type thats iso to lists?
03:40:52 <erisco> because what does that mean? :s
03:40:59 <augur> it seems like you want listy behavior, but not necessarily listy representation
03:41:18 <augur> doesnt it tho? it seems like every Collection can be turned into a list
03:41:21 <augur> and vice versa
03:41:23 <augur> in an isomorphic way
03:41:27 <erisco> augur, yes. in fact because I want a "list with length" ie an O(1) length operation
03:41:56 <augur> erisco: ok, so just say its iso to list
03:42:12 <erisco> augur, yes that would be a consequence of having no more or less properties than list, I would think
03:42:20 <erisco> augur, is list well defined somewhere else?
03:42:23 <donri> for what value of "collection" though? Set is lossy
03:42:27 <augur> erisco: i dont know what you mean tho
03:42:33 <augur> defined somewhere else?
03:42:56 <augur> class Functor f => IsoFunctor f where toList :: f a -> [a] ; fromList :: [a] -> f a
03:43:07 <augur> with laws toList.fromList = id ; fromList.toList = id
03:43:40 <erisco> augur, that seems reasonable
03:43:51 <augur> you can loosen that somewhat to just the first one if you want to allow trees to be members
03:43:56 <erisco> augur, so I suppose then what I am doing is simply describing facts of list
03:44:20 <erisco> but no... wait
03:44:35 <augur> trees have more structure than lists, so they can be used wherever you use lists, essentially, except the roundtrip through lists isnt an iso because you're canonicalizing
03:45:18 <erisco> how does a function to convert to and from [] guarantee that when I convert from [] that the new data structure adheres to all the laws of []?
03:45:37 <augur> there are no guarantees in haskell. thats up to the user of the type class
03:45:52 <erisco> even theoretically
03:46:03 <augur> i dont know what you mean
03:46:06 <erisco> for example
03:46:10 <augur> functions dont guarantee anything
03:46:15 <augur> either they have the property or they dont
03:46:31 <augur> if they dont, they dont
03:46:37 <augur> if they do they do
03:46:38 <hiptobecubic> what are the laws of []
03:46:51 <erisco> hiptobecubic, dunno was working on that
03:47:09 <erisco> augur, I agree that a function in Haskell does not guarantee anything
03:47:32 <augur> erisco: you can i think essentially just reduce it to laws about vacant, into, and oust, i think.
03:47:37 <erisco> augur, however, I am talking about the written documentation for what it ought to guarantee
03:47:47 <augur> erisco: yes but thats what i just said
03:47:59 <augur> you specify it as an iso
03:48:06 <erisco> okay, I understand
03:48:08 <erisco> but
03:48:08 <hiptobecubic> if you want it to behave like [], why not use []?
03:48:27 <augur> hiptobecubic: he wants to have more flexibility with representations
03:48:31 <augur> such as manifest length
03:48:43 <erisco> (that is important for the big-O of my program)
03:48:57 <hiptobecubic> so you don't want [], then, which can be infinite
03:50:03 <augur> length ofcourse can be indexed, so if you used a vector instead you can just read off the length, but haskell doesnt have true vectors. you'd need to use SHE to get that feature
03:50:16 <augur> erisco: you could ofcourse just use (Int,[a]) :)
03:50:19 <erisco> hiptobecubic, so can a list with length
03:50:31 <augur> but im not sure why you want to create a type class, erisco
03:51:16 <erisco> augur, I'll worry about that, but I want to ask
03:51:18 <b__> @pl pva i n f = sum [pv i x f | x <- [0..n]]
03:51:21 <lambdabot> pva = id (fix (const (((sum .) .) . flip (flip . (flip .) . (((:) .) .) . flip ((.) . flip . ((<-) .) . flip (flip . ((|) .) . flip pv x) x) (enumFromTo 0)) [])))
03:51:21 <lambdabot> optimization suspended, use @pl-resume to continue.
03:51:33 <b__> insanity
03:51:36 <hiptobecubic> so you want length to be O(1), but _|_ if the collection is infinite?
03:51:36 <erisco> augur, if iso with list means toList and fromList as you stated
03:51:54 <erisco> augur, how does that say anything about what I get out of fromList?
03:52:05 <erisco> because it seems to say nothing
03:52:52 <erisco> "iso with list" may mean losslessly convertible from and back to a list, by the id laws you stated
03:53:05 <augur> erisco: it says nothing specific. it does say, however, that you can turn it back into a list without any information loss.
03:53:31 <erisco> correct, which means that if I depend on the properties of [] then the only thing iso lets me do is convert back to []
03:53:40 <erisco> so I never can use the other representation
03:53:42 <augur> but as a consequence, you get that there must exist some functions that work just like the ones you're interested in, by virtue of the iso
03:53:50 <augur> erisco: why cant you use the other representation?
03:53:59 <erisco> because it doesn't have to behave like []
03:54:04 <augur> no it doesnt
03:54:09 <augur> but so what?
03:54:22 <augur> just because it doesnt HAVE TO doesnt mean it CANT
03:54:23 <erisco> and by "doesn't have to" I don't mean "haskell can't throw a compiler error if it doesn't"
03:54:41 <erisco> I mean there is nothing stated theoretically by iso that would require such a thing
03:54:51 <augur> thats correct
03:55:05 <augur> i mean, to some extent there is, via the iso
03:55:12 <augur> but that doesnt mean its efficient to use the iso for that
03:55:32 <erisco> okay, so
03:55:35 <augur> there is, for instance, a head-like function by composition:   head.toList
03:55:42 <augur> and a tail-like function   tail.toList
03:55:43 <augur> etc etc
03:56:00 <augur> but this is why im asking why you want a type class in the first place
03:56:27 <erisco> if I had a function which currently worked on [], and I wanted to generalize, I would instead accept something iso to list, operate on the list, then iso back
03:56:56 <erisco> is that the picture?
03:57:20 <augur> thats one way of doing things, yes. its not efficient, obviously, but its guaranteed to work.
03:57:41 <erisco> I agree that will work. However, yes, I lose exactly the efficiency I am requiring
03:58:02 <augur> list-y type classes dont give you the efficiency you require either, however.
03:58:05 <donri> erisco: depending on the operation you could possibly generalize to some of Functor, Foldable, Traversable
03:58:08 <augur> all they do is specify an interface
03:58:32 <augur> erisco: what you seem to want to do is invent your own type, and then merely prove that it's iso to lists
03:58:39 <augur> you dont need a typeclass for this, you just do it.
03:58:54 <erisco> augur, correct, however if an algorithm is written to operate on that interface, and I supply the instance, then I know the additional properties of the instance will still be held
03:59:26 <augur> erisco: you dont need to use a typeclass for any of this
03:59:31 <erisco> how is it merely just proof of iso to list? did we not just agree how it isn't that?
03:59:46 <augur> no, a proof of isomorphism is not the IsoFunctor class i described
04:00:05 <erisco> okay
04:00:09 <augur> the class i described was a cheap way to state very generically that something is iso
04:00:19 <augur> but you seem to merely want to know that the thing you're implementing is iso
04:00:37 <augur> you want to invent LengthTaggedList and you want to know that it's "basically just a list"
04:00:48 <augur> so just do that
04:00:58 <augur> invent the type, and show that its basically just a list
04:01:08 <augur> that is, exhibit an isomorphism
04:01:14 <erisco> augur, how does this not miss the point we just discussed?
04:01:25 <erisco> that is, if I want to write algorithms generic to the representation
04:01:31 <mm_freak> Applicative ((:[]) + liftM* or repeat+zipWith), Alternative ([]/++), Functor (map), Foldable (foldr/foldl), Monad (concatMap), Traversable (mapM), …
04:01:36 <jdoles> Does http://ipwnstudios.com/ still exist?
04:01:58 <mm_freak> erisco: see what operations you use and how you can generalize them…  the list above might help
04:02:11 <augur> erisco: aha, thats what you want to do? write something generically over all listy things? well then you cant guarantee the efficiency you seek to guarantee.
04:02:30 <augur> erisco: if you want to be generic, then you must be generic over really stupid implementations
04:02:33 <erisco> augur, perhaps proving isomorphism is all I need for my list of laws, but your assertion that I do not need a type class is a different matter
04:02:51 <augur> erisco: you need a typeclass if you want genericity over the algo, this is true
04:03:10 <erisco> "cannot guarantee the efficiency you seek to guarantee" why?
04:03:27 <mm_freak> erisco: if you require isomorphism to [], you should just write a list algorithm to begin with
04:03:39 <jdoles> If you want efficiency, why would you write it in Haskell to begin with?
04:03:40 <augur> but that genericity costs you your desired efficiency. or at least it makes it arbitrarily dependent on the implementation
04:03:47 <mm_freak> erisco: a generalized type signature will not make your algorithm more general and likely less efficient
04:03:49 <erisco> if I write genericTails which works on any listy thing, and I give it the listy thing of "list with length", then I know the length of the list can be determined in O(1)
04:04:11 <erisco> jdoles, this is big-O, not just coefficients
04:04:27 <augur> erisco: only for that particular implementation
04:04:37 <erisco> augur, yes but that is the point!
04:04:40 <augur> but you dont need type classes to do that
04:04:43 <erisco> why
04:04:46 <augur> why why
04:05:02 <augur> you dont need type classes to make lists-with-length
04:05:12 <erisco> agreed
04:05:21 <erisco> I can duplicate the functions
04:05:27 <erisco> I can have listWithLengthTails, and so on
04:05:28 <augur> type classes let you abstract an interface, thats all.
04:05:34 <erisco> that is stupid though
04:05:43 <jdoles> erisco: why is that stupid?
04:05:43 <augur> how is that stupid
04:05:45 <osfameron> jdoles: efficiency compared to what?  I tend to write perl/python day-to-day, so rewriting in Haskell would (very likely) be more efficient ;-)
04:06:11 <erisco> if this is the crux of why you say I don't need it, then I won't bother arguing further :P
04:06:15 <jdoles> osfameron: compared to optimized C++.
04:06:34 <augur> erisco: dont blame me for your lack of understanding of your own problem >_>
04:06:53 <erisco> that isn't blame
04:07:08 <jdoles> osfameron: in principle Haskell should be faster than C++ (there is more information about the static behaviour of the program available), but somehow it isn't.
04:07:10 <erisco> I don't know how to explain how duplicating functions is not stupid
04:07:35 <erisco> or is stupid rather
04:07:42 <jdoles> osfameron: and in the end, all that matters is how fast a given correct program can be obtained with a given desired performance level.
04:07:44 <mm_freak> jdoles: haskell actually beats optimized C/C++ for some operations
04:07:52 <augur> erisco: duplication functions is stupid indeed, but if you're only ever going to use them for one particular instance of the class, there's no duplication
04:08:00 <osfameron> there is a very limited set of tasks that I would write C++ for.  Actually, Arduino programming is pretty much it.
04:08:10 <jdoles> Let me refer to the Eigen library again.
04:08:35 <augur> you write them once. either they're generic and apply to any listy thing, and you get what you get, efficient or not, or you write them specialized to the efficient type you want to use
04:08:40 <jdoles> Additionally, there is a severe lack of programs written in Haskell, which doesn't do much good for its credibility.
04:08:59 <mm_freak> jdoles: not a lack of programs — a lack of users
04:09:03 <augur> if you're only ever going to care about your efficient type, then there is no point in using a type class
04:09:03 <sipa> the same was once true for C
04:09:04 <jdoles> Even OCaml has more financial backing than Haskell.
04:09:17 <erisco> augur, okay. thanks for your help :)
04:09:22 <mm_freak> financial backing is meaningless
04:09:44 <sipa> jdoles: Oracle also has more financial backing than postgresql
04:10:04 <augur> erisco: anyway, if you insist on doing the typeclass thing anyway, all you need are the laws about fake-nil and fake-cons
04:10:05 <jdoles> sipa: Oracle is only backed by one party.
04:10:10 <jdoles> sipa: so, that's not the same.
04:10:19 <augur> erisco: and your fake-case
04:10:27 <sipa> ok
04:10:29 <erisco> augur, sorry what are these things?
04:10:36 <mm_freak> jdoles: PHP has a lot more financial backing than haskell
04:10:40 <mm_freak> so PHP is better?
04:10:49 <jdoles> mm_freak: PHP is better for some things, yes.
04:11:02 <mm_freak> jdoles: broken guestbooks, what else?
04:11:09 <sipa> lol
04:11:13 <kranius> :)
04:11:21 <jdoles> Extremely low-cost, low-quality simple web application creation.
04:11:26 <erisco> augur, fake-nil as in vacant, fake-cons as in into, and fake-case as in?
04:11:33 <augur> that is to say,  oust vacant == Nothing ; oust (x `into` xs) == Just (x,xs)
04:11:34 <jdoles> (for which there happens to be a lot of demand)
04:11:43 <edwardk> jdoles: I'll just say this, my experience with Haskell's efficiency does not match up with your assessment. I've written, shipped and sold production quality software written in Haskell and had it blow the doors off the nearest hand-written laboriously tuned C/C++ equivalent, because Haskell let me work smarter, not harder and ship better algorithms.
04:11:44 <jdoles> Nobody is interested in perfection.
04:11:49 <mm_freak> jdoles: ok, you have a point there…  haskell does not support the low-quality aspect =)
04:11:56 <osfameron> I dislike PHP as much as the next programming language snob, but there are some extremely complex, high quality apps with great UIs written with PHP
04:12:15 <Maior> oh another language war, yay
04:12:22 <erisco> augur, you can reduce the 5 laws I have currently stated into three?
04:12:22 <Maxdamantus> Is Facebook still written in PHP?
04:12:37 <jdoles> edwardk: do you have any pretty pictures of your work or is it all classified?
04:12:39 <mm_freak> Maxdamantus: well, in what they call "hiphop"
04:12:44 <mm_freak> a compiled PHP dialect
04:12:50 <jdoles> edwardk: besides your articles, that is.
04:12:53 <augur> erisco: into two. those are the defining laws of lists.
04:13:10 <edwardk> Most of what I do winds up classified ;)
04:13:31 <edwardk> Well, not as classified as when I was a defense contractor =)
04:13:36 <jdoles> edwardk: how much do you charge?
04:13:39 <erisco> augur, okay I will try and derive the others I stated from them :) cool. what about "missing stuff"?
04:13:58 <mm_freak> "enough"
04:14:00 <jdoles> Some people charge 800$ and also put it on their website, so there is nothing to be ashamed of.
04:14:06 <augur> erisco: deriving them probably wont be easy, but its unnecessary to do so
04:14:10 <erisco> augur, I'm really clueless on how to establish those facts... and both are definitely true for []
04:14:22 <jdoles> (per hour)
04:14:35 <edwardk> I don't tend to do hourly work.
04:14:42 <erisco> augur, agreed, but that would be taking you on word ;) rather I just want to see how the redundancy of what I did comes in
04:14:49 <augur> erisco: within can be eliminated entirely, you realize.
04:14:51 <erisco> augur, this is the first time I've tried to establish such a thing
04:14:55 <augur> its definable in terms of oust
04:15:05 <erisco> augur, according to you, yes, I'll look at that indeed
04:15:13 <augur> so you can just get rid of it
04:15:15 <edwardk> I tend to write something big in a domain and sell it off once and for all.
04:15:33 <jdoles> edwardk: and where do you get the domain knowledge?
04:15:36 <erisco> augur, then "missing stuff" kinda vanishes it seems
04:15:43 <jdoles> edwardk: or even that there is demand for whatever you are writing?
04:16:09 <edwardk> jdoles: I collect degrees and have a pretty wide-ranging technical background
04:16:11 <erisco> augur, I guess you would rather define the operation of "within" using just oust and into, yeah? then you'd prove the "missing stuff" based off the definition of "within"
04:16:13 <augur> specifically   within y fxs = case oust fxs of { Nothing -> False ; Just (x,fxs') -> x == y || within y fxs' }
04:16:15 <erisco> augur, that is my guess
04:16:35 <augur> erisco: this is just the normal elem definition but strung through your oust case gadget
04:16:47 <jdoles> edwardk: the second question is the more interesting one, I suppose. It's not that hard to learn useful parts of a domain.
04:16:53 <erisco> augur, right, and through such a definition I can prove "missing stuff"
04:17:10 <erisco> augur, right? excellent :D
04:17:19 <augur> erisco: there's nothing left to prove. within _is_ repeated use of oust.
04:17:31 <erisco> yes, even better point ^.^
04:17:48 <augur> btw, erisco
04:17:53 <erisco> hm?
04:18:35 <augur> there is a library that is, smuggly, called Sexy Prelude, i think, which has done all of this already.
04:19:05 <augur> they abstracted all of the prelude library into type classes instead of rigid data types
04:19:09 <erisco> https://github.com/DanBurton/sexy ?
04:19:27 <augur> oh, no, i think its classy prelude, actually
04:19:29 <edwardk> As for knowing about demand, I do a lot of work on parallel/work-stealing algorithms, cache-oblivious structures, Bayesian models, automatic differentiation comes up in my code in tons of places, GPGPU work, movie-style Metropolis light transport and general mathematics. The things I write tend to be applicable across a wide-array of domains in general and then in graphics in particular, because that was an early love of mine.
04:19:52 <augur> who knows. there's a video on it, erisco. lemme find it.
04:20:09 <erisco> augur, I'm all for this already being done :D
04:20:21 <augur> the idea tho was to make the normal definitions work on genericized types so that you can write JS using haskell
04:20:42 <augur> ah no, erisco, it's AwesomePrelude
04:20:47 <augur> http://vimeo.com/9351844
04:21:12 <augur> anyway, erisco, ultimately what makes a type what it is is two things:
04:21:20 <augur> the constructors, and the case analysis
04:21:55 <augur> you've smuggled in the case analysis for lists by way of Maybe and pairs, but you ought to avoid that and just use the essential structure of the case operation
04:21:58 <augur> which is this:
04:22:20 <erisco> something did seem unsatisfying about that
04:22:24 <h007> can someone tell me what is wrong with this random tree generation code? http://pastebin.com/cWZxNC1z
04:22:29 <mauke> The paste cWZxNC1z has been copied to http://lpaste.net/92440
04:22:32 <augur> listCase :: [a] -> r -> (a -> [a] -> r) -> r
04:22:35 <h007> it just halts
04:22:42 <augur> listCase [] nilCase consCase = nilCase
04:22:50 <augur> listCase (x:xs) nilCase consCase = consCase x xs
04:23:36 <tryhr> سمَـَّوُوُحخ ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
04:23:38 <h007> i based my on the code here: http://byorgey.wordpress.com/2013/04/25/random-binary-trees-with-a-size-limited-critical-boltzmann-sampler-2/ which works for binary tree, but when i add more nodes, it halts
04:23:45 <augur> those are the laws you want to obey, erisco
04:23:49 <augur> !ops
04:23:51 <jdoles> Bye Apple users.
04:24:09 <augur> jdoles: im on a mac :D
04:24:15 <augur> erisco: so what you want is this class:
04:24:35 <jdoles> augur: why aren't you gone then?
04:24:39 <erisco> augur, actually it is on the video poster you linked to :P
04:24:39 <augur> jdoles: magic
04:24:49 <augur> erisco: their version is SLIGHTLY different
04:24:50 <augur> but
04:24:52 <sipa> why would he...?
04:25:05 <jdoles> augur: perhaps you use a command line irc client.
04:25:10 <augur> sipa: that text tryhr posted is toxic
04:25:17 <augur> jdoles: nope, limechat
04:25:27 <jdoles> augur: is that GTK?
04:25:27 <augur> class Listish f where   nil :: f a   ;   cons :: a -> f a -> f a
04:25:41 <h007> mauke: thanks, any help with the code?
04:25:52 <augur> ;   caseListish :: f a -> r -> (a -> f a -> r) -> r
04:26:17 <augur> erisco: with the laws   caseListish nil n c = n ; caseListish (cons x xs) n c = c x xs
04:26:52 <augur> erisco: you should get this pattern down, because this is THE definition of an ADT.
04:27:19 <erisco> sorry, do you mean this is how ADTs are defined?
04:27:23 <h007> help fixing this tree generation code? http://lpaste.net/92440 anyone? it works and fails randomly
04:27:40 <augur> erisco: yes, basically, all ADTs are nothing but this notion: constructors + case analysis
04:27:47 <augur> actually technically its constructors + fold
04:27:55 <erisco> yum yum :)
04:28:05 <augur> but thats reconstructible from the case usually
04:28:15 <augur> i forget what you need to do that. maybe ambient recursion?
04:28:29 <erisco> augur, these are some delicious things to learn... I still have to look at the listCase and grok what it is doing
04:28:35 <erisco> but I've copied it down
04:28:47 <augur> erisco: listCase is doing .. case analysis for lists!
04:28:54 <augur> look at this explicit case expression for lists:
04:28:54 <erisco> yes.. thanks.. :P
04:28:58 <mr-> h007: how does it fail?
04:29:05 <erisco> well you keep typing stuff so I haven't looked deeply yet :P
04:29:08 <erisco> give me a minute
04:29:22 <augur> case l of { [] -> n ; (x:xs) -> m }
04:29:26 <h007> just freezes, no output
04:29:35 <augur> x and xs are free in m, so really we might as well just say
04:29:45 <mr-> h007: oh, because it does not terminate
04:29:54 <h007> mr-: if you try it in ghci you'll se
04:30:07 <h007> mr-: yes
04:30:10 <augur> case l of { [] -> n ; (x:xs) -> c x xs } where c is a closed function (ie no free vars)
04:30:28 <mr-> h007: it does not fail, it just creates a huge tree
04:30:29 <Cale> h007: the expected size of the generated tree is infinite
04:30:37 <erisco> augur, hang on for a second
04:30:42 <augur> erisco: holding
04:30:54 <augur> edwardk: wabisabi
04:30:58 <h007> right, how can i specify a max depth?
04:31:05 <erisco> augur, you said    listCase [] nilCase consCase = nilCase; listCase (x:xs) nilCase consCase = consCase x xs
04:31:07 <edwardk> i think augur finally snapped
04:31:19 <mr-> h007: you could give it another parameter
04:31:21 <augur> edwardk: it wasnt me! D:
04:31:29 <erisco> but nilCase is constant between the two, with only the pattern match on the list changing
04:31:29 <augur> erisco: yep
04:31:33 <erisco> and consCase
04:31:36 <erisco> :s
04:31:38 <augur> erisco: yes it is!
04:31:43 <erisco> ohh
04:31:45 <erisco> right
04:31:46 <Cale> h007: take the depth as a parameter to the function
04:31:52 <erisco> it is returning the argument... silly me
04:31:52 <Cale> h007: (the max depth)
04:31:54 <augur> nilCase is what you do when the list is []
04:32:00 <Cale> h007: if it's 0, then you have to produce a leaf
04:32:07 <augur> obviously you dont need any more information about [] since you know everything there is to know about it
04:32:07 <erisco> for some reason the thing on the right wasn't pairing with the thing on the left in my head
04:32:25 <augur> etc for the cons case
04:32:36 <h007> Cale/mr-: let me try change it in lpaste directly
04:32:46 <augur> erisco: the point is, what defines an ADT is its constructor-case interaction.
04:34:10 <augur> all else is irrelevant, so as long as you do that, you're fine. you can do it with just lambdas, if you're cheeky, and that gives you whats called a scott encoding.
04:34:32 <augur> erisco: scott encodings being one standard way of coding lists in the untyped LC, provided you have ambient recursion.
04:35:07 <erisco> I am still stuck on figuring out what listCase does... ie why someone would call such a function
04:35:57 <augur> erisco: its just how you do case analysis
04:35:59 <h007> Cale/mr-:  doesn't seem to work. could you have a look at the changes i made? http://lpaste.net/92440
04:36:08 <augur> haskell has case analysis built in, so listCase is not primitive
04:37:27 <augur> erisco: but what makes that possible is that underneath, haskell knows how to do case analysis based on an ADTs definitions. well what if you dont have a fixed definition, you just know the constructors?
04:37:31 <augur> then what makes it list-y?
04:37:45 <Cale> h007: that seems to work here
04:37:53 <augur> that it case analyses like a list, of course. but you cant write a generic case for it. instead you write your own case, and you show that it's list-like via those equations
04:37:55 <mr-> h007: looks good, but I would prefer to pattern match, personally
04:38:05 <h007> Cale: it doesn't print anything on screen for me
04:38:06 <Cale> h007: at least, it's depth-limited. The distribution of trees that you get is really awkward still of course.
04:38:21 <Cale> h007: Add  "deriving Show"  to the definition of Tree
04:38:47 <mr-> h007: to make it a little more fancy, you could vary the probability for branching depending on the depth :-)
04:38:58 <augur> erisco: so caseListish lets you write programs like this:   sumListish xs = caseListist xs 0 (\x xs -> x + sumListish xs)
04:39:00 <h007> Cale: thanks, it works. I wonder why it didn't give me an error for that
04:39:08 <Cale> Because it's not an error
04:39:11 <erisco> augur, okay so what I'll do is make the class and then try and instance it for []
04:39:21 <h007> mr-: please show me how
04:39:24 <erisco> augur, to see how it works... then write an algorithm such as length for it
04:39:33 <erisco> there is an air of mystery at the moment :)
04:39:34 <augur> erisco: you can add some illudicating comments if you want:   caseListish xs {- [] -> -} 0   {- cons -} (\x xs -> x + sumListish xs)
04:39:41 <erisco> Haskell has clearly spoiled me
04:39:47 <Cale> Well, it would be an error to try to print a Tree without a Show instance
04:40:02 <augur> erisco: you just write it like you write case, except with extra noise instead.
04:40:04 <augur> length is easy
04:40:17 <Cale> but if you run an IO action on the GHCi prompt and there's no Show instance for the result, or if the result has type (), then it doesn't try to print anything.
04:40:17 <erisco> good, I might be able to figure it out then :P
04:40:35 <Cale> In the old days, the behaviour was more consistent: it just didn't print the results of IO actions at all.
04:40:40 <augur> lengthListish xs = caseListish xs 0 (\x xs -> 1 + lengthListish xs)
04:40:56 <h007> Cale: ok i get it
04:41:05 <b_jonas> doesn't that have the problem that it's not tail recursive?
04:41:18 <augur> 0 is the length of an empty listish, and if the listish thing isnt empty and is instead cons x xs (different xs!), then the result is just the recursive length + 1
04:41:36 <augur> erisco: it might be good to practice turning pattern matching defs into case defs, for known types
04:41:39 <augur> instead of
04:41:47 <augur> length [] = 0 ; length (x:xs) = 1 + length xs
04:41:49 <augur> write it with case
04:41:56 <augur> length xs = ...
04:42:09 <erisco> hold your horses man :D
04:43:06 <erisco> and also what is confusing up front is that the Listy class involves [] in the function signatures
04:43:08 <augur> erisco: just remember: an ADT is constructors + case. and conveniently, the case is directly determined by the constructors.
04:43:17 <augur> erisco: does it? where.
04:43:39 <augur> erisco: not in the version i gave!
04:43:43 <erisco> you said listCase :: [a] -> r -> (a -> [a] -> r) -> r   right?
04:44:12 <erisco> oh
04:44:15 <erisco> caseListish :: f a -> r -> (a -> f a -> r) -> r
04:44:40 <erisco> okay that helps things along a bit :P so let me just try and instance this for [] so I can get up to speed
04:44:44 <erisco> I'll let you know when
04:45:01 <erisco> okay? :) I appreciate the help but I don't want to waste your time by not being able to follow what you are saying next
04:45:52 <augur> erisco: fun fact: all of this is derivable automatically from type defs. in fact, in a Real Language like agda, you can make type defs first class and define this all once and for all, parametric over every data declaration!
04:45:58 <augur> a single case function to rule them all!
04:46:06 <augur> but i digress
04:46:25 <augur> erisco: try playing this same game with other familiar types, tho.
04:46:39 <augur> constructors + case + equations
04:47:20 <augur> bool and nat and maybe are good things to prod for baby steps to list, if you prefer.
04:48:08 <augur> erisco: remember, the point is this: what makes a value what it is, is what you can do with it, which is ultimately just one case or another.
04:48:11 * hackagebot chesshs 0.1.1 - Simple library for validating chess moves and parsing PGN files  http://hackage.haskell.org/package/chesshs-0.1.1 (ArnoVanLumig)
04:48:13 * hackagebot twentefp 0.4.2 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-0.4.2 (ChristiaanBaaij)
04:48:29 <augur> what males nil nil? that you know its nil. what makes cons cons? that you know its cons (and what the head and tail therefore are)
04:48:57 <augur> makes**
04:49:14 <augur> your intuitions about Maybe (a, f a) were exactly correct, but that might be hard to generalize to other types, which is a good intuition to have imo
04:49:21 <h007> mr-: this doesn't seem to work quite well http://lpaste.net/92440
04:50:29 <mr-> h007: you have got the logic the wrong way round.
04:52:05 <haasn> “Real Language like agda”
04:52:06 * haasn chuckles
04:52:22 <augur> haasn: :)
04:52:57 <augur> haasn: i was gonna say Epigram 2 but i figured that would be pushing it :p
04:53:24 <mr-> h007: I think I would do it a bit like that: http://lpaste.net/92444
04:53:42 <augur> haasn: i used to dream in the lambda calculus
04:53:53 <augur> then i learned haskell and dreamt in the polymorphic lambda calculus
04:53:53 <haasn> isn't epigram 2 not yet finished
04:54:08 <h007> mr-: thanks, much cleaner
04:54:09 <augur> (haasn: and never will be, hence why its funny!)
04:54:18 <augur> then i learned agda and dreamt in the dependently typed LC
04:54:46 <augur> then i learned (about) epigram 2, and now i dream in the skyhooks-to-infinity self-hosting DTLC :D
04:54:50 <haasn> heh
04:54:58 <haasn> you make me want to learn epigram
04:55:28 <haasn> but I fear learning a dependently typed language will make it it just as frustrating to write Haskell as learning Haskell makes it frustrating to write, say, C#
04:55:29 <augur> haasn: you first have to become a grumpy irishman
04:55:38 <augur> oh man, haasn, that is so true
04:55:43 <augur> you have no idea
04:55:47 <haasn> I kind of don't want to spoil it for myself :)
04:55:50 <augur> programming in agda has ruined me
04:55:59 <augur> interactive coding is the most amazing thing to ever happen ever
04:56:17 <augur> and the crummy hacks that we have for haskell just aint enough
04:56:33 <Vei1> hi
04:56:39 <Vei1> why can't i
04:56:43 <Vei1> > (-1) 2
04:56:44 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
04:56:44 <lambdabot>    arising f...
04:56:46 <Vei1> but can
04:56:51 <Vei1> > (+1) 2
04:56:52 <lambdabot>   3
04:56:54 <Vei1> ?
04:57:02 <augur> vehk: -1 in that position is interpreted as negation, not subtraction
04:57:05 <mkramer> http://lpaste.net/92446
04:57:07 <augur> > (- 1) 2
04:57:08 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
04:57:08 <lambdabot>    arising f...
04:57:09 <danr> > (subtract 1) 2
04:57:10 <lambdabot>   1
04:57:18 <mkramer> :t replicateM_
04:57:19 <lambdabot> Monad m => Int -> m a -> m ()
04:57:24 <Vei1> augur, danr: ah, thanks.
04:57:26 <danr> @type (-1)
04:57:27 <lambdabot> Num a => a
04:57:29 <danr> @type (subtract 1)
04:57:30 <lambdabot> Num a => a -> a
04:57:34 <augur> any time a - shows up before a single number like that, haskell things its a negative number
04:57:36 <mkramer> replicateM_ stubbornly takes an Int, but I want to an Integer number of replications
04:57:55 <danr> @hoogle genericReplicate
04:58:00 <danr> :(
04:58:07 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
04:59:14 <mkramer> Anything for replicateM?
04:59:27 <apfelbox> You can do ((-) 1) 2, but the order of the arguments is the other way round as you would think ;-)
05:01:02 <mr-> > ((-1) 1) 2
05:01:04 <lambdabot>   Could not deduce (GHC.Num.Num
05:01:04 <lambdabot>                      (GHC.Integer.Type.Intege...
05:01:13 <mr-> > ((-) 1) 2
05:01:14 <lambdabot>   -1
05:02:31 <Rarrikins> > (subtract 1) 2
05:02:32 <lambdabot>   1
05:04:42 <Vei1> mr-: At least it shorter than subtract.
05:05:10 <augur> erisco: when you're brave enough, or have solved the bool-nat-maybe trio: http://lpaste.net/92447
05:05:56 <mkramer> danr: Got it! sequence_ . genericReplicate
05:06:06 <mkramer> thank you
05:07:10 <apfelbox> augur ((-) e) = \x -> x - e
05:07:22 <apfelbox> or use subtract ;-)
05:07:30 <augur> apfelbox: :)
05:07:39 <danr> mkramer: nice!
05:07:42 * augur makes apfelkuchen
05:08:48 <danr> augur: what's the point of these typeclasses with only one instance?
05:09:30 <augur> danr: which where
05:10:34 <danr> augur: boot-nat-maybe trio
05:10:41 <augur> oh, in the link?
05:10:59 <augur> answers to the little puzzles for erisco
05:11:14 <augur> im going to annotate with some magic :)
05:13:04 <augur> danr, erisco: annotated with our favorite warp core engineer!
05:13:40 <haasn> (of course, these type classes are superseded by lenses ;)
05:14:00 <danr> augur: mr. church-encoder
05:14:17 <augur> scott encoder
05:14:39 <augur> haasn: are they? i dont think they are
05:15:31 <augur> danr: but the point is that erisco wanted to know how to convey the idea of being list-like, so i finally caved and gave him a typeclassy thing like he wanted, because he's stubborn :P
05:16:01 <erisco> augur, only because that is what you people require to get any information out :P
05:16:06 <haasn> augur: well eg. Listish can be had with lens's class Cons and a Prism' (l a) () -- or something
05:16:24 <erisco> augur, first I have to weave through the lasers of "well why are you doing that?"
05:16:38 <augur> erisco: you probably dont need this, but you insisted. and anyway, once i remembered the "right" answer, i decided it was better for you to really get this anyway, because its far too cool
05:16:45 <augur> for your purposes, feh, its pointless
05:16:49 <augur> but for KNOWLEDGE
05:16:51 <augur> its damn sexy
05:17:01 <erisco> you do not know what I am using this for
05:17:19 <augur> haasn: oh well sure, if you use some built ins
05:17:29 <augur> but that defeats the purpose of this exercise
05:17:40 <augur> erisco: you said you were trying to implement some silly algorithm yadda yadda blah blah
05:17:48 <erisco> lol
05:18:29 <augur> algorithms are for weirdos who want to actually DO stuff!
05:21:37 <quchen> Algorithms are for weirdos who want to have the computer DO stuff instead of themselves.
05:24:34 <augur> erisco: if you can grok this fact about what an ADT "is", youll be ahead of a lot of people in understanding the truth of FP
05:27:14 <hiptobecubic> what the hell is going on with this bool-nat-maybe trio?
05:27:24 <haasn> augur: (I was only half-serious)
05:27:25 * hiptobecubic isn't ahead of anyone
05:27:26 <haasn> also wow that message took a long time to deliver
05:27:30 <haasn> my internet just cut out for about 10 minutes
05:27:55 <hpc> hiptobecubic: it's exactly what it looks like; a ridiculous solution to a non-problem
05:28:22 <augur> hiptobecubic: what do you mean? :D
05:28:52 <hiptobecubic> hpc, augur what problem are they solving? What's up with Scott? Why did anyone write any of this?
05:29:02 <augur> hpc: indeed. well, its a non-problem in some sense. i mean, i guess if you REALLY want to abstract the notion of list, you do it like this, and then just provide generic isos, but
05:29:28 <augur> hiptobecubic: erisco wanted to know what it really meant to be a list in a generic, type-classy, interface-only way
05:29:44 <osfameron> quchen: algorithms are for people who don't know how to buy ram
05:29:59 <hiptobecubic> or time travel
05:30:02 <augur> so i gave him an explanation, after some tooth-pulling, together with instantiations for the normal types, and some loopy scott encoding versions to show its a magical notion
05:30:16 <hiptobecubic> augur, oh scott encoding is a "thing"
05:30:19 <hiptobecubic> I didn't know
05:30:50 <augur> hiptobecubic: yeah. its how you implement these things in an LC with only lambda terms and primitive recursion
05:31:17 <augur> presumably you'd want names in there somewhere to make the primitive recursion elegant, but you can do without it.
05:32:03 <augur> i wonder if scott + ycombinator is sufficient, or would you need to really do church encodings, i wonder
05:33:08 <augur> i should be cheeky and implement the LC this way
05:33:14 <augur> just to blow eriscos mind :)
05:34:39 <augur> scott and church encodings seem daunting when they're not explained properly. it took me years to really understand them
05:34:44 <mm_freak> repa http://lpaste.net/92449 vs. accelerate+CUDA http://lpaste.net/92450
05:34:53 <mm_freak> if anyone cares to compare repa and accelerate =)
05:35:18 <mm_freak> repa version needs 21s, accelerate version 800ms
05:35:45 <mm_freak> repa on quadcore, accelerate on geforce GTX 550
05:36:25 <mm_freak> wait, repa version needs 6.7 secs when parallelized…  my bad =)
05:36:32 <b__> Why are Doubles used for currency, even in good papers? Just laziness?
05:38:34 <hiptobecubic> b__, because that's not what they are focused on and it will cloud the understanding of lay people?
05:38:47 <b__> hiptobecubic: sounds plausible
05:39:31 <mm_freak> i'm amazed about how well accelerate works despite being purely functional
05:42:07 <hiptobecubic> mm_freak, i think they use skeleton code, yes?
05:42:21 <mm_freak> hiptobecubic: i don't know how they do it
05:42:31 <hiptobecubic> i think that's it, i'd have to read the paper again
05:42:43 <hiptobecubic> I remember it being something like various skeleton kernels that they plug your code into
05:42:53 <mm_freak> that would make sense
05:43:18 <mm_freak> but i remember the dark days using CUDA's hybrid language, where you would have to come up with good parameters
05:43:29 * hiptobecubic still uses it
05:43:46 <hiptobecubic> It's quickly becoming unnecessary for all but the dirtiest stuff, thank god
05:44:32 <hiptobecubic> python's @cuda decorator practically lets you just write normal python syntax
05:45:45 <hiptobecubic> and numba *does* let you work with normal numpy. These are bright days for gpu computing. I will be thrilled when haskell's libs become a little less in the way
05:48:26 <erisco> hpc, haters gunna hate
05:49:05 <augur> erisco: how you doin there
05:49:14 <erisco> went out to get a coffee
05:49:37 <hiptobecubic> It seems like you should be able to translate haskell reasonably well to thrust template-style expressions, but what do i know
05:49:51 <augur> mm coffee
05:50:01 <hiptobecubic> then you have to generate C++ though :(
05:50:10 <mm_freak> hiptobecubic: i understand the need for an expression EDSL for GPU code in haskell
05:50:25 <mm_freak> you're not going to write GPU code in regular haskell
05:50:34 <hiptobecubic> mm_freak, yes of course
05:50:41 <hiptobecubic> mm_freak, have you played with thrust at all?
05:50:57 <hiptobecubic> It tries to bring a lot of <functional> over to the gpu
05:51:09 <mm_freak> nope, never heard of it
05:51:18 <hiptobecubic> It's a major headache to use, but if you are just generating it it might not be terrible
05:51:24 <erisco> augur, ah the slides were describing a wrapper on lists weren't they
05:51:37 <augur> erisco: the AwesomePrelude ones were, yeah
05:51:40 <hiptobecubic> mm_freak, https://github.com/thrust/thrust
05:51:46 <augur> but they give the gist of it
05:52:17 <hiptobecubic> mm_freak, so you get expressions like   int x = thrust::reduce(d_vec.begin(), d_vec.end(), 0, thrust::plus<int>());
05:52:42 <hiptobecubic> which is pretty directly related to fold
05:53:04 <mm_freak> hiptobecubic: omg
05:53:12 <mm_freak> i'll see how far i get with accelerate =)
05:53:27 <mm_freak> thrust doesn't seem to be something i want to use
05:53:36 <hiptobecubic> mm_freak, i didn't say it was pretty :)  But at least it's not totally at odds with the functional paradigm
05:54:41 <mm_freak> yet i'm not sure when i would want to use it
05:55:15 <hiptobecubic> I'm not talking about end users using it really. I mean as a way to get the ugly parts of generating gpu code for free
05:55:45 <mm_freak> ah, now i get it
05:55:59 <hiptobecubic> as in a compiler for Haskell -> thrust for some useful part of your code
05:56:07 <mm_freak> well, you certainly have a point, but that would mean an additional dependency
05:56:24 <mm_freak> not sure if that's appropriate given that the templates are probably rather small
05:56:25 <hiptobecubic> if you have cuda installed you have thrust automatically. nvidia adopted it
05:56:29 <mm_freak> ah
05:56:32 <mm_freak> i see
05:56:44 <mm_freak> well, i noticed that accelerate requires CUDA >= 5
05:57:02 <hiptobecubic> the trick, as always, will be figuring out how to manage persistent values on the gpu
05:57:19 <hiptobecubic> that's recent though. accelerate has been around for at least a few years i think
05:57:38 <hiptobecubic> they are just pushing along to the newest version because there are so many useful features tacked on every time
05:58:15 <hiptobecubic> You couldn't even link separate cuda modules together until recently. they just recommended compiling all your cuda code as one giant blob.
05:58:57 <erisco> augur, so is 'list' around just to assert the laws?
05:59:15 <mm_freak> ugly
05:59:17 <augur> erisco: where what
05:59:29 <mm_freak> i wonder when accelerate will get (useful) OpenCL support
05:59:45 <hiptobecubic> foldr f z v = thrust::reduce(v_.begin(), v_.end(), z, f_maker()) or something
05:59:46 <erisco> augur, sorry you called it 'caseListish'
06:00:04 <hiptobecubic> mm_freak, i emailed about that last year. it was a small project that was more or less abandoned unfortunately :/
06:00:05 <mm_freak> in any case, i'm very pleased…  combine distributed-process + repa + accelerate and build your own supercomputer
06:00:31 <mm_freak> hiptobecubic: yeah, i noticed
06:00:43 <hiptobecubic> no one is working on it now
06:01:44 <erisco> augur, oh, no, I see
06:01:54 <erisco> augur, it gives you a way to pattern match
06:02:03 <augur> erisco: exactly
06:02:10 <erisco> I was mistakenly thinking you'd only give nil or cons to caseListish
06:02:20 <augur> if you abolish primitive pattern matching, you need to make up for it
06:02:37 <augur> some languages actually do it all this way
06:02:52 <augur> so epigram 2, for instance, in some abstract sense, does exactly this
06:03:00 <augur> that is to say, it has exactly these equations under the hood
06:03:06 <augur> and it uses them for rewriting
06:03:27 <augur> and really, in some sense, haskell does this too, but a bit more abstractly, by giving you a generic pattern matching system
06:03:52 <erisco> which doesn't apply to type classes
06:03:59 <erisco> but this scheme does
06:04:04 <augur> erisco: well
06:04:07 <augur> lets be clear
06:04:14 <augur> you can pattern match on some things that are Listish
06:04:21 <augur> but not with the listish pseudoconstructors
06:04:23 <augur> so you cant do
06:04:30 <augur> foo (cons x xs) = ...
06:05:16 <erisco> that is what I meant. a type which is listish can be pattern matched, but any type which is listish cannot
06:05:22 <augur> erisco: the scott encodings show a case where you cant do it at all, tho.
06:05:27 <augur> because its functions all the way down
06:05:33 <erisco> like turtles?
06:05:40 <augur> :)
06:06:18 <augur> erisco: but notice, there is a dreadfully awful pattern here: the case for each thing is defined in the blindingly obvious way for the "real" types
06:06:37 <erisco> so?
06:06:58 <augur> so what thats telling you is that haskell's ADTs are more or less "just" this, at some level
06:07:25 <augur> and that haskell is itself just using ADTs + case/pattern matching to hide these very implementation details
06:07:26 <erisco> when you say ADT I might not be understand what you are saying
06:07:34 <augur> for all we know, haskell's ADTs are just sugar for scott encodings!
06:07:49 <augur> ADTs, the things you write beginning with "data"
06:08:11 <erisco> okay, I've always seen this term with the additional assumption that constructors are hidden
06:08:35 <augur> erisco: sure. the "true" constructors are hidden, in that we cant see what they really are.
06:08:44 <augur> so how do we know they're not scott encodings? or something else? we dont!
06:08:52 <erisco> right
06:11:07 <erisco> augur, you know what the next thing is, right?
06:11:39 <augur> erisco: nope :D
06:12:14 <erisco> do you expect me to tie an algorithm for length directly to the representation?
06:12:15 <erisco> :)
06:12:33 <erisco> its type classes all the way up
06:12:45 <augur> erisco: well, the generic length algo doesnt need to be
06:13:00 <erisco> no, I do not mean having Num instead of Int
06:13:07 <augur> but your special, efficient length algo will need to be. there is no "generic representation-specific" one
06:13:43 <augur> this class abstracts listiness, not representation-specific algos.
06:13:52 <erisco> yes exactly
06:14:05 <erisco> and the algorithm for length on a listy is O(n)
06:14:18 <augur> oh its not O(n) no
06:14:30 <augur> it depends entirely on your implementation
06:14:33 <erisco> true
06:14:43 <augur> because youll be casing and stuff, and if all of that is nasty, then so is length
06:14:47 <augur> now you can ofcourse add further class methods for things like length, so that you can make those generic as well
06:14:49 <erisco> ish?
06:14:54 <erisco> I mean, how can it not be?
06:15:16 <erisco> what other approach than pattern matching on cons can you do?
06:15:36 <augur> erisco: its more that your particular defs might not be so clean
06:15:50 <erisco> you mean the uncons might not be O(1)?
06:15:54 <erisco> okay, yes, agreed
06:16:06 <augur> cons might not be O(1) either
06:16:10 <erisco> yes
06:16:11 <erisco> but
06:16:14 <augur> i mean, maybe there's a theorem here
06:16:16 <augur> i dont know
06:16:24 <augur> i wouldnt expect it to be O(n) just off the bat
06:16:26 <erisco> when we talk about the complexity of a sort algorithm
06:16:37 <erisco> it assumes the comparison is O(1). if it isn't that is an additional consideration
06:16:44 <augur> anyway, if you want to make length a listish method as well, thats fine
06:16:50 <erisco> so length is O(n) wrt the number of cons pattern matches required
06:16:53 <augur> but you're adding more to it than just list structure now
06:17:02 <erisco> no
06:17:05 <erisco> no no
06:17:20 <erisco> this is the essence I really wanted to see all along
06:17:47 <augur> im not sure that adding length would really be problematic. you'd just want to also then have some laws like
06:18:05 <augur> length nil = 0 ; length (cons x xs) = 1 + length xs
06:18:10 <erisco> sure but then it isn't listy :) it is listy + something, which is what I'd be after now then
06:18:24 <augur> and if that happens to be true ANd youve implemented it in O(1) time, fine
06:18:30 <b__> hiptobecubic: (about Double to represent currency in papers and tutorials...) there is almost never a disclaimer that this is "an awful idea", whereas if you ask here in #haskell, the badness is exclaimed by a choir of 20
06:18:39 <erisco> we can only assess complexity wrt the interface
06:18:48 <erisco> this is true regardless of your complexity analysis method
06:18:59 <erisco> you are assuming that some underlying thing or another is behaving a certain way
06:19:12 <augur> erisco: sure, but what im saying is, the interface itself might not be constant for any given operation
06:19:13 <Maior> b__: er what? go work in finance ;P
06:19:17 <augur> cons x xs might not be constant time
06:19:23 <erisco> agreed
06:19:31 <erisco> it can vary depending on the instance, absolutely
06:19:36 <b__> Maior: care to elaborate? ^^
06:19:39 <hiptobecubic> b__, true. I'm sure there is a strong establishment of people using double's regularly now.
06:19:46 <augur> so we're talking about a very flexible notion of O(n) which i think is invalid for complexity reasoning
06:20:02 <erisco> I don't
06:20:11 <augur> well you should think more about it
06:20:18 <erisco> I'm not an authority on the theory, but I haven't been convinced of a compelling case why not
06:20:20 <Maior> b__: I'm new to Haskell, but everywhere I've ever seen someone try to use floating point for currency, others have told them they're crazy and to not...
06:20:33 <hiptobecubic> b__, I will say, at the bank I was at, doubles were used for everything except the accounting itself. All the pricing algorithms etc were just simulations so fixed point arith wasn't what you wanted
06:20:44 <int-e> augur: you can always talk about doing O(n) foo operations.
06:20:45 <augur> erisco: well, usual complexity reasoning assumes that you have some well-defined cost metrics on the basic operations involved
06:21:08 <b__> hiptobecubic: ok, interesting
06:21:13 <erisco> augur, yes, and the interface is not where those operations/implementations are :)
06:21:38 <erisco> augur, and even looking at the implementation, there are underlying factors to that as well
06:21:59 <augur> erisco: yes but its no fair saying that it's O(n) if your operations dont give you some constant factor
06:22:01 <erisco> "length for listy is O(n) assuming blah and blah is O(1)" is not unreasonable
06:22:16 <erisco> any more than saying "assuming malloc is usually O(1) this algorithm is O(n)"
06:22:38 <erisco> augur, implication. I don't need to doubleback on any claim
06:22:38 <augur> erisco: but my point is that "blah is O(1)" isn't a given
06:22:44 <b__> hiptobecubic: the lack of precision was generally not a problem?
06:22:52 <erisco> that is why IF this is O(1) THEN this follows
06:23:05 <augur> if "blah" is "nil and cons are constant time" fine
06:23:14 <augur> but what if they're not? i dont know.
06:23:32 <erisco> then the claim doesn't follow
06:23:39 <Kaini> I've a function :: StateT s IO (), could I somehow "partially apply" the state, that I get a function' :: IO (), which I can subsequently pass into anotherFunction :: IO () -> IO () as callback? Or am I forced to change anotherFunction to :: StateT s IO () -> StateT s IO () (Which means that I need huge amounts of liftIOs)
06:23:39 <erisco> simple
06:23:55 <augur> erisco: indeed. so you cant reason without these extra, non-given assumptions
06:23:57 <augur> anyway, i should sleep
06:23:59 <augur> night!
06:24:04 <erisco> yes you can
06:24:09 <erisco> don't be silly :)
06:24:37 <erisco> g'night thanks for the help
06:24:44 <augur> erisco: you can reduce it to maybe O(n) primitive operations, but not to O(n) actual time
06:24:57 <augur> and those are very different concepts
06:25:07 <erisco> do you realize the number of assumptions it takes to claim something is O(n) real time?
06:25:28 <augur> erisco: sure, but so what?
06:25:39 <erisco> so there is no reason we can't play the same game
06:25:56 <augur> i mean, i can be perverse and make my cons the normal cons, but with a 2^n forced delay
06:26:05 <erisco> yes! you can!
06:26:17 <augur> cons x xs = wait (2^n) then return x:xs
06:26:23 <augur> now you dont have O(n) time!
06:26:23 <erisco> and I can take your proven O(n) algorithm and run it on my OS with a forced O(2^n) delay
06:26:31 <augur> you just have O(n) steps, or something.
06:26:34 <erisco> yes
06:26:38 <erisco> that is what big-O is based on
06:26:45 <augur> eh..
06:26:54 <augur> i dont think thats the case
06:26:59 <hiptobecubic> b__, well when you are working with very large and very small numbers, double *saves* your precision. It's hard to represent 1e-16 in fixed point arithmetic but you might need it if you are integrating over a large probability density or something
06:26:59 <augur> but whatever, im going to sleep. :P
06:27:08 <erisco> mm, I'd take a look if you are unsure. I'm sure :)
06:27:34 <hiptobecubic> b__, also, these simulations can already take days. using bignumber libraries is just not an option
06:38:27 <hari_> :data Token = Token String
06:42:00 <hari_> When I define myfunc (Token s)  = s in ghci it gives a parser error on =
06:43:06 <Twey> hari_: GHCi is basically a big do-block.  You need to use ‘let’ if you want to define stuff.
06:43:25 <hari_> Twey, thanks.
06:44:21 <jdoles> If Haskell is so productive, why isn't ghci a real Haskell interpreter after more than a decade?
06:44:52 --- mode: ChanServ set +o elliott
06:45:00 <elliott> jdoles: please quit the blatant trolling
06:45:20 <elliott> you've been banned before, no excuse, it's ridiculous.
06:46:32 <jdoles> elliott: it seems ridiculous to continue to say that Haskell is so productive when nobody can't even work out a working interpreter in a short timeframe.
06:46:33 <b__> hiptobecubic: thanks
06:47:00 <jdoles> elliott: but, if you feel that someone showing you a mirror should be banned, then go right ahead.
06:47:10 <mbrock> haha
06:47:24 <elliott> ok.
06:47:27 --- mode: elliott set +b $a:jdoles
06:47:28 --- kick: jdoles was kicked by elliott (jdoles)
06:47:28 <b__> jdoles, where do I buy http://themagicwarehouse.com/az7082.jpg ?
06:47:30 --- mode: elliott set -o elliott
06:47:32 <hari_> One doubt. I had the impression that let is used for binding a name to an expression's result.
06:47:58 <hari_> How come it is also used to define functions?
06:48:16 <fryguybob> elliott looks in the mirror and likes what he sees.
06:48:18 <mbrock> just a little syntactic sugar
06:48:24 <b__> "The Mirror Laughs When Anyone Looks Into It"!
06:49:59 <hari_> OK, need to look up haskell docs for the keyword meanings
06:51:09 <mbrock> you could see "let X = Y" as meaning "make it so that X means Y", and then "let f x = x + 1" means "make it so that f x means x + 1" which makes sense
06:51:38 <b__> hiptobecubic: I won't be doing extremely expensive computations, but I guess Doubles are still practical. As long as there are no major discrepancies between fixed and floating point calculations
06:52:22 <hari_> mbrock, thanks for the explanation
06:54:19 <mbrock> np!
06:55:55 <hiptobecubic> b__, well what are you doing? If you are doing account balancing then used fixed. If you are doing "computational finance" which is basically physics with different names for things then things are done in double precision
07:01:26 <akegalj> i cant figure out what is Typeable class used for?
07:02:01 <elliott> runtime type information / dynamic typing type stuff
07:02:42 <hari_> suppose I use a function that returns Maybe String, what is the quick way to extract the value from the Maybe type?
07:03:17 <quchen> :t Data.Maybe.fromMaybe -- hari_
07:03:17 <akegalj> hari_: fromMaybe
07:03:17 <lambdabot> a -> Maybe a -> a
07:03:24 <b__> hiptobecubic: thanks for clearing that up :)
07:03:33 <quchen> > fromMaybe 0 (Just 10)
07:03:34 <lambdabot>   10
07:03:36 <quchen> > fromMaybe 0 Nothing
07:03:37 <lambdabot>   0
07:03:44 <b__> I'm doing both, but I should probably seperate them
07:03:44 <hari_> quchen, and akegalj : thanks
07:04:14 <hari_> I should really get back to reading. I keep forgetting everything I learn when jump to a new concept.
07:04:18 <eyebloom> Can anyone explain why 'lets' are part of most core languages? I understand the need for letrecs but most plain lets seem to just be simultaneous abstraction and application.
07:04:31 <akegalj> elliott: what do i get when declaring something with Typeable. I can't see advantages of it :/
07:04:39 <dmwit> eyebloom: let is more polymorphic than lambda
07:04:48 <dmwit> > let x = 3 in (x, x) :: (Int, Double)
07:04:50 <lambdabot>   (3,3.0)
07:04:53 <hiptobecubic> b__, definitely separate them. The accounting side is important and shouldn't be mixed up
07:05:00 <dmwit> > (\x -> (x, x)) 3 :: (Int, Double)
07:05:01 <lambdabot>   Couldn't match type `GHC.Types.Int' with `GHC.Types.Double'
07:05:01 <lambdabot>  Expected type:...
07:05:38 <b__> hiptobecubic: okay. thanks :)
07:05:44 <haasn> > getLine
07:05:45 <lambdabot>   <IO [Char]>
07:05:46 <haasn> ^- uses Typeable
07:05:47 <eikke> akegalj: see the docs of Data.Typeable and Data.Dynamic
07:05:51 <eyebloom> I see. Do you think that is the main reason?
07:06:25 <dmwit> yes =)
07:06:40 <eikke> haasn: huh?
07:06:41 <haasn> wait, I'm having a look at Data.Typeable right now; gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b) -- isn't this blatantly unsafe when c is a type family?
07:06:42 <akegalj> eikke: ok, i will read it
07:07:01 <haasn> eikke: instance Typeable a => Show (IO a) -- for lambdabot
07:07:09 <dmwit> haasn: I don't think type variables ever get instantiated to families.
07:07:22 <haasn> dmwit: oh, right
07:07:25 <eikke> haasn: aah, like that, OK
07:07:27 <haasn> that makes sense
07:07:54 <eikke> haasn: I thought you implied getLine uses Typeable-functionality somehow
07:08:12 <haasn> not at all, sorry :)
07:08:37 <eyebloom> dmwit: Thanks. I finished reading "Types and Programming Languages" a few months ago and I was wondering if anyone could recommend another good book on this topic?
07:08:39 <eikke> akegalj: note in GHC 7.8, Typeable1/2/... will no longer exist, things changed around a bit
07:09:52 <erisco> why is this notation invalid Haskell?   class (Integral b, Listish f b) => Countish (f b) where
07:11:19 <haasn> erisco: if you're referring to http://lpaste.net/92447 it's because Listish only has one parameter
07:11:23 <McManiaC> erisco: you usually define dependencies for class instances
07:11:26 <dmwit> erisco: Perhaps you'd like class (...) => Countish f b where
07:11:39 <McManiaC> oh
07:11:42 <Sculptor> oh? hi
07:11:50 <josephle> eyebloom: Practical Foundations for Programming Languages by Bob Harper if you want a slightly different take on the basics, Advanced Topics in Types and Programming Languages to see some more interesting stuff
07:11:54 <haasn> erisco: in which case you'd want class (Integral b, Listish f) => Countish (f b) -- or whatever
07:11:56 <McManiaC> erisco: did you mean Listish (f b) ?
07:12:29 <erisco> Countish is kind * -> * -> * and Listish is * -> *
07:12:42 <erisco> the extra * on Countish is the Inegtral
07:12:56 <dmwit> erisco: I'm sure you meant Countish is kind * -> * -> Constraint and Listish is * -> Constraint...
07:13:41 <dmwit> erisco: If that's the case, then you're really hosed, because you've asked f to be a type, but you're trying to hand Listish two types.
07:13:55 <dmwit> erisco: So perhaps you even meant Countish is kind (* -> *) -> * -> Constraint...?
07:13:56 <erisco> no just one
07:14:33 <erisco> if Listish is * -> *, then I'd expect * -> * -> * can be Listish provided I supply one type
07:14:41 <erisco> which is what I did
07:15:05 <dmwit> erisco: If you expect f :: * -> * -> *, then f cannot be an argument to Countish :: * -> * -> Constraint.
07:15:48 <haasn> erisco: are you referring to http://lpaste.net/92447 ?
07:15:56 <haasn> the Listish there has kind (* -> *) -> Constraint
07:15:58 <erisco> haasn, yes
07:16:01 <dmwit> erisco: (...and I'm pretty sure all arguments to class declarations have to be type variables.)
07:16:09 <haasn> which means ‘f’ has kind * -> *
07:16:27 <haasn> and your definition would work, given Countish :: * -> Constraint
07:16:33 <haasn> I mean, my definition
07:18:16 <eyebloom> josephle: Thanks
07:19:34 <haasn> oh
07:19:37 <haasn> whoops
07:19:46 <haasn> I thought were were meaning ‘instance’ not ‘class’ sorry
07:20:08 <haasn> it would be class Countish x; instance (Integral b, Listish f) => Countish (f b)
07:20:13 <erisco> maybe this makes my intent clearer
07:20:25 <erisco> (Integral b, Listish (f b)) => Countish f
07:21:29 <dmwit> haasn: Again, the RHS of the => is almost certainly going to have to be Countish f b
07:22:02 <haasn> both work, as far as being valid Haskell is concerned
07:22:23 <erisco> this is perplexing
07:22:37 <haasn> I think it would be a lot easier if erisco told us what he actually wants to achieve
07:22:39 <dmwit> haasn: No, they don't. =)
07:22:53 <erisco> haasn, I can't be much clearer than the pseudo code
07:22:55 <dmwit> haasn: (Perhaps you're confusing class declarations and instance declarations again!)
07:23:17 <mbrock> what operations do you want for Countish?
07:23:35 <haasn> GHCi accepts “class Listish (f :: * -> *); class Countish x; instance (Integral b, Listish f) => Countish (f b)”
07:23:42 <haasn> meaning it's valid Haskell O.o
07:23:54 <dmwit> haasn: That's an *instance*.
07:24:12 <dmwit> Oh, you suggested to use it as an instance.
07:24:14 <dmwit> Well. Okay.
07:24:22 <Eduard_Munteanu> Hmmm... what happens if a typeclass member has a constraint which cannot be satisfied for a particular instance? Does GHC stop telling you to define it?
07:24:27 <dmwit> But if there's only ever going to be one instance, why bother making a class...?
07:24:31 <haasn> and I thought you were responding to my suggestion to use it as an instance :P
07:24:36 <Eduard_Munteanu> I mean, does GHC do anything special?
07:24:41 <haasn> yeah fair point. I really don't know what erisco is doing
07:24:57 <erisco> (Integral b, Listish f) => Countish f b   is certainly not what I want
07:25:26 <Eduard_Munteanu> I think I want a constraint-level negation.
07:25:43 <dmwit> Eduard_Munteanu: Maybe you want closed type families!
07:25:59 <Eduard_Munteanu> dmwit: you mean I should just use a GADT?
07:26:02 <erisco> 'f' for Listish is * -> *.  'g' for Countish is * -> * -> *. therefore, 'g b' should be * -> *, and therefore 'g b' can be Listish
07:26:28 <Eduard_Munteanu> Not sure what closed type families are otherwise.
07:26:46 <dmwit> Eduard_Munteanu: Closed type families are a new extension, only available in HEAD at the moment.
07:27:06 <erisco> if this is confusing then I don't know what else to say
07:27:10 <Eduard_Munteanu> dmwit: hmm... so is it like a GADT except it does automatic resolution like typeclasses?
07:27:20 <Eduard_Munteanu> I'm only guessing.
07:27:50 <dmwit> Hm. I don't think it's very like a GADT. It's like a type family, except you can write overlapping clauses and they're resolved in order.
07:28:09 <mbrock> erisco: if you give an example of an operation you want the class to have, perhaps someone can show how to implement it in another way
07:28:12 <dmwit> e.g. type family Isn'tBool where instance Isn'tBool Bool = False; instance Isn'tBool a = True
07:28:13 <Eduard_Munteanu> Oh hm. That seems useful.
07:28:20 <Eduard_Munteanu> Haha...
07:28:31 <Eduard_Munteanu> That's a lot like type functions (literally) in Agda.
07:28:45 <dmwit> This looks a bit like negating the (a ~ Bool) constraint, which is why I suggested it.
07:28:54 <dmwit> Perhaps it can be used for whatever it is you are wishing to negate, as well.
07:29:05 <Eduard_Munteanu> I was implementing a type-level Maybe.
07:29:12 <haasn> yeah, a class declaration on its own is usually rather useless (until you start mixing in MPTCs and FunDeps)
07:29:27 <Eduard_Munteanu> And wasn't sure how to do a 'maybe'-like decider.
07:30:01 <haasn> closed type families are a blessing
07:30:02 <erisco> mbrock: length :: f b a -> b
07:30:14 <haasn> I had to switch to ghc 7.7 when implementing my units library :P
07:30:39 <hari_> >map toTitle "this is a test"
07:30:40 <dmwit> erisco: What if you just write class Countish f where length :: f b a -> b -- ?
07:30:41 <ocharles> haasn: units library?
07:30:43 <erisco> mbrock, seems I might use  (Integral b) => f a -> b
07:31:01 <haasn> ocharles: http://hub.darcs.net/nand/units
07:31:59 <mbrock> erisco: that sounds like it should be possible
07:32:03 <ocharles> haasn: but there are already some of these libraries, what's new?
07:32:40 <ocharles> oh, yours is probably one I'm thinking of
07:32:40 <ocharles> since it's been in dev since 2012
07:32:51 <hari_> \map toTitle "this is a test"
07:33:00 <hari_> \ map toTitle "this is a test"
07:33:03 <haasn> ocharles: I'm not sure what's new or not; I implemented this as a fun project to get experience working with type families
07:33:08 <dmwit> hari_: > is the right character. But you need a space.
07:33:16 <hari_> > map toTitle "this is a test"
07:33:17 <lambdabot>   "THIS IS A TEST"
07:33:24 <haasn> plus, it's handy in physics class :)
07:33:29 <hari_> dmwit, thanks.
07:33:29 <ocharles> haasn: :)
07:33:53 <haasn> ocharles: one of the main things it provides is a very clean API, I guess; since it uses neat typeoperators instead of confusing MPTCs and stuff
07:34:05 <ocharles> haasn: have you thought about offering Iso's between units?
07:34:18 <haasn> ocharles: 30 meter / 5 second :: Double :@ Meter/Second -- type can be inferred, of course
07:34:33 <ocharles> that is nice :)
07:34:46 <haasn> ocharles: I haven't touched the library since the programming competition I entered it in :P
07:35:02 <ocharles> haasn: Maybe I'll have a play about adding more edwardk dependencies to it and seeing what happens ;)
07:35:46 <haasn> feel free, if you really care then I might as well upload the local changes that I have on my netbook
07:35:48 <Eduard_Munteanu> I think this will do though... class (TyMaybe t a) => TyMaybeDecide n j t a where; instance TyMaybeDecide n j TyNothing n where; instance TyMaybeDecide n j (TyJust a) (j a) where
07:36:35 <ocharles> haasn: just an idea, truth be told I'm not sure i'll get round to it
07:36:38 <ocharles> at least not for a while
07:36:59 <haasn> faire nough
07:37:32 <haasn> also no guarantees it's easy to build, I ran it using some GHC 7.7 from december 2012
07:38:10 <ocharles> I don't have GHC > 7.6 yet, because the GHC HEAD expression in NixOS is broken
07:38:45 * hackagebot friendly-time 0.3 - Print time information in friendly ways  http://hackage.haskell.org/package/friendly-time-0.3 (PatrickBrisbin)
07:39:09 <epta> ocharles: you are using nixos as a desktop os?
07:39:23 <haasn> ocharles: http://hub.darcs.net/nand/units/browse/src/Units/SI.hs line 88 could be changed to an Iso I guess
07:40:14 <erisco> mbrock, that definition seems troublesome
07:40:31 <hari_> One of the difficulties I have encountered in learning Haskell is understanding syntax, the type system and libraries come in the way of learning the primitive concepts.
07:40:37 <erisco> it requires the implementor be able to return any Integral type
07:43:21 <hari_> Every time I try to grasp a new concept, the syntax complexity or something in the type system, I feel like I hit a road block and need to go back.
07:43:22 <ocharles> epta: yea
07:44:16 <erisco> dmwit, this is fine, and is what I had, but the Listish constraint is lost
07:44:22 <hari_> And many tutorials seem to use monads a lot. Example, every parser implementation seems to be monadic.
07:44:55 <ciaranm> parsers as monads is beauty
07:45:00 <hari_> It kind of hinders my learning the basics when I try to solve a problem in my own mind in a functional way.
07:45:34 <Eduard_Munteanu> Actually I need one more type variable for the result.
07:46:14 <erisco> can you only constrain the class type to another class with the same... type arity?
07:46:46 <hari_> ciaranm, I am not against monads in particular, though they make my head ache trying to figure them out. The ony thing is that I am somebody who likes to get down to the primitives in order to understand concepts.
07:48:11 <hari_> I am yet to understand the Haskell "primitives" fully. And what is why concepts like monads seem beyond my reach. Problem is, there seem to be no tutorial that doesn't use monads at some point. Especially for the non-trivial problems
07:49:17 <geekosaur> you should not be trying to figure them out yet if you're new to haskell. really
07:49:24 <hari_> I agree that it is not good to reinvent the wheel, but I am somebody who needs to "re-invent" in order to learn a concept fully. This is where I face difficulties finding a good reference.
07:49:25 <ciaranm> hari_: monads are a primitive. or rather, functors are a primitive.
07:49:28 <erisco> IO is overrated
07:49:31 <geekosaur> you can only develop an intuition for them by *using* them
07:49:58 <allsystemsarego> hi all, http://lpaste.net/92451 please code-review my custom XML parser
07:50:03 <ciaranm> i dunno. my intuition for monads came from learning category theory.
07:50:14 <Tekmo> hari_: The primitive `IO` commands all map to FFI calls or GHC built-ins
07:50:43 <hari_> I don't have a mathematics background though.
07:50:51 <Tekmo> hari_: You don't need one
07:52:00 <Rarrikins> hari_: Are you using do notation with them?
07:52:00 <hari_> Not sure if I am making myself understood in the context.
07:52:27 <hari_> do notation for?
07:52:33 <Rarrikins> hari_: For using a monad.
07:52:38 <Tekmo> hari_: What's your specific question about `IO`?
07:52:47 <hari_> Not about IO.
07:53:04 <geekosaur> ciaranm, that's using them, just in a CT context instead of a Haskell one :)
07:53:22 <Tekmo> So, as far as Haskell primitives go, there are three basic primitive concepts
07:53:31 <Tekmo> Lambdas, case statements, and type classes
07:53:31 <hari_> My question was, how do I grasp functional programming and the type system independently so that I can advance?
07:53:45 <erisco> by not starting with monads
07:53:54 <ciaranm> haskell's type system fits on a t-shirt
07:53:59 <Tekmo> I think you need a more specific question
07:54:26 <hari_> OK, I wanted to figure out how to write a basic parsing without using monads, but couldn't find any tutorial
07:54:40 <erisco> hari_, you are in luck. I just wrote a paper on parsing :)
07:54:43 <haasn> ciaranm: got any examples? :)
07:54:49 <hari_> I do understand parsing
07:54:53 <erisco> hari_, you do not need monads
07:55:00 <Tekmo> Yeah, you don't need monads
07:55:04 <hari_> erisco, it certainly seems a popular topic in haskell. :)
07:55:05 <erisco> hari_, you just need functions
07:55:19 <Tekmo> The simplest type of parser I can think of is:
07:55:21 <ciaranm> haasn: http://mumble.net/~campbell/images/HM-t-shirt.png
07:55:28 <Tekmo> type Parser a = String -> Maybe (a, String)
07:55:40 <erisco> hari_, well don't conflate issues. if you want to learn monads, then learn monads. if you want to learn Haskell as a beginner, don't start with an advanced topic such as monads
07:55:47 <erisco> if you want to make a parser, you don't need monads
07:55:51 <erisco> I would know ;)
07:56:10 <ciaranm> you don't need monads, but a parser without monads is like a spaceship without a holodeck
07:56:13 <hari_> erisco, isn't the parsec and attoparsec monad based?
07:56:13 <haasn> ciaranm: heh :)
07:56:20 <haasn> saved for future use
07:56:34 <erisco> hari_, things aren't "monad based" per se
07:56:38 <Tekmo> hari_: That's a function which takes a `String` to parse and then either: A) returns `Nothing` if the parse fails, or B) Returns a parsed value of type `a` along with the unconsumed leftovers
07:57:02 <erisco> hari_, monad is not a dependency like a library. it is like an interface you can express computations with
07:57:16 <hari_> erisco, ok.
07:57:16 <Tekmo> Here's an example of a parser which consumes the first character of the input and never fails:
07:57:24 <Tekmo> hari_: anyChar :: Parser Char
07:57:29 <erisco> hari_, it may be that those parsers follow an interface that is a monad
07:57:38 <Tekmo> hari_: Sorry, it can fail
07:57:43 <Tekmo> hari_: If the string is empty
07:57:48 <erisco> hari_, but as I said, you do not need monads, or any equivalent interface
07:57:59 <Tekmo> hari_: anyChar str = case char of [] -> Nothing; c:cs -> Just (c, cs)
07:57:59 <erisco> hari_, but you will want Applicative :)
07:58:03 <hari_> So I am not using monads if I use the do notation?
07:58:30 <Tekmo> You are definitely using monads if you use do notation
07:58:55 <haasn> > do 3 + 4 -- like here
07:58:56 <lambdabot>   7
07:59:01 <ciaranm> unless you're doing something stupid using do notation!
07:59:03 <haasn> just kidding :)
07:59:29 <erisco> hari_, and you want to start with your main idea first and worry about what interface suites it afterwards, likely
07:59:32 <haasn> but yeah any non-trivial do block desugars to Monad functions
07:59:52 <erisco> I can't think of a good reason to say "I want to solve X but if it isn't a monad then it isn't a solution"
07:59:58 <hari_> erisco, agreed.
08:00:18 <Tekmo> hari_: Under the hood, all parsing libraries are just functions of strings
08:00:28 <Tekmo> hari_: The monad is just automating a lot of boring state passing
08:00:32 <erisco> hari_, I started my parser without Monad or Applicative, but the functions I defined ended up naturally following the interface of Applicative
08:00:44 <erisco> hari_, so I simply used the functions I already had to define an instance of Applicative
08:00:50 <hari_> OK, thanks.
08:00:51 <Tekmo> hari_: But if you skip using the monad you can do everything yourself just by threading state and error handling throughout your computation
08:01:10 <hari_> That means passing around the state of the world in a function argument right?
08:01:12 <erisco> Tekmo: "all parsing libraries are just functions of strings" this isn't true
08:01:13 <absence> will traversing a++b++c++d happen in linear time due to laziness?
08:01:25 <Tekmo> erisco: Well, the ones he is interested in are
08:01:35 <erisco> mm, they might not be. I don't know
08:01:41 <tomejaguar> absence: unfortunately not
08:01:52 <Tekmo> hari_: No, not the state of the world
08:01:58 <erisco> but string is [Char], and there is no reason for Char, and not necessarily a reason for [] either
08:02:04 <Tekmo> hari_: In these parsers, the state that is being passed around is the unconsumed string input
08:02:08 <opqdonut> absence: it will, because ++ associated to the left: a++(b++(c++d))
08:02:16 <Tekmo> erisco: I meant text in general
08:02:20 <tomejaguar> opqdonut: it will?
08:02:24 <hari_> Telkmo, OK
08:02:27 <erisco> Tekmo, well again, no :)
08:02:33 <erisco> Tekmo, you can parse a list of integers
08:02:33 <opqdonut> tomejaguar: yes
08:02:37 <erisco> for instance
08:02:38 <Tekmo> erisco: Yes, I know
08:02:40 <tomejaguar> opqdonut: oh, ok :)
08:02:50 <opqdonut> tomejaguar: head ((x:xs)++ys) ==> x:head (xs++ys)
08:02:53 <opqdonut> tomejaguar: get it?
08:02:55 <tomejaguar> yup
08:02:57 <Tekmo> I wrote the article about using parsers to parse chemical substructures: http://www.haskellforall.com/2012/10/parsing-chemical-substructures.html
08:03:12 <absence> opqdonut: great, thanks :)
08:03:16 <Tekmo> But I'm sticking to the libraries he is referring to
08:03:22 <hari_> One question about the attoparsec module
08:03:46 * hackagebot hat 2.8.0.0 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.8.0.0 (OlafChitil)
08:03:51 <hari_> Where is it appropriate to use do notation on the parsing function and when should I use <|>
08:04:10 <merijn> hari_: When it's more readable
08:04:12 <Tekmo> hari_: p1 <|> p2 means to try `p1` and if it fails then to try `p2` instead
08:04:15 <erisco> hari_, you are putting the cart way before the horse
08:04:44 <erisco> Tekmo, hari_ this is not a necessary definition of <|>
08:04:50 <Tekmo> erisco: Right
08:05:07 <merijn> Tekmo: I guess the release of pipes 4 means the API of the pipes-safe library is officially stable?
08:05:17 <merijn> -ish
08:05:20 <Tekmo> `pipes-safe` is pretty much stable
08:05:35 <Tekmo> I don't anticipate any changes unless somebody finds a huge bug in it
08:05:42 <hari_> erisco, whenever I try to learn one concept, I hit three roadblocks in the form of other advanced concepts. Like that one. That's why I don't know where to start.
08:05:51 <merijn> Good, then I can finish updating my stuff to use pipes :>
08:05:55 <Tekmo> merijn: :)
08:06:06 <erisco> hari_, functions. start with functions
08:06:09 <Tekmo> hari_: You start by solving a specific problem
08:06:18 <erisco> hari_, and for evaluating your programs, just use ghci
08:06:30 <Tekmo> hari_: You need to answer a specific question, otherwise you won't have anything concrete to guide your understanding
08:06:46 <merijn> hari_: Functions and types, focus on those. Then when those are comfortable, expand to typeclasses.
08:06:54 <Tekmo> hari_: Instead of saying "Should I use monads here?", you should instead ask "What am I trying to accomplish?"
08:07:41 <merijn> hari_: Most problems I see with advanced concepts come from people glossing over/not fully understanding types before moving on to typeclasses and then becoming hopelessly lost as they try to explore advanced concepts without being able to use the types as a stable ground to start from :)
08:07:46 <Maior> so trying to install frag with cabal, I'm getting https://gist.github.com/doismellburning/6413876 which is presumably some kind of FFI-y issue, but I've no idea how to cajole it into working...
08:08:41 <hari_> i seem to understand types when the concept is introduced in tutorials.
08:08:43 <merijn> Maior: Looks like the definition of GLFloat changed to something that doesn't match the FFI, but no one updated the package
08:08:49 <dcoutts_> Maior: more likely it's a change in the GL binding package that frag has not been updated for
08:08:55 <hari_> But when used in actual code, I start getting a lot of confusion.
08:09:02 <erisco> then guess what :)
08:09:28 <Tekmo> hari_: What previous programming language are you coming from?
08:09:46 <hari_> I know Python, C
08:09:51 <Tekmo> Ok, then let's use C
08:09:52 <hari_> Some subset of C++
08:09:57 <Tekmo> Since C hsa type signatures, sort of
08:10:03 <merijn> hari_: Practice writing them in addition to just reading them. I'm a big advocate of doing manual type inference on paper as a learning exercise (i.e. substituting type variables with "real" types)
08:10:07 <monoidal> Maior: does it work if you replace `r00` with `GLFloat r00`?
08:10:14 <Tekmo> hari_: Take the sin() function for example
08:10:25 <Tekmo> hari_: double sin(double angle)
08:10:38 <Tekmo> hari_: The equivalent Haskell type for that would be: sin :: Double -> Double
08:10:47 <hari_> OK
08:10:48 <erisco> is there some compiler extension for  class (Integral b, Listish (f b)) => Countish f b  ? I can't see why this wouldn't be permissable
08:11:07 <Tekmo> hari_: The difference between Haskell and C is that Haskell separates the argument list from the type
08:11:23 <hari_> Tekmo, ok
08:11:26 <merijn> erisco: You need at least MPTC and FlexibleInstances for that, I think
08:11:39 <erisco> merijn, MPTC?
08:11:46 <merijn> erisco: MultiParameterTypeClasses
08:11:47 <Tekmo> hari_: You know how C lets you declare function prototypes wihtout argument names, right?
08:11:55 <Tekmo> hari_: Like: double sin(double)
08:12:00 <hari_> Tekmo, yes
08:12:01 <Maior> monoidal: not in scope, though the import suggests it should be... will look around for more
08:12:04 <Tekmo> hari_: It's just like that
08:12:08 <erisco> marijn sorry I said that wrong
08:12:18 <erisco> class (Integral b, Listish (f b)) => Countish f
08:12:19 <Tekmo> hari_: In Haskell a type signature is like a function prototype from C, if you squint :)
08:12:29 <hari_> Tekmo, yes, I understand that :)
08:12:32 <Tekmo> hari_: Ok, good
08:12:34 <erisco> it rejects Listish (f b) syntatically
08:12:35 <merijn> erisco: How should the compiler select the instance of b to use?
08:12:41 <Tekmo> hari_: The difference is that in Haskell you can have much richer types
08:12:45 <merijn> erisco: Paste the error?
08:13:00 <Tekmo> hari_: In C you are limited to the primitive types, like `int`, `double`, `char`, etc. and structs
08:13:06 <Tekmo> hari_: And pointers
08:13:16 <erisco> merijn, based on usage? not sure where the counter example lies
08:13:25 <hari_> ok
08:13:27 <Tekmo> hari_: In Haskell, you have two new things that C does not have
08:14:11 <Tekmo> hari_: One unique thing is "sum types" (i.e. like `Either` and `Maybe`), which are like tagged unions in C but much better
08:14:32 <hari_> OK
08:14:37 <Tekmo> hari_: Actually, make that three new things
08:14:37 <merijn> erisco: It can't select it based on usage, b doesn't appear in the typeclass constraint of Countish
08:14:45 <Tekmo> hari_: The next new thing are generics, like C++ generics
08:14:53 <arkeet> but better
08:15:01 <Tekmo> hari_: We call them "parametric polymorphism", but generics is the same basic idea
08:15:18 <hari_> OK
08:15:18 <merijn> erisco: You're claiming "Countish f" exists for any b that is Integral and for which "f b" is an instance of Listish, but if there are multiple b's like that, what should it do?
08:15:26 <Tekmo> hari_: Whenever you see a lowercase type variable in a type signature, that's a generic type
08:15:31 * arkeet does not have fond memories of C++ templates
08:15:36 <Tekmo> hari_: For example, use the type signature from the `id` function
08:15:38 <Tekmo> hari_: id :: a -> a
08:15:39 <arkeet> :t id
08:15:40 <lambdabot> a -> a
08:15:44 <Tekmo> hari_: That `a` is generic
08:15:49 <hari_> OK
08:15:49 <Tekmo> hari_: It can be any type
08:15:56 <arkeet> :t map
08:15:57 <lambdabot> (a -> b) -> [a] -> [b]
08:16:03 <merijn> :t id `asAppliedTo` 'c'
08:16:03 <lambdabot> Char -> Char
08:16:08 <merijn> :t id `asAppliedTo` True
08:16:09 <lambdabot> Bool -> Bool
08:16:16 <arkeet> :t id `asAppliedTo` id
08:16:17 <lambdabot> (a -> a) -> a -> a
08:16:17 <Tekmo> hari_: Do you have any questions so far?
08:16:43 <hari_> None so far
08:16:47 <t7> @djinn (a -> a) -> a -> a
08:16:47 <lambdabot> f a = a
08:16:50 <hari_> thank you for your patience.
08:16:53 <merijn> erisco: You could get it to work, but only if you use FunctionalDependencies to force that every 'f' can have only one 'b'
08:16:54 <Tekmo> hari_: The last new thing is that types can take other types as arguments
08:17:04 <Tekmo> hari_: For example, check out the type of `getLine`
08:17:04 <erisco> merijn, sorry I still don't understand the objection :(
08:17:06 <arkeet> t7: (a -> a) -> (a -> a)  ~  Nat
08:17:07 <Tekmo> :t getLine
08:17:16 <Tekmo> hari_: Just ignore the fact that it is `IO` for a second
08:17:17 <hari_> > :t getLine
08:17:18 <Tekmo> > :t getLine
08:17:26 <t7> @djinn (a -> b) -> (b -> c) -> (c -> d) -> a -> d
08:17:32 <Tekmo> Well, I'll write it out
08:17:34 <Tekmo> getLine :: IO String
08:17:35 <merijn> erisco: Suppose your code uses (+) intenrally (because 'b' is Integral, right?), which implementation of (+) does it use?
08:17:41 <hari_> just a moment folks
08:17:44 <erisco> marijn, "there is a Countish f for all Integral b" true. "for all Integral b, f b is Listish". Yes, that is what I am trying to constrain.
08:17:46 <hari_> I have to get away.
08:17:50 <t7> i borked lambdabot :O
08:17:54 <Tekmo> hari_: Alright
08:18:01 <arkeet> t7: it was already that way ;)
08:18:21 <lambdabot> IO String
08:18:21 <lambdabot>   <hint>:1:1: parse error on input `:'
08:18:21 <lambdabot>   <hint>:1:1: parse error on input `:'
08:18:21 <lambdabot> f a b c d = c (b (a d))
08:19:22 <hari_> Sorry folks.
08:19:25 <monoidal> Maior: realToFrac?
08:19:27 <t7> sorry too long
08:19:29 <erisco> merijn, the one for whichever instance of Integral is being used
08:19:48 <hari_> Tekmo, Truly appreciate your help,
08:19:58 <Tekmo> hari_: You're welcome! :)
08:20:04 <merijn> erisco: And how does it know which one that is? :)
08:20:23 <arkeet> Maior: use realToFrac to convert between Float and CFloat.
08:20:26 <hari_> I will get back some time. Right now I am pressed by other work. :(
08:20:35 <arkeet> (there's a rewrite rule that makes sure it's efficient.)
08:20:37 <merijn> erisco: Normally GHC would infer it from the type, but "Countish f" doesn't have a 'b' in it, so GHC can't use the type to select the instance
08:20:40 <Maior> monoidal: arkeet cheers, will try that
08:20:48 <erisco> merijn, but it does
08:20:56 <arkeet> oh yeah, you're trying to build frag. :p
08:20:56 <hari_> Hate to interrupt a truly interesting learning.
08:20:59 <arkeet> have fun
08:21:00 <erisco> here let me paste the whole thing
08:21:45 <erisco> merijn, I think I am beginning to see the problem but here http://lpaste.net/92453
08:21:49 <arkeet> someone should update it so it builds on current ghc :p
08:21:53 <arkeet> and packages
08:21:55 <erisco> the scope doesn't carry over to the class functions does it
08:22:19 <danilo2> Hi! Could somebody tell me what are the benefits of using TChan over Chan (in Haskells threads)? Arent both operations allow for message passing between threads? Message passing is safe, elegant etc - what benefits bring the STM there? :)
08:23:10 <merijn> danilo2: Polling multiple chans
08:23:36 <merijn> danilo2: "readTChan chan1 <|> readTChan chan2 <|> readTChan chan3" returns the message from the first channel that has one
08:23:40 <Tekmo> danilo2: What merijn means is that you can wait on the result of multiple channels without polling
08:23:41 <fryguybob> danilo2: STM allows for composition of small atomic operations into new larger atomic operations.
08:23:49 <merijn> danilo2: Also, safe pushback/peeking
08:23:59 <erisco> merijn, and no it was not a syntax error... I must not have been checking the line number correctly
08:24:02 <erisco> my bad
08:24:15 <erisco> I get the error 'b' not in scope... as guessed. well shoot.
08:24:57 <merijn> erisco: The constraints on a class don't introduce a variable, you probably want to extend Countish to be a multiparam typeclass
08:25:33 <merijn> erisco: i.e. change the last bit to "Countish f b" and add "{-# LANGUAGE MultiParamTypeClasses #-}" (or whatever the correct name is)
08:26:31 <danilo2_> merijn, Tekmo, fryguybob: Thank you! The example with pooling is very cool - could you please tell me - how this example could be rewritten using only chans?
08:27:03 <merijn> danilo2_: It can't, unless you use 1 thread per chan and have them write to a single collective channel
08:27:46 <merijn> i.e. make a thread do a blocking read from a chan and then write it to the "collection" channel, do that for all chans and then do blocking read on the collection channel
08:27:49 <danilo2_> and using Tchans (as you've shown in the example) arent we using one thread per channel ?
08:27:56 <merijn> danilo2_: No
08:28:07 <merijn> danilo2_: We're using the RTS's retry support
08:28:14 <erisco> merijn, gotcha so far. now it is crying for flexible instances
08:28:25 <merijn> erisco: Oh, right, yeah you need that one too
08:28:43 <merijn> erisco: Standard haskell is really conservative in the instances it allows
08:29:01 <danilo2_> merijn: Ah, ok! got it, so we are simply iterating over TChans and if every fails it simply retries it?
08:29:20 <merijn> danilo2_: "<|>" (for STM, at least) tries the first action, if it retries it tries the second action, if the second action retries it retries the entire composition
08:29:22 <Tekmo> danilo2_: It waits on all of them and returns the first one that produces a value
08:29:47 <Tekmo> danilo2_: STM makes it really easy to write programs without polling
08:29:53 <merijn> danilo2_: And the way the RTS implement retry is blocking (i.e. it will only *really* retry if one of the transactional variables has changed)
08:30:21 <danilo2_> Ok, thank you - do you know any place where can I learn more benefits of TChans? In real World Haskell there is only a little section connected to them: http://book.realworldhaskell.org/read/software-transactional-memory.html
08:30:22 <merijn> danilo2_: So if none of the channels have an element it will block until one of the channels is modified in wich case it wakes up
08:30:31 <merijn> danilo2_: Simon Marlow's new book :)
08:30:53 <merijn> danilo2_: http://shop.oreilly.com/product/0636920026365.do
08:30:59 <erisco> marijn, marvelous thank you
08:30:59 <Tekmo> danilo2_: You should probably familiarize yourself with STM in general
08:31:15 <Tekmo> danilo2_: You should read Simon Peyton Jones's STM tutorials on School of Haskell
08:31:16 <merijn> danilo2_: There might be a free version online, there was a free beta edition, not sure if it still exists
08:31:21 <erisco> merijn, I had played with mptc and fundeps before but didn't see the applicability here
08:31:22 <danilo2_> merijn: Thnak you! I'm gonna read it :)
08:31:27 <merijn> danilo2_: The STM paper is also pretty easy to read
08:31:34 <Tekmo> https://www.fpcomplete.com/school/beautiful-concurrency
08:31:38 <danilo2_> Tekmo: I\'m a **little** familiar - by reading a chapter in Realf World Haskell on it :)
08:31:50 <merijn> danilo2_: It's linked from the STM docs, it explains how it's implemented and that sorta thing
08:32:01 <Tekmo> danilo2_: Those tutorials are very close to his original paper
08:32:05 <danilo2_> Tekmo: Thank you for the tutorial!
08:32:07 <merijn> erisco: That means it was a learning experience ;)
08:32:11 <Tekmo> danilo2_: You're welcome!
08:32:24 <Maior> monoidal: arkeet: huzzah, thanks
08:32:26 <erisco> merijn, here is your reward: http://lpaste.net/92454 may be of no use to you :P
08:32:32 <danilo2_> merijn: I'll read them both :) Thank you for all the informations :)
08:33:31 <erisco> but I think augur would be proud
08:33:48 <merijn> erisco: Next step, GADT and TypeFamilies abuse :p
08:33:55 <erisco> this is not abuse
08:33:58 <erisco> this is love
08:34:07 <merijn> We hurt the ones we love ;)
08:34:13 <erisco> that's love
08:34:22 <erisco> right? :)
08:35:10 <merijn> I'm not saying GADT/TypeFamilies abuse is bad, I love it :p
08:37:30 <haasn> GADTs and TypeFamilies love you too
08:39:48 <merijn> They code, especially closed families :)
08:39:58 <merijn> eh
08:40:01 <merijn> s/code/do
08:44:19 <jophish> Yo yo yo
08:46:30 <jophish> I'm writing a language with the syntax of Haskell, but with no recursive data types and a whole bunch of other restrictions (It's compiling to a system without pointers :)). At the moment I'm using language.haskell.exts and compiling to my own IR based on Hindley-Milner, from which I'm going to transform into llvm.
08:47:27 <jophish> At the moment I'm wondering how applicable GHC's Core will be to my use case. Could it be worth using GHC to typecheck and optimise, before grabbing the Core and translating that to LLVM myself
08:47:55 <luite> jophish: why do you want to translate core to LLVM? GHC already does that?
08:48:07 <luite> (through Cmm though)
08:49:04 <jophish> luite: ghc seems to insert a lot of things into the llvm which I don't need, garbage collection, pointers. I need to do several transformation of my own too, defunctionalization for example
08:49:44 <quicksilver> I have a feeling that GHC core is too specific and too complex and will lead you down blind alleys
08:49:50 <quicksilver> ICBW, that's only a feeling.
08:49:55 <jophish> quicksilver: that's my thinking so far
08:49:56 <luite> core is relatively simple
08:50:02 <luite> the simplest intermediate language
08:50:10 <luite> in ghc that is :)
08:50:15 <quicksilver> that's relative, luite
08:50:32 <quicksilver> it contains, for example, unboxed tuples, and specific implementations of GHC internal types
08:50:54 <quicksilver> if jophish wants to do those a different way that's unhelpful
08:51:46 <Maior> is there an equivalent to `:type` for IO/Array/etc. in ghci?
08:51:46 <jophish> Another way of wording my question may be: (Is GHC capable of removing recursive types in most use cases (like stream fusion can do for lists)) OR (Are the GHC optimisations on non-recursive data types likely to improve the code, given that it's going to go through LLVM which is excellent at that kind of thing)
08:52:45 <jophish> quicksilver: Every data type will just turn into an llvm struct, no boxing for example. I don't know how much Core relies on that
08:53:35 <jophish> It would be really nice to have lists in this language but I wouldn't want to have them if they can't be compiled in certain use cases.
08:53:38 <quicksilver> the main thing which GHC does at the Core level is inline everything and then apply RULES
08:53:51 <quicksilver> since your language is different the RULES won't apply to you
08:54:05 <quicksilver> inline everything is probalby a transformation you can do yourself
08:54:27 <jophish> heh, I hope so. LLVM can certainly do a very good job at that
08:54:43 <quicksilver> but the way GHC inlines its own base implementation (that's how you get all the primitive Int# and stuff) is probably confusing for you.
08:55:06 <quicksilver> if you tailor your source code so that GHC doesn't think any of the standard prelude is involved
08:55:17 <quicksilver> and doesn't recognise any of its types
08:55:26 <quicksilver> maybe that will produce something useful for you?
08:55:35 <quicksilver> although obviously it won't have any RULES then.
08:57:00 <jophish> quicksilver: Is there any reference for these RULES?
08:57:20 <quicksilver> how RULES work in general? Or what specific RULES are in the library?
08:57:47 <quicksilver> if you meant the former, then http://www.haskell.org/haskellwiki/GHC/Using_rules and the links it contains.
08:57:51 <jophish> I assume that a RULE is a transformation from Core to Core, making things a little bit better
08:58:18 <quicksilver> it is expressed as source-to-source in fact
08:58:35 <quicksilver> it's applied in the simplifier(?) but details in that link
08:58:49 <jophish> quicksilver: thanks!
08:58:52 <Maior> struggling to do sufficient type-smooshing with https://gist.github.com/doismellburning/6414320
08:59:37 <jophish> Ah, I see
08:59:44 <jophish> Gosh, these look jolly useful
09:03:13 <Maior> in fact, I really don't understand that error at all
09:05:54 <jophish> quicksilver: Rules are certainly on my wishlist now, so much useful stuff!
09:06:56 <geekosaur> Maior: I don't see an MArray instance for GLint / CInt
09:07:23 <Maior> geekosaur: ahhh right
09:07:24 <monochrom> Maior: IOUArray does not support GLint. this "does not support" fact is represented elsewhere: by writeArray availability, i.e., by having no instance for MArray that links up IOUArray and GLint.
09:08:04 <monochrom> (whereas, e.g., IOUArray "supports" Double by having an MArray instance that links up IOUArray and Double)
09:08:49 <Maior> so I just declare my own MArray instance for IOUArray and double that probably just does a GLint -> Int/similar conversion then uses existing instance stuff
09:10:29 <monochrom> that would be too easy. MArray deliberately hides away some method names you need to write a complete instance.
09:11:21 <Maior> ah, bah
09:11:33 <quicksilver> jophish: elaborating a bit, the problem is that GHC doesn't compile haskell. It compiles a language which doesn't really have a name (call it GHC?)
09:11:59 <quicksilver> jophish: it shares haskell syntax but it has explicit strict and lazy annotations, it has side-effects, etc.
09:12:16 <quicksilver> jophish: if you aren't careful then using GHC as a frontend ties you to their implementation choices.
09:12:26 <quicksilver> jophish: if you *are* careful it might work though!
09:12:34 <Maior> bah compiling Frag is proving tedious; I suspect/guess I can get some set of older libraries that this was built against, and Stuff Just Works, but that seems far from ideal
09:13:42 <luite> jophish: GHC does have core2core plugins where you can influence what it does, perhaps take out some specific things that you don't want to support before the optimizer is run
09:17:05 <Maior> monochrom: apologies for the slightly ridiculous question, but, assuming 1) that at one point this code worked, does that make it likely that a) at some point there was an MArray for GLint...?
09:17:43 <monochrom> that is interesting. I don't know.
09:17:58 <Maior> I have a sinking feeling that (1) doesn't hold
09:18:06 <Maior> but that seems odd
09:18:35 <tomboy64> hehehe pjeuler #303 is nasty
09:18:39 <mietek> cabal install libxml-sax --extra-include-dirs=/usr/local/opt/libxml2/include --extra-lib-dirs=/usr/local/opt/libxml2/lib
09:18:47 <mietek> Do these cabal flags work at all?
09:18:51 <Maior> it's a 6 commit repo, all from 2008, so I assume Changes Have Happened in Haskell/other libraries since
09:18:52 <monochrom> alternatively, in a distant past GLint was type GLint = Int
09:18:59 <Maior> monochrom: ah that'd do it
09:19:09 <tomboy64> you gotta sum up 1000 elements. 998 elements go rather quickly to bruteforce. but #999 is evil.
09:20:12 * Maior switches to GL==2.1
09:21:15 <Maior> or not, since that won't install
09:21:58 <quicksilver> yes, GLint used to be Int
09:22:10 <Maior> hm
09:22:15 <quicksilver> but that wouldn't work any more would it?
09:22:24 <quicksilver> isn't GLint 32 bit whilst Int is 64 bit on many machines
09:22:29 <quicksilver> I'm not sure.
09:22:48 <Maior> actually so I could probably just frob the `writeIndices` definition a bit then
09:23:17 <Maior> since presumably a GLint->Intything exists
09:24:01 <erisco> how might you instance a class for a class?
09:28:10 <erisco> mm that wouldn't work out right. never mind
09:28:20 <jophish> quicksilver: luite: I think it might be best to implement things myself, drawing 'inspiration' from how GHC does things wherever appropriate. It would probably only make sense to switch to using GHC if the answer was "Yes, GHC is a perfect frontend and will fit in your current project without hassle"
09:28:50 <luite> jophish: you could still use the GHC typechecker if you don't like Core though
09:29:12 <luite> that will give you an HsSyn AST with all names annotated with their origin and type
09:29:28 <jophish> luite: after I spent all weekend implementing a type checker! I think not!
09:29:36 <jophish> (I'll look into this)
09:30:04 <LudvikGalois> Has anyone written a Haskell compiler which targets the JVM?
09:30:13 <luite> i'd be rather impressed if you could typecheck all the extensions correctly in a weekend :)
09:30:26 <Eduard_Munteanu> LudvikGalois: there have been attempts at that (or .NET, unsure) AFAIK
09:30:38 <jophish> I can typecheck integers and the identity function :)
09:34:46 <Maior> ugh this is going to require more frobbing than I'd like
09:36:18 <apfelbox> what exactly is <*> and <$> ?
09:36:40 <Eduard_Munteanu> apfelbox: they're part of Applicative
09:36:40 <erisco> apfelbox, http://www.haskell.org/hoogle/
09:36:43 <apfelbox> (google just removes "<$>" from the query, lol)
09:36:55 <Eduard_Munteanu> Yeah, use hoogle for that.
09:36:55 <jophish> apfelbox: try hoogle
09:37:12 <jophish> http://www.haskell.org/hoogle/?hoogle=(%3C*%3E)
09:37:17 <Clint> @hoogle (<$>)
09:37:18 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
09:37:18 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:37:19 <erisco> or our friend lambdabot :)
09:37:27 <apfelbox> nice :)
09:37:33 <apfelbox> thanks all!
09:37:34 <Eduard_Munteanu> Does GHC make any attempt to solve implicit parameters? Are they metavariables or are they strictly limited to threading arguments around?
09:37:57 <Maior> any reading advice for implementing MArray IOUArray GLint IO?
09:40:26 <Heffalump> Eduard_Munteanu: what do you mean by solev?
09:40:38 <Eduard_Munteanu> I want to define   data Decidable a where Yes :: a -> Decidable a; No :: (?neg :: a -> Void) -> Decidable a   and I was hoping I could merely say "No" in case 'a' is exactly Void.
09:40:40 <Heffalump> if you left out a lot of type signatures I imagine you'd get whole-program type-inference for them
09:41:08 <Eduard_Munteanu> Heffalump: the way implicits work in Agda, if you're familiar with that.
09:41:10 <Heffalump> you could make Decidable a GADT which wuold express that, perhaps
09:41:21 <Heffalump> I'm not, sorry
09:41:43 <apfelbox> interface file versions of hi files match to the GHC version?
09:42:44 <Eduard_Munteanu> Heffalump: Agda lets you insert _ placeholders anywhere (and in fact that's how implicits work behind the scenes) and it will fill them up if it can construct an expression of the correct type
09:43:57 <Heffalump> Eduard_Munteanu: GHC will only ever infer types, not values (AFAIK)
09:43:57 <Eduard_Munteanu> (but said expression could have unsolved metavariables itself, so it's not really magical if there are ambiguities)
09:44:19 <Heffalump> so if you could express it all at the type level, then maybe
09:44:51 <flebron> is there a more idiomatic way of writing [[a, b, c] | a <- [0..], b <- [0..a], c <- [0..b]]?
09:44:52 <Eduard_Munteanu> I guess I could make a typeclass.
09:45:11 <Heffalump> I don't think that would be any different to making an implicit parameter
09:45:29 <Heffalump> and implicit parameters have the advantage that they can mention type variables that dno't exist in the signature on the RHS of the constraint
09:46:18 <apfelbox> GHC automatically loads all dependencies (= imports), right? From which version on did GHC do this?
09:46:25 <Maxdamantus> @@ @pl @undo [[a, b, c] | a <- [0..], b <- [0..a], c <- [0..b]]
09:46:25 <lambdabot>  ap ((=<<) . (`ap` enumFromTo 0) . ((=<<) .) . flip flip [] . ((flip . ((:) .)) .) . (. ((. return) . (:))) . (.) . (:)) (enumFromTo 0) =<< [0..]
09:46:34 <Maxdamantus> I think most people prefer that.
09:46:44 * Twey chuckles.
09:46:49 <haasn> edwardk: it would realling be interesting to provide Isos for reversible arithmetic operations, in particular (+) and perhaps (*) (though we'd have to be careful to exclude 0, presumably via error)
09:46:54 <haasn> would really*
09:47:37 <ocharles> haasn: which isomorphism is that?
09:48:11 <Y_Less> Is there any equivalent to GHCi's ":i" in Template Haskell to query known instances of something?
09:48:16 <ocharles> +5 => -5 ?
09:48:24 <Heffalump> flebron: I think that is the most idiomatic way
09:48:30 <flebron> thanks :)
09:48:50 <Heffalump> well, the [a,b,c] instead of (a,b,c) may be a bit of a smell depending on what you do with it afterwards
09:48:51 <Twey> I think it's pretty idiomatic.
09:48:56 <haasn> edwardk: fahrenheit = multiplying (9/5).adding 32;  100^.fahrenheit = 212;  212^.from fahrenheit = 100
09:49:11 <flebron> yeah, i changed it to [a, b, c] only because i was going to apply nub . permutations to it :)
09:49:16 <haasn> ocharles: adding n = iso (+n) (subtract n); multiplying n = iso (*n) (/n)
09:49:30 <ocharles> hmm, interesting
09:49:44 * Hodapp looks up Template Haskell...
09:49:47 <ocharles> haasn: if you change that to a Prism, I think you get something like invertible-syntax
09:50:01 <ocharles> and partial-isomorphisms
09:50:06 <haasn> right but this is stronger than a prism
09:50:27 <ocharles> sure, but it would be interesting to see how far you can go to compose partially invertible functions
09:50:38 <haasn> you can compose prisms just fine
09:50:41 <Eduard_Munteanu> class Decidable a where yes :: a -> Decidable a; no :: (a ~ Void) => Decidable Void;
09:50:43 <haasn> even with true isomorphisms
09:50:47 <haasn> so I guess that answers that question?
09:50:47 <ocharles> i know
09:50:51 <Eduard_Munteanu> What does GHC do about 'no' if a is not Void?
09:50:53 <ocharles> haasn: just rambling i guess :)
09:50:58 <Eduard_Munteanu> I mean when you define an instance.
09:51:05 <ocharles> haasn: mostly wondering how much of that paper can be implemented in just lens, without having to define new data types
09:51:13 <haasn> try it! :)
09:51:14 <Eduard_Munteanu> Is it smart enough to tell they're different and stop bugging you about defining 'no'?
09:51:16 <ocharles> i should!
09:51:22 <ocharles> but it's time to go home now
09:51:54 <Eduard_Munteanu> Actually the 'yes' there is broken.
09:52:02 <Heffalump> Eduard_Munteanu: an instance of what?
09:52:22 <Eduard_Munteanu> Heffalump: data Void; instance Decidable Void where ...
09:52:56 <Eduard_Munteanu> Or maybe it isn't broken.
09:53:12 <Eduard_Munteanu> You still need an 'a' to give to 'yes'.
09:53:29 <Heffalump> what is the class Decidable? I saw a datatype definition above but not a class.
09:53:57 <Eduard_Munteanu> Heffalump: I just defined it, same name, yeah... class Decidable a where yes :: a -> Decidable a; no :: (a ~ Void) => Decidable Void;
09:53:57 <haasn> that class would be a kind error
09:54:05 <haasn> (->) can't have something of kind Constraint on the right hand side
09:54:09 <haasn> </pedantry>
09:54:29 <Eduard_Munteanu> haasn: the rhs is a GADT, not a typeclass.
09:54:39 <haasn> I'm complaining about the reuse of names :P
09:54:43 <Heffalump> sorry, missed that above
09:54:45 <Eduard_Munteanu> Ah, fair. :)
09:55:00 <haasn> class names and type constructors share their namespace after all
09:55:16 <Heffalump> I don't think that definition is valid because 'no' doesn't mention 'a'.
09:55:19 <Eduard_Munteanu> haasn: hm... I guess they can be ambiguous with ConstraintKinds no?
09:55:22 <Heffalump> you wuold have to have => Decidable a
09:55:47 <haasn> Eduard_Munteanu: yes, but iirc the namespace is shared even outside of it, no?
09:55:56 <Eduard_Munteanu> Not sure.
09:56:12 <haasn> Eduard_Munteanu: also I tried class Foo a where foo :: (a ~ Int) => a -- I can't define an instance Foo () where foo = ..., not sure if relevant
09:56:14 <Eduard_Munteanu> Heffalump: hm, you're right
09:56:47 <erisco> @pl \x y -> False
09:56:47 <lambdabot> const (const False)
09:56:49 <haasn> not even if I change foo to :: (a ~ Int) => Int
09:56:52 <erisco> right silly me
09:56:53 <Eduard_Munteanu> Actually dunno if it doesn't work.
09:57:17 <erisco> :t (const . const)
09:57:18 <lambdabot> a -> b -> b1 -> a
09:57:28 <Eduard_Munteanu> haasn: yeah, that's what I was curious about... if GHC ignored 'no' altogether smartly.
09:58:05 <Eduard_Munteanu> For specific types type equality should be decidable.
09:59:05 <Eduard_Munteanu> s/specific/concrete/
09:59:19 <haasn> Eduard_Munteanu: hmm, with class Foo a where foo :: (a ~ Int) => () -- asking GHCi :t foo will fail unless there's an instance Foo Int
09:59:52 <haasn> even if you ask :t foo :: Foo Int => ()
10:00:01 <Eduard_Munteanu> haasn: that's normal I suppose
10:00:12 <haasn> (though you can define bar :: Foo Int => (); bar = foo just fine)
10:00:15 <haasn> yeah I guess
10:01:02 <Eduard_Munteanu> Instance resolution can affect types AFAICT.
10:01:57 <Eduard_Munteanu> So foo wouldn't be a Foo Int if Int ~ Char was required from resolution.
10:03:33 <mkramer> I'd like to make a polymorphic function that does one thing if passed a Functor and another thing if it's passed a non-Functor. (http://lpaste.net/92456)
10:03:39 <mkramer> Is that stupid?
10:04:07 <jmcarthur> perhaps not stupid, but not doable either
10:04:33 <mkramer> how could I implement my "dump" idea?
10:04:44 <jmcarthur> how do you want to use it?
10:04:48 <jmcarthur> what is it for?
10:04:49 <haasn> mkramer: instance Show a => Show (YourFunctor a)
10:05:02 <copumpkin> your kinds don't work anyway
10:05:04 <haasn> there's a host of other issues with the paste
10:05:07 <mkramer>         dump hIsOpen inTestHandle, dump myPureRecord
10:05:19 <haasn> putStrLn $ show <$> x -- would be a type error
10:05:27 <haasn> (Functor a, Show a) -- kind error
10:05:34 <haasn> also putStrLn . show = print
10:06:00 <copumpkin> it's also not trivial to fix
10:06:06 <copumpkin> you need more than a functor to do what you want to do
10:06:08 <jmcarthur> mkramer: i don't understand what you expect `dump hIsOpen inTestHandle` to do
10:06:34 <mkramer> lift show into the IO Bool before putStrLn'ing it
10:07:12 <haasn> you can't putStrLn an IO String either so it's pointless
10:07:21 <jmcarthur> mkramer: so you mean something like    myAction >>= print   ?
10:07:29 <haasn> you might be interested in mapM_ print :: Show a => IO a -> IO ()
10:07:36 <haasn> sorry
10:07:41 <haasn> wrong function
10:07:53 <haasn> :t (>>= print)
10:07:54 <lambdabot> Show a => IO a -> IO ()
10:10:29 <mkramer> oh,
10:10:43 <mkramer> hIsOpen Foo >>= print
10:10:50 <jmcarthur> exactly
10:11:12 <mkramer> thank you
10:11:18 <erisco> haskell without pattern matching is quite tedious it turns out
10:11:40 <applicative_tmp> yeah, it kinda like other languages then
10:11:56 <erisco> actually
10:11:58 <erisco> yes :P
10:12:08 <jmcarthur> i don't use pattern matching that much these days. do i fail?
10:12:20 <erisco> jmcarthur, do you pattern match your lists?
10:12:25 <jmcarthur> i use so many higher order functions
10:12:30 <applicative_tmp> you've probably moved to a higher level
10:12:32 <applicative_tmp> right
10:12:56 <jmcarthur> erisco: rarely
10:13:10 <applicative_tmp> do you use 'head' a lot?
10:13:11 <erisco> ah, well, if there was a definition already, or a composition of other algorithms, then sure
10:13:17 <jmcarthur> applicative_tmp: hell no
10:13:26 <applicative_tmp> haha.
10:13:48 <erisco> at least guards take a small bit of pain out
10:14:07 <erisco> glorified if/then/else it seems but (haven't used them before)
10:14:14 <Maior> at some point, was there a `catch` in Prelude or something...? https://github.com/doismellburning/Frag/blob/master/src/Textures.hs#L35
10:14:21 <applicative_tmp> yes Maior
10:14:25 <jmcarthur> Maior: yeah that's dead and gone, basically
10:14:41 <jmcarthur> Maior: there's one in Control.Exception, but it's not exactly the same thing as the old catch
10:14:47 <applicative_tmp> Maior: repairing past uses is trivial but irksome
10:15:06 <Maior> applicative_tmp: well, trivial's good
10:15:09 <jmcarthur> has frag been unmaintained for that long?
10:15:14 <Maior> jmcarthur: last commit, 2008
10:15:17 <jmcarthur> wow
10:15:36 <applicative_tmp> Maior: in that case you would import Control.Exception to get catch but then the little lambda need improvment
10:15:37 <Maior> I'm using a GitHub copy because I want to get it building with Travis - looks just like the darcs one though
10:15:55 <applicative_tmp> you need a signature for the exception type of what is there _
10:16:20 <applicative_tmp> one way is to as ScopedTypeVariables to the language list
10:16:52 <haasn> I need to create a repository to hold all my fizzbuzzes or something, they're beginning to fill up my haskell folder..
10:16:53 <applicative_tmp> and then write (\(e::SomeException) -> do print ("missing texture: "++path) etc
10:17:18 <erisco> @src zipWith
10:17:18 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:17:18 <lambdabot> zipWith _ _      _      = []
10:17:18 * Maior attempts to work out *what* Exception
10:17:19 <Maior> cheers
10:17:37 <erisco> wait a minute... 'as' can be used?
10:17:48 <jmcarthur> why not?
10:17:50 <erisco> is my syntax highlighter lying?
10:17:51 <erisco> well damn
10:17:58 <erisco> all this time wanted to say 'as'
10:18:06 <merijn> Maior, applicative_tmp: Nicer would be "\(SomeException _) -> do print <blahblah>"
10:18:08 <erisco> it is also a keyword
10:18:19 <merijn> Maior: That avoids needing STV
10:18:31 <erisco> then again notepad++ can't highlight haskell comments correctly either
10:18:33 <applicative_tmp> oh Maior like merijn says; somehow I hadn't noticed that
10:18:48 <Eduard_Munteanu> Grr... there aren't absurd / empty patterns in Haskell, no?
10:18:51 <applicative_tmp> thanks merijn
10:19:07 * haasn casually mentions Control.Exception.Lens
10:19:08 <Eduard_Munteanu> I'm trying to define a bot-eliminator
10:19:28 <mr-> @botsnack
10:19:28 <lambdabot> :)
10:19:45 <applicative_tmp> Maior: the point is, theres now a million kinds of exceptions so it needs to know what kind; the SomeException _ pattern tells it
10:20:31 <Maior> applicative_tmp: sure; wish I had some idea
10:20:55 <merijn> Doesn't System.IO or something still export the old catch?
10:21:07 <merijn> That'd avoid the entire need for update the code, just change the imports
10:21:07 <apfelbox> Does GHC automatically load all import dependencies on compilation (with ghc MyFile.hs)
10:21:17 <apfelbox> ?
10:21:19 <merijn> System.IO.Error
10:22:07 <merijn> Maior: Before updating all the code, try doing "import System.IO.Error (catch)" (assuming the module doesn't need Control.Exception otherwise)
10:22:39 <Maior> merijn: alas `Module `System.IO.Error' does not export `catch'`
10:22:56 <applicative_tmp> no, it doesnt have catch
10:22:59 <applicative_tmp> catchIOError
10:23:53 <Maior> huzzah
10:23:56 <Maior> catch = catchIOError
10:23:59 <Maior> cheers
10:24:39 <merijn> oh, they renamed it?
10:24:44 <erisco> haasn, it is too awesome: zipWith :: (Listish f, Listish g, Listish h) => (a -> b -> c) -> f a -> g b -> h c
10:24:49 <merijn> That's what I get for relying on my memory
10:25:03 <applicative_tmp> is that basically equivalent to Ye Olde 'catch'?
10:25:42 <merijn> afaik
10:25:54 <merijn> System.IO.Error was the place Prelude initially exported catch from
10:26:04 <merijn> So I guess they just renamed it to avoid the name clash
10:26:31 <erisco> the code isn't so awesome though :( time for the haskell extension that defines pattern matching for type classes
10:26:48 * erisco isn't going to write it :P
10:29:46 <jmcarthur> apfelbox: so long as they are properly packaged up in ghc-pkg (they should be if you used cabal install to install the libraries), yes. if you are using cabal to build your program, though, you will have to list the dependencies in the cabal file.
10:30:19 <jmcarthur> apfelbox: ghc will also check local paths and such automatically if you are using some module defined in your local project
10:30:20 <apfelbox> I am directly compiling and it just works (chdir to the root directory of the program)
10:30:46 <apfelbox> Ok, is this something new (the automatic local checking)?
10:30:52 <apfelbox> In 7.6.3 it works, in 6.12.1 not
10:30:54 <jmcarthur> nope, it's been this way forever
10:31:11 <jmcarthur> maybe it got better at guessing what the root of the project is
10:31:25 <jmcarthur> but it has done module dependency tracking for a long time
10:32:47 <apfelbox> Ok, the other party probably wasn't in the correct directory, I guess
10:44:51 <joelteon> Why aren't tuple sections enabled by default?
10:48:41 <geekosaur> ghc tries to stay compatible with the standard without any extensions enabled, and (,,) is a perfectly valid reference to an operator named ,, in standard Haskell
10:48:52 * hackagebot mongoDB 1.4.1.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.1.1 (FedorGogolev)
10:49:45 <Maior> ok that's cute
10:50:12 <Maior> `A 98-tuple is too large for GHC`
10:50:45 <startling> {- Manuel says: Including one more declaration gives a segmentation fault. -}
10:50:48 <startling> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
10:50:55 <edwardk> donri: it could. are you signing up to maintain them from release to release?
10:51:13 <edwardk> haasn: Add them to Numeric.Lens?
10:51:19 <joelteon> Maior: you might want to think about using an ADT
10:51:24 <Taneb> Maior, why the hell were you using a 98-tuple
10:51:26 <edwardk> haasn: i've even used the fahrenheit example before
10:51:28 <donri> edwardk: are you answering to #haskell-lens ?
10:51:35 <edwardk> donri: i guess so
10:51:41 <edwardk> just skimming my highlights
10:51:49 <Maior> Taneb: observing that `:type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)` worked
10:52:17 <joelteon> interesing
10:52:22 <joelteon> :t (,,,,,,,,,,,,,)
10:52:23 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
10:52:29 <NNOTM> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:52:30 <lambdabot>     A 98-tuple is too large for GHC
10:52:30 <lambdabot>       (max size is 62)
10:52:30 <lambdabot>       Workaround: use nested tuples or define a data type
10:52:33 <joelteon> so that's reasonable
10:52:40 <startling> > ":t (" ++ replicate 98 ',' ++ ")"
10:52:41 <lambdabot>   ":t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
10:52:51 <joelteon> I think the biggest tuple i've ever *actually* used is 4
10:52:53 <haasn> edwardk: alright; any idea on the names? ‘multiplying’ is a bit verbose
10:52:58 <joelteon> anything past that and you need a datatype
10:53:05 <edwardk> Maior: (,…,) is in general implemented just as a single case in the ghc type checker defined recursively. it should work for any natural number worth of (,)'s you choose other than 1 ;)
10:53:07 <joelteon> or at least it's in your best interests to have one
10:53:25 <startling> edwardk: is it really? http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
10:53:26 <edwardk> haasn: verbose, but it won't collide
10:53:39 <Hafydd> Why is it called Haskell 98 if it can't handle 98-tuples?
10:53:46 <haasn> right, and the ‘ing’ thing fits well with other lens names
10:53:48 <startling> I assumed the "98-tuple is too large ..." error was a parsing thing.
10:53:49 <Maior> edwardk: I figured as much
10:54:07 <edwardk> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:54:08 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
10:54:09 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c, d, e,
10:54:11 <lambdabot> f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54,
10:54:11 <edwardk> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:54:13 <lambdabot> t55, t56, t57, t58, t59, t60, t61, t62, t63)
10:54:17 <lambdabot>     A 63-tuple is too large for GHC
10:54:21 <lambdabot>       (max size is 62)
10:54:26 <edwardk> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:54:31 <lambdabot>     A 64-tuple is too large for GHC
10:54:33 <lambdabot>       (max size is 62)
10:54:35 <lambdabot>       Workaround: use nested tuples or define a data type
10:54:38 <edwardk> bah
10:54:53 <erisco> nested tuples! brilliant! 62x62 elements easily
10:55:06 <monochrom> hehehe
10:55:10 <edwardk> ok, in my compilers its its own thing =)
10:55:26 <startling> so who's Manuel?
10:55:39 <edwardk> chakravarty
10:56:18 <startling> why does he say that including 63-tuples gives a segmentation fault?
10:56:26 <lpaste> thr33strikes pasted “Can someone explain this for me?” at http://lpaste.net/92460
10:56:31 <edwardk> i would presume because it does
10:56:35 <haasn> > replicate 98 ')'
10:56:37 <edwardk> maybe register passing conventions?
10:56:38 <startling> edwardk: heh
10:56:44 <lambdabot>   "))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
10:56:52 <haasn> ^ typical type signature for nested tuples
10:56:59 <Hafydd> Heh.
10:57:43 <monochrom> thr33strikes: getDirContent <- getDirectoryContents "."
10:57:43 <startling> thr33strikes: line 15
10:57:49 <Hafydd> > 62 ^ 62
10:57:50 <lambdabot>   134364564515225004658302677932296937303529095376341154029090650267130114850...
10:57:54 <startling> pryou probably mean getDirectoryContents "."
10:58:16 <startling> thr33strikes: ^
10:58:17 <Hafydd> > log (62^62) / log 10
10:58:18 <lambdabot>   111.12828474889173
10:58:19 <thr33strikes> can you explain why it's that way instead of the way I wrote it?
10:58:36 <thr33strikes> I'm new to haskell and programming :)
10:58:37 <startling> thr33strikes, getDirectoryContents is a function taking a string/filepath
10:59:00 <edwardk> haasn: then you need to figure out if you want to do a prism or a iso for exp/log =)
10:59:52 <blume> ?src Data.List.permutations
10:59:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:00:05 <blume> eh
11:00:23 <Hafydd> In Soviet #haskell, the bot abuses you.
11:00:25 <haasn> edwardk: prism I guess
11:00:29 <edwardk> haasn: did you see https://www.fpcomplete.com/user/edwardk/snippets/mandelbrot ?
11:00:53 <edwardk> haasn: if you'd rather i used 'haasn' there or something else as the call out to you for the original definition, let me know
11:01:15 <haasn> yes I think I'd prefer that
11:01:36 <edwardk> haasn, Haasn?
11:01:49 <haasn> Haas, N. I guess
11:01:52 <startling> haasn't
11:01:57 <edwardk> hah. k. =)
11:01:57 <startling> :t hasn't
11:01:58 <lambdabot> Getting All s a -> s -> Bool
11:02:06 <haasn> that hardly looks very much like the version I gave :P
11:02:10 <haasn> it's no longer a one-liner
11:02:12 <haasn> disgusting
11:03:15 <FreeFull> :t has
11:03:16 <lambdabot> Getting Any s a -> s -> Bool
11:03:20 <haasn> oh, that reminds me, can we make iterated be an indexed fold?
11:03:29 <FreeFull> > has _1 3
11:03:31 <lambdabot>   No instance for (Control.Lens.Tuple.Field1 s0 s0 b0 b0)
11:03:31 <lambdabot>    arising from a u...
11:03:38 <FreeFull> > has _1 (1,2)
11:03:40 <lambdabot>   True
11:03:47 <FreeFull> > has _3 (1,2)
11:03:48 <lambdabot>   No instance for (Control.Lens.Tuple.Field3 (t0, t1) (t0, t1) b0 b0)
11:03:49 <lambdabot>    aris...
11:03:52 * hackagebot groundhog-sqlite 0.4.0.1 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.0.1 (BorisLykah)
11:03:54 * hackagebot groundhog-postgresql 0.4.0.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.0.1 (BorisLykah)
11:03:56 * hackagebot groundhog-mysql 0.4.0.1 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.0.1 (BorisLykah)
11:04:16 <startling> FreeFull, _n are lenses. has/hasn't say whether a traversal acts on some value. all lenses act on all possible values.
11:04:16 <thr33strikes> thanks a lot I was soo close
11:04:23 <startling> > has _head []
11:04:24 <lambdabot>   False
11:04:33 <haasn> > has (ix 1) (1,2)
11:04:35 <lambdabot>   True
11:04:36 <haasn> > has (ix 3) (1,2)
11:04:37 <lambdabot>   False
11:04:39 <haasn> lenses are magic
11:05:00 <startling> > over _head (+ 1) [0]
11:05:02 <lambdabot>   [1]
11:05:09 <startling> > over _head (+ 1) []
11:05:10 <lambdabot>   []
11:05:15 <haasn> > ("hello","world") ^? ix 1
11:05:16 <lambdabot>   Just "world"
11:06:02 <marai> how can I write a "read something :: Int" in a map? map (read :: Int) ["2","3"] doesn't seem to be correct syntax.
11:06:21 <monochrom> map read ["2", "3"] :: [Int]
11:06:37 <startling> or map (read :: String -> Int)
11:06:54 <haasn> edwardk: I think you could retrofit repa into your version
11:06:58 <startling> marai: the syntax is correct, it's just that read is not of the type Int.
11:06:59 <edwardk> i want a my traversal transformer so i can have over (my _head)
11:07:01 * monochrom has a cunning plan!
11:07:01 <haasn> in order to make it parallelized again
11:07:13 <edwardk> haasn: likely. min was a dumb hack
11:07:15 <edwardk> er mine was
11:07:20 <startling> :t min
11:07:21 <lambdabot> Ord a => a -> a -> a
11:07:26 <startling> complete hack. >:(
11:07:28 <monochrom> (map :: (String -> Int) -> [String] -> [Int]) read ["2", "3"] :)
11:07:29 <marai> monochrom: ooh interesting. thanks.
11:07:40 <edwardk> if you want to hack out the repa magic I'd include it either as a replacement or a supplement in that post
11:08:16 <edwardk> more parallelism would let us run more detailed 'brots.
11:08:17 <startling> edwardk: lens haskell is looking even more and more like perl code. :(
11:08:35 <edwardk> startling: but with a principled foundation
11:08:38 <haasn> edwardk: it would be a simple change actually, just change the forM_ stuff in ‘png’ to a call to repa's ‘fromFunction’ and then mapM_ put over the resulting array or whatever
11:08:46 <startling> edwardk: (re: "my")
11:09:02 <edwardk> ah
11:09:13 <marai> startling: when you wrote "map (read :: String -> Int)" are you providing read a type signature?
11:09:43 <startling> marai: yeah. read has type "Read a => String -> a". By saying "read :: String -> Int", you're just making the type more specific.
11:09:55 <FreeFull> startling: I see
11:09:59 <marai> startling: cool! thanks.
11:10:55 <sebzim> Does anyone here know anything about GHC.TypeLits?
11:11:37 <startling> marai: the other ways people have said make the type more specific in more indirect ways.
11:12:02 <sebzim> I'll take that as a no then
11:12:34 <startling> sebzim: there was a recent thing on /r/haskell ... oh.
11:13:04 <Taneb> @quote first.principles
11:13:04 <lambdabot> No quotes match. :(
11:13:11 <Taneb> @quote first principle
11:13:12 <lambdabot> No quotes for this person. Whoa.
11:13:15 <Taneb> @quote first.principle
11:13:15 <lambdabot> stephen_turnbull says: First Principle of Herding Cats: Put the cats in a box, then herd the box.
11:13:23 <Taneb> @quote from.first.principle
11:13:23 <lambdabot> No quotes match. Are you typing with your feet?
11:13:28 <Taneb> @quote dots
11:13:28 <lambdabot> No quotes match. Take a stress pill and think things over.
11:13:32 <Taneb> :(
11:13:38 <haasn> oh
11:13:40 <ReinH> oh hai
11:13:44 <ReinH> edwardk: did you finish it yet? :D
11:13:52 <edwardk> i should start it ;)
11:13:59 <ReinH> damn it
11:14:02 <ReinH> :p
11:14:03 <Taneb> What's the "I've just written an AI from first principles, how do I get some dots on the screen" quote?
11:14:21 <startling> @quote AI
11:14:21 <lambdabot> quicksilver says: C++ templates are a vile obscenity with no theoretical foundation and no comprehensible denotational semantics. Please do not compare them to haskell types or classes again.
11:14:25 <edwardk> haasn: if you can hpaste the 5 line change i'll go hack it into the site
11:14:28 <ReinH> not quite
11:14:29 <startling> @quote AI
11:14:30 <lambdabot> ghc says: My brain just exploded.
11:14:34 <startling> ???
11:14:37 <haasn> edwardk: mandelbrot = 0 ^? taking n (indexing (iterated step)).filtered diverges.asIndex
11:14:49 <haasn> I forgot we can add indexing to an arbitrary fold
11:14:53 <edwardk> haasn: yeah but then i have to put 2 sets of nested parens =)
11:14:54 <Taneb> @quote Brent from.first
11:14:54 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
11:14:58 <Taneb> @quote Brend from.first
11:14:58 <lambdabot> No quotes match. And you call yourself a Rocket Surgeon!
11:15:01 <haasn> yes, we need a better meta-language for composing lens transformers
11:15:02 <Taneb> @quote Brend
11:15:02 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
11:15:06 <Taneb> :(
11:15:09 <Taneb> Today is not my day
11:15:15 <Taneb> I apologize for spamming the channel
11:15:17 <Taneb> Anyway, I found it
11:15:22 <edwardk> 3 if i don't name 'step'
11:15:24 <Taneb> Brend: I have created a revolutionary AI from first principles! Also, can anyone tell me how to draw coloured dots on the screen?
11:15:36 <ReinH> heh :)
11:16:01 <edwardk> i started with the taking n (indexing (iterated (\….))) version
11:16:54 <prophile> is there a type along the lines of a -> (IO b, b -> IO ()) for "mutable dictionaries"?
11:18:44 <haasn> edwardk: (oh, you also want the AR to be 3:2, right now it's 2:1 which throws the image off)
11:19:18 <edwardk> then i went 2:1 because it exactly fit in the window size they give for content
11:19:29 <edwardk> otherwise i have to clip parts or leave an annoying border
11:20:41 <Maior> well, Frag's been building for half an hour now
11:21:33 <roboguy_> does ghc do any static garbage collection analysis?
11:23:11 <startling> FreeFull: I can walk you through deriving it, if you'd like.
11:23:15 <startling> roboguy_: I don't think so.
11:24:45 <roboguy_> startling: I don't know a whole lot about it, but it seems like that would potentially make things quite a bit more efficient
11:26:16 <FreeFull> Bah, I have to install lens again
11:26:56 <startling> roboguy_: it's very much
11:27:07 <startling> an active research project, as I understand it
11:27:11 <FreeFull> There is probably a newer version than what I used to have anyway
11:27:21 <roboguy_> startling: hmm, seems interesting. maybe I'll look that up
11:27:23 <Maior> I don't suppose ghc has anything like "hey, send me USR1 and I'll dump status" does it?
11:27:39 <FreeFull> Yeah, lens updated on August 30th
11:27:42 <startling> roboguy_: keyword is "regions"
11:28:06 <startling> I think JHC does somes stuff with regions.
11:28:39 <Taneb> Can anyone tell me roughly what looks like it's gonna be in Haskell 2014
11:28:48 <roboguy_> startling: thanks!
11:33:46 <haasn> edwardk: oh, wait, I have to putWord8 0 in between rows, not elements; that makes things a lot less trivial
11:35:12 <sebzim> I heard something about Applicative => Monad making it into 2014
11:35:30 <sebzim> but not the way I had hoped
11:35:35 <haasn> edwardk: actually, I think it can still be done, with ‘sumP’
11:35:44 <sebzim> pure and return will still be different
11:36:13 <edwardk> haasn: i suppose one could compute the entire array in parallel then just serialize it that way
11:36:33 <Taneb> sebzim, look how little was changes in Haskell 2010
11:36:36 <edwardk> sebzim: sadly yes
11:36:45 <haasn> edwardk: that's basically what I'm doing, the trick is just serializing it elegently (ie. without manually counting out rows/columns)
11:36:46 <levi> roboguy_: There were a couple of bigish language efforts in the past that used region-based memory management, MLKit and Cyclone. The results were effective in some cases, but not quite as 'automatic' as a regular garbage collector and often needed a garbage collector as well.
11:37:02 <Taneb> Report Haskell is quite conservative and slow to change
11:37:04 <haasn> emphasis on ‘elegantly’ :)
11:38:12 <haasn> edwardk: is there some Monoid I can use for this Put stuff?
11:38:17 <startling> levi: why would you need a garbage collector? are there cases where region-based memory management is impossible?
11:38:24 <haasn> so I don't have to write (\x y -> x >> y) manually
11:38:25 <roboguy_> levi: Mercury uses a technique like that right? it claims to be the fastest logic programming language (not sure if that's saying much, I haven't worked much with logic languages)
11:38:40 <edwardk> haasn: Put is built over Builder, so you can probably turn that into a bit 'tell' of a builder
11:38:51 <roboguy_> startling: it's probably undecidable in general right? because of conditional branching?
11:39:13 <edwardk> (\x y -> x >> y) = (>>) of course =)
11:39:14 <startling> roboguy_: I don't know.
11:40:22 <levi> startling: From what I understand, it was fairly easy in MLKit to write programs where regions could not be usefully inferred. You have to think about how your program is allocating and understand a bit about how regions work.
11:41:47 <levi> And then in Cyclone, region-based collection was conservative due to regions having affine rather than linear types. You could leak if you weren't careful, but you couldn't access freed memory.
11:42:05 <roboguy_> levi: if the regions can't be inferred, would it be any slower than a normal GCed system?
11:42:35 <roboguy_> or any less efficient, I should say probably
11:43:00 <haasn> edwardk: err right (\x y -> x >> put y)
11:43:08 <Sonarpulse> edwardk: I'll have you bytes patch in within an hour
11:43:14 <haasn> or w/e, I'm not sure my current approach works.. it's a bit mind-bending
11:43:16 <levi> Probably not.  Regions could certainly reduce GC pressure.
11:43:17 <edwardk> Sonarpulse: great!
11:43:56 <levi> There's a lot of good documentation and papers surrounding the MLKit system.
11:44:17 <startling> roboguy_: maybe regions arent exactly what you're asking about.
11:45:35 <edwardk> haasn: maybe use mapM_ put ?
11:45:36 <roboguy_> startling: it seems like they are. I was wondering if there's a way to determine, at compile time, where (some) memory can be freed so that the GC has less work to do
11:46:21 <levi> There have been research papers that attempt to measure the cost of GC by analyzing the points at which GC runs in a program and then inserting 'free' calls there. But that's not something that works outside of a benchmark, because the GC points depend dynamically on program inputs.
11:46:24 <edwardk> haasn: if you can just split the repa array into an array of arrays, then do it in two levels like we do in the core png loop that'd work
11:46:32 <haasn> edwardk: that would be simplest, but I don't know how to get the repa array as a nested vector or something, toVector just flattens it down to a single very long vector
11:46:38 <haasn> so I don't know where to insert the ‘0’s in between rows
11:46:41 <startling> roboguy_: there is. Rust does some of it by virtue of linear typing. I don't know if the name for it in general.
11:46:55 <haasn> repa doesn't like nesting itself afaik
11:47:45 <startling> roboguy_: the gist of it is that there are cases where you can compile in malloc and free calls.
11:47:48 <roboguy_> startling: I was going to look at rust, but the compiler immediately either segfaults or sigtraps when I try to run it in (seemingly) any way
11:48:22 <startling> roboguy_: lovely. at least you managed to compile it.
11:48:25 <edwardk> haasn: isn't there some kind of 'slice' mechanic iirc?
11:49:06 <Sonarpulse> edwardk: what is the easiest way to get GHCi to to load the C object files?
11:49:09 <haasn> edwardk: ah, that could work
11:49:34 <haasn> I have to go now, I'll get back to it later
11:49:40 <edwardk> Sonarpulse: i tend to just cabal install each time, then start up ghci and load from there after :cd .. or something so it doesn't look locally
11:49:47 <edwardk> haasn: kk
11:51:32 <lpaste> thr33strikes revised “Can someone explain this for me?”: “Can someone explain why this doesn't work?” at http://lpaste.net/92460
11:51:45 <levi> The Disciple language is a good place to look for information about region types.
11:51:49 <Sonarpulse> ok
11:51:51 <Sonarpulse> thanks
11:51:55 <d3lxa> question: if you have an array and you have to fetch some related info about each entry (map fn lst), thus you "augment" the data for later use, what's your (best) way of doing it? (let's say your in a monad, use DB for example)
11:52:26 <startling> Sonarpulse, cabal repl (in HEAD) might be useful
11:52:27 <Zenol> If I want to convert from a ByteString to a Vector Word8, I can use Vector.fromList . ByteString.unpack or will it really unpack the whole stream?
11:52:33 <Sonarpulse> ah!
11:52:34 <ocharles> d3lxa: mapM?
11:52:44 <startling> Sonarpulse: you can also ghci -lwhatever iirc
11:52:45 <ocharles> d3lxa: possibly with async, if you can augment in parallel
11:53:05 <Sonarpulse> ok
11:53:07 <Sonarpulse> thanks so much
11:53:11 <levi> Disciple has the added benefit of being very close to Haskell.
11:53:57 <d3lxa> ocharles: yes indeed. in parallel? sounds nice; I mean which way to use: save it at each augmentation, each time you create a one-bigger uple, or all at once, or is there a reusable pattern behind this (generalization)?
11:54:17 <ocharles> i'm afraid i'm not really following the question
11:54:43 <FUZxxl> Hello!
11:54:54 <FUZxxl> Somebody an idea how to solve this optimization problem: http://stackoverflow.com/q/18570427/417501 ?
11:54:56 <levi> But see SPJ's talks for slides that illustrate the likely life cycle of any interesting research language.
11:55:21 <erisco> :t group
11:55:22 <lambdabot> Eq a => [a] -> [[a]]
11:55:26 <erisco> :t sort
11:55:27 <lambdabot> Ord a => [a] -> [a]
11:55:39 <edwardk> @let _Read = prism' show Text.Read.readMaybe . simple
11:55:40 <lambdabot>  .L.hs:207:21: Not in scope: `Text.Read.readMaybe'
11:55:44 <edwardk> shucks
11:55:50 <erisco> > group . sort $ [6,3,7,6,4,2,4,4,3,2,5,4,3,6,7,3,2,4,5,4,3,6,7]
11:55:51 <lambdabot>   [[2,2,2],[3,3,3,3,3],[4,4,4,4,4,4],[5,5],[6,6,6,6],[7,7,7]]
11:55:54 <edwardk> :t Text.Read.readEither
11:55:55 <lambdabot> Read a => String -> Either String a
11:56:00 <erisco> is this the most efficient way to do this?
11:56:15 <edwardk> @let _Read = prism show Text.Read.readEither . simple
11:56:16 <lambdabot>  .L.hs:207:20: Not in scope: `Text.Read.readEither'
11:56:23 <edwardk> aw, old lambdabot is old
11:56:25 <d3lxa> ocharles: let's say I have an id, wants to get n-"joined" data from this id, I can do a mapM and thus outputting a n-uple: my actual way is to do it one augmentation at a time, since I don't know how to do otherwise: do {a <- map lst fn1; b <- map a fn2; … }
11:56:27 <erisco> I suppose it may be ... nlohn
11:56:30 <ddinh> Is there any difference between Text.ParserCombinators.Parsec and Text.Parsec?
11:56:31 <erisco> nlogn
11:56:32 <edwardk> oh
11:56:36 <edwardk> @let import Text.Read
11:56:37 <ReinH> erisco: it can be done in a single traversal, so no :)
11:56:37 <lambdabot>  Defined.
11:56:42 <edwardk> @let _Read = prism show Text.Read.readEither . simple
11:56:43 <lambdabot>  .L.hs:208:9:
11:56:43 <lambdabot>      No instance for (Choice p0) arising from a use of `prism'
11:56:43 <lambdabot> ...
11:56:47 <erisco> ReinH, please demonstrate :)
11:56:48 <ReinH> erisco: do you need them to be sorted or just grouped?
11:57:10 <edwardk> @let _Read :: (Read a, Show a) => Prism String a;  _Read = prism show Text.Read.readEither . simple
11:57:11 <lambdabot>  .L.hs:209:30:
11:57:11 <lambdabot>      Expecting two more arguments to `Prism String a'
11:57:11 <lambdabot>      In ...
11:57:12 <erisco> ReinH, um depending on what you mean, I think just grouped
11:57:17 <edwardk> @let _Read :: (Read a, Show a) => Prism' String a;  _Read = prism show Text.Read.readEither . simple
11:57:19 <lambdabot>  Defined.
11:57:20 <edwardk> sorry for the spam
11:57:26 <ReinH> erisco: as in, do the resulting groups need to be sorted?
11:57:30 <erisco> no
11:57:31 <edwardk> > _Read # 12
11:57:36 <lambdabot>   "12"
11:57:47 <edwardk> > "EQ ^? _Read :: Maybe Ordering
11:57:48 <ocharles> d3lxa: well 'mapM fn1 lst >>= mapM fn2' *might* be writeable as 'mapM (fn1 >=> fn2) lst'
11:57:48 <lambdabot>   <hint>:1:31:
11:57:49 <lambdabot>      lexical error in string/character literal at end of input
11:57:50 <edwardk> > "EQ" ^? _Read :: Maybe Ordering
11:57:54 <lambdabot>   Just EQ
11:58:08 <ocharles> d3lxa: depending on what the actual action is. so if you have lots of functions, you can fold them all under (>=>)
11:58:17 <mr-> 1Oh, readMaybe
11:58:37 <ocharles> that transformation will always type check, but whether or not it keeps the same semantics would depend on what fn1 does and what monad you're in
11:58:39 <edwardk> or maybe that should be _Show
11:58:47 <d3lxa> > :t (>=>)
11:58:48 <lambdabot>   <hint>:1:1: parse error on input `:'
11:58:52 <edwardk> shachaf: thoughts?
11:58:55 <ocharles> :t (>=>)
11:58:56 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:58:59 <startling> d3lxa: ^
11:59:11 <ocharles> d3lxa: >=> is like (.), but for monadic actions
11:59:12 <Zenol> Ok, better question. What is the good way to read a Vector Word8 from a file, strictly (and if possible peaces by peaces, beacause I nead to break the whole file in some Vector of fixed sizes).
11:59:13 * d3lxa scratching his head, yep thx
11:59:27 <Zenol> *need
11:59:47 <startling> d3lxa: "\x -> a x >>= b" is "a >=> b"
12:00:01 <erisco> :t sortBy
12:00:15 <ReinH> erisco: hmm, you'd need a structure that has O(1) inserts
12:00:27 <ReinH> fromListWith is n*log n
12:00:30 <ReinH> for Map
12:00:31 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:00:32 <shachaf> edwardk: On the name?
12:00:33 <ReinH> erisco: so maybe no
12:00:38 <edwardk> shachaf: yeah
12:00:54 <shachaf> edwardk: Probably _Show is better than _Read, since _Show # x = show x
12:01:01 <edwardk> sold
12:01:06 <shachaf> But I don't think either one is quite right.
12:01:15 <shachaf> But there's no common name for the combination, so eh.
12:01:19 <shachaf> Is this a legal prism?
12:01:36 <startling> :t (#)
12:01:37 <lambdabot> parse error on input `)'
12:01:43 <edwardk> if you have non-crappy read/show it is at least an improper prism of the normalizing kind. =)
12:01:58 <elliott> you could call it _Text!
12:02:02 <erisco> :t groupBy
12:02:03 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:02:04 <edwardk> in that the result is idempotent
12:02:48 <edwardk> :t _Read
12:03:23 <shachaf> I wonder whether there should be a lens thing for specifying types?
12:03:38 <edwardk> saying a proxy or some such?
12:03:41 <startling> asLensOf?
12:03:48 <shachaf> Maybe you can use Equality.
12:04:14 <startling> It'd be useful to be able to specify the tuple lenses
12:04:32 <shachaf> > "EQ" ^? _Read . (id :: Equality' Ordering Ordering)
12:04:36 <lambdabot>   Just EQ
12:04:48 <erisco> :t \f -> (:) f
12:04:49 <lambdabot> a -> [a] -> [a]
12:04:56 <shachaf> I,I type Equality'' s = Equality s s s s
12:05:11 <Eduard_Munteanu> I would like an asEdwardKWouldDo :P
12:05:49 <shachaf> edwardk: readEither isn't right.
12:06:00 <startling> kmettly
12:06:15 <shachaf> > readEither "123"
12:06:16 <lambdabot>   Left "Prelude.read: no parse"
12:06:33 <shachaf> (Well, it isn't right when it's left, at least.)
12:06:34 <ReinH> Eduard_Munteanu: WWEKD?
12:06:44 <erisco> :t foldr
12:06:45 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:07:41 <edwardk> shachaf: i can switch to readMaybe i suppose
12:07:43 <edwardk> :t readMaybe
12:07:44 <lambdabot> Read a => String -> Maybe a
12:08:32 <Eduard_Munteanu> ReinH: WWEKD?
12:08:34 <shachaf> It's simple anyway.
12:08:53 <edwardk> was readMaybe only added in 7.6? or 7.4?
12:08:57 <shachaf> @let _Show = prism' show readMaybe
12:08:58 <lambdabot>  .L.hs:211:9:
12:08:58 <lambdabot>      No instance for (Choice p0) arising from a use of prism'
12:08:58 <lambdabot>  ...
12:09:02 <shachaf> 7.6, I think.
12:09:13 <ReinH> Eduard_Munteanu: What Would Edward K Do?
12:09:17 <edwardk> hrmm =(
12:09:19 <prophile> furthermore, when /w 24
12:09:26 <prophile> uh
12:09:27 <edwardk> we need to support 7.4
12:09:32 <prophile> so (1) I don't know how to irssi
12:09:37 <prophile> and (2) I have no idea where that came from
12:09:51 <shachaf> > review (prism' show readMaybe) 5
12:09:53 <lambdabot>   No instance for (GHC.Read.Read a0)
12:09:53 <lambdabot>    arising from a use of `Text.Read.read...
12:09:57 <shachaf> > review (prism' show readMaybe . simple) 5
12:09:58 <lambdabot>   "5"
12:10:08 <shachaf> I guess you still need that even with prism'.
12:10:18 <edwardk> :t reads
12:10:19 <lambdabot> Read a => ReadS a
12:10:19 <shachaf> Maybe prism' should restrict the type further?
12:10:33 <applicative> Zenol: what do you mean read a Vector Word8 from a file? there is e.g. Vector.unfoldr ByteString.uncons after eg. ByteString.readFile
12:10:53 <edwardk> guess it'd have to do it by hand using reads to maintain backwards compatibility
12:11:10 <ReinH> erisco: conceptually, if you have a data structure with O(1) modify and O(1) bucketing, you can place each element into a bucket with a single traversal of the list
12:11:22 <ReinH> erisco: I can't think off-hand of a data structure that would allow this
12:11:44 <applicative> Zenol: but that's just one thing you might be after of course
12:11:53 <shachaf> Using reads isn't so bad.
12:12:04 <shachaf> (In a library.)
12:12:17 <startling> readMaybe is pretty easy to derive
12:12:37 <shachaf> edwardk: Hmm, you could have a traversal of all the multiple parses rather than just one.
12:12:38 <startling> I've done it a dozen times. 8)
12:12:41 <thr33strikes> I'm trying to use the isSuffixOf function, and I'm confused about the bool portion of it.  How do I get that output if it's one of the arguments?
12:12:44 <shachaf> (But then it's not a prism anymore.)
12:12:51 <startling> :t isSuffixOf
12:12:52 <lambdabot> Eq a => [a] -> [a] -> Bool
12:12:55 <shachaf> Since no one uses multiple parses it's not worth it.
12:13:15 <shachaf> thr33strikes: It doesn't look like one of the arguments to me.
12:13:17 <startling> > "a" `isSuffixOf` "cba" -- thr33strikes
12:13:18 <lambdabot>   True
12:13:42 <elliott> shachaf: type As a = Equality' a a?
12:13:54 <elliott> "EQ" ^? _Read . (id :: As Ordering)
12:13:58 <shachaf> elliott: It might be worth it adding something like that.
12:14:16 <shachaf> @let type As a = Equality' a a
12:14:17 <lambdabot>  Defined.
12:14:42 <ReinH> edwardk: Question about SOA vs AOS data structures. Shouldn't you be able to use an isomorphism to hide the implementation details so you can interact with whichever shape is easier to use?
12:14:44 <shachaf> > view (id :: As Ordering) minBound
12:14:45 <lambdabot>   LT
12:14:49 <startling> is Equality' just an Endo-ish type synonym?
12:15:16 <shachaf> type Equality' s a = forall p f. p a (f a) -> p s (f s)
12:15:39 <startling> hum
12:15:44 <ReinH> edwardk: like, type R,G,B = Int; Vector (R,G,B) vs (Vector R, Vector G, Vector B), shouldn't I be able to pretend I'm dealing with (R,G,B) pairs while still representing as the latter?
12:16:04 <edwardk> ReinH: thats exactly what vector does
12:16:12 <ReinH> ah right
12:16:23 <Zenol> applicative: Computing a big array from a file. I check the function you wrote to see if it's what I need :)
12:16:23 <edwardk> ReinH: and my wavelet tree stuff is about doing the same thing but now allowing sums
12:16:31 <ReinH> wavelet tree?!
12:17:29 <edwardk> ReinH: take a ook in github.com/ekmett/structures at the implmentation of Data.Vector.Map it abuses Data.Vector.Bit (also defined in there) to make a bitvector that supports O(1) "rank" and then uss that to basically build a Vector (Maybe a) for its values that is unboxable
12:17:48 <ReinH> huh
12:18:16 <edwardk> it does so by using the bit vector's rank (count of True's up to a given position) to offset the index into the vector of a's
12:18:26 <edwardk> we can generalize this though
12:18:27 <Zenol> applicative: Sounds like it's exactly what I'm looking for :)
12:18:33 <edwardk> take any GADT, make a bitvector for the sum parts
12:18:40 <edwardk> er any ADT anyways
12:18:48 <edwardk> then recursively define things for the different cases
12:19:00 <edwardk> and you can get a 'tree of vectors' rather than a vector of trees, that is fully unboxed
12:19:13 <edwardk> if you make the tree of vectors lazy then you can even store infinite structures in it
12:19:23 <edwardk> but forcing any one forces all of the ones with the same shape at least that far
12:19:57 <ReinH> edwardk: huh
12:20:06 <ReinH> this seems useful
12:20:11 <edwardk> if you play some games interleaving the bitmasks you can get a wavelet tree, otherwise you just get a kind of tree i've never named
12:20:12 <edwardk> it is.
12:20:19 <edwardk> that is the other thing that is going into structures after the COLA
12:20:22 <ReinH> what would you use this for?
12:20:27 <ReinH> COLA?
12:20:35 <ReinH> I really need to pay more attention
12:20:48 <edwardk> it gives you something close to a Vector (Maybe a), Vector (Either a b), etc. that is still unboxable
12:21:04 <ReinH> oh
12:21:50 <edwardk> COLA = cache oblivious lookahead array. its a Map made out of flat vectors in a particular geometric order using fractional cascading that lets me make a data structure with the same general API as Map, but which hits the asymptotics of a B-Tree when used ephemerally and amortized
12:21:56 <ReinH> edwardk: I just realized that indexed traversal of a Tree or Cofree [] gives you a path list representation. That's nice.
12:22:04 <edwardk> i've yet to make it fast enough to compete
12:22:08 <ReinH> edwardk: Oh. I know what that is. Didn't know the abbrev :)
12:22:32 <startling> edwardk is branching out into beverages
12:22:35 <ReinH> haha
12:22:52 <edwardk> this is a Diet COLA, because the bitvector helped it lose a lot of weight.
12:23:25 <edwardk> (i can store the forwarding pointer offsets implicitly, so my version takes a lot less memory)
12:23:52 <ReinH> sigh
12:24:35 <edwardk> i figure i can get a "COLA on a functional diet" post out of it ;)
12:24:37 <fizruk> Hi all! I have a strong suspicion that something is wrong with network-simple-tls package (can't build it locally). The error displayed by ghc 7.4 seems reasonable, but the erroneous code seems to be a part of package for a few months, so I'm not sure if it is package's fault. Can anyone approve it can be built or reproduce an error?
12:25:04 <levi> And I thought COLA was 'combined object/lambda abstraction' ;P
12:25:18 <levi> I guess that one didn't catch on!
12:25:40 <edwardk> levi: heh they managed to get the top hit on wikipedia/google though!
12:25:55 <ReinH> edwardk: what would you use today for a 2 dimensional Data.Vector? Would you index into a 1d vector via an iso V2 <-> index?
12:26:12 <dmwit> fizruk: What's the error?
12:26:22 <edwardk> ReinH: i'd probably hack on spars =)
12:26:28 <levi> I think the VPRI stuff is pretty interesting, but would be much more so if it was done more openly.
12:26:38 <ReinH> spars?
12:26:39 <lpaste> fizruk pasted “No title” at http://lpaste.net/92464
12:26:48 <edwardk> ReinH: sparse the project from the matrix multiplication series
12:26:58 <fizruk> dmwit: ^
12:27:13 <edwardk> but i tend to use Vector (Vector a) for now, since that is how linear is structured
12:27:16 <dmwit> fizruk: I suspect you have two versions of crypto-random installed, and that they're getting mixed up.
12:27:20 <edwardk> its not optimal, but it works
12:27:33 <dmwit> fizruk: Could you ghc-pkg list crypto-random? Additionally, ghc-pkg check to look for other fishy things.
12:27:46 <edwardk> i kind of want to do a 'dense' set of morton ordered stuff as well
12:27:47 <ReinH> edwardk: having trouble finding spars :(
12:27:55 <edwardk> spars_e_ i typo a lot
12:28:16 <edwardk> https://github.com/ekmett/sparse
12:28:24 <ReinH> oh.
12:28:46 <ReinH> edwardk: that's what you're building from the SoC series
12:28:50 <edwardk> yeah
12:28:52 <lpaste> fizruk pasted “ghc-pkg list and check” at http://lpaste.net/92465
12:28:59 <ReinH> cool
12:29:07 <ReinH> edwardk: I want to go back to my roguelike again
12:29:38 <edwardk> at the scale of a roguelik vector of vector is fine =)
12:29:50 <ReinH> edwardk: sure
12:30:03 <fizruk> dmwit: I investigated to the point that tls uses crypto-random while network-simple-tls uses crypto-random-api
12:30:07 <edwardk> if you added enormous worlds you may want to look at the morton order =)
12:30:38 <fizruk> dmwit: as I understand, they do not depend on each other and have their own definitions of CPRG typeclass
12:30:45 <ReinH> edwardk: I kind of want to do infinite worlds :)
12:30:51 <ReinH> with a comonad representation
12:30:59 <ReinH> edwardk: the problem is serializing them, I guess
12:31:04 <edwardk> http://www.cs.indiana.edu/~dswise/ppopp01.pdf talks about morton ordering for dense arrays and neat encoding tricks
12:31:18 <fizruk> dmwit: no idea how this could ever work... I must be missing something
12:31:20 <edwardk> the issue with infinite worlds/comonadically is information flow
12:31:26 <ReinH> edwardk: I had an idea for a roguelike with an infinite world where difficulty is proportional to distance from spawn
12:31:33 <dmwit> fizruk: Hm, something seems a bit odd. Let me try installing, too, and see what happens. =)
12:31:37 <edwardk> how do you deal with monsters where at the edge?
12:31:46 <ReinH> right
12:31:50 <Sonarpulse> edwardk: ok, got it
12:31:50 <edwardk> er way out at the edge of the light cone
12:32:01 <Sonarpulse> mind if I submit without new tests
12:32:05 <edwardk> you need to basically be able to dynamically generate the content out at the edge
12:32:07 <edwardk> Sonarpulse: go for it
12:32:08 <Sonarpulse> and if you like it then I'll add tests
12:32:12 <ReinH> edwardk: well, you'd only need to calculate things inside your field of view
12:32:20 <ReinH> you could handwave the rest
12:32:30 <edwardk> ReinH: sure, but then you need a generator that can extend the field of view consistently
12:32:34 <ReinH> right
12:32:40 <edwardk> and to deal with what happens when actors you can't see act
12:32:43 <Sonarpulse> as it changes the API a big (default is now host, as bad as an idea as serializing host-endianess is, for some needed symmetry)
12:32:43 <dmwit> edwardk: Like minecraft. =)
12:32:53 <edwardk> dmwit: very much so =)
12:33:20 <ReinH> dmwit: yep :)
12:33:24 <edwardk> also its not your field of view necessarily but any field of view of any actor you've ever seen, lest you get the problem spelunky has where folks use the frozen zone
12:33:47 <edwardk> er nt even actors you've seen but which have ever seen something you can influence
12:33:48 <ReinH> dmwit: iirc, early versions of minecraft experienced exponential slowdown as you got further from the spawn :)
12:33:55 <edwardk> e.g. consider quake's PHS
12:34:12 <edwardk> i can emit a light that can be seen by anyone who can see what it can see
12:34:13 <ReinH> PHS?
12:34:18 <edwardk> potentially hearable set
12:34:18 <joelteon> so this is weird: https://travis-ci.org/joelteon/melvin#L1080
12:34:21 <ReinH> right
12:34:23 <joelteon> that doesn't happen for me on ghc 7.4
12:34:24 <edwardk> it was the PVS of the PVS
12:34:25 <joelteon> or on 7.6
12:34:27 <joelteon> or 7.7
12:34:32 <joelteon> that build box uses 7.4 afaik
12:34:38 <ReinH> edwardk: shit's complicated
12:34:42 <edwardk> yep
12:34:43 <ReinH> I might stick to finite worlds for now :D
12:34:55 <edwardk> just pointing out the light cone is a first order approximation and interactions are all 2+ =)
12:35:17 <ReinH> edwardk: yep :)
12:35:17 <dmwit> fizruk: I get the same error. Perhaps you should whine at the maintainer a bit.
12:35:45 <fizruk> dmwit: thanks!
12:35:48 <edwardk> ReinH: anyways there are some libtcod bindings someone mentioned that may help you bootstrap
12:36:03 <ReinH> edwardk: oh I know. Or LambaHack.
12:36:27 <ReinH> But I want to learn how those parts work
12:36:34 <lpaste> thr33strikes pasted “can someone explain what I'm doing wrong?” at http://lpaste.net/92466
12:36:44 <dmwit> Well. Light cones are not an approximation. But light speed in games tends to be infinite.
12:37:01 <dmwit> ...which makes the light cone kind of big.
12:37:02 <ReinH> edwardk: for instance I want to learn how to write an efficient Floyd-Warshall for grids of walkable cells.
12:37:20 <dmwit> thr33strikes: You are using ' instead of `
12:37:25 <ReinH> There have to be some efficiencies compared to more general types of weighted directed graphs
12:37:38 <edwardk> do you need negative weights?
12:37:46 <ReinH> edwardk: I don't see why I would
12:37:49 <thr33strikes> dmwit: wow
12:38:14 <dmwit> The "perhaps" in that particular error message is quite deceptive.
12:38:19 <edwardk> then can't you upgrade to dijkstra?
12:38:24 <thr33strikes> dmwit: thanks a lot
12:38:30 <ReinH> edwardk: yeah probably.
12:38:41 <spaceships> can someone write a simple example using foldMap for me?
12:38:47 <S_J> :t foldMap
12:38:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:38:52 <edwardk> > foldMap Sum [1,2,3]
12:38:54 <ReinH> edwardk: but the key is to generate for all pairs
12:38:54 <lambdabot>   Sum {getSum = 6}
12:38:55 * hackagebot th-desugar 1.1.0 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.1.0 (RichardEisenberg)
12:39:00 <ReinH> edwardk: so you can build it when you generate the level
12:39:02 <edwardk> > foldMap id ["hello","world"]
12:39:03 <lambdabot>   "helloworld"
12:39:42 <S_J> @src foldMap
12:39:42 <lambdabot> Source not found. Just try something else.
12:40:00 <ReinH> > foldMap First [Nothing, Just 1, Just 2]
12:40:02 <lambdabot>   First {getFirst = Just 1}
12:40:13 <dmwit> S_J: It's part of Foldable, I guess, so you have to look in the instances to see how it's defined.
12:41:14 <dmwit> ?let ensure p x = x <$ guard (p x)
12:41:16 <lambdabot>  Defined.
12:41:38 <spaceships> I think I need to study Monoids more to get this -- thanks
12:41:42 <dmwit> > foldMap (First . ensure odd) [2,4,6,8,9]
12:41:45 <lambdabot>   First {getFirst = Just 9}
12:41:54 <dmwit> > foldMap (First . ensure odd) [2,4,6,8,9,11,13,15]
12:41:58 <lambdabot>   First {getFirst = Just 9}
12:42:34 <ReinH> Actually, Floyd's doesn't give you the path information, so it's not actually useful
12:42:39 <ReinH> I do want Dijkstra
12:43:01 <ReinH> or the Fib heap version maybe
12:43:04 <edwardk>  you can recover the path by using a suitable ring-like structure
12:43:06 <dmwit> ?let filter' = foldMap . ensure
12:43:07 <lambdabot>  .L.hs:213:11:
12:43:07 <lambdabot>      No instance for (Monoid (f0 a0)) arising from a use of `f...
12:43:12 <ReinH> edwardk: how so?
12:43:17 <dmwit> ah, bugger
12:43:22 <edwardk> track the minimum path as part of your ring
12:43:42 <ReinH> edwardk: I don't have a good enough intuition for algebraic structures to understand what that means :(
12:43:55 * hackagebot diagrams-haddock 0.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2 (BrentYorgey)
12:43:57 * hackagebot hint 0.3.3.7 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.7 (DanielGorin)
12:44:05 <ReinH> :(
12:44:07 <ReinH> aaaaand he's gone
12:44:23 <dmwit> ReinH: Instead of tracking path length, track length and the actual path together.
12:45:35 <ReinH> dmwit: right, track (length, path)
12:45:55 <ReinH> dmwit: in this specific case, a grid with uniform weight, I can just track path because length is sum path :D
12:46:19 <ReinH> although performing the sum is unnecessary so I might as well track length
12:46:21 <dmwit> You can. But it may make sense for modularity's sake to track them separately anyway.
12:46:38 <chrisdone> anyone know how to enable profiling with the ghc api?
12:46:58 <ReinH> plus I already know how to parallelize Floyd's with Repa because of SM's book :D
12:47:01 <ReinH> yay
12:47:08 <dmwit> ReinH: There comes a few places in the Floyd-Warshall algorithm where you have to compare and combine paths. The operations you need are just the operations of a ring.
12:47:14 <dmwit> So congratulations, now you know what a ring is.
12:47:15 <ReinH> dmwit: that makes sense now
12:47:26 <ReinH> dmwit: I know what a ring is already, I just didn't make the intuitive leap :D
12:47:29 <chrisdone> now go take it to mordor
12:47:58 <ReinH> dmwit: basically I need to make [(length, path)] a ring by defining the operations that provide its structure
12:48:07 <dmwit> yes
12:48:10 <ReinH> sweet
12:48:32 <ReinH> I just leveled up :D
12:48:44 <Sonarpulse> edwardk: https://github.com/ekmett/bytes/pull/8
12:49:17 <Sonarpulse> oh no he left.
12:49:19 <edwardk> back
12:49:37 <ReinH> edwardk: I figured it out with dmwit's help. I just need to make (say) (length, path) into a ring
12:49:43 <Sonarpulse> yay!
12:49:44 <edwardk> k
12:49:44 <Sonarpulse> https://github.com/ekmett/bytes/pull/8
12:49:45 <edwardk> yeah
12:49:48 <chrisdone> bos called ircbrowse useless =(
12:49:53 <chrisdone> which i read on ircbrowse =)
12:49:56 <edwardk> chrisdone: =(
12:50:00 <ReinH> edwardk: but Ring isn't a standard typeclass, is it? What do I want?
12:50:08 <Sonarpulse> ironically I didn't actually provide an instance for float
12:50:13 <Sonarpulse> and Double
12:50:43 <edwardk> Sonarpulse: i can't take the patch with it switching the default to host order =(
12:50:54 <dmwit> As we've discovered before: "endianness" ain't the right word for how braindead Float and Double are.
12:51:03 <ReinH> edwardk: it's obvious how to make a Monoid via + and ++, for instance
12:51:13 <edwardk> Sonarpulse: we literally just switched it to this to get sane serialization across platforms
12:51:35 <ReinH> edwardk: I need to make myself a chart of all the common algebraic structures and what each one requires
12:51:41 <bscarlet> dmwit: Which is your complaint with Float & Double?
12:51:51 <edwardk> Sonarpulse: so we may need to rework your patch into a form we can take
12:52:02 <dmwit> bscarlet: The only truly reliable way to serialize it is by printing it to ASCII!
12:52:08 <edwardk> its consistent, but it'd be a serious pain in the ass to actually use in all the situations we currently use bytes
12:52:24 <Sonarpulse> yeah, you would need a lot of
12:52:25 <dmwit> bscarlet: The spec doesn't give enough information or operations to do anything else 100% correctly.
12:52:41 <Sonarpulse> s/serialize/serializeBE/g
12:53:05 <bscarlet> dmwit: which spec?
12:53:10 <dmwit> bscarlet: IEEE754
12:53:32 <dmwit> bscarlet: And even worse, even printing to ASCII doesn't preserve all the different kinds of NaNs there are. So there's literally nothing you can reliably do if that's something you need.
12:53:39 <edwardk> Sonarpulse: that would be non-trivial given the nature of some of the structures we serialize through bytes today
12:53:58 <Sonarpulse> I understand
12:54:12 <mcstar> @hoogle floattorational
12:54:12 <lambdabot> No results found
12:54:39 <dmwit> :t decodeFloat -- mcstar, is this what you're looking for?
12:54:40 <lambdabot> RealFloat a => a -> (Integer, Int)
12:54:45 <monochrom> realToFrac does Float -> Rational
12:54:51 <dmwit> Or yes, realToFrac.
12:54:55 <edwardk> dmwit: you can pretty sanely store an ieee 754 float and just deal with endian-swapping, the only real issue is that haskell will quietly turn on/off signaling nans so you can't use all bit patterns of them in haskel
12:55:04 <chrisdone> :t realToFrac
12:55:05 <lambdabot> (Fractional b, Real a) => a -> b
12:55:06 <bscarlet> dmwit: what kind of problem are you concerned about with the basic "emit the bits" approach?
12:55:07 <monochrom> but decodeFloat is even better
12:55:07 <mcstar> dmwit: for your serialization problems :)
12:55:11 <edwardk> haskell being ghc here
12:55:21 <chrisdone> monochrom: why?
12:55:30 <dmwit> bscarlet: The bit order is not defined. Storage format is defined, but no mapping between storage format and physical format.
12:55:43 <edwardk> we found that out when we were round tripping between scala and haskell and had an endianness bug
12:55:54 <dmwit> bscarlet: (The term "storage format" used in the document is a bit of a misnomer -- it's a logical format, nothing more.)
12:56:07 <dmwit> edwardk: I believe that you can do this by coincidence.
12:56:26 <bscarlet> dmwit: what kind of coincidence?
12:56:33 <dmwit> mcstar: realToFrac doesn't even handle infinities, let alone NaN, negative zero, and other fun stuff
12:56:48 <edwardk> dmwit: while it is a logical format, there is a practical issue that all implementations that one may care to use store it in one of the two naive endian orderings read directly off the storage format description
12:56:55 <Sonarpulse> edwardk: by using CPP I think I could redefine (de)serializeBE
12:56:56 <dmwit> bscarlet: The kind of coincidence that current CPUs happen to agree on bit order for doubles and floats. =)
12:56:58 <Sonarpulse> and -LE
12:57:02 <mcstar> dmwit: but would it be possible to serialize a float as a pair of two integers, a mantissa and an exponent?
12:57:03 <Sonarpulse> keeping BE default
12:57:15 <lpaste> thr33strikes pasted “Works in ghci but not as a script file, can you explain why?” at http://lpaste.net/92468
12:57:15 <dmwit> edwardk: Right. That's what I meant by "coincidence".
12:57:25 <edwardk> Sonarpulse: let's take a step back and design this =)
12:57:28 <dmwit> mcstar: Nothing in the spec allows this.
12:57:35 <mcstar> ok, just asking
12:57:37 <dmwit> mcstar: The spec just *doesn't have the right queries* for it.
12:57:42 <Sonarpulse> sure
12:58:28 <monochrom> thr33strikes: how about adding your own "print"?  print (".jpg" `isSuffixOf` "somefile.jpg")
12:59:11 <chrisdone> hmm. somehow i wanted to read that as: "somefile.jpg" `hasSuffix` ".jpg"
12:59:49 <edwardk> Sonarpulse: the majority usecase is for serializing data to a consistent format across hosts, that the user doesn't think about, network order is love-it-or-not, the default ordering that seems to have won for the most part. so big endian it is for the default Int64, etc. types. now, we can support BigEndian/LittleEndian aliases, but i personally feel typesafe-endian makes the fundamental attribution error of assuming you should
12:59:49 <edwardk>  load something in fully then swap it as a whole, rather than deal with it at the serialization boundary.
12:59:57 <monochrom> please don't use ghci as a standard for the Haskell language
13:00:43 <thr33strikes> I tried earlier printing it similar to what I did with getDirContent and that didn't work do you know why?
13:01:06 <monochrom> I do not want to know. just enter my code.
13:01:20 <Sonarpulse> I made type-safe endian work as it does for stuff like port numbers and other values Haskell AFIAK pulls without changing endianness
13:01:32 <edwardk> Sonarpulse: we could take a step of allowing serializeBE and serializeLE, but then you can't deal with mixed endian formats, e.g. the png example i just posted has parts of both endianness because it uses zlib (little endian) inside chunks that are big endian
13:02:19 <Sonarpulse> serializeBE an serializeLE right now don't have endianness guards in their signiture
13:02:27 <Sonarpulse> the usage is as you say, where you want
13:02:47 <Sonarpulse> A) endiann converted two host while the value is in haskell land
13:03:01 <Sonarpulse> and B) to be able to mix endianness if nessisary
13:04:00 <Sonarpulse> serializeBE an serializeLE you can think if as just using the actual bit fiddling machinary from my library (which i actually didn't write but got from another library)
13:04:14 <Sonarpulse> my notio of type guards isn't imposed on the user of bytes
13:04:31 <Sonarpulse> *notion of endianness type projections isn't...
13:04:42 <edwardk> so, what we could do is make a class for things that can be serialized in a particular endianness. class SerialBE and SerialLE  and put serializeLE and serializeBE in there. i don't love it but it would let you have a serializeBE    that can work across number types/floats, etc.
13:05:16 <edwardk> bu that kind of drags me back to the sort of code duplication i was avoiding by writing bytes in the first place
13:05:59 <Sonarpulse> well then we have the mixed endianness problems too
13:06:10 <augur> erisco: i had an idea!
13:06:16 <Sonarpulse> like with PNG
13:06:40 <Sonarpulse> I agree that that level of type safety can get more in the way then help when writting Serial instances
13:06:51 <edwardk> well, if we view those SerialBE/SerialLE classes as second class citizens, to be used at the leaves then its okay
13:06:54 <startling> is there a nice synonym to traverse the left side of a bitraversable?
13:06:55 <briennetheblue_> thr33strikes you need "let answer =" instead of "answer <-" I think
13:07:18 <edwardk> ten you can serializeLE :: Float -> Put ()  and you're good
13:07:31 <erisco> augur, stunning!
13:07:33 <fizruk>  dmwit: oh, I see, tls package has switched to crypto-random just 2 minor versions ago
13:07:42 <Sonarpulse> ok
13:07:50 <erisco> augur, I tried to hack my program without listish and countish and it wasn't a happy thing :(
13:07:56 <edwardk> and we can then make instances for SerialLE a => Serial (LittleEndian a), etc.
13:08:03 <edwardk> that way you can have your existing aliases
13:08:04 <Sonarpulse> sure
13:08:09 <edwardk> but users aren't forced to use them
13:08:12 <Sonarpulse> should SerialBE just be synnonmy for serial?
13:08:13 <augur> erisco: oh? why not?
13:08:20 <edwardk> i think it should be separate
13:08:22 <Sonarpulse> should there be a SerialHost too?
13:08:26 <NemesisD> is there anything in haskell like naturals that can restrict values to values > 0
13:08:30 <Moggle> thr33strikes: everything in a do block must have a return type of "IO x"
13:08:35 <erisco> augur, it was hideous, took a lot of time, and didn't work =\
13:08:35 <NemesisD> kind of like all the non-empty list packages floating around out there
13:08:40 <edwardk> right now I think s11010001 uses host order for Word and Int as they have unknown size
13:08:44 <Moggle> thr33strikes: GHCI cheats a little bit and lets you avoid doing that
13:08:48 <dmwit> NemesisD: Sure, look on Hackage.
13:08:55 * hackagebot halberd 0.1.2 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2 (ErikHesselink)
13:08:57 * hackagebot network-simple 0.3.0 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.3.0 (RenzoCarbonara)
13:09:05 <erisco> so I might try a different approach
13:09:17 <Sonarpulse> NemesisD: https://github.com/ekmett/nats/
13:09:18 <Moggle> thr33strikes: to avoid that, you use a 'let' binding as briennetheblue_ said
13:09:20 <erisco> augur, working with listCase is really difficult
13:09:23 <erisco> augur, syntatically
13:09:28 <edwardk> i could live with SerialHost + SerialBE + SerialLE
13:09:28 <Sonarpulse> to pass on what I just learned about :)
13:09:39 <spaceships> what's the point of having Ordering be a Monoid?
13:09:53 <Sonarpulse> with ConstraintKinds you can make class synonyms, right?
13:09:54 <edwardk> spaceships: its convenient!
13:10:02 <mauke> > (<>)
13:10:03 <lambdabot>   No instance for (Data.Monoid.Monoid m0) arising from a use of `e_1'
13:10:03 <lambdabot>  The ty...
13:10:09 <edwardk> (a,b) `compare` (c,d) = compare a c <> compare b d
13:10:11 <Moggle> > LE `mappend` GT
13:10:11 <NemesisD> Sonarpulse: i actually have nats as a dependency but i'm not sure how i'd restrict it to > 0, rather than >= 0
13:10:12 <dmwit> NemesisD: You need something lazy?
13:10:12 <lambdabot>   Not in scope: data constructor `LE'
13:10:12 <lambdabot>  Perhaps you meant `LT' (imported from ...
13:10:15 <augur> erisco: you gotta get better at it!
13:10:17 <monoidal> spaceships: you can mappend several orderings to get lexicographic ordering
13:10:20 <augur> erisco: but i had an idea about that anyway :)
13:10:22 <Moggle> > LT `mappend` GT
13:10:23 <lambdabot>   LT
13:10:27 <Moggle> oh right
13:10:29 <edwardk> without that instance you need to write a case and deal with EQ separately yourself on a and c
13:10:31 <erisco> augur, for example here is zipWith on listish: http://lpaste.net/92469
13:10:37 <NemesisD> dmwit: doesn't really matter
13:10:37 <erisco> augur, hardly the two lines it normally is
13:10:39 <Moggle> the monoid for Ordering lets you 'short circuit' early
13:10:39 <edwardk> or you have to make up some godawful combinator
13:10:39 <erisco> @src zipWith
13:10:40 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:10:40 <lambdabot> zipWith _ _      _      = []
13:10:47 <erisco> augur, but what was your idea? :D
13:10:48 <monoidal> spaceships: (x,y) `compare` (z,t) = (x `compare` z) `mappend` (y `compare` t)
13:10:49 <sirspazzolot> thought exercise: how would I implement 'reverse' with recursion? (been going through lyah in bursts, ie very novice)
13:10:56 <Sonarpulse> NemesisD, ah you need a Wholes then
13:11:01 <edwardk> > zipWith compare "hello" "world"
13:11:02 <lambdabot>   [LT,LT,LT,EQ,GT]
13:11:08 <spaceships> monoidal: oh, that's cool
13:11:10 <Sonarpulse> sorry  didn't think differece between => and >
13:11:12 <edwardk> > fold $ zipWith compare "hello" "world"
13:11:13 <lambdabot>   LT
13:11:18 <mauke> > sortBy (comparing length <> compare) (words "what is the point of having Ordering be a Monoid")
13:11:19 <lambdabot>   ["a","be","is","of","the","what","point","Monoid","having","Ordering"]
13:11:30 <spaceships> mauke: ooooooh
13:11:31 <edwardk> (that doesn't deal with the length issue)
13:11:35 <dmwit> NemesisD: http://hackage.haskell.org/package/nat
13:11:41 <Moggle> sirspazzolot: Take the first element of the list, recursively sort the tail of the list, then put the first element at the end
13:11:42 <augur> erisco: you're writing all of this with combinators. thats a bad idea. also your zipWith2 is horrid, dont do that
13:11:51 <Moggle> sirspazzolot: if you want code I can do that
13:11:57 <augur> erisco: you're supposed to used caseListish to stand in for pattern matching
13:11:58 <erisco> augur, it follows the same definition as in the prelude
13:12:09 <erisco> augur, that is even more verbose and hard to read
13:12:10 <edwardk> spaceships: the question you should usually ask isn't "what is the point of this instance?" like you want to take it away, but rather how can I use it =)
13:12:12 <augur> erisco: prelude surely doesnt use null, etc.
13:12:16 <sirspazzolot> Moggle: oh I think that makes sense to me
13:12:20 <mcstar> Moggle: why sort?
13:12:22 <augur> erisco: lemme show you the right way to do it
13:12:22 <erisco> augur, you are right... it uses pattern matching
13:12:26 <erisco> augur, okay :)
13:12:27 <spaceships> edwardk: very well, duly noted ;)
13:12:34 <dmwit> sirspazzolot: Turn your list into a zipper, walk to the end of the zipper, and emit elements as you walk back.
13:12:41 <Moggle> mcstar: uh, i meant reverse not sort
13:12:44 <erisco> but if you use lambdas with listCase, I tried that, and it works but it difficult to read
13:12:44 <Moggle> mcstar: mah bad!
13:12:47 <dmwit> sirspazzolot: If you want code I can do that. ;-)
13:12:54 <edwardk> spaceships: when the instance is unambiguous it is almost always a good thing to have, as people find very odd and unintended uses for the instance later on in my experience
13:13:39 <Sonarpulse> edwardk: shall I redo it then with the three classes?
13:13:56 <edwardk> Sonarpulse: yeah added to the existing Serial class i think that'd be pretty useful
13:14:09 <Sonarpulse> oh, so you want
13:14:17 <thr33strikes> Moggle and Brienn: thanks
13:14:18 <Sonarpulse> Serial, SerialBE, SerialLE, and SerialHost?
13:14:21 <edwardk> yes
13:14:33 <Sonarpulse> ok!
13:14:42 <edwardk> SerialBE/SerialLE and SerialHost will be for specifying ordering. Serial lets the protocol pick
13:14:46 <Moggle> Question: reverse . reverse $ [1..] basically won't work (GHCI doesn't optimize it). I'm curious, does anyone think it *should* optimize it? I'm torn between thinking optimization should not change the behavior of the unoptimized program, and the fact that it just makes sense that it can be optimized away.
13:15:03 <Moggle> Of course, you should never be writing that code so...
13:15:15 <Sonarpulse> should Serial have Default instance provided by SerialBE?
13:15:23 <roconnor> Moggle: I think it should be optimized, or at least have such an option.
13:15:28 <roconnor> I'm in the minority I think
13:15:28 <edwardk> Serial has a default using generic programming
13:15:38 <Sonarpulse> you can
13:15:39 <edwardk> you can copy the generic programming approach over to the other classes
13:15:41 <dmwit> :t let fromList xs = ([], xs); right (xs, y:ys) = (y:xs, ys); right end = end; emit = fst {- sneaky trick! -} in emit . until (null . snd) right . fromList
13:15:42 <lambdabot> [a] -> [a]
13:15:49 <shachaf> roconnor: "optimized"?
13:15:50 <Sonarpulse> only one default instance per method then?
13:15:54 <edwardk> correct
13:15:56 <Sonarpulse> ok
13:16:00 <erisco> Moggle, reverse . reverse == id does not hold just as you've shown
13:16:14 <dmwit> roconnor: Optimized to what, out of curiosity?
13:16:17 <roconnor> shachaf: I'd like an optimization mode that may promote non-total values to total ones.
13:16:20 <Moggle> erisco: it *does* hold for non infinite lists, though. it's basically lazy evaluation that's messing everything up
13:16:24 <NemesisD> dmwit: so is the idea there to pattern match on the Nat type and throw a fit if it uses the Zero constructor?
13:16:29 <roconnor> dmwit: reverse . reverse optimized to id.
13:16:34 <dmwit> roconnor: right
13:16:44 <dmwit> NemesisD: No, use the Nat1 type.
13:16:55 <Sonarpulse> and lastly, should the secondary instances be in a different module?
13:17:02 <mcstar> @pl \l -> flip (++) [l]
13:17:13 <lambdabot> flip (++) . return
13:17:14 <lambdabot> optimization suspended, use @pl-resume to continue.
13:17:15 <thr33strikes> Moggle:  I'm looking at the type FilePath and it says it's a String.  Is there a way to break it up into characters in order to manipulate the filename or is there already a function that does it.  I've tried searching Hoogle but didn't see anything can you point me in the correct direction?
13:17:18 <roconnor> I haven't thought deeply about the consequences, but an optimization mode where it allows things that preserve total values but may promote non-total values.
13:17:27 <edwardk> roconnor: i'm generally okay with rewrite rules increasing the definedness of a program. foldr/build fusion is predicated on that in many ways
13:17:31 <Caztiel> hey
13:17:32 <Sonarpulse> Data.Bytes.Serial.Endian ?
13:17:39 <Moggle> thr33strikes: Strings ARE [Char].
13:17:39 <roconnor> edwardk: good to know I'm not alone then.
13:17:55 <mcstar> > foldr (flip (++) . return) [1..10]
13:17:56 <lambdabot>   <[Integer] -> [Integer]>
13:17:59 <Caztiel> what's the best way to install Haskell on Fedora? yum install @haskell or haskell-platform? I noticed a big difference in the depencies count
13:18:00 <augur> erisco: annotated with and without insightful comments
13:18:01 <mcstar> > foldr (flip (++) . return) [] [1..10]
13:18:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
13:18:15 <edwardk> Sonarpulse: lets just put them in the same module, as annoying as it is
13:18:18 <NemesisD> dmwit: ah ok. thanks. I'll give it a shot
13:18:19 <donri> is there any way with TH to pprint a Type without module qualifications? as with nameBase but Type -> Doc
13:18:25 <erisco> augur, what is? :)
13:18:31 <augur> erisco: what is what
13:18:32 <Moggle> thr33strikes: You can manipulate a FilePath exactly the same way you would manipulate a regular list of Chars.
13:18:33 <roconnor> some people have counter argued that people want to use partial values to enforce a security of software.
13:18:39 <erisco> augur, what is annotated?
13:18:44 <thr33strikes> Moggle: that's what I thought but I am getting a " couldn't match expected type error saying the compiler was expecting Char instead of filepath
13:18:52 <augur> erisco: your past
13:18:52 <augur> e
13:18:55 <roconnor> I'm not sure I completely buy that arugment, but it is a reasonable argument.
13:18:59 <mauke> thr33strikes: Char isn't a list of Chars
13:19:01 <Sonarpulse> edwardk
13:19:03 <Sonarpulse> ok
13:19:05 <Moggle> thr33stirkes: Sounds like you're passing something a [Char] rather than a Char
13:19:07 <erisco> http://lpaste.net/92469?
13:19:14 <Moggle> thr33strikes: Sounds like you're passing something a [Char] rather than a Char rather
13:19:30 <roconnor> I think relying on partial values for security of software is not cool.
13:19:32 <edwardk> roconnor: the utility of that argument is rather less than that of 'having everything be faster by fast and loose equational reasoning' =)
13:19:42 <roconnor> edwardk: I agree
13:19:45 <Moggle> thr33strikes: If you could show me your code, I could point you in the right direction.
13:20:33 <erisco> augur, I was under the impression that YOU were going to be making a paste :)
13:20:36 <lpaste> thr33strikes pasted “Here it is” at http://lpaste.net/92471
13:20:39 <spaceships> The Endo Monoid is cool! What is it good for?
13:20:45 <dmwit> erisco: he did
13:20:47 <spaceships> edwardk: how's that? ;)
13:20:48 <dmwit> erisco: open it and see
13:20:54 <augur> erisco: i did
13:20:57 <erisco> what?
13:20:58 <Moggle> Catziel: Haskell-platform just includes a lot of libraries that tend to be super useful, I'd really recommend it unless you're hard on disk space.
13:21:02 <augur> erisco: i annotated your paste
13:21:08 <erisco> ohhhhhhhh
13:21:11 <Moggle> Caztiel: Haskell-platform just includes a lot of libraries that tend to be super useful, I'd really recommend it unless you're hard on disk space.
13:21:28 <mauke> @hoogle getDirectoryContents
13:21:28 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
13:21:49 <Caztiel> Moggle: and @haskell is just the compiler/ interpreter?
13:21:52 <erisco> augur, I had this but how can you find that not difficult to read?
13:22:10 <erisco> the next function I have to redefine has four list arguments
13:22:12 <Caztiel> Moggle: or with the standard library? and haskell-platform with a lot of libraries?
13:22:16 <Moggle> Caztiel: correct, along with the base libraries. Haskell-platform inclues a lot of useful libraries that *should* be in the base Haskell libraries.
13:22:25 <Caztiel> ah I see :)
13:22:27 <Caztiel> thanks
13:22:30 <Moggle> Caztiel: no problem :)
13:22:46 <Moggle> thr33strikes: as mauke noted, getDirectoryContents returns IO [FilePath]
13:22:58 <augur> erisco: its just some noisy case stuff
13:23:09 <ReinH> edwardk: question for you. If I have a type Grid a = Vector (Vector a), it seems like it might be useful to index it by V2 Int. Is there an easy way to make it indexable or provide *WithIndex instances or whatever I need to do?
13:23:27 <Moggle> thr33strikes: so your last line is not correct
13:23:46 <ReinH> iow I'd like to make it play nicely with itraverse and friends
13:23:51 <erisco> augur, was this your idea?
13:23:56 * hackagebot halberd 0.1.2.1 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.1 (ErikHesselink)
13:23:56 <ocharles> with the 'network' package, is Network.Socket.send guaranteed to have sent (some of) the data when it returns?
13:24:17 <ocharles> i'm trying to debug some networking stuff, and strace shows 'writev' being called on the socket as expected, but nothing is actually getting to the remote server it seems
13:24:22 <Moggle> thr33strikes: essentially you'll want to 'loop' over every FilePath in getDirContent with forM or mapM.
13:24:25 <ocharles> i'm not sure if this is some buffering or something
13:24:29 <edwardk> ReinH: put a newtype wrapper around it when needed?
13:24:31 <ion> How do you define “have sent”? “Have passed to the system’s TCP/IP stack”?
13:24:32 <Eduard_Munteanu> I'm using TH to write a typesafe parser. Is there something in lens I can use to tell TH to store a particular thing in a record field?
13:24:34 <Moggle> thr33strikes: If you're not familiar with how to do that, I can write some code for you.
13:24:42 <edwardk> ReinH: you can also use ifolded<.>ifolded to get the pair
13:25:03 <thr33strikes> Hoggle: thanks but I want to try to learn some of this on my own
13:25:15 <briennetheblue_> thr33strikes, http://lpaste.net/92471 works, right?
13:25:20 <augur> erisco: hold on, im implementing it
13:25:28 <jeff_s1> Any idea why my memory is filling up with MUT_ARR_PTRS_FROZEN?
13:25:41 <Eduard_Munteanu> I'm thinking of quoting a setter by name but that's a bit unsafe because I might miss one.
13:25:48 <ReinH> edwardk: I might as well make Grid a newtype so I can provide instances?
13:25:53 <trevorfancher> So I am following http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid so I can call lambdabot from GHCI
13:26:04 <trevorfancher> But lambda fails to install via cabal
13:26:16 <erisco> augur, the genericity of algorithms like zipWith become rather exciting if you ask me :)
13:26:17 <trevorfancher> The Undo plugin doesn't build. Any suggestions?
13:26:24 <edwardk> ReinH: sounds plausible =)
13:26:26 <trevorfancher> I am on the most recent Haskell Platform
13:26:28 <Moggle> thr33strikes: kay, let me know when/if you need more help. haskell's learning curve is ridiculous, so don't be afraid to ask for help :P
13:26:46 <Moggle> that said, Haskell is wonderful and easy in retrospect.
13:26:55 <Moggle> i think if Haskell was my first language I would have had a very easy time learning it
13:27:09 <Eduard_Munteanu> Moggle: that's quite possible
13:27:12 <edwardk> Eduard_Munteanu: not sure what you mean in that i don't see what is different about doing this at TH time than any other time
13:27:18 <jeff_s1> Haskell is great until you get an out of memory error, and your profiler says your memory is full of MUT_ARR_PTRS_FROZEN ><
13:27:20 <thr33strikes> Moggle: You've explained a lot that I'm missing, thanks.
13:27:49 <jeff_s1> Perhaps it's something to do with Vector.cons...
13:28:13 <Moggle> Whereas something like C# or Ruby I could pick up in a day or two of tinkering, thanks to previous exposure to imperative languages
13:28:15 <applicative> jeff_s1: which module of vector?
13:28:27 <thr33strikes> briennetheblue:  I'll check it out and try to learn from what you gave me.  Thanks.
13:28:27 <Moggle> Months later, I'm still feeling rather overwhelmed by everything there is to learn.
13:28:42 <Moggle> It doesn't help being in the same channel as edwardk and realizing you've wasted the first 20 years of your life.
13:28:56 <augur> erisco: annotated again
13:29:02 <briennetheblue_> thr33strikes, you didn't have any brackets in that line with map, so i think it was as if you'd written '(map isSuffixOf ".jpg") getDirContent' which isn't what you meant
13:29:09 <edwardk> Moggle: i wasted a lot of mine too =)
13:29:10 <mcstar> haskell is a tool, like any other prog. lang
13:29:14 <ReinH> edwardk: oh, g^@..ifolded<.>ifolded nice
13:29:20 <Eduard_Munteanu> edwardk: I want to direct the parser output to different fields of different records. I guess I can write something that checked if all fields of all records got filled, but is there anything better?
13:29:21 <thr33strikes> ic
13:29:24 <Moggle> edwardk: shh you're making me even more jealous :P
13:29:34 <augur> erisco: the idea was to take your idea about oust seriously
13:29:44 <Eduard_Munteanu> Oh... maybe I should use the constructors directly.
13:29:50 <edwardk> Eduard_Munteanu: we don't have any sort of totality checker like that. we talked about it, but the 'bokeh'-lenses are just too damn hard to write and need too many instances =(
13:30:08 * Eduard_Munteanu googles that name
13:30:09 <applicative> jeff_s1: is there anything else you can say about the case?
13:30:21 <edwardk> Eduard_Munteanu: if you're parsing then the Foo <$> parseField1 <*> parseField2 <*> parseField3   approach is probably better than doing t by field
13:30:37 <mcstar> my guess is that he is using vectors as he would lists
13:30:38 <Eduard_Munteanu> Hm, yeah.
13:30:41 <augur> erisco: can then eliminate the case methods entirely this way, making Viewable a superclass of the relevant things, and then define your equations using haskell's internal case
13:31:13 <erisco> augur, I am going to get a little something to eat
13:31:24 <erisco> augur, then I am going to take a real close look and determine just how brilliant this is
13:31:41 <applicative> mcstar: well there's a number of ways of going wrong, not that I am aware of more than 1/3 of them ;)
13:31:57 <mcstar> applicative: code would be helpful... :)
13:32:48 <edwardk> Eduard_Munteanu: the idea is that you can view a lens as splitting a value 's' into two parts, the stuff you are focusing on 'a'   and some extra stuff 'x', lets call it the "bokeh" as that is the stuff in an image that is out of focus of the lens. normally we just know that x exists and don't name that type.   and we have s <-> exists x. (a, x)   for a lens
13:32:55 <edwardk> Eduard_Munteanu: this is the concept of an isomorphism lens.
13:33:21 <edwardk> Eduard_Munteanu: upgraded to lens style lenses you'd have exists x. (s -> (a, x), (b, x) -> t)
13:33:24 <Eduard_Munteanu> Something like a zipper?
13:33:29 <HugoDaniel> hi
13:33:41 <Eduard_Munteanu> HugoDaniel: hey
13:33:47 <HugoDaniel> :D
13:33:48 <edwardk> Eduard_Munteanu: when we make a 'bokeh' style lens we'd let you see the type 'x' ripping off the coend that locks it away from you.
13:33:57 <edwardk> then it becomes part of the type like s t a b
13:34:01 <edwardk> x s t a b
13:34:12 <mcstar> he meant fstab
13:34:27 <edwardk> now we can talk about whether we've fully applied a lens by talking about whether x = ()
13:34:27 * chrisdone makes the psycho sound
13:34:37 <Eduard_Munteanu> Oh, hm.
13:35:11 <edwardk> and we can allow 'multiple fields' to be set in parallel, if we make sure 'x' supports all the lenses for the fields that s supported minus the one you used to get in there.
13:36:11 <tomboy64> hahaaaa
13:36:13 <tomboy64> so excited
13:36:16 <shachaf> Typing all these lens types in gets tiresome. I should implement stab completion.
13:36:18 <Eduard_Munteanu> I wonder if Data.Data and friends can do something like it.
13:36:25 <Eduard_Munteanu> Hah, shachaf
13:36:26 <tomboy64> it's computing my solution for project euler #303
13:36:29 <edwardk> but now we need an explosive number of bokeh types for a given type. given data Foo a = Foo { _a,_b, _c :: a }   a -- the bokeh style would need 'x's for Foo sans a, sans b, sans c, sans ab, sans ac, sand bc, sans abc, etc.
13:36:36 <jeff_s1> applicative: https://github.com/shawjef3/levgen-benchmarks/blob/master/H.hs
13:36:45 <edwardk> Eduard_Munteanu: Data.Data isn't sufficient, GHC.Generics isn't sufficient
13:37:02 <Eduard_Munteanu> edwardk: presumably TH lets you build those types en masse
13:37:03 <shachaf> edwardk: I wonder whether we can implement a replacement for "lens"/"prism" that uses this?
13:37:11 <jeff_s1> I've been working on the Haskell portion of http://togototo.wordpress.com/ .
13:37:25 <edwardk> you need to literally make a class for the fields, then make instances for them on a case by case basis, you wind up with 2^n bokeh types for a type with n fields, O(n*2^n) instances etc
13:37:28 <Eduard_Munteanu> Oh, but the order also matters.
13:37:32 <Eduard_Munteanu> Yeah.
13:37:41 <shachaf> prism :: (s -> Either x a) -> (Either x b -> t) -> Prism s t a b or something
13:37:55 <Eduard_Munteanu> I see, it is a bit crazy.
13:37:58 <edwardk> Eduard_Munteanu: its just a _lot_ of boilerplate for types that _most_ users will never use
13:38:02 <edwardk> so we threw it away
13:38:06 <edwardk> it was a possible thing
13:38:10 <edwardk> but its not a viable thing =)
13:38:36 <edwardk> the compromise is the 'exposed' lenses, which also let you do some of the things you can do with a bokeh lens
13:38:36 <Eduard_Munteanu> edwardk: what if you set things all at once?
13:38:48 <edwardk> well, if you set all the things, just use a prism or something for the constructor
13:38:56 <edwardk> why name them by field?
13:39:01 <chrisdone> i suspect edward is escaping a past life in which he did some bad stuff, hence the beard, that's cover, and doing haskell work, that's penance, but he can't help slip in words from his past work into the types
13:39:01 <Eduard_Munteanu> Hm, right.
13:39:39 <chrisdone> A Haskell of Violence
13:39:55 <luite> oh hai chrisdone
13:40:09 <edwardk> it'd be _nice_ to have a syntax for foo & _x .~ … & _y .~ … & _z .~ …   that could check that you didn't miss initializing any parts of foo, and lets you use the lens names, but it comes at way too high a cost i think
13:40:40 <edwardk> maybe a TH quasiquoter or something if you really want it =)
13:40:41 <Eduard_Munteanu> edwardk: maybe it can be checked in TH rather than the typesystem?
13:40:57 <chrisdone> luite: hai. i got an idea for doing source maps from core and stg, enable profiling -fprof-auto, so exprs are annotated with tickish's that contain srcspans
13:41:07 <Eduard_Munteanu> Should be easy to go over the fields in TH tho' not as nice as misusing the type system :)
13:41:27 <edwardk> [new| foo | x = … | y = … |]   or somthing
13:41:37 <augur> anyone know if the -> view pattern thing can work without the explicit view, currently?
13:41:45 <augur> or was that feature not implemented
13:41:58 <edwardk> augur: you need to use the explicit ->
13:42:02 <Eduard_Munteanu> augur: something like instance resolution?
13:42:06 <augur> edwardk: yes but i mean the thing to its left
13:42:10 <augur> (view -> foo)
13:42:11 <augur> vs
13:42:13 <augur> (-> foo)
13:42:23 <luite> chrisdone: the source locations from the identifiers are not enough?
13:42:25 <augur> i just get a parse error with that
13:42:26 <chrisdone> what would that mean? the view is the left
13:42:28 <edwardk> you need to supply something, otherwise it is like an empty expression, it won't parse
13:42:30 <chrisdone> the right is the pattern
13:42:33 <edwardk> (id -> ...)
13:42:49 <augur> chrisdone, edwardk: ok. there were suggestions that it would default to a view class method
13:42:49 <edwardk> that is the equivalent of writing foo =
13:42:58 <chrisdone> luite: well what does that give you?
13:42:58 <augur> http://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
13:43:01 <edwardk> augur: no class was built
13:43:17 <Eduard_Munteanu> I thought augur wanted the view function to be dispatched according to the type of the rhs of -> and the type of the arg.
13:43:23 <chrisdone> augur: ah, that sounds cool
13:43:28 <edwardk> class View a b  sounds like a lovely recipe for terrible inference
13:43:34 <luite> chrisdone: haven't tested, but most things in a source file are going to have an Id somwhere don't they?
13:43:34 <augur> edwardk: :)
13:43:57 <luite> chrisdone: or do the id's of functions refer back to where they are defined?
13:44:27 <shachaf> @let blens :: (s -> (x,a)) -> ((x,b) -> t) -> Lens s t a b; lens' to fro f s = let (x,a) = to s in (\b -> fro (x,b)) <$> f a
13:44:28 <lambdabot>  .L.hs:214:1:
13:44:28 <lambdabot>      The type signature for `blens' lacks an accompanying binding
13:44:35 <shachaf> @let blens :: (s -> (x,a)) -> ((x,b) -> t) -> Lens s t a b; blens to fro f s = let (x,a) = to s in (\b -> fro (x,b)) <$> f a
13:44:37 <lambdabot>  Defined.
13:44:49 <chrisdone> luite: sure. Names have src spans. but expressions don't, so if your code has a pattern match error in a big function, you just get "theFunctionName", whereas maybe you want to drill down to the actual offending expression
13:45:38 <luite> chrisdone: oh but you can still find the greatest source loc of anything nested under that fun?
13:45:41 <shachaf> Hmm, maybe bprism' :: (s -> Either x a) -> (x -> t) -> (b -> t) -> Prism s t a b is nice.
13:45:53 <chrisdone> in fact if i have
13:45:54 <chrisdone> fib 0 = 0    <- this is the only line that you know about
13:45:54 <chrisdone> fib b = ...
13:46:04 <edwardk> nice, but will it blens?
13:46:04 <dmwit> :t lens
13:46:07 <kryft> What's the best way to turn foo :: [IO a] into bar :: IO [a]?
13:46:15 <dmwit> :t sequence -- kryft
13:46:16 <lambdabot> Monad m => [m a] -> m [a]
13:46:16 <shachaf> @hoogle [IO a] -> IO [a]
13:46:17 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:46:17 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:46:17 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
13:46:18 <chrisdone> luite: hm?
13:46:30 <Eduard_Munteanu> kryft: also have a look at mapM
13:46:30 <kryft> dmwit: Ah, thanks
13:46:32 <Eduard_Munteanu> :t mapM
13:46:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:46:36 <dmwit> So is lambdabot silently ignoring :t errors now?
13:46:47 <augur> erisco: ok, annotated properly
13:46:52 <dmwit> ?src mapM
13:46:52 <lambdabot> mapM f as = sequence (map f as)
13:47:09 <luite> chrisdone: well you know what part of the function contains the patterns, there you also have names
13:47:41 <dmwit> elliott: Make lambdabot say more stuff when :t goes wrong!
13:47:48 <dmwit> (please)
13:47:56 <shachaf> kryft: Also have a look at http://haskell.org/hoogle :-) It's very useful for that sort of question.
13:48:06 <shachaf> dmwit: There's a bug in the ghci code that handles :t.
13:48:19 <shachaf> I'm pretty sure we figured it out once and fixed it, but I don't remember what it was.
13:48:25 <dmwit> heh
13:48:29 <chrisdone> luite: sorry, what good are names of identifiers for expressions?
13:48:29 <augur> erisco: you could try to use some more generic technique of course, so that you dont have to replicate your view methods everywhere
13:48:35 <kryft> shachaf: Thanks, I realized that from people's answers ;)
13:48:49 <luite> chrisdone: that they have a source location too
13:51:07 <Kevin-_-> Hello, I'm trying to construct an array of Binary Trees using their subtrees.  To eliminate duplicates I'm using union, but I keep getting a No instance for (Eq a)...  Here's my code for that.  http://lpaste.net/92478
13:51:07 <chrisdone> luite: but it's the source location of the Name itself...
13:51:10 <augur> is it possible to write a constraint like this:
13:51:18 <augur> class View (f a) (ListView f a) => Listish f where
13:51:20 <mcstar> jeff_s1: what is your motivation for using vectors?
13:51:28 <Sonarpulse> edwardk: I'll have it done later tonight
13:51:30 <luite> chrisdone: ah ok
13:51:33 <augur> where a is bound on the left only?
13:51:33 <edwardk> Sonarpulse: k
13:51:36 <Kevin-_-> When I just type in a couple of example trees into ghci with union it workis
13:51:37 <Kevin-_-> works
13:51:38 <jeff_s1> mcstar: I'm using a vector because the original version did.
13:51:43 <jeff_s1> I could use a list I suppose.
13:51:43 <edwardk> i'm going to close out your existing merge request explicitly
13:51:47 <chrisdone> luite: unless there's something i don't know about with Located or so
13:51:56 <mcstar> jeff_s1: consing is a natural operation on lists
13:52:02 <Kevin-_-> if I substitute union for ++ it works only it has duplicates
13:52:12 <monoidal> Kevin-_-: you need subtrees :: Eq a => BinTree a -> [BinTree a]
13:52:27 <luite> chrisdone: ah ok, i haven't tried it yet :)
13:52:28 <mcstar> jeff_s1: also, did the original version used immutable vectors in the same way as you?
13:52:28 <Kevin-_-> ah ok
13:52:45 <monoidal> Kevin-_-: or Ord, depending on what union does
13:53:06 <chrisdone> luite: i'm using the NamedThing instance of Var which gives you a Name and Name has SrcLoc/SrcSpan
13:53:41 <chrisdone> luite: but all references to e.g. fib in a program i have here are X.hs:8:1
13:54:19 <chrisdone> luite: here's source maps based on Names alone https://www.youtube.com/watch?v=lcR2UdXUQ9Q
13:54:37 <mcstar> .push_back is not equivalent to V.cons, afaik
13:54:39 <Kevin-_-> monoidal: that worked perfect, thanks again.
13:54:53 <chrisdone> luite: and ofc pattern match errors give you location information, so i use that, too. and any invocation of `error' also spits out a mapping
13:54:58 <augur> i guess probably some type functions would be useful here too..
13:55:30 <mcstar> the former one modifies a mutable vector, which is internally overallocated, and allocates/copies ~2n amount, but cons needs to copy the whole vector on each consing
13:56:11 <jfischoff> I'm looking for a Ringoid like monad thing. Something like MonadPlus + annihilation by a 'zero' (error). I don't know if that makes any sense …
13:56:15 * startling realizes belatedly that he could replace ~60 LOC with ask >>= \f -> normalize <$> traverse f term
13:57:02 <chrisdone> luite: so yeah, i'm trying to enable profiling so that i'll get most if not all srcspans by the CostCentre type: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/CoreSyn.html#t:Tickish
13:57:25 <luite> chrisdone: you should set the value to null first before you call the function :p
13:57:27 <chrisdone> otherwise i can't see a way to pass srcloc info through to core
13:58:04 <ocharles> jfischoff: isn't that >> and mzero?
13:58:06 <chrisdone> luite: what value?
13:58:15 <luite> chrisdone: when forcing a thunk
13:58:59 <jfischoff> > mzero `mplus` Just "hey"
13:59:01 <lambdabot>   Just "hey"
13:59:15 <monochrom> startling: haha, that's extreme :)
13:59:18 <chrisdone> luite: why?
13:59:21 <luite> bleh this hackaton has totally broken my productivity :p
13:59:58 <startling> monochrom: the best part is that I had been avoiding those lines because they were so messy.
13:59:59 <ocharles> jfischoff: hmm, i must have read the laws wrong
14:00:01 <jeff_s1> Ya, using a list instead of a vector doesn't cause a memory problem. Stragne.
14:00:07 <mcstar> not really
14:00:17 <mcstar> did you see what i wrote?
14:00:23 <mcstar> didnt nick you
14:00:30 <luite> chrisdone: so that it can be garbage collected, the thunk shouldn't be entered more than once anyway, right? (this would give you something similar to eager blackholing)
14:00:31 <jfischoff> ocharles: also I just realized I want the regular kind :p. Going to look in algebra ...
14:00:37 <ocharles> v >> mzero = mzero
14:00:45 <ocharles> > Just "Hey" `mplus` mzero
14:00:47 <lambdabot>   Just "Hey"
14:00:52 <ocharles> da fuq?
14:00:59 <ocharles> MonadPlus Maybe breaks the laws?
14:01:02 <mcstar> anyway, which package provides Data.List.Split?
14:01:03 <ocharles> duh
14:01:03 <ocharles> >>
14:01:05 <ocharles> not mplus
14:01:10 <jfischoff> oh yeah
14:01:15 <ocharles> hence me saying >> not mplus :)
14:01:16 <dmwit> mcstar: split
14:01:19 <chrisdone> luite: it won't be garbage collected if i don't set it to null?
14:01:21 <mcstar> duh
14:01:37 <luite> chrisdone: if multiple things have a reference to that thunk then no
14:01:50 <luite> of only one thing has a reference then you don't need to update the thunk at all
14:03:40 <luite> chrisdone: though i'm not sure what your tail-call model is, perhaps it's different for you
14:03:56 * hackagebot hspec-expectations-pretty 0.1 - hspec-expectations with pretty printing on failure  http://hackage.haskell.org/package/hspec-expectations-pretty-0.1 (GregWeber)
14:04:32 <luite> chrisdone: btw if you're using ghc as a frontend, do you need any customization from the api? i have a patch that lets you customize ffi types, ffi desugaring, hook into the driverpipeline (get stability checking for free) and a few other things related to getting working template haskell
14:04:36 <chrisdone> luite: i'd have to profile it before making any decisions
14:05:35 <chrisdone> luite: possibly later. i'm still just at playing around stage at the moment
14:05:48 <luite> oh but then 7.8 will be out!
14:05:58 <luite> without the chance of getting stuffs in
14:06:23 <chrisdone> not a big deal, i might never release this
14:06:43 <luite> chrisdone: perhaps you can help me think of features that are still missing from ghcjs and might require some ghc api patch to support them!
14:07:05 <chrisdone> source maps =p
14:07:13 <luite> yeah good one :p
14:07:21 <chrisdone> you've presumably written a nontrivial app with ghcjs
14:07:33 <luite> all apps are trivial once they're written ;p
14:07:35 <chrisdone> and when exceptions are thrown, it's really nice to know where it came from
14:07:48 <monochrom> oh! that's a nice one.
14:08:30 <monochrom> every time there is a translation, the reverse problem "how to map errors back" is always a bigger problem.
14:08:57 * hackagebot mongodb-queue 0.2.5.3 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.5.3 (GregWeber)
14:08:57 <chrisdone> yeah
14:09:02 <monochrom> someone will now say: every translation should be a profunctor. or something. :)
14:09:17 <luite> chrisdone: the pattern match failure exceptions from ghc do include line info
14:09:27 <mcstar> jeff_s1: well, i still have the version with vectors.. :)
14:10:01 <chrisdone> luite: yup, as i said above, i'm using that and the sourcemap contains entries for it
14:10:01 <luite> chrisdone: and i have some ffi changes (not yet pushed) so that js exceptions get converted into haskell exceptions for safe and interruptible imports
14:10:26 <chrisdone> yeah i was thinking of something similar too
14:10:39 <chrisdone> catching js exceptions and translating them into something mapped to the ffi call
14:10:51 <luite> currently for ghcjs unsafe = insert code directly, safe = catch js exceptions, interruptible = async ffi thing
14:11:53 <luite> first i was thinking of changing the parser grammar in ghc for javascript imports, but this actually maps nicely to these things, even though the semantics are different from native code
14:12:07 <DRiKE> when using FSNotify's watchDir, is there a way to get the eventPath in a String-format? I just want to output the filenames of the changed files.
14:12:25 <luite> DRiKE: you can convert it, somehow :)
14:12:40 <luite> with show, perhaps
14:12:52 <DRiKE> is that.. good practice?
14:13:06 <luite> or encodeString
14:13:17 <luite> well, they're not really String, they're platform dependent
14:13:25 <chrisdone> for debugging, Show is good
14:13:30 <luite> unix paths have no specific encoding
14:13:34 <luite> so you're guessing a bit there
14:13:41 <chrisdone> for actual programs, no, there should be a conversion class
14:13:51 <luite> but for printing changed filenames it can work, if you're not reading that stuff
14:14:03 <DRiKE> ok
14:14:18 <chrisdone> luite: i'm happy 99% of fore is using Text
14:14:26 <DRiKE> I'm also struggling with the fact that I use a mix of System.IO.FilePath and Filesystem.Path.CurrentOS.FilePath
14:14:28 <chrisdone> luite: do you have an efficient function to convert from FastString to Text?
14:14:47 <chrisdone> luite: in GHC HEAD there's a FastString->ByteString, but i don't have HEAD
14:14:53 <DRiKE> and the System.IO.FilePath is essentialy a String if I'm correct
14:15:14 <luite> chrisdone: i had a cunning plan to make Text use a JS string as underlying storage with GHCJS :)
14:15:21 <chrisdone> whoever made Filesystem.Path.CurrentOS.FilePath needs to be taken out back and rmdir'd
14:15:39 <chrisdone> luite: psch, that's an old idea
14:16:04 <augur> anyone? :(
14:16:06 <luite> chrisdone: i can't hear you
14:16:31 <DRiKE> well FSNotify enforces me to use Filesystem.Path.CurrentOS.FilePath I'm afraid
14:16:58 <chrisdone> i mean the namespace Filesystem.Path.CurrentOS.FilePath is RIDICULOUS
14:17:57 <chrisdone> fastStringToText :: FastString -> Text
14:17:58 <chrisdone> fastStringToText = T.decodeUtf8 . L.pack . bytesFS
14:17:58 <chrisdone> luite: ^ got a better version of this?
14:18:06 <luite> yeah i use HEAD ;p
14:18:07 <Hodapp> huh, GHCJS looks interesting
14:18:12 <chrisdone> luite: d'aww
14:18:27 <chrisdone> luite: that is why nobody can build your stuff =p
14:18:37 <luite> in 3 weeks they will
14:18:39 <chrisdone> lol
14:18:44 <Hodapp> https://github.com/ghcjs/ghcjs-canvas zomg zomg *bouncebouncebounce*
14:18:45 <luite> well, 5 or so
14:18:46 <chrisdone> he said while ringing his hands
14:18:54 <luite> hopefully
14:18:55 <Hodapp> wringing*
14:19:08 <chrisdone> i thought wringing, but thought i'd made that spelling up
14:19:19 <chrisdone> english! it's just hipster german
14:19:28 <luite> and i hope i'll have the non-concurrent rts also updated to all the new nice features then too
14:19:40 <chrisdone> Hodapp: that's so, like, last year, man
14:19:40 <luite> for all the whiners complaining about complexity and code size ;p
14:20:05 <chrisdone> luite: both of them? =p
14:20:24 <luite> nah there are more whiners than users :p
14:20:28 <luite> perhaps 3 even
14:20:48 <luite> but i went to a hackathon last weekend, which is horrible for getting coding done :(
14:20:49 <erisco> augur, I'm not familiar at all with these "flexible contexts" ... seems I goofed because the type of zipWith is incorrect http://lpaste.net/92481
14:21:11 <luite> and now here in this hostel the only place where there's internet in the lobby, which has people, and stuff
14:21:19 <luite> also bad for productivity
14:22:20 <luite> oh and the blonde girl with the yoga pants is back, don't they realize i have serious hacking to do? this is distracking you guys
14:23:15 <Hodapp> bah?
14:23:31 <augur> erisco: yeah forget the viewable thing
14:23:41 <augur> just look at the one where listView is a method of Listish
14:23:45 <augur> thats sufficient for now
14:24:01 <augur> im still trying to figure out how to genericise it properly
14:25:35 <chrisdone> luite: are you in that hostel with the picture of a squirrel or something?
14:25:41 <chrisdone> near the blue monkey cafe?
14:26:02 <luite> i think it has a tree
14:26:13 <luite> it's hostelling international zurich
14:26:45 <chrisdone> ah, i didn't stay there last time
14:27:34 <luite> i'm leaving tomorrow, the weather seems good, so i'm probably going to the mountains
14:27:52 <chrisdone> i don't really get any hacking done at hackathons. if i want to hack i don't go to a place filled with interesting people, i stay at home with a computer and djent metal music
14:28:24 <luite> chrisdone: yeah same, it was quite fun though :)
14:28:27 <chrisdone> cool
14:28:42 <chrisdone> yeah. i like talking to people at hackathons =)
14:29:16 <chrisdone> "so *you're* that guy!"
14:29:21 <chrisdone> i say that all day
14:29:28 <chrisdone> "i've used your library!"
14:29:38 <erisco> augur, well one method is to convert the arguments into an ADT
14:29:41 <luite> well no one said that to me ;)
14:29:52 <augur> erisco: ?
14:29:57 <zomg> chrisdone: go to a hackathon in Finland and you won't meet anyone famous because nobody in Finland has made any of the cool libraries for any language
14:30:00 <zomg> lol
14:30:04 <erisco> augur, http://lpaste.net/92482
14:30:29 <chrisdone> zomg: lol. they just make fine libraries. fineland
14:30:55 <erisco> augur, for  foo :: (Listish f) => f a  you can  foo xss = ... listishT xss :: [a]
14:30:57 <augur> erisco: i dont know what you're doing there. you seem to have missed the point of these view things
14:31:06 <tolt> @type map
14:31:07 <lambdabot> (a -> b) -> [a] -> [b]
14:31:07 <erisco> augur, I wasn't using the view in that case
14:31:12 <zomg> I went to a hackathon once. The only "oh you're that guy" I got was from a guy I had been talking with on twitter
14:31:14 <erisco> augur, I know the view is different
14:31:20 <augur> erisco: http://lpaste.net/92474
14:31:23 <tolt> lambdabot is awesome. That's really cool.
14:31:24 <augur> just look at that one
14:31:25 <zomg> and he was like, "oh you're that guy with his head like this *tilts his head* on twitter"
14:31:28 <chrisdone> luite: on saturday i walked up a local mountain here. yay. love climbing up, hate walking down. hard to my old man knees
14:31:29 <luite> chrisdone: do you know tricks for affordable food/stay in switzerland/zurich? :p
14:31:34 <zomg> 'cause my profile photo on twitter is angled slightly
14:31:35 <zomg> :D
14:31:42 <ReinH> edwardk: is there an easy way to make Grid Indexable or an instance of *WithIndex? https://gist.github.com/reinh/01791658946fb7c253d1
14:31:42 <erisco> augur, but with the objective of pattern matching, listishT is one way
14:31:50 <augur> erisco: just look at http://lpaste.net/92474
14:31:51 <augur> :|
14:31:57 <edwardk> just write the instance
14:32:00 <luite> chrisdone: you need to bring poles for that
14:32:05 <ReinH> edwardk: hah, well yes...
14:32:06 <chrisdone> zomg: lol, that's how they think of you. the guy with the tilted head =p
14:32:13 <zomg> Yep :P
14:32:14 <erisco> augur, whaa
14:32:18 <chrisdone> luite: for walking down hill? hmm, could help
14:32:22 <ReinH> edwardk: I am trying! :D
14:32:23 <erisco> augur, I don't even know what that pattern match means
14:32:27 <augur> erisco: :)
14:32:32 <erisco> everything is on its head right now
14:32:38 <luite> chrisdone: yeah for climbing they're not of that much use, at least for normal hiking trails
14:32:48 <ReinH> edwardk: I am trying to grok http://hackage.haskell.org/packages/archive/lens/latest/doc/html/src/Control-Lens-Indexed.html#FunctorWithIndex
14:32:51 <chrisdone> luite: or do you mean i should hire polish people to guide me down the right paths, like the guides in everest?
14:33:00 <luite> but for the descent it takes a lot of the shocks, especially if you're trekking with a heavy backpack
14:33:03 <augur> erisco: the idea is that you want to be able to write pattern-matching programs but using views
14:33:10 <donri> i'm the guy people ^W luite ask "why aren't you here!?" on irc when there's a hackathon
14:33:16 <augur> erisco: so haskell has an extension that lets you do this
14:33:44 <chrisdone> luite: right, the shocks walking down hill kills my knees
14:33:46 <luite> chrisdone: i personally don't use them when walking with light load though, but if your knees hurt then they definitely help.
14:34:04 <edwardk> instance TraversableWithIndex (Int,Int) Grid where itraverse f (Grid w h xs) = Grid w h <$> itraverse (\i -> itraverse (\j -> f (i,j))) xs
14:34:07 <augur> erisco: so if v is youre view function, you write (v -> pat) where you want to instinctively do pattern matching but cant because the types wont let you
14:34:09 <edwardk> now lets golf. =)
14:34:32 <augur> erisco: and instead, haskell applies v to the "actual" argument, and pattern matches on the result with pat
14:34:54 <ReinH> edwardk: but I want instance TraversableWithIndex (V2 Int) Grid :D
14:35:17 <edwardk> ReinH: ok, swap to V2 i j then =P
14:35:20 <ReinH> So it matches up with (!!!) :: Grid a -> V2 Int -> a
14:35:21 <erisco> augur, nifty
14:35:22 <ReinH> edwardk: ok :D
14:35:35 <bawr> Do I want to be reading something alongside learn you a haskell?
14:35:37 <erisco> augur, so you are puzzling on how to get listView out of Listish? I hadn't seen this pastebin yet
14:35:49 <luite> chrisdone: i'm still a bit offended that nominolo (i think, i apologize if it was someone else) suggested that as a dutch guy i should start with a practice hill nearby zurich instead of a real mountain ;)
14:35:57 <ReinH> edwardk: sorry I'm slow
14:36:06 <augur> erisco: yeah, im trying to make the view generic
14:36:32 <chrisdone> luite: i think years of being a sedentary programmer made my body think it was done, its task had been fulfilled, down-hill from here. so all this activity in the past year is like when you turn on a disused factory in the movies when all the lights turn on and the machinery starts working but it's dusty and there're rats in the stock cupboard
14:36:56 <erisco> you certainly are an advanced practitioner of Haskell wizardry
14:37:11 <chrisdone> luite: ha =)
14:37:18 <augur> erisco: no, im an Agdaist :)
14:37:38 <augur> actually im a spiritual Epigram2ist
14:38:22 * chrisdone goes back to watching 'Airplane!'
14:38:47 <edwardk> ReinH: well, the key thing is that you get there in the end ;)
14:39:09 <augur> erisco: brb heading to drink coffee
14:39:12 <ryant5000> is there a newer alternative to HList?
14:39:22 <erisco> I'll just try and catch up
14:39:28 <luite> chrisdone: yeah i also was in rather bad shape but started cycling a lot more this year
14:39:32 <edwardk> ryant5000: most folks just reimplement it locally as needed
14:39:52 <edwardk> ryant5000: e.g. you can use datakinds now to make it pretty sexy
14:39:57 <ryant5000> edwardk: lol, that's exactly what i'm contemplating
14:40:26 <luite> chrisdone: surely you should go back to watching 'Airplane!'
14:40:56 <augur> erisco: what we're getting at here tho is that these types are all definable as initial f-algebras, and initial f-algebras are isomorphisms
14:41:09 <augur> erisco: so we're trying to use the reverse direction of the iso
14:41:34 <chrisdone> luite: =D
14:41:34 <augur> but im stuck on the parameteric versions because type classes arent as powerful as i'd like them to be
14:41:38 <kryft> Woohoo, I successfully fixed my first stack overflow (and it wasn't just a foldl either) :P
14:41:59 <augur> anyway brb
14:42:15 <ReinH> edwardk: folding a Grid will lose the Grid structure, right?
14:42:24 <ReinH> edwardk: i.e., is this correct? instance FoldableWithIndex Coord Grid where ifoldMap f (Grid w h xs) = ifoldMap (\i -> ifoldMap (\j -> f (V2 i j))) xs
14:42:28 <ReinH> it typechecks
14:42:40 <ReinH> (type Coord = V2 Int)
14:42:46 <edwardk> you can let ifoldMap rest on the definition for itraverse
14:42:51 <edwardk> if you don't want to implement it
14:42:55 <edwardk> but yes, thats right
14:43:25 <ReinH> edwardk: er, but FoldableWithIndex is a superclass?
14:43:45 <ReinH> when I declare the TraversableWithIndex instance I get a No instance for (FoldableWithIndex Coord Grid)
14:44:04 <edwardk> ys
14:44:13 <edwardk> but look at the default definition of ifolded
14:44:18 <edwardk>  ifoldMap = ifoldMapOf itraversed
14:44:32 <ReinH> edwardk: right, but then why am I getting the error?
14:44:34 <edwardk> so now you can just write the instance FoldableWithIndex Coord Grid  -- no body
14:44:37 <edwardk> just that
14:44:38 <kryft> http://lpaste.net/92483 <- My original code was the commented out function above; could I have made it strict like the version below without losing the brevity?
14:44:41 <ReinH> ohhhhh duh
14:44:44 <edwardk> same with FunctorWithIndex Coord Grid
14:45:03 <chrisdone> luite: 'you ever been in a cockpit before?' 'nope, i've never been on a plane before!' 'you ever seen a grown man naked?'
14:45:06 <ReinH> edwardk: oh duh
14:45:08 <ReinH> awesome sauce
14:45:46 <ReinH> edwardk: ok, back to the golfing :D
14:46:11 <ReinH> I should be able to itraverse<.>itraverse or something?
14:46:33 <mcstar> chrisdone: ...and dont call me Sherley!
14:48:34 <Hodapp> hrmph. Official atom-msp430 examples are generating non-compilable C code
14:49:50 <ReinH> edwardk: Do I need to do something applicative with itraversed<.>itraversed?
14:50:28 <edwardk> not sure i parse
14:50:38 <ReinH> edwardk: sorry
14:50:50 <haasn> ReinH: what are you golfing? :)
14:51:16 <edwardk> haasn: he's got a grid that is 2d points as a datatype, and wants all the lens classes =)
14:51:27 <edwardk> so he's suffering some pain just getting through writing them all
14:51:34 <ReinH> edwardk: xs^@..itraversed<.>itraversed will give me [((i,j), x)]
14:51:39 <haasn> makeEverything
14:51:55 <ReinH> edwardk: so I think this will help me but I'm not sure how
14:51:56 <haasn> ReinH: yes the indices get tupled together
14:52:00 <edwardk> ReinH: what are you trying to write?
14:52:13 <ReinH> edwardk: I'm trying to golf the TraversableWithIndex instance declaration
14:52:20 <edwardk> see the version i wrote above
14:52:32 <edwardk> you can write it with itraversed<.>itraversed
14:52:36 <edwardk> but you need to be tricky
14:52:58 <jfischoff> are there any unification algo's that utilize a free monad for much of the work?
14:53:08 <ReinH> edwardk: Right, I currently have itraverse f (Grid w h xs) = Grid w h <$> itraverse (\i -> itraverse (\j -> f (V2 i j))) xs
14:53:14 <edwardk> itraverse f (Grid w h xs) = Grid w h <$> itraverseOf (itraversed<.>itraversed>) (uncurry f) xs
14:53:24 <ReinH> heh
14:53:34 <ReinH> so itraversed<.>itraversed is a red herring?
14:53:39 <edwardk> if you use makePrisms on Grid you can go futher
14:54:00 <edwardk> itraverse f = itraverseOf (_Grid.itraversed<.>itraversed>) (uncurry f)
14:54:04 <haasn> I don't understand where the indices are coming from
14:54:09 <haasn> oh, Vector
14:54:12 <edwardk> yeah
14:54:25 <ReinH> Vector (Vector a)
14:54:32 <haasn> why is the uncurry needed here?
14:54:33 <jfischoff> > :t  (<.>)
14:54:35 <lambdabot>   <hint>:1:1: parse error on input `:'
14:54:42 <edwardk> of course then you need to use reindex or whatever the combinator is to swap out from (,) tupling to V2 indexing.
14:54:45 <ReinH> edwardk: you're missing a V2 constructor somewhere?
14:54:46 <jfischoff> @type (<.>)
14:54:47 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
14:54:53 <ReinH> right
14:54:55 <edwardk> so the current one you have is nicer than the complex one here
14:55:06 <ReinH> edwardk: well you were talking about golfing it...
14:55:13 <haasn> oh, because of V2 indexing
14:55:17 <edwardk> then you added the V2 wrinkle =)
14:55:22 <ReinH> edwardk: my bad :D
14:55:49 <haasn> also _Grid? Don't you mean ‘cells’?
14:55:56 <edwardk> if itraverse and itraversed were defined circularly then you could just use itraversed = _Grid.itraversed<.>itraversed   with the (,) index.
14:56:11 <edwardk> but alas they aren't
14:58:20 <Eduard_Munteanu> How do you initialize and track some state in the Q monad?
14:58:38 <Eduard_Munteanu> Is there a "main"? :)
14:59:29 <edwardk> Eduard_Munteanu: you'll hate me, but my main strategy is to make another module, put an IORef at the top level of it, and initialize it with unsafePerformIO wrapping it in NOINLINE
14:59:49 <Eduard_Munteanu> Aww. :)
14:59:50 <edwardk> Eduard_Munteanu: then i can reference that IORef across multiple template-haskell actions
15:00:00 <chrisdone> it's a classic
15:00:08 <edwardk> i did that when writing some localization machinery
15:02:13 <chrisdone> did a similar thing for the define-command patern often done in lisp
15:02:20 <Eduard_Munteanu> I think I'll ask the user to make one big record.
15:06:18 <ReinH> edwardk: and now for my next trick, making grid^.ix V2 1 1 work :D
15:06:46 <ReinH> edwardk: I think I want to use At since my grid has bounds?
15:07:01 <edwardk> you need ix because it has bounds
15:07:22 <edwardk> at you can't have because yu can't put 'one point' outside the bounds
15:07:28 <edwardk> :t Control.Lens.ix
15:07:29 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
15:07:40 <simon> question (someone else asked and I didn't know): is Control.Arrow.returnA = Control.Category.id?
15:07:40 <edwardk> so type instance Index Grid = Coord
15:07:40 <ReinH> ah
15:07:46 <edwardk> er
15:07:52 <edwardk> type instance Index (Grid a) = Coord
15:07:55 <ReinH> right
15:08:03 <edwardk> type instance IxValue (Grid a) = a
15:08:08 <edwardk> thn you just need the ix function itself
15:08:16 <edwardk> fortunately. we haveone for vector
15:08:23 <ReinH> I saw that
15:08:26 <ReinH> should be able to compose
15:09:25 <edwardk> instance Applicative f => Ixed f (Grid a) where ix (i,j) = _Grid._3.ix i.ix j
15:09:39 <edwardk> we can of course make that more explicit
15:10:00 <edwardk> er
15:10:08 <edwardk> instance Applicative f => Ixed f (Grid a) where ix (i,j) = _Grid._3.ix i<.>ix j
15:10:34 <edwardk> since for some reason i was insane enough to require ix to be an indexed lens
15:11:08 <ReinH> heh
15:11:55 <ReinH> edwardk: you keep forgetting that type Coord = V2 Int :p Now I have to do all the hard work :p
15:11:59 <ReinH> jokes
15:12:12 <erisco> augur, it is either having listView or having listCase, right? I'm not sure what is trying to be abstracted now
15:12:31 <edwardk> i'm wondering if in 3.10/4 if we won't want to make it so that many of the stock lenses are unindexed instead
15:12:38 <ReinH> edwardk: and also that Grid contains _x and _y bounds
15:12:53 <erisco> ugh I can feel the food coma
15:12:57 <edwardk> i was using the fact that your vectors matched them there
15:13:01 <augur> erisco: i want to abstract listView out of the class tho. ill figure it out, dont you worry
15:13:06 <edwardk> _Grid._3 got you down to the vectors themselves
15:13:20 <edwardk> > Data.Vector.fromList [1,2,3]^? ix 4
15:13:21 <lambdabot>   Not in scope: `Data.Vector.fromList'
15:13:34 <edwardk> that does the right thing and returns Nothing
15:13:36 <erisco> augur, okay but my question remains... without listView will there not be listCase anyways?
15:14:03 <augur> erisco: no. the point is that if you abstract listView, you still have it, but its a superclass sort of thing
15:14:05 <ReinH> edwardk: how does the Prism for (Grid width height xs) work?
15:14:22 <augur> so the same "view" method will apply to any abstract type not just lists
15:14:25 <augur> youll see
15:14:33 <ReinH> I get how it would work for Grid a = Grid { _cells :: Vector (Vector a) }
15:14:43 <hilo> hi, I have a question about Either. If I have a function that returns Either a b, and I use case (func) of Left Right to handle potential errors, does that mean I necessarily have to wait for the entire function to finish (i.e. can't make it lazy) before I can work with its output?
15:14:45 <ReinH> but not with the product type
15:14:48 <edwardk> _Grid :: Prism (Grid a) (Grid b) (Int,Int,Vector (Vector a)) (Int, Int, Vector (Vector b))
15:15:00 <edwardk> it makes a tuple
15:15:07 <edwardk> hnce why i can use _3 to go deeper
15:15:40 <ReinH> oh
15:17:22 <ReinH> edwardk: ok, awesome, ix (i,j) = _Grid._3.ix i<.>ix j works for (Int, Int)
15:17:38 <edwardk> you can write it by hand a bit longer
15:17:38 <ReinH> unfortuntaly I don't grok what is going on enough to make ix (V2 i j) work
15:17:43 <Cale> hilo: Pattern matches are in general what forces evaluation to occur.
15:17:53 <luite> chrisdone: what's the correct thing to throw exceptions from javascript as, synchronous or asynchronous exceptions?
15:18:01 <Zenol> Hum, someone giv me a link with a lots of Either -> Maybe, Maybe -> Either, etc. But I can't recall the name of the package :(
15:18:07 <Cale> hilo: At some level, you can imagine that *all* evaluation occurs because something is trying to pattern match.
15:18:08 <edwardk> ix (i,j) (Grid w h xs) = Grid w h <$> ix i (ix j (indexed f i j)) xs
15:18:12 <edwardk> er
15:18:20 <edwardk> ix (i,j) (Grid w h xs) = Grid w h <$> ix i (ix j (indexed f (V2 i j))) xs
15:18:28 <Cale> hilo: and in general, just enough evaluation will occur to determine which pattern matches
15:18:33 <edwardk> bah
15:18:39 <Zenol> oh, get it. Control.Error.Safe.
15:18:46 <edwardk> ix ij@(V2 i j) (Grid w h xs) = Grid w h <$> ix i (ix j (indexed f ij)) xs
15:18:49 <ReinH> edwardk: er... :)
15:18:58 <ReinH> ah
15:19:05 <edwardk> ix ij@(V2 i j) f (Grid w h xs) = Grid w h <$> ix i (ix j (indexed f ij)) xs
15:19:08 <edwardk> forgot the f
15:19:11 <Cale> hilo: i.e. it will evaluate until it can see that the result is in the form Left e or Right x, for some perhaps unevaluated expression e or x.
15:19:30 <ReinH> nice
15:19:35 <edwardk> it is crap like this that is making me reconsider requiring ix to be indexed
15:19:38 <ReinH> edwardk: where does the Applicative f come from?
15:19:41 <augur> type class masters halp http://lpaste.net/92486
15:19:48 <augur> a is not in scope in the last class
15:19:58 <edwardk> ix can fail, so ix i and ix j use the Applicative
15:20:22 <ReinH> ah
15:22:03 <geekosaur> augur, I think a has to be in the instance head, not just the context? In fact possibly ghc should reject that for f not being reachable
15:22:08 <geekosaur> er, for a not being reachable
15:22:26 <augur> geekosaur: thats presumably the case
15:26:37 <hilo> Cale: thanks, that makes sense. I was wondering how to keep things lazy even when dealing with libraries like parsec. the parse function returns Either by default...is there some way around this? Or should I just be splitting up the input?
15:32:00 <Cale> hilo: You might be able to get away using smaller parsers (and many applications of runParser), along with something which breaks up your input into chunks somehow.
15:32:07 <simon> can anyone answer this: is Control.Arrow.returnA = Control.Category.id?
15:32:27 <Cale> :t returnA
15:32:28 <lambdabot> Arrow a => a b b
15:32:32 <Cale> yes, it should be
15:32:54 <Cale> (if it's not, you can consider it a bug in the instances)
15:33:38 <zzo38> What was the Typeable class intended to be used for? Is its intentions similar to the things I have used it for?
15:33:39 <napping> Zenol: errors
15:34:01 <ReinH> Is there a combinator (maybe from Arrow?) such that f (g,h) a = (g a, h a)?
15:34:50 <simon> Cale, can you tell me briefly how they relate terminologically? (I don't suppose "returnA" is the identity arrow, and that the identity arrow *is* the identity category, but rather that it's some kind of case of category?)
15:35:05 <hilo> Cale: ok, I'll try that, thanks.
15:35:11 <Cale> zzo38: Typeable is meant to be used for dynamic typing and similar via cast. I don't know what you've used it for, but it's best not to write your own instances of Typeable, and let the compiler derive them (soon, this will be mandatory)
15:35:50 <Cale> simon: Every instance of Arrow is morally an instance of Category, with id = returnA and (.) = (<<<)
15:36:50 <Cale> simon: Arrow existed before Category, which is the only reason for the lack of superclass constraint.
15:37:08 <Cale> oh, there *is* a superclass constraint now
15:37:11 <Cale> pardon me :)
15:37:13 <simon> yes
15:37:16 <simon> okay, thanks. :)
15:37:30 <Cale> returnA is still defined as arr id though
15:37:36 <Cale> oddly enough
15:37:44 <simon> I wonder how many times a day you have to say "I should read more about category theory" before you should actually pick up a book.
15:37:46 <Cale> That could pose some difficulties
15:37:51 <zzo38> Cale: I don't write my own instances of Typeable, but I have subclassed it. I don't find Dynamic very useful, though. instance Eq TypeRep is useful, however, in a few different ways.
15:38:10 <Cale> If you *do* want to pick up a book, I would recommend "Category Theory" by Steve Awodey.
15:38:41 <Cale> It has the nice property of being almost entirely self-contained, and is quite light on prerequisites as far as such books go.
15:38:44 <zzo38> Dynamic doesn't seem a very useful use of Typeable to me, though.
15:39:12 <Cale> zzo38: Well, look at how Control.Exception uses Typeable for a better example
15:39:24 <Cale> zzo38: It's sort of Dynamic-like without being literally Dynamic.
15:39:28 <joelteon> if I have a Chan that a thread is writing to, and that thread is the only provider, and it dies, the Chan should be garbage collected, right?
15:39:28 <simon> Cale, I used to have one at the uni library called "Category Theory for Computer Scientists", but I'll look the other one up.
15:39:44 <Cale> simon: I can send you a copy, one sec
15:40:03 <Cale> (just reinstalled OS, don't have webserver running yet)
15:40:04 <zzo38> Cale: Maybe it is better example; I will look.
15:40:04 <simon> Cale, oh! great.
15:40:21 <joelteon> also, if I have a thread whose only job is to read from the chan forever and all the chan's providers are killed, will the thread just block forever or will it die too?
15:41:03 <zzo38> Cale: O, that uses it similar to what I have done.
15:41:27 <Cale> simon: sent you a link in PM
15:41:41 <napping> joelteon: GHC generally tries to notice that and send an exception to the thread
15:41:55 <simon> Cale, thanks :)
15:41:56 <ReinH> crap, I actually need f g h a = (g <$> a, h <$> a) so liftA2 (,) won't work. :(
15:41:56 <joelteon> Ok, is it worth it to play it safe and kill the thread myself?
15:42:00 <joelteon> or should I not bother
15:42:39 <simon> @pl \g h a -> (g <$> a, h <$> a)
15:42:42 <lambdabot> flip ((.) . ap . ((,) .) . (<$>)) (<$>)
15:42:42 <lambdabot> optimization suspended, use @pl-resume to continue.
15:42:46 <simon> great.
15:43:51 <simon> @pl \(g,h) a -> (g a, h a)
15:43:51 <lambdabot> uncurry (liftM2 (,))
15:46:44 <NemesisD> isn't there a function somewhere for doing a monadic operation until you get a Nothing and then return the concatenated results
15:47:16 <haasn> NemesisD: there are lots of functions like this in Control.Monad.Loops
15:47:26 <haasn> like unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
15:47:40 <haasn> or unfoldM :: Monad m => m (Maybe a) -> m [a]
15:48:48 <ocharles> <3 unfoldM_
15:48:54 <NemesisD> ahh yes i haven't used loops in a while
15:49:05 <ocharles> haasn: I used that yesterday with SDL and lens to make a slick 'parseEvents' routine for use with netwire 5 :)
15:49:18 <haasn> yes I stumbled across the module the other day where it provided something really useful
15:49:40 <funfunctor> g'day
15:49:40 <haasn> oh right, iterateUntilM
15:49:44 <ocharles> http://lpaste.net/92490
15:49:55 <haasn> http://bpaste.net/show/128639/
15:50:18 <NemesisD> oh man this module is awesome
15:51:03 <ocharles> haasn: heh, for best of 3 semantics?
15:51:08 <haasn> yeah
15:51:13 <ocharles> neat
15:51:19 <haasn> iterateUntilM ((>=2) . uncurry max) -- :)
15:51:31 <ocharles> yea
15:53:47 <ocharles> I should read that unfold paper, now that i'm starting to see them crop up more
15:54:57 <NemesisD> hmm why doesn't STM provide a tryReadTChan
15:55:08 <haasn> because you have `orElse`
15:56:00 <NemesisD> hmm so like Just <$> readTChan `orElse` return Nothing
15:56:12 <fryguybob> NemesisD: Yes
15:56:17 <NemesisD> sweet
15:56:27 <NemesisD> into the utils module it goes
15:56:48 <chrisdone> it stil could provide that, it;s useful
15:56:56 <haasn> right but keep in mind instead of using Maybe in your result you could still use `orElse`
15:56:58 <haasn> perhaps higher up
15:57:35 <NemesisD> eh, its for testing, i'm going to run a monadic operation and then load the contents of the TChan into a list
16:08:56 <augur> anyone have refs they can give andrej bauer for data=codata categories? http://www.reddit.com/r/haskell/comments/1le9xn/the_elements_of_an_inductive_type/cc08jrn?context=3
16:09:40 <_oio_> could someone explain unfoldTree from data.tree
16:10:24 <shachaf> Looks like a typical unfold function.
16:11:02 <augur> :t unfoldTree
16:11:03 <lambdabot> (b -> (a, [b])) -> b -> Tree a
16:11:19 <augur> @def unfoldTree
16:11:19 <lambdabot>  Parse failed: TemplateHaskell is not enabled
16:11:29 <augur> is it !def?
16:11:34 <augur> @help
16:11:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:11:41 <augur> @list
16:11:41 <lambdabot> What module?  Try @listmodules for some ideas.
16:11:44 <augur> :|
16:11:47 <augur> @help list
16:11:47 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:12:00 <augur> :|
16:12:18 <shachaf> It doesn't exist.
16:12:18 <augur> im sure i can reconstruct it, but
16:12:30 <augur> you just wanna be sure!
16:12:55 <geekosaur> if you're looking for @src, pretty sure unfoldTree isn't in its tiny db
16:13:04 <augur> oh thats it
16:13:06 <augur> src
16:13:35 <augur> ok anyway, _oio_ suppose you want to build a Tree a from some seed value s :: b
16:13:55 <augur> _oio_: well what's a tree?  data Tree a = Node a [Tree a]
16:14:03 <augur> so its a node, and some list of children
16:14:35 <augur> so that means to build a tree from a seed, you have to have a way of taking a seed and turning it into a value for the node (an a) together with some seeds for the child nodes
16:15:12 <augur> that is to say, you need a function that computes the "next local subtree"
16:15:19 <augur> so thats what the b -> (a,[b]) argument is
16:15:46 <augur> so lets work with an example, just because
16:15:56 <erisco> > tail []
16:16:08 <augur> suppose we want to build a binary tree of depth n
16:16:20 <lambdabot>   *Exception: Prelude.tail: empty list
16:16:50 <augur> what do we have to do at each step, from the top down? given some current depth, we have to decide whether or not we just stop here, or continue producing daughter nodes
16:16:55 <shachaf> Can you take this to -overflow?
16:17:06 <augur> shachaf: suuuuure :P
16:17:12 <augur> as if there was anything going on here
16:17:19 <augur> _oio_: to #haskell-overflow!
16:17:20 <shachaf> If it was before, it certainly isn't now.
16:17:35 <peddie> has anyone else had a problem with emacs' haskell-mode not being able to find other files from the same cabal project?  I can load one file from the project OK, but I can't load its neighbor which imports it
16:17:51 <augur> _oio_ ^
16:17:59 <augur> ^^
16:18:04 <_oio_> k
16:18:47 <augur> _oio_: come to #haskell-overflow
16:19:56 <_oio_> already there
16:20:11 <_oio_> the first one was worng
16:24:12 <AfC> I need to put  {-# LANGUAGE OverloadedStrings #-} into a Haddock documentation comment. What do I need to escape?
16:24:27 <AfC> I'm just getting a blank at the moment; it's obviously getting interpreted somewhere along the way
16:28:55 <erisco> :info (++)
16:30:51 <augur> erisco: heylo
16:31:02 <erisco> augur, greetings
16:31:22 <erisco> just rewriting my Cartesian product implementation with listView
16:31:33 <augur> erisco: i think the closest thing we can get is a generic n-param version of View, unfortunately
16:31:51 <augur> which might be reasonable, but it's not perfect, unfortunately.
16:32:01 <erisco> I'm not exactly sure what you are trying to abstract
16:32:02 <augur> i would prefer to have a truly generic View
16:32:11 <augur> erisco: the view method
16:32:13 <augur> ill show you
16:35:35 <edwardk> NemesisD: optional . readTChan
16:36:47 <edwardk> augur: the issue is we just never found a set of constraints on it that didn't suck. so on wasn't picked.
16:37:01 <edwardk> the two parameter version doesn't infer well, the other two miss a number of scenarios
16:37:09 <augur> edwardk: fundeps?
16:37:30 <edwardk> the problem is you sometimes want the fundep running one way and sometimes the other
16:38:11 <augur> true
16:38:49 <edwardk> it is all well and good to say you want it, but there isn't a way to really get it ;)
16:41:16 <taylorgb_> edwardk: Have you been working on some new exciting mind-bending stuff?
16:41:36 <edwardk> always
16:42:58 <edwardk> taylorgb_: cache oblivious lookahead arrays, succinct data structures, and some random posts about matrix multiplication
16:43:59 <taylorgb_> Is there some secret to knowing which packag contains the most recent incarnation of lens and associated zippers?
16:44:07 <taylorgb_> er package
16:44:11 <edwardk> lens contains the latest notion of lens =)
16:44:20 <edwardk> zippers will soon contain the latest notion of zippers
16:44:29 <edwardk> with the 3.10 release we're splitting it out
16:44:53 <taylorgb_> Ah. Cool.
16:57:05 <erisco> spotted the ambiguous type :D
16:57:19 <erisco> augur, this is the kind of monstrosity I've tested this design against: http://lpaste.net/92491
16:58:32 <erisco> intermediate data structures are an interesting thing
16:58:43 <erisco> guess you just pick a type out of the blue
16:58:53 <augur> erisco: http://lpaste.net/92492
17:03:12 <byorgey> what's the state of the art for running a bunch of actions concurrently using a thread pool (e.g. so no more than N are running at once)?
17:03:17 <byorgey> is there a package for that?
17:03:38 <shachaf> byorgey: spawn has http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html#v:pool for that.
17:03:48 <byorgey> awesome, thanks
17:04:13 <erisco> augur, ah :D perfect
17:04:18 <shachaf> byorgey: Oh, it's using a deprecated API which will be removed in GHC 7.8.
17:04:24 <erisco> I like the addition of the BTree
17:04:31 <byorgey> shachaf: oh, boo =(
17:04:36 <shachaf>     Deprecated: "Control.Concurrent.QSem will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead."
17:04:48 <augur> erisco: but your constant time length will again have to be added externally
17:04:59 <erisco> augur, yes of course. I have Countish
17:05:01 <augur> but you could just make a lengthy class for that
17:05:17 <shachaf> byorgey: So maybe look in SafeSemaphore? The implementation of pool is just two lines anyway.
17:05:21 <erisco> named after the ADT Counted
17:05:28 <augur> erisco: i think convention is to make verb-based names ables
17:05:32 <augur> eg Countable
17:05:42 <erisco> that is an adjective
17:05:47 <byorgey> shachaf: will do
17:05:49 <augur> yes, but Count is a verb
17:06:15 <augur> thats why you use able, to make it an adjective, and you get a nice english-ish constraint: Countable l ~ l is countable
17:06:19 <erisco> but then we have Listable instead of Listish?
17:07:03 <augur> eh. no. i dont think there are conventions for that
17:07:10 <augur> anyone have suggestions there?
17:07:23 <augur> for a typeclass that exposes a list-like interface?
17:07:32 <erisco> but why are you asserting Countable over Countish then?
17:07:43 <augur> erisco: because we "can count" the countables
17:07:46 <augur> they're not "like a count"
17:07:54 <erisco> Countish is a type class
17:08:02 <augur> i know
17:08:03 <augur> erisco look
17:08:08 <erisco> :s
17:08:17 <augur> the -ish's were because the things are "sorta like" an X, so they're X-ish
17:08:25 <erisco> yeah
17:08:26 <augur> in that we have an X-like constructor interface
17:08:28 <augur> pseudoconstructors
17:08:29 <erisco> I made an ADT called Counted
17:08:33 <erisco> and Countish is like Counted
17:08:34 <augur> well dont do that
17:08:36 <augur> thats pointless
17:08:37 <erisco> ;p;
17:08:50 <erisco> what is pointless?
17:08:57 <augur> having an ADT called Counted
17:09:00 <erisco> why
17:09:05 <augur> why isnt it
17:09:07 <augur> what does it do
17:09:17 <augur> give me the definition
17:09:25 <erisco> data Counted a b = NonZero { nzcount :: a, counted :: b, less :: Counted a b } | Zero
17:09:46 <augur> i dont know what thats supposed to even be for
17:09:53 <augur> anyway
17:09:58 <erisco> to keep track of length on a Listish
17:10:01 <augur> the countable type class would just be the interface for counting
17:10:18 <erisco> it has the single function "length :: f b a -> b"
17:10:22 <augur> class Countable a where count :: a -> Int
17:10:37 <augur> instance Countable [a] where count = length
17:10:50 <augur> instance Countable (LenList a) where count (LenList n _) = n
17:10:57 <erisco> a Countish has to be a Listish else we can't state the laws
17:11:08 <augur> nonsense
17:11:26 <augur> you dont need laws
17:11:28 <augur> why do you need laws
17:11:44 <erisco> so that I know what properties are acceptable
17:12:02 <augur> erisco: yor laws ARE properties
17:12:07 <erisco> yes
17:12:08 <augur> so again, why do you need laws
17:12:23 <erisco> I'll do bad things otherwise
17:12:33 <erisco> what kind of answer do you want?
17:12:40 <augur> erisco: what do you mean youll do bad things
17:12:41 <augur> what bad things
17:12:45 <augur> rape and pillage? :|
17:13:01 <erisco> oh nothing that severe. Maybe just some petty theft
17:13:02 <augur> what are you going to just go off and do if you dont have laws, and what are these laws supposed to even be
17:13:28 <erisco> augur, you stated them just yesterday
17:13:35 <augur> erisco: i did no such thing!
17:13:56 <erisco> and I do not understand the strong opposition to defining the meaning of the interface
17:14:39 <erisco> length nil == 0 ; length (cons x xs) == 1 + length xs
17:14:44 <augur> erisco: the interface IS the meaning. your count type class is nonsense
17:15:04 <erisco> no, it is not
17:15:13 <augur> erisco: oh, i see. well, you can make countable a subclass of listish if you want to require listishs
17:15:26 <augur> class Listish l => Countable (l a) where count :: l a -> Int
17:15:35 <erisco> class (Integral b, Listish (f b)) => Countish f b where
17:16:39 <augur> you probably want int, actually
17:17:00 <augur> :t length
17:17:00 <lambdabot> [a] -> Int
17:17:01 <erisco> probably, and I will specify so if I do :)
17:17:10 <erisco> :t genericLength
17:17:11 <lambdabot> Num i => [b] -> i
17:17:18 <augur> you could use that too!
17:17:51 <augur> anyway, remember, class hierarchies are how to define the interrelatedness of what things can do
17:18:07 <erisco> I did some OOP once
17:18:17 <augur> no no, dont think of it like OOP
17:19:32 <augur> also, the laws are informal, remember
17:19:45 <erisco> meaning?
17:19:45 <shachaf> I recommend #-overflow again.
17:19:56 <erisco> shachaf, this is our Haskell code though :s
17:20:07 <shachaf> Yes. #haskell-overflow is for Haskell.
17:20:10 <augur> ignore shachaf, he just doesnt like it when i talk
17:21:48 <augur> erisco: the laws, being informal, can be pseudo-enforced however you like. so for instance there's no reason you cant say that you expect countable listish things to obey more laws than just countable and listish things's laws
17:22:21 <erisco> yes there is no compiler enforcement, I understand
17:22:29 <erisco> I'm not converting to agda quite yet :P
17:22:34 <augur> thats tho really, since you can always define count for listish things, there's no reason not to make countable a superclass and define a default definition or something. i think that's possible.
17:23:32 <erisco> eh, I'm not too sure about that
17:23:32 <augur> sorry, make countable a subclass? i dont remember how these words line up
17:23:38 <augur> anyway
17:23:39 <augur> it'd be
17:23:46 <augur> instance Listish f => Countable (f a) where ...
17:24:02 <augur> im sure there are probably some type inference problems here tho
17:24:31 <augur> youll get overlapping instances
17:24:42 <augur> i dont know if haskell can resolve that by instantiation specificity
17:25:45 <Gracenotes> PSA: enter is not punctuation :)
17:27:07 <augur> Gracenotes: i hit enter once a thought is complete. unfortunately i have rapid turnover of thoughts!
17:27:38 <augur> ill try to reign it in tho
17:28:26 <augur> reign? thats not right, is it? whatever
17:28:29 <shachaf> Or just take it to #-overflow, which is meant for long discussions so that you don't fill the channel with this.
17:29:20 <augur> if only you were so vigilant with other people, shachaf, i might be inclined to think you meant that
17:29:49 <Gracenotes> #-overflow is more important if there are other discussions that are being drowned out
17:29:59 <FreeFull> I haven't found a list long enough to overflow length yet
17:30:13 <FreeFull> I mean, Int
17:30:28 <Gracenotes> This list is pretty long: [1..]
17:30:43 <augur> Gracenotes: will it overflow int, or just never stop computing!
17:31:07 <Gracenotes> > maxBound :: Int
17:31:08 <lambdabot>   2147483647
17:31:31 <augur> @src length
17:31:31 <lambdabot> Source not found. Do you think like you type?
17:31:33 <FreeFull> Gracenotes: What I mean is that I haven't managed to evaluate a list's length for long enough to overflow Int
17:31:33 <augur> :|
17:32:07 <augur> if length is not defined tail recursively, it wont matter how small int is, itll never overflow because no additions will ever take place
17:32:34 <Gracenotes> FreeFull: this sounds a bit Sisyphean
17:33:08 <FreeFull> If [1..] is [Int] then length will terminate
17:33:17 <FreeFull> And not overflow either
17:33:33 <Gracenotes> You'll have more luck if it's been compiled with all of the super-optimized GHC flags, rather than running it from ghci, if that's what you're doing
17:33:54 <FreeFull> length l                =  len l 0#   where  len :: [a] -> Int# -> Int  len []     a# = I# a#  len (_:xs) a# = len xs (a# +# 1#)
17:33:55 <augur> FreeFull: will it?
17:34:01 <FreeFull> augur: YEs
17:34:05 <augur> > length ([1..] :: [Int])
17:34:12 <lambdabot>   mueval-core: Time limit exceeded
17:34:13 <augur> FreeFull: why is that tho
17:34:14 <FreeFull> It will take a really long time
17:34:25 <Gracenotes> it's not that length will terminate, it's that enumFrom will terminate.
17:34:28 <FreeFull> > [maxBound - 1 ..] :: Int
17:34:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:34:30 <lambdabot>              with actual type ...
17:34:42 <FreeFull> > [maxBound - 1 ..] :: [Int]
17:34:43 <lambdabot>   [2147483646,2147483647]
17:34:47 <augur> ahhh ok
17:35:07 <Gracenotes> so what is the point of this exercise?
17:36:15 <augur> Gracenotes: erisco was curious about how to abstract list-like structure from particular implementations, include length
17:36:30 <FreeFull> Gracenotes: Demonstrating [1..] is a finite list depending on its type
17:36:40 <erisco> I wanted to keep track of length on a list so the obvious thing to do was abstract lists, right?
17:36:56 <erisco> so the next obvious step was to ask augur to abstract lists :P
17:38:01 <erisco> :re
17:38:43 <Gracenotes> abstracting lists? Foldable and Traversable does most of that, that you could want.
17:39:02 <erisco> mm you should take a gandar at augur's pastebins :)
17:39:11 <erisco> this is what we were up to: http://lpaste.net/92492
17:39:56 <augur> Gracenotes: the constructor-view abstraction generalizes to all ADTs tho, so
17:40:38 <erisco> augur, gunna be bold and rename Listish to List
17:40:53 <augur> erisco: maybe ListI for list interface?
17:41:14 <erisco> else Stack, and that word is too harsh
17:41:40 <erisco> or Listable. not sure why that isn't okay
17:42:09 <applicative> Sequential
17:42:09 <FreeFull> Would a list zipper be a listable?
17:42:41 <erisco> there are some basic laws to satisfy :3
17:42:55 <FreeFull> What are the laws?
17:43:07 <applicative> the listable laws?!
17:43:34 <augur> FreeFull: the laws are just the reductions for the ADT at a type theoretic level
17:43:59 <erisco> what is a list zipper?
17:44:02 <applicative> uncons (cons x y) = Just (x,y)
17:44:04 * hackagebot test-framework-th-prime 0.0.6 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.6 (KazuYamamoto)
17:44:40 <k0001> Excuse me, I'll make a silly question: What's the best way to draw the Haskell logo in a single line ASCII?
17:44:42 <augur> FreeFull: so basically   case viewf nil of { Nil -> m ; Cons x xs -> n } = m   case viewf (cons x xs) of { Nil -> m ; Cons x xs -> n } = n
17:44:52 <applicative> haha
17:45:05 <applicative> the old ghc banner didnt have a lambda
17:45:23 <augur> FreeFull: the use of views lets us use haskell case
17:45:50 <FreeFull> erisco: [a] a [a]
17:46:03 <FreeFull> Which represents a list with a focus
17:46:08 <erisco> looks like a story of isolation
17:46:12 <augur> FreeFull: a non-empty list :(
17:46:35 <augur> need maybe around it!
17:46:39 <FreeFull> [a] (Maybe a) [a]
17:46:40 <augur> Maybe ([a] a [a])
17:46:43 <augur> :)
17:46:49 <dibblego> you can drop the Maybe
17:46:58 <augur> dibblego: can you?
17:47:08 <dibblego> yes, the zipper needs no such thing
17:47:22 <dwcook> k0001, >\= ?
17:47:22 <augur> dibblego: why not
17:47:23 <applicative> k0001: lets devise a new backend for the diagrams library:  diagrams-ascii
17:47:24 <dibblego> this point is in one of the zipper papers
17:47:39 <FreeFull> You can't make an empty list into a zipper
17:48:01 <erisco> then a zipper is not a Listish/ListI/Listable/Sequential
17:48:03 <dibblego> I will need to look it up
17:48:26 <dibblego> it is the same in derivation
17:48:45 <k0001> dwcook: The best I was able to come up with is .\\=
17:49:06 <dwcook> k0001, yeah, that looks way better than my attempt.
17:49:12 <erisco> well, unless the singleton case is the nil case
17:49:22 <augur> it depends on whether or not you're zippering into List positions or into Element positions
17:49:23 <erisco> which would be odd, but possible
17:49:51 <augur> actually it doesnt
17:49:52 <augur> hmm
17:49:52 <k0001> applicative: Oh... that's an interesting idea. I haven't yet had an excuse to dive into `diagrams`.
17:49:57 <FreeFull> augur: Is viewf like head?
17:50:12 <augur> FreeFull: no, it's a generic view widget
17:50:49 <augur> the specific instances in question just map a listish thing into either Nil or Cons x xs, where x is the head, and xs is the "tail" but in the listish type
17:51:00 <applicative> hm mcbrides editor zipper is sort of Zipper a b = ([a],b,[a]) where b is 'information at the cursor' http://stackoverflow.com/questions/12358083/purely-functional-data-structures-for-text-editors/12361200#12361200
17:51:31 <augur> there are a million notions of zipper
17:52:09 <applicative> this is why, no empty zipper seems strangely dogmatic
17:53:52 <mstksg> is there a way to show redundant build-depends in a cabal file?
17:54:04 <applicative> data Zipper2932b2b f a = Zipper2932b2b [a] (f a) [a]; instance Listable f -> Listable (Zipper2932b2b f) ...
17:54:16 <FreeFull> 2932b2b?
17:54:45 <heatsink> To distinguish it from the other 2932b2a data types
17:54:49 <applicative> well, augur said a million notions, rightly enough, so I figured ....
17:54:59 <roboguy_> what about Zipper [a] [a]
17:55:10 <augur> :)
17:56:23 * applicative begins new libary notions_of_zipper, enumerating all possibilities; it would have to be a more interesting hackage contribution than the mighty gutenberg-fibonacci
17:57:10 <applicative> which lists all the fibonacci numbers known to Project Gutenberg, somewhat mysteriously
17:57:43 <FreeFull> @let data Listy a = Nil | Cons a (Listy a)
17:57:44 <lambdabot>  Defined.
17:58:09 <FreeFull> @let data Listy a = Nil | Cons a (Listy a) deriving (Show, Eq)
17:58:09 <lambdabot>  .L.hs:220:6:
17:58:09 <lambdabot>      Multiple declarations of `Listy'
17:58:09 <lambdabot>      Declared at: .L.hs:2...
17:58:13 <applicative> http://hackage.haskell.org/package/gutenberg-fibonaccis stuns the mind, really
17:58:19 <startling> @undef
17:58:20 <lambdabot> Undefined.
17:58:27 <FreeFull> All the defs D:
17:58:30 <FreeFull> @let data Listy a = Nil | Cons a (Listy a) deriving (Show, Eq)
17:58:31 <lambdabot>  Defined.
17:58:56 <startling> FreeFull: oops, did people add important stuff? sorry.
17:59:21 <jkole> what is Haskell's speciality? AI?
17:59:36 <Iceland_jack> jkole: no
17:59:41 <erisco> augur, thanks for the help :D I'm going to sleep now
17:59:47 <augur> night
17:59:59 <erisco> augur, I'll be able to expand on this and rewrite my parser how I need to
18:00:18 <FreeFull> @let class Listable f where nil :: f a; cons :: a -> f a -> f a; viewf :: f a -> Listy a
18:00:18 <m3ga> jkole: depends on who you ask; some say webdev, some say compilers, some say library design etc. no many would say AI
18:00:19 <lambdabot>  Defined.
18:00:26 <FreeFull> Does this Listable look good?
18:00:28 <jkole> m3ga, I see
18:00:42 <erisco> FreeFull, I'll be calling it that
18:00:46 <erisco> if that matters :P
18:00:57 <slack1256> Anybody could install ajhc from cabal?
18:01:03 <shachaf> jkole: Haskell's specialty is computer programs, but it's good at some other things too.
18:01:54 <FreeFull> I just realised my definition of Listy is wrong
18:01:59 <jkole> Is Haskell better than Go, or are they both entirely different and therefore not available for comparison?
18:02:08 <FreeFull> @undef
18:02:08 <lambdabot> Undefined.
18:02:09 <levi> Yes. :P
18:02:11 <startling> jkole: I wouldn't compare them.
18:02:18 <shachaf> jkole: Questions like "is Haskell better than X?" or "what's Haskell good for" are unlikely to lead to anything good.
18:02:22 <FreeFull> @let data Listy f a = Nil | Cons a (f a) deriving (Show, Eq)
18:02:23 <lambdabot>  Defined.
18:02:41 <FreeFull> @let class Listable f where nil :: f a; cons :: a -> f a -> f a; viewf :: f a -> Listy f a
18:02:42 <lambdabot>  Defined.
18:02:42 <levi> Go compiles faster than Haskell.
18:02:45 <shachaf> Especially when you come ask in this channel like that.
18:02:47 <slack1256> @ask can haskell be better than go
18:02:47 <lambdabot> Consider it noted.
18:02:48 <shachaf> See the FAQ:
18:02:50 <shachaf> @where faq
18:02:50 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:02:58 <Iceland_jack> jkole: Do you know any two languages where one is stricly better than the other at everything?
18:03:02 <jkole> Well, I'm trying to figure out what's special about it.
18:03:07 <jkole> What its place is
18:03:10 <applicative> jkole: Go is totally trashy compared to Haskell; honest.
18:03:21 <FreeFull> @let instance Listable [] where nil = []; cons = (:); viewf [] = Nil; viewf (a:as) = Cons a as
18:03:21 <lambdabot>  .L.hs:156:26:
18:03:22 <lambdabot>      Ambiguous occurrence `Cons'
18:03:22 <lambdabot>      It could refer to either...
18:03:23 <shachaf> Let's not have a language war in here, please.
18:03:32 <jkole> Iceland_jack, yes, Ruby is pretty much better than PHP at everything
18:03:32 <FreeFull> :t Cons
18:03:33 <lambdabot>     Ambiguous occurrence `Cons'
18:03:33 <lambdabot>     It could refer to either `L.Cons',
18:03:33 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:141:18
18:03:36 <slack1256> @faq can haskell be better than go
18:03:36 <lambdabot> The answer is: Yes! Haskell can do that.
18:03:39 <slack1256> see?
18:03:43 <FreeFull> @let instance Listable [] where nil = []; cons = (:); viewf [] = Nil; viewf (a:as) = L.Cons a as
18:03:44 <lambdabot>  Defined.
18:03:50 <applicative> Go away Go.
18:04:00 <FreeFull> > viewf [3,4,5]
18:04:02 <slack1256> @faq can haskell save my marriage?
18:04:02 <lambdabot> The answer is: Yes! Haskell can do that.
18:04:03 <lambdabot>   Cons 3 [4,5]
18:04:09 <shachaf> OK, I tried.
18:04:11 <Iceland_jack> jkole: You're asking the wrong question, if you want to see what Haskell is good at then study Haskell
18:04:33 <jkole> That's a lot of effort to find out what a languages purpose is. Normally people can just tell you, assuming there is one.
18:04:53 <Iceland_jack> Are you familiar with a ‘general-purpose programming language’?
18:04:54 <applicative> go is slow; haskell is fast; here's the fraudulent proof: http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=go&data=u32
18:04:59 <levi> jkole: That's a vague question to ask.
18:05:13 <jkole> Iceland_jack, so it's a general purpose language?
18:05:25 <Maior> jkole: are you able to explain "the purpose of X" where X is another language?
18:05:30 <FreeFull> Haskell is general purpose
18:05:30 <slack1256> jkole: general purpose are general.
18:05:34 <levi> Haskell is very much general-purpose.
18:05:37 <Maior> jkole: or "language A is better than language B", for some A/B?
18:05:40 <m3ga> jkole: yes, haskell is a general purpose high level language
18:05:42 <Maior> (just curious)
18:05:51 <Iceland_jack> jkole: https://en.wikipedia.org/wiki/Haskell_%28programming_language%29 ← first line on Wikipedia btw
18:06:00 <applicative> lets not have a language war; lets have a war about language wars
18:06:07 <jkole> The purpose is usually defined by the strengths of the language
18:06:17 <FreeFull> jkole: What's the purpose of C?
18:06:32 <ReinH> edwardk: oh look what I found :D http://www.ukuug.org/events/agm2010/ShortestPath.pdf
18:06:44 <applicative> the purpose of C is that people already know it
18:06:53 <slack1256> usually computer languages compete on succintness, haskell may not be the succintest (apl anyone?) but is certainly interesting and worth learning it.
18:07:01 <jkole> Low level, speed, better than its predecessors
18:07:02 <levi> FreeFull: Creating memory leaks, buffer overruns, and vulnerability to stack-smashing attacks!
18:07:05 <Maior> I mean, I genuinely don't think my two questions can be reasonably answered for most languages
18:07:55 <edwardk> ReinH: heh
18:08:02 <applicative> 'haskell is better than php' -- even that Maior ???
18:08:08 <Maior> applicative: yes
18:08:10 <jkole> Anything is better than PHP
18:08:17 <jkole> $$$$$$lol
18:08:18 <slack1256> ^ that is just bias
18:08:22 <edwardk> ReinH: i updated the mandelbrot renderer to use interlacing and use greyscale
18:08:25 <applicative> I did think we were allowed to say that with impunity
18:08:27 <jkole> It's not really.
18:08:46 <FreeFull> jkole: Would you rather write your web apps in befunge?
18:08:48 <FreeFull> I know I would
18:08:49 <Maior> applicative: because as much as I dislike PHP, I'd probably pick it over Haskell for "I want to create a quick shit web form"
18:08:51 <jkole> It's slow, it has stupid idiosyncrasies
18:08:52 <edwardk> ReinH: perhaps a bit overkill =)
18:09:01 <edwardk> ReinH: given that i added parallelism to it earlier
18:09:04 <Maior> applicative: *for teaching someone
18:10:00 <jkole> FreeFull, if it was a quick hack job, PHP is great for that
18:10:03 <heatsink> TeX produces beautiful page layouts.  Someone should write a web server in TeX.
18:10:04 <jkole> but it's by no means elegant
18:10:12 <jkole> or a well designed language
18:10:52 <Maior> heatsink: I've considered that before...
18:11:01 <ReinH> still, fun :)
18:11:15 <levi> TeX->SVG?
18:11:19 <mm_freak_> Maior: why?
18:11:20 <mm_freak_> i'm sure i can "make a quick shit web form" in haskell much faster than in PHP
18:11:33 <applicative> j lato doesn't take the pains to write a version of 'du' with his new 'posix-paths'; surely it will crash everything if he does, from the look of it.
18:11:35 <levi> For the world's slowest-rendering pages of text.
18:11:46 <Maior> mm_freak_: part of it's that I can't
18:11:58 <mm_freak_> Maior: time to learn it then =)
18:11:59 <Maior> mm_freak_: Haskell web-stuff doesn't come naturally to me
18:12:05 <jkole> So Haskell is equivalent to PHP?
18:12:11 <Maior> mm_freak_: it's on my todo list, but other stuff keeps getting in the way!
18:12:15 <startling> jkole: yep.
18:12:26 <jkole> That's embarrassing.
18:12:27 <applicative> well, there's a php compiler in haskell; and of course acme-php
18:12:30 <DigitalKiwi> wait what
18:12:35 <Iceland_jack> jkole: You got us, there is actually no use for Haskell
18:12:44 <startling> my life is a lie. :(
18:12:47 <jkole> Well no one seems to know what it is.
18:12:55 <jkole> So that's not entirely sarcasm.
18:13:09 <Maior> mm_freak_: but given ubiquity of Apache + mod_cgi + hosting setups etc., I'd find it easier and faster to say "look, write an HTML page, now sprinkle some <%php stuff"
18:13:10 <DigitalKiwi> i was actually about to ask a haskell web question...
18:13:21 <DigitalKiwi> but i think i'll grab some popcorn for now
18:13:35 <mm_freak_> Maior: neither faster nor easier in my view
18:13:37 <Maior> mm_freak_: note, not *for me* - doing demo for friend/relative who doesn't write code, doesn't know what a type is, etc.
18:14:06 <Moggle> jkole: If you're looking for something Haskell does better than other languages, you might consider DSLs.
18:14:14 <Riccardo> I need some more help with lenses... I got a basic traversal to work (with #haskell's help), but now i need to add indexing: http://lpaste.net/1527700380920578048
18:14:38 <Maior> jkole: pure functions, immutable objects, awesome type system, voila
18:14:40 <Riccardo> aside from all the type-foo that i don't get, there should be a problem as f is applied to both branches of choosing, but one is not an indexed traversal
18:14:41 <edwardk> :t Control.Lens.choosing
18:14:42 <lambdabot> Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
18:14:44 <DigitalKiwi> I thought haskell did everything better :<
18:14:48 <mm_freak_> Maior: i'd feel bad demonstrating PHP to people =)
18:14:50 <ferdinand> What's haskell like in engineering applications, specifically electronics and DSP?
18:14:54 <edwardk> choosing doesn't appear to be index-preserving
18:15:03 <Moggle> DigitalKiwi: of course it does :D
18:15:08 <Maior> mm_freak_: same
18:15:11 <edwardk> do you need an index from outside the choosing to pass through?
18:15:12 <jkole> Moggle, consider them for what purpose?
18:15:18 <applicative> the php compiler for which mankind has so long been sighing: https://github.com/jhartikainen/hs-language-php
18:15:22 <edwardk> or just from underneath it
18:15:31 <Riccardo> underneath
18:15:40 <Riccardo> but it's only in one of the branches
18:15:47 <levi> ferdinand: Well, it's pretty nice for those if you use it to develop EDSLs for them.
18:15:52 <DigitalKiwi> I can't tell if you guys are trolling jkole or if he's trolling you ( or maybe both )
18:15:55 <Moggle> jkole: All the purposes? Haskell's purity makes restricting yourself to a few functions easily enforceable by the compiler, thanks to monads.
18:16:01 <Maior> DigitalKiwi: bit of both I think
18:16:03 <mm_freak_> Maior: especially in the danger of giving them the impression that PHP might be a great thing
18:16:09 <Riccardo> i'm ok with coming up with a fake index for the non-indexable branch, but i doubt it would type check as it is
18:16:14 <edwardk> Riccardo: i don't understand the index you want, since by choosing you have indices on each side
18:16:16 <Maior> mm_freak_: heh fair
18:16:18 <startling> Moggle: monads have nothing to do with it.
18:16:29 <Moggle> startling: I agree.
18:16:35 <jkole> PHP is by far an excellent language for being bad at things.
18:16:43 <edwardk> and they cant agree. you want a fake 'Nothing' or Just (i,j) or something as the index?
18:16:44 <ferdinand> levi: ty
18:16:46 <Maior> mm_freak_: I'd be pointing out that I'd choose better alternatives given Time and Future Things...
18:16:47 <Iceland_jack> jkole: Did you come to this channel to diss PHP?
18:16:56 <jkole> No, I wanted to find out why everyone says Haskell is like PHP
18:17:00 <FreeFull> :t let toList xs = case viewf xs of Nil -> []; (Cons a as) -> a : toList as in toList
18:17:01 <lambdabot>     Ambiguous occurrence `Cons'
18:17:01 <lambdabot>     It could refer to either `L.Cons',
18:17:01 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:141:18
18:17:03 <Riccardo> i have a.choosing (itraversed.b.itraversed.c) c
18:17:06 <mm_freak_> Maior: that woudln't hel
18:17:08 <FreeFull> :t let toList xs = case viewf xs of Nil -> []; (L.Cons a as) -> a : toList as in toList
18:17:08 <mm_freak_> help
18:17:09 <lambdabot> Listable f => f a -> [a]
18:17:13 <startling> help
18:17:16 <applicative> do they?
18:17:18 <levi> jkole: Who says its like PHP?
18:17:23 <Moggle> startling: However, he's looking for things so... monads are kinda Haskelly.
18:17:37 <jkole> Blog postings, not in terms of syntax, but in terms of badness "ALLEGEDLY"
18:17:40 <Maior> jkole: try harder - that one was way too obvious
18:17:40 <Riccardo> i need indexes both for b and c on the left branch, but as far as i understand the same function is used on the right branch
18:17:45 <Iceland_jack> “Haskell is like PHP” --Nobody
18:17:59 <FreeFull> :t let toListable [] = nil; toListable (a:as) = cons a (toListable as) in toListable
18:17:59 <lambdabot>     Ambiguous occurrence `cons'
18:18:00 <lambdabot>     It could refer to either `L.cons',
18:18:00 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:148:9
18:18:02 <jkole> No, they equate it to having no purpose
18:18:04 <levi> jkole: Lots of people say stupid things in their blogs, especially about things they don't know well.
18:18:05 <FreeFull> :t let toListable [] = nil; toListable (a:as) = L.cons a (toListable as) in toListable
18:18:05 <DigitalKiwi> show these blogs
18:18:06 <lambdabot> Listable f => [a] -> f a
18:18:07 <jkole> It's just another language dead in the water
18:18:09 <jkole> without a goal
18:18:15 <startling> Moggle: "Haskell's purity makes restricting yourself to a few functions easily enforceable by the compiler, thanks to monads." <- I mean that this is a misleading thing to say.
18:18:17 <Moggle> jkole: Why does a language need a goal?
18:18:19 <edwardk> Riccardo: you're probably going to have to give up on using 'choosing' to drive this
18:18:19 <FreeFull> @undef
18:18:19 <lambdabot> Undefined.
18:18:24 <jkole> It's like Bitcoin, we already have money, why invent a new currency
18:18:29 <Maior> rofl
18:18:29 <jkole> That does the same thing
18:18:38 <Moggle> startling: I will admit I misspoke there! Apologies for the confusion.
18:18:39 <Maior> and there goes all pretence at subtlety
18:18:43 <edwardk> or we can come up with some kind of 'ichoosing'
18:19:00 <jkole> Tweak a few things and you've got a new syntax, but the language does nothing new. What's the point. To give you something to learn?
18:19:01 <FreeFull> startling: Anything that has "thanks to monads" as part of its message is probably misleading
18:19:04 <edwardk> that takes two indexed traversals with different indices and gives you (Either i j) as the composite index
18:19:13 * applicative thanks the monads
18:19:32 <heatsink> praise the monads.
18:19:34 <Moggle> jkole: If you think Haskell only has a little bit of 'new syntax' compared to something like Java, you're in for a pleasant surprise.
18:19:37 <Riccardo> i guess i can use prisms for this no?
18:19:48 <Riccardo> one lens traversal to change the left side, and one for the right side
18:19:48 <Iceland_jack> Moggle: He's very probably trolling
18:19:56 <jkole> No, the syntax is radically different, but the end result is exactly the same, you're trading complexity for complexity
18:19:57 <jkole> REVOLUTION
18:19:59 <jkole> No?
18:20:11 <FreeFull> jkole: The semantics of Haskell are radically different
18:20:16 <Moggle> Iceland_jack: people say that in this channel for quite a few things, I don't think he is.
18:20:16 <Maior> jkole: that's why I only write x86 assembler; all other things are pointless
18:20:32 <edwardk> Riccardo: well, lets look at the type you want for your indexed traversal and figure out how it should work
18:20:56 <edwardk> lensF :: IndexedTraversal' (Maybe (Int,Int)) Fug Int   ?
18:20:57 <applicative> jkole: you really want to know what haskell's secret sauce is?
18:21:02 <jkole> applicative, yes
18:21:14 <Moggle> jkole: I disagree and think the language is quite a bit *better*. The exchanged complexity nets you quite a few benefits.
18:21:16 <applicative> It's unbelievably beautiful
18:21:30 <jkole> Moggle, what are they? That's all I'm wondering really :|
18:21:36 <levi> jkole: Are you coming here just to spout vague philosophical-sounding nonsense? I'd be surprised to hear you actually believe that stuff.
18:21:37 <jkole> applicative, define beautiful
18:21:54 <monochrom> everyone: this is getting close enough to a language war. I ask you to stop. just stop.
18:21:56 <jkole> levi, No... It's not philosophical. It's a genuine curiosity.
18:22:00 <FreeFull> applicative: There are cases where Haskell is ugly
18:22:19 <FreeFull> jkole: Haskell tends to express mathematical ideas well
18:22:26 <applicative> oh, it cant be defined; this has been known for some centuries.
18:22:41 <edwardk> lensF f (Fug (Right x)) = Fug . Right <$> c (indexed f Nothing) x
18:22:41 <levi> jkole: You have a funny way of phrasing "curiosity"
18:22:43 <Moggle> jkole: Well, if I had time I might write an essay but... a well defined typing system eliminates a huge class of bugs, it's functional and pure, so the compiler can reason about it more easily and thus generate more efficient code (though I would hardly go out of my way to say Haskell is the speediest language)
18:22:44 <Riccardo> edwardk: that would work
18:22:55 <FreeFull> edwardk: Fug?
18:23:03 <monochrom> P.S. if someone uses the provocative tactic on you, e.g., "haskell is useless. convince me otherwise", then don't answer. just don't answer.
18:23:19 <Moggle> jkole: Haskell code is very abstract, and tends to be much shorter than the equivalent code in other languages (though not by like a factor of 10 or anything stupidly exaggerated)
18:23:19 <Riccardo> but why a maybe? if i am not using choosing but two separate traversals, there is no need to create a function that works for the non-indexed path
18:23:26 <applicative> no, tell them it's so beautiful you cant stop writing it
18:23:37 <jkole> applicative, is right, and Moggle has the right idea
18:23:55 <jkole> I was not aware of those strong points
18:24:00 <Moggle> jkole: Haskell code, due to its purity, is not typically structured like imperative languages. This tends to make it easier to look over code and understand it, because you don't have to keep track of a bunch of intertwined changing states.
18:24:02 <levi> jkole: If you're really curious, there are a lot of blogs out there describing why people think Haskell is wonderful.
18:24:05 <FreeFull> xmonad is longer than dwm
18:24:15 <DigitalKiwi> yeah, it's all 1s and 0s anyway, why have different languages?!
18:24:15 <Moggle> jkole: Also due to its purity, Haskell can be parallelized *very* easily. Take a look at the STM Monad.
18:24:25 <edwardk> lets expand IndexedTraversal
18:24:30 <mm_freak_> guys, stop feeding the troll
18:24:31 <FreeFull> STM is pretty awesome
18:24:39 <jkole> Hmm interesting Moggle
18:24:39 <Moggle> jkole: The best way to understand the advantage really *is* to just code in it for a week or so and read tutorials.
18:24:48 <applicative> but the secret secret sauce is, its unimaginably beautiful and the compile is a monster of optimization
18:24:55 <applicative> compiler
18:25:07 <jkole> Kind of like Go parallelization?
18:25:29 <FreeFull> Better
18:25:37 <levi> It does Go-style stuff, plus more.
18:25:38 <edwardk> IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t
18:25:42 <jkole> Interesting
18:25:45 <edwardk> when p = (->) this is a normal travrsal
18:25:52 <jkole> So why don't more people use Haskell?
18:25:54 <m3ga> jkole: Go offers one single parallelism primitive baked into the language. haskll offers many, all as libraries.
18:25:55 <Moggle> jkole: If I want to change "forM_ [0..w-1] $ \x -> put (p x y)" to be parallelized
18:25:58 <levi> See the recent book on parallel and concurrent Haskell.
18:26:02 <FreeFull> jkole: Network effects
18:26:08 <applicative> jkole: because their friends use Java?
18:26:10 <edwardk> but when p a b = Indexed i a b  then we have a dfferent beast
18:26:17 <ion> jkole: Catch-22
18:26:19 <Moggle> jkole: I can just change it to this: "F.mapM_ put   (fmap (p ?? y) [0..w-1] `using` parListChunk 16 rdeepseq)"
18:26:28 <ion> jkole: More people don’t use Haskell because more people don’t use Haskell.
18:26:35 <FreeFull> Imperative programming is the dominant paradigm and it's not easy to change that
18:26:37 <edwardk> newtype Indexed i a b = Indexed { runIndexed :: i -> a -> b }
18:26:53 <edwardk> so using your indexed traversal with something like itraverseOf will give you
18:26:56 <Moggle> jkole: Or any other numerous methods. There was a textbook just released recenetly, Parallel and Concurrent Haskell (or something). It's free. I'll get you a link.
18:27:05 <jkole> Thanks Moggle
18:27:09 <applicative> people don't want to give up on what they already learned, even agda
18:27:26 <haasn> Moggle: STM has little to do with parallelization
18:27:27 <FreeFull> I hope Rust will make the imperative world better once it is ready
18:27:31 <haasn> Moggle: it's concurrency
18:27:38 <Moggle> haasn: Yes, my bad if I implied differently.
18:27:39 <edwardk> itraverseOf lensF :: Applicative m => (i -> Int -> m Int) -> Fug -> m Fug
18:27:45 <haasn> (parallelization is *even* easier in haskell :)
18:27:49 <FreeFull> pmap
18:27:50 <Moggle> haasn: ... which I probably did. So my mistake!
18:27:58 <edwardk> where i is whatever index type we have
18:28:05 <applicative> oh i was going to mention marlowes book to our skeptic http://chimera.labs.oreilly.com/books/1230000000929/index.html
18:28:09 <edwardk> when you get down to the Int on the right hand side you don't have any index to give
18:28:11 <Moggle> jkole: http://chimera.labs.oreilly.com/books/1230000000929/index.html
18:28:14 <DigitalKiwi> scala is my gatway drug to haskell tbh
18:28:17 <Moggle> applicative: darnit
18:28:22 <jkole> Cheers
18:28:25 <edwardk> whe you get to it on the left you could give the composition of the two indices
18:28:45 <edwardk> so the best index you can give for a traversal of both sides is Either (Int,Int) ()   or Maybe (Int,Int)
18:28:57 <edwardk> both kinda suck
18:29:02 <DigitalKiwi> I tried learning haskell but I know like a dozen imperative languages, wasn't until I started using scala and eventually learning FP in scala that I got to a point I could even start to change to haskell thinking
18:29:02 <edwardk> but you asked for an indexed traversal =P
18:29:05 <Moggle> jkole: As for the 'beautiful code' argument, representing the fibonacci sequence is a bit contrived, but nice.
18:29:05 <mm_freak_> jkole: in any case it's a mistake to relate quality in any way to size of user base
18:29:17 <jkole> mm_freak_, seems that way
18:29:36 <Riccardo> no it's fine... but are you still going to use choosing?
18:29:37 <DigitalKiwi> mm_freak_: hehe, java, php, C++, etc. ;)
18:29:40 <mm_freak_> jkole: in fact there is a concept called "Avoid Success At All Costs"
18:29:45 <Moggle> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in take 10 fib
18:29:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
18:29:49 <edwardk> Riccardo: you can't really
18:29:57 <edwardk> choosing doesn't support indexing
18:29:57 <haasn> Moggle: that F.mapM_ code seems oddly familiar :P
18:30:00 <Moggle> jkole: I don't know if that makes any sense, but... yeah.
18:30:10 <edwardk> we can make a new ichoosing that is indexed
18:30:13 <Moggle> haasn: I just stole it from edwardk, I had a tab of something he wrote open :P
18:30:18 <edwardk> but the existing one is useless to us
18:30:18 <jkole> Moggle, a little, with my limited knowledge of Haskell, I'll have to give it a try though
18:30:34 <mm_freak_> jkole: haskell follows that principle to some degree to remain free of pollution
18:30:43 <Moggle> jkole: If you haven't had it recommened, try Learn You a Haskell.
18:30:57 <haasn> Moggle: yes, I've just been staring at it for a good half an hour or so :)
18:31:00 <Iceland_jack> jkole: Haskell has some interesting ideas, even if you don't use it (I know this is what everyone says): if you're interested in checking it out look at Learn you a Haskell
18:31:01 <ion> jkole: http://youtu.be/b9FagOVqxmI
18:31:14 <mm_freak_> that also means that we won't rename "Monoid" to "ICombinable" =)
18:31:14 <applicative> jkole: try the GHC, the best tutorial of all;  make sure to compile with -O2
18:31:15 <jkole> Thanks :)
18:31:22 <Riccardo> oh i think i misunderstood before
18:31:31 <heatsink> DigitalKiwi, when you learned Scala, how did you learn "good FP style"?
18:31:32 <Iceland_jack> Some of the benefits of Haskell are very abstract, so it's hard to convey properly
18:31:42 <heatsink> I ask because Scala lets you basically ignore the FP stuff and write Java
18:31:47 <jkole> Fair enough, it'll probably be more evident when I give it a while
18:31:51 <jkole> whirl*
18:31:52 <mlamari> Anyone have darcs-bridge working?  I ask here as there are dependency issues on Win32 AND on linux
18:32:14 <mlamari> Could be the "hell" issue of which I have heard
18:32:22 <DigitalKiwi> heatsink: I wouldn't go so far as to say I learned "good fp style" but that I was able to learn fp concepts more gently
18:32:33 <Riccardo> so i should think of traversals as going from the inner type to the outer, so that choosing in this case is in the way and prevents indexing?
18:32:39 <levi> jkole: Just read through 'Learn You a Haskell' and 'Real World Haskell' and play around with it. You could already have written your first Haskell program!
18:32:59 <DigitalKiwi> heatsink: which is what your second sentence got at, I probably started scala and used very little FP (or at least didn't know it if I did)
18:33:01 <Maior> DigitalKiwi: heh, first day of computer science undergrad, we got taught ML - that was interesting...
18:33:10 <levi> jkole: Or see http://tryhaskell.org/
18:33:11 <Riccardo> if i had a.traversed.b.choosing... i could use the index for a
18:33:21 <jkole> http://learnyouahaskell.com/chapters seems good
18:33:23 <heatsink> I see
18:33:25 <Moggle> jkole: Do read Real World Haskell *after* Learn you a Haskell. It's good, and goes into more detail than LYAH, but... RWH has so many errors and half the code doesn't compile. It's sort of embarassing, and I hope they release an updated version sometime.
18:33:46 <Moggle> jkole: It's not good for starting out imo.
18:33:55 <DigitalKiwi> Maior: when I was studying CS they taught us C++, when I switched to mechanical engineering they had us take an intro to computer programming...either fortran or matlab (I picked fortran...)
18:35:05 <_oio_> how can i pattern mach the rest of a list of tuples
18:35:11 <startling> I didn't even think RWH was that good.
18:35:19 <mm_freak_> _oio_: _:xs?
18:35:36 <mm_freak_> (x1,x2):rest
18:36:11 <Maior> how could one pattern match a tuple of unknown arity?
18:36:17 <geekosaur> you can't
18:36:22 <Maior> ok
18:36:32 <Maior> (I don't have a use-case, just wondered)
18:36:33 <simon> Maior, the type system does not allow variable-size tuples.
18:36:43 <simon> Maior, you use lists for that use-case.
18:36:53 <_oio_> @let func [(nr,nbr):xs] = xs
18:36:54 <lambdabot>  Defined.
18:36:56 <mm_freak_> haskell's type system is not powerful enough
18:37:00 <mm_freak_> but GHC's type system is =)
18:37:13 <monochrom> _oio_: that code looks wrong
18:37:29 <monochrom> @type func
18:37:30 <lambdabot> [[(t, t1)]] -> [(t, t1)]
18:37:33 <mm_freak_> _oio_: that's a list of lists
18:37:34 <edwardk> Moggle: reload. i just updated the page with a bit more text ;)
18:37:43 <Moggle> edwardk: Thanks! :D
18:37:43 <simon> _oio_, using both square brackets *and* cons (:) looks wrong.
18:37:46 <monochrom> do you know why it begins with [[ not just [ ?
18:38:39 <_oio_> idk
18:38:43 <mm_freak_> _oio_: hint:  [x] is a singleton list
18:38:45 <mm_freak_> always
18:38:58 <mm_freak_> (with no commas that is)
18:39:22 <mm_freak_> so what is [(nr, nbr) : xs]?
18:39:25 <Iceland_jack> > let [x] = [1,2,3] in x
18:39:27 <lambdabot>   *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern [x]
18:39:33 <Iceland_jack> > let (x:xs) = [1,2,3] in x
18:39:34 <lambdabot>   1
18:40:16 <mlamari> (On win32) I wiped my user's cabal directory - now it says all the packages are missing - is there a way to tell it to just rebuild everything or its perception of what should be there?
18:40:45 <napping> I've forgotten how to use haskell-mode with more complicated projects. Is there some way to get it to run ghci out of the root directory so imports work?
18:40:45 <mm_freak_> mlamari: if you still have your 'world' file, just cabal update && cabal install world
18:41:10 <monochrom> mlamari: see my http://www.vex.net/~trebla/haskell/sicp.xhtml , although its directory names are for linux instead of windows
18:41:12 <mm_freak_> mlamari: otherwise you will have to reinstall everything manually
18:41:19 <mlamari> mm_freak:  I'm getting 'missing files' junk
18:41:27 <mm_freak_> mlamari: for which command?
18:41:35 <mlamari> cabal install world --reinstall
18:41:54 <mm_freak_> mlamari: did you wipe the entire directory?
18:42:00 <mlamari> Yes
18:42:02 <monochrom> mm_freak_: it's an "erase .cabal" without an "erase .ghc". do you know what happened now?
18:42:05 <mm_freak_> then your world file is also gone
18:42:16 <mm_freak_> monochrom: yeah
18:42:19 <mm_freak_> packages still registered
18:42:27 <mlamari> "There are files missing in the io-choice-0.0.4 package
18:42:28 <mlamari> etc.
18:42:29 <mm_freak_> but pointing to non-existent paths
18:42:34 <mlamari> ghc-pkg check lists a ton of crap
18:42:37 <mlamari> Wheree's that all stored?
18:43:31 <mm_freak_> mlamari: you will have to wipe your .ghc/$PLATFORM directory as well, but i don't know where it is on windows
18:43:52 <mm_freak_> likely in the same directory where your cabal user dir was
18:43:54 <monochrom> maybe I know. I happen to be on windows now
18:44:43 <mlamari> Thanks looks like that was it - the ghc directory.
18:45:27 <monochrom> actually, "ghc-pkg list" tells you
18:46:25 <sansor_> do you know if there are plans for making Data.Text.ICU.Regex compatible with the Regex base library?
18:46:50 <sansor_> and the Data.Text module in general more like the Data.ByteString module?
18:47:32 <monochrom> it's likely \Users\you\AppData\Roaming\ghc
18:48:09 <applicative_> whats the difference between data.text and data.bytestring, sansor_ ; i mean, which are you thinking of
18:48:10 <monochrom> I suppose %APPDATA%\Roaming\ghc is better
18:48:23 <applicative_> mlamari: are you installing 'darcs-fastconvert'?
18:48:29 <ferdinand> in some cases it'd just be %APPDATA%\ghc
18:48:34 <sansor_> i can use the "=~" operator on String and ByteString
18:48:36 <mlamari> applicative_:  Well, that's what started all this - I was trying to
18:48:47 <mlamari> applicative_:  Now I'm just trying to get back to what I had before
18:48:57 <sansor_> but I think it doesn't work with Data.Text
18:49:06 <monochrom> oh oops, it's %APPDATA%\ghc here, too. I misread it.
18:49:15 <dpwright> I'm trying to make use of the EitherT monad transformer to clean up some nested case statements, and it's good, but sometimes I need to perform an action on failure
18:49:16 <sansor_> it's pretty easy to switch anything from String to ByteString but not so much with the Data.Text
18:49:32 <applicative_> oh, i see mlamari that isn't a difference between text and bytestring in themselves
18:49:49 <dpwright> I thought eitherT would give me what I wanted, but that lifts it into the wrapped monad
18:49:55 <monochrom> what goes under AppData\Roaming and what goes under AppData\Local?
18:50:16 <mm_freak_> dpwright: do you need the exact error value?
18:50:27 <mm_freak_> dpwright: i.e. do you need the x in Left x?
18:50:31 <dpwright> to be clear, I only need to perform this action if certain of the steps fail, not blindly for the whole thing
18:50:46 <dpwright> mm_freak_: I'm printing it out at the moment for debugging purposes, so it'd be useful, but it's not essential
18:51:01 <mm_freak_> dpwright: well, EitherT is an Alternative
18:51:06 <mm_freak_> but it doesn't give you the error value
18:51:20 <mm_freak_> EitherT is likely also a MonadError
18:51:47 <applicative_> mlamari: i'm still not following; but the point to be made is darcs-fastconvert is not maintained; still less is the 'darcs-bridge' linked from the darcs site
18:51:51 <mm_freak_> as a last resort you can write a 'catch' or 'finally' function easily
18:52:11 <mm_freak_> finally :: (Monad m) => EitherT e m a -> EitherT e m b -> EitherT e m a
18:52:14 <mlamari> applicative_:  Well, to a noob like me "it doesn't work".  If it doesn't have a trivial fix, I guess it's a nonstarter for me.
18:52:23 <applicative_> mlamari: I seem to be having no trouble building all the dependencies if I follow the mildly deprave expedient of scrapping the upper bounds
18:52:25 <dpwright> hmm, I'll take a look at the Alternative documentation -- I've never used that before
18:52:43 <mm_freak_> > Right "success" <|> Right "error"
18:52:44 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error a0)
18:52:44 <lambdabot>    arising from a use ...
18:52:45 <dpwright> it is a MonadError, but it seems a bit unfortunate to have to resort to exceptions :-/
18:52:48 <mlamari> applicative_:  What did you change?  I'm not especially good at reading these errors
18:52:53 <mm_freak_> > Right "success" <|> Right "error" :: Either () String
18:52:53 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error ())
18:52:54 <lambdabot>    arising from a use ...
18:52:54 <applicative_> mlamari: i will get back to you in a sec, i am building it in a sandbox and theres a pile of deps
18:53:00 <mm_freak_> wat…
18:53:44 <mm_freak_> Alternative for Either is not predefined?
18:54:48 <mm_freak_> wow, this is a REALLY stupid interplay between base and mtl
18:54:49 <Moggle> mm_freak_ isn't the Monoid instance for Either basically Alternative? I may be misremembering.
18:55:09 <Moggle> Left "error" `mappend` Right "right"
18:55:11 <dpwright> It appears to be defined in the package I'm using (http://hackage.haskell.org/packages/archive/either/3.4.1/doc/html/Control-Monad-Trans-Either.html -- that's EitherT rather than Either
18:55:11 <shachaf> Either has a Monoid instance?
18:55:17 <Moggle> > Left "error" `mappend` Right "right"
18:55:17 <mm_freak_> > Right "a" <> Right "b" :: Either () String
18:55:18 <lambdabot>   No instance for (Data.Monoid.Monoid
18:55:18 <lambdabot>                     (Data.Either.Either...
18:55:18 <applicative_> mlamari: here's the cabal file i'm using, but i'm still building stuff http://lpaste.net/92496
18:55:18 <lambdabot>   No instance for (Data.Monoid.Monoid
18:55:18 <lambdabot>                     (Data.Either.Either...
18:55:23 <Moggle> well apparently it does not.
18:55:32 <mm_freak_> Monoid is not predefined either
18:55:33 <Moggle> what *was* I thinking of? Maybe?
18:55:38 <Moggle> Nothing `mappend` Just 1
18:55:39 <listofoptions> anybody know how to do a generic instance (point wise?) update on a data type? like say: "substituteOncePerInstance 2 1 [2,2,3,5]    ->    [1,2,3,5]"
18:55:41 <mm_freak_> yes, Maybe has a Monoid instance
18:55:43 <Moggle> > Nothing `mappend` Just 1
18:55:43 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
18:55:44 <lambdabot>    arising from a use of `e_11'
18:55:44 <lambdabot>  Th...
18:55:59 <external-reality> Hey um... I hear that using type classes as you do interfaces in other languages  is "abuse" but I am having a hard time understanding why?
18:55:59 <mm_freak_> > Just "x" <> Just "y"
18:56:00 <lambdabot>   Just "xy"
18:56:12 <mm_freak_> Moggle: Monoid is usually not what you want for handling errors
18:56:23 <mm_freak_> it is what i often use for /accumulating/ errors
18:56:26 <external-reality> Can someone clarify the situation for me please?
18:56:32 <mlamari> applicative_:  Dangit, I meant darcs-bridge sorry if I said darcs-fastconvertr
18:56:41 <Moggle> mm_freak_: Well, you'd want it for erroring when it finds the first error, no?
18:56:52 <Cale> external-reality: Perhaps you could be clearer about what kind of use you mean
18:56:52 <mm_freak_> Moggle: look at the example
18:56:59 <mm_freak_> > Just "x" <> Just "y"
18:57:00 <lambdabot>   Just "xy"
18:57:04 <applicative_> sansor_: i wonder if http://hackage.haskell.org/package/regex-tdfa-text is any good?
18:57:13 <geekosaur> external-reality, it's not su much "abuse" as "doesn't work"
18:57:22 <applicative_> mlamari: yes, this will take a minute i can do that one too...
18:57:28 <mm_freak_> > Just "x" <> Nothing
18:57:29 <lambdabot>   Just "x"
18:57:29 <Moggle> mm_freak_: Mappend is a bit weird sometimes, I thought? Sometimes it's like adding things together, sometimes it's like Alternative.
18:57:30 <external-reality> hmm...
18:57:37 <Moggle> > Nothing <> Just "x"
18:57:38 <lambdabot>   Just "x"
18:57:40 <mlamari> Of course, I'd take either if it worked :)
18:57:47 <Moggle> It appears I was wrong on Maybe as well. :D
18:57:50 <mm_freak_> Moggle: as far as i've seen Monoid is always like adding
18:57:52 <sansor_> oh thanks! couldn't find that one
18:57:59 <edwardk> external-reality: when i define a typeclass, i'm almost always trying to encapsulate a set of relationships rather than just 'overloading a name'
18:58:03 <Moggle> > Nothing >> Just 1 >> Just 2
18:58:04 <lambdabot>   Nothing
18:58:08 <mm_freak_> Moggle: the only alternating monoids are First and Last
18:58:10 <sansor_> do you mind me asking how you found it :)
18:58:10 <startling> > Nothing <> Just "A"
18:58:10 <lambdabot>   Just "A"
18:58:11 <Moggle> okay so it was the monad instance I was thinking of.
18:58:25 <mm_freak_> > First (Just 1) <> First (Just 2)
18:58:25 <startling> > Just "A" <> Just "B"
18:58:26 <lambdabot>   First {getFirst = Just 1}
18:58:26 <lambdabot>   Just "AB"
18:58:26 <edwardk> external-reality: if i use the former and i have the generic type sgnature involving the class i can often reason about the code without worrying about the type i happen to haveinstantiated it at
18:58:37 <mm_freak_> > Last (Just 1) <> Last (Just 2)
18:58:38 <lambdabot>   Last {getLast = Just 2}
18:58:39 <sansor_> the Data.Text documentation only mentions text-icu package
18:58:43 <edwardk> external-reality: the typeclass has removed worries from my mind, and i can often just use the laws for the types to get by
18:58:47 <Moggle> > Right "wat" >> Left "error" >> Right "success"
18:58:48 <lambdabot>   Left "error"
18:59:00 <Moggle> well I appear to be a moron, but there's nothing new there.
18:59:13 <Moggle> i was thinking of monad, not monoid. derp.
18:59:37 <edwardk> external-reality: on the other hand, if i just make CanMap or something with no laws, then i wind up with a CanMap constraint leaking into my environment because i didn't lock down to a single particular instance, I'm stuck reasoning about the particular instances involved. the typeclass has added to th set of concerns I have about the world
18:59:41 <joefiorini> anyone seen an error with cabal 1.18 and installing hdbc-postgresql?
19:00:24 <external-reality> edwardk: thank you for that! :-)
19:01:03 <napping> external-reality: one particular misues is trying to make a heterogenous collection of things that just happen to have various typeclass instances
19:01:19 <edwardk> external-reality: By capturing the essentials of the problem typeclasses can be a great way to establish more general code letting your reason about essential complexity, by capturing the pecularities of whatever syntax you want, letting you reuse a name in fundamentally unrelated situations they can also be used to mire yourself in incidental complexity.
19:02:34 <edwardk> probably the most damning example i can think of is that the code 'foldMap point' is meaningless
19:02:58 <leroux> external-reality: Building it right now---I'll let you know.
19:03:00 <edwardk> it doesn't give you any ability to reason about what it is doing. there are no laws relating the action of the monoid and the target of 'point'
19:03:18 <edwardk> but people go to use it as an example for why we should add Pointed to the class hierarchy all the time
19:03:32 <edwardk> because they may want to use it to build lists or sets that way
19:03:40 <haasn> what's wrong with ‘pure’ for lists
19:03:43 <haasn> shorter than point
19:03:49 <haasn> oh, or sets
19:03:58 <edwardk> but to reason about that in any context you need to know the particular instance.
19:04:11 <napping> you mean trying to overload the point function?
19:04:15 <edwardk> napping: yes
19:04:24 <joelteon> anybody know what __GLASGOW_HASKELL__ is in 7.4.2?
19:04:28 <napping> okay, foldMap has a perfectly good law
19:04:34 <edwardk> point has no laws relating it to _anything_, except the free theorem
19:04:41 <haasn> edwardk: so in this day and age would we just pass in a Prism?
19:04:47 <Ghoul_> how do I do something like this
19:05:01 <edwardk> foldMap does, but you're relying on an ad hoc property of the relation that happens to hold for [] and Set.
19:05:10 <Ghoul_> [1..5] -> [[1..5], [2..5], [3..5], [4,5], [5]]
19:05:11 <edwardk> if you go to substitute in Maybe for the type for that you're in for a rude surprise!
19:05:20 <edwardk> > tails [1..5]
19:05:21 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
19:05:24 <edwardk> > init $ tails [1..5]
19:05:25 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
19:05:32 <roboguy__> edwardk: what's the free theorem for point?
19:05:33 <Ghoul_> oh, cool
19:05:36 <Ghoul_> didn't know about tails
19:05:43 <dibblego> duplicate [1..5]
19:05:45 <edwardk> roboguy__: fmap f . point = point . f
19:06:04 <edwardk> dibblego: oh yeah. i did write that instance =)
19:06:08 <napping> edwardk: for a point :: a -> m !?
19:06:27 <edwardk> napping: class Pointed f where point :: a -> f a
19:06:40 <napping> oh, a pointed like that
19:06:41 <shachaf> @free point :: a -> F a
19:06:41 <lambdabot> $map_F f . point = point . f
19:06:43 <monochrom> joelteon: it's 704. see also GHC User's Guide section 4.12.3. it's somewhere on your hard disk.
19:06:47 <roboguy__> ah, right
19:06:51 <joelteon> thanks monochrom
19:07:38 <roboguy__> pointed never seemed particularly useful to me
19:07:41 <applicative_> oh lawd, MissingH is going into my little sandbox
19:07:55 <joelteon> MissingH seems pointless too
19:08:04 <edwardk> roboguy__: it gives a principled way to do affine traversals, thats about it
19:08:22 <roboguy__> I don't know what an affine traversal is
19:08:31 <roboguy__> but I'll take your word for it, I guess
19:08:36 <edwardk> joelteon: CosmicRay may disagree, but i'm kind of with you in that its a bit too weird of a grab bag
19:08:44 <edwardk> roboguy__: a traversal with a single target at most
19:08:48 <roboguy__> ahhh ok
19:08:55 <shachaf> Affine traversals are kind of important, though.
19:08:57 <edwardk> > has (element 4) "hello"
19:08:58 <lambdabot>   True
19:09:00 <joelteon> Yeah, if I wanted all the stuff in MissingH, I'd depend on all the packages, but I don't need *all* that stuff
19:09:02 <edwardk> shachaf: sure
19:09:05 <DigitalKiwi> okay i've seen the page about web stacks on the haskell wiki, but what are people actually using?
19:09:16 <roboguy__> shachaf: right, I didn't know thats what that was called though
19:09:33 <DigitalKiwi> and for what kind of sites, cause obviously one size won't fit all
19:10:03 <edwardk> joelteon: heh and that is coming from the author of lens, the biggest grab bag since missingH ;)
19:10:23 <joelteon> yeah, it would be neat if you could pick your lens dependencies
19:10:25 <joelteon> ._.
19:10:29 <zomg> DigitalKiwi: I believe Happstack is being used in a quite wide variety of sites, as is Yesod. Plain warp itself (+ addon modules from hackage) are pretty usable too
19:10:49 <edwardk> joelteon: the problem is lens needs almost all of its dependencies for itself. so you'd just get to shed 2-3 dependencies
19:10:55 <edwardk> and i'd have to cripple the library to let you do it
19:11:04 <edwardk> just doesn't reach parity
19:11:07 <joelteon> well, yeah
19:11:12 <joelteon> but apart from that
19:11:39 <DigitalKiwi> zomg: oh
19:11:55 <DigitalKiwi> i've actually never looked at happstack until 30 seconds ago >.>
19:13:27 <zomg> Yeah I've done a couple of smaller sites with Yesod myself, now working with plain warp to see if it's a good idea or not =)
19:13:41 <applicative_> mlamari: this looks pretty complicated. i recomment #darcs or the darcs mailing list
19:13:46 <DigitalKiwi> i looked most at yesod
19:15:39 <edwardk> joelteon: in the end no choice of how to split the library up makes everyone happy, so i choose in this to please myself =P
19:15:59 <joelteon> >_>
19:16:04 <mlamari> applicative_:  Understood - thanks for trying!
19:16:39 <applicative_> mlamari: i have another hare-brained scheme but it probably wont work
19:17:36 <DigitalKiwi> zomg: I know of template haskell but not really about...and that yesod uses it, how would you rate yesod for a beginner to haskell? or would there be something else you'd suggest starting with?
19:17:59 <applicative_> man the repo darcs is very different
19:18:16 <applicative_> it seems to be half written in C for one thing
19:18:37 <mlamari> For anyone using Conduits (or equivalent) - if you were loading from or saving to multiple actual files, do you combine multiple sources/sinks into one?  Any functions/etc. I should look at, or examples?
19:18:39 <zomg> DigitalKiwi: depends on how much of a beginner you are I guess. I think it's decent, you can get stuff done by just modifying the auto-generated site and just learning from there.
19:19:09 <fiddlerwoaroof> \quit
19:19:10 <zomg> DigitalKiwi: though at least in the past the error messages it caused were pretty confusing, though I think they have been working on to making them a bit saner
19:19:39 <DigitalKiwi> zomg: sometimes I feel like I R Baboon
19:19:47 <zomg> hehe
19:20:14 <DigitalKiwi> and then I get something super cool working and I AM IRON MAN
19:20:49 <Ghoul_> lol
19:20:50 <Hodapp> DigitalKiwi: what brings you into this neck of the woods?
19:21:11 <DigitalKiwi> I have been lurking here off and on for years
19:21:22 <zomg> Pepper Potts probably sent him to the wrong appointment
19:21:23 <zomg> err
19:21:24 <DigitalKiwi> sometimes, I even try learning haskell
19:23:05 <Ghoul_> > maximum $ map (\x -> product $ take 5 x) $ init $ tails number $ map ord $ "12222222222522222221"
19:23:06 <lambdabot>   Not in scope: `number'
19:23:06 <lambdabot>  Perhaps you meant one of these:
19:23:06 <lambdabot>    `IM.member' (imp...
19:23:13 <Ghoul_> > maximum $ map (\x -> product $ take 5 x) $ init $ tails $ map ord $ "12222222222522222221"
19:23:14 <lambdabot>   331250000
19:23:21 <Ghoul_> Its way too big. Why q_q
19:23:27 <dpwright> actually, I think I'm failing at a more fundamental level with this EitherT stuff
19:23:40 <dpwright> I think I must be misunderstanding what it does / how to use it
19:23:46 <DigitalKiwi> Ghoul_: no comment!
19:24:17 <dpwright> I have a sequence of functions which return "IO (Either Error ())"
19:24:21 <fylwind> hi guys, I have another Parsec question: say I have two parsers A and B, and I chain them together A <*> B.  I would like the combined parser to fail without consuming input if and only if B fails without consuming input.  That is, if B fails after consuming input, the combined parser shall also fail after consuming input.  OTOH if A fails (with or without consuming input) then the combined parser should fail without consuming
19:24:22 <fylwind> input. (what a mouthful! :) )
19:24:35 <ReinH> edwardk: I am having moderate success with my pathfinding :)
19:24:38 <Ghoul_> oh, doh! ord doesn't do what I thought it did
19:24:50 <fylwind> so the question being, how should I chain the parsers to accomplish this behavior? (most efficient way possible)
19:25:03 <dpwright> I want to run them, dropping out early if I ever hit the left case or otherwise returning the final Right value... so the return type I want in the end is also "IO (Either Error ())"
19:25:21 <edwardk> Ghoul_: you want the digit value or something?
19:25:25 <Ghoul_> yeah
19:25:26 <dpwright> Right now I can't even lift the IO functions I want to call correctly
19:26:05 <Ghoul_> > map read "12222222222522222221"
19:26:06 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
19:26:06 <lambdabot>  Expected type...
19:26:06 <dpwright> lift / liftIO seem to be expecting an IO action returning (), not one returning "Either Error ()"
19:26:09 <edwardk> :t  Data.Char.digitToInt
19:26:10 <lambdabot> Char -> Int
19:26:15 <edwardk> ^- that is what you want
19:26:32 <Ghoul_> thanks
19:26:44 <edwardk> ord = fromEnum
19:26:49 <dpwright> so "lift $ return ()" works, but "lift $ return (Right ())" doesn't
19:27:15 <dpwright> that points to a misundertanding on my part as to how EitherT is supposed to work, I think
19:27:35 <dpwright> or the runEitherT function
19:27:37 <dpwright> or something
19:30:16 <zomg> dpwright: aren't you supposed to use the functions left/right in Control.Monad.Trans.Either with EitherT?
19:31:01 <dpwright> zomg: Examples I've seen have done that
19:31:07 <Ghoul_> hehe, I have to stop trying to reinvent the wheel
19:31:23 <ReinH> edwardk: is there an easy way to make V2 Int an instance of NFData?
19:31:31 <Ghoul_> primes from Data.Numbers.Primes is such a good prime sieve for euler problems
19:31:33 <dpwright> that would mean rewriting all my functions as EitherT monads instead of IO (Either Error ())
19:31:40 <edwardk> ReinH: yes, submit patches to linear and add deepseq as a dependency to it
19:31:43 <edwardk> ReinH: i'd take it
19:31:52 <dpwright> I was hoping there would be a simple way I could call the latter function from within the EitherT monad
19:31:54 <dagano> what is the best way to print the last n chars of a string?
19:31:59 <ReinH> edwardk: :D ok, and meanwhile in my own code? I'll submit once I get it working.
19:32:07 <ReinH> edwardk: there's a GHC extension I can use right?
19:32:10 <NemesisD> i can't tell if Travis-CI is being an idiot or if i'm doing something wrong: https://travis-ci.org/MichaelXavier/vigilance/builds/10917154 https://github.com/MichaelXavier/vigilance/blob/master/vigilance.cabal
19:32:48 <NemesisD> i'm explicitly specifying QuickCheck >= 2.5.1 and its complaining that it has 2.4.2 installed
19:33:08 <carter> NemesisD: do you do a cabal update?
19:33:09 <edwardk> instance (NFData a, NFData b) => NFData (V2 a b) where rnf (V2 a b) = rnf a `seq` rnf b `seq` ()
19:33:12 <dpwright> something like "IO (Either e a) -> EitherT e IO a" or something
19:33:14 <carter> you may have to do a force install
19:33:19 <carter> they use a somewhat stale vm
19:33:22 <edwardk> ReinH: iirc you just have to write the instance yourself
19:33:28 <edwardk> er
19:33:33 <carter> caba install quickcheck --reinstall
19:33:34 <carter> or something
19:33:39 <edwardk> instance NFData a => NFData (V2 a) where rnf (V2 a b) = rnf a `seq` rnf b `seq` ()
19:34:00 <NemesisD> carter: it looks like it does cabal update at the beginning
19:34:08 <edwardk> ReinH: submit the patch to linear and i'll have it up before you can blink =P
19:34:37 <dpwright> I mean, I guess I could *write* that function fairly easily, but it seems like either it should already exist or I'm working off a misunderstanding
19:35:05 <carter> NemesisD: but if the vm comes with certain packages pre installed
19:35:08 <carter> you'll have to reinstall them
19:35:41 <NemesisD> carter: i thought cabal install --only-dependencies --enable-tests would do that
19:35:42 <carter> NemesisD: so you have have to add to your .travis.yml some forced reinstall of the deps
19:35:49 <carter> NemesisD: only if its sandboxed
19:35:56 <carter> in the cabal 1.18 sense
19:35:56 <ReinH> edwardk: yep, got it :)
19:36:02 <NemesisD> ugh
19:36:04 <ReinH> edwardk: my wife is forcing me to go eat dinner though :/
19:36:13 <carter> NemesisD: you should file a ticket on this too
19:36:21 <edwardk> ReinH: they do things like that
19:36:29 <NemesisD> what is the ticket? cabal 1.18 isn't even released
19:36:31 <carter> its only by telling htem that you can get this fixed
19:36:35 <carter> NemesisD: i mean with travils
19:36:48 <NemesisD> carter: i know. what are they doing wrong
19:36:51 <carter> yeah
19:37:15 <carter> NemesisD: it may be simpler
19:37:20 <dpwright> I guess I'm looking for the opposite of runEitherT
19:37:22 <carter> link me to your .travis.yml?
19:37:31 <applicative_> dpwright: EitherT a IO  b = IO (Either a b) already, no
19:37:33 <carter> ok
19:37:34 <carter> https://github.com/MichaelXavier/vigilance/blob/master/.travis.yml
19:37:38 <carter> soooo
19:37:44 <carter> you may wanna do a cabal update
19:37:46 <carter> explicitly
19:37:48 <carter> before things
19:37:58 <applicative_> @type EitherT
19:37:58 <lambdabot> Not in scope: data constructor `EitherT'
19:38:04 <applicative_> no such luck
19:38:13 <carter> NemesisD: as a crayz example of a haskell yml https://github.com/cartazio/ghc/blob/master/.travis.yml
19:38:18 <carter> @hackage lens
19:38:18 <lambdabot> http://hackage.haskell.org/package/lens
19:38:23 <applicative_> dpwright: EitherT is the opposite of runEitherT
19:38:38 <carter> NemesisD: adapt the lens one here https://github.com/ekmett/lens/blob/master/.travis.yml
19:38:49 <dpwright> applicative_: Ah!
19:39:09 <carter> NemesisD: you need an explicit cabal update in your travis script
19:39:25 <applicative_> dpwright: have you seen the additional helper function in the 'errors' package? I suppose you have
19:39:53 <edwardk> carter: only if you replace before_install IIRC
19:40:11 <carter> edwardk could be, i'm cargo culting :)
19:40:34 <carter> i thought it was an issue, that they didn't do a cabal update on the vm normally
19:40:35 <edwardk> carter: even then its fine unless you need just released versions of dependencis
19:40:39 <NemesisD> carter: ah ok. giving it a try now
19:40:44 <edwardk> no, they do their own
19:40:48 <carter> oh
19:40:52 <carter> well
19:41:24 <edwardk> i originally wrote that line as part of the mkdir -p … thing, but it got split when we incurred a dep on exceptions that wasn't getting picked up by the vm's without it
19:41:28 <leroux> Has anyone had trouble with installing base using cabal 1.18?
19:41:41 <edwardk> installing base?
19:41:50 <leroux> Yeah....but that should probably be installed with ghc...
19:41:51 <leroux> Right?
19:41:53 <edwardk> leroux: in general upgrading base doesn't happen
19:41:53 <carter> yup
19:41:56 <carter> yup
19:42:21 <NemesisD> yeah it doesn't seem to like the cabal-apt-install part
19:43:10 <carter> NemesisD: hrmmm
19:43:24 <carter> how about start with a .yml thats an explicit version of  the default one
19:43:27 <leroux> So, I've already configured and built ghc using an alternate prefix.
19:43:28 <applicative_> leroux dont update base. what version of ghc are you using? on what platform?
19:43:39 <leroux> The Glorious Glasgow Haskell Compilation System, version 7.7.20130901
19:43:46 <leroux> cabal-install version 1.18.0
19:43:54 <carter> leroux: whats your actual goal?
19:43:58 <applicative_> so you have base with that ghc, what's next?
19:44:37 <leroux> Building and installing ghc to my system. I configured it with an alternate prefix so that I could easily switch ghc builds.
19:44:39 <applicative_> it could be that something has a higher bound that is lower than 7.7's base
19:45:13 <enthropy> is it typical for an average application to load almost a hundred packages when you're linking it?
19:45:16 <leroux> Oh, I did forget to including ghc's lib dir in LD_LIBRARY_PATH.
19:45:53 <leroux> Well, DYLD since I'm on OS X.
19:46:00 <applicative_> leroux: this is seeming suspicously complicated but i'm not sure
19:46:07 <leroux> It is...
19:46:19 <NemesisD> hmm i don't see a default travis.yml, i think its just the cabal install script
19:46:23 <applicative_> i have ghc-head on osx i just build with --prefix=/Users/m/h
19:46:56 <leroux> I use --prefix=local (just in the build tree itself)
19:47:41 <applicative_> oh that's a little confusing, but i guess makes sense
19:48:22 <leroux> And I installed cabal from HEAD as well. Not from brew.
19:48:24 <carter> leroux whats that have to do with changing base?
19:48:25 <joefiorini> I'm trying to install a library that depends on hdbc-postgresql using the cabal 1.18 rc; getting a type error in Setup.hs around ProgramSearchPath. Anyone seen/fixed that before?
19:48:37 <leroux> carter: cabal isn't able to find base.
19:48:37 <carter> joefiorini: file a ticket on hackage!
19:48:39 <edwardk> enthropy: depends on if i wrote it =P
19:48:41 <TallerGhostWalt_> Is there a good reference for all the type annotation syntax?
19:48:41 <leroux> Or ghc-prim.
19:48:45 <carter> leroux: huh
19:48:47 <applicative_> as carter says, it's still a little mysterious why your asking about base
19:49:02 <TallerGhostWalt_> Like what does the tilde mean?
19:49:05 <applicative_> all of these are present if you manage to build ghc
19:49:06 <leroux> "ould not find module ‛GHC.CString’"
19:49:18 <carter> TallerGhostWalt_ ~ == equals
19:49:21 <leroux> I'm assuming it can't find base since it says that.
19:49:23 <dpwright> applicative_: Sorry, I had to restart
19:49:33 <edwardk> leroux: something is hosed in your install. base came with your compiler
19:49:37 <enthropy> edwardk: your libraries are partly to blame
19:49:46 <carter> leroux i'd agree with edwardk  there
19:50:01 <edwardk> enthropy: what am i being blamed for exactly?
19:50:05 <dpwright> I haven't taken a look at the errors package, I will do so now -- but it looks like your hint about the EitherT constructor being the opposite of runEitherT was exactly the hint I needed -- thanks!
19:50:11 <TallerGhostWalt_> yeah I figured that one out but I guess I was hoping there was a place to look!
19:50:16 <lpaste> enthropy pasted “loading so many packages” at http://lpaste.net/92497
19:50:25 <carter> TallerGhostWalt_: ghc dev wiki
19:50:27 <applicative_> oh wait, leroux could it be you haven't done stuff like 'sync-all get' and so on
19:50:31 <joefiorini> carter: stupid question, but where do I do that? looks like I can't just create a user account.
19:50:34 <leroux> applicative_: I did.
19:50:38 <carter> joefiorini for what?
19:50:46 <TallerGhostWalt_> ooh, I hadn't thought of that
19:50:49 <joefiorini> file a ticket on hackage
19:50:50 <applicative_> leroux: hm, i dont get it
19:50:57 <carter> joefiorini hackage?!
19:51:00 <carter> cabal
19:51:07 <carter> right?
19:51:11 <carter> @hackage cabal
19:51:12 <lambdabot> http://hackage.haskell.org/package/cabal
19:51:12 <joefiorini> oh, you said hackage, I got confused :)
19:51:24 <carter> https://github.com/haskell/cabal/issues?state=open
19:51:24 <edwardk> you're depending on trifecta and repa and stm and HList and quickcheck in the same application. you're basically dragging in hackage
19:51:33 <carter> thats a lot of hackage
19:51:34 <joefiorini> carter: looking there, thanks
19:51:34 <applicative_> dpwright: oh great; errors is what all the cool kids are using for either eithert etc management, its unusually sensible
19:51:36 <carter> who's doing that
19:52:00 <edwardk> enthropy: with 7.8 my recollection is that the Loading .. messages will go away finally. i put in a request for that and it was approved
19:52:15 <edwardk> enthropy: that will still happen, but hopefully it'll stop spamming users ;)
19:52:27 <NemesisD> i feel like my life is going to be a whole lot easier when they just release cabal 1.18
19:52:36 <leroux> applicative_: I have base 4.7.0.0 installed...
19:52:50 <carter> NemesisD: its out already
19:52:52 <NemesisD> is there a way i could force travis to install a newer version of QuickCheck?
19:52:53 <carter> just RC status
19:52:55 <leroux> Could it be that the package I'm trying to install needs an older base?
19:53:07 <carter> leroux: you need to share error messages
19:53:10 <carter> gist them
19:53:25 <carter> leroux: if you can share error messages that orgiinate things
19:53:27 <carter> we can help better
19:53:36 <NemesisD> carter: i use it . i mean released as in platforms I have to deal with that I don't control will have it
19:53:37 <leroux> https://gist.github.com/leroux/6419231
19:54:13 <edwardk> leroux: if i had to guess your whole install is fubared. have you tried just nuking the site from orbit by reinstalling the latest platform?
19:54:15 <carter> leroux: i dont' know if Text has a 7.8 version yet
19:54:42 <edwardk> leroux: or are you doing something with GHC HEAD?
19:54:47 <leroux> edwardk: Yes.
19:55:00 <dpwright> applicative_: Oh, nice!  Yeah, this looks like a nice way to deal with potentially exception-throwing functions -- thanks :-)
19:55:02 <carter> leroux mght just be that text is not aware of 7.8 internal ap's yet
19:55:03 <carter> https://gist.github.com/leroux/6419231#file-gistfile1-txt-L1-L3
19:55:04 <applicative_> oh, i think i've installed text with ghc-7.7
19:55:08 <carter> huh
19:55:14 <NemesisD> i should just develop on CentOS and that way I don't write anything that doesn't compile on a GHC from 3 years ago
19:55:29 <carter> but then you'd be sad
19:55:46 <applicative_> OH PROFILING LIBRARIES
19:55:49 <NemesisD> it would be a race between finishing my projects and the urge to off myself
19:55:58 <leroux> applicative_: I just disabled them and tried again.
19:56:04 <leroux> Am trying again*
19:56:14 <carter> applicative_ good call
19:56:15 <applicative_> oh i see you noticed
19:56:30 <leroux> applicative_: Do I need to enable profiling on ghc?
19:56:44 <applicative_> leroux: when you build you specify if you want it
19:56:51 <leroux> ahh, I see.
19:56:55 <leroux> I use quick build.
19:57:08 <carter> leroux quickbuild is good for dev, but not for USING it
19:57:34 <applicative_> right so you need to adjust cabal/config not to add profiling libraries.  i wonder if there's a way to do this just with your ghc-head.
19:57:50 <leroux> applicative_: Yeah, Data.Text is building now as we speak.
19:58:11 <mm_freak_> accelerate doesn't seem to support recursion…  is that right?
19:58:21 <mm_freak_> (would make sense)
19:58:27 <carter> mm_freak_ its a flat DSL
19:58:40 <carter> it has combinators that may act recursive thogh
19:58:48 <carter> in a loopy sense
19:58:52 <mm_freak_> couldn't it use observable sharing or something to allow general recursion?
19:59:08 * hackagebot ghc-mod 2.1.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.1.0 (KazuYamamoto)
19:59:10 <carter> no clue
19:59:21 <leroux> applicative_: Is it sane to use GhcProfiled = Yes in the quick build?
19:59:22 <chrisdone> do cost centres ever show up in core output?
19:59:24 <carter> mm_freak_: its also a got a pretty restricted complation model
19:59:33 <carter> if you read the papers
20:00:05 <mm_freak_> hmm
20:00:27 <mm_freak_> that would mean there are many algorithms i can't express =/
20:00:33 <carter> mm_freak_ indeed
20:00:42 <carter> mm_freak_: what algs are you wanting?
20:01:46 <mm_freak_> carter: i was about to write a divide-and-conquer multiplication algorithm, but noticed that i can't actually recurse unless i arbitrarily enforce a maximum depth outside of the DSL
20:01:59 <mm_freak_> mult :: Int -> Acc BigInt -> Acc BigInt
20:02:15 <carter> accelerate is also the wrong subtrate for that
20:02:34 <carter> first proto it in vector!
20:03:05 <mm_freak_> and it also means, it will be completely unrolled on the GPU
20:03:16 <carter> yeah
20:03:33 <carter> accelerate and repa are kinda only good for algs that are sort of pointwise or stencil like
20:03:40 <mm_freak_> it's just an experiment to find the limits of accelerate
20:03:53 <mm_freak_> well, repa can actually do that
20:03:54 <carter> ah
20:04:09 <mm_freak_> that's because it's not a DSL, so recursion is on haskell's side
20:04:10 <carter> well, thats because its a shallow embedding, right?
20:04:15 <carter> yup
20:04:24 <mm_freak_> if that's what "shallow embedding" means, then yes =)
20:04:38 <carter> shallow = use the host language to run
20:04:49 <carter> deep = "i have my own little compiler thingy"
20:04:54 <mm_freak_> ah, i see
20:05:05 <mm_freak_> so accelerate and atom are deep embeddings
20:05:13 <carter> yup!
20:05:36 <mm_freak_> i wonder if accelerate will ever support recursion then
20:05:59 <carter> as its currently done, nope
20:06:10 <carter> theres ways around that going forward
20:06:47 <mm_freak_> well yeah, i could always take a CPU indirection, but for frequent recursions that would destroy the point of using a GPU =/
20:07:03 <carter> nope
20:07:07 <carter> i meant something else
20:07:15 <mm_freak_> what did you mean?
20:07:18 <carter> well
20:07:27 <joelteon> guys, what's the time complexity of f 1 = ...; f 2 = ...; f 3 = ...
20:07:31 <joelteon> i.e. calling f
20:07:43 <carter> depends on the f
20:07:44 <mm_freak_> joelteon: depending on the type
20:07:44 <carter> oh
20:07:49 <joelteon> ok, Text
20:07:58 <mm_freak_> joelteon: then that's a type error
20:08:06 <carter> joelteon:  Int -> IO Tex?
20:08:10 <joelteon> no, I mean
20:08:16 <joelteon> f "a" = ...; f "b" = ... and so on
20:08:18 <MedDev> hmm is there someway I can pass a field name? or extract it somehow from a partially applied field accessor?
20:08:24 <joelteon> what's the time complexity of calling f?
20:08:26 <mm_freak_> joelteon: O(n) in that case, n = number of cases
20:08:32 <joelteon> sorry, I thought it would be the same regardless of type
20:08:45 <carter> ifs be ifs
20:08:46 <mm_freak_> joelteon: if you use actual constructors, then yes
20:09:00 <mm_freak_> joelteon: f X = …; f Y = …; f Z = …; …
20:09:02 <mm_freak_> O(1)
20:09:09 * hackagebot ghc-mod 2.1.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.1.1 (KazuYamamoto)
20:09:18 <joelteon> oh
20:09:19 <tac> joelteon: pattern matching naively compiles down to tag-checking, so you can expect it takes linear time in the number of cases, amortized by how long it takes to test equality of two elements
20:09:24 <joelteon> yeah, I wouldn't be matching on a constructor
20:09:33 <mm_freak_> joelteon: in your case 'f "x"' really means: 'f x | x == fromString "x" = …'
20:09:47 <joelteon> right
20:09:54 <mm_freak_> so it checks them in order
20:09:56 <carter> mm_freak_: so theres two ways aroudn the deep expression problem:
20:10:03 <carter> 1) ghc compiler plugin magic
20:10:16 <carter> 2) add something like the idris DSL machinery to ghc
20:10:23 <mm_freak_> carter: 3) observable sharing
20:10:32 <carter> mm_freak_ accelerate does that though
20:10:52 <carter> but i think how they compile to gpu may not allow general control flow patterns
20:11:07 <mm_freak_> carter: it doesn't seem to
20:11:09 <mm_freak_> test :: Acc (Scalar Word32) -> Acc (Scalar Word32)
20:11:09 <mm_freak_> test n = cond (the n ==* 0) (unit 0) (test (unit (the n - 1)))
20:11:17 <mm_freak_> infinite loop, because infinite expression
20:11:22 <applicative_> MedDev: maybe you should say a bit more about these fields and accessors?
20:11:34 <carter> ?
20:11:35 <mm_freak_> carter: i tried with the interpreter, because i was afraid of uploading that to the GPU
20:11:42 <MedDev> workin on a paste applicative_ :)
20:11:58 <carter> which is infinite?
20:12:02 <mm_freak_> carter: it should just count down its argument and then return 0
20:12:13 <mm_freak_> f 0 = 0; f x = f (x - 1)
20:12:19 <mm_freak_> that's what it really does
20:12:23 <mm_freak_> or is supposed to do
20:12:36 <carter> huh
20:12:38 <carter> bug?
20:12:43 <mm_freak_> no, it's reasonable
20:12:50 <mm_freak_> it's an infinite expression
20:12:55 <mm_freak_> i actually expected that one to loop
20:13:03 <carter> but they have sharing ...
20:13:10 <mm_freak_> hmm
20:13:19 <mm_freak_> perhaps it's the interpreter that can't handle it?
20:13:52 <mm_freak_> ok, i'll just go ahead and try on my GPU…  if i time out, my system crashed =)
20:14:18 <mm_freak_> nope, same result
20:14:49 <mm_freak_> does it have sharing in Acc or in Exp?
20:14:50 <lpaste> MedDev pasted “partially applied accessor” at http://lpaste.net/92498
20:14:51 <carter> huh
20:14:55 <mm_freak_> currently i'm recursing in Acc
20:15:00 <carter> ohh
20:15:02 <carter> try exp?
20:15:09 <carter> idk…. should be both?
20:15:09 <mm_freak_> ok, let me try
20:15:15 <carter> worth filing a ticket to ask
20:17:09 <mm_freak_> carter: http://lpaste.net/92499
20:17:13 <mm_freak_> same result
20:17:48 <carter> huh
20:18:03 <carter> worth giving them  a ticket explaining what you'd expect vs what happened
20:18:13 <carter> at the very least they'll have more documentation!
20:18:28 <dpwright> mm_freak_, applicative_ -- just to follow up, the EitherT constructor solved my problem with trying to call IO functions, and then to do cleanup after certain operations, "catchT" in the errors package was exactly what I needed
20:18:37 <dpwright> Thanks for pointing me in the right direction!
20:24:36 <Moggle> Might not be a Haskelly enough question for this channel, but I have been trying to read up on category theory and I feel my knowledge of mathematics is seriously lacking. All I've gotten is some basic group theory in a required course for my engineering major. I don't suppose anyone has some good suggestions on textbooks I can use to build up my base?
20:24:54 <Moggle> That is to say, more abstract math. My calculus is more than fine :P
20:25:43 <mm_freak_> carter: https://github.com/AccelerateHS/accelerate/issues/112
20:26:02 <carter> mm_freak_ awesome!
20:26:16 <carter> these days, whenever someone hits neat / unexpected / bugs / etc
20:26:28 <carter> my stance has become "file a ticket, so its written down somewhere"
20:26:45 <mm_freak_> maybe i should read the paper
20:27:10 <joelteon> is there a magic comment that will prevent HLint from complaining about camel case in a certain file?
20:28:20 <mm_freak_> Moggle: you don't really need a lot of prior knowledge for category theory…  it's just unfortunate that many introductions jump into topology very early
20:28:50 <mm_freak_> Moggle: CT is mostly a self-contained theory
20:29:36 <carter> yeah
20:29:45 <carter> theres a lot of vocab
20:29:48 <carter> which is daunting
20:29:52 <carter> just ask people what it means
20:29:54 <td123> anyone know any good books I can get formally introduced to type theory? I'm considering Types and Programming Languages by Ben Pierce
20:30:02 <carter> td123 thats a classic
20:30:20 <carter> that + reading lots of papers that sound cool once you've read that book, will get you started
20:30:27 <carter> also proofs and types by girard
20:30:29 <carter> plus some others
20:30:34 <carter> plus the bob harper tome
20:30:42 <carter> which got published last fall
20:30:50 <td123> but those probably come after TaPL I'm guessing
20:31:03 <joelteon> ANN module isn't working for me with hlint
20:31:05 <Moggle> mm_freak_: Uh, like two of my category theory textbooks jumped right into talking about various algebras. I was sort of lost.
20:31:32 <td123> carter: thanks, I'll make myself a list
20:31:34 <Moggle> mm_freak_: I'm also just plain interested in general math, so....
20:31:55 <mm_freak_> Moggle: just try multiple sources
20:31:56 <carter> joelteon: theres some flags you can just pass hlint I think
20:32:03 <carter> read all the cool things
20:32:18 <carter> or at least
20:32:24 <carter> figure out the best style of math books for you
20:32:28 <carter> and read them in all the topics
20:32:44 <mm_freak_> Moggle: i liked this video series: http://www.youtube.com/watch?v=eu0rj5C2Otg&list=PLE4CC57A4C08EEF2F
20:33:14 <mm_freak_> it's very gentle…  from time to time it does jump into other advanced fields, but overall very accessible
20:33:31 <Moggle> mm_freak_: I'll look into it! Thanks.
20:34:44 <Ghoul_> I need a data type thats like a 2d array
20:34:49 <Ghoul_> ideas?
20:35:20 <td123> carter: are you referring to http://www.amazon.com/Practical-Foundations-Programming-Languages-Professor/dp/1107029570
20:35:30 <carter> yeah
20:35:33 <mm_freak_> Ghoul_: standard arrays, repa arrays, maps, hashmaps, …
20:35:39 <mm_freak_> Ghoul_: depending on your application really
20:35:40 <carter> i read part of a draft a few years ago
20:35:44 <joelteon> heh
20:35:46 <carter> pdf is free online too
20:35:49 <joelteon> carter: yeah, I'd rather automate it though
20:36:01 <carter> ??
20:36:04 <carter> joelteon: yes
20:36:10 <joelteon> but it won't work anyway
20:36:13 <carter> you script calling hlint with those flags
20:36:20 <Ghoul_> UArray is probably good enough
20:36:23 <joelteon> at the bottom I have {-# ANN module "HLint: ignore Use camelCase" #-}
20:36:30 <joelteon> well actually it's
20:36:33 <mm_freak_> Ghoul_: depends on your application
20:36:36 <joelteon> {-# ANN module ("HLint: error Use camelCase" :: String) #-}
20:36:45 <joelteon> and hlint complains about redundant brackets, though if I remove them it's a parse error
20:36:45 <carter> does anyone actually use Uary?
20:36:49 <joelteon> and it still complains about camelCase
20:36:52 <td123> carter: cool thanks
20:36:53 <carter> joelteon: bug report!
20:36:54 <mm_freak_> Ghoul_: you can also use vectors with Data.Ix
20:36:57 <joelteon> ok
20:38:17 <carter> @hackage array
20:38:17 <lambdabot> http://hackage.haskell.org/package/array
20:38:40 <carter> for someon reason i've forgottten that array's existed for the past few years :)
20:38:41 <Ghoul_> Yeah I'll use array. My use case isn't complex (just brute forcing a euler)
20:38:49 <carter> Ghoul_ i like vector personally
20:39:19 <mm_freak_> Ghoul_: it's probably better to use vectors instead…  just use them together with Data.Ix
20:39:27 <joelteon> maybe I need a newer hlint
20:39:32 <carter> mm_freak_ agreed
20:39:42 <carter> array isn't really actiely deved
20:39:46 <carter> relatively
20:39:47 <Ghoul_> that sounds confusing.
20:39:49 <carter> and vector has a better api
20:39:55 <carter> Ghoul_: TLDR: use Vector
20:40:06 <carter> its the moderner array
20:40:15 <mm_freak_> Ghoul_: vectors are one-dimensional, so indices and sizes are expected to be passed as Int
20:40:35 <mm_freak_> Ghoul_: Data.Ix is the module for converting between arbitrary kinds of coordinates and Int
20:40:36 <carter> you can totally make a wrapper that uses 2 shape
20:40:45 <carter> yeah
20:40:49 <carter> what mm_freak_  says
20:40:58 <mm_freak_> so you can use e.g. (Int, Int) or even Integer or your own type
20:41:09 <carter> mm_freak_:  wait
20:41:15 <carter> theres a subtlty
20:41:23 <carter> you nedd to know the shape of a 2d array
20:41:23 <mm_freak_> hmm?
20:41:25 <carter> to do the
20:41:31 <carter> (int,int) -> int mapping
20:41:48 <mm_freak_> carter: sure
20:41:53 <carter> index (int, int ) -> shape (int, int)-> location
20:42:05 <carter> Ghoul_ if you can wait a few weeks, use my stuff
20:42:10 <carter> else just do a wee think like that
20:42:13 <carter> and choose row major
20:42:13 <Ghoul_> that's making it so much harder than it has to be
20:42:19 <tac> The built-in Haskell vector library is obnoxious -.-
20:42:21 <carter> you need to know the shape
20:42:21 <mm_freak_> Ghoul_: use arrays =)
20:42:29 <carter> i'm tired
20:42:30 <carter> night all
20:42:34 <Ghoul_> night
20:42:36 <mm_freak_> night carter
20:42:44 <mm_freak_> tac: what is the built-in vector library?
20:43:00 <enthropy> carter: why not repa?
20:43:13 <carter> for what?
20:43:21 <mm_freak_> enthropy: because repa has a learning curve
20:43:23 <enthropy> for doing the indexing conversion
20:43:31 <mm_freak_> i use repa for most things now
20:43:38 <carter> because Ghoul_  has only been haskelling for a few months
20:43:38 <mm_freak_> but it's not exactly easy to get into =)
20:43:44 <enthropy> while somewhere down there you have a vector
20:43:57 <carter> mm_freak_: ooo, hopefully i can get you to try out my stuff when i get it out soon :)
20:44:00 <carter> night all
20:44:09 <mm_freak_> carter: something to read already?
20:44:43 <mm_freak_> too bad…  i'll be happy to check it out =)
20:44:43 <carter> mm_freak_ not quite, aiming to release a better numerical lib in a few weeks
20:44:50 <carter> or at least the start of one
20:44:54 <mm_freak_> "better"?
20:45:18 <carter> mm_freak_ : yes
20:45:21 <carter> as in
20:45:25 <carter> lets you reason about locality
20:45:30 <carter> and is a bit more extensible
20:45:31 <carter> and such
20:45:51 <mm_freak_> i see…  not sure where i would use it, but i'll check it out when you release it =)
20:46:15 <carter> yay
20:46:18 <carter> thats all i can ask for
20:46:43 <mm_freak_> btw, in the last two days there have been at least two requests for shapes on vectors
20:46:45 <carter> mm_freak_: while the types will be a tad more complex / richer than repa, i'm hope to have it be easier to use
20:46:52 <mm_freak_> i think i'll make a wrapper library for that
20:46:57 <carter> good thing i've been working on it for a year :)
20:47:09 <carter> mm_freak_ cool
20:47:15 <carter> row major only?
20:47:40 <mm_freak_> carter: not sure yet…  i guess i'll just use repa shapes for indexing
20:47:52 <carter> cool
20:47:54 <carter> so row major
20:48:09 <mm_freak_> anyway, go to bed =P
20:48:10 <carter> repa's really really got "row major " baked in
20:48:11 <carter> k
20:48:14 <carter> yes
20:48:52 <chrisdone> awesum
20:49:25 <chrisdone> luite: compiling core as interpreted for the breakpoints gives me sufficient sourcemappage
20:51:04 <enthropy> a bit of irony to have a typo in the description for http://hackage.haskell.org/package/quickcheck-poly
20:51:27 <enthropy> is there a version of this that isn't bitrotted?
21:04:57 <sclv> enthropy: it seems like a… bad idea
21:05:14 <sclv> like with a bit more boilerplate you can get something much more reliable
21:05:21 <sclv> that doesn't rely on the ghc api
21:12:15 <mm_freak_> when i write:  data X a (b :: a)
21:12:32 <mm_freak_> then the second a is not the same as the first a, it's just a separate polymorphic kind variable
21:12:35 <mm_freak_> right?
21:14:20 <ReinH> edwardk: so I've got my shortest paths algo but I'm doing a lot of work to turn my grid into a sparse matrix unnecessarily
21:14:24 <ReinH> so I need to refactor a bit
21:15:03 <zomg> So was reading about bifunctors and profunctors and whatnot.. cool, but I have no idea what I'd use them for \o/
21:17:45 <edwardk> ReinH: if only you had some kind of nice sparse matrix type to start with… j/k ;)
21:18:49 <ReinH> edwardk: :p
21:19:02 <ReinH> edwardk: I'm using Map Coord (Map Coord Weight) and it doesn't such
21:19:09 <edwardk> hrmm, sequence algebras form a Choice instance.
21:19:19 <ReinH> *suck
21:19:32 <edwardk> ReinH: Mat Weight gives you coherence ;)
21:19:33 <ReinH> the problem is that I'm doing a lot of work to get from my grid representation to my graph representation
21:19:47 <edwardk> but in seriousness you've got a not bad way to deal with it there
21:19:55 <edwardk> Map Coord (Map Coord Weight) is even linear-compatible
21:20:06 <ReinH> what does that mean?
21:20:22 <edwardk> i mean that that can be viewed as a sparse matrix in linear and used for matrix multiplication, etc.
21:20:28 <ReinH> edwardk: ah, neat
21:20:42 <edwardk> all the matrix multiplication combinators wil just work on that
21:20:52 <scshunt> ugh, fffffff the entirely sensible thing that is the stage restriction :P
21:21:04 <edwardk> and you can apply it to a sparse vector indexed by coordinates, etc.
21:21:30 <ReinH> edwardk: the issue is that I'm using a "reachability matrix" that represents, e.g., where the walls are in a roguelike map: Vector (Vector Bool)
21:21:39 <lpaste> edwardk pasted “sequence algebras” at http://lpaste.net/92500
21:21:45 <ReinH> which I could use directly to calculate the path lengths
21:21:52 <edwardk> shachaf: ^-
21:22:06 <ReinH> but I convert it into Map Coord (Map Coord Weight) rather inefficiently and unnecessarily
21:22:11 <edwardk> shachaf: interesting that a sequence algebra forms a Choice
21:22:31 <edwardk> shachaf: its one of those cases where we have something that isn't obviously a DownStar but is Choice
21:23:39 <ReinH> if type Grid a = Vector (Vector a) then I probably want to just map onto reachable neighbors and get Grid (Set Coord) or such, since all edge weights are 1
21:24:43 <ReinH> I'm sure there are some other speedups I can get based on the uniform edge weights too
21:25:41 <edwardk> ReinH: if you used repa rather than linear you could probably use a stencil or something
21:25:55 <edwardk> but then you have two problems =P
21:26:11 <ReinH> edwardk: right, I'm about to try a repa version anyway :)
21:27:09 <chrisdone> haha, this is winrar
21:27:22 <chrisdone> stepping through haskell code with the chrome debugger
21:27:51 <ReinH> edwardk: I'm pretty sure this code is ripe with opportunities for speedups https://gist.github.com/anonymous/74e57a2d6aef0a95c331
21:28:08 <ReinH> edwardk: for instance I use a bounds check to calculate a vertex's edges (neighbors) when I don't need to
21:28:42 <ReinH> the entire transformation from grid to graph to shortest paths is inefficient and unnecessary :D
21:28:57 <ReinH> chrisdone: wait what?
21:29:38 <jfischoff> So I have this unification code that I wrote using a free monad. Its ugly, but it works.
21:29:49 <chrisdone> ReinH: i compiled from core->js as interpreted so the core contained breakpoints (which means source spans), so i'm able to generate a source map =]
21:29:59 <ReinH> chrisdone: that is insane :D
21:30:22 <jfischoff> I wish I knew how to write elegant code with a free monad, where I could tear it down top to bottom, but I can't see how to do that nicely
21:34:16 <chrisdone> ReinH: just uploading a video to demonstrate :3
21:35:11 <ReinH> chrisdone: cool :D
21:35:43 <shachaf> edwardk: Hmm, where did that type come from?
21:36:37 <shachaf> It's not Cofree of a functor (since x would be both negative and positive).
21:36:56 <edwardk> shachaf:  http://www.cse.chalmers.se/~bernardy/PP.pdf adapt the sequence algebra type into something Moore/explicit Fold like
21:37:26 <edwardk> also playing with the comonad for reducers
21:37:32 <edwardk> data Reducer b a = forall m. Reducer (m -> a) (b -> m) (m -> m -> m) m
21:40:20 <shachaf> Hmm, so it has an associativity law.
21:41:49 <shachaf> (But no identity laws? That's a bit odd here.)
21:42:07 <shachaf> Does it end up being different from a list of some sort?
21:44:40 <edwardk> shachaf: yeah the lack of identity laws is strange
21:44:50 <shachaf> OK, I guess this paper is just about efficiency.
21:45:14 <edwardk> shachaf: given the associativity if you had identity laws then this would be equivalent to a list.
21:45:15 <shachaf> So with the laws it should end up being a more efficient representation of the same thing?
21:45:21 <edwardk> yeah
21:46:11 <edwardk> it lets you fold binary trees without doing foo (Bin x a y) = x `mappend` cons a y  or snoc x a `mappend` y
21:46:36 <edwardk> you can 'factor' the reduction through a, which is often a much smaller subset of 'm' than you'd get with a monoid.
21:46:45 <edwardk> so you can get away with reasoning about fewer cases
21:47:01 <edwardk> and you may have ones where the result doesn't form a monoid
21:47:25 <edwardk> but i think to get there you'd need to abuse the lack of identity laws -- which i think are likely an oversight
21:47:41 <edwardk> with the identity laws you could finitely reassociate to get a flat list
21:47:53 <edwardk> it is used in practice to break up a document in tree shape
21:48:06 <edwardk> and fold together charts through some element
21:48:42 <edwardk> i've been able to come up with a form of fingertree that lets you turn one of these into a monoid (assuming the extra identities)
21:49:10 <shachaf> (I like how you've completely lost trust in GHC's inlining heuristics.)
21:49:24 <ReinH> edwardk: oh god, now I have to try to get gtk2hs running on OS X o_O
21:49:39 <edwardk> shachaf: =)
21:49:58 <shachaf> By the way, do we have Choice/Strong laws?
21:50:00 <edwardk> shachaf: one day i'll do enough research to restore my trust
21:50:14 <edwardk> i honestly don't remember
21:53:11 <fylwind> @pl f g = j . k g
21:53:11 <lambdabot> f = (j .) . k
21:53:19 <shachaf> So that type isn't Nu of anything. What is it?
21:55:18 <augur> shachaf: which type? :D
21:58:36 <shachaf> edwardk: How is this actually used?
21:58:51 <dolio> Are you talking about Reducer?
21:59:04 <shachaf> No, Seq
21:59:21 <dolio> I don't think I was around for that.
21:59:26 <shachaf> http://lpaste.net/92500
22:00:08 <dolio> Well, Seq b a is some sequence algebra on bs with carrier x, and a projection out into as.
22:00:19 <dolio> Presumably, at least.
22:01:08 <shachaf> I guess I should read the paper.
22:01:28 <dolio> What you do is use it to reduce a tree.
22:01:47 <dolio> Just like you use a reducer to reduce a tree.
22:02:00 <dolio> And project out the result at the end.
22:02:56 <Ghoul_> So, this was the best "array fudge product" thing I could come up with and it doesn't look very haskell-ey http://lpaste.net/8807641132704989184
22:03:09 <shachaf> I think I'm missing something.
22:03:10 <Ghoul_> What's the *proper* way of doing this?
22:03:45 <shachaf> You start out with just one x value. If you want to get another one, you have to call the function h x b x, right?
22:03:50 <shachaf> (Where x :: x, b :: b.)
22:04:01 <dolio> Yes.
22:04:56 <dolio> If you have a binary tree with bs at the nodes, you call h at each node, with the reduction of the two children, and at the leaves you use the x.
22:05:09 <dolio> And then you look at the a result of the whole tree to get your answer.
22:05:16 <edwardk> shachaf: not sure yet. =)
22:05:27 <ReinH> edwardk: huh, looks like vector is doing more fusion than I thought? How can I get some insight into how much it's actually able to fuse?
22:05:38 <dolio> I'm not sure why it quantifies over x instead of just having a be the carrier.
22:05:43 <edwardk> ReinH: by getting good at reading core
22:05:51 <ReinH> edwardk: `sigh
22:05:56 <dolio> Except it's covariant that way.
22:06:04 <dolio> Which is nice.
22:06:13 <edwardk> dolio: for compatibility with the other reducer-like structures i'm playing with
22:06:23 <edwardk> dolio: and because this way i can get a comonad, applicative, etc. for it
22:06:37 <dolio> I guess it's a lot like those foldl combinators.
22:06:40 <ReinH> edwardk: I am generating the adjacency matrix directly from the grid now and I am actually getting a good speedup
22:06:40 <edwardk> the comonad is kinda sexy
22:06:41 <edwardk> yep
22:06:58 <dolio> Where you want to map at the end, because covariance is nice.
22:07:09 <elliott> I bet there's a great non-existential form!!
22:07:20 <edwardk> dolio: turns out if you don't want to map you can 'keep it open' by extending the Seq b comonad
22:07:36 <edwardk> elliott: Sadly Moore loses pretty badly to the existential version
22:07:40 <shachaf> dolio: OK, I guess so.
22:07:44 <elliott> don't ruin my dream.
22:07:45 <edwardk> elliott: fmaps are expensive and you pay every step =(
22:07:58 <edwardk> elliott: i'm saddened by it, but i'm adapting and learning to dream new dreams ;)
22:08:12 <edwardk> Yoneda (Moore b) a   may be as efficient as Foldl b a
22:08:19 <Tekmo> Is your `Moore` implementation still recursive?
22:08:38 <elliott> edwardk: you should make Moore in machines existential, then.
22:08:42 <edwardk> Tekmo: i'm currently playing with other recursion schemes that are similarly non-recursive
22:08:53 <edwardk> in particular sequence algebras and monoidal reducers
22:09:00 <ReinH> edwardk: actually I spoke too soon :)
22:09:02 <edwardk> elliott: i'm planning on it =/
22:09:08 <edwardk> elliott: it makes me sad though
22:09:35 <shachaf> I like this Moore. It should at least exist somewhere.
22:09:42 <Tekmo> I really think the existential version of your `Mealy` would really be useful for some basic FRP
22:09:55 <shachaf> I still think this "Fold" might be more rightly called "Unfold".
22:10:12 <chrisdone> ReinH: http://www.youtube.com/watch?v=ABmRkWS3wIU
22:10:13 <Tekmo> So technically it can also be a scan
22:10:15 <Gracenotes> Is efficiency a fundamental property of the semantics or the quirkiness of GHC's implementation?
22:10:20 <Tekmo> It's totally agnostic of how the fields are actually used
22:10:27 <edwardk> shachaf: i'm looking at bundling up more of these into something, as i need the sequence algebras
22:10:32 <edwardk> and i need all the fiddly instances
22:10:44 <Gracenotes> to get more philosophical than is warranted
22:10:57 <edwardk> shachaf: i also want to play with the right folds in this sense and see if the comonad does what i wanted it to do order wise for the left folds
22:11:03 <Tekmo> Oh, I wanted to point out another thing.  I noticed that you use `INLINE` a lot in your code, but I've noticed a lot of cases where `INLINE` gives worse performance
22:11:12 <Tekmo> I came across this when optimizing `pipes`
22:11:32 <edwardk> since extending seems to partially apply the answers on the right now, and i want to partially apply it on the left.
22:11:42 <edwardk> that would be better for HMAC machinery
22:11:48 <ReinH> edwardk: lmao, my carefully rewritten grid to adjacency matrix code that avoids all the intermedia steps and does a single fold
22:11:57 <edwardk> and would let me use this in hash to add a bunch of HMACs
22:11:58 <ReinH> is not faster than the "inefficient" version
22:12:03 <shachaf> You're computing HMACs?
22:12:03 <ReinH> edwardk: I guess stream fusion is magic?
22:12:04 <edwardk> heh
22:12:15 <edwardk> ReinH: roman is better at optimization than most of us ;)
22:12:19 <ReinH> lmao
22:12:25 <ReinH> I'm just surprised at what it's able to fuse, I guess
22:12:40 <edwardk> shachaf: it is something i want to be able to do with this sort of thing. i loved that the comonadic folds let me 'resume' an HMAC
22:12:42 <Tekmo> ReinH: Are you inspecting core?
22:12:45 <lspq> Why will my program not run? http://pastebin.com/TwMqWw4B
22:12:49 <mauke> The paste TwMqWw4B has been copied to http://lpaste.net/92501
22:12:50 <ReinH> Tekmo: not yet
22:12:58 <ReinH> Tekmo: just trying to glean some information from benchmarks
22:13:02 <edwardk> shachaf: i thought that made for a gorgeous API
22:13:04 <Tekmo> ReinH: This is good practice when you optimize
22:13:10 <ReinH> similar to the way a fortune teller might try to read tea leaves, I suppose
22:13:13 <Tekmo> ReinH: It takes a lot of magic out of the process
22:13:14 <edwardk> shachaf: one combinator, everything else standard
22:13:30 <ReinH> Tekmo: I should do that.
22:13:58 <lspq> Anyone?
22:14:01 <Tekmo> ReinH: Usually when I optimize the first two things I do are inspect the list of rules that fired and then search for the loop breaker in the core
22:14:22 <enthropy> lspq: you're missing a package from hackage most likely
22:14:24 <Tekmo> ReinH: You don't necessarily need to understand exactly what the inner loop does, but just sort of remember what it looked like
22:14:51 <enthropy> lspq: if you have the haskell-platform you can probably  cabal install arithmoi
22:14:52 <lspq> enthropy: how would I install it on linux/debian
22:14:55 <Tekmo> ReinH: Then as you try different alternatives you will notice patterns in certain loops and you will start to figure out what works well and what does not
22:15:13 <lspq> enthropy: command not found
22:15:28 <Ghoul_> Tekmo: have you solved euler 11 in haskell?
22:15:53 <Tekmo> Ghoul_: Yes
22:15:59 <levi> ReinH: There are a bunch of interesting papers and stuff on fusion properties of recursion combinators and calculating programs with them.
22:16:00 <Tekmo> I just did a brute force search
22:16:04 <Ghoul_> monolithic boilerplate :(
22:16:58 <Tekmo> I did these problems over 2 years ago, so I don't remember exactly what my code looked like
22:17:02 <levi> Though stream fusion is a bit of a different beast, it relies on the same sort of algebraic simplification, as far as I understand it.
22:17:24 <Tekmo> Yes, stream fusion is the same basic idea
22:17:28 <ReinH> Tekmo: cool :)
22:17:30 <enthropy> lspq: then install it
22:17:32 <Tekmo> If you take out the recursion, GHC goes to town on it
22:17:33 <Ghoul_> Anyway, gotta go have lunch because I got so preoccupied doing eulers I forgot to. bye
22:17:40 <enthropy> lspq: with apt-get or something
22:17:43 <Tekmo> that's like the #1 trick for high-performance Haskell code: get rid of recursion
22:17:53 <lspq> enthropy: yep installing now
22:17:56 <Tekmo> GHC optimizes non-recursive code like a beast
22:18:09 <joelteon> isn't map recursive
22:18:12 <Tekmo> It is
22:18:13 <Ghoul_> I think the ddc flow stuff knows how to handle recursion
22:18:17 <joelteon> It seems like it would be difficult to avoid
22:18:19 <joelteon> it
22:18:21 <Tekmo> The only reason it performs well is because of rewrite rule tricks
22:18:56 <joelteon> how do you avoid recursion, then?
22:19:10 <Tekmo> You apply the recursion at the last moment
22:19:12 * jfischoff just realized unification-fd is based off of a free monad ...
22:19:14 <joelteon> the entire standard library is recursion
22:19:21 <Tekmo> the idea is that you split your algorithm into two components
22:19:26 <edwardk> jfischoff: yeah
22:19:28 <levi> Well, the 'rewrite rule tricks' are well-founded properties of folds.
22:19:31 <Sonarpulse> edwardk
22:19:39 <Tekmo> A non-recursive component (i.e. one step of the loop) and the recursive component
22:19:39 <Sonarpulse> got the three classes
22:19:39 <edwardk> jfischoff: i mentioned it to wren back when he released
22:19:52 <Tekmo> The non-recursive component is what you compose
22:19:53 <joelteon> I see
22:19:59 <edwardk> jfischoff: the code in ermine uses that notion directly
22:20:02 <Tekmo> And you apply the recursive part at the last moment
22:20:07 <Sonarpulse> well 3 new ones. Also notice that the module description for Serial is the same as the one for Put
22:20:13 <jfischoff> edwardk: oh cool, I should check that out
22:20:22 <edwardk> Sonarpulse: feel free to fix the descriptions
22:20:27 <edwardk> Sonarpulse: cut and paste error i guess
22:20:45 <joelteon> Tekmo: can you give an example?
22:20:51 <Sonarpulse> OK. I'll write something for that too
22:21:02 <Tekmo> joelteon: Stream fusion is the canonical exapmle
22:21:16 <Tekmo> You write your loop as a non-recursive generating function and a seed
22:21:32 <Tekmo> Then composing transformations composes those non-recursive elements
22:21:39 <jfischoff> edwardk: I'm looking for something light though, the "Bound" of unification so to speak
22:21:49 <Tekmo> Then when you actually begin streaming is when you begin applying recursion, repeatedly applying the generator
22:22:16 <Tekmo> joelteon: Another example is my `foldl` library, which is what Edward was talking about
22:22:21 <edwardk> jfischoff: i have a simplification to unification-fd lying around that moves the MPTCs into records
22:22:29 <Tekmo> joelteon: `foldl` encodes the `Fold` non-recursively by preserving the step function
22:22:32 <edwardk> jfischoff: not sure if its on github though
22:22:46 <Tekmo> joelteon: Composing `Fold`s is efficient because GHC is connecting those non-recursive steps
22:22:53 <Tekmo> joelteon: Then when you run the fold is when the actual recursion occurs
22:22:55 <jfischoff> edwardk: oh the unification stuff?
22:23:20 <joelteon> ok, I'm gonna have to look at it
22:23:24 <joelteon> I have no idea how stream fusion works
22:23:34 <levi> joelteon: To make a recursive function non-recursive, just give it a 'continuation' parameter. To apply it, you give it to a fixed-point combinator, which calls the function with itself as its continuation.
22:23:44 <Sonarpulse> edwardk: what width do you want module descriptions?
22:23:49 <joelteon> oh, neat
22:23:56 <joelteon> I already do that frequently
22:23:57 <Tekmo> Oh
22:24:04 <Tekmo> joelteon: Then let me give you a simpler example
22:24:04 <Sonarpulse> some go pass the -----------
22:24:09 <Tekmo> joelteon: Let's use `map` as the example
22:24:14 <joelteon> ok
22:24:14 <Tekmo> joelteon: So the ordinary `map` is recursive
22:24:18 <joelteon> right
22:24:24 <edwardk> jfischoff: https://github.com/ekmett/unification knock yourself out
22:24:29 <Tekmo> joelteon: But let's say that you just stored the function you want to map in a data type:
22:24:37 <edwardk> Sonarpulse: if you can't think of anything to say leave them blank
22:24:41 <Tekmo> data Map a b = Map (a -> b)
22:24:50 <jfischoff> edwardk: rock!
22:25:03 <Sonarpulse> I think I have something good
22:25:09 <Tekmo> joelteon: If you preserve the original function that you intended to map, you can connect those functions really easy:
22:25:24 <Tekmo> joelteon: You just compose that raw funcitons
22:25:30 * jfischoff giggles with excitement
22:25:32 <edwardk> jfischoff: the ermine version uses a pre-tied monad rather than free monad, and just does substitution directly on it, using a prism to identify the return constructors
22:25:32 <Tekmo> (Map f) . (Map g) = Map (f . g)
22:25:35 <joelteon> ok
22:25:47 <Tekmo> Then you could `run` the map to get things going:
22:25:52 <Tekmo> run :: Map a b -> [a] -> [b]
22:26:07 <jfischoff> edwardk: yeah this is good place for me to start than :)
22:26:14 <Tekmo> joelteon: Obviously this example is gratuitous since you don't need the `Map` data type
22:26:20 <Tekmo> joelteon: What we just did is the equivalent of stream fusion
22:26:28 <joelteon> oh
22:26:29 <Tekmo> joelteon: We turned multiple passes over the list into a single pass
22:26:38 <Tekmo> map f . map g = map (f . g)
22:26:50 <joelteon> oh
22:26:54 <joelteon> that's stream fusion?
22:27:01 <Tekmo> Stream fusion is more complicated
22:27:04 <Tekmo> but it's the same basic idea
22:27:14 <shachaf> CoYoneda is the way to do fmap fusion!
22:27:14 <edwardk> jfischoff: i don't recall the state of that code
22:27:14 <edwardk> jfischoff: i just remembered i had it lying around from forever ago
22:27:19 <edwardk> shachaf++
22:27:29 <Tekmo> Stream fusion lets you store more sophisticated things than just maps
22:27:38 <Tekmo> joelteon: For example, you can do filters or concatMaps
22:27:39 <edwardk> yoneda is fmap fusion, codensity is bind fusion.
22:27:59 <shachaf> You can make a "difference category" for (.) fusion.
22:28:30 <jfischoff> edwardk: I have faith
22:28:34 <shachaf> I don't know whether you can derive Codensity from applying it to Kleisli...
22:29:04 <Tekmo> The important part is that the more non-recursive information you preserve, the more material you give ghc to optimize with
22:29:18 <Tekmo> GHC gets lots the moment you tell it to optimize a loop
22:29:20 <Tekmo> *lost
22:29:55 <joelteon> ok
22:30:18 <Tekmo> The rough reason why is because `ghc`'s trick for optimizing a loop is to pick an arbitrary funciton in that loop and set it to be the loop breaker
22:30:28 <Tekmo> Then it tries to tighten everything else in the loop except the loop breaker
22:30:42 <Tekmo> Unfortunately, it has to get pretty lucky to pick the right loop breaker and get a really good loop tightening
22:30:46 <Tekmo> Most of the time it doesn't
22:35:57 <jfischoff> edwardk: that code is perfect for where I am at… now to find the time :)
22:38:58 <levi> joelteon: http://metagraph.org/papers/stream_fusion.pdf
22:39:01 <shachaf> I guess (forall r. k b r -> k a r) is generally better than (forall r. k r a -> k r b)?
22:40:09 <Sonarpulse> edwardk: what about making SerialHost a synnonym for either SerialBE or SerialLE
22:40:11 <Sonarpulse> with CPP
22:40:26 <Sonarpulse> and likewise with (de)serializeHost
22:45:16 <shachaf> What do you call something like that? (forall r. k b r -> k a r)?
22:47:11 <shachaf> Is that the Yoneda embedding?
22:51:31 <Kelet> Hello,
22:51:52 <thr33strikes> :q
22:51:56 <augur_> shachaf: surely not
22:52:18 <spaceships> what can the Dual Monoid instance be used for?
22:52:28 <shachaf> Reversing things.
22:52:44 <augur_> the yoneda embedding is more or less (.)
22:52:55 <notdan> Does anybody know if the FP Afternoon (talks at Zurihac) were recorded?
22:53:01 <Kelet> Referential transparency means that you can replace an expression with it's value and the meaning does not change. This implies that with a referentially transparent function, for all x, f(x) = f(y) if x = y correct?
22:53:08 <augur_> oh hello Kelet
22:53:12 <edwardk> Sonarpulse: i'd rather keep it separate
22:53:18 <augur_> we've been over this already Kelet
22:53:33 <edwardk> Sonarpulse: makes it kinda brittle and makes it do magic things to alias it
22:53:54 <arkeet> Kelet: what do you mean by = ?
22:53:58 <augur_> Kelet: referential transparency is a property of program contexts, not functions
22:54:12 <augur_> the property you just gave is merely that f respects =
22:54:23 <Sonarpulse> alright
22:54:29 <ReinH> edwardk: threadscope segfaults :( sad panda
22:54:30 <Sonarpulse> then I am ready to push
22:55:18 <[JJ]Albert> So, Haskell as a first language... How is that?
22:55:26 <augur> [JJ]Albert: a good idea!
22:55:34 * [JJ]Albert has a heart attack
22:56:15 <[JJ]Albert> I wasn't expecting such a quick reply. Will it sadden you to hear that I was put up to it?
22:56:38 <shachaf> [JJ]Albert: Please don't troll, even by proxy.
22:56:42 <[JJ]Albert> Not hating on Haskell here.
22:56:49 <[JJ]Albert> Yeah, sorry.
22:57:19 <[JJ]Albert> I'll be on my way. Sorry for any implied rudeness. Go, Haskell.
22:57:58 <Kelet> augur, Can you explain further I don't quite understand. Is a function not a context in a program?
22:58:07 <augur> Kelet: no, a function is a term.
22:58:08 <ReinH> [JJ]Albert: or stay around and learn some haskell :)
22:58:18 <Kelet> but a function has a context?
22:58:24 <[JJ]Albert> Ho boy, um, yes...
22:58:33 <augur> Kelet: a context is just a program, with a part of it plucked out
22:58:38 <Kelet> what part
22:58:46 <augur> Kelet: any part you like
22:59:03 <augur> thats just what a context is -- a program with a part plucked out
22:59:34 <Sonarpulse> edwardk: does a CPP default instance for SerialHost avoid enough brittleness?
22:59:47 <augur> Kelet: usually you want to do this at the level of ASTs so that you can say "part" in a coherent way
23:00:14 <ReinH> [JJ]Albert: Haskell is not scary :) Try this http://learnyouahaskell.com/
23:01:14 <[JJ]Albert> Well to be fairly honest, it would be more like my 1.5th language. If I planned on taking it now, which to be honest, I'm only looking at it now as a friend of mine is a Haskell user.
23:01:31 <[JJ]Albert> But nothing against Haskell, again, I'm interested.
23:01:49 <ReinH> [JJ]Albert: you can dabble in as many languages as you like :)
23:01:53 <edwardk> Sonarpulse: i'd really rather it be its own thing. that way if we ever have to run on a VAX, we can, and we don't have to have users worry about not being able to supply an instance on one platform or another
23:02:05 <ReinH> [JJ]Albert: you might find this interesting http://pragprog.com/book/btlang/seven-languages-in-seven-weeks
23:02:20 <jxv> ReinH, I'm the friend.
23:02:25 <ReinH> jxv: hai :)
23:02:39 <edwardk> Sonarpulse: e.g. it might be really easy to supply a host order backend via Storable
23:02:58 <edwardk> but if the user also hand rolled a little endian backend, then they may or may not conflict
23:03:11 <edwardk> just strikes me as a bad compromise to save a few lines
23:03:20 <johnw> edwardk: hey!
23:03:23 <edwardk> heya johnw
23:03:28 <[JJ]Albert> So yes, jxv here is the very efficient guy. I'm a busy, slow person that is slowly taking on C of all things at the moment. Well, I'm on hiatus.
23:03:34 <johnw> edwardk: gotta a moment to join a G+ call about lens? :)
23:03:45 <edwardk> hah, give me a sec
23:03:49 <edwardk> but then sure
23:04:04 <johnw> k, just ping me
23:04:20 * hackagebot x509-system 1.4.1 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.1 (VincentHanquez)
23:04:23 <[JJ]Albert> I may be late to the party, but I'm interested in getting my programming back on track.
23:04:26 <Sonarpulse> err, I mean a default instance based on whatever the user defined for SerialBE and SerialLE
23:04:45 <ReinH> johnw: hi
23:04:50 <[JJ]Albert> After my hiatus. I have my studies at the moment and such.
23:04:53 <johnw> ReinH: hi!
23:05:03 <Sonarpulse> there are currently no default instance for SerialLE or SerialBE
23:05:13 <Sonarpulse> and Serial uses GSerial as before
23:05:38 <jkole> Does Haskell have if statements?
23:05:54 <edwardk> > if True then "yes" else "no"
23:05:55 <lambdabot>   "yes"
23:06:10 <edwardk> johnw: ready
23:06:14 <lispy> technically an if expression
23:06:20 <edwardk> true
23:06:26 <[JJ]Albert> Kinda the underdog of languages, Haskell. Yes?
23:06:42 <lispy> use `when` if you want a more statement like version
23:06:45 <lispy> :t when
23:06:45 <lambdabot> Monad m => Bool -> m () -> m ()
23:06:51 <ReinH> or bool
23:06:53 <ReinH> :t bool
23:06:54 <lambdabot> Not in scope: `bool'
23:06:54 <jkole> I heard Haskell helped save some children from a burning building.
23:06:55 <edwardk> [JJ]Albert: i might have said that 6 years ago, i think that isn't the case any more. bbiab
23:07:02 <johnw> edwardk: invite sent
23:07:03 <ReinH> :t Data.Bool.Extras.bool
23:07:04 <lambdabot> Couldn't find qualified module.
23:07:07 <ReinH> wah wah
23:07:26 <[JJ]Albert> edwardk: Well I'm saying this as a person whose scratching the surface of software development and language studies.
23:07:43 <ReinH> johnw: how can lambdabot not have as important an extension as Data.Bool.Extras? o_O
23:07:46 <ReinH> :p
23:07:48 <[JJ]Albert> So yeah, I'm a bit under-informed.
23:08:28 <[JJ]Albert> Again, sorry for my rudeness earlier. Was playing it off as if I'd wandered into a Scientology convention.
23:08:49 <[JJ]Albert> I didn't mean it as such.
23:09:10 <ReinH> [JJ]Albert: relax :)
23:09:20 <[JJ]Albert> I will someday.
23:09:59 <DaveS> Haskell is the language you want to use at work but can't for reasons out of your control
23:10:13 <[JJ]Albert> But yeah, I don't have Haskell on my plans list yet. My stupid, ill-written task list in need of rewriting.
23:10:26 <[JJ]Albert> *plans list
23:10:43 <[JJ]Albert> But my friend has me interested.
23:11:52 <levi> [JJ]Albert: You should put Haskell on your plans list, especially if your plans list includes other programming language related items.
23:12:04 <[JJ]Albert> levi: Certainly.
23:12:23 <[JJ]Albert> I have a multitude of interests, and programming is key to getting there.
23:12:42 <levi> You will simultaneously learn a lot about programming languages in general and learn a very practical language for doing cool stuff.
23:12:45 <[JJ]Albert> And Haskell sounds like just the thing I'll want when I'm confident enough.
23:13:17 <DaveS> Don't worry about being confident. Approach it like any other language
23:13:24 <levi> Well, it's also a good place to start building confidence, as you won't have to un-learn other things later.
23:13:27 <[JJ]Albert> Hmm, y'know, you are right.
23:13:55 <DaveS> You are better off not knowing other programming idioms when learning haskell
23:16:59 <[JJ]Albert> DaveS, Y'know, moments ago I was fighting off anxiety, and now, maybe it's time I did bite big. I'm getting Learn You Haskell For a Great Good.
23:17:47 <shachaf> «quasiquotation memes»? I get some unusual referers.
23:18:43 <levi> [JJ]Albert: Dive in! Write code! Ask questions about the errors you get! ;)
23:19:15 <[JJ]Albert> Alrighty then.
23:19:27 <[JJ]Albert> I'll be adding #haskell to my quickload list.
23:20:31 <levi> For you will get many. And it may take frustratingly long to get your programs to type-check. But you'll get the hang of it, and then you'll find that a lot of anxiety in programming is *removed* by the type system.
23:21:02 <[JJ]Albert> yes, I get what you mean.
23:21:54 <levi> And don't worry about conversation here that goes over your head. Things get pretty 'lofty' sometimes, but there are always people willing to help with beginner questions as well.
23:22:28 <[JJ]Albert> Well I won't worry too much, I'll just ask my questions when I can.
23:23:02 <levi> You can get by pretty well without knowing all the 'deeper' stuff, which is primarily useful when designing new libraries or just investigating new ways of doing things.
23:24:15 <startling> listening to the lofty questions that I didn't quite understand has helped me learn a lot, for what that's worth.
23:24:17 <[JJ]Albert> levi: Sounds about right.
23:24:41 <[JJ]Albert> Say, how is the field of robotics and haskell? As a bit off-topic sure, but curious.
23:24:48 <levi> Oh yeah, it's a great way to learn interesting things.
23:25:26 <[JJ]Albert> It was a thought that came to mind. It's probably not too large, I mean, open source robotics itself is a small category for the time being.
23:25:39 <levi> Well, haskell is not used directly in robots very often, but it could be used *indirectly* to great effect.
23:25:55 <[JJ]Albert> Hmm, yes I get what you mean.
23:26:09 <arkeet> ajhc is a haskell compiler that targets embedded stuff like arm :-)
23:26:39 <_emm_> there is something that has been puzzling me yesterday
23:27:05 <_emm_> if you lift fromMaybe to the IO monad, it seems to evaluate the default argument first
23:27:14 <_emm_> which is rather inconvenient
23:27:24 <arkeet> that's to be expected.
23:27:28 <arkeet> :t liftM2
23:27:29 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:27:34 <arkeet> doesn't magically make anything short-circuit.
23:27:59 <arkeet> @src liftM2
23:27:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:28:05 <_emm_> I see
23:28:08 <arkeet> notice how it runs m1 and m2, no matter what.
23:28:11 <_emm_> yeah, obviously
23:28:11 <arkeet> incidentally,
23:28:12 <arkeet> :t liftA2
23:28:13 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:28:22 <arkeet> this is the Applicative version that does the same thing.
23:28:30 <arkeet> the point is that it exists.
23:28:33 <levi> GHC's runtime is not very well-suited for real-time applications, but Haskell itself is a great platform for building trying out algorithms that you'll later translate to a lower-level language. You can even write domain-specific languages in Haskell that emit code or data for your robot to use.
23:28:45 <arkeet> and when restricted to Applicative operations, execution of actions cannot depend on values.
23:29:02 <levi> That sentence got mangled. :/
23:29:06 <_emm_> isn't that equivalent to f <$> a <*> b anyway? I didn't even know you had liftA* equivalents of liftM
23:29:09 <arkeet> so it can't decide whether or not to run something based on whether another action results in Nothing.
23:29:14 <startling> _emm_: yep.
23:29:14 <arkeet> it is.
23:29:15 <_emm_> sure
23:29:16 <[JJ]Albert> Hmm, yes, this is pretty interesting I must say.
23:29:30 <arkeet> I tend to prefer using liftA2 over those operators.
23:29:37 <_emm_> really?
23:29:45 <arkeet> they're easier to partially apply.
23:29:49 <[JJ]Albert> So yes, I'll be seeing you around then.
23:29:54 <startling> _emm_: you can do "flip maybe <$> whatever <*> yuck"
23:30:04 <_emm_> I like the operators, because they look like normal function applications
23:30:05 <[JJ]Albert> I have a PDF of that book now. I'm going to start programming, and such.
23:30:15 <arkeet> liftA2 f a b
23:30:21 <arkeet> (liftA2 f) a b
23:30:22 <levi> [JJ]Albert: Have fun!
23:30:23 <arkeet> looks pretty clean.
23:30:40 <[JJ]Albert> levi: Thanks.
23:30:52 <[JJ]Albert> Also, jxv, you passed out there?
23:31:10 <jxv> looking at elm
23:31:19 <[JJ]Albert> Ah yes, you told me. Sorry.
23:31:32 <_emm_> but I see the point about partial application
23:31:52 <_emm_> or if you need to, say, lift something over a collection
23:32:06 <_emm_> just wouldn't be my first choice
23:32:13 <startling> oh, I think I misunderstood your question. Yeah, you need Monad for short-circuiting behavior, but there's no reason you can't flip a function to change /order/.
23:33:07 <_emm_> startling:  well. I don't want to change the order of the application, I don't want to evaluate the default unless it's needed
23:33:27 <startling> _emm_: right. you can write it out pretty easily with do notation.
23:33:40 <arkeet> :t maybe
23:33:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:33:42 <arkeet> er
23:33:44 <startling> I think there's a thing somewhere but I forget where.
23:33:46 <arkeet> :t fromMaybe
23:33:46 <lambdabot> a -> Maybe a -> a
23:34:12 <arkeet> :t \a m -> m >>= maybe a return
23:34:13 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
23:34:13 <_emm_> startling: I'm building a program which goes "look into the config file, if not present prompt the user", and obviously it doesn't work if you prompt the user all the time
23:34:47 <_emm_> startling: but yes, I built a "fromMaybeM" equivalent by hand instead
23:35:03 <_emm_> startling: this part wasn't a problem
23:35:07 <startling> _emm_: yeah, that's the way to go.
23:35:26 <startling> _emm_: the thing about IO is that it's strictly sequence (normally)
23:35:34 <startling> *sequenced, sorry
23:35:39 <arkeet> don't confuse evaluation with execution.
23:35:55 <startling> arkeet: am I confusing evaluation with execution?
23:36:02 <_emm_> startling: I understand how lifting would screw up fromMaybe's semantics
23:36:06 <arkeet> I never said that
23:36:13 <shachaf> startling: Nope. Keep it up!
23:36:21 <startling> shachaf: <3
23:36:57 <arkeet> hm, I wonder if you could make some awful short-circuiting lift using unsafePerformIO or something and stuff.
23:37:25 <startling> _emm_, it's not really that. it's that for a >>= b in IO, a gets executed and then b gets executed, regardless of whether b is "const something" or whatever.
23:37:36 <startling> arkeet: unsafeInterleaveIO? I think so.
23:37:45 <arkeet> maybe.
23:37:51 <arkeet> don't do it.
23:37:57 <startling> definitely not.
23:38:13 <_emm_> startling: sure, I get that
23:38:32 <startling> it's possible for a Monad to behave lazily in this way, just not for IO to.
23:39:24 <_emm_> startling: I see what you mean
23:40:27 <_emm_> startling: but yes, it's the side effect I'm interested in - if my default was, say, a pure computation without seq, that'd still be lazy, yes?
23:41:06 <arkeet> seq doesn't really matter.
23:41:20 <arkeet> :t fmap . fromMaybe
23:41:21 <lambdabot> Functor f => b -> f (Maybe b) -> f b
23:41:28 <startling> _emm_: yep.
23:41:30 <arkeet> and then you end up with just that.
23:44:32 <_emm_> I was proud of my one-liner :)
23:54:20 <enthropy> -XConstraintKinds doesn't let you invent type variables it seems
23:54:34 <_emm_> thinking about it, there is one thing I'd like advice about: error handling
23:54:53 <_emm_> so usually I go with Maybe/Either/EitherT
23:55:01 <_emm_> and avoid exceptions
23:55:02 <enthropy> is there way to fake something like    type Ty (a,b,c) useful1 useful2 =  ( ... big mess ... )
23:56:12 <_emm_> but then: it's a pain because
23:56:18 <_emm_> a)  you get unwieldly signatures that you then proceed to hide behind a type alias
23:56:56 <startling> _emm_: it's often more convenient to have a MonadError MyError m => m Whatever
23:57:35 <_emm_> b) I end with a global error type which has a flag for all possible error types and a message, which kind of breaks modularity
23:57:40 <startling> ErrorT and EitherT are both members of this class. ErrorT is sort of a one-trick pony, though, and EitherT works much more nicely.
23:57:41 <_emm_> "end up"
23:58:40 <zomg> What about MEitherT?
23:59:08 <startling> The "global error type" thing is often the best you can do; sometimes you can cheat and just use Strings + some other information, though.
