00:00:32 <dpwright> still, (.)<$><*> is a bit more involved than "<.>"... but I guess that's specific enough that a special operator isn't worth the effort?
00:00:54 <startling> I've never seen a use for (.) <$> ... <*> ...
00:01:10 <startling> :t (.) <$> ask <*> ask
00:01:11 <lambdabot> (Applicative f, MonadReader (c -> c) f) => f (c -> c)
00:01:28 <startling> :)
00:18:41 <ReinH> haasn: oh, Data.Semigroup.Foldable :D
00:18:45 <ReinH> haasn: lets me do this   end    = getMax . foldMap1 Max $ abs (p - p')
00:20:22 <haasn> oh uh
00:20:25 <haasn> maximumOf folded ?
00:20:55 <ReinH> :t maximumOf folded
00:20:56 <lambdabot> (Ord a, Foldable f) => f a -> Maybe a
00:21:01 <ReinH> Maybe :(
00:21:08 <ReinH> :t getMax . foldMap1 Max
00:21:09 <lambdabot> Not in scope: `getMax'
00:21:09 <lambdabot>     Not in scope: `foldMap1'
00:21:09 <lambdabot>     Perhaps you meant one of these:
00:21:14 <ReinH> ok fine
00:21:41 <ReinH> I can't get ala to work in this case though
00:22:13 <haasn> ala Max foldMap1
00:23:05 <ReinH> haasn: Could not deduce (Wrapped a a (Max a) (Max a))
00:23:10 <supki> you probably need to add an instance for Wrapped
00:23:11 <supki> yeah
00:23:27 <ReinH> Wrapped is just a newtype iso right?
00:23:38 <supki> it's a class
00:23:42 <haasn> no Wrapped instance :(
00:23:57 <haasn> well you can write that instance yourself where wrapped = iso Max getMax
00:24:02 <haasn> or use ‘au’
00:24:08 <ReinH> that's what I meant :)
00:30:56 <ReinH> haasn: oh, mimimumOf and maximumOf use tropical/arctic monoids under the hood (Control.Lens.Internal.Fold.Min) . Thus the Maybe. Cool.
00:31:59 <haasn> Uhm
00:32:00 <haasn> Tropical? Arctic?
00:33:43 <ReinH> min and max semigroup with +inf and -inf, respectively
00:33:54 <haasn> as represented by Nothing?
00:34:12 <ReinH> haasn: or Option if you want a sane monoid ;)
00:34:21 <haasn> Or that :)
00:34:29 <ReinH> internally Control.Lens uses its own data Min a = NoMin | Min a
00:34:31 <haasn> Weird names, though
00:34:44 <ReinH> haasn: Tropical because the inventor was from Brazil
00:34:46 <ReinH> not kidding
00:34:46 <haasn> Like, what does +inf/-inf have to do with trop-- oh
00:34:53 <ReinH> Arctic because it's the opposite of Tropical
00:34:58 <ReinH> stupid names are stupid :)
00:35:02 <arkeet> that's biased against antarctic =(
00:35:16 <arkeet> polar would be less biased
00:35:20 <ReinH> it's biased against referring to mathematicians from Brazil by name :p
00:35:26 <arkeet> eh
00:35:36 <haasn> trop++ # just making sure shachaf is happy
00:35:44 <ReinH> heh
00:37:23 <ReinH> haasn: how do I use firstOf correctly? firstOf ??? [Just 1, Nothing] --> Just 1
00:37:42 <arkeet> put a lens in ???
00:37:44 <haasn> firstOf (folded._Just)
00:37:46 <arkeet> well, a fold
00:37:52 <arkeet> right.
00:37:53 <ReinH> fistOf traversed [Just 1] gives me Just (Just 1)
00:38:04 <arkeet> right, because traversed targets the elements of the list.
00:38:09 <arkeet> not the things inside Justs
00:38:28 <arkeet> > firstOf folded [Nothing, Just 1]
00:38:29 <lambdabot>   Just Nothing
00:38:32 <ReinH> er, shouldn't firstOf be targetting the elements of the list?
00:38:34 <arkeet> > firstOf (folded._Just) [Nothing, Just 1]
00:38:36 <lambdabot>   Just 1
00:38:38 <ReinH> ah
00:38:43 <arkeet> it targets the elements of the fold you give it.
00:38:45 <haasn> > head [Nothing, Just 1]
00:38:46 <lambdabot>   Nothing
00:38:55 <haasn> -- firstOf = headOf, basically
00:39:04 <arkeet> indeed.
00:39:07 <arkeet> except it returns a Maybe.
00:39:13 <arkeet> in order to be total.
00:39:31 <ReinH> gotcha
00:40:16 <ReinH> I thought they were more like First and Last
00:40:22 <ReinH> but that makes sense
00:40:32 <arkeet> > firstOf (folded._Just) []
00:40:34 <lambdabot>   Nothing
00:41:13 <arkeet> well, it sort of is.
00:41:17 <haasn> > [Nothing, Just 1] ^? indexing (folded._Just).index 0
00:41:19 <lambdabot>   Couldn't match type `GHC.Types.Int'
00:41:19 <lambdabot>                with `p0 a1 (Control.Len...
00:41:25 <haasn> works here =/
00:42:36 <arkeet> lambdabot is on some git version of lens.
00:42:41 <arkeet> maybe something changed.
00:43:21 <haasn> ReinH: getFirst $ [Just 2, Nothing, Just 1]^.folded.wrapped -- if you want First behavior
00:43:26 <haasn> or uh.. assuming that Wrapped instance exists
00:43:35 <haasn> arkeet: I'm on git from a few days ago, let me try updating..
00:43:53 <arkeet> maybe yours is too new, then.
00:43:56 <arkeet> I dunno.
00:43:56 <haasn> Most likely
00:44:01 <haasn> :t Control.Lens.indexing
00:44:01 <lambdabot> Indexable Int p => ((a -> Control.Lens.Internal.Indexed.Indexing f b) -> s -> Control.Lens.Internal.Indexed.Indexing f t) -> p a (f b) -> s -> f t
00:44:07 <arkeet> :t Control.Lens.index
00:44:08 <lambdabot> (Eq i, Applicative f, Indexable i p) => i -> Overloading' p (Indexed i) f a a
00:45:41 <arkeet> oh duh.
00:45:42 <arkeet> :t index
00:45:43 <lambdabot> Ix a => (a, a) -> a -> Int
00:45:59 <arkeet> > [Nothing, Just 1] ^? indexing (folded._Just).Control.Lens.index 0
00:46:00 <lambdabot>   Not in scope: `Control.Lens.index'
00:46:00 <lambdabot>  Perhaps you meant one of these:
00:46:00 <lambdabot>    `Con...
00:46:03 <arkeet> eh.
00:46:10 <haasn> oh boy
00:46:54 <arkeet> > [Nothing, Just 1] ^? indexing (folded._Just).Lens.index 0
00:46:55 <lambdabot>   Just 1
00:47:38 * haasn votes we kick this useless ‘Data.Array’ thing out of lambdabot and import Control.Lens.index instead
00:47:49 <arkeet> lol
00:49:04 <ReinH> heh
01:08:31 <mgsloan> @tell ta479 chrisdone tried GHC --> emscripten years ago.  He says "compiling the generated llvm works. but you still need a runtime; good luck getting the ghc runtime to compile with llvm"
01:08:31 <lambdabot> Consider it noted.
01:19:57 <startling> Is there ean error thing somewhere that lets you do stack-trace-type-things? I want to have 'describe "while doing x" $ throwError "oops"' -> Encountered an error while doing x: "oops"
01:20:29 <startling> (This should nest)
01:27:18 <arkeet> @where rts-xc
01:27:18 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
01:27:28 <arkeet> startling: does this help? ↑
01:28:08 <startling> arkeet, oh, that's not quite what I mean.
01:28:23 <arkeet> oh.
01:28:25 <arkeet> I think I get what you mean.
01:28:37 <arkeet> I dunno.
01:28:50 <arkeet> there's probably a monad transformer for that.
01:29:04 <startling> I'm not debugging Haskell. I'm writing a thing for displaying errors.
01:29:09 <arkeet> (that should be haskell's slogan.)
01:29:14 <arkeet> I understand now yeah.
01:29:16 <startling> arkeet: right, I guessed so, but I don't see one anywhere.
01:29:38 <arkeet> I mean just a thing that turns it into: throwError "while doing x: oops"
01:30:08 <startling> oh, I can do it just with MonadError can't I.
01:30:13 <arkeet> can you
01:33:00 <startling> :t \s -> flip catchError (throwError . (:) s)
01:33:01 <lambdabot> MonadError [a1] m => a1 -> m a -> m a
01:48:13 <SrPx> "This was not brought up in the blog, but Haskell is out of the picture for any application where performance really matters."
01:48:18 <mangaba_leitosa> shachaf: thanks for the preview hit, it worked. I said 'it gives error' without specifying which error because I assumed that it was expected behaviour :-0
01:48:19 * SrPx sighs
01:48:37 <SrPx> it is always **that** same argument. cmon guys do something already.
01:49:25 <haasn> @hoogle (a -> Maybe a) -> a -> [a]
01:49:25 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
01:49:25 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:49:25 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:50:11 <mangaba_leitosa> shachaf: now, if I add multiple constructors with fields, it works as expected with set/preview. But as soon as I add a new constructor without fields, makeLenses "gives an error" :-)
01:52:41 <startling> SrPx: what's that from?
01:53:34 <SrPx> just some random comment in a reddit thread, but it is always the same argument. always. everywhere. like a plague
01:54:00 <startling> SrPx: I think it's something every language that's not C, C++, or Java has to deal with.
01:54:11 <SrPx> I'm not sure if you guys even **wish** haskell was more popular, but I'm pretty sure it could be way faster than c++ with some work on the compiler
01:54:14 <ibotty> java has it as well
01:54:31 <SrPx> startling: ghc is at least the same level as java as I see it, no?
01:54:32 <ibotty> haha SrPx. "some work"
01:54:45 <alpounet> SrPx, it's not that simple
01:54:50 <startling> ^
01:55:35 <SrPx> okay, some billions of money invested. lets make a kickstarter, i dont know ... i just read all that about the stalin compiler i was talking other day, and it is as fast as c for most cases, and it isn't even a static language. then there is mlton...
01:55:43 <alpounet> yeah sure
01:55:51 <alpounet> if you have 1 billion dollars, that's easier
01:56:47 <alpounet> but right now there are really just a few people working on GHC for money
01:56:55 <alpounet> for the others, it's just research or hobby
01:57:41 <startling> It seems like the kind of people who "care" about performance more often than not shouldn't care.
01:57:55 <SrPx> but for example, there are some thing I do **not** understand,  I admit, but: lists are much slower than vectors. why can't the optimizer just use vectors under the hoods for some situations? or, why is haskell not optimizing for constants? why isn't there a whole program compiler? etc~
01:58:06 <SrPx> startling: it is not about performance, it is about marketing.
01:58:30 <alpounet> SrPx, we have a vector library
01:58:34 <alpounet> parallèle arrays libraries
01:58:38 <alpounet> parallel*
01:58:41 <alpounet> etc
01:58:42 <quchen> SrPx: I don't think we're that interested in making GHC perform better. It's certainly desirable, but if there was some serious funding I doubt it would mean people work all day on getting it to "carefully written C speed".
01:58:49 <SrPx> alpounet: but why is that necessary? can't the optimizer just use vectors?
01:58:52 <startling> it's not that simple. lists let you do stream fusion.
01:58:59 <alpounet> SrPx, what if you really want a list?
01:59:11 <haasn> edwardk: collatz = preview $ failing (filtered even.to (`div` 2)) (to (*3).adding 1)
01:59:12 <SrPx> alpounet: what would be the difference?
01:59:27 <alpounet> SrPx, different data structure, different performances
01:59:33 <haasn> edwardk: it would be really nice if we could get a lower fixity on `failing` by the way, I always want to do f.g.h `failing` i.j.k -- but that doesn't parse
01:59:36 <alpounet> liste are useful for quite a few things
01:59:43 <SrPx> alpounet: so you'd want a list even knowing it would be slower for what you are doing?
01:59:45 <haasn> edwardk: and failing (f.g.h) (i.j.k) is simply ugly
02:00:00 <alpounet> SrPx, i don't want it when it's slower, generally :)
02:00:09 <ibotty> but it's not slower generally
02:00:18 <SrPx> most of the cases it is much slower, as far as I know?
02:00:19 <alpounet> but for example, lists can represent some kind of infinite stream of values
02:00:24 <ibotty> you know that there are linked lists in the linux kernel SrPx
02:00:31 <alpounet> in other languages, you'd have to do crazy things to make that possible
02:00:36 <alpounet> in Haskell you can just use [a]
02:02:06 <SrPx> startling: vectors too...?
02:02:48 <SrPx> also, quchen isn't having more people using haskell important right now, or what?
02:02:53 <alpounet> SrPx, also, little by little, we're also getting performance-related improvements in GHC
02:03:08 <alpounet> SIMD support is coming little by little
02:03:21 <alpounet> (we actually have a decent support in HEAD)
02:05:09 <SrPx> Hmm...
02:06:07 <SrPx> Yea maybe, but beating C in most benchmarks would be a ridiculous piece of adversing and I guess haskell really has the potential to do so very well
02:06:30 <SrPx> Sometimes I see it as if you don't actually want to be flooded with newcomers
02:07:14 <alpounet> SrPx, depends on the domain… 'cause the runtime system does quite a few things that are not done in a C program, and that's quite some additional cost depending on what your application does
02:07:35 <SrPx> alpounet: eg?
02:09:24 <alpounet> SrPx, in number crunching apps, the C code would pretty straightforwardly compile to an efficient machine code, and with SIMD etc when given the appropriate flags, whereas in Haskell you start with a non-strict language. ok, we have unboxed vectors and whatnot, but trust me, it's not easy at all to even catch up with C in performances
02:09:49 <alpounet> i've experienced this with math/AI programs, where i tried hard to get as close as possible to the C/C++ equivalents
02:10:42 <alpounet> the way the Haskell language is makes it a non-trivial task to compile it to an efficient machine code
02:11:11 <alpounet> in addition, you have an RTS that will have to open and evaluate thunks for all the values of your program, except the unboxed ones
02:11:59 <alpounet> it's quite efficient in general
02:12:13 <alpounet> but C is a pretty damn high bar
02:12:48 <SrPx> alpounet: hm well that all makes sense to me, fair enough. but with some tweak haskell could be much more optimizable, then, i guess. i wish some language took that path, of creating a fp-friendly language that is as optimizable as possible, taking advantage of optimizations c can't even dream of (for lack of side effects etc)~
02:13:28 <SrPx> that is what bugs me, I get. fp open doors for some behemoth optimizations but noone is actually exploiting that for high performance computing ?!
02:13:30 <alpounet> SrPx, that's kind of one of the directions in which the community (and some of its "leaders") is taking GHC/Haskell
02:13:52 <alpounet> but to get some intense work done on that, you need money
02:14:42 <SrPx> well so when I'm rich in an ideal universe I'm donating half of my money to you guys, ~
02:15:11 <alpounet> heh
02:15:42 <SrPx> alpounet: but could you point where those "leaders" (who are them) said that?
02:15:59 <SrPx> leaders you mean people working on GHC?
02:16:09 <alpounet> on GHC or core libraries
02:16:36 <SrPx> where can I read what they say?
02:16:41 <merijn> Am I the only one who thought of edwardk when I saw the "Edward C++ hands" article in Haskell Weekly news? ;)
02:16:50 <alpounet> merijn, nope, i did too at first
02:18:44 <merijn> SrPx: I fell into the conversation midway, so maybe this comment isn't relevant, but here goes anyway: If we're talking about numerical code, Haskell isn't particularly great, but some of my colleagues are working on a purely functional array language for numeric stuff and fairly naive code can frequently get close too, if not beat carefully hand optimised C with ASM inner-loops, etc.
02:18:50 <alpounet> SrPx, what kind of thing exactly do you want to read? explanations about how to write efficient haskell? code repositories with their projects? or some general speech about where GHC should go? if it's the latter, i don't think i have seen any, but that direction is taken just from all the key and efficient libraries written and the work done in GHC performance-wise. it's just some kind of momentum we have, well one of them anyway.
02:19:17 <alpounet> merijn, cool stuff! open source?
02:19:30 <merijn> SrPx: If you're interested in FP for high performance numeric stuff, it might worth looking into
02:19:35 <merijn> alpounet: no-ish
02:20:02 <merijn> alpounet: The compiler binary is available, but isn't open source, but if you ask you can probably get a copy of the source
02:20:32 <alpounet> merijn, there's a language spec freely available though I guess?
02:21:21 <merijn> alpounet: They had some issues with people copying development work and then publishing it, so they're kinda hesitant to open the entire thing up. However, if you're interested in working/looking at stuff there's no problem getting a copy. It's just that they wanna sorta keep track who has access to stuff
02:21:38 <alpounet> ok
02:21:46 <merijn> alpounet: Yeah, there's a language report with BNF and semantics, etc. most of the interesting stuff is of course in the form of optimisations
02:21:49 <alpounet> don't have time now, but I might ping you about this in a close future
02:22:20 <merijn> alpounet: http://www.sac-home.org/ feel free to ping if you wanna get in touch with any of 'em
02:23:38 <Jaxan> ah sac, i've heard of that. looked nice and simple
02:23:57 <merijn> SrPx: Essentially, what it boils down too is that FP has lots of potential for HPC, *but* the people working on Haskell are not very focussed on HPC and more on language design/abstraction power. There certainly are lot of other people working on high-performance FP, though
02:24:11 <SrPx> merijn: what is it?
02:24:37 <SrPx> oh ok nvm
02:25:31 <merijn> Jaxan: I find the syntax a bit too C-ish, but then again that's how they trying to sell/trick C people into using it. The underlying functional stuff is pretty neat, though :)
02:26:07 <alpounet> merijn, i know of a company working on some kind of C with dependent typing, with HPC in mind too
02:26:21 <Jaxan> merijn: that's the fun, you write C code, but silently it is functional :)
02:26:38 <alpounet> for once :p
02:26:40 <merijn> alpounet: That's called C++ ;)
02:27:26 <merijn> alpounet: The difference though is that this is really far from C, it has proper multidimensional arrays, GC and as I said pure (using uniqueness types for IO)
02:27:36 <alpounet> merijn, haha - take the objects and templates out, and yeah that's something vaguely like it. but I do mean some kind of dependent typing, not what C++ has
02:28:16 <bearclaw> SrPx: http://benchmarksgame.alioth.debian.org/
02:28:36 <merijn> alpounet: C99 had minimal dependent types support, but it got made optional in C11 :p
02:29:07 <companion_cube> dependent typing in C?!
02:29:09 <alpounet> really minimal then i guess haha
02:31:04 <SrPx> (reading the paper brb)
02:31:24 <merijn> companion_cube: Yeah, but I don't think any compilers implemented that part of the spec, which is also why C11 made it optional. It was too hard to implement
02:32:33 <quchen> SrPx: Sure it is, but I don't think performance should be Haskell's (GHC's) main selling point. It's a tad annoying that people always think in terms of performance. Python is "slow" and powers some of the biggest websites around. People should stop acting like they're protein folding as part of their daily programming routine.
02:32:54 <aleator> I recall there was some semi-standard infinite list type. Which one is preferred nowadays?
02:33:26 <quchen> SrPx: On the other hand, telling people how cool it feels to write 100 lines of code, compiling it, and once the type errors are fixed the program does what it should (and only that) - which happens quite often with Haskell - is like explaining colour to a blind person
02:33:35 <quchen> But *that* is what makes Haskell cool
02:34:16 <quchen> What makes Haskell awesome is often hard to sell :-(
02:35:12 <ibotty> can someone tell me what dropWhileEnd is supposed to do?
02:35:21 <aleator> quchen: My personal biggest difficulty as Haskell salesman are the . and $ operators. I can't believe how much difficulties beginners have with these.
02:36:14 <ibotty> i don't get it:
02:36:15 <ibotty> T.dropWhileEnd (== '.') ".abc" == ".abc"
02:36:15 <ibotty>  T.dropWhileEnd (== '.') "a.abc" == "a.abc
02:36:19 <alpounet> aleator, yeah and "practical people" really see "." as "bah, it's like that shitty composition operator in math we saw in school"
02:36:53 <merijn> companion_cube: I just looked it up, it takes the following form: sizeof of an array returns the size of that array, but the size of an array may be a runtime value which means you need a runtime value to determine the type of said array for sizeof
02:37:00 <aleator> alpounet: Like our main CS1/2 teacher: "But is is always more clear to use parentheses instead"/"Why does it look different from c anyways?"
02:37:03 * alpounet has had to sell Haskell to a programming user group, by doing a talk about it to a 100% non-haskell audience
02:37:21 <quchen> aleator: "But you can use curly braces and semicolons in Haskell as well!" ;-)
02:37:24 <companion_cube> merijn: oh, the dark corners of arrays... I almost only use pointers instead
02:37:29 <ibotty> oh. i kind of get it now. it is a `dropWhileR`, i.e. from the right
02:38:15 <bartavelle> alpounet, did it work ?
02:38:18 <merijn> companion_cube: i.e. "char myArray[10];" gives "sizeof myArray == 10", however if you have "int foo(int i) { char myArray[i]; return (sizeof myArray); }", here the return value of foo depends on the (dependent) type of myArray
02:38:19 <SrPx> quchen: it is not about being the main selling point. It is about: "see that 2 liner quicksort" (person is automatically impressed) (two days later person comes back to you: so I talked to the professor and he said haskell is a shit because it is too slow and c++ is the language of the gods)
02:38:24 <SrPx> (this actually happened)
02:38:32 <quchen> aleator: Selling languages is frustrating so I stopped doing it. I recommend enthusiastically, and then that's it.
02:38:34 <SrPx> (and with small variations, several times with different people)
02:38:34 <merijn> companion_cube: In practice I don't think anyone implement this optional feature
02:39:10 <aleator> quchen: I'm earning my pay in part as university teacher. No sale, no credits, no funds ;/
02:39:37 <quchen> aleator: Tenure means you can *force* people to use Haskell :-D
02:40:02 <aleator> quchen: Only after FP is made non-elective subject..
02:40:10 <SrPx> quchen: so it is more about, it is too easy to sell haskell already. but people won't leave the C world mindset, the inercia is too big. now if we got much faster than C benchmarks... and combine that with some parallelization talk... and a good ide... and pa, the world is suddenly using haskell
02:40:15 <alpounet> bartavelle, decently, a few of them learned some bits of haskell the night after and the following days, and 4 or 5 of them actually are decent at writing Haskell now (i think there was something like 15 people there - yeah programming isn't exactly popular in my city)
02:40:26 <companion_cube> merijn: sounds terrible anyway
02:40:35 <aleator> BTW. Is there an explicit 'finite list' data type?
02:40:37 <merijn> companion_cube: Terribly cool you mean? ;)
02:40:42 <companion_cube> not.
02:41:19 <merijn> companion_cube: All of C is terrible, witness mauke's beautiful program: http://mauke.hopto.org/stuff/c/sizeof.c :)
02:41:24 <quchen> aleator: No, there are no finite lists. You can make them using smart constructors though.
02:41:27 <merijn> companion_cube: Try and figure out what that prints without running
02:42:18 <quchen> aleator: The problem here is that a list always consists of cons cells, and a cons cell doesn't know about what came "before", so it cannot decide whether the next element has to be [].
02:42:26 <ibotty> merijn: you can write obfuscated code in haskell as well. the difference is that it's more acceptable in C
02:42:36 <companion_cube> prints the ascii number of 'e'
02:42:42 <ibotty> (and easier not to)
02:42:57 <companion_cube> hmmm, wait, not sure about the sizeof 0 actually
02:43:17 <companion_cube> depends on the architecture anyway
02:43:28 <merijn> companion_cube: Nope
02:43:35 <quchen> What does sizeof(0) do? Seems pretty heavily compiler-dependent
02:43:36 <companion_cube> so what does it do? :)
02:43:38 <merijn> companion_cube: The result is 1 on any architecture :)
02:43:50 <merijn> quchen: You fell in the devious trap
02:43:52 <companion_cube> merijn: now you have to explain :)
02:44:01 <merijn> sizeof is a unary operator, not a function
02:44:10 <merijn> unary operator bind less tight than postfix
02:44:15 <companion_cube> oh I see
02:44:26 <companion_cube> so it's basically sizeof char
02:44:40 <quchen> Ahahahaha
02:44:49 <aleator> quchen: Well, perhaps not a list as such but something between fixed size vector and normal list?
02:45:05 <merijn> "sizeof(0)["abcdefghij"]" -> "sizeof ((0)["abcdefghij"])" -> sizeof ("abcdefghij"[0]) -> sizeof 'a' -> 1
02:45:29 <quchen> merijn: I'll just use the "I don't know C" joker :>
02:45:37 <quchen> (And so can you!)
02:45:37 <merijn> quchen: No one does :)
02:45:39 <quchen> :-P
02:46:17 <quchen> To be fair, such an example is probably easy* to reproduce in Haskell with `infix` operators with custom fixity
02:46:20 <quchen> *: by Mauke, at least
02:46:37 <quchen> > 3 `subtract` 1
02:46:39 <lambdabot>   -2
02:50:08 <dpwright> it seems that most of the questions I ask here are when I've written something that I'm sure must already exist, but here's another one... I have something that feels like it should be expressible with some sort of fold, but I can't quit figure it out
02:50:25 <SrPx> "you write c code, but silently it is functional" wat
02:50:32 <dpwright> ...actually I was going to describe it but I'll just put the code up
02:51:18 <SrPx> aleator: what is hard with . and $ at all?
02:52:11 <aleator> SrPx: Surprisingly almost everything for some. Most difficult seems to be stuff like f . g x $ y
02:52:40 <dpwright> http://lpaste.net/93418
02:52:54 <aleator> I'm not sure if it is actually . or $ but that with haskell you don't have explicit grouping of function arguments, and people don't know where the parentheses would go.
02:53:33 <aleator> SrPx: Consider f 1+2 vs. java f(1)+2 or f(1+2)
02:54:17 <dpwright> so it takes a function which can create a list from another list, an accumulator, and a list.  For each iteration it runs the function to generate the new list from the old list and adds it to the accumulator, filtering out what's already in there.  When the function can no longer generate any new values that aren't already in the accumulator, it returns
02:54:19 <SrPx> aleator: to be fair I do think that is a problem, I'm honestly more for Lisp-like syntax but now that is suddenly too scary :~
02:54:53 <SrPx> aleator: but that is the kind of thing that honestly I guess needs the work of someone who actually understands the mindset of newbies. haskell is lacking a lot on that, it is not friendly at all, period...
02:55:04 <SrPx> aleator: as in, that is 99% the reason python is so famous.
02:55:09 <dpwright> I feel like maybe by dealing with a list of lists and then concatenating them at the end I could rewrite it as a fold, but I've been trying for a while and can't quite seem to get it right
02:55:10 <Flonk> aleator: as someine who is newish to Haskell, I can relate to that!
02:55:35 <Flonk> *someone
02:55:51 <dpwright> the tricky bit being that the function f may return results which are already in the accumulator, and I want to filter those out
02:56:05 <quchen> dpwright: You're not really walking over a list element-by-element, which is what foldr would be for
02:56:45 <dpwright> quchen: Yeah, exactly -- I considered making some sort of infinite list / tree of all the potential results from f and walking that, but I still need to figure out when to stop
02:57:22 <quchen> dpwright: I think you can make a fold out of this, but it's not going to be a simple one
02:57:34 <quchen> Probably in the same style of "foldl in terms of foldr"
02:57:49 <quchen> Wait, no
02:58:01 <quchen> Hm. Anyway, I wouldn't call that function an obvious fold.
02:59:05 <alexander__b> I have "main = do input <- concatMap . words =<< getArgs" in one of my programs, and because I found it so neat I tried to copy it into the program I'm working with right now, but this fails with "Couldn't match type `[a0] -> [b0]' with `IO [String]'" -- ideas?
02:59:59 <dpwright> hmm, maybe I'm barking up the wrong tree then.  I mean it's not *so* bad as it is and it works, but it just feels like a pattern that I might have expected to be abstracted.  Like, it's essentially a thing with a generator function, creating values from the current state until there are no more values to be created that aren't already made.  Or something
03:00:20 <quchen> alexander__b: concatMap takes two arguments
03:00:28 <quchen> > concatMap show [1..10]
03:00:31 <lambdabot>   "12345678910"
03:00:56 <benj_> SrPx, I disagree there aren't many people who understand the mindset of newbies. The mistake other lang communities make is to assume the best thing is to tell newbies what they want to hear. As a haskell newcomer, I really like that nobody is trying to convince me to use Haskell no matter what.
03:01:28 <alexander__b> quchen: I have the exact same code in another program without complaints
03:01:28 <quchen> alexander__b: If you want to concat all command line arguments and then split them into words, try "words . concat =<< getArgs"
03:02:21 <alexander__b> quchen: this gives "Couldn't match type `[String]' with `IO [String]'"
03:03:37 <aleator> Flonk: Sure. Haskell syntax is actually hard. It is not problem of the student but the language. But once learned, there is no going back :)
03:03:54 <quchen> aleator: There's a return missing. Or fmap.
03:04:00 <merijn> aleator: concatMap . words doesn't return an IO
03:04:03 <quchen> :t words . concat <$> getArgs
03:04:04 <lambdabot> Not in scope: `getArgs'
03:04:07 <alexander__b> and, yes, what I want to achieve is that all arguments always look like ["this", "is", "a", "demo"] -- regardless of whether I use './program a list of arguments' or './program "a list of arguments"'.
03:04:07 <merijn> aleator: Use fmap instead of =<<
03:04:21 <merijn> (or use <$>)
03:04:24 <jbracker> If I want to send something to haskell-cafe I just send to "haskell-cafe@googlegroups.com" right?
03:04:42 <alexander__b> merijn: wait are you talking to me?
03:04:48 <merijn> alexander__b: eh, whoops, yes
03:04:55 <merijn> I blame irssi autocomplete
03:05:01 <quchen> λ. :t words . concat <$> getArgs
03:05:01 <quchen> words . concat <$> getArgs :: IO [String]
03:05:03 <quchen> alexander__b: ^
03:05:10 <alexander__b> merijn: I'm confused why the exact same code works in my other program
03:05:19 <haasn> alexander__b: that line seems familiar..
03:05:22 <merijn> alexander__b: Including the getArgs?
03:05:24 <alexander__b> haasn: :-D
03:05:32 <alexander__b> merijn: yus
03:05:43 <merijn> alexander__b: I'd be interested to see that code, because that can't possibly compile
03:05:47 <quchen> It often helps to paste code instead of telling stories about it
03:07:19 <alexander__b> merijn: my current iteration doesn't compile because of other things, and I don't seem to have a git version with that exact line, and I'm too lazy/busy to make it work right now.
03:07:21 <arianvp> hi
03:07:25 <arianvp> sup
03:07:48 <merijn> alexander__b: anyhoo, it is fmap you want in this case :)
03:09:52 <alexander__b> main = do input <- words . concat <$> getArgs
03:09:53 <aleator> If anyone has extra time, I'm hunting mistakes here: http://functional-programming.it.jyu.fi/TIES343/slides/Collection4.html
03:09:53 <Flonk> aleator: There's not that much syntax, fortunately, but ' ' vs '$' vs '.' throws me off balance every time.. Just an hour ago i was faced with fmap.flip elem and had no idea how to put brackets around it to make it more obvious
03:09:55 <alexander__b> seems about right?
03:10:33 <alexander__b> map concat to the result of getArgs and then do words on the result and "store it" (IDK the right term) in input
03:10:41 <aleator> Flonk: I've tried, with little success to flaunt the definition f . g = \x -> f (g x) in front of the students and make them use that in troubled cases. Didn't help though.
03:10:53 <quchen> Flonk: But now you know how it's parsed?
03:11:23 <quchen> "Function application binds tighter than any other operator, (.) binds pretty tightly, ($) is super loose"
03:11:51 <quchen> So   fmap.flip elem  ≡  fmap . (flip elem)
03:12:02 <haasn> “. has the highest stickiness”
03:13:06 <aleator> I find stickiness and binding tighter to be quite confusing concepts for beginners.
03:14:26 <aleator> It boils down to memorizing precedence and conciously applying that. But when students have a complex problem, they don't have working memory to spare for thinking about precedences.
03:14:37 <SrPx> benj_: but maybe that is a problem, if good for you
03:14:53 * aleator is thinking about making classical pupil dilation experiments with haskell students..
03:15:22 <quchen> aleator: You can always parenthesize and then refactor
03:16:40 <quchen> aleator: Escaping from Lisp syntax is also a good selling point for .$, because who wants S-expressions when there are no macros :-)
03:19:28 <Flonk> quchen: I brute-forced all ways to bracket this expression and checked until the types matched
03:19:39 <merijn> Flonk: btw, you can ask ghci about how strong things bind
03:19:45 <Flonk> quchen: For some reason higher-order functions make me uncomfortable
03:19:52 <Flonk> merijn: Oh? How?
03:20:11 <merijn> ":i" will print the fixity of an operator (i.e. whether it's left associative or right associative and how strong it binds)
03:20:27 <merijn> Flonk: The default (which isn't printed, which I think is a mistake) is "infixl 9"
03:20:27 <Flonk> :t (++)
03:20:29 <lambdabot> [a] -> [a] -> [a]
03:20:30 <Flonk> :i (++)
03:20:38 <merijn> Flonk: lambdabot doesn't support :i
03:20:53 <Flonk> merijn: Oh okay, too bad
03:20:57 <Flonk> I didn't know that though, thanks!
03:21:25 <merijn> Flonk: Function application is infixl 10 (operators can only have 0 through 9), with ($) having 0 and (.) having 9
03:22:05 <merijn> Flonk: You can even specify the fixity of your own stuff using "infixr 1 $$" or "infixl 8 **" like annotation
03:22:31 <merijn> Flonk: It even works for infix application of functions, i.e. "infixl 4 `elem`" defines the fixity for infix use of elem
03:24:32 <Flonk> merijn: That's pretty neat
03:24:52 <Flonk> Knowing that juxtaposition takes precedence over (.) clears things up a lot
03:25:15 <merijn> Flonk: The other rules of thumb are that function application binds tighter than any operator and record update binds tighter than anyting (i.e. "foo MyRecord { recordField = 1 }" is parsed as "foo (MyRecord { recordField = 1 })")
03:25:32 <merijn> Flonk: Yes, that's an important one to know, fortunately it's also easy :)
03:26:20 <merijn> It explains why you need "map (foo.bar) myList" because "map foo.bar myList" is "(map foo) . (bar myList)"
03:27:38 <merijn> Flonk: And while I'm busy info dumping, this one will be helpful to you too: http://blog.codeslower.com/static/CheatSheet.pdf
03:27:47 <merijn> @where+ cheat-sheet http://blog.codeslower.com/static/CheatSheet.pdf
03:27:47 <lambdabot> Nice!
03:29:51 <Flonk> merijn: Cool, thanks
03:32:06 <haasn> edwardk: Something's up with lens and/or vector, the latest version of ‘lens’ on hackage doesn't work with the latest version of ‘vector’, uploaded two days ago
03:32:19 <haasn> http://hackage.haskell.org/package/vector-0.10.9.0 isn't that a strange version number though?
03:32:21 <haasn> I wonder what happened there
03:32:26 <Taneb> Known bug
03:32:29 <haasn> ok
03:32:31 <Taneb> vector broke PVP
03:33:20 <Taneb> Apparently it was a mistake that couldn't be corrected due to the Great Hackage Switchover
03:38:01 <ocharles> is the hackage switchover complete?
03:38:08 <ocharles> My DNS records might not have updated yet
03:57:12 <haasn> “hackage.haskell.org. 7200 IN A 66.193.37.204” is what it says for me
03:58:44 <ocharles> haasn: hmm, same as me
04:01:09 <haasn> That's what the NS haskell.org is registered to tells me
04:03:14 <ksf> ocharles, the hackage front page says it's in progress
04:04:53 <ocharles> ksf: sure, it said that yesterday too
04:04:56 <ocharles> i thought it was a few hours
04:17:12 <ksf> http://lpaste.net/93420    why does this happen?
04:20:21 <supki> ksf: typo in (:&) type signature?
04:20:58 <ksf> good call but no, that's not it.
04:21:13 <ksf> changes the error to  Couldn't match type ‛t’ with ‛([Char], Integer)’
04:23:21 <pavonia> .oO(boom, boom, ay ... `t' is untouchable ...)
04:23:32 <alexander__b> how do I shorten something like: "[f x, g x]"?
04:23:53 <alexander__b> i.e. I want to construct a list by applying different functions to the same argument
04:24:04 <alpounet> make a list of the functions
04:24:10 <alexander__b> [foo arg, bar arg, fu arg, baz arg]
04:24:13 <Hafydd> > map ($ x) [f, g]
04:24:14 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
04:24:14 <lambdabot>    arising from a us...
04:24:14 <ksf> :t map (f $)
04:24:15 <lambdabot> (Show a, FromExpr b) => [a] -> [b]
04:24:16 <alpounet> and then map ($ x) listOfFunctions
04:24:21 <alexander__b> alpounet: that's what I thought, but I wondered if there was some syntax sugar or whatever to do it
04:24:30 <ksf> what Hafydd said
04:24:33 <alexander__b> I guess I can do that
04:24:34 <alexander__b> thanks!
04:24:34 <mauke> > sequence [f, g] x :: [Expr]
04:24:35 <lambdabot>   [f x,g x]
04:24:52 <alexander__b> that looks acceptably nice to me. :-)
04:25:24 <ocharles> mauke: oh nice, i never thought of doing that
04:25:31 <ocharles> good 'ol (a ->) Monad
04:25:38 <alexander__b> I like mapping $ but sequence looks nice too
04:26:30 <gpampara> Wouldn't an applicative solve that nicely?
04:26:49 <Hafydd> The advantage of mauke's method is that it can be parameterised by x easily.
04:26:51 <alexander__b> to make it even shorter
04:26:55 <alexander__b> is there a neat way to do: [length, length . words, length . lines] ?
04:27:04 <alexander__b> i.e. to not write "length" three times
04:27:18 <alexander__b> the full thing: map ($ input) [length, length . words, length . lines]
04:27:22 <merijn> alexander__b: "map (length.) [id, words, lines]"
04:27:45 <alexander__b> merijn: ah, length. genius! thank you, haskell.
04:27:46 <merijn> :t sequence . map (length.) [id, words, lines]
04:27:46 <lambdabot>     Couldn't match expected type `a0 -> [m0 a1]'
04:27:47 <lambdabot>                 with actual type `[[Char] -> Int]'
04:27:47 <lambdabot>     In the return type of a call of `map'
04:27:58 <merijn> oh
04:28:00 <merijn> wait
04:28:01 <merijn> :t words
04:28:02 <lambdabot> String -> [String]
04:28:04 <merijn> :t lines
04:28:04 <lambdabot> String -> [String]
04:28:27 <mauke> <merijn> "sizeof(0)["abcdefghij"]" -> "sizeof ((0)["abcdefghij"])" -> sizeof ("abcdefghij"[0]) -> sizeof 'a' -> 1   <- not quite correct
04:28:35 <mauke> "..." is an array of char but 'a' is an int
04:28:36 <merijn> alexander__b: oh, damn, won't work
04:28:42 <alexander__b> aha
04:28:50 <merijn> alexander__b: id is the wrong type
04:28:54 <alexander__b> yes
04:29:25 <merijn> mauke: Because all literals are int?
04:29:27 <alexander__b> my ghc-mod in vim tells me the same.
04:29:33 <mauke> merijn: all character literals
04:29:44 <mauke> :t sequence $ map (length .) [map pure, words, lines]
04:29:45 <lambdabot> [Char] -> [Int]
04:29:57 <merijn> mauke: or rather, I guess I mean "all literals that don't have annotations like UL, etc."
04:30:06 <Hafydd> @pl \x -> [length x, length $ words x, length $ lines x]
04:30:10 <lambdabot> ap ((:) . length) (ap ((:) . (length $) . words) (flip ((:) . (length $) . lines) []))
04:30:10 <lambdabot> optimization suspended, use @pl-resume to continue.
04:30:12 <mauke> merijn: no, the story is more complicated for numeric literals
04:30:13 <Hafydd> D:
04:30:34 <merijn> mauke: Yeah, the "sizeof 'a'" bit was a bit dodgy anyway, I wasn't sure how else to describe taking the sizeof an element in an array
04:30:49 <mauke> > sequence (map (length .) [map pure, words, lines]) "five words on\ntwo lines\n"
04:30:50 <lambdabot>   [24,5,2]
04:31:25 <merijn> Well, other than "sizeof "abcedfghij"[0]", which is not particularly more enlightening :)
04:31:35 <merijn> mauke: I don't think I wanna know about C numeric literals >.<
04:32:22 <mauke> merijn: it's different in C++, of course. 'x' is a char in C++
04:32:36 <mauke> but you can't reliably detect C++ that way because sizeof (int) might be 1 anyway
04:33:25 <Phlogistique> haha
04:33:43 <Phlogistique> I'll ask that next time I do a technical interview
04:34:22 <mauke> Phlogistique: https://raw.github.com/mauke/poly.poly/master/poly.poly
04:34:58 <Hafydd> Good grief.
04:35:12 <alexander__b> OK my current solution, lol, is map ($ input) (map (length .) [map pure, words, lines])
04:35:17 <merijn> Phlogistique: See http://mauke.hopto.org/stuff/c/sizeof.c for related code
04:35:27 <alexander__b> ghc-mod says: 12 col 15 warning| Use map once
04:35:36 <Phlogistique> merijn: I saw that
04:35:40 <alexander__b> so does this mean I shouldn't use map more than once per line or something?
04:36:01 <mauke> alexander__b: map f . map g == map (f . g)
04:36:05 <merijn> Phlogistique: Additionally, fun questions: Ask why casting a function pointer to void* is wrong and inquire how many bits are in a char or what the signedness of char is :)
04:36:23 <merijn> Phlogistique: (although this may be more on topic for -blah)
04:36:46 <alexander__b> mauke: I understand this simple example, but my intuition is not strong enough to use it on my more complicated line
04:36:52 <mauke> map (\f -> length (f input))
04:37:20 <mauke> or map (($ input) . (length .)) if you want a more literal substitution
04:37:37 <supki> ksf: interesting, ghc seems to default b to Integer in the pattern match (sorry if this is obvious)
04:38:08 <haasn> supki: GHC will default Integral and Num constraints to Integer
04:38:16 <haasn> and probably a few others
04:38:33 <haasn> (it also defaults Rational, Floating etc. to Double)
04:38:35 <supki> why?
04:38:40 <haasn> convenience?
04:38:42 <supki> (context: http://lpaste.net/93420)
04:39:37 <supki> i.e. it works with monomorphic foo
04:39:51 <alexander__b> mauke: aha! after braining a bit I got it, thanks!
04:40:26 <Phlogistique> merijn: hah, fot the first question, I must admit my ignorance
04:40:48 <Phlogistique> for
04:40:56 <int-e> merijn: old timers will remember various memory models from DOS, with different sizes for data and function pointers. :)
04:41:00 <supki> OTOH bar :: Num a => (String, a) errors
04:41:27 <int-e> merijn: so it's not just wrong in theory, it's also wrong in practice ;-)
04:41:29 <merijn> Phlogistique: functions are allowed to live in different memory/address space, void* are defined to be able to point to any *data* object, hence they may not be convertible
04:41:52 <merijn> Phlogistique: On x86 that generally doesn't happen, but it's still wrong :)
04:42:37 <Hafydd> Phlogistique: fails the interview.
04:42:41 <Hafydd> -:
04:42:42 <Phlogistique> merijn: heh! alright
04:44:11 <alexander__b> err I wanna make a function that returns "    " ++ show... how would this look? i.e. if I call f 42, it should return "    42"
04:44:41 <int-e> what's wrong with  ("    " ++) . show  ?
04:44:48 <boothead1> When you have a typeclass method that has (MonadIO m) => what are you allowed in the instances?
04:45:02 <alexander__b> int-e: maybe the way I placed my parens
04:45:22 <alexander__b> int-e: yes, yours work. thanks. :-)
04:48:10 <ocharles> boothead1: not sure what you mean
04:48:21 <ocharles> boothead1: you're allowed any monad that is MonadIO?
04:51:26 <boothead1> ocharles, it seems I also have to state all the other types of Monad it is too. I ended up with (MonadIO m, MonadReader Connection  m) =>
04:51:55 <boothead1> but I'm not sure if there might be other requirements for different instances
04:51:57 <ocharles> boothead1: well sure, MonadIO m does not imply MonadReader Connection m
04:51:58 <Taneb> Hmm, is there a way to have a web page display an svg then wait for the server to send the next svg?
04:52:02 <Taneb> svg or png
04:52:30 <ocharles> boothead1: I don't think MonadIO m just implies m is a Monad (and nothing else right now)
04:52:30 <boothead1> ocharles, no I guess not. are you back from germany yet?
04:52:36 <ocharles> Yea, I am
04:56:36 <ksf> http://lpaste.net/93421   can someone tell me whether that's a ghc bug?
04:57:05 <boothead1> ocharles, so there's not some catch all monad transformer thing i can use to the left of the => then?
04:57:07 <ksf> all mentions of untouchable types in errors I found on the net revolve around type inference, but as a matter of fact ghc *did* infer the type.
04:57:33 <ksf> ...it just fails to unify it without that type annotation
04:57:42 <boothead1> I thought that was the whole point? "Transformers, Monads in disguise!"
04:58:15 <ksf> boothead1, type Foo m
04:58:17 <ksf>  er
04:58:26 <ksf> type Foo m = (Bar m, Baz m)
04:58:34 <ksf> enable -XConstraintKinds and you're set.
05:01:29 <ocharles> boothead1: you could use constraint kinds as ksf said, or just have an empty class that just implies a bunch of other things to be an instance of that class
05:01:49 <ocharles> boothead1: alternatively, ask yourself if you want to be working with polymorphic monads, or if it's just easier to build a concrete monad and work in that
05:02:07 <ksf> ocharles, the latter one would require undecidableInastances
05:02:21 <ocharles> ksf: oh, right
05:02:34 <Dakk> Hey! I need some help with my function
05:02:36 <Dakk> http://pastebin.com/xRR10kAv
05:02:39 <mauke> The paste xRR10kAv has been copied to http://lpaste.net/93422
05:02:41 <intrados> When using Aeson, is there a way to pattern match against the contents of the JSON object? There's a "success" field in the JSON and I'd like to return mzero when "success" is 0
05:02:50 <Dakk> It says that the last expression of a do statement, must be an expression
05:03:03 <ocharles> ksf: class MonadReader Connection m => MyMonad m really needs undecidable instances? I thought just FlexibleContexts
05:03:21 <ksf> ocharles, you could write MyMonad m => Connection m somewhere else.
05:03:37 <ksf> Dakk, line up the x and return
05:04:04 <ksf> Dakk, as it is, return (Soduku .... is seen as a continuation of the expression readFile file
05:04:16 <ksf> and as that's a binding, not an expression, you get the error you get.
05:04:40 <supki> intrados: parseJSON (Object o) = do ...; s <- o .: "success"; if s == 0 then mzero else ....
05:06:17 <ksf> Dakk, also, the canonical way to format that code is "do" on the same line as "=", x and return indented four spaces, where two, turnToSudoku on a new line and indented four spaces.
05:06:35 <Dakk> hmm
05:06:39 <ocharles> 'if s == 0 then mzero' is guard (s /= 0), no?
05:06:42 <Dakk> ksf could you make a quick example on pastebin?
05:08:21 <ksf> Dakk, somewhat like this: http://lpaste.net/93423
05:08:37 <dr_diagoras> greetings. I have a question on size of Int in GHC. I know I shouldn't rely on exact bitness of Int, but I have heard that in x64 environment it is usually 64. I have just checked - in GHCi on my win64 machine "maxBound :: Int" is only 2147483647. I'm a bit curious how is this happening?
05:08:51 <ksf> oh. and r is going to be a char.
05:08:51 <Dakk> ksf THaks! :)
05:08:58 <ksf> but ghc is going to tell you that :)
05:11:23 <luite> dr_diagoras: the ghc you can download for windows is 32 bit, 7.8 will probably have a proper 64 bit release
05:12:01 <ksf> dr_diagoras, the haskell spec says Int is "at least 31 bytes".
05:12:16 <ksf> if you want an Int64, use Int64.
05:13:29 <dr_diagoras> luite: thanks, that's what I was suspecting too. I remember checking on linux machine and getting 64 bits - that's why my curiosity raised
05:15:25 <alexander__b> what is the best way to check if there are args, and if not use stdin?
05:15:58 <alexander__b> I do input <- getArgs; case input of [] -> interact format; _ -> parse $ concat input -- but this doesn't work with args.
05:16:14 <alexander__b> in parse, I do contents <- getContents -- so I assume that's... not right.
05:16:37 <alexander__b> here's the entire code atm http://bpaste.net/show/135561/
05:17:02 <alexander__b> (I will decouple parsing/formatting/counting later, I am aware that it's a bit meh atm)
05:17:30 <alexander__b> so what I want to do is emulate wc's behaviour. if args: use the files passed as args. if no args: count stdin.
05:18:27 <ksf> alexander__b, you want to readFile your args, not getContent
05:19:08 <ksf> parse essentially replicates the behaviour of interact
05:19:26 <ksf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#interact
05:20:04 <edwardk> haasn: i'd take a patch for changing failing's fixity, go for it
05:20:33 <alexander__b> ksf: OK
05:20:49 <alexander__b> ksf: I am using interact, as you can see in main
05:21:09 <alexander__b> ksf: but OK, so if args: use readfile, if no args: use interact?
05:21:43 <ksf> yes, more or less. I can think of more enterprisey ways but that's fine.
05:22:04 <alexander__b> ksf: :-) I'll look into readFile. thanks.
05:26:13 <alexander__b> ksf: OK so now parse is contents <- readFile args; putStrLn $ format contents -- how do I map this to the input, when parse returns IO ()?
05:27:08 <alexander__b> i.e. putStrLn $ unlines $ map parse input -- only er, something that compiles instead of map
05:27:23 <ksf> :t mapM
05:27:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
05:27:28 <alexander__b> that's what I thought
05:27:38 <alexander__b> I guess I'm doing something wrong with the way I'm using parse though
05:28:17 <alexander__b> oh right the problem is with unlines
05:28:28 <alexander__b> unlines can't take an IO ()
05:28:41 <ksf> fmap is your friend
05:28:49 <alexander__b> not a newbie's friend :-P
05:28:57 <ksf> ...applying unlines "inside" the IO.
05:29:18 <ksf> :t fmap :: (String -> String) -> IO String -> IO String
05:29:19 <lambdabot> (String -> String) -> IO String -> IO String
05:29:21 <ksf> :t fmap
05:29:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:29:28 <alexander__b> yes, I get the theory behind this, but I still get stuck whenever I have to do this type of thing... guess that's why I'm trying to write this program though, heh.
05:29:42 <ksf> practice, practice, practice.
05:29:49 <alexander__b> exactly :-)
05:34:06 <alexander__b> OK I'm not sure where unlines is supposed to go
05:34:13 <alexander__b> I thought maybe putStrLn <$> unlines $ mapM parse input but err no
05:35:48 <ksf> :t let args = ["foo.dat", "bar.dat"] in fmap unlines . mapM readFile $ args
05:35:49 <lambdabot> IO String
05:36:03 <identity> alexander__b: what is the type of parse and input?
05:36:31 <alexander__b> identity: parse ::  String -> IO ()
05:36:39 <alexander__b> identity: input is <- getArgs
05:37:02 <identity> alexander__b: and what exactly are you trying to do, then?
05:37:09 <alexander__b> so IO [String]
05:37:26 <alexander__b> call parse on every arg, unlines the result and print it
05:37:54 <identity> :t unlines
05:37:55 <lambdabot> [String] -> String
05:38:08 <identity> getArgs >>= mapM parse . lines
05:38:23 <identity> parse is String -> IO (), you said. It doesn't return a result
05:38:25 <identity> it returns ()
05:38:44 <alexander__b> righ tit should return IO [String]?
05:38:44 <pr> @hoogle groups
05:38:44 <lambdabot> package groups
05:38:44 <lambdabot> System.Posix.User getGroups :: IO [GroupID]
05:38:44 <lambdabot> package semigroups
05:39:13 <identity> Well, depends on what you're doing. I can't tell you what *your* code should look like ;)
05:39:21 <alexander__b> identity: http://bpaste.net/show/135561/
05:39:51 <alexander__b> identity: oh, old paste
05:40:30 <alexander__b> identity: http://bpaste.net/show/135563/ a bit broken but
05:41:12 <identity> yes. parse returns nothing, namely because you're printing the result of "format contents" instead of returning it
05:41:14 <alexander__b> identity: I want to use format on stdin if no args, but if args then parse/main should make sure that format is called on every file's content
05:41:26 <alexander__b> identity: yes, I realise that now
05:41:56 <alexander__b> I think I'll forego it entirely and just use readFile in main, if that is acceptable
05:42:09 <alexander__b> oh wait no I won't
05:42:14 <alexander__b> because I want to handle options in the future :-)
05:43:07 <identity> you can simply do: parse args = do { contents <- readFile arg; return $ format contents;}
05:43:09 <pr> let's say i want to represent graphs (undirected, finite) in haskell. in addition i want to be able to represent permutations acting on the graph, giving rise to a new, possible isomorphic graph. what would be a good way to go about this?
05:43:27 <identity> in which case parse is String -> IO String
05:43:44 <alexander__b> identity: I see. thank you!
05:46:36 <identity> alexander__b: alternatively, even more concise using applicative: format <$> readFile args
05:47:33 <alexander__b> identity: OK nice, thanks
05:48:04 <haasn> Whoa, I never realized data X = X { a, b :: C } -- wroks
05:48:06 <haasn> works, even
05:48:52 <alexander__b> so then I mapM this new parse to the input, then how do I unlines it?
05:49:06 <jmcarthur_mobile> I only realized that within the last couple months and still keep forgetting
05:49:39 <alexander__b> I tried putStrLn <$> unlines <$> mapM parse input
05:49:44 <alexander__b> but apparently I'm doing goofd, heh.
05:50:17 <alexander__b> Couldn't match type `IO ()' with `()', right
05:52:04 <identity> alexander__b: unlines <$> mapM parse input is :: IO String
05:52:41 <identity> alexander__b: putStrLn :: String -> IO String. fmap :: (a -> b) -> f a -> f b -- so putStrLn doesn't fit
05:52:55 <identity> anyway, unlines <$> mapM parse input >>= putStrLn
05:52:59 <identity> should do the trick
05:54:27 <alexander__b> it does -- though I'm not 100% sure I understand why fmap doesn't work but >>= does work
05:55:26 <haasn> Isn't there some library somewhere that provides pointInBox :: Ord a => (a,a) -> (a,a) -> (a,a) -> Bool -- ?
05:55:34 <haasn> gloss has this but specialized to Float; I want Int
05:55:54 <fizbin> @type (>>=)
05:55:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:56:02 <fizbin> @type fmap
05:56:03 <jmcarthur_mobile> :t inRange
05:56:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:56:03 <lambdabot> Ix a => (a, a) -> a -> Bool
05:57:00 <jmcarthur_mobile> haasn: it may not look it at first, but inRange may be what you want
05:57:21 <haasn> jmcarthur_mobile: thanks, worth a try!
05:57:24 <identity> alexander__b: It's all in the types.
05:57:33 <fizbin> alexander__b: look at the type of the first parameter in fmap and the type of the second parameter in (>>=)
05:57:46 <alexander__b> identity: so how do I, say, ++ an IO String()?
05:58:00 <alexander__b> "foo" ++ var, where var is IO String
05:58:09 <alexander__b> eh -- String not String()
05:58:09 <identity> alexander__b: (++ "foo") <$> var
05:58:14 <alexander__b> interesting.
05:58:20 <identity> :t fmap
05:58:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:58:23 <Cale> alexander__b: run the IO String to get its String result, then use ++ on that
05:58:32 <identity> :t (++ "foo")
05:58:33 <lambdabot> [Char] -> [Char]
05:58:42 <fizbin> alexander__b: Or do { x <- var; return ("foo" ++ x) }
05:58:44 <identity> so here (a -> b) is (String -> String)
05:58:49 <Cale> alexander__b: i.e.  do v <- var; return ("foo" ++ v)
05:58:56 <Cale> yeah
05:59:06 <identity> and f a is IO String
05:59:08 <haasn> jmcarthur: confirm
05:59:20 * fizbin is apparently sharing a haskell brain with Cale this morning.
05:59:21 <jmcarthur_mobile> Yay!
05:59:32 <alexander__b> if I do x <- var, is the var "spent"/"taken out" or something, or can I do v <- var; w <- var?
05:59:45 <identity> alexander__b: the computation is run again.
05:59:47 <identity> 'run'
05:59:48 <Cale> alexander__b: You can run an IO action as many times as you like
05:59:56 <alexander__b> interesting. thanks all.
05:59:59 <Cale> alexander__b: The results may all be different
06:00:14 <fizbin> alexander__b: But that will in fact run it again, so if you take user input to make that IO String...
06:00:20 <Cale> alexander__b: An IO String contains a String in the same sense that /bin/ls contains a list of files.
06:00:33 <alexander__b> well my specific scenario was on a program argument
06:01:08 <merijn> alexander__b: "putStrLn "foo"" is a program fragment that prints "foo", that program fragment can be executed any number of times in any number of place
06:01:23 <merijn> alexander__b: The same goes for input
06:01:44 <identity> alexander__b: getArgs is impure because it needs to access the environment to ask for the arguments to the program. The arguments are still there, but the fact that it's an IO action just means the action is not pure. It's accessing the outside world.
06:01:48 <merijn> alexander__b: See also, my work in progres article: https://gist.github.com/merijn/6478573
06:01:58 <identity> And we all know that going outside is very, very bad and should be avoided at all costs.
06:02:11 <alexander__b> hey so, (++ "foo") <$> var -- this will be the same as doing 'var ++ "foo"'? in the latter the var would just be a string then of course
06:02:23 <alexander__b> identity: yes
06:02:57 <Cale> alexander__b: Well, apart from the fact that they don't both typecheck at the same time :)
06:03:10 <Cale> <$> is shorthand for fmap
06:03:13 <identity> alexander__b: (++ "foo") <$> var is "take the result out of the computation var, and apply the function (++ "foo") to it, and return a new computation"
06:03:25 <Cale> :t fmap
06:03:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:03:34 <Cale> So, if f = IO here, for instance
06:03:38 <alexander__b> identity: right
06:03:43 <Cale> We have fmap :: (a -> b) -> IO a -> IO b
06:03:45 <merijn> identity: I prefer the "is the same as stuffing the function into the computation and getting a result
06:03:54 <identity> merijn: that works well
06:03:56 <identity> as well*
06:04:05 <merijn> It stops the myth that you can get things out
06:04:08 <Cale> So, it takes a function, and an IO action, and gives you another IO action which has the function applied to its results.
06:05:00 <Cale> "Takes the result out of the computation" is a bit of a funny thing to say. Why not just say "produces a computation which runs the computation var, and applies the function to it"
06:05:16 <identity> merijn: Yeah, that's true. But sometimes, just using any analogy that works is what is needed. It will all eventually "click" for them
06:05:21 <Cale> (the verb being "to run" :)
06:05:30 <Cale> Or "executes"
06:07:56 <alexander__b> OK so (++ arg) <$> format <$> readFile arg -- will result in the result of format etc ++ "foo", right? how do I uh prepend "foo"?
06:08:10 <alexander__b> so make the ++ the other way around
06:08:17 <alexander__b> if you get what I mean
06:08:56 <identity> alexander__b: ("foo" ++)
06:09:24 <alexander__b> oh
06:10:39 <merijn> alexander__b: incidentally, you can also do "(++ arg) . format <$> readFile arg"
06:10:59 <merijn> i.e. fmap the composition, rather than fmapping one at a time
06:11:00 <intrados> I'm trying to conditionally parse JSON with Aeson. If the "success" field isn't 1, I want to return mzero. I get type errors when I try to do it with guards and when I try monadically. http://sprunge.us/cTaF
06:14:54 <supki> intrados: you can't compare (o .: "success") and 1, the former isn't a number, it's a parser returning the number
06:15:23 <supki> intrados: as for the monadic version I don't see what's wrong, can you paste the error too?
06:16:51 <intrados> http://sprunge.us/ShAb
06:17:23 <supki> uh
06:17:59 <supki> it does not know what type s has
06:18:22 <supki> you can either annotate it or use  then return (Test s)  instead of parsing the same field twice
06:18:40 <intrados> Yeah. I tried adding :: Int at the end of the <- line
06:18:45 <intrados> But that caused new errors
06:18:57 <supki> oh, it does not work like that I think
06:19:24 <supki> <- line is :: Parser Int or something
06:19:27 <intrados> Yeah. I think it's the thing with it being a parser
06:20:27 <supki> you can annotate (s :: Int) <- ... with -XScopedTypeVariables extension enabled I think
06:20:56 <t7> x86 mov is turing complete
06:21:29 <intrados> Ah, -XScopedTypeVariables worked. Thanks
06:22:42 <haasn> Is there something like MonadState s m => (s -> m s) -> m () -- ?
06:23:29 <haasn> + some additional MonadTrans constraints, w/e
06:23:37 <haasn> Err, that's not what I meant
06:23:54 <haasn> basically  \f -> do { s <- get s; s' <- lift (f s); put s' }
06:24:36 <supki> get s ?
06:24:48 <haasn> s <- get*
06:24:57 <supki> well
06:25:00 <supki> @ty \f -> modify (lift . f)
06:25:01 <lambdabot> (Monad m1, MonadTrans t, MonadState (t m1 a) m) => (t m1 a -> m1 a) -> m ()
06:27:13 <supki> hmm
06:30:46 <akegalj> i would like to do something like "instance Bounded A where; minBound = f1 a; maxBound = f2 a; a = [someList]". how to define function a which will be visible in both maxBound and minBound but not outhside instance scope? Or do i just do "a = [someList]" in same module as instance but not export a?
06:31:14 <supki> @ty \f -> id <~ (get >>= lift . f)
06:31:14 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m s) -> t m ()
06:32:54 <bergmark> akegalj: the latter
06:33:20 <akegalj> bergmark: ok..i supposed it, thnx
06:56:04 <sfvisser> akegalj: should could do this: http://lpaste.net/93430
06:56:42 <sfvisser> that way not the the shared stuff, but the two helper functions are in scope
06:56:48 <sfvisser> might not be what you want
06:56:54 <haasn> supki: fair enough
06:57:19 <haasn> but uh
06:57:42 <haasn> :t \f -> put =<< lift . f =<< get -- lens here is overkill
06:57:43 <lambdabot> (Monad m, MonadTrans t, MonadState a (t m)) => (a -> m a) -> t m ()
06:57:51 <haasn> (yes, haasn saying lens is overkill. it happened)
07:01:41 <cgaebel> test
07:04:48 <donri> cgaebel: it didn't work, try again
07:08:42 <alexander__b> can someone with a less imperative mind give me any ideas on how to calculate the totals here: http://bpaste.net/show/135590/ ?
07:09:14 <alexander__b> what I"m doing now is count all chars/words/lines of each file, then format it, then output it
07:09:28 <quchen> :t modify . lift -- haasn: get/put is overkill :-P
07:09:29 <lambdabot> ghc: panic! (the 'impossible' happened)
07:09:29 <lambdabot>   (GHC version 7.6.3 for i386-unknown-linux):
07:09:29 <lambdabot>   kindFunResult
07:09:35 <quchen> Ooops
07:09:42 * quchen hides
07:09:45 <alexander__b> so my imperative mind would just, when counting -- increase the total counter for chars/words/lines. but that's not very functional.
07:10:05 <identity> alexander__b: sec
07:10:18 <Taneb> alexander__b, sounds like a left fold
07:10:36 <alexander__b> Taneb: wat. did you look at the source?
07:10:43 <merijn> alexander__b: Well, why not fold over the entire String and update counts as you encounter chars/spaces/line breaks
07:10:44 <alexander__b> I have coupled formatting and counting too much, I think.
07:11:01 <alexander__b> merijn: oh. that was my second idea. but that sounded stupid. :-P
07:11:07 <alexander__b> I thought maybe I should have restructured everything somehow
07:11:21 <alexander__b> because the way you suggest, if I change the formatting, I might have to change the total counting as well
07:11:21 <merijn> I guess whether that works depends on whether you will encounter multiple spaces in a row
07:18:36 <haasn> quchen: fun, I get the same error
07:18:57 <TallerGhostWalt> What is the closest xml analogy to Data.Aeson?
07:19:02 <haasn> quchen: oh, it tries matching m a ~ t m a
07:19:23 <haasn> :t \f -> modify (lift f) -- this doesn't error
07:19:24 <lambdabot>     Couldn't match kind `* -> *' with `*'
07:19:24 <lambdabot>     Expected type: a0 -> a0
07:19:24 <lambdabot>       Actual type: a0 -> a0
07:19:25 <TallerGhostWalt> I really want ToXML , FromXML
07:19:47 <quchen> haasn: In private chat it works. (Apart from the fact that my code is a) wrong and b) supki did the exact same thing half a page earlier)
07:20:05 <haasn> quchen: not quite the same thing
07:20:13 <haasn> he did (lift . f) not (lift f)
07:20:25 <quchen> Oh wait no, it also crashes in the pointfree version.
07:20:35 <haasn> It only crashes in the pointfree version for me
07:20:43 <quchen> Let me see what HEAD-minus-two-weeks has to say about this
07:22:18 <quchen> Eh, I don't have the MTL for HEAD of course. Mpf
07:23:10 <lamefun> can I make a copy of a big structure with only one field changed without reassigning all of them?
07:23:13 <TallerGhostWalt> hxt has a pickler
07:23:45 <TallerGhostWalt> but it's xpWrap function seems to require ordered xml at the child level which I can't guarantee in this application.
07:24:01 <quchen> lamefun: Very rarely all of them are reassigned.
07:24:06 <TallerGhostWalt> I could just write a hand parser but would prefer an idiomatic soln. if available.
07:24:12 <identity> TallerGhostWalt: I wish there was something as good as Aeson for XML
07:24:19 <quchen> lamefun: If you change the first element of a list, the tail will be shared for example.
07:24:24 <identity> Aeson spoiled me
07:24:30 <haasn> lamefun: are you asking about record update syntax?
07:24:46 <lamefun> I mean, without MyStruct { f1 = f1, f2 = f2, .........., fX = fX + 1 }
07:25:06 <haasn> lamefun: eg. data Foo = Foo { foo :: Int, bar :: Bar, bat :: Bat, ... };  quux :: Foo -> Foo; quux x = x { foo = 5 }
07:25:12 <Cale> lamefun: myRecord { fX = fX + 1 }
07:25:16 <TallerGhostWalt> well... I was afraid that was the answer, okay then i'll write a dumb hand parser. Thanks!
07:25:24 <Cale> lamefun: Where myRecord is the old value of the same type
07:27:27 <donri> TallerGhostWalt: xml-picklers with xml-conduit is alright
07:34:38 <haasn> Hmm.. what would be a clean way to write this? :: Char -> [(Int,Int)] -> Doc -- with the semantics that the ‘Char’ would appear at each listed coordinate
07:35:16 <haasn> I guess I could fold over a 2d vector and then convert those to lines ‘manually’
07:35:25 <haasn> But I'm wondering if there's some, like, really clean way :P
07:35:42 <quchen> haasn: You're the Lens guy :-P
07:36:24 <haasn> quchen: yes yes, foldr (\n -> (folded<.>folded).ix n .~ 'c') -- but that's not the point :P
07:36:48 * quchen regrets saying what he said
07:36:49 <haasn> traversed even
07:37:15 <haasn> and s/ix/index/
07:38:17 <haasn> okay fine, I'll use that :)
07:43:50 <TallerGhostWalt> donri: Does xml-picklers have a way of addressing out of order records?
07:44:03 <donri> TallerGhostWalt: not sure what you mean
07:45:34 <saml> hello
07:45:36 <donri> TallerGhostWalt: it won't consume elements that don't match
07:45:39 <saml> what's a good haskell book? learn you haskell?
07:45:45 <saml> i want to make a web site
07:45:53 <TallerGhostWalt> like unpickling the type: Widget { key1 ::SomeType1, key2::SomeType2, key3::SomeType3}  with the xml: <widget> <key2>SomeVal</key2> <key1> SomeVal </key1> <key3> SomeVal </key3> </widget>
07:46:07 <donri> saml: the happstack crash course and the yesod books are probably good places to start for that
07:46:15 <saml> thanks
07:46:16 <donri> s/books/book
07:46:38 <Philonous> TallerGhostWalt, Order of the xml elements doesn't matter by default
07:47:17 <Sculptor> yo
07:47:25 <Philonous> Philonous, Just use xp3Tuple (key1Pickler) (key2pickler) (key3pickler)
07:47:37 <Philonous> TallerGhostWalt, Just use xp3Tuple (key1Pickler) (key2pickler) (key3pickler)
07:48:01 <TallerGhostWalt> I have to put that in an xpWrap right?
07:48:13 <donri> i wonder if an applicative xml pickler would be possible
07:48:15 <TallerGhostWalt> I did that and it gave me what I thought were out of order errors
07:48:22 <TallerGhostWalt> but perhaps I was mistaken
07:48:40 <TallerGhostWalt> Also I am not using Data.XML.Pickle
07:48:47 <TallerGhostWalt> I was using hxt's pickler that looks really similar
07:48:50 <Philonous> TallerGhostWalt, Yes, xp3Tuple picklers 3-tuples, you can use xpWrap to marshal those into your type
07:48:50 <TallerGhostWalt> maybe that is the problem
07:54:17 <Philonous> donri, Picklers aren't even functors.
07:54:41 <donri> oh yeah
07:54:45 <donri> bifunctors then? :P
07:54:50 <donri> biapplicative, is that a thing
07:54:53 <Philonous> difunctors
07:54:54 <ocharles> yes
07:54:56 <bennofs> Is it only me, or does hackage print error messages when trying to access the docs of a package?
07:55:03 <ocharles> @hackage bifunctors
07:55:03 <lambdabot> http://hackage.haskell.org/package/bifunctors
07:55:07 <ocharles> biapplicative is there, donri
07:55:43 <bennofs> Does that link work for you?
07:56:07 <donri> bennofs: works for me, but hackage is currently migrating to hackage2
07:56:15 <Philonous> picklers aren't bifunctors either
07:56:44 <TallerGhostWalt> Oh, wow yeah this is way different than the hxt pickler
07:56:47 <Philonous> they are profunctors, though
07:57:17 <TallerGhostWalt> good, hope!
07:57:20 <Philonous> (Errr, no, they are not)
07:57:24 <sclv> the partial isomorphisms package is related
08:01:33 <alexander__b> using applicatives or other magic, is there a way to shorten this: "mapM (\x -> format <$> count <$> readFile x) files"
08:01:52 <alexander__b> full thing: outputFiles files = concat <$> mapM (\x -> format <$> count <$> readFile x) files
08:03:37 <ion> concatMap (format . count) <$> mapM readFile files
08:03:50 <alexander__b> ah, yeh, concatMap, of course
08:04:23 <alexander__b> works, thanks!
08:04:54 <haasn> There's no instance (Random a, Random b) => Random (a,b) -- ??
08:06:48 <td123> what's a good suggestion for an audio library
08:07:46 <Lethalman> td123, I use gstreamer, though I don't know what's the status in haskell
08:08:47 <td123> I'm receiving pcm data and I need to play it
08:09:27 <td123> gstreamer is part of gtk2hs cool
08:10:43 <merijn> Anyone that can give a starting clue for how to define extract for Pretext (defined here: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1#a-glimpse-down-the-rabbit-hole) ?
08:11:22 <td123> doesn't look like gstreamer comes with any coded comments
08:11:35 <Lethalman> td123, usually a parse_launch is enough
08:11:43 <merijn> Actuall, I'm not even sure what the fmap for Pretext looks like...
08:12:38 <Lethalman> td123, with gst-launch command line you can test your pipelines
08:12:49 <Lethalman> then use gstparse in haskell to simply parse the string and play
08:13:54 <ClaudiusMaximus> i want to do some stuff with lazy infinite polynomials.  i found http://hackage.haskell.org/package/polynomial which looks like it has everything i need and more, but it's only for finite polynomials
08:14:10 <ClaudiusMaximus> any other packages that might be relevant?
08:14:16 <merijn> oh, wait
08:14:36 <merijn> I had a typo, I did know how to define extract :)
08:14:58 <Lethalman> td123, you should be able to feed a stream to gstreamer using appsrc with your own data, again not sure what's the status of appsrc in haskel
08:16:13 <luite> ClaudiusMaximus: hm, isn't a polynomial a finite sum by definition?
08:16:31 <quicksilver> if they're infinite they are normally called power series instead
08:16:41 <quicksilver> I don't know if there are any packages for working with them
08:16:57 <luite> of course it's just nitpicking terminology, but it might guide the package search :)
08:17:12 <dpwright> I have a type signature that looks like this: "([a] -> b -> b) -> ([a] -> b -> [a]) -> [a] -> b -> b" -- can that "[a] -> b" that appears throughout be changed into an applicative or a functor or something?
08:17:41 <applicat1ve> if i write '#if !MIN_VERSION_vector(0,10,9)
08:17:51 <alpounet> http://sigfpe.blogspot.com/2005/07/formal-power-series-and-haskell.html and http://blog.sigfpe.com/2007/11/small-combinatorial-library.html  might be relevant for power series
08:17:58 <applicat1ve> that means, for users of vector < 0.10.9 do ...
08:18:03 <applicat1ve> is that right?
08:18:08 <ClaudiusMaximus> luite, alpounet: thanks!
08:18:22 <alpounet> there are a couple for polynomials IIRC
08:18:24 <alpounet> too
08:18:35 <dpwright> I feel like there must be something I can do with it but trying to change it to "Applicative f => (f b) -> (f [a]) -> f b" doesn't work... am I on the right lines or going down a dead end?
08:18:53 <quchen> dpwright: That depends on the implementation of your function. You can always write "a → b" as "Reader a b", but that doesn't accomplish anything (apart from making the code more verbose).
08:18:55 <alexander__b> http://bpaste.net/show/135616/ -- in outputFiles I need to do count instead of output, and then I want to map show on the results just to check if I'm going in the right direction -- how would I do map show there?
08:19:05 <alexander__b> tl;dr I have outputFiles files = concatMap output <$> mapM readFile files
08:19:22 <alexander__b> I want to do "count <$> mapM readFile files"
08:19:28 <luite> if you need something for mutiplying huge multivariate polynomials i might have something, but i haven't written anything for power series :)
08:19:29 <alexander__b> and then map show to this
08:19:57 <alexander__b> or otherwise turn it into an IO String that works where with the result is being used (outputFiles input >>= putStr)
08:20:21 <dpwright> quchen: actually it's a continuation of what I was asking you about before... I tried to generalise it a bit further to see if it would lead anywhere.  I'll put up what I've got now...
08:22:04 <ClaudiusMaximus> luite: yep power series was the term i was missing
08:23:22 <alexander__b> show <$> (count <$> mapM readFile files) -- Couldn't match type `[Char]' with `Char' -- does this mean that... OK no I don't know what it means.
08:23:34 <luite> ClaudiusMaximus: what are you working on? do you need analytical or just formal properties?
08:24:14 <alexander__b> oh, so maybe outputFiles files = show <$> (mapM count <$> mapM readFile files)
08:25:09 <dpwright> http://lpaste.net/93440 (quchen)
08:25:22 <alexander__b> uhm. kind of... except... the output is tenfold what it should be. ugh.
08:25:23 <merijn> alexander__b: Why not write your function as "[String] -> ??" and then just do "mapM (fmap myFunc . readFile) files"?
08:25:35 <dpwright> I'm really just playing / exploring, and don't really know what I'm doing... but it feels like progress since last time
08:25:37 <alexander__b> merijn: which function?
08:26:04 <merijn> alexander__b: Rather than have so many fmaps, why not combine all your functions purely and at the end fmap everything in one go?
08:26:05 <alexander__b> merijn: I need to map count to all the files, then I want to do some formatting to them (add the totals and such)
08:26:33 <merijn> alexander__b: Is there any reason why you have "mapM count"? i.e. why can't count be "String -> ?"
08:26:44 <alexander__b> merijn: it is
08:26:47 <alexander__b> http://bpaste.net/show/135590/
08:26:51 <ClaudiusMaximus> luite: fractals (as usual) - there's a trick where you can approximate the n'th iteration of z->z^2+c in a small neighbourhood of c by a power series - you can calculate the coefficients of the series for n+1 from the series for n, but i think it might work to use an algorithm similar to (^) to find the n'th series coefficients in O(log n) time
08:27:12 <alexander__b> my intuition with this stuff is still not quite there... so I probably overuse/abuse fmap now that I'm starting to learn how to use it.
08:27:32 <alexander__b> merijn: oh wait wrong paste
08:27:39 <alexander__b> merijn: http://bpaste.net/show/7vdxuvlpGmkzWtOkNWOQ/
08:27:49 <alexander__b> oh
08:27:52 <alexander__b> ok my middlepaste is broken
08:28:09 <alexander__b> merijn: http://bpaste.net/show/135590/ there FFS. :-)
08:28:31 <alexander__b> OK... I give up. fml.
08:28:51 <ClaudiusMaximus> luite: to be more precise, you compute Z_n with high precision, and let d_n = z_n - Z_n, so d_0 = c - C, and you get a power series for d_n in terms of d_0
08:29:40 <merijn> alexander__b: i'll check in a sec, first tea time
08:29:58 <alexander__b> merijn: I have looked at this link ten times now. if I don't get it right now I never will: http://bpaste.net/show/135619/ THERE. line #12 I just want to map count to each file and then show the results.
08:30:04 <alexander__b> merijn: NP. sorry for the spam.
08:30:44 <luite> ClaudiusMaximus: ah, do you need to compute many terms of those to get the required precision? or is it adaptive?
08:31:39 <alexander__b> show <$> (map count <$> mapM readFile files) -- seems to accomplish what I want at least
08:32:26 <ClaudiusMaximus> luite: i've implemented single-step coefficient calculation with 3 terms, with some vague handwaving to check that the truncation isn't too inaccurate after each iteration, depends on 'C' but for deep zooms it's usually good for n around a few 1000
08:33:30 <ClaudiusMaximus> luite: but something adaptive would be a bonus - i think there are quickly diminishing returns as the coefficients start to get bigger pretty quickly, but that might be offset by the log time
08:38:04 <alexander__b> (map count <$> mapM readFile files) -- this returns an IO [[Int]] like it's supposed to. so how do I uhm do anything with it? I want to use this value for pure things.
08:38:25 <dmwit> Teach your pure things how to handle IO.
08:39:03 <alexander__b> that thing might be e.g. [[1, 2, 3], [4, 5, 6]],now I want to sum 1+4, 2+5, 3+6. I find this hard when it's impure.
08:39:25 <applicat1ve> what is the type of count?
08:39:26 <dmwit> :t \xs -> map sum . transpose <$> xs
08:39:27 <lambdabot> (Functor f, Num b) => f [[b]] -> f [b]
08:39:31 <alexander__b> applicat1ve: String -> [Int]
08:40:14 <alexander__b> dmwit: is there no way to get it out of the impure state and just... use it purely? because all this applicative syntax is starting to make my head spin so late in the day, heh.
08:40:19 <applicat1ve> countFiles :: [String] -> [[Int]] ; countFiles = map count
08:40:27 <dmwit> alexander__b: No, there is no way.
08:40:44 <dmwit> alexander__b: You don't have to use Applicative syntax if you don't want.
08:40:56 <dmwit> :t \xs -> do { v <- xs; return (map sum . transpose $ v) }
08:40:57 <lambdabot> (Monad m, Num b) => m [[b]] -> m [b]
08:41:04 <applicat1ve> what are you going to do with the [[Int]] when you get it?
08:41:36 <dmwit> :t \xs -> do { v <- xs; return . map sum . transpose $ v }
08:41:36 <lambdabot> (Monad m, Num b) => m [[b]] -> m [b]
08:41:41 <applicat1ve> oh i see, sorry I was worrying about something else
08:42:35 <alexander__b> applicat1ve: as mentioned: that thing might be e.g. [[1, 2, 3], [4, 5, 6]],now I want to sum 1+4, 2+5, 3+6. I find this hard when it's impure.
08:43:05 <merijn> alexander__b: Why not something like? http://lpaste.net/93442
08:43:16 <applicat1ve> but it should be pure , [String] -> [Int] with count and transpose in the middle.
08:43:57 <merijn> alexander__b: Of course it's starting to make your head spin, you're trying to mix things to much, resulting in way too many <$> than necessary :)
08:45:23 <alexander__b> merijn: your suggestion breaks output a bit
08:45:57 <applicat1ve> @type let moo = let count = map length . lines in map sum . transpose . map count in moo
08:45:57 <lambdabot> [String] -> [Int]
08:46:33 <dmwit> Wait, you can have records with GADT syntax? amazing
08:46:33 <alexander__b> merijn: also it does not decouple format and count so that I can easily count the totals
08:46:55 <thoughtpolice> ghch
08:47:03 <thoughtpolice> what
08:47:10 * thoughtpolice does not know what just happened to his keyboard
08:47:26 * applicat1ve 's client couldn't render it
08:47:28 <donri> dmwit: i think they're changing the syntax though
08:47:46 <Iceland_jack> donri: They are?
08:47:49 <merijn> alexander__b: Or do something like this: http://lpaste.net/93442
08:48:06 <alexander__b> merijn: actually your suggestion is pretty much what I had originally and wanted to change in order to decouple format&count and get totals, heh
08:48:29 <alexander__b> merijn: haha your new suggestion is *exactly* what I had originally
08:48:30 <merijn> donri, dmwit: Why? Hasn't the record GADT syntax been the same for ages now?
08:48:36 <donri> https://github.com/ghc/ghc/commit/9fc2778cf20990524b13705a519b0c337ad197fe
08:48:43 <donri> or maybe this was changed long ago
08:48:43 <alexander__b> oh, except my original did not break output for stdin
08:48:47 <merijn> alexander__b: Why did you change it then? :p
08:48:51 <ClaudiusMaximus> luite: nevermind, i just realized the fatal flaw :(  the coefficients for d_n = sum a_n,i d_0^i have a dependency on the Z_n, and truncating that series will fail as C >> 0
08:48:57 <alexander__b> merijn: because I want to count total values
08:49:23 <merijn> alexander__b: oh, then change zipWith to a fold over filename/content tuples?
08:49:29 <alexander__b> merijn: right now it will output "chars  words  lines\n" per file, I want to add "total:  chars  words  lines" at the end
08:49:52 <merijn> alexander__b: Actually, this sounds like a job for! The State monad!
08:50:41 <alexander__b> merijn: here is my last git commit: http://bpaste.net/show/135623/ in here everything works -- so I just wanna add "total: ..." output to it.
08:50:55 <alexander__b> notice how I don't abuse <$> too much there :-P
08:51:54 <alexander__b> but my imperative mind is having a hard time understanding how I keep track of totals except for decoupling formatting and counting a lot, which was what I was trying. I am not familiar with the state monad, and am still in the beginning stages of learning haskell I think.
08:52:19 <luite> ClaudiusMaximus: oh you need to compute much wich an absolute value close to or greater than one?
08:52:26 <luite> with
08:53:29 <merijn> alexander__b: The State monad simulates state by adding an extra input and output argument to a function and letting you conveniently update those
08:54:20 <ClaudiusMaximus> luite: the flaw is bascially assuming i have f(f(f(...f(d_0)...))) = f^n(d_0) when in fact each f is different
08:54:22 <applicat1ve> funny, the revolting accessors in the GADT record are almost type-safe, but for the If constructor. Pair {arg1 :: a, arg2::b} -> Term a b;
08:54:54 <merijn> > let inc = do { x <- get; put (x+1); return x } in runState (inc >> inc >> inc) 3
08:54:56 <lambdabot>   (5,6)
08:54:56 <applicat1ve>  Pair {arg1 :: a, arg2::b} -> Term (a, b)  rather
08:55:13 <luite> ClaudiusMaximus: ah okay
08:55:22 <merijn> > let inc = do { x <- get; put (x+1); return x } in execState (inc >> inc >> inc) 3
08:55:23 <lambdabot>   6
08:55:59 <merijn> > let inc = do { x <- get; put (x+1); return x } in runState (sequence . replicate $ inc >> inc >> inc) 3
08:56:00 <lambdabot>   Couldn't match type `a1 -> [a1]'
08:56:00 <lambdabot>                with `[Control.Monad.Trans....
08:56:03 <merijn> whoops
08:56:26 <merijn> > let inc = do { x <- get; put (x+1); return x } in runState (sequence (replicate 5 inc)) 3
08:56:27 <lambdabot>   ([3,4,5,6,7],8)
08:56:48 <merijn> > let inc = do { x <- get; put (x+1); return x } in execState (sequence (replicate 5 inc)) 3
08:56:49 <lambdabot>   8
08:57:05 <luite> ClaudiusMaximus: well i got to run to the airport to get some lunch. i'm looking forward to seeing your results, they tend to be pretty :)
08:57:07 <merijn> alexander__b: You might want to read the LYAH chapter on State to see what's going on :)
09:04:09 <danilo2> Hello :) I've got a question. I'm writing a Parsec parser and I would like to ask you - how would you generalize this code to work over an array of fields: "pTest fields@(field1:field2:fieldrest) = (.) <$> (Expr.addField <$> field1) <*> (Expr.addField <$> field12)" ?
09:06:28 <danilo2> where field1 = basefield1 <$> genID
09:06:36 <danilo2> etc
09:13:08 <sclv> chair's report from the haskell symposium has been posted to reddit btw: http://www.reddit.com/r/haskell/comments/1n5wav/haskell_symposium_program_chair_report_by/
09:13:14 <sclv> normally i'm against trolling for upvotes
09:13:26 <sclv> but i feel like its really important ppl show they endorse this
09:13:29 <dmwit> cabal --version says it's 1.16.0.2 using Cabal-1.16.0, but when I "cabal configure -v3", I see "Using Cabal library version 1.18.1" right before it builds Setup.hs. Why is this? How can I ask cabal-install to use a different Cabal?
09:15:03 <RaceMatters> L o O o O o O o O o O o O o O o O o O o O o O o O o O o O o O o O o O o O L
09:15:05 <supki> dmwit: cabal has --cabal-lib-version option
09:17:02 <elliott> sclv: logged in to reddit for the first time in months to upvote :)
09:17:02 <dmwit> supki: thanks
09:17:41 <dmwit> supki: What does the Cabal-1.16.0 mean in cabal --version if that's not the library it's going to use to build Setup.hs?
09:17:49 <RaceMatters> Justin Bieber is gay
09:17:53 <dmwit> ?where ops
09:17:54 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
09:17:54 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:18:02 --- mode: ChanServ set +o geekosaur
09:18:03 --- mode: ChanServ set +o glguy
09:18:10 --- mode: geekosaur set +b *!*RaceMatte@*.dl2music.com
09:18:10 --- kick: RaceMatters was kicked by geekosaur (RaceMatters)
09:18:25 <geekosaur> was waiting for that, but was also working...
09:18:37 <dmwit> thanks
09:18:52 * elliott gets a cunning plan: configure my IRC client to automatically op on @where ops if I've talked in the past five minutes.
09:18:54 --- mode: geekosaur set -o geekosaur
09:19:12 <elliott> and maybe auto-focus the window!
09:19:15 --- mode: glguy set -o glguy
09:20:12 <ocharles> elliott: and maybe make it auto kick everyone to be on the safe side if you're out of the room!
09:20:35 <elliott> I should just set up a script to /msg chanserv clear users every five minutes.
09:20:36 <elliott> just in case.
09:21:01 <ocharles> well we do want to avoid success at all costs
09:21:19 <supki> dmwit: I think it's the version cabal-install executable was built with
09:22:05 <quicksilver> elliott: opping doesn't save much time though
09:22:21 <haasn> elliott: make it recognize who's spamming and auto-ban, too
09:22:44 <dmwit> supki: I guess it must be. I'm just wondering what impact it has. Perhaps too much impact to summarize in a few lines of IRC, though. =P
09:23:05 <dmwit> supki: Oh, maybe it affects what happens for non-Custom buildtypes.
09:25:29 <ParahSailin> looks like aeson broke compatibility with something: "No instance for (FromJSON (V.Vector Value))"
09:26:07 <Cale> sclv: What is that article referring to? This seems to be a report about papers submitted to some conference, but then also something about prejudice? Is there some kind of context I'm missing?
09:26:23 <sclv> its the chair's report from the haskell symposium
09:26:32 <sclv> they traditionally talk about where papers are from and what are accepted
09:26:40 <sclv> and percentages of acceptance etc and topics
09:27:07 <sclv> and this time ken decided he'd talk about papers coming disproportionately not from women, minorities, etc.
09:27:13 <sclv> and that this is the 'tip of the iceberg'
09:27:21 <sclv> i.e. not about the haskell community per se
09:27:23 <sclv> but the world of cs
09:27:26 <sclv> and the world outside of cs
09:27:46 <sclv> but also that this is something that we should feel that we should acknowledge, and talk about how to change
09:28:02 <pratz> Hello guys
09:28:03 <Cale> It make it seem like there was some kind of problem with the paper acceptance process that was being danced around.
09:28:04 <applicat1ve> the trouble with this is that it looks like another attack on D. Swierstra
09:28:15 <pratz> I have just started learning haskell
09:28:21 <Cale> pratz: welcome!
09:28:22 <applicat1ve> hi pratz
09:28:24 <pratz> had a basic query
09:28:55 <Cale> pratz: Sure, that's what we're here for. Feel free to ask any questions you might have.
09:29:13 <pratz> python - consider I have a file like object, so when i do file.size or file.something I get the information of that perticular file. How achieve the same in haskell ?
09:29:16 <ParahSailin> i've been saving my broken .ghc directories every time i re-cabal
09:29:22 <ParahSailin> im up to 20 now
09:29:35 <sclv> applicat1ve: D. responded very well, eventually to that whole thing.
09:29:43 <sclv> but the discussion thread itself revealed lots of problems
09:29:49 <sclv> and also its a broader issue regardless
09:30:08 <sclv> like within hard sciences, CS is bad. within CS, FP is worse.
09:30:09 <applicat1ve> sclv: i thought the thread was proven to be a horrible injustice to him.
09:30:17 <Cale> pratz: There's a bunch of stuff in System.Directory for querying the filesystem. I'm not sure there's a cross-platform way to ask about file size (though I might be wrong about that)
09:30:32 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html
09:30:34 <danilo2> Hello :) I've got a question. I'm writing a Parsec parser and I would like to ask you - how would you generalize this code to work over an array of fields: "pTest fields@(field1:field2:fieldrest) = (.) <$> (Expr.addField <$> field1) <*> (Expr.addField <$> field2)" ?
09:30:39 <sclv> it turned in my mind into a larger debate over if these are serious issues at all to begin with
09:30:40 <danilo2> where field1 = basefield1 <$> genID, etc :)
09:30:48 <sclv> not just what he meant in one offhand comment
09:31:04 <sclv> so its not about the thread or d at all this discussion
09:31:06 <acomar> pratz- readFile is a function to lazily read the contents of a file into a string, and then you can use the standard string functions to figure out things like length
09:31:09 <sclv> and i'd hate for it to go back there
09:31:18 <sclv> its about us recognizing more broadly that the proportions are bad
09:31:23 <applicat1ve> Swierstra? he was attempting to say the same as Shan, but the baboons in the audience made it seem the opposite
09:31:25 <sclv> and that maybe we should do something about that
09:31:33 <sclv> applicat1ve: chill out about that thread!
09:31:33 <Cale> There's also System.Posix.Files if you'd like to avoid reading the contents of the files to get their size. http://www.haskell.org/ghc/docs/6.10.3/html/libraries/unix/System-Posix-Files.html#t%3AFileStatus
09:31:47 <sclv> Shan didn't mention swiestra at all in his chairs report
09:31:52 <sclv> which i think was a good report
09:32:08 <sclv> so if it becomes another stupid argument over something that was said over a year ago
09:32:16 <sclv> and that we yelled at eachother about on reddit for another good two weeks
09:32:19 * elliott sigh.
09:32:25 <sclv> then that would be a waste of a productive discussion
09:32:35 <sclv> which is much bigger
09:33:42 <Cale> sclv: Why do you think there's a problem with prejudice in FP specifically? I haven't noticed any. Maybe there's gender bias and so on, but is that a problem with the way the community works? I think we're very much oblivious to gender, race, etc. here.
09:34:02 <sclv> i don't know if there's a problem with prejudice writ large
09:34:06 <sclv> i know there's a problem with ratios
09:34:26 <sclv> the 'worst to worser' thing i gave was really about ratios, not attitudes
09:34:28 <merijn> sclv: I think your original formulation is...maybe not wrong, but not one I like
09:34:33 <sclv> everyone in the haskell world is super nice
09:34:35 <lightquake> i'm making a toy symbolic algebra REPL, which consists of the parse/evaluate/whatever library and a simple program that actually drives the REPL. do i want to tell cabal init that this is a library or an executable?
09:34:52 <sclv> but its just a very… skewed demographic
09:34:55 <Cale> I'm not sure that there is... relative to the ratios of the people in the general population in the areas where FP is popular? I don't know.
09:35:02 <Iceland_jack> sclv: I'll agree to that
09:35:11 <pratz> Cale: is my question wrong
09:35:16 <sclv> certainly genderwise its worse even than more obviously problematic communities like ruby
09:35:24 <sclv> so i just think we should care about that
09:35:27 <applicat1ve> yes
09:35:31 <merijn> sclv: You mentioned "needing to change the ratio" (of women/minorities/etc), I think striving for "better" ratios is the wrong approach
09:35:33 <Cale> pratz: Well, what program are you trying to write?
09:35:43 <sclv> well i think if we strive to be better
09:35:44 <arnsholt> Part of the problem with things like this is that even if people don't *think* they're treating people differently, they actually are
09:35:46 <sclv> we'll see better ratios
09:35:48 <merijn> sclv: I think the thing to do is striving for reducing friction and barriers
09:35:51 <sclv> i don't know what striving to be better means
09:35:55 <sclv> merijn: sure
09:36:16 <sclv> its not about having the solution yet. its about frankly saying that there's something wrong
09:36:22 <sclv> and not trying to point fingers either
09:36:30 <Iceland_jack> arnsholt: Prejudiced people rarely think of themselves as such, that's the tricky part
09:36:31 <acomar> sclv: I think that's generally the problem -- everyone can get behind "let's do it better" but if no one can point to something in specific, you end up going in circles
09:36:47 <merijn> sclv: That formulation is less likely to rub people (like me) who dislike prescriptivism (i.e. "the ratio of minorities/women/etc. should be X")
09:36:54 <pratz> Cale: take a simpel example- I want to write a function which accepts a string, how that function should provide few other function like len of string etc ...
09:36:59 <pratz> *simple
09:37:06 <sclv> acomar: yeah well on the other hand pretending there is no problem isn't a lot of fun either
09:37:13 <acomar> sclv: totally agree
09:37:25 <merijn> sclv: As opposed to "we should reduce/remove barrier/friction point X"
09:37:27 <dmwit> lightquake: Tell cabal init whatever you want. Then put in both a library and an executable stanza yourself afterwards.
09:37:29 <pratz> Cale: /how/now
09:37:35 <sclv> honestly even acknowledging things like this makes us, i think, more welcoming to v/a ppl who would otherwise feel precisely friction and barriers
09:37:56 <sclv> because at least they won't feel that ppl are _happy_ about the ratios!
09:38:23 <Cale> pratz: You can tuple a bunch of results together if you like, or make a datatype for them...
09:38:42 <Cale> pratz: But it's not really clear what to suggest without a bigger picture of what you want your program to do.
09:39:11 <dmwit> danilo2: Perhaps you will be interesting in mapM or zipWithM.
09:39:57 <danilo2> dmwit: I know mapM and zipWithM, but I cannto simpel to figure this one out :(
09:40:26 <Cale> pratz: e.g. it's easy to write a function  wc x = (length x, length (words x), length (lines x)), but is this the sort of thing you're looking for?
09:40:26 <dmwit> danilo2: Okay. Well, I'm not sure I understood the question yet. Perhaps you could paste some code showing your attempt.
09:40:30 <dmwit> ?hpaste
09:40:30 <lambdabot> Haskell pastebin: http://lpaste.net/
09:41:01 <Cale> pratz: You'd probably be better off with separate functions usually, rather than one which returns a triple of otherwise independently computed values.
09:41:26 <merijn> Cale: I think he wants to fake objects? Which is probably a bad idea, but the reflex can be deeply ingrained
09:42:05 <dmwit> pratz: My take is that it will be beneficial to you to attempt to learn Haskell instead of attempting to learn how to use Haskell as if it were Python.
09:42:14 <Cale> Well, if you really want objects, you can encode them in Haskell in I think a way which is truer to OO than most typed OO languages are.
09:42:30 <acomar> Cale- that's kinda counter productive for someone just getting started
09:42:34 <merijn> Cale: Sure, I know, but I don't think beginners should do that :)
09:42:46 <Bram> hey, I've apparently managed "the impossible": "ghc: panic! (the 'impossible' happened)" doing something like this (if you want to reproduce) http://paste.debian.net/46494, should I really report a bug?
09:43:02 <Bram> the error is "deriving (eq)" instead of "deriving (Eq)"
09:43:11 <dmwit> Bram: That's a known (and fixed) bug.
09:43:20 <dmwit> Bram: Upgrade GHC, or Don't Do That. =)
09:43:41 <Bram> dmwit: 2 seems better :p
09:43:44 <dmwit> Bram: But the short answer is always "yes, report a bug", where "report a bug" includes checking to see if it has already been reported.
09:44:03 <Bram> (I'm running ubuntu LTS haskell 7.4.1)
09:44:25 <dmwit> s/haskell/GHC/
09:44:26 <Bram> dmwit: ok, never sure how serious those requests are
09:44:28 <Bram> thx
09:44:31 <Bram> indeed
09:44:44 <dmwit> very serious
09:44:49 <Cale> Well, the nice thing is that the result can also be interpreted as normal functional programming: you build records of functions/values which you can think of as the public methods or messages that your objects respond to, and have "constructors" which are functions whose parameters are the private bits of the objects you're defining, and then use those constructors recursively in response to many messages to give new
09:44:49 <Cale> objects.
09:44:50 <dmwit> Crashes are step 1 in creating an exploit.
09:45:17 <Bram> I see
09:47:36 <acomar> how would you guys approach this problem --
09:47:50 <Cale> (This doesn't give you inheritance, but imo, inheritance and subtyping are red herrings. The key point about OO at least in my head is that you have values which are determined by their responses to messages.)
09:47:56 <acomar> I have a dynamic data type (accessed through the ffi) that I'd like to make a little more type safe via a type alias
09:48:00 <danilo2> dmwit: I've got list of fields, which are simple constructors. Each has got id, so I'm generating the ids like "nid a = a <$> newID".  To create field adding parser combinator I'm writing: (.) <$> (Expr.addField <$> nid field1) <*> (Expr.addField <$> nid field2).
09:48:05 <danilo2> dmwit: This function outputs (m Expr). So I've got lsit of fields with ids ([m Expr]) and I need a function (m Expr->m Expr -> m Expr) -> [m Expr] -> m Expr, which will behave like this one I provided for 2 values
09:48:30 <acomar> it's a Matrix and I want to track the channels and dimensions in the type (there's only a few of each that I need to worry about)
09:48:53 <dmwit> :t foldM
09:48:54 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:49:01 <dmwit> danilo2: ?
09:49:06 <mcstar> whats the hot new haskell way of drawing regular shapes (interactively, possible in multiple windows) in haskell?
09:49:07 <Cale> acomar: It's easy enough to make a newtype which has phantom type parameters
09:49:09 <acomar> a data declaration gives me multiple constructors, but I can't see that at the type level
09:49:17 <acomar> right, I'm getting to the issue
09:49:20 <Cale> mcstar: There's gloss
09:49:26 <mcstar> other than that?
09:49:44 <mcstar> Cale: it doesnt handle window closing really well, and i want to use this from ghci
09:49:49 <Cale> Well, I would normally recommend diagrams, but I'm not sure how easy it is to use diagrams interactively.
09:50:01 <danilo2> dmwit: heh :) ok, I'll try to figure it out. If I will not suceed, I'll be back with an example :)
09:50:02 <acomar> so how can I restrict what goes into the type parameters to just a few options (that I can ideally pattern match on)
09:50:35 <dmwit> acomar: GADTs!
09:50:45 <mcstar> Cale: i would like to be able to pan/zoom, even if the scene cant be interactively updated
09:50:48 <acomar> dmwit: how would that work?
09:50:53 <merijn> acomar: You can see different constructors at the type level using GADTs!
09:51:02 <merijn> GADTs <3
09:51:04 <mcstar> GADTs!
09:51:05 <acomar> really
09:51:15 <acomar> I'll have to read up on that, I had no idea
09:51:23 <merijn> acomar: There's a nice explanation at https://en.wikibooks.org/wiki/Haskell/GADT
09:51:31 <dmwit> acomar: data CanOnlyBeAOrB a where MkA :: CanOnlyBeAOrB A; MkB :: CanOnlyBeAOrB B
09:51:52 <merijn> dmwit: Needs more KindSignatures
09:52:10 <acomar> dmwit: and I can tell apart MkA versus MkB at the type level so functions can restrict their operation to one or the other?
09:52:18 <dmwit> acomar: correct
09:52:23 <acomar> awesome!
09:52:44 <dmwit> acomar: foo :: CanOnlyBeAOrB A -> Bar need only pattern match on MkA's; it's clear that it will never be handed a MkB
09:52:48 <merijn> acomar: I had something similar to distinguish Control vs Data records, see: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs#L25-L36
09:52:54 <Cale> mcstar: Well, it can make SVGs. Also, there does seem to be a diagrams-gtk package for rendering directly to GTK windows.
09:52:58 <mcstar> acomar: what did you mean by 'channel'?
09:53:11 <mcstar> Cale: ill look that up
09:53:16 <acomar> mcstar: RGB, BGR, Grayscale, etc.
09:53:21 <mcstar> ah, ok
09:53:26 <dmwit> ?hoogle (m Expr -> m Expr -> m Expr) -> [m Expr] -> m Expr
09:53:26 <lambdabot> Warning: Unknown type Expr
09:53:26 <lambdabot> No results found
09:53:31 <dmwit> too bad
09:53:46 <merijn> Looks like a monadic fold, maybe monad-loops?
09:53:59 <dmwit> It's foldM.
09:54:02 <donri> acomar: you can even go crazy and forbid anything other than CanOnlyBeAOrB A or CanOnlyBeAOrB B with DataKinds ;)
09:54:10 <dmwit> Which I already said. I just wanted to see if Hoogle could answer for me.
09:54:26 <acomar> donri: I actually thought that was the route I'd *have* to go, I'm glad to hear there's a step down from that
09:54:31 <merijn> dmwit: Expr messed it up
09:55:02 <merijn> @hoogle (m a -> m a -> m a) -> [m a] -> m a
09:55:02 <dmwit> ?hoogle (m expr -> m expr -> m expr) -> [m expr] -> m expr
09:55:02 <lambdabot> No results found
09:55:02 <lambdabot> No results found
09:55:08 <dmwit> merijn: no it didn't =)
09:55:11 <merijn> :t foldM
09:55:12 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:55:12 <donri> acomar: well with only GADTs you can make it impossible to construct values of any other type except bottom. with DataKinds you can make even bottoms a kind-mismatch at compile-time.
09:55:24 <merijn> dmwit: foldM isn't right, though
09:55:39 <dmwit> Yes, the proposed type is missing one argument compared to foldM.
09:55:40 <merijn> dmwit: Well, maybe with some Applicative juice
09:55:46 <donri> acomar: DataKinds are easy, but they may well be overkill for your use, i have no idea
09:55:58 <dmwit> But Hoogle can usually deal with one missing argument.
09:56:05 <acomar> donri: I'll ask you for details in a moment once I've absorbed the use of GADTs here
09:56:24 <acomar> donri: I'm not sure it is overkill, but then I'm relatively new at this
09:56:25 <dmwit> Applicative is not needed or helpful. You need Monad.
09:56:48 <joelteon> > let in ()
09:56:49 <lambdabot>   ()
09:57:04 <merijn> Oh, wait I guess monad already has ap
09:57:21 <haasn> > let in don't do ()
09:57:21 <lambdabot>   <hint>:1:14: parse error on input `do'
09:57:24 <haasn> :(
09:57:27 <dmwit> ap isn't enough.
09:57:31 <joelteon> > let let' = let in "in" in let'
09:57:32 <merijn> acomar: It might be overkill, but it's cool educational overkill, so you should look into it anyway
09:57:32 <lambdabot>   "in"
09:57:33 <dmwit> But it's irrelevant.
09:57:41 <acomar> merijn: :D
09:57:45 <donri> acomar: oh this is for tracking dimensions of a matrix in the types? you may even want to go nuts with TypeLits ;)
09:57:49 <dmwit> You're talking about how to construct the argument to foldM, and the Hoogle query doesn't need to answer that question.
09:58:12 <merijn> donri: TypeLits is part of DataKinds
09:58:14 <acomar> donri: I'd love to track the rows cols and such that way so I can provide a usable Num instance
09:58:27 <acomar> donri: but how's the type level arithmetic in ghc 7.6?
09:58:31 <donri> merijn: yes, but it's a module so kind (hah) of separate
09:58:56 <merijn> acomar: Basically, you know how all types have kind *? DataKinds lets you create new types with a specific kind (by lifting values)
09:59:04 <donri> acomar: not sure you can have type-level Num instances. you get basic arithmetic type families on natural numbers
09:59:05 <dmwit> acomar: Type level arithmetic is there, but type level equalities are all syntactic still as far as I know.
09:59:17 <acomar> merijn: yea, I know the basics, I've just never actually made use of DataKinds
09:59:19 <dmwit> acomar: e.g. m+n ~ n+m still isn't a fact that GHC knows
09:59:34 <merijn> acomar: i.e. you can for example lift Maybe to the type level so you can get "Just Int :: Maybe *" and "Nothing :: Maybe *" :)
09:59:37 <Sornaensis> hi
09:59:50 <Sornaensis> does anyone here get paid to write haskell
09:59:52 <acomar> donri: not type level Num instances, you just can't multiply two matrices unless the cols match the rows
10:00:00 <acomar> and it's nonsensical to try
10:00:08 <dmwit> Sornaensis: You might like the Haskell in Industry wiki page.
10:00:09 <acomar> it'd be nice to forbid that at the type level
10:00:30 <merijn> acomar: You can certainly do that using type level equality :)
10:00:34 <Sornaensis> hm
10:00:36 <donri> acomar: aha. well see what dmwit was saying.
10:00:36 <Maior> did I hear someone say Agda?
10:00:47 <merijn> acomar: Also, closed type families in 7.8 will help with that stuff :)
10:00:54 <dmwit> acomar: To be honest, that doesn't even seem to require anything special. Just give foo the type Matrix m n -> Matrix n p -> Matrix m p or whatever.
10:01:43 <merijn> "data Matrix (n :: Nat) (m :: Nat) where Matrix ..."
10:01:45 <dmwit> acomar: It's getting the arguments to foo to have the appropriate type that's going to be tripping you up.
10:01:47 <acomar> dmwit: ahh, but what about when you have operations that change the structure of the matrix in there, so you end up with something like Mat m (k+r=n)
10:01:52 <merijn> dmwit: Needs some lifting to Nat, though
10:01:53 <ReinH> oh hai
10:01:59 <dmwit> acomar: exactly
10:02:10 <haasn> merijn: now we just need indexed categories :)
10:02:28 <acomar> dmwit: so that's why I don't want to go down that route quite yet
10:02:42 <merijn> haasn: We don't even have support for indexed monads yet :(
10:02:48 <acomar> I was just planning to provide a way to track 2D versus 3D and a few different channel representations
10:02:54 <dmwit> merijn: I haven't the faintest idea what "lifting to Nat" means.
10:02:55 <merijn> haasn: (syntactically, anyway)
10:03:02 <Cale> Sornaensis: I am
10:03:10 <haasn> merijn: not even with RebindableSyntax?
10:03:22 <merijn> dmwit: If you want properly kinded sizes, I mean
10:03:38 <merijn> dmwit: Because, how would I specify what type a 10 by 50 matrix has?
10:03:40 <dmwit> merijn: That's a question of how Matrix is defined, not how the type signature of foo looks.
10:03:42 <Cale> Sornaensis: I'm working for skedge.me on their web application backend, which is written in Haskell using Snap.
10:03:55 <Sornaensis> cool
10:03:58 <merijn> dmwit: Oh, sure :)
10:04:21 <merijn> Sornaensis: I was paid to write haskell not too long ago :)
10:04:31 <haasn> merijn: but can you write id :: Matrix n n -- ?
10:04:41 <merijn> Although I'm not sure the people paying were aware of that ;)
10:04:49 <haasn> I've earned money by writing Haskell!
10:04:56 <merijn> haasn: What do you mean by "can you write that"?
10:05:14 <dmwit> haasn: That seems plausible, assuming n is appropriately-kinded. If not, it still seems plausible with a bit of a typeclass context.
10:05:17 <mightybyte> Sornaensis: I also work full-time for a company writing Haskell.
10:05:57 <merijn> Sornaensis: I "know" (for values of know that mean "talked too") a bunch of people at Intel doing Haskell
10:05:58 <haasn> merijn: well consider the simpler case of Vec :: Nat -> * -> *; is it possible to write replicate :: forall n a. a -> Vec n a
10:06:15 <merijn> haasn: No :(
10:06:18 <Sornaensis> ah I see
10:07:04 <merijn> haasn: At least not with a value level representation of n
10:07:07 <dmwit> replicate :: Replicate n => a -> Vec n a -- along with a very simple proof that all Nat's are instances of Replicate
10:07:14 <merijn> haasn: In other words, wtb Agda
10:07:59 <dmwit> Y'all might like the paper "Dependently typed programming in Haskell".
10:08:01 <mcstar> i was paid to write haskell too
10:08:04 <donri> Sornaensis: facebook does haskell and hired the best minds for it
10:08:06 <ReinH> haasn: so I actually went back to the case statement because the ala Max, while clever, seemed less immediate and intention revealing.
10:08:14 <haasn> merijn: what about sing :: forall (n :: Nat). Sing n -- ?
10:08:30 <ReinH> haasn: I do really wish semigroups were first-class citizens like monoids though :/
10:08:33 <merijn> haasn: Might work, not sure
10:08:36 <dmwit> Oops, I mean "Dependently typed programming with singletons".
10:08:46 <merijn> dmwit: I seens it
10:08:52 <ReinH> There are so many useful semigroups that are not monoids
10:09:21 <danilo2> Is there any predefined function like " f (b -> c) -> f (a -> b) -> f (a -> c)"  (like function composition, but in monad)? If not, can we write it nicer than: "mp a b = (.) <$> a <*> b" ?
10:09:22 <haasn> dmwit: oh, good point re: Replicate
10:09:53 <dmwit> danilo2: liftA2 (.)
10:10:18 <merijn> dmwit: I'm imagining a sassy black women going "Y'all mother fuckers need dependent types!" :)
10:10:33 <dmwit> Eeeexcellent. =D
10:10:42 <dmwit> (Who says you can't transmit tone by text?)
10:11:06 <merijn> dmwit: Even C99 had (extremely limited!) dependent types!
10:11:23 <danilo2> dmwit: Thank you!
10:11:32 <dmwit> merijn: err?
10:12:13 <merijn> dmwit: It's true! They made it optional in C11, since no one implemented it because it was too hard
10:13:31 <acomar> hmm... I think DataKinds lets me give the representation I want a little more cleanly -- the extra phantom parameter required with GADTs isn't easy to track
10:14:11 <merijn> acomar: With DataKinds (and KindSignatures) you can even constrain the phantom type to only allow certain values!
10:14:28 <acomar> merijn: that's actually exactly what I want to do for the newtype wrapper
10:14:31 <merijn> acomar: see my earlier github link :)
10:14:37 <acomar> oh sorry, I missed that
10:15:13 <merijn> acomar: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs#L25-L36
10:15:29 <acomar> awesome, thank you
10:15:34 <merijn> acomar: The kind signature on the variable of Record means it can only have two values, anything else is a type error
10:15:58 <merijn> i.e. "Record String" is not allowed, since String :: * and not RecType
10:16:04 <dmwit> merijn: Okay, looking around online a bit it seems you're probably referring to arrays whose length is determined statically. I don't know the extend of C99's type-checking requirements, but if GHC extensions have taught us anything it's that statically-checked dynamically-sized arrays don't require true dependent types.
10:17:12 <merijn> dmwit: Yeah, "int foo(int i) { char myArray[i]; return (sizeof myArray); }" it's a dependent type because the type of myArray depends on the runtime value i
10:17:52 <dmwit> Though I probably won't fight too hard against "hard to implement". =P
10:18:21 <mcstar> why isnt char myArray[i] a 'dependent type' even if i is known statically?
10:18:53 <dmwit> mcstar: It just depends how the type system is set up.
10:19:03 <acomar> ok, here's what I'm thinking: http://lpaste.net/93446
10:19:09 <dmwit> mcstar: You can set up a non-dependent system that allows arrays with statically-known sizes, is the point.
10:19:31 <acomar> so now I can write a function like convert :: Mat d RGB e -> Mat d BGR e
10:19:43 <dmwit> mcstar: You can also set up a system with dependent arrays and get arrays with statically-known sizes for free.
10:20:09 <dmwit> mcstar: Presumably the former would be simpler. Though I don't know for sure.
10:20:16 <acomar> and I still have access to RGB as a normal type constructor so I can provide a witness at the value level?
10:20:46 <mcstar> dmwit: my point is only that, if the size is not known statically, or cannot be deduces, for example, depends on an input parameter, how could the program be still type safe? (i think it wouldnt typecheck)
10:20:56 <mcstar> deduced*
10:21:13 <dmwit> mcstar: Define "type safe".
10:21:40 <mcstar> no type error at runtime
10:21:51 <dmwit> What is a type error at runtime?
10:21:58 <mcstar> eyah, thats tricky :)
10:22:03 <mcstar> i sais, it woudlnt typecheck
10:22:34 <dmwit> You say it wouldn't type-check. I say your type system isn't exciting enough yet to check it.
10:23:09 <mcstar> ok, so dependent types work, even if the value they depend on only known at run-time?
10:23:17 <dmwit> correct
10:23:23 <mcstar> ok, thanks
10:23:52 <dmwit> Interested? =)
10:24:03 <mcstar> well, it sounds interesting...
10:24:15 <mcstar> but im not interested in it atm :)
10:24:21 <dmwit> okay =)
10:24:36 <enthropy> acomar: I don't believe you get any connection between the 'RGB (promoted) and the original RGB
10:24:54 <acomar> enthropy: Oh really?
10:25:26 <dmwit> enthropy: Perhaps he doesn't need one to write convert :: Mat d RGB e -> Mat d BGR e
10:25:54 <acomar> I need to be able to pass at witness at construction though, don't I?
10:25:58 <enthropy> well they have the same name... but there's no SingE/SingI instance to get an RGB out of a (proxy 'RGB)
10:26:09 <acomar> check my editted paste: http://lpaste.net/93446
10:26:15 <enthropy> no you just ask for a type signature / function that has a restricted type
10:26:26 <dmwit> enthropy: Perhaps you're hoping he will write convert :: Mat d c e -> Mat d c' e eventually. Then he'll need a connection.
10:26:28 <enthropy> acomar: https://github.com/acowley/HOpenCV takes that approach
10:26:34 <dmwit> But for monomorphic choices of c and c', probably not.
10:27:22 <acomar> dmwit: I'd love to be able to write that
10:27:29 <enthropy> https://github.com/acowley/HOpenCV/blob/master/src/OpenCV/ColorConversion.hs
10:27:44 <dmwit> acomar: Oh. Well, then you should pay attention to what enthropy is telling you. =P
10:28:03 <enthropy> actually there's no distinction between RGB, BGR or other random orders in HOpenCV
10:28:07 <acomar> dmwit: I am :)
10:28:52 <enthropy> but it does do that for color/monochrome
10:29:53 <dmwit> acomar: (And, by the way, GADTs are another way to get the connection enthropy is suggesting you need.)
10:30:07 <acomar> dmwit: can you expand on that?
10:30:35 <dmwit> I think I did already? You can have data Matrix c where MatrixRGB :: CMatrix -> Matrix RGB; Matrix BGR :: CMatrix -> Matrix BGR
10:30:56 <acomar> oh I see
10:31:44 <enthropy> that looks like it will make lots of operations a pain
10:31:52 <enthropy> most don't care about what color order you have
10:31:53 <dmwit> Probably.
10:32:02 <acomar> yea, exactly
10:32:52 <ReinH> Has Colour been mentioned yet?
10:32:55 <ReinH> @hackage colour
10:32:55 <lambdabot> http://hackage.haskell.org/package/colour
10:32:56 <enthropy> if there are only a couple functions that care, you can have    class F1 color where f1 :: Matrix color -> Matrix color;  instance F1 RGB; instance F1 BGR
10:33:00 <dmwit> Well. You only have to write the colorless function once.
10:33:19 <dmwit> foo :: (CMatrix -> CMatrix) -> Matrix c -> Matrix c
10:33:29 <dmwit> unsafeFoo if you prefer =)
10:33:51 <enthropy> so is there a difference between the gadt method and the F1 class?
10:34:16 <dmwit> Yes, singletons are better when you want to dispatch on return type as he wants to with convert.
10:34:21 * enthropy guesses you can end up with less type annotations with GADTs
10:34:54 <acomar> hmm... I think I'm just going to have to write out a few functions
10:35:01 <acomar> before I understand the distinctions being made
10:35:27 <dmwit> enthropy: I'm not so sure about that, to be honest.
10:35:32 <acomar> enthropy: the approach you linked is probably what I'll have to fall back to, I was just hoping to write those functions without sticking the types in the name of the functions is all
10:35:59 <haasn> colour++
10:36:39 <dmwit> acomar: I think he has the types in the names because Mono/Tri isn't a fine enough distinction for all the conversions he's writing.
10:36:41 <ReinH> I don't understand why anyone would ever write a color manipulation function ever again when Colour exists ;)
10:36:49 <acomar> ReinH, haasn: the issue is that OpenCV provides its own implementation of color spaces
10:36:51 <dmwit> You should not need to put the types in your names if you don't want to.
10:37:19 <dmwit> ReinH: Who says anybody's writing a color manipulation function? acomar is writing a matrix manipulation function.
10:37:20 <ReinH> acomar: oh good
10:37:22 <acomar> I'm not writing my own color manipulation functions, I want to track the color space at the type level to type check the dynamically typed code that's actually getting run
10:37:26 <ReinH> dmwit: ok :)
10:37:40 <ReinH> gotcha
10:38:13 <acomar> it's one of the huge pain points when you use the library extensively -- the matrices change on you and you get weird bugs popping up
10:38:21 <acomar> that some type checking would reveal immediately
10:38:29 <ikarus> Erm, I know this is blasphemy, but for an algorithm I need to get several infinite random lists of numbers, preferably without exposing that code for the horror of monads (at that level I just want to see infinite lists)
10:38:47 <dmwit> ikarus: Use split and randoms/randomRs.
10:39:04 <ikarus> dmwit: any example code I can look at for that ?
10:39:18 <acomar> and dmwit: to be fair, I don't intend to write any matrix manipulation code either :)
10:39:20 <aristid> ikarus: why do you think it is blasphemy?
10:39:24 <enthropy> dmwit: true, you need the type signature with the gadt http://lpaste.net/93448
10:39:35 <dmwit> :t \g -> let (g1, g2) = split g in (randoms g1, randomRs (1,10) g2)
10:39:36 <lambdabot>     Couldn't match expected type `(g0, g1)'
10:39:37 <lambdabot>                 with actual type `[a0] -> [[a0]]'
10:39:37 <lambdabot>     In the return type of a call of `split'
10:39:37 <enthropy> both functions end up being 3 lines
10:39:47 <ikarus> aristid: because randomness is impure
10:40:07 <dmwit> :t \g -> let (g1, g2) = System.Random.split g in (randoms g1, randomRs (1,10) g2)
10:40:08 <lambdabot> (Num a1, RandomGen g, Random a, Random a1) => g -> ([a], [a1])
10:40:16 <dmwit> ikarus: There's your example code. =)
10:41:06 <ikarus> dmwit: coo
10:41:19 <dmwit> > let (g1, g2) = System.Random.split (mkStdGen 42) in zip (randoms g1) (randomRs (1,10) g2) :: [(Bool, Int)]
10:41:20 <lambdabot>   Not in scope: `System.Random.split'
10:41:20 <lambdabot>  Perhaps you meant `System.Random.next'...
10:41:28 <dmwit> Ah, too bad.
10:42:36 <luite> keep in mind that split is an operation for which very little work has been done to check its correctness. if you want to use high quality random numbers you'd probably not use StdGen anyway, but any alternative would probably lack split
10:42:53 <aristid> ikarus: embedding randomness by generating a seed using unsafePerformIO would be impure. "randoms" is not.
10:43:32 <luite> (there was a paper here at this ICFP for that though, but i'm still a bit skeptical, not sure if i already missed the talk or if it's still coming up)
10:44:00 <dmwit> Has anyone even defined what "correctness" of split would mean?
10:44:08 * dmwit tries to imagine
10:44:42 <enthropy> how independent the two generators are?
10:44:46 <geekosaur> it should give you two independent RNGs
10:44:48 <ikarus> luite: and yes, I would want high quality randomness in this case
10:44:50 <enthropy> how long before they repeat
10:45:04 <ReinH> ikarus: PRNGs with a given seed are pure
10:45:06 <ikarus> well, ideally I'd want system randomness as 3 infinite lists :)
10:45:15 <ikarus> but that is going to hurt
10:45:15 <haasn> :t unfoldr (Just . over _1 randoms . split)
10:45:16 <lambdabot>     Couldn't match type `(g0, Splitter a1)' with `[a1] -> [[a1]]'
10:45:16 <lambdabot>     When using functional dependencies to combine
10:45:16 <lambdabot>       Field1 (a, b) (a', b) a a',
10:45:16 <ReinH> it's generating the seed that must be impure
10:45:18 <geekosaur> (although thet can't be fully independent because PRNGs repeat...)
10:45:38 <fryguybob> dmwit: http://dl.acm.org/citation.cfm?id=2503784
10:45:39 <haasn> unfoldr (Just . over _1 randoms . split) :: (RandomGen b, Random a) => b -> [[a]]
10:45:45 <ReinH> well, it could be pure if you don't actually want a random seed ;)
10:45:50 <haasn> or uh...
10:45:51 <dmwit> fryguybob: cool, thanks
10:46:04 <dmwit> haasn: wrong split
10:46:05 <haasn> randoms <$> unfoldr (Just . split) g
10:46:24 <dmwit> :t split
10:46:25 <lambdabot> Splitter a -> [a] -> [[a]]
10:46:29 <ReinH> dmwit: well that depends on your imports, doesn't it :p
10:46:32 <fryguybob> dmwit: That is the talk that luite mentioned.
10:46:41 <haasn> fmap randoms . unfoldr (Just . split) -- ikarus
10:46:58 <dmwit> ikarus: You may have to do something more exciting if you don't want PRNGs.
10:46:59 <luite> fryguybob: was it yesterday?
10:47:15 <luite> if you don't need repeatble runs, i think it's much easier
10:47:18 <fryguybob> luite: Two days ago?
10:47:22 <luite> oh!
10:47:31 <luite> fryguybob: ah right, haskell symposium
10:47:32 <fryguybob> It is all a blur at this point.
10:47:38 * dmwit mumbles something about unsafeInterleaveST
10:47:40 <luite> i think i missed that one
10:47:41 <luite> haha
10:47:46 <luite> too many good talks!
10:47:52 <luite> but i definitely missed that one
10:48:43 <dmwit> ikarus: An alternative strategy is to take one of the actually good PRNGs, pick three seeds from a truly random source, and then run from there.
10:49:13 <dmwit> Though I don't know enough about the interfaces offered by the actually good PRNGs to give much more advice than that.
10:49:27 <luite> if you don't need repeatable runs, seed it from an invisible source (system entropy?) and get it to generate new blocks impurely in the background
10:50:02 <dmwit> Right, that's the unsafeInterleaveST approach, right? =)
10:50:40 <luite> oh i missed that, but yeah :)
10:52:04 <magneticduck> question: can I have an ambiguous type variable in a constructor of a data type?
10:52:35 <dmwit> You can never have types in a constructor of a data type at all.
10:52:57 <dmwit> only data
10:53:19 <magneticduck> for instance, in my library, I have a "sound" type that represents sounds that are later rendered into wav files, and one of the constructors is to play a "waveform" with a set of defining parameters that can b changed over time and an "envelope" that defines them
10:53:35 <magneticduck> OscillateSound (WaveForm a) (Envelope a) <other stuff>
10:53:47 <magneticduck> ...am I thinking straight?
10:53:49 <magneticduck> x|
10:53:58 <magneticduck> s/b/be
10:54:21 <magneticduck> the envelope defines the parameters in function of time
10:54:28 <magneticduck> what would be another way of doing that?
10:54:32 <dmwit> I think maybe you haven't included *quite* enough code for people to be sure if you are thinking straight.
10:55:04 <magneticduck> uh
10:55:26 <magneticduck> one sec
10:56:03 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs
10:56:11 <magneticduck> there is a small chance I'm not thinking straight
10:56:14 <magneticduck> I'm kind of tired
10:57:06 <magneticduck> but the idea is this; I have a data type "WaveForm a" that defines essentially a waveform in function of a parameter space a
10:57:30 <magneticduck> and a "envelope" type "Envelope a" that is a function Time -> a
10:58:06 <magneticduck> they are used together to define a sound in a constructor of the "Sound" data type
10:58:15 <dmwit> Yes, it's possible.
10:58:19 <magneticduck> alright cool
10:58:23 <magneticduck> how would I do it?
10:58:31 <dmwit> Check out ExistentialQuantification or GADTs.
10:58:42 <magneticduck> mm cool
10:58:45 <magneticduck> is it used much?
10:59:02 <magneticduck> I mean, am I standing out a lot by using it?
10:59:10 <dmwit> No. But you can probably do without.
10:59:17 <dmwit> e.g. what if you did this?
10:59:48 <magneticduck> define a data type that can hold any parameter space I want?
10:59:57 <dmwit> data Waveform = Waveform { getSample :: Duration -> Float, getPhaseLength :: a -> Float }; type Envelope = Duration -> Waveform
11:00:10 <dmwit> oops
11:00:17 <dmwit> getPhaseLength :: Float
11:00:18 <dmwit> I mean
11:00:30 <magneticduck> uh
11:00:41 <magneticduck> well I could change it to something like that, although I wouldn't call it an envelope
11:00:43 <magneticduck> hmm
11:01:16 <magneticduck> well thanks for the suggestions
11:01:30 <magneticduck> I'll check GADTs if only for fun
11:01:37 <magneticduck> (gtg)
11:01:45 <dmwit> Having the intermediate "a" type is known as the Existential Anti-pattern, if you want to read more.
11:04:47 <johnw> hello from ICFP!
11:04:55 <sm> hello johnw!
11:04:58 <johnw> hey sm!
11:05:11 <johnw> sm: I'm sitting right next to "the two Simons" :)
11:05:20 <sm> awesome, wish I was there :)
11:07:17 <luite> johnw: hello from ICFP too!
11:07:22 <acomar> so what exactly does Rank2Types do? I'm having to use it, but I'm not entirely sure why -- because I need explicit foralls?
11:07:39 <johnw> and I met luite! :)
11:08:06 <johnw> acomar: if you are passing polymorphic functions TO functions, you need Rank2Types or the more general RankNTypes
11:08:33 <sclv> acomar: yeah in general if all your 'foralls' can be floated to the far left then you're rank 1
11:08:43 <sclv> if they're 'inside' an argument then you need rankn
11:08:46 <johnw> for example, if I wanted to pass the fully general function id :: forall a. a -> a to another function, that other function would be of type f :: (forall a. a -> a) -> ..., and you would need Rank2Types
11:09:16 <acomar> I guess I don't see anything like that
11:09:25 <acomar> the foralls are all the way to the left in every case they're used
11:09:31 <luite> johnw: i'm flattered that meeting me gets the same number of smileys as sitting next to the two Simons ;)
11:09:33 <johnw> acomar: the forall might be tucked into another type
11:09:46 <johnw> luite: most definitely :)
11:09:56 <acomar> johnw: must be, I'll try and track it down
11:10:21 <johnw> acomar: can you paste the code and the error?
11:10:30 <dmwit> acomar: You can probably get away with a weaker extension, like ExplicitQuantification or whatever it's called.
11:11:14 <johnw> ExistentialQuantification
11:11:25 <dmwit> No, I want still weaker.
11:11:30 <johnw> WeakerQuantification
11:11:33 <johnw> ;
11:11:33 <dmwit> The extension that *just* turns on "forall".
11:11:56 <acomar> yea, I'll paste it
11:11:58 <elliott> that exists, I think.
11:12:01 <elliott> ForallSyntax?
11:12:14 <johnw> elliott: what is your full name?
11:12:19 <sclv> explicitforalls maybe
11:12:22 <johnw> i've met two other Elliott named people here, and you were neither of them
11:12:27 <dmwit> ExplicitForAll, according to the GHC manual.
11:12:28 <luite> hehe
11:12:28 <donri> i've hird of elliott's full name
11:13:13 * elliott knows of at least two other Haskell Elliotts.
11:13:22 <elliott> well, assuming last names count.
11:13:26 <dmwit> hrm
11:13:27 <johnw> they do
11:13:35 <johnw> I knew that Conal wasn't you
11:13:52 <dmwit> For some reason I thought "import Foo hiding (foo)" was only a warning when Foo didn't export foo.
11:13:55 <dmwit> But it's actually an error. =(
11:13:56 <acomar> http://lpaste.net/93450
11:14:00 <dmwit> That makes back-compatibility harder. =(
11:14:16 <donri> dmwit: depends on ghc version i think?
11:14:24 <dmwit> What, really?
11:14:26 <donri> which admittedly doesn't help back-compat issues
11:14:34 <dmwit> I would think that would be part of the Report for sure.
11:14:36 <acomar> and yea, it does look like it's just to turn on forall syntax
11:14:51 <dmwit> acomar: -XExplicitForAll is probably enough for you
11:14:58 <johnw> right
11:15:04 <donri> dmwit: i'm not even sure it's a warning without -Wall on 7.6
11:15:27 <dmwit> ?where report
11:15:27 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
11:15:36 <acomar> ahh, I *do* need Rank 2 types in a different module though
11:16:00 <acomar> when a type synonym expands, the forall is in the return type of a function
11:16:20 <acomar> awesome, thanks all
11:16:48 <dmwit> The Report does say it should be an error.
11:16:57 <dmwit> donri: So if you are telling the truth, you should probably report a bug. =)
11:17:13 <dmwit> "It is an error to hide an entity that is not, in fact, exported by the imported module."
11:17:55 <dmwit> acomar: forall's in return types are not rank-2...
11:18:33 <dmwit> acomar: That said, Rank2Types/RankNTypes are by no means controversial extensions.
11:18:44 <donri> Warning:    Module `Control.Monad' does not export `zygohistomorphic'
11:18:54 <donri> import Control.Monad hiding (zygohistomorphic)
11:19:29 <acomar> dmwit: well, let me lpaste this particular error
11:20:08 <donri> dmwit: ghc isn't report-compliant anyway is it?
11:20:22 <dmwit> http://ghc.haskell.org/trac/ghc/ticket/7167 =(
11:20:22 <supki> dmwit: that behaviour was changed because of the removal of catch from Prelude
11:20:41 <supki> yeah
11:21:05 <acomar> dmwit: http://lpaste.net/93450
11:21:10 <acomar> ExplicitForall is on
11:22:04 <dmwit> acomar: Yeah, that's not okay. Maybe you meant type VideoCapture d c e = Producer (Mat d c e) IO () ?
11:22:11 <dmwit> Or did you really want an existentially-quantified type?
11:22:19 <acomar> dmwit: no, I really did want that
11:22:45 <acomar> I don't want to have to specify the types in this case because I don't know what they are without checking at runtime
11:23:05 <acomar> I can force them to something in specific, but that's the wrong behavior
11:23:29 <dmwit> Hm. I'm suspicious, but cautiously supportive.
11:24:14 <acomar> basically, the default colorspace/dimensions are coming off the camera hardware
11:25:03 <acomar> that type needs to deal with any and all cameras/video files
11:25:57 <dmwit> So. Since "hiding" is an error, I have to alpha-vary my code.
11:26:09 * dmwit mumbles under his breath
11:29:22 <maverick_> Hi all, I'm trying to pretty paste a table like this http://pastebin.com/q0rEG8sx
11:29:27 <mauke> The paste q0rEG8sx has been copied to http://lpaste.net/93452
11:30:00 <maverick_> I have to make a function --> printTable :: Table -> [String] printTable table@(header:rows)     = undefined
11:30:30 <maverick_> And I already have some functions that I combine to make it, but I'm not really sure how to
11:30:40 <ReinH> maverick_: I would recommend writing it as showTable :: Table -> String and printTable :: Table -> IO () = putStr . showTable
11:30:52 <ReinH> naming something print usually implies that IO will happen
11:31:04 * dmwit chuckles
11:31:13 <dmwit> Can't even let him finish his question... =P
11:31:33 <ReinH> dmwit: well, I assume the question is going to be "how do I turn a Table into a String" :p
11:31:56 <acomar> actually dmwit, I think you're right. That type isn't saying what I want.
11:32:04 <maverick_> The question is how I can combine my functions so it becomes a function that I just typed
11:32:19 <dmwit> acomar: Bummer! What were you hoping it would say?
11:32:32 <ReinH> and it's probably going to be something like unlines $ showHeader header : fmap showRow rows
11:32:43 <acomar> dmwit: that I don't care what d c and e are, but they are something
11:32:49 <maverick_> I already have a function printLine [5; 6; 6; 6] that gives  "+-----+------+------+------+"
11:33:09 <geekosaur> @lpaste maverick_, paste your existing code
11:33:09 <lambdabot> Haskell pastebin: http://lpaste.net/
11:33:20 <geekosaur> don't paste directly into the channel
11:33:32 <dmwit> I wonder if we have an official "homework" policy. (This sounds a lot like homework to me...)
11:33:36 <bennofs> geekosaur: I think he pasted http://lpaste.net/93452
11:33:58 <ReinH> bennofs: your existing *code* :)
11:34:00 <geekosaur> bennofs, iit;s not code
11:34:13 <maverick_> That's the input and output
11:34:18 <bennofs> Oh I see. Should have looked at that paste :P
11:34:22 <ReinH> heh
11:35:00 <enthropy> > map (maximum . map length) $ transpose [["a","abc"],["ab","x"]]
11:35:01 <lambdabot>   [2,3]
11:35:05 <ReinH> maverick_: without knowing what your functions are we can't tell you how to combine them
11:35:15 <maverick_> I'm pasting them
11:35:16 <maverick_> Hold on
11:35:29 <Cylta> Hi guys. can I use haskel on ARM and can I do parallel stuff, that will use CPU and videocard in many threads?
11:35:34 <ReinH> enthropy: and combine that with a padding function and bob is your uncle :)
11:36:11 <ReinH> fmap (zipWith pad xs widths)
11:36:18 <maverick_> http://lpaste.net/1239454461282222080
11:36:31 <maverick_> The last one is the function I have to make so it is still undefined
11:36:49 <maverick_> I was thinking about using zip on columnWidths together with a list of strings?
11:37:16 <maverick_> And use map (map toUpper) (head[[a]]) to change the first row to uppercase
11:37:16 <enthropy> maybe there's a cleaner way to do it with one of the pretty-printing libraries
11:38:24 <dmwit> ReinH: Even once he tells us, I don't think telling him how to combine them is a good idea, morally.
11:38:38 <geekosaur> enthropy, I think this is an early homework problem?, pretty printing libraries are probably not part of the solution
11:39:01 <enthropy> well more generally is there a way to use them to make such tables?
11:39:08 <dmwit> maverick_: You should take a stab at it and show us where you get stuck.
11:39:18 <dmwit> enthropy: The "boxes" library might do okay there.
11:39:42 <dmwit> But generally no, well-aligned tables isn't really a strong suit of Haskell pretty-printing libraries.
11:39:50 <maverick_> First I wanted to change the first row to uppcase
11:40:03 <maverick_> With map(map toUpper) (head[[a]])
11:40:07 <maverick_> I tested it and it works
11:40:08 <xRamses> I may doing something very wrong, but how can I append 2 IO Strings? I can't liftM (++) as it seems.
11:40:25 <dmwit> xRamses: Why not?
11:40:34 <dmwit> xRamses: Oh, yes, you want liftM2 instead. =)
11:40:35 <luite> liftM2
11:40:36 <maverick_> I can print those symbol lines with printLine and the columnWidths as argument
11:40:50 <maverick_> But I'm stuck at the printRow function
11:41:03 <xRamses> dmwit: Ah very well, thanks
11:41:10 <maverick_> To make an argument for it I have to zip it
11:41:19 <maverick_> The list of columnWidths together with something I don't know
11:41:21 <maverick_> That's where I am stuck
11:41:42 <luite> xRamses: also applicative would work here, (++) <$> ioxs <*> ioys
11:43:04 <xRamses> luite: Well for that I have to understand functors first, but everything when the time is right. Thanks anyway.
11:43:20 <ReinH> maverick_: well, what do you want that zipping to do?
11:43:35 <luite> xRamses: oh it also works if you don't understand it ;)
11:44:12 <xRamses> luite: Hehe, yes maybe
11:44:33 <maverick_> ReinH, I want to add an int and string together in a tupel so I can give it to the printRow function, because that one needs a [(Int, String)]
11:44:43 <subway> Howdy.... I'm playing around with writing a utility to capture snapshots of webpages, and am extremely new to Haskell/FP. Anyone able to explain why I seem to hang at mainGUI here: http://pastebin.com/JQtTngJW
11:44:46 <mauke> The paste JQtTngJW has been copied to http://lpaste.net/93453
11:45:08 <ReinH> maverick_: well, that's what zip does, but this doesn't seem very easy to compose
11:45:48 <maverick_> I have the list with Ints
11:45:54 <maverick_> Because the function columnWidths gives me those
11:45:57 <ReinH> right
11:46:55 <maverick_> I tried concat on the table since it is a [[string]], so I get a [string] and then zip it with those [int]
11:47:39 <ReinH> maverick_: so do you want to pad each column by that column's width (from columnWidths)? And do that for all columns?
11:49:06 <ReinH> maverick_: let's say you have a function printField :: Int -> String -> String that takes a column width, a column contents, and gives the correct padded column contents to print
11:49:08 <maverick_> ReinH, like this http://lpaste.net/5420472117390999552
11:49:09 <dmwit> subway: See http://dmwit.com/gtk2hs
11:49:53 <subway> dmwit: thanks
11:49:54 <maverick_> I used  that printField in printRow
11:49:58 <maverick_> So it is included already
11:50:06 <maverick_> I only forgot to paste it
11:50:15 <ReinH> maverick_: ok, so what do we know? We know that column widths are invariant for the table. Each row will get the same widths. Right?
11:51:25 <maverick_> Yes that's true
11:51:54 <ReinH> so inside our printTable function we can bind a function printRow :: String -> String that uses the same columnWidths for each row
11:52:17 <ReinH> er printRow [String] -> String sorry
11:52:46 <ReinH> it's a specific case of a more general function printRowWidths :: [Int] -> [String] -> String -- printRow = printRowWidths columnWidths
11:53:09 <ReinH> so how would you define printRowWidths?
11:54:34 <maverick_> A function that makes a string of everything in one row?
11:54:55 <ReinH> maverick_:  a function that takes a list of widths and a list of fields and combines them into a row
11:54:58 <ReinH> :t zipWith
11:54:59 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:55:41 <ReinH> you have a list of Int and a list of String so you need a function Int -> String -> String that takes a width and a string and does the right thing. But you have that, right?
11:55:44 <ReinH> printField
11:56:23 <maverick_> Yes -- > printField :: Int -> String -> String
11:57:56 <ReinH> maverick_: so zipWith printField columnWidths :: [String] -> [String] and now you just need to intercalate "|" to add in the bars between cells.
11:58:16 <ReinH> so printRow = intercalate "|" . zipWith printField columnWidths
11:58:53 <ReinH> printRow :: [String] -> String
11:59:16 <ReinH> oh and there's a concat in there somewhere
12:00:03 <ReinH> maverick_: does that make sense? zip is a specialized zipWith: zip = zipWith (,), so by creating tuples with zip and passing them around and untupling them with uncurry you are basically doing the work of zipWith in a very round-about way
12:00:32 <maverick_> Ok, hold on, I will try to implement it
12:01:26 <ReinH> maverick_: you basically reimplemented a deconstructed zipWith ;)
12:06:30 <kowey> there isn't a beginner's channel is there? i'd like to talk somebody through http://pastebin.com/TRLYhZvg without making too much noise
12:06:33 <mauke> The paste TRLYhZvg has been copied to http://lpaste.net/93455
12:07:06 <geekosaur> no beginner's channel, but you can do talkthroughs in -overflow
12:07:18 <geekosaur> (that is, #haskell-overflow)
12:07:24 <kowey> sounds good to me, thanks!
12:08:33 <aristid> geekosaur: didn't there use to be -beginners or so?
12:08:47 <geekosaur> there's a mailing list but not a channel
12:09:12 <geekosaur> (I think someone did try to create a channel at one point, but it didn't get much use and withered away?)
12:10:34 <fizruk> Hi! Is there an alternative for plugins package?
12:10:59 <fizruk> I mean http://hackage.haskell.org/package/plugins
12:11:51 <dmwit> Yes, hint, mueval, and the more raw ghc-api packages are the modern alternatives.
12:12:16 <fizruk> dmwit: thanks, I'll check out those!
12:12:28 <dmwit> If you just want configuration, you might also consider dyre.
12:13:39 <magneticduck> dmwit always seems so stern, ending his sentences with periods. >:|
12:13:46 <fizruk> dmwit: I want to load a foreign function at runtime
12:14:23 <dmwit> fizruk: You've exhausted what I know -- specifically, package names. I don't know *anything* about what they support. =P
12:14:39 <dmwit> But maybe there are people in here that know more about them than their names.
12:15:06 <fizruk> dmwit: then I'll look through the packages myself first =)
12:15:55 * dmwit puts his best stern face back on
12:16:46 <magneticduck> Very well.
12:18:26 <enthropy> fizruk: libffi is another option too
12:18:42 <dmwit> I can't help thinking "cp" is ill-designed. But I don't know how to design it better.
12:20:43 <fizruk> enthropy: that package seems to be abandoned for over 4 years...
12:21:01 <enthropy> it still works I think
12:22:53 <fizruk> enthropy: API seems very reasonable to me, thanks!
12:24:57 <ijp> what pragma do I need to turn on n+k patterns?
12:25:19 <dmwit> NPlusKPatterns
12:25:24 <ijp> ah, of course
12:27:55 <stepkut> I would like to create a FRP language for sequencing individually addressable RGB christmas tree lights, but I am having some difficulties figuring out which FRP approach to use
12:28:50 <peteretep> I have a plan to 3d map those
12:28:55 <peteretep> Two photos, plot them in 3d space
12:29:07 <peteretep> Wonder what resolution you would need to do that
12:29:24 <maverick_> :t (+)
12:29:25 <lambdabot> Num a => a -> a -> a
12:54:11 <exicer> Is there some way to turn OverloadedStrings on in ghci ?
12:55:03 <supki> exicer: :set -XOverloadedStrings
12:55:20 <carter> anyone know who i can pester to add a channel to lpaste?
12:55:25 <exicer> supki: Cheers
12:56:26 <startling> carter, chrisdone, maybe
12:56:32 <carter> ok
12:56:42 <carter> startling: good hanging out in boston
12:56:49 <startling> carter, eh?
12:56:53 <carter> wait
12:56:55 <carter> nvm
12:57:00 <carter> i'm mixing up you and Gracenotes
12:57:37 <startling> oh, heh. I was running through every time I've been in boston, wondering if I'd talked to any secret Haskellers...
12:59:33 <donri> stepkut: netwire 5, because if something is already on hackage it's outdated
12:59:48 <stepkut> donri: :)
12:59:56 <stepkut> donri: I should look at that!
13:00:17 <donri> stepkut: http://hub.darcs.net/ertes/netwire i think is the active one
13:00:32 <startling> ooh, hackage is shiny
13:00:56 <donri> yep, hackage 2 is live
13:01:05 <donri> take that, gwern
13:01:07 <stepkut> donri: I've started from the other end for the moment. I am writing out what I want to be able to do which both general and specific examples
13:06:11 * dmwit cackles madly
13:06:29 <dmwit> Now I can be dmwit on Hackage t[wo]o!
13:06:49 <carter> @tell chrisdone could you add #haskell-llvm to lpaste?
13:06:50 <lambdabot> Consider it noted.
13:08:00 <kuribas> Are there haskell extensions to restrict a type to some constructors?
13:08:19 <dmwit> GADTs, sort of
13:08:20 <carter> dmwit: why wuld you want to be dmwit  there?
13:08:29 <dmwit> There's a very nice pigworker answer on SO about it.
13:08:33 <dmwit> Let me see if I can find it for you.
13:08:39 <dmwit> carter: Because dmwit is my brand.
13:08:44 <sm> when running a program in cabal repl in emacs in ssh, is there a way to control-c out of the running program without also exiting ghci ?
13:08:51 <carter> but real names™
13:08:55 <sclv> donri: haha yes. success delayed is success doubled
13:09:03 <startling> sm, C-C doesn't do it?
13:09:05 <dmwit> carter: My real name is not hidden or hard to find from my brand.
13:09:08 <carter> true
13:09:22 <carter> i have to agree with daniel on that one
13:09:26 <sm> startling: C-c C-c exits ghci, same with C-q C-c
13:09:30 <dmwit> It's not about privacy for me. I just like "dmwit" better. =)
13:09:59 <startling> sm, dang. I don't know.
13:10:00 <donri> GADTs are today's answer to every question, seems
13:10:07 * sm is using ghci more since cabal repl and liking it 
13:10:12 <carter> fair
13:10:14 <startling> killall ghc seems to only sometimes kill ghci.
13:10:34 <carter> startling: isn't there an issue where double kills are sometimes needed?
13:10:43 <donri> sm: it's a known limitation of cabal repl that ^C exits
13:10:53 <donri> apparently non-trivial to fix
13:10:59 <sm> aha
13:11:34 <startling> I mean, usually kill $GHCI_PROCESS only stops the running function and drops you back into ghci, but sometimes it kills ghci too.
13:11:37 <startling> I don't know why.
13:12:47 <dmwit> kuribas: I'm having trouble finding it, sorry.
13:12:50 <joelteon> yeah, ^C killing cabal repl is also non-trivial to ignore
13:13:34 <joelteon> :p
13:14:28 * kuribas is reading about GADT's now.
13:14:35 <donri> yeah, i have a habbit of using ^C to clear the command line (including the ghci input)
13:14:59 <donri> i also have an alot of hobbits. yay english
13:15:08 <ReinH> donri: FYI: ^l
13:15:23 <acomar> dmwit, enthropy: So I'm trying to actually write that convertColor function now
13:15:31 <donri> ReinH: no, i mean the input not the screen
13:15:43 <ReinH> ah right
13:15:44 <glguy> I use ^U for that
13:15:45 <donri> ReinH: in cabal repl i instead need ^K ^U
13:15:52 <donri> glguy: assuming you're at the end :)
13:15:53 <acomar> let me lpaste what I'm trying, let me know if you guys have any ideas
13:15:57 <ReinH> yep, emacs bindings work-ish
13:16:12 <johnw> is there an idiomatic way of expressing this: do { x <- m; x' <- x; return x' }
13:16:25 <glguy> join?
13:16:43 <shachaf> @@ @pl @undo do { x <- m; x' <- x; return x' }
13:16:43 <lambdabot>  join m
13:16:50 <shachaf> hoorambdabot
13:16:52 <acomar> http://lpaste.net/93458
13:16:55 <johnw> excellent!
13:16:58 <acomar> dmwit, enthropy ^
13:17:28 <johnw> for some reason join never occurred to me
13:17:43 <startling> do notation can do that in my experience.
13:17:47 <acomar> is there any way around the type class function must use type class variable issue?
13:18:10 <dmwit> acomar: That's what the singletons are for.
13:18:17 <acomar> singletons?
13:18:22 <startling> acomar, sometimes people have a -> Int or whatever
13:18:32 <dmwit> Remember enthropy was telling you you'd need a connection? This is where. =)
13:18:39 <startling> you do thisFunction (undefined ::a)
13:18:47 <dmwit> startling: noooo
13:18:49 <enthropy> acomar: something like:  Num c => proxy a -> proxy b -> c -- might work?
13:18:50 <dmwit> Use Proxy, please.
13:19:09 <startling> dmwit, what's that?
13:19:09 <shachaf> Or proxy.
13:19:12 <acomar> so what would Proxy have to look like?
13:19:26 <shachaf> You can use Maybe or whatever else.
13:19:33 <dmwit> acomar: Or, why not class Convertable a b where convertColor :: Mat d a e -> Mat d b e
13:19:37 <startling> is it like Const Int a ?
13:19:38 <shachaf> Proxy is like Maybe without Just.
13:19:50 <acomar> dmwit: fair enough, I'll give that a shot
13:19:56 <enthropy> Maybe probably won't work here unless it's become polykinded
13:20:00 <johnw> if anyone is willing to review: https://gist.github.com/jwiegley/6719450
13:20:08 <acomar> shachaf: oh neat, what package is that from?
13:20:10 <johnw> i'm trying to simplify the monad-control library
13:20:19 <donri> @hackage tagged
13:20:19 <lambdabot> http://hackage.haskell.org/package/tagged
13:20:29 <shachaf> It's going into base.
13:20:36 <shachaf> But right now tagged.
13:21:08 <kuribas> Is there a dependent typing extension in haskell?
13:21:26 <donri> {-# LANGUAGE Agda #-}
13:21:36 <glguy> hackage2 breaks cabal-install's bootstrap.sh
13:21:36 <johnw> kuribas: heh, the talk at ICFP is exactly about that right now
13:22:01 <donri> glguy: #hackage
13:22:03 <WraithM> You can sorta fake it, is my understanding.
13:22:03 <glguy> (easy to fix, but doesn't work out of the box anymore)
13:22:25 <kuribas> johnw: cool
13:23:26 <WraithM> kuribas: There's this http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636
13:23:44 <deas> Just quick question - is this correct definition of bind for State monad? : x >>= f = state $ \st0 -> let (a,st1) = runState x st0 in runState (f a) st1    ?
13:23:59 <donri> or more recently, see the papers on kind promotion and singletons
13:24:13 <WraithM> link?
13:24:22 <WraithM> oh, papers
13:24:25 <WraithM> nvm
13:24:40 <shachaf> deas: It looks reasonable.
13:24:41 <bearclaw> beginner question again: "class CLS a where foo :: a -> x" can't possibly be instanciated due to the x right?
13:24:59 <johnw> kuribas: this is what's being discussed right now: http://www.cis.upenn.edu/~eir/papers/2013/fckinds/fckinds-extended.pdf
13:25:02 <shachaf> deas: (Except if you're using "state" you're probably actually using a StateT newtype, not a State newtype.)
13:25:20 <donri> WraithM: afraid of papers? you just linked one yourself!
13:25:36 <ikarus> dmwit: that would be true if I would accept PRNGs, but what I am doing in theory requires a real RNG
13:25:41 <WraithM> donri: No :) not at all, just that link would be links
13:25:48 <WraithM> and I can just look those up myself
13:25:50 <kuribas> johnw: great
13:26:06 <dmwit> ikarus: You'll need to look into using unsafeInterleaveIO, then.
13:26:14 <dmwit> ikarus: And it ain't gonna be pretty.
13:26:16 <deas> shachaf: and can i somehow use particularly State?
13:27:02 <shachaf> State isn't a newtype in mtl.
13:27:10 <ikarus> dmwit: ick, that's just uncool, can't I just create an infinite list of randomness using a real random source and pass around that list ?
13:27:22 <shachaf> If you're doing this for learnin'-y reasons, you can just define your newtype, and forget Control.Monad.*
13:27:25 <dmwit> ikarus: Yes. But you said you need three lists.
13:27:39 <shachaf> newtype State s a = State { runState :: s -> (s, a) }
13:27:40 <ikarus> dmwit: that requirement I just managed to avoid by rewriting some bits
13:27:52 <dmwit> ikarus: Actually, even a single list is probably going to require unsafeInterleaveIO somewhere (though perhaps written for you -- e.g. in readFile).
13:27:54 <WraithM> donri: I would happily accept some solid links if you had them available though!
13:28:29 <dmwit> ikarus: The modern alternative is conduits/pipes/iteratees. But I don't understand that playing field well enough to make a clear suggestion about which will be best for you.
13:28:32 <donri> WraithM: http://dreixel.net/research/pdf/ghp.pdf  http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf
13:28:39 <deas> yes, okey... I am trying to learn and I tried to actually replace my definition of bind in definiton of sequence and it didnt work
13:28:51 <donri> kuribas: ^ also
13:28:55 <WraithM> donri: Thank you :)
13:29:04 <deas> probably beacuse of the difference StateT vs State
13:29:11 <deas> thanks for you answer
13:31:22 <acomar> ok, I updated the lpaste: http://lpaste.net/93458
13:31:27 <acomar> I'm trying the proxy approach
13:31:40 <acomar> before I give up and just do what dmwit suggested, which will most likely work fine
13:32:04 <shachaf> ccshan++
13:32:21 <acomar> if I give the type signature for the usages of Proxy explicitly, I get a kind mismatch error :/
13:32:38 <dmwit> acomar: Look up ScopedTypeVariables and read about them a little.
13:32:54 <acomar> will do
13:33:10 <dmwit> acomar: You're deep in the rabbit-hole now. :3
13:33:22 <acomar> dmwit: :D
13:34:43 <dmwit> acomar: Other solutions include: write foo :: Matrix a b c -> Proxy b; or make the channels be the last argument to Matrix and just pass the matrices instead of Proxy.
13:35:00 <dmwit> foo _ = Proxy is a fine implementation, but you have to give the type signature
13:35:01 <ikarus> anyone else want to pipe in on my problem (pun intended), I am trying to find true random numbers that meet certain properties, quite deep within code that would otherwise be purely functional, and well, it's baffling me still
13:36:29 <mstksg> if they are true random numbers that change every time you call the function
13:36:35 <mstksg> then it can't really be considered pure
13:36:57 <ikarus> mstksg: yes, but the thing is, otherwise it would be pure, so all the code was already written as if it was
13:37:11 <mstksg> fundamentally you are going to have to wrap it all in a monad with some sort of state concept
13:37:32 <mstksg> or else string the seed through the entire function
13:37:34 <benmachine> ikarus: you're in for a bumpy ride
13:37:36 <mstksg> there is no way around it
13:37:43 <benmachine> this is like the textbook example of when purity is annoying :P
13:37:54 <acomar> dmwit: Making a type synonym for Mat that moved the channel argument to the end and then passing the matrices worked
13:37:56 <ikarus> benmachine: yes, I KNOW
13:38:01 <acomar> dmwit: Thanks!
13:38:13 <benmachine> ikarus: comfort yourself with the knowledge that it doesn't get any worse :)
13:38:15 <ikarus> benmachine: even better, it's not real IO, it's true randomness :)
13:38:20 <mstksg> benmachine, ikarus: actually, i consider this situation now to be a situation where purity is a great asset
13:38:30 <mstksg> and makes Haskell shine
13:38:55 <mstksg> it's all a part of restructuring how you approach a program/problem from the very beginning
13:39:20 <mstksg> the only annoying part is really the adjustment from the baggage you carry from your programming history
13:39:59 <dmwit> acomar: uh
13:40:06 <dmwit> acomar: A type synonym...?
13:40:11 <mstksg> i actually think it's a situation where Haskell's type system really shines :)
13:40:12 <dmwit> acomar: That probably did not do what you think it did.
13:40:14 * mangaba_leitosa looking at lenses. those (^%%=) operation remind of J or APL
13:40:42 <Cale> ikarus: Usually the key is just to add an additional parameter which specifies the random values needed.
13:41:14 <acomar> dmwit: o.O I just didn't want to go rummaging around everywhere to rewrite the type variable order for Mat
13:41:24 <acomar> so I added type Mat' d e c = Mat d c e
13:41:39 <dmwit> acomar: Of course, and I sympathize with that. But type synonyms get expanded immediately, always.
13:41:40 <acomar> then used that in the signature of cvtValue and convertColor
13:41:45 <Cale> ikarus: and then at the top level, you can get those values by running IO actions (like randomRIO)
13:41:46 <ikarus> Cale: thing is, I need to try out multiple random numbers until they meet a certain property :\
13:41:49 <dmwit> acomar: (Except when being printed for the user.)
13:42:17 <acomar> dmwit: so what's the issue with it not being the last type variable?
13:42:54 <dmwit> acomar: Your typeclass polymorphic function takes something of type "proxy a" to determine what type "a" is -- that is, "a" is the last type.
13:43:19 <acomar> dmwit: ahh, I got rid of the proxy
13:43:37 <acomar> cvtColor :: Num c => Mat d a e -> Mat d b e -> c
13:43:46 <dmwit> acomar: Why don't you paste some new code so we can be sure we're arguing about the same thing? =)
13:43:46 <acomar> (after synonym expansion)
13:43:49 <acomar> ok
13:44:16 <Cale> ikarus: In that case, you could make that parameter be a sequence of random values? Or of course, you could produce as your result a lambda which takes the random value and does the last bit of the computation from there.
13:44:27 <acomar> dmwit: http://lpaste.net/93458
13:44:30 <acomar> this compiles fine
13:44:45 <ikarus> Cale: hmhm, considering that last option, this code is going to be ugly one way or another though :(
13:44:49 <Cale> ikarus: When you say "true random numbers", are you doing cryptography?
13:45:07 <ikarus> Cale: yes, don't worry, intellectual exercise, not doing ACTUAL crypto :)
13:45:27 <dmwit> acomar: Oh, you got rid of Proxy entirely? okay, then
13:45:45 <Cale> If pseudorandom numbers are okay, then you could pass around StdGen values.
13:45:46 <dmwit> acomar: I thought you were keeping it, or I never would have suggested ScopedTypeVariables.
13:46:28 <Cale> With a StdGen, you can get an infinite stream of random values, and well, though it hasn't been properly studied, there's also a split function which will turn one StdGen into two.
13:46:33 <acomar> dmwit: I got rid of it when you told me to just pass the mats
13:46:43 <acomar> dmwit: I realized the mats where exactly the proxy I needed
13:47:01 <ikarus> Cale: I want to see if I can get it done first without stdGen, else yes, I think I'll go that route
13:47:35 <dmwit> acomar: There is a middle ground, where you keep "proxy" but use the matrices instead of a Proxy.
13:47:47 <acomar> dmwit: ahh, alright
13:50:00 <ikarus> Cale: I find it sort of disappointing that nothing prepares you for this mess really :)
13:50:35 <Cale> Well, it comes down to how well you manage to break things up into smaller pieces
13:51:06 <Cale> If the computation is nicely compositional, it's probably not too much trouble to break up the part before and after whatever effects are required.
13:58:49 <acomar> dmwit: awesome, thanks so much for your help. The conversions work correctly. Of course, actually specifying what conversion you want requires DataKinds, but... that's the rabbit hole
13:58:54 <ikarus> hrm, there is no support for proper randomness in Haskell proper anyway, so I guess I'd have to thread it myself from /dev/urandom or similar :(
13:59:06 <dmwit> acomar: good stuff =)
13:59:29 <dmwit> ikarus: What kind of support do you want?
14:00:20 <ikarus> dmwit: atleast some encapsulation above just reading bytes from that file :)
14:00:39 <dmwit> Like what?
14:00:58 <ikarus> dmwit: so you can do "ranges", etc on them
14:01:52 <dmwit> http://hackage.haskell.org/package/random-source ?
14:03:31 <ikarus> dmwit: ah, sorry
14:03:33 <dmwit> and http://hackage.haskell.org/package/random-fu for a much higher-level abstraction level
14:09:05 <lamefun> are cabal packages signed/verified?
14:09:31 <startling> good question.
14:09:47 <dmwit> no
14:09:57 <startling> are hackage downloads over HTTPS?
14:10:14 <dmwit> I believe Hackage now supports HTTPS.
14:10:18 <startling> :/
14:10:33 <dmwit> Why :/ to that?
14:10:49 <k0001_> :t (:/)
14:10:50 <startling> "now supports" implies that it didn't before, and that it's not the default.
14:10:50 <lambdabot>     Not in scope: data constructor `:/'
14:10:50 <lambdabot>     Perhaps you meant one of these:
14:10:50 <lambdabot>       `:+' (imported from Data.Complex),
14:11:13 <dmwit> I'm not sure whether it was supported before.
14:13:07 <ReinH> startling: literally anyone can publish to any package at any time and your security concern is that it doesn't use HTTPS? ;)
14:13:10 <startling> @def data Emotion = (:/) | (:|) | (:\)
14:13:10 <lambdabot>  .L.hs:140:16: parse error on input `:/'
14:13:24 <identity> It seems my brain is fried. I remember there being some niftier way of doing something like: any (\x -> any ($ x) [isAlpha, isBlah]) "foo"
14:13:26 <lamefun> ?!
14:13:26 <lambdabot> Maybe you meant: v @ ? .
14:13:30 <identity> or is that just me?
14:13:34 <lamefun> anyone can publish to any package at any time?
14:13:55 <startling> ReinH, eh? Anyone can publish a /new/ package name at any time.
14:16:10 <dmwit> ReinH: Hackage2 exists and is live now. So things are slightly better.
14:16:17 <ReinH> dmwit: yay :)
14:16:34 <ReinH> startling: then why do I hear about people accidentally clobbering other people's packages?
14:16:41 <dmwit> startling: It *used* to be that Hackage allowed anyone to publish a new version of any package.
14:17:16 <ReinH> for instance http://hackage.haskell.org/package/Adaptive-0.1 and http://hackage.haskell.org/package/Adaptive-0.22
14:17:18 <donri> i somehow managed to resist the temptation to put a trojan in base
14:17:20 <dmwit> identity: and . sequence [isAlpha, isBlah] $ "foo" ?
14:17:49 <dmwit> identity: ...and by "and" of course I mean "or"
14:17:50 <startling> dmwit, ReinH: :/ :/ :/
14:18:00 <dmwit> startling: Yes, we know.
14:18:01 <identity> dmwit: I think that may be it indeed, thanks :)
14:18:08 <dmwit> startling: That's why people wanted Hackage2.
14:18:12 <dmwit> startling: And now we have it.
14:18:32 <donri> it's not the *only* reason to want hackage2
14:19:00 <Clint> what, you mean i can't hijack packages anymore?
14:19:35 <donri> Clint: you can still politely ask the owner at gunpoint to add you to the maintainers
14:19:44 <ReinH> > and . sequence [isAlpha, isLower] <$> "foo"
14:19:45 <lambdabot>   [True,True,True]
14:19:48 <startling> > (||) <$> isAlpha <*> isHexDigit $ 'A' -- identity
14:19:49 <lambdabot>   True
14:19:49 <Clint> that seems like the opposite of convenient for MIA maintainers
14:19:54 <ReinH> dmwit: so not quite
14:20:00 <ReinH> applicative is nice though
14:20:12 <dmwit> ReinH: You didn't read my example carefully.
14:20:20 <donri> Clint: admins can add you too, if you convince them the maintainer is MIA
14:20:25 <Clint> well that's good
14:20:30 <ReinH> dmwit: I did. And then I fixed it so it typechecked.
14:20:39 <ReinH> > and . sequence [isAlpha, isLower] $ "foo"
14:20:40 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
14:20:41 <lambdabot>  Expected type...
14:21:11 <dmwit> uh
14:21:51 <dmwit> > and . map (sequence [isAlpha, isLower]) $ "foo"
14:21:52 <lambdabot>   Couldn't match type `[GHC.Types.Bool]' with `GHC.Types.Bool'
14:21:52 <lambdabot>  Expected type...
14:22:03 <dmwit> ick
14:22:32 <dmwit> Oh, there's two any's in the original!
14:22:34 <dmwit> My mistake.
14:22:38 <ReinH> heh :)
14:22:56 <startling> :t any ((||) <$> isAlpha <*> isHexDigit)
14:23:01 <lambdabot> [Char] -> Bool
14:23:02 <dmwit> > or $ [isAlpha, isLower] <*> "foo"
14:23:07 <lambdabot>   True
14:23:09 <startling> dmwit: oh, nice
14:23:10 <dmwit> There we go.
14:23:38 <startling> > any $ [isAlpha, isLower] ?? "foo"
14:23:39 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
14:23:39 <lambdabot>              with actua...
14:23:43 <dmwit> identity: See updated code.
14:23:58 <startling> oh, oops
14:24:05 <ReinH> or . ([isAlpha, isLower] <*>)
14:24:41 <ReinH> heh, go home @pl you're drunk: ((or $) .) . (<*>)
14:24:53 <startling> ReinH: it's beautiful
14:25:09 <startling> :t (or $)
14:25:09 <lambdabot> [Bool] -> Bool
14:25:12 <startling> :t or
14:25:13 <lambdabot> [Bool] -> Bool
14:25:14 <startling> ???
14:25:26 <startling> :t (or .) . ap
14:25:27 <lambdabot> [a -> Bool] -> [a] -> Bool
14:25:32 <ReinH> startling: you need a section?
14:25:45 <dmwit> :t or . sequence
14:25:45 <ReinH> dunno
14:25:46 <lambdabot>     Couldn't match type `[a0]' with `Bool'
14:25:46 <lambdabot>     Expected type: [[a0]] -> [Bool]
14:25:46 <lambdabot>       Actual type: [[a0]] -> [[a0]]
14:26:14 <startling> :t let (.:) = fmap fmap fmap in or .: ap
14:26:15 <lambdabot> [a -> Bool] -> [a] -> Bool
14:26:28 <S_J> > map (> 5 . < 10) [1,2,7,8,90]
14:26:29 <lambdabot>   <hint>:1:12: parse error on input `<'
14:26:30 <dmwit> :t \f xs -> or (mapM f xs)
14:26:30 <lambdabot>     Couldn't match type `[b0]' with `Bool'
14:26:30 <lambdabot>     Expected type: [Bool]
14:26:30 <lambdabot>       Actual type: [[b0]]
14:26:40 <startling> identity: sorry!
14:26:50 <dmwit> oh
14:26:51 <dmwit> bleh
14:27:00 <S_J> > map (\x->(x > 5) && (x < 10)) [1,2,7,8,90]
14:27:01 <lambdabot>   [False,False,True,True,False]
14:27:14 <S_J> can it be written denser?
14:28:13 <dmwit> > map (inRange (6,9)) [1,2,7,8,90]
14:28:14 <lambdabot>   [False,False,True,True,False]
14:28:44 <S_J> > let isBetween lower upper = \x -> x > lower && x < upper in map (isBetween 3 8) [1..10]
14:28:45 <lambdabot>   [False,False,False,True,True,True,True,False,False,False]
14:29:07 <dmwit> You don't like inRange, huh? =)
14:29:12 <S_J> @src inRange
14:29:12 <lambdabot> Source not found. My brain just exploded
14:29:40 <identity> dmwit: that looks even better, thanks! :)
14:29:50 <startling> > inRange (6, 9) 6
14:29:51 <lambdabot>   True
14:30:02 <S_J> does xmonad not exist for windows?
14:30:10 <startling> dmwit, ^ should be an open interval
14:30:27 <enthropy> S_J: it doesn't exist for windows
14:30:29 <ReinH> S_J: nope. It exists for X.
14:30:42 <dmwit> startling: I know. I changed the interval. He said 5-10, I said 6-9.
14:30:47 <dmwit> I'm aware it's not identical.
14:30:57 <startling> oh, heh
14:32:16 <lamefun> so cabal install is unsafe?
14:32:42 <ReinH> lamefun: define unsafe
14:32:53 <startling> lamefun: yes.
14:33:35 <lamefun> I can't be sure that what I build comes from the package's author?
14:34:23 <startling> lamefun: seems so.
14:34:47 <ReinH> Yes. I don't know what the authentication plans are for hackage 2
14:35:03 <ReinH> but identity is an important part of security so I hope they address it somehow
14:35:04 <elliott> that's quite a high bar to set, though.
14:35:22 <ReinH> elliott: security is hard. That isn't an excuse to not do it.
14:35:33 <elliott> package authors themselves would have to sign packages, and you'd need to trust their keys, etc.
14:35:44 <elliott> ReinH: I never said anything of the sort.
14:36:04 <ReinH> elliott: yes, but having a trust mechanism in place that you can audit is infinitely better than none at all
14:36:06 <startling> elliott: what's wrong with that?
14:36:07 <elliott> I just mean that this is a stringent definition of "safe", even if a worthy one.
14:36:15 <elliott> ...]
14:36:25 <elliott> ok, you can feel free to believe I am arguing against the implementation of some mechanism here if you wish.
14:36:53 <ReinH> elliott: I'm not sure how else to take your comments. Yes, it's hard to do security well.
14:38:17 <startling> I mean, why is "package authors themselves would have to sign packages" an issue? We already have automatic cabal uploader(s).
14:38:29 <elliott> I mean that if your requirement for safety is as strong as "I can't be sure that what I build comes from the package's author", then cabal install is only as unsafe as a very comfortable majority of systems. if you want to see the ways in which cabal is or has been *more* insecure than other systems, then you need to look at weaker requirements.
14:39:32 <ReinH> elliott: eh? Plenty of package systems use signed packages
14:40:05 <ReinH> dpkg-buildpackage, for instance
14:42:22 <ReinH> And I don't find the "you don't have to outrun the bear, you just have to outrun your friend" argument compelling in any form when applied to security
14:42:58 <elliott> good grief.
14:43:17 <shachaf> What if the bear is your friend?
14:43:56 <ReinH> I've listened to a lot of "we're not *that* insecure, just look at our competitors" arguments.
14:44:47 <ReinH> I find them pretty frustrating because they tend to impede progress.
14:45:34 <tac> shachaf: that's what we call a corner case
14:46:03 <lamefun> is there a language that has a package system that's serious?
14:46:21 <FreeFull> lamefun: Standard ML?
14:46:31 <ski> that's a module system, not a package system
14:46:36 <chrisdone> omg hackage 2 ヽ (＾▽＾) ﾉ
14:46:40 <FreeFull> Ah, yeah
14:46:54 <FreeFull> C has plenty of package systems =P
14:47:40 <elliott> ReinH: at no point did I defend cabal/Hackage's insecurity, nor suggest that it should not be fixed. I was offering a comparison and a note that calling cabal unsafe, while accurate, perhaps suggests that the bar for security being offered is far more common and easily-attained than it is, which is relevant when comparing it to other systems.
14:47:57 <elliott> that doesn't mean it's a good thing, but it's a fact.
14:48:04 <lamefun> is GHC signed?
14:48:24 <startling> lamefun, it would probably be signed by package maintainers, depending on how you installed it
14:48:31 <FreeFull> Type system for packages?
14:48:44 <ReinH> elliott: that's true. Most arguments of that form are designed to derail the security conversation, but not all. I shouldn't have jumped to conclusions.
14:49:13 <lamefun> startling, it could be replaced with malicious code while distro's package maintainer downloads it
14:49:53 <startling> lamefun, I don't know of any serious safeguards against an attack like that
14:50:05 <startling> https, I guess?
14:50:31 <enthropy> you might expect the package maintainer to audit things?
14:50:34 <chrisdone> sign the package with the author's private key, the downloader has the public key
14:50:38 <ReinH> lamefun: sadly, there aren't many. Most companies that want such guarantees have an internal vetting process whereby they allow use of approved packages from a trusted internal source.
14:50:40 <enthropy> the distro package maintainer
14:50:43 <startling> that only works if your attacker is not a government or a certificate authority
14:50:58 <ReinH> lamefun: this makes it about as easy to use new packages as you might think :/
14:50:59 <elliott> ReinH: I do think signed packages would be a really good idea, but I think it's important to realise that even once you have signed packages, the problem of trust is a very difficult one.
14:51:35 <ReinH> elliott: absolutely, but it's a problem I would like to at least be able to address.
14:52:20 <ReinH> An alternate universe hackage that started with signed packages could have a robust trust network by now :)
14:59:38 <elliott> ReinH: also, for instance, edwardk's signature on a package will imply trusting about 50 random github users too :p
15:00:14 <FreeFull> I trust edwardk
15:00:16 <FreeFull> Do you?
15:00:18 <ReinH> elliott: yep, that's why you need to start building a chain of trust :)
15:00:32 <ReinH> also so that when it breaks you can BLAME somebody ;)
15:00:33 <shachaf> edwardk looks over commits, for the most part.
15:00:39 <FreeFull> Can everyone edwardk trusts be trusted?
15:01:15 <FreeFull> I think it's difficult to write Haskell code that looks like it does the right thing, but actually does something evil
15:01:22 <startling> do you trust everyone who ever committed to lens?
15:01:30 <startling> (because they all have the commit bit)
15:01:42 <shachaf> Some people have a commit bit and have never committed to lens.
15:01:46 <zeiris> I don't trust edwardk's machine, or ability to vet every commit to his code for sneaky backdoors. The underhanded Haskell contest wouldn't be nearly as nasty as the C version, but still.
15:02:11 <FreeFull> I do want to see some underhanded haskell
15:02:16 <ReinH> oh come on guys just grep unsafePerformIO and you're done /s
15:02:20 <zeiris> Having an audit log of package versions uploaded is, in my eyes, sufficient.
15:02:28 <elliott> ReinH: it would be nice if installing a Cabal package didn't, say, grant it rights to do whatever it wants with your home directory.
15:02:36 <ReinH> elliott: also true
15:02:50 <FreeFull> ReinH: or just unsafe
15:02:52 <elliott> that would probably be an even bigger win than signing packages, just sandboxing the builds properly.
15:02:59 <nisstyre> ReinH: also grep for ExistentialQuantification
15:03:01 <elliott> admittedly you usually then immediately load the code and start executing it at runtime.
15:03:11 <FreeFull> I'm sure there is some way to make unsafePerformIO out of unsafeCoerce
15:03:20 <elliott> sigh. trust nothing and move to a desert island
15:03:20 <lamefun> Just make Haskell proprietary, problem solved.
15:03:27 <ReinH> elliott: rubygems recently patched an exploit that would allow a malicious gem to DoS your machine in install by exploiting a bug in the version parsing code.
15:03:47 <ReinH> it's a big attack area
15:03:57 <zeiris> Can't malicious gems just straight up run code?
15:04:27 <startling> zeiris, gems are signed
15:04:28 <elliott> ReinH: fundamentally, I am sceptical that anything as open as Hackage can fundamentally be trusted with the operating systems we have now, unless you sandbox everything you do thoroughly.
15:04:54 <ReinH> zeiris: you can install them such that they can't run their *own* code.
15:05:45 <lamefun> what's the point of installing a gem and not using it?
15:06:06 <ReinH> there's a difference between installing a gem and using a gem
15:06:08 <FreeFull> elliott: Maybe if you only ever used SafeHaskell?
15:06:15 <ReinH> gems that can exploit the rubygems installer are more dangerous than gems that have to be run
15:06:16 <FreeFull> Of course that would rule out stuff like SDL bindings
15:06:48 <ReinH> FreeFull: You can mark anything you want safe. SafeHaskell isn't any more trustworthy than the authors of the packages.
15:06:58 <elliott> that's not true.
15:07:07 <elliott> you have to explicitly trust to get a Trustworthy module to be safe.
15:07:11 <maverick_> Is there a way I can give my haskell file an input so it creates an output of it in the CMD of windows?
15:07:13 * ski . o O ( "InferredSafe" )
15:07:14 <elliott> modules that are marked as Safe are machine-checked to be safe given your trust.
15:07:18 <maverick_> Input as a text file
15:07:37 <ReinH> elliott: gotcha
15:07:38 <FreeFull> Otherwise SafeHaskell wouldn't be very useful
15:07:42 <lieven_> there was a blog post mentioned here a while ago on how to run a string containing x86 assembler but I can't find the reference anymore.
15:08:04 <FreeFull> lieven_: I think it didn't even involve any function with unsafe in the name
15:08:17 <epta> .цшт 28
15:08:18 <lieven_> FreeFull: indeed it didn't. just FFI.
15:08:58 <FreeFull> lieven_: And bytestrings
15:09:08 <lieven_> yeah. do you have the url?
15:09:27 <chrisdone> http://this-plt-life.tumblr.com/post/36425241559/when-i-read-a-blog-post-by-robert-harper
15:09:29 <FreeFull> Trying to find it right now
15:11:35 <zeiris> ReinH: did the ruby gem signing shenanigans result in a workable system? Last I checked, they got bogged down in getting everything signed and the default permissions were still accessible.
15:12:16 <ReinH> zeiris: I mean, you can sign stuff. But no one really does it and if they do, no one really checks. :/
15:12:32 <ReinH> they still need to make signing easier for gem publishers
15:13:14 <ski> nisstyre : what about existentials ?
15:13:38 <nisstyre> ski: they're a code smell
15:13:42 <zeiris> Migrating something like hackage, with tonnes of missing maintainers, onto signing would be challenging. If you added an "Install unsigned package <foo> y/n?" people would just learn to hit y by default.
15:13:51 <nisstyre> well, the extension is
15:13:55 <nisstyre> not existential types in general
15:14:05 <jmcarthur_mobile> I disagree.
15:14:10 <nisstyre> about what?
15:14:19 <jmcarthur_mobile> Why is the extension a smell?
15:14:36 <jmcarthur_mobile> I shouldn't disagree without hearing it out first.
15:14:38 <nisstyre> jmcarthur_mobile: because they're hardly ever really needed
15:14:45 <maverick_> Does someone knows how I can give my haskell file an textfile as input and it creates an textfile output afterwards in my CMD?
15:15:03 <nisstyre> jmcarthur_mobile: show me a really good use of them
15:15:08 <Iceland_jack> maverick_: In your CMD?
15:15:11 <nisstyre> and I'll concede that they can be useful
15:15:22 <jmcarthur_mobile> nisstyre: free applicatives
15:15:27 <maverick_> ghc file.hs <input.txt> output.txt
15:15:34 <maverick_> I thought there was a notation like this or something
15:16:04 <enthropy> maverick_: runghc file.hs things you can access using System.Environment.getArgs
15:16:26 <nisstyre> jmcarthur_mobile: ok I'll have to go understand that first
15:16:27 <FreeFull> maverick_: < and > are shell redirection
15:16:31 <jmcarthur_mobile> nisstyre: also, Nu
15:16:45 <enthropy> FreeFull: CMD.EXE doesn't do that as far as I know
15:16:49 <ski> nisstyre : not sure whether you think `CoYoneda' is a good use
15:16:51 <jmcarthur_mobile> nisstyre: which is particularly useful for stream fusion
15:17:03 <FreeFull> maverick_: < will take a file and pipe it into stdin, and > will take stdout and pipe that to a file. It doesn't work with cmd.exe, as enthropy said
15:17:07 <nisstyre> jmcarthur_mobile: okay that's a very useful thing
15:17:48 <maverick_> Hmm is there any other way to do it then?
15:17:49 <ski> nisstyre : and `Density' as well
15:17:57 <FreeFull> lieven_: Found it: http://mainisusuallyafunction.blogspot.co.uk/2010/09/executing-bytestring.html
15:18:20 <jmcarthur_mobile> nisstyre: any sort of defunctionalization
15:18:26 <enthropy> maverick_: did you understand my suggestion?
15:18:28 <nisstyre> ski: not really sure what that is, I know Yoneda is a category thing but it's a bit beyond me to try and understand it well
15:18:34 * ski . o O ( `< input command > output' )
15:18:35 <nisstyre> *category theory thing
15:18:44 <jmcarthur_mobile> nisstyre: since the existential allows to reify the closure
15:18:49 <maverick_> Nope, I'm just a newbie here
15:18:58 <jmcarthur_mobile> *the variables closed over
15:18:59 <nisstyre> jmcarthur_mobile: you can reify closures with existentials?
15:19:05 <FreeFull> maverick_: You can write your program to take files as arguments
15:19:17 <FreeFull> And then read or write to them inside the program
15:19:24 <maverick_> Aha I see
15:19:25 <nisstyre> oh I think I see what you mean
15:19:26 <jmcarthur_mobile> nisstyre: not as a function from a closure to something else, but as a code transformation
15:19:27 <ski> nisstyre : `data CoYoneda f b = forall a. CY (f a) (a -> b)' and `data Density w b = forall a. D (w a) (w a -> b)'
15:19:29 <enthropy> maverick_: well you can have:   main = do [inputFile,outputFile] <- getArgs; ...
15:19:32 <nisstyre> jmcarthur_mobile: yeah
15:19:36 <startling> don't you need existentials for Cont?
15:19:42 <startling> Or is that just RankWhatever?
15:19:55 <ski> nisstyre : i don't see how to eliminate the existential in these cases
15:19:56 <maverick_> Thanks a lot
15:20:18 <nisstyre> ski: me neither
15:20:26 <startling> yeah, I'm confusing things, it's Rank2/RankNTypes
15:20:37 <ski> startling : for `PureCont' you need `PolymorphicComponents'
15:20:47 <ski> and for a better `callCC', you want rank-3 types
15:21:05 <FreeFull> -XRank2Types is actually the same as -XRankNTypes
15:21:14 <ski>   data PureCont a = PC (forall o. Cont o a)
15:21:22 <startling> doesn't RankNTypes switch on PolymorphicComponents?
15:21:24 <ski>   data PureContT m a = PCT (forall o. ContT o m a)
15:21:27 <ski> startling : yes
15:21:30 <jmcarthur_mobile> ski: rank 3 borders on existential sometimes
15:21:36 <startling> Yeah, that's what I'm thinking of then. thanks!
15:22:13 <ski>   callCC :: MonadCont o m => ((forall a. b -> m a) -> m b) -> m b
15:22:16 <ski> jmcarthur_mobile : elaborate ?
15:22:47 <jmcarthur_mobile> ski: I'm referring to the encoding of existential quantification in terms of universal quantification
15:23:02 <ski> nisstyre : e.g., consider the case `CoYoneda IORef b', which is iso to `exists a. (IORef a,a -> b)'
15:23:08 * jmcarthur_mobile tires of typing this on phone... 
15:23:24 <ski> (you don't like mobile code ?)
15:23:39 <ikarus> hrm, how can I trace where an exception came from ? (it's from outside my own code)
15:24:01 <ski> jmcarthur_mobile : yeah, my problem with it is that its indirect
15:24:28 <jmcarthur_mobile> "indirect"? Is that being used in some formal sense?
15:25:53 <jmcarthur_mobile> You just mean that you don't like the continuation passing style that encoding requires?
15:26:31 <elliott> ski: but just picking a = Void is enough with the existing callCC.
15:27:48 <ski> elliott : you may have to eta-expand
15:27:58 <jmcarthur_mobile> elliott: void is forall a. a
15:28:11 <elliott> I mean that ski's signature and callCC are equal in power
15:28:24 <elliott> because you can pick a = Void and liftM absurd
15:28:47 <shachaf> I,I ((b -> m (forall a. a)) -> m b) -> m b
15:28:50 <jmcarthur_mobile> Ah
15:29:47 <ski> elliott : yeah, that `liftM' constitutes eta-expansion, in this case
15:29:54 <ski> this may hinder tail-recursion
15:30:09 <elliott> fair enough
15:30:15 * startling asks ski for a signature
15:30:21 * startling proves LEM
15:30:34 * ski hands startling `not :: Bool -> Bool'
15:30:37 <ski> there you go
15:30:57 <startling> >:(
15:34:11 <Peaker> Hackage 2 is snappy! :)   does using happstack imply using lazy I/O or no longer?
15:34:27 <cadabra> Can I match across lines with Text.Regex.PCRE? Nothing I tried seems to work...
15:40:17 <mgsloan> cadabara: I believe you need to use "compMultiline"
15:40:56 <sm> you're right, it is snappy
15:41:17 <mgsloan> It is! I could answer that question in 50seconds because hackage responded fast enough
15:44:01 <ikarus> ... ah, the ghc in Debian is so old it doesn't have -xc ....
15:44:36 <shachaf> How old is that?
15:44:39 <FreeFull> Is there anything in Debian that isn't old?
15:45:01 <hpc> debian stable?
15:45:09 <hpc> maybe the documentation
15:45:48 <elliott> -xc is a runtime option.
15:45:50 <elliott> @where rts-xc
15:45:51 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
15:46:53 <cadabra> Why is Text.Regex so complicated... After all these years, it's still a pain every single time. Sigh.
15:47:46 <Iceland_jack> cadabra: To make you avoid using regexps! /s
15:49:03 <cadabra> Ha ;o I guess I *could* write parsec routines for this junk
15:52:41 <Cale> cadabra: Using proper parser combinators is almost always nicer than using regular expressions. The only reason I'd use a regex library these days is if I was required to make regular expressions work for the users of my program.
15:57:57 <mangaba_leitosa> shachaf: eventually, I found data-lens easier than lens if I just want handy record fields and don't want to learn it in depth :-)
15:59:37 <mangaba_leitosa> shachaf: data-lens won't fail with fatal error if the type contain constructors without record fields, and it wan't wrap everything into Maybe if the type has more than one constructor :-)
16:00:30 <shachaf> I don't know what "fatal error" you're talking about here.
16:01:00 <shachaf> If you write data Foo = A { x :: Int } | B { y :: Char }, then x (B 'a') will fail with a fatal error at *runtime*.
16:01:48 <mangaba_leitosa> shachaf: the fatal error is when makeLenses refused to work with a type like data Foo = A { x :: Int } | B, where the second constructor does not have fields
16:02:44 <shachaf> Works for me.
16:02:55 <mangaba_leitosa> shachaf: for me it just said your constructor is expected to have N arguments and it doesn't and fails
16:03:09 <mangaba_leitosa> shachaf: maybe my version was different
16:03:38 <shachaf> Maybe. You've never said what your actual code or actual errors were, so I resorted to guessing.
16:03:59 <shachaf> That's my mistake. Tell people what your actual code and actual errors are. :-)
16:04:08 <mangaba_leitosa> shachaf: let me try again...
16:11:24 <mangaba_leitosa> shachaf: ok I installed it again and trying now...
16:18:06 <mgsloan> cadabra: text-icu seems pretty nice: http://hackage.haskell.org/package/text-icu-0.6.3.5/docs/Data-Text-ICU-Regex.html
16:18:14 <mgsloan> albeit probably slower due to the unicode support
16:22:22 <mangaba_leitosa> shachaf: I played a little bit to figure out about which data definition it will complain and about which not, but failed. Here is the code and the error messages: http://lpaste.net/93464
16:23:31 <dmj`> fg
16:23:34 <mangaba_leitosa> shachaf: so, it won't work for 'data T = T1 Int Int | T2 { _field1:: Int, _field2:: Int}' (see lpaste above), but WILL work for 'data T = T1  | T2 { _field1:: Int, _field2:: Int}'
16:24:04 <shachaf> mangaba_leitosa: Aha.
16:24:13 <shachaf> mangaba_leitosa: Maybe you've found a bug.
16:24:18 <stevejb> hello, I am working on debugging my first large haskell program and I have found that I need a stack trace. Is there a way to completely reinstall haskell platform and any other library that I have installed in one swoop, or is it something that I need to do by hand?
16:24:30 <stevejb> meaning, reinstall with the profiling libraries?
16:24:36 <mangaba_leitosa> shachaf: look like this indeed
16:24:42 <mangaba_leitosa> shachaf: looks like this indeed
16:25:55 <mgsloan> cadabra: Nvm, the whole IO match results stuff is gross (incidentally I'm doing something regexey right now)
16:29:33 <mangaba_leitosa> shachaf: does it fail for you the same way?
16:30:59 <merijn> stevejb: The platform stuff should come with profiling libraries, I don't think there's a way to rebuild everything with profiling in one go, though
16:31:17 <merijn> stevejb: In terms of debugging, have you look at our good friend Debug.Trace?
16:31:35 <merijn> stevejb: ghci also has a builtin debugger, but that's not quite as useful as in non-lazy languages
16:32:19 <merijn> @quote cmccann adhd
16:32:19 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
16:38:13 <Ralith> really, it's still pretty useful
16:39:06 <k00mi> isn't there something like `cabal install world`?
16:39:34 <tabemann> yes
16:43:35 <shachaf> mangaba_leitosa: Yep.
16:43:41 <shachaf> mangaba_leitosa: You should open a bug.
16:44:22 <chaoslynx> is there a way to read a chunk of a binary file and bind it to fields of a record, like you can in C, with fread by passing a pointer to the struct?
16:44:47 <shachaf> mangaba_leitosa: Thanks for showing your code, either way.
16:45:14 <chaoslynx> right now I've written a parser with attoparsec, but that makes everything much longer than what one could do in C
16:46:49 <mangaba_leitosa> shachaf: I did not show you the code right away because I believed that my description 'complains about constructors without field names and fails' is sufficient for describing issue  :-)
16:47:07 <shachaf> When in doubt, err on the side of showing code.
16:47:12 <shachaf> When not in doubt, show code anyway.
16:47:18 <mangaba_leitosa> sure :-)
16:47:22 <mangaba_leitosa> will do
16:47:46 <mangaba_leitosa> shachaf: thanks for looking into this
16:48:24 <shachaf> mangaba_leitosa: But, really, open a bug. :-)
16:48:26 <ReinH> I'm going to have to write a k-d tree package for Linear, aren't I...
16:49:00 <geekosaur> chaoslynx, you may want to use Data.Binary instead of attoparsec. if you are expecting to do true C-style reads, how were you expecting the result to work in Haskell? a flat C struct is not directly usable
16:49:17 <mangaba_leitosa> shachaf: I'll try. I think this assumes trying the latest dev release first before reporting the bug... I just installed what I had my Gentoo packages
16:49:34 <mangaba_leitosa> shachaf: will need to try on the latest version
16:50:20 <shachaf> mangaba_leitosa: I'm pretty sure nothing has changed in that code for a while.
16:51:04 <mangaba_leitosa> shachaf: ah, OK. Do I report via email to  A. Kmett <ekmett@gmail.com> ?
16:51:16 <mangaba_leitosa> shachaf: ah, they have a bug tracker
16:51:18 <startling> Wrong vowel.
16:51:22 <shachaf> Report it on github.com.
16:51:23 <shachaf> Yes.
16:51:42 <mangaba_leitosa> startling: vowel?
16:51:51 <startling> mangaba_leitosa: it's E. Kmett, not A. Kmett.
16:51:52 <shachaf> startling: Edward A. Kmett.
16:52:54 <mangaba_leitosa> startling: ah, I stripped the beginning when copy/pasting :-)
16:53:15 <startling> oh, heh
16:54:52 <chaoslynx> geekosaur, i might be wrong but except some types not a lot would change in http://lpaste.net/93465, if I used Data.Binary
16:55:41 <geekosaur> probably correct. but you haven't answered the more key question anyway
16:56:01 <geekosaur> Haskell's internal representation IS NOT C's internal representation
16:56:09 <geekosaur> you can't use a struct directly
16:56:27 <Peaker> chaoslynx: Reading into a struct in C kinda works, and people rely on it, but it's not really a portable thing to do.. different compilers can have different representations for same struct
16:56:34 <mangaba_leitosa> shachaf: done: https://github.com/ekmett/lens/issues/341
16:56:51 <shachaf> mangaba_leitosa: Thanks!
16:57:14 <Peaker> chaoslynx: so the "right" way to do it in C is reading it field by field.. Haskell forces you to do it the right way if you have a particular wire format to adhere to.  If not, you can just derive a Binary instance
16:57:14 <geekosaur> there is horrible stuff like the internals of BytrString
16:57:20 <mangaba_leitosa> shachaf: np :-)
16:57:28 <geekosaur> *ByteString
16:57:38 <Peaker> chaoslynx: in fact, deriving a Binary instance is very much like the C solution, in terms of not having a wire format but is more portable/correct
16:58:05 <chaoslynx> Peaker, ok so the right way would be to derive the Binary instance?
16:58:25 <Peaker> chaoslynx: do you need to be compatible with C? or any other thing except your own code?
16:59:05 <jhormuz_> Do any of you apt-get your haskell platform, of do most of you build from source?  (I would rather use apt-get but it is always out of date, so I end up building from source)
16:59:27 <chaoslynx> Peaker, i want to be compatible with C
16:59:40 <hpc> jhormuz_: i download the latest ghc binary and compile cabal myself
16:59:42 <shachaf> jhormuz_: Another possibility: Don't use haskell-platform.
16:59:46 <Peaker> chaoslynx: did you consider protocol buffers?
16:59:53 <hpc> but it's kind of a lot of work
17:00:51 <jhormuz_> hpc- why do you prefer this?
17:01:20 <hpc> jhormuz_: no idea
17:01:30 <hpc> i just did it once and i never really felt the need to do it any differently
17:01:32 <chaoslynx> peaker, i think that might be overkill, for some reason I decided that I wanted to load dds images into opengl not by using some external c binding but with haskell
17:01:57 <hpc> jhormuz_: it's a decent learning experience though
17:02:25 <hpc> (building cabal and maybe even ghc)
17:02:34 <Peaker> chaoslynx: then you have a very specific wire format you need to comply with.. the explicit attoparsec/Binary code is the best option then
17:02:57 <Peaker> chaoslynx: and in your C code, you ought to consider explicitly parsing each field too, since relying on struct layout is not allowed if you want to conform to C's standard, too..
17:03:24 <jhormuz_> I guess I will widen the question....  How do most of you install ghc at all....
17:04:04 <Peaker> jhormuz_: I install it from .deb's, on this machine, from source on others... depending how up-to-date the .deb repo is
17:05:32 <hiptobecubic> jhormuz_, I got the list of library versions and installed them all manually using cabal
17:05:41 <hiptobecubic> jhormuz_, then added them as constraints to my cabal config
17:05:56 <jhormuz_> peaker- I am curious if you ever had any problems doing this.  When I used apt-get, it put some old libs on the machine.  I could use cabal to install newer stuff in my home dir, but was never able to fully get rid of dependency problems.
17:06:36 <jhormuz_> hiptobecubic- don't you still need the ghc executable before doing this?
17:06:50 <hiptobecubic> jhormuz_, yes. installed ghc via distro package
17:07:21 <jhormuz_> hiptobecubic- so ghc was apt, but all libs were installed by cabal?
17:07:58 <hiptobecubic> jhormuz_, not a debian distro, but yes, essentially. Then put them in my .cabal/config  http://bpaste.net/show/135763/
17:08:22 <hiptobecubic> jhormuz_, So it kind of builds the platform as it's needed when i'm installing other things
17:09:57 <jhormuz_> hiptobecubic- Perhaps I should be doing something similar (although ghc is a release behind in ubuntu, so maybe I build that)
17:10:31 <chaoslynx> Peaker, the reference implementation does that
17:10:45 <hiptobecubic> jhormuz_, you could steal the platform from debian unstable maybe?
17:11:13 <Peaker> chaoslynx: it's common practice, portability isn't highly valued
17:11:37 <jhormuz_> hiptobecubic- maybe, but that sounds like more work than building (ie- I probably need a bunch of debian dependencies, etc)
17:12:16 <chaoslynx> Peaker, the plugin for gimp does the right thing :)
17:12:57 <hiptobecubic> jhormuz_, so forget the distro packages all together. Get a binary ghc, dump it in ~/.local/bin, build cabal-install, then cabal install the versions of the libs in the platform (don't forget alex and happy)
17:14:20 <jhormuz_> hiptobecubic- sounds good, I am rebuilding right now, will let you know how it goes....
17:14:59 <hiptobecubic> cabal install this list http://bpaste.net/show/135765/
17:15:24 <hiptobecubic> It's just what's in the config
17:15:58 <mischov> Should 'cabal install ghc-mod'  work on GHC version 7.6.3?
17:16:45 <jhormuz_> hiptobecubic- Thanks
17:20:02 <mangaba_leitosa> shachaf: BTW, in contrast, data-lens worked like a charm. But it reminds of J or APL because of its naming style for operations like (^%%=)
17:22:54 * mangaba_leitosa always assigned names to all J functions when trying to use it :-)
17:24:59 <elliott> data-lens does significantly less than lens.
17:25:05 <elliott> lens is practically misnamed, really.
17:25:37 <ReinH> elliott: lens-and-a-fuckton-of-other-related-stuff doesn't quite roll trippingly off the tongue.
17:27:37 <mangaba_leitosa> elliott: I only wanted record labels anyway :-)
17:27:47 <elliott> mangaba_leitosa: that's what you think. :)
17:30:07 <mangaba_leitosa> elliott: I wonder how the authors of haskell could invent select functions in the language standard, but without correspondent update functions...
17:31:06 <mangaba_leitosa> elliott: that's like List.head without List.tail :-)
17:32:00 <elliott> magicman: yeah :) record labels are great, lens just takes it to another level.
17:33:49 <mangaba_leitosa> elliott: but the need to install a library for such a simple functionality is ridiculous... GHC has several extensions for improving match patterns for fields, but none for generating update functions...
17:34:31 <elliott> well, you'd really want it to generate lenses. being able to give the "get" and "set" parts the same name, and compose them together, is very nice.
17:34:50 <mangaba_leitosa> indee
17:34:51 <mangaba_leitosa> d
17:35:08 <startling> mangaba_leitosa: what's wrong with installing a library?
17:35:23 <mangaba_leitosa> startling: the number of its dependencies :_)
17:35:33 <mangaba_leitosa> startling: like 25 or so for lens :-)
17:35:47 <startling> mangaba_leitosa, what's wrong with a large number of dependencies? You install them only a couple of times.
17:36:04 <startling> (I would say 'once', but ...)
17:36:14 <mangaba_leitosa> startling: this means worse portability of the code
17:36:23 <startling> mangaba_leitosa, how so?
17:36:55 <mangaba_leitosa> startling: something trying out your simple code will think twice before trying it out if he needs to install 25 additional libraries
17:37:30 <theWinner> I'm wondering if someone is willing to help me with lenses in my F# code
17:37:31 <elliott> mangaba_leitosa: note that many of lens's dependencies are in the Haskell Platform (so most everyone will have them already and you'd quite likely want to depend on them anyway)
17:37:35 <mangaba_leitosa> startling: (and if those libraries aren't supported by his haskell compiler?) :-)
17:39:06 <mangaba_leitosa> elliott: true...
17:39:14 <elliott> mangaba_leitosa: haha, multiple haskell compilers :) good joke
17:39:23 <elliott> (ok, (a)jhc is experiencing somewhat of a revival right now.)
17:40:24 <startling> mangaba_leitosa, most people "trying out your simple code" won't bother installing GHC, I think
17:40:29 <mangaba_leitosa> elliott: GHC, NHC, hugs are already dead? :-)
17:40:43 <elliott> mangaba_leitosa: nhc and hugs are totally dead, yep
17:40:46 <elliott> as is yhc
17:41:23 <mangaba_leitosa> elliott: oops, not GHC... BHC... or how was its name
17:42:16 <mangaba_leitosa> elliott: ah, HBC. I remember using it instead of GHC when GHC did not have REPL yet
17:42:50 <geekosaur> hbc long dead, I think. only compilers still kicking are (aghc, (a)jhc, and uhc I think
17:43:05 <geekosaur> er. ghc (a)jhc uhc
17:43:06 <elliott> mangaba_leitosa: dead, dead, dead
17:43:09 * geekosaur edit fail
17:43:11 <mangaba_leitosa> :-)
17:43:18 <elliott> is UHC still being worked on?
17:43:28 <elliott> every time I've heard it has recent activity it's been from, like, 2010.
17:43:31 <mangaba_leitosa> elliott: well, then the issue with dependencies is not that significant indeed
17:43:39 <geekosaur> unclear actually
17:48:16 <elliott> geekosaur: https://github.com/UU-ComputerScience/uhc/commits/master looks half-dead, half-alive
17:49:26 <mischov> Is there a hotkey for in the fpcomplete ide equivalent to hitting the play button?
17:50:03 <spaceships> mischov: ":main" ?
17:52:18 <mangaba_leitosa> googled fpcomplete. commercial haskell IDE. hmmm :-)
17:52:29 <mangaba_leitosa> really worth trying?
17:53:31 <mischov> Just dipping my toes.  On some fronts quick to get going with... on others... little confusing but I'm not really in any position to comment at the moment
17:54:03 <WingbeatPony> Speaking of dipping toes, I'm new to the language as of 30 minutes ago. I have no idea what I'm doing
17:54:11 <Polarina> mangaba_leitosa, it took me five minutes to figure out how to make a new file. Haven't yet managed to include a package. I find it cluttered and confusing, honestly.
17:55:25 <WingbeatPony> But I have a pretty good idea of what I want to get done. Can anyone point me in the direction of server libraries and/or be willing to listen to me outline my grand project, in PM if I have to?
17:55:25 <mischov> WingbeatPony: Learn you a Haskell is always a nice starting point
17:56:12 <WingbeatPony> mischov: That's kind of where I started, I've got an okay handle on the language structure by this point but I can't really "do" anything with it yet
17:56:16 <mangaba_leitosa> Polarina: aha... I see
17:56:19 <dalaing> WingbeatPony: this is great, has awesome homework exercises, references Learn You A Haskell as it goes - http://www.seas.upenn.edu/~cis194/lectures.html
17:57:09 <ReinH> Polarina: off to a bad start :(
17:57:20 <Polarina> mangaba_leitosa, I much prefer my own terminal and editor. :)
17:58:01 <mangaba_leitosa> Polarina: I think that vim is the best IDE :-)
17:58:23 <Polarina> I'm worse and use gedit.
17:58:28 * Polarina giggles.
17:58:32 <mischov> emacs was working for me but for some reason things are causing troubles all over my setup
17:58:44 <mischov> so I thought I'd give the fp thing a shot
17:59:03 <mischov> problem number 1... I don't feel like clicking all the time.. and finding hotkeys is murder.
17:59:18 <mischov> fbcomplete thing*, for clarity
17:59:22 <mischov> fp.. even
17:59:47 <mangaba_leitosa> Polarina, mischov: LOL, I went to the site and clicked on Start Trial. It forced me to register, which I did. Now it says: "Cannot start another trial until 2014-01-25" OH MY GOD!
18:00:46 <mangaba_leitosa> so, downloading a trial is even trickier then creating a new file :-)
18:01:04 <mangaba_leitosa> I think the first time I had Javascript disabled
18:01:07 <monochrom> gedit is ok
18:01:13 <mangaba_leitosa> so it assumed that I downloaded the trial once
18:01:24 <mischov> On the other hand, it (the ide) trying to compile stuff frequently means you get a lot of helpful error messages (and a couple less helpful ones)
18:01:28 <mangaba_leitosa> and another attempt is on 2014-01-25
18:02:35 <mangaba_leitosa> maybe it was supposed to open a download window using javascript
18:02:43 <mangaba_leitosa> anyway, I won't try again :_)
18:03:03 <mischov> Nothing downloaded for me.  Browser-based.
18:03:08 <mischov> You just log in and start.
18:03:25 <mangaba_leitosa> mischov: ah, really. it's browser based?
18:03:29 <mischov> Mmhmm.
18:03:31 <mangaba_leitosa> mischov: there is no desktop version?
18:03:54 <mischov> I can't say I'm an expert but I got the idea it was a browser thing.
18:04:38 <mangaba_leitosa> browser-based IDE... I think I never head of any before, unless it was for AJAX development :-)
18:04:44 <mangaba_leitosa> s/head/heard/
18:04:56 <tswett> Ahoy. So in GHC, I'm declaring a type constructor Dual as "type Dual a (m :: * -> *) r = a m r -> m r", and partially applying Dual to one argument later on in the code.
18:05:08 <tswett> Apparently GHC doesn't like that; it wants Dual to be applied to three arguments right off the bat.
18:05:36 <tswett> Can I tell GHC to go ahead and allow me to partially apply it, or will I have to make Dual into a newtype or something instead?
18:06:33 <ski> tswett : the latter
18:07:00 <tswett> *nod* Thanks.
18:07:07 <geekosaur> tswett: ghc cannot handle partially applied type functions at all
18:07:31 <dolio> You can tell GHC to let you partially apply it. But only if it's in a spot where expansion of other synonyms will cause it to become fully applied.
18:10:00 <ski> @let type Comparator a = a -> a -> Ordering
18:10:01 <lambdabot>  Defined.
18:10:05 <ski> @let type AtInt f = f Int
18:10:06 <lambdabot>  Defined.
18:10:12 <ski> @let type IntComparator = AtInt Comparator
18:10:13 <lambdabot>  Defined.
18:10:16 <ski> @type compare :: IntComparator
18:10:17 <lambdabot> IntComparator
18:11:46 <dolio> It's even stricter than it needs to be in that case.
18:12:08 <dolio> Because you can't say 'type AlsoComparator = Comparator'
18:12:45 <dolio> Even though that won't really break anything as long as there are no un-expanded synonyms at the end.
18:13:22 <Taslem> Are there any relatively simple Haskell libraries for processing sound? I'm running Windows and don't really need to be able to play the sounds, just read in and write out files.
18:16:52 <tswett> Taslem: so you're pretty much looking for the ability to read and write audio files? Do you want to do any fancy processing in between?
18:17:42 <Taslem> tswett: Ideally some sort of FFT and inverse, changing speed/pithc. That's about it for the moment, I think.
18:18:50 <tswett> *nod* That sounds like something I'd be interested in using myself, actually.
18:19:46 <tswett> Lately I've been thinking about how I might take an audio file and process it into an image file that somehow indicates what's going on.
18:20:14 <MedDev> Taslem, i'm working on a beat and onset detection library at the moment.
18:20:25 <Ralith> tswett: waterfall?
18:21:05 <tswett> Ralith: it'll probably be some type of spectrogram, if that's what you're asking.
18:21:20 <Ralith> tswett: no, I'm asking if you're familiar with the waterfall visualization
18:21:34 <tswett> Oh. No, I'm not.
18:21:36 <Ralith> which is a spectrogram, so
18:21:47 <MedDev> Taslem, i don't know if libsndfile works for windows but hsndfile is quite easy to use and it has a vector instance which makes for pulling the data out quickly and easily
18:28:03 <roconnor> > seq (seq undefined) 7
18:28:04 <lambdabot>   7
18:28:14 <shachaf> Yep, seq isn't a strict function.
18:28:47 <tswett> Hm. I'd expect every non-constant function to be strict in at least one of its arguments.
18:29:09 * roconnor finds it hard to tell when a function is or eta-expanded or not.
18:29:12 <tswett> > seq (error "first") (error "second")
18:29:13 <lambdabot>   *Exception: first
18:29:28 <shachaf> tswett: Every function has exactly one argument. Are you saying all functions are strict?
18:29:39 <shachaf> (Or constant.)
18:30:12 <tswett> shachaf: I'm thinking of a function returning a function as being a function of multiple arguments.
18:30:23 <roconnor> tswett: by seq is not strict, shachaf means that seq undefined is not equal to undefined.
18:30:27 <roconnor> tswett: no more, no less.
18:30:32 <tswett> Right.
18:30:37 <shachaf> tswett: OK. But I'm not sure what you mean exactly.
18:30:51 <shachaf> At any rate Just is a non-strict non-constant function of one argument.
18:31:13 <tswett> Yeah, come to think of it, that's obviously true.
18:31:54 <roconnor> shachaf: I just posted http://cstheory.stackexchange.com/questions/19165/is-eta-equivalence-for-functions-compatiable-with-haskells-seq-operation
18:32:00 <roconnor> shachaf: I hope it isn't a dumb question.
18:33:19 <tswett> I guess I'm thinking of a certain fact about lambda calculus.
18:33:55 <roconnor> Haskell is a forest of lifted domains.
18:36:29 <tswett> Essentially, the fact that if a term has a head normal form, then it has a form of the form \x1 x2 x3 ... -> a E1 E2 E3 ..., where a is a variable. Or whatever.
18:36:36 <monochrom> I like lifted domains
18:36:42 <theWinner> So I have two lenses where each returns Maybe t
18:36:50 <theWinner> I tried to compose them like this -
18:37:01 <theWinner> lens1 >>| lens2
18:37:07 <roconnor> monochrom: really?  I'm ambivalent.  What makes you like them?
18:37:09 <dolio> roconnor: Do I need to find SPJ tomorrow and tell him our scheme, by the way?
18:37:13 <theWinner> (where >>| is lens composition)
18:37:37 <tswett> Thus making every lambda calculus term with no free variables "strict in one of its arguments".
18:37:40 <theWinner> but since the first lens returns Maybe t, the second lens does not compose
18:37:54 <theWinner> should I be using a different lens composition operator?
18:37:54 <roconnor> dolio: The "scheme" seems ill defined at the moment.  I'm not entirely convinced that all domains are enumerable.
18:38:32 <monochrom> I like "data X = Ctor Int X" having a non-empty solution
18:38:36 <tswett> What do you call a lambda calculus term that has a beta normal form?
18:39:01 <monochrom> and other things granted by non-strictness
18:39:05 <roconnor> theWinner: you probably want a "Maybe t to t" partial lens slotted in between.
18:39:36 <dolio> Haskell expressions are enumerable. Everything else is irrelevant, I think.
18:39:39 <theWinner> is that included in the lens package?
18:40:28 <shachaf> theWinner: You're using lens and a (>>|) operator for composition?
18:40:41 <theWinner> yes
18:41:02 <shachaf> Did you define that yourself because you don't like (.), or what?
18:41:08 <theWinner> truth be told, I'm doing this in F#, but can;t find anyone to help me in F# land
18:41:10 <roconnor> dolio: oh right;  I'm not so happy with your type-1 computability interpreation.  I'm more of a type-2 computability person.
18:41:21 <shachaf> Anyway, traverse is a traversal from Maybe a to a.
18:41:39 <shachaf> You can also use _Just (a prism) if you want to be explicit about it, I guess.
18:41:44 <dolio> roconnor: sclv thought we should save it for next April 1st. But I don't know if I want to wait that long.
18:41:54 <tswett> Right, uh, so, above, I had a type constructor Dual with three arguments, and I wanted to partially apply it. The declaration is now "newtype Dual a (m :: * -> *) r = Dual (a m r -> m r)", but GHC still doesn't like it.
18:41:57 <roconnor> dolio: heh
18:42:02 <tswett> Do I need to define it using GADT syntax or something?
18:42:09 <roconnor> dolio: you should spend between now and April 1st implementing it.
18:42:15 <theWinner> hm, I don't understand that answer
18:42:26 <theWinner> I'm afraid I'm not good at haskell
18:42:47 <theWinner> should I google haskell traverse?
18:42:52 <roconnor> theWinner: in some Lens libraries in haskell land, there is a partial lens/traversal from Maybe t  to t, but I cannot guarentee it is in your F# library.
18:43:04 <Makoryu> Let's say I'm building a scripting language for use as a runtime-loaded DSL (as opposed to an embedded one, which I could load with hs-plugins). Is there a preferred solution for either (1) constructing a non-horrible dynamic type system, or (2) performing type inference from the API I provide?
18:43:13 <shachaf> theWinner specifically asked about "the lens package".
18:43:16 <dolio> roconnor: Yeah, I think that was part of it. Submit an actual patch.
18:43:18 <shachaf> Kind of odd if you're using F#.
18:43:18 <roconnor> theWinner: if your library doesn't support partial lenses or the like, then you are out of luck and will have to do thing the old fashion way.
18:43:52 <theWinner> I don't know if the library supports it, because I don't know what to look for
18:44:00 <theWinner> I'm using Fsharpx btw
18:44:17 <theWinner> unfortunately the terminology is not translating well
18:44:31 <theWinner> could you show me the old-fashioned way?
18:45:17 <roconnor> theWinner: the old-fashion way it to write get and set by hand at the place you want to use it.
18:45:20 <Saizan> roconnor: what do you mean by type-1 vs. type-2 here?
18:45:38 <roconnor> Saizan: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.6784
18:45:42 <theWinner> ah, so don't use lens composition in that case
18:45:54 <theWinner> I don't think that will scale for my code
18:46:03 <roconnor> theWinner: the result of such a composition can never be a lens.
18:46:18 <dolio> roconnor: Considering that forall x. _|_ x = (\_ -> _|_) x, and thus _|_ = \_ -> _|_ is perfectly fine domain theoretically, I'm not sure what other problems there are domain theoretically.
18:46:19 <roconnor> theWinner: only a partial lens a.k.a affine traversal.
18:46:54 <theWinner> ah, I was hoping that there was a special combinator that gave me a full lens
18:47:03 <shachaf> Not for that package's representation of lenses.
18:47:16 <shachaf> Which has nothing to do with lens's, so I'm not sure where that came from. :-)
18:47:21 <roconnor> theWinner: the problem it is that it can never satifiy the get-set law.
18:47:41 <roconnor> theWinner: if one of your Maybe is Nothing, then set must fail, and if set fails, then you cannot get back what you set.
18:47:42 <dolio> roconnor: Man, there's a typo in that abstract.
18:47:44 <shachaf> Or even the get law.
18:47:56 <shachaf> "get l has to be a total function"
18:48:04 <shachaf> That's totally a law.
18:48:39 <roconnor> shachaf: presumably such a fictional lens will result in Maybe a, and get will return Nothing.
18:49:17 <theWinner> roconnor, that's what I intuited
18:49:34 <theWinner> i think
18:50:34 <roconnor> theWinner: to be more specific.  Suppose we have l1 :: Lens A (Maybe B) and l2 :: Lens B (Maybe C).  and we try to make a magical lens l3 :: Lens A (Maybe C) by "composing" l1 and l2.
18:50:53 <ski> roconnor : "type-1" and "type-2" "computability interpreation" ?
18:50:57 <roconnor> theWinner: Suppose I give you an x :: A, such that get x = Nothing.
18:50:58 <ski> dolio : are you assuming that every Haskell value is the value of some (closed) expression ?
18:51:18 <ski> (iow more or less that every (computable) function is algorithmic)
18:51:21 <ski> tswett : it ought to work with no extensions
18:51:22 <roconnor> theWinner: Suppose I give you an x :: A, such that get l1 x = Nothing.
18:52:04 <roconnor> theWinner: then we try to do set l3 x (Just c) for some c :: C.
18:52:28 <roconnor> theWinner: but since there is no B inside x :: A to set, then that set must fail.
18:52:34 <dolio> Probably.
18:52:44 <tswett> ski: well, I think I'm abusing GHC pretty badly. ^_^
18:52:49 <roconnor> theWinner: an hence get l3 (set l3 x (Just c)) = Nothing.
18:52:58 <tswett> http://lpaste.net/93466
18:53:12 <roconnor> theWinner: but this violates the get-set law that says that get l3 (set l3 x y) = y
18:53:26 <roconnor> theWinner: ... that was a bit more involved that I expected...
18:53:39 <theWinner> so you're also saying you cannot write a lens for 'Map a (Map a b)'
18:53:50 <roconnor> theWinner: that's right.
18:53:53 <theWinner> since lookup on the first map can fail?
18:53:57 <theWinner> argh
18:54:04 <theWinner> how do you get around that?
18:54:23 <roconnor> theWinner: we have partial lenses / affine traversals that support such things.
18:54:58 <theWinner> any idea how tedious it would be to implement something similar in F#?
18:55:11 <theWinner> \ Ocaml
18:55:36 <roconnor> theWinner: it is most definitely doable, though it won't quite be as elegant to use as in Haskell.
18:56:05 <theWinner> it doesn't require type classes or templating, right
18:56:15 <theWinner> I don't mind trading away some elegance
18:56:15 <roconnor> theWinner: nope.
18:56:32 <theWinner> I suppose I could try to port the Haskell code
18:56:41 <roconnor> theWinner: in Haskell, due to outragous fortune, the type-class system lets us transparently use lenses and partial lenses an traversals.
18:56:49 <theWinner> however, I suck at Haskell, so who knows if I will be successful
18:57:04 <roconnor> theWinner: a naive implementation in Ocaml / F# would force you to cast Lenses to Partial Lenses explicitly.
18:57:28 <roconnor> theWinner: there may be some clever tricks in Ocaml / F# available that I'm not aware of.  subtyping?
18:57:48 <theWinner> no idea
18:58:13 <roconnor> http://hackage.haskell.org/package/data-lens has both lenses and parital lenses.  You can port that.
18:58:48 <theWinner> perhaps my best bet is to write a question on StackOverflow about defining and using partial lenses and affine traversals in F#
18:59:01 <theWinner> I'll try to port that
18:59:11 <theWinner> not sure how wmuch success I will have :)
18:59:45 <roconnor> theWinner: the master branch at https://github.com/roconnor/data-lens/ has mostly complete support for multi-lenses (aka traversals) if you want to go further.
19:00:01 <theWinner> I'd like to build the port on top of the Fsharpx lenses
19:00:14 <theWinner> I would like to avoid reimplementing lenses
19:00:28 <roconnor> theWinner: it's probably best to start with adding partial lenses. to Fsharpx lenses.
19:00:47 <theWinner> cool - i just hope they would be compatible
19:00:50 <roconnor> (ironically, edwardk's lens library doesn't have explicit support for partial lenses).
19:01:26 <roconnor> theWinner: it should be.  partial lenses is a new data type, and there is a conversion function from lenses to partial lenses.  You will need some operator overloading to make the syntax reasonable.
19:01:41 <theWinner> ok cool
19:02:11 <theWinner> thank you roconner and shachaf
19:02:17 <roconnor> np
19:07:42 <tswett> So, uh, if it's all right for me to link my paste again, could someone tell me why GHC isn't accepting my partial application of a type constructor defined with "data"? http://lpaste.net/93466 My understanding is that it ought to work.
19:10:30 <roconnor> tswett: you have a typo in line 11 in the definition of Plus.
19:11:02 <tswett> roconnor: yeah, looks like that "a" should be a "b".
19:11:50 <tswett> And apparently that was the error. Cool.
19:11:51 <tswett> Thanks.
19:11:59 <roconnor> ... I don't understand the error ...
19:12:22 <roconnor> I mean I don't understand the error message
19:12:27 <roconnor> and how it relates to the actual erro.
19:12:51 <roconnor> My strategy with haskell is to ignore error messages unless I'm out of ideas.
19:13:14 <tswett> I wanted both a and b to have the kind (* -> *) -> * -> *, and it was correctly inferring the kind for a, but it wasn't correctly inferring the kind for b, because I forgot to actually use b.
19:13:28 <roconnor> tswett: that kinda makes sense.
19:13:53 <roconnor> tswett: it presumed that b had kind *
19:14:02 <roconnor> but Dual b doesn't have kind *
19:14:09 <roconnor> unless you apply more arguments.
19:14:35 <roconnor> tswett: try turning on RankNKinds.
19:17:15 <tswett> roconnor: but the error's already fixed.
19:17:39 <roconnor> ... there is no RankNKinds.  I made it up.
19:18:01 <tswett> That would be a pretty cool feature, though.
19:18:39 <tswett> data Apply (a :: k1 -> k2) (b :: k1) = Ap (a b)
19:18:50 <tswett> I guess that's what Idris and the like are for.
19:20:33 <tswett> There, now it compiles. It's going to be so weird if all of this actually works.
19:22:11 <tswett> Now I'm going to bust my brain open trying to figure out how to write "id".
19:24:17 <tswett> "Lolly . Dual $ \(Times arg (Dual rest)) -> rest arg". The simplest identity function I've ever written.
19:24:25 <tswett> No, wait, it's actually the most complicated.
19:27:41 <WingbeatPony> Uh, I'm trying to install haskell on a distro of linux there isn't a package built for... and it would appear GHC is part of haskell. Is there something I'm missing here?
19:28:12 <tswett> Hi WingbeatPony.
19:34:19 <pdxleif> WingbeatPony: What distro?
19:34:32 <WingbeatPony> tinycore linux
19:34:37 <pdxleif> There should be a generic version of haskell you can download / build off the GHC page if your distro doesn't have one.
19:35:00 <elliott> "part of haskell" doesn't really make any sense (maybe you're talking about the haskell platform?); it is true that GHC requires GHC to build
19:35:08 <elliott> and generic GHC binaries for Linux are available to make this possible
19:35:16 <WingbeatPony> Yeah, that's what confused me
19:35:20 <pdxleif> There's some "build from source" instructions here: http://www.haskell.org/platform/linux.html
19:35:21 <elliott> (but you should probably just use the binaries unless you have a few hours to spare building)
19:35:43 <tswett> So there's no compiler or interpreter capable of compiling/running GHC other than GHC itself?
19:35:46 <pdxleif> GHC is a compiler for the Haskell language, just as GCC is a compiler for the C language.
19:36:29 <pdxleif> GHC is written in Haskell.
19:36:55 <WingbeatPony> I found a page for GHC version 7.6.3...am I going to need haskell already to build it?
19:37:04 <pdxleif> But I don't know what you mean by "runnning" - GHC's a binary, just like any other (ls, grep, gcc, etc)
19:37:05 <elliott> you will need GHC if you want to build GHC.
19:37:14 <elliott> like I said, there are prebuilt GHC binaries to do this with, or you can just use the binaries directly.
19:37:28 <elliott> http://www.haskell.org/ghc/download_ghc_7_6_3 ignore the big red warning at the top.
19:37:53 <WingbeatPony> Aha! A prebuilt, generic binary! Circular logic possibly avoided
19:38:58 <pdxleif> Any advice for getting "lens" installed at the moment? https://github.com/ekmett/lens/pull/340
19:39:05 <elliott> WingbeatPony: way back in the mists of time (aka circa 1989), this circularity arose when GHC was rewritten in Haskell, after previously being written in Lazy ML :)
19:39:14 <elliott> you need gcc to compile gcc, too.
19:39:37 <Hodapp> self-hosting compiled languages are quite common.
19:39:59 <Hodapp> I encountered it in the form of SBCL/CMUCL
19:41:35 <WingbeatPony> At least I know I'm not crazy, I guess
19:42:57 <pdxleif> It's fun to watch GCC build itself.  Like watching a robot pull itself out of a package that comes with a small version of itself, that reads the instructions and builds the full robot.
19:43:36 <WingbeatPony> Almost makes you want to write a 3D printer controller
19:53:15 <xi`obev> Are we sure there isn't a trojan in ghc that only shows up when compiling ghc and inserts itself into the new compiled binary?
19:53:31 <xi`obev> And perhaps that will eventually wreck havoc?
19:53:54 <Hodapp> shhhhhh
19:54:59 * CaptainK reaches for tinfoil hat
19:55:15 * Hodapp hands CaptainK a copy of "Reflections on Trusting Trust"
19:55:50 <pdxleif> A teacher told me that's why he'd never assign self-modifing code.  He didn't wanna hear the excuse, "Well, it was correct when I turned it in..."
19:56:00 <Hodapp> 9_9
19:56:28 <roconnor> There are some reasonably strong countermeasures available to Trusting Trust.
19:56:37 <Hodapp> roconnor: like what?
19:57:10 <roconnor> Hodapp: 2 separately developmed non-colluding deterministic compilers.
19:57:15 <roconnor> *separately developed
19:57:50 <Makoryu> Hodapp: Basically, you exploit the combinatorial explosion of effort that attacking all combinations of "compiler A -> compiler B -> ..." would involve
19:57:59 <roconnor> even if both compilers are trying to insert torjans, as long as they aren't colluding with each other, the trechery can be exposed.
19:58:22 <roconnor> though I forget if you can determin who is being trecherous.
20:02:30 <roconnor> @seen t7
20:02:30 <lambdabot> 77
20:02:40 <roconnor> :/
20:02:43 <lispy> I wonder if Yao style garbled circuit logic could be applied
20:03:19 <elliott> Hodapp: http://www.dwheeler.com/trusting-trust/
20:04:35 <fragamus> given an integer n I need an array of integers from 0 to n-1
20:05:02 <Makoryu> > [0 .. 8 - 1]
20:05:02 <tswett> fragamus: [0..n-1]
20:05:03 <lambdabot>   [0,1,2,3,4,5,6,7]
20:05:25 <Makoryu> fragamus: When you say "array" do you mean "list"
20:05:38 <Makoryu> Or do you mean "it really has to be a flat array"
20:06:00 <Makoryu> If you're not sure, you probably do mean "list"
20:06:21 <NemesisD> do people not keep resumes on their sites anymore
20:06:59 <NemesisD> whoops, this isn't #haskell-blah
20:12:11 <Hodapp> elliott: neat, thanks :)
20:15:36 <CaptainK> Hodapp: thanks for the book
20:16:03 <CaptainK> now I can trust...even less than when I thought the NSA was the worst of it
20:17:18 <ReinH> elliott: trusting trust now irrelevant due to transister doping ;)
20:18:16 <CaptainK> lol, ya but that is far less likely
20:19:15 <ReinH> I don't even trust trust trusting
20:19:25 <ReinH> maybe if I fmap fmap fmap it
20:20:24 <ReinH> roconnor: yeah, the first solution to the "trusting trust" game was confidence through independent verification iirc
20:21:27 <tswett> Seems like what I'm trying to do is way harder than it ought to be.
20:22:32 <roconnor> ReinH: the proposed countermeasure is quite a bit different from independent verification.  Though I suppose if you squint you could see it that way.
20:23:08 <roconnor> ReinH: transister doping?
20:23:27 <zeiris> GHC sure links in a lot of static library stuff. What if there's a virus that infects those static libraries, then spreads to all compiled binaries distributed... Then infects the libraries on those machines too!
20:23:34 * roconnor though doping was an essential part of a semi-conductor.
20:24:09 <CaptainK> has anyone ever found something supicious with GHC?
20:24:25 <zeiris> Recent paper on inserting silicon backdoors by changing doping levels. Undetectable via visual analysis, current analysis methods aren't scalable enough to really detect it.
20:24:42 <zeiris> CaptainK: probably not, but we're not gonna let that spoil our fun :D
20:26:59 <CaptainK> well when they started being supicious about the NSA and they lied to the public...many of the supicious types were labeled as tinfoil hatters
20:27:29 <CaptainK> dont sure if hatters is a word :P
20:27:51 <CaptainK> me fail english? unpossible
20:28:05 <roconnor> zeiris: can you give me some idea how to go from fabrication "errror" to software backdoor?
20:28:05 <geekosaur> "haters". "hatters" make hats (cf. the Mad Hatter from Carroll)
20:28:47 <CaptainK> great book
20:28:57 <zeiris> roconnor: the paper in question targeted random number generation and timing attacks on hardware crypto if I remember right. So, not a software backdoor, and likely to be specifically targeted.
20:29:25 <zeiris> Definitely nothing that's relevant to practical GHC/cabal security, which is too obscure a target for anyone sane.
20:29:32 <CaptainK> maybe if I go back to programming my Timex ZX41, there can be no possible backdoor
20:29:50 <roconnor> zeiris: sensible.
20:30:07 <roconnor> CaptainK: ZX81?
20:30:28 <CaptainK> oh ya...memory is failing...or Timex Sinclair 1000
20:30:58 <roconnor> CaptainK: it isn't failing memory; it is a delibrate nerual backdoor inserted by the NSA into your brain.
20:31:33 <CaptainK> haha...can you imagine when they really start inserting shit into the brain direct?
20:31:41 <roconnor> CaptainK: how do you know you are not writing a backdoor into your compiler written in your ZX81?
20:31:52 <zeiris> Even worse; the NSA didn't insert the backdoor, they merely found it and are exploiting it right now as we speak!
20:32:07 <CaptainK> hey...I program hangman...in total confidence...no one is watching me!
20:32:21 <roconnor> CaptainK: that's what you've been programmed to think.
20:32:33 <CaptainK> lol...but I ate the blue pill!!!
20:33:44 <zeiris> On a more practical note, an OS Haskell DSL for generating high level crypto primitives in multiple languages (block cipher modes, padding schemes, protocols, APIs, and anything else high level enough that the generated code has no cost centers in it and doesn't get optimized to death) seems like a useful thing.
20:34:22 <zeiris> Write code once, generate trustworthy code for MSP430 + Arduino + Android + x86.
20:40:07 <jhormuz> I just installed a bare ghc, and am trying to install cabal, but when I run bootstrap.sh, it seems to be rather broken....  downloads pointing to the wrong place, and after I fixed that, it still fails telling me that I need parsec (how do I get parsec without cabal :/ )....  Is there a better way to get cabal?
20:41:09 <CaptainK> can we just blame everything on the NSA?
20:42:37 <CaptainK> maybe time to get a job as an anti-NSA consultant
20:42:56 <jhormuz> how do you gll get cabal installed?
20:43:25 <Makoryu> I just install the platform
20:43:28 <Makoryu> Which comes with it
20:44:42 <jhormuz> makoryu- is the platform up to date (ie- are there things that you can only get by a direct build?)
20:45:36 <Makoryu> jhormuz: It's pretty up to date, yes. There's another release due in November.
20:45:44 <ReinH> roconnor: the exploit alters the dopant polarity transistors on a chip, allowing the gate behavior to be altered http://people.umass.edu/gbecker/BeckerChes13.pdf
20:45:51 <ReinH> *polarity of
20:47:16 <ReinH> roconnor: one pretty significant result is that it can reducing the security of Intel's Ivy Bridge RNG from 128 bits down to any n they choose
20:48:12 <jhormuz> makoryu- thanks....  I am still trying to figure out the best way to get things up (even though I have set up haskell environments a few times, it is always an ordeal)....  If I understand correctly, the HP is the stable way to install stuff.
20:48:17 <ReinH> roconnor: and the "independent verification" I was referring to was Wheeler's paper, although perhaps that's not a very accurate way to summarize it.
20:49:29 <ReinH> but the idea iirc was that you compile the source twice (or n times) through independently written compilers and check for bit-for-bit accuracy
20:49:47 <ReinH> so I thought "independent verification" came pretty close
20:51:06 <ReinH> ah here we go. It's a "bit" more complicated than that :) https://www.schneier.com/blog/archives/2006/01/countering_trus.html
21:00:53 <Adeon> do you know how to put an icon in an executable in cabal/Setup.hs on windows?
21:00:53 <kxra> i'm running into a dependency loop trying to install clckwrks
21:00:59 <kxra> acid-state seems to be the problem
21:01:17 <Adeon> I'm trying to look for another project that does that but haven't found one that does it automatically, yet
21:02:22 <ta479> http://xkcd.com/
21:02:27 <Adeon> it's just that I think my program would be least 118% cooler if it had an icon in the executable
21:07:36 <applicative> kxra: but what is the problem?
21:09:14 <Elision> mua ha ha ha ha
21:09:16 <Elision> http://lpaste.net/93468
21:09:19 * Elision is the worst haskell programmer
21:09:42 <Elision> trigger warning: stupidity
21:09:47 <ReinH> Elision: I... what?
21:09:57 <Elision> it's for dealing out bridge hands :D
21:10:07 <ReinH> Elision: why on earth wouldn't you use:
21:10:09 <kxra> applicative: if i install clckwrks, it fails at trying to install acid-state
21:10:15 <kxra> installing acid-state breaks everything else
21:10:29 <ReinH> deal [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z] ?
21:10:38 <ReinH> hlint even tells you to?
21:10:39 <ReinH> some people
21:10:42 <ReinH> smh
21:10:44 <Elision> ReinH: ... basically anything else? the idea was too dumb not to go for it
21:10:52 <Elision> oh
21:10:55 <applicative> kxra: i'm trying it in a sandbox just a sec
21:11:35 <Elision> I wasn't aware you could do that in pattern matching until hlint told me I could, at which point I was too lazy to redo it
21:11:43 <kxra> applicative: thanks!
21:11:43 <ReinH> I mean, or possibly some other not completely ridiculous thing ;)
21:12:05 <kxra> was asking in #happs, but it seems dormant for some reason
21:12:17 <Elision> ;)
21:12:20 <kxra> probably just a lull in activity. i'm excited for the project
21:12:31 <tswett> deal (a:b:c:d:xs) = (Hand (a:as), Hand (b:bs), Hand (c:cs), Hand (d:ds)) where (Hand as, Hand bs, Hand cs, Hand ds) = deal xs; deal [] = (Hand [], Hand [], Hand [], Hand [])
21:13:05 <Elision> that's the BORING way to to do it, yeah
21:13:41 <applicative> kxra: but are you saying cabal-install fails during building, or declares the whole thing impossible because it cant find consistent versions?
21:14:28 <tswett> deal_ (a:as) (h:hs) = deal as (hs ++ [a:h]); deal_ [] hs = hs; deal xs = (a, b, c, d) where [a, b, c, d] = deal_ xs [[], [], [], []]
21:14:46 <applicative> Elision: you're missing a few cases there ;)
21:15:02 <ReinH> chunksOf, anyone?
21:15:33 <Elision> applicative: well, let's just hope nobody loses any cards under the sofa :p
21:15:41 <tswett> Oh yeah. If the deck is shuffled, you may as well just give the top thirteen cards to the first player, the next thirteen cards to the second, and so on.
21:15:47 <ReinH> > chunksOf 14 [1..52]
21:15:48 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14],[15,16,17,18,19,20,21,22,23,24,25,26,27...
21:15:51 <ReinH> boom
21:16:00 <ReinH> or 13, which I somehow typoed
21:16:00 <tswett> > last $ chunksOf 14 [1..52]
21:16:01 <lambdabot>   [43,44,45,46,47,48,49,50,51,52]
21:16:13 <Makoryu> ReinH: What library is that in
21:16:22 <ReinH> Data.List.Split
21:16:23 <kxra> applicative: it can install acid-build, but installing cabal for some reason breaks
21:16:27 <kxra> is it working fine for you?
21:16:36 <Elision> tswett: but that's not how you deal cards!
21:16:40 <kxra> how can i just uninstall everything and start from scratch?
21:16:47 <Makoryu> Oh man
21:16:51 <kxra> i'm just trying to run clckwrks anyway
21:16:53 <Makoryu> How did I not know about this library
21:16:54 <Elision> but yeah, I'll probably do that
21:16:56 <ReinH> Elision: doesn't matter :p
21:16:59 <Elision> oh hi Mako
21:17:06 <Makoryu> Oh shit hey
21:17:08 <Makoryu> How's it going
21:17:14 <Elision> pretty good
21:17:15 <ReinH> it is how you deal cards up to isomorphim :p
21:17:17 <applicative> kxra: cabal is still building it, but it clearly thinks it has a coherent scheme.
21:17:26 <Elision> abusing haskell pattern matching, you?
21:17:28 <tswett> Elision: okay, so first deal the deck into four piles and stack the piles on top of each other, and then deal the cards the way I suggested. :D
21:17:36 <Elision> hehehe
21:17:49 <Makoryu> Elision: Things... And stuff
21:18:30 <tswett> Dang. It's pretty weird how the programming language I'm coming up with is very, very similar to Haskell, but seems to be almost impossible to compile into Haskell.
21:18:43 <Makoryu> tswett: There are a few of those...
21:18:44 <applicative> kxra: are you using ghc-7.6 and so on?
21:19:07 <applicative> kxra: and what is the specific complaint about clckwrks?
21:19:12 <Makoryu> Elision: I seem to recall you just getting your feet wet in Haskell a couple years ago... How's it been treating you
21:19:45 <Elision> heh, all right
21:20:30 <tswett> A program in this language consists of a set of type and function declarations. Functions have STLC-like types. Evaluation is lazy. Every Haskell type is interpretable as a type in this language, and every Haskell function definition could be trivially translated into this language.
21:21:16 <kxra> applicative: let me try it again
21:21:33 <kxra> happstack-authenticate-0.10.5 depends on acid-state-0.11.3 which failed to install
21:21:56 <kxra> then i can install that, but i have to force-reinstall everything else which breaks things
21:22:09 <applicative> man, everything written bos takes a half an hour to compile; it's okay though, everything is really fast after that...
21:23:02 <ReinH> > transpose $ chunksOf 4 [1..52] -- Elision
21:23:03 <lambdabot>   [[1,5,9,13,17,21,25,29,33,37,41,45,49],[2,6,10,14,18,22,26,30,34,38,42,46,5...
21:23:09 <ReinH> if you really want them in the order they would be dealt
21:23:48 <tswett> > (!! 2) . iterate (concat . transpose . chunksOf 4) $ [1..52]
21:23:49 <lambdabot>   [1,17,33,49,14,30,46,11,27,43,8,24,40,5,21,37,2,18,34,50,15,31,47,12,28,44,...
21:23:59 <ReinH> what no
21:23:59 <ReinH> :p
21:24:08 <tswett> > (!! 52) . iterate (concat . transpose . chunksOf 4) $ [1..52]
21:24:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:24:08 <applicative> kxra: if you do ghc-pkg list bytestring does it mention -0.10 ?
21:24:11 <ReinH> stop that
21:24:16 <tswett> no
21:24:34 <ReinH> :p
21:25:51 <Elision> heh
21:26:09 <tswett> Sorry, I have to do one more. It's mandatory.
21:26:12 <tswett> > (!! 51) . iterate (concat . transpose . chunksOf 4) $ [1..52]
21:26:14 <lambdabot>   [1,14,27,40,2,15,28,41,3,16,29,42,4,17,30,43,5,18,31,44,6,19,32,45,7,20,33,...
21:26:37 <ReinH> tswett: so a perfect shuffle has a cycle of 8
21:26:39 <ReinH> > (!! 8) . iterate (concat . transpose . chunksOf 2) $ [1..52]
21:26:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:26:50 <Elision> perfect
21:27:01 <tswett> Just 8, eh? Is there an obvious reason for that?
21:27:04 <ReinH> true story
21:27:10 <kxra> applicative: http://pastebin.ca/2459011
21:27:12 <Elision> something something permutation groups
21:27:28 <Elision> > (!! 4) . iterate (concat . transpose . chunksOf 4) $ [1..52]
21:27:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:27:35 <Elision> yeah it's actually 4 I guess
21:27:36 <ReinH> tswett: if you  must know http://www-stat.stanford.edu/~cgates/PERSI/papers/83_05_shuffles.pdf
21:27:49 <Elision> which totally makes sense
21:27:52 <ReinH> nerd sniped.
21:28:58 <applicative> kxra: I thought this might be part of it. But there is still something fishy. In your case it restricted its attention to a fairly old acid state, but I notice in my case it isn't using the most recent one.
21:29:32 <applicative> kxra: something needs to be done about the two bytestrings, you need a more recent ghc. but admittedly that isn't the whole story in this case
21:29:35 <tswett> So what you're telling me is that the group generated by this shuffle is the same as the multiplicative group generated by i.
21:29:40 <tswett> Suspicious.
21:30:58 <ReinH> symmetric group, yes http://en.wikipedia.org/wiki/Symmetric_group
21:31:32 <kxra> applicative: ok, running apt-get dist-upgrade now
21:31:44 <applicative> kxra: oh do they have a more recent ghc, good
21:31:52 <kxra> maybe that'll fix it, even if it technically shouldn't be necessary
21:32:13 <kxra> i wish cabal wasn't such a pain >,<
21:32:20 <tswett> It's just the cyclic group of order 4, isn't it? There is no symmetric group of order 4.
21:33:28 <applicative> kxra: this is mostly a case of being committed to some major libraries that are by now out of step with hackage. I am confident that with a new ghc cabal update/ cabal install clkwrks -j will work fine
21:33:36 <applicative> kxra: it will just take forever ...
21:33:49 <kxra> what's -j?
21:33:58 <applicative> kxra: parallel builds
21:34:18 <ReinH> tswett: in S_2n a perfect shuffle sends k | k <= n = 2k-1 | k > n = 2(k-n)
21:34:27 <applicative> i just mention it cause there are so many dependencies...
21:35:03 <applicative> kxra: you don't get as much information in the event of a breakdown if you just -j
21:37:09 <Elision> hm.... how many fixed points does it have
21:37:23 <ReinH> Elision: er... infinitely many?
21:37:32 <haasn> Ooh, new hackage. But now hayoo doesn't work :(
21:38:00 <haasn> Hmm.. isn't there some HashMultiSet ?
21:39:44 <Elision> > filter (uncurry (==)) (zip [1..52] (transpose . chunksOf 4) $ [1..52])
21:39:44 <lambdabot>   Couldn't match expected type `[b1]'
21:39:45 <lambdabot>              with actual type `[a1] -> ...
21:39:54 <Elision> balls
21:40:17 <applicative> kxra: something else is going wrong...
21:40:20 <Elision> > filter (uncurry (==)) (zip [1..52] ((transpose . chunksOf 4) [1..52])
21:40:21 <lambdabot>   <hint>:1:70:
21:40:21 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
21:40:26 <Elision> ah whatever
21:40:43 <applicative> how can happy fail to build, with complaint, setup: The program happy is required but it could not be found
21:41:07 <kxra> applicative: you're running into trouble too?
21:41:23 <kxra> stepcut? meow
21:41:56 <applicative> hah
21:42:53 <applicative> kxra: yes, but it's sort of separate, it's the executable 'happy'. if your package manager has the haskell platform i think it comes with. but i got past the problem.
21:44:12 <applicative> kxra: mysteriously 'cabal install happy' failed, but 'cabal install' from within the happy source was fine.
21:44:51 <applicative> kxra: i'm up to acid-state-0.11.4 ...
21:47:14 <kxra> applicative: my giant dist-upgrade is still running
21:48:29 <applicative> kxra: you might make bold to install the new 'cabal-install' which has 'cabal sandbox ...'
21:51:01 <applicative> kxra: with this sort of monster build you end up doing building a lot from scratch but cabal-install is free to reason without worrying about what you have in ~/.cabal
21:52:33 <ParahSail1n> the bytestring unpack source looks like it would not be very good performance
22:03:42 <applicative> what makes a man use Template Haskell?
22:08:34 <acomar> applicative: having to write a bunch of boilerplate definitions :/
22:09:42 <acomar> i.e. when you need to write a definition for every permutation of two types from a set of types larger than like 4
22:10:56 <applicative> yes, but the errors ...
22:11:28 <kxra> applicative: hm. okay i'm in the same dependency loop it seems
22:12:09 <acomar> applicative: you have to put up with em if you don't want to write a hundred or so definitions by hand
22:12:12 <applicative> kxra: i managed to build it. the only trouble I had was with these two executables you need for preprocessing.
22:13:22 <applicative> kxra: cabal install clckworks --dry-run tells you there's a contradiction, so to say
22:15:10 <adnap> > Data.Foldable.fold . M.fromList $ zip "abc" [[1],[2],[3]]
22:15:11 <lambdabot>   [1,2,3]
22:16:25 <applicative> kxra: the trouble i seem to have had arose from some subtlety about building and using a preprocessor in a sandbox. There is some delicate point about hsx2hs requiring an out of date version of haskell-src-exts
22:17:24 <kxra> applicative: could you help stepcut debug? i may be too slepp deprived to make this work
22:17:39 <applicative> is stepcut around?
22:18:04 <kxra>  was briefly responsive in #happs
22:18:10 <applicative> oh
22:25:34 <adnap> Is an FRP Event a Monoid?
22:43:00 <adnap> If a module defines a type using types from modules other than Prelude, should I do X--I don't know how to do X--so that that importing the module automatically imports the needed types?
22:46:08 <ptc> you should just be able to put "import ThisOtherModule" at the top of your file and be happy
22:47:03 <ptc> adnap: ^
22:51:04 <ReinH> adnap: importing a module will import whatever that module exports
22:53:35 <adnap> Say module A defines "data A = A" and B imports A and defines "data B = B". Importing only B will result in "Not in scope: type constructor or class `A'" Should I do X in B so that this error does not occur when the user of B does not import A?
22:53:49 <adnap> *"data B = B A"
23:03:45 <gaze__> hey guys
23:04:24 <gaze__> would someone mind doing a little code review? I'm confused about how to do something I'd normally do in an object orientey way. http://lpaste.net/93475
23:06:13 <gaze__> oops, sorry, this guy here http://lpaste.net/93475
23:07:40 <ParahSail1n> not seeing why you defined those classes
23:07:46 <ReinH> adnap: importing A does not automatically export A
23:08:13 <ReinH> so module B won't export A unless you specifically add it to the list
23:08:37 <gaze__> ParahSail1n: because I want to have multiple backing canvases
23:08:45 <adnap> ReinH: Yeah, my question is if B should export A
23:08:51 <gaze__> perhaps pdf, mac, windows, linux
23:09:07 <ReinH> adnap: if you want consumers of B to automatically have access to A then yes
23:09:19 <adnap> Well, I am asking for opinions
23:09:26 <ParahSail1n> what is winpaint
23:10:12 <gaze__> ParahSail1n: He should ultimately hold something that represents gradients, line stroke, etc.
23:10:48 <ParahSail1n> still not sure why there are those classes
23:11:00 <gaze__> on windows there doesn't appear to be an actual paint object, so here it'd hold a representation, but skia for instance actually has a paint object so I want to call the various methods on the paint object.
23:11:33 <ParahSail1n> you can do that with regular functions..
23:11:59 <ReinH> adnap: my opinion is that it depends entirely on what you want the behavior to be for your modules
23:12:21 <ReinH> and I don't have enough information to give you any other guidance
23:12:33 <gaze__> this is a very common strategy for abstracting over multiple "backends"
23:12:38 <gaze__> I've seen it in xmonad
23:12:49 <gaze__> vty-ui
23:13:02 <ReinH> LambdaHack, etc
23:13:15 <ReinH> gaze__: but keep this in mind http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:13:27 <gaze__> yes yes! So I'd like to do that.
23:13:36 <gaze__> that's what the second half of my pastebin asks about
23:14:04 <gaze__> one strategy "hides" the backing paint object pointer as an existential, and the other hides it using partial application
23:14:29 <gaze__> but with an existential I can get him back out. With partial application I don't think I can.
23:14:37 <ReinH> I'd prefer the record approach
23:14:44 <ReinH> are you having problems with it?
23:14:51 <gaze__> as do I. I'd use it in a heartbeat if I could figure out how to get this right.
23:15:05 <gaze__> my question about how to use the record approach is at the end.
23:15:29 <gaze__> once the internal state is partially applied, we can't get him back out to mutate it, without something very very clumsy
23:15:52 <ReinH> what internal state?
23:16:14 <gaze__> the pointer to the paint object
23:16:35 * dilinger_ chuckles at today's xkcd
23:16:47 <ReinH> why do you need to?
23:17:04 <gaze__> because it's expensive to recreate 10 slightly different ones.
23:17:27 <ReinH> then that breaks the encapsulation that this depends on
23:17:50 <gaze__> existential types allow me the flexibility to get the thing back out.
23:18:13 <ReinH> right, and that's one of the reasons you would want to use them over the record approach
23:18:14 <adnap> It would be cool if I could standalone-derive multiple instances of the same class with one "deriving"
23:18:14 <albertid> dilinger_, :)
23:18:27 <albertid> is anyone aware of a haskell FRP channel on freenode?
23:20:23 <gaze__> ReinH: So there's no way to use the record approach with the mutating partially applied state?
23:20:44 <ReinH> gaze__: maybe something something monad?
23:20:48 <ReinH> I'm not sure tbh
23:21:29 <gaze__> hmm
23:22:33 <gaze__> anyone else have any ideas?
23:33:37 <gaze__> I think the trick is to model the paint as a monoid
23:47:38 <wagle> whats "obviously" wrong with the expression: 4.13566751e−15 * 299792458 / 0.000475
23:47:58 <wagle> ?  ghci doesnt like it
23:47:59 <zRecursive> I has been frustrated by GHC-7.6.x as `("M-x", spawn "~/bin/clisp.sh")` doesnot work now. IIRC, it works using GHC-7.4.x
23:48:42 <cinimod> what does ghci say?
23:48:44 <zRecursive> it is xmonad
23:48:48 <liyang> wagle: I can see from some of the pixels that that's not a '-' but probably a minus sign or one of the m- or n-dashes..
23:49:37 <leroux> It's the minus sign.
23:49:43 <liyang> I mean, look: - – — are completely different.
23:50:10 <wagle> ah, thanks, that was it
23:50:51 <wagle> what i get for cutting and pasting physical constants from wikipedia
23:51:20 <pdxleif> Shouldn't there be some lib you can import physical constants from?
23:51:38 <pdxleif> > pi
23:51:41 <lambdabot>   3.141592653589793
23:51:43 <cinimod> Do you need the speed of light that precise?
23:51:45 <wagle> h
23:51:50 <pdxleif> > the_melting_point_of_a_kitten
23:51:50 <wagle> > h
23:51:51 <lambdabot>   Not in scope: `the_melting_point_of_a_kitten'
23:51:51 <lambdabot>   can't find file: L.hs
23:52:57 <shiona> pdxleif: I'm sure threetoad has written those as a C-header. We just need a wrapper
23:53:01 <wagle> it was easier to use the precision than to replace some of the digits with 0's
23:53:39 <wagle> well, at least i got the correct answer now
23:53:54 <shiona> well, wrong name, no matter
23:54:04 <haasn> @ask edwardk How about ‘as’ for ‘to . const’? eg. "HeLlo WoRLd" ^.. folded.(filtered isUpper.as '!' `failing` as '.')  --  "!.!...!.!!."
23:54:04 <lambdabot> Consider it noted.
23:59:17 <wagle> wrong units for eV, anyway
