00:21:47 <shelf> scripty: http://www.cse.unsw.edu.au/~chak/papers/intro-computing.pdf
00:49:28 * hackagebot crypto-random 0.0.6 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.6 (VincentHanquez)
01:14:39 <wuttf> any haskell hackers here who would happily join a project but have no idea which?
01:15:03 <Taneb> wuttf, what project are you advertising?
01:15:50 <wuttf> umm, not trying to advertise really, i wanna get someone to code with, im open to any projects
01:16:01 <wuttf> i have some pet projects but most of them are shit though :D
01:17:11 <wuttf> never had the pleasure to hack with someone. I could join some projects but most of them look intimidating for me :D
01:17:24 <wuttf> Taneb: in hs at least
01:19:28 <Taneb> What's your favourite pet project?
01:22:06 <Taneb> wuttf, ?
01:22:07 <wuttf> Taneb: Ehh hard question. Im writing a web toolkit for my newbies to try to get them on hs. Probably that
01:22:20 <wuttf> but im not really working on it, so big task
01:22:24 <wuttf> :D
01:22:49 <Taneb> Well, if you're interests are in web, check out Hapstack, Snap, Yesod, maybe Scotty?
01:23:40 <wuttf> hmm
01:23:56 <pharaun> osm
01:24:11 <pharaun> sorry, isn't scotty unmaint now? but if wuttf want to pick up on that, that could be neat
01:24:29 <wuttf> lemme check scotty
01:24:30 <wuttf> a minute
01:24:41 <zomg> I think just plain warp is pretty easy to work with
01:24:50 <zomg> It is a bit lower level though
01:26:04 <wuttf> hm what I did is to write thin wrappers around db drivers, wai etc, which all uses the same map type, modeled after JavaScript objects, so newcomers can have a full stack without
01:26:14 <wuttf> dealing with a lot of different types
01:26:28 <wuttf> somethign like that would be my idea
01:27:47 <kuribas> In "f x | x < 5 = 2", is f strict in x?
01:28:42 <johnw> > let f x | x < 5 = 2 in f undefined
01:28:43 <lambdabot>   *Exception: Prelude.undefined
01:28:46 <johnw> seems so
01:29:06 <kuribas> Does ghc know when a function is strict in nf?
01:29:20 <kuribas> That it evaluates a whole list for example.
01:29:33 <johnw> i don't follow
01:30:21 <kuribas> For example "f a b c = sum [a, b, c]".  Will ghc figure out f is strict in a, b and c?
01:30:46 <johnw> based on that definition, f is not strict in any argument
01:31:16 <johnw> because it can return the sum call without evaluating the arguments
01:31:26 <kuribas> > let f a b c = sum [a, b, c] in f undefined 2 3
01:31:27 <lambdabot>   *Exception: Prelude.undefined
01:31:37 <kuribas> It's strict...
01:31:39 <johnw> that's happening due to an implicit print
01:31:53 <johnw> you're calling f, then evaluating the return value in order to print it
01:32:03 <johnw> f isn't strict, it's lambdabot forcing the evaluation of the return value
01:32:43 <kuribas> johnw: That's also true of the first function.
01:32:51 <johnw> > let f a b c = sum [a, b, c] in length $ f undefined 2 3
01:32:52 <lambdabot>   No instance for (GHC.Num.Num [a0]) arising from a use of `f'
01:32:53 <lambdabot>  Possible fix:...
01:33:00 <wuttf> is there a generic zero value for types?
01:33:29 <johnw> kuribas: in the former case, it was forced by the <, which happened before f returned
01:34:05 <wuttf> I want to   Maybe a -> (a, Bool)
01:34:16 <wuttf> where Bool is False in case of Nothing and True in case of just
01:34:45 <johnw> > let f a b c = sum [a, b, c] in length [f undefined 2 3]
01:34:47 <lambdabot>   1
01:34:52 <johnw> > let f !a b c = sum [a, b, c] in length [f undefined 2 3]
01:34:53 <lambdabot>   1
01:35:40 <kuribas> > let f x | x < 5 = 2 in length [f undefined 2 3]
01:35:41 <lambdabot>   No instance for (GHC.Num.Num a2) arising from the literal `3'
01:35:41 <lambdabot>  The type var...
01:35:44 <johnw> hmm.. in that case it's not even going to call f
01:35:55 <kuribas> > let f x | x < 5 = 2 in length [(f 2) undefined 2 3]
01:35:56 <lambdabot>   No instance for (GHC.Num.Num a3) arising from the literal `3'
01:35:56 <lambdabot>  The type var...
01:36:17 <kuribas> > let f x | x < 5 = 2 in length [f 2, undefined, 2, 3]
01:36:18 <lambdabot>   4
01:36:24 <kuribas> johnw: Which is my point.
01:36:37 <johnw> i just said that f isn't evaluated in that example
01:36:48 <johnw> f is strict if it evaluates its arguments
01:36:53 <johnw> your first function did, your second didn't
01:37:04 <kuribas> Yes it does.
01:37:13 <johnw> how so?
01:37:21 <kuribas> sum is strict in it's elements.
01:37:29 <johnw> but f doesn't call sum
01:37:29 <kuribas> > sum [undefined, 1, 2]
01:37:31 <lambdabot>   *Exception: Prelude.undefined
01:37:33 <johnw> it returns a call to sum
01:37:53 <kuribas> That doesn't make sense for me.
01:38:32 <johnw> f doesn't need to evaluate a, b or c in order to return the call to sum using a, b and c
01:38:45 <johnw> so any strictness you're observing here relates to sum, not f
01:41:27 <kuribas> What's the definition of strict?
01:42:02 <johnw> "A function f is said to be strict if, when applied to a nonterminating expression, it also fails to terminate."
01:42:18 <kuribas> Then my function is strict.
01:42:23 <johnw> i guess it is
01:42:49 <kuribas> because f _|_ b c = _|_
01:44:06 <krivenok> Hello folks. I've just started learning haskell and implemented starightforward solution for euler project problem #401. My solution "looks" fine for me, but answer is wrong, so I guess I misunderstand something. Could you please look at my script (http://pastebin.com/G7sxTH2P) and point me to the right direction?
01:44:17 <mauke> The paste G7sxTH2P has been copied to http://lpaste.net/92685
01:44:38 <johnw> kuribas: another website says, "A strict function is a function whose arguments are evaluated before the body is."
01:44:46 <johnw> according to that definition, f is not strict
01:44:56 <kuribas> yes
01:46:48 <johnw> but I think an argument can be made here that your f is operationally equivalent to a strict function, even if perhaps it is not strict by definition (in that it doesn't evaluate its arguments, it simply yields a value which, when itself evaluation, will always force the evaluation of those arguments)
01:48:59 <kuribas> In any case, my question is if ghc will consider the second function as strict?
01:49:18 <johnw> I'm sorry to confuse the matter then; I don't know the answer to that question
01:50:02 <kuribas> johnw: According to this, the second f is strict: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Strict_Functions
01:50:12 <mero> hi, profiling a program revealed that it spends about 50% of the time in "make" defined here: http://lpaste.net/92686 I figure this will improve when switching from String to Data.Text or ByteString.. or is there another problem with these two functions?
01:51:05 <johnw> kuribas: ok, thanks for pointing that out
01:51:35 <hiptobecubic> krivenok, I would say that you probably missed the point of this problem and that haskell's lazy eval makes it unfairly easy
01:52:41 <kuribas> johnw: Though it only says something about one argument functions.
01:52:57 <johnw> it later generalizes
01:53:12 <kuribas> Ah, yes.
01:54:16 <krivenok> hiptobecubic: yep, implementing it in haskell should be easy, but my program doesn't produce correct result. honestly, I have no idea where the bug is...
01:55:32 <ski> > let f a b c = sum [a, b, c] in f undefined 2 3 `seq` ()  -- no implicit `print'
01:55:33 <lambdabot>   *Exception: Prelude.undefined
02:03:47 <mm_freak> ocharles: http://lpaste.net/92687
02:03:54 <mm_freak> a simple clock drawn using netwire-gloss
02:07:02 <kuribas> So a function can be strict even when it doesn't evaluate it's arguments.
02:07:18 <kuribas> for example f a b = undefined.
02:07:39 <mm_freak> kuribas: yes
02:09:21 <mm_freak> ocharles: http://hub.darcs.net/ertes/netwire-gloss
02:14:35 * hackagebot google-mail-filters 0.0.1.0 - Write GMail filters and output to importable XML  http://hackage.haskell.org/package/google-mail-filters-0.0.1.0 (LiyangHu)
02:49:40 <wuttf> How efficient is the Data.Text type?
02:49:45 <pharaun> hah i was going to write a package like ^
02:49:50 <pharaun> guess someone beat me to it :)
02:50:57 <donri> wuttf: ETOOBROADQUESTION
02:51:08 <wuttf> donri: lulz
02:51:25 <wuttf> donri: is it bad if I use it for http responses instead of lazybytestrings?
02:51:33 <wuttf> donri: i guess a sane http response is no more than half a meg
02:51:37 <donri> wuttf: it's a utf16 bytestring with stream fusion
02:51:55 <wuttf> donri: so in the order of 1-2 megs? okay to use it?
02:52:11 <donri> wuttf: certainly. there's lazy text too btw.
02:52:41 <wuttf> donri: no worries probably i will return JSONs anyway
02:52:48 <wuttf> donri: and those are small
02:52:51 <donri> wuttf: what type of response? if the response is data text would likely be wrong
02:53:23 <wuttf> donri: u mean in cas eof binary or sumtin like that?
02:53:38 <donri> wuttf: for json you probably want to use say aeson and then render it to a bytestring with the appropriate content-type
02:54:08 <wuttf> donri: ahh okay
02:54:15 <wuttf> donri: sticking with bytestrings then
02:54:37 <donri> wuttf: just make sure you send the right content type :) aeson is utf-8
02:55:50 <wuttf> donri: ahh I see
02:55:59 <wuttf> donri: shit!
02:56:07 <donri> wuttf: anyway you can't actually send Text over the wire so whatever you do it's gonna get sent as a bytestring, sort of. the important thing to consider is the encoding.
02:56:21 <wuttf> minute bruv
02:56:25 <donri> Text is a mirage, an abstraction
02:57:06 <wuttf> donri: i totally get you
02:57:12 <donri> but if you're working with "human" text, you should probably use Text internally
02:57:34 <donri> working with bytestring for human text is like processing xml without a parser
02:59:13 <wuttf> donri: I use regexes to parse xml
02:59:18 <wuttf> donri: just kidding :D
02:59:27 <donri> wuttf: the door is that way ->
03:00:00 <merijn> donri: Wait...utf16? Where is that said? I thought it was some other more efficient encoding
03:02:14 <mm_freak> merijn: what would be more efficient?
03:02:35 <donri> merijn: http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text-Foreign.html#g:1
03:03:57 <donri> merijn: jasper did a gsoc for utf-8 but it didn't get merged http://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
03:05:36 <mm_freak> merijn: btw, you may be interested in that, too:  http://lpaste.net/92687
03:07:31 <Lethalman> mm_freak, nice
03:08:28 <Lethalman> mm_freak, shouldn't hours be 3600 though? :P
03:11:38 <mm_freak> Lethalman: see the annotation =)
03:12:08 <Lethalman> ah
03:12:25 <mm_freak> i could write this much simpler, but i wanted to demonstrate events
03:18:53 <hpaste> tm pasted “No title” at http://lpaste.net/2560525490305630208
03:19:36 <timblechmann> hi, i'm trying to get into haskell, but have some troubles with passing string arguments ... see http://lpaste.net/2560525490305630208
03:20:00 <timblechmann> passing a string as argument works fine, but trying to concatenate causes an error ...
03:20:13 <timblechmann> probably a stupid newbie problem
03:20:14 <timblechmann> any idea?
03:20:29 <danr> timblechmann: does it say that ++ is ambiguous? (either from Data.Tex or Prelude)
03:20:38 <danr> the newbie problem is that you haven't written what error you got :)
03:21:23 <timblechmann> danr: sry for that: Couldn't match expected type `Data.Text.Internal.Text with actual type `[a0]'
03:23:00 <merijn> mm_freak: Well, utf-8 for one
03:23:32 <merijn> mm_freak: Neat, I'll check it out :)
03:23:57 <timblechmann> danr: so from my understanding, it expects a Text, but receives a function? maybe i somehow have to evaluate it explicitly?
03:24:08 <danr> oh
03:24:16 <danr> timblechmann: you forgot to write do after verbosely $
03:24:46 <ski> @hoogle Text -> Text -> Text
03:24:46 <lambdabot> Data.Text append :: Text -> Text -> Text
03:24:46 <lambdabot> Data.Text.Lazy append :: Text -> Text -> Text
03:24:46 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
03:24:58 <Zenol> timblechmann: [a0] is "a list of something"
03:25:08 <mm_freak> merijn: UTF-8 is only faster for english
03:25:16 <mm_freak> for pretty much every other language it's slower
03:25:35 <Zenol> timblechmann: It expect a Data.Text but received a [Char]. One way is to "pack" your string into Text (Data.Text pack)
03:25:43 <mm_freak> merijn: see the article donri linked
03:25:50 <timblechmann> danr: ok, that's from reducing the test case
03:26:39 <timblechmann> Zenol: ok, let me see
03:26:47 <mm_freak> timblechmann: i suggest that you try without OverloadedStrings for now
03:27:10 <mm_freak> timblechmann: that makes the error messages more beginner-friendly and helps you understand where what kind of argument is expected and where conversion needs to occur
03:27:24 <timblechmann> mm_freak: i see
03:27:32 <danr> what's with this default magic? I've never had to use the default keyword
03:28:04 <mm_freak> danr: it makes Text the default for string literals
03:28:16 <mm_freak> in combination with OverloadedStrings
03:28:24 <mm_freak> you don't really need it
03:28:49 <danr> mm_freak: I see
03:29:07 <danr> mm_freak: so this only applies when the type cannot be inferred?
03:29:11 <mm_freak> not sure what the shelly tutorial suggests to use though =)
03:29:24 <danr> it's on the top of the documentation here: http://hackage.haskell.org/packages/archive/shelly/1.3.0.7/doc/html/Shelly.html
03:29:44 <mm_freak> danr: when the inferred type is ambiguous…  i don't know the exact resolving rules though
03:29:53 <mm_freak> it's really the same as this:
03:29:56 <mm_freak> > 2 + 3
03:29:57 <lambdabot>   5
03:30:13 <danr> mm_freak: yeah, I'm with you
03:30:16 <mm_freak> the type of that expression is polymorphic and ambiguous…  defaulting just arbitrarily picks Integer for convenience
03:30:21 <mm_freak> :t 2 + 3
03:30:22 <lambdabot> Num a => a
03:33:03 <timblechmann> danr, mm_freak: afaict OverloadedStrings simplifies the use of shelly ... that's why it is suggested
03:33:42 <mm_freak> timblechmann: it simplifies the use of pretty much any library that uses non-String types heavily
03:33:52 <timblechmann> mm_freak: :)
03:34:20 <ski> timblechmann : you could probably use `append' instead of `(++)' .. or make the latter an alias of the former
03:34:43 <mm_freak> import Data.Monoid and use (<>)
03:35:11 <ski> .. or that
03:36:27 <timblechmann> mm_freak, ski: append did not help (Data.Text.Internal.Text vs Text) ... Monoid and <> seem to work, though
03:36:39 <timblechmann> note to myself: figure out what it does
03:37:10 <mm_freak> timblechmann: (<>) is about the most general "append" you can get
03:37:39 <timblechmann> mm_freak: i see
03:37:52 <mm_freak> here is a witness for how general it is:
03:37:59 <mm_freak> > (id <> reverse) "abc"
03:38:00 <lambdabot>   "abccba"
03:38:01 <mm_freak> =)
03:38:24 <Zenol> ?!
03:38:24 <lambdabot> Maybe you meant: v @ ? .
03:38:48 <Zenol> What does <> on a -> a ?
03:38:54 <mm_freak> if b is a monoid, then a -> b is also a monoid
03:39:00 <mm_freak> (f <> g) x = f x <> g x
03:39:11 <Zenol> :o
03:39:14 <Zenol> Ok :)
03:39:51 <Zenol> Yeh, the same way {f : E -> R} have a sum, product, etc.
03:41:12 <mm_freak> i don't understand that
03:42:02 <mm_freak> ah, yes
03:42:06 <Zenol> r, the right writing would be {f | f : E --> IR} where IR is the set of real numbers, E an arbitrary set, and f a function.
03:42:10 <mm_freak> > (sin + 2*cos) 15
03:42:11 <lambdabot>   No instance for (GHC.Show.Show a0)
03:42:11 <lambdabot>    arising from a use of `M240218564.sho...
03:42:19 <mm_freak> > (sin + 2*cos) 15 :: Double
03:42:20 <lambdabot>   No instance for (GHC.Num.Num
03:42:20 <lambdabot>                     (GHC.Types.Double -> GHC.T...
03:42:34 <mm_freak> oh, apparently it was removed
03:42:48 <mm_freak> > liftA2 (\x y -> x + 2*y) sin cos 15
03:42:50 <lambdabot>   -0.8690879855605258
03:43:13 <mm_freak> and yeah, (<>) = liftA2 (<>)
03:47:27 <Ghoul_> :( lots of discussion on leftToMaybe and isLeft and things, but no sign of a `bool` in sight
03:48:38 <Zenol> Ghoul_: You mean Bool -> a -> Maybe a ?
03:48:53 <donri> a -> a -> Bool -> a, please
03:48:55 <Ghoul_> Bool -> a -> a -> a
03:48:57 <Ghoul_> or something like that
03:49:02 <Ghoul_> what donri suggested
03:49:21 <Ghoul_> basically short-hand if that doesn't look so ridiculous
03:49:58 <mm_freak> maybe the mistake is to use Bool in the first place
03:49:59 <donri> it composes better and is consistent with the other catamorphisms like maybe and either and the fold functions
03:51:39 <mm_freak> :t F.foldr . const . const
03:51:40 <lambdabot> Foldable t => b -> b -> t a -> b
03:51:51 <mm_freak> there is your a -> a -> Bool -> a
03:52:14 <Zenol> @let ifte v1 v2 t = if t then v1 else v2
03:52:15 <lambdabot>  Defined.
03:52:27 <Zenol> > 3 `ifte` 5 $ True
03:52:30 <lambdabot>   3
03:52:43 <Zenol> seams cool.
03:54:45 <Ghoul_> mm_freak: why don't you like it?
03:54:58 <mm_freak> because i don't like Bool in general
03:55:27 <mm_freak> Ghoul_: here is a good explanation: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
03:57:51 <donri> > (F.foldr . const . const) 1 2 False
03:57:53 <lambdabot>   Couldn't match expected type `t0 a0'
03:57:53 <lambdabot>              with actual type `GHC.Typ...
03:58:37 <Ghoul_> its all nice and stuff to say that we shouldn't have it because it's better to not cobble information and blah blah
03:58:52 <Ghoul_> but its honestly a PITA when you need it
03:59:03 <Ghoul_> inline-if's look terrible and/or mucl up indentation
03:59:05 <Ghoul_> *muck
03:59:48 <donri> and doesn't compose pointfree
04:00:08 <Ghoul_> they're trying to fix that with lambda if and lambda case
04:00:15 <Ghoul_> but they look pretty wierd imho
04:00:24 <merijn> Ghoul_: You probably meant MultiwayIf?
04:00:38 <mm_freak> Ghoul_: the point is that you don't really need booleans in most cases
04:00:41 <merijn> There is no lambda if, unless I missed something really major
04:00:54 <donri> haha yeah lets add LambdaIf instead of `bool`
04:00:55 <Ghoul_> I saw on trac a thing in development to allow something like this
04:01:04 <Ghoul_> (if then 1 else 2) True
04:01:15 <Ghoul_> (or something along those lines. Let me hunt it down)
04:01:20 <merijn> maybe, but that doesn't exist atm
04:01:26 <merijn> unlike lambda case, which does exist
04:01:42 <mm_freak> if we ever get Bool out of the Prelude, i wouldn't miss it for a second =)
04:02:19 <Ghoul_> how do you do a foldUntil or dropWhile without bool?
04:02:31 <mm_freak> Ghoul_: let me pick a simpler example: (==)
04:02:48 <mm_freak> (==) :: (Alternative f, Eq a) => a -> a -> f a
04:03:05 <mm_freak> if x and y are equal, the result is pure x, otherwise empty
04:03:21 <Zenol> Question. How would you do, without bolean, to select the value 3 if v1 is the same as v2, and 4 if v1 is not the same as v2.
04:03:26 <Zenol> So, without == or /=.
04:03:53 <Ghoul_> That would increase the entry level to haskell by like.. more than it is already
04:03:57 <mm_freak> Zenol: you need an equality function, but you don't need Bool
04:04:04 <mm_freak> Ghoul_: sure
04:04:22 <Ghoul_> okay ,what if you need to compare two "bools" without bools?
04:04:31 <Zenol> oh, that what you just wrote
04:04:34 <mm_freak> Ghoul_: example?
04:04:53 <Ghoul_> f | (a || b) == (c | d)
04:05:02 <Ghoul_> where a and b are the same but c and d are another type
04:05:14 <Ghoul_> err, I did that terribly
04:05:17 <mm_freak> Ghoul_: (||) = (<|>)
04:05:18 <Ghoul_> make the || and | =='s
04:05:32 <mm_freak> you need Alternative to construct and combine these things and Foldable to do the 'if'
04:05:47 <Ghoul_> This signature aint' gonna work
04:05:47 <Ghoul_> (==) :: (Alternative f, Eq a) => a -> a -> f a
04:05:47 <mm_freak> the major difference is that now the result has a meaning
04:05:55 <mm_freak> why not?
04:06:13 <Ghoul_> a -> a, but they'll be different a's from the f a
04:06:21 <mm_freak> huh?
04:06:26 <Ghoul_> And what meaning does it have that bool doesn't carry?
04:07:05 <mm_freak> 'x == y' is the singular value that represents both x and y
04:07:11 <mm_freak> if that is not possible, it is empty
04:07:12 <Zenol> then (v1 == v2) <$ 3 <|> 4 ?
04:07:17 <mm_freak> it's a very sensible notion
04:07:22 <Zenol> (with your alternative ==)
04:07:29 <Ghoul_> How is that useful though?
04:07:30 <Ghoul_> at all.
04:07:49 <mm_freak> Ghoul_: it's useful in the same way we make a difference between ByteString and Text
04:08:04 <mm_freak> most languages don't and in those languages it bites you from time to time
04:08:20 <Ghoul_> can you give an example where it would be useful?
04:08:33 <mm_freak> Ghoul_: what is your definition of "useful"?
04:08:48 <donri> cf structural vs nominative typing
04:09:06 <donri> but that argument extends to using any "standard" types really...
04:09:10 <mm_freak> Ghoul_: if you don't consider type-safety to be useful, you're really in the wrong channel
04:09:53 <Ghoul_> but type safety isn't useful for predicates because I might want to do something completely independent of the types of the things I previously compared
04:09:54 <danr> the door is ...
04:09:56 <donri> i tend to prefer data PostStatus = Published | Draft over { published :: Bool }, anyway
04:10:07 <mm_freak> Ghoul_: you can
04:10:47 <Ghoul_> Meh, anyway, it would probably be too hard for the optimizer
04:10:53 <Ghoul_> I still punt for bool
04:10:59 <mm_freak> donri: i tend to prefer:  published :: (Alternative f) => Post -> f Post
04:11:13 <mm_freak> donri: then i can just use traverse/mapM
04:11:20 <mm_freak> less bool, more convenience
04:12:05 <mm_freak> Ghoul_: you're really just searching for reasons to justify your conviction
04:12:13 <mm_freak> desparately even
04:12:26 <Ghoul_> I guess this would still require some sort of Bool functor anyway?
04:12:34 <mm_freak> Ghoul_: what do you mean?
04:12:56 <donri> mm_freak: published = filtered (has (status . _Published))  -- ;)
04:13:05 <mm_freak> =P
04:14:08 <Ghoul_> so what does `some (1 == 2)` return?
04:14:33 <mm_freak> Ghoul_: depends on the functor
04:14:49 * hackagebot labyrinth 0.4.1.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.4.1.0 (AlexeyKotlyarov)
04:15:02 <paolino> is there a class for default values like a  half Monoid
04:15:04 <paolino> ?
04:15:19 <merijn> Data.Default :)
04:15:24 <Ghoul_> Maybe I should go do a phd in something computer science
04:15:25 <mm_freak> paolino: you want mempty sans mappend?
04:15:29 <Ghoul_> so I can compare things in haskell
04:15:45 <mm_freak> Ghoul_: not necessary…  i don't have anything close to a ph.d. ;)
04:15:51 <merijn> @hackage data-default
04:15:51 <lambdabot> http://hackage.haskell.org/package/data-default
04:15:51 <paolino> mm_freak, if it makes any sense :-)
04:16:01 <Ghoul_> What are you going to tell the students who take haskell for like 4 months in intro to comp. sci?
04:16:05 <mm_freak> paolino: i think it's called a pointed set
04:16:13 <mm_freak> paolino: but it's not really a useful concept =)
04:16:17 <Ghoul_> That comparing things is waaay over their head
04:16:59 <mm_freak> Ghoul_: it isn't really complicated…  just pick f = Maybe
04:17:16 <mm_freak> "unlike in other languages, when the values are equal you get Just their value, otherwise you get Nothing"
04:17:30 <mm_freak> then explain how to combine and fold Maybes
04:18:00 <mm_freak> and how these operations correspond to the usual boolean operators
04:18:19 <Ghoul_> that means comparable types have to be combinable right?
04:18:24 <Ghoul_> so then they have to be monoids..?
04:18:29 <mm_freak> no
04:18:53 <mm_freak> class Eq a where (==) :: (Alternative f) => a -> a -> f a
04:19:09 <donri> requiring Alternative for Eq is a bit ...
04:19:23 <mm_freak> this will also teach you a valuable lesson about 'not' =)
04:19:25 <donri> oh wait nevermind
04:19:57 <mm_freak> 'not' is one of the weirdest functions from a theoretical standpoint
04:20:23 <mm_freak> and that's why defining a 'not' in this case is not as trivial as for Bool
04:20:28 <FreeFull> mm_freak: That's a weird definition for Eq
04:20:51 <paolino> merijn, that one, I thought it had a place in the categorism
04:21:02 <Ghoul_> well, maybe you can propose this for haskell 2050
04:21:21 <paolino> mm_freak, it seems Pointed is for (* -> *) kinds
04:21:38 <mm_freak> paolino: yes, Pointed doesn't denote pointed sets
04:21:44 <donri> paolino: Pointed is not "pointed sets"
04:21:51 <Ghoul_> *today* we have Bool types, and as much as they might be a wart, *today* it would be nice to have `bool`
04:22:08 <Ghoul_> I don't think Bool will go any time soon
04:22:13 <paolino> I should have guessed
04:22:49 <mm_freak> i should perhaps write prelude-without-bool =)
04:23:28 <donri> mm_freak: call it unconditional-love
04:23:35 <mm_freak> hehe
04:24:18 <Ghoul_> mm_freak: I would be open to trying it out
04:24:36 <Ghoul_> It certainly doesn't sound *bad*
04:24:40 <Ghoul_> What happens to things like guards?
04:24:52 <mm_freak> Ghoul_: some functions disappear, most notably 'filter'
04:24:55 <mm_freak> it becomes concatMap
04:25:09 <mm_freak> :t concatMap
04:25:10 <lambdabot> (a -> [b]) -> [a] -> [b]
04:25:22 <mm_freak> see how this function is readily compatible with my Alternative-Eq
04:26:47 <thr33strikes> this is called a type? compareWithHundred :: (Num a, Ord a) => a -> Ordering
04:27:00 <paolino> a signature
04:27:18 <paolino> name :: type
04:27:25 <mm_freak> Ghoul_: guard becomes:  require :: (Foldable f, MonadPlus m) => f a -> m a
04:27:41 <thr33strikes> the signature defines the function?
04:27:44 <Ghoul_> m-m-monads
04:27:52 <donri> so "and" becomes sequence with Maybe? what is "or"?
04:27:53 <Ghoul_> so now our guards run over Identity...?
04:28:14 <paolino> thr33strikes, it sign the function interface
04:28:19 <mm_freak> donri: "and" is (<*>), "or" is (<|>)
04:28:34 <donri> ah so asum
04:28:58 <paolino> thr33strikes, telling what must go in and what will come out
04:29:10 <Ghoul_> You'd need a smarter compiler to get speed out of this.
04:29:10 <donri> mm_freak: (note i said and/or, not &&
04:29:16 <donri> mm_freak: (note i said and/or, not &&/||)
04:29:22 <mm_freak> oh
04:29:25 <thr33strikes> telling the function interface what must go in and come out?
04:30:00 <Zenol> mm_freak: and what become /= ?
04:30:11 <paolino> compareWithHundred is willing to accept a value of type a
04:30:16 <donri> Zenol: _Nothing ;)
04:30:18 <mm_freak> let me just write a simple example
04:30:28 <mm_freak> that should answer all questions =)
04:30:32 <paolino> and compute a value of type Ordering
04:30:59 <paolino> given a *implements* Num and Ord class
04:31:07 <Zenol> mm_freak: since now we can hide prelud, did you think of rewriting all the boolean stuff with such functions? (So that it can be tested and see if it's really cool, or not so) ?
04:32:18 <paolino> thr33strikes, the function is defined somewhere else
04:32:51 <Zenol> donri: I don't know what means _Nothing :s
04:33:19 <paolino> using compareWithHundred = ....
04:33:24 <donri> :t _Nothing
04:33:37 <donri> :t _Nothing
04:33:42 <donri> silly bot
04:33:51 <paolino> that's nothing
04:34:13 <donri> Zenol: it's a prism that traverses unit on Nothing
04:34:27 <thr33strikes> compareWithHundred = compare 100 this would be the definition of the function then?
04:34:35 <paolino> yes
04:34:38 <Zenol> donri: prism and traverses are word that I can't understand now x)
04:34:52 <donri> Zenol: lens :)
04:35:19 <thr33strikes> do you always have to provide a signature to use a function?
04:35:23 <paolino> :t compare
04:35:25 <lambdabot> Ord a => a -> a -> Ordering
04:35:29 <Ghoul_> paolino: going to want to mention why the arguments are missing maybe
04:35:34 <merijn> thr33strikes: You almost never have to provide a signature to use a function
04:35:43 <merijn> thr33strikes: But your fellow coders may lynch you if you don't
04:36:08 <paolino> thr33strikes, it's very good to do it
04:36:17 <thr33strikes> merijn why do you say that
04:36:25 <paolino> and required in some cases
04:36:36 <merijn> thr33strikes: Because I have no clue what you're doing if there's no types to tell me :)
04:36:45 <thr33strikes> ic
04:36:54 <donri> thr33strikes: you rarely need to provide type signatures, but it's considered good practice to do so for top-level definitions
04:37:05 <Ghoul_> mm_freak: would your plan involve adding a type other than Maybe
04:37:07 <hpaste> tm pasted “No title” at http://lpaste.net/2813309286615089152
04:37:14 <Ghoul_> or would all the bools essentially become Maybe
04:37:19 <thr33strikes> what
04:37:21 <thr33strikes> sorry
04:37:30 <Zenol> donri: could you write a short example with _Nothing?
04:37:36 <donri> thr33strikes: it can function as (checked!) documentation, it can tell you when your expectations are wrong, it can prevent inferring a more general type than you wanted
04:37:40 <timblechmann> another probably very stupid newbie error: http://lpaste.net/2813309286615089152
04:37:43 <thr33strikes> what is considered top level and what's the alternative bottom lvl
04:37:47 <merijn> thr33strikes: For example, yesterday we had someone with a question about some code not working and when I looked at his paste with no types, I would have to manually figure out what types everything was.
04:38:06 <mm_freak> Ghoul_: bools would become Alternatives
04:38:08 <timblechmann> trying to apply a function on a list of tuples
04:38:13 <mm_freak> i'm still writing the example code
04:38:19 <merijn> thr33strikes: top level means definitions at the file level, rather than local definitions in let or where clauses
04:38:21 <Ghoul_> ok
04:38:21 <mm_freak> figuring out 'not' right now =)
04:38:58 <thr33strikes> got it
04:39:11 <merijn> thr33strikes: For example https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L110
04:39:17 <donri> :t Nothing ^! _Nothing . act (const (putStrLn "got Nothing"))
04:39:18 <lambdabot> IO ()
04:39:24 <paolino> timblechmann, you need mapM_ instead of map, but I never saw the error
04:39:26 <donri> but i wasn't too serious about _Nothing
04:39:30 <merijn> thr33strikes: tryReadPty is top level, the ptyClosed and can'tHappen things are *not* top level
04:39:32 <Zenol> :t mapM
04:39:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:39:44 <Zenol> :t print
04:39:45 <lambdabot> Show a => a -> IO ()
04:39:56 <Zenol> :t mapM print
04:39:57 <lambdabot> Show a => [a] -> IO [()]
04:40:07 <merijn> Zenol: You probably want mapM_
04:40:13 <timblechmann> paolino:  ah, thanks ...
04:40:22 <merijn> :t mapM_
04:40:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:40:25 <Zenol> merijn: merijn It's for timblechmann  :)
04:40:41 <merijn> mapM_ throws away the result list, saving memory
04:40:50 <Ghoul_> mm_freak: I'm gonna pop out for a bit. If you finish that example can you query it to me or something?
04:40:57 <mm_freak> not :: (Alternative g, Foldable f) => f a -> g ()
04:40:58 <mm_freak> not = F.foldr (\_ _ -> empty) (pure ())
04:41:02 <mm_freak> that's my current version
04:41:04 <mm_freak> but it sucks
04:41:13 <ski> s/throws away/refrains from constructing/
04:41:13 <thr33strikes> thanks I see it now
04:41:27 <Zenol> merijn: oh, ok, I didn't know it was more effecient (though that if you don't use the IO [()] it was skiped)
04:41:40 <mm_freak> Ghoul_: sure
04:41:45 <Ghoul_> thanks
04:41:48 <Ghoul_> can't wait. brb
04:42:06 <merijn> Zenol: If you never use the "IO [()]" it is skipped, but if you do run it, the list gets made
04:42:16 <timblechmann> mm_freak: Zenol, merijn, paolino: thanks a lot for the help, btw ... haskell is quite different to the other languages that i know, so the first steps are a bit  hard
04:42:37 <mm_freak> timblechmann: be brave, it pays off =)
04:42:45 <merijn> timblechmann: Don't worry, everyone here had the same struggle at first :)
04:42:56 <mm_freak> but there is a very important downside to haskell
04:43:03 <mm_freak> it ruins you for most other languages
04:43:11 <merijn> timblechmann: It took me 4 different attempts at starting to learn haskell before it stuck for good :p
04:43:22 <thr33strikes> when you're building your own functions it's always best to add a signature and when it's something out of the library like tail there is no need?
04:43:24 <paolino> same here
04:43:27 <S_J> So if you want to write an application protocol on top of TCP there are certain problems that alywas need to be solved. 1. timeouts/keep-alive. 2. determine what a message is, using for example a delimiter or sending the size of the msg in the first byte.     Is there some haskell module that solves this?
04:44:03 <mm_freak> where was that strange girl metaphor for haskell again?
04:44:23 <donri> mm_freak: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
04:44:25 <paolino> tail is already defined with its signature
04:44:36 <paolino> @src tail
04:44:36 <lambdabot> tail (_:xs) = xs
04:44:36 <lambdabot> tail []     = undefined
04:44:42 <timblechmann> mm_freak, merijn: well every new language changes the way of thinking ... which is good ...
04:44:42 <paolino> :t tail
04:44:42 <mm_freak> yeah =)
04:44:43 <lambdabot> [a] -> [a]
04:45:04 <mm_freak> donri: yeah, that's the one =)
04:45:07 <donri> thr33strikes: we don't normally put signatures inside "expressions" or on "local definitions"
04:45:16 <merijn> thr33strikes: The type inference can figure out 90% of all the types, but annotating your own functions with types is considered good practice for 2 reasons: 1) to check the code you wrote has the right type (i.e. stops you from writing code that compiles but isn't what you intended) and 2) documentation for other programmers
04:45:28 <hari_> What exactly is this "encodeFloat" function for?
04:45:38 <hari_> from Prelude
04:45:42 <hpc> also, writing your own type signatures makes the errors nicer sometimes
04:45:43 <merijn> :t encodeFloat
04:45:44 <lambdabot> RealFloat a => Integer -> Int -> a
04:45:59 <merijn> > encodeFloat 10 20
04:46:00 <lambdabot>   1.048576e7
04:46:08 <merijn> heh
04:46:14 <merijn> Ok, no clue :p
04:46:16 <hari_> > encodeFloat 2 2
04:46:18 <lambdabot>   8.0
04:46:22 <hari_> > encodeFloat 2 1
04:46:23 <lambdabot>   4.0
04:46:50 <hpc> > encodeFloat 1 2
04:46:51 <lambdabot>   4.0
04:47:00 <hari_> There was no documentation for that function.
04:47:06 <merijn> hari_: Yes there is
04:47:09 <paolino> thr33strikes, and you can write the signature of an obvious function and let it undefined till later and work on another part using it
04:47:12 <merijn> hari_: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:encodeFloat
04:47:43 <kuribas> And infered types can be more general, but less efficient.
04:47:44 <Zenol> donri:  mm_freak: Haha, I'd better don't show that to my girl :)
04:48:06 <hpc> > encodeFloat 1 1
04:48:07 <lambdabot>   2.0
04:48:58 <hpc> RealFloat is a pretty hardcore class
04:49:31 <Zenol> 2^a eb ?
04:49:41 <Zenol> > ecodeFloat 0 1
04:49:42 <lambdabot>   Not in scope: `ecodeFloat'
04:49:42 <lambdabot>  Perhaps you meant one of these:
04:49:42 <lambdabot>    `decodeFloat...
04:49:43 <mm_freak> Zenol: that Alternative-Eq just reminded me of it =)
04:49:44 <Zenol> > encodeFloat 0 1
04:49:46 <lambdabot>   0.0
04:49:51 <Zenol> > encodeFloat 1 0
04:49:52 <lambdabot>   1.0
04:49:53 <hari_> merijn, thanks. Seems a bit complicated.
04:49:56 <Zenol> > encodeFloat 42 0
04:49:57 <lambdabot>   42.0
04:50:01 <Zenol> > encodeFloat 42 1
04:50:03 <lambdabot>   84.0
04:50:10 <Zenol> > encodeFloat 42 -1
04:50:11 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
04:50:11 <lambdabot>    arising from a use ...
04:50:21 <S_J> So if you want to write an application protocol on top of TCP there are certain problems that alywas need to be solved. 1. timeouts/keep-alive. 2. determine what a message is, using for example a delimiter or sending the size of the msg in the first byte.     Is there some haskell module that solves this?
04:50:23 <Zenol> err. I'd better stop flooding here.
04:50:35 <S_J> ^^ i guess that is that what pythons twisted does?
04:52:11 <hpc> typically the way you separate a stream into messages is on a newline
04:52:36 <hpc> (or '\0' if you are in a binary format)
04:53:06 <hpc> the rest i am not really sure if there's a module for
04:53:34 <mm_freak> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044109.html
04:53:35 <mm_freak> lol
05:01:25 <hari_> > significand 12
05:01:27 <lambdabot>   0.75
05:01:39 <S_J> @type significand
05:01:40 <lambdabot> RealFloat a => a -> a
05:01:46 <S_J> > significand 1
05:01:47 <lambdabot>   0.5
05:01:49 <S_J> > significand 2
05:01:51 <lambdabot>   0.5
05:01:55 <S_J> ?
05:01:59 <S_J> what does thta do?
05:02:04 <S_J> @src significand
05:02:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:03:09 <hari_> S_J, I am not sure. Trying to figure it out myself
05:04:33 <S_J> > map significand [-5,5]
05:04:34 <lambdabot>   [-0.625,0.625]
05:04:36 <S_J> > map significand [-5..5]
05:04:38 <lambdabot>   [-0.625,-0.5,-0.75,-0.5,-0.5,0.0,0.5,0.5,0.75,0.5,0.625]
05:04:57 <S_J> > map significand [0,10,20,30]
05:04:59 <lambdabot>   [0.0,0.625,0.625,0.9375]
05:05:09 <S_J> > map significand [0,10,20,30,40,50,60]
05:05:10 <lambdabot>   [0.0,0.625,0.625,0.9375,0.625,0.78125,0.9375]
05:05:26 <hari_> The documentation says "The first component of decodeFloat, scaled to lie in the open interval (-1,1), either 0.0 or of absolute value >= 1/b, where b is the floating-point radix. The behaviour is unspecified on infinite or NaN values. "
05:07:38 <hari_> I was checking out the Prelude just wondering what those functions are doing in Prelude.
05:07:40 <hiptobecubic> S_J, are you familiar with floating point representation?
05:07:48 <hiptobecubic> in memory i mean
05:09:40 <hiptobecubic> S_J, hari_, http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
05:10:26 <hari_> hiptobecubic, thanks for the link.
05:10:38 <hiptobecubic> hari_, no problem. It's a good read, if a little dense
05:12:12 <hiptobecubic> S_J, hari_, a little less terse maybe: http://floating-point-gui.de/
05:12:51 <Ghoul_> mm_freak: I think I get your thing a little better now
05:13:14 <Ghoul_> since if a == b, then you can just turn that into Just a, since a == b anyway, and the same for all the other alternatives
05:13:24 <Ghoul_> It didn't click before
05:13:29 <hari_> hiptobecubic, yes, FP arithmetic has always been a kind of black box to me. (and I guess to a lot of others as well)
05:13:33 <Ghoul_> I was worried about how to combine the things and just confused myself
05:13:34 <mm_freak> Ghoul_: not working on it right now, but i still have to figure out a sensible 'not'
05:14:00 <hiptobecubic> hari_, the second like i gave is much more clear i think
05:14:07 <hiptobecubic> especially under "Number formats"
05:14:40 <hari_> hiptobecubic, yes, reading that one now.
05:15:34 <S_J> I read in some version of Network.Socket that send and recv does not work as intended, true?
05:15:39 <S_J> cant find it again
05:16:46 <Ghoul_> mm_freak: why does that `not` suck?
05:16:54 <Ghoul_> because it uses the unit?
05:17:30 <mm_freak> Ghoul_: consider (==) :: (Alternative f) => a -> a -> f a
05:17:50 <mm_freak> the resulting value may be in some sense a witness that the two values are equal
05:18:28 <mm_freak> now you can't have straightforward f a -> f a for 'not', because that would make the witness meaningless again, bringing us back to Bool
05:18:39 <Ghoul_> `not` doesn't really make sense then
05:18:44 <Ghoul_> probably need something more sane
05:18:50 <mm_freak> yeah
05:18:57 <aristid> mm_freak: go look at the agda standard library.
05:19:13 <mm_freak> aristid: sure, i'd just use propositional equality or something like that in agda
05:19:13 <aristid> mm_freak: i think the type you want is Dec
05:19:19 <mm_freak> but haskell lacks the type system for that
05:19:34 <aristid> but you don't want to give up just yet?
05:19:58 <mm_freak> no…  i'll think about it this evening
05:21:38 <S_J> Sockets: one send always sends everything right? but a single receive can receive everything from a byte to the whole emssage...?
05:22:39 <mm_freak> S_J: at least with the high level interface, yes
05:22:54 <mm_freak> that is when you have Handle, not Socket
05:23:18 * ski . o O ( `f a -> f ()' )
05:23:36 <mm_freak> S_J: indeed, for Socket that's not guaranteed
05:23:52 <mm_freak> ski: that's what i have right now
05:24:04 <mm_freak> except that i have f a -> g ()
05:24:17 <ski> aye
05:24:25 <S_J> talkign Socket. send=everythung, recv=1byte_to_everything. correct? and for high level interface you can send and receive in one call?
05:24:37 <ski> negation-as-failure isn't so nice :/
05:24:46 <S_J> Network.Socket is lacking in comments. it is pretty bad
05:25:07 <mm_freak> S_J: no
05:25:20 <mm_freak> S_J: it's actually documented in Network.Socket
05:25:29 <mm_freak> you have to make sure that you sent everything
05:25:48 <mm_freak> 'send' returns the number of bytes sent, and as such corresponds to the C function 'send'
05:25:52 <Ghoul_> kazyness + sockets are hellish
05:25:55 <Ghoul_> *lazy
05:27:09 <S_J> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/Network-Socket.html
05:27:17 <S_J> do i have the wrong docs?
05:27:53 <FreeFull> S_J: You have to look at the source code to see the comments
05:28:00 <mm_freak> no, you don't
05:28:03 <Ghoul_> S_J: http://hackage.haskell.org/package/network-2.4.1.2
05:28:12 <Ghoul_> you should consider network-simple
05:28:21 <Ghoul_> it's a higher high level interface
05:28:22 <mm_freak> or simply Network instead of Network.Socket
05:28:32 <S_J> yeah have it now. how can I see local version fo my modules?
05:28:39 <S_J> liek versionof Network.Socket
05:28:48 <mm_freak> S_J: cabal info network
05:28:54 <S_J> I want the low-level
05:29:30 <Ghoul_> how come? performance?
05:29:46 <mm_freak> S_J: you don't usually use the low level interface in haskell…  if you don't want to use the Handle-based interface, there are many stream processing abstractions that don't require you to get headaches
05:29:56 <mm_freak> like pipes-network
05:30:02 <Ghoul_> +1 for pipes-network
05:30:12 <Ghoul_> laziness over the low level interface drives you batty
05:30:37 <S_J> so to send properly, id have to get the siz ewof my message. then send one byte at a time until all is sent? i mean at leats id have to be able to index it somehow
05:30:55 <Ghoul_> You shouldn't have to
05:31:12 <Ghoul_> You can send the whole thing at once
05:31:33 <Ghoul_> although working with Ptr's are a little unsafe
05:31:53 <Ghoul_> try Network.Socket.ByteString for things you want to work out the box
05:32:12 <FreeFull> S_J: Nah, you could try to send the whole message, see how much was sent, drop that much of the message and repeat until the message is empty
05:32:33 <FreeFull> Or just use some higher level library
05:32:39 <Ghoul_> and once again, network-simple removes the need to do hundreds of lines of boilerplate to get a connection open. It doesn't abstract send or recv though, only the connection stuff, so it's still equally performant
05:32:45 <S_J> yes but working on lists seems poor, inefficient
05:32:51 <mm_freak> S_J: it is
05:32:56 <mm_freak> again, don't use Network.Socket
05:35:10 <mm_freak> using String for networking is not only inefficient…  it's wrong
05:37:57 <FreeFull> mm_freak: I agree
05:38:02 <Ghoul_> hGetBuf/hPutBuf for speed
05:38:18 <FreeFull> Bytestring is what should be used on the lower level
05:38:20 <S_J> well the thing is i wanted to use the low level stuff to learn more about sockets, but maybe that is not so meaningful
05:38:24 <Ghoul_> or sendBuf/recvBuf
05:39:19 <S_J> what i eventually want to do is write a sql database and you would connect to it via sockets. So Im figuring out the socket stuff now.
05:39:29 <mm_freak> S_J: it's really just a thin layer around the awkward C API
05:39:40 <mm_freak> Network.Socket that is
05:39:57 <mm_freak> there is almost no value in knowing these details
05:40:21 <mm_freak> S_J: for serious applications in haskell you would use one of the high performance streaming abstractions
05:40:21 <S_J> so what would you recommend for the above, a protocol for communicating with a sql db, pipes?
05:40:27 <mm_freak> pipes, conduit, enumerator, etc.
05:40:34 <mm_freak> my personal recommendation is pipes
05:40:49 <Ghoul_> pipes is the fastest and lightest
05:41:23 <Ghoul_> theres more stuff on hackage for conduit though, pipes is newer
05:44:10 <S_J> what are the pros cons of rach? why do you recommend pipes?
05:44:59 * hackagebot crypto-random 0.0.7 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.7 (VincentHanquez)
05:45:40 <Ghoul_> pipes is fast and maintained really well by Tekmo (hes writing a new version right now). It's in greater flux though and things change faster
05:46:18 <Ghoul_> conduit isn't *dead*, but it doesn't change that much. I think the one guy is working on yesod right now. Theres tons of stuff on hackage for conduit though, so you can basically do anything by pulling in whateverhere-conduit
05:46:19 <S_J> but oleg is agenius!
05:47:39 <mm_freak> S_J: if you're referring to iteratees, they are almost no longer used
05:47:49 <mm_freak> pipes is both fast and theoretically sound
05:48:10 <mm_freak> conduit does not provide the same soundness, but it's also fast and allows resuming
05:48:12 <donri> and then there's machines ;)
05:51:55 <ParaSa1lin> i think pipes doesnt have any ready system for bytestrings and attoparsec
05:52:19 <Ghoul_> ParaSa1lin: theres pipes-bytestring, pipes-network and pipes-attoparsec/pipes-binary
05:52:41 <ParaSa1lin> in 4.0 rc?
05:52:49 <Ghoul_> *right now* for 3
05:52:52 <S_J> gabriel gonzales == tecmo?
05:52:57 <Ghoul_> but also in 4 because k0001 updated them a few days ago
05:53:02 <Ghoul_> yes
05:53:50 <ParaSa1lin> i checked yesterday, the pipes-extra package is built against prehistoric version of pipes, no?
05:54:13 <Ghoul_> uh, idk. I've never had to use it.
05:54:47 <ParaSa1lin> right
05:55:44 <Ghoul_> when I use pipes I just pull in pipes and pipes-whatever
05:55:49 <Ghoul_> where whatever is usually network, binary or both.
05:56:08 <Ghoul_> it all clicks together and the packages export the necessary glue automatically
05:57:07 <mm_freak> ParaSa1lin: see pipes-parse
05:57:26 <ParaSa1lin> mm_freak, right i saw that yesterday
05:57:54 <ParaSa1lin> but nothing for bytestring
05:57:57 <exicer> So, on OSX where are the default places haskell is installed to? I need to completely remove and start again...
05:58:09 <ParaSa1lin> until i guess 4.0 gets released
05:59:33 <mm_freak> ParaSa1lin: it's not based on any particular stream type
05:59:45 <ParaSa1lin> mm_freak, i realize that
05:59:47 <mm_freak> you can use it with ByteString, Text, String, whatever you need
06:00:10 <ParaSa1lin> mm_freak, there is nothing right now that will read a file into a Producer of bytestrings
06:01:00 <ParaSa1lin> so rather than dick around outside cabal, yesterday i just ended up going with io-streams
06:01:59 <merijn> exicer: There is an uninstall script if you installed Platform
06:02:05 <merijn> exicer: Lemme check the location
06:03:00 <merijn> exicer: /Library/Frameworks/GHC.framework/Versions/Current/Tools/ has a shell script called "Uninstaller", that should properly purge things
06:03:13 <exicer> Cool, thanks
06:06:46 <mm_freak> ParaSa1lin: i actually started a pipes-bytestring, then discovered that tekmo is writing one himself, and right now both seem stalled =)
06:07:04 <mm_freak> i'll wait for pipes 4 before i give it another shot
06:07:23 <mm_freak> because all that upstream nonsense will become invisible
06:07:29 <merijn> mm_freak: No, pipes-4 had a release candidate this week
06:07:35 <merijn> mm_freak: The release should be any day now
06:07:51 <merijn> Unless someone finds critical bug it should be done atm
06:08:23 <merijn> The pipes-4 API so far seems significantly nicer and elegant than the previous one
06:08:52 <merijn> So unless you have an odd definition of stalled... ;)
06:09:41 <merijn> mm_freak: Main reason for the long wait is that they're attempting to have the entire pipes ecosystem compatible and up to date before release, i.e. stuff like pipes-safe, pipes-parse, etc.
06:10:04 <mm_freak> yeah, i saw the post
06:10:18 <mm_freak> and i'm talking about pipes-bytestring
06:10:24 <mm_freak> not pipes ;)
06:11:05 <jon_r> hi, is it possible to use regex's in guard conditions?
06:12:54 <merijn> jon_r: You can use arbitrary functions in guards, so yes
06:20:42 <S_J> when is the release for the new pipes scheduled?
06:20:58 <donri> jon_r: you can even use regex in patterns with rex!
06:22:42 <mroman> How can I ensure I/O order?
06:22:54 <mroman> specifically: putStr "foo: " + getLine
06:23:08 <donri> mroman: the monad enforces order
06:23:13 <mroman> well it should
06:23:15 <mroman> stil
06:23:21 <mroman> the getLine comes before foo
06:23:36 <mroman> maybe flush
06:23:46 <donri> mroman: your example doesn't type check
06:23:46 <merijn> mroman: In the IO monad any side effects left of >>= are guaranteed to happen before anything on the right
06:24:00 <mroman> done
06:24:02 <mroman> hFlush stdout
06:24:18 <merijn> mroman: I was about to ask whether the issue was putStr not printing :)
06:24:26 <donri> yes, stdout is normally line buffered
06:24:27 <mroman> Yeah
06:24:33 <merijn> mroman: Yeah, you need to either use hFlush or hSetBuffering
06:24:36 <mroman> I just figured out that was a stupid question :)
06:24:48 <jon_r> how can I make a haskell regex match an entire string ignoring newlines
06:26:48 <onur> http://fotogaleri.ntvmsnbc.com/haydarpasaya-bogazici-stadi.html
06:26:58 <onur> opps
06:27:06 <onur> damn putty sorry
06:28:31 <sordina> Why are fingertrees based on monoids rather than semigroups?
06:30:14 <merijn> sordina: Well, why not?
06:31:52 <sordina> merijn: Is there somewhere where mempty is required?
06:32:07 <elliott> empty tree?
06:32:45 <haasn> @ask edwardk In tables, how does traversal order work? I want to traverse things according to their insertion order, but ideally also traverse them according to their key order (with another key)
06:32:45 <lambdabot> Consider it noted.
06:33:27 <sordina> elliott: mm true, but it seems like a large impact in order to accomodate an empty tree.
06:33:47 <donri> haasn: possibly you need to use autoincrement to get "insertion order"
06:33:57 <Taneb> haasn, I believe it goes by order of primary key
06:34:09 <sordina> I'm just exploring the concept for the first time, so I might be way off base :)
06:34:33 <haasn> yes, I could live with having an (unused) primary key that dictates insertion order and then just traverse things according to their secondary keys and stuff depending on which elements I want to query
06:35:04 * hackagebot libvorbis 0.1.0.0 - Haskell binding for libvorbis, for decoding Ogg Vorbis audio files  http://hackage.haskell.org/package/libvorbis-0.1.0.0 (StephenBlackheath)
06:35:09 <donri> sordina: one obvious reason is monoid is in base, semigroups aren't
06:35:32 <sordina> donri: that's actually a really good point
06:35:47 <elliott> sordina: monoids are nicer than semigroups
06:35:51 <elliott> they have more structure.
06:36:00 <donri> of course, semigroup *should* be in base...
06:36:01 <elliott> so I don't think you need much of a reason to want to use them :)
06:36:07 <donri> the Monoid Maybe instance is just silly
06:36:45 <FreeFull> You can make any semigroup a into a Monoid (Maybe a)
06:37:03 <donri> FreeFull: but what base does is make any monoid into a monoid :P
06:37:15 <FreeFull> donri: Yeah, because there aren't any semigroups =P
06:37:37 <sordina> elliott: isn't less structure nicer in general?
06:37:43 <donri> FreeFull: which was my point exactly...
06:38:26 <elliott> sordina: nah. magmas are boring.
06:38:28 <elliott> laws are nice.
06:38:33 <donri> sordina: define "nicer". more things can be semigroups, but you can do more things with a monoid.
06:38:38 <FreeFull> donri: I didn't even read what you wrote about the monoid maybe instance until now
06:38:39 <elliott> of course, more things can be semigroups; if you have no real need for mempty then it's nice to be able to use them
06:39:06 <elliott> but here mempty is the natural equivalent of a natural base case (empty tree)
06:39:10 <elliott> it fits well.
06:39:18 <elliott> consider tracking the size of the tree or whatever. natural base case.
06:39:21 <sordina> elliott, donri: yes I mean nicer as in more permissive.
06:39:37 <elliott> and you can always lift a semigroup to a monoid
06:39:45 <elliott> giving you a special value representing that base case of the empty tree.
06:40:02 <FreeFull> Some trees can't be empty
06:40:55 <jon_r> dumb q, but can i call a function without importing a module?
06:41:02 <jon_r> e.g. Data.String.endswith
06:41:34 <Taneb> The extra power granted by group over monoid isn't very useful in Haskell, as far as I can see
06:41:43 <donri> jon_r: you can with a flag that is on by default in ghci but not ghc/cabal
06:41:51 <sordina> But if you have a seigroup label that's lifted into a monoid then your tree becomes (FT (Maybe SemiGroup tag) value), which has a conceptual overhead, as opposed to (Maybe FT (Semigroup tag)) if you needed an 'empty' tree.
06:42:00 <donri> jon_r: it's probably a bad idea to use outside ghci
06:42:06 <sordina> (excuse the loosey goosey typeclass constructors)
06:42:19 <jon_r> so I have a string, I want to run ends with on it, so I have to import Data.String into my modules namespace?
06:42:44 <FreeFull> jon_r: You could only import the function you want
06:42:51 <FreeFull> But you do have to import
06:43:05 <FreeFull> For example,   import Data.String (endswith)
06:43:55 <FreeFull> The one caveat is that this will also import all typeclass instances from the module
06:44:24 <donri> there is no such function in Data.String though
06:44:32 <sordina> I guess I'm advocating lifting the tree instead of the tag.
06:45:13 <FreeFull> donri: Yeah, just using jon_r's example
06:45:23 <elliott> sordina: that doesn't work
06:45:25 <elliott> because subtrees can be empty too.
06:45:26 <donri> who i was talking to :)
06:45:31 <elliott> or, well.
06:45:33 <elliott> eh.
06:45:53 <jon_r> does anyone know what the equivalent of /\A\s+\Z/ is in haskell? I can't make \A \Z work
06:46:07 <FreeFull> There is a difference between having an empty subtree and having no subtree
06:46:28 <FreeFull> jon_r: You probably need \\ rather than \
06:46:36 <Iceland_jack> jon_r: Do you mean in strings? You need "\\A" for \A
06:46:39 <jon_r> well yes
06:46:49 <jon_r> but I still can't make it work
06:46:49 <sordina> elliott: Ah. That must be what I'm missing. What is the purpose of an empty subtree?
06:47:04 <jon_r> e.g. message =~ "\\A\\s+$"
06:47:08 <FreeFull> jon_r: Which regex package are you using?
06:47:14 <elliott> I think I've gotten myself confused.
06:47:19 <jon_r> Text.Regex.Posix
06:47:21 <elliott> but anyway monoids are nice. identity laws are good to have. :P
06:47:36 <elliott> you could try writing semigroup finger trees and compare yourself
06:47:48 <jon_r> Text.Regex.Posix
06:47:56 <elliott> sordina: http://apfelmus.nfshost.com/articles/monoid-fingertree.html
06:48:08 <sordina> haha I just did in a little huffman encoder that's why I asked.
06:48:27 <elliott> sordina: "search" there uses mempty fwiw, you can see how it fits naturally
06:48:34 <elliott> also what I said about the empty trees was nonsense.
06:48:38 <elliott> but that's a really good article.
06:50:12 <sordina> Cool :) apfelmus always has such great posts.
06:51:05 <sordina> https://gist.github.com/sordina/6475250 is the toy example I was putting together.
06:51:45 <FreeFull> elliott: I think most if not all trees won't be monoids but will be semigroups, and all forests will be monoids
06:53:12 <FreeFull> elliott: Actually, that's not true
06:53:55 <FreeFull> Trees are semigroups if their elements are part of a semigroup
06:56:10 <FreeFull> The monoid instance for Forests I'm thinking on is probably the same that you would declare for ZipList
06:58:14 <sordina> FreeFull: Interesting
06:59:54 <FreeFull> @let instance Monoid a => Monoid (ZipList a) where mempty = ZipList []; mappend (ZipList []) (ZipList []) = ZipList []; mappend (ZipList xs) (ZipList []) = ZipList xs; mappend (ZipList []) (ZipList ys) = ZipList ys; mappend (ZipList (x:xs)) (ZipList (y:ys)) = ZipList (mappend x y : mappend (ZipList xs) (ZipList ys))
06:59:55 <lambdabot>  .L.hs:155:45:
06:59:55 <lambdabot>      Couldn't match expected type `[a]' with actual type `ZipL...
07:03:31 <FreeFull> @und
07:03:32 <lambdabot> Maybe you meant: undefine undo
07:03:33 <FreeFull> @undef
07:03:33 <lambdabot> Undefined.
07:03:42 <FreeFull> @let instance Monoid a => Monoid (ZipList a) where mempty = ZipList []; mappend (ZipList []) (ZipList []) = ZipList []; mappend (ZipList xs) (ZipList []) = ZipList xs; mappend (ZipList []) (ZipList ys) = ZipList ys; mappend (ZipList (x:xs)) (ZipList (y:ys)) = ZipList (mappend x y : getZipList (mappend (ZipList xs) (ZipList ys)))
07:03:43 <lambdabot>  Defined.
07:04:16 <FreeFull> map getSum $ getZipList $ ZipList [Sum 1,Sum 2,Sum 3] <> ZipList [Sum 5] <> mempty
07:04:24 <FreeFull> > map getSum $ getZipList $ ZipList [Sum 1,Sum 2,Sum 3] <> ZipList [Sum 5] <> mempty
07:04:28 <lambdabot>   [6,2,3]
07:04:37 <FreeFull> I do think it satisfies the monoid laws
07:05:13 <FreeFull> The Monoid a restraint can of course be changed to Semigroup a
07:07:11 <S_J> so anyone good with pipes. i have been shopping and im back to write a simple client/server with pipes to start with. do I need to give credentials? while i might want that eventually I just want to run a connection for now
07:09:19 <FreeFull> @undef
07:09:19 <lambdabot> Undefined.
07:10:09 <paolino> :t view
07:10:10 <lambdabot> MonadReader s m => Getting a s a -> m a
07:10:37 <paolino> this seems monadic , but I can use it in pure code
07:11:36 <paolino> :t \l -> (+1) . view l
07:11:37 <lambdabot> Num a1 => Getting a1 a a1 -> a -> a1
07:12:28 <merijn> Anyone know if it's possible to make pandoc's rST mode support \begin{code} style literate haskell?
07:12:31 <S_J> http://hackage.haskell.org/packages/archive/pipes-network/0.5.1.0/doc/html/Control-Proxy-TCP.html
07:12:36 <merijn> I really dislike Bird-style
07:12:39 <S_J>  serve (Host "127.0.0.1") "8000" $ (connectionSocket, remoteAddr) -> do
07:12:44 <S_J> whats with the -> ?
07:12:56 <merijn> paolino: It's because "r ->" is a monad :)
07:12:58 <S_J> i get parse error
07:13:08 <hpc> missing a lambda, i think
07:13:17 <S_J> r?
07:13:20 <hpc> what's the type of serve?
07:13:33 <paolino> merijn, where is the runReader ?
07:13:36 <startling> :t liftM (+ 1) view -- paolino
07:13:37 <lambdabot> (Num (m a), MonadReader s m) => Getting a s a -> m a
07:13:52 <merijn> paolino: Presumably hidden in the lens operators
07:14:09 <merijn> :t (.~)
07:14:10 <lambdabot> ASetter s t a b -> b -> s -> t
07:14:32 <merijn> :t view _2
07:14:33 <lambdabot> (MonadReader s m, Field2 s s b b) => m b
07:14:41 <merijn> :t (view _2 .~)
07:14:42 <lambdabot> Field2 (a -> Mutator b) (a -> Mutator b) (s -> Mutator t) (s -> Mutator t) => b -> s -> t
07:14:44 <startling> paolino, there's no runReader. "view" works for any MonadReader x m. x -> anything is a MonadReader x m => m anything
07:14:57 <paolino> but the view returns a monadic value , I'm supposed to run it
07:15:10 <merijn> paolino: You're overthinking
07:15:15 <merijn> paolino: Forget that it is a monad
07:15:22 <startling> :t view traverse
07:15:23 <lambdabot> (Traversable t, Monoid a, MonadReader (t a) m) => m a
07:15:34 <merijn> paolino: functions are monads, you don't worry about how to run those, no?
07:15:48 <swistak35> Hi, is there a way to some dynamic programming, like convert Strings to Modules? I have imported some qualified modules, and I would like to have them in a list, and collectively run some method "foo" from them, and gather the results to another list. Is it possible?
07:16:37 <Chousuke> swistak35: can you not just make a list of the functions you want to apply?
07:16:45 <startling> :t view _1 `asAppliedTo` (1, 2)
07:16:45 <lambdabot> (Num t, Num t1) => (t, t1) -> t
07:16:46 <swistak35> Except keeping all "foo" methods in a list, because I want also to run other "bar" method, so I would have to maintain two different lists (but it's still fine solution which I will use, but it doesn't look nice)
07:16:50 <swistak35> Chousuke: ^
07:17:08 <Chousuke> hmm
07:17:44 <swistak35> There would be only two lists, so it isn't that hard, but if there's a way to make it more clear I would like to know : )
07:17:49 <Chousuke> if you need to do that with a whole bunch of methods, you could make a record of functions
07:18:16 <Chousuke> I don't think you can treat a module as a first-class value
07:18:25 <paolino> startling I appreciate but there is a gap from here to there
07:18:26 <Chousuke> and involving Strings in any way sounds evil
07:18:46 <swistak35> Chousuke: okay, thank you : )
07:19:40 <merijn> paolino: By applying it as a function GHC infers you're using the "(->) r" monad of MonadReader
07:19:46 <paolino> startling, for sure the m there is not a datatype
07:20:16 <paolino> so it's a typesynonyminstance ?
07:20:21 <merijn> what?
07:20:27 <paolino> the m
07:20:38 <Chousuke> the m is a type variable?
07:20:44 <merijn> Why do you think typesynonyminstance is remotely relevant?
07:20:56 <merijn> m is just a type variable
07:20:59 <paolino> because I don't unwrap it
07:20:59 <Chousuke> still sounds like overthinking
07:21:12 <merijn> paolino: There's nothing to unwrap
07:21:52 <Ghoul_> @where exercises
07:21:52 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
07:21:54 <paolino> so it's not a Monad instance for a datatype
07:21:54 <merijn> > return 5 $ 3
07:21:56 <lambdabot>   5
07:21:57 <S_J> hpc: http://hackage.haskell.org/packages/archive/pipes-network/0.5.1.0/doc/html/Control-Proxy-TCP.html
07:22:08 <merijn> :t return 5
07:22:09 <lambdabot> (Monad m, Num a) => m a
07:22:21 <merijn> paolino: It's doing the exact same as that
07:22:29 <S_J> serve :: HostPreference	-> ServiceName -> ((Socket, SockAddr) -> IO ())	-> IO ()
07:23:03 <merijn> "return 5 :: Monad m => m Int", if I apply "m Int" to a Char, then logically m must be "(->) Char"
07:23:05 <hpc> S_J: yeah, definitely missing a lambda
07:23:25 <merijn> paolino: Which means "m Int" must be "(->) Char Int" == "Char -> Int"
07:23:29 <merijn> > return 5 $ 'a'
07:23:30 <lambdabot>   5
07:23:34 <hpc> it should be serve "whatever" "whatever" $ (x,y) -> do ...
07:23:50 <hpc> er, dammit
07:23:53 <hpc> it should be serve "whatever" "whatever" $ \(x,y) -> do ...
07:24:19 <merijn> paolino: Typeclass instances are for types, there is no requirement that said type is an ADT
07:25:06 <paolino> ok, then why view is so generalized ?
07:25:33 <haasn> @tell edwardk there's so much boilerplate in Tabular; wouldn't it be possible to auto-derive most of it via TH?
07:25:33 <lambdabot> Consider it noted.
07:25:47 <paolino> :t (^.)
07:25:47 <lambdabot> s -> Getting a s a -> a
07:26:00 <paolino> :t flip (^.)
07:26:00 <lambdabot> Getting c a c -> a -> c
07:26:37 <paolino> :t view :: Getting c a c -> a -> c
07:26:37 <lambdabot> Getting c a c -> a -> c
07:26:55 <supki> paolino: to use it in ReaderT
07:27:07 <paolino> ah
07:27:36 <paolino> I get this for free for every function, Ic
07:28:55 <paolino> it's good that we don't write any pure function of 2 args like that
07:29:17 <paolino> any signature
07:29:26 <Ghoul_> S_J: change $ to $\
07:30:02 <hpc> :t ($\)
07:30:03 <lambdabot>     Not in scope: `$\'
07:30:03 <lambdabot>     Perhaps you meant one of these:
07:30:03 <lambdabot>       `$' (imported from Data.Function), `$!' (imported from Prelude),
07:30:17 <Ghoul_> uh, add a space.
07:30:50 <Ghoul_>  serve (Host "127.0.0.1") "8000" $ \(connectionSocket, remoteAddr) -> do
07:31:02 <paolino> btw thanks, some stuff is difficult to settle in my head
07:31:06 <Ghoul_> also, I recommend you probably change (Host ...) to just HostAny
07:32:00 <paolino> :t fmap 5 6
07:32:01 <lambdabot> (Functor f, Num (a -> b), Num (f a)) => f b
07:32:38 <hpc> Ghoul_: explicitly setting the host is a good sanity check
07:32:51 <hpc> in case you make it publicly visible or something
07:32:53 <merijn> Right, time to improve the world one tiny step at a time...
07:33:27 <hpc> merijn: can you start with how long it takes to download a steam game? ;)
07:33:35 <merijn> hpc: It's pretty fast here
07:33:38 <Ghoul_> hpc: I don't do that because it means I can test it on both an ipv4 and an ipv6 config
07:33:47 <S_J> so im on windows, pipes work there to? I need to do withSocketsDo, how do I do that with the serve function inpipes?
07:33:47 <merijn> hpc: My UK cable might be sucky, but I did get 3MB/s
07:34:04 <hpc> Ghoul_: well yeah, i wouldn't use an IP either, but limiting to "localhost" would be better
07:34:12 <Ghoul_> S_J: just add it to main
07:34:17 <Ghoul_> main = withSocketsDo $ regular stuff..
07:34:20 <merijn> hpc: I was more thinking along the lines of "add support for latex style literate haskell to pandoc's rST engine"
07:34:32 <merijn> hpc: Because Bird-style sucks!
07:34:43 <hpc> but bird is the word!
07:36:20 <merijn> Semi-related, why does hdevtools only produce useful typing info if a package is installed :(
07:36:53 <deech> Hi all, I'm currently working on an FFI binding. Are enum's the only way to get c2hs to translate `#define`'s?
07:39:30 <merijn> deech: So you want to make #define things available as haskell values?
07:40:29 <merijn> deech: Not sure how to do that using c2hs, but GHC's new capi FFI lets you import #define values using the normal "foreign import" stuff
07:40:35 <merijn> deech: See this example: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L224-L235
07:41:03 <merijn> Well... "new" :p
07:41:19 <solirc> Hackage down?
07:41:35 <Taneb> Hehe, I just successfully wrote a program in Haskell with a GUI
07:41:39 <Taneb> I feel like a god among me
07:41:40 <Taneb> n
07:41:59 <solirc> Luckily there is still http://new-new-hackage.haskell.org/
07:42:17 <Taneb> It's just a little thing for converting celcius and fahrenheit
07:42:24 <Taneb> And it crashes if it can't read the text-box
07:42:46 <merijn> What's this error mean? "Could not find module `Paths_pandoc` it is a hidden module in the package `pandoc-1.11.1'"
07:43:17 <Clint> it means you're trying to import a hidden module?
07:43:19 <hpc> merijn: it means there's probably a reason it didn't want you using pandoc-1.11.1
07:43:26 <hpc> any other output?
07:45:18 <deech> merijn: That's awesome. How recent is this change?
07:45:32 <merijn> hpc: Well, I'm trying to get hdevtools to typecheck the uninstalled pandoc stuff
07:45:47 <merijn> deech: Dunno exactly, it's not *that* recent/new, I think
07:46:00 <deech> merijn: And also, is there some reason not to mark those import "pure"?
07:46:24 <merijn> deech: Oh wait, yes it is that new >.<
07:46:25 <paolino> is hdiff.luite.com ever down ?
07:46:29 <merijn> It's in the 7.6 release notes
07:46:43 <deech> merijn: Ah.
07:46:59 <merijn> deech: "unsafe" is marking them pure :)
07:47:14 <deech> merijn: Really?! Crap, I've been wasting my time.
07:47:22 <merijn> deech: unsafe means "import this in an unsafe way" not "import something unsafe"
07:48:21 <supki> merijn: Paths_pandoc is cabal-generated module, the error means they for some reason have included it in .cabal file
07:48:30 <deech> merijn: I thought "pure" did a thing where the call is only made once because you're saying the results' always the same.
07:48:30 <S_J> if i want to run a connection over http, what lib would i use?
07:49:38 <merijn> deech: I think the following things apply "safe" means C can call back into haskell, but has more overhead, "unsafe" is unsafe if you call back into haskell, but less overhead
07:50:08 <merijn> deech: If the type doesn't return IO GHC treats it as pure
07:50:08 <deech> merijn: Thanks.
07:50:30 <merijn> deech: So "unsafe" and "Word8" is basically a constant (or should be)
07:50:50 <merijn> I'm not entirely sure about that, but someone will presumably correct me if I'm not correct :p
07:55:21 <statusfailed> Hackage is down!? everybody panic!
08:02:01 <mkramer> are the hackage doc pages down?
08:02:04 <AnalogFile> yup, Hackage down for me too
08:02:28 <sclv> we're swapping a drive
08:02:34 <sclv> expect 1/2 hour of downtime
08:02:35 <mkramer> <3
08:03:17 <merijn> I should've kept track of that, I just nuked a bunch of packages >.<
08:03:35 <statusfailed> merijn: it was you!!
08:03:52 <statusfailed> oh wait I just read sclv's comment :P
08:06:45 <kuribas> Does hackage build the documentation automatically?
08:06:58 <merijn> kuribas: Yes, if possible
08:07:38 <merijn> kuribas: Haddock requires that the package can be build to produce documentation, so packages that don't build on hackage have no online documentation (see for example the haskell-zeromq package and other things relying on C libraries)
08:07:51 <dfan> I just wrote a little helper function that has to already exist somewhere, but hoogling didn't turn up anything
08:07:55 <dfan> onlyIf :: Bool -> Maybe a -> Maybe a
08:08:00 <dfan> onlyIf b x = if b then x else Nothing
08:08:13 <dfan> Is there a more idiomatic way to write that logic?
08:08:34 <Iceland_jack> lookds like guard
08:08:36 <Iceland_jack> @ty guard
08:08:36 <lambdabot> MonadPlus m => Bool -> m ()
08:09:02 <Iceland_jack> > do guard True; Just "hello!"
08:09:03 <lambdabot>   Just "hello!"
08:09:05 <Iceland_jack> > do guard False; Just "hello!"
08:09:06 <lambdabot>   Nothing
08:09:32 <Iceland_jack> > do guard True; "hello!"
08:09:33 <lambdabot>   "hello!"
08:09:36 <Iceland_jack> > do guard False; "hello!"
08:09:37 <lambdabot>   ""
08:09:39 <applicative> there must be something more compact?
08:09:41 <applicative> hm
08:10:19 <Iceland_jack> I mean it depends on what dfan actually wants to do, maybe they're looking for something like ‘unless’
08:11:02 <dfan> > Hmm, I would prefer to avoid dropping into do's and semicolons, but maybe that is what people do
08:11:02 <Iceland_jack> It's hard to tell without further context
08:11:03 <lambdabot>   <hint>:1:4: parse error on input `,'
08:11:15 <kuribas> merijn: So basicly, when cabal haddock works, it should show up on hackage.
08:11:19 <dfan> and guard True >>= \_ -> Just "foo" is too ugly for words
08:11:35 <elliott> guard true >> Just "foo"
08:11:39 <applicative> [x | x <- mthing , bool] :: MonadPlus m => Bool -> m b -> m b
08:11:46 <Iceland_jack> Nothing wrong with do-notation..
08:11:56 <dfan> elliott: Aha!
08:12:20 <applicative> kuribas: certainly thats the theory; with all the linking to the rest of hackage
08:12:39 <kuribas> Ok, I'll cross my fingers :)
08:12:51 <merijn> kuribas: Yes
08:13:06 <merijn> kuribas: Keep in mind that hoogle doesn't index all of them, though
08:13:09 <dfan> I think I like elliott's solution the best
08:13:16 <elliott> I suggest not writing guard True though :)
08:13:56 <merijn> elliott: That's totes useful!
08:14:29 <kuribas> merijn: If my documentation shows up, that's already good!
08:15:36 <merijn> Speaking of which
08:16:12 <merijn> Is it possible to generate "stand-alone" documentation? i.e. like my local documentation, but linking to hackage rather than locally?
08:16:40 <merijn> That'd let me upload my (not-building) docs somewhere else
08:17:50 <danr> is there some function to look through type synonyms in template haskell?
08:18:21 <danr> oh, found one by Lennart
08:18:53 <applicative> dfan: i think defined
08:19:16 <applicative> let dfan bool = if bool then Just id else Nothing in dfan True <*> Just 1
08:19:25 <applicative> > let dfan bool = if bool then Just id else Nothing in dfan True <*> Just 1
08:19:26 <lambdabot>   Just 1
08:19:39 <applicative> > let dfan bool = if bool then Just id else Nothing in dfan False <*> Just 1
08:19:40 <lambdabot>   Nothing
08:20:45 <applicative> and so on. I think this problem hasn't been solved yet.
08:25:04 <applicative> > let assertZ p = if p then return () else mzero in assertZ True *> Just 1
08:25:05 <lambdabot>   Just 1
08:25:07 <dfan> I am happy with 'guard myTest >>' but I can see how <*> can read nicely to Haskellers
08:25:13 <applicative> > let assertZ p = if p then return () else mzero in assertZ False *> Just 1
08:25:14 <lambdabot>   Nothing
08:25:42 <applicative> oh okay, Control.Errors has a function assertMay that specialized assertZ there
08:26:17 <applicative> Control.Error I mean.  Actually, thats sort of what you mean, no?
08:27:25 <applicative> of course, assertMay bool *>  and guard bool >> are pretty similar ...
08:28:07 <applicative> but the former is just so much swanker ;)
08:30:46 <dfan> Here is a use case: I am checking to see whether an incomplete hand of cards can end up being a flush, given the available remaining cards, but only if the hand so far is all of one suit
08:30:54 <danilo2> Does anybody have seen such behaviour before? : I'm running "cabal update" and getting the error: "Downloading the latest package list from hackage.haskell.org \n cabal: does not exist"
08:30:56 <dfan> The latter is my guard condition
08:31:14 <applicative> hackage is down? danilo2
08:31:33 <applicative> allegedly just for an hour or so
08:31:38 <dfan> guard flushPossible >> (L.find (rankAvail st xs) ranks) >>= (\r -> Just $ groupScore Flush + xr + yr + r)
08:31:38 <dfan>  
08:31:51 <dfan> is what it looks like now, which I'm happy enough with
08:31:54 <applicative> if desperate you can use luite's site, danilo2
08:32:06 <danilo2> applicative: ah you're right. But the error message is not informative :)
08:32:07 <merijn> danilo2: Hackage is down for maintenance
08:32:13 <merijn> applicative: 20-30 mins more like
08:32:42 <merijn> applicative: They're slotting a new disk into the RAID mirror, one of the disks is dying
08:33:02 <danilo2> applicative: Luite has a mirror of hackage somewhere? What is the luite's site?
08:33:25 <merijn> @where mirror
08:33:25 <lambdabot> see hackage-mirror
08:33:26 <applicative> http://hdiff.luite.com/cgit/errors/tree/Control/Error.hs
08:33:30 <merijn> @where hackage-mirror
08:33:31 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
08:33:35 <applicative> oh that's a particular module t
08:34:02 <applicative> put what merijn says in your .cabal/config file, and you can toggle between it and hackage; the solution has downsides but few
08:34:57 <danilo2> applicative: thank you! :) Could you please give me a hint how to tell cabal to use it? I was searching right now for any information but didnt find anything useful :(
08:35:10 <heha> hi all, newbie here
08:35:24 <applicative> open $HOME/.cabal/config on unix
08:35:49 <applicative> danilo2: that is, edit it; I'm not sure where it is on windows.
08:36:03 <applicative> oh wait, with os x - orthodox platform it may be elsewhere too
08:36:08 <applicative> hi heha
08:36:09 <danilo2> applicative: Ok! I've got it :) I do not use windows :)
08:36:15 <geekosaur> os x puts it in the same place and uses it to redirect everything else
08:36:24 <applicative> so you'll see a line just like the one merijn typed
08:36:36 <applicative> comment it, and add merijns
08:36:41 <applicative> wait lambdabot typed it
08:36:46 <applicative> @where hackage-mirror
08:36:47 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
08:37:02 <danilo2> applicative, merijn: I got it :) thank you very much! :)
08:37:04 <applicative> or is the syntax wrong
08:37:17 <applicative> then do cabal update again
08:37:24 <danilo2> ok :)
08:37:34 <heha> i would like to use haskell for COM automation, but the current version (com-1.2.3.1) failed to build...
08:37:35 <geekosaur> it's the right syntax
08:38:02 <applicative> it might be more sensible to be patient in the present case, but the solution is worth knowing, so you can toggle between them on worse days
08:38:35 * ski doesn't know about COM
08:40:11 <applicative> hah, google thinks that the top directory for the com package is in Indonesian
08:40:21 <applicative> http://hdiff.luite.com/cgit/com/tree/
08:40:50 <applicative> maybe google translate could translate haskell into haskell, by inlining the definitions for us
08:41:21 <kier> I think google translate should be able to translate Indonesian into Haskell
08:41:54 <applicative> heha: is the error something horrible and com-ish, or a specific haskell error?
08:42:29 <applicative> heha: it looks like it was uploaded in the last year; i dimly remember someone working with it not too many months back
08:43:00 <heha> anyone using com package? does it works?
08:43:43 <ski> perhaps if you stay, someone later will have an idea
08:43:45 <applicative> it has no dependencies on hackage but thats maybe not to surprising; it would end up in user executables
08:44:10 <applicative> heha: the community is in dire need of windows knowledgeable people, which may or may not alarm you to hear
08:44:50 <heha> applicative, there is quite a lot of warnings and errors...
08:44:54 <applicative> heha: the compiler people know what they are doing with windows the rest of us ...
08:45:14 <applicative> heha: warnings are to be expected; what is the last error before failure
08:45:43 <heha> System\Win32\Com\Automation\TypeLib.hs:2823:1:     Unacceptable argument type in foreign declaration: Ptr ()     When checking declaration:       foreign import stdcall safe "dynamic" prim_System_Win32_Com_Automation_TypeLib_afterTypeChange          :: Ptr ()            -> Ptr ()               -> Int32 -> Ptr (ITypeInfo a) -> Ptr WideString -> IO Int32
08:46:14 <heha> sorry, simply paste here the error
08:46:31 <applicative> right this violates more recent rules, doesn't it?
08:46:52 <heha> i think so, maybe it works in older ghc...
08:47:24 <geekosaur> I think it requires extra imports now, yeh
08:47:33 <joelteon> darn, hackage is down again
08:47:40 <applicative> is that what this error is?  I thought it was about ffi
08:47:49 <applicative> @hackage-mirror
08:47:50 <lambdabot> Unknown command, try @list
08:47:53 <applicative> @where hackage-mirror
08:47:53 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
08:47:56 <joelteon> sweet
08:48:38 <merijn> joelteon: It's offline to get a dying disk replaced, should come back up any moment now
08:48:47 <joelteon> oh, good
08:49:08 <heha> this is the last one
08:49:35 <ParaSa1lin> anyone have a mirror of hackage docs?
08:49:40 <FreeFull> What would be an example of an idiomatic Haskell codebase? Want to show some Haskell to someone who never saw any
08:51:04 <applicative> somehow i cant trust a function like prim_System_Win32_Com_Automation_TypeLib_requestTypeChange
08:51:47 <merijn> ParaSa1lin: You can make cabal install local copies of docs for all your packages
08:51:57 <merijn> FreeFull: xmonad?
08:52:02 <joelteon> have any of you guys used rex? it looks really neat, but operates on String
08:52:04 <merijn> FreeFull: Pandoc?
08:52:14 <applicative> heha: the line in question has a different number in http://hdiff.luite.com/cgit/com/tree/System/Win32/Com/Automation/TypeLib.hs
08:52:15 <ParaSa1lin> merijn, well i know that
08:52:21 <heha> or is there any alternative package for COM automation?
08:52:44 <applicative> FreeFull: Pandoc is actually a good example, or would if not so gigantic now
08:52:57 <FreeFull> merijn: I'm a bit worried that X11 is ugly and the ugliness is infectious
08:52:58 <applicative> or maybe gigantic code base is what you want i guess
08:53:06 <FreeFull> applicative: Well, one file will do
08:53:32 <enthropy>  mapM_ g =<< replicateM n f   ===  replicateM_ n (g =<< f)  -- this is not required, but what can we say about the `a' in `f :: m a' if it does hold?
08:54:11 <FreeFull> Is Hackage down?
08:54:14 <joelteon> yep
08:55:23 <joelteon> Anybody know if there's a module like text-format for ByteStrings?
08:55:27 <ParaSa1lin> that should be a lambdabot feature, responding to "is hackage down"
08:55:43 <enthropy> @faq is close enough?
08:55:43 <lambdabot> The answer is: Yes! Haskell can do that.
08:55:45 <donri> joelteon: i'm not sure that makes sense
08:55:52 <joelteon> ?
08:56:05 <joelteon> why not
08:56:10 <donri> joelteon: bytes don't have such structure
08:56:11 <heha> not sure, but my local version is 1.2.3.1
08:57:01 <applicative> FreeFull: maybe it's dumb but to keep with this idea https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs combined with say https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/Markdown.hs and e.g. https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Writers/Docx.hs
08:57:27 <joelteon> ok
08:58:38 <ski> enthropy : not sure why you expect to be able to say something about `a'
08:59:46 <ParaSa1lin> hm hackage back up, or i have some pages cached
09:00:06 <merijn> No, looks like it's back up
09:01:43 <enthropy> ski: if it's like Int or Integer rather than an IORef
09:02:00 <applicative> heha: what happens if you replace import Foreign.Ptr (Ptr, castPtr)
09:02:05 <applicative> heha: with import Foreign.Ptr (Ptr, castPtr)
09:02:14 <applicative> heha: with import Foreign.Ptr (Ptr(..), castPtr) rather
09:02:18 <applicative> in the offending module
09:02:24 <enthropy> things that can't be changed by some IO
09:03:21 <elliott> IORefs never change
09:03:24 <elliott> they always point to the same thing
09:03:33 <ski> enthropy : i think one sufficient condition is `forall y. liftM2 (,) f (g y) = (flip . liftM2 . flip) (,) f (g y)'
09:03:33 <elliott> consider this, you can also use an Int to identify a file handle which you track in a map in IO
09:03:48 <ParaSa1lin> hm, looks like hxt's parser's arrow instance is just defined in terms of monadic functions
09:03:51 <elliott> you never "change" the Int when you use it to cause effects; same for IORef
09:04:11 <merijn> Is the current lambdabot source on github?
09:04:22 <merijn> Specifically I'm mostly interested in the quote file :p
09:04:24 <gavri> how do I share objects in haskell?
09:04:24 <deech> I'm converting C enums into Haskell datatypes. What's the best way of dealing with 2 enumerations that have the same numerical value?
09:04:41 <ski> (yes, conceptually, `IORef's can be thought of as array/map indices/keys -- the actual state is carried around "inside" `IO')
09:04:42 <gavri> for example, if I have a constructor that takes in no arguments called Empty
09:04:42 <joelteon> > foldr f a [b,c,d]
09:04:43 <lambdabot>   f b (f c (f d a))
09:04:47 <merijn> gavri: What do you mean by 'share'? And what do you mean by 'objects'?
09:04:55 <gavri> and would like to share just one Empty object
09:04:56 <joelteon> > foldr ($ a) [b,c,d]
09:04:57 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
09:04:57 <lambdabot>                     Debug....
09:05:09 <kuribas> Can I have more than one cathegory in cabal?
09:05:10 <elliott> ski: I think it's a common source of confusion to imagine Haskell as having certain kinds of special "mutable values"
09:05:20 <gavri> assuming a tree datastructure, with the usual meanings of Bin and Empty
09:05:29 <merijn> gavri: Constructors with no argument are by definition shared
09:05:29 <elliott> rather than an "external" mutable state that is never reflected in terms of actual Haskell values
09:05:30 <gavri> when I do a (Bin 5 Empty Empty)
09:05:33 <elliott> (inside of IO)
09:05:36 <gavri> oh ok, thanks
09:05:42 <gavri> what about constructors with parameters?
09:05:44 <ski> > map ($ a) [f,g,h]     :: [Expr]
09:05:45 <lambdabot>   [f a,g a,h a]
09:05:53 <ski> elliott : yes
09:06:01 <gavri> how do I share objects created through constructors with parameters?
09:06:08 <merijn> gavri: Those are only guaranteed to be shared if you do it explicitly
09:06:09 <joelteon> isn't there a function somewhere a -> [a -> a] -> a
09:06:21 <ski> elliott : i'm not really happy with people saying "this is pure and that is impure", either
09:06:21 <merijn> gavri: GHC *may* optimise to share, but that's not guaranteed
09:06:22 <kuribas> deech: fromEnum
09:06:43 <scshunt> joelteon: that seems to me to be an unlikely library function type
09:06:48 <merijn> gavri: You can guarantee it using something like "let t = Bin 5 Empty Empty in Bin 1 t t"
09:06:49 <gavri> how do I share them explicitly? if I invoke a function that returns these objects, the returned objects are not shared, right?
09:07:06 <joelteon> rats
09:07:07 <gavri> oh cool
09:07:19 <merijn> gavri: i.e. ghc guarantees that it will only ever compute named values once
09:07:23 <gavri> let and where clause defined functions are only invoked once?
09:07:28 <ski> elliott : even though `RealWorld -> (RealWorld,a)' has limitations, i think it's useful for realizing this ..
09:07:40 <merijn> gavri: If they evaluate to values, then yes
09:07:43 <gavri> how are named values different from function definitions?
09:07:51 <gavri> I guess these are dumb questions
09:07:53 <enthropy> deech: usually one of the labels is the prefered one, so  fromEnum 5 = TheNewerLabelThatIsEqualTo5ForC
09:07:55 <jmcarthur> gavri: where desugars to let, and let is how we explicitly define sharing
09:07:58 <gavri> is there a reference I could read?
09:08:02 <kuribas> joelteon: foldl (.) ?
09:08:02 <jmcarthur> gavri: functions are values
09:08:03 <elliott> ski: yes, I'm okay with referring to things in IO as impure/effectful/etc. as long as you also admit the same for State etc. and do it in a principled manner
09:08:09 <elliott> otherwise so much confusion abounds
09:08:17 * ski nods
09:08:18 <scshunt> joelteon: if you added a Monoid constraint to a, then that would be fine... it's just foo a = mconcat . map ($ a)
09:08:20 <applicative> kuribas: yes:  Category: Control, Acme, Game
09:08:25 <ski> (though i prefer to say "effectful")
09:08:29 <gavri> if a let defined function takes in a parameter
09:08:34 <merijn> gavri: Well, I meant that if you have "let f = .. in Bin 1 (f 10) (f 10)" ghc doesn't guarantee "f 10" is only computed once
09:08:37 <deech> enthropy: Did you toEnum 5?
09:08:39 <kuribas> applicative: Ah, I see.
09:08:42 <enthropy> maybe
09:08:43 <elliott> ski: IO does break semantics though, so there's that :(
09:08:44 <gavri> oh yeah
09:08:45 <joelteon> > foldr (.) [a,b,c,d]
09:08:46 <lambdabot>   Couldn't match expected type `a0 -> b0'
09:08:46 <lambdabot>              with actual type `[Deb...
09:08:48 <gavri> it doesn't, right?
09:08:52 <merijn> gavri: GHC *may* optimise it to only evaluate functions once, but it's not guaranteed
09:08:53 <gavri> so how do I ensure that it does?
09:08:54 <ski> elliott : which semantics ?
09:09:00 <merijn> gavri: Actually, in some case it can figure that out
09:09:02 <gavri> it's one of the exercises in okasaki's book
09:09:05 <merijn> gavri: Just name the result
09:09:07 <jmcarthur> gavri: let x = f 10 in ...
09:09:12 <applicative> kuribas: oh here's a typical example https://github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/blob/master/pipes-concurrency.cabal#L26
09:09:18 <merijn> gavri: "let x = f 10 in Bin 1 x x"
09:09:27 <kuribas> applicative: ok, thanks.
09:09:32 <deech> enthropy: Then I get overlapping enum warnings on the fromEnum side. Do you know how to turn off warnings locally?
09:09:38 <gavri> so there is a difference between functions that take no parameters from functions that take parameters when it comes to whether the return values are memoized or not?
09:09:43 <applicative> kuribas: he should add Game because of the tutorial, it occurs to me...
09:09:54 <jmcarthur> gavri: note that *sometimes* ghc will perform common subexpression elimination, but this is not to be depended on (and it's somewhat rare anyway)
09:09:58 <merijn> gavri: Think of names as pointers/references to values. When the runtime looks up the value and it's not computed, it will be. If the value is already computed it will just use it
09:10:06 <jmcarthur> gavri: it's not the same thing as memoization
09:10:06 <ski> gavri : there are no functions that take no parameters. every function takes exactly one parameter
09:10:18 <elliott> ski: e.g., can observe sharing, can distinguish _|_s
09:10:19 <enthropy> deech: you mean for the enum instance generated by c2hs?
09:10:21 <gavri> merijin, and that isn't guaranteed either?
09:10:30 <merijn> @google Conal Elliot Everything is a function
09:10:32 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:10:32 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
09:10:37 <deech> enthropy: yes, or even by hand.
09:10:41 <elliott> merijn: two ts! two ts!!!!
09:10:52 <jmcarthur> gavri: it's exactly as in any other language. if you define an intermediate value in a strict language, it's only evaluated once, not twice. however, if you do this in the body of a function and apply the function twice, the work in the body of the function can still happen twice
09:10:53 <merijn> elliott: It's not even your name!
09:10:53 <elliott> I should set up a script to correct people on conal's and my name.
09:10:59 <applicative> in the primitive lambda calculus everything really was a function
09:11:10 <enthropy> deech: well there's no point in having two clauses   toEnum 1 = .. ; toEnum 1 = ..
09:11:21 <elliott> merijn: but I want people to keep assuming I'm Conal.
09:11:22 <gavri> an intermediate value here == function with no arguments?
09:11:22 <kuribas> joelteon: flip (foldl (.) id)
09:11:23 <ski> elliott : i think you can "explain away" that as due to indeterminacy (though this isn't then very accurate)
09:11:26 <elliott> merijn: makes 'em listen
09:11:32 <deech> enthropy: You're right. Dumb question.
09:11:33 <hpc> elliott: it should have a very low probability of correcting in the opposite direction
09:11:37 <hpc> fur fun
09:11:46 <elliott> ski: right, probably IO works out if you just let its semantics be completely nondeterministic...
09:11:48 <hpc> *o
09:12:04 <jmcarthur> gavri: in haskell, a value is either a function or it is not. all functions in haskell have one argument
09:12:05 <enthropy> elliott: that's a good argument for saying you can't say anything about the `a'
09:12:09 <applicative> elliott: you don't say 'denotational' and 'meaning' enough; you'll never pass the turing-conal test
09:12:17 <gavri> oh ok
09:12:18 <gavri> got it
09:12:26 <elliott> I talk about meaning a lot. I try to slip it in subtly when trying to get newbies to think about their types.
09:12:40 <elliott> the CPOs are hidden away behind the curtain.
09:12:46 <ski> enthropy : i still didn't get why you thought you could say something about `a'
09:12:52 <elliott> by the way, what is "a"?
09:13:00 <merijn> gavri: You should read that blog post, btw :)
09:13:07 <enthropy> elliott: the result of f
09:13:16 <jmcarthur> gavri: a "function with no arguments" might make sense when you are thinking in some sort of abstraction (the same one that allows us to talk about functions of more than one argument), but when talking about just haskell it is, in the most pedantic sense, nonsensical
09:13:20 <ski> elliott : "mapM_ g =<< replicateM n f   ===  replicateM_ n (g =<< f)  -- this is not required, but what can we say about the `a' in `f :: m a' if it does hold?"
09:13:21 <enthropy>  > mapM_ g =<< replicateM n f   ===  replicateM_ n (g =<< f) -- recall
09:13:22 <merijn> gavri: It should explain why there is no such thing as "function with no arguments" :)
09:13:27 <applicative> a :: *, probably; there's an assertion
09:13:34 <dmj`> I'm trying to add SSL to Scotty. Was wondering if someone could comment if I have the right approach?
09:13:35 <dmj`> https://github.com/xich/scotty/pull/43
09:13:36 <elliott> ah. my answer is nothing
09:13:38 <merijn> jmcarthur: It's usually quicker to just link to the Conal blogpost :)
09:13:42 <gavri> thanks, everybody
09:13:43 <elliott> my proof is parametricity
09:13:50 <ski> applicative : which is self-evident ;)
09:13:56 <gavri> I'm reading the blog post
09:14:14 <applicative> ski: like all the best assertions, upon proper reflection
09:14:20 <ski> <ski> enthropy : i think one sufficient condition is `forall y. liftM2 (,) f (g y) = (flip . liftM2 . flip) (,) f (g y)'
09:14:53 <enthropy> yep, if you can change the order of effects you can go from   f f f f f f g g g g g g   to  f g f g f g
09:15:10 <ski> yes
09:15:13 <enthropy> *and have the same result
09:15:20 <ski> so if you know `f' and `g y' commute, you're safe
09:15:56 <applicative> enthropy: is this like the constrain on 'MonadZip'?
09:17:10 <heha> applicative, try that, but still the same error when build
09:17:43 <applicative> grrrr, heha
09:17:48 <applicative> enthropy: https://github.com/ghc/packages-base/blob/master/Control/Monad/Zip.hs#L29
09:17:59 <ersran9> Is there a good resource for understanding how functions actually behave as functors and applicatives?
09:18:15 <dmj`> @lyah
09:18:16 <lambdabot> Unknown command, try @list
09:18:25 <dmj`> @where lyah
09:18:25 <lambdabot> http://www.learnyouahaskell.com/
09:18:59 <applicative> ersran9: 'actually behave'?  you mean, how do you use fmap and <*> and so on?
09:19:13 <ersran9> dmj`: yes, I've read that. I have an intuition of how they work with types like Maybe, lists etc. I just can't actually extend that intuition to (-> r)
09:19:23 <ersran9> applicative: like, how do I think about it
09:19:44 <merijn> ersran9: I think the best way would be to first try to implement fmap and then look at the real source
09:19:45 <hpc> ersran9: if it helps, (r ->) is the same as Reader r
09:20:00 <applicative> ersran9: the Functor idea is so abstract that you wont be able to form an image, except about the symbols or graphs or other representations
09:20:17 <merijn> ersran9: The Functor instance for "(->) r" is not very hard to implement, so trying to write it is good exercise
09:20:38 <applicative> data Blank a = Blank; instance Functor Blank where fmap f Blank = Blank
09:20:44 <ersran9> merijn: hmm. okay I think I'll try that out
09:20:50 <dmj`> ersran9: In haskell you are mapping algebraic structure onto computation.
09:20:51 <elliott> applicative: I think the key is that functor eventually becomes a kind of foundation that you can form images on top of.
09:21:05 <applicative> data Vanilla a = Vanilla a ; instance Functor Vanilla where fmap f (Vanilla a) = Vanilla (f a_
09:21:08 <applicative> data Vanilla a = Vanilla a ; instance Functor Vanilla where fmap f (Vanilla a) = Vanilla (f a)
09:21:14 <elliott> where before you might have been able to imagine things in terms of physical objects like containers, or things you know operationally like side-effects, or such, you can start thinking about functors instead.
09:21:17 <applicative> elliott: yes
09:21:25 <elliott> at least I would like to believe I have developed this kind of intuition
09:21:38 <applicative> try to get an intuition for what is meant by 'is'
09:21:39 <ersran9> elliott: exactly! I think I have that container model in my head.
09:21:55 <elliott> ersran9: right. it's probably time to grow out of it :)
09:22:27 <applicative> it works really well for all the examples except the most crucial ones
09:22:38 <ersran9> elliott: yes, exactly my question. What would be the way to move forward to develop a more generic intuition?
09:22:45 <gavri> so I have another related question, if I I have a let definition say "let x = f 5", this object pointed to by x is a single object that is shared in a single invocation of this function or is it shared across invocations?
09:23:18 <gavri> in invocations of the function inside which this let is used, I mean. not talking about the function "f"
09:23:48 <dmj`> ersran9: Have you tried the typeclassopedia?
09:23:49 <applicative> > let f = (+1) in let x = f 5 in x + x + x
09:23:50 <lambdabot>   18
09:23:51 <elliott> ersran9: I don't know. try thinking of types and whether they can be Functors, trying to write the instances for them. try seeing what you can do with the interface and what it means in terms of various instances.
09:23:56 <elliott> and yes, read the Typeclassopedia.
09:24:08 <elliott> if you bang your head against the idea enough it'll click.
09:24:13 <ersran9> dmj`: not yet, probably its time for me to attempt to read it
09:24:17 <applicative> ^^^ gavri for sure it doesn't recalculate x 3 times for x + x + x
09:24:26 <merijn> argh
09:24:38 <enthropy> applicative: seems quite similar
09:24:42 <merijn> Nothing as annoying as not being able to load modules in ghci to figure out what's going wrong with your types :(
09:24:45 * merijn kicks pandoc
09:24:56 <ersran9> elliott: aha, nice. Looks like I got a whole night of banging head in front of me. Thanks guys!
09:26:23 <applicative> merijn: cabal repl inside pandoc?
09:26:24 <gavri> I mean for a function definition like this: squareAndTriple n = let x = (n * n) in (3 * x)
09:27:08 <gavri> if I call squareAndTriple(5) once, (5 * 5) is only executed once
09:27:19 <gavri> but if I call it twice, it's executed twice, right?
09:27:22 <enthropy> gavri: Debug.Trace.trace can help with seeing when things are evaluated
09:27:35 <danr> Any good name suggestions for a TH library that generates fmap, foldMap and traverse for arbitrary-aritied functors? (http://lpaste.net/92697)
09:27:54 <applicative> merijn: if i remember it was the gruesome use of Paths_Pandoc that made it such  a trial; but cabal repl is supposed to handle this
09:27:59 <gavri> enthropy: that would show me ghc's behaviour right, including optimizations?
09:28:08 <gavri> I'd like to know haskell's rules
09:28:21 <dmj`> gavri: squareAndTriple = (*3) . (^2)
09:28:29 <elliott> haskell has no rules here
09:28:30 <enthropy> or effects of things like -XNoMonomorphismRestriction, or having type variables left over in a type signature
09:28:34 <elliott> implementations can evaluate however they want to
09:28:34 <monochrom> haskell's rules say nothing about this
09:28:54 <monochrom> haskell's rules say only what answer you get, not how many steps or what steps.
09:29:01 <applicative> there are no rules in Haskell, only {#-RULES-#}
09:29:20 <gavri> ok, thanks again, everybody
09:29:58 <merijn> eeeeewww
09:30:10 <merijn> pandoc uses DatatypeContexts....
09:31:00 <merijn> applicative: What is "cabal repl"?
09:31:14 <applicative> its in cabal-1.18  merijn
09:31:25 <applicative> i can't say i understand all the ins and outs of it
09:31:30 <merijn> Guess I first have to upgrade cabal then...
09:31:36 <hpaste> thr33strikes pasted “how would I run this as a script instead of ghci?” at http://lpaste.net/92699
09:31:45 <merijn> I forgot, do I need to unregister the old cabal-install before updating?
09:32:15 <thr33strikes> i tried main = do
09:32:17 <enthropy> elliott, ski: still going back to my original question, other languages have the concept of a "value type" or a "reference type". This is not a useful way to talk/think about the properties of the f and g you expect to come across?
09:32:21 <applicative> merijn: you might rename it for the moment if its in ~/.cabal/bin, since it will be overwritten by itself
09:32:37 <elliott> enthropy: yes, in haskell all types contain unchanging values
09:32:43 <elliott> possibly implemented with references, but this matters only for performance
09:33:16 <elliott> we have things that create the illusion of mutability -- State, where the catch is that we *vary* the values we are looking at -- and things that allow access to external mutability -- like IO
09:33:21 <elliott> but the values themselves never change.
09:33:37 <elliott> IO is best thought of a communication with, say, a C program that has a mutable store and file IO capabilities.
09:33:50 <elliott> also known as the runtime system :)
09:35:06 <applicative> thinking of IO that way, is surely basically a mental illness; but never mind....
09:35:33 <enthropy> one example I recently struggled with http://lpaste.net/92671
09:35:35 <gavri> is it correct to say that if I create an object out of a constructor that takes in no arguments multiple times, multiple objects may or may not be created, but if I have a top level definition say "let empty = Empty" and use "empty" in all of my function definitions, then compiler/runtime is forced to use the same object?
09:35:49 <merijn> applicative: "cabal repl" seems intended to work with sandboxes, which is not what I have
09:35:54 <dmj`> ersran9: Think of Maybe and List as computational contexts. Maybe is a context for computations that can fail (or return  single value), list is one for non-determinism (computations that can have multiple results). When you use a functor you are modifying the values inside of this context in such a way that the functor laws for composition and identity are upheld. The container analogy breaks down when you begin using fmap on
09:35:54 <dmj`> non-container like things, like functions. Look at the State monad instance for functor and you'll see.
09:36:17 <merijn> gavri: "let" is an error at the top level, but yes, if you use "empty = Empty" at the top level, it's guaranteed to be just one value
09:36:34 <merijn> gavri: Although in the case of constructors with no arguments, that already happens automatically
09:36:49 <applicative> merijn: yes, but thats because you havent been using cabal-1.18?
09:37:13 <gavri> yeah, but the top level definition is haskell being haskell and the empty constructor being a single object is ghc optimizing?
09:37:18 <gavri> or have I got that wrong?
09:37:28 <applicative> merijn: just a sec, i dont have it on this machine , or not quite
09:37:49 <merijn> applicative: I'm installing it now, but my problem is that I can't load the code due to some modules not being found
09:38:06 <applicative> merijn: which ones?
09:38:07 <merijn> applicative: I don't see how sandboxes (or tools for working with sandboxes) help with that?
09:38:14 <applicative> what are missing?
09:38:37 <merijn> applicative: The Paths one (which I fixed by adding dist/build/autogen to my search path) currently it's giving syntax errors on CPP macros :\
09:38:58 <ersran9> dmj`: hmm. okay I'm gonna try and forget boxes and keep that in mind. I guess it takes time :(
09:39:01 <merijn> Right now I just manually nuked all the compatibility macros to get it to load
09:39:47 <merijn> Which is slightly undesirable
09:40:18 <enthropy> there is a way to get those to run with ghci
09:40:29 <merijn> elliott: You're maintaing lambdabot atm, right? Is there a reasonably up to date dump of her quotes file somewhere?
09:40:37 <enthropy> you have to make it look at something else inside dist/build/autogen
09:40:58 <merijn> enthropy: You're referring to the Paths bit?
09:41:09 <elliott> merijn: there isn't. I could look into providing one
09:41:09 <merijn> enthropy: I just mentioned I already fixed that :>
09:41:16 <enthropy> no the cabal_macros.h
09:41:28 <elliott> merijn: you can grep the tunes.org logs for @remember and ?remember of course
09:41:42 <merijn> elliott: The quote I'm looking for is ancient, I think
09:42:35 <thr33strikes> I'm reading Leaernyouahaskell but most of the examples are written for ghci.  I'm having a hard time using the correct syntax in an actual script.  Can someone help me fill in the blanks?  Is there another tutorial that explains this using examples written as scripts?
09:42:54 <dmj`> ersran9: it does, and the plot only thickens as you go. Write a bunch of code. Do the typeclassopedia. My 2 cents.
09:43:01 <ski> merijn : what was the quote about ?
09:43:18 <elliott> thr33strikes: my personal recommendation is to embrace ghci for a while
09:43:24 <merijn> thr33strikes: There's not really a notion of a "script" a haskell file is set of top level definitions and a "main :: IO ()" definition
09:43:34 <dmj`> thr33strikes: what text editor are you accustomed to?
09:43:45 <thr33strikes> vi
09:43:48 <merijn> thr33strikes: I'm guessing your main issue is that editing in ghci sucks?
09:44:22 <merijn> thr33strikes: You can load files into ghci using ":l filename.hs", it will load all definitions in that file into ghci and ":r" will reload any changed files from within ghci
09:44:36 <dmj`> can vim do send-to-repl (C-c C-l) like emacs?
09:44:45 <merijn> ski: getting stuff out of IO
09:45:02 <thr33strikes> I'll resend an example I posted a little earlier
09:45:07 <merijn> dmj`: Yes, but I never bothered with it, I tend to use tmux, vim in one half, ghci in the other and then just run ":r"
09:45:10 <ski> @quote /bin/ls
09:45:10 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:45:20 <ski> merijn : some other one ?
09:45:20 <merijn> ski: Not the one, I know that one by heart
09:45:26 <hpaste> thr33strikes revised “how would I run this as a script instead of ghci?”: “resubmit” at http://lpaste.net/92699
09:45:35 <ski> merijn : any words you recall ?
09:45:36 <applicative> merijn: yes, pandoc is killing my cabal repl inobscure ways; everything else works.
09:45:41 <enthropy> merijn: about the preprocessor macros http://stackoverflow.com/questions/12546757/how-do-i-use-cabals-min-version-and-other-macros-with-ghci
09:45:54 <ersran9> dmj`: I'm going to do that. Thank you for your help!
09:45:56 <merijn> ski: Some, but the problem is that IO has way to many hits in terms of words like "version"
09:46:00 <enthropy> merijn: arguably this could all be set in a .ghci file inside the pandoc repo
09:46:17 <ski> "version" ?
09:46:19 <merijn> thr33strikes: What you you mean by "run that as a script"?
09:46:22 <dmj`> ersran9: no problem, look forward to seeing your progress
09:46:36 <merijn> ski: the io in version matches if you just search for IO in lambdabot >.>
09:46:40 <merijn> @quote IO
09:46:41 <lambdabot> Cale says: One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
09:46:44 <thr33strikes> I mean compile it and run it using the ./filename command
09:47:07 <kuribas> hackage says that I shouldn't use unallocated top level name.  I use Math.Bernstein for bernstein polynomials, Geom2D for geometry functions, and Geom2D.CubicBezier for cubic beziers.  Is that ok?
09:47:24 <dmj`> merijn: lol
09:47:36 <kuribas> I could prepend Data...
09:47:59 <supki> @quote \bIO\b
09:47:59 <lambdabot> monopoly says: do not exist IO. go directly to the REPL, do not pass any parameters or continuations
09:48:01 <dmj`> thr33strikes: you can sort of run your .hs file as script if you add #!/usr/bin/runghc at the top
09:48:05 <merijn> thr33strikes: I annotated a minimal working sample: http://lpaste.net/92699
09:48:21 <merijn> thr33strikes: You can do "ghc filename.hs" to compile that and run the result
09:48:35 * merijn thwaps dmj` with a newspaper
09:48:52 <dmj`> :)
09:49:01 <merijn> thr33strikes: And what dmj` meant to say was "you can add #!/usr/bin/env runhaskell at the top of your file"
09:49:15 <dmj`> yea that =P
09:49:18 <applicative> threedaymonk: that will be much faster if you compile with ghc -O2 ;)
09:49:24 <merijn> dmj`: Using any shebang that doesn't use /usr/bin/env is ground for justified lynching
09:49:38 <NemesisD> i think i'm going to need to build an old version of cabal during this transition period
09:49:42 <gavri> haskell made the first part of the sharing subtrees exercise much easier than I expected it would be https://raw.github.com/gavri/okasaki-exercises-solutions/master/e2.5-sharing-subtrees.hs I hope I haven't missed anything
09:49:44 <applicative> oopp thr33strikes /= threedaymonk
09:50:06 <merijn> thr33strikes: Basically, my version uses "readLn" to read an Int from stdin and then uses "putStrLn" to print the result to stdout
09:51:25 <thr33strikes> how does ghci actually help you write a working program if the syntax is different when you got to put it in a file?
09:51:29 <merijn> 1.18 gives me "cabal repl: unknown command"
09:51:33 <dmj`> merijn: duly noted
09:51:52 <merijn> thr33strikes: How is the syntax different?
09:51:54 <jmcarthur> gavri: there "where empty = Empty" part is unnecessary
09:51:56 <gavri> I guess laziness helped me there, right? it wouldn't have been as easy if haskell was strict
09:52:04 <jmcarthur> gavri: Empty is just a constant anyway
09:52:12 <gavri> oh ok
09:52:16 <gavri> I finally understood that
09:52:18 <jmcarthur> gavri: i don't think laziness has anything to do with it in this case
09:52:28 <thr33strikes> there's a term I can't remember right now
09:52:33 <gavri> constructors are functions, except the constructor that takes in no arguments
09:52:38 <thr33strikes> code that doesn't interact with the real world
09:52:42 <jmcarthur> gavri: well, actually, it kind of does if you want to be pedantic maybe...
09:53:02 <gavri> didn't laziness help? that function goes top down and an object was shared at each level
09:53:04 <jmcarthur> gavri: the difference between lazy evaluation and call-by-name is that laziness adds sharing
09:53:15 <dmj`> thr33strikes: It lets you test your functions on the fly, ensure stuff compiles. No different that irb and python repl in concept
09:53:16 <gavri> I'd have to go bottom up in a strict language
09:53:19 <jmcarthur> gavri: but laziness adds no sharing over normal strict evaluation, normally
09:53:53 <thr33strikes> dmj: but once you hit enter it's gone correct?
09:53:56 <gavri> in this case it made the function definition simpler, right?
09:54:02 <applicative> merijn: unfortunately, as far as I can tell I do need a sandbox ; then cabal repl works fine
09:54:11 <jmcarthur> gavri: right. in a strict language you would just define a value  child = complete x (d - 1)  and then make your result   Bin x child child
09:54:15 <__S__J__> whats up with the (->) syntax? can you show me a aworking example?
09:54:22 <applicative> merijn: how to manage things so that half of hackage isn't built inside the directory, I dont know
09:54:24 <supki> merijn: if you have dist directory you need to rerun cabal configure before cabal repl
09:54:37 <jmcarthur> gavri: it would have to evaluate the subtree before being able to return, so laziness allows you to avoid that potentially, but that's not really related to sharing
09:55:05 <gavri> ok, I think I get it
09:55:20 <__S__J__> nm
09:55:22 <jmcarthur> gavri: however, laziness *can* make it possible to share some recursive definitions where strict evaluation without special support for this would require you to evaluate more at each recursive step
09:55:36 <applicative> merijn: i can even ask it to execute Paths_pandoc.getBinDir
09:55:36 <jmcarthur> gavri: but that's a tricky thing that i don't think you should quite explore yet
09:55:38 <__S__J__> can someone look at my pipes problem above?
09:55:44 <gavri> it didn't help in this case though, right?
09:55:49 <jmcarthur> gavri: right
09:55:49 <dmj`> thr33strikes: It's gone when you close the repl. When you hit enter its stored in memory and can be retrieved and used.
09:55:50 <gavri> I don't know why I thought laziness helped
09:56:03 <__S__J__> http://lpaste.net/92700 <- pipes problem
09:56:14 <merijn> applicative: This seems to help: http://stackoverflow.com/questions/12546757/how-do-i-use-cabals-min-version-and-other-macros-with-ghci
09:56:14 <jmcarthur> gavri: you just aren't used to thinking about laziness yet. this is normal
09:56:21 <gavri> also am I right in saying that constructors that take in arguments are functions and those that don't are not?
09:56:34 <merijn> gavri: Yes
09:56:35 <jmcarthur> yes
09:56:36 <merijn> :t Nothing
09:56:36 <lambdabot> Maybe a
09:56:38 <merijn> :t Just
09:56:39 <lambdabot> a -> Maybe a
09:56:47 <ski> merijn : .. oh
09:57:20 <thr33strikes> merijn: the example you sent me shows pure code in the first few lines and then code that interacts with the realworld in the next?
09:57:22 <gavri> that should have come up somewhere. I've read a couple of introductory haskell books :D
09:57:28 <gavri> I guess it's deducible
09:57:33 <gavri> but I never made the connections
09:57:49 <jmcarthur> i agree that this should be made more clear in beginner material
09:57:59 <jmcarthur> especially since in some languages this is not true
09:58:28 <zhak7> Hi all
09:59:02 <jmcarthur> every time somebody says that i secretly wish that all 1149 people in here would say hello
09:59:11 <zhak7> lol
09:59:13 <monochrom> hello
09:59:25 <monochrom> hello
09:59:34 <zhak7> I'm new to Haskell
09:59:39 <monochrom> (I'm trying to make up for the other thousand people!)
09:59:41 <enthropy> jmcarthur: better yet, start greeting each of the other 1149
09:59:48 <enthropy> -1
09:59:58 <jmcarthur> > product [1..1149]
09:59:59 <lambdabot>   170857757720368524417015333097405790116210616836486436151687652960380992731...
09:59:59 <merijn> thr33strikes: Yes, basically haskell code has a "main" action of type "IO ()" that is run when your program is run. It is very similar to the "main" function in C/C++/whatever
10:00:10 <jmcarthur> err
10:00:12 <jmcarthur> no
10:00:24 <enthropy> > 1149 * 1148
10:00:26 <lambdabot>   1319052
10:00:33 <jmcarthur> yeah
10:00:37 <monochrom> it is, indeed, why some IRC netiquette says: "don't say hello that easily when someone joins".
10:00:49 <jmcarthur> assuming both say hello to each other
10:01:39 <monochrom> at first the advice looks rude. but imagine even just 50 people saying hello just because someone joins. it's going to be epic
10:01:49 <zhak7> Nobody forces everyone to say hello, I'm just polite ;)
10:01:52 <jmcarthur> very welcoming though!
10:02:25 <ski> enthropy : consider `type M a = State (Int,Int) a; type RefInt = Bool; readRef :: RefInt -> M Int; readRef False = gets fst; readRef True = gets snd; writeRef :: RefInt -> Int -> M (); writeRef False m = modify enthropy : consider `type M a = State (Int,Int) a; type RefInt = Bool; readRef :: RefInt -> M Int; readRef False = gets fst; readRef True = gets snd; writeRef :: RefInt -> Int -> M (); writeRef False m = modify (first (const m)); writeRef 
10:02:31 <monochrom> oh, the joiner himself/herself saying hello is totally cool, no problem there :)
10:02:49 <zhak7> hah :D
10:02:49 <ski> hm, suspected cut off ".. writeRef False m = modify (first (const m)); writeRef True n = modify (second (const n)); evalM :: Int -> Int -> M a -> a; evalM m n ma = evalState ma (m,n)'"
10:04:25 <enthropy> that's a lot to consider
10:04:26 <__S__J__> http://lpaste.net/92700 <- pipes problem, can someone explain how to fix the type problem?
10:04:39 <ski> enthropy : now, a `RefInt' here *behaves* like if it was an `IORef Int', i.e. like a "reference type" -- but in actuality it's just a (boolean) index into a collection (a pair, here) -- the `RefInt' itself doesn't contain the data stored "behind" it, that data is secretly passed along inside the `M' monad
10:05:46 * hackagebot threepenny-gui 0.3.0.0 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.3.0.0 (HeinrichApfelmus)
10:05:48 <copumpkin> ski: that much code seems more suited to a paste :P
10:05:48 * hackagebot cubicbezier 0.1.0 - Efficient manipulating of 2D cubic bezier curves.  http://hackage.haskell.org/package/cubicbezier-0.1.0 (KristofBastiaensen)
10:05:57 <copumpkin> ski: just for pedagogical reasons :)
10:06:03 <ski> enthropy : the main difference with `IORef' is that (a) here you can't allocate new references dynamically (so there's only two of them, even); and (b) here you can actually "go back in time" and try another state-update, since there is an `evalM' function (unlike for `IO')
10:06:07 <applicative> __S__J__: this is complicated; for starters you might install the new pipes-platform which will be hackaged today or tomorrow.
10:06:07 <copumpkin> oh, it's duplicated
10:06:30 <ski> copumpkin : yeah, i didn't realize it was so long
10:06:35 <elliott> ski: it isn't
10:06:36 <ski> .. oh, so it is
10:06:38 <elliott> you just repeated your message
10:06:59 * ski hangs head in shame
10:07:05 <copumpkin> :)
10:07:41 <applicative> __S__J__: https://github.com/Gabriel439/pipes-platform you will also need https://github.com/k0001/network-simple
10:08:11 <monochrom> new catchy thing to say: an IORef Int contains an Int in the same sense as an IO Int contains an Int
10:08:24 <jmcarthur> uh
10:08:32 <elliott> monochrom: but how do you get the IORef out?
10:08:50 <monochrom> that's the realm of ConstraintKinds!
10:09:03 <ski> why ?
10:09:11 <monochrom> err, no, oops
10:09:17 <enthropy> IORef just has kind * -> *
10:09:19 <jmcarthur> that statement can be taken a couple different ways
10:09:42 <edwardk> elliott: by forking repeatedly and scribbling to all the addresses in the heap in separate copies of the process one at a time until the answer changes
10:10:16 <jmcarthur> since in the operational sense, it *does* contain an Int, although perhaps denotationally it does not. i guess the denotation of a reference requires some environment.
10:10:33 <elliott> I don't think IORef Int operationally contains an Int
10:10:36 <elliott> it contains an address
10:10:41 <elliott> well.
10:10:48 <elliott> okay, so does Int
10:10:57 <elliott> or whatever. "contains" is an operationally weird phrase.
10:10:59 <monochrom> it was a joke. please don't take it seriously. :)
10:11:04 <jmcarthur> we typically think of indirection as containing, but the mutability makes it weird
10:11:07 <discoloda> can I get a little help with a little library? https://gist.github.com/discoloda/6477331
10:11:16 <jmcarthur> monochrom: i was not, but that doesn't not make it less interesting
10:11:18 <elliott> yes, operationally Strings change too
10:11:22 <thr33strikes> merijn: that makes so much more sense now. thanks for the example.
10:11:22 <elliott> to become evaluated
10:11:38 <jmcarthur> *doesn't make
10:12:15 <merijn> thr33strikes: FWIW, as I mentioned before, if you just want to play with things in ghci while writing in an editor you can load external files into ghci and run the code from there
10:12:21 <applicative> merijn: yes, but all this is taken care of by cabal sandbox init; cabal configure; cabal repl
10:12:33 <monochrom> if you take it seriously, I think you can do it both ways. ski shows how to make RefInt not contain an Int. but you could do it another way, and make RefInt contain an Int.
10:12:38 <merijn> applicative: Is it? Why?
10:12:50 <merijn> applicative: Why does cabal do that for sandboxes but not for non-sandboxes?
10:12:56 <applicative> merijn: i'm busily all over pandoc
10:13:14 <applicative> merijn: i think we just don't enough about how to use it -- or its an issue to raise
10:13:17 <monochrom> but I like the denotational story
10:13:20 <merijn> I managed to get it to load using that SO answer and -idist/build/autogen already, btw
10:13:22 <jmcarthur> ah, i didn't realize that made sense in context. i had ignored ski's code because it looked long
10:13:44 <merijn> Fingers crossed my newly compiling pandoc actually works rather than crashing due to me introducing a silly bug :>
10:13:58 <elliott> monochrom: ski's RefInt contains a pointer too
10:14:26 <jmcarthur> yeah, i also like the denotational story, but you have to admit that the claim that IORef Int contains no Int sounds pretty confusing ;)
10:14:30 * applicative didn't need black magic to open Paths_pandoc and find out where the executable had been installed in his sandbox
10:14:30 <monochrom> it's really a pointer.
10:14:51 <merijn> applicative: I wasn't interested in executables?
10:15:01 <thr33strikes> merijn:  I'll try to become more comfortable with running code either way.  My hurdle right now is my lack of knowledge and everyday because of people like you and this channel I'm getting a little smarter.
10:15:03 <applicative> merijn: that was an example
10:15:08 <merijn> applicative: I wanted to load a module into ghci to check out some types/make hdevtools work
10:15:37 <applicative> right, so my example of loading a module into ghci was loading Paths_pandoc
10:15:47 * hackagebot genifunctors 0.1.0.0 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.1.0.0 (DanRosen)
10:17:10 <jmcarthur> i suppose no (T a) where a is invariant will contain an a
10:17:21 <monochrom> I think in real life we cut some slack on imperative programmers (there are so many afterall, and even I am one of them) and agree to say: if you have a pointer/address to an Int, you already say the pointer contains an Int, even though denotationally you still have to look up the environment
10:17:40 <elliott> jmcarthur: yep. covariant: "does not contain negative uses" contravariant: "does not contain positive uses" invariant: "does not contain positive or negative uses"
10:17:43 <jmcarthur> so for that reason i think IORef is less interesting than IO in this respect
10:17:48 <applicative> merijn: which i did by doing cabal repl; > import Paths_pandoc ; > :browse ; etc
10:17:49 <jmcarthur> since IO is covariant
10:17:50 <elliott> er
10:17:54 <elliott> jmcarthur: sorry, that is not what invariant is
10:18:00 <dmj`> thr33strikes: sublime text 2 is also quick and dirty for writing/compiling haskell. Install it, then install the sublime-haskell package, set your build system to haskell, define a main function, Apple+B to compile, and bob's your uncle.
10:18:00 <elliott> at least in the terminology lensy folk use
10:18:01 <watermind> Here's an idea/question... why not be able to declare constructors in classes, and then define in instance declarations?
10:18:02 <elliott> we call that anyvariant
10:18:08 <elliott> invariant is Endo
10:18:31 <jmcarthur> elliott: invariant is just neither covariant nor contravariant
10:18:32 <edwardk> anyvariant = phantom, easily changed
10:18:38 <watermind> that way we could use pattern matching with class polymorphism
10:18:53 <enthropy> watermind: you know about associated types / type families?
10:18:54 <edwardk> "both covariant and contravariant"
10:19:02 <jmcarthur> err
10:19:03 <jmcarthur> right
10:19:12 <watermind> enthropy: I know about type families, not associated types
10:19:31 <enthropy> well you can put a data family inside a class
10:20:01 <watermind> enthropy: hmm yes I've looked at that before, and even used it... let me refresh my memory
10:20:32 <enthropy> I guess the actual data that you make the instance of the data family has to be declared somewhere else
10:20:39 <ski> @remember monochrom new catchy thing to say: an IORef Int contains an Int in the same sense as an IO Int contains an Int
10:20:39 <lambdabot> Good to know.
10:20:45 <watermind> enthropy: I'm remembering, so you could use different data structures for different instances
10:20:47 * hackagebot boomerang 1.4.0 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.0 (JeremyShaw)
10:20:58 <monochrom> yikes
10:21:13 <ski> HHOS, and all that
10:21:13 <watermind> enthropy: still not sure how that helps in this case though?
10:21:32 <elliott> jmcarthur: invariant requires both ways to map (so *can* contain covariant "a"s)
10:21:40 <elliott> anyvariant requires neither way, or equivalently provides both ways to map
10:21:43 <elliott> so cannot contain any "a"
10:21:50 <shachaf> I approve of the word "phantom".
10:21:58 <shachaf> I never liked "anyvariant".
10:22:19 <ski> how about "avariant" ?
10:22:24 <enthropy> watermind: I dunno, it's the closest thing to your suggestion I know
10:22:47 <monochrom> phantariant
10:22:50 <shachaf> Why not "phantom"? That word is already in use and amounts to the same thing.
10:23:18 <elliott> how about + for covariant, - for contravariant, ± for phantom?
10:23:35 <elliott> er, not for phantom, for invariant
10:24:03 <elliott> and then something for phantom.
10:24:09 <shachaf> ∓ for phantom, obviously
10:24:32 <monochrom> +_+  :)
10:24:38 <shachaf> 0 for phantom
10:24:53 <elliott> yes, I was considering 0
10:25:11 <monochrom> 0 is nice
10:25:32 <elliott> there should be a standard symbol for numbers without sign.
10:25:34 <elliott> then you could use that
10:25:35 <shachaf> What about a notation for strict positivity?
10:25:36 <watermind> enthropy: http://lpaste.net/92705
10:25:41 <watermind> ^ an example of what I mean
10:26:17 <watermind> the idea is that if you could declare constructors in classes then you could use pattern matching when together with class polymorphism
10:26:18 <shachaf> ＋, clearly.
10:26:51 <watermind> it's seems like a pretty simple extension
10:27:00 <elliott> strict positivity is a weird notion.
10:27:17 <watermind> and it would make some code simpler, and allow for more type safety and better warnings/error messages
10:27:34 <monochrom> the "strict" just means "not 0"
10:27:51 <shachaf> Next, edwardk can come up with a notation for colavariant types.
10:28:46 <shachaf> monochrom: I don't think a "strictly positive" type is related to that.
10:28:52 <elliott> is pepsi a colavariant?
10:28:54 <edwardk> actually. funny you should mention that. the tensors library i'm playing with lets me talk about tensors with  superscripts and subscripts as 'modes' or as distinguishing data from codata.
10:29:12 <edwardk> but it all comes down to wanting to smash these things together into a variant of the cola… in morton order
10:29:15 <edwardk> we'll see if it works
10:29:23 <watermind> hmmm let me see
10:29:28 <edwardk> there is a more coherent exposition than that
10:29:38 <edwardk> but notationally things look like string diagrams
10:29:51 <elliott> edwardk: I like how you just mash together a bunch of concepts and force them to help each other.
10:29:59 <elliott> "alright, let's have tensors, codata, and morton order"
10:30:39 <monochrom> "one variant to rule them all, in the dark lands of morton order"...
10:31:01 <monochrom> or perhaps s/variant/cola/
10:31:02 <edwardk> well, by using the string diagram i get a nice notation, superscripts are codata/inputs, subscripts are results, tables and tensors are the same in this view, and my matrix multiplier works even for n-way multiplies/n-way joins so i get a 'planless' join structure.
10:31:53 <edwardk> then in the string diagram i let you make arbitrary forks and you can form cups as 'joins', and we can have tables as tensors with only subscripts, and table-valued functions as tensors that have some superscripts
10:32:33 <edwardk> the results are produced in my funny morton order. if you have something with all superscripts it acts like a filter. with a mix of super and subscripts it acts like a function, with all subscripts it acts like a table.
10:33:01 <BMeph> edwardk: You do know, don't you...
10:33:16 <edwardk> we can't form a 'cap', but we can take a table of possible inputs, .g. a range, and wire it up to an input of a predicate, and take another table of possible inputs and wire it up to the other input, then fork those wires and read out the answers
10:33:21 <BMeph> edwardk: ..that you cannot simply waltz into morton order? ;p
10:33:35 <monochrom> haha
10:34:07 <edwardk> and all of the results can be produced interleaved in morton order using the join trick…. and i'm working on ways to upgrade the cola to provide the catenable form i need to make my matrix multiplier fast
10:34:46 <monochrom> "one simply unsafeInterleaveIO into Morton order" http://lpaste.net/77457
10:35:17 <thr33strikes> does ghci ignore main?
10:35:28 <monochrom> no
10:35:37 <edwardk> on thought is to take the cola and use it as part of a larger structure. build an interval map out of say a finger tree where the entries are sorted vectors with bloom filters, and say that we never want more than log n intervals to overlap at any position, then i can search for a point by doing a lookup on the interval map, filtering the selection down, and then searching the hits.
10:36:01 <edwardk> doing cola-style joins to preserve the interval map invariant, but then concatenation is orders of magnitude cheaper
10:36:14 <edwardk> that means that the cola forms the basis for my tables/relations/tensors
10:36:25 <edwardk> but its complicated enough that i probably will never finish it
10:36:59 <merijn> thr33strikes: Define "ignore" it doesn't automatically run main, but if you type "main" or ":main" it will execute it
10:38:26 <edwardk> one of the reasons the matrix multiply series has stalled is that i've been working on getting the cola into a suitable form, so i can talk about things about a step behind actually implementing them
10:38:40 <edwardk> now that it beats map i can start polishing it up
10:39:12 <thr33strikes> ok that explains it
10:39:48 <ski> enthropy : did you get my point ? or should i paste and reexplain ?
10:40:04 <thr33strikes> doesn't automatically run it because of laziness?
10:40:25 <monochrom> no. because I don't want it run.
10:40:40 <merijn> thr33strikes: No, mostly because it's really inconvenient to execute a program everytime you reload when you're loading an executable into ghci :p
10:40:48 <enthropy> ski: I think I got it
10:40:52 <thr33strikes> ok
10:41:25 <hpaste> enthropy pasted “watermind” at http://lpaste.net/92706
10:41:25 <merijn> thr33strikes: Imagine a program that spends 5 minutes working on your disk and you just wanted to check the type of a function, executing it would be really annoying
10:41:35 <enthropy> watermind: maybe that is "close enough"?
10:43:42 <ski> enthropy : the main point is that, conceptually speaking, an `IORef a' does in no way contain a `a' value -- it just acts like an array index (in reality a memory address) into some array (the heap) that is separately passed around (implicitly in both the `IO' and the `M' case. in the `IO' you can't get at it at all)
10:43:51 <bss03> Anything in haskell-platform for length-indexed container type family?  Like: Vector 7 Int?
10:45:13 <watermind> enthropy: yeap, I was leaning towards that kind of solution (i.e. use another type to convert to and from and pattern match)...
10:45:25 <johnw> bss03: no, but repa will do that
10:45:40 <watermind> enthropy: mapList f (toC -> Con x xs)  -- ??
10:45:57 <enthropy> watermind: -XViewPatterns
10:46:06 <merijn> Pffft, why does my code refuse to work if I make blind changes in a codebase I don't know >.>
10:46:07 <watermind> enthropy: need to check those... never heard of them
10:46:30 <enthropy> there's not much to them
10:46:41 <bss03> johnw: Thanks.  I knew about Repa, but I think that's overkill for this project.  I'll just use a non-length-indexed type family.
10:46:55 <watermind> enthropy: ohhhh so this exists, I had no idea
10:47:38 <merijn> Is there a way to temporarily disable building of profiled libraries and docs from the command line?
10:48:05 <johnw> --disable-library-profiling
10:48:13 <monochrom> --disable-documentation
10:48:17 <merijn> \o/
10:48:46 <merijn> johnw: I'm assuming there's a similar --disable-executable-profiling?
10:48:55 <johnw> give the man a cookie!
10:49:33 <merijn> i r smrt
10:49:34 <enthropy> watermind: maybe you would be interested in writing your functions in terms of types from GHC.Generics instead
10:49:41 * bss03 Cookie-Set: heresYourCookie
10:49:54 <enthropy> since then the  to/from code will be automated if people ask for it
10:51:23 <merijn> hmmm
10:51:39 <watermind> enthropy: I understand the suggestion, but I don't think so...
10:51:40 <bss03> Is Data.Graph directed or undirected?  I think the documentation is ambiguous on this point.
10:51:47 <merijn> Why don't we add Debug.Trace.trace to Prelude so you don't have to continually add/remove the Debug.Trace import?
10:52:09 <watermind> enthropy: this was just an example... I was trying to move towards what ML languages offer with their modules
10:52:59 <watermind> this isn't quite the same, but it does help working with abstractions
10:53:04 <gavri> given a list, how do I apply them as arguments to a function. for example, assuming that there is no "sum" function, how do I use + to add up the two elements in the two element list [4, 5]?
10:53:13 <dmj`> Added warp-tls to Scotty. Hoping for feedback from warp people. Tried to base off flask.
10:53:14 <dmj`> https://github.com/xich/scotty/pull/43
10:53:21 <elliott> gavri: foldr or foldl'
10:53:24 <elliott> > foldr f z [a,b,c,d]
10:53:25 <lambdabot>   f a (f b (f c (f d z)))
10:53:29 <bss03> dmj: Data.List.foldl' 0 (+)
10:53:31 <elliott> > foldr (+) 0 [a,b,c,d]
10:53:32 <lambdabot>   a + (b + (c + (d + 0)))
10:53:37 <elliott> > foldl f z [a,b,c,d]
10:53:38 <lambdabot>   f (f (f (f z a) b) c) d
10:53:40 <elliott> > foldl (+) 0 [a,b,c,d]
10:53:41 <lambdabot>   0 + a + b + c + d
10:53:43 <gavri> I was hoping for something more concise than that :/
10:53:44 <elliott> (but you want foldl' for strictness when summing)
10:53:57 <elliott> gavri: "foldl' (+) 0" isn't much longer than "sum"...
10:54:23 <bss03> dmj: foldr1 (+) ?
10:54:35 <gavri> I guess it doesn't look so great in the context of the actual code I'm writing
10:54:57 <gavri> it doesn't feel like I'm folding anything
10:55:04 <elliott> gavri: why not just write sum...?
10:55:07 <begriffs> Can anyone help me debug this type error? I am trying to use postgresql-simple and the simplest example fails:  do { conn <- connect defaultConnectInfo; query conn "select 2 + 2" }. It wants "IO b0" but it is getting "q0 -> IO [r0]". Does query take another argument that the example in the docs isn't telling me about?
10:55:08 <gavri> because they just happen to be two arguments to a function
10:55:12 <bss03> gavri: If you are reducing a list, you are doing a fold.
10:55:14 <gavri> that happen to be in an array
10:55:17 <elliott> ok, well, what is the actual code?
10:55:22 <johnw> I think he wants something like "apply" from Lisp?
10:55:32 <watermind> enthropy: now I just wish we could have multiple instances for the same types, one of them being the default one, and the possibility of opening alternative instances in a certain scope
10:55:45 <gavri> johnw: yeah, I finally made the connection
10:55:48 <gavri> that's what I want really
10:55:52 <johnw> apply is just a fold ;)
10:55:55 <elliott> you can't have that, sorry :)
10:55:57 <elliott> it doesn't have a type.
10:56:08 <elliott> but I'd like to ask again the actual function and list involved here
10:56:43 <bss03> alliot: Well, it doesn't have a "simple" type.  I'm pretty sure you can dependently type it. :P
10:56:54 <merijn> That moment you realise you just spent an hour debugging functionality and it turns out cabal just wasn't updating the symlink to your binary >.>
10:57:01 <gavri> elliott: I'll link to it in a couple of minutes
10:58:51 <jmcarthur> haskell can type apply, but it isn't as simple as fold
10:58:52 <erisco> > foldr (:) [] [1..10]
10:58:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:59:08 <gavri> elliott: https://gist.github.com/gavri/6477749/raw/7e9c831bb76df9b937c14ec8e5e06e364d923b96/gistfile1.hs
10:59:15 <erisco> reduced to a list! :)
10:59:21 <jmcarthur> and it can't just use a simple list. it needs to have more rich types
10:59:22 <gavri> so I wanted to simplify that using map
10:59:26 <bss03> jmcarther: It involes HList for the arguments and some weird typeclass for the function, yeah.
10:59:42 <gavri> and realized that after the simplification, I had a list of two elements
10:59:43 <jmcarthur> or some alternative to HList, but yes, that's the general idea
10:59:49 <gavri> that I wanted to apply to the Bin constructor
11:00:03 <gavri> to (Bin x) actually
11:00:14 <jmcarthur> gavri: why a list instead of a tuple?
11:00:17 <elliott> gavri: split should return a tuple, not a list
11:00:24 <jmcarthur> gavri: with a tuple, you could just use uncurry
11:00:25 <elliott> in fact incomplete assumes it does
11:00:26 <jmcarthur> :t uncurry
11:00:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:00:32 <gavri> thanks a lot
11:01:31 <applicative> begriffs: did you figure it out; there are two 'query' functions one in mysql and one in mysql-simple https://www.fpcomplete.com/hoogle?q=query&env=ghc-7.4.2-stable-13.09
11:02:19 <bss03> If I have a function I want to specialize, and I want the specialization to have a separate name, I just do something like:
11:03:03 <bss03> g :: (Num n) => n -> Foo; f :: Int -> foo; g = {- stuff here -}; {-# SPECIALIZE g Int #-}; f = g;
11:04:33 <xplat> if i want to deserialize an ADT from a serialization format defined by another language's runtime (ocaml here), which binary serialization library should i use?  binary, cereal or something else?
11:04:51 <gavri> a stupid thing to do, I know, but is there a reason there can't be a version of uncurry that acts on lists? it would have limited use and would be strictly a subset of what uncurry does, but I'm helping that the answer to this this question would help me gain a better understanding of types in haskell
11:04:56 <begriffs> applicative: I'm using the one from postgresql-simple though
11:05:08 <gavri> *hoping
11:05:28 <xplat> gavri: there's no such thing as a variadic function for it to curry/uncurry into
11:05:37 <gavri> oh
11:05:38 <gavri> got it
11:05:40 <merijn> xplat: binary or cereal should both work, their very similar
11:05:54 <merijn> xplat: Juse use the Get monad to specify the deserialisation
11:07:09 <xplat> gavri: if you stretched things you could say foldl is similar to an uncurry for lists, though
11:07:23 <xplat> merijn: ah, thanks
11:08:24 <gavri> damn, there's a specific kind of pleasure I get from learning haskell that I don't get from learning other programming languages
11:09:32 <johnw> being able to think like a mathematician rather than like a computer?
11:10:54 * hackagebot web-routes-boomerang 0.28.0 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.28.0 (JeremyShaw)
11:11:20 <gavri> maybe, but I don't think pure math without being able to run it on a computer would make me feel so great either
11:12:00 <johnw> Mathematica has been around for a long time
11:12:28 <begriffs> applicative:  oh query_
11:12:53 <gavri> never used mathematica. does it have file/device IO etc?
11:13:15 <merijn> gavri: It has file IO
11:13:36 <joelteon> I'm still getting 404s when I try to upload packages, but hackage looks up
11:15:01 <begriffs> What's up with these functions that end in underscore, like query_ and forM_ ? Does that signify something?
11:15:12 <johnw> that the return value is ignored
11:15:34 <johnw> it means the function returns Monad m => m (), typically
11:15:41 <johnw> and so it can optimize for that case
11:15:42 <donri> begriffs: you get the effects (m) but the value (a) is empty (())
11:15:54 * hackagebot data-fresh 0.2013.250 - An interface for generating fresh values  http://hackage.haskell.org/package/data-fresh-0.2013.250 (StijnVanDrongelen)
11:16:52 <applicative> it makes a big difference with eg sequence and sequence_ if i remember
11:17:49 <dmj`> @src sequence_
11:17:50 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:18:01 <S_J> http://lpaste.net/92708 <- can someone help me with pipes
11:18:04 <ski> (the value is trivial)
11:18:12 <S_J> i cant figure out what i need to do
11:19:10 <donri> begriffs: but, doesn't seem like postgresql-simple follows this convention here
11:19:25 <S_J> socketWriteD it has a very weird return type
11:20:41 <applicative> S_J: yes it isn't in IO to get it to type check you'd need to add lift$ to getLine and to the last line
11:20:44 <wontez> can you apply a pattern to IO functions?
11:20:55 * hackagebot damnpacket 0.1.1 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.1 (JoelTaylor)
11:21:22 <applicative> S_J: however, I doubt this is what you want. it is likely that you are looking for a pipes combination involving socketWriteD
11:21:49 <applicative> S_J: well wait, maybe not
11:22:35 <ski> threestrikes : it's not clear what you mean
11:22:42 <erisco> :t coalesce
11:22:42 <lambdabot> Not in scope: `coalesce'
11:23:03 <ski> @wn coalesce
11:23:05 <lambdabot> *** "coalesce" wn "WordNet (r) 3.0 (2006)"
11:23:05 <lambdabot> coalesce
11:23:05 <lambdabot>     v 1: mix together different elements; "The colors blend well"
11:23:05 <lambdabot>          [syn: {blend}, {flux}, {mix}, {conflate}, {commingle},
11:23:05 <lambdabot>          {immix}, {fuse}, {coalesce}, {meld}, {combine}, {merge}]
11:23:07 <lambdabot>     2: fuse or cause to grow together
11:23:38 <threestrikes> ski: is it possible to filter a function like getCurrentDirectory for only files of a certain type?
11:23:47 <threestrikes> ski: or extension
11:23:53 <ski> @hoogle getCurrentDirectory
11:23:53 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
11:23:55 <ski> isn't a function
11:24:04 <ski> it's an `IO'-action
11:24:38 <threestrikes> ohh ok I thought an IO action was a function
11:24:58 <ski> no
11:25:05 <merijn> I'll take the upcoming discussion as a hint to get back to writing my "IO as Programs" explanation that I was procrastinating from
11:25:05 <threestrikes> more reading lol
11:25:09 <S_J> applicative: i want to write and read to a socket...using pipes
11:25:11 <ski> functions in Haskell always takes an argument (exactly one argument)
11:25:14 <ski> @type getDirectoryContents
11:25:15 <lambdabot> Not in scope: `getDirectoryContents'
11:25:20 <ski> @hoogle getDirectoryContents
11:25:21 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
11:26:29 <ski> threestrikes : after applying `getDirectoryContents' to e.g. the directory path you get by executing `getCurrentDirectory', and then executing the resulting `IO'-action, you could filter the resulting list of file (including directory) names that you get as a result
11:26:34 <threestrikes> @hoogle filepath
11:26:34 <lambdabot> Prelude type FilePath = String
11:26:34 <lambdabot> System.IO type FilePath = String
11:26:34 <lambdabot> System.FilePath.Windows type FilePath = String
11:26:38 <threestrikes> wow
11:26:52 <threestrikes> lambdabot :)
11:27:00 <applicative> S_J: this typechecks but isn't what you want yet http://lpaste.net/92709
11:27:40 <applicative> S_J: all the lines in a do block be in the same idiom, or 'monad'; in this case some 'proxy'
11:28:37 <edwardk> ok, what is the nicest way folks can think of to split a list into runs that are monotone increasing?
11:29:05 <johnw> edwardk: a fold should be pretty easy?
11:29:26 <edwardk> johnw: should be, but i figured i'd ask as it is 5-levels deeper than the problem i care about =)
11:29:32 <johnw> ah
11:29:49 <S_J> applicative: so what do i want then?
11:29:51 <napping> what do you mean by "nicest"?
11:29:51 <tromp> fold would be quadratic time?!
11:30:07 <edwardk> i'm also looking for a linear tim solution if possible
11:30:12 <threestrikes> ski: I think I  did that using dirContent <- getDirectoryContents
11:30:16 <tromp> oh, only a leftfold is
11:30:19 <napping> that's more or less how Data.List.sort starts, if you want something efficient
11:30:22 <S_J> I cant IO and socketWriteD in the same do block?
11:30:24 <edwardk> bonus points if you can have it emit vectors rather than lists.
11:30:28 <threestrikes> ski: is this correct?
11:30:50 <edwardk> napping: nicest in the sense that it doesn't have bad asymptotics and the code is obviously correct
11:31:05 <edwardk> good constant factors would be nice as well
11:31:20 <edwardk> as this will form a key part in fromList for the COLA
11:31:55 <enthropy> "obviously correct" shouldn't be that important, since the specification is pretty easy to check
11:32:10 <tromp> an rfold just has to stick next element in front of first list, or prepended as singleton list
11:32:11 <edwardk> basically i have code that can insert monotone increasing vectors into the cola in a big fell swoop, doing minimal merging, but i need to get them out of the initial list
11:32:52 <ski> threestrikes : your `dirContents' is now a list of file paths, that you can filter, e.g. using `filter' or a list comprehension
11:33:09 <enthropy>  prop_splitRuns1 xs = xs == concat (splitRuns xs);  prop_splitRuns2 xs = all (\run -> and $ zipWith (<) run (drop 1)) (splitRuns xs)
11:33:32 <edwardk> hence why this was something just above trivial but anoying to have to deal with along the way =)
11:33:33 <enthropy>  prop_splitRuns1 xs = xs == concat (splitRuns xs);  prop_splitRuns2 xs = all (\run -> and $ zipWith (<) run (drop 1 run)) (splitRuns xs)
11:34:10 <ski> edwardk : .. idly wondering whether one could delay inserting and batch after a while, and whether that would be worth it
11:34:10 <tromp> whenever i read "streaming B-tree" i can't help but think of "screaming B-tree"
11:34:19 <threestrikes> ski: How do I know what the list type consists of once I send the data to dirContents?  Does it continue to be IO?
11:34:26 <edwardk>  ski: thats basically what i'm doing with these runs themselves
11:34:45 <edwardk> tromp: well, its finally screaming. now i want it to support more operations ;)
11:35:06 <edwardk> so i started in on split and union
11:35:13 <ski> threestrikes : `getDirectoryContents dirPath' is an `IO [FilePath], but after `dirContent <- getDirectoryContents dirPath', `dirContent' is a plain `[FilePath]', no `IO' left in it
11:35:40 <ski> edwardk : yeah, thinking about individual, iterated, "insert" calls
11:35:52 <tromp> edwardk, is there a good Judy-tree impl for haskell?
11:36:03 <edwardk> insert itself does a lot of that, but i'm trying to get the whole vectors at a time rather than elementwise inserts
11:36:07 <threestrikes> ski: and when the IO drops it's considered "pure"?
11:36:16 <edwardk> since i seem to have hit a performance cap with that approach
11:36:41 <johnw> > let f x (b,xs@(y:ys)) = if x > b then (x,[x]:xs) else (x,(x:y):ys) in snd $ foldr f (0,[[]]) [4,5,6,1,2,7,8,6]
11:36:42 <lambdabot>   [[4,5,6],[1,2,7,8],[6],[]]
11:36:53 <edwardk> tromp: funny you should ask. ciao marcelo wrote some back in 2006. i first came into this channel to ask about them, since audreyt was his mentor
11:37:08 <edwardk> tromp: but its an external binding, not a reimplementation
11:37:09 <napping> edwardk: I think a little mutual recursion wouldn't be bad.
11:37:10 <applicative> S_J: you can IO and Pipe in the same do block with the appropriate attunement of lifts.
11:37:16 <edwardk> and i have no idea if they are still working
11:37:21 <applicative> S_J: here is another piece of your puzzle http://lpaste.net/92710
11:37:43 <edwardk> napping: i'm happy to outsource this function, i just want it to be fast. let me commit what i have
11:38:03 <edwardk> right now i'm just using  fromList xs = List.foldl' (\m (k,v) -> insert k v m) empty xs
11:38:10 <edwardk> which should probably be a foldr
11:38:11 <tromp> do you know how Judy trees compare to Data.Map in benchmarks?
11:38:26 <edwardk> tromp: well Data.Map is crippled by having to support all versions for all time
11:38:34 <threestrikes> ski: to be more specific, when the IO is no longer a part of FilePath the dirContent can be considered a part of pure code with no side effects?
11:38:37 <edwardk> tromp: so its not exactly a fair fight
11:38:49 <kqr1> threestrikes, not really
11:38:51 <ski> threestrikes : when the `IO' drops the action is considered "done", you're left with the result of executing it. the effects of executing it have already been realized
11:39:02 <edwardk> the COLA i have here cheats a bit too ;)
11:39:14 <kqr1> threestrikes, dirContent is a pure value, yes, but it is still "trapped" in an IO function, sort of
11:39:42 <ski> threestrikes : Haskell doesn't have side-effects at all. but yes, you can say that there's no *effects* (specifically I/O-effects) left, since they have been performed
11:40:11 <threestrikes> ok
11:40:18 <threestrikes> o
11:40:22 <tromp> Ok, so I should ask about Array.ST vs Judy instead
11:40:22 <kqr1> threestrikes, i.e. you have to do `dirContent <- getDirectoryContents' in an IO function, but then for the rest of that function `dirContent' is a pure value
11:40:45 <edwardk> then judy will stomp it
11:40:47 <ski> threestrikes : if we said `getDirectoryContents :: FilePath -> [FilePath]', *then* this would be *side*-effectful (doing I/O effects without declaring them in the interface / type signature, iow doing those effects on the *side*)
11:41:09 <tromp> because Array is only for very dense arrays?
11:41:17 <ski> threestrikes : however, keeping track of the `IO' explicitly in the type means that we're not *hiding* the effects, so they're not *side*-effects
11:41:20 <applicative> S_J: this will be about 1/40,000th the labor tomorrow when the new pipes libraries come out
11:41:58 <ski> threestrikes : in particular, this means that we know that when there's no `IO' hiding in the type, then there's no I/O-effects
11:42:04 <kqr1> applicative, pipes-4.0.0 is the new pipes?
11:42:28 <threestrikes> ski: gotcha
11:42:53 <applicative> kqr1: yes
11:43:06 <S_J> apples: really, TOMORROW?
11:43:15 <ski> threestrikes : in this way, one of the points of using monads to model effects is that we can *refrain* from using a monad, and then we know that the operation won't perform the associated effects (unlike in say C++ where any function call may do I/O or state effects, and may throw an exception -- all this without declaring this in the interface)
11:43:16 <S_J> lol apples->applicative
11:43:35 <edwardk> tromp: yeah. and judy is scarily dense
11:43:38 <hpaste> monochrom annotated “example” with “example implemented (Haskell 98!)” at http://lpaste.net/92705#a92711
11:43:56 <monochrom> watermind: http://lpaste.net/92705#a92711
11:44:54 <tromp> 5
11:44:59 <tromp> wrong window:(
11:45:11 <S_J> Does Parsec work on bytestrings?
11:45:12 <monochrom> /win vista
11:45:27 <S_J> or rather, Can parsed work on bytestrings?
11:45:46 <monochrom> yes
11:45:53 <danilo2> Maybe this is strage question - but is it possible to not load Prelude in any file? I know I can use "import qualified Prelude as Prelude" - but is it possible to prevent Haskell from loading it in any file of my library? (ina cabal config etc?)
11:45:57 <S_J> applicative: ty but I still dont get how to use the Proxy/serve stuff with withSocketsDo
11:46:03 <johnw> NoImplicitPrelude
11:46:14 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#text
11:46:20 <johnw> put that in an extensions block in your cabal file
11:46:26 <johnw> I think it's language-extensions:
11:46:42 <jmcarthur> this (and a few minor variations i have explored recently) is the only example i know about of a lambda calculus syntax which only permits normal form terms. does anybody know of any others, particularly ones in which eta-conversion is sound? http://www.cs.yale.edu/homes/hudak/CS430F07/Programs/LCInterpreterWithSolns.txt
11:47:13 <danilo2> johnw: thank you! And maybe is there a way to load my custom Prelude in each file? (replacing the built in?)
11:47:50 <jmcarthur> it's the eta normal form requirement that is making it difficult for me to invent my own
11:48:05 <johnw> danilo2: for that you'll need to just import
11:48:19 <danilo2> johnw: Ok, thank you :)
11:48:41 <merijn> danilo2: NoImplicitPrelude extension and enable the package wide using the cabal extension syntax
11:48:50 <merijn> oh, curse johnw's speed
11:49:57 <kqr1> danilo2, -XNoImplicitPrelude
11:50:13 <napping> jmcarthur: is that eta-long?
11:50:40 <kqr1> danilo2, or, on a per-file basis, {-# LANGUAGE NoImplicitPrelude #-} followed by import YourPrelude
11:50:56 * hackagebot damnpacket 0.1.2 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.2 (JoelTaylor)
11:51:23 <jmcarthur> napping: you just gave me a very helpful keyword
11:51:26 <kqr1> oh i'm way late to the party there
11:52:11 <napping> jmcarthur: there may be some normalization by evaluation things done in Agda you could look at
11:52:14 <jmcarthur> napping: it looks like i'm looking for a syntax for canonical terms, which is beta-normal + eta-long
11:52:36 <napping> okay, then you do have types, to know how long to make the etas
11:53:02 <khyperia> Question: I want to display an image in a window (aka make a mandelbrot renderer). What's the easiest way to do that? I've only ever done console programs before.
11:53:24 <jmcarthur> ah, i didn't realize that required types. it did in fact run into a problem which i would not have had without types, but i thought maybe i wasn't being imaginative enough
11:53:48 <jmcarthur> i realize i am probably a little fuzzy
11:54:04 <napping> jmcarthur: you can't tell if you want f, or \x -> f x, or \x y -> f x y etc without types
11:54:16 <jmcarthur> right
11:54:21 <jmcarthur> that makes sense
11:54:31 <jmcarthur> i have found LF type theory
11:54:34 <napping> otoh, without types you can write diverging expessions, so you couldn't give a total "apply" operation
11:55:59 <jmcarthur> nice http://twelf.org/wiki/Hereditary_substitution_for_the_STLC
11:56:28 <monochrom> @tell watermind http://lpaste.net/92705#a92711
11:56:29 <lambdabot> Consider it noted.
11:57:27 <ParaSa1lin> @hoogle (//>)
11:57:27 <lambdabot> No results found
11:57:28 <jmcarthur> napping: hmm. is there a reason eta-long is preferred over... "eta-short"?
11:57:53 <inkjetunito> good evening. in general, is compiled haskell faster than (interpreted) python?
11:58:03 <byorgey> inkjetunito: yes.
11:58:04 <jmcarthur> inkjetunito: far far far faster
11:58:06 <elliott> jmcarthur: knowing that a value of a function type is always a lambda is arguably simpler
11:58:07 <napping> I'm not really sure, perhaps just beacuse every term of type A -> B starts then with a lambda binding something of type A
11:58:21 <inkjetunito> byorgey, jmcarthur: great.
11:58:30 <elliott> inkjetunito: yes but you can easily construct badly-written test programs that turn out slower than python ones because the latter spends 90% of their time in highly-optimised C library functions
11:58:33 <napping> inkjetunito: with some possible execptions if you're leaning heavily on functions actually implemented in C
11:59:01 <elliott> haskell's performance should not disappoint at all once experienced with the language and GHC, though, especially if python is already adequate for your purposes
11:59:02 <napping> In particular if you're mostly doing fairly straightforward string munging, Python seems to come out pretty fast
11:59:15 <byorgey> khyperia: I suggest the  gloss  and  gloss-raster  packages.
11:59:39 <khyperia> alright, thanks
12:00:11 <S_J> how would you represent a game board in haskell? Data.map?
12:00:17 <jmcarthur> inkjetunito: yeah i agree with the caveats the other answerers have said
12:00:22 <S_J> i always found arrays a real hassle to work with
12:00:38 <jmcarthur> S_J: i have represented game boards in many different ways. it depends on what i need to be able to do with it
12:00:45 <johnw> there's a library for working with game boards in Haskell, actually
12:00:51 <jmcarthur> johnw: oh interesting
12:01:09 <bss03> S_J: I suppose it depends.  I tend to use a Data.Map.Map or some IArray implementation.
12:01:20 <khyperia> Is there a way to write "\x -> x - 2" in the style of "(operator value)"? When I write (-2) it gets interpreted as negative two, but ((-) 2) doesn't work either, since (/ 2) /= ((/) 2)
12:01:26 <elliott> khyperia: (subtract 2)
12:01:26 <inkjetunito> elliott, napping: thanks
12:01:31 <khyperia> ah, thanks
12:01:33 <johnw> http://hackage.haskell.org/package/grid
12:01:33 <bss03> S_J: I've also just seen it represented as a list of moves.
12:01:35 <elliott> khyperia: it's gross; we're sorry.
12:01:42 <bss03> (subtract 2)
12:01:50 <jmcarthur> khyperia: this is a little special case in haskell syntax that many of us don't really like
12:02:55 <erisco> > (flip (-) $ 2) 1
12:02:56 <lambdabot>   -1
12:03:19 <jmcarthur> johnw: that library looks fantastic
12:03:36 <khyperia> that's... really verbose and confusing, erisco, heh.
12:03:42 <S_J> Map.map?
12:03:48 <erisco> > flip (-) $ 2 $ 1
12:03:49 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> c))
12:03:49 <lambdabot>    arising f...
12:03:54 <erisco> oh right :(
12:03:56 <inkjetunito> i'm mostly interested in haskell because it seems to have a good collection of libraries and it's (hopefully) faster than python on numeric operations
12:04:23 <erisco> khyperia, eh we tried
12:04:25 <jmcarthur> S_J: the library johnw just linked to looks like it basically has everything i ever rolled on my own
12:04:47 <edwardk> so no great insight on elegant conversions to runs?
12:05:02 <monochrom> I like how it also has hexagonal tiles
12:05:03 <edwardk> > groupBy (<) [1,2,3,4,3,4,2,1,4]
12:05:04 <lambdabot>   [[1,2,3,4,3,4,2],[1,4]]
12:05:14 <edwardk> oh its based on the first
12:05:33 <monochrom> and toroidal, hehe
12:05:37 <napping> yep. Not sure you'll do better than something like let run acc limit l@(x:xs) | limit <= x = run (x:acc) x xs; run acc _ l = (reverse acc,l)
12:05:42 <jmcarthur> monochrom: and how it's well documented
12:05:51 <napping> let runs l = unfoldr (\l -> case l of [] -> Nothing; (x:xs) -> Just (run [x] x xs)) l
12:05:51 <monochrom> play Pac Man on hexagonal toroidal maps!
12:06:00 <napping> except building up a vector rather than reversed list
12:06:25 <applicative> S_J: here is something like what you seem to have intended http://lpaste.net/92712 the bytestringiness is seeming a little precipitate
12:06:33 <napping> though turning the whole list into a vector and extracting subvectors by offset might better amortize costs of growing
12:07:13 <edwardk> napping: hrmm. ok, next challenge i guess, accreting the lengths of the little vectors so they can be built with fromListN
12:07:15 <jmcarthur> S_J: btw, here's another relevant library which by design is compatible with any game board type you can probably come up with: http://hackage.haskell.org/package/astar
12:07:48 <edwardk> and we can build the vector in reverse so the reversing step isn't needed if we do it right
12:08:25 <edwardk> basically i'm looking for Ord k => [k] -> [Vector k]
12:08:51 <S_J> how do I generate a value from the uniform distribution [0,1] ?
12:09:28 <napping> edwardk: should this be lazy? parallel?
12:09:43 <bss03> S_J: Are you fine with [0, 1) ?
12:09:55 <edwardk> :t randomR (0,1 :: Double) (mkStdGen 1)
12:09:56 <lambdabot> (Double, StdGen)
12:09:58 <bss03> @hoogle randomRIO
12:09:58 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
12:09:59 <edwardk> > randomR (0,1 :: Double) (mkStdGen 1)
12:10:01 <lambdabot>   (6.440633872506418e-2,545291967 2103410263)
12:10:22 <edwardk> > fst $ randomR (0,1 :: Double) (mkStdGen 1) -- chosen by fair die roll
12:10:22 <lambdabot>   6.440633872506418e-2
12:10:48 <monochrom> I thought 4 was the number chosen by fair die roll
12:11:00 <bss03> monochrom: 7, here.
12:11:09 <erisco> monochrom, it was rolled again to make it more random
12:11:50 <monochrom> 7 is beyond fair die. it's fairy die. :)
12:12:04 <danilo2> kqr1, merijn : Thanks - It works beautfully :)
12:12:51 <bss03> astar doesn't seem to be relevant and the grid isn't quite haxagonal: http://www.codecup.nl/rules_poly-y.php :(
12:12:57 <johnw> danilo2: :(
12:13:11 <johnw> first to answer, first to be forgotten
12:14:09 <merijn> johnw: In your face! :p
12:14:30 <monochrom> on the opposite side, Chinese Kungfu stories like to do this: two persons compete in die rolling, winning condition is getting the lowest number. first person rolls and gets 1. second person rolls so hard, and possibly with some Kungfu, that the die is powdered, it's a 0, win.
12:14:51 <johnw> curse this alacritous flesh
12:15:24 <danilo2> johnw: You've answered it faster than I asked for it :D But of course - thank you very much for your help! Indeed - you were first and after I got your answer I managed to solve the problem :)
12:22:10 <watermind> monochrom: yes I understand we can do that... I was thinking of ways to make abstraction simpler and less error prone
12:23:54 <SrPx> Hey guys I'm desperate for an incremental topological sorting lib again, anyone? http://www.reddit.com/r/haskell/comments/1lwguh/is_there_any_incremental_topological_sorting/
12:25:56 <jmcarthur> napping: alright, thanks. your help guided me to hereditary substitution, for which there is a goldmine of what i was looking for.
12:26:02 <aristid>  SrPx unlikely that it already exists, although you could search hackage. why not just implement the algorithms you found in those papers though?
12:26:22 <SrPx> aristid: because it is hard :/
12:26:30 <SrPx> as in, would take a lot of time
12:26:46 <SrPx> the simple is easy, I've just done it in another language. but it is not as fast
12:27:06 <aristid> SrPx: and are you sure sorting a mere 1000 elements 30 times per second is a big problem?
12:27:54 <aristid> hmm i guess topological sorting will be less efficient than regular sorting
12:28:19 <edwardk> napping: parallel would be good, but i'm mostly just looking for the generation of the vectors.
12:28:19 <SrPx> yes, a lot! at least it was the bottleneck of my game, making it unplayeble in slower machines. I changed it to incremental and not it is not the bottleneck anymore, it is the graphics engine. but still, if I'm going to port it to haskell it would be really sweet if I had the right lib to do it
12:28:36 <SrPx> aristid: eh it is necessary for the effect
12:28:42 <jmcarthur> SrPx: another way to get the same effect would be to just use a z buffer when rendering
12:30:10 <jmcarthur> SrPx: unless you need alpha translucency or other fancy blending i suppose
12:31:33 <SrPx> jmcarthur: hard to deretmine what z-index to attribute to each pixel of the sprite, though. i guess. not sure. but yea, i will try that
12:31:48 <mp> hi, how do I find (debug?) which function reads my lazy list?
12:32:04 <SrPx> jmcarthur: actually not quite. yea i guess that is the way to go. let me see
12:32:10 <jmcarthur> SrPx: a nice thing about the z buffer is it allows you to use shapes which with topological sort would require you to break into smaller pieces
12:32:32 <S_J> socketReadS: Less than the specified maximum number of bytes might be received at once. //// I thought pipes abstracted this annoying problem.
12:32:37 <SrPx> ok I guess this problem is solved
12:32:39 <SrPx> thamks
12:34:20 <SrPx> does anyone know about the state of art in haskell -> js translation? can it be almost as fast as js already?
12:34:21 <khyperia> is there a way to convert a Num to an Int? toInteger is the closest thing that I've found, but still way off track.
12:34:40 <SrPx> (i'm asking because the faq doesn't splicity say if those solutions are already practical)
12:35:01 <SrPx> explicit
12:35:10 <byorgey> SrPx: the state of the art consists of fay, ghcjs, and haste (in alphabetical order)
12:35:16 <td123> KyleCloud: 1 :: Int ?
12:35:24 <byorgey> they seem quite practical.  People use them.
12:36:00 <SrPx> byorgey: and in performance order? (:
12:36:47 <byorgey> SrPx: I have no idea.  And besides, comparing performance is pretty meaningless since they all support different subsets of Haskell, do different things well and poorly, etc.
12:37:36 <k00mi> KyleCloud: does it have to be any Num, or is Integral enough?
12:37:43 <k00mi> uh, khyperia I mean
12:38:02 <khyperia> Integral is probably fine.
12:38:08 <aristid> byorgey: i suppose ghcjs' subset of haskell is the most complete?
12:38:38 <k00mi> khyperia: fromIntegral, then
12:38:43 <khyperia> right
12:38:56 <donri> SrPx: probably you should bet on ghcjs at least in the long run. but i think it's also the most optimized right now, too. i think fay wins in some cases due to being stupid :P
12:39:14 <merijn> Right, I need some newbie and expert proof readers for an article I'm working on explaining IO
12:39:25 <S_J> socketReadS wants () as 3rd param, what is that?
12:39:58 <applicative> S_J: again, it will be gone tomorrow.
12:39:59 <merijn> Please don't reddit/whatever the link for now, as I plan to polish it and rehost on my own website once it's sufficiently done: https://gist.github.com/merijn/6478573
12:39:59 <donri> luite: was that the case?
12:40:19 <applicative> S_J: meanwhile the previous question is answered in the newer pipes-network
12:40:22 <merijn> (also, There's at least one section I haven't gotten around to writing)
12:40:59 <merijn> Any feedback on grammar/style/content is welcome
12:41:23 <applicative> S_J: see functions like this? https://github.com/k0001/pipes-network/blob/master/src/Pipes/Network/TCP.hs#L113
12:41:30 <elliott> merijn: you have seen the wiki Introduction to IO, right?
12:41:34 <elliott> (didn't read past the title :p)
12:41:59 <byorgey> aristid: yes, that's my understanding
12:42:17 <byorgey> in order of haskell subset completeness it goes  ghcjs > haste > fay
12:43:41 <aristid> i wasn't even aware of haste
12:43:43 <merijn> elliott: Yeah, but I wanted to work on a slightly more elaborate intuition, including making use of first class IO
12:43:47 <donri> ghcjs has historically been the hardest to install, but that's been improving a lot (but i don't know how complete this progress is)
12:43:52 <merijn> elliott: Although I haven't gotten around to that yet
12:43:54 <luite> donri: what case?
12:44:04 <luite> donri: the basic ghcjs patch has been merged in ghc 7.8
12:44:24 <donri> luite: that ghcjs wins most benchmarks and is the most optimized, but that fay wins in some cases due to being stupid :)
12:44:30 <k00mi> merijn: IO type *constructor*, if you want to be thorough
12:44:31 <luite> but not yet the hooks thing (we can do without, but then we'd have to copy/paste lots of ghc source into ghcjs)
12:44:41 <luite> donri: oh i did some comparisons where ghcjs won indeed
12:44:42 <merijn> elliott: The wiki intro is more focussed on a sort of quick start guide
12:44:57 <merijn> k00mi: That's correct, but also useless info :)
12:45:02 <S_J> pipes has made by life 200 times more difficult so far
12:45:10 <luite> donri: but fay currently converts direct tailcalls into loops, ghcjs doesn't do that yet, so fay would probably win there
12:45:12 <elliott> you could opt to not use pipes.
12:45:17 <merijn> k00mi: Knowing that it's a type constructor doesn't tell you much about what it is :)
12:45:19 <S_J> is there a new version coming out tomorrow for real and is it easier to use?
12:45:27 <luite> fay also wins in code size since the non-concurrent ghcjs runtime is not ready yet
12:45:28 <S_J> because I dont see the charm of it so far
12:45:31 <khyperia> I'm very dumb and not understanding of types... but is there a "Integral a => Int -> a" function? (opposite of my earlier question)
12:45:40 <jmcarthur> merijn: "Haskell's IO type (note: type, not IO
12:45:42 <luite> khyperia: fromIntegral
12:45:43 <johnw> S_J: you may find conduit a bit simpler
12:45:45 <jmcarthur> gah copied a newline
12:45:55 <khyperia> oh god I'm an idiot
12:45:58 * hackagebot hexpat-lens 0.0.3 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.0.3 (JosephAbrahamson)
12:45:58 <k0001> S_J: Yes, it's going out tomorrow. The “charm” is that it is compatible with pipes-4.0.0 :)
12:46:32 <applicative> oh k0001 is here; tell S_J not to use the old pipes-network
12:46:37 <luite> donri: also i redid the base libs installation prodedure so it's a lot simpler :)
12:46:39 <jmcarthur> merijn: "Haskell's IO type (note: type, not IO monad!)"... if you want to be pedantic, IO is really a type constructor. some colloquially call type constructors types, but then again, some colloquially call IO a monad
12:46:58 <merijn> jmcarthur: I'm not referring to the type constructor, though
12:46:59 <tel> merijn, I don't like the personification of GHC… I'm guilty of it myself sometimes, but it really sets up the idea of "fighting" with the compiler instead of working with it :s
12:47:03 <k00mi> merijn: sure, neither does saying it's a type (and that's not even true!)
12:47:04 <edwardk> tel++ hexpat-lens
12:47:08 <merijn> jmcarthur: I'm referring to "IO a"
12:47:18 <merijn> tel: Which personification of GHC?
12:47:20 <donri> luite: cool. bbl dinner :) anyway it was SrPx who was asking about hs->js and performance
12:47:25 <tel> edwardk modeled on lens-aeson :D
12:47:25 <applicative> aw johnw, pipes-4 is *so* much simpler than that layer cake conduit stuff ;)
12:47:26 <jmcarthur> merijn: ah, then i would talk about an (IO a) rather than an (IO)
12:47:40 <tel> merjin "GHC's subtle way" "it's mad at you"
12:47:53 <johnw> applicative: it really didn't look that way to me reading the mailing list posts
12:47:53 <merijn> tel: Ah
12:48:01 <johnw> upstream operators, downstream operators, etc.
12:48:14 <merijn> tel: "GHC's helpful attempt at informing you, you dun goofed" ;)
12:48:19 <luite> SrPx: oh, in most cases plain JS will be faster still, since haskell relies a lot of immutable data, doing much more allocation than JS
12:48:20 <tel> merijn, haha
12:48:21 <applicative> john, all gone.
12:48:33 <luite> SrPx: and JS engines aren't tuned for very fast allocation of lots of mem
12:48:40 <k0001> S_J: Tomorrow, new versions the following packages will be released together: pipes, pipes-safe, pipes-concurrency, pipes-parse, pipes-network, pipes-binary, pipes-zlib and pipes-attoparsec. If you are starting something today, prefer to use whatever is on my GitHub or Gabriel439's :)
12:48:45 <applicative> johnw: all gone ... until you open the forbidden modules
12:48:45 <merijn> k00mi: I disagree, with the notion that IO is not a type
12:49:11 <tel> merijn, I keep trying to write that kind of stuff like "GHC is too stupid to see the logic of your ways" but… that's pretty patronizing
12:49:13 <luite> SrPx: but you can write some of your code in JS, directly in a foreign import if needed, with GHCJS
12:49:14 <jmcarthur> you mean to address me?
12:49:20 <applicative> IO as program fragments?
12:49:40 <merijn> applicative: The title/section tiles suck
12:49:41 <k00mi> merijn: if we talk about IO :: * -> *, then you're wrong
12:49:42 <applicative> where by a program we mean something like a text
12:49:48 <luite> SrPx: and some code (where GHC unboxes things) will already be pretty fast
12:49:50 <haasn> writing TH code is always such dense work, it ends up taking an hour to produce a few lines
12:49:56 <haasn> do I just suck at TH?
12:49:56 <tel> merijn, many people reject purity because they feel their programs have internal logic and it's more of a communication breakdown with GHC, I feel
12:50:00 <merijn> applicative: I figured I best just start writing instead of obsessing over tiles for years
12:50:23 <merijn> applicative: I can obsess over those after actually finishing a basic draft :p
12:50:38 <merijn> k00mi: In what sense?
12:50:42 <jmcarthur> merijn: i will grant that calling things of kind (* -> *) is not totally uncommon. this also probably isn't the place to argue about that, since it's not the point you are trying to make in the tutorial anyway. however, since some people will nonetheless be taught that IO is not a type, i think those people will find your language confusing
12:50:58 * hackagebot gnutls 0.1.5 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.1.5 (JohnMillikin)
12:51:04 <jmcarthur> *i will grant that calling things of kind (* -> *) a type is not totally uncommon
12:51:12 <tel> merijn, but I like the conversational mode
12:51:20 <merijn> jmcarthur: Yeah, I'll rework it, because apparently everyone has already complained about it ;)
12:51:36 <merijn> tel: That's because I prefer lecturing on IRC to writing prose :)
12:51:50 <merijn> So I figured I'd just roll with it
12:52:07 <k00mi> merijn: what jmcarthur said, something of kind * is a type, * -> * is not
12:52:21 <applicative> merijn: there was an elaborate post some years ago saying the occupants of IO x were 'little C programs' that get glued together by >>= etc
12:52:23 <Ralith> that is my understanding as well
12:52:40 <tel> merijn, there's a lot of space there to sort of inchworm someone's logic toward better notions of IO/purity, so I think it's not a bad mode
12:53:20 <merijn> applicative: There also was reverse post proving that C was a purely functional language ;)
12:53:39 <tel> jmcarthur merijn: maybe take some tricks from roconnor's IO-is-not-a-monad post?
12:54:37 <tel> http://r6.ca/blog/20110520T220201Z.html
12:54:49 <simon> @pl \(x,y) -> x * 10 + y
12:54:52 <lambdabot> ap (((+) . (* 10)) . fst) snd
12:54:52 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:08 <simon> @pl-resume
12:55:14 <lambdabot> ap (((+) . (* 10)) . fst) snd
12:55:14 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:16 <applicative> but thats just more nonsense, roconnor's post.  it delays the real problem by turning IO into a type that needs an interpreter run on it.
12:55:32 <td123> I am trying to write a test for a function https://github.com/gostrc/hs-spotify/commit/4390a5b56f2f097f201a105050c16bf145d7f611 but when I run cabal test, I get module Bindings.Spotify.Toplist does not export sp_toplist_region
12:55:40 <td123> I'm kind of stumped
12:55:49 <merijn> tel: Yeah, that post is interesting in its own way, but not in a "how do I quickly get an intuition for IO" way :)
12:56:25 <jmcarthur> i also agree that roconnor's approach is not the kind that will resonate with beginners
12:56:27 <tel> merijn, yeah, I don't think it applies directly, but some of the logic is useful for sidestepping the monad/IO-as-a-type parts
12:56:56 <jmcarthur> you mean talking about I/O instead of IO?
12:56:57 <merijn> tel: Which I also find lacking in the wiki bit by Cale. This text so far is mostly a slightly more elaborate rephrasing of the wiki, but I'm also working on some stuff on first class IO to show how we can do neat things you'd normally need Lisp macro's for using first class IO
12:57:11 <applicative> these tutorials are a disaster.  i recommend reading Peyton Jones instead
12:57:21 <merijn> jmcarthur: Yeah, I think inserting a / at the beginning will help :)
12:57:37 <tel> merijn ifM :)
12:57:43 <tel> .. or really just if
12:57:44 <merijn> applicative: What in particular do you object to in my text?
12:57:51 <merijn> tel: I was gonna go with if or &&, yes
12:58:10 <applicative> im thinking of roconnor at the moment: "IO is kind of like RWS () [Instruction Register] Location a"
12:58:44 <tel> applicative hah, I don't think I prefaced roconnor's post well. It's not a good beginner tutorial
12:58:47 <merijn> applicative: Sure, but roconnor's post is not meant to be a newbie post
12:59:15 <merijn> applicative: He wrote it by request from Conal, who is interested in denotational semantics
12:59:17 <tel> applicative but I think it's good to separate out "monad" from "sequence of operations"
12:59:18 <applicative> my objection is that its worse than false
12:59:27 <merijn> applicative: And the question whether IO is a monad is an open question
12:59:44 <S_J> how can I generate a list of 100 IO Ints?
12:59:55 <tel> S_J map return [1..100]
12:59:59 <S_J> uniform01 :: IO Int, how can i get a 100 of it?
13:00:11 <merijn> :t replicateM
13:00:12 <lambdabot> Monad m => Int -> m a -> m [a]
13:00:13 <tel> S_J ah, replicateM 100 uniform01
13:00:44 <merijn> applicative: Not all posts have to be written for newbies :)
13:02:22 <applicative> if all questions are put onto an interpreter function or even a so-called 'run time system', absolutely nothing is explained
13:02:34 <merijn> applicative: He's not trying to explain
13:02:47 <merijn> applicative: Or rather, he is, but a different question :)
13:03:12 <merijn> applicative: i.e. the question "is IO a monad?" not "what is IO?" or "how does IO work?" or "how should I think about IO?"
13:05:58 * hackagebot Twofish 0.3.2 - An implementation of the Twofish Symmetric-key cipher.  http://hackage.haskell.org/package/Twofish-0.3.2 (RonLeisti)
13:06:00 * hackagebot here 1.2.2 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.2 (TaylorHedberg)
13:06:09 <inkjetunito> haskell seems to fill the gap very well. i first tried filling it with common lisp, but it was missing the wheel
13:06:36 <applicative> i have read this many times; my conviction, which I wont press at the moment, is that it is poison
13:10:06 <khyperia> .... okay. Wow. Haskell noob here, I just spent three hours coding a thing, ran it for the first time just now, worked 100% no bugs.
13:11:07 <applicative> khyperia: you are going far beyond our usual advertising slogans ;)
13:11:49 <applicative> these aren't "the very first thing you write workds" but "when you write it once and it works" or something like that
13:12:06 <khyperia> I know it's commonly said bugs in functional are hard to make, but... wow. It's something different to actually experience it.
13:12:28 <erisco> okay maybe I am just not as fortunate
13:13:11 <applicative> khyperia: but dont you feel like you need a stiff drink after dealing with horrible typechecker thingy or whatever they call it?
13:13:36 <khyperia> ... what?
13:14:16 <applicative> just kidding
13:14:19 <h4199> I think he nailed all his types too, right khyperia?
13:14:32 <khyperia> ... right?
13:14:39 <khyperia> Sure. Let's go with sure.
13:15:10 <h4199> did everything compile the first time you tried?
13:15:16 <khyperia> yep
13:15:52 <khyperia> then again, I'm using eclipsefp, which gives pre-compile errors.
13:16:54 <applicative> ow wow
13:17:26 * applicative thinks, no *way* i'm learning eclipsefp though
13:17:46 <S_J> is there a function split :: Int -> [a] -> [[a]] that splits a lists every X elements?
13:17:51 <hrefchef> So, I'm having some trouble with a haywire library I made. Parts of it cannot see other parts. I drew the directory structure here with the error codes I get: http://i.imgur.com/pBWW0Nh.png
13:18:07 <h4199> Data.List.Split
13:18:18 <erisco> S_J, http://www.haskell.org/hoogle/?hoogle=Int+-%3E+%5Ba%5D+-%3E+%5B%5Ba%5D%5D
13:18:34 <applicative> boy is that a confusing image hrefchef
13:18:37 <hrefchef> Does anyone know why some source files aren't available to others? I can't figure it out. Files in the "Cannot find" directories work, while other files in the same dir don't work.
13:18:59 <hrefchef> applicative: If you'd rather look at the actual directory, I have it here: https://www.dropbox.com/s/9bx3a04zhq2xeh9/Mirror.tar.gz
13:19:04 <erisco> S_J, does not look to be
13:19:09 <hrefchef> Trying to compile the "Mirror.hs" source file.
13:19:30 <h4199> S_J http://hackage.haskell.org/packages/archive/split/0.2.2/doc/html/Data-List-Split.html "chunksOf"
13:19:31 <applicative> is Mirror.hs inside the Cookbook directory?
13:19:40 <hrefchef> applicative: It's not.
13:19:44 <applicative> sorry forget that
13:19:46 <erisco> :t chunksOf
13:19:46 <hrefchef> One level above it.
13:19:47 <lambdabot> Int -> [e] -> [[e]]
13:19:57 <erisco> on Hoogle it says Int -> Text -> [Text]
13:20:32 <erisco> > chunksOf 2 [1..10]
13:20:34 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:20:37 <applicative> hrefchef: have you considered running cabal init and having done with using ghc directly for make - ing
13:20:37 <erisco> mm okay
13:20:57 <threestrikes> splitAt :: Int -> [a] -> ([a], [a]) -- can this be changed to split an element at a character?
13:21:22 <hrefchef> applicative: I haven't ever used Cabal, but I could look into it. For a library like this a cabal packge is a good idea.
13:21:33 <erisco> threestrikes, (takeWhile etc, dropWhile etc)
13:21:39 <hrefchef> As a beginner I was afraid cabal would screw this up worse than it is.
13:22:05 <applicative> hrefchef: do the modules have the proper names internally? does Cookbook/Ingredients/Lists/Modify.hs call itself Cookbook.Ingredients.Lists.Modify internally?
13:22:27 <h4199> threestrikes, have you looked a break?
13:22:35 <h4199> :t break
13:22:35 <erisco> http://www.haskell.org/hoogle/?hoogle=%28a+-%3E+bool%29+-%3E+%5Ba%5D+-%3E+%28%5Ba%5D%2C%5Ba%5D%29
13:22:36 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:22:45 <threestrikes> h4199: no I havn't
13:22:49 <hrefchef> applicative: All do, yeah. It used to work from within ghc as well. It's just when a file include it that problems come up.
13:22:50 <erisco> > break (=='a') "haylo world"
13:22:51 <lambdabot>   ("h","aylo world")
13:23:00 <erisco> > span (=='a') "haylo world"
13:23:00 <joelteon> :t breakChar
13:23:01 <lambdabot> Not in scope: `breakChar'
13:23:01 <lambdabot>   ("","haylo world")
13:23:03 <threestrikes> @hoogle break
13:23:03 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
13:23:04 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
13:23:04 <lambdabot> Data.ByteString.Char8 break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
13:23:12 <erisco> > partition (=='a') "haylo world"
13:23:13 <lambdabot>   ("a","hylo world")
13:23:37 <hrefchef> I am going to make a cabal package and come back if it doesn't get fixed.
13:23:44 <erisco> letmehooglethatforyou.org where is this? :)
13:23:50 <erisco> need to raise awareness
13:24:37 <applicative> hrefchef: maybe it's obvious what wrong, but its hard without the directories. If you do cabal init, and try to specify 'executable Mirror' or something, you might find out something...
13:24:41 <geekosaur> please don't. lmgtfy is horribly condescending
13:25:05 <johnw> geekosaur++
13:25:15 <erisco> what?
13:25:26 <erisco> did not realize it was offensive
13:25:31 <elliott> did you know lambdabot has a lmgtfy command? I made a sad face when I discovered it.
13:25:59 * hackagebot currency 0.1.0.0 - Types representing standard and non-standard currencies  http://hackage.haskell.org/package/currency-0.1.0.0 (StephenWeber)
13:26:30 <h4199> threestrikes: you might also want to look at splitWhen
13:26:35 <h4199> > splitWhen (<0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]
13:26:36 <lambdabot>   True
13:26:41 <applicative> i think erisco meant really that hoogle should be better known
13:27:21 <applicative> certainly the jazzy https://www.fpcomplete.com/hoogle should be better known
13:27:32 <threestrikes> @hoogle splitWhen
13:27:32 <lambdabot> No results found
13:28:05 <h4199> http://hackage.haskell.org/packages/archive/split/0.2.2/doc/html/Data-List-Split.html , third function down
13:28:11 <sm> nice, I'm glad fpcomplete is working on hoogle
13:28:14 <sm> johnw++
13:28:44 <applicative> its so much better now
13:28:46 <johnw> \o/
13:29:10 <applicative> johnw: on the other hand ...
13:29:20 <applicative> ... that may not be saying much.
13:29:30 <applicative> so i'll say, it's WAY WAY better
13:30:32 <mgccl> I have a list Ord a=>[a], I want to apply a function f only to the maximum of this list. any clever approaches? I'm thinking of zipping this list with the index, and maximum result the index, then I apply f to only that index.
13:30:49 <erisco> :t max
13:30:50 <lambdabot> Ord a => a -> a -> a
13:31:07 <erisco> > foldr max 0 [1..10]
13:31:08 <lambdabot>   10
13:31:20 <johnw> i've actually done a bit of work to move Hoogle's database into SQLite, if anyone is interested in taking that over; doesn't look like we're going to be using it for a while
13:31:33 <erisco> mgccl, is that along the lines of what you want?
13:32:05 <applicative> mgccl erisco, doesn't he want to find the maximum and change it at the same time?
13:32:08 <h4199> erisco: he wants to apply f to the max, while keeping the list intact
13:32:30 <mgccl> erisco: h4199 got it.
13:32:53 <johnw> that might actually be a correct use of the Tardis monad
13:33:03 <applicative> @type maxView
13:33:04 <lambdabot>     Not in scope: `maxView'
13:33:04 <lambdabot>     Perhaps you meant one of these:
13:33:04 <lambdabot>       `IM.maxView' (imported from Data.IntMap),
13:33:06 <johnw> since you need to apply an action in the "past" based on a result from the "future"
13:33:10 <applicative> @type Set.maxView
13:33:10 <lambdabot> Couldn't find qualified module.
13:33:14 <applicative> bah.
13:33:46 <erisco> mgccl, replace the updated element with a map
13:34:06 <merijn> johnw: Does that mean I will have a way to merge my local Hoogle databases and not run out of memory while doing so? :>
13:34:17 <mgccl> johnw: woah... mind blown...
13:34:19 <johnw> merijn: i already have a way for you to do that
13:34:22 <johnw> merijn: cabal install rehoo
13:34:27 <applicative> mgccl: if you had a Set not a list, maxView myset would return Just (themaximum, therest) so it would just be a question of insert (f themaximum) therest
13:34:35 <johnw> cd to your hoogle/databases directory
13:34:39 <johnw> run: rehoo -j4 -c64 .
13:35:25 <mgccl> erisco: ahh that works.
13:35:56 <erisco> mgccl, it is kind of painfully inefficient but, alas, these are immutable lists
13:36:21 <merijn> johnw: You told me about that before, that still crashed for me last time
13:36:30 <johnw> hmm
13:36:30 <merijn> johnw: Even with really small settings
13:36:36 <mgccl> applicative: i see, I could also write a maxView for lists, (begin, themax, rest)...
13:36:40 <johnw> oh yeah, i kind of remember that
13:37:01 <h4199> mgccl: is the maximum unique? If not how did you want to handle that?
13:37:40 <erisco> > let { l = [4,3,2,5,4,6,4,3]; sl = sort l; f = (+100); } in f (head sl) : tail sl
13:37:41 <lambdabot>   [102,3,3,4,4,4,5,6]
13:37:41 <applicative> mgccl: i cant see how to manage this in one pass.
13:37:52 <erisco> mgccl, something like that too, if you can change ordering
13:41:02 <mgccl> applicative: 1 pass might be possible... I will return when I figure that out...
13:42:24 <applicative> > let rectify f xs = let mx = maximum xs ; g x = if x == mx then f x else x in map g xs in rectify (+1) [2,3,5,5,1] -- is disgusting
13:42:25 <lambdabot>   [2,3,6,6,1]
13:43:12 <erisco> mgccl, you do not know until the end of the list what the maximum is. at that point, it is too late to pluck it out without another pass
13:44:39 <erisco> mgccl, unless you always pluck out what is currently the highest value
13:45:00 <erisco> which will reorder your list... so if that is alright, then perhaps :) the mapped element will be tail inserted
13:45:34 <lions> part
13:48:29 <khyperia> What about this: Do a recursive expansion on the list, keeping track of the maximum as you go through it. Then, when you're unwinding, if the current value equals the maximum (which you return from the recursive call), apply f to it.
13:48:33 <k0001> I feel guilty running `rm -rf cabal-dev; cabal sandbox init` everyehere. cabal-dev has made my life so much pleasant until now! But I guess its time has come...
13:49:37 <applicative> k0001: have you found some major things missing yet? i never used cabal-dev
13:49:50 <applicative> for more than a few minutes
13:51:15 <threestrikes> is it possible to go from FilePath to String and back again?
13:51:20 <applicative> the trouble with cabal sandbox init is that i now have 10 completely compiled copies of le monde eduard kmett on my system
13:51:28 <applicative> threestrikes: couldn't be easier ;)
13:51:32 <applicative> id
13:51:39 <applicative> and to go back, id
13:51:41 <h4199> :t FilePath
13:51:42 <lambdabot> Not in scope: data constructor `FilePath'
13:51:48 <h4199> :t Filepath
13:51:49 <lambdabot> Not in scope: data constructor `Filepath'
13:51:52 <h4199> gah
13:51:53 <applicative> threestrikes: do :i Filepath in ghci
13:52:01 <geekosaur> @src FilePath
13:52:01 <lambdabot> type FilePath = String
13:52:01 <applicative> @info FilePath
13:52:01 <lambdabot> FilePath
13:52:10 <applicative> ah there we are
13:52:14 <erisco> mgccl, wanna see my answer?
13:52:20 <applicative> geekosaur++ as usual
13:52:58 <S_J> why do I get [(),()...] when i do mapM print xs ?
13:53:16 <h4199> :t print
13:53:16 <applicative> threestrikes: there are other FilePathlike types around, but the usual one is just another name for String.
13:53:17 <lambdabot> Show a => a -> IO ()
13:53:20 <threestrikes> @src getDirectoryContents
13:53:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:53:26 <Clint> :t mapM print
13:53:26 <geekosaur> because mapM gives you the result, which in this case you don;t care about. try mapM_
13:53:27 <lambdabot> Show a => [a] -> IO [()]
13:53:33 <h4199> S_J because it returns
13:53:36 <h4199> ()
13:53:41 <threestrikes> ic
13:53:55 <h4199> if you don't care about the contents you can just use mapM_
13:54:04 <h4199> :t mapM_
13:54:05 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
13:54:10 <threestrikes> @hoogle getDirectoryContents
13:54:10 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
13:54:33 <mgccl> erisco: okey. I was just typing up a one pass version of the maximum thing.
13:54:43 <applicative> > let goo :: FilePath -> FilePath ; goo = reverse in goo "hello"
13:54:44 <lambdabot>   "olleh"
13:54:46 <erisco> mgccl, yeah that is what I made too
13:54:58 <geekosaur> even if @src had getDirectoryContents it wouldn;t be very enlightening since it's just a wrapper around FFI calls to the dirent functions
13:55:01 <mgccl> erisco: http://lpaste.net/92714
13:55:12 <geekosaur> (on posixlikes at least)
13:55:41 <erisco> mgccl, http://lpaste.net/92715
13:57:37 <td123> found out the problem
13:57:43 <td123> cabal does not run hsc2hs
13:57:46 <td123> doh
13:57:50 <k0001> applicative: not really. I mean, I'm not a `cabal-dev` expert; all I did was `cabal-dev {configure,build,install,install-deps}`, and then I used it together with `cabal-meta` when I needed to install unreleased versions of some dependencies (`cabal-meta --dev install`), and that's all. So far, cabal sandboxes solve all those problems for me.
13:58:40 <mgccl> erisco: I see, so if order doesn't matter than this works well.
13:58:46 <johnw> mgccl: https://gist.github.com/6479230
13:59:00 <erisco> mgccl, well there isn't anything else you can do for a one pass
13:59:10 <erisco> mgccl, for the reason I said
13:59:13 <DigitalKiwi> td123: for shame
13:59:40 <td123> oh hey DK, didn't know you hung out in #hs
13:59:45 <johnw> that is single pass
14:00:06 <johnw> you don't even need Tardis for that, just the reversed state monad
14:00:21 <jkoppel> "cabal haddock --executables" keeps failing with "haddock: failed to parse haddock prologue from file: dist/doc/html/myprogram/myprogram/haddock-prolog84346.txt"
14:00:24 <DigitalKiwi> td123: someday I may even learn :)
14:00:41 <erisco> johnw, I am unconvinced... how does it operate?
14:00:43 <jkoppel> Why might it be doing that?
14:01:16 <johnw> erisco: it uses the stack as a virtual list, which as it collapses back down, carries the maximum value back through all the previous iterations
14:01:21 <johnw> so I think effectively it's two-pass
14:01:34 <merijn> Why do I always cut myself on the bleeding edge :(
14:01:35 <johnw> one through the list on the heap, and one through this virtual list on the stack
14:01:51 <johnw> but you get to write the code as if it was one pass, and in fact the code can only *observe* a single pass
14:02:05 <erisco> two passes is two passes =\
14:02:07 <mgccl> maybe we can define "effective one pass" if this code use O(1) extra memory.
14:02:20 <johnw> erisco: operationally, yes
14:02:24 <erisco> well
14:02:33 <johnw> the nice thing about using the reversed state monad here is that the code itself cannot take advantage of two passes
14:02:49 <johnw> you get to restrict what the code can do to exactly what you mean
14:02:56 <merijn> johnw: That seems inefficient, you can do the thing in a single pass
14:02:58 <erisco> granted, but I'm not sure what was the effect mgccl was after ... an interesting idea though
14:03:12 <johnw> merijn: how?
14:03:31 <merijn> oh, hmm, maybe you're right
14:03:54 <merijn> Because'd you need to compare against the result to see if you're currently at the place to update
14:03:59 <johnw> right
14:04:11 <johnw> the best you can do is to maintain an index for the largest thing you've seen so far, and then use (!!)
14:04:15 <applicative> did mgccl 's other function work, apart from glaring nontotality; I didnt notice the critique
14:04:18 <erisco> mgccl, if you reverse, that is a pass over the list
14:04:21 <johnw> at least then the second pass doesn't always need to go all the way to the end
14:04:25 <merijn> gah, I fixed pandoc to do what I want, only to run into Hakyll not supporting the newest pandoc version :(
14:04:51 <johnw> let me benchmark this tardis version against naive two-pass
14:05:14 <mgccl> erisco: yes, I'm now convinced there is no way to get over the 2 pass...
14:05:55 <erisco> mgccl, not for arbitrary list lengths. there is of course an algorithm for fixed lengths
14:06:08 <khyperia> but there is a way to have the second pass be "as you're coming back up from the end of the list"
14:07:28 <erisco> and if you can give up order preservation... well hey :)
14:10:05 <johnw> ok, the tardis version is crazy faster
14:10:10 <johnw> 7us vs. 418us
14:10:17 <johnw> oh, wait
14:10:20 <johnw> 7us vs. 418ns
14:10:22 <johnw> not faster
14:10:26 <johnw> crazy slower
14:10:36 <johnw> like 20x slower
14:10:47 <johnw> trying with -O2
14:10:56 <johnw> same
14:11:00 * hackagebot currency 0.2.0.0 - Types representing standard and non-standard currencies  http://hackage.haskell.org/package/currency-0.2.0.0 (StephenWeber)
14:11:29 <erisco> johnw, what about the one pass? :)
14:11:36 <johnw> where was that code?
14:11:40 <erisco> http://lpaste.net/92715
14:11:49 <erisco> we can see if giving up order is a worthwhile tradeoff
14:12:39 <johnw> tardis 4.7us naive 267ns mapmax 167ns
14:13:07 <erisco> what is naive? does it use !!?
14:13:11 <johnw> btw, my naive is: let x = maximum xs in map (\y -> if y == x then f y else y) xs
14:13:21 <erisco> ah
14:13:22 <johnw> since tardis also applies the function to equal maximum members
14:14:00 <erisco> so the one pass saves you the time of a cache miss roughly
14:14:13 <erisco> not a huge win
14:14:57 <johnw> oh well, that's a bummer that tardis is so much slower :(
14:15:10 <johnw> back to work
14:15:15 <erisco> I suppose ghc couldn't grind through its abstractions?
14:15:33 <monochrom> wait, tardis can afford to be slower because it can always go back in time
14:16:25 <johnw> erisco: it piles on the lambdas, unfortunately, and in this case I don't think it can elide them
14:16:32 <monochrom> also, latest Cartesian Closed Comics: http://ro-che.info/ccc/21.html
14:17:51 <johnw> heh
14:24:07 <donri> say once that happens though, would it break anything to say sequence = sequenceA using the Applicative constraint?
14:24:56 <donri> i sort of wish lift was called fmap and we could have lift2 = liftA2 etc
14:25:07 <donri> uh, fmap was called lift
14:27:09 <erisco> can you create a circular reference in Haskell?
14:27:36 <erisco> seems like any attempt would just result in a copy where the circle would normally close
14:27:40 <monochrom> yes. like this? x = 0:x
14:28:00 <S_J> so you can use record syntax to get getters. what about setters?
14:28:03 <bss03> cycle l = l : cycle l
14:28:05 <bss03> @src cycle
14:28:05 <lambdabot> cycle [] = undefined
14:28:06 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:28:20 <pavonia> see also http://www.haskell.org/haskellwiki/Tying_the_Knot
14:28:21 <geekosaur> also see http://www.haskell.org/haskellwiki/Tying_the_Knot
14:28:22 <donri> S_J: you get record update syntax, but that's it
14:28:23 <geekosaur> heh
14:28:24 <erisco> S_J, records are immutable... but for instance you can do      myrecord { myField = newValue }
14:28:29 <bss03> S_J you can use record update syntax.
14:29:11 <monochrom> circular binary tree (assume suitable data declaration): t = Branch t t  (it's t's all the way down)
14:30:15 <erisco> monochrom, across scopes though?
14:30:17 <bss03> Infitie Rose Tree, very Knotty: t = cycle [t]
14:30:24 <donri> @src repeat
14:30:25 <lambdabot> repeat x = xs where xs = x : xs
14:30:33 <donri> might've been what you wanted, bss03
14:30:33 <monochrom> what is "across scope"?
14:31:00 * hackagebot data-fresh 0.2013.250.1 - Interface and functor transformers for fresh values  http://hackage.haskell.org/package/data-fresh-0.2013.250.1 (StijnVanDrongelen)
14:31:17 <monochrom> better yet, what is the actual concrete thing you want?
14:32:28 <DigitalKiwi> monochrom: http://ro-che.info/ccc/13.html hahaha
14:32:57 <monochrom> yeah, CCC is fun
14:40:39 <DigitalKiwi> 03 was funny I like the halting problem
14:46:55 <Zenol> http://ro-che.info/ccc/21.html haha this one is really funny :)
14:48:40 <Rc43> Hi, guys.
14:48:48 <Rc43> Can anybody look my question? http://stackoverflow.com/questions/18678197/haskell-ghc-cps-and-performace-time
14:49:02 <Rc43> (Please answer on SO, not here.)
14:50:37 <pavonia> What is CPS?
14:50:54 <DigitalKiwi> child protective services
14:51:06 <geekosaur> continuation passing style?
14:51:10 <Zenol> continuation passing style.
14:51:11 <bss03> Continuation Passing Style
14:51:27 <Taneb> continuation passing Style!
14:51:48 <donri> collaborative pseudonym studies
14:51:50 <DigitalKiwi> not on first page of google == doesn't exist
14:53:15 <monochrom> donri wins :)
14:53:22 <Rc43> DigitalKiwi, I think it is because of google's user customizations. I have CPS on the first page (think because I often enter FP queries).
14:53:51 <Rc43> DigitalKiwi, (I mean continuation pasing style meaning of CPS)
14:54:16 <DigitalKiwi> so you're saying I have child protective services on first page because I abuse my children!? D:
14:54:46 <ski> Clockmaker Pressor Stockfish
14:55:32 <monochrom> I am not convinced that tail recursion and avoiding stack etc etc are efficiency measures.
14:55:46 <Rc43> DigitalKiwi, :D
14:55:50 <monochrom> "avoiding stack" = "blowing heap"
14:56:33 <tabemann> the reason to avoid the stack is because generally you have far more heap than you have stack available
14:56:41 <Rc43> monochrom, doesn't tail recursion use stack instead of heap? Why are you talking about avoiding stack then?
14:57:00 <monochrom> no
14:57:04 <Rc43> monochrom, aaah, you mean stack frames replacement
14:57:13 <tabemann> and as for tail recursion, I have to disagree (even though laziness in Haskell often obviates tail recursion)
14:58:11 <Saizan> there are lot of variables to consider in a lazy language, the only general answer is "it depends"
14:58:31 <Saizan> also in ghc the stack is really only artifically limited
14:59:03 <monochrom> we are recently starting to talk about raising or removing the stack limit, because it has been set artificially low
14:59:19 <Saizan> but tail recursion is still nice when you'd be strict on the result of the recursive call anyway, otherwise it can make things slower
14:59:37 <monochrom> (a program that uses 8M stack and 800M heap is not more efficient than a program that uses 800M stack and 8M heap)
14:59:41 <Saizan> (infinitely slower sometimes)
15:00:31 <monochrom> as for tail recursions, some tail recursions give you O(1)-space algorithms, counting both stack and heap. if you can do that, that is cool, I have no complaint.
15:00:43 <ski> tail recursion is sometimes useful for encoding an algorithm as an iterative process
15:00:55 <ski> there can also be other ways of achieving this
15:01:01 * hackagebot openexchangerates 0.1.0.0 - Fetch exchange rates from OpenExchangeRates.org  http://hackage.haskell.org/package/openexchangerates-0.1.0.0 (StephenWeber)
15:01:06 <monochrom> but some other tail recursions, notably CPS techniques, merely change O(n)-stack to O(n)-heap. I question you what have you saved.
15:01:14 <ski> indeed
15:02:04 <jmcarthur> apart from stack overflows, of course, when your runtime artificially limits you
15:02:07 <ski> (so in those cases you'd not get an iterative process, even though using tail recurtsion)
15:02:20 <ski> (s/recurtsion/recursion/)
15:02:33 <Saizan> yeah, CPS can still boost performance, but in other ways
15:02:35 <monochrom> use +RTS -K800M -M8M -RTS to obtain heap overflow faster
15:02:39 * ski nods
15:03:01 <ski> (e.g. you can encode semi-tail-calls via CPS)
15:03:11 <red_> what is the best way to get two numbers out of the following string "33 22" ?
15:03:29 <monochrom> see also http://ghc.haskell.org/trac/ghc/ticket/8189
15:03:55 <Saizan> > map read . words $ "33 22" :: [Int]
15:03:56 <lambdabot>   [33,22]
15:04:18 <Saizan> that's going to fail horribly if the string is malformed though
15:04:25 <Saizan> > map read . words $ "3z 22" :: [Int]
15:04:25 <red_> i know it's not 'type conversion' but is it bad practice to use ::[Int] within a fcn?
15:04:26 <lambdabot>   [*Exception: Prelude.read: no parse
15:04:27 <monochrom> and my message http://www.haskell.org/pipermail/haskell-cafe/2013-August/108580.html
15:04:48 <Rc43> Saizan, how does it boost performance?
15:04:56 <Saizan> red_: nope, sometimes you just need it
15:05:06 <red_> k thanks
15:05:17 <ski> > do let {s0 = "33 22"}; (m,s1) <- (reads :: ReadS Int) s0; (n,s2) <- (reads :: ReadS Int) s1; return ((m,n),s2)
15:05:18 <lambdabot>   [((33,22),"")]
15:05:56 <Saizan> Rc43: for example it can help reassociating uses of (>>=) to the right, which helps a lot for free monads
15:06:22 <ski> > replicateM 2 (StateT (reads :: ReadS Int)) `runStateT` "33 22"
15:06:23 <lambdabot>   [([33,22],"")]
15:06:40 <ski> red_ : is one alternative
15:07:20 <monochrom> CPS or codensity really reduces costs of free monads. in some cases from O(n^2) to O(n). that is a good use.
15:07:26 <red_> ski: state monad is not my friend yet
15:07:55 <ski> red_ : using type ascriptions are not bad practice. sometimes the context isn't enough to determine what some intermediate type should be, so a type ascription can tell the system what you intended
15:08:27 <ski> red_ : note that those are not "casts" nor "coercions"; you can't use them to assign a type to an expression that the system wouldn't have allowed anyway
15:08:38 <ski> red_ : ok, so read the list monad version (first one)
15:09:01 <ski> `reads' returns a list of possible parses (in most cases, there's either one parse, or no parse (so parse error))
15:10:12 <red_> readS is a context for Int, where is it defined? what is it?
15:10:34 <ski> (if you prefer, you can rewrite the former version as a list comprehension)
15:10:55 <ski> `readS' is one thing (a function). `ReadS' is another thing (a type)
15:11:06 <ski> @type readS
15:11:07 <lambdabot>     Not in scope: `readS'
15:11:07 <lambdabot>     Perhaps you meant one of these:
15:11:07 <lambdabot>       `read' (imported from Prelude), `reads' (imported from Prelude)
15:11:07 <bss03> @hoogle ReadS
15:11:07 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
15:11:07 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
15:11:09 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
15:11:11 <ski> er
15:11:12 <ski> @type reads
15:11:13 <lambdabot> Read a => ReadS a
15:11:19 <ski> which is the same as
15:11:27 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Prelude.html#t:ReadS
15:11:29 <ski>   reads :: Read a => String -> [(s,String)]
15:11:32 <red_> yeah I meant the type
15:11:41 <ski> given the definition of the type `ReadS'
15:11:51 <ski>   type ReadS a = String -> [(a, String)]  -- as `hoogle' gave above
15:12:40 <ski> the intension is that the function gets a string of all input, except the one to the left "of the current position" (which has already been consumed)
15:13:01 <ski> and it'll return a parsed value of type `a', and the rest of the input string, so that parsing can continue with that
15:13:33 <ski> however, because a parse can fail (and in general, succeed in more than one way), we give a list of pairs of `a'-result and rest-of-string
15:15:24 <red_> ski: thanks, very helpful'
15:15:56 <monochrom> red_: see my http://www.vex.net/~trebla/haskell/reads.xhtml
15:17:57 <erisco> seems tedious to coalesce a list of records [Record]. Say I want to merge all Record where myField has the same property
15:18:40 <erisco> foldr (aggregateF) defaultRecord . groupBy (propEq) . sortBy (propCmp)
15:20:12 <erisco> I can take out propEq as a case of propCmp
15:22:41 <ski> @let readSum :: ReadS Expr; readSum = \s0 -> [(n,s2) | (m,s1) <- reads s0 , (n,s2) <- return' (fromInteger m) s1 ] where return' m = \s1 -> (m,s1) : [(o,s4) | ("+",s2) <- lex s1 , (n,s3) <- readSum s2 , (o,s4) <- return' (m + n) s3 ]
15:22:42 <lambdabot>  Defined.
15:22:46 <erisco> :t foldr'
15:22:47 <lambdabot>     Not in scope: foldr'
15:22:47 <lambdabot>     Perhaps you meant one of these:
15:22:47 <lambdabot>       BS.foldr' (imported from Data.ByteString),
15:22:50 <ski> > readSum "2 + 3 + 4"
15:22:51 <erisco> :t foldr2
15:22:52 <lambdabot>     Not in scope: `foldr2'
15:22:52 <lambdabot>     Perhaps you meant one of these:
15:22:52 <lambdabot>       `foldr' (imported from Data.List),
15:22:53 <lambdabot>   [(2," + 3 + 4"),(2 + 3," + 4"),(2 + 3 + 4,""),(2 + (3 + 4),"")]
15:23:06 <ski> > [n | (n,"") <- readSum "2 + 3 + 4"]
15:23:09 <lambdabot>   [2 + 3 + 4,2 + (3 + 4)]
15:23:11 <erisco> > foldr1 (+) [1,2,3]
15:23:12 <ski> > [n | (n,"") <- readSum "2 + 3 + 5 + 7"]
15:23:12 <lambdabot>   6
15:23:15 <lambdabot>   [2 + 3 + 5 + 7,2 + 3 + (5 + 7),2 + (3 + 5) + 7,2 + (3 + 5 + 7),2 + (3 + (5 ...
15:23:33 <ski> oh, red_ left ..
15:24:20 <ski> > length [n | (n,"") <- readSum "2 + 3 + 5 + 7"]
15:24:23 <lambdabot>   5
15:31:31 <red_> ok another easy question ? i want to apply a fcn relating the first and second elements in a [[Int]] like [[1,2],[2,3],[4,4]]
15:31:37 <red_> i tried lambdas but it did not work
15:32:06 <red_> > map (\x -> \y -> x -y) [[1,2],[3,4]]
15:32:07 <NemesisD> i'm comparing 2 algorithms 1 that uses a parallel strat and one that doesn't using criterion. i'm using 'nf' on the sequential one to fully evaluate the result
15:32:07 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
15:32:07 <lambdabot>    arising from a use ...
15:32:43 <leroux> > map (\[x, y] -> x - y) [[1,2],[3,4]]
15:32:44 <lambdabot>   [-1,-1]
15:32:49 <red_> durrrrrr
15:32:50 <red_> thank you
15:32:59 <NemesisD> but on the parallel one i'm using parMap rdeepseq $ thefunction, am i correct that i don't need to use 'nf' from criterion in thise canse and whnf will do?
15:33:12 <leroux> No problem, red_.
15:33:22 <NemesisD> i'm thinking that nf is double-evaluating the result and inflating the runtime
15:34:13 <NemesisD> and perhaps a better quesion: is there a smarter way to tell if my benchmark is actually fully evaluating my data?
15:34:28 <ski> red_ : an example :
15:34:36 <ski> > [n | (n,"") <- readSum "2 + 3 + 5"]
15:34:40 <lambdabot>   [2 + 3 + 5,2 + (3 + 5)]
15:34:42 <ski> > [n | (n,"") <- readSum "2 + 3 + 5 + 7"]
15:34:46 <lambdabot>   [2 + 3 + 5 + 7,2 + 3 + (5 + 7),2 + (3 + 5) + 7,2 + (3 + 5 + 7),2 + (3 + (5 ...
15:34:55 <ski> this is ambiguous parsing
15:36:06 <ski> (note that `2 + 3 + 5' there really means `(2 + 3) + 5', it's just that `show' omits the brackets when printing them on the left like that)
15:36:21 <red_> ambiguous because there are multiple directions on the parse tree?
15:39:23 <Peaker> do FFI import declarations allow ST types as well as IO types?
15:41:23 <red_> :t sort
15:41:25 <lambdabot> Ord a => [a] -> [a]
15:42:06 <red_> :t sortBy
15:42:07 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:42:16 <Rc43> How to save continuation before using callCC?
15:42:34 <DigitalKiwi> is there a bot with seen still
15:42:39 <DigitalKiwi> or anyone seen glguy lately...
15:42:54 <enthropy> preflex: xseen DigitalKiwi
15:42:56 <preflex>  DigitalKiwi was last seen on freenode/#haskell 16 seconds ago, saying: or anyone seen glguy lately...
15:43:22 <DigitalKiwi> preflex: xseen glguy
15:43:22 <preflex>  glguy was last seen on freenode/#haskell 7 days, 21 hours and 54 minutes ago, saying: edwardk: and is any of this on your github?
15:43:32 <red_> aaand another dumb question : how do i sort a list of lists by the first elem of the internal lists --> [[1,_,_],[2,_,_],...] ?
15:43:36 <DigitalKiwi> aww :<
15:43:57 <DigitalKiwi> thanks
15:44:17 <ParaSa1lin> @ty sortBy (comparing head)
15:44:17 <lambdabot> Ord a => [[a]] -> [[a]]
15:44:25 <enthropy> red_: sort already does that, except it'll be different for ties
15:44:41 <red_> enthropy: sort is lexicographic, no?
15:44:52 <ParaSa1lin> @src sort
15:44:53 <lambdabot> sort = sortBy compare
15:44:59 <ParaSa1lin> @src [] compare
15:44:59 <lambdabot> Source not found. It can only be attributed to human error.
15:45:04 <ParaSa1lin> @src compare
15:45:04 <lambdabot> compare x y | x == y    = EQ
15:45:05 <lambdabot>             | x <= y    = LT
15:45:05 <lambdabot>             | otherwise = GT
15:45:23 <red_> kthnks
15:45:26 <enthropy> red_: yes, which is the same as comparing the first element
15:45:31 <monochrom> Rc43: I don't think it can be done? callCC is how you get at and save a continuation
15:45:33 <enthropy> if all the first elements are different
15:45:34 <ski> Peaker : not to my knowledle -- you could probably use `unsafeIOToST', though
15:45:55 <ParaSa1lin> @src [] (<=)
15:45:55 <lambdabot> Source not found. Take a stress pill and think things over.
15:46:03 * hackagebot hspec 1.7.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.7.2 (SimonHengel)
15:46:05 * hackagebot hspec-meta 1.7.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.7.2 (SimonHengel)
15:46:10 <ParaSa1lin> @src [] (<)
15:46:11 <lambdabot> Source not found. My mind is going. I can feel it.
15:46:14 <ParaSa1lin> @src [] (>)
15:46:14 <lambdabot> Source not found.
15:46:22 <ski> Rc43 : if you have `Cont o' or `ContT o m', you could unwrap with `runContT' and grab it that way
15:46:26 <Rc43> monochrom, I thought that callCC will return value to the point that we have set already, like setjmp/longjump in C.
15:46:51 <S_J> @hoogle String->[String
15:46:51 <lambdabot> Parse error:
15:46:51 <lambdabot>   String->[String
15:46:51 <lambdabot>           ^
15:46:53 <S_J> @hoogle String->[String]
15:46:54 <lambdabot> Prelude lines :: String -> [String]
15:46:54 <lambdabot> Data.List lines :: String -> [String]
15:46:54 <lambdabot> Data.String lines :: String -> [String]
15:47:28 <jmcarthur> Rc43: the function argument that callCC passes to its argument is its continuation
15:48:25 <monochrom> callCC (\k -> ... k is the continuation you can save now ...)   this does not conflict with what you said
15:48:32 <jmcarthur> Rc43:   x <- callCC $ \k -> foo        -- k is callCC's continuation, and x is the thing you ultimately apply k to in foo
15:49:37 <monochrom> see my http://www.vex.net/~trebla/haskell/cont-monad.xhtml , has examples of leaking out that k for future use
15:51:26 <monochrom> if you go so far as to save it in a mutable variable and use it some time later, way outside that callCC where it came from, you can pull many, many stuns.
15:55:17 <DigitalKiwi> what do you think of http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours (caveat, what do you think of it for someone that doesn't know scheme)
15:57:54 <NemesisD> anyone have experience with the performances characteristics of containers' Data.Map.Strict vs Data.HashMap.Strict
15:58:30 <NemesisD> they seem to have the same complexity for the most part
15:58:35 <ent> DigitalKiwi: i've only gone through the first few chapters but so far, lack of scheme knowledge doesn't seem to be a problem
15:59:14 <NemesisD> and actually, IntSet would work here
16:00:42 <NemesisD> intset claims to be especially good at unions
16:00:50 <giulia12> Hellooooooooooo!!!
16:00:57 <giulia12> hello :)
16:02:12 <NemesisD> hi
16:02:46 <Peaker> NemesisD: if you're after performance and don't need a persistent data structure, my https://github.com/Peaker/small_hash is faster than IntMap or any other Haskell option I benchmarked it against
16:03:25 <NemesisD> Peaker: got something up on hackage?
16:03:38 <bss03> Peaker: I don't see any haskell there.
16:03:52 <Peaker> https://github.com/Peaker/small_hash_hs is the Haskell binding to it
16:03:57 <Peaker> NemesisD: nope
16:04:09 <NemesisD> that's not gonna work for me
16:04:51 <NemesisD> trying to keep this reasonably easy to build and package
16:05:10 <Peaker> maybe I ought to put it on hackage at some point
16:05:12 <DigitalKiwi> ent: what about the other aspects of it
16:05:40 <edwardk> NemesisD: clearly you should adopt the bleeding edge and use my unreleased structures library ;)
16:05:54 <edwardk> that'll make packaging easy! ;)
16:06:40 <ent> DigitalKiwi: It seems pretty nice
16:07:12 <ent> DigitalKiwi: I think it's a lot more interesting than the toy projects in real world haskell
16:10:43 <NemesisD> lol
16:16:16 <bss03> Is there a lens construct that's equivalent to b -> a and (a -> b -> Maybe a OR b -> Maybe a)?
16:16:36 <shachaf> What does that OR mean?
16:16:51 <bss03> Well, in this case I don't need the first a.
16:17:19 <shachaf> Maybe you should describe what these things are.
16:18:13 <Fuuzetsu> Is there a nice way of bundling a cabal package inside of a package? I want to test cross-package linking in Haddock but in the same time I don't want to rely on the developer having any package documentation already on his system. The idea is to put our internal package in the Haddock test dependencies and use that.
16:18:26 <Fuuzetsu> at the same time*
16:19:48 <dwcook> If I'm using a TVar inside of IO, is it okay just to use the IO versions of the functions as much as possible? In that case, why are there no IO versions of write or modify?
16:20:17 <Peaker> dwcook: atomically a >> atomically b   is not the same as   atomically (a >> b)
16:20:42 <dwcook> Peaker, okay, noted. Why are the IO versions provided then?
16:20:46 <shachaf> dwcook: The IO versions of newTVar etc. exist because sometimes using an STM transaction is a problem.
16:20:48 <SrPx> donri: luite byorgey sorry, I had to quit. reading
16:20:56 <Peaker> shachaf: when?
16:20:56 <dwcook> shachaf, example?
16:21:17 <shachaf> For example, when you're using unsafePerformIO and want to avoid nested transactions.
16:21:21 <Peaker> dwcook: I think you'd want to think about the needed atomicity whenever you use STM. So the IO variants detract from that
16:21:23 <shachaf> For the whole "global variable" trick.
16:21:30 <fryguybob> dwcook: If you are only working with a single TVar you can atomically do something with it more efficiently then a full transaction can.
16:23:08 <dwcook> I actually haven't put much thought into the concurrency properties my program will need. Currently I'm having several threads read from a single variable, but soon I'll need to let the clients affect the world. I was thinking of using TChans for that.
16:23:22 <dwcook> Namely, have a single thread read all the "input" channels and change the world based on them.
16:23:25 <dwcook> Does that sound sane?
16:23:27 <merijn> dwcook: newTVarIO lets you use unsafePerformIO to have a top level TVar
16:23:53 <merijn> dwcook: Yeah, that's sounds perfectly reasonable
16:23:56 <SrPx> luite: byorgey hmm I see! I was thinking in porting an application from JS to Haskell but I'd like to be able to work on the Haskell version while still being able to keep the browser one up-to-date. as in, I want to start coding in haskell only
16:24:50 <dwcook> Okay, good, thanks.
16:25:29 <dwcook> Thanks everyone – I'll have to figure out how the transactions will work.
16:26:01 <NemesisD> hmm doing some benchmarking, seems like strict hashmaps with int keys do a better job at unions than intmaps
16:29:18 <imm33_> hello everry 1
16:29:32 <imm33_> hello says ariana
16:29:51 <haasn> How can I construct my own IOExceptions?
16:30:27 <NemesisD> you're definitely going to need to take a Sith initiate oath to do that
16:30:48 <merijn> haasn: mkIOError
16:32:42 <haasn> hmm
16:32:58 <haasn> while it seems to work, handling_ _IOException won't pick it up :(
16:33:08 <haasn> even if I loosen to handling_ id (aka. SomeException)
16:36:04 * hackagebot pipes 4.0.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.0.0 (GabrielGonzalez)
16:36:06 * hackagebot pipes-safe 2.0.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.0.0 (GabrielGonzalez)
16:36:08 * hackagebot pipes-parse 2.0.0 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-2.0.0 (GabrielGonzalez)
16:36:10 * hackagebot pipes-concurrency 2.0.0 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-2.0.0 (GabrielGonzalez)
16:36:13 <merijn> \o/
16:36:21 <Tekmo> :)
16:36:53 <spaceships> what can "fix" be used for?
16:36:54 <h4199> Does this make it official??
16:36:56 <Tekmo> Yes
16:36:58 <Tekmo> It's official
16:37:04 <dwcook> spaceships, recursion
16:37:05 <merijn> spaceships: Any recursion
16:37:06 <k0001> Woo hoo!!
16:37:13 <shachaf> merijn: Even polymorphic recursion?
16:37:17 <Tekmo> I'm just polishing the announcement post for tomorrow
16:37:19 <h4199> Congratulations
16:37:23 <Tekmo> Thanks :)
16:37:29 <merijn> shachaf: shush
16:37:31 <k0001> Tekmo: I'll just go ahead and push mine too.
16:37:36 <Tekmo> k0001: Alright
16:37:43 <merijn> shachaf: It could, if it weren't for haskell's silly type system!
16:37:45 <shachaf> merijn: That's a real question. Can fix be used for polymorphic recursion?
16:37:51 <shachaf> Or can you make another function which can?
16:37:53 <haasn> Tekmo: now we need an update to pipes-network so I can scrap this stupid server I'm working on and rewrite it in a more sane environment
16:38:02 <Tekmo> haasn: He's updating it right now
16:38:09 <haasn> excellent
16:38:11 <dwcook> So is that announcement of pipes like Christmas come early or something?
16:38:16 <Tekmo> k0001 is the maintainer of it and he's pushing it to Hackage right now
16:38:23 <Tekmo> haha
16:38:27 <merijn> shachaf: Actually, I'm not sure, and it's past 12 on Saturday so I can't be arsed thinking about it :)
16:38:34 <wavewave> hi
16:38:37 <spaceships> can i have a simple example of the use of fix?
16:38:41 <Tekmo> Hi
16:38:48 <merijn> > fix error
16:38:49 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:38:50 <dwcook> > fix (1 :)
16:38:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:39:06 <Tekmo> spaceships: The most common use of `fix` is if you don't want to define an intermediate recursive helper function
16:39:19 <Tekmo> spaceships: Let's use `dwcook`'s function as an example
16:39:19 <wavewave> Tekmo: good to see you ;-D
16:39:25 <Tekmo> wavewave: You, too! :)
16:39:34 <Tekmo> spaceships: Without `fix` you would write something like:
16:39:39 <haasn> Tekmo: how long will it take? :P I want to write an example of a simple chat server for this guy, right about now
16:39:50 <startling> the most common use of "fix" is not using it.
16:39:51 <Tekmo> spaceships: let ones = 1:ones in ones
16:39:52 <haasn> don't tell me I have to use network-conduit instead :)
16:40:21 <Tekmo> haasn: As soon as Hackage accepts his upload
16:40:21 <spaceships> Tekmo: ah, okay. recursion without a base case?
16:40:28 <Tekmo> spaceships: It can have a base case
16:40:42 <Tekmo> spaceships: The trick is to make the function lazy so that the recursion stops after some point
16:40:52 <shachaf> Any kind of recursion at all. It's quite barbaric.
16:41:16 <startling> > fix (const "spaceships")
16:41:18 <lambdabot>   "spaceships"
16:41:34 <Tekmo> spaceships: The reason `startling`'s example works is because:
16:42:10 <haasn> Tekmo: great! /me waits patiently
16:42:12 <Tekmo> fix (\_ -> "spaceships") = (\_ -> "spaceships") (fix (\_ -> "spaceships")) = "spaceships"
16:42:40 <spaceships> okay, it ignores the recursive argument
16:42:41 <dwcook> By the way, often it's more convenient to use an already defined function. For example, if you want an infinite list of 1's, you can just
16:42:44 <dwcook> > repeat 1
16:42:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:42:50 <k0001> haasn: I'm just checking that everything builds fine locally, and then I'll upload it. Say, 20 minutes.
16:42:55 <Tekmo> spaceships: Right.  The recursion bottoms out when it stops using the argument
16:42:58 <haasn> k0001: alright
16:43:00 <amyers> Anyone have any advice on using Data.Graph from containers vs Data.Graph.Inductive from fgl?
16:43:22 <Tekmo> I use `Data.Graph`
16:43:24 <haasn> k0001: I think it'll be faster for me to just build your library from git, assuming it works
16:43:24 <spaceships> Tekmo: thanks for your help
16:43:28 <startling> Data.Graph from containers has always been a pain for me. I don't know anything about the other one.
16:43:29 <Tekmo> spaceships: You're welcome!
16:43:55 <shachaf> fix of a strict function is quite boring.
16:44:04 <shachaf> Since the least fixed point is always ⊥.
16:44:21 <amyers> There's a lot more stuff in fgl but the API seems a bit more complicated
16:45:06 <k0001> haasn: sure, that will work.
16:46:13 <amyers> Tekmo: Have you had good experiences with Data.Graph?
16:46:38 <mgccl> I can't believe I can use guard on tuples... I thought it suppose to only work on functions...
16:46:49 <Tekmo> amyers: Yes
16:47:06 <Tekmo> The big problem is that it doesn't have many functions
16:47:12 <Tekmo> You have to roll most of your own graph functions
16:47:22 <mgccl> like this, http://lpaste.net/92718
16:47:29 <amyers> Tekmo: Yeah, that's what made fgl look attractive, there is way more stuff already defined
16:47:35 <wavewave> The original paper on Data.Graph is very classic. I love the paper.
16:48:18 <amyers> You can use guards anywhere you pattern match right?
16:48:19 <Tekmo> The main reason I rejected `fgl` way back was mainly because it was obvious from studying the source code that there was little attention to performance
16:48:21 <wavewave> Structuring Depth First search in haskell by King and Launchbury
16:48:40 <amyers> Tekmo: Ah, that's good to know
16:48:52 <amyers> Tekmo: That will almost certainly be important for me
16:49:13 <amyers> Tekmo: How is memory footprint for Data.Graph?
16:49:40 <Tekmo> amyers: It's really small
16:50:00 <Tekmo> It's just an adjacency list representation
16:50:06 <amyers> Ah, Good.  My use case I will have several thousand with <= 1k nodes
16:50:14 <Tekmo> i.e. `Array Vertex [Vertex]`
16:51:00 <amyers> so updates are expensive?  |V|?
16:51:05 * hackagebot pipes-network 0.6.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.0 (RenzoCarbonara)
16:51:22 <k0001> haasn: there you go :)
16:51:42 <wavewave> amyers: see this paper on the algorithm of Data.Graph :    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.2591&rep=rep1&type=pdf
16:52:11 <amyers> odd ... It says I have exceeded my daily download allowance ....
16:52:14 <Tekmo> amyers: It depends on the time complexity of update for `Array`.  I forgot what that is
16:52:23 <amyers> I haven't been on citeseer in a couple days ...
16:52:40 <amyers> Tekmo: Yeah, that's what I'm unfamiliar with as well
16:52:56 <Tekmo> amyers: In my case the graph was static so it didn't matter for me
16:53:08 <amyers> Tekmo: Mine are as well, I was just curious
16:53:41 <amyers> Tekmo: Okay, I will use Data.Graph for now, thanks for the info
16:53:48 <Tekmo> You're welcome
16:54:06 <amyers> wavewave: Thanks, I can get to the paper if I copy the link out of my irc client into the browser.  I'll check it out
16:54:39 <wavewave> amyers: you're welcome.
16:55:50 <haasn> k0001: thanks
16:56:03 <wavewave> I love the paper, since it has a proof for the correctness of strongly connected component algorithm by using equational reasoning.
16:56:29 <wavewave> that's quite difficult in imperative algorithm description.
16:56:44 <amyers> That's cool
16:58:31 <haasn> oh no!
16:58:33 <wavewave> btw, we need to improve Data.Graph by using more efficient data type..
16:58:45 <haasn> lens-9999 requires <exceptions-0.3
16:59:00 <haasn> but network-simple requires exceptions >=0.3.2 :(
16:59:07 <wavewave> it's still quite the same as the original paper
16:59:12 <haasn> this is the part where I want to throw everything away and switch to NixOS..
16:59:20 <edwardk> haasn: did we just not bump the lens head dep on exceptions?
16:59:32 <haasn> possible, the ebuild must be outdated
16:59:33 <applicative> oh hi Tekmo
16:59:40 <edwardk> haasn: feel free to bump it
16:59:42 <edwardk> it should be fine
16:59:49 <edwardk> heya tekmo
17:00:12 <k0001> haasn edwardk if that's not the case, I can try running network-simple with a lower version of exceptions and see what happens.
17:00:59 <applicative> nice precis of the docs k0001
17:01:04 <applicative> i mean http://monoid.k0001.org/haskell/Pipes/
17:01:13 <edwardk> k0001: well, i wrote both lens and exceptions, and we don't use anything particularly exotic out of exceptions in lens, the only thing that may have to change is a couple of deps may have to pull it stuff from the .Pure module
17:01:44 <fiddlerwoaroof> is it possible to say "not of type x" with pattern matching?
17:02:10 <fiddlerwoaroof> i.e. foo !(String a) = a
17:02:22 <haasn> you can't pattern match on types
17:02:27 <applicative> where ! means not?
17:02:30 <fiddlerwoaroof> yeah
17:02:31 <wavewave> fiddlerwoaroof: process x first then use _
17:02:43 <wavewave> ah.. type?
17:02:44 <applicative> it's hard with or without pattern matching.
17:02:49 <startling> fiddlerwoaroof: you can't do it with pattern matching.
17:03:03 <startling> I feel like one of those new extensions all the cool kids are using can do it.
17:03:24 <applicative> fiddlerwoaroof: but i think if people know more about the context, they will know what to do
17:03:30 <wavewave> does it make sense by the way?
17:03:41 <k0001> edwardk: I think that it might still be a good idea to lower the network-simple's dependency on exceptions, if possible. I confess that I didn't try running it with a lower version, but I don't do anything fancy with it so I expect it should work.
17:03:45 <startling> fiddlerwoaroof: if it seems like something you need, you're probably wrong.
17:03:51 <fiddlerwoaroof> wavewave: yeah, but it wouldn't work here.
17:04:04 <fiddlerwoaroof> at least, not that I can see
17:04:10 <Tekmo> applicative edwardk: Hi!
17:04:22 <wavewave> fiddlerwoaroof: what's the type of foo?
17:04:33 <edwardk> Tekmo: did some more fiddling with those folds
17:04:48 <Tekmo> edwardk: What did you come up with?
17:05:01 <k0001> applicative: gotta love standalone-haddock!
17:05:09 <applicative> Tekmo: he's gone completely foldmad, worse than you!
17:05:14 <Tekmo> edwardk: You need to check out this issue on `foldl`: https://github.com/Gabriel439/Haskell-Foldl-Library/pull/3
17:05:20 <Tekmo> edwardk: It has a lot of stuff you might be interested in
17:05:28 <edwardk> i wound up with comonads for L, R, M and L' folds. the comonad for M is rather different than the others, but i have a notion of folding homomorphisms between them
17:05:41 <wavewave> fiddlerwoaroof: probably you're using existential type now?
17:06:06 <edwardk> Tekmo: nice. i should be able to cleanly adapt those
17:06:46 <hpaste> fiddlerwoaroof pasted “No title” at http://lpaste.net/92720
17:06:51 <edwardk> Tekmo: a lot of them overlap with th fact that i can drive my foldings off of lens-style folds though, so using prefixOf or postfixOf or runOf with a specified fold can also do the filtering out there
17:07:45 <Tekmo> edwardk: Is there a way to convert a `foldl` fold to a lens fold or does that require making it use the original `Monoid` approach?
17:07:49 <fiddlerwoaroof> the code I pasted has overlapping cases, and I'd like to de-overlap the first one by saying something like (type1, !type2) -> ...
17:08:22 <fiddlerwoaroof> wavewave: I don't think so, because I'm not sure what that means.
17:08:26 <wavewave> fiddlerwoaroof: how about creating  a function like 'typeOf'
17:09:00 <hpaste> fiddlerwoaroof revised “No title”: “No title” at http://lpaste.net/92720
17:09:01 <wavewave> fiddlerwoaroof: case (typeOf arg1, typeOf arg2) of ...
17:09:07 <edwardk> well a Fold is the thing that picks the targets, a `foldl` fold/"Beautiful Folding"  fold is what i'm calling a Folding, which is an iteratee-like thing it describes what to do with it. what i have is something for each folding typ that defines how to run it over a Fold.
17:09:30 <wavewave> and typeOf :: ArgType -> SimpleTypeRepresentation
17:09:30 <edwardk> for the L' case this means doing a Foldable-style foldl' which is unfortunate
17:09:37 <shachaf> edwardk: Hey, lens already uses the name Folding.
17:09:40 <applicative> fiddlerwoaroof: whatever it is thats going, the first case will always match the rest arent read
17:09:51 <Tekmo> edwardk: Keep in mind that if you need `foldl` to make any changes, just ask
17:09:59 <Tekmo> edwardk: I'm not stabilizing the API just yet
17:10:14 <applicative> fiddlerwoaroof: the type1 type2 of the top level binding are not used in the case statement, but shadowed
17:10:15 <edwardk> Tekmo: well, what i have is rather… idiosyncratic ;)
17:10:19 <Tekmo> edwardk: Haha
17:10:30 <Tekmo> edwardk: I'm still holding out for the `Arrow` and `ArrowChoice` fold
17:10:45 <Tekmo> edwardk: It's just that every time I think I have it I find out I'm wrong
17:10:51 <wavewave> fiddlerwoaroof: what is the type of arg1, arg2?
17:11:09 <edwardk> Tekmo: interestingly i do have a Monad for my foldings that gives you a leaky-but-legal multipass algorithm support
17:11:23 * applicative is convinced that L / Foldl is and idea that is doomed never to be properly implemented because the implementer goes mad with generalizations before completing it
17:11:30 <applicative> an idea
17:11:35 <wavewave> need to be some kind of sum type.
17:11:43 <Tekmo> I think the one true way is whatever way forms `Arrow` and `ArrowChoice`
17:11:44 <fiddlerwoaroof> They will be LispVala from the "write your own scheme" wiki book.
17:11:50 <fiddlerwoaroof> ^ wavewave
17:12:08 <wavewave> data ArgType  = IntType Int | DoubleType Double | StringType String
17:12:12 <wavewave> for example
17:12:15 <fiddlerwoaroof> yeah
17:12:16 <edwardk> well, I get a 'Choice' -- which is basically 'ProfunctorChoice' the Arrow version requires you to be in 'Mealy' form rather than Moore form
17:12:31 <edwardk> i have both lying around but the Moore form is cleanly resumable as a Comonad.
17:12:43 <wavewave> then you can pattern-match .
17:12:45 <edwardk> which lets me do things like start a crc32 run it for a while, then feed it more input
17:12:46 <fiddlerwoaroof> The bit of code I'm working on is for wrapping Prelude functions for scheme type-checking
17:12:48 <Tekmo> edwardk: The problem I get when I try the `Mealy` form is that my encoding is not a true `Category` unless you assume that the `Fold` is consumed in exactly one way
17:13:06 <edwardk> prefix [3,4] (prefix [1,2] crc32)
17:13:22 <wavewave> case (arg1,arg2) of (IntType x1, IntType x2) -> blahblah ; (DoubleType x1, DoubleType x2) -> blahblah ; ..
17:13:30 <edwardk> i care more about the comonad than the category as the comonad captures resumption
17:13:37 <Tekmo> applicative: If you want you can always write your own fold library
17:13:38 <edwardk> but mealy is also useful in its own right
17:13:54 <Tekmo> I want the `Arrow` and `ArrowChoice` for FRP
17:13:58 <edwardk> sure
17:14:03 <edwardk> mealy is definitely more FRP-like
17:14:18 <edwardk> moore strikes me as a better balance for HMAC-like things
17:14:49 <crocket> How does haskell handle modules these days?
17:14:53 <wavewave> fiddlerwoaroof: then all absurd case will be   _ -> Left "error"
17:15:44 <fiddlerwoaroof> wavewave: I realize I could do it that way, but then I'd have to write a bunch of nearly identical code for +,-,*, etc..
17:16:05 * hackagebot pipes-binary 0.2.0 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.2.0 (RenzoCarbonara)
17:16:08 <wavewave> fiddlerwoaroof: you can parameterize the function
17:16:40 <fiddlerwoaroof> wavewave: I'm not sure what that means (I'm relatively new to Haskell)
17:16:53 <wavewave> fiddlerwoaroof: hmm you already parameterize it using op as a parameter of your function.
17:17:06 <fiddlerwoaroof> ah, I see
17:17:41 <applicative> Tekmo: there's not too much to write, it is a matter of communication. Conal already took it into his head and then ... generalized http://conal.net/blog/posts/another-lovely-example-of-type-class-morphisms and 30 other posts
17:18:04 <Tekmo> applicative: Is there anything wrong with the `foldl` library?
17:18:05 <wavewave> fiddlerwoaroof: so.. just try. I think you already got what you want almost.
17:18:18 <fiddlerwoaroof> thanks, I'll work on it.
17:18:34 <wavewave> :)
17:19:10 <applicative> Tekmo: no, i like it as it is, or more or less. Then i would favor more theoretical ones like edwards or what you are contemplating
17:19:38 <wavewave> fiddlerwoaroof: probably you may need extra type class constraint.
17:20:09 <applicative> my thought is that this idea has been around forever and people keep failing at a focussed and optimized presentation of the core idea, which would put it among the abcs of haskell  see the smashing success of http://hackage.haskell.org/package/ZipFold which took the air out of the room for some time
17:20:19 <wavewave> wrap2 :: (Num a) => (a -> a-> a) -> ArgType -> ArgType -> ArgType
17:20:36 <wavewave> depending on what constraints you want for 'op'
17:20:41 <k00mi> I'm surprised this works: "readLn :: (MonadIO m) => (Read a) => Producer' a m ()"
17:20:54 <k00mi> is it any different from (MonadIO m, Read a) => ?
17:20:55 <Tekmo> applicative: I never even knew about the `ZipFold` package before
17:20:58 <shachaf> k00mi: No.
17:21:05 * hackagebot pipes-attoparsec 0.3.0 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.3.0 (RenzoCarbonara)
17:21:08 <shachaf> k00mi: It's also not valid in Haskell 2010, but GHC allows it.
17:21:20 <k00mi> ah, ok
17:21:38 <applicative> Tekmo: I wasn't thinking you did; but that it is a warning ;)
17:21:40 <wavewave> k00mi, shachaf: I wasn't aware of it. ;-)
17:21:41 <shachaf> k00mi: It even allows C a => Foo -> D a => Bar -> ...
17:21:51 <wavewave> cool
17:21:53 <Tekmo> applicative: haha
17:22:07 <Tekmo> applicative: The difference between me and Conal is that I take the time to promote the use of libraries
17:22:26 <applicative> Tekmo: there are several really excellent posts about it by Conal; he promoted it into his version of excessive generality
17:22:32 <k00mi> shachaf: huh, I don't even know what behavior to expect from that
17:22:40 <edwardk> Tekmo: anyways, i just pushed folds to hackage. i don't want to step on your toes in this area, but i needed it for another project, and i need more than just left folds
17:22:51 <Tekmo> edwardk: I don't mind at all
17:22:57 <applicative> Tekmo: they predate your interest, but i would think the series of conal posts linked above were among the most widely read in their day
17:23:09 <edwardk> Tekmo feel free to steal any of my instances or laws
17:23:16 <Tekmo> edwardk: Will do ;)
17:23:20 <startling> I like ClassA a => ClassB b => c style better than parens; I only stopped using it because people laughed at me.
17:23:27 <edwardk> Tekmo: the comonad for M is quite interestingly different than the ones for L and R
17:23:43 <edwardk> and yet it supports the notion of a folding homomorphism just as well
17:24:14 <edwardk> notably when using 'M' you can 'prefix' or 'postfix' data on either side without leaking memory but with L or R you have to leak for one or the other
17:24:30 <edwardk> and it drops out as an emergent property of just reading the fold type off as other comonads
17:24:55 <edwardk> my first attempt at M was wrong, as it made an illegal monoid for foldMap!
17:25:37 <startling> Neat. You don't often find illegal monoids.
17:25:58 <copumpkin> we need the monoid police
17:26:06 * hackagebot folds 0.1 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.1 (EdwardKmett)
17:26:08 <Tekmo> applicative: Here is the problem: http://packdeps.haskellers.com/reverse/ZipFold
17:26:10 <edwardk> startling: it was replacing the 'seed' with the result of the first fold. so using the comonad was making up a "monoid" where "mempty" was the previous tree!
17:26:14 <shachaf> startling: Hey, I made a maximally illegal monoid!
17:26:21 <shachaf> It's useful.
17:26:50 * startling waits for hackage docs to be generated
17:26:55 <startling> shachaf, what does that look like?
17:27:04 <Tekmo> I noticed that Hackage uploading is much faster now
17:27:11 <startling> (what is "maximally illegal"?)
17:27:25 <sclv> we have raid one and one drive failed
17:27:27 <shachaf> I just mean that it breaks all the laws. Which I guess is pretty common for illegal monoids.
17:27:33 <startling> shachaf: oh, heh
17:27:40 <shachaf> > a <> b <> c
17:27:41 <lambdabot>   a <> b <> c
17:27:44 <benmachine> shachaf: heh, I was hoping something more dramatic
17:27:46 <shachaf> > (a <> b) <> c
17:27:47 <lambdabot>   (a <> b) <> c
17:27:53 <sclv> so we swapped it this morning, and then when we rebooted it fscked which took a while
17:27:53 <benmachine> like, every element is an identity except for mempty
17:27:55 <shachaf> > a <> mempty
17:27:57 <lambdabot>   a <> mempty
17:28:04 <sclv> and then copied stuff over to the other drive to resync
17:28:04 <startling> shachaf: oh, right.
17:28:04 <shachaf> benmachine: That would be a pretty good monoid.
17:28:07 <haasn> :t a
17:28:07 <lambdabot> Expr
17:28:09 <haasn> oh boy
17:28:11 <applicative> but it's so hard to make an illegal monoid
17:28:12 <benmachine> or there are only two inhabitants and (a <> b) <> c and a <> (b <> c) are always opposite ones
17:28:24 <sclv> but possibly it was just rebooting the box that cleaned up speed -- it had been up forever
17:28:25 <shachaf> benmachine: You could also break the closure law.
17:28:30 <shachaf> benmachine: But that's tricky in Haskell.
17:28:30 <benmachine> applicative: that's not entiiirely true
17:28:39 <startling> haasn, it's http://hackage.haskell.org/package/simple-reflect
17:28:46 <benmachine> shachaf: indeed. sometimes I don't see closure stated as a law, it's implicit in the types
17:28:48 <jmcarthur> shachaf: some might say if the result is _|_ when neither argument is _|_ then you have broken it
17:28:55 <benmachine> some might say that!
17:29:03 <elliott> I would say that.
17:29:06 <haasn> startling: yeah I didn't know Expr had a Monoid instance
17:29:14 <startling> shachaf: no one should parse show strings anyway.
17:29:25 <shachaf> Expr's Monoid instance is great.
17:29:36 <elliott> data Argh = Mon | Oid; instance Monoid Argh where mempty = Mon; mappend Mon _ = Mon; mappend _ Mon = Mon; mappend _ _ = undefined
17:29:37 <startling> > f >>= return
17:29:38 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr (m0 b0))
17:29:38 <lambdabot>    arising from...
17:29:48 <applicative> Tekmo: did I mention before that foldls like 'all' and so on need a bit of a warning, since of course they are like using 'all' in ML or something
17:30:03 <shachaf> > foldMap (\x -> var [x]) (S.fromList "abcdef")
17:30:04 <lambdabot>   (((((mempty <> a) <> mempty) <> b) <> (mempty <> c) <> mempty) <> d) <> (me...
17:30:06 <shachaf> Just look at that!
17:30:17 <shachaf> Fortunately I got Milan to fix it.
17:30:19 <jmcarthur> to support Monoid properly i guess Expr would have to just be a free monoid... which leads to the idea that ideally Expr would be a "free everything"
17:30:22 <benmachine> applicative: in what way?
17:30:33 <applicative> benmachine: in what way what?
17:30:43 <shachaf> jmcarthur: I like that Expr exposes parenthesization and memptys.
17:30:46 <benmachine> applicative: all in ML
17:30:56 <jmcarthur> yeah that is quite nice :)
17:31:01 <shachaf> Or, at least, I like that something does it.
17:31:02 <benmachine> applicative: sorry, just curious
17:31:08 <shachaf> Which is why I wrote the magma thing.
17:31:09 <applicative> benmachine: it's just that it will continue to apply the predicate to the elements of the list even after it has failed
17:31:20 <benmachine> applicative: I don't think an ML all need do that necessarily
17:31:30 <applicative> benmachine: of course you can escape it
17:31:49 <jmcarthur> :t var
17:31:50 <lambdabot> String -> Expr
17:31:53 <benmachine> applicative: yeah, you just have to do so explicitly instead of reusing general fold combinators
17:32:05 <benmachine> unless they're fold combinators with an escape hatch
17:32:16 <applicative> fold (all even) [1,2,2,2,2,2,2,2,2,2,2] will apply even to the whole list, which isn't so bad with even
17:32:26 <jmcarthur> > mconcat $ foldMap (\x -> [var [x]]) (S.fromList "abcdef")
17:32:28 <lambdabot>   a <> b <> c <> d <> e <> f <> mempty
17:32:29 <benmachine> blink blink
17:32:35 <applicative> benmachine: i mean the fold in the foldl library
17:32:36 <benmachine> what type does all have?
17:32:36 <jmcarthur> aw, still shows mempty of course
17:32:45 <jmcarthur> was trying to recover the monoid laws that way
17:32:59 <shachaf> Well, it does sort of obey the monoid laws that way.
17:33:06 <shachaf> It'll always show exactly one mempty at the end.
17:33:08 <jmcarthur> i guess. everything is terminated with mempty
17:33:31 <jmcarthur> mm, that isn't true
17:33:32 <shachaf> λ> foldMap N (S.fromList [1,2,3,4,5,6])
17:33:32 <shachaf> (((((ε ◇ N 1) ◇ ε) ◇ N 2) ◇ ((ε ◇ N 3) ◇ ε)) ◇ N 4) ◇ ((ε ◇ N 5) ◇ ((ε ◇ N 6) ◇ ε))
17:33:46 <jmcarthur> ah, yes it is
17:33:48 <jmcarthur> i fooled myself
17:34:18 <shachaf> jmcarthur: And you are the easiest person to fool!
17:34:21 <shachaf> (So I hear.)
17:34:44 <jmcarthur> i probably said that
17:35:10 <shachaf> I think Feynman said that.
17:35:12 <shachaf> I don't know.
17:35:38 <jmcarthur> Feynman said jmcarthur is the easiest person to fool?
17:36:06 * hackagebot pipes-zlib 0.3.0 - Zlib compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.3.0 (RenzoCarbonara)
17:36:14 <shachaf> He said that "you are the easiest person to fool".
17:36:18 <chirpsalot> jmcarthur: that would be a bad sign. :P
17:36:37 <shachaf> Maybe I should've used capture-avoiding substitution or something there.
17:37:46 <benmachine> use-mention distinct on "you"
17:37:56 <benmachine> +ion
17:37:59 <benmachine> ion: not you
17:44:38 <fiddlerwoaroof> does haskell have anything like virtualenv in python?
17:44:42 <Tekmo> hsenv
17:44:49 <Tekmo> and cabal sandbox now
17:45:46 <geekosaur> note that those provide different levels of sandboxing; cabal sandbox lets you sandbox packages, hsenv sandboxes entire compiler installations
17:46:44 <fiddlerwoaroof> thanks, hsenv looks like what I was looking for.
18:06:07 * hackagebot pipes-aeson 0.2.0 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.2.0 (RenzoCarbonara)
18:17:22 <pharaun> nice bunch of pipes-x stuff coming in :)
18:21:20 <pharaun> what ever happened to hackage 2?
18:21:53 <geekosaur> slowly progressing
18:22:08 <geekosaur> http://new-hackage.haskell.org is a thing
18:22:14 <geekosaur> dunno how often they sync it
18:22:31 <pharaun> yeah i just tried it, i noticed and its down so that's what made me ask :)
18:22:43 <Demos> it is still down, geez
18:22:54 <sm> http://new-new-hackage.haskell.org/ is up (at the moment)
18:23:01 <pharaun> new-new? :)
18:23:02 <geekosaur> oy
18:23:06 <sm> don't ask
18:23:22 <pharaun> oh its beta now
18:23:24 <startling> pharaun, newer than old-new, akak new
18:23:29 <geekosaur> o.O
18:24:00 <shachaf> Just skip ahead to fix-new-hackage.haskell.org
18:24:34 <startling> turns out naming subdomains in a time-sensitive way is a bad idea.
18:25:34 <pharaun> you can "register" an account, that's nice
18:25:51 <pharaun> just recently requested hackage access so that's how i noticed the new thing
18:26:45 <pharaun> oh they're hoping to switch to new around the icfp
18:26:52 <pharaun> that's pretty soon
18:27:28 <joelteon> it hasn't sent my email yet :(
18:31:53 <jfischoff> what flag do I pass to ghci to increase the stack size?
18:32:23 <jfischoff> oh I see nv
18:40:30 <SrPx> Any reason Haskell doesn't allow for the conventional (λx.x*x) LC syntax? :(
18:41:08 * hackagebot cabal-audit 0.3.0.0 - Check how up-to-date your .cabal dependencies are.  http://hackage.haskell.org/package/cabal-audit-0.3.0.0 (JoelTaylor)
18:43:36 <geekosaur> because haskell allows identifiers to use non-ascii symbols. λ is a Greek letter
18:43:50 <geekosaur> note *letter*, not "convenient symbol for you to appropriate"
18:43:57 <ekipan> if you insist on lambda, why not also the middle dot instead of the asterisk for mulitplication?
18:44:15 <ekipan> ascii is usable by everyone at least
18:44:25 <sm> joelteon: hi, is cabal-audit better than packdeps ?
18:46:48 <startling> there might be a lambda codepoint for math.
18:48:33 <geekosaur> there might be one now, there wasn't in older revisions of unicode and font support is always diey
18:48:35 <geekosaur> *dicey
18:55:48 <red_> am i here
18:55:52 <copumpkin> nope
18:55:55 <copumpkin> only I am here
18:56:00 <ahill-89> There's a deep metaphysical question for you.
18:56:31 <SrPx> hm ok
18:56:58 <red_> if i have a list [1..7], is there an obvious fcn i'm overlooking to perform some fcn in this order (1*(1*2)*(1*2*3)*(1*2*3*4)) etc?
18:57:04 <scripty> 5/=5  : False ? I thought i'll get error
18:57:13 <red_> this seems like it should be very obvious
18:58:08 <ekipan> > inits "abcd"
18:58:09 <lambdabot>   ["","a","ab","abc","abcd"]
18:58:17 <geekosaur> scripty, why?
18:58:19 <erisco> @pl \x y -> compare x y == EQ
18:58:22 <lambdabot> flip (flip . ((==) .) . compare) EQ
18:58:22 <lambdabot> optimization suspended, use @pl-resume to continue.
18:58:59 <scripty> geekosaur , the left hand must be variable right ?
18:59:10 <geekosaur> no?
18:59:17 <scripty> num+=7;
18:59:28 <geekosaur> errrr
18:59:29 <scripty> I dont understand
18:59:43 <geekosaur> haskell doesn;t have "variables" in the sense implied by that
18:59:46 <ahill-89> :t (/=)
18:59:47 <lambdabot> Eq a => a -> a -> Bool
18:59:57 <geekosaur> and /= is what C-like languages call !=
18:59:58 <ekipan>  (/=) is the "not equal" operator, spelled != in various other languages
19:00:27 <jfischoff> red_: product $ map product $ inits [1..7]
19:01:14 <erisco> > product . map product . inits $ [1..7]
19:01:15 <lambdabot>   125411328000
19:01:15 <scripty> OMG! peculiar i though it was compound operator
19:01:27 <startling> OH. hahaha
19:01:29 <erisco> jfischoff, hey I like dollar too but
19:01:47 <geekosaur> you wont find C's op= operators in Haskell because they imply variables of a kind Haskell doesn't have
19:01:56 <jfischoff> erisco: dollar is easier for beginners
19:02:15 <shachaf> Well, except when you implement them yourself. But you shouldn't worry about that yet.
19:02:18 <geekosaur> (not directly at least; there are IORefs and such but those can't be used quite as blithely as C and friends toss around op=)
19:02:19 <startling> scripty, in any case, 5 / 5 isn't an error ...
19:02:36 <ekipan> ref *= x = modifyIORef (* x) ref
19:03:23 <geekosaur> startling, that's not the point. in C-like languages, x /= y means divide x by y and store result in x
19:03:40 <shachaf> :t (+=)
19:03:41 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
19:04:09 <startling> geekosaur, why would 5 /= 5 ever be an error? because '5' isn't a variable?
19:04:26 <geekosaur> see what I just said
19:04:37 <geekosaur> in C it's an error because the thing on the left is not an "lvalue"
19:04:52 <geekosaur> 5 /= 5, in C-like languages, is something like: 5 = 5 / 5
19:04:54 <startling> yes, I know.
19:05:09 <geekosaur> which is why someone expecting C-like syntax would expect 5 /= 5 to be an error
19:06:00 <startling> I guess my mistake is imagining a haskell-like language where (/=) is divide-assign and interpreting scripty's question in terms of that.
19:07:03 <shachaf> lens calls it (//=)
19:07:17 <ekipan> you'd have to make 5 be an assignable-to thing, which I suppose you could do with an appropriate Num instance
19:07:53 <ekipan> perhaps *inappropriate* would describe it better
19:08:03 <startling> instance Num (Lens' a b) where ...
19:08:10 <shachaf> > (`runState` (20,"hi")) $ do { _1 //= 10; _2.mapped %= toUpper }
19:08:11 <lambdabot>   ((),(2.0,"HI"))
19:11:13 * hackagebot folds 0.2 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.2 (EdwardKmett)
19:12:04 <startling> the hackage docs for 0.1 aren't even ready yet. :'(
19:13:01 <shachaf> http://ekmett.github.io/folds/
19:13:48 <erisco> :t foldr1
19:13:49 <lambdabot> (a -> a -> a) -> [a] -> a
19:14:37 <erisco> @pl \x y -> compare (f x) (f y)
19:14:40 <lambdabot> flip ((.) . compare . f) f
19:14:41 <lambdabot> optimization suspended, use @pl-resume to continue.
19:15:21 <ekipan> @src on
19:15:21 <lambdabot> (*) `on` f = \x y -> f x * f y
19:16:56 <red_> command for flattening a list?
19:17:10 <red_> :t flatM
19:17:11 <lambdabot> Not in scope: `flatM'
19:17:20 <ekipan> @hoogle [[a]] -> [a]
19:17:20 <lambdabot> Prelude concat :: [[a]] -> [a]
19:17:20 <lambdabot> Data.List concat :: [[a]] -> [a]
19:17:20 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:17:21 <erisco> red_, what do you mean by flatten?
19:17:32 <red_> Just Just x = Just x
19:17:41 <red_> [[1],[2]] = [1,2]
19:18:04 <ekipan> @type join
19:18:05 <lambdabot> Monad m => m (m a) -> m a
19:18:07 <erisco> red_, as ekipan pointed out, you'll want to check Hoogle for questions like these
19:18:33 <SrPx> why this doesnt work? :/ `x [] = []; main = do putStrLn $ show (x [])`
19:18:38 <red_> ok thanks .. i have yet to realize how helpful hoogle can be . but i guess you can learn a lot form knowing a type signature
19:19:12 <SrPx> show "testing the bot"
19:19:20 <erisco> red_, some things. there is not a single way to go from [[a]] to [a]
19:19:20 <SrPx> lambdabot: help
19:19:27 <SrPx> grr.
19:19:31 <ekipan> > let x [] = [] in show (x [])
19:19:32 <lambdabot>   "[]"
19:19:33 <red_> erisco: surely
19:19:46 <SrPx> why it doesn't work here...?!
19:19:50 <scripty> >
19:20:18 <ekipan> @paste it, it's probably a simple syntax error
19:20:18 <lambdabot> Haskell pastebin: http://lpaste.net/
19:20:20 <SrPx> I mean, the code
19:20:51 <SrPx> http://lpaste.net/92722
19:24:09 <ekipan> it's saying it doesn't know which "show" function to use
19:24:36 <ekipan> the empty list could be of any element type, try fixing its type with an annotation
19:24:55 <ekipan> presumably lambdabot has more type defaulting
19:25:15 <ekipan> > let x [] = [] in show (x ([]::[Char]))
19:25:16 <lambdabot>   "[]"
19:26:50 <ekipan> > let x [] = [] in show (x [] :: [Char])
19:26:51 <lambdabot>   "\"\""
19:28:52 <ekipan> hmm, how DOES one ask lambdabot which type she defaults in an > subexpression?
19:29:14 <SrPx> ... :|
19:29:15 <SrPx> okay
19:29:28 <SrPx> also, how do I ":t" on Haskell? (not on lambdabot nor the repl)
19:29:34 <SrPx> :t [2,3]
19:29:35 <ekipan> @type ()
19:29:35 <lambdabot> Num t => [t]
19:29:35 <lambdabot> ()
19:29:37 <arkeet> SrPx: you don't.
19:29:42 <SrPx> ekipan: thanks
19:29:45 <SrPx> arkeet: why?
19:30:09 <arkeet> what exactly do you mean?
19:30:14 <geekosaur> what would :t do in a program?
19:30:15 <SrPx> ekipan: no, it doesn't work?
19:30:26 <ekipan> I misread your message
19:30:30 <SrPx> geekosaur: return a string representing the type of the expression?
19:30:37 <SrPx> exactly as lambdabot does
19:30:44 <enthropy> > typeOf ()
19:30:45 <lambdabot>   ()
19:30:51 <arkeet> > typeOf id
19:30:52 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
19:30:52 <lambdabot>    arising from a use ...
19:30:54 <ekipan> > show (typeOf ())
19:30:55 <lambdabot>   "()"
19:30:58 <startling> :t typeOf
19:30:59 <lambdabot> Typeable a => a -> TypeRep
19:31:19 <SrPx> arkeet: not in cope
19:31:20 <geekosaur> if it's a program, the type is known at compile time so it would be something of a no-op.
19:31:22 <SrPx> scope*
19:31:27 <startling> SrPx, haskell is not dependently typed!
19:31:27 <geekosaur> Data.Typeable
19:31:30 <ekipan> @hoogle Typeable
19:31:30 <lambdabot> Data.Typeable module Data.Typeable
19:31:30 <lambdabot> Data.Typeable class Typeable a
19:31:30 <lambdabot> Data.Typeable class Typeable1 t
19:31:33 <arkeet> SrPx: it's a Typeable thing. but it's very limited.
19:31:40 <elliott> typeOf is not an answer here.
19:31:43 <arkeet> only works on Typeable instances, and doesn't do polymorphic things. so ^
19:31:49 <elliott> it doesn't even give useful polymorphism info or anything
19:32:18 <red_> >[(a,b) | a <- [1..10], b <-[10..1]]
19:32:22 <arkeet> I don't know if there's some TH way of doing it.
19:32:28 <arkeet> red_: needs a space after >
19:32:38 <arkeet> > [10..1]
19:32:39 <lambdabot>   []
19:32:42 <red_> > [(a,b) | a <- [1..10], b <-[10..1]]
19:32:43 <lambdabot>   []
19:32:53 <arkeet> > [10,9..1]
19:32:54 <ekipan> > [10..1]
19:32:55 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
19:32:55 <lambdabot>   can't find file: L.hs
19:32:56 <enthropy> arkeet: reify 'x  will sometimes have something to say about the type of x
19:32:58 <red_> oh durrr
19:33:03 <red_> 10,9
19:33:05 <red_> thx
19:33:23 <enthropy> it will if the thing is imported from another module
19:38:25 <NemesisD> are tuplesections considered harmless
19:39:34 <red_> ok i have a list [a1,a2,a3,a4,..] and i want the following (a1*a1 then (a1+a2)*a2 then (a1+a2+a3)*a3, etc.  i know i can use inits to get the successive sums, but i need to 'access' the original list.  is this mutual recursion? is this way easy?
19:39:49 <haasn> NemesisD: yes, but they can get slightly unreadable at times
19:40:04 <elliott> red_: access howso?
19:40:23 <haasn> red_: zipWith (*) xs (map sum (tails xs))
19:40:26 <haasn> I think
19:40:33 <red_> in an imperative mindset ,, I am multiplying a3 by the sum of what came before it
19:40:38 <haasn> > let xs = [a,b,c] in zipWith (*) xs (map sum (tails xs))
19:40:39 <lambdabot>   [a * (0 + a + b + c),b * (0 + b + c),c * (0 + c)]
19:41:02 <haasn> > let xs = [a,b,c] in zipWith (*) xs (map sum (inits xs))
19:41:03 <lambdabot>   [a * 0,b * (0 + a),c * (0 + a + b)]
19:41:21 <haasn> well you get the idea
19:41:38 <red_> i WILL get the idea when i spend 5 minutes staring at it
19:41:41 <red_> :)
19:42:00 <ekipan> > zipWith (*) [a, b, c] [d, e, f]
19:42:01 <lambdabot>   [a * d,b * e,c * f]
19:43:57 <shachaf> Why map sum . inits and not scanl?
19:44:01 <shachaf> (Or actually scanl1 in this case.)
19:44:29 <haasn> because I don't have scanl in my active memory!
19:44:36 <red_> :t scanl
19:44:37 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
19:44:41 <haasn> > let xs = [a,b,c] in zipWith (*) xs (scanl1 (+) xs)
19:44:42 <lambdabot>   [a * a,b * (a + b),c * (a + b + c)]
19:44:46 <haasn> shachaf++
19:44:58 <red_> i like that
19:45:20 <elliott> > (zipWith (*) <*> scanl1 (+)) [a,b,c]
19:45:21 <lambdabot>   [a * a,b * (a + b),c * (a + b + c)]
19:45:38 <SrPx> how to get the element before tail?
19:45:53 <shachaf> I veto elliott's @plification.
19:46:23 <copumpkin> SrPx: tail . init
19:46:36 <copumpkin> oh wait
19:46:37 <copumpkin> last . init
19:46:41 <copumpkin> I think that's what you're talking about?
19:46:59 <ekipan> > (last . init) "abcde"
19:47:00 <lambdabot>   'd'
19:47:21 <SrPx> good one, thanks
19:47:30 <haasn> > "abcde"^?reversed.ix 1
19:47:31 <lambdabot>   Just 'd'
19:47:41 <shachaf> If you keep guessing what people mean, they'll never learn to express themselves clearly!
19:48:44 <SrPx> > take 10 x where x = 0 : 1 : init x
19:48:45 <lambdabot>   <hint>:1:11: parse error on input `where'
19:49:40 <SrPx> > let x = 0 : 1 : init x in take 10 x
19:49:41 <lambdabot>   [0,1,0,1,0,1,0,1,0,1]
19:50:03 <SrPx> > let x = 0 : 1 : (tail . init) x in take 10 x
19:50:10 <lambdabot>   mueval-core: Time limit exceeded
19:50:35 <ekipan> init on an infinite list is still infinite, and thus has no last
19:50:51 <ekipan> erm wait
19:51:25 <haasn> ‘init’ on an infinite list is effectively ‘id’
19:51:47 <copumpkin> > let x = 0 : 1 : tail x in take 10 x
19:51:48 <lambdabot>   [0,1,1,1,1,1,1,1,1,1]
19:51:56 <copumpkin> hashcat: not quite, it seems :)
19:51:59 <copumpkin> haasn
19:52:09 <haasn> > let x = 0 : 1 : init (tail x) in take 10 x
19:52:16 <lambdabot>   mueval-core: Time limit exceeded
19:52:23 * haasn scratches head
19:52:37 <copumpkin> you need to think about how productive it is
19:52:48 <haasn> @src init
19:52:48 <lambdabot> init [x]    = []
19:52:48 <lambdabot> init (x:xs) = x : init xs
19:52:48 <lambdabot> init []     = undefined
19:53:18 <haasn> > let x = 0 : 1 : 2 : tail (init x) in take 10 x
19:53:19 <lambdabot>   [0,1,2,1,2,1,2,1,2,1]
19:53:34 <copumpkin> so it forces two levels down
20:01:21 <SrPx> oh it makes sense.
20:01:28 <SrPx> thanks
20:02:00 * SrPx is amused with the fact you can refer to a variable inside itself
20:02:27 <haasn> recursion is pretty standard
20:04:02 <ekipan> > cycle "lo"
20:04:03 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
20:05:06 <ekipan> @src cycle
20:05:06 <lambdabot> cycle [] = undefined
20:05:06 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:05:19 <SrPx> Is there a function that takes a list and returns every consecutive pair / triple? eg f [0,1,2,3,4] == [[0,1,2],[1,2,3],[2,3,4],[3,4,0],[4,0,1]]
20:05:55 <ekipan> > (map (take 2) . tails) "abcdefg"
20:05:56 <lambdabot>   ["ab","bc","cd","de","ef","fg","g",""]
20:06:10 <haasn> > zipWith drop [0..] (repeat (cycle [0..4]))
20:06:11 <lambdabot>   [[0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1...
20:06:17 <haasn> oh
20:06:37 <haasn> > zipWith (\n -> take 3 . drop n) [0..] (repeat (cycle [0..4]))
20:06:38 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4],[3,4,0],[4,0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,0],[4...
20:06:48 <haasn> there's probably a better solution :)
20:06:55 <shachaf> > (\l -> zipWith const (map (take 3) (tails (cycle l))) l) "abcdefg"
20:06:56 <lambdabot>   ["abc","bcd","cde","def","efg","fga","gab"]
20:07:23 <SrPx> ekipan: wat. you are mapping `((take 2) . tails)` to a list? `((take 2) . tails)` of 'a' makes no sense.
20:07:34 <SrPx> wait, tails. let me check that function
20:07:44 <shachaf> But on the other hand why am I helping? It won't help.
20:07:45 <ekipan> (map (take 2)) . tails
20:07:52 <ekipan> function application has highest precedence
20:07:58 <ekipan> over all other operators
20:08:03 <haasn> > let xs = [0..4] zipWith (\n -> take 3 . drop n) [0..] (cycle <$> xs <$ xs)
20:08:04 <lambdabot>   not an expression: `let xs = [0..4] zipWith (\n -> take 3 . drop n) [0..] (...
20:08:09 <haasn> > let xs = [0..4] in zipWith (\n -> take 3 . drop n) [0..] (cycle <$> xs <$ xs)
20:08:10 <SrPx> schahow not?
20:08:10 <lambdabot>   No instance for (GHC.Show.Show a0)
20:08:10 <lambdabot>    arising from a use of `M1091162098.sh...
20:08:16 <haasn> > let xs = [0..4] in zipWith (\n -> take 3 . drop n) [0..] (cycle <$> (xs <$ xs))
20:08:17 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4],[3,4,0],[4,0,1]]
20:08:24 <SrPx> shachaf: how not?
20:08:44 <SrPx> he quit :/
20:10:25 <SrPx> haasn: (=
20:10:31 <haasn> somebody remind me about what the difference between *> and >> is for Monads
20:11:32 <SrPx> haasn: too complex to me though. <$> and <$...
20:12:28 <enthropy> haasn: the Applicative <*> doesn't have to be the same as Monad ap
20:12:38 <applicative> is there one to speak of     (*>) = liftA2 (const id)
20:12:45 <ekipan> if it isn't the same, I'd call that a bug
20:12:47 <enthropy> but I don't think base has anything like that
20:12:48 <haasn> enthropy: are you sure?
20:13:25 <ekipan> the fact that Monad doesn't descend from Applicative is a bug in the standard, for which work is being done to correct
20:13:47 <enthropy> haasn: it would be legal to have ZipList be what you get for lists
20:14:33 <applicative> enthropy: but ap wouldn't typically be involved in an implementation of >>
20:15:21 <haasn> enthropy: ZipList can't be made a Monad though
20:15:57 <applicative> > getZipList $ pure 'a'
20:15:58 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:16:15 <enthropy> haasn: so?
20:16:18 <applicative> sure it can, it just cant use return = pure
20:16:40 <haasn> it can? show me an implementation of Monad (ZipList a) that satisfies all the monad laws
20:16:47 <applicative> and will violate the protocol that the monad instance agree with the applicative instance with ap = <*> etc
20:16:56 <haasn> oh
20:17:03 <haasn> yes of course, by using the regular [] instance on it
20:17:03 <applicative> instance Monad ZipList where return = ZipList .return
20:17:22 <haasn> right; but isn't it a law that return = pure ?
20:17:30 <applicative> haasn: it's amazing how many people are under a magical illusion about this. it's like a dream
20:17:49 <applicative> haasn: a law of what, the monad class? or the applicative class?
20:17:55 <geekosaur> haasn: `appicative` there is of the oppinion that haskell's applicative is a complete and utter lie
20:18:14 <applicative> not at, I just oppose bullshit
20:18:18 <geekosaur> and that he(?) alone is competent to tell the world what  valid applicative is
20:18:55 <applicative> geekosaur: you just saw it happen above; haasn is a very competent haskeller
20:18:56 <SrPx> hey, just wondering, is [a] a sugar for (list a) ?
20:18:57 <haasn> aren't we getting Applicative as a superclass of Monad in 7.8 or 7.10? In which case it would be a Monad law
20:19:17 <tabemann> [a] is sugar for [] a
20:19:20 <scshunt> the fact that pure = return follows from the uniqueness of functor and the monad laws
20:19:26 <applicative> haasn, well, its a question what it would be a law of.
20:19:29 <haasn> tabemann: or a:[], depending
20:19:46 <SrPx> tabemann: [] is a type?
20:19:47 <applicative> scshunt: what is pure?
20:19:57 <tabemann> SrPx: [] is a type of kind * -> *
20:20:02 <scshunt> :t pure
20:20:02 <lambdabot> Applicative f => a -> f a
20:20:05 <SrPx> * ?
20:20:11 <scshunt> erm, right
20:20:23 <ekipan> > 1 : [] :: [] Int -- first brackets is the nil int list, second is the type constructor of list types
20:20:24 <lambdabot>   [1]
20:20:29 <scshunt> confusing pure and fmap
20:20:47 <SrPx> .. eh
20:20:56 <scshunt> what I should have said is that for every monad instance, there exists an applicative instance with pure = return, and this can be determined from the monad laws
20:21:02 <tabemann> SrPx: okay, knowing what * means requires knowing about kinds
20:21:06 <applicative> there is a unique functor instance given the functor laws; there is a unique-up-to-isomorphism monad instance, if i understand; but applicative doesn't decide things in the same way
20:21:24 <SrPx> tabemann: ok, if it is advanced I'll not jump steps
20:21:33 <applicative> scshunt: yes pure = return ; <*> = ap of course
20:21:35 <scshunt> so it makes a lot of sense for Applicative => Monad
20:21:44 <tabemann> SrPx: basically, a type constructor that takes one argument is kind * -> *
20:21:56 <tabemann> whereas a type constructor that takes no arguments is kind *
20:22:15 <ekipan> it's just another way to say the same thing ([] Int) and [Int] are both the type "list of ints"
20:22:21 <applicative> it's totally optional as far as the laws go.  the reason it makes sense is that the Monad class doesn't permit independent optimization of fmap and <*>
20:22:45 <enthropy> @hoogle WrappedMonad
20:22:46 <lambdabot> Control.Applicative newtype WrappedMonad m a
20:22:54 <applicative> liftM and ap aren't methods of Monad
20:22:55 <SrPx> tabemann: this makes some sense but many concepts are missing
20:23:29 <SrPx> I can make my own type, foo, and then have a "foo of lists of ints"?
20:23:55 <applicative> this is the reason why Functor => Applicative => Monad is necessary
20:23:58 <ekipan> data Foo a = {- put data constructors here -} -- then sure you can have Foo [Int]
20:24:39 <SrPx> How does it map to c++? (sorry but the last time I worked with types was C++)
20:24:40 <ekipan> (type names which begin with lowercase letters are type variables)
20:24:41 <haasn> applicative: I thought the main reason was to save us from having to type out all those darned (Functor f) constraints ¬_¬
20:24:50 <SrPx> oh OK
20:25:11 <applicative> if we only used Monad, as oleg used to recommend, we wouldn't have a problem ;)
20:25:17 <SrPx> ekipan: is that syntax or convention?
20:25:32 <ekipan> syntax
20:25:53 <ekipan> datatypes you define must begin with a capital letter
20:26:19 <haasn> or a :
20:26:26 <ekipan> (or a colon for symbol names, yes)
20:27:30 <SrPx> OK (:
20:27:43 <ekipan> the list type constructor is just a special case that can be written cirumfix
20:28:49 <ekipan> circum
20:31:44 <SrPx> ok!
20:38:15 <joelteon> :t (a =<<) . b
20:38:15 <lambdabot>     Couldn't match expected type `a1 -> m0 b0' with actual type `Expr'
20:38:15 <lambdabot>     In the first argument of `(=<<)', namely `a'
20:38:15 <lambdabot>     In the first argument of `(.)', namely `(a =<<)'
20:38:17 <joelteon> wohops
20:38:23 <joelteon> :t \a b -> (a =<<) . b
20:38:23 <lambdabot> Monad m => (a1 -> m b) -> (a -> m a1) -> a -> m b
20:38:28 <joelteon> oh so that's just (<=<)
20:41:43 <applicative> reddit wants to know 'Why use Monads for IO?" I wonder how many monads IO :: * -> * is?
20:41:57 <carter> ??
20:42:14 <joelteon> it's gotta be at least 4
20:42:18 <applicative> the plural just seems uncanny
20:42:36 <applicative> though of course there are all the instances of MonadIO , for example, so it can be made sense of
20:43:05 <applicative> joelteon: yeah, i use for, putChar, getChar and two others
20:43:12 <applicative> four, rather; bah
20:44:27 <applicative> putChar, getChar, return and forkIO are the only monads I use for IO
20:44:28 <haasn> Codensity IO
20:44:36 <haasn> Codensity (Codensity IO)
20:44:40 <haasn> ...
20:44:51 <elliott> Fix2 Codensity IO
20:45:19 <joelteon> mapM putChar myStr
20:45:38 <joelteon> :t iterate
20:45:39 <lambdabot> (a -> a) -> a -> [a]
20:45:44 <applicative> mapM_ and avoid the pain
20:46:09 <joelteon> > head $ iterate (+1) 0
20:46:10 <lambdabot>   0
20:46:41 <joelteon> @let iterateM f s = fmap (s:) (f s >>= iterateM f)
20:46:42 <lambdabot>  Defined.
20:46:49 <joelteon> :t iterateM
20:46:49 <lambdabot> (Monad f, Functor f) => (a -> f a) -> a -> f [a]
20:46:52 <joelteon> woohoo
20:47:08 <applicative> :t iterateM show
20:47:09 <lambdabot> Char -> [[Char]]
20:47:17 <joelteon> could remove the Functor constraint, but there's really no reason Functor shouldn't be a superclass of Monad :(
20:47:21 <applicative> > iterateM show 'a'
20:47:25 <lambdabot>   *Exception: stack overflow
20:47:26 <applicative> hahah
20:47:31 <joelteon> > fmap head $ iterateM show 'a'
20:47:36 <lambdabot>   "*Exception: stack overflow
20:47:52 <applicative> joelteon: that couldn't be clearer yes, since there's no option for Functor instances, given the stated laws
20:48:16 <haasn> iterateM won't work for a very large number of interesting monads
20:48:17 <haasn> afaik
20:48:28 <elliott> try lazy state.
20:48:33 <elliott> or writer.
20:48:54 <haasn> > execWriter $ iterateM tell "a"
20:48:55 <lambdabot>   Couldn't match expected type `()'
20:48:55 <lambdabot>              with actual type `[GHC.Types...
20:49:07 <haasn> oh
20:49:13 <joelteon> I don't know if it's possible to make iterateM ever yield a value
20:49:16 <haasn> > execWriter $ iterateM tell () -- hehe
20:49:20 <lambdabot>   ()
20:49:28 <joelteon> ok, so there is
20:49:36 <haasn> > runWriter $ iterateM tell ()
20:49:39 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
20:49:40 <applicative> @pl iterateM f s = fmap (s:) (f s >>= iterateM f)
20:49:44 <lambdabot> iterateM = fix ((liftM2 fmap (:) .) . liftM2 flip ((>>=) .))
20:49:44 <lambdabot> optimization suspended, use @pl-resume to continue.
20:49:44 <joelteon> oo so it is
20:49:48 <joelteon> hang on i'll do it
20:49:50 <joelteon> i have a functioning pl
20:49:51 <applicative> blech
20:50:11 <joelteon> iterateM = fix ((liftM2 fmap (:) .) . liftM2 flip ((>>=) .))
20:50:15 <joelteon> oh, so lambdabot was right
20:50:16 <applicative> oh nice writer example
20:50:56 <haasn> > execWriter $ iterateM (\x -> tell x >> return x) "hmm"
20:50:59 <lambdabot>   "hmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhm...
20:51:15 <joelteon> :t \x -> tell x <$ x
20:51:16 <lambdabot> (Functor f, MonadWriter (f b) m) => f b -> f (m ())
20:51:21 <joelteon> oh, right
20:51:22 <haasn> x <$ tell x
20:51:27 <joelteon> yeah i got it backwards
20:51:35 <joelteon> :t (<$) <*> tell
20:51:36 <lambdabot> (Functor f, MonadWriter a f) => a -> f a
20:51:51 <haasn> <$ is like a confused <3
20:51:56 <joelteon> > execWrite $ iterateM ((<$) <*> tell) "hmm"
20:51:57 <lambdabot>   Not in scope: `execWrite'
20:51:57 <lambdabot>  Perhaps you meant one of these:
20:51:57 <lambdabot>    `execWriter' ...
20:52:01 <joelteon> > execWriter $ iterateM ((<$) <*> tell) "hmm"
20:52:04 <lambdabot>   "hmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhmmhm...
20:52:10 <joelteon> man I love using <*> on functions
20:52:20 <haasn> I love writing unreadable code, too
20:52:23 <joelteon> yeah
20:52:30 <joelteon> i don't do it in library code, but it's entertaining
20:52:40 <haasn> it's why I'm such a big fan of lens :)
20:52:48 <applicative> you're corrupting youth!!
20:52:49 <joelteon> well, if you say so
20:52:57 <joelteon> lens seems readable
20:53:05 <edwardk> if it was hard to write it should be hard to read!
20:53:09 <applicative> as long as you don't make a type violation
20:53:13 <joelteon> yeah
20:53:16 <joelteon> but if you do that you're dumb
20:53:18 <joelteon> i never make mistakes
20:53:32 <joelteon> type checkers are for the weak
20:53:54 <applicative> i was going to say, why bother not making mistakes all the time, when you have a typechecker
20:54:07 <edwardk> lens is a community building tool. you either understand the error messages perfectly or it drives you to IRC to find someone who does
20:54:22 <applicative> hah
20:54:32 <Tekmo> edwardk: So is anybody ever going to work on a GHC extension to use type synonyms to simplify inferred types?
20:54:38 <haasn> it helps to read the derivation and stuff
20:54:40 <Tekmo> I feel like that's something both of our libraries would benefit from
20:54:45 <edwardk> Tekmo: go for it =)
20:54:54 <applicative> they're a nightmare but, as Mrs Thatcher used to say, there is no alternative
20:55:00 <Tekmo> edwardk: I just might, but it has to wait until after I graduate
20:55:02 <edwardk> Tekmo: i started getting the scans to work. found the appropriate one for semigroup reducers as well
20:55:04 <haasn> Tekmo: I assume it would be a bit tricky to to work out the exact semantics
20:55:09 <joelteon> is it possible to do that?
20:55:40 <applicative> Tekmo: surely it would be hard?
20:55:49 <Tekmo> haasn: The idea I had in mind is that it would be applied as a pass after the type is inferred
20:55:57 <haasn> it seems outright silly to try and apply in-scope type synonyms in reverse in general, it would make more sense to try and keep track of existing type synonyms and avoid expanding them as much as possible
20:56:08 <applicative> maybe if you could make them something like a newtype-for-purposes-of-error-messages
20:56:18 <Tekmo> haasn: No, I came to the conclusion that trying to preserve type synonyms throughout the process would not work
20:56:31 <Tekmo> haasn: The only realistic way to do it is as a single pass after the type has been inferred
20:56:49 <elliott> you have to track synonyms originally used
20:56:52 <elliott> lest you replace String with FilePath
20:56:52 <Tekmo> No
20:56:58 <Tekmo> The idea is that you don't track synonyms originally used
20:57:01 <haasn> Tekmo: I think one compromise would be to keep track of all type synonyms involved throughout the entire type checking process of that type, and then only try to reverse from that pool
20:57:02 <applicative> what if there are several synonymns available
20:57:03 <Tekmo> You also don't always apply type synonyms
20:57:06 <Tekmo> It's specifically opt in
20:57:20 <Tekmo> You add an annotation to a type synonym that just enables it and gives the type synonym a priority
20:57:31 <Tekmo> For example:
20:57:34 <elliott> but it should be able to identify FilePaths.
20:57:37 <Tekmo> {-# STICK Producer 10 #-}
20:57:48 <elliott> it shouldn't be hard to take note of all the type synonyms actually used in the source code and simply restrict the choice to those at the end
20:57:50 <Tekmo> No, I don't think you want to enable it for `FilePath`s
20:58:04 <Tekmo> Or perhaps the end user is responsible for enabling them, not the library writer
20:58:26 <Tekmo> Anyway, the point is that once you enable it that type synonym gets some priority as indicated in the PRAGMA
20:58:27 <applicative> readFile :: FilePath -> IO FilePath
20:58:39 <jon_r> can anyone point me to the docs for `all` googling for it is impossible...
20:58:40 <Tekmo> That's exactly why you don't want to enable it for FilePath
20:58:46 <Tekmo> jon_r: Use hoogle
20:58:50 <bsrk> How do I know if a port is being used by some process or not? (in haskell, not command line)
20:58:52 <Tekmo> http://www.haskell.org/hoogle/
20:58:58 <Tekmo> You can use that to search for Haskell functions
20:59:04 <jon_r> hattip
20:59:08 <Tekmo> Hayoo is also great, too:
20:59:09 <Tekmo> http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:59:15 <Tekmo> Hayoo has more comprehensive coverage by default
20:59:18 <SrPx> let f x = 2, g x = 3 in (f 0) + (g 0)
20:59:21 <applicative> jon_r: https://www.fpcomplete.com/hoogle?q=all&env=ghc-7.4.2-stable-13.09 is a little jazzier
20:59:25 <SrPx> > let f x = 2, g x = 3 in (f 0) + (g 0)
20:59:26 <lambdabot>   <hint>:1:12: parse error on input `,'
20:59:32 <ekipan> semicolons, SrPx
20:59:33 <SrPx> > let f x = 2 and g x = 3 in (f 0) + (g 0)
20:59:34 <lambdabot>   <hint>:1:21: parse error on input `='
20:59:39 <applicative> jon_r: why i left your query on the url i dont know
20:59:41 <SrPx> > let f x = 2; g x = 3 in (f 0) + (g 0)
20:59:42 <lambdabot>   5
21:00:08 <SrPx> ekipan: thanks. They work as expression aggregators?
21:00:19 <ekipan> they seperate declarations
21:00:22 <Guest38417> haskell is a piece of fucking shit
21:00:27 <Guest38417> fucking nigger_ bitch
21:00:30 <ekipan> (and expressions in do blocks)
21:00:32 <Guest38417> fuck off faggits
21:00:34 <jon_r> is there an easy way to return false if the list is empty?
21:00:35 <Guest38417> FUCK HASKELL
21:00:38 <Guest38417> MOTHERFUCKERS
21:00:39 <applicative> grrrr
21:00:42 --- mode: ChanServ set +o edwardk
21:00:44 <Tekmo> jon_r: not . null
21:00:45 <Guest38417> FUCK U
21:00:47 <Guest38417> FAGGIT
21:00:47 --- mode: edwardk set +b *!43d5da4a@gateway/web/freenode/ip.67.213.218.74
21:00:47 --- kick: Guest38417 was kicked by edwardk (Your behavior is not conducive to the desired environment.)
21:00:54 <Tekmo> Thanks
21:01:18 <jon_r> Tekmo is there an easy way to combine that with an all :)
21:01:22 <applicative> jon_r: null
21:01:31 <applicative> oh Tekmo said, jon_r
21:01:40 <Tekmo> jon_r: You mean an `all` that special cases the empty list to return False instead of True?
21:01:46 <ekipan> the grammar says that declarations in a let block are enclosed in braces seperated by semicolons, SrPx
21:01:52 <ekipan> but you can use layout to omit them
21:02:01 <SrPx> Okay, ekipan . Thanks
21:02:11 <SrPx> > let shift n l = drop n l ++ take n l; consecs l = take (length l) $ [take 2 l] ++ consecs (shift 1 l); rule1 a = (head a) + (last a); step l = map rule1 $ consecs l; a = [0,0,0,0,0,0,1] : map step a in a !! 6
21:02:12 <lambdabot>   [1,6,15,20,15,6,1]
21:02:17 <SrPx> look I've grow a pascal triangle o.o
21:02:39 <edwardk> Tekmo: is your version of Mealy of the form: data L1 a b = forall c. L1 (c -> b) (c -> a -> c) (a -> c)   or something else?
21:02:41 <jon_r> Tekmo pretty much, I'm currently using pattern matching on a separate function
21:02:55 <applicative> edwardk: you're still @edwardk
21:03:00 <applicative> not that it matters.
21:03:11 <edwardk> applicative: i tend to stay 'loaded' for about 10 minutes after the first spammer, JIC
21:03:17 <Tekmo> edwardk: The latest version I tried was (a -> x, x -> x -> x, b -> x), but that didn't work
21:03:18 <edwardk> applicative: it takes too long to switch
21:03:21 <applicative> oh, i see, probably sensible
21:03:41 * elliott nostalgically remembers that one day when the spammers just wouldn't go away
21:03:56 <Tekmo> edwardk: Or just: (Monoid x) => (a -> x, x -> b)
21:03:56 <applicative> it's monochrom i think who characteristically forgets
21:04:17 <edwardk> Tekmo: well, the monoid version is stronger. that is the M folding I have now.
21:04:21 <edwardk> its too strong though.
21:04:37 <Tekmo> edwardk: Let me briefly review your `folds` package.  One second
21:04:47 <edwardk> I have the (a -> x) (x -> x -> x) (b -> x) folding
21:04:58 <edwardk> let me put up new haddocks on github
21:04:59 <Tekmo> edwardk: Yea, that's exactly what I had
21:05:05 <edwardk> the one on hackage is a bit behind
21:05:14 <edwardk> http://ekmett.github.io/folds/
21:05:20 * haasn remembers the day when services went down and somebody decided to de-op absolutely everybody as soon as ChanServ joined the channel again
21:05:31 <edwardk> L1, M1 and R1 are the mealy-likes.
21:05:54 <haasn> so what's this business behind ‘fold’ and friends anyway? What's the motivating use case?
21:05:57 <edwardk> L1 is a left folding mealy machine, M1 is a semigroup reducer and R1 is a reversed mealy machine for right folds. ideally i'd have an L1'
21:06:14 <edwardk> haasn: well, for me its mostly for dealing with HMACs and streaming statistical folds
21:06:21 <Tekmo> haasn: See this post: http://www.haskellforall.com/2013/08/composable-streaming-folds.html
21:06:26 <haasn> thanks
21:06:30 <haasn> I'll have a read when I wake up
21:06:33 <Tekmo> Alright
21:06:37 <edwardk> Tekmo: you're aware of the original: http://squing.blogspot.com/2008/11/beautiful-folding.html right?
21:06:55 <Tekmo> edwardk: Yeah, somebody already pointed that out to me
21:06:57 <joelteon> i wonder what kind of person sits there on a saturday night and thinks
21:07:01 <joelteon> "hey, i'll troll #haskell"
21:07:03 <Tekmo> edwardk: That was what inspired the current formulation
21:07:11 <edwardk> Tekmo: just making sure =)
21:07:23 <Tekmo> edwardk: And applicative pointed out Conal's version to me, too
21:07:34 <edwardk> Tekmo: basically i'm just going through and defining all the instances
21:07:47 <Tekmo> I still feel like there should be one *right* one
21:07:51 <edwardk> there turn out to be a lot of legal instances and it is quite the sort of mental puzzle I like
21:08:01 <kallisti> hm, when was catch removed from Prelude?
21:08:01 <edwardk> they are good at different things
21:08:11 <edwardk> 7.6 or so
21:08:27 <kallisti> ah. I'm still using 7.4
21:08:33 <Tekmo> kallisti: base-4.6, I think
21:08:40 <SrPx> guys, I think I've made an optimized 2^n function
21:08:46 <SrPx> > foo = let shift n l = drop n l ++ take n l; consecs l = take (length l) $ [take 2 l] ++ consecs (shift 1 l); rule1 a = (head a) + (last a); step l = map rule1 $ consecs l; a = ((take 100 (repeat 0)) ++ [1]) : map step a; pow2 n = sum $ last $ take (n+1) a in pow2 8
21:08:47 <lambdabot>   <hint>:1:5: parse error on input `='
21:09:02 <applicative> i have the mad plan of rewriting a pile of the statistics library with Foldl's.
21:09:11 <SrPx> > let shift n l = drop n l ++ take n l; consecs l = take (length l) $ [take 2 l] ++ consecs (shift 1 l); rule1 a = (head a) + (last a); step l = map rule1 $ consecs l; a = ((take 100 (repeat 0)) ++ [1]) : map step a; pow2 n = sum $ last $ take (n+1) a in pow2 8
21:09:12 <lambdabot>   256
21:09:16 <SrPx> :D where do I submit it
21:09:17 <Tekmo> SrPx: Isn't the optimized version to do exponentiation by squaring?
21:09:19 <Tekmo> :)
21:09:20 <applicative> bos preens himself telling us that some Vector Double -> Double function 'uses only one pass'
21:09:30 <applicative> but what if I want to apply three of them to one vector, etc
21:09:35 <SrPx> Tekmo: no, my version is much faster I've tested it
21:09:57 <kallisti> so what should I do instead of "hiding (catch)" to make my code work on both 7.4 and 7.6?
21:10:08 <edwardk> L' can avoid leaking, M can do searches and doesn't leak when it has content bolted on from either side, R can deal with (:) and [] without reassociating, L1 and L1' are mealy machines so they work so long as you feed them a non-empty container worth of content, M1 is a semigroup reducer which I have a lot of backlogged theory for, R1 is like a slowed down foldr1
21:10:16 <Tekmo> kallisti: You need a CPP pragma to guard it
21:10:22 <Tekmo> kallisti: I'll find an example for you
21:10:30 <kallisti> don't worry I know how to do that
21:10:36 <kallisti> I was just hoping I wouldn't :P
21:10:41 <applicative> kallisti: um, one possibility is import qualified Control.Exception as Ex and use Ex.catch instead
21:10:48 <Tekmo> The other option is to not use `catch` :)
21:10:50 <edwardk> baically L vs. R comes down to whether prefixing or postfixing content leaks memory
21:11:03 <applicative> kallisti: the 'literature' seems to use a variety of maneouvers
21:11:33 <applicative> kallisti: right, don't use catch use the errors library ;)
21:11:37 <edwardk> kallisti: either CPP pragma it, explicitly enumerate the imports from Prelude rather than the things you hide, or avoid catch entirely or import Control.Exception as E and use E.catch when you use it
21:12:09 <edwardk> Tekmo: i may go through and do a naming pass once i figure out what all the things i want to work with here ;)
21:12:21 <kallisti> I think I'll qualify catch. seems like the simplest solution
21:12:26 <applicative> kallisti: as you can see, there is agreement that there are hundreds of options, though most of them are how you import Control.Exception qualified
21:12:47 <kallisti> I'm using Control.Exception.Lifted actually, but it's the same principle
21:13:06 <enthropy> kallisti: import Prelude hiding (catch) -- works with ghc-7.6.2 here
21:13:20 <enthropy> even though catch isn't exported by that Prelude
21:13:33 <Tekmo> I think edwardk's suggestion of using a qualified `catch` is probably the best
21:13:50 <applicative> hey that was my suggestion! boo hoo
21:13:51 <haasn> edwardk: is Control.Exception.Lens compatible with both 7.6 and 7.4?
21:14:00 <kallisti> enthropy: I wonder if that's special cased, because hiding an undefined symbol from any other module would result in an error.
21:14:04 <edwardk> enthropy: if you turn on -Wall does it complain?
21:14:11 <enthropy> yes it's a warning
21:14:12 <edwardk> haasn: yes
21:14:35 <edwardk> enthropy: just making sure =)
21:14:47 <enthropy> it used to be an error, but to keep from breaking so much code that has hiding (catch) it's a warning
21:14:51 <applicative> enthropy I think 'hiding (catch)' actually broke stuff for a bit but they had to make it warning again.
21:14:55 <edwardk> exactly
21:15:03 <edwardk> that was my recollection fro the 7.6 switch over
21:15:12 <enthropy> rather hiding (somethingNotActuallyExported) -- is only a warning now
21:15:14 <edwardk> because as an error it caused little things like cabal to die
21:15:28 <edwardk> because old cabal generated code included the hiding (catch)
21:15:40 <applicative> haha
21:19:24 <applicative> Tekmo: I meant to add earlier that I think the secret advantage of your foldl library over other things like it was the sensible decision to export a pile of already written Foldl's
21:20:03 <Tekmo> applicative: Thanks!
21:20:08 <haasn> including batteries has been lens' success strategy
21:20:33 <edwardk> applicative: i definitely agree
21:20:41 <Tekmo> Well, the thing about lenses is that the lenses for your own types matter more
21:20:41 <Tekmo> With the exception of exceptions
21:20:44 <Tekmo> That's one thing where you need lots of prisms built in
21:20:46 <applicative> Tekmo: did i mention, it should have a separate average or mean; there is the question of the numerator overflowing
21:21:05 <applicative> despite this being the poster child for the foldl-in-amber idea
21:21:10 <haasn> Tekmo: speak for yourself, lens' standard library of lenses have been absolutely irreplaceable when it comes to IRC and GHCi golfing :)
21:21:40 <Tekmo> haasn: Haha
21:21:49 <Tekmo> haasn: Lens is THE irc library
21:21:54 <edwardk> i've been trying to formulate a version of those common folds that can work with the class driving the folds that i have. the problem with two things being parametric, one producing and one consuming arises. so i have to either make fixed type versions of all the folds or make fixed type versions of the applicators
21:22:01 <haasn> Tekmo: s/irc//
21:22:15 <Tekmo> applicative: What do you mean about overflowing?  You mean providing separate ones for `Double` and `Integer`?
21:22:41 <applicative> no, its just the obvious point that sum xs may make no sense, though average xs does
21:23:01 <edwardk> Tekmo: just that the naive sum xs / count xs overflows pretty easily
21:23:19 <Tekmo> edwardk: The point is that you don't compute it that way
21:23:33 <Tekmo> edwardk: You use `(/) <$> sum <*> genericLength`
21:23:59 <Hafydd> In what context does sum xs not make sense when average xs does?
21:24:01 <Tekmo> edwardk: `foldl` doesn't even expose a way to do it the naive way
21:24:08 <Tekmo> ^ Hafydd
21:24:24 <edwardk> um, that works for relatively small data sets, it even works for the most part for sums, but when you start moving up to higher moments they explode faster and faster
21:24:37 <Tekmo> edwardk: I don't understand what you are referring to
21:24:57 <applicative> wait maybe were confused let me try it with the foldl lib if its on here
21:25:03 <edwardk> computing varances as a running total of sum of squares naively is a great way to lose all your numerical precision.
21:25:10 <Tekmo> This was like the entire motivation behind `foldl`: computing `average` correctly
21:25:14 <Tekmo> http://www.haskellforall.com/2013/08/composable-streaming-folds.html
21:25:15 <edwardk> computing skewnesses and kurtoses get worse
21:25:19 <edwardk> sure
21:25:23 <edwardk> its just charmingly naive
21:26:03 <Tekmo> So what about kurtosis causes problems?
21:26:08 <Hafydd> Tekmo: are you trying indicate that the answer to my question is above?
21:26:25 <Tekmo> Hafydd: I meant that I agreed with your statement
21:26:30 <Hafydd> Oh.
21:26:37 <edwardk> take some numbers with reasonable ranges. now the sums of squares of them have bigger dynamic ranges, right?
21:26:44 <edwardk> the sums of cubes gets even bigger
21:26:52 <edwardk> the sums of fourth powers...
21:27:09 <edwardk> as you mov to higher and higher statistical moments you are getting bigger and bigger numbers with wild cancellations
21:27:41 <Tekmo> Are you saying that `foldl` is numerically unstable?
21:27:48 <edwardk> this is why we have robust one pass algorithms like terriberry's algorithm
21:27:59 <edwardk> i'm saying i wouldn't use it to chew through a lot of variances
21:28:07 <SrPx> oh my... Haskell is even more awesome than I thought, and I considered it pretty awesome ...
21:28:46 <h4199> SrPx, what have you disovered?
21:28:59 <edwardk> there do exist perfectly good monoids (Terriberry's) and there is a perfectly good left fold (Chan's) but adding up and dividing isn't that
21:29:14 <carter> this is for floating point usage right?
21:29:15 <edwardk> in fact you can do full on kahan summation as a left fold
21:29:17 <edwardk> sure
21:29:24 <edwardk> so destroying your significand is a real concern
21:29:48 <Tekmo> Ok, I just read the Wikipedia page on this.  I get it now
21:30:00 <Tekmo> In case others are interested, the relevant page is this:
21:30:00 <Tekmo> http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
21:30:04 <edwardk> ou get 53 bits of it. so say you have a 20 bit dynamic range in your content, sum of squares now uses 40 bits of significand, sum of cubes wants 60. so you're truncated. sum of 4th powers uses 80.
21:30:35 <edwardk> Tekmo: i have code for a pretty robust moments monoid that does kurtoses, etc
21:30:53 <edwardk> i also have 'compensated' which makes it so you can basically ignore the issue =P
21:31:52 <edwardk> as for the 20 bits of dynamic range, that isn't much to ask for given that you get it even if you add up something like 1s… when you deal with a million (2^20th) of them!
21:32:13 <edwardk> if you do a billion numbers, 2^30th dynamic range means the sum of squares won't even fit
21:32:38 <applicative> Tekmo: right, with the foldl library F.fold (div <$> F.sum <*> F.length) [1..2^32] = -2147483648
21:32:57 <Tekmo> applicative: Use `Integer` and `genericLength`
21:33:14 <applicative> Tekmo: right, but there is also an answer for Int and Double
21:34:01 <applicative> i hadn't known about edwardk having worked on such things but the statistics library has tons of foldls like this only it misexports them and mostly miswrites them
21:34:14 <edwardk> Integer is an answer for some data sets, but often i have a big bag of doubles. round tripping through rational and making the code 100x slower isn't really viable =)
21:34:38 <edwardk> applicative: i've been talking with carter about spending some time doing statistical-folds
21:34:46 <Tekmo> edwardk: Well, if somebody contributes the cold for the smart statistics I will accept the pull request
21:34:50 <Tekmo> *contributes the code
21:34:53 <applicative> oh really, that was the scheme i was advancing
21:34:54 <edwardk> that's one of the reasons why i put the package out there
21:35:22 <edwardk> Tekmo: mostly just wanted to make you aware of the issue
21:35:22 <carter> first i need to finish yak shaving on ghc having nice primops :)
21:35:24 <applicative> Tekmo: I was thinking of just pulling a bunch from the statistics library
21:35:49 <carter> Tekmo: a bunch of nice algs by edwardk  are in the multipass lib
21:35:50 <h4199> applicative: which are wrong?
21:35:53 <applicative> carter: stick with that, if you know what you're doing ;)
21:36:01 <Tekmo> I don't even know where to begin with navigating the `statistics` library
21:36:12 <carter> its huge and takes while to compile
21:36:16 <carter> and its bos's take on things
21:36:19 <applicative> h4199: oh what did i say was wrong?
21:36:29 <h4199> parts of the stats lib
21:36:36 <Tekmo> Also, if it's written by bos then I don't trust it
21:36:39 <applicative> Tekmo: yeah I know, its sort of bos's secret world
21:36:43 <carter> Tekmo oh?
21:36:45 <edwardk> it is best to have a working knowledge of statistics when going in and looking at the statistics package =)
21:36:45 <Tekmo> I'm pretty sure his criterion has a ton of statistical bugs in it
21:36:51 <carter> Tekmo YUP
21:36:52 <carter> i've hit them
21:37:02 <carter> it crashs if you only do 2-3 samples
21:37:14 <edwardk> carter: well, lots of things aren't defined down there
21:37:14 <Tekmo> Here, let me pull up an example I brought up on his repository
21:37:22 <applicative> his expertise is elsewhere, we're supposed to file bug reports
21:37:36 <edwardk> carter: but yes, it should be more careful about calculating undefined moments
21:37:49 <carter> applicative i like the edwardk  approach "gave me a solid pull request: you get commit bit"
21:37:52 <edwardk> applicative: well, he is quite responsive to pull requests
21:37:59 <Tekmo> Here: https://github.com/bos/criterion/issues/11#issuecomment-15376537
21:38:23 <edwardk> they merged my beta distribution into the statistics package from my order-statistics package before i even asked ;)
21:38:37 <carter> didyou get push powers on it then?
21:38:43 <SrPx> > let f 0 = 0; f (a+1) = a in f 3
21:38:44 <lambdabot>   <hint>:1:17: Parse error in pattern: a + 1
21:38:49 <SrPx> okay, I guess I was expering too much
21:38:58 <carter> n+k patterns are bad too
21:39:18 <carter> Tekmo: i'm yak shaving having nice prefetch intrinsics
21:39:25 <SrPx> does patterns work for something other than "a:b"?
21:39:55 <edwardk> carter: nah
21:39:57 <applicative> hm, the issue is closed without a clear account of the resolution it seems tekmo
21:40:01 <carter> shame
21:40:04 <joelteon> ooo, pipes 4.0 is out
21:40:08 <carter> joelteon yes
21:40:16 <applicative> is my memory wrong that he wrote the statistics library first for the sake of criterion?
21:40:28 <Tekmo> carter: There is a distinct pleasure about code going hyper-fast
21:40:30 <edwardk> applicative: afaik
21:40:32 <ekipan> > case lookup 2 [(1,'a'), (2,'b')] of Just x -> x
21:40:34 <lambdabot>   'b'
21:41:08 <joelteon> time to port
21:41:38 <applicative> Tekmo: in any case, I was recommending e.g. Statistics.Sample as exporting a bunch of stuff that should have been foldls-in-amber https://github.com/bos/statistics/blob/master/Statistics/Sample.hs
21:41:39 <edwardk> i'm hoping carter's prefetches help out with small COLAs in structures.
21:41:44 <ekipan> > case lookup 3 [(1,'a'), (2,'b')] of Just x -> x; Nothing -> '\u2639'
21:41:45 <lambdabot>   <hint>:1:63:
21:41:45 <lambdabot>      lexical error in string/character literal at character 'u'
21:42:07 <edwardk> it trounces data map on inserts for large enough maps, but loses for lookups
21:42:10 <carter> edwardk: well, that plus the local linear scans
21:42:11 <applicative> Tekmo: and the cases where div <$> sum <*> length become pretty clear in the discussion there and elsewhere
21:42:16 <edwardk> carter: yeah
21:42:18 <carter> edwardk: i may ahve to mod it to do pairs of ops
21:42:30 <Tekmo> applicative: What is this "in amber" thing? :)
21:42:34 <carter> because the whole point of the prefetches is to accelerate the binary search work
21:42:51 <applicative> Foldl op seed out is a 'foldl' in amber
21:42:59 <edwardk> Tekmo: just more or less 'captured in the moment'
21:43:02 <carter> and while the ffi will be < 5-10ns, that could still slow things down
21:43:03 <applicative> sorry, it's and edwardk contagion i took to
21:43:10 <applicative> i'm misusing it presumably
21:43:25 <edwardk> Tekmo: i referred to an M a b   as a 'foldMap in amber' in the haddocks for folds
21:43:34 <Tekmo> Oh, I get it! :)
21:43:58 <applicative> i should have spoken of e.g. a reified foldl or something, edwards idea is more fancy
21:44:36 <applicative> Statistics.Sample ought to be exporting reified Foldls rather than Vector a -> a functions
21:44:57 <edwardk> applicative: did you see all the let folds for adler32 and the crc variants i had in folds before ripping them out?
21:44:58 <applicative> if i want both samples, by hypothesis, i have to apply the function twice, his way.
21:45:02 <edwardk> er left
21:45:23 <applicative> edwardk: yes somewhere i saw them
21:46:30 <applicative> Tekmo: i was saying to edwardk the module is especially uncanny since the L'/Foldl concept is barely below the surface in Statistics.Sample
21:46:40 <edwardk> yeah
21:46:50 <applicative> i think you will have more respect for him when you observe this
21:48:13 <Tekmo> I have respect for him, just not for that particular library :)
21:48:26 <applicative> even the specifically existential character of the type; he defines several types in passing for specific funcions
21:48:52 <applicative> Tekmo: yeah i think the library is okay, it has just has too pretentious a title
21:48:58 <applicative> it should be, criterion-common
21:49:21 <Tekmo> I don't mind pretentious titles
21:49:32 <applicative> oh i hadn't noticed ;)
21:49:36 <Tekmo> :)
21:50:10 <edwardk> heh
21:50:20 <edwardk> can't say that i can complain about that aspect either ;)
21:50:36 <Tekmo> Well, *somebody* has to take that name
21:50:42 <edwardk> =)
21:50:44 <Tekmo> :)
21:56:26 <carter> who's going to take tubes
21:56:32 <carter> thats what I wanna know
21:56:45 <carter> maybe that should be for the next big networking lib
21:56:51 <Tekmo> Senator Ted Stevents
21:56:54 <Tekmo> *Stevens
21:56:56 <carter> its just a series of tubes right? :P
21:56:58 <carter> hehe
21:57:24 <carter> i may take tubes if i ever do a networking library and i want a silly name
21:57:37 <Tekmo> `tubular-1.0.0`
21:57:39 <shachaf> I'll wait for capillaries.
21:58:18 <carter> shachaf: that'll be for bluetooth and zigbee and such
21:59:06 <Tekmo> Also, I think somebody already had dibs on collapsible-fabric-pet-tunnel
22:00:04 <carter> ooooo
22:00:07 <carter> whats that one for?
22:00:13 <Tekmo> It's a joke :)
22:00:14 <carter> a childrens FRP lib?
22:00:25 <carter> i know, i was trying to push it further
22:00:28 <Tekmo> :)
22:00:51 <applicative> Tekmo: maybe if the above was put thus: there ought to be a 'mean' in Foldl that i can run on an unboxed vector; bos has one only he can't express it
22:01:08 <carter> but yeah, onething i've learned is that its general best to make your *.Internal.* modules exposed, for the power users
22:01:17 * hackagebot folds 0.3 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.3 (EdwardKmett)
22:01:20 * hackagebot hackage-proxy 0.2.0.0 - Provide a proxy for Hackage which modifies responses in some way.  http://hackage.haskell.org/package/hackage-proxy-0.2.0.0 (MichaelSnoyman)
22:01:21 * hackagebot http-reverse-proxy 0.2.1.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.2.1.1 (MichaelSnoyman)
22:01:23 * hackagebot project-template 0.1.3.1 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.3.1 (MichaelSnoyman)
22:01:25 * hackagebot cabal-install 1.18.0.1 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.1 (JohanTibell)
22:01:45 <edwardk> carter: the joke around the office for days before i shipped machines was that it should be called tubes
22:01:54 <carter> ok
22:01:55 <Tekmo> applicative: So I guess my question is how do you compute `mean` in finite precision in a numerically stable way?
22:02:05 <carter> noted
22:02:15 <shachaf> tibbe: Uh oh. Should I upgrade?
22:02:23 <edwardk> tekmo: take the first level of chan's algorithm
22:02:28 <Tekmo> edwardk: I loved the `Appliance` type class in `machines`
22:02:33 <edwardk> Tekmo: hah
22:02:39 <tibbe> shachaf: only if you're having issues
22:02:47 <carter> which issues?
22:02:51 <shachaf> OK.
22:02:53 <applicative> Tekmo: yes, i take it there are technical answers, that wont be ideally beautiful, but can in fact be packaged as Foldl's and used just fine in e.g (,,,) <$> mean <*> ... etc
22:02:54 <tibbe> shachaf: I believe the issue was due to how HP on OS X uses non-default Cabal install dirs
22:03:00 <carter> yup!
22:03:02 <shachaf> Ah.
22:03:17 <carter> i fixed mine up
22:03:30 <carter> i had some weird other linking errors i couldn't repro easily though
22:04:42 <applicative> Tekmo: how icky is the 'Welford' mean here https://github.com/bos/statistics/blob/master/Statistics/Sample.hs#L70
22:05:04 <Tekmo> applicative: I found the algorithm edwardk referred to on the wikipedia page
22:05:28 <applicative> ah. I prefer bos to wikipedia
22:05:57 <applicative> anyway, the harmonic mean is better, if only by dint of its name
22:06:46 <applicative> carter: do you know a lot of statistical nonsense, or sense rather?
22:06:57 <carter> sometimes
22:07:15 <carter> or at least the prior says "carter believes he does, though somtimes i have to look things up "
22:07:47 <carter> applicative is there a question to be asked?
22:08:28 <carter> Tekmo the wikipedia version is easier to read than the bos one for sure
22:08:32 <applicative> carter: no, I was just thinking about the question of a proper expression of some of these things as Foldls/L's etc, who could vet them if not write them, so to say
22:08:42 <carter> edwardk knows a lot
22:08:43 <applicative> no way, the bos one is in Haskel
22:08:53 <applicative> Haskell even
22:09:07 <carter> applicative: the thing is, once you're in floating point land
22:09:12 <carter> rather than exact numbers
22:09:20 <carter> the answer often turns into "it depends"
22:09:40 <applicative> i was about to intervene ... 'dont say it...'
22:09:58 <carter> eh?
22:10:07 <applicative> carter: about floating points
22:10:12 <carter> tough
22:10:13 <edwardk> welford's algorithm should just be level 1 of chan's
22:10:19 <applicative> anyway, forget the above, i was just collecting information
22:10:49 <carter> edwardk: yeah looks that way
22:11:22 <tel> oh: Chan-the-person's
22:11:26 <edwardk> if you dig through old patches on github.com/analytics/analytics you'll find my moments comonad. i don't think it got split out into the analytics diaspora when the project refocused
22:11:37 <tel> I got worried you were looking into parallel moment calculations
22:11:50 <carter> tel no 4chan
22:11:51 <carter> :P
22:11:56 <applicative> i wish i could join some scientific project for a year or two as assistant haskell crank and figure out what is really needed for some of these things
22:12:05 <carter> applicative do it!
22:12:07 <edwardk> tel: no, that very thing
22:12:29 <carter> applicative write gpu codes in haskell
22:12:36 <edwardk> tel: i have a whole bunch of stuff for parallel moment calculations =P
22:12:40 <Tekmo> applicative: Scientists produce the shittiest code
22:12:48 <tel> Tekmo++
22:12:50 <edwardk> and various other summary data
22:12:57 <tel> edwardk is this in analytics?
22:13:07 <Tekmo> The problem is that everybody in science is horribly underpaid
22:13:09 <edwardk> tel: it was. if you go back enough patches you'll find a moments monoid
22:13:12 <Tekmo> So all the good programmers just leave
22:13:17 <applicative> yes, but if we had an impossibly beautiful and impossible clear and perfect etc. pile of libraries etc etc
22:13:22 <tel> edwardk ah ah, secret stuff
22:13:27 <applicative> they wouldn't care...
22:13:54 <tel> edwardk I may look that up. I have some NUTS code that I want to revisit soon and all this fold stuff would plug into it nicely
22:14:00 <carter> Tekmo: plus everyone gets all esoteric to exoticify their research
22:14:08 <carter> tel ooooo
22:14:10 <edwardk> tel: hamitonian monte carlo?
22:14:13 <tel> yup
22:14:22 <edwardk> tel: nice. i'm currently NDA'd out of that space =(
22:14:22 <carter> tel you do realize edwardk  spent time hacking on that?
22:14:29 <tel> :(
22:14:41 <carter> nda'd in exchange for money though!
22:14:45 <carter> (right?)
22:15:00 <carter> though i guess thats the only nda's anyone shoudl do, right?
22:15:37 <applicative> tel, you don't need this information form carter; it's a priori knowledge
22:15:48 <applicative> i should go; good luck with the Pipes-4 inauguration Tekmo!
22:15:53 <Tekmo> Thank you!
22:16:00 <edwardk> tel: https://github.com/analytics/analytics/blob/1788912c838f8070b374e0a6effa1283c9ae9195/src/Data/Analytics/Numeric/Moments.hs appears to have some of the moment calculations in it
22:16:11 <tel> I have just so many old cruddy BUGS scripts from darker days—Stan is really nice but, obviously it not being in Haskell is a problem
22:16:13 <edwardk> carter: yes =)
22:16:24 <tel> oh! It's sunday—pipes-4!
22:16:34 <edwardk> tel: we should talk monte carlo some time
22:16:44 <tel> edwardk I'd love to :)
22:16:48 <edwardk> not many people in the haskell space who knows what NUTS is
22:16:54 <Tekmo> tel: Yeah, it was a slightly early release
22:16:54 <edwardk> bgamari and a few others
22:17:24 <Tekmo> edwardk: That's not a very Google-friendly name
22:17:36 <edwardk> No U-Turn Sampling Hamiltonian Monte Carlo
22:17:53 <tel> from Andrew Gelman out of Columbia
22:17:54 <edwardk> it is a trick by a student of gelman's to make it so you don't have to tune how far your hamitonian monte carlo sampler goes
22:18:32 <tel> that stuff totally dominated my undergrad, then I stepped away in grad school toward speech processing
22:18:42 <edwardk> ou can combine it with nesterov's dual averaging to tune the step size, and the Riemann manifold hamiltonian monte carlo stuff to tune the 'flick' strength and you have more or less a parameter free HMC.
22:18:47 <carter> i really wanna resume playing with MCMC sometimeee
22:19:41 <edwardk> basically the RMHMC approach may not always be cost effective inverting that tensor is O(n^3) in general, but it makes it so you don't have any parameters left, which is gorgeous
22:20:18 <SrPx> > 2^0.5
22:20:19 <lambdabot>   Could not deduce (GHC.Real.Integral b0)
22:20:20 <lambdabot>    arising from a use of `GHC.Real....
22:20:21 <SrPx> ?
22:20:28 <Tekmo> 2**0.5
22:20:33 <SrPx> Ty
22:20:44 <Tekmo> > 2**0.5
22:20:45 <lambdabot>   1.4142135623730951
22:20:49 <SrPx> (What is the ^ for then?)
22:20:52 <Tekmo> (^) requres an integral exponent
22:20:54 <tel> (while also just generally being HMC so you don't get terrible convergence problems :)
22:21:04 <edwardk> tel: yeah
22:21:08 <SrPx> HMC?
22:21:13 <Tekmo> I'm guessing because it presumably uses a more efficient exponentiation-by-squaring
22:21:17 <edwardk> hamiltonian monte carlo
22:21:33 <SrPx> ... oh, sure. I know those words
22:21:47 <tel> normal monte carlo does hill climbing based essentially just on position
22:21:58 <tel> hamilltonian adds in a momentum term
22:22:18 <edwardk> http://www.cs.utoronto.ca/~radford/ftp/ham-mcmc.pdf is probably the best intro
22:23:00 <tel> the momentum makes your sampler less likely to get "stuck" in narrow parts of your parameter space
22:23:38 <edwardk> basically normally what you do to do MCMC, is you try to draw independent random samples from a distribution using some way to get correlated samples. you find some point on the distribution which has non-zero probability density. then you apply some kind of perturbation of candidate selection function to it subject to certain conditions about symmetry and you accept 'better' positions (with higher density) all the time, and
22:23:38 <edwardk>  'down hill moves' some of the time
22:23:44 <joelteon> does ghci have a command for expanding type synonyms?
22:23:59 <Tekmo> joelteon: Try `:i TypeSynonym`
22:24:39 <edwardk> if you take a snap shot of your moves every so often, it moves like a stop motion video, and you see the point jumping around the distribution. there is a whole study of how often to sample, etc. but the idea stays the same. this is metropolis hastings.
22:25:26 <edwardk> it is used to sample from a probability density function you don't know the full c.d.f for. e.g. you know something proportional to the p.d.f but not the actual constant needed to normalize it to a c.d.f.
22:25:58 <edwardk> now if you know a bit more about the distribution than just the value of the p.d.f for a given point you can do more. the first optimization you can do is use the derivative of the p.d.f at a given point
22:26:26 <edwardk> if you know that (well, the derivative of the thing you have that is proportional to the p.d.f) then you can use it to bias your samples uphill to get better accept rates
22:26:38 <edwardk> this gives you MALA, or the metropolis adjusted Langevin algorithm, but it kinda sucks
22:26:44 <tel> (and if you've been automatically computing it all along… :)
22:26:49 <edwardk> it works a little bit better than knowing nothing
22:27:02 <edwardk> and if you have automatic differentiation.. then its free =)
22:27:24 <edwardk> HMC works differently, what we do is try to make 'big moves' that have high acceptance probability
22:27:29 <Tekmo> You know, this is why libraries exist
22:28:03 <edwardk> the main problem you have with MCMC in general is the curse of dimensionality, if you're making a bunch of random moves, lots of them will be fighting your forward progress moving you back the way you came.
22:28:15 <edwardk> and it can be very hard to cross a long thin valley
22:28:49 <edwardk> so what HMC does is replace your position, with a position and a momentum, it picks the momentum randomly instead of the new destination randomly
22:28:52 <dwcook> Are there operations in some module supporting a container that, equivalently, either imposes a unique restriction on a list or adds order to a set?
22:29:06 <dwcook> s/unique/uniqueness/
22:29:40 <edwardk> then it runs a hamiltonian simulation of a frictionless pick skittering around on your function (suitably turned upside down and logarithmed). this means you'll shoot down into peaks (now valleys) and come out the other side after some amount of time
22:29:47 <Tekmo> dwcook: `Data.Set` from `containers` requires that all elements are unique and also keeps them sorted
22:30:14 <edwardk> but most of the time you'll be a just a bit lower than when you went in, the hamiltonian simulation makes it so when you go down you keep all that energy
22:30:19 <edwardk> s you'll come back up
22:30:55 <Tekmo> edwardk: So in other words, it simulates a ball rolling around with no friction or any other dissipative force?
22:30:55 <edwardk> the first way to do this used some fixed number of steps, say 150 steps, and some fixed sizes you had to guess at for the steps, in some made up notion of time that was bolted on side-ways to the model
22:31:00 <Tekmo> edwardk: But with some element of randomness?
22:31:02 <dwcook> Tekmo, oh good, I was unaware that imposed order. Sounds perfect. Thanks.
22:31:07 <edwardk> tel: feel free to fix up what i'm saying if i tell any obvious fips
22:31:10 <edwardk> er fibs
22:31:11 <Tekmo> dwcook: You're welcome!
22:31:24 <tel> edwardk semi-afk but it sounds great so far ;)
22:31:41 <dwcook> Tekmo, woops, sorry, I both misunderstood what you meant and didn't full state the problem.
22:31:41 <edwardk> Tekmo: yeah. basically we 'flick' the sample every so often and see where it goes, then accept or reject the new position the same old way
22:31:55 <Tekmo> edwardk: I understand how normal monte-carlo works
22:31:55 <dwcook> I want to impose an *arbitrary* order, not based on the type itself.
22:31:57 <edwardk> and we just look at it after a while
22:32:19 <edwardk> now, we still had some magic 150 steps constant in our system
22:32:29 <edwardk> NUTS is a way to eliminate that
22:32:45 <joelteon> ok, pipes-4.0 is confusing so far
22:32:49 <Tekmo> dwcook: I usually hack around this by wrapping the elements in a newtype with a custom `Ord` instance
22:33:04 <AfC> Tekmo: congrats on pipes-4.0
22:33:05 <edwardk> what it does is turn this into a 'slice sampling' problem, by basically building a tree up from the current position along the direction we've selected as our momentum, but to remove bias it builds the tree randomly forward or back at each step
22:33:09 <Tekmo> AfC: Thanks!
22:33:10 <joelteon> Tekmo: pipes is awesome
22:33:14 <pharaun> pipes 4.0 is the stable api now?
22:33:15 <edwardk> doubling in size each level
22:33:19 <Tekmo> joelteon: Thank you :)
22:33:21 <Tekmo> pharaun: Yes
22:33:23 <joelteon> Tekmo: can i badger you incessantly over the next few hours?
22:33:23 <AfC> pharaun: yes
22:33:23 <pharaun> i remember reading while it was on 3.0ish
22:33:27 <Tekmo> joelteon: Yes
22:33:29 <joelteon> ok
22:33:32 <joelteon> thanks
22:33:35 <pharaun> Tekmo: sweet! hella yes i'm going to give this a shot then :)
22:33:42 <pharaun> i just hope the http part isn't too tricky to do
22:33:58 <Tekmo> Are you Silicoid from /r/haskell?
22:33:59 <edwardk> and it looks for when the vectors at the end points of the tree would be heading in opposite directions
22:34:14 <edwardk> that means you'd have turned around and started skittering back down a valley towards where you came from
22:34:27 <edwardk> so the path after that point would be partially redundant with how you got there
22:34:41 <edwardk> so NUTS then slice samples the tree so far, picking a point along the way
22:34:53 <edwardk> and it can do so without introducing bias
22:34:55 <edwardk> its quite clever
22:36:39 <edwardk> anyways, that is what NUTS is
22:36:46 <tel> the whole tree-sampling bit for volume preservation is fantastic
22:37:29 <enthropy> dwcook: if you have  (Map a Int, Map Int a),   with Int being the index into the list `a' being your values that might be able to do what you ask for
22:37:39 <pharaun> Tekmo: me? i'm not :)
22:37:43 <edwardk> i'm a big fan of NUTS based HMC for big continuous models
22:37:56 <enthropy> ixset on hackage has that kind of representation, but maybe there are alternatives
22:37:57 <Tekmo> pharaun: Oh, I was just asking because somebody on /r/haskell named Silicoid was asking about http stuff, too
22:37:57 <edwardk> like the ones that come up in metropolis light transport
22:38:01 <pharaun> ahh
22:38:43 <pharaun> Tekmo: basically i've been using http-conduit for bunch of streaming/downloading stuff and i was looking at the pipes api and i really liked the api and yeah. I'm going to have to try to do an equivalent in pipes :) (re http)
22:39:07 <Tekmo> So I can point out one `pipes` idiom which is unique
22:39:24 <Tekmo> Other streaming libraries can use this idiom, but I haven't seen them do it yet
22:39:39 <Tekmo> It's the trick that `pipes-parse` does for subdividing streams using `FreeT`
22:39:57 <carter> does it relate to being able to ask how much to get fed?
22:39:59 <tel> edwardk I'd never heard of metropolis light transport
22:40:02 <Tekmo> carter: No
22:40:08 <dwcook> enthropy, I think for the sake of simplicity and just getting it working, I'm just going to use a list and do a membership check on insert, for now.
22:40:09 <tel> edwardk I've always used this stuff for big gnarly graphical models
22:40:45 <dwcook> If I need something fancier later, I can adopt it without changing the interface, probably.
22:40:48 <edwardk> metropolis light transport is basically one of the main reasons why i learned bayesian statistics
22:41:11 <h4199> wait, edward, the algorithm "frictionless momentums" down a valley and up to the other side the NUTS stops it from "falling back in", how is that case handled when NUTS is not employed?
22:41:12 <edwardk> that and that pesky wanting to graduate thing later
22:41:22 <Tekmo> pharaun: Anyway, the best place to begin is Andrew Cowie's `http-streams` library
22:41:23 * hackagebot conduit 1.0.7.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.7.4 (MichaelSnoyman)
22:41:25 * hackagebot conduit-extra 0.1.0 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.0 (MichaelSnoyman)
22:41:33 <edwardk> h4199: by cutting off at some point and picking some point along the path
22:41:37 <tel> edwardk do you have a ref on it? Or just the siggraph paper?
22:41:43 <h4199> ah, k
22:41:59 <carter> @hackage http-streams
22:42:00 <lambdabot> http://hackage.haskell.org/package/http-streams
22:42:10 <edwardk> tel: i have lots of references, but they maybe should go off channel
22:42:28 <carter> edwardk tel its on topic for #haskell-numerics :)
22:42:39 <tel> MCMC tuning is especially painful since it's non-deterministic and sometimes hard to measure whether it's working "well" or not
22:43:11 <carter> except when you can prove quantitative convergence… which sin't with the intersting models right?
22:43:21 <tel> edwardk we can move it, though I'm probably sleeping soon so any deeper talk will be another night :)
22:43:32 <edwardk> tel: lets pick up another time then
22:43:43 <tel> lets :)
22:43:57 <carter> i should wander off t
22:43:59 <carter> night all!
22:44:05 <Tekmo> Good night
22:44:10 <tel> g'night :)
22:44:15 <edwardk> I have to drive up to new hampshire tomorrow stupidly early, so i'm frantically pushing out code before i forget =)
22:44:21 <carter> ick
22:44:23 <carter> enjoy
22:44:44 <tel> and Tekmo, congrats on the pipes rollout
22:44:48 <pharaun> Tekmo: thanks for the pointer :)
22:44:59 <Tekmo> pharaun: You're welcome!
22:45:02 <Tekmo> tel: Thanks :)
22:45:11 <carter> Tekmo what tel said
22:45:22 <Tekmo> carter: Thank you!
22:45:27 <carter> Tekmo: though you know i've been a lurker on pipes developement for 1-2 years now?
22:45:35 <carter> even the pipes-core stuff too
22:45:38 <Tekmo> carter: I know
22:45:49 <Tekmo> carter: I remember you commenting way back on one of the earliest releases
22:46:02 <carter> "something thats not iterateees, OMG"
22:46:05 <carter> probably, right?
22:46:23 <carter> then conduits followed suit around then?
22:46:23 * hackagebot project-template 0.1.3.2 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.3.2 (MichaelSnoyman)
22:46:25 * hackagebot resourcet 0.4.8 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.8 (MichaelSnoyman)
22:46:27 <Tekmo> It was some question about the old push composition
22:46:27 * hackagebot cprng-aes 0.5.2 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.5.2 (VincentHanquez)
22:46:34 <carter> oh push vs pull
22:46:42 <carter> and trying to understand semantics
22:46:46 <Tekmo> carter: Yeah
22:46:58 <pharaun> hah thanks carter i was about to go search hackage for that one (http-streams)
22:47:17 <Tekmo> pharaun: You will also want to check out `pipes-bytestring`: https://github.com/Gabriel439/Haskell-Pipes-ByteString-Library
22:47:18 <carter> the @hackage  package-name command rocks
22:47:25 <Tekmo> pharaun: However, I can't complete that until after I graduate
22:47:33 <pharaun> course load?
22:47:40 <Tekmo> I'm writing up my thesis
22:47:42 <carter> phd thesis load
22:47:44 <Tekmo> Yeah
22:47:44 <pharaun> ahh
22:47:49 <pharaun> oof, best of luck!
22:47:54 <Tekmo> Thanks :)
22:51:24 * hackagebot cereal-conduit 0.7.1 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.1 (MylesMaxfield)
22:51:26 * hackagebot crypto-numbers 0.2.1 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.1 (VincentHanquez)
22:58:24 <threestrikes> @hoogle filepath
22:58:25 <lambdabot> Prelude type FilePath = String
22:58:25 <lambdabot> System.IO type FilePath = String
22:58:25 <lambdabot> System.FilePath.Windows type FilePath = String
23:05:05 <threestrikes> @hoogle elem
23:05:05 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
23:05:05 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
23:05:05 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
23:05:27 <threestrikes> @hoogle filter
23:05:27 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
23:05:27 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
23:05:27 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
23:06:44 <enthropy> do other people use the haskellmode for vim?
23:07:25 <enthropy> does :DocIndex also stop calculating when the output fills up?
23:08:05 * enthropy guesses this is a vim issue
23:12:03 <leroux> enthropy: I just ran it and it seems like it takes a bit of time to finish.
23:12:07 <leroux> Took about 15sec for me.
23:14:24 <hari_> Would love some feedback on this: http://harishankar.org/blog/entry.php/musings-on-functional-programming-and-haskell
23:15:49 <leroux> hari_: Reading it now.
23:16:02 <enthropy> leroux: yes it takes a long time. But the hundreds of lines about "populating g:haddock_index from haddock index files in" just scrolled by?
23:16:45 <enthropy> in my case it got stuck after one page and needed to be told to move on (space or page down)
23:16:47 <leroux> enthropy: Initially it looked like it was completely stopped, but then suddenly it `less`'s everything.
23:16:54 <leroux> enthropy: That means it's done.
23:17:11 <enthropy> or I just commented out the echo lines
23:18:06 <leroux> I get all the populating lines.
23:18:22 <hari_> leroux, thanks.
23:19:46 <leroux> hari_: No pun intended in "All said and done, FP, especially as viewed through the lens of Haskell, is tough."?
23:20:49 <leroux> hari_: It looks great.
23:21:10 <leroux> You can gather more feedback on the haskell reddit.
23:21:14 <hari_> leroux, no pun intended.
23:21:18 <pharaun> hari_: i liked the article its a nice one
23:21:42 <hari_> pharaun, thanks.
23:22:27 <hari_> I think the problem about "unfamiliar problem domain" is one reason I discovered that FP is tough
23:23:00 <pharaun> one thing i've found that is helpful sometime it to implement projects you've done in other language as a way to compare
23:23:12 <pharaun> or are already familiar with that domain so you can focus on learning the fp/haskell stuff
23:23:16 <hari_> pharaun, yes.
23:23:32 <hari_> RWH has a chapter on reading barcode from an image.
23:23:57 <hari_> That is kind of where I found it extremely tough to follow along.
23:24:35 <shachaf> @quote kmc incompatible
23:24:35 <lambdabot> kmc says: Haskell is a language where the community observes that there are 50 incompatible error handling monads, and the response is 50 incompatible packages for generically handling all error
23:24:36 <lambdabot> handling monads
23:25:52 <pharaun> hari_: yeah i wasn't a fan of that chapter myself *shrugs* was able to manage it but yeah
23:26:45 <fylwind> what's the command to look at intermediate Haskell and/or C code when compiling w/ -O ?
23:26:46 <hari_> pharaun, RWH is a good book, but later chapters are quite densely packed.
23:36:25 * hackagebot tls 1.1.5 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.5 (VincentHanquez)
23:41:25 * hackagebot cipher-blowfish 0.0.2 - Blowfish cipher  http://hackage.haskell.org/package/cipher-blowfish-0.0.2 (VincentHanquez)
23:44:16 <threestrikes> can this "let containsExtension w (ws,_) = w `elem` ws) be written with w being any character I want?
23:44:32 <Taneb> Yeah
23:45:27 <Taneb> You could even say "containsExtension wow_Haskell_is_cool (ws,_) = wow_Haskell_is_cool `elem` w" if you wanted
23:45:41 <Taneb> But that is awful style
23:45:55 <shachaf> Taneb: Wait, multi-character names?
23:45:58 <shachaf> Is that a new extension?
23:46:12 <Taneb> shachaf, I think it was added in GHC 7.6
23:46:25 * hackagebot cipher-des 0.0.4 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.4 (VincentHanquez)
23:46:41 <Taneb> threestrikes, just to be clear, shachaf was joking there
23:46:50 <shachaf> Anyway, yes. Talking about how cool Haskell is in your Haskell code is considered bad style.
23:48:01 <threestrikes> ic
23:58:33 <SrPx> Hmm so I'm looking through Data.Vector and it seems like it beats lists on pretty much all functions (in O complexity), so why are functions the standard structure?
23:59:42 <jfischoff> are you asking why use []?
23:59:48 <Taneb> SrPx, lists are easier to define (MUCH easier), have quicker cons, and allow for infinite lists
