00:00:45 <erisco> wagle, will you use average, median, or mode?
00:01:45 <wagle> not sure how to describe what I want
00:02:52 <erisco> in a recent survey, 2 spaces was determined as the best indentation for Haskell
00:02:58 <johnw> I use 4
00:03:09 <johnw> I do find it forces me to split out sub-functions more
00:03:21 <johnw> I used to use 2.  They are equally easy to get used to, imo
00:03:45 <ion> johnw: Try 20, it’ll force you to do that even more!
00:03:46 <shachaf> I use seven spaces followed by a tab.
00:04:27 <johnw> shachaf: you could add Unicode thin spaces as an improvement
00:04:38 <scshunt> shachaf: for any reason other than to be different?
00:04:42 <ion> I write everything on a single line, no indentation needed.
00:05:18 <fylwind> ion: can you actually do that?
00:05:31 <wagle> acgually the problem is that aquamacs is ignoring my ~/.emacs file
00:05:56 <wagle> actually
00:06:06 <wagle> let me fix that
00:06:11 <ion> fylwind: FWIW, yes.
00:06:16 <shachaf> Unless you use CPP.
00:08:39 <Ghoul_> I use 8 spaces for indentation
00:08:49 <Ghoul_> but most syntax isn't important so I use 1 space
00:12:18 <wagle> the indentation modes arent working in emacs, they just throw up a dialog with ambiguous instructions
00:17:56 <wagle> ok, solved it..  my agda mode stuff was failing, and so the .emacs file exited before it got to my haskell configuration
00:18:26 <Maxdamantus> Why can't people just use something like vim's copyindent?
00:18:55 <Maxdamantus> You don't need special indentation rules for every language. You just need to know how you want it indented.
00:18:59 <ksf> why can't people just use vim?
00:19:18 <Maxdamantus> I suspect emacs has something like it too.
00:19:44 <Maxdamantus> (copyindent simply copies the spaces/tabs from the previous line when creating a new one)
00:20:07 <ksf> well, emacs has a nice raytracer and I guess also email and irc client, but I wouldn't vouch for the editor.
00:20:40 <shachaf> I think that's enough editor war.
00:21:16 <wagle> i used vim to edit my .emacs file
00:21:24 <ksf> that's the spirit.
00:25:59 <ion> @quote emacs
00:25:59 <lambdabot> emacs says: [comment just above a bug in haskell-mode's elsip file] ;; Not sure if it's useful/needed and if it actually works"
00:27:13 <mstksg> emacs problem?  just use vim </unhelpful comment for the day>
00:55:45 <ksf> which library pioneered the functor model of extensible records? grapefruit?
01:23:32 <wagle> is it possible to test the components (top level function defn's) of a ghc style main program file in, say, ghci?
01:45:12 <monoidal> wagle: yes, load it ghci <filename> or :l <filename>, if you don't see the definitions :l *<filename>
01:45:50 <haasn> monoidal: what does the * do?
01:46:22 <wagle> monoidal: hmm..  tried ghci <filename>, and it couldnt see the top level defn's
01:46:30 <monoidal> haasn: it loads everything that is in scope
01:46:35 <monoidal> wagle: what about :load *Main?
01:46:37 <haasn> wagle: I think you may need to “import ModuleName” too
01:46:54 <haasn> (though I think it happens automatically for module Main? not sure)
01:47:02 <monoidal> wagle: or, remove *.hi and *.o files
01:47:18 <wagle> right now, I'm just using the IO monad..  ok
01:50:09 <wagle> this worked, thanks!  : Prelude> :l *soln1.hs
01:50:11 <monoidal> wagle: alternative: put "module Main where" in your file
01:50:19 <monoidal> wagle: i.e. export everything
01:56:39 <wagle> aww..  i'm going to have to use a monad to track all my state variables
02:06:17 <johnw> wagle: do you need to modify the state variables?
02:06:59 <wagle> sorta kinda..  i'm just making fun of myself for being squeamish
02:07:55 <wagle> I'm explicitly winding a state monad through my code
02:08:14 <johnw> I ask because if you don't need to modify state, the 'reflection' package offers an alternative
02:08:25 <johnw> with that library, you thread a constraint through your functions, rather than a reader monad
02:08:38 <johnw> but if you need to manipulate the state, you do need a monad
02:08:55 * hackagebot ghc-mod 3.1.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.1 (KazuYamamoto)
02:11:59 <wagle> like: oh noes!  I need to use the Maybe monad now, and I'm afraid!  (because its been a while)
02:12:25 <maxiepoo> don't fear the monad
02:13:37 <wagle> well, I am doing thiis algorithms course in haskell, and the other one in java for the reason of learning both approaches
02:13:53 <johnw> the maybe monad is fun!
02:14:07 <mcstar> maybe the monad is fun!
02:14:40 <johnw> i just used MaybeT yesterday in a way that turned out to be super cool
02:14:46 <wagle> if i dont watch out, I'll have to use transformers
02:15:17 <johnw> transformers are inevitable
02:15:31 <johnw> there's only so much energon in the universe
02:17:02 <johnw> Cale: ping
02:17:20 <Cale> hi
02:17:27 <johnw> thanks for your astar library!
02:17:33 <Cale> no problem
02:17:54 <johnw> i made a version that uses IntMap and IntSet, rather than 'Map k a' and 'Set a'
02:18:07 <johnw> err, Set k
02:18:36 <johnw> i'm using it here: https://github.com/ledger/ledger4/blob/master/commodities/Data/Commodity.hs
02:20:18 <Cale> cool
02:20:59 <johnw> after looking at the various graph libraries, I realized I didn't need a graph representation, I just need a flexible A* algorithm with a HOF interface
02:21:07 <johnw> and there was astar, made to order :)
02:22:57 <Cale> Yeah, I wrote astar after needing to implement one during an ICFP competition and not finding much. I realised shortly after that it's possible to write one which is actually agnostic about graph representation.
02:23:19 <Cale> Really, we could probably write most graph algorithms like that.
02:23:59 <mcstar> http://i.imgur.com/Dder3.png -- A* finding a route from purple to yellow, blue is wall, red is visited
02:25:34 <johnw> Cale: yeah, your idea of representing a graph as a function 'a -> Set a' was what I needed
02:33:24 <mauke> http://mauke.hopto.org/stuff/javascript/a-star/main.html - I don't know whether it's actually A* but it looks nice
02:34:42 <Cale> Something looks wrong there
02:34:54 <Cale> Maybe the heuristic is bad
02:35:01 <mcstar> mine is not animated http://i.imgur.com/3XxRW.png
02:35:39 <Cale> mauke: Are you using Euclidean distance for the heuristic?
02:35:57 <mcstar> a* should always try the best route accoring to heuristic, which is usually just the distance between the head and the target
02:36:13 <mauke> Cale: manhattan
02:36:21 <Cale> hmm, even so
02:36:33 <Cale> It looks like it's exploring not-best-first
02:38:29 <mcstar> mauke: it borked, i tried refresh and nothing happens, blank canvas
02:39:15 <Maxdamantus> A* probably wouldn't be suitable for normal mazes.
02:39:33 * Maxdamantus remembers using a screensaver that looked like something else.
02:39:36 <Cale> It's not terrible for normal mazes
02:39:41 <mauke> mcstar: try a hard reload (shift-f5 or ctrl-f5?)
02:40:03 <Cale> (but somehow I don't think mauke's javascript thing is actually A*)
02:40:10 <mcstar> mauke: worked
02:40:58 <Cale> lol, this one's going to be fun, there's no route to the goal
02:41:05 <Maxdamantus> Yeah, "Maze" in xscreensaver.
02:41:32 <Maxdamantus> it seems to try random directions and disqualify sections from being plausibly useful.
02:42:55 <mcstar> i wonder what 'field' is in mauke's code
02:43:19 <mauke> the playing field
02:43:39 <mcstar> you add the value of field to the heuristics to get the weight? (it was quite some time i implemented a*...)
02:43:46 * Maxdamantus remembers writing something to do with mazes in an assignment a few years ago.
02:43:54 * Maxdamantus looks.
02:44:11 <mauke> uh, I haven't looked at this code in a while
02:44:37 <Maxdamantus> Ah, leftwalker.
02:44:53 * Maxdamantus wonders if it handled islands.
02:45:58 <mauke> mcstar: are you talking about get_next(q)?
02:46:12 <mcstar> yes
02:46:33 <mauke> q is the queue of potential tiles to visit next
02:46:54 <mcstar> also, i remember, it was easy to write a wrong weight function, that could destroy optimality (the alg. wouldnt find the optimal route) but was faster in practice
02:47:04 <Maxdamantus> Try this one: http://upload.wikimedia.org/wikipedia/commons/c/cf/MAZE.png
02:47:08 <mauke> field.at(loc).g is the length of the path needed to reach loc
02:47:21 <Maxdamantus> There are apparently two solutions.
02:47:24 <mauke> dist(loc, z) is the distance left from loc to the target z
02:47:51 <Maxdamantus> (presumably that means shortcutting any cycles that might occur)
02:48:22 <Cale> Is q not a priority queue?
02:48:29 <mauke> it's an array :-)
02:48:34 <Cale> ah, okay
02:48:46 <Cale> I think that's why it's exploring too many tiles a lot of the time
02:49:16 <Cale> When it goes to the queue to get the next tile to explore, it should always start with the best one
02:49:23 <mauke> it does
02:49:27 <Cale> hmm
02:49:36 <mcstar> thats why the 'splice' i guess
02:49:38 <mauke> it loops over the whole array and tries to find the tile with the smallest f
02:49:43 <Cale> I've seen things which seemed to contradict that :P
02:49:47 <mcstar> to maintain priorities
02:50:55 <mcstar> i remember i was scolded when i told on #lisp that i wanted to use a list to implement a priority queue :)
02:51:12 <mauke> pfft
02:51:19 <Cale> It's definitely not picking the closest yellow tile every time
02:51:36 <mauke> Cale: are you sure?
02:51:40 <Cale> I'm sure
02:51:50 <mauke> well, closest to what?
02:51:55 <Cale> to the goal
02:52:01 <mcstar> mauke: i tried fibonacci heaps and other heap based priqueues, and the list based was faster for the sizes of my problem :)
02:52:01 <mauke> does it have to?
02:52:05 <Cale> If the main line gets blocked, it'll go back to some rather old yellow tile
02:52:22 <mauke> Cale: yes, because it tries hard not to go "backwards"
02:52:23 <Cale> rather than one which has lowest heuristic distance
02:52:39 <mcstar> Cale: but remember, it has to keep optimality...
02:52:50 <mauke> it minimizes g+h, not just h
02:53:40 <Cale> hmm
02:55:00 <mauke> it has to explore the whole bounding rectangle of (start, goal) before stepping outside
02:55:02 <Cale> But it looks like it's picking tiles to explore which go in the opposite direction when it has better options!
02:56:14 <Cale> Maybe I'm wrong :)
02:56:20 <mauke> reload
02:56:28 <mauke> I changed one character :-)
02:57:10 <mauke> looks like it's switched to a kind of breadth first search
02:58:41 <mcstar> actually this looks more like the A* i remember
02:59:18 * Maxdamantus wonders how inefficient the fake A* is he implemented over Dijkstra's algorithm.
02:59:18 <mauke> the difference is how it chooses from tiles with the same weight
02:59:31 <mauke> it used to pick the last one; now it picks the first one
02:59:41 <mcstar> clever :)
02:59:43 <Maxdamantus> where it simply added the distance to the cost.
02:59:45 <Cale> ah, yeah, maybe try Euclidean metric, it's admissible even if unrealistic
03:00:14 <Cale> and you'll get fewer ties
03:00:18 * mauke reloads
03:01:33 <ksf_> zomg.
03:01:47 <ksf_> I can get better error messages by enabling -XIncoherentInstances
03:07:54 <mauke> Cale: I've made another tweak
03:08:32 <mauke> manhattan distance, ties are broken by choosing tiles closer to the target
03:08:40 <Cale> cool
03:09:20 <mcstar> http://sprunge.us/Waig?cl -- i wonder what this one does
03:09:32 <Cale> yeah, that seems much more optimal now, if not as colourful :)
03:10:28 <ksf_> are closed type classes planned?
03:12:06 <Ghoul_> wow "getEntropyPool" is insanely slow
03:12:36 <Ghoul_> It's been running for about a minute on my hardware
03:12:41 <Cale> Ghoul_: What library is that part of?
03:12:53 <Ghoul_> crypto-random
03:13:20 <mauke> inb4 /dev/random
03:13:26 <Ghoul_> possibly
03:13:28 <Ghoul_> I'm on windows
03:14:07 <mcstar> try moving your mouse more
03:14:25 <Ghoul_> lol
03:14:43 <Cale> There's createEntropyPool...
03:15:01 <Ghoul_> Oh, that's the one
03:15:12 <Ghoul_> my program hangs at the line `entrop          <- createEntropyPool`
03:18:32 <Ghoul_> hah! Wierd.
03:18:44 <Ghoul_> Some consequence of laziness made debugging it really confusing
03:18:45 <aristid> will generalized stream fusion find its way into the actual vector package someday?
03:19:37 <hansholm> Hey, I'm a beginner with haskell and I try to implement the floor function. There are some problems concerning the types:
03:19:47 <hansholm> context
03:20:20 <hansholm> floor :: (RealFrac a, Integral b) => a -> b
03:20:26 <mauke> what do you mean by "implement"?
03:20:49 <hansholm> I have to write it by myself with a linear search ;)
03:21:10 <mauke> o_O
03:21:15 <hansholm> The compiler says: "Could not deduce (a ~ Integer)"
03:21:17 <aristid> :t fromInteger
03:21:17 <lambdabot> Num a => Integer -> a
03:21:36 <mauke> > floor (1e99) :: Int
03:21:38 <lambdabot>   0
03:21:51 <aristid> > floor (1e99) :: Integer
03:21:52 <lambdabot>   999999999999999967336168804116691273849533185806555472917961779471295845921...
03:21:59 <aristid> hehehe
03:22:10 <mauke> > floor (1/0)
03:22:11 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
03:22:47 <udevd> wait what
03:23:03 <aristid> > logBase 10 $ fromInteger $ floor (1/0)
03:23:04 <lambdabot>   Infinity
03:23:08 <Ghoul_> ick, iunno
03:23:24 <Ghoul_> I think it is createEntropyPool. It's so hard to debug. afk
03:24:30 <ksf_> what ghc should I download if I want to try out closed type families?
03:24:52 <ksf_> it's not only a matter of latest, now, it's also a matter of which directory.
03:26:54 <rootnode> > floor (1/0)
03:26:55 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
03:27:06 <rootnode> no kidding...huh. what is happening there?
03:27:09 <aristid> rootnode: mauke did that 5 minutes ago.
03:27:19 <rootnode> I know...just had to check for myself
03:27:20 <aristid> rootnode: it just takes a very large integer.
03:27:42 <aristid> rootnode: large enough that if you convert it back to double it results in Infinity
03:27:52 <mauke> > floor (0/0)
03:27:53 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
03:28:02 <aristid> mauke: now that is nasty.
03:28:18 <aristid> > fromInteger (floor (0/0)) :: Double
03:28:19 <lambdabot>   -Infinity
03:28:24 <aristid> TSK TSK TSK
03:28:57 <hansholm> any idea what the problem is in my code? when I leave out the type declaration it works, but returns a float...
03:30:23 <mauke> hansholm: what code?
03:30:57 <aristid> mauke: is there any rational justification for floor NAN returning effectively -Infinity?
03:31:15 <hansholm> http://pastebin.com/R5CPDRtJ
03:31:18 <mauke> The paste R5CPDRtJ has been copied to http://lpaste.net/93244
03:31:43 <aristid> hansholm: try (0::Integer)
03:32:45 <hansholm> same problem (already tried this)
03:33:33 <aristid> hansholm: it's perhaps only part of the solution, but still necessary.
03:33:44 <mauke> it's not necessary
03:33:44 <aristid> :: binds less tightly than function application
03:33:50 <mauke> why is there a type annotation at all?
03:34:11 <aristid> ah sorry indeed i was confused it's not necessary
03:34:39 <hansholm> the comiler says: Could not deduce (a ~ Integer) and Could not deduce (b ~ Integer)
03:34:41 <ksf_> hansholm, the method to get an integer from a float is floor/ceil ...
03:34:52 <aristid> hansholm: fromInteger
03:35:18 <hansholm> yeah I know, but I#ve to write it by myself as an exercise ^^
03:35:20 <ksf_> as you need to compute using floats, you can't implement floor and return an integer without using floor.
03:35:38 <aristid> ksf_: it is possible if you don't mind inefficiency
03:35:38 <ksf_> just return a float. if its *.0, then it floored.
03:36:02 <aristid> hansholm: just use fromInteger (searchFrom 0)
03:36:30 <mauke> aristid: that makes no sense
03:36:37 <mauke> searchFrom doesn't return an Integer
03:37:09 <aristid> damn you're right i can't think today :/
03:37:16 <hansholm> why not? it takes 0 as an integer and only does pred and succ?
03:37:24 <mauke> it doesn't take 0 as an integer
03:37:34 <mauke> and it doesn't only do pred and succ
03:37:39 <mauke> it also does >x and <x
03:37:43 <mauke> and x is fractional
03:37:52 <mauke> :t (>)
03:37:53 <lambdabot> Ord a => a -> a -> Bool
03:37:59 <mauke> therefore 0 has the same type as x
03:38:35 <hansholm> ahh ok I'm too new to functional programming… you're right…
03:38:36 <hansholm> thanks
03:38:48 <mauke> non sequitur
03:38:56 <mauke> this is static typing, not functional programming
03:40:05 <hansholm> yeah that's true, but in all languages I've done before it was no problem to compare ints and floats…
03:40:21 <aristid> :t let x = (4::Double) in \a -> fromIntegral x > x
03:40:21 <lambdabot>     No instance for (Integral Double)
03:40:22 <lambdabot>       arising from a use of `fromIntegral'
03:40:22 <lambdabot>     Possible fix: add an instance declaration for (Integral Double)
03:40:30 <mauke> hansholm: that's probably not true
03:40:34 <aristid> :t let x = (4::Double) in \a -> fromIntegral a > x
03:40:35 <lambdabot> Integral a => a -> Bool
03:40:37 <mauke> no language I know can compare ints with floats
03:40:45 <mauke> but several languages I know implicitly convert ints to floats
03:41:09 <mauke> so you actually get a float/float comparison, you just don't know about it
03:41:34 <wagle> tutor..  you can..
03:41:59 <wagle> n150 is the integer rep of var 150, v150 is the float
03:43:05 <Maior> eh?
03:43:28 <wagle> v150 = 1.0
03:43:39 <wagle> n149 = 1
03:44:08 <wagle> if n150 == n149 then go nutz else stay sane
03:45:25 <wagle> http://en.wikipedia.org/wiki/TUTOR_%28programming_language%29
03:45:27 <wagle> meh
03:45:34 <wagle> not a major point
03:46:30 <ksf_> oh, an archeologist.
03:54:44 <wagle> @hoogle [a,a,a]->(a,a,a)
03:54:44 <lambdabot> Parse error:
03:54:44 <lambdabot>   [a,a,a]->(a,a,a)
03:54:44 <lambdabot>     ^
03:55:20 <ksf_> waaagh the ghc build segfaults
03:55:31 <Ghoul_> :(
03:55:45 <aristid> :t \[a,b,c] -> (a,b,c)
03:55:53 <lambdabot> [t] -> (t, t, t)
03:55:55 <wagle> inconceivable!
03:56:10 <wagle> aristid: yeah, was going to do that
03:56:42 <aristid> wagle: you were thinking there might be already a function for that? :P
03:56:50 <wagle> yeah
03:56:55 <aristid> yeah no
03:57:04 <wagle> guessnot
03:57:16 <aristid> @hoogle [a] -> (a,a,a)
03:57:17 <lambdabot> Data.Text commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)
03:57:17 <lambdabot> Data.Text.Lazy commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)
03:57:17 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
03:57:21 <aristid> haha.
03:57:49 <aristid> wagle: you should only call that function when you know for sure that there are three elements, of course.
03:58:23 <wagle> yeah, i know..  have to decide how pedantic to be for throwaway code
03:58:24 <ksf_> @djinn [a] -> (a,a,a)
03:58:24 <lambdabot> Error: Undefined type []
04:03:25 <wagle> hey, first my code compiled, then it ran..  must work, right?
04:06:09 <Hafydd> Unless your problem specification is wrong.
04:06:40 <Chousuke> wagle: it works, but are you sure it does the right thing correctly?
04:06:56 <Chousuke> it might be doing the wrong thing. correctly.
04:06:57 <chrisdone> if you wrote: main = putStrLn "Release the hounds!" though it may compile, vicious dogs may not necessarily be released on someone at your front door
04:07:17 <wagle> all true all true
04:07:21 <Hafydd> may not
04:07:45 <wagle> the answer i got was very surprising
04:07:58 <wagle> not impossible though
04:07:59 <Chousuke> chrisdone: if the houndkeeper reads your program output, the result might be what you desire.
04:08:22 <chrisdone> Chousuke: i suppose in the IO monad, that's a value result
04:08:45 <chrisdone> er, valid
04:08:47 <wagle> i have 15 tries with the houndkeeper, and I have another program to write..  (checks two at once, grrr)
04:10:03 <Chousuke> wagle: if your program compiles and seems to work, read through it and try to check if you're really specified correctly (and accurately) what you want
04:11:23 <wagle> yeah... i havent used any of my tries yet..  when i get the other program "running correctly", I will try to unlock the achievement
04:12:08 <wagle> algorithms without sideeffects is brain twisty..  ooooo
04:12:14 <Chousuke> and there are things that you can't really accurately specify in Haskell (or it would take too much effort); you'll just need to do some non-type-checked reasoning in such cases.
04:12:59 <Chousuke> I think algorithms with side-effects are much worse to be honest :P
04:13:31 <wagle> what I want to do is to send it at something like coq or agda or isabelle, but I dont know them yet
04:13:32 <Chousuke> though I suppose it depends on the problem
04:14:25 <wagle> side-effects can make it faster..  but I want to experiment with coding algorithms both ways and see how to convert between theem, etc
04:15:28 <Chousuke> there's no real way to "convert" algorithms like that
04:15:55 <wagle> well, i'll find out..  i'm just starting this project
04:17:02 <Chousuke> you get certain benefits from immutability and laziness, but you will also need (and are able!) to use very different algorithms compared to a strict language that defaults to mutating things.
04:19:09 <wagle> i'm going to see how far I get with this other algorithm before I sleep
04:19:22 <Chousuke> have fun, then :)
04:19:34 <donri> are there computational algorithms with side-effects other than mutation?
04:19:39 <exicer> Hmm, stupid question - I have [IO String], how can I print it ?
04:19:41 <donri> we've got mutation covered with ST
04:20:02 <donri> exicer: how do you want it printed?
04:20:28 <exicer> I guess I just want to assume that it will be there, for the purposes of debugging
04:20:29 <int-e> @type print . sequence {- not necessarily what you want -}
04:20:39 <exicer> the string that is
04:20:45 <lambdabot> (Monad m, Show (m [a])) => [m a] -> IO ()
04:20:47 <donri> exicer: there is no one string
04:20:53 <int-e> hah
04:20:57 <exicer> ah sorry, I mean each string
04:21:15 <int-e> @type sequence >=> print
04:21:16 <lambdabot> Show a => [IO a] -> IO ()
04:22:35 <exicer> Cheers, that is exactly what I wanted
04:22:58 <int-e> note that it will evaluate all the strings before it starts printing
04:23:42 <int-e> you may be better off with forM_ list (>>= print)  printing each element individually.
04:24:00 <int-e> @type mapM_ (>>= print)
04:24:01 <lambdabot> Show a => [IO a] -> IO ()
04:24:02 <exicer> Hm, okay.
04:27:13 <Ghoul_> ahaha Cale I found out the problem. It's a user error
04:27:40 <Ghoul_> The documentation says to input a certificate size, so I put in 1024 (for 1024-bit) but it actually means in bytes.
04:33:13 <ksf__> No instance for (SingI Nat (1 + 0))
04:33:15 <ksf__> yeeehah?
04:38:38 <ksf__> > sing :: Sing (1+1)
04:38:39 <lambdabot>   <hint>:1:15: Illegal literal in type (use -XDataKinds to enable): 1
04:39:02 <ksf__> shouldn't that work?
04:39:20 <ksf__> how am I supposed to do anything with my nats if it doesnt?
04:49:23 <monoidal> ksf__: this looks like bug: Sing (1+1) ~ Sing 2, but Sing 2 can be derived
04:49:36 <monoidal> oh wait, I was doing it in 7.6
04:50:20 <monoidal> ksf__: sing :: Sing (1+1) works in HEAD. 7.6 does not have the solver for naturals, even in the simplest case
04:50:36 <ksf__> % ghc --version
04:50:36 <ksf__> The Glorious Glasgow Haskell Compilation System, version 7.7.20130828
04:50:59 <int-e> ksf__: it doesn't work in my 10 days old version either. :)
04:51:05 <monoidal> if you can enable DataKinds and TypeOperatora for the bot it should work too
04:52:02 <Maior> System.Console.GetOpt - anyone happen to prefer any alternatives to this?
04:52:20 <chrisdone> Maior: optparse-applicative
04:52:30 <monoidal> ksf__: fun fact: it doesn't work in 0910, works in 0915
04:52:41 <Maior> chrisdone: cheers
04:52:54 <monoidal> ksf__: almost certainly that's when the natural solver was merged
04:53:19 <mcstar> does anybody have a resource on (symbolic) 'index computation & manipulation' (of arrays)? -- haskell
04:55:25 <arkeet> monochrom: so that means it'll be in 7.8?
04:55:55 <arkeet> I love ghc.
04:55:59 <arkeet> almost as much as monoids.
04:56:19 <chrisdone> but is ghc easy?
04:56:21 <quchen> arkeet: You probably meant monoidal there.
04:56:31 <arkeet> er, yes.
04:56:33 <quchen> chrisdone: Not sure, GHC is a Monad, not a Monoid
04:56:49 <monoidal> arkeet: <spoiler> look at https://github.com/ghc/ghc/blob/master/docs/users_guide/7.8.1-notes.xml to see what will be in 7.8 </spoiler>
04:56:50 <arkeet> quchen: but monads are nothing but monoids in a category of endofunctors.
04:57:11 <monoidal> arkeet: it's really mindblowing and IMO 7.8 deserves to be called 8.0
04:57:16 <quchen> In *the* category of endofunctors ;-)
04:57:36 <Maior> arkeet: if you do the right replacements, yes
04:57:39 <arkeet> quchen: endofunctors of which category?
04:57:41 <quchen> Yeah the 7.8 release notes are a pretty cool read
04:57:55 <arkeet> I want to be able to partially specify type signatures :(
04:58:42 <arkeet> that's a lot of changes.
04:58:53 <monoidal> also, new TH might land in
04:59:11 <monoidal> and there are many minor improvements not mentioned in the notes
04:59:54 <arkeet> MINIMAL pragma, cool
05:00:09 <quchen> In a couple of days SPJ will just send a mail "yeah let's just call it 9.0"
05:00:34 <ksf__> monoidal, are there snapshots available somewhere?
05:00:38 <ksf__> I downloaded the latest one.
05:01:14 <int-e> arkeet: sometimes it's possible to make restricted versions of the identity functions for the purpose. If I do a lot of ST array work I sometimes define functions like  stu :: ST s (STUArray s i e) -> ST s (STUArray s i e)
05:01:25 <arkeet> ??
05:01:28 <monoidal> ksf__: I'm afraid snapshots are currently not updated, but I'm not sure (I just do git pull)
05:02:05 <monoidal> ksf__: some time ago snapshots were available, but now that location lists only <=august
05:02:06 <int-e> so  stu (newArray (1,42) (0 :: Int))  would do something sensible.
05:02:43 * ksf__ is git cloning
05:02:54 * arkeet wonders why that was for me
05:03:05 <arkeet> oh.
05:03:09 <arkeet> right.
05:03:17 <arkeet> that's not what I meant though.
05:03:28 <arkeet> sort of.
05:03:43 <arkeet> I mean I'd want to be able to put holes in a type signature
05:03:48 <arkeet> and have them be inferred.
05:04:17 <arkeet> I dunno
05:04:25 <chrisdone> ugh, hate it when a reasonable data type in a library has no show instance
05:05:20 <chrisdone> thank zeus for standalone deriving
05:05:24 <arkeet> GHCi now supports a prompt2 setting, which allows you to customize the continuation prompt of multi-line input.
05:05:25 <int-e> arkeet: yes, that would be nicer.
05:05:39 <donri> arkeet: also ghci-ng
05:05:43 <quchen> ..?
05:05:50 <quchen> Could you explain those GHCi changes?
05:05:55 <arkeet> ?
05:05:59 <chrisdone> surely a better GHC API is better than making ghci more customizable
05:06:09 <chrisdone> i want to be able to use GHC like i use xmonad
05:06:14 <arkeet> surely that's also a lot more work
05:06:44 <chrisdone> i wouldn't say so, the API for interpreted code is quite good, you can do everything you can do in ghci
05:06:57 <chrisdone> you just have to be stubborn and not runaway crying sometimes
05:06:58 <int-e> chrisdone: surely you can extend ghci-ng into a library :)
05:07:15 <mcstar> who is the guy behind wellposed.com ? i cant remember his nick, he used to visit this channel
05:07:26 <donri> chrisdone: btw have you ever used :force in ghci (re lack of Show instances)
05:08:39 <donri> it's annoying that it doesn't take an expression though
05:08:56 <chrisdone> int-e: that already exists in the ghc-api
05:09:05 <FreeFull> One problem with defining my own Prelude, type defaulting isn't working
05:09:16 <chrisdone> donri: nope, never used that
05:09:36 <int-e> chrisdone: presumably there are some utility functions in the actual (extended) ghci implementation that would be useful.
05:09:43 <chrisdone> FreeFull: yeah ghc secretely uses its GHC.Foo types
05:09:52 <Eduard_Munteanu> Is it possible to define a type synonym within a class instance, without making it an associated type family? I just want the kinds to match.
05:10:03 <Eduard_Munteanu> Erm, within a class _definition_
05:10:13 <donri> chrisdone: it's basically deepseq+show but via ghc instead of classes
05:10:24 * arkeet wonders what the benefit of putting one inside a class would be.
05:10:30 <arkeet> instance.
05:10:31 <Maior> ugh option parsing seems hard
05:10:40 <donri> chrisdone: so you get to see the actual representation, mostly
05:10:41 <arkeet> Maior: how are you doing it?
05:10:53 <arkeet> Maior: optparse-applicative is quite nice.
05:10:59 <Maior> arkeet: I'm not, at the moment - reading through o-a and GetOpt
05:11:05 <arkeet> :)
05:11:11 <chrisdone> donri: hmm, it seems more like whnf
05:11:12 <Eduard_Munteanu> arkeet: well it's going to be defined only for instances of that class, and the kind signatures would bind variables to the kinds in the class head
05:11:35 <chrisdone> donri: or a debugger step. evaluating parseCheck [] gives me "parseCheck = _"
05:11:47 <Eduard_Munteanu> As you can see I'm trying to graduate to kind-safety. :P
05:11:58 <donri> chrisdone: what type does that have?
05:12:09 <chrisdone> donri: Either ParserFailure (Int, String)
05:12:15 <Maior> arkeet: I'm trying to map from http://docs.python.org/dev/library/argparse.html to o-a (the former being the one I've spent most time with, and with options I most frequently reach for)
05:12:31 <donri> chrisdone: try let x = parseCheck []; :force x
05:12:34 <b__> Is there no function like `Monoid m => m a -> a'?
05:12:41 <donri> chrisdone: (as i said, annoying that it doesn't take an expression)
05:12:42 <arkeet> b__: that's a kind error.
05:13:05 <arkeet> b__: if you meant Monad, then the answer is no.
05:13:08 <Maior> arkeet: o-a looks nicest, but a bit light on the docs
05:13:26 <chrisdone> donri: ah, that works. neat
05:13:55 <donri> chrisdone: also :print and :sprint to not force, which shows the thunks (that's the underscores)
05:13:58 <chrisdone> Maior: i'm using optparse-applicative presently. the docs are light in places, would like more examples. but it's a good lib
05:14:22 <Maior> chrisdone: ok, cheers, will get using then!
05:14:34 <b__> arkeet: ah yeah
05:16:09 <donri> :t Control.Comonad.extract
05:16:10 <lambdabot> Control.Comonad.Comonad w => w a -> a
05:16:23 <Walther> Okay, this will be an interesting question.
05:16:29 <Walther> How hard is it to write a compiler?
05:16:56 <donri> Walther: probably not hard. writing a /good/ compiler on the other hand...
05:17:12 <b__> donri that's exactly what I had in mind, thanks
05:17:18 <Walther> I'm just thinking about this whole deal with Haskell being somewhat domain-specific to .edu as it doesn't run on the industry-standard JVM
05:17:35 <arkeet> are you trolling?
05:17:38 <mangaba_leitosa> lol at industry-standard JVM
05:17:45 <Walther> No, sadly, not trolling
05:18:06 <Walther> mind you I did use the word "somewhat" hence implying there are people using it for "real stuff" as well
05:18:10 <FreeFull> The way I'm doing things, I'm sacrificing pattern matching
05:18:27 <chrisdone> it seems like trolling because what you're saying is generally contrary to the haskell community's view of haskell
05:18:29 <Walther> and having haskell run on JVM would definitely increase the possibility of its adoption
05:18:37 <mcstar> haskell's domain is .org
05:18:53 <mauke> Walther: I don't want to be part of your "industry"
05:18:53 <arkeet> Maior: hopefully you've seen the readme https://github.com/pcapriotti/optparse-applicative
05:18:58 * haasn doesn't understand what the JVM has to do with anything
05:19:03 <FreeFull> Obviously everything has to run on the JVM
05:19:04 <arkeet> Maior: or maybe this little intro http://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html
05:19:04 <Walther> chrisdone: I can see why, but I am being perfectly honest here - perhaps I should word myuself better
05:19:05 <mangaba_leitosa> Walther: does the instustry-standard C++ run on JVM?
05:19:10 * hackagebot iterable 1.0 - API for hierarchical multilevel collections.  http://hackage.haskell.org/package/iterable-1.0 (MichalGajda)
05:19:12 * hackagebot hPDB 0.999 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-0.999 (MichalGajda)
05:19:14 * hackagebot hPDB-examples 0.999 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-0.999 (MichalGajda)
05:19:15 <haasn> FreeFull: no, no, everything has to run on JavaScript
05:19:17 <Walther> okay we started on the wrong foot here
05:19:22 <FreeFull> JSVM
05:19:32 <Maior> :t (!)
05:19:33 <lambdabot> Ix i => Array i e -> i -> e
05:19:57 <Maior> er, what does `OptShort !Char` mean? (http://hackage.haskell.org/packages/archive/optparse-applicative/0.5.2.1/doc/html/Options-Applicative-Types.html)
05:20:03 <chrisdone> Walther: anyway, attempts have been made several times to make JVM backends for haskell, and java foreign function interfaces, for this reason
05:20:09 <arkeet> Maior: it's a strict field.
05:20:11 <Walther> A friend of mine noted that GHC can compile to LLCM and LLVM stuff could be theoretically compiled to JVM stuff
05:20:22 <Maior> arkeet: ah ok cheers
05:20:37 <arkeet> Maior: just makes the constructor strict in that argument.
05:20:41 <Walther> chrisdone: yes, i've tried to google the field, but have not been succesful in finding why the attempts have failed
05:21:36 <mcstar> why prefer a virtual machine, in favor of native code + runtime?
05:21:41 <chrisdone> Walther: mostly it's a difference in how the JVM expects its source languages to behave and the way Haskell tends to be implemented efficiently, it's also a problem of having someone maintain the backends, which no one has offered to do
05:22:03 <Walther> And sorry for sounding like I was trolling, the part about "domain specific to .edu" was just a joke I wrongly assumed people would get
05:22:09 <chrisdone> they tend to be presented as "look what i started" "yeah that's good, will you maintain it?" "not likely" "then we're not putting it in ghc"
05:22:19 <Walther> Ah.
05:22:22 <Walther> Hmmhmm.
05:22:43 <mauke> Walther: and the "industry-standard JVM"?
05:23:20 <Walther> mauke: just something I've faced way too often >_>
05:23:48 <Walther> personally not the biggest fan of java
05:23:52 <mangaba_leitosa> Walther: for JVM, you might want to check clojure & scala :-)
05:23:55 <Walther> but it seems to pop up everywhere
05:23:56 <mauke> have you tried scala?
05:24:04 <chrisdone> mcstar: the JVM has a bunch of benefits over 'native code'
05:24:06 <Walther> mangaba_leitosa: yes, i've heard of both of them
05:24:18 <mcstar> the solution then, is to write a JVM in haskell that would interface industry-standard java code with haskell's
05:24:22 <int-e> http://www.haskell.org/haskellwiki/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET_or_on_the_JVM.3F is relevant
05:24:24 <Walther> mangaba_leitosa: I've taken a look at both and I think I'd still prefer learning haskell
05:24:55 <mangaba_leitosa> Walther: good decision :-)
05:24:56 <Walther> int-e: yes, i've read that and it tends to be very .net specific on the "why"'s
05:25:16 <hvr> chrisdone: btw, what I dislike most about the JVM is that its JIT compilation doesn't allow the OS' page-table to properly share common code
05:25:55 <Walther> mangaba_leitosa: the biggest reason being Haskell code is just orders of magnitudes more readable than say, clojure with tons of extra pretty much unnecessary ()'s everywhere
05:26:04 <Walther> among other things
05:26:32 <dfan> I recommend trolling one userbase at a time
05:26:46 <chrisdone> mcstar: mostly it's an industry favourite because targetting a single machine is easier for portability, it's easier for sysadmins to manage and deploy, it's got standard ways of measuring/analyzing/tooling and any language compiling to it, its problems/pitfalls are well know, any language that compiles to it is pretty much acceptable (java, scala, clojure, jruby) because all the tooling is there
05:27:25 <hvr> chrisdone: not all sysadmins share that thought :-)
05:27:32 <chrisdone> mcstar: whereas if you're coming at haskell from an industry position and you're trying to solve a problem, haskell is like starting from scratch
05:27:41 <int-e> Walther: I don't think so; I think the reasons translate directly to reasons for the JVM.
05:27:45 <Walther> No, I am not trolling, I'm serious. I'm a fan of photograhpy, (web) design etc as well, have some visual tendencies, and I personally find Haskell more readable. I'm sorry if my reasons sound silly to you :P
05:27:55 <Walther> int-e: could you elaborate please?
05:28:15 <chrisdone> mcstar: scala/clojure at least give you a base to say "okay, i know this. the language might be different, but i don't have to worry about the stack"
05:28:43 <Walther> I mean, writing a haskell compiler would definitely be a project that would be a) good in learning how the language actually works and learn to use it in real life b) would definitely be difficult enough to last a while as a project c) could have the chance of benefitting others
05:29:00 <chrisdone> mcstar: and if this fancy-pancy language dies, i can always hire 5 java programmers to interface with it and rewrite it over time =)
05:29:05 <mcstar> i thought ghc was pretty portable... maybe it isnt
05:29:13 <int-e> Walther: briefly, IL = bytecode, verifiable IL = satisfy the static bytecode checker, and you will want to interface existing libraries, and you have to reimplement the RTS for the virtual machine.
05:29:22 <mangaba_leitosa> Walther: I prefer minimalistic yet expressive syntax, too :-)
05:29:29 <hvr> Walther: btw, do you know http://en.wikipedia.org/wiki/Frege_(programming_language) ?
05:29:29 <chrisdone> hvr: "not all" -- care to give a percentage on that? ;)
05:29:54 <hvr> chrisdone: I don't have the stats, it just happens that the admins at my workplace dislike it :-)
05:30:20 <chrisdone> hvr: mine too :-)
05:30:26 <Walther> hvr: that did come up in google results as well, yes, took a peek at it and at a first peek it sesemed to bastardize haskell with java style quite a lot
05:30:47 <hvr> chrisdone: generally, they prefer stuff that integrates properly into debian or redhat, by being .rpm or .deb and the java apps they have to handle don't play well
05:30:52 <mcstar> one thing i can imagine, is that once code is compiled for the jvm, it can run anywhere, provided jvm exists on the platform
05:31:02 <mcstar> but you would need source for recompilation in the case of haskell
05:31:20 <mauke> mcstar: do you know how many programs bundle their own jvm because they only work on one specific version?
05:31:23 <Cale> The main reason to compile Haskell for the JVM of course would be the ability to mod minecraft
05:31:30 <mcstar> mauke: no, i dont
05:31:32 <chrisdone> Cale :D
05:31:39 <simon> surely.
05:32:02 <chrisdone> mauke: that's true
05:32:10 <Walther> chrisdone: :D
05:32:11 <mcstar> mauke: so, what benefit remains? familiarity(cheap labor)?
05:32:13 <chrisdone> big programs do that a lot
05:32:14 <Walther> Cale: ^
05:33:15 <Walther> mcstar: Well, many big companies like JVM for reasons X - and it's a completely different reason whether those reasons are ..er, reasonable, than "would haskell / the world benefit from being able to run haskell on jvm"
05:33:16 <hvr> Cale: btw, there are packages like http://hackage.haskell.org/package/mcpi
05:33:31 <FreeFull> I don't think I can have my own Eq and keep pattern matching on integers ):
05:33:45 <mcstar> different question*
05:33:48 <Cale> heh, cool
05:34:18 <Walther> mcstar: yeah
05:34:23 <chrisdone> lol, optparse-applicative
05:34:37 <chrisdone> execPureParser returns Either Parserfailure a
05:34:45 <chrisdone> but in order to inspect ParserFailure, you need IO
05:34:55 <chrisdone> ಠ_ಠ
05:35:49 <mangaba_leitosa> Walther: so this Frege looks like an attempt to do what you want :-)
05:36:24 <mcstar> little more respect for the logicians, pls
05:37:08 <chrisdone> unsafePerfomIOUnecessarily
05:38:30 <Walther> mangaba_leitosa: No, it doesn't really, it looks like a different language made for the purpose with attempts at mimicing style of both haskell and java, trying to meld them together
05:38:45 <Walther> but mostly the first part of the sentence, it looks like a different language
05:40:39 <mangaba_leitosa> Walther: if you start a new project, I you sure you cover haskell in its entirety or will end up implementing a subset, which will be a different language then?
05:40:48 <mangaba_leitosa> s/I you/are you/
05:41:09 <Walther> mangaba_leitosa: that is a good question
05:41:28 <Walther> of course targetting GHC and its api wouldn't be a bad goal
05:41:52 <Walther> putting code in github would help facilitate maintainability w/ pull requests and so forth
05:42:16 <Walther> then again, writing a compiler is not an overnight task, especially for someone taking their first steps with the language
05:42:25 <Walther> otoh it could be a good project for learning...
05:42:27 * Walther shrugs
05:43:06 <chrisdone> it's hard, i wouldn't bother
05:43:51 <chrisdone> there's infinite work to be done on a compiler, it just sucks up your time you could be doing on other things
05:44:58 <mcstar> ... like writing a different compiler
05:45:25 <mangaba_leitosa> like inventing your own language :-)
05:48:00 <Cale> Wasn't that kind of how JHC got started?
05:48:53 <Cale> I remember hearing somewhere that John Meacham wanted to learn Haskell, so he wrote a Haskell compiler :)
05:49:47 <mcstar> yeah, it was said here as well
05:50:24 <Cale> http://repetae.net/computer/jhc/jhc.shtml -- ah, yeah, see "The story of jhc" near the end
05:51:00 <doomlord_> writing a compiler that competes with existing ones seems a bit daunting. isn't clang+llvm 3m LOC or something.. and haskell probably has more scope for compiler optimizations...
05:51:30 <luite> GHC is a lot smaller than LLVM
05:52:06 <doomlord_> i suppose haskell relies more on work done by the runtime
05:52:46 <ksf__> ghc-cabal: Error: Could not find module: System.Time with any suffix: ["hi"]
05:52:56 <ksf__> in the search path: ["dist-install/build"]
05:53:02 <ksf__> ...when trying to install HEAD
05:53:44 <doomlord_> i wish i could write my own language cherrypicking my exact choice of features, unfortunately life is too short.
05:55:44 <Walther> nah, writing an own language would be way limiting due small userbase
05:57:11 <doomlord_> at the minute rust is the closest thing to 'what i want', but i miss overloading from C++ and function-level type inference from haskell..
05:57:22 <mangaba_leitosa> Walther: if all persons thought in the same way, our current choice of languages would be limited by LISP and FORTRAN
05:57:43 <doomlord_> plus i'm not actually so keen on the rust module system
05:58:10 <Walther> mangaba_leitosa: Heh, of course
05:58:11 <ksf__> it also lacks decent syntax
05:58:19 <chrisdone> excellent. i'm using optparse-applicative for a simple IPC protocol
05:58:43 <chrisdone> a protocol with a --help for every command =]
05:58:45 <ksf__> and from the little dabbling I did using closures in it requires a ph.d
05:58:54 <doomlord_> (rust's syntax works 100% for  me, being more c++ conditioned it just comes across as a  cleaned up C++)
05:59:06 <tiffany> I love rust
05:59:25 <Walther> But yeah, assuming I would take on this mammoth of a project, any experience with GHC and its "api" (that is referred in an old pull request of a version of haskell to jvm compiler as a reason of not merging)
05:59:34 <doomlord_> despite those reservations , rust is my favourite language.
05:59:39 <Cale> But what kind of language would you design? It's really hard to out-do things which already exist design-wise. It would be really nice to have something based on HoTT directly, and which supported higher inductive types properly, but as far as I know, the full computational interpretation there is still a research project...
05:59:54 <doomlord_> it just hasn't eliminated that "my perfect language.." itch completely :)
06:00:19 <Walther> ^I suppose that itch for "my perfect X" is the reason many here like programming
06:00:22 <ksf__> Cale, there's this challenge up to write a complete system, bare metal to high level, in <=20kloc
06:00:32 <doomlord_> i gather haskell has multi-parameter typeclasses which can do more of what C++ overloading..
06:00:43 <chrisdone> Cale: i'd probably do something like lisp/smalltalk meets idris/disciple
06:00:45 <mangaba_leitosa> doomlord_: is rust ready for real world apps, like haskell is?
06:00:46 <doomlord_> .. .and i know the argument against full type inference, but i would still like it as an option
06:00:47 <mcstar> i learned to prefer mediocrity, it causes less headache
06:01:15 <doomlord_> rust is definitely immature, but its an exciting time to be in it - you have a chance to steer it a little with feedback and contributions
06:01:17 <chrisdone> Cale: it seems to me that the two are never merged despite the obvious advantages of both
06:01:35 <mangaba_leitosa> doomlord_: I see
06:01:42 <Cale> I can't really say that I understand what the point of Disciple is.
06:01:43 <ksf__> a statically typed functional language that properly supports row polymorphism and FRP
06:01:51 <ksf__> plus such niceties as aspect grammars.
06:01:57 <Cale> I don't really get why effect types are interesting.
06:02:17 <tiffany> I'm working on a pet scripting language with S-expr syntax for which I plan to implement frp
06:02:27 <Cale> (over what we already are doing in Haskell -- it seems like monads can express more sorts of effects anyway)
06:02:41 <ksf__> monads don't compose nicely.
06:02:43 <chrisdone> Cale: i think it's quite involved to do the same things in haskell to the point that nobody does
06:03:05 <doomlord_> i've worked in games mostly where c++ is irreplaceable, rust excites me because it has the same control over memory.
06:03:25 <ksf__> as to low-level stuff, it'd be nice to be able to have region-based memory management with the possibility to write custom gcs
06:03:28 <chrisdone> it's pretty heavy handed in haskell to say that i just read files or that this code throws exceptions or that i use these exact values and don't return them and session types are messy to do
06:03:31 <ksf__> that's still recent research, though.
06:03:46 <mangaba_leitosa> doomlord_: the list on the wiki 'Influenced by: Alef, C#, C++, Camlp4, Common Lisp, Cyclone, Erlang, Haskell, Hermes, Limbo, Napier, Napier88, Newsqueak, NIL, Ocaml, Ruby, Sather, Standard ML' looks really impressive :-)
06:04:05 <doomlord_> yeah its got ideas from all over the place :)
06:04:19 <ksf__> Cale, or you could do a thing like parasail
06:04:22 <Cale> chrisdone: Well, to really express more effectively, you need dependent types, I think.
06:04:51 <ksf__> which goes off onto an adverturous expedition into unchartered design space
06:06:04 <doomlord_> I'm still wondering if i can find a language that would make collaborative projects more enjoyable. rust - small userbase. C/C++ - fantastic when i'm working solo but hugely unpleasant in a team environment.
06:08:14 <Cale> Haskell is not so bad in a team environment
06:08:24 <chrisdone> haskell is awesome in a team environment
06:08:47 <edvo> is there a standard package for printing values to ByteString, i.e. the opposite of attoparsec?
06:09:20 <ksf__> edvo, blaze, for example
06:09:20 <Cale> edvo: Well, there's binary
06:11:05 <Cale> oh, and cereal
06:11:29 <Cale> (cereal uses strict bytestring)
06:11:43 <edvo> Thank you, I will look into it
06:18:50 <doomlord_> is there a tool that generates visual graphs of haskell modules & typeclasses
06:21:52 <quchen> doomlord_: Not sure what you mean, but I don't know anything remotely "visual" for Haskell source.
06:22:30 <quchen> There are things like this: http://www.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
06:22:35 <quchen> But that's not very beginner-friendly.
06:22:54 <doomlord_> thats what i have in mind, yes
06:22:59 <monoidal> there's ancient cabal-graph http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabalgraph  but probably bitrotten
06:23:16 <int-e> there's also http://hackage.haskell.org/package/graphmod (which I've never used)
06:23:43 <doomlord_> i was wanting to write such a thing for rust, its traits idea is very similar, i'd want to display modules enclosing the traits
06:23:56 <int-e> (but it only covers modules, not type classes)
06:29:40 <Cale> http://www.cas.mcmaster.ca/~kahl/Haskell/HsDep.lhs
06:29:51 <Cale> no idea whether that still runs
06:30:23 <Cale> you'll also need http://www.cas.mcmaster.ca/~kahl/Haskell/Dot.lhs
06:30:53 <Cale> It makes module dependency graphs
06:33:03 <int-e> "import IO", how quaint :)
06:36:55 <chrisdone> int-e: better in my opinion =)
06:37:34 <chrisdone> System.IO is like "Computer.IO" or "Program.IO" or "Stuff.IO", redundant
06:39:22 <donri> Data.Data.Data Factory Factory
06:39:52 <chrisdone> =)
06:40:56 <mescalinum> > maximumBy (compare . map length) $ [[1,20],[2],[3,5,1]]
06:40:57 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[a0]'
06:40:58 <lambdabot>  Expected type: [a0] -> [a0...
06:41:20 <chrisdone> try comparing
06:42:00 <chrisdone> :t maximumBy (comparing (map length))
06:42:01 <lambdabot> [[[a]]] -> [[a]]
06:42:15 <chrisdone> probably just length for your type
06:42:20 <chrisdone> :t maximumBy (comparing length)
06:42:21 <lambdabot> [[a]] -> [a]
06:45:38 <mescalinum> no way
06:45:54 <mescalinum> the loong version it works:
06:45:56 <mescalinum> > maximumBy (\a b -> compare (length a) (length b)) [[1,20],[2],[3,5,1]]
06:45:57 <lambdabot>   [3,5,1]
06:46:33 <mescalinum> > :t (\a b -> compare (length a) (length b))
06:46:34 <lambdabot>   <hint>:1:1: parse error on input `:'
06:46:43 <mescalinum> :t (\a b -> compare (length a) (length b))
06:46:44 <lambdabot> [a] -> [a1] -> Ordering
06:48:40 <mescalinum> ok
06:48:47 <mescalinum> > maximumBy (comparing length) [[1,20],[2],[3,5,1]]
06:48:48 <lambdabot>   [3,5,1]
06:49:12 * hackagebot monarch 0.9.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.9.0.0 (NoriyukiOhkawa)
06:49:55 <doomlord_> does the haskell compiler ever optimzie [lists] as some other datastructure with the same semantics (eg unrolled linklists for greater cache efficiency or whatever)
06:51:28 <Cale> Generally no, but it will fuse together many operations on lists so as not to produce intermediate lists
06:52:00 <Cale> The way that's done is by recognising certain adjacent higher order functions (there are specific RULES pragmas in the list library)
06:52:21 <Cale> For example, if you write map f . map g, you'll end up with the same code as if you wrote map (f . g)
06:53:45 <Cale> There's something called stream fusion, but as far as I'm aware, it's not turned on for lists at the moment. (But is enabled for ByteString, Text, and Vector)
06:55:16 <beaky> hello
06:55:26 <Cale> There's a paper on stream fusion here: http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=CB145D49C604EAC599F50B183CA65D82?doi=10.1.1.104.7401&rep=rep1&type=pdf
06:56:13 <Cale> http://hackage.haskell.org/package/stream-fusion (and there's a drop-in replacement for the list library to use it)
06:57:47 <Cale> The kind of fusion which does exist for lists in Data.List and the Prelude is called foldr/build fusion.
06:58:24 <donri> fusion confusion
06:58:41 <Cale> I wonder if I can find a paper which describes foldr/build fusion...
06:59:08 <donri> why doesn't base use stream fusion?
06:59:20 <beaky> anyone here build a webapp with haskell?
06:59:32 <beaky> what are things i should know before I do a haskel webap
07:00:03 <Cale> beaky: I'm currently working for skedge.me on their web application backend in Haskell.
07:00:16 <beaky> wow
07:00:41 <beaky> skedge.me looks kinda like the kind of webapp i am trying to do as well
07:01:09 <beaky> (though at a much smaller scale)
07:01:16 <beaky> mine is smaller scale* :D
07:01:30 <mr-> Is there a ([a] -> Int -> Maybe a) - Version of (!!) ?
07:01:32 <beaky> i am using the scotty framework because it defines a simple html monad
07:01:36 <Cale> As to what things you should know, well, have a look at the various frameworks and see what you like. We're using Snap. I think my personal favourite would be HAppStack, though I don't really have a lot of experience. There's also Yesod, which has too much TH stuff for my liking, but it can do a lot for you.
07:01:48 <Cale> I haven't looked at Scotty yet.
07:01:51 <magneticduck> quick question-- I'm trying to typecast a piece of data in a let expression as a Path Double (from my code), but no matter how many parens I put on, it gives me the error "not in scope: data constructor Double"
07:02:05 <magneticduck> I'm doing something horribly wrong somewhere, but I can't seem to figure it out
07:02:50 <Cale> mr-: I think you'll probably end up using lookup n . zip [0..]
07:03:01 <magneticduck> oh wait never mind, silly typo
07:03:05 <Cale> magneticduck: You're using Double as a value
07:03:16 <Cale> (rather than as a type)
07:03:16 <magneticduck> yeah the syntax was wrong
07:03:58 <magneticduck> so many parens! Is there a better way to do it than ((pathFromPoints <code>) :: (Path Double))
07:04:08 <beaky> wow I will check out the hapstack framework if scoty doesn't work out  :D
07:04:10 <magneticduck> can I at least make a line break?
07:04:20 <Cale> donri: Oh, as to why base doesn't use stream fusion, well, I don't know the specific reason, but it's not *always* better than foldr/build fusion.
07:04:37 <mr-> Cale: Yeah.. I know how to implement it. I was just wondering if it was defined somewhere.. like some hidden Data.List.Total, or something ;-)
07:04:47 <Cale> ah, I dunno
07:05:05 <donri> Cale: oh, they're mutually exclusive?
07:05:34 <Cale> donri: Kind of yeah
07:05:54 <Cale> Well, it would be rather interesting to see what happens if you try to use them together :P
07:07:51 <Cale> donri: They both operate to some extent by passing from lists to some other datatype, so that various higher order functions on lists will turn into O(1) operations on that other datatype (which is a type of functions of some sort)
07:08:22 <Cale> and then eliminating redundant conversions back and forth
07:09:22 * ksf__ wants closed type classes
07:09:30 <ksf__> and a HEAD that builds
07:11:08 <Gracenotes> ksf__: I guess the usual thing there is 'use ADTs'
07:11:19 <doomlord_> stream fusion ,interestng, sounds a lot like what you can acheive manually with lazy expression templates elsewhere
07:11:35 <Gracenotes> no nice instance selection though :/
07:12:06 <constantius> hello! I installed the lambdabot locally but I can't find any way how to interact with it. is there a way to set it up like, in separate terminal window?
07:13:24 <constantius> ?src error
07:13:24 <lambdabot> error s = throw (ErrorCall s)
07:14:13 * hackagebot monad-extras 0.3.1.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.3.1.0 (ChrisDone)
07:20:01 <magneticduck> @where hpaste
07:20:01 <lambdabot> http://lpaste.net/new/haskell
07:20:24 <magneticduck> sooo, I got a new error today
07:20:30 <magneticduck> http://lpaste.net/93252
07:20:40 <magneticduck> got this error on runtime
07:21:14 <magneticduck> I have never heard of the symbol "fps_minimum", I don't use it in my code
07:22:12 <magneticduck> I'm using modules from and written on top of Gloss and hsndlib, if that helps..?
07:22:56 <magneticduck> what kind of information should I give?
07:23:51 <magneticduck> this is the first time I've made an executable that uses two of my libraries (one that uses Gloss and one that uses hsndlib) at the same time
07:24:07 <magneticduck> I'll try to compile a test that just imports them both to see what happens I guess
07:24:13 * hackagebot monad-extras 0.3.2.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.3.2.0 (ChrisDone)
07:25:46 <Cale> magneticduck: ghc-pkg list bytestring
07:26:14 <Cale> also ghc-pkg check and make sure you don't have broken packages
07:26:19 <magneticduck> http://lpaste.net/93253
07:26:23 <magneticduck> yeah, something's broken
07:26:29 <magneticduck> so, what exactly does that mean>?
07:26:48 <ksf__> that the clock is ticking.
07:26:49 <magneticduck> I have a package with dependencies that have been altered after it was installed?
07:26:52 <Cale> Well, run ghc-pkg check and it'll tell you all the problems
07:26:55 <Cale> yeah
07:27:05 <magneticduck> I have a lot of problems
07:27:11 <ksf__> you have a maximum of 20 minutes before someone will tell you to just nuke ~/.cabal
07:27:16 <ksf__> and ~/.ghc
07:28:19 <magneticduck> http://lpaste.net/93254
07:28:19 <Cale> Well, ~/.ghc should suffice
07:28:22 <magneticduck> lol
07:28:34 <magneticduck> how do I fix that?
07:29:07 <magneticduck> it's all haddock?
07:29:12 <ksf__> hmmm haddock problems don't look critical.
07:29:23 <Cale> There are problems in package RecurEngine-0.1.0.0:
07:29:29 <Cale>   dependency "LinearTools-0.1.0.0-59d3b2d93ff34782252c03dffa1d1ba5" doesn't exist
07:29:43 <ksf__> you're missing LinearTools
07:29:44 <magneticduck> yeah I know about that
07:29:46 <Cale> So reinstall RecurEngine
07:29:47 <magneticduck> that's one of my own packages
07:29:53 <magneticduck> no, it's dead
07:30:03 <magneticduck> I don't use it for anything
07:30:07 <Cale> well, is that the entire output?
07:30:22 <Cale> ghc pkg unregister RecurEngine
07:30:26 <magneticduck> ghc-pkg check : http://lpaste.net/93254
07:30:27 <Cale> er, ghc-pkg
07:30:53 <magneticduck> alright the error is gone
07:31:05 <Cale> okay well...
07:31:42 <magneticduck> but I still the error I came in with
07:32:32 <Cale> Maybe try ghc-pkg unregister bytestring-0.10.0.1
07:32:46 <Cale> Is there something which depends on the newer version for sure?
07:33:00 <magneticduck> I reinstalled it, now I don't get an error when I ask ghc-pkg about it, but I still get the error when I install my program
07:33:29 <Cale> Wait, when did you reinstall bytestring?
07:33:34 <magneticduck> right now
07:33:37 <Cale> ah, okay
07:33:50 <Cale> hmm
07:34:01 <magneticduck> ghc-pkg list doesn't say anything bad but I get the same weird error
07:34:44 <Cale> Does your project somehow rely on both versions of bytestring?
07:35:06 <magneticduck> my project doesn't even rely on it at all
07:35:11 <magneticduck> only because Gloss does
07:35:32 <magneticduck> well the executable imports both Gloss and a package I made that uses Gloss
07:35:39 <magneticduck> I never got any error in the past
07:37:27 <magneticduck> alright, so I start off with a Main code file that imports Graphics.Gloss, Graphics.Gloss.Interface.Pure.Game, EuclideanThings, and EuclideanGloss
07:37:33 <magneticduck> EuclideanGloss depends on Gloss
07:37:55 <magneticduck> then I import another module called SoundsOfDuck (rofl) and I get the error
07:38:10 <magneticduck> SoundsOfDuck relies on hsndlibrary, and neither of them seem to use bytestring
07:39:19 <Cale> Well, heh, you can always do what ksf__ hinted at
07:39:28 <magneticduck> nuke .cabal
07:39:36 <magneticduck> like delete everything inside it?
07:39:38 <Cale> .ghc would be the important one to nuke
07:40:03 <Cale> Don't delete .cabal unless you want to lose your ~/.cabal/config
07:40:13 <kier> Does Control.Lens provide a lens along the lines of Lens [a] [b] a b (i.e. for operating on each element of a list in parallel)?
07:42:05 <Cale> http://hackage.haskell.org/packages/archive/lens/3.9.1/doc/html/Control-Lens-Setter.html#v:mapped
07:42:24 <Cale> It's not a full lens, just a Setter
07:42:32 <magneticduck> alright I minimally reduced the problem; importing Graphics.Gloss and SoundsOfDuck at the same time gives the error!
07:42:44 <magneticduck> HOWEVER just importing what I thought was the bad library, hsndfile, does not
07:42:58 <magneticduck> SoundsOfDuck relies on process, safe, and hsndfile
07:43:17 <kier> Cale: I've just found Control.Lens.Each.each, would that be much different to mapped?
07:43:25 <magneticduck> I'm going to see if I can reduce it to the conflict between two libraries
07:43:39 <kier> > mapped +~ 2 $ [1..5]
07:43:41 <lambdabot>   [3,4,5,6,7]
07:43:47 <kier> > each +~ 2 $ [1..5]
07:43:49 <lambdabot>   [3,4,5,6,7]
07:44:07 <Eduard_Munteanu> Is the following a reasonable indexing for a category? Let I, A : Cat, C = I x A. Then Ob(C) = Ob(I) x Ob(A), Hom(A, B) = { f_i,j | i, j : I, f_i,j : A_i -> B_j }, id_A = id_i,i A_i, (g_j,k . f_i,j) = h_i,k
07:44:21 <magneticduck> BINGO if I import System.Process and Sound.File.Sndfile at the same time I get the error
07:44:36 <magneticduck> can anybody else recreate it?
07:44:53 <supki> > traversed +~ 2 $ [1..5]
07:44:54 <lambdabot>   [3,4,5,6,7]
07:45:03 <magneticduck> to install hsndfile (hackage library) you need libsndfile
07:45:11 <magneticduck> or libsndfile-dev
07:45:27 <supki> > traverse +~ 2 $ [1..5]
07:45:41 <Eduard_Munteanu> Perhaps I can also define it as a bifunctor F : I x A -> Cat or something like that?
07:46:16 <magneticduck> yeah I solved the problem by taking process out of SoundsOfDuck's dependencies
07:46:18 <lambdabot>   [3,4,5,6,7]
07:46:20 <magneticduck> well that's interesting.
07:50:12 <Eduard_Munteanu> I only really know what the indexed (co)monads look like. :/
07:51:01 <Cale> Eduard_Munteanu: Are you trying to define a product of categories?
07:51:11 <Cale> Or... I'm confused about the notation here.
07:51:31 <Eduard_Munteanu> Cale: no, I wonder what indexed categories are in the 2-indices style
07:52:13 <Cale> If you were just to say to me "indexed category", I would think of a category C together with a functor J -> C from some index category J.
07:52:13 <Eduard_Munteanu> Cale: you know, like indexed monads being a  M : I x I -> C^C
07:53:13 <Eduard_Munteanu> Cale: bind should be explicit enough to illustrate: m i j a -> (a -> m j k b) -> m i k a
07:53:31 <Eduard_Munteanu> Err, the last a should be 'b'.
07:53:51 <Cale> Well, hmm
07:54:09 <Cale> Do you mean an indexed version of something like Control.Category?
07:54:16 <Eduard_Munteanu> Cale: yes.
07:54:39 <Eduard_Munteanu> Cale: it seems that's needed for the indexed Kleisli to make a category.
07:54:48 <Cale> Okay (because Control.Category looks very different from an ordinary category to me)
07:55:18 <Eduard_Munteanu> Cale: oh, I already have a non-Hask Category variant
07:55:54 <Cale> So, what restrictions are you going to place on things which aren't already there?
07:56:07 <Cale> A category is in some sense already "indexed" -- that's what objects are
07:57:01 <Eduard_Munteanu> class CategoryG (hom :: dom -> cod -> *) where  type Dom :: ix -> ob -> dom  type Cod :: ix -> ob -> cod  idG :: Dom i a |~hom~> Cod i a   composeG :: (Dom j b |~hom~> Cod k c) -> (Dom i a |~hom~> Cod j b) -> (Dom i a |~hom~> Cod k c)    -- is what I already have (a |~f~> b is sugar for hom a b)
07:58:01 <Eduard_Munteanu> Cale: yeah but you can't define an indexed Kleisli category I think, newtype Kleisli m i j a b = Kleisli (a -> m i j b)
07:59:26 <Eduard_Munteanu> I think those indices must be "aligned" with object indices when you define the category.
07:59:35 <dropdrive> Does anyone know if the Haxl talk at Zurihac was recorded?  I've found the slides already.
08:00:37 <Eduard_Munteanu> e.g. idKleisli :: Dom a i |~Kleisli m i i~> Cod a i
08:01:09 <Eduard_Munteanu> Oh, btw, ignore the polykinds, they're not essential here.
08:02:03 <notdan> Am I correct to say that Strict Text -> Lazy Text conversion (TL.fromStrict) is "free"?
08:02:48 <notdan> and in general the conversion between strict/lazy text does not affect the performance if at some point every text values should be in the memory?
08:03:05 <Eduard_Munteanu> notdan: as far as x |-> [x] is free I guess?
08:03:15 <jacco_> how can I specify configuration flags of the cabal file when "cabal install"-ing?
08:03:35 <Eduard_Munteanu> I'm not sure it splits the strict one into chunks though.
08:03:52 <Cale> I don't think it's free
08:05:25 <Eduard_Munteanu> Cale: is the above reasonable at all? All I can find online is indexed categories being functors S^op -> Cat for some category S, but I'd prefer using the "traditional" 2 indices representation
08:05:26 <notdan> It says that it's O(c), but I don't understand why
08:05:37 <notdan> fromStrict t = chunk t Empty
08:05:48 <Cale> Eduard_Munteanu: Well, what "indexed" means here is the issue.
08:06:09 <notdan> toStrict is O(n), but this is expected, as you would have to pay that price of O(n) anyway if you plan to use the lazy text
08:06:19 <Cale> Eduard_Munteanu: "Indexed" in indexed monad is perhaps not the first thing one would think of.
08:06:55 <Cale> Eduard_Munteanu: The question about how to get something analogous to a Kleisli category for indexed monads is a good one though.
08:08:28 <Cale> Well, to have arrows compose, you need arrows like b -> m j k c and a -> m i j b, so your objects definitely won't be straightforward objects of your base category.
08:08:38 <Eduard_Munteanu> Cale: I think one can represent any category as the image of functor from Hask... unfortunately functors themselves have rather trivial indexing. :/
08:09:27 <Cale> Perhaps we could put a single index on each object, which I think is what you were doing.
08:09:28 <Eduard_Munteanu> Cale: sure, my base category isn't Hask. I'm using 'a' as a function from indices to objects
08:09:53 <Eduard_Munteanu> Cale: yes, one index per object, two per functors 2, but I'm not really sure that's reasonable
08:10:02 <Eduard_Munteanu> s/2//
08:11:16 <Cale> So, in that case, the objects of our generalised Kleisli category are pairs of objects of the original category and indices, and the arrows (A,i) -> (B,j) are maps A -> M i j B (where M is the indexed monad)
08:12:00 <Eduard_Munteanu> Cale: I'm considering a rule like 'f i j a' gives me an 'a j'. Then if you have 'f i j a ~~> f k l b' then the arrow is (j, k)-indexed
08:12:10 <Cale> Then we can define id_(A,i) to be the appropriate ireturn
08:12:24 <Cale> and we get composition, I think
08:12:36 <Cale> Should be on the nose associative even
08:12:39 <Eduard_Munteanu> Hm, that makes sense.
08:13:17 <Cale> (Though I haven't actually seen anyone write down the laws for an indexed monad)
08:13:34 <Eduard_Munteanu> Cale: well, that's still a Kleisli category for a Hask monad because of the (->), so it will be trivial to index, no?
08:13:54 <Cale> ?
08:14:02 <Cale> I've used -> in more than one sense
08:14:06 <Eduard_Munteanu> Oh, ok.
08:15:34 <Cale> Well, (A,i) -> (B,j) is an arrow in a category whose objects aren't just objects of Hask, and I'm saying that those are implemented by arrows A -> M i j B which are arrows in Hask.
08:15:44 <jacco_> how would I specify configuration flags of the cabal file when "cabal install"-ing?
08:16:03 <Eduard_Munteanu> Cale: I think I want   newtype Kleisli hom m i j a b = Kleisli (a |~hom~> m i j b),  or IOW you make a monad on whatever category 'hom' represents
08:16:41 <Cale> jacco_: --flags="foo -bar" will set foo to true and bar to false.
08:17:04 <Eduard_Munteanu> Cale: and now 'hom' is indexed itself so you can do something actually useful with the indices
08:17:18 <jacco_> Cale: thanks! I was unable to find that with google for some reason
08:17:20 <Cale> uhhh
08:17:29 <Cale> jacco_: I just did cabal install --help :)
08:17:30 <Eduard_Munteanu> (->) doesn't have non-trivial indices.
08:17:49 <jacco_> Cale: aha, thanks :)
08:18:20 <Eduard_Munteanu> (e.g. you can make it indexed simply by giving it indices from '(), the singleton kind)
08:18:31 <Cale> Eduard_Munteanu: Well, ideally it would look more like  newtype Kleisli m (a,i) (b,j) = Kleisli (a -> m i j b)
08:18:51 <Cale> (i.e. you'd be pattern matching on pairs there...)
08:19:29 <Cale> We unfortunately confuse the idea of a pair of types with the type of pairs in Haskell :)
08:20:42 <Cale> But I don't think you need any more abstraction than that unless your indexed monads are already generalised even more somehow.
08:21:00 <Eduard_Munteanu> Cale: you can write   newtype Kleisli m (i : ix) (j : ix) (a : ix -> ob) (b : ix -> ob) = ... I think
08:21:23 <Cale> Those aren't the kinds I intend for a and b
08:21:23 <Eduard_Munteanu> (perhaps make that ixA and ixB)
08:21:31 <Cale> oh, I suppose you could do that though!
08:21:38 <Cale> Well...
08:21:53 <Eduard_Munteanu> Cale: you'd make that  = Kleisli (a i -> m i j (b j))
08:21:54 <Cale> hmm, that's still kind of way too general
08:22:07 <Cale> and no, you don't want that
08:22:32 <Cale> You really want these things to be implemented by straightforward arrows a -> m i j b
08:22:39 <Cale> where a and b are not indexed
08:22:51 <Cale> They don't depend on i and j
08:23:16 <Eduard_Munteanu> Cale: hm, plain (->) won't work for my purpose   (I'm playing with indexed store comonads on the partial Hask category)
08:23:26 <Cale> It's just that the objects in our Kleisli category are *pairs* of objects and indices
08:23:48 <Cale> or pairs of types and indices if you prefer
08:24:07 <Cale> Well, you can generalise the -> if you want
08:24:25 <Cale> But then you'll also want the indexed monad to be an indexed monad on a different category
08:24:46 <Eduard_Munteanu> Yeah, that part was reasonable.
08:26:03 <Eduard_Munteanu> In case you're wondering, I'm trying to see if indexed store comonads on partial Hask can be used as a general API for parsers.
08:26:09 <Cale> lol, you could represent pairs of indices and types in the Church encoding...
08:27:22 <Cale> newtype Kleisli m (p1 :: (* -> ix -> k) -> k) (p2 :: (* -> ix -> k) -> k) = ...
08:27:40 <Eduard_Munteanu> Hm.
08:27:42 <Cale> I'm not sure that's a great idea ;)
08:28:05 <Cale> Probably best just to put the parameters there and treat them in pairs
08:28:06 <Eduard_Munteanu> Cale: shouldn't I carry around the indices in the arrow type?
08:28:12 <Cale> (like pipes!)
08:29:50 <Cale> An object in the Kleisli category for the indexed monad M on the category C is a pair (a,i) of an object a of C and an index i, and an arrow from (a,i) to (b,j) in the Kleisli category for the indexed monad is an arrow of C from a to M i j b.
08:30:44 <Cale> So you could write
08:31:05 <Cale> newtype Kleisli m a i b j = K (a -> m i j b)
08:32:00 <Cale> Then you need some new kind of Category thing to deal with the fact that you have pairs of types
08:32:05 <Cale> But it's a trivial generalisation
08:33:44 <Cale> class Category h where id :: h a i a i; (.) :: h b j c k -> h a i b j -> h a i c k
08:34:12 <Cale> i.e. you literally just replace each type parameter with two :P
08:34:12 <Eduard_Munteanu> Cale: what if I generalize that to   newtype Kleisli m f a i b j = K (a |~f i j~> m j k b)  where f is the hom type?
08:34:16 <mr-> h a i a i is good, but h a i c k could be better
08:34:21 <Eduard_Munteanu> Heh.
08:34:29 <mr-> i h a c k ?
08:34:54 <Cale> Eduard_Munteanu: Why does f take i and j as parameters?
08:35:06 <Cale> I can understand generalising there
08:35:25 <Cale> But it doesn't quite make sense to me why the choice of f would depend on i and j
08:35:47 <Cale> also k is not in scope
08:35:49 <Eduard_Munteanu> Cale: I index arrows with the indices of the objects, perhaps it makes sense to carry them around
08:36:40 <Cale> Though presumably you meant newtype Kleisli m f a i b j = K (a |~f i j~> m i j b)
08:36:40 <Eduard_Munteanu> Oh, right, b's index would be k, not j I think.
08:36:49 <Cale> There is no k!
08:37:06 <Cale> or... I'm confused!
08:37:19 <Cale> There's either no k or no j
08:37:32 <Cale> Or are you intending to turn this into an existential type?
08:37:57 <Eduard_Munteanu> Cale: newtype Kleisli m f a i b j k = K (a |~f i j~> m j k b)  where i is the index of a, and k the index of b
08:38:11 <Cale> Anyway, the natural thing would be that you only have one base category
08:38:52 <Cale> Maybe I should look at how you've done indexed monads
08:39:38 <Cale> But even if you had those extra parameters, I would think you'd supply them to f before the result became a parameter to Kleisli
08:39:59 <Eduard_Munteanu> Cale: class MonadG m where  returnG :: a -> m i i a   bindG :: m i j a -> (a -> m j k b) -> m i k b
08:40:12 <Cale> and that -> is just normal?
08:40:21 <Eduard_Munteanu> Cale: err, no, I forgot about that, lemme see...
08:40:47 <Cale> If that were your definition of MonadG, then I would recommend just having:
08:40:57 <Cale> newtype Kleisli m a i b j = K (a -> m i j b)
08:41:54 <Cale> It's unfortunate that we don't have type level pairs to that Kleisli would have 3 parameters
08:41:56 <Cale> so*
08:42:01 <Cale> but that's close enough
08:42:24 <Eduard_Munteanu> Cale: class MonadG m hom where  returnG :: a |~hom i i~> m i i a   bindG :: (a |~hom i j~> m j k b) -> (m i j a |~hom j i~> m i k b)
08:42:43 <Cale> Oh, that's quite weird.
08:42:44 * Eduard_Munteanu rewrote that now, his .hs is a mess right now.
08:43:04 <Cale> What the heck...
08:43:06 <Eduard_Munteanu> Cale: the parameter order?
08:43:20 <Cale> The way that the indices work
08:43:25 <Cale> Why not just:
08:43:54 <Cale> class MonadG m hom where  returnG :: a |~hom~> m i i a   bindG :: (a |~hom~> m j k b) -> (m i j a |~hom~> m i k b)
08:44:04 <Cale> What do the extra indices do for you?
08:44:13 <Eduard_Munteanu> Plain objects have one index, functors have an input index and an output one, and which is used is dictated by whether it is on the lhs/rhs of the |~hom~>
08:44:22 <Cale> (they're varying a bit, but they vary in a rather strange way!)
08:45:05 <Cale> I think you're trying to do the *next* level of indexing or something
08:45:20 <Eduard_Munteanu> Cale: so  m i j a  maps (a, i) to (m a, j)
08:45:29 <Eduard_Munteanu> "maps"
08:45:58 <Eduard_Munteanu> Perhaps I looked too much at the store comonad with the input and output indices.
08:46:06 <Eduard_Munteanu> Though the indexed state works the same way.
08:46:53 <Cale> I mean, I guess if you have concrete instances which work like that
08:46:58 <Cale> then that's what you have
08:47:08 <Cale> I just find it rather confusing
08:47:19 <applicative> |~hom~> is basically backticks here? or some transformation on hom
08:47:36 <Eduard_Munteanu> applicative: nah, just sugar for  hom a b
08:47:42 <Cale> It's presumably some clever way to write hom infix rather than prefix.
08:47:44 <Cale> yeah
08:47:44 <applicative> okay
08:47:48 <Cale> so backticks
08:48:14 <Eduard_Munteanu> type (|~) a hom = hom a   type (~>) to b = to b
08:48:15 <Cale> Also maybe consider making it ~~hom~>
08:48:24 <applicative> haha
08:48:27 <Cale> |~ makes it look like a \mapsto arrow
08:48:33 <Cale> (which is like a lambda)
08:48:37 <Eduard_Munteanu> Hm, fair point.
08:48:53 <applicative> Eduard_Munteanu: so you actually implemented this under the constraints of Haskell
08:49:16 <Eduard_Munteanu> applicative: yeah
08:49:21 <applicative> good work!
08:49:29 <Cale> What's going on with the contravariant thing with the indices in bind
08:49:51 <Cale> You give it an arrow in hom i j and it gives you an arrow in hom j i
08:50:07 <applicative> sorry, i intervened without grasping the genuine issue...
08:51:23 <Cale> The way that the indices to the monad depend on the indices to the category also really rubs me the wrong way somehow.
08:51:39 <Cale> But again, if I saw the instances of this class, it might help.
08:55:35 <thirsteh> can somebody tell me if there's no point in using either regexp-pcre or pcre-light because the other one is clearly faster? pcre-light's description makes it seem faster, and written by Johan Tibbell, but regexp-pcre was updated more recently and uses libpcre (although the syscalls may be expensive)
08:55:50 <thirsteh> i.e. can someone say "X, duh!" so I don't have to set up a criterion test for both :)
08:56:25 <squidz> exit
08:56:26 <squidz> exit
08:56:37 <thirsteh> ah johan's uses libpcre too
08:56:42 <Eduard_Munteanu> applicative: to be honest edwardk suggested the |~f~> thing in some other form.
09:00:11 <Eduard_Munteanu> Cale: oh, hm, the indices are wrong indeed
09:02:27 <Eduard_Munteanu> I'll come back when I'm done with it, so I don't make wrong guesses.
09:07:47 <lamefun> Are Monoids and Product actually used somewhere?
09:08:50 <albertid> by any chance, does anyone know how to filter duplicates in reactive-banana behaviours or events?
09:09:17 <quchen> lamefun: Monoids are *heavily* used, yes.
09:10:32 <Maior> lamefun: lists are monoids
09:10:37 <Maior> lamefun: http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html
09:11:35 <lamefun> yes, but why use `mappend` instead of just ++?
09:11:44 <quchen> (++) is only for lists.
09:12:00 <quchen> When you use `mappend`, you can write functions that work for any monoid, not just lists.
09:12:12 <argiopeweb> lamefun: You can always swap out for a sequence, vector, etc etc etc later down the road if you decide lists aren't solving your problem.
09:12:18 <Maior> lamefun: think of ++ as list-specific syntactic sugar (ish)
09:12:30 <quchen> For example, "mconcat" does the same thing as "concat" for lists, but it also works on Product and Sum and Ordering and all other monoids.
09:12:41 <twanvl> you can also use (<>) instead of mappend, which looks much nicer
09:13:25 <Cale> There's a lot of really nice uses of various monoids in 'diagrams'
09:13:55 <Cale> also, have a look at my example here: http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
09:15:24 <lamefun> Aren't monoids too general?
09:15:34 <Cale> Too general for what?
09:15:47 <Cale> General means that there are lots of examples of them
09:16:20 <thirsteh> I guess monoids aren't very hip :)
09:16:22 <Cale> The fact that many of examples of them are general constructions which involve other already-existing monoids in some way mean that the typeclass machinery can build many monoids for us for free.
09:16:40 <Cale> means*
09:17:02 <Cale> For example, in that example I linked, I made use of the fact that functions whose codomain is a monoid form a monoid.
09:17:36 <Cale> which lets us combine ordering comparison functions in a natural way
09:17:41 <lamefun> Is there something complex and useful that makes sense for all monoids, not just a subset of them?
09:17:59 <Cale> I just stated something which usefully holds of all monoids
09:18:33 <Cale> It's not very complex, but it also doesn't have to be to save you from writing a bunch of code.
09:19:13 <Cale> The best theorems are often the very easy ones :)
09:19:56 <quchen> Cale: Just think about what mathematics Fermat's Last Theorem resulted in! :-)
09:20:41 <Cale> Well, that's a very hard theorem. But compare that mathematics with, for instance, Fermat's Little Theorem :)
09:20:49 <thirsteh> E = MC^2...
09:21:01 <quchen> That's neither math nor a theorem.
09:21:04 <Cale> Which is far easier to prove, but also very applicable
09:21:45 <thirsteh> not math, huh.
09:21:59 <thirsteh> too good for gravity
09:22:06 <dfan> Say you have some Tree of your new datatype X. If you specify how to combine Xs by making it a Monoid, you can fold over your tree for free
09:22:21 <quchen> It's also very much unrelated to gravity. Anyway, this is OT.
09:22:29 <thirsteh> quchen: calm down
09:22:31 <thirsteh> :)
09:22:36 <Cale> :t fold
09:22:37 <lambdabot> (Foldable t, Monoid m) => t m -> m
09:23:44 <Cale> lamefun: anyway, the fact that there aren't many deep mathematical results about the possible structures monoids can have doesn't stop it from being a really useful general interface
09:24:30 <Cale> lamefun: Almost all algorithms which make use of a balanced tree somehow to improve the performance of some operation are secretly putting values in some monoid on the branch nodes of that tree
09:24:59 <Cale> The monoid axioms are exactly what you need to not have to recompute too much when you rebalance the tree
09:25:43 <Cale> That this fact isn't mentioned in more first year CS courses is a bit of a shame, imo.
09:26:55 <Cale> (or, whichever course normally introduces, say, binary search trees)
09:30:52 <Cale> (Balanced) Trees whose branches hold values in some monoid, and whose leaves hold values of a type which comes equipped with a map to that monoid are a very generally useful structure, and some little modifications to them without altering the interface can give asymptotic and constant factor improvements when accessing the left and right fringes as well.
09:31:36 <Cale> Finger trees do this, and give asymptotically optimal versions of many useful structures, like priority queues and interval maps.
09:31:51 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
09:33:11 <Cale> (by varying the choice of monoid and the choice of mapping to that monoid, you get all kinds of useful things!)
09:34:49 <FreeFull> Monoids are everywhere
09:34:49 <Cale> Also, I don't really know of a library which makes use of this fact, but regular languages are also tied up with the theory of monoids -- you can characterise regular languages as preimages in a free monoid under a homomorphism to a finite monoid.
09:35:37 <simon> Cale, that sounds very interesting.
09:35:46 <Cale> i.e. you have some monoid homomorphism f: A* -> M where M is a finite monoid, A is an arbitrary alphabet, and A* is the free monoid on that alphabet (i.e. lists of elements of A)
09:36:11 <Cale> and you choose any subset of M, and its preimage is a regular language on A
09:36:45 <Cale> and all regular languages arise in that way, by picking some finite monoid M, homomorphism A* -> M and subset of M
09:39:59 <simon> Cale, at my university, they go straight for the min-max-trees in week 4 of CS. :)
09:40:19 <Cale> simon: But do they generalise to an arbitrary monoid?
09:41:14 <simon> Cale, they don't!
09:41:25 <simon> also, they're using SML, so no typeclasses.
09:41:37 <Cale> Well, better than Java
09:41:38 <simon> or... just one typeclass.
09:41:52 <simon> yes. Java is in two months.
09:42:06 <Cale> But yeah, even one is enough.
09:42:07 <simon> more people fail the Java course.
09:42:19 <Cale> (you can do this rather nicely with module parameters)
09:42:26 <simon> do what?
09:42:40 <Cale> Parameterise your tree datastructure by a choice of monoid
09:43:01 <simon> ah yes. you mean make an SML functor?
09:43:01 <tc> Question: ghc-pkg find-module is able to find Text.Pandoc, but when I go to import it in ghci it fails... anyone know where I should start looking?
09:43:03 <tc> http://lpaste.net/93255
09:43:04 <Cale> yep
09:43:26 <simon> I still haven't fully grasped the relationship between SML functors and Haskell functors. :)
09:43:37 <simon> I know how both of them work, but not what they abstractly have in common.
09:43:44 <Cale> simon: I'm not sure they're really functors in any meaningful sense.
09:43:55 <Cale> They're just module-level functions.
09:44:00 <simon> Cale, the "computational context" they go between are structures, then...
09:44:02 <simon> yeah.
09:44:16 * hackagebot network-simple-tls 0.2.0 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.2.0 (RenzoCarbonara)
09:44:17 <Cale> tc: hmm
09:44:27 <monochrom> tc: I want to see the output of "ghc -v"
09:44:27 <Cale> tc: Try ghci -package pandoc
09:44:44 <Cale> (but it looks like it should be exposed?)
09:45:03 <Cale> yeah, do ghc -v
09:45:27 <Cale> It might be hiding the package due to some other problems
09:46:00 <tc> Cale: http://lpaste.net/93256
09:46:09 <tc> Cale: Thanks, that is more illuminating already.
09:46:40 <Cale> Actually, thank monochrom for the -v hint, I don't think of that often enough :)
09:47:27 <tc> monochrom: Thank you too :)
09:47:35 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
09:48:42 <monochrom> and also http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
09:50:02 <tc> monochrom: Ah, interesting.  It probably is some weird interaction between ~/.cabal and Debian.
09:50:45 <monochrom> which is covered by #unsafeInterleave
09:53:07 <simon> Cale, if a monad is a monoid, why do we generally refer to it as a monad; because it's a specific monoid of functions?
09:53:28 <Cale> simon: It's a generalised kind of monoid
09:54:05 <Cale> simon: Normally the word "monoid" is used by ordinary mathematicians to refer to a set with a binary operation which has an identity and is associative.
09:54:16 <simon> Cale, yes, I am familiar with this definition.
09:54:17 <Cale> This is a monoid object in the category of sets.
09:54:50 <Cale> A monad on some category C is a monoid object in the category of endofunctors on C.
09:55:00 <Cale> So it's not an ordinary monoid.
09:55:33 <simon> ...on sets, where the elements of the set are not viewed as "objects".
09:55:56 <Cale> Well, I haven't said what a monoid object is.
09:56:04 <tc> Cale/monochrom: Thanks again.  rm -r ~/.cabal ~/.ghc solved the issue.  Where I was stuck before was that without giving -pandoc ghci wasn't directly giving me any indication of why it wasn't loading even with -v, and I wasn't aware of the interleaving issue.
09:56:05 <Cale> But it's defined with respect to a given monoidal category
09:56:18 <Cale> tc: cool
09:56:28 <monochrom> good good
09:57:01 * simon should soon read the Category Theory book he's been given... ;-)
09:57:12 <Cale> simon: and yeah, when we generalise the notion of monoid, we need to do something to avoid talking about elements
09:57:37 <Cale> simon: in particular, the definition of monoid has in it the existence of an identity element
09:57:43 <prophile> I thought everyone named 'simon' understood all this stuff perfectly
09:57:48 <notdan> Is it possible to profile a Haskell program if not all the libraries are compiled with the profiling on? My program depends on GHC API and it would be a bummer to have to recompile ghc again with profiling enabled
09:57:56 <argiopeweb> prophile: They all have to start somewhere. ;)
09:58:06 <simon> prophile, yeah, being "simon" on here puts a level of pressure on me!
09:58:13 <Cale> I wonder how well SPJ understands category theory actually. I haven't seen much indication from him that he does :)
09:58:14 <argiopeweb> hehe
09:58:27 <Cale> (but it's likely he knows some by now)
09:58:58 <enthropy> notdan: I think you need profiling libraries of everything
09:59:03 <Cale> Well, elements of sets can be identified with functions from a one-element set
09:59:13 <monochrom> @quote SPJ lax
09:59:13 <lambdabot> No quotes match.
09:59:16 <quchen> Category theory is largely an emergent property of Haskell I guess. SPJ implements the rules, not what they lead to.
09:59:17 <notdan> enthropy: baah, that sucks :(
09:59:17 <enthropy> that's why the binaries of ghc include them
09:59:26 * hackagebot snap-extras 0.7 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.7 (DougBeardsley)
09:59:59 <monochrom> @quote lax.monoid
09:59:59 <lambdabot> geheimdienst says: haskell makes hard things easy and easy things a strong lax monoidal endofunctor ...
10:00:14 <monochrom> (one last time)
10:00:15 <monochrom> @quote lax.monoid
10:00:15 <lambdabot> malcolmw says: i want a book "Lax monoidal functors and coalgebraic specification for dummies"
10:00:38 <Cale> So, we can sort of adjust the definition of an ordinary monoid a bit to remove the mention of elements, first by saying that we have a pair of functions eta: 1 -> M, and mu: M x M -> M, and then specifying the laws in terms of those
10:00:49 <monochrom> hrm, would that be a way to say "monads and oop for dummies"? :)
10:01:16 <monochrom> or maybe "monads and lazy data structures for dummies"
10:01:22 <quchen> monochrom: ⊥?
10:01:46 <Cale> and that would generalise immediately to an arbitrary category with products
10:01:51 <Cale> but that's not quite good enough for us
10:01:57 <monochrom> ⊥ sounds too specific
10:02:14 <Cale> We want mu: M . M -> M where . here is composition of functors
10:02:35 <Cale> and mu is a natural transformation, i.e. a polymorphic function
10:02:45 <Cale> (mu is join in Haskell)
10:02:51 <Cale> :t join
10:02:52 <lambdabot> Monad m => m (m a) -> m a
10:03:27 <argiopeweb> Cale: Since you seem to be knowledgeable and inclined to discuss, are you aware of a reason for the lack of a Ring class? Seems Num should be a subclass of Ring...
10:03:51 <Cale> So we want to replace the product x with some other operation on objects of the category, and this 1 which was the identity of the product with some identity of sorts for that operation (at least up to isomorphism)
10:03:59 <Cale> and if you do that, you get the notion of a monoidal category
10:04:17 <Cale> argiopeweb: Not all instances of Num are rings
10:04:21 <Cale> In particular, Float
10:04:26 * hackagebot hermit 0.3.1.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.3.1.0 (AndrewFarmer)
10:04:27 <argiopeweb> Ooh, good call.
10:04:34 <argiopeweb> IEEE FP always mucking up the works.
10:04:53 <Cale> But yeah, we should take abs and signum out and give them their own class
10:04:57 <prophile> Eq on floats isn't an equivalence relation either
10:05:02 <prophile> doesn't stop anyone
10:05:51 <Cale> Eq obviously stands for Equibblywobbly
10:06:06 <prophile> ah, of course
10:07:18 <argiopeweb> Cale: That would make much more sense, though I imagine the standard "let's not be mean to beginners" line of reasoning would kick in quickly.
10:07:28 <geekosaur> just think of it as the same problem as Ord being conflated between a total order and a useful order for building e.g. trees
10:07:48 <quchen> Ord for Complex please!
10:07:52 <geekosaur> not to mention the shambling horror of Enum/Bounded
10:08:16 <Cale> Enum needs to lose the pred/succ/toEnum/fromEnum nonsense.
10:08:21 <monochrom> my opinion is that "Float makes Eq not an equivalence relation, Num not a ring" is overblown
10:08:32 <Cale> I'd like to just think of Enum as "how the list sequence syntax works"
10:08:53 <argiopeweb> IMHO, Enum exists to provide backwards compatibility with C-style reasoning.
10:08:57 <Cale> The fact that toEnum and fromEnum go via Int make them pretty useless
10:09:23 <Cale> Or at least, often incorrect somehow.
10:09:33 <quchen> Not even given the partiality of Enum the typeclass hierarchy is creepy. http://i.imgur.com/vTYIZE2.png
10:10:11 <quchen> Apologies for that awkward sentence
10:10:38 <quchen> Problem is you can't just go out and fix these issues because each simple change to that hierarchy is a major code break
10:10:43 <enthropy> your flowchart is missing Rational
10:11:04 <quchen> enthropy: Submit a patch, it's from the Haskell 2010 report :-)
10:11:47 <enthropy> it makes it look like there's no point of having 4 classes for Fractional,RealFrac,Floating and RealFloat
10:11:52 <argiopeweb> Unfortunately so, though hopefully 7.8 will be a proof of concept for big hierarchy changes and will make future changes easier.
10:12:33 <Cale> "Real" is very unfortunately named
10:12:53 <Cale> Seeing as most types of computable reals won't have a sensible instance of it.
10:13:02 <quchen> argiopeweb: 7.8 doesn't make a "big" hierarchy change. The Monad ⇒ Functor (logically) thing is already in Haskell, you just have to connect the dots. Changing the number classes is way harder I think.
10:13:37 <Cale> Num has changed though!
10:13:40 <Cale> Recently
10:13:52 <Cale> It lost its superclass constraints
10:14:17 <quchen> "Changed"
10:14:20 <argiopeweb> quchen: Apoligies if I implied big. My reasoning is that the community hasn't been receptive to actually implementing the (obvious) hierarchy in past, so this small change may pave the way to larger changes.
10:14:37 <argiopeweb> Though yes, changing the number classes will be a bear.
10:14:46 <monochrom> no, I think "Real" just means "not Complex"
10:15:01 <Cale> Moving abs and signum out of Num would be almost the only thing I would really worry about doing.
10:15:20 <monochrom> if you accept the name "Integral" then you accept the name "Real"
10:15:35 <quchen> argiopeweb: No need to apologize, I didn't mean to say your statement was - well, apology worthy.  What I meant was that changing number classes would not mean changing them but completely removing them, and replacing them with something else.
10:15:51 <Cale> Apart from the naming being a little odd, the rest of the classes are *reasonably* sensible...
10:16:19 <Cale> Well, toInteger maybe also deserves its own class, separate from the division algorithm stuff.
10:16:45 <argiopeweb> quchen: Mmm. A complete rewrite would probably be a "in the next standard" type of thing. Unfortunate.
10:17:02 <quchen> argiopeweb: From what I can tell after working with the Applicative ⇒ Monad issue - for which the actual change is *trivial* - changing number classes have lots of additional burdens. a) nobody knows a good hierarchy to begin with, no matter how outlandish. b) the rat's tail of such a change can be pretty large.
10:17:06 <prophile> 2022?
10:17:12 <Cale> argiopeweb: Implement first, standardise after
10:17:40 <Cale> There's no point in having a standard which describes zero implementations.
10:18:15 <quchen> argiopeweb: For example the AMP implements warnings to allow you to make your code future-proof. I can't see that happening in the number hierarchy case.
10:18:42 <Cale> I don't think the number hierarchy needs really big changes.
10:18:49 <Cale> Just maybe a couple of splits
10:19:02 <Cale> It's better thought out than it appears at first.
10:19:31 <quchen> Cale: It's in this awkward spot between practicality and math.
10:19:50 <quchen> That spot is less awkward than either of the corner cases though. ;-)
10:20:11 <Cale> I wouldn't want it to reflect the mathematical hierarchy if the instances are going to lie
10:20:21 <Cale> and the instances not lying would be inconvenient and silly
10:20:38 <Cale> So it's better that the names be a bit non-technical
10:20:43 <Cale> (i.e. Num instead of Ring)
10:21:07 <dwcook> @type catch
10:21:12 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
10:21:22 <Cale> If we start allowing the implementation of superclass methods in subclass instances, then splitting abs and signum out of Num might be made relatively painless.
10:21:54 <quchen> Cale: Right, that would actually be a decent addition to GHC.
10:22:20 <argiopeweb> That would be very neat.
10:22:28 <Cale> class Arith a where (+), (*), (-), negate, fromInteger
10:22:39 <Cale> and then have Num subclass Arith with abs and signum
10:22:40 <quchen> "Relatively" painless would be a process similar to the AMP though, because otherwise GHC complains that Num doesn't define 'negate'.
10:23:11 <Cale> hm?
10:23:23 <quchen> Sorry, not negate, but abs
10:23:41 <Cale> Well, I'm thinking we'd make Num keep its present meaning
10:23:50 <Cale> but define a new class which is slightly more general
10:24:22 <Cale> If we want to maximise backward compatibility anyway
10:24:36 <quchen> So you're proposing a class SubNum, and then SubNum ⇒ Num? SubNum contains +*- etc, Num adds abs/signum? I see.
10:24:44 <Cale> I called it Arith
10:24:52 <quchen> Yep
10:25:04 <Cale> yeah
10:25:32 <Cale> So, then you do something similar as well with Integral
10:25:45 <Cale> class Division a where ... all the division stuff...
10:26:08 <aloiscochard> Hi everyone, I don't understand why I'm getting an "Illegal polymorphic or qualified type" here http://lpaste.net/93257 ? could someone please give me some hints?
10:26:43 <Cale> class Division a => Integral a where toInteger :: a -> Integer
10:27:15 <enthropy> is there a systematic way to know where the bindings.dsl.h is installed?
10:28:31 <Cale> aloiscochard: That is kinda weird, but you should be aware that your definition of query won't use the same 'a' as the overall signature if you write it like that
10:29:00 <aloiscochard> Cale: forget query, it's a old code I forgot to remove, that's why it's commented out
10:29:03 <Cale> aloiscochard: I think you may want to add {-# LANGUAGE ScopedTypeVariables #-} to the top of your module and make  bind :: forall a. ...
10:29:05 <aloiscochard> oops
10:29:07 <argiopeweb> Cale: As for the implement first, standardize after methodology, I much prefer that to the C++ standardization process. Very aggravating.
10:29:09 <aloiscochard> there is two query :-)
10:29:43 <aloiscochard> Cale: thank you, I'll try that. It looks like it's related to the fact that Representation is a type family thing
10:30:06 <Cale> oh!
10:30:20 <Cale> oh yeah, that should be a kind error
10:30:33 <Cale> What's Representation a doing in the class context?
10:30:39 <aloiscochard> Cale: no help with ScopedTypeVariable + forall
10:30:52 <Cale> Representation isn't a class
10:31:20 <Cale> Or a type constructor which otherwise produces something of kind Constraint
10:31:23 <aloiscochard> Cale: it's a type
10:31:27 <aloiscochard> oh ok
10:31:27 <Cale> So it doesn't belong in the bit before the =>
10:31:34 <aloiscochard> I see *facepalm*
10:31:40 <enthropy> probably you want (Resource a)
10:32:06 <aloiscochard> I'm moving forward I replaced with Resource a and now: `Representation' is a type function, and may not be injective
10:32:47 <Cale> Right, that's a problem because when you go to use bind, it will have to know which 'a' you want.
10:32:59 <Cale> and it won't be able to determine that only knowing Representation a
10:33:14 <aloiscochard> (update paste: http://lpaste.net/93257)
10:33:28 <aloiscochard> Cale: can I be a bit more explicit then?
10:33:50 <aloiscochard> Ah I see!
10:33:53 <aloiscochard> I think I got it
10:34:00 <Cale> You can *maybe* solve that problem by taking a parameter of type Proxy a, or else making it an associated data type rather than an associated type synonym
10:34:25 <enthropy> aloiscochard: the `a' in the query isn't equal to the `a' two lines above
10:34:30 <aloiscochard> Cale: I think I see how to solve, by having the result type containing Resource, that should make inference work, right?
10:34:40 <enthropy> but maybe that doesn't matter
10:34:45 <Cale> enthropy: That actually might be okay, yeah
10:34:57 <aloiscochard> enthropy: oh, really. what the difference then?
10:35:09 <Cale> Though aloiscochard should certainly turn off the monomorphism restriction
10:35:26 <aloiscochard> I have DeriveDataTypeable, ExistentialQuantification, NoMonomorphismRestriction, TypeFamilies, Cale
10:35:28 <Cale> aloiscochard: Type variables only scope over the one type signature they occur in
10:35:35 <FreeFull> I wonder if the monomorphism restriction will ever be off by defualt
10:35:39 <FreeFull> default*
10:35:54 <enthropy> FreeFull: it's not all bad
10:36:01 <Cale> If you want them to scope over the entire function definition, you can turn on ScopedTypeVariables, and then explicitly quantify them with forall
10:36:17 <enthropy> otherwise they would never have added it
10:36:24 <FreeFull> enthropy: I do admit monomorphism can make things faster
10:36:25 <aloiscochard> Cale: I think I understood (well I hope), I'll work more on it and comeback if I have more issue.
10:36:25 <Cale> The monomorphism restriction should just be a warning IMO.
10:36:27 <FreeFull> Sharing and such
10:36:37 <aloiscochard> thanks a lot Cale and enthropy for your help :-)
10:36:55 <Cale> There are also cases where it helps numeric type defaulting along, but meh, I don't think it would be a huge loss.
10:38:34 <an6502> Hey, somebody here a TemplateHaskell expert? I'm trying to write a function that generates all the case matches for an Enum, and can't figure out how that is supposed work...
10:38:50 <joelteon> how would you write it normally
10:39:52 <an6502> Basically I can generate matches inside the case with "match (conP 'Main.Emum123 []) (normalB (litE (StringL "Dummy123"))) []"
10:40:29 <an6502> ...and I can enumerate all my Enum cosntructors with "(enumFromTo minBound maxBound :: [MyEnum])"
10:40:38 <an6502> But I fail to combine the two
10:41:31 <an6502> I don't get how I can pass a variable to conP, the TH ' syntax doesn't just work for some arbitrary variable
10:42:24 <exicer> I'm just messing around with http-conduit, trying to make something to allow me to scrape a load of information about films from a certain date. The approach I am using is clearly wrong, as it takes a huge amount of memory. Code is here http://lpaste.net/93260
10:42:28 <exicer> Can anyone point out what I'm doing wrong ?
10:44:17 <enthropy> an6502: use lift
10:45:00 <enthropy> then instead of pattern-matching (since that doesn't give you a Name and it isn't guaranteed to use the ConE constructor)
10:45:28 <enthropy> you can do something like   case x of _ | x == $a -> ...
10:45:57 <Eduard_Munteanu> Cale: after thinking about this some more, I think I want C^I, not I x C for indexing categories. So I guess it's much like diagrams.
10:46:31 <Eduard_Munteanu> Cale: perhaps indexed monads are like that too
10:47:20 <an6502> Hmm, lift gives an Exp not a Name, so I can't pass it to any of those functions like conP, is there a way to convert?
10:47:21 <Eduard_Munteanu> Actually they are somewhere in Endo(C)^I, I suppose
10:48:00 <enthropy>   $(mapM (\y -> do ConE n <- lift y; return n) [False, True] >>= stringE . show)
10:48:15 <enthropy> that gives me a list of names that turns into a string "[GHC.Types.False,GHC.Types.True]"
10:48:57 <Eduard_Munteanu> Now perhaps there's more to say about the relation of C^I to Monad(C)^I.
10:50:21 <enthropy> and that list can also be [minBound .. maxBound :: Bool]
10:50:40 <monochrom> > [minBound .. maxBound :: ()]
10:50:51 <monochrom> @botsnack
10:50:56 <lambdabot>   [()]
10:50:56 <lambdabot> :)
10:52:19 <enthropy> monochrom: do you get the same core if you use (== True) vs. pattern matching?
10:52:24 <an6502> enthrophy: Oh, yes, I see, that seems to work
10:52:39 <an6502> enthrophy: An yes, you're right abotu the enumeration, too ;-)
10:52:48 <FreeFull> @botslack
10:52:48 <lambdabot> :)
10:52:53 <monochrom> likely yes, but test it
10:54:45 <an6502> btw, is there some better way to derive a Lift instance for an Enum type? It seems kinda stupid to have a hundred lines saying lift Enum123 = [|Enum123|], maybe I'm missing something?
10:55:27 <donri> an6502: generate them with TH? :)
10:56:00 <donri> @hackage th-lift
10:56:00 <lambdabot> http://hackage.haskell.org/package/th-lift
10:56:19 <aloiscochard> I tried something a bit different: http://lpaste.net/93261 ... but why the compiler can't deduce the correct Data here?
10:56:39 <an6502> Oh, god, I'm so slow at this TH stuff, probably like 1h of debugging per generated line ;-)
10:56:53 <an6502> I'll see if that package works for me, thanks
10:57:33 <tromp_> > 2**3
10:57:33 <lambdabot>   8.0
10:57:45 <aloiscochard> oh... because there is two different Data needed!
10:58:00 <aloiscochard> damn, I don't see how I can solve this...
10:58:08 <FreeFull> aloiscochard: What happens when you replace the $ with brackets?
10:58:47 <aloiscochard> FreeFull: you mean with parens?
10:59:11 <aloiscochard> FreeFull: same issue with parenthesis
10:59:29 <Mdx> Hi people, can someone help me? I'm doing some fmap exercises and I got stuck on one here. ( http://lpaste.net/93262 )
11:00:37 <Eduard_Munteanu> Mdx: furry should work for other things too
11:00:59 <Mdx> Eduard_Munteanu:  what you mean by that?
11:01:31 <Eduard_Munteanu> Mdx: there's a Fluffy (Either a) probably
11:01:36 <Eduard_Munteanu> That's enough of a hint. :)
11:02:14 <Mdx> hmmmm, I`ll work on that, thanks!
11:04:16 <enthropy> an6502: you can probably get the constructor names out of  (reify ''DataTypeName)
11:05:18 <aloiscochard> what's the preferred way to ask question in 'non real-time', stackoverflow or is there some specific mailing list?
11:05:27 <enthropy> something like  $(reify ''Bool >>= \(TyConI (DataD _ _ _ x _)) -> stringE $ show x)
11:05:35 <enthropy> gives  "[NormalC GHC.Types.False [],NormalC GHC.Types.True []]"
11:06:04 <dfan> aloiscochard: There's a haskell-beginners mailing list; also the Haskell subreddit
11:06:15 <aloiscochard> dfan: cool, thanks!
11:07:03 <ksf_> \o/ ghc compiled and installed!
11:07:10 <ksf_> (and my source typechecks)
11:07:29 <enthropy> aloiscochard: add type signature    (fromJSON jsvalue :: a)
11:07:41 <Eduard_Munteanu> Oh, I think I figured it out!
11:08:29 <aloiscochard> enthropy: shouldn't be 'Result a'?
11:09:25 <an6502> enthrophy: Looks good, thanks! IIRC there was example somewhere explaining how to enumerate record members with reify, will also have a look
11:10:00 <Eduard_Munteanu> If you have an indexed category I -> C, a monad is in (I -> C) -> I -> C. But I think they simplified that to I x I -> (C -> C), which is "smaller" and lets you pick the indices for source and target ahead of time.
11:12:07 <edwardk> is there anyone else here at cufp/haskell implementor's workshop?
11:12:21 <Eduard_Munteanu> Yay, an edwardk.
11:12:26 <jfischoff> is there any reason to use IOArray vs a mutable boxed Vector?
11:12:50 <jfischoff> or vice a versa ;)
11:13:02 <jfischoff> basically which is better when?
11:14:33 <Eduard_Munteanu> edwardk: I was just saying I think they derived indexed monads from some notion of indexed categories. Could you confirm my reasoning?
11:15:06 <edwardk> sounds right
11:15:15 <edwardk> i don't have a firm theoretical underpinning for that
11:15:40 <enthropy> aloiscochard: maybe.. you need a type signature to fix the `a' that's an intermediate value
11:15:58 <enthropy> since you don't have one on the right hand side of data Binding a
11:15:59 <ij> So, there are the functions show and others that are very general and everyone uses. Should one be afraid to try to use them, just because they sound right, but might be imported later?
11:16:44 <Eduard_Munteanu> edwardk: namely, you have indexed categories like I -> C for an index category I and base category C. Then a monad on that is like (I -> C) -> (I -> C). But you can make it "smaller" and write indices upfront: I x I -> (C -> C)
11:17:32 <Eduard_Munteanu> Then you get an indexed monad on the base category.
11:17:45 <Mdx> Eduard_Munteanu:  You made me realize I wasn't using the constructors for Either, thanks !
11:17:56 <edwardk> that sounds coherent
11:18:12 <Eduard_Munteanu> Ok, cool, thanks.
11:18:35 <dfan> Didn't feel powerful enough to go to the implementor's workshop, will be at the symposium tomorrow though
11:18:36 <Eduard_Munteanu> Mdx: I wasn't hinting at that, rather I was suggesting you should call 'furry' again on the Either.
11:18:51 <aloiscochard> enthropy: yep I tried in some place but without success, anyway I have to run so I created a SO question, thanks for your help!
11:19:00 <Mdx> Eduard_Munteanu: yeah, but I didn't had that defined, and while I was defining that I realized my mistake
11:19:00 <aloiscochard> if anyone feel the motivation to help ;-) http://stackoverflow.com/questions/18947222/how-can-i-use-multiple-data-instance-when-one-of-them-is-deduced-from-a-type
11:19:49 <Eduard_Munteanu> Mdx: for newtypes it's commond to define instances like  fmap f = Something . fmap f . unSomething
11:19:53 <Eduard_Munteanu> *common
11:20:08 <Mdx> hmmmm I see
11:20:56 <Eduard_Munteanu> Newtype wrappers, more precisely.
11:22:13 <Mdx> If the newtype is something like newtype Name = String, I need a deriving functor, right?
11:22:39 <Eduard_Munteanu> Mdx: it can't be that
11:22:47 <Eduard_Munteanu> Mdx: unless you mean  newtype Name = Name String
11:22:57 <notdan> "Live" feed from he Haskell Implementors Workshop: http://ezyang.tumblr.com/
11:23:10 <Mdx> oh, ok
11:23:40 <dfan> notdan: Awesome, thanks!
11:25:11 <ksf_> is there a trick to convince ghc not to expand constraint synonyms?
11:25:47 <ksf_> (closed type families rock, but the constraints they generate are plain ugly)
11:27:03 <ksf_> (I just want another way to say Foobar baz ~ True => ...)
11:28:25 <Eduard_Munteanu> Mdx: with GeneralizedNewtypeDeriving, if you have a  newtype Wrapper a = Wrapper (F a)  where F is already a Functor, you can write 'deriving Functor'.
11:29:39 <Eduard_Munteanu> Mdx: which just automates writing an instance like I suggested above
11:31:19 <Mdx> Eduard_Munteanu:  hmmm, that's usefull, thanks !
11:32:35 <Eduard_Munteanu> Mdx: btw, the data deriving Functor is entirely different, newtype deriving works for any typeclass.
11:33:32 <Eduard_Munteanu> (data deriving is specific and only works for a few typeclasses, it isn't just wrapping/unwrapping stuff)
11:33:34 <Mdx> there is much difference between data and newtype? I never understood the distinction clearly
11:34:00 <prophile> newtype has additional restrictions, uses the same underlying type representation, and is more strict
11:34:06 <Eduard_Munteanu> Mdx: no, not very different in most aspects
11:34:24 <Eduard_Munteanu> I was talking about 'deriving' for data vs newtype.
11:34:43 <Mdx> I see
11:35:16 <Iceland_jack> Mdx: http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell & http://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell
11:36:03 <Mdx> Iceland_jack: oh thanks, I look into those
11:36:26 <Iceland_jack> No problem Mdx!
11:36:50 <Iceland_jack> An important reason for using newtype is if you want to make a datatype an instance of some type class
11:37:18 <Eduard_Munteanu> Or a bunch of datatypes.
11:37:22 <argiopeweb> newtype LogDouble = LogDouble Double
11:38:27 <deech> Can someone help me set up a local Hoogle? I got `hoogle data` to create a default database, but when I do `hoogle data all` I get "gzip: ../hackage/cabal.tar.gz no suck file or directory".
11:38:39 <deech> s/suck/such/g
11:39:36 <Eduard_Munteanu> deech: if I was gzip, I'd be offended too :P
11:39:50 <deech> :)
11:43:32 <joelteon> heh, that suchs
11:43:35 <joelteon> suchs
11:43:38 <joelteon> what have you done?
11:43:40 <joelteon> !
11:44:28 <deech> If I may direct everyone's attention away from the funny typo :).
11:56:58 <haasn> > comparing length "re _Show" "to show"
11:56:59 <lambdabot>   GT
11:57:07 * haasn is not amused
11:57:17 <haasn> also is there a name for to . const ?
11:57:19 <joelteon> :t to show
11:57:59 <lambdabot> (Functor f, Show s, Conjoined p, Contravariant f) => p String (f String) -> p s (f s)
11:58:32 <shachaf> haasn: Getters don't get names, usually.
11:58:57 <joelteon> am i lagging or is lambdabot?
11:59:08 <joelteon> lambdabot responded 40 seconds after i typed that
11:59:20 <Cale> :t to show
11:59:27 <Cale> I think it's lambdabot
11:59:30 <lambdabot> (Functor f, Show s, Conjoined p, Contravariant f) => p String (f String) -> p s (f s)
12:00:06 <shachaf> That signature is pretty obvious, don't you think?
12:01:07 <haasn> isn't Conjoined needlessly strong here? Profunctor would work
12:01:26 <ellipsis> I'm trying to run cabal-dev ghci and it's complaining that it can't parse ghc's --info output
12:01:31 <ellipsis> ghc and cabal-dev are both updated
12:02:21 <ellipsis> is it just a bug with cabal-dev or what?
12:06:37 <danilo2> Hello! I'm using TemplateHaskell and I can pass a function name to TH function by prefixing it with ' . I want to ask you If is it somehow possible to pass a constructor name as a function name there? I mean - if I have data X = X, I cannot use it like this: myTH 'X. Instead I'm making now a temp function x = X and use it like: myTH 'x. Is it possible ommiting this step with temp function in this case?
12:11:13 <danilo2> According to the documentation: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html : "Similarly 'C has type Name and names the data constructor C" - but it does not work with newtypes - is it a bug in GHC?
12:15:50 <benmachine> danilo2: 'X works for me, show your code and the error?
12:17:03 <enthropy> aloiscochard|off: leave off the last two forall a. in your http://lpaste.net/93263
12:21:42 <Walther> Hmm. Could someone tell me why this is wrong http://lpaste.net/1061781718765142016
12:22:33 <Iceland_jack> Walther: You can't have an expression in the where clause
12:22:38 <Iceland_jack> it needs to be an assignment
12:23:03 <Walther> Hmm. How can I create conditional definitions then?
12:23:16 <Iceland_jack> you could do:
12:23:16 <Iceland_jack>     a = if even 5 then 5 else 6
12:24:10 <danilo2> benmachine: Ok, brb, I'll make a short example
12:24:23 <Iceland_jack> Or you can omit the local variable and use guards
12:25:08 <Iceland_jack> Also you need to add a type context of (Eq a) to the type, since you will be comparing the values for equality
12:27:01 <Walther> :t compress (x:xs) = if x == head xs then compress xs else x : compress xs
12:27:12 <Walther> > :t compress (x:xs) = if x == head xs then compress xs else x : compress xs
12:27:28 <Walther> Huh.
12:27:37 <lambdabot> parse error on input `='
12:27:37 <lambdabot>   <hint>:1:1: parse error on input `:'
12:27:38 <Iceland_jack> Walther: http://lpaste.net/1061781718765142016 is this what you're looking for?
12:28:10 <Iceland_jack> It's basically the same as: map head . group :)
12:28:18 <Iceland_jack> > group [1,1,1,1,2,3,2,2,4]
12:28:19 <lambdabot>   [[1,1,1,1],[2],[3],[2,2],[4]]
12:28:22 <Iceland_jack> > map head $ group [1,1,1,1,2,3,2,2,4]
12:28:23 <lambdabot>   [1,2,3,2,4]
12:28:51 <Walther> Iceland_jack: edited a bit, now it works but i can't figure out myself what the type signature should be
12:29:06 <Walther> the link should remain the same(? http://lpaste.net/1061781718765142016 )
12:29:30 <Iceland_jack> Walther: I just posted a fixed version! :)
12:29:43 <danilo2> benmachine: http://lpaste.net/93266 <- here you go
12:29:44 <Iceland_jack> Including a correct type signature: compress :: (Eq a) => [a] -> [a]
12:29:47 <Walther> I know! But I'm trying to learn here, not just find the perfect solution! ;)
12:30:06 <danilo2> benmachine: If you want TH.hs file I'll change it to be simple exxample also
12:30:08 <Iceland_jack> Sure :)
12:31:00 <ksf_> .oO( -XStructurallyDecreasingInstances )
12:31:23 <Iceland_jack> Walther: Do you understand the type signature?
12:31:40 <danilo2> benmachine: ah wait, the error is somewhere else! nvm :)
12:31:48 <benmachine> danilo2: :)
12:31:54 <Walther> Iceland_jack: Which one? :P
12:32:03 <Iceland_jack> <Iceland_jack> Including a correct type signature: compress :: (Eq a) => [a] -> [a]
12:32:14 <Walther> hmm
12:32:23 <Iceland_jack> @ty map head . group
12:32:24 <ksf_> li :: (Num t, ElemTy "right" rs ~ t, ElemTy "left" rs ~ [Char]) =>[Var rs]         <--- is that a readable-enough inferred type for a list of extensible eithers ?
12:32:56 <ksf_> (also, note the working polymorphism)
12:33:03 <lambdabot> Eq b => [b] -> [b]
12:34:26 <Walther> I'm having a bit of a difficulty understanding what the "(Eq a) =>" part implies - Eq implies that a has to be a type that can be compared with another element to see if they're equal, but how does the => differ from ->
12:34:31 <Walther> :t =>
12:34:32 <lambdabot> parse error on input `=>'
12:34:38 <joelteon> :t (=>)
12:34:38 <lambdabot> parse error on input `=>'
12:34:40 <Iceland_jack> Walther: => is not a function
12:34:44 <Walther> nod
12:34:50 <Walther> it's part of type declaration
12:34:51 <Iceland_jack> It separates the types from the type constraints
12:35:10 <Iceland_jack> If you have the type signature [a] -> [a] then a can be what ever
12:35:18 <Iceland_jack> but we can't compare ‘what ever’
12:35:36 <Walther> Hmm. So it first requires that a can be compared isEqual, and if that is met, then proceeds with list to list
12:35:43 <ksf_> Walther, in a sense they don't differ. during compilation => get "translated" into ->, in the sense that a dictionary is passed.
12:35:56 <Iceland_jack> ksf_: Yes but that is an implementation detail
12:35:59 <Walther> ^
12:36:08 <ksf_> Walther, if you *really* want to understand the whole thing, google scholar for "qualified types"
12:36:24 <Iceland_jack> Let's say you want to add two numbers Walther
12:36:38 <Iceland_jack> and you want to be able to add Ints as well as Doubles (and Floats and …)
12:36:50 <ksf_> you have to know that it *is* a number, but you don't necessarily care *what kind* of numbers.
12:37:09 <Walther> you want to make sure it ...ha, (Num a) => a -> a ?
12:37:11 <Iceland_jack> You could either create two functions:
12:37:12 <Iceland_jack>     addInt    :: Int -> Int -> Int
12:37:12 <Iceland_jack>     addDouble :: Double -> Double -> Double
12:37:12 <Iceland_jack>     ...
12:37:20 <Iceland_jack> *-> a :)
12:37:22 <Iceland_jack> but yes, exactly
12:37:31 <Iceland_jack> Same thing with show:
12:37:31 <Iceland_jack> @ty show
12:37:32 <lambdabot> Show a => a -> String
12:37:44 <Walther> ah yeah, adding two to get a third, +1 ->a :P
12:37:46 <ksf_> or you could make a giant sum type, data Num = Int Int | Double Double | ....
12:37:47 <Walther> Nod.
12:38:10 <Walther> Ooh, guards can be used in the type declaration?
12:38:15 <Iceland_jack> No
12:38:20 <ksf_> all those aren't solution, that's why we have => :)
12:38:29 <Iceland_jack> They aren't guards
12:38:41 <ksf_> Walther, that's | in the sense of List a = Nil | Cons a (List a)
12:38:41 <path[l]> wow I'm not sure what a type declaration with a guard would even mean
12:38:44 <path[l]> now I have to think about that
12:38:51 <ksf_> Walther, a tagged union in C-speak
12:38:53 <Walther> now this got me curious, if you could have a type declaration that ensures you have two of same type but any type
12:38:53 <path[l]> how would a guard be useful in a type declaration
12:39:02 <Walther> path[l]: ^
12:39:18 <Iceland_jack> Walther: data Foo a = Foo a a
12:39:19 <path[l]> if I just declare something like a tuple (a,a)
12:39:19 <Walther> Say we want to have two strings *or* two integers *or* ...
12:39:23 <path[l]> I've already done that
12:39:31 <Walther> hmm
12:39:36 <path[l]> I dont need a guard, the type variables give me that
12:39:47 <Iceland_jack> Prelude> data Foo a = Foo a a deriving Show
12:39:47 <Iceland_jack> Prelude> Foo 15 pi
12:39:48 <Iceland_jack> Foo 15.0 3.141592653589793
12:40:03 <path[l]> I'm not saying your idea is stupid, I'm saying I've never thought about it so I am now
12:40:03 <path[l]> haha
12:40:10 <Iceland_jack> Walther: You can see that ghci inferred that 15 was a floating-point number
12:40:15 <Iceland_jack> since pi is one
12:40:20 <Walther> hmm, does that fail if you give it a string and a float?
12:40:23 <Iceland_jack> yes
12:40:29 <Walther> or any other two not-equal
12:40:33 <Walther> Hm.
12:40:46 <Walther> I'll say it once again, haskell definitely is interesting :P
12:40:54 <path[l]> shouldnt it be possible to make lambdabot do this?
12:40:55 <Iceland_jack> There's plenty more!
12:40:59 <path[l]> I forgot how to make lambdabot execute code
12:41:05 <Iceland_jack> > 5 + 1
12:41:06 <lambdabot>   6
12:41:17 <donri> > data Foo a = Foo a a deriving Show
12:41:18 <lambdabot>   <hint>:1:1: parse error on input `data'
12:41:23 <donri> @let data Foo a = Foo a a deriving Show
12:41:24 <lambdabot>  Defined.
12:41:26 <path[l]> > let data Foo a = Foo a a in Foo 16 "hello"
12:41:28 <lambdabot>   <hint>:1:5: parse error on input `data'
12:41:31 <donri> > Foo 15 pi
12:41:36 <lambdabot>   Foo 15.0 3.141592653589793
12:41:40 <path[l]> @let data Foo a = Foo a a in Foo 16 "hello"
12:41:40 <lambdabot>  Parse failed: Parse error: in
12:42:10 <Iceland_jack> Walther: Tell me if the type of this makes sense to you:
12:42:10 <Iceland_jack> @ty (\(a:b:bs) -> if a == b then [5] else bs)
12:42:11 <lambdabot> (Eq t, Num t) => [t] -> [t]
12:42:12 <donri> "@let" /= "> let"
12:43:23 <Walther> Iceland_jack: It makes sure that a) t is comparable b) t is a numeral (int/double) c) defines a function that takes a list and spits out another list
12:43:44 <geekosaur> and you can't use `data` in a let binding (you can use it in @let but that's because @let is a bot-specific hack)
12:43:55 <Iceland_jack> Right, and how does Haskell know that the input is: ⅰ) a list, ⅱ) a list of numbers?
12:44:54 <Walther> Eh, no idea really. A list has to have type [a] and a number is of type Num
12:45:18 <Iceland_jack> because we pattern match on the input, Haskell can tell that it's a list
12:45:31 <Iceland_jack> but also because we return a list in the case that (a == b)
12:45:40 <Walther> Nod
12:45:44 <Iceland_jack> @ty (\[] -> 'a')
12:45:45 <lambdabot> [t] -> Char
12:45:54 <Iceland_jack> @ty (\(_:_) -> 'a')
12:45:55 <lambdabot> [t] -> Char
12:46:02 <Walther> I see.
12:46:15 <Iceland_jack> so when Haskell sees [] or (:) (the data constructors for lists) it knows it's dealing with a list
12:46:37 <Walther> What is the difference between x:xs and x:_ ?
12:46:47 <Iceland_jack> the second one just ignores the rest of the list
12:46:59 <Iceland_jack> > let x:xs = "hello!" in x
12:47:00 <lambdabot>   'h'
12:47:01 <Iceland_jack> > let x:_ = "hello!" in x
12:47:02 <lambdabot>   'h'
12:47:04 <Iceland_jack> otherwise no difference
12:47:08 <Walther> Nod.
12:47:14 <Iceland_jack> > let _:xs = "hello!" in xs
12:47:15 <lambdabot>   "ello!"
12:48:09 <Iceland_jack> So can you guess what happens when we do something like: let a:as = "" in as?
12:48:44 <dfan> > > let (x,_,_) = (1,2,3) in x
12:48:45 <lambdabot>   <hint>:1:1: parse error on input `>'
12:48:50 <dfan> > let (x,_,_) = (1,2,3) in x
12:48:51 <lambdabot>   1
12:48:57 <dfan> > let (x,dummy,dummy) = (1,2,3) in x
12:48:58 <lambdabot>   Conflicting definitions for `dummy'
12:48:59 <lambdabot>  Bound at: <interactive>:1:8-12
12:48:59 <lambdabot>        ...
12:49:03 <dfan> is one way that _ is useful
12:49:33 <Walther> mmh
12:49:51 <Iceland_jack> _ makes your intentions more clear and you can make sure that the value is not being used elsewhere in the expression
12:49:56 <mr-> > let (x : _ignoreThis) = "foo" in x
12:49:57 <lambdabot>   'f'
12:50:20 <mr-> and you can still annotate with some documentation!
12:51:00 <Iceland_jack> mr-: That doesn't provide the second guarantee though
12:51:00 <Iceland_jack> > let (a, _hi) = (1, True) in _hi
12:51:01 <lambdabot>   True
12:51:15 <mr-> Iceland_jack: Oh
12:51:28 <mr-> I honestly believed it would
12:51:33 <mr-> The shame!
12:51:40 <elliott> it does disable the warning though
12:51:49 <Iceland_jack> > It is a convention that the compiler will not warn about unused variables that begin with an underscore.
12:51:50 <lambdabot>   <hint>:1:105:
12:51:50 <lambdabot>      parse error (possibly incorrect indentation or mismatche...
12:52:24 <mr-> > let (_ : _ignoreThis) = "foo" in _
12:52:26 <lambdabot>   Pattern syntax in expression context: _
12:52:31 <mr-> how inconsistent ;-)
12:52:39 <Iceland_jack> How is it inconsistent?
12:53:38 <mr-> It's not. It's just weird to treat each of _, _foo and foo differently
12:53:55 <roconnor> _ is different from _foo and foo
12:54:03 <Iceland_jack> _ is used in patterns :) it can't be used as an identifier
12:54:04 <Walther> Heh, this sounds like "say nothing" "nothing"
12:55:03 <mr-> roconnor: and _foo is different from foo, as the first disables a warning, as elliott pointed out
12:56:35 <roconnor> does _foo also enable a warning if it is used?
12:57:56 <roconnor> ``Underscore, "_", is treated as a lower-case letter, and can occur wherever a lower-case letter can. However, "_" all by itself is a reserved identifier, used as wild card in patterns. Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore. This allows programmers to use "_foo" for a parameter that they expect to be unused.
12:58:49 <geekosaur> I think it should since starting to use an identifier that advertises itself as unused is a bug looking for a chance to happen
12:59:29 <enthropy> > view _2 (1,2)
12:59:30 <lambdabot>   2
13:00:02 <geekosaur> yes, I know about lens, and those accessors *do* worry me
13:01:03 <elliott> they're not parameters though.
13:01:03 <enthropy> it should be straightforward enough to warn about `f _unused = _unused' but not warn about _2
13:01:05 <roconnor> I guess those identifiers are not bound in a pattern...
13:01:07 <elliott> there's no reason to apply that rule to parameters.
13:01:11 <elliott> er. to not parameter
13:01:11 <elliott> s
13:11:51 <Polarina> Hello everyone.
13:13:16 <roconnor> hi
13:14:36 * hackagebot yesod-paginator 0.9 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.9 (PatrickBrisbin)
13:14:41 <jetho> exit
13:14:45 <Polarina> What are you all up to?
13:14:52 <roconnor> accounting
13:15:02 <roconnor> with hledger, so I guess I'm on topic.
13:16:58 <hiptobecubic> I can't believe arch doesn't have a haskell-platform package. wtf
13:17:11 <hiptobecubic> what a disaster this is
13:17:34 <Earnestly> hiptobecubic: Why should arch package haskell-platform as it is?
13:17:35 <roconnor> haskell-platfrom is stupidish...
13:17:54 <roconnor> though given the current disasterish that cabal is, I'm starting to understand the platform.
13:18:08 <Earnestly> Also, arch does apparently package haskell-platform
13:18:26 <Earnestly> Ah, not Arch, the AUR.  Nevermind.
13:19:59 <hiptobecubic> Earnestly, even that is no longer maintained
13:20:16 <roconnor> hiptobecubic: have you tried NixOS?
13:20:26 <Earnestly> hiptobecubic: Seems in keeping, arch ships ghc 7.6.3
13:20:59 <donri> haskell-platform wouldn't make sense for arch because they want to ship the latest of everything and then they wouldn't be shipping a correct platform set
13:21:32 <hiptobecubic> donri, they could ship the latest platform
13:21:51 <donri> hiptobecubic: but that would mean shipping not-latest of all the packages included in platform
13:21:56 <Earnestly> That would conflict with many of the haskell-foobar packages though
13:22:05 <hiptobecubic> donri, if they push every version bump out to everyone for every core package, no one will have any time to write anything. we'll all be reinstalling world all day
13:22:23 <donri> hiptobecubic: yes, i'm not saying it's a good idea. i'm saying it's the arch way :)
13:22:50 <hiptobecubic> it's not even up to date
13:22:58 <hiptobecubic> they ship cabal 1.16
13:23:04 <donri> oldschool!
13:23:19 <hiptobecubic> well it defeats the only argument they may have had
13:23:47 <Earnestly> Arch linux provides a way to flag packages as out of date
13:24:16 <Earnestly> Actually, cabal is flagged apparently anyway
13:24:18 <hiptobecubic> Earnestly, they *are* flagged
13:24:44 <Earnestly> Yup, just take the pkgbuild and build the newer release
13:26:52 <bgamari_> ocharles, is tekmo ever online?
13:27:03 <donri> bgamari_: yes, but not too often
13:32:28 <donri> @seen Tekmo
13:32:29 <lambdabot> 7EK/\/\O
13:32:38 <donri> ok thank you lambdabot that's very helpful
13:32:45 <donri> preflex: seen Tekmo
13:32:46 <preflex>  Tekmo was last seen on #haskell 1 day, 14 hours, 54 minutes and 3 seconds ago, saying: Alright, I'll talk to you guys later
13:34:00 <monochrom> @seen monochrom
13:34:00 <lambdabot> MONOcHroM
13:34:24 <monochrom> heh, probably seen->leet
13:34:32 <donri> @leet has a close edit distance to seen, i guess?
13:34:32 <lambdabot> hA5 4 c1o$3 EdiT dis+aN(3 +o 5e3N, I 9U3S$?
13:34:37 <donri> ya
13:37:11 <NemesisD> is there any way to annotate source code with breakpoints before loading it into ghci?
13:41:04 <tibbe> hvr: cool
13:41:08 <tibbe> https://gist.github.com/hvr/6648575#file-base-4-6-0-1-vs-4-7-0-0-md
13:47:33 * ksf_ currently thinks that using tries as a backend for extensible records is a good idea. let's see how that holds up to a night of sleep.
13:50:03 <ksf_> while lookup might not be that fast, doing it faster would probably involve quite some pain when it comes to reshuffling records, that is, reordering their type signature.
13:54:42 * hackagebot cipher-rc5 0.1.0.0 - Pure RC5 implementation  http://hackage.haskell.org/package/cipher-rc5-0.1.0.0 (FinnEspenGundersen)
13:57:55 <NemesisD> anyone know how to force cabal test to run threaded
13:58:15 <thoughtpolice> put -threaded in ghc-options for the 'test' stanza
13:59:03 <NemesisD> thoughtpolice: is there any way i could have it run with +RTS -N? the bugs i'm seeing are not solved with just compiling with -threaded
13:59:42 <thoughtpolice> ghc-options: -threaded -rtsopts "-with-rtsopts=-N"
14:00:36 <thoughtpolice> you can also add other stuff to -with-rtsopts there to tune things or whatever
14:00:38 <NemesisD> are my ideas about how the threaded runtime wrong? that if you don't specify -Nn it will run on 1 capability only?
14:01:59 <thoughtpolice> -N is not implied at all, no. so with no extra options it will just run on 1 core
14:02:08 <thoughtpolice> -N by itself means 'use all cores'
14:03:06 <thoughtpolice> (also, note that if you specify -N, your program may seem to use multiple cores in places it would otherwise be sequential - the garbage collector is also multicore if you run with -N)
14:03:46 <NemesisD> now the test is failing again. god this is a nightmare
14:05:08 <NemesisD> i'm trying to test some code that sends different kill signals to child processes. in test it is giving me bogus results
14:05:32 <NemesisD> i.e. its sending a TERM to aa process that does not die on TERM, but reports that it did
14:05:36 <Rembane> NemesisD: But not when you run the actual code?
14:08:10 <NemesisD> Rembane: right if i fire up ghci and run the code it behaves as expected
14:08:29 <NemesisD> i am wondering if the runtime or something is killing child procsesses and giving me back synthetic exit statuses
14:09:22 <NemesisD> i.e. i try to kill that indestructable process with a SIGTERM (15), it lives, then somehow it says it was terminated with signal 15
14:09:43 <NemesisD> i have no idea what is going on anymore.
14:09:59 <geekosaur> @lpaste actual code?
14:10:00 <lambdabot> Haskell pastebin: http://lpaste.net/
14:10:18 <shachaf> hpaste.org is working again.
14:10:23 <Tekmo> How do you know the thread is still alive?
14:10:27 <Tekmo> *process
14:11:19 <donri> Tekmo: getProcessExitCode?
14:11:29 <Rembane> NemesisD: Is it behaving as expected when you compile it?
14:11:49 <donri> oh you were speaking to NemesisD
14:12:02 <NemesisD> actually maybe i'm mistaken. i see the indestructable job gets marked as "defunct" when i send it a SIGTERM
14:12:22 <NemesisD> i'm not sure why that would happen, and only in test
14:12:52 <NemesisD> if i launch it myself and kill it with kill -TERM it sticks around...
14:13:12 <geekosaur> "defunct" means waitpid() has not been called by its parent yet
14:14:27 <donri> bgamari_: Tekmo is here now btw ;)
14:14:44 <Tekmo> Yeah!
14:14:46 <Tekmo> :)
14:14:57 <bgamari_> so he is
14:15:05 <NemesisD> geekosaur: after the term in the test i'm calling getProcessStatus False True, false sets WNOHANG, true sets WUNTRACED
14:15:31 <bgamari_> Tekmo, Did you mean to include a Text in DecodeError?
14:15:49 <bgamari_> You'd want some way to look at the text decoded up to the point of the error, no?
14:16:12 <Tekmo> bgamari_: There are two possible ways to do this
14:16:19 <Tekmo> One is to include Text in DecodeError
14:16:20 <geekosaur> you don't want WNOHANG unless you're looping on it
14:16:27 <Tekmo> The other is to spit out one final `Some` before returning an error
14:16:43 <bgamari_> Tekmo, But the Some would need to include a continuation
14:16:47 <geekosaur> (WUNTRACED is probably irrelevant, unless you have a binding to ptrace somewhere and know how to use it)
14:16:52 <Tekmo> bgamari_: The continuation is the error
14:17:07 <bgamari_> fair enough
14:17:10 <NemesisD> geekosaur: so the test code is the one deciding on the wnohang. the thinking there is that i'm explicitly testing the case where a process does not respond to a sigterm
14:17:27 <bgamari_> I think I actually prefer your approach
14:17:32 <NemesisD> geekosaur: i'm asserting that if my program is configured to only sigterm, it does not force a stubborn process to die with a sigkill
14:18:24 <geekosaur> WNOHANG means return immediately if the process has not exited already at that point. if you call it immediately after sending the signal, whether it has exited by that point or not is up to (a) the system's scheduler (b) whether it has a SIGTERM handler that does some work first
14:18:30 <donri> Tekmo, bgamari_: is the ByteString even needed in DecodeError then? isn't it the same as the leftover from the previous Some?
14:19:15 <bgamari_> donri, true, I think you would want to include a Word8 though
14:19:15 <NemesisD> geekosaur: yeah that's what i want. if i set wnohang to false then my test will hang forever on the case of the process that eats sigterms, no?
14:19:24 <bgamari_> being the invalid byte of the encoding
14:19:47 <Tekmo> donri: This assumes that there is at least one `Some`
14:20:19 <donri> bgamari_: isn't that ByteString.head leftOver? or can it be off-set...
14:20:26 <geekosaur> yes, but if you set it true then you require the process to have already been scheduled and responded to the signal right then, no delaying at all and no allowance for the fact that the system may schedule other processes instead of you or the target process
14:20:45 <geekosaur> either you want a loop or you want an alarm signal to interrupt the waitpid call
14:20:54 <geekosaur> just calling it once is NOT what you want
14:21:03 <NemesisD> geekosaur: oh sorry, yes my code checks at least twice whenever it does that
14:21:35 <geekosaur> I would not want to bet on just twice being enough either, unless you have a significant delay
14:21:48 <Tekmo> donri: Remember that the consuming code has no way to guarantee in the types that at least one `Some` precedes every `DecodeError`
14:22:01 <geekosaur> but it sounds like all your calls happen before it has actually exited, then you never check again so it stays as a zombie
14:22:38 <NemesisD> geekosaur: maybe you could help me with this feature, i can put up what i have on a branch on github
14:22:43 <bgamari_> Tekmo, you could always just pass an empty Some if the first codepoint was invalid
14:23:03 <donri> Tekmo: i should read the code before commenting ;)
14:23:09 <NemesisD> geekosaur: i'm the maintainer for angel. i'm trying to add support so a user can configure if it should forcibly kill a process that does not yield, and how long to wait
14:23:12 <Tekmo> donri: :)
14:23:41 <Tekmo> bgamari_: What I mean is that the person consuming the `Some` can't prove in the types that they will get at least one `Some` before a `Decode`
14:23:47 <Tekmo> *`DecodeError`
14:24:36 <bgamari_> That is true
14:24:43 * hackagebot GLUtil 0.6.7.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.7.1 (AnthonyCowley)
14:24:58 <geekosaur> that sounds straightforward, set a timer ( http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Signals.html#v:scheduleAlarm ) and wait without WNOHANG (but you'll probably need an exception handler because it probably throws on -1/EALRM)
14:26:35 <geekosaur> sorry, EINTR. you will also need a signal handler, but possibly that can just return if you use the exception handler to catch the EINTR
14:29:41 <NemesisD> geekosaur: i'm going to put it on github for now, maybe if you have a chance you could take a look. i need a break. so far i've wasted my entire weekend on what should have been a 30 minute feature
14:31:07 <geekosaur> the POSIX process stuff is a bit painful to use from Haskell, but even harder if you don't understand the POSIX process model. if you study that then you may well be able to figure it out yourself, modulo adjustments needed for Haskell interfaces tending to turn C syscalls returning -1 into exceptions
14:32:00 <NemesisD> i don't disagree but if i am not in a good mental state right now to continue on this
14:32:18 <NemesisD> and it would also be helpful if someone with a bit more experience could keep me from just bashing on the problem for hours on end
14:32:53 <Tekmo> NemesisD: Get some sleep!
14:33:08 <Tekmo> Nothing better than well-rested mind for tackling hard problems
14:33:35 <NemesisD> Tekmo: that re-energized me from last night but its now 3pm and i've been thrashing on this all day yet again
14:34:02 <Tekmo> NemesisD: Take a break again
14:34:16 <Tekmo> Some problems you can't speed up by just throwing more hours at them
14:34:23 <Maior> so, er, I'm failing a bit - how do I use Data.Array's array to build an array with every element being a constant value?
14:34:25 <Tekmo> Just rest and try it again tomorrow
14:34:47 <NemesisD> i believe the actual problem is that i'm out of my depth on this problem (though shouldn't be because killing a child process should not be this hard)
14:34:54 <Maior> I suspect my list comprehension is fail
14:35:01 * geekosaur is winding toward a nap himself...
14:35:20 <geekosaur> NemesisD, you'd be surprised. the POSIX process model is a bit... arcane
14:35:58 <NemesisD> anyways, if anyone wants to give it a look, i'd appreciate it. if not, that's fine too. https://github.com/MichaelXavier/Angel/blob/sigkill/test/Angel/JobSpec.hs#L38
14:36:12 <geekosaur> the simple cases (like just waiting for it to exit) are simple; the case you're trying to deal with is often the most complex part of daemon nannies
14:36:56 <geekosaur> (rivaled only by the code to respond to starting the child process failing before the exec())
14:36:57 <NemesisD> if i could summon users of angels to solve this problem for me i would
14:44:21 <ReinH> hai
14:44:58 <hpc> NemesisD: just post on stackoverflow "haskell can't to this! also i am using this library" ;)
14:46:59 <Cale> Summoning angelic hordes is overrated anyway. GO BMX BANDIT!
14:47:29 <ReinH> > listArray (0,10) (repeat 0) -- Maior
14:47:30 <lambdabot>   array (0,10) [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(...
14:48:30 <benmachine> Maior: maybe listArray would be easier?
14:49:03 <benmachine> Maior: (this intended as a stalling tactic while I look up the docs)
14:50:27 <Maior> ReinH: ah, excellent, thanks
14:50:37 <benmachine> oh I'm slow :(
14:51:42 * Maior is porting http://fabiensanglard.net/rayTracing_back_of_business_card/index.php to haskell
14:51:46 <Maior> (badly)
14:52:34 <Maior> is there a function along the lines of (Array i a) -> (a->b) -> (Array i b) ?
14:52:48 <Maior> Hoogle's not coming up with much
14:52:51 <Maior> a sort of array-y-map
14:52:57 <Eduard_Munteanu> Maior: fmap?
14:53:07 <ReinH> Maior: fmap
14:53:12 <Maior> :t fmap
14:53:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:53:13 <Eduard_Munteanu> @instances Array i
14:53:14 <lambdabot> Couldn't find class `Array i'. Try @instances-importing
14:53:20 <Maior> oh, an Array's a Functor? excellent
14:53:32 <Maior> er, (Array i) I guess
14:53:35 <Eduard_Munteanu> Maior: it better be :)
14:53:38 <ReinH> > fmap succ (listArray (0,5) (repeat 0))
14:53:39 <lambdabot>   array (0,5) [(0,1),(1,1),(2,1),(3,1),(4,1),(5,1)]
14:53:48 <Maior> awesome, thanks
14:54:00 <shachaf> Hmm, is it a Profunctor?
14:54:10 <shachaf> I guess not, because you need constraints. :-(
14:54:13 <ReinH> If you want it flipped, Control.Lens defined <&> (and so can you)
14:54:16 <shachaf> :t Data.Array.ixmap
14:54:16 <lambdabot> (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
14:54:25 <ReinH> > listArray (0,5) (repeat 0) <&> succ
14:54:26 <lambdabot>   array (0,5) [(0,1),(1,1),(2,1),(3,1),(4,1),(5,1)]
14:54:32 <shachaf> Er, and there's the (i,i) argument.
14:54:36 <ReinH> shachaf: ixmap transforms indexes
14:54:52 <shachaf> ReinH: Right. Hence the question about profunctoriality.
14:54:57 <ReinH> shachaf: right
14:55:01 <Eduard_Munteanu> Are associated data families subsumed by associated type families plus GADTs?
14:55:04 <ReinH> shachaf: I confess to not understanding profunctors :)
14:55:21 <benmachine> I wonder if you could package the range into the array to make it a profunctor
14:55:31 <shachaf> ReinH: "P is a Profunctor" just means "P is contravariant in the first argument and covariant in the second"
14:55:32 <ski> profunctors are like functors, but more pro
14:55:43 <benmachine> hmm, I guess not because you'd need to know how the function mutated the range
14:55:48 <ReinH> shachaf: oh. Is that all.
14:55:54 <shachaf> I.e. lmap :: (b -> a) -> P a x -> P b x; rmap :: (a -> b) -> P x a -> p x b
14:56:03 <ReinH> shachaf: can you use that in a sentence please?
14:56:03 <benmachine> ReinH: (->) is kind of the prototypical example
14:56:11 * ski prefers the term "difunctor" for that
14:56:54 <ski> (.. another argument for being able to rename-on-import)
14:56:58 <Eduard_Munteanu> class ... t ... where   data Foo t ... where Con :: ... -> Foo t ...   seems doable with a single GADT and a type family sending things to their respective indices.
14:56:59 <shachaf> alt.data.functor.di.di.di
14:57:03 <shachaf> (As monochrom might say.)
14:57:10 <Eduard_Munteanu> Erm, Con would appear in the instance.
14:57:13 <BMeph> HAs anyone yet defined ":0", ":1", ":2", etc. as types? :)
14:57:47 <ski> @type undefined :: 0
14:57:48 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 0
14:58:31 <Eduard_Munteanu> In fact despite data's convenience, I suspect it's better to use 'type' since it's more general.
14:58:34 <BMeph> @type undefined :: :0
14:58:35 <lambdabot> parse error on input `:'
15:00:30 <benmachine> BMeph: : is an operator symbol but 0 is not
15:00:55 <benmachine> ski: sometimes I think I'd rather always use the wrong name than sometimes use it :P
15:01:41 <Eduard_Munteanu> I guess I should've seen that coming, GADTs are already typeclassy so if you combine them with an existing one...
15:01:58 <ski> benmachine : the wrong name being the one you wanted to use, or the one the library actually used ?
15:02:27 <benmachine> ski: the one the library actually used, I suppose
15:02:56 <ski> (rename-on-export would sometimes be nice as well. Racket has both)
15:03:03 <benmachine> ski: I mean, I don't want rename-on-import because I don't want every to be able to fix mistakes each in their own unique way
15:03:46 <ski> well, if the library author acknowledges it's an error, it can be changed in a later version
15:04:14 <ski> so, i suppose the question is in case the author doesn't want to change, but there one (or just a few) alternative proposals
15:05:13 <ski> implemented in a proper way, the module system should still know they are the same thing, even when referred to by different names, so third party should still be able to use simultaneously code that uses one name and code that uses the other one
15:06:21 <ski> (and if they really want to, they could rename one of them back to the other)
15:07:35 <ksf_> BMeph, 0,1,... *are* types since 7.6
15:07:39 <ksf_> ...of kind Nat
15:08:20 <quchen> ksf_: Werent type-level Nats introduced in 7.7?
15:08:25 <shachaf> So not inhabitable types. In ski's terminology.
15:08:25 <ksf_> http://ghc.haskell.org/trac/ghc/wiki/TypeNats
15:08:51 <ksf_> 7.6 . closed type families and a proper constraint solver for + etc is 7.7
15:09:06 <shachaf> I wish Haskell had a nice general way of talking about variance of data types.
15:09:17 <ksf_> shachaf, you can get values out of them, though.
15:09:28 <shachaf> Instead of needing Functor, Contravariant, Bifunctor, Profunctor, "Contravariant-in-the-first-argument", ...
15:09:38 <ksf_> > sing :: Sing (2*2) -- works in 7.7
15:09:39 <lambdabot>   <hint>:1:15: Illegal literal in type (use -XDataKinds to enable): 2
15:10:22 <shachaf> sing :: Sing 4 works in 7.6, though.
15:10:29 <ksf_> yep
15:10:49 <enthropy> @let {-# LANGUAGE DataKinds #-}
15:10:50 <lambdabot>  Parse failed: Parse error: EOF
15:10:50 <Rc43> Hi, guys.
15:12:24 <Rc43> I implemented my simple web client for one site, careful creation of headers, queries and requests, etc... only for see that Network.HTTP doesn't support https. =/
15:12:27 <Rc43> Any workaround?
15:16:05 <ksf_> Rc43, curl
15:16:16 <chrisdone> use http-conduit
15:16:19 <chrisdone> curl isn't thread-safe
15:16:22 <ksf_> ...or that.
15:16:42 <ski> shachaf : habitable types
15:16:43 <chrisdone> and is generally messy, uses strings in a bunch of places
15:16:58 <Rc43> ksf_, chrisdone, ye, I have seen these alternatives on SO. There is no workaround without re-coding?
15:17:18 <Rc43> may be Network.HTTP supports it but in obscure way or something
15:17:23 <chrisdone> dunno. never used network.http
15:18:00 <nwf> Anyone at ICFP not have dinner plans or have room for two in plans? :)
15:18:43 <ski> shachaf : btw, OCaml has variance annotations in type definitions, see <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual016.html>
15:19:06 <dfan> nwf: You might try asking on twitter with #ICFP
15:19:17 <shachaf> ski: That's subtyping, though, isn't it?
15:19:41 <ski> yes, but the idea of variance is basically the same
15:20:07 <shachaf> Does it give you the ability to fmap?
15:20:31 * ksf_ tries to think of a good argument against unsafecoerce for his next go at heterogenous products and sums
15:20:59 <ski> if `A' is a subtype of `B', and we use subsumption rather than coercion subtyping, then we get an O(0) mapping from `c A' to `c B', for any covariant `c'
15:21:17 <tearful> So I'm trying to count letter frequencies of a large file (~ 140M) and I keep running out of memory. I'm using Data.ByteString.Lazy.Char8's readFile and foldl'. The fold shouldn't need the whole file in memory... Any ideas?
15:21:32 <shachaf> ski: Sure. But I want fmap.
15:21:38 <shachaf> I'd also like to understand subtyping.
15:21:38 <ksf_> ...only way to get around O(n) access, and if I chose O(log n) (tries), then I get reshuffling for free.
15:22:38 <ksf_> tearful, maybe you're building up a giant list of additions to your data structure?
15:22:49 <ksf_> tearful, the general advice is: profile
15:23:03 <ksf_> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html
15:23:32 <ksf_> or rather http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/prof-heap.html
15:23:58 <tearful> I'll try that. Thanks
15:24:38 <shachaf> ski: I see two variance annotations. Oughtn't there be four?
15:26:15 <ski> shachaf : well, istr you could write both, but it seems not
15:26:42 <ski> for abstract types, if you omit the variance, it assumes invariance
15:26:49 <ski> hm
15:26:52 <ksf_> noone wants to talk me out of unsafeCoerce?
15:27:38 <ski> ksf_ : not sure what you mean by "heterogenous products and sums" ..
15:27:48 <ksf_> I meant extensible :)
15:28:01 <ski> like Trex ?
15:28:16 <ksf_> like trex, hlist, records, grapefruit, vinyl
15:28:27 <ski> ok
15:28:45 <ksf_> though most of those lack inbuilt support for sums.
15:29:44 * hackagebot NineP 0.0.2.1 - 9P2000 in pure Haskell  http://hackage.haskell.org/package/NineP-0.0.2.1 (SergeyAlirzaev)
15:30:00 <ksf_> I'd use tries as backing for the products, and sums are single key/value pairs. plus some type magic so you feel like you're programming haskell
15:30:07 <ksf_> (and lookups etc. never fail)
15:34:44 * hackagebot GLUtil 0.7 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.7 (AnthonyCowley)
15:38:03 <Maior> sss
15:44:13 <thesofa> hey guys im trying to play around with parsec
15:44:26 <thesofa> but im having issues having debug.trace work for me consistantly
15:44:48 <thesofa> in ghci, it is only printing the first time i run the expression
15:44:56 <thesofa> example: http://lpaste.net/6856726489891602432
15:45:44 <thesofa> is ghci caching the result of the calculation or something?
15:46:32 <joelteon> i think it's tracing the evaluation of that expression
15:46:44 <joelteon> no wait never mind
15:46:46 <joelteon> ignore me
15:47:28 <enthropy> one way might be to add an argument to expr
15:49:07 <thesofa> looks like ghci has a +r flag that does what i want, but its for compiled code only?
15:49:35 <enthropy> http://lpaste.net/6856726489891602432
15:50:16 <enthropy> that one is missing one parens I think
15:51:04 <thesofa> yea, im playing around trying to grasp parsing
15:51:19 <thesofa> but id like a debug.trace crutch to do some of the thinking for me :)
15:51:52 <thesofa> and it does appear to work, but only once
15:52:02 <thesofa> which is kind of annoying
15:52:11 <enthropy> did you see my alternative?
15:52:18 <enthropy> also you could use the ghci debugger
15:53:07 <thesofa> oh, you just added an argument and that forces reevalutaion?
15:53:14 <thesofa> sorry, they looked so similar
15:53:51 <ski> ksf_ : ok
15:55:46 <thesofa> that does do the trick, enthropy. thanks!
15:56:33 <thesofa> haskell can be so lazy sometimes :P
15:56:45 <chrisdone> hur hur
15:56:48 <chrisdone> =p
16:00:33 <chrisdone> i'm making a simple emacs wrapper to the fpco api. things implemented so far, type checking, hlint, get type info of identifier at point (including local bindings), jump to definition. todo: autocomplete, hoogle search, stylish haskell
16:04:44 <chrisdone> Peaker: hej
16:04:53 <Peaker> chrisdone: hey
16:05:09 <chrisdone> Peaker: working on emacs bindings to the fp complete ide as we speak =p
16:05:51 <Peaker> chrisdone: awesome! :)
16:09:19 <chrisdone> Peaker: here's the approach: you make a project on the site e.g. by cloning your git repo on the site, then you clone it locally, in your local copy you put a .dir-locals.el file with the project id in there. you cabal install fpco-api and run it with your account token (from the account page), run fpco-server and then you just start hacking. emacs will talk to the fpco-server which knows how to talk to fpcomplete.com's api
16:09:50 <chrisdone> Peaker: the reason for the program is to support editors like vim that can't handle so much state
16:10:05 <chrisdone> and we'd prefer to write as little elisp/vimscript as possible =)
16:11:56 <Peaker> yeah, makes sense :)
16:12:10 <Peaker> slightly harder to install than pure elisp, but understandable
16:12:14 <chrisdone> Peaker: in the end it amounts to the usual toolset that emacs users are used to, in varying degrees. type info, definition location info, autocomplete, hoogle search, stylish, but all in one service
16:12:16 <chrisdone> indeed
16:12:46 <chrisdone> i gave some pushback initially about it, i wanted it to be an M-x package-install single step, but yeah
16:13:05 <chrisdone> as a trick we can always say "cabal install fpco-api (y/n)?" and have emacs run it =p
16:19:15 <AfC> When stripping the binary that comes out of GHC, is there any reason to do anything less sweeping than -s aka --strip-all?
16:36:52 <ski> AfC : could try asking in #ghc
16:37:36 <AfC> ski: fair enough. Cheers.
16:38:30 <AfC> Actually, this is a bad week to ask any Haskell related questions online, isn't it.
16:39:54 <pharaun> why?
16:40:08 <pharaun> and i haven't had any issue with strip-all here but *shrugs*
16:42:08 <luite> pharaun: everyone is at ICFP
16:42:58 <pharaun> ahh
16:47:12 <pxqr> is it possible to get {sub,super}script character for corresponding Unicode charater?
16:47:27 <pxqr> Data.Char do not offer such a function
16:47:37 <shachaf> Not in Data.Char.
16:47:55 <shachaf> The situation is complicated.
16:47:56 <pxqr> shachaf: where is then?
16:47:58 <shachaf> See https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts
16:53:15 <DigitalKiwi> preflex: seen glguy
16:53:15 <preflex>  glguy was last seen on #haskell-lens 5 days, 4 hours, 54 minutes and 44 seconds ago, saying: ah, good
17:07:09 <pxqr> shachaf: the situation is complicated indeed :(
17:09:12 <astropirate_> seen astropirate_
17:09:17 <astropirate_> preflex: seen astropirate_
17:09:18 <preflex>  astropirate_ was last seen on #haskell 5 seconds ago, saying: seen astropirate_
17:09:21 <astropirate_> preflex: seen astropirate
17:09:21 <preflex>  astropirate was last seen on #go-nuts 3 days, 4 hours, 48 minutes and 1 second ago, saying: it has served me rather well :\
17:09:36 <astropirate_> preflex: seen DigitalKiwi
17:09:36 <preflex>  DigitalKiwi was last seen on #haskell 16 minutes and 21 seconds ago, saying: preflex: seen glguy
17:20:01 <Rarrikins> Is there a way for Aeson to get Rationals in such a way that it turns 0.1 into 1 % 10?
17:52:57 <tel> Does anyone have experience writing SmallCheck instances which finish… at least slightly efficiently?
18:04:52 * hackagebot demarcate 0.1.0 - Demarcating transformed monad.  http://hackage.haskell.org/package/demarcate-0.1.0 (NickolayKudasov)
18:22:18 <ParahSail1n> Rarrikins, doesnt aeson use Read instances?
18:24:23 <haasn> Rarrikins: aeson's Number is pretty much Either Integer Double
18:24:36 <haasn> oh, but you could make your own FromJSON/ToJSON instances
18:24:41 <haasn> instead of relying on that one
18:25:20 <Rarrikins> I've looked into it a bit.
18:25:28 <Rarrikins> It uses attoparsec's Number type.
18:25:40 <Rarrikins> Before it gets to the FromJSON, I believe.
18:26:42 <Rarrikins> Though I don't know for sure about that last part.
18:27:13 <haasn> Yeah I just looked at it and saw that myself.. hmm
18:41:47 <wagle> in unboxed vector, what does "unboxed" mean?
18:42:49 <shachaf> Not boxed. Values stored directly in the vector, contiguously in memory, rather than pointers.
18:43:19 <dolio> wagle: data Int = I# Int#. An unboxed Vector Int stores just the Int# things directly.
18:43:54 <dolio> Which are machine integers.
18:45:15 <shachaf> Machintegers.
18:46:49 <dolio> That's why they're so fast.
18:51:14 <wagle> the examples arent very good for what i'm trying to do, which is to mutate an existing vector..
18:52:03 <wagle> i'm trying to implement lazy union find with O(1) operations
18:57:17 <dolio> shachaf: You should have come to ICFP. Free 128MB flash drive.
18:57:39 <dolio> And a t-shirt.
18:57:46 <elliott> wow, 128MB!
18:57:48 <shysoft> cabal install websockets fails for me due to compilation error in the 'cereal' dependency. galois has a github repo which references a fix for this for ghc 7.6.3, unfortunately cabal seems unaware of this fix. any advice?
18:57:54 <shachaf> That's as many as 1073741824 bits!
18:58:29 <elliott> that must have cost, like, whole cents.
18:58:59 <dolio> It has all the papers on it, looks like.
18:59:12 <MortyPinkman> 128 MB, preparing for the 21st century
18:59:47 <MortyPinkman> That phrase stopped being cool, right?
19:00:09 <shachaf> dolio: If you want better free flash drives, you'd better start publishing bigger papers.
19:00:18 <shachaf> Lots of pictures.
19:00:18 <dolio> Indeed.
19:00:47 <copumpkin> is it a special design of flash drive?
19:00:55 <copumpkin> shaped like a lambda, ideally
19:01:13 <dolio> It appears to have an LED in it, that lights up when it's plugged in.
19:01:20 <dolio> And it says ICFP'13 on it.
19:03:38 <hiptobecubic> Hey guys. What is pkg-config, why doesn't cabal or hayoo find it, and why is mine wrong? http://lpaste.net/93274
19:04:08 <arkeet> pkg-config isn't a haskell thing.
19:04:20 <arkeet> it's a program.
19:04:38 <arkeet> you need to install it. and probably the development packages for those libraries too.
19:05:08 <arkeet> C libraries.
19:07:52 <wagle> nominolo: do you have examples anywhere of something that uses your Data.UnionFind.IntMap?
19:10:04 <hiptobecubic> arkeet, ohhhhhh that. yes of course. don't mind me, screwing with haskell libraries for the last few hours has fried my brains
19:17:26 <wagle> if i have a set {1000, 20000}, can someone tell me how to use Data.UnionFind.IntMap to put the two in the same equivalence class?
19:20:52 <wagle> nevermind, found the example at the bottom of the source
19:58:17 <shysoft> I'm frustrated that having just installed the haskell platform on my mac, 3/3 libraries I've attempted to install via cabal install have all failed. There's nothing special or strange about my configuration, I can't believe none of this stuff has been tested or fixed.
19:58:50 <argiopeweb> shysoft: Running the newest Xcode?
19:58:59 <shysoft> yes
19:59:18 <argiopeweb> There's your problem.
19:59:29 <argiopeweb> Let me find you the writeup on it (I'm not a Mac user).
19:59:57 <monoidal> shysoft: https://groups.google.com/forum/#!msg/haskell-cafe/vbmq79VPEl0/RwloMXgaM40J
20:00:09 <argiopeweb> monoidal: Thanks.
20:00:13 <Makoryu> shysoft: Long story short, Apple changed some stuff and broke GHC
20:00:23 <argiopeweb> And it's fixed in 7.8.
20:01:03 <shysoft> okay, i'll downgrade my xcode, unfortunately I'll have to rewrite my c++ stuff to work around a clang++ bug. :/
20:01:49 <Makoryu> shysoft: The alternative is upgrading GHC, albeit to an unstable version
20:01:55 <argiopeweb> shysoft: Story of my life. I wouldn't wish C++ on my worst enemy due to the standards implementation issues.
20:02:17 <dolio> Won't be unstable for much longer.
20:02:42 <argiopeweb> dolio: Do we have an estimated time of arrival?
20:02:50 <wagle> if library has "newtype Point a = Point Int", how do I do a Show instance for it?
20:02:53 <dolio> This week?
20:03:00 <argiopeweb> Oh hell yes.
20:03:07 <monoidal> wagle: deriving instance Show (Point a)
20:03:18 <dolio> I don't remember the exact date, but ICFP was the target, and it's now ICFP.
20:03:23 <monoidal> wagle: or, message the maintainer and ask to add
20:03:25 <wagle> monoidal: i cant change the library source
20:03:35 <monoidal> wagle: write this line in your own code
20:03:54 <monoidal> wagle: you can also write just "instance Show (Point a) where show (Point x) = "Point " ++ show x
20:03:54 <argiopeweb> dolio: You've just made my week.
20:03:59 <monoidal> wagle: or something to that effect
20:04:24 <monoidal> wagle: this is called an orphan instance, which is generally not recommended, but you have no other choice
20:04:26 <wagle> monoidal: tried that, Point was undefined constructor
20:04:41 <wagle> leet me try harder
20:05:15 <monoidal> wagle: I'm afraid there won't be a way then. Maybe the library has some function getPoint :: Point a -> Int
20:07:09 <td123> dolio: http://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.8 says a release candidate should happen in october
20:10:23 <dolio> Hmm...
20:10:47 <dolio> Maybe ICFP was the merge deadline?
20:10:50 <dolio> That did happen.
20:10:55 <argiopeweb> Yeah, looking that way.
20:11:19 <dolio> Sorry to get your hopes up.
20:11:19 <argiopeweb> Hey, end of the week is 2 days from October, so it may make it.
20:11:49 <argiopeweb> And I can always break down and build the freeze to help with debugging.
20:35:17 <Mdx> Hi people, could someone give me a hint? it's a monad exercise ( http://lpaste.net/93277 )
20:36:41 <scshunt> Mdx: how do you get an a -> m b from a m (a -> b) ?
20:38:14 <monochrom> hint: banana is very important
20:40:18 <Mdx> scshunt: I'll try to answer that, brb
20:45:31 <augur> mmm banana
20:47:03 <Mdx> all that potassium is short circuiting my braaain
20:52:47 <AnalogFile_> I'd use a dirty trick: pretend it's a monad, write solution in do notation, manually desugar do notation, change return and  >>= into unicorn and banana.
20:53:15 <haasn> scshunt: flip!
20:53:25 <AnalogFile_> then cry because I solved the problem but still did not really learn monads
20:55:27 <Mdx> AnalogFile_: that would be a great start, if I did knew how to solve it with do
20:56:22 <AnalogFile_> Mdx: oh, yes. it does assume that you know how to use do notation and how to desugar it, of course.
20:57:13 <arkeet> I don't think this exercise teaches you anything about moands.
20:57:15 <AnalogFile_> but I understood do much before I understood monads (assuming I do understand monads, which I'm not 100% certain of).
20:57:15 <Mdx> AnalogFile_: well as far I saw that isn't tooo complicated, but still
20:57:15 <arkeet> or monads.
20:57:25 <arkeet> but it's not a bad exercise in using the types to guide you.
20:57:41 <dalaing> Mdx: how comfortable are you with using monads in Haskell code?
20:57:59 <Mdx> arkeet: yeah it's mostly for it,  I guess using monads would be better for that
20:58:37 <Mdx> dalaing: hee, I guess not much experience outside something in maybe,io and snap
20:59:08 <dalaing> Mdx: Week 8 and onwards of http://www.seas.upenn.edu/~cis194/lectures.html might help
20:59:27 <Mdx> dalaing: ty, i`ll have  a look!
21:03:51 <ReinH> Mdx: It will probably help to flip your banana
21:09:50 * ReinH cheats and writes instance Monad Misty
21:10:41 <joelteon> monad pokemon?
21:10:43 <joelteon> pokemonad?
21:11:00 <Mdx> ReinH: ehh, but writting explicitly what arguments goes to banana, wouldn't flip be desnecessary?
21:12:55 <ReinH> Mdx: it would make it much cleaner. Try to write this with =<< instead of >>=: lookup person people >>= \person' -> lookup person' addresses >>= \address' -> return address
21:14:21 <joelteon> isn't ">>= \a -> return a" the same as ""
21:15:01 <ReinH> joelteon: yes, but more nesting makes the difference clearer
21:15:28 <joelteon> oh
21:15:45 <ReinH> putting the anonymous lambdas on the lhs makes for pretty awkward nesting
21:17:08 <Mdx> god I feel overwhelmed, I guess i`ll read the lectures  dalaing sent to me before attempting anything
21:17:09 <ReinH> I would find it very confusing to write apple using =<<, let alone banana :)
21:17:38 <ReinH> Mdx: I recommend that you start here:
21:17:39 <ReinH> apple ma mf = let (>>==) = flip banana in
21:17:43 <joelteon> lookup person people >>= flip lookup addresses
21:17:55 <joelteon> lookup ?? addresses =<< lookup person people
21:17:57 <joelteon> neat
21:18:05 <ReinH> joelteon: yeah, ?? is nice :)
21:18:12 <joelteon> i love ??
21:18:25 <ReinH> I need to use it more
21:18:37 <dalaing> Mdx: I've been through those exercises before, there's only one or two concepts to get before the overwhelmingness goes away
21:18:59 <ReinH> I just think writing banana as flip (>>=) makes this unnecessarily difficult
21:19:00 <Mdx> dalaing: that's reassuring
21:19:47 <ReinH> as in, without flipping it back to >>= order I'm not sure I could write apple either
21:20:38 <dalaing> Mdx: how well do you understand monads, conceptually? and do you know how to write the Monad instance for Maybe?
21:22:15 <Mdx> dalaing: I  guess I don't understand monads conceptually at all. I get they are a `construct ` that must respect some laws
21:22:34 <haasn> They're an abstraction for a common pattern
21:22:37 <Mdx> dalaing:  I wrote instances for list, maybe, and a modified either
21:23:13 <Makoryu> Aw jeez, I painted myself into a corner here
21:23:17 <Mdx> and for ((->) t)
21:23:24 <Makoryu> Anyone good at lenses?
21:23:32 <haasn> m-maybe
21:23:34 <dalaing> Mdx: did you understand why they were how they were? my first pass through those exercises I kind of brute forced my way past the type system and kept on going
21:25:43 <Mdx> dalaing:  I don't think I got the question.
21:26:16 <dalaing> Mdx: when you wrote the Monad instance for Maybe, was it clear why the instance had to be the way you wrote it?
21:26:58 <dalaing> Mdx: the first time I tried those exercises I think I just kept doing things until the compiler was happy with me (ie I didn't really understand what was going on)
21:27:34 <Mdx> dalaing: hmm, I would say im closer to bruteforcing
21:28:18 <Mdx> dalaing:  writting instances for fmap was way clearer, monad kinda blurry
21:28:44 <dalaing> Mdx: (with some handwaving) monads are ASTs for various interpreters - they describe a "computation context"
21:29:13 <AnalogFile_> every day I learn something new about haskell. and every day I learn there's a new way to learn haskell !!
21:29:14 <dalaing> Mdx: for the Maybe monad, that context is just used for modelling failure (represented by Nothing)
21:29:38 <Mdx> dalaing: like something happening alongside normal function aplication, even sometimes interfering in the result? (like nothing in maybe monad)
21:29:47 <Mdx> dalaing:  ok
21:30:17 <dalaing> Mdx: we can build descriptions out of whatever we have lying around, but we can't pull the values of the description once we've made them
21:30:34 <Mdx> dalaing: hmmmmm
21:31:03 <dalaing> Mdx: in those notes I linked I think monads are explained like a recipe - you can take an apple and look at your pie crust recipe and put together an apple pie recipe, but you can't reach into a written-down recipe and pull out an apple
21:31:50 <dalaing> Mdx: so we have return, which takes a regular value and puts it into the description
21:32:01 <dalaing> Mdx: for Maybe, return x = Just x
21:32:14 <dalaing> Mdx: how are you doing so far?
21:32:37 <Mdx> dalaing: im following you
21:32:40 <dalaing> cool
21:33:21 <dalaing> Mdx: return isn't enough to build up larger descriptions, but we need a way to build them up so that we don't have apples falling out of our recipes, so to speak
21:33:39 <dalaing> that's where bind (>>=) comes in
21:33:58 <Mdx> what do you mean by falling out?
21:34:21 <dalaing> Mdx: you won't find anything with type m a -> a
21:34:38 <dalaing> Mdx: and you shouldn't be able to build anything that can do that with the monad machinery
21:35:38 <dalaing> given an apple, I can write down a recipe for apple slices (a -> m a), but I can't shake the recipe and have an apple drop out (m a -> a)
21:35:40 <Mdx> dalaing: wait, what makes that impossible? It would break some law?
21:36:23 <dalaing> Mdx: I don't think there's a way to do it using the functions in the monad typeclass
21:36:45 <dalaing> Mdx: for Maybe you can do it with various functions from Data.Maybe
21:36:48 <Mdx> dalaing: ohh I understand what you said ( was thinking of [a]-> a, like head )
21:37:15 <Mdx> dalaing:  it wouldn't be something common out of monads
21:37:53 <dalaing> still following?
21:38:01 <Mdx> yep
21:38:04 <dalaing> cool
21:38:26 <dalaing> so bind has type (a -> m b) -> m a -> mb
21:38:54 <dalaing> which would be straighforward if we had something to get the "a" from the "m a"
21:39:23 <dalaing> but we don't have that and we can't build it
21:39:55 <Mdx> yes
21:39:58 <haasn> Makoryu: what did you want to do with lenses?
21:40:09 <dalaing> Mdx: so we write it ourselves
21:40:26 <Makoryu> haasn: Replace something in a nested list by numeric indices
21:40:28 <dalaing> for Maybe, bind f Nothing = Nothing -- a failed computation fails
21:40:36 <haasn> Makoryu: example?
21:40:47 <dalaing> bind f (Just x) = f x -- a non-failed computation goes onto the next step
21:40:57 <Makoryu> haasn: Gimme a minute... I'll just show you how I ended up doing it
21:41:02 <Mdx> dalaing:  I must be explicit becauseI depend on the context, that's right?
21:41:17 <dalaing> Mdx: not sure I follow
21:41:40 <ellipsis> can anyone help me with Text.Regex.PCRE?
21:41:47 <ellipsis> I'm seeing what I think is some weird behavior
21:41:56 <ellipsis> so I don't think I'm understanding the =~ operator right
21:42:45 <dalaing> Mdx: actually, I think I get what you're asking, and yes
21:43:11 <dalaing> Mdx: bind is different for every monad, because they model different contexts
21:43:26 <Mdx> dalaing: ok, that's what I was trying to say
21:43:41 <ellipsis> If I do (largeString =~ "uin") I get back "a m"
21:43:53 <ellipsis> sorry, that was (largeString =~ "uin") :: String
21:45:45 <dalaing> Mdx: so, in the Maybe monad, what do we get for bind (\x -> return 2 * x) (return 3)
21:46:18 <Mdx> i guess 6?
21:46:31 <dalaing> an apple just fell out of your recipe
21:46:45 <Mdx> oh wait
21:47:08 <Mdx> should it be Just in place of return 2*x?
21:47:08 <Makoryu> haasn: https://github.com/malleusinferni/puck/blob/master/Main.hs#L44
21:47:14 <apples> i think (\x -> return $ 2 * x) is correct
21:47:28 <dalaing> apples: yeah, indeed
21:47:43 <Makoryu> haasn: I'm probably gonna refactor all this to use state and lens stuff... Just wanted to hack out a quick prototype to try out the concept
21:47:47 <AnalogFile_> in the maybe monad return is Just
21:47:51 <dalaing> Mdx: so bind (\x -> return (2 * x)) (return 3)
21:48:08 <dalaing> Mdx: remember that return x = Just x (ie return = Just)
21:48:09 <Mdx> ok
21:48:22 <Mdx> didn't though of the ()
21:48:39 <haasn> Makoryu: Editor?
21:48:54 <Makoryu> haasn: I'm not using any lenses yet, to be clear
21:48:58 <dalaing> with the infix bind (>>=) that's (return 3) >>= \x -> return (2 * x)
21:49:22 <Makoryu> haasn: "Editor" is a record holding the application state
21:49:27 <haasn> I can't find it :(
21:49:34 <haasn> pixels :: [[Int]] ?
21:49:38 <Makoryu> Yeah
21:50:14 <haasn> and you want to modify the pixel that's currently being pointed at by the cursor?
21:51:12 <Makoryu> haasn: Yep. Though that representation ([[Int]]) will probably go away, so don't worry about it
21:52:25 <haasn> > ["hello","world","foo","bar","bat"] & (traversed <.> traversed).index (1,3) %~ toUpper
21:52:26 <Mdx> dalaing:So does  \x -> return (2 * x) <<=  (return 3)   be the same function?
21:52:26 <lambdabot>   Couldn't match type `GHC.Types.Int'
21:52:26 <lambdabot>                with `p0 GHC.Types.Char ...
21:52:44 <haasn> huh, that works here
21:53:01 <Makoryu> @unlet
21:53:01 <lambdabot>  Define what?
21:53:07 <Makoryu> ¯\O_o/¯
21:53:10 <stephenmac7> I was wondering if anyone has any suggestions about getting started with haskell
21:53:10 <haasn> Makoryu: either way this looks somewhat like a use case for ‘tables’ to me :)
21:53:17 <dalaing> Mdx: I think so, you might need brackets around the lambda
21:53:24 <Mdx> dalaing:  ok
21:53:26 <haasn> Makoryu: that, or zippers
21:53:42 <dalaing> stephenmac7: I point everyone at this http://www.seas.upenn.edu/~cis194/lectures.html
21:53:45 <stephenmac7> Only think I have done so far is read part of LYAH
21:53:58 <dalaing> and the associated recommended reading (which includes parts of LYAH)
21:54:29 <dalaing> the course has some pretty nifty homework exercises as well
21:54:32 <Makoryu> haasn: Holy crap, how have I not heard of tables
21:54:34 <stephenmac7> dalaing: I see, and what do you suggest I do for practice?
21:54:47 <stephenmac7> Besides just the HW exercises
21:54:59 <stephenmac7> (Which look very helpful :D )
21:55:34 <dalaing> stephenmac7: they're a really good start, after that there's write yourself a scheme in 48 hours, then just hack on whatever you find interesting
21:55:51 <dalaing> Real World Haskell has some good info in it for when you want to go further
21:56:25 <dalaing> Mdx: so with (return 3) >>= (\x -> (return 2 * x)), what answer did you get
21:56:35 <leroux> stephenmac7: Here are some resources I found nice: https://gist.github.com/leroux/6395804
21:56:45 <Mdx> so that's Just 6
21:56:54 <dalaing> Mdx: and what do you get for Nothing >>= (\x -> return (2 * x))
21:56:59 <leroux> stephenmac7: There is a section for exercises/practice stuff.
21:57:02 <Mdx> that would be nothing
21:57:09 <stephenmac7> leroux: Ah, thanks
21:57:10 <dalaing> cool
21:57:16 <leroux> Hope it's helpful. =)
21:57:18 <stephenmac7> dalaing: The wikibook?
21:57:26 <stephenmac7> leroux: Looks like it will be :)
21:57:32 <stephenmac7> Too bad LYAH has no exercises
21:57:34 <haasn> Makoryu: for a zippersy solution, you could use zipper ["foo","bar","bat","baz"] & ifromWithin (traversed <.> traversed) -- and that will give you a Top :>> [String] :> (Char :@ (Int, Int)) -- or whatever the syntax on that is
21:57:48 <leroux> stephenmac7: There are third-party lyah exercises.
21:57:48 <haasn> Makoryu: basically a zipper cursored by an (Int, Int)
21:57:58 <leroux> https://github.com/noelmarkham/learn-you-a-haskell-exercises
21:57:59 <dalaing> Mdx: so Maybe is modelling computations that can fail, and failures stay failed
21:58:02 <Makoryu> haasn: I don't know how zippers work either :/
21:58:05 <haasn> Makoryu: so you can literally move around your focus, and use stuff like ‘view focus’ to retrieve the currently focused value :)
21:58:45 <Makoryu> That is pretty cool
21:58:45 <Mdx> dalaing: ok
21:58:46 <leroux> Makoryu: I like looking at basic Zippers as tapes. Which you can move the head over.
21:58:48 <dalaing> Mdx: and bind gives us temporary access to the value in the computation in order to describe further steps in the computation
21:58:59 <dalaing> Mdx: but it's typed in such a way that nothing "falls out"
21:59:02 <stephenmac7> leroux: I think that just has answers
21:59:11 <leroux> Hmm? No, check the branches.
21:59:29 <leroux> master has exercises, solutions has solutions.
21:59:33 <Makoryu> Anyway I'm not gonna work on this any more tonight
21:59:36 <Makoryu> Desperately need sleep
21:59:37 <haasn> Makoryu: http://hackage.haskell.org/packages/archive/lens/3.9.1/doc/html/Control-Lens-Zipper.html
21:59:47 <haasn> But keep in mind that zippers were moved into a separate package (that isn't on hackage yet)
21:59:55 <Makoryu> haasn: Thanks. It's going on my reading list...
22:00:09 <haasn> Oh, you could use a zipper *with* tables!
22:00:36 <leroux> stephenmac7: https://github.com/HaskVan/HaskellKoans is also cool.
22:00:39 <leroux> Just added it to the list.
22:00:46 <haasn> Makoryu: zipper (view table ...) & ifromWithin each
22:01:09 <haasn> Though I'm not sure how much sense that makes :)
22:01:20 <Mdx> dalaing: ok... I can see the importance of that context and bind in that interpretation, but can we have something as usefull for example in list?
22:01:46 <dalaing> Mdx: the context for list is non-deterministic choice
22:01:55 <dalaing> Mdx: rather than failure
22:02:02 <Makoryu> haasn: I basically have no idea what you wrote there... I'm very unfamiliar with lenses apart from the basic concept behind them, and totally unfamiliar with tables and zippers
22:02:11 <haasn> well you're in for a journey, then :)
22:02:19 <Mdx> dalaing:  hmmmmmmm
22:02:46 <stephenmac7> Thank you all. I've just had trouble getting through LYAH and though having exercises/projects might help
22:02:48 <Mdx> dalaing: now that's interesting
22:02:55 <haasn> Makoryu: ‘tables’ is a bit like an overloaded Map; lists with efficient querying (based on multiple indices and index types)
22:03:02 <stephenmac7> I've had to restart it a few time (even after getting to Ch 11)
22:03:06 <stephenmac7> *times
22:03:06 <dalaing> Mdx: so [1,2,3] >>= (\x -> return ([x - 1, x * 2]))
22:03:12 <haasn> Makoryu: and ‘zipper’ is like an overloaded zipper/tape; lets you ‘step into’ a traversal, move around inside it, etcv.
22:03:34 <Mdx> [0 2 1 4 2 6]
22:03:41 <Mdx> all possible outcomes
22:03:43 <haasn> > zipper ("Hello", "world") & rezip -- do we have them here?
22:03:44 <lambdabot>   Not in scope: `zipper'Not in scope: `rezip'
22:03:44 <lambdabot>  Perhaps you meant `recip' (imp...
22:03:46 <dalaing> and you can keep chaining them
22:03:46 <haasn> :(
22:03:53 <dalaing> Mdx: it looks better with do notation
22:03:59 <stephenmac7> dalaing: leroux: You think it'll help?
22:04:59 <Mdx> dalaing: I guess so :p
22:05:01 <dalaing> stephenmac7: exercises and projects helped me tremendously
22:05:33 <stephenmac7> It took me about 4 reads to understand function composition and I still don't understand fmap D:
22:05:49 <stephenmac7> dalaing: Which exercises and projects did you do?
22:05:50 <haasn> Makoryu: zipper ("Hello","world") & fromWithin both & tug rightward & fromWithin traverse & focus .~ 'W' & rightmost & focus .~ '!' & rezip  ==> ("Hello","Worl!")
22:05:58 <haasn> sorry for the huge example :P
22:09:32 <dalaing> stephenmac7: the ones in those notes, a good chunk of the NICTA course / Tony Morris's exercises, write yourself a scheme, played with most of the content in Real World Haskell, and then various side projects
22:10:21 <stephenmac7> dalaing: Okay, thanks. Hopefully that will be enough to get me programming in something other than python.
22:10:24 <dalaing> intro to functional programming with Haskell is also superb, but that's more for the mathsy side than the every day programming side
22:10:39 <stephenmac7> I'm not interested in the mathy side ;)
22:12:36 <dalaing> it has made a lot of other stuff much, much easier
22:12:52 <dalaing> Mdx: have you done much with lists and do notation
22:12:54 <dalaing> ?
22:12:58 <stephenmac7> Then maybe I might do it :)
22:13:19 <dalaing> stephenmac7: it's possibly for later on though, once you're hooked :)
22:13:33 <stephenmac7> I'm not hooked yet :)
22:13:54 <stephenmac7> Looks nice but I fail to see how haskell can become useful. I think write yourself a scheme might fix that.
22:14:28 <Mdx> dalaing: no, never tried
22:17:17 <dalaing> Mdx: made up example -> http://lpaste.net/93278
22:17:50 <dalaing> where "m a" is "[a]"
22:18:58 <stephenmac7> dalaing: Thanks
22:19:11 <stephenmac7> I think I'll try to finish LYAH, do exercises, and write myself a scheme in 48 hours
22:20:16 <dalaing> stephenmac7: I'd give that course a go as well, it references the relevant bits of LYAH/RWH/Typeclassopedia, the lectures are a few pages long, the homework is nice for digging in
22:20:26 <dalaing> but I've been spruiking that course ever since I stumbled onto it :)
22:20:41 <stephenmac7> dalaing: That too :)
22:20:51 <ReinH> make sure you actually try to write some Haskell
22:20:54 <ReinH> just reading isn't enough
22:20:56 <stephenmac7> Let me just save my irc history for this channel :D
22:21:03 <stephenmac7> ReinH: I think I figured that out the hard way.
22:21:24 <ReinH> pick some small but interesting problem and try to solve it with Haskell
22:21:27 <stephenmac7> Might as well have taken a course called "Learn Haskell the Hard way"
22:21:31 <dalaing> stephenmac7: ReinH is telling it like it is - write lots and lots of code
22:21:48 <stephenmac7> Biggest thing I've done in haskell is euler :P
22:21:55 <haasn> Where can I find the documentation for HaXml? The hackage description just links to http://www.cs.york.ac.uk/fp/HaXml/ which links to http://www.haskell.org/HaXml which is a 404 error
22:22:01 <dalaing> that was the first thing I tried :)
22:22:07 <ellipsis> Can someone give me some pointers as far as regexes go? I have a regex that works perfectly in Python
22:22:12 <ellipsis> but when I run it in Text.Regex.PCRE
22:22:16 <stephenmac7> It's very good for that. Lots of one-liners :D
22:22:18 <ellipsis> it doesn't work right
22:22:30 <ReinH> ellipsis: show us some code :)
22:22:32 <stephenmac7> Well, thanks dalaing and ReinH
22:22:33 <ellipsis> sure
22:22:35 <ellipsis> one second
22:22:53 <ReinH> stephenmac7: so you mentioned not understanding fmap?
22:23:10 <dalaing> stephenmac7: not a problem - if you have any questions / need any help, this is a pretty helpful channel
22:23:54 <Mdx> dalaing: I got to go now, sorry! Thank you for your time, I appreaciate your lesson!
22:24:13 <dalaing> Mdx: no worries, I hope it helped
22:24:23 <Mdx> dalaing: it helped for sure!
22:24:43 <ellipsis> http://lpaste.net/93281
22:24:43 <dalaing> Mdx: now write a Parser monad! :)
22:24:46 <ellipsis> same regex works in python
22:24:56 <ellipsis> I'm not posting the test data because it's ~4GB
22:25:33 <stephenmac7> ReinH: Yes
22:25:42 <ReinH> stephenmac7: do you understand map for lists?
22:25:45 <stephenmac7> Yes
22:25:45 <Mdx> dalaing: I'll do one as an exercise then! Thanks again, i`ll be looking at that website tomorrow.
22:25:49 <Mdx> cya #haskell
22:26:13 <ReinH> stephenmac7: do you know what a functor is (in Haskell terms)?
22:26:35 <stephenmac7> Kind of
22:26:41 <stephenmac7> I know fmap can be used on it :P
22:26:50 <ReinH> that's exactly what a functor is :)
22:27:04 <ReinH> a functor is a thing that can be fmapped
22:27:07 <ReinH> :t fmap
22:27:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:27:11 <ReinH> :t map
22:27:11 <lambdabot> (a -> b) -> [a] -> [b]
22:27:26 <ellipsis> but it matches stuff like "authority]] o"
22:27:31 <ellipsis> when it really shouldn'
22:27:32 <ellipsis> t
22:27:58 <ReinH> aaaand that's why I hate regexp
22:28:06 <ellipsis> yeah it's kind of a mess
22:28:16 <ellipsis> but I don't want to use a full-blown WikiText parser
22:28:20 <stephenmac7> ReinH: So maybe is a functor?
22:28:29 <joelteon> i mean, regexp are good for what they're designed for
22:28:32 <stephenmac7> Prelude> fmap (+3) $ Just 4
22:28:33 <stephenmac7> Just 7
22:28:47 <ReinH> stephenmac7: let's try a simpler one
22:28:56 <ReinH> > fmap (+3) (Identity 3)
22:28:58 <ellipsis> anyway, same regex in Python works fine and matches exactly what I want it to
22:28:59 <lambdabot>   Identity {runIdentity = 6}
22:29:24 <stephenmac7> What is identity?
22:29:39 <Makoryu> stephenmac7: It's like Maybe, except without Nothing
22:29:45 <stephenmac7> Ah
22:29:47 <ReinH> newtype Identity a = Identity { runIdentity a }
22:29:55 <ReinH> it's a type that contains exaclty one value
22:30:08 <ReinH> can you write: fmap f (Identity a) = ???
22:30:33 <stephenmac7> I see. I think another problem is that I never understood type classes/constructors very well
22:30:40 <ReinH> :t Identity
22:30:41 <lambdabot> a -> Identity a
22:30:53 <ReinH> Identity is a function that returns a value of type Identity
22:30:57 <ReinH> so it's a type constructor
22:31:26 <stephenmac7> Which one?
22:31:31 <stephenmac7> They're both called Identity
22:31:45 <Makoryu> Yeah, that's kinda confusing
22:31:48 <ReinH> stephenmac7: we are talking about two different levels here
22:31:51 <joelteon> there's the Identity type and the Identity function
22:32:00 <stephenmac7> Then there's type parameters, making things even worse
22:32:19 <stephenmac7> Identity is a class, type, and function??
22:32:29 <Makoryu> Identity isn't a typeclass, no
22:32:46 <haasn> it can also be a promoted type and kind!
22:32:50 <ReinH> stephenmac7: Identity is not a typeclass, but it is both a type and a function that constructs values of that type
22:32:54 <haasn> the same name can mean up to five things
22:32:57 <ReinH> stephenmac7: let's write a different version:
22:33:01 <Makoryu> All right, so there are two namespaces: One for type stuff, and one for value stuff (including functions)
22:33:04 <stephenmac7> So, it's a constructor
22:33:11 <ReinH> data MyIdentity a = ConstructIdentity a
22:33:21 <Makoryu> Constructors are in the value namespace
22:33:24 <ReinH> ConstructIdentity is a function that returns a value of type MyuIdentity
22:33:28 <haasn> ReinH: that isn't what ‘type constructor’ usually means, is it?
22:33:31 <haasn> that's just a regular constructor
22:33:36 <ReinH> haasn: I guess I mean data constructor?
22:33:38 <haasn> yeah
22:33:43 <joelteon> yeah, Maybe is a type constructor
22:33:47 <ReinH> yeah
22:33:54 <joelteon> yeah
22:33:54 <stephenmac7> So, MyIdentity is the type, but ConstrucIdentity is not
22:33:56 <ReinH> this isn't less confusing for experienced haskellers :p
22:34:13 <haasn> stephenmac7: correct
22:34:23 <ReinH> stephenmac7: yes
22:34:55 <stephenmac7> ReinH: So, in maybe: data Maybe a = Just a | Nothing
22:35:01 <ReinH> stephenmac7: right
22:35:05 <stephenmac7> Just is a constructor and nothing is a constructor
22:35:08 <phao> Hi... as a curiosity... why do people sometimes say a person to learn haskell needs to have a phd?
22:35:11 <ReinH> stephenmac7: right
22:35:11 <stephenmac7> but Maybe is the data type
22:35:15 <ReinH> right
22:35:21 <phao> I've heard that about monads too
22:35:22 <zomg> phao: probably as a joke =)
22:35:37 <stephenmac7> So, what makes a value produced by Just difference from one by Nothing?
22:35:41 <phao> I am sure it wasn't a joke when I heard it
22:35:41 <stephenmac7> *different
22:35:41 <ReinH> stephenmac7: right
22:35:46 * haasn wishes he had a phd!
22:35:51 <phao> it wasn't serious though.
22:36:02 <stephenmac7> ReinH: It was a question, not a statement... :)
22:36:11 <spring> a question language flag...
22:36:17 <haasn> stephenmac7: that they're different values..?
22:36:21 <ellipsis> phao: pretty sure that's not true, since I'm learning and I haven't started college :P
22:36:25 <spring> Suppose I have let x = [[]]
22:36:36 <spring> head x :: [a]
22:36:36 <Makoryu> phao: Sometimes people say that to exaggerate the number of new concepts you have to learn, as opposed to the ones you can carry over from other languages if you stick to the C family
22:36:41 <haasn> stephenmac7: sums are distinct; eg. data Bool = False | True -- two distinct constructors
22:36:44 <spring> tail x :: [[a]]
22:37:02 <haasn> stephenmac7: data Foo a = X a | Y a -- X 3 and Y 3 are distinct
22:37:13 <spring> Now head x == tail x gives me True
22:37:18 <stephenmac7> I see.
22:37:22 <spring> Earlier we used to get type error
22:37:46 <stephenmac7> Thinks make a little more sense now :)
22:37:47 <haasn> spring: ah, polymorphism
22:37:57 <haasn> :t \x -> head x == tail x
22:37:57 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
22:37:58 <lambdabot>     Expected type: [a0]
22:37:58 <lambdabot>       Actual type: [[a0]]
22:38:10 <ReinH> stephenmac7: so back to fmap? :)
22:38:11 <haasn> :t let x = undefined in head x == tail x
22:38:12 <lambdabot> Bool
22:38:17 <stephenmac7> ReinH: Yes
22:38:34 <ReinH> stephenmac7: so fmap f (Identity a) = ???
22:38:35 <joelteon> :t head ?x == tail ?x
22:38:36 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
22:38:36 <lambdabot>     When using functional dependencies to combine
22:38:36 <lambdabot>       ?x::[[a0]],
22:38:38 <haasn> spring: your ‘a’ in ‘head x :: [a]’ gets instantiated to [b] (of (tail x :: [[b]]’
22:38:42 <ReinH> stephenmac7: when you see the type:
22:38:44 <ReinH> :t fmap
22:38:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:38:49 <ReinH> you can infer a few things
22:39:05 <spring> Yes so my question is what is the language flag that when (un)set gives the type error?
22:39:12 <stephenmac7> It's a function which takes a function and a functor
22:39:26 <haasn> spring: there is no language flag for this
22:39:32 <stephenmac7> Then it returns the another functor of the same type
22:39:37 <phao> ellipsis, you're learning haskell on your own just for fun?
22:39:45 <haasn> (but you can probably make that function type check by using RankNTypes and providing a signature manually.. though you also need ImpredicativeTypes I think)
22:39:46 <ellipsis> phao: yep
22:39:55 <ellipsis> I already know a bunch of other languages
22:40:09 <ellipsis> so I'm learning Haskell in order to force myself to think more functionally
22:40:09 <haasn> :t (\x -> head x == tail x) :: (forall a. [[a]]) -> bool
22:40:10 <lambdabot>     Couldn't match expected type `bool1' with actual type `Bool'
22:40:10 <lambdabot>       `bool1' is a rigid type variable bound by
22:40:10 <lambdabot>               an expression type signature: (forall a. [[a]]) -> bool1
22:40:11 <haasn> :t (\x -> head x == tail x) :: (forall a. [[a]]) -> Bool
22:40:12 <lambdabot> (forall a. [[a]]) -> Bool
22:40:12 <AnalogFile_> phao: a few hours ago I was reading something that may actually explain why they say you need a PHD to learn haskell
22:40:25 <phao> AnalogFile_, what was that?
22:40:32 <AnalogFile_> phao: http://lpaste.net/93282
22:40:52 <arkeet> ((\x -> head x == tail x) :: (forall a. [[a]]) -> Bool) [[]]
22:40:57 <arkeet> > ((\x -> head x == tail x) :: (forall a. [[a]]) -> Bool) [[]]
22:40:58 <lambdabot>   True
22:40:59 <arkeet> > ((\x -> head x == tail x) :: (forall a. [[a]]) -> Bool) [[],[]]
22:41:00 <lambdabot>   False
22:41:01 <haasn> stephenmac7: it doesn't ‘return a functor’, the type Identity is a functor but the values ‘Identity’ or ‘Identity 3’ are not
22:41:01 <ReinH> stephenmac7: because of the types, you can infer that the functor has to be the same but the value can change type
22:41:24 <stephenmac7> haasn: Ah, I see.
22:41:29 <ReinH> so fmap can't go from Identity 3 to Just 5, for isntance
22:41:35 <haasn> stephenmac7: just some terminology to keep in mind :)
22:41:35 <ReinH> but it can go from Identity 3 to Identity "foobar"
22:41:40 <stephenmac7> Identity 3 is a value of a type which is a functor
22:41:46 <ReinH> stephenmac7: yes
22:41:46 <haasn> phao: I'm learning Haskell on my own just for fun!
22:41:54 <AnalogFile_> phao: that's just a little piece. the full story is http://www.haskell.org/haskellwiki/Catamorphisms
22:42:01 <zRecursive> just for fun too :)
22:42:08 <ReinH> stephenmac7: so right away we can tell that whatever fmap does, the type of the functor must stay the same
22:42:11 <haasn> AnalogFile_: you don't need a phd to learn what catamorphisms are!
22:42:22 <phao> I imagine most people learning haskell are doing just for fun, or curiosity.
22:42:24 <AnalogFile_> but of course you do not really need to understand that to learn haskell
22:42:38 <haasn> phao: It is a very fun language :)
22:43:04 <haasn> a phd might come in handy reading some of edwardk's documentation, though
22:43:05 <ReinH> stephenmac7: let's talk about data constructors and pattern matching for a second
22:43:17 <zRecursive> i amnot dare to use haskell for real application as it is hard to control its running ...
22:43:22 <ellipsis> hassn: Couldn't agree more. at this point when I code in C++ I miss monads
22:43:30 <haasn> (of course, a phd is a meaningless document - what matters in the end is knowledge, and you don't need a phd to acquire knowledge)
22:43:42 <haasn> ellipsis: pft, implement monads in C++ then :)
22:43:56 <stephenmac7> ReinH: Wait, so if I have data T a = R a | L a
22:44:02 <haasn> http://hub.darcs.net/nand/csharp/browse/PureIO/PureIO.cs#66 -- make your own reality
22:44:02 <AnalogFile_> hassn: no, sure. in fact catas I do know. But imagine some highscool student that stumbles upon that kind of text
22:44:10 <ReinH> stephenmac7: kk
22:44:29 <stephenmac7> Applying fmap to something constructed with R can never return an L value?
22:44:34 <haasn> AnalogFile_: It all depends on context. Until very recently I was a highschool student myself
22:44:38 <ellipsis> haasn: could, but the template arcana required would make it worse than not using them at all IMO
22:44:50 <Obfuscate> haasn: Meaningless documents are nonetheless very useful for finding employment. ;)
22:44:53 <zRecursive> there is `data` why do we need `newtype` ?
22:44:57 <haasn> ellipsis: yeah, true. I don't actually use C# nonsense like what I pasted
22:45:03 <ReinH> stephenmac7: no, because the functor is the type T
22:45:10 <haasn> zRecursive: we don't technically, but there are minor semantic differences and it has to do with efficiency as well
22:45:13 <ellipsis> haasn: not to mention the template vomit if I get something wrong :P
22:45:19 <Makoryu> zRecursive: It's a way to force the compiler to make certain optimizations
22:45:20 <ReinH> so R 1 and L 1 are both values of type T Int
22:45:20 <haasn> zRecursive: you can pattern match on a ‘newtype’ constructor for ‘free’
22:45:32 <haasn> > case undefined of Identity _ -> ()
22:45:33 <lambdabot>   ()
22:45:43 <stephenmac7> But can the input be R "test" and output R 5
22:45:47 <haasn> -- if Identity were a ‘data’ type and not a ‘newtype’, this would throw an exception
22:46:03 <haasn> zRecursive: the end result is that newtypes have no runtime overhead
22:46:11 <ReinH> stephenmac7: yes
22:46:26 <stephenmac7> Even if it's T int then T [Char] ?
22:46:33 <haasn> ellipsis: I just like hacking things like monads into languages not designed to hold them, for fun :P
22:46:33 <AnalogFile_> hassn: and you understand stuff like "we can trivially transform an Algebra into an F-W-Algebra by mapping the counit of the comonad over F" without a blink? Chapeau!
22:46:44 <ReinH> stephenmac7: I think I misunderstood
22:46:48 <zRecursive> ReinH: in `case undefined of Identity _ -> ()`, Identiry canot be a data constructor ?
22:46:53 <ReinH> stephenmac7: fmap can't change an R 1 to an L 1 because fmap id = id
22:47:31 <dalaing> AnalogFile_: I'm a few books away from being able to understand it without a blink, but I  have a good idea which books they are
22:47:38 <haasn> AnalogFile_: I'd need a bit to think about counits and comonads to really understand it, but I'm familiar with most of that terminology by now due to #haskell osmosis. It's just a matter of time. (Ps. my name is haasn not hassn, if you spell it correctly I will be able to see your messages better :)
22:47:59 <dalaing> AnalogFile_: (and I'm a few books into my journey)
22:48:46 <AnalogFile_> haasn: sorry! Just typing in webchat.freenode.net and it's 7am and did not sleep
22:48:55 <stephenmac7> ReinH: I think I'll just reread the section on functors
22:49:48 <haasn> AnalogFile_: either way, I'm familiar with generalized catamorphisms, anamorphisms, hylomorphisms etc. due to previous exposure to edwardk
22:49:50 <ReinH> stephenmac7: ok, there's just one thing I wanted to mention :)
22:50:01 <stephenmac7> ReinH: Thanks, but it's really late an I have to go. However, mentions your thing :)
22:50:03 <zRecursive> :t undefined
22:50:03 <lambdabot> a
22:50:04 <stephenmac7> *mention
22:50:12 <AnalogFile_> haasn: agreed that learning haskell will teach you math. in fact maybe you do not need a phd to learn haskell, but once you REALLY learned haskell you are a long way into your work to get a phd :P
22:50:57 <zRecursive> "category theory"" is relative to math ?
22:51:07 <haasn> AnalogFile_: it's a bit of a shame, though. I will never be able to enjoy the Java they'll probably force me to go through during my first few semesters. :( I don't look forward to it!
22:51:16 <dalaing> stephenmac7: fmap (2*) <some list / tree / maybe> -- double every value in the list / tree / maybe of Integers
22:51:24 <haasn> zRecursive: category theory is a branch of mathematics, yes
22:51:32 <AnalogFile_> haasn: it's one of my intuitions: maybe instead learning math to understand haskell, one should learn haskell to understand math :P
22:51:34 <ReinH> stephenmac7: for fmap f (Identity a), consider f (Identity a) = a gives you the a "inside" the Identity, and Identity b gives you an Identity of value b
22:51:38 <zRecursive> haasn: thx
22:51:54 <dalaing> haasn: the tooling and ecosystem around Java is kind of nice relative to some other things they could teach you
22:51:55 <ReinH> stephenmac7: the only thing left to do is to convert the a into the b, and there's only one way to do that if you're given fmap f (Identity a)
22:52:00 <zRecursive> :t Intentity
22:52:00 <stephenmac7> dalaing: I got that part
22:52:01 <lambdabot>     Not in scope: data constructor `Intentity'
22:52:01 <lambdabot>     Perhaps you meant `Identity' (imported from Control.Monad.Identity)
22:52:06 <zRecursive> :t Identity
22:52:07 <lambdabot> a -> Identity a
22:52:23 <haasn> dalaing: I guess so, but I don't even have my C# tricks like Func<>/Linq. :(
22:52:35 <stephenmac7> ReinH: in the function you're giving, right
22:52:37 <stephenmac7> ?
22:52:48 <ReinH> stephenmac7: given that fmap f (Identity a) = ??? gives you access to a, f, and the Identity function
22:53:01 <Makoryu> :k Identity
22:53:02 <lambdabot> * -> *
22:53:02 <ReinH> stephenmac7: what's your first guess for how to write fmap?
22:53:04 <AnalogFile_> haasn: you are going to hate Java. I did. I refused to learn it.
22:53:26 <stephenmac7> ReinH: Doesn't it depend on what you're writing fmap for?
22:53:35 <haasn> AnalogFile_: yes, I've certainly learned a lot about mathematics via Haskell; including lots of category theory. I like to use Hask as my ‘working model/intuition’ to understand CT concepts. Of course, it doesn't get me very far, but it generally gets me far enough to understand their relevance to Haskell, which is all I really care about CT for
22:53:36 <ReinH> stephenmac7: we're writing the fmap isntance for Identity a
22:53:40 <ReinH> *instance
22:53:44 <ReinH> :t fmap
22:53:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:53:56 <stephenmac7> :t map
22:53:57 <lambdabot> (a -> b) -> [a] -> [b]
22:53:58 <ReinH> stephenmac7: remember that f takes an a and gives a b, and the functor here is Identity
22:54:21 <haasn> AnalogFile_: The only language I vehemently refuse to learn is C. :(
22:54:40 <stephenmac7> fmap :: (a -> b) -> Identity a -> Identity b
22:54:44 <Excedrin> haasn: you'd rather learn Intercal than C?
22:54:56 <ReinH> stephenmac7: exactly
22:55:04 <stephenmac7> Now for the actual definition :P
22:55:27 <haasn> Excedrin: Esoteric languages can be fun. (But either way, it's not like anybody would force me to learn Intercal)
22:55:30 <AnalogFile_> haasn: maybe someday we'll have a math (or even CT) book that explains stuff saying something like: this works very much like in haskell :P
22:55:45 <ReinH> stephenmac7: so how do you go from a value of type a to a value of type b?
22:55:46 <Kaidelong> when I first learned java I really loved it because it had compile-time checked exceptions
22:55:49 <Makoryu> AnalogFile_: I've considered doing that with a J tutorial...
22:55:53 <Kaidelong> but they got rid of that
22:56:03 <Makoryu> Kaidelong: They did what
22:56:05 <haasn> AnalogFile_: http://www.haskell.org/haskellwiki/Category_theory does some of that iirc
22:56:29 <Kaidelong> your program would not compile if you didn't handle all declared exceptions
22:56:36 <Kaidelong> nice way to keep discipline
22:56:44 <Kaidelong> but people just wrote empty handlers for Exception
22:56:46 <AnalogFile_> haasn: main difference: C may be useful to do stuff, Java may land you a job.
22:56:49 <Excedrin> The Haskell Road to Logic, Maths and Programming
22:56:52 <Kaidelong> that did nothing except throw
22:56:55 <Excedrin> no?
22:56:59 <stephenmac7> ReinH: Still thinking
22:57:15 <Makoryu> Kaidelong: Yeah. The standard library really abused exceptions as a form of control flow, and it went downhill from there
22:57:16 <Kaidelong> I've been searching for jobs, not much for java out there
22:57:19 <ReinH> stephenmac7: what does f do?
22:57:38 <stephenmac7> f is the function
22:57:38 <phao> AnalogFile_, besides, one is much more likely to do useful stuff in java than in C.
22:57:53 <phao> do more frequently*
22:57:58 <haasn> AnalogFile_: Yeah. I haven't really thought about getting a job or anything like that, I've only ever programmed for fun. I'd like to have a job programming Haskell, though. Maybe I'll find a position that gives me a bit of leeway as to what language I use? Who knows.. it's a bit too far into the future for me to really worry about right now
22:58:15 <haasn> AnalogFile_: ah, but for the JVM, I know there are a lot of interesting languages that run on it (apart from Java), eg. Scala, Frege or Ermine
22:58:15 <AnalogFile_> Makoryu: ohh, J! I did never learn it. But I know it's a descendant of APL. The lovely write only language :)
22:58:17 <Kaidelong> Makoryu: Did it? Java exceptions are not designed for that. Not that it would be bad if they did, Icon essentially does a lovely job with that sort of thing and MonadPlus is essentially like that
22:58:28 <ReinH> stephenmac7: if the type of f is f :: a -> b, what does f do?
22:58:38 <haasn> AnalogFile_: J is APL but with more ASCII spam. So in other words, ideal for lens programmers
22:58:56 <Kaidelong> but my understanding was that java exceptions just perform so horribly that nobody should use them for control flow
22:59:00 <stephenmac7> It takes a type a and returns a type b
22:59:01 <Makoryu> Kaidelong: Once it occurs to you that "exceptions as control flow" are a code smell, it's a lot easier to see the (many) places in the Java API where that's exactly what's happening
22:59:11 <ReinH> Kaidelong: no one should use exceptions for flow control full stop.
22:59:15 <Makoryu> Kaidelong: Nope, it's a semantic thing mostly
22:59:41 <Excedrin> ReinH: but they don't have call/cc!
22:59:46 <Makoryu> haasn: J is exactly what your explanations of lens stuff reminded me of... I'll get the hang of it though ;)
22:59:58 <Kaidelong> ReinH: which exceptions?
23:00:08 <AnalogFile_> haasn: actually the JVM is written in C. You'll have a very hard time to write a JVM in Java and then a compile-to-bytecode program for it, also in Java.
23:00:11 <ReinH> Kaidelong: all exceptions
23:00:17 <Makoryu> AnalogFile_: Basically, J makes Perl look as tidy as a Puritan
23:00:18 <Kaidelong> there are lightweight exceptions in some languages intended just for that purpose
23:00:25 <ReinH> Kaidelong: no, there aren't
23:00:31 <ReinH> exceptions are not a flow control mechanism
23:00:38 <Kaidelong> they're a jump
23:00:38 <ReinH> even if they're light weight
23:00:48 <stephenmac7> ReinH: fmap f (Identity a) = Identity $ f a
23:00:49 <haasn> AnalogFile_: what about writing a JVM in Haskell? This needs to be done! :)
23:00:53 <ReinH> Kaidelong: so is goto, but they are semantically different from goto
23:00:55 <AnalogFile_> Makoryu: but it takes the keyboard fun out of APL!!
23:00:58 <ReinH> stephenmac7: yep!
23:01:11 <Kaidelong> then you must be using a narrowly, technically defined definition of exception
23:01:12 <Excedrin> AnalogFile_: http://www.igormaznitsa.com/projects/mjvm/index.html
23:01:20 <stephenmac7> My issue was that I was trying to curry it
23:01:26 <AnalogFile_> haasn: that's doable, I guess. After all Haskell is compiled!
23:01:32 <stephenmac7> fmap = Identity
23:01:34 <stephenmac7> :P
23:01:39 <ReinH> Kaidelong: I am using the standard definition of exception
23:01:44 <haasn> “there exist Haskell implementations which produce native code for some platform”
23:01:49 <ReinH> exceptions are for *exceptional* cases
23:01:50 <haasn> </pedantry>
23:02:00 <ReinH> that's what they mean everywhere
23:02:02 <stephenmac7> ReinH: Well, thanks
23:02:05 <ReinH> stephenmac7: np
23:02:10 <stephenmac7> I'll be back soon
23:02:16 <ReinH> stephenmac7: now think about how to write fmap f [a]
23:02:18 <stephenmac7> It's 2 AM here
23:02:25 <ReinH> stephenmac7: (you have to apply f to every a)
23:02:41 <stephenmac7> The cheap way would be to use map :P
23:02:51 <ReinH> stephenmac7: but without doing that :p
23:03:07 <stephenmac7> I'm guessing a fold
23:03:14 <ReinH> yes, or with straight up recursion
23:03:14 <haasn> ‘exceptions for control flow’ sound a bit like Nothing/Either
23:03:31 <Kaidelong> which is an example of MonadPlus
23:03:43 <AnalogFile_> Excedrin: the problem is that it's not compilable to native code by a java program. And if it was, it would be far from being as efficient as a C JVM. Java can be more efficient than C for some things, but not for this, I'm affraid.
23:04:37 <Excedrin> AnalogFile_: no reason why not, only nobody's done it because it's kinda pointless
23:05:00 <Kaidelong> exceptional cases is quite a vague thing anyway, when does a case become exceptional?
23:05:08 <haasn> stephenmac7: fmap f = Identity . f . runIdentity -- :)
23:05:13 <Kaidelong> If it should never occur in normal excution of a program?
23:05:25 <haasn> @pl fmap f = Identity . f . runIdentity
23:05:28 <lambdabot> fmap = id (fix (const ((Identity .) . (. runIdentity))))
23:05:28 <lambdabot> optimization suspended, use @pl-resume to continue.
23:05:31 <haasn> yuck!
23:05:44 <stephenmac7> ReinH: fmap f = foldl (\acc x -> f x : acc) []
23:05:51 <stephenmac7> What on earth is runidentity?
23:05:52 <elliott> haasn: fmap = over _Identity
23:06:03 <stephenmac7> But I'm done for noe
23:06:04 <stephenmac7> *now
23:06:05 <Kaidelong> runIdentity :: Identity a -> a
23:06:15 <haasn> elliott: over wrapped
23:06:17 <Kaidelong> @src runIdentity
23:06:17 <lambdabot> Source not found. Are you on drugs?
23:06:19 <stephenmac7> > runIdentity 5
23:06:20 <lambdabot>   No instance for (GHC.Show.Show a0)
23:06:20 <lambdabot>    arising from a use of `M1869108636.sh...
23:06:30 <ReinH> stephenmac7: almost, but foldl isn't lazy enough
23:06:33 <ReinH> consider:
23:06:39 <haasn> @src Identity
23:06:39 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
23:06:41 <ReinH> take 10 $ fmap (+1) [1..]
23:06:42 <haasn> stephenmac7: ^
23:06:44 <haasn> it's the field name
23:06:46 <ReinH> > take 10 $ fmap (+1) [1..]
23:06:47 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
23:06:54 <Kaidelong> grrr haskell records
23:06:55 <ReinH> take 10 $ foldl (:) [] [1..]
23:06:57 <ReinH> > take 10 $ foldl (:) [] [1..]
23:06:58 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
23:06:58 <lambdabot>  Expected type:...
23:07:00 <ReinH> > take 10 $ foldr (:) [] [1..]
23:07:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:07:07 <stephenmac7> ReinH: Ah
23:07:10 <stephenmac7> foldr
23:07:13 <AnalogFile_> Excedrin: it's only pointless because C exists everywhere. Anyone that want to defend the position that C is not the most useful, basic language needs to be able to avoid C alltogether
23:07:14 <Kaidelong> well that's a newtype
23:07:16 <Kaidelong> but same syntax
23:08:26 <zRecursive> Can concurrent and lazy coexist ?
23:08:50 <ReinH> stephenmac7: still not quite right...
23:09:04 <ReinH> > let fmap' f xs = foldr (\acc x -> f x : acc) [] xs in take 10 $ fmap' (+1) [1..]
23:09:05 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
23:09:05 <lambdabot>  Expected type:...
23:09:54 <stephenmac7> ReinH: Mleh. I'm just going to use regular recursion
23:09:59 <ReinH> stephenmac7: ok :)
23:10:04 <stephenmac7> fmap _ [] = []
23:10:15 <ReinH> ok
23:10:25 <stephenmac7> fmap f (x:xs) = f x : fmap f xs
23:10:29 <haasn> correct
23:10:32 <ReinH> yep
23:10:38 <ReinH> stephenmac7: the fold version:
23:10:44 <Kaidelong> zRecursive: yes, ACM communications had an article on data structures built to enable that sort of thing
23:10:44 <ReinH> > let fmap' f xs = foldr ((:) . f) [] xs in take 10 $ fmap' (+1) [1..]
23:10:47 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
23:10:58 <Kaidelong> but just think of it as a server-client model
23:11:07 <Excedrin> AnalogFile_: I think that a lot of people can avoid C
23:11:08 <zRecursive> Kaidelong: any URL ?
23:11:15 <stephenmac7> ReinH: I really need to go though
23:11:22 <stephenmac7> Thank you
23:11:23 <AnalogFile_> zRecursive: sure. you can do concurrency in haskell. here is a starter http://www.haskell.org/haskellwiki/Concurrency
23:11:32 <ReinH> stephenmac7: np
23:11:39 <stephenmac7> Good bye
23:11:43 <haasn> zRecursive: http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:11:49 <zRecursive> thx
23:11:57 <haasn> I highly recommend reading that book, to anybody :)
23:12:08 <ReinH> it's pretty great
23:12:19 <zRecursive> i will
23:12:30 <ReinH> haasn: although I wish he had written it after someone invents a nice concurrent task-sharing monad
23:12:40 <AnalogFile_> Excedrin: I do not mean avoid programming in C in your job. I mean being able to port a language to a new platform without using a C compiler (or cross compiler) for that platform
23:12:54 <Kaidelong> ReinH: What about Orc?
23:13:10 <Kaidelong> I thought it was pretty nice
23:13:17 <Excedrin> well ya, there's llvm right?
23:13:33 <ReinH> Kaidelong: I'm thinking something with Cilk++ or Intel TBB semantics
23:14:00 <ReinH> Kaidelong: i.e. each worker provides a task-stealing deque that other workers can steal from
23:14:36 <Kaidelong> shouldn't that be implementation detail rather than something exposed in the API?
23:14:55 <ReinH> Kaidelong: that's why it's a monad :)
23:15:00 <ReinH> the modad hides the implementation
23:15:02 <AnalogFile_> Excedrin: sure. that's a starter. if you can extend llvm to support a new platform without using C. which I'm not sure you can.
23:15:28 <Kaidelong> so you want something like Orc or asynchronous workflows with that specific implementation then
23:15:30 <alpounet> ReinH, that's pretty close to what you have when running the multicore RTS
23:15:46 <alpounet> except that you don't have access to it
23:15:57 <ReinH> alpounet: kind of, but sparks are expensive
23:16:25 <ReinH> you can't effectively parallelize thousands of operations by naively generating sparks
23:16:26 <alpounet> yeah
23:16:32 <ReinH> but you can throw them in a work stealing group
23:16:44 <Kaidelong> there was another neat parallelization EDSL library called Accelerate
23:17:03 <Kaidelong> although it generated CUDA so you needed a graphics card with support for it
23:17:15 <ReinH> so you have n = number of cores workers, you split the tasks into n worker + steque threads, and each thread can steal from any other worker at need
23:17:59 <ReinH> alpounet: I'm going to try to use Edward's new steque implementation to update https://github.com/ekmett/tasks
23:18:17 <kryft> So if I want to do some performance-sensitive linear algebra, should I look into hmatrix and the ST monad?
23:18:26 <ReinH> and then hopefully add more of the TBB interface
23:19:01 <ReinH> kryft: you should probably start with the vector and linear packages
23:19:26 <kryft> (Performance-sensitive in the sense that I care about the speed, but not in the sense that it absolutely must be as fast as possible no matter the cost)
23:19:57 <kryft> ReinH: Oh, I hadn't even heard about linear
23:20:29 <zRecursive> The linking time of GHC-7.6.x is a pain on my freebsd box :(
23:20:48 <ReinH> kryft: although hmatrix does provide a lot of useful tools out of the box
23:21:25 <ReinH> and plays nicely with Vector
23:21:42 <frxx> is it recommended practice to reach String or Data.Text by default?
23:21:51 <kryft> ReinH: So what does linear have over hmatrix?
23:22:04 <frxx> +for
23:22:23 <ReinH> frxx: you probably want Text for anything non-trivial
23:22:49 <ReinH> or ByteString where relevant
23:23:10 <frxx> for heavy parsing and such? what about when performance isn't an issue
23:23:30 <ReinH> kryft: linear is mostly about fast, low-level data structures and combinators
23:23:34 <frxx> is Data.Text meant to replace String in all cases?
23:24:08 <ReinH> hmatrix includes a lot of high-level algorithms and such
23:24:39 <ReinH> frxx: String is still useful for simple cases where it performs adequately
23:25:05 <ReinH> If you're writing a command-line app, String is probably Fast Enough
23:25:29 <ReinH> if you're write a templating library for generating HTML or such, you probably want Text
23:27:12 <frxx> is there any advantage in using String even when it's fast enough? as opposed to always using Data.Text
23:27:27 <kryft> Do you happen to know of a good example of fast numerics (with or without linear algebra) using the ST monad that I could eyeball?
23:28:14 <ReinH> frxx: it's a bit annoying to use Text as it's usually imported qualified, although OverloadedStrings helps out with that
23:28:38 <ReinH> kryft: Anything that uses STArray would be a good example
23:28:48 <haasn> Data.Text.Lens ~
23:29:28 <ReinH> haasn: that helps :)
23:29:37 <kryft> ReinH: Ok, thanks
23:30:01 <ReinH> kryft: this uses STArray https://gist.github.com/reinh/8c5b077ef47933eb12fb
23:33:37 <kryft> ReinH: So STArray is basically just a mutable vector? And if I'm doing in-place updates on matrices, I need something like ST MatrixType? (I haven't used ST, so I don't know the real type signature)
23:33:50 <ReinH> kryft: STArray is a mutable array in the ST monad.
23:34:11 <kryft> Right, yes.
23:34:50 <ReinH> if you want to do in-place mutation you need a monad that allows state transformation. This usually means ST or IO.
23:35:41 <ReinH> ST is a strict state thread monad. The main advantage of using ST over IO is that you are restricted from performing arbitrary IO.
23:36:10 <ReinH> and generally from modifying memory outside of the monad's internal mutable state
23:36:24 <ReinH> (unsafePerformIO notwithstanding)
23:37:31 <ReinH> This means that runST is referentially transparent, which is a nice guarantee.
23:39:10 <kryft> Yes, I've understood that the point of the ST monad is to allow you to do destructive updating within the function while still appearing pure (referentially transparent) to the outside
23:39:50 <ReinH> kryft: hmatrix uses FFI to interface with GSL under the hood iirc
23:40:57 <ReinH> Looks like it does let you do mutation via Data.Packed.ST http://hackage.haskell.org/packages/archive/hmatrix/0.15.0.1/doc/html/Data-Packed-ST.html
23:41:18 <ReinH> but generally it provides a pure interface to the underlying GSL stuff
23:48:01 <kryft> Hmm, actually maybe I don't even need mutation...
23:50:26 <ski> kryft : ooc, what are you doing ?
23:50:53 <kryft> ski: Basically I want to implement this algorithm http://davidroihardoon.com/Professional/Publications_files/SCCA_fulltext.pdf
23:51:06 <kryft> Well, a slightly modified version, but anyway
23:51:11 <kryft> ski: (Page 12)
23:54:50 <ski> Algorithm 2 or Algorithm 3 ?
23:55:11 <kryft> Both actually
23:56:34 <kryft> And Algorithm 1 on the previous page too, but I figured that looking at any one of those is enough for figuring out how it should be done efficiently and elegantly in Haskell :)
23:57:24 <kryft> Now that I think about it, I'm guessing it could be done efficiently just by passing around state with a plain State monad
23:58:14 <kryft> Since all the 'destructive updates' in the algorithm description are of the form 'replace this vector (from the previous iteration) with the result from this calculation'
23:58:31 <Cale> kryft: You could use a Data.IntMap or Data.Map in place of a mutable array
23:58:53 <ski> or possibly even `Array'
