00:00:43 <dissipate_> major contributor to Haskell calls it 'useless': http://www.youtube.com/watch?v=iSmkqocn0oQ
00:01:37 <JuanDaugherty> same ole thing with SPJ?
00:01:46 <JuanDaugherty> like from 2 ya oder?
00:01:54 <CADD> dissipate_: blah old news..
00:02:49 <Twey> He was talking about the starting state, and he was joking.
00:02:50 <dissipate_> CADD, i'm surprised he hasn't ported Haskell to .NET
00:03:02 <dissipate_> since he works for MS
00:03:05 <CADD> dissipate_: lol, thats called f#
00:03:19 <dissipate_> i thought F# was based on ocaml?
00:03:24 <CADD> dissipate_: yup
00:03:29 <Twey> dissipate_: They prefer to take his ideas and attempt to port them to C#
00:03:39 <Twey> F# wasn't by SPJ
00:03:47 <CADD> nope
00:03:59 <dissipate_> Twey, actually, what he said was interesting. they want to port pure functions and STM to imperative languages.
00:04:17 <Twey> dissipate_: They tried for a bit, then gave up
00:04:31 <dissipate_> Twey, 'they' being MS research?
00:04:34 <Twey> Yes
00:04:42 <dissipate_> gave up in 2 years?
00:04:44 <CADD> lol slinky code
00:05:00 <Twey> The existing impurity made STM hard and pure code difficult to integrate, apparently
00:05:24 <CADD> Twey: what a suprise!
00:05:24 <Gracenotes> then people gave up on STM and decided to pursue HTM.
00:05:36 <Gracenotes> er, wait, that hasn't fully happened yet. anyway, soon.
00:05:38 <johnw> they wanted to port STM to cover side-effecting transactions, which essentially ended up being too near impossible
00:05:54 <dissipate_> and keep OOP i imagine?
00:05:58 <Twey> Gracenotes: HTM?
00:06:01 <shachaf> Gracenotes: Those are pretty unrelated for the most part.
00:06:18 <shachaf> Or, at least, are used to accomplish very different things.
00:07:09 <Gracenotes> they exist at different levels of abstraction, certainly.
00:07:43 <Gracenotes> not sure what OOP has to do with anything, though. there are practically no OO languages, anyway.
00:07:46 <dissipate_> so let me get this straight. they want to keep OOP, and functions with side effects but allow pure functions as well and STM in an imperative language?
00:08:00 <Twey> dissipate_: Mostly just STM
00:08:20 <Twey> Also, want*ed*.
00:08:32 <dissipate_> how does OOP work with pure functions? everytime you mutate it, you get a fresh copy?
00:08:43 <johnw> dissipate_: what do you mean be OOP?
00:08:46 <dissipate_> sounds nutty
00:08:55 <dissipate_> johnw, object oriented programming
00:09:02 <Twey> Heh
00:09:11 <johnw> yes, I know what the acronym means; but what do you mean by it in this context?
00:09:32 <johnw> are you talking about message passing, encapsulation, inheritance-based polymorphism, ...?
00:09:37 <dissipate_> johnw, a language with classes and objects like Java
00:09:47 <dissipate_> johnw, yep
00:09:53 <Gracenotes> classes aren't really OOP.
00:09:56 <Gracenotes> subclassing is terrible.
00:10:04 <Gracenotes> </war>, sorry.
00:10:21 <dissipate_> johnw, not so much inheritance though. that has been deemed bad.
00:11:09 <aleator> Gracenotes: I can live with subclassing but subtyping gets me ;)
00:11:32 <dissipate_> aleator, and what about mixins?
00:11:43 <johnw> dissipate_: without inheritance, how is OOP different from just having record syntax?
00:12:28 <dissipate_> johnw, interfaces
00:12:33 <shachaf> I suspect that this isn't a good channel for "what's the true nature of OOP" arguments.
00:12:43 <johnw> my only point is that "OOP" covers a broad range of ideas; when I think of OOP, I mostly consider Smalltalk
00:12:55 <dissipate_> johnw, also, mixins, which piggy back off multiple inheritance.
00:12:59 <johnw> but shachaf is right, I suppose there isn't much fruitful discussion here wrt Haskell
00:13:47 <Gracenotes> this is the One True Paper on what objects are: http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
00:13:48 <dissipate_> shachaf, i was inquiring about these languages Simon Peyton was researching
00:14:18 <doomlord__> OOP is a vague buzzword
00:14:20 <Gracenotes> notably, they're contrasted with ADTs. In some ways, ADTs are more functional than objects.
00:15:01 <CADD> doomlord__: true that. except when its smalltalk
00:15:35 <CADD> doomlord__: not only is it a buzzword, its a poorly defined buzzword
00:16:33 <dissipate_> CADD, have any idea what simon peyton was referring to in his 'nirvana' category of languages?
00:16:43 <doomlord__> particularly annoying when used in conjunction with C++ eg "my C++ code is propper OOP, yours isn't" etc :)
00:16:55 <CADD> dissipate_: the band?
00:17:06 <dissipate_> CADD, har har. :P
00:17:15 <CADD> dissipate_: but seriously though. useful and pure iirc?
00:17:47 <dissipate_> CADD, 'useful and safe' is the phrase he used
00:18:06 <CADD> dissipate_: oh lawdy tell me about it. and sadly this goes all the way from the freshman dorm to the watercooler in the corperate skyscraper
00:18:12 <CADD> oops
00:18:13 <dissipate_> BTW, how do we know this guy isn't just pandering to the guys writing his paycheck at MS?
00:18:15 <CADD> doomlord__: ^
00:18:28 <Gracenotes> another fun thing: I like Pierce's rule of thumb that OOP is Java where all classes are final and non-interface types only appear when they're instantiated.
00:18:32 <CADD> dissipate_: SPJ you mean?
00:18:38 <dissipate_> CADD, yep
00:18:58 <Cale> Anyone know whether there's a simple library around with a representation of IO actions which carry out their effect exactly once when run, and thereafter produce a cached value?
00:19:00 <Gracenotes> ...really offtopic, though. this channel should be discussing more important things, like
00:19:02 <dissipate_> CADD, i find it ironic that one of the main architects of haskell is working for The Man at MS. i'm sure they pay him well though.
00:19:04 <CADD> dissipate_: i think you are thinking very little of SPJ's work and the virtues of referential transparency..
00:19:28 <CADD> Cale: like a memoization transformer?
00:19:40 <dissipate_> CADD, no, i'm trying to figure out what language he was working on that is both 'safe and useful'
00:19:44 <CADD> dissipate_: hells yeah they do
00:19:51 <Gracenotes> Cale: unsafeInterleaveIO?
00:19:51 <johnw> Cale: explicit-sharing?
00:19:59 <CADD> dissipate_: he is not, they are working *towards* it
00:20:13 <levi> I think it's awesome that Microsoft pays people like SPJ to do researchy things with Haskell instead of making them churn out .NET frameworks or something.
00:20:14 <johnw> http://hackage.haskell.org/packages/archive/explicit-sharing/0.9/doc/html/Control-Monad-Sharing.html
00:20:26 <CADD> levi: i second that
00:20:29 <Cale> Gracenotes: Kind of, but safer :P
00:20:45 <Cale> explicit-sharing might be it, let's see
00:20:47 <dissipate_> CADD, but this 'safe and useful' language that has some kind of OOP (whatever  you want to call it) is going to be 'better' than Haskell?
00:20:57 <Cale> hmm
00:20:59 <shachaf> I don't think explicit-sharing is it.
00:21:15 <Cale> I just want something like  makeOnce :: IO a -> Once a; runOnce :: Once a -> IO a
00:21:23 <CADD> dissipate_: useful != oop in that talk
00:21:26 <dissipate_> levi, he said in the video they were working on some language for .NET, porting some ideas from haskell...
00:21:56 <shachaf> Or just makeOne :: IO a -> IO a?
00:21:59 <shachaf> ce
00:22:17 <CADD> dissipate_: iirc it meant lots of mutation
00:22:19 <Cale> shachaf: I want the type to represent the fact that this is present.
00:22:36 <dissipate_> CADD, true, but do you really believe MS is going to put out a non-OOP language?
00:22:41 <Cale> (it's easy enough to write this myself if needs be)
00:22:49 <shachaf> Cale: Async does that but it also spawns a thread immediately which is presumably not the behavior you want.
00:22:56 <CADD> dissipate_: yeah, have you ever seen the langs that come out of MSR?
00:23:03 <levi> dissipate_: Researching cool stuff in Haskell and then porting it to other languages is not what I meant by 'churning out .NET frameworks'.
00:23:03 <dissipate_> CADD, nope
00:23:06 <shachaf> I can't think of a library that provides exactly that.
00:23:10 <johnw> shachaf: why do you think explicit-sharing does not apply?
00:23:11 <CADD> dissipate_: oh man. crazy studd
00:23:13 <CADD> stuff*
00:23:17 <Cale> yes, I'm thinking of something like Async, except instead of forking, wait until the first time the value is demanded and then execute the action
00:23:29 <dissipate_> CADD, the languages in .NET don't seem crazy at all.
00:23:30 <shachaf> Er, I meant IO a -> IO (IO a), of course.
00:23:39 <shachaf> There seems to exist http://hackage.haskell.org/package/io-memoize
00:23:57 <johnw> do { runOnce <- share someAction; runOnce; runOnce }
00:24:00 <shachaf> Which gives you that type, but not the extra Once type that you wanted.
00:24:05 <Cale> yeah
00:24:36 <dissipate_> levi, what are they churning out exactly?
00:24:45 <dissipate_> if not stuff for .NET
00:25:05 <levi> dissipate_: Mostly research papers. :P
00:25:47 <levi> Microsoft Research does actually do *research* rather than just work on the next generation of product.
00:25:49 <shachaf> Perhaps explicit-sharing isn't the package I was thinking of...
00:26:08 <dissipate_> levi, which researcher came up with Visual Basic?
00:26:27 <CADD> dissipate_: although i cant find it right now, i remember some of the stuff that has come out. they do very very intersting stuff at msr
00:26:39 <levi> dissipate_: Why are you asking stupid questions?
00:26:52 <dissipate_> CADD, too bad they will be shut down when MS goes belly up
00:26:53 <CADD> levi: hehe, good question
00:27:08 <CADD> dissipate_: you are expecting for MS to go belly up?
00:27:18 <dissipate_> levi, some of their products are really bad
00:27:25 <shachaf> At any rate it looks rather too complicated for what Cale wants.
00:27:31 <shachaf> What's with all the instances?
00:28:05 <dissipate_> CADD, it's not a matter of 'if' but 'when'. technically, though, they won't go bankrupt, just split up and have their different divisions sold off.
00:28:33 <shachaf> Oh, Sharing /= Shareable. Still.
00:28:53 <CADD> dissipate_: im guessing you are expecting linux to eat ms's lunch?
00:29:08 <frontend1oader> this is the year of the linux desktop
00:29:28 <ibotty> frontend1oader: also in this channel?
00:29:35 <dissipate_> CADD, no, but google, apple and facebook might.
00:30:10 <dissipate_> CADD, i don't expect windows to go away anytime soon. like i said, they will probably just split up and get sold off. the products will still be around.
00:30:43 <johnw> shachaf: I think it's to allow monadic lists which evaluate members only once; otherwise, the Shareable instances are all pretty meaningless ('shareArgs _ = return' in nearly every case)
00:31:19 <levi> dissipate_: This is not #microsoft, it's #haskell. This discussion isn't even tangentially relevant anymore.
00:31:30 <CADD> dissipate_: i think facebook will go away before ms
00:31:35 <johnw> shachaf: in fact, not just members, but tails as well
00:31:35 <CADD> levi: kk, it ends here
00:32:02 <shachaf> Thanks, levi.
00:32:09 <johnw> if you don't use that feature, it seem pretty similar to io-memoize, just more convuloted
00:32:28 <dissipate_> levi, well, to bring it back to haskell, i don't think haskell itself is ever going into .NET
00:32:42 <CADD> dissipate_: meh, how cares?
00:32:44 <shachaf> Neither of them does what Cale wants, though.
00:32:53 <shachaf> Given that it's three lines to write it himself, that's probably what he'll do.
00:32:54 <CADD> dissipate_: haskell is good on its own
00:32:59 <dissipate_> levi, at least not officially
00:33:37 <dissipate_> CADD, i don't care, but people itching to use haskell at some .NET shop will care
00:33:45 * hackagebot dimensional 0.12.1.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.12.1.1 (BjornBuckwalter)
00:33:53 <CADD> dissipate_: i doubt there are many of those shops
00:34:50 <shiona> We have all these monoids and applicatives and such. Is there such a class that empty * x = x and for every y != empty : y * x = y?
00:35:01 <dissipate_> CADD, what kind of shops are using haskell?
00:35:34 <shachaf> shiona: For any x?
00:35:34 <CADD> shiona: huh? that would only work if x = unit
00:35:46 <CADD> dissipate_: not enough
00:35:51 <Gracenotes> it wouldn't work if empty = 0.
00:35:52 <shachaf> I.e. ab=a, unless a=1?
00:35:56 <shiona> shachaf: yes, for any x
00:36:25 <shiona> would such a thing make any sense
00:36:27 <shachaf> Maybe you want First?
00:36:36 <shachaf> I'm not sure how useful a class for that is in general.
00:37:09 <shiona> I'll take a peek
00:37:13 <dissipate_> CADD, well, that brings me back to the whole native compiled binary issue. i don't know shops doing web development running those.
00:37:22 <Gracenotes> anyway, about porting Haskell to things in general, issues are that every call in Haskell is a tail call, and representing everything as a thunk is just stupidslow.
00:37:34 <shiona> yeah, sounds about right. thanks
00:37:44 <Gracenotes> well, porting Haskell to language VMs
00:38:04 <CADD> dissipate_: im not sure what you mean
00:38:33 <dissipate_> CADD, i had a whole discussion earlier about how the main haskell compiler compiles to native binary executables.
00:38:36 <levi> dissipate_: Look harder.  Or, instead, write a haskell program. Come back when you have questions about haskell!
00:38:46 <dissipate_> CADD, industry has moved away from that in a big way.
00:39:27 <CADD> dissipate_: well there are quite a few shops using happstack/yesod/snap
00:39:34 <dissipate_> Gracenotes, a VM or interpreter ported to a variety of architectures
00:39:46 <Gracenotes> the cargo cult industry? That's the best one to be in.
00:40:45 <CADD> Gracenotes: skip the cargo and just go with the cult!
00:41:13 <dissipate_> Gracenotes, CADD said above ^ that not enough shops run Haskell. either it's good for industry or it isn't.
00:41:34 <dissipate_> Gracenotes, and i pointed out that a huge chunk of industry has moved away from native compiled binaries
00:41:56 <CADD> dissipate_: i see it as neutral. shops should use what they want
00:42:18 <CADD> dissipate_: i think compiled binaries are probably here to stay. especially in the closed source sphere
00:43:09 <dissipate_> CADD, of course they are, for systems programming. for doing web dev though? nope.
00:43:17 <Gracenotes> guess what, Haskell has bytecode
00:43:18 <Gracenotes> BAM
00:43:25 <CADD> :D
00:43:40 <dissipate_> Gracenotes, and that runs on what VM?
00:43:47 <CADD> Gracenotes: now we just need a computer that runs haskell bytecode in-silico
00:43:52 <Gracenotes> ready to leverage that for the next-generation of synergistic startups.
00:43:52 <levi> Please don't feed the troll anymore.
00:44:11 <CADD> dissipate_: yeah man, i dont see where you are going with this
00:44:57 <dalaing> I thought it was going to #haskell-blah
00:45:03 <dissipate_> CADD, i'm not going anywhere, i already made my point. you can argue the reasons industry went away from native compiled binaries, but that's just a fact. you can't say Haskell should be used by more shops and then ignore this.
00:45:20 <CADD> dalaing: yes please. let do this in #haskell-blah
00:45:21 <CADD> dissipate_: ^
00:45:27 <shachaf> Better to go to #haskell-/dev/null
00:45:44 <CADD> shachaf: :D
00:46:08 <dalaing> I'm not currently in #haskell-blah, so it's the same to me, maybe I should have suggested #haskell-gah
00:46:21 <Gracenotes> I see a great future for firms who shave their yaks vertically rather than horizontally.
00:53:46 <dmj`> I have a lens-aeson question.
00:53:57 <dmj`> In lens-aeson you can do this:
00:53:59 <dmj`> putStrLn $ "{\"a\": 1, \"b\": 3}" & key "a"._Integer *~ 100
00:54:07 <dmj`> and it will return: {"a":100,"b":3}
00:55:03 <dmj`> I have my own json file, and I want to modify the key "x" to be 100 let's say
00:55:17 <dmj`> print $ json ^? key "elements" . nth 0 . key "x" *~ 100
00:55:56 <dmj`> but that fails because I need a mutator, how do I add a mututator?
00:57:20 <dalaing> I don't know anything about lens-aeson, but a visual diff makes me wonder you're missing a ._Integer from that incantation
00:57:27 <aleator> dmj`: Does this work? print (json & key "elements" . nth 0 .key "x"._Integer *~ 100)
00:57:59 <hari_> In this code fragment Can anybody tell me why this pattern match overlap occurs: http://lpaste.net/92780
00:58:12 <CADD> Gracenotes: lol
00:58:59 <shachaf> I bet that's not the real reason, but I don't know anything about Aeson. A good way to get help is to give people complete, executable code that they can try things out with.
01:01:52 <dalaing> hari_: maxRows and maxCols aren't working as patterns
01:02:09 <hari_> dalaing, I suspected as much
01:02:26 <dalaing> (unless I've gotten something horribly wrong)
01:03:04 <hari_> dalaing, how do I set the pattern when I don't have an absolute value but need to match against another parameter?
01:04:11 <dalaing> hari_: more guards?
01:05:15 <dalaing> if it was me I'd make each of those patterns into a function, use guards to work out if the 3rd and 4th parameters were 0 or the maximum values, then call the appropriate function
01:05:38 <dalaing> there could be an easier way, I haven't tried to work out what you're actually doing after the pattern match
01:05:41 <dmj`> aleator: Yea, that actually works, but the value isn't really updated and it only returns a subset of the json
01:06:00 <dmj`> aleator: but yes it compiles
01:08:18 <hari_> dalaing, I see.
01:09:54 <hari_> dalaing, pattern matching seemed much easier to work out the flow of the code
01:11:20 <dalaing> hari_: I have a vague feeling that a Foldable or Traversable instance for Row might be helpful in some way
01:14:04 <hari_> dalaing, I have not yet understood those concepts traversable or foldable
01:14:45 <hari_> dalaing, the code is for the game "Lights Off"
01:15:58 <hari_> Where, when I toggle one (row, col) then (row-1, col), (row, cow-1), (row, col), (row, col+1) and (row+1,col) are affected
01:16:32 <hari_> Special cases happen obviously when the column and row are 0,0 or (maxrow, maxcol)
01:17:47 <hari_> Couldn't figure out any suitable way. I guess I must look into more advanced concepts.
01:18:46 * hackagebot yaml-config 0.2.0 - Configuration management  http://hackage.haskell.org/package/yaml-config-0.2.0 (FedorGogolev)
01:18:59 <mm_freak> ocharles: one way to achieve scene deltas easily is by having two types
01:19:04 <mm_freak> Scene and DScene
01:19:25 <mm_freak> ocharles: the scene wires generate only scene deltas
01:23:36 <zielwasserjunki> hari_, so your function looks like: one :: (Int, Int) -> [(Int, Int)]?
01:30:01 <dmj`> Here's a better example of my lens-aeson code: For some reason it's never actually updating the value of "x" to 100
01:30:11 <dmj`> http://lpaste.net/7443921765627068416
01:30:25 <hari_> zielwasserjunki, I will post the full code
01:30:29 <dmj`> lens-aeson /= aeson-lens
01:30:41 <hari_> zielwasserjunki, I am mapping over the function on a list of rows
01:32:41 <hari_> be back later
01:32:51 <mm_freak> when you say "\_ -> …", hlint would tell you to use const…  perhaps this one should be removed
01:33:44 <supki> dmj`: 0 * 100 /= 100
01:35:22 <ibotty> mm_freak: why? different strictness?
01:36:03 <dmj`> supki: 0 / 100 /= 100
01:36:42 <supki> yes, you need +
01:38:31 <dmj`> supki: ooooooooh, so that's what that operator does :)
01:38:46 <mm_freak> ibotty: no, strictness is the same, but i choose between const and \_ -> depending on which one looks better or is more readable
01:39:02 <ibotty> ah so they are identically but in look
01:39:40 <mm_freak> ibotty: for example if you write "mkPure $ \ds x -> …" all over your library…  then for consistency you want to write "mkPure $ \ds _ -> …"
01:39:45 <mm_freak> not something weird based on const
01:39:57 <dmj`> supki: It's 3:40 here give me a break
01:40:05 <mm_freak> mkPure $ \ds -> const $ …
01:40:18 <mm_freak> mkPure $ \ds _ -> …
01:40:52 <ibotty> ah for partial constant arguments i see your point
01:41:13 <mm_freak> ibotty: also for this case:  mkSF_ $ \x -> …
01:41:25 <mm_freak> for consistency you want to write:  mkSF_ $ \_ -> …
01:41:33 <ibotty> it looks even more weird when you need a flip inside to apply the const trick (don't know whether hlint proposes that)
01:41:36 <mm_freak> hlint wants you to write something like this:  mkSF_ . const $ …
01:41:59 <mm_freak> which is not only inconsistent, but also derails the indentation mode of my editor
01:42:22 <ibotty> well. i would have written it that way... but in a larger mostly identical stanza of code, maybe not.
01:42:52 <mm_freak> well, imagine you have a library of hundreds of similar looking functions ;)
01:43:10 <mm_freak> they all begin with one of those mk* functions and a set of lambda arguments
01:43:12 <ibotty> yes. i can imagine scenarios :D
01:45:44 <paolino> @hoogle minBy
01:45:44 <lambdabot> No results found
01:47:22 <paolino> uhm should I implement it with minimumBy f [x,y] , or there is a nicer way ?
01:48:06 <mm_freak> paolino: 'min'
01:48:15 <paolino> :t min
01:48:16 <lambdabot> Ord a => a -> a -> a
01:48:34 <mm_freak> oh, with f
01:48:40 <paolino> yes
01:49:18 <mm_freak> paolino: what is 'f'?
01:49:24 <paolino> fst
01:49:33 <ibotty> what about `min . on f`
01:49:35 <mm_freak> :t minimumBy
01:49:36 <lambdabot> (a -> a -> Ordering) -> [a] -> a
01:49:44 <mm_freak> that would be a type error, paolino
01:49:57 <mm_freak> you want to compare only the fst?
01:50:11 <paolino> minimumBy (comparing f)
01:50:22 <mm_freak> paolino: can you compare the snd?
01:50:34 <mm_freak> i mean, does it have an Ord instance?
01:50:43 <paolino> no
01:50:52 <paolino> :t on
01:50:53 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:51:34 <ibotty> min `on` f will discard your original tuple\
01:51:39 <ibotty> so that won't work
01:51:42 <paolino> right
01:54:03 <paolino> some prism, maybe :-P
01:54:26 <mm_freak> \x y -> if fst x <= fst y then x else y
01:54:31 <mm_freak> how about this?
01:56:08 <paolino> well, I asked because sometimes I look for something in Prelude which should be there but it's not because you can have it done in a more general way
01:57:37 <paolino> also min is there to avoid that if
01:58:07 <paolino> but I will if :-)
01:58:47 * hackagebot tuples-homogenous-h98 0.1.1.0 - Wrappers for n-ary tuples with Traversable and Applicative/Monad instances.  http://hackage.haskell.org/package/tuples-homogenous-h98-0.1.1.0 (PetrPudlak)
01:58:49 <ibotty> well i like minimumBy (comparing fst) [x, y]
01:58:53 <mm_freak> desparately looking for abstraction even for comparing two tuples is one of the few of The Haskeller's Burdens
01:58:55 <ibotty> it's even longer :D
01:59:10 <mm_freak> just use the damn if ;)
01:59:34 <ibotty> ... but shouldn't there be a nice combinator :D
01:59:55 <mm_freak> how long have you been programming haskell?
02:00:03 <dmj`> I wrote an implementation of a Binary Search Tree, can't figure out how to implement the monad instance though... functor makes sense.. but bind is unclear to me
02:00:13 <hpaste> dmj pasted “Binary Search Tree” at http://lpaste.net/92781
02:00:22 <paolino> mm_freak, me ?
02:01:14 <mm_freak> dmj`: your tree may not be a monad
02:01:46 <mm_freak> dmj`: the usual monadic tree looks like this:  data BTree a = Leaf a | Branch (BTree a) (BTree a)
02:02:03 <mm_freak> but it doesn't have values at branches, only at leaves
02:02:17 <mm_freak> paolino: yeah
02:02:55 <b__> Is there a library of Parsec based parsers for common patterns?
02:03:12 <mm_freak> dmj`: yes, i'm pretty sure your tree type is not a monad
02:03:32 <paolino> ibotty, this story of computing a value from another tuple it to the first an use this to sort some as to come to an end
02:04:07 <paolino> mm_freak, I' am hobbist so I don't program, I'm just exposed
02:04:42 <ibotty> paolino: ?
02:04:56 <paolino> botty, I do this in every program
02:05:24 <mm_freak> dmj`: in 'Node x l r >>= f' the only thing you can do is to apply f to x, completely discarding the branches
02:06:15 <mm_freak> paolino: sure, but for how long?  i have a followup question based on your answer…  more than one year? =)
02:06:21 <paolino> I'm pretty sure I always have a map snd . sortBy (comparing fst) . map (f &&& id) or similar in every application
02:06:28 <paolino> mm_freak, sure
02:06:44 <mm_freak> paolino: have you ever needed this before?  and do you find it likely that you will need it after today? =P
02:07:09 <mm_freak> if you do, maybe the proper answer is to write a wrapper type
02:07:19 <mm_freak> newtype Fst a = Fst a
02:07:32 <mm_freak> instance (Ord a) => Ord (Fst (a, b))
02:07:33 <ibotty> i think most people have a common Data.Prelude.Extra module or something like that. not for published stuff but for one-offs
02:07:47 <dmj`> mm_freak: interesting. I'll have to stare at it more
02:09:11 <dmj`> mm_freak: for pre,post,in-order traversal using (++) is ok though right?
02:10:15 <mm_freak> dmj`: yes, although none of those folds are natural
02:10:28 <mm_freak> dmj`: this is another difference…  a monadic tree always has a canonical fold
02:10:46 <dmj`> pre-order traversal == depth first search, with is linear, just want to make sure mine is too
02:11:24 <mm_freak> dmj`: do you want a binary search tree like Set or rather a finger-tree like Seq?
02:12:51 <dmj`> mm_freak: Well I mean, both would be fine, the goal is pedagogy and understanding trade-offs in a functional setting
02:14:32 <dmj`> mm_freak: So sets are implemented using the tree you described above?
02:14:53 <dmj`> mm_freak: Also, canonical fold, do you mean that because my tree is now a monad I can use foldM on it?
02:15:04 <dmj`> @src foldM
02:15:04 <lambdabot> foldM _ a []     = return a
02:15:05 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:15:54 <mm_freak> dmj`: well, sure, you can use foldM, but i'm thinking of a Foldable instance
02:16:19 <mm_freak> in your case, which one do you choose?  in the monadic case, you always know which one to choose
02:17:30 <satc> I want something like typfamilies but at kind level. Does that exist in haskell??
02:17:48 <mm_freak> satc: nope
02:19:36 <mm_freak> dmj`: note how (>>=) for b-trees corresponds to concatMap for lists
02:19:39 <mm_freak> you could call it leafMap
02:21:16 <dmj`> mm_freak: So my tree can't be a monad, but it can be a foldable functor
02:22:08 <mm_freak> dmj`: sure…  whenever you can write a toList function, you can write a Foldable instance
02:22:13 <satc> mm_freak: Given data Foo (a :: X) = Foo a. I want X to somehow capture that a can be of type A | B | C. I know I can achieve that by defining data X = A | B | C and then lifting type X to kind level. Now suppose, data Bar (a :: Y) = Bar a, here I want Y to capture a to be A | B. Now I can not define data Y = A | B.
02:23:29 <mm_freak> satc: data X :: * -> * where Xa :: A -> X A; Xb :: B -> X B; …
02:23:58 <mm_freak> data Foo (a :: X a) = Foo a
02:25:03 <dmj`> mm_freak: why does a monadic tree have a canonical fold? Doesn't data BTree a = Empty | Node a (BTree a) (BTree a) have one as well
02:25:10 <mm_freak> satc: of course you could dispense with all this type-level work and just write appropriate instances
02:25:30 <mm_freak> satc: instance Monoid (Foo A); instance Monoid (Foo B); …
02:26:01 <mm_freak> dmj`: you have three to choose from, each equally valid
02:26:09 <Taneb> I am going to make a little calculator app in Haskell
02:26:13 <satc> mm_freak: Thanks. Let me see if that works in my original problem.
02:26:18 <mm_freak> iot, pre, post
02:26:51 <hpaste> b__ pasted “<3” at http://lpaste.net/92782
02:27:19 <mm_freak> dmj`: the reason why you have a canonical fold for monadic trees is that you have a canonical join, which is also kind of a flattening operation
02:27:27 <mm_freak> join :: BTree (BTree a) -> BTree a
02:28:26 <Hugh__> Hi- when you use a language pragma at the top of a file, will the compiler use it only for the code in that file or for all code in the program? thanks
02:28:40 <bartavelle> Hugh__, only in that file
02:28:55 <Hugh__> awesome. as i thought! Thakns
02:29:00 <mm_freak> b__: welcome to applicative style =)
02:30:07 <dmj`> mm_freak: k, I'm gonna write out the monad instance later, 430am here
02:30:13 <b__> Love how I can use int for both Ints and Integers, without writing the types
02:30:27 <dmj`> mm_freak: thank you for the help
02:34:00 <mm_freak> dmj`: you're welcome
02:34:22 <mm_freak> b__: welcome to H-M type inference =)
02:34:54 <b__> :)) It's so pretty
02:37:51 <satc> mm_freak: http://lpaste.net/92784 I am not sure how to get rid of the type family abuse here?
02:38:39 <mm_freak> satc: i don't know either, because i don't know what you want to do
02:39:32 <mm_freak> apparently some machine code stuff
02:41:16 <satc> mm_freak: Yeah.. I want haskell to infer type automatically
02:42:06 <satc> mm_freak: http://lpaste.net/92784 See the updated code and how types are inferred in the examples at the end of the file
02:42:30 <mm_freak> satc: constraints won't help type inference
02:42:49 <mm_freak> because both type classes and type families are open
02:43:21 <satc> mm_freak: I know that. I just want it to fail if wrong types are given
02:43:38 <mm_freak> satc: btw, DataKinds also lift [], which may be nicer than ArgList
02:44:17 <satc> mm_freak: Oh. Thanks for that.
02:44:31 <mm_freak> remember to use ': and '[]
02:45:03 <mm_freak> satc: i think what you really want is a simple GADT
02:46:45 <mm_freak> satc: GADTs are the primary way to establish constructions, and the values are both programs and proofs
02:47:17 <satc> mm_freak: Ok.. I will try that and see if I can come up with a simpler design
02:47:24 <mm_freak> (i'm pretending that ⊥ doesn't exist)
02:52:46 <merijn> mm_freak: "type families are open" you forgot the footnote "except in 7.8 where we will have closed type families" ;)
02:53:02 <mm_freak> ah, nice
02:53:13 <merijn> mm_freak: I know, right!
02:53:17 <mm_freak> finally type level functions =)
02:54:31 <mm_freak> change log for GHC 13.0.0:  Added -XAgda2013.
03:03:48 * hackagebot sodium 0.7.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.7.0.0 (StephenBlackheath)
03:19:42 <Taneb> Update on me writing a calculator app in Haskell: I can successfully input numbers
03:21:55 <Taneb> With decimal points!
03:22:31 <Hafydd> Does it have a CLI?
03:23:56 <Taneb> Nah, GUI
03:24:36 <Taneb> The main point was to help me learn to write GUI code
03:25:37 <ocharles> mm_freak: but fast and loose reasoning is morally correct, so you don't have to feel bad about _|_ :)
03:25:47 <Hafydd> You should have chosen something that benefits more from not having a CLI.
03:25:48 <ocharles> though I do need to actually read that paper to make claims like that
03:25:57 <Hafydd> GUI calculators are awful.
03:26:13 <mm_freak> ocharles: but i feel bad about saying "proof" in the presence of ⊥ =)
03:26:15 <Hafydd> (Unless there's a CLI embedded in the GUI)
03:26:46 <mm_freak> Taneb: which GUI framework?
03:26:50 <Taneb> GTK
03:27:09 <Taneb> Hafydd, could you suggest something?
03:28:06 <Hafydd> Taneb: a paint program.
03:28:17 <Hafydd> Minesweeper.
03:28:33 <Taneb> Hafydd, let me do this in small steps
03:28:36 <Hafydd> A graph editor.
03:29:07 <Kaini1123> Getting Minesweeper right is extraordinarily difficult :P
03:29:16 <Hafydd> What's difficult about it?
03:29:28 <Kaini1123> Generating fields that are guranteed to be solvable
03:29:31 <Hafydd> Oh, generating solvable puzzles? I suppose so.
03:29:46 <Taneb> Kaini1123, I don't think even Windows minesweeper does that
03:30:15 <Kaini1123> Taneb, yes - that's why I've never played the Windows version
03:30:30 <Taneb> Kaini1123, do other versions?
03:30:36 <`Jake`> There's a whole lot of strategy involved with efficient guessing
03:31:17 <Kaini1123> Taneb, for example http://www.chiark.greenend.org.uk/~sgtatham/puzzles/
03:31:27 <Taneb> Oh, wow
03:42:27 <ocharles> mm_freak: here's what I came up with last night http://lpaste.net/92787
03:42:56 <ocharles> mm_freak: idea is to build up Scenes, and when rendering I check the delta between Scenes to do the minimal amount of redrawing, though that's not yet implemented
03:43:12 <ocharles> mm_freak: I also use the monad under the Wire as an asset cache
03:43:54 <ocharles> All a bit messy at the moment, but I'm enjoyng where it's going
03:44:41 <mm_freak> ocharles: you shouldn't call the session value 'clock'
03:46:01 <ocharles> right, it's the time delta
03:46:12 <ocharles> (and a new session)
03:48:36 <mm_freak> ocharles: it's not a time delta
03:48:44 <mm_freak> it's only a time delta for Timed T () =)
03:48:55 <mm_freak> it's a state delta, that's why i call it 'ds'
03:48:58 <mm_freak> s and ds
03:49:04 <ocharles> ok, makes sense
03:49:18 <ocharles> in *this* case I'm in control of it so it really is a time delta. but it seems good to get into that mode of thinking
03:52:06 <ocharles> using foldMap to construct the scene is fun though :)
04:51:01 <kuribas> Why isn't there a computer algebra written in haskell yet?
04:51:32 <kuribas> I am using maxima, but it's semantics are strange.
05:20:49 <shiona> is there some neat way of doing a 'reverse map', a -> [a->b] -> [b]
05:21:02 <shiona> I found out using ap works, but I need to make a singleton list
05:21:12 <mauke> sequence
05:21:21 <mauke> well, flip sequence I guess
05:21:39 <shiona> hmm, thanks. Will take a look
05:21:40 <mauke> :t map . flip id
05:21:41 <lambdabot> a -> [a -> b] -> [b]
05:21:45 <edvo> :t \a -> map ($ a)
05:21:46 <lambdabot> a -> [a -> b] -> [b]
05:21:50 <mauke> :t [map . flip id, flip sequence]
05:21:50 <lambdabot> [a -> [a -> a1] -> [a1]]
05:23:03 <mauke> :t flip ap . pure
05:23:03 <lambdabot> (Monad m, Applicative m) => a -> m (a -> b) -> m b
05:23:30 <mauke> :t [map . flip id, flip sequence, flip ap . pure]
05:23:31 <lambdabot> [a -> [a -> a1] -> [a1]]
05:24:26 <dfan> Whoa, trying to wrap my brain around flip id
05:24:42 <shiona> edvo: that was probably what I was looking for. Shows how little I know about $
05:25:12 <edvo> dfan: flip id = flip ($)
05:25:19 <mauke> dfan: ($) = id
05:25:45 <mauke> :t ($)
05:25:46 <lambdabot> (a -> b) -> a -> b
05:25:54 <mauke> which is (a -> b) -> (a -> b)
05:26:00 <mauke> which is c -> c where c = a -> b
05:26:06 <mauke> which is a special case of id
05:26:16 <dfan> flip ($) I understand, I guess the point is that $ really is a no-op
05:26:32 <mauke> @src flip
05:26:32 <lambdabot> flip f x y = f y x
05:26:43 <mauke> flip id = \x y -> id y x
05:26:50 <mauke> = \x y -> y x
05:27:25 <Tinned_Tuna> @src flip
05:27:25 <lambdabot> flip f x y = f y x
05:27:31 <dfan> Got it now, thanks
05:58:52 * hackagebot vault 0.3.0.1 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.0.1 (HeinrichApfelmus)
06:03:39 <bitonic-work> can I install a package into a specific sandbox?
06:03:46 <bitonic-work> like, a local package
06:06:00 <donri> bitonic-work: perhaps cabal --sandbox-config-file=FILE install ...?
06:06:22 <bitonic-work> donri: I'll try that in a second, thanks
06:12:40 <bitonic-work> unrelated question
06:12:52 <bitonic-work> how do I nuke *all* cabal related stuff on OS X?
06:15:53 <merijn> bitonic-work: Look in ~/Library/Haskell
06:24:04 <bitonic-work> merijn: yeah but there are a lot of other places :(
06:24:16 <bitonic-work> I find it quite weird that there is no way to uninstall the ghc binaries
06:24:21 <bitonic-work> or at least I couldn't find it
06:26:07 <merijn> Eh, there is
06:26:15 <merijn> Haskell Platform provides an uninstaller
06:26:54 <merijn> bitonic-work: There is an "Uninstaller" script in /Library/Frameworks/GHC.framework/Versions/Current/Tools
06:28:57 <bitonic-work> merijn: I'm talking about the GHC binaries
06:29:00 <bitonic-work> not the Haskell platform
06:31:22 <merijn> bitonic-work: Well, how did you install the ghc binaries?
06:31:33 <bitonic-work> merijn: from the website
06:32:30 <merijn> mmm, then I don't really know? I've only ever installed the GHC binaries via platform or by downloading them and doing the "make install" thing, both are easy to uninstall, no clue how to do so with the GHC installer
06:33:13 <bitonic-work> merijn: yes, I downloaded the binaries and did `make install`.  how do I remove that?
06:35:04 <merijn> Should be a "make uninstall" target, I hope, that or nuke the --prefix you installed into
06:36:05 <bitonic-work> merijn: there is no `make uninstall' target, and nuking `/usr' might not be a good idea.
06:37:26 <merijn> ah
06:37:33 <merijn> This is why installing into /usr is a terrible idea >.<
06:38:12 <bitonic-work> actually it's /usr/local
06:38:15 <bitonic-work> which is a bit less bad
06:38:22 <bitonic-work> I never had a problem installing in /usr/local with linux
06:38:42 <geekosaur> right, but you still have to disentangle it from anything else you might have installed there
06:38:42 <merijn> bitonic-work: Did you ever install something using make install in linux?
06:38:56 <bitonic-work> merijn: of course
06:39:16 <merijn> The only reason it's not a problem in linux (usually) is package managers carefully doing all the details for you
06:39:37 <bitonic-work> no no, I'm talking about installing stuff with `make install'.  but there usually is some cleanup command
06:39:48 <bitonic-work> with ghc you're screwed apparently
06:40:11 <merijn> Might be there's another cleanup command rather than "make uninstall", I just wouldn't know what
06:41:17 <bitonic-work> doesn't look like it
06:41:44 <applikativ> bitonic-work: i always put it ghc & friends in their own directory
06:41:51 <applikativ> for frequent nuking
06:42:28 <applikativ> here's the list of things in .../bin
06:42:31 <bitonic-work> boh, I never once had to do a GHC installation.  if anything the local cabal database
06:42:49 <bitonic-work> yeah I was just doing that
06:42:58 <bitonic-work> installing in an isolated prefix and see what's there
06:43:08 <applikativ> in lib there is a separate ghc subdir
06:43:35 <applikativ> if it's parallel to what I have, so remove /usr/local/lib/ghcsomethig
06:44:00 <bitonic-work> applikativ: don't worry, as said I've installed the thing already in a separate prefix
06:44:08 <bitonic-work> but thanks ehe
06:44:43 <applikativ> oh i thot you were trying to recover what to elimate from /usr/local
06:44:52 <bitonic-work> yep
06:47:26 <bitonic-work> OK it's not that much stuff
06:47:38 <applikativ> it seems to put fifty html pages directly in /usr/local/share/doc maybe that's not a much used directory
06:47:44 <applikativ> or directory name
06:51:38 <bitonic-work> applikativ: it didn't here
06:52:34 <bitonic-work> or maybe it did, but they were all under share/doc/ghc
06:53:53 * hackagebot io-streams 1.1.2.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.2.0 (GregoryCollins)
06:53:54 <applikativ> bitonic-work: right, i get it now; i have also been haddocking things into the same local directory somehow. or maybe just cabal which i also put in that directory.
06:54:17 <applikativ> pardon distraction
06:55:10 <applikativ> the only other thing i see is share/man/man1/ghc.1
06:55:30 <bitonic-work> yes
06:56:13 <applikativ> so it's not too hard to scrap even if you put it in /usr/local mostly you need to remember the 7 or 8 things in bin/
06:56:32 <bitonic-work> no, it's not
06:56:43 <bitonic-work> it's still *way* harder than `make unistall' :)
06:56:49 * merijn justs installs into ~/ghc
06:57:05 <applikativ> merijn: yes i think that's bitonic-work 's new plan
06:57:12 <bitonic-work> and by the way, the Haskell Platform installer installs yet some other place
06:57:15 <emmp> hey there, I'm trying to figure out the "$" operator, specifically I'm trying to figure out why the first two "in" clauses compile while the third doesn't:
06:57:23 <emmp> http://lpaste.net/92788
06:57:23 * bitonic-work 's plan is to get rid of Mac OS X as soon as possible :P
06:57:26 <applikativ> bitonic-work: on os x?
06:57:47 <bitonic-work> applikativ: yeah, it seems to put everything in some /Library and then symlinks
06:57:52 <applikativ> oh yeah. i have to say I don't approve of mzero's scheme, probably because of ignorance
06:57:55 <mauke> emmp: function application binds tighter than any operator
06:58:16 <mauke> emmp: 'a ? b c' parses as 'a ? (b c)' for any operator ?
06:58:33 <applikativ> he wants to make haskell platform like python and some other analogies, but this breaks the parallel with linux and impedes communication here
06:59:21 <emmp> so that means that fibs is evaluated before the function composition takes place?
07:00:15 <mauke> emmp: no
07:00:33 <mauke> that means you get a type error because your code is parsed the wrong way
07:00:38 <mauke> nothing is evaluated
07:00:54 <applikativ> bitonic-work: the os x platform installer does however come with an uninstaller script
07:01:11 <merijn> emmp: The last one is parsed "sum . (takeWhile (< 4000000)) . (filter even fibs)"
07:02:07 <emmp> so it fails because it tries to compose a function with a list
07:02:16 <applikativ> bitonic-work: in that script would probably have rooted out the stuff you wanted to uninstall a while back and has various arguments etc for this
07:02:34 <applikativ> bitonic-work: i meant, 'in fact, now that i think of it, that script ...'
07:02:57 <merijn> emmp: Correct
07:03:44 <merijn> emmp: As mauke mentioned function application binds tighter than anything*
07:03:59 <merijn> * - Unless that anything is record field updates, those bind tighter...
07:04:24 <mauke> also @ in patterns
07:04:33 <mauke> or does it?
07:04:40 <emmp> I don't understand "binding" in this context, according to LYAH explicit fun. application is right associative
07:04:45 <merijn> mauke: You can't have function application in patterns
07:05:08 <emmp> I'm trying to figure out how right association helps in this example.
07:05:09 <mauke> emmp: associativity only matters among operations of equal precedence
07:05:12 <merijn> emmp: Are you familiar with operator precedence from other languages?
07:05:22 <emmp> merijn, yes.
07:05:37 <merijn> emmp: Basically, function application has the highest precedence
07:05:46 <merijn> emmp: Higher than any operator, which includes $
07:05:49 <mauke> merijn: case x of x :+ Just y ->
07:06:01 <mauke> it's function application if you squint hard enough
07:06:21 <quchen> … meaning it's not function application? :s
07:06:23 <merijn> mauke: Anything is function application if you squint hard enough ;)
07:06:41 <mauke> well, what do you call the 'Just y' part?
07:06:50 <merijn> mauke: A pattern>
07:06:53 <emmp> ok, so by making the application explicit with $ I "separate" so to speak the function composition from the list it should be applied to.
07:06:54 <applikativ> bitonic-work: oh here is the script, too late, https://gist.github.com/mzero/1381399
07:07:14 <mauke> merijn: and 'f x' is an expression, but you can be more specific
07:07:25 <merijn> emmp: Yes, since $ is an operator (and the one with the lowest predence!)
07:07:34 <mauke> like, why does it parse as x :+ (Just y) and not (x :+ Just) y?
07:07:48 <emmp> great, thanks to all.
07:07:50 <merijn> emmp: (.) has a higher precedence than $, which is why things work out like that
07:08:07 <merijn> emmp: You can check the precedence by typing ":i ($)" in ghci
07:08:42 <merijn> emmp: The default (when it shows nothing) is infixl 9, function application has a precedence of 10
07:08:53 * hackagebot bdo 0.1.0.0 - Update CSS in the browser without reloading the page.  http://hackage.haskell.org/package/bdo-0.1.0.0 (ChrisDone)
07:09:18 <emmp> and $ has zero, it seems.
07:09:43 <emmp> I didn't know ":i", cool.
07:10:12 <merijn> emmp: Browsing the help of ghci can be enlightening, it has many surprisingly useful features :)
07:10:44 <emmp> I intend to read the ghci documentation at some point.
07:14:03 <bennofs> emmp: for a quick glance, try :help
07:14:30 <emmp> ok.
07:26:34 <merijn> hmm, what's the best way to represent a data type of 0, 1 or 2 elements? Should I just use a list and call it a day?
07:27:30 <mauke> Either a (Maybe (a,a))
07:27:52 <sm> Maybe (Either a (a,a))
07:28:23 <merijn> Lovely >.>
07:28:33 <bennofs> Either () (Either a (a,a))
07:28:59 <mauke> Either () (Either (a, ()) (a,(a,()))))
07:30:12 <bergmark> @hackage these -- merijn
07:30:12 <lambdabot> http://hackage.haskell.org/package/these -- merijn
07:31:36 <elliott> not quite
07:32:36 <bergmark> you could always define a Triether type
07:36:49 <dfan> Data.FingerTree, which has a data type with 1-4 elements, just explicitly uses One a | Two a a | etc., presumably for optimization, although it leads to a lot of boilerplate
07:38:42 <elliott> perhaps providing Traversable would ease some of that boilerplate
07:41:15 <hari_> Would like some tips/suggestions on this code http://lpaste.net/92790
07:45:37 <merijn> hari_: Array would be a nicer way to model the board than nested lists
07:45:44 <merijn> hari_: Lets you use two dimensional indices
07:45:55 <merijn> hari_: Thus simplifying your lookups/updates
07:46:16 <hari_> merijn, OK
07:46:49 <merijn> Additionally, lookups in Array are O(1) instead of O(n) :)
07:47:22 <hari_> merijn, thanks.
07:47:34 <merijn> hari_: Hopefully this will let you simplify "toggleColumn" as right now it's dreadfully complex
07:47:42 <elliott> {,Hash,Int}Map may be even better.
07:48:07 <hari_> merijn, yes, I know. I'll look at Data.Array.
07:48:33 <hari_> merijn, you mean toggleColumns? toggleColumn is the simple function
07:48:37 <merijn> elliott: It depends, I think Array makes more sense (semantically) if you're modelling a fixed NxM board
07:48:50 <merijn> hari_: eh, yeah :)
07:48:52 <quchen> hari_: Also scroll down all the way for automatic HLint suggestions. (You can also install HLint locally, it's pretty handy.)
07:49:08 <haasn> what's the logic of toggleColumns? in lights out, don't the four squares immediately orthogonal to the one you press flip their state?
07:49:09 * hackagebot git-annex 4.20130909 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130909 (JoeyHess)
07:49:15 <haasn> (in addition to the one you did press)
07:49:20 <hari_> merijn, yes, I have hlint installed.
07:49:22 <elliott> merijn: I am speaking from an efficiency pov
07:49:28 <hari_> merijn, I am going through the output now.
07:49:47 <merijn> elliott: Agreed, although I highly doubt that'll be relevant in this example :)
07:49:56 <haasn> I would honestly use lenses (and maybe tables) here, you could implement logic like that in a few simple lines :)
07:50:07 <quchen> elliott: Maps are more efficient for small datasets, is that what you're saying?
07:50:16 <merijn> haasn: Yes, but lenses can be horifically intimidating with their types when you start
07:50:23 <merijn> quchen: No, Map has less copying
07:50:37 <merijn> quchen: If anything it'll be even more efficient for big datasets
07:50:44 <haasn> something like toggle :: (Int,Int) -> Whatever -> Whatever; toggle pos = each.indices (\i -> distance i pos <= 1) %~ not
07:50:49 <merijn> quchen: Array has to copy everything, Map only log n entries
07:51:00 <quchen> merijn: Oh right, silly me.
07:51:00 <haasn> where distance (x,y) (z,w) = abs (x-z) + abs (y-w) -- or whatever
07:51:07 <elliott> yeah, copying an array you update all the time can suck
07:51:10 <merijn> haasn: Array already has update functions like that
07:51:11 <quchen> Secretly added ST s everywhere I guess ;-)
07:51:33 <haasn> merijn: fair enough
07:51:53 <merijn> haasn: Hell, having 2 dimensional indices is the main reason I suggested array :)
07:53:09 <hari_> haasn, that's the logic I implemented in the horrible toggleColumns function
07:53:15 <haasn> merijn: with tables you can have additional indices on the X and Y columns, so you could do something like foo^.with X (==) x -- to single out a column :)
07:55:01 <hari_> I figured out that using List was probably a bad idea to model the board
07:55:15 <hari_> But didn't know the alternatives much.
07:58:21 <merijn> hari_: Yeah, many people start out with lists like that, but it quickly starts to suck for two-dimensional things :)
07:59:17 <hari_> merijn, coming from Python, I found lists easiest to figure out in haskell (similar syntax etc)
08:06:07 <ocharles> haasn: fun lensism of the day! cache cacheKey action = use cacheKey >>= maybe ((cacheKey <?=) =<< action) return
08:06:25 <ocharles> Use an At-like thing as a cache :)
08:06:38 <ocharles> (where in this case the cache is assumed to be part of some MonadState)
08:07:15 <ocharles> i'm glad you made me try and go further with lens, it's a lot of fun
08:07:47 <haasn> I don't know why it surprised me that <?= exists
08:07:52 <haasn> I was only aware of ?~
08:07:55 <haasn> but that seems very useful :)
08:08:32 <haasn> that (>>=) is in the reader monad?
08:08:39 <ocharles> no, MonadState
08:08:41 <haasn> er disregard that
08:08:44 <ocharles> :)
08:08:44 <haasn> yeah
08:08:46 <haasn> I was looking at the wrong type signature
08:09:24 <haasn> oh, and I missed a (. I was trying to parse maybe (cacheKey <?=) =<<
08:09:26 <haasn> it makes sense now
08:09:28 <haasn> neat!
08:09:29 <haasn> but confusing :)
08:09:43 <ocharles> but netwire 5 + lots of lens use is starting to give me some really nice code. http://lpaste.net/92794 is a scene that has a grid of the grass tile, with another tile that slides accross it
08:10:05 <hari_> :t any
08:10:06 <lambdabot> (a -> Bool) -> [a] -> Bool
08:10:15 <ocharles> (I use that cache thing to only load the tileset once)
08:10:41 <edwardk> nice
08:11:29 <haasn> looks awesome
08:11:58 <haasn> my recent obsession has been with ‘tables’ as a way to store maps with multiple indices allowing reasonably efficient lookups :)
08:12:00 <edwardk> fmap P (liftA2 V2 (integral 0 . 10) 0)  can probably b liftA2 (P . V2) ...
08:12:01 <ocharles> yea, and I plan to calculate the deltas between render frames to work out exactly what needs redrawing - so if the player only moves, then you might just redraw the grass under their feet and their new location
08:12:18 <ocharles> edwardk: for some reason I can't get that to work. let me try again
08:12:21 <haasn> edwardk: (P .: V2)
08:12:40 <ocharles> ah yea, it's because of the two arguments and that composition generally being annoying
08:12:54 <edwardk> i just need to get haasn interested in using morton order so you can have a single index that 'just works'
08:13:01 <edwardk> ocharles: ah yeah thats what it is
08:13:20 <edwardk> that is all my pattern matcher found.
08:13:27 <edwardk> oh and you can replace the flip with ??
08:13:41 <edwardk>  flip foldMap [0 .. P (V2 24 18)]  becomes  foldMap ?? [0 .. P (V2 24 18)]
08:13:47 <ocharles> cool, that's much prettier
08:14:16 <ocharles> does ?? extend to multiple arguments? foo bar ?? baz $ quack == foo bar quack baz?
08:14:41 <edwardk> yes
08:14:42 <haasn> flip (foo bar) baz $ quack  (foo bar) quack baz
08:14:52 <ocharles> nice
08:14:53 <edwardk> :t (??)
08:14:54 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:14:58 <haasn> but not the other way, obviously; ie. foo ?? bar baz $ quack -- :)
08:15:11 <FreeFull> :t id ?? id
08:15:11 <lambdabot> ((a -> a) -> b) -> b
08:15:15 <edwardk> haasn: just keep using ??
08:15:22 <edwardk> foo ?? bar ?? baz $ quack = foo quack bar baz
08:15:24 <ocharles> haasn: foo ?? bar baz $ quack isn't foo quack bar baz?
08:15:30 <ocharles> oh, that's a bit ickierr
08:15:33 <FreeFull> :t id ?? id $ id
08:15:34 <lambdabot> a -> a
08:15:44 <edwardk> ocharles: foo ?? bar baz $ quack = foo quack (bar baz)
08:15:56 <ocharles> ah
08:16:01 <edwardk> ocharles: ?? is good at swapping the last two args
08:16:23 <edwardk> you can use it to smuggle an arg deeper, but that is an emergent property rather than its initial purpose
08:16:37 <hari_> hlint corrected http://lpaste.net/92795
08:16:39 <ocharles> yea, I think an explicit lambda will work nicer there
08:16:40 <edwardk> it also has th benefit of letting you elide parens around the args you move past =)
08:16:47 <Taneb> What's this about smuggling arms dealers
08:17:18 <ion> This was a nice Coq tutorial. https://www.youtube.com/playlist?list=PLDD40A96C2ED54E99
08:17:26 <edwardk> foo ?? bar takes a lot of arguments ?? baz does too $ quack  = foo quack (bar …) (baz ..)
08:18:15 <edwardk> but while a single (??) is often beautifying, multiple are an acquired taste, like excessively pointfree coe
08:19:40 <haasn> :)
08:20:46 <haasn> a good operator is signified by its ability to let you eliminate ugly parens en passant
08:20:53 <haasn> lens takes this to the extreme, naturally
08:21:05 <edwardk> heh
08:22:34 <flebron> What does "sequential" mean in     (<*>) :: f (a -> b) -> f a -> f b     -- | Sequential application.?
08:24:01 <edwardk> flebron: nothing
08:24:14 <edwardk> its a fluff word =)
08:24:18 <flebron> Alright :)
08:24:20 <S11001001> lol edwardk
08:24:25 <ion> ledwardk
08:24:36 <S11001001> flebron: the fs can't be flipped around and mean the same
08:25:03 <ion> “sequential; application”
08:25:06 <edwardk> :t (<**>)
08:25:07 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:25:19 <edwardk> is different than flip (<*>)
08:25:20 <haasn> I guess it distinguishes it from (<*>)'s evil twin; \f g -> flip id <$> g <*> f -- ?
08:25:22 <flebron> S11001001: Well application (($), if one wants) already does that, why sequential?
08:25:26 <edwardk> in that the 'effects' i f are sequenced left to right
08:25:27 <haasn> :t \f g -> flip id <$> g <*> f -- I hope I got that right
08:25:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:25:31 <haasn> I did!
08:25:56 <edwardk> but what that means if often not 'sequential'
08:26:10 <S11001001> flebron: applicative application, not the other.  haasn's got it
08:26:17 <ion> flebron: The action will execute the two applicative actions that came as parameters and apply the function resulting from the first one to the value resulting from the second one.
08:27:32 <flebron> So (thinking about this in monad terms) it returns an action which is the result of first running the first parameter's action, then the second parameter's action, and then taking the first parameter's result and applying it to the second parameter's result, and returning that as the result?
08:27:49 <ion> An example: negation :: Parser (Integer -> Integer); negation = negate <$ char '-' <|> pure id; nat :: Parser Integer; nat = read <$> many1 digit; int :: Parser Integer; int = negation <*> nat
08:27:54 <flebron> (Which would seem to make sense from the `ap` definition in McBride's paper)
08:28:18 <ion> flebron: That sounds right.
08:28:59 <flebron> Though to be honest my notion of "then" is still (>>=) :)
08:29:34 <ion> I don’t see anything wrong with thinking of it like that.
08:29:58 <flebron> Not all applicatives are monads :p
08:30:03 <ion> Applicative is more general than Monad but when both are implemented, the concept of “then” is the same concept for both.
08:50:08 <haasn> my notion of ‘then’ is *>
08:52:16 <niteria> a *> b == a >>= \_ -> b ?
08:53:53 <haasn> that's (>>), but (*>) and (>>) are expected to be the same
08:54:19 <haasn> x *> y is technically flip const <$> x <*> y
08:54:22 <haasn> if I got that right
08:54:26 <haasn> :t \x y -> flip const <$> x <*> y
08:54:27 <lambdabot> Applicative f => f a -> f b -> f b
08:54:29 <haasn> I did!
08:55:15 <ekipan> the source spells it const id, which is equivalent to flip const
08:57:30 <inkjetunito> do you often see newbies complaining here?
08:59:35 <ion> Complaining about what?
09:00:10 <inkjetunito> ion: the language
09:00:26 <ion> no
09:00:36 <haasn> I don't think I have. Most of the time, newcomers are more confused about having to unlearn their previous programming habits
09:00:44 <haasn> rather than complaining that Haskell isn't like them
09:00:49 <Taneb> Trolls complain, newbs ask questions :)
09:00:59 <haasn> but in general the newcomers I see here are genuinely interested in learning Haskell
09:01:01 <Ankhers> I vaguely remember one or two, could be trolls.
09:01:09 <haasn> yeah, you get obvious trolls from time to time
09:01:48 <Ankhers> Though, if I remember correctly, the trolls ended up learning things nonetheless.
09:01:50 <inkjetunito> i think Haskell is very pleasant to learn. perhaps it's just ripe enough or something
09:03:01 <Ankhers> I would love to ACTUALLY learn Haskell. I just don't have a real project to apply it to.
09:03:12 <applikativ> occasionally someone becomes dispirited and goes on the attack
09:03:31 <haasn> applikativ: I must be on during the wrong times :P
09:03:53 <applikativ> haasn: yes, i don't think it's common
09:04:01 <Ankhers> haasn: or the right times...
09:04:20 <haasn> Ankhers: do you do a lot of programming in general?
09:04:47 <Ankhers> haasn: Yes, I am a software dev. Currently doing c++ / ruby
09:04:59 <mm_freak> Ankhers: write the tools you use for for your C++/ruby development in haskell
09:05:00 <inkjetunito> compared to what i learned previously, the documentation has been good enough so far, the "main" implementation is in a very usable state and the introductions to the language are somewhat hype-free
09:05:20 <haasn> the way I really started learning Haskell was to just implement every single thing I'd otherwise have written in my previous ‘language of choice’ in Haskell instead
09:05:23 <mm_freak> Ankhers: if you're looking for a real project, you can try to write a small web page using a haskell web framework
09:05:30 <haasn> though if it's for work that might not be doable unfortunately
09:06:28 <Ankhers> mm_freak: I started doing the web thing a little while ago. Yesod, apparently GHC, had a bug on OSX 64bit... So That got delayed. Now I am attempting to decide which of the three 'main' web frameworks I should try.
09:06:32 <flebron> haasn: Same, and the previous language was Python.
09:06:39 <applikativ> Ankhers: i also think a way people slip haskell into some pre-established enviroment without confusing things, is little parser executables
09:07:23 <haasn> you could try WebGL game development using ghcjs, gloss and netwire :)
09:07:31 <applikativ> i mean, this is a fairly elementary sort of thing.
09:07:32 <mm_freak> Ankhers: if you can't decide write a small haskell program that selects one for you randomly =)
09:07:42 <Ankhers> lol
09:07:53 <haasn> mm_freak: instance Random Project where ...
09:08:05 <mm_freak> i'm serious…  when i can't decide i just toss a coin
09:08:13 <inkjetunito> haasn: does haskell compile into JS nicely?
09:08:20 <haasn> inkjetunito: for some meaning of ‘nicely’
09:08:30 <Ankhers> We do 'code kata' from time to time here. I try and do most exercises in Haskell
09:08:39 <mm_freak> just to try one of them and see how far i get is usually much faster than to fail with an educated guess
09:08:49 <inkjetunito> haasn: i mean for not having the compiler to reimplement the whole language in js
09:08:51 <haasn> inkjetunito: here is pong in .js: http://hdiff.luite.com/gloss/pong/out.js
09:08:53 <Ankhers> fair enough.
09:08:54 <applikativ> i haven't noticed it lately but it used to happen a lot that there were parsec question that were actually aimed at some work project where the surroundings were in God knows what Edomite programming language
09:08:58 <inkjetunito> haasn: thanks
09:09:21 <ekipan> them names
09:09:27 <haasn> inkjetunito: well, this one was generated with ghcjs which is just a backend / extension of GHC itself, so as a result it can compile almost anything GHC can compile
09:09:32 <haasn> (the exception being FFI stuff, obviously)
09:09:39 <mm_freak> inkjetunito: haskell requires a run-time system, which does need to be written in javascript in this case
09:09:43 <mm_freak> inkjetunito: there is no way around that
09:09:59 <inkjetunito> haasn: the output looks reasonably small
09:10:11 <applikativ> inkjetunito: ghcjs is the most grandiose of the hs/js schemes around. there are other simpler things
09:10:26 <haasn> inkjetunito: compared to a pong game written in ‘normal’ js? :)
09:10:50 <inkjetunito> haasn: heh. no.
09:10:57 <haasn> wait a minute, that file has 93706 lines
09:11:00 <haasn> you call this reasonably small? :)
09:11:16 <haasn> to be honest, I'm surprised it runs at all (see http://hdiff.luite.com/gloss/pong/ )
09:11:21 * applikativ looks for a Fay or Elm 'pong'
09:11:29 <haasn> elm should be much smaller
09:11:36 <luite_> later versions make smaller code
09:11:37 <applikativ> yeah i head they can compile gloss
09:11:50 <haasn> with fay, you don't get the nice things like lenses ;)
09:11:57 <luite_> also i'm going to commit a non-concurrent runtime soon-ish
09:11:59 <haasn> or FRP
09:12:02 <mauke> I wonder what happens if you run that through the closure compiler
09:12:05 <applikativ> oh is that out of the question in fay?
09:12:05 <luite_> that gloss example is quite old
09:12:27 <haasn> applikativ: I'm not sure, but fay has no type classes and also lacks a lot haskell extensions
09:12:36 <haasn> you could probably implement basic lenses ‘manually’
09:12:50 <luite_> ouch
09:13:10 <luite_> haasn: that pong out.js file is from before we had the ghcjs optimizer in place :)
09:13:15 <applikativ> no Functor in fay?  lenses (narrowly construed) only need rank2types, no?
09:13:16 <haasn> luite_: update it!
09:13:16 <luite_> it's already a lot better
09:14:04 <luite_> haasn: yeah i'll go over the old examples soon, ghcjs release is in a few weeks and i'm fixing other stuff first
09:14:24 <haasn> applikativ: https://github.com/faylang/fay/wiki/Why-fay-does-not-currently-support-type-classes
09:14:37 <luite_> also i have a non-concurrent runtime ready soon, which will make code more compact
09:14:41 <applikativ> it is plain that in the long run, everthing, even the children, will be made of javascript.
09:14:47 <mm_freak> you can have FRP in fay, but it won't look as nice
09:15:20 <haasn> mm_freak: yeah, and you'll have to implement it from scratch - whereas Elm has it ‘built in’
09:15:30 <haasn> which is why I said elm would be smaller :P
09:16:23 <mm_freak> not from scratch
09:16:24 <luite_> elm mostly has the bindings with dom/canvas built in, but haskell already has more advanced graphics libs like diagrams
09:16:40 <luite_> with haskell you'd have to build your own active html elements etc
09:16:44 <mm_freak> you can take netwire, rewrite the classy stuff into nonclassy stuff and compile it
09:16:52 <mm_freak> although i'm not sure whether fay supports GADTs
09:17:07 <mm_freak> in any case GHCJS is what i'd choose
09:17:10 <luite_> i think it does
09:17:23 <luite_> but it doesn't know about any dictionaries in them
09:18:08 <mm_freak> probably because it simply doesn't have dictionaries
09:18:15 <mm_freak> i guess elm has the same limitation
09:18:54 <paolino> hi, what is the problem with pattern bindings and existentials that makes ghc brain explodes ? The possibility of recursive definitions ?
09:19:11 <levi> I don't think any of the 'compile a functional language to js' implementations that aren't built with the help of a full haskell compiler have typeclasses.
09:19:18 <applikativ> well, i think ghc only pretends that its brain exploded
09:19:24 <luite_> mm_freak: fay has some partial workaround, using dynamic dispatch on the values
09:19:39 <levi> They mostly have nicer record types, though.
09:20:19 <paolino> applikativ, I had to clean the desk
09:20:20 * Lethalman is using ghcjs for rewriting a static website as single page js.... working very well, using blaze-html, network and other stuff seamlessly
09:20:21 <levi> Except fay, which has to pass the Haskell type-checker.
09:20:22 <luite_> mm_freak: so you can implement a subset of typeclasses, for example Eq a where (==) :: a -> a -> Bool, you can implement that by attaching some (==) method to (a prototype) of a in JS
09:21:44 <luite_> mm_freak: of course it's not quite the same, dispatch based on value instead of type, but some very common/useful typeclasses can be done this way
09:23:07 <applikativ> paolino: ha!
09:23:08 <levi> From what I gather, the fay guys are working on using the 'Typing Haskell In Haskell' package to implement closer to full Haskell98 features.
09:23:32 <luite_> lethalman also has submitted a GHCJS patch that reduces the code size a bit more :) (but it still has a bug so i cannot yet merge it)
09:25:53 <luite_> levi: yeah although i'm not sure if that's the way they want to go now
09:26:06 <luite_> there was some talk about implementing a more modern algorithm
09:26:47 <luite_> although i'm not sure personally if it wouldn't make more sense then to just use ghc's typechecked AST then
09:27:08 <mm_freak> luite_: i suppose GHCJS just compiles the core language, so it doesn't have any of those issues
09:27:10 <luite_> haven't really paid much attention to the discussions at zurihac last week
09:27:16 <luite_> mm_freak: yeah, STG
09:27:44 <luite_> but that means that some code you get is less compact, or looks less like the original haskell
09:27:50 <bitonic-work> are there functions to read ACII data in a ByteString somewhere?  specifically Word16/32 in hex notation
09:28:05 <luite_> bitonic-work: there's base16-bytestring
09:28:41 <bitonic-work> luite_: thank you!
09:28:53 <luite_> bitonic-work: and binary/cereal to get the stuff out of the decoded bytestring
09:29:08 <bitonic-work> luite_: right, the problem with `binary' is that it works with lazy bytestrings
09:29:18 <bitonic-work> and I didn't want to pull `cereal' in
09:29:59 <luite_> bitonic-work: wrapping a strict ByteString into a lazy one is not an expensive operation
09:30:38 <luite_> bitonic-work: but for simple things the functions in Data.ByteString.Builder will work
09:30:42 <luite_> int h bytestring pacakge
09:31:33 <luite_> only writing though, i think...
09:31:39 <bitonic-work> yeah
09:35:52 <lingxiao> hey has anyone programmed extensively with arrows? or have preference for it for some reason? if preference is the right word
09:36:23 <lingxiao> and would like to asnwer a few general question from me? :D
09:38:07 <quchen> Don't ask to ask, ask.
09:38:55 <lingxiao> ok cools, what are some common computations that can be descirbed using arrows that cannot be described using monads?
09:39:07 <lingxiao> I know it's more general than monads, but what are some concret examples?
09:39:34 <lingxiao> I'm reading the original Chalmers paper on it mind you, but would like more examples
09:39:39 <quchen> I don't think they're more general, they're just different. You can't make a Monad instance from every Arrow.
09:39:53 <quchen> (Actually you can't make a Monad instance for any arrow because the kinds don't match.)
09:40:43 <quchen> One basic example for "something" arrows can do that monads cannot is a State object that tracks whether the user has modified the state yet.
09:41:07 <applikativ> paolino: oh i realized i meant to link http://lpaste.net/92798
09:41:22 <quchen> Monads can't capture that because in (>>= f) the "f" is fully generic, and the monad can't react to "case <f modifies>".
09:42:05 <applikativ> paolino: if you consider the binding via Foo made at the top level, its pretty clearly insane
09:42:44 <quchen> Some FRP libraries rely on arrows, but I haven't used them. That's probably the only somewhat wide-spread use of Arrows, at least as far as I know. Many people think Arrows are broken anyway and stay away from them.
09:43:01 <applikativ> quchen: that you can make an arrow instance from every monad, but not vice versa, means they're more general, on one way of understanding 'general'
09:43:18 <applikativ> or am i in a muddle
09:44:36 <levi> I think at least one of the XML packages uses arrows.
09:44:44 <quchen> applikativ: You can take any Monad and make Kleisli arrows out of that.
09:44:55 <applikativ> i think those are Kleisli arrows though, in the xml libs
09:44:59 <donri> levi: hxt
09:45:00 <applikativ> quchen: right
09:45:06 <quchen> applikativ: Similarly, monads aren't more general than functions because you can take any function and make a monad out of it (Reader).
09:45:11 <donri> levi: but it's really a monad
09:45:23 <applikativ> if so then the xml arrows don't show 'arrows are more general'
09:45:59 <quchen> applikativ: But I guess you could also argue the other way round somehow. :-D
09:46:09 <applikativ> its the ones that cant be expressed equivalently by Kleisli m a b that are 'more general'
09:47:04 <applikativ> quchen: is that analogy function == monad ; monad == arrow right?
09:47:10 <quchen> Sort of, yes.
09:47:13 <applikativ> that should not be == sorry
09:47:23 <quchen> For suitable (==) :-)
09:47:25 <donri> btw if every monad can be made an arrow and arrow is equivalent to applicative+category, does that mean any applicative can be upgraded to a monad via a category instance?
09:47:41 <elliott> no, that just upgrades them to an arrow
09:47:43 <elliott> (modulo some laws)
09:47:47 <quchen> applikativ: Another way of looking at it: Kleisli is not an instance of Monad.
09:48:00 <donri> elliott: ooh right. duh.
09:48:05 <donri> got that backwards there.
09:48:42 <shachaf> Kleisli m a is an instance of Monad!
09:48:48 <quchen> Oh?
09:48:50 <shachaf> (When m is.)
09:49:36 <shachaf> Well, maybe not *is* an instance.
09:49:40 <shachaf> But could be.
09:49:40 <donri> hm i guess what i actually meant was that any monad can be expressed as applicative plus category? is that true?
09:49:51 <shachaf> donri: Where did "monad" get into it?
09:50:16 <applikativ> quchen: Kleisli m a is an instance of monad, no? Kliesli m a b ~ ReaderT a m b
09:50:24 <donri> shachaf: because any monad can be expressed as arrow?
09:50:59 <applikativ> oh shachaf has responded to quchen
09:52:27 <quchen> applikativ: Hm.
09:53:29 <applikativ> man all these libraries in base should be thrown out; really obvious thinks like adding deriving (Show, Eq, etc.) to Identity are missing
09:54:01 <donri> applikativ: but base doesn't export any Identity, does it?
09:54:02 <quchen> applikativ: Send a patch? Sounds like nobody bothered adding that yet
09:54:09 <applikativ> so of course there's no monad instance for Kleisli m a, but this is in fact *morally* required if ophans are to be avoided
09:54:29 <applikativ> donri: right, i shouldn't have mentioned base, I was thinking of transformers
09:54:34 <lingxiao> quchen: wait woa so now I'm a little confused, in this paper, it says:
09:54:44 <donri> honestly i kinda want an Identity in base
09:54:51 <donri> there's a hidden Id in Traversable :p
09:54:52 <lingxiao> "for any monad m, functions of type a -> m b are poential arrows"
09:55:03 <quchen> donri: There are multiple Id hidden in GHC ;-)
09:55:09 <lingxiao> so I guess that means not all function of type a -> m b are necessarily arrows?
09:55:11 <donri> i can imagine
09:55:18 <donri> but it does export Const ...
09:55:22 <applikativ> yes this is nonsense, and the constant and identity functores in lens should be scrapped
09:55:30 <geekosaur> lingxiao, `m` is not something magic all by itself
09:56:00 <donri> oh dear and transformers *also* has a *separate* Constant
09:56:00 <applikativ> donri: i mean, supposing a Identity in genuine base, to which i was ineptly assimilating transformers
09:56:03 <geekosaur> if you don;t have an additional constraint it could represent any type constructor that can be parameterized by an additional type
09:56:05 <applikativ> of course it does
09:56:10 <quchen> lingxiao: Yes, for any Monad m, you can create a Kleisli arrow, i.e. "instance Monad m => Arrow (Kleisli m)", where Kleisli m a b = a -> m b.
09:56:12 <lingxiao> geekosaur: sorry could you expand on that? I'm sick and am having trouble understanding super terse english
09:56:18 <geekosaur> *many* of those are monads, but not all
09:56:43 <geekosaur> example: unless you have an additional constraint, I can use Data.Set as `m`
09:56:46 <geekosaur> which is not a monad
09:56:58 <geekosaur> (well, is not a Monad, because of the Ord constraint)
09:57:55 <applikativ> that a -> m b is an arrow ('in a and b' so to speak) is a way of saying m is a monad ; only to say it's an arrow, you have to wrap it it
09:58:04 <quchen> "All Monads are Arrows" means that given a Monad instance, you can write an Arrow instance. Similarly for "All Arrows are Monads". It is true that there are *some* Arrows you can use to write a Monad instance (Kleisli), but in general you can't.
09:58:25 <shachaf> Also you should forget about Arrow because it's a bad class.
09:58:40 <shachaf> That's the true path to long-term happiness.
09:58:40 <applikativ> ah the arrow trolls are here
09:58:42 <donri> i recently had to add a dependency on transformers *just* for runIdentity to get a safe "singleton" traversal, that felt silly
09:59:02 <donri> (ie. head or fromJust would have worked just as well, but didn't feel right)
09:59:03 <lingxiao> so in other words arrows is not a superclass to monads like functor is to applicative
09:59:52 <lingxiao> shachaf: yeah all the arrow stuff look a little excessive to me but I dont really trust my judgement, and I've seen people use it a some, like Gabriel Gonzales
09:59:53 <applikativ> arrow is a fine class its that classes are no good; i realized this studying Frank for a bit
10:00:06 <quchen> lingxiao: Yes, Arrows are not a superclass of Monads (and can't be made one).
10:00:23 <lingxiao> and reading through this paper on YAMPA, which is an FRP DSl, they talk about arrows first
10:00:35 <applikativ> the usual complaint 'but my would be arrow doesnt realize arr' is enforced like mad by the syntax of Frank
10:00:36 <lingxiao> quchen: ok nice thanks for clearning that up
10:00:50 <quchen> applikativ: Classes are no good? Waitwaitwait.
10:01:07 <applikativ> quchen: of course i don't think that
10:01:19 <lingxiao> So if I want to understand FRP in and out, and want to use a well maintained, usable FRP library
10:01:21 <applikativ> it's just that the arrow idea doesn't fit too well with the whole system.
10:01:31 <lingxiao> which one should I pick, would they be the same llibrary
10:01:46 <quchen> lingxiao: There are also non-arrow FRP libraries.
10:01:58 <quchen> (Which I know nothing about. Just mentioning it.)
10:02:10 <joelteon> > foldl1 f [a,b,c,d]
10:02:11 <lambdabot>   f (f (f a b) c) d
10:02:11 <lingxiao> quchen: I know there's reactive banana, and a few others..
10:02:14 <applikativ> but the Frank language makes  'everything an arrow' to put it with extreme crudity
10:02:16 <joelteon> > foldr1 f [a,b,c,d]
10:02:18 <lambdabot>   f a (f b (f c d))
10:02:31 <lingxiao> but word yes, anyone else has played with FRP and would like to volunteer an answer?
10:02:53 <lingxiao> applikativ: can I ask what this "frank language" is all about?
10:03:45 <applikativ> lingxiao: yet another experimental with a fancy modern effect system
10:04:15 <lingxiao> applikativ: ah and it uses arrows alot I take it, what's your criticism against it?
10:04:25 <hpaste> cocool pasted “byorgey hw” at http://lpaste.net/92799
10:04:26 <fl00r> join /##freebsd
10:04:28 <cocool> I'm working through byorgey's homeworks in my spare time for some Haskell practice, but I've hit a snag. insert keeps stomping on old values rather than going deeper into the tree, and I'm not sure why.
10:04:46 <n-dolio> I don't see how frank would solve the problem of your arrow-like thing not having arr.
10:04:55 <applikativ> lingxiao: https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/TFM.pdf http://hackage.haskell.org/package/Frank
10:04:55 <n-dolio> Other than that it doesn't support such things, and is deficient for such constructs.
10:05:11 <n-dolio> If it, indeed, forces that things have arr.
10:05:36 <lingxiao> ah ok haha thanks!
10:06:01 <applikativ> everything a -> b is already an effect and can be subsumed under a [console, tell-mom, etc] b
10:06:08 <applikativ> and compose with it
10:07:04 <n-dolio> Okay. Then it is a system that cannot represent arrow-like things that lack arr.
10:07:30 <applikativ> right, exactly, it has the same constraint that the Arrow class has
10:07:55 <applikativ> n-dolio: oh i see, you misunderstood how i was intervening n
10:08:05 <n-dolio> Well then it sucks for anyone who has an arrow-like thing that doesn't support arr.
10:08:23 <applikativ> yeah Frank sucks for them too
10:08:31 <applikativ> only Frank doesn't suck
10:08:48 <applikativ> therefore their Arrow trolling, which is also Frank trolling, is empty
10:10:00 <n-dolio> Whose arrow trolling? The people who want to do things almost like Arrow, except that arr completely screws the situation?
10:10:11 <applikativ> of course good luck getting compositions like bip :: a [console] b; bop :: b [maybe] c; bipbop :: a [console, maybe] c going
10:10:34 <skypers> hey
10:10:45 <skypers> where does cabal put apps on linux per default?
10:10:49 <skypers> I’ve installed something
10:10:49 <applikativ> n-dolio: there are such people, who think there is no actual idea in the arrow class
10:10:51 <skypers> I can’t run it
10:10:57 <skypers> it says it doesn’t exist
10:11:07 <mauke> ~/.cabal/bin
10:11:17 <elliott> there's an idea to Arrow, it's just not a terribly great one.
10:11:35 <applikativ> elliott: why is it not great?
10:11:40 <skypers> thank you mauke
10:11:50 * applikativ invites n-dolio to watch the fud
10:11:52 <hpaste> cocool annotated “byorgey hw” with “byorgey hw (annotation)” at http://lpaste.net/92799#a92800
10:12:20 <elliott> you pay the cost of the incredibly awkward tuples & sums programming style (especially when working with GADTs etc. where you basically have to use unsafeCoerce a lot), without actually gaining the advantages you could in terms of optimisation and flexibility.
10:12:29 <elliott> though if you're going to pre-brand it as FUD I don't know why I bother
10:12:41 <applikativ> elliott: the tuples are indeed hopeless
10:13:51 <joelteon> @hoogle a -> [a -> a] -> a
10:13:52 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:13:52 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:13:52 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:14:02 <joelteon> ok
10:14:08 <applikativ> but again, they have to do with fitting an idea into a particular programming language
10:14:23 <Kaini1123> How can I lift f :: IO a -> IO b to f' :: MyMonad a -> MyMonad b (assuming IO at the bottom of MyMonad's monad stack)
10:14:26 <joelteon> oh that's just foldr ($)
10:14:35 <jfischoff> foldr (.)
10:14:45 <jfischoff> maybe both ...
10:15:15 <shachaf> Kaini1123: You cannot.
10:15:27 <jfischoff> heh foldr ($)
10:15:58 <lingxiao> elliot: what do you mean by "idea to arrow", as in "potimisation and flexibility" as you said later?
10:16:27 <lingxiao> or do you mean optimisation and flexibility is needed over the monad, but the arrow implementation is cumberson?
10:16:34 <lingxiao> cumbersom*
10:16:57 <ifthenelse> Using optparse-applicative, how do you assign a default value if one is not supplied?
10:17:26 <Kaini1123> Hm, so how am I supposed to use Database.PostgreSQL.Simple.Transaction.withTransaction :: Connection -> IO a -> IO a in anything that's not IO-only?
10:18:09 <joelteon> ifthenelse: 'value'
10:18:22 <joelteon> option ( long "foo" <> short 'f' <> ... <> value "default" )
10:18:44 <ifthenelse> like, strOption          ( long "hello"         <> metavar "TARGET"         <> value ""            <> help "Target for the greeting" )
10:18:52 <ifthenelse> ?
10:18:54 <joelteon> yes
10:18:58 <ifthenelse> Thank you!
10:20:55 <Twey> cocool: Your problem doesn't occur for me
10:21:18 <Twey> cocool: Leaf (LogMessage Info 1 "Nothing to report") (Node Leaf (LogMessage Info 4 "Everything normal") (Node Leaf (LogMessage Info 6 "Completed armadillo processing") Leaf))
10:21:41 <cocool> Weird.
10:22:02 <cocool> Maybe my ghci is misbehaving
10:22:22 <Twey> (I just copy/pasted your code and defined data MessageType = Info deriving (Show, Eq); type TimeStamp = Int)
10:22:31 <Twey> Perhaps you forgot to reload the file?
10:22:49 <Twey> Or maybe your parseMessage isn't working as expected
10:23:21 <quchen> Is there any reason to have a separate module/type for the free Applicative when Applicative => Monad?
10:23:32 <quchen> I just saw it in the "free" package
10:23:45 <cocool> D'oh.
10:23:53 <cocool> Now it works, Twey. I guess I forgot to reload :D
10:23:57 <Twey> Heh.
10:24:01 <cocool> Thanks for restoring my sanity, at least
10:24:03 <haasn> quchen: you mean WrappedMonad?
10:24:04 <Twey> Happens to everyone
10:24:24 <quchen> haasn: No, "Ap" from "Control.Applicative.Free".
10:24:59 <haasn> oh, I see what you mean now
10:25:00 <danr> quchen: the free applicative /= the free monad
10:25:05 <haasn> yeah
10:25:16 <quchen> danr: Oh?
10:25:48 <quchen> danr: So in particular the "free" Applicative you can make using ap/return from the "free Monad" is not the same as the "free Applicative"?
10:25:55 <arkeet> correct
10:26:13 <danr> quchen: you cannot make a Monad instance for the free applicative of f, called Alt f in this package
10:26:15 <quchen> Glad I asked. Also I'm confused now. :-)
10:26:35 <arkeet> the free monad doesn't satisfy the universal property of the free applicative.
10:26:47 <ReinH> hai
10:26:49 <elliott> "free X" varies widely depending on what X is.
10:26:52 <elliott> for instance, the free monoid is a list.
10:27:21 <elliott> calling the free monad Free was kind of a bad idea.
10:27:26 <arkeet> true
10:27:35 <shachaf> I've said so before, but no one listens.
10:27:50 <quchen> elliott: That one also somewhat confuses me. Free (f (Free f a)) is not the same as "FreeCons f (Free f a)" or something, which I would recognize as a list
10:28:03 <ifthenelse> With optparse-applicative, can you have requirements in groups? For instance, if you enable "--cheese", you need to enter "--flavor" flavors, but if you enter "--dogs", you need to enter "--color"?
10:28:10 <arkeet> quchen: the latter is a kind error.
10:28:21 <shachaf> quchen: It's a list in the category of endofunctors!
10:28:26 <arkeet> haha
10:28:41 <ReinH> hah
10:28:42 <elliott> hmm, the free monoid and free monad show the relation between monoids and monads cutely.
10:28:49 <elliott> A* = A^0 + A^1 + A^2 + ...
10:28:55 <elliott> F* = F^0 + F^1 + F^2 + ...
10:28:56 <ReinH> I find it slightly strange that I understand cofree comonads but don't fully understad free monads
10:29:09 <danr> elliott: oh, that's elegant
10:29:14 <arkeet> Free f a = a^0 + a^1 + a^2 + ...
10:29:15 <joastbg> i'm trying to parse a date, readTime defaultTimeLocale "%F" "1998-06-03", and then i need to import Locale, but it says its member of hidden package
10:29:16 <arkeet> er
10:29:17 <arkeet> no.
10:29:23 <shachaf> A regular list of A: 1 + (A * (1 + (A * ...
10:29:31 <arkeet> not quite.
10:29:33 <arkeet> yeah.
10:29:33 <ReinH> shachaf: cofree [A]
10:29:36 <arkeet> what shachaf is about to say.
10:29:37 <joelteon> Is there anything like rex that's designed for search-and-replace rather than just search?
10:29:42 <quchen> elliott: Ah, so I can see the Free Monad as a type-level list of sorts?
10:29:43 <shachaf> arkeet: I'll let you say it.
10:29:46 <arkeet> =(
10:29:59 <levi> joastbg: Did you add the package to your cabal file?
10:30:02 <arkeet> Free f a = a + f (a + f ...)
10:30:24 <shachaf> tharkeet
10:30:27 <quchen> arkeet: Oh right, I forgot about the "Pure" part.
10:30:36 <quchen> Starting to make sense to me now.
10:30:49 <joastbg> I need to add haskell98 package, you mean in cabal file? i just use ghci now, playing around
10:31:07 <applikativ> joastbg: you probably dont want to do that
10:31:15 <applikativ> joastbg: what is telling you you need to?
10:31:27 <danr> arkeet: I think it's more like Free f a = a + f a + f^2 a + f^3 a + ...
10:31:42 <arkeet> danr: only if f distributes over +
10:31:48 <shachaf> Note that the "category of endofunctors" is a monoidal category (with functor composition).
10:31:59 <shachaf> It's not exactly the usual kind of product.
10:32:00 <joastbg> applikativ: I found a link on the web, http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html, but I simply need to parse a string to a date "YYYY-MM-DD"
10:32:01 <donri> ifthenelse: ((,) <$> cheese <*> flavor) <|> ((,) <$> dogs <*> color)  -- possibly
10:32:05 <ReinH> arkeet: you're describing Cofree f a
10:32:15 <arkeet> danr: e.g. Free (Const r) a = a + r, not a + r + r + r + ...
10:32:19 <arkeet> ReinH: nope
10:32:25 <ReinH> arkeet: ... yep.
10:32:27 <arkeet> nope
10:32:45 <ReinH> sure you are
10:32:50 <danr> Free (Const r) a = a + Const r a + Const r (Const r a) + ..
10:32:53 <arkeet> I'm simply expanding the recursion in Free f a = a + f (Free f a)
10:32:59 <applikativ> joastbg: you can add     Default-Language: Haskell2010
10:32:59 <arkeet> danr: that's what I'm saying is false!
10:33:15 <applikativ> joastbg: or rather Haskell98
10:33:16 <elliott> arkeet: given that F is covariant shachaf's and my expressions are equivalent, afaict
10:33:27 <elliott> oh, I guess the problem is that the +s give you "tags".
10:33:31 <elliott> so never mind.
10:33:39 <arkeet> the problem is f doesn't have to preserve coproducts.
10:33:53 <joastbg> applikativ: will this have any other effects, when used in a larger program?
10:34:08 <danr> arkeet: gotcha! thanks
10:34:36 <applikativ> adding 'haskell98'? I'm not sure what all the effects are -- it used to be clearer in the mind when ghc was making the transition
10:34:47 <applikativ> not that it quite made the transition, as i understand
10:35:02 <ReinH> arkeet: for instance, [1 :< [ 2 :< []]] :: Cofree [Int]
10:35:06 <applikativ> joastbg: i'm just investigating why it wants it
10:35:26 <arkeet> ReinH: sure. but that's not what I'm describing.
10:35:28 <arkeet> + is not *
10:35:32 <shachaf> ReinH: Cofree [Int] is a kind error.
10:35:36 <arkeet> heh.
10:35:48 <ReinH> Cofree [] Int :p
10:35:53 <danr> arkeet: since Roll (K r (Free (K r) a)) = Roll r
10:35:58 <joastbg> applikativ: Yes, it confuses me a bit, that it's kind of a mystery to parse a date, and why as you say, an older spec is needed
10:36:00 <arkeet> Free f a = a + f (Free f a).
10:36:02 <dissipate__> how out of date is the book 'learn you a haskell'?
10:36:02 <shachaf> OK, but Cofree doesn't even have +
10:36:05 <applikativ> joastbg: so far its looking like this little files just have the usual problems, e.g. 'import Locale' should be 'import System.Locale'
10:36:06 <arkeet> Cofree f a  = a * f (Cofree f a)
10:36:19 <arkeet> dissipate_: it's good.
10:36:35 <arkeet> it's current on what it covers.
10:36:36 <dissipate__> arkeet: but are the concepts and code samples up to date?
10:36:40 <ReinH> arkeet: ok
10:36:42 <applikativ> joastbg: which is the one that failed?
10:37:01 <ReinH> dissipate__: close enough to be useful
10:37:16 <dissipate__> ReinH: cool
10:38:01 <joastbg> applikative: it works now, using readTime defaultTimeLocale "%F" "1998-06-03" :: UTCTim
10:39:13 <quchen> arkeet: So Cofree is Free with a product instead of sum?
10:39:23 <joastbg> applikativ: typo(s), it works now readTime defaultTimeLocale "%F" "1998-06-03" :: UTCTime
10:39:35 <applikativ> what did you have to add joastbg ?
10:40:01 <arkeet> quchen: Cofree is Free with a product instead of coproduct.
10:40:05 <arkeet> =)
10:40:26 <joastbg> applikativ: I added: Data.Time.Format and System.Locale
10:40:27 <quchen> And coproduct is the inverted Pi I was always wondering about why it exists in Latex. ;-)
10:40:52 <quchen> arkeet: I'll just bite: "Sums are coproducts?"
10:41:33 <shachaf> Well, Cofree is also, like, codata and stuff, man.
10:41:40 <shachaf> Yes, sum types are coproducts.
10:41:41 <applikativ> joastbg: oh ok.  the longer name for Locale is the only haskell98/2010 issue so far then; the regex and time libraries may have subtle changes though, as you go through these
10:41:46 <shachaf> And product types are products! Isn't it great?
10:42:05 <quchen> Can't judge that.
10:42:09 <quchen> Probably yes.
10:42:30 <quchen> So what's a "product type" as opposed to a "product"?
10:42:33 <joastbg> applikativ: thanks for your help, I didn't find any useful info on the web about this, but now it works
10:42:54 <mmaruseacph42> quchen: a type which is isomporphic to a tuple
10:43:19 <mmaruseacph42> consider for example the type (Bool, Bool) -- it has exactly 4 values (excluding the bottoms)
10:43:24 <quchen> mmaruseacph42: Yes, that's what I understood as a tuple so far.
10:43:24 <levi> applikativ: His example works after importing Data.Time.Format, Data.Time.Clock, and System.Locale
10:43:31 <applikativ> joastbg: in general the 'haskell 98' problem is really the 'hierarchical module' problem, with old tutorial material; you need Control.Monad, not Monad, Data.List not List, its usually mechanical
10:43:31 <mmaruseacph42> that 4 is the product of 2 values of the first Bool and 2 values of the second one
10:43:32 <quchen> But now shachaf distinguished between product types and products.
10:43:50 <mmaruseacph42> aah, products in the cat theory sense
10:43:51 <shachaf> Well, a categorical product.
10:44:13 <mmaruseacph42> I'll listen to other speak about this since I'm not guru in category theory
10:44:31 <quchen> shachaf: So "A categorical product in Hask is a product type" would be the full statement?
10:44:42 <shachaf> I would reverse it.
10:44:46 <quchen> Or "is a category that has tuples as objects"
10:44:57 <shachaf> I don't know what that second one means.
10:45:55 <shachaf> But (A,B) is a product of A and B (disregarding ⊥ etc.).
10:46:07 <shachaf> (There might also be other products.)
10:46:17 <shachaf> Maybe I should say: ((A,B),fst,snd) is a product of A and B.
10:46:37 <shachaf> OK, that notation is confusing.
10:46:58 <haasn> ⟨(A,B),fst,snd⟩
10:47:01 <joastbg> applikativ: I will keep this in mind
10:47:12 <elliott> curry/uncurry is cooler than fst/snd
10:47:38 <arkeet> what i want to understand is how Yoneda works even on non-functors.
10:47:39 <ion> @type uncurry const
10:47:39 <shachaf> How does curry/uncurry get into it?
10:47:40 <lambdabot> (c, b) -> c
10:48:10 <quchen> (A,B) is the product category of A and B, i.e. for each 'a' from A and 'b' from B it has an object (a,b). Correct so far?
10:48:16 <applikativ> π1/ π2 are cooler than curry/uncurry
10:48:31 <elliott> curry/uncurry let you both construct and destruct pairs.
10:48:36 <haasn> π₁/π₂ are cooler than π1/π2
10:48:37 <quchen> (... plus appropriate morphisms)
10:48:46 <elliott> you can say p is a product if you have (p a b -> c) <-> (a -> b -> c)
10:48:52 <elliott> and curry/uncurry are the two halves of that isomorphism.
10:48:59 <arkeet> no, elliott.
10:49:04 <shachaf> elliott: But then you have to have a definition of exponentials.
10:49:09 <elliott> well, yes.
10:49:11 <elliott> I mean in Haskell, mainly.
10:49:12 <shachaf> Usually you define exponentials in terms of products.
10:49:18 <arkeet> (x -> p a b) <-> (x -> a, x -> b)
10:49:23 <arkeet> where the latter (,) is just cartesian product.
10:49:25 <shachaf> arkeet++
10:49:57 <shachaf> And for coproduct: (c a b -> x) <-> (a -> x, b -> x)
10:50:09 <arkeet> :t either
10:50:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:50:20 <applikativ> well, this has gone off topic in a not too unfamiliar, but of course I'm not saying that
10:50:28 <applikativ> too unfamiliar way rather
10:50:46 <skypers> hi there
10:50:52 <applikativ> hi there skypers
10:51:08 <shachaf> :t (&&&)
10:51:09 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:51:14 <arkeet> shachaf: explain how Yoneda can get us a Functor out of nothing.
10:51:14 <skypers> http://t.co/Dv33Ej5SNF is here my new portfolio, written with leaf, a haskell program I wrote (already in hackagedb)
10:51:17 <skypers> :)
10:51:27 <shachaf> arkeet: Which Yoneda? Where?
10:51:39 <applikativ> yes shachaf explain to us how Yoneda can get a functor out of anything!
10:51:42 <ReinH> shachaf: the lemming
10:51:51 <ReinH> pretty sure it's a lemming
10:51:55 <arkeet> shachaf: the one in kan-extensions, say
10:52:24 <arkeet> Data.Functor.Yoneda
10:53:14 <shachaf> arkeet: Can I do CoYoneda instead?
10:53:22 <arkeet> if you'd like.
10:53:45 <arkeet> but I want to understand it more category-theoretically.
10:55:14 <arkeet> shachaf: well, later.
10:55:16 <arkeet> I have to go.
10:55:20 <levi> skypers: Nice.
10:55:37 <skypers> levi: thank you
10:55:44 <shachaf> arkeet: I'm not saying that I can do either one, of course.
10:55:55 <skypers> my tool – leaf – is quite nice to use, but I’d like to improve it
10:56:08 <applikativ> fmap f (Y phi) = Y (phi . f)
10:56:09 <skypers> like adding more flexible concepts, like stylesheets
10:56:17 <skypers> now they’re in CSS, and hm, it’s CSS…
10:57:36 <levi> skypers: Have you seen Clay?
10:58:03 <levi> It's a combinator library for generating CSS.
10:58:08 <skypers> nope
10:58:16 <skypers> I use blaze html
10:58:27 <skypers> I’ll look forward to clay then :)
10:58:41 <latro`a_> hm...this might be really obvious, not sure. fix a Functor f. is it possible to prove that either there exists x :: forall a. f a, or else any "fmap f m" must apply f to something?
10:58:44 <levi> Doesn't seem very widely used, but I used it on my new site.
10:59:28 <latro`a_> (this is true, for example, with Maybe and []; it seems like it's a theorem the typechecker should be able to prove, though)
11:00:04 <arkeet> latro`a_: what about neither? consider Const Void
11:00:35 <latro`a_> isn't that basically a twisted around version of the first case?
11:00:52 <arkeet> uh
11:00:52 <arkeet> how so?
11:00:55 <latro`a_> (I may misremember the definition of Const)
11:01:05 <latro`a_> Const a b = Const a, yes?
11:01:09 <arkeet> Const r a = r
11:01:15 <arkeet> yeah
11:01:15 <latro`a_> k
11:01:24 <arkeet> so Const Void a has no values for any a.
11:01:46 <latro`a_> is that the third case and there are no others?
11:02:28 <arkeet> so, you are trying to say that we can't have both?
11:02:41 <latro`a_> more precisely that it's exactly one of the three
11:03:10 <arkeet> well it's pretty clear that there exists x :: forall a. f a, or fmap f m must apply f to anything, or neither, or both.
11:03:36 <latro`a_> well yeah
11:03:48 <arkeet> s/anything/something/
11:03:48 <latro`a_> it seems to me that neither -> uninhabited type
11:04:06 <latro`a_> and that both -> functor laws are violated
11:04:36 <arkeet> consider f Void, then.
11:04:58 <arkeet> fmap f (x :: Void) can't apply f to anything.
11:05:05 <arkeet> er, (x :: f Void)
11:05:15 <latro`a_> that seems to suggest that the first case is just always true, then
11:05:22 <latro`a_> which makes my statement true but boring
11:05:25 <arkeet> no, that's clearly false.
11:05:29 <latro`a_> hm?
11:05:33 <arkeet> f = Identity
11:05:37 <latro`a_> touche
11:05:53 <latro`a_> I see
11:06:10 <latro`a_> so basically my statement is true modulo bottoms?
11:06:18 <latro`a_> (meaning not very true at all)
11:07:29 <latro`a_> that is, either there exists x :: forall a. f a, or fmap g (m :: f b) must apply g to something, or b is something equivalent to Void
11:07:40 <applikativ> hah, there's a nice little tutorial for 'clay' part of an act of atoning for writing a monad tutorial ... http://www.stephendiehl.com/posts/haskell_web.html
11:07:58 <applikativ> 'do i need to know category theory in order to write a file?'
11:08:32 <haasn> do I need to understand monads in order to use bash?
11:08:53 <latro`a_> my point here was basically "where does the b come from, if we don't have a value that can just be that type freely, and we also don't have a value to apply the function to?"
11:08:57 <joelteon> do i need to learn category theory to cook dinner?
11:09:02 <applikativ> do i need to study group theory before i can turn around?
11:09:08 <arkeet> latro`a_: I don't know.
11:09:27 <arkeet> do I need to learn quantum field theory to use irc?
11:09:29 <haasn> do I need to study group theory in order to look in a mirror?
11:09:40 <latro`a_> it seems to me that the "forall b" part of the type enforces *something* like what I just said
11:09:49 <shachaf> Do I need to study monoids in order to have an identity?
11:09:50 <applikativ> well, haasn no, you need to study the category Grp for that
11:09:55 <arkeet> shachaf: yes.
11:10:05 <shachaf> Do I need to study abelian groups in order to commute?
11:10:07 <haasn> shachaf: yes but it's easy
11:10:10 <arkeet> shachaf: yes.
11:10:24 <arkeet> well, abelian monoids should suffice.
11:10:26 <shachaf> arkeet knows that my identity is deeply connected to monoids anyway.
11:10:35 <shachaf> arkeet: what about abelian magmas!!!!
11:10:38 <haasn> arkeet: commutative semigroup
11:10:46 <haasn> or that :)
11:10:47 <arkeet> shachaf: I don't like those.
11:10:50 <joelteon> I fell in some abelian magma last night in Minecraft
11:10:52 <shachaf> I know.
11:10:58 <joelteon> dropped all my iron ingots, my bucket, my shears, and some coal
11:11:09 <arkeet> joelteon: did you lose your identity?
11:11:12 <joelteon> yeah
11:11:16 <joelteon> but it's ok, i respawned at my bed
11:11:19 <arkeet> what a shame :(
11:11:26 <joelteon> and now i have to level up again
11:11:59 <latro`a_> is the magma a monoid now?
11:12:09 <applikativ> no, a lot of non group operations commute
11:12:11 <Lethalman> just flip your head
11:12:11 <FreeFull> I'm in a channel with an URL shortener bot and it just randomly shortened an URL to 4monad
11:12:17 <arkeet> latro`a_: if you can find a more precise way to state the question, I might be able to give a more precise answer?
11:12:44 <arkeet> I'm not sure what "f is applied to something" means.
11:13:10 <jfischoff> does Free f a ~ Fix (f :+: K a)?
11:13:13 <latro`a_> in [], either the list is empty (in which case xs :: forall a. f a)
11:13:24 <latro`a_> or you apply the function to at least one element
11:13:33 <arkeet> "sure"
11:13:49 <Raydiation> hi do you use haskell for webapps? what frameworks do you like best?
11:13:49 <arkeet> jfischoff: sure.
11:13:55 * jfischoff nods
11:14:14 * hackagebot bytes 0.12 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.12 (EdwardKmett)
11:14:22 <applikativ> Raydiation: well, that question not as inflamatory as 'what editor should i use'? ;)
11:14:55 <shachaf> arkeet: what about Foo f a = a -> f (Foo f a)
11:15:04 <arkeet> I don't know what that is.
11:15:10 <shachaf> and Bar f a = f (Bar f a) -> a
11:15:12 <Raydiation> applikativ: im aware of that :) i just want to dig into haskell and i do web development a lot
11:15:16 <arkeet> or that.
11:15:18 <shachaf> that one doesn't even have a constant variance!
11:15:20 <applikativ> Raydiation: the three happening frameworks are Yesod, Snap and Happstack. Scotty, I don't think counts as a 'framwork' quite
11:15:21 <arkeet> haha
11:15:40 <arkeet> a -> f (a -> f (a -> ...))
11:15:44 <arkeet> I don't know what that is.
11:16:02 <arkeet> besides it being Fix (f . (a ->))
11:16:14 <haasn> consider a ~ ByteString, f ~ IO for an example that makes sense to me
11:16:41 <Raydiation> applikativ: whats your personal preference?
11:16:42 <arkeet> I'm tired.
11:16:43 <shachaf> IO makes sense to you?
11:16:49 <haasn> or f a ~ IO (x, a)
11:16:50 <arkeet> IO doesn't make sense to me.
11:16:53 <monochrom> "Foo f a = a -> f (Foo f a)" looks interesting
11:17:00 <haasn> shachaf: it's just a free monad, what's the big deal?
11:17:13 <arkeet> free on what functor?
11:17:25 <haasn> http://comonad.com/reader/2011/free-monads-for-less-3/
11:17:30 <n-dolio> Definitely not a free monad.
11:17:31 <joelteon> free monad with purchase of two applicatives
11:17:43 <applikativ> Raydiation: oh, i don't have one, since I have never constructed a serious website. or another way to put it is, my favorite is hakyll ;)
11:17:44 <haasn> newtype OI a = forall o i. OI (FFI o i) o (i -> a) deriving Functor
11:17:50 <haasn> IO = Free OI
11:17:56 <haasn> sort of
11:18:00 <n-dolio> Oh, you mean IO is a free monad.
11:18:04 <shachaf> FREE monad with the purchase of two functors*!
11:18:09 <haasn> well, it's one possible implementation
11:18:13 <Raydiation> applikativ: i see, thanks :)
11:18:14 <shachaf> * functors must be adjoint to qualify
11:18:25 <jfischoff> heh
11:18:26 <haasn> shachaf: hahaha
11:18:36 <applikativ> Raydiation: but they are all familiar, and have different features; im not sure where the most up-to-date non-ideological comparison might be.  yesod surely has more of a 'community' than the others
11:18:42 <haasn> shachaf: free comonad, too
11:18:48 <latro`a_> what exactly is FFI o i
11:18:54 <shachaf> haasn: That's two free monads!
11:18:55 <Raydiation> applikativ: thanks, thats what i wanted to hear :)
11:19:52 <shachaf> haasn: Anyway, the comonad is, like, cofree and stuff.
11:20:01 <haasn> latro`a_: either an impure function (if you're in a language that has that sort of thing) o -> i; or some abstract representation of an external function call or something, I guess
11:20:16 <edwardk> derp. i just realized HLINT listens when you say 'ignore "Parse error"'
11:20:25 <edwardk> that will let us kill a ton of #ifdef HLINT blocks in lens
11:20:36 <jfischoff> oh nice
11:20:41 <shachaf> edwardk: Does it just ignore the rest of the file in that case, or what?
11:20:53 <edwardk> probably, admittedly
11:21:02 <edwardk> so maybe we want to keep them
11:21:06 <shachaf> That's not so great if you actually want to use it.
11:21:07 <levi> Raydiation: Yesod relies heavily on domain-specific languages in Template Haskell, which has its pluses and minuses.
11:21:19 <edwardk> but it just came up at work as we were debating about using HLint internally
11:21:36 <monochrom> "new course: MAT 1337 Category Theory. Instructor: Adjunct Prof. Untor"
11:21:42 <edwardk> and putting ignore 'Parse error' was enough to mitigate the 'its a pain in the ass' concerns to where I could use it =P
11:21:49 <monochrom> err, s/Untor/Unctor/ !
11:22:00 <Raydiation> levi: you mean like using a proper template language?
11:22:04 <Raydiation> rather than php style?
11:22:05 <applikativ> monochrom: Adjunct Professors come in pairs
11:23:13 <levi> Raydiation: Opinions vary widely on what the 'proper' way to do templates is. Most of the Haskell frameworks have a 'blessed' template package, but you can usually use a different one if you want to via a little bit of glue code.
11:23:29 <jfischoff> So I had this idea. Take `Free f a` go to `Fix (f :+: K a)`. Then turn the Fixes into STRefs, and share the refs where the 'a's are equal. The idea is too make a Free monad that has faster substitution.
11:23:31 <applikativ> Raydiation: i don't think you need to get too mixed up in th to use yesod.
11:23:52 <applikativ> Raydiation: but then i'm only intersted in the io models the different frameworks use ;)
11:24:08 <Raydiation> applikativ: you mean like event driven?
11:24:19 <jfischoff> Am I on the right track there? is there a better way to do efficent substitution with a free monad?
11:24:35 <n-dolio> How are you going to determine if two arbitrary as are the same?
11:24:41 <jfischoff> Eq
11:24:44 <n-dolio> Nope.
11:24:45 <levi> applikativ: Just about all the Yesod examples make heavy use of quasiquoters for routes, html generation, css generation, persistence management, etc.
11:25:09 <jfischoff> n-dolio: go on
11:25:22 <levi> You probably could use Yesod without TH, but it's certainly not the way it's usually used.
11:25:29 <applikativ> levi: i think we're in complete agreement; but not every rational person is scared off by this
11:25:55 <n-dolio> Well, unless it's some 'optamize :: Eq a => Free f a -> Free f a' combinator.
11:26:11 <n-dolio> It's not going to happen automatically, though.
11:26:12 <edwardk> jfischoff: tuning in now what is the question?
11:26:16 <levi> Sure, I don't think it's a reason to be scared off, but it takes some getting used to if you're not familiar with using a lot of TH-generated code.
11:26:35 <jfischoff> edwardk: you know substitute from bound?
11:26:42 <applikativ> Raydiation: no, i meant another aspect of io, they all have different replacement for the so-called 'lazy io', yesod uses conduits, snap uses 'io-streams' increasingly, happstack is preparing to use the new pipes
11:26:45 <jfischoff> I want to make an optimize version for Free
11:27:13 <jfischoff> or something like Free maybe a different representation with STRefs where the Pure a are the same
11:27:32 <jfischoff> This is connected with unification ...
11:27:55 <applikativ> i haven't heard it, but it follows from first principles that `scotty` is preparing to organize io using the `machines` package
11:29:22 <dcoutts> testers requested!  http://beta.hackage.haskell.org/
11:29:56 <geekosaur> what, not newnewnewnewhackage? :p
11:30:25 <edwardk> jfischoff: i'll catch up with you about this after i get back from a meeting
11:30:29 <dcoutts> geekosaur: we considered that...
11:30:31 <dcoutts> ;-)
11:30:39 <jfischoff> edwardk: cool
11:30:50 <elliott> dcoutts: will the haddock stylesheet be adjusted to match the site design?
11:31:28 <dcoutts> elliott: if someone can do that, it's not totally trivial since the .css is duplicated in each generated bundle
11:31:31 <donri> hackage factory factory
11:31:39 <sm> hooray
11:32:26 <donri> applikativ: isn't scotty just a layer on top of wai = conduit though?
11:33:11 * monochrom has a bit of worry about doing final switchovers to coincide with ICFP :)  i.e., what if something goes wrong in the switching, will the staff be available to fix problems?
11:35:06 <luite_> hmm, is the physical location of the staff really an issue/
11:35:07 <luite_> ?
11:35:24 <tpsinnem> hm, typeclass newbie question: if i have a value of a type with a Monad instance, can i not also use Functor methods on it?
11:35:40 <luite_> usually you'd just remote reboot into a rescue distro if something really goes wrong... the new hackage is hosted at some proper isp isn't it?
11:35:46 <monochrom> yes. physical location affects internet connections and attention span
11:36:09 <luite_> oh i think there should be enough reliable connections in boston :)
11:36:43 <geekosaur> spoken like someone who's never seen a conference wifi config overload
11:37:18 <applikativ> dcoutts: i take it that the request for an upload account still vanishes into Prof. Patterson's lost email account?
11:37:24 <luite_> geekosaur: nah i mean many haskellers even live nearby, there's the hotel, airport and other locations
11:37:45 <dcoutts> applikativ: no, as it says, there's self registration
11:37:59 <applikativ> oh, then it's maybe a little slow?
11:38:35 <dcoutts> applikativ: ahh, no, we need to install sendmail on the new VM...
11:39:10 <elliott> um, I hope you still need some kind of approval for new package uploads?
11:39:31 <applikativ> i'm not sure what Prof. Patterson goes by in approving people
11:39:43 <jfischoff> there was never really any approval I think
11:39:45 <dcoutts> elliott: yes, as it says on the features page about self-registration
11:39:56 <elliott> it feels reassuring to know you have to pass a two second test to upload a new version of yesod :)
11:40:01 <monochrom> luite_: http://ro-che.info/ccc/13
11:40:06 <ReinH> Does the prelude define a Functor instance for all Monad instances?
11:40:17 <geekosaur> no
11:40:29 <ReinH> well, WrappedMonad
11:40:35 <applikativ> you mean, does it also define Functor? there must be exceptions
11:41:02 <applikativ> MerelyFunctoredMonad
11:41:19 <dcoutts> elliott: see also the bit about security
11:41:20 <luite_> monochrom: hehe i suspect that during most talks, half the audience will be answering stackoverflow questions anyway :)
11:41:36 <elliott> dcoutts: ok, I admit reading would help :)
11:41:37 <ReinH> tpsinnem: A Monad is does not necessarily have a defined Functor instance, although many do
11:41:56 <applikativ> the old test was that you used to have to be able to figure out what email account prof. patterson might be reading
11:42:15 <applikativ> which of course exceeded my capacities
11:42:19 <ReinH> Is there a principled reason to not define fmap f x = x >>= (return . f) for all monads?
11:42:26 <donri> applikativ: not the one listed? http://hackage.haskell.org/packages/accounts.html
11:42:30 <elliott> aka fmap = liftM
11:42:34 <ReinH> right
11:42:41 <applikativ> ReinH: that it's a bad definition?
11:42:49 <ReinH> or just a historical artifact?
11:42:51 <tpsinnem> ReinH: ok, thanks
11:42:57 <ReinH> applikativ: why?
11:42:59 <applikativ> is that how liftM is implemented?
11:43:08 <ReinH> it's the definition used for, e.g., Functor IO
11:43:12 <monochrom> no. but there is a reason to not write "instance Monad m => Functor m"
11:43:17 <applikativ> >>= can be recursive while fmap is not, for one thing
11:43:25 <donri> monochrom: DefaultSignatures ;)
11:43:41 <cppcabrera>  /close
11:43:42 <ReinH> applikativ: you tell me http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#liftM
11:43:48 <shachaf> applikativ: Huh?
11:43:55 <ReinH> applikativ: I'm not sure what you're trying to say
11:43:58 <monochrom> yikes, what's default signatures?
11:44:00 <applikativ> so it is with e.g. the Stream type in vector
11:44:10 <ReinH> liftM is defined using a do-sugared >>=
11:44:22 <donri> monochrom: they let you have an alternative type signature for a class default
11:44:38 <donri> default fmap :: Monad m => ...
11:44:54 <monochrom> onoes
11:45:01 <ReinH> applikativ: so please explain how it's bad, given that it's the definition used by Prelude?
11:45:31 <elliott> you can define a better fmap than liftM for some types.
11:45:40 <ReinH> elliott: yes, asolutely
11:45:44 <ReinH> but it's not *bad*
11:45:51 <donri> ...but fmap = liftM would be better than no instance, surely
11:46:21 <ReinH> donri: but once you define it for all Monad m as liftM
11:46:24 <ReinH> you no longer get to choose
11:46:28 <donri> any other definition is just gonna be an optimization, yeah? can come later
11:46:37 <donri> ReinH: that doesn't work though
11:46:38 <ReinH> donri: no, once you say instance Monad m => Functor m
11:46:46 <ReinH> you can't then say "oh but this monad is special"
11:46:57 <donri> ReinH: that instance will conflict with any other instance
11:47:01 <jfischoff> ^ this
11:47:05 <ReinH> donri: yes, that's what I'm saying
11:47:14 <donri> ReinH: (not just for monads)
11:47:25 <johnw> @tell heatsink Remember that code I showed you using async and wait?  Even simpler: do { (hout,herr) <- createProc ; concurrently (gather hout) (gather herr) }
11:47:25 <lambdabot> Consider it noted.
11:47:35 <ReinH> donri: yes, that's why you can't define instance Monad m => Functor m
11:47:45 <ReinH> and why fmap = liftM is not better than no instance
11:47:59 <donri> ReinH: i was suggesting it on a per-instance case
11:48:21 <ReinH> donri: functor instances are defined on plenty of monad instances
11:48:35 <ReinH> Functor IO is defined as liftM, although it's inlined
11:48:38 <donri> ie. better to add an instance with liftM than to refrain from adding an instance at all before you know the best definition possible
11:50:01 <donri> ReinH: then aren't you answering your own question? <ReinH> Is there a principled reason to not define fmap f x = x >>= (return . f) for all monads?
11:50:13 <ReinH> donri: yes, I am :) I just needed to think it through.
11:50:17 <donri> :)
11:50:18 <donri> cool
11:50:42 <edwardk> ReinH: how would one do that definition?
11:50:46 <ReinH> applikativ: I'm seriously confused here. fmap is often recursive, e.g., on any recursive data type (List, Tree, etc)
11:50:55 <ReinH> edwardk: one wouldn't :)
11:51:02 <edwardk> Sonarpulse: bytes 0.12 is released
11:51:08 <Sonarpulse> saw, yay!
11:51:21 <Sonarpulse> noticed that url in readme is analytics/bytes
11:51:23 <ReinH> edwardk: hard to miss if you're in #haskell-lens :p
11:51:38 <Sonarpulse> not ekmett/bytes
11:51:58 <Sonarpulse> for Travis
11:52:30 <edwardk> Sonarpulse: patch! =) it used to be housed under the analytics project but then nobody could find it
11:52:32 <applikativ> ReinH: right, but e.g. Stream is not a recursive type; fmap is not defined recursively; neither is concatMap/=<< in fact but it's a gruesome nightmare in which a Stream is itself used to represent the state of the stream
11:52:37 <Sonarpulse> ok
11:52:39 <edwardk> so i went and pulled most of them back into my own account
11:52:52 <edwardk> which is ironic from a finding perspective, because i have _way_ too many repositories
11:53:13 <ReinH> applikativ: I'm just trying to understand why you called the definition bad, and why you said
11:53:16 <ReinH> applikativ : >>= can be recursive while fmap is not, for one thing
11:54:45 <mkscrg> all, is there consensus on a library for cryptographic hashes (sha, etc.)?
11:55:01 <Clint> no, but cryptohash is pretty good
11:55:06 <applikativ> ReinH: right, I think that Data.Vector....Stream.map f = concatMap (singleton . f) looks like it would be horrible
11:55:12 <edwardk> mkscrg: there are several out there, and i'm likely to add to the pile soon
11:55:16 <Sonarpulse> edwardk: readme fixed
11:55:21 <edwardk> Sonarpulse: thx
11:55:24 <Sonarpulse> np
11:55:34 <Sonarpulse> cabal ignores readme right?
11:55:36 <Sonarpulse> *hackage
11:55:42 <edwardk> Sonarpulse: yeah
11:55:52 <ReinH> applikativ: yes, there may certianly be more efficient definitions than fmap = liftM for some instances
11:55:53 <Clint> edwardk: what are you adding?
11:55:55 <edwardk> Sonarpulse: i won't re-release for this, but its nice to have the docs updated
11:55:58 <applikativ> ReinH: this may not be the best example, it would just surprise me if a definition of fmap in the styleof liftM would be rational
11:56:04 <mkscrg> edwardk: fair enough. put differently, is cryptohash a reasonable choice?
11:56:21 <applikativ> ReinH: this is one of the reasons why Functor => Monad is important
11:56:38 <applikativ> though i guess they could let us implement liftM ourselves
11:56:38 <edwardk> Clint: now that i have a nice theory for comonadic folds i can make 'digests' just be a left fold that you can partially feed or extract from, so the API for a cryptographic hash becomes one definition
11:56:53 <Clint> cool
11:56:55 <Sonarpulse> oh good
11:57:10 <ReinH> edwardk: that's cool :)
11:57:22 <ReinH> edwardk: the idea of "resumable" folds is pretty neat
11:57:40 <edwardk> Clint: with Folds you could just use 'run [1,2,3] crc32'         or 'run [3] $ run [1,2] $ duplicate crc32'   and get the same answer
11:57:57 <Clint> nice
11:58:15 <donri> http://beta.hackage.haskell.org/user/EdwardKmett it almost looks like a short list when presented this way
11:58:24 <Sonarpulse> then it's not such a big such deal that I missed the release
11:58:29 <Sonarpulse> g2g
11:58:45 <edwardk> donri: hah
11:58:50 <ReinH> donri: why am I not using Hackage 2? huh
11:59:46 <ReinH> edwardk: now I want to write an editor with rope
11:59:51 <ReinH> damn you
11:59:58 <edwardk> ReinH: don't bother. rope is old. =)
12:00:03 <ReinH> edwardk: but still :p
12:00:16 <edwardk> the version of the ropes in trifecta is better
12:00:27 <applikativ> somehow i think Hackage 2 is conceptually out of date, now that its' becoming real ...
12:00:29 <ReinH> k
12:01:01 <applikativ> why do i need it, i would rather install things from suitably tagged repos on github somehow
12:01:27 <jfischoff> speaking of old, edwardk do you still use reducers?
12:01:27 <donri> yeah let's force everyone to depend on git and github
12:01:47 <applikativ> donri: admittedly that's disgusting
12:01:50 <Heffalump> you could view git as a software distribution mechanism - cabal upload = git push
12:02:04 <edwardk> jfischoff: not very much. i've been trying to find a more coherent version of the ideas in it, this why lens has Fold and why i'm playing with folds. ;)
12:02:08 <Heffalump> (I mean take the tarball, untar it, commit)
12:02:10 <donri> Heffalump: but why git at all, then? :p
12:02:14 <edwardk> they were just a little too awkward to use
12:02:18 <applikativ> donri: on the other hand almost everything on hackage is inaccessible to patches; so it might as well be thrown out
12:02:19 * jfischoff nods
12:02:40 <ReinH> edwardk: so what happened to tropical semiring when you moved over to reducers? I couldn't figure out if it was a reducer.
12:03:04 <edwardk> jfischoff: http://hackage.haskell.org/packages/archive/folds/0.3/doc/html/Data-Fold.html#t:M captures the current notion of a reducer i kind of like
12:03:08 <jfischoff> the nice thing about reducers is it makes explicit the idea that some monoids have elements, which is captured anywhere else that I know of
12:03:29 <edwardk> ReinH: monoids < 1.3.5 or so was a bit monolithic. i went to break it up and never finished
12:03:30 <jfischoff> s/is/isn't
12:03:33 <donri> applikativ: i'm not sure what you're sayng
12:03:39 <ReinH> edwardk: ah. You bastard. ;)
12:03:58 <ReinH> jfischoff: "some monoids have elements"?
12:04:09 <edwardk> ReinH: i got far enough to split out the compression monoids/generators into 'compressed' but thats about it
12:04:19 <applikativ> donri: github can tell me if someone has patched a repo someone else has forgotten about; this alone makes it 200X as valuable as hackage which is basically an immense pile of things that dont build wont build, whose users have basically spammed our system etc
12:04:30 <ReinH> edwardk: well I found your old version and ported it over so it's all good ;)
12:04:32 <jfischoff> ReinH: feel free to find another way to say it
12:04:33 <edwardk> reducers was an attempt to capture the more liberal notion of a semigroup reducer rather than require a monoidal reducer.
12:04:35 <applikativ> 40% of hackage is spam from 3+ years ago
12:04:38 <johnw> reducers!
12:04:43 <johnw> i was just recommending it to someone today
12:04:52 <edwardk> this is captured in 'folds' as M1, while the old notion of a reducer is 'M'
12:04:59 <edwardk> the names could use some work ;)
12:05:00 <ReinH> jfischoff: I would if I understood what you are saying :)
12:05:01 <johnw> i erroneously thought it offered O(1) snoc on regular lists, but was proven wrong reading the code
12:05:09 <jfischoff> oh well
12:05:12 <donri> applikativ: hackage 1 works like that, though. (but not hackage 2)
12:05:15 <ReinH> jfischoff: which I assume is my fault :)
12:05:27 <edwardk> johnw: sadly no magic snoc
12:05:35 <donri> applikativ: cabal unpack; cabal sdist; cabal upload; view "recent" log
12:05:38 <jfischoff> ReinH: you generours :)
12:05:41 <johnw> edwardk: well, I wasn't expecting *that* much magic, just a dlist under the hood
12:05:42 <jfischoff> err your
12:05:47 <applikativ> donri oh i don't have get hal daume's permission to get WordNet to compile?
12:05:49 <ReinH> jfischoff: now I'm not so sure ;)
12:06:00 <donri> applikativ: technically no, not currently
12:06:06 <ReinH> roconnor: ping
12:06:25 <applikativ> donri: right, the while idea is no good. it is too bound up with rights
12:06:32 <jfischoff> So edwardk have you put much thought into a substitution friendly Free?
12:06:35 <edwardk> johnw: note: snoccing a d-list violates its invariants as i recall
12:06:42 <donri> applikativ: the "while" idea?
12:06:46 <jfischoff> also I don't get M on first glance
12:06:53 <johnw> edwardk: by dlist snoc, I meant ++[x], that shouldn't violate anything
12:07:23 <applikativ> donri: sorry. right this is why the hackage idea is no good. everything is in the control of dead people like hal daume
12:07:30 <edwardk> johnw: it violates the assumption that dlist x . dlist y == dlist (x ++ y)
12:07:43 <donri> anyway git for packages encourages ditching version management. cf vim addons in modern times
12:07:44 <jfischoff> I guess you M ? unit append m
12:07:46 <edwardk> the monoid homomorphism breaks
12:07:49 <jfischoff> err you have
12:07:56 <edwardk> but you can use the unit append
12:08:03 <jfischoff> not sure what m -> b is
12:08:14 <donri> applikativ: but it isn't?
12:08:14 <johnw> i don't quite follow, I was thinking of unit append
12:08:27 <edwardk> what i mean to say is that a dlist that takes the input list, and appends rather than prepends violates the assumption
12:08:33 <donri> applikativ: anyone can upload anything to any package name in hackage 1
12:08:36 <johnw> the only magic I was expecting was for reducers to guarantee O(n) at reduction time
12:08:43 <edwardk> appending with (x:)  is fine
12:08:44 <applikativ> donri: yes, but it's wrong
12:08:57 <applikativ> donri: because it's a publication system
12:09:07 <donri> applikativ: yes, it is. not sure what you're suggesting that would be different, though :)
12:09:37 <ReinH> donri: well, authentication might be nice ;)
12:09:53 <ReinH> signed packages?
12:10:00 <johnw> edwardk: if both dlists and Codensity work by right-associating the underlying operation, and if both Yoneda and Codensity are kan extensions, can I think of Yoneda as a right-association too?
12:10:09 <donri> ReinH: that's all part of hackage 2 or coming
12:10:12 <applikativ> donri: on github i can make public a patched version of a package even against the wil of the original author
12:10:14 <ReinH> donri: good :)
12:10:26 <ReinH> applikativ: no one is stopping you from using haskell libraries from github
12:10:35 <applikativ> I do
12:10:39 <johnw> Yoneda seems to be more like a distributive operation than a re-association
12:10:46 <donri> applikativ: so what you actually want is to have the user name part of the package name
12:11:01 <applikativ> huh?
12:11:15 <applikativ> i want a system that is not hostage to people who have left the community
12:11:26 <donri> i don't see how git would help
12:11:29 <applikativ> but more especially people who cant decide if they have
12:11:55 <applikativ> donri: i push patched hackage garbage to github for newbies on here about 4 times a day
12:11:59 <ReinH> donri: git helps in one concrete way: cryptologically verified payload contents and history
12:12:11 <donri> in hackage 2 you can still upload a fork with a new name, or, convince an admin the package is unmaintained and have it transferred to you
12:12:12 <exFalso> Hi, is there a way to update cabal dependencies in .cabal? When i 'cabal init' it will automatically derive the dependencies and insert them in the .cabal, can i update this subsequently?
12:12:14 <edwardk> johnw: yes. just going back to my mis-targeted point for a second: DList a = Endo [a] -- but DLists are covariant and Endo [a] is invariant, having a in both positive and negative position. the correctness of this hinges on the fact that that Endo [a] can always be passed [] and manipulated. the ability to pass it [] hinges in the ability that it only prepends.  now (xs++) . (x:)   is a perfectly valid dlist that snoc's x , but
12:12:14 <edwardk>  if you just look at the Endo [a] type you can make bad inhabitants (\xs -> xs ++ [x]) which have the DList a type but which aren't valid dlists is all.
12:12:44 <ReinH> donri: I don't know what Hackage 2's security model is, but if it actually has one then that would be a marked improvement :)
12:12:45 <kuribas> exFalso: cabal update?
12:12:46 <applikativ> donri, this is hopeless paperwork, it is out of date
12:12:54 <johnw> edwardk: ah, I see what you mean now, thanks for explaining that
12:12:55 <edwardk> johnw: that is all i was saying off hand, before my attempt to say that got confused with being a criticism of dlists in general
12:13:14 <exFalso> kuribas: afaik that only downloads the package list from hackage?
12:13:16 <sm> exFalso: update them by hand. The packdeps website or command-line tool, or cabal-audit tool, will warn you of outdated deps
12:13:24 <johnw> I do tend to use Endo to make ad hoc dlists
12:13:40 <applikativ> donri: you really not thinking how many new users are lost because they cant install something last uploaded in Mar 2011
12:13:48 <edwardk> codensity right associates binds, yoneda 'fuses' fmaps (and probably right associates them)
12:13:51 <applikativ> donri: i think about 20 a day
12:13:56 <elliott> edwardk: and the condition that makes an Endo [a] a valid DList is naturality!
12:13:56 <donri> applikativ: the only reason your github model would "solve" that is because your user name is part of the package name. applicativ/my-forked-package
12:14:06 <donri> applikativ: this is equivalent to uploading applicative-my-forked-package to hackage
12:14:11 <johnw> anyone know how to mirror Hackage 2 yet?
12:14:13 <exFalso> sm: hmm thanks, i thought there must be an existing automated way of doing it seeing as it does it at 'cabal init'
12:14:30 <sm> exFalso: not yet, I think
12:14:34 <johnw> I only use my local Hackage mirror these days; not only does it always work, it's much faster when rebuilding the world
12:14:53 <applikativ> donri: i dont a darn about github, there must be a record, on the webpage pointing to patched version completely that can exist with out and against the will of the socalled original authro
12:14:55 <jfischoff> is there any way to make composition functor (:.:) that composes with itself? Like (:.:) :.: (:.:)?
12:15:01 <applikativ> this is the only feature of github i refer to
12:15:17 <applikativ> donri: if everything on hackage were also on github, then you could track this easily.
12:15:31 <donri> applikativ: i don't know of any such feature of github, except the "fork network". is that what you're talking about?
12:15:39 <sm> exFalso: at cabal init time, you have no code, so it can choose some deps without thinking too hard :)
12:15:53 <kuribas> :t (.) . (.)
12:15:54 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:16:04 <applikativ> donri: yes, the fork network images are a crucial part of the github api
12:16:22 <ReinH> donri: I *think* what applikativ wants is a security model with strong identity and integrity guarantees.
12:16:46 <ReinH> You don't need github to get these, but it certainly is an option
12:16:54 <edwardk> roconnor: do you remember the link for the paper that says that if there is both a left fold and a right fold that can derive an answer then there is a monoid?
12:17:12 <applikativ> the impediments to updating dead code are simply too great.
12:17:18 <roconnor> edwardk, that doesn't sound familiar to me.
12:17:19 <applikativ> it is an academic model
12:17:32 <ReinH> roconnor: hai
12:17:36 <roconnor> hi
12:17:39 <edwardk> roconnor: shucks
12:17:43 <donri> personally i think the user centric view of github is a bad thing
12:17:47 * roconnor is in bern
12:17:50 <edwardk> i just can't remember the name of the paper for the life of me and i wanted to cite it
12:17:55 <ReinH> roconnor: I was reading your ICFP 2010 portmortem
12:18:13 <roconnor> ReinH, which contest was that?
12:18:16 <donri> as evidenced by edwardk's problem of where to put "his" stuff
12:18:24 <ReinH> roconnor: the engines and fuels one
12:18:27 <johnw> edwardk: if Yenoda is basically doing: fmap f (fmap g (fmap h xs)) => fmap (f . g . h) xs, there should be a way to write that which shows it's a left-to-right association mapping...
12:18:48 <roconnor> ReinH, for orbits?
12:18:54 <donri> or that there's a "lens" organization but lens itself is under ekmett
12:19:04 <ReinH> roconnor: you had to produce engines and fuels that would "power" them
12:19:11 <ReinH> using ternary gates and encodings
12:19:16 <roconnor> ReinH, oh right, the cars
12:19:20 <ReinH> yeah
12:19:35 <ReinH> (it was secretly a way to get programmers to generate relative termination problems)
12:19:53 <ReinH> roconnor: http://cl-informatik.uibk.ac.at/workspace/ajsw10/slides/BF.pdf
12:19:55 <edwardk> johnw: well, that is happening because all it is doing it is accumulating it in between the argument (a -> r) of forall r. (a -> r) -> f r and the actual fmap that gives you the f r at the end
12:20:16 <johnw> right
12:20:18 <ReinH> roconnor: That was one of my first "using Haskell in anger" experiences :)
12:20:29 <roconnor> ReinH, :)
12:20:36 <applikativ> donri: the fact is at least 80 of hackage is simply uninstallable; a different idea could get rid of this in a couple of weeks
12:20:49 <ReinH> roconnor: we had a team of four, including a mathematician with a phd specialty in linear algebra
12:20:52 <ReinH> purely by coincidence
12:21:02 <ReinH> roconnor: who had an appendicitis on day 1. :/
12:21:12 <johnw> edwardk: right
12:21:24 <luite_> ReinH: sabotage!
12:21:28 <ReinH> roconnor: he followed along from the hospital and would call us with suggestions
12:21:31 <roconnor> ReinH, I really like their encoding
12:21:32 <ReinH> which would save us hours of work
12:21:36 <johnw> edwardk: i'm just wondering why the behavior appears different in character from dlist and codensity, with which it is so intimately related
12:21:37 <ReinH> roconnor: it was a very pretty problem
12:21:38 <monochrom> sabotage is my thought too :)
12:21:58 <ReinH> roconnor: writing the ternary circuit generator was fun
12:22:24 <ReinH> we put quite a bit of effort into circuit minimization
12:22:30 <edwardk> well, yoneda fuses fmap, codensity fuses (>>=)
12:22:48 <johnw> does it fuse >>=, or just right-associate it?  if it's fusion, then that answers my question
12:22:55 <DRiKE> anyone experience with cross compiling ghc for the raspberry pi (host system is Arch 64 in my case). arm-linux-gnueabihf-nm complains: 'includes/dist-derivedconstants/header/tmp.o: File format not recognized'
12:22:57 <ReinH> roconnor: we hand coded some basic operations and then wrote a heuristic solver
12:23:02 <edwardk> fusing is right associating there =)
12:23:03 <DRiKE> not sure how to proceed
12:23:08 <johnw> ah, hmm
12:23:17 <edwardk> it makes all the (>>=)'s happen at once
12:23:18 <ReinH> roconnor: what I love about ICFP competitions is that each individual piece is that interesting, and they have so many layers
12:23:18 <johnw> so it's like combining the behaviors of dlist and yoneda, in a sense
12:23:25 <edwardk> yeah
12:23:27 <donri> applikativ: personally i find it rather hellish with vim addons to figure out which github fork is the one you should use, and if that one with a recent fix is just a one-off get-it-to-work that's gonna be even more unmaintained than the original
12:23:28 <johnw> cool
12:23:42 <ReinH> roconnor: I think our code is still on github somewhere
12:24:03 <johnw> @tell sclv I think I found the connection between Yoneda and "fold functions": Mendler algebras expressed using Coyoneda
12:24:03 <lambdabot> Consider it noted.
12:24:14 <applikativ> donri yes the matter needs to be systematized i dont care about github of course
12:24:15 <ReinH> roconnor: oh btw we figured out that the server allowed HTTP basic auth so we used shell scripts and curl to ship solutions to the server :D
12:24:19 <ReinH> saved us a LOT of time
12:24:24 <edwardk> codensity f a is 'bigger' than f but it is useful in that if f has an expensive normalization step on left associated binds then you never pay it. on the other hand it mean you get no benefit of the normalization until the end
12:24:29 <RichyB> ReinH, hahah, cool! One of the team members is a linear algebraist throwing suggestions in from the hospital in which he is possibly-not-dying. That's so charmingly William Gibson. :D
12:24:37 <donri> applikativ: ah
12:24:40 <applikativ> donri: good luck waiting for Prof. Hal Daume to tell you which 'fork' of WordNet wins his approval
12:24:43 <ReinH> RichyB: I know. It was epic! (He was fine)
12:24:51 <edwardk> hence why Codensity f is always a 'win' for free monads… there is no normalization!
12:24:59 <RichyB> I love it when life goes temporarily all cyberpunk.
12:25:06 <johnw> edwardk: in general you don't recommend expressing effects using Codensity (Free f), but rather to use monad transformers?
12:25:13 <johnw> i've been reading your SO comments on that subject here and there
12:25:15 <ReinH> RichyB: needs trailer voiceover
12:25:26 <ReinH> "A race against time. Four men..."
12:25:38 <ReinH> "When all that you know is wrong."
12:25:49 <arnsholt> applikativ: What, you mean you use other resources than the Wall Street Journal? I'm shocked, I tell you, shocked! =p
12:25:53 <tdp93422> is there a native implementation of gzip (zlib) on hackage? It seems like everything I find uses FFI to the C libraries....
12:26:09 <ReinH> edwardk: ^
12:26:11 <roconnor> ReinH, really?  that would have been so much easier
12:26:13 <edwardk> johnw: well, i tend to prefer looking at (MonadState s m, MonadError e m) => e -> m s      than at some monolithic construction that is too big to express Reader and too small to express lazy Writer.
12:26:17 <ReinH> roconnor: yep! :D
12:26:35 <ReinH> roconnor: I started out writing a bunch of glue stuff in Ruby but it turns out bash and *nix tools were easier to use and faster
12:26:40 <geekosaur> tdp93422, gzip is not trivially reimplemented so I doubt it
12:26:42 <edwardk> johnw: passing in the monad transformer dictionaries _are_ the product of lawvere theories
12:26:56 <edwardk> they just come with a free implementation when you pick an instance
12:26:57 <tdp93422> Thanks /geekosaur
12:27:02 <johnw> edwardk: but not the coproduct?
12:27:07 <ReinH> roconnor: at one point we had out solver spitting out solutions into a directory and we would watch that directory for new files and then curl them
12:27:07 <edwardk> er coproduct
12:27:13 <edwardk> product of theories is easy
12:27:18 <ParahSailin> tdp93422: why not just use the c zlib?
12:27:19 <RichyB> tdp93422, I don't think so. I don't know of implementations of gzip in *any* language other than C, largely because zlib is so stable and it's been so long since anyone found a bug in it that *everyone* uses it through their local C FFI.
12:27:46 <ParahSailin> theres probably a javascript implementation of gzip that lots of people use
12:28:04 <ParahSailin> just because people do lots of crazy stuff in javascript
12:28:11 <tdp93422> I wanted to write a program usable across linux, windows, and mac osx without dealing with libraries separately for each OS.
12:28:20 <edwardk> johnw: i find the classes a lot easier to reason about than the CPS'd lawvere theory stuff, and they have the benefit of not injecting my monad into a larger domain
12:28:42 <ReinH> roconnor: one of my absolute favorite things about the competition is that our engine solver had these parameters that constrained it, like maximum matrix size, maximum value to use, number of matrixes, etc
12:29:00 <ReinH> roconnor: and we found that by varying these parameters, we could improve its ability to find solutions
12:29:03 <roconnor> ReinH, you should do the ICFP 2006 contest
12:29:10 <sclv> johnw: neat. catching up on the scrollback now.
12:29:13 <edwardk> oleg's effect monad is too big to express Reader. It can only express State. Now, it can express reader.. but only by writing it as State that doesn't change State!
12:29:20 <ReinH> roconnor: but the parameters were pretty dependent, so it was hard to find local maximums in performance
12:29:25 <johnw> edwardk: that makes sense; though, does being the mtl maintainer mean I need to eat my salt grain? :)
12:29:30 <ReinH> roconnor: and we didn't *quite* have time to write a solver for the solver
12:29:50 <ReinH> roconnor: so instead I wrote a benchmarking tool that would tell me the efficiency of each set of params and then I did some manual hill climbingh
12:29:53 <edwardk> johnw: you should know me well enough by now to know that if a better solution came along i'd drop the old one on the floor =P
12:30:04 <johnw> haha, yeah, that was purely teasing :)
12:30:14 <ReinH> roconnor: in my mind it was like tweaking knobs on an old piece of analog equipment
12:30:18 <ReinH> and it was awesome
12:30:21 <roconnor> :D
12:30:39 <ReinH> roconnor: I'll check out 2006
12:31:02 <edwardk> ICFP 2006's programming contest was amazing
12:31:09 <ReinH> cool :D
12:31:21 <edwardk> by far the best PL-theory centric contest ever
12:31:24 <ReinH> we should get together and form a super team for the next one
12:31:31 <ReinH> I will provide moral support
12:31:46 <edwardk> i always forget about it til the weekend of the contest
12:31:50 <ReinH> no but seriously that would be epic
12:31:56 <edwardk> then sometimes i spend a few hours to just get the feel for the problem domain
12:31:57 <ReinH> if you are at all interested then I will bug you about it :)
12:32:15 <ReinH> last one just ran so it'll be a while
12:32:17 <edwardk> e.g. the orbital mechanics one was fun
12:32:53 <edwardk> optimizing it using hohmann transfers actually put me on the leaderboard for a while
12:33:04 <edwardk> then life intervened
12:33:43 <roconnor> I have never got the hand of controling integer approximations of mechanics.
12:33:51 <roconnor> I feel I need to learn some control theory
12:34:05 <MitchellSalad> hi, could someone please show me how to compose these two producers? http://lpaste.net/92802
12:34:11 <MitchellSalad> ima pipes newb
12:36:12 <ParahSailin> MitchellSalad: you want to feed the output of one into the input of another? then at least one of them cannot be a Producer
12:36:16 <donri> MitchellSalad: >> is composition for producers, no?
12:36:48 <levi> 2006 ICFP contest was epic.
12:36:56 <applikativ> MitchellSalad: note that these producers produce one thing only. a capitalize 'a' for example
12:36:59 <MitchellSalad> say, main = runEffect $ for P.stdinLn duplicate
12:37:10 <MitchellSalad> im trying to both duplicate and capitalize the input
12:37:36 <MitchellSalad> so that "foo" becomes "FOO\nFOO"
12:37:39 <ParahSailin> MitchellSalad: thats gonna be at least a Pipe, not a Producer
12:37:45 <poseid> when I have a structue { a: '…', b: [ '123', '456'] }, what is the operation to filter a list of that structure on the properties in b?
12:37:49 <applikativ> MitchellSalad: doesn't the think you just typed work?
12:38:07 <MitchellSalad> applikativ: it does but there's no capitalize
12:38:07 <ParahSailin> await >>= \q -> yield q >> yield q
12:38:38 <donri> MitchellSalad: a mere producer can't transform a stream
12:38:55 <poseid> hmm.. probably I am looking for a reject
12:38:59 <MitchellSalad> not even when sequenced with for/~> ?
12:39:13 <statusfailed> Is there an easy way to print binary data to stdout?
12:39:14 <applikativ> god i have to go, but for (P.stdin >-> Pipes.map (Prelude.map toUpper) ) duplicate would be one way
12:39:37 <statusfailed> I want to control the endianness ideally, but printing char8's one-by-one is fine for now
12:39:56 <MitchellSalad> hm, alright thanks, ill keep stepping through this tutorial
12:39:57 <edvo> MitchellSalad: for cat $ \s -> let cap = map toUpper s in cap ++ "\n" ++ cap
12:40:02 <statusfailed> or do I mean Word8. hm.
12:40:23 <levi> statusfailed: You must mean Word8, because Char8 is not a type.
12:40:26 <edvo> MitchellSalad: i meant  in yield (cap ++ "\n" ++ cap)
12:41:03 <MitchellSalad> I'm not seeing how this problem involves pipes, though. can't I just sequence these two producers together with ~>?
12:41:05 <statusfailed> levi: looks like ^^
12:41:13 <statusfailed> levi: is there a putWord8?
12:41:23 <MitchellSalad> similar to runEffect $ for stdinLn (duplicate ~> lift . putStrLn)
12:41:33 <levi> statusfailed: Char8 is the name of a package that lets you treat Word8 values as Char, though.
12:41:37 <MitchellSalad> except that the second producer produces Char, not String
12:41:55 <levi> String is [Char]
12:41:58 <statusfailed> levi: yeah, that's what I was looking at
12:41:59 <MitchellSalad> right
12:42:03 <statusfailed> levi: Char is 32-bit Unicode though
12:42:14 <statusfailed> I want to write bytes to stdout directly
12:42:37 <identity> Do you guys have any recommendations for libraries on hackage for processing images? Jpeg, png, bmp maybe. It needs to expose and allow one to manipulate the pixels themselves.
12:43:14 <geekosaur> JuicyPixels?
12:43:15 <levi> When you put a Char into a Word8 via the Char8 package, it truncates it to a Word8.
12:43:18 <donri> identity: people seem to like JuicyPixels
12:43:37 <statusfailed> levi: I have the Word8 already, i'm trying to write audio samples to stdout
12:43:42 <donri> MitchellSalad: you might be right it might be possible with for / ~>
12:44:15 * hackagebot happy 1.18.11 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.11 (SimonMarlow)
12:44:16 <levi> statusfailed: Ok, so you just need something to take Word8 -> IO () ?
12:44:21 <statusfailed> levi: yeah
12:44:56 <Raydiation> any idea why i get this: fatal error: IO.hs: No such file or directory
12:45:03 <Raydiation> is this a haskell default file?
12:45:21 <Raydiation> src/Data/Vault/Lazy.hs:6:0:
12:45:21 <Raydiation>      fatal error: IO.hs: No such file or directory
12:45:21 <Raydiation>      #include "IO.hs"
12:45:27 <statusfailed> levi: I can cons it actually
12:45:33 <applikativ> identity: juicypixels is pure haskell so of course it's highly loveable
12:45:35 <geekosaur> wat
12:45:36 <levi> statusfailed: That's putStr from Data.ByteString
12:46:20 <applikativ> MitchellSalad: isn't it something like yield . Prelude.map toUpper ~> duplicate
12:46:34 <identity> I had seen juicypixels, but I wasn't sure if there was a favorite, so I decided to ask. Thanks! I'll try them juicy pixels
12:46:44 <statusfailed> levi: yeah, putStr (cons myWord8 null)
12:46:47 <statusfailed> which is totes gross :p
12:47:01 <monochrom> statusfailed: do you mind putStr (singleton x)? :)
12:47:15 <statusfailed> er, not null
12:47:20 <statusfailed> monochrom: that's what I wanted :D
12:47:23 <monochrom> empty :)
12:47:24 <ocharles> identity: there is devil too
12:47:29 <ocharles> (devil bindings, that is)
12:47:50 <MitchellSalad> applikativ: but I want to use a (Char -> Producer Char IO ())
12:48:00 <applikativ> man those devil things are a nightmare on os x. e.g. they only make 2 formats or something
12:48:03 <MitchellSalad> yield . Prelude.map toUpper is String -> Producer String
12:48:28 <applikativ> MitchellSalad: right, I got sidetracked by putting P.stdinLn in front in my mind
12:48:49 <applikativ> but doesnt yield.toUpper~>duplicate typecheck?
12:48:59 <donri> MitchellSalad: you could probably use P.toList[M]
12:49:14 <levi> statusfailed: You might also be interested in Data.Binary
12:49:16 <applikativ> i'm adopting a fake compressed style to make pipes seem sexy like lens
12:49:26 <edwardk> hhahahahah
12:49:32 <donri> MitchellSalad: although not the way you've structured this...
12:50:05 <edwardk> clearly the key to lens' success was the elision of spaces making it socially acceptable to golf with
12:50:12 <statusfailed> levi: yes, this is pretty slow :p
12:50:17 <applikativ> yield.toUpper~>duplicate :: Producer Char m ()
12:50:23 <statusfailed> plus I need 24-bit little endian
12:50:32 <donri> MitchellSalad: i would probably change capitalize to a Pipe and then you can toList it
12:51:12 <applikativ> yield.toUpper~>duplicate :: Monad m => Char -> Producer Char m ()
12:51:13 <MitchellSalad> that may be the right way to do it, i have no idea, but having read only the Producer part of the pipes tutorial it does seem like a problem that can be solved using only producers
12:52:20 <levi> statusfailed: Data.Binary is almost certainly what you want if you are trying to control the byte-level representation of something in input/output streams.  Or something like Data.Binary, anyway.
12:52:29 <Elision> for some reason this channel highlights me a lot
12:52:45 <Elision> what is it with y'all and elision :?
12:52:47 <MitchellSalad> http://lpaste.net/92802
12:52:51 <applikativ> donri: why does he want to toList it? i missed something
12:53:08 <applikativ> elision++
12:53:38 <Elision> here and ##math
12:53:41 <tpsinnem> more sort-of-newbie questions: what's the standard way of getting a useful REPL session going for a haskell project with cabal-managed dependencies?
12:53:41 <Elision> weird
12:53:51 <applikativ> MitchellSalad: do you want to duplicate letters or lines?
12:53:58 <MitchellSalad> lines
12:53:58 <johnw> Elision: the reason being...
12:54:14 <sellout-> Elision: Does your client highlight on every “…”? ;)
12:54:19 <levi> statusfailed: It's got get/put functions for various size and endianness combinations, and a mechanism for building generic serialization to/from your higher-level types.
12:54:38 <applikativ> tpsinnem: well now theres 'cabal repl' in your 'cabal sandbox'ed directory
12:54:53 <applikativ> tpsinnem: not that i have figured out all theins and outs of it
12:55:08 <donri> MitchellSalad: i might be missing something i admit, but the obvious ways to do what you want is to either change capitalize to act on String, or, make them into Pipe so you get the proper compositions that pipes offer
12:55:31 <MitchellSalad> right, ok
12:55:32 <levi> I am loving cabal sandbox + add source
12:56:12 <MitchellSalad> yeah, if capitalize = yield . Prelude.map toUpper, then they would compose with ~>
12:56:31 <Elision> sellout-: people just use the word 'elision' a lot more than I'd expect
12:56:32 <applikativ> MitchellSalad: I TOLD YOU SO ;)
12:56:42 <Elision> for a channel of non-classics-majors
12:56:42 <MitchellSalad> i know!
12:57:19 <donri> MitchellSalad: runEffect $ stdinLn >-> toList capitalize >-> duplicate >-> stdoutLn
12:57:43 <statusfailed> levi: I'm just using Word16s now, but it looks good, thank you :)
12:58:55 <tpsinnem> applikativ: thanks. i guess i'll have to update my cabal itself first though
12:59:05 <donri> MitchellSalad: actually that might not do what you want after all...
12:59:34 <MitchellSalad> donri: i didnt try it, still reading the consumers part
12:59:41 <MitchellSalad> anyways thanks for the help
13:00:03 <donri> MitchellSalad: also, it won't even type check because i had misread the type of toList
13:00:08 <donri> MitchellSalad: so ignore me
13:00:57 <donri> MitchellSalad: (i think i thought it was like mapM_ yield, which could work but do the wrong thing)
13:01:56 <tpsinnem> should i be able to use 'cabal sandbox init' in a directory where i have already done a bunch of other cabal stuff? 'cabal init' and 'cabal install' etc.
13:02:05 <tpsinnem> .. and have things just work nicely
13:02:39 <donri> tpsinnem: did you try? if it fails, maybe try cabal clean first
13:07:58 <tikhon> tpsinnem: what other cabal things have you done there?
13:08:06 <tikhon> oh, never mind
13:08:11 <tikhon> misread your question
13:09:52 <Raydiation> can you compare type classes to magic methods in python? ie if you derive from object in python you can call len(yourObject) which is implemented by the __len__ method
13:10:48 <ericmoritz> Raydiation, sort of
13:11:04 <Raydiation> i see :) thanks
13:11:10 <tpsinnem> donri: haven't yet. was installing a current cabal version, and now doing it again because user and global installations were stepping on each others toes apparently
13:11:11 <donri> object implements __len__?
13:11:23 <ericmoritz> Raydiation, Python has some blessed methods that let you use objects like that but it isn't quite the same
13:12:08 <Twey> There's some overlap between typeclasses and interfaces
13:12:13 <ericmoritz> Type classes are more like interfaces
13:12:39 <Raydiation> donri: yes
13:12:42 <Iceland_jack> It's not that far off, __abs__, __add__, ... (Num), __cmp__ (Ord), __and__ (Bits), __hash__ (Hashable), __str__ (Show), etc.
13:12:43 <Twey> Python's ‘magic methods’ are of course just interfaces without compiler support
13:13:34 <donri> ignoring everything that makes haskell and python different, then yes, its "protocols" are close to type classes
13:13:54 <dissipate__> Twey: python has too much magic IMO. everything is straightforward if you don't touch the magic stuff, but once you do, things can get confusing.
13:15:09 <Raydiation> to implement the interfaces i just do: instance Ord MyType where ...
13:15:10 <Raydiation> right?
13:15:15 <Raydiation> for implementing Ord
13:15:29 <ericmoritz> dissipate__, as a professional Python developer that moonlights as a amateur Haskell/Erlang dev; I agree.  There's a lot of magic in those magic methods.  Basically hardcoded interfaces to the built-in functions
13:15:36 <Iceland_jack> Raydiation: Right
13:15:37 <Twey> Raydiation: But interfaces are restricted to dispatching on the first argument (the object instance); typeclasses also allow you to dispatch on e.g. the return value
13:15:55 <Twey> dissipate__: Probably, yes
13:15:58 <Raydiation> thanks
13:16:04 <donri> Raydiation: Ord you would usually let the compiler derive for you, though
13:16:07 <dissipate__> ericmoritz: is the stuff that is magic in python get exposed up front in haskell?
13:16:35 <Twey> dissipate__: But the magic exists for a reason; it seems characteristic of a language that has forgotton the second clause in ‘as simple as possible, but no simpler’
13:16:41 <Peaker> Python is mostly "single-dispatch", though, and type-classes go far beyond that
13:16:50 <Raydiation> is the IO monad a type class?
13:17:05 <ericmoritz> dissipate__, yeah, there's a 1-to-1 connection between a function's name and its implementation.  In Python len() is implemented using the magic __len__ method.  and __eq__, etc
13:17:06 <Twey> Raydiation: No, but there is an associated type class (MonadIO)
13:17:08 <donri> Raydiation: no, IO is a type that implements the Monad interface
13:17:21 <Peaker> Raydiation: no, it's an instance, or an abstract type, depending on which you mean
13:17:25 <ericmoritz> dissipate__, 1-to-1 in Haskell that is
13:17:48 <Peaker> ericmoritz: methods are functions too, and they can be implemented in many different instances
13:17:51 <Twey> dissipate__: There's no magic in Haskell.  :þ
13:18:04 <Twey> (FSVO ‘magic’)
13:18:07 <Peaker> The monomorphism restriction could be said to be magic, of the bad kind
13:18:07 <ericmoritz> dissipate__, in Python you have to know the secret methods in order to make generic code
13:18:24 <dissipate__> ericmoritz: yeah, the magic stuff, the lack of good multi-threading and just the junk that goes with OOP is turning me away from python for writing apps. great scripting language though.
13:18:34 <Peaker> In Python, various kinds of generic code are just not really possible/practical to make
13:18:38 <Twey> Peaker: Is the DMMR still standard?  I thought it was going to be off by default in H2010, but it still seems to be on in GHC
13:18:53 <Peaker> Twey: I think they just changed the default for ghci
13:18:58 <ericmoritz> dissipate__, the more and more I work with Haskell; the more and more Python looks slapped together
13:19:14 <Peaker> also, unary minus in Haskell is quite magical
13:19:15 <dissipate__> ericmoritz: that's a big turn off.
13:19:36 <Twey> There are some syntactic surprises, but nothing semantic
13:19:47 <dissipate__> ericmoritz: that's fine for 99.9% of scripting though, right?
13:20:10 <Twey> If unary minus is magic, it's the kind of magic cast by ugly demons with big claws to make everyone sad ☹
13:20:24 <Peaker> Twey: Well, the way memory retaining works in GHC is somewhat semantically magical
13:20:46 <Twey> Peaker: That's not something you generally think about, though
13:21:02 <Twey> Optimization is allowed to be magical
13:21:14 <Peaker> Twey: could say the same about Python's magic, possibly
13:21:28 <Twey> Peaker: Nope; Python's magic is required to implement the API you want
13:21:35 <Peaker> Twey: but the O() behavior of code is beyond the allowance of magic in optimization, IMO
13:21:49 <Peaker> constant optimizations can be afforded all manners of magic though
13:21:51 <ParahSailin> also a little magical how infix constructors must start with :
13:21:55 <Twey> (to be fair Python's is not really ‘magic’ either, just convention)
13:21:56 <ericmoritz> dissipate__, yeah Python is nice for quick hacks but starts to fall apart is projects grow in size and the worts of its abstractions start showing
13:22:39 <Twey> ParahSailin: If we're talking about syntactic magic, I've always found the case distinction magical to start with
13:23:06 <ericmoritz> dissipate__, I can't say if Haskell solves the project size problem; I haven't built a project in Haskell as large as what I work with day to day
13:23:19 <Twey> ParahSailin: I don't think the colon thing is significantly more magical than the general case of constructors having to start with a capital
13:23:33 <dissipate__> ericmoritz: have you read the paper 'Out of the Tar Pit'?
13:23:42 <ericmoritz> dissipate__, nope, I'll look into it
13:24:31 <dissipate__> ericmoritz: haskell and other FP languages like clojure solve a huge problem in large systems by eliminating unbridled mutable state.
13:25:22 <ericmoritz> mutable state isn't really our problem; it is project structure and the inablity to easily refactor code that is developed on by dozens of developers
13:25:37 <dissipate__> ericmoritz: pure functions and immutable data structures are a godsend compared to OOP and mutable state. as for abstractions, that matters too, but immutable state is a huge improvement in itself.
13:26:05 <Raydiation> is this how a monad in javascript would look like? https://dpaste.de/Qd1GQ/
13:26:14 <tikhon> To me, the case distinction makes a lot of sense: in other languages (especially Java), the case conventions are strong enough that they may as well be language features; I think it makes sense to actually support them in the language.
13:26:30 <mauke> Raydiation: how is that a monad?
13:26:37 <dissipate__> ericmoritz: have you heard of Uncle Bob's stuff on clean architecture?
13:26:42 <danilo2> Hi! Could someody tell me why I'm geting here an compile error? The compiler wants me to use UndecidableInstances, but I know , thay are dangerous: http://lpaste.net/92804
13:26:48 <Raydiation> mauke: no idea, trying to grasp the concept
13:26:49 <ericmoritz> dissipate__, nope
13:27:07 <mauke> Raydiation: that's just flip id, no?
13:27:26 <Raydiation> well its some kind of partial function application i guess
13:27:59 <dissipate__> ericmoritz: unfortunately, a lot of the material is OOP oriented but the part about the layer abstractions applies to any language: http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html
13:29:30 <ericmoritz> Raydiation, no this is: https://github.com/ericmoritz/async-compare/blob/master/node/firsts.js#L131
13:29:55 <mauke> ಠ_ಠ
13:30:08 <danilo2> I've got a question - If I'm sure, that there will be NO OTHER instance of "FClass (Vector a) ...", does using UndecidableInstances in this code is dangerous? : http://lpaste.net/92804
13:30:17 <Raydiation> ericmoritz: isnt this essentially the same?
13:30:41 <Raydiation> i mean i store a value in that function basically
13:30:53 <ericmoritz> Raydiation, oh, yeah I guess you're implementing an Identity monad
13:30:56 <Raydiation> so the next time i pass in a function that function will be called with that value
13:31:37 <Raydiation> i think this is called bind
13:32:08 <ericmoritz> Raydiation, you've implemented a bind factory; but yeah, that is essentially an Identity monad.
13:33:52 <donri> danilo2: undecidable instances aren't that dangerous to begin with?
13:33:52 <ericmoritz> Raydiation, your implementation may result is some non-idiomatic JS; monad(1)(f)(g) would be the same as m >>= f >>= g in Haskell
13:34:26 <Raydiation> i see
13:34:42 <ericmoritz> Raydiation, though I'm no expert on JS style ;)
13:35:39 <Raydiation> so whats the difference between this and partial function application
13:35:58 <danilo2> donri: I dont know - I'm asking to know more about them. I know certain conditions that they could be dangerous, but I'm prety sure, In my code these conditions will not happen (I'm generating Haskells code).
13:36:08 <ericmoritz> Raydiation, in this case, nothing
13:36:22 <danilo2> donri: Additional does using this flag slowes down the final code? (Maybe it is completely unrelateD)
13:36:36 <ericmoritz> Raydiation, but a monad is much more than just partial application
13:36:51 <Twey> dissipate__: Clojure doesn't eliminate mutable state, though :þ  It just discourages it.
13:37:01 <donri> danilo2: no i think at worst it slows down the compiler
13:37:18 <donri> danilo2: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
13:37:32 <Twey> (it doesn't even give you a way to tell whether a function is mutable or not; I hear this is effectively impossible to combine with Java interop)
13:37:53 <dissipate__> Twey: true, but isn't that an improvement over having it everywhere? i would rather have 1 function that has side effects than 200.
13:38:26 <dissipate__> Twey: side effects where you need them is a huge improvement in software design.
13:38:51 <jfischoff> I don't really see the problem with undecideable instances. Worse case your you get a compiler error, of is there something worse?
13:38:52 <MaidenJohn> hello guys
13:38:55 <MaidenJohn> i need help plz
13:39:04 <dissipate__> Twey: the paper 'Out of the Tar Pit' goes into more detail on this.
13:39:05 <jfischoff> what's up
13:39:16 <Twey> ericmoritz: Types give you a huge hand with refactoring.  If you write your types right in Haskell, you can have a pretty good level of confidence that when you fix all the type errors resulting from a refactor, the code should work.
13:39:42 <dissipate__> Twey: bottom line is Clojure and Haskell are both big improvements over more mainstream OOP languages.
13:39:43 <donri> danilo2: UndecidableInstances are widely used, i believe. for example mtl relies on them heavily
13:39:59 <MaidenJohn> i need pc games cracks or serial numbers any idea plz
13:40:12 <Twey> danilo2: I think you're getting the error because your instance uses ‘b → A (IO b)’ for the parameter b that is supposed to be fully determined by a
13:40:17 <donri> @where ops
13:40:17 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
13:40:17 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:40:17 <danilo2> donri: Thank you :) By the way - does anywhere exist a list of Haskell Extensions, which slowes down the final code OR are very dangerous and we should (almost) never use them (like Overlaping instances)
13:40:33 <ericmoritz> Twey, that is what I suspect; most of our errors in Python are type errors
13:40:52 <Twey> danilo2: The fact that it's a polymorphic type means that the type is *not* fully determined: the caller can choose ‘b’ at call-time
13:40:58 <dissipate__> ericmoritz: i'm interested in how the Clean Architecture translates in pure FP languages like Haskell.
13:41:02 <danilo2> Twey: Ok, I get it. So I'll stick with UndecidableInstances in this example :)
13:41:03 --- mode: ChanServ set +o geekosaur
13:41:15 <geekosaur> MaidenJohn, wrong channel
13:41:28 <MaidenJohn> do u know any channel plz ?
13:41:41 <danilo2> Twey: Ok, but as I understand, while compiling the code with -O2, the compiler would optimize it and nothing will be checked in runtime ?
13:41:42 <Raydiation> MaidenJohn: #hackorz
13:41:46 <donri> wrong network in fact
13:41:47 --- mode: ChanServ set +o mauke
13:41:47 --- kick: MaidenJohn was kicked by mauke (how did you get here)
13:41:50 <jfischoff> The more extensions you turn on the more bugs you find in GHC. Which is really a pain
13:42:17 <ericmoritz> Twey, and often it is a key missing from a chunk of JSON or a value being null when someone assume it would always be non-null
13:42:42 <Twey> dissipate__: Oh, to be sure it's an improvement, but it's not really comparable to what Haskell does.  The innovation in Haskell is not that it discourages mutability (Scheme's been doing that for years, after all) but that it *programmatically and composably* separates pure functions and impure actions and gives tools for working with the separation
13:43:25 --- mode: geekosaur set -o geekosaur
13:43:40 <donri> danilo2: duno, i think the general consensus is that people shouldn't be told about extensions so they don't think they should use them, which of course has the effect that they use anything GHC suggests on failure. so no i don't know of any such resource other than the ghc manual. :(
13:43:47 --- mode: mauke set -o mauke
13:44:01 <Twey> ericmoritz: IME most errors are type errors in Haskell if you spend the time to design your types right.
13:44:21 <wolf1oo> I'm somewhat new to the haskell state monad (and monad use in general), does anyone have any pointers? I have a parser (generated with happy) which needs to "save" the code string, for use in the error printing function. Any advice would be appreciated!
13:44:32 <dissipate__> Twey: interestingly the authors of 'Out of the Tar Pit' did not say Haskell was the ultimate solution. they suggested something called 'Functional Relational Programming'. i cannot assess if that's the solution or if Haskell is better.
13:45:08 <danilo2> donri: If I will ever be a "haskell master" I will write such document! :D This is one of the most important information to me, which I cannot find anywhere :)
13:45:29 <donri> danilo2: the ghc manual isn't *that* bad though...
13:45:38 <donri> user guide*
13:45:48 <Twey> ericmoritz: What ‘type error’ means in a language is entirely dependent upon the type system in the language.  In a dependently-typed language such as Agda, you can reduce *all* possible errors to type errors if you're so inclined.
13:46:29 <Twey> (with the occasional exception of unprovable non-termination)
13:46:39 <donri> i like how many people think all haskell does is catch at compile time what would be a TypeError exception in python
13:46:46 <donri> which almost never comes up in python
13:46:49 <danilo2> donri: I know, I started reading it. But I'm on the beginning yet (too much work, to little time ... ) :)
13:46:53 <ericmoritz> Twey, my definition is someone expected a variable to hold a value of a certain type and it ended up being something else.  The bain of dynamic typing ;)
13:47:25 <dissipate__> Twey: what's your opinion of Proof Oriented Programming? http://www.prooforientedprogramming.org/pop.html
13:47:38 <dissipate__> Twey: seems to go beyond even Haskell.
13:47:50 <ericmoritz> These are often runtime type errors though; data coming from an external source that I do not control
13:48:21 <Raydiation> ericmoritz: why do you return a maybe(null) if the value is not there? https://github.com/ericmoritz/async-compare/blob/master/node/firsts.js#L135 this blogpost doesnt do this http://modernjavascript.blogspot.co.at/2013/06/monads-in-plain-javascript.html
13:48:24 <ericmoritz> Though I suspect that Maybe and Either monads can help in this case
13:49:15 <ericmoritz> Raydiation, because I want to be able to chain the .bind() calls
13:49:23 <Raydiation> i see thanks
13:49:40 <donri> dissipate__: isn't that basically what dependently typed languages are about
13:49:49 <Brunoooo> Hi, Haskell beginner here. Does anyone know why the following doesn't work? http://pastebin.com/T6k2635c . I want to transform an Int list [1,2,3] to a string list ["-","--","---"]
13:49:51 <mauke> The paste T6k2635c has been copied to http://lpaste.net/92809
13:49:57 <Raydiation> maybe its a better idea to just start with javascript and functional programming
13:50:20 <Twey> ericmoritz: Well, yes, but what can be defined as a ‘type’ depends on the language.  ‘x exists’, ‘x holds a value’, ‘x holds an array’, ‘x holds an array of integers’, ‘x holds an array of 5 integers’, and ‘x holds an array of 5 integers all of which are between 12 and 17’ are all ‘types’ that can lead to type errors, but that type error indicates the breaking of a different level of assertion about your program.  Python only 
13:50:30 <mauke> Brunoooo: that can't be right because '-' is not a String
13:50:47 <dissipate__> donri: nope. read the site.
13:51:04 <Brunoooo> mauke: if you replicate a char, it becomes a string right?
13:51:12 <ericmoritz> Twey, I'm not disagreeing.  I was just clarifying what I meant.
13:51:24 <donri> Brunoooo: i think you want something like, printLine = map (`replicate` '-')
13:51:25 <mauke> Brunoooo: irrelevant
13:51:34 <Twey> ericmoritz: *nod* I was doing the same :þ
13:51:37 <dissipate__> donri: in proof oriented programming, you write a formal proof and then extract a working program from that proof. this is different from writing something in a typed language.
13:51:50 <donri> Brunoooo: and you want to change the type to [Int] -> [String]
13:51:58 <Twey> ericmoritz: Haskell will certainly help you fix ‘this was meant to be an integer’ bugs, but that's really only the start.
13:52:08 <dissipate__> donri: or rather just writing a program in a typed language. proof > program
13:52:11 <Twey> dissipate__: It's not, actually
13:52:31 <mauke> inb4 curry-howard
13:52:33 <scriptor> Brunoooo: your current function is taking a list of ints and returning a string, but it sounds like you want to return a list of strings instead
13:52:50 <Brunoooo> yes I made a mistake there, my final intention is to concatenate the result to one string. Thats why I used foldr instead of map. So [1,2,3] should become "------"
13:52:55 <donri> Twey: i think they're after a difference in mentality
13:53:01 * Twey nods.
13:53:03 <dissipate__> Twey: what do you mean? you have no opinion of POP?
13:53:17 <hpaste> goakley pasted “Type Filtering” at http://lpaste.net/92810
13:53:27 <goakley> I think I'm missing something basic here, could someone have a look at these few lines?  http://lpaste.net/92810
13:53:40 <ericmoritz> Twey, well the start is convincing others to use Haskell.  Sadly that is not going to happen on this project.  It is too large.  I'm stealing ideas like Maybe from Haskell to add protections against runtime typing issues though
13:54:08 <Twey> dissipate__: Writing a proof is exactly equivalent to writing a program: consistent dependently-typed languages *are* ‘Proof Tools’, and the process of compiling them *is* ‘Program Extraction’
13:54:19 <Clint> goakley: you're missing the TypeData -> Bool function?
13:54:47 <donri> > foldr ((++) . (`replicate` '-')) "" [1,2,3]
13:54:48 <lambdabot>   "------"
13:54:49 <Twey> dissipate__: My opinions on POP are exactly those on writing fully-specified dependently-typed programs :þ
13:55:09 <dissipate__> Twey: so when you write a program in Haskell you are 100% sure it is correct?
13:55:12 <Twey> (it's a great idea, but more work needs to be done to make it convenient)
13:55:17 <goakley> clint: Yes, but I'm not sure what to use for that function.  I feel like there's some sort of built in for that, but I can't figure it out.
13:55:29 <Twey> dissipate__: Haskell is not logically consistent
13:55:33 <benmachine> dissipate__: when you write a proof you are not 100% sure it is correct
13:55:36 <mauke> :t fix
13:55:38 <lambdabot> (a -> a) -> a
13:55:54 <benmachine> proofs have much better correctness properties than just reckoning something
13:55:58 <dissipate__> Twey: well, this might tickle your fancy (from the page): Fantasia is an open source project aimed at making Proof Oriented Programming a reality. The goal of Fantasia is to create a simple, easy, elegant, and complete environment for performing proofs. Also, Fantasia incorporates a very basic built-in extraction engine for converting proofs into python functions.
13:56:01 <benmachine> but don't think no-one ever makes mistakes in them
13:56:03 <donri> Brunoooo: ^ you need to include ++ and the base case (the empty list) or use foldr1
13:56:09 <scriptor> Brunoooo: replicate isn't really suited for a fold function, consider that fold is passing the function an accumulator (the string), and a list item (the number), replicate expects two ints
13:56:14 <quchen> dissipate__: Even if you write a proof for something, it may not be the proof for what you were trying to prove. "triple = (*2)" is the usual example.
13:56:16 <Raydiation> as for lifting, is this some kind of reverse decorator? i mean you run a function after a function has been run
13:56:27 <Twey> dissipate__: The interface does sound interesting
13:56:51 <Clint> goakley: pattern match on the constructor
13:57:27 <Twey> Raydiation: Lifting is not like decorators
13:57:33 <ericmoritz> dissipate__, is that like Coq?
13:57:37 <Twey> (in any intuitively-useful way)
13:57:38 <goakley> clint: Can one pattern match in a lambda, or do I need to define something separate?
13:57:53 <Clint> goakley: you can but you don't want to in this case
13:57:54 <Brunoooo> okay so I should take a different approach then. Here's the story better explained by the way: http://pastebin.com/DVubPKMr
13:57:58 <mauke> The paste DVubPKMr has been copied to http://lpaste.net/92811
13:57:59 <Twey> goakley: You can match it to a variable, but not deconstruct it
13:58:03 <quchen> > (\(a,b) -> a + b) (3, 4) -- goakley
13:58:04 <lambdabot>   7
13:58:17 <Raydiation> so for instance you always want to turn the result of a function into a maybe you use a lift function to not have to write Maybe(func(result))
13:58:23 <mauke> Brunoooo: concatMap
13:58:33 <donri> Brunoooo: foldr ((++) . (`replicate` '-')) "" [1,2,3]  -- if you really want to use foldr
13:58:35 <Twey> Raydiation: No
13:58:37 <Raydiation> s/result/in
13:58:54 <mauke> Brunoooo: also, foo xs = replicate (sum xs) '-'
13:58:57 <ericmoritz> Raydiation, no lift lets you take a non-monadic function a pass in a monad
13:58:57 <Twey> Raydiation: That doesn't even type; Maybe is a type constructor, which means it expects a type parameter.  func(result) is presumably supposed to be a value.
13:59:30 <donri> > [1,2,3] >>= flip replicate '-'
13:59:31 <lambdabot>   "------"
13:59:35 <ericmoritz> so think I want to do +1 to Just 1 (+1) returns a number
13:59:38 <Twey> lift strips one layer of monad transformers away to give you a value in the ‘inner’ monad.
13:59:50 <Twey> ericmoritz: That's fmap
13:59:59 <Raydiation> so lift always involves a monad?
14:00:11 <goakley> Clint: Pattern matching worked, wish there were something more generic though.  Thanks
14:00:12 <quchen> (There are many many lifts in Haskell. Some of them are called "lift", most aren't.)
14:00:18 <dissipate__> ericmoritz: i don't know. but extracting programs from proofs sounds very elegant to me.
14:00:19 <Twey> Raydiation: And a monad transformer, yes.  Unless you're using a significantly different meaning of ‘lift’ than is usual.
14:00:45 <dissipate__> ericmoritz: can you imagine telling your boss that you *proved* correctness before you even generated the program?
14:00:58 <quchen> Twey: fmap lifts a function in a Functor. There's liftAX, liftMX, lift from TH, lift from transformers, …
14:01:25 <quchen> I wouldn't say trafo-lift is the only "lift" function.
14:01:39 <tpsinnem> (ok thanks folks, 'cabal repl' in the new cabal seems to indeed work peachily)
14:01:49 <Twey> quchen: Oh, that kind of lift.
14:02:07 <quchen> Twey: I thought you were talking about what "lift" is in general
14:02:09 <Twey> I suspect Raydiation didn't mean that, though.
14:02:13 <quchen> Oh.
14:02:16 <quchen> Sorry then.
14:02:21 <Twey> No, I was talking about the function ‘lift’ :þ
14:02:34 <Raydiation> reading through some examples it looked like you could use any function instead of a Monad
14:02:35 <quchen> Oh. Well that one is fairly unique if you're talking about transformers.
14:02:45 <Twey> Raydiation: Functions are monads
14:02:58 <mauke> enjoy your confusion
14:03:01 <Twey> I mean, the function type (r →) is a monad
14:03:03 <Raydiation> xD
14:03:06 <Twey> Heh
14:04:29 <quchen> (r →) is the go-to Monad to confuse beginners.
14:04:33 <Raydiation> functions are monads in haskell? or in any other language
14:04:49 <ericmoritz> dissipate__, my boss would just say, "uhh.. that's good right?"
14:04:55 <mauke> the type ((->) e) is an instance of Monad, which is a typeclass
14:04:59 <Brunoooo> donri: that worked! Can you explain to me why the "" near the end was necessary?
14:05:01 <hpc> whereas, (a -> r) -> r is the go-to monad to confuse intermediate programmers
14:05:16 <mauke> hpc: but where do I put the foralls?
14:05:23 <quchen> You guys.
14:05:27 <ericmoritz> Twey, isn't fmap and liftM basically the same thing? Just one is for a Functor and the other is for a Monad
14:05:27 <Twey> Raydiation: Mathematically, functions are monads.  Haskell also defines a Monad instance for functions that (roughly?) corresponds to the mathematical definition.
14:05:34 <donri> Brunoooo: consider what would happen given an empty input list
14:05:47 <Brunoooo> ah thanks
14:05:52 <hpc> mauke: in true mathematician style, (a -> r) -> r, for all a, r
14:06:05 <Brunoooo> Im really new to haskell, thanks for the help :)
14:06:07 <mauke> well, that looks pretty boring
14:06:09 <Peaker> hpc: the "a" is usually a given
14:06:11 <mauke> @src Cont
14:06:12 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:06:12 <quchen> ericmoritz: liftM = fmap for types that are both Functor and Monad instances. Due to a historical accident, that's not enforced. However, if you violate that law, the Haskell police will put you in a jail with 1000 PHP programmers.
14:06:15 <Twey> ericmoritz: Yeah, to some extent fmap, liftM, and liftA are all ‘the same thing’
14:06:28 <Twey> Hence the name
14:06:34 <Twey> ‘lift’ is weird, though.
14:06:54 <hpc> bro, do you even liftM?
14:06:55 <Peaker> newtype Foo a = Foo { runFoo :: forall r. (a -> r) -> r }
14:07:06 <ystael> quchen: Hours later, the attendants remove 999 dead PHP programmers from the cell.  "They weren't type correct," the Haskell programmer explains sheepishly.
14:07:16 <Twey> Heheh.
14:07:18 <ystael> The lone survivor stares, twitching.
14:07:42 <Twey> ‘I never knew you could use a function like that’
14:07:42 <ericmoritz> Twey, oh lift not liftM; I assumed he was talking about liftM
14:08:15 <donri> Brunoooo: if you use foldr1 you don't need that empty string argument, but instead it will throw a nasty exception if the input list is empty
14:08:24 <Twey> (don't use foldr1 please)
14:08:36 <hpc> Brunoooo: or more specifically, it will throw an even nastier pure exception
14:08:53 <Twey> Also known as ‘it breaks’
14:08:54 <hpc> Brunoooo: which is even less fun than plain old regular IO exceptions (like every other language has)
14:08:58 <hpc> yes, that
14:09:00 <donri> yeah, you can't catch it except in IO
14:09:22 <hpc> pure exceptions occur at an unpredictable point in IO-land, is what makes it annoying
14:09:42 <quchen> hpc: At least they won't leave your program in an undefined state when you throw them from pure code.
14:09:45 <quchen> Could be worse.
14:10:16 <Twey> ‘It could be worse.  You could be writing C.’
14:10:34 <hpc> man, you don't even know
14:10:43 <hpc> by relative standards, C is very well specified
14:11:01 <Raydiation> you mean its clearly defined whats undefined
14:11:20 <quchen> Twey: https://www.youtube.com/watch?v=SJUhlRoBL8M
14:11:38 <haasn> does anybody else think “withSocketsDo $ do” is awfully redundant?
14:11:39 <Twey> I think a language that makes C look well-specified is not a language I want to know about
14:11:42 <haasn> would be cleaner to have “withSockets $ do”
14:11:46 <Twey> haasn: Right?!
14:12:04 * haasn .oO( withSocketsDon't )
14:12:09 <Twey> I'm pretty sure it could just be added automatically anyway
14:12:12 <hpc> haha
14:12:19 <Twey> I'm not sure why we write withSocketsDo
14:12:23 <dennis> hey guys
14:12:24 <monochrom> the best way to win is of course to avoid pure exceptions
14:12:28 <geekosaur> because windows needs it
14:12:33 <quchen> Twey: #ifdef __WIN__ do withSocketsDo $ do
14:12:45 <dennis> im playing around with criterion but i cant find any good tutorial
14:12:54 <Twey> geekosaur: But can't you just do it in the first sockets call?
14:12:56 <geekosaur> and the Do suffix makes sense if you're not following it with a do block but with a fucntion
14:13:00 <deggis> after one month of diving into world of ruby, i'd sometimes prefer writing web apps with C
14:13:02 <dennis> im currently using this: http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
14:13:16 <geekosaur> Twey, maybe there is a procedural version that works that way
14:13:22 <dennis> but the commands in it are not working because the options are not displayed by the help function
14:13:28 <geekosaur> withSocketsDo is a bracket
14:13:29 <dennis> so it seems that this options are not valid anymore^^
14:13:40 <shoret> deggis: why?
14:13:42 <geekosaur> makes sure winsock is properly cleaned up in case of exceptions
14:13:44 <RichyB> Twey, no, not really. You may be making millions of sockets calls; you don't want to be checking whether you've initialised the socket library or not yet on every single one of them.
14:13:47 <hpc> dennis: it's an edwardk library, there are no tutorials
14:13:50 <hpc> dennis: or docs
14:14:06 <Twey> RichyB: You probably won't be opening millions of sockets
14:14:06 <quchen> hpc: Criterion isn't by edwardk I think ..?
14:14:11 <monochrom> haasn: so are you just uncomfortable with the name? you can rename it, you know.
14:14:24 <hpc> oh, it's bos
14:14:25 <Twey> A boolean check doesn't seem terribly uncomfortable
14:14:26 <haasn> yes, it's just the name :)
14:14:35 <geekosaur> remember, windows networking does not work like unix, there'd be a lot of fake filehandles rotting after an exception, which would throw weird errors if touched afterward
14:14:36 <haasn> main = let withSockets = withSocketsDo in withSockets $ do ...
14:14:41 <RichyB> Twey, why wouldn't I? Haskell has things like web servers written with it.
14:14:50 <Twey> Then you close the bracket in the socket's finalizer (@geekosaur)
14:14:52 <dennis> and bos has also noc docs xD?
14:14:59 <quchen> haasn: This channel will not tolerate redundancies in this channel!
14:15:16 <donri> withSockets could make you think it takes a function Socket -> IO a
14:15:18 <RichyB> There is an argument that could be made that perhaps (withSocketsDo) could be done by the RTS behind your back, but it's not a _huge_ wart.
14:15:21 <acowley> Yeah we follow TCWNTRITC in this channel!
14:15:24 <hpc> i was thinking of trifecta
14:15:26 <deggis> shoret: there's just so many odd features (ok, many are because of rails). and then there's "features" like this http://weber.fi.eu.org/blog/Informatique/ugly_ruby.html?lang=en
14:15:27 <donri> i guess that'd be singular though
14:15:32 <Twey> RichyB: Because operating systems only support 65535 sockets :þ
14:15:56 <dennis> well if i remeber corrctly edward told me to use that criterion thing^^
14:16:05 <monochrom> naw, since "sockets" is plural, withSockets :: Traversable t => t Socket -> IO a :)
14:16:07 <dennis> anyone knows ho to print charts with the newest version?
14:16:24 <hpc> Twey: that's what VPNs are for!
14:16:27 <RichyB> Twey, fortunately that is not true.
14:16:44 <monochrom> err, Traversable t => (t Socket -> IO a) -> IO a !
14:16:47 <acowley> dennis: Just run your executable with --help
14:17:05 <int-e> hpc: ouch?
14:17:05 <acowley> dennis: You probably want, mybench -o charts.html
14:17:28 <Twey> RichyB: Hmm?  65535 Internet sockets, and Windows doesn't support local sockets anyway
14:17:35 <dennis> yes i actually did that and the -t option is the template option which is no png^^
14:17:47 <Twey> (obviously you wouldn't compile the check on non-Windows)
14:18:10 <dennis> ah that works...
14:18:34 <dennis> but can i save them as png?
14:18:49 <deggis> shoret: well, i had to have my 30 characters worth of outcry :) i like haskell programmers' attitude towards programming (and implementing actual stuff) more than i like ruby writers (so far). only my feeling
14:18:50 <Twey> Alternatively, compiler optimization: if the program uses sockets, wrap main in withSocketsDo.  No more checks; I don't know of many programs that repeatedly enable and disable sockets, anyway.
14:19:50 <luite_> Twey: but that would make every program depend on the network package?
14:20:01 <RichyB> Twey, the hard 64ki connections limit in TCP applies to a single client talking to a single server. Specifically, every concurrent connection must have a unique (source addr, source port, dest addr, dest port) tuple. For most servers (dest addr, dest port) is constant, so you can have up to 64*1024 connections from each client address.
14:20:43 <donri> clearly we need to allow libraries to export 'main' that is automatically run before the Main.main!
14:20:57 <luite_> donri: oh noes
14:21:07 <luite_> that reminds me of c++ woes
14:21:10 <hpc> woo static blocks!
14:21:11 <RichyB> You can quite happily write a Haskell program that holds open one hundred thousand TCP sockets simultaneously. I can't remember clearly but I think that I've done it myself for fun at least once.
14:21:31 <luite_> donri: in which order, and how do you handle errors?
14:21:58 <donri> luite_: i'm gonna go with "random" and "not".
14:22:01 <Twey> luite_: Only ones that use sockets
14:22:04 <RichyB> Twey, yeah, I'd go with that solution. "If the program uses sockets, wrap main in withSocketsDo." The only potential downside is FFI safety when mixing Haskell with other code that might expect to initialise WinSock behind your back?
14:22:10 <Twey> (or network, if that's your thing)
14:22:38 <luite_> Twey: right, in that case it does indeed look much like static initializers
14:22:39 <RichyB> Pretty unlikely though because it's not awfully common to write Haskell libraries and then call them from C programs instead of the other way around.
14:22:47 <RichyB> *The only potential downside that I can think of right now.
14:24:38 <Twey> RichyB: You need to call a Haskell RTS initialization function when doing that anyway — the RTS can put the socket stuff in there
14:24:52 <donri> Twey: hey maybe we could wrap all socket functions in withSocketsDo and use stream fusion to optimize it away!
14:25:09 <monochrom> onoes
14:25:21 <luite> donri: hehe you're the optimistic type eh
14:25:22 <Twey> donri: I don't think stream fusion applies to IO :þ
14:25:29 <RichyB> Twey, I'd buy that.
14:25:51 <hpc> couldn't we just always initialize the socket system?
14:25:52 <donri> Twey: so just unsafePerformIO them all!
14:25:53 <luite> Twey: clearly a monad is the wrong abstraction and we need some fusable stream instead
14:25:56 <geekosaur> and it wouldn;t work anyway as the socket ceases to exist outside withSocketsDo. miss one "optimize away" and you are screwed
14:26:01 <applikativ> tpsinnem: are you figuring cabal sandbox/repl out?
14:26:04 <Twey> Hahaha
14:26:32 <donri> geekosaur: oh come on this is only for windows, no one expects things to run bug free there anyway
14:27:06 * Twey laughs.
14:29:02 <applikativ> the vector Stream type can take the form Stream IO a, Twey; I'm not sure how you could leverage that to work with anything but mutable arrays though ...
14:29:05 <tpsinnem> applicative: yeah, i didn't have much time to play with it yet but so far it indeed just works now
14:29:18 <benmachine> cf. Torvalds, 'When you say, "I wrote a program that crashed Windows," people just stare at you blankly and say, "Hey, I got those with the system, /for free/."'
14:29:19 <applikativ> oh cool.
14:29:21 <tpsinnem> uhm
14:29:28 <tpsinnem> applikativ, not applicative  :)
14:29:49 * benmachine somehow read applikativ as talking about Stream IO Twey
14:30:05 <applikativ> tpsinnem: i was just going to point out that in the main directory of a file with .cabal and a sandbox, 'cabal repl' should open ghci with everything available qualifid
14:30:15 <applikativ> oh i'm applikativ again
14:30:23 <tpsinnem> yeah
14:31:08 <applikative> something mysterious going on. i forgot my freenode login anyway
14:31:39 <hpc> i just have a /hpc ident alias
14:32:07 <donri> i authenticate with SASL like a real man
14:32:11 <applikative> Stream IO Twey is a perfectly good type; MVector Twey is more difficult
14:34:37 <monochrom> "Stream IO Twey" is the best thing since monad transformers
14:36:22 <dcoutts_> applikative: I forget, was it you earlier who noticed that the email on the beta hackage was not working? Anyway, it should be fixed now so worth trying it again.
14:36:33 <applikative> okay dcoutts_
14:37:58 <applikative> dcoutts_: Server error: sendmail exited with error code ExitFailure 1
14:38:06 <dcoutts_> heh
14:38:22 * dcoutts_ admits he only noticed that ssmtp was installed, didn't try it
14:38:30 <applikative> let me try a less bizarre email account name than what_is_it_to_do_anything etc
14:39:05 <applikative> Server error: sendmail exited with error code ExitFailure 1
14:39:13 * dcoutts_ tries...
14:39:19 <monochrom> "Server error: what_is_it_to_do_anything is too long" :)
14:40:09 <applikative> all of my addresses are bad; another 'practical.wisdom' is taken for new-age or maybe 12 step spam, when it makes perfect sense in my peculiar case
14:40:25 <applikative> not that i possess any
14:43:55 <applikative> what happened to MitchellSalad his pipes questions were pitched to approximately my level ;)
14:45:18 <applikative> what are the grades of comprehension here, noob, Tenderfoot, ...?
14:51:08 * Twey has been streamed
14:52:42 <haasn> rest in pieces
14:53:34 <dcoutts_> applikative: ok, we've worked out the problem, will solve it eventually
14:53:58 <dcoutts_> we were relaying email to haskell.org, but it's rejecting relaying (quite rightly in general)
14:56:06 <applikative> oh i see, dcoutts_
14:57:40 <applikative> are you sure its not Dr Patterson who's not rejecting my mail?
14:57:48 <applikative> or is who is rather.
14:58:11 <monochrom> hehe
14:58:37 <applikative> I'm convinced he has something against me; and he's probably right.
14:59:22 <acowley> You keep misspelling his name. Might not help.
14:59:29 <applikative> uh oh
14:59:42 <applikative> oh how interesting
15:00:13 <applikative> @remember It's Ross Paterson, not Ross Patterson, you fool!
15:00:13 <lambdabot> Done.
15:00:26 <applikative> oh, i wanted it to say it would never forget
15:00:32 <dcoutts_> applikative: yes I'm sure :-)
15:00:59 <dcoutts_> sendmail: RCPT TO:<foo@example.com> (550 relay not permitted)
15:00:59 <dcoutts_> *** Exception: sendmail exited with error code ExitFailure 1
15:01:24 <donri> @quote It's
15:01:24 <lambdabot> It's says: Ross Paterson, not Ross Patterson, you fool!
15:01:26 <monochrom> um... last time I complained that someone was using @remember wrong, he argued back. so I'm not doing it again.
15:01:31 <dcoutts_> applikative: we've got ssmtp configured to relay to haskell.org, and it's the haskell.org smtp server that rejects with "550 relay not permitted"
15:01:45 <applikative> hhah ok i will leave it to you to express my intention donri
15:02:01 <benmachine> @forget It's Ross Paterson, not Ross Patterson, you fool!
15:02:02 <lambdabot> Done.
15:02:20 <quchen> What's the appropriate place to propose a Haddock change? There doesn't seem to be a dedicated mailing list here http://www.haskell.org/mailman/listinfo
15:02:36 <acowley> Doesn't it have its own trac?
15:02:41 <quchen> It does
15:02:53 <applikative> @remember applicative Note to self: It's Ross Paterson not Ross Patterson, you fool!
15:02:53 <lambdabot> It is forever etched in my memory.
15:03:03 <applikative> @quote Ross
15:03:04 <lambdabot> praetorian42 says: I have yet to come across a scenario where compile-time type checking is a worthwhile substitute for reasonably thought-out dynamic code
15:03:14 <quchen> Opening a ticket without any discussion isn't how GHC proposals work, so I thought I should ask some list about it before
15:03:14 <applikative> @quote Patterson
15:03:14 <lambdabot> applicative says: Note to self: It's Ross Paterson not Ross Patterson, you fool!
15:03:21 <acowley> Yeah
15:03:28 <shachaf> I think it's considered bad form to @remember yourself.
15:03:41 <benmachine> shachaf: in this case it doesn't seem to be for humour
15:03:46 <applikative> shachaf: yes it was a technical problem, i'm hoping donri will work around it
15:04:06 <acowley> quchen: I guess it depends on how specific the proposal is. You could start by trying it out here, and see if shachaf knows if its already a lens combinator. Then try the cafe if it's a big change, etc.
15:04:14 <shachaf> help
15:04:26 <monochrom> oh tricky, "across" contains "ross"
15:04:31 <quchen> shachaf: Is there a lens combinator for adding type signatures to the Haddock index overview? :-D
15:04:57 <shachaf> That depends. What's a combinator?
15:05:12 <applikative> actually I should attribute it to acowly
15:05:22 <acowley> You're just not good with names, are you?
15:05:40 <acowley> shachaf: It's a lens thing. Pretty obscure.
15:05:52 <applikative> @forget applicative Note to self: It's Ross Paterson not Ross Patterson, you fool!
15:05:52 <lambdabot> Done.
15:06:01 <shachaf> applikative: This is a good state.
15:06:03 <applikative> acowley: oh god.
15:06:04 <shachaf> Don't @remember it now.
15:06:07 <quchen> Oh, there *is* a mailing list, the reference just isn't on the main Haskell mailing list overview.
15:06:25 <monochrom> you can use @tell :)
15:06:50 <applikative> i tell Ross Paterson how to spell his name?
15:07:05 <haasn> I somehow don't think @remember will help you remember things.
15:07:11 <applikative> what's a good state shachaf ?
15:07:16 <acowley> Yes, otherwise people will always have doubt about the first vowel sound.
15:08:00 <monochrom> no, you tell yourself. :)
15:08:39 <monochrom> there is also @where :)
15:08:46 <applikative> haasn: no, but a few erroneous @remembers and @forgets might help with a spelling issue
15:09:50 <applikative> haasn: I was merely attempting to express to acowlie that I wouldn't forget the spelling of Paterson's name
15:10:17 <acowley> :P
15:10:40 <haasn> what's wrong with “acowley: I won't forget the spelling of Paterson's name again”?
15:10:43 <monochrom> I don't mind misspellings.
15:10:55 <acowley> trichromatic: That's lucky
15:10:57 <applikative> haasn: probably nothing?
15:11:17 <applikative> multichrom, very kind of you
15:11:25 * monochrom bows!
15:11:27 <applikative> monotone
15:11:52 <monochrom> monochromatic restriction
15:12:31 <monochrom> "hi, what does --haddock-hyperlink-source does under the monochromatic restriction?" :)
15:13:06 <applikative> it means that the haddocks are printed in black on a back background
15:13:15 <monochrom> \∩/
15:13:17 <applikative> black background
15:13:32 <acowley> The dreaded monochrom restriction is an alpha equivalence among all IRC nicks. We are #haskell.
15:31:22 * hackagebot tconfig 0.5.2 - Simple text configuration file parser library.  http://hackage.haskell.org/package/tconfig-0.5.2 (MariusGhita)
15:40:03 <icarus127> What are the practical differences between Data.Map from containers and Data.HashMap.Lazy from unordered-containers?
15:40:45 <Peaker> requiring Ord rather than Hashable for one..
15:41:02 <copumpkin> icarus12: Data.Map allows you to do ordery things with it
15:41:12 <copumpkin> like taking efficient ranges and finding the min/max in log time
15:42:27 <icarus127> Ah, right I see those in the API now
15:42:28 <icarus127> thanks
15:49:19 <dennis> got another question to criterion. Is it possible to have something like: bench "myname" $ whnf (functionToTest (generateValues)) 1 and exclude the function generateValues from the testing?
16:02:12 <SrPx> Do you guys have any argument of authority supporting haskell? Like someone famous, influent or important. I guess this is the only thing that works with some people...
16:03:12 <ion> John Carmack, kind of
16:04:00 <Peaker> why does http://hackage.haskell.org/packages/archive/unix/2.6.0.1/doc/html/System-Posix-DynamicLinker.html#v:dlsym <-- return a FunPtr? dlsym can be used with functions and non-functions...
16:05:16 <Fuuzetsu> SrPx: I guess that depends on who _you_ consider famous, influential or important.
16:05:20 <Peaker> luckily, castFunPtrToPtr exists
16:05:37 <SrPx> Fuuzetsu: any suggetion?
16:06:06 <SrPx> Peaker: pointers in Haskell!?????????!!
16:06:31 <Cale> SrPx: of course
16:06:43 <Fuuzetsu> Cale is famous and influential.
16:06:57 <Fuuzetsu> In some circles.
16:07:50 <sclv> eric meijer
16:07:51 <benmachine> Peaker: what's not fun about dlsym? (ha ha ha)
16:07:59 <SrPx> Fuuzetsu: okay. I'll update my definition to: billionaire, highly influential researcher, CEO/Founder/etc of a big business, etc etc
16:08:10 <Peaker> SrPx: Haskell has a C FFI, and re-exposes all of C's low-level thingies
16:11:31 <Cale> Simon Peyton Jones is a highly influential researcher ;)
16:11:32 <SrPx> cmon that is the problem with mathy people, you have to define everything
16:11:32 <sclv> SrPx: eric meijer has spoken well of haskell, and played a role in it over years.
16:11:32 <sclv> he's as highly influential as cs researchers get
16:11:32 <sclv> doug mcillroy is also a declared haskell fan
16:11:32 <sclv> (inventor of unix pipes, and so arguably a bit influential)
16:11:32 <sclv> honestly billionaire doesn't/shouldn't provide any authority. like if trump endorsed haskell i would hardly find that compelling
16:11:32 <sclv> 
16:11:32 <Dodek> i'd be surprised if more than a handful of billionaires knew what haskell is
16:11:32 <sclv> lennart likes haskell, i hear. he's pretty influential!
16:11:32 <copumpkin> if someone would be convinced by a billionaire endorsing haskell, I don't think they're worth your time to convince
16:11:32 * hackagebot hopenpgp-tools 0.0.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.0.1 (ClintAdams)
16:17:01 <HugoDaniel> im a hundrionaire, and i like haskell
16:18:28 <Twey> sclv: Lennart Poettering likes Haskell?
16:18:50 * Twey starts looking for a new favourite language that doesn't have its head on the chopping block
16:18:55 <sclv> yeah and simon cowell or something i heard
16:21:04 <applikativ> oh macilroy has that charming library where is it
16:21:47 <applikativ> ah here with a paper attached http://www.cs.dartmouth.edu/~doug/powser.html
16:22:32 <applikativ> i think he's not a billionaire though
16:27:54 <emmp> hey everyone, is there a way in emacs' haskell-mode to include expressions to be evaluated on file load?
16:28:18 <emmp> I get "Parse error: naked expression at top level"
16:31:26 <tabemann> umm there's a reason it 's a parse error
16:31:35 <tabemann> you can't *have* naked expressions at top level
16:32:14 <emmp> yes, I understand, bust I want to evaluate a part of the file on ghci
16:32:21 <emmp> so that I don't have to switch buffers
16:32:40 <emmp> and type in the expressions in the REPL
16:33:51 <emmp> I don't know if I'm clear.
16:34:21 <ekipan> I don't know emacs, and this doesn't fix your problem, but giving your expression a toplevel name means you won't have to retype the whole thing each time at least
16:35:04 <emmp> good idea.
16:35:09 <emmp> thanks
16:35:24 <ekipan> I would assume there's a way to order emacs to load ghci in a buffer and evaluate that name each time you reload your file
16:35:59 <emmp> evaluate a single line, yes, that would be very useful.
16:36:51 <ekipan> maybe even a job for your ghci dotfile if you want it even outside emacs
16:37:50 <danilo2> Hello :) Is there a way in Hasell to define a typeclass "class X a where f :: a -> a" and create an instance of this class, BUT: define the method "f" in such way, that if the instance will be matched, the compiler will print my custom error message (during the compilation stage)?
16:38:44 <latro`a_> I don't think you can make GHC print a custom error at compile time in the first place
16:38:56 <enthropy> danilo2: you can have a context that won't be satisfied
16:39:22 <enthropy>  instance YouAreMakingATerribleMistake a => X a
16:39:36 <enthropy> and have no instances of the class YouAreMakingATerribleMistake
16:40:44 <enthropy> probably people can see through the error message "suggested fix: add instance YouAreMakingATerribleMistake Int"
16:40:48 <danilo2> enthropy, latero`a_ : Thank you, I know I can have a context, but I would love to replace somehow the error message - I'm translating a "pseudocode" to haskell code and it would be a lot clerer if the error will be replaced (It is probably not possible that way, but I was hoping to get an suprising answer :) )
16:40:58 <byorgey> danilo2: this is a feature which many people developing embedded domain-specific languages would love to have
16:41:04 <byorgey> it is not possible right now.
16:41:27 <danilo2> enthropy, latero`a_, byorgey: Is it maybe possible using GHC Api?
16:41:48 <enthropy> you can process those error messages that contain YouAreMakingATerribleMistake
16:42:00 <byorgey> danilo2: not in any sane way that I know of.
16:42:13 <danilo2> enthropy: Yeah, that is a good solution right now :) Thank you :)
16:42:39 <enthropy> or just leave them as-is... there's not that much to translate
16:42:47 <byorgey> danilo2: however, you will be glad to hear that a PhD student is working on this
16:43:03 <monochrom> I am not sure that is good or bad, haha
16:43:03 <enthropy> if you have -XDataKinds, you can put the error message as a string
16:43:04 <byorgey> under Jurriaan Hage at Utrecht
16:43:05 <danilo2> byorgey: I'm very happy to hear that!
16:43:28 <danilo2> enthropy: really? how?
16:43:53 <NihilistDandy> byorgey: I've been trying out your code golf assignment. That first one's pretty rough for the second week of classes :D
16:43:56 <monochrom> it has a high-probability implication of "will die off after he/she graduates"
16:44:25 <byorgey> monochrom: well, that's true, sadly.
16:44:32 <byorgey> but it is still better than no one working on it.
16:44:58 <NihilistDandy> But then I saw the mind-blowing lens thing that ekmett wrote for it, and now I'm trying to wrap my head around that
16:45:00 <byorgey> so I don't see how it can possibly be bad.
16:45:03 <danilo2> byorgey: Is it open source? Can we test it one day?
16:45:05 <byorgey> just good with very low probability.
16:45:11 <byorgey> danilo2: I have no idea.
16:45:31 <byorgey> I don't even know the name of the PhD student.  Just that a position for working on this problem was advertised and filled.
16:45:37 <monochrom> relatedly, HaRe has just risen again
16:45:38 <hpaste> enthropy pasted “danlio” at http://lpaste.net/92813
16:46:09 <enthropy> danlio2 ^^ look there
16:47:00 <danilo2> enthropy: Thank you for this example! It is the best solution so far :) I'm starting using it right now! :)
16:47:32 <enthropy> well I don't think you're likely to be able to do much string processing there
16:48:02 <byorgey> enthropy: haha, nice
16:48:35 <danilo2> enthropy: Ok, but for now it is everything I need :) In the future I will dig into GHC API - "Maybe" I will find another solution for this :)
16:50:31 <byorgey> I don't think the GHC API will help very much.
16:50:40 <enthropy> danilo2: I'm not sure why that one only prints an error if you try to use a
16:51:14 <enthropy> seems like a -fdefer-type-errors is happening when it shouldn't
16:53:36 <danilo2> enthropy: I didn't see such error - I copied the example and trying to use "a" in "main" and getting "custom error message"
16:54:05 <enthropy> I mean if you just have `a' as a top-level definition
16:54:11 <enthropy> and do nothing with it
16:54:32 * edwardk waves hello.
16:54:51 <danilo2> entrhopy: ah, I see
16:55:01 <danilo2> byorgey: You're probably right, but I still need GHC API to do some work. By the way - I have a question connected to GHC API, which I will try to solve in one month from now or something like that:
16:55:09 <edwardk> i'm sitting here trying to devise an algorithm for computing a crc monoidally, and i think i've got it down to one missing step.
16:55:44 <edwardk> anybody here familiar with polynomial division in that setting?
16:56:44 <danilo2> Right now I'm generating Haskell code and I have to create a lot of typeclasses containing one method (because the program is generating a lot of different modules, all defining datatypes, which implements the same type classes). The uestion is - Can I somehow using GHC API "fake" the existence of these files? I mean
16:57:09 <enthropy> why can't you have real files?
16:57:16 <danilo2> Simply tell GHC that if it is searching for A/<name>.hs file it will find there a typeclass <name> ?
16:57:54 <edwardk> the two properties i'm looking to exploit is the notion of zero-blindness which drives the choice of 'initial xor' for real CRCs: crc 0 (replicate n 0 ++ a) = crc 0 a; and the linearity-like condition that all true CRCs satisfy: crc r1 a1 `xor` crc r2 a2 = crc (xor r1 r2, xor a1 a2)
16:57:56 <arkeet> why not generate those with TH?
16:58:20 <danilo2> enthropy: I can, but in very bad case It will generate (lets say) 100 files. Each of threm HAS TO be registered in cabal as a library (because other libraries would use it - AS A COMMON typeclass) :( (oh, maybe this is related to cabal api?)
16:58:52 <arkeet> why do they need to be in separate files?
16:59:08 <enthropy> somewhere inside Distribution.Simple is something for parsing cabal files
17:00:18 <danilo2> arkeet: because they are like function names. So It is simply impossible to generate in one file all possible function names. So lets say different users are generating different libraries, but if one library uses A.hs (which defines typeclass A), and other uses creates other library which uses A.hs then these typeclasses should be considered THE SAME typeclass
17:00:39 * arkeet isn't following
17:01:17 <danilo2> enthropy: Ok, I till look into it but in few weeks from now :( I've got too much current task to move forward with this one
17:01:22 <danilo2> enthropy: Than you :)
17:01:38 * enthropy did something for cabal files in http://hackage.haskell.org/package/module-management
17:01:52 <enthropy> hidden in the scripts/ bit that's not exported there
17:02:16 <edwardk> so crc r (a1 ++ a2) = crc r ((a1 ++ replicate (length a2) 0) `xor` (replicate (length a1) 0 ++ a2)) -- if we switch to ^ for replicate and + for xor to reduce the pain then we can factor that using blindness and linearity into   crc(crc(r,0^k1) + crc(0,a1), 0^k2) + crc(0,a2)
17:03:12 <edwardk> that means all i need is the crc from a fixed initial condition and the ability to quickly calculate a crc(r,0^k) the crc from some initial state r applied to a string of k 0's
17:03:19 <edwardk> so now i need to find a way to compute that quickly
17:03:26 <danilo2> enthropy: Than you! I'll look there :)
17:03:36 <edwardk> if i can do that, then the monoid itself is pretty cheap.
17:03:50 <Raydiation> hm, i think i understood the IO monad http://www.youtube.com/watch?v=z0N1aZ6SnBk
17:03:51 <edwardk> and you could then calculate crc's off a fingertree incrementally, etc.
17:03:58 <Raydiation> its basically like dependency injection
17:04:05 <danilo2> enthropy: Could you please tell me one mor thing? what does mean  ":: Symbol" in yours example "class Failure (a :: Symbol)" ?
17:04:11 <edwardk> anybody following? =)
17:04:13 <Raydiation> you need to pass in dependencies into the function
17:04:27 <arkeet> danilo2: that's a kind signature.
17:04:38 <arkeet> saying a has kind Symbol.
17:04:49 <danilo2> akreet: ah, ok
17:04:51 <arkeet> ordinary types have kind *
17:05:21 <danilo2> arkeet: I know, that ordinary have *, but what is "Symbol" then?
17:05:26 <arkeet> it's a kind.
17:05:34 <arkeet> its members are type-level strings.
17:06:11 <danilo2> arkeet: Oh I didnt see it ocmes from the import. So the symbol is simply *
17:06:23 <arkeet> no
17:06:24 <danilo2> akreet: Everything's clear now :) thanks :)
17:06:27 <arkeet> =(
17:06:49 <arkeet> but yes, Symbol is declared in GHC.TypeLits
17:06:54 <arkeet> or something
17:06:59 <Raydiation> so basically all the bind operators like >>= make sure that the IO stuff gets evaluated
17:07:25 <joelteon> in order, specifically
17:07:36 <Raydiation> is this lazy btw?
17:07:54 <joelteon> it's up to you
17:07:57 <joelteon> but lazy by default, yes
17:08:07 <Peaker> Raydiation: evaluation isn't the issue, >>= gives order to the composition of first class actions. not considered "evaluations"
17:08:38 <Raydiation> isnt the order defined anyways?
17:08:49 <danilo2> arkeet: hmm So Symbol is defined as datatype in GHC.TypeList and it is not a DataTypy, but it is a somehow special "Kind" ?
17:08:58 <Raydiation> i mean if i combine f and g into f(g()) the order is given right?
17:09:02 <arkeet> danilo2: there is some GHC magic, yes.
17:09:14 <joelteon> Raydiation: you can't do that with IO
17:09:14 <Peaker> Raydiation: nope, unlike most langs Haskell has no built in ordering rules
17:09:20 <danilo2> arkeet: heh :) I love GHC magic :)
17:09:21 <joelteon> oh, and that
17:09:46 <Peaker> Raydiation: either f or g could be first
17:09:49 <Raydiation> is there a reason why the order is not defined?
17:10:12 <Peaker> Raydiation: because it enables optimzations, gives compilers freedom
17:10:26 <Raydiation> oh nice
17:10:41 <Raydiation> so basically if everything was evaluated in order, we wouldnt need the IO monad?
17:10:48 <Peaker> the only thing that is defined is non-strictness -- and that may affect evaluation order strategies
17:11:21 <Peaker> Raydiation: well, we'd have 1 less reason to have it, but there are other compelling reasons
17:11:58 <Raydiation> like making side effects obvious?
17:12:04 <Raydiation> in the type sig?
17:12:11 <Peaker> Raydiation: yep
17:12:52 <Raydiation> what kind of optimizations can you do in the compiler btw?
17:14:28 <Peaker> Raydiation: I'm not sure, maybe someone else has examples handy
17:14:57 <Raydiation> stuff like check if a function is used a lot in various other functions and use more agressive optimizations?
17:15:06 <Raydiation> although this is normally interesting for JITs right?
17:16:21 <Peaker> Raydiation: I think some of the parallelism infrastructure (thunk eval) relies on it
17:16:34 <ekipan> > let x = "abc" ++ x in take 8 x -- non-strictness allows more programs to have valid values
17:16:36 <lambdabot>   "abcabcab"
17:16:50 <Peaker> e.g: in corner cases, the RTS might doubly-evaluate same thunk in 2 threads
17:17:07 <Peaker> but it doesn't matter because eval order isn't specified
17:17:07 <ekipan> compare: String x() { return "abc" + x(); }
17:17:45 <Peaker> ekipan: but you could say "lazy", why say "non-strict" and leave eval order unspecified?
17:18:33 <ekipan> haskell is specified as non-strict, laziness is an implementation detail
17:18:52 <Raydiation> iirc >>= is defined in haskell. How do you write a function that enforces order?
17:19:13 <Peaker> ekipan: the question is what advantages this yields over specifying it's lazy and having predictable eval order
17:19:26 <ekipan> the definition of bind (>>=) for the IO type is not expressible in Haskell, it's built in as a standard library
17:19:35 <Peaker> Raydiation: consider (:)
17:19:43 <Peaker> Raydiation: it enforces order
17:19:47 <ekipan> and that's because the IO type itself is abstract
17:19:52 <Peaker> just not *evaluation* order
17:20:26 <Raydiation> thanks
17:21:08 <ekipan> the IO type (in specific) is what's special, the Monad typeclass isn't all that special
17:21:26 <ekipan> aside from do notation syntax, which isn't actually neccessary
17:21:29 <Raydiation> monad is more like a convenience thing?
17:21:36 <Raydiation> that avoids repetition?
17:22:03 <Peaker> Yeah, a whole lot of repetition
17:22:16 <ekipan> indeed, it allows a library of functions that work on all monads, without caring how they are implemented
17:22:24 <Peaker> more than convenience... common vocabulary, laws, ..
17:22:25 <ekipan> @src sequence -- like this for instance
17:22:25 <lambdabot> Source not found. I am sorry.
17:22:30 <ekipan> dur
17:22:46 <Peaker> -- not accepted apparently?
17:22:52 <ekipan> @src sequence
17:22:52 <lambdabot> sequence []     = return []
17:22:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:22:52 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:22:54 <geekosaur> probably not; it's a dumb plugin
17:23:14 <ekipan> the semicolons in do notation desugar to ordinary applications of the (>>=) bind function
17:24:13 <ekipan> sequence (x:xs) = x >>= (\v -> sequence xs -> (\vs -> return (v:vs)))
17:24:19 <Peaker> btw, most of Control.Monad belongs in Control.Applicative, will this be addressed in the Applicative migration?
17:24:47 <geekosaur> not immediately, I imagine
17:24:54 <applikativ> isnt the 'migration' not supposed to break everything on hackage?
17:25:02 <geekosaur> probably need several versions to avoid breaking everything in existence, yeh
17:25:06 <latro`a_> ekipan: pretty sure there's a typo there
17:25:09 <Peaker> it can be reexported
17:25:11 <latro`a_> because you have two -> in the same scope
17:25:20 <latro`a_> the second one is >>= iirc
17:25:56 <ekipan> whoops
17:28:23 <ekipan> @undo sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:28:23 <lambdabot> sequence (x : xs) = x >>= \ v -> sequence xs >>= \ vs -> return (v : vs);
17:28:37 <applikativ> a lot of Control.Monad is more like e.g. Data.Foldable and Data.Traversable anyway
17:32:21 <b2coutts> is it possible to mask/unload some or all Prelude definitions?
17:32:40 <ekipan> include Prelude hiding (stuff)
17:32:46 <ekipan> import
17:32:53 <ekipan> sorry, sneezed right there
17:33:06 <ekipan> all over the channel
17:34:34 <ekipan> import Prelude () -- hide everything, followed by:    import qualifed Prelude as P -- or whatev
17:34:41 <tikhon> there is also an extension called NoImplicitPrelude
17:34:52 <tikhon> {-# LANGUAGE NoImplicitPrelude #-}
17:35:16 <tikhon> it's also enabled automatically by some other extensions like RebindableSyntax
17:35:44 <b2coutts> ekipan: perfect, thanks
17:36:22 <Raydiation> Peaker: ok got it http://www.youtube.com/watch?v=z0N1aZ6SnBk 57:00
17:36:27 <Raydiation> what kind of optimiziations you can do
17:37:06 <Raydiation> you can basically distribute it over many cores without having to think of that one result may depend on another result
17:37:16 <Raydiation> stuff like maybe writing to globals
18:31:39 <anarcat> hi!
18:32:23 <anarcat> 1.111+0.2+1 == 2.111+0.2 => False. why?
18:33:47 <shanse> > 2.111+0.2
18:33:48 <lambdabot>   2.3110000000000004
18:34:41 <applikativ> maybe if you substituted 'isNotTooFarFrom' for == you'd have better luck ;)
18:34:53 <anarcat> wtf? :)
18:35:04 <copumpkin> anarcat: it's like that in almost every programming language
18:35:08 <applikativ> anarcat: there are some 'exact' real libraries
18:35:09 <copumpkin> it's not a haskell thing :)
18:35:16 <applikativ> it's totally not haskell
18:35:18 <anarcat> well, i was expecting haskell to suck less
18:35:24 <pavonia> > 1.111+0.2+1 == 2.111+ (0.2 :: CReal)
18:35:26 <lambdabot>   True
18:35:34 <copumpkin> == on CReal is a lie too :P
18:35:44 <applikativ> anarcat: it does, try creal or the deluxe cyclotomic if you don't need all Floating operations
18:35:46 <copumpkin> > 1.111+0.2+1 == 2.111+ (0.2 :: Rational)
18:35:47 <lambdabot>   True
18:35:48 <copumpkin> there you go
18:35:51 <copumpkin> now it's exact
18:36:10 <applikativ> == on reals in general is a classist lie
18:36:17 <applikativ> classicist
18:36:36 <anarcat> interestingly, python has the exact same issue
18:36:39 <scshunt> type Real = Nat -> Rat
18:36:59 <copumpkin> anarcat: as I said, it's true of almost every language out there
18:37:04 <applikativ> anarcat: yes, its machine numbers, what do you expect; cabal install cyclotomic is what i recommend ;)
18:37:07 <copumpkin> you aren't stuck with it
18:37:15 <copumpkin> but your CPU provides that kind of math
18:37:17 <ekipan> > 1.111+0.2+1 == 2.111+ (0.2 :: Rational) -- if you really want exactness
18:37:17 <lambdabot>   True
18:37:20 <copumpkin> so most languages support it by default
18:37:21 <shachaf> copumpkin: You should write proofs about floating point values in Agda!
18:37:26 <copumpkin> shachaf: I've considered it :P
18:37:30 <applikativ> don't use rational its a drag
18:37:31 <copumpkin> but I'd need a model
18:37:45 <pavonia> copumpkin: What's wrong with (==) for CReals?
18:37:52 <copumpkin> pavonia: it's undecidable
18:37:55 <copumpkin> so it checks a truncation
18:38:09 <applikativ> it gives out after a zillion places.
18:38:09 <applikativ> the fact is it's a pseudoconcept
18:38:17 <pavonia> Even for finite decimal numbers?
18:38:24 <pavonia> *a finite number of
18:38:28 <anarcat> hehe
18:38:31 <applikativ> define them; then it wont be a pseudoconcept
18:38:33 <byorgey> CReal doesn't know whether a number is finite
18:38:57 <applikativ> define apartness and the contradictoriness of apartness, like brouwer
18:39:25 <copumpkin> > (read "0." ++ replicate 40 '0' ++ "1" :: CReal) == (read "0." ++ replicate 40 '0' ++ "2" :: CReal)
18:39:27 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
18:39:28 <lambdabot>              with ac...
18:39:32 <copumpkin> dammit
18:39:41 <copumpkin> > (read ("0." ++ replicate 40 '0' ++ "1") :: CReal) == (read ("0." ++ replicate 40 '0' ++ "2") :: CReal)
18:39:42 <lambdabot>   False
18:39:47 <copumpkin> grr
18:39:57 <copumpkin> > (read ("0." ++ replicate 60 '0' ++ "1") :: CReal) == (read ("0." ++ replicate 60 '0' ++ "2") :: CReal)
18:39:58 <lambdabot>   True
18:40:00 <copumpkin> there we go
18:40:56 * pavonia is puzzled
18:41:00 <applikativ> equality in cyclotomic is derived
18:41:25 <applikativ> the elements are Integer and Map Integer Rational
18:41:31 <applikativ> the fields rather
18:41:36 <ion> pavonia: The representation of a CReal is a function from the precision you want to the result value times base^precision.
18:41:49 <ion> pavonia: Both being integers.
18:41:56 <copumpkin> > toCReal $ "0." ++ repeat '9'
18:42:00 <lambdabot>   1.0
18:42:00 <applikativ> so it can crash, but it'll be because you Map or Integers got too big for your machine
18:42:04 <copumpkin> sweet
18:42:06 <copumpkin> it works!
18:42:11 <applikativ> creal is a distraction
18:42:16 <copumpkin> >_<
18:42:29 <shachaf> copumpkin: Finally you can use CReal's (==) to prove that 0.999... == 1!
18:42:33 <copumpkin> yes!
18:42:37 <pavonia> ion: How does it know what precision I want?
18:42:44 <shachaf> pavonia: You wnat 40 digits.
18:42:44 <copumpkin> pavonia: it keeps all precision!
18:42:45 <copumpkin> forever!
18:42:52 <shachaf> Or that.
18:43:02 <ion> pavonia: You apply it to the integer representing the precision you want.
18:43:19 <bscarlet> Is there any replacement for the float2Double that used to be in GHC.Float?
18:43:23 <copumpkin> pavonia: when doing certain operations (showing, anything that returns a Bool), it truncates the number to 40 digits, but otherwise everything has infinite precision
18:43:27 <ion> realToFrac?
18:43:30 <copumpkin> did nobody look twice at my function?
18:43:39 <applikativ> well, why?
18:43:52 <copumpkin> > toCReal $ "0." ++ repeat '9'
18:43:53 <applikativ> CReal is two years ago's vogue
18:43:55 <lambdabot>   1.0
18:43:58 <copumpkin> that one :(
18:44:34 <ion> copumpkin: I did, i was hoping to see the source.
18:44:47 <copumpkin> > toCReal "0.1"
18:44:51 <pavonia> Just to make sure, the precision of 40 is hard-wired in the code?
18:44:51 <lambdabot>   0.1
18:45:02 <monochrom> > toCReal ("0." ++ repeat '9' ++ "12345")
18:45:04 <copumpkin> pavonia: yes, it's a bit of a toy implementation to show what's possible
18:45:05 <lambdabot>   1.0
18:45:11 <monochrom> \∩/
18:45:40 <bscarlet> ion: I need something which does bit-for-bit what casting a float to a double would do in C. I didn't think realToFrac did that in all cases. Am I wrong?
18:45:40 <applikativ> the author of creal has had a new version for some years by the way, so the one on hackage is six ways out of date
18:45:54 <copumpkin> applikativ: the real author or the apparent author?
18:45:59 <pavonia> copumpkin: I see, I've thought it always has infinite precision
18:46:04 <asmyers> So, isn't the new cabal sandbox supposed to sanbox installs?
18:46:04 <copumpkin> pavonia: it does!
18:46:06 <applikativ> the real author, the academic guy
18:46:12 <pavonia> O_o
18:46:27 <copumpkin> pavonia: as I said, it only truncates for operations that it has to, in theory
18:46:32 <ion> pavonia: It hardcodes a number of digits only for the operations that couldn’t be implemented otherwise.
18:46:35 <applikativ> pavonia: scrap == and two other functions and youre fine
18:46:40 <copumpkin> pavonia: there's no way to check if two CReals are equal or <= or whatever, so it must truncate there
18:46:45 <copumpkin> it's a mathematical truth
18:46:56 <pavonia> Ahhh
18:47:13 <copumpkin> pavonia: the other is just for Show, because it needs to show with some finite precision
18:47:21 <copumpkin> I've always wondered if there's an efficient way to get an infinite string of digits
18:47:27 <copumpkin> the problem is that it would always be infinite
18:47:39 <pavonia> Yeah, that makes sense
18:48:00 <copumpkin> > showCReal 100 pi
18:48:01 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
18:48:09 <copumpkin> > drop 100 $ showCReal 1000 pi
18:48:10 <lambdabot>   "79821480865132823066470938446095505822317253594081284811174502841027019385...
18:48:20 <monochrom> consider also cyclotomic :)
18:48:28 <copumpkin> @hackage cyclotomic
18:48:28 <lambdabot> http://hackage.haskell.org/package/cyclotomic
18:49:13 <applikativ> equality in cyclotomic is exact
18:49:25 <applikativ> show is exact
18:50:01 <mhitza> does Haddock have issues with ImplicitParams in the type signature? this signature "String -> ((?configuration :: Configuration) => IO b) -> IO b" shows up as "String -> ([configuration :: Configuration] => IO b) -> IO b"
18:50:19 <copumpkin> I'm disappointed that nobody was puzzled by my toCReal :(
18:50:23 <applikativ> there is really no contest, apart from the limitation on available operations
18:50:52 <applikativ> mentioning creal is like mentioning iteratees
18:50:55 <ion> copumpkin: I wasn’t puzzled by it, but i do find it neat. I’d still like to read the sauce.
18:50:55 <copumpkin> lol
18:51:02 <geekosaur> mhitza, probably; file a bug
18:51:07 <copumpkin> > @let toCReal x = if length (take 100 x) == 100 then 1 else read x :: CReal
18:51:08 <copumpkin> :P
18:51:08 <lambdabot>   <hint>:1:1: parse error on input `@'
18:51:26 <mhitza> geekosaur, ok, thank's for the input
18:51:27 <bscarlet> > realToFrac (-1/0 :: Float) :: Double
18:51:28 <lambdabot>   -3.402823669209385e38
18:51:32 <copumpkin> > read ("0." ++ repeat '9') :: CReal
18:51:42 <lambdabot>  Terminated
18:51:56 <ion> copumpkin: Oh, i’m disappointed. I expected a CReal-wrapped function that reads just enough of the string.
18:52:01 <copumpkin> :P
18:52:09 <applikativ> equality in cyclotomic is decidable; its a theorem
18:52:38 <copumpkin> someone translate it to agda
18:53:29 <ion> Aww, CReal doesn’t export the data constructor even in .Internal.
18:53:50 <applikativ> the proof is marginally harder than that for Rationals
18:54:45 <applikativ> in agda as usual there would be the question of verifying that what was proven was what was intended
18:54:57 <monochrom> copumpkin: sufficiently clever conjurer's trick is indistinguishable from advanced technology!
18:55:12 <copumpkin> applikativ: it's not that hard
18:55:20 <ion> applikativ: Just write a proof for that.
18:56:03 <copumpkin> I'd define a type cyclotomic, a binary relation on it, prove the relation is an equivalence relation, and then show that the relation is decidable
18:56:10 <applikativ> a proof that r == s v r /= s in agda which secure less certainty than one in prose
18:56:30 <applikativ> the situation is worse the more complex the theorem
18:56:38 <applikativ> it would secure less certainty
18:56:39 <copumpkin> that's why we factor out functionality
18:56:48 <copumpkin> and state it the way I did
18:56:57 <copumpkin> the basic building blocks are super simple and are hard to get wrong
18:57:15 <applikativ> right, but gauss already knew how to do the calculation?
18:57:21 <copumpkin> so?
18:57:27 <applikativ> shall i prove that naturals have successors?
18:57:44 <copumpkin> o.O
18:58:33 <haasn> would a good approach to defining ‘functional programming’ be that it's based on expansion and reduction of ASTs?
18:58:41 <haasn> perhaps s/ASTs/expressions/
18:58:45 <haasn> expression trees
18:59:23 <monochrom> equivalence relation is not enough. you have to show Leibniz's law. for every function f that you care, if x~y then f x ~ f y
18:59:55 <copumpkin> monochrom: in a "real" language, I'd quotient the type by that relation
19:00:04 <copumpkin> unfortunately I don't have such a language :)
19:00:12 <monochrom> that works too
19:00:29 <applikativ> god quotients, what a disaster
19:00:40 <monochrom> this is why I use a real proof language, such as HOL4 and PVS
19:01:19 <monochrom> not those curry-howard self-congratulations such as Coq or Agda
19:01:34 <applikativ> its true, really
19:02:00 <Cale> SHOTS FIRED
19:02:05 <haasn> haha
19:02:28 <joelteon> hey, buddy, you gotta respect curry-howard
19:02:30 <joelteon> don't get coqy
19:02:42 <monochrom> haha
19:03:26 <sinistersnare> hi yall! For my 17th birthday, my best friend got me "The most obscure programming book I could find" as a joke. I know what language I am learning next!
19:03:35 <sinistersnare> http://i.imgur.com/YL1QzAU.jpg :p
19:03:43 <joelteon> oh boy
19:03:48 <joelteon> that's the most obscure one your friend could find?
19:03:56 <copumpkin> sinistersnare: I wish someone had bought that for me when I was 17
19:04:05 <sinistersnare> hes always perplexed when i talk to him about clojure...
19:04:10 <sinistersnare> which im only a newbie at too :p
19:04:18 <applikativ> oh awesome sinistersnare , our friends can help you get set up and so on
19:04:22 <monochrom> do you mean the graph theory book there?
19:04:24 <sinistersnare> ive thought about learning haskell, but i didnt have this book! i cant wait
19:04:31 <sinistersnare> yes, the graph theory book too :p
19:04:58 <sinistersnare> that was my present to myself, because its only like $6 on amazon!
19:05:30 <applikativ> lyah has the slight defect that there are no exercises; it could do with a repo of code samples too
19:05:41 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml
19:05:46 <applikativ> but its good
19:05:50 <Moogle_> sinistersnare: have fun! learning haskell is almost like releaning programming altogether.
19:06:13 * applikativ read YAHT, by the dim bulb, Prof. Daume'
19:06:28 <sinistersnare> feel like im stepping into a new world!
19:06:38 <copumpkin> dim bulb?
19:06:46 <monochrom> Haskell is like elephant
19:07:00 <applikativ> isn't that your feeling, have you looked at it lately? yaht i mean?
19:07:08 <applikativ> i havent looked too lately myself...
19:07:09 <copumpkin> I haven't read it, just curious
19:07:26 <copumpkin> applikativ: you feel a lot more "trolly" with your new spelling :) you should move back to the old one
19:07:27 <applikativ> it isn't just that the book is dull...
19:07:43 <copumpkin> I haven't dealt with anything of his
19:07:54 <applikativ> copumpkin: im just irritable at the moment, waiting for someone with a genuine problem, and not just someone showing off
19:09:53 * copumpkin hugs applikativ 
19:09:57 <applikativ> but no doubt youre right
19:09:57 <applikativ> copumpkin: note that you have put down a number of people in the last half hour
19:10:05 <satc> How to check inside a module if cabal is run with enable-tests? Is there some flags set by cabal?
19:10:25 <copumpkin> applikativ: how so?
19:10:37 <applikativ> wait, what is satc's problem
19:10:57 <applikativ> are you asking how --enable test works, or something subtler?
19:11:36 <satc> applikativ: I want to do certain things in a module if you are compiling with --enable-tests.
19:11:43 <applikativ> -cbits-1.0.a: unknown symbol `_ffi_closure_alloc' grrrrr
19:11:46 <monochrom> I take it to mean: is some CPP macro defined when --enable-tests
19:11:56 <satc> monochrom: Yes
19:12:24 <Fuuzetsu> the answer is ‘no’, I believe
19:12:53 <satc> monochrom: Or how to achieve similar behaviour.
19:13:20 <applikativ> there is usually a test-suite field in the .cabal file satc but i sense you know that
19:14:06 <satc> applikativ: Yes. I want some thing like monochrom said. Defining a cpp mmacro which can be tested.
19:15:25 <applikativ> satc: i don't know about that, it isn't what i take to be the customary dumb procedure, which is to make a test.hs executable and tell cabal about it
19:16:45 <applikativ> this raises a problem with quickcheck since one would like ones propositions in the relevant file, but not to export them to ordinary users, then one uses CPP ifdef TESTING
19:16:50 <copumpkin> applikativ: PM please :)
19:16:59 <applikativ> how do you do that?
19:17:10 <copumpkin> I just sent you one, just wanted to point it out
19:23:26 <satc> applikativ: I suppose this is how it was done in older versions of cabal.
19:26:24 <enthropy> applikativ: take a look at doctest
19:27:02 <enthropy> there is some quickcheck support for it too
19:59:13 <Fuuzetsu> I'm seeing some messed up behaviour here… I have some code that does a bunch of prints and calls to system programs (ghc --version for example) and if I run it from GHCi, it's all fine and in order but if I run it in a shell, the order is all messed up.
19:59:42 <scshunt> Fuuzetsu: can you paste it (lpaste.net)
19:59:44 <scshunt> ?
19:59:56 <Fuuzetsu> eh, let me push it up, one sec
20:01:21 <mstksg> is anyone here familiar/work oftenly with the current FRP haskell ecosystem?
20:01:28 <mstksg> what is the trendy framework right now?
20:01:40 <Fuuzetsu> scshunt: https://github.com/Fuuzetsu/haddock/blob/tests/hoogle-test/run.lhs
20:01:43 <mstksg> i need to simulate a dynamic system and i feel like FRP is the appropriate approach
20:02:02 <mstksg> many tutorials i have found were written in the 2000's or even 1990's
20:02:02 <Fuuzetsu> (you'll need GHC HEAD if you want to try it yourself)
20:02:11 <scshunt> Fuuzetsu: that's illegible
20:02:15 <Fuuzetsu> https://raw.github.com/Fuuzetsu/haddock/tests/hoogle-test/run.lhs
20:02:18 <Fuuzetsu> try this
20:02:25 <Fuuzetsu> sorry, GitHub doesn't tolerate LHS
20:02:40 <scshunt> my guess would be something like threading
20:02:54 <Fuuzetsu> Yes, as is mine but I'm not sure how to stop it.
20:03:00 <ghena1986> http://bit.ly/17KoYYq
20:03:03 <nonconvergent> Hi guys.
20:03:13 <mstksg> hi nonconvergent
20:03:40 <geekosaur> that creature needs to be banned. hitting mutiple channels. (where's idoru?)
20:03:55 <geekosaur> (ghena1986 that is)
20:04:35 <Clint> idoru: wake up
20:18:51 <anarcat> hello
20:19:32 <anarcat> i am trying to install git-annex, which depends on the "vault" package, yet that package refuses to install with cabal:      fatal error: IO.hs: No such file or directory
20:19:38 <anarcat> any idea?
20:23:57 <hari_> In reference to a comment to my article, I'd like to know whether this point I wrote makes sense: http://harishankar.org/blog/entry.php/musings-on-functional-programming-and-haskell#comment-55311
20:25:40 <hari_> I am not sure whether I made myself clear.
20:30:07 <nisstyre> hari_: well allocating more memory instead of altering the existing memory is the actual different isn't it?
20:30:22 <nisstyre> whether the old memory gets deallocated is up the the runtime obviously
20:30:27 <nisstyre> *up to
20:30:39 <hari_> nisstyre of course.
20:30:56 <hari_> Depending on the type of value the function returns.
20:31:11 <nisstyre> hari_: so "mutating" could mean a functional update if you used it in a generic sense
20:31:29 <hari_> nisstyre, yes, I was talking in that sense.
20:31:31 <nisstyre> but there is a difference obviously
20:31:37 <hari_> Not mutate as in destructive memory update.
20:31:40 <nisstyre> yeah
20:31:43 <nisstyre> I agree
20:32:07 <nisstyre> hari_: I think there it gets a bit fuzzy is with things like zippers
20:32:22 <nisstyre> where you are only updating part of a structure
20:33:30 <hari_> nisstyre, thanks for the thoughts.
20:34:09 <hari_> I must go now. Will be back later.
20:34:10 <nisstyre> hari_: no problem
20:38:04 <Tribal> >reverse 12
20:38:18 <Tribal> > reverse 12
20:38:20 <lambdabot>   No instance for (GHC.Show.Show a0)
20:38:20 <lambdabot>    arising from a use of `M1398385879.sh...
20:38:24 <Tribal> > reverse '12'
20:38:26 <lambdabot>   <hint>:1:10: parse error on input `12'
20:38:29 <Tribal> harhar
20:38:37 <Tribal> > reverse "12"
20:38:38 <lambdabot>   "21"
20:39:15 <Tribal> Please don't yell at my inadequacy, ty
20:39:46 <ekipan> if you'd like to feel inadequate in private, lambdabot responds to /msg's
20:40:03 <ekipan> explore, and then come back to the channel with questions
20:40:12 <Tribal> `-`
21:00:37 <totimkopf> hello, could someone please show me how to make Map k an instance of Functor?
21:02:37 <enthropy> @hackage containers
21:02:38 <lambdabot> http://hackage.haskell.org/package/containers
21:03:58 <enthropy> totimkopf: I have a instance Functor (Map k) -- Defined in `containers-0.5.0.0:Data.Map.Base'
21:04:09 <enthropy> so you could look in that file in the containers library
21:04:22 <totimkopf> enthropy: thanks :)
21:11:14 <totimkopf> enthropy: line 2530, correct? Why did LYAH make it seem to be a difficult thing :p
21:12:45 <enthropy> you have to follow through to the definition of map I guess
21:13:24 <enthropy> which is two lines apparently
21:13:28 <totimkopf> yes :)
21:13:49 <totimkopf> why did LYAH make it seem like a challenge, they could have just included it
21:13:59 <totimkopf> anyway, thank you
21:14:13 <enthropy> by the way ghc can derive functor instances
21:39:32 <MitchellSalad> how come the associative operator for a Pipe was named >-> and not >~>, for symmetry with >~ and ~>
21:39:43 <satc> How do you guys export Arbitrary instances of a data type you defined? I mean suppose I have a package A which defined data Foo, Now I wrote some tests in A and defined Arbitrary instance there. Now I have a pacakge B which uses Foo, and while writing the tests for that I need the arbitrary instance for Foo. Defining Arbitrary instance with Foo in the same module is not an option as it will add dependency on QuickCheck even if the user might not want to run the
21:39:43 <MitchellSalad> </persnickety>
21:39:44 <satc> tests.
21:40:28 <S11001001> satc: put in some random object, say "import ThatObject._ where you want to use these arbs"
21:41:05 <S11001001> satc: by convention, the name of the library you distribute with these arbs is "yourlib-scalacheck-binding"
21:42:58 <satc> S11001001: Wait.. what. I am saying I dont want to export Arbitrary instance with the package as it adds dependency on QuickCheck. So I have defined that in tests. Now how do I use them if I want to use Arbitray instances in another package.
21:43:29 <S11001001> satc: is "another package" in the same build, or a different one?
21:43:58 <S11001001> satc: I assumed you were building a library of data types and wanted to provide arbs to library users who wanted them.
21:44:38 <satc> S11001001: Yes, but I dont want to add dependency on quickcheckk for users who dont want them.
21:44:57 <S11001001> satc: yes to "building a library of data types..."?
21:45:44 <satc> Lets say I am writing a second library which uses the first
21:46:03 <S11001001> which could be in a separate build?
21:46:51 <Ghoul_> System.FilePath behaves differently on windows than it should when including Posix
21:47:09 <Ghoul_> Shake realized this and wrote a better `normalize` which behaves proper
21:48:20 <S11001001> satc: Ugh, I am sorry, I have been talking nonsense, thought this was #scala (where your problem is also relevant) until Ghoul_ started talking about that.  Ick.
21:48:20 <satc> S11001001: Yes.
21:49:12 <satc> Ghoul_: Wait, that was for??
21:49:39 <S11001001> satc: no, I was really confused for a bit that Ghoul_ was talking about a haskell library in #scala; not related to your question :)
21:50:39 <S11001001> satc: Anyway, perhaps the same technique applies, though; you could define a library of arbs that depends on your main library, and have the tests for your main library in that library of arbs instead.  I imagine this wouldn't be ideal, though
21:50:58 <Ghoul_> satc: it was just a remark. probably not related to your problem.
22:02:27 <heath> why is static typing important again?
22:02:53 <satc> S11001001: Yeah, this was what I am doing right now. Thought there might be a better solution.
22:04:15 <S11001001> satc: it happens to work well for scala because of the different way the build system works.  I don't know, maybe haskell projects are doing something better that works for cabal.
22:32:58 <heath> re: my question from earlier...
22:33:59 <heath> makes sense that if you send a value to another function, that function should compute the same result over and over, that's why static is good. case closed </haskell_101>
22:44:47 <johnw> can "cabal sandbox" use an alternate GHC tarball, like hsenv --ghc=PATH does?
23:30:24 <dmj`> in Data.Set, why isn't null defined as null Tip = True; null _ = False;
23:30:53 <dmj`> null t = case t of { Tip -> True; Bin {} -> False }
23:31:26 <dmj`> or does it not matter
23:34:59 <identity> Is anyone here familiar with juicypixels? generateFoldImage, in particular. I'm getting stack overflows when trying to generate an image
23:35:19 <enthropy> dmj`: I don't think having a _ saves you anything
23:35:45 <enthropy> the runtime still has to look for which constructor you have to decide which case to take
23:37:28 <shachaf> dmj`: The second thing you gave is the actual definition?
23:37:35 <dmj`> shachaf: yes
23:37:41 <shachaf> I doubt it matters.
23:38:30 <enthropy> there might be a "software engineering" argument in favor of the second
23:38:54 <enthropy> since if you add some new constructors, you'll have some warnings to look at and make updates accordingly
23:50:34 <identity> How would I go about tracking down where a stack overflow is happening? I'm pretty sure I know where, but I'm unsure, as I cannot replicate the overflow in ghci.
23:50:53 <shachaf> @where rts-xc might help.
23:50:53 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
23:51:19 <shachaf> Also set options in ghci to limit the stack size?
23:51:24 <shachaf> I think there's something.
23:51:29 <identity> it doesn't by default?
23:51:40 <shachaf> I don't rmeember the details.
23:51:46 <identity> if I compile my program, and increase the stack size to something ridiculous, like 500m, it still consumes all my ram
23:52:02 <identity> if I run the same thing in ghci, it finishes fine without eating all my megabytes
23:52:41 <identity> i'll check that out though, thanks
23:52:59 <shachaf> Oh. I don't know. Optimizations?
23:53:29 <dmj`> identity: is the code long? why not post it?
23:55:31 <identity> dmj`: it is somewhat long, yes, and not really commented and somewhat .. messy
23:55:53 <identity> however, -xc did help me track some stuff down. It seems I probably need to make my data type strict
23:56:11 <identity> putting bangs in a couple of places helped, but it doesn't seem to be enough
