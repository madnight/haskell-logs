00:06:12 <joelteon> is there any performance advantage of using anonymous recursion over
00:06:22 <joelteon> whatever you call the alternative
00:07:05 <leroux> joelteon: CPS?
00:07:17 <joelteon> named recursion?
00:07:18 <leroux> Continuation-style passing.
00:07:34 <joelteon> right
00:15:40 <arkeet> joelteon: you mean foo x = ... foo ..., vs foo = fix $ \foo x -> ... foo ...
00:15:47 <Heffalump> joelteon: it depends a lot on the combinators you use for the anonymous recursion and hwo they optimise
00:15:48 <joelteon> sure, yeah.
00:16:28 <Heffalump> some of them like foldr, map, etc, have extensive fusion rules defined that ought to optimise many uses
00:17:01 <arkeet> e.g fold f z . map g = fold (f . g) z
00:17:06 <arkeet> well
00:17:10 <arkeet> more general than that
00:18:21 <mm_freak> leroux: named recursion is not CPS
00:18:38 <leroux> Not named, anonymous.
00:19:02 <mm_freak> neither named nor anonymous recursion are CPS
00:19:03 <leroux> I was trying to say that CPS is anonymous.
00:19:05 <leroux> Oh.
00:19:28 <mm_freak> CPS has little to do with recursion, except perhaps that it seems to make value recursion incredibly difficult to achieve
00:19:59 <leroux> But CPS can still be used to achieve anything recursive, right?
00:20:28 <mm_freak> leroux: sure, a function can be its own continuation
00:22:04 <mm_freak> :t fix ($ 5)
00:22:05 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = a0 -> b0
00:22:05 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
00:22:05 <lambdabot>       Actual type: (a0 -> b0) -> b0
00:23:06 <mroman> ah damn
00:23:11 <mroman> my cabal is really broken :(
00:26:31 <mm_freak> :t let cycleC c = runContT c (const $ cycleC c) in cycleC
00:26:32 <lambdabot> ContT r m a -> m r
00:27:03 <mm_freak> hmm…  i rather expected m b instead of m r
00:27:12 <mm_freak> ah no, it makes sense
00:27:33 <mm_freak> that's actually an interesting way to express an infinite loop with abort
00:28:13 <mm_freak> :t let abort = ContT . const . return in abort
00:28:14 <lambdabot> Monad m => r -> ContT r m a
00:29:58 <mroman> ah seriously
00:30:11 <mroman> this is the forth time cabal update told me to update cabal-install
00:31:22 <mroman> fifth
00:31:54 <mm_freak> mroman: so update it already ;)
00:31:58 <joelteon> it's because the cabal you're using is earlier in your $PATH than the (newer) version you installed
00:32:52 <mroman> well
00:32:54 <mroman> the weird thing is
00:33:00 <mroman> apparently it always install 1.16.02
00:33:07 <mroman> in an endless cycle :D
00:33:32 <Lethalman> eeeeeek http://thedailywtf.com/Articles/OMGWTF2-The-Honorable-Mentions.aspx
00:34:26 <mm_freak> hehe, read that one
00:34:28 <mm_freak> Cppify.hs
00:35:58 <dpwright> I have a function which runs pipes-network's "serve" function, and it works fine when I run it on the main thread, but if I use forkIO to fork it off to another thread it won't accept any connections
00:36:10 <dpwright> is this expected behaviour?
00:36:19 <mm_freak> dpwright: does your main thread exit after forking?
00:36:32 <mroman> yeah
00:36:34 <dpwright> mm_freak: No, it waits in an infinite loop
00:36:44 <mroman> the old cabal is in /usr/bin/cabal
00:36:44 <mroman> and another version in local bin cabal
00:36:47 * hackagebot cipher-aes 0.2.5 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.5 (VincentHanquez)
00:36:48 <mm_freak> dpwright: did you compile with -threaded?
00:36:53 <dpwright> yes
00:37:05 <mm_freak> dpwright: then it's not expected behavior
00:37:13 <mm_freak> could you paste the code?
00:37:31 <dpwright> I will see if I can simplify it a bit first...
00:37:52 <mm_freak> simplify it to the essentials
00:37:57 <dpwright> I have a load of nonsense to do with win32 services in there at the moment (although I am running it in the console)
00:38:12 <mm_freak> as a win32 side note, make sure you call withSocketsDo
00:38:25 <mm_freak> withSocketsDo $ … >> forkIO server >> …
00:38:40 <dpwright> yeah, I have double-checked that -- I also tried calling it on the thread instead of at the beginning of main just on the off chance but no dice
00:39:04 <dpwright> I'll see whether it goes away as a result of simplification
00:39:21 <dpwright> if it does, maybe that's a clue -- if not, I'll paste the code
00:41:47 * hackagebot cryptocipher 0.6.0 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.6.0 (VincentHanquez)
00:43:13 <mroman> Couldn't match expected type `containers-0.4.2.1:Data.Map.Map String String' with actual type `Map k0 a0'
00:43:21 <mroman> That doesn't sound very good.
00:43:44 <shachaf> If you see a version number, it means you have multiple versions involved.
00:43:46 <shachaf> Don't.
00:44:52 <mroman> yeah
00:44:56 <mroman> everything is messed up
00:45:44 <mroman> oh well
00:45:48 <mroman> let's update to 7.6.3
00:46:48 * hackagebot DrIFT 2.4.1 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-2.4.1 (KiwamuOkabe)
00:48:50 <trevorfancher> So I'm reading the Learn You a Haskell and I'm a little confused about the findKey examples on http://learnyouahaskell.com/modules#data-map
00:49:29 <trevorfancher> It seems to me the folder version runs through the whole list even if the key is found earlier
00:49:50 <trevorfancher> But the recursive version returns soon as the key is found
00:50:03 <trevorfancher> Yet the author says the foldr version is the preferred
00:50:13 <trevorfancher> What am I missing?
00:51:48 <trevorfancher> I think my question boils down to: Am I right in thinking the first version of findKey on http://lpaste.net/92555 returns soon as the key is found, but the second versions runs through the whole list every time?
00:54:01 <supki> > foldr (\v acc -> if v == 7 then Just v else acc) Nothing [1..]
00:54:02 <lambdabot>   Just 7
00:54:11 <supki> foldr stops if you don't need acc
00:54:16 <supki> (unlike foldl)
00:54:31 <supki> s/need/use/
00:55:04 <trevorfancher> Hmm, how does it know if I use acc or not?
00:55:56 <trevorfancher> Looks like I need to go review foldr again, I am a little confused now
00:56:17 <mroman> > foldr (\v acc -> if v == 7 then Just v else acc) Nothing ([1..]++[7])
00:56:18 <lambdabot>   Just 7
00:56:41 <supki> @src foldr
00:56:41 <lambdabot> foldr f z []     = z
00:56:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:56:46 <mroman> weird
00:57:12 <mroman> shouldn't it return the last found value for the key?
00:57:59 <supki> why?
00:58:28 <mroman> because it should loop through the whole list and replace acc with Just v if the key matches?
00:58:44 <mroman> if the key matches multiple times it should replace a previous finding?
00:58:53 <shachaf> > let f = (\v acc -> if v == 7 then Just v else acc) in f 1 (f 5 (f 7 (f 9 Nothing)))
00:58:54 <lambdabot>   Just 7
00:59:01 <shachaf> > let f = (\v acc -> if v == 7 then Just v else acc) in f 1 (f 5 (f 8 (f 9 Nothing)))
00:59:02 <lambdabot>   Nothing
00:59:08 <shachaf> That's all foldr does.
01:00:34 <trevorfancher> I see
01:00:36 <mroman> > let f key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in f 7 [(7,1),(7,2)]
01:00:37 <lambdabot>   Just 1
01:00:42 <trevorfancher> Reading the src helps
01:01:02 <trevorfancher> Perhaps I should default to that. Reading a paragraph of explanation sometimes is just confusing
01:01:23 <mroman> ah yeah
01:01:35 <mroman> it returns the left-most finding
01:02:09 <mroman> but that still doesn't explain why it works for [1..]++[7]
01:02:25 <trevorfancher> I've been using the ghc docs to read the source, but a lot of their definitions are "optimized" for speed and such
01:02:28 <trevorfancher> Like http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-Base.html#foldr
01:02:58 <mroman> > foldr (\v acc -> if v == 7 then Just v else acc) Nothing ([8..]++[7])
01:03:04 <trevorfancher> Is there a place to read definition of the standard functions that aren't worried about optimization
01:03:05 <lambdabot>   mueval-core: Time limit exceeded
01:03:13 <trevorfancher> @src foldr
01:03:13 <lambdabot> foldr f z []     = z
01:03:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:03:34 <trevorfancher> Like that, where is lambdabot getting its source from?
01:03:47 <shachaf> A handwritten database.
01:03:52 <shachaf> But you can look at the Haskell Report.
01:03:54 <shachaf> @where report
01:03:54 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
01:04:02 <mroman> supki: If it does f 1 ( f 2 ( f 3 (...
01:04:21 <mroman> how is that evaluated?
01:05:18 <trevorfancher> Cool http://www.haskell.org/onlinereport/haskell2010/haskellch20.html#x28-23100020.3
01:05:33 <lpaste> dpwright pasted “pipes-network server failing when run on a thread” at http://lpaste.net/92556
01:05:39 <trevorfancher> Not quite code tho
01:06:31 <dpwright> mm_freak: There it is
01:07:34 <dpwright> on my machine, using "runNotThreaded" works fine, but "runThreaded" just refuses the connection
01:11:13 <mm_freak> dpwright: note:  forever x >> y = forever x
01:12:06 <mm_freak> dpwright: try the following:  forkIO runDaemon >> forever (threadDelay 1000000)
01:12:26 <dpwright> mm_freak: Yeah... in my actual program that waits on an MVar which is set by the win32-services handler, I just wanted a way to make it wait when I'm not using services
01:12:30 <dpwright> ok
01:13:16 <shiona> is there a clean way to combine comparations. Like "Compare with x, but if that turns out equal then use y"
01:13:20 <dpwright> mm_freak: Right you are!
01:13:30 <dpwright> Just busy looping and not yielding the thread, then?
01:13:34 <shiona> I would assume there is, but I'm not sure how
01:13:45 <enthropy> shiona: there's an instance Monoid Ordering
01:13:52 <shiona> ok, great
01:13:54 <dpwright> (by "right you are" I mean, that worked)
01:13:56 <mm_freak> dpwright: what you really want for graceful shutdown is at least this:  (forkIO runDaemon >> forever waitSomehow) `finally` killThread t
01:13:56 <mm_freak> but it will probably not leave the other thread enough time to clean up
01:13:59 <mm_freak> it's best to write your threads in such a way that they don't require graceful shutdown
01:14:45 <mm_freak> dpwright: it shouldn't make a difference actually
01:14:57 <mm_freak> dpwright: if you compiled with -threaded both should work
01:15:06 <mm_freak> if not, you should file a GHC bug report
01:15:36 <mm_freak> dpwright: although it's probably not a bug
01:15:50 <mm_freak> when you have a single OS thread, then it may in fact never yield
01:16:45 <mm_freak> even given -threaded
01:16:54 <enthropy> > sortBy (\x -> comparing length x `mappend` compare x) ["shiona","z", "shionb" , "zzzzzzzzzzzz"]
01:16:55 <lambdabot>   ["z","shiona","shionb","zzzzzzzzzzzz"]
01:18:32 <dpwright> yeah... even with -threaded it's not necessarily going to spawn a new OS thread for every forkIO, is it?
01:18:33 <mm_freak> dpwright: indeed…  the problem is that 'forever (return ())' is a tight loop with no allocations or other yielding points
01:18:53 <mm_freak> dpwright: it spawns a fixed number of OS threads, which you can specify on the command line
01:19:09 <mm_freak> dpwright: compile with -rtsopts and call your program with "+RTS -N"
01:19:22 <mm_freak> then it will spawn as many threads as you have CPUs*cores
01:19:32 <dpwright> mm_freak: OK, thanks -- bit of a silly one then.  At least now I have a working console version which should be easier to debug than the service
01:19:35 <shiona> enthropy: damn that is nice and clean
01:19:47 <dpwright> ah, cool, thanks
01:19:59 <mm_freak> dpwright: the lessen you should learn is:  never busy-loop for waiting =)
01:20:10 <dpwright> if you don't call it with "+RTS -N", what is the default?
01:20:17 <mm_freak> dpwright: 1
01:20:22 <shiona> I thought that it sounded somehow like some property of Maybe's and the likes. All I could think of was just monad, which let me to a dead end
01:20:36 <mm_freak> dpwright: you can set a default when compiling your program…  let me look up the option
01:20:43 <dpwright> also do things like "+RTS -N" get included in System.Environment.getArgs or are they treated differently?
01:22:16 <trevorfancher> So without lazy evaluation it seems to me foldr wouldn't be possible
01:22:44 <trevorfancher> Or not with the same kind of definition anyways
01:23:17 <mm_freak> compile with (for example):  -with-rtsopts="-N"
01:23:46 <mm_freak> dpwright: RTS options are catched and removed by the RTS
01:23:54 <mm_freak> so your program (getArgs) does not see them
01:24:07 <mm_freak> they begin with +RTS and end with -RTS
01:24:24 <dpwright> mm_freak: Great, thanks!  I'm using the existence or lack of arguments to determine whether to run it as a service or console app
01:24:39 <mm_freak> dpwright: that's fine…  RTS options won't affect that
01:25:01 <mm_freak> trevorfancher: foldr would be possible, but infinite lists would not exist
01:25:12 <mm_freak> trevorfancher: and foldr would actually always leak memory
01:25:49 <mm_freak> trevorfancher: to be efficient/sensible foldr critically depends on the folding function to be non-strict in its second argument
01:31:26 <shiona> enthropy: how would you turn one of the orderings around? I found something about "Down", but I'm not clear how to use it
01:31:48 <shiona> of course since I'm stuck with integrals I could just use negations, but is there a nicer way
01:37:32 <enthropy> no idea what "Down" is
01:37:54 <enthropy> maybe it's as much effort as:    flip $ comparing f
01:38:37 <shiona> ha, that's ingenious
01:40:35 <mm_freak> shiona: comparing (\x y -> f (Down x) (Down y))
01:40:44 <mm_freak> flips GT and LT
01:40:58 <shiona> ah, so I would have had to change the types themselves
01:41:07 <mm_freak> yeah
01:41:10 <mm_freak> :t Down
01:41:11 <lambdabot> a -> Down a
01:41:21 <mm_freak> > Down 3 > Down 4
01:41:22 <shiona> I tried to do something like "comparing $ Down fst"
01:41:23 <lambdabot>   True
01:41:42 <shiona> which didn't quite work
01:41:43 <mm_freak> oh wait
01:41:56 <shiona> but the flip trick is really neat
01:41:59 <enthropy> > sortBy (comparing Down) [1 .. 10]
01:41:59 <mm_freak> comparing (Down . f)
01:42:00 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
01:42:19 <mm_freak> > sortBy (comparing (Down . fst)) [(1,2), (2,3)]
01:42:21 <lambdabot>   [(2,3),(1,2)]
01:42:37 <shiona> wait what, what did I do wrong
01:42:55 <mm_freak> Down fst :: Down ((a, b) -> a)
01:43:08 <mm_freak> Down . fst :: (a, b) -> Down a
01:43:22 <shiona> ah
01:43:31 <shiona> of course
01:43:36 <mm_freak> in particular Down f x is a type error =)
01:43:42 <mm_freak> (Down . f) x = Down (f x)
01:44:00 <shiona> I still have problems with (.) and ($) :D
01:44:33 <shiona> thanks, seems to work now nicely
01:44:37 <shiona> and I learned something
01:45:41 <mm_freak> shiona: "." is more similar to the circle operator ∘ in math
01:45:51 <mm_freak> that should remind you that (.) is function composition, not application
01:45:55 <ibotty> not correct. but might help till you figured it out (it's not that hard). use (.) with pointfree style (composing functions) and ($) with points (shuffling around values)
01:46:37 <ibotty> mm_freak: i always thought it . _is_ ∘
01:46:44 <mm_freak> shiona: and you can remember ($)'s meaning using this mnemonic:  applications make money, so ($) is function application =)
01:47:02 <mm_freak> ibotty: depending on what you mean by ∘ =)
01:47:07 <ibotty> aha.
01:47:29 <mm_freak> ibotty: to me (.) from Control.Category is much more like ∘
01:48:42 <ibotty> ah, of course. but isn't Prelude.(.) Hask's categorial (.)?
01:48:50 <mm_freak> yeah
01:49:20 <mm_freak> ibotty: in the earlier statement i was actually referring to the shape of the symbol, not its meaning
01:49:21 <ibotty> why isn't that the standard (.) again? error messages again?
01:49:35 <mm_freak> (.) looks a lot like (∘) and actually renders like (∘) in my emacs
01:49:46 <ibotty> (in my vim as well)
01:49:48 <mm_freak> ibotty: historic reasons
01:50:09 <mm_freak> for about the same reason Monad is not a subclass of Applicative
01:50:40 <mm_freak> and why map has such a weird type
01:50:42 <ibotty> is there any drawback in changing it? applicative will be a superclass of monad in a few releases, so what's holding back Control.Category?
01:51:26 <ibotty> i understood, that with map it's the fear of bad error messages.
01:51:54 <mm_freak> ibotty: well, some people argue that ':t (.)' would confuse the hell out of beginners
01:52:16 <ibotty> that is certainly true.
01:52:19 <mm_freak> and also the error messages, yeah
01:52:32 <ibotty> (that's a consequence, in a way)
01:52:32 <enthropy> generalizing types only makes error messages worse
01:53:14 <ibotty> the same can be said about higher order functions. hell are they scary. and the error messages... ^^
01:53:18 <mm_freak> i'd love the generalized versions in Prelude…  a good solution may be to add a Beginner module
01:53:25 <mm_freak> import Beginner; import Prelude ()
01:53:27 <ibotty> that's a good idea
01:53:43 <ibotty> maybe call it SimplePrelude
01:53:55 <mm_freak> because i don't really buy that the default setting should be bent towards beginners
01:53:55 <ibotty> so people don't feel like infants
01:54:03 <mm_freak> yeah, something like that
01:54:12 <mm_freak> import Simple; import Prelude ()
01:54:39 <mm_freak> or make it a language extension that imports the simple prelude by default
01:54:46 <mm_freak> {-# LANGUAGE SimplePrelude #-}
01:54:47 <ibotty> do you need a language pragma for that to work? (NoImplicitPrelude?)
01:55:57 <donri> that's what happstack does, seems to work alright
01:56:15 <mm_freak> i think that's really a good idea
01:56:15 <mm_freak> improve Prelude already!  and treat beginners separately
01:56:21 <donri> the main package is highly general and polymorphic; happstack-lite re-exports the same functions with monomorphic types
01:56:48 <merijn> mm_freak++
01:56:50 * hackagebot uuagc-cabal 1.0.5.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.5.0 (JeroenBransen)
01:57:08 <merijn> mm_freak: Remind me, when will AMP and Foldable/Traversable finally make it into Prelude? :<
01:57:41 <donri> merijn: AMP 7.8, the others maybe 7.10
01:58:02 <merijn> donri: You mean the AMP transition will *start* in 7.8, no?
01:58:07 <donri> IIRC and IIUC edwardk in the haskellcast correctly
01:58:47 <merijn> afaik ghc will get a warning shouting about missing applicative instances for 1 or 2 releases at least, before the trigger is pulled
01:58:50 <ibotty> donri: happstack-lite: that sounds reasonable.
01:58:58 <donri> merijn: eh, start? there are no phases here?
01:59:07 <donri> hm
01:59:51 <merijn> donri: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Applying_the_AMP_to_GHC_and_then_Haskell_in_practice
01:59:57 <mm_freak> who would like to write a proposal for SimplePrelude?
01:59:59 <kosmikus> shachaf: no, I haven't announced it yet, but I'm working on it. why?
02:00:01 <donri> yeah was just reading that :)
02:00:32 <mm_freak> i mean, come on guys, 10 out of 11 of my imports account for the 90s prelude
02:00:37 <donri> mm_freak: let's call it interlude, because it's intermediate while learning :)
02:00:56 <mm_freak> and it really sucks to have to import Control.Applicative, Control.Category, Data.Foldable, … in EVERY single module
02:01:01 <merijn> mm_freak: I thought Foldable and Traversable were already okayed for Prelude, which accounts for a lot of my pain
02:01:03 <elliott> simplified prelude stuff has been discussed to death on libraries@ already
02:01:18 <merijn> mm_freak: And foldable/traversable also brings in applicative
02:01:24 <mm_freak> yeah
02:01:35 <mm_freak> but also drop the special 'map', (.), id, …
02:01:39 <ibotty> elliott: can you give a link
02:01:54 <mm_freak> each time you import Control.Category you have to actually hide Prelude's retarded defaults
02:01:58 <mm_freak> import Prelude hiding ((.), id)
02:01:59 <elliott> strewn throughout months of the archives :P
02:02:32 <mm_freak> elliott: any conclusions?
02:02:59 <donri> yeah Category is the worst because the conflicts and because qualifying operators suck
02:03:20 <Ghoul_> is there anything like splitHalf?
02:03:31 <Ghoul_> splitAt .... length is O(2n) :(
02:03:43 <elliott> since when does libraries@ come to conclusions? :p
02:03:44 <ibotty> (... and what about proper math classes :D)
02:04:01 <mm_freak> Ghoul_: no, because it requires a full traversal
02:04:04 <ibotty> Ghoul_: what kind of algorithm can you imagine that does not do this
02:04:24 <donri> Ghoul_: if you care about time complexity and need to do things like that don't use lists
02:04:34 <mm_freak> Ghoul_: one nice way to split a list in half is by alternating elements
02:04:46 <mm_freak> that's WHNF O(1)
02:04:53 <ibotty> [a, a', b, b',..] |->([a,b,..],[a',b',..]
02:05:06 <Ghoul_> the order of the list is important, but okay, I get the point
02:05:13 <Ghoul_> that was an overwhelming amount of No.
02:05:19 <ibotty> :D
02:05:25 <ibotty> with reason i hope
02:05:33 <donri> Ghoul_: Seq has O(1) length and retains ordering
02:05:43 <mm_freak> :t let alternate n = transpose . takeWhile (not . null) . map (take n) . iterate (drop n) in alternate
02:05:44 <lambdabot> Int -> [a] -> [[a]]
02:06:05 <mm_freak> transpose . takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..10]
02:06:09 <mm_freak> > transpose . takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..10]
02:06:10 <lambdabot>   [[1,3,5,7,9],[2,4,6,8,10]]
02:06:32 <elliott> I think you can do a nicely lazy split in half thing with a lot of knot tying nonsense.
02:06:58 <elliott> for instance, if you have seen 100 elements of the list, you know it is okay to emit at least the first 50 to the first list.
02:07:25 <Ghoul_> mm_freak: thats cool, but unfourtunately I can't use that :\
02:07:27 <merijn> obfuscated haskell is funny: http://thedailywtf.com/Articles/OMGWTF2-The-Honorable-Mentions.aspx
02:07:36 <mm_freak> elliott: that sounds like a more expensive traversal
02:08:03 <Ghoul_> I'm actually not going to worry about it siince its probably more trouble than its worth optimizing for lists that are only going to be max like 50 long, thanks guys.
02:08:04 <mm_freak> Ghoul_: perhaps your mistake is to use lists in the first place =)
02:08:24 <mm_freak> Ghoul_: see Seq or Vector
02:10:06 <Ghoul_> > sizeOf (2 :: Int)
02:10:07 <lambdabot>   Not in scope: `sizeOf'
02:10:08 <lambdabot>  Perhaps you meant one of these:
02:10:08 <lambdabot>    `IM.size' (impor...
02:10:49 <Ghoul_> is there a better way to load things into ghci by module name,rather than filename?
02:11:00 <dpwright> I know if-then-else vs if as a function has been argued to enough of an extent to have a wiki page (http://www.haskell.org/haskellwiki/If-then-else)... I was just wondering, is there a commonly-used package which has something like the if' mentioned in that link defined, or does everyone who wants to do such a thing just define it themselves ad-hoc?
02:11:04 <Ghoul_> I find myself wanting to load things, but on windows the path for them is huuuuuuuuuuuuge and its never gonna happen
02:11:32 <ibotty> can't you cd in the right directory before?
02:11:47 <merijn> dpwright: Mostly people just define it ad hoc, I think
02:12:17 <merijn> dpwright: There might be a kitchen-sink utility library, but it's not really worth depending on for just one function
02:12:18 <mm_freak> Ghoul_: :m?  import?
02:12:27 <donri> merijn: hah, CPP, that's almost cheating. i was wondering how he got "time_t_ seed" to work as a pattern
02:12:58 <mm_freak> dpwright: define it yourself, if you really need it…  there is disagreement about what the name and type of such a function should be
02:13:09 <mm_freak> dpwright: example:  (?) :: Bool -> (a, a) -> a
02:13:23 <mm_freak> in the end 'if' should really be a class function
02:13:53 <dpwright> ah, I see, yeah, those sorts of alternatives hadn't occurred to me
02:14:03 <mm_freak> class (Monoid a) => IsEmpty a where if' :: a -> b -> b -> b
02:14:04 <donri> Ghoul_: ghci -ipaths:to:search (or :set -i from ghci)
02:15:14 <dpwright> I just find myself, when things return a Maybe, quite often binding them to a call to maybe after that, and when things return a Bool hankering after the same thing
02:15:17 <donri> mm_freak: monoid, really?
02:15:27 <mm_freak> donri: what would you suggest?
02:15:45 <donri> mm_freak: i imagine you're not using mappend there, it's just for mempty?
02:15:51 <mm_freak> donri: Monoid gives a well-defined "empty" and IsEmpty allows to test whether it's empty
02:16:10 <donri> mm_freak: annoyingly we have two monoids for Bool, though
02:16:59 <tomboy64> is there a simple way to get arbitrary precision (>2000 digits) with the floating type?
02:17:12 <tomboy64> or do i need to tackle this via gmp in c?
02:17:30 <donri> @hackage cond btw, dpwright
02:17:30 <lambdabot> http://hackage.haskell.org/package/cond btw, dpwright
02:17:44 <mm_freak> donri: good point
02:18:16 <mm_freak> tomboy64: does it have to be floating point?  if not, see Rational
02:18:24 <mm_freak> > 1/3 :: Rational
02:18:25 <lambdabot>   1 % 3
02:18:42 <tomboy64> mm_freak: yes, it needs to be floating point.
02:18:52 <mroman> oh damn.
02:18:57 <tomboy64> i really like rational but it's not applicable here
02:19:07 <mm_freak> tomboy64: which operations do you need?
02:19:09 <mroman> I can't install the new ghc with a broken ghc :)
02:19:52 <tomboy64> mm_freak: addition and sqrt (or the necessary operations to make fast sqrt work)
02:19:58 <Zenol> mroman: You'll have to download a compiled release :)
02:20:18 <mroman> looks that way
02:20:24 <tomboy64> mm_freak: and i need to be able to traverse the mantisse in a list-like manner
02:20:24 <mroman> my whole installation is totally broken
02:20:52 <Zenol> tomboy64: numbers package?
02:21:08 <tomboy64> zenol, mroman: doesn't ghc provide bootstrapping during compilation?
02:21:17 <tomboy64> zenol: gonna look at it
02:21:39 <mm_freak> tomboy64: i found this library: http://hackage.haskell.org/package/variable-precision
02:22:38 <mm_freak> tomboy64: also if all you need is a larger range (not a higher precision), you can use the much faster logfloat package
02:22:49 <mroman> tomboy64: I don't know.
02:23:00 <mroman> usually an old version of ghc is required to compile the newer version
02:23:21 <mroman> but some of the core packages are currently broken
02:24:16 <Zenol> tomboy64: you can try it. Remove your old GHC and you'll see if it compile or not :)
02:24:22 <tomboy64> mm_freak: no, i need a precision of >2000 digits after the decimal point
02:24:36 <tomboy64> zenol: i use gentoo. i just compiles :p
02:25:51 <mroman> you can bootstrap fgrom .hc files or something
02:26:55 <Zenol> s/tomboy64/mroman ~.~
02:27:03 <mm_freak> tomboy64: ok, then give these a shot:  http://hackage.haskell.org/package/numbers, http://hackage.haskell.org/package/variable-precision
02:27:18 <mm_freak> tomboy64: the former library even has computable reals with infinite precision
02:27:27 <tomboy64> mm_freak: thanks. looking at variable-precision right now
02:27:51 <mm_freak> > (sin pi :: CReal) == 0
02:27:53 <lambdabot>   True
02:28:18 <Zenol> oh, cool :)
02:28:42 <alexander__b> can someone link me to the source code for sort?
02:29:08 <alexander__b> oh. it's not in prelude. I don't remember where it was even, heh.
02:29:26 <mm_freak> > pi :: BigFloat Prec50
02:29:27 <alexander__b> found it on hoogle.
02:29:28 <lambdabot>   Not in scope: type constructor or class `BigFloat'Not in scope: type constr...
02:29:37 <tomboy64> alexander__b: Data.List
02:29:58 <mm_freak> alexander__b: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/Data-List.html#sort
02:35:57 <mm_freak> does it pay off to using sharing for partially applied functions?
02:36:32 <mm_freak> f x = let again = … if something then f (x - 1) else again in again
02:37:40 <tomboy64> how do i un-import stuff in ghc?
02:37:46 <tomboy64> in ghci, i mean
02:38:11 <Taneb> :m - Data.Char
02:38:22 <tomboy64> ahh
02:38:24 <tomboy64> thanks
02:38:26 <Taneb> :)
02:47:01 <shiona> Any clean solution for a common exercise input file reading? After initial few functions I have a list of strings that contain two ints divided by a space. I would like to have a list of (Int, Int)
02:47:29 <shiona> I really don't like my million nested maps I have at the moment
02:51:43 <aleator> How did you get the new cabal install to install executables outside the sandbox?
02:52:30 <supki> cp .cabal-sandbox/bin/exe ~/.cabal/bin/
02:52:32 <supki> :)
02:54:43 <mroman> does ghc have auto-install package yet?
02:55:08 <d3lxa> I'm trying my first TH but I've got "The exact Name `toJSON_a5c1' is not in scope" where I wanted the toJSON from Aeson, code: http://lpaste.net/92559 I'm sure it's dumb, any idea, please?
02:55:08 <tomboy64> shiona: how about map (read . words) YOURLIST?
02:55:19 <tomboy64> shiona: that should give you [Int, Int)
02:55:24 <tomboy64> err [Int,Int]
02:56:48 <hari_> can anybody tell me what is the equivalent of takeTill in Attoparsec with a failure condition?
02:57:27 <mroman> @type read . words
02:57:28 <lambdabot>     Couldn't match type `[Char]' with `Char'
02:57:29 <lambdabot>     Expected type: String -> String
02:57:29 <lambdabot>       Actual type: String -> [String]
02:57:33 <mroman> tomboy64: No it wont.
02:57:35 <shiona> yeah, and having to do that for a list of lines will get me "map (map read.words)".. and due to a file read I have one fmap
02:57:51 <tomboy64> doh
02:57:56 <quchen> :t map read . words
02:57:57 <lambdabot> Read b => String -> [b]
02:58:20 <quchen> mroman: ^
02:58:27 <mroman> yeah, that works
02:58:48 <shiona> and then making that list of lists of ints to list of tuples will take another mapping (I think I should be able to put that in the map before but couldn't get it working)
02:59:10 <tomboy64> shiona: how bout making a do?
02:59:21 <shiona> tomboy64: I guess that's what I'm going to have to do
02:59:27 <tomboy64> shiona: just list all the stuff cleanly underneath?
02:59:43 <tomboy64> shiona: i usually avoid do via $ and list it underneath - works just as well
03:00:26 <shiona> mm, ok
03:00:34 <aleator> supki: Well that'll work. Just that I forget that half the time ;)
03:00:34 <shiona> I guess I'll take a look at this at a later time
03:00:55 <tomboy64> hehehe
03:01:03 <tomboy64> postcratination ftw!
03:01:12 <mroman> shiona: I'd just write different functions for that and join them
03:01:21 <mroman> or use where
03:01:33 <mroman> you still have the map but it's more readable and looks cleaner
03:01:49 <tomboy64> mroman: where is a bugger to debug
03:02:05 <tomboy64> can't just feed the stuff random stuff in there
03:03:41 <mroman> tomboy64: ?
03:04:36 <tomboy64> mroman: if you write a function and put loads of parts of it in its where, you can't simply test the sub-parts by feeding it test-input in ghci
03:05:59 <Zenol> @hoogle Word8 -> Word8 -> Word16
03:06:00 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:06:00 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
03:06:00 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
03:06:10 <Zenol> :(
03:11:59 * hackagebot cipher-camellia 0.0.1 - Camellia block cipher primitives  http://hackage.haskell.org/package/cipher-camellia-0.0.1 (VincentHanquez)
03:12:56 <mroman> tomboy64: http://codepad.org/2IT2sIOr <- I'd would have opt for that
03:13:02 <mroman> or use a parsing library if necessary
03:14:08 <mroman> I've always wondered if there's a parsec light
03:18:24 <donri> mroman: ReadP? :p
03:18:40 <mroman> Is there a regex library that can capture stuff in the corresponding type?
03:19:19 <mroman> regexCapture "([0-9]*)\s([0-9]*)" :: [Int,Int] maybe
03:19:22 <donri> not quite sure what you mean there, but rex gives you compile-time checked regexps with typed capture groups
03:21:14 <mroman> Text.Regex does not provide that afaik
03:21:23 <donri> @hackage rex
03:21:23 <lambdabot> http://hackage.haskell.org/package/rex
03:21:41 <donri> if you have to use regexps, that's the nice one
03:21:58 <donri> mgsloan++
03:23:07 <mroman> oh wow
03:23:13 <mroman> that looks like perl .
03:23:17 <mroman> in the bad way
03:23:52 <donri> more than any other regex lib? how so?
03:24:45 <mroman> I'm not sure what
03:24:54 <mroman> [rex|^<\s* (?{ }[^\s,>]+) \s*,\s* (?{ }[^\s,>]+) \s*>$|]
03:24:57 <mroman> is supposed to do
03:25:35 <quchen> Well that's what Regex looks like.
03:25:59 <donri> yeah. rex only adds the ?{} syntax which maps a function on a capture group
03:26:24 <donri> in this case implicitly id, meaning the string is taken as is
03:26:30 <mroman> oh
03:26:54 <mroman> neat
03:27:05 <quchen> Regex is easy to write, hard to debug, and impossible to read.
03:27:14 <mroman> yeah
03:27:22 <mroman> and there are different standards for it
03:27:31 <mroman> or quasi-standards
03:28:04 <quchen> I know only PCRE, and then there are all those implementations that just do what they want.
03:28:12 <donri> supposedly rex uses pcre
03:44:13 <simukis_> how would I show a 2-places 0-padded integer?
03:45:21 <supki> > map (printf "%02d") [7, 13, 123] :: [String]
03:45:23 <lambdabot>   ["07","13","123"]
03:47:18 <simukis_> supki: exactly what I was looking for.
03:59:46 <haasn> Is there a Haskell implementation of the pcf format (http://fontforge.org/pcf-format.html) anywhere?
04:08:45 <haasn> Hmm, I'll try writing my own. There's one thing I'm not sure how to best approach: The header specifies a number of offsets, and I want to ‘get’ something starting from each offset
04:09:13 <haasn> am I doomed to manually count how many bytes I read and use ‘skipBytes’ on (target - howManyIAlreadyRead) ?
04:09:23 <haasn> or is there a simpler way to just ‘jump to a specific position’
04:10:05 <Lethalman> haasn, you want to seek probably
04:10:19 <Lethalman> :t hSeek
04:10:20 <lambdabot> Not in scope: `hSeek'
04:11:43 <haasn> Lethalman: in the context of a Binary instance
04:11:56 <Ghoul_> binary is for serializing things in order
04:12:08 <haasn> right
04:12:17 <Ghoul_> a one-off skip isn't too bad, right?
04:12:22 <haasn> either way, I just noticed that each section has a size in bytes along with the offset in bytes
04:12:27 <haasn> so I can just do arithmetic on that to figure out how many to skip
04:12:48 <haasn> I guess in practice there won't be any padding but to conform to the spec I have to account fo rit
04:14:07 <Ghoul_> haasn: I had to use Binary to do something like this once, and it was reasonably painful in a situation where I had to go backwards
04:14:20 <haasn> I don't have to go backwards
04:14:26 <Ghoul_> I'm unsure if you'll ever get a situation like that, but in the end I found it much easier to use the mmap package and storables
04:14:41 <Ghoul_> pointer arithemtic was nicer for what I had to do
04:14:48 <haasn> I mean, I could use some other binary-decoding-type package if there's one that makes this easier than Binary
04:14:58 <haasn> but I want to avoid working with a Handle directly
04:17:12 <merijn> haasn: Use pipes and then use a combinator that parses bytestrings as a pipe
04:17:36 <merijn> haasn: Alternatively use hGetContents and lazy IO + lazy bytestring, but that brings all the usual lazy IO problems with it
04:18:38 <haasn> I don't know enough about pipes to understand how to do it with that
04:20:34 <lpaste> merijn pasted “Pipes + Cereal” at http://lpaste.net/92564
04:20:44 <merijn> haasn: That's what I'm using right now
04:22:40 <haasn> I don't know enough about pipes to understand that code
04:23:02 <haasn> is this pipes-4 or pipes-3?
04:23:22 <merijn> pipes-4
04:23:37 <merijn> haasn: Actually almost none of that is pipes specific
04:24:05 <haasn> I don't understand where ‘ask’ is is coming from. I don't see a MonadReader instance for Proxy
04:24:32 <merijn> haasn: Connection is a synonym that includes MonadState and MonadReader
04:24:49 <merijn> So it's the instance for "m", not for Proxy
04:25:18 <haasn> how come you don't have to ‘lift’?
04:25:29 <ocharles> Proxy has an instance for MonadState
04:25:35 <ocharles> assuming the base has a MonadState
04:25:42 <haasn> ok. I guess it's not visible in my version of the haddock
04:25:56 <merijn> oh wait
04:26:03 <merijn> I forgot Proxy *does* have a MonadState
04:26:05 <ocharles> pretty sure mtl stuff got merged in anyway
04:26:07 <merijn> *I* wrote it
04:26:16 <ocharles> that's what I thought :)(
04:26:20 <merijn> ocharles: It did, I was the one that wrote all of that xD
04:26:26 <merijn> I'm just dumb
04:26:35 <merijn> And forgot
04:26:36 <ocharles> merijn: are you aware of pipes-bytestring?
04:27:01 <ocharles> oh actually there's attoparsec, maybe that doesn't help here
04:27:08 <merijn> I tried using that first
04:27:13 <merijn> attoparsec sucks for what I want
04:27:20 <haasn> ok. I think I understood the code now but I don't understand how it relates to my problem. Won't I still have to conjure some MonadReader Handle ‘m’ out of nowhere?
04:27:37 <merijn> haasn: Well, sure, but you don't have to do the same
04:27:50 <merijn> haasn: You could just change it to be "Handle -> Get a -> Effect m a"
04:28:06 <merijn> No specific reason why the Handle has to come from a reader
04:28:12 <hari_> What is the function to convert a string to a bytestring? fromString doesn't seem to work
04:28:13 <haasn> I don't want to use a HAndle
04:28:17 <merijn> ocharles: I don't see a pipes-bytestring
04:28:19 <haasn> at least, I don't think I do
04:28:23 <haasn> I want to have ByteString -> Maybe a
04:28:28 <merijn> haasn: So use "IO ByteString" instead
04:28:41 <merijn> pipes let's you trivially lift IO operations in there
04:28:57 <merijn> haasn: Well, you have two options (three, technically)
04:29:14 <ocharles> merijn: https://github.com/Gabriel439/Haskell-Pipes-ByteString-Library
04:29:23 <merijn> haasn: 1) read the entire ByteString into memory, then use a pure function "ByteString -> Maybe a"
04:29:46 <ocharles> hari_: you don't go from String to ByteString
04:29:50 <merijn> haasn: 2) pipes-like, like this (advantage, you can stream the parsing, saving memory and doing things incrementally)
04:29:56 <ocharles> hari_: you go from String -> Text -> ByteString
04:30:12 <merijn> haasn: 3) lazy IO + lazy ByteString + pure function ByteString -> Maybe a
04:30:15 <ben__> can anyone think of a reason that I'd get a segmentation fault when using postresql-simple with profiling on, but not with it off or in ghci?
04:30:16 <ocharles> hari_: so, for example: Data.Text.Encoding.encodeUtf8 (Text.pack "Hello, world!")
04:30:16 <hari_> ocharles, how do I convert a literal string to bytestring?
04:30:32 <haasn> merijn: the entire structure is going to be in memory one way or the other
04:30:38 <merijn> haasn: 3 is like 2, but prettier and more prone to breaking
04:30:39 <ocharles> > Data.Text.Encoding.encodeUtf8 (Data.Text.pack "Hello, world!")
04:30:42 <lambdabot>   Not in scope: `Data.Text.Encoding.encodeUtf8'Not in scope: `Data.Text.pack'
04:30:44 <ocharles> bah
04:30:57 <merijn> haasn: If the end structure is smaller than your ByteString because you skip MBs of data you still win
04:31:28 <haasn> the end structure will most likely contain the same amount of information. It's just big tables that I'm loading to bytestrings or vectors or repa arrays or something (haven't decided)
04:31:48 <haasn> well, for some definition of ‘big’
04:31:58 <merijn> hari_: It depends on the question, are you asking "How do I turn String literals into a ByteString?" or are you asking "How do I conveniently write literal ByteString's for interaction with things like C/network that have no encoding"?
04:32:12 <haasn> merijn: an example file I have here is 24 kB of data uncompressed
04:32:19 <haasn> I'm not awfully worried
04:32:25 <merijn> haasn: You could just do strict IO and call it a day, then
04:32:28 <haasn> yeah
04:32:41 <hari_> Literal strings
04:33:05 <hari_> like "hello world" when used in a function accepting only bytestring
04:33:18 <merijn> That is not an answer
04:33:27 <ocharles> hari_: it depends how the ByteString will be used
04:33:28 <d3lxa> few hours I'm stuck with TH, got "The exact Name `toJSON_a5c1' is not in scope" where I wanted the toJSON from Aeson, code: http://lpaste.net/92559 any idea, please?
04:33:36 <merijn> hari_: Have you read http://www.joelonsoftware.com/articles/Unicode.html ?
04:33:51 <merijn> hari_: If not, please do so in order to make sure you know what you actually want
04:34:02 <ocharles> hari_: what function are you trying to use that wants a ByteString?
04:34:14 <hari_> I am using Attoparsec
04:34:15 <merijn> hari_: There are fifteen billion ways to turn String into ByteString and if you don't understand why, selecting the right one will be hard
04:34:56 <merijn> Incidentally, approximately 14,999,999,997 or so of those are wrong >.>
04:36:01 <haasn> this thing specifies ‘lsbint32’, I assume that's an Int32 in little-endian order; how come Binary doesn't provide a function for this? It just has one for Word32, but I want an Int32 not a Word32 (unless I'm misunderstanding the meaning of ‘lsbint32’)
04:36:38 <ocharles> haasn: I think bytes has that
04:36:49 <ocharles> ah no, only Word32
04:37:22 <ocharles> haasn: can you go from Word32 to Int32 with fromIntegral?
04:37:32 <haasn> I'm not sure if that has the correct semantics
04:37:43 <ocharles> "For coercing between any two integer types, use fromIntegral, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign. "
04:37:47 <ocharles> so says Data.Word
04:37:57 <haasn> > fromIntegral (255 :: Word8) :: Int8
04:37:59 <lambdabot>   -1
04:38:01 <haasn> ok
04:40:57 <mroman> Are there yet optimizations for manipulating lists at specific indices?
04:41:42 <mroman> rather than taking the list apart and put it together again
04:42:04 <haasn> are you referring to optimizations in terms of code, or optimizations in terms of performance?
04:42:15 <haasn> > "hello world" & ix 3 .~ '!'
04:42:15 <mroman> performance
04:42:17 <haasn> oh ok
04:42:18 <ibotty> you might have a look at zippers
04:42:18 <lambdabot>   "hel!o world"
04:43:15 <mroman> @type ix
04:43:20 <ibotty> if you need to non-trivially traverse a list that might be what you need..
04:44:33 <mroman> well
04:44:41 <hari_> Oh yes, I know about UTF-8
04:45:13 <mroman> I just want fast list manipulations
04:45:30 <ibotty> in what way fast?
04:45:44 <ibotty> there is no fast in every way
04:46:01 <mroman> ok
04:46:16 <mroman> Mostly you just map or fold over them
04:46:27 <ibotty> do you have many filter, map, folds after one another, then you might want fusion. array-fusion (or similar) is your package.
04:46:49 <merijn> mroman: Changing a list always mean modifying all chunks in front of it, unless you use a Zipper
04:46:55 <mroman> I'm writing a little interpreter
04:46:59 <ocharles> mroman: correct data structure helps too. You might want to consider a Vector or Seq
04:47:23 <merijn> Hell, maybe IntMap is better
04:47:32 <mroman> where no list occurs twice actually
04:47:33 <merijn> If you only plan to access by index
04:48:20 <mbrock> sometimes you can easily find an efficient way if you stop thinking in terms of "modifying the list" and instead think of what results you want to get out when you're done -- if that makes sense
04:48:38 <ibotty> usually all the container have a very similar api and big-O notation for all the operations
04:50:03 <ibotty> and you should know what fusion is.
04:50:18 <mbrock> for example, if you have an algorithm that appends a lot of lists, and then finally goes through them sequentially, you can gain speed by just keeping a list of lists and then traversing that
04:52:04 <mroman> I'm thinking about lists like python has :)
04:52:25 <mroman> i.e you can map, reduce over them, you can access them by index
04:52:33 <mroman> and you can modify them by index
04:52:46 <hari_> what does {-# LANGUAGE OverloadedStrings #-} do?
04:53:01 <ibotty> mroman: take a look at vector then. i think it's closest to that.
04:53:19 <ibotty> hari_: it appends fromString to every string literal you have in your source file
04:53:32 <monoidal> hari_: it makes strings polymorphic - like currently integer literals are Num a => a, it makes strings IsString a => a
04:54:10 <hari_> Thanks, ibotty and monoidal
04:56:47 <mroman> Vector update is O(m+n)
04:56:56 <mroman> ! is O(1)
04:57:39 <mroman> good enough.
04:57:43 <mroman> Is map fast for Vectors?
04:58:11 <ibotty> yes. vector is fast
04:58:19 <donri> no
04:58:31 <ibotty> but in lists it's faster
04:58:38 <ibotty> i mean, what do you want
04:58:46 <ibotty> you have the time complexities written down
04:59:16 <mroman> so
04:59:17 <ibotty> just for reference i looked up the python time complexities
04:59:21 <ibotty> https://wiki.python.org/moin/TimeComplexity
04:59:22 <donri> if you have bulk updates you can do a mutable vector in st or io though
05:01:21 <mroman> My main interest is fast map, fold and filter.
05:01:59 <merijn> What does fast mean?
05:02:00 <mroman> everything else is an edge case
05:02:15 <merijn> If you don't actually look at the results map/fold/filter on list is O(1)
05:02:30 <merijn> Pretty sure that vector's map/fold are strict?
05:02:44 <mroman> The result is required, of course
05:02:47 <merijn> List map/fold/filter already do fusion
05:02:53 <merijn> mroman: Yes, but for the entire list?
05:02:57 <mroman> I mean fast in terms of time.
05:03:20 <merijn> There is no way to say what will be fast in terms of time without knowing what you will be doing
05:03:37 <donri> mroman: point is that "take 10 . map" is O(10) for list, but O(n) for a strict data structure
05:03:54 <donri> mroman: on the other hand list may be slow when you need the whole thing
05:04:02 <mroman> oh
05:04:08 <mroman> I need lazy lists.
05:04:14 <mroman> that's for sure.
05:04:42 <Cale> Lists are pretty much ideal if you're iterating through the elements in sequence.
05:04:48 <donri> then you either want to stick to list or use some streaming library like pipes
05:04:49 <Cale> They're bad at random access.
05:05:34 <donri> all structures have trade-offs, or we'd just use one for everything
05:05:45 <mroman> It's supposed to be a minimal general purpose language with support for lists. And most of the time in that language you just use maps, reduce or filter.
05:05:50 <Cale> Lists are our loops in Haskell. Just as a loop either doesn't occur at all (because its precondition isn't met), or consists of one iteration followed by another loop, a list is either empty, or consists of one element followed by another list.
05:06:10 <mroman> I'm just not sure whether I should implement those lists with haskells native lists
05:06:14 <mroman> or if I have better options available
05:06:26 <mroman> obviously I can predict what somebody does with those lists.
05:06:29 <mroman> *can't
05:07:05 <mroman> on the other hand, performance is not an actual criteria
05:07:28 <Cale> I'd say just go with normal lists for now
05:07:48 <mroman> because it's just a reference implementation to keep things going :)
05:07:56 <Ghoul_> Anything else is 10x harder to use anyway
05:08:11 <Ghoul_> Lists are about as elegant as you could wish for in haskell :)
05:08:51 <donri> list is great as a control structure; it's just not that great as a data structure
05:09:53 <mroman> If required I can always introduce an array type later so it's not a big deal anyway
05:10:03 <Ghoul_> complexity lacking for list lookup/length isnt always a big issue anyway, since haskell generates pretty fast native code
05:10:50 <mroman> Yeah...
05:11:04 <mroman> Last time I spend an hour optimizing some haskell code to calculate something
05:11:14 <mroman> it was still 12 times slower than what I got with 5minutes of java :)
05:11:19 <mroman> *spent
05:11:28 <ibotty> and if you get bitten later, you can first try to switch to stream-fusion...
05:11:41 <mm_freak> (holdFor 0.5 . periodic 1 . "yes" <|> "no") . for 15 --> "ok, that starts to suck"
05:12:02 <mm_freak> display "yes" and "no" alternatingly for 15 seconds, then the "that sucks" message
05:12:05 <mm_freak> netwire 5 =)
05:12:12 <mroman> ibotty: Usually that requires a lot of code rewrite?
05:12:13 <Ghoul_> hah
05:12:20 <ibotty> mroman: no
05:12:40 <merijn> mm_freak: Will netwire 5 have proper events? :>
05:12:44 <Ghoul_> If your code is 12x slower than java you did something wrong
05:12:48 <mm_freak> merijn: yes!
05:12:54 <mroman> Ghoul_: probably
05:12:58 <Ghoul_> naive haskell code is often faster than naive java code by a huge margin
05:13:01 <merijn> mm_freak: So I can have multiple independent event sources?
05:13:02 <mroman> but still the point remains valid
05:13:03 <ibotty> with the right stanza on top (importing things, hiding things): nothing if you don't use list comprehensions
05:13:06 <mm_freak> merijn: yeah
05:13:10 <merijn> mm_freak: <3
05:13:20 <donri> mm_freak: what does that mean? i kinda liked the simplicity of netwire 4, though i've never done anything with it TBH... :p
05:13:25 <mroman> naive java code is usually faster than my naive haskell code
05:13:27 <merijn> mm_freak: Maybe I won't have to wait for Apfelmus to fix reactive-banana then \o/
05:13:34 <mroman> on the other hand
05:13:39 <merijn> mroman: Are you compiling haskell with -O2?
05:13:41 <donri> the event/behavior separation always confused me in other libraries
05:13:43 <mroman> writing more complex stuff with Haskell is way easier
05:13:49 <merijn> donri: Reall? Why?
05:14:04 <donri> merijn: if i knew i wouldn't be confused!
05:14:06 <merijn> donri: They're completely different smentically
05:14:09 <mm_freak> merijn: the new way to switch works like this:  you have regular yampa-style events (say, Wire s e m a (Event a))
05:14:15 <merijn> donri: Have you mostly been looking at arrowized FRP?
05:14:16 <donri> monoids for inhibition just clicked for me
05:14:24 <merijn> donri: Because they fuck things up completely
05:14:35 <mroman> merijn: That was some time ago
05:14:43 <mm_freak> merijn: then you say until . myEvent, which turns that into a time interval…  the interval from the start until the event happens
05:14:44 <mroman> I even got helped by several people in here
05:14:51 <mm_freak> merijn: finally you can switch by using (-->)
05:14:57 <mm_freak> once the interval is finished, switch away
05:15:12 <merijn> mm_freak: I'll keep any eye out as things progress, then :)
05:15:20 <mm_freak> =)
05:15:22 <donri> merijn: i admit i haven't really played with frp seriously
05:15:39 <donri> at a glance netwire just seemed cleaner and simpler
05:15:44 <merijn> donri: I've finally seen the light (go ahead, ask mm_freak how many times I've bugged him being complete)
05:15:54 <donri> and i attributed that in part to not separating events and behaviors
05:15:56 <mm_freak> donri: it means that netwire 5 takes continuous time seriously
05:16:04 <merijn> donri: Yes, but netwire (up until now) also throws out almost anything that makes FRP FRP if you look at conal's stuff
05:16:13 <donri> hehe ok
05:16:34 <merijn> donri: Event's are things that just happen, at any time X, an event may not have a value
05:16:55 <merijn> donri: Behaviour's are time-varying values, at any time X a Behaviour has a value
05:17:07 <merijn> donri: But the value at time X and Y may differ (assuming X /= Y)
05:17:29 <mroman> merijn: But i still might have the code
05:17:31 <merijn> Event's provide you a notion of doing something "when" an event happens
05:17:37 <merijn> s/Event's/Events
05:18:19 <donri> and why isn't Wire with inhibition enough?
05:18:21 <merijn> donri: Like a line of input on a terminal may happen at time X, the notion that it "arrives" has no meaning before X and the only meaning it has after X is "it happened"
05:18:34 <mroman> http://codepad.org/TZG5q5Ni
05:18:37 <mroman> ^- ah. there it is
05:18:38 <merijn> donri: Wire have a single entry point
05:18:48 <mm_freak> donri: because inhibition is too tightly coupled with data flow
05:18:56 <mm_freak> donri: it may disrupt data flow when it really shouldn't
05:19:00 <merijn> donri: Netwire composes small wires into bigger ones, it is impossible to have an "event" happen localised
05:19:10 <mm_freak> merijn: that's possible
05:19:29 <merijn> mm_freak: I mean, that the event has to be triggered by something happening in the top level wire
05:19:31 <mm_freak> what is not easily possible is event propagation…  i.e. if an event did not happen, a later wire cannot notice this
05:19:44 <merijn> No input into the top level wire means no update to notice a possible event happening
05:19:48 <mm_freak> merijn: no, that's not the case…  events can be triggered anywhere
05:19:54 <merijn> Oh?
05:20:24 <mm_freak> the problem is propagation:  if an event does not happen, the rest of the wire is frozen
05:20:44 <mm_freak> x . ev…  when ev didn't happen, x is never reached
05:21:13 <mm_freak> yampa has first class events, which you can propagate around until you decide to react to them
05:21:14 <merijn> Then how do I write this in netwire "Event String" is an event when I get network input, now I want "Behaviour String" whose value is "the last received String"
05:21:35 <mm_freak> merijn: hold . netStringE
05:21:52 <mm_freak> netStringE :: Wire s e m a (Event String)
05:22:06 <donri> mm_freak: is this netwire 4?
05:22:08 <merijn> mm_freak: Is this the new netwire stuff ot the old 4?
05:22:10 <mm_freak> netwire 5
05:22:15 <merijn> mm_freak: Right, I was talking about 4
05:22:17 <donri> i think merijn means netwire 4
05:22:28 <mm_freak> merijn: in netwire 4 'hold' was a combinator
05:22:30 <merijn> mm_freak: I'm not judging netwire 5 until I've actually looked at it
05:22:39 <mm_freak> hold :: Wire s e m a b -> Wire s e m a b
05:22:41 <merijn> mm_freak: I was trying to explain the problem with netwire 4 to donri
05:22:49 <mm_freak> in 5 it's a regular wire:  Wire s e m (Event a) a
05:23:15 <ocharles> I'm hoping to finally get round to doing some event stuff in Netwire 5 soon
05:23:25 <merijn> donri: Anyhoo, the thing is, I want my "Behaviour String" to hide the existence of "Event String", it's an implementation detail, the rest of my code should not need to know where the String value comes from
05:23:27 <ocharles> because Wires, Occasions and Events still confuse me a bit
05:23:41 <merijn> donri: events as inhibition don't really give you that type of composability
05:23:45 <mm_freak> ocharles: you will find that today or tomorrow there will be a huge push
05:23:52 <ocharles> mm_freak: oh?
05:24:13 <ocharles> mm_freak: I just finished my UI skeleton stuff and am working on the renderer at the moment, so I haven't actually done any of the FRP stuff
05:24:18 <mm_freak> ocharles: the interface will change a bit…  i have removed the yampa-style switching combinators and replaced them by a better concept
05:24:37 <merijn> donri: Because "Wire e m a b", what is the value of 'a' if the Behaviour is obtaining the 'b' from an internal Event source that is not visible outside the Behaviour
05:24:40 <ocharles> what is yampa-style switching? A value tupled with an Event?
05:24:45 <ocharles> because I found that a bit clunky
05:25:00 <mm_freak> merijn: btw, you requested to get polymorphic time
05:25:08 <merijn> I did?
05:25:13 <mm_freak> IIRC
05:25:41 <merijn> I don't think I did, but then as we saw earlier today I couldn't even remember pipes had mtl transformers, even though I was the person that implemented them xD
05:25:58 <mroman> 20*10^6 rounds take ghc -O2 19.47s, and java 4.7s
05:26:01 <mm_freak> ocharles: me too…  yampa needs it that way, because it doesn't have intervals
05:26:02 <Ghoul_> mann the feel when you get a euler question like "find the nth prime"
05:26:02 <Ghoul_> its all like, "Yo man, haskell got this"
05:26:02 <Ghoul_> primes !! n
05:26:15 <mroman> it's better than last time I tried
05:26:28 <mm_freak> lol merijn
05:26:31 <merijn> donri: Btw, I though the "Push-Pull Reactive Programming" paper by Conal Elliot described the idea really clearly
05:26:52 <ocharles> I haven't read that one, I should give that a look
05:27:05 <donri> merijn: ok thanks :)
05:27:14 <merijn> It recaps the Functional Reactive animation paper, but has a lot more implementation stuff
05:27:19 <merijn> Which really helped for me
05:27:48 <merijn> It shows how Events are functors, Behaviours are Applicatives and all that
05:28:03 <merijn> donri: Which should hopefully clarify what the semantic difference is
05:28:12 <mm_freak> and Events are only functors…  unlike yampa Event will be opaque
05:28:34 <mm_freak> i found that exposing Event can expose discrete time
05:28:58 <merijn> donri: For example, Event cannot really be Applicative in a sane semantics sense, but Behaviours can be
05:29:09 <Ghoul_> mroman: change the import at the top to Control.Monad.State.Strict
05:29:28 <merijn> I mean, what would "Event (a -> b) -> Event a -> Event b" even mean semantically?
05:29:39 <mm_freak> merijn: (<*>) is not the problem
05:29:42 <mm_freak> 'pure' is the problem
05:29:43 <Ghoul_> -O2 -fllvm for flags
05:29:54 <merijn> "Behaviour (a -> b) -> Behaviour a -> Behaviour b" on the other hand makes more sense
05:30:22 <merijn> mm_freak: Actually, I think you can implement both, but which is the "right" semantics is very unclear
05:30:26 <elliott> Events are Apply perfectly reasonably
05:30:31 <DMcGill> clearly this is a case for a Pointed class!
05:30:32 <elliott> pure not so much unless you introduce notions of starting time and stuff
05:30:34 <merijn> pure could just be an event at minus infinity time
05:30:38 <merijn> or positive infinity time
05:30:38 <elliott> no, it's a case for Apply
05:30:59 <merijn> elliott: Yes, but there's like 4 possible implementation of <*>
05:31:10 <elliott> and one reasonable one :P
05:31:14 <elliott> I think only one satisfies the laws.
05:31:15 <mm_freak> merijn: there is really only one sensible implementation of (<*>), but it doesn't have a 'pure'
05:31:17 <merijn> elliott: What's the reasonable one?
05:31:20 <mm_freak> zipping events
05:31:56 <Ghoul_> mroman: also, the use of IO random is probably really slow
05:31:58 <Ghoul_> You'd be better off doing this all pure, rolling the new random between calculations
05:31:59 <mm_freak> a proper 'pure' for that one would be the "event that always happens", which is nonsense
05:32:11 <elliott> merijn: the event occurs whenever either occurs and matches their values
05:32:15 <merijn> So basically you use every function once and the result "happens" at time max(functionEvent, argumentEvent)?
05:32:16 * hackagebot test-framework-golden 1.1.3 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.3 (RomanCheplyaka)
05:32:21 <elliott> wat
05:32:23 <sclv> ruling out 'nonsense' is a bad way to write code
05:32:31 <elliott> for every occurrance of either the function or argument event, you have an occurrance
05:32:38 <elliott> the value at that time is the result of applying the function at the time to the argument at the time
05:32:44 <merijn> elliott: Sure, but mm_freak mentions zipping
05:32:46 <mm_freak> merijn: Event f <*> Event x = Event (f x); _ <*> _ = NoEvent
05:32:53 <merijn> elliott: That doesn't sound like zipping to me
05:32:55 <elliott> it is
05:32:58 <sclv> ruling out 'nonsense' to the compiler makes sense
05:33:01 <elliott> it matches up the values at the same point in time
05:33:05 <elliott> compare "same point in the list"
05:33:07 <merijn> elliott: See, your proposal is different from mm_freak
05:33:08 <mm_freak> merijn: think of events as [(Time, a)]
05:33:11 <mm_freak> then that's zipping
05:33:15 <mroman> Ghoul_: Yes
05:33:24 <mroman> that's what makes comparing it to java difficult
05:33:29 <sclv> but ruling out code that doesn't match your intuitions is generally a sign you have insufficient intuitions
05:33:34 <mroman> @random
05:33:35 <lambdabot> Unknown command, try @list
05:33:50 <Ghoul_> @where random
05:33:50 <lambdabot> I know nothing about random.
05:33:59 <Ghoul_> Right on, son.
05:34:21 <merijn> mm_freak: I know
05:34:50 <merijn> mm_freak: But afaict you and elliott are suggesting different things, thus reinforcing my earlier claim that it is unclear which implementation "makes sense"
05:35:27 <mm_freak> merijn: i'm not sure we are proposing different things…  i just assumed a specific implementation of Event
05:36:05 <mm_freak> merijn: combining simultaneous events
05:36:30 <elliott> I don't see any contradiction between our statements.
05:36:37 <elliott> but I also do not understand mm_freak's (<*>) implementation
05:36:49 <mm_freak> elliott: which one would you recommend?
05:37:02 <elliott> I don't know. yours looks like a data type:
05:37:09 <elliott> data Event a = Event a | ... | NoEvent
05:37:12 <elliott> which I do not understand.
05:37:13 <mm_freak> elliott: it is a data type isomorphic to Maybe
05:37:28 <mm_freak> elliott: in AFRP that's how you represent events internally
05:37:32 <elliott> oh, well sure.
05:41:05 <merijn> mm_freak: You propose combining simultaneous events, elliott seemed to suggest generate a new event everytime *either* event happens
05:41:21 <quchen> Is there any reason not to use the LLVM build of GHC? According to benchmarks, LLVM usually seems to be faster than GHC's NCG.
05:41:34 <mm_freak> merijn: how would that work?  say the function event occurs, but the value event doesn't…  what would the resulting occurred (!) event be?
05:42:16 <elliott> oh, then I am disagreeing with mm_freak!
05:42:22 <elliott> it should take the last value of the argument.
05:42:34 <Ghoul_> quchen: it takes much much longer to build
05:42:40 <elliott> I think relying on exact simultaneity for events is very bad
05:42:46 <merijn> mm_freak: Hence my point that you two disagree and thus reinforcing my claim that it's non-obvious! :)
05:42:48 <elliott> what if they are 0.01 ms apart instead?
05:42:49 <Ghoul_> and I dont think the GHC built with llvm works
05:42:59 <elliott> mm_freak's instance sounds obviously crap :P
05:43:00 <Ghoul_> it has some problem, but I forget what it is.
05:43:07 <quchen> Ghoul_: Okay, that's a very strong point against the LLVM build then
05:43:33 <mm_freak> elliott: when reactimating you have a discrete framerate, and within one frame two events can occur simultaneously…  there is no way to tell which one occurred first
05:43:38 <Ghoul_> sorry if I misunderstood, not sure whether you mean building things with llvm using ghc, or building ghc with llvm
05:43:40 <mm_freak> so you have to assume simultaneity
05:44:12 <elliott> mm_freak: sure, it can happen. my interpretation is compatible with that
05:44:15 <quchen> Ghoul_: I meant "making GHC with BuildFlavour = perf-llvm"
05:44:21 <elliott> but an instance which relies on simultaneous occurrences to be useful sucks
05:44:29 <elliott> because of timing issues in the real world and so on
05:44:46 <mm_freak> elliott: you can have an arbitrary combinator that combines Event (a -> b) with Event a to Event b, returning the last value
05:45:05 <mm_freak> elliott: but that combinator is certainly not applicative and likely is not very useful either
05:45:19 <elliott> ok. I disagree
05:45:29 <mm_freak> elliott: what i have instead is this:
05:45:43 <mm_freak> mappend :: (Semigroup a) => Event a -> Event a -> Event a
05:46:02 <mm_freak> and a more general combinator:  merge :: (a -> a -> a) -> Event a -> Event a -> Event a
05:46:04 <Ghoul_> quchen: actually, looking at the trac I think the llvm things got fixed
05:46:15 <Ghoul_> so the answer might just be, that there is no real reason
05:46:28 <Ghoul_> could ask #ghc though, I don't think they would mind, and they could give a better answer
05:46:29 <DMcGill> does Monoid imply Semigroup?
05:46:51 <mm_freak> elliott: that way you can reconcile a button event with a periodic time event, say
05:47:07 <merijn> elliott: reactive-banana does what you want as follows: 'Event a -> Behavior a" and "Behaviour (a -> b) -> Behaviour a -> Behaviour b" (i.e. the Applicative of Behaviour)
05:47:10 <merijn> eh
05:47:17 * hackagebot tasty-golden 2.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.1 (RomanCheplyaka)
05:47:18 <elliott> merijn: but you don't get an Event out the end
05:47:19 <Ghoul_> (compile time is one, but it's negligible for a one-off build)
05:47:40 <merijn> elliot: Alternatively it also has "Behaviour (a -> b) -> Event a -> Event b"
05:48:05 <mm_freak> simultaneity of events is difficult in FRP…  there is no one solution to rule them all
05:48:05 <merijn> elliott: Which takes the value of the Behaviour at the time of the Event and applies that
05:48:06 <applicative> building ghc itself with llvm takes an eternity as I learned trying to build so as to use the new vector machinery quchen
05:48:10 <Lethalman> at this point, I've seen some frp using sometimes Event and sometimes Behavior, what's the real difference?
05:48:18 <mm_freak> but i think all implementations follow the 'merge' concept
05:48:23 <Lethalman> I mean, when I expected an Event, I found a Behavior instead
05:48:29 <merijn> Lethalman: There is no or, Behaviour and Event are orthogonal
05:48:49 <Lethalman> merijn, I believe so, but I don't get it
05:48:49 <quchen> applicative: I've never done a perfect build of GHC, but I imagine it take a couple of hours. How much slower is LLVM?
05:48:52 <mm_freak> Lethalman: Event a = [(Time, a)], Behavior a = Time -> a
05:48:57 <merijn> Lethalman: Behaviour == a time varying value, think of it (conceptually) as a function "Time -> a"
05:49:09 <mm_freak> Lethalman: behaviors are time-varying values, events are discrete occurrences
05:49:15 <Lethalman> ah
05:49:33 <merijn> Lethalman: So behaviours have values that change over time, Events are things that happen at a specific point in time and have a value when they do
05:49:34 <applicative> quchen i'm not sure, i think it might have been twice as long
05:49:48 <Ghoul_> quchen: for regular stuff llvm takes about 3-4x longer to build. I've only ever built ghc with the ncg, but even then it takes me about 4-5 hours to do. It'd be a very very long build with llvm I think.
05:49:51 <merijn> Lethalman: A line of input arriving would be an event, it happens at time T and has a certain value
05:50:11 <merijn> Lethalman: Displaying "the last received line" would be a Behaviour, it always has a value, but which value changes over time
05:50:35 <applicative> oh is that right Ghoul_ , it would explain my impression of eternity
05:50:39 <Lethalman> merijn, you can ask a value for a past time value for both Event and Behavior?
05:50:40 <merijn> Lethalman: See also: http://conal.net/papers/push-pull-frp/
05:50:53 <mm_freak> Lethalman: theoretically yes, practically no
05:51:34 <merijn> Lethalman: I thought that paper was really readable (assuming you are comfortable with Functor/Applicative/Monad typeclasses)
05:51:55 <Lethalman> merijn, yes tried to read that paper once
05:52:00 <Lethalman> then didn't use frp much, will reread
05:52:04 <Lethalman> for example: http://weblog.luite.com/wordpress/?p=127
05:52:17 <Lethalman> I expected mousePosition to return an Event, not a Behavior
05:52:23 <quchen> Ghoul_, applicative: Alright, if it takes longer than a night I'll probably forget about it. Thanks for the info, I thought I could maybe speed up compilation with the LLVM-built compiler for free or something.
05:52:28 <Ghoul_> hah
05:52:28 <Ghoul_> if it were convenient to rent out an AWS for 50 cents a build, I'd take it.
05:52:59 <Ghoul_> quchen: run it overnight? :)
05:52:59 <merijn> Lethalman: Well, the mouse cursor always has a value, no?
05:53:09 <Maior> Ghoul_: spot instances ftw
05:53:21 <Lethalman> ah
05:53:35 <merijn> Lethalman: At time T the mouse cursor is at point X, the value of X varies over time
05:53:35 <quchen> Ghoul_: 4-5 hours times 3-4 is longer than a night. Unless you live in Greenland maybe.
05:53:37 <quchen> ;-)
05:53:45 <Lethalman> merijn, ok
05:53:48 <applicative> quchen it may speed up compilation later. though I don't know that the ghc's sort of behavior is the sort of thing llvm is good at optimizing; it seems it is necessary for the recent version of dph if you want the simd business
05:53:55 <merijn> Lethalman: Keys could be either Behaviour or Event, depending on your framework
05:54:31 <Lethalman> also, what's the whole point of using frp if at the end there's listen (values counter) (\n -> ....
05:54:36 <Lethalman> that seems a callback
05:55:03 <mm_freak> Lethalman: FRP doesn't use callbacks
05:55:19 <merijn> Lethalman: You could model keys as being a key + set of modifiers + pressedOrNot (i.e. a Behaviour) or KeyUp/KeyDown Event with as a value the key pressed
05:55:34 <Lethalman> I expected something like divText = (:) <$> "Count: " <*> counter or such
05:55:50 <Lethalman> +pure
05:56:16 <merijn> Lethalman: If you ask Conal, he thinks the majority of of FRP libraries aren't actually FRP. I'm only aware of reactive and reactive-banan (and apparently soon netwire 5!)
05:56:31 <Lethalman> ah netwire isn't really frp? :S
05:56:33 * Lethalman confused
05:56:48 <mm_freak> Lethalman: it's not strictly FRP…  you can easily "cheat"
05:57:00 <Lethalman> mm_freak, well, how do you deal with external systems if you don't cheat?
05:57:13 <mm_freak> Lethalman: example?
05:57:13 <Lethalman> if there's a callback giving you an event for example
05:57:50 <merijn> Lethalman: If your preexisting is using callbacks, you can't avoid implementing a callback
05:57:50 <applicative> conal attaches great importance to continuous time; why he thinks Double forms a continuum I'm not sure
05:57:53 <merijn> Lethalman: FRP is not magic
05:58:06 <merijn> applicative: Not just continuous time, also denotational semantics
05:58:18 <Lethalman> merijn, exactly, so what you mean by cheating?
05:58:36 <applicative> merijn: well, i was taking that for granted since conal is the topic
05:58:38 <merijn> Lethalman: I didn't mention cheating?
05:58:43 <mm_freak> applicative: Double doesn't have to be continuous for time semantics to be continuous
05:59:02 <Lethalman> merijn, sorry, it was referred to mm_freak
05:59:10 <donri> i never understood this "function of time" stuff, doesn't seem very useful outside animation?
05:59:16 <merijn> donri: Oh?
05:59:25 <merijn> donri: How about "show a dialog for X seconds"
05:59:32 <donri> that's an animation :p
05:59:33 <applicative> mm_freak: yes, i understand that in fact; its really just that 'continuity' seems much more of a blur than might first be expected.
05:59:39 <elliott> interfaces are just animation with input
05:59:45 <merijn> donri: Then anything with an interface is an animation...
05:59:47 <donri> i'm thinking of say, an irc bot
05:59:50 <mm_freak> Lethalman: example: 'noise' in netwire 4 is supposed to give you a noisy value…  at each point in time it has a value between 0 and 1
06:00:10 <donri> i guess time can be used for throttling and such, but why privilege time
06:00:15 <donri> it's just another parameter?
06:00:15 <merijn> donri: If you only work with request/response things, then yes it's not that useful
06:00:25 <mm_freak> Lethalman: that's actually cheating, because if you look at time 0, then it doesn't care whether you look at time 1 or 2, it will give you the same "next value"
06:00:28 <applicative> frp should be called AOP since 'everything is an animation'?
06:00:44 <merijn> donri: Name one other parameter that you can't have as first-class language value
06:00:45 <mm_freak> Lethalman: as such it exposes the framerate of the underlying implementation
06:00:48 <mm_freak> that's cheating
06:00:57 <Lethalman> mm_freak, ah
06:01:13 <merijn> donri: The point of FRP is not so much "continuous time" it's "continuous time *as first class value*"
06:01:15 <donri> merijn: i mean if i have to put everything else in a Reader, say, why not time?
06:01:18 <Lethalman> mm_freak, in practice you look at the last value, and that's why it works somehow
06:01:36 <merijn> donri: How do you put time in a Reader?
06:01:42 <mm_freak> Lethalman: in that case yes, but there are cases where it doesn't work
06:01:50 <elliott> donri: because (Time -> a) doesn't actually work.
06:02:05 <elliott> FRP is the theory of how you can make values dependent on time work.
06:02:20 <elliott> that's where the notion of a behaviour comes from.
06:02:22 <merijn> donri: Your problem is that (like me for a while) you are to blinded by just a single possible implementation approach (i.e. the arrowized FRP stuff like netwire 4)
06:02:39 * elliott doesn't see what this has to do with AFRP :/
06:02:40 <merijn> donri: The notion that you have "an input" in the first place is completely orthogonal to FRP
06:02:44 <mm_freak> donri: a Reader-based implementation would have a so-called time-leak, which grows larger with every switch
06:03:03 <merijn> elliott: They all rely on inputs, and if you only update on an input, then just storing the "time value" in a Reader makes sense
06:03:09 * elliott thinks the problem with (Time -> a) is more semantic than operational, really :/
06:03:13 <zeroXten> heh, takeWhile
06:03:19 <merijn> Because every activation only has "one" time
06:03:42 <merijn> It is only once you let go of the implementation details that "first class time" makes sense as something to strive for
06:04:17 <mm_freak> donri: there is also an engineering issue when constructing events:  keyPressed :: [(Time, a)]
06:04:17 <mm_freak> donri: this would now involve lazy I/O
06:05:00 <merijn> donri: It's not "we have this arrow type thing where we put inputs in together with a time and then we can do things with time", the starting point is "I want to define behaviour that depends on time and then lets see how we can implement it"
06:05:41 <donri> but i don't see how time itself matters, i guess, except when it does (and is a special case of the application)
06:06:11 <mm_freak> donri: don't think of time as a certain value, think of it as an abstract concept
06:06:27 <mm_freak> just like "neighbour" is an abstract concept in topology
06:06:29 <h007> :t (\_->1)
06:06:30 <lambdabot> Num a => t -> a
06:06:53 <elliott> donri: time matters because FRP is about time :P
06:07:05 <elliott> if time isn't important then of course FRP won't be.
06:07:06 <donri> elliott: for an irc bot?
06:07:17 <elliott> it's your choice to link FRP and IRC bot
06:07:32 * applicative hadn't noticed the concept of 'a neighbor' in topology
06:07:35 <elliott> maybe a time-based approach to an IRC bot is beneficial, or maybe it's better to simply think of it as fed a discrete sequence of input lines
06:07:43 <elliott> that's for you to decide
06:07:46 <donri> but i keep getting told frp is a great fit for an irc bot :)
06:08:13 <mm_freak> donri: it is
06:08:24 <donri> mm_freak: and how does time fit into that picture?
06:08:35 <h007> http://www.iterasi.net/openviewer.aspx?sqrlitid=ixx7fcluvek_9lfolsxr_g
06:08:36 <mm_freak> donri: you're still thinking of time as a value
06:09:17 <mm_freak> donri: say 'newMessage' is the event for a new channel message
06:09:18 <donri> mm_freak: well i used to think it was supposed to be abstract but it seems the libs actually have a time parameter that's a Double or something
06:09:31 <mm_freak> donri: and you want to display a log of the last 10 log messages
06:09:44 <merijn> donri: Yes, but we also just covered most libraries don't really qualify as proper FRP :)
06:09:53 <RichyB> elliott, I don't understand that statement. An FRP program is a bunch of transformations from wires to other wires, right? If nothing keeps state or examines the clock, surely I've got an FRP program that just reacts to the current state of the universe and doesn't care when it is?
06:09:56 <mm_freak> donri: collect 10 . newMessage
06:09:59 <mm_freak> done
06:10:21 <mm_freak> donri: netwire 5 doesn't necessarily have such a parameter =)
06:10:22 <merijn> RichyB: netwire 4 isn't proper FRP, so discussing "FRP programs" using netwire 4 terminology is not going to lead you down a sensible path
06:10:25 <mm_freak> donri: Wire s e m a b
06:10:31 <mm_freak> if s = (), then there is no time parameter
06:10:43 <donri> mm_freak: so in netwire 4 "Time" is more like "step count"?
06:10:45 <mm_freak> and in fact you can't use 'time', 'for', 'after', etc.
06:10:51 <mm_freak> donri: in netwire 4 Time = Double
06:11:04 <RichyB> merijn, the only time I've tried to use FRP was the Elm language; is that using the same terminology as Netwire?
06:11:10 <mm_freak> in netwire 5 you can have:  Wire (Timed NominalDiffTime ()) e m a b
06:11:11 <merijn> RichyB: No clue
06:11:15 <mm_freak> which gives you real time
06:11:35 <merijn> RichyB: For the "proper" definition, consult http://conal.net/papers/push-pull-frp/ :)
06:11:37 <elliott> RichyB: I don't really care about arrowised FRP, frankly :p
06:11:42 <RichyB> (I got a bit stuck with Elm because I couldn't wrap my head around the fact that it doesn't seem to have an IO monad. ¬_¬)
06:11:45 <elliott> but I think you'd have to define "wire" etc.
06:11:53 <donri> mm_freak: that doesn't seem to be the netwire 4 collect
06:11:57 <mm_freak> RichyB: the terminology is slightly different
06:12:15 <mm_freak> RichyB: we have what is traditionally called a 'signal function':  SF a b
06:12:26 <mm_freak> if 'a' is fully polymorphic, then SF a b is a behavior
06:12:34 <mm_freak> donri: it's not
06:12:42 <RichyB> mm_freak, when you say "we", you are talking from the perspective of, uh, netwire 5? Or Conal's FRP?
06:12:50 <mm_freak> RichyB: AFRP
06:13:09 <RichyB> AFRP? Does the 'A' stand for "Actual" or "Arrowised"? ;)
06:13:20 <mm_freak> there is no semantic difference between FRP and AFRP…  it's just that we use different combinators and our concept is a bit more flexible =)
06:13:24 <donri> mm_freak: but what i originally meant was that all this (Double -> a) talk confuses me and only seems useful to certain animation uses
06:13:44 <mm_freak> RichyB: Arrowized (yampa/netwire) or Applicative (netwire)
06:13:44 <elliott> I actually kind of dislike it when people say a Behaviour a is Time -> a.
06:13:51 <prophile> conal elliott claims that one of they key properties of FRP is being able to handle values continuous in time
06:13:54 <elliott> I would accept "an a that varies over time" because it doesn't immediately suggest that (->) works.
06:14:01 <elliott> oh, I feel like I should clarify that I am not Conal right now.
06:14:11 <mm_freak> donri: you should really just read conal's paper
06:14:21 <donri> i've never hird of elliott
06:14:31 <prophile> he basically invented FRP
06:14:33 <prophile> with paul hudak
06:14:46 <merijn> donri: I linked one of his papers earlier :p
06:14:57 <merijn> A few times this discussion, actually >.>
06:15:10 <donri> [hird is elliott's last name, people]
06:15:27 <elliott> [crickets]
06:15:33 <merijn> Conal does hang out here reasonably often under the nick "conal"
06:15:36 <prophile> I confess a whoosh on my part there
06:16:09 <prophile> really?
06:16:31 <RichyB> Elliott is one of those really annoying people (like EdwardK) who accidentally stymies the community a bit because people don't do their own implementation of $somewhat_maths_y_thing, they wait around to see what implementations Conal|EdwardK will come up with. ;)
06:16:46 <edwardk> sorry!
06:16:49 <donri> prophile: i just don't see how a concrete Time value matters to time continuity except in edge cases like some animation
06:17:00 <RichyB> We love you for it. :)
06:17:03 <elliott> donri: the concrete Time value is a misnomer
06:17:09 <elliott> and it's not what you want for animation or whatever really either
06:17:13 <donri> elliott: except it's right there in the libs?
06:17:18 <elliott> which libs?
06:17:33 <elliott> some maybe, but that's more an implemetnation detail or confusion on the part of the author than anything
06:17:43 <elliott> except for ones that try to make (Time -> a) actually work where Time is a Double or wahtever
06:17:46 <elliott> (but I believe this to be fundamentally flawed)
06:17:59 <elliott> also note that access to an actual system clock which gives you the time in UTC or whatever is a separate issue to the abstract notion of time-varying values you get in FRP.
06:18:33 <RichyB> Are you saying that I should think of FRP values as time-varying because the inputs change over time instead of because the clock is moving forward?
06:18:44 <merijn> RichyB: They can do both
06:18:44 <mm_freak> donri: as a user of FRP you don't get to see that Double, if it exists
06:18:59 <merijn> RichyB: FRP allows for values that vary even if inputs don't
06:19:14 <RichyB> merijn, interesting. I didn't know that.
06:19:16 <mm_freak> donri: FRP that supports real-time animation usually gets a time delta to the last frame…  but that's internal and shouldn't really matter to you
06:19:25 <merijn> RichyB: In fact, that's one of the reasons for it being thought of
06:19:33 <mm_freak> donri: but it enables you to write things like this:  10 + 2*time
06:19:36 <donri> i guess "frp is about functions of time" is like "monads are space suits"
06:19:44 <RichyB> I'll have to read Conal's paper. I kinda assumed that the way you achieved that was to have an input coming from a clock.
06:19:44 <mm_freak> which starts at 10 and increases with twice the speed of real time
06:19:50 <elliott> FRP is about time-varying behaviour, but not actual functions with a time parameter
06:19:50 <donri> it only makes sense to people who already understand the true abstraction
06:19:59 <elliott> RichyB: I mean that the internal notion of the system changing over time isn't necessarily related to how you measure the time with actual hardware or whatever.
06:20:00 <mm_freak> donri: agreed
06:20:01 <merijn> donri: I prefer "frp is about continuous, first class, time"
06:20:08 <elliott> I think first-class is misleading.
06:20:11 <elliott> it implies you have a value that represents time.
06:20:12 <merijn> donri: Functions are really orthogonal to the entire thing
06:20:14 <elliott> that's not necessarily true.
06:20:31 <merijn> elliott: Right, I meant that the "behaviour over time" is first class
06:20:44 <merijn> i.e. you can pass changes over time to other things that then change over time differently
06:21:06 <elliott> that isn't quite true in AFRP
06:21:11 <donri> or perhaps the better analogy is this whole "IO is state over the entire world" nonsense
06:21:11 <elliott> not that I necessarily object to excluding it as being FRP :P
06:21:19 <merijn> "computation using first class, continuous time-varying values"
06:21:41 <quchen> Does anyone else here frequently need `return ()` a lot of times? Would `unit = pure ()` be something useful to have in Control.Applicative?
06:21:41 <merijn> elliott: If that doesn't hold, it's not "proper" frp
06:22:01 <mm_freak> quchen: see 'void' in Control.Monad
06:22:15 <mm_freak> other than that i'd prefer to actually write 'return ()' =)
06:22:19 <quchen> mm_freak: Yeah but that one takes an argument
06:22:23 <quchen> Alright
06:22:48 <merijn> Ok, I'm as happy as I'm likely to ever be with my last summary
06:22:54 <quchen> I was thinking more of "maybe unit XYZ" as a possible use case
06:23:17 <elliott> quchen: "nil" might be a good name for it if you want one
06:23:17 <mm_freak> elliott: well, the major difference between FRP and AFRP is that in AFRP composition is external and behaviors are mostly self-contained
06:23:29 <elliott> quchen: it's half of the zippy style Applicative
06:23:46 <mm_freak> elliott: FRP: integral 0 (integral 0 (pure 1)), AFRP: integral 0 . integral 0 . pure 1
06:23:53 <quchen> elliott: Yes, but ** isn't nearly as useful, is it? That's why I wasn't asking for the full thing
06:24:18 <mm_freak> elliott: i'd go as far as to say that's the defining difference
06:25:05 <applicative> quchen: people bring this up all the time, but then fight over the name. i prefer 'done', for no good reason
06:25:23 <mm_freak> i still prefer 'return ()'
06:25:27 <mm_freak> don't invent too many aliases
06:25:41 <applicative> mm_freak: you need parentheses in the context quchen mentioned,
06:25:49 <mm_freak> then use parentheses
06:25:54 <applicative> mm_freak: return () is fine; but (return ()) is ugly
06:26:04 <quchen> Yeah, that's my main issue with (return ()), it looks like it's from Lisp land :P
06:26:06 <mm_freak> applicative: that's not really return's fault, it's ()'s fault
06:26:07 <elliott> maybe I should play around with FRP semantics again sometime.
06:26:20 <elliott> also, the correct name is (||) with idiom brackets
06:26:25 <mm_freak> anyway, i really don't get why people have such a problem with parentheses
06:26:28 <elliott> not to be confused with (|), which is empty.
06:26:32 <applicative> (|)
06:26:46 <applicative> is empty, how is (||) read?
06:27:10 * applicative hides Prelude (||)
06:28:25 <elliott> applicative: well, it's nice to say (| a, b |) for (,) <$> a <*> b
06:28:30 <elliott> so it extends naturally to (| |) being pure ()
06:28:44 <elliott> just think of idiom brackets as regular parens that get made magically applciative by the |s
06:28:45 <applicative> that's really awsome yes.
06:28:49 <elliott> then (||) is the applicative version of ()
06:29:03 <Lethalman> that reminds me of [: :]
06:29:48 <quchen> HEAD seems to like [::] a lot
06:30:02 <quchen> Is that some new parallel list notation or something?
06:30:10 <Lethalman> quchen, it is
06:30:18 <applicative> well, not lists though
06:30:31 <Lethalman> list comp
06:30:58 <haasn> (||) looks to me like (Data.Bool.||)
06:31:34 <elliott> oh, I guess it'd have to be (| |)
06:31:38 <applicative> parallellistcomp is [x + y | x <- xs | y <- ys] as zipWith (+) xs ys
06:31:39 <elliott> a shame
06:31:52 <merijn> haasn: It's supposed to be "(| f a b c |)" == "f <$> a <*> b <*> c"
06:32:11 <haasn> yes what elliott said makes more sense
06:32:16 <elliott> I like the alternative syntax you get from it
06:32:27 <elliott> (| f x | g y |) is (f <$> x <|> g <$> y)
06:32:30 <elliott> and (|) is empty
06:32:38 <applicative> [:a:] is paralle arrays
06:32:39 <haasn> that's very cute
06:33:02 <Ghoul_> applicative: paralell? as in, threaded?
06:33:38 <applicative> Ghoul_: it's a dph thing, see e.g. http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell#A_simple_example
06:34:15 <Ghoul_> oooh okay
06:34:39 <applicative> Ghoul_: note that the example uses a parallel-in-the-sense-of-ParallelListComp comprehension, within a parallel array comprehension
06:36:18 <Ghoul_> it all looks cool, but repa does this with less fuss I think
06:36:20 <applicative> the type of comprension that uses | blah | blah | blah ] should be called something else, like zip comprehension, though parallel is the perfect name in fact
06:38:24 <mm_freak> btw, what happened to DPH?
06:39:04 <applicative> in the she source, (|f a b c|) turns into pure f <*> a <*> b <*> c which I guess is smoother to implement
06:39:31 <applicative> mm_freak: well they seem to beaver away at it
06:39:39 <elliott> I'd like (| f x |) to work for Functors on principle
06:39:51 <applicative> that's a good point
06:40:30 <mm_freak> i wonder if we actually need DPH given both repa for unboxed arrays and parallel strategies for arbitrary data structures
06:41:00 <applicative> mm_freak: well repa is pretty hard to use ...
06:41:10 <mm_freak> applicative: huh?  not really
06:41:22 <mm_freak> it has a learning curve, but after that it's pretty straightforward to use
06:41:24 <applicative> i hate the dimension types
06:41:34 <applicative> but i havent used it lately
06:41:35 <mm_freak> what would you prefer?  Data.Ix?
06:41:37 <Ghoul_> stream fusion is nice
06:41:43 <applicative> hah, ok point take
06:41:45 <applicative> taken
06:42:01 <mm_freak> applicative: i wasn't really making a point =)
06:42:13 <applicative> ok counterpoint taken
06:42:43 <mm_freak> repa shapes are there to make sure that your arrays are rectangular
06:43:26 <applicative> anyway, i had to fret about dph trying to build the new vector; it has for example the fancy simd machinery now as vector is supposed to
06:43:36 <applicative> dph does
06:43:44 <mm_freak> is it usable?
06:43:56 <applicative> dph, I dont know
06:44:45 <mm_freak> hmm, apparently DPH and repa solve the same problem
06:46:15 * applicative is a yarr man himself, http://hackage.haskell.org/package/yarr ;)
06:46:44 <donri> quchen: that's traverse, i think?
06:47:03 <donri> :t traverse print (Just "hi")
06:47:04 <lambdabot> IO (Maybe ())
06:47:15 <donri> :t traverse_ print (Just "hi")
06:47:16 <lambdabot>     Not in scope: `traverse_'
06:47:17 <lambdabot>     Perhaps you meant one of these:
06:47:17 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
06:47:21 <donri> :t F.traverse_ print (Just "hi")
06:47:22 <lambdabot> IO ()
06:47:49 <mm_freak> i wasn't even aware of yarr until now =)
06:47:51 <quchen> donri: You wizard!
06:48:00 <mm_freak> i'll give it a try later
06:48:52 <quchen> donri: Now that you mention it I remember the discussion about using for/for_ a couple of weeks ago
06:48:58 <donri> quchen: and for_ = flip traverse_
06:49:07 <mm_freak> right now my favorite parallelization concept is still strategies
06:49:23 <mm_freak> mostly because i can parallelize everything, not just unboxed arrays
06:49:34 <applicative> what, not monad-par ?
06:49:38 <applicative> ;)
06:49:38 <mm_freak> nope
06:49:40 <mm_freak> ;)
06:49:53 <quchen> What's wrong with monad-par? (Apart from the fact that it has different use cases)
06:50:05 <saml> > monad-par
06:50:06 <lambdabot>   Not in scope: `monad'Not in scope: `par'
06:50:06 <lambdabot>  Perhaps you meant one of these:
06:50:06 <lambdabot>  ...
06:50:13 <mm_freak> although monad-par has one advantage:  it can parallelize stream processors
06:50:30 <applicative> > text "@hoogle monad-par"
06:50:33 <lambdabot>   @hoogle monad-par
06:50:49 <applicative> darn those additional spaces
06:50:56 <donri> or @hackage, rather
06:50:58 <mm_freak> applicative: wouldn't work anyway
06:51:07 <mm_freak> IRC does not echo
06:51:12 <applicative> donri oh yeah
06:51:59 <applicative> > text " " $$ "@hackage monad-par"
06:52:00 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
06:52:01 <lambdabot>              w...
06:52:04 <quchen> applicative: Those spaces make a lot of sense in case Kappabot comes back
06:52:11 <applicative> > text " " $$text  "@hackage monad-par"
06:52:12 <lambdabot>  @hackage monad-par
06:52:17 <applicative> bah
06:52:27 * hackagebot module-management 0.17.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.17.1 (DavidFox)
06:52:47 <donri> > text "" $$ text "@hackage monad-par"
06:52:48 <lambdabot>   @hackage monad-par
06:53:17 <applicative> > text " hello" $$text  "@hackage monad-par"
06:53:19 <lambdabot>    hello
06:53:19 <lambdabot>  @hackage monad-par
06:53:28 <applicative> tricky!
06:53:39 <donri> @say @hackage monad-par
06:53:39 <lambdabot> Maybe you meant: src slap faq
06:54:30 <applicative> lambdabot, you are the most awesome illustration of advanced security techniques!
06:55:04 <donri> @@ @hackage monad-par
06:55:05 <lambdabot>  http://hackage.haskell.org/package/monad-par
06:57:23 <elliott> you can use @where
06:57:38 <donri> that's cheating!
06:58:20 <donri> @echo testing testing
06:58:20 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "donri!~dag@unaffiliated/dagodenhall", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo
06:58:21 <lambdabot> testing testing"]} target:#haskell rest:"testing testing"
06:58:28 <donri> eeeh
06:59:10 <Saizan> on irc you don't get your own messages back from the server anyway, it's only an issue with two bots
07:06:36 <mbrock> Saizan: huh, you don't?
07:08:43 <mbrock> wait yeah I'm not surprised, just misremembered
07:10:45 <Eduard_Munteanu> Hm, is this thing familiar?   data Enumerable a = forall i. Enumerable { base :: i, step :: i -> Maybe i, value :: i -> a }    or some variation on that.
07:11:13 <elliott> that's also known as [a].
07:11:17 <Eduard_Munteanu> Basically Enum plus minBound from Bounded, with a hidden index.
07:11:34 <elliott> isomorphism left as exercise to reader
07:11:45 <Eduard_Munteanu> elliott: not always
07:11:57 <elliott> can you show me an (Enumerable a) that does not correspond to an [a]?
07:12:11 <elliott> or a program consuming an (Enumerable a) that cannot be written as one consuming an [a]?
07:12:47 <elliott> oh, hmm
07:12:50 <elliott> it is actually NonEmpty a
07:14:07 <mroman> hm
07:14:33 <elliott> Eduard_Munteanu: fromNonEmpty xs = Enumerable { base = xs, step = NE.nonEmpty . NE.tail, value = NE.head }
07:14:36 <Eduard_Munteanu> elliott: I think it is isomorphic but it makes indexing implicit and the responsibility of whoever constructs it. And that index can be reused for other purposes.
07:14:50 <elliott> the index is just isomorphic to the actual nonempty :)
07:14:52 <Eduard_Munteanu> Perhaps it shouldn't be hidden.
07:14:55 <elliott> the existential stops you doing anything interesting with it
07:15:57 <Eduard_Munteanu> Right I guess I want something like  data Enumerable k v = Enumerable k (k -> Maybe k) (k -> v)
07:16:17 <Eduard_Munteanu> That's what I actually have, I tried to be smarter without trying it first. :)
07:16:32 <Eduard_Munteanu> Anyway now the k can be shared.
07:17:01 <elliott> I think Enumerable k (k -> k) (k -> Maybe v) might be nicer.
07:17:03 <elliott> then it's more like [a].
07:17:06 <elliott> actually it's not, that's bad.
07:17:12 <elliott> because you could go from Nothing to Just with the (k -> k).
07:17:23 <Eduard_Munteanu> elliott: that's like Map and I'm trying to avoid Map because it isn't total in the keys.
07:18:11 <elliott> perhaps the k -> Maybe k should be part of a typeclass on k
07:18:15 <elliott> data Enumerable k v = Enumerable k (k -> v)
07:18:20 <elliott> then it's Store
07:18:27 <elliott> data Store s a = Store s (s -> a)
07:18:27 <Eduard_Munteanu> Oh.
07:18:28 <elliott> and you get a comonad
07:18:38 <elliott> and you just have class Key k where next :: k -> Maybe k
07:18:47 <elliott> and do Key k => ... Store k v -> ...
07:20:52 <Eduard_Munteanu> elliott: I think I still want an existential in case the code constructing the Enumerable needs to track state or whatever.
07:21:10 <elliott> I don't understand. you can track state without an existential
07:22:14 <Eduard_Munteanu> Perhaps   data Enumerable k v = forall i. Enumerable i (i -> Maybe i) (i -> k) (i -> v)   ... or just drop the 'v' completely and make a Set-like thing first.
07:22:36 <Eduard_Munteanu> Yeah, I know.
07:23:19 <elliott> I think if you get Store you know you're on to something, so you should do what I said. :p
07:23:32 <Eduard_Munteanu> Hm, yeah.
07:23:49 <elliott> you don't have to use a typeclass, you could pass around Enumeration k -> ...
07:23:52 <Eduard_Munteanu> elliott: Store is a comonad even with an existential 's' no?
07:23:54 <elliott> where type Enumeration k = k -> Maybe k
07:23:58 <Eduard_Munteanu> Yeah.
07:24:03 <elliott> as a separate thing to the Store
07:24:10 <elliott> Eduard_Munteanu: (exists s. Store s a) is isomorphic to a
07:24:36 <Eduard_Munteanu> elliott: yes but with Key you can iterate through the values of 'a'
07:24:53 <Eduard_Munteanu> I do need that aspect.
07:25:40 <Eduard_Munteanu> The reason I insist on functions is you make it harder to construct non-total maps from the index type to the value.
07:26:07 <elliott> Eduard_Munteanu: no you can't, or it's not existential :p
07:26:24 <elliott> anyway, Store + Enumeration is the same as your non-existential version
07:26:34 <elliott> (as is Store + a typeclass, with reflection)
07:26:45 <elliott> and you don't really want to bundle the key enumeration with the store, I think
07:26:50 <elliott> because what if you want to take two with the same key type?
07:27:41 <Eduard_Munteanu> Hm yes, in my actual usecase I need keys to have the same type.
07:29:38 <Eduard_Munteanu> Bah, I wish I could define provably injective functions in Haskell.
07:30:19 <Eduard_Munteanu> Then all of those enumerability and uniqueness properties would propagate to the value types.
07:30:29 <zomg> Provably injective
07:30:37 <zomg> Another one for FP the buzzword dictionary
07:30:38 <zomg> :D
07:30:57 <merijn> zomg: How is that a buzzword?
07:31:13 <ocharles> injective functions is discrete maths 101...
07:31:17 <zomg> In that I have no idea what it is and it sounds fancy
07:31:18 <zomg> :P
07:31:21 <elliott> truly, the ideas of a function being injective, or something being provable, were unknown to the world before 1990
07:31:23 <applicative> the concept 'injective' presupposes equality
07:32:07 * Hodapp spraypaints "your mom is a partial function" on Eduard_Munteanu's butt
07:32:11 <Eduard_Munteanu> The larger question I've been trying to answer is whether given a bunch of maps, you can put uniqueness constraints on any pairs of those types.
07:32:12 <zomg> I figured it had to be some math thing since everything seems to be a math thing with you guys
07:32:15 <zomg> ;)
07:32:21 <mauke> zomg: programming is a math thing
07:32:31 <Eduard_Munteanu> :D
07:32:32 <zomg> I can program but I can't math
07:32:35 <applicative> so even in the languages where you can 'prove something injective' you don't know what the heck you're doing anyway
07:32:44 <mauke> zomg: you're already mathing
07:32:55 <zomg> maybe like, scrub level mathing
07:33:03 <ocharles> it's the hurry-coward isomorphism!
07:33:05 <ocharles> sic.
07:33:08 <Eduard_Munteanu> applicative: right, but my types do support equality testing
07:33:13 <merijn> zomg: injective means that for all possible values from a specific input domain produces result that full within a certain output domain
07:33:17 * Hodapp drinks tea and stares at the channel.
07:33:24 <merijn> (or the other way around? I always forget...)
07:33:31 <zomg> merijn: I think I may have understood that :D
07:33:40 <Eduard_Munteanu> Also surjectivity is the harder one to prove. :D
07:33:46 <mauke> zomg: injective means f(x) /= f(y) if x /= y
07:33:53 <mauke> no overlaps in output
07:34:02 <zomg> Yeah sounds about right then :)
07:34:04 <merijn> right, that's what I get for trying to math from memory
07:34:19 <mauke> surjective means the function hits all possible outputs
07:34:28 <Eduard_Munteanu> Also if you have an enumerable map like that then you pretty much have uniqueness guaranteed for the domain (but not the codomain).
07:34:53 <Eduard_Munteanu> Simply because you can't define f 3 = True and f 3 = False simultaneously.
07:35:10 <mauke> e.g. if you have f :: Int -> Bool and f is surjective, then there exist x, y :: Int with f x = True and f y = False
07:35:34 <merijn> And bijective means both!
07:35:42 <Eduard_Munteanu> mauke: unfortunately you sort of need a pseudoinverse to prove surjectivity constructively, AFAICT
07:35:45 <merijn> Did I math properly?
07:35:52 <Eduard_Munteanu> Yes. :)
07:36:00 <Eduard_Munteanu> At least in Set. :P
07:36:10 <merijn> Eduard_Munteanu: That's the only place I care about!
07:36:37 <DMcGill> and this leads us nicely in to bijective homomorphisms i.e. isomorphisms!
07:37:14 <merijn> My math-to-English translator just replaces "isomorphic" with "the same" :p
07:37:29 <mauke> isopathy
07:37:32 <merijn> Just as it replaces "co-" with "opposite world-"
07:37:37 <DMcGill> sure, for a given value of "same"
07:37:54 <merijn> DMcGill: isomorphic is isomorphic to the same :p
07:37:59 <DMcGill> lol
07:38:03 <zomg> as much as people want to call programming math, the most advanced math I need in programming is addition, subtraction, division and multiplication... maybe boolean logic =)
07:38:17 <merijn> zomg: That's not math, that's arithmetic
07:38:19 <DMcGill> I've found that my maths training helped me think more logically
07:38:23 <mm_freak> my math-to-english translator replaces "isomorphism" with "\f -> exists g. g . f = id"
07:38:23 <cschneid> assuming param is a ByteString - is there a less roundabout way to get a number out of this. Specifically I expect an int64.
07:38:23 <cschneid>   let parsedParam = read $ T.unpack $ TE.decodeUtf8 $ param
07:38:24 <Eduard_Munteanu> zomg: well it's not all math, sure
07:38:26 <DMcGill> maths has nothing to do with numbers
07:38:28 <zomg> merijn: so you don't even need math!
07:38:33 <Eduard_Munteanu> zomg: but math is useful
07:38:46 <DMcGill> mm_freak: isn't it that f . g = g . f = id?
07:38:47 <Zenol> zomg: need, what means need here?
07:38:49 <zomg> see, stop calling programming math when someone like me who has been programming 13+ years can't even get it right
07:38:50 <merijn> zomg: Math helps you reason about invariants of your code
07:38:52 <zomg> ;)
07:38:53 <mm_freak> DMcGill: that's a type error
07:39:00 <mm_freak> DMcGill: (likely)
07:39:08 <Zenol> zomg: Actualy, you **need** nothing more than an assembler.
07:39:16 <DMcGill> you already did "g . f = id", you can't complain about function equality!
07:39:20 <merijn> zomg: And "coding by invariant" has (in my experience) been the most reliable way to avoid/reduce bugs
07:39:33 <merijn> zomg: Regular expressions are math!
07:39:36 <mm_freak> zomg: one thing people don't get is that math is not calculating stuff
07:39:42 <Eduard_Munteanu> Also math is sort of a terrible word for a bunch of pure disciplines.
07:39:45 <DMcGill> it's just a way of thinking
07:39:50 <mm_freak> in fact i'd say, programming is not math, it's logic
07:39:50 <merijn> zomg: They describe regular grammars! (Unless you use the vile perl heresy)
07:39:51 <DMcGill> of reasoning
07:39:51 <haasn> for some meaning of ‘calculating’
07:39:52 <elliott> the most advanced mathematics you need in programming is programming.
07:40:05 <zomg> mm_freak: see, that's what I was told math was in school
07:40:08 <Hodapp> Oh, it's like trying to explain some form of analysis to my dad and he'll say "Oh, so it's just math."
07:40:08 <DMcGill> merijn: there isn't a single regex library that is still regular
07:40:14 <Zenol> mm_freak: and logic is a branch of maths :)
07:40:18 <Hodapp> Yes, dad, it's just math, like ALL OF SCIENCE, PHYSICS, AND ENGINEERING.
07:40:23 <mm_freak> Zenol: no
07:40:27 <zomg> math is calculating stuff is what I've been taught in the 12 years I spent sitting in classrooms =)
07:40:27 <Eduard_Munteanu> Just about any pure discipline involving reasoning is called math.
07:40:37 <mm_freak> Zenol: logic is a branch of philosophy
07:40:57 <DMcGill> Hodapp: yep, you got it ;)
07:40:58 <Zenol> mm_freak: Er, so i'll have to tell to my teacher that he is not doing math but philosophy x)
07:41:04 <mauke> merijn: perl regexes are better than the rest
07:41:05 <Zenol> (a logician)
07:41:05 <Eduard_Munteanu> Hodapp: science is distinct in that it's not "pure", it's empirical.
07:41:16 <merijn> mauke: Because they're not regexes? :)
07:41:22 <mm_freak> Zenol: well, there is a branch of mathematics called "logic", but it's not the logic i'm referring to
07:41:27 <mm_freak> i'm referring to foundations
07:41:33 <mauke> merijn: #haskell-blah?
07:41:39 <geekosaur> well, ignoring (??{...}) at least
07:41:53 <Hodapp> Eduard_Munteanu: It's more that my dad seems to divide study down into "math" and "not math", where he tries to make sure the "math" part is just some silly little niche area
07:42:29 <Zenol> mm_freak: I don't find the 'logic' I use so while writing code so different from the logic I read.
07:42:32 <Hodapp> like, I mean, "math" as a whole is pretty much a sub-field that's about the same size and complexity as, say, "deep frying", right?
07:42:40 <Eduard_Munteanu> So yeah, if you want, you can say there are only three things: humanities (dealing with labels), physics (dealing with facts) and math (dealing with inferences) :)
07:42:51 <DMcGill> http://en.wikipedia.org/wiki/Dynamic_programming#History
07:43:03 <mm_freak> Zenol: each time you write a type signature you use that kind of logic =)
07:43:11 <DMcGill> funny story about the math/not math split
07:43:29 <mm_freak> Zenol: all of the symbols you see in type signatures come from propositional logic
07:43:39 <mm_freak> and that's not by accident =)
07:43:53 <Eduard_Munteanu> Although you can merge physics and humanities on the idea that humanities study things that push human buttons, empirically. :P
07:43:54 <Zenol> mm_freak: Yes I now, and although I never read the proof I'm awere of the curry oward isomorphisme (not sure of the spelling).
07:44:04 <mm_freak> howard
07:44:06 <mm_freak> isomorphism
07:44:15 <mm_freak> know
07:44:23 <elliott> hint: you're using the mathematics whether you acknowledge that's what it is or not. the fact that you're not having to think about it specially as anything more than programming is because it *is* programming.
07:44:24 <Hodapp> aware
07:44:34 <mm_freak> speling
07:45:25 <Zenol> mm_freak: but, what logic which isn't math you are talking about?
07:45:46 <bitonic> is `pronk' unmantained?
07:45:59 <mm_freak> Zenol: propositional logic was a good example…  math can be built on these foundations
07:46:22 <Eduard_Munteanu> Logics and math can easily be lumped together.
07:46:49 <mm_freak> Zenol: or let me put it this way:  you don't need math to construct logic, but you need logic to construct math
07:46:52 <Zenol> mm_freak: It's still what I call math.
07:47:05 <Hodapp> is it something that nerds do? YUP IT'S MATH
07:47:05 <bitonic> mm_freak: some would say the opposite
07:47:13 <mm_freak> i guess
07:47:25 <opqdonut> math as in the study of formal systems
07:47:35 <Hodapp> mm_freak: HAH! You GUESS! So you need inductive logic to construct... whatever the hell you were building.
07:47:38 <Zenol> mm_freak: The fact that a theory need to build on it doesn't means that studying how to build theories isn't math.
07:47:40 <opqdonut> some people prefer to call that logic and call the non-cool parts math, but w/e
07:47:43 <zomg> On the topic of invariants, I probably use something like that subconsciously when programming :P
07:47:55 <mm_freak> Hodapp: that "i guess" was really a "*sigh*" ;)
07:48:04 <zomg> and maybe some other things as well which I don't have names for because of my scrub-level math
07:48:07 <zomg> =)
07:48:09 <bitonic> mm_freak: see for example good 'ol Bob Harper: <http://existentialtype.wordpress.com/2013/06/22/whats-the-big-deal-with-hott/>
07:48:14 <Eduard_Munteanu> Perhaps you can call it metamath... and then say math = metamath. Russell hits again. :P
07:48:17 <Zenol> yeh, as opqdonut says, I'm of those who want to call study of formal system "maths".
07:48:36 <bitonic> mm_freak: actually sorry, this <http://existentialtype.wordpress.com/2012/08/11/extensionality-intensionality-and-brouwers-dictum/>
07:49:09 <Hodapp> I think the important thing we all should agree on is that since Haskell is Turing-complete, you may as well pick some simpler Turing-complete and solve all your problems that way.
07:49:10 * Hodapp hides
07:49:12 <mm_freak> bitonic: i've read that article
07:49:23 <bitonic> mm_freak: right, that's an article that argues the opposite
07:49:27 <mm_freak> logic and interpretation have always been separate concepts, and i think that's the way it should be
07:49:28 <bitonic> (of what you said)
07:49:33 <merijn> Hodapp: Ah, so you only program brainfuck? ;)
07:49:47 <mm_freak> bitonic: and i don't agree that it argues the opposite…  it poses interesting questions
07:49:53 <mm_freak> about interpretation
07:50:00 <elliott> this is -blah material by now, btw
07:50:05 <mm_freak> right
07:50:08 <mm_freak> i have to go anyway =)
07:50:17 <merijn> -blah is busy fighting about regexes and heroin vs morphine :p
07:50:20 <doomlord> are there any ides for haskel which can assist with its type inference .. eg hover over a symbol and it tells you the type there
07:50:27 <merijn> s/fighting/lecturing
07:50:46 <DMcGill> what was the argument against type-driven name resolution again?
07:50:47 <merijn> doomlord: If you don't mind something that's far from practical, check out Lamdu
07:50:52 <mm_freak> maybe we need #haskell-blah to take a universe argument =P
07:50:53 <mm_freak> bye =)
07:50:54 <doomlord> heh :)
07:51:02 <merijn> doomlord: https://github.com/Peaker/lamdu
07:51:15 <Hodapp> merijn: No, but I have coworkers who argue that since C++ is pretty close to how you express mathematics, there is no point in really using anything else.
07:51:20 <merijn> Peaker was demo-ing it at IFL, they've made amazing progress
07:51:44 <merijn> doomlord: It doesn't just tell you types of symbols, it does type-based auto completion :)
07:51:46 <doomlord> its a fairly suprious question , whats on my mind is - i've been getting into rust but have the uncomfortable observation that the IDE counts for more than the language when dealing with existing libraries
07:51:58 <doomlord> (imo) -  eg navigating etc.
07:52:04 <Zenol> which types the article is talking about?
07:52:16 <Zenol> logic's types or "haskell" types?
07:52:19 <doomlord> yeah type based autocompletion etc.
07:52:31 <merijn> doomlord: oh, if it's a curiosity thing, definitely check out lamdu. Things similar to it will be the state-of-the-art for functional languages for years to come :)
07:53:03 <doomlord> it seems to me the real practical benefit of so called "OOP", is you type a variable name, then press "dot", then get a nice dropbox of possible functions..
07:53:04 <merijn> doomlord: The Only(TM) downside it has atm, is that you can't actually compile anything you write with it :p
07:53:42 <Hodapp> gah, "OOP"
07:53:47 <zomg> doomlord: a lot of people who do OOP in dynamic languages aren't even usign that really :)
07:53:51 <doomlord> yeah i'm not a fan of OOP.
07:54:14 <doomlord> but i *really* like the assist with navigation of a codebase.
07:54:58 <zomg> You mean like 'jump to implementation' or whatever?
07:55:13 <doomlord> that and especially autocomplete
07:55:44 <Hodapp> doomlord: OOP has some wonderful ideas... and some shitty bastardizations and some implementations based on those bastardizations.
07:55:58 <zomg> I think that should be doable with languages like haskell too
07:56:20 <zomg> I mean Java is probably the strongest one when it comes to tooling and that's probably due to it not being a dynamic language
07:56:48 <Hodapp> doomlord: but one of the essays I read on it put it in a way that made sense: with OOP, your fundamental, default abstraction is that every object is a stateful RPC server. And that's fine, but it's really not a good default abstraction to have to use.
07:56:57 <merijn> You don't need OOP, even C has ctags
07:57:04 <merijn> There's tag generator for haskell too
07:57:09 <zomg> Yeah
07:57:12 <doomlord> tags are a lot better than nothing
07:57:38 <merijn> doomlord: tags in this sense are not annotations
07:57:46 <Hodapp> zomg: As much as I dislike Java, some of the tooling there is very nice.
07:58:06 <doomlord> i missed the c  in ctags. "TAGS" file :)
07:58:24 <merijn> doomlord: You just "compile" a list of name->file+line number mappings and editors use these for navigation, I know there's at least 3 or so programs that generate them for haskell
07:58:38 <zomg> Hodapp: yeah that's definitely the strongest part of it... but on the other hand, the weakness too.. would hate to use Java without an IDE
07:58:38 <doomlord> sure and i have them for rust too
07:59:03 <Hodapp> zomg: the neat part is how much of that tooling works not just on Java but on any JVM-targeting language
07:59:10 <doomlord> i've only written a trivial amount of haskell so can't comment on whether haskell needs it
07:59:23 <quicksilver> merijn: the haskell tags implementations I've seen don't actually work if you use the same name more than once
07:59:28 <quicksilver> which is pretty common in large projects
07:59:35 <Hodapp> e.g. if I write Scala, I don't get Java code, but I do get Java classes, and all the remote-debugging and profiling tools can work with that
07:59:48 <doomlord> part of the reason i ask .. i wondered if there are any IDE eengines that decouple type inference from the language (eg if they have an AST and ar edesigned to work with multiple languages)
07:59:57 <quicksilver> some of the other things perviously mentioned which use ghc-api and similar can get that right thuogh
08:00:20 <doomlord> i gather haskell has both forwards/backwards type inference, (wchih rust does, locally only)
08:00:42 <Hodapp> rust looks interesting
08:01:21 <Zenol> some things looks strange for me. Like, you can't define operator as you are allowed in haskell.
08:01:32 <Zenol> I haven't read any good explanation for that fact.
08:01:38 <doomlord> i hope it gains traction,but C++ has many 'fanatically loyal supporters' and to be fair new tooling/supporting libraries appears to be a sticking point
08:02:41 <Hodapp> to also be fair, Java tooling makes C++ tooling look like soggy punch cards
08:03:13 <doomlord> part of why the dream of a native, deterministic-memory managed language with *context-free-grammar* is appealing to me.
08:03:25 <Hodapp> ...OCaml?
08:03:28 * Hodapp runs
08:03:47 <Hodapp> Rust at least has a C FFI though; not perfect, but with a C wrapper you can use C++ libs in it
08:03:48 <Eif0> Hello, does (:) equals to (++) in terms of big-O?
08:03:54 <doomlord> (isn't ocaml all GC)
08:03:54 <merijn> Eif0: No
08:04:15 <Eif0> merijn: (:) -- O(1); (++) -- O(n)?
08:04:15 <nicoo> Eif0: (:) is O(1)
08:04:16 <merijn> Eif0: (:) is O(1), (++) is O(n) worst case
08:04:29 <nicoo> (++) is O(n) with n the size of the first list
08:04:32 <doomlord> the sticking point with C++ libs is ... overloading , and of course if they're heavily templated. rusts' generics aren't as powerful as C++ templates yet (partly they dont need to be since the most common patterns are inbuilt)
08:04:43 <Hodapp> meh, fuck C++ templates
08:04:53 <merijn> Eif0, nicoo: (++) can be more efficient (O(1)) in case of fusion, but that's not guaranteed
08:05:13 <doomlord> yeah but there's many important codebases the world uses in C++. In my line of work C++ is the only choice.
08:05:20 <nicoo> merijn: Yes, “smart enough compiler” © removes the use of (++)
08:05:37 <merijn> nicoo: No, but (++) was written to play well with fusion
08:05:38 <Eif0> Okay, got it. Thanks.
08:05:52 <nicoo> Hodapp: Why ? They are a very nice tool for blowing up the size of the binary
08:06:12 <merijn> so "map (+1) (l1 ++ l2)" travers the list once, not twice
08:06:30 <merijn> Eif0: additionally, (:) never has to copy list elements
08:06:45 <merijn> Eif0: (++) has to copy the entire prefix list in the worst case
08:06:48 <nicoo> merijn: Sorry, wasn't precise enough ; I meant that fold (l1 ++ l2) can get optimized away
08:07:45 <Hodapp> nicoo: what they do to compile time and to error messages is enough for me.
08:08:01 <tomejaguar> Can someone explain to me why "let manyPrints = replicate tenMillion (print "Hi") in sequence manyPrints" doesn't cause a stack overflow?
08:08:52 <Eif0> tomejaguar: Because iy doesn't get evaluated?
08:09:06 <tomejaguar> Eif0: ?
08:09:22 <doomlord> i reacally its idiomatic to work the opposite way in haskell always... $ for chaining opposite to  |> in F# or . notation in oop-style langauges
08:10:04 <Eif0> tomejaguar: Ah, nvm. Though you were in ghci and haven't seen `in'.
08:10:11 <nicoo> Hodapp: Don't you love GCC's mindless unfolding of all typedefs (though it's more GCC sucking than templates sucking : Clang gives much nicer errors)
08:12:08 <tomejaguar> Weird.  I do get a stack overflow with "let manyReturns = replicate tenMillion (return ()) in sequence manyReturns".
08:12:14 <tomejaguar> What's going on?
08:13:13 <Eduard_Munteanu> tomejaguar: the monad in question probably has a strict (>>=)
08:14:01 <Eduard_Munteanu> @src sequence
08:14:01 <lambdabot> sequence []     = return []
08:14:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:14:01 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:14:40 <Eduard_Munteanu> foldr + strictness spells stack overflow.
08:14:45 <tomejaguar> Eduard_Munteanu: the monad in question is IO
08:15:31 <Eduard_Munteanu> I think that has a strict bind yeah.
08:15:49 <tomejaguar> I am confused why I *don't* get a stack overflow with (print "hi") but I *do* get one with (return ())
08:16:24 <Eduard_Munteanu> tomejaguar: do you still get a stack overflow with 'return $! ()' ?
08:16:39 <tomejaguar> yes
08:16:44 <tomejaguar> But that may never be evaluated
08:16:50 <Zenol> Eduard_Munteanu: return $! () isnt just return () ?
08:16:52 <tomejaguar> Hmm, actually I guess it has to be
08:17:03 <Zenol> Eduard_Munteanu: since () is already in normal form...
08:17:06 <Eduard_Munteanu> Not sure for ()
08:17:07 <tomejaguar> for the IO to skip the return
08:18:36 <Eduard_Munteanu> tomejaguar: are you testing with GHC or lambdabot?
08:18:39 <tomejaguar> GHC
08:20:39 <Eduard_Munteanu> Still, the return itself might thunk.
08:21:07 <tomejaguar> True
08:21:11 <tomejaguar> I don't understand this
08:21:17 <tomejaguar> I'm not compiling with any optimizations
08:21:32 <Eduard_Munteanu> tomejaguar: oh, you definitely should.
08:21:48 <tomejaguar> I want to understand what's going on here
08:22:15 <Eduard_Munteanu> tomejaguar: even stuff like 'sum' may fail with no -O, unfortunately
08:22:28 <tomejaguar> I don't want to know why it fails.  I want to know why it succeeds.
08:22:32 <tomejaguar> It shouldn't succeed.
08:22:59 <Eduard_Munteanu> tomejaguar: possibly putStr has access to the IO constructor
08:23:09 <tomejaguar> Interesting.  What does that mean?
08:23:52 <Eduard_Munteanu> tomejaguar: it probably results in less indirection one way or another.
08:24:16 <Sculptor> hi
08:25:05 <Eduard_Munteanu> tomejaguar: not sure about this specific case, but unless 'return' is specialized for IO it results in dictionary passing, I think.
08:25:11 <Eduard_Munteanu> Sculptor: hi
08:25:53 <Eduard_Munteanu> tomejaguar: anyway, you should really turn on optimizations
08:26:09 <tomejaguar> I do when I actually build something to use.
08:26:19 <tomejaguar> At the moment I'm just trying to understand this behaviour.
08:26:26 <tomejaguar> Optimisations would make it harder to understand!
08:28:01 <mroman> > foldl1 (||) $ map ((==7)) [1..]
08:28:13 <lambdabot>  Terminated
08:28:21 <mroman> > foldr1 (||) $ map ((==7)) [1..]
08:28:25 <lambdabot>   True
08:29:28 <mroman> foldr doesn't always yield the same result als foldl?
08:29:30 <mroman> or does it?
08:30:03 <mauke> > foldl f z [x,y]
08:30:04 <lambdabot>   f (f z x) y
08:30:06 <mauke> > foldr f z [x,y]
08:30:08 <lambdabot>   f x (f y z)
08:30:17 <tomejaguar> huh
08:30:24 <mroman> So it's not
08:30:25 <mroman> ok
08:30:31 <Eduard_Munteanu> mroman: same result if associative, otherwise no
08:30:41 <tomejaguar> > id x
08:30:44 <lambdabot>   x
08:30:50 <tomejaguar> When did lambdabot get that power?
08:31:01 <merijn> Always
08:31:04 <merijn> > f x
08:31:06 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
08:31:06 <lambdabot>    arising from a us...
08:31:08 <merijn> aww
08:31:10 <merijn> I fail
08:31:13 <mauke> > x^2
08:31:15 <lambdabot>   x * x
08:31:15 <tomejaguar> That's fun.
08:31:21 <merijn> > foldr f x [a,b,c]
08:31:23 <lambdabot>   f a (f b (f c x))
08:34:00 <scripty> I'm super Newbie in Haskell , i accidently installed v 6.12.1 , how to uninstall or upgrade
08:34:34 <mroman> windows or linux?
08:34:38 <scripty> linux
08:35:04 <mroman> through your package manager?
08:35:06 <Eduard_Munteanu> scripty: depends on your distro?
08:35:10 <quicksilver> merijn: not always. You are young grasshopper.
08:35:21 <mroman> if so, then consult your package manager on how to remove it
08:35:29 <scripty> I use Linux Mint Julia
08:35:40 <mroman> upgrading is easy: Download a binary distribution from haskell.org
08:35:40 <quicksilver> sometime in early 2008 : http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
08:35:54 <mroman> untar it and do the usual make install
08:36:19 <mroman> I'm almost certain you can't build the newest version with a 6.x version
08:36:28 <Zenol> if i recall, ./configure and then make install.
08:36:37 <mroman> so you're probably better of by downloading a binary distribution instead of a source
08:36:41 <cschneid> I have a line like:   either (\_ -> return []) buildPostSplice p  -- how can I get rid of that silly lambda that just throws away the input.
08:36:43 <mroman> yes, ./configure is required too
08:36:45 <scripty> so no need of uninstall ?
08:36:54 <mroman> scripty: not really
08:37:06 <mroman> it just wastes disk space but it shouldn't harm
08:37:32 <mroman> it will install everything into a seperate directory
08:38:32 <mroman> I just installed the newest version today myself
08:38:46 <mroman> 1.) Download http://www.haskell.org/ghc/dist/7.6.3/ghc-7.6.3-i386-unknown-linux.tar.bz2
08:39:01 <mroman> install it (through ./configure and make install)
08:39:33 <mroman> and there you go :)
08:40:07 <Zenol> > x ^ 4096
08:40:08 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
08:40:11 <Zenol> :o
08:40:13 <mroman> after that I downloaded the haskell-platform-2013 source and compiled it
08:40:59 <kqr1> is there a neater way to do basically `\a b -> if f a b == k then f a b else g a b'?
08:42:23 <Zenol> kqr1: at least '\a b -> (if f a b == k then f else g) $ a b'
08:42:43 <kqr1> can you really do `f $ a b'?
08:42:50 <Zenol> err
08:42:51 <kqr1> doesn't that get parsed as f (a b)
08:42:52 <mroman> no
08:42:53 <Zenol> no $.
08:43:02 <kqr1> ah clever
08:43:12 <kqr1> hm
08:43:38 <tromp__> better: let fab = f a b in ...
08:43:42 <kqr1> yeah
08:43:44 <Zenol> and actualy '(if f a b == k then f else g)'
08:44:04 <applicative_> scripty you might have to install 'cabal-install' by hand too, once you have the ghc mcroman linked above
08:44:06 <Erichsen> Can anyone tell me if it would be possible to define a type like for example type Point = (Float, Float) and then set a specific equality class for that?
08:44:29 <applicative_> you mean and Eq instance?
08:44:40 <Erichsen> yea
08:44:41 <Zenol> err, forget the last thing I wrote.
08:44:41 <supki> cschneid: what's the type of buildPostSplice?
08:44:53 <S11001001> Erichsen: needs newtype
08:44:55 <applicative_> Erichsen: no, it already exists, in this case it's no tragedy
08:45:14 <applicative_> Erichsen: you should define data Point = Point !Float !Float
08:45:42 <cschneid> supki: doesn't matter in this case, but it's a `Splice AppHandler` inside of snap. Was just wondering in general how to eliminate a throw-away input to a lambda
08:45:51 <Erichsen> applicative_: thanks :)
08:45:52 <applicative_> or even the laborious data Point = Point  {-#UNPACK-#} !Float {-#UNPACK-#} !Float
08:45:55 <cschneid>   (\_ -> something) -- is there a nicer way to throw away that one input
08:46:06 <supki> const something
08:46:46 <supki> anyway, you can do something like  p^!!_Right.act buildPostSplice  with lens, I think
08:47:02 <cschneid> ... what. :)
08:48:13 <supki> well, _Right peeks Rights from Either, act applies some action on that and ^!! returns a list of results :)
08:48:58 <cschneid> supki: but what about my behavior on Left, which is to do something, even if it's just a default `return []`.
08:49:44 <Eif0> Why does one may need lens? Is something like boost for cpp?
08:50:13 <cschneid> Eif0: it's a powerful way to inspect into lots of different kinds of data structures. I just don't understand it :)
08:50:40 <supki> cschneid: oh, I assumed you really wanted to return [] in the Left case
08:50:44 <sm> Eif0: it helps with accessing and updating deeply-nested immutable data structures
08:51:01 <edwardk> Eif0: lens is designed to make your code shorter and more composable. i get common reports of code shrinking 3x and becoming more legible in the process.  Think by analogy to jquery. you don't _need_ jquery to manipulate the DOM in javascript. It is just painful enough to do it without it that few people did
08:51:09 <cschneid> supki: ahh, yours would do that?
08:51:12 <Eif0> sm cschneid Ah, i seen, hence th name "lens".
08:51:14 <elliott> lens is the DLC expansion pack for Haskell
08:51:19 <supki> > Left 4^.._Right
08:51:21 <lambdabot>   []
08:51:37 <edwardk> @remember elliot lens is the DLC expansion pack for Haskell
08:51:37 <lambdabot> Done.
08:51:49 <Eif0> edwardk: Yep, that makes sense.
08:51:49 <elliott> wow, single t
08:51:52 <elliott> you insult my legacy.
08:51:54 <edwardk> clearly i should have figured out how to charge for lens =)
08:51:55 <supki> cschneid: should do; not so easy to test actions in lambdabot :)
08:51:58 <cschneid> supki: ok, that's cool. Although at this point in my haskell life, I'm going for clarity
08:52:01 <edwardk> @forget elliot lens is the DLC expansion pack for Haskell
08:52:01 <lambdabot> Done.
08:52:05 <edwardk> @remember elliott lens is the DLC expansion pack for Haskell
08:52:05 <lambdabot> Okay.
08:53:45 <petapetapeta> applicative_: Why do you use ! in this case?
08:54:32 <mroman> > foldl1 (flip (-)) [a,b,c,d]
08:54:33 <lambdabot>   d - (c - (b - a))
08:54:53 <elliott> > foldl1 subtract [a,b,c,d]
08:54:54 <mroman> is that available as a standalone tool like pointfree?
08:54:55 <lambdabot>   d - (c - (b - a))
08:55:01 <elliott> @hackage simple-reflect
08:55:01 <lambdabot> http://hackage.haskell.org/package/simple-reflect
08:56:26 <applicative_> petapetapeta: it just makes it strict, and unpack makes it smaller; it isnt absolutely certain that this would be better, just likely, it seemed to me.
08:56:39 <petapetapeta> applicative_: Okay :)
08:57:16 <applicative_> petapetapeta: i have the dubious methodological principle that if i am thinking of the things in the type as kind of like numbers, then for sure i want the fields strict.
08:58:03 <petapetapeta> applicative_: I guess it would make sense to do it like that. But I am not sure what the gain is
08:58:43 <applicative_> petapetapeta: the compiler is so good, there often is no gain.
08:59:25 <applicative_> but the builtin (,) constructor is distinctly lazy
09:00:21 <applicative_> petapetapeta: have you read things like http://www.slideshare.net/tibbe/highperformance-haskell
09:00:40 <petapetapeta> applicative_:  No I haven't seem that before.
09:00:50 <applicative_> it's a little paranoid about strictness but has some good lessons. I learned a lot from it (then unlearned a little.)
09:01:06 <petapetapeta> applicative_: I will check it out :) Thanks!
09:01:09 <applicative_> it's definitely one of the must-read tutorials
09:10:43 <Zenol> Can I write a "Getting Word8 ? Word8" myself
09:14:31 <merijn> Zenol: I dunno, where do Getting and ? come from?
09:14:41 <Zenol> merijn: A lens "Getting"
09:15:54 <Zenol> merijn: Actualy, I'm writing an emulator, and LD take a Getting and an ASetter'. And I could use the same LD if I could write a lens or something like that to acess the memory (for stuff like 'LD a (HL)' )
09:16:11 <Zenol> iLDrr :: ASetter' Registers Word8 -> Getting Word8 Registers Word8
09:16:51 <Zenol> since both LD (HL) a and LD a (HL) exists, maybe what I want to write is a lens for "(HL)"...
09:17:03 <Zenol> (I have a "a" lens generated by makeClassy)
09:18:59 <applicative_> these type synonymns are perfect chamber of horror!
09:20:46 <supki> I don't think that type signature makes much sense
09:21:12 <Zenol> applicative_: I find riting ASetter' instead of ASetter and write two time the same type easier.
09:21:13 <supki> aside from jokes about lens type signatures in general I mean
09:21:40 <elliott> Zenol: you don't want to return Getting
09:21:42 <elliott> return a Getter
09:21:50 <elliott> the -ing/AFoo types are only for consumption
09:21:58 <Zenol> supki: hum, it means that the first argument is a "register" field of size Word8 "write only", and the second is the same thing but "read only".
09:22:15 <Zenol> elliott: iLDrr :: ASetter' Registers Word8 -> Getting Word8 Registers Word8 -> VmS Clock is the true signature.
09:22:27 <elliott> ah, then yes :)
09:22:55 <Zenol> I should have writent "-> ..." after Getting :)
09:23:09 <Zenol> it seams that what I nead is a "simple lens".
09:23:11 <haasn> what's the premier, correct, fully standards compliant and optionally failure-tolerant HTML5 parsing library? :P
09:24:08 <elliott> haasn: Hubbub. but I didn't ever finish writing the Haskell binding so you can't use it.
09:24:27 <elliott> btw, HTML5 parsing is failure-tolerant by definition.
09:24:37 <elliott> the parser's behaviour on every sequence of bytes is pretty much precisely defined by the spec.
09:24:38 <haasn> ah, did not know that
09:24:43 <haasn> cool
09:24:59 <haasn> so what's the premier, correct, fully standards compliant HTML5 parsing *Haskell* library? :P
09:25:02 <donri> tagsoup? xmlhtml? duno about full compliance
09:25:07 <elliott> Hubbub once you write a Haskell binding to it.
09:25:09 <Hannibal_Smith> haasn, none
09:25:22 <Maior> a/win 41
09:25:31 <elliott> it should be very easy actually. IIRC the only problem was needing to patch one of its dependencies to be thread-safe and maybe they did that anyway in the time that's passed.
09:25:35 <mr-> 41?!
09:26:23 <Maior> mr-: 94+, but was aiming for 41, apologies
09:26:41 <donri> doesn't simply /41 work
09:27:49 <Maior> donri: -!- Irssi: Unknown command: 41
09:28:06 <donri> maybe it was a weechat feature or a plugin
09:28:08 <elliott> my record was 72 or something.
09:28:10 <donri> haven't used either in ages
09:28:12 <geekosaur> I think that's a (common but not default) plugin
09:31:10 <haasn> elliott: where's the stub of your hubbub bindings?
09:31:12 <Zenol> Hum, could someone write a small Lens' Box Int where data Box = Box { val :: Int } ?
09:31:19 <Zenol> So that I understand how it works.
09:31:33 <donri> makeLenses ''Box
09:31:53 <Zenol> donri: Yes but maeLenses won't work for the Lens I want to write.
09:31:53 * donri evil laughter
09:32:10 <haasn> Zenol: l f (Box i) = Box <$> f i
09:32:28 <elliott> haasn: an old hard drive
09:32:34 <donri> _val = lens val (\box newVal -> box { val = newVal })
09:32:36 <donri> or something like that
09:32:45 <elliott> don't use lens
09:32:50 <elliott> use lens but not lens.
09:33:13 <Zenol> elliott: What do you means?
09:33:21 <haasn> He means to use the lens library but not the ‘lens’ function
09:33:39 <Zenol> there is a lens function?
09:33:47 <donri> :t lens
09:33:52 <donri> :(
09:33:59 <Zenol>  Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
09:34:14 <Zenol> Don't understand anything from the type x)
09:34:32 <haasn> it means given a getter and an ‘update’ function it constructs a lens
09:34:40 <haasn> (s -> a) -- the getter
09:34:45 <haasn> (s -> b -> t) -- the ‘update’
09:34:59 <haasn> Functor f => (a -> f b) -> s -> f t -- Lens s t a b
09:35:15 <donri> Zenol: lens :: (a -> b) -> (a -> b -> a) -> Lens' a b
09:36:11 <elliott> it's bad though.
09:36:22 <elliott> because it's longer than the direct version and often slower and stuff.
09:36:58 <donri> elliott: it doesn't optimize away?
09:37:14 <elliott> the slowness is from the inherent lack of sharing in more complex cases
09:37:28 <elliott> btw, (<&>) is nice for defining lenses in direct style
09:37:29 <elliott> fewer ugly parens
09:37:51 <elliott> val box = _val box <&> \val' -> box { _val = val' }
09:38:05 <donri> nice
09:38:07 <elliott> as you can see, lens is just a crappy form of (<&>) :p
09:38:29 <elliott> er, that's not quite right
09:38:36 <elliott> val f box = f (_val box) <&> \val' -> box { _val = val' }
09:38:47 <elliott> _1 f (a,b) = f a <&> \a' -> (a',b)
09:38:56 <Zenol> @src <$>
09:38:56 <lambdabot> f <$> a = fmap f a
09:39:01 <elliott> or even f a <&> (,b)
09:39:21 <donri> ok that's less nice but alright
09:39:27 <Zenol> and I was thnking that <$> used pure etc...
09:39:28 <donri> i get the sharing point
09:39:43 <donri> @src liftA
09:39:43 <lambdabot> liftA f a = pure f <*> a
09:41:37 <Zenol> LYAH lied to me :p
09:43:33 <donri> Zenol: you sure?
09:43:38 <triyo> lukexi: could I bug you about your NSObject+HSInit.m code sample?
09:46:37 <napping> Is there anything suitable in recursion-schemes for traversing a term top-down, possibly substituting as you go?
09:46:45 <napping> transformTD :: (Traversable (Base t), Unfoldable t, Foldable t, Monad m) =>
09:46:49 <napping>                (t -> m (Maybe t)) -> t -> m t
09:47:49 <jfischoff> napping: I have been wondering something similar myself
09:48:06 <ParahSailin> so something like "(Locus {loc = i, candidates = ((PSet _ ((lsq,lst):_) _):_)})" could be made a lot prettier with lenses?
09:48:26 <napping> I'm trying to replace certain complicated subterms with fresh variables, and gather a substitution of the extracted terms
09:48:29 <napping> thus the monad
09:48:40 <elliott> monad traversals are bad, IIRC
09:48:41 <elliott> law-wise
09:49:54 <triyo> lukexi: when you get a moment, perhaps you could explain to me how I can bind my own Haskell function ...
09:50:34 <triyo> or point me to an example
09:50:48 <napping> Control.Lens.Plated has transformM which is bottom-up
09:51:01 <napping> actually, I might prefer the bottom-up order
09:51:18 <monochrom> fun fact: in the paper Data Types a la Carte, in the extensible expression evaluation example, the answer is 1337
09:51:40 <Zenol> donri: LYAH says that a <$> b is the same as pure a <*> b, and actualy it _does the same_ in the example given, but because Functor > Applicative, then it's not.
09:52:04 <donri> Zenol: it's semantically equivalent for every applicative
09:52:25 <Zenol> seams that my lens can be reduced to something like "HGm f vm = (vmWb vm) <$> f (vmRb vm)". Now I have to write a vmWb and a vmRb x)
09:52:47 * hackagebot HsOpenSSL 0.10.3.4 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3.4 (MasatakeDaimon)
09:53:11 <Zenol> donri: not sure that he explicitely stated that it's only true for applicative.
09:53:32 <donri> Zenol: it's true for any functor that is an applicative too :)
09:54:22 <napping> instance (Traversable t) => Plated (Fix t) where plate f (Fix t) = Fix <$> traverse f t
09:57:17 <jfischoff> napping: my current thought is do a bottom up traversal inserting a bunch of state actions, and then fold over the actions in top down order
09:57:44 <jfischoff> basically splitting things into two passes :p
09:57:45 <napping> jfischoff: I'm thinking I'll just define that Plated instance for fix, and use it
09:58:03 <Zenol> > _1 .~ 'a' $ (1, 2)
09:58:05 <lambdabot>   ('a',2)
09:59:37 <Zenol> > _1 %~ (x -> show x) $ (1, 2)
09:59:38 <lambdabot>   Pattern syntax in expression context: x -> show x
09:59:44 <Zenol> > _1 %~ (\x -> show x) $ (1, 2)
09:59:45 <jfischoff> napping: if you provide a one level evaluation for an F-algebra you can evaluate the whole thing. I'm not sure if you need fix but you would know best
09:59:46 <lambdabot>   ("1",2)
09:59:56 <jfischoff> but you would going bottom up
10:00:06 <napping> I'm building the terms I'm working on as Fix of a bsae functor
10:00:12 <joelteon> :t _1 %~ show
10:00:14 <lambdabot> (Show a, Field1 s t a String) => s -> t
10:00:16 <napping> that's where Fix comes in
10:00:25 <napping> I decided to skip the early exit for now
10:00:33 <jfischoff> yeah I know
10:00:44 <Zenol> writing all my functions in a state monad wasn't a good idea. Now I have to rewrite most of them.
10:01:03 <joelteon> why's that?
10:01:04 <jfischoff> napping: s/fix/plated
10:01:08 <jfischoff> my bad
10:01:32 <jfischoff> I was trying to say you might not need plated
10:01:46 <absence> is reverse state monad useful for anything?
10:01:52 <joelteon> not really
10:02:06 <absence> thank god :)
10:03:25 <joelteon> it's useful for saying to newbies, "look, monads are simple!" then show them time-traveling state
10:05:09 <absence> is that another way of saying it's useful to scare people away from haskell? ;)
10:05:50 <Zenol> a >>= return.b can be simplified?
10:05:59 <elliott> liftM b a
10:06:04 <donri> Zenol: fmap b a
10:06:07 <elliott> or fmap b a, b <$> a if it is a Functor
10:06:09 <elliott> which it is not necessarily.
10:06:09 <monochrom> where can I read about reverse state?
10:06:28 <absence> monochrom: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
10:06:32 <monochrom> thanks
10:06:51 <absence> monochrom: there even a package for it: http://hackage.haskell.org/package/rev-state
10:07:04 <Zenol> er, yes, fmap.
10:07:48 * hackagebot containers 0.5.3.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.3.1 (JohanTibell)
10:11:52 <Zenol> (1, 2) ^. _1
10:11:56 <Zenol> > (1, 2) ^. _1
10:11:58 <lambdabot>   1
10:12:07 <Zenol> :t (^.)
10:12:08 <lambdabot> s -> Getting a s a -> a
10:12:18 <Zenol> err, isn't ^. in Control.Lens ?
10:13:32 <scripty> Hello this question might be baseless with respect to functional oriented way but  i would like to know
10:13:39 <scripty> Can Haskell programming help coding in OO world ?
10:14:08 <donri> nope. next question!
10:14:09 <mkramer> I just got spammed by the FP Complete folks who are selling a Haskell IDE now…has anyone tried it?
10:14:32 <monochrom> haha
10:14:57 <donri> @faq Can Haskell programming help coding in OO world ?
10:14:57 <lambdabot> The answer is: Yes! Haskell can do that.
10:15:04 <donri> ok i guess i'm wrong
10:15:24 <mkramer> @faq Can Haskell divide by zero?
10:15:24 <lambdabot> The answer is: Yes! Haskell can do that.
10:15:47 <threedaymonk> @faq Can Haskell solve the Halting Problem?
10:15:47 <lambdabot> The answer is: Yes! Haskell can do that.
10:15:49 <monochrom> I don't know what sense "help" is. does this count? Haskell helps the OO world by reducing OO.
10:16:21 <Zenol> @faq Can Haskell cook my breakfast ?
10:16:21 <lambdabot> The answer is: Yes! Haskell can do that.
10:16:25 <Zenol> :o
10:16:30 <Zenol> How?
10:16:41 <donri> import Acme.Breakfast
10:16:56 <mkramer> Anyway, Haskell IDE. Haskell could, in theory, have a ridiculously helpful IDE
10:17:04 <Zenol> @package acme
10:17:04 <lambdabot> http://hackage.haskell.org/package/acme
10:17:08 <donri> scripty: sorry, we're not being helpful here. but it's an impossible question.
10:17:11 <mkramer> right? I mean, isn't Haskell just supremely susceptible to tooling?
10:17:48 * hackagebot cabal-debian 3.5 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.5 (DavidFox)
10:18:23 <doomlord> theth
10:18:47 <donri> mkramer: depends. the syntax is insanely hard to work with without a full parser, and even those aren't completely compatible with ghc. and if your code doesn't type check, there's much less you can say about it (although -fdefer-type-errors seems to work surprisingly well)
10:18:51 <scripty> donri hmmm , i thought i could learn Haskell in career point of view if it could help in the way i code in OO world .
10:19:12 <cschneid> scripty: I come from an OO / ruby background. Haskell has pushed me to think of types, minimize unbounded values (ie, nils and friends), make functional bits of code, separate from my io code
10:19:18 <donri> scripty: haskell will make you a better programmer and a worse OO programmer.
10:19:23 <doomlord> the thing about the oop-style ides's (forget the term OOP itself) isthe search of the codebase beinf performed when you type one parameter then ".", and you get a nice dropdown box of applicable functions.. and you can chain that over and over...
10:19:59 <cschneid> doomlord: making demeter sad. :)
10:20:25 <doomlord> i think haskell is usually written the other way round ?    foo $ bar $ baz x  instead of x.baz().bar().foo()
10:21:00 <cschneid> scripty: not sure what OO world you're coming from, but most of the OO languages have borrowed the idea of map / reduce and other similarly higher level functions. Haskell has a very pure & clean impl of those if you are working to properly understand & use them
10:21:21 <doomlord> (i'm not a fan of OOP, but  rather the chaining .. a.foo(b) .. )
10:21:43 <merijn> btw, is anyone still looking into getting TravisCI more up to date for haskell? I looked into it a while a go, but didn't have much time and someone else was working on it
10:22:01 <joelteon> i'd be happy to do that, but I'm not sure who to talk to
10:22:08 <shoret> the "without a full parser" problem is trivial to overcome, though -- check out haskell-src-exts
10:22:13 <merijn> doomlord: lens has (&) which is flip ($), so lets you work the "right way" around
10:22:33 <doomlord> oh nice. last time i asked about that people said .. "dont do that" :)
10:22:36 <donri> shoret: that was the "even those" comment
10:22:36 <scripty> People you scared me , saying i'll forget OO itself :)
10:22:39 <cschneid> doomlord: the $ approach isn't bad. you learn fast.
10:22:42 <merijn> joelteon: The people in the irc channel here on freenode are fairly responsive, I think travis uses puppet, so having a puppet (or whatever) script for it should help
10:23:02 <merijn> cschneid, doomlord: That's just because $ is not nice, you should prefer . to $
10:23:08 <doomlord> cschneid, sorry to sound like a broken record, but the other way round the experience in an IDE is magic .. you get a list of potential functions at each . :)
10:23:23 <merijn> "\x -> foo $ bar $ baz x" == "foo . bar . baz"
10:23:28 <donri> merijn: should be able to sudo add-apt-repo ppa:
10:23:30 <shoret> donri: in what way(s) is -exts not compatible with ghc?
10:23:56 <mkramer> donri: Imagine this. >mapM paths (hClose) *IE sees that doesn't typecheck, looks up the arguments on Hoogle, and suggests forM
10:24:02 <merijn> donri: Don't suppose you have a repo with an example travis config? :p
10:24:09 <doomlord> hoogle is pretty impressie
10:24:13 <Zenol> scripty: but it's true. I was a "OO" fan, until I was used to haskell way.
10:24:23 <donri> merijn: duno... it's what i did before they officially supported haskell at all
10:24:28 <doomlord> i am a multi-paradigm programmer.
10:25:00 <merijn> Lack of smarter auto-completion is way down my list of haskell priorities
10:25:22 <mkramer> What's at the top of your list?
10:25:22 <donri> merijn: https://github.com/dag/kibr/blob/3cd380aae56ddcffe351b5404cabe9551739e926/.travis.yml
10:25:24 <joelteon> I would like an IDE that suggests functions for you
10:25:39 <donri> merijn: but you'll probably have to find another ppa, this was 2 years ago
10:25:43 <Zenol> are they an emacs extention that allow seeing the type of every thing you have your cursor on?
10:26:03 <joelteon> yeah
10:26:05 <joelteon> hell, vim can do that
10:26:06 <shoret> Zenol: ghc-mod
10:26:16 <donri> hdevtools
10:26:36 <donri> shoret: https://github.com/haskell-suite/haskell-src-exts#non-comprehensive-list-of-supported-extensions
10:26:51 <doomlord> is writing a tool that does type-checking for haskel without using the whole haskell compiler considered too difficult, or too wasteful (replicating). In rust, the issue is the language is not mature enough- they give you the compiler-as-library, but it can't do everything clang can yet.
10:26:57 <Zenol> shoret: ghc-core-mod ?
10:27:03 <scripty> Zeonl Oh! I want to improve programming skills ... I write bad and ugly code :) .
10:27:15 <donri> shoret: and it parses some things differently, like some ghc-valid unboxed tuples fails with HSE
10:27:20 <doomlord> so far most people i've spoken to think it would be a waste to write a rust type-inferer.
10:27:40 <donri> shoret: i think HSE is great stuff btw, i'm just saying haskell isn't *all* "IDE friendly"
10:27:51 <shoret> Zenol: http://www.mew.org/~kazu/proj/ghc-mod/en/
10:27:54 <kier> SublimeHaskell supposedly has completions or something along those lines, but I've never looked into it (I only use it for linting & building)
10:27:56 <doomlord> i wonder if an IDE type inferer could be written that was a superset of several langauges .. eg use for haskell, use for rust , with different AST/parser plugin
10:27:58 <merijn> donri: Thanks!
10:28:00 <shoret> (http://stackoverflow.com/questions/15034392/find-inferred-type-for-local-function)
10:28:56 <merijn> doomlord: Type inference that general quickly becomes useless
10:29:03 <merijn> doomlord: And/or lisp
10:29:25 <mkramer> I'm curious to see what parts of GHC the IDE is using, but anyway, I am only talking hypothetically
10:29:53 <mkramer> hypothetically, static analysis on Haskell source should yield more information than static analysis on C++ or Java source
10:30:00 <donri> certainly
10:30:04 <doomlord> as far as i can gather, rusts ideas are in some way a  subset of haskell (no HKTs yet, no multi-parameter typeclasses)
10:30:11 <d3lxa> question: can I group types together and create an instance (of class) only for them?
10:30:16 <mkramer> more things are provably true about Haskell code, so, that should lead to more interesting IDE support
10:30:35 <doomlord> ... but the extra features different pointer/reference types, which are quite central
10:30:56 <donri> stuff like hoogle, hlint, @pl and @djinn would work far less well in most other languages, certainly
10:31:00 <shoret> sorry, meant: http://stackoverflow.com/a/15035701
10:31:46 <Zenol> shoret: cabal: There is no package named 'ghc-mode'
10:31:51 <Eduard_Munteanu> d3lxa: you can make a wrapper and write an instance for it
10:31:52 <mkramer> and yah, telling me what the inferred types of my let bindings would be awesome, I would love that
10:31:59 <geekosaur> ghc-mod
10:32:01 <mkramer> Even being able to click in the gutter and set breakpoints would be pretty sweet
10:32:02 <donri> shoret: hdevtools is faster
10:32:12 <Zenol> arg. I'm tired.
10:32:27 <shoret> donri: isn't hdevtools only for vim?
10:32:45 <donri> i think i read there was an emacs plugin
10:32:46 <merijn> mkramer: Let me once again pimp Lamdu :)
10:33:09 <donri> oh maybe just flymake
10:33:16 <merijn> mkramer: It's not haskell, but heavily "haskell inspired": https://github.com/Peaker/lamdu
10:33:18 <joelteon> clear
10:33:19 <joelteon> whoops
10:33:26 <Eduard_Munteanu> d3lxa: however that's not necessarily easier or nicer than separate instances.
10:33:33 <merijn> mkramer: Mostly because supporting all of haskell is really hard for a prototype...
10:33:37 <donri> can't imagine it'd be hard to port ghc-mod.el (or whatever) to hdevtools
10:34:02 <d3lxa> Eduard_Munteanu: which wrap do you use? say I have: data A = AX|AY|…, data B = BX | BY… then?
10:34:35 <mkramer> It sounds neat, but I've sworn off other languages for the time being
10:34:49 <mkramer> I need to go deeper in my own languages
10:35:02 <jfischoff> is there a simple way to trace out timings in a program?
10:35:09 <d3lxa> Eduard_Munteanu: my goal was to avoid copy/paste these instances and only change the type it applies to (as the body does *not* change at all)
10:35:09 <Eduard_Munteanu> d3lxa: data AOrB = ThisIsA A | ThisIsB B
10:35:40 <Eduard_Munteanu> d3lxa: oh... can't you make it a separate function?
10:36:02 <Eduard_Munteanu> d3lxa: then the instance might involve just calling that function
10:36:37 <Eduard_Munteanu> But that depends on your actual application.
10:37:06 <d3lxa> Eduard_Munteanu: yes I can, but still, have a lot of these types (actually these are dumb Enum)
10:37:07 <Eduard_Munteanu> Sometimes breaking one big typeclass into smaller stuff can be better, if you can use polymorphic functions for the rest of the stuff.
10:37:07 <ReinH> ls
10:37:12 <ReinH> whoops
10:37:59 <d3lxa> Eduard_Munteanu: my application is I have a lots of Enum types and I've written a generic instance that could be applied to all of them (because they all derive from Read, Show and Enum)
10:39:10 <Eduard_Munteanu> d3lxa: why not a simple function?
10:39:24 <d3lxa> Eduard_Munteanu: by the DRY principle I wanted not to copy/paste or try to use "one fits all" solution (I can make it work with FlexibleInstances, UndecidableInstances, OverlappingInstances << but some say it's evil, right? then is copy/paste "eviler"?)
10:39:30 <merijn> mkramer: You should still check it out, only to see the future potential for haskell!
10:39:55 <merijn> mkramer: There isn't much point in trying to use it anyway, there's no way to compile the language, you can only typecheck! :p
10:40:07 <mkramer> oh, I see
10:40:22 <merijn> Compilation is an implementation detail ;)
10:40:27 <mkramer> so true
10:40:28 <td123> I'm trying to bind a c lib to hs, is there a way to bind enum values to their own type value? currently I just newtype cint but that exposes more than what is needed
10:41:03 <Eduard_Munteanu> d3lxa: if all your types derive Read, Enum and Show and your instance only depends on those constraints instead of specific constructors etc., then you should be able to write that as a function, perhaps with some help from ScopedTypeVariables if you need to disambiguate types.
10:41:15 <merijn> td123: You can using the fancy new CApi stuff (which also support CPP macros!), hold on
10:41:57 <merijn> td123: Hmm, wait, actually it might be simpler to just use c2hsc
10:42:06 <donri> c2hs
10:42:27 <td123> hmm, Ok, I'll check it out, I've been using hsc2hs
10:42:50 <merijn> donri: No
10:43:10 <merijn> donri: http://hackage.haskell.org/package/c2hsc
10:43:11 <d3lxa> Eduard_Munteanu: yes it's true, i'm forced to use instance because I don't call the function myself (my case is To/FromJSON instances, where I call toJSON and it recurse for me) that said I could write my own toJSON function, right?
10:43:35 <joelteon> Doesn't look like hdevtools knows how to use a cabal sandbox, though
10:43:40 <merijn> td123: c2hsc tries to auto-generate the hsc code you need by parsing the C code :>
10:44:26 <td123> merijn: thanks, I'll check it out :)
10:44:56 <joelteon> how do you tell GHC where to look for packages?
10:45:00 <td123> merijn: does it handle creating a new data with unique values for enums?
10:45:32 <merijn> td123: It should
10:45:46 <td123> merijn: wow, that sounds too good to be true, thanks
10:45:46 <merijn> td123: It's not 100% flawless, but for simple headers it should Just Work (TM)
10:46:08 <merijn> td123: So it kinda depends how messy/complicated the headers you use are
10:46:36 <merijn> td123: auto-generates Storable instances too
10:46:46 <Eduard_Munteanu> d3lxa: you can make a newtype wrapper and declare a (Show a, Enum a, Read a, ...) => Wrapper a  instance
10:46:47 <merijn> anyhoo, gotta run
10:47:07 <Eduard_Munteanu> Erm  ToJSON (Wrapper a).
10:47:21 <Eduard_Munteanu> That shouldn't overlap with anything.
10:47:47 <Eduard_Munteanu> And it should be like  newtype Wrapper a = Wrapper a
10:47:49 * hackagebot DBus 0.5.0 - D-Bus bindings  http://hackage.haskell.org/package/DBus-0.5.0 (AlexanderKojevnikov)
10:48:55 <d3lxa> Eduard_Munteanu: then could I match like this? myfn (mine::Show) -> … show … I doubt I can, it means I'm forced to match on each of these ItsA, ItsB, … or am I wrong again?
10:49:26 <d3lxa> Eduard_Munteanu: ok I think I've misread you, I understand
10:49:38 <Eduard_Munteanu> d3lxa: you can make instances for Show etc. like   instance (Show a) => Show (Wrapper a)
10:49:58 <Eduard_Munteanu> d3lxa: or just use GeneralizedNewtypeDeriving and write 'deriving Show'
10:50:48 <Eduard_Munteanu> d3lxa: also you're not making specific constructors, just a wrapper for any type.
10:51:00 <Eduard_Munteanu> Forget the ItsA, ItsB etc.
10:53:20 <Eduard_Munteanu> IOW it will work for any type you put in as long as it derives those classes.
10:53:35 <enthropy> Eduard_Munteanu: deriving Show doesn't need GeneralizedNewtypeDeriving
10:54:10 <enthropy> even if you have a newtype, it still does the normal thing for Show
10:54:22 <Eduard_Munteanu> Er, right.
10:54:29 <d3lxa> this means you will see the wrapper in the Show/Read
10:55:03 <Eduard_Munteanu> d3lxa: oh, if that's an issue you can write a "passthrough" instance yourself.
10:55:48 <Eduard_Munteanu> instance Show a => Show (Wrapper a) where show (Wrapper a) = show a
10:56:29 <d3lxa> Eduard_Munteanu: oh, that's what you meant, a super-general newtype
10:58:01 <enthropy> d3lxa: did you figure out why you had the wrong name?
11:01:15 <ReinH> edwardk: When monoids became reducers, what happened to tropical semirings? They are some form of reducer now, right?
11:01:40 <ReinH> edwardk: I might just grab your old monoids package so I can work directly with tropical semirings for clarity, or reimplement
11:01:54 <ReinH> or just use roconnor's definition
11:02:17 <monochrom> tropical semirings and arctic magma? :)
11:02:45 <ReinH> monochrom: confirm
11:06:36 <eevar> any feedback on https://github.com/ivarnymoen/nanomsg-haskell ? -- do keep it light, I don't know what a monad is ;)
11:10:13 <bergmark> eevar: you can use {-# LANGUAGE EmptyDataDecls #-} so you can write `data Foo` instead of `data Foo = Foo`. and you have some `_ <- foo`'s in your examples, change them to `void foo`
11:10:42 <Cale> (I would personally just change them to 'foo'
11:10:44 <Cale> )
11:11:05 <eevar> bergmark: added to my todo list, thanks
11:11:12 <bergmark> some of them return stuffs
11:11:20 <Cale> Sure, so?
11:11:23 <bennofs> Is it possible to compile a static library that includes all of GHC's library using ghc?
11:11:47 <d3lxa> enthropy: you mean with my TH? no
11:11:53 <Cale> You'll get a warning if you have -Wall on, but -Wall complains about lots of stuff which is fine.
11:12:44 <evancz> Hello! Does anyone know a way to turn a (Parser a) into a (Parser (String,a)) where the string is the original source?
11:13:06 <d3lxa> Eduard_Munteanu: thank you for your help =)
11:13:09 <eevar> cale: seeing a long stream of warnings when you compile something is a bit disconcerting to me
11:13:23 <evancz> also is chrisdone around? We hae been talking about using language-ecmascript in Elm and I was curious about how it has gone in Fay
11:13:48 <monochrom> evancz: is that Parser from parsec?
11:13:49 <bergmark> evancz: what are you going to use it for?
11:14:31 <bergmark> we just use it to parse ffi expressions, the developers seem really nice though :) they sent us some PR's for stuff that might break in the future
11:14:32 <evancz> monochrom: yes
11:14:32 <enthropy> d3lxa: in the [d| |], it would usually refer to the toJSON that you imported
11:14:44 <enthropy> but I guess it gets confused by the one on the right-hand-side
11:15:08 <evancz> bergmark: the plan is to maybe use it for JS generation and perhaps some optimization passes
11:15:16 <d3lxa> enthropy: oh, yes, for that I tried mkNameG, not sure if that solved but I think so
11:15:20 <monochrom> then it is: \p -> do { str <- getInput; a <- p; return (str, a) }
11:15:24 <enthropy> or not
11:16:09 <evancz> monochrom: so if you run 5 of these in sequence, would you get "tails"?
11:16:09 <bergmark> evancz: Fay uses a custom JS ADT that only contains the things we need
11:16:18 <monochrom> yes
11:16:31 <enthropy> d3lxa:  valD (varP 'toJSON) (normalB [| toJSON . id |] ) [] -- uses the "right" toJSON
11:16:32 <ion> liftA2 (,) getInput
11:16:34 <evancz> bergmark: I see, making it easier to optimize?
11:16:40 <monochrom> getInput gives you what p will see
11:17:01 <evancz> monochrom: okay, so I can do that, get the position at the beginning and end and take the difference
11:17:14 <bergmark> evancz: yes, special nodes for Thunks etc, and less verbose to generate the tree
11:18:03 <enthropy> d3lxa: mkNameG would work too
11:18:13 <evancz> bergmark: my suspicion was that having an Elm specific version would be "better" in some sense, but I felt like there could potentially be some teamwork within haskell
11:18:16 <evancz> here's the idea
11:18:32 <Zenol> wonderfull. Now I can remove even more code thanks to the lens I added ;D
11:18:51 <evancz> If language-ecmascript supports tail calls or minification or whatever else, all haskell for web projects can benefit from this
11:19:11 <evancz> do you think the tradeoffs for any particular project are too big to make the group effort pay off?
11:19:17 <d3lxa> enthropy: writting everything in TH is quite verbose, I prefer your solution :)
11:21:40 <bergmark> evancz: tail calls would be cool. I can't say if it would be worth it, it would most definitely be a substantial rewrite of our code, maybe if we can map our custom adt to the language-ecmascript adt
11:21:59 <napping> Does anyone know about http://hackage.haskell.org/trac/hackage/ticket/517
11:22:09 <bergmark> evancz: we rely on closure for minification, not sure if language-ecmascript can compete with that
11:22:50 <evancz> bergmark: yeah, I agree, but I don't like sending people through a ton of different tools to get a good result
11:23:16 <evancz> but yea, perhaps that is not a practical idea
11:23:40 <napping> Is it still impossible to get cabal install to build documentation with --hyperlink-source?
11:23:47 <evancz> bergmark: do you package Closure in, or do you have people install it separately?
11:24:06 <donri> napping: --haddock-hyperlink-source
11:24:07 <bergmark> evancz: separately
11:24:18 <evancz> do you guys have an installer?
11:24:23 <bergmark> we have a --closure flag that looks for things that will break
11:24:35 <evancz> nice, that makes sense
11:24:48 <evancz> I just got rid of the last couple things that would break closure :)
11:25:02 <evancz> I wonder if an installer would let you package this kind of thing
11:25:44 <evancz> correction: *hopefully* got rid of
11:25:49 <bergmark> we have a custom pretty printer also, that would be nice to get rid of
11:26:06 <napping> donri: ah, it's just impossible to set in the config file?
11:26:18 <evancz> yeah, that was one thing besides TCO that I thought would be a great public resource
11:26:27 <donri> napping: yes, though maybe with 1.18
11:26:45 <evancz> currently language-ecmascript is not super pretty, but setting up a "readable" and "mini" printer seems doable
11:27:08 <evancz> and for things that don't concern performance, creating a mapping to it should be no problem?
11:27:37 <bergmark> yeah that should be straight forward
11:27:46 <MeepyTheParrot> Dear Haskell chat, how do I "chomp" a newline off a string, preferably a String -> String function
11:27:56 <evancz> would you guys consider using something like this?
11:28:15 <evancz> I think it'll be easier to find someone to take up this project if they have known users besides Elm :)
11:28:23 <ibotty> MeepyTheParrot: what does chomp off mean? remove?
11:28:27 <bergmark> evancz: just a pretty printer you mean?
11:28:29 <donri> napping: seems in 1.18 you can put haddock-options: in cabal/config
11:28:30 <evancz> yeah
11:28:41 <monochrom> MeepyTheParrot: I have a better idea. consider the function called "lines". here is an example:
11:28:42 <MeepyTheParrot> yeah, "Hi\n" to "Hi"
11:28:58 <monochrom> > lines "hello\nkitty\n\nhey\n\n"
11:28:59 <lambdabot>   ["hello","kitty","","hey",""]
11:29:33 <evancz> by the way, thanks to monochrom for helping with the parsec issue :)
11:29:45 <monochrom> you're welcome
11:30:04 <bergmark> evancz: sure, but wouldn't it be better to add a better pretty printer to language-ecmascript then?
11:30:13 <evancz> monochrom: I'm working on a documentation tool and want to capture the source representation as well as the structured data
11:30:22 <applicative> napping: oh i do see a 'haddock-options' field in the cabal-1.18 default conf file
11:30:32 <evancz> bergmark: yeah, updating their pretty printer is one way
11:30:34 <MeepyTheParrot> My issue is that I get a line of text using getLine, but when I putStrLn("you said" ++ line) it puts the line on a newline, it's frustrating
11:30:47 <applicative> oh donri has said this
11:30:52 <monochrom> then consider putStr
11:30:54 <donri> MeepyTheParrot: so use putStr?
11:31:04 <MeepyTheParrot> I'm not sure if that's the issue but i'll check
11:31:20 <ibotty> well, you'll get one \n less :)
11:31:22 <monochrom> actually, getLine already takes away the \n
11:31:35 <napping> applicative: I guess I'll just wait for that and pass it explicitly for now.
11:32:10 <applicative> napping: or just install it ;)  I don't seem to have suffered for my impatience
11:32:50 <monochrom> this is why there is no "chomp" in common Haskell libraries. getLine and lines already cut the \n, who needs chomp?
11:33:03 <napping> Hmm, I guess I do have Cabal-1.17.0 which is already not on hackage
11:33:06 <evancz> bergmark: I'll email the language-ecmascript folks and see what they think of this kind of thing. Thanks for talking thtrough this with me :)
11:33:23 <applicative> napping: tibbe sez plz try cabal install http://johantibell.com/files/Cabal-1.18.0-rc2.tar.gz http://johantibell.com/files/cabal-install-1.18.0-rc2.tar.gz
11:33:31 <bergmark> evancz: cool! let me know how it goes
11:34:01 <MeepyTheParrot> silly me, I have made a very silly mistake, it works now ^_^ thanks
11:34:12 <cschneid> :t ^_^
11:34:13 <lambdabot> parse error on input `^'
11:34:22 <cschneid> hmm, what's the rule on what can be an operator?
11:34:24 <applicative> napping then you can be the first on your block to use cabal sandbox and cabal repl
11:34:48 <cschneid> :t (^_^)
11:34:49 <lambdabot> parse error on input `)'
11:34:57 <MeepyTheParrot> I did putStr ("you have entered" ++ line) then right after it putStrLn(line), then was curious why it said "You have entered $line$line" >.>
11:35:10 <napping> applicative: why is that not tagged in git?
11:35:57 <applicative> napping: yeah i don't know; i had installed it from the repo on git hub a month or two ago; then a few days ago just used that command
11:36:58 <pavonia> cschneid: I think you can only use characters c such that isSymbol c == True
11:37:34 <applicative> napping: i used to find it alarming to install a version of Cabal that didn't come with my ghc but duncan c convinced me this was nonsense.
11:37:36 <cschneid> pavonia: turns out I should just google things: http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
11:38:06 <MeepyTheParrot> Is there any up to date tutorials on setting up OpenGL binding for haskell?
11:38:29 <MeepyTheParrot> I never learnt to use Cabal and the one time I tried it failed horribly
11:38:38 <monochrom> cschneid: in ^_^, the _ is disqualified. cf "get_input"
11:38:54 <tibbe> applicative: making the cabal release now
11:39:04 <cschneid> so underscores break up names in haskell?
11:39:17 <cschneid> I've been using camel case for my code, but I use  foo_bar_baz style in ruby
11:39:21 <cschneid> that doesn't work apparently?
11:39:22 <pavonia> No, but operators
11:39:26 <applicative> tibbe oh; maybe you should wait patiently after all napping
11:39:31 <napping> tibbe: I see the cabal-1.18.0 branch in git is behind even the point where you actually change the version number in Cabal.cabal to 1.18.0
11:39:35 <cschneid> ahh, but on operators it does. Because it's not part of the list
11:39:48 <joelteon> man I wish I could use hdevtools
11:39:49 <joelteon> :(
11:40:26 <applicative> MeepyTheParrot: you mean you haven't been able to use the cabal-install executable?
11:40:55 <applicative> MeepyTheParrot: oh you mean with opengl
11:41:09 <monochrom> cschneid: ^_^ has the same status as, say, ^a^. therefore, "break up" happens because, say, a^b^c is 5 tokens
11:41:13 <MeepyTheParrot> yeah I want to set up opengl, I got no idea where to start :(
11:41:20 <MeepyTheParrot> also i have no idea how to send messages directly, im an irc noob
11:41:23 <applicative> MeepyTheParrot: it comes with the haskell platform
11:41:27 <MeepyTheParrot> I know
11:41:29 <cschneid> monochrom: sure. makes sense.  *.* is valid though, since . is valid as an operator symbol.
11:41:33 <MeepyTheParrot> I tried using it to get gtk, but that failed horribly
11:41:37 <cschneid> was just trying to make smilies, not gonna lie
11:41:52 <MeepyTheParrot> Idk how to use it properly
11:42:04 <applicative> MeepyTheParrot: yes these things can be a pain in the neck, what platform are you on?
11:42:11 <MeepyTheParrot> Windows 7
11:42:12 <monochrom> I do regret that ^_^ is not one single operator. it's so cute. :)
11:42:32 <joelteon> ^=^
11:42:36 <cschneid> ಠ_ಠ doesn't work either
11:42:40 <monochrom> hey, that works
11:42:47 <applicative> MeepyTheParrot: oh indeed that might make gtk a pretty advanced installation
11:43:04 <MeepyTheParrot> Indeed
11:43:16 <JordiGH> What's so "1 (one)" about monads? Why the name?
11:43:29 <MeepyTheParrot> But how do I set up OpenGL? I really wanna start doing some experiments
11:43:44 <monochrom> perhaps the "mon" part does not refer to "one"
11:44:01 <MeepyTheParrot> I mean, i'd be happy with any graphic library for haskell
11:44:08 <JordiGH> Is the term just borrowed from philosophy?
11:44:13 <JordiGH> Leibniz's monads?
11:44:18 <monochrom> no, neither
11:44:19 <JordiGH> Because they are so GODLY?
11:44:20 <MeepyTheParrot> I want to learn to use Cabal :(
11:45:02 <JordiGH> Saunders Mac Lane adopted the philosophical term "monad" (a single entity that generates all other entities) for this construct, noting the construct's ability to generate a corresponding category.[
11:45:03 <monochrom> it may be more related to the "mon" in "monoid"
11:45:04 <JordiGH> Ah.
11:45:18 <JordiGH> monochrom: The "mon" in "monoid" is indeed about oneness... a single operation.
11:45:22 <applicative> MeepyTheParrot: what happens if you do e.g. cabal install gloss
11:45:33 <monochrom> well then, darn MacLane
11:45:55 <applicative> Mac Lane
11:45:56 <MeepyTheParrot> hmm second
11:46:16 <napping> also a monad is a monoid in a category of endofuntors
11:46:21 <JordiGH> Too bad he died before he could write Categories for the Working Haskellorian.
11:46:58 <MeepyTheParrot> Okay, to be honest I have not used cabal in a  year and I cannot find it on my computer anymore
11:47:05 <MeepyTheParrot> how do I get it again >.>
11:47:15 <Ralith> napping: clearly it should've been named a monend.
11:47:37 <applicative> monad is in Euclid's greek isnt it? it just means unit
11:47:52 <applicative> even in modern greek it seems http://translate.google.com/#auto/en/%CE%BC%CE%BF%CE%BD%CE%B1%CE%B4
11:48:20 <napping> Ralith: is that properly related to ends/coends?
11:48:24 * monochrom has a cunning plan!
11:48:35 <napping> I haven't learned that much of the math
11:48:51 <Ralith> napping: I haven't the slightest.
11:48:53 <monochrom> people have complained about the name "return". I now know the perfect solution
11:49:08 <monochrom> class Monad m where { monad :: a -> m a; ... }  :)
11:49:11 <joelteon> man, pragma comments have be the MOST annoying thing to type
11:49:20 <napping> just pointing out that the similarity to some other mathematical terms is unsurprising (even if Leibniz may have something to do with the exact word)
11:49:22 <joelteon> any tips for that, anyone?
11:49:26 <evancz> monochrom: holy crap
11:49:35 <evancz> that's actually way better :)
11:49:50 <monochrom> see? it's a cunning plan! :)
11:50:03 <aristid> monochrom: how would you rename pure?
11:50:07 <Hafydd> What's wrong with mpure?
11:50:28 <monochrom> pure doesn't need renaming
11:50:35 <evancz> Hafydd: then you have to learn what a monad is and what an mpure is
11:50:38 <shachaf> monochrom: class Functor m => Monad m where { monad :: Free m a -> m a }
11:50:38 <MeepyTheParrot> oh, okay Cabal works on cmd but not on my msys, odd
11:50:39 <aristid> monochrom: why not rename return pure then? :P
11:50:41 <applicative> what, monochrom you can introduce the much unloved Pointed calling it Monad, with just one method
11:50:58 <Hafydd> evancz: you have to learn what a Monad is to use Monads, anyway.
11:50:59 <applicative> class Monad f where monad :: a -> f a
11:51:13 <MeepyTheParrot> it says gloss is already installed
11:51:17 <Hafydd> (in particular, to use a function called "monad").
11:51:19 <applicative> like you need to know what a group is in order to turn around
11:51:29 <evancz> lol
11:51:46 <monochrom> "to understand Monad, first you have to understand monad"
11:51:51 <evancz> lol
11:52:09 <evancz> oh man, that is awesome :)
11:52:42 <Hafydd> Just have return :: a -> IO a.
11:53:21 <Hafydd> Or class MonadReturn m where return = mpure
11:53:25 <evancz> Hafydd: it's no problem once you "know what return does" but coming from imperative world, it just looks like a "return" that does the wrong thing
11:53:36 <evancz> sorry, I jumped in late
11:53:40 <evancz> I'll recuse myself :)
11:53:49 <evancz> carry on everyone :)
11:54:08 <MeepyTheParrot> is there a gloss reference for haskell?
11:54:41 <applicative> MeepyTheParrot: yes, cabal unpack gloss-examples
11:54:46 <applicative> then you study the files
11:59:16 <MeepyTheParrot> i ran caball unpack gloss-examples, but it still has gloss-examples packed >.>
11:59:27 <MeepyTheParrot> it just creates a new folder with a new packed gloss-examples.cabal
11:59:32 <MeepyTheParrot> how do i "unzip" it
12:01:17 <applicative> you cant enter the folder it has subdirs for picture and raster
12:02:41 <applicative> hm.  MeepyTheParrot what happens if you just click the link for the source at the bottom of http://hackage.haskell.org/package/gloss-examples
12:02:55 <MeepyTheParrot> same thing
12:03:09 <MeepyTheParrot> i get the .cabal file
12:03:24 <MeepyTheParrot> i dont see any examples
12:04:03 <MeepyTheParrot> or are the examples in raster/picture >.>
12:04:06 <applicative> grrrr. this seems like a bug for someone. I cant believe windows cant open a tar.gz
12:04:10 <applicative> MeepyTheParrot: yes!
12:04:35 <MeepyTheParrot> it cant find module Graphics.Gloss.Raster.Field
12:04:36 <MeepyTheParrot> >.>
12:04:41 <monochrom> cabal-install contains code for tar and gz already IIRC
12:04:52 <applicative> yes, but we wanted the code monochrom
12:04:56 <applicative> but we have it
12:05:05 <MeepyTheParrot> the picture works though
12:05:27 <applicative> MeepyTheParrot: start small, enter picture/Hello and do ghc -O2 Hello.hs
12:05:50 <applicative> Main.hs rather
12:06:11 <applicative> then open Main.exe
12:06:44 <MeepyTheParrot> hello works, yay ^_^
12:07:27 <applicative> then do the same for pictures/Stryene/Main.hs which is more amusing
12:07:36 <ReinH_> well that was weird
12:07:47 <Zenol> er. Is it bad to write a lends that don't respect the law (actualy, reading or writing will change the value at next use)
12:07:50 <Zenol> ?
12:08:03 <applicative> actually I'm not seeing how Styrene rotates' with right click but never mind.
12:08:16 <monochrom> > let (^∞^) = && in True ^∞^ False
12:08:18 <lambdabot>   <hint>:1:13: parse error on input `&&'
12:08:22 <applicative> Zenol: as longs as it follows the lends laws
12:08:25 <monochrom> > let (^∞^) = (&&) in True ^∞^ False
12:08:26 <lambdabot>   False
12:08:36 <monochrom> ^∞^
12:09:19 <ReinH> aand we're back
12:09:27 <stelleg> how would you guys recommend communicating between a parent and child process?
12:09:37 <ReinH> monochrom: what is this infinity operator?
12:09:52 <monochrom> it's a pig's nose :)
12:09:56 <ReinH> I see.
12:10:05 <Zenol> I means, lens law. i.e. view view isn't view.
12:10:15 <ReinH> monochrom: I am messing with tropical semirings so infinity operators interest me :)
12:10:19 <monochrom> or a teddy bear's nose. or any cute animal's nose :)
12:10:27 <monochrom> ones
12:10:31 <monochrom> err, onoes
12:10:39 <ReinH> nah it's good :)
12:10:59 <applicative> MeepyTheParrot: ooo 'Machina' is pretty cosmic, why not start from that, varying things in the file
12:11:15 <MeepyTheParrot> :)
12:11:44 <MeepyTheParrot> it works too, ill play around with it :)
12:11:47 <applicative> ... and the pigs eyes are booleans, monochrom ?
12:11:53 <MeepyTheParrot> thanks so much
12:12:13 <ReinH> monochrom: borrowed from some old edwardk code https://gist.github.com/reinh/f13580cff706fb30c86d
12:12:29 <monochrom> stelleg: I recommend any of the standard mechanisms (pipes, sockets, shared memory, there are others) depending on the problem. "the solution depends on the problem"
12:13:02 <ReinH> I avoided the pointed version because I don't understand pointed
12:13:10 <monochrom> the ^ is an eye, closed to just a line due to smiling
12:13:22 <napping> Is there some way to write a type class instance that only applies to free type variables?
12:13:31 <napping> I think Oleg did that somehow
12:14:08 <stelleg> monochrom: Thanks. Are there any straightforward ways to use MVars or TVars with shared memory?
12:14:15 <monochrom> no
12:14:22 <applicative> MeepyTheParrot: that uses the 'animate' function, something like the Visibility example uses the simple game interface so there can be input
12:14:23 <stelleg> thought so
12:14:36 <stelleg> thanks
12:16:02 <ReinH> stelleg: you should read this http://chimera.labs.oreilly.com/books/1230000000929
12:16:04 <applicative> MeepyTheParrot: oh it occurs to me that nand / haasn's Pong.hs is an excellent gloss and lens tutorial at the same time https://github.com/ekmett/lens/blob/master/examples/Pong.hs
12:16:06 <ReinH> it's free
12:16:31 <MeepyTheParrot> bookmarked
12:16:55 <MeepyTheParrot> thisll give me plenty to look through for now
12:16:57 <MeepyTheParrot> thanks a lot ^_^
12:17:20 <stelleg> ReinH: thanks, I had seen this before but forgotten about it
12:18:35 <Eduard_Munteanu> Hrm, Template Haskell should really use more specific types, even if just wrappers.
12:18:47 <Eduard_Munteanu> "Name" doesn't say much.
12:19:12 <stelleg> ReinH: nice, looks like Control distributed process should a nice easy way to do what I want to do, thanks
12:20:20 <ReinH> stelleg: :) np
12:20:38 <applicative> oh ok  the pigs ears are booleans then monochrom
12:21:12 <applicative> according as what the pigs friends are telling him or her
12:27:52 * hackagebot hexpat-lens 0.0.1 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.0.1 (JosephAbrahamson)
12:27:54 * hackagebot HaRe 0.7.0.0 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.0 (AlanZimmerman)
12:27:56 * hackagebot aeson 0.6.2.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.6.2.0 (BryanOSullivan)
12:39:46 <tel> New Aeson! :D
12:40:05 <donri> new HaRe!
12:40:48 <napping> tibbe: should the new Cabal be on hackage yet?
12:42:08 <tel> I've been excited to see the new aeson TH functions for a long time. This will probably eliminate 1/3rd of my ToJSON/FromJSON instances
12:43:27 <Eduard_Munteanu> How does the indexed store comonad relate the two index types? I guess it just threads input and output indices in (=>>), but which index should be to the left of the ->?
12:43:32 <ifthenelse> Can this channel serve as a help service?
12:44:01 <Eduard_Munteanu> ifthenelse: if you can ask a direct question, yes. :)
12:44:06 <ifthenelse> Yay!
12:44:10 <ifthenelse> I have a question:
12:45:11 <ifthenelse> For command line arguments, why do I run into parsing issues when I try
12:45:17 <ifthenelse> main = do
12:45:30 <ifthenelse>     (test1:test2:test3) <- getArgs
12:45:57 <Eduard_Munteanu> ifthenelse: what issues?
12:45:59 <ifthenelse> if I have 3 arguments, let's say, so I would have the command be "./test alf1 alf2 alf3
12:46:06 <ifthenelse> That wouldn't work
12:46:27 <monochrom> test1 = "alf1", test2 = "alf2", test3 = ["alf3"] not "alf3"
12:46:36 <ifthenelse> I have to have "(test1:test2:test3:[]) <- getArgs" for everything to work
12:46:38 <Eduard_Munteanu> ifthenelse: given (a:b:c), a, b :: Something, c :: [Something]
12:46:49 <ifthenelse> yeah, but why
12:46:54 <monochrom> more generally, "./test a b c d e" -> test3 = ["c", "d", "e"]
12:46:57 <donri> [test1,test2,test3] <-
12:47:05 <monochrom> it is how ":" is defined.
12:47:05 <ifthenelse> oh
12:47:07 <ifthenelse> I see
12:47:09 <ifthenelse> it's a list
12:47:16 <ifthenelse> well now I feel dumb
12:47:19 <Eduard_Munteanu> ifthenelse: that's how lists are defined: a list has a head and a tail
12:47:44 <ifthenelse> yeah, it didn't click that the getArgs was bound to a list
12:47:56 <ifthenelse> I for some reason thought it was syntatical sugar
12:48:05 <ifthenelse> OK NEW QUESTION
12:48:14 <ifthenelse> so I want to convert all of that to cmdArgs
12:48:19 <monochrom> [x,y,z] is the syntax sugar. x:y:z:[] is the real thing
12:48:56 <ifthenelse> but I get the error "unhandled argument, none expected: True"
12:49:37 <Eduard_Munteanu> That sounds like an error message *you* wrote.
12:49:45 <ifthenelse> I didn't
12:49:47 <donri> ifthenelse: i recommend optparse-applicative, although you might like simpleargs which basically makes your previous getArgs code with minor modification do the right thing with error messages
12:49:52 <ifthenelse> I'm assuming it's from cmdArgs
12:50:25 <ifthenelse> Yeah, I was also confused as to which command line parser to use
12:50:31 <ifthenelse> because there are like 20
12:51:01 <ifthenelse> I decided to use cmdArgs because it seems like everyone else is
12:51:22 <Zenol> How to convert Word16 -> Word8 (something like "truncate").
12:51:39 <Eduard_Munteanu> Zenol: fromIntegral?
12:51:48 <donri> :t fromIntegral :: Word16 -> Word8
12:51:49 <lambdabot> Word16 -> Word8
12:51:57 <Zenol> oh, ok.
12:52:18 <donri> > (fromIntegral :: Word16 -> Word8) maxBound
12:52:18 <Eduard_Munteanu> There is a specific Prim thing that truncates like that but normally you shouldn't need that.
12:52:19 <lambdabot>   255
12:53:25 <Zenol> ok, thanks. With shift it should does what I want :)
12:53:35 <donri> ifthenelse: i like optparse-applicative because it works like normal parser combinator libraries like parsec, but for options, and you get bash completions
12:53:58 <ifthenelse> I see
12:54:08 <donri> ifthenelse: cmdargs seems overly magical and complex for no good reason AFAICT
12:55:00 <ifthenelse> All of my coding use to ignore all of command line parsing--I just did the arguments in the order they should be (as I never needed any complex parsers). As my programs grew, however, so did the arguments, so I am new to the whole parser thing.
12:55:12 <ifthenelse> I just never needed it for so long
12:55:37 <ifthenelse> I just got into it using the python parser, which is fantastic, so I wanted a similar type of thing for Haskell
12:56:05 <ifthenelse> "argparse"
12:56:24 <ifthenelse> So you are saying that optparse-applicative is what I should go with?
12:56:36 <donri> argparse's got nothing on a nice Alternative parser combinator library ;)
12:56:42 <ifthenelse> haha
12:57:46 <ifthenelse> I'm in that weird phase of Haskell where I (think) I understand applicatives and monads--I just don't know where to use them in my own programs!
12:58:04 <ifthenelse> Having that in the parser should help the entry and break the ice, I suppose
12:58:37 <monochrom> optparse-applicative can be your first Applicative exposure. also it is just Applicative, no Monad.
12:59:08 <ifthenelse> I really want to get this right, though...is this library well known and well used?
12:59:14 <monochrom> yes
12:59:16 <ifthenelse> Like, is it one of the standards?
12:59:28 <donri> no, the standard one is getopt in base and it kinda sucks
12:59:39 <ifthenelse> Yeah I'm avoiding that haha
12:59:40 <monochrom> what is "standard"?
12:59:44 <cschneid> reading over optparse-applicative, that's awesome.
12:59:46 <donri> cmdargs seems popular mostly because it's older than optparse-applicative
13:00:01 <donri> ifthenelse: let's say it this way. *applicative* is the standard for parsing.
13:00:01 <monochrom> isn't "well-known and well-used" enough?
13:00:16 <applicative> optparse applicative is widely used http://packdeps.haskellers.com/reverse/optparse-applicative
13:00:38 <monochrom> the Haskell community does not work like the Python community.
13:00:50 <donri> ifthenelse: and AFAIK optparse-applicative is the only one that's actually an applicative
13:01:09 <ifthenelse> ok, ok I get it! haha
13:01:13 <ifthenelse> I'll try it out
13:01:30 <applicative> a really cool example of applicative/monad interaction is the Concurrently type in the async library
13:01:54 <tippenein> Is there a reason cabal doesn't have a -s --save flag for install ? If you're in a directory which has a *.cabal file, shouldn't it just add that package to the dependency list?
13:01:58 <monochrom> the Python community has a Guido that randomly rules "don't use this, don't use that". that may be your notion of "standard". there is no such figure in the Haskell community.
13:02:14 <applicative> if you want one thing after another and so on, you use the usual monad interface; if you want things to happen 'concurrently' you wrap with Concurrently and use the applicative interface
13:02:20 <ifthenelse> Yeah, that is one of the dogmas I liked about Python
13:02:24 <donri> ifthenelse: for example, you could use these combinators http://hackage.haskell.org/packages/archive/parsers/0.9/doc/html/Text-Parser-Combinators.html even though they're not written with option parsing in mind at all
13:02:26 <ifthenelse> "There is only one way to do something"
13:03:11 <monochrom> Guido is a great way to build a community
13:03:29 <tippenein> how about DHH? >.<
13:03:34 <monochrom> but note how that sentence does not say what kind of community is being built.
13:03:37 <applicative> the method of #haskell is to pretend that haskell is different from that, but then to constitute a conformist Guido
13:03:41 <ifthenelse> I just like that it's easier to know when I'm doing the wrong thing and there is a faster way haha
13:03:52 <donri> funny thing is most of the python stdlib is crap and everyone actually uses third-party alternatives :p
13:03:55 <monochrom> a self-congratulating community is still a community
13:03:56 <shachaf> I nominate monochrom for dictator of #haskell.
13:04:16 <applicative> conformism doesnt use a dictator
13:04:21 <ifthenelse> hold on, this reminds me of one of my first "big" haskell programs
13:04:38 <monochrom> "only one way" is great for a self-congratulating, anti-intellectual community
13:04:48 <ifthenelse> Should I be writing functions or variables?
13:05:01 <applicative> ??!
13:05:02 <mauke> category error
13:05:07 <ifthenelse> By that, I mean I have a function to make matrix A into matrix B
13:05:16 <mauke> that's like saying should I be writing types or integers?
13:05:28 <ifthenelse> now in another function, I want to use both matrix A and matrix B
13:05:39 <ifthenelse> should, in the where clause, I say
13:05:44 <shachaf> mauke: An example of a category error is when (.) isn't associative?
13:06:06 <applicative> > 1 == True
13:06:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
13:06:08 <lambdabot>    arising from the literal `1...
13:06:08 <ifthenelse> where; mb = ma2mb ma
13:06:18 <applicative> is a typical category mistake
13:06:36 <mauke> > 1 == Int
13:06:37 <lambdabot>   Not in scope: data constructor `Int'
13:06:38 <lambdabot>  Perhaps you meant one of these:
13:06:38 <lambdabot>    `I...
13:06:53 <shachaf> 1 = Int
13:06:55 <ifthenelse> or should I just use the function ma2mb in point free form?
13:07:57 <FZ> is (,) a Category?
13:08:15 <tomejaguar> FZ: no
13:08:25 <donri> well sure, it's a function :p
13:08:28 <donri> :t (,)
13:08:29 <lambdabot> a -> b -> (a, b)
13:08:59 <shachaf> But it's a semigroupoid!
13:09:01 <Eduard_Munteanu> It isn't?
13:09:51 <FZ> I mean it doesn't make an interesting Category, but i think it could be made into a trivial one
13:10:19 <FZ> right?
13:10:19 <tibbe> napping: give me a minute, doing some more tests
13:11:01 <elliott> FZ: what is id?
13:11:19 <FZ> elliott: you have a point
13:11:26 <applicative_> there are two interestingly different Category instances for (,); id = (undefined,undefined) and id = undefined
13:11:53 <joelteon> id = (id, id)
13:11:53 <Eduard_Munteanu> elliott: id a = (a, a) ?
13:11:58 <elliott> Eduard_Munteanu: id :: (a,a)
13:11:59 <shachaf> Eduard_Munteanu: id :: (a,a)
13:12:02 * shachaf sighs.
13:12:18 <Eduard_Munteanu> Err, that wasn't supposed to be valid Haskell, but yeah.
13:12:21 <elliott> applicative_: violates laws as well as basic decency
13:12:32 <FZ> ok, I guess not then
13:12:38 <donri> @google rectangular band
13:12:39 <lambdabot> http://en.wikipedia.org/wiki/Band_(mathematics)
13:12:39 <lambdabot> Title: Band (mathematics) - Wikipedia, the free encyclopedia
13:12:42 <FZ> thanks though
13:12:44 <Eduard_Munteanu> Oh the original question was about Category, not category.
13:12:49 <applicative_> i was hoping only to violate basic decency, but of course went further
13:12:53 * hackagebot Cabal 1.18.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.0 (JohanTibell)
13:12:55 * hackagebot cabal-install 1.18.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0 (JohanTibell)
13:13:00 <donri> yay cabal
13:13:11 <applicative_> ooooooooooooooooooooooooooooooooooooooo
13:13:29 <donri> i'll have to lift my mighty "Cabal installed" constraint :(
13:13:53 <shachaf> So is Cabal one of the packages you're not supposed to upgrade without upgrading GHC?
13:13:57 <shachaf> I can't remember.
13:14:10 <applicative_> #haskell used to always teach that, but the answer is no
13:14:14 <donri> should be fine
13:14:43 <donri> i think it's only problematic for packages like ghc-mod that depend on both Cabal and ghc
13:14:54 <elliott> I figure one of these days we'll learn it was FUD all along and you can even upgrade base
13:15:02 <elliott> anything can happen
13:15:06 <donri> \o/
13:15:23 <elliott> shachaf: dcoutts told me you can upgrade Cabal. YMMV
13:15:34 <elliott> I made sure to ask him about five times before doing it, too.
13:16:02 <shachaf> tibbe++
13:16:09 <applicative_> yes, he decided to intervene and put an end to that particular bit of #haskell FUX
13:16:11 <applicative_> FUD
13:16:12 <applicative_> bah
13:16:12 <donri> well dcoutts and tibbe also think you can upgrade bytestring just fine but that crashes the linker and shit like that
13:16:28 <applicative_> can they have said that about bytestring
13:16:54 <applicative_> the argument about Cabal is pretty specialized
13:17:04 <tibbe> upgrading cabal should be fine
13:17:21 <tibbe> bytestring is a bit more iffy because it's shipped with ghc
13:17:30 <tibbe> and things might already be linked against that version
13:17:30 <ReinH>  /msg lambdabot @pl f x = Tropical (g !!? x)
13:17:32 <ReinH> woops
13:17:36 <applicative_> Cabal is shipped with ghc too
13:17:39 <shachaf> But Cabal is also shipped with GHC.
13:17:59 <applicative_> Cabal is not a problem because of what depends on it and how. It can in  principle be a problem.
13:18:21 <donri> all i know is i've upgraded cabal/-install numerous times without problems but never managed to do it right with bytestring :)
13:18:24 <applicative_> bytestring is totally out of the question except perhaps for mad geniuses
13:19:07 <donri> yeah, i think that's the thing (dcoutts and tibbe are mad geniuses :))
13:19:27 <applicative_> there is an element of that
13:20:27 <ifthenelse> Wait, so with optparse-applicative, the parser has to be defined in the same order as the type?
13:20:34 <applicative_> but I think dcoutts was arguing more carefully when I heard him explain it. ghc-mod is making me wonder though
13:20:50 <donri> ifthenelse: that's easiest yes, but not necessary
13:20:59 <edwardk> ReinH: playing with tropical semirings?
13:21:00 <donri> ifthenelse: you can pack things around with a tuple
13:21:37 <edwardk> ReinH: i expect if we keep talking you're going to wind up going off and getting a Ph.D in mathematics ;)
13:21:57 <applicative_> optparse-applicative is too fancy anyway; I use ReadArgs which is the blackest art on Hackage
13:22:15 <Eduard_Munteanu> So... (=>>) :: w i j a -> (w j k a -> b) -> w i k b would be my guess. Now if  data Store i o a = Store (i -> r) o  , 'o' becomes the 'i' when you cobind it around. But normally I suppose i and o aren't unrelated, or not fully polymorphic, no?
13:22:20 <ifthenelse> ...
13:22:23 <donri> applicative_: well i'm thinking of the last minute massive changes to bytestring builder that didn't seem to consider the ramifications WRT not being able to upgrade it without ghc :p
13:22:38 <ifthenelse> So now I shouldn't use it!?!?
13:22:54 <ifthenelse> It sure is wordy
13:23:04 <applicative_> donri: yes, the introduction of bytestring 0.10 was a bit of a catastrophe
13:23:26 <donri> no one is replying to my proposal on libs@ today though :(
13:23:57 <Eduard_Munteanu> Unlike the indexed state I can't really figure an application for it off the top of my head.
13:23:59 * applicative_ refuses to subscribe
13:24:25 <Eduard_Munteanu> I guess it might be useful if you want to permute your store, IOW reindex it, in a computation.
13:25:21 * applicative_ greps the libraries list once or twice a year for peyton jones, mcbride and couple other names 
13:25:47 <pxqr> why not default fromString :: Read a => String -> a; fromString = fromMaybe (error "fromString: def") . readMaybe ?
13:26:11 <donri> pxqr: because "error" :p
13:26:22 <donri> you might find that in acme-php though!
13:26:37 <pxqr> donri: yep, but that's better than nothing
13:26:48 <pxqr> donri: in ghci!
13:27:14 <donri> pxqr: actually
13:27:30 <donri> pxqr: wtf. what's even the point of read'ing a string literal
13:28:28 <pxqr> donri: that's might be convenient for UTCTime and URI for example
13:29:14 <donri> pxqr: you'd still need to make those instances, so why not just type that out then
13:29:15 <pxqr> > "file://localhost/etc" :: URI
13:29:16 <lambdabot>   Not in scope: type constructor or class `URI'
13:29:50 <pxqr> donri: yes, but this is half step to the goal!
13:30:02 <ReinH> edwardk: haha :)
13:30:16 <ReinH> edwardk: I'm implementing a "dijkstra's map" algorithm
13:30:22 <ReinH> and tropical semirings are perfect
13:30:26 <pxqr> we could make instance Read a => IsString a ... also
13:30:45 <donri> pxqr: that would block all other instances
13:30:49 <pxqr> but with overlapping hell
13:31:01 <donri> pxqr: and would mean you have to type "\"foo\"" for actual String!
13:31:34 <donri> pxqr: i suggest you make quasi-quoters for these things instead :)
13:31:51 <donri> [url|file://localhost/etc|]
13:33:11 <pxqr> donri: compile-time errors as a bonus
13:33:19 <donri> quite
13:33:23 <Eduard_Munteanu> Huh... I'm not sure I can even define a Copointed instance for 'Store i o'.
13:33:26 <donri> and better type inference
13:34:09 <Eduard_Munteanu> Wait, that's the point. (no pun intended)
13:34:11 <pxqr> donri: this seems not a bad idea; i wonder if there is a package
13:35:38 <pxqr> does any details about new TH available right now?
13:35:39 <Eduard_Munteanu> I guess I want  instance Copointed (Store i i) => Comonad (Store i o).
13:50:08 <Zenol> (Functor f, HasRegisters t) => (Word8 -> f Word8) -> t -> f t has an alias?
13:51:03 <ifthenelse> So I'm almost finished the first draft with optparse-applicative
13:51:11 <supki> HasRegisters t => Lens' t Word8
13:51:12 <supki> ?
13:51:21 <ifthenelse> I have an error on "optional $ strOption":
13:51:29 <joelteon> > fix (join . (`ap` flip lookup [(1,id)]) . (fromMaybe .) . flip ((.) . (*)) . (. pred)) 10
13:51:30 <lambdabot>   3628800
13:51:50 <ifthenelse> "Couldn't match expected type "parser String" with actual type "f0 a0 -> f0 (Maybe a0)""
13:52:55 <Zenol> supki: Don't know, I had a strange error with Lens' Registers Word8. Let's try with HasRegisters.
13:53:52 <Zenol> illegal polymorphic or qualified type...
13:53:57 <joelteon> @let factorial = fix(join<$>(<*>(`lookup`[(1,id)]))<$>(fromMaybe<$>)<$>flip((<$>)<$>(*))<$>(<$>pred))
13:53:58 <lambdabot>  Defined.
13:54:00 <joelteon> > factorial 10
13:54:06 <lambdabot>   3628800
13:55:17 <Cale> ifthenelse: That sounds like you forgot an argument to a function, or have an extra one.
13:55:36 <Taneb> joelteon, if you think that's obfuscated, my factorial function was 7 lines long with a fair few unsafeCoerces, crashed on numbers bigger than 12, and got onto Uncyclopedia for about 10 minutes
13:55:57 <hpaste> Zenol pasted “What does it means ?” at http://lpaste.net/92575
13:56:32 <Zenol> Here is the error I get if I try to write the type signature.
13:56:43 <edwardk> Zenol: f t ->  (Functor f, HasRegisters t) => (Word8 -> f Word8) -> t -> f t    doesn't make much sense
13:56:48 <Cale> Zenol: you have a class context halfway through that type
13:56:53 <joelteon> Taneb: I wanna see it
13:57:00 <edwardk> what is lRR supposed to be?
13:57:09 <Cale> Zenol: Is there any reason you decided to repeat the class context?
13:57:33 <Taneb> joelteon, the only place where I know it's online is on http://uncyclopedia.wikia.com/wiki/Talk:Haskell
13:57:45 <edwardk> Zenol: is this supposed to be a function taking two lenses and giving you a lens or something?
13:58:04 <edwardk> Zenol: sadly what you want there won't work
13:58:22 <Zenol> edwardk: Yes, exactly.
13:58:24 <edwardk> because if you passed it the same lens twice you'd get an illegal lens
13:58:33 <edwardk> Zenol: consider lRR a a
13:58:36 <ifthenelse> I wrote (semi-colon is newline): "options = Options; <$> switch ( .. ); <*> optional $ strOption (..); <*> optional $ strOption (..); <*> strOption (..); <*> strOption (..)"
13:58:49 <joelteon> what the hell
13:58:52 <joelteon> Taneb: admirable
13:59:20 <Taneb> joelteon, bonus points if you can figure out how it works
13:59:33 <Zenol> edwardk: Are they a way to say "two different lenses" ?
13:59:42 <monochrom> ifthenelse: very likely $ is getting in the way. don't use $
13:59:53 <edwardk> Zenol: now we can hand roll these individually, we can also write a one-off version, or even just take a them parametrically, since you have a limited usecase and then deal with the fact that they are illegal by just 'not doing that'
14:00:07 <joelteon> unsafeCoerce unsafeCoerce
14:01:00 <clahey> Has anyone made teams for the ICFP contest?
14:01:02 <Taneb> joelteon, there are 12 unsafeCoerces in the program
14:01:06 <joelteon> neat
14:01:14 <joelteon> and it breaks my vim
14:01:16 <Taneb> I could probably get rid of them all with some newtype-hackery
14:01:21 <clahey> In particular anyone in the Boston area interested in forming a team?
14:01:29 <Taneb> joelteon, try it with a smaller number, like 6
14:01:43 <Zenol> edwardk: It would have been cool to allow creating a 16bits register from two 8bits registers :(
14:01:44 <edwardk> Zenol: in practice i'd probably write this: wide :: Lens' r Word8 -> Lens' r Word8 -> Lens' r Word16; wide h l f reg =  (writeRR h l reg) <$> f (readRR h l reg)
14:01:57 <joelteon> no, it breaks my vim because I use vim2hs
14:01:59 <edwardk> Zenol: you can _do_ it, like i showed there
14:02:02 <joelteon> which freaks on long lines
14:02:05 <elliott> edwardk: taking Lens' :(
14:02:08 <tomejaguar> clahey: ICFP contest is over
14:02:27 <tomejaguar> for this year at least
14:02:28 <edwardk> Zenol: but its generally considered bad form, since we're passing higher rank arguments
14:02:29 <clahey> tomejaguar, Oh, I thought it said September, not August.  Damn.
14:02:38 <clahey> tomejaguar, I thought it was closer to the conference.
14:02:38 <edwardk> Zenol: this means that it doesn't generalize to traversals, etc.
14:02:50 <joelteon> Taneb: oh, but it won't parse
14:03:02 <edwardk> clahey: nope. it snuck up and passed
14:04:14 <Taneb> joelteon, I have a local copy on my other computer, let me see...
14:04:22 <ifthenelse> OK, it has to do with "optional $"--so how can I declare some (not all) optional arguments in a Parser in optparse-applicative?
14:04:46 <Zenol> edwardk: I have still the Illegal polymorphic or qualified type: Lens' Registers Word8 error. By bad rank you means I should use -XRankNTypes? Also, I didn't played with traversable. I'm still learning how to use Getting / ASetter and Lens.
14:05:01 <Zenol> *still have
14:05:11 <clahey> edwardk, Grr.  Argh.
14:05:21 <tomejaguar> ifthenelse: do you just want "optional (strOption (..))"?
14:05:22 <Zenol> (Or Lens' r Word8 if I replace Registers by a type variable r)
14:05:29 <edwardk> you need RankNTypes to write that signature, yes
14:05:40 <shachaf> By "bad form" he probably means that you *shouldn't* use RankNTypes there (although you can).
14:05:43 <ReinH> edwardk: I am an idiot. I can't write a monad instance for a newtype wrapper around Maybe :/
14:05:54 <ifthenelse> tomejaguar: would that work for just one argument? I tried that and I still got an error
14:06:11 <Zenol> edwardk: Er, ok. Why? Because Lens' is hiding a nested "forall f." etc?
14:06:12 <edwardk> there is a version of this that doesn't need rank n types
14:06:16 <edwardk> yep
14:06:22 <edwardk> we can modify your original definition a bit
14:06:36 <ifthenelse> tomejaguar "expected type String with actual type Maybe a0
14:06:56 <edwardk> wide :: ALens' r Word8 -> ALens' r Word8 -> Lens' r Word16; wide h l f reg =  (writeRR (cloneLens h) (cloneLens l) reg) <$> f (readRR (cloneLens h) (cloneLens l) reg)
14:07:02 <ifthenelse> I thought Parser could support that
14:07:04 <edwardk> now it is no longer rank-n
14:07:11 <ifthenelse> but it seems like it wants a string
14:07:24 <Taneb> joelteon, I'm sorry but I think I deleted my local copy
14:07:24 <ifthenelse> oh...I define a maybe instead of a string?
14:07:26 <edwardk> well, it may be on old ghc's that complain about the alias for Lens being higher rank, but its 'doing the right thing' now
14:07:27 <elliott> writeRR and readRR should take ALens too.
14:07:31 <Taneb> And I can't be bothered to debug it
14:07:33 <elliott> then you wouldn't need the clone
14:07:42 <joelteon> rats
14:07:42 <edwardk> elliott: sure, but i was just limiting impact =)
14:07:45 <joelteon> ok well I'll take your word for it
14:08:00 * Zenol go browsing the documentation to understand ALens'
14:08:14 <edwardk> Zenol: the idea is this. we make lenses go by varying the choice of 'f' right?
14:08:32 <edwardk> ALens picks an 'f' that contains all the information necessary to make a new lens up
14:08:50 <edwardk> cloneLens lets you reconstitute that information into a new lens that lets you pick other f's
14:08:52 <Taneb> joelteon, aaah it was on this computer all along!
14:08:54 <edwardk> :t cloneLens
14:08:55 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
14:09:02 <haasn> @quote unabstracted
14:09:02 <lambdabot> No quotes match.
14:09:06 <edwardk> cloneLens :: ALens s t a b -> Lens s t a b
14:09:09 <Taneb> But... parse error
14:09:12 <joelteon> Yep
14:09:16 <joelteon> main.hs:2:1
14:09:23 <Taneb> I guess I can rewrite it!
14:09:28 <shachaf> This is way smoother with pure profunctor lenses.
14:09:29 <edwardk> the problem is both readRR and writeRR wanted to make different choices for 'f'
14:09:33 <edwardk> shachaf: sure
14:09:38 <shachaf> The choice of p is always obvious.
14:09:48 <shachaf> (Well, OK, that's not *strictly* true.)
14:10:08 <edwardk> the choice of 'f' here is also pretty obvious
14:10:33 <Zenol> edwardk: So, what will be the f choosen by ALens?
14:10:51 <edwardk> ALens uses Pretext IIRC
14:11:01 <edwardk> :info Control.Lens.Info.Pretext
14:11:07 <edwardk> :info Control.Lens.Internal.Pretext
14:11:09 <shachaf> edwardk: In the case of profunctor lenses p is just a lens.
14:11:09 <edwardk> :info Control.Lens.Internal.Context
14:11:18 <edwardk> :t Control.Lens.Internal.Context
14:11:19 <lambdabot> (b -> t) -> a -> Context a b t
14:11:19 <edwardk> derp
14:11:20 <shachaf> (With the natural order of arguments.)
14:11:28 <shachaf> I.e. p a b s t = s -> (a, b -> t)
14:11:33 <edwardk> :t Control.Lens.Internal.Context.Pretext
14:11:33 <lambdabot> (forall (f :: * -> *). Functor f => p a (f b) -> f t) -> Control.Lens.Internal.Context.Pretext p a b t
14:11:35 <shachaf> Similarly for prisms and whatever else.
14:11:46 <Zenol> elliott: Whats wrong with using Getting / Setter for writeRR / readRR? Isn't it beter to allow only "reading" for readRR?
14:12:02 <elliott> well, all I know is edwardk's code had some cloneLenses where they shouldn't rightfully be
14:12:17 <clahey> I didn't realize the ICFP was going to be so expensive to attend.  Is it worth it?
14:12:18 <ReinH> edwardk: why am I struggling to write instance Monad Tropical for newtype Tropical a :: { getTropical :: Maybe a } ?
14:12:24 <edwardk> Zenol: nothing is wrong with that. the issue is that Getting and Setter are different types that don't unify
14:12:34 <edwardk> ReinH: deriving Monad
14:12:47 <edwardk> use generalized newtype deriving
14:12:49 <shachaf> ReinH: Because that definition is a syntax error. :-)
14:13:00 <ReinH> shachaf: s/::/= where appropriat e:p
14:13:07 <shachaf> Still an error, but eh.
14:13:13 <shachaf> You can use GeneralizedNewtypeDeriving, but you should also figure out how to do it yourself if it's not obvious.
14:13:19 <shachaf> It's a good exercise.
14:13:58 <ReinH> shachaf: I want to.
14:14:16 <joelteon> tropical?
14:14:16 <ReinH> shachaf: I'm getting hung up on wrapping and unwrapping the newtype :/
14:14:25 <ReinH> joelteon: sweltering.
14:14:42 <elliott> try hole-driven development.
14:14:45 <elliott> it's good for this and also all other tasks.
14:14:53 <elliott> it will make every move obvious
14:14:56 <shachaf> It's not good for all tasks.
14:14:57 <ReinH> elliott: how can I learn how to do that?
14:14:59 <shachaf> Only the ones elliott cares about.
14:15:16 <shachaf> (But it's good.)
14:15:17 <elliott> ReinH: turn on ImplicitParams. when you write a definition, fill in ?x instead of any code, and observe the type error
14:15:25 <elliott> if you think you need to use some of your arguments, write them after ?x
14:15:28 <ReinH> elliott: oh that's a thing
14:15:33 <ReinH> neat
14:15:37 <joelteon> or, use GHC HEAD and TypeHoles!
14:15:39 <elliott> then fill in the obvious next move, e.g. a case on a variable, and put ?x in one branch and undefined in the other
14:15:44 <ifthenelse> IT WORKED! Thank you everyone for your help with optparse-applicative!
14:15:46 <elliott> or ?x and ?y in both branches, if you're feeling adventurous
14:15:52 <elliott> joelteon: yes, if you want worse messages
14:15:58 <joelteon> I do
14:15:59 <ReinH> elliott: :D I did not know that this was a thing. Thanks!
14:16:02 * shachaf remembers spending a while convincing elliott to use ?x instead of ().
14:16:12 <ReinH> :D
14:16:24 <elliott> () is good too!
14:16:26 <shachaf> (Not that it matters much here.)
14:16:29 <elliott> when you don't want to trek all the way to the top of the file
14:16:40 <quchen> What's the difference between () and ?x here?
14:16:45 <quchen> (Or anywhere for that matter)
14:17:08 <Zenol> actualy wide :: ALens' r Word8 -> ALens' r Word8 -> Lens' r Word16; is still more than rank1, it seams.
14:17:21 <shachaf> Zenol: It is not.
14:17:28 <napping> elliott: what's the advantage of an implicit param over ()?
14:17:36 <elliott> I forget, but shachaf doesn't.
14:17:38 <edwardk> Zenol: "[17:07] edwardk:	 well, it may be on old ghc's that complain about the alias for Lens being higher rank, but its 'doing the right thing' now
14:17:38 <edwardk> "
14:17:38 <Zenol> shachaf: Illegal polymorphic or qualified type: Lens' Registers Word16
14:17:52 <elliott> a little-known fact is that shachaf never forgets anything, eer.
14:17:53 <elliott> v
14:18:04 <Zenol> Isn't it the last Lens' at the end of the type?
14:18:12 <edwardk> yes
14:18:23 <edwardk> which is rank-1 once ghc rips open the alias
14:18:25 <shachaf> Zenol: GHC wants you to turn on RankNTypes.
14:18:35 <edwardk> but until it does, it looks like its scary to ghc
14:18:35 <napping> I thought you were talking about an actual holes extension which would presumably tell you something about the local scope, but I'd expect applying arguments to work just about the same with () or an implicit
14:18:35 <shachaf> But it's not a rank-n type (for n /= 1)
14:18:48 <Zenol> oh, ok :/
14:19:05 <edwardk> napping: thats what we're getting
14:19:20 <shachaf> Contrary to elliott belief, I don't remember everything.
14:19:35 <Zenol> so ghc-7.6 is "too old" ?
14:19:38 <napping> edwardk: elliott seems to suggest turning on ImplicitParams and using ?x
14:19:41 <paolino_> it would be nice to see cabal compile in parallel
14:19:42 <shachaf> I think ?x does give you more information.
14:19:52 <edwardk> napping: thats what i use as a poor man's hole in the meantime
14:19:53 <shachaf> It also lets you have multiple ImplicitParams easily.
14:19:56 <napping> if you can actually turn on and use TypeHoles I would expect that to be clearly better
14:20:01 <shachaf> It also lets GHC suggest things with inference?
14:20:08 <elliott> TypeHoles aren't better.
14:20:13 <shachaf> Last time I checked TypeHoles (which was many months ago), ImplicitParams was better.
14:20:14 <elliott> unless they fixed them.
14:20:14 <edwardk> sure, if you're on HEAD and have TypeHoles, go nuts
14:20:27 <napping> I've just been using (), I don't understand why an implicit param would be better
14:20:30 <Zenol> I'm really efraid of RankNTypes. I had inference error one time, with it.
14:20:32 <napping> trying harder to instantiate the type?
14:20:41 <shachaf> Try it and see.
14:20:44 <edwardk> Zenol: here its not a rank-n type. ghc just is worried it might be
14:20:51 <shachaf> Maybe it isn't better in your use case. :-)
14:21:00 <edwardk> Zenol: you can write that signature explicitly without one to prove it to yourself
14:21:02 <edwardk> just expand Lens
14:21:32 <edwardk> wide :: Functor f => ALens' r Word8 -> ALens' r Word8 -> (Word16 -> f Word16) -> r -> f r
14:22:07 <thoughtpolice> shachaf: TypeHoles has been tweaked some but I can't remember your complaints exactly
14:22:15 <shachaf> thoughtpolice: I can't either.
14:22:19 <edwardk> Zenol: but then you'll have given into the tyranny of the type checker and made your types less readable for no reason
14:22:46 <Taneb> joelteon, I've got a feeling most of that code was decrementing
14:22:47 <shachaf> More like "the tyranny of the extension checker".
14:23:54 <Zenol> edwardk: But if I want GHC to "try anyway", I can't do anything else than adding LANGUAGE RankNTypes ?
14:23:56 <napping> well, with (test :: Int; test = foldr _ 12 ["a","b"]) ?x gives two separate errors about not having defined ?x :: a0 -> Int -> Int and not having IsString a0, while () complains it doesn't match String -> Int -> Int
14:24:16 <thoughtpolice> shachaf: i think the main thing that was changed is that HEAD is now not as clever in what relevant bindings it suggested
14:24:36 <edwardk> shachaf: i'll be in california for the gsoc mentor summit oct 19-20, i can stick around a day or two on either side. curious if you guys are planning any sort of haskell meetup around then or would be interested in doing one
14:24:49 <edwardk> Zenol: correct
14:24:51 <napping> ah, and with a class that doesn't get defaulted () would just complain () doesn't match a0 -> Int -> Int without mentioning the constraint
14:25:13 <thoughtpolice> like, before you could have: f1 :: Int -> Int -> Int; f1 x y = _, and 'x' and 'y' would not be suggested, but f :: a -> a -> a; f x y = _, would make both 'x' and 'y' suggested
14:25:33 <edwardk> oh i hadn't even thought about the () being in the defaulting rules
14:25:45 <thoughtpolice> previously it relied on basically what types unify with the type variables in the scope of the hole. this was changed for the better
14:25:56 <shachaf> edwardk: We've been having some trouble finding venues recently, so there hasn't been a meeting in a bit, but we can certainly try for something when you're around.
14:25:59 <edwardk> i agree that it was trying to be too clever
14:26:13 <edwardk> shachaf: i'd be willing to do a talk even
14:26:57 <edwardk> shachaf: if you can ping folks and lemme know i'll then book my flight accordingly
14:27:03 <thoughtpolice> edwardk: yes, after Andres suggested the change and Simon made it i played around a little and i like it much better
14:27:09 <shachaf> edwardk: Sounds good. I'll do that.
14:27:10 <napping> edwardk: well, in my case I saw IsString a defaulting a to String, not the other way around
14:28:15 <Eduard_Munteanu> Argh, indexed comonad indices for (=>>) are different.
14:28:24 <Zenol> feel like I'm not understanding what I'm doing. cloneLens l desn't create a Lens that could be used as a Getting / ASetter ?
14:28:26 <shachaf> edwardk: A day or two on either end -- so that'd be Thu at the earliest or Tue at the latest?
14:28:35 <edwardk> Eduard_Munteanu: in the choice of direction?
14:28:52 <Eduard_Munteanu> edwardk: yeah, it's like un-composing arrows
14:28:55 <ReinH> elliott: oh, well that was easy.
14:28:56 <edwardk> yep
14:28:58 <ReinH> Why am I so dumb? :/
14:29:04 <edwardk> Eduard_Munteanu: think 'co-category' ;)
14:29:17 <Eduard_Munteanu> Oh, yeah, makes sense.
14:29:23 <tibbe> Cabal 1.18.0 is out! http://www.haskell.org/pipermail/haskell-cafe/2013-September/108722.html
14:29:32 <tibbe> 852 commits!
14:29:35 <monochrom> onoes
14:29:44 <elliott> ReinH: everything is easy with hole-driven development
14:29:57 <elliott> you finally get to stop thinking
14:30:03 <Taneb> man, I need a radically different syntax
14:30:05 <edwardk> Eduard_Munteanu: https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs uses the one parameter version where its clear this arises from just allowing for an indexed parameter
14:30:05 <jfischoff> tibbe: congrats!
14:30:09 <Taneb> As in not even writing
14:30:10 <shachaf> Eduard_Munteanu: duplicate :: w i k a -> w i j (w j k a)
14:30:11 <Taneb> Trees
14:30:16 <edwardk> tibbe++
14:30:22 <Eduard_Munteanu> Nowai.
14:30:34 <ReinH> Tropical (Just a) >>= k = Tropical $ getTropical (k a)
14:30:40 <ReinH> that should have been obvious :/
14:30:40 <Eduard_Munteanu> I derived duplicate for the wrong indexing direction earlier, it seemed odd. :)
14:30:58 <edwardk> Eduard_Munteanu: you can derive the 'two parameter' version from the one parameter version, which forces you into the right decomposition
14:31:02 <Zenol> oh, i see, I can't share the use of a lens created localy with cloneLens in both a call as a setter and as a getter.
14:31:22 <elliott> ReinH: Tropical $ getTropical x is not so obvious
14:31:40 <ReinH> elliott: well, I knew I had to unwrap and rewrap it
14:31:44 <ReinH> even before I tried to write it
14:31:48 <edwardk> Zenol: yeah cloneLens is allowing the fresh selection of a new choice for 'f'
14:31:49 <elliott> I disagree
14:31:49 <ReinH> so I don't know why I didn't try that first
14:31:54 <edwardk> Zenol: you ned two such choices
14:31:56 <edwardk> er need
14:31:57 <elliott> as in, your answer is overly complex.
14:32:02 <ReinH> elliott: ?
14:32:12 <elliott> ReinH: what is the definition of getTropical?
14:32:16 <elliott> write it in terms of pattern matching
14:32:27 <Zenol> edwardk: Ok, it compile :)
14:32:43 <ReinH> elliott: I can get rid of the wrapping and unwrapping.
14:32:43 <ReinH> sigh
14:32:47 <ReinH> elliott: I told you I'm domb :)
14:32:48 <Zenol> Is there a way to activate Rank2Types only for one function of a module?
14:32:52 <ReinH> *dumb
14:32:57 <edwardk> ReinH: Tropical m >>= k = Tropical (m >>= getTropical . k)
14:32:58 <Eduard_Munteanu> edwardk: hm, how does that At thing work, is it an uncurried form of the functor?
14:33:01 <edwardk> ReinH: borrow from Mayb
14:33:32 <edwardk> Eduard_Munteanu: At is a trick by Bob Atkey (hence the name), Conor called it 'AtKey' i think
14:33:37 <shachaf> Zenol: Turning it on globally doesn't hurt much.
14:33:41 <Eduard_Munteanu> Heh.
14:34:07 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Types.hs#L107
14:34:10 <edwardk> At is boring
14:34:13 * Zenol is paranoiac
14:34:31 <edwardk> data At :: * -> k -> k -> * where At :: a -> At a k k
14:34:47 <edwardk> it just makes sure the last two parameters match
14:34:56 <jfischoff> Derpendent Types
14:35:00 <ReinH> oh.
14:35:00 <jfischoff> :)
14:35:02 <ReinH> sigh
14:35:02 <edwardk> in the comonad case i need the dual
14:35:04 <edwardk> newtype Coat a i j = Coat (i ~ j => a)
14:35:05 <Eduard_Munteanu> edwardk: does one really need indexed variants for Functor and (Co)Pointed? It seems to me you can make those pointwise-indexed, e.g. Copointed for w i i, Functor for w i j  etc.
14:35:16 <edwardk> it says if you can show me the indices match then i can give you a
14:35:23 <Eduard_Munteanu> Oh.
14:35:41 <edwardk> Working out the need for Coat took me an embarassingly long time
14:35:48 <Eduard_Munteanu> edwardk: how do you deal with i and j not matching though?
14:35:53 <edwardk> jfischoff: thats the lib =)
14:36:26 <edwardk> Eduard_Munteanu: consider the store comonad:    data Store s a i = Store (s ~> a) (s i)
14:36:33 <edwardk> where ~> is a natural transformation
14:36:43 <ReinH> edwardk: wait, doesn't this work? Tropical (Just a) >>= k = k a
14:36:47 <Eduard_Munteanu> Ok.
14:36:50 <edwardk> the 'i' parameter is fixed outside its the arg to Store.
14:36:51 * jfischoff takes a look at indexed
14:37:09 <edwardk> the one for the 'experiment' is selected when it gets invoked
14:37:17 <edwardk> so we can pass it s i, and get an   a i
14:37:39 <edwardk> now, this gives you a way to talk about 'higher rank' stores
14:37:52 <edwardk> it is also enough to give you the classic 2-parameter indexed stores!
14:38:19 <Eduard_Munteanu> Hm.
14:38:53 <edwardk> we do that by using Store s (Coat b j) i
14:38:54 <Eduard_Munteanu> newtype Coat a i j = Coat (i ~ j => a)   still seems odd to me. It's almost a GADT but it isn't.
14:39:17 <edwardk> that is saying but for this constraint, i could give you 'a'
14:39:35 <shachaf> Eduard_Munteanu: It asks the consumer for the equality, rather than providing it.
14:39:41 <edwardk> it took me a _long_ time to find that
14:39:48 <elliott> that type is scary
14:40:41 <edwardk> (!=>) :: IComonad w => w a i -> (w a j -> b) -> w (Coat b j) i   --- looks a lot more like the indexed store extend you'd expect
14:40:46 <Eduard_Munteanu> Oh I see, the producer only makes Coat a same same's
14:41:09 <edwardk> if you pick a = (Coat a' k)  or something
14:41:56 <edwardk> IComonad w => w (Coat a' k) i -> (w (Coat a' k) j -> b) -> w (Coat b j) i
14:42:05 <Eduard_Munteanu> How is that different from  data Coat a i j where Coat :: a -> Coat a i i ? Just newtype being slimmer?
14:42:13 <edwardk> no different meaning
14:42:42 <edwardk> Coat :: a -> Coat a i i = Coat :: (i ~ j) => a Coat a i j
14:42:43 <edwardk> this is
14:42:48 <shachaf> Eduard_Munteanu: That's data Coat a i j = i ~ j => Coat a i j
14:42:52 <shachaf> Er.
14:42:54 <shachaf> No.
14:42:58 <shachaf> Eduard_Munteanu: That's data Coat a i j = i ~ j => Coat a
14:42:58 <edwardk> Coat :: ((i ~ j) => a) -> Coat a i j
14:43:24 <shachaf> Vs. data Coat a i j = Coat (i ~ j => a)
14:44:31 <edwardk> Eduard_Munteanu: consider the difference between Foo a b= forall r. Foo (r -> b, r -> a -> r, r)    and Foo a b = Foo (forall r. (r -> b, r -> a -> r, r))
14:44:38 <edwardk> the former is an existential, the latter universal
14:44:47 <Eduard_Munteanu> You mean   Coat i i a   picks j but not i?
14:44:52 <edwardk> the difference is similar here in who is being asked to supply the proof
14:45:26 <shachaf> Eduard_Munteanu: i and j aren't treated differently in any of these.
14:45:28 <Eduard_Munteanu> So the (i ~ j) variant is parametric in both i and j.
14:45:34 <edwardk> i mean Coat a i j is like using weasel words to say "I can't necessarily prove i ~ j, but if I could, then here is an 'a'
14:46:10 <shachaf> Logical implication is weasel words now? :-(
14:46:10 <edwardk> At a i j   is saying i = j and here's an a
14:46:33 <napping> it looks like cabal install --reinstall doesn't rebuild the documentation
14:46:42 <elliott> edwardk: unfortunately you can't write Coat a Int Char!
14:47:04 <chrisdone> donri: donri
14:47:12 <edwardk> shachaf: well, i was trying to aim for the plausible deniability, 'hey i'm not saying these are the same thing, but hypothetically, if they were.. then the murderer would live here.'
14:47:22 <edwardk> elliott: ?
14:47:27 <donri> chrisdone: chrisdonri
14:47:29 <Eduard_Munteanu> Wait, I get that, but is my explanation wrong? I'm thinking in Agda terms a bit here... namely parameters vs indices.
14:47:58 <chrisdone> donri: i ported bdo to haskell as a service. you want to try it with vim?
14:48:13 <shachaf> edwardk: GHC will give you a unification error even though it ought to work out.
14:48:17 <monochrom> napping: don't you need --enable-documentation too? and --haddock-hyperlink-source? and hscolour?
14:48:21 <donri> chrisdone: maybe. possibly. probably!
14:48:25 <shachaf> I think I complained about this on the mailing list at one point.
14:48:50 <elliott> edwardk: because (Int ~ Char => ...) is uninhabited
14:48:59 <elliott> it's an error to try and write a value of that type.
14:49:15 <elliott> it's like if Coq stopped you writing (False -> ...) because, um, duh, False is obviously not true!
14:49:24 <napping> monochrom: that worked before, but now passing those it doesn't print any output about updating documentation, nor does it update the documentation
14:49:39 <napping> supposed 1.18.0 would make it possible to set all those default in the config file, instead it seems they are broken
14:49:45 <Eduard_Munteanu> data Coat (a i j : Set) where Coat : i == j -> a -> Coat a i j   vs    data Coat (a i : Set) : Set -> Set where    Coat :: a -> Coat a i i,   right?
14:49:53 <monochrom> I see. I guess I have never tried --reinstall
14:50:04 <edwardk> elliott: ghc will stop me from writing it?
14:50:11 <elliott> edwardk: try it
14:50:22 <edwardk> elliott: well, i can get there by subversion i'd think
14:50:23 <shachaf> http://www.haskell.org/pipermail/glasgow-haskell-users/2013-March/022416.html
14:50:28 <napping> defaulting jobs to $ncpus is nice but was hiding output
14:50:28 <edwardk> make one polymorphic in 'a'
14:50:31 <edwardk> then pick a = Char
14:50:49 <shachaf> Yes, you can sometimes trick GHC into doing it.
14:50:52 <shachaf> But the trickery is annoying.
14:50:52 <Eduard_Munteanu> I'm totally confused by GHC's implementation of GADTs though, mostly because it doesn't distinguish indices from parameters.
14:51:18 <monochrom> napping: there is some log in .cabal/logs
14:52:33 <edwardk> Eduard_Munteanu: i'd ask dolio. =)
14:52:34 <napping> looks like --hyperlink-source isn't actually an option to haddock
14:52:45 <edwardk> Eduard_Munteanu: i'm forgetting all i knew about agda
14:53:51 <Eduard_Munteanu> Eh, I haven't touched it lately either.
14:54:05 <edwardk> Eduard_Munteanu: anyways i was just using that to showcase that you can get the 'right answer' forced on you for how those should compose just by using the single parameter version and making a monad/comonad is over k -> * instead of *
14:54:16 <monochrom> napping: if possible, prefer "cabal haddock --hyperlink-source" because the right options to haddock and other auxiliary procedures are very very detailed :)
14:54:28 <Eduard_Munteanu> I see.
14:54:34 <edwardk> then using Coat to talk about the values picks the right args for the 2 arg version
14:54:53 <napping> monochrom: yeah, so how do I get cabal install to automatically pass all the right options?
14:54:53 <edwardk> this was conor's trick, but i thought it was quite clean
14:54:55 <monochrom> for example to do it manually you have to run hscolour with detailed options and then haddock with detailed options
14:55:15 <edwardk> sadly in haskell it means all sorts of unnecessary boxing
14:55:17 <monochrom> "cabal install --enable-documentation --haddock-hyperlink-source"
14:55:20 <edwardk> so its terribly inefficient
14:55:26 <edwardk> so i wind up needing both styles anyways
14:55:35 <Eduard_Munteanu> edwardk: how about Functor and all that... do they really need separate typeclasses?
14:55:53 <edwardk> IFunctor?
14:55:59 <Eduard_Munteanu> edwardk: yes
14:56:02 <edwardk> class IFunctor f where
14:56:02 <edwardk>   imap :: (a ~> b) -> f a ~> f b
14:56:08 <edwardk> that takes a natural transformation
14:56:13 <napping> monochrom: you missed the part where it is supposedly possible to make those flags the default in Cabal 1.18
14:56:14 <edwardk> what gives me that now?
14:56:34 <edwardk> i need that full flexibility
14:56:38 <monochrom> sure, edit .cabal/config if 1.18
14:56:45 <napping> monochrom: How?
14:56:57 <edwardk> consider fmapping over that store i showed
14:57:13 <monochrom> must I answer?
14:57:15 <edwardk> i need to work no matter what type parameter winds up on the 'a'
14:57:24 <napping> monochrom: that's the only question I've been asking
14:57:28 <Eduard_Munteanu> edwardk: oh you mean comonads must be natural in indices, not just pointwise functorial?
14:57:34 <Eduard_Munteanu> *indexed comonads
14:57:35 <monochrom> sigh, ok
14:57:36 <edwardk> yeah
14:57:57 <Eduard_Munteanu> I see.
14:58:02 <monochrom> change the line "-- documentation: False" to "documentation: True"
14:58:08 <edwardk> it isn't enough for you to give me class IFunctor f where imap :: (a i -> b i) -> f a i -> f b i
14:58:27 <edwardk> and i don't hav a class for that anyways =)
14:58:28 <monochrom> the hyperlink-source one is too new, I don't know its exact name. I'm still with 1.16
14:58:51 <napping> monochrom: I've had documentation: True approximately as long as I've been using cabal-install
14:59:05 <Eduard_Munteanu> edwardk: I was looking at older category-extras' IxFunctor that had   ixmap :: (a -> b) -> f i j a -> f i j b   but it seemed you could just use a  Functor (f i j).
14:59:08 <edwardk> one of the reasons why i've been exploring this so hard is to find a formulation for parameterized lenses
14:59:24 <edwardk> Eduard_Munteanu: i can't write the IndexedComonad constraint that way though
14:59:41 <edwardk> class (forall i j. Functor (f i j)) => IComonad f where … ???
14:59:53 <Eduard_Munteanu> edwardk: hm, so apart from the naturality thing, you can't write the superclass constraint, right.
15:00:05 <napping> tibbe: should it be possible to make --haddock-hyperlink-source the default in .cabal/config now?
15:00:06 <edwardk> hence the making of a new class
15:00:23 <monochrom> ok, how about this? move .cabal/config to elsewhere so you can restore it later. run "cabal update" or something so it re-generates .cabal/config. now you can read all the new options inside.
15:00:24 <edwardk> this version is a bigger slam dunk because its working 'one parameter up'
15:00:42 <edwardk> and nicely because once you've written the one parameter version you nver have to write any bigger versions.
15:00:45 <edwardk> we're parametric in k
15:00:55 <edwardk> the old cases hold where k = ()
15:01:10 <napping> monochrom: that's what I did before I started asking here. There's a haddock-options: line which doesn't work because hyperlink-source is properly a cabal haddock option for reasons you've mentioned, and nothing explicitly about hyperlink.
15:01:13 <edwardk> it'd just leave an odd style =)
15:01:53 <monochrom> I see
15:01:56 <Eduard_Munteanu> edwardk: would there be much of a semantic difference if you moved the superclass constraint to ixmap's type? e.g.  ixmap :: forall i j. (Functor (f i j)) => ...
15:02:41 <Eduard_Munteanu> That makes f pointwise functorial.
15:02:52 <edwardk> Eduard_Munteanu: ixmap may need the ability to use another ixmap at a different index though
15:02:55 <edwardk> hence naturality
15:03:10 <Eduard_Munteanu> Oh, I see.
15:03:43 <Eduard_Munteanu> edwardk: so what is it CT-wise, a "trifunctor"?
15:04:14 <Eduard_Munteanu> F : I x J x A -> A ?
15:04:26 <Zenol> there isn't a xor operator in Data.Lens.Bits?
15:04:44 <edwardk> Eduard_Munteanu: no idea =)
15:05:04 <edwardk> Eduard_Munteanu: i view the two-parameter versions as just degenerate cases of the 1-parameter versions
15:05:21 <edwardk> the one parameter version is just the normal construction built over k -> * instead of *
15:05:42 <Eduard_Munteanu> Yeah, then it would be a bifunctor : K x A -> A, I suppose.
15:07:22 <napping> tibbe: I've made a shell alias for now
15:08:31 <edwardk> Zenol: we don't have a xor=     since xor isn't an operator =)
15:08:47 <edwardk> Zenol: you can of course use over l (xor a)
15:08:53 <edwardk> or l %~ xor a
15:10:14 <Zenol> a should be a value, or can be a lens?
15:10:14 <monochrom> yikes, edwardk is gone
15:10:55 <Zenol> ohw :(
15:11:59 <Zenol> I wonder why isn't a .^. operator in Data.Bytes
15:13:01 <monochrom> perhaps because ^ does not mean xor
15:13:03 <Saizan> Eduard_Munteanu: more like K x (K -> A) -> A
15:13:05 <monochrom> > 2^2
15:13:06 <lambdabot>   4
15:13:14 <monochrom> guess what ^ means :)
15:13:34 <shachaf> ^ means exponentiation, and ^^ means tetration, obviously.
15:13:37 <Taneb> joelteon, the decrement function is 238 characters long and still growing
15:13:39 <shachaf> > 2^^2
15:13:40 <lambdabot>   4.0
15:13:49 <mornfall> or not :-)
15:13:49 <joelteon> sweet
15:14:06 <monochrom> does tetration mean "the answer is 4"? :)
15:14:07 <Zenol> not sure that | and & have the same meaning as .|. and .&. ...
15:14:24 <shachaf> | is syntax.
15:14:29 <mornfall> > 2^^3
15:14:30 <lambdabot>   8.0
15:14:34 <mornfall> monochrom: apparently not
15:14:35 <monochrom> at least you already know || and &&
15:15:09 <monochrom> > [False /= False, False /= True, True /= True]
15:15:10 <lambdabot>   [False,True,False]
15:15:23 <Zenol> If you really don't like ^ (wich is the xor operator in C as | and & are or/and operators) I'm ok with any symbol.
15:15:33 <monochrom> therefore, I nominate ./=. or .≠. for bitwise xor
15:16:59 <monochrom> C is wrong because C does not use ^ for exponentiation. look at Fortran.
15:17:26 <monochrom> but you're going to get back at me with Pascal
15:17:31 <mornfall> tex!
15:17:50 <Zenol> monochrom: I'm really ok for any symbol, I just would be happier if there was one :p
15:18:28 <mornfall> .⊕.
15:18:33 <Zenol> hum, I would like to write a %= (xor b), but here b is a lens...
15:18:43 <Zenol> Oh, yeh! .⊕. :D
15:18:57 <Zenol> or only ⊕ ^^
15:19:45 <sm> woot new cabal.. thank you tibbe, dcoutts and all
15:19:49 <Zenol> whould be a <%~ operator somewhere...
15:20:21 <mornfall> .><. would possibly work too, in ascii
15:21:06 <Zenol> ren't they already a >< operator?
15:21:17 <Zenol> @hoogle (><)
15:21:17 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
15:21:17 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
15:21:17 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:21:43 <mornfall> I hope it's used for a product... :-P
15:22:20 <Zenol> Data.Sequence.(><)
15:23:04 <Zenol> hum, we can argue that xor "concatenate" two values.
15:24:15 <mornfall> that's a stretch (but >< or >-< is a xor symbol, although not as good as a circled +... good luck drawing a circled plus in ascii tho)
15:25:35 <Taneb> joelteon, final lenght of decrement function: 350 chars
15:25:35 * geekosaur casts summon APL...
15:25:47 <Taneb> Or thereabouts
15:25:54 <geekosaur> + backspace O
15:27:33 <Zenol> (+)
15:27:57 <Zenol> you asked me to draw it, not to make it a valid haskell operator :p
15:28:25 <Mackbet> http://www.neobux.com/?r=Mackbeth
15:28:29 <ion> ⊕
15:29:06 <napping> Zenol: unicode operators are accepted
15:29:08 <ion> > let a ⊕ b = a * b in 42 ⊕ 10
15:29:09 <lambdabot>   420
15:30:04 <Zenol> napping: I mean (+) can't be an operator, because ( can't be part of an operator.
15:30:24 <Zenol> Cut and past in lens's documentation for the operator '<%~'
15:30:27 <napping> oh that's out
15:31:23 <Zenol> @msg edwardk When you do not need the result of the addition, (%~) is more flexible.  -> s/addition/affectation
15:31:24 <lambdabot> Not enough privileges
15:31:28 <Zenol> :(
15:31:45 <shachaf> Try @tell.
15:32:06 <Zenol> @tell edwardk When you do not need the result of the addition, (%~) is more flexible.  -> s/addition/affectation
15:32:06 <lambdabot> Consider it noted.
15:32:11 <Zenol> shachaf: Thanks :)
15:32:47 <Zenol> sreriously, what "<<%@=" could means?!
15:33:20 <Zenol> I nead some kind of lift2Lens...
15:33:26 <joelteon> :t (<<%=)
15:33:27 <lambdabot> (MonadState s m, Data.Profunctor.Strong p) => Overloading p (->) ((,) a) s s a b -> p a b -> m a
15:33:58 <Zenol> Yes, both the type and the doc can't help me :(
15:35:05 <Zenol> maybe I can do something with <*> and use...
15:35:33 <joelteon> :t execState
15:35:34 <lambdabot> State s a -> s -> s
15:35:57 <joelteon> > runState (_1 <<%= succ) (2,'c')
15:35:59 <lambdabot>   (2,(3,'c'))
15:36:37 <joelteon> Zenol: << if I recall correctly is the lens idiom for "returns the old value"
15:37:24 <Zenol> joelteon: Do you now how I could do something like "a %= xor b" where b and a are both lens, the whole living in a state monad?
15:37:57 <Dodek> is there any document that describes all the lens typeclasses, like Getting etc?
15:38:00 <joelteon> there's an xor lens, Zenol
15:38:04 <Zenol> I can do "b' <~ use b ; a %= xor b'" but it's not beatifull.
15:38:13 <Zenol> oh?
15:38:13 <joelteon> or is there?
15:38:21 <joelteon> well, I thought there was
15:38:26 <joelteon> but it looks like all we have is & and |
15:38:39 <Zenol> I have a .|.= and a .&.= but no .xor.= :/
15:38:48 <joelteon> yeah, well, .xor.= isn't an operator name
15:38:51 <joelteon> you could define your own
15:38:57 <joelteon> using something like .^.=
15:39:18 <Zenol> I only need to use it once in the whole code.
15:39:33 <joelteon> ok, then just do it the way you were doing
15:39:49 <Zenol> But there should be an operator or function that allow transforming a function like xor into something nice when you use lens.
15:40:03 <joelteon> yeah, but you couldn't do .|.= b either
15:40:13 <joelteon> as far as I know you can't combine a setter and a getter like that
15:41:30 <Zenol> even with "over" and stuff like that? :/
15:42:20 <joelteon> not that I know of, but my lens-fu is not very strong
15:42:28 <joelteon> edwardk wrote it
15:42:35 <joelteon> you could join #haskell-lens and ask, the guys there know more than me
15:43:10 <Zenol> or I can wrote it in a post it a ask edwardk tomorow :p
15:43:19 <joelteon> sure
15:48:03 <haasn> what do you mean
15:48:21 <haasn> transforming a function into an operator like .|.= ?
15:49:07 <joelteon> yeah
15:49:12 <joelteon> you could easily define xor
15:49:21 <joelteon> l .^.~ n = over l (xor n)
15:49:55 <haasn> l .^.~ n = l %~ (.^. n)
15:50:01 <haasn> l .^.= n = l %= (.^. n)
15:50:04 <haasn> does this answer your question?
15:51:10 <jfischoff> does anyone have an example of linking an haskell executable by hand, i.e. not using ghc?
15:51:45 <chrisdone> jfischoff: uhh hang on
15:52:54 <chrisdone> this makefile might help https://github.com/Peaker/haskell_ffi_tests
15:53:16 <chrisdone> it uses gcc to compile, linking to ghc's runtime environment
15:53:52 <monochrom> nice, it also builds a shared library :)
15:54:08 <jfischoff> chrisdone: thanks
15:54:35 <haasn> joelteon: 1. the combination of a getter and a setter is exactly what a lens is, 2. .&.= and stuff doesn't need a getter, just a setter (you can map functions over setters via ‘over’, the name is perhaps a bit misleadingly implying that you can only use ‘set’)
15:54:56 <elliott> Overer
15:55:04 <joelteon> ok, so combining a getter and a setter, and another getter and a setter
15:55:39 <joelteon> but yeah, like I said
15:55:42 <joelteon> I warned him not to listen to me
15:55:59 <haasn> elliott: Mapper
15:57:48 <Zenol> haasn: Hum, l .^.= n = l %= (.^. n) ?
15:57:55 <jfischoff> chrisdone: not exactly what I want, but I think it is best I'll get :P
15:58:03 * hackagebot haskell-names 0.2.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.2.1 (RomanCheplyaka)
15:58:16 <Zenol> n isn't a getter here?
15:58:30 <Eduard_Munteanu> Saizan: hmmm... is the index K supposed to determine A? I thought for any given indexed (co)monad you get a corresponding co(monad) by fixing the indices.
15:58:38 <jfischoff> is there a way to tell ghc --make to automatically find packages and only use the ones I pass in?
15:58:47 <jfischoff> s/automatically/not automatically
15:58:56 <Zenol> haasn: I would like the same thing as writing "a %= xor 5" but replacing 5 with a getter, all that living in a state monad.
15:59:27 <Eduard_Munteanu> Saizan: as in (>>=) :: m i i a -> (a -> m i i b) -> m i i b
15:59:36 <chrisdone> monochrom: i was looking into building emacs linked to haskell, peaker helped me out and made that demo =)
16:00:00 <chrisdone> jfischoff: yeah umm
16:00:03 <chrisdone> -hide-all-packages
16:00:05 <chrisdone> or something like that
16:00:06 <jfischoff> ah
16:00:27 <Eduard_Munteanu> Where  m i i  is a functor Hask -> Hask.
16:00:31 <jfischoff> google says you are right
16:00:34 <Saizan> Eduard_Munteanu: i was talking of the 1-index version
16:00:37 <haasn> Zenol: n <- use yourGetter; a %= xor n
16:00:44 <Eduard_Munteanu> Oh, ok. I don't fully grok that yet.
16:00:54 <napping> is there any good data structure you for keeping a set of sets, and partiioning it based on which sets are subsets of a query set?
16:00:54 <haasn> Zenol: use yourGetter >>= (a %=) . xor -- hmm, if only (%=) had a name..
16:01:02 <Saizan> which is really (k -> *) -> (k -> *)
16:01:14 <haasn> Zenol: note for the special case where instead of ‘xor’ you're using ‘const’ there's an operator for this called <~
16:01:17 <joelteon> bwah
16:01:18 <haasn> as in a <~ yourGetter
16:01:24 <Eduard_Munteanu> Saizan: um, I didn't ask edwardk... what's that 'k' again?
16:01:29 <elliott> :t (<~)
16:01:29 <joelteon> that's what I suggested
16:01:30 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
16:01:34 <elliott> haasn: are you sure?
16:01:42 <haasn> a <~ use yourGetter -- sorry
16:01:47 <monochrom> jfischoff: it's also what cabal-install does. "ghc -hide-all-packages -package base-127.0.0.1 ..."
16:01:48 <Zenol> haasn: Yes I use <~ for stuff like a <~ use b
16:01:53 <Eduard_Munteanu> Saizan: a placeholder for the index category?
16:02:00 <chrisdone> monochrom: hax!!!1
16:02:05 <jfischoff> monochrom: ah cool that's what I want
16:02:11 <Eduard_Munteanu> (therefore presumably a subcategory of *)
16:02:13 <Saizan> Eduard_Munteanu: it's a kind parameter
16:02:27 <jfischoff> its really unfortunate that make is so much faster than cabal
16:02:58 <Eduard_Munteanu> Does it correspond to some GHC extension?
16:03:13 <jfischoff> mostly because of -j
16:03:19 <Zenol> haasn: (a %=) . xor =<< use b works fine. Thanks :)
16:03:34 <haasn> Zenol: be careful with that, somebody might stab you
16:03:38 <joelteon> we need a $ that is =<<
16:03:51 <Zenol> haasn: why? :o
16:04:01 <joelteon> because, you know, haskell needs more operators.
16:04:03 <haasn> Zenol: bordering on incomprehensible
16:04:06 <haasn> joelteon: like =<< ?
16:04:11 <joelteon> yes, but shorter
16:04:19 <Saizan> Eduard_Munteanu: yeah, PolyKinds
16:04:21 <joelteon> and visually similar to $
16:04:34 <Eduard_Munteanu> joelteon: f <$> a <*> b <*> ... ?
16:04:44 <Dodek> when it comes to the operators, haskell is the new perl.
16:04:45 <joelteon> what about it?
16:04:46 <haasn> joelteon: I'm sure there's an unicode glyph that's like =<< somewhere :P
16:04:58 <Eduard_Munteanu> joelteon: sort of does that for a pure 'f'.
16:05:11 <Eduard_Munteanu> Hm, I should look at polykinds, thanks.
16:05:56 <Eduard_Munteanu> Would be nice if one could 'join' for a monadic 'f' less intrusively.
16:06:18 <joelteon> >>= id
16:06:19 <Eduard_Munteanu> Some do stuff like   f <$> a <*> b <*> c <**> d
16:06:34 <joelteon> but with my proposed new monadic $, we could do id $= f
16:06:59 <Eduard_Munteanu> Err, not sure what you mean.
16:07:10 <joelteon> because join f = f >>= id
16:07:15 <joelteon> and $= is =<<
16:07:27 <Eduard_Munteanu> Oh, I see.
16:07:29 <jfischoff> is there a way to ask cabal what packages it will use to link an executable with? exact package id
16:07:58 <Eduard_Munteanu> It needs to associate to the right I suppose.
16:10:13 <Kaini> jfischoff, I think cabal build -v prints it
16:11:51 <Eduard_Munteanu> Hmmm...
16:12:48 <acowley> jfischoff: I wrote a horrible little program to give me the right files to link to based on package names. However, "right" in this instance was just the newest version.
16:13:44 <Eduard_Munteanu> Let (<*>) = (,), and  f <$> x = uncurry f (lift x)   where lift automagically lifted (a, (b, c)) to (a, b, c) and so forth
16:13:46 <acowley> jfischoff: It worked for my needs because I couldn't find the right pieces in Cabal itself. But it's too limited and fragile to be generally useful. My use-case was a Makefile where I could just list things like HS_PKGS=vector JuicyPixels OpenGL
16:14:45 <Eduard_Munteanu> Perhaps stick a fmap in there too.
16:15:22 <Eduard_Munteanu> Anyway I was going for something like    f <$> (a <*> b <*> c)
16:15:53 <adnap> XD
16:16:05 <adnap> Would f <$> $ a <*> b <*> c work?
16:16:22 <Eduard_Munteanu> Cool.
16:16:25 <Eduard_Munteanu> I think so.
16:16:28 <enthropy> no
16:16:29 <adnap> I don't even think you need $
16:16:39 <adnap> f <$> a <*> b <*> c
16:16:42 <joelteon> well, no
16:16:51 <Eduard_Munteanu> It would work if <*> associated to the right.
16:16:52 <enthropy> (f <$>) $ a <*> b <*> c  would give you  f <$> (a <*> b <*> c)
16:17:00 <joelteon> because that's (((f <$> a) <*> b) <*> c)
16:17:09 <joelteon> and that's no good
16:17:18 <enthropy> > f <$> do a <*> b <*> c :: Expr
16:17:19 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
16:17:19 <lambdabot>              w...
16:17:23 <Eduard_Munteanu> Sure, but we're talking about a different (<$>) and (<*>)
16:17:33 <joelteon> oh nvm
16:17:44 <adnap> I don't think the order matters
16:18:09 <adnap> > (+) <$> (Just 3 <*> Just 2)
16:18:10 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
16:18:10 <lambdabot>    arising f...
16:18:30 <Eduard_Munteanu> adnap: it matters for the normal Applicative stuff.
16:18:34 <adnap> > (+) <$> Just 3 <*> Just 2
16:18:35 <lambdabot>   Just 5
16:18:37 <Eduard_Munteanu> It associates to the left.
16:18:44 <adnap> Oh, I see
16:18:56 <enthropy> > not <$> do Just (==) <*> Just 1 <*> Just 1
16:18:57 <lambdabot>   Just False
16:19:08 <Eduard_Munteanu> And this is problematic because the very last <*> dictates what happens with the result.
16:19:15 <adnap> enthropy: Ah!
16:19:32 <adnap> enthropy: Now I understand the different applicatons
16:19:41 <adnap> *applications
16:19:44 <Eduard_Munteanu> E.g. if you want to join, you'll have to do use a makeshift <***> say, in f <$> a <*> b <***> c.
16:20:04 <Eduard_Munteanu> Would be nicer if you could use a different <$> instead.
16:20:18 <amyers> Does anyone know why a 'cabal build' would build everything but not link the executable?  It is an executable build
16:20:30 <amyers> and it was working before
16:20:35 <amyers> Not sure what I did to break it
16:21:54 <joelteon> what happens if you run the executable
16:22:12 <amyers> It's not there
16:22:19 <amyers> Okay, if I change this line in my .cabal file
16:22:20 <amyers> ghc-options: -Wall -O3 -rtsopts -with-rtsopts -K64M -c
16:22:22 <amyers> to
16:22:23 <amyers> ghc-options: -Wall -O3 -rtsopts -with-rtsopts -K64M
16:22:27 <amyers> It now builds the executable
16:22:31 <Eduard_Munteanu> And unfortunately we don't have unifix (?) operators either, so something like  $$ f <$> a <*> b  is also out of the question.
16:22:37 <jfischoff> acowley: yeah thats what I want
16:22:53 <joelteon> what does -c do?
16:22:58 <enthropy> > let (!) x = product [1 .. x] in (5 !)
16:23:00 <lambdabot>   120
16:23:09 <amyers> So removing the -c option fixes it?  Does -with-rtsopts only take the next argument?
16:23:18 <joelteon> yeah
16:23:22 <Eduard_Munteanu> (Agda lets you define mixfix ops like $$_ :: ...)
16:23:25 <amyers> joelteon: When given as an RTS option it uses the compacting collector
16:23:35 <amyers> joelteon: I see, that makes sense, I'm a dummy
16:23:39 <amyers> joelteon: Thanks
16:23:40 <joelteon> why aren't you using +RTS ... -RTS
16:23:45 <Eduard_Munteanu> (And unlike normal functions they can bind less tight than function application)
16:23:56 <amyers> joelteon: I don't want to have to put that in every time I run the program
16:24:11 <joelteon> oh ok
16:26:27 <Zenol> good night.
16:36:04 <ReinH> acowley: ping
16:36:21 <acowley> ReinH: pong
16:36:45 <ReinH> acowley: so I wrote my own dijkstra map algorithm, which is not very fast
16:36:51 <ReinH> but I used a tropical semiring :D
16:37:02 <acowley> ReinH: How not fast?
16:37:46 <acowley> ReinH: I played a bit with a branch of the DistanceTransform package to think about the situation. And it's not a great fit for the algorithm, but I think iterating the algorithm to a fixed point would work.
16:37:50 <ReinH> acowley: I'm not quite sure, but probably O(n^3) with shitty constants :)
16:38:06 <acowley> ReinH: Which would have some of the pleasant characteristics of jump-point search.
16:38:16 <ReinH> acowley: yes, jump point search is magical
16:38:29 <ReinH> but in this case not useful since I want the distance to a target point *from everywhere*
16:38:35 <ReinH> and calculating that via JPS is not faster than brute forcing it
16:38:45 <ReinH> i.e. BFS
16:39:06 <napping> how serious about performance are you?
16:39:21 <ReinH> napping: not super serious right yet
16:39:36 <adnap> Can someone explain why this doesn't work, and how to fix it? http://ideone.com/9Xmoss
16:39:49 <napping> JPS might have better spatial locality if you become super serious
16:40:35 <acowley> ReinH: Unless you can do the same 1D decomposition trick ala Meijster, but iterate it. You get fast runs in either dimension, but pay for obstacles with iteration.
16:40:47 <ReinH> acowley: right
16:40:52 <ReinH> acowley: what I'm doing right now is quite stupid
16:41:10 <ReinH> but it handles any number of target points
16:41:35 <ReinH> a BFS from a single target would have better asymptotics
16:41:52 <acowley> ReinH: What size maps are you dealing with?
16:42:42 <ReinH> acowley: roguelike-size maps, so let's say ||V|| on the order of 10^2 to 100^3
16:43:06 <ReinH> er
16:43:08 <ReinH> 100^2
16:43:34 <napping> I see no efficient function for partitioning a Data.Map by set Data.Set of keys
16:43:43 <adnap> boop
16:43:54 <adnap> Did anyone look?
16:44:06 <acowley> ReinH: And how much time are you willing to spend on computing things?
16:45:46 <ReinH> acowley: it should be responsive for a turn-based game, so I can be a bit slow
16:46:15 <ReinH> acowley: I've parallelized the generation so I can wait for a particular dijkstra map from a grid of IVars
16:46:31 <ReinH> si maps !!! coord gives me an IVar that I can get
16:46:33 <ReinH> *so
16:46:43 <ReinH> for the dijkstra map with that coord as the target
16:46:55 <acowley> ReinH: I guess I'll need to try out the iterative approach to see how it goes. I think it's less than 1ms per iteration. You need an iteration for each zig or zag in your path, so perhaps a fixpoint after 10 iterations?
16:47:27 <ReinH> acowley: I'm currently using a fixed point approach where I walk out from the targets and increment their neighbors
16:47:35 <ReinH> and stop when there's nothing left to update
16:48:07 <jmcarthur> wait, there's a DistanceTransform package?!
16:48:25 <jmcarthur> :o this would have save me so much time if i had known
16:48:29 <jmcarthur> *saved
16:48:48 <jmcarthur> acowley++
16:49:01 <adnap> :/
16:49:17 <acowley> jmcarthur: As ReinH demonstrated quite aptly yesterday, it desperately needs a V2
16:49:24 <ReinH> jmcarthur: :)
16:49:35 <jmcarthur> acowley: what is wrong with it?
16:49:47 <acowley> jmcarthur: I stirred the pot too long and never took out the trash
16:49:50 <ReinH> acowley: I'm going to switch to a straight up BFS from the target, which should be faster and doesn't require a fixed point
16:49:59 <jfischoff> NOINLINE sufficent to prevent inlining no matter what?
16:50:02 <acowley> jmcarthur: I was trying to compete with a high-end CUDA version, and I got to within 2x of its performance
16:50:10 <jmcarthur> acowley: i take that to mean the main issues are just lack of polish and cleanliness?
16:50:21 <acowley> jmcarthur: So then I stopped. I now have an OpenCL version that is faster than the CUDA one, but it has no home.
16:50:24 <acowley> jmcarthur: Yes
16:50:33 <ReinH> jmcarthur: yes, although there are a few low hanging features omitted
16:50:36 <jmcarthur> that is fine. i could clean it up.
16:50:39 <acowley> ReinH: You need more speed!
16:50:42 <jmcarthur> i'd been implementing my own
16:50:43 <ReinH> jmcarthur: go for it :)
16:50:47 <ReinH> acowley: OK! :D
16:51:05 <acowley> ReinH: I got all excited by this and now I want to see a bunch of swarming dudes on screen
16:51:06 <jmcarthur> i will get to it fairly soonish
16:51:13 <jmcarthur> i have other things on my stack right now
16:51:20 <ReinH> acowley: well fine :)
16:51:21 <jmcarthur> but i will almost certainly use this
16:51:29 <acowley> jmcarthur: The problem we have is that the distance transform used for things like this isn't quite what ReinH needs
16:51:30 <jmcarthur> in particular, i'm glad you took the time to make it fast
16:51:36 <jmcarthur> ah
16:51:42 <jmcarthur> well, it's exactly what i need :)
16:51:46 <acowley> jmcarthur: The distance transform is just distance to sources. ReinH needs shortest path to source.
16:51:47 <ReinH> acowley: we need to do the distance transform over a tropical semiring!
16:52:00 <ReinH> acowley: I actually don't need shortest paths
16:52:09 <jmcarthur> what do you need?
16:52:12 <acowley> ReinH: It's just information on barriers that needs to be propagated
16:52:20 <adnap> Hello?
16:52:22 <acowley> ReinH: Oh, then I don't know what you need!
16:52:27 <adnap> Should I just come back later?
16:52:41 <jmcarthur> adnap: sorry, did you ask a question earlier?
16:52:45 <adnap> jmcarthur: Yes
16:52:46 <ReinH> acowley: I do need the distances, but I need infinity to represent an unreachable square
16:52:46 <jmcarthur> adnap: sometimes things get lost
16:52:59 <adnap> Can someone explain why this doesn't work, and how to fix it? http://ideone.com/9Xmoss
16:53:01 <jmcarthur> adnap: even now i'm not pro
16:53:03 <acowley> ReinH: Right, but you need distances that route around unreachable squares
16:53:03 <jmcarthur> oops
16:53:12 <jmcarthur> adnap: i'll take a look
16:53:28 <ReinH> acowley: right
16:53:41 <acowley> ReinH: So it's not any of the easy distance metrics
16:53:48 <shachaf> jmcarthur: you're, like, totally pro, man
16:53:56 <acowley> Easy distance metrics (on uniform grids)
16:53:57 <ReinH> acowley: sure it is
16:54:08 <ReinH> acowley: it's any of the easy metrics *over a tropical semiring* ;)
16:54:33 <jmcarthur> shachaf: lol. i hit enter before i was done and then decided not to finish
16:54:43 <acowley> ReinH: It's not the binary operation that makes the DT algorithm not work for you, though, it's the graph topology encoded by your unreachable squares
16:55:05 <ReinH> acowley: you just need an applicative that understands infinity
16:55:42 <acowley> ReinH: Right, but that's the easy part! The hard part is plumbing the graph topology / unreachable square information through the DT algorithm without hurting performance too much
16:55:52 <jmcarthur> adnap: i'm going totally on a hunch based on experiences with RankNTypes, but if it works i can't explain why...   try replacing  print . fmap g $ f  with  print $ fmap g f
16:56:06 <acowley> ReinH: I actually initially wrote that code using a sum type with an explicit infinity and appropriate operations
16:56:07 <adnap> jmcarthur: That doesn't work
16:56:10 <jmcarthur> ah
16:56:16 <jmcarthur> then i have no clue
16:56:19 <acowley> ReinH: But performance drove me to obscenity :(
16:56:27 <ReinH> acowley: right, that would be a tropical semiring :D
16:56:46 <ReinH> acowley: specifically, this https://gist.github.com/reinh/8b858990b9dee67c6211
16:56:53 <jmcarthur> adnap: oh
16:56:57 <jmcarthur> adnap: i see what's going on
16:57:44 <jmcarthur> adnap: you may have defined f to be polymorphic in q, but by the time fmap gets under it, that q has been bound to something. it's no longer really "forall" q
16:58:20 <jmcarthur> adnap: i think you might need something like impredicative types to make this work, and even that is iffy because, afaik, impredicative types are kind of discouraged and somewhat loosely supported in ghc
16:58:36 <jmcarthur> f :: F p (forall q. F q Integer)
16:58:38 <ReinH> acowley: consider update v m = min v (m + 1) where v = currentValue; m = minNeighbor
16:58:49 <adnap> jmcarthur: That does not work. I already tried that
16:58:55 <adnap> jmcarthur: What is q bound to?
16:58:55 <jmcarthur> that does not surprise me
16:59:14 <ReinH> if v and m are Tropical values, update v m gives you your current behavior
16:59:23 <ReinH> but update <$> v <*> m is the behavior we want
16:59:42 <jmcarthur> it's not that it's bound to anything in particular, but that it's bound at all. it's like the difference between   forall q. f q  and  f (forall q. q).  q is bound in different places in each
16:59:43 <ReinH> because the applicative handles the infinity special case
16:59:57 <jmcarthur> hmm... are those actually equivalent? i stink at impredicative types
17:00:16 <ReinH> acowley: i.e. infinity stays infinity no matter what
17:00:41 <jmcarthur> adnap: i only have very loose reasoning skills about these things, and i've obviously been wrong twice already, so i think i'm going to abandon ship here
17:00:54 <jfischoff> there is a serious bug in crypto-random
17:00:57 <adnap> jmcarthur: Alright
17:01:06 <jmcarthur> jfischoff: any bug in a crypto library is serious
17:01:18 <ReinH> acowley: my Tropical is just a newtype wrapper around Maybe, so you should be able to use Maybe directly
17:01:23 <ReinH> maybe Maybe would give you better performance?
17:01:25 <shachaf> jmcarthur: Are what equivalent?
17:01:35 <adnap> jmcarthur: I will ask in here again later.
17:01:43 <jmcarthur> shachaf:    forall a. f a   and   f (forall a. a)
17:01:44 <jfischoff> its not a security bug, but it can bring down your site
17:02:03 <elliott> jmcarthur: yes if f is covariant
17:02:08 <jmcarthur> shachaf: i know there are instantiations of f for which they are the equivalent, but i don't know if it's that case for any f
17:02:12 <jmcarthur> ah! that makes sense
17:02:12 <jfischoff> it keeps opening handles to /dev/random through a unsafePerformIO call
17:02:39 <jmcarthur> i assume there is some similar property for when f is contravariant?
17:03:13 <jmcarthur> jfischoff: gross :(
17:03:24 <jfischoff> does Vincent Hanquez hangout here?
17:03:31 <jfischoff> jmcarthur: yeah
17:03:48 <jmcarthur> the only obvious workaround is to shake the mouse a lot :)
17:05:06 <Eduard_Munteanu> Unfortunately quite a few Linux things default to /dev/urandom because people got bitten and they're bitter now.
17:05:19 <jmcarthur> /dev/urandom is still pretty good
17:05:24 <elliott> jmcarthur: well, (forall a. a) is Void.
17:05:26 <elliott> so probably something with ()
17:05:28 <elliott> aka (exists a. a)
17:05:29 <jfischoff> it leaks both
17:05:38 <elliott> forall a. f a ~~ f () or such.
17:05:40 <Eduard_Munteanu> jmcarthur: yes, but it's that "YMMV" that frightens me
17:05:52 <jmcarthur> elliott: hmm...
17:05:56 <Eduard_Munteanu> It could be good, great or very bad.
17:05:57 <adnap> elliott: So... could you take a look at this and tell me how to fix it? http://ideone.com/9Xmoss
17:06:13 <jmcarthur> Eduard_Munteanu: well, sure, you have to be aware of the properties of whatever OS you're actually using
17:06:21 <acowley> ReinH: Yeah, I built the first few versions on an Extended numeric type I have in a few places
17:06:23 <jmcarthur> Eduard_Munteanu: under linux it is still considered cryptographically secure
17:06:48 <Eduard_Munteanu> jmcarthur: *if* there is enough entropy to begin with, and which /dev/random needs as well. :)
17:06:52 <adnap> /dev/urandom uses bits from /dev/random
17:07:11 <jmcarthur> Eduard_Munteanu: i think the reason this is so is precisely because it won't start producing anything until it has a good enough seed
17:07:23 <jmcarthur> Eduard_Munteanu: it just happens that usually it got a good seed long ago
17:07:29 <shachaf> elliott: Isn't exists a. f a ~~ f () for covariant f?
17:07:33 <Eduard_Munteanu> I thought it always produced something.
17:07:40 <Ghoul_> lambdabot is broken
17:07:44 <Ghoul_> :t uncurry
17:07:45 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:07:47 <benmachine> perhaps f a = a ~ a would not commute with forall
17:07:53 <Ghoul_> wait, nevermind.
17:07:59 <Eduard_Munteanu> But in any case, it certainly doesn't scale the pool size with how much you draw from it.
17:08:43 <shachaf> On the other hand (() -> R) is not the same as (exists a. a -> R)
17:08:45 <jmcarthur> shachaf: i'm trying to exemplify that with   data F a = F (a -> Int)  and am failing
17:08:53 <Eduard_Munteanu> So while a few bits of randomness would be enough for a few bytes of pseudorandom data, you can't really be sure if you're drawing GiBs from it.
17:08:57 <jmcarthur> yeah
17:08:59 <shachaf> jmcarthur: Exemplify which?
17:09:09 <jmcarthur> shachaf: exists a. f a ~~ f () for covariant
17:09:12 <jmcarthur> f
17:09:35 <shachaf> jmcarthur: Covariant or not, you can always go from (forall a. f a) to (f (forall a. a)), I assume.
17:09:40 <adnap> Eduard_Munteanu: It "doesn't scale the pool size"? I thought it did
17:09:42 <shachaf> Just by instantiating a = forall b. b
17:09:53 <jmcarthur> aqh
17:09:55 <jmcarthur> *ah
17:10:24 <jmcarthur> yeah, that makes sense. it may make sense that there is no dual for contravariant functors then
17:10:32 <jmcarthur> since the same applies to both
17:10:44 <Eduard_Munteanu> adnap: urandom never blocks AFAIK... therefore no matter how much you draw from it, it won't require more entropy. And that should follow even if it needs a starting entropy size.
17:10:45 <shachaf> How do you go from (f (forall a. a)) to (forall a. f a) in general?
17:10:52 <jmcarthur> but maybe there is one for exists
17:11:04 <jmcarthur> like that ^^ ?
17:11:06 <elliott> fmap absurd
17:11:12 <adnap> Eduard_Munteanu: I did not think either of those things were true.
17:11:17 <shachaf> "in general" meaning that you don't know that f is a functor.
17:11:59 <jmcarthur> for covariant functors, absurd works
17:12:02 <shachaf> jmcarthur: Well, if f is covariant, you can go from (f ()) to (exists a. f a) just by, uh, anti-instantiating, can't you?
17:12:11 <jmcarthur> maybe this is where for contravariant functors exists my come into play
17:12:19 <benmachine> (forall a. a) -> Void is inhabited, forall a. a -> Void is not
17:12:31 <Eduard_Munteanu> adnap: I'm pretty sure they're true... a lot of things use /dev/urandom precisely because "oh, my machine might not have enough entropy to install automatically"
17:12:32 <shachaf> And from (exists a. f a) to (f ()) by fmapping (const ())
17:12:41 <shachaf> So it looks like the same deal as forall, except backwards.
17:12:45 <Eduard_Munteanu> Stuff like cryptsetup.
17:12:51 <Eduard_Munteanu> Sort of disappointing.
17:12:57 <shachaf> benmachine: Right, that's what I said above.
17:13:06 <shachaf> benmachine: Er, no it isn't.
17:13:10 <shachaf> I said an equivalent for exists.
17:13:14 <benmachine> ok
17:13:15 <jmcarthur> shachaf: maybe the duality is clearer with   (exists a. f a) to (f (exists a. a))
17:13:22 <Eduard_Munteanu> If you can't get enough entropy when installing, maybe you should supply some.
17:13:43 * benmachine scroll a bit
17:13:52 <shachaf> jmcarthur: OK, what I said still works, doesn't it?
17:13:56 <jmcarthur> think so
17:14:06 <jmcarthur> for covariant f, of course
17:14:11 <shachaf> Yes.
17:15:08 * Eduard_Munteanu goes to bed
17:15:16 <shachaf> Maybe contravariant f, (exists a. f a) ~~ f (forall a. a) or something?
17:15:18 <acowley> ReinH: Here's some version of the type I was using before: https://github.com/acowley/DistanceTransform/blob/e4c32f0ea862802d9654dfc9a3ace4bf8a36970a/src/Extended.hs
17:16:13 <jmcarthur> hmm
17:16:19 <shachaf> (forall a. f a) ~~ f () when f is contravariant.
17:16:34 <shachaf> Using the same logic. In one direction you instantiate, in the other you contramap (const ())
17:17:24 <jmcarthur> (() -> A) -> (Void -> A) ... i guess that works...
17:17:35 <shachaf> And similarly for (exists a. f a) ~~ f Void: Anti-instantiate to go left, contramap absurd to go right.
17:18:14 <shachaf> So there you go. If it's contravariant it switches the initial and terminal objects.
17:18:19 <shachaf> Perfectly sensible.
17:18:29 <jmcarthur> yeah makes sense
17:18:45 <acowley> haddock is far better at using multiple cores than I had guessed
17:19:04 <shachaf> Is there a name for coinstantiation?
17:19:05 <ReinH> acowley: Extended is an applicative right?
17:19:22 <acowley> ReinH: Probably!
17:19:22 <shachaf> I bet sclv_ would say something about forgetful functors and what not.
17:19:47 <ReinH> where: pure = Finite; Finite f <*> Finite a = pure (f a)
17:20:22 <ReinH> acowley: that would make some things easier for you https://gist.github.com/reinh/8b858990b9dee67c6211#file-gistfile1-hs-L49-L55
17:20:50 <ReinH> maybe
17:20:59 <ReinH> NegInf makes it more complicated
17:21:00 <benmachine> well, Extended is isomorphic to Either Bool, right
17:21:14 <ReinH> benmachine: only if two lefts make a right!
17:21:14 <benmachine> if we ignore the !
17:21:18 <ReinH> I've been waiting forever to make that joke.
17:21:20 <acowley> ReinH: I stripped all that stuff out for the sake of adding speed holes to my station wagon
17:21:30 <jmcarthur> ReinH: haha
17:21:34 <ReinH> benmachine: see, because NegInf * NegInf = PosInf?
17:21:36 <ReinH> Come on.
17:21:44 <benmachine> ReinH: ...okay :P
17:21:56 <ReinH> that's the best it's going to get
17:22:04 * benmachine sees NegInf + PosInf = Finite 0 and cringes a bit
17:22:14 <arkeet> o_o
17:22:16 <ReinH> benmachine: yeah, I'm not sure that one is correct
17:22:17 <acowley> Huzzah for lack of principles!
17:22:20 <ReinH> but Tropical is fine
17:22:23 <ReinH> and we don't need NegInf
17:22:31 <acowley> I don't know why I have that
17:22:39 <benmachine> ReinH: it depends what exactly your standards for correctness are
17:22:52 <acowley> I guess I needed something.
17:22:55 <ReinH> benmachine: correct includes -inf + +inf /= 0
17:22:57 <ReinH> :)
17:23:01 <benmachine> :P
17:23:21 <fylwind> how do people set their upper bound on the build-depends version for various dependencies?
17:23:45 <benmachine> fylwind: tarot cards
17:23:51 <benmachine> "I see great changes in the future of containers"
17:23:55 <benmachine> "minor version upper bound"
17:23:56 <acowley> hahaha
17:24:18 <ReinH> acowley: use Tropical and the applicative instance will make things much easier for you :)
17:24:27 <ReinH> as will the semiring instance, probably
17:24:29 <acowley> I keep drawing the death card when depending on kmettage :(
17:24:36 <ReinH> lmao
17:24:42 <acowley> ReinH: Like I keep saying: all that nice stuff had to go
17:24:45 <benmachine> fylwind: more seriously, I usually do < x.(y+1) where x.y is the latest version, unless I'm using only bits I'm pretty sure are never going to change, in which case < (x+1)
17:24:52 <acowley> ReinH: It was fun, but it got in the way
17:25:05 <ReinH> acowley: you can just use Maybe
17:25:12 <ReinH> you won't get a num instance
17:25:13 <acowley> ReinH: This is bat country, where all your types must be represented by Ints
17:25:13 <ReinH> but who cares
17:25:19 <benmachine> I use the term "never going to change" loosely
17:25:19 <ReinH> wait
17:25:26 <fylwind> I see, though that still feels awfully conservative
17:25:31 <ReinH> you can get a Num a => Num (Maybe a) trivially right?
17:25:33 <acowley> fylwind: Don't use upper bounds
17:25:43 <acowley> fylwind: That's the other approach.
17:25:55 <benmachine> fylwind: eh, I have to edit my packages every few months
17:26:12 <fylwind> well I kinda wished there was like some kind of distinction between the x and y in "x.y"
17:26:15 <benmachine> fylwind: either it's trivial and doesn't take very long, or it's hard and a better upper bound wouldn't have helped
17:26:17 <acowley> The problem with upper bounds is that once they become necessary you have entered a period where nobody can use your package in conjunction with other packages.
17:26:54 <chrisdotcode> hello everyone
17:26:58 <fylwind> like it would be nice if the 2nd number stood for "backwards compatible" or something
17:27:01 <ReinH> acowley: you need to be able to say if this is infinity then it stays infinity, otherwise it becomes the min of these two things
17:27:11 <benmachine> fylwind: http://www.haskell.org/haskellwiki/PVP
17:27:13 <ReinH> acowley: which you can totally do with an applicative tropical semiring :D
17:27:16 <acowley> If you have a standalone thing, then upper bounds mean future haskellers can gaze upon your majesty
17:27:23 <ReinH> I don't know how you would do that with just ints
17:27:31 <acowley> ReinH: It's already there in that code
17:27:34 <acowley> ReinH: reserve a bit
17:27:39 <ReinH> right
17:27:42 <benmachine> acowley: I don't get what you mean re: using packages in conjuction with other packages
17:27:57 <fylwind> benmachine: yeah I looked at that; it didn't say anything about the x vs y part though
17:28:01 <ReinH> acowley: well, alrighty then :D
17:28:07 <acowley> benmachine: I mean that if I only work with versions of lens < 1.2, then my package is going to be hard to use with more modern things
17:28:11 <ReinH> I'm trying to figure out what's wrong with my parallelization
17:28:22 <benmachine> acowley: yes but if you wrote your package a year ago, it's going to be hard to use with modern things
17:28:29 <acowley> benmachine: True!
17:28:36 <benmachine> acowley: the only difference is whether your failure is configure-time or compile-time :P
17:28:38 <ReinH> if I compile with -threaded and run with -N4 but the RTS -s out put says "using -N1"
17:28:45 <ReinH> what does that mean?
17:28:52 <benmachine> acowley: but sure, if you don't think you'll be around in a year, you might want to put generous upper bounds in
17:29:19 <acowley> benmachine: Yeah, but I also like to be optimistic. In a year, if my stuff works, great. If I put a restrictive upper bounds on its dependencies, nobody will even try to use it.
17:29:20 <benmachine> acowley: but I think the chances of a substantial package written today compiling with base-5 are pretty low
17:29:40 <benmachine> acowley: that's not true, they will just edit your cabal file :P
17:29:46 <benmachine> acowley: they might even send a pull request!
17:30:14 <ReinH> it means there's nothing to parallelize, right?
17:30:16 <acowley> benmachine: Well, I know I've skipped past packages whose upper bounds are too restrictive. I've certainly edited a lot, too, but if there are alternatives I chose the easy route
17:30:29 <benmachine> fylwind: isn't the whole point of the PVP the x vs. y thing, or do I misunderstand what you mean
17:30:53 <fylwind> PVP was discussing x.y vs z ( in "x.y.z")
17:30:57 <benmachine> acowley: meanwhile I've had a headache downloading and trying to compile packages that don't specify bounds, trying to work out what they were designed to be used with
17:31:02 <acowley> benmachine: x.y are both major version components
17:31:09 <benmachine> fylwind: ah, I see what you mean
17:31:12 <acowley> benmachine: I know, there's no free lunch here
17:31:40 <acowley> benmachine: But I do think lots of dependencies will bump majors without breaking your code
17:32:00 <benmachine> "bump majors" sounds like a euphemism for something
17:32:23 <benmachine> acowley: yeah, okay, but I think that only calls for subtlety in you upper bounds, not none at all
17:32:37 <benmachine> acowley: hence I often write base < 5 instead of base < 4.8 or whatever we're on now
17:32:46 <benmachine> if I'm only using a few things that I think are pretty static
17:33:07 <benmachine> but then someone's going to finally agree with me that hierarchical modules are crap and restructure EVERYTHING for base-5
17:33:18 <acowley> Yes, I like to make Haskell seem edgy through apparent innuendo that masks mind-numbingly boring technical details.
17:33:35 <benmachine> and that's going to be 20 years in the future so it's no real stretch to put the constraint in
17:34:12 <napping> version numbers are never going to solve the problem of deciding whether a change that isn't backwards compatible is going to break a particular client
17:34:34 <k0001_> cabal install cabal-install Cabal… What kind of magic spell is this?
17:34:44 <benmachine> napping: they can make it easier, though
17:34:52 <acowley> I too enjoy subtlety in my package configuration
17:36:10 <napping> Perhaps there would be some use for a further tier which is backwards compatible except for deleting things
17:36:14 <acowley> Soon we'll have CI servers running our automated test suites and emailing us with version bound relaxation suggestions and everything will be wonderful
17:36:23 <ddinh> Is there any difference between Text.ParserCombinators.Parsec and Text.Parsec?
17:37:07 <napping> the guarantee being that if your code still compiles at all with the greater version it will work the same
17:37:46 <napping> beyond that I can think only of breaking out the theorem prover, and documenting the properties you require of all imported functions
17:37:56 <acowley> I keep getting cabal into a state where it says "unrecognized option `--list-sources=cabal-sdist-list-sources'"
17:38:04 <benmachine> ddinh: the longer modules are what it was called in parsec-2, I think the shorter names are new in parsec-3
17:38:05 <acowley> It's always due to use of add-sources
17:38:11 <napping> and a big public repostiory where everyone can contribute lemmas about every existing version
17:38:13 <benmachine> ddinh: I forget whether or not this has any bearing on the APIs
17:39:46 <benmachine> ddinh: I think basically the short version is that Text.Parsec is better, so use that
17:39:55 <benmachine> ddinh: but I might be wrong
17:40:38 <benmachine> acowley: btw it looks like NegInf * (-1) = NegInf
17:40:53 <acowley> benmachine: :(
17:41:07 <acowley> benmachine: The good news is that code is no longer in the repository
17:41:16 <benmachine> ah, okay :)
17:41:44 <benmachine> I'm not sure how it got in my browser window in the first place
17:41:52 <acowley> I was digging up old versions to show that I did indeed start life with an aim to use real data types
17:41:53 <benmachine> I tend to see a link and then click the link
17:41:57 <benmachine> with obvious exceptions
17:42:04 <acowley> benmachine: are you new to the internet?
17:42:05 <acowley> :P
17:42:19 <haasn> ddinh: http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-ParserCombinators-Parsec.html mentions it's a ‘compatibility module’
17:42:29 <haasn> it seems to be there just for backwards compatibility
17:42:30 <benmachine> acowley: :P no, just very sheltered
17:43:52 <enthropy> @type partitionEithers
17:43:53 <lambdabot> [Either a b] -> ([a], [b])
17:44:29 <acowley> argh, this cabal-install bug is killing me. But every time I encounter it, it's in some ridiculously big project.
17:44:36 <enthropy> @type \xs -> let (a, partitionEithers -> (b,c)) = partitionEithers xs in (a,b,c
17:44:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:44:44 <enthropy> @type \xs -> let (a, partitionEithers -> (b,c)) = partitionEithers xs in (a,b,c)
17:44:45 <lambdabot> [Either a1 (Either a b)] -> ([a1], [a], [b])
17:44:56 <enthropy> is there such a thing in general?
17:45:16 <hpc> enthropy: for repeated nesting of Either, or infinite nesting of Either?
17:45:29 <enthropy> repeated Either, it ends somewhere
17:45:42 <hpc> that's gonna be ugly typeclass stuff, most likely
17:46:24 <hpc> and... well infinite actually wouldn't work afaik :(
17:47:05 <enthropy> transpose is kindof close
17:49:55 <edwardk> :t Control.Lens.transposeOf
17:49:56 <lambdabot> LensLike ZipList s t [a] a -> s -> [t]
17:50:49 <edwardk> enthropy: what are you trying to do? splitEithers?
17:51:04 <augur_> oh btw, erisco, you could probably automate a lot of that stuff using TH
17:51:11 <edwardk> :t Data.Either.partitionEithers
17:51:12 <lambdabot> [Either a b] -> ([a], [b])
17:52:18 <enthropy> edwardk: putting elements of a list into separate lists based on some calculation
17:53:03 <haasn> :t partition -- isn't that what this does?
17:53:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:53:17 <enthropy> yeah but Bool only does 2
17:53:18 <haasn> or do you mean (a -> Int) -> [a] -> [[a]] -- or something like that
17:53:40 <enthropy> closer to the latter
17:53:40 <acowley> edwardk: Any objections to me updating Linear.Matrix.translation to a Lens'? It's ugly code, but *shrug*
17:57:26 <edwardk> go for it
17:58:34 <ddinh> thanks benmachine
17:59:04 <acowley> 'tis done
17:59:06 <adnap> Trying again...
17:59:23 <adnap> Can someone explain why this doesn't work, and how to fix it? http://ideone.com/9Xmoss
18:01:18 <geekosaur> isn't that the ST vs. (.) (and formerly ($)) problem? (I think ($) is only special cased for runST?)
18:01:24 <levi> So with the new cabal, what's the story with regard to executable tools?  Does one just add each sandbox binary directory to PATH, or is there some way to install the hermetically-built binaries user- or system-wide?
18:15:55 <bbloom> I've heard that GHC has an intermediate language that is a typed lambda calculus variant. What's it called and where can I learn more about it and the rest of GHC's internals?
18:16:12 <edwardk> Core
18:16:29 <bbloom> http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType ?
18:17:04 <bbloom> Thanks.
18:17:35 <edwardk> yep
18:17:45 <shelf> is it better to use cabal-dev most of the time, or to frequently purge your .cabal dir?
18:17:46 <edwardk> you may also want to read up on the spineless tagless g-machine
18:17:48 <wolf1oo> what's the default start code in an alex file?
18:17:48 <shelf> s/better/more common/
18:18:10 <edwardk> but that whole code commentary is probably the best place to explore ghc's internals
18:18:30 <bbloom> edwardk: excellent. found SPJ's paper on spineless/tagless. thanks!
18:19:02 <benmachine> shelf: I do neither
18:19:12 <edwardk> bbloom: also look for dynamic pointer tagging
18:19:16 <enthropy> adnap: http://lpaste.net/92577
18:19:30 <benmachine> shelf: I think you can mostly get by by running --dry-run before you install anything, and rejecting any installs that look fishy
18:19:42 <bbloom> edwardk: this is a good entry point. i'll do a beam search over references from here. thanks again
18:19:45 <edwardk> bbloom: the best overview i know for the internals of ghc's evaluator actually comes from rob ennals' thesis which was on making serious changes in the way the STG gets evaluated
18:19:59 <edwardk> bbloom: so he had to cover in unusual depth all the ins and outs of the existing STG evaluator
18:20:11 <benmachine> shelf: although often I don't even bother with that, maybe I'm just lucky
18:20:26 <edwardk> bbloom: http://ennals.org/rob/archive/intel/pubs/thesis.pdf
18:20:30 <bbloom> edwardk: i'm mostly interested in the compiler, not the runtime (at least right now) but i'll add that to the queue too
18:20:37 <edwardk> bbloom: i recommend that to anyone who is serious about exploring the STG
18:21:01 <shelf> ah okay. since i don't run anything productive and just hack, i'm going to purge, and see what breaks
18:21:26 <shelf> cabal-dev seems like a better solution though
18:21:39 <shelf> most of these libraries i install for a single program
18:21:47 <edwardk> bbloom: you'll also want to look at the system Fc papers, if you care about the modern GHC typechecker
18:22:23 <edwardk> OutSideIn(X) is another good entry point
18:27:02 <adnap> enthropy: What the--
18:28:47 <benmachine> shelf: there has just recently been a new cabal-install release which supports some sandboxing not unlike what cabal-dev does
18:29:16 <enthropy> adnap: so far there's no sign that you should use RankNTypes there
18:29:42 <enthropy> if you dropped the type signature on g, you could have things compile without the `apply'
18:30:17 <applicative> someone should put the news about cabal-install in the header news for the channel, whatever its called
18:30:17 <adnap> enthropy: "g :: (forall a. F a b) -> Bool" gives "Illegal symbol '.' in type" without RankNTypes
18:30:46 <adnap> applicative: It's called the "topic"
18:31:14 <applicative> Topic: 'cabal-install-1.18 released: now with cabal sandbox and cabal repl"
18:31:28 <enthropy> adnap: what about that?
18:31:31 <applicative> topic, yes, it goes by so fast irssi I never see it any more
18:31:43 <lightquake> in the void package, absurd :: Void -> a is defined as absurd a = a `seq` spin a where spin (Void b) = spin b
18:31:43 <adnap> enthropy: Oh, I see. Well, this is just an abstraction of a problem I'm having with a library.
18:31:56 <lightquake> why isn't it just a `seq` x where x = x or something similar?
18:31:56 <adnap> enthropy: I will see if I can use this information to fix the real problem.
18:33:25 <adnap> enthropy: "That" was "about" your statement: "there's no sign that you should use RankNTypes there"
18:33:51 <applicative> with the new cabal sandbox you can have your own personal cabal hell in every subdirectory of $HOME/myhaskell
18:34:10 <enthropy> adnap: I see what you meant
18:34:30 <shelf> oh my
18:35:00 <applicative> shelf: but then you just do 'cabal sandbox delete' and start over ;)
18:35:19 <applicative> shelf: in any case its actually much less likely
18:36:35 <benmachine> lightquake: void is an edwardk package, so there is probably dark magic involved, possibly to do with how well it optimises or something
18:36:39 <dmwit> lightquake: Possibly to trick the compiler into *not* turning it into an exception.
18:37:24 <lightquake> benmachine: when I saw the version number, I was wondering how you could possibly have six different versions of an uninhabited type
18:37:34 <benmachine> lightquake: :P
18:37:55 <benmachine> lightquake: there have been many more releases than that, actually
18:38:00 <applicative> the type changes completely with every version of void
18:38:02 <benmachine> but perhaps most of them were just twiddling metadata
18:38:12 * hackagebot concurrent-supply 0.1.7 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.7 (EdwardKmett)
18:38:17 <dmwit> lightquake: That is, if the thing after the seq is an exception, GHC has a choice of which exception to throw (because we know that first guy is an exception, right? =). So making the thing after the seq an infinite loop ensures that if any exception gets thrown it's from the Void, not <<loop>>.
18:39:01 <edwardk> lightquake: i've been meaning to write an article about 'the care and feeding of the simplest package possible' to showcase just how many corner cases need to be dealt with in a package, even one that simple
18:39:36 <edwardk> dmwit gets the million dollar prize for the right explanation
18:39:42 <adnap> lightquake: Such a cool nick XD
18:39:43 <dmwit> yaaaaay
18:40:06 <lightquake> dmwit: wait, in a `seq` b, GHC can throw the b exception?
18:40:13 <dmwit> lightquake: right!
18:40:31 <benmachine> lightquake: a `seq` b doesn't provide many promises at all
18:40:45 <dmwit> lightquake: You might like my SO question...
18:40:56 <benmachine> lightquake: if GHC can statically prove that b is bottom or a isn't, it doesn't need to evaluate a at all
18:40:59 <dmwit> http://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
18:41:04 <lightquake> I thought the point of Void was that any Haskell term of type Void would throw an exception when evaluated to WHNF
18:41:12 <dmwit> or loop
18:41:26 <dmwit> lightquake: Read the answers to that question, I promise they'll be enlightening. =)
18:41:36 <lightquake> ah, got it
18:42:28 <lightquake> dmwit: it is indeed
18:44:07 <benmachine> lightquake: sure, but which exception?
18:44:22 <benmachine> lightquake: or also, it might just infinite-loop
18:44:32 <shelf> cabal sandboxes are sweet. glad i asked you guys before disappearing down the galois-hole
18:44:38 <lightquake> benmachine: also true
18:45:58 <lightquake> this has been helpful, ty :)
18:49:33 <erisco> augur_, you mean the unrepresented stuff?
18:50:12 <augur_> erisco: the abstract stuff
18:50:29 <erisco> yes
18:50:40 <erisco> I do feel the convenience is merely a language problem
18:50:58 <erisco> but I am focused on my parsing work for a while
18:51:02 <erisco> need to put it to bed first
18:57:52 <hpaste> arkeet pasted “??” at http://lpaste.net/4420813729013170176
18:58:04 <arkeet> oops.
18:58:51 <dmwit> That is a big number.
18:59:06 <dmwit> Have we just had a massive influx of lpaste-based questions or did lpaste switch its numbering scheme?
18:59:22 <applicative> private pastes have big numbers
18:59:30 <applicative> i found out the other day
18:59:42 <edwardk> dmwit: it has to do if its public or not
18:59:46 <dmwit> I see.
19:00:00 <dmwit> Allowing announcements of private pastes seems like a misfeature.
19:01:15 <edwardk> well, depends on if you have unlogged channels
19:01:22 <edwardk> e.g. #haskell-lens is unlogged
19:01:29 <edwardk> so a private paste there avoids it showing up in browse
19:01:41 <edwardk> but still lets it be said to the channel for recaps and what not
19:02:17 <edwardk> IOW - i use the feature ;)
19:02:32 * dmwit demands more psychic pain for edwardk
19:03:09 <dmwit> Hm, psychic seems like the wrong word now that I've looked it up.
19:04:25 <benmachine> dmwit: anyway, it's probably a bad idea to think of private pastes as super secure
19:05:34 <arkeet> it saves me the hassle of linking the paste in the channel myself.
19:05:42 <arkeet> unfortunately, sometimes I tell it to go to the wrong channel.
19:05:56 <dmwit> Although I didn't say it, one person disagreeing with me was enough to change my mind. Three is overkill. =)
19:05:58 <arkeet> that one was meant for -blah.
19:06:20 <arkeet> =)
19:18:20 * hackagebot hexpat-lens 0.0.2 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.0.2 (JosephAbrahamson)
19:19:10 <saulzar> Trying out cabal 1.18 ... ran into an issue (http://trac.haskell.org/gtk2hs/ticket/1277) where the workaround was to put an upper bound on the cabal version... so I look at the cabal-docs and it says upper bounds on the cabal version are ignored, anyone know what they're talking about then?
19:20:30 <applicative> saulzar: do you already have a cabal? this seems to be a defect of bootstrap.hs, not 'cabal install cabal-install' or am i wrong?
19:21:18 <applicative> saulzar: in any case if you git clone https://github.com/haskell/cabal the patch has been applied
19:22:06 <applicative> saulzar: or vary what you have thusly https://github.com/haskell/cabal/commit/03d12e643eb843b3b22dc90af7992c5945fafdbb
19:23:33 <Ghoul_> k0001_: would you welcome a pull request for direct handle serializing in pipes-network as a submodule or something?
19:24:08 <saulzar> Oh, no trouble installing cabal - but the issue is with the glib library Setup.hs script where the API has changed
19:25:32 <Ghoul_> k0001_: gotta pop out. /query me a response if you make one, thanks.
19:26:12 <saulzar> cabal-1.18 itself installed without a hitch (from existing cabal, I didn't need to bootstrap it)
19:27:17 <applicative> yes, i was missing a crucial fragment of your question.
19:28:20 * hackagebot webserver 0.7.1.1 - HTTP server library  http://hackage.haskell.org/package/webserver-0.7.1.1 (JohnLato)
19:28:33 <Ankhers> has anyone has success updating to cabal 1.18.0 on OSX 10.9?
19:30:09 <applicative> yes
19:30:57 <applicative> Ankhers: did the build fail?
19:31:58 <Ankhers> applicative: It did, failed on "invalid preprocessing directive"
19:32:40 <applicative> grrr
19:32:55 <applicative> Ankhers: but you have been able to install other stuff with your existing cabal?
19:33:04 <tinyghost> Ankhers I'm updating it right now, I'll tell you if it succeeds
19:34:02 <Ankhers> applicative: To be honest, I just reinstalled the platform because I thought I messed something up. Previously, however, I was able to install packages.
19:34:15 <shelf> oh god, i ended up with cabal hell anyway
19:34:29 <shelf> rejecting: hashable-1.2.0.10/installed-c87... (conflict:
19:34:29 <shelf> bytestring==0.10.0.2/installed-13b..., hashable =>
19:34:30 <shelf> bytestring==0.9.2.1/installed-004...)
19:34:43 <shelf> bytestring, every time
19:34:53 <applicative> what version of ghc are you using shelf
19:35:03 <applicative> man it's a cabal inferno in here
19:35:25 <monochrom> you have too many bytestrings. it is a usual cause of problems.
19:35:44 <applicative> yes but hashable shouldn't need bytestring 0.9
19:35:56 <shelf> i just nuked everything :> and then a simple dependencies rebuild ended up with two bytestrings again.
19:35:59 <shelf> hah.
19:36:06 <applicative> shelf: what ghc do you have though
19:36:06 <shelf> i'm still on 7.4.2
19:36:15 <applicative> ah you must get rid of it
19:36:37 <applicative> it comes with bytestring 0.9 and it will just be chronic pain
19:37:07 <shelf> oh, is that the source of my worries.
19:37:22 <shelf> thanks, i'll nuke the whole thing and reinstall hp
19:37:31 <applicative> shelf: what platform are you on?
19:37:37 <monochrom> next time you start clean, consider my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown to keep it clean for long time
19:37:45 <shelf> OS X, i installed haskell platform in perhaps January
19:38:00 <applicative> oh okay, yes there's a new platform version.
19:38:03 <shelf> haven't touched it since then, i didn't realise they'd updated.
19:38:35 <applicative> you can also use the os x distribution on the ghc page, i do that sort of following another of monochroms helper pages
19:38:37 * shelf searches for a mailing list
19:39:02 <applicative> its not that old the new hp, but after january
19:39:11 <applicative> the previous hp was a bit long in the tooth
19:39:51 <imm33> hi
19:40:06 <applicative> hi imm33
19:40:20 <dmwit> 1. understand Cabal 2. cabal-install is now 20% cooler
19:40:48 <shelf> is the homebrew hp install any different from the .pkg these days?
19:41:05 <applicative> dmwit: saulzar was just asking a question about Cabal and gtk2hsbuildtools
19:41:13 <monochrom> "understand Cabal" is a life-long career
19:41:19 <dmwit> applicative: Oh?
19:41:22 <dmwit> saulzar: ping
19:41:56 <applicative> i left him the lurch investigating but he had bumped into http://trac.haskell.org/gtk2hs/ticket/1277, which you closed
19:42:01 <shelf> would you say this still sums up the 'dream' solution for future-cabal? http://blog.johantibell.com/2012/03/cabal-of-my-dreams.html
19:42:16 <monochrom> no
19:42:17 <dmwit> saulzar: Use gtk2hs from darcs.
19:42:27 <dmwit> applicative: fixed in HEAD, kthx
19:42:35 <applicative> hah
19:43:22 <dmwit> I guess the release of 1.18 probably makes it just that much more important to get a gtk release out the door.
19:43:30 <monochrom> my dream consists of only one feature. it's very simple. default to refusing multiple versions.
19:43:38 <saulzar> dmwit: Cool - was just doing that now. Cheers :)
19:43:44 <monochrom> that solves all cabal hell.
19:43:52 <shelf> heh
19:44:04 <applicative> saulzar: oh good.
19:44:15 <dmwit> monochrom: That seems like it just makes the failure happen earlier.
19:44:16 <shelf> that'd kick those library devs into line, eh
19:44:21 <monochrom> a command line option re-enables multiple versions. sure.
19:44:31 <dmwit> I don't object to failing early when it's possible, but handling more situations is good too. =)
19:44:48 <shelf> in my < 1 year of using haskell, i've seen interfaces broken between releases... quite a few times
19:45:19 <benmachine> monochrom: seems like your feature wouldn't be very hard to implement
19:45:19 <dmwit> My dream is for the "version" of each package to include its hash.
19:45:33 <benmachine> monochrom: it's basically an 'installed' constraint for every... installed package, right?
19:45:39 <monochrom> the point is you must be awake and sign your name and you must be at least 18 years old to explicitly request for multiple versions because you need to know you're getting them.
19:46:23 <MrRacoon> ~~>
19:46:26 <applicative> Ankhers: yes, i just installed it the orthodox way on os x. i'm worried about the preprocessor business.
19:47:00 <Ankhers> applicative: Are you on 10.9 or 10.8 though?
19:47:16 <applicative> oh, 10.8
19:47:16 <Ankhers> I don't really expect most things to work on 10.9 yet.
19:48:08 <applicative> Ankhers: I dont have real information but there is an uptick in preprocessor problems on os x. i thought it was a new xcode but maybe its all 10.9 related
19:48:52 <saulzar> dmwit: Hmm. There's also a "Ambiguous occurrence `moreRecentFile'"  - seems it's been added to cabal and simply commenting it out of SetupWrapper.hs works
19:48:56 <applicative> the problem -- whatever is at the root of it -- is that when ghc asks for cpp it gets the clang cpp which goes wrong.
19:49:43 <dmwit> saulzar: Okay, glad you fixed it. Interested in drawing up a patch and sending it to the mailing list?
19:50:22 <geekosaur> 10.9 requires the new xcode
19:50:27 <saulzar> I guess it needs an #ifdef  for cabal version number?
19:50:38 <geekosaur> the new xcode has no gcc, and clang's preprocessoe enforces C
19:50:42 <applicative> ah, so the theories are consistent
19:51:03 <dmwit> I vaguely recall that it's not really possible to use CPP for that particular file, so it's better if you can find a way not to use #ifdef.
19:51:12 <dmwit> I don't remember the details of why, though.
19:51:19 <applicative> does one get a different gcc then? or are we just without hope geekosaur?
19:51:43 <dmwit> Or maybe CPP is okay, but there's no macro defined for the cabal version number.
19:51:44 <saulzar> Maybe rename it to something else? Or perhaps use hiding on the one from Cabal...
19:51:46 <dmwit> That sounds more likely
19:52:01 <geekosaur> it's possible to use clang to build gcc, and ship the cpp from that, if we really must go that way
19:52:05 <dmwit> saulzar: Yeah, import hiding seems more likely to work on both old and new cabals.
19:52:25 <applicative> i got my os x gcc from some little command line tools bundle but i guess that doesn't exist or doesnt have a real gcc for 10.9?
19:52:41 <geekosaur> doesn;t have a real gcc
19:52:49 <applicative> grrrr
19:52:53 <geekosaur> apple's ditching gcc entirely
19:52:58 <dmwit> import Foo hiding (foo) is not an assertion that Foo exports foo, which is good.
19:53:33 <applicative> this must be a problem for other languages too?
19:54:01 <dmwit> applicative, geekosaur: Oh, hang on.
19:54:18 <geekosaur> not really; using cpp for anything oter than c/c++ has been deprecated for a very long time, and most other languages don;t use it
19:54:34 <geekosaur> (perl *can* but it's not default and has been strongly deprecated for years, for example)
19:54:53 <applicative> oh i see, we are following unbest practices anyway
19:54:59 <dmwit> applicative, geekosaur: From elsewhere, install cpphs and use cabal install --ghc-options="-pgmPcpphs -optP--cpp"
19:55:12 <geekosaur> yes, but people are afraid of cpphs's license
19:55:13 <dmwit> (Didn't follow the whole conversation, so if this is not relevant, apologies.)
19:55:18 <dmwit> geekosaur: okay
19:55:22 <applicative> dmwit: yes that's geekosaur 's other solution
19:55:24 <geekosaur> we've had that discussion to death and back
19:55:37 <dmwit> Okay, sorry for re-covering that ground, then.
19:55:51 <applicative> geekosaur: it's just a question of what to tell people here for particular disasters. so dmwit 's remark is to the point
19:56:29 <applicative> haskell platform doesnt come with cpphs
19:57:02 <applicative> so Ankers try 'cabal install cpphs' then 'cabal install --ghc-options="-pgmPcpphs -optP--cpp  cabal-install '
19:57:14 <saulzar> So I can make changes, and use darcs send to bundle it up, email to mailing list - is that the correct procedure?
19:57:16 <applicative> throw in a few prayers
19:57:17 <geekosaur> I still think it's the best solution since cpp never generates code, at most it generates line annotations based on the original files, so can't possibly infect what it's run on.
19:57:31 <dmwit> saulzar: make changes, darcs record, darcs send
19:57:43 <dmwit> saulzar: If you don't have an SMTP server running on your box, darcs send -o foo.dpatch
19:57:45 <geekosaur> but omg gnu license panic panic avoid terror aieeeeeee
19:58:01 <geekosaur> (which is more or less what apple's doing that triggered this whole mess...)
19:58:04 <saulzar> dmwit: Yep - that's what I'm thinking. Thanks :)
19:58:16 <applicative> if github is worth a half billion dollar how come they don't support darcs and n other systems?
19:58:29 <dmwit> saulzar: Thanks!
19:59:20 <applicative> I wonder what would happen if i put those options for ghc in my cabal/conf, or does it have a suitable field?
19:59:25 <Ankhers> applicative: wouldn't they need to change their name if that were the case?
19:59:54 <saulzar> dmwit: Hm, seems there's a few more..
20:00:37 <leroux> applicative: They support a few other systems than git.
20:01:02 <applicative> leroux: oh do they, just not darcs?
20:01:21 <saulzar> dmwit: `programFindLocation'  it seems has a new argument
20:01:24 <leroux> Yeah. =) They have svn and hg.
20:01:44 <lightquake> leroux: are you sure?
20:01:49 <leroux> lightquake: I think so.
20:01:57 <leroux> http://hg-git.github.io/
20:02:02 <applicative> certainly hg/git interoperation is pretty advanced
20:02:10 <leroux> https://github.com/blog/626-announcing-svn-support
20:02:16 <lightquake> that's not supporting git, that's just hg-git interop
20:02:19 <leroux> Ahh.
20:02:22 <lightquake> er, supporting hg
20:02:23 <applicative> yes.
20:02:27 <leroux> I think all of them are interop.
20:02:57 <leroux> Too bad DarcsGit is dead (according to the site).
20:03:06 <dmwit> saulzar: *sigh*
20:03:07 <leroux> Or rather, it's broken.
20:03:16 <Ankhers> applicative: Still no luck on updating cabal
20:03:28 <applicative> actually that wouldn't be so bad, if people who don't want to figure out darcs but understand git and github could e.g. interact not too helplessly with gtk2hs for example
20:03:57 <saulzar> (or one removed..)  - I'm not sure what you can do about that without #ifdef
20:03:59 <leroux> Ankhers: Upgrading to 1.18?
20:04:08 <Ankhers> leroux: Indeed.
20:04:12 <leroux> I couldn't upgrade either.
20:04:16 <leroux> What errors were you getting
20:04:42 <Ankhers> preprocessor directive. I'm on OSX 10.9 though, so I don't really expect things to work at the moment.
20:04:48 <leroux> That's weird. It's working now.
20:04:59 <applicative> leroux: are you on os x 10.9?
20:05:04 <leroux> No.
20:05:28 <applicative> ah ok, it was a different problem from the one Ankhers is having.
20:05:30 <applicative> grrrr
20:05:31 <dmwit> saulzar: If you're up for it, I recommend putting together a patch with *just* the changes you need to make to get gtk2hs working with 1.18.
20:05:46 <dmwit> saulzar: Let some poor maintainer sap deal with back-compat.
20:06:08 <applicative> this suggests that somewhere in cabal/Cabal there is something cpphs cant handle?
20:06:17 <dmwit> saulzar: And know that already pointing out what changes are needed for 1.18 is a huge help to the poor maintainer sap you're sticking with the rest of the work. ;-)
20:06:22 <applicative> Ankhers: you gave it the directive dmwit mentioned above?
20:06:22 <leroux> Ahh, I know why. I was in my ghc build tree (and it picks my built binary instead of system ghc).
20:06:54 <Ankhers> applicative: I did what you mentioned suggested 'cabal install --ghc-options="-pgmPcpphs -optP--cpp" cabal-install'.
20:07:06 <Ankhers> after installing cpphs
20:07:07 <applicative> did you install cpphs first?
20:07:10 <applicative> damn
20:07:27 <dmwit> Ankhers: And just to check: ~/.cabal/bin (or wherever your installs go) is in your PATH, right?
20:07:33 <applicative> is your new haskell platform .cabal bin in path?
20:07:50 <applicative> if you do 'which cpphs' or whatever it shows up?
20:07:58 <saulzar> dmwit: Alright, I'll do that
20:08:40 <Ankhers> both ~/.cabal/bin and ~/Library/Haskell/bin are in my PATH
20:09:03 <dmwit> dang
20:09:16 <applicative> :(
20:09:51 <applicative> Ankhers: what was the complaint at the moment of breakage, maybe you should add verbose=3 or something
20:10:36 <Ankhers> One sec, installing again with verbose=3
20:10:44 <applicative> --verbose=3 rather
20:11:03 <Ankhers> aye
20:11:08 <applicative> hahah
20:11:19 <dpwright> If I have haskell code stored in a string -- an entire module's worth, say, the equivalent of what would usually be in a file but stored in a string, not a file -- can I use the GHC packages to interpret it without having to write it out to a file and load that in interpreted mode?
20:11:19 <applicative> it's just the last paragraph that's likely to useful....
20:12:33 <dpwright> I've been looking through the haddocks, but there's quite a lot there and so far I haven't found anything... just wondered if anyone who knows the libraries better could point me in the right direction
20:12:43 <applicative> dpwright: what, ghc -e "putChar 'a'" isn't good enough?
20:12:51 <bqp> ls
20:13:22 <Ankhers> applicative: So this kinda scares me... I successfully installed when using --verbose=3... lol
20:13:33 <dpwright> applicative: This string is in an application that is running on a device without ghc installed
20:13:46 <dpwright> and without the ability to load/save files from the filesystem
20:14:25 <geekosaur> that sounds like a lose to me
20:14:25 <applicative> but it will generate the module/string and send it elsewhere?
20:14:38 <applicative> oh good work Ankhers
20:15:20 <dpwright> I'm hoping (I'm not sure if this is possible) that I could, yeah, read in a string, and interpret/run the resulting code
20:15:27 <Ankhers> Well, thanks for the help nonetheless.
20:15:59 <applicative> well, good luck with 'cabal sandbox init' Ankhers
20:17:38 <dpwright> and, if possible, generate a module and store that for use by other interpreted strings
20:18:26 <dpwright> another alternative would be if I could somehow "fake" a filesystem by rewriting functions like FD.openFile, but that seems like it would be a lot of work...
20:18:29 <applicative> but there isnt another machine with the whole real ghc involved?
20:19:31 <dpwright> applicative: That's correct.  I was hoping I would be able to embed the ghc functionality by importing the GHC packages into my application
20:20:20 <applicative> does hint involve everything; i don't know anything about it, really
20:21:24 <dpwright> I took a look at hint -- it seems to wrap the standard GHC packages to make them easier to use.  It looks nice, but it also expects to be able to read things from the filesystem by the looks of things... maybe I'll take another look
20:21:37 <startling> why doesn't haskell favor more specific paterns over less specific ones?
20:21:51 <benmachine> startling: because that's not a total order
20:22:09 <benmachine> startling: which would you prefer out of Left [] or Right (x:xs)?
20:22:23 <geekosaur> dpwright, ghc-api may well expect to be able to use e.g. temporary files
20:22:40 <geekosaur> and in particular it will want to load interface files and libraries for modules
20:22:42 <startling> benmachine, you can just pick one arbitrarily -- as written, for example. It doesn't matter since something will never match both Left _ and Right _.
20:22:54 <geekosaur> so you need to be able to load files, if nothing else
20:22:57 <benmachine> startling: ok, what about (True, _) and (_, False)
20:23:28 <startling> Maybe that should be a warning.
20:23:39 <benmachine> warning or not, it's still got to *do* something
20:24:06 <startling> falling back to the order as written seems reasonable.
20:24:06 <dpwright> geekosaur: Yeah, it's in module loading that I thought I might get tripped up.  hint *does* let me interpret arbitrary strings, but as soon as I tried to load a module or anything of course it would need access to the filesystem
20:24:17 <benmachine> startling: another question would be, why not just write them in the order you want in the first place?
20:24:41 <geekosaur> I am surprised it doesn't fail pretty much immediately... it needs to load Prelude!
20:24:53 <applicative> but that seems a really superficial matter, i wonder why ghc api and thus hint insist on it
20:25:16 <benmachine> applicative: probably because it's almost always available :P
20:25:20 <dpwright> geekosaur: Sorry, when I say "hint lets me" what I mean is "it is in the api" -- I haven't actually tried running hint on the device yet!
20:25:28 <dpwright> so quite possible it doesn't work at all
20:25:38 <benmachine> well, in fairness it might be because you almost always want to access the base package which you probably don't even have source for
20:25:59 <startling> benmachine, Hope had the "more specific things match first" rule, and Hope invented pattern-matching. Haskell is the one that changed things; I'm wondering why.
20:26:01 <applicative> benmachine: of course, still they make a lot of things possible that would never cross my mind
20:26:26 <geekosaur> yeh, I would expect it to fail right out the gate (hence my "sounds like a lose" earlier; I cannot imagine it working, given that it's actually doing what ghc does and ghc requires all these files)
20:26:42 <benmachine> startling: oh, I don't know why that decision was originally made, seems things are simpler this way though and just as expressive
20:27:33 <startling> I guess I should have been more clear.
20:27:47 <sellout-> startling: I think the tradeoff is that you need to create arbitrary rules to make that a total order, which means more rote memorization. I’m not at all familiar with Hope, though.
20:28:16 <dpwright> geekosaur: Yeah... alright, thanks.  I was starting to get that impression myself.  I guess my only options are to fake the filesystem in some way (it's just a mapping from filename strings to content strings, amiright?!), or rethink what I'm doing
20:28:26 <startling> "we don't want to create an arbitrary rule, so we'll just use the arbitrary rule everywhere"? ;)
20:28:44 <sellout-> startling: Well, one rule versus many.
20:29:00 <startling> that's fair.
20:29:14 <benmachine> I wonder when ML got pattern matching
20:29:16 <startling> Relying on declaration order has always seemed ugly to me, I guess.
20:29:42 <benmachine> startling: I think being able to specify an order is beneficial, and I don't see a better way of doing so
20:29:57 <sellout-> startling: But I imagine the benefit would be that you could define the different function-level patterns in different places in the source – did Hope take advantage of that?
20:29:58 <startling> The history section for patern-matching on wikipedia says "See also: Regular expression#History" :/
20:30:21 <startling> sellout-: no idea. I'm reading about Hope for the second time right now.
20:30:22 <sellout-> Although, I don’t really see much use to that “benefit” in Haskell.
20:31:07 <startling> hmm, something like defining new constructors for a type at arbitrary places in privileged modules could be useful for that.
20:31:22 <startling> data List = [] | ...
20:31:30 <startling> map _ [] = []
20:31:40 <sellout-> I have a language of my own that has that problem, though – and currently if you have two patterns that match, the behavior is nondeterministic.
20:31:50 <startling> data List a = ... | a : List a
20:32:02 <startling> map f (a : b) = f a : map f b
20:32:22 <startling> (forgot the parameter in the first 'data')
20:32:30 <startling> sellout-: I think I'd be okay with that.
20:32:50 <sellout-> startling: I might be ok with that if my pattern language were a little richer ;)
20:33:06 <startling> you can still specify order this way, you just have to make the patterns explicitly specific.
20:33:35 <startling> hmm, maybe not.
20:33:36 <saulzar> dmwit: Alright, it's just those two changes at least
20:33:37 <sellout-> startling: Yeah, but it kind of makes using _ difficult.
20:33:59 <startling> or else-like cases.
20:34:22 <startling> though I guess those can be transformed into an inner case pretty easily.
20:34:27 <benmachine> startling: it could be argued that allowing "fallback cases" allows for shorter/chearer definitions
20:34:29 <applicative> dpwright: I like this idea of including a faked file system in your executable; keep going and you will have an operating system
20:34:30 <benmachine> *clearer
20:34:33 <benmachine> and less duplication
20:34:47 <benmachine> applicative: hah
20:34:58 <benmachine> everything in userspace, woo
20:35:16 <startling> benmachine: maybe. I'm not so sure.
20:35:37 <benmachine> startling: I'm thinking zip (x:xs) (y:ys) = (x,y) : zip xs ys; zip _ _ = []
20:35:40 <benmachine> for example
20:37:14 <startling> that's just zip [] [] = [], though.
20:37:35 <benmachine> startling: no, it's zip (_:_) [] = [] and zip [] (_:_) = []
20:37:42 <benmachine> and zip [] [] = []
20:37:59 <dpwright> applicative: Heh... yeah, bit of a downward spiral that -- what fundamental feature will I find out is missing next?!
20:38:01 <startling> oh, right. hmmm
20:38:07 <benmachine> unless your lists are length-typed but that's another story :p
20:38:30 <startling> of course they are. :)
20:39:28 * benmachine needs to sleep
20:39:30 <startling> ... if lengthXs * lengthYs == 0 then [] else ...
20:39:31 * benmachine sees to that
20:39:41 <benmachine> startling: ew. just ew.
20:39:46 <startling> :)
20:40:05 <monochrom> haha
20:40:21 <monochrom> that's what mathematicians do, you know
20:40:50 <monochrom> x^n + y^n = z^n where x*y*z > 0
20:41:11 <saulzar> Blah... well the build scripts don't fail at least, but gtk3 doesn't compile :(
21:08:19 <dmwit> saulzar++
21:25:50 <MedDev> Hodor?
21:28:51 <kqr1> what is wrong if I get a "parse error on input $" when I try to use the TH splice to get lenses out of my data structure? i have the data declaration "data Point = Point { _px :: Double, _py :: Double }" and then I try to do "$(makeLenses ''Point)"
21:29:00 <MedDev> Hodor.
21:31:09 <pavonia> kqr1: Do you have the TemplateHaskell extension enabled?
21:31:27 <edwardk> kqr1: {-# LANGUAGE TemplateHaskell #-}
21:33:15 <kqr1> i did not!
21:33:21 <kqr1> i just found out that was the problem myself
21:33:27 <kqr1> thanks a bunch anyway
21:33:49 <MedDev> Hodor!
21:37:29 --- mode: ChanServ set +o edwardk
21:37:36 --- mode: edwardk set +b *!~MDev@96-41-232-235.dhcp.ftbg.wi.charter.com
21:37:37 --- kick: MedDev was kicked by edwardk (Your behavior is not conducive to the desired environment.)
21:38:18 --- mode: edwardk set -o edwardk
21:51:35 <mkramer> How can I instantiate Show for the subtypes of my GADT that have Show elements? http://lpaste.net/92582
21:51:57 <mkramer> I'd like to instantiate Show differently if a is member of Show than if it isn't
21:52:35 <arkeet> you could do something ugly with OverlappingInstances.
21:53:09 <arkeet> maybe.
21:53:13 <Fuuzetsu> mkramer: I didn't know you could do that.
21:53:27 <arkeet> it's probably not a great idea.
21:53:53 <mkramer> Fuuzetsu: you need {-# LANGUAGE GADTs #-}
21:53:53 <Fuuzetsu> just stick unsafe in front of it and call it a day
21:54:41 <mkramer> Really? There's no way to look at my type parameter a, or my val a, and condition on whether that val is a member of Show?
21:54:49 <startling> unsafeShow :: Tagged a -> b
21:55:15 --- mode: ChanServ set +o edwardk
21:55:42 --- mode: edwardk set -b *!~MDev@96-41-232-235.dhcp.ftbg.wi.charter.com
21:59:03 <Umbrall> I'm confused by why I'm getting a bug with some code
21:59:29 <Umbrall> See I was making a function which would be used for composed monads
21:59:50 <Umbrall> of the type (f a -> f (m b)) -> f (m a) -> f (m b)
21:59:57 <Umbrall> Applicative f => that
22:00:21 <Umbrall> And I have this: (\(s, a) (s', a') -> (mappend s s', a')) <$> m <*> (f $ fmap snd m) but when I tested it with Writer as both monads
22:00:28 <Umbrall> it seemed to duplicate the upper monad each time
22:00:34 <mkramer> what does adding unsafe to the front of the function do?
22:00:50 <Umbrall> it doesn't do anything but let you know it's unsafe
22:00:53 <Umbrall> don't use those functions
22:01:02 <shachaf> Monads don't generally compose.
22:01:06 <Fuuzetsu> I thought it makes it go 5 times as fast.
22:01:10 <Umbrall> I know, that's what that does there
22:01:22 <mkramer> I'm tired, I should stop
22:01:25 <Umbrall> Whenever you can write that for a monad, you can compose an applicative on top of it
22:01:44 <Umbrall> but for some reason that definition there is causing the Writer monad to mappend with itself
22:01:54 <Umbrall> and go from [3] -> [3,3] when I'm not doing anything with it
22:02:04 <shachaf> I don't understand what you mean.
22:02:12 <shachaf> Perhaps you should @paste your full actual code.
22:02:19 <Umbrall> that's all the relevant code
22:02:24 <Umbrall> and the only thing that's causing hte problem
22:02:40 <Umbrall> there is more code, but I've tested and this is the only case that causes the problem, with my writer instance on the inside
22:03:24 <arkeet> Umbrall: you're "executing" m on both sides of <*>
22:03:36 <Umbrall> oh you know that's why
22:03:42 <Umbrall> somehow I didn't see that
22:03:58 <Umbrall> but that still shouldn't be a problem
22:04:23 <Umbrall> since the one is just applying the f :: f a -> f (m b)
22:04:49 <Umbrall> the m b in this case being (s, b)
22:05:02 <Umbrall> which it then mappends the s of
22:06:26 <Umbrall> I guess I should still poste this:       m >>= f = Comp . ((flip transform) $ (>>= (getComp . f))) . getComp $ m
22:06:52 <Umbrall> that's the bind operation for two composed monads, transform is the f (m a) -> (f a -> f (m b)) -> f (m b) here
22:15:32 <fimad> hey, would someone mind explaining something to me? I've encountered a situation where it seems that by applying a contraint to a type I'm changing the kind?
22:15:35 <fimad> is that suppose to happen?
22:15:50 <fimad> :k forall (io :: * -> *). ReaderT Int io
22:15:50 <shachaf> Perhaps.
22:15:50 <lambdabot> * -> *
22:16:09 <fimad> :k forall (io :: * -> *). Functor io => ReaderT Int io
22:16:10 <lambdabot> *
22:16:18 <fimad> that doesn't seem right to me
22:16:27 <shachaf> Hmm, no, it doesn't.
22:17:16 <shachaf> Oh, I think the thing on the right side of => is just assumed to have kind *.
22:17:31 <Umbrall> Okay I fixed my problem but I have no idea how
22:17:38 <shachaf> :k Show a => ReaderT
22:17:39 <lambdabot> *
22:17:46 <fimad> >.>
22:17:47 <shachaf> :k Int => Maybe
22:17:48 <lambdabot> *
22:18:04 <shachaf> I think it's fixed in HEAD?
22:18:33 <fimad> no workarounds if I'm not building ghc from source?
22:19:09 <shachaf> What do you need to work around?
22:19:52 <fimad> ideally I'd like to have a type alias for (MonadIO io, Functor io) => ReaderT SomeState io
22:20:11 <fimad> so I don't need to write that all over the place in my type signatures
22:21:01 <shachaf> :t let foo :: (Int => Show a) => Int; foo = undefined in foo -- you can do some fun things
22:21:02 <lambdabot> (Int -> Show a) -> Int
22:21:03 <fimad> and I'd like to be able to use the alias in a monad transformer stack
22:21:23 <shachaf> OK, I imagine type synonyms should still work?
22:21:50 <shachaf> But constraints would have to be moved outside regardless.
22:22:55 <fimad> _._ yeah? If I left the final type argument implicit I got kind errors, if I made it explicit in the synonym, I got errors about not applying the proper number of arguments if I used it in a stack
22:23:50 <shachaf> "(Foo a => b) c" is not the same as "Foo a => b c"
22:23:56 <shachaf> Even if the former was valid.
22:25:56 <fimad> by moved outside, do you mean substituting "type x = Foo a => b" into "x c" would yield "Foo a => b c" because that is what I was intending.
22:27:11 <shachaf> When I said that I didn't properly read wht you were trying to do.
22:27:25 <shachaf> That's not how the substitution would work. It'd become (Foo a => b) c
22:28:20 <fimad> is the only difference the scope of a?
22:29:31 <shachaf> Scope? This doesn't even have to do with variables.
22:29:58 <shachaf> With type T = Foo A => B, T C would be (Foo A => B) C
22:30:02 <shachaf> Still a problem.
22:35:58 <fimad> alright, I think I get it, thanks!
22:49:17 <flebron> is hugs still recommended as a teaching tool?
22:50:13 <edwardk> no
22:53:41 * hackagebot cipher-des 0.0.3 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.3 (VincentHanquez)
22:53:53 <arkeet> flebron: hugs is not recommended for anything.
22:54:57 <flebron> arkeet: alright, cool. i'm teching a class that uses haskell, and one of the other TAs recommended hugs
22:55:10 <arkeet> hugs hasn't been maintained in years.
22:55:20 <flebron> is there anywhere on the hugs site that says it's not recommended?
22:55:40 <flebron> since it hasn't been maintained, my argument was that documentation could go offline at any moment, and the package could be removed from distros for lack of maintainers
22:55:44 <Heffalump> are you sure hugs isn't maintained? I think it just doesn't get much changes.
22:55:44 <arkeet> I would say that the last update being in 2006 says that it's not recommended.
22:57:11 <startling> it implements all of Haskell 98, doesn't it?
22:57:26 <lispy> Haskell 98 and then some, AFAICT
22:57:36 <lispy> but we're on Haskell2010...
22:57:37 <Heffalump> apart from a small number of documented exceptions (recursive modules)
22:57:48 <shachaf> I suspect nothing implements Haskell 98 exactly.
22:58:03 <startling> sure. so it'll work for pure haskell code. it won't work for lens and friends, but you know.
22:58:30 <shachaf> Lots of lens is H98-compatible.
22:59:36 <startling> you need Rank2Types for a lot of it, don't you?
23:00:18 <shachaf> Maybe for the type synonyms, but not for the actual mechanics of it.
23:00:39 <hpaste> simukis_ pasted “100% CPU usage when writing to file?!” at http://lpaste.net/92585
23:00:48 <startling> shachaf: understood.
23:00:53 <simukis_> ↑ could someone help me with that?
23:01:03 * simukis_ is really stuck now.
23:01:09 <edwardk> startling: you only need them for the synonyms, but many combinators in it and almost all the lenses are basically 98.
23:01:30 <shachaf> http://hackage.haskell.org/package/lens-family-core is all H98, for instance.
23:01:36 <startling> edwardk: is something up? you look ... angry tonight.
23:01:45 <edwardk> i am?
23:01:52 <flebron> the haskell wiki still says " It is certainly the best system for newcomers to learn Haskell. "
23:01:57 <simukis_> Namely as soon as this code starts writing to a file on line 27 cpu usage jumps to 100%.
23:02:00 <edwardk> distracted mayb
23:02:06 <startling> flebron: I would change that.
23:02:07 <shachaf> edwardk: (You're +o.)
23:02:31 --- mode: edwardk set -o edwardk
23:02:47 <edwardk> oh, kick/ban scuffle earlier
23:02:48 <Dtgr> is there a read function that returns maybe or either? or do i have to go with the readIO and catch the exception on error situations?
23:03:03 <shachaf> Dtgr: readMaybe and readEither, as of GHC 7.6
23:03:21 <edwardk> Dtgr you can do it with 'reads' as well
23:03:26 <edwardk> dtgr: no need to go out to IO
23:03:37 <shachaf> Or, yes, reads when you don't have those.
23:03:42 <shachaf> readIO is unnecessary.
23:03:49 <Dtgr> all right, thanks
23:04:08 <edwardk> Dtgr: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Prism.hs#L308 uses reads that way
23:04:17 <startling> that always bugged me. Good to know it's fixed in 7.6,
23:04:32 <startling> The only way to do things gracefully without exceptions is racy. :(
23:05:59 <shachaf> There is always https://github.com/ghc/packages-base/blob/master/Text/Read.hs#L91
23:06:22 <startling> oh, good to know.
23:06:31 <shachaf> edwardk: I wonder whether the prism should do what Text.Read's code does?
23:07:24 <shachaf> (Any reason not to use prism'?)
23:07:50 <arkeet> shachaf: readMaybe isn't in base <4.6
23:08:13 <arkeet> readEither isn't in <4.5 either, I think.
23:08:21 <arkeet> but we don't care about that old anymore.
23:08:22 <shachaf> arkeet: Yes, I mentioned it above.
23:08:24 <arkeet> ok.
23:08:27 <shachaf> Well, GHC 7.6.
23:09:04 <shachaf> I thought readEither and readMaybe were introduced at the same time?
23:09:07 <shachaf> I don't know.
23:09:11 <arkeet> nope.
23:09:11 <shachaf> What's the context of that?
23:09:21 <arkeet> ghc 7.4 has readEither but not readMaybe.
23:09:40 <arkeet> but yeah, why doesn't _Show use prism'?
23:09:45 <mm_freak> http://lpaste.net/92586
23:09:47 <mm_freak> =)
23:09:48 <shachaf> My GHC 7.4 doesn't.
23:09:52 <arkeet> no?
23:10:02 <arkeet> maybe that wasn't in 7.4.1
23:10:49 <arkeet> oh wait.
23:10:52 <arkeet> it's there, just not exported
23:10:54 <arkeet> :/
23:11:34 <arkeet> yeah, 7.6 then.
23:11:41 <shachaf> Oh, yes, I remember that.
23:12:15 <arkeet> I wonder why it uses String instead of some data ReadError = NoParse | AmbiguousParse or something
23:12:23 <arkeet> oh well
23:12:27 <edwardk> shachaf: just to avoid going through another pair of wrappers putting on and taking off stuff
23:12:46 <shachaf> But it's all, like, inlined away and stuff, man. Y'know?
23:12:56 <edwardk> prove it then switch =P
23:13:10 <shachaf> I guess edwardk just hates abstraction.
23:13:16 <edwardk> yes
23:13:24 <edwardk> abstraction is for you ivory tower weirdos
23:13:41 * hackagebot JuicyPixels-repa 0.6.2 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.6.2 (ThomasDuBuisson)
23:13:53 * arkeet . o O ( category-extras )
23:14:55 <knrafto> is there an easy way to get a readable Handle that's backed by a ByteString?
23:15:22 <shachaf> edwardk: Well, they compile to the exact same Core.
23:15:29 <edwardk> shachaf: go for it then
23:15:39 <shachaf> Hmm, arkeet should do it.
23:15:43 <arkeet> knrafto: open a pipe, maybe?
23:15:46 <arkeet> shachaf: you already did it.
23:16:04 <knrafto> I'm trying to abstract over reading a file or reading from a ByteString
23:16:10 <edwardk> nah, he just asserted that he did it. there is a difference ;)
23:16:22 <arkeet> I just asserted that he did it too.
23:16:32 <shachaf> I still haven't worked out the details there! You do it.
23:16:42 <arkeet> but you did it enough to get Core.
23:16:51 <shachaf> I mean, the details with submitting patches and copyright and all that.
23:16:56 <arkeet> git push
23:16:57 <arkeet> done
23:17:17 <shachaf> I tested it in a separate file.
23:17:18 <lispy> knrafto: Handle
23:17:22 <arkeet> :/
23:17:30 <arkeet> well, send me the code then if you're that lazy.
23:17:43 <knrafto> yes, a Handle. Is there a way to get one from a ByteString?
23:17:43 <lispy> knrafto: that's the only existing abstraction there. If you can't use that, then you'll need to build your own.
23:18:03 <lispy> knrafto: Well, and pipes/conduits/iteratee/enumerators/etc may apply
23:18:03 <arkeet> knrafto: a Handle is a thin wrapper around an os file handle, so not really.
23:18:08 <knrafto> lispy: should I build my own using mkHandle?
23:18:28 <lispy> @hoogle mkHandle
23:18:28 <lambdabot> GHC.IO.Handle.FD mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle
23:18:29 <knrafto> s/mkHandle/mkFileHandle/
23:18:41 * lispy isn't familiar with mkFileHandle
23:18:49 <knrafto> @hoogle mkFileHandle
23:18:49 <lambdabot> GHC.IO.Handle mkFileHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle
23:18:55 <shachaf> arkeet: Dangerous territory here.
23:19:03 <arkeet> shachaf: =(
23:19:09 <arkeet> we're both lazy, I get it.
23:19:21 <shachaf> arkeet: It's a matter of changing prism to prism' and changing Right to Just and Left ... to Nothing.
23:19:30 <arkeet> true.
23:19:44 <shachaf> And then comparing the Core to be safe.
23:20:01 <arkeet> well, you know better than me how to do that.
23:20:03 <shachaf> You can use the special trick I just invented for comparing the Core.
23:20:11 <arkeet> I'm scared of your tricks.
23:20:20 <shachaf> You'd love and/or hate it.
23:20:32 <arkeet> most likely the latter.
23:29:50 <toltolt> Does anyone have good sources/examples of naming conventions in a functional language like haskell?
23:30:26 <ReinH> toltolt: just give things names that explain why they exist
23:30:30 <arkeet> do you mean naming conventions in haskell?
23:31:03 <toltolt> A little of both. Naming functions properly is mostly what I'm talking about.
23:31:18 <ReinH> there are a few idioms like (x:xs), recursive functions named go, etc
23:31:33 <ReinH> but mostly just give things names that tell you what they are
23:32:04 <johnw> we also often suffix with ' for strict or alternate, _ for unit return value, M for a monadic combinator, etc.
23:32:19 <ReinH> I see a fair amount of haskell code that uses single letter variables for lots of things
23:32:21 <arkeet> johnwM_'
23:32:23 <ReinH> I think this is a bad idea
23:32:38 <shachaf> _ is about discarding -- the () is just an occasional artifact of that.
23:32:38 <johnw> arkeet: how did you guess!
23:32:43 <arkeet> unsafeJohnwM2_'
23:32:58 <toltolt> I guess an example would help. I had a function that I couldn't think of a good name for. It was calculateFromArray :: [String] -> Double
23:33:05 <ReinH> unless you're talking about something general enough, like f . g = \x -> f (g x))
23:33:13 <arkeet> toltolt: what does it do?
23:33:21 <ReinH> toltolt: calculate what?
23:33:24 <ReinH> from what kind of array?
23:33:31 <ReinH> why would you want to perform that calculation?
23:33:32 <toltolt> The function took a list like ["4" + "+" + "10"]
23:33:42 <arkeet> I can already see that it takes an array (a list, rather), from the type.
23:33:45 <toltolt> and returned 10.0
23:34:05 <toltolt> Yeah. That's what I was saying. I was just stuck without a name...
23:34:10 <ParaSa1lin> length of variable name should be roughly proportional to the number of lines it is in scope for
23:34:23 <ReinH> ParaSa1lin: perhaps
23:34:26 <johnw> toltolt: I probably would have gone with evalExprList or something
23:34:32 <arkeet> if that were true, all the prelude function names would be gigantic!
23:34:43 <toltolt> johnw, that's a much better name.
23:34:47 <ParaSa1lin> log log proportional?
23:34:57 <arkeet> :)
23:35:16 <ReinH> calculateInfix
23:35:22 <ReinH> or evalInfix
23:35:36 <arkeet> evaluate
23:35:43 <ReinH> as distinct from a function that evaluates ["+", "4", "2"]
23:35:49 <toltolt> But it could also take ["4","+","10","/","2"]
23:35:52 <arkeet> ReinH: what if he doesn't care about non-infix?
23:36:53 <toltolt> evalExprList is much better. I'm also still using array on accident :(
23:37:13 <arkeet> toltolt: it's also nice to be able to tell things about what a function does from its type.
23:37:20 <ReinH> arkeet: evalADL :)
23:37:32 <arkeet> String isn't a very informative type.
23:37:41 <ReinH> or evalDAL depending on who you ask
23:37:52 <toltolt> DAL?
23:37:58 <ReinH> direct algebraic logic
23:38:01 <arkeet> digital to analog uh
23:38:02 <arkeet> lens
23:38:27 <arkeet> I've never heard of that.
23:38:32 <arkeet> oh.
23:38:33 <toltolt> I've never heard that before ReinH. That's interesting
23:38:35 <arkeet> it's probably trademarked
23:38:41 <ReinH> http://sharp-world.com/contents/calculator/features/standard/dal/
23:38:52 <ReinH> it's the closest thing to what you're describing
23:38:58 <arkeet> huh
23:38:59 <ReinH> input mechanism for calculators that are not RPN
23:39:17 <arkeet> only if you like using Sharp trademarks.
23:39:19 <ReinH> *input langauge, I guess you would say
23:39:20 <toltolt> Yeah. I have used it a million times but I've never heard that.
23:39:33 * ReinH shrugs
23:39:38 <ReinH> it's not super relevant to anything ever :)
23:39:42 <ReinH> I just like obscure trivia
23:40:04 <toltolt> I'm trying to write a program to calculate definite integrals. Just kind of bored in my current programming class and want to learn more haskell.
23:40:48 <arkeet> you should consider separating parsing expressions from evaluating them. :)
23:41:22 <ReinH> Simon Marlow's youtube channel has one video, a threadscope demo from 3 years ago
23:41:25 <ReinH> he should make more videos
23:41:36 <arkeet> parseExpr :: String -> Expr; eval :: Expr -> Double
23:41:37 <arkeet> or something.
23:41:37 <ReinH> if we interview him for the podcast I will ask him to :D
23:42:12 <ReinH> (we're tentatively planning to interview him in November, but don't tell anyone)
23:42:15 <toltolt> Alright. I'll look into that.
23:42:22 <leroux> ReinH: Sounds great. =)
23:42:26 <arkeet> this means creating your own expression data type.
23:42:37 <arkeet> you'll learn something I'm sure.
23:42:37 <arkeet> :)
23:42:50 <ReinH> arkeet: string typing -100 :)
23:43:31 <Ghoul_> anyone know any examples for writing rewrite rules for sequential things?
23:43:58 <Ghoul_> like if I want to say "doing f(x) and then doing f(x) any time later is the same as f(2*x)
23:46:51 <SrPx> you guys should really make a library where you code in Haskell and compile it to non-cryptic C++...
23:47:41 <Ghoul_> unfortunately trying to express haskell as C isn't very sane most of the time
23:48:27 <startling> SrPx:
23:48:28 <ReinH> Ghoul_: well, if you use a restricted subset of C, you get Cmm...
23:48:28 <startling> heh
23:49:08 <Ghoul_> Cmm looks pretty gross
23:49:22 <ReinH> (http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType)
23:49:26 <ReinH> it is totally gross :)
23:49:35 <Ghoul_> I'm not sure that it passes as non-cryptic, especially because I can imagine it generating a lot of goto's and disgusting things like that
23:49:36 <ReinH> it is a slightly less gross subset of C :)
23:50:06 <SrPx> Please save me from having to actually write C ...
23:50:19 <ReinH> SrPx: sure. Just write Haskell ;)
23:51:29 <m3ga> SrPx: also have a look at Rust language. has a lot of the same good ideas as haskell, but a much less mature.
23:51:36 <SrPx> I have to ship C++ code to my professor so he will pass me. I have worked with C++ for 4 years, I can do it, it is not even a complex application. But I start coding. Then suddenly I notice I could solve something easily composing 2 functions. Then I spend the next 4 hours trying to do so.
23:51:42 <startling> I wouldn't compare Rust to Haskell.
23:51:42 <SrPx> I don't know how it happens. I just can't control it.
23:51:53 <Ghoul_> Punting for rust, its great
23:52:17 <SrPx> It is like I've got a functional curse or something.
23:52:28 <mm_freak> SrPx: at least C++ supports you in employing haskell design patterns
23:52:30 <m3ga> SrPx: we all have that curse
23:52:46 <Ghoul_> #include <functional> ?
23:52:48 <startling> It's an imperative language with an interesting use of linear types and a slightly more powerful type system than average.
23:52:55 <toltolt> Atleast you don't have to hear your professor talk about what an object is and how it can help abstract real world things...
23:53:44 <mm_freak> startling: to me more powerful than average starts when you can be polymorphic on * -> *
23:53:52 <SrPx> m3ga: right? What is wrong with the humanity. Why do I have to write the same 30 characters long line to loop through a vector. Why do I need templates. Why all the classes, methods, typedefs, typenames. Why all the polution. Nothing of that is necessary.
23:54:28 <Ghoul_> templates are nice
23:54:29 <SrPx> toltolt: I do
23:54:32 <SrPx> toltolt: if I do!!!
23:54:49 <mm_freak> rust doesn't have that, so it has an average type system…  in fact C++ is more powerful
23:55:04 <Ghoul_> typeclasses make all the difference with rust
23:55:21 <SrPx> Ghoul_: how are templates any better than a tool that CTRL+V'ed some text replacing a few tokens? Seriously?
23:55:34 <mm_freak> type classes constrained to * polymorphism isn't really that useful
23:55:35 <m3ga> maybe Rust just looks really good in comparison to Go
23:55:50 <Ghoul_> SrPx: they are very different
23:55:53 <Fuuzetsu> you can do dependent typing with templates if you're masochistic enough
23:56:06 <mm_freak> also i really don't understand why language inventors don't get syntax right
23:56:10 <SrPx> Ghoul_: what templates do that can't be done by copypasting a function changing the types?
23:56:12 <Ghoul_> You can implement curry(..)(..)(..) and other crazy things with templates
23:56:15 <mm_freak> rust has the same problem as go:  complicated syntax
23:56:47 <Ghoul_> all the pointer types and object loaning or something like that is pretty confusing with rust
23:56:52 <m3ga> but rust doesn't have null-able references, rust does have algebraic data types and pattern matching
23:56:53 <Ghoul_> lots of symbols ^ & ! ~
23:57:13 <mm_freak> m3ga: haxe has that as well
23:57:23 <mm_freak> ADTs don't magically make a language awesome
23:57:35 <Ghoul_> Yes they do
23:57:44 <startling> mm_freak: well, consider the latest generation of imperative language design -- ruby, python, and go. Surely they lower the average quite a bit.
23:57:46 <m3ga> no, but using a language without them is a pain
23:57:54 <startling> C has ADTs!
23:58:14 <mm_freak> startling: indeed
23:58:20 <Ghoul_> That's a startling fact
23:58:24 <m3ga> startling: yes, but poor unsafe ones
23:58:46 <Ghoul_> That was a triple pun.
23:59:37 <mm_freak> anyway, i don't take rust seriously…  it has pretty much the same quirks as all the other trendy new languages
23:59:46 <startling> m3ga, only a little less safe than e.g. Haskell's
