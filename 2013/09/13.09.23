00:00:08 <kryft> Cale: Hmm, you mean a map where the values are matrices?
00:00:20 <Cale> kryft: A principled way to translate imperative programs is to take each line and define a function with parameters for each of the mutable variables in scope, and have it evaluate to the function corresponding to the next line to execute (according to the control flow of the original program) with possibly updated values of the parameters.
00:01:18 <Cale> But for things like arrays or matrices of arbitrary size, you'll need a data structure which admits reasonably efficient updates. Data.Map does that reasonably well for most purposes, or you can just ignore the cost of copying and use Data.Array or whatever.
00:02:16 <kryft> Cale: Ah, so you meant basically rolling my own matrix/vector type?
00:02:21 <Cale> no
00:02:26 <Cale> Well, maybe?
00:02:39 <ski> well, it's more or less a fixedpoint iteration, that repeatedly makes a new vector from an old one (afaicd)
00:02:46 <kryft> ski: Yes
00:02:53 <haasn> repa?
00:03:10 <haasn> (I have no idea what this is about, but repa permits efficient updates of arbitrary dimension vectors)
00:03:16 <Cale> I'm talking about less fancy things than repa, but sure, you could eventually get it into a form where you could use repa
00:03:19 <haasn> parallel updates, that is
00:03:27 <ski> and i think you can probably define a new version array in terms of the old, that updates all indices at once (bulk update), which should mean less copying
00:03:27 <kryft> But I still want fast matrix multiplication, which I suspect I wouldn't get without something like hmatrix
00:03:34 <ski> (or less needless copying)
00:03:48 <Cale> It does look like they work on one index at a time
00:03:51 <Cale> I_i
00:04:15 <kryft> Oh right, they do, and only a subset of the indices
00:04:40 <Cale> kryft: I'm not talking about the matrices involved
00:04:43 <ski> Cale : yes, though (fat) `w' and `e' in the update probably depends on the already updated stuff, from current round
00:04:50 <haasn> huh, repa has linear algebra stuff: http://hackage.haskell.org/packages/archive/repa-algorithms/3.2.4.1/doc/html/Data-Array-Repa-Algorithms-Matrix.html
00:04:54 <Cale> kryft: If there's matrix multiplication going on, you should probably use a matrix library
00:05:01 <ski> but i think you can probably express this as a recursive array
00:05:03 <Cale> I'm talking about the arrays
00:05:35 <ski> perhaps `X' and `K' are matrices here, not sure
00:06:06 <kryft> Cale: You mean 'arrays' as in the arrays of floating point values that are being updated?
00:06:16 <kryft> Or something more abstract
00:06:37 <Cale> Well, yeah, the arrays being updated. Maybe they're also meant to be vectors somehow?
00:06:45 <kryft> Yes, they are vectors
00:06:48 <ski> > map (\n -> 0 `max` n `min` 3) [-2 .. 7]
00:06:49 <lambdabot>   [0,0,0,1,2,3,3,3,3,3]
00:07:00 <kryft> As in they are involved in matrix products in the algorithms
00:07:18 <Cale> It's unclear to me whether bold w is identified with (w_1, w_2,...)
00:07:25 <Cale> But that seems likely?
00:07:37 <ski> yes, given "convergence over *w*"
00:07:47 <ski> (at the end)
00:07:48 <kryft> Cale: It is identified, yes
00:08:08 <kryft> Cale: Uh bold w = (w_1, w_2, ...) as you said
00:08:36 <kryft> The reason for the I_i stuff is that only a small number of indices are actually updated on each iteration
00:09:07 <Cale> So yeah, you really are updating that vector. However, you might be able to do it all at once, or perhaps in two alternating phases.
00:13:26 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
00:13:27 <lambdabot>  Defined.
00:14:26 <kryft> Probably using ST and mimicking the algorithm pseudo-code (and the matlab implementation) pretty closely will be easiest to begin with
00:14:44 <Cale> I probably wouldn't bother with ST, but you could.
00:15:15 <kryft> Cale: You think I could get essentially the same performance without that?
00:15:24 <Cale> yeah
00:16:09 <Cale> Well, maybe it depends a little
00:16:29 <wagle> if i'm trying to minimize stack allocation, do I use foldr or foldl?
00:16:35 <Cale> If these things are huge so that the garbage is going to be a problem, then maybe just using ST will save you a bunch of trouble
00:16:44 <shachaf> ST can have a performance cost sometimes compared to writing a recursive function!
00:16:50 <Cale> wagle: foldr or foldl'
00:17:06 <shachaf> GHC won't keep the Int# in an STRef s Int in a register.
00:17:08 <ski> > (map ((! 0) &&& (! 1)) . iterate (\oldArr -> fix $ \newArr -> tabulate (0,1) $ \i -> let at j = (if j < i then newArr else oldArr) ! j in at 0 + at 1)) (array (0,1) [(0,0),(1,1)])
00:17:11 <lambdabot>   [(0,1),(1,2),(3,5),(8,13),(21,34),(55,89),(144,233),(377,610),(987,1597),(2...
00:17:24 <Cale> wagle: depending on the nature of the function you're folding
00:17:56 <Cale> wagle: The stack consists not of function applications but of pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match.
00:17:56 <ski> note how `at j' here uses the old array if the new value "hasn't been defined yet", otherwise it uses the new array
00:18:09 <ski> kryft,Cale ^
00:18:18 <Cale> wagle: (and you can think of things like (+) for Integer as needing to match on both of its arguments)
00:18:29 <kryft> Cale: Some of the vectors have something like 220k elements
00:19:06 <ski> what we have here is basically `a_{n+1} = a_n + b_n' and `b_{n+1} = a_{n+1} + b_n', with `a_0 = 0' and `b_0 = 1'
00:19:07 <wagle> running out of stack, and dont know why..  8/
00:19:32 <Walther> Slightly offtopic, what is a "vector" in this context - I know math vectors, but those don't have "elements" (and definitely not up to 220k)
00:19:34 <Cale> wagle: If you write  foldl (+) 0 [1,2,3], the way this gets evaluated is as follows:
00:19:39 <ski> however, both `a_n + b_n' and `a_{n+1} + b_n' there are expressed as `at 0 + at 1' in the code
00:20:12 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> ((0+1)+2)+3
00:20:25 <kryft> Walther: They're 'math vectors', and R^220000 is definitely a valid vector space :P
00:20:39 <Cale> Up to this point, essentially no stack space gets used (well, one space for evaluating the list, maybe)
00:21:00 <ski> (because `foldl' is tail-recursive !)
00:21:26 <Cale> But now we need to evaluate an expression like (...)+3, and (...) isn't ready to match on, it's not evaluated yet. So the pattern match inside (+) goes on the stack
00:21:29 <Walther> kryft: 220k as in i+j+k...[up to 220k] or what does the "element" number denote then
00:21:57 <Cale> and we evaluate something like (...)+2, and for the same reason, another match inside (+) goes on the stack
00:22:34 <Cale> and then finally we get to 0+1, which we can evaluate to 1, and then popping the stack, 1+2 can evaluate to 3, and then popping the stack 3+3 can evaluate to 6
00:22:41 <Cale> wagle: Make sense?
00:22:54 <alpounet> Walther, there just are 220k coordinates, and the "names" are just numbers (the index in the array/vector)
00:23:01 <ski> Cale : hm, one could perhaps display this as explicit reduction steps, with felleisen contexts marking the current expression to reduce
00:23:19 <Cale> I often do display it as explicit reduction :)
00:23:24 <Walther> alpounet: So are you referring to a 220k-dimension vector
00:23:30 <kryft> Walther: Yes
00:23:32 <Walther> in a sense
00:23:36 <Walther> Ah, now I get it.
00:23:41 <alpounet> yes I am
00:23:41 <Walther> Insane, to say the least.
00:24:03 <kryft> Walther: Quite commonplace, really :)
00:24:12 <ski> Cale : yeah, but it's hard to display reduction from `((0+1)+2)+3' to `((0+1)+2)+3', but easier to see it in `{((0+1)+2)+3}' to `{(0+1)+2}+3' to `({0+1}+2)+3'
00:24:15 <Walther> solving the traveling salesman or building a system for public transport? ;)
00:24:16 <wagle> Cale: sortof..  but wondering what to do about my stack
00:24:31 <alpounet> Walther, well, this isn't exactly your everyday vector, but it is sometimes useful, and some jobs imply working on such high-dimensional vectors
00:24:37 <Cale> wagle: Well, you haven't pasted your code on lpaste.net yet, so I can't tell you why it's overflowing.
00:24:44 <kryft> Walther: Actually the 220k-dimensional vector is a brain (fmri data, 220k voxels)
00:24:46 <ski> (where the braces mark the current sub-expression to consider)
00:25:06 <Walther> alpounet: Of course. It's still astounding at times what kind of math programmers have to deal with.
00:25:08 <ski> (and everything outside the braces needs to be stored somewhere, e.g. on the stack)
00:25:13 <Walther> with or without actually knowing it ;)
00:25:18 <Walther> kryft: Oooooh
00:25:37 <kryft> Well, 'a brain', but sort of ;)
00:25:45 <ski> @brain
00:25:46 <lambdabot> It must be inordinately taxing to be such a boob.
00:25:46 <Cale> wagle: But yeah, this gives you some kind of idea of where stack overflows usually come from: large expressions consisting of applications of strict functions being accumulated, and only evaluated much later, once they've grown unmanageably large.
00:26:02 <ski> hm
00:26:22 <Cale> wagle: This means that if you write something in a tail-recursive way, you usually need to add strictness to it.
00:27:18 <kryft> ski: Hmm, so you basically rolled your own one-line persistent functional array? :P In the sense that there's no unnecessary copying
00:27:24 <wagle> Cale: ah..  how do I add strictness?
00:27:31 <Cale> wagle: Generally, if you have some case where you're accumulating a large amount of data into a summary of some sort, you want strictness (and tail recursion). In most other cases, you want laziness.
00:27:39 <Cale> There are a couple of ways...
00:28:02 <wagle> i sorta agreed not to publish my homework
00:28:24 <Cale> An easy one is to turn on {-# LANGUAGE BangPatterns #-} and then a pattern match like (!x) will cause x to be evaluated when matching.
00:28:47 <ski> kryft : each time we get around to the "for i = 1 to length of I do", i allocate a new array (instead of allocating a new array at each individual array update)
00:28:50 <Cale> Or you can use seq
00:29:09 <ski> kryft : still, for a very large array, you may want to use update-in-place anyway
00:29:26 <Cale> seq x y will evaluate to y, but will only make that result available for pattern matching once x has been evaluated.
00:29:33 * ski isn't sure
00:29:49 <Cale> (GHC may still decide to evaluate y first, but it won't make the result available until x has been evaluated)
00:30:15 <kryft> ski: Yeah, I think I'll probably just use ST with a matrix/vector type, at least to begin with
00:30:18 <ski> kryft : the above `tabulate' which i defined is a very handy function on persistent, immutable arrays
00:30:19 <Cale> So, you can use that to ensure that the stack won't blow up
00:30:36 <Cale> For example, in foldl'
00:30:46 <Cale> Well, let's look at foldl first:
00:30:55 <Cale> foldl f z [] = z
00:31:14 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
00:32:13 <Cale> The trouble here was that this never gives f z x a chance to evaluate. foldl just applies itself to new parameters, and the expression gets larger and larger
00:32:14 <wagle> i dont find foldl', do find foldl1
00:32:25 <Cale> foldl' is defined in Data.List
00:32:29 <ski> @index foldl'
00:32:29 <lambdabot> Data.List
00:32:32 <Cale> foldl' f z [] = z
00:32:49 <ski> (please use `$!')
00:33:00 <Cale> foldl' f z (x:xs) = let z' = f z x in seq z' (foldl f z' xs)
00:33:17 <Cale> We could also use $! I suppose
00:33:29 <Cale> I was trying to explain how seq works though :)
00:33:37 <Cale> and that's another step away
00:33:46 <ski> ok
00:33:55 <Cale> also, it's awkward because the associativity is wrong
00:34:04 * ski nods sadly
00:34:15 <kryft> It will be interesting to see how the performance of the haskell implementation compares with matlab. Actually maybe I'll profile the matlab code first to make sure that it isn't spending all it's time on matrix multiplication, which is unlikely to be any faster outside of matlab. :P
00:34:57 <Cale> kryft: I would be surprised if it wasn't spending all its time on matrix multiplication.
00:35:22 <Cale> Given that you have (220k)^2 matrices
00:35:30 <notdan> Does anybody know if I can installed a profiled version of the 'vector' library?
00:35:36 <notdan> It gives me an error: ghc: You can't call hscCompileCoreExpr in a profiled compiler
00:35:55 <Cale> notdan: That's odd
00:36:02 <Cale> notdan: What are you running?
00:36:11 <Cale> (what command produced that)
00:37:02 <Cale> notdan: That sounds like you're running a profiled version of ghc somehow
00:37:07 <wagle> Cale: ok, converted my two foldls to foldl', and its not running out of stack..  but will probably not terminate soon
00:37:30 <Cale> wagle: well, at least it runs now!
00:38:00 <ski> kryft : anyway, also try with vector and matrix libraries
00:38:39 <Cale> hscCompileCoreExpr hsc_env srcspan ds_expr
00:38:39 <Cale>     | rtsIsProfiled
00:38:39 <Cale>     = throwIO (InstallationError "You can't call hscCompileCoreExpr in a profiled compiler")
00:40:00 <Cale> #ifdef GHCI
00:40:00 <Cale> -- Consult the RTS to find whether GHC itself has been built profiled
00:40:00 <Cale> -- If so, you can't use Template Haskell
00:40:00 <Cale> foreign import ccall unsafe "rts_isProfiled" rtsIsProfiledIO :: IO CInt
00:40:00 <Cale> rtsIsProfiled :: Bool
00:40:01 <Cale> rtsIsProfiled = unsafePerformIO rtsIsProfiledIO /= 0
00:40:03 <Cale> #endif
00:40:11 <Cale> (sorry for the longish paste)
00:40:31 <notdan> Cale: yes, I need a profiled version of GHC, because I want to profile my program which uses GHC API
00:42:15 <Cale> hmm
00:42:43 <Cale> http://ghc.haskell.org/trac/ghc/ticket/4532
00:43:22 <notdan> oh :(
00:43:24 <notdan> thanks
00:43:28 <notdan> that's a bummer
00:44:16 <Cale> That's a rather old ticket, I don't know if it's still entirely impossible or not, but yeah, it seems like that might be the case.
00:44:42 <kryft> ski, Cale: Anyway, thanks for the help!
00:44:47 <ski> yw
00:50:24 <ksf_> last chance to convince me not to use unsafecoerce for extensible products and sums
00:50:55 <ksf_> (the plan is to represent products as tries of their labels)
00:52:35 <kqr> is there a clever way to express `if p a b then a else b'? or would that require TH?
00:53:06 <ksf_> foo p a b = if p a b then a else b
00:53:37 <kqr> yeah i just realised
00:53:38 <ksf_> if2?
00:54:35 <ksf_> you could of course also change p to not return a bool.
00:54:43 <monoidal> kqr: TH is unlikely needed. worst-case you can create a combinator
00:55:01 <ksf_> in the sense of just writing "a `or` b"
00:55:23 * hackagebot liquid-fixpoint 0.1.0.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.1.0.0 (EricSeidel)
00:56:04 <kqr> ksf_, good point
01:00:23 * hackagebot liquidhaskell 0.1 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.1 (EricSeidel)
01:05:30 <monoidal> kqr: maximumBy p [a,b] - technically this requires p to be a linear order, but should work without it
01:06:18 <monoidal> kqr: um, sorry, that requires p :: a -> a -> Ordering not Bool
01:41:12 <haasn> Are there any performance considerations regarding the order of (independent) patterns? in GHC
01:44:12 <haasn> monoidal: (a -> a -> Bool) -> a -> a -> Ordering -- should be possible
01:45:25 <arkeet> haasn: it should?
01:45:29 <haasn> oh, I just saw what this is about
01:45:33 <arkeet> well
01:45:36 <haasn> arkeet: I mean, it's obviously possible :P
01:45:39 <haasn> But not very relevant, either
02:12:26 <d3lxa> what's the monadic function 'If cond actionIfTrue' without else, do a thing if it's true or do nothing? returns m () anyway?
02:14:27 <quchen> :t when
02:14:28 <lambdabot> Monad m => Bool -> m () -> m ()
02:14:42 <quchen> when p m = if p then m else return ()
02:14:58 <theWinner> I need me some Haskell expertise on my F# code -
02:15:07 <theWinner> Is this a monad? - http://lpaste.net/93284
02:15:14 <d3lxa> quchen: oh yeah, that's it, 'when'
02:15:17 <d3lxa> thx
02:15:20 <profmakx> rgh
02:15:38 <quchen> d3lxa: There's also 'unless', which uses "not p" as predicate.
02:16:22 <d3lxa> I now see that with the (correct) signature, I could have found it on hayoo/hoogle
02:20:57 <Taneb> theWinner, I'm not sure (I don't know F# at all), but to me that looks like the Writer monad
02:23:15 <gpampara> Taneb: Agreed
02:24:45 <gpampara> With a bit of State there as well
02:27:40 <quchen> "Writer with a bit of State" doesn't sound like a Monad.
02:28:32 <ij> Does haskell have namespaces or only imports?
02:28:43 <ij> (through)
02:29:17 <quicksilver> it has rather limited namespace/renaming support via the "import .. qualified as" statement
02:30:11 * Maxdamantus wonders if anyone's made a type system that only lets you refer to type classes and type variables (and not actual types)
02:30:14 <ij> Is that ever a problem?
02:31:39 <Maxdamantus> `a -> b -> c` might use (->) like a metavariable, in that it's implicitly a single variable in a term.
02:32:12 <Maxdamantus> `((->) d) => d a (d b c)`
02:34:59 <Ghoul_> ij: nope
02:35:25 <Ghoul_> you can even "namespace" separate packages which use the same module names using the PackageImports extension
02:35:42 <Ghoul_> ie: recently I found 2 packages using the module name Crypto.Random, so I could use something like:
02:35:54 <Ghoul_> import qualified "package1" Crypto.Random as R
02:36:00 <Ghoul_> import qualified "package2" Crypto.Random as Z
02:36:41 <quchen> Oh, I didn't know about that. I was wondering what would happen in that case.
02:37:12 <Ghoul_> Funnily enough the same maintainer owned both packages that were conflicting, so I sent him an email
02:37:26 <Ghoul_> it's annoying when it happens, but at least there *is* a way around it ;)
02:37:37 <theWinner> thanks all
02:37:42 <ij> Weird that he owns both of them.
02:37:47 <ij> Ghoul_, sounds great
02:37:52 <theWinner> if I don't have a monad, I do wonder if I instead have an arrow
02:38:03 <theWinner> er wait, arrows are monads?
02:38:58 <quchen> No.
02:39:57 <haasn> monads are arrows
02:40:12 <theWinner> but arrow are not monads?
02:40:15 <haasn> theWinner: do you have an applicative?
02:40:22 <theWinner> i believe I do
02:40:30 <haasn> chances are you have an arrow, then
02:40:37 <theWinner> that's what I figured
02:40:46 <theWinner> I guess I just need to work it out
02:44:32 <boothead> Why isn't this a thing in ghci? :l something.hs can't load this. Stop, hoogle time? Relatedly; can I get haskell to play MC Hammer on demand?
02:44:36 <jophish> Yo yo yo
02:45:43 <jophish> I have some text which has some segments in brackets. I'd like to remove the characters in brackets and the brackets themselves. This isn't particularly difficult to achieve, but I can't see a very elegant way to do it.
02:46:09 <Ghoul_> It sounds like you're removing everything. Is [] suffice?
02:46:42 <jophish> Ghoul_: I mean, I have a string "abc[def]gh" and I'd like "abcgh"
02:47:15 <Ghoul_> oh, uh. This sounds like a job for a fold hack
02:47:30 <jophish> yeah, I ended up carrying a list and a flag in the fold
02:47:35 <jophish> it didn't feel neat
02:48:50 <quchen> A non-hack would be using a parser.
02:48:54 <quchen> I think you want that fold hack.
02:49:02 <Ghoul_> in Data.List there is sepByOneOf
02:49:19 <Ghoul_> You could drop every second list produced by that..
02:49:40 <Ghoul_> but, actually, that would exhibit strange behaviour like "abc[def[h] returning "abch"
02:50:07 <quchen> I think you meant Data.List.Split
02:50:27 <jophish> I'm counting on there being no nested brackets
02:50:47 <quchen> You could also do that using a fold hack.
02:51:54 <Ghoul_> This seems like such a trivial thing to pull in a whole parsing library for
02:52:08 <Ghoul_> but if you're going to do so, attoparsec is fast and probably well suited for this *simple* parsing.
02:52:20 <chrisdone> λ> parse (do before <- manyTill anyChar (char '['); manyTill anyChar (char ']'); after <- manyTill anyChar eof; return (before++after)) "test" ("abc[def]gh"::String)
02:52:20 <chrisdone> Right "abcgh"
02:52:21 <Ghoul_> afk
02:52:27 <jophish> I think the fold is nicer than parsec
02:52:58 <Ghoul_> if you show us the fold, maybe we can try and golf it ;)
02:53:25 <jophish> sounds good, give me a sec to write it here (It's on another compiter)
02:53:28 <jophish> computer*
02:55:50 <chrisdone> applicative version: parse ((++) <$> manyTill anyChar (char '[') <*> (manyTill anyChar (char ']') *> manyTill anyChar eof))
02:55:53 * hackagebot cipher-rc5 0.1.0.1 - Pure RC5 implementation  http://hackage.haskell.org/package/cipher-rc5-0.1.0.1 (FinnEspenGundersen)
02:58:06 <quchen> > let go '[' cs n = cs $! n+1; go ']' cs n = cs $! max 0 (n-1); go c cs 0 = c : cs 0; go c cs n = cs n; noBrackets code = foldr go (const []) code 0 in noBrackets "hel[lo w[or]l]d!"
02:58:07 <lambdabot>   "held!"
02:58:13 <quchen> Not so Applicative version
02:58:19 <chrisdone> lol
02:58:36 <quchen> But works for nested brackets. At least something!
02:59:45 <Ghoul_> quchen: is this a job for foldr1?
03:00:03 <quchen> Ghoul_: Depends on whether you want your function to be able to crash.
03:00:23 <d3lxa> is there a standard function like: a -> m () -> m a?
03:00:44 <quchen> :t (<$)
03:00:46 <lambdabot> Functor f => a -> f b -> f a
03:00:48 <Ghoul_> return . void ?
03:00:55 <Ghoul_> wait, no.
03:01:02 <quchen> :t liftM const
03:01:03 <lambdabot> Monad m => m a1 -> m (b -> a1)
03:01:10 <quchen> Woops,
03:01:12 <quchen> :t liftM . const
03:01:14 <lambdabot> Monad m => r -> m a1 -> m r
03:01:36 <Rarrikins> @pl \a z -> z >> return a
03:01:40 <lambdabot> flip (>>) . return
03:01:40 <lambdabot> optimization suspended, use @pl-resume to continue.
03:01:41 <d3lxa> something like liftM const >>= action ?
03:01:52 <Rarrikins> @type flip (>>) . return
03:01:53 <lambdabot> Monad m => b -> m a -> m b
03:02:09 <quchen> d3lxa: (<$) is what you're looking for.
03:02:16 <DMcGill> d3lxa: value <$ action
03:02:19 <d3lxa> isn't there (<<)?
03:02:23 <quchen> No.
03:02:25 <d3lxa> @type (<<) . return
03:02:27 <lambdabot>     Not in scope: `<<'
03:02:27 <lambdabot>     Perhaps you meant one of these:
03:02:27 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
03:02:51 <d3lxa> can't you use =<< and discarding the () argument?
03:02:53 <DMcGill> Besides, (<<) wouldn't do what you want anyway since both arguments to (>>) are monadic.
03:03:03 <d3lxa> oh yeah, right
03:03:33 <quchen> There's (<*), which is arguably like (<<), which is unarguably not what you want.
03:04:32 <d3lxa> @type (<*)
03:04:33 <lambdabot> Applicative f => f a -> f b -> f a
03:04:36 <DMcGill> all these sorts of functions are known as Applicative style, and it's interesting seeing programs specified like this when they could also be in do-notation
03:05:03 <d3lxa> ok, great idea to use the "application" of the monad
03:05:07 <jophish> http://lpaste.net/93289
03:05:10 <DMcGill> do{ x <- readChar; n <- readInt; whiteSpace; return (f x n)}
03:05:26 <jophish> A pretty rough version, but it demonstrates what I'm doing
03:05:32 <DMcGill> f <$> readChar <*> readInt <* whiteSpace
03:07:31 <jophish> Is it an idiomatic thing to pass a flag with a fold. I've never had to do it before
03:08:08 <d3lxa> quchen: not sure if it's correct http://sprunge.us/SgRI but seem not
03:08:45 <d3lxa> oh it's the reverse right? the "const" is last?
03:09:03 <DMcGill> d3lxa: use (<$) not (<*)
03:09:16 <d3lxa> @type (<$)
03:09:17 <lambdabot> Functor f => a -> f b -> f a
03:09:25 <d3lxa> oh yeah, sure
03:09:50 <DMcGill> although I'd argue that ($>) is a little clearer here
03:09:58 <DMcGill> not that it matters too much
03:10:44 <quchen> DMcGill: Unfortunately $> isn't in 7.6
03:10:53 <quchen> It's in HEAD though
03:11:12 <DMcGill> huh
03:13:34 <d3lxa> you need GHC 7.6 to have such a difficult function: flip (<$)? =p ahah
03:18:20 <Jeanne-Kamikaze> is there something stronger than killThread ?
03:18:49 <Jeanne-Kamikaze> it seems I cannot killThread a thread that has blocked by calling Network.socket.accept
03:19:22 <boothead> Does anyone know how I might go about telling SmallCheck how to generate me an increasing list of timestamps?
03:19:23 <chrisdone> hmm -- i suppose that's related to calling into C, it's left the runtime at this point
03:19:23 <notdan> The safest way is to use processes and killProcess
03:19:29 <Jeanne-Kamikaze> ah
03:19:39 <Jeanne-Kamikaze> yeah
03:20:14 <boothead> Jeanne-Kamikaze, nukeThreadFromOrbitJustToBeSafe I'm not sure if such a thing exists, but that's what you should call it if you make one :-)
03:21:27 <boothead> Jeanne-Kamikaze, I used to have similar problems in python when a thread was blocked by epoll or whichever event loop zeromq was using
03:21:38 <Jeanne-Kamikaze> I just need a non-blocking accept
03:21:55 <Jeanne-Kamikaze> there must be some way to do it
03:21:55 <chrisdone> what about listenOn?
03:22:01 <chrisdone> i'm pretty sure i've used that and killed the thread before
03:22:08 <chrisdone> it probably manages this stuff for you
03:22:41 <Jeanne-Kamikaze> I don't like the high level socket api because it distinguishes between Socket and Handle
03:23:12 <Jeanne-Kamikaze> guess I'll just grab some bsd sockets reference
03:23:51 <chrisdone> actually that one uses Socket.accept anyway
03:27:26 <Jeanne-Kamikaze> oh noes, it won't let me configure the socket as non-blocking
03:31:14 * hackagebot ac-machine 0.2.0.1 - Aho-Corasick string matching algorithm in Haskell  http://hackage.haskell.org/package/ac-machine-0.2.0.1 (YutaTaniguchi)
03:32:04 <DMcGill> is there some function "guardPredicate :: (a -> Bool) -> a -> f a; guardPredicate p a = if p a then pure a else fail"
03:32:30 <DMcGill> for whatever f, pure and fail makes sense. I'm using it inside Maybe so the monad's return and fail "" would work just fine there I think
03:33:15 <Taneb> \p x -> guard x >> return x
03:33:17 <Lethalman> guardPredicate (p a) would be the same :P
03:33:31 <Lethalman> why (a -> Bool) -> a when you can have Bool
03:33:45 <DMcGill> I don't want to have to give 'a' a name
03:34:02 <Lethalman> ah right you want -> f a sorry
03:34:04 <DMcGill> filterM or on traversals seems like
03:34:09 <DMcGill> they'd do what I want
03:34:24 <DMcGill> traversables*
03:34:47 <yogsototh> Hi could someone explain to me what is the meaning of the pipe in the definition of the typeclass MonadReader? http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-Reader.html thanks.
03:35:06 <tdammers> guys, what's the best way to build haskell projects for OS X, other than building *on* OS X?
03:35:12 <tdammers> build host is debian wheezy
03:35:44 <tdammers> I have a mac available, but it's not mine, so I'd rather not use that
03:36:11 <johnw> yogsototh: that's called a "functional dependency"
03:36:24 <johnw> it means that any typeclass instance for "m" can only ever be matched to one "r"
03:36:36 <johnw> so, if you have instance MonadReader Foo Bar, you cannot also have instance MonadReader Foo Baz
03:37:07 <johnw> you read it as "m determines r" or "m fixes r"
03:37:35 <yogsototh> johnw: Thanks a lot! I couldn't read it.
03:41:34 <Jeanne-Kamikaze> is there some way to magically auto-derive Functor, Applicative, Monad, and whatever instances when newtyping an existing monad ?
03:42:52 <johnw> GeneralizedNewtypeDeriving
03:42:58 <Jeanne-Kamikaze> as in, newtype ConstrainedIO a = ConstrainedIO { run :: IO a } deriving <Everything that IO implements>
03:43:16 <johnw> newtype MonadWrapper m = MonadWrapper m deriving (Functor, Applicative, Monad, MonadPlus, etc.)
03:43:23 <monoidal> Jeanne-Kamikaze: you need to write those classes
03:43:34 <Jeanne-Kamikaze> but I don't want to
03:43:34 <monoidal> Jeanne-Kamikaze: i.e. list them. there's no "everything that can be done"
03:43:39 <Jeanne-Kamikaze> ah
03:43:41 <Jeanne-Kamikaze> well yeha
03:43:49 <Jeanne-Kamikaze> I'll try that then :D
03:45:12 <monoidal> Jeanne-Kamikaze: suppose someone implements class I a where f :: IO a -> I a; instance I IO where f = id
03:46:00 <monoidal> Jeanne-Kamikaze: then, if you had "derive everything" you would have access to the newtype constructor, which is probably not intended
03:46:18 <DMcGill> anybody feel like code golfing http://lpaste.net/93290 for me? I can't help but feel that there's a better way of doing it
03:46:47 <monoidal> Jeanne-Kamikaze: I meant class I m where f :: IO a -> m a
03:46:51 <Jeanne-Kamikaze> ah, true
03:47:54 <monoidal> Jeanne-Kamikaze: (in fact, that class already exists and is called MonadIO)
03:48:13 <Jeanne-Kamikaze> right, so the MonadIO would leak in
03:48:31 <Jeanne-Kamikaze> ok, this did save some clutter
03:49:22 <Maior> so, er, any tips on turning C's `printf("%c%c%c", x, y, z);` into something Haskell-y?
03:49:35 <johnw> Maior: it's been done a few times
03:49:59 <johnw>  http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
03:50:07 <Maior> it's the truncation I'm not sure about, though I guess I could just DIY it with "cap the int, then Show"
03:50:20 <Maior> oh, that exists, sigh, thanks johnw !
03:52:13 <tdammers> Maior: it feels a bit dirty though... using C's actual printf through FFI
03:52:19 <DMcGill> how do I turn a list into a Fold on that list? I'm trying to use 'chunking' on it.
03:53:10 <merijn> tdammers: You can't even do that, the FFI doesn't support variadic functions, afaik
03:53:38 <DMcGill> ah, 'folded' is what I want
03:53:43 <Maior> tdammers: oh is that how it's implemented?
03:55:34 <johnw> merijn: correct, it does not
03:56:13 <merijn> johnw: Which makes me so sad :<
03:56:38 <johnw> merijn: doing varargs right for all ABIs is more than I think GHC will ever want to care about
03:56:48 <johnw> (said as someone who has been in that position before)
03:57:21 <johnw> that said, you could always use http://hackage.haskell.org/package/libffi
03:57:29 <johnw> that has the ability to call foreign C varargs function
03:57:41 <johnw> a bit unmaintained, albeit
03:59:33 <merijn> 5s and I already see a C flaw in the Haskell code there :p
04:00:07 <merijn> Filthy lie that calling memset on NULL is a crash
04:02:18 <haasn> Is there a function that acts as both ‘takeWhile’ and ‘dropWhile’?
04:02:30 <haasn> @hoogle (a -> Bool) -> [a] -> ([a],[a])
04:02:31 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
04:02:31 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
04:02:31 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
04:02:31 <arnsholt> It's mostly going to SEGV though, isn't it? As long as you're not in the kernel or something silly like that
04:02:34 <haasn> aha!
04:03:42 <merijn> arnsholt: You'd say that and you'd be wrong*.
04:04:01 <merijn> * - for values of wrong that mean "right and most conditions, except where it subtly screw you over"
04:04:41 <arnsholt> Oh, this is the whole undefined behaviour when operating on NULL pointers, isn't it?
04:05:12 <merijn> Because dereferencing NULL doesn't necessarily crash your program. In fact, dereferencing NULL is undefined behavior and the compiler can do whatever it likes. Which mostly means crash, except when it doesn't because the compiler decided a value is guaranteed to be NULL, so it can perform deadcode elimination on everything after it
04:05:31 <merijn> And then you're really confused for a few hours :p
04:06:15 <arnsholt> Right
04:07:06 <quicksilver> pre-protected memory, pre-virtual memory OSes often had NULL be a perfectly valid location
04:07:18 <quicksilver> dereferencing it just gave you the data at memory location 0.
04:07:34 <quicksilver> these days OSes try pretty hard to make a NULL dereference crash though.
04:07:50 <arnsholt> Yeah, that makes perfect sense. Memory is just a great big array of bytes
04:09:13 <merijn> quicksilver: Sure, the OS will try pretty hard, but if the compiler fouls it up you'll never reach that point :)
04:12:05 <quicksilver> merijn: yes. That's why I never use compilers.
04:12:11 <quicksilver> always fouling stuff up.
04:13:58 <kuribas> Can I develop OS X apps with older Xcode versions?
04:15:23 <merijn> kuribas: Depends, do you want actual .app things or just binaries you can distribute standalone?
04:15:35 <merijn> The latter, definitely, the former, I'm not sure.
04:16:52 <kuribas> I don't know the difference, I am new to apple development.
04:16:58 <Guest2237> hello
04:17:06 <kuribas> Preferably something that can easily be installed.
04:18:14 <Guest2237> anyone willing to teach me some SQL I will pay
04:18:28 <Guest2237> /set name mars
04:18:29 <Kinnison> I fear you're in the wrong channel for that kind of thing
04:18:52 <Guest2237> can you send me a channel name?
04:19:18 <Guest2237> where there will be someone to help me?
04:19:19 <tdammers> merijn: hmm, I thought it was, never bothered to check though
04:19:24 <merijn> kuribas: OSX has a .app format which lets you use Cocoa bundles, ship resources and settings with it and use all their fancy Objective C frameworks. On the other hand, you can just build standalone binaries for OSX too, which are things like the libraries/binaries you use on linux.
04:20:00 <kuribas> merijn: In that case, I want an .app
04:20:26 <merijn> kuribas: Then I'm not sure whether an older Xcode works, couldn't hurt to try, I guess?
04:20:32 <Guest2237> how can I make a chatroom?
04:20:34 <Yaniel> .app is a "all in one" folder with binaries, libs, resources etc
04:21:03 <kuribas> merijn: No, it's free.  But I cannot test it on another mac than the one I have.
04:23:12 <wearelegionapart> #newblood
04:24:00 <wearelegionapart> can someone teach me some php? I can pay up to 900 dollars via paypal
04:24:36 <kuribas> wearelegionapart: Are you a bot?
04:32:51 <Rarrikins> How can I get Aeson to fail with the error message within some JSON or handle the data normally?
04:35:28 <mikeplus32> > 1e1.5
04:35:30 <lambdabot>   Could not deduce (GHC.Num.Num (a -> b0))
04:35:30 <lambdabot>    arising from the ambiguity chec...
04:35:33 <mikeplus32> > 1e1.5 3
04:35:36 <lambdabot>   Could not deduce (GHC.Num.Num
04:35:36 <lambdabot>                      (GHC.Integer.Type.Intege...
04:35:41 <mikeplus32> > (1e1.5) 3
04:35:43 <lambdabot>   Could not deduce (GHC.Num.Num a0)
04:35:43 <lambdabot>    arising from the ambiguity check for `...
04:35:47 <mikeplus32> @type 1e1.5
04:35:48 <lambdabot> (Fractional (b -> c), Num (a -> b)) => a -> c
04:35:52 <mikeplus32> what's going on there?
04:36:35 <Rarrikins> > 1.5e1
04:36:37 <lambdabot>   15.0
04:37:15 <monoidal> 1e1.5 is parsed as 1e1 .5
04:37:50 <Rarrikins> > 1 * 10**1.5
04:37:52 <lambdabot>   31.622776601683793
04:38:45 <monoidal> mikeplus32: 1e1 . 5 is composition of functions 1e1 and 5
04:39:25 <monoidal> mikeplus32: normally functions are not instances of Num/Fractional, but it is possible to define them
04:41:40 <merijn> mikeplus32: Essentially, one of the problems with typeclasses is that there's no way for GHC to know "what is sensible", GHC only knows two things, 1) 1e1 and 5 are Num instances, 2) you're composing them. Therefore, you must be trying to use the instance of Num for functions. But then it realises "I don't know any Num instance for functions" and complains about that
04:57:58 <danilo2> Hello! I just found out that there is a Hackage2 (Beta). I want to ask you - is it safe to switch to beta? Additional - on old Hackage there is Parsec which has a lot of versions and on new there is Parsec3 package - are they relevant? Which one is newer?
04:58:02 <danilo2> http://hackage.haskell.org/package/parsec
04:58:09 <danilo2> http://beta.hackage.haskell.org/package/parsec3-1.0.0.5
04:58:26 <danilo2> Or it is the same package but with different numeration ?
04:58:49 <Yaniel> Beta generally means that it is not "safe" in the sense of not breaking stuff
04:58:50 <fryguybob> danilo2: The switchover should be happening very soon, so I would wait a couple days
04:59:12 <danilo2> fryguybob: Ah, nice to know! :)
04:59:21 <danilo2> fryguybob: so I'll wait for it :)
05:01:40 <Saizan> danilo2: old hackage has parsec3 too
05:02:21 <Saizan> and yeah, it's parsec-3.x with a different name
05:03:45 <danilo2> Saizan: oh, I didnt saw that :) Ok thank you :)
05:07:50 <Raydiation> hi i have to learn lamda calculus and the slides that i have to use dont really explain the syntax very well
05:07:57 <Raydiation> what does \x . \y . x * y mean
05:08:12 <Itkovian> Raydiation that would be a function that takes two arguments
05:08:22 <Raydiation> something like function (x) { return function (y) { return x * y }}?
05:08:25 <Itkovian> x and y and the function value is the multiplication of both arguments
05:08:25 <Raydiation> translated to js
05:08:33 <Taneb> Raydiation, that is precisely it
05:08:36 <Raydiation> ty :)
05:09:06 <Raydiation> could this be a functor?
05:09:15 <Itkovian> Raydiation as you can see, each lambda calculus (and by extension Haskell) function really is a function that takes a single argument
05:09:33 <quicksilver> not in the sense 'functor' people use in haskell or category theory, no.
05:09:38 <Raydiation> ok ty
05:11:09 <Itkovian> and returns either a function that takes again a single argument or returns a non-function value
05:14:14 <Raydiation> the second syntax that i dont get is \x.f(xx). is xx x*x? and what is f
05:14:47 <Raydiation> so if i execute it with 3 does it return f(33) ?
05:14:54 <Raydiation> or f(9)
05:15:45 <Saizan> Raydiation: xx is x applied to x
05:15:57 <Raydiation> so x is a function?
05:16:17 <Saizan> (in haskell you'd put a space between them)
05:16:21 <Saizan> Raydiation: yeah
05:17:57 <merijn> Raydiation: The lambda calculus only has functions, there is nothing else :)
05:18:23 <DMcGill> how can I derive IArray for my newtype on an Array? GHC is choking on its multiple parameters
05:18:44 <DMcGill> newtype Box a = Box {unbox :: Array (Int, Int) a}
05:19:32 <DMcGill> "Can't make a derived instance of `IArray (Box a)' [...] `IArray' does not have arity 1"
05:26:08 <quchen> Raydiation: Numbers in Lambda calculus look like \fx.f(fx)  (that corresponds to 2)
05:26:45 <quchen> When you see explicit numbers in lambda expressions, it's shorthand notation for something like that.
05:27:03 <quchen> When you don't see numbers in lambda expressions there's probably nothing with numbers going on.
05:27:06 <fizruk> DMcGill: you can't make Box an instance of IArray, because of its type signature of bound function
05:27:27 <fizruk> DMcGill: bounds :: Ix i => a i e -> (i, i)
05:28:08 <fizruk> DMcGill: so for Box type it should be Ix i => Box i a -> (i, i)
05:28:36 <fizruk> DMcGill: but Box does not take an index type parameter
05:29:30 <quicksilver> quchen: that is only one possible encoding of numbers in the lambda calculus.
05:29:32 <fizruk> DMcGill: try newtype BoxI i a = Box { unbox :: Array (i, i) a }
05:29:51 <fizruk> DMcGill: and then: type Box = BoxI Int
05:32:42 <quchen> quicksilver: What others are there?
05:33:09 <quchen> "lambda calculus number encoding -church" doesn't yield much ;-)
05:33:14 <merijn> quchen: That's Church encoding, I think. You also have Scott encoding and a bunch more for data types
05:33:58 <DMcGill> fizruk: I still can't get it working, could you possibly put together a minimal code snippet that compiles please?
05:34:09 <merijn> quchen: Most things like Scott encoding work for any recursive ADT, so you can just manually translate "data Nat = Succ Nat | Zero" into them
05:35:44 <quchen> merijn: So in Haskell terms Church encoding is like lists of Endo mconcat-ed, while Scott is the list itself … ish?
05:35:46 <DMcGill> fizruk: I suppose I could always define "bounds = bounds . unBox; numElements = numElements . unBox; ..." myself in the worst case
05:36:41 <merijn> quchen: I have no clue what that means :p
05:36:48 <quchen> Church re-applies f :: a → a repeatedly, whereas Scott is more like having number :: [()]
05:37:12 <merijn> Yeah, I think so? tbh, it's been awhile since I read about Scott encoding
05:37:23 <quchen> Ignore that we're talking about the untyped λ calculus ;-)
05:37:54 <quchen> I'll just believe you. That sounds like a good plan.
05:39:38 <oddsignals> Is there an idiomatic way to create subtotals for a list of records in Haskell?
05:39:59 <fizruk> DMcGill: it seems to impossible to automatically derive IArray (because of parameter order for IArray)
05:40:16 <mauke> what's a subtotals?
05:40:19 <merijn> oddsignals: What do you mean by that?
05:40:23 <oddsignals> Right now I'm doing sortBy, then groupBy, then foldl, but it gets verbose and repetitive - especially when grouping by several fields
05:40:59 <fizruk> DMcGill: yes, you can still define bounds = bounds . unBox -- for BoxI
05:41:36 <DMcGill> fizruk: the problem is that if you look at the source IArray has about 10 methods defined but the haddocks only show bounds :S
05:42:28 <chrisdone> how do you view the ban list of a channel?
05:42:32 <chrisdone> all the -b entries
05:42:34 <chrisdone> er, +b
05:43:02 <chrisdone> n/m got it
05:44:04 <fizruk> DMcGill: haddock seem to generate only definitions with documentation...
05:44:49 <Rarrikins> I'm writing an instance method. When I recurse on it, it always uses the function I'm in rather than a polymorphic version. How can I get the polymorphic version?
05:44:54 <fizruk> DMcGill: do you actually need a newtype? =)
05:45:20 <merijn> Rarrikins: It should automatically use the appropriate polymorphic variant when applied to a different type\
05:45:33 <merijn> Rarrikins: Do you have a minimal example + error you can pastebin?
05:46:52 <DMcGill> fizruk: I'm defining my own custom Read for (Box (Maybe Int))
05:46:55 <DMcGill> so I think so
05:47:15 <fizruk> ok, I'll try another idea
05:47:17 <merijn> DMcGill: Why does it need to be a read instance?
05:47:29 <merijn> DMcGill: Why not just "someFunction :: String -> Box (Maybe Int)"?
05:47:39 <DMcGill> I suppose I should just so that
05:47:43 <DMcGill> and get rid of the newtype
05:48:28 <DMcGill> thanks for the suggestions people
05:48:29 <Rarrikins> merijn: It's for parseJSON :: Value -> Parser a in Aeson. I give it a Value when I recurse, but that allows calling the same instance's parseJSON again without a type error.
05:49:27 <merijn> Rarrikins: oh, are you calling a function polymorphic in the return type?
05:50:13 <Rarrikins> merijn: Yes
05:51:20 <merijn> Rarrikins: Have you tried adding a type annotation to force the result type?
05:51:43 <merijn> Rarrikins: i.e. change "parseJSON foo" into "(parseJSON foo :: Parser MyType)"
05:53:03 <Rarrikins> merijn: Well, the instance is for a container type which can hold anything.
05:53:22 <oddsignals> merijn: mauke: Here's a code sample with what I'm using now that I'm trying to simplify: http://pastebin.com/RS4qRapT
05:53:23 <mauke> The paste RS4qRapT has been copied to http://lpaste.net/93295
05:54:17 <Rarrikins> Is there a way to use the type variables of the current function in a type annotation?
05:54:31 <monoidal> Rarrikins: ScopedTypeVariables
05:56:17 <Eduard_Munteanu> :t asTypeOf   -- for simpler stuff
05:56:18 <lambdabot> a -> a -> a
05:57:47 <mauke> you can have a lot of fun with local custom type constraints
05:58:02 <mauke> foo = bar where deref :: Ptr a -> a; deref = undefined  -- e.g.
05:59:28 <Eduard_Munteanu> mauke: and Ptr is a newtype, right?
05:59:38 <mauke> doesn't matter
05:59:40 <mauke> @src Ptr
05:59:40 <lambdabot> data Ptr a = Ptr Addr#
05:59:43 <mauke> apparently not
05:59:50 <Eduard_Munteanu> Hm.
06:01:04 <Eduard_Munteanu> Not sure I get it, unless that's completely polymorphic in 'a' as well.
06:02:10 <Eduard_Munteanu> Nevermind.
06:03:33 <mauke> :t sizeOf
06:03:45 <lambdabot>     Not in scope: `sizeOf'
06:03:45 <lambdabot>     Perhaps you meant one of these:
06:03:45 <lambdabot>       `IM.size' (imported from Data.IntMap),
06:04:20 <int-e> :t Foreign.Storable.sizeOf
06:04:21 <lambdabot> Foreign.Storable.Storable a => a -> Int
06:04:39 <DMcGill> is the a filter on Comonads? filterW :: Comonad w => (a -> Bool) -> w a -> [a]
06:05:15 <DMcGill> I have a Pointer (which is an Array with an index to form a comonad)
06:06:29 <DMcGill> and I'd like to filter based on the current cell I'm in like: rows = -- all other cells with the same row index; cols etc
06:06:30 <Eduard_Munteanu> DMcGill: I don't think that type works, for arbitrary comonads.
06:06:44 <Eduard_Munteanu> Well, it does but trivially.
06:06:52 <DMcGill> Array has a foldable or traversable instance right?
06:07:55 <Eduard_Munteanu> DMcGill: yeah, it should
06:08:01 <DMcGill> I can't see one. Hmm, I'm sure lens can do what I want to do
06:08:53 <Rarrikins> I finally got it. Thanks everyone.
06:10:43 <DMcGill> ComonadStore does what I want I think :)
06:11:43 <Eduard_Munteanu> DMcGill: yeah, assuming you mean the typeclass ComonadStore, not the comonad itself.
06:12:37 <DMcGill> I do
06:13:35 <ibotty> hi, i have a kind of problem with aeson's FromJSON and newtypes
06:13:36 <Eduard_Munteanu> DMcGill: I think a Cotraversable would also do
06:13:39 <ibotty> paste is here
06:13:40 <ibotty> http://lpaste.net/93296
06:14:00 <ibotty> the problem is, that i find the double fmap kind of unelegant
06:14:05 <ibotty> is there a nicer way?
06:14:33 <ibotty> (i newtype, because i don't want orphan instances: A is external)
06:14:40 <DMcGill> is Cotraversable on Hackage?
06:14:54 <Eduard_Munteanu> DMcGill: dunno, I was looking for it too
06:15:26 <ibotty> (and relatedly: is it possible to derive them with th in aeson?)
06:16:37 <Eduard_Munteanu> ibotty: aeson lets you automate that if you derive Data IIRC
06:19:20 <ibotty> sorry, what do you mean?
06:19:30 <ibotty> using deriving not th?
06:20:08 <Eduard_Munteanu> ibotty: http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Generic.html
06:22:23 <ibotty> i'll have a look. thanks
06:23:17 <craigInnes> Hi, I am currently trying to learn how to use haskell-src-exts to do some basic parsing and extracting of values. I am new to haskell and finding the documentation a bit difficult to navigate. I have used the parseFile function to parse a file and obtain a result of type "ParseResult (Module SrcSpanInfo)" and am now trying to figure out how to investigate particular values of the parse tree and manipulate them. Can any one point me in the ge
06:23:17 <craigInnes> neral direction of the kind of functions and data I should be looking for in the documentation in order to do this? Thanks
06:23:32 <supki> ibotty: well,  fmap f . fmap g = fmap (f . g)
06:23:42 <supki> ibotty: this could save you one fmap in both functions
06:25:36 <boothead> Hi Guys, can anyone tell me what Predicate `xxx` used as a type means?
06:26:06 <boothead> I have this as a type signature: eventSeries :: (Monad m, Serial m e) => Serial m (Event e)
06:26:29 <Eduard_Munteanu> boothead: how's that defined or where did you see that?
06:26:36 <mauke> boothead: is Serial a class or a type?
06:28:14 <Maior> well this is odd; I have a function `fluffle f = printf "%c" $ (floor f :: Int)` that I defined as `fluffle _ = "x"` for debugging purposes; when building with that definition of `fluffle`, ghc started using about a gig of RAM before I had to kill it
06:28:28 <Maior> I assume that was because it was doing some crazy optimisation?
06:31:11 <Maior> though actually it still does it with -O0
06:31:44 <boothead> mauke, Serial is a class
06:31:56 <mauke> boothead: then what is Serial m (Event e) supposed to do?
06:31:59 * hackagebot structural-induction 0.1.1 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.1.1 (DanRosen)
06:32:04 <boothead> Eduard_Munteanu, i'm attempting to write it myself
06:32:34 <boothead> mauke, I'm trying to make a function that says if Serial m e then I'm returning and instance of Serial m (Event e)
06:32:50 <mauke> which instance?
06:33:21 <mauke> wait, Serial m (Event e) is not a class
06:33:24 <mauke> it doesn't have instances
06:33:42 <mauke> what is even going on
06:34:14 <boothead> mauke, no I was defining a method and moved it out of the instance declaration... I gues there's my problem :-)
06:35:24 <ibotty> supki: thanks for your pointer. but i don't see it now. how can i remove the superfluous fmap in parseJSON (Object v) = fmap N $ A <$> v .: "a" <*> v .: "b"
06:36:06 <mauke> N <$> A <$> ...
06:36:08 <mauke> N . A <$>
06:36:26 <DMcGill> is there a shortcut for (\x -> 3*(div x 3))
06:36:31 <DMcGill> some kind of 'floor to the nearest 3)
06:36:36 <boothead> mauke, actually I do have instance Serial m a => Serial m (Event a). How can I say that my function returns one of those instances?
06:36:51 <mauke> boothead: that makes no sense
06:36:55 <mauke> boothead: functions return values
06:36:59 <ibotty> but there is no N <$> A <$>
06:37:12 <mauke> ibotty: what
06:37:23 <int-e> DMcGill: no. you can make it pointfree, (3 *) . (`div` 3), but I'm not sure that's an improvement.
06:37:26 <DMcGill> boothead: do you mean to make that instance call your function?
06:37:30 <ibotty> well. in a way it is. (with fmap)... but i don't see it
06:37:54 <mauke> what is there to see?
06:38:18 <ibotty> parseJSON (Object v) = fmap N $ A <$> v .: "a" <*> v .: "b"  -- correct
06:38:34 <ibotty> parseJSON (Object v) = (N . A) <$> v .: "a" <*> v .: "b" -- not correct
06:38:49 <ibotty> maybe i am just a little dense today
06:39:04 <Yuu-chan> What's the best way to read two integers from the input? Like int a, b; std::cin >> a >> b; in C++
06:39:14 <boothead> DMcGill, mauke: Gah... It should be Series m (Event e) in the return value... An off by two error :-)
06:39:32 <mauke> Yuu-chan: the behavior of cin >> in C++ is so fucked up I'm not even sure how to emulate it in Haskell
06:40:02 <quicksilver> readLn migh be the answer Yuu-chan wants, though
06:40:07 <opqdonut> mauke: readLn will read a line from stdin and parse it
06:40:08 <quicksilver> a <- readLn; b <- readLn
06:40:09 <opqdonut> oops
06:40:15 <opqdonut> Yuu-chan: readLn will read a line from stdin and parse it
06:40:41 <Yuu-chan> Doesn't readLn read line to the newline?
06:40:47 <opqdonut> yes
06:41:09 <Yuu-chan> Two integers are on the same line, like 4 5
06:41:11 <opqdonut> if you want the integers to be separated with a space, you should use getLine and words
06:41:32 <mauke> Yuu-chan: that sounds like a bad user interface
06:41:51 <opqdonut> > map read $ words "4 5"    :: [Int]
06:41:53 <Yuu-chan> I tried [a, b] <- map read . words <$> getLine, but now I'm need to optimize the program
06:42:17 <Yuu-chan> mauke: that's a typical input in many programmer contests :(
06:42:19 <opqdonut> that is pretty much the simplest way to do it
06:42:22 <mauke> Yuu-chan: true
06:42:42 <mauke> Yuu-chan: is that the bottleneck in your code?
06:42:46 <opqdonut> if you are reading a large text file you should probably use Data.Text instead of String
06:43:34 <merijn> s/probably/definitely
06:43:41 <opqdonut> :)
06:43:43 <Yuu-chan> Haskell standard IO is a real bottleneck in many tasks from there :(
06:43:45 <quchen> Yuu-chan: Careful with patterns like [a,b]. Your program above crashes when the user enters three digits like "./foo 1 2 3".
06:43:53 <merijn> Yuu-chan: Never use String for file input, use Data.Text
06:44:06 <Yuu-chan> quchen: I know, but here the input format is strictly defined
06:44:36 <merijn> Yuu-chan: Also, you might want to use a better parsing library than just "read" :)
06:44:42 <ibotty> mauke: The problem is that i don't have N <$> A <$> a <*> b but N <$> (A <$> a <*> b)
06:44:44 <quchen> Yuu-chan: Then case-match on the result, for example. Or use a pattern like (a:b:_), which at least won't crash for *more* numbers (but still for less).
06:44:48 <merijn> There's Text.Read.readMaybe in ghc 7.6
06:45:03 <merijn> And parsec and friends are pretty easy
06:45:08 <Yuu-chan> merijn: I actually need to read numbers usually
06:45:11 <ibotty> that's surely possible. but i don't see how...
06:46:03 <mauke> quchen: there's no point in case matching. and (a:b:_) is even worse
06:46:05 <monoidal> I guess that Yuu-chan is using some online programming judges, where the input format is strictly restricted
06:46:15 <Yuu-chan> Another problem is that the checking server runs the naked GHC. No mtl, no text, no attoparsec...
06:46:17 <monoidal> so there's no need in worrying about partiality of [a,b]
06:46:23 <mauke> Yuu-chan: and no -O2?
06:46:26 <Yuu-chan> monoidal: that's right.
06:46:43 <quchen> mauke: Why is there "no point" in matching?
06:46:54 <Yuu-chan> ghc -v0 -O
06:46:59 <mauke> quchen: what are you going to do if it doesn't match?
06:47:26 <quchen> mauke: Handle it? Terminate with something other than a pattern mismatch exception?
06:47:33 <mauke> quchen: handle it how?
06:47:43 <mauke> quchen: and what's the point of terminating "nicely"?
06:47:46 <monoidal> quchen: in Yuu-chan's situation, there's no problem in terminating with an exception
06:48:14 <quchen> monoidal: Oh, there's more to that code? Looks like I came in too late then
06:48:51 <mauke> :t \n a x y -> n <$> (a <$> x <*> y)
06:49:41 <mauke> preflex: seen lambdabot
06:49:42 <preflex>  lambdabot was last seen on #haskell 45 minutes and 20 seconds ago, saying: Foreign.Storable.Storable a => a -> Int
06:50:05 <mauke> preflex: seen elliott
06:50:05 <preflex>  elliott was last seen on #haskell 7 hours, 44 minutes and 13 seconds ago, saying: haasn: fmap = over _Identity
06:50:57 <blippeds> Can anyone tell me if there is a significance to using xs as the variable?
06:51:14 <merijn> blippeds: one list multiple listS, one x multiple xS :)
06:51:29 <blippeds> ahh ok, just seen it in two books now and wondering
06:51:33 <blippeds> thanks
06:52:30 <merijn> blippeds: Commonly it's used for lists where you don't know the type of element, since "someElement" isn't really more descriptive than "x" and if you think of "xs" as plural of 'x', then patterns like "map f (x:xs)" should be clear :)
06:53:08 <merijn> blippeds: The same goes for stuff like "a:as" or just "as/bs/xs" when not pattern matching, but still refering to a list/collection
06:54:37 <blippeds> thanks again! There isn't an upvote system here?
06:54:55 <quchen> There is! It's used by saying "<nick>, thanks"
06:55:09 <mauke> our bots do track karma
06:55:13 <merijn> quchen: You forgot about "<nick>++" for @karma :p
06:55:30 <quchen> merijn: No, I didn't *forget*.
06:55:41 <mauke> quchen++
06:55:46 <blippeds> <merijn>++
06:55:54 <mauke> blippeds: fail
06:56:02 <blippeds> merijn++
06:56:06 <Yuu-chan> mauke++
06:56:08 <mauke> blippeds: success
06:56:21 <mauke> preflex: karma merijn
06:56:22 <preflex>  merijn: 15
06:56:53 <Yuu-chan> Too imperative.
06:57:02 <quchen> Next time someone helps me instead of thanking him I'll give him an upvote on a piece of paper which I am going to print right now.
06:57:09 <t7> Yuu-chan: nah its in the IRC monad
06:57:27 <sipa> functional karma would make it a function of time
06:57:32 <DMcGill> box s = let (x,y) = pos s in [peek (x'',y'') s | let x' = 3*(div x 3); y' = 3*(div y 3), x'' <- [x'..x'+2], y'' <- [y'..y'+2], x'' /= x || y'' /= y]
06:57:47 <DMcGill> get the 3x3 box that the pointer is in from a sukoku 9x9 grid
06:57:57 <DMcGill> it's pretty gross though, any suggestions?
06:58:17 <quchen> 1. Use Array or Vector+Ix
06:58:31 <DMcGill> x' and y' are the top left corner of each 3x3 box
06:58:40 <quchen> 2. Aggregate coordinates, 3. slice away
06:59:20 <DMcGill> what do you mean by "aggregate coordinates"?
07:00:14 <merijn> blippeds: Incidentally, other common mnemonics are f/g/h for functions (e.g. map f (x:xs) = ...), i/j for numeric indices (e.g. drop i (x:xs) = ...) and l for lists
07:00:28 <DMcGill> and I'm using Pointer which is a wrapper around Array with an index - runPointer :: Pointer i a -> (Array i a, i)
07:00:50 <DMcGill> merijn: don't forget f for functors!
07:00:55 <quchen> What I meant was pretty much "do the same thing but split it over multiple lines and give things expressive names".
07:01:05 <merijn> blippeds: and x' is frequently used to refer to updated values of the original variable x
07:01:15 <DMcGill> ah ok. It was nice for the simpler case though: [peek (x',y) s | x' <- [0..8], x /= x']
07:01:25 <DMcGill> that's col s
07:01:38 <DMcGill> but I suppose for boxes I'd better split it up a little
07:02:12 <oddsignals> I tried to find a better phrasing for my question and posted it on StackOverflow ( http://stackoverflow.com/questions/18960504 ) - thankful for any suggestions here as well :)
07:03:32 <merijn> oddsignals: oh, that's a nice question.
07:04:04 <merijn> I think that should be possible with ExistentialQuantification, lemme ponder this
07:04:13 <Raydiation> that lambda calculus stuff is actually something pretty awesome but its not something that you would think of intuitively
07:05:47 <DMcGill> merijn: refresh the stackoverflow page, a nice solution has already been posted
07:05:48 <Maior> @hoogle Int -> Float
07:05:57 <DMcGill> Maior: fromIntegral
07:06:01 <Maior> thanks!
07:06:10 <DMcGill> > fromIntegral (3 :: Int) :: Float
07:06:20 <DMcGill> > fromIntegral (3 :: Int) :: Float
07:06:28 <DMcGill> > (fromIntegral (3 :: Int)) :: Float
07:06:51 <merijn> DMcGill: I don't like that one
07:06:55 <Maior> and now my raytracer kinda works
07:07:05 <merijn> DMcGill: I like the sortAndGroup function and that should be possible
07:07:11 <Raydiation> @hoogle Float -> Int
07:07:22 <Raydiation> hm, no bot?
07:07:33 <DMcGill> Raydiation: you probably want round or floor
07:07:36 <DMcGill> or ceil
07:07:48 <Raydiation> DMcGill: ty
07:08:14 <DMcGill> it's 'ceiling', not 'ceil' actually
07:09:31 <Raydiation> btw, do you think knowing FP and OOP will be future proof enough?
07:09:58 <Raydiation> as in you dont have to learn a new concept in the next 30 years
07:09:59 <Yuu-chan> Yay! I've rewrite my solution using ByteString IO and readInt and now it passes the time limit.
07:10:06 <mauke> Raydiation: ...
07:10:23 <merijn> bah
07:10:24 <DMcGill> much like building hardware, you can't really futureproof programming knowledge imo. Sure, a fortraner from 30 years ago could still get employment now if they'd never learnt anything new in all that time
07:10:31 <merijn> Why can't I have existential newtypes?
07:10:34 <mauke> yes, that's exactly why people learn Haskell: so they don't have to learn anything new for the next 30 years
07:10:36 <merijn> Lame
07:11:02 <oddsignals> merijn: thanks for looking into it :)
07:11:13 <Raydiation> mauke: learning new concepts is always hard and time intensive
07:11:19 <mauke> uh huh
07:13:18 <Raydiation> took me more than one year to grasp how to do OOP properly
07:13:49 <Raydiation> learning ruby took me like 2 weeks
07:14:32 <argiopeweb> Raydiation: Are you planning on being locked on a desert island and forced to program in the near future? Your learning vs. using timescale is rather tight...
07:16:20 <merijn> oddsignals: hmm, if it is possible it's not as obvious as I thought and I can't spend too much time on it, sorry
07:18:06 <merijn> Raydiation: tbh, I don't think either are comparable. I think OOP is not even current proof, the common things considered are OOP are already terrible and useless to learn. Most of the things you learn during FP are not really FP specific and will still be valid centuries from now
07:18:08 <oddsignals> merijn: np, thanks for trying!
07:18:35 <monoidal> merijn: http://ghc.haskell.org/trac/ghc/ticket/3701
07:19:30 <merijn> oddsignals: You can probably do it using a GADT based heterogeneous list, but that wouldn't actually save you any typing, so that's hardly worth it
07:19:39 <merijn> monoidal: oooh, they're coming any moment now? <3
07:20:30 <monoidal> merijn: unfortunately, the ticket # says something about the age of this bug
07:20:37 <monoidal> merijn: there's also http://ghc.haskell.org/trac/ghc/ticket/1965
07:27:07 <DMcGill> ahhh, "Pointer (Int,Int) (Maybe Int) -> Maybe (Pointer (Int,Int) Int)" is exactly what Cotraversable would be!
07:27:12 <DMcGill> but it doesn't exist :(
07:28:02 <merijn> DMcGill: Time to publish a library!
07:28:16 <RichyB> I was about to ask how on Earth you'd define Storable (Int, Int) but then I noticed that "Pointer" is not "Ptr"
07:29:07 <DMcGill> http://irc-logs.googlecode.com/svn-history/r51/trunk/logs/freenode/haskell/2011/2011-01-05
07:31:36 <DMcGill> Ix gives you an isomorphism between (Int,Int) and Int anyway
07:32:02 <DMcGill> well, close enough
07:32:28 <supki> DMcGill: Cotraversable exists, it's called Distributive
07:33:39 <DMcGill> I'm much more in favour of intuitative names for things than category theory inspired ones
07:34:12 <DMcGill> I guess this is the downside of them! Thanks supki
07:35:10 <oddsignals> @pl f s c = map (foldl1' s) . (g c)
07:36:59 <kqr> if i want to do simple search and replace operations with regexes in haskell, is it Text.Regex i should turn to?
07:37:13 <DMcGill> new problem: there's no Ix i => instance Distributive (Pointer i)
07:37:30 <DMcGill> or it'd be PointerT technically but what's an Identity monad between friends?
07:38:13 <DMcGill> it must be deliberate since there's no ComonadZip instance either
07:38:18 <chrisdone> > snd $ foldr (\x (c,xs) -> case x of '>' -> (flip const,xs); '<' -> ((:),xs); _ -> (c,c x xs)) ((:),[]) "foo<bar><mu>zot</mu></bar>bob"
07:38:36 <chrisdone> i just wrote this. that guy earlier was asking for a similar fold. heh
07:38:41 <enthropy> kqr: I don't think it does replacements
07:39:09 <chrisdone> (strips out the html tags)
07:39:33 <kqr> enthropy, with subRegex it does
07:39:51 <enthropy> good to know
07:42:05 * hackagebot monad-extras 0.3.0.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.3.0.0 (JohnWiegley)
07:42:08 * hackagebot monad-extras 0.4.0.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.4.0.0 (JohnWiegley)
07:46:48 <merijn> johnw: Forgot to update the version field? :p
07:47:00 <johnw> didn't realize there was a pending pull request
07:47:06 <johnw> so I just merged that in and updated again
07:49:09 <bscarlet> oddsignals: How about something based on (Map.toList . Map.fromListWith (<>))?
07:50:18 <Raydiation> cabal dependency management is pretty bad :/
07:50:31 <DMcGill> hmm, I still don't grok Comonads completely. How would I do andW :: Ix i => Pointer i Bool -> Bool
07:51:02 <DMcGill> I suppose I could just ignore the comonad and iterate over the array
07:51:08 <DMcGill> fold over the array even
07:51:59 <bscarlet> oddsignals: e.g. http://lpaste.net/93299
07:52:46 <DMcGill> no instance for Ix i => Foldable (Array i) in Data.Foldable or Data.Array. Is there an orphan instance somewhere and how could I search for it?
07:53:47 <tailcalled> cabal install cabal cabal-install should update cabal, right?
07:54:42 <kqr> what is the suggested style for partially applying something like elem? "(`elem` xs)" or "flip elem xs"?
07:55:09 <Yuu-chan> kqr: I'd prefer the former one
07:55:29 <Iceland_jack> kqr: I personally don't have a preference one way or the other
07:55:30 <Raydiation> whats the type signature for main = putStrLn "Hello World"
07:55:33 <Yuu-chan> Sections are nice.
07:55:39 <Iceland_jack> Raydiation: main :: IO ()
07:55:40 <monoidal> kqr: `elem` is usually used infix, so I would use the first
07:55:41 <Yuu-chan> Raydiation: IO ()
07:55:42 <Raydiation> ty
07:55:44 <kqr> i've found i'm using flip more and more, and at some point it almost feels like i'm abusing it when a section might look better
07:55:54 <Iceland_jack> but when the right part grows I prefer to use an anonymous function
07:56:00 <monoidal> Raydiation: you can write :t putStrLn "Hello World" to check this.
07:56:18 <Raydiation> IO () basically means side effect operation with no type?
07:56:23 <kqr> Raydiation, ":t" is short for ":type" to help out with the memory bit of it
07:56:31 <Raydiation> ty
07:56:37 <Iceland_jack> Raydiation: That a value of type ()
07:56:40 <monoidal> Raydiation: somewhat. It is similar to a void function in C
07:56:44 <Iceland_jack> where () is analogous to void
07:56:46 <Raydiation> ty
07:57:28 <Raydiation> btw, the do notation looks like imperative programming
07:57:30 <kqr> Raydiation, the value () is often called "unit value" or "unit type" depending on context. the unit type is a type that consist of only a single value – the unit value. both are written () in haskell
07:57:40 <kqr> yes, the do notation is designed to look imperative
07:58:05 <Raydiation> so i use that in my main function to do all the IO and then use pure functions in other haskell files?
07:58:24 <kqr> or in the same file
07:58:29 <kqr> you might need more than one IO function as well
07:58:37 <Raydiation> where do i put database queries?
07:58:44 <kqr> but keeping the number of functions that do IO down is usually a good idea
07:58:45 <Raydiation> usually id create a db layer
07:59:08 <Raydiation> doesnt this turn everything into impure functions if its the lowest layer?
07:59:20 <Eduard_Munteanu> Raydiation: that can be a monad transformer, if you want separation
07:59:22 <Raydiation> i mean everything above
07:59:23 <DMcGill> ok so the docs for Data.Foldable don't list all the instances that are defined in the source
07:59:24 <DMcGill> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html
07:59:52 <DMcGill> specifically for Array i
07:59:56 <DMcGill> why is this?
08:00:18 <Raydiation> so i can create a function that takes the IO monad which turns it into a pure function?
08:00:31 <Iceland_jack> No
08:00:31 <Eduard_Munteanu> Raydiation: no
08:00:40 <DMcGill> Raydiation: use "<-" inside a do-block
08:00:47 <kqr> Raydiation, you can't do IO and then pretend the function is pure
08:01:03 <DMcGill> it's not what you asked for, but I'm pretty sure it's what you want
08:01:05 <kqr> Raydiation, however, you can, in an IO function, temporarily make values pure and pass them as arguments to pure functions
08:01:46 <Raydiation> thought so
08:02:37 <Raydiation> do you use something like mvc in haskell?
08:03:00 <Eduard_Munteanu> Raydiation: you can make or pretend that you have a monad that only does specific IO ops, like db queries.
08:03:17 <Iceland_jack> Eduard_Munteanu: That's probably too advanced
08:03:49 <Raydiation> i mean essentially the structure is request -> controller -> service layer -> database layer
08:03:58 <Raydiation> so everything in there will be impure
08:04:58 <Eduard_Munteanu> Raydiation: sure, you can abstract stuff. Don't expect a 1-to-1 mapping with OOP though.
08:05:18 <DMcGill> There's no isLeft in Data.Either? either (const True) (const False) will have to do unless I want to start with Prisms I suppose
08:05:38 <chrisdone> new haskellcast episode  yaaaaaaaaaaaaaaaaaay
08:05:39 <Raydiation> is there a different way to do this in haskell?
08:05:49 <chrisdone> (ღ˘⌣˘ღ) ♫･*:.｡. .｡.:*･
08:06:06 <chrisdone> http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/
08:06:15 <dwcook> Is there some type that represents functions known to halt?
08:06:32 <DMcGill> dwcook: no http://en.wikipedia.org/wiki/Halting_problem
08:06:34 <merijn> DMcGill: There was a bikeshed discussion on the list to add that, but it wasn't added in the end, I think
08:06:43 <merijn> DMcGill: How does that link help
08:06:45 <dwcook> DMcGill, obviously you'd need to use a subset of the computable functions.
08:06:47 <Eduard_Munteanu> DMcGill: consider using Applicative and Alternative instead, and a more parser-combinator-y approach, perhaps?
08:06:48 <kqr> chrisdone, super yay!
08:06:59 <chrisdone> yaaay
08:07:00 <merijn> DMcGill: Anyhoo, if you have a list of Either's you could use lefts/rights
08:07:26 <monoidal> dwcook: in type systems stronger than Haskell, -> represents such functions
08:07:27 <merijn> dwcook: I don't think there's a way to encode totality in Haskell, you might be interested in Agda/Coq? Those do guarantee totality on functions
08:07:51 <Eduard_Munteanu> dwcook: you can sort of do that at the type level, that's as far as termination checking "exists" in Haskell.
08:07:53 <kqr> chrisdone, are you the chris of the podcast or an unrelated chris?
08:08:19 <chrisdone> i am an unrelated chris
08:08:30 <kqr> okay
08:08:36 <dwcook> I'm not looking for type-level totality, just a procedure-like type whose values consists of operations that, assuming there are no undefined values, are known (beyond the type system) to halt.
08:08:39 <kqr> third chris here who just thinks the cast is awesome
08:08:41 <bergmark> oh yes beer+haskellcast
08:09:08 <merijn> dwcook: That doesn't exist, at least not as far as I know
08:09:10 <Eduard_Munteanu> dwcook: no, not really then, unless you implement an EDSL and run manually constructed terms.
08:09:22 <kqr> Raydiation, generally there's much less impurity than you think, but i can't help you more than that (especially since i'm not very well versed with the MVC workflow)
08:09:24 <dwcook> Eduard_Munteanu, that's precisely the sort of thing I'm looking for, actually.
08:10:30 <Eduard_Munteanu> dwcook: well, an easy example is an SKI calculus evaluator, or a STLC evaluator. Those don't do recursion, unless you specifically add it.
08:11:08 <dwcook> For example, say you had Data Addition = Addition Addition Addition | Term Integer and a function runAddition :: Addition -> Integer. You have designed this in a way that it halts, modulo undefined.
08:11:23 <dwcook> Eduard_Munteanu, isn't SKI Turing complete?
08:11:43 <bergmark> Raydiation: you can always have pure domain logic, and then call that from your controller or w/e which has the whole monad stack
08:11:50 <merijn> dwcook: Yes, but the STLC example holds :)
08:12:03 <Eduard_Munteanu> What's fix in SKI? :/
08:12:18 <merijn> Eduard_Munteanu: I dunno, but I do remember SKI is Turing complete
08:13:03 <dwcook> There exists a conversion between SKI and LC, and LC is TC
08:13:07 <monoidal> Eduard_Munteanu, merijn: Y can be written as (\x -> x x) (\x -> f (x x)) or something to that effect. take pointless version of that.
08:13:28 <monoidal> of course, that requires *untyped* LC, typed LC without fix is not Turing complete
08:13:46 <dwcook> But yeah, the STLC example is indeed along the lines of what I'm looking for
08:14:25 <Raydiation> bergmark: ok ty
08:14:47 <Raydiation> any idea why this fails with Could not find module `Data.List.Utils': import Data.List.Utils (split)
08:15:25 <geekosaur> because you don't have the split package installed?
08:15:31 <monoidal> it's MissingH in fact
08:15:40 <geekosaur> (which is not the same thing as the function you're trying to import in there)
08:16:01 <Raydiation> geekosaur: when i remove the split it still fails
08:16:04 <monoidal> Raydiation: cabal install MissingH to get the package
08:16:08 <Raydiation> i see ty
08:16:13 <Raydiation> i thought it was built in
08:16:20 <Eduard_Munteanu> monoidal: that's omega IIRC, but sure, any fixed point combinator does.
08:16:24 <geekosaur> oh, hm, yes, MissimngH
08:16:26 <geekosaur> no
08:16:36 <merijn> dwcook: You can fairly easily use GADTs to provide an EDSL ala STLC in haskell
08:16:56 <monoidal> Eduard_Munteanu: note there's f sneaked: f (x x), omega IIRC has (\x -> x x) (\x -> x x)
08:16:57 <geekosaur> Platform comes with split, MissingH has gradually been whittled away although older code may still use it
08:17:04 <Eduard_Munteanu> Oh.
08:17:09 <Eduard_Munteanu> Yeah.
08:17:24 <dwcook> merijn, I'm unfamiliar with GADTs, can you elaborate?
08:18:26 <Eduard_Munteanu> dwcook: GADTs let you define a data type that contains only well-typed STLC terms, so you don't need to implement typechecking separately.
08:18:55 <dwcook> Eduard_Munteanu, isn't that no different from defining multiple cases of a type with data?
08:19:29 <merijn> dwcook: No, you can't define a "evaluate :: Expr a -> a" for normal datatypes
08:19:33 <Eduard_Munteanu> dwcook: no, since normal 'data' doesn't let you make indexed types.
08:19:34 <merijn> dwcook: You can do so for GADTs
08:20:09 <dwcook> merijn, you could just pattern match. I think I'm misunderstanding something.
08:20:18 <merijn> dwcook: Simple example "data Expr a = I Int", you can define "I 1 :: Expr Char" here
08:20:20 <Eduard_Munteanu> dwcook: indexed as in data constructors decide the type's parameters, not the type constructor.
08:20:39 <merijn> dwcook: Alternatively, "data Expr a = I a" doesn't let you guarantee the argument to I is an Int
08:20:46 <Raydiation> how do i pattern match an empty string? []?
08:20:54 <dwcook> Raydiation, yes, that will work. Also ""
08:20:58 <Raydiation> ty
08:21:12 <merijn> dwcook: In the first case "eval (I x) = x" is a type error, in the second you can't enforce I taking an Int
08:22:06 * hackagebot standalone-haddock 1.1.4 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.4 (RomanCheplyaka)
08:22:10 <merijn> dwcook: GADTs let you write "data Expr a where I :: Int -> Expr Int" this guarantees that "I" can only create "Expr Int", thus making sure that "eval :: Expr a -> a" is correctly typed *and* guarantees the type of I is Int
08:22:49 <dwcook> Hmm. Can you provide an incorrect example that doesn't use GADTs?
08:23:29 <Raydiation> if i have the type [[String]] (list of list of strings) is [] a valid return?
08:23:32 <Eduard_Munteanu> dwcook: or  data HaveA a where GiveInt :: Int -> HaveA Int; GiveChar: Char -> HaveA Char   so you can have multiple constructors as well, in case that wasn't clear.
08:23:36 <danr> Raydiation: yes
08:23:39 <Raydiation> ty
08:24:02 <Eduard_Munteanu> dwcook: for example normal datatypes don't let you enforce application is well typed.
08:24:02 <merijn> dwcook: Given "eval :: Expr a -> a; eval (I x) = x" this will be wrong "eval (I 1 :: Expr Char)"
08:25:01 <dwcook> I'm still not getting what you're saying, so I think I'll play around with such DSLs a bit to see if it makes more sense then.
08:25:03 <burbul> @pf datumwise_outf f = return $ OutF (map $ f)
08:25:09 <burbul> @pl datumwise_outf f = return $ OutF (map $ f)
08:25:10 <lambdabot> Maybe you meant: pl bf
08:25:19 <lambdabot> datumwise_outf = id (fix (const ((return $) . OutF . (map $))))
08:25:29 <merijn> dwcook: There is a more elaborate example at: https://en.wikibooks.org/wiki/Haskell/GADT
08:25:29 <lambdabot> Plugin `pl' failed with: <<timeout>>
08:25:50 <Eduard_Munteanu> dwcook: http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype   too
08:25:54 <burbul> @pl datumwise_outf f = return $ OutF (map f)
08:26:03 <lambdabot> datumwise_outf = (return $) . OutF . map
08:26:13 <lambdabot> Plugin `pl' failed with: <<timeout>>
08:26:26 <burbul> :t return
08:26:31 <lambdabot> Monad m => a -> m a
08:26:38 <burbul> :t (return $)
08:26:45 <lambdabot> Monad m => a -> m a
08:27:01 <burbul> why does lambdabot refer to (return $)?
08:27:29 <ifthenelse> :buffer 1
08:27:49 <ksf> I *hate* when this happens. Everything works when I fix the type, otherwise a cryptic type error appears.
08:28:08 <geekosaur> burbul: note the timeout error. @pl is slightly wonky right now
08:28:16 <burbul> thanks
08:33:33 <DMcGill> Why don't the docs of Data.Foldable accurately report the instances defined in the source?
08:35:18 <Raydiation> why do i ge: tline 7, column 16:  Expecting one more argument to `[]'  https://dpaste.de/s7sNc/
08:35:46 <ksf> Raydiation, because [] isn't a type
08:35:47 <Raydiation> ah, maybe [a] -> [a]
08:35:56 <ksf> :k []
08:35:57 <lambdabot> * -> *
08:36:02 <ksf> yep, that's a type.
08:36:16 <Raydiation> ty
08:36:22 <ksf> [] is a type level function taking another type and returning a type.
08:45:40 <Raydiation> any reason why line 3 is printed out after line 4? https://dpaste.de/1UZ0k/#L3
08:46:00 <Raydiation> is there a difference between putStr and putStrLn?
08:46:12 <geekosaur> yes, putStrLn outputs a newline after
08:46:21 <Clint> the difference is Ln
08:46:31 <Raydiation> yeah but i get no output before it asks for input
08:46:35 <geekosaur> you probably want to flush the buffer (or set stdout unbuffered)
08:46:38 <Raydiation> if i use putStrLn works fine
08:46:50 <merijn> Raydiation: That's because input is line buffered
08:46:54 <geekosaur> by default it's going to be line-buffered to the terminal
08:46:54 <Raydiation> ah i see, so it flushes after \n
08:46:56 <quicksilver> and output, more to the point.
08:47:05 <merijn> Raydiation: Yes, you can turn off buffering using hSetBuffering
08:47:06 <quicksilver> but defaults are there to be changed.
08:47:36 <quicksilver> or just hFlush stdout
08:47:38 <merijn> Raydiation: Haskell's line buffering behavior was chosen to be compatible with that of C/python/etc.
08:47:50 <merijn> Right, hFlush works too
08:48:30 <elliott> note that this behaviour is inconsistent with c and python
08:48:34 <Raydiation> ty
08:48:45 <merijn> elliott: Eh, how so?
08:49:06 <merijn> elliott: Both Python and C are linebuffered by default
08:49:09 <geekosaur> C does ugly linking of filehandles so that stdout gets autoflushed before a read on stdin
08:49:17 <merijn> geekosaur: No, only C++ does that
08:49:27 <merijn> geekosaur: And maybe some hideous GNU stdlib's
08:49:37 <merijn> geekosaur: OSX/FreeBSD C won't flush stdout on input
08:49:40 <geekosaur> GNU does it, the old System V stdio did it
08:49:52 <geekosaur> BSDish (including OS X) may well have avoided that pit
08:49:55 <elliott> I know I am right because GHC HQ has said as much :P
08:50:28 <merijn> And I remember troubleshooting this same question in #python a bunch of times and python was mimicking C too
08:50:46 <merijn> s/and python/because python
08:50:50 <geekosaur> is it mimicking, or just using C's stdio?
08:50:55 <quicksilver> http://stackoverflow.com/questions/2123528/does-reading-from-stdin-flush-stdout
08:51:03 <quicksilver> geekosaur: GHC doesn't use stdio.
08:51:12 <geekosaur> I meant Python
08:51:22 <quicksilver> oh, python probably uses C stdio
08:51:22 <geekosaur> I know ghc doesn't and was in fact typing that...
08:51:53 <elliott> merijn: anyway there may be inter-libc disagreement; I think that is enough to prove you can't justify GHC's behaviour here as "to mimic C/Python" :p
08:52:22 <quicksilver> well it in mimicing it, just not in detail, IMO
08:52:31 <elliott> I meant this particular detail
08:52:33 <quicksilver> "line-buffered by default" is a common tradition
08:52:36 * elliott nods
08:52:46 <quicksilver> see the stackoverflow post
08:52:48 <merijn> elliott: tbh, I've never encountered a flushing C implementation, even on linux. But maybe I used the wrong reading function (like read instead of fread or something)
08:53:11 <quicksilver> it appears that the relevant standards certainly guarantee line-buffering but not the strange linked behaviour.
08:53:32 <quicksilver> OTOH beginner programmers in every language I've ever used get confused by the fact that this line-buffering is terminal only
08:53:43 <quicksilver> and things behave differently with non-terminal FDs such as pipes and sockets
08:53:49 <Raydiation> is import System.IO considered bad practice like using namespace std; in C++?
08:53:52 <elliott> also, GHC's notion of "no buffering" is not C's
08:54:01 <elliott> it also disables the *terminal's* line buffering
08:54:16 <merijn> Raydiation: Opinions differ, I like universal imports. Some masochists explicitly qualify everything
08:54:38 <geekosaur> or import only the names they're actually using
08:54:43 <merijn> elliott: That's the same as C, but C also supports a "half-cooked" mode
08:55:19 <merijn> Essentially C has 4 modes, block buffered, raw, cooked and some weird halfway between raw and cooked
08:55:44 <merijn> Note that that's a pty/tty specific notion, afaik
08:56:15 <Cale> Raydiation: If there's really just one thing that I need from a module, I might explicitly import just that, but for the most part, it's too obnoxious to import things one at a time.
08:56:16 <elliott> I am talking about setvbuf here
08:56:29 <merijn> Cale++
08:56:35 <elliott> which doesn't do anything terminal-specific AFAIK, but corresponds to hSetBuffering
08:56:43 <Cale> Oh, and when it comes to importing qualified, I guess it depends on the module.
08:56:55 <Cale> Some modules can't be imported unqualified, like Data.Map.
08:57:04 <Cale> System.IO won't have any troubles as far as I know.
08:57:19 <Raydiation> shouldnt your IDE handle this?
08:57:33 <Raydiation> basically do the proper imports
08:57:34 <Cale> (It depends on how much the names in that module overlap with the names in other ones)
08:57:39 <Cale> What IDE?
08:57:43 <Cale> I use vim :)
08:58:39 <mr-> importing qualified and importing explicitely really help when reading somebody else's code
08:58:50 <Cale> But personally, I usually try to avoid naming things in such a way that I'll have to import qualified
08:59:02 <Cale> Because explicit module qualifications on names are ugly
08:59:22 <Cale> (.) should be composition only ;)
08:59:37 <merijn> mr-: It depends
09:00:07 <merijn> mr-: Obscure things I will import explicitly, but stuff like Control.Applicative/Control.Arrow/Data.Traversable, et al. I don't see the point
09:00:54 <mr-> merijn: that's right
09:02:10 <ziman> is it possible/recommended to create asynchronous conduits? my usecase is a parallel http downloader where the output is quite decoupled from the stream of URLs.
09:02:18 * hackagebot monad-logger 0.3.2.0 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.2.0 (MichaelSnoyman)
09:02:19 <ziman> or should I go with a pair of Source+Sink?
09:03:52 <elliott> Cale: don't you mean mapping only? :)
09:04:19 <Cale> elliott: Yeah, I suppose. It should be some *generalisation* of composition in any case.
09:04:46 <Cale> Module qualification is something entirely different, so using '.' for that has always seemed out of place to me.
09:05:28 <merijn> Cale: Yes, but -> was already taken as lambda syntax ;p
09:05:29 <Raydiation> is data something like struct in C?
09:05:54 <merijn> Raydiation: It's something like a struct with a union and an enum that tells you which union variant is in use
09:06:34 <merijn> Raydiation: i.e. "data Either a b = Left a | Right b" would be a union of "Left a" and "Right a" with an enum indicating which is used
09:06:43 <merijn> eh, "Right b"
09:06:50 <Raydiation> what i dont quite get is why do i need to define a constructor like in data BookInfo = Book String which i then use by writing Book "my title"
09:07:14 <levi> You don't have to do that.
09:07:23 <Cale> You kind of do...
09:07:24 <Raydiation> wouldnt data Book = String suffice?
09:07:38 <levi> type Book = String
09:07:44 <quicksilver> you can do that - sort of - with the 'type' keyword
09:07:45 <merijn> levi: No, that's something different
09:07:51 <Cale> Raydiation: no, you're defining a type whose values are completely disjoint from every other
09:07:53 <quicksilver> but the reason for constructors is so that things have different types
09:08:02 <quicksilver> you want subexpressions to have different types
09:08:04 <levi> merijn: I know, but does he really want a new type?
09:08:15 <quicksilver> so (Book "my title") is a BookInfo, where ("my title") is just a String
09:08:18 <merijn> levi: Passing a "String" to "type Book = String" isn't a type error, with "data Book" it is
09:08:19 <Cale> Raydiation: The system needs a way to distinguish values of type BookInfo from values of type String
09:08:28 <merijn> levi: If he doesn't, then he'd probably want newtype
09:08:38 <merijn> levi: Then you at least get the typechecking
09:08:50 <Raydiation> is it so i can mix types?
09:08:57 <levi> merijn: I was going to get to that, until you assumed I was WRONG!!
09:08:57 <Cale> Raydiation: Also, consider the more general case:
09:09:15 <Raydiation> like BookInfo = Book String | DateBook String Date
09:09:46 <Cale> Raydiation: You can indeed do that
09:10:19 <Raydiation> but whenever i put BookInfo into the type signature i need to match both cases rases?
09:10:20 <Cale> That defines BookInfo with two data constructors,  Book :: String -> BookInfo, and DateBook :: String -> Date -> BookInfo
09:10:33 <merijn> #haskell hive mind, I need you to find me a link. I remember edwardk explaining how to use the Store comonad in the context of Pixel operations that could then be extended to cover an entire image, etc. Does anyone perchance know the link I'm talking about?
09:10:37 <Raydiation> s/rases/right?
09:10:41 <Cale> Ideally, unless you know for certain you won't get the other case.
09:10:42 <merijn> Since edwardk seems to be absent, the lazy bugger
09:11:13 <Cale> (even if you know you won't get the other case, you usually should at least put in proper error handling of some sort)
09:11:17 <Gracenotes> too busy discussing effects
09:11:17 <S11001001> merijn: ICFP vortex
09:11:53 <levi> merijn: Wouldn't happen to be something to do with his SoH articles on automata, would it?
09:12:10 <pqmodn> merijn: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1 ?
09:12:25 <levi> Yeah, those ones.
09:12:31 <merijn> levi: I thought it was before then? I remember him explaining something similar in SoH, yeah
09:12:53 <levi> That's the only thing that comes to mind, but there may very well be other things.
09:13:40 <merijn> hmm
09:14:30 <Raydiation> looking at: data Suit = Club | Diamond | Heart | Spade : those are all empty data constructors right?
09:14:38 <merijn> levi, pqmodn: Thanks anyway, I'll check that again
09:14:41 <merijn> Raydiation: Yes
09:14:48 <merijn> S11001001: I'm unsure what that refers too?
09:14:51 <Raydiation> are data constructors functions?
09:15:00 <dwcook> Raydiation, they can be, but those aren't.
09:15:03 <merijn> Raydiation: Sometimes (i.e. if they have more than 0 arguments)
09:15:05 <merijn> :t Just
09:15:06 <lambdabot> a -> Maybe a
09:15:10 <merijn> :t Left
09:15:11 <lambdabot> a -> Either a b
09:15:13 <dwcook> :t Nothing
09:15:14 <merijn> :t Nothing
09:15:14 <lambdabot> Maybe a
09:15:14 <Raydiation> i see, because i read void functions are a side effect
09:15:14 <lambdabot> Maybe a
09:15:45 <merijn> Raydiation: You might be interested in reading this blog post if you're thinking of "void functions" for data constructors
09:16:02 <merijn> @google conal elliott everything is a function in haskell
09:16:05 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:16:05 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
09:16:09 <Raydiation> ty
09:16:19 <dwcook> I was going to call it but couldn't remember the actual title
09:16:35 <S11001001> merijn: http://www.icfpconference.org/icfp2013/index.html
09:17:16 <Gracenotes> esp. http://www.haskell.org/haskell-symposium/2013/
09:17:41 <merijn> S11001001: I'm aware of ICFP, yeah. I was just wondering how that related to my question?
09:18:09 <S11001001> merijn: it was about where edwardk was :)
09:18:41 <merijn> Oh, I knew he was at ICFP, doesn't mean I can't call him lazy out of jealousy for not being able to attend ICFP :p
09:19:14 <S11001001> merijn: please, by all means :)
09:19:28 <Gracenotes> I can likely live-irc it
09:19:47 <Gracenotes> that's a thing, right. like a liveblog
09:20:04 <merijn> IRC is for live kibbitzing about crappy presenters
09:20:41 <Gracenotes> The panel is talking about if a strict Haskell would help effects be sane
09:21:27 <pqmodn> can someone point me to where i can learn (for myself) how to understand why P -> forall b. Q(b) is rewritten as forall b. P -> Q(b), (eg "quantifiers to the right of an arrow can be lifted"). i'd also like to figure out if they are equivalent, or does that only work in one direction? does Haskell arrange types that way just to write them in a canonical form, for unification or something?
09:23:13 <Gracenotes> largely just counterfactually, btw..
09:23:19 <merijn> pqmodn: Well, the English explanation is fairly obvious (to me), so I don't know how to explain it further. "P -> forall b. Q(b)" says that "if P is true, then Q(b) holds for all b", the other says "for all b, if P is true, Q(b) holds"
09:24:11 <merijn> pqmodn: Clearly if P means that "Q(b)" holds for *all* b, then it follows that "for every specific b, if P then Q(b)"
09:24:21 <jrslepak> so it's not an artifact of HM-like typing?
09:24:26 <pqmodn> merijn: i understand it at that level, but can it be proven? or is it an axiom in constructive logic? and can it be written with "iff" instead of "if"?
09:24:34 <merijn> pqmodn: Note, that afaik the reverse operation does *not* hold
09:24:50 <merijn> pqmodn: Or rather, I'm not sure about the reverse operation
09:24:56 <pqmodn> merijn: that's the part i struggle with most (the reverse)
09:25:30 <merijn> pqmodn: That I dunno, you'd have to wait for one of our resident mathematicians (or logicians) to show up
09:26:10 <pqmodn> merijn: fair enough! who are some people to bug about these questions, if i happen to see them?
09:32:39 <ksf> http://lpaste.net/93304     any type magician willing to tell me if there's a way to get rid of the type sig for "l"?
09:32:59 <merijn> pqmodn: I don't know specifically who loves those type of questions, but "prime time" for this channels is in 3 hours or so, so might wanna try again then
09:33:07 <ksf> (ghc 7.7 required)
09:33:14 <pqmodn> merijn: ok, thanks! :)
09:34:29 <ksf> pqmodn, well, the two are just equivalent.
09:34:30 <elliott> pqmodn: let's say that if (e :: forall a. t), where a can appear in t, we can write (e @ b) (where b is a type) having the type t[a := b], i.e. making the instantiation explicit; so if (length :: forall a. [a] -> Int) then (length @ String :: [String] -> Int)
09:34:34 <elliott> pqmodn: with me so far?
09:34:59 <elliott> (the reason I am introducing this notation is because it's hard to see in Haskell because quantification and instantiation are implicit at the term level)
09:35:26 <pqmodn> elliott: yes (that's familiar from Core's type application syntax)
09:36:36 * ksf realises he's hopelessly outclassed by elliot.
09:36:47 <elliott> pqmodn: right. then let's also introduce Core's type lambda syntax, if I remember it correctly -- given that e has type t (with "a" free), (\ @ a -> e) has type (forall a. t), and brings a into scope for e (so we can say e.g. (\ @ a -> \ (x :: a) -> x) for the identity function)
09:36:55 <elliott> ok?
09:37:50 <pqmodn> okay, yep
09:38:29 <elliott> pqmodn: then we can construct the isomorphism; one way: f :: (P -> forall b. Q b) -> (forall b. P -> Q b); f = \k -> \@b -> \p -> k p @ Q b
09:38:53 <elliott> the other way: g :: (forall b. P -> Q b) -> (P -> forall b. Q b); g = \k -> \p -> \@b -> k p @ Q b
09:39:11 <elliott> you can maybe see now that this basically just corresponds to "flip"
09:39:17 <elliott> just one of the arguments is a type argument, not a value argument
09:39:32 <pqmodn> yeah, that's surprisingly simple!
09:39:32 <elliott> in a dependently-typed langauge this is clearer. and you don't need to introduce special notation for type abstraction/application :)
09:39:49 <elliott> in actual Haskell, you can just write f k = k and g k = k, I think.
09:39:57 <elliott> and then if you look at the Core, it might write something like my terms under the hood.
09:41:45 <ystael> elliott: i was curious about the same thing so i tried writing it out in agda but given your explanation i feel like i missed the point
09:41:52 <ystael> because it seemed like it was really just flip
09:41:54 <ystael> http://lpaste.net/93305
09:42:01 <elliott> yep
09:42:12 <elliott> if your "forall" really is just a (dependent) function type, then it's flip :)
09:42:35 <ystael> ah, ok, that's what's going on then
09:42:37 <elliott> but in Haskell types are second-class, so we need to introduce notation to talk about what happens when the quantifiers get implicitly shuffled around.
09:43:29 <pqmodn> can it be proven that (forall b. Q(b)) -> P cannot be converted to (or from) forall b. Q(b) -> P? this isn't like flip because the first argument is like a higher-order function i think. i don't quite have a grasp on how to prove things false with constructive logic
09:44:19 <elliott> pqmodn: consider (\k -> makeP (k @ String) (k @ Int))
09:44:26 <elliott> that uses the (forall b. Q b) at both Q String and Q Int
09:44:33 <monoidal> pqmodn: think about a sentence in first order logic
09:44:37 <elliott> and in particular, the body of the function gets to choose.
09:44:47 <elliott> with the forall on the outside like that, the /caller/ of the function gets to choose a (single) b that it can use
09:45:02 <elliott> think of quantifiers in terms of who gets the power to choose
09:45:19 <Raydiation> is <- only for IO types?
09:45:27 <monoidal> Raydiation: no, any monad
09:45:28 <elliott> ((forall b. Q b) -> P) -- "give this function a way to get (Q b) for any b it chooses, it will give you a P"
09:45:42 <elliott> (forall b. Q b -> P) -- "give this function a (Q b) for any b you choose, it will give you a P"
09:46:03 <Raydiation> monoidal: is it just syntactic sugar for calling fmap?
09:46:17 <monoidal> Raydiation: syntactic sugar for calling (>>=)
09:46:28 <pqmodn> elliott: that makes sense, but how can it be shown that they're not equivalent? by instantiating the quantified variable and showing the result isn't equivalent?
09:46:31 <monoidal> Raydiation: ... x <- expr ... is the same as ... expr >>= (\x -> ...)
09:47:03 <Raydiation> ty
09:47:24 <quinso> Why do people use HTF when there is quickcheck?
09:47:47 <pqmodn> elliott: also, thanks so much. i've been tripping on the first problem for months!
09:48:16 <seanparsons> Am I understanding cabal correctly in that if I have multiple "projects" within one cabal file it doesn't have transitive dependencies between them?
09:48:30 <elliott> pqmodn: to show that it is not true for all "P"s and "Q"s in general, I suggest picking P = Void (aka False) and Q cunningly.
09:48:36 <seanparsons> I'm finding myself duplicating dependencies for a test-suite, which seems wrong.
09:48:43 <DMcGill> does trace significantly slow down optimised code?
09:49:17 <elliott> pqmodn: for example. pick Q = identity. you can write ((forall b. b) -> Void) easily. (forall b. b -> Void) on the other hand, you cannot.
09:50:24 <elliott> this means you can construct (forall p q. ((forall b. q b) -> p) -> (forall b. q b -> p)) -> Void. though I suggest writing proofs like this in Coq or Agda, it's really so much nicer and you can't cheat :p
09:51:12 <Raydiation> what is Just? a simple container for a value?
09:51:33 <seanparsons> Raydiation: A way to represent if a value exists or not.
09:52:01 <pqmodn> elliott: that makes sense! wow, thanks. hopefully this toy problem gives me the motive for trying out Coq or Agda, i've wanted to for a long time.
09:52:19 <DMcGill> I'm getting a "MArray: undefined array element" when using Data.Array. There are no undefined's in the code. Is this indicative of an OoB error?
09:52:29 <seanparsons> It's a data constructor for Maybe, which has another possible constructor Nothing.
09:52:36 <Raydiation> seanparsons: so Maybe a = Just a | Nothing right?
09:52:52 <elliott> pqmodn: type theory is a fun rabbit hole to fall down :)
09:53:00 <Raydiation> so in essence Just a means that theres a value
09:53:19 <Raydiation> yet :t Just gives me
09:53:19 <Raydiation> Just :: a -> Maybe a
09:53:34 <DMcGill> :t Just 1
09:53:35 <lambdabot> Num a => Maybe a
09:53:42 <seanparsons> Raydiation: Indeed.
09:53:46 <DMcGill> :t Just (1 :: Int)
09:53:49 <lambdabot> Maybe Int
09:53:59 <pqmodn> elliott: thanks for the push then :)
09:54:02 <Raydiation> ty
09:54:14 <seanparsons> Yeah, Just is effectively a function from a value of type a to another value of the type Maybe a.
09:57:29 * hackagebot mustache2hs 0.3 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.3 (StephenWeber)
09:58:48 <Raydiation> is Just a monad? as in how do i get the a out of it?
09:58:57 <sipa> Maybe is a monad
09:59:03 <sipa> Just is that monad's return
09:59:16 <donri> Raydiation: and what if it's a Nothing?
09:59:20 <monoidal> do x <- Just 3; y <- Just 4; return (x+y)
09:59:21 <sipa> (Just is a value constructor, Maybe is the type)
09:59:22 <monoidal> > do x <- Just 3; y <- Just 4; return (x+y)
09:59:23 <lambdabot>   Just 7
09:59:33 <Chousuke> Raydiation: you need to write a function from Maybe Something -> Something
10:00:28 <Raydiation> i see so <- extracts the value of that monad basically
10:00:34 <Chousuke> Raydiation: if the Something is just a, you can't write a total function with that signature though. (what value of every type corresponds to nothing?)
10:01:48 <ksf> @djinn Maybe a -> a -> a
10:01:48 <lambdabot> f a b =
10:01:49 <lambdabot>     case a of
10:01:49 <lambdabot>     Nothing -> b
10:01:49 <lambdabot>     Just c -> c
10:01:53 <Raydiation> extract as in partially apply to a function?
10:01:59 <Raydiation> +it
10:02:26 <Chousuke> Raydiation: the do syntax is just syntactic sugar for the bind function
10:03:20 <ksf> @djinn Maybe a -> (a -> Maybe b) -> b
10:03:21 <lambdabot> -- f cannot be realized.
10:03:32 <ksf> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
10:03:32 <lambdabot> f a b =
10:03:32 <lambdabot>     case a of
10:03:32 <lambdabot>     Nothing -> Nothing
10:03:32 <lambdabot>     Just c -> b c
10:03:59 <ksf> that's >>= for Maybe, what you'll get when you "do foo <- bar"
10:04:08 <Raydiation> i see ty
10:04:18 <Chousuke> it doesn't really "extract" anything since you can never "leave" the monad without writing a specific function for a particular monad (that is, it's not possible to write such a function for all monads in general)
10:04:25 <ksf> it will short-circuit everything after that away because, well, there's no value that could be passed on.
10:04:37 <ksf> (if the value is Nothing)
10:05:01 <Raydiation> so i need to pattern match Nothing anytime i get a Maybe monad in a function?
10:05:10 <ksf> there's no need at all to use its monad instance when you use maybe, though.
10:05:29 <ksf> Raydiation, the monad instance is a way to *not* do that all the time.
10:05:29 <Chousuke> Raydiation: you don't get "monads" from functions, really
10:05:46 <Raydiation> Chousuke: you mean as a return value?
10:06:00 <Chousuke> yeah.
10:06:30 <ksf> Raydiation, what I'd recommend is to work with cases manually, until you recognise that pattern above all over the place, and see that using >>= makes sense.
10:06:39 <ksf> the step to do-notation is only syntactic sugar, then.
10:06:52 <Chousuke> Raydiation: it's basically an interface for a very common code pattern
10:08:13 <Raydiation> do you also use the do notation if you just bind one result?
10:08:53 <k00mi> Raydiation: don't think of Maybe as "a monad", it's a data type that can be used for various things, among them modeling failing computations which forms a monad
10:09:05 <Chousuke> Raydiation: a type constructor like Maybe (which actually is just a type itself) can implement Monad if it's possible to write >>= (bind) for it in a way that satisfies specific laws
10:09:42 <Chousuke> Raydiation: turns out there are tons of types like Maybe that are monads.
10:09:57 <kloplop321> What does `instance (a ~ b) =>`... mean?
10:10:10 <ksf> kloplop321, ~ is type equality
10:10:30 <ksf> doesn't sound too sensible, as you can always write instance Foo a a to get the same effect.
10:10:45 <elliott> it's sensible.
10:10:47 <elliott> it helps inference
10:10:54 <elliott> we do it a lot in lens
10:11:05 <kloplop321> ksf, so `instance (a ~ b) => Monoid (Endomorphism a b) where` means that when a and b are the same then it is an instance of so so?
10:11:09 <elliott> it means that it can commit to the instance head before it knows a and b must be the same
10:11:15 <elliott> otherwise you can get inference issues
10:11:20 <ksf> kloplop321, yep
10:11:36 <elliott> kloplop321: it means that (Endomorphism a b) has a Monoid instance, and that picking this instance then constrains a = b
10:11:39 <Raydiation> btw, bind in haskell always involves monads right?
10:11:42 <kloplop321> ksf, elliott, thank you for the enlightenment.
10:11:45 <elliott> so in general, only (Endomorphism a a) is a monoid.
10:11:49 <ksf> Raydiation, not only in haskell
10:11:54 <elliott> but this way of expressing the instance infers better than instance Monoid (Endomorphism a a)
10:12:00 <Raydiation> then what about https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
10:12:05 <elliott> since a is not always "obviously" the same as b, even if it can be constrained to be so (e.g. in the presence of polymorphism)
10:12:22 <monoidal> if type inference was ideal, instance Monoid (Endomorphism a a) and instance a ~ b => Monoid (Endomorphism a b) would be the same. it's more of a limitation how GHC searches for instances.
10:12:57 <elliott> monoidal: not quite
10:12:58 <Raydiation> iirc you use bind in JS to partially apply a function
10:13:00 <elliott> consider:
10:13:05 <ksf> elliott, speaking of type inference, is there a way to get rid of the type sig for "l" here and still have "foo" typecheck? http://lpaste.net/93304
10:13:05 <elliott> instance Monoid (Endomorphism a a)
10:13:07 <elliott> instance Monoid (Endomorphism Int String)
10:13:10 <elliott> these don't conflict.
10:13:22 <elliott> this is why GHC is right to be conservative about committing to the (Endomorphism a a) instance
10:13:33 <kloplop321> I was looking through https://gist.github.com/sdiehl/6442143 which had this and I wasn't sure what to make of it. Though I've seen it in the compile complaints before.
10:13:37 <elliott> with "instance a ~ b => Monoid (Endomorphism a b)", any other instances for Endomorphism would oevrlap. so it can commit.
10:13:50 * ksf always thought Foo a a would get rewritten to a ~ b => Foo a b
10:13:51 <quinso> It seems my cabal update can't update the list of packages. Is the server down or something?
10:13:55 <monoidal> elliott: sure, but if GHC was very smart, they would not overlap
10:14:17 <elliott> monoidal: well, I think they're semantically different. I could even imagine wanting the non-~ version sometimes.
10:14:19 <k00mi> Raydiation: unrelated to what is pronounced bind in haskell (>>=)
10:14:29 <elliott> ksf: does this require a newer GHC than 7.6.3?
10:14:34 <ksf> yep
10:14:42 <elliott> unfortunately I'm on Windows so can't really get a head build :)
10:14:44 <ksf> HEAD, though the latest snapshot should suffice
10:14:57 <Raydiation> k00mi: ok thanks
10:15:02 <elliott> do they make snapshot builds for windows?
10:15:32 <monoidal> ksf: import UTF8? where is it?
10:15:40 <ksf> there's ghc-7.7.20130828-windows-extra-src.tar.bz2 , dunno what that is
10:15:45 <ksf> monoidal, encodeString, nothing else.
10:15:51 <ksf> that's value level, you can ignore it :)
10:16:01 <monoidal> ksf: System.IO.UTF8?
10:16:11 <ksf> (to turn Sings into ByteStrings)
10:16:19 <ksf> no, a custom module.
10:16:32 <elliott> ksf: I think that's the source code with Windows line endings
10:16:50 <ksf> tried compiling the encoding package to do the same, but it's a) big and full of dependencies and b) didn't compile
10:16:59 <ksf> just a sec
10:17:51 <ksf> monoidal, pasted the module as annotation
10:19:08 <elliott> ksf: anyway, I wouldn't hope for omitting type signatures with that many language extensions.
10:19:30 <ksf> But it's the only one I need :'(
10:20:27 <elliott> ksf: my advice is to implement -XRowTypes.
10:21:10 <ksf> my type theory foo isn't strong enough for that.
10:21:53 <ksf> ghc has come a very, very long way since HList, though.
10:23:11 <ReinH> oh hai
10:23:20 <johnw> ReinH: hey there
10:24:52 <ksf> elliott, but with a proper row type library I could probably implement a sane aspect grammar system and use that to implement a compiler understanding row types :)
10:25:00 <ksf> *attribute grammar
10:26:24 * ksf doesn't understand why there's even a discussion about allowing duplicate labels, btw.
10:26:45 <ksf> if you need two things in there, make the type the label is allocated with a tuple. or a list.
10:27:47 <elliott> ksf: because the theory is simpler and easier to implement if you just use a list rather than adding preconditions.
10:27:54 <elliott> and you can make up some kind of argument that it's even useful :P
10:28:34 <ksf> but it also becomes ugly semantically speaking. for one, you really need lists, to have an ordering.
10:28:56 <ksf> which means you can't treat the labels as set and reshuffle.
10:29:09 <elliott> true, the weird pseudo-reshuffling in that one paper is weird.
10:29:16 <ksf> which, so I claim, is important from a software engineering pov.
10:29:27 <elliott> (it does shuffle, just not across duplicate labels)
10:29:42 <elliott> I don't know. as a language implementor, I kind of want to pick the list-based system. as a language fan, it disgusts me :)
10:31:24 <ksf> I think the whole -XRowTypes extension could even be limited to -XTypeLevelSets and half a handful of predicates.
10:31:39 <ksf> ...to get around such type inference issues as I face right now.
10:32:00 <Raydiation> regarding http://www.haskell.org/haskellwiki/Do_notation_considered_harmful is it correct to have this do block? https://dpaste.de/g9prd/#L4
10:32:05 <mcstar> let me re-ask a previous question of mine:
10:32:08 <mcstar> does anybody have a resource on (symbolic) 'index computation & manipulation' (of arrays)?
10:32:52 <mcstar> im interested in a way of dealing formally with indices, ranges, transposition, general reordering, and in the end, automatic loop generation
10:32:54 <ksf> Raydiation, why wouldn't it be?
10:32:59 <ksf> doesn't it typecheck?
10:33:35 <shachaf> Did you know that just anyone can make a page on the wiki?
10:33:58 * ion goes and writes /haskellwiki/Haskell_considered_harmful
10:33:58 <Raydiation> i mean i could also do getLine >>= putStrLn reverseList
10:34:09 <ksf> shachaf, someone even linked that page to my what monads are not page...
10:34:14 <mcstar> "The reversed strings are" correctly
10:34:23 <Raydiation> :P
10:34:45 <ksf> Raydiation, putStrLn . reverseList , but yes.
10:34:51 <ksf> see also pointless programming.
10:34:59 <shachaf> In this case my first guess on the author of that page was correct.
10:35:00 <ksf> http://www.haskell.org/haskellwiki/Pointfree
10:35:07 <t4nk060> Hey
10:35:15 <t4nk060> wondering if i could get some help with something basic
10:35:16 <t4nk060> 1. (a) Write a function halveEvens :: [Int] -> [Int] that returns half of each even number in the list. For example, halveEvens [0,2,1,7,8,56,17,18] == [0,1,4,28,9] Your denition should use a list comprehension,
10:35:37 <mcstar> i thought you guys could provide some guidance, sine you were talking about attribute grammar
10:35:45 <mcstar> which afaik is useful in code generation
10:35:45 <shachaf> t4nk060: Well? What sort of help do you want? What have you done so far?
10:35:47 <ion> shachaf: Hmm, i don’t think i’m familiar with the author.
10:35:56 <ksf> mcstar, orthogonal.
10:36:08 <shachaf> ion: Henning Thielemann
10:36:18 <mcstar> ksf: i thought you could use it for domain specific optimization
10:36:37 <mcstar> like, it could carry additional info with an AST or something
10:36:38 <shachaf> t4nk060: (This looks like homework or something so people are probably not going to just tell you the answer.)
10:36:40 <ksf> you can use it for any catamorphism
10:36:52 <mcstar> ksf: now you are talking chinese... :D
10:36:56 <t4nk060> It's for one of my tutorials
10:37:02 <t4nk060> I know i won't get told the answe
10:37:11 <t4nk060> But could I get some guidance on how to start it
10:37:18 <ksf> mcstar, yes, but it's an implementation technique, it's got nothing to do with compilers or such as a domain.
10:37:28 <t4nk060> I've made up the skeleton for the function
10:37:28 <ion> shachaf: Ok, i’m definitely not familiar with him.
10:37:36 <micom> hello its my very beginning with haskell, "quicksort [y | y <- xs, y > x]"          what does  <- xs mean?
10:37:42 <ksf> but it's bloody useful if you have large, complicated folds.
10:37:47 <micom> y <- xs
10:37:51 <shachaf> ion: Ask elliott.
10:38:01 <ksf> and one particular nice thing is that you can plug in what you get out into the input.
10:38:13 <mcstar> ksf: ok, i get it, anyway, dont hesitate to help me if you have some resource to share on the subject im interested in
10:38:19 <ksf> that is, make the whole thing circular (as long as it's not really circular)
10:38:25 <mcstar> or just some general guidelines, whatever, im a bit lost
10:40:08 <ksf> shachaf, wasn't henning the ModuleName.C guy?
10:40:40 <shachaf> Yes.
10:41:02 <mcstar> micom: in list comprehensions, y <- xs, successively binds the elements(list) of xs to y, which you can use on either side of the |
10:41:30 <mcstar> (but i think the list comprehension notation can be overloaded for monads)
10:42:04 <monoidal> micom: if you know Python, it's equivalent to [y for y in xs if y > x]
10:42:39 <mcstar> except it haskell's lists are lazy
10:42:42 <mcstar> -it
10:43:05 <micom> oh thanks guys , thats pretty easy, now i understand it well( i guess)
10:43:14 <ReinH> mcstar: http://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions yay!
10:43:22 <micom> any recommendation of tutorial for c++ programmer?
10:43:26 <micom> haskell tutorial
10:43:33 <mcstar> > let lst = [x | x <- lst]
10:43:35 <lambdabot>   not an expression: `let lst = [x | x <- lst]'
10:43:48 <ReinH> micom: learn you a haskell is good
10:43:51 <carado> hello.
10:43:56 <mcstar> > let lst = [x | x <- lst] in lst
10:44:01 <ReinH> @google learn you a haskell
10:44:03 <lambdabot> http://learnyouahaskell.com/
10:44:03 <lambdabot> Title: Learn You a Haskell for Great Good!
10:44:06 <lambdabot>   mueval-core: Time limit exceeded
10:44:19 <ReinH> mcstar: heh what did you expect to happen?
10:44:26 <micom> ReinH, ok i will stick to them for longer
10:44:28 <mcstar> mueval exceeded
10:44:44 <ReinH> well alright then :p
10:44:47 <mcstar> :)
10:45:04 <mcstar> i couldnt think of anything useful to demonstrate..
10:45:29 <mcstar> > let lst = 1 : [x + 1| x <- lst] in take 10 lst
10:45:32 <monoidal> > [x+y | x <- [1,2,3], y <- [10,20]]
10:45:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:45:34 <lambdabot>   [11,21,12,22,13,23]
10:45:39 <joelteon> @undo lst = [x | x <- lst]
10:45:39 <lambdabot> lst = concatMap (\ x -> [x]) lst
10:46:02 <joelteon> but
10:46:05 <joelteon> :t concatMap
10:46:06 <lambdabot> (a -> [b]) -> [a] -> [b]
10:46:09 <joelteon> so that's just id
10:46:14 <joelteon> so lst = id lst
10:46:56 <joelteon> @pl a = id a
10:46:57 <lambdabot> a = fix id
10:47:44 <joelteon> :t fix id
10:47:45 <lambdabot> a
11:01:42 <ReinH> Woo haskell cast episode 2 is up! :D
11:04:03 <path[l]> there's a haskell cast?
11:04:04 <path[l]> wow
11:05:36 <ion> @type cast
11:05:38 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
11:06:09 <schell> in this script `do { putStr ">"; hFlush stdout; i <- getLine; }` it takes two returns before i is evaluatied
11:06:15 <schell> evaluated*
11:06:21 <schell> why is that?
11:06:30 <ion> That is a syntax error.
11:07:09 <geekosaur> schell, I think we need to see the actual full code
11:07:11 <geekosaur> @lpaste
11:07:12 <lambdabot> Haskell pastebin: http://lpaste.net/
11:07:13 <schell> think of it in regular do notation, i probably borked it in my mind in translation
11:07:36 <monochrom> what is "i is evaluated"?
11:07:48 <ion> and “two returns”
11:07:55 <merijn> ion: carriage returns
11:08:00 <merijn> ion: i.e. newlines
11:08:01 <ion> Oh, *those*
11:08:31 <schell> http://lpaste.net/93310
11:08:42 <exicer> Can anyone tell me what stupid thing I've done here:  http://lpaste.net/93303 ?
11:08:52 * ksf inspects his needle printer he's using as a console and observes that yes, hitting return returns the carriage.
11:09:01 <schell> line 73 - step
11:09:07 <exicer> I get a message that I don't understand..
11:10:02 <merijn> exicer: Would've helped to paste that message too ;)
11:10:13 <exicer> Hah, good point - just a sec
11:10:15 <geekosaur> exicer, not that I can help, but please annotate your paste with the full error message
11:11:34 <exicer> http://lpaste.net/5146328615494877184
11:11:38 <schell> monochrom: i'm just trying to express that it appears as though rest of the do is not run until two newlines have been read by stdin
11:12:48 <ksf> exicer, return on line 34?
11:13:04 <ksf> (blindly guessing, I don't know enough of conduit to make an educated guess)
11:13:08 <monochrom> I have just tried your program. it takes me only one newline.
11:13:25 <ksf> no, that has to be it.
11:13:30 <schell> monochrom: ha! weird
11:13:31 <ksf> results is a list.
11:13:37 <schell> so it's my terminal
11:13:53 <ksf> exicer, try getMovies' _ [] results = return results
11:13:56 <t4nk534> hi
11:14:00 <t4nk534> got a simple function "halveEvens xs = [ x * 2 | x <- xs, even x]"
11:14:06 <exicer> ksf: Just have, same problem :s
11:14:13 <t4nk534> what would i do if i want it to divide by 2 instead of multiply
11:14:20 <t4nk534> [x div 2 | doesn't seme to work
11:14:24 <t4nk534> am i missing something :o
11:14:27 <Cale> x `div` 2
11:14:28 <schell> monochrom: thanks
11:14:30 <Cale> or  div x 2
11:14:30 <exicer> ksf: Actually, also an additional problem
11:14:35 <t4nk534> ah
11:14:43 <t4nk534> I used ' instead of `
11:14:44 <t4nk534> thanks alot
11:14:52 <Cale> no problem!
11:15:33 <Cale> http://4.bp.blogspot.com/_D_Z-D2tzi14/S8TRIo4br3I/AAAAAAAACv4/Zh7_GcMlRKo/s1600/ALOT.png <-- picture of me
11:15:47 <t4nk534> ghci>  halveEvens xs = [0,1..20]  <interactive>:59:15: parse error on input `='
11:15:53 <t4nk534> I'm getting that error Cale
11:15:57 <t4nk534> What did I do wrong :o
11:16:06 <Cale> t4nk534: In ghci you'll need to put 'let' in front of your declarations
11:16:08 <ksf> t4nk534, add a "let" in front
11:16:13 <schell> monochrom: it's my auto build process - it monitors my files and runs the program from the command line, waiting for some input before quitting, so it's essentially two programs running getLine at the same time
11:16:18 <schell> monochrom: i bet that's it
11:16:19 <ksf> t4nk534, ghci behaves (mostly) like a do block
11:16:21 <DMcGill> my comonadic sudoku solver doesn't work on any of my supposedly easy examples and it doesn't even feel like it's doing any work. What stupid trivial mistake have I made? http://lpaste.net/93311 I've been tearing my hair out all day with this
11:16:23 <t4nk534> ah I see
11:16:31 <Cale> t4nk534: But probably, even just for playing around, it'll be better if you open up a text editor in another window, and put your declarations into a file
11:16:33 <schell> monochrom: yeah
11:16:44 <t4nk534> ghci>  halveEvens [0,1..20] [0,1,2,3,4,5,6,7,8,9,10]
11:16:48 <t4nk534> I did do so Cale
11:16:49 <Cale> t4nk534: whenever you save your file, :r in ghci will reload it, and you can put in expressions to test things
11:17:00 <t4nk534> halveEvens :: [Int] -> [Int] halveEvens xs = [ x `div` 2 | x <- xs, even x]
11:17:05 <monochrom> that is a great continuous disintegration system
11:17:10 <t4nk534> That's my function created on notepad++
11:17:12 <t4nk534> just a simple one
11:17:20 <t4nk534> And I loaded it into gchi
11:17:25 <t4nk534> ghci rather
11:17:49 <t4nk534> Somebody helped me with the function, why does it use xs instead of x
11:18:09 <Cale> xs is just another variable, the intention is that you read it as plural
11:18:20 <mcstar> 'axes'
11:18:22 <Cale> (it's a list of numbers)
11:18:33 <geekosaur> t4nk534, are you being confused by the list comprehension perhaps?
11:18:39 <t4nk534> Ah I see
11:18:44 <t4nk534> Yeah geekosaur
11:18:50 <t4nk534> I think I get it now though
11:18:55 <t4nk534> So it doesn't have to be xs
11:19:03 <t4nk534> It could be y for example
11:19:06 <Cale> sure
11:19:11 <t4nk534> Okay
11:19:19 <Cale> It's just conventional to name list variables with names ending in s :)
11:19:21 <geekosaur> yeh, xs is just a convention "plural x"
11:19:31 <t4nk534> halveEvens xs = [ x `div` 2 | x <- xs, even x]
11:19:35 <t4nk534> so that function
11:19:54 <t4nk534> it declares x's as x, so whatever numbers I type will be declared as x
11:19:57 <shachaf> > let map f [] = []; map f (x:x's) = f x : map f x's in map toUpper "hello"
11:19:58 <lambdabot>   "HELLO"
11:20:05 <shachaf> Oh boy. Innovation!
11:20:06 <mcstar> err
11:20:45 <monochrom> congrats shachaf :)
11:21:47 <mcstar> t4nk534: well, nobody is saying it, so i will, what you said is very weird and/or potentially wrong terminology
11:22:00 <t4nk534> I figured
11:22:03 <ReinH> Anyone have any really nice, elegant examples of arg/options parsing (using GetOpts or something else)?
11:22:06 <t4nk534> I just confused myself even more
11:22:16 <t4nk534> I'm talking as if its an imperative a
11:22:20 <t4nk534> language
11:22:21 <t4nk534> lol
11:22:31 <mcstar> t4nk534: think about labels being bound to values
11:22:37 <mcstar> or the other way around
11:22:45 <t4nk534> Right
11:23:09 <mcstar> re-bounding is not possible, only shadowing
11:23:38 <micom> hello again, map f (x:xs)            =  f x : map f xs                    // the second " : "  i'm not sure what is it responsible for
11:23:50 <mcstar> :t (:)
11:23:51 <lambdabot> a -> [a] -> [a]
11:23:53 <ksf> t4nk534, haskell is the best imperative language I've ever used...
11:23:55 <schell> ReinH: you can see how I've used it here -> https://github.com/schell/steeloverseer/blob/master/src/Main.hs
11:23:59 <mcstar> the 'cons' operator
11:24:02 <schell> not sure how elegant that is...
11:24:11 <geekosaur> micom, it's the same as the first but it's building instead of deconstructing
11:24:13 <micom> oh thanks i will google the cons operator
11:24:36 <micom> i get it, it creates a list from left and right side
11:24:37 <geekosaur> > let x = 1; y = [3] in x : y
11:24:38 <mcstar> well, in haskell i think it is called list constructor
11:24:39 <lambdabot>   [1,3]
11:24:48 <t4nk534> Well i've written "halveEvens xs = [ x `div` 2 | x <- xs, even x]" as a list comprehensive
11:24:58 <mcstar> sion*
11:25:00 <t4nk534> how do I go about doing it as a recursive version
11:25:17 <t4nk534> comprehension, right.
11:25:23 <ksf> t4nk534, start with halveEvens [] = ... and halveEvens (x:xs) = ...
11:25:26 <micom> > let x = [1,3,4]; y = [3,4] in x:y
11:25:27 <ReinH> schell: I tried a lens'd version of "high-level option handling with GetOpt" https://gist.github.com/reinh/eabe0310fc93668004c0
11:25:28 <lambdabot>   No instance for (GHC.Show.Show t0)
11:25:28 <lambdabot>    arising from a use of `M292478957.sho...
11:25:32 <ReinH> schell: I'm kind of happy with it
11:25:52 <ReinH> :t (:)
11:25:53 <lambdabot> a -> [a] -> [a]
11:26:05 <ReinH> micom: the first argument is a single a, not a list of [a]
11:26:10 <monochrom> it's a foldr = foldl where { foldl [] = a; foldl (your : you're) = foldr your (foldl you're) }
11:26:13 <ReinH> > 1:[2]
11:26:14 <lambdabot>   [1,2]
11:26:23 <micom> ook, o got it, thanks again guys
11:26:36 <ReinH> micom: consider this definition
11:26:37 <schell> ReinH: looks good
11:26:40 <ReinH> repeat x = x : repeat x
11:27:06 <ReinH> schell: cool :)
11:27:35 <micom> ok, going back to learn it learn it:)
11:28:10 <mcstar> > (map (`div` 2)) . (filter even) $ [1..10]
11:28:12 <lambdabot>   [1,2,3,4,5]
11:29:55 <Raydiation> is do a language feature which is built in?
11:30:02 <S_J> > map (+4) [1,2,3,4]
11:30:03 <lambdabot>   [5,6,7,8]
11:30:10 <Cale> Raydiation: somewhat
11:30:21 <ReinH> Raydiation: is which?
11:30:23 <Cale> Raydiation: It desugars into applications of >>=
11:30:26 <ReinH> oh is "do" sorry
11:30:37 <Raydiation> yeah, its quite awesome
11:30:39 <Cale> do { x } ==> x
11:30:51 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
11:30:56 <Cale> er
11:30:56 <ReinH> Raydiation: the syntax is built in, the semantics come from the monad typeclass
11:31:07 <Cale> do { v <- x ; <stmts> } ==> x >>= \v -> do { <stmts> } -- let's be consistent ;)
11:31:14 <ReinH> :)
11:31:27 <Cale> do { let { <decls> } ; <stmts> } ==> let { <decls> } in do { <stmts> }
11:31:38 <ReinH> damn it where is Edward when you need him
11:32:45 <Cale> and just for completeness' sake, if p is a pattern which might fail to match (i.e. a pattern involving a constructor from a datatype which has more than one), then
11:33:01 <quchen> Cale: NOOOOOO
11:33:41 <Cale> do { p <- x; <stmts> } ==> let ok p = do { <stmts> }; ok _ = fail "<some error message>" in x >>= ok
11:34:02 <Raydiation> what is the use of return?
11:34:23 <Cale> If v is any value, then generally return v is an action which does nothing except to return that value.
11:34:36 <Raydiation> and it forces execution?
11:34:41 <mcstar> nope
11:34:43 <Cale> no?
11:34:54 <Cale> What return is precisely will depend on the monad in question
11:35:01 <Raydiation> IO for instance
11:35:03 <Cale> It's one of the things you define when you make an instance of Monad
11:35:09 <Cale> along with >>=
11:35:10 <mcstar> the runtime executes IO
11:35:12 <mcstar> not return
11:35:37 <monochrom> a possible use of return: see an implementation of "sequence" below
11:35:41 <monochrom> @src sequence
11:35:41 <lambdabot> sequence []     = return []
11:35:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:35:41 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:35:44 <Cale> For example, return "Hello" is an IO action which when executed will do nothing, and result in the string "Hello"
11:35:54 <monochrom> especially the part about "return (v:vs)"
11:36:31 <mcstar> > return 1 :: Maybe Int
11:36:32 <lambdabot>   Just 1
11:36:33 <Raydiation> so i use return in a do block?
11:36:37 <ReinH> I was wondering why this room is kind of dead today while at the same time reading live blogging reports of ICFP
11:36:39 <Cale> return generally useful at the end of a chain of actions to decide what the result of the combined action should be, rather than leaving it up to the last action in the chain
11:36:43 <ReinH> and I totally didn't make the connection
11:36:47 <ReinH> I am not a smart man.
11:36:51 <Cale> Raydiation: commonly, sure
11:37:00 <Cale> Raydiation: It's worth noting that it is *not* a keyword
11:37:04 <Cale> But an ordinary function.
11:37:10 <Cale> :t return
11:37:11 <lambdabot> Monad m => a -> m a
11:37:21 <Cale> In the case that m = IO, that's  return :: a -> IO a
11:37:38 <Cale> so it takes a value and gives you a do-nothing IO action which results in that value every time
11:37:38 <mcstar> return is like the value constructor of a type in the monad typeclass
11:37:51 <mcstar> but since some of those are not exported, you are forced to use return
11:37:55 <Cale> If you're familiar with unix 'true' and 'false, it's kind of like that
11:37:57 <ReinH> All that is required is that the last statement provide a monadic value. For example, do { x <- getLine; return x } is redundant.
11:37:58 <mcstar> (which is the point..)
11:38:02 <Cale> oops, missed a '
11:38:46 <ReinH> although do { getLine } is also redundant
11:38:47 <Cale> (those are programs which do nothing, but produce a particular exit code)
11:39:10 <mcstar> Cale: IO ()?
11:39:19 <Cale> mcstar: well, thinking of them like IO Int :)
11:39:23 <mcstar> ok..
11:39:29 <ReinH> Cale: IO Word8 :p
11:39:33 <Cale> Or that, yes :)
11:39:41 <ReinH> just heckling, please disregard
11:40:36 <mcstar> ever since ive run into a IO (IO ()), i always write out main :: IO ()
11:40:46 <AndChat|600084> does haskell allow c++ ffi bindings!
11:40:59 <mcstar> yay!
11:41:09 <Cale> AndChat|600084: It's possible to rig things to work, but C++ is remarkably hard to FFI to in general, from any language.
11:41:22 <Raydiation> why do i need return here? https://dpaste.de/PU3SL/
11:41:28 <Cale> AndChat|600084: Probably the most reliable way is to write a C++ wrapper which exposes things as a C library.
11:41:34 <merijn> AndChat|600084: The easiest way is to have C bindings for your C++ stuff and then use that
11:41:45 <Raydiation> cant i just leave it out and only do if line != ""
11:42:02 <mcstar> Raydiation: because the branches of if have to produce a value of the same type
11:42:04 * quchen seconds merijn's comment. Write C wrappers to avoid a lot of pain
11:42:06 <Cale> Raydiation: Because if expressions must produce a value.
11:42:08 <AndChat|600084> Cale, merijn: thnx
11:42:17 <mcstar> you have to explicitely tell, what will happen in either case
11:42:20 <Cale> Also, indent if/then/else like this:
11:42:22 <Cale> if foo
11:42:24 <mcstar> will->should
11:42:24 <fizruk> :t when
11:42:25 <Cale>    then bar
11:42:26 <lambdabot> Monad m => Bool -> m () -> m ()
11:42:27 <Cale>    else quux
11:42:53 <Cale> Raydiation: You might like to use when
11:42:53 <fizruk> Raydiation: take a look at 'when'
11:42:59 <Cale> :t when
11:43:00 <lambdabot> Monad m => Bool -> m () -> m ()
11:43:01 <mcstar> now!
11:43:02 <Raydiation> ty
11:43:13 <Cale> or unless
11:43:14 <Cale> :t unless
11:43:15 <lambdabot> Monad m => Bool -> m () -> m ()
11:43:23 <Cale> (which is the opposite)
11:43:26 <Cale> You could write
11:43:27 <merijn> AndChat|600084: The good news is that C FFI from haskell is really easy and I don't believe C++ to C is particularly hard either :)
11:43:28 <quchen> Raydiation: Also note that the inequality operator is /= and not != in Haskell. :-)
11:43:52 <Cale> unless (line == "") $ putStrLn ... >> echo
11:44:00 <Raydiation> ah right
11:44:18 <Cale> Those are just ordinary functions btw
11:44:33 <Cale> when p x = if p then x else return ()
11:45:02 <Cale> Because IO actions are values, you can invent whatever control structures suit your needs.
11:45:13 <Cale> (but of course, Control.Monad has a bunch of them already)
11:45:40 <Raydiation> so basically you line up the type of () to whatever you like it
11:45:47 <Raydiation> -it
11:46:08 <ReinH> (and if those don't suffice, try monad-loops)
11:46:16 <Cale> The empty tuple is just when you have nothing interesting to produce as a result
11:46:16 <mcstar> return () is kind of really redundant, but in other cases, it isnt
11:46:22 <Raydiation> regarding when p x = if p then x else return ()
11:46:26 <Raydiation> what type is return here?
11:46:37 <mcstar> :t return ()
11:46:38 <lambdabot> Monad m => m ()
11:46:47 <mcstar> as you can see:
11:46:48 <mcstar> :t ()
11:46:49 <lambdabot> ()
11:46:53 <Raydiation> oh
11:46:55 <mcstar> so theres that :)
11:47:00 <Cale> If you want to pretend everything is IO, then  return :: () -> IO ()
11:47:08 <Cale> (in this case)
11:47:21 <Cale> () is the empty tuple
11:47:51 <mcstar> or the type of it
11:47:53 <Cale> (there's no 1-tuple though, as that's somewhat redundant and hard to have syntax for)
11:49:08 <merijn> Raydiation: The type of return depends on what type is inferred for it
11:49:13 <merijn> > return () :: Maybe ()
11:49:14 <fizruk> Cale: Identity?
11:49:16 <lambdabot>   Just ()
11:49:20 <merijn> > return () :: [()]
11:49:21 <lambdabot>   [()]
11:49:28 * ksf wonders if it were possible to add strictness annotations to type families
11:49:30 <Raydiation> ok so it infers it from the input?
11:49:31 <merijn> > return () :: Either String ()
11:49:32 <mcstar> this is my fav. utility package http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers-Monad.html
11:49:35 <lambdabot>   Right ()
11:49:44 <merijn> Raydiation: No, it's inferred from the type of the result
11:49:54 <Cale> fizruk: iirc, Identity is a newtype even, so it's not *quite* the right analogous thing, but close, yeah
11:50:07 <merijn> Raydiation: Haskell typeclass functions can be polymorphic in their return value
11:50:08 <Raydiation> i mean when p x = if p then x else return ()
11:50:22 <Raydiation> p is a bool, x is something else
11:50:23 <fizruk> Cale: it is newtype
11:50:26 <merijn> Raydiation: Yes, it depends on the type inferred for the result of when
11:50:28 <Cale> mcstar: lol, wow
11:50:32 <Raydiation> ok ty
11:50:59 <Cale> Raydiation: x is some action which must have the same type as return ()
11:51:19 <Cale> and we don't know which monad is being used from the code for when, so that remains polymorphic
11:51:29 <Cale> but the result type is fixed because of the use of return ()
11:52:06 <Cale> If you wanted to be able to maybe have a result, you could write something like:
11:52:28 <Cale> whenMaybe p x = if p then (do v <- x; return (Just v)) else return Nothing
11:52:44 <Raydiation> mcstar: looks like perl
11:53:02 <Cale> and this would have type  whenMaybe :: (Monad m) => Bool -> m a -> m (Maybe a)
11:53:19 <mcstar> i think it was meant to be a joke, but who knows
11:53:27 <ReinH> mcstar: holy nope, batman.
11:53:36 <ReinH> mcstar: I thought lens was bad... ;)
11:54:15 <levi> Looks like it should be in the Acme namespace.
11:54:25 <Cale> I'd like to see the reverse dependencies of that package. I really hope that there are none.
11:54:31 <ReinH> At least they went the sane route and used template haskell...
11:55:03 <ReinH> on the other hand, monad-loops provides nice things like untilJust
11:55:32 <Cale> http://hackage.haskell.org/packages/archive/monad-loops/0.4.2/doc/html/Control-Monad-Loops.html -- yeah, this stuff is basically good
11:55:57 <Cale> There's maybe just a few too many variants to actually remember them all perfectly...
11:56:27 <ReinH> the guarded loops are the most useful for me
11:56:37 <ReinH> whileJust and untilJust are probably my 80% case
11:57:26 <levi> Descrption of the Plumbers thing is on this blog: http://www.mgsloan.com/wordpress/
11:58:44 <mgsloan> Yeah, I ought to release another version under Acme
11:58:45 <Rarrikins> What graph libraries are fast (I need to do things like find elementary cycles and solve linear programming problems)?
11:58:58 <mcstar> next time a plumber comes buy, ill ask them what is their fav. operator
11:59:03 <mcstar> by*
11:59:18 <ReinH> levi: construct ALL the operators.
11:59:35 <ReinH> Rarrikins: Data.Graph, perhaps.
11:59:43 <mgsloan> I believe it ended up on hackage due to "<DanBurton> you should put it on hackage"
12:00:11 <ReinH> Rarrikins: Although depending on your graph sizes, something as simple as an adjacency list representation can be fine
12:00:34 <mgsloan> I actually do think that maybe arity 2 plumbers are somewhat reasonable
12:00:46 <mgsloan> it's kinda nice having a system, rather than having a bunch of different combinators
12:00:59 <mgsloan> that way you learn one notation, which happens to be encoded as a set of operators
12:01:10 <exicer> If anyone could tell me what I'm doing wrong on http://stackoverflow.com/questions/18966772/haskell-scraping-with-http-conduit-problems, that would be awesome.
12:01:12 <mgsloan> But I agree, at that point, you're just taking point free too far
12:01:28 * mgsloan doesn't use plumbers
12:01:42 <Rarrikins> ReinH: It's a pretty small graph.
12:02:06 <Rarrikins> ReinH: I'll take a look at Data.Graph. Thanks
12:02:18 <ReinH> Rarrikins: something as simple as a Map Vertex (Map Vertex Weight) might be fine
12:02:26 <Cale> exicer: Delete the explicit type signature on getMovies', it's incorrect.
12:02:33 <mcstar> Rarrikins: coursera?
12:02:39 <ReinH> but Data.Graph will provide you quite a bit out of the box
12:03:06 <Rarrikins> mcstar: No, it's just a hobby problem.
12:03:11 <mcstar> ah, ok
12:03:38 <exicer> Cale: What should it be? There is a new problem when I remove it
12:03:39 <ReinH> you can also use tropical star-semirings for lots of graph-related stuff, including solving linear equations http://r6.ca/blog/20110808T035622Z.html
12:03:44 <ReinH> Rarrikins: you might enjoy that link
12:03:48 <Cale> exicer: In particular, there's no way in hell that the result is a list, since you're making an HTTP request, and lists can't express that idea.
12:03:59 <Cale> exicer: It will probably be an IO action.
12:04:13 <Cale> (perhaps whose result type is a list)
12:04:34 <Rarrikins> ReinH: Ahh, thanks :)
12:05:15 <exicer> Cale: Hm, okay
12:05:26 <chrisdone> Cale: in the Hell monad, Nothing is possible
12:05:36 <ReinH> ha
12:05:43 <ReinH> chrisdone: Hell is other monads?
12:05:50 <Cale> exicer: What's the new problem when you remove the type signature?
12:07:04 <chrisdone> ReinH: so deep
12:07:04 <Cale> Oh, I can think of one problem looking at this
12:07:20 <monochrom> "Haskell makes hard things easy and Nothing a thing"
12:07:29 <Cale> You're calling getMovies' recursively, but inside a runResourceT, so you'll need a lift
12:07:53 <exicer> http://lpaste.net/5294038510808858624
12:08:11 <exicer> I had also changed getMovies' to return results
12:08:21 <exicer> Cale: http://lpaste.net/93318
12:08:25 <Cale> getMovies' will produce an action in some monad which presumably isn't ResourceT transformed, because of the runResourceT
12:08:32 <S_J> typeclasses == ad hoc polyporhism?
12:08:43 <Cale> S_J: no, they're better
12:08:45 <exicer> Cale: Ohh
12:09:36 <mcstar> well, at least ghci has Just, do, it
12:09:58 <Cale> S_J: Typeclasses differ from ad-hoc polymorphism in a bunch of ways, one of which is that defining new things in terms of typeclass polymorphic parts can result in more typeclass polymorphic things.
12:10:21 <ReinH> chrisdone: not every day I get to butcher Sartre in #haskell ;)
12:10:28 <monochrom> mcstar: have you seen my: it's a foldr = foldl where { foldl [] = a; foldl (your : you're) = foldr your (foldl you're) }
12:10:29 <Cale> S_J: For instance, sort :: (Ord a) => [a] -> [a] has just a single definition, which makes use of the comparison operations defined by the Ord typeclass.
12:10:44 <Cale> (and becomes polymorphic on that basis)
12:10:44 <mcstar> monochrom: ah, no, what is it? (yes i did... :)
12:11:34 <ReinH> Cale: also something something denotational semantics
12:11:49 <ReinH> and something something polymorphic free theorems
12:12:18 <Cale> S_J: That is, normally with ad-hoc polymorphism, you define some name at a bunch of specific types, and you have to make sure that wherever it's used, the type is specific enough to pick one of those. With typeclasses, you can defer that choice by having the thing which uses the polymorphic thing itself be polymorphic.
12:12:59 <Cale> Another difference is that you can write instances of a typeclass which depend on other instances, and effectively create "infinitely many instances"
12:13:13 * monochrom frowns. (Ord a) => [a] -> [a] does not have just a single definition. it is very limiting, yes, but not remotely to the point of just a single definition
12:13:30 <Cale> monochrom: I said the name of the function!
12:13:42 <Cale> I mean that 'sort' is defined just once
12:13:50 <Cale> not once per type of lists you want to sort
12:13:58 <monochrom> oh, that
12:14:00 <ksf> what would be also cool would be a way to suppress unification errors (unless it's the only one ghc could find)
12:14:02 <ReinH> monochrom: to your point, though, you do know some things about a function of that type for free
12:14:21 <ReinH> and thus about any instance of that typeclass
12:14:30 <levi> S_J: The paper introducing them was called "How to make ad-hoc polymorphism less ad hoc"
12:14:45 <Cale> I really wish the paper hadn't been called that
12:14:47 <ReinH> hah
12:15:08 <ReinH> Cale: "A principled approach to sharing names"?
12:15:39 <doomlord_> away from c++ i always miss ad-hoc polymorphism
12:16:12 <S_J> away from c++ i always feel a sense of happiness
12:16:24 <mcstar> away from c++ i ..., oh wait, im not
12:16:29 <Cale> S_J: As another example, there is an instance Monoid m => Monoid (e -> m). Ignoring for the moment what Monoid is if you're unfamiliar, the interesting thing about this is that once there is one instance of this class, there are infinitely many: if m is an instance of Monoid (and so has implementations of the operations), then this declaration tells us how to get an instance for functions e -> m, and then for functions
12:16:29 <Cale>  e' -> e -> m, and so on
12:17:12 <Cale> You generally can't do anything like that with ad-hoc polymorphism.
12:17:48 <ReinH> A couple nice resources on the power of typeclasses: http://conal.net/papers/type-class-morphisms/ http://www.iai.uni-bonn.de/~jv/papers/FreeTheoremsInvolvingTypeConstructorClasses.pdf
12:17:49 <Cale> Typeclasses give you a way to define functions by recursion on the structure of the types involved.
12:18:00 <Cale> (to some extent, anyway)
12:18:57 <ReinH> Cale: they also get you the wonderful ability to pay for something once and then reuse it (as you say) infinitely many tim es
12:19:34 <ReinH> once you know what (say) a Functor is, you know something important about any correct instance
12:19:57 <Cale> Not to mention that when you define a typeclass, you usually don't just give it one method with a perfectly general type. Typeclasses also serve as something akin to Java interfaces.
12:20:22 <Cale> (though again, more general)
12:20:30 <ReinH> And they provide a large shared vocabulary for library implementation
12:20:57 <ReinH> There's a good reason why, for instance, diagrams went to so much trouble to make Diagram a Monoid instance
12:21:37 <Cale> Diagram uses monoid instances in some very clever ways :)
12:21:38 <mcstar> the best thing in typeclasses is that they are similar to c++ templates
12:21:43 <Cale> Diagrams*
12:21:54 <ReinH> Cale: yeah, the functional perl blew my mind
12:21:55 <mcstar> both are kind of accidental discoveries
12:22:58 <ReinH> pearl*
12:23:13 <chrisdone> lol
12:23:18 <chrisdone> that's two  VERY different sentences
12:23:27 <monochrom> functional perls blow many people's minds, too :)
12:23:30 <ReinH> chrisdone: I'm pretty sure someone does that about once a day
12:23:36 <monochrom> yikes, s/perls/perl/
12:23:44 <ReinH> perl is implemented in haskell, so...
12:23:52 <geekosaur> no
12:24:00 <chrisdone> no it's not o _o
12:24:14 <geekosaur> there's an ancient perl6 prototype written in haskell, but not being actively maintainer
12:24:15 <chrisdone> pugs /was/
12:24:16 <geekosaur> *maintained
12:24:27 <ReinH> It's *an* implementation. I didn't say the current implementation :p
12:24:28 <chrisdone> but yeah the main perl 6 is some parrot thing iirc
12:24:39 <ReinH> Rakudo, yes
12:24:44 <chrisdone> though personally i'd class perl 5 as "perl"
12:24:44 <geekosaur> rakudo is parrot and jvm
12:24:46 <mauke> ReinH: that's perl6, not perl
12:24:50 <chrisdone> perl 6 is… a pipedream
12:25:01 <ReinH> it's also provably unparsable.
12:25:02 <ReinH> so that's nice
12:25:23 <arnsholt> Provably unparseable only in a boring sense though
12:25:25 <geekosaur> well, so is perl5 :)
12:25:31 <mauke> so is lisp
12:25:43 <arnsholt> You can do similar things in many languages
12:25:54 <arnsholt> And yeah, let's not get started about Common Lisp
12:26:20 <chrisdone> hmm maybe unparseable is the wrong terminology?
12:26:36 <chrisdone> surely not necssarily parseable
12:26:50 <arnsholt> chrisdone: Have you read the original post where this whole mess comes from?
12:26:55 <ReinH> this channel is now about perl
12:27:02 <chrisdone> common lisp isn't provably unparseable, its macros are turing complete so the best you can say is you don't know if it will parse or not
12:27:15 <monochrom> perhaps it means "(\x -> is x valid perl?) is undecidable"
12:27:28 <chrisdone> right
12:27:41 <mauke> hey, with TH this also applies to haskell
12:27:47 <chrisdone> nod
12:27:52 <arnsholt> Here's the actual post: http://www.perlmonks.org/?node_id=663393 go read that and come back
12:28:03 <ReinH> chrisdone: but if macros are turing complete then parsing is subject to the halting problem...
12:28:04 <mauke> is that the terrible thing?
12:28:38 <ReinH> which makes it unparsable in exactly the same way that perl is
12:28:39 <chrisdone> ReinH: which is why i said "the best you can say is you don't know if it will parse or not"
12:28:59 <mcstar> arnsholt: are you going to grade him too?
12:29:00 <chrisdone> "unparsable" seems like a sensationalist title? in the article he uses "undecidable" which seems proper
12:29:07 <arnsholt> mcstar: Possibly =)
12:29:13 <mauke> oh, that's the author of Marpa
12:29:22 <arnsholt> Perl is obviously parseable, since perl the program does it just fine
12:29:36 <ReinH> chrisdone: well, if parsing is undecidable then there exists at least one program that cannot be parsed.
12:29:45 <ReinH> That seems like a reasonable definition of unparsable to me
12:29:58 <arnsholt> The entiter point of that is that it's not *statically* parseable, due to the interleaving of compilation-time and run-time. Similar to what you can do in Lisps
12:30:45 <ihm1> Is there any reason why one can't write 'join :: Event (Event a) -> Event a' in Reactive.Threepenny? I have 'joinIO :: Event (Event a) -> IO (Event a)' by imperatively pushing values onto the result stream
12:30:56 <S_J> So windows uses timeslices between threads but obv that needs to be scheduled with other progras as well so how do you even know how often a thread will run?
12:30:56 <chrisdone> ReinH: surely there exist squillions of syntax productions that can't be parsed? =)
12:31:33 <elliott> ihm1: join for Events/Behaviours is the source of FRP's most famous problem, time leaks with dynamic event switching
12:31:34 <chrisdone> arnsholt: oh, then, yeah, as mauke said, lisp, haskell, etc.
12:31:42 <monochrom> my thesis supervisor taught me to be flexible with the line drawn between "compile time" and "run time". thus, "is this string is a valid program?" and "is this string a terminating program?" are not so different.
12:32:08 <elliott> ihm1: it's... a little complicated. take a look at http://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html and http://apfelmus.nfshost.com/blog/2012/09/03-frp-dynamic-event-switching-0-7.html
12:32:25 <monochrom> after all, like I sometimes say, "hugs turns compile-time type errors to run-time type errors" :)
12:32:26 <ihm1> elliott: I should have no qualms about using the function I wrote assuming the source stream and the produced streams aren't very productive though, right?
12:33:02 <chrisdone> monochrom: hmm but it's not done at runtime, so, huh?
12:33:10 <elliott> if the function works for you then go for it. no guarantee the semantics make sense or that it isn't leaky, though, since I don't know what it's doing or much about threepenny :)
12:33:19 <chrisdone> monochrom: hugs still has a compile step separate to running, how is it any different to ghc?
12:33:22 <elliott> just saying that that type is historically very risky.
12:33:55 <mauke> chrisdone: that also applies to perl
12:34:00 <mcstar> 'dont invest in that type!' the elders say
12:34:10 <ihm1> elliott: This function intercalates all the produced streams
12:34:18 <levi> Cale: A lot of the stuff you can do with type classes now was not part of the initial implementation of them, though, due to only working for kind *.
12:34:23 <monochrom> "time leak" sounds scary. the scariest thing since "space leak".
12:34:51 <ReinH> Looks like I successfully nerd sniped the entire room.
12:34:55 <ReinH> My condolences.
12:34:55 <chrisdone> mauke: what are you referring to that applies to perl?
12:35:14 <mauke> chrisdone: compile step separate to running
12:35:18 <chrisdone> sure
12:35:34 <Cale> levi: sure
12:35:37 <chrisdone> perl's compile errors may be different to haskell's but it's a non-empty set, for sure
12:35:44 <Cale> levi: Though I've only described things which were always there
12:36:44 <fizruk> Can anyone explain why I get error on commented lines? http://lpaste.net/93322
12:36:48 <chrisdone> monochrom: ?
12:37:05 <monochrom> chrisdone: if a "compile step" is repeated every time a "run step" is repeated, the distinction becomes questionable.
12:37:35 <chrisdone> monochrom: for both ghc and hugs, correct?
12:37:44 <S11001001> fizruk: DMR?
12:37:50 <monochrom> it is a useful organizational distinction. it may not be a useful theoretical distinction
12:38:03 <fizruk> S11001001: what is DMR?
12:38:04 <mauke> S11001001: no
12:38:16 <mauke> probably impredicativity
12:38:17 <S11001001> mauke: cool, just random guess
12:38:19 <monochrom> for both runghc and runhugs.
12:38:25 <mauke> but I don't know what that means
12:38:33 <mcstar> dreaded...
12:38:57 <mcstar> is it an actualy error, or something hlint complains about?
12:39:01 <mcstar> actual*
12:39:06 <S11001001> no that couldn't be it, never mind
12:39:11 <fizruk> mcstar: actual error
12:40:07 <stolaruk> I have a simple data type and I'm wondering if a zipper can be made for it. Please see http://lpaste.net/93323
12:40:14 <S11001001> ermine does the same thing when you use pointlessness with rank-n types
12:40:32 <S_J> whats the best way to do an action periodically in a thread in haskell? is Control.Concurrent.Timer recommended?
12:41:20 <elliott> monochrom: time leaks are just a special case of space leak
12:41:27 <elliott> monochrom: a shame, because they sound so exciting :)
12:41:41 <elliott> FRP is the jamming of time into value space, after all.
12:41:54 <S_J> and where should i place something that abstracts sockets? makes it easy to define tcp application protocols. like Network.Socket.MyLib or Network.MyLib?
12:42:34 <k00mi> is there a good reason text uses utf-16 instead of utf-8?
12:42:55 <monochrom> time flies like an arrow. space leaks like an FRP arrow. :)
12:43:16 <merijn> k00mi: Historical reasons
12:43:19 <chrisdone> fruit flies like a banana
12:43:37 <k00mi> so that's a "no" :P
12:43:46 <merijn> k00mi: There was a UTF8 implementation too, but apparently it was slower than the utf-16 one, so it's currently shelved
12:43:54 <fizruk> mauke: ImpredicativeTypes flag does not solve the problem, if that's what you mean
12:43:55 <k00mi> aha
12:44:01 <elliott> k00mi: they tried out UTF-8 and rejected it. I'm not sure I'm totally convinced by their reasons for doing so, except for compatibility with ICU, which is quite a big deal.
12:44:13 <cdidd> this channel is more popular than ##php and ##c++ combined. Haskell the popular language.
12:44:26 <doug> or the language that people have the most trouble with
12:44:31 <chrisdone> lol
12:44:51 <levi> Popular among people who hang out in computer-language-themed IRC channels on freenode.
12:44:57 <chrisdone> maybe i shouuld generate some stats of what percentage of people in here actually talk vs idle
12:45:11 <monochrom> the debate between utf-8 and utf-16 boils down to a debate between Euro-centric and Asia-centric.
12:45:18 <levi> Who are no doubt perfectly representative of the general population of programmers!
12:45:25 <merijn> monochrom: You forgot the 3rd faction
12:45:32 <chrisdone> monochrom: wasn't that discredited by benchmarks and such?
12:45:36 <mcstar> Klingons!
12:45:39 <merijn> monochrom: "People who think it gives them constant indexing in strings"
12:45:57 <monochrom> chrisdone, I am sure each side can craft a benchmark to discredit the other side
12:46:12 <monochrom> in fact, I can
12:46:44 <chrisdone> istr a demonstration that utf-16  doesn't give a performance boost for the major non-alpha scripts like for arabic, chinese, japanese
12:46:51 <elliott> monochrom: eh. I try to compensate for my Euro bias - though undoubtedly not wholly successfully - and I think independent concerns like ASCII compatibility (OK, this is Euro-centric in some sense, but only insofar as all of modern computing is...) and the fact that e.g. markup formats like HTML being used to contain solely Asian text still have a lot of stuff that's smaller in UTF-8 around it, are relevant.
12:46:57 <elliott> (cut off, maybe?)
12:47:08 <monochrom> because I frequently use both kinds of texts. texts of pure English, and texts of pure Chinese
12:47:24 <elliott> to be free of bias, we should just all use UTF-32. Haskell tried that. :)
12:48:00 <monochrom> well, Haskell has only tried [UTF-32]. the [] part killed it.
12:48:04 <chrisdone> elliott: that's a good point for html
12:48:51 <levi> elliott: Except you should use the UCF-4 name, just because.
12:48:55 <elliott> I think if we could start over, with today's memory and disk space and no historical ASCII or existing formats to care about, then we should go with UTF-32 for both transfer and storage.
12:48:58 <levi> Er, UCS-4
12:49:06 <elliott> but as it stands, UTF-8 seems like the best option.
12:49:09 <aristid> levi: utf-32 please :)
12:49:11 <chrisdone> if 30% of your page is latin1 it's not worth using two bytes. tho i'm not sure how many bytes chinese would use. does it rest within the 2byte range in utf-16?
12:49:41 <levi> aristid: That would be far too consistent with utf-8 and utf-16.
12:49:42 <elliott> CJK in Unicode is still a mess in general, right?
12:50:06 <stolaruk> Is there a resource that describes the prerequisites for a zipper? I have a data type but I'm a newbie and I'm not sure how to make a zipper for it...
12:50:07 <elliott> Han unification and all.
12:50:21 <aristid> levi: ucs-2 and ucs-4 both exist, but utf-16 and utf-32 are preferred i think and there are subtle differences
12:50:28 <chrisdone> true… relates to the way programmers treat text, anyway, i suppose
12:50:32 <aristid> iirc ucs-2 is not a mbcs unlikes utf-16
12:50:37 <chrisdone> the old "sequence of characters" fallacy
12:51:09 <aristid> i think the main appeal of ucs-2/utf-16 originally was that you could just use them like real arrays, back when unicode fit in 16 bits.
12:51:16 <monochrom> my Chinese name is 9 octets in utf-8. 3 octets per character; 3 characters
12:51:34 <aristid> monochrom: that's better than the utf-32 version:0
12:51:37 <chrisdone> aha. in utf16?
12:51:44 <aristid> monochrom: does your name fit in the BMP?
12:52:15 <monochrom> it fits in the BMP. (most of CJK does.)
12:52:24 <Cale> It seems ever so slightly shortsighted to me to define UTF-32 to be fixed-length. Why not just use the same trick as UTF-8 to handle arbitrarily large integer codepoints?
12:52:32 <levi> aristid: ucs-2 is definitely deprecated, but I think ucs-4 and utf-32 are essentially synonymous.
12:52:33 <chrisdone> monochrom: how's your name stored in utf-16?
12:52:56 <aristid> monochrom: ok so 6 bytes then
12:52:59 <S_J> can a thread kill itself? is there any dangers associatd with that?
12:53:20 <Cale> S_J: no danger.
12:53:29 <stolaruk> A suicidal thread could die.
12:53:30 <elliott> Cale: well, there would be riots if Unicode grew again.
12:53:48 <aristid> i guess as the set of character grows larger, the notion of storing text without compression becomes sillier and sillier
12:54:01 <monochrom> it's U+9ECE U+88D5 U+660C
12:54:14 <chrisdone> suicide = myThreadId >>= killThread
12:55:38 <mauke> unidecode says: 黎裕昌 Li Yu Chang
12:55:53 <mauke> also: wow, that first one looks complicated
12:56:02 <Iceland_jack> A thread also terminates when the action it is executing has completed
12:56:36 <mcstar> monochrom: would you be offended if someone called you your unicode equivalent?
12:57:57 <monochrom> no, but high probability I will not even know :)
12:58:06 <S_J> whats the best way to do an action periodically in a thread in haskell? is Control.Concurrent.Timer recommended?
12:59:37 <ihm1> Is there any way to automatically get a Generic and or Serializable instance for a type that has a Typeable instance?
12:59:42 <Iceland_jack> S_J: forkIO (forever (do threadDelay pause; action)) ?
13:00:18 <chrisdone> “hey U+9ECE U+88D5 U+660C, you suck!” ( ° / □°\）
13:00:33 <monochrom> haha
13:00:47 <mcstar> U+ is redudant
13:01:01 <bennofs> ihm1: so you can't just add a deriving (Generic) clause to that datatype?
13:01:03 <mcstar> the problem is, that an alphanumeric string is too impersonal
13:01:14 <ihm1> bennofs: It's a type defined in another library
13:01:18 <mcstar> (at least the ones like that..., the chinese characters are much cooler)
13:01:27 <S_J> Iceland_jack: but i dont want to pause my thread since it is doing other things as well.
13:01:28 <bennofs> ihm1: Are it's constructors exported
13:01:29 <bennofs> ?
13:01:35 <ihm1> Yes
13:01:43 <mcstar> (even if you dont know the meaning, i guess that the reason ppl tattoo on themselves)
13:02:14 <ihm1> bennofs: I suppose I could write the Generic instance manually without too much difficulty
13:02:24 <bennofs> ihm1: Then you could write deriving instance Generic YourDataType, with -XStandaloneDeriving and -XDeriveGeneric#
13:02:40 <ihm1> bennofs: Oh duh, forgot about standalone deriving
13:03:49 <ihm1> bennofs: Thanks much
13:10:42 <ihm1> What's the preferred time library these days?
13:12:53 <aristid> ihm1: the standard one isn't so bad.
13:13:05 <aristid> unless you need speedy parsing/formatting.
13:13:27 <elliott> there is
13:13:28 <elliott> @hackage thyme
13:13:29 <lambdabot> http://hackage.haskell.org/package/thyme
13:13:33 <elliott> which is supposedly fast or something. :P
13:13:35 <ihm1> aristid: I'm just a bit bummed there isn't a Generic instance for UTCTime (and it isn't derivable because DiffTime is kept abstract)
13:14:48 <aristid> elliott: people should just adapt to the leisurely pace of time.
13:14:53 <S_J> Is the select command not implemented in the sockets library? i want it
13:15:03 <oddsignals> bscarlet: Sorry, was idling earlier - thanks for the suggestion, I'll look into it!
13:16:27 <Kaidelong> elliott: a fast time library sounds important for FRP
13:16:40 <Kaidelong> so I can see the motivation
13:17:05 <ihm1> Kaildelong: I'm not so sure about that? It's just for recording times and converting between formats and whatnot
13:17:10 <elliott> Kaidelong: I can't tell how serious you are :)
13:17:26 <Kaidelong> slightly
13:17:27 <aristid> Kaidelong: if you think it's important for FRP, imagine how important it is for HTTP microbenchmarks! :)
13:18:32 <chrisdone> the thyme package is awesome!
13:18:57 <chrisdone> it was 6x faster at parsing when i tested it
13:19:00 <joelteon> can verify that thyme is awesome
13:19:15 <Kaidelong> oh it's for parsing?
13:19:17 <chrisdone> its UTCTime is stored as a 64-bit int
13:19:22 <chrisdone> no it's a complete self-contained time library
13:19:31 <chrisdone> so it has parsing, yeah, but all the rest, too
13:19:48 <bscarlet> oddsignals: It's really two separate suggestions: using Map to organize the grouping, and using Monoid, expecially for tuples, to simplify writing the combining operation(s). I wish Map.union used a Monoid instance by default (I wish Map.union was Map.unionWith (<>)), but it sadly isn't so.
13:19:59 <aristid> chrisdone: it appears to still use String?
13:20:21 <chrisdone> aristid: it exposes an attoparsec parser, so you can use bytestring, that's what i did
13:20:22 <joelteon> Kaidelong: you can s/Data.Time/Data.Thyme/ and will see no change except for better performance, essentially
13:20:31 <aristid> chrisdone: nice
13:20:43 <aristid> chrisdone: and Text too i suppose:)
13:20:59 <aristid> chrisdone: did your usage scenario involve HTTP perchance?:D
13:21:03 <chrisdone> aristid: ah, looking i see that its _printer_ is string, indeed
13:21:03 <ihm1> chrisdone: 64-bit int you say? Then writing the serialize instance should be a snap (with unsafeCoerce that is)
13:21:16 <chrisdone> aristid: it was parsing times from a database with mysql-simple
13:21:46 <chrisdone> aristid: some dude in here showed how haskell was like 10x slower than php at reading n thousand rows with time in them
13:22:19 <chrisdone> so i ported his HDBC nonsense to mysql-simple and time to thyme, it ended up being twice as fast as the php version, as it should be =)
13:22:35 <ReinH>  "UTCTime is not Y294K-compliant. Please file a bug report on GitHub when this becomes a problem."
13:22:38 <ReinH> Cheeky
13:22:43 <chrisdone> =)
13:23:15 <ReinH> chrisdone: lol mysql
13:23:23 <ReinH> The "I don't care about data" database
13:23:27 <chrisdone> yeah, only phpers use mysql it seems
13:23:59 <ReinH> Is 00:00:00 00/00/0000 a valid time? It is if you use mysql!
13:24:02 <aristid> all the cool javascripters use mongodb
13:24:48 <Itkovian> ReinH :-)
13:24:50 <ReinH> lol mongodb The "I don't care about data" nosql
13:24:51 <ihm1> Anyone know what's going on with these lens install errors? http://lpaste.net/93325
13:25:14 <mauke> those are warnings, not errors
13:25:18 <chrisdone> ugh, i feel a bit ill
13:25:42 * chrisdone goes to bed… after watching an episode of death note
13:26:17 <ReinH> chrisdone: ttfn
13:28:14 <oddsignals> bscarlet: I'll read up on the details but it looks like a cleaner solution than the one I have now, based on the SO answer. I'm still quite new to Haskell so it's often a case of realising there has to be a better solution for something I'm doing but not knowing where to look.
13:29:55 <Kaidelong> anyone here used Data Supported Haskell?
13:35:30 <ocharles> mm_freak: read some more papers on yampa, events are clicking a little more :)
13:36:03 <mm_freak> ocharles: well, yampa handles them differently
13:36:34 <ocharles> mm_freak: really? the paper I was reading seems identical in semantics to netwire
13:36:36 <mm_freak> it doesn't have a notion of intervals, so the only way to handle events in yampa is using switching combinators
13:36:39 <ocharles> just without intervals
13:36:41 <ocharles> right
13:36:46 <ocharles> but what an event is seems to be the same
13:36:53 <mm_freak> yeah
13:36:56 <ocharles> just in netwire we operate on these by converting them to intervals
13:37:03 <ihm1> Are there any good alternatives to cereal (Data.Serialize) that use Data rather than Generic (or is there an way of getting a Generic instance from a Data instance)?
13:37:18 <mm_freak> ihm1: Generic is based on Data
13:37:33 <ocharles> I'm trying to suss how to deal with gravity, jumping and collisions in a mario type clone. it's a bit of a puzzle :)
13:38:22 <ihm1> mm_freak: In what way? In such a way that it's possible to get a Generic instance from a Data instance?
13:38:49 <mm_freak> ocharles: i hope to add new calculus wires this week
13:39:00 <mm_freak> ocharles: one of them will be an integral wire that can respond to events
13:39:10 <ocharles> mm_freak: great, can't wait. I've hacked up my own 'integralReset :: (a, Event b) a' wire for now
13:39:24 <ocharles> and also a integralWithE :: (a, Event (a -> a)) a
13:39:42 <elliott> those are some, uh, interesting type signatures.
13:40:00 <ocharles> Right now, I mostly can't figure out how to deal with knowing that i'm hitting the ground. it feels like if I have an Event for 'hit the ground', that would violate event semantics because it fires constantly while you're touching the ground
13:40:04 <ocharles> so maybe I need to make that an interval
13:40:25 <ocharles> but that then feels like I need a integralWithAndEvent :: (a, (a -> a), Event (a -> a)) a
13:40:57 <ocharles> one function determined by the interval (reset to 0 when touching the ground, id otherwise), and another to cause a jump which is discrete
13:41:06 <ocharles> elliott: how about that one? :)
13:41:27 <elliott> ocharles: I don't believe (a, b) c is ever valid.
13:42:17 <mm_freak> ocharles: first figure out whether "hitting the ground" actually resembles an event/interval
13:42:20 <mm_freak> i'd say no
13:42:41 <mm_freak> elliott: i suppose that there is a Wire s e m in front of that =)
13:42:45 <ocharles> yes :)
13:43:01 <mm_freak> integralWithE :: Wire s e m (a, Event (a -> a)) a
13:43:13 <mm_freak> and also a bunch of constraints =)
13:43:46 <ocharles> ok, I guess it doesn't have to be an interval
13:44:16 <ocharles> But I do need to somehow modify the velocity signal to reset y-velocity to 0 if there is ground underneith me
13:44:20 <ibotty> hi. anyone know how i can integrate an attoparsec parser into aeson?
13:44:20 <ibotty> say i have a parseJSON instance and i want to tokenize a string i get within parseJSON by attoparsec
13:44:29 <ocharles> but yes, that can be done without intervals or events
13:45:12 <mm_freak> ocharles: you should probably factor the collision detection out
13:45:39 <mm_freak> the world value (w) might include information about collisions, such that both velocity and position can use it
13:46:00 <ocharles> Hm
13:46:44 <ocharles> I did consider that, but it felt messy to have both signals reacting to collisions. but I guess both react differently. velocity means "I need to go back to 0" and position means "I need to get out of the collision"
13:47:45 * hackagebot quickspec 0.9.2 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9.2 (NickSmallbone)
13:48:14 <mm_freak> yeah
13:48:31 <mm_freak> in a more physically correct setting velocity would actually not just drop to zero
13:48:37 <mm_freak> and acceleration would go to zero
13:49:10 <ocharles> i don't think mario is the height of physically correct modelling
13:49:15 <mm_freak> hehe yeah
13:49:24 <ocharles> but ok, i'll see what happens if I do that
13:49:46 <ocharles> I guess with a recursive loop I should be able to do that but only ever emit non-colliding frames from the game signal itself
13:50:11 <mm_freak> the laws of gravity don't seem to apply to japanese italian plumbers =)
13:50:19 <hpc> ocharles: now i am imagining a mario game with qwop controls
13:50:22 <mm_freak> yeah
13:50:44 <mm_freak> collision detection without value recursion is ugly/impossible
13:51:13 <ocharles> hpc: haha
13:51:18 <ihm1> Is unsafeCoerce safe to use with newtypes?
13:51:27 <ocharles> mm_freak: and on the otherhand, very elegant with it :)
13:51:34 <hpc> ihm1: just pattern-match
13:51:45 <mm_freak> yeah
13:51:45 <S11001001> ihm1: coming in 7.8, Coercible!
13:51:48 <YayMe> In the recentest haskell, what module do I best find the State monad?
13:51:56 <ihm1> hpc: It's a type whose constructors aren't exported
13:52:02 <ocharles> mm_freak: oh, 'tag' feels like it could be useful
13:52:22 <ocharles> tag x = arr (<$ x), I think
13:52:22 <mm_freak> YayMe: Control.Monad.State for the mtl interface, Control.Monad.Trans.State for the transformers interface
13:52:32 <mm_freak> YayMe: the underlying type is the same, but the mtl version is a bit more flexible
13:52:37 <hpc> YayMe: you generally want the mtl interface
13:52:57 <YayMe> Thanks.
13:53:21 <mm_freak> ocharles: what about fmap?
13:53:25 <mm_freak> Event is a Functor
13:53:54 <mm_freak> oh, you mean a wire for that purpose
13:53:56 <ocharles> mm_freak: <$ is fmap (const), but maybe I missed a level of functoryness
13:54:03 <ocharles> yea
13:55:15 <mm_freak> ocharles: well, it could probably be useful, if you use yampa style events, but in netwire you should add semantic information and then use (<>)
13:56:48 <ReinH> mm_freak: the laws of gravity actually don't apply :)
13:57:07 <mm_freak> ReinH: ?
13:57:25 <ocharles> mm_freak: fair enough
13:57:37 <ocharles> anyway, looking to having a bit more stock wires in the netwire library
13:57:41 <ocharles> it's still feeling a tad sparse
13:57:55 <ReinH> mm_freak: for instance, falling off a ledge doesn't apply a universal gravity acceleration to your velocity
13:58:05 <mm_freak> ocharles: feel free to open as many feature requests as you want on darcshub =)
13:58:10 <mm_freak> ocharles: i'll probably add most of them
13:58:12 <ReinH> it applies whatever your last falling acceleration was
13:58:25 <joelteon> okay, so I need to pass over a list of tokens and emit text based on them
13:58:25 <ReinH> er, last falling velocity
13:58:32 <joelteon> but I also need to maintain a state based on the current token
13:58:44 <mm_freak> ocharles: another great way get new wires into netwire is to write them and tell me to pull them in =)
13:58:52 <joelteon> and if I tried to just do it purely in state monad
13:58:59 <ocharles> mm_freak: oh, darcs hub has an issue tracker? that might work well when i'm hacking away and you're not around for free support
13:59:00 <joelteon> it would basically be st <- get; case st of [] -> ...
13:59:03 <joelteon> for every single call
13:59:05 <ocharles> mm_freak: :)
13:59:07 <joelteon> I'd rather do some kind of fold
13:59:12 <mm_freak> ocharles: =)
13:59:15 <ReinH> mm_freak: so if you run straight off the first ledge on a stage you will go farther than if you jump first
13:59:29 <joelteon> what do you guys recommend
13:59:41 <mm_freak> ReinH: i'm not really knowledgable there
13:59:57 <ReinH> mm_freak: also gravity is different if you hold 'A' after you jump
14:00:11 <mm_freak> joelteon: you can write a custom combinator
14:00:45 <mm_freak> joelteon: you can also stick a Maybe/MaybeT somewhere and then use (<|>) to combine alternative behaviors
14:01:05 <S_J> would it be unsafe to let a function that executes when a Timer fires to write to an MVar and a thread that reads that MVar?
14:01:18 <mm_freak> ReinH: are you explaining gravity or mario gravity?
14:01:28 <ReinH> mm_freak: mario gravity
14:01:39 <mm_freak> S_J: doesn't sound unsafe so far
14:02:01 <ikarus> anyone here ever dared deal with graphs in haskell
14:02:04 <mm_freak> ReinH: i guess that depends on the mario in question
14:02:05 <caumeslasal> joelteon: isn't there an overlapping between a fold and the State ?  I mean, if your function gets the state at every step to do things, that's exactly what your doing with a fold and its accumulator (accum <=> your state) ?
14:02:17 <ReinH> mm_freak: talking about original SMW here
14:02:26 <ikarus> I am trying to figure out what the sanest approach is to dealing with them
14:02:30 <mm_freak> ikarus: given that there is an apparently full-featured openstreetmap library, probably yes ;)
14:02:51 <ikarus> mm_freak: note the /here/ part :)
14:03:28 <joelteon> oh wait, this is perfect for RWS
14:03:34 <mm_freak> ikarus: i suggest just asking a question
14:03:38 <joelteon> I can just "tell" the output I want to give
14:03:46 <ikarus> mm_freak: I am trying to figure out where to start reading
14:03:48 <ikarus> essentially
14:04:11 <caumeslasal> Oops, I get a strange runtime error : "toJSON: not AlgRep NoRep(DataType {tycon = "Data.UUID.UUID", datarep = NoRep})"; but Data.UUID.UUID is an instance of Data and Typeable ? any guess ?
14:04:26 <mm_freak> ikarus: i see…  well, there is a lot of reading material on graphs simply because there are many different kind of graphs and implementation strategies
14:04:41 <caumeslasal> joelteon: it seems
14:05:05 <joelteon> but the recursing part is what's giving me trouble
14:05:17 <joelteon> reader isn't designed for *consuming* input, it's designed for *environment*
14:05:19 <ikarus> mm_freak: exactly, well, I am dealing with simple, undirected, connected, without loops or multiple edges graphs
14:05:27 <joelteon> i need an input state and an emitter state and they need to be separate
14:06:27 <ReinH> ikarus: there are lots of ways to "deal with" graphs (in Haskell) depending on what kind they are, how dense they are, kind of operations you want to perform on them, etc
14:06:56 <ikarus> ReinH: it's a proof of concept, so the one that leads to most elegant code and I've just specified what kind they are :)
14:07:07 <mm_freak_> ikarus: i see…  well, there is a lot of reading material on graphs simply because there are many different kinds of graphs and implementation strategies
14:07:08 <mm_freak> ikarus: from simple node/edge maps to completely abstract graphs with observable sharing
14:07:12 <mm_freak_> ikarus: from simple node/edge maps to completely abstract graphs with observable sharing
14:07:17 <mm_freak_> oh
14:07:18 <joelteon> this is what I've got right now: https://gist.github.com/joelteon/6676991
14:07:21 <mm_freak_> my ghost spoke
14:07:32 <ReinH> ikarus: you might start with an adjacency list
14:08:13 <ikarus> ReinH: well, from the stuff I did run into, that was recommended against due to hardly matching functional programming needs
14:08:25 <ReinH> I'm not sure why that would be
14:08:56 <mm_freak_> well, functional programmers would prefer algebraic descriptions of graphs rather than node/edge lists
14:09:01 <ikarus> ReinH: for a given v, find the v's connected to it and recurse on it
14:09:03 <mm_freak_> but the former run into problems with bottoms
14:09:21 <ReinH> IntMap Vertex (IntMap Vertex Weight) can be a reasonable representation, as can Array (Vertex, Vertex) Weight, depending on how dense
14:10:33 <ReinH> there are other options but either would be a good place to start
14:25:26 <caumeslasal> joelteon: Sorry, going to sleep ; just as a bye : maybe you should use the Writer monad for your output, to begin. Then, I think use the sequence (Control.Monad) over the [action t | t <- tokens]. Hope this helps (rather than confuse you).
14:25:49 <elliott> aka mapM action tokens
14:31:47 <joelteon> :t mapM ?act ["a", "b", "c"]
14:31:48 <lambdabot> (Monad m, ?act::[Char] -> m b) => m [b]
14:31:56 <joelteon> oh yeah, that's a good idea
14:32:24 <joelteon> :t mapM (runState ?r) ["a", "b", "c"]
14:32:25 <lambdabot> (Monad ((,) a), ?r::State [Char] a) => (a, [[Char]])
14:38:26 <Gracenotes> perhaps I can advertise this; there's a panel for the next 50 minutes about teaching Haskell in academia and industry. twitter questions including #teachhaskell will be included, it seems.
14:38:55 <Gracenotes> and I think it'll be recorded and put online eventually
14:39:03 <Fuctor> Hello, here's to hoping someone's awake. I'm trying to make an instance of arbitrary, and getting a compiler error; not to sure how to deal with it, code at: https://gist.github.com/TinnedTuna/e732e11fb0cad1125819
14:39:15 <Fuctor> s/arbitrary/Arbitrary/g
14:39:41 <S_J> why is does not tryTakeMVar return Maybe instead of Bool??
14:40:28 <merijn> Fuctor: It's telling you that BitSet is a type synonym (i.e. "type BitSet a = ???") and standard haskell doesn't allow typeclass instances for type synonyms
14:40:34 <Gracenotes> this one? tryTakeMVar :: MVar a -> IO (Maybe a)
14:41:08 <merijn> Fuctor: Solution: As GHC helpfully informs you, turning on "{-# LANGUAGE TypeSynonymInstances #-}" will ignore the standard and define the instance anyway
14:41:10 <Fuctor> merijn: so how does Test/QuickCheck work : http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/src/Test-QuickCheck-Arbitrary.html
14:41:22 <joelteon> how do you figure out the display width of a Char?
14:41:38 <geekosaur> you use a GUI toolkit that has such a concept?
14:41:41 <Fuctor> it doesn't seem to be doing anything with {-# ... #-} in there?
14:41:47 <joelteon> geekosaur: like what?
14:41:51 <merijn> Fuctor: Most (if not all) of those instances aren't type synonyms
14:41:57 <Gracenotes> anyway, ask questions about things about teaching haskell. do it. >.>
14:41:59 <joelteon> I don't mean how many pixels, I mean zero-width, single width, double width, etc.
14:42:09 <joelteon> like zwnbsp has no width
14:42:19 <merijn> Fuctor: Yeah, I don't see a single type synonym there
14:42:25 <Fuctor> merijn: So, if I (in my TFIDF file) remove the type Document = BitSet ..., it will work ?
14:42:40 <Fuctor> (i.e. just directly use BitSet, rather than using Document)
14:42:46 * hackagebot unordered-containers 0.2.3.3 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.3.3 (JohanTibell)
14:43:00 <geekosaur> if you want straight text output, look for a binding to ICU
14:43:25 <hpc> joelteon: that stuff is going to be pretty font-specific
14:43:32 <merijn> Fuctor: The problem is: http://hackage.haskell.org/packages/archive/bitset/1.4.7/doc/html/src/Data-BitSet-Dynamic.html#BitSet
14:43:47 <hpc> joelteon: i have seen fonts where f is i-width, n-width, and m-width
14:43:58 <geekosaur> S_J, I have no idea what you're asking
14:44:01 <joelteon> yeah, I'm assuming a monospace font
14:44:04 <hpc> (also fonts where i is n-width or its own ultra-narrow)
14:44:18 <joelteon> hpc: I'm trying to simulate struckthrough text in terminals that don't support it
14:44:21 <joelteon> which means using U+0336
14:44:25 <merijn> Fuctor: So "instance Arbitrary (BitSet a) where" is trying to define an instance for the BitSet type synonym
14:44:27 <joelteon> but if it's paired with a zero-width character, it just looks like a dash
14:44:30 <joelteon> and I'd like to avoid that
14:44:41 <joelteon> I want to use it on one or more width characters
14:45:29 <hpc> joelteon: well in a terminal that's completely different
14:45:46 <hpc> not only do you have stuff like zwnbsp (which you may or may not really have to deal with)
14:45:53 <joelteon> yeah, exactly
14:46:01 <hpc> but you have color codes, the screen magic byte, the clear character
14:46:09 <Fuctor> merijn: is there any fix that doesn't involve GHC extensions?
14:46:10 <hpc> *screen magic char
14:46:27 <hpc> so uh
14:46:31 <hpc> good luck
14:46:37 <hpc> there's no central resource for this stuff
14:46:48 <merijn> Fuctor: Define the instance for the internal type of Data.BitSet.Dynamic
14:46:48 <Fuctor> merijn: I'm wondering if maybe using Data.BitSet.Generic might help instead
14:46:56 <joelteon> alright
14:47:00 <hpc> except maybe terminfo
14:47:03 <joelteon> i'm just gonna be optimistic and draw them after everything
14:47:07 <joelteon> and hope that doesn't screw up layout too much
14:47:16 <joelteon> it can be disabled, so that's not a huge deal
14:47:21 <merijn> Fuctor: Although, tbh, there's no real reason to not use that extension, unless you insist on being portable to one of the other compilers that no one uses for production code
14:48:06 <hpc> joelteon: if you can find a spec somewhere that promises useful things, you can always do that and say "if you are in a broken shell, tough shit"
14:48:20 <joelteon> meh
14:48:44 <joelteon> 0336 isn't supported by most of my fonts anyway
14:50:32 <oddsignals> Fuctor: Even if you define the instance for the internal type, you might still have to enable the FlexibleInstances extension to get it to work... So you're probably stuck with an extension either way
14:50:32 <merijn> joelteon: Get better fonts! ;) (I said, not knowing whether my fonts support that)
14:50:47 <joelteon> consolas does not
14:50:51 <joelteon> deja vu does
14:51:26 <oddsignals> Fuctor: I just went through the same thing writing a FromJSON instance for Decimal
14:52:32 <Fuctor> gah, that's awful :-(
14:52:42 <Fuctor> I *hate* extensions with a religious passion :-p
14:52:47 * hackagebot haskell-src-meta 0.6.0.4 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.4 (BenMillwood)
14:52:48 <merijn> Fuctor: Why?
14:53:05 <Fuctor> merijn: well, should a contender to GHC ever arise, I may have permanently pinned myself to it
14:53:24 <Fuctor> and hopefully, one day, we will have a contender to GHC
14:53:28 <dwcook> Fuctor, conversely, a contender might have to support the existing extensions
14:53:34 <merijn> Any serious contender will support those extensions anyway, the report is overly pessimistic
14:53:36 <stepkut> H98 should be more than enough Haskell for anyone!
14:53:53 <stepkut> Have we really learned anything useful in the last 15 years? I think not!
14:53:55 <zenzike> Fuctor: I can't think of any extensions that have religious passion...
14:54:15 <merijn> Fuctor: The Haskell report is conservative and describes/defines what exists and what's being used, not as a design blueprint where the language should go
14:55:19 <quchen> As Elliott put it a couple of days ago, "It is an interesting exercise to imagine a language revision more conservative than H2010".
14:55:35 <Fuctor> merijn: I know, but I have hopes that one day the language (and, hopefully) many libraries would be able to run on a compiler that adhered to the standard. So if, someone came up with a fully-verified Haskell, we'd be able to run all of the lovely libs on it :-p
14:56:10 <merijn> Fuctor: Most of Hackage requires some number of extensions
14:56:10 <Fuctor> tbh, I'm hoping that a formally verified Haskell is a *when*, not an if.
14:56:24 * elliott wonders what "formally verified" is being used to mean here.
14:56:26 <Fuctor> merijn: Most of Hackage currently relies on extension
14:56:38 <Fuctor> elliott: in much the same was as compcert is formally verified
14:56:49 <haasn> I wonder how practical it would be to allow imports below the main body of code
14:56:50 <Fuctor> s/was/way
14:56:56 <haasn> Apart from compiler efficiency concerns
14:57:07 <merijn> haasn: That'd be awful
14:57:12 <quchen> Fuctor: I think we already have such compilers. What you're basically describing is one that implements H98, and for that GHC isn't the only one I think. Take that away and you're left with GHC, which is what people developing Haskell (the language) predominantly use to explore new things.
14:57:22 <merijn> haasn: Some line at the bottom of the file could import a function and change the meaning of all code
14:57:35 <elliott> Fuctor: ok, so you want an (operational?) semantics for Haskell in a computer proof assistant, plus a compiler proved to respect those semantics in the same?
14:58:03 <elliott> that's very ambitious. we don't have a formal semantics for Haskell full stop :)
14:58:52 <Fuctor> quchen: I'm not against GHC being used to experiment and find out what might be good in a future spec, I just think that people who want to use Haskell in a more rigorous way should have a way to escape the experimental nature of it :-)
14:59:10 <Fuctor> elliott: We don't have a formal semantics for most of C ;-)
14:59:24 <Fuctor> well, it is formal, but it's just defined to be undefined a lot of the time
14:59:33 <merijn> Fuctor: Eh, C's operational semantics are pretty specifically defined
14:59:48 <levi> We don't have many people wanting to do formally verified code in C, either.
14:59:51 <merijn> Fuctor: No, code that results in undefined behaviour is not valid C, hence why it is undefined
15:00:06 <Fuctor> merijn: that's not true
15:00:18 <merijn> Well, I guess it depends on how you define "valid C"
15:00:25 <Fuctor> merijn: f(x++, --x); is a valid function call
15:00:30 <levi> It's C that's defined to have implementation-defined behavior.
15:00:37 <merijn> levi: What? Are you joking? Millions of people are interested in verifying C
15:00:51 <Fuctor> levi: yes, or usually referred to as "undefined"
15:01:05 <Fuctor> ie. the compiler can make demons fly out you nose, if it's capable of doing so :-p
15:01:07 <merijn> levi: No, multiple ++/-- operators between sequence points is undefined behavior, not implementation-defned behaviour
15:01:09 <shachaf> "implementation-defined" isn't the same as "undefined"...
15:01:23 <levi> I think there's a distinction between implementation defined and undefined in C.
15:01:49 <merijn> levi: Yes, and that example is undefined, not implementation defined
15:02:51 <levi> merijn: Lots of people are interested in formally verified C in some sense of 'lots of people', but compared to the number of people who write C, the number is miniscule.
15:03:28 <merijn> s/C/Haskell in that sentence and it still holds
15:03:34 <levi> Indeed.
15:03:36 <merijn> So that's kind of a vacuous statement in this context
15:04:46 <levi> The context seems to be a bit weird, is all I'm saying.
15:08:19 <ikarus> hrm, is the right approach to figuring out the complexity of an algorithm written in a functional programming language identical to solving it's recurrence expression ?
15:08:47 <Fuctor> ikarus: not always.
15:08:58 <ikarus> Fuctor: any other suggested approaches ?
15:09:02 <Fuctor> ikarus: especially not always in a lazy setting
15:09:11 <Fuctor> ikarus: do you have access to Okaski's book?
15:09:41 <ikarus> Fuctor: probably
15:09:53 <ikarus> let's see if the library carries it
15:09:56 <ikarus> '
15:10:00 <Fuctor> he gives several examples of (primarily for amortised data structures) analysing the running time of functional data structures in a lazy setting
15:10:19 <ikarus> Fuctor: got a ISBN for it ?
15:10:23 <Fuctor> though it is written in StandardML, not Haskell, but it is still applicable :-)
15:10:24 <levi> The thesis version is freely downloadable, IIRC.
15:11:19 <ikarus> levi: any title then in that case
15:11:27 <merijn> Yeah a Google Scholar search for "okasaki purely functional data structures" should turn it up
15:11:36 <k00mi> the book contains a translation to haskell
15:11:41 <k00mi> his thesis doesn't
15:11:50 <Fuctor> ikarus:  ISBN 0-521-66350-4
15:12:00 <acowley> That book is pretty amazing
15:12:07 <acowley> Its reputation is well-deserved
15:12:11 <Fuctor> acowley: everyone loves that book ^.^
15:12:20 <acowley> There's very little not to love
15:12:57 <Fuctor> ikarus: it basically boils down to assuming that your lazxy language implements memoisation under the hood, determining if certain expressions have already been evaluated.
15:13:25 <Fuctor> i.e. once f x has been evaluated, it has cost 1 to evaluate it again.
15:14:23 <merijn> Are there any well known examples of data types that are monads and comonads? I guess list could be one, but I'm not sure what a sensible comonad instance for list would be
15:15:00 <quchen> merijn: (,) e, Identity
15:15:19 <quchen> (->) r when r is a Monoid too I think
15:15:31 <S11001001> many trees
15:15:53 <quchen> merijn: Lists aren't comonads (you can't extract []), but non-empty lists are
15:15:57 <acowley> The Comonad instance for NonEmpty is straight forward
15:16:00 <quchen> (And those are also Monads)
15:16:08 <acowley> http://beta.hackage.haskell.org/package/comonad-3.1/docs/src/Control-Comonad.html
15:16:12 <acowley> (search for NonEmpty)
15:16:16 <merijn> quchen: Don't you mean where a is a Monoid for "(->) r a"?
15:16:34 <quchen> merijn: I mean  Monoid m => Comonad ((->) m)
15:16:43 <ikarus> Fuctor: mhm, that just modifies the recurrent expression though, makes some operations 1 instead of E, etc
15:16:46 <haasn> merijn: NonEmpty/Stream
15:16:57 <ikarus> and as 2E is still E, it doesn't quite matter
15:17:00 <benmachine> infinite streams are monads and comonads
15:17:03 <ikarus> (in O() notation)
15:17:31 <benmachine> interestingly, they have a different monad instance from standard lists
15:17:32 <Fuctor> ikarus: it matters when you're finding the amortised running time of the algorithm.
15:17:45 <benmachine> (unsurprisingly, I guess, since singletons aren't infinite)
15:18:00 <haasn> quchen: (,) e is a Comonad when e is a Comonoid; just like (e ->) is a Monad when e is a Comonoid, right? :)
15:18:25 <merijn> Wait, what is a comonoid?
15:18:26 <Fuctor> ikarus: but your right, for the "strict" (i.e. non-amortised) analysis of an algorithm, it only has to run O(g(x)) once for it to be worst-case O(g(x))
15:18:27 <quchen> haasn: Not sure what to say.
15:18:41 <quchen> haasn: Probably "no", but then you'll convince me otherwise ;-)
15:19:07 <haasn> quchen: (every Haskell type is a Comonoid)
15:19:07 <quchen> My guess would be "no and that's silly", but I've become hard to surprise in this channel lately haha
15:19:13 <quchen> SEE WHAT I MEAN
15:19:23 <shachaf> merijn: comempty :: w -> (); comappend :: w -> (w,w)
15:19:38 <haasn> quchen: I love the duality on Reader/Writer, Monad/Comonad and Monoid/Comonoid though
15:19:41 <haasn> There's so much symmetry!
15:19:42 <shachaf> Look at how return x = \_ -> x discards an argument and join f = \x -> f x x duplicates an argument.
15:19:53 <shachaf> (And pretend you had linear types.)
15:20:08 <merijn> shachaf: I'll take a shortcut and just pretend I understood that ;)
15:20:13 <quchen> haasn: I don't understand that symmetry. What's symmetric for Reader and Writer?
15:20:47 <haasn> quchen: well the fact that they behave like ’opposites’ in terms of Monad/Comonad and Monoid/Comonoid; they're also adjunct
15:20:50 <haasn> adjoint*
15:21:10 <shachaf> haasn: Is that "opposites" thing always the case for adjoints?
15:21:13 <merijn> shachaf: Is comappend "w -> (w, w)" because mathematicians like confusing and mixing curried and uncurried functions?
15:21:15 <haasn> so you can see that (e -> a -> x) is isomorphic to (a -> (e, x))
15:21:23 <haasn> err
15:21:26 <quchen> haasn: Oh, you mean Reader and Env, Writer and … whatever its Co-brother is
15:21:27 <haasn> ((e,a) -> x)
15:21:38 <shachaf> If only I knew any other adjoint endofunctors than Identity and that one...
15:21:47 <haasn> shachaf: Composition of those!
15:21:51 <shachaf> merijn: mappend :: (m,m) -> m is pretty standard.
15:21:52 <merijn> (i.e. they pretend that mappend :: (w, w) -> w and then flip the arrow for comappend?)
15:22:01 <merijn> w00t!
15:22:12 <shachaf> Yes.
15:22:14 <merijn> I'm smart and mathematicians are confusing
15:22:20 <shachaf> See https://en.wikipedia.org/wiki/Monoid_object
15:22:25 <elliott> mathematicians never advocated (m -> m -> m).
15:22:29 <elliott> that's Haskell's fault.
15:22:29 <ikarus> merijn: hah, I knew I knew you :P
15:22:42 <ikarus> merijn + haskell, can only lead to one conclusion
15:22:47 <shachaf> elliott is such a h8r.
15:23:31 <shachaf> haasn: That's boring, though.
15:24:15 <merijn> ikarus: It can?
15:24:16 <shachaf> By compositions you only mean (x,(y,-)) -| (x -> (y -> -)), right?
15:24:31 <shachaf> Or are you saying that State has an adjoint?
15:24:44 <quchen> haasn: And  (e -> a -> x) vs (a -> (e, x)) is neatly shown by Reader/Env?
15:24:52 <quchen> I'm still not sure what to make of this
15:25:08 <shachaf> You can make a monad and a comonad.
15:25:15 <ikarus> merijn: yes, although you probably don't know me, but your name drifted by more then once at the UvA
15:25:32 <haasn> quchen: I meant ((e,a) -> x) sorry
15:25:45 <haasn> quchen: (it's just currying); and that's the adjunction between Reader and Writer
15:26:08 <shachaf> Instead of Reader and Writer can we just say (r ->) and (r,)? Much less confusing.
15:26:13 <benmachine> shachaf: State doesn't have an adjoint because it's a composition of a left adjoint and a right adjoint, I suppose
15:26:28 <merijn> ikarus: For a second I was worried whether that was as a positive thing or as an evil dictator, but then I realised I'm fine with either :p
15:26:28 <benmachine> shachaf: I mean, there's not a side that both of the functors have adjoints on
15:26:37 <shachaf> benmachine: Well, that doesn't mean that it doesn't. But it means that "composition of adjunctions" won't give you one.
15:26:38 <haasn> quchen: note (e -> a -> x) is just (e -> Reader a x) and ((e,a) -> x) is just (Writer a e -> x)
15:27:04 <benmachine> shachaf: yeah, that's what I meant
15:27:07 <quchen> Writer? As in the Monoid Monad thing? Where's the "Co" in what you're saying? I thought we were still on the Co-vs-non-Co topic
15:27:25 <shachaf> Forget about the names Reader and Writer, I say. Just write (e,) and (e ->)
15:27:32 <shachaf> (And read it, too.)
15:28:11 <quchen> Ah, when he says Writer he means the (e ->) type (and not whatever else there usually is for Writer, e.g. Monad instance)
15:28:19 <shachaf> No, (e,).
15:28:22 <haasn> (I didn't really remember what Env is, looks like Env and Writer are identical (other than the fact that one is a transformer)
15:28:58 * benmachine thinks... right adjoints preserve limits, can I think of any functors that preserve tuples that aren't just representables
15:29:34 <shachaf> benmachine: Anyway, I think the question was whether when F -| G where F is a comonad and G a monad (or vice versa) they were "related" somehow.
15:29:38 <haasn> quchen: yes I mean (e->) and (e,) when I say ‘Reader’ and ‘Writer’; those are just the names I'm used to I guess
15:30:01 <haasn> I'm still not fully aware of the Env/Traced stuff
15:30:04 <quchen> haasn: Ah okay, with that clarified let me read everything you said again :-)
15:30:29 <benmachine> shachaf: more related than being adjoint to each other?
15:30:43 <shachaf> benmachine: Yes.
15:31:17 <shachaf> benmachine: The example here is that the (e,) monad and (e ->) comonad both require e to be a monoid (and vice versa).
15:31:24 <quchen> haasn: Env is what comonad-transformers calls the "tuple" Comonad, Traced is the "function" one
15:31:28 <haasn> quchen: but the fact that we have similar relationships between Reader/Env and Traced/Writer makes them even more symmetric, doesn't it? :)
15:35:19 <acowley> I keep writing, join $ f <$> a <*> b
15:35:21 <acowley> It's ugly
15:35:33 <haasn> oI f a b J Io
15:35:41 * haasn ducks
15:35:50 <haasn> or s/J Io/Jo/
15:36:01 <quchen> Thanks for clarifying that.
15:36:03 <acowley> That's actually kind of nice
15:36:19 <shachaf> acowley: You can just make an alternative to <*> that joins, I think.
15:36:35 <acowley> ooh
15:36:38 <haasn> trivially, join .: (<*>)
15:36:44 <haasn> I need that too, now!
15:36:46 <shachaf> (I don't recommend either. But especially not pseudoidiom pseudobrackets.)
15:37:10 <haasn> but all the good <_)> names are taken..
15:37:12 <haasn> <_>*
15:37:18 <benmachine> how do you feel about join [i| f a b |]
15:37:19 <shachaf> :t fmap fmap fmap join (<*>)
15:37:20 <lambdabot> (Monad m, Applicative m) => m (a1 -> m a) -> m a1 -> m a
15:37:37 <acowley> benmachine: That's not too bad
15:38:07 <benmachine> acowley: I used to maintain the package that provided that quasiquoter but I stopped
15:38:09 <acowley> The wonders of fmap fmap fmap never cease
15:38:26 <acowley> I'm reluctant to use TH for such a minor thing
15:40:00 <benmachine> mm
15:40:08 <benmachine> I had an idea wrt TH the other day
15:40:09 <acowley> Oh man, Applicative uses <**>?
15:40:13 <acowley> What a waste
15:40:23 <merijn> Doesn't SHE doe this type of preprocessing?
15:40:34 <merijn> s/doe/do
15:40:36 <shachaf> Hey, I use <**> !
15:40:42 <acowley> Why?
15:40:42 <merijn> :t (<**>)
15:40:43 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
15:40:47 <benmachine> TH should be compiled with all the splices as holes, typechecked as far as possible, then the splices get access to all the bindings/type information available at that point
15:40:56 <merijn> shachaf: <**> should've been <&>
15:41:03 <benmachine> including their own context, that would be pretty cool
15:41:03 <haasn> no that's flip (<$>)
15:41:11 <haasn> and quite good at it, too
15:41:12 <merijn> :t <$>
15:41:13 <lambdabot> parse error on input `<$>'
15:41:17 <merijn> :t (<$>)
15:41:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:41:20 <acowley> <**> should have been <*> with a subtly different unicode star in the middle
15:41:21 <haasn> note the symmetry between $/<$> and &/<&>
15:41:28 <benmachine> type-directed expression resolution
15:41:29 <scshunt> benmachine: I'm not sure that givine a TH splice access to its own context is sane
15:41:30 <benmachine> what could go wrong?
15:41:32 <scshunt> but the rest I agree with
15:41:52 <benmachine> scshunt: I also doubt its sanity but I think it would be cool to try
15:41:53 <scshunt> it wouldn't actually solve anything though
15:41:56 <merijn> benmachine: Nothing, when Epigram is done! ;)
15:42:14 <merijn> Type direct program derivation!
15:42:54 <scshunt> benmachine: the problem is that GHC would have to stop on every unknown identifier
15:43:02 <scshunt> benmachine: this would lead to really weird, unintuitive behaviour
15:43:12 <benmachine> scshunt: huh? I don't follow
15:43:16 <benmachine> stop when?
15:43:21 <benmachine> which part are you talking about here
15:43:23 <scshunt> benmachine: when trying to analyze a declaration
15:43:25 <scshunt> outside a splice
15:43:32 <scshunt> since it wouldn't know if that identifier was referred to in the splice
15:43:43 <benmachine> scshunt: what do you mean by stop?
15:43:56 <scshunt> benmachine: hold onto that declaration until later
15:44:00 <haasn> Doesn't hdph do something like this?
15:44:04 <haasn> (need to)
15:44:17 <benmachine> scshunt: hmm. I think my story works much better for expression splices than declaration splices
15:44:28 <scshunt> benmachine: ah, yes, it would
15:44:39 <benmachine> of course most of TH is declaration splices, I guess :P
15:44:47 <scshunt> hmm
15:44:57 <scshunt> I should design a quasi-quoter for easy inclusion of declaration splices
15:45:10 <haasn> Oh, it just looks at the source code location
15:45:17 <scshunt> because if you have a declaration mutually dependent on a splice, you can stick it in with sequence, concat, and [d| |]
15:45:39 <scshunt> would be nice to have a quasiquoter that did all that for you
15:46:57 <scshunt> something like  $($([alsoD| data Foo |]) [someExpression])
15:48:20 <scshunt> or (:) <$> $(alsoD) <*> args I think?
15:48:21 <scshunt> err
15:48:36 <scshunt> hmm
15:50:59 <seanparsons> Taking the aeson cabal file as an example, is it not possible to get cabal to inherit the dependencies for the aeson library in the test-suite? https://github.com/bos/aeson/blob/master/aeson.cabal
15:51:19 <seanparsons> All of the dependencies get duplicated, which seems like a maintenance nightmare.
15:55:18 <benmachine> seanparsons: in general the dependencies need not be identical
15:55:50 <benmachine> seanparsons: the common thing is for test suites to have additional dependencies, but I suspect it's also possible for them to have fewer in some circumstances
15:56:09 <mel-> Hi. I have cabalized my package. Is there a way to configure it in such a way that when i execute 'cabal build' it displays the actual ghc-invocatoins (including options)? Similar to what 'make' does? It seems that cabal adds some options to ghc in order to eliminate calls eo 'assert' in my code. I'd like to keep my asserts!
15:56:21 <seanparsons> benmachine:  If you're writing the tests for a library they would have to be a superset of the library's dependencies, I'm looking for a way
15:56:29 <seanparsons> ...to avoid the duplication.
15:56:37 <monochrom> mel-: "cabal build -v"
15:56:39 <merijn> Anyone know if there's a flag to silence the warning "The function `main' is not defined in module `Main'"?
15:57:29 <mel-> aaah, that was easy. thanks, monochrom
15:57:32 <monochrom> to preserve assertions: disable optimizations. "cabal configure --disable-optimization
15:57:33 <benmachine> seanparsons: I don't think they would have to be a superset, I think you can actually depend on the library itself
15:57:38 <merijn> seanparsons: You could make the tests depend on the library itself
15:57:51 <merijn> seanparsons: You only need the dependencies used by the actual test
15:58:10 <seanparsons> When I've done that in the past it hasn't worked, which seems to be born out by the aeson build as well.
15:58:11 <monochrom> cabal default is --enable-optimization=1
15:58:17 <seanparsons> I may well be wrong however.
15:58:20 <benmachine> merijn: is that a warning? I thought that was an error, is it in your export list?
15:58:30 <mel-> nice, nice. thank you!
15:58:39 <seanparsons> In the aeson one, the tests depend on base, containers, unordered-containers, etc, etc.
15:59:00 <merijn> benmachine: Dunno, might be an error. I'm using hdevtools to get warnings while editing in vim, it's really annoying to get that message for files without a module definition
15:59:22 <benmachine> merijn: put a module definition :P
15:59:28 <merijn> benmachine: Basically, if I'm writing into a scratch file without a module declaration I don't want to get a message about a missing main
15:59:47 * benmachine writes module Banana where as reflex
15:59:48 <merijn> benmachine: Yeah, but that gets really tedious the 1500th time you write "module Foo where" just to get hdevtools to stop whining
16:00:45 <benmachine> aw, ghc won't let me compile /dev/null
16:00:52 <monochrom> merijn: you may like -no-hs-main
16:01:02 <benmachine> I may like monochrom
16:01:19 <benmachine> we can't be sure.
16:02:03 <monochrom> -no-hs-main was originally intended for "the main is in a C file"
16:02:16 <parcs> > 0x1e0
16:02:18 <lambdabot>   480
16:03:03 <monochrom> benmachine: http://spikedmath.com/445.html
16:04:13 <benmachine> monochrom: :)
16:04:23 <merijn> monochrom: I <3 you
16:04:51 <seanparsons> If I comment out containers from the build-depends for the aeson test-suite it complains about containers not being in build-depends, but surely it should be a transitive dependency from the aeson lib?
16:05:02 <merijn> No, wait
16:05:06 <merijn> I take back my <3
16:05:19 <merijn> hdevtools was just slow, it's still a error/warning!
16:07:46 <seanparsons> benmachine: Is it just the case that this is the cabal behaviour and we have to deal with it?
16:08:53 <benmachine> seanparsons: I don't think dependencies should work how you want them to
16:08:59 <merijn> seanparsons: No, depending on a library is not transitive
16:09:05 <benmachine> seanparsons: however you are welcome to disagree
16:09:54 <merijn> seanparsons: And just because aeson depends on library X doesn't mean your tests do (i.e. if all collections are created/consumed by your library your tests don't have to depend on the collections at all)
16:10:02 <acowley> Depending is sort of transitive, but available imports are not transitive
16:10:19 <acowley> Which will eventually take us to the bright future of multiple versions of libraries linked into one binary
16:10:20 <benmachine> acowley: depending in the sense of having-in-your-build-depends
16:10:25 <acowley> right
16:10:26 <benmachine> and hence being exposed by cabal
16:10:28 <acowley> oh
16:10:46 <acowley> Yes, it's the exposure part that is at issue here
16:11:23 <seanparsons> benmachine, merijn: I have no particular opinion, I can see some benefit to them not being transitive. It's counter to how other build tools do it, which is why it's not necessarily clear and it doesn't really appear to be documented that this is the behaviour.
16:11:59 <benmachine> seanparsons: good documentation is hard to come by
16:12:05 <benmachine> however I should be in bed
16:12:15 <acowley> I think the way cabal does it is nice
16:12:16 <merijn> seanparsons: Well, it's transitive in the sense that "if your test depend on your library, they implicitly depend on everything your library depends on"
16:12:16 <seanparsons> It's likely to be frustrating to me as in my case I'll be looking at something with two test-suite instances (if that's possible) which means copy pasta all over the place.
16:12:40 * haasn is a bit confused on how Codec.Compression.Zlib.Lens made it into ‘lens’
16:12:50 <haasn> shouldn't that be a separate package zlib-lens or whatever
16:12:50 <merijn> seanparsons: However, it's not transitive in the sense that "packages that are imported should be explicitly listed in the build-depends"
16:13:09 <benmachine> seanparsons: http://beta.hackage.haskell.org/package/Cabal-1.18.1/Cabal.cabal has two test suites
16:13:32 <benmachine> seanparsons: that's the only part of your problem I can help with, I'm afraid
16:13:47 <supki> haasn: zlib is in the platform
16:13:53 <seanparsons> benmachine: That's cool, like I said, not really a problem just something that's quite different.
16:14:15 <haasn> supki: Not everybody uses the platform :P
16:14:22 <supki> right
16:14:27 <seanparsons> merijn: Well yeah, in the sense that the library wouldn't work without that there, but not in the sense that you can use those libraries in the test-suite (in my example).
16:14:40 <haasn> But does lens incur a ‘zlib’ dependency only for that module?..
16:14:57 <supki> I think so
16:14:59 <benmachine> seanparsons: it's possible to help with some of the rest of your problem, but only while awake :P
16:15:04 <seanparsons> merijn: It would be handy if I could bundle up all those dependencies somewhere and refer to them from multiple places.
16:15:10 <haasn> it just seems a bit out of place I guess
16:15:13 <haasn> I'll ask edwardk
16:15:27 <seanparsons> benmachine: It's fine, you have been of help, don't you worry. :)
16:16:58 <acowley> that does seem a somewhat excessive dependency for lens
16:17:51 <niteria> I have a running haskell program, compiled with -threaded -O2 -with-rtsopts=-T, can I somehow attach to it to see what uses so much memory?
16:17:51 <acowley> Wait, where is that in lens?
16:18:33 <acowley> niteria: To see what specifically is using memory, I think you'll have to use memory profiling and analyze it after the fact
16:18:41 <niteria> Names of the data constructors would be enough
16:18:49 <acowley> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/prof-heap.html
16:18:59 <niteria> increased memory usage happens after 2-4days
16:19:11 <niteria> and I've been unable to reproduce it
16:19:59 <niteria> it sort of looks like if gc just gave up
16:20:30 <acowley> Bugs that take days to reproduce are never fun
16:20:44 <acowley> Can you simulate heavier load to trigger the issue faster?
16:21:20 <niteria> I've tried that, but on synthetic load it works just fine
16:22:02 <niteria> it's suspiciously time dependent
16:23:05 <acowley> I've never tried to tap into the heap profiling data while running
16:23:32 <acowley> niteria: Your problem is not fun
16:23:38 <niteria> I wonder how much disk space would 4day heap profile take
16:24:28 * tabemann remembers that a few *seconds* event dump will make threadscope explode all the RAM on his system with ease
16:25:02 <tabemann> (just why does threadscope do that on my system?)
16:25:19 <Kevin-_-> is there a way to set a default value when calling a function?  i.e. if I have void myfunct (int value = 0) { printf("%d\n", value); }
16:25:39 <Kevin-_-> then when I called myfunct it would print 0, if I did myfunct 3 it would print 3
16:25:56 <niteria> you can simulate that with records
16:27:23 <Kevin-_-> ah I see
16:28:16 <acowley> It doesn't really simulate default arguments from other languages, does it?
16:29:06 <niteria> and I'm pretty sure you could do that with some typeclass hackery
16:29:14 <apples> sounds like Maybe may be a better fit
16:29:17 <Makoryu> niteria: Like Printf?
16:29:32 <Makoryu> acowley: Depends how you do it, really. The semantics are there if you put them there.
16:30:06 <acowley> Maybe is the right fit
16:30:29 <niteria> Makoryu: I haven't seen the printf implementation, but I guess so
16:30:41 <acowley> No
16:31:00 <niteria> I've only seen polyvariadic functions and it looks like it could be easily adopted
16:31:18 <acowley> printf is wonderful, and I ape it for OpenCL driving code, but it's too heavy a pattern to be used all over
16:31:22 <niteria> but it's better to go with Maybe or records
16:32:26 <niteria> records simulate named arguments which is nice
16:42:31 <ludwig`> Best haskell to javascript compiler? Found "http://www.haskell.org/haskellwiki/The_JavaScript_Problem". Unfortunately, it gives alot of options without clearly identifying which is the most stable/complete/supported.
16:43:46 <Makoryu> ludwig`: It also seems to be (as usual, for Haskell wiki pages) awkwardly incomplete and outdated
16:44:21 <geekosaur> for what it's worth, (a) it seems to be a tossup between fay and ghcjs currently; (b) ghcjs will be in ghc's next release
16:44:51 <geekosaur> I think fay generates better code for browsers whereas ghcjs is a more complete and more faithful implementation?
16:45:04 <geekosaur> (but also much larger and slower generated code)
16:45:53 <shachaf> Well, Fay isn't Haskell. So that's a bit of a problem if you want to compile Haskell.
16:46:11 <bergey`> How active is fay's development?  I know there's a lot going on with ghcjs.
16:46:12 <hpc> i am going to go ahead and be the jerk who says "why would you ever compile to javascript"
16:46:21 <merijn> hpc: MOP
16:46:31 <merijn> hpc: Money-Oriented Programming :)
16:46:37 <geekosaur> because you want to write sruff to run in a web page but want to use a real language?
16:46:45 <niteria> I wonder how usefull would be to connect to haskell program with gdb
16:46:58 <merijn> niteria: ghci has a debugger builtin
16:47:11 <geekosaur> not very; gdb doesn't really understand how ghc code is evaluated
16:47:22 <merijn> @quote cmccann debugger
16:47:22 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
16:47:46 <hpc> niteria: maybe if you wanted to learn how evaluation worked
16:47:55 <merijn> niteria: Are you aware of the existence of Debug.Trace?
16:48:10 <niteria> I want some way to connect to a running process to get some information
16:48:12 * merijn finds trace more useful than the debugger in terms of doing actual debugging
16:48:38 <niteria> I want to know what takes up my memory
16:48:39 <merijn> niteria: gdb can certainly attach to a running process and 'get some information', but it won't be particularly useful
16:48:51 <merijn> niteria: Oh, that's what the heap profiler is for
16:49:02 <niteria> but I would need to run it for 4 days
16:49:35 <niteria> and I'm pretty sure that would be gigabytes of data
16:50:03 <merijn> ludwig`: As far your question, I think ghcjs is the most complete compiler and it will be integrated in the 7.8 release of GHC, last I heard
16:50:04 <niteria> maybe if I could set very low sampling frequecy that would help
16:50:53 <merijn> ludwig`: Fay is a compiler for a "haskell-like" language to JS, but not actual haskell (i.e., something that is Fay will be valid haskell, but not necessarily the other way around), ghcjs even supports lightweight threads and MVars :)
16:51:46 <ReinH> Wrote some Rails. Feel stupider. Time for more Haskell.
16:52:05 <merijn> ludwig`: UHC is supposedly pretty solid, but I'm not familiar with it, I don't think it supports haskell threads, but I could be wrong
16:52:43 <ReinH> merijn: How well can you implement Haskell threads on an evented runtime anyway?
16:52:49 <merijn> ludwig`: JMacro and Roy I never heard of, so those are probably irrelevant, Idriss is a dependently typed language separate from Haskell and I'm not sure what it's doing on that list
16:53:02 <merijn> ReinH: According to luite the answer to that question is "pretty well"
16:53:12 <geekosaur> ReinH, any time you use threads without -threaded, you're using an evented runtime
16:53:22 <ReinH> geekosaur: that's true, but why would you do that? :p
16:53:25 <merijn> ReinH: It makes no sense if you have computational threads, of course. But for concurrent IO stuff it's easy
16:53:36 <merijn> ReinH: For code clarity's sake?
16:53:46 <ReinH> TIL threads make code *more* clear
16:53:56 <ReinH> :p
16:53:59 <merijn> ReinH: They do if you have no mutable shared state :)
16:54:12 <geekosaur> well, they do in haskell at least. not something I'd claim about threads in other languages :)
16:54:28 <hpc> geekosaur: prolog with threads could be interesting
16:54:30 <merijn> Oh, apparently Idriss has a JS backend? heh, who knew
16:55:08 <ucefkh> salam Idriss
16:55:14 <ucefkh> hello haskel
16:55:34 <merijn> ludwig`: Anyhoo, Fay, UHC and ghcjs are the only really relevant ones if you want to do frontend dev, I think. Of which UHC/ghcjs try to actually compile haskell and Fay just tries to be a haskell compatible dialect
16:58:18 <Makoryu> It's gonna be a strange world when ghcjs is officially released
16:58:59 <Makoryu> "It compiles to JS" will be an officially supported selling point of the main Haskell implementation
16:59:09 <Maior> iä
16:59:17 <merijn> Well, the release was planned together with 7.8 and ICFP, so that'd be approximately any moment now
16:59:23 <Makoryu> Yeah
16:59:26 <merijn> Supposedly cabal support is in the works too
16:59:50 <Makoryu> merijn: Meaning what? You can fetch packages from the browser?
17:00:45 <geekosaur> meaning cabal will be able to build libraries for ghcjs
17:00:47 <merijn> Makoryu: Cabal support for dependency resolution, etc. for libraries written for ghcjs
17:00:57 <merijn> And building, obviously
17:01:22 <merijn> Makoryu: i.e. have a JS library depending on a bunch of other stuff? Just "cabal install foo" rather than manually messing with js files :)
17:01:40 <Makoryu> Dang
17:02:00 <geekosaur> (of course it cannot help with libraries using the C FFI; such libraries would need a JS FFI variant)
17:03:28 <merijn> It'll be interesting to see what happens after :)
17:05:32 <haasn> compile cabal-install using ghcjs
17:10:13 <Redz> acid-state or haskelldb?
17:13:10 * hackagebot sym 0.9 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.9 (AndersClaesson)
17:18:00 <levi> I don't think there's any reason to count jmacro out just because one opinionated guy hasn't used it.  It's actually pretty nifty.
17:20:17 <ucefkh> levi i agree
17:22:06 <haasn> Redz: they're fairly different
17:22:20 <haasn> acid-state is for persisting state that is kept in memory
17:22:28 <haasn> haskelldb is for interacting with an actual database system
17:22:56 <haasn> Also I think ‘persistent’ is more popular for that
17:23:40 <Redz> haasn: and if i generate too much data?
17:24:44 <haasn> Too much data to fit into memory? Then acid-state won't be of awful much use for that unless you want to rely on swap space and stuff
17:24:56 <haasn> But if you have a large store I wouldn't use acid-state either way
17:25:37 <haasn> Hmm... now I want to experiment with creating large distributed key/value or relational stores using distributed-process, acid-state and many workers..
17:26:33 <AfC> haasn: or you could just spin up a Riak cluster and use that
17:26:38 <Redz> haasn: best of both worlds would be nice.
17:27:00 <AfC> (for bog's sake, don't go inventing a distributed key/value store from scratch)
17:28:06 <haasn> http://hackage.haskell.org/package/riak aha!
17:28:11 * hackagebot network-bitcoin 1.4.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.4.0 (ClarkGaebel)
17:28:32 <haasn> AfC: well it would be for coolness factor
17:29:26 <AfC> haasn: don't be ridiculous. It's a hard problem and smart people have already worked years of their lives on it. You would better serve humanity by putting your time into something that leverages their efforts rather than duplicating and not coming even close¹
17:30:11 <AfC> ¹ Caveat: unless you truly have a unique take on the problem space, are aware of all the prior art and why it will not do, and are convinced that you and you alone can do better
17:30:17 <AfC> (in which case go nuts)
17:30:51 <haasn> Is Riak the ‘state of the art’ then, in your opinion?
17:31:16 <AfC> It is one of about three contenders that survived from the dozens of people|projects that set out to make such a thing
17:31:23 <Maior> woo riak
17:32:41 <AfC> Cassandra and of course the original Dynamo being others. I think rather well of Riak so far, more due to the fact that I'm looking after several others' Cassandra clusters and increasingly being underwhelmed by it.
17:33:17 <haasn> Well the main ‘advantage’ of a Haskell-y approach would be directly working with SafeCopy/Serializable data types instead of having to go through JSON, but that may as well just be better off as a higher-level wrapper (that serializes to JSON)
17:33:31 <Thulsadum> i guess, i've now totaly screwed my haskell packages... how can i reset (i.e. delete) it?
17:33:51 <haasn> Thulsadum: deleting .ghc and .cabal usually does a good job of wiping “everything”
17:34:08 <Thulsadum> ah, i missed the first one.
17:34:17 <Thulsadum> wasn't aware of it
17:34:19 <shachaf> "deleting" means "moving them to some other directory until everything is working, come on, you have the disk space", by the way.
17:34:53 <haasn> I think that goes without saying
17:34:54 <Thulsadum> shachaf: yep, that's the meaning of deletion. :)
17:35:06 <Clint> also "wiping"
17:36:01 <haasn> Hmm.. how useful would a command be that exposes an interface like ‘rm’ but will internally hardlink/copy the contents somewhere else, and use some form of VCS or history or something to keep track of files you've deleted that you could ‘undelete’
17:36:08 <haasn> Not for scripting and efficiency, but for manual user interaction
17:36:30 <Clint> i think i've seen some trashcan things like that
17:36:31 <acowley> You don't have your entire home directory in git?
17:37:00 <geekosaur> there are lots of trashcan implementations. dunno how many back it with vc
17:37:01 <haasn> acowley: I keep media in my home directory :( Maybe I should move that to /media and symlink them
17:37:10 <acowley> git-annex to the rescue?
17:37:12 <geekosaur> haasn: git-annex
17:37:15 <acowley> I want to love git-annex
17:37:27 <Makoryu> I wonder if Haskell->JS compilation could be used to boot GHC on weird platforms
17:37:37 <hpc> but git-annex doesn't want to love you?
17:37:38 <Makoryu> (This doesn't actually make sense)
17:37:43 * haasn keeps hearing these wonderful things about git-annex but never bothered to actually read up/learn about it... :(
17:37:46 <acowley> No it doesn't
17:38:18 <haasn> Makoryu: you could run GHC on weird platforms that way but will it help actually producing native code for that platform?
17:38:30 <acowley> I tried using it, and got myself completely twisted around with lost files (luckily I'd done a non-git-annex backup prior)
17:38:45 <acowley> I also really want to use it with glacier, but the CLI tools for that are in a bizarre forked state
17:39:27 <Makoryu> haasn: Realistically, GHC is probably too coupled to native code generation, and to compiling for the environment it was built in, for that to actually happen
17:39:55 <Makoryu> Hence "doesn't make sense"
17:39:59 <haasn> Makoryu: yeah I guess so. I don't have much experience cross-compiling with GHC either, I wish it were as simple as “ghc -target win32 ...” or whatever
17:40:02 <Makoryu> Even if it technically worked it would buy you nothing
17:43:10 <zq> is there a built-in equivalent to (\x y -> [x, y]) ?
17:44:03 <Makoryu> @pl \x y -> x : y : []
17:44:03 <lambdabot> (. return) . (:)
17:44:34 <zq> yeah no
17:44:38 <zq> :t (:)
17:44:38 <lambdabot> a -> [a] -> [a]
17:44:39 <Makoryu> I tried
17:44:51 <zq> what's @pl?
17:45:04 <acowley> pointless (pointfree)
17:45:08 <Makoryu> It's a magic trick for rewriting functions
17:45:15 <Makoryu> Usually doesn't actually help though
17:45:24 <acowley> But when it does, it's magic!
17:45:36 <hpc> it always works sometimes
17:46:00 <Makoryu> @pl \f xs -> zipWith f xs (tail xs)
17:46:03 <lambdabot> flip (ap . zipWith) tail
17:46:03 <lambdabot> optimization suspended, use @pl-resume to continue.
17:46:03 <acowley> hpc: usually
17:48:18 <joelteon> ap zip tail
17:49:02 <ReinH> If you want magic, try djinn ;)
17:49:36 <joelteon> @djinn Monad m => (a -> m b)
17:49:36 <lambdabot> -- f cannot be realized.
17:49:42 <joelteon> @djinn Monad m => (a -> m b) -> [a] -> m [b]
17:49:42 <lambdabot> Error: Undefined type []
17:49:49 <joelteon> cmooooonnn
17:50:29 <geekosaur> djinn can't handle recursive types, I think (so no lists)
17:50:55 <zq> so no builtins?
17:50:58 <joelteon> @djinn Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
17:50:58 <lambdabot> -- f cannot be realized.
17:51:02 <shachaf> It's not as if lists would do you any good.
17:51:03 <zq> :T ap
17:51:05 <zq> :t ap
17:51:06 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:51:32 <zRecursive> :t ap zip
17:51:32 <lambdabot> ([a] -> [b]) -> [a] -> [(a, b)]
17:51:43 <zRecursive> very clear
17:51:57 <acowley> Boy, our "magic" is pretty impressive
17:53:27 <ReinH> super impressive
17:53:28 <dmj`> if Applicative => Monad goes through, will `ap` be removed?
17:53:48 <acowley> Probably not
17:53:52 <Makoryu> Would Applicative end up in Prelude
17:54:00 <acowley> Hopefully
17:54:01 <dmj`> since it would be redundant, because (<*>) does the same thing
17:54:14 <acowley> It's redundant, but folks would object to breakage
17:54:14 <Transhumanist> I wish Scala was a beautiful as Haskell. :(
17:54:17 <Makoryu> dmj`: We already have <$> and fmap
17:54:43 <zRecursive> :t (<$>)
17:54:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:55:37 <dfan> Heck, we already have map and fmap
17:56:07 <zRecursive> :t fmap
17:56:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:56:34 <zRecursive> @src (<$>)
17:56:34 <lambdabot> f <$> a = fmap f a
17:56:38 <dmj`> Makoryu: true, and liftM, <$> just seems more tolerable. Would be cool to have only <$>, <*>, return and (>>=), for Functor => Applicative => Monad.
17:57:35 <enthropy> it's not like there's a shortage of names
17:57:42 <enthropy> and you can always shadow
17:57:50 <Transhumanist> not portable
17:57:58 <enthropy> > let f ap = ap + 1 in f 2
17:57:59 <lambdabot>   3
17:58:49 <dmj`> if not return, what would we call it? lift :: a -> m a. What's a cool lifting symbol? (..^) :: a -> m a
17:59:19 <Makoryu> Pretty sure lift is taken
17:59:25 <hpc> i would call it goto
17:59:48 <hpc> but i am a monster
18:00:01 <dmj`> yea, MonadTrans has it
18:00:04 <zRecursive> :t return
18:00:05 <lambdabot> Monad m => a -> m a
18:00:10 <zRecursive> :t lift
18:00:11 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:01:04 <zRecursive> it is not `lift :: a -> ma` ?
18:01:29 <Makoryu> zRecursive: It does something totally different from return
18:02:06 <zRecursive> yeah, there is MonadTrans context
18:02:15 <haasn> for some meaning of “totally different”; I think there's some sort of structure on top of monad transformers where ‘lift’ acts a little more like ‘return’
18:02:23 <ReinH> Makoryu: I don't know about totally different
18:02:29 <haasn> but I can't really think of anything right now
18:03:01 <hpc> haasn: a kind of Point-y relationship?
18:03:40 <ReinH> the lift laws show a passing similarity to the fmap laws
18:03:54 <Makoryu> ReinH: Well.... I guess it's the same kind of "different" you get when comparing newtype and data
18:03:59 <haasn> hpc: I'm not really sure. I remember talking about this like a year ago
18:04:02 <ReinH> lift . return = return vs fmap id = id
18:04:16 <ReinH> lift (m >>= f) = lift m >>= (lift . f) vs  fmap (f . g)  ==  fmap f . fmap g
18:04:35 <haasn> ReinH: yeah that makes sense
18:04:38 <hpc> ReinH: that second one should be
18:04:57 <hpc> lift . (f <=< g) = (lift . f) <=< (lift . g)
18:05:09 <ReinH> hpc: then you might want to fix the documentation :)
18:05:13 <ReinH> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Class.html
18:05:20 <haasn> hpc: cute, I like it :)
18:05:21 <hpc> ReinH: they're the same
18:05:27 <ReinH> hpc: ah I see what you're doing there
18:05:29 <hpc> ReinH: i mean just for making it visually similar
18:05:31 <haasn> you should add it to the documentation regardless!
18:05:49 * haasn is also a big fan of (f >=> g) >=> h  =  f >=> (g >=> h) -- for associativity of Monads
18:06:06 <ReinH> hpc: feels like there's a homomorphism here of some sort...
18:06:23 <shachaf> haasn: free monad monad monad algebras forever
18:06:27 <hpc> ReinH: probably something silly to do with categories / arrows
18:06:38 <ReinH> hpc: well it looks like it sends application to composition
18:06:43 <hpc> ReinH: given the way that the (>=>) formulations of the monad laws turn out to be a kleisli category
18:06:55 <zRecursive> :t (>=>)
18:06:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:06:56 <ReinH> and composition to <=<
18:07:26 <ReinH> hpc: and that's about as far as my feeble math brain will go :)
18:07:40 <hpc> it's about as far as mine goes too :(
18:07:59 <ReinH> sadly all the really smart haskellers are at ICFP :p
18:08:07 <hpc> i do much better with general coding style problems
18:08:15 <zRecursive> :t (f >=> g)
18:08:16 <lambdabot> (Monad m, Show a, Show b, FromExpr (m b), FromExpr (m c)) => a -> m c
18:08:34 <haasn> I do much better with ‘rewrite things in obscure lensy ways’ problems :(
18:08:36 <ReinH> that is not very pretty
18:08:40 <joelteon> :t (?f >=> ?g)
18:08:41 <lambdabot> (Monad m, ?f::a -> m b, ?g::b -> m c) => a -> m c
18:08:46 <ReinH> better
18:08:58 <ReinH> oh yeah that makes the morphism more obvious
18:09:08 <joelteon> implicit params are the best
18:09:15 <joelteon> we just need to somehow enforce that you can't use them in real code
18:09:43 <ReinH> it's almost definitely a functor from something to the kleisli category?
18:09:43 <zRecursive> joelteon: "?" is better
18:09:46 <shachaf> I'm not sure how "(Monad m, ?f::a -> m b, ?g::b -> m c) => a -> m c" is more obvious than "Monad m => (a -> m b) -> (b -> m c) -> a -> m c"...
18:09:50 <ReinH> definitely sort of maybe?
18:10:00 <joelteon> shachaf: because ?f and ?g are in the type signature
18:10:05 <ReinH> shachaf: help!
18:10:09 <joelteon> it's like annotating each argument
18:10:21 <hpc> shachaf: they look the same to me ;)
18:10:47 <hpc> albeit the implicit params version is more "value-oriented"
18:11:06 <hpc> like, "if you do this, these are these types and that's this type"
18:11:44 <ReinH> shachaf: you're mathy... what's the relationship between fmap and lift from MonadTrans? It looks like a homomorphism?
18:11:51 <shachaf> help
18:12:17 <ReinH> heh
18:12:26 <monochrom> thank you for calling tech support. how may I help you?
18:12:31 <shachaf> :t lift
18:12:32 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:12:42 <ReinH> shachaf: compare the fmap laws to the lift laws
18:12:47 <ReinH> it looks like it sends application to composition
18:12:50 <elliott> (forall a. m a -> n a) -> t m a -> t n a is relevant.
18:12:52 <ReinH> and . to <=<
18:12:59 <elliott> that's (m ~> n) -> t m ~> t n
18:13:05 <elliott> and lift is m ~> t m
18:13:12 <elliott> aka fmap and pure
18:13:29 <enthropy> is that generalization useful if you still have to decide which one you want (lift vs. return)?
18:13:35 <haasn> elliott: can this be made explicit with one of those generalized/indexed Category/Functor classes?
18:14:46 <elliott> type f ~> g = forall a. f a -> g a
18:14:49 <ReinH> shachaf, elliott: so I think it's a functor from something to the Kleisli category?
18:15:13 <ReinH> it's a functor functor? My brain hurts.
18:18:38 <haasn> ‘functor functor’ -> natural transformation?
18:19:43 <shachaf> "functor between functor categories"?
18:20:20 <ReinH> it's a functor monofunctorendomorphism
18:20:21 <ReinH> obv
18:20:36 <ReinH> monoid
18:20:44 <ReinH> definitely involves a monoid somehow
18:23:22 * hackagebot cab 0.2.0 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.0 (KazuYamamoto)
18:37:05 * thorrr slaps xinming around a bit with a large trout
18:40:18 <elliott> thorrr: um, you might want to turn off that script :)
18:40:52 <luite> vewy vewy quiet
18:41:22 <luite> i guess everyone went to boston or cambridge for dinner
18:41:47 <acowley> elliott: I'm trying to make machines pretty, btw
18:41:53 <acowley> elliott: But I'm not touching Plan yet
18:42:14 <acowley> I have concurrent tee and wye and ~> and buffers, and bidirectional feedback loops
18:42:30 <luite> \o/
18:42:33 <acowley> If things are working for my uses I'll try to backport some of the pieces I'm using to build these out of
18:42:34 <BMeph> Is there an (m ~> t n) -> (t m ~> t n)?
18:43:15 <acowley> Which ~> is that?
18:45:53 <joelteon> @djinn (a -> m b) -> (m a -> m b)
18:45:53 <lambdabot> -- f cannot be realized.
18:48:03 <pavonia> @djinn Monad m => (a -> m b) -> (m a -> m b)
18:48:04 <lambdabot> f a b = b >>= a
18:56:17 <shachaf> @djinn Monad f => (c -> f d) -> (f c -> f d)
18:56:17 <lambdabot> -- f cannot be realized.
18:56:20 <shachaf> "whoops"
18:59:35 <apples> wait, what?
19:03:18 <stevejb> hello, I have a newbie question about deriving types and nested types. I have the following simple example that does what I want, but I want to make sure I understand the Data and Typeable derivations
19:03:20 <stevejb> http://lpaste.net/93330
19:05:14 <stevejb> specifically, say if the Sample type did not derive Data and Typeable, would MegaType not be able to also derive those things?
19:05:55 <joey__> Can anybody tell me how to do a complete uninstall of my Cabal packages on Windows? I've messed it up, and I think it's best to start from scratch.
19:10:54 <pavonia> stevejb: How would you prevent a type from being a Data or Typeable instance then?
19:11:54 <shachaf> By not exporting the constructors?
19:12:20 <pavonia> I think that doesn't matter, the instances are exported anyway
19:12:32 <shachaf> Maybe I misunderstood.
19:12:55 <luite> hm, does standalone deriving work without the constructors then?
19:13:24 <shachaf> I should hope not.
19:14:11 <luite> yeah i'd expect not, but its a thing that doesn't need to look at the data at all
19:14:35 <luite> so an exception wouldn't seem too unreasonable :)
19:15:18 <luite> shachaf: what day are you arriving at icfp?
19:15:31 <shachaf> luite: Not sure. Not in 2013, at any rate.
19:15:45 <luite> hmm, i'll probably not stay that long :(
19:19:44 <stevejb> pavonia: I think I need to understand the DeriveDataTypeable stuff a bit more. I am trying to understand and adapt some sample code to get my program to take command line arguments
19:20:53 <pavonia> Do you even need Data and Typeable for that?
19:21:40 <stevejb> apparently so. It does not work with runhaskell if I take them out
19:23:23 <stevejb> perhaps not typeable but at least Data
19:24:24 <stevejb> experimenting, it does seem like both Data and Typeable are needed, at least for my sample code
19:32:42 <gaze__> Hey folks, I have what should be a pretty easy question
19:34:13 <gaze__> say I want to abstract over the windows event pump... so I can implement a similar strategy for linux and os x.
19:44:07 <ReinH> stevejb: what library are you using for command line arg handling?
19:44:57 <zRecursive> ReinH: is getArgs not enough ?
19:45:04 <zRecursive> :t getArgs
19:45:05 <lambdabot> Not in scope: `getArgs'
19:45:13 <ReinH> if it does what you want, sure
19:45:13 <zRecursive> :hoogle getArgs
19:46:08 <monochrom> getArgs is in System.Environment. comes with GHC
19:48:01 <startling> @where getArgs
19:48:01 <lambdabot> I know nothing about getargs.
19:48:29 * hackagebot mono-traversable 0.1.0.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.1.0.0 (MichaelSnoyman)
19:51:54 <dmj`> @typ getArgs
19:51:55 <lambdabot> Not in scope: `getArgs'
19:51:55 <hiptobecubic> Does anyone have a cabal.conf that locks packages to the version in the latest haskell platform?
19:52:53 <Rarrikins> @hoogle getArgs
19:52:53 <lambdabot> System.Environment getArgs :: IO [String]
19:52:53 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
19:52:53 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
19:53:29 * hackagebot pandoc-citeproc 0.1.1.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.1.1.1 (JohnMacFarlane)
20:04:37 <dmj`> @typ catch
20:04:38 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
20:10:16 <lcfrs> Any reason why haskell-src is part of Haskell Platform instead of haskell-src-exts?
20:10:44 <haasn> Would it be possible to come up with an x86 EDSL for writing highly performant algorithms (eg. SIMD stuff), that synthesizes to native code at runtime? (Perhaps with access to information about the processor it's running on..)
20:11:22 <elliott> @hackage harpy
20:11:22 <lambdabot> http://hackage.haskell.org/package/harpy
20:11:25 <elliott> @hackage that-one-llvm-thing
20:11:25 <lambdabot> http://hackage.haskell.org/package/that-one-llvm-thing
20:11:32 <shachaf> Certainly it'd be possible.
20:13:07 <luite> elliott: hmm, i clicked that link and was kinda disappointed that it wasn't a package :(
20:13:30 * hackagebot monarch 0.10.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.10.0.0 (NoriyukiOhkawa)
20:14:12 <elliott> augustss has some llvm-y blog posts doing that sort of thing.
20:15:36 <haasn> I... don't think that's an actual package (that-one-llvm-thing)
20:16:03 <haasn> elliott: thanks!
20:17:16 <shachaf> I even heard of this crazy optimization where compilers can generate x86 code at *compile time*.
20:22:09 <haasn> shachaf: I don't know much about the FFI or primitive operations and stuff. What would I need to go through if I wanted to produce binaries that used, say, SSE operations for my algorithms?
20:22:32 <haasn> Preferably without ‘writing the algorithm in C and using the FFI’
20:22:38 <shachaf> That depends.
20:22:45 <shachaf> You could write the algorithm in C and use the FFI.
20:23:02 <shachaf> There are SSE primops that you can use to write SSEy code in Haskell, or so I hear.
20:23:29 <Makoryu> haasn: Pull the pin, throw the problem at Repa, then scream and dive behind a table.
20:24:15 <haasn> The main reason I'd be interested in this being some sort of user library (rather than a compiler-embedded primop or similar) is because that allows more flexibility across platforms, processor architectures - think about new extensions to x86 in the latest line of processors, if those had to be explicitly added as GHC primops or something it would depend on compiler changes to keep up, rather than a
20:24:17 <haasn> comparatively simple library change
20:24:55 <haasn> Of course, if primops are definable in a generic way from within user libraries, without requiring some sort of compiler acknowledgement for that particular instructions, the result would be equally satisfying
20:25:26 <Makoryu> I seem to recall hearing that GHC supports plugins for intercepting various compilation phases
20:25:33 <Makoryu> Don't know how this actually works
20:25:54 <jmcarthur> Makoryu: i only know about core-to-core transformations being written with that. that may be all it can do?
20:26:00 <Makoryu> Maybe
20:26:32 <scshunt> Is using Either String () a common idiom for a function that may fail?
20:26:48 <haasn> scshunt: depends, I like http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
20:26:52 <startling> scshunt, that's the same as Maybe String
20:27:03 <scshunt> startling: yes, but more idiomatic with using Either to report errors
20:27:13 <shachaf> startling: The Monad instance is different.
20:27:17 <startling> sure. if it fits with the rest of your code, do it.
20:27:18 <scshunt> usually Nothing indicates failure, where in this case it would represent the opposite and hence be unidiomatic
20:27:27 <startling> shachaf: that's true.
20:27:32 <shachaf> I think it's implied that this is "Either String a" instantiated at a=()
20:27:40 <haasn> scshunt: I can't imagine what sort of function would ‘possibly fail’ while producing a (), though
20:28:00 <startling> const (Left "!")
20:28:02 <haasn> unless you meant something like IO (Either String ()) ?
20:28:05 <shachaf> Hooray for, like, naturality or something, man.
20:28:10 <NemesisD> every time i search for tmchan there's this computer science professor named T.M. Chan that comes up first
20:28:12 <shachaf> haasn: Well, presumably a function returns this.
20:28:26 <shachaf> do { ...; makeSureIt'sOK x; ... }
20:28:42 <haasn> shachaf: that makes sense; but you might as well -> Bool and use ‘guard’
20:28:44 <shachaf> makeSureIt'sOK :: Foo -> Either SomeErrorType ()
20:29:00 <shachaf> haasn: If you want an informative error?
20:29:13 <haasn> oh, never mind
20:29:17 <startling> > throwError "!" :: Either String ()
20:29:19 <lambdabot>   Left "!"
20:29:24 <haasn> :t throwError
20:29:25 <lambdabot> MonadError e m => e -> m a
20:29:31 <startling> scshunt: might as well use that instance.
20:30:22 <haasn> Anyways that article has a lot of useful options as well as some pros/cons of each
20:35:00 <wagle> how do you get vectors/arrays/whaever with O(1) updates?  i think Vector doesnt
20:36:29 <elliott> use a mutable array/vector.
20:36:32 <elliott> (don't)
20:36:38 <elliott> (but that's what you'd have to do)
20:36:44 <wagle> sheesh.  ask a question, then answer it yourself (impure)
20:37:24 <NemesisD> the documentation for dupTChan says that data is "seen by everyone else", but it doesn't specify that if you dup a chan twice and read in one of them, is the same message still available in the other?
20:37:53 <NemesisD> i'm assuming it is
20:37:57 <wagle> the arrays are 2^24 large, and ran for 8 hours before I gave up..  I must be copying on update
20:38:39 <wagle> other people in imperative languages are getting 40 second times..  soo...
20:39:09 <elliott> wagle: you may want to consider: Data.HashMap, Data.Sequence
20:39:23 <elliott> trees are nicer than flat arrays when you update them a lot in a pure setting.
20:39:29 <elliott> since you don't have to copy every time.
20:39:43 <elliott> you can even do things like flat array + list of updates and then merge them in every now and then, depending on what you're doing.
20:39:57 <scshunt> oh good god someone wrote checked exceptions in haskell
20:39:59 <wagle> trying to implement union find
20:40:43 <wagle> highly optimized, since its trying to test my mettle
20:41:34 <wagle> coul;d just do it in an imperative language, but i wanna do haskell for various reasons
20:42:27 <elliott> you might want to use ST so you can use mutable arrays/vectors under the hood but provide an externally pure interface.
20:42:30 <elliott> also, repa might interest you. maybe.
20:43:07 <NemesisD> turns out the answer is yes
20:43:29 <NemesisD> stm is so nice
20:43:56 <wagle> yeah, I'm allergic to using anything marked unsafe____
20:44:35 <elliott> ST isn't unsafe.
20:44:41 <elliott> the whole point is that it's safe.
20:46:17 <wagle> yeah, that's what i was trying to say (was looking at Data.Vector and its unsafe updates)
20:46:40 <haasn> those aren't unsafe in the sense of mutation, they're unsafe in the sense of skipping length checks and stuff
20:49:43 * wagle looks at repa
20:49:51 <haasn> (Doesn't STArray and stuff have the same sort of unsafeUpdate functionality?)
20:50:00 <haasn> if it does I can't find it
20:50:41 <haasn> Oh, is that what the distinction between Data.Array.ST and Data.Array.ST.Safe is about?
20:50:44 <wagle> talking about http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Impure_Arrays
20:51:23 <wagle> i might be looking in the wrong place, though
20:51:49 <haasn> wagle: yes, those are unsafe in the sense of bounds checking being skipped
20:52:08 <haasn> you can use regular (safe) ‘write’
20:52:16 <haasn> to avoid corrupting memory and crashing and stuff
20:52:35 <haasn> the ‘unsafe’ versions are there as a performance optimization for when you know your algorithm is correct
20:52:38 <wagle> its not like i proved my program bug free
20:52:54 <haasn> also, again, you can use ST instead of IO here to have your external API be pure instead of relying on IO
20:52:54 <wagle> ok
20:53:03 <haasn> If all you need is vector updates
20:54:45 <wagle> ok..  i need to learn ST anyway..  heh
20:55:27 * wagle looks for a monadic version of Vectors
20:55:35 <haasn> STArray
20:56:31 <monochrom> best of both worlds: ST and MVector
20:57:35 <haasn> ah
20:57:36 <slack1256> Maybe this is wrongly planted: How do typeclasses fit in System F?
20:57:38 <startling> ST + MVector = STM Vector ?
20:57:54 <haasn> startling: I don't think that's how it works :)
20:58:55 <startling> :3
21:02:28 <startling> It's too bad Haskell has significant whitespace.
21:03:01 <monochrom> and yet, not significant enough to indicate operator precedence
21:03:48 <levi> It's too bad some people have hang-ups about significant whitespace.
21:04:38 <monochrom> ideally, one could use fewer spaces around an operator to indicate higher precedence, more spaces to indicate lower precedence. then authors would almost never need parentheses, and readers would never need memorization.
21:05:17 <startling> I wouldn't go that far, but requiring whitespace around operators lets you do pretty cool things.
21:05:54 <dmj`> monochrom: 5+5 - 9   * 10       + 20             ==30
21:06:07 <monochrom> \∩/
21:06:11 <spaceships> how about a programming language modeled after the begriffsschrift... in two dimensions
21:06:14 <dmj`> :)
21:06:32 <monochrom> what is begriffsschrift?
21:06:57 <spaceships> frege's formal logic system, supplanted by russel and such i think
21:06:59 <startling> it's the thing that frege did that looks kinda like it has turnstiles in it
21:07:11 <shachaf> https://en.wikipedia.org/wiki/Begriffsschrift
21:07:30 <doug> destroyed by goedel
21:07:43 <shachaf> deströdel
21:08:10 <startling> doug: what do you mean?
21:08:46 <dolio> German has good names for math stuff.
21:08:56 <dolio> Like entscheidungsproblem.
21:09:40 <monochrom> thanks. begriffsschrift in two dimensions will look nice
21:10:09 <spaceships> noticing parens in begriffsschrift script
21:10:14 <ReinH> dolio: even though that was Hilbert's problem ;)
21:10:25 <spaceships> perhaps you could design it in a way to solve precedence with 2d
21:10:45 <Ghoul_> has anyone ever written anything to parse cabal files
21:10:55 <startling> Cabal
21:11:08 <Ghoul_> ick. okay.
21:11:20 <monochrom> der Tropicalsemiringen des Nibelungen :)
21:11:22 <dolio> There's some vim highlighting for cabal files.
21:11:26 <dolio> I think.
21:11:29 <ReinH> there is
21:11:34 <ReinH> it's not very sophisticated
21:11:36 <Ghoul_> I'm writing a build system in shake, and I'd like to load up the modules that should be built from a cabal file
21:11:43 <dolio> That probably doesn't qualify as parsing, even, though.
21:11:58 <wagle> i *think* i'm slow because I'm copying length 2^24 vectors all over the place..  any way to *prove* it?
21:12:09 <ReinH> wagle: don't *think*. Measure.
21:12:11 <dalaing> profiling?
21:12:16 <elliott> if you suspect you're doing that, then I consider that sufficient proof that it's happening.
21:12:26 <elliott> because any efficient program I'd write would very obviously not copy 2^24-size vectors constantly.
21:12:32 <startling> Ghoul: I'm sure parsing things are somewhere in http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/
21:12:34 <ReinH> elliott: hah
21:12:45 <wagle> ReinH: hence my use of the word "prove"
21:12:46 <arkeet> elliott: it does not follow.
21:12:54 <ReinH> wagle: profile it
21:13:04 <dalaing> is that a non-constructive proof?
21:13:07 <arkeet> elliott: if you wrote an inefficient program, that doesn't necessarily mean you weren't copying 2^24-size vectors constantly.
21:13:12 <Ghoul_> It's Distribution.PackageDescription.Parse incase anyone was wondering.
21:13:39 <arkeet> or something.
21:13:48 <elliott> arkeet: "any program I'd write for efficiency", then.
21:13:48 <wagle> i guess i was asking for the "best" profiling package
21:13:56 <elliott> the one GHC has.
21:14:10 <ReinH> GHC has great profiling tools
21:14:14 <startling> monochrom: der Nibelungenliegruppe
21:14:26 <wagle> hahaha..  i dont trust google after it sent me to Data.Vector
21:14:31 <monochrom> yikes
21:14:41 <ReinH> wagle: Data.Vector is one of the most high performance libraries in the haskell universe
21:14:46 <ReinH> but even it can't prevent developers from doing dumb things
21:15:43 <wagle> sure..  I'm wanting to do gobs of updates, and I'm accusing it of making copies when I update, hence my wanting to *prove* it
21:16:07 <gaze__> hey folks, say I'm writing a 2d graphics library that wants to pass around an HDC in the case of windows, and some other thing in the case of a mac, and then provide a smattering of functions that each must implement.(drawline, etc.)
21:16:09 <ReinH> wagle: vector is not designed for extremely performant inserts unless you use modify
21:16:27 <gaze__> what's the best thing to stick the HDC in?
21:16:43 <gaze__> ideally I'd like to have some graphics monad that we work inside
21:16:58 <ReinH> or maybe a graphics monoid
21:17:36 <gaze__> a monad would map better onto windows' API as the operations don't commute
21:17:48 <startling> Monoid doesn't require commutativity
21:17:51 <ReinH> monoids don't necessarily commute
21:18:41 <gaze__> ooh whoops
21:18:46 <gaze__> well okay, graphics monoid then.
21:19:02 <gaze__> what's the best thing to stuff the HDC in?
21:19:02 <haasn> Is there a class for Monads which are commutative? ie (x *> y) = (y <* x)
21:20:40 <startling> is that useful?
21:20:47 <gaze__> I was thinking perhaps having a Graphics type class and making it existential on something that wraps the device context or something
21:20:48 <haasn> Maybe
21:20:55 <startling> :)
21:21:04 <gaze__> but then I guess existential types are frowned upon for reasons I don't understand completely
21:21:08 <copumpkin> startling: it's the natural thing to fold over a Set datastructure
21:21:38 <gaze__> are there any libraries that implement the pattern I'm attempting to do?
21:21:58 <dalaing> haasn: I think there was a discussion about commutative monads in the last month or two - could have been on haskell-cafe, could have been somewhere else
21:23:21 <dalaing> ah, it was on reddit
21:24:15 <dalaing> http://www.reddit.com/r/haskell/comments/1jegxb/the_commutative_monad/ , probably not what you were after though
21:24:41 <arkeet> a commutative monad is nothing but a monoid in the category of monoids in a category of endofunctors.
21:24:42 <arkeet> I think.
21:26:15 <ReinH> arkeet: profunctors, probably
21:26:19 <ReinH> I may have made that up
21:28:22 <shachaf> arkeet: Really? How does that work?
21:28:44 <shachaf> Is that the category of monads with composition as the monoidal product?
21:29:10 <arkeet> I dunno.
21:29:14 <arkeet> I'm just guessing, because
21:29:23 <arkeet> monoids in the category of monoids are commutative monoids.
21:29:27 <wagle> elliott: you saying I should use MVector in the ST monad?
21:29:48 <gaze__> anyone have any ideas as far as what the appropriate way to do what I'm trying to do is?
21:30:11 <wagle> i appear to need a monad to operate MVector in
21:30:29 <shachaf> arkeet: What's the monoidal operation there?
21:30:33 <elliott> wagle: sure, if you want. I'd never leap to the mutable solution first, personally.
21:30:40 <arkeet> shachaf: anything.
21:30:44 <arkeet> it happens to be identical to the other one.
21:30:51 <dolio> arkeet: That's Eckmann-Hilton, right?
21:31:05 <arkeet> yeah
21:31:17 <Ghoul_> Hmmm. I get a "Parse error in pattern" even though I don't think I make one
21:31:51 <Ghoul_> https://gist.github.com/kvanberendonck/6680383
21:32:17 <wagle> elliott: I already did it with Data.Vector, and it ran for 8 hours before I gave up..  people in imperativee languages are reporting 40 second to 40 minute times
21:32:52 <elliott> wagle: like I said, try HashMap or some other non-vector structure.
21:32:58 <elliott> it depends.
21:33:19 <monochrom> perhaps you have an infinite loop by mistake?
21:33:24 <wagle> elliott: ok, thanks
21:34:14 <wagle> monochrom: occured to me, but it works on smaller data, and its a learning experiencee
21:34:39 <monochrom> anyway, the monad you need for MVector is ST. or rather (ST s)
21:35:55 <wagle> monochrom: for what s?  or does that question make sense?
21:36:33 <monochrom> short answer: don't ask. long answer: the s in "runST :: (forall s. ST s a) -> a"
21:37:10 <wagle> ah, ok..  thanks
21:37:44 <wagle> its an existential type, i think
21:38:14 <dalaing> Section 2 of http://www.haskell.org/haskellwiki/Monad/ST helped me get what was going on
21:38:42 * hackagebot jmacro-rpc-happstack 0.2.1 - Happstack backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-happstack-0.2.1 (GershomBazerman)
21:39:18 <ReinH> wagle: what does your algorithm actually do?
21:39:53 <wagle> union find for a 2^24 vector
21:40:34 <wagle> doing a clustering algorithm
21:41:09 <wagle> the assignment is trying to make you do an efficient union find
21:41:26 <wagle> ReinH: ^^^
21:42:08 <wagle> I need to grok arrays/vectors and mutation in haskell anyway
21:45:16 <Ghoul_> wagle: you can kick their asses by using pointer magic, if you feel up to it
21:45:22 <Ghoul_> they'll all drop in awe ;)
21:45:48 <wagle> sounds aweful
21:46:07 <wagle> (i'm trying to avoid unsafe____)
21:46:22 <Ghoul_> have you checked if its something you can do with REPA?
21:46:39 <Ghoul_> (sorry I don't really understand what the algorithm might entail)
21:46:41 <wagle> just heard about repa..  it looked interesting
21:47:56 <wagle> i might try it both ways to see what happens
21:48:52 <wagle> now that i blew the assignment deadline with the 8 hour run time, I can do what I want until the hard deadline
21:50:36 <Ghoul_> also, did you make sure to pass flags
21:50:40 <Ghoul_> -O2 and such?
21:51:02 <wagle> no, i didnt..  thats a good point
21:51:19 <Ghoul_> ghc -O2 -threaded ...
21:51:39 <Ghoul_> oh, and if you have llvm, try `ghc -O2 -fllvm -threaded ...`
21:52:03 <Ghoul_> llvm improves some of my programs by 20-30% :)
21:54:59 <leroux> wagle: Where's this assignment from? Sounds interesting.
21:55:36 <wagle> Ghoul_: its a mac..  no llvm found?  huh
21:56:02 <wagle> leroux: the coursera MOOC algorithms design and analysis 2 course
21:56:06 <Ghoul_> Uh, not sure about macs
21:56:21 <Ghoul_> theres a way they usually get llvm but I don't know how that is... could be port/brew
21:56:25 <leroux> wagle: You can install llvm with brew/
21:56:28 <wagle> llvm is produced by apple..  but oh well
21:56:43 <Ghoul_> llvm is actually open source, but they do ship clang/llvm with xcode (I thought...)
21:56:59 <wagle> what I thought too
21:57:39 <wagle> maybe -O2 will optimize Vector updates to mutations..  huh..  prolly not
21:58:45 <wagle> i'm using all four processors, anyway
22:02:34 * wagle tries out profiling
22:05:15 <Ghoul_> wagle: without any -O, you're really *asking* for terrible performance, because I dont think you even get strictness
22:05:55 <Ghoul_> -O2 will strictify and unwrap/unbox things
22:06:45 <wagle> I have some explicit strictness annotations..  must be working partially, because before I was running out of stack on my foldl's
22:06:57 <raphie> hey guys, I just started learning Haskell and I think I had a Haskell epiphany, kinda like the one I had with Lisp's homeiconicicity. in every other language I've used, types are an afterthought, something to basically check your work. here, it feels like your data definitions *are* your work. it's beautiful. sorry, I know this is off topic, but it kinda blew my mind
22:09:26 <elliott> raphie: if you think that's off-topic you should see the off-topics this place ventures to sometimes. :p
22:09:36 <elliott> type-first thinking is really great. it makes things so much more easier.
22:10:45 <shachaf> elliott: I like think-first, type-second thinking, but eh.
22:10:46 <edwardk> parcs++ # -j
22:10:55 <shachaf> parcs++
22:11:00 <raphie> I think it was the book I'm reading showing me how to define List and Tree types
22:11:00 <shachaf> One of these days I'll try it.
22:11:22 <raphie> and I realized, wow, I'm done!
22:12:14 <edwardk> raphie: =)
22:12:48 <edwardk> raphie: i was talking with daan leijen the other day, for him the epiphany was that writing [1,2,3] was enough to make the list, malloc each node, stick the values in...
22:13:16 <edwardk> raphie: for me it was how easy generic programming becomes compared to, say,  c++ templates
22:13:19 <raphie> edwardk: ahh, I'm used to that with scheme's (list 1 2 3)
22:14:08 <raphie> but the type system is just so... elegant
22:14:23 <raphie> in every other typed language, it feels like a chore, like something I shouldn't need to do
22:14:40 <gaze__> edwardk: I'm actually really confused about how to do generic programming properly
22:14:46 <edwardk> raphie: what really impresses me about the type system is how well it holds up to me _really_ beating on it, and contorting it in impossible ways
22:14:58 <startling> :>
22:15:45 <gaze__> I've so far seen 4 or 5 different ways to make a platform agnostic graphics API
22:15:46 <edwardk> > ("this","is",["generic","enough"],4 :: Int, ('m','e'))) & biplate %~ toUpper
22:15:47 <lambdabot>   <hint>:1:55: parse error on input `)'
22:15:53 <edwardk> > ("this","is",["generic","enough"],4 :: Int, ('m','e')) & biplate %~ toUpper
22:15:54 <lambdabot>   ("THIS","IS",["GENERIC","ENOUGH"],4,('M','E'))
22:16:17 <gaze__> oh that sort of generics
22:16:37 <edwardk> gaze__: oh sorry, misread your comment as a new statement, not in the context of my previous one.
22:16:42 <edwardk> i actually just meant things like
22:16:46 <edwardk> :t (:)
22:16:46 <startling> haha what
22:16:47 <lambdabot> a -> [a] -> [a]
22:16:58 <startling> :t biplate
22:17:13 <startling> :t Control.Lens.biplate
22:17:13 <edwardk> :t Data.Data.Lens.biplate
22:17:14 <lambdabot>     Not in scope: `Control.Lens.biplate'
22:17:14 <lambdabot>     Perhaps you meant one of these:
22:17:14 <lambdabot>       `Control.Lens.plate' (imported from Control.Lens),
22:17:14 <lambdabot> (Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
22:17:23 <startling> oh, it's a Data thingy
22:17:24 <raphie> edwardk: probably my favorite feature over lisp is the auto-currying
22:17:27 <raphie> that's amazing
22:17:36 <startling> there's nothing automatic about it. :)
22:17:44 <raphie> er, "baked-in"
22:17:55 <edwardk> raphie: in general most list combinators are really a fold of some kind of binary operator over their args, yu just never get to know if its folding left to right or right to left
22:18:09 <raphie> in scheme, racket specifically, you have to write (curry fn arg)
22:18:18 <raphie> which doesn't feel magical like it does here
22:19:03 <edwardk> raphie: yeah. http://comonad.com/reader/2009/curried-scheme/ was my attempt at making a decent currying macro
22:19:29 <gaze__> would anyone be willing to chat about designing a proper platform agnostic graphics API? So far I've seen that graphs uses some sort of EDSL... I have half a mind to hide the platform specific backend pointer in an existentially quantified type, is that considered an okay thing to do?
22:19:59 <gaze__> I've seen a quite a few posts about the evils about existential quantification
22:20:08 <gaze__> is this an appropriate use?
22:20:54 <edwardk> graphs as in my graphs package?
22:21:06 <raphie> edwardk: any idea how this works under the hood, like in the assembly? if I have myFn a b c d = ..., is it really doing four different subroutine jumps?
22:21:44 <edwardk> raphie: you should read http://research.microsoft.com/apps/pubs/default.aspx?id=67488 to understand the implementation. the short answer is that all the args get passed at one time
22:22:07 <gaze__> oops sorry, I mean charts!
22:22:27 <edwardk> if you under-apply that calls a different function that makes a closure and that wants the rest of the args
22:23:07 <wagle> total alloc = 32,922,540,064 bytes (in 44 seconds)...  I think I'm copying out the wazoo
22:23:14 <edwardk> gaze__: if you know the api existentially, why not take that and just make the 'backend' be a record of its methods
22:23:26 <edwardk> gaze__: rather than make a type, just make an object.
22:23:56 <ReinH> edwardk: hai
22:23:56 <gaze__> so generate a display list and have some backend churn through it?
22:23:57 <edwardk> gaze__: the nice thing about a functional language is we have functions ;)
22:24:01 <startling> def apply(f, a): f.add_parameter(a); if f.ready_to_call: return f.call(); else: return f;
22:24:32 <ReinH> edwardk: did you see my tweet about fmap and lift?
22:25:25 <gaze__> I like that certainly, but what about things where the graphics API chats back?
22:25:25 <edwardk> gaze__: i mean this. instead of having some kind of class Backend f where newFoo :: a -> f; bar = … ; …    and have something else existentially know 'f', just make a data Backend f = Backend { newFoo :: forall a. a -> f, … } -- and put that in as the member where you'd throw the existential
22:25:59 <edwardk> ReinH: nope
22:26:10 <edwardk> ReinH: haskell workshop
22:26:17 <ReinH> edwardk: yay haskell workshop :)
22:26:30 <ReinH> edwardk: so the fmap laws and the lift laws from MonadTrans look awfully similr
22:26:39 <ReinH> I was asking if there's a homomorphism there
22:26:59 <ReinH> there application is sent to composition and composition is sent to kleisli composition
22:26:59 <edwardk> ReinH: lift is family of monad homomorphisms
22:27:02 <ReinH> *where
22:27:20 <ReinH> so fmap id = id and lift . return = return
22:28:04 <edwardk> a monad transformer forms a module over all monads, with a monad homomorphism from the base monad.
22:28:15 <ReinH> hmm
22:28:19 <ReinH> so this is not a coincidence
22:28:23 <edwardk> lift . return = return is one of the monad homomorphism conditions
22:28:29 <raphie> is there a way to get haskell to automatically make maps parallel?
22:28:30 <luite> oh hm i missed edwardk's talk
22:28:38 <ReinH> fmap (f . g) = fmap f . fmap g compared to lift . (f <=< g) = (lift . f) <=< (lift . g)
22:28:48 <edwardk> luite: i'm pretty sure i'll be around ;)
22:29:02 <edwardk> ReinH: yep
22:29:23 <ReinH> so how would you express the relationship between fmap and lift?
22:30:19 <haasn> How long has the concept of a mathematical ‘function’ been known for? Since the dawn of writing?
22:30:39 <haasn> eg. f x = 2*x
22:30:41 <edwardk> haasn: i showed your pong and brainfuck examples to SPJ today =P
22:30:53 <haasn> edwardk: oh no :(
22:30:57 <ReinH> ah
22:30:59 <ReinH> *hah
22:31:16 <haasn> edwardk: I feel they're dirty for being so.. imperative
22:31:19 <gaze__> edwardk: still a bit confused. Do you have any examples of this being used in a larger codebase?
22:31:26 <haasn> edwardk: you should have shown him my lensy fizzbuzz examples instead!
22:31:53 <ReinH> edwardk: btw I used lenses for getopts parsing the other day. It went pretty well. https://gist.github.com/reinh/eabe0310fc93668004c0
22:32:05 <edwardk> gaze__: replacing existentials with just passing what the arg is? we pass records with fields that are functions in them all over
22:32:07 <ReinH> actually that's the wrong evrsion
22:33:40 <startling> haasn: not sure. I bet you'll need to wait until set theory at least to see a real definition though
22:34:00 <startling> (that is, functions are single-valued and well-defined)
22:34:08 <haasn> startling: perhaps for a more principled question. How long has the english term ‘function’ been in use (to describe this sort of thing)?
22:34:11 <ReinH> edwardk: https://gist.github.com/reinh/7880188e1b251bb51e6e
22:34:31 <gaze__> is passing a huge record with your entire API in it the standard way to do this sort of thing?
22:34:43 <gaze__> I guess it's no different from a big vtable
22:34:51 <edwardk> thats pretty nice
22:35:02 <startling> haasn: http://comonad.com/reader/2009/curried-scheme/
22:35:07 <startling> ugh, sorry, mispaste
22:35:13 <edwardk> gaze__: exactly, then the trick is finding a nice simple core you can reason about
22:35:15 <startling> haasn: http://www.etymonline.com/index.php?term=function&allowed_in_frame=0
22:35:25 <haasn> ReinH: cute
22:35:49 <ReinH> haasn: :D
22:35:51 <edwardk> as usual everything goes back to Leibniz
22:35:53 <haasn> startling: thanks!
22:37:00 <ReinH> haasn: I particularly like the foldl (>>=) but I didn't come up with it
22:37:02 <startling> it strikes me that the chain rule barely makes sense except as a rule for differentiating composite functions
22:37:31 <startling> (and yeah, apparently Leibniz first used it)
22:38:03 <haasn> ReinH: I would have used foldr (>=>) return actions mempty
22:38:07 <haasn> at least if my types are correct
22:38:41 <ReinH> haasn: hmm
22:38:49 <haasn> :t foldr (>=>) return ?? mempty
22:38:50 <lambdabot> (Monad m, Monoid c) => [c -> m c] -> m c
22:38:53 <haasn> :t foldl (>>=) (return mempty)
22:38:54 <lambdabot> (Monad m, Monoid a) => [a -> m a] -> m a
22:39:04 <startling> :t (??)
22:39:05 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:39:07 <ReinH> ah ha
22:39:19 <ReinH> I still can't figure out when ?? will work
22:39:33 <haasn> I just use it as xs ?? ys = \x -> xs x ys
22:39:40 <haasn> ... and as <&> ($x)
22:39:45 <ReinH> right
22:39:51 <ReinH> makes sense
22:39:55 <haasn> but I never mix more than a single (??) into the expression
22:39:57 <haasn> ...except sometimes
22:40:01 <ReinH> haasn: hahah
22:40:28 <startling> that's an interesting function
22:40:43 <startling> very clearly illustrates what Applicative gives you.
22:41:37 <haasn> which one and what does Applicative have to do with it?
22:41:52 <startling> :t (<*>)
22:41:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:41:56 <startling> :t (??)
22:41:56 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:43:55 <startling> > (,,) <$> Just 1 <*> Just 2 ?? 3
22:43:57 <lambdabot>   Just (1,2,3)
22:44:50 <haasn> aha !
22:45:01 <wagle> > fix Nothing
22:45:02 <lambdabot>   Couldn't match expected type `a0 -> a0'
22:45:03 <lambdabot>              with actual type `Data...
22:45:08 <haasn> you mean as in x ?? y = x <*> pure y
22:45:11 <wagle> 8(
22:45:23 <startling> :t fix -- wagle
22:45:24 <lambdabot> (a -> a) -> a
22:45:30 <startling> haasn: exactly
22:45:33 <haasn> that's a great formulation of the right-hand ‘pure’ law :)
22:45:39 <haasn> along with x <$> y = pure x <*> y
22:45:42 <wagle> yeah, I know
22:45:48 <startling> useful for applicative style, too
22:45:55 <haasn> cool! I learned something
22:45:58 <startling> me too!
22:46:01 <wagle> fixing Just would have been more boring
22:46:05 <ReinH> > [succ, pred] ?? 1
22:46:06 <lambdabot>   [2,0]
22:46:11 <ReinH> I didn't even think of that but it's obvious from the types
22:48:08 <startling> right, it's like fmap ($ 1)
22:49:00 <startling> :t flip (fmap . flip id)
22:49:01 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:50:22 <startling> where's that from? lens?
22:50:41 <edwardk> startling: which?
22:50:46 <shachaf> Yes, (??) is from lens.
22:50:54 <startling> yeah, (??).
22:51:01 <zRecursive> :t (??)
22:51:02 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:51:19 <zRecursive> weird
22:51:21 <ReinH> edwardk: so to be clear, if lift is a monad homomorphism from the base monad w/ fmap, does that make it a functor functor?
22:51:23 <haasn> import Control.Lens as Prelude
22:51:53 <edwardk> zRecursive: it is usually used to swap args around 'foo bar ?? baz'   gives you (\x -> foo bar x baz)
22:52:10 <wagle> > Nothing ?? 1
22:52:11 <startling> edwardk: oh, that's clever
22:52:11 <lambdabot>   Nothing
22:52:27 <startling> :t (,) ?? 1
22:52:28 <lambdabot> Num b => a -> (a, b)
22:53:00 <startling> :t (,) <$> ask ?? 1
22:53:00 <lambdabot> (Functor f, Num a, MonadReader a1 f) => f (a1, a)
22:53:04 <wagle> > (succ, pred) ?? 1
22:53:05 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
22:53:06 <lambdabot>    arising from a use ...
22:53:15 <zRecursive> edwardk: why can `f (a -> b)` manipulate a not `f a` ?
22:53:16 <wagle> shrug
22:53:22 <edwardk> startling: people kept asking me for more combinators that wre just flipped versions of things, so i concocted that, based on ski's generalized flip
22:53:34 <startling> wagle: that's from a stupid Show instance for functions
22:53:36 <edwardk> zRecursive: f = (->) e
22:53:42 <haasn> wagle's error had me confused for a moment before I remembered instance (Typeable a, Typeable b) => Show (a -> b)
22:53:43 <startling> :t (succ, pred) ?? 1
22:53:44 <lambdabot> (Enum a, Enum b, Num b) => (a -> a, b)
22:53:44 <haasn> yeah..
22:53:49 <edwardk> :t (??)
22:53:50 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:53:58 <ReinH> > [succ, pred] ?? 1 -- this?
22:54:00 <lambdabot>   [2,0]
22:54:02 <zRecursive> :t (<*>)
22:54:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:54:05 <edwardk> whn f = (->) e that is (e -> a -> b) -> a -> e -> b
22:54:13 <startling> > (1, pred) ?? 2
22:54:15 <lambdabot>   (1,1)
22:54:23 <wagle> actually (,) has two embedded types
22:54:26 <haasn> is it bad that I misread edwardk's line as ‘whnf’?
22:54:35 <startling> wagle: doesn't matter. (,) a is a functor
22:54:44 <wagle> hmm
22:55:12 <startling> haasn: haha, me too. you must have seen https://github.com/ekmett/bound/blob/master/examples/Simple.hs#L78
22:55:22 <wagle> type of ?? is less general than for that, i think, but I'm no expert
22:55:35 <startling> > fmap (+ 1) ("wagle", 0)
22:55:36 <lambdabot>   ("wagle",1)
22:55:41 <haasn> startling: No but I was playing around with criterion earlier :)
22:56:00 <haasn> startling: http://hackage.haskell.org/packages/archive/criterion/0.8.0.0/doc/html/Criterion-Main.html#v:whnf
22:56:04 <wagle> :t (,)
22:56:04 <lambdabot> a -> b -> (a, b)
22:56:23 <wagle> :t (??)
22:56:24 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:56:27 <startling> haasn: that's not even edwardk code!
22:56:31 <edwardk> wagl: fmap wants to chang the value of 'the last type argument'
22:56:55 <wagle> edwardk: ah ok
22:57:11 <startling> wagle: with the "Functor (,) n", that reads as "(,) n (a -> b) -> a -> (,) n b"
22:57:42 <startling> sorry, "Functor ((,) n)"
22:58:42 * wagle blinks a couple times
22:59:06 <startling> wagle, well, consider type Second a = (String, a)
22:59:16 <startling> obviously Second can be a Functor, right?
22:59:26 <ReinH> wagle: fmap for the 2-tuple functor applies the function to the second element
22:59:32 <wagle> no, I meant I was starting to "get it"
22:59:38 <ReinH> ah
22:59:42 <ReinH> the blink of understanding
22:59:44 <zRecursive> The world is much clean without Control.Lens :)
22:59:47 <ReinH> we see that so rarely
23:00:02 <startling> ReinH: haha, indeed
23:01:06 <wagle> > fmap (+1, (1,2))
23:01:07 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)
23:01:17 <wagle> > fmap ((+1), (1,2))
23:01:19 <lambdabot>   Couldn't match expected type `a0 -> b0'
23:01:19 <lambdabot>              with actual type `(a1 ...
23:01:44 <zRecursive> "Functor <--- Applicative <--- Monad" is basically enough for a beginner ?
23:02:21 <ReinH> wagle: fmap takes two arguments
23:02:54 <ReinH> > (uncurry fmap) ((+1), (1,2))
23:02:56 <wagle> > fmap (+1) (1,2)
23:02:56 <lambdabot>   (1,3)
23:02:57 <lambdabot>   (1,3)
23:03:06 <startling> zRecursive: (,) n doesn't even have a Traversable instance without lens. I wouldn't call that "clean". :(
23:03:39 <wagle> I was trying it in ghci to see what the entire error message was
23:03:40 <zRecursive> :t (,) n
23:03:41 <lambdabot> b -> (Expr, b)
23:03:58 <startling> I mean the type, not the value.
23:04:02 <edwardk> zRecursive: the type
23:04:28 <shachaf> startling: Sure it does.
23:04:36 <zRecursive> ":t" returns type,right ?
23:04:36 <startling> wagle: there are a couple other classes like Functor that work on "all the values of the last type parameter"
23:04:38 <ParahSail1n> somewhat interesting http://www.urbit.org/2013/08/22/Chapter-0-intro.html
23:05:09 <startling> > foldMap id (1, [1, 2, 3])
23:05:10 <lambdabot>   [1,2,3]
23:05:19 <wagle> yeah, i started blinking when (,) showed up as a functor
23:05:26 <startling> shachaf: does it now?
23:05:31 <shachaf> In HEAD.
23:05:58 <startling> > traverse (Just . (+ 1)) (1, 2)
23:05:59 <lambdabot>   Just (1,3)
23:06:20 <startling> wagle: generalizing these notions turns out to be really useful.
23:06:47 <pavonia> :t traverse
23:06:53 <wagle> yeah, i wasnt expecting (,) to me assymetrical
23:07:02 <wagle> s/me/be/
23:07:15 <pavonia> @ty traverse
23:07:20 <startling> wagle: it is a little strange at first.
23:07:38 <startling> pavonia: traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:07:43 <ReinH> :t (,)
23:07:44 <lambdabot> a -> b -> (a, b)
23:07:51 <mstksg> wagle: one useful case is if you look at them as ordered pairs on a graph/function
23:07:51 <pavonia> thanks startling
23:08:00 <startling> zRecursive: :t shows the type of a value
23:08:13 <zRecursive> sure
23:08:14 <mstksg> or as key/value pairs
23:08:19 <edwardk> > over both (+1) (1,2)
23:08:20 <startling> we're talking about the type (,); when you say :t (,) you're asking about the value (,)
23:08:20 <lambdabot>   (2,3)
23:08:21 <wagle> sure, total order..  i like partial orders..
23:08:53 <startling> wagle: the best way to think about it is as the only way the Functor instance works
23:09:02 <zRecursive> startling: odd
23:09:17 <wagle> monads introduce total orders or something..  it bugs me
23:09:23 <ReinH> wagle: fmap can only take an a to b, it can't deal with both types in (a,b)
23:09:31 <wagle> right
23:09:38 <startling> wagle: you could write newtype Flip a b = Flip (b, a) and then instance Functor (Flip a) ...
23:09:49 <ReinH> if you had an (a,a) you could write fmap f (a,a) = (f a, f a)
23:10:02 <wagle> fmap*
23:10:20 <ReinH> but since you can't assume that about arbitrary 2-tuples, you have to pick one
23:10:22 <wagle> i wonder how that'd work
23:10:34 <startling> wagle: something like newtype Both a = Both (a, a)
23:11:01 <wagle> fmap2 (+1) (1,2) == (2,3)
23:11:20 <startling> > over both (+ 1) (1, 2)
23:11:22 <lambdabot>   (2,3)
23:11:22 <ReinH> :t both
23:11:23 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:11:24 <startling> ;)
23:11:38 <wagle> fmap_blah (+) (1,2) = 3
23:11:39 <zRecursive> > map (+1) [1,2]
23:11:40 <lambdabot>   [2,3]
23:11:47 <ReinH> :t over both
23:11:48 <lambdabot> (a -> b) -> (a, a) -> (b, b)
23:11:58 <wagle> i understand the types
23:12:36 * wagle thinks
23:12:39 <shachaf> Pft, that type isn't lensy.
23:12:43 <shachaf>   :: forall (f :: * -> *) a i i1 (p :: * -> * -> *).
23:12:43 <shachaf>      (Applicative f, Indexable i p, Indexable i1 p) =>
23:12:43 <shachaf>      p Int (f a) -> (i, i1) -> f (a, a)
23:12:46 <shachaf> That's more like it.
23:13:21 <edwardk> =)
23:13:44 <shachaf> I think the greatest theoretical contribution of lens is the discovery of Conjoined Profunctors.
23:13:49 <startling> wagle: the thing about types like "Applicative f => (a -> f b) -> s -> f t" is that you can make mapping-ish functions out of them. Do you see how?
23:14:00 <shachaf> class (Choice p, Data.Profunctor.Rep.Corepresentable p, Comonad (Data.Profunctor.Rep.Corep p), Traversable (Data.Profunctor.Rep.Corep p), Strong p, Data.Profunctor.Rep.Representable p, Monad (Data.Profunctor.Rep.Rep p), MonadFix (Data.Profunctor.Rep.Rep p), Distributive (Data.Profunctor.Rep.Rep p), A.ArrowLoop p, A.ArrowApply p, A.ArrowChoice p) => Conjoined p where
23:14:34 <edwardk> i should fix that
23:14:42 <ReinH> holy. shit.
23:14:44 <edwardk> i mean, i think i missed a few superclasses
23:14:47 <wagle> startling: havent gotten around to sitting down and grokking applicatives..  get close frequently though
23:15:17 <elliott> I should go rogue and remove Conjoined.
23:15:47 <startling> wagle, well, "Monad m => (a -> m b) -> s -> m t" is just as good in this case.
23:16:31 <wagle> where are s and t coming from?
23:16:49 <startling> just any specific s and t
23:16:54 <startling> :t both -- this is one example
23:16:55 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:17:14 <wagle> oh..  that makes more sense
23:17:23 <haasn> :t bytes
23:17:29 <startling> the thing about functions like those is that you can turn them into (a -> b) -> s -> t functions.
23:17:52 <haasn> :t Data.ByteString.Strict.bytes
23:17:53 <lambdabot> Couldn't find qualified module.
23:17:56 <wagle> s == n a
23:17:57 <startling> you can also do more
23:17:58 <haasn> :t Data.ByteString.Strict.Lens.bytes
23:18:02 <haasn> :(
23:18:09 <lambdabot> (Applicative f, Indexable Int p) => p Word8 (f Word8) -> BSC.ByteString -> f BSC.ByteString
23:18:13 <haasn> :)
23:18:21 <shachaf> bytes++ chars--
23:19:31 <ion> @karma bytes
23:19:32 <lambdabot> bytes has a karma of 1
23:19:36 <ion> @karma chars
23:19:36 <lambdabot> chars has a karma of -1
23:19:49 <pavonia> @karma lens
23:19:49 <lambdabot> lens has a karma of 4
23:19:50 <haasn> It's surprisingly hard to come up with an example of a lenslike where p/q are both fixed at (->) and the s/t/a/b are monomorphic
23:20:43 <shachaf> You mean one actually exported by lens?
23:20:48 <haasn> yes
23:20:59 <haasn> or, rather, one lambdabot has imported
23:21:02 <edwardk> do we actually have any?
23:21:10 <thirsteh> why is ArithException not in scope when I import Control.Exception_
23:21:26 <haasn> I was about to say “isn't it _ArithException” :(
23:21:51 <startling> :t traverse `asAppliedTo` (pure . (head `asAppliedTo` "haasn"))
23:21:51 <lambdabot> (Applicative f, Traversable t) => ([Char] -> f Char) -> t [Char] -> f (t Char)
23:22:21 <thirsteh> haasn: hmm, maybe it was changed recently? Latest docs deceive me: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
23:22:26 <thirsteh> looks fine and exported in source too
23:22:51 <haasn> thirsteh: no no the _ArithException I was talking about is from a different library altogether :)
23:23:03 <haasn> One that I have an unhealthy fondness for
23:23:18 <startling> > has _ArithException
23:23:20 <lambdabot>   No instance for (Control.Exception.Lens.AsArithException
23:23:20 <lambdabot>                   ...
23:23:44 <thirsteh> I can't import any of the exceptions from Control.Exception except SomeException. I don't get it.
23:23:48 <startling> :t _ArithException
23:24:06 <thirsteh> I'm glad I've gotten this far without needing specific exceptions, but alas
23:24:07 <edwardk> :t Control.Exception.Lens._ArithException
23:24:08 <lambdabot> AsArithException p f t => Overloaded' p f t ArithException
23:24:33 <edwardk> :t _ArithException # DivideByZero
23:24:34 <lambdabot> AsArithException Control.Lens.Internal.Review.Reviewed Identity t => t
23:24:44 <edwardk> > _ArithException # DivideByZero :: SomeException
23:24:46 <lambdabot>   divide by zero
23:25:08 <edwardk> > SomeException DivideByZero ^? _ArithException
23:25:09 <lambdabot>   Just divide by zero
23:25:34 <edwardk> > SomeException StackOverflow ^? _ArithException
23:25:36 <lambdabot>   Nothing
23:25:46 <startling> "Just divide by zero" -- it's that easy!
23:25:48 <edwardk> > SomeException DivideByZero ^? _DivideByZero
23:25:50 <lambdabot>   Just ()
23:26:06 <NemesisD> is there a more concise way to do: do x <- action; frobulate x; x
23:26:12 <edwardk> DivideByZero is a constructorof ArithException
23:26:19 <NemesisD> bracket maybe? thought there was something in applicative that may do this
23:26:21 <edwardk> x or return x at the end?
23:26:29 <NemesisD> return x
23:26:48 <thirsteh> What am I missing? Exactly the same here: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/src/GHC-Exception.html#ArithException ArithException is exported
23:26:58 <smile`> Haskell prime report will be contantly updated?
23:26:58 <edwardk> i usually use      x <$ frobulate x   for the last line which helps a bit
23:27:05 <haasn> > is _DivideByZero $ SomeException DivideByZero -- i want “import Control.Lens.Extras” :'(
23:27:07 <lambdabot>   Not in scope: `is'
23:27:07 <lambdabot>  Perhaps you meant one of these:
23:27:07 <lambdabot>    `id' (imported from ...
23:27:22 <edwardk> haasn: hah
23:27:22 <shachaf> haasn: Just use ain't and ai.
23:27:27 <haasn> :t ai
23:27:27 <lambdabot>     Not in scope: `ai'
23:27:27 <lambdabot>     Perhaps you meant one of these:
23:27:27 <lambdabot>       `pi' (imported from Prelude),
23:28:08 <smile`> Can anybody explain Haskell Prime to me?
23:28:29 <startling> NemesisD: (\x -> x <$ frobulate x) `liftM` action, I guess
23:29:27 <startling> smile`: Haskell 98 was a standard for Haskell from 1998. Haskell Prime is the continuosly-evolving next iteration.
23:29:35 <NemesisD> ehh i guess ill do it the hard waay
23:30:31 <smile`> startling: Like C++03 to C++11 ?
23:30:33 <haasn> (<*=) :: Monad m => m a -> (a -> m b) -> m aSource
23:30:43 <haasn> from ‘SimpleH’, but might as well be cannibalized as your own definition
23:30:53 <haasn> ignore the ‘Source’ bit, paste error
23:31:09 <smile`> What is bieng improved upon in the standard? Libraries? Sementics? Syntax?
23:31:17 <haasn> it has a cute implementation, too:
23:31:29 <startling> smile`: sort of. "Haskell Prime" is a little like saying "the next Haskell standard". Haskell 2010 was formerly Haskell Prime, until it was released.
23:31:41 <haasn> :t \x f -> x >>= liftA2 (>>) f return -- NemesisD
23:31:42 <lambdabot> Monad m => m a -> (a -> m a1) -> m a
23:31:56 <wagle> :t frobulate
23:31:57 <lambdabot> Not in scope: `frobulate'
23:32:01 <wagle> aww
23:32:36 <startling> smile`: and yes, things like syntax, semantics, and the base library are what changes. Here's what Haskell 2010 changed: http://www.haskell.org/haskellwiki/Haskell_2010
23:34:05 <smile`> I hate standardisations, after R5RS to R6RS was implemented. I hope the constant standardisations in haskell only improve upon the language, and haskell remains haskell... :(
23:34:50 <elliott> heehee, "constant"
23:34:53 <wagle> wasnt R5RS the one that abolished eval?  or was that R4RS?
23:35:36 <wagle> oops, a little offtopic
23:35:49 <shachaf> I'm waiting for the one that abolishes evil.
23:36:12 <Taneb> shachaf, that's called the Haskell report ;)
23:36:50 <startling> if you abolish evil in Haskell, only the non-Haskellers will have evil!
23:37:33 <smile`> Ok, Haskell reports do not change the language, but improves upon existing technologies in the language. Am I right?
23:37:34 <wagle> sorry, I lost interest in scheme when someone asked about eval and some high mucky much answered in total "eval? there's no eval in scheme?"
23:37:54 <wagle> mucky muck
23:37:58 <shachaf> Haskell 98 sure "improved" on the "technologies" in Haskell 1.4
23:38:15 <startling> smile`: typically the standardizations standardize extensions that GHC already implements.
23:38:50 <wagle> whereas there are a billion versions of scheme out there
23:39:21 <smile`> startling: But Haskell remains Haskell, like C++ remains to be ugly C++. Right?
23:40:06 <startling> sure.
23:40:16 <smile`> :)
23:40:19 <shachaf> Please, no language bashing in this channel.
23:42:15 <smile`> shachaf: I am not bashing C++. It is advantageous that its ugly, like our sewage infrastructure is trivial and required to be ugly. Withought our sewage infrastructure, we are lost.... C++ is the neccessary evil.
23:43:17 <wagle> meh, you are just continuing the bashing instead of one-offing it
23:43:55 * hackagebot fay-text 0.2.0.0 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.2.0.0 (AdamBergmark)
23:43:57 * hackagebot fay-jquery 0.4.0.1 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.4.0.1 (AdamBergmark)
23:43:59 * hackagebot fay-base 0.18.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.18.0.0 (AdamBergmark)
23:44:01 * hackagebot fay 0.18.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.0 (AdamBergmark)
23:44:59 <wagle> hmm..  interesting (ie, Fay)
23:46:33 <luite> nah ;)
