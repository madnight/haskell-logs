00:00:29 <nisstyre> SrPx: a linked list is useful in many ways, in other situations a vector is more appropriate
00:00:44 <nisstyre> IIRC there is an OverloadedLists extension coming that would allow you to use [] for vectors
00:01:06 <Taneb> nisstyre, I think that's coming in 7.8, not out  yet
00:01:06 <nisstyre> might already be in the latest ghc
00:01:10 <nisstyre> oh ok
00:06:16 <SrPx> nisstyre: Taneb ah it makes sense
00:06:28 <Taneb> :)
00:30:12 <johnw> SrPx: lists go together well with laziness, and sharing due to immutability
00:32:22 <joelteon> damn, Tekmo is gone
00:32:30 <joelteon> has anybody used pipes 4 yet?
00:32:36 <pharaun> not me, not yet
00:32:40 <pharaun> whats up?
00:32:57 <joelteon> i'm trying to figure out whether tryIO and liftP have both been replaced by lift
00:35:36 <pharaun> i don't see liftp or tryio
00:37:49 <jfischoff> pipes 4 looks likes a serious improvement
00:37:56 <joelteon> they're in the older pipes and pipes-safe respectively
00:38:03 <joelteon> tryIO was the function you wrapped around every single IO call
00:39:20 <joelteon> also, the whole runEitherK thing seems to have been scrapped, which is a pity
00:39:48 <johnw> what did runEitherK do?
00:41:37 <joelteon> ran an ExceptionP proxy and returned Right result or Left exception
00:41:46 <joelteon> also there's no StateP monad transformer anymore
00:46:22 <joelteon> but on the plus side, there's no StateP monad transformer anymore!
00:47:47 <SrPx> many functions on the docs are missing their O() complexity :(
00:48:16 <joelteon> heh
00:48:43 <joelteon> lifts everywhere
00:48:50 <pharaun> SrPx: O(scary) :)
01:01:54 <pharaun> joelteon: the tutorial are all saying lift
01:02:13 <pharaun> even for io func
01:20:25 <absence> when running cabal sandbox init i end up with a corrupt 00-index.tar so fail and suggest i run cabal update. when i do, the download is skipped because remote and local files match. the non-sandboxed 00-index.tar is fine and not corrupted. anyone know what could be wrong?
01:20:50 <absence> "so installs fail"
01:20:52 <absence> sorry
01:32:33 <joelteon> well, that's neat
01:32:37 <joelteon> lot of lifting, but ok
01:32:44 <joelteon> what I don't really get now is how bracket works
01:36:01 <Ghoul_> Hey, that's a cool idea
01:36:03 <Ghoul_> a complexity analyzer that works on complexity annotations
01:45:53 <joelteon> ok so far with pipes 4, I feel like I'm using lift a LOT
01:57:45 <AfC> joelteon: there's a pattern around that (can't tell you what it is off-hand, but I recall it came up on the mailing list).
01:58:36 <mroman> The mysql-simple example is broken
01:58:49 <mroman> at least for me.
01:58:59 <mroman> LongLong is incompatible with Int
01:59:08 <mroman> (but Integer isn't)
02:00:40 <mroman> on the other hand
02:00:50 <mroman> mysql-simple can't just return String data?
02:00:53 <joelteon> shouldn't "Base (Proxy Void () () Packet (SafeT (StateT s IO)))" reduce to "Base IO"?
02:03:13 * hackagebot yesod-auth 1.2.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.2 (MichaelSnoyman)
02:03:15 * hackagebot yesod-bin 1.2.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.3 (MichaelSnoyman)
02:03:16 <mroman> ah. hqsl it is, then.
02:03:17 * hackagebot yesod-core 1.2.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.4.1 (MichaelSnoyman)
02:03:19 * hackagebot yesod-form 1.3.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.2 (MichaelSnoyman)
02:07:20 <joelteon> i feel like it should
02:09:29 <kuribas> Is the information on parallel haskell from "Real World Haskell" still relevant?
02:09:53 <kuribas> I have found this newer book: http://chimera.labs.oreilly.com/books/1230000000929/index.html
02:10:15 <AfC> kuribas: Simon Marlow has just about finished a textbook on parallel and concurrent haskell; having seen some of that material when it was in draft I'd say it's excellent.
02:10:29 <tac> kuribas: In general, RWH is somewhat out of date
02:10:36 <satc> I have a array of 256 Word8 elements. The only operation I want to support is to look element at index i (which is also a Word8). Right now I have defined it as a function (using pattern matching). Will representing it as ByteString or Vector will provide faster lookup.
02:10:37 <AfC> Ah, there you go
02:10:40 <kuribas> AfC: That's the second book I linked.
02:10:44 <tac> kuribas: You're better off looking at the new Concurrency and Parallelism book
02:10:52 <kuribas> ok
02:10:53 <AfC> Well yes, buy that, then
02:11:19 <kuribas> I've bought to many books lately, I was still deciding if I should buy it :)
02:14:26 <joelteon> how do you lift an IO action into Base?
02:14:35 <joelteon> in pipes 4, that is
02:14:44 <johnw> kuribas: it's very well worth it
02:14:44 <joelteon> pipes-safe 2, actually
02:15:02 <johnw> and not just for reading about concurrency, but about exception safety also
02:42:12 <kuribas> ok
02:45:35 <SrPx> > data Vec a = (Num a) => Vec a a a
02:45:36 <lambdabot>   <hint>:1:1: parse error on input `data'
02:49:21 <Taneb> SrPx, constraints in a data type are deprecated and widely considered a misfeature
02:49:33 <SrPx> Taneb: )=
02:49:44 <SrPx> okay
02:49:58 <SrPx> Taneb: are you aware of a Vector 3D implementation? I can't find it
02:50:07 <Taneb> Try the "linear" package
02:50:20 <SrPx> okay, thanks!
02:51:15 <SrPx> perfect. I'd like to understand why it uses !a, though
02:52:12 <nh2> what's the best way to convert a Storable.Vector Word8 to ByteString? Can I just unsafeCoerce or is there a nicer function?
02:53:09 <Taneb> SrPx, that just means it's stricter
02:53:15 * hackagebot boomerang 1.3.4.1 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.3.4.1 (DagOdenhall)
02:53:23 <Taneb> It provides a stronger guarantee that you have all of a vector
02:56:55 <SrPx> Taneb: I know, I just don't know what it is for
03:11:00 <mstksg> is persistent's "update" unsafe?  what happens when my data store rejects an update to a unique field?
03:19:08 <donri> mstksg: i doubt it's "unsafe" in the sense usually reserved for that word in haskell code, but it might throw an exception, i guess
03:32:01 <Rc43> Hi, folks.
03:33:46 <Rc43> Is it ok to use such code for forcing evaluation (for avoiding compiler from optimize code to just return "Done.")?
03:33:47 <Rc43> `main = putStrLn $ foldl (\_ _ -> "Done.") undefined $ map func_I_want_to_test [1..100]'
03:34:09 <Rc43> I don't want print it, because printing takes time and benchmark will be incorrect.
03:34:27 <arkeet> Rc43: that won't evaluate anything in the list.
03:35:19 <arkeet> if you want to benchmark things, try using criterion
03:35:41 <arkeet> for forcing evaluation, you should probably know about seq.
03:35:44 <arkeet> :t seq
03:35:44 <lambdabot> a -> b -> b
03:36:26 <donri> or rather deepseq if it's a list, meaning nf rather than whnf with criterion
03:36:55 <Rc43> arkeet, hm, I tried such way to force yesterday and it seems there were pauses when I increased length of list ...
03:36:57 <arkeet> :t foldr seq ()
03:36:58 <lambdabot> [a] -> ()
03:37:18 <Rc43> arkeet, may be because I placed list with test data in the other object, so ghc couldn't optimize it ...
03:37:55 <kuribas> Do you normally increase a package version number after release or before?
03:40:55 <Rc43> arkeet, foldr seq didn't help, may be I use it incorrectly
03:41:03 <arkeet> > foldr seq () [undefined]
03:41:04 <lambdabot>   *Exception: Prelude.undefined
03:41:17 <arkeet> Rc43: well, seq only evaluates to whnf
03:42:01 <kuribas> Rc43: Try force from DeepSeq
03:42:07 <kuribas> :t force
03:42:08 <lambdabot> Not in scope: `force'
03:42:38 <absence> has anyone tried the new pipes-binary yet? decode and decodeGet return StateT and i'm a bit confused about how to hook them up with other pipes
03:42:44 <donri> no, just use criterion via 'nf' :p
03:42:45 <arkeet> well, mostly you should understand what you're doing.
03:42:51 <Rc43> arkeet, How to write `main' function with this evaluation via `foldr seq'? I tried "let _ = foldr seq () $ map func_to_test [1..100] ; putStrLn "\Done.\"", it seems to be optimized to just "putStrLn \"Done.\""
03:43:05 <arkeet> :/
03:43:20 <arkeet> that won't evaluate anything.
03:43:38 <arkeet> > let 1 = 2 in ()
03:43:39 <lambdabot>   ()
03:44:04 <arkeet> but if you're benchmarking, you really ought to be using criterion.
03:44:17 <donri> it's not even an optimization, it's just the evaluation strategy
03:45:23 <arkeet> Rc43: let _ = ... does nothing at all.
03:45:52 <Rc43> arkeet, ok, how to write main with forcing?
03:46:15 <Rc43> Place (putStrLn "Done.") inside of foldr?
03:46:44 <arkeet> no.
03:47:25 <arkeet> if you want to force something in IO, you can use evaluate.
03:47:27 <arkeet> :t evaluate
03:47:27 <lambdabot> a -> IO a
03:47:33 <arkeet> but if you're benchmarking, you really should be using criterion.
03:47:44 <donri> Rc43: import Criterion.Main; main = defaultMain [ bench "func" $ nf func [1..100] ]
03:48:05 <Rc43> arkeet, seems to be OK, thank you.
03:48:10 <Kaini> @pl \(v, _) -> not (v subject)
03:48:11 <Rc43> I will look at Criterion, too.
03:48:13 <lambdabot> ap ((const . not . ($ subject)) . fst) snd
03:48:14 <lambdabot> optimization suspended, use @pl-resume to continue.
03:48:40 <donri> Rc43: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
03:48:57 <Rc43> kuribas, somehow deepseq works in ghci, but no if I compile code, tells that no NFData instance.
03:50:06 <arkeet> you're probably doing something different then.
03:50:12 <arkeet> between ghci and your compiled code.
03:50:14 <donri> Rc43: are you trying deepseq on the same data in both cases?
03:50:45 <donri> it's possible you have an orphan instance imported in ghci but it's more likely you're trying it on different data
03:51:12 <Rc43> donri, I will check again now
03:51:34 <Rc43> arkeet, `evaluate' didn't force
03:52:03 <donri> Rc43: if you deepseq a container, every type contained in it (recursively) has to have an NFData instance
03:52:33 <arkeet> Rc43: evaluate only evaluates to whnf, i.e. the top level constructor in whatever data you're doing.
03:52:34 <donri> Rc43: 'evaluate' forces the WHNF; deepseq forces the NF
03:52:34 <arkeet> likewise for seq.
03:52:51 <arkeet> so if you seq a list, it'll only evaluate far enough to tell whether the list is empty or not.
03:53:01 <Rc43> arkeet, aah, ye, already understood that
03:53:02 <arkeet> (i.e. whether it's using the [] or (:) constructor)
03:53:41 <donri> Rc43: see the link i gave you; it explains whnf and nf nicely
03:54:29 <Rc43> donri, data is same, but I think I got why it complains; just ghci assumes that result list is of ints, but ghc don't know about result type, because I didn't type it
03:55:26 <Rc43> Ye, now it works.
03:55:32 <Rc43> Thanks, guys.
03:55:43 <Rc43> I used `evaluate' and `deepseq'.
03:56:35 <donri> not sure that'll do what you want but ok
03:56:46 <donri> just-use-criterion ;) it's really good
03:57:10 <donri> it measures outliers and such
03:57:11 <Rc43> donri, ye, I will look; just want to know how to do same thing without any tools
03:58:47 <watermind> just noticed Real World Haskell has a chapter on STM
03:59:25 <watermind> I thought STM was pretty new, is RWH (online version) being regularly updated? Or am I wrong about STM being that new?
03:59:54 <mauke> STM isn't that new
04:00:11 <watermind> right
04:00:11 <donri> watermind: the first version of stm on hackage is from 2006
04:00:13 <donri> and that's 2.1
04:00:20 <arkeet> STM isn't all that new.
04:00:34 <donri> and probably ghc had stm stuff before we had an stm package
04:00:37 <arkeet> the stm paper is from 2005.
04:01:47 <watermind> right... I thoguht it was much more recent for some reason
04:02:43 <jack_rabbit> Is there any project that's widely used that is written in haskell, outside the haskell community?
04:02:44 <donri> i guess it was sort of new during the "boom" back when pugs had people discovering haskell and RWH was being written
04:03:13 <donri> jack_rabbit: darcs, xmonad
04:03:17 <arkeet> right, RWH was published in 2008.
04:03:30 <arkeet> darcs is widely used outside the haskell community? ;)
04:03:37 <donri> jack_rabbit: facebook uses haskell internally i think...
04:04:09 <watermind> xmonad is widely used?
04:04:29 <donri> for a tiling WM, certainly
04:04:32 <jack_rabbit> donri, If facebook uses haskell internally, I'd love to work for facebook.
04:04:52 <watermind> I have to try a tiling WM someday to see what the fuss is all about
04:05:05 <donri> jack_rabbit: they've been hiring the brightest minds in the haskell community, don't get your hopes up to work on those projects ;)
04:05:38 <watermind> another question, is parsec the parser of choice these days? or is there one?
04:05:52 <donri> depends what you're parsing
04:06:12 <arkeet> (alternatives: attoparsec, trifecta, )
04:06:48 <watermind> say, some simple programming language, or logic
04:07:12 <jack_rabbit> donri, I'm probably not among the brightest haskell developers. In fact, I'm still a beginner. However, the fact that an institution uses haskell is inspiring.
04:07:21 <donri> possibly for a programming language you want trifecta
04:07:28 <donri> unless the emphasis was on "simple"
04:07:47 <watermind> donri: is there some sort of flowchart for this? :P
04:07:52 <donri> :)
04:08:42 <donri> attoparsec gives you high performance for low-level protocol parsing, at the expense of useful error messages and look-ahead (IIRC)
04:09:15 <donri> trifecta gives you ultra super powers with colorful error messages on the terminal with support for turning a parser into a syntax highlighter
04:10:04 <merijn> donri: tbh, in my experience so far cereal/binary are nicer than attoparsec in terms of actually parsing low level stuff
04:10:27 <Ghoul_> trifecta is super cool
04:10:31 <donri> parsec is the slowest but sort of the "gold standard" and has better errors than attoparsec (but possibly not as good as trifecta)
04:10:46 <watermind> donri: I see, pretty cool
04:10:52 <Ghoul_> parsec is in my experience realllly slow
04:10:58 <kuribas> Should I {-# INLINE -#} small functions that are exported from my module?
04:11:05 <donri> merijn: yeah, probably, maybe depends on exactly *how* low level?
04:11:07 <Ghoul_> I once wrote and optimized a parser in it that took milliseconds to parse 400 lines..
04:11:09 <merijn> jack_rabbit: I know that both Standard Chartered Bank, S&P Capital and some other financial firms use Haskell internally
04:11:16 <donri> kuribas: nah
04:11:24 <wojtekM_> Hello list! I have a question, again...
04:11:32 <kuribas> donri: Does haskell do cross module inlining?
04:11:38 <donri> kuribas: small functions get inlined anyway. INLINABLE can be useful though
04:11:43 <merijn> donri: Well, attoparsec is lacking things as obvious as "parse flexible length value inside fixed width field"
04:12:04 <arkeet> kuribas: I think it does if you use {-# INLINE #-}
04:12:04 <kuribas> For example: (Point x1 y1) ^+^ (Point x2 y2) = Point (x1+x2) (y1+y2)
04:12:07 <merijn> donri: For example, when I had to parse a null padded string inside a 20 byte field, that was really annoying
04:12:19 <arkeet> this is why lens inlines all the things.
04:12:23 <merijn> donri: It's also the main reason I use cereal now, as in binary that was pretty obnoxious too
04:12:25 <wojtekM_> data My = A | B, is it possible to limit the type a function yields to be always A?
04:13:04 <kuribas> wojtekM_: no
04:13:07 <merijn> jack_rabbit: The big "problem" is that the companies that are making lots of money writing haskell aren't the popular web2.0 fads that everyone is writing about
04:13:09 <donri> merijn: yeah that sounds like the sort of thing binary and cereal are better for
04:13:25 <kuribas> wojtekM_: A function "a -> My" can return A or B
04:13:42 <donri> merijn: i.e. binary data :p presumably attoparsec is for ASCII or something like that
04:14:06 <merijn> jack_rabbit: I talked to a guy whose company had a 100k LOC of ActionScript3 to Flash compiler written in Haskell and they were doing quite well selling it.
04:14:10 <wojtekM_> kuribas: even if I know that a function always gives A, I cannot write it down?
04:14:18 <wojtekM_> kuribas: Well, okay
04:14:21 <donri> merijn: or do you think binary/cereal are better suited than attoparsec for things like http, json...?
04:14:21 <merijn> jack_rabbit: When you start looking around, lots of people use haskell, but no one is talking about it ;)
04:14:29 <merijn> donri: I guess?
04:14:30 <kuribas> wojtekM_: Not in that type.  You can make a new type for it.
04:14:42 <donri> merijn: you guess, which part? :)
04:15:23 <wojtekM_> kuribas: Okay, thanks
04:15:32 <arkeet> wojtekM_: you can maek another type, say, OnlyA, and then write a function OnlyA -> My
04:15:48 <merijn> donri: Well, so far my experience seems to say that attoparsec is good for parsing complex collections of atoms, but not so good at structured data
04:15:57 <merijn> donri: cereal/binary seem better at structured data
04:15:57 <arkeet> (and maybe you want to be able to go back: My -> Maybe OnlyA.)
04:16:06 <arkeet> (and then you use a prism.)
04:16:18 <merijn> i.e. "20 int32_t followed by a String of length x"a
04:16:25 <jack_rabbit> merijn, I think you're simplifying things, but it is comforting to see people using haskell.
04:16:36 <donri> merijn: yeah that sounds like a good assessment
04:16:56 <merijn> jack_rabbit: Well, I'm not saying *everyone* is using it, but more people that you would naively expect :)
04:18:16 * hackagebot hamlet 1.1.7.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.2 (MichaelSnoyman)
04:18:18 * hackagebot shakespeare 1.2.0 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.0 (MichaelSnoyman)
04:18:20 * hackagebot shakespeare-css 1.0.6.3 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.3 (MichaelSnoyman)
04:18:23 * hackagebot shakespeare-i18n 1.0.0.4 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0.4 (MichaelSnoyman)
04:18:24 <merijn> donri: The problem is, if you have 50/50 mix of atoms/data than both suck :p
04:18:25 * hackagebot shakespeare-js 1.2.0 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.2.0 (MichaelSnoyman)
04:18:41 <donri> kuribas: i would suggest not using INLINE unless you know why, and to use INLINABLE on polymorphic public functions, and *maybe* also on monomorphic functions if you really want to. and use GHC.Exts.inline internally on calls to your own INLINABLE functions
04:19:04 <donri> merijn: i can imagine :/
04:19:47 <kuribas> donri: Does ghc do inlining cross modules?  For example my vector addition function:
04:19:47 <donri> kuribas: (but do benchmark; inlining can actually severely hurt performance in many cases)
04:19:49 <kuribas> (Point x1 y1) ^+^ (Point x2 y2) = Point (x1+x2) (y1+y2)
04:20:21 <merijn> kuribas: The answer is "sometimes"
04:20:28 <donri> kuribas: IIUC it will expose small functions for cross-module/package inlining, yes
04:21:01 <donri> kuribas: INLINE basically says "inline this, all the time, everywhere, unconditionally" (almost)
04:21:13 <kuribas> donri: So declaring a small function INLINABLE doesn't make much difference.
04:21:20 <donri> kuribas: INLINABLE says "expose this for inlining in the interface file"
04:21:25 <nh2> new-hackage down?
04:21:51 <donri> kuribas: which makes it possible to get type specialization in downstream consumer code or explicitly inline it at the call site with GHC.Exts.inline
04:22:12 <donri> kuribas: for small functions, neither pragma should matter no
04:22:28 <arkeet> well, it would if you're using it in another module.
04:22:42 <kuribas> arkeet: That's my question actually.
04:23:15 <donri> i don't think cross-module matters for small functions
04:23:23 <donri> note that base doesn't INLINE all the things
04:23:27 * hackagebot shakespeare-text 1.0.0.7 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.7 (MichaelSnoyman)
04:23:27 <donri> also see http://neilmitchell.blogspot.se/2011/06/inline-pragmas-in-safe-library.html
04:23:29 * hackagebot yesod-platform 1.2.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4 (MichaelSnoyman)
04:23:30 <arkeet> note that lens does INLINE all the things
04:23:31 * hackagebot netpbm 1.0.0 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-1.0.0 (NiklasHambuechen)
04:23:50 <arkeet> look at core to be sure
04:23:55 <donri> quite
04:23:58 <kuribas> donri: I think it matters especially for small functions.
04:24:05 <arkeet> indeed.
04:24:12 <kuribas> "Without INLINABLE, GHC will omit the definition from the interface file if it is too big. If some other function got inlined into the right-hand-side, this could easily push it over the limit."
04:24:20 <kuribas> http://stackoverflow.com/questions/9709823/is-there-any-reason-not-to-use-the-inlinable-pragma-for-a-function
04:24:21 <arkeet> "if it is too big" hmm
04:24:30 <arkeet> what's the threshold?
04:24:50 <donri> the threshold can be set with -f flags
04:26:07 <donri> it does of course depend on the code, what option is the best
04:26:23 <donri> in lens' case, it's built up by lots and lots of really small but highly polymorphic functions
04:26:29 <kuribas> I guess my vector addition will definitely be inlined.
04:26:49 <arkeet> lots of lens code disappears after inlining.
04:27:05 <arkeet> shachaf makes sure of that.
04:27:34 <donri> but i recently had a case where trying INLINE on everything worsened the performance considerably
04:27:44 <donri> it's not a silver bullet
04:28:33 <fylwind> wouldn't excessive INLINEs cause higher instruction cache misses?
04:28:56 <donri> something like that, yes
04:29:05 <donri> the ghc user guide says something about that
04:33:11 <Ghoul_> is there a way to detect if a program is running on windows?
04:33:21 <Ghoul_> prefferably without the preprocessor, so, at runtime
04:33:25 <donri> > System.Info.os
04:33:26 <lambdabot>   Not in scope: `System.Info.os'
04:34:03 <donri> it's in base
04:34:07 <Ghoul_> oh, cool
04:34:08 <Ghoul_> thanks
04:34:49 <Ghoul_> how can I load a thing registered in ghc-pkg into ghci?
04:35:32 <Ghoul_> :module + System.Info, awesome :)
04:37:15 <noteventime> Ghoul_: If you have a resent-ish version you can also use the standard import syntax
04:41:31 <hpaste> Kaini pasted “How to generalize this?” at http://lpaste.net/92738
04:42:05 <Kaini> How could I define this functions in a "elegant" way? http://lpaste.net/92738
04:43:25 <yesthisisuser> I'm playing around with HaskellDB. Does anyone know if there is a way to do a SQL LAST_INSERT_ID query?
04:44:11 <mauke> (,,) <$> apiAskParam p1 <*> apiAskParam p2 <*> apiAskParam p3
04:45:37 <donri> sequenceOf each $ each %~ apiAskParam  -- possibly :p
04:45:55 <Kaini> huh?
04:46:01 <donri> uh maybe s/$/./
04:48:05 <donri> Kaini: mauke used Control.Applicative from the base package; I used Control.Lens from the lens package
04:48:12 <Kaini> Ah
04:48:14 <Kaini> Control.Lens
04:48:21 <Kaini> I was looking for it right now
04:48:35 <Kaini> And there is no way to remove the 2 3 4 5 verions of the function?
04:48:46 <Kaini> Maybe some newtype foo?
04:48:55 <donri> Kaini: my version does that, if it works
04:48:57 <donri> (didn't test)
04:49:42 <Kaini> I'll try it :) Thanks
05:08:17 * hackagebot yesod 1.2.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.2.1 (MichaelSnoyman)
05:08:19 * hackagebot yesod-auth 1.2.2.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.2.1 (MichaelSnoyman)
05:08:21 * hackagebot yesod-bin 1.2.3.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.3.1 (MichaelSnoyman)
05:08:24 * hackagebot yesod-core 1.2.4.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.4.2 (MichaelSnoyman)
05:08:26 * hackagebot yesod-form 1.3.2.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.2.1 (MichaelSnoyman)
05:14:35 <t4nk734> hello
05:15:01 <FreeFull> Hi
05:15:20 <t4nk734> i want to use in Haskell some mutable arrays, like in python (i mean, i can say arr[1] <op> 2)
05:15:31 <t4nk734> can you give me keywords to google for?
05:15:46 <t4nk734> for example, for chess board
05:16:02 <t4nk734> where i have 8x8 array with different states
05:16:31 <fredmorcos> is it possible for the runtime+compiler to automatically parallelize all pure code?
05:16:37 <Eduard_Munteanu> t4nk734: see the 'vector' or 'array' packages, they both provide mutable arrays
05:16:47 <t4nk734> Eduard_Munteanu: thanks =)
05:17:42 <Eduard_Munteanu> t4nk734: http://www.haskell.org/haskellwiki/Arrays
05:18:04 <FreeFull> t4nk734: You might not need a mutable array though, returning a new array with a change is often enough. Mutable arrays are mostly just for performance
05:20:21 <Eduard_Munteanu> fredmorcos: there have been attempts to do that, but it tends to be difficult to decide whether something's worth parallelizing. As for a midway approach look at DPH.
05:20:21 <kuribas> fredmorcos: Not at this moment: http://chimera.labs.oreilly.com/books/1230000000929/index.html
05:21:37 <fredmorcos> Eduard_Munteanu, I think the Cilk (work-stealing) scheduler may be a very good fit
05:22:58 <Eduard_Munteanu> It might be easier for JIT-ed code since profile-based code generation is less inconvenient there.
05:23:18 * hackagebot yesod-bin 1.2.3.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.3.2 (MichaelSnoyman)
05:23:57 <Eduard_Munteanu> Actually I wonder if GHC can do profile-based optimizations.
05:24:36 <fylwind> so why is GHC called the "Glorious" Glasgow Haskell Compiler? :)
05:28:18 * hackagebot yesod-platform 1.2.4.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4.1 (MichaelSnoyman)
05:28:45 <Ghoul_> Eduard_Munteanu: I know for certain the NCG won't do it
05:29:44 <Ghoul_> LLVM probably does it (or at least, there's a branch or in-dev version that does?), and you might be able to *hack* it to work using command line options through ghc into llvm
05:43:25 <Eduard_Munteanu> I see.
06:02:32 <jmcarthur> i would have pointed out to fredmorcos that ghc already provides very convenient work stealing queues
06:05:31 <salva> list
06:14:24 <paolino> hello , is there a specific channel for questions on gtk bindings ?
06:25:15 <serban> Hi, I'm using EclipseFP plugin and would like to have tab completion in console when running/using haskell. Is that possible?
06:37:23 <mroman> oh man
06:38:16 <mroman> my installation is still broken
06:38:21 <mroman> it says web-encodings is installed
06:38:28 <mroman> but import Web.Encodings is still missing
06:38:47 <mroman> can I remove EVERYTHING except the compiler and reinstall eveything through cabal?
06:43:20 * hackagebot lens 3.9.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.9.1 (EdwardKmett)
06:51:52 <mroman> system.directory is apparentely broken
06:53:20 * hackagebot integration 0.2 - Fast robust numeric integration via tanh-sinh quadrature  http://hackage.haskell.org/package/integration-0.2 (EdwardKmett)
06:54:40 <mroman> What's the successor of web-encodings
06:54:43 <mroman> it's obsolete on hackage
06:56:36 <niteria> @where paste
06:56:36 <lambdabot> http://lpaste.net/new/haskell
06:57:27 <hpaste> niteria pasted “unexpected strictness annotation” at http://lpaste.net/92739
06:57:43 <niteria> why can't I do !Map.Map on line 30?
07:01:52 <k00mi> niteria: try putting the ! in front of the paren
07:02:51 <merijn> mroman: How is System.Directory broken?
07:04:33 <mroman> merijn: There's no Prelude.catch
07:04:44 <niteria> k00mi: same error
07:04:47 <k00mi> niteria: actually, I don't think you can have a ! there at all
07:05:09 <epta>  http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-rpar-rseq where are these `time: 0.00s' came from? > The first timestamp is printed when the rpar/rseq fragment returns, and the second timestamp is printed when the last calculation finishes
07:05:13 <epta> But how?
07:05:38 <mroman> I can't install squat anymore
07:05:40 <mroman> everything is broken
07:06:22 <k00mi> niteria: you can only annotate fields in constructors
07:07:06 <niteria> docs for MVar suggest strict-concurrency, but it fails to install
07:07:38 <merijn> mroman: Are you by any chance building 1.2.0.0 with 7.4?
07:08:25 <merijn> mroman: Or really just which GHC and which version of directory? Sounds like your using a version that's too old with a compiler that's to new or vice versa
07:09:00 <mroman> i also get linker errors :(
07:09:21 <merijn> mroman: The way to nuke your install (on linux) is "rm -rf ~/.ghc"
07:09:33 <kuribas> arkeet: Isn't the derivative of tan = 1/cos^2 x?
07:09:49 <donri> epta: see rpar.hs in http://hackage.haskell.org/package/parconc-examples
07:10:07 <merijn> mroman: For future reference, the correct way to unregister a packge is "ghc-pkg unregister pkg-name"
07:10:17 <mroman> http://codepad.org/bvV2gkBK
07:11:20 <merijn> mroman: How did you install things? Platform? Or some distro's package manager?
07:11:59 <mroman> make install for ghc-7.6.3 and cabal
07:12:26 <mroman> and the platform
07:12:40 <mroman> but I deleted ~./caba/lib and  ~/.ghc
07:12:46 <mroman> and then did make install for ghc again
07:12:59 <mroman> and installed the rest through ~/.cabal/bin/cabal
07:13:31 <merijn> Curious
07:13:42 <merijn> Did it ask to do reinstall/forced installs?
07:13:49 <epta> donri: thanks, forgot about it
07:14:03 <mroman> merijn: not after i deleted everything
07:14:05 <mroman> before, yes
07:15:02 <mroman> there are currently two versions of bytestring installed
07:15:39 <mroman> some package requires an older version of bytestring
07:16:01 <merijn> reinstall/forced install are usually one way trips into breakage town, and as cabal says you shouldn't do them unless you know what you're doing
07:16:12 <watermind> so ":i Data.Aeson.Types.Internal.Parser"  results in "Failed to load interface for `Data.Aeson.Types.Internal   it is a hidden module in the package `aeson-0.6.1.0'"
07:16:14 <merijn> mroman: Yeah, there's no real way to fix that, other than nuke it and start over
07:16:55 <watermind> I don't see how that makes sense... the type Data.Aeson.Types.Internal  is exposed since it is used in e.g. (.:)
07:17:18 <mroman> merijn: I already tried that :)
07:17:20 <watermind> also looking at http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/src/Data-Aeson-Types-Internal.html it seems to be exported
07:17:42 <donri> watermind: the module itself isn't "exposed", though
07:17:48 <donri> watermind: maybe you want Data.Aeson.Parser
07:18:02 <mroman> the unix package for example requires bytestring-0.9.2.1
07:18:07 <mroman> and cgi requires 10.0.2
07:18:10 <watermind> donri: right I see
07:18:21 * hackagebot keter 1.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.0.1 (MichaelSnoyman)
07:18:22 <mroman> also
07:18:28 <mroman> that error only occurrs with runghc
07:18:35 <mroman> compiling and ghci itself works apparentely
07:18:50 <donri> watermind: or Data.Aeson.Types
07:18:54 <watermind> donri: but the type of (.:) is   ... -> aeson-0.6.1.0:Data.Aeson.Types.Internal.Parser a
07:19:11 <mroman> but i still wonder what to use for web.encodings
07:19:17 <donri> watermind: Data.Aeson.Types exports the Parser type
07:19:27 <merijn> mroman: Well, either you need to downgrade your cgi version to one that works with an older bytestring, or you can do "cabal unpack unix", edit the cabal file to use a newer bytestring version and install that. Usually the upper limits are rather conservative and it will "Just Work", although sometimes it requires some fixing to be compatible again
07:20:00 <wojtekM_> Is it possible to have a type local to function scope?
07:20:13 <mroman> I thought using different versions of the same package is possible?
07:20:16 <watermind> donri: I understand, but then why is the type in GHCi displyed as aeson-0.6.1.0:Data.Aeson.Types.Internal.Parser a ? rather than  Data.Aeson.Types which is exporting Parser?
07:20:31 <donri> watermind: because that's where it's actually defined
07:20:47 <statusfailed> Are there any good lisp tutorials with a more theoretical bent?
07:20:48 <Makoryu> mroman: You can have different versions installed alongside each other. But when loading and linking them, one would replace the other
07:21:09 <watermind> donri: hmm this is the kind of info I'd expect to get on further inspection, e.g. with :i type
07:21:21 <merijn> Makoryu: That won't work if he has two libraries using different versions in the same program
07:22:11 <merijn> mroman: It is, but if they're different bytestrings and your program has two different versions of bytestrings flowing through it, that won't work
07:22:15 <donri> watermind: agreed, it could be better. but you can import the same thing from multiple places though (if they re-export) so it has to call *some* module the canonical place. so it uses the defining module for that.
07:22:15 <Makoryu> merijn: Sorry, should have been clear. The reason you can't do that is because *if* this was allowed, one *would* replace the other, or other bad things would happen
07:22:25 <wojtekM_> f = let type A = Int in 3
07:22:27 <wojtekM_> ?
07:22:27 <mroman> hm
07:22:31 <mroman> ghci is broken, too
07:22:52 <mroman> but compiling still works :D
07:22:54 <statusfailed> ooh, "Chaitin the Unknowable" seems to be in the right area
07:23:07 <mroman> yet
07:24:00 <kuribas> arkeet: Never mind.
07:24:21 <watermind> donri: so you're saying GHCi opts for reducing every type to some canonical representation and always uses that, am I understanding correctly?
07:25:42 <watermind> I can see how that helps recognizing if two types/modules/whatever are the same... but it complicates being able to actually referring to them and gathering more info
07:26:11 <Makoryu> (http://hackage.haskell.org/packages/archive/graphviz/2999.16.0.0/doc/html/src/Data-GraphViz-Attributes-Complete.html <- This took ages to compile on my machine but I have no idea why.)
07:26:13 <merijn> donri: It only displays like that for types that aren't directly imported, I think
07:26:16 <merijn> eh
07:26:19 <merijn> s/donri/watermind
07:26:30 <watermind> merijn: right
07:27:00 <merijn> wojtekM_: And what would you do with A in that example?
07:27:43 <watermind> is there an easy way in such cases to tell where the type is being imported from, rather than where it is originally defined?
07:28:21 * hackagebot markdown 0.1.6.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.6.1 (MichaelSnoyman)
07:32:19 <wojtekM_> merijn: I need to instantiate a parser within a parser. For some reason, this litle one can not be part of the big one
07:34:12 <merijn> wojtekM_: And what does the type have to do with that?
07:34:46 <watermind> it's not just me who gets confused with this,  define,    f x = (.:) x  , then use ghc-mod M-t to fill in the type signature, and the resulting type is not valid
07:36:12 <wojtekM_> merijn: my big parser is: type Parser = ParsecT ByteString TheState IO
07:36:43 <wojtekM_> merijn: my little I want to be just: type Parser = ParsecT ByteString TheState IO
07:37:23 <merijn> Those have the same type?
07:37:25 <wojtekM_> merijn: I can find my way around, but I just wanted to know if something like type local to function exists. I guess the answer is no
07:37:49 <wojtekM_> merijn: different types
07:38:07 <Makoryu> wojtekM_: Are they different ByteStrings, or...?
07:38:33 <Makoryu> If by "TheState" you mean the same state representation for both of them, I don't see the difference
07:40:50 <wojtekM_> I neeed to read length, then read a string of the length, memoize the string in TheState, and then finally parse the string
07:42:21 <wojtekM_> I can analyze the string ad-hoc, or use regex, but the most elegant way would be to run a small internal parser on it
07:42:43 <wojtekM_> but the string has already been consumed
07:45:48 <wojtekM_> and I didn't want to pollute the namespace with the small parser type, as it is only going to bemeaningful within a small scope
07:47:52 <merijn> Why not just write out the full type if you're only gonna use it once?
07:48:21 * hackagebot yaml 0.8.5 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.5 (MichaelSnoyman)
07:49:47 <wojtekM_> Uhm, because... ;-)
07:49:59 <wojtekM_> Okay, thanks!
08:03:22 * hackagebot wai-extra 1.3.4.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.5 (MichaelSnoyman)
08:04:36 <red___> how do i truncate (/) on Float?
08:05:10 <red___> [2.0833334e-2,2.0,96.0]
08:06:34 <red___> > let x = [2.0,96.0] in ((\[fst,scnd] -> (fst / scnd)) x : x)
08:06:35 <lambdabot>   [2.0833333333333332e-2,2.0,96.0]
08:06:56 <wojtekM_> merijn: It turned out that I don't even have to write down the type at all.
08:13:51 <riley__> If I have a list of 'State a ()' and I want to evaluate them all and get the final state out, how do I do it?
08:16:27 <paolino> :t State
08:16:28 <lambdabot>     Not in scope: data constructor `State'
08:16:28 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
08:16:31 <bjorkintosh> so here's a question.
08:17:00 <bjorkintosh> since it is possible to use the lambda symbol as a prompt, why is it that we still type <= when we could be typing the neater symbol?
08:17:59 <Taneb> bjorkintosh, most people don't have the neater symbol on their keyboards
08:18:00 <bergmark> for the same reason you wrote "the neater symbol" rather than actually typing it? :)
08:18:09 <bjorkintosh> hahahah
08:18:19 <bjorkintosh> touche(')
08:18:21 <Taneb> @hackage base-unicode-symbols
08:18:21 <lambdabot> http://hackage.haskell.org/package/base-unicode-symbols
08:18:38 <bjorkintosh> does ghc understand the unicode symbols?
08:18:49 <bergmark> bjorkintosh: yes
08:18:55 <bjorkintosh> hmm. nice.
08:18:58 <Taneb> It parses them but doesn't associate them with the ASCII versions
08:19:08 <hpc> the haskell specification says they must be understood
08:19:08 <Taneb> But check out that package I just linked
08:19:28 <bjorkintosh> Taneb, is it included in the haskell-platform?
08:19:33 <Taneb> No
08:20:23 <bjorkintosh> okay.
08:20:30 <bjorkintosh> that would be neat.
08:22:20 <Taneb> "cabal install base-unicode-symbols --enable-documentation --haddock-hyperlink-source"
08:22:55 <paolino> :t sequence_ :: [State a ()] -> State a () -- riley__
08:22:56 <lambdabot> [State a ()] -> State a ()
08:23:18 <bjorkintosh> cabal update first, man.
08:23:23 <bjorkintosh> always update first.
08:24:26 <bjorkintosh> that was fast.
08:24:55 <merijn> Does anyone know how to stop hdevtools from choking on a runhaskell shebang?
08:25:27 <riley__> Perfect! Thanks. Kept trying to compose w/ (>>) but failed.
08:25:27 <merijn> bjorkintosh: I would actually recommend not cabal updating unless strictly necessary for some new package you need
08:25:45 <Taneb> bjorkintosh, that library only depends on base and hasn't been changed in over a year. You can get away without cabal updating with it
08:26:04 <bjorkintosh> ah i see.
08:26:28 <bjorkintosh> it is not possible to tab complete hackage names?
08:26:30 <merijn> I try to update as little as possible after installing platform, seems to keep things nice and stable
08:26:49 <bjorkintosh> ye gads i might have goofed on that one.
08:27:18 <geekosaur> bjorkintosh, I doubt anyone has assembled a bash-completion package for it
08:27:38 <Tekmo> bjorkintosh: It use to tab complete, if I remember correctly, but it was really slow
08:28:00 <Tekmo> bjorkintosh: So I would always regret hitting tab by mistake
08:28:16 <bjorkintosh> oh i see.
08:28:32 <deech> I'm trying to write Storable instances for two datatypes where one contains the other: https://gist.github.com/deech/6485616. Unfortunately I'm getting compiler errors. Any help is appreciated.
08:29:06 <Tekmo> I think `cabal update` is safe as long as you know how to maintain your package database, meaning that you know how to unregister packages and remove conflicts
08:30:40 <donri> Tekmo: how far is pipes-bytestring from a release?
08:30:53 <Tekmo> donri: A couple of months
08:30:57 <Tekmo> donri: I need to graduate first
08:31:00 <donri> :)
08:31:03 <Tekmo> :)
08:31:07 <Tekmo> There are still a few things missing
08:31:18 <Tekmo> The important missing bits are splitter functions in the style of `pipes-parse`
08:31:28 <merijn> Tekmo: Graduation is overrated! :p
08:31:31 <Tekmo> :)
08:32:39 <haasn> what's the deal with the Int parameter on everything in pipes-network?
08:32:47 <haasn> I thought explicit buffering would be abstracted out by the interface
08:33:09 <haasn> or am I misunderstanding how things work? I just want to more or less lazily process lines the user sends me, without using actual lazy IO
08:34:01 <Tekmo> haasn: I'm not entirely sure
08:37:44 <Tekmo> deech: What does the #pointer declaration do?
08:38:22 * hackagebot xml-hamlet 0.4.0.5 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.5 (MichaelSnoyman)
08:39:17 <Tekmo> deech: Are you using `c2hs`?
08:40:38 <deech> Tekmo: yes. I've updated the gist with the generated output.
08:41:13 <Tekmo> deech: Have you tried `hsc2hs`?  `cabal` integrates with that to automatically run `hsc2hs` on any `*.hsc` files
08:41:31 <merijn> Or even better
08:41:33 <merijn> c2hsc
08:41:43 <merijn> Which parses C files and generates hsc from them :)
08:41:56 <Tekmo> Seriously?
08:42:23 <Tekmo> Wow, that's really useful
08:42:24 <merijn> Yes
08:42:25 <deech> Tekmo: No I've haven't tried that.
08:43:03 <deech> merijn: Does c2hsc have hooks to allow me to control naming?
08:43:08 <monochrom> Taneb, bjorkintosh: you forgot --enable-library-profiling
08:43:10 <merijn> Tekmo: It's not flawless, it doesn't get really complex C headers/files completely right, but if you're lucky it does all the work, and if you're unlucky it does *most* of the works
08:43:14 <donri> i think c2hs is supposed to be integrated with cabal too somehow
08:43:23 * hackagebot cookbook 0.1.0.0 - A silver-platter library in Haskell.  http://hackage.haskell.org/package/cookbook-0.1.0.0 (NatePisarski)
08:43:37 <merijn> deech: It doesn't have any hooks atm, it's just a binary
08:43:40 <donri> merijn: i guess i'm really unlucky then because i couldn't get it to do anything :p
08:43:43 <deech> I have c2hs integrated with Cabal,just add it to the `build-tools` flag.
08:44:08 <merijn> deech: I manually hooked c2hsc into cabal: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
08:44:13 <watermind> to perform substitutions of variables in AST's, is it common to abstract the structure of the Var field and use a monad instance?
08:45:16 <Tekmo> I think so.  Isn't there some paper about doing this?
08:45:21 <watermind> and then  ast >>= subst_fun
08:45:32 <watermind> Tekmo: I don't know...
08:45:54 <Tekmo> Well, I found this: http://blog.sigfpe.com/2006/11/variable-substitution-gives.html
08:47:50 <donri> what kind of substitution? https://www.fpcomplete.com/user/edwardk/bound
08:48:24 * hackagebot cookbook 0.1.1.0 - An independent library of common haskell operations.  http://hackage.haskell.org/package/cookbook-0.1.1.0 (NatePisarski)
08:48:44 <jmcarthur> watermind: it is pretty common
08:48:50 <watermind> Tekmo: thanks, I didn't knwo about this paper
08:48:57 <watermind> know*
08:49:08 <Tekmo> Yeah, the post mentions the paper by Uustalu and Venee
08:49:13 <jmcarthur> watermind: i highly recommend looking at the bound library donri linked
08:49:25 <jmcarthur> watermind: if you need scoping, at least
08:49:49 <jmcarthur> ah, he linked a tutorial instead of a library, but whatever :)
08:50:13 <watermind> donri: jmcarthur: thanks... oh the number of my "to read" articles by  Edward is starting to pile up
08:50:14 <donri> it's a tutorial for a library :)
09:04:00 <bennofs> context reduction stack overflow :O
09:05:01 <deech> What's the best way to bind a C array if the length is unknown?
09:06:21 <Makoryu> deech: Unknown at compile time, or unknown at runtime?
09:07:03 <donri> there's peekArray0 or something like that for arrays with a terminator
09:07:05 <deech> Makoryu: Unknown at compile time, it's just a A* which I want to marshall in to [A].
09:07:58 <merijn> Foreigun.Util.Marshall
09:08:03 <Tekmo> deech: Then you need some other value to store length or a sentinel value to terminate the array like \0
09:08:15 <merijn> wait, my bad, wrong name
09:08:39 <deech> Can't I just keep iterating the pointer by some offset until it points to nothing?
09:08:41 <merijn> Foreign.Marhsall and Foreign.Marshall.Array
09:08:49 <donri> deech: that doesn't make sense though
09:08:51 <merijn> deech: "points to nothing", wut?
09:08:55 <monochrom> force the C side to tell you length
09:09:04 <donri> deech: this is why buffer overflows are a security problem you know
09:09:06 <merijn> deech: What do you envision "points to nothing" to mean?
09:09:29 <Tekmo> deech: He means using a sentinel value that terminates the array
09:09:42 <Tekmo> deech: However, I'd recommend storing the length alongside the array
09:09:43 <deech> Right, like a NULL.
09:09:44 <donri> deech: try peekArray nullPtr
09:09:52 <merijn> Pointers always point to something, unfortunately that something may not be something you're allowed to see
09:09:53 <donri> deech: uh, peekArray* nullPtr
09:09:57 <Tekmo> Like donri said, it's less secure to use a null value to terminate the array
09:09:57 <donri> deech: uh, peekArray0 nullPtr
09:09:58 <donri> gah
09:10:03 <donri> what's wrong with me
09:10:04 <deech> I'm not using the right terminology. I'm a C newbie.
09:10:09 <tpsinnem> hey -- is there a name for a tree structure, where each leaf is associated with a numerical value, and each internal node is associated with the sum of the values of its children?
09:10:10 <merijn> deech: Then you need to be sure the array is terminated with NULL, is it?
09:10:10 <Makoryu> Oh boy
09:10:27 <red___> if i want to build a graph, is IntMap a good choice..especially if i want to pull out edges with least weight?
09:10:51 <deech> merijn: I don't know. I'd have to check the source. Right now it's just a pointer to the start of the array.
09:11:00 <deech> Makoryu: We all have to start somewhere.
09:11:12 <merijn> deech: There is only two ways to find the end of an array in C: 1) store the length in an int 2) have the last element be a fixed value
09:11:13 <Tekmo> red___: Why not `Data.Graph`?
09:11:16 <Makoryu> deech: Not a problem. Just note that C arrays don't know how long they are
09:11:24 <red___> Tekmo: because i don't know about that !
09:11:28 <Tekmo> red___: :)
09:11:29 <Makoryu> deech: They're nude pointers
09:11:31 <deech> Makoryu: Understood.
09:11:36 <merijn> deech: If you're not sure about 2), then 1) is the only option, which means you need to be told how long it is
09:12:06 <deech> merijn: Great. Thanks! I'll try to make that happen.
09:12:35 <Makoryu> deech: If the C data structure was instead a linked list, and you could guarantee that the last node would point to NULL, then you *could* iterate it in the way you suggested
09:13:19 <merijn> deech: Foreign.Marshall.Array has functions for dealing with both options
09:13:39 <Zearen> Is there an existing "reverse semaphore" like structure for Haskell ?  I mean, I could code one up in about an hour, but there's no reason to repeat work.
09:14:15 <Zearen> I mean, QSemN exists, but it isn't as nice as it could be for what I'm trying to do.
09:14:26 <deech> merijn, Makoryu : Thanks!
09:15:51 <Tekmo> Zearen: So what is the problem with QSemN?
09:18:31 <Zearen> I have to write a custom reverseSignal using peekAvail
09:19:33 <Zearen> So the logic is I have a bunch of threads entering a section, and I don't want other logic to continue until they've all completed.
09:19:56 <Zearen> Typically you'd use a join, but I can't do that here.
09:21:19 <jmcarthur> you mean you want to have one thread waiting on all the others to finish before continuing?
09:21:48 <Zearen> Yes.  But this thread may or may not exist
09:21:59 <jmcarthur> the first thing that comes to mind is to use a TVar with a count of the threads that are still running and just have the waiting thread wait until the count reaches zero
09:22:11 <jmcarthur> stm is good for these kinds of retry loops
09:23:02 <jmcarthur> atomically $ do { n <- readTVar tvar; unless (n == 0) retry }
09:24:05 <Zearen> Yes, that's exactly what I would do if a package doesn't already exist; I was just making sure I wasn't missing some obvious.
09:24:16 <jmcarthur> another possibility
09:24:19 <jmcarthur> use the async library
09:24:25 <jmcarthur> and just wait on the whole set of jobs
09:24:34 <jmcarthur> that would be even more straightforward i guess
09:25:17 <Tekmo> Zearen: Using `async` you would write:
09:25:34 <Tekmo> as <- replicateM n $ async someThread
09:25:37 <Tekmo> mapM_ wait as
09:25:44 <Zearen> It would if I had access to the threads; the threads are callbacks.
09:26:08 <jmcarthur> if they are callbacks then do you even know how many there will be?
09:26:14 <Zearen> No
09:26:25 <jmcarthur> ah, then neither of our suggestions will work
09:26:30 <Tekmo> I would just roll this yourself
09:26:52 <jmcarthur> i'm not even sure your problem is well specified, now
09:26:57 <Zearen> Ok, that's what I was checking.  Thanks.
09:27:06 <jmcarthur> i don't know what it means for an unknown set of callbacks to "finish"
09:27:19 <Tekmo> jmcarthur: I think he means that the callbacks would signal some event
09:27:32 <Tekmo> jmcarthur: And after N events have been signaled he can begin some other computation
09:27:40 <jmcarthur> ah
09:27:45 <Tekmo> Oh
09:27:47 <Tekmo> Hold on
09:27:48 <jmcarthur> the stm suggestion could work in that case, if so
09:27:51 <Zearen> Welll
09:27:56 <Tekmo> Zearen: Did you check Control.Concurrent.STM.TSem?
09:28:09 <Zearen> Let me give it a look
09:29:17 <Zearen> That seems like a regular Semaphore.
09:29:54 <Tekmo> Why do you need a reverse semaphore?
09:30:00 <Tekmo> Aren't you just waiting for N tasks to complete?
09:32:16 <Zearen> What I want to do is have each callback increment when entering, and decrement when leaving.  The rest of the logic can continue  when the count is 0
09:32:52 <Tekmo> Yeah, this is a very small amount of code to write
09:32:58 <Tekmo> You can very easily write this up
09:33:46 <Zearen> Yup, I just didn't want to hand write and have someone say, "Well, why didn't you just use x"
09:33:58 <Zearen> Thanks.
09:34:08 <Tekmo> You're welcome
09:35:57 <jmcarthur> Zearen: if the waiting thread runs before any callbacks run, it should just go ahead and run to completion?
09:36:08 <jmcarthur> Zearen: this is what would happen if no callback has incremented that counter yet
09:36:23 <Tekmo> You can fix that really easily by just adding an additional `Bool` Tvar
09:36:46 <Tekmo> and then only flipping it after the first thread acquires the semaphore
09:37:03 <Zearen> The waiting thread is started asynchronously
09:37:12 <Tekmo> Of course, then there is the problem if that thread finishes before the next one begins
09:37:26 <Tekmo> Oh, then you just keep a separate `TVar Int`
09:37:42 <Tekmo> You keep track of how many threads have acquired the semaphore ever
09:37:48 <jmcarthur> getting complicated, Tekmo :P
09:37:54 <Tekmo> No, it works!
09:37:58 <Tekmo> You wait on two things:
09:38:08 <Tekmo> * Have N threads ever acquired the semaphore
09:38:16 <jmcarthur> i believe you. just saying... this is no longer quite so trivial to reason about
09:38:19 <Tekmo> * Are there currently 0 threads that are acquiring you
09:38:52 <Tekmo> Maybe a more intuitive way to frame it is like this
09:38:56 <Tekmo> You're waiting on N tasks to complete
09:39:16 <Tekmo> Which is the same thing as saying "I'm waiting for N tasks to begin and N tasks to end"
09:39:27 <Tekmo> So you keep track of how many times they begin and how many times they end
09:39:42 <Tekmo> Once they both reach N you are done
09:39:50 <jmcarthur> ah, just two counters that never decrement. when they are equal you can run
09:39:56 <Tekmo> When they are N you can run
09:40:07 <jmcarthur> i thought we didn't know what N is
09:40:08 <Tekmo> i.e. both counters = N
09:40:31 <Zearen> The callbacks are responses to server input.  The waiting thread is a call to gracefully stop the server.
09:40:37 <jmcarthur> ah!
09:40:40 <jmcarthur> that helps
09:40:50 <jmcarthur> so really one counter is fine
09:41:02 <jmcarthur> you can only kill when it's zero
09:41:17 <Zearen> Yup, that's the idea.
09:41:35 <Zearen> I thought something like that may already exist.
09:48:20 <red___> :t fromListWith
09:48:21 <lambdabot>     Not in scope: `fromListWith'
09:48:21 <lambdabot>     Perhaps you meant one of these:
09:48:21 <lambdabot>       `IM.fromListWith' (imported from Data.IntMap),
09:48:31 <red___> :t IM.fromListWith
09:48:32 <lambdabot> (a -> a -> a) -> [(IM.Key, a)] -> IM.IntMap a
09:59:31 <ocharles> mm_freak_: good work with all the netwire progress!
09:59:35 <ocharles> will have chance to take a look tonight
10:06:13 <ocharles> mm_freak_: that clock is beautiful :)
10:06:16 <Guest73672> @let poop = "~..o8o..~"
10:06:17 <lambdabot>  Defined.
10:06:39 <gnuvince> Can anyone explain the pipe syntax in the code at page 6 of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf ?
10:06:43 <ocharles> mm_freak_: though i'm curious what 'notYet' is needed for
10:08:37 <edvo> gnuvince: you mean "Monad Error e m | m -> e"? That are functional dependencies. http://www.haskell.org/haskellwiki/Functional_dependencies
10:08:45 <Guest73672> @let diarrhea = replicate100 poop
10:08:45 <lambdabot>  .L.hs:139:12:
10:08:45 <lambdabot>      Not in scope: `replicate100'
10:08:45 <lambdabot>      Perhaps you meant one o...
10:08:51 <Guest73672> @let diarrhea = replicate 100 poop
10:08:51 <lambdabot>  .L.hs:139:26:
10:08:51 <lambdabot>      Not in scope: `poop'
10:08:51 <lambdabot>      Perhaps you meant `loop' (impor...
10:08:58 <gnuvince> edvo: that's what I meant; thanks for the link!
10:09:52 <mauke> Guest73672: ?
10:10:45 <Guest73672> @let throwAgainstWall = const "SPLAT!"
10:10:46 <lambdabot>  Defined.
10:11:00 <Guest73672> > throwAgainstWall poop
10:11:01 <lambdabot>   Not in scope: `poop'
10:11:01 <lambdabot>  Perhaps you meant `loop' (imported from Control.Arrow)
10:11:05 <gnuvince> edvo: in the example in the link you provided, class Mult a b c | a b -> c where ..., does that mean that c needs to be an a or a b?
10:11:15 <mauke> Guest73672: could you please stop that?
10:11:42 <edvo> gnuvince: it means that c is uniquely defined by a and b
10:11:50 <mm_freak_> ocharles: 'periodic 1' occurs at 0, 1, 2, 3, 4, …
10:12:01 <mm_freak_> ocharles: notYet forgets the first occurrence
10:12:11 <mm_freak_> notYet . periodic 1 occurs at 1, 2, 3, 4, …
10:12:43 <ocharles> mm_freak_: ah, i see
10:12:53 <satvik> can some one explain this. type of binary tree is fix point of equation bt = 1 + bt * bt
10:12:59 <ocharles> but doesn't 0 mean 12 o'clock?
10:13:19 <ocharles> mm_freak_: i would have thought you would have wanted to go 0-59 and cycle
10:14:07 <ocharles> mm_freak_: in fact, defining the clock in terms of "at :: [Time] -> [Event]" might also be nice
10:14:13 <ocharles> seconds every 1 second, minutes every 60
10:14:13 <ocharles> etc
10:14:18 <mm_freak_> ocharles: that's what i do
10:14:57 <mm_freak_> sumE . notYet . periodic 1 . 1 denotes [(0, 0), (1, 1), (2, 2), (3, 3), …
10:14:58 <FreeFull> There seem to be two monoid instances for ZipList
10:15:07 <FreeFull> A discardy one and a keepy one
10:15:13 <mm_freak_> ocharles: if you picture Event as [(Time, a)]
10:15:34 <ocharles> mm_freak_: hm, how does event at t=0 get value 0? because sumE on NotEvent = 0?
10:16:33 <FreeFull> For the keepy one, mempty = ZipList; for the discardey, mempty = ZipList (cycle mempty)
10:16:35 <geekosaur> satvik: that equation is equivalent to the Haskell type: data Tree a = Leaf a | Branch (Tree a) (Tree a). 1 is a value; + is Haskell's |, * indicates "parameters" to a constructor (might be easier to think of it as: a * a is like (a,a) in Haskell)
10:16:36 <mm_freak_> ocharles: oh, sorry
10:16:40 <mm_freak_> it starts at (1, 1)
10:16:50 <mm_freak_> ocharles: and then comes hold <|> 0
10:16:52 <FreeFull> Which would be mempty = mempty : mempty   if : was ZipList's constructor
10:17:05 <ocharles> mm_freak_: ah yes
10:18:13 <geekosaur> satvik, in some sense this is like calculus derivatives applied to types. constants become 0, variables become constants, types become variables
10:18:57 <mm_freak_> mempty = pure mempty
10:19:03 <mm_freak_> mappend = liftA2 mappend
10:19:37 <danilo2> Hello! :) Is there any way to write the following expression nicer (I mean simplier, more pure, etc): mapM f classes >>= mapM g ? :)
10:20:37 <aleator> danilo2: Perhaps mapM (f>=>g)?
10:20:53 <aleator> danilo2: But this depends on the context.
10:21:18 <FreeFull> :t \f g -> mapM (f >=> g)
10:21:18 <danilo2> aleator: I was looking for something like that
10:21:19 <lambdabot> Monad m => (a -> m b1) -> (b1 -> m b) -> [a] -> m [b]
10:21:23 <bergmark> danilo2: the only way to make that purer is to make f and g purer
10:21:24 <satvik> geekosaur thanks for that. I wanted to know how fix point comes into picture.
10:21:43 <aleator> danilo2: But depending on which monad, this might not be the same.
10:21:51 <geekosaur> that's because bt is onb both sides of the =
10:21:57 <geekosaur> so we have a type which "depends on" itself
10:22:06 <danilo2> bergmark: I know, maybe pure was wrong word - this has to be monadic, so the aleator 's solution is very nice :)
10:22:20 <geekosaur> this is a form of recursion, and is how a single equation can describe a type which can expand arbitrarily
10:23:21 <ParaSa1lin> just checking my understanding, foldr (+) 0 is not constant space?
10:23:40 <FreeFull> ParaSa1lin: Yes, because (+) is strict in both arguments
10:24:02 <quchen> It still builds up an O(n) thunk
10:24:13 <FreeFull> ParaSa1lin: You probably want  foldl' (+) 0
10:24:19 <ParaSa1lin> im not sure why tekmo uses foldr in Data.Fold then
10:24:25 <geekosaur> just expand the equation into itself where a `bt` appears. so: bt = 1 + (1 + bt * bt) * (1 + bt * bt) = 1 + (1 + (1 + bt * bt) * bt) * (1 + bt * bt), etc. as the tree grows. the type is unbounded because you can substitute back in forever
10:24:31 <skypers> hey
10:24:50 <geekosaur> this describes the growth of a binary tree
10:24:52 <skypers> what libs exist for GUI in Haskell?
10:25:08 <FreeFull> ParaSa1lin: It might be the Num instance tekmo uses has a different strictness for (+)
10:25:32 <ParaSa1lin> http://hackage.haskell.org/packages/archive/foldl/1.0.0/doc/html/src/Control-Foldl.html#fold
10:25:36 <Zearen> In case curiousity exists: https://gist.github.com/zearen-wover/6486622
10:26:01 <satvik> geekosaur thanks
10:26:15 <ParaSa1lin> help me understand why he defines fold in terms of foldr
10:26:33 <mm_freak_> ParaSa1lin: whether foldr (+) is constant space depends on how and with what type you use it
10:26:47 <mm_freak_> ParaSa1lin: for example it's constant space for this type:  data Nat = Zero | Succ Nat
10:26:59 <ParaSa1lin> right, or for foldr (:)
10:27:28 <mm_freak_> ParaSa1lin: the rule of thumb is:  check the strictness of the folding function
10:27:44 <deech> Has anyone who's used the fficxx know how it handles overloaded functions?
10:27:55 <Tekmo> Oh
10:28:03 <Tekmo> The reason I use `foldr` is to trigger `fold/build` fusion
10:28:08 <deech> Or if any more documentation exists.
10:28:11 <geekosaur> skypers: wxhaskell, gtk2hs, and OpenGL are the lower level libraries; you can program them "procedurally" or you can (try to) make use of various FRP interfaces built on top of them for something more "Haskelly", although FRP is still evolving
10:28:29 <Tekmo> `foldr` still runs in constant space
10:28:31 <skypers> geekosaur: I see
10:28:33 <skypers> I don’t like Qt…
10:28:48 <skypers> geekosaur: do you think it’s simple to design GUI interfaces in FPL?
10:28:58 <geekosaur> the Qt bindings exist but I don't think they've been updated and last I heard they didn't play well with recent ghc or recent Qt
10:29:09 <geekosaur> which is why I didn't mention them
10:29:23 <deech> skypers: Heinrich Apfelmus just released a web-based FRP GUI library. http://apfelmus.nfshost.com/blog/2013/09/07-threepenny-gui-0-3.html
10:30:13 <skypers> ok, I see
10:30:14 <ParaSa1lin> o hey, Tekmo, so using the Fold on a strict "reducing" function would be bad idea?
10:30:15 <skypers> but hm I meant
10:30:24 <geekosaur> skypers, you can program wx or gtk or opengl pretty much the same way you can in other languages, although that's double-edged because it feels like you're forcing haskell to be a procedural language. FRP is more functional-like, but as I said is still evolving
10:30:32 <skypers> is GUI development compatible with FPL approach?
10:31:02 <skypers> geekosaur: yeah, I’m writing stuff in Haskell and OpenGL
10:31:05 <wereSheep> I installed a package with 'cabal install'. I don't want it anymore, how do I get rid of it?
10:31:10 <mm_freak_> skypers: the mistake many people make is to have a big "GUI" box to put everything into, but there are many different kinds of GUIs and there are different abstractions to capture them
10:31:13 <skypers> cabal remove wereSheep
10:31:20 <skypers> ah
10:31:21 <skypers> no
10:31:26 <skypers> ghc-pkg i think
10:31:31 <skypers> ghc-pkg remove
10:31:35 <skypers> or something like that
10:31:45 <skypers> 19:30 < mm_freak_> skypers: the mistake many people make is to have a big "GUI" box to put everything into, but there are many different kinds of GUIs and there are different abstractions to capture them
10:31:45 <mm_freak_> wereSheep: you can unregister it using ghc-pkg, but that doesn't remove the installed files
10:31:50 <skypers> so fraking true.
10:31:52 <geekosaur> how "easy" it is depends on how familiar you are with the underlying toolkit (for the lower level ones) and how well you do with monadic programming (low level) or whatever methodology your chosen FRP stack uses
10:31:55 <skypers> that’s why I don’t like Qt
10:32:02 <wereSheep> so.. rm -rf ~/.ghc then?
10:32:17 <skypers> it breaks C++’s std things
10:32:31 <skypers> with all those shits like QString and so on
10:32:31 <mm_freak_> skypers: fundamentally there is little difference between Qt, GTK+ and wx
10:32:45 <mm_freak_> skypers: "fundamentally" as in "abstraction-wise"
10:32:46 <skypers> mm_freak_: you mean, technically?
10:32:49 <skypers> I see
10:32:57 <wereSheep> and ~/.cabal for good measure as well...
10:33:02 <Tekmo> ParaSa1lin: What example did you have in mind?
10:33:11 <geekosaur> they all do pretty much the same thing and their high level behavior is similar. implementation details differ of course
10:33:22 <mm_freak_> skypers: currently the best abstraction for GUIs we know is FRP
10:33:48 <jmcarthur> that's a pretty strong claim for frp
10:33:52 <skypers> FRP stands for… what?
10:34:00 <mm_freak_> skypers: Functional Reactive Programming
10:34:05 <ParaSa1lin> Tekmo, like summation, though i havent looked at how you define that Fold
10:34:21 <jmcarthur> i would s/best abstraction/abstraction with the most potential/
10:34:28 <aleator> mm_freak_: Can you put FRP in a nutshell for me?
10:34:35 <mm_freak_> skypers: FRP allows you to express GUIs declaratively, no text field updates, no event handlers, etc.
10:34:39 <ParaSa1lin> L.sum would not be constant space, right?
10:35:21 <Tekmo> ParaSa1lin: There is a `sum` fold defined as: `sum = Fold (+) 0 id`
10:35:21 <skypers> mm_freak_: I wonder how it works
10:35:29 <Tekmo> ParaSa1lin: Note that you don't need to enforce strictness in the definition
10:35:30 <skypers> sounds great to get rid of event handlers
10:35:45 <Tekmo> ParaSa1lin: The `fold` function takes care of keeping the accumulator WHNF strict for you
10:35:59 <Tekmo> ParaSa1lin: I know that it doesn't look like that because it uses `foldr`, but it actually does
10:36:17 <skypers> mm_freak_: does FRP stand for “Functional Reactive Programing”?
10:36:24 <Tekmo> ParaSa1lin: It's a trick recommended to me by several people and also the same trick that `Data.Foldable` uses for `foldl'`
10:36:34 <Tekmo> skypers: Yes
10:36:38 <ParaSa1lin> Tekmo, yeah im having trouble seeing that
10:36:39 <mm_freak_> skypers: you capture GUI elements as time-varying values and treat them like all other first class values
10:36:48 <Tekmo> ParaSa1lin: Yeah, it was hard for me to understand, too
10:37:07 <mm_freak_> skypers: then you have events, which denotationally are discrete points in time possibly with a value attached to each point
10:37:15 <jmcarthur> aleator, skypers: in FRP, you compose time-dependent values. that's the nutshell explanation
10:37:26 <Tekmo> ParaSa1lin: Really you just have to work through it slowly in order for it to click
10:37:31 <skypers> I see
10:37:38 <jmcarthur> aleator: this is as opposed to stuff like imperative-style callbacks, etc.
10:37:43 <ParaSa1lin> Tekmo, im thinking about doing an applicative xml pull parser for pipes
10:37:45 <mm_freak_> skypers: but explanations don't really help much…  you should really just try it out
10:37:53 <skypers> yeah
10:37:56 <Tekmo> ParaSa1lin: Cool!
10:38:00 <skypers> just another question
10:38:16 <Tekmo> ParaSa1lin: So what was the user-facing API you had in mind?
10:38:32 <skypers> I live in France and Haskell is not really spread across companies
10:38:44 <skypers> what’s about in america / england / wherever?
10:38:50 <ParaSa1lin> Tekmo, i was thinking about making combinator operators similar to xpath symbols
10:38:53 <skypers> I mean in industry
10:38:57 <danilo2> Could somebody tell me please, what can Arrows in Haskell do, which Monads cannot? I 've read some Arrow tutorials and everything so far could be made simply using some functions and monads. Is it something more than a "syntactic sugar"? :)
10:39:07 <skypers> I’d love getting wired to write haskell programs
10:39:38 <jmcarthur> danilo2: it's the other way around. monads can do things arrows cannot
10:39:40 <ParaSa1lin> Tekmo, similar to what hxt does, but not insane like hxt
10:39:58 <Tekmo> I'm still new to xml, so give me a second to Google these terms :)
10:40:25 <jmcarthur> danilo2: monads can determine what future effects to perform based on past results. arrows give you a more static program structure.
10:40:26 <danilo2> jmcarthur: according to wiki (http://www.haskell.org/haskellwiki/Arrow): "They can do everything monads can do, and more"
10:40:44 <Tekmo> ParaSa1lin: So my understanding is that an xpath is like a way to navigate an XML structure
10:40:53 <geekosaur> true or false depending on how you look at things
10:40:54 <ParaSa1lin> Tekmo, you're academic?
10:40:57 <jmcarthur> danilo2: that's either wrong or looking at it dually
10:41:21 <Tekmo> ParaSa1lin: I'm a grad student in bioinformatics
10:41:45 <ParaSa1lin> Tekmo, huh, im in industry bioinformatics
10:41:49 <Tekmo> ParaSa1lin: Really?
10:41:53 <Tekmo> ParaSa1lin: What do you work on?
10:42:05 <ParaSa1lin> Tekmo, so i deal with xml crunching on occasion
10:42:07 <Tekmo> :)
10:42:16 <Tekmo> Most of the crunching I do is of CSVs
10:42:28 <jmcarthur> danilo2: there are more instances of Arrow possible than of Monad, which is sometimes what people mean when they say one type class is more powerful than another. however, if you have only an instance of Monad for type A and only an instance of Arrow for type B, you can do more with A then with B
10:42:35 <danilo2> jmcarthur: that's strange - I've found this sentrence in few places. Like: (http://www.haskell.org/arrows/) "They serve much the same purpose as monads [...] but are more general", or: "Arrows, or Freyd-categories, are a generalization of Monads."
10:42:35 <mm_freak_> danilo2: my favorite arrow is (and has to be) this one:  newtype Auto m a b = Auto (a -> m (b, Auto m a b))
10:42:45 <elliott> danilo2: "general" means nothing
10:42:49 <jmcarthur> danilo2: those are correct. arrows are a generalization of monads
10:42:55 <elliott> power is about consumer vs. producer
10:42:59 <mm_freak_> danilo2: it allows you to compose locally stateful components without one giant StateT of all the individual states
10:42:59 <ParaSa1lin> Tekerson, yeah i work for a company that does lots of random client projects, so it's something different every time
10:43:01 <jmcarthur> danilo2: "more general" means "there are more things which are arrows"
10:43:01 <elliott> let's say you are producing instances for a type
10:43:13 <ParaSa1lin> Tekmo, ups
10:43:14 <elliott> then Arrow is more general than Monad, you can instantiate Arrow when maybe you couldn't Monad
10:43:20 <elliott> let's say you are using instances for a type
10:43:25 <elliott> then Monad is more powerful than Arrow, it lets you do more
10:43:35 <elliott> increase in power on one side is the same as a decrease on the other side
10:43:41 <ParaSa1lin> Tekmo, ncbi does a lot of databases in xml so unfortunately i have to work with xml
10:43:44 <Tekmo> ParaSa1lin: So you really want to study `pipes-parse` in this case
10:43:44 <elliott> therefore, "more general", "more powerful" etc. are all but meaningless
10:43:48 <mstksg> Tekmo: yes, xpath is similar to the idea of css selectors, if you've ever done any web development
10:43:56 <Tekmo> ParaSa1lin: I have
10:43:58 <elliott> I think this is one of the most important things to understand about abstraction
10:44:00 <mstksg> only they are more powerful in that they can be numbered, etc.
10:44:00 <mm_freak_> danilo2: this type is not inherently non-monadic though…  it's actually possible to make it a monad, but the Monad instance would be practically useless
10:44:01 <Tekmo> Oops
10:44:04 <Tekmo> mstksg: I have
10:44:14 <elliott> the more fancy things you can do with it -- the harder it will be to provide and the less general it will be
10:44:18 <merijn> They're just tree traversals...
10:44:23 <Tekmo> ParaSa1lin: So the trick with `pipes` is very similar to the xpath you are proposing
10:44:23 <elliott> the simpler and easier to provide it is -- the less useful it will be to use
10:44:28 <danilo2> jmcarthur, mm_freak_, elliot: Ok, thank you. I need to read more about them and learn them more deeply to see the differences more clear.
10:44:32 <Tekmo> ParaSa1lin: You model your XML file as an effectful data structure
10:44:34 <jmcarthur> elliott: conventionally, at least, "more general" means more instances are possible, and "more powerful" means more power is available from each instance.
10:44:39 <ClaudiusMaximus> monads can do more than arrows (eg dynamic branching), but you can do more with arrows than monads (eg static analysis) - as far as i understand it
10:44:42 <jmcarthur> although it's not used 100% consistently
10:44:48 <elliott> jmcarthur: I would be happy if people actually stuck to that :)
10:44:53 <elliott> but in my experience, they don't
10:44:53 <ParaSa1lin> Tekmo, you mean generate a dom?
10:45:00 <Tekmo> ParaSa1lin: Yeah, sort of
10:45:03 <elliott> and also they seemingly tend not to realise that "more general" = "less powerful"
10:45:09 <elliott> and "more powerful" = "less general"
10:45:16 <Tekmo> ParaSa1lin: The idea is that you generate a DOM that only lets you traverse the file linearly
10:45:16 <jmcarthur> yeah
10:45:25 <ahill-89> Tekmo: It almost sound like you're describing a SAX parser.
10:45:31 <sshack> elliott: Unless you're referring to turing machines.
10:45:34 <Tekmo> ahill-89: Let me google that.  Hold on
10:45:41 <ParaSa1lin> Tekmo, i was going to do it sax style where i would make a Producer of "Events"
10:45:49 <jmcarthur> maybe if we s/powerful/specialized/ the relationship with generality is more clear
10:45:51 <Tekmo> ParaSa1lin: Yeah, that's the right idea
10:45:56 <mm_freak_> danilo2: as an exercise write the following state monad type:  data State s a = State { usesPut :: Bool, runState :: s -> (s, a) }
10:46:07 <Tekmo> ParaSa1lin: See `pipes-parse`, which also shows you how to use `FreeT` to group or sub-divide streams of events
10:46:15 <Tekmo> ParaSa1lin: In case you have a nested data structure
10:46:21 <ParaSa1lin> Tekmo, hm i will
10:46:25 <mm_freak_> danilo2: the 'usesPut' flag should be True, if the computation uses 'put'
10:46:35 <mm_freak_> usesPut (put 15) = True
10:46:54 <mm_freak_> usesPut (return "blah") = False
10:46:55 <Tekmo> ParaSa1lin: You should also study Oliver Charles' `pipes-tar` which uses the same idea to group a TAR stream into files
10:47:08 <Tekmo> https://github.com/ocharles/pipes-tar
10:47:42 <ocharles> ParaSa1lin: that's http://github.com/ocharles/pipes-tar
10:47:44 <ocharles> :)
10:47:56 <Tekmo> Hey, Oliver!
10:48:03 <ocharles> ahoi! congrats on the release :)
10:48:12 <danilo2> elliott,jmcarthur : than you for the clarification
10:48:13 <Tekmo> ahill-89: Yes, it's exactly like SAX
10:48:26 <jmcarthur> elliott: more general doesn't *always* mean less powerful though. e.g. indexed monads vs. monads
10:48:27 <danilo2> mm_freak_: Ok - I'll try it
10:48:28 <danilo2> :)
10:48:34 <ocharles> Tekmo: nixos stuff submitted, so should all be in nix soon
10:48:54 <elliott> jmcarthur: yeah, I think it depends exactly how you define "provide" vs. "use" and stuff in context
10:49:10 <jmcarthur> yeah
10:49:40 <mm_freak_> danilo2: actually you can even write a simpler one:  newtype Reader e a = Reader { usesEnv :: Bool, runReader :: e -> a }
10:50:00 <mm_freak_> usesEnv should be true, if the function refers to its environment
10:50:18 <mm_freak_> try to write a Monad instance for this one
10:50:35 <hiptobecubic> has anyone used haskell to read/show a webcam?
10:50:58 <hiptobecubic> let me rephrase, has anyone here done that? Or can suggest where to start looking for it
10:51:23 <zomg> hiptobecubic: might be easiest if you can find a library to interface with the OS's video capture mechanism
10:51:40 <hiptobecubic> v4l in linux, i suppose
10:52:07 <ocharles> hiptobecubic: there was a application for using haskell to correct your posture posted to r/haskell at some point
10:52:11 <zomg> Yeah don't really know about how it works in *nix but at least on Windows there's an OS level feature for camera feeds I'm pretty certain.
10:52:34 <hiptobecubic> ocharles, oh... right. i remember seeing that awhile ago. thanks i'll look for it
10:52:39 <danilo2> mm_freak_ - I want to know If i understand correclty - your example with custom State s a (I'll stick with state, because I know better how state works in Haskell whan reader) - should be my custom monad?
10:52:43 <hiptobecubic> i found this as well http://hackage.haskell.org/packages/archive/bindings-linux-videodev2/0.1/doc/html/Bindings-Linux-VideoDev2.html
10:58:46 <ParaSa1lin> Tekmo, ah yes i see foldl' in Foldable is the same as your fold, but i still dont get it
10:59:07 <ReinH> Tekmo: hai
10:59:19 <Tekmo> ReinH: Hi!
10:59:46 <Tekmo> ParaSa1lin: Like all problems, start with a simple example, like a list of length 2
11:00:00 <Tekmo> ParaSa1lin: So let's imagine that we are folding the list [1, 2]
11:00:13 <ParaSa1lin> ok ill try to work it out on paper
11:00:31 <Tekmo> ParaSa1lin: `foldr cons nil xs` basically replaces all (:)'s with cons and all []'s with nil
11:00:40 <shachaf> First, understand an example with a list of length 0. Then, assume that you understand an example with a list of length n, and use it to understand an example with a list of length n+1.
11:01:01 <Tekmo> ParaSa1lin: So if we expand out [1, 2], we get (:) 1 ((:) 2 [])
11:01:14 <Tekmo> ParaSa1lin: So if we run `foldr cons nil` on that list we get:
11:01:19 <Tekmo> ParaSa1lin: cons 1 (cons 2 nil)
11:01:30 <Tekmo> ParaSa1lin: Now let's look at the specific `cons` and `nil` that this `foldr` is using
11:01:33 <ParaSa1lin> Tekmo, right, we want lazy for (:), but i dont understand how it would be constant space for (+)
11:02:07 <Tekmo> ParaSa1lin: So in this case the `cons` is our `step'` function and `nil` is `id
11:02:14 <Tekmo> ParaSa1lin: So we get:
11:02:17 <mm_freak_> danilo2: yes
11:02:28 <mm_freak_> danilo2: the exercise is:  write a Monad instance for that type
11:02:31 <Tekmo> ParaSa1lin: step' 1 (step' 2 id)
11:02:39 <mm_freak_> danilo2: you will fail, but i want you to see why =)
11:03:02 <Tekmo> Now, technically the entire thing is: `foldr step' id [1, 2] begin`, so let's also insert the `begin` at the end
11:03:16 <Tekmo> ParaSa1lin: step' 1 (step' 2 id) begin
11:03:31 <Tekmo> ParaSa1lin: Now let's expando ut the definition of `step'`
11:03:40 <Tekmo> ParaSa1lin: step' x k z = k $! step z x
11:03:52 <Tekmo> ParaSa1lin: In the context of our list, that first `step'` will expand out to
11:04:03 <Tekmo> x = 1
11:04:12 <Tekmo> k = step' 2 id
11:04:14 <Tekmo> z = begin
11:04:29 <wereSheep> pressing ^C while in `cabal repl` and a :main is running kills the repl instead of interrupting the actual application. Is that intentional?
11:04:31 <Tekmo> k $! step z x = step' 2 id $! step begin 1
11:04:54 <Tekmo> ParaSa1lin: Now we expand the next `step'`
11:05:00 <Tekmo> x = 2
11:05:03 <Tekmo> k = id
11:05:06 <Tekmo> z = step begin 1
11:05:14 <danilo2> mm_frak_ - ok but how it should be used? I understand that you want to see something like: runState (\x -> do put 15) should return the usesPut somehow? or where this usesPut should be used? (I'm sorry for this maybe silly queston, but I do not completely see the usage you want)
11:06:01 <Tekmo> k $! step z x = id $! step (step begin 1) 2
11:06:18 <Tekmo> Notice that `step begin 1` was strictly evaluated by the previous step
11:06:30 <Tekmo> And now once we apply `step ... 2` to that we strictly evaluate it again
11:06:47 <Tekmo> And in this case we're done
11:06:56 <mm_freak_> danilo2: the type of usesPut is:  usesPut :: State s a -> Bool
11:06:58 <inkjetunito> a-ha. the downside of Haskell must be long compile times :p
11:07:02 <danilo2> mm_freak_: you've written as an example "usesPut (return "blah") = False" - but the types does not match - coudl you please explain the usage of such custom monad I should write? :)
11:07:20 <Tekmo> ParaSa1lin: So the end result is we compute `step (step begin 1) 2`, strictly evaluating each sub-result along the way
11:07:20 <danilo2> mm_freak_: ah ok :)
11:07:51 <mm_freak_> danilo2: its usage is pretty much the same as regular state monads, but with one additional feature:  you can ask without running the computation whether it changes its state long the way
11:07:57 <mm_freak_> (potentially)
11:10:57 <mkramer> what does O(n\c)/ mean, e.g. in the documentation for Data.ByteString.Lazy#drop
11:11:33 <mkramer> That means it's n in the number of bytes to drop?
11:12:22 <mkramer> or that it might need to fill a new buffer chunk?
11:12:27 <kanishka> What a typical circumstance you find yourself using  (Data.Functor's) <$ ?
11:12:28 <monochrom> it is O(n/c). n is number of bytes. c is number of bytes per chunk, usually 64KB
11:12:47 <hpaste> enthropy pasted “is there a par mapM_?” at http://lpaste.net/92745
11:12:53 <monochrom> "O(n\c)/" is a typo
11:12:57 <fryguybob> O(n\c)/ is when this guy \o/ gets stuck in O(n)
11:13:01 <danilo2> mm_freak_: Mybe I am wrong, but this is not possible, because each computaton depends on the previous ones result, so we cannot execute something "in the middle", without exeuting the whole code
11:13:02 <hpc> kanishka: i would expect mostly in parsers
11:13:26 <mkramer> oh, so it's warning me that it filling buffer chunks is amortized over this operation
11:13:39 <monochrom> I don't know about that
11:13:42 <mm_freak_> danilo2: exactly
11:13:50 <mm_freak_> danilo2: and that's where arrows come in =)
11:13:59 <monochrom> I don't think any amount of big-O or n/c is enough to say either way
11:14:11 <mm_freak_> danilo2: the usesPut flag is a static piece of information
11:14:31 <danilo2> mm_freak_ - great, so we can do with arrows **everything**, as with monads? Or does they have some downsides?
11:14:42 <monochrom> but n/c is written because some people may refuse to take c as constant
11:15:04 <mm_freak_> danilo2: the arrow interface is less powerful, meaning that it is more general
11:15:16 <mm_freak_> danilo2: just like Functor is less powerful than Monad, but more general
11:15:34 <staafl> mm_freak_, define "powerful"
11:15:35 <monochrom> but it's amazing how humans can "read between the lines" where there is nothing to read, and make things up
11:15:41 <trinithis> Say I have the type (a b). I know (a) is a higher kinded type, but is there a specific name for this type of type?
11:15:51 <monochrom> today is probably a prime-numbered day
11:16:04 <mm_freak_> danilo2: next exercise…  you know that you can't write a Monad instance…  try to write an Applicative instance
11:16:10 <mm_freak_> staafl: less expressive
11:16:19 <geekosaur> heh
11:16:28 <staafl> mm_freak_, that's an interesting definition
11:16:32 <danilo2> mm_freak_: Ok, I'm simply searching for an example where arrows can do something monads cannot (like the example with the satate - I would love to see its arrows implementation)
11:16:48 <mm_freak_> danilo2: we're getting there
11:16:55 <mm_freak_> danilo2: write the Applicative instance
11:17:37 <danilo2> mm_freak_: heh :D Ok I'll try. I know it would be possible (or I suppose so), but give me a moment :)
11:19:36 <kanishka> hpc: can't imagine the example, but I'll keep it in back of my mind
11:20:01 <ParaSa1lin> Tekmo, hm, this seems to be good explanation http://stackoverflow.com/questions/6172004/writing-foldl-using-foldr
11:20:23 <Tekmo> ParaSa1lin: Yeah, that one is good
11:21:44 <danilo2> mm_freak_: Do I understand good the usage of such instane? Do you want to see    usesPut(pure () <$> put <*> pure 15) to return True?
11:23:03 <mm_freak_> danilo2: does it use 'put'?
11:23:28 <mm_freak_> danilo2: (i'll ignore the type error)
11:23:51 <danilo2> mm_freak_: Yeah, I see there is a type error. Wait a minute :)
11:25:20 <Tekmo> danilo2: Well, think about some simple equations that this must satisfy
11:25:27 <Tekmo> danilo2: Obviously: usesPut (put x) = True
11:25:38 <Tekmo> danilo2: Similarly: usesPut (pure x) = False
11:25:54 <Tekmo> danilo2: And: usesPut get = False
11:26:14 <Tekmo> danilo2: So now that we have the base cases, let's consider the recursive case
11:26:18 <tpsinnem> is there a package that might implement various basic dependent types on top of the singletons package or some such?
11:26:25 <Tekmo> danilo2: usesPut (f <*> x) = ?
11:26:29 <tpsinnem> like 'Vect' etc
11:28:14 <hpaste> enthropy annotated “is there a par mapM_?” with “is there a par mapM_? (annotation)” at http://lpaste.net/92745#a92746
11:28:30 <danilo2> Tekmo: Ok usesPut (f <*> x) = usesPut f || usesPut x , BUT the problem for me right now is other - how we would use the "put" in applicative style - will it be something like "pure () <$ put 15" ?
11:28:50 <mm_freak_> danilo2: ignore that problem for now
11:29:40 <mm_freak_> let's have a working Applicative, then we will explore its (quite limited) expressive power
11:29:49 <danilo2> mm_freak_, Tekmo, ok, but - how would you define "usesPut (put x) = True" - put is a function, we cannot pattern match over function as far as I know
11:30:09 <Tekmo> danilo2: You assume that put is a function, but it might not be
11:30:19 <Tekmo> I mean, `put` might be a function
11:30:22 <mm_freak_> danilo2: put s = State True (\_ -> (s, ()))
11:30:23 <Tekmo> But, `put x` might not be
11:30:42 <nitin2> Does anyone know a Haskell introduction based on algebra?
11:30:55 <danilo2> mm_freak_, Tekmo: Ah ok, brb
11:31:04 <mm_freak_> danilo2: remember that usesPut is not a function you write…  it's a field of the State constructor
11:31:26 <edvo> In http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ it says that the numbers of values of type `a -> b` is b^a. This seems plausible I have some problems when `a ~ Void`. For instance the number of values of type `Void -> Bool` should be 2^0 = 1. But what is this only function of this type then?
11:32:26 <Tekmo> absurd
11:32:34 <Tekmo> absurd :: Void -> a
11:32:46 <danilo2> mm_freak_: I know :) brb
11:33:10 <edvo> I can see at least two functions: const True and const False. But I guess this is not meant here.
11:33:22 <erisco> :t iterate
11:33:22 <mm_freak_> edvo: it's the empty function
11:33:23 <lambdabot> (a -> a) -> a -> [a]
11:33:36 <edvo> Mathematically it would be an empty set
11:33:37 <mm_freak_> edvo: the empty function is such that you can't actually call it
11:33:47 <mm_freak_> because you can't construct its argument
11:33:58 <edvo> I see
11:34:00 <mm_freak_> note that we pretend that bottom does not exist
11:34:21 <monochrom> yes, the empty set represents the unique function from Void to Bool
11:34:43 <edvo> So const True and const False are actually the same in this case, because they have the same output for each possible argument
11:34:52 <edvo> makes sense, thank you
11:34:58 <mm_freak_> edvo: yeah, you could look at it that way
11:35:52 <stolaruk> I just finished reading LYAH and I'm thinking about writing a text adventure game. Any advice on how I might handle state?
11:36:25 <ocharles> stolaruk: two suggestions - one is "just thread it!", and the other is "use a State monad".
11:36:26 <mm_freak_> stolaruk: as a haskell beginner you should probably just use recursion
11:37:03 <ocharles> stolaruk: in the first part, i mostly mean that you return whatever values some other function needs
11:37:06 <ocharles> and pass it all explictly
11:37:38 <mm_freak_> stolaruk: to put it differently, model your game as a function
11:37:48 <stolaruk> mm_freak_: I don't understand, how can recursion be used to handle state
11:38:07 <mm_freak_> stolaruk: f currentState = … f newState …
11:38:09 <stolaruk> ocharles: so like pass around a World thing or something like that
11:38:09 <leroux> stolaruk: You pass the state around.
11:38:13 <aristid> Tekmo: earlier today, xplat mentioned to me that he doesn't like putback based parsing, which the current pipes-parse is also an example of, he would prefer something like peek/consume. did you consider that alternative design approach when designing pipes-parse?
11:38:13 <Tekmo> stolaruk: Simple example is a function that prints an increasing list of numbers
11:38:30 <Tekmo> stolaruk: printAllTheThings n = print n >> printAllTheThings (n + 1)
11:38:41 <ocharles> stolaruk: not the whole world, just whatever things need
11:38:44 <ion> Generalized: succ n
11:38:52 <stolaruk> ok
11:39:02 <Tekmo> aristid: What is the semantic difference between those two alternatives?
11:39:11 <ion> Safer: [n..]
11:39:24 <mm_freak_> stolaruk: a state "change" really just denotes calling a function with a different argument
11:39:30 <aristid> Tekmo: well for example it is possible to put back thing that were never in the input.
11:39:43 <monochrom> stolaruk: do you find my http://lpaste.net/52480 useful?
11:39:46 <Tekmo> aristid: I consider that fine
11:40:04 <Tekmo> aristid: `pipes-parse` does not assign a meaning to the producer stored in the `StateT`
11:40:15 <stolaruk> monochrom: I'm checking it out now
11:40:15 <bennofs> Is it possible / a good idea to use netwire for GUIs?
11:40:56 <mm_freak_> bennofs: what kind of GUI?
11:41:01 <aristid> Tekmo: hum i'm not the best guy to argue the merits of non-putback parsing, i'm just curious
11:41:14 <Tekmo> aristid: Besides, all the pushback stuff is just an implementation aid on the road to implementing the truly useful things like the high-level functions of `Producer`s
11:41:45 <Tekmo> aristid: Things like `groupBy` and `splitOn` are the true high-level interface
11:42:36 <stolaruk> monochrom: Yes I see, that's cool!
11:43:09 <bennofs> mm_freak_: I was thinking about writting a QML-based GUI (QML is a language to write Qt applications).
11:43:13 <aristid> Tekmo: and those don't expose any StateT stuff but are just functions of Producers anyways? fair enough
11:43:19 <Tekmo> aristid: Right
11:43:34 <Tekmo> aristid: StateT is just an implementer's concern on the way to implementing those functions
11:43:36 <mm_freak_> bennofs: the current major version of netwire is unsuitable for widget-based UIs…  you'll have to wait for netwire 5
11:43:47 <aristid> Tekmo: hum possibly stupid question... might functions of Consumers also be workable?
11:44:08 <Tekmo> aristid: I think so
11:44:12 <dissipate_> haskell noob here. is haskell considered good for systems programming?
11:44:25 <aristid> Tekmo: but functions of Producer make for the more natural API interface?
11:44:27 <mm_freak_> bennofs: it's mostly reader for use though, so you can get the repository and experiment with it:  http://hub.darcs.net/ertes/netwire
11:44:29 <jmcarthur> dissipate_: define systems programming
11:44:40 <Tekmo> aristid: Yeah, I prefer to model things as data structures rather than folds
11:44:45 <mm_freak_> reader?
11:44:48 <mm_freak_> ready
11:44:49 <aristid> Tekmo: well i suppose in iteratee land everything is done with functions of consumers, so it must be possible
11:45:00 <mm_freak_> i've been programming haskell for too long…
11:45:10 <Tekmo> aristid: Also, the emphasis on functions of `Producer`s is going to be more natural for people coming from a language with generators
11:45:11 <dissipate_> jmcarthur, something that includes low level memory management and hardware interrupts and IO
11:45:15 <aristid> mm_freak_: you're the guy who actually likes iteratees, right? :P
11:45:40 <luite> is it possible to build the test suite program with cabal, without running it?
11:45:58 <mm_freak_> aristid: i wouldn't use them, but i like their elegance
11:46:04 <jmcarthur> dissipate_: you can use haskell DSLs to generate C for stuff like that, but running a ghc-generated binary in the environment is likely to be not worth that hassle
11:46:13 <jmcarthur> *in that environment
11:46:17 <aristid> mm_freak_: what would you actually use then? oO
11:46:34 <mm_freak_> aristid: pipes
11:46:46 <dissipate_> jmcarthur, i see. thanks for the info.
11:46:50 <aristid> mm_freak_: good answer ;)
11:46:54 <mbrock> dissipate_: check out House, it's more of a research project but you might find it interesting: http://programatica.cs.pdx.edu/House/
11:47:01 <ion> dissipate: I’m going to use Rust for a project on an Arm system for which Haskell might sadly not be appropriate.
11:47:02 <aristid> mm_freak_: i suppose that's more out of ecosystem concerns?
11:47:22 <dissipate_> ion, so Rust is good for systems programming?
11:47:29 <aristid> ion: does rust have ARM support already?
11:47:34 <mm_freak_> aristid: not really
11:47:43 <ion> aristid: Yes
11:47:45 <ion> :-P
11:47:50 <ion> At least it worksforme™
11:47:50 <mm_freak_> ecosystemwise the enumerator library is still superior
11:48:09 <aristid> it wouldn't be good for prices of stuff i suppose but i kinda want intel to win in the mobile space so i don't need to worry about compilers supporting non-x86 :>
11:48:09 <mm_freak_> and conduit even more
11:48:47 <aristid> mm_freak_: ok so you like iteratees but prefer pipes out of non-ecosystem reasons. which are those reasons?
11:49:02 <mm_freak_> aristid: elegance and speed =)
11:49:09 <elliott> conduit surely beats enumerator for ecosystem
11:49:19 <mm_freak_> although iteratees probably outperform pipes
11:49:48 <dissipate_> ion, is Rust a replacement for C or C++?
11:50:01 <Hannibal_Smith> Non performance critical C++
11:50:19 <ion> dissipate: It’s a lower-level language that provides more safety guarantees than, say, C or C++, and easy IPC between lightweight, supervised threads inspired by Erlang. There’s per-thread garbage collection and you can choose avoid GC altogether where appropriate. Those are the main reasons why i’m going to use it.
11:50:22 * aristid hopes Tekmo gets pipes to a state where snoyman is convinced to change conduit to be a small wrapper around pipes :D
11:50:44 <dissipate_> mbrock, thanks for that link. i'll check that out.
11:51:04 <stolaruk> Ppl are talking a lot about Rust
11:51:10 <dissipate_> ion, how does it compare to golang?
11:51:35 <mm_freak_> aristid: add predefined combinators for yielding and resuming
11:51:50 <mm_freak_> that's michael's main complaint about pipes
11:51:59 <sclv> golang and rust are v. different approaches
11:52:15 <aristid> mm_freak_: the "exception handling" concerns are already out of the way?
11:52:22 <sclv> go is about making c more modern and syntactically lightweight + having concurrency
11:52:25 <Hannibal_Smith> Haskell solves concurrency problem, much better than Go, or Rust
11:52:25 <ion> dissipate: For one, AFAIU Rust provides more safety guarantees.
11:52:37 <merijn> aristid: I dunno what they were, but the new pipes-safe has new and nicer exception handling
11:52:47 <sclv> rust is really about memory safety and low level systems design
11:52:51 <aristid> merijn: without masking exceptions!
11:52:54 <Redz> if i want something like
11:52:54 <Redz> data TilList a b = TlNode a (TilList a b) | TlEnd b
11:52:54 <Redz> what should i look for?
11:53:04 <erisco> monochrom, I suppose what I meant was
11:53:22 <sclv> the 'aim' of rust is to write code one would reach for C++ for more, while the 'aim' of go is to write code one would reach for C for, in my opinion
11:53:23 <dissipate_> ion, ever try Racket?
11:53:25 <edvo> pipes-safe has a very nice interface, but does not provide prompt finalization in all cases, as far as i know
11:53:27 <merijn> aristid: Right not it masks exceptions, except in await/yield, so you can still get interrupted, just not in the middle of something
11:53:29 * hackagebot hole 0.1 - Higher kinded type removal  http://hackage.haskell.org/package/hole-0.1 (ThomasEding)
11:53:31 * hackagebot hole 0.1.1 - Higher kinded type removal  http://hackage.haskell.org/package/hole-0.1.1 (ThomasEding)
11:53:31 <mm_freak_> aristid: not sure, haven't tried the latest pipes-safe yet
11:53:48 <danilo2> mm_freak_: Ok,could you give me a hint what would be the equivalent of fmap over State s a ?
11:53:49 <ion> dissipate: Not so far.
11:53:54 <NemesisD> i'm playing around a bit with benchmarking and sparks. what would be the best way to parallelize a naive, recursive fibonnaci solver?
11:53:54 <mm_freak_> but in any case you can always put a ResourceT below proxies
11:54:03 <erisco> monochrom, say I make a map. in a mutable world, I can update the thing being mapped and all is well. however, here, I need to update the thing, remove the old thing from the map, and put in the new one
11:54:08 <mm_freak_> NemesisD: 'par'
11:54:15 <dissipate_> ion, http://docs.racket-lang.org/more/
11:54:23 <NemesisD> in my testing using par and pseq i see a lot of fizzled sparks and it runs twice as slow as the non parallelized one
11:54:38 <mm_freak_> danilo2: fmap f (State ch g) = State ch (\s -> …)
11:54:59 <edvo> mm_freak_: i have not tried, but i am not sure if this will help. the main problem is premature termination
11:55:10 <aristid> merijn: oh i thought it doesn't mask anymore? i guess i must have misread
11:55:18 <mm_freak_> NemesisD: make sure you use sharing
11:55:34 <mm_freak_> NemesisD: fib n = let x = fib (n - 1); y = fib (n - 2) in x `par` y `pseq` x + y
11:56:19 <mm_freak_> NemesisD: as a side note you can't parallelize the memoizing fib function
11:56:33 <hpaste> NemesisD pasted “Naive fib parallel” at http://lpaste.net/92747
11:57:33 <mm_freak_> NemesisD: that should work
11:57:44 <supki> Redz: that looks like Free ((,) a) b, see free package
11:58:22 <NemesisD> mm_freak_: yeah it works. compiled with ghc --make -O2 -threaded -rtsopts, running with +RTS -N4 it seems about twice as slow for the fib of 40 than the sequential version
11:58:55 <dwcook> Is it possible to limit stack space so I don't accidentally freeze up my whole system due to a programming error?
11:59:16 <elliott> it comes pre-limited
11:59:17 <geekosaur> stack is rarely the problem, it's already pretty limited by default
11:59:28 <geekosaur> perhaps you want to limit the heap?
11:59:33 <merijn> aristid: Oh wait, it doesn't use mask, no. I misremembered
11:59:36 <dwcook> Hmm, well I accidentally let a bunch of thunks build up and it froze up my system for a bit
11:59:46 <geekosaur> (remember haskell does not work like other languages, stack doesn't do what you think)
11:59:49 <merijn> aristid: Relevant quote: "Note that the MonadCatch instance for Proxy provides weaker versions of mask and uninterruptibleMask that do not completely prevent asynchronous exceptions. Instead, they provide a weaker guarantee that asynchronous exceptions will only occur during awaits or yields and nowhere else."
11:59:53 <dwcook> Noted
12:00:08 <mm_freak_> NemesisD: can't confirm that
12:00:10 <dwcook> Basically, I applied modifyTVar a bunch of times without reading it, and I believe that is what caused it
12:00:28 <mm_freak_> NemesisD: needs 10.3 secs with one thread, 3.3 secs with four threads for me
12:00:39 <mm_freak_> 397% CPU utilization
12:01:29 <dwcook> Okay yay, using modifyTVar' relieves that
12:01:37 <Redz> supki: thank you, i'll take a look at.
12:02:14 <dwcook> Would accumulating a super huge Integer value would have a similar problem?
12:02:30 <aristid> merijn: so you were _effectively_ right, just not in the implementation?
12:02:56 <merijn> aristid: No, read carefully, that's the behaviour of explicitly using mask/uninterruptibleMask
12:03:04 <mm_freak_> NemesisD: see my annotation
12:03:11 <merijn> aristid: bracket, finally, et al. don't mask
12:03:11 <aristid> merijn: oh.
12:03:46 <identity> I've been forced to learn python for school, and after using haskell for so long it just feels .. thrown together, without the rigid type system
12:03:49 <merijn> Which is a much nicer API to work with
12:03:51 <NemesisD> mm_freak_: what's the significant difference there? using integers?
12:03:57 <mm_freak_> NemesisD: no, works for Int to
12:04:02 <monochrom> dwcook: if you want to limit, limit heap. (stack is already limited to 8MB.) +RTS -M1M -RTS  (1MB heap)
12:04:12 <mm_freak_> NemesisD: although unlikely the difference may be 'where' vs. 'let'
12:04:34 <dwcook> monochrom, that will prevent tons of thunks from building up?
12:04:35 * monochrom is declaring war at stack limits
12:04:49 <monochrom> that will abort your program
12:05:06 * monochrom is also declaring war at unlimited heap
12:05:06 <dwcook> I figured, but does that have to do with thunks?
12:05:15 <monochrom> yes
12:05:20 <dwcook> Okay, cool. Thanks.
12:05:45 <dwcook> What does the stack do, then?
12:05:51 <mm_freak_> NemesisD: works with 'where' as well for me
12:06:02 <geekosaur> it's a pattern match stack, not a call stack. thunks build up on the heap
12:06:13 <dwcook> Oh, I see.
12:06:28 <geekosaur> mostly
12:06:30 <mm_freak_> NemesisD: my concern was that your x and y may be polymorphic, but that's not actually possible
12:06:58 <mm_freak_> also the proper type signature is probably this:  fib :: Int -> Integer
12:07:13 <mm_freak_> it doubles the performance for me
12:07:15 <monochrom> when you do 1+(2+(3+(4+..., you build 1+(2+(3+(4+... on the heap. then you traverse it with the help of the stack (for bread crumbs)
12:07:17 <NemesisD> mm_freak_: your version runs in 21.66 seconds for me. 8.34 when typesig is Int -> Int
12:07:24 <geekosaur> procedural intuitions about stack vs. heap don't work so well in a non-strict language
12:07:52 <Targen> I just stumbled into something odd in lens-xml.  The signature for the (./) combinator is `Plated a => Traversal s t a a -> Traversal a a u v -> Traversal s t u v`, where each Traversal is universal in the Applicative: `type Traversal s t a b = Applicative f => (a -> f b) -> s -> f t`.  This restricts its usability as the combined traversals cannot have additional constraints!  Anyone run into this?
12:08:08 <monochrom> the same story goes for (...(1+2)+3)+4)+...
12:08:35 <danilo2> mm_freak_: I'm sorry that I'm making it so long, but I'm trying and testing around. I hope I'll finish it shortly :)
12:08:37 <mm_freak_> NemesisD: GHC 7.6.3 on i5
12:08:48 <mm_freak_> danilo2: take your time
12:08:50 <monochrom> therefore, both foldr(+) and foldl(+) use both O(n) heap and O(n) stack
12:08:58 <edvo> Ok I have tried. Using ResourceT in pipes also does not protect from premature termination and might miss prompt finalization (the same way that SafeT does)
12:09:12 <bjorkintosh> holy crap. when did this channel become so popular?
12:09:27 <bjorkintosh> there're 1172 characters here!
12:09:27 <Makoryu> Last week
12:09:29 <bjorkintosh> ah.
12:09:30 <Tekmo> edvo: The way you get prmopt finalization is to use `runSafeP`
12:09:42 <Taneb> bjorkintosh, it's been one of the largest channels on Freenode for a while now
12:09:55 <bjorkintosh> weird!
12:10:06 <Tekmo> edvo: Whenever you run a `SafeT` block any dropped finalizers get called
12:10:09 <erisco> we'll have to open #haskell-meta just so people can talk about how awesome #haskell is
12:10:11 <edvo> Tekmo: yes I know. thats why I was saying in all cases
12:10:18 <NemesisD> mm_freak_: if i'm using Int -> Int, it runs in 8.34s for me, If I swap out your pars for x + y, runs in 4.2s. compiled with --make -threaded -O2 -rtsopts, run with +RTS -N4, GHC 7.6.3, i5 2520M @ 2.5ghz
12:10:20 <Targen> Pure functional languages and ancient chat technology clearly go hand-in-hand.
12:10:31 <merijn> bjorkintosh: When I started coming here (I'm guessing 3-4 years ago?) there were already 660+ users at any time
12:10:36 <Taneb> Targen, I think the Python channel is larger :P
12:10:53 <edvo> Tekmo: simple code: runSafeT . runEffect $ for (each file) $ \f -> readFile f >-> P.take 1 >-> P.stdoutLn
12:10:56 <Targen> Taneb: That’s unfair!  Their community is huge. ;)
12:11:08 <edvo> when the file has more than one line it is closed at the very end
12:11:12 <Taneb> Targen, yeah, but out community is awesome
12:11:14 <Tekmo> edvo: Change that to:
12:11:24 <bjorkintosh> yeah the python channel is bigger, but that is because there are several 1000s more python programmers.
12:11:29 <bjorkintosh> but i think this is everyone.
12:11:30 <Tekmo> edvo: runEffect $ for (each file) $ \f -> runSafeP $ readFile ...
12:11:38 <mm_freak_> NemesisD: ah, you mean the non-sparked version vs. the sparked one
12:11:47 <bjorkintosh> hello everyone.
12:11:52 <mm_freak_> NemesisD: that's actually reasonable, because you're creating lots and lots of microsparks
12:12:06 <NemesisD> mm_freak_: so is the granularity too small/variable?
12:12:11 <Taneb> bjorkintosh, there are almost 13k subscribers to the haskell subreddit
12:12:16 <mm_freak_> NemesisD: it works much better, if you parallelize only to a certain level…  let me try
12:12:20 <bjorkintosh> whoa!
12:12:23 <donri> SafeT first!
12:12:27 <edvo> Tekmo: yes, that works. But that requires manual intervention. As I understood, conduit provides prompt finalization under all circumstances.
12:12:30 <bjorkintosh> so there must be interesting work getting done in haskell.
12:12:31 <mm_freak_> NemesisD: too small…  par has no problem with variable granularity
12:12:52 <Tekmo> edvo: Are you sure about that?
12:12:59 <edvo> Tekmo: no
12:13:22 <Targen> langpop.com has some very interesting data.  There’s an enormous gap for Haskell between their metrics for use and discussion.
12:13:25 <edvo> I can try, though
12:13:44 <dissipate_> bjorkintosh, but how many of those python 'programmers' are real programmers?
12:14:11 <mm_freak_> NemesisD: indeed, limited depth works very well
12:14:15 <Tekmo> edvo: So the reason I don't do what `conduit` does is for a few reasons
12:14:21 <dissipate_> bjorkintosh, a lot of the python 'programmers' i have run into are more like python scriptors
12:14:25 <bjorkintosh> dissipate_, they get paid to copy-paste. but they get paid regardless :)
12:14:29 <Tekmo> edvo: First, it's not associative, meaning that the order of finalizers changes depending on how you group things
12:14:42 <dissipate_> bjorkintosh, cargo cult programming?
12:14:42 <bjorkintosh> will i get paid to write haskell? not muy likely.
12:14:46 <Tekmo> edvo: The second reason is that the way conduit formulates it only works with one type of composition operator
12:14:50 <bjorkintosh> sure.
12:14:52 <merijn> dissipate_, bjorkintosh: THis is starting to go off-topic and flamey for no good reason
12:14:58 <mm_freak_> NemesisD: http://lpaste.net/92747
12:15:02 <mm_freak_> see annotation
12:15:11 <Tekmo> edvo: With pipes you can safely single step pipes or use other combinators (ie. `for` and `(>~)`) and finalization works correctly
12:15:12 <bjorkintosh> you're right.
12:15:14 <monochrom> merijn++
12:15:25 <Tekmo> edvo: Whereas teh conduit approach means you must restrict yourself only to using one type of composition operator
12:15:29 * monochrom is a complex programmer, not a real programmer
12:15:40 <merijn> monochrom: Anything for that sweet, sweet karma!
12:15:43 <mm_freak_> NemesisD: this version runs in 2.3 secs with one thread and 0.7 secs with four threads
12:15:45 <dissipate_> monochrom, what's a 'complex' programmer?
12:15:52 <nitin2> Does anyone know a Haskell introduction based on algebra?
12:15:53 <merijn> dissipate_: It's a joke :)
12:15:58 <merijn> dissipate_: complex vs real numbers
12:16:01 <monochrom> has a real part and an imaginary part
12:16:08 <bjorkintosh> nitin2, i know of one based on discrete mathematics.
12:16:17 <monochrom> think of the "imaginary part" as "knows theories"
12:16:24 <Targen> monochrom: I believe that’s called schizophrenia. ;)
12:16:25 <dissipate_> monochrom, that's a good one. :D
12:16:31 <inkjetunito> ghci is very nice, but is there an alternative with syntax highlighting and possibly even more editing aids?
12:16:31 <bjorkintosh> it is a good one.
12:16:33 <bjorkintosh> very good.
12:16:41 <bjorkintosh> inkjetunito, emacs.
12:16:58 <inkjetunito> bjorkintosh: thanks
12:17:01 <bjorkintosh> you normally write your code in an editor.
12:17:04 <NemesisD> mm_freak_: so what do you initially pass in as the first arg, which i'm assuming is depth
12:17:09 <edvo> Tekmo: don't get me wrong. I like the pipe API way more than conduit's. But that seems to be a disadvantage and I wonder if we could do better in pipes. We only need to run finalizers right after a premature termination
12:17:11 <bjorkintosh> it is a compiled language, afterall.
12:17:20 <zomg> emaghcs? =)
12:17:26 <bjorkintosh> sure.
12:17:31 <edvo> Tekmo: that is, we need to be able to
12:17:33 <inkjetunito> bjorkintosh: yeah, i do, but now in the learning phase i like quickly trying things out
12:17:44 <mm_freak_> NemesisD: 10
12:17:52 <zomg> I just use tmux, I can have a split terminal between ghci and vim
12:18:29 * hackagebot cyclotomic 0.4 - A subfield of the complex numbers for exact calculation.  http://hackage.haskell.org/package/cyclotomic-0.4 (ScottWalck)
12:18:30 <mm_freak_> NemesisD: made another annotation that gets along without the extra argument
12:18:39 <Tekmo> edvo: Believe me, I've tried variations on what you propose and all of them have subtle flaws, flaws which are present in `conduit`
12:18:44 <mm_freak_> NemesisD: same running time
12:19:23 <Targen> There are a few tricks to get syntax highlighting in GHCi output, but nothing too spectacular, last I checked.  Mostly just hooks that postprocess `show` output, so it’s not too reliable.
12:19:29 <Tekmo> edvo: Let me find an old conduit issue to demonstrate what I'm talking about
12:19:44 <Tekmo> edvo: https://github.com/snoyberg/conduit/pull/57
12:19:59 <NemesisD> mm_freak_: thanks! that sure does make a pretty threadscope graph
12:20:11 <bjorkintosh> does haskell have decent QT hooks?
12:20:54 <Tekmo> edvo: To give you a higher-level answer to your question, the only way to get this 100% right and avoid the problems that `conduit` has is to use much more advanced type machinery like indexed monads, which is a huge pain
12:20:56 <inkjetunito> Targen: thanks
12:20:56 <NemesisD> i started down this road after watching a screencast where someone made a parallel fibonacci solver in elixer (erlang derivative) and ruby. was flabberghasted at how much machinery they used for it
12:21:14 <Tekmo> edvo: So I decided it was easier to ask the user to place the `runSafeP` correctly than it was to teach them how to use indexed monads and override `do` notation
12:21:31 <edvo> Tekmo: I think you are right
12:21:32 <bjorkintosh> NemesisD, what do you mean by machinery?
12:21:41 <bjorkintosh> was it too many lines of code?
12:21:59 <mm_freak_> NemesisD: well, a proper memoizing/streaming fibonacci computer can't really be parallelized
12:22:20 <mm_freak_> and it's asymptotically faster than this naive version
12:22:32 <edvo> Tekmo: when I understand snoyberg correctly in the last comment, different design decisions have been taken. I actually agree, that associativity is more important than prompt finalization
12:23:12 <mm_freak_> i love the cases when you can parallelize an algorithm by replacing a 'map' by 'parMap rdeepseq' =)
12:24:10 <hpaste> NemesisD pasted “erlang-in-ruby fibonacci solver o_O” at http://lpaste.net/92752
12:24:30 <mm_freak_> wow, that's really ugly
12:24:36 <danilo2> mm_freak_: I've got one problem - it seems so simple, but I simply getting type error - why this applicative instance does not work?: http://lpaste.net/92751
12:24:47 <mm_freak_> but they don't have lazy evaluation, so they can't really have 'par' either
12:24:54 <Tekmo> edvo: Associativity matters particularly in ensuring proper ordering of finalization
12:25:08 <Tekmo> edvo: Which matters for ensuring proper nesting of resource acquisition
12:25:10 <NemesisD> some of the machinery there is for benchmarking but it seems like he may have just been doing a rote translation of the erlang verison, which really probably shouldn't have been that verbose either
12:25:45 <mm_freak_> danilo2: because you simply can't express (<*>) in terms of fmap =)
12:25:47 <Targen> mm_freak_: I did a 5 minute demo of that at work a few days ago.  It’s a superb tool for convincing people of the merits of Haskell — the managers are used to Java, so they were quite shocked at how easy it was to parallelize! :)
12:26:27 <merijn> Man, I wish the time between fixing a bug in a program/library and actually being able to use the result wouldn't take so long >.<
12:26:35 <monochrom> "one doesn't simply fmap into Applicative"? :)
12:26:43 <bjorkintosh> Targen, but how many things are actually amenable to parallelization?
12:27:01 <monochrom> but I wonder what the Bool is doing there
12:27:15 <Targen> bjorkintosh: That’s a fantastically complex question there ;)
12:27:28 <mm_freak_> Targen: yeah, parallelism, in particular data parallelism, is one of haskell's killer features
12:27:38 <mm_freak_> and it's really impossible to have in most other languages
12:27:44 <Targen> I was caught off-guard when they asked if I could do the same with IO computations.  Thank god for async!
12:27:50 <NemesisD> pur code can be pretty darn nice to parallelize. it is really easy to benchmark
12:27:52 <merijn> mm_freak_: My supervisor would strongly disagree with you
12:27:53 <edvo> Tekmo: I see, thank you very much
12:27:58 <Tekmo> edvo: You're welcome!
12:28:05 <bjorkintosh> mm_freak_, impossible? erlang scoffs at you!
12:28:09 <bjorkintosh> (and java too)
12:28:15 <bjorkintosh> don't hit me!
12:28:16 <mm_freak_> bjorkintosh: data parallelism
12:28:23 <merijn> mm_freak_: He gets really grumpy if you say Haskell is good at data parallelism
12:28:23 <tel> Tekmo, how far along is pipes-bytestring on your github? I want to get a lazy bytestring out of pipes-concurrency
12:28:27 <bjorkintosh> data parallelism.
12:28:39 <mm_freak_> bjorkintosh: you have a data structure and you want to evaluate it in parallel…  that is a meaningless concept in erlang
12:28:41 <merijn> bjorkintosh: Erlang is terrible at data parallelism
12:28:45 <Tekmo> tel: It's usable.  The only reason I haven't published it is that it's missing splitters in the style of `pipes-parse`
12:28:51 <bjorkintosh> hmm.
12:28:51 <Tekmo> tel: i.e. a function like:
12:28:54 <bjorkintosh> TIL!
12:28:59 <mm_freak_> merijn: what would be his favorite then?
12:29:04 <Tekmo> tel: chunksOf :: Int -> Producer ByteString m r -> FreeT (Producer ByteString m) m r
12:29:29 <merijn> mm_freak_: Well, he's working on his own purely functional language for data parallel array/matrix computation, so he might be a little biased ;)
12:29:41 <mm_freak_> merijn: i see =)
12:29:42 <Tekmo> tel: Here is what I'll do.  I'll open issues on Github for all the features from `pipes-bytestring` that I think are missing and if people flesh those out then I will publish it
12:29:45 <merijn> mm_freak_: To be fair, they're far better at numeric code than haskell
12:30:10 <mm_freak_> merijn: well, if he is designing his language for that domain, then i'm sure it is
12:30:10 <bjorkintosh> merijn, what is far better at numeric code?
12:30:14 <tel> Tekmo, I'm booked right now, but with a list like that I'd be more than happy to take a crack at some issues next week
12:30:18 <merijn> mm_freak_: Too bad that, lacking ADTs and other stuff, they suck at everything else atm ;)
12:30:21 <Tekmo> tel: Alright
12:30:22 <Targen> Does DPH get along with type classes yet?  I haven’t checked in about a year.
12:30:30 <tel> Tekmo, though I'll try out the library as-is right now
12:30:43 <Tekmo> tel: It will compile and work
12:30:51 <Tekmo> tel: It builds and has most of what you will need
12:31:11 <mm_freak_> merijn: but then he should probably give repa/accelerate a shot =)
12:31:11 <mm_freak_> but it sounds like he would be quite familiar with repa
12:31:12 <merijn> bjorkintosh: SAC (Single Assignment C)
12:31:23 <bjorkintosh> ah.
12:31:46 <mm_freak_> i still have to try yarr
12:32:03 <tel> Tekmo, What I'd love, and I don't think I saw it previously, would be a (Lazy.ByteString -> Lazy.ByteString) -> Pipe Strict.ByteString Strict.ByteString m r
12:32:17 <merijn> mm_freak_: We were at IFL, I believe someone was doing Cholesky using repa and was about 2 orders of magnitude slower than their SAC Cholesky stuff
12:32:35 <mm_freak_> i've been told that yarr has the potential to outperform repa, which i doubt
12:32:43 <aristid> mm_freak_: what's yarr?
12:32:46 <Tekmo> tel: That is tricky
12:32:54 <mm_freak_> another regular parallel array library
12:32:55 <aristid> @hackage yarr
12:32:55 <lambdabot> http://hackage.haskell.org/package/yarr
12:33:00 <Tekmo> tel: You'd have to use unsafeInterleaveIO to get that to work
12:33:58 <tel> Tekmo Really? I'm not super familiar with LBS internals, but I thought they were pure?
12:34:01 <tel> purish
12:34:03 <Tekmo> tel: They are
12:34:08 <mm_freak_> merijn: well, repa needs to be written idiomatically…  for example don't construct an unboxed array you don't need…  that's a common beginner mistake
12:34:12 <Tekmo> tel: But that function's semantics are not
12:34:32 <Tekmo> tel: Try to implement the function and you will see what I mean
12:34:40 <aristid> mm_freak_: it appears Yarr has no scans either :D
12:35:09 <mm_freak_> aristid: it probably has unfolds
12:35:09 <tel> Tekmo, hm, alright, maybe I'll get to the point where I can take a look at bytestring issues more quickly than I thought :)
12:35:19 <merijn> mm_freak_: If you're presenting a paper on high-performance haskell I'm assuming it's written as proper repa code :)
12:35:38 <mm_freak_> merijn: i'd hope so =)
12:35:39 <aristid> mm_freak_: i was saddened when i learned that repa has deliberately no scans at all:)
12:35:55 <mm_freak_> aristid: it too has unfolds
12:36:15 <mm_freak_> you don't need scans for vectors…  they are useful for lists
12:36:51 <mm_freak_> the problem with scans is that they are inherently sequential
12:37:02 <aristid> mm_freak_: you don't need scans?!
12:37:15 <mm_freak_> you don't /want/ scans ;)
12:37:21 <aristid> mm_freak_: i don't want scans?!
12:37:30 <shachaf> Didn't conal have that thing about parallelizing some types of scans?
12:37:45 <mm_freak_> aristid: general scans destroy your parallelism
12:37:45 <aristid> accelerate can parallelize associative scans.
12:38:31 <aristid> mm_freak_: i imagine if you have a problem that requires a scan, it won't care about your parallelism
12:38:51 <aristid> mm_freak_: i don't find unfolds in repa btw
12:39:45 <mm_freak_> aristid: indeed, repa doesn't have unfolds
12:39:55 <mm_freak_> you should try to express your array using fromFunction
12:40:18 <mm_freak_> unless you have a ready-made vector, in which case you would use fromUnboxed
12:41:03 <mm_freak_> if you really want to unfold, you can use fromListUnboxed
12:41:29 <mm_freak_> what bothers me most about all the regular parallel array libraries is that they insist on unboxed vectors
12:41:49 <danilo2> mm_freak_: http://lpaste.net/92753 :))))))
12:41:53 <Tekmo> What's wrong with unboxed vectors?
12:42:11 <mm_freak_> Tekmo: sometimes you want to parallelize Integer vectors ;)
12:42:38 <Tekmo> mm_freak_: The problem is that boxed vectors are pretty nasty to work with
12:42:43 <Tekmo> They leak space like crazy
12:42:49 <ReinH> woo, second episode of the haskell cast is a wrap!
12:43:09 <h4199> ReinH is it already up?
12:43:17 <ReinH> h4199: a wrap as in we just finished recording :D
12:43:37 <h4199> What did you talk about this week?
12:43:39 <aristid> Tekmo: they leak space? how so?
12:43:59 <ReinH> aristid: "leak" may not be the most correct term
12:44:02 <mm_freak_> danilo2: seems correct, except that i would write it like this:  State chf ff <*> State chx fx = State (chf || chx) (\s -> let (s', f) = ff s; (s'', x) = fx s' in (s'', f x))
12:44:30 <danilo2> mm_freak_: of course
12:44:41 <Tekmo> aristid: You can't do a long-running series of mutations on them (in either ST or IO) without them leaking space
12:44:49 <ReinH> Tekmo: orly
12:44:53 <Tekmo> That's my experience
12:44:56 <danilo2> mm_freak_: Thank you for this, really. I have seen something very interestung by this exmple!
12:44:56 <ReinH> so actual leaks?
12:45:00 <ReinH> not just heap explosion?
12:45:00 <Tekmo> Yes, space leaks
12:45:05 <ReinH> wow :/
12:45:10 <aristid> Tekmo: why?
12:45:19 <mm_freak_> Tekmo: no, they don't leak space…  it's just that all the usual lazy evaluation effects apply
12:45:19 <Tekmo> So let me give the example I had in mind
12:45:20 <danilo2> mm_freak_: Ok so I understand the arrows re like applicative style ?
12:45:35 <ReinH> Tekmo: I thought you were referring to boxed + laziness
12:45:37 <Tekmo> I was writing a pipe that was binning results from its input into a vector
12:45:58 <Tekmo> I tried out four permutations:
12:46:08 <Tekmo> Boxed + IO
12:46:09 <mm_freak_> Tekmo: if you say that unboxed vectors are fine but boxed vectors suck, then by extension most haskell types suck ;)
12:46:11 <Tekmo> Boxed + ST
12:46:18 <Tekmo> Sorry, 6 permutations
12:46:27 <Tekmo> basically {Boxed,Unboxed,Storable}x{ST,IO}
12:46:37 <Tekmo> And I also employed every strictness trick in the inner loop
12:46:45 <Tekmo> I made sure everything was strictly evaluated
12:46:58 <Tekmo> And the results were quite decisive
12:47:02 <mm_freak_> danilo2: no…  now try to express a function of this type:  putResult :: State s s -> State s ()
12:47:06 <Tekmo> Unboxed and Storable *always* ran in constant space
12:47:14 <Tekmo> Boxed never ran in constant space and always leaked
12:47:19 <ReinH> Tekmo: o_O
12:47:27 <aristid> Tekmo: sounds like a bug?
12:47:38 <mm_freak_> danilo2: it should 'put' the result of the argument action
12:47:42 <ReinH> space leaks do sound like a bug
12:47:59 <ReinH> Tekmo: what do you mean when you say "leaked"?
12:48:14 <Tekmo> The heap profile grew
12:48:26 <Tekmo> and it ran damn slow, too
12:49:03 <danilo2> mm_freak_: ok
12:50:12 <red___> i am having trouble thinking about Data.Graph, can anyone point to a resource that would help me (other than hackage)?
12:50:26 <red___> functional data structures blow my mind
12:50:30 <Tekmo> red___: How familiar are you with graphs in general?
12:50:37 <red___> Tekmo: pretty familiar
12:50:38 <danilo2> mm_freak_: Shouldnt the signature be: putResult :: State s s -> State () s ?
12:50:53 <Tekmo> red___: Data.Graph is an adjacency list representation of a graph
12:50:56 <Cale> red___: Just plain Data.Graph?
12:51:06 <Cale> Or are you talking about FGL?
12:51:17 <red___> Tekmo: so just a list of pairs?
12:51:22 <Cale> (whose modules all start with Data.Graph, but it doesn't take Data.Graph itself)
12:51:40 <red___> Tekmo: my graph is weighted...is that a problem? i'd like to key the pairs by their weight
12:51:41 <Tekmo> red___: If you fully expand out the `Graph` type synonym you get `Array Vertex [Vertex]`
12:51:42 <mm_freak_> danilo2: what would be the result of a function with that type?
12:52:02 <Tekmo> red___: No, it's not a problem.  You just keep a separate `vector` mapping `Edge`s to weights
12:52:18 <mm_freak_> Tekmo: i don't buy your argument against boxed vectors, simply because they work for me ;)
12:52:32 <Tekmo> mm_freak_: Let me see if I can produce the case that triggered this
12:52:56 <mm_freak_> Tekmo: for a legitimate usage of boxed vectors see my 'instinct' library
12:52:56 <Cale> red___: Usually I find that when I need a graph, I don't end up bothering with most of the graph libraries... of course, it depends on what sort of things you need, but usually something like Map Vertex (Set Vertex) or  Map Vertex (Map Vertex Weight) will work nicely.
12:53:06 <red___> Tekmo: the type synonym helps .. i am trying to imp a haskell version of prim and it is harder than i thought it would be
12:53:35 <Tekmo> red___: What do you mean by prim?
12:53:41 <red___> Cale: thanks, i am pulled toward intmap, maybe mapping a weight to a pair of edges?
12:53:46 <red___> Tekmo: prim's MST
12:54:34 <Cale> red___: Er, perhaps you mean mapping pairs of vertices to weights?
12:54:37 <mm_freak_> Tekmo: i calculate the activations of a neural network using a boxed vector…  the backprop learning algorithm makes heavy use of boxed vectors and runs in constant space until a certain minimum error is reached
12:54:51 <red___> Cale: :) yep
12:54:54 <Cale> red___: Map (Vertex, Vertex) Weight  would work
12:55:18 <Cale> red___: However, it might not be ideal, since you're usually going to be interested in the *neighbours* of a given vertex
12:55:26 <Tekmo> mm_freak_: Just give me a second
12:55:50 <ReinH> red___: you need an efficient way to get the edges for a vertex and the weight for an edge
12:56:18 <ReinH> preferably both at the same time
12:56:34 <ReinH> Map Vertex (Map Vertex Weight) would work
12:56:38 <mm_freak_> Tekmo: you may be interested in this article: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
12:56:43 <red___> in any other language I would use a priority queue and be done with it, i think
12:56:47 <Tekmo> I'm already well aware of that technique
12:56:47 <Cale> red___: So, it might be better to split that up into  Map Vertex (Map Vertex Weight),  i.e. you have a map from vertices u to maps which have a key/value pair (v,w) when there is an arc u -> v with weight w.
12:56:56 <Tekmo> Other than vectors I'm quite good at removing space leaks from code
12:57:15 <Cale> red___: You could absolutely use a priority queue here.
12:57:17 <mm_freak_> well, the article is about not introducing them in the first place =)
12:57:23 <ReinH> red___: you could use a priority queue here as well but it might be nice to build the algorithm more directly first
12:57:41 <red___> where is priority queue?
12:57:44 <Cale> red___: But I thought you were talking about your graph representation.
12:57:52 <Cale> red___: I like the PSQueue package myself.
12:57:59 <Tekmo> mm_freak_: Also, keep in mind that if it were a flaw in the way I wrote it, it would have also leaked for unboxed and storable vectors, too
12:58:00 <monochrom> me too
12:58:02 <ReinH> red___: there are a number of them with different properties
12:58:23 <red___> Cale: i guess I was talking about both graph representation and a dstruct to keep 'explored edges' in Prim's MSt
12:58:56 <mm_freak_> Tekmo: not at all…  it's easy enough to build unevaluated expressions using boxed vectors, whereas it's impossible for unboxed/storable ones
12:58:56 <ReinH> red___: start with the simplest thing that could possibly work while you're learning
12:59:10 <ReinH> i.e. type ExploredVertices = Set Vertex
12:59:19 <red___> ReinH: good advice
12:59:23 <Cale> red___: If I were implementing Prim's algorithm, I would probably make my implementation independent of the graph representation by taking parameters which were functions for querying the graph structure.
12:59:28 <Tekmo> mm_freak_: But int his case I made sure to fully evaluate each term being stored in the vector
12:59:31 <ReinH> red___: later on you can add performance improvements incrementally
12:59:44 <mm_freak_> Tekmo: so you suspect that i
12:59:50 <mm_freak_> Tekmo: so you suspect that it's a bug in vector?
12:59:54 <Cale> red___: For example, see the type of my A* implementation here: http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
12:59:57 <ReinH> red___: type Graph = Map Vertex (Map Vertex Weight)
13:00:05 <Tekmo> mm_freak_: Just give me a second to repeat the scenario that triggered this for me
13:00:12 <Tekmo> mm_freak_: I need to make sure that it still happens
13:00:13 <mm_freak_> ok
13:00:16 <red___> ooh A*, classic!
13:00:31 <ReinH> red___: now, make a singleton set from a vertex in Graph to kick start your algorithm
13:01:15 <red___> ReinH: that is helpful, I think I will try that avenue first
13:01:28 <Cale> red___: I use PSQueue as my priority queue internally there
13:02:22 <ReinH> red___: if you look up a bunch of (Map Vertex Weight) based on the vertices in your ExploredVertices, you can union them together with min and then find the min key of the resulting map
13:02:32 <ReinH> that is the new vertice that you add to explored vertices
13:02:51 <Cale> the new vertex*
13:02:53 <Cale> ;)
13:02:54 <ReinH> or you can min each and then min that result, or you can do it as a fold, etc
13:03:01 <ReinH> Cale: whoops
13:03:02 <monochrom> damn english
13:03:16 <red___> vertice
13:03:42 <red___> way better
13:03:48 <ReinH> vertice is more principled :p
13:03:52 <Cale> "vertexes" is acceptable, but "vertice" is a bit off :)
13:03:57 <ReinH> Cale: shush
13:04:24 <red___> precipexes
13:04:27 <red___> ok thanks, channel
13:05:14 <ReinH> red___: the point is that you can take advantage of algebraic properties of maps and integers to do most of the work for you :)
13:05:18 <ReinH> (and sets)
13:05:50 <danilo2> mm_freak_: here you go: http://lpaste.net/92753 :)
13:06:07 <ReinH> Tekmo: I am disconcerted by this reported space leak in Vector :)
13:06:24 <ReinH> do you have a reproducible test case yet?
13:06:34 <Tekmo> That's what I'm writing up right now
13:07:07 <ReinH> cool :)
13:07:19 <Tekmo> So far it looks like it is not working
13:07:25 <VABAV> Hello to everybody! Can anybody help me to understand what exercise 2 of chapter 5 of Real World Haskell suggests to implement?
13:07:29 <Tekmo> Maybe I was using a bugged version of vector at the time
13:07:54 <VABAV> Also, how to implement this efficiently?
13:08:38 <danilo2> mm_freak_: wait it does not work as supposed to
13:09:08 <Tekmo> Huh
13:09:10 <Tekmo> It works now
13:09:14 <Tekmo> I will go ahead and lpaste the code
13:09:21 <Tekmo> Well, that's good news, then!
13:09:56 <mm_freak_> danilo2: it does
13:09:57 <Tekmo> http://lpaste.net/92755
13:10:13 <VABAV> Or this chat is not for questions by newbies? :-(
13:10:45 <Tekmo> It is for questions by newbies! :)
13:11:20 <Cale> VABAV: Perhaps you'd care to remind us what that exercise says, or link it?
13:11:33 <mm_freak_> Tekmo: that would most likely have been a bug in the RTS, not in vector, because vectors really just store thunk pointers
13:11:35 <Tekmo> Which one is the exercise?
13:11:52 <Tekmo> mm_freak_: Well, either way it is fixed now
13:11:58 <Tekmo> Now I can go back to using boxed vectors again!
13:11:59 <VABAV> Sure, http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html, then search for "Exercises"
13:12:11 <Cale> "The asInt_fold function uses error, so its callers cannot handle errors. Rewrite it to fix this problem"
13:12:17 <ion> > [(-1)**0.5, sqrt (-1)] :: [Complex Double]
13:12:18 <lambdabot>   [6.123031769111886e-17 :+ (-1.0),(-0.0) :+ 1.0]
13:12:19 <Cale> That one?
13:14:08 <danilo2> mm_freak_: Ok, whats next? (I'm still thinking about the usage of previous one)
13:14:11 <ReinH> TL;DR: basically everything is a fold.
13:14:11 <ReinH> red___: btw, relevant to your interests: http://stackoverflow.com/questions/6976559/comparison-of-priority-queue-implementations-in-haskell
13:14:11 <ReinH> A bit surprised that dons didn't answer it but still useful ;)
13:14:11 <ReinH> red___: also of interest is the fact that prim's algo computes a fixed point of the inner traversal loop
13:14:12 <ReinH> awww he's gone :(
13:14:14 <Cale> VABAV: It wants you to use Either to handle errors, so if the function parses an Int successfully, it should produce Right x where x is an Int, and if not, it should produce Left s where s is a String explaining why it failed.
13:17:05 <Cale> VABAV: according to the comments there, it seems that Either hasn't been introduced yet, so that might be a bit of an oversight on the authors' part. Regardless, Either is a pretty simple type to understand. It's defined as  data Either a b = Left a | Right b
13:17:15 <mm_freak_> danilo2: now try to express putResult using only the applicative interface
13:17:29 <VABAV> @Cale:  Are we  talking about the same? Copy-pasting the text of exercise, just a moment...
13:17:29 <lambdabot> Unknown command, try @list
13:17:43 <mm_freak_> danilo2: you must not take apart State values
13:17:58 <VABAV> Our pretty printer does not take nesting into account. Whenever we open parentheses, braces, or brackets, any lines that follow should be indented so that they are aligned with the opening character until a matching closing character is encountered. Add support for nesting, with a controllable amount of indentation.
13:18:31 * hackagebot digestive-functors-heist 0.8.0.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.0.0 (JasperVanDerJeugt)
13:18:32 <VABAV> "nest :: Int -> Doc -> Doc"
13:18:32 <mm_freak_> danilo2: i have to go now, but i'll be back in about two hours
13:18:39 <Cale> ah, okay
13:18:59 <Cale> I must've found my way to a different exercises section somehow
13:19:19 <mm_freak_> danilo2: in any case you will fail to solve the task, so what is missing is a way to compose State computations
13:19:34 <VABAV> With that link i gave?? Sorry then.
13:19:44 <Cale> Yeah, I dunno what happened
13:19:54 <mm_freak_> danilo2: since the monadic interface is not possible you would extend State to this type:  data State s a b = State Bool ((s, a) -> (s, b))
13:20:23 <mm_freak_> danilo2: this type is an arrow and gives you back the ability to pass values from one computation to another
13:22:26 <VABAV> Anyway it seems to answer my question the chapter must be read at least a little bit. So, who read Real World Haskell, Chapter 5? It's about writing pretty-printer library for JSON.
13:22:35 <Cale> VABAV: okay, so the goal there is to be able to have blocks which are indented to a certain column, so as to be able to line up subsequent lines when you have a list or map structure that's being split across many lines.
13:22:56 <danilo2> mm_freak_: Ok, thank you - I'll think about it :)
13:23:27 <danilo2> mm_freak_: Sometimes things are very very simple, but its hard to see the simplest thing keeping you back from the solution heh :)
13:23:31 * hackagebot HaRe 0.7.0.2 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.2 (AlanZimmerman)
13:23:51 <Cale> You'll see in the ghci example they have there, a representation of a JObject:
13:23:55 <VABAV> @Cale: Okay, but what if my JSON on the input just does not contain a line after a opening delimiter?
13:23:55 <lambdabot> Unknown command, try @list
13:23:56 <Cale> ghci> putStrLn (pretty 10 value)
13:23:56 <Cale> {"f": 1.0,
13:23:56 <Cale> "q": true
13:23:56 <Cale> }
13:24:09 <Cale> It would be nice if the "q" actually lined up with the "f"
13:24:51 <VABAV> But then whats an Int parameter?
13:25:05 <Cale> and for that, you'll need to add something to the representation of Doc to express the idea that you're in a block starting in a given column
13:26:01 <VABAV> So, you mean, another data constructor? Because that were my thoughts :-)
13:26:02 <Cale> Or, a block which has been indented by a specific number of characters relative to the next enclosing block
13:26:04 <Cale> yeah
13:27:41 <VABAV> That's the problem for a kind of guy who i am, actually :-) I see 'write a function' and assume --- "don't touch anything else!" :-(
13:27:45 <Cale> In fact, I think it would be possible to do without the Int parameter, if you wanted to just make the nested bit set its indentation based on the current position in the line.
13:28:31 * hackagebot data-fresh 0.2013.251.0 - Interface and functor transformers for fresh values  http://hackage.haskell.org/package/data-fresh-0.2013.251.0 (StijnVanDrongelen)
13:28:34 <Cale> (Though, that would require more changes to the rendering algorithm, because it doesn't keep track of that position at present)
13:28:58 <VABAV> Yeah, that's the point where i think you understand it differently than what i think authors meant.
13:28:59 <Cale> or, oh, the pretty one does
13:29:36 <Cale> The overall goal is to be able to print things like:
13:29:43 <Cale> [["hello",
13:30:00 <Cale>   "there"],
13:30:06 <Cale>  ["this",
13:30:10 <Cale>   "is",
13:30:15 <Cale>   "nested"]]
13:30:25 <danilo2> mm_freak_: Ahhh!! I found the error ! You see, I've implemented put as: put a = State True (\b -> (b,a)) and it was wrong. Because of that I was sitting and scratching my head, because some types was wrong... Now everything is clear ...
13:30:26 <Cale> Or some variation thereof
13:30:32 <VABAV> Why not like that?
13:30:36 <VABAV> [[
13:30:50 <VABAV>     "hello"
13:30:53 <Cale> The important thing being the amount of whitespace at the start of each of those lines
13:31:05 <VABAV> ]]
13:31:14 <Cale> (making subsequent elements of the lists line up vertically)
13:31:15 <danilo2> mm_freak_: It was implementewd as "normal put" And your state class has got flipped arguments compared to state from Haskell :)
13:31:33 <VABAV> That's where Int parameter makes sence.
13:31:34 <Cale> Or, imagine prettyprinting Haskell source code
13:31:48 <Cale> You'd want all the lines in a 'where' block to start in the same column
13:32:20 <Cale> So, you'd need some way to represent the notion that a Doc was a block of code which all must be indented together.
13:32:55 <Cale> i.e. all lines must start on the same column (regardless of which column that is)
13:33:22 <Cale> You could include an Int parameter to say that it has to be indented by a specific amount, or you could set the amount of indentation based on where you started the block.
13:33:28 <VABAV> Yeah! And then i do want to my function be so smart to figure out how much to indent the code in subsequent lines all by itself!
13:34:40 <VABAV> Are you assuming it meant to be recursive?
13:34:53 <danilo2> mm_freak_: Because I made an error on the beginning, It was hard for me to get forward. Than you once again for everythink :)
13:34:57 <VABAV> *was meant
13:37:10 <VABAV> Little bit confused, sorry. I'll take a look at prettyfied JSON in that chapter...
13:40:02 <VABAV> How do you think, how crazy is the idea to contact authors? And what is the easiest way to do it?
13:41:47 <Cale> It's not that crazy... they used to hang out here a little more often than they do these days...
13:42:06 <Cale> But you'd probably find it easier to use email
13:42:27 <h4199> what is lambdabot's last seen command?
13:42:42 <elliott> it doesn't have one
13:42:43 <elliott> but preflex does
13:42:46 <elliott> preflex: xseen h4199
13:42:46 <preflex>  h4199 was last seen on freenode/#haskell 19 seconds ago, saying: what is lambdabot's last seen command?
13:42:51 <Cale> Don Stewart's email is  dons00 (at) gmail.com
13:42:54 <VABAV> But it must be a hard task to get their emails or am i worng?
13:43:03 <h4199> preflex: xseen bos
13:43:03 <preflex>  bos was last seen on freenode/#haskell 8 days, 21 hours, 44 minutes and 43 seconds ago, saying: we need a "><>" operator too
13:43:27 <VABAV> Oh! Thanks a lot!!! :-)))
13:43:50 <monochrom> on twitter, he's "donsbot" :)
13:43:57 <Cale> and Bryan O'Sullivan is bos (at) serpentine.com
13:44:04 * tacpacpoc the best game REAL GOLD : http://www.goldentowns.com?i=7386
13:44:21 <h4199> VABAV: and bos in this channel when he is around
13:44:46 <Cale> I wonder why dons never shows up anymore
13:45:05 <monochrom> it would be cool if bos's email were boss@gmail.com or something :)
13:45:30 <monochrom> because as I always like to say, "he's chartered by a bank" :)
13:46:17 <merijn> Cale: To busy taking pictures of sunsets/-rises ;)
13:46:51 <monochrom> but even those pictures are getting old, no? there haven't been new pictures for a while
13:47:17 <monochrom> I say, he's chartered by either a bank or a significant other
13:48:01 <aristid> monochrom: there must be some kind of standard chartering agreement or so.
13:48:11 <monochrom> hehehe
13:48:20 * copumpkin slaps aristid and monochrom 
13:48:23 <VABAV> Thanks again, Cale!
13:49:47 <aristid> monochrom: now we need to find stupid puns about copumpkin's situation.
13:49:53 <copumpkin> lol
13:49:59 <copumpkin> I'm still around!
13:50:02 <donri> it's interesting how fast these spammers get killed, but their messages not blocked?
13:50:44 <copumpkin> donri: I don't think the ircd has facilities for pre-filtering messages, but they can probably monitor them easily
13:51:05 <monochrom> I already found one last year's halloween, aristid. http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
13:51:21 <copumpkin> aww
13:51:37 <monochrom> oh, copumpkin's situation, not copumpkin's nick. I'll have to think again.
13:51:50 <monochrom> what is the situation? I don't even know that.
13:51:56 <copumpkin> me neither!
13:52:08 <monochrom> is it some kind of connection with Galois?
13:52:14 <aristid> monochrom: those pumpkin kittehs are cute though
13:52:20 <copumpkin> lol
13:52:38 <aristid> monochrom: iirc copumpkin is trimming hedges these days or something like that
13:52:51 <aristid> i know i know... TERRIBLE.
13:53:03 <copumpkin> #haskell-terriblepuns
13:54:52 <merijn> Apparently everyone cool is working in finance nowadays >.>
13:55:12 <aristid> merijn: that's not true! i'm not cool and i also work in finance.
13:55:19 <copumpkin> lol
13:55:30 <copumpkin> aristid fails at logic at least
13:55:33 <monochrom> they are trying to cause a financial collapse and transition to communism
13:55:38 <jmcarthur> lol
13:55:43 <copumpkin> yeah, look at jmc
13:55:47 <copumpkin> jmcarthur that is
13:55:53 <copumpkin> he's the worst!
13:55:57 <aristid> copumpkin: :( sometimes logic needs to be bended a bit for the sake of a terrible pun.
13:55:59 <merijn> aristid: I was about to remark "Which makes it doubly sad that Jane Street told me 'not interested', as that means I'm not cool..." :p
13:56:00 <jmcarthur> yeah that guy sucks
13:56:05 <copumpkin> of all the financiers around here, he's the closest to wall street
13:56:22 * copumpkin shakes his head
13:56:57 <copumpkin> http://en.wikipedia.org/wiki/Financier_(cake)
13:57:29 <merijn> Someone rich should just pay me to work on Haskell infrastructure fulltime, I hear new-hackage still needs work :p
13:57:30 <monochrom> I love cakes. they're so sweety.
13:58:00 <aristid> copumpkin: so english wikipedia says it's a cake not to be confused with pastry... and french wikipedia says "est une pâtisserie" :D
13:58:10 <companion_cube> maybe communism wouldn't be so bad
13:58:12 <copumpkin> terrible
13:58:51 <companion_cube> why so?
13:58:54 <ReinH> merijn: hai
13:58:58 <Targen> Nowdays I can’t distinguish random comments from subtle puns on some new sort of lens I don’t know about.  Is a «sweety» some generalization of bazaars?
13:59:08 <edwardk> =)
13:59:35 <merijn> ReinH: Is that a confirmation or an offer to give me money? :P
13:59:42 <monochrom> no, sweety is just to rhyme with lazy, e.g., "I love haskell, it's so lazy"
14:00:08 <Cale> Monoids.
14:00:10 <aristid> monochrom: it might rhyme better if the first line hadn't been confined to your head
14:00:15 <monochrom> (please don't take it too seriously and lecture me on non-strictness vs laziness)
14:00:43 <monochrom> it is not confined to my head. it has appeared in this channel before
14:00:51 <aristid> hmm
14:00:52 <ReinH> companion_cube: but affirming a disjunct is FUN ;)
14:00:54 <ReinH> er
14:00:56 <ReinH> copumpkin: ^
14:01:05 <aristid> monochrom: somehow i didn't make the association to they monoids joke.
14:01:07 <aristid> *the
14:01:10 <monochrom> you may also have heard shachaf saying, "I love monochrom, he's so lazy"
14:01:24 <aristid> no:)
14:01:46 <Targen> edwardk: Hi!  Do you have a second to look at a curious bit of lens-xml?  I’m about to file a bug report, but my lens-fu is weak so I may be asking for something unreasonable re: the laws by which everything must abide...
14:01:55 <aristid> monochrom: why are you tip-toeing around it like this? just say it! "i love monoids. they are so easy!"
14:02:12 <monochrom> because I don't love monoids
14:02:12 <edwardk> Targen: hop on #haskell-lens and ask there, even if i wind up too busy there should be someone
14:02:26 <aristid> monochrom: why don't you love monoids?
14:02:28 <h4199> I'm just confused now, mind's getting hazy?... or perhaps the chat here is simply crazy?
14:02:29 <Targen> Ah, there’s another channel.  Great, thanks!
14:02:48 <monochrom> because they are too easy. or too hard. I don't know which. depends on how you look at it.
14:03:46 <donri> i love women, they're so easy. ok this joke clearly doesn't scale.
14:04:06 * aristid finds the tab with this again: http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
14:04:10 <copumpkin> o.O
14:04:28 <h4199> donri: please me, but please don't finish that thought in channel
14:04:39 <copumpkin> take it to #haskell-blah, but preferably nowhere
14:04:44 <copumpkin> :)
14:04:51 <donri> yeah agreed
14:07:33 <dwcook> If I define type Foo = Num a => a and let a = 1 :: Foo, I expect a + (2 :: Integer) to be a type error because I thought Foo wouldn't let me pick a more specific type. Why is it not an error?
14:07:47 <monochrom> I love big-Omega, it's so hardy. (Hardy and Littlewood introduced it.)
14:07:52 <merijn> donri: Are you secretly a male supermodel to come up with that one? :p
14:08:03 <shachaf> dwcook: That signature has an implicit forall that should probably be explicit.
14:08:46 <donri> merijn: nah, but you do get a lot of unwanted female attention as a gay male :p
14:09:40 <dwcook> shachaf, same result with type Foo = forall a. Num a => a. What am I missing?
14:09:46 <monochrom> eliminate all Foo to see what's really going on
14:10:06 <monochrom> a :: Num a => a; a = 1
14:10:07 <shachaf> dwcook: Nothing -- this is expected behavior.
14:10:26 <monochrom> a + (2 :: Integer) will not be a type error
14:10:30 <dwcook> I mean to say, what am I misunderstanding that causes me to expect the wrong thing?
14:10:46 <copumpkin> dwcook: forall means that your value must be valid for all possible `a`s
14:10:52 <copumpkin> dwcook: you're saying it's exactly one of them
14:10:55 <dwcook> Oh, maybe I should figure out what the expression as a whole has as its type.
14:10:56 <copumpkin> which is not forall
14:11:11 <donri> dwcook: polymorphism would be useless if you couldn't specialize it to a concrete type later :)
14:11:36 <aristid> there's of course data Foo = forall a. Foo a
14:11:40 <dwcook> I was trying to have a type whose contents could only be used as a Num, not as a more specific type such as Integer.
14:11:47 <copumpkin> dwcook: the main thing to understand about polymorphism and the like is who makes the decisions. In your forall case, the caller gets to choose what type it wants, and you need to be able to provide it. You're trying to choose for the caller
14:11:56 <aristid> dwcook: that makes little sense i'm afraid :)
14:12:56 <aristid> dwcook: it is the definition of Num a => a that any Num instance can be used.
14:13:02 <dwcook> Oh. Woops. I think it was the fact that I used a type *synonym*.
14:13:12 <dwcook> That was what I was confused about.
14:13:47 <monochrom> eliminate all type synonyms to see what's going on
14:14:23 <dwcook> Okay, I see what was going on now. For some reason I used type when I wanted newtype.
14:14:29 <shachaf> #define FOO (forall a. Num a => a)
14:15:03 <joelteon> Anybody know how to lift an IO action into the Base monad in pipes-safe 2?
14:15:09 <dwcook> Or maybe not even that.
14:15:18 <donri> joelteon: not liftIO?
14:15:31 <monochrom> it is unclear to me how useful is "a type that could only be used as a Num, not as a specific type"
14:15:54 <dwcook> monochrom, as an exercise, mostly.
14:16:41 <copumpkin> back when Num implied Show, it might have been more useful
14:16:50 <donri> problem with Num is all methods give you back an "a" so you can't really do anything with it
14:16:56 <copumpkin> forcing yourself to only use a certain interface can be interesting
14:17:34 <joelteon> uh oh, now the IO -> Base problem went away and I have a different one entirely
14:18:43 <dwcook> Yeah, I am discovering that Num doesn't seem to be that useful a constraint on existential types. I appear to have no means of saying "the contents should be the same type", which makes it kind of useless.
14:19:24 <shachaf> Much of the time when people think they want existential types, they actually don't.
14:19:34 <copumpkin> dwcook: existentials can be useful for ensuring uniqueness, but you want a typeclass/interface that's designed especially for that kind of usage
14:19:36 <merijn> @where existential-antipattern
14:19:36 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
14:19:37 <copumpkin> and Num isn't that
14:19:40 <jmcarthur> and sometimes they actually want universal types
14:19:42 <merijn> dwcook: Read that
14:19:45 <dwcook> I've read that blog post.
14:19:47 <merijn> ah
14:19:52 <merijn> nvm then :p
14:19:59 <dwcook> I simply wanted to get a feel for how existential types work, not for use in anything.
14:20:44 <merijn> The only usecase I've found for existentialtypes is together with Typeable to force my will upon the compiler when working with GADTs/TypeFamilies hijinks
14:20:55 <jmcarthur> i actually disagree that that's an antipattern.
14:20:59 <donri> sort of the whole point of an existential is that you *can* have different types for an "a"
14:21:10 <monochrom> SomeException is a good example of existential type
14:21:14 <jmcarthur> but i would whole heartedly agree than most people that do it are not understanding something
14:21:20 <jmcarthur> *that most
14:21:48 <merijn> jmcarthur: How is that *not* an antipattern?
14:21:49 <shachaf> I don't tell people that they shouldn't use existential types. But I tell them that they should understand the alternatives before they do.
14:22:10 <merijn> jmcarthur: In almost all cases the non-existential approach is strictly better
14:22:20 <dwcook> Have you ever seen a legitimate usage of existentials that was better in some way than the alternatives?
14:22:35 <monochrom> in general, for an existential type to be useful, it must come with good getters. because the getters are all that you can get from an existential value
14:22:54 <jmcarthur> merijn: monochrom just said better what i was about to say
14:24:03 <merijn> jmcarthur: Then maybe you misunderstood the blogpost? It wasn't saying "existential types are antipattern", but a specific use of existential types (as for example illustrated by the the Widget example) is
14:24:06 <monochrom> if you throw in Typeable, you can maybe cut some corners on getters, because you can downcast to specific types and then you can do more.
14:25:34 <donri> is there a clean alternative to existentials for "extensible interfaces"? for example test-framework/tasty seem to use existentials; how would they look without it?
14:25:36 <monochrom> in OO languages, you always have Typeable. this is why you can make every type existential and be very careless about providing good getters
14:25:47 <jmcarthur> merijn: he named the antipattern "existential typeclass"
14:25:52 <jmcarthur> pretty general sounding to me
14:26:22 <FreeFull> https://news.ycombinator.com/item?id=6349837   How's this for an explanation of monads? Have I done something wrong?
14:27:45 <merijn> jmcarthur: Sure, but the alternative is "Antipattern: Existential typeclass, except that one time where you know what you're doing"
14:27:53 <jmcarthur> donri: data type a la carte is worth looking into (but it becomes a bit unweildly in practice, IMO). i prefer oleg-style final encodings, which allow to extend functionality by simply instantiating more type classes.
14:27:54 <monochrom> gain some, lose some. Typeable means you gain type-case, and lose parametricity.
14:28:09 <Cale> FreeFull: Why'd you decide to rename things?
14:28:17 <spaceships> writing foldMap in terms of traverse -- I feel as if I am cheating by using Writer to turn it into a list and then mappend over that...
14:28:50 <jmcarthur> spaceships: doesn't seem like cheating to me
14:29:06 <Cale> Oh, I suppose return is taken :P
14:29:07 <spaceships> jmcarthur: okay, thanks I'll move on ;)
14:29:07 <jmcarthur> spaceships: you are aware that there is a standard implementation for this, right?
14:29:12 <monochrom> parametricity means, for example: if I give you joy :: a -> [a], then you need only one test case to discover its entire behaviour. if your test shows that joy () = [(),()], then you know that for all x of all types, joy x = [x,x].
14:29:26 <jmcarthur> :t foldMapDefault
14:29:27 <lambdabot>     Not in scope: `foldMapDefault'
14:29:27 <lambdabot>     Perhaps you meant one of these:
14:29:27 <lambdabot>       `T.foldMapDefault' (imported from Data.Traversable),
14:29:28 <FreeFull> Cale: I thought return was a confusing name in terms of what it actually does, and collapse is also slightly more intuitive than join
14:29:32 <jmcarthur> :t T.foldMapDefault
14:29:33 <lambdabot> (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:29:38 <monochrom> sad :: Typeable a => a -> [a]  does not allow you to conclude the same thing
14:29:39 <spaceships> jmcarthur: oh, cool, i'll check out the source for that !
14:29:57 <FreeFull> Cale: also you can't use return as a function name if the language already has it as a reserved word
14:29:59 <merijn> monochrom: Mostly I use Typeable with existential when I already have the type encoded elsewhere using GADTs/typefamilies and just need a way to convince GHC of the fact that I do know ;)
14:30:02 <donri> foldMapDefault f = getConst . traverse (Const . f)
14:30:11 <Cale> return v is an action which does nothing except to return v
14:30:13 <Makoryu> FreeFull: The real problem with "understanding" monads has nothing to do with understanding the kinds of things that can be monads, and everything to do with understanding the kinds of operations that can be done on monads, and the kinds of operations that can be done on those operations
14:30:14 <jmcarthur> spaceships: it's basically like what you were doing, but just using something simpler than Writer
14:30:28 <niteria> @hoogle a -> (a,a)
14:30:29 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
14:30:29 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
14:30:29 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
14:30:41 <monochrom> precisely because sad can do type-case. it can do: if the parameter is Int, I'll give you [x-1, x+1, x], tee hee hee!
14:31:01 <spaceships> jmcarthur: cool. checking out!
14:31:02 <niteria> @pl \x -> (x,x)
14:31:02 <lambdabot> join (,)
14:31:03 <Cale> I think most people struggle not with the monad abstraction, but with the examples, which for many people will be the first serious examples of functional programming many beginners will come across.
14:31:22 <Cale> er, that was redundant, but you get what I'm saying :P
14:31:22 <spaceships> donri: that's cute. need 10min to grok though ;)
14:31:25 <merijn> Cale++
14:31:41 <merijn> So many people trip not on monads, but on typeclasses and type signatures
14:31:51 <jmcarthur> monochrom: oof... aren't we getting Typeable for every type by default soon? do you know if we will still have to add Typeable constraints if we use it, or is this going the way of seq?
14:31:52 <Cale> I mean things like the implementation of the State monad.
14:32:20 <Cale> Most people won't be used to the idea of manipulating functions in quite that way when they come to that.
14:32:50 <FreeFull> You can't do monads without higher order functions
14:32:53 <joelteon> GHC, I love you, but sometimes your type inference really bones me
14:32:56 <monochrom> to save the day, the constraint "Typeable a" is still not automatic. if you see joy :: a -> [a], you still know that Typeable is not being used, even though a supports Typeable.
14:33:04 <jmcarthur> yay!
14:33:22 <toddaaro> hello, anyone able to help with a cabal problem on ubuntu 13.04 (there must be so many asking about that in this channel...). I successfully installed from source: apt-get for 7.6.2, make install on 7.6.3, make install on the haskell platform. I was then able to do cabal update, so I did a fresh install of cabal to get the updated version, then I added ~/.cabal/bin to my path, and now all cabal operations fail with "cabal: ghc: missing -B<dir> option"
14:33:26 <shachaf> Cale: You should configure your IRC client to show you when you're +o.
14:33:39 <Cale> shachaf: It is configured to show this
14:33:44 <shachaf> Oh.
14:33:59 <jmcarthur> why you waving your ops around?
14:34:06 <Cale> I don't know why I'm +o at the moment.
14:34:23 <donri> Cale: it sure looks manly, though!
14:34:37 <FreeFull> Cale: The person has stated before in comments that they did not want a Haskelly explanation of monads
14:34:43 --- mode: Cale set -o Cale
14:34:56 <Cale> FreeFull: I don't believe that the idea is all that useful in most other programming languages.
14:35:08 <copumpkin> I have some quote in lambdabot with a non-haskelly definition of monads
14:35:08 <Cale> Apart from languages with type systems which are about as powerful as Haskell's
14:35:32 <FreeFull> Yeah, having a good type system and do notation helps a lot
14:35:38 <Cale> The reason is that in order to be a useful abstraction, you need to be able to write code which will generically work in any monad.
14:35:49 <erisco> I have [A] and each A has [B]. I want to uniquely number all A and B ... zip [1..] bs is the basic approach for one list
14:36:00 <FreeFull> Automatic polymorphism
14:36:34 <Cale> and in order to do that, you need to be able to have code which is polymorphic in its result type -- which is hard for most OO languages, and pretty much impossible for anything dynamically typed
14:36:53 <Cale> i.e. where you select the monad instance based on how the code is used
14:37:01 <Cale> This is mandatory because of the type of return
14:37:30 <Cale> return :: (Monad m) => a -> m a -- this has an m in its result type which can't be determined from the parameter you give it, only from the context in which it's used.
14:38:00 <dwcook> @type return ()
14:38:00 <lambdabot> Monad m => m ()
14:38:13 <FreeFull> That isn't something you get in Java I think
14:38:19 <copumpkin> or Scala
14:38:21 <dwcook> @type return () ++ []
14:38:21 <lambdabot> [()]
14:38:34 <Cale> You'll want things like sequence to be polymorphic too, on account of the fact that they're written using return and bind.
14:38:39 <FreeFull> Scala does have monads
14:39:04 <Cale> So, basically, you need type (constructor) classes
14:39:07 <copumpkin> sure, but you can't make something like return that works right
14:39:10 <copumpkin> you always need to annotate it
14:39:27 <monochrom> Look at "Maybe Int". many languages now are polymorphic in the Int position, "Maybe t". few languages are polymorphic in the Maybe position, "m Int". this is why monad is less usable in most languages
14:39:29 <FreeFull> Typeclasses or something equivalent
14:39:46 <copumpkin> the thing that most people cite as being equivalent isn't really
14:39:55 <copumpkin> it gives a decent approximation for simple use cases
14:40:13 <Cale> Most implementations of "monad" in languages other than Haskell are either useless or horribly awkward, or both.
14:40:46 <monochrom> at this level we are not even getting into what kind of polymorphism (like type class? like Java class?)
14:41:07 <Cale> Yeah, monochrom has a good point there
14:41:15 <monochrom> just merely which position can be polymorphic
14:42:12 <Cale> It's rare enough to be able to write anything which is polymorphic over a type which has a type parameter, let alone being able to abstract over such things which support a given interface.
14:42:32 <donri> even haskell doesn't *quite* have "monads", though, does it
14:42:34 <toddaaro> anyone able to help with my "cabal: ghc: missing -B<dir> option" problem? that is the result of nearly all cabal commands
14:42:49 <Cale> donri: It does have monads on Hask.
14:43:01 <Cale> (i.e. on the category of Haskell types and functions)
14:43:19 <spaceships> so in foldMap with traverse: there is no need for mappend because (<*>), used to collect side effects, for Const is mappend?
14:43:29 <aristid> donri: to step that game up a bit: try finding a way to claim that Agda doesn't have monads :)
14:43:37 <FreeFull> donri: It has endofunctors on Hask and some of those are monads
14:43:41 <Sonarpulse> If the Networking package uses all the crazy GHC IO manager features, why does it attempt to mimick the posix sockets API?
14:43:57 <donri> aristid: well that's what i'm thinking of. haskell doesn't enforce the laws.
14:43:58 <geekosaur> toddaaro, do you by any chance have a $PATH pointing at the ghc lib directory?
14:44:09 <geekosaur> (don't do that, you can't run the stuff in there directly for the most part)
14:44:12 <aristid> FreeFull: endofunctors on Hask are things that have kind * -> *?
14:44:15 <Cale> FreeFull: Here's my monad tutorial which is really secretly aimed at people who write monad tutorials: http://www.haskell.org/haskellwiki/Monads_as_computation
14:44:27 <toddaaro> geekosaur: yes I do, is that what does this? is there a different directory I should point at for the executables?
14:44:34 <shachaf> aristid: Things which are (or can be made) instances of Functor.
14:44:41 <donri> the monad tutorial tutorial
14:44:49 <aristid> donri: oh i thought you referred to it being limited to one category
14:44:50 <donri> monads are like tutorials, you can have tutorials on them
14:44:51 <aristid> shachaf: ah
14:45:02 <geekosaur> there should be an actual bin directory somewhere. it contains scripts which run the actual ghc binary with options telling it where things live (so that it can be relocated easily)
14:45:08 <toddaaro> geekosaur: well, I thought I did, I've got "/usr/local/lib/ghc-7.6.3"
14:45:16 <Cale> FreeFull: It is important to express the reason why we want to be able to identify the structures which support these operations: so that we get access to a library of functions which operate in an arbitrary monad.
14:45:19 <geekosaur> so it should be in /usr/local/bin
14:45:21 <toddaaro> geekosaur: ok, I'll try that, thanks a bunch!
14:45:58 <Cale> Without that conclusion, that we get all the stuff in Control.Monad for free without having to write it by hand, being able to identify what's a monad is pretty pointless.
14:46:01 <FreeFull> Cale: Yeah, you're right
14:46:04 <toddaaro> geekosaur: yep, fixed the issue
14:46:14 <geekosaur> if you look in there, ghc will be a shell script which sets a bunch of options to tell ghc where its guts are
14:46:16 <aristid> i must have missed the change when (<$) became a method of Functor oO
14:46:34 <FreeFull> I don't know how to turn that from something someone wouldn't even try to understand to something that will be easy
14:46:46 <jmcarthur> we also can have monads on (* -> *) -> (* -> *), etc.
14:46:52 <FreeFull> :t (<$)
14:46:53 <lambdabot> Functor f => a -> f b -> f a
14:47:03 <aristid> jmcarthur: in haskell? they'd not be instance of Monad though then?:)
14:47:06 <FreeFull> :t fmap const
14:47:07 <lambdabot> Functor f => f a -> f (b -> a)
14:47:13 <jmcarthur> aristid: no, a different type class
14:47:18 <FreeFull> :t \a -> fmap (const a)
14:47:19 <lambdabot> Functor f => b -> f a -> f b
14:47:25 <jmcarthur> aristid: but that type class can generalize to a lot of other kinds through PolyKinds
14:47:33 <FreeFull> aristid: There, same type
14:47:41 <jmcarthur> aristid: basically anything of the form   (k -> *) -> (k -> *)
14:47:50 <aristid> FreeFull: ?
14:47:55 <jmcarthur> err
14:48:01 <Sonarpulse> I would understand if it was just a bunch of wrappers over the C
14:48:03 <jmcarthur> yeah that's right
14:48:11 <Sonarpulse> but it isn't at all.
14:48:11 <aristid> jmcarthur: sounds like something useful
14:48:16 <jmcarthur> it is!
14:48:36 <jmcarthur> (this is one of the definitions of indexed monads, btw)
14:48:42 <jmcarthur> (one of the more general ones)
14:49:01 <aristid> jmcarthur: you should make your own streaming I/O library with that and become rich and famous.
14:49:11 <jmcarthur> i'll pass
14:49:19 <jmcarthur> well, on the streaming library part :)
14:49:29 <aristid> :)
14:49:37 <Cale> FreeFull: My general approach is that if you don't want to learn either Haskell (or some other functional language with a powerful type system), or category theory, then there's not much point in bothering to try to understand what the monad abstraction is about, and you just shouldn't bother with it.
14:49:49 <jmcarthur> aristid: Tekmo's index-core actually is what i was just talking about
14:50:05 <aristid> jmcarthur: oh i wasn't aware of that
14:50:16 <jmcarthur> or one implementation of it
14:50:31 <Cale> It's a nice abstraction, but it's really not such a *huge* deal, and most programming languages aren't really able to take advantage of it.
14:50:32 <Twey> > zip [1 ..] $ as >>= ap (fmap . (,)) getBs -- erisco
14:50:33 <lambdabot>   Not in scope: `as'
14:50:33 <lambdabot>  Perhaps you meant one of these:
14:50:33 <lambdabot>    `a' (imported from D...
14:50:33 <FreeFull> Ok, which languages do monads properly?   Arguably Haskell, Unarguably Agda, Idris?
14:50:35 <jmcarthur> aristid: it's not polykinded though :(
14:50:39 <Twey> Er, silly me
14:50:41 <jmcarthur> aristid: but it should be
14:50:54 <Cale> FreeFull: Haskell does a better job than Idris and Coq, imo.
14:51:03 <companion_cube> OCaml can deal with monads, one at a time
14:51:04 <Cale> I don't know about the details with Agda.
14:51:14 <hiptobecubic> Why is it arguable for haskell?
14:51:14 <aristid> jmcarthur: pull request it. https://github.com/Gabriel439/Haskell-Index-Core-Library
14:51:22 <jmcarthur> companion_cube: ocaml's not very good at it, IMO
14:51:23 <Twey> Cale: Better than Idris how, exactly?
14:51:26 <FreeFull> hiptobecubic: Because Haskell doesn't check the laws hold
14:51:27 <erisco> Twey, what is ap?
14:51:28 <haasn> Haskell does Monad properly :)
14:51:32 <Cale> (The instance selection mechanism for typeclasses in Idris and Coq is flaky)
14:51:39 <Twey> erisco: ap is the Schönfinkel operator
14:51:42 <jmcarthur> Cale: agda is not much better than ocaml in this respect
14:51:44 <companion_cube> jmcarthur: not, but it does the job (see the monadic future libraries)
14:51:45 <haasn> FreeFull: oh, yes
14:51:45 <erisco> :t ap
14:51:46 <hiptobecubic> FreeFull, doesn't that restrict you to dependent types?
14:51:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:51:52 <Twey> (on functions)
14:52:06 <haasn> FreeFull: also haskell doesn't do a very good job of encoding arbitrary monads, only monads that are injective endofunctors over Hask or w/e
14:52:06 <erisco> ah
14:52:14 <aristid> jmcarthur: because agda doesn't have proper type classes?
14:52:14 <dwcook> Why is STM limited to GHC?
14:52:22 <dwcook> In practice, is this an issue?
14:52:24 <jmcarthur> companion_cube: if i can't write a decently usable polymorphic traverse, i'm not very happy with it
14:52:30 <aristid> dwcook: it's not limited to GHC oO
14:52:36 <Cale> haasn: Well, monads are endofunctors (usually, unless explicitly generalised)
14:52:54 <dwcook> Perhaps I was misled by this description: TChan: Transactional channels (GHC only)
14:52:57 <companion_cube> jmcarthur: it's not as convenient as hskell, but the abstraction is still definitely worth it
14:53:06 <Cale> I don't believe they'd have to be injective ones -- it's just a little tricky to express type constructors which aren't injective in Haskell.
14:53:13 <jmcarthur> aristid: well, type classes are one way to save it, sure. i think instance arguments could help, but i don't have the experience with them to say, and the standard library doesn't encourage them for monads yet anyway
14:53:27 <Cale> But the Monad typeclass should work fine even if the type constructor isn't injective.
14:53:41 <aristid> jmcarthur: the standard library monads in agda are also lawless :/
14:54:03 <jmcarthur> aristid: yeah, pretty disappointing there
14:54:05 <aristid> jmcarthur: the instance argument stuff is fairly limited btw
14:54:07 <merijn> dwcook: STM is limited to GHC because no other Haskell compiler has implemented STM at the moment
14:54:10 <Cale> Yeah, I suppose one downside to the encoding of monads in Haskell is that we can't represent the laws
14:54:21 <Cale> while in Coq or Idris, they can
14:54:28 <jmcarthur> aristid: yeah, i can't imagine instance arguments being all that great
14:54:32 <merijn> dwcook: on the other hand, no one tries to use a compiler other than GHC for production code atm either
14:54:34 <haasn> Cale: Hmm. Can type- or data families be instances of typeclasses (eg. Monad)?
14:54:42 <shachaf> jmcarthur: Most #haskell arguments aren't all that great.
14:54:44 <aristid> dwcook: no other haskell compiler is also really used by anybody at the moment. other than maybe the subset-of-haskell-to-javascript compilers.
14:54:49 <merijn> Well, except for Standard Chartered who implemented their own compiler :p
14:54:55 <dwcook> Hmm, I see.
14:54:56 <Cale> haasn: Should be possible. Closed ones would do better.
14:55:00 <shachaf> Oh, I guess that'd be #agda. Oh well.
14:55:08 <dwcook> Why are there projects like HUGS? Did they just happen to never get popular?
14:55:15 <merijn> aristid: Wrong, apparently the majority of Standard Chartered's code is now their own strict Haskell dialect
14:55:22 <aristid> merijn: meh.
14:55:32 <jmcarthur> dwcook: hugs is pretty old, and used to be more popular than it is now
14:55:33 <Cale> dwcook: Hugs used to be more popular
14:55:44 <fryguybob> dwcook: GHC's STM has support in the runtime system, so it isn't just a matter of building a haskell library with another compiler.
14:55:52 <merijn> dwcook: Hugs was veyr popular, at some point people just stopped maintaining it
14:55:58 <merijn> dwcook: Also, most of the stuff that made hugs popular was stolen by ghc(i) :p
14:55:58 <Cale> But it's written in C which means that Haskell programmers aren't *really* going to want to maintain it ;)
14:56:09 <watermind> jmcarthur: companion_cube: quite frankly I wouldn't say haskell is great at dealing with multiple monads either - although I've yet to read the recent paper on Extensible Effects (that seems interesting)
14:56:11 <aristid> merijn: sounds more like a haskell-inspired language than haskell if it's strict:)
14:56:13 <dwcook> Heheh.
14:56:19 <jmcarthur> merijn: SC's implementation has some really cool features, too!
14:56:42 <jmcarthur> watermind: i think the extensible effects stuff is way overblown, and i think haskell monads are underrated ;)
14:56:55 <aristid> monad transformers ftw :P
14:57:01 <Twey> jmcarthur: Overblown why?
14:57:27 <watermind> jmcarthur: why do you find it overblown? like I said I have't really read it yet, just skimmed, but seemed really nice
14:57:30 <jmcarthur> Twey: they limit you to one instantiation of each kind of effect at a time, and they only work for certain kinds of effects
14:57:33 <hpaste> Cale pasted “Monads in Coq” at http://lpaste.net/92758
14:57:50 <Cale> There's my beginnerish Coq code implementing monads.
14:58:03 <Twey> Hrm
14:58:05 <aristid> needs more unicode syntax
14:58:06 <Cale> (and proving that the laws hold)
14:58:17 <Cale> aristid: I *hate* unicode syntax.
14:58:32 <Cale> It's basically the only reason I don't play around with Agda more.
14:58:34 <jmcarthur> Twey: and while i am not familiar enough with them to use this as another point against them, i'm not sure how well they compose with existing monads
14:58:37 <erisco> :t fmap . (,)
14:58:37 <lambdabot> Functor f => a -> f a1 -> f (a, a1)
14:58:39 <watermind> jmcarthur: one instantiation? isn't it the point that you can work with multiple effects?
14:58:43 <jmcarthur> Twey: i imagine that part works alright
14:58:54 <Cale> The standard library needs to be forked and all the unicode syntax replaced with stuff that's not so RSI-inducing to type.
14:59:19 <jmcarthur> watermind: you can have different effects at once as long as they are not the same kind of effect
14:59:22 <aristid> Cale: it looks quite verbose somehow
14:59:37 <Cale> aristid: It is a little verbose, yeah.
14:59:37 <watermind> jmcarthur: ah right, I hadn't thought of that
15:00:06 <merijn> jmcarthur: I know, I heard Lennart talk about it a bit
15:00:23 <jmcarthur> yeah, that's how i know, too
15:00:32 <jmcarthur> not sure how much is public though
15:00:42 <jmcarthur> *truly public. of course it's public-ish
15:00:54 <Cale> aristid: There might be a way to avoid having to mention some of the implicit parameters. I'm not sure my usage there is optimal. When I wrote this the first time through, I just had all the parameters explicit.
15:00:58 <merijn> jmcarthur: I think that's how anyone knows :p
15:01:01 <watermind> jmcarthur: well... it is limiting, but that's bound to happen if you're simplifying the effect system
15:01:08 <Cale> (including all type parameters)
15:01:16 <Twey> jmcarthur: AIUI they're implemented as a monad
15:01:25 <ion> The “intros. induction l0. apply app_nil_l. simpl. … reflexivity.” stuff modifies some state, right? And you’re using an interactive program to pick the actions? Please excuse my ignorance, but couldn’t it add some kind of comments to the lines describing the state change?
15:01:30 <jmcarthur> watermind: right. i'm simply not convinced that the gains (what are they exactly? they seemed to small to me that i've forgotten) are worth the losses
15:01:32 <Cale> Because I didn't know what I was doing and had never (and still have never) read a Coq tutorial to figure that out.
15:01:32 <watermind> jmcarthur: problem being precisely that at times all those transformer layers are overwelming
15:01:36 <Twey> So they compose with other monad(-transformer)s as per usual
15:01:37 <jmcarthur> Twey: yes
15:02:00 <watermind> jmcarthur: code that is easier to write, read, and maintain?
15:02:09 <jmcarthur> Twey: well, the thing i don't know is whether it has to be a base monad (uses IO internally) or can be a transformer
15:02:10 <elliott> ion: most Coq proofs are pretty "unidiomatic".
15:02:22 <elliott> otoh the idiomatic ones can be pretty opaque too, but at least they're not so mechanical.
15:02:24 <erisco> :t ap (fmap . (,))
15:02:24 <lambdabot> Functor f => (a -> f a1) -> a -> f (a, a1)
15:02:33 <k00mi> jmcarthur: uh, I might misunderstand you, but you can have the same effect multiple times in your "stack" (like two environments/Readers)
15:02:41 <Cale> ion: The proofs are unreadable without the interactive environment
15:02:45 <jmcarthur> k00mi: i'm talking about extensible effects, not monad transformers
15:02:53 <k00mi> jmcarthur: I know, so am I
15:02:53 <shachaf> Could not deduce (?hi::w (a -> r) -> (w ((w (a -> r) -> r) -> r) -> r) -> r)
15:02:58 <Twey> Cale: Agda syntax isn't very RSI-inducing.  It might help to remap your backslash key :þ but in general it doesn't take much more effort to use a short Unicode symbol than a long ASCII symbol
15:03:05 <Cale> ion: If you step through them one line at a time in coqide, it'll make more sense what's going on.
15:03:07 <jmcarthur> k00mi: i thought you could only do that if the two readers are for different types
15:03:16 <k00mi> jmcarthur: that's correct
15:03:24 <jmcarthur> yeah, that's frustrating, to me
15:03:27 <Twey> Cale: I actually choose to use an Agda-like backslash method where I previously used a Compose key in some cases
15:03:32 <k00mi> but can you do that with monad transformers?
15:03:33 * hackagebot hub 1.2.0 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.2.0 (ChrisDornan)
15:03:33 <jmcarthur> with monad transformers i can at least disambiguate them
15:03:36 <jmcarthur> lift
15:03:47 <ion> cale: Ok, so you need more information (that coqide displays) than would fit in a comment to see what’s going on?
15:03:52 <Cale> Twey: I don't like how hard it is on my pinky finger
15:03:58 <watermind> jmcarthur: you can disambiguate with a newtype and lift your operations into it :P
15:04:04 <k00mi> hm, how does lift know what Reader I want?
15:04:12 <Twey> Cale: That seems like a limitation of your layout rather than the syntax
15:04:35 <Cale> I suppose, though it's odd to have a keyboard mapping where \ is anywhere near the middle of the keyboard :P
15:04:51 <jmcarthur> k00mi: lift has a precise definition. each lift "peels" off the top transformer. so if i peel off a reader then ask will use the next one below it
15:04:58 <Cale> ion: Yeah
15:05:04 <jmcarthur> k00mi: whereas if i didn't use lift then it would have just used the top one
15:05:12 <Cale> ion: I suppose you could write out the current goal as a comment on each line, which would help some.
15:05:16 <Twey> Cale: Mine is on the right ring finger, and it's comfortable enough.  You don't use it *all* the time, after all.
15:05:24 <Cale> ion: But to really fully interpret it, you need both the goal and context.
15:05:24 <ion> ok
15:05:28 <ion> aye
15:05:48 <Cale> ion: It's a really baroque sort of syntax for the lambda calculus which avoids mentioning variables a lot of the time.
15:06:02 <erisco> Twey, by A and B I meant to number them individually
15:06:03 <jmcarthur> k00mi: this notion of "peeling" is actually dual to the actual type of lift, of course, but it's a useful way of looking at it
15:06:24 <erisco> Twey, else I would just zip with [A]
15:06:37 <Cale> Twey: I dunno. I just have a standard QWERTY layout, and after a few hours playing around with Agda, my hands were sort.
15:06:40 <Twey> erisco: Yes; that's what the snippet I posted does
15:06:40 <Cale> sore*
15:06:57 <Twey> Cale: I see your problem :þ
15:07:17 <Cale> I'm not about to change keyboard layouts though :P
15:07:38 <k00mi> jmcarthur: I see, so I would have to use  lift . lift  to get the secound Reader
15:07:48 <erisco> Twey, ah I saw the type incorrectly
15:08:02 <Twey> Presumably you could tell emacs (or the Agda input method) to use something else as the escape character instead
15:08:16 <Cale> Yeah, maybe
15:08:22 <Twey> (though I think if you're using QWERTY you're asking for pain no matter what you do)
15:08:27 <Cale> I'd prefer just to have a new standard library though :)
15:08:33 <jmcarthur> k00mi: just one lift would be fine, if the first reader is on top
15:08:48 <Cale> Just elide all the \'s from what was typed for the most part
15:09:11 <Twey> Mmm
15:10:16 <Twey> Agda's Unicode syntax is nice because a) type signatures can get quite distractingly verbose, and squeezing more information into each character helps reduce that and b) you quickly run out of a specific type of character in ASCII, e.g. ‘bracket’ characters
15:10:30 <k00mi> jmcarthur: with monad transformers, can I write code that is polymorphic over the monad, with the requirement of two identical transformers?
15:11:06 <Peaker> Twey: there are significant drawbacks, too
15:11:12 <Twey> You could just remove the backslash, but you'd end up with a lot of things that look like ‘a minus b’
15:11:50 <Twey> Peaker: The one I run into most often is not knowing how to type a character and having to look it up with C-u C-x =
15:12:03 <jmcarthur> k00mi: i'm not sure what you mean. example?
15:12:07 <Twey> But even that's less of a barrier than I initially expected it to be
15:12:27 <Peaker> Twey: huffman encoding suggests that single letter should catch the most frequent things, and short sequences of letters would rarely be necessary, thus only making things longer by a bit
15:12:29 <jmcarthur> k00mi: i'm guessing you mean something like   (Monad m, MonadTrans t) => t (t m) a  ?
15:13:23 <Peaker> Twey: and having to learn to read/write more glyphs is a serious downside, even if post-learning, entering those glyphs isn't so bad
15:13:25 <Twey> Peaker: But Huffman encoding doesn't apply if you want your identifiers to be semantically meaningful
15:13:26 <erisco> Twey, I am still perplexed but thanks
15:13:39 <Twey> erisco: What are you perplexed about?
15:13:52 <Peaker> Twey: and there's the issue of many lookalike glyphs that are hard to discern
15:14:04 <Peaker> Twey: and issues regarding missing glyphs in various fonts in web browsers and other installations
15:14:09 <k00mi> jmcarthur: more like  (MonadReader1 m, MonadReader2 m) => m a, i.e. have two layers of the same transformer somewhere in the stack
15:14:11 <Twey> erisco: My understanding of your problem was that you had a [a] and a function a → [b], and you wanted to number every combination of a and b
15:14:18 <Peaker> Twey: and the inability to enter those glyphs in contexts other than the programming editor being used
15:14:39 <yitz> Twey: the way you type it is C-x 8 RET, then guess the beginning of its Unicode name and keep hitting TAB until you find it.
15:14:48 <jmcarthur> k00mi: where MonadReader1 and MonadReader2 read the same type?
15:14:48 <Peaker> Twey: IMO the downsides significantly outweigh the upsides (which I agree are there)
15:14:51 <Targen> I suspect Agda is nothing but a conspiracy to convert vim-using functional programmers to emacs.  How macabre.
15:15:08 <k00mi> jmcarthur: not necessarily, but possibly
15:15:16 <jmcarthur> k00mi: if they read different types, you can do it, if not, you have to distinguish the them in m be decomposing it into at least one of the transformers
15:15:30 <jmcarthur> *distinguish them in m by
15:15:38 <k00mi> jmcarthur: ok
15:16:12 <k00mi> then I can't see what those extensibel effects gain you either (in that regard)
15:16:14 <jmcarthur> k00mi: so it would look something like    (MonadReader A (t m), MonadReader B m) => t m a
15:17:06 <Twey> Peaker: The lookalike glyph issue is just a question of careful naming, and occurs with e.g. people who use ‘l’ and ‘I’ as identifiers in ASCII.  The rest are not Agda's fault; even the Agda input method is really just a convenience hack (frankly I think it's slightly ridiculous that modern operating systems still don't support a means of inputting mathematical notation in Unicode nearly twenty-two years after the standard was released)
15:17:25 <jmcarthur> my only point is that at least with monad transformers you can use the same mechanism you are used to using, whereas with extensible effects you have to sometimes switch to monad transformers anyway.
15:17:47 <yitz> Twey: emacs provides it
15:17:49 <Peaker> Twey: 'l' and 'I' are a problem, fortunately there are only a handful of such potential problems in ASCII.. Unicode gives us far more opportunities to shoot our feet
15:18:00 <jmcarthur> k00mi: also, my other point, to reiterate, was that extensible effects can't even capture all the effects that you can with monad transformers (Cont, for example)
15:18:26 <jmcarthur> k00mi: so overall i'm just not very enthusiastic, since the gains of using extensible effects are forgettable
15:18:28 <yitz> Twey: on Mac OS X you have the universally available Font dialog, though it can be a little awkward
15:18:28 <Twey> Peaker: Very true, but they're largely avoided in practice.  Except when bitonic is around.  ;)
15:18:40 <Twey> yitz: A Font dialog?
15:19:12 <Twey> That's not an input method, is it?
15:19:26 <Peaker> jmcarthur: the extra power transformers have over effect systems seems to be a showstopper to me..   ListT (t m)  vs:  t (ListT m)  is an important distinction.   So I find it weird so many prominent people I respect in the FP world are working on the effect system direction
15:20:02 <yitz> Twey: sorry, right, not that one. The Special Characters dialog.
15:20:14 <Cale> Peaker: I find that really weird as well.
15:20:29 <Cale> and I don't even particularly like monad transformers
15:20:35 <Twey> I thought I was just horribly misunderstanding that.
15:20:44 <watermind> jmcarthur: I'm not sure if I follow that argument (of sometimes having to switch to monad transformers)...  sometimes you implement a non-monadic function but then you have to switch to monadic code, and sometimes you start with just having a monad but than having to implement transformers and add layers
15:20:50 <Twey> yitz: What is it?
15:21:15 <Twey> yitz: You can enter ‘extended’ characters using sequences with the Option key, I think, but it requires some setup to be usable
15:21:36 <erisco> Twey, it is too clever for me :)
15:22:01 <Cale> watermind: Well, but the switch to using some monad will be nontrivial precisely because you'll have to encode all the information about ordering which wasn't present in the pure code.
15:22:15 <watermind> jmcarthur: it's all a matter of needs... sometimes all those layers you need to peel are useful, sometime they just make reasoning about the code harder
15:22:18 <yitz> Twey: the fn keys does something too. i never learned about all that stuff. i usually just use emacs when i need unicode characters that i don't know how to type.
15:22:43 <Twey> erisco: Pointedly, it's: zip [1 ..] [ (a, b) | a ← as, b ← getBs a ]
15:22:49 <k00mi> jmcarthur: if m is MonadReader, isn't (t m) aswell for all t?
15:23:00 <k00mi> so would that really require a second Reader layer?
15:23:11 <Twey> yitz: *nod* That's why the Agda input method exists.  :þ
15:23:15 <erisco> Twey, that I can understand
15:23:35 <Cale> Either you do that work all the time, up front -- and have to worry about sequencing even in code which you intend to be pure, because it might not always be so, or you allow for it to be deferred (as we do in Haskell), and sometimes have to pay up later.
15:24:28 <erisco> Twey, thanks
15:24:35 <Twey> erisco: No problem ☺
15:24:52 <Peaker> Kinda funny cause Haskell is known for making you pay a bit more up-front to save costs later (thinking out good types to model your problem)
15:26:53 <jmcarthur> k00mi: they can be different kinds of readers
15:29:37 <yitz> k00mi: transformer libraries provide an automatic instance of MonadReader for t m for certain values of t. but the library author wrote out those instances by hand - it's not automaicly true.
15:31:37 <k00mi> I see, thanks
15:41:17 <ocharles> mm_freak_: starting a little SDL framework for netwire
15:41:35 <erisco> I can't think of how I can possibly construct this structure between Rule and Prod http://lpaste.net/92759
15:42:00 <ocharles> mm_freak_: taking some hints off your gloss clock, I'm building up a 'Scene' which will be able to view differences between frames to minimize redrawing. then as scenes are a monoid, you should be able to build scenes up really fluidly
15:42:05 <erisco> in mutable land it would be trivial... at a loss otherwise
15:42:06 <ocharles> (and wires are monoids so you don't really have to think about wires at all)
15:42:43 <erisco> need [Prod] to make Rule, but each Prod needs Rule
15:43:29 <erisco> so perhaps I can't have prodRule be of type Rule... perhaps RuleID rather
15:45:30 <erisco> bleh have a rough idea of what might be done
15:47:12 <Twey> erisco: Generally, having some sort of unique identifier inside the data-type is an antipattern in Haskell
15:47:52 <erisco> Twey, what do you mean?
15:47:54 <Twey> It's better to just talk about the interesting data, then add IDs externally (via tuples or some other data-type) as necessary
15:48:27 <Peaker> Twey: I don't think that is workable in the general case
15:48:43 <Peaker> and it may add partiality (e.g: duplicating same sums "outside" of the type as you have inside it)
15:48:48 <erisco> well the issue isn't about the ids it is about the circular reference
15:48:55 <erisco> but after some more thought I think I can fix that
15:49:34 <Twey> erisco: The same applies, I think: have a [(Rule, [Prod])]
15:50:12 <Twey> Unless Prods may exist without a Rule, in which case you can use a [(Maybe Rule, [Prod])]
15:50:34 <Twey> (or better, Set (Maybe Rule, Set Prod))
15:50:46 <erisco> no I can make it work I think
15:50:53 <Twey> Peaker: What ‘sums’ do you mean here?
15:51:19 <erisco> > [1..2]
15:51:20 <lambdabot>   [1,2]
15:51:50 <Peaker> Twey: data Foo = Foo { ... Either (SomeId, a) (OtherId, b) ... }
15:52:07 <Peaker> Twey: if you try to move "SomeId" and "OtherId" outside of Foo into some tuple or such, it will need to add partiality
15:52:20 <erisco> Twey, I dunno, it may be pointless later on, so I'll keep it in mind
15:53:28 <Twey> Peaker: Wouldn't you move the whole Either out and parameterize the type, Either (SomeId, Foo a) (OtherId, Foo b) ?
15:54:24 <Peaker> Twey: but then you're moving other fields of Foo into the Either
15:54:56 <Peaker> Twey: this kind of encoding is going to cost you -- why not just have the id's inside Foo?
15:55:19 <haasn> setup: At least the following dependencies are missing: base >=4.2 && <4.6
15:55:21 * haasn cries
15:56:07 <Twey> Peaker: I'm not sure why I'd have an Either'd ID like that anyway; I suspect it's a substantially different use-case than the one I was thinking of (in which each distinct element is identified by a unique ID, rather than by uniqueness of its properties)
15:57:13 <Redz> is there a way to use guards in an expression far away from toplevel?
15:57:22 <Twey> Redz: where, or case
15:57:37 <Twey> Redz: case () of () | pat → res; …
15:57:40 <Peaker> Twey: We have a type inference engine where each subexpression in each inferred value/type has its own identity, and identities can be unified and such. AST elements refers to identities, and there are various structures with referrals to identities of other structures. I've never heard the claim that this kind of thing was an antipattern, and I don't see the reason it would be
15:57:48 <Twey> Redz: Or the recent extension, MultiWayIf
15:57:52 <erisco> Twey, I can say   rule = Rule ... productions; productions = [Prod ...  for example to get the circular ref
15:58:09 <erisco> this only seems to work in a one to many fashion
15:58:15 <Twey> erisco: I'm not saying you can't, just that it's a bad idea
15:58:21 <erisco> Twey, why?
15:58:32 <Twey> Just experience
15:58:54 <erisco> so you would rather (Rule, Prod) ?
15:59:06 <erisco> flatten it out as it were?
15:59:42 <erisco> the structure gets even more complex... each Prod has a list of ProdPart, and unfortuantely a ProdPart can also have a Rule :P
15:59:51 <Twey> Peaker: In GHC, you mean?
16:00:01 <erisco> I set this up without a Haskell mindset it seems
16:00:07 <Peaker> Twey: no, in Lamdu
16:00:26 <Redz> Twey: thank you. the alternative case pattern seems suitable.
16:00:29 <yitz> Redz: or let
16:01:00 <erisco> Twey, but I can assign ids to everything before constructing the actual data
16:01:03 <Peaker> Twey: when "mutability" is a useful part of the algorithm, identities are important, and then I don't see why it'd be an anti-pattern to use those identities in arbitrary positions inside data structures
16:01:08 <Twey> Peaker: I usually see it where people come from OO languages with object identity, and want to simulate it in Haskell.  I'm not denying that there are cases where it's plausible, but I think it's something to be wary of for newbies.
16:01:15 <erisco> Twey, and can resolve the data through a Map or something
16:01:31 <haasn> mgsloan: how come GtkInteractive doesn't export ‘display’?
16:01:36 <haasn> (in toy-gtk)
16:01:40 <haasn> I can't seem to define my own instance..
16:01:45 <Peaker> Twey: sure, it can be over-used, as type-classes are, for example.. going as far as "defining new type classes is an anti-pattern" might be a bit much though :)
16:02:00 <Twey> True that :þ
16:02:05 <Twey> Poor choice of phrasing, sorry.
16:02:19 <mgsloan> haasn: GtkInteractive is a constraint synonym
16:02:36 <Twey> erisco: I don't know what you're trying to do, sorry.  Perhaps you'd care to explain the use-case a bit more?
16:02:36 <mgsloan> haasn: GtkDisplay does export "display", tho!
16:02:38 <haasn> oh, I just saw that myself
16:02:40 <yitz> Peaker: in my opinion classyprelude - where *everything* becomes a type class - is an antipattern.
16:03:06 <mgsloan> haasn: Glad someone's trying out that stuff!  Let me know if there're any tweaks you'd make / pull requests / etc
16:03:13 <haasn> oh no! Couldn't match expected type `gtk-0.12.4:Graphics.UI.Gtk.Types.DrawingArea' with actual type `gtk-0.12.4:Graphics.UI.Gtk.Types.DrawWindow
16:03:14 <erisco> Twey, this is the full structure: http://lpaste.net/92760
16:03:33 <erisco> Twey, that I was intending anyways... and then found out what a pain it would be to construct
16:03:33 <haasn> mgsloan: I guess I messed up badly?
16:03:45 <haasn> mgsloan: I just want to implement String -> IO () -- what's the simplest way?
16:03:45 <leroux> Oh, this is great. http://ro-che.info/ccc/22
16:04:08 <Peaker> yitz: I haven't tried it -- and it might go too far. But I think it's fair to say standard Prelude and most libraries don't go far enough..  lens ecosystem might rectify this
16:04:09 <haasn> mgsloan: here's what I thought http://bpaste.net/show/130664/ but apparently that isn't correct
16:04:18 <Twey> erisco: Is this an encoding of the T → x | y | z grammar notation?
16:04:24 <erisco> Twey, yes
16:04:47 <Peaker> yitz: I love "At" and some of the classy prelude classes ended up as lens classes too ("Map" -> "Each").
16:05:11 <Peaker> "At" and "Contains" kill so much of the Data.Map/Data.Set api's in one stroke
16:05:49 <erisco> Twey, right now my thought is that I can relax prodRule :: Rule to prodRule :: RuleID and RuleRef Rule to RuleRef RuleID
16:05:50 <Twey> erisco: Context-free?
16:05:54 <erisco> Twey, yes
16:06:22 <erisco> Twey, and I would relax them as so because I can calculate the IDs before constructing Rule, Prod, or ProdPart
16:06:46 <erisco> and as you can see I intend there to be RuleID -> Rule and ProdID -> Prod mappings, so resolving the ids back to the actual data can be done
16:06:50 <Peaker> erisco: do you have "mutability" here, where you want a change to a Prod be visible to multiple rules who all point at that Prod?
16:06:59 <mgsloan> haasn: There's two ways to do it.  The one I usually use is "defaultDisplay", and make an instance of Diagrammable.  I wrote this code before default method signatures, so I probably aught to make that a default
16:07:21 <mgsloan> haasn: The other way is to use "displayDiagram yourDiagram"
16:07:28 <haasn> I don't have defaultDisplay or displayDiagram
16:07:31 <erisco> Peaker, I did not intend any mutability, but I did come up with this model assuming the conveniences of mutability
16:07:43 <erisco> Peaker, ie I do not want mutability
16:07:44 <haasn> mgsloan: what packages are those defined in?
16:07:51 <Peaker> erisco: if you don't need mutability you can just define everything with actual pure references rather than explicit identities
16:08:04 <Peaker> erisco: as a cyclic data structure
16:08:06 <mgsloan> haasn: This one https://github.com/mgsloan/toy-gtk-diagrams  also check out these: https://github.com/mgsloan/toy-gtk-diagrams/tree/master/Examples
16:08:12 <erisco> Peaker, what do you mean?
16:08:43 <erisco> Peaker, I do not know how to construct the cyclic parts aside from the one-to-many of Rule to Prod
16:09:05 <haasn> mgsloan: oh god, this is a dependency nightmare
16:09:11 <haasn> I don't even have diagrams-contrib ;_;
16:09:29 <mgsloan> haasn: Yeah, toy and diagrams are both split among a few different packages
16:09:31 <haasn> mgsloan: it requires lens <0.10 is that intentional?
16:09:33 <hpaste> Twey revised “No title”: “CFGs (fixed)” at http://lpaste.net/92760
16:09:44 <Twey> erisco: Something like this?
16:10:11 <mgsloan> haasn: Less than 3.10, yes
16:10:39 <haasn> mgsloan: have you tested it with 0.10?
16:10:42 <Peaker> erisco: oh, mutability is not the only reason you might need explicit identities. You might need to be able to discover cyclic references, and stop your loop. Do you need this ability?
16:10:43 <erisco> Twey, no
16:11:00 <Twey> erisco: Why not?
16:11:18 <mgsloan> haasn: I haven't.  I didn't realize that the head version of lens was 3.10
16:11:18 <Twey> That is, what algorithms are you using that would be unsuitable for that representation?
16:11:33 <erisco> Twey, sorry I missed that Production was a list
16:11:36 <haasn> mgsloan: ok. I'll test it and let you know once I manage to get diagrams-contrib to build
16:11:41 <mgsloan> Thanks!
16:11:48 <Twey> erisco: So did I, once ;)
16:11:54 <yitz> Peaker: i had to deal with a lot of code in our codebase that someone "upgraded" to classy prelude. it was a major loss of information that made it far less readable and maintainable, imo.
16:12:13 <Twey> Huh, did I nuke your paste?
16:12:27 <erisco> Twey, well other than Production needs a name, this is roughly equivalent, but simply removes the cyclic references
16:12:29 <geekosaur> yep
16:12:44 <Twey> Why does that happen?  ☹
16:12:46 <erisco> Twey, and relies on [Char] equivalence ... which is what I'd do with the ID anyhow
16:12:56 <geekosaur> you used the wrong link
16:13:00 <Peaker> yitz: I partially blame the IDE situation though.  We only like monomorphic functions because when we have mono-types, we can't see that they are mono when used with generic functions. But good IDEs could make this apparent
16:13:05 <Twey> Seems a bit unsafe
16:13:23 <geekosaur> edit and annotate are different things. and yes, I kinda wish the edit page had a big warning on it
16:13:24 <yitz> Peaker: the prelude definitely needs a facelift though. basicprelude is a good first step. i just think classyprelude is a bad second step.
16:14:10 <geekosaur> or maybe it should be immutable like haskell :p
16:15:30 <yitz> Peaker: i dunno. the beauty of haskell is its type system. knowing the exact type of each symbol, without a research project - or relying on an external ide - adds a huge amount of expressiveness to haskell code and is for me one of its major advantages.
16:17:18 <Peaker> yitz: OTOH, having code monomorphic to strict or lazy bytestrings for no good reason is very annoying
16:17:22 <merijn> Peaker: If you blame the IDE situation, get back to coding! ;)
16:17:23 <erisco> geekosaur, then you could not annotate either
16:17:25 <Ghoul_> best way to replace all of one thing in a list with another?
16:17:29 <erisco> geekosaur, without generating a new url :)
16:17:33 <Ghoul_> I've been using map but there's probably a better way
16:17:34 <Peaker> merijn: :-)
16:17:39 <geekosaur> but that's what annotate does!
16:17:50 <Peaker> yitz: also, stealing tons of names for various monomorphic instances rather than just 1 name is also bad
16:17:50 <erisco> nope same url
16:17:53 <mgsloan> haasn: Actually, ignore those examples, unfortunately - things changed a while back (new diagrams, namespace changes, etc) and I still need to update them
16:17:53 <Twey> erisco: The nameless representation would be soething like http://lpaste.net/92760
16:17:55 <geekosaur> noty exactly
16:17:57 <Twey> something**
16:17:59 <bergmark> Ghoul_: better in what way?
16:18:08 <Ghoul_> a more *proper* way maybe
16:18:13 <geekosaur> you can go to the annotation directly; the link is the url is original#rannotation
16:18:17 <Ghoul_> there doesn't seem be a function called `replace` though
16:18:20 <geekosaur> but you can go directly to annotation
16:18:20 <Peaker> merijn: I took on a short-term contracting project that's going to postpone my Lamdu work for a month or two :-(
16:18:51 <yitz> Peaker: not to me. first of all, you just change the import. second - in my experience the lazy/strict distinction is usually significant and worthwhile to be easily visible in the code.
16:19:05 <Twey> erisco: (would be helpful if you could repaste the original, sorry — didn't realize I λpaste had no access control :þ)
16:19:16 <yitz> Peaker: the names are not stolen. use qualified imports.
16:19:27 <geekosaur> sory, it's a<post> not r<post> in the chain
16:19:32 <geekosaur> it's kinda weird
16:19:45 <merijn> Peaker: I did the opposite, I recently found an interesting phd position which will hopefully let me invest more time into haskell coding on my various projects \o/
16:19:51 <erisco> Twey, sure, done
16:19:53 <Peaker> yitz: Qualified imports effectively annotate the type everywhere -- which may be too verbose. an IDE can annotate better than that
16:19:53 <Twey> erisco: (and type Grammar = Rule if you want)
16:19:54 <enthropy> merijn: you did robotics with haskell at some point?
16:19:55 <merijn> Peaker: This is, of course, assuming I actually get the job >.>
16:20:06 <yitz> merijn: oh that's great news!
16:20:07 <Peaker> merijn: cool :)
16:20:17 <merijn> enthropy: Nope?
16:20:24 <erisco> Twey, I can take it from here I think
16:20:30 <enthropy> ok
16:20:35 <Peaker> yitz: and take Data.Binary for example, I sometimes want to generate a lazy bytestring, sometimes strict, Data.Binary itself should not really care which is generated in many cases
16:20:36 <bergmark> Ghoul_: seems proper to me :) don't think there's anything more specific in base
16:20:49 <merijn> Peaker: And if I don't, I'll be unemployed, so I'll still have all the time to work on Haskell!
16:20:54 <merijn> Peaker: It's win-win! ;)
16:21:05 <Twey> erisco: You haven't related this back to your original question, though :þ
16:21:18 <erisco> how not?
16:21:20 <Ghoul_> ok
16:21:29 <erisco> you've removed the cyclic parts as the solution
16:21:33 <erisco> I was proposing the same thing
16:21:34 <yitz> merijn: not if i can help it. but haven't heard back yet... need to ping those guys.
16:21:35 <NemesisD> how do i negate flags with cabal?
16:21:55 <NemesisD> theres a flag "previewServer" and i'm trying to turn it off
16:22:30 <NemesisD> ah its just -
16:22:32 <Twey> erisco: You saw the cyclic version too, right?
16:22:37 <haasn> mgsloan: shame, diagrams-contrib doesn't build under lens 0.10
16:22:42 <haasn> so that rules out your package working :)
16:22:44 <Peaker> merijn: heh, if you become unemployed, you'll probably be employed at seeking Haskell jobs
16:22:49 <mgsloan> haasn: :/
16:23:11 <haasn> and there goes one and a half hours of my otherwise fine day :P
16:23:13 <ekipan> the other day I accidentally edited someone's paste instead of annotating, but I recovered it from the raw
16:23:18 <erisco> Twey, yes but I have no way to construct it
16:23:22 <ekipan> which doesn't seem to change
16:23:33 <erisco> Twey, the one-to-many approach doesn't apply to ProdPart/Either Rule String
16:23:43 <Twey> erisco: It's okay to construct things like: let xs = Rule $ Set.fromList [Production [Right "x", Left xs]]
16:23:52 <Twey> … in xs
16:24:12 <erisco> yes but that is a one-to-many... one xs to many productions
16:24:20 <yitz> Peaker: hmm. you do binary stuff more than me. but whenever i've used binary, it *did* matter whether the bytestring is lazy or strict. and the part of the code that just describes the serialization format is generic, just change the import.
16:24:29 <erisco> but that Rule is not necessarily the same Rule that owns Prod
16:24:55 <Twey> erisco: It doesn't have to be; you can name any rules you like
16:25:05 <Twey> ekipan: Haha, oh yeah!
16:25:21 <erisco> Twey, I do not know how to name it
16:25:23 <Peaker> yitz: no.. Data.Binary is (necessarily) hard-coded to a specific ByteString type
16:25:25 <erisco> or to get the "it"
16:25:47 <Peaker> yitz: and if you have Data.Binary.Strict/Data.Binary.Lazy (which don't exist now) then you get a cartesian explosion of library modules
16:26:10 <yitz> Peaker: yes i remember that problem
16:26:11 <Twey> erisco: let xys = Rule $ Set.fromList [Production [Right "x", Left yxs]]; yxs = Rule $ Set.fromList [Production [Right "y", Left xys]] in xys
16:26:28 <erisco> Twey, I have an arbitrary number of rules
16:26:44 <NemesisD> parallel cabal build jobs makes my laptop smell funny
16:26:45 <Twey> erisco: Sure, that's why Production takes a list
16:26:59 <Twey> You have only one starting rule
16:27:46 <erisco> Twey, I do not see how this answers the problem with constructing Left
16:28:09 <Twey> erisco: Would you like to post a grammar you think can't be constructed in this way?
16:28:21 <erisco> Twey, if that is your question you've missed my point
16:28:24 <Peaker> yitz: so either you lose convenience/performance (conversions everywhere) or you blow up in a cartesian way,  or you use type-classes (which I prefer). Maybe there are other/better options
16:28:35 <Twey> I may have missed your point
16:28:35 <erisco> Twey, the rules are *arbitrary*... I do not know at compile time
16:28:54 <Twey> Okay
16:29:15 <Twey> So you can use a list in the ‘let’ as well, and refer back to it
16:29:24 <mgsloan> haasn: Sorry about that
16:29:26 <erisco> but how do I construct said list?
16:30:04 <mgsloan> haasn: I haven't had much time for making toy release worthy, which is why it's not on hackage yet
16:30:16 <Twey> From whatever input you get at runtime, I'm guessing?
16:30:25 <erisco> Twey, I suppose if I could use indexing (ie !!) then maybe I could rig something together
16:30:26 <haasn> mgsloan: yeah fair enough, caused me a great deal of pain pulling all of those deps from your github page manually :P
16:30:32 <haasn> mgsloan: life was so much simpler when it was one package :)
16:30:38 <Twey> Presumably the input has names (or you would need infinite input)
16:31:02 <mgsloan> haasn: Well, the idea is that gtk / cairo deps are painful for people, and therefore if there were other backends we wouldn't want them
16:31:04 <Twey> You can build the named form from that, and convert to the cyclic form
16:31:15 <mgsloan> haasn: But there aren't other backends, so yeah, maybe a bit pointless
16:31:32 <mgsloan> haasn: This is what mgsloan/toy-sources is for, though - it pulls and builds all the repos
16:31:40 <mgsloan> haasn: Same for diagrams/diagrams-sources
16:32:17 <mgsloan> haasn: I recommend using cabal-dev or hsenv - they make this kind of pain go away
16:32:49 <erisco> Twey, I'll have to puzzle from here. thanks for your help
16:33:02 <beefcube> how do I convert from a function with type Either a b to EitherT within do notation for EitherT?
16:33:07 <haasn> mgsloan: I'd prefer to keep things consistent
16:33:13 <haasn> mgsloan: I use portage for managing packages
16:33:31 <haasn> it's just that sometimes a bit of manual upkeep is required because gentoo-haskell doesn't have infinite manpower :(
16:34:10 <pavonia> @src EitherT
16:34:10 <lambdabot> Source not found. :(
16:35:10 <mgsloan> haasn: I imagine!  I can certainly see that being handy for lib dependencies and such
16:36:42 <pavonia> beefcube: EitherT . return, I guess
16:37:19 <beefcube> just found it XD, don't really understand that though
16:39:08 <pavonia> beefcube: return "lifts" the Either value into the monad required for the monad insatcne of EitherT, and EitherT makes it an value of type EitherT
16:39:17 <pavonia> *instance
16:43:17 <beefcube> ah, EitherT { runEitherT :: m (Either a b) } was confusing me, but it looks like its acting as a constructor in that case, gotcha
16:43:25 <beefcube> it's*
16:43:49 <pavonia> it *is* a constructor
16:44:58 <pavonia> you could also write EitherT { runEitherT = return myEitherVaue }, but that's overly verbose
16:45:06 <shachaf> thoughtpolice: Any chance of #7633 getting into 7.8?
16:46:05 <thoughtpolice> shachaf: definitely possible. i can look into it perhaps
16:46:08 <thoughtpolice> shachaf: or you could!
16:47:32 <shachaf> thoughtpolice: What can I do to help?
17:03:38 <hpaste> Twey annotated “No title” with “erisco's CFG name-removal” at http://lpaste.net/92760#a92766
17:06:07 <hpaste> Twey revised “erisco's CFG name-removal”: “erisco's CFG name-removal, happy HLint” at http://lpaste.net/92766
17:14:07 <Twey> λpaste's edit is weird and broken
17:14:41 <Twey> Not only does it allow you to overwrite anyone's paste and not update the raw, edits to annotations become separate pastes (and don't update the annotation)
17:15:19 <Twey> But annotations to pastes resulting from an edit to an annotation are annotations to the original paste.
17:17:40 <serban> Hey, i have a custom type list as a parameter for a function
17:18:06 <ekipan> seems to me it'd be easiest to delete this broken edit feature
17:18:20 <serban> let's say the type is called Point, the parameter is [Point] and the function gets another Point, which I want to add to the head of the [Point] list and return it
17:18:23 <serban> any ideas?
17:18:52 <ekipan> :t (:)
17:18:53 <lambdabot> a -> [a] -> [a]
17:18:56 <Twey> serban: Erm, f p ps = p : ps
17:19:02 <mauke> serban: what's the problem?
17:19:04 <Twey> serban: Also known as f = (:) :þ
17:19:23 <serban> ty:))
17:22:10 <jfischoff> is there a way to make substitution fast with free monads? Perhaps with a zipper like thing?
17:22:33 <jfischoff> I was thinking "Why walk when you can take the tube?" might be relevant
17:26:40 <serban> ah, not that, i knew that, although i'm a noob:)) how do i call the list from the signature? blah :: Point -> [Point] -> [Point] // Point is a custom type
17:27:17 <serban> eg blah Point x y [what?] = (Point x y) : [what?]
17:27:41 <ekipan> (Point x y) in parentheses
17:28:10 <ekipan> otherwise its three seperate patterns: the nullary constructor Point, and two seperate variables x and y
17:28:16 <geekosaur> and you can call the [what?] whatever you want
17:29:33 <Twey> serban: In this case you don't need to call it anything because you're not deconstructing it, but in general you need to bracket multi-word patterns, e.g. blah (Point x y) points = Point x y : points
17:29:57 <ekipan> it's customary to name list variables in plural
17:29:57 <Twey> (but here it's the same as: blah point points = point : points, which is not really worth defining a function for)
17:30:33 <joelteon> > "A\822B\822C\822"
17:30:34 <lambdabot>   "A\822B\822C\822"
17:30:37 <joelteon> aw
17:30:38 <serban> aha, thanks
17:31:03 <ekipan> indeed: blah = (:)
17:33:17 <Twey> > text "A\822B\822C\822"
17:33:18 <lambdabot>   A̶B̶C̶
17:33:36 * hackagebot unix-bytestring 0.3.7 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.7 (WrenThornton)
17:33:58 <Twey> joelteon: λb renders PrettyPrint documents nicely
17:34:03 <mauke> Y̶E̶S̶.̶
17:34:06 <joelteon> oh
17:34:17 <joelteon> is it my terminal's fault that it displays those characters on top of each other?
17:35:06 <joelteon> because chrome seems to display it fine
17:36:10 <mauke> on top how?
17:36:38 <joelteon> it draws an a, then draws a b in the same place, then draws a c in the same place
17:36:40 <joelteon> so they look like a blob
17:37:01 <mauke> sounds like a bug in your client or terminal, yes
17:37:14 <mauke> definitely terminal
17:37:26 <joelteon> it's iterm
17:37:27 <mauke> a misbehaving irc client couldn't achieve blobness by itself
17:37:29 <joelteon> terminal can do it
17:37:34 <joelteon> damn
17:38:42 <Twey> joelteon: My terminal (Terminal) does it fine
17:38:50 <joelteon> yeah, terminal can draw it
17:38:53 <joelteon> iterm can't
17:38:59 <joelteon> OR it might be my font...
17:39:42 <Twey> Oh, I meant xfce4's Terminal, not the Mac one
17:39:46 <Twey> Apparently there's an iTerm 2 now
17:40:04 <joelteon> ahhh, it's Consolas!
17:40:29 <joelteon> time to switch
17:49:06 <serban> question2: what do i need to derive to be able to use list functions on my data type? i currently have data Blah = Blah [Point] deriving (Show)
17:49:22 <serban> (eg head , etc)
17:49:24 <shachaf> Are you reading some introduction to Haskell?
17:49:41 <shachaf> I think a lot of your questions would be easier to answer with some more background.
17:50:32 <serban> i went through learnyouahaskell.com, but i jumped right to it, please excuse me if I bothered
17:50:57 <geekosaur> serban, you don't derive anything for lists, they're lists
17:51:11 <geekosaur> they're a type, not a typeclass
17:51:38 <shachaf> Well, you might benefit from not jumping right to it -- the book answers a lot of questions.
17:51:41 <Twey> serban: You can have a list of any type.  Some functions may impose additional requirements on the type inside the list, though — e.g. sort requires Ord
17:51:48 <shachaf> Anyway, you can't make "head" work on your type.
17:52:03 <Twey> Oh, on your own data-type.
17:52:04 <shachaf> (But you shouldn't be using "head" in the first place. It's not a good function.)
17:52:59 <serban> ok, back to the drawing board:))
17:53:29 <S11001001> serban: There are *certain* "list" functions that are actually more broadly applicable than to "list".  lyah talks about them.  Part of thinking about your type definitions is figuring out which ones you can support correctly
17:54:24 <geekosaur> my guess is they did data Foo = Foo [something] and now want to magically go "though" the Foo.
17:55:00 <Twey> Sounds like a job for Traversable
18:09:41 <joelteon> so, correct me if I'm wrong, but rex patterns are designed to be used over the whole string, right?
18:12:27 <dfan> The head of a Blah [Point] would be a Blah Point, which doesn't exist, anyway
18:13:04 <Twey> dfan: Surely it makes sense as Blah [Point] → Point
18:13:44 <Twey> I don't think it was intended to be fmap head
18:13:51 <dfan> Fair enough
18:13:55 <Twey> … and, er, Blah doesn't have a parameter
18:14:53 <dfan> Yeah, I meant head of a Blah wouldn't be a Blah, but you're right, it could be defined to be a Point
18:15:41 <dfan> If that's what he wants, maybe he just wants Blah to be a newtype
18:18:26 <Twey> dfan: I think it is.  serban was confused because f ∷ Blah doesn't give head f ∷ Point.
18:19:09 <Twey> Oh, did you mean it should be a type alias?
18:23:11 <dfan> Yeah, possibly, if he wants to be able to use lots of list functions on it
18:23:19 <simon> does anyone know the LaTeX code for those [[ ]]-like braces used in formal semantics?
18:24:22 <dfan> simon: http://tex.stackexchange.com/questions/18304/double-square-braces-like-these-exp
18:24:39 <simon> dfan, thanks!
18:24:44 <Twey> simon: You mean the ‘meaning’ braces, ⟦⟧?
18:25:05 <haasn> simon: \llbracket \rrbracket
18:25:08 <haasn> I think
18:27:32 <simon> Twey, yup. thanks all :)
18:31:23 <niteria> can two packages share a sandbox with cabal sandbox?
18:31:45 <kloplop321> Has anyone else had problems with hackage lately linking to file:// ?
18:33:12 <pharaun> i have noticed that
18:33:12 <Gracenotes> well, there have been such problems
18:33:23 <Gracenotes> might be to do with new cabal, perhaps?
18:33:34 <niteria> oh, I guess add-source is what I'm looking for
18:44:11 <danilo2> Can I make in haskell an instance of a typeclass, which will define a function FOR ANY type, which is not function? I mean sometihng like: instance Get a where get x = x, but "a" should not allow for (x->y->...)
18:45:13 <Twey> danilo2: No
18:45:32 <danilo2> Twey: ok, thank you :)
18:46:12 <Twey> danilo2: You can't talk about ‘any type except <foo>’ in Haskell, in general
18:46:22 <Makoryu> danilo2: If you do stuff with GADTs instead of typeclasses, you can restrict it to particular types
18:46:25 <Twey> (and I would question your motive for trying to do so)
18:46:40 <Makoryu> Alternatively you could do "get :: Eq a => a -> a"
18:46:53 <Twey> You can restrict typeclasses to particular types, too :þ
18:46:56 <Makoryu> Since Eq instances don't really work for functions
18:47:01 <Twey> That's the opposite of the qeustion, though
18:47:09 <Twey> Makoryu: But functions aren't the only things without Eq instances.
18:47:11 <danilo2> Makoryu: oh, that is interesting
18:47:16 <Twey> question**
18:47:21 <Makoryu> Twey: True, but this is a cheap hack anyway :p
18:47:51 <Makoryu> danilo2: I'm curious why you're trying to do this, and what your actual goal is
18:47:55 <lukexi> is there a flag i'm missing to tell cabal not to build executables/to only build the library?
18:47:59 <danilo2> Makoryu: Ok, but with GADT's I will be able to restrict instances to **not functions** ?
18:48:04 <Twey> instance Eq (a → b) where _ == _ = True -- what do you mean?  Eq works fine for functions :þ
18:48:20 <danilo2> Makoryu: I was waiting for this question :D So I'm just hacking :)
18:48:40 <Makoryu> danilo2: You would be able to restrict instances to the particular types you specify, and by not specifying any function types, exclude them
18:48:45 <Twey> danilo2: No.  You will be able to create a parameterized type that can only be parameterized by certain other types.
18:48:57 <Makoryu> s/instances/"instances"/
18:49:08 <Makoryu> (Since this works nothing like the typeclass hack you're asking for)
18:49:32 <Twey> danilo2: You can do the same thing with typeclasses, by just defining an instance for every type there is except function types :þ
18:49:37 <danilo2> Makoryu: Could I ask you for a simple one liner example? I would be thankful for this
18:49:50 <Makoryu> danilo2: No, because it would not be one line...
18:50:02 <Twey> Semicolons love you
18:50:04 <danilo2> Twey: Yes, I know - but for every type is ... a lot of dwork :D
18:50:13 <Twey> danilo2: It would be the same with a GADT
18:50:15 <danilo2> Makoryu: Ok, thank you :)
18:50:22 <niteria> but you can detect at runtime if you got a function type
18:50:33 <Twey> Hrm, yes
18:50:47 <danilo2> Twey: Ah, so in GADTS I would also specify each type by hand?
18:51:04 <niteria> but doing polyvariadic trick I guess
18:51:16 <Axman6> hoh muh gord, it's been so long...
18:51:24 <Twey> danilo2: Yes.  Like I said, Haskell doesn't let you talk about ‘everything except this type’ (at compile-time, but listen to niteria for a run-time solution)
18:51:34 <Twey> Axman6: Oh, that's you?
18:51:40 <danilo2> niteria: I would like to do it at compile time, to "enable" optimizations, but thank you for the trick :)
18:51:45 <Axman6> I think I'm me...
18:51:50 <Twey> Caesar cipher, got it
18:51:53 * Twey feels silly.
18:51:59 <Axman6> heh, aye
18:52:06 <danilo2> Twey: ok, thank you very much :)
18:52:22 <Axman6> > unzip $ map (pred &&& succ) "Axman6"
18:52:23 <lambdabot>   ("@wl`m5","Bynbo7")
18:52:26 <Makoryu> danilo2: I am skeptical of these "optimizations" you mention
18:52:27 <Axman6> still got it
18:52:57 <Twey> Makoryu: Not checking types at runtime sounds like an optimization to me ;)
18:53:20 <Twey> Axman6: Shh.  You'll bring down the lens police.  #haskell is a very different place these days…
18:53:33 <danilo2> Makoryu: why? If I create an instance of a class, the call to the function can be translated to only one jump in asm, where runtime gives us (for sure) an overhead
18:53:39 <Axman6> Twey: is it? D:
18:54:24 <Makoryu> danilo2: I don't follow what you're trying to do exactly
18:55:13 <danilo2> Makoryu: I'm sorry :) I was only trying to define a function (let call it get), which will behave like "id" for simple variables and will behave differentlly for different types of functions (as parameters)
18:57:44 <Twey> danilo2: You *can* use OverlappingInstances and define a more specific (a → b) instance over a general a instance
18:57:50 <Twey> That's reasonably bad mojo, though
18:58:27 <danilo2> Twey: Oh! that could be something I am looking for! :)
18:58:58 <Twey> danilo2: Please don't do it in code I might have to use some day ;)
18:59:00 <danilo2> Twey: Why could it be bad? I know it could be error prone, but are there any other downsides?
18:59:10 <pavonia> danilo2: What are "simple variables" in that context?
18:59:20 <S11001001> danilo2: you mean "error prone" isn't a sufficient downside?
18:59:28 <danilo2> pavonia: I was tlaking about everything except of functions
18:59:35 <Twey> danilo2: What downsides could there be for a program other than being ‘error-prone’?  :þ
19:00:01 <danilo2> S11001001: Yes it is, I'm not planing touse it in production code - I'm just hacking with Haskell and trying to do "hacky things" :)
19:00:19 <danilo2> Twey: Ok, youre right :P
19:01:41 <jfischoff> is there something like a zipper for a free monad that allows for performant substitutions?
19:03:25 <dibblego> Hello, this code invokes a bug in GHC 7.4.1 that has been fixed at some time at least before (or equal to) GHC 7.6.3, however, I would like to find the bug in the database so I can document it. Any suggestions on how to find that specific bug? https://gist.github.com/tonymorris/6460828
19:04:09 <shachaf> Oh, the bug where you run into trouble with duplicate instances when you define instances in ghci.
19:04:26 <dibblego> yes
19:05:10 <shachaf> http://ghc.haskell.org/trac/ghc/ticket/5820
19:05:22 <dibblego> great thanks
19:06:02 <khyperia> I don't really understand point-free refactoring, and how it exactly is done. Is there an offline version of @pl that I can spam without annoying people in here? (or does the command work in PM?)
19:06:13 <shachaf> (Found via https://encrypted.google.com/search?q=site:ghc.haskell.org+instances+ghci , for what it's worth!)
19:06:24 <shachaf> (I often have better luck with the Google than with trac search.)
19:06:24 <dibblego> khyperia: yes, cabal install pointfree
19:06:29 <khyperia> thanks
19:06:33 <shachaf> khyperia: It also works in /msg.
19:06:46 <shachaf> elliott: Is @pl ever going to be fixed?
19:06:47 <dibblego> khyperia: I also have in ~/.ghci :def pl \s -> P.return P.$ ":! pointfree \"" P.++ s P.++ "\""
19:07:01 <shachaf> It would be nice. Even if it just calls out to the binary or something.
19:07:23 <khyperia> ... I have no idea what that jumble of symbols mean, dibblego.
19:07:34 <dibblego> khyperia: it allows me to invoke it from ghci
19:07:43 <khyperia> ah
19:08:11 <Twey> khyperia: I'm not sure @pl is always the best way to learn about point-free style.
19:08:41 <Twey> khyperia: Be aware that the definitions it comes up with are often much messier than what a human could generate.
19:09:02 <khyperia> Do you have a tutorial somewhere or something you could possibly link?
19:10:06 <Twey> khyperia: I'm not really sure it's a topic for tutorials.  As you grow more proficient with Haskell and its libraries you'll see more ways that a function can be written directly in terms of other functions.
19:10:25 <khyperia> ah
19:10:55 <lpsmith> Ok,  I have two lists of type (Eq a) => [(a,b)] and [(a,c)],   and the "a"s are _nearly_ in the same order.   Does anybody know a good algorithm for matching up the pairs according to type a?
19:11:21 <shachaf> What does "nearly" mean?
19:11:32 <khyperia> but the thing I'm specifically having trouble with is the function composition operator, and say, how, "\x y -> f (g x) y" would look in point-free
19:11:46 <copumpkin> lpsmith: man, how'd you end up with types polymorphic in Eq?
19:11:49 <copumpkin> :P
19:12:01 <khyperia> well, maybe that wasn't the best example
19:12:14 <copumpkin> f =<< g
19:12:28 <shachaf> copumpkin: Hey, it could've been an even weirder type, like (exists a. Eq a => [(a,b)])!
19:12:34 <copumpkin> > (f =<< g) x y :: Expr
19:12:35 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
19:12:35 <lambdabot>    arising from a us...
19:12:43 <Twey> khyperia: First you can take off the ending y, because that's directly applied, so that's \x → f (g x); then you can rewrite that with composition as ‘\x → (f . g) x’, and then you can remove the x again to give f . g
19:12:52 <enthropy> if you had Ord a =>, you could use a unionWith on maps you've made from the two lists
19:12:56 <copumpkin> > (f =<< (g :: Expr -> Expr)) x y
19:13:01 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
19:13:01 <khyperia> right
19:13:05 <lambdabot>    arising from a us...
19:13:07 <copumpkin> > (f =<< (g :: Expr -> Expr)) x y :: Expr
19:13:11 <lambdabot>   f (g x) x y
19:13:18 <copumpkin> boo
19:13:20 <copumpkin> I fail
19:13:20 <Twey> khyperia: There's only really one way to make a function point-free, which is by η-contraction (converting \x → f x into f)
19:13:26 <lpsmith> copumpkin, I'm speaking loosely here
19:13:34 <copumpkin> lpsmith: I'm just being an asshole, sorry :)
19:13:36 <Twey> khyperia: The combinators are just about how you get a function into that form
19:13:45 <lpsmith> copumpkin, =)
19:13:47 <khyperia> ... how do you have all these unicode symbols all quick? Do you have them bound do a shortcut or something?
19:14:02 <copumpkin> oh wait, that's just f . g
19:14:28 <slack1256> khyperia: learn about 'digraph' on vim or the equivalent on emacs/other editors
19:14:34 <Twey> copumpkin: I have a Compose key and UIM set to TeX-style
19:14:35 <lpsmith> shachaf, I have the same elements in both lists,  where the transposition-only edit distance is low relative to the length of the lsits
19:14:36 <dwcook> khyperia, you can also setup a compose key
19:14:43 <Twey> Er, khyperia, sorry
19:14:49 <dwcook> [compose]-> yields →
19:14:51 <khyperia> ah
19:15:01 <dwcook> At least under the default bindings for whatever Linuxy thing provides it
19:15:27 <dwcook> FreeCompose if you're on Windows
19:15:32 <Twey> xkb
19:15:39 <Twey> Windows has Compose key support?!
19:15:46 <dwcook> Not by default
19:15:47 <Twey> At last!
19:15:50 <dwcook> I had to install a program for it
19:16:21 <Twey> Well, obviously.
19:21:46 <khyperia> Well then. Looks like it's working, but this irc client doesn't accept unicode characters in input or something. Works when I type it into chrome's address field, but not here.
19:21:48 <khyperia> Fun times.
19:21:56 <canthelp> why
19:22:13 <canthelp> who doesnt use unicode these days
19:22:16 <khyperia> coulda just asked, haasn, lol.
19:22:27 <haasn> just curious :)
19:22:28 <khyperia> although it works fine when I copy-paste it into the field
19:22:37 <khyperia> also you too Twey
19:23:07 <Twey> khyperia: But I saved two lines of chat! (which we've now used anyway :þ)
19:23:11 <khyperia> heh
19:23:13 <Twey> I'm all about communication efficiency.
19:23:48 <Twey> I don't know what the state of Unicode is on Windows these days, but it always used to be a bit broken
19:23:58 <Twey> If all else fails, you can just use emacs (+ erc)
19:24:01 <shachaf> Most people here use Unicode, but often just the first 128 codepoints.
19:24:30 <canthelp> broken on windows?
19:24:32 <Twey> shachaf: I haven't seen much usage of the <11 range
19:24:42 <shachaf> Twey: Really?
19:24:44 * shachaf disagrees.
19:24:56 <canthelp> as long as you stick to ucs-2 it should work on windows
19:25:03 <Twey> shachaf: I don't see it.  My client converted it.  :þ
19:25:23 <canthelp> what character?
19:25:32 <Twey> canthelp: \1
19:25:39 <canthelp> ascii 1?
19:25:52 <Twey> Unicode 1, specifically.  But sure.
19:25:53 <spaceships> so am I right that Const is the applicative functor that acts like a monoid?
19:25:59 <canthelp> that has special irc meaning
19:26:08 <joelteon> I want to use rex to just replace substrings of a string. is that possible? because it looks like rex isn't designed to do that
19:26:09 <canthelp> was it at the start of the message
19:26:17 <shachaf> spaceships: All applicative functors "act like monoids".
19:26:23 <Twey> canthelp: That was rather the point.
19:26:35 <canthelp> i thought the question was about unicode
19:26:36 <shachaf> But Const x <*> Const y = Const (x <> y), and pure _ = Const mempty, if that's what you mean.
19:26:58 <Twey> canthelp: shachaf sent an ACTION command, which needs to be surrounded by \1's.
19:27:05 <Twey> (in the protocol)
19:27:11 <canthelp> yes
19:27:23 <spaceships> shachaf: it ignores fmap, too right?
19:28:02 <shachaf> spaceships: I don't know what "ignores" means, but I suspect that you'd figure out the answer to your question by looking at the definition of Const (and its instances).
19:28:38 <spaceships> shachaf: thanks for your help. yep, doing that too.
19:29:00 <flebron> So Howard-Curry gives us a way to translate between the usual functional programs and constructive proofs. Is there a corresponding notion for typeclasses? For instance, a logical interpretation of the Functor typeclass? (I'm aware of the categorical one)
19:29:23 <flebron> (The question arises because (.) = fmap, and (.) is implication.)
19:34:05 <Twey> flebron: Typeclasses are just type-directed sugar for passing a record of functions, i.e. a conjunction of implications
19:34:30 <dwcook> Or associated values in general
19:34:37 <Twey> Aye
19:34:43 <dwcook> e.g., empty :: (Monoid m) => m
19:34:55 <dwcook> @type empty
19:34:56 <lambdabot> Alternative f => f a
19:35:04 <dwcook> I got the wrong name I guess
19:35:06 <Twey> So the meaning is that of the applied conjunction; there's no special meaning for typeclasses
19:35:12 <Twey> dwcook: mempty
19:35:17 <dwcook> @type mempty
19:35:18 <lambdabot> Monoid a => a
19:35:22 <dwcook> Thanks
19:35:28 * Twey always confuses mempty/mappend and mzero/mplus
19:35:36 <shachaf> Twey: No, that's an implementation of type classes.
19:36:11 <Twey> shachaf: Sure, but for Curry–Howard purposes they're equivalent
19:44:10 <augur> does GHC have an interactive editing mode, or does it merely have a big monolithic type checker?
19:44:15 <Ghoul_> just like there is arbituary length int's (Integer)
19:44:25 <Ghoul_> is there an arbituarily precise version for floats?
19:44:32 <enthropy> have you seen ghci?
19:45:11 <augur> enthropy: no what i mean is something where you can send genuine code into GHC, and have it type check portions of the code
19:45:21 <JuanDaugherty> augur, enthropy was answering your query
19:45:31 <augur> GHCi isnt what i mean, JuanDaugherty
19:45:40 <augur> thats why i just said what i said
19:46:14 <enthropy> Ghoul_: there are some bindings for mpfr, there's a Data.CReal in http://hackage.haskell.org/package/numbers-3000.1.0.3
19:46:15 <JuanDaugherty> scroll up
19:46:21 <enthropy> the latter is much easier to use
19:46:38 <JuanDaugherty> you see where ... .
19:46:42 <Ghoul_> oh okay, so haskell doesn't have it built in
19:46:45 <Ghoul_> thats all I needed to know, thanks
19:46:47 <ekipan> Ghoul_: Rational, which is Ratio Integer
19:47:00 <Ghoul_> is rational pure haskell?
19:47:01 <JuanDaugherty> it's in lambdabot code which is in ghci
19:47:09 <Ghoul_> or is it bound to gmp?
19:47:18 <augur> JuanDaugherty: i dont know what you're saying
19:47:46 <enthropy> Ghoul_: Rational is Ratio Integer, so it's a bit of both I guess
19:49:15 <joelteon> is it possible to make an attoparsec parser lazy?
19:49:23 <joelteon> lazy in the regex sense, not in the Haskell sense
19:52:08 <enthropy> augur: have you seen https://github.com/nominolo/scion ?
19:52:53 <augur> enthropy: no
19:52:54 <augur> looking
19:53:22 <enthropy> there's another project somewhere on github for printing types of all values you've called __ or something
19:53:27 <augur> i should look at the GHC API
19:54:04 <enthropy> there's also ghc-mod
19:54:55 <enthropy> the ghc-api is not a very pretty place
19:55:05 <enthropy> you'll be better off using things that use it
19:56:15 <augur> well i dont actually need to use it, i was just wondering
19:59:13 <enthropy> it beats writing your own typechecker
19:59:53 <Twey> I'm not so sure…
20:00:33 <augur> enthropy: indeed :)
20:00:50 <Twey> augur: Haskell has holes now
20:00:58 <augur> Twey: fake holes
20:01:19 <Twey> Fake holes?
20:02:20 <augur> Twey: haskell cant have real holes without a real editor.
20:03:07 <Twey> Eh.  Not a language feature.
20:03:29 <augur> its an editor feature, ultimately
20:03:35 <augur> i mean, its a language feature too, to a minor extent
20:03:49 <Twey> The language feature is holes, which GHC has
20:04:00 <Twey> Nice editor support for holes is a different matter
20:04:11 <augur> holes without nice editor support are mostly useless :)
20:04:18 <augur> i'd like to see GHC's holes tho. link?
20:04:27 <Twey> http://www.haskell.org/haskellwiki/GHC/TypeHoles
20:05:22 <augur> real holes! :)
20:05:56 <xpika> the haskell platform Haskell Platform 2013.2.0.0 64bit opens in text edit
20:05:59 <Twey> You can get reasonably far.  emacs has support for loading a file into GHCi, holes and all, so compared to agda2-mode, the main thing that's missing is the ability to view information about a specific hole interactively (GHCi will just spew all the information about all the holes back at you at once, instead)
20:06:55 <augur> Twey: but can you interactively modify the source code, or will it just reload the whole thing each time?
20:07:15 <Twey> augur: The latter, but I'm not sure what the practical difference is
20:07:34 <augur> well if you have a big file i imagine its pretty intense, but fair enough
20:07:47 <Twey> In both cases you modify the hole, tell the editor to update, then read the new information about the hole
20:08:23 <Twey> Oh, and there's no proof search, obviously
20:08:37 <roboguy_> the last stable, major release of ghc doesn't have holes does it?
20:08:39 <augur> does the hole info list in-scope vars?
20:08:59 <Twey> augur: Yes; see linked article
20:09:25 <Twey> (‘Relevant bindings include:’)
20:09:38 <Twey> s/://
20:10:23 <Twey> roboguy_: No, coming 7.8
20:10:42 <augur> Twey: lovely!
20:11:03 <augur> thats all we need to make an editor with good hole support :)
20:11:23 <Twey> Indeed
20:11:35 <Twey> That seems to be the plan, reading the comments on the wiki page
20:11:48 <augur> i hope that GHC provides that stuff in a clear datatype
20:11:57 <Twey> I doubt it
20:12:01 <augur> :(
20:12:13 <Twey> GHC datatypes tend to be a little baroque :þ
20:12:18 <augur> anyway, i ask because im going to make an editor and my hope is to eventually have haskell support
20:12:28 <augur> Twey: well all i mean is it shouldnt just be a big blob of text
20:13:25 <hpaste> joelteon pasted “parsing is hard” at http://lpaste.net/92772
20:13:27 <Twey> augur: data SrcSpan = RealSrcSpan !RealSrcSpan | UnhelpfulSpan !FastString.FastString
20:13:35 <joelteon> see I can't figure out how to parse that ^
20:13:37 <Twey> augur: Oh, it won't be a big blob of text
20:13:49 <Twey> You might have to do impurity to get the values out, though
20:13:55 <joelteon> because how do you figure out the boundaries of a Plain text?
20:13:58 <augur> Twey: i dont know what you mean
20:14:13 <Twey> augur: Sometimes you get things wrapped up in IO-ish monads
20:14:32 <augur> Twey: for the hole info?
20:15:22 <Twey> joelteon: So &b\t starts a new B, and &/b\t ends it?
20:15:43 <Twey> augur: I don't know about the hole info specifically.  I'm just bemoaning the GHC API.  ☺
20:15:44 <augur> ok anyway, different topic
20:16:08 <augur> how would a plugin-like system be done in haskell?
20:16:20 <joelteon> Twey: yes
20:16:26 <joelteon> \t is a tab character, not the literal \t
20:16:30 <Twey> Yeah
20:16:49 <Twey> augur: Through the GHC API, but there are several existing packages; have a Google
20:16:51 <augur> byb plugin-like, i mean that i want to have a program with user-installable components
20:17:07 <Driscoll> is there a terse way to say "map over each row in an Array"
20:17:12 <Driscoll> without using range or something
20:17:15 <Twey> I think ‘plugins’ is this week's
20:17:30 <Driscoll> in this case, Array (Int,Int) Int
20:17:45 <Twey> Driscoll: No; the Array might not even have something that can be described as a ‘row’
20:17:51 <Driscoll> right
20:18:07 <Driscoll> so the closest approximation would be to use range?
20:18:25 <augur> Twey: is this week's?
20:19:10 <Twey> augur: Every so often one of them overtakes another.  I'm not totally sure which is in the lead at the moment, but I think it's plugins.
20:19:24 <augur> Twey: one of what
20:19:26 <augur> this week's what
20:19:27 <Twey> Driscoll: I'd say so, yes
20:19:33 <Twey> augur: Plugin package
20:19:34 <Driscoll> is that efficient
20:19:38 <Twey> Driscoll: Yes
20:19:43 <augur> Twey: im very confused
20:19:46 <Driscoll> like, my solutions was this, previously:
20:20:09 <Twey> augur: There are several options for a package that provides plugin support.
20:20:30 <Twey> augur: Generally one of them is better than the others, but that varies with time and I'm not up to date.
20:20:49 <Driscoll> map (myArray !) ( range ((0,0),(10,0)) )
20:20:57 <Driscoll> except that i was doing that for each row
20:21:00 <Driscoll> that seems like overkill
20:21:10 <Driscoll> but i can't find anything better
20:21:19 <augur> Twey: i still dont understand what you mean by "this week's"
20:22:00 <Twey> augur: Never mind; it's not important
20:22:14 <augur> why cant you explain it tho? :(
20:22:16 <augur> im curious!
20:22:37 <Twey> augur: I did, but you didn't get it :þ  It's not important enough to try harder.
20:22:45 <augur> you didn't explain it!
20:22:47 <Twey> Just a turn of phrase.
20:23:05 <augur> what do you mean this week's plugin package
20:23:06 <Twey> augur: The joke is that every week there's a new favourite.
20:23:28 <augur> that "joke" only works if everyone is in on it. :|
20:23:31 <Twey> Obviously the changes happen less frequently than once a week; it's a humorous hyperbole.
20:23:53 <Twey> augur: So I explained it!
20:23:55 <augur> you gotta add some extra words explaining how your short form connects up!
20:24:13 <augur> "plugin packages are this weeks package topic of choice" or something
20:24:37 <Twey> That's not what I meant, though :þ
20:24:49 <Driscoll> so Twey, is what I just posted a reasonable way to do it?
20:25:08 <augur> Twey: then you are confusing!
20:31:07 <Twey> Driscoll: I'd say so, yes
20:31:13 <user123abc> I'm getting started with haskell and am trying to learn the emacs tools
20:31:33 <user123abc> can I use haskell-mode to look up the types and definitions of symbols in my code?
20:32:00 <Driscoll> thanks Twey
20:34:00 <xpika> is there a cabal install flag for hiding a package?
20:38:14 <enthropy> xpika: cabal install tells ghc to -hide-all-packages
20:38:45 <enthropy> I think you have to edit the .cabal file to get rid of packages that are asked for there
20:39:02 <flebron> Question. Why is (*>)       :: Applicative f => f a -> f b -> f b, not (*>) = flip const?
20:39:52 <enthropy> flip const wouldn't be very useful
20:39:54 <flebron> (Following http://www.seas.upenn.edu/~cis194/lectures/11-applicative2.html , which asks one to implement (*>).)
20:40:13 <flebron> Well it's the first thing that comes to mind when seeing f a -> f b -> f b.
20:40:28 <enthropy> it would mean you have an Applicative constraint there without needing it
20:40:33 <flebron> Indeed!
20:40:34 <hpaste> joelteon pasted “lazy parsing in attoparsec” at http://lpaste.net/92773
20:40:41 <joelteon> ^ seems horribly horribly un-performant to me.
20:41:05 <Hafydd> :t flip const
20:41:06 <lambdabot> b -> c -> c
20:41:08 <joelteon> but it works
20:41:25 <joelteon> oh right, and I forgot a definition, one sec
20:41:41 <hpaste> joelteon annotated “lazy parsing in attoparsec” with “lazy parsing in attoparsec (annotation: forgot definition of 'chunk')” at http://lpaste.net/92773#a92774
20:41:58 <joelteon> but it definitely works
20:42:04 <joelteon> i just wonder if there's a better way
20:42:14 <Hafydd> @src (*>)
20:42:14 <lambdabot> (*>) = liftA2 (const id)
20:42:38 <Hafydd> @unpf (*>)
20:42:38 <lambdabot> (*>)
20:42:48 <Hafydd> @unpf liftA2 (const id)
20:42:49 <lambdabot> liftA2 (\ _ b -> b)
20:43:04 <pavonia> flebron: The (f a) thing wouldn't get executed with flip const
20:43:55 <flebron> What does it mean to execute an f a?
20:44:04 <ekipan> depends on the f
20:44:07 <joelteon> let lazy a b = ([] <$ try b) <|> ((:) <$> a <*> lazy a b)
20:44:11 <joelteon> i like that definition better
20:44:28 <flebron> ekipan: Is there any meaning to executing an f a, then?
20:44:51 <ekipan> it's kind of the point of having applicative functors in the first place
20:44:58 <flebron> (I'm aware specific instances will define semantics for it, but surely there's a point to the word being used in the above sentence, without meaning a specific applicative.)
20:45:56 <Hafydd> The two `f b' values can be different in the case of *>.
20:45:58 <pavonia> flebron: Well, I'm not sure "execute" is the correct term here
20:47:02 <pavonia> maybe "to reveal the effect of the specific Applicative" is a better one :P
20:48:03 * flebron is unsure what (*>) is supposed to be
20:48:19 <joelteon> it's <*> ignoring the left hand side
20:48:25 <joelteon> discarding, not ignoring.
20:48:28 <enthropy> > Nothing *> Just 2
20:48:29 <lambdabot>   Nothing
20:48:37 <ekipan> it's the same thing as (>>)
20:48:42 <ekipan> in Monad
20:48:54 <pavonia> > (flip const) Nothing $ Just 2
20:48:55 <lambdabot>   Just 2
20:48:59 <flebron> well in >>'s case i define it with bind
20:49:15 <Hafydd> > Nothing *> Just "kidding"
20:49:16 <lambdabot>   Nothing
20:49:39 <ekipan> > "abc" *> "de"
20:49:40 <lambdabot>   "dedede"
20:49:55 <Hafydd> "abc" *> "haue"
20:49:56 <flebron> I see the examples, but I'm not getting what it _is_ :p
20:49:58 <Hafydd> > "abc" *> "haue"
20:49:59 <lambdabot>   "hauehauehaue"
20:50:43 <Hafydd> @src liftA2
20:50:43 <lambdabot> liftA2 f a b = f <$> a <*> b
20:50:53 <flebron> Though I guess that's the conceptual problem I'm trying to solve - I understood Functor well enough, and Monads do seem to be a computational model (i.e. the definition of concatenation and composition of procedures), but applicative just stands weirdly in the middle
20:51:01 <ekipan> Parsed <$> string "stuff you want to parse, but ignore" *> string "argument to Parsed"
20:51:31 <enthropy> don't you need parentheses there?
20:51:35 <ekipan> probably
20:52:06 <enthropy> yeah, everything is infixl 4
20:52:25 <enthropy> so you're getting:    (Parsed <$> string "stuff you want to parse, but ignore") *> string "argument to Parsed"
20:53:25 <pavonia> flebron: Have you read http://www.soi.city.ac.uk/~ross/papers/Applicative.html ? I think it's the first publication of Applicatives
20:54:05 <ekipan> Paragraph <$> (string "<p>" *> contents <* string "</p>")
20:54:10 <flebron> nope
20:54:23 <flebron> pavonia: is that the recommended way to understand what applicatives are?
20:54:27 <fylwind> i learned applicatives by using Parsec
20:54:34 <pavonia> flebron: I think so
20:57:56 <dmj`> pavonia: Applicatives are in between functors and monads in power
20:58:11 <pavonia> yes
20:58:55 <dmj`> pavonia: they just allow you to apply a function already inside an applicative context to a value inside a context.
20:59:26 <dmj`>  Just (+1) <*> Just 1
20:59:35 <dmj`> > Just (+1) <*> Just 1
20:59:36 <lambdabot>   Just 2
20:59:48 <pavonia> dmj`: Yeah, I know :P
21:00:17 <dmj`> pavonia: oops that was meant for flebron
21:00:20 <joelteon> yeah I think you're preaching to the choir heh
21:13:43 <AfC> If I have a record type in a module which I'm exporting, should I a) use TypeName(..) or b) export the field names functions explicitly, or c) ...?
21:14:26 <enthropy> option a looks better in haddock
21:14:47 <AfC> enthropy: ah, right
21:15:15 <enthropy> c might be to not list any exports explicitly at all
21:15:38 <AfC> enthropy: yeah, but as soon as you have one you need to do it "Right"
21:16:03 <AfC> enthropy: thanks
21:16:36 <joelteon> I usually don't export data constructors just to avoid breaking old code if I add fields
21:18:01 <AfC> joelteon: I've definitely done that in other contexts - so much so that in those places I've made explicit functions that have useful names wrapping the cryptic field name [functions]
21:42:28 <SrPx> Hey guys, I've been trying to accept the strong typing but the first thing I try to do in Haskell - work with some JSON objects I have - is proving to be a pain. Where in LiveScript all I need is `obj=JSON.parse(data); log obj.foo.bar.x;`, in Haskell seems like I have to write a schema for my JSON in the form of types :/
21:43:47 <SrPx> As I see it now, it just hinders my productivity for no good... is there any thing I can do? Are there tricks around that? Or a reasoning why that should be necessary?
21:45:04 <dmj`> SrPx: You mean, writing instances for FromJSON and ToJSON?
21:45:27 <dalaing> SrPx: for some higher level information on static types - http://gbaz.github.io/slides/hurt-statictyping-07-2013.pdf
21:46:02 <SrPx> dmj`: if I understood correctly, before working with the JSON I have to write a whole schema - as in, translating the shape of the JSON to Haskell types - and then some additional boilerplate to convert JSON to that schema and vice versa.
21:46:33 <SrPx> dalaing: ok I will read that carefully :/
21:46:38 <copumpkin> "fail early"
21:46:56 <copumpkin> you could load a json object in livescript and half an hour later try to get obj.foo.bar.x
21:47:02 <copumpkin> and then it will fail because the input was bad
21:47:16 <copumpkin> it's the usual argument for static typing
21:47:25 <copumpkin> a little more up-front work for better reliability down the road
21:47:31 <dmj`> SrPx: I suppose it would depend on what library you are using. Have you tried aeson?
21:47:34 <SrPx> but as I see it now, as much as I want to believe that a strong typing system helps for some things, at this moment it is just making me completely unable to do some simple json manipulations. And that is the experience I have to judge ...!
21:47:40 <SrPx> dmj`: yes
21:47:48 <copumpkin> we could design a JSON library for haskell that gave you a super easy interface but it's kind of against our principles
21:48:07 <copumpkin> SrPx: it might be the experience you have to judge, but you owe it to yourself not to be short-sighted, either
21:48:10 <SrPx> copumpkin: problem is I'm working with livescript for months already and I've never had a problem similar to that :/ I write my code carefully
21:48:27 <copumpkin> SrPx: we mostly don't want to have to rely on our own good self discipline
21:48:31 <SrPx> copumpkin: sure, that is why I'm going to keep trying
21:48:32 <copumpkin> teams and such, especially
21:48:38 <copumpkin> anyway, I agree it's kind of painful
21:48:40 <dibblego> I do wonder if copumpkin is over-reaching with apologies
21:48:59 <BMeph> SrPx: Correct me if I'm wrong, but has your experience been in programming with languages that are object-oriented?
21:49:05 <copumpkin> dibblego: I apologize if I'm over-reaching with apologies
21:49:29 <dalaing> SrPx: I did a lot of Python before I started doing Haskell.  A little while ago I was told I could use whatever language I wanted for a little throw away program.  I did it in Haskell, it took a couple of hours, and a few minutes of writing tests (via QuickCheck) revealed a problem, and all was well
21:49:49 <copumpkin> I don't like dealing with JSON in Haskell either :)
21:49:58 <dalaing> SrPx: the next day I was told that by "whatever language I wanted" it was meant "Python", so I rewrote it in Python
21:50:29 <BMeph> copumpkin: Considering what JSON is, I'm honestly surprised at how much effort is made to be able to use it in Haskell. :\
21:50:31 <dalaing> SrPx: it took a little longer to write it in Python, but it took a day of writing tests to get it most of the way to the same level of confidence
21:50:47 <dmj`> SrPx: It's really not that hard with aeson. Suppose we had a person... data Person { firstName :: !Text, lastName :: !Text } deriving (Show, Generic)
21:50:50 <copumpkin> I could envision a simpler interface that requires less type modeling
21:50:55 <copumpkin> and is still reasonably safe
21:51:08 <SrPx> BMeph: no, I guess I can consider LiveScript to be FP, at least how I use it. Just without the Types. I love FP, I use high order functions all the time, my whole codebase consists of small functions combined, composed, etc. I just don't get typing yet, or why it is so tied to FP. But maybe it is a matter of time
21:51:16 <dmj`> SrPx: then you can declare instance FromJSON Person and instance ToJSON Person.
21:51:31 * copumpkin tharps
21:51:32 <SrPx> a sec too many messages
21:51:40 * copumpkin goes to sleep :)
21:52:33 <dmj`> SrPx: main = do { x <- (eitherDecode <$> getJSON) :: IO (Either String [Person]); case x of { Right p -> print p; Left _ -> error ":(" }  }
21:52:47 <SrPx> dalaing: what was it specifially?
21:53:08 <dmj`> SrPx: basically, read this article. https://www.fpcomplete.com/school/text-manipulation/json
21:53:47 <dalaing> SrPx: it was code to parse several log files and do some stats on them
21:53:53 <AfC> SrPx: I just had to build a ridiculous cascade of types to extract a mere three fields from a huge nested JSON resposnse
21:54:16 <SrPx> dmj`: what if my objects don't follow a schema? For example, I have some players with a "KI" attribute, which is a number measuring a kind of power. But other players don't have that attribute at all. Now this is just an example, but how would encoding that type even work?
21:54:32 <SrPx> AfC: ... proceed
21:55:04 <SrPx> dmj`: ok just after that article on types
21:55:06 <AfC> I'm saying it was fucking awful. I tried to make lens-aeson work, but I don't think it's ready yet.
21:55:16 <dalaing> SrPx: there's Maybe for that - it's a type constructor, so Maybe Int is an Int that may or may not be there, Maybe String is a string that may or may not be there, etc...
21:55:24 <SrPx> AfC: so, your opinion on the typing thing? :/
21:55:29 <AfC> Now obviously I now have Haskell types that will help me be correct yada yada
21:55:49 <SrPx> dalaing: OK, I didn't know maybe worked like that, inside structs. Interesting
21:56:04 <dmj`> SrPx: can you share a sample .json file?
21:56:25 <dmj`> SrPx: So I can see specifically what you mean
21:58:39 <SrPx> dmj`: it is not a "specific" json, i've been working with LS for months so everything I do involving communication has a JSON as a data carrier, so the thing is that if I have to formalize it everytime I want to pass a new kind of message between client/server, I will waste a good amount of time doing so :/
21:58:47 <SrPx> dmj`: i can send you something, though, let me see
21:58:50 <edwardk> AfC: what were you trying to do?
22:01:42 <dalaing> SrPx: whether or not it's a waste of time depends on how much you value robustness - in your obj=JSON.parse(data); log obj.foo.bar.x, what do you want to happen if foo or bar aren't there?
22:02:16 <SrPx> dalaing: but it always is :/
22:02:25 <Twey> SrPx: Typing is bound up with FP because typing is the killer feature for FP
22:02:47 <edwardk> AfC: your testimonial is rather different than all the other lens-aeson testimonials so i'm really trying to figure out where the impedence mismatch comes from
22:02:50 <dalaing> SrPx: if you can lock down that behaviour by describing the type you're expecting, then you might have fewer surprises down the road (or fewer typos or thinkos at the end of a long day)
22:03:17 <SrPx> OK I'm coming to the conclusion haskell is probably one of the greatest, safest languages out there, maybe the world would be a better, safer place if everything was in haskell... but it probably isn't the best thing when you really care about writing programs fast. Maybe it is not meant to
22:03:51 <dalaing> SrPx: like I said before, I used to do a lot of Python, and I code faster in Haskell now
22:03:56 <Twey> SrPx: For a safe language, Haskell does surprisingly well on the convenience front, too
22:04:08 <edwardk> SrPx: depends on how much you expect those 'fast' programs to do. i think faster in haskell than i do in any other language at this point
22:04:43 <Twey> There are probably people who can code Perl faster, but I'd rather use Haskell for quick, throwaway things than most other languages (Python, C++, Java, &c.)
22:04:48 <SrPx> yes, I could probably be miles faster in Haskell than in C++. but I guess livescript was the right combination of tools and trashy typing that is perfect to get my stuff working asap,  and that is probably hard to beat with a well designed language (sadly?)
22:04:50 <edwardk> SrPx: it takes a while to get back up to speed relative to what you had before, but a lot of that is familiarity with a different ecosystem, everything having new names, etc.
22:05:18 <SrPx> i guess i will give it another try when I have less strict deadlines, though
22:05:20 <Twey> LiveScript seems… dubious.  Javascript isn't really known for its terseness.  :þ
22:06:26 <dalaing> SrPx: these are pretty good lecture notes with excellent homework exercises, btw - http://www.seas.upenn.edu/~cis194/lectures.html
22:07:23 <dalaing> SrPx: I was initially skeptical about Haskell, and I think the main thing that changed for me was that my definition of "working" got more and more rigorous
22:07:30 <edwardk> i don't recommend picking up haskell on a deadline
22:07:48 <SrPx> dalaing: working?
22:07:54 <SrPx> edwardk: why
22:08:21 <dalaing> SrPx: from "to get stuff working asap" in your last message
22:08:22 <SrPx> Twey: LiveScript is pretty terse, certainly more than haskell as it doesn't have the type annotations
22:08:24 <edwardk> SrPx: because most languages involve picking up a little bit of syntax and then you're up to speed modulo looking up some things as you go
22:08:53 <edwardk> SrPx: my experience is that type inference allows me to elide more code than type annotations cost me at the top level.
22:09:43 <SrPx> dalaing: I see, I mean if I was in charge of making a huge database system or a medical software or something like that, there is no way I'd be using a scripty language. I guess I just thought haskell was a serious language that was so good it worked for throwaway programs aswell as scripty langs, which does not seem to be the case
22:09:58 <edwardk> because i don't have to explicitly name exactly what namespace i want to go look for a given member in as often as not. what monoid? doesn't matter, mappend, it'll figure out which one i mean. what monad? doesn't matter. return.
22:10:28 <dalaing> SrPx: I respectfully disagree :)
22:10:38 <scripty> SrPx you mentioned my name ;)
22:10:39 <Twey> SrPx: Almost all type annotations aren't required in Haskell.  The verbosity of ECMAScript syntax is far greater than of Haskell syntax, even in the rare case that you do have to use a type annotation or two.
22:11:09 <ekipan> function and return are pretty heavy-handed keywords
22:11:24 <Twey> (and in those rare cases it's usually to help you track down a bug that would be more effort to find without the type annotation, so you save on time again)
22:11:26 <edwardk> i wrote a _lot_ of untyped code in perl/python/javascript before I found haskell. heck i wrote a javascript compiler along the way, but the sheer utility of having fmap just 'do what you mean' and still be able to reason about it unlike the perl hacks is a pretty big deal.
22:11:44 <dalaing> SrPx: I think I've only _just_ crossed my personal limit for talking about languages with Haskell, but I'd be surprised if I changed my mind too radically as time went on
22:12:30 <dalaing> (limit == 10k lines, ideally in production but not in this case)
22:12:48 <edwardk> my experience with perl/python/javascript is i didn't dare 'think big' beyond a certain scale, because i couldn't have any belief that the code paths i wasn't actively testing were any good. this led to a culture of fear, defensive testing through TDD-like tools to try to get some semblance of the functionality that the types give you for free
22:13:09 <SrPx> edwardk: yea and the fact I don't understand what you said means I really should try a little further before I take conclusions
22:13:20 <enthropy> how could a FFI work to call haskell functions from a scripting language?
22:13:25 <Twey> ↑ what edwardk said is also my experience
22:13:29 <SrPx> scripty: woops. haha
22:13:32 <pharaun> edwardk: we have 1-1.5m sloc python codebase at work
22:13:34 <enthropy> where that language is written in a quasiquote
22:13:45 <pharaun> edwardk: let's put it this way... its... "exciting" to refactor it
22:13:52 <pharaun> so people. usually dont
22:14:11 <SrPx> dalaing: I didn't understand what you said/disagreed
22:14:20 <edwardk> pharaun: i've had some pretty darn scary python codebases myself. what i love about haskell is i don't think twice about massively refactoring an API. when I'm done assuming i didn't do anythng dumb with loop indices (why would i have any of those!) it just works
22:14:33 <Twey> Furthermore, I notice that most languages (even functional languages) with weaker type systems don't tend to use the complex combinators that seem so natural in Haskell, and where they do appear require a lot more thought to use correctly (Clojure)
22:14:44 <SrPx> edwardk: uh huh makes a lot of sense, haskell if very good for big projects isnt it?
22:15:00 <dalaing> SrPx:  I was disagreeing with "I guess I just thought haskell was a serious language that was so good it worked for throwaway programs aswell as scripty langs, which does not seem to be the case"
22:15:14 <dissipate_> Twey, why is there so much tension in the FP community between Haskell and Clojure?
22:15:15 <pharaun> edwardk: yup :) that's the real lovely thing about haskell for me
22:15:28 <SrPx> edwardk: I guess the whole safety thing makes it much easier to trust in the whole codebase as you keep scaling to the next levels
22:15:52 <dissipate_> pharaun, why do i keep reading complaints about space leaks in haskell?
22:15:59 <SrPx> dalaing: so you thin it is as good as script.y langs for throwaway programs?
22:16:15 <pharaun> dissipate_: because space leaks are context dependent and one of those harder to reason aspect about the language unfortunately
22:16:18 <dalaing> SrPx: yeah, although I wasn't convinced for quite a while
22:16:22 <edwardk> SrPx: for me, what i like about haskell is that it doesn't get in the way of code reuse for me. i mentioned this a few times elsewhere, but my experience is that haskell lets me actually achieve what "object-oriented programming" has been trying to achieve, which is that the code that i write is pretty much automatically reusable. you solve the general problem once and move on to new problems and laziness makes sure your
22:16:23 <edwardk>  algorithms compose, purity makes sure you didn't sneak in some dumb one-off hack that you'll forget in 6 months
22:16:28 <Twey> dissipate_: Is there?
22:16:59 <dissipate_> Twey, i dunno. i keep seeing Haskell pop up in #clojure and vice versa
22:17:04 <SrPx> edwardk: amazing, that was the kind of feedback I was expecting. makes a lot of sense
22:17:10 <edwardk> i have a _lot_ of haskell code out there. i tried to have comparable levels of coverage of concepts in other languages and failed miserably.
22:17:24 <AfC> edwardk: hey
22:17:25 <SrPx> edwardk: also you message got clipped
22:17:27 <edwardk> i'd always want to tweak something and it was like playing jenga
22:17:28 <Twey> dissipate_: If I had to guess, it's because Clojure and Haskell represent the opposite ends of the FP spectrum.  But this is the first time I've talked about Clojure in #haskell, I think.
22:17:32 <AfC> edwardk: (sorry, was in a meeting)
22:17:45 <edwardk> AfC: so what was it that blew up for you with lens-aeson?
22:17:51 <AfC> edwardk: I was trying to follow the examples and kept getting AsValue => ... errors
22:18:02 <Twey> dissipate_: Clojure takes a lot of ideas from Haskell, but without the types the complexity feels a bit overwhelming
22:18:04 <dissipate_> Twey, opposite ends of the FP spectrum in what way?
22:18:30 <edwardk> >>> "[12,13,{\"x\":42}]"^?nth 2.key "x"._Integer
22:18:30 <edwardk> Just 42
22:18:49 * AfC tries again
22:18:51 <Twey> dissipate_: Clojure is untyped, has no control of effects, and focuses on syntax, whereas Haskell is all about its types
22:18:52 <edwardk> were you trying to use a custom ToJSON/FromJSON or something?
22:19:05 <SrPx> Twey: in what sense they represent the oposite ends of FP?
22:19:17 <SrPx> edwardk: wat
22:19:19 <AfC> edwardk: I was forced to, yes; the incoming keys have capital letters
22:19:24 <dissipate_> Twey, what?? it does have control over side effects and has almost no syntax.
22:19:41 <dissipate_> Twey, BTW, there is typed clojure, but it is optional.
22:19:46 <edwardk> SrPx: addressing afc's concerns about something unrelated
22:19:53 <SrPx> oh ok
22:20:08 <Twey> dissipate_: I've always said that it's silly to describe Haskell as a ‘functional’ language: the thing that sets Haskell apart is its type system.  The fact that it's a functional language is just a way to make that work.
22:20:43 <edwardk> afc: if you have a custom ToJSON/FromJSON instance for something, and you've drilled to it you can use the _JSON prism to get it out
22:20:53 <arkeet> haskell is a language that is functional. it works.
22:20:54 <AfC> edwardk: oh!
22:21:01 <edwardk> >>> "[12,13,{\"x\":yourcrazyinstancegoeshere}]"^?nth 2.key "x"._JSON
22:21:07 * arkeet has met a few dysfunctional languages
22:21:09 <AfC> AAAAAAAAAhhhhhhhhhhhhhh
22:21:24 <jack_rabbit>  arkeet I see what you did there.
22:21:39 <edwardk> afc: nth, key, etc. all give you the 'Value' types you get out of Aeson
22:21:39 <AfC> edwardk: is the type of _JSON :: Value ?
22:21:51 <Twey> dissipate_: Good to know; I don't think that existed when I tried Clojure (or I just didn't dig deep enough).  By ‘no control over effects’ I meant that it has no effect typing.  Likewise, that lack of syntax is precisely what Clojure aims for; Haskell doesn't try to have an elegant syntax like that, instead preferring to support equational reasoning independent of the code's representation
22:21:51 <AfC> (wait, me looks)
22:21:59 <dissipate_> Twey, yes, i am interested in learning Haskell, but i'm currently more interested in learning Clojure. one major downside to Haskell IMO is that it doesn't compile to the JVM.
22:22:03 <edwardk> _JSON :: (ToJSON a, FromJSON a) => Prism' Value a  -- more or less
22:22:20 <arkeet> dissipate_: scala is probably closer to haskell
22:22:24 <edwardk> we're composing a fold on the right hand side of ^? there
22:22:25 <arkeet> and it's a JVM language
22:22:35 <pharaun> clojure does have the io! thing iirc
22:22:41 <pharaun> for banning io in function iirc
22:22:50 <arkeet> but I think it's worth just using haskell for a while.
22:22:58 <arkeet> scala lets you fall back into old habits.
22:23:03 <AfC> edwardk: gotcha. I have the lens-aeson docs up now
22:23:09 <tabemann> Scala to me just seems like a slightly better Java
22:23:20 <Twey> pharaun: It's not a type, though, which is the point
22:23:25 <dissipate_> Twey, you might want to check this out: https://github.com/clojure/core.typed
22:23:25 <arkeet> "slightly" seems like an understatement.
22:23:31 <edwardk> if you wanted to get out all of the children of an array as your json objects you can do foo^.._Array.each._JSON   and each will deserialize
22:23:50 <edwardk> AfC: lens-aeson was something definitely written for folks who know how to use lens, so the examples lead a _lot_ to be desired
22:23:53 <AfC> edwardk: ok, well that's useful to know. If I end up getting it working, and can contribute a useful example, I'll send you a patch
22:24:06 <edwardk> but there is a whole channel #haskell-lens full of people who know how to use it and who are willing to help
22:24:28 <edwardk> and we're more than happy to take constructive criticism and patches for the docs
22:24:32 <AfC> edwardk: yeah. I was sorta wildly optimistic that I would learn how to use lens by a motivating example that would really help me out
22:24:47 <dissipate_> Twey, also related is Clojure has contracts: https://github.com/clojure/core.contracts
22:25:01 <edwardk> afc: did you see https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms ?
22:25:18 <AfC> I did. That was what I was trying to follow
22:25:20 <dissipate_> arkeet, yeah, i'm not interested in scala at all. seems like a 'better' java. i'm trying to get away from OOP.
22:25:21 <pharaun> Twey: yeah, i'm having no luck with adoption of haskell at work
22:25:31 <arkeet> dissipate_: you should try out haskell. ;)
22:25:31 <pharaun> but folks are starting to adopt clojure, i have no idea what to think
22:25:33 <pharaun> about that
22:25:43 <AfC> edwardk: actually the most accessible description of how Lens & friends work
22:25:43 <pharaun> but as a fan of functional language i think its a nice thing
22:25:54 <SrPx> Twey: so now that you said that, do you think haskell would be dependently typed if it was invented later?
22:26:06 <AfC> edwardk: I'd yet come across [and I've been following your work for a while; so nicely done there]
22:26:07 <dissipate_> arkeet, i want to, but i'm more interested in clojure right now. i'm very turned on to macros.
22:26:08 <Twey> dissipate_: There's really only so far you can go with gradual typing — people think that it's good to offer multiple options, and it's true that having the option to type a function or two is definitely a boon when writing programs, but it's totally different to having a whole typed ecosystem
22:26:24 <Twey> SrPx: Uhhm, probably
22:26:38 <edwardk> AfC: tekmo has a nice little intro that focuses on how to just use them to muck around in some data with multiple targets from a game perspective
22:26:50 <AfC> edwardk: thanks. I'll have a peek for that.
22:26:58 <SrPx> dissipate_: how is not compiling to JVM a disadvantage?!
22:27:05 <dissipate_> Twey, yep, i agree. for now i'm willing to live without typing.
22:27:05 <AfC> edwardk: [trying to keep up with Tekmo is even harder than keeping up with you :)]
22:27:20 <tabemann> somehow I'm not entirely impressed by efforts to try to tack on aspects of dependent typing onto Haskell, when I've seen *real* dependent typing in other languages
22:27:29 <arkeet> dissipate_: who needs macros ;)
22:27:30 <AfC> edwardk: I'll have another go this afternoon and get back to you tomorrow with my experience.
22:27:31 <dissipate_> SrPx, for the kinds of applications i want to write, i don't want to compile to native.
22:27:39 <tabemann> (of course, then, I have a hard time wrapping my brain around even the simplest of combinators in the likes of Agda...)
22:27:39 <edwardk> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html with examples like: units.traversed.(around target 1.0).health -= 3
22:28:09 <arkeet> haskell lets you write your own control structures as ordinary functions.
22:28:30 <arkeet> in part because of the type-level separation of IO.
22:28:38 <dissipate_> SrPx, i'm not saying the JVM doesn't have it's warts, but i'm not too keen on compiling to native executables.
22:28:40 <arkeet> and because of laziness.
22:28:46 <tabemann> arkeet: hence why I tend to not be entirely impressed with much of the use of macros in Lisps, as many of those things aren't necessary in Haskell
22:28:50 <Twey> SrPx: Dependent types (with types-as-values) seem to me to be a much more elegant way of expressing type systems, even if you don't ever write any code you wouldn't have written without them.  The details of how best to structure a dependent language are still being beaten out, though, so that value of ‘later’ might be in the future.
22:28:52 <arkeet> tabemann: indeed!
22:28:59 <Twey> SrPx: I'm only an amateur type-theorist, though :þ
22:29:19 <dissipate_> arkeet, anyone who wants to extend the language?
22:29:28 <arkeet> extend with what?
22:29:50 <dissipate_> arkeet, extend with macros
22:29:53 <arkeet> ...
22:29:58 <arkeet> that do what?
22:30:54 <dissipate_> arkeet, all kinds of stuff, there are large macro libraries. much of the stuff that are built into languages like perl or python are macros in clojure.
22:31:13 * arkeet peeks at the wikibooks page on clojure's macros and notes that those things can be done with ordinary functions in haskell.
22:31:21 <Twey> dissipate_: Haskell is basically a huge macro language used to build programs in IO :þ
22:32:01 * SrPx *reading on lenses*
22:32:15 <arkeet> dissipate_: and those things are just ordinary functions in haskell.
22:32:32 <Twey> Well, not all of them, but a large majority.
22:32:35 <arkeet> sure.
22:32:45 <arkeet> and macros aren't first-class values, afaik
22:33:03 <CADD> arkeet: they are if they are fexprs. :)
22:33:16 <arkeet> this sounds worse and worse ;)
22:33:23 <SrPx> Twey: yea I'm waiting for a dep typed language that works for practical purposes ...
22:33:35 <Twey> (we do have a macro system for the odd case where you really do need a macro; it works pretty much like a standard Lisp macro system, except it's typed with the types of the code it generates and it's a little clumsier to account for having to deal with more syntax)
22:33:40 <tabemann> there is idris, but I disagree with its being designed as a strict rather than lazy language
22:33:46 <arkeet> SrPx: idris hopes to be that, no?
22:33:46 <Twey> SrPx: Are you aware of Idris and ATS?
22:33:48 <dissipate_> arkeet, but you can go way beyond what's in the core libraries of clojure and make your own macros
22:34:02 <SrPx> yes, I've done some simple things in Idris. not sure about ATS
22:34:06 <Twey> FSVO ‘practical’ and ‘dependently-typed’, respectively
22:34:07 <CADD> SrPx: i would third idris
22:34:24 <SrPx> but it is still experimental and takes a long time to make some simple things. hope it gets there soon, though!
22:34:25 <arkeet> dissipate_: I'm just saying that a lot of the things you'd use macros for in lisp or clojure or whatever can be done with ordinary functions in haskell. :)
22:34:31 <arkeet> which sounds a lot more attractive to me.
22:34:42 <arkeet> (and for the rest, there's template haskell.)
22:35:21 <dissipate_> arkeet, yep. not saying haskell isn't powerful. it is.
22:35:44 <SrPx> arkeet: I guess some macros could solve my JSON issue, though
22:35:48 <SrPx> actually ... no
22:36:03 <dissipate_> arkeet, get haskell to compile to JVM. :P
22:36:22 <arkeet> what's so good about JVM?
22:36:50 <tabemann> I don't see why one even *wants* to compile to the JVM
22:36:53 <SrPx> well I don't know where to go next, i guess I've already coded in the 20 or so most popular languages. programming is so weird nowadays, everything is wrong...
22:36:53 <dissipate_> arkeet, don't have to worry as much about what platform someone is running on
22:37:17 <CADD> SrPx: ever try factor?
22:37:31 <SrPx> CADD: read a lot about...
22:37:35 <tabemann> even if you could compile Haskell to the JVM, it would mean sacrifices that would limit performance, and it would preclude using GHC's threaded runtime (which is much better than Java HotSpot's concurrency)
22:37:47 <CADD> SrPx: oh man, its beautiful. the dataflow combinators are amazing
22:38:09 <SrPx> it is, I should read some more now
22:38:13 <Twey> dissipate_: Haskell compiles to LLVM, LLVM compiles to VMKit, and VMKit is trying to support a JVM
22:38:23 <Twey> Factor's pretty
22:38:33 <CADD> SrPx: yeah, im with you. never used it for anything, but its a purdy lang
22:38:41 <CADD> Twey: precisely
22:38:53 <Twey> It's even more impressive once you see how much of it was made by slava :þ
22:38:58 <enthropy> SrPx: it doesn't really seem like you have a json issue
22:39:04 <CADD> ikr? he wrote like everything
22:39:38 <Twey> I love concatenative languages, I really do
22:39:49 <enthropy> if can't fit your stuff into a data type you can write, then you can just leave it as Value or whatever data type represents all valid json
22:39:51 <Twey> I wanted to make a dependent concatenative language, but the two don't really seem to fit together syntactically
22:39:52 <dissipate_> tabemann, that's going to be a major limiting factor for a lot of developers. :(
22:40:04 <SrPx> Twey: slava?
22:40:16 <tabemann> dissipate_: there are fundamental design issues with the JVM that make implementing Haskell for it hard to impossible
22:40:38 <tabemann> case in point - no tail call optimization - and the use of trampolines to get around that would hurt performance too much
22:40:46 <dissipate_> tabemann, hmm, i didn't realize haskell has an interpreter
22:40:46 <Twey> SrPx: Slava Pestov, the guy who, er, single-handedly designed and implemented most of Factor
22:42:09 <dissipate_> tabemann, what architectures has Hugs been ported to?
22:42:14 <pepper_chico> hi, I'm just starting compiling the haskell platform on linux, I don't know haskell, I getting what seems a basic error from the build
22:42:25 <pepper_chico> I have
22:42:27 <pepper_chico> newtype Vertex1 a = Vertex1 a
22:42:27 <pepper_chico>    deriving (Eq, Ord, Ix, Bounded, Show, Read, Typeable)
22:42:49 <pepper_chico> and
22:42:49 <tabemann> Hugs is in C, and I don't know what platforms it has been supporting, but it's not supported anymore itself, and no one except misguided CS instructors use it anymore
22:42:51 <pepper_chico> instance Typeable a => Typeable (Vertex1 a) where
22:42:51 <pepper_chico>    typeOf = typeOfDefault
22:43:01 <tabemann> one should be using GHCi, not Hugs
22:43:15 <pepper_chico> but lines like that are giving errors like:
22:43:32 <arkeet> pepper_chico: would you like to put the errors and stuff on a pastebin?
22:43:33 <arkeet> @paste
22:43:33 <lambdabot> Haskell pastebin: http://lpaste.net/
22:43:38 <pepper_chico> ‛typeOf’ is not a (visible) method of class ‛Typeable’
22:43:44 <SrPx> I think that in the future we will have a language where everything you have to do is to combine functions to do what you want. no ifs, no loops, no variables. just like scheme. except it would not be turing complete, allowing it to be optimized to faster than c speeds
22:43:48 <arkeet> also, why are you compiling the haskell platform?
22:44:02 <dissipate_> tabemann, if haskell had a good interpreter ported to a number of architectures, then no need for JVM.
22:44:08 <SrPx> Twey: oh, that is common though
22:44:24 <dissipate_> SrPx, APL?
22:44:37 <tabemann> dissipate_: GHCi itself at the moment only supports x86 and AMD64, but GHC otherwise supports a wider range of platforms
22:44:52 <SrPx> dissipate_: APL is cool, but far from perfection too
22:45:06 <pepper_chico> arkeet, because I've custom compiled ghc from sources, and picked the latest plataform release for the build, ubuntu 13.04 doesn't have a package for the platform
22:45:07 <SrPx> is it fast? i never checked
22:45:08 <dissipate_> SrPx, cool as in unreadable?
22:45:34 <pepper_chico> arkeet, do you have an idea about that kind of error?
22:45:52 <SrPx> dissipate_: cool as in, has some great ideas but some bad things too. and yea, unreadable
22:46:09 <dissipate_> tabemann, bah, no ARM? port the interpreter and make it good. native executables are old stuff IMO. unless of course you are doing systems programming.
22:47:02 <dissipate_> SrPx, BTW, there is a modern APL language: J, has an interesting corporate backed software package: jsoftware.com
22:47:17 <SrPx> for example, I'll never pardon humanity for the fact no compiler ever is able to optimize (x -> 2*x + 2*x) to (* -> 4*x)
22:47:37 <CADD> SrPx: check out J, I had a good time with it
22:47:39 <SrPx> dissipate_: tried that one too. Better and worse in some aspects!
22:47:45 <CADD> SrPx: its written by the same guy that wrote apl
22:47:48 <SrPx> not much more readable IMO
22:48:02 <CADD> SrPx: meh, but its damn expressive.. :)
22:48:03 <SrPx> CADD: now that is new. interesting!
22:48:14 <tabemann> dissipate_: why do you need an interpreter so badly
22:48:29 <CADD> SrPx: yeah, its super cool. and doesnt have the problem of requiring unicode. its all ascii baby
22:48:30 <tabemann> an actual compiler can do so many more optimizations than an interpreter can do effectively
22:48:41 <arkeet> pepper_chico: it would help if you posted build logs.
22:48:44 <dissipate_> tabemann, don't want my collaborators to have to run make
22:48:49 <pepper_chico> here's a pastebin of my problem for compiling haskell platform
22:48:51 <pepper_chico> http://pastebin.com/a2rn4Ur2
22:48:53 <mauke> The paste a2rn4Ur2 has been copied to http://lpaste.net/92776
22:49:10 <tabemann> dissipate_: I don't think GHCi is really meant for serious use anyways
22:49:29 * SrPx just wants a scheme as safe as Haskell, as smart as Agda and as fast as C. Is SrPx really asking much? :(
22:49:30 <arkeet> like actual build logs.
22:49:37 <dissipate_> tabemann, industry has moved away from binary executables. that's just a fact. :(
22:49:42 <CADD> SrPx: check out shen.
22:49:47 <tabemann> "the industry"
22:49:47 <tabemann> yeah
22:49:55 <dissipate_> tabemann, unless of course you are doing systems programming.
22:49:56 <tabemann> since how are Java bytecode executables not binary executables
22:50:11 <dissipate_> tabemann, sorry, native binary executables
22:50:13 <CADD> SrPx: http://shenlanguage.org/
22:50:24 <SrPx> CADD: I feel bad for it not being popular, must admit I should've had it a bigger chance. Is it fast?
22:50:26 <tabemann> the only difference between bytecode executables and native ones is that bytecode executables need a goddamn JIT if you you're going to get any performance out of them
22:50:46 <CADD> SrPx: it uses sbcl, so take what you want from that.
22:50:50 <tabemann> you've just drank too much of the Java and .NET kool-aid there
22:50:52 <pepper_chico> arkeet, that pastbin is not enough?
22:50:58 <dissipate_> tabemann, so everyone is back to 'make'? :(
22:51:04 <tabemann> how hard is make
22:51:08 <arkeet> pepper_chico: it tells nothing about your build environment and such.
22:51:09 <tabemann> and with GHC you don't even *need* make
22:51:11 <SrPx> CADD: well not faster than C ^^
22:51:18 <CADD> tabemann: if only the borroughs 5000 system actually would have made it. we would all be much happier
22:51:29 <dissipate_> tabemann, pretty nasty IMO. at least that's been my experience.
22:51:34 <CADD> SrPx: well, sbcl is pretty damn fast. given that its not running on a lispm :)
22:51:41 <arkeet> pepper_chico: you are using GHC 7.6.3?
22:52:10 <tabemann> dissipate_: invoking a compiler at the command line, or writing a Makefile to do it, isn't that hard
22:52:11 * SrPx wonders where are the lisp machines in this imperative word!!
22:52:44 <SrPx> CADD: do you have some figures? I don't know much about sbcl
22:52:47 <tabemann> and as you are obviously comparing things to the Java world
22:52:47 <dissipate_> tabemann, bottom line is if i want to do a web app, or some artificial intelligence thing, i don't want my collaborators to have to run 'make'. that's old school.
22:52:51 <pepper_chico> arkeet, that's the full build log http://pastebin.com/XgmJsumn
22:52:58 <mauke> The paste XgmJsumn has been copied to http://lpaste.net/92777
22:53:03 <tabemann> since when is make any harder to work with than (ugh) ant or maven
22:53:05 <CADD> SrPx: just think. even if you are using haskell, its still all stacks at the end of the day *sobs*
22:53:16 <tabemann> "old school"
22:53:16 <arkeet> pepper_chico: are you using GHC 7.6.3?
22:53:18 <tabemann> exactly
22:53:22 <tabemann> you're just listening to the propaganda
22:53:26 <arkeet> looks like you aren.
22:53:27 <arkeet> t
22:53:36 <CADD> SrPx: well, there is the language benchmarks. but those come with all the obvious caveats
22:53:41 <arkeet> pepper_chico: it won't work with GHC HEAD.
22:53:50 <arkeet> you need to use 7.6.3
22:53:58 <arkeet> >checking version of ghc... 7.7.20130908
22:54:10 <arkeet> pepper_chico: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
22:54:24 <SrPx> CADD: wow it is indeed fast. I wonder how Racket can be slower than CL?!
22:54:39 <pepper_chico> arkeet, my simple question is why, I'd like to make the fix if syntax changed, I've used the flag, because I really wanted to try with the ghc build I have now
22:55:01 <arkeet> pepper_chico: if you're feeling adventurous enough to use GHC HEAD, you shouldn't be using the platform anyway.
22:55:14 <SrPx> CADD: would you tell me what is stopping most languages to be as fast as C, though? Is it such a hard problem to optimize code?
22:55:21 <arkeet> but if you're just getting started with haskell, I *really* recommend against using anything other than 7.6.3
22:55:28 <dissipate_> tabemann, ok, i don't care about JVM, just have a good interpreter that has been ported.
22:55:41 <CADD> SrPx: not enough people. love racket, they actually just recently released their jit, so the rank may be a bit outdated
22:55:49 <tabemann> dissipate_: and I don't see what you gain about using an interpreter
22:55:50 <pepper_chico> arkeet, do you have an idea why that does not compile, does it make any sense to not compile?
22:55:54 <arkeet> yes, it makes sense.
22:56:02 <arkeet> 7.8 makes extensive changes to Typeable.
22:56:06 <CADD> SrPx: yes, optimization sucks and the x86 sucks
22:56:08 <tabemann> with a properly set-up build system building should be trivial
22:56:11 <SrPx> CADD: ... really?! How it was running on the cpu benchmark game!?
22:56:13 <dissipate_> tabemann, python, perl and ruby seemed to have gained a lot
22:56:19 <SrPx> CADD: interpreted!?
22:56:23 <tabemann> python, perl, and ruby are horribly slow
22:56:27 <CADD> SrPx: yup
22:56:41 <pepper_chico> arkeet, I'd like to know the quick fix for that..., just to see whether the build goes on
22:56:52 <pepper_chico> that's the only kind of error happening by now
22:57:03 <CADD> SrPx:  http://docs.racket-lang.org/guide/performance.html
22:57:05 <SrPx> CADD: why a language such as racket has so few people? It is almost as good as a dynamic language can get
22:57:21 <CADD> SrPx: it truely is. although its the lisp curse.
22:57:23 <dissipate_> tabemann, BTW, i'm saying this from *my* perspective. if the Haskell community determines that native binaries are the way to go, so be it.
22:58:13 <arkeet> pepper_chico: uh, looks like you could remove the "instance ... Typeable (Vertex1 a) ..." thing
22:58:41 <tabemann> native binaries compiled statically means that GHC can, despite any overhead from laziness or boxing or the like, still come out as competitive with Oracle Hotspot, which has far more developers working on it than there are working on GHC
22:58:41 <arkeet> pepper_chico: but you still really should use 7.6.3
22:59:26 <tabemann> it means that we can do all kinds of different optimizations statically
22:59:31 <pepper_chico> arkeet, I'll give it a try, ghc takes too long to build
23:00:15 <tabemann> but I should go to bed
23:00:18 <pepper_chico> arkeet, you say, remove, but leave the typeOf = typeOfDefault?
23:00:25 <dissipate_> tabemann, fair enough
23:00:31 <SrPx> CADD: lisp curse?
23:00:38 * SrPx is reading that link
23:00:42 <arkeet> pepper_chico: no, remove that too
23:00:52 <pepper_chico> hmm, interesting
23:00:54 <arkeet> pepper_chico: but you'll probably run into trouble later
23:01:57 <dissipate_> what about the parrot VM?
23:02:04 <dissipate_> perl 6 is on there
23:02:26 <CADD> SrPx: to put it briefly: the power of lisp is its own worst enemy.
23:02:46 <dissipate_> hmm, nevermind, that's for dynamic languages
23:03:01 <dissipate_> CADD, how so?
23:04:12 <CADD> SrPx: http://www.lambdassociates.org/blog/bipolar.htm
23:04:52 <SrPx> CADD: maybe ... I guess it is simpler than one could guess, though. I think if someone released a simple editor that made coding in lisp ridiculously easy and make a fancy app to write web apps, people would be jumping over it
23:05:30 <CADD> dissipate_: in many ways. "too academic", not understanding the purpose and beauty of its postfix and paren riddled syntax, all the concepts that it intoduced like homoiconicity, the if statement(yes lisp was the first lang to ever have the if statement), garbage collection.
23:05:38 <SrPx> CADD: oh ive read that
23:06:03 <CADD> dissipate_: but the lisp curse is much more of a meme than it is an actuall assesment of its failure. which is multifaceted
23:07:09 <CADD> SrPx: well although its not for lisp. Peaker is working on a brilliant editor for haskell called Lamdu: https://github.com/Peaker/lamdu
23:07:38 <CADD> SrPx: yeah, great article. im sure it resonates with a lot of people. it did with me
23:08:33 <dissipate_> CADD, too academic? haskell is the epitome of an academic language...
23:08:44 <SrPx> CADD: (actually I have been mistaken, am just reading it now)
23:09:15 <CADD> dissipate_: haskell isnt the only lang that has suffered such ignorance.
23:09:24 <CADD> SrPx: oh cool
23:11:48 <dissipate_> CADD, haskell is based on advanced mathematics. i'm not saying that's a bad thing, and it is subjective if that qualifies it as 'academic', but there is no way it is less 'academic' than lisp.
23:11:58 <pepper_chico> arkeet, yeah, you were right... will leave this for tomorrow, thanks anyway
23:12:12 <arkeet> pepper_chico: leave 7.6.3 compiling overnight ):
23:12:14 <arkeet> :)
23:12:16 <pepper_chico> lots of other problems...
23:12:17 <Twey> dissipate_: All programming languages are based on ‘advanced mathematics’ :þ
23:12:19 <pepper_chico> yeah
23:12:23 <pepper_chico> will do it
23:12:44 <CADD> dissipate_: thats not what i was saying. plus its funny when people call cl a "functional" lang
23:12:52 <pepper_chico> I will try to checkout a tag, hope it works just simple, from the git repository
23:12:56 <Twey> As for academi…a…ism, Haskell isn't even near the top of the pile these days
23:12:57 <dissipate_> Twey, so which highly esteemed mathematicians crapped out PHP?
23:12:59 <arkeet> pepper_chico: no
23:13:03 <arkeet> just download the sources from the site.
23:13:14 <arkeet> pepper_chico: http://www.haskell.org/ghc/download_ghc_7_6_3
23:13:18 <pepper_chico> =/
23:13:23 <pepper_chico> I just like repos
23:13:28 <Twey> dissipate_: Hahah, I didn't say it was always a *good* use of advanced mathematics :þ
23:13:36 <arkeet> pepper_chico: there's more that can go wrong if you just do your own thing
23:13:49 <pepper_chico> I will just take a look anyway
23:13:59 <Twey> There's always some kind of semantics going on there, though, no matter how informal
23:14:47 <Twey> And something like, say, Java or C++ has ample formalizations from researchers across the world, but nobody accuses it of being based on ‘advanced mathematics’.
23:14:53 <pepper_chico> ghc is in a bit messy state... for build and stuff, most of thing I get, are from source, and just works, or I can just checkout a tag
23:15:41 <SrPx> CADD: haha increadible
23:16:03 <dissipate_> Twey, and BTW, if the war has come down to 2 languages: clojure vs. haskell, i think i can live with that. but sadly that is not the case. and neither of these languages will be mainstream *anytime* soon.
23:16:35 <Twey> Um, sure.
23:16:44 <CADD> dissipate_: http://this-plt-life.tumblr.com/post/36425236106/when-somebody-says-but-clojure-will-bring-more-people
23:17:08 <CADD> SrPx: the article?
23:17:23 <SrPx> CADD: yes. also lol@that
23:17:31 <CADD> SrPx: cool
23:18:03 <dissipate_> CADD, i don't care about bringing more people to lisp. i'm mainly interested in FP for the advantages it gives with pure functions and excellent multi-threading, plus getting rid of OOP.
23:18:58 <CADD> dissipate_: but purity and multithreading is not even the point of fp though.
23:19:27 <CADD> dissipate_: recursion and functions as a value are "the point" of fp
23:19:32 <dissipate_> CADD, that may be true, but they are great advantages
23:19:44 <CADD> dissipate_: yup
23:20:37 <dissipate_> CADD, industry and huge percentage of academia are stuck in imperative and OOP land. that's not changing anytime soon. not with haskell and not with clojure.
23:21:13 <CADD> dissipate_: thats fine. let them build towers of shit
23:21:23 <CADD> dissipate_: they will eventually learn.. :)
23:21:32 <Twey> That's the opposite of fine
23:22:17 <smith_> Is it possible to create a type of String that guarantees that it will contain only a certain set of characters?
23:22:28 <tero-> CADD: will they? FP has a steep learning curve. the imperative road might be more tempting
23:22:33 <CADD> Twey: you are completely right. but there is no much stoping them.
23:23:06 <CADD> tero-: fp has a steep learning curve to people who have been damaged by other models.
23:23:17 <CADD> tero-: ive heard fp-first learners dont have that much difficulty
23:23:28 <dissipate_> CADD, i agree
23:24:02 <dissipate_> almost anyone in industry has been damaged
23:24:06 <tero-> CADD: I buy that but what do we do with the rest of the people? :)
23:24:28 <CADD> tero-: oh man, now you are asking the hard questions. :)
23:24:28 <dissipate_> tero-, make them jobless until they learn FP
23:24:57 <CADD> tero-: well definatly dont do what i do and smash my friends quaint ideas of what they think programming should be. they kind of hate me for it.. :)
23:25:07 <CADD> tero-: and definatly dont bring up HoTT
23:25:10 <tero-> heh
23:25:23 <dissipate_> CADD, quaint ideas being OOP?
23:25:25 <Twey> CADD: You just managed to distract me from actual PLT with funny reaction GIFs about PLT.  Congratulations.
23:25:36 <CADD> dissipate_: hehe, there are a lot..
23:26:08 <CADD> Twey: ikr? i <3 axis of eval
23:26:18 <CADD> Twey: what are you working on?
23:26:21 <dissipate_> after i read the paper 'out of the tar pit' and watching Hickey's talks about the problems with OOP, i was convinced it was bad
23:26:49 <SrPx> smith_: I don't think so
23:26:58 <smith_> SrPx: Aw.
23:27:10 <Twey> CADD: I'm playing around with proving stuff about a linear language in Agda
23:27:25 <CADD> dissipate_: http://axisofeval.blogspot.com/2012/11/when-everybody-and-their-dog-writes.html just to shake it up a bit.. :)
23:27:46 <SrPx> smith_: mind I don't know almost anything about haskell at all but people missed your question :x
23:28:00 <CADD> Twey: ooo, sounds interesting. i rememeber reading somewhere that you can use linear logic to make gc unnecessary?
23:28:16 <CADD> Twey:  i think it was called something like "look ma' no garbage"?
23:29:08 <CADD> Twey: or am i totally off the mark of what you are doing?
23:29:45 <Twey> CADD: Haha, yeah, pretty much
23:29:57 <CADD> Twey: oh ok, enlighten me please
23:30:01 <Twey> I don't know what you're referring to specifically
23:30:08 <Twey> Oh no, I meant you pretty much hit it on the head
23:30:09 <CADD> Twey: http://home.pipeline.com/~hbaker1/LinearLisp.html
23:30:14 <SrPx> CADD: I think we just need a killer FP language. There is none. Period. After that it is just a matter or marketing
23:30:15 <CADD> Twey: i just looked it up, lol
23:30:16 <dissipate_> CADD, technically, 'out of the tar pit' was a critique of having side effects, not OOP itself
23:30:16 <Twey> Ah, that I've read
23:30:42 <dissipate_> CADD, and was Hickey's critique bad? i thought it was downright excellent.
23:30:48 <CADD> dissipate_: is that the paper called "getting energy out of the turing tarpit"
23:30:51 <Twey> I'd quite like a safe low-level language without GC.  AFAICT such a thing doesn't exist, so I have every intention of building it :þ
23:31:00 <Twey> Step 1) learn PLT
23:31:01 <CADD> dissipate_: its not. it just made me rememeber that post
23:31:06 <SrPx> a FP language (or computer) faster than C is the first thing we should be worrying about
23:31:24 <CADD> SrPx: pretty much. although scala is officially now more popular than haskell.. *sob*
23:31:31 <dissipate_> CADD, nope: http://shaffner.us/cs/papers/tarpit.pdf
23:31:36 <Twey> SrPx: ATS is a thing, you know.
23:31:40 <yyyyy> Twey: You should look into SPARK. It has exactly what you need. Not FP, though.
23:31:41 <Twey> If that's all you're worried about.
23:31:49 <CADD> dissipate_: thanks
23:31:54 <Twey> yyyyy: Is that the Ada thing?
23:32:10 <dalaing> Twey: any thoughts on Rust?
23:32:18 <Twey> dalaing: Rust is okay
23:32:23 <CADD> Twey: i am definatly on the road of PLT
23:32:24 <dissipate_> CADD, another link if that one doesn't work: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.93.8928
23:32:45 <CADD> Twey: write yourself a scheme was a lot of fun. although i need to get better at agda
23:32:52 <Twey> dalaing: I think not including dependent types in Rust is an error
23:33:04 <yyyyy> Twey: Yes. It has an integrated theorem prover. The syntax was bearable until the latest standard, which seems to have improved it massively. On the semantics side many new things appeared.
23:33:20 <CADD> Twey: i think not including dependent types in any language is an error :)
23:33:40 <CADD> Twey: although apparently singleton types are just as good as dependent types.
23:33:40 <Twey> CADD: Dynamic languages are easy enough, but type theory requires thought and mathematics, neither of which I'm particularly good at :þ
23:33:44 * hackagebot yesod-platform 1.2.4.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4.2 (MichaelSnoyman)
23:34:06 <CADD> Twey: well dynamic languages are just unityped langs. but you know that
23:34:07 <dalaing> Twey: C/C++ interop are on their must-have list, not sure how dependent typing would fair on that front
23:34:31 <Twey> dalaing: Just fine
23:34:40 <yyyyy> Twey: www.spark-2014.org
23:34:56 <dalaing> Twey: sorry, efficient C/C++ interop are on their must-have list :)
23:35:13 <Twey> dalaing: A more powerful type system never takes power away.  Types are irrelevant to performance; they'll probably all be erased by runtime anyway.
23:35:41 <Twey> (okay, sometimes dependent languages have problems with that last one, but that's the theory)
23:35:49 <Twey> yyyyy: Thanks; will investigate
23:36:11 <CADD> yyyyy: 'you cannot proceed from the informal to the formal by formal means' - Perlis
23:36:35 <Twey> CADD: Ada and Spark have always been pretty formalized, though.
23:36:52 <CADD> Twey: i know, im just quote mining.. :)
23:36:59 <Twey> Ahuh.
23:37:58 <yyyyy> CADD: I do admit I like Ada. I know it's not trendy at all, and I'll get stoned publicly, but it's the most enjoyable imperative language there is IMHO.
23:38:13 <CADD> Twey: ok hey, you are in lojban too
23:38:31 <CADD> yyyyy: well, i would rather use it than most imperative langs. sadly i havent yet
23:38:54 <Twey> CADD: I've been there for a long time.  ☺
23:39:08 <k00mi> Twey: I don't think dependent types in a non-research language is a good idea just yet, especially if you want actual industry adaption
23:39:13 <CADD> yyyyy: plus ada is govt approved. :)
23:39:24 <CADD> Twey: yeah, im still very green at lojban
23:39:57 <yyyyy> CADD: if you do have some free time look into SPARK directly. The flow control is specially nice, and there are many static checks in the code, though the approach is very different than e.g. haskell
23:40:12 <Twey> k00mi: AFAIUI dependent types are on the cusp right now — they've got solid (if new) theory behind them, but need some work to be nicer to use
23:40:15 <zRecursive> @src seq
23:40:15 <lambdabot> Source not found. Maybe you made a typo?
23:40:37 <CADD> yyyyy: i definitely will!
23:40:45 <CADD> yyyyy: i was actually just looking at it
23:41:03 <Twey> k00mi: But they're powerful enough that any new discoveries should be implementable after the fact
23:41:30 <Twey> (e.g. HoTT in Agda)
23:42:50 <yyyyy> CADD: government approved might be a con ;). But cross-pollinating approaches with the SPARK team could be fruitful.
23:42:54 <k00mi> Twey: I think that's better left to Idris and the like, rust isn't supposed to be that revolutionary
23:43:13 <k00mi> Twey: is HoTT in Agda possible? I thought there are fundamental differences
23:43:20 <CADD> yyyyy: you are completely right on that front ;)
23:43:27 <k00mi> or rather, one fundamental difference
23:43:35 <CADD> k00mi: yeah, its been implemented in coq and agda
23:43:58 <CADD> k00mi: https://github.com/HoTT/HoTT-Agda
23:44:37 <yyyyy> the HoTT book got here almost a week ago. I haven't got the time to read it until now. I'll happily clone that repository.
23:45:21 <CADD> yyyyy: yeah, i like agda a bit more than coq. although i know that if i want to be serious i will eventually have to bite the bullet and learn coq
23:46:30 <Twey> k00mi: AFAIK, the only issue that's been found so far is that certain types of pattern-matching in Agda allowed the proof of axiom K, which is inconsistent with HoTT
23:46:36 <yyyyy> CADD: are there substantial limitations in Agda precluding its use? I thought the major distinction in usage (notwithstanding the foundational differences) was tactics in coq
23:46:45 <CADD> yyyyy: take a look at this branch: https://github.com/HoTT/HoTT-Agda/tree/2.0 its where all the new improvements are happening
23:46:54 <Twey> (the Agda people added a flag to restrict pattern-matching to patterns not known to be sufficient to prove K)
23:47:13 <CADD> yyyyy: yeah, coq is very heavily based on tactics while agda takes the pattern matching approach
23:47:44 <CADD> yyyyy: so no limitiations, just different ways.
23:47:59 <CADD> yyyyy: turing completeness, yadda yadda
23:48:35 <Twey> CADD: Um, Turing-completeness invalidates a proof assistant :þ
23:48:44 <yyyyy> CADD: thanks for the link!
23:49:18 <CADD> Twey: i know. there is termination checking. but from a plt standpoint the ability to program anything still stands
23:49:29 <CADD> yyyyy: np :)
23:50:05 <Twey> CADD: Hmm?  That's not true — there are terminating programs that can't be proven terminating
23:51:06 <CADD> Twey: you are completely right, i meant turing completeness more as the capability of the language to express any problem more than its proper definition
23:51:36 <Twey> Rather depends on the power of the termination checker, I'd assume
23:51:56 <Twey> I don't know whether Coq and Agda have been proven formally equivalent in computational power
23:52:07 <CADD> Twey: yeah, shouldnt have abused definitions around a bunch of very pedantic people. and this is speaking as a very pedantic person.. :)
23:52:09 <yyyyy> CADD: if i remember jacquard looms are turing complete as well, but i'd refrain from doing proofs with them :) too laborious
23:52:20 <Twey> Heh, sorry
23:52:39 <CADD> Twey: i dont know if they can. but that would be interesting!
23:52:45 <CADD> Twey: no need to be sorry
23:52:57 <CADD> Twey: please, catch me on my bullshit. i would do the same. :)
23:53:10 <CADD> yyyyy: omg
