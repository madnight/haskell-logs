00:00:16 <mm_freak> complicated syntax, retarded type system, language-driven runtime
00:00:33 <startling> I'm impressed by runtimeless Rust.
00:01:00 <Ghoul_> bare metal rust is quite impressive
00:01:22 <Ghoul_> If only they didnt decide to implement a runtime system. Then the language would have more merit, as It'd be a "better C"
00:01:24 <startling> My favorite thing about Rust, though, was hearing people say in #rust that their Maybe (Option?) was a Monad, and having them say the local equivalent to "maybe" when asked what bind was.
00:01:25 <ReinH> startling: hey, you leave Ruby out of this :p
00:01:29 <ReinH> no but seriously it sucks
00:02:04 <thoughtpolice> why is this conversation happening in #haskell? i'm pretty sure useless language bashing is pretty off topic here
00:02:09 <startling> Things have changed since then (you can at least have functors ...) but not a lot.
00:02:13 <shachaf> thoughtpolice++
00:02:20 <thoughtpolice> and all of it is annoying, at the least
00:02:22 <startling> thoughtpolice: yeah, I'll step out here. My apologies.
00:02:31 <ReinH> thoughtpolice: is that (useless langauge) bashing or useless (langauge bashing)? ;)
00:02:40 <Ghoul_> hahha
00:02:45 <mm_freak> thoughtpolice: you're right…  i apologize
00:02:50 <thoughtpolice> ReinH: take your pick, just do it somewhere else
00:03:30 <ReinH> thoughtpolice: why do you hate fun? ;)
00:03:40 <mm_freak> but PHP bashing is still on-topic, ok?
00:03:59 <shachaf> mm_freak: No. Stop it.
00:04:07 <mm_freak> just joking =)
00:04:36 <shachaf> This is really tiresome at this point.
00:05:02 <ReinH> shachaf: but how will we feel superior to other langauges if we don't remind ourselves constantly?
00:05:10 <ReinH> it's a problem.
00:05:20 <mm_freak> #haskell-bash
00:05:20 <shachaf> ReinH: Saying these things ironically is still saying them.
00:05:57 <ReinH> ... but it's saying them ironically?
00:06:29 <ReinH> I don't have a horse in this race. The whole thing is pretty funny. But I can see how it would get tiresome.
00:07:17 <mm_freak> all of this bashing really just means that there should be a programming languages channel, where all communities are represented
00:07:33 <mm_freak> then instead of bashing, we could learn from each other
00:07:35 <ReinH> mm_freak: that would work about as well as #religion or #politics
00:07:41 <ReinH> if those were things
00:08:22 <mm_freak> ReinH: channel rules and kickbans solve that easily
00:08:51 <ReinH> no one is that dedicated
00:09:53 <mm_freak> well, i'm not opening that channel, but anyway…  more communication could really help all language communities, including haskell…  after all i bash haskell all the time, at least silently in my room =)
00:10:10 <shachaf> What good do rules and such do if no one pays attention to them?
00:11:09 * mm_freak .o(fix Monad already! fix Prelude already! fix fmap already!)
00:11:56 <earthy> mm_freak: sounds like lambda the ultimate...
00:12:43 <startling> We should have a channel where we all talk about languages that aren't haskell in positive tones.
00:13:07 <mm_freak> #haskell-love?
00:13:14 <mm_freak> how about a haskell flirt channel?
00:14:03 <toltolt> I'd love to flirt with some languages (Java's new lambda functions seem pretty cool)
00:14:26 <startling> #not-haskell
00:15:06 <mm_freak> ok, this is getting weird…  i'll turn to my beloved haskell code again =P
00:16:10 <pharaun> i have a parsec question actually! (distraction ;p)
00:16:21 <mm_freak> as a last remark, i noticed that not using other languages really helps bashing them less =)
00:16:28 <ReinH> You know what would also be nice?
00:16:34 <ReinH> A channel where we talk about Haskell.
00:16:41 <pharaun> the grammar is unfortunately not under my control, but i am wondering what is a good way to deal with this case in parse
00:17:08 <mm_freak> @remember ReinH <ReinH> You know what would also be nice? <ReinH> A channel where we talk about Haskell.
00:17:08 <lambdabot> I will never forget.
00:17:17 <ReinH> heh
00:17:22 <pharaun> *parsec - "((a) b)-" -> I want to grab the first ( then grab whatever content is inside till the last ) and then grab the )
00:17:42 <mm_freak> pharaun: see 'between'
00:17:54 <bartavelle> if a package gets into stackage, it means it will eventually end on SoH, right ?
00:17:56 <johnw> won't between parse "(a"?
00:17:58 <pharaun> i'm not sure of a good way of dealing with that other than maybe paren counting but then that could lead me to trouble in cases like "((a b)-"
00:18:08 <mm_freak> pharaun: and use it recursively to handle the inner parentheses
00:18:12 <johnw> oh, I think between handles nesting, right
00:18:14 <pharaun> mm_freak: yup i've been playing with between, but it seems to match on the first )
00:18:22 <mm_freak> johnw: it doesn't handle nesting
00:18:26 <pharaun> it doesn't
00:18:29 <johnw> oh, n/m then
00:18:38 <pharaun> i actually am already using between :)
00:18:43 <mm_freak> pharaun: that's why you don't just use 'many anyChar'
00:18:46 <johnw> shouldn't be hard to write a betweenRecursive
00:18:55 <ReinH> Speaking of regular langauges, there's a joke somewhere that has the punchline "Now you have n log n problems"... and I want to find it.
00:18:58 <pharaun> but unfortunately the content -> between ( <content> ) is not within my control
00:19:01 <mm_freak> pharaun: you use an actual parser that handles (i.e. consumes!) the inner pair of parentheses
00:19:11 <pharaun> so it can have anything inside :\
00:19:31 <mm_freak> pharaun: if it can contain unbalanced parentheses, then the grammar is broken
00:19:46 <pharaun> haha its trying to do language parsing
00:20:00 <pharaun> i'm wanting to use the () to mark something inside as "unescaped"
00:20:19 <pharaun> and to stop parsing that and take it as a literal
00:20:40 <mm_freak> pharaun: you then need to have some kind of escape for ')'
00:20:53 <pharaun> such as \) ?
00:20:57 <mm_freak> yeah
00:20:59 <pharaun> yeah :\
00:21:13 <mm_freak> pharaun: in other words, first get the grammar right =)
00:21:29 <pharaun> grammar isn't exactly under my control
00:21:45 <pharaun> but i think i may be able to do some adjustment/tweak to make it better
00:21:48 <pharaun> alright thanks.
00:21:53 <mm_freak> pharaun: i understand the problem…  it's pretty much the HTML 4 problem
00:22:00 <mm_freak> where a <p> doesn't need a </p>
00:22:05 <pharaun> ahhh yes
00:22:10 <pharaun> that's exactly the problem it is :\
00:22:20 <mm_freak> pharaun: there is really only one solution:  heuristics
00:22:24 <pharaun> is there any good html4 parser examples in haskell that i could dig into to see how its done
00:22:52 <pharaun> mm_freak: that's what i am... kinda discovering :) i just need to start figuring out how i can do this heuristics,
00:23:15 <pharaun> i guess i *do* control the input so i could maybe do some form of pre-processing
00:23:17 <mm_freak> pharaun: well, what comes after the closing ')'?
00:23:40 <mm_freak> and which part of the grammar is beyond your control?  only between the parentheses or the whole grammar?
00:23:48 <pharaun> typically a restricted set of character, but it unfortunately can be within the parentheses
00:23:58 <pharaun> the content between the parentheses
00:24:04 <mm_freak> then preprocess
00:24:07 <pharaun> but the braces/outside part i can adjust
00:24:26 <mm_freak> (\(a\)bcd\()
00:24:41 <mm_freak> (the "\(" just for uniformity)
00:24:49 <pharaun> hmm
00:24:52 <pharaun> that's a good idea
00:25:07 <pharaun> then i could scan for the closing brace and boom capture the content within
00:25:27 <mm_freak> so it's not like HTML4 where the grammar itself is like this…  you really just need to embed an arbitrary string =)
00:25:37 <mm_freak> in fact you could just as well base64 it
00:25:44 <pharaun> the string within ?
00:25:46 <mm_freak> yes
00:25:53 <mm_freak> then you can probably even do without the parentheses
00:25:58 <pharaun> hmm
00:26:00 <mm_freak> but it's not human-friendly
00:26:04 <pharaun> heh yeah
00:26:19 <pharaun> i'm still quite curious about the html4 case
00:26:52 <pharaun> its the one where, you have opening tags but are not required to have closing tag, and you can sometime mix the ordering ie <i><b>da</i></b> and that's "valid" ?
00:26:56 <mm_freak> there are some HTML libraries out there, but i'm not sure how they handle these cases…  also implementations often disagree about how to handle them
00:27:12 <mm_freak> no, that's not valid
00:27:17 <johnw> tag elision is part of the SGML specification
00:27:26 <pharaun> oh its not? cuz i know i've seen that in some html docs before :\
00:27:29 <mm_freak> but this is valid:  <b>not italic <i>italic</b>
00:27:33 <johnw> it requires knowing the schema for the tag grammar
00:27:38 <mm_freak> the <i> is implicitly closed by the </b>
00:27:42 <pharaun> ahhh
00:27:45 <mm_freak> or:  <p>para 1 <p>para 2
00:27:52 <mm_freak> the first <p> is closed by the second <p>
00:27:54 <johnw> note that this is a feature which XML specifically dropped
00:28:09 <pharaun> johnw: the not needing a closing tag?
00:28:11 <startling> johnw: hey you
00:28:13 <johnw> yeah
00:28:19 <startling> johnw: did I miss the Chicago haskell thing?
00:28:21 <pharaun> that's... a good thing it sounds like :p
00:28:43 <johnw> startling: Sep 14
00:29:22 <startling> Aha. Thanks!
00:29:23 <arbn> Yay for more Haskell meetups in the eastern half of the US. :)
00:29:27 <pharaun> mm_freak: anyway thanks gave me some stuff to chew on :)
00:29:36 <mm_freak> have fun =)
00:29:39 <pharaun> was starting to drive myself a little nutty with this one
00:30:19 <startling> johnw, where can I find more information about it? The G+ page you linked to before isn't showing me anything, potentially because I do not have a G+ account.
00:30:43 <mm_freak> pharaun: one additional note though:  be rigorous about escaping, if you don't trust the foreign string
00:30:55 <pharaun> yeah i don't trust it at all
00:31:03 <pharaun> alright will double check escaping and stuff
00:31:05 <mm_freak> then base64 is probably a good idea
00:31:22 <mm_freak> note the type:  ByteString -> Base64
00:31:25 <mm_freak> it's not Text -> Base64
00:31:45 <pharaun> yup
00:31:48 <johnw> looking
00:31:56 <pharaun> don't want to touch it more than i have to
00:32:29 <mm_freak> i don't know the application, but if you should just pass it on without processing it, it's probably a good idea to treat it as a ByteString, not text
00:32:39 <mm_freak> base64 is also used by XML to embed binary data
00:33:00 <pharaun> oh it is? i'll admit i haven't needed to deal with binary data in xml before (probably for the better of my sanity)
00:33:09 <pharaun> anyway good to know
00:33:18 <mm_freak> yes, XML has binary data types
00:33:25 <mm_freak> and the encoding is base64
00:33:40 <pharaun> does make sense i suppose
00:33:50 <mm_freak> yeah…
00:33:51 <johnw> startling: Sept 14 4PM-8:30PM 659 W Diversey Pkwy Chicago, IL 60657‎ (773) 472-3667 nextdoorchi.com
00:34:17 <mm_freak> you're lucky:  haskell actually makes a difference there…  Text and ByteString are incompatible, which is good =)
00:34:34 <mm_freak> except that ByteString has an unsafe "Char8" interface
00:34:46 <pharaun> good ol' Char8
00:34:58 <pharaun> some of my first project used Char8 got slapped rightfully for that
00:35:40 <mm_freak> =)
00:37:01 <startling> johnw: saving it. thank you very much.
00:41:29 <Ghoul_> is readInt8OffPtr a primop?
00:46:02 <Ghoul_> ok, different question. Is it safe to read things directly into a block of memory, particularly, numeric types?
00:46:57 <Ghoul_> If I use the Foreign.Storable stuff they have to be copied once, but if I read the size of the object directly into a buffer I dont need to copy it at all. Is this safe? Does Foreign.Storable do magical things like correct signs or something?
00:47:31 <Ghoul_> *magical things I can't do without
00:48:52 <mm_freak> Ghoul_: Storable is safe for some value of "safe"
00:49:27 <mm_freak> Ghoul_: it works with pointers, which are inherently an impure concept, and Storable actions are in IO
00:50:21 <mm_freak> Ghoul_: about size, if the pointers are compatible and you get the number of elements right, it should be fine
00:51:17 <Ghoul_> mm_freak: what about not using storable?
00:51:48 <Ghoul_> like, I think I can figure out how to hack together an arbituary garbage collected allocation somehow, then pass it through `with`
00:52:03 <Ghoul_> then I have a pointer, and can do things like hGetBuf directly onto it
00:52:09 <Ghoul_> is that relatively *correct*?
00:52:38 <mm_freak> Ghoul_: you have to get allocation, finalization and marshalling right
00:53:02 <mm_freak> Ghoul_: to see how this works, have a look at the source code of 'bytestring' or 'vector'
00:53:26 <Ghoul_> ok
00:53:38 <mm_freak> in general the answer is:  use ByteString
01:06:18 <pharaun> hm dunno if i should be surprised or not, but there's no ffi binding for lxml
01:10:22 <Ghoul_> well, PSA, bytestring is much much faster than I thought it was
01:10:23 <_emm_> pharaun: the Python library?
01:10:44 <Ghoul_> especially Network.Socket.ByteString which uses O(1) unsafe marshall stuff for construction
01:11:19 <Iceland_jack> N.S.ByteString is fantastic
01:11:24 <pharaun> doh i could've swore it was an C library
01:11:29 <pharaun> guess i was thinking of libxml2 nvm :)
01:12:07 <_emm_> pharaun: well, it is python-compiled-to-C, mostly, with libxml2 underneath
01:12:16 <Ghoul_> I saw `unsafePackAddressLen` and was like "I'm gonna go out and beat ByteString at it's own game"
01:12:29 <Ghoul_> but it uses something even faster already :(
01:12:45 <pharaun> _emm_: yeah, still, doh :) my bad
01:16:54 <jkoppel> How can I tell if a Haskell library is built with profiling?
01:17:32 <arkeet> see if there are .p_hi files?
01:20:00 <jkoppel> @arkeet: Thanks!
01:20:00 <lambdabot> Unknown command, try @list
01:23:25 <jkoppel> Looks like I got my libraries to build with profiling, but my program itself is refusing to...
01:31:29 <jkoppel> Running "cabal install --enable-executable-profiling" gets halfway through the compilation and then errors with 'unknown symbol `_pushCostCentre'"
01:36:02 <jkoppel> And if I instead run "cabal configure --enable-executable-profiling" followed by "cabal build," I get
01:36:49 <jkoppel> Tarski/SCM/Src.hs:1:1:
01:36:49 <jkoppel>     cannot find normal object file `dist/build/my-program/my-program-tmp/My/Modules/Foo.o'
01:36:50 <jkoppel>     while linking an interpreted expression
01:43:39 <Taneb> I think you know you're doing Haskell right when the inferred type signature is "fact :: a1 -> (((Any * -> Any *) -> (Any * -> Any * -> Any *) -> Any * -> Any *) -> (Any * -> e -> Any *) -> ((Any * -> Any *) -> Any * -> Any *) -> a -> b) -> b"
01:53:16 <mm_freak> :k Any
01:53:17 <lambdabot> *
01:53:56 <mm_freak> what is Any?
01:54:22 <mm_freak> and what does 'Any *' mean?  since when can types depend on kinds?
01:54:31 <Taneb> mm_freak, it's in GHC.Prim
01:54:48 <Taneb> I'm not actually quite sure what it's for, but it's connected with unsafeCoerce
01:55:21 <mm_freak> hmm, ok
01:55:50 <Taneb> (basically I'm writing horrible obfuscated code for fun)
01:56:33 <mm_freak> but i still wonder how Any can take a kind as its argument…
01:58:26 <danr> :k Any *
01:58:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:00:46 <Taneb> mm_freak, it doesn't, that's just PolyKinds syntax
02:00:49 <Enigmagic> :k Int
02:00:51 <lambdabot> *
02:00:53 <Taneb> I think it means "Any but with kind *"
02:00:59 <Enigmagic> right.
02:01:09 <mm_freak> Taneb: according to the documentation Any does in fact take a kind argument
02:01:20 <mm_freak> :k Any
02:01:21 <lambdabot> *
02:01:22 <Zenol> good morning.
02:01:25 <mm_freak> weird
02:03:02 <mm_freak> at some point we have to admit defeat and finally collapse the hierarchy =)
02:04:18 <mm_freak> or at least get dependent type /syntax/ into haskell…  not actual dependent types, but at least the dependent arrow syntax
02:09:02 * hackagebot murder 1.3.3 - MUtually Recursive Definitions Explicitly Represented  http://hackage.haskell.org/package/murder-1.3.3 (MarcosViera)
02:18:50 <Zenol> are they a "range" type. (So that f :: Range 0 7 -> V can only be called as f 0, ..., f 7 ?)
02:19:02 * hackagebot halberd 0.1.2.2 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.2 (ErikHesselink)
02:24:23 <t7> can i check if a point is in a circle without sqrt or trig?
02:24:47 <t7> or is sqrt fast in glsl
02:25:08 <t7> oh i can do distance squared :D
02:25:22 <Maior> t7: yes
02:25:25 <t7> now i can do fast perfect circles
02:25:34 <Cale> Yeah, x^2 + y^2 = r^2
02:25:48 <t7> but they wont be smooth
02:26:19 <t7> need some kinda modulo pixel thing
02:27:15 <Itkovian> t7 Bresenham?
02:27:16 <t7> now i just need to write 500 lines of boilerplate to test this
02:29:49 <Yaniel> t7 smoothstep
02:39:52 <t7> it works hahaha
02:42:24 * Zenol is tired of writing 30 times the same line with only few changes.
02:42:57 <t7> haha anti aliasing
02:43:33 <Sculptor> it works, IT WORKS!!! OMG! OMG! OMG! OMG!.... I mean, it compiles... now what is a segfault?
02:44:06 <Zenol> Sculptor: segfault? Are you using unsafe coerce ? x)
02:44:35 <Sculptor> that is actualy from #c++ channel
02:44:50 <Zenol> oh, ok.
02:46:25 <t7> http://i.imgur.com/FryNjC6.png
02:47:06 <Zenol> what's really wonderfull with ghc, it's that you can load your code in ghci, then type :r until it compile, and then test it. You don't have to recompile the whole binary at each step.
02:47:32 <mm_freak> t7: looks like a repa one-liner
02:47:40 <Zenol> t7: Nice circle :)
02:47:54 <mm_freak> or an accelerate one-liner, if you want to do it on the GPU =)
02:48:17 <t7> no conditionals so that should be really fast too
02:48:35 <mm_freak> i remember when i wrote my first shader
02:48:38 <mm_freak> it was hell =/
02:51:15 <ocharles> i still have a video of my first "big" terrain engine
02:51:25 <ocharles> it has pixel shaded water!
02:51:57 <mm_freak> cool
02:52:06 <mm_freak> with caustics?
02:52:08 <ocharles> naw
02:52:33 <mm_freak> where is the video? =)
02:52:34 <ocharles> it just renders the world with a y scale of -1, and then perturbs that with a normal map
02:52:37 <ocharles> iirc
02:52:37 <ocharles> let me dig it out
02:52:45 <ocharles> i have to remember how to connect to sourceforge :P
02:52:58 <h007> hello, some help with parallel haskell, please. i have a tree data type: data T a = L a | N (T a) (T a) and i want to evaluate each branch (at the top level, or maybe ability to specify at which depth) in parallel, using parallel strategies. I don't want to evaluate each element in the tree in parallel, but branches. is this possible using the `using` function as we do for lists?
02:52:59 <mm_freak> ah, so it's just reflective
02:53:08 <ocharles> reflective but with a fresnal index
02:53:20 <ocharles> or however you spell it
02:53:36 <mm_freak> "refractive index"?
02:54:02 <ocharles> https://en.wikipedia.org/wiki/Fresnel_equations
02:54:17 <ocharles> so at shallow angles it is reflective, and at bigger angles it's transparent
02:54:21 <mm_freak> ah
02:54:59 <mm_freak> ocharles: would you want to work together with me on an SDL+OpenGL rendering engine based on netwire?
02:55:26 <quchen> h007: By "evaluating", do you mean deepseq the branches at top level?
02:55:40 <h007> quchen: yes
02:55:57 <ocharles> mm_freak: http://fraction.sourceforge.net/videos/Lovely%20water.avi
02:56:00 <ocharles> mm_freak: absolutely!
02:56:06 <quchen> h007: Sure you can do that with strategies
02:56:50 <mm_freak> ocharles: amazing!
02:57:04 <ocharles> mm_freak: oh, also http://fraction.sourceforge.net/videos/Better%20water.avi
02:57:07 <ocharles> i don't know which is newer :P
02:57:22 <ocharles> i think this is the only evidence i have that i programmed before going to university :(
02:57:25 <remdezx> Hi all! Do you now how can I list drives on Windows in Haskell? I search a lot but didn't find anything.
02:57:25 <h007> quchen: so if i have N t1 t2 for example, i want to evaluate t1 and t2 in parallel and not every element in parallel in the list. I found parList evaluates every element in parallel. But parListChunk is similar to what i want but I am having difficulty defining it for trees
02:57:26 <Zenol> ocharles: Wow, beautiful :D
02:57:50 <quchen> h007: `rparWith rdeepseq` gives you a strategy to deepseq something. Apply that to each branch you want to evaluate.
02:58:09 <mm_freak> ocharles: the second one is animated, so it's probably newer
02:58:15 <mm_freak> but both look really great
02:58:15 <ocharles> ah yes
02:58:19 <ocharles> h007: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
02:58:43 <ocharles> h007: though you seem to understand the basics, you might have missed something
02:58:45 <ocharles> mm_freak: thanks :)
02:59:07 <ocharles> mm_freak: i was really into the "ShaderX" books when i was a kid, though a lot of it went over my head I could usually hack something close enough together
02:59:12 <remdezx> Hi all! Do you now how can I list drives on Windows in Haskell? I search a lot but didn't find anything.
02:59:15 <ocharles> now it's quite nice that i actually have a bit of a clue what's going on
02:59:21 <donri> is that link meant to be public
03:00:17 <ocharles> donri: it comes up in google so i don't see why not
03:00:29 <mm_freak> ocharles: yeah…  unfortunately my optics knowledge is rather limited…  once the release is out i will do a proof of concept framework for gloss
03:00:44 <ocharles> mm_freak: so are you thinking 2d or 3d?
03:00:49 <mm_freak> 3D
03:00:53 <ocharles> ambitious
03:00:57 <quchen> h007: So you'd do something like `evalTreeTop (N l r) = N (l `using` rparWith rdeepseq) (l `using` rparWith rdeepseq)`
03:01:08 <quchen> (At least conceptually, haven't checked it)
03:01:11 <ocharles> but i guess gloss sorta has the 2d stuff covered quite well
03:01:27 <mm_freak> ocharles: not sure yet about the data structures…  i'll probably keep it general enough, so that users can choose a suitable data structure based on scene
03:01:36 <mm_freak> for example BSP for in-doors, something else for outdoors
03:01:48 <ocharles> yea
03:01:54 <ocharles> quad trees work well for outdoors
03:01:59 <ocharles> because the scene is usually quite sparse
03:02:30 <mm_freak> what did you use for the terrain?
03:02:46 <h007> ocharles, quchen: i have this, which doesn't seem to work http://lpaste.net/92587
03:03:34 <Ghoul_> remdezx: look at the package win32
03:03:37 <mm_freak> h007: rpar (f x) evaluates the Eval X value, not the X
03:03:41 <mm_freak> h007: see rparWith
03:03:51 <quchen> h007: rpar only sparks.
03:03:54 <Ghoul_> remdezx:  Find out how you would do it in C++, then use that, if you're looking for a non-portable way of doing it
03:04:10 <Ghoul_> /s/then use that/then implement that using the win32 package/
03:04:23 <quchen> h007: The issue you're having is why I used `rparWith rdeepseq` in my example above (instead of just `rpar`).
03:04:58 <mm_freak> h007: you should read the chapter that ocharles linked
03:05:05 <remdezx> Ghoul_: I would like to do it portable - on windows return disk letters and under linux just return "/"
03:05:08 <h007> quchen: http://lpaste.net/92587 this doesn't work either. I want to be able to do myTree `using` parTreeTopLevelOnly (something like this)
03:05:47 <quchen> h007: Even if you call it with s = rdeepseq?
03:06:30 <quchen> Anyway, what mm_freak said ocharles said.
03:06:35 <ocharles> mm_freak: data structures?
03:06:44 <ocharles> mm_freak: pretty sure that's just a uniform grid with a heightmap
03:06:51 <ocharles> i'm not sure i do any occlusion
03:07:02 <ocharles> nor lod
03:07:14 <donri> man i can't believe i never bothered to try :[s]print/:force in ghci
03:08:40 <mm_freak> ocharles: ah, ok
03:08:50 <mm_freak> ocharles: i'll let you know once i start with the gloss framework =)
03:09:55 <danilo2> Hello! I've got a naming question. In Haskell It is inpossibble to define data constructor (->>) (like: data Ala = Int ->> Int deriving(Show)), but it is possible to define (:-:) (like:  data Ala = Int :-: Int deriving(Show)) AND it is not possible to define function (:-:) but it is possible to define function (->>) why? What are the names, which can be canstructors and functions?
03:10:09 <ocharles> mm_freak: yea, i'm eagerly refreshing the netwire change long for this new "big change" :)
03:10:29 <mm_freak> danilo2: infix data constructors have to start with a colon
03:10:30 <quchen> danilo2: Leading ":" is reserved for data constructors, yes.
03:10:38 <donri> danilo2: it used to be consistent but they broke it in 7.6 to allow for prettier type level programming
03:10:44 <mm_freak> danilo2: pretty much everything else has to start with noncolon
03:10:46 <danilo2> oh so constructors can start ONLY with colon?
03:10:49 <donri> danilo2: oh i misread
03:11:19 <h007> quchen, ocharles, mm_freak: http://lpaste.net/92587 i think i try to apply a basic strategy (type variable `a`) to the `T a`, that's why i get the error. but can't seem how to fix this.
03:11:46 <donri> danilo2: [without TypeOperators] : count as an upper case character, and any other non-alphanumeric character as lower case
03:12:17 <ocharles> donri: in 7.6 can anything be a type operator (other than ->, =>, ::) ?
03:12:24 <danilo2> quchen, donri, mm_frak: This is not likely to change? I understand that if I want to make infix constructor it HAS TO begin with ":" ?
03:12:32 <donri> and actually i don't think type operators affect data constructors anyway
03:12:37 <donri> that would make pattern matching ambiguous
03:12:53 <donri> so tldr ignore most of what i said ;)
03:13:01 <danilo2> donri - ok, thank you :)
03:13:27 <donri> danilo2: the key here is pattern matching. you need some syntactical distinction to make it unambiguous and sane.
03:13:31 <mm_freak> danilo2: you can write wrapper functions which have noncolon names
03:13:44 <mm_freak> (->>) = (:->>)
03:13:49 <quchen> danilo2: Not sure about the status of this, but I'd treat it on a similar level as "data constructors begin with capitals": infix data constructors start with colons.
03:13:52 <donri> @src %
03:13:52 <lambdabot> x % y = reduce (x * signum y) (abs y)
03:13:54 <danilo2> donri: btw it would not make pattern matching ambigous - in pattern amtching there is impossible to have function calls, so every such infix operator would be type constructor
03:14:03 <quchen> mm_freak: You can't pattern match on ->> though.
03:14:10 <mm_freak> danilo2: for pattern-matching you still need (:->>) though
03:14:34 <donri> > case () of (->>) -> (->>)
03:14:35 <lambdabot>   ()
03:16:04 <donri> danilo2: note that a top-level "function definition" is really just a binding pattern match
03:16:45 <donri> > let Just x = Just 2 in x -- strip the let..in and this works in the top-level too
03:16:46 <lambdabot>   2
03:16:54 <donri> that's like x = 2
03:17:44 <danilo2> hmm ok :) It makes sense, but I was not aware of this before :) thnaks :
03:17:45 <danilo2> :)
03:17:52 <donri> so it would make operator definitions syntactically ambiguous
03:18:21 <donri> which could possibly work by resolving it later, haskell is already ambiguous with the fixities
03:18:25 <donri> but let's not make it worse!
03:18:29 <hmaster> danilo2: you are wrong
03:20:16 <danilo2> hmaster: what do you mean - I am wrong?
03:20:47 <hmaster> danilo2: yes
03:22:28 <danilo2> Is it not possible in Haskell to create data consturctor named ":" ?
03:22:57 <merijn> danilo2: No, because it already exists, you can make other infix data constructors, though
03:23:51 <danilo2> merijn: I wanted to hide the Prelude definition and override it, but it seems not possible though
03:24:11 <dpwright> Hmm, debugging some code at the moment, just wondering -- is there any equivalent of __FILE__, __LINE__ in C for haskell?
03:24:14 <merijn> danilo2: I'm pretty sure list syntax is hard coded in GHC, so that won't work
03:24:35 <merijn> dpwright: I'm pretty sure you can use those with the CPP extension
03:24:39 <danr> dpwright: you can get it with template haskell
03:24:48 <danr> but I think the CPP pragmas are there too
03:24:57 <dpwright> merijn: Oh cool, thanks
03:25:16 <merijn> {-# LANGUAGE CPP #-}
03:25:52 <quchen> h007: The type sig for your parT is wrong. The strategy you're providing is one for sub-trees, and not for elements.
03:26:00 <quchen> Annotated http://lpaste.net/92587
03:26:05 <dpwright> seems to work -- thanks!
03:27:41 <quchen> h007: And in general if the types don't check because of "rigid variable" then delete your type sig and see what GHC infers instead :-)
03:28:05 <h007> quchen: ok, testing now
03:28:53 <ben__> can anyone tell me what a .tix file is any why I might get a segfault that goes away when I delete it?
03:34:09 <quchen> h007: And I think by nesting parT you can go n levels deep, i.e. "`using` parT (parT rdeepSeq)" will go to level 2 in your tree in parallel and then deepseq. You can generalize that using `appEndo . mconcat . map Endo $ replicate n parT` for example.
03:36:56 <quchen> ben__: I've never heard of a .tix file in conjunction with Haskell.
03:37:34 <quchen> (Also not of segfaults, at least in friendly code.)
03:39:18 <h007> quchen: wo this is cool
03:39:36 <h007> do i need to import any other module to use the generalisation
03:49:09 <shiona> Is there some nice mutable forest datastructure?
03:50:42 <ocharles> hi ben__ :) .tix is a summary generated by profiling
03:51:07 <ocharles> i forget exactly what it does, but i'm surprised that would change runtime
03:51:17 <ocharles> ben__: folks in #ghc will probably be interested to hear about that
03:52:27 <zeroXten> wow i really suck at haskell
03:52:43 <ocharles> zeroXten: practice makes perfect
03:52:43 <Cale> zeroXten: having trouble?
03:53:46 <zeroXten> I guess I was just comparing it to picking up something ruby which I found much more natural (coming from perl basically). Python I don't really like. I guess I just need to get used to thinking recursively :)
03:56:48 <ocharles> zeroXten: Ruby, Python and Perl are basically the same with different syntax
03:56:54 <ocharles> zeroXten: Haskell is a whole n'other way of thinking
03:57:06 <ocharles> so you do have to be patient, but i guarantee it pays off :)
03:57:30 <zeroXten> ocharles: yeah exactly
03:58:01 <Cale> Python and Ruby are essentially the same language compared to Haskell.
03:58:04 <zeroXten> i'm kinda used to using some "functional" approachs with ruby and its method chaining.
03:58:27 <zeroXten> like array.map { |e| e + 1 }.uniq.count etc
03:58:49 <Cale> (It always kind of surprises me when someone likes one of those two and not the other)
03:59:10 * hackagebot system-posix-redirect 1.1 - A toy module that allows you to temporarily redirect  a program's stdout.  http://hackage.haskell.org/package/system-posix-redirect-1.1 (LiyangHu)
03:59:56 <mm_freak> the choice between python and ruby is pretty much driven by preference
04:00:29 <mm_freak> there are few technical reasons to prefer one over the other
04:01:35 <mm_freak> zeroXten: and welcome…  good to see you here =)
04:03:34 <zeroXten> heh, blame mm_freak if I have any stupid questions :)
04:03:52 <zeroXten> mm_freak: yeah, in that python sucks and ruby is awsome :)
04:04:07 <ocharles> they all suck next to the mighty Haskell
04:04:10 <zeroXten> hehe
04:04:11 <zeroXten> http://blog.0x10.co.uk/2013/05/a-little-python-vs-ruby.html
04:04:15 <elliott> this topic sucks.
04:04:19 <ocharles> zeroXten: i'll warn you though
04:04:36 <ocharles> if you do get into Haskell and still have to write Ruby, your life will change... for the worse
04:04:45 <ocharles> i'm a Perl coder by profession, and now I can't stand writing it
04:04:55 <zeroXten> haha
04:05:29 <zeroXten> i'll see if I have to take monkey patching to the extreme then :)
04:14:01 <mm_freak> ocharles: 'periodic 1 |- now', to combine the two events with the value of the leftmost taking precedence…  what do you think of this syntax?
04:14:16 <mm_freak> (it means the event that happens now, in one second, in two seconds, etc.)
04:14:43 <ocharles> mm_freak: well |- immediately makes me think of adjunctions
04:14:52 <mm_freak> yeah, me too =/
04:15:18 <donri> so is netwire 5 still afrp?
04:15:23 <mm_freak> donri: sure
04:15:23 <ocharles> can't you fmap a First into there or something to let people choose the semigroup?
04:15:54 <mm_freak> ocharles: that's really clunky
04:16:16 <mm_freak> fmap (fmap Last) (periodic 1) <> fmap (fmap Last) now
04:16:30 <mm_freak> fmap getLast (fmap (fmap Last) (periodic 1) <> fmap (fmap Last) now)
04:16:31 <donri> needs moar Compose
04:16:46 <ocharles> mm_freak: hmm
04:16:59 <mm_freak> here is a cleaner method:  liftA2 (merge const) (periodic 1) now
04:17:09 <mm_freak> and i want to provide an operator for that
04:18:19 <mm_freak> rec x <- delay 1 . hold . sumE . (periodic 1 |& now) -< x
04:18:21 <mm_freak> how about this?
04:19:29 <mm_freak> |& for left-biased, &| for right-biased
04:20:30 <donri> why not <<<<<<< and >>>>>>>
04:20:40 <mm_freak> lol
04:22:49 <mm_freak> i named them (<&) and (&>) now
04:22:59 <ocharles> i think > is the most useful
04:23:09 <ocharles> then you point to who has priority
04:23:14 <mm_freak> yeah
04:23:25 <donri> mm_freak: that could get confusing with lens, where <&> is flip <$> and considering there's <$ (and $> ?)
04:23:44 <mm_freak> donri: it's almost impossible not to get confusing with lens
04:23:49 <donri> hahaha
04:23:56 <donri> fair point
04:24:25 <Letchik> Why isn't it possible to place function's type signature in where block?
04:24:43 <donri> Letchik: but it is
04:24:57 <mm_freak> lens' functions use up almost the entire namespace…  i would even have to rename 'at' to something less clear =)
04:25:15 <mm_freak> now <& at 3 <& at 7
04:25:40 <donri> mm_freak: well i think it's a bigger issue with operators
04:26:07 <mm_freak> donri: they don't clash at least
04:26:16 <Letchik> donri: this http://puu.sh/4jA02/6ac459436f.png doesn't compile, while this http://puu.sh/4jA0n/c2bf5611ae.png does
04:26:33 <quicksilver> I think you have to be a bit bold with operator names
04:26:36 <quicksilver> Letchik: don't use tabs
04:26:48 <Letchik> quicksilver: I dont
04:26:57 <Letchik> hmm
04:26:58 <Letchik> actually
04:26:59 <Letchik> i do
04:27:02 <Letchik> stupid notepad++
04:27:03 <quicksilver> are you sure? the dotted grey lines look like tabs tops
04:27:05 <quicksilver> :)
04:27:25 <mm_freak> this seems to be a regular pattern
04:27:26 <donri> moar liek notepad-- amarite
04:27:34 <mm_freak> "i don't use tabs…  oh wait…" =)
04:27:41 <quicksilver> if you spend your whole time worrying about operator clashes with possible other libraries you never get anything done
04:27:53 <quicksilver> it's not *too* hard to rename operators at the top of a particular file if you want to
04:27:58 <donri> -fwarn-tabs should be the default
04:28:00 <quicksilver> (need to)
04:28:03 <donri> but it's not even enabled by -Wall :/
04:28:05 <mr-> @karma notepad
04:28:05 <lambdabot> notepad has a karma of 49
04:28:19 <mm_freak> notepad++--
04:28:25 <mm_freak> @karma notepad++
04:28:25 <lambdabot> notepad++ has a karma of 0
04:28:40 <int-e> oh no :)
04:28:42 <int-e> @karma c
04:28:42 <lambdabot> c has a karma of 1
04:28:46 <Letchik> @karma vim
04:28:46 <lambdabot> vim has a karma of 2
04:28:56 <Letchik> @karma haskell
04:28:56 <lambdabot> haskell has a karma of 15
04:29:16 <donri> quicksilver: i wasn't talking about namespace collisions though
04:29:20 <int-e> is the C ++ hack still there that would reduce the karma of the person mentioning it? :)
04:29:29 <donri> quicksilver: more like, false expectations
04:29:34 <mm_freak> let's see
04:29:38 <mm_freak> @karma mm_freak
04:29:39 <lambdabot> You have a karma of 10
04:29:45 <mm_freak> no it isn't =)
04:29:49 <donri> @karma is_a_bitch
04:29:50 <lambdabot> is_a_bitch has a karma of 0
04:30:46 <quicksilver> donri: yes you're right that's a slightly different issue. My general point applies though. The namespace of "nice-looking" operators is too small to let development be held up by worrying about it.
04:30:59 <quicksilver> donri: lens might change names, different operators might gain or lose fashion
04:31:33 <ocharles> mm_freak: <& stuff looks good
04:32:26 <mm_freak> alright
04:32:39 <donri> quicksilver: i wasn't suggesting it's a critical issue =)
04:32:52 <Letchik> How long will it take to learn vim to use with haskell?
04:33:14 <fylwind> i was reading "Exploiting Vector Instructions with Generalized Stream Fusion" and i thought "it would be nice if academic papers had a comment thread" :)
04:33:16 <merijn> Letchik: If you already know vim, you mean?
04:33:21 <donri> > 1/0 -- this long, Letchik
04:33:22 <lambdabot>   Infinity
04:33:22 <Letchik> merijn: no
04:33:27 <Letchik> I don't know vim.
04:33:30 <determinant__> @Letchnik, it is a power vs time issue
04:33:30 <lambdabot> Unknown command, try @list
04:33:41 <Letchik> @list
04:33:41 <lambdabot> What module?  Try @listmodules for some ideas.
04:33:44 <merijn> Letchik: Ah, then it will take you as long as using vim in any other languages
04:33:57 <Letchik> merijn: and how long is that?
04:33:58 <laar> Letchik: To learn vim is like to learn haskell, the basics are preaty straight forward, but there is always something more you can learn.
04:34:00 <determinant__> If you don't know vim, then there is a steep hill to reach the peek :)
04:34:02 <merijn> Which may be anywhere from a few months to a couple of years
04:34:05 <determinant__> laar +1 to your comment
04:34:27 <donri> http://mrozekma.com/editor-learning-curve.png
04:35:13 <merijn> Letchik: I think it took me about 3 months to "get" vim, then 6 months to become really adept at it, and probably about 2 years before it replaced my brain to the point where people ask "how do you do that in vim?" and I can't answer without first doing it, because the behaviour has become so automatic I don't even remember what keys to press
04:36:51 <determinant__> Letchik : for a quick start, you should look at ST3 + SublimeREPL
04:36:56 <Cale> I think people focus way too much on text editor usage :P
04:37:02 <Letchik> determinant__: I don't like it
04:37:07 <Letchik> tried
04:37:09 <Letchik> but with ST2
04:37:21 <Cale> I use vim, but the difference between vim and anything else for me is pretty minimal.
04:38:22 <Letchik> Too bad leksah cannot into repl and single source files without cabal project.
04:38:35 <determinant__> Letchik : You don't like ST + Sublime REPL ? If its a preference issue then, you have to climb the Vim mountain
04:39:20 <Cale> The way I use vim probably annoys really hardcore vim people :)
04:39:37 <shiona> same here
04:40:01 <Cale> (For one, I use the arrow keys and spend a lot of time in insert mode :)
04:40:18 <mbrock> it's weird how sectarian some people get about editors, but I do think it's great to learn more about how to edit efficiently with whatever editor you find yourself using...
04:40:20 <merijn> Cale: What, you don't look at your screen and see a list of hjkl and ^] whenever you use some family members windows machine? :p
04:40:50 <mbrock> if nothing else only to postpone or avoid stress injuries from inefficient use of input devices
04:41:03 <fxr> any fay developers here?
04:41:10 <determinant__> Cale : The whole point of modal editing is to use the power, you are way under utilizing the vim :(
04:41:23 <donri> fxr: bergmark is in here and also in #fay
04:41:34 <merijn> fxr: Do you mean "fay developers" as in "people who use fay to write code" or "people who implement fay"? :p
04:41:41 <mbrock> this can also be achieved by typing fewer characters which means you could advocate for Haskell purely in terms of physical health
04:41:55 <Cale> determinant__: It doesn't matter because I'm programming in Haskell, so I spend a tiny fraction of the time I spend thinking on actual typing things in, so optimising that tiny fraction is a waste of my time.
04:42:01 <fxr> merijn: I mean ppl who uses fay
04:42:10 <fxr> donri: tnx
04:43:02 <Cale> The main editor feature I'd actually care about isn't implemented in any editor.
04:43:09 <mbrock> I've noticed that competence in typing and editing can sometimes make me a little reckless, but also willing to try experiments more than others who find editing to be a chore
04:43:18 <tdammers> Cale: what's that?
04:44:00 <Cale> tdammers: I'd like any edit which I make that causes the first non-whitespace character after a layout keyword to move, to cause the remainder of that block to move in the same way.
04:44:11 <tdammers> merijn: my family members do not have Windows computers. I don't allow it.\
04:44:57 <donri> Cale: chrisdone might have that in his structural mode for emacs
04:45:43 <Cale> donri: Perhaps if it could be separated from the rest, that would be interesting.
04:45:45 <tdammers> next best thing I can think of in vim is < and >
04:45:51 <mm_freak> Cale: rectangle editing is a good replacement for that
04:46:09 <tdammers> and rectangle editing (visual block mode), yes
04:46:21 <ben__> Anyone used floobits yet? I just had one of my most WOW software experiences!
04:46:33 <Cale> I want to be able to position my cursor after the 'do' in a do-block and hit enter and tab and have the whole block move
04:47:11 <boothead> ocharles, you still here?
04:47:24 <mm_freak> Cale: i do that using rectangles…  it's pretty straightforward, at least in emacs
04:47:40 <Cale> mm_freak: But you have to select the block first
04:47:50 <mm_freak> you get used to that
04:47:53 <Cale> I also want to be able to add parameters to a function like:
04:48:02 <Cale> foo x y = do blah ...
04:48:11 <Cale> and have it keep track of where the block should be
04:48:14 <tdammers> having to select the block first is kind of the curse of braceless syntax
04:48:21 <tdammers> and tbh, the problem is much more annoying in Python
04:48:30 <mm_freak> Cale: i understand your request, but it's probably far from easy to implement
04:48:33 <Cale> tdammers: Basically, I want my editor to be aware of the layout rules in Haskell :)
04:48:52 <tdammers> Cale: not only the layout rules, but also your indentation preferences
04:48:52 <ocharles> boothead: aye
04:49:09 <Cale> It doesn't have to know about my indentation preferences
04:49:11 * hackagebot swish 0.9.0.7 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.7 (DouglasBurke)
04:49:11 <boothead> tdammers, can't you just use haskell-stylish?
04:49:33 <tdammers> boothead: idk, it's not really something that annoys me enough to find a better solution
04:49:38 <donri> Cale: there's a simple solution: always newline after a layout herald ;)
04:49:52 <Cale> donri: That's awful though, I don't want to have to do that.
04:49:53 <tdammers> donri: that's what I usually end up doing :x
04:50:16 <Cale> (Though it's what I end up doing a lot of the time)
04:50:16 <tdammers> of course the hanging do causes maintenance nuisances on its own
04:50:30 <donri> Cale: it makes for cleaner patches too though
04:50:39 <donri> which merge with fewer conflicts
04:50:39 <tdammers> it sits there orphaned at the end of the line, which is a particularly blind spot for most people
04:50:45 <jonkri> I've previously used <http://hackage.haskell.org/packages/archive/SMTPClient/1.0.4/doc/html/Network-SMTP-Simple.html> to send e-mail, but since I know want to do SMTP auth, I'm looking into alternative libraries. Any suggestions?
04:50:47 <boothead> ocharles, check this out: https://floobits.com/r/boothead/hs-tempo/#buf-src/Main.hs
04:51:41 <donri> tdammers: how is that a problem?
04:52:12 <tdammers> well, one sometimes forgets to add or remove the do
04:52:28 <tdammers> the compiler catches it, but the error message causes a short "what?"
04:52:32 <donri> tdammers: how is that a problem?
04:52:41 <donri> tdammers: don't remove the do?
04:52:46 <ocharles> boothead: I don't have permission to chat apparently
04:52:47 <donri> redundant do is the most useless "error" in hlint
04:52:51 <Cale> I'll often use a style like:
04:52:54 <Cale> foo x y z =
04:52:56 <Cale>   do ...
04:52:58 <tdammers> I was about to say that hlint complains
04:53:07 <donri> disable it in hlint then :)
04:53:11 <tdammers> nah
04:53:16 <tdammers> I actually like removing it
04:53:17 <Cale> and then have following lines start in column 5 of course :)
04:53:24 <tdammers> makes it easier to see possible refactorings
04:53:29 <tdammers> at least for me, for some reason
04:53:52 <tdammers> Cale: I usually do this:
04:53:55 <tdammers> foo x y z = do
04:53:57 <tdammers>     ...
04:54:03 <tdammers>     where
04:54:06 <ocharles> boothead: 'uuid' will have a _UUID prism soon hopefully, so you don't need fromJust . fromString :)
04:54:09 <tdammers>         a = whatever
04:54:22 <boothead> ocharles, that's a shame. I'v got code in emac updating in the web editor in real time...
04:54:57 <boothead> ocharles, I'm sure that will extremely usefull to me when I grow enough brain cells to figure out what a Prism is!
04:55:11 <Cale> tdammers: I'll always indent the 'where' less than the lines in the do-block, to emphasise that it's part of the declaration rather than part of the expression.
04:55:22 <Rc43> Hi, guys.
04:55:28 <ocharles> boothead: :)
04:55:33 <Cale> But yeah, I use that style sometimes too
04:55:44 <Cale> (but I don't like it much)
04:55:56 <ocharles> boothead: also, pretty sure traverseWithKey is in 'keys'
04:56:03 <Cale> I think it's much nicer to have layout keywords at the top left of each block they contain
04:56:06 <Rc43> I am trying to install profiling version of prelude, but have problems.
04:56:10 <Rc43>  I tried this:
04:56:11 <Rc43> > cabal install --reinstall -p base
04:56:12 <lambdabot>   Not in scope: `cabal'Not in scope: `install'
04:56:14 <Cale> In some kind of ideal visualisation of the code
04:56:20 <boothead> ocharles, oh and I can edit in the webpage and it changes in emacs too :-)
04:56:34 <Rc43> But it can't reinstall base.
04:56:46 <boothead> ocharles, keys ?
04:56:49 <Cale> Rc43: that comes with ghc
04:57:01 <Cale> Rc43: You're not meant to reinstall it without reinstalling GHC
04:57:15 <hpaste> merijn pasted “How to simplify?” at http://lpaste.net/92591
04:57:28 <tdammers> my main reason for this style is that the indentation matches the logical nesting level of the code
04:57:29 <merijn> Is there a way to cleanup overloading like that?
04:57:33 <Cale> If you don't have the profiling libraries for base, you probably installed GHC through your system package manager?
04:57:37 <tdammers> instead of following the size of what is basically random code
04:57:41 <Rc43> Cale, so I need new ghc with profiling inside?
04:57:48 <Cale> Debian likes to split GHC into millions of tiny fragments
04:58:03 <ocharles> @hackage keys
04:58:03 <lambdabot> http://hackage.haskell.org/package/keys
04:58:04 <Rc43> And why I can't compile my programm without profiling version of Prelude?
04:58:05 <ocharles> boothead ^
04:58:24 <Rc43> I needn't to profile Prelude, I need to profile my own code.
04:59:11 <Cale> Rc43: what distribution are you using?
04:59:21 <Cale> (or, how did you install GHC?)
04:59:33 <Rc43> Cale, ubuntu server, installed ghc with package.
04:59:36 <Cale> There's likely a package for the profiling libraries
04:59:50 <Cale> Look for libghc-*-prof
04:59:51 <donri> libghc-*-prof i think
04:59:54 <donri> :)
05:00:15 <merijn> Is the STM library not shipped with ghc?
05:00:37 <Cale> (But if it were me, I'd just get a binary package from http://www.haskell.org/ghc/download_ghc_7_6_3#binaries )
05:00:57 <Rc43> Cale, ye, I see now.
05:01:15 <Rc43> Cale, but why I can't build my app with profiling without profiling version of Prelude?
05:01:28 <Rc43> Cale, or my ghc itself can't profile?
05:01:48 <Rc43> Cale, and will package only install addition libraries or recompile old?
05:02:18 <Cale> Rc43: It's probably differences between the standard and profiling runtime which mean that all the code needs to be compiled for profiling.
05:02:28 <Cale> But I don't really know what those are.
05:03:10 <Rc43> Cale, ok, thanks for the information.
05:03:23 <boothead> ocharles --- o_0 i literally don't know what I'm looking at there :-)
05:03:48 <Cale> Rc43: It's a good idea to edit ~/.cabal/config and make sure it has  library-profiling: True  and  documentation: True
05:04:13 <Cale> Rc43: Otherwise, you end up with the annoyance of having to reinstall lots of packages later.
05:05:34 <ocharles> boothead: well, you wrote a 'traverseWithKey' function, which is already in that library :)
05:05:34 <ocharles> http://hackage.haskell.org/packages/archive/keys/3.0.3/doc/html/Data-Key.html#v:traverseWithKey
05:05:34 <ocharles> and does me changing the open file change it for you too? :P
05:05:43 <Rc43> Cale, if I set "True" will I have both versions or profiling only?
05:07:03 <klugez> Rc43: Both.
05:07:04 <Cale> Both
05:07:20 <Rc43> Nice.
05:07:24 <boothead> ocharles, correction I *stole* a traverseWithKey function from Aeson :-)
05:07:50 <boothead> ocharles, you shouldn't have edit permission i don't think
05:08:05 <Cale> But yeah, it would be interesting to know exactly why profiling code needs to be linked against profiling code.
05:08:55 <deech> Hi all, the recent Cabal broke my Setup.hs. Should I tune the Setup.hs to this version, revert it, or so do some CPP magic?
05:09:32 <Cale> deech: What stuff are you doing in Setup.hs? Most packages get by without customising that.
05:10:27 <deech> It's pretty much what's described here: http://stackoverflow.com/a/18580540/230813. Basically intercepting the linker phase to include some extra object files.
05:11:01 <deech> One record keys don't exist anymore. And to be fair the new Cabal makes the process easier.
05:11:03 <Cale> Interesting :)
05:11:53 <deech> Cale: The idea is that I have a C code that I intend to release as its own project but until then I want all the object files bundles with the Cabal library.
05:12:45 <deech> Cale: So what do you think? Make people upgrade or not? :)
05:13:42 <Cale> I dunno! It's probably worth seeing whether CPP flags set through the .cabal file will actually be applied to Setup.hs
05:14:31 <deech> Cale: Ah, thanks!
05:15:45 <Cale> (If not, I'd say just make people upgrade :)
05:16:36 <deech> Cale: Will do!
05:17:59 <danharaj> Hey Cale will you be awake in ~2-3 hours?
05:19:53 <shiona> Am I right to think that (Monoid b => a -> b) and function application is a monoid?
05:20:29 <shiona> I think I accidentally used something like that and I was totally blown away after I (thought that I might have) understood what just happened
05:21:25 <shiona> also would be nice if there was a way to find which things are of a given typeclass
05:22:03 <jmcarthur_mobile> Not function application, but you can make any instance of Applicative a Monoid in the same fashion as that specific case.
05:22:15 <jmcarthur_mobile> mempty = pure mempty
05:22:37 <jmcarthur_mobile> mappend = liftA2 mappend
05:23:03 <jmcarthur_mobile> In GHCi you can use :i to get information like that
05:23:34 <shiona> jmcarthur_mobile: oh, thanks :D
05:25:33 <shiona> and yeah, function application of course isn't quite the thing. I really don't have the word for what it is though
05:25:48 <ski> > sortBy (comparing length `mappend` compare) [words "The quick brown fox jumps over the lazy dog"]  -- shiona, the traditional example of this, sorting primarily by length, secondarily by ordinary lexicographic letter ordering (ASCII)
05:25:50 <lambdabot>   [["The","quick","brown","fox","jumps","over","the","lazy","dog"]]
05:25:51 <donri> shiona: "function"
05:26:07 <ski> see Cale's comment at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> for more info
05:26:21 <ski> er, goofed the example should be
05:26:22 <shiona> donri: yeah, functions is the set of the monoid, but what is the operation
05:26:30 <ski> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
05:26:32 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
05:26:35 <ski> there
05:26:37 <parcs> does this ever make sense? mkWeakIORef ref (readIORef ref >>= ...)
05:26:39 <donri> > (map toUpper <> reverse) "hello"
05:26:40 <lambdabot>   "HELLOolleh"
05:27:06 <shiona> but yeah, ski, that is pretty much what I did. I first thought I had used the Monoid of Ordering
05:27:18 <ski> yes, it boils down to that
05:27:33 <ski> from `Monoid (rho -> a)' to `Monoid a' a couple of steps first
05:27:42 <shiona> but then I understood that I actually did the thing whose name I don't know, call it just mappend, of (a -> Ordering)
05:27:57 <donri> you're using two monoids there
05:28:00 <mm_freak> "the dog fox the lazy"…
05:28:48 <shiona> donri: Other than Ordering and a function to that?
05:29:07 <donri> shiona: function and ordering, two monoids in concert
05:29:12 <shiona> yea
05:29:22 <Cale> and you're using the instance for functions twice
05:29:22 <shiona> absolutely beautiful
05:29:26 <Cale> So three monoids :)
05:29:40 <Cale> Ordering, a -> Ordering, and a -> a -> Ordering
05:29:52 <shiona> hmm
05:31:08 <merijn> Is darcs.haskell.org the only place where the stm package is hosted?
05:31:28 <Cale> merijn: It's on hackage, isn't it?
05:31:56 <merijn> Cale: I mean sources to patch
05:32:05 <merijn> I guess I can use cabal unpack
05:32:14 <donri> cabal get --source-repository :)
05:32:38 <donri> which won't work here, ah
05:32:39 <shiona> You've broken me. I'm sitting in class and all I can see is monoids on the whiteboard
05:32:53 <shiona> disjunctions, conjunctions, sums
05:32:54 * ski grins
05:33:25 * ski is idly wondering which class this might be
05:33:38 <shiona> "Mathematical logic"
05:33:40 <int-e> oh, lattices
05:33:46 <donri> "my god, it's full of monoids" i had fun rediscovering elementary algebra
05:34:27 <int-e> and if you stare at stuff long enough you might find a couple of Galois connections :)
05:35:05 <Philonous> Why can't I run cabal-dev and the new cabal sandboxes in parallel?
05:35:17 <fryguybob> merijn: There is also github.com/ghc/packages-stm
05:36:12 <ski> shiona : ok. i suppose propositional and predicate logic, interpretations and proofs (Hilbert-style and Natural Deduction). soundness and completeness. perhaps compactness. perhaps some other logics like (various) modal, intuitionistic
05:36:29 <shiona> ski: Hilbert just now
05:36:55 <shiona> or well, we moved to a slide called "Clausal form"
05:37:35 <shiona> this is actually rather hard, since we have been taught all this stuff way earlier, but with the idea "it's immediately visible from this"
05:37:37 <ski> shiona : my condolences
05:37:44 <ski> (for Hilbert)
05:37:50 <shiona> ski: why, I woundn't have to take this course
05:38:04 <shiona> I just came to see if I'm interested and it doesn't look too bad
05:38:19 <ski> Hilbert-style is painful to start with (and also to do later), imho
05:38:22 <shiona> although here I am in IRC, someone might argue I'm not too interested
05:38:52 <ski> Natural Deduction proofs are generally considered easier to actually *do* (and read)
05:39:08 <shiona> ski: I've been studying for years, I know my way around quite a few ways around logical deduction
05:39:37 <shiona> I might not ever understand why Hilbert would be useful to learn though
05:40:33 <ski> afaiui, people think Hilbert-style is sortof nice because when doing meta-theorems, you have only few inference rules to check, and then a bunch of axioms
05:40:46 <merijn> fryguybob: That seems to imply stm ships with ghc, but my ghc source doesn't have a directory for it?
05:41:12 <ski> shiona : if you already know ND, you should be fine, i think
05:41:15 <fryguybob> merijn: Under libraries/stm?
05:42:01 <ski> it's just that it seems people sometimes try some basic logic, but come away horrified after having only seen Hilbert-style proofs .. which is a shame
05:42:01 <merijn> fryguybob: That doesn't exist
05:42:11 <fryguybob> merijn: I guess not.
05:43:18 <shiona> I'm familiar with ND, but I still like to stick with the rather elementary style of using rules of implication, elimination and the likes
05:44:23 <shiona> de moore of course
05:46:38 <ski> (de Morgan ?)
05:46:39 <applicative> merijn: whats wrong with http://git.haskell.org/?p=packages/stm.git;a=summary
05:46:49 <ski> shiona : fair enough
05:46:58 <shiona> ski: yea, sorry. I can't think straight
05:47:11 <shiona> oh god now he's going back to truth tables
05:47:49 <ski> (and by "rules of implication, elimination" i assume you mean axioms like `A -> (B -> (A /\ B))' &c. as opposed to the ND intro. and elim. inference rules)
05:48:20 <shiona> a -> b <=> (!a v b)
05:48:30 <shiona> but now the class is over, time to move to the next one
05:48:52 <ski> ok, so more "algebraic style", perhaps
05:49:08 <ski> have fun
05:52:02 <shiona> ski: guess so
05:54:06 <merijn> Does anyone know whether there's better ways of doing this? http://lpaste.net/92591
05:59:15 <fryguybob> merijn: Is ZMPT1 a qualified module name and a data constructor?
06:03:28 <merijn> fryguybob: Yes
06:04:17 * hackagebot clash-lib 0.2 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.2 (ChristiaanBaaij)
06:04:56 <fryguybob> merijn: I don't see anything to simplify, the qualified name has nothing to do with the data constructor name.  You could make a type class that moves each line into an instance, but the code is the same, just distributed differently.
06:06:01 <fryguybob> merijn: I don't know if template haskell would let you "cast" the name of a data constructor to a qualified name, but that doesn't sound very sane to do anyway.
06:06:31 <fryguybob> merijn: I suppose there is always CPP...
06:06:33 <merijn> fryguybob: Sure, I'm just curious what the best way to distribute code like this where you have >2 implementations for the same thing is
06:06:49 <merijn> Clearly type classes don't help, as the type is the same in all cases
06:08:28 <fryguybob> merijn: Well the types could be different, or have a different parameter.
06:09:03 <merijn> fryguybob: No, because if I did that I would have no valid way to return things...
06:09:32 <fryguybob> merijn: I'm not sure what you mean.
06:10:09 <merijn> fryguybob: Which value's type would I change?
06:11:34 <fryguybob> merijn: I can't see enough of the code to tell, but I'm refering to the way that Diagrams, for instance, has multiple backends determined by the type.
06:12:42 <merijn> fryguybob: The problem is that I have a negotation that returns the type, so then I would have to modify the part that does negotiation to returns different types for every version, which would be mildly annoying
06:13:07 <merijn> Maybe I can get away with adding a field for getFrame/putFrame in the version type...
06:13:07 <fryguybob> merijn: Certainly such a change would be pervasive.
06:13:54 <mm_freak> can i list all infix 5 operators?
06:14:19 <mm_freak> (that are in scope)
06:22:49 <wojtekM_> Hello list! Is there an analogy for >>= operator, but where the rigtht hand takes two arguments?
06:23:38 <danr> @type liftM2
06:23:39 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:24:45 <wojtekM_> @type Text.Parsec.Combinator.count
06:24:46 <lambdabot> Text.Parsec.Prim.Stream s m t => Int -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
06:25:33 <wojtekM_> anyWord8 ??? Text.Parsec.Combinator.count
06:25:36 <merijn> quchen: Good news, I finally got around to isFullTBQueue, adding it to trac now
06:25:51 <quchen> merijn: Oh, I thought you did that a long time ago
06:25:55 <levi> merijn: You could maybe save a little bit of text via making the type part of the record and using field name punning.
06:26:00 <merijn> quchen: I was supposed to, but I forgot :p
06:26:00 <quchen> Or did you just not check @messages in forever? :-)
06:26:16 <merijn> quchen: I did, but then didn't get around to it immediately :p
06:26:38 <quchen> merijn: Semi-good news, I think everything is AMP-warning-patched, but I can't run the validation script because of overheating isses. Haha.
06:27:14 <quchen> @tell merijn Daily isFullTBQueue reminder.
06:27:14 <lambdabot> Consider it noted.
06:28:14 <quchen> main = forever $ sleep 86400 >> irc "@tell merijn Daily isFullTBQueue reminder."
06:28:15 <quchen> ;-)
06:28:53 <ski> wojtekM_ : you could always use `join' ..
06:29:20 <donri> wojtekM_: better explain what you're trying to do
06:30:07 <ski> @help messages
06:30:07 <lambdabot> messages. Check your messages, responding in private.
06:30:20 * ski wonders when the "responding in private" part got added
06:33:07 <quicksilver> recently
06:33:20 <quicksilver> since the elliott-coup
06:33:43 <merijn> quchen: http://ghc.haskell.org/trac/ghc/ticket/8232 \o/
06:35:21 <quchen> Beautiful.
06:38:56 <wojtekM_> I am writing a parser, and trying to reduce verbosity. This is what I have
06:39:13 <wojtekM_> fields :: Parser Fields
06:39:13 <wojtekM_> fields = do
06:39:13 <wojtekM_>    cnt <- anyWord16AsInt
06:39:13 <wojtekM_>    PC.count cnt fieldDesc
06:39:16 <wojtekM_>  
06:39:35 <wojtekM_> and I would like to have something like:
06:39:39 <wojtekM_> fieldsNew = anyWord16AsInt >>= PC.count $ fieldDesc
06:41:14 <quchen> merijn: Although, http://lpaste.net/92597
06:41:17 <quicksilver> fieldsNew = anyWord16asInt >>= (\c -> PC.count c fieldDesc)
06:41:24 <quicksilver> is probably what I would write
06:41:42 <quicksilver> although, andWords16asInt >>= flip PC.count fieldDesc
06:41:43 <quicksilver> is possible
06:41:58 <merijn> quchen: That requires adding extra imports to the module
06:42:18 <quicksilver> wojtekM_: PS, don't paste code in channel :)
06:42:22 <merijn> quchen: I try and stick as close as possible to existing module style
06:42:33 <quchen> Here you go ;-) http://lpaste.net/92599
06:42:34 <donri> wojtekM_: count <$> anyWord16AsInt <*> pure fieldDesc
06:42:50 <quchen> Woops typo. Anyway, just bikeshedding here
06:43:14 <quchen> (I'm still surprised that function isn't in the API yet.)
06:43:22 <wojtekM_> PC.Count is Text.Parsec.Combinator.count, fieldDesc parses field desc, anyWord16AsInt nomen omen
06:44:09 <quicksilver> donri: don't think so, 'PC.count' is a parser not a plain function.
06:45:14 <donri> ah, of course
06:46:53 <Umbrall> Hm, so I was making a composable monad thing, and I had an operation :: Applicative f => f (m a) -> (f a -> f (m b)) -> f (m b)
06:47:05 <donri> count =<< anyWord <*> pure fieldDesc  -- ehhh
06:47:10 <Ghoul_> I would really like a concatMaybe or something like that
06:47:25 <Ghoul_> [a] -> Maybe a -> [a]
06:47:44 <notdan> Ghoul_: what would it do?
06:47:46 <Umbrall> but the implementation I had had used <*>
06:47:47 <Ghoul_> I always have to hack around it with list comprehensions [fromJust x | isJust x] : ...
06:47:55 <donri> :t F.fold `asAppliedTo` [Just 2]
06:47:56 <lambdabot> (Num a, Monoid a) => [Maybe a] -> Maybe a
06:48:00 <Umbrall> which can sometimes cause errors, e.g. lists concatenating twice
06:48:09 <Umbrall> but I can't find a way to do it without this
06:48:24 <Ghoul_> Uh, its for when you have a thing that produces some extra fields for a list only sometimes
06:48:26 <Umbrall> er, by lists I mean writers
06:48:39 <Ghoul_> Hmm yes, writer is actually a good way about that now you mention it
06:48:49 <Ghoul_> but its probably a little too verbose to run a writer for light usage
06:48:51 <Umbrall> of course that had nothing to do with what you were saying
06:48:59 <Umbrall> and I was talking about something completely different
06:49:04 <Ghoul_> lol
06:49:38 <donri> :t maybeToList
06:49:39 <lambdabot> Maybe a -> [a]
06:50:03 <wojtekM_> Excellent, thank you.
06:50:09 <donri> :t F.toList `asAppliedTo` Nothing
06:50:10 <lambdabot> Maybe a -> [a]
06:50:23 <notdan> :t asAppliedTo
06:50:26 <lambdabot> (a -> b) -> a -> a -> b
06:50:34 <donri> Ghoul_: Foldable or Data.Maybe has your back
06:50:42 <wojtekM_> I guess it is a matter of taste, which one to use, lambda or flip?
06:50:52 <merijn> notdan: "asAppliedTo" == const with a funny type signature
06:51:08 <wojtekM_> I do not have taste for haskell code, yet...
06:51:48 <Ghoul_> > F.toList `asAppliedTo` (Just 4) : [1..3]
06:51:50 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
06:51:50 <lambdabot>    arising from a use ...
06:52:12 <donri> > [1..3] ++ F.toList (Just 4)
06:52:13 <lambdabot>   [1,2,3,4]
06:52:23 <merijn> Ghoul_: That doesn't work because it doesn't know which type you meant with the numeric literals
06:53:20 <Ghoul_> > [1..3] ++ F.toList Nothing
06:53:21 <lambdabot>   [1,2,3]
06:53:26 <Ghoul_> cool
06:57:56 <Ghoul_> Had no idea Data.Foldable is part of base
06:58:00 <Ghoul_> It's pretty dcool
06:58:05 <Ghoul_> *cool
06:58:12 <donri> > F.fold $ (Just <$> [1..3]) ++ [Just 4]
06:58:13 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
06:58:13 <lambdabot>    arising from a use of `e_1134'
06:58:13 <lambdabot>  ...
06:58:16 <donri> :(
06:58:33 <donri> > F.fold $ (Just <$> [1..3]) ++ [Just 4] :: [Int]
06:58:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
06:58:35 <lambdabot>              with actual typ...
06:59:06 <donri> > F.fold ((Just <$> [1..3]) ++ [Just 4]) :: [Int]
06:59:07 <lambdabot>   Couldn't match type `Data.Maybe.Maybe a0' with `[GHC.Types.Int]'
06:59:07 <lambdabot>  Expected ...
06:59:29 * hackagebot graphs 0.5 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.5 (EdwardKmett)
06:59:32 <donri> oh yeah
07:01:19 <Umbrall> Does someone know where the source code for WriterT is?
07:01:47 <donri> @hackage transformers
07:01:47 <lambdabot> http://hackage.haskell.org/package/transformers
07:03:47 <donri> > F.fold (Just [1..3] <> Just [4]) :: [Int]
07:03:49 <lambdabot>   [1,2,3,4]
07:04:01 <quicksilver> Ghoul_: catMaybes?
07:04:20 <quicksilver> Ghoul_: (and maybeToList as someone showed)
07:04:54 <robindv> hi
07:06:42 <robindv> I've a compile error as beginning haskell-programer, is somebody willing to help me?
07:07:03 <quicksilver> robindv: definitely, that's what we're here for. Trying pasting the code and the error to lpaste.net
07:07:07 <donri> @lpaste the code and error, robindv
07:07:07 <lambdabot> Haskell pastebin: http://lpaste.net/
07:09:12 <robindv> quicksilver: http://lpaste.net/4967827962196918272
07:10:03 <quicksilver> robindv: you can only compare items for equality if they are the same type
07:10:18 <quicksilver> robindv: your type signature gives 'e' and 'i' different types
07:10:50 <robindv> quicksilver, aha, sounds very logic; Thanks :)
07:10:53 <quicksilver> it's probaly confusing to use the same letter for the types as the variables, I'd write the type signature as "has_element: Eq a => a -> a -> Bool -> Bool
07:11:34 <quicksilver> (in fact in this case you *could* have left the type signature out - it would have been inferred. But possibly your teacher is asking you to write signatures, which is a good idea anyway)
07:13:08 <robindv> Its working, ty :)
07:14:47 <merijn> Yay! Another import cycle >.<
07:15:11 <quicksilver> #include <rants/cyclic_dependencies>
07:15:22 <danilo2> Is it possible to force haskell to "show" qualified data constructors?
07:15:30 <quicksilver> no, danilo2
07:15:34 <Umbrall> So looking at WriterT I have an implementation that works
07:15:37 <quicksilver> 'show' is a pretty simplistic function
07:15:42 <Umbrall> but I don't know why it's different than the other implementation
07:15:47 <Umbrall> which should be identical
07:15:53 <quicksilver> and types can't "know" how they might be qualified in various different settings
07:15:57 <quicksilver> it would be
07:16:00 <Iceland_jack> danilo2: I'm assuming you're not talking for actual programming but rather for interactive use in GHCi?
07:16:01 <donri> danilo2: :[s]print in ghci if that's where you wanted it
07:16:05 <quicksilver> nice to have a better solution - maybe one of the pretty printers?
07:16:08 <danilo2> quicksilver: I was supposing so.
07:16:35 <merijn> Umbrall: Pastebin both next to eachother?
07:16:36 <Iceland_jack> You can always get the module using :info
07:16:39 <Iceland_jack> Prelude> :i nub
07:16:39 <Iceland_jack> nub :: Eq a => [a] -> [a]       -- Defined in `Data.List'
07:16:46 <Umbrall> I think I know what works but I don't know why I had to do something
07:17:12 <donri> danilo2: (and :force)
07:17:43 <danilo2> donri, quicksilver: I was needing something else - namely - I'm creating unit tests to a compiler and I print the AST structure, but the AST consist of Expr and Types - both sometimes have the same names, so it is hard to write tests to check if AST is good. Of course I can write custom show or check by strings the values, but I was wondering if there is something built in
07:18:14 <quicksilver> I would not write unit tests which depend on show, danilo2
07:18:21 <Eduard_Munteanu> Can I do / how do I do something like   data Foo :: (n :: Nat) -> Vec n * -> * where ...   with DataKinds?
07:18:26 <quicksilver> I'd have unit tests compare the AST structures directly
07:18:31 <quicksilver> personally
07:18:33 <Umbrall> http://lpaste.net/5982099216590176256
07:18:44 <Eduard_Munteanu> Or is that too dependently-typed?
07:19:03 <Umbrall> the former seems like code you're supposed to just use applicative for not monad
07:19:30 <quicksilver> Umbrall: the second action calls 'm' twice
07:19:38 <quicksilver> Umbrall: the first action only calls it once
07:19:43 <Eduard_Munteanu> I mean the part where you name a parameter and make a subsequent one dependent on it.
07:19:53 <danilo2> quicksilver: exactly! but imagine, that you are testing if parse("a") == Identifier "a". If test fails it prints: I was expecting [] but got Identifier "a", so I can simply copy and paste the expected string as AN EXPRESSION (not string) - but the problem is - it uses not qualified names.
07:19:55 <Iceland_jack> (what is the status of type-level literals and arithmetic in the latest GHC btw?)
07:20:04 <danilo2> quicksilver: I hope, now it is clear :)
07:20:12 <quicksilver> danilo2: oh, heh, nasty
07:20:57 <merijn> Umbrall: What's "f $ return a" supposed to do?
07:21:14 <merijn> Umbrall: You don't have type signatures, but if I remember the types right that should be a type error
07:21:38 <danilo2> Is it possible (maybe using TemplateHaskell) to get the current module name as String? (I was asking about it some time ago, but without the answer :( )
07:21:50 <Eduard_Munteanu> danilo2: yes
07:21:57 <donri> danilo2: nameBase
07:23:45 <donri> danilo2: perhaps modify this to include qualification https://github.com/dreixel/generic-deriving/blob/master/src/Generics/Deriving/Show.hs
07:24:39 <danilo2> donri: This is the default show implementation?
07:24:53 <donri> danilo2: no it's a version using Generic
07:25:36 <donri> danilo2: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Generics.html#g:3
07:26:42 <danilo2> donri: Thank you! I dont know genereics so I think right now I'll stay with simple string show, but in a week or two, when I'll have more time (deadlines ... :( ) I'll do it the proper way :)
07:26:52 <Eduard_Munteanu> Hm, the ghc guide says only * -> * -> ... -> * kinds are promoted and there's only BOX, not BOX -> BOX etc.
07:28:53 <quicksilver> donri: I don't thnk you can
07:28:59 <quicksilver> donri: Generics doesn't know how you're qualified
07:29:09 <quicksilver> does it?
07:29:26 <Umbrall> oh sorry @merijin
07:29:28 <donri> >>> moduleName $ from $ Just 2
07:29:28 <donri> "Data.Maybe"
07:29:33 <Umbrall> I only have f $ return a because otherwise it doesn't typecheck
07:29:40 <quicksilver> donri: oh, neat
07:29:40 <Umbrall> sorry I'll add the types
07:29:44 <donri> quicksilver: i thought danilo2 just wanted the module
07:29:49 <wojtekM_> @source Control.Applicative.(<|>)
07:29:49 <lambdabot> Unknown command, try @list
07:29:51 <quicksilver> donri: I think he does, really
07:29:55 <donri> danilo2: did you want the "import *as*"?
07:30:00 <quicksilver> donri: slightly muddled wires on my part
07:30:07 <Umbrall> but right now it should be m (n a) -> (m a -> m (n b)) -> m (n b) where n b here == (s, b)
07:30:13 <quicksilver> module name would be fine to disambiguate which is all he needs
07:30:49 <Umbrall> Edited it: http://lpaste.net/5982099216590176256
07:30:59 <danilo2> donri: Ekhm .. I was not talking about imports - I simply wanted to create custom Show, which will add module name before function or data constructor.
07:31:13 <donri> danilo2: yeah, then TH and Generic can do it just fine
07:31:52 <danilo2> donri: Yeah, but it is not straightforward I think. I'll have to dig into current implementations etc ... and I will do it, but in few weeks, after a deadline :)
07:31:59 <danilo2> donri: Thank you :)
07:33:59 <donri> danilo2: i think you could get far by copying the code i linked and just prepend a call to moduleName ++ "." anywhere "conName" is used (plus add the Datatype constraint)
07:34:36 <donri> but i'm not 100% sure that'll work
07:34:43 <donri> but it'd be a start ;)
07:40:53 <donri> yeah you'll need to do it in the M1 D instance, rather, and move the M1 C code out from the instance so you can pass along the datatype metadata
07:43:03 <danilo2> donri: Ok thank you :) I'll test it :)
07:43:10 <mm_freak> ocharles: http://lpaste.net/92604
07:43:12 <mm_freak> lovely? =)
07:43:41 <danilo2> donri: btw. How this code works? how can I use it?
07:44:51 <donri> danilo2: you use DeriveGeneric with deriving (Generic) and then you have a generic representation of the algebraic structure of your type which you can then work with generically. GENERICS!
07:45:10 <mm_freak> that's FRP dynamic switching on steroids =)
07:45:12 <ocharles> mm_freak: that monoid instance is pretty neat!
07:45:37 <Eduard_Munteanu> Let there be DataKinds,  data Foo = F1 | F2 | F3   and   data IndexedByFoo :: Foo -> * where MkIndexed :: Foo -> IndexedByFoo ?   -- what's the proper way to refer to the Foo and replace the '?'?
07:45:45 <ocharles> mm_freak: what's 'modes'?
07:46:19 <ocharles> mm_freak: that's the switch, right?
07:46:24 <ocharles> what's its type?
07:46:59 <mm_freak> ocharles: refresh
07:47:13 <danilo2> donri: Thanks :D Generally telling I dont understand simply how to use It, but this is because I completly do not know the Generics :)
07:47:47 <ocharles> mm_freak: ta
07:48:48 <mm_freak> it's more a router than a switch
07:48:52 <ocharles> i wonder how this looks in netwire 4
07:48:54 <ocharles> yea
07:49:04 <donri> danilo2: you can represent any algebraic type with just Void, (), (,) and Either. that's basically what Generic does
07:49:07 <mm_freak> there is the 'context' wire in 4, but it's less powerful
07:49:07 <ocharles> switch implies a change in state, but this appears stateless
07:49:13 <ocharles> i never figured out context
07:50:21 <mm_freak> it's basically 'modes', but it selects the mode based on the input signal and at every instant…  this makes it only useful in few scenarios
07:50:23 <ocharles> i guess in netwire 4 i'd have some sort of forever loop and use "andThen"
07:50:25 <donri> danilo2: Void is zero, () is one, (,) is * and Either is +. algebra!
07:50:31 <ocharles> but this is remarkably elegant
07:50:45 <ocharles> donri: don't forget a -> n being exponentiation
07:50:52 <danilo2> donri: Ok, thats vey interesting :) I'm going to read about the generics right now :)
07:51:11 <donri> ocharles: does Generic encode that? (could it?)
07:51:12 <mm_freak> yeah, i thought that a modal application like a game with a menu or a GUI with modal sub-GUIs could benefit from this
07:51:29 <ocharles> mm_freak: mergeL is <& ?
07:51:51 <mm_freak> (<&) is liftA2 mergeL
07:52:00 <ocharles> donri: ah Generic. I was just going along with the whole type algebra stuff :)
07:52:01 <ski> donri : .. and `[a]' is `1 / (1 - a)'
07:52:08 <ocharles> mm_freak: ah ok
07:52:16 <ocharles> oh, i see you're using it with at
07:52:20 <ocharles> i missed that
07:52:21 <donri> danilo2: so for example, type Bool = Either () (), type Maybe a = Either () a, etc
07:52:47 <donri> danilo2: so with Generic, we only need to know about these primitives and we can work with any algebraic type (that derives Generic, which ghc can do for you)
07:52:49 <ocharles> mm_freak: presumably at 3 &> at 5 &> at 10 is the same?
07:53:14 <mm_freak> in this case yes, because the event value is the same at every occurrence
07:53:30 <ocharles> same at every occurence?
07:53:56 <mm_freak> ev1 <- at 3 <& at 5 <& at 10 -< InGame
07:54:04 <mm_freak> it's always InGame
07:54:06 <danilo2> donri: Ok I got it :) Do you know any papers you can recommend, I can read to fully understand generics? I do not have strong background in the algebraic types theory.
07:54:17 <ocharles> is 'at 1 &> at 3 &> at 2' is 'at 1 <& at 3 <& at 2' ?
07:54:17 <mm_freak> so it doesn't matter whether we left-merge or right-merge
07:54:25 <mm_freak> not in general
07:54:33 <ocharles> not in general, but for these at's it is
07:54:43 <donri> danilo2: the paper would be http://dreixel.net/research/pdf/gdmh.pdf
07:54:47 <mm_freak> for these because of the 'pure InGame'
07:55:08 <mm_freak> counterexample:  at 2 . "blah" <& at 3 . "blubb"
07:55:18 <mm_freak> when they occur simultaneously, "blah" will be chosen
07:55:25 <donri> danilo2: more approachable possibly http://www.haskell.org/haskellwiki/GHC.Generics
07:55:39 <ocharles> how can they occur simultaneously? doesn't at 2 occur for a single instant?
07:55:59 <mm_freak> well, the framerate might drop to one frame per minute =)
07:56:04 <ocharles> ah, heh
07:56:12 <ocharles> gotcha
07:56:19 <danilo2> donri: Thank you very very much! :)
07:57:52 <ocharles> mm_freak: so if at 2 and at 3 do occur at the same time, if you use <&, the value coming out of at 2 is used, right?
07:57:56 <ocharles> is there a way to take both?
07:58:08 <ocharles> is that what <|> is for?
07:58:08 <mm_freak> right
07:58:16 <mm_freak> and yes:  at 2 <> at 3
07:58:27 <mm_freak> then the event value has to be in a Semigroup
07:58:28 <ocharles> which semigroup is used there?
07:58:30 <ocharles> got it
07:58:47 <ocharles> so what is the event under 'at' - entirely polymorphic?
07:58:50 <mm_freak> instance (Semigroup a) => Monoid (Event a)
07:59:11 <mm_freak> yes, entirely polymorphic
07:59:23 <mm_freak> at :: (HasTime t s) => t -> Wire s e m a (Event a)
07:59:28 <ocharles> ok
07:59:49 <ocharles> so i could (Sum 1 <$> at 2) <|> (Sum 2 <$> at 3)?
08:00:02 <ocharles> urgh
08:00:04 <ocharles> erm*
08:00:12 <ocharles> maybe that is (Sum 1 <$) <$> at 2
08:00:15 <mm_freak> note, (<|>) has a completely different meaning
08:00:29 <ocharles> <|> isn't like <> ?
08:00:52 <mm_freak> nope, (<|>) selects based on inhibition
08:00:53 <ocharles> i expected an Event that has all events folded under a semigroup
08:00:57 <mm_freak> use (<>) to merge events
08:01:04 <ocharles> ah, ok
08:01:22 <ocharles> and that works because Monoid b => Monoid (Wire e m a b)
08:01:25 <ocharles> or whatever Wire is now
08:01:29 <mm_freak> here you can use (<|>):  "blah" . for 3 <|> "blubb" . after 3
08:01:43 <mm_freak> or rather just:  "blah" . for 3 <|> "blubb"
08:01:54 <mm_freak> and yeah, exactly
08:02:03 <ocharles> all making sense!
08:02:11 <mm_freak> there is one additional type parameter now:  s
08:02:17 <mm_freak> "emab" → "semab" =)
08:02:17 <ocharles> oh yes
08:02:23 <quicksilver> preflex: seen ManateeLazyCat
08:02:24 <preflex>  ManateeLazyCat was last seen on #haskell 4 days, 5 hours, 6 minutes and 13 seconds ago, saying: Hello, have anyone know a library get bash completions list with feed string?
08:02:40 <mm_freak> (sounds much nicer than "stab" =P)
08:02:43 <ocharles> what's the intention there? I'm usually just going to be using my system clock as my session
08:02:54 <ocharles> that's what s is for, right?
08:03:09 <applicative> quicksilver: oh ManateeLazyCat has been around?
08:03:23 <mm_freak> s is mainly for time, but you can distribute other accumulating state deltas across the network
08:03:34 <quicksilver> applicative: apparently so; I didn't realise until I asked.
08:03:51 <mm_freak> the difference between the 's' and a reader monad is that 's' must be a monoid and accumulation (when a wire inhibits) is automatic
08:04:27 <hari_> Can anybody suggest a data serialization library or method in Haskell?
08:04:27 <quicksilver> applicative: I just stumbled across a piece of elisp written by him and wondered where he had got to. Dramatic trajectory of "emacs enthusiast -> emacs guru -> haskell enthusiast -> massively productive haskell coder -> *gone*"
08:04:42 <quicksilver> hari_: there are loads.
08:04:46 <applicative> quicksilver: looks like he's still making his amazing use of google translate.
08:05:17 <quicksilver> hari_: cereal, acid-state, binary,
08:05:28 <donri> hari_: probably binary, maybe cereal, probably not bytes, possibly safecopy
08:05:37 <applicative> quicksilver: yes, i'm not sure what he was up to when he was doing all that haskell; but then came the children...
08:05:45 <haasn> quicksilver: does acid-state have its own serialization? I thought it uses binary or something
08:05:51 <hari_> quicksilver, donri thanks.
08:05:54 <quicksilver> acid-state uses safecopy
08:05:56 <quicksilver> (I think)
08:05:57 <donri> haasn: safecopy, which uses cereal
08:06:07 <donri> haasn: but the plan is to move both to binary
08:06:12 <haasn> ah, right
08:06:24 <quicksilver> donri: why?
08:06:29 <quicksilver> applicative: ah, children :-(
08:06:39 <haasn> it uses cereal's Get but has its own instances. I see now
08:06:45 <mm_freak> ocharles: one nontrivial example of using 's': random number generation…  i don't want to put a state monad below the wire just to generate noise
08:06:53 <donri> quicksilver: performance reasons mostly, as i understood it
08:07:45 <donri> quicksilver: and standardizing, i think the plan is to get binary into platform
08:07:56 <donri> and to port binary to bytestring's builder
08:07:59 <ocharles> mm_freak: so what would you use as S there?
08:08:19 <ocharles> mm_freak: a RandomGen, or does it need more than that?
08:09:17 <mm_freak> ocharles: did you check out Session?
08:09:19 <Eduard_Munteanu> Whoa, cool, this works: class IsFoo (f :: Foo) where; instance IsFoo F1 where; ...  data IxByFoo :: Foo -> ... where Con :: IsFoo f => IxByFoo f ...
08:09:29 <enthropy> if I have a separate thread which communicates by ((Chan InData1, Chan InData2, ... ), Chan OutData), where that thread has a function like    f :: InData1 -> InData2 -> OutData, is there a sensible way to associate the OutData with the InData?
08:10:02 <ocharles> mm_freak: not really
08:10:03 <enthropy> if there was just one InData, the communication could be through something like      (Chan (InData1, OutData -> IO ()))
08:10:04 <ocharles> mm_freak: let me have a look
08:10:09 <mm_freak> ocharles: you would have something like s = Random StdGen (Timed NominalDiffTime ())
08:10:17 <Eduard_Munteanu> I wish I could just define Foo.
08:10:20 <enthropy> where the callback there writes an MVar
08:11:04 <mm_freak> ocharles: and you would have something like this:  prngSession :: (RandomGen g) => g -> Session m (s -> Random g s)
08:11:15 <enthropy> hmm, I guess all the input chans need their own callback
08:11:40 <mm_freak> ocharles: then finally instead of just 'clockSession_' (which is 'clockSession <*> pure ()') you would have:  prngSession (mkStdGen 0) <*> clockSession_
08:11:45 <ocharles> mm_freak: ah, now that I'm looking at this it makes a bit more sense
08:12:04 <ocharles> oh, that use of <*> is pretty neat
08:12:25 <ocharles> that Applicative Session instance hadn't really seemed very interesting, but now it does :)
08:12:28 <mm_freak> yeah, Session m is just an Applicative =)
08:13:15 <mm_freak> and if you're used to wires, Session is very easy to understand…  it's just a mini-wire for state deltas =)
08:13:33 <ocharles> yea, i saw that :)
08:13:39 <ocharles> i was like "hey, I recognise this pattern..."
08:13:47 <mm_freak> hehe
08:14:26 <quicksilver> donri: cool.
08:14:37 <quicksilver> donri: make binary better and then standardise on binary sounds good to me :)
08:15:21 <merijn> donri: Doesn't cereal claim to perform relatively similar to binary?
08:15:42 <visionincison> Hi all, does anybody here use Haskell for Machine Learning?
08:15:47 <merijn> Also, binary defaults to lazy BS, which is really sucky
08:16:19 <mm_freak> visionincison: i've done a few neural network and markov chain experiments
08:16:51 <visionincison> mm_freak: Ah ok cool, with or without librarys
08:16:59 <mm_freak> both
08:17:13 <visionincison> mm_freak: ahh ok cool
08:17:44 <visionincison> Would you say that doing a neural net in Haskell would be hard for somebody who is new to the language?
08:17:53 <visionincison> given that the best way to learn it is to use it
08:18:21 <mm_freak> visionincison: well, it's not as straightforward as your average list function experiment =)
08:18:33 <mm_freak> visionincison: it really depends…  neural networks can be a wonderful exercise in exploiting laziness
08:19:15 <mm_freak> feed-forward networks in particular can be expressed completely declaratively, including calculating activations and backpropagation learning
08:19:29 <visionincison> Yeah, I suspected as much. I guess the best thing for me to do is to jump in and have a go
08:19:37 <mm_freak> i agree
08:19:38 <visionincison> Yeah, I'd start with a BAckpropn MLP
08:19:39 <hari_> I can define a data type deriving "Show"
08:19:42 <visionincison> Backprop*
08:20:02 <mm_freak> visionincison: if you get stuck, you can see how i did it…  my ANN code is on hackage
08:20:05 <mm_freak> @where instinct
08:20:05 <lambdabot> I know nothing about instinct.
08:20:11 <mm_freak> @hackage instinct
08:20:11 <lambdabot> http://hackage.haskell.org/package/instinct
08:20:19 <mm_freak> it's a bit dated, but should still work
08:20:32 <hari_> How do I construct back the data from the string representation?
08:20:40 <danilo2> Maybe this is wrong place to ask, but your always so helpful that maybe somebody will have an idea - the question is - how would you name a function , which takes an AST and "dealias" the variables (so it converts expression like x=x+1 to b=a+1) - it produces SSA (Static Single Assignment)?
08:20:57 <mm_freak> hari_: if you're sure the string is valid, you can use 'read'
08:21:05 <mm_freak> > read "123" :: Integer
08:21:08 <lambdabot>   123
08:21:09 <visionincison> Ah ok, I may have a play with this first then
08:21:13 <visionincison> Always good to learn :)
08:21:20 <mm_freak> visionincison: i suggest trying on your own
08:21:27 <hari_> mm_freak, could it be done on user defined data?
08:21:38 <hari_> > data Foo = Foo String String
08:21:39 <lambdabot>   <hint>:1:1: parse error on input `data'
08:21:41 <mm_freak> visionincison: start with a data type, then continue to generate a layered network
08:21:54 <visionincison> ah i see
08:21:55 <merijn> hari_: Yes, if you derive or define a Read instance
08:22:11 <visionincison> Thanks :)
08:22:13 <mm_freak> visionincison: you can start with lists at first, but they are quite unfortunate
08:22:18 <hari_> merijn, thanks.
08:22:22 <mm_freak> visionincison: in the end you will want to use vectors
08:22:26 <merijn> "data Foo = Foo String String deriving (Show,Read)"
08:22:38 <visionincison> mm_freak: how so?
08:22:44 <mm_freak> visionincison: or Map if performance is not a concern
08:22:45 <merijn> hari_: now you can use "show" to turn it into a string and "read" for the reverse
08:22:56 <mm_freak> visionincison: neural network operations require a lot of random indexing
08:23:04 <merijn> hari_: Although those a probably not how you wanna do real serialisation
08:23:11 <Eduard_Munteanu> Yay, I figured it out!
08:23:23 <mm_freak> visionincison: list indexing is O(n) and doesn't provide a very nice interface for vector-like operations, which you need for ANNs
08:23:30 <Eduard_Munteanu> class IsFoo (f :: Foo) where; instance IsFoo f where;
08:23:38 <hari_> merijn, what is the disadvantage of this?
08:23:51 <Eduard_Munteanu> Is there a more straightforward way though?
08:24:01 <mm_freak> visionincison: however, it's fine if your first ANN is a list of lists =)
08:24:07 <hari_> I agree it is probably wasteful and slow .
08:24:23 <hari_> Binary serialization might be more efficient and fast on large data structures.
08:24:30 <merijn> hari_: read normally doesn't do error checking
08:24:30 * hackagebot hatex-guide 1.1.0.0 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.1.0.0 (DanielDiaz)
08:24:37 <mm_freak> Eduard_Munteanu: apparently you're already using DataKinds
08:24:41 <visionincison> Ok, for getting my feet wet, I'll use lists, then build a refined version with vectors
08:24:44 <merijn> hari_: And can't do things like streaming construction
08:25:03 <mm_freak> Eduard_Munteanu: just require (a :: Foo) instead of (IsFoo a) => a
08:25:08 <hari_> merijn, I agree. I will look at cereal
08:25:28 <Eduard_Munteanu> Hm, I thought that didn't work, lemme try again.
08:25:47 <mm_freak> Eduard_Munteanu: it works for data type definitions and for 'forall'
08:25:51 <merijn> Eduard_Munteanu: why use IsFoo over "(a ~ Foo) => a"?
08:25:53 <mm_freak> forall (a :: Foo). …
08:26:00 <merijn> oh
08:26:05 <merijn> KindSignatures, my bad
08:26:07 <hari_> > data Foo = Foo String String
08:26:08 <lambdabot>   <hint>:1:1: parse error on input `data'
08:26:18 <merijn> hari_: lambdabot doesn't do data types
08:26:26 <hari_> merijn, OK
08:26:37 <merijn> Eduard_Munteanu: You can just enable KindSignatures and add kind annotations to types
08:27:08 <merijn> Eduard_Munteanu: Do you have some sample code?
08:27:11 <Eduard_Munteanu> Hm, can't get it working. Let me paste my actual code.
08:27:17 <Eduard_Munteanu> One sec.
08:27:25 <hari_> when I use "read (show (Foo "hello" "world"))" I get an error like     No instance for (Read a0) arising from a use of `read'
08:27:29 <hari_> ...
08:27:51 <monochrom> because it doesn't know that you want to read back a Foo
08:27:57 <hari_> I define data Foo = Foo String String deriving (Read, Show)
08:28:09 <merijn> > read "123"
08:28:11 <lambdabot>   *Exception: Prelude.read: no parse
08:28:14 <merijn> > read "123" :: Int
08:28:16 <lambdabot>   123
08:28:17 <geekosaur> hari_, given the show, all it knows is there's a String. (it "hides" that there's a Foo behind it)
08:28:33 <merijn> :t read
08:28:35 <lambdabot> Read a => String -> a
08:28:43 <merijn> hari_: You need to tell GHC what type read should be creating
08:28:50 <hari_> OK got it now
08:28:57 <hari_> It works :)
08:29:10 <hari_> read (show (Foo "hello" "world")) :: Foo
08:29:31 <wojtekM_> http://lpaste.net/92606 How do I convert this to applicative style? Please note the order of elements.
08:30:16 <hari_> merijn, thanks
08:30:37 <Eduard_Munteanu> merijn, mm_freak: http://lpaste.net/92607
08:30:38 <hari_> geekosaur, yes, I realized that now
08:30:47 <Eduard_Munteanu> This works as it is but what if I need to do something with the 'r'?
08:31:20 <Eduard_Munteanu> I was also planning on   Type :: r -> Record r (Succ Zero) '[]
08:31:25 <merijn> Eduard_Munteanu: What do you mean "do something with r"?
08:31:35 <Eduard_Munteanu> But I don't know how to lift the value of that 'r' to a type.
08:31:47 <merijn> Eduard_Munteanu: Manually
08:31:57 <merijn> Maybe the singletons library will help
08:32:11 <merijn> Eduard_Munteanu: Actualy, no
08:32:13 <Eduard_Munteanu> Well, I can do  TypePubR :: Record PubR ...  but that's annoying.
08:32:14 <ski>   (,,) <$> primTypecode <*> pure 0 <*> fieldName  -- i suppose
08:32:16 <merijn> Eduard_Munteanu: What you're asking makes no sense
08:32:34 <ski>   ((,,) `flip` 0) <$> primTypecode <*> fieldName  -- or perhaps
08:32:51 <merijn> Eduard_Munteanu: "Type :: r -> Record r (Succ Zero) '[]" <- here r is either "PubR" or "FprR"
08:32:53 <Eduard_Munteanu> merijn: why? Example expression  foo :: Record PubR ...  ; foo = Type PubR
08:33:01 <ski> wojtekM_ ^
08:33:12 <merijn> Eduard_Munteanu: The PubR and FprR types have no inhabitants, so "r -> Record r" is silly
08:33:17 <Eduard_Munteanu> merijn: err, r :: RecordId.
08:33:22 <merijn> Eduard_Munteanu: No
08:33:28 <merijn> Eduard_Munteanu: Well, yes
08:33:40 <merijn> Eduard_Munteanu: The *kind* of *type* r is RecordId
08:33:44 <Cale> wojtekM_: (\pt fn -> (fn, 0, pt)) <$> primTypecode <*> fieldName
08:33:55 <merijn> i.e. the PubR and FprR are types, but these types have no inhabitants
08:33:57 <Eduard_Munteanu> Yeah, I know. It's so much easier in Agda. :D
08:34:14 <monochrom> hari_: see also my http://www.vex.net/~trebla/haskell/reads.xhtml for how to read better
08:34:38 <merijn> Eduard_Munteanu: But since 'r' has no inhabitants the type of "Type" makes no sense, you could never construct a value using Type
08:34:57 <donri> merijn: i think that might've been true before but that binary has seen a lot of performance work in recent releases
08:35:00 <hari_> monochrom, thanks.
08:35:18 <donri> merijn: and presumably a port to bytestring builder would help even more
08:35:22 <merijn> donri: Maybe, but there's no strict BS interface :(
08:35:26 <Eduard_Munteanu> merijn: no, I want Record parametrized by a type, which is a lifted value of RecordId.
08:35:39 <donri> merijn: what'cha need that for?
08:36:15 <merijn> Eduard_Munteanu: Name one valid value to pass to Type given "Type :: r -> Record r (Succ Zero) '[]"
08:36:45 <merijn> donri: All my other stuff works with strict BS, parsing with binary and then converting to strict seems not very efficient
08:36:50 <Eduard_Munteanu> merijn: I already said I meant   Type :: (r :: RecordId) -> Record r ...
08:37:05 <donri> merijn: i think conversion to strict is almost free
08:37:11 <merijn> Eduard_Munteanu: I can see that, that doesn't answer my question
08:37:30 <Eduard_Munteanu> merijn: well you can lift specific names, why can't you lift 'r' somehow?
08:37:37 <wojtekM_> ski, Cale: thanks
08:37:38 <merijn> Eduard_Munteanu: There is no possible value of type "r :: RecordId" that you can give to Type
08:37:41 <donri> merijn: hm or not? docs say O(n)
08:37:48 <merijn> donri: Exactly
08:38:09 <Eduard_Munteanu> merijn: (r :: RecordId) is the same thing as RecordId except it's named. Think dependent types.
08:38:23 <merijn> Eduard_Munteanu: No, it's not
08:38:28 <wojtekM_> ski, Cale: I'll use the lambda version, it is clear (for me) how it works
08:38:33 <Eduard_Munteanu> Well, maybe not in Haskell.
08:38:35 * ski nods
08:38:39 <Cale> I would just use the do-notation, myself :P
08:38:40 <Eduard_Munteanu> I was asking if you can do that.
08:38:48 <Eduard_Munteanu> Something like that.
08:38:51 <merijn> Eduard_Munteanu: No, not without some other lifting tool
08:38:52 * ski . o O ( `ado' )
08:38:59 <Eduard_Munteanu> Hm, I see.
08:39:08 <merijn> Eduard_Munteanu: Haskell doesn't have values with types other than *
08:39:11 <Eduard_Munteanu> I wonder if you can define a Lift. :/
08:39:28 <Eduard_Munteanu> merijn: I know.
08:39:35 <ski> "a Lift" ?
08:39:44 <donri> merijn: could you work with toChunks maybe?
08:39:45 <merijn> Eduard_Munteanu: Something like "Proxy r" might work
08:40:42 <Eduard_Munteanu> ski: let A :: *, and a :: A. Then  Lift a  takes the value 'a' and lifts it to a type.
08:40:47 <merijn> donri: I would have to change my strict pipes functions to use lazy IO to get a lazy bytestring, then parse that using binary, which breaks all my nice pipes guarantees
08:40:54 <Eduard_Munteanu> Like Agda's Lift for example.
08:41:50 <ski> Eduard_Munteanu : which type ?
08:42:00 <n-dolio> I think that's actually not covered by Lift in Agda.
08:42:04 <donri> merijn: http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html#g:3
08:42:06 <n-dolio> It just bumps things up a universe.
08:42:08 <Eduard_Munteanu> ski: the same type DataKinds lifts the specific value to.
08:42:20 <donri> merijn: in fact that uses strict bytestrings
08:42:20 <Eduard_Munteanu> n-dolio: hm right, it won't lift A into Set.
08:42:23 <n-dolio> Or, many universes.
08:42:45 <n-dolio> Second-class cumulativity.
08:42:56 <donri> merijn: i imagine writing a pipe for that would be trivial
08:43:02 <merijn> donri: oh, that's better
08:43:22 <merijn> donri: oh well, I can always retrofit that
08:43:22 <Eduard_Munteanu> ski: with DataKinds if you have  data A = A1 | A2 ...  then A1 is both a value and a value lifted to a type. I wanted to do the same for any such A, not specific names.
08:43:48 <ski> mhm, ok
08:43:56 <Eduard_Munteanu> Any such A<n>.
08:44:32 <ski> so sortof like, given `a :: A :: *', `LiftValue a :: LiftType A, where the latter is a kind
08:44:35 <Saizan> you'd need a way to restrict it to constructors, otherwise you go beyond what DataKinds offers
08:44:48 <ski> hm, point
08:45:01 <Eduard_Munteanu> ski: I have an enumeration RecordId and a GADT like  data Record :: RecordId -> ... where Type :: (r :: RecordId) -> Record (Lift r) ...
08:45:07 <Eduard_Munteanu> I want something like Type.
08:45:34 <Eduard_Munteanu> Saizan: yes, but if you give it a bound name like 'r' in that signature it's easy to check.
08:45:48 <merijn> What's the easiest way to have "Map ByteString v" that does case-insensitive lookups? newtype bytestring and provide my own Ord/Eq or should I just lowercase before insertion/lookup?
08:46:06 <Eduard_Munteanu> You just need r's type to be inductively defined.
08:46:12 <donri> @hackage case-insensitive is in platform IIRC
08:46:12 <lambdabot> http://hackage.haskell.org/package/case-insensitive is in platform IIRC
08:46:20 <Eduard_Munteanu> Erm, or whatever other restrictions are.
08:46:37 <Saizan> Eduard_Munteanu: the way you do Type is take r to be a type of kind RecordId
08:46:58 <Saizan> Eduard_Munteanu: and add another field that reifies it to values, if you need that
08:47:24 <gavri> I'm doing exercises from okasaki's book and don't know what the best way to solve exercise 2.3 is https://raw.github.com/gavri/okasaki-exercises-solutions/wip/e2.3-insert-existing-element-without-node-copy.hs the idea is to use an exception to break out if it is determined that the element to be inserted is already in the tree
08:47:30 <Eduard_Munteanu> I wonder how though, I certainly don't want to define RecordId twice.
08:47:31 <merijn> donri: oh, interesting but how does it perform compared to my suggestions?
08:47:51 <gavri> the constraint is that only one exception handler has to be invoked
08:48:10 <gavri> is there a way to do this that doesn't require the IO monad?
08:48:18 <Saizan> Eduard_Munteanu: that's how you do it, define data RecordId = ... and then data RecordIdSing :: RecordId -> * where ...
08:48:41 <donri> merijn: probably similarly considering it stores the folded case in the type, but worse memory because it keeps the original around too
08:48:44 <Cale> gavri: Maybe/Either?
08:49:04 <ocharles> gavri: you could use the Maybe monad
08:49:07 <gavri> Maybe and Either both require that the error case is handled in each function call
08:49:18 <gavri> instead of just once
08:49:26 <Eduard_Munteanu> Saizan: but then what constructor do you have for RecordIdSing?
08:49:30 <gavri> that's one of the constraints of the exercise
08:49:52 <Eduard_Munteanu> Saizan: you meant I have to redefine it?
08:49:59 <Saizan> Eduard_Munteanu: for each constructor of RecordId you have a corresponding one in RecordIdSing indexed by that
08:50:01 <gavri> there shouldn't be exception handling for each recrusive call
08:50:06 <Cale> gavri: You can use the monad instance to simulate exceptions though.
08:50:11 <gavri> only one exception should ever have to be invoked
08:50:12 <Eduard_Munteanu> Oh, hm. That's what I was trying to avoid though.
08:51:02 <Saizan> Eduard_Munteanu: until someone implements "pi" in GHC that's how it's going to happen
08:51:03 <ski> gavri : continuations ?
08:51:39 <gavri> ski: I think that would be against the spirit of the question
08:51:57 <gavri> which I guess is to not proliferate exception case handling
08:51:57 <ski> why ?
08:52:01 <gavri> I'm not sure though
08:52:06 <Eduard_Munteanu> Right.
08:52:16 <ski> using CPS, you'd not proliferate case handling (rather the opposite)
08:52:50 <Eduard_Munteanu> I think I'll make a TH helper to define this stuff.
08:53:27 <Cale> gavri: Catching exceptions is impure though, so you need to do *something* different
08:53:56 <Cale> (Exceptions break referential transparency)
08:54:19 <ski> `insert e t = loop e t id where loop e Empty k = k (Bin e Empty Empty); loop e t@(Bin n l r) ...' or something
08:54:21 <gavri> ski: I'll look this up in haskell, but from what I remember of continuations in ruby, the  continuation reference has to be passed on, if that makes sense
08:54:41 <ski> (you could also use `Cont' i think, if you prefer that to explicit CPS)
08:55:01 <gavri> Cale: yeah, the book has been written based on standard ML. maybe it's straightforward there?
08:55:41 <ski> well, exceptions are side-effects in SML
08:55:52 <applicative> wojtekM_: like this? http://lpaste.net/6887966780627615744 or the like.
08:55:59 <Cale> Also, I'm not sure I agree with the wording of the question here: "Inserting an existing element into a binary search tree copies the entire search path even though the copied nodes are indistinguishable from the originals." -- this is untrue, if you're inserting a new node in that subtree, the "copied" nodes *are* distinguishable from the originals.
08:56:35 <gavri> this is about inserting a duplicate element
08:56:40 <gavri> an "existing" element
08:56:42 <ski> (it's just that exceptions in Haskell tend to be less predictable, and thus less desirable, due to the impreciseness of them in Haskell, because Haskell's non-strict)
08:56:44 <Cale> ah
08:57:03 <donri> merijn: actually this is weird, storing the original. presumably it means you can easily have two CI that are == but give different output for "original"?
08:57:08 <gavri> I was confused with the wording too
08:57:12 <Cale> If the element already exists, then yeah, you should be able to safely produce the original tree as a result.
08:57:17 <gavri> yeah
08:57:26 <donri> merijn: i wonder if that breaks any laws... does == have laws?
08:57:45 <elliott> donri: yes but they get broken :p
08:57:54 <applicative> reflexivity seems like a good start
08:58:09 <elliott> yeah, Float/Double break that though (Which breaks Map, Set etc. of course)
08:58:15 <ski> donri : i think `forall a0 a1. a0 == a1 = True => a0 = a1' ought to be a law (modulo irritating stuff with ADTs)
08:58:42 <elliott> I think Eq instances should be equivalence relations and that any two equal values should be denotationally indistinguishable from outside the module the type is defined in, unless you import modules or use functions marked as internal or unsafe
08:58:44 <ski> > let x = [0 ..] in x == x
08:58:51 <lambdabot>   mueval-core: Time limit exceeded
08:59:10 <applicative> they should be equivalence relations; it's hard to see why one would make a further constraint.
09:00:08 <hpaste> Cale pasted “tree insertion” at http://lpaste.net/92609
09:00:09 <donri> so is it a law that if a == b then f a == f b ?
09:00:35 <Cale> gavri: ^^ there it is with the Maybe monad
09:00:50 <ski> donri : imo, yes
09:01:17 * applicative doesn't see that that's what Eq expresses; it doesn't seem practical either
09:02:04 <Cale> But if you don't like the fact that >>= is pattern matching at each step, then perhaps we can rewrite this in success/failure continuation style
09:02:14 <ski> (re ADTs, ideally the type system would distinguish between the abstract type, and the representation type (Mercury does this, e.g.))
09:02:23 <gavri> Cale: thanks a lot. I'm no good at monads and that was very instructional
09:02:29 <applicative> maybe if there were an EqF :: (* -> *) -> Constraint ?
09:03:32 <ski> @src fromMaybe
09:03:32 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:03:45 <gavri> Cale: yeah, I'll look up CPS. thanks a lot
09:03:55 <Cale> (I know about fromMaybe, it's just not in the Prelude)
09:04:10 <ski> gavri : if you think it'll help, i could paste a CPS version or two ..
09:04:25 <ski> (but perhaps you'd prefer to mull over it yourself)
09:04:36 * hackagebot memexml 0.0.1 - Library for reading Meme XML output  http://hackage.haskell.org/package/memexml-0.0.1 (FlorianEggenhofer)
09:05:11 <gavri> ski, yeah, I'll try to figure it out myself. thanks a lot for offering. I'll ask again here if I can't get CPS to work either
09:05:28 <gavri> thanks Cale, ski and anybody else I might have missed
09:05:32 <ski> yw
09:07:18 <applicative> ski: here's an amusing Eq type https://github.com/bobatkey/Forvie/blob/master/src/Data/Type/Eq.hs
09:07:51 <applicative> he hates Bool clearly
09:08:48 <ski> well, boolean blindness and all that
09:09:05 <ski> and those classes can be useful
09:09:16 <applicative> i think his version of filter is (a -> Maybe b) -> [a] -> [b]
09:09:56 <ski> e.g. in a `lookup2 :: Eq2 key => Map2 key value -> key i -> value i' (or however you want to call them)
09:10:16 <applicative> oh yeah here's an example of atkey-filter https://github.com/bobatkey/Forvie/blob/master/src/Data/MonadicStream.hs#L383
09:11:12 <applicative> oh i see about lookup yes
09:11:41 <Eduard_Munteanu> Saizan, ski, merijn: whoa... I think I managed to do it with PolyKinds!
09:12:05 <Eduard_Munteanu> data Lift r k where Lift :: r -> Lift r k   -- bad name but ...
09:12:18 <Eduard_Munteanu> data RecordTest :: RecordId -> * where Type :: (r ~ Lift RecordId r') => r -> RecordTest r'
09:13:11 <Eduard_Munteanu> Actually it doesn't prevent me from mismatching the r's... grrr...
09:13:38 <applicative> ski:  oh this is better https://github.com/bobatkey/acfg-parser/blob/master/src/Data/TypedMap.hs
09:14:10 <Cale> applicative: Have you read https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf ?
09:14:19 <applicative> of course
09:15:12 * applicative takes arms against a C of troubles
09:15:39 <ski> applicative : yea, that's basically the `Map2' i had in mind
09:16:34 <applicative> atkey writes really good haskell when he bothers to
09:19:37 * hackagebot mmap 0.5.9 - Memory mapped files for POSIX and Windows  http://hackage.haskell.org/package/mmap-0.5.9 (GracjanPolak)
09:20:20 <applicative> Cale have you seen some of the implementations, most familiarly http://hackage.haskell.org/package/index-core and http://hackage.haskell.org/package/indexed
09:20:42 <applicative> woops wrong indexed
09:20:51 <applicative> Cale https://github.com/ekmett/indexed
09:21:21 <Cale> Yeah, I was just thinking of the funny reference to Bob Atkey in that paper
09:22:20 <applicative> oh yeah the at-key type is in edward k's library
09:23:00 <applicative> i dimly remember contibuting the Group.hs for amusement
09:23:40 <applicative> 'a groupoid is an indexed group'
09:25:12 <applicative> no one seems to have implemented the file-system example with the new ghc extensions though?
09:26:25 <donri> what example?
09:26:48 <applicative> the principal example in the Kleisli Arrows ... paper cale mentioned
09:28:53 <applicative> I think a version is in the source for the `she` package
09:31:49 <stelleg> anyone here had success with spawning on external nodes using distributed-process?
09:32:44 <ocharles> applicative: i tweeted pigworker about it
09:32:52 <ocharles> he says that paper never got finished, and he might consider redoing it without she now
09:35:45 <applicative> oh, not surprising. here's the she version of the opening problem http://lpaste.net/2875883296510705664
09:35:52 <applicative> of the solution to it
09:59:43 * hackagebot ureader 0.1.0.0 - Minimalistic CLI RSS reader.  http://hackage.haskell.org/package/ureader-0.1.0.0 (SamTruzjan)
10:10:50 <hpaste> satc pasted “Data constructors and kinds” at http://lpaste.net/92610
10:11:18 <satc> Any help with the above. I am struggling with kinds and data constructors ?? ^^
10:12:07 <applicative> whats wrong satc
10:12:35 <applicative> shouldnt the signature be data Args :: WordSize -> *
10:12:56 <supki> does not matter I think
10:13:00 <satc> applicative: Yeah. but it doesn't matter
10:13:00 <applicative> then for Op you will need a so-called Singleton type
10:13:09 <satc>  Expected kind `OpenKind', but `ws' has kind `WordSize
10:13:12 <satc> Error ^
10:13:15 <applicative> yes
10:13:28 <satc> It seems like you can pass only openkind to data constructors
10:13:37 <evancz> does anyone know if you can pretty print with aeson?
10:13:47 <evancz> I cannot seem to find any dials for this
10:14:20 <supki> evancz: there is aeson-pretty package
10:14:53 <evancz> okay, thank you! I'll take a look :)
10:15:03 <applicative> so like that satc http://lpaste.net/92610
10:16:34 <satc> applicative: Thanks. That looks like what I want.
10:18:05 <mm_freak> ocharles: pushed =)
10:18:08 <applicative> i finished porting mcbride's filehandle example to use datakinds ocharles donri cale http://lpaste.net/2472160253337141248
10:18:26 <applicative> and edward's 'indexed' implementation
10:21:47 <evancz> supki: works great, thanks :)
10:21:53 <Zenol> I have a lens that works with the Register type. What should I write so that it works with any "HasRegisters" ? (now I have to write registers . myLens each time).
10:22:16 <evancz> do you happen to know why it converts ">" to "\u003e"?
10:24:19 <evancz> hmm, it looks like they are equivalent to JS's JSON.parse
10:26:51 <donri> Zenol: makeClassy ''Register and then add instances for the generated class
10:28:18 <supki> evancz: any character in JSON string can be escaped
10:28:27 <supki> I think spec explicitly states that
10:28:47 <evancz> It seems like an odd choice for readability though
10:28:48 <supki> section 2.5
10:29:13 <evancz> i.e. it can be done, but why would it be done
10:30:29 <Zenol> donri: I have already a makeClassy ''Register, and I added instance for HasRegister, that's why registers . myLens works.
10:31:08 <Zenol> donri: But I would like to use myLens on anything which is instance of HasRegister.
10:31:34 <donri> Zenol: and how is myLens written/generated?
10:31:42 <Zenol> donri: Maybe I should write a (HasRegister t) => Lens' t Word8
10:31:53 <Zenol> donri: Writen by hand, of type Lens' Registers Word8
10:32:15 <Zenol> er, Lens' Registers Bool for this one, actualy, but it doesn't matter.
10:32:22 <donri> Zenol: then yeah, just add a HasRegister constraint and compose with the registers lens
10:33:05 <donri> Zenol: i think it generates an id instance for HasRegister Register for you
10:33:40 <ocharles> mm_freak: ooo! partner is round atm, but i'll look forward to checking it out later :)
10:38:57 <stolaruk> How can I get a line of input from the console w/ support for cursor movement based on the arrow keys?
10:40:23 <applicative> stolaruk: i think getLine already has suitable buffering and whatnot, no?
10:41:01 <geekosaur> not for arrow keys necessarily. haskeline or readline package
10:41:06 <Makoryu> stolaruk: getLine will interface with whatever input buffering is available in your TTY (unless you use it inside ghci)
10:41:08 <stolaruk> applicative: It's not handling the arrow keys on my bash
10:41:27 <stolaruk> I've been using runghc
10:41:49 <applicative> oh, yes it doesnt work in my ghci -- but if i compile things it's fine
10:41:57 <stolaruk> geekosaur: thanks, will take a look
10:42:00 <Makoryu> On most systems if you want arrow key support you need application-specific terminal handling
10:42:18 <Makoryu> Haskeline and readline give you "good defaults" for REPL-like input
10:42:31 <Makoryu> History navigation with up/down, tab expansion, etc.
10:43:04 <stolaruk> Makoryu: that sounds like what I want
10:43:19 <applicative> if you are speaking of a line of input, there are only the <- and -> keys, no?
10:43:38 <Makoryu> applicative: Not if you use history navigation
10:43:49 <stolaruk> applicative: yes but those keys are not working for me, also I do want history nav
10:44:08 <applicative> you didn't say you want that. i doubt that haskeline etc will work properly with runghc either
10:44:11 <Zenol> donri: It's that. Thanks :)
10:44:15 <geekosaur> you will probably need extra code for history support
10:44:36 <stolaruk> Yeah I can roll my own history support if necessary, no big deal
10:44:57 <geekosaur> well, it has the history support. what it does not have is any clue about your program context
10:45:06 <Zenol> wonderfull, lens that allow acessing bytes one by one \ o /
10:45:07 <applicative> there is ample history support in haskeline
10:45:08 <stolaruk> yes, I would imagine
10:47:25 <haasn> dmwit: oh, you wrote yeganesh? thanks!
10:48:21 <chrisdotcode_> hi every one :)
10:48:28 <applicative> hi chrisdotcode_
10:48:38 <chrisdotcode_> hi ,applicative :)
10:51:50 <chrisdotcode_> :t liftIO
10:51:51 <lambdabot> MonadIO m => IO a -> m a
10:52:07 <chrisdotcode_> so in liftIO, is "a" a function?
10:52:39 <Cale> chrisdotcode_: That 'a' is a type variable which could stand for any type at all.
10:52:53 <Cale> (Including function types)
10:53:29 <chrisdotcode_> Cale: okay, so I've been trying to wrap my head around this. fmap is (a ->b) -> (f a -> f b), which is making the function operate on functors, but the type signature of liftIO just confuses me.
10:53:48 <chrisdotcode_> I'd expect something like: (a -> b) -> IO (a -> b)
10:53:57 <haasn> that's ‘return’ aka ‘pure’
10:54:01 <haasn> and is unrelated to what liftIO does
10:54:06 <haasn> liftIO is not to be confused with liftM
10:54:08 <Cale> liftIO takes an IO-action and turns it into an m-action
10:54:12 <chrisdotcode_> :t liftM
10:54:12 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:54:31 <chrisdotcode_> okay, I think I thought that liftIO was liftM, before I knew what liftM was.
10:54:32 <geekosaur> chrisdotcode, it evaluates an IO action, whatever it is, in the context of a monad which has a MonadIO instance (that is, one which has an IO monad at its base and which knows how to reach that IO)
10:54:41 <haasn> ‘liftIO’ is like ‘lift’, ie. for monad transformers
10:54:45 * hackagebot HSmarty 0.1.0.0 - Haskell implementation of a subset of the PHP-Smarty template language  http://hackage.haskell.org/package/HSmarty-0.1.0.0 (AlexanderThiemann)
10:54:47 <haasn> :t left
10:54:48 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
10:54:50 <chrisdotcode_> I thought that "liftIO" was lifting an action to an IO context, but I guess it's the other way around?
10:54:51 <haasn> err
10:54:52 <haasn> :t lift
10:54:53 <dmwit> haasn: cheers =)
10:54:53 <lambdabot>     Ambiguous occurrence `lift'
10:54:53 <lambdabot>     It could refer to either `Control.Monad.Writer.lift',
10:54:53 <lambdabot>                              imported from `Control.Monad.Writer' at /home/lambdabot/.lambdabot/State/L.hs:52:1-27
10:55:03 <haasn> :t Control.Monad.Transformer.Class.lift -- err
10:55:04 <lambdabot> Couldn't find qualified module.
10:55:08 * haasn gives up
10:55:15 <Cale> chrisdotcode_: It takes an IO action, and turns it into an m-action.
10:55:16 <geekosaur> chrisdotcode_, I think it depends on what side you're approaching it from :)
10:55:26 <haasn> (Monad m, MonadTrans t) => m a -> t m a
10:55:28 <geekosaur> 'lift' is used a lot of ways in haskell, some of them contradictory
10:55:44 <chrisdotcode_> so isn't liftIO unsafe, because it's "unwrapping" an inherently unsafe action (IO), and putting into a monad?
10:55:51 <geekosaur> no
10:55:51 <Cale> chrisdotcode_: no
10:55:56 <Cale> chrisdotcode_: m isn't arbitrary
10:55:57 <applicative> ?
10:56:03 <haasn> liftIO is like lift, except that ‘m’ is IO and ‘t m’ becomes just ‘m’
10:56:03 <Cale> liftIO can't be used with any monad m
10:56:08 <chrisdotcode_> ohhhh, okay.
10:56:10 <chrisdotcode_> :t liftIO
10:56:11 <geekosaur> notice the MonadIO constraint
10:56:12 <lambdabot> MonadIO m => IO a -> m a
10:56:21 <chrisdotcode_> oh, okay. I didn't see the MonadIO constraint.
10:56:37 <Cale> It can only be used with certain monads which support such an operation, likely because IO is being used in their definition.
10:56:40 <geekosaur> this means the monad must (a) be based on IO and (b) know how to reach that IO without forcing you to Control.Monad.Trans.lift through each level individually
10:56:43 <haasn> chrisdotcode_: eg. instance MonadIO (IdentityT IO) where liftIO m = IdentityT m
10:56:45 <geekosaur> to reach that IO
10:56:50 <chrisdotcode_> so liftIO takes an IO action and makes it into a MonadIO action?
10:56:56 <haasn> yes
10:57:03 <Cale> Into an m-action for some m which is an instance of MonadIO
10:57:07 <chrisdotcode_> and liftM does the same thing as fmap, but with monads?
10:57:22 <haasn> instance MonadIO (ReaderT r IO) where liftIO m = ReaderT (\_ -> m)
10:57:27 <haasn> etc.
10:57:29 <Cale> yeah, liftM is the default implementation of fmap for something which is an instance of Monad
10:57:32 <haasn> chrisdotcode_: yes
10:57:47 <chrisdotcode_> okay, cool. so I think I got it.
10:58:19 <chrisdotcode_> I just finished typeclassopedia; where should I go next?
10:58:29 <chrisdotcode_> (besides writing code, of code :) )
10:58:44 <Cale> Read Simon Peyton Jones' papers
10:59:00 <haasn> read some ekmett haddocks
10:59:03 <haasn> (don't)
10:59:15 <Cale> (especially older ones)
10:59:23 <chrisdotcode_> heh, I was scared of touching papers for as long as I could...
10:59:31 <haasn> SPJ writes a lot of readable stuff
10:59:31 <applicative> chrisdotcode_: start making arbitrary claims about how the typeclass heirarchy is totally wrong
10:59:32 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf is a good one to start with perhaps :)
10:59:35 <haasn> eg. his paper on Beautiful Concurrency
10:59:36 <haasn> yeah that one :)
10:59:46 <chrisdotcode_> oh, STM. I know very little about how it actually works
10:59:54 <haasn> then read the paper :)
10:59:54 <chrisdotcode_> thanks, guys :)
11:00:15 <applicative> chrisdotcode_: if you are interested in stm like things there is also the new book by Simon M
11:00:22 <structuralist> Have any libraries been written based on http://dl.acm.org/citation.cfm?id=1842044 ?
11:00:27 <chrisdotcode_> applicative: is the paper entry-level enough?
11:00:39 <structuralist> ("Categorifying Computations into Components via Arrows as Profunctors")
11:01:04 <applicative> chrisdotcode_: it's a book, or manual; I just mention it, take a look http://chimera.labs.oreilly.com/books/1230000000929/index.html
11:01:41 <chrisdotcode_> applicative: awesome! thank you :)
11:01:44 <Cale> structuralist: It's hard to tell without being able to read the paper.
11:02:00 <Zenol> oh, 'parcon'.
11:02:04 <applicative> chrisdotcode_: and the example code https://github.com/simonmar/parconc-examples
11:02:07 <structuralist> Cale: I think this should be accessible: http://www.sciencedirect.com/science/article/pii/S157106611000071X
11:02:16 <Cale> http://takeichi.ipl-lab.org/~asada/papers/fromComptoComp.pdf -- found it
11:03:58 <zark4711> Hi developers, can anyone give me a 3-word-hint, if it is possible with quickcheck to check if the code tested throws an exception. as an example: a function that removes an element from an empty set should throw and exception instead of just returning an untouched set. i was too stupid to find anything relevant on the web.
11:05:02 <Cale> I think that's what  expectFailure :: Testable prop => prop -> Property  is for
11:07:04 <Cale> structuralist: I'm not even sure what it would mean to implement the results of that paper as a library.
11:07:26 <zark4711> @Cale: yes, I found that too. But it says "expected to fail for some test cases". Anyone know how to expect failure for all cases?
11:07:26 <lambdabot> Unknown command, try @list
11:08:20 <Cale> structuralist: But Ed Kmett has some libraries with profunctor-related stuff.
11:09:19 <haasn> Cale: I'm trying to find that one ekmett library that really had me rolling on the floor in terms of documentation, but I have no leads :(
11:09:34 <mjboa> clear
11:09:35 <Cale> haasn: ?
11:09:47 <Eduard_Munteanu> Is there any way, when using DataKinds, to associate constructors of a type with their lifted counterparts, or the type itself with the corresponding kind? I'm trying to generate some typeclasses to do the lifting from that kind to *.
11:10:11 <haasn> Cale: oh, wait, was your “(especially older ones)” not a reply to “read some ekmett haddocks (don't)”?
11:10:32 <Cale> haasn: It was a continuation of my last message, about reading SPJ's papers
11:10:51 <haasn> ah, okay
11:11:05 <Eduard_Munteanu> TH might be able to generate them but there isn't much type safety to it.
11:11:37 <structuralist> Cale: I'm hoping there's a nice library for composing systems expressed as coalgebras
11:12:30 <td123> when binding to a c lib, how do I represent a struct with no body?, typedef struct foo foo;
11:12:31 <haasn> oh, I found it
11:12:42 <structuralist> Cale: I'd guess a library would mean some kind of implementation of this sentence: "the behavior of composed components can be computed from the behavior of each component"
11:12:52 <haasn> typical ekmett documentation: “Mathematically, it is a strong lax symmetric semi-monoidal comonad on the category Hask of Haskell types. That it to say that w is a strong lax symmetric semi-monoidal functor on Hask, where both extract and duplicate are symmetric monoidal natural transformations.”
11:13:24 <Cale> haasn: Makes sense to me :)
11:14:43 <mr-> strong lax sounds weird
11:15:51 <mr-> (I thought they exclude each other..)
11:15:59 <Cale> I think that's strong in the sense of having a strength
11:16:16 <Cale> (the terminology is somewhat overlapping...)
11:17:34 <mr-> Ah, tensorial strength?
11:17:38 <Cale> yes
11:18:54 <Eduard_Munteanu> strict <-> lax
11:19:14 <Eduard_Munteanu> As in strict monoidal.
11:19:36 <Cale> There's also strong monoidal functors whose coherence maps are invertible
11:19:57 <danharaj> isn't that strict monoidal
11:19:58 <Cale> Strict monoidal functors are the ones whose coherence maps are the identity
11:20:02 <danharaj> ah
11:20:21 <structuralist> "a strong monoidal functor may also be called a weak monoidal functor" http://ncatlab.org/nlab/show/monoidal+functor
11:20:25 * structuralist facepalms
11:20:35 <Eduard_Munteanu> Hah.
11:20:47 <Eduard_Munteanu> I guess that's weak as in weak n-category?
11:21:17 <Eduard_Munteanu> i.e. some law that's usually an equivalence holding only up to isomorphism.
11:21:20 <Cale> There's an unfortunate proliferation of potential convention choices in low-dimensional higher category theory.
11:24:11 <Cale> Yeah, the thing about strong vs. weak there is whether "monoidal functor" for you is the same as "lax monoidal functor" or "strict monoidal functor"
11:35:14 <haasn> what's the newtype for reversing ordering?
11:36:01 <haasn> oh, Down
11:50:48 <Eduard_Munteanu> Argh... it seems asstypes can't share constructors between instances.
11:51:46 <Eduard_Munteanu> Maybe I want a type synonym.
11:54:59 <mr-> Meh.. is there a way to see which fromJust failed? ;-)
11:56:02 <geekosaur> fromJust unreasons
11:56:47 <kier> replace fromJust with fromMaybe (error "my distinguishable error")?
11:57:19 <Zenol> would be cool if there was a "fmap flip set" function/operator in Lens.
11:58:20 <edwardk> ;t fmap flip set
11:58:25 <edwardk> :t fmap flip set
11:58:26 <lambdabot> ASetter s t a b -> s -> b -> t
11:58:26 <shachaf> Er, by "fmap" do you mean "(.)" here?
11:58:31 <edwardk> :t set
11:58:32 <lambdabot> ASetter s t a b -> b -> s -> t
11:58:40 <edwardk> you can use set ?? xs
11:58:47 <mr-> kier: it's a rather large codebase, most of which is not writen by me
11:58:48 <edwardk> er
11:58:50 <edwardk> set l ?? xs
11:59:22 <ReinH> edwardk: hai
11:59:31 <edwardk> we added (??) because there were a _lot_ of requests for flipped versions of almost every combinator ;)
11:59:46 <edwardk> heya ReinH
11:59:50 <enthropy> do people have a name for f :: Chan (a, b -> IO ()) -> a -> IO b
11:59:54 <shachaf> I only ever remember requesting flipped set.
12:00:29 <edwardk> flipped set, flipped over, flipped view for folks who liked infix names but not the operators, etc.
12:01:04 <Eduard_Munteanu> I figured it out...
12:01:40 <noteventime> Is it possible to tell haskell-mode how to start GHCi, I want to use it with a cabal sandbox?
12:01:42 <ReinH> edwardk: I have a question for you about parallelization and sharing
12:02:57 <Eduard_Munteanu> data Foo = FA | FB   class Promoted a where data Lift a :: *; lift :: Lift a;    instance Promoted 'FA where  data Lift 'FA :: * where LiftFA :: Lift 'FA; lift = LiftFA;
12:03:16 <Eduard_Munteanu> Then you can do stuff like   data Test :: Foo -> * where  Con :: Lift f -> Test f
12:03:32 <Eduard_Munteanu> Not sure if Lift is an appropriate name though.
12:03:56 <ReinH> edwardk: my dijkstra map map algorithm could theoretically benefit from sharing betweet maps. e.g. if I am creating the map for target coord c and I already have (some part of) the map evaluated for another cell c', I can merge the results from c' to speed up the calculation for c
12:04:17 <Eduard_Munteanu> And building a Test 'FA is as easy as 'Con lift'
12:04:33 <Eduard_Munteanu> Perhaps I should s/lift/proxy/
12:04:34 <edwardk> ReinH: that way lies a muddled mess of very fast imperative code ;)
12:04:58 <Eduard_Munteanu> Anyway, that seems easy to generate with TH.
12:04:59 <ReinH> edwardk: well, let's just say I only use complete results for c'
12:05:04 <ReinH> but I don't want to block on their evaluation
12:05:15 <ReinH> I want to say "if the result is evaluated, use it. If not, don't"
12:05:19 <edwardk> as you're folding along maybe you could keep track of a 'current overall result' or something
12:05:22 <ReinH> is there some way to do that?
12:05:22 <edwardk> and fold it in first
12:05:39 <edwardk> there is, but i don't know how well it works. i have a package for it
12:05:44 <ReinH> edwardk: right, I mean, I could do this all in a State monad or something
12:05:49 <ReinH> I'm more concerned with the non-blocking-ness
12:05:53 <edwardk> http://hackage.haskell.org/packages/archive/tag-bits/0.1.1.2/doc/html/Data-TagBits.html
12:06:03 <edwardk> see unsafeIsEvaluated
12:07:03 <edwardk> ReinH: i haven't used that in a while though, so if they've added new closure types to GHC or changed the heap layout your mileage may vary
12:07:07 <ReinH> heh :)
12:07:28 <ReinH> edwardk: sounds scary. I'll put that approach on hold for the moment
12:07:46 <Zenol> 'fmap flip set (registers . fl) reg . not' ->  'set (registers . fl) ?? reg . not' ?
12:07:48 <ReinH> edwardk: I should, however, be able to turn this into an iterative bfs algorithm by enumerating all the nodes in bfs order
12:07:50 <edwardk> the guts of that function are enlightening if you care about ghc internals
12:07:55 <ReinH> basically folding of neighbors
12:08:12 <edwardk> Zenol: not sure of fixity there, but generally thats the idea
12:08:45 <ReinH> edwardk: and since we're talking about a static grid where all nodes are eventually traversed, I should be able to build this enumeration in linear time, right?
12:08:58 <ReinH> I just find some way of enumerating that puts the nodes in the right order?
12:09:07 <Zenol> Hum, ((set (registers . fl)) ?? (reg . not)) doesn't type :s
12:09:32 <edwardk> write it without flipping or anything, just straight
12:09:39 <ReinH> what do you mean?
12:09:45 <edwardk> that was for Zenol
12:09:47 <ReinH> oh duh
12:10:47 <Zenol> edwardk: It type / compile with the fmap flip version. I need this partial application to map throught <$>.
12:11:16 <ReinH> edwardk: if I'm starting at 0 in a 1d universe than my traversal order would be [1, -1, 2, -2...]
12:11:23 <shachaf> Why do you write fmap when you mean function composition? :-(
12:11:24 <edwardk> Zenol: yes. i just want to help you work through what the ?? version looks like
12:11:47 <ReinH> I should be able to do the same for a 2d universe, right?
12:11:53 <edwardk> Zenol: and the first step is deobfuscating it down to just applying set inside a lambda =P
12:12:46 <Zenol> > set _1 ?? (1, 2) $ "a"
12:12:48 <lambdabot>   ("a",2)
12:13:21 <Zenol> Oh
12:13:26 <Zenol> ok, .not, right.
12:13:40 <edwardk> yes, what you had was .not right =)
12:14:06 <Zenol> xD
12:19:37 <ReinH> edwardk: what's the term for the difference in "memoization" between fib n = (map fib' [0..] !! n) and fib = (map fib' [0..] !!)
12:19:45 <ReinH> it's not technically memoization, right?
12:20:19 <edwardk> both forms suck ;)
12:20:25 <ReinH> how so?
12:20:26 <edwardk> thats the term =P
12:20:52 <edwardk> well, depends on if fib' is defined in terms of your fib list, but in general
12:21:04 <ReinH> I don't care about it being a good definition of fib
12:21:10 <ReinH> I care about the at-need evaluation semantics
12:21:34 <edwardk> the form of fibs that gives you the list defined in terms of itself is a much better use of memoization, then not sharing any of the previous results and just remembering the answer
12:21:53 <edwardk> the way those are written they get no dynamic programming benefit
12:22:02 <ReinH> edwardk: let me put this into my context
12:22:28 <edwardk> http://stackoverflow.com/questions/3208258/memoization-in-haskell/3209189#3209189 talks about a nicer memoization scheme, but i realize you aren't fishing for better ways to write fib ;)
12:22:32 <ReinH> edwardk: if I'm going to traverse my map breadth-first, checking neighbors as I go, I want to memoize getting the value at a coord and getting the neighbors for a coord
12:23:12 <ReinH> is it sufficient to do: let get = (map!!!); neighbors = (neighborsOf grid) in ...
12:23:23 <ReinH> or is that unnecessary?
12:24:16 <ReinH> hmm, actually the iterative version wouldn't be able to use sharing in that way
12:24:20 <edwardk> you could compute the neighbors of your grids once and forall
12:24:23 <ReinH> since the map is ephemeral
12:24:24 <edwardk> right?
12:24:43 <ReinH> as in the map is the accumulator of intermediate results
12:24:50 <edwardk> e.g. when you start up, during that folding step, grab the grid, compute the neighbors and store that as a grid or zipped into your result grids
12:24:58 * hackagebot HaRe 0.7.0.1 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.1 (AlanZimmerman)
12:25:42 <ReinH> edwardk: right, I can have a function Grid a -> Grid (a, a), something like ifoldr (id &&& minNeighbor)
12:26:20 <Eduard_Munteanu> Cool, this trick works for promoted Nats too.
12:26:23 <ReinH> edwardk: the thing is though, and this is proving my original question to be irrelevant
12:26:38 <ReinH> for each step in the bfs traversal, I only need the value of that square and its immediate neighbors
12:26:41 <ReinH> so never mind :)
12:27:02 <ReinH> and those values will change during the traversal since I'm getting them from the accumulated grid of previous results
12:29:28 <ReinH> although it occurs to me that I might be able to compute the distance to each point in the map in parallel using jump point search to each point more quickly than in serial using a bfs
12:29:50 <ReinH> especially for larger maps
12:30:24 <ReinH> although I'd probably have to be more careful about granularity since I'd potentially be creating a *lot* of sparks
12:31:52 <ReinH> and I've been wanting to implement JPS in Haskell anyway, so I might as well give it a shot
12:33:13 <edwardk> clearly you should use workstealing instead ;)
12:33:52 <Eduard_Munteanu> Haha... this is cool: type Lift a = (Lifts a ~ Lifts a)
12:34:04 <edwardk> Eduard_Munteanu:?
12:34:20 <epta> What happens with fpcomplete? http://img89.imageshack.us/img89/2176/mvp6.png
12:34:21 <Eduard_Munteanu> I'll pastebin this thing for some context.
12:34:41 <edwardk> epta: wow. i've never seen that before
12:34:45 <edwardk> johnw: ^- ideas?
12:35:23 <edwardk> epta: where are you coming from geographically?
12:35:46 <ReinH> edwardk: I just realized something cool!
12:36:05 <edwardk> that you could use a chase-lev deque and workstealing?
12:36:13 <edwardk> =)
12:36:31 <epta> edwardk: russia
12:37:04 <edwardk> epta: johnw or mgsloan or one of the other fpcomplete guys around here may know what's going on
12:37:18 <edwardk> i'm actively mentioning them by name to see if any of them are awake ;)
12:37:36 <ReinH> edwardk: JPS will traverse the non-pruned nodes between the source and target and can trivially calculate the distane to each (it's `succ`). If I iterate through the map from outside in to find the distance to each node via JPS, annotating all distances of traversed nodes as I go, I might be able to get a lot of sharing!
12:37:50 <Eduard_Munteanu> edwardk: http://lpaste.net/92615
12:37:54 <ReinH> edwardk: also what is a chase-lev deque?
12:38:14 <ReinH> oh this http://hackage.haskell.org/package/chaselev-deque
12:38:19 <mkramer> Question about GADTs: How are these functions semantically different from each other? http://lpaste.net/92616
12:38:45 <Eduard_Munteanu> edwardk: tldr I want to refer to Nats like I do in Example.
12:38:45 <ReinH> edwardk: aaaaaaand now I have another paper to read o_O
12:39:00 <Eduard_Munteanu> edwardk: without declaring a constructor for each nat I want to force the index for.
12:39:13 <edwardk> ReinH: http://ekmett.github.io/structures/Control-Concurrent-Deque.html
12:39:19 <ReinH> oh cool
12:39:20 <edwardk> ReinH: i think the docs there are starting to not suck
12:39:22 <Eduard_Munteanu> edwardk: any idea if there's a cleaner way to write that constraint synonym?
12:39:24 <ReinH> edwardk: :D
12:39:43 <elliott> mkramer: the instance gets brought into scope by pattern matching on the constructor
12:39:52 <elliott> since isBigger never does so, it doesn't get the Ord a
12:40:19 <edwardk> i mayb should switch that to working over an arbitrary prim monad so that you _could_ use it in ST s if you wanted
12:40:38 <epta> edwardk: working now
12:40:42 <Eduard_Munteanu> The constraint synonym is there so you don't need to provide a proxy value like 'lift'.
12:40:44 <madjestic> I am trying to load a file "foo" from disk by one of the functions - if such file is in a subdir, relative to the main file, will it get picked automatic, or the file name needs a subdir prefix?
12:41:07 <n-dolio> mkramer: Any match in a let is irrefutable. Irrefutable matches don't provide evidence from a GADT match, because they succeed even if the right constructor isn't there.
12:41:16 <n-dolio> That is why #3 doesn't work.
12:42:22 <mkramer> Thanks guys. What you say makes sense. But suppose I'm in a do block and I just pulled a Tag a out of a monad. Now I need to get the value in the tag and I need its constraints in scope
12:42:32 <mkramer> How can I do that?
12:42:51 <Eduard_Munteanu> Oh bah.
12:42:57 <n-dolio> Tag a s <- ...
12:43:18 <Eduard_Munteanu> I can just use 'Promoted a' instead of that.
12:43:55 <ReinH> edwardk: ok, so this lets me parallelize using a thread pool idiom with non-blocking "steal". Awesome sauce.
12:44:36 <Cale> mkramer: btw, "monad" refers to the type constructor, rather than the values (which we might refer to as "actions")
12:44:52 <ParahSailin> are people generally satisfied with optparse-applicative?
12:45:01 <Clint> generally
12:45:05 <Cale> mkramer: e.g. Maybe is a monad, but Just 5 is not
12:45:18 <jfischoff> I'm using ScopedTypeVariables and I have something like forall m. Monad m => …. and in my function I have blah :: m Int, but I'm getting an error that saying Could not deduce m Int ~ m0 Int
12:45:38 <jfischoff> why is ghc not respecting my annotation?
12:45:43 <ParahSailin> because ive been using it for only very simply cmdline parsing of arguments, but trying to do more unusual stuff is very difficult with it
12:46:27 <johnw> epta: which URL did you go to to see that FP Complete Heroku error message?
12:47:10 <mkramer> Cale: n-dolio: thank you
12:48:02 * Eduard_Munteanu is a tad bit stupid
12:48:14 <ReinH> edwardk: I just realized something else! I can take advantage of the pruning behavior of JPS: Split the map into quadrants centered on the source square and do the JPS-based distance map in parallel on each. It's guaranteed that there will be no possibility for sharing among quadrants! :D
12:48:14 <Eduard_Munteanu> I don't need that at all if I don't want to specify a value.
12:48:32 <ReinH> edwardk: I think I came up with an algorithm that doesn't suck. I am excite.
12:48:51 <ReinH> well, that's not true
12:48:53 <edwardk> hrmm, why is there no stToPrim in Control.Monad.Primitive?
12:48:57 <ReinH> adjacent quadrants might have some sharing
12:48:59 <edwardk> its easy to write with the pieces they give
12:49:10 <ReinH> but opposite quadrants won't
12:49:37 <joelteon> is it easy to type "hsvm"?
12:49:37 <ReinH> but it's ok if I duplicate a little work if I can get overall speedups from the parallelization
12:50:02 <edwardk> i guess its primToPrim
12:51:51 <epta> johnw: https://www.fpcomplete.com/ , it's on the screen actually
12:52:15 <totte> Is there an equivalent to the gcc "-ftime-report" for ghc to measure the time it takes to compile?
12:52:39 <edwardk> ok, aborting that change. it isn't worth the pain
12:53:47 <johnw> epta: can you send me a browser window screen shot?
12:54:29 <epta> johnw: http://img89.imageshack.us/img89/2176/mvp6.png
12:54:47 <johnw> that's the whole browser window?  what browser are you using?
12:54:56 <epta> firefox :(
12:55:38 <epta> btw, now it's working, so I think it was a just heroku issue
12:55:49 <johnw> ah, ok
12:55:52 <johnw> I hadn't heard of that problem yet
12:56:33 <Eduard_Munteanu> Argh, I think I accomplished nothing.
12:57:54 <Eduard_Munteanu> There still is no way to relate constructors and their lifted counterparts.
12:58:15 <Eduard_Munteanu> Unless there is some extension that allows classes parametrised on values or something like that.
12:58:43 <johnw> Eduard_Munteanu: can you show an example of what you're talking about?
12:59:43 <Eduard_Munteanu> johnw: I was working on http://lpaste.net/92615 until I realized it does nothing helpful. I wanted to relate constructors to their lifted counterparts (give DataKinds).
12:59:51 <ReinH> edwardk: I have an administrivia question for you: what's the easiest way to set up a cabal package with correct source dirs and such?
13:00:05 <ReinH> i.e. fastest 0 to new package development
13:00:20 <Eduard_Munteanu> Some of that is obviously stupid in retrospect.
13:00:23 <ReinH> I figure you must have it streamlined since you've written a hundred packages
13:01:08 <Eduard_Munteanu> I guess I can relate original type constructors with lifted data constructors, since they're on the same level.
13:02:05 <levi> Not to speak to edwardk's practices, but some really prolific people are just good at cranking stuff out, whether it's filled with boilerplate or not. Maybe even *most* prolific people.
13:02:52 <edwardk> ReinH: i've gotten very good and spewing out boilerplate ;)
13:03:12 <edwardk> ReinH: you may want to take something like https://github.com/lens/project-template as a baselin
13:03:49 <edwardk> ReinH: it doesn't follow _all_ of my current practices, but it has enough
13:04:29 <johnw> heh, I have a template on github too :)
13:04:53 <johnw> I think half of being "experienced" in any system is the amount of boilerplate you've evolved to solve common issues
13:05:00 * hackagebot hsx 0.10.5 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.5 (NiklasBroberg)
13:05:00 <edwardk> ReinH: my usual approach is to start with one module, get it to work, throw it in a repo, under a src dir until i can't load it easily from ghci to test, then pull in a cabal file, get it up to github and keep going
13:05:50 <edwardk> i wind up with a lot of little project-lets that don't quite make it to the thresholds along the way
13:06:53 <enthropy> is putting haskell code in a quasiquote a solved problem?
13:07:15 <dennis> Hi
13:07:51 <dennis> Got a question regarding libarys
13:07:53 <enthropy> the haskell-src-exts parser doesn't have a way to act like reads
13:08:38 <dennis> Is there a well performing libary for matrices which implements the standard operations for matrices?
13:08:58 <enthropy> so I'm not really sure how to get the stuff in between the $( ) for  $(<<something haskell-src-exts can parse>>)
13:09:28 <dennis> im actially using this one: http://hackage.haskell.org/packages/archive/bed-and-breakfast/0.4/doc/html/Numeric-Matrix.html is there one that performs better?
13:09:31 <Cale> dennis: Sure, there are a few. You might try hmatrix, which is a binding to GSL, BLAS and LAPACK
13:09:40 <edwardk> dennis: linear is simple, there is also hmatrix which is more traditional
13:11:56 <dennis> ah seems its the same then :=
13:12:06 <dennis> good if u recommend it ill use that one ;)
13:12:09 <dennis> thx
13:15:10 <swistak35> Hi
13:17:01 <swistak35> let's say, that I have a function which reads a contents of a file, creates some datatype based on contents of the file, and return that datatype. However, I know that through whole working of the program, contents of this file doesn't change. Is there some way to memoize this value and not read contents of this file every time?
13:17:56 <geekosaur> then why are you reading it multiple times?
13:18:48 <swistak35> because it's kind of "external plugin" and I wanted to avoid putting this result in my main program
13:19:28 <Cale> swistak35: If you just don't readFile more than once, then the value you get won't be recomputed
13:19:39 <Eduard_Munteanu> swistak35: your plugin can be a big term of the corresponding ADT then.
13:19:44 <Cale> (it won't read the file more than once unless you explicitly say to do that)
13:20:25 <swistak35> Eduard_Munteanu: what's "ADT"?
13:20:42 <levi> Probably Algebraic Data Type?
13:20:52 <johnw> correct
13:23:29 <Eduard_Munteanu> I wasn't being very serious. :)
13:24:38 <swistak35> Eduard_Munteanu: sorry, I'm still newbie : )
13:28:31 <johnw> newbies are the future
13:39:20 <Makoryu> Okay. Tree transformations in Haskell. Any gotchas I should know about?
13:39:28 <ClaudiusMaximus> swistak35: maybe you can exploit first class IO actions - have your plugin be an IO action that constructs and returns one (or more) other IO actions.  something like  happiness :: IO (IO (), IO Bool) ; main = do{ (getHappier, happyNow) <- happiness ; let loop = do { getHappier ; h <- happyNow ; unless h loop } ; loop ; putStrLn "bliss" }
13:41:17 <levi> Makoryu: I guess it would help to know a bit more about the context.
13:46:51 <NemesisD> anyone running cabal 1.18.0
13:46:58 <johnw> yes
13:47:10 <merijn> yes
13:47:26 <joelteon> yes
13:47:30 <sm> yes
13:47:40 <NemesisD> i can't install the mysql package with it
13:47:53 <NemesisD> it looks like there may have been an api change that broke the setup script
13:48:01 <sm> totally your fault, cabal 1.18.0 is flawless
13:48:30 <NemesisD> could one of you guys give it a try. i'm willing to entertain the idea that its my fault
13:48:36 <sm> :)
13:48:59 <merijn> Clearly there's only one solution
13:49:02 <merijn> Blame Duncan
13:49:41 <NemesisD> no no! take the opportunity to blame me first!
13:50:08 <tel> NemesisD that hit me too, there was definitely an API change in cabal
13:50:21 <sm> NemesisD: fails here too
13:50:30 <tel> unfortunately, I didn't document it : (
13:50:32 <NemesisD> tel: did you figure out a workaround or roll back
13:50:46 <tel> I cabal unpacked and worked around it
13:50:54 <tel> give me 5 minutes and I'll figure it out again
13:50:56 <tel> (hopefully)
13:51:14 <NemesisD> should i file a ticket with bos/mysql or haskell/cabal?
13:52:00 <tel> bos/mysql
13:52:10 <tel> it was an intended cabal api change so far as I can tell
13:52:20 <NemesisD> rgr. i'll file a ticket
13:52:39 <tel> programFindLocation in the SimpleProgram ADT changed types, require's a new parameter
13:53:29 <tel> and if I could find a haddock anywhere I could be more specific
13:54:37 <tel> here we go, programFindLocation :: Verbosity -> ProgramSearchPath -> IO (Maybe FilePath)
13:54:43 <tel> ProgramSearchPath is new
13:55:02 * hackagebot bound 0.9 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.9 (EdwardKmett)
13:56:10 <tel> that ProgramSearchPath I think can just be ignored, but it means that the mysql Setup script doesn't typecheck on Cabal 18
13:56:30 <tel> and by ignored I mean "it worked for me"
13:58:00 <NemesisD> tel: so did you set it to [] on your build
13:58:32 <tel> all I did was
13:58:40 <tel> Setup.lhs line 26
13:58:43 <tel>     programFindLocation = \verbosity -> liftM2 mplus
13:58:44 <tel> becomes
13:58:46 <tel>     programFindLocation = \verbosity _ -> liftM2 mplus
13:59:09 <NemesisD> oh lol
13:59:52 <tel> it's just immediately calling findProgramLocation which doesn't take that new ProgramSearchPath line… so, as far as I can tell without actually knowing what's going on
13:59:58 <tel> ignoring it is OK (?!)
14:00:10 <NemesisD> tel: i wonder if I should PR with that _ or if that isn't responsible
14:00:19 <NemesisD> either way i think he's gonna need to case off of cabal version
14:00:40 <NemesisD> haskell don't play that variadic function nonsense
14:00:50 <danharaj> you can have variadic functions in haskell
14:00:52 <hpc> t printf
14:00:58 <hpc> :t printf
14:00:59 <lambdabot> PrintfType r => String -> r
14:01:16 <hpc> NemesisD: it not only plays, it wins by stealing the ball and running away
14:01:42 <sm> but it's not very sociable with the other players
14:03:30 <tel> NemesisD I can't really comment on what the right answer is. I've never used Cabal beyond build simple
14:04:42 <tel> but yeah, that's a complete API-breaker. I imagine lots libs will get by without changes because they use the defaults provided by simpleProgram.
14:05:51 <tel> here's a similar PR for postgresql-libpq
14:05:51 <tel> https://github.com/lpsmith/postgresql-libpq/pull/11
14:06:52 <dennis> is there a built in function that can make a list [1, 2, 3 ,4 5, 6, 7, 8] to [[1,2], [3,4],[5,6],[7,8]] ?
14:08:17 <hpc> dennis: no, because you are missing a comma ;)
14:08:38 <hpc> there's a "chunk" function somewhere
14:09:06 <Makoryu> levi: I'm constructing abstract syntax trees from another data structure... Thinking about how to propagate attributes up or down the tree
14:09:25 <hpc> aha! dennis: http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html#v:chunksOf
14:09:38 <NemesisD> i'm encouraged by the fact that bos is still working on other haskell stuff
14:09:41 <Makoryu> Huh. How come that's not on hoogle?
14:10:03 <NemesisD> there hasn't been an update to the mysql package in a while but with the quality of stuff that bos puts out, that could just be that its done and perfect
14:10:17 <hpc> Makoryu: hoogle explictly only searches the platform, apparently
14:10:25 <Makoryu> Oops
14:10:29 <hpc> or something
14:10:32 <hpc> it's kind of weird
14:10:41 <dennis> got it thx :)
14:11:13 <levi> hayoo often indexes stuff that hoogle doesn't.
14:11:16 <geekosaur> only searches bootlibs by default, there's some magic to make it include *specific* platform packages
14:11:18 <geekosaur> this is where hayoo becomes very handy
14:11:40 <NemesisD> i typically have more luck with hayoo's type search too
14:11:42 <hpc> there's been some -cafe talk about expanding hoogle that seems to have gone nowhere
14:11:47 <NemesisD> but hayoo is frequently slow/down
14:11:55 <hpc> and hoogle is catchier
14:12:18 <geekosaur> my recollection is the hoogle dev is working on it when he can, but busy
14:12:19 <levi> Makoryu: There are most likely some interesting approaches to doing that in published papers. I don't know of any off-hand, though.
14:13:30 <NemesisD> that's neil mitchell right?
14:14:06 <johnw> fpcomplete.com/hoogle indexes a lot more
14:14:20 <johnw> geekosaur: I also work on Hoogle sometimes
14:14:37 <NemesisD> duck duck go's !hoogle syntax uses the original
14:14:52 <NemesisD> that could change though if fpcomplete's became the standard
14:15:00 <johnw> plus, it's quite easy to run a local hoogle instance that indexes everything on Hackage
14:15:39 <johnw> also, fpcomplete.com/hoogle should have some of my recent search optimizations, like always preferring exact identifier matches to case insensitive ones
14:15:58 <johnw> i'm not sure when that patch is going to make its way over to the "standard" hoogle
14:16:07 <Tordek> hi
14:16:28 <Tordek> what's the ~ syntax in let ~( fullList , ~( (a, b, c):_ )
14:16:40 <joelteon> irrefutable pattern matches
14:16:40 <johnw> Tordek: it's a lazy pattern match
14:16:48 <johnw> http://www.haskell.org/haskellwiki/Lazy_pattern_match
14:16:52 <Tordek> thanks!
14:17:02 <joelteon> oh, that reminds me of something
14:17:23 <joelteon> if you're trying to pattern match on something, say Maybe Int, that should *never* realistically be Nothing, is it ok to use a lazy pattern match on Just?
14:17:59 <benmachine> joelteon: the words "should" and "realistically", they worry me
14:18:07 <johnw> if it does end up being Nothing, you'll just get your exception later
14:18:15 <joelteon> ok
14:18:19 <johnw> it's pretty much as bad as using fromJust
14:18:39 <johnw> (and functionally is equivalent to it as well)
14:19:05 <benmachine> johnw: it is /very/ slightly better because the exception message will include a source location
14:19:07 <Makoryu> joelteon: If you're doing this in a context where there's *any* kind of error handling available, that's probably preferable
14:22:42 <joelteon> my download speed from haskell.org is 0KB/s
14:22:54 <shachaf> artyomkazak: Please use Applicative, not Monad, for "mapM_"-alikes!
14:25:04 * hackagebot bindings-hdf5 0.1 - Project bindings-* raw interface to HDF5 library  http://hackage.haskell.org/package/bindings-hdf5-0.1 (MauricioAntunes)
14:27:17 <artyomkazak> shachaf: um, what exactly do you mean?
14:28:37 <artyomkazak> (if it would lead to changing the signature of mapM_, then I doubt bytestring folks would be willing to introduce such an inconsistency)
14:29:47 <shachaf> artyomkazak: It's a generalization -- Applicative instead of Monad. Admittedly it's not *strictly* a generalization right now, but it's a shame to introduce a function like that and have it be less useful right away.
14:30:37 <shachaf> Also maybe it matters less for mapM_ than for mapM? But it matters for both.
14:31:23 <S_J> @src mapM
14:31:23 <lambdabot> mapM f as = sequence (map f as)
14:31:29 <shachaf> Did you see the code in lens that edwardk and I wrote?
14:31:29 <S_J> @type mapM
14:31:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:31:37 <S_J> @type sequence
14:31:38 <lambdabot> Monad m => [m a] -> m [a]
14:32:12 <shachaf> (Surely if you're introducing mapM_ you want to introduce mapM as well?)
14:32:16 <Umbrall> I'm wondering. Is there any reason that they nobody made a generic typeclass based monad transformer for the simple composition ones before?
14:32:35 <S_J> > mapM (Just . (+1)) [1,2,3]
14:32:37 <lambdabot>   Just [2,3,4]
14:32:47 <S_J> > mapM (Just . (+1)) [Nothing, Just 5]
14:32:49 <lambdabot>   No instance for (GHC.Show.Show a0)
14:32:49 <lambdabot>    arising from a use of `M703168784.sho...
14:32:50 <shachaf> Anyway, I haven't really looked at your code yet -- I can look this evening.
14:32:59 <shachaf> S_J: lambdabot also responds to /msg.
14:33:02 <Umbrall> Like [], ((,) s), Maybe, (Either l) and all that can just use that instead of making their own transformers
14:33:03 <S_J> > map (Just . (+1)) [Nothing, Just 5]
14:33:04 <lambdabot>   No instance for (GHC.Show.Show a0)
14:33:04 <lambdabot>    arising from a use of `M1837251612.sh...
14:33:15 <S_J> > map (Just . (+1)) [1,2,3]
14:33:16 <lambdabot>   [Just 2,Just 3,Just 4]
14:36:36 <niteria> is there (Show a) => a -> ByteString?
14:37:47 <artyomkazak> First of all, it’s more like “fixing a hole” than introducing a function. Obviously I would be glad if mapM_ was using Applicative instead of Monad, but my primary goal is to have it *in bytestring*, not in YetAnotherMissingFunctionsPackage. Then, I have seen the code in lens, but a) I prefer mapM_ to traverse the bytestring left-to-right and not in some vaguely defined order (actually, even right-to-left would be annoying in some cases); b) to 
14:38:04 <joelteon> niteria: if I'm working with bytestring, I usually define show = pack . Prelude.show somewhere and import it a lot
14:39:48 <shachaf> niteria: How should that work?
14:40:05 <shachaf> joelteon: pack :: [Word8] -> ByteString, so that's a type error.
14:40:17 <joelteon> not if you import Data.ByteString.Char8.
14:40:21 <joelteon> which I usually do.
14:40:36 <shachaf> You shouldn't.
14:40:48 <joelteon> Okay.
14:40:56 <shachaf> It's broken. Experts only.
14:41:02 <joelteon> How do you get a value that can be "show"n into ByteString format?
14:41:17 <shachaf> That depends. What do you want the ByteString to contain?
14:41:30 <joelteon> ...
14:41:57 <shachaf> I mean, there are lots of ways to encode strings into bytes. What are you after?
14:42:12 <joelteon> Ok, let's say UTF8
14:42:19 <monochrom> if I have a value "joy" such that show joy = "你好", what bytestring is that?
14:42:26 <shachaf> OK, then use encodeUtf8.
14:42:43 <shachaf> Or Data.ByteString.UTF8.fromString
14:42:53 <joelteon> Oh, good idea.
14:42:56 <joelteon> ok, point taken.
14:42:59 <joelteon> niteria: don't listen to me
14:43:12 <Umbrall> Yay I just made the impossible happen somehow!
14:43:22 * monochrom always uses his native tongue to confound Americocentric worldviews!
14:43:23 <Umbrall> Kind incompatibility with matching types
14:43:38 <joelteon> hey, American words have accents in them too
14:43:47 <joelteon> like soufflé
14:43:49 <joelteon> :D
14:44:33 <S_J> > return . id =<< Just 7
14:44:33 <monochrom> that still doesn't confound iso-8859-1 which is what Char8 does
14:44:34 <lambdabot>   Just 7
14:44:46 <joelteon> oh, does it?
14:44:52 <joelteon> wow, I've been using the wrong library all this time
14:45:14 <shachaf> Better yet, if you want to represent text, don't use ByteString.
14:45:16 <shachaf> Use Text.
14:45:19 <aristid> joelteon: you thought Data.ByteString.Char8 uses utf-8?
14:45:40 <joelteon> well, I don't use non-ascii characters much so I didn't think of it.
14:45:41 <monochrom> don't feel bad. GHC itself was iso-8859-1-only for a long time.
14:46:09 <monochrom> it is why Char8 existed in the first place. to fit GHC at that time.
14:46:12 <dennis> Next question... is it possible to get more digits in ghcis +s option?
14:46:17 <stolaruk> How can I use a function of type IO String -> IO String to map over IO [String] ?
14:46:19 <niteria> well, who uses show for anything other than debugging
14:46:19 <Makoryu> joelteon: I'm gonna send you stuff in CP437 and we'll see what happens...
14:46:25 <joelteon> Makoryu: no, thanks
14:46:42 <monochrom> I use show on Int etc and it is not debugging
14:47:40 <Saizan> stolaruk: f :: IO String -> IO String is kind of unusual, but mapM (f . return) =<< m should work
14:47:50 <Saizan> stolaruk: where m :: IO [String]
14:48:05 <shachaf> Saizan: That has the right type but perhaps it doesn't match the intent of f :: IO String -> IO String
14:48:07 <stolaruk> ok thanks
14:48:12 <niteria> ok, nevermind, I'm glad I asked anyway, I was going to use pack
14:48:20 <Saizan> shachaf: yeah
14:48:33 <joelteon> yeah
14:48:33 <joelteon> phew, that was a close one
14:48:33 <Saizan> stolaruk: what is this IO String -> IO String function?
14:48:51 <stolaruk> Well it isolates part of a string. I'm stuck in the IO monad
14:49:19 <Makoryu> stolaruk: It's really IO String -> IO String? Not String -> IO String or IO (String -> String) or something?
14:49:29 <Saizan> can you make it String -> IO String? that'd be more usual, otherwise it looks more like a control structure
14:49:48 <stolaruk> Saizan: yeah maybe
14:50:05 * hackagebot rss2irc 1.0.4 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.4 (SimonMichael)
14:53:41 <dennis> arhhh.. Haskells lazyness is killing me -.- i want to do some performance tests. is it possible to force an evaluation of a structure but omit outputting it on console?
14:53:55 <ReinH> What's the complexity of Data.List.union? nm or n+m?
14:54:28 <dmwit> dennis: Take a look at the "criterion" package.
14:54:39 <dmwit> It has good documentation about dealing with laziness in performance testing.
14:54:50 <ReinH> And what should I use if I want to improve that? Data.Set?
14:55:23 <dmwit> dennis: However, to answer your direct question: yes, it is possible. e.g. something like main = complicated `seq` return () will do no work but will force "complicated" into WHNF.
14:55:34 <dmwit> s/do no work/produce no output/
14:56:06 <Makoryu> ReinH: Looks like it'll be O(n * m)
14:56:11 <ReinH> Makoryu: that's what I thought
14:56:13 <ReinH> Actually, I can't use Set in this case, I need ordering.
14:56:14 <Makoryu> Linear search and all
14:56:27 <ReinH> Is there a structure that gives me O(n+m) union *and* ordering?
14:56:54 <ReinH> or at least n log m?
14:57:17 <ReinH> That would be easier than making my algorithm smarter so I can avoid the union. Which I am not smart enough to do. :/
14:57:19 <Makoryu> If you need to preserve ordering, consider annotating the list (zip [0..] xs) then running it through a Set
14:57:23 <dmwit> ReinH: \xs ys -> filter (`Set.elem` Set.fromList ys) xs -- ?
14:57:31 <Makoryu> I'm sure there's a smarter way but...
14:57:38 <Makoryu> Or that
14:57:55 <ReinH> dmwit: right
14:58:04 <ricree> any advice on fixing linker errors with ffi? I'm getting an undefined reference error even though I'm pretty sure I have the right pkgconfig-depends in my .cabal file
14:58:08 <ReinH> well, let's see how much of a problem this is before I start prematurely optimizintg
14:58:12 <ReinH> thanks :)
14:58:31 <ricree> is there something else I need to be adding here so that it actually finds the library?
14:58:41 <dmwit> Makoryu: If all the indices are unique... what's Set going to do? =P
14:59:08 <ReinH> dmwit: I'm worried that the increased overhead outways the asymptotic speedup there for my use case. Will keep in mind though.
14:59:13 <dmwit> ricree: I don't know how to help. But I bet anybody who does will need to see the exact error.
14:59:16 <dmwit> ?hpaste
14:59:17 <lambdabot> Haskell pastebin: http://lpaste.net/
14:59:43 <Makoryu> dmwit: See, if you let me take this to its logical conclusion, I'd be dragging around newtypes and writing new Ord instances
14:59:54 <dmwit> right
14:59:56 <dmwit> very annoying =)
15:01:16 <ReinH> Makoryu: yeah, let me stop you right there...
15:01:49 <hpaste> ricree pasted “FFI Linking Error” at http://lpaste.net/92619
15:15:54 <ricree> Anyone able help with an FFI linking issue I'm having? http://lpaste.net/92619
15:16:06 <ricree> feels like it's something simple I'm missing, but I'm not sure what
15:16:52 <mouseAnonEEsq> did you tell cabal to include the c object?
15:17:26 <FreeFull> My distro has a new version of xmonad but no corresponding xmonad-contrib for it ):
15:18:15 <ricree> mouseAnonEEsq: I thought pkgconfig-depends took care of that. What else do I need to add?
15:21:46 <mouseAnonEEsq> ricree: I'm far from an expert, but the linker doesn't like something about this: "static ganv/canvas.h ganv_canvas_new"
15:22:50 <mouseAnonEEsq> ricree: which doesn't really help you, since that's what the error says.. eh
15:23:18 <tel> Is there a good workaround to cabal hell when both transformers and List take the Control.Monad.Trans.List module?
15:23:43 <tel> In particular, cabal install transformers List; cabal install semigroupoids fails
15:24:21 <mouseAnonEEsq> ricree: check the header; also, I don't know why you have static in your ffi declaration
15:25:39 <Clint> tel: don't use List?
15:26:01 <levi> tel: Do they have version constraints that *really* conflict, or is it just not finding a common version?
15:26:16 <tel> Clint I'm trying to use Hexpat—I suppose I could try to convince them to drop List, but that's likely not going to work
15:26:38 <tel> levi I'm trying a few experiments to see what causes the failures most consistently.
15:27:05 <ricree> mouseAnonEEsq: thanks for taking a look at it
15:27:09 <monochrom> no no, the linker won't see "static ganv/canvas.h ganv_canvas_new" at all
15:27:38 <levi> tel: Did you try installing them both with the same cabal command?
15:27:53 <tel> levi doing that currently
15:28:00 <tel> annnd, just failed
15:28:06 <tel> cabal install transformers List semigroupoids
15:28:10 <tel> src/Data/Functor/Bind.hs:62:1:
15:28:11 <tel>     Bad interface file: /Users/tel/Dropbox/proj/hs/zalora/.cabal-sandbox/lib/Control/Monad/Trans/List.hi
15:28:11 <tel>         Something is amiss; requested module  transformers-0.3.0.0:Control.Monad.Trans.List differs from name found in the interface file List-0.5.1:Control.Monad.Trans.List
15:28:11 <tel> Failed to install semigroupoids-3.1
15:28:19 <madjestic> is there a recommended way to obtain an auto-complete dictionary for haskell? (emacs)
15:28:28 <ricree> monochrom: why's that?
15:28:45 <mouseAnonEEsq> well there's always cabal-dev
15:28:59 <levi> mouseAnonEEsq: That's not likely to help in this case, unfortunately.
15:29:08 <tel> yeah, this is sandboxed already
15:29:11 <levi> mouseAnonEEsq: And the new cabal has cabal sandbox!
15:29:57 <Saizan> tel: sounds like a bug
15:30:13 <tel> Saizan whose, though? :)
15:30:27 <Saizan> tel: since List is not a dependence of semigroupoids it shouldn't matter what modules it exports
15:30:32 <levi> It's the problem that two packages are providing different versions of the *same* module name.
15:30:44 <epta> Is there a way to use cabal sandbox dir with runhaskell?
15:31:00 <tel> Saizan so, Cabal
15:31:05 <monochrom> because GHC User's Guide says so
15:31:43 <Saizan> levi: the toolchain has handled that fine in the past
15:31:51 <levi> tel: There is a GHC extension that lets you specify which package to import a module from. You may be able to use that to coerce things into building.
15:31:57 <Saizan> levi: as long as you didn't depend on both packages at the same time
15:32:31 <levi> Saizan: I ran into it a few months ago when I played around with Fay.
15:32:38 <Saizan> tel: which version of cabal are you using? i can't reproduce with mine
15:32:46 <tel> Saizan I'm top-level depending on lens <- semigroupoids/transformers and hexpat <- List
15:33:26 <tel> Saizan, oh, weird. I thought it was 1.18 but I'm picking up 1.17 instead. That's probably the problem.
15:33:33 * tel goes PATH diving
15:33:42 <Saizan> tel: still, it shouldn't fail when building semigroupoids as your error seems to be suggesting
15:35:22 <tel> Saizan I'll rebuild 1.18, make sure I'm using it, and try again.
15:35:34 <lroca88> Hi there friends, I need to know if there are a site to training haskell, with problems, and solutions, something like http://cerberus.delos.com:790/usacogate
15:36:16 <levi> lroca88: School of Haskell has a bunch of tutorials, and some of them have exercises that you can do, but it's not really quiz-like.
15:37:43 <levi> I am working (slowly) on putting together a quiz/exercise based site, but I am not yet very far along.
15:38:00 <leroux> lroca88: Maybe you'll find something here https://gist.github.com/leroux/6395804
15:38:03 <mouseAnonEEsq> what sort of "training"?
15:38:11 <leroux> lroca88: Exercism.io ?
15:38:25 <lroca88> I'm looking for something like USACO, but for haskell, that put competitions, and problems to solve, this problems are tested by the server that has the problems
15:38:41 <lroca88> Thanks leroux and levi
15:38:52 <leroux> lroca88: https://www.hackerrank.com/ <-- they support haskell, I think...
15:38:57 <mouseAnonEEsq> google has a giant list of problems + mechanisms for checking them
15:39:18 <mouseAnonEEsq> https://code.google.com/codejam/
15:39:22 <mouseAnonEEsq> but not
15:39:26 <mouseAnonEEsq> haskell exclusively
15:40:29 <mouseAnonEEsq> I guess giant is an exaggeration
15:40:53 <artyomkazak> mouseAnonEEsq: spoj.pl has a list hundred times as giant and they also support Haskell. I doubt it’s what lroca88 was asking for, though
15:44:44 <DigitalKiwi> http://www.haskell.org/haskellwiki/Programming_contests ?
15:44:50 <ocharles> mm_freak: new implementation looks interesting
15:45:05 <lroca88> well in github a saw a topic about daily haskell excercises thats maybe work
15:45:21 <lroca88> https://gist.github.com/leroux/6395804
15:45:34 <leroux> Yep.
15:45:58 <ParahSailin> lol is this the first challenge? https://www.hackerrank.com/signup
15:46:15 <ParahSailin> or it loads now
15:46:50 <DigitalKiwi> i was expecting a captcha on the lines of the one for arch linux forums...
15:47:11 <ParahSailin> DigitalKiwi: it was just a ruby stack trace the first time i hit it
15:47:15 <DigitalKiwi> What is the output of "date -u +%V$(uname)|sha256sum|sed 's/\W//g'"?
15:47:45 <DigitalKiwi> which is a fun to solve problem if you don't yet have a working linux... :/
15:47:52 <DigitalKiwi> for some levels of fun :|
15:48:08 <DigitalKiwi> s/levels/definitions/
15:49:40 <levi> Hackerrank does look pretty cool, aside from being a bit slow.
15:51:15 <DigitalKiwi> ParahSailin: your nick is making me confused :<
15:52:20 <lroca88> Another question, I' looking the book haskell the craft of functional programming 3rd edition, can you provide me a link to download it for free. I'm cuban, i haven't money sorry ):
15:52:51 <haasn> artyomkazak: b-but do they have all of hackage? I ain't writing any code without Control.Lens
15:52:58 <Maior> lroca88: learnyouahaskell.com is free online
15:53:05 <shachaf> haasn: Write your own lens!
15:53:22 <haasn> shachaf: but there's a big difference between writing my own lens and writing my own Control.Lens :(
15:53:33 <edwardk> haasn: heh
15:53:38 <shachaf> How much functionality does a minimal lens replacement need?
15:53:44 <edwardk> shachaf: about 8 lines
15:53:49 <shachaf> I bet you could fit it in a few KB.
15:53:50 <leroux> lroca88: That link I linked you to has some good resources.
15:53:56 <leroux> Like learn you a haskell and real worl haskell.
15:53:58 <shachaf> edwardk: Not *that* minimal.
15:54:00 <leroux> world*
15:54:02 <lroca88> yeap but I see that the book I'm looking for is used by Universities of first world
15:54:19 <leroux> You shouldn't base your decision off that.
15:54:34 <haasn> shachaf: it would be interesting to see a version of all the lens functions written in a way that they require as few dependencies on other lens functions as possible, so you can just copy/paste the ones you need
15:54:40 <leroux> If you want coursework, it's also on that gist.
15:54:49 <shachaf> haasn: That's how lens is already written. :-(
15:55:10 * DigitalKiwi is reminded of someone "I'm a poor college student. All my money goes to computers and internet so that I can pirate books for school" and I'm like "wat...I can remember when we needed to buy tree form books..."
15:56:16 <artyomkazak> haasn: I don’t know of any site with competition-style problems which offers *anything* but pure ghc.
15:56:41 <DigitalKiwi> they also hadn't heard of dewey decimal....
15:59:08 <ReinH> edwardk: ping!
15:59:30 <edwardk> pong
15:59:50 <ReinH> edwardk: I have *significantly* improved the average case performance of my dijkstra map algorithm!
16:00:05 <edwardk> yay!
16:00:28 <edwardk> trying to figure out if i can make valid instances of 'Cons' and 'Snoc' for all my folds
16:01:48 <edwardk> arguably not because they have kind of dual semantics
16:01:51 <edwardk> but syntactically yes
16:02:40 <ReinH> edwardk: I compute an ordering to traverse the map breadth-first from a starting coordinate
16:02:57 <ReinH> edwardk: then I fold over the ordering, computing the distances for cells as I go
16:03:23 <ReinH> this doesn't guarantee a solution, but it is a fixed point of the solution
16:03:30 <ReinH> so I just reapply until it converges on the solution
16:03:52 <ReinH> which is the same as I was doing before but now the heuristic search has much, much better asymptotics in almost all cases
16:04:33 <ReinH> for many maps it'll find all but a few distances on the first search so it only needs a few runs before it converges
16:05:15 <lroca88> Ok, I will start with the book of Miran lipovaka, do you think that is a good idea??, However if you know about link of haskell the craft of functional programming 3rd edition for free, let me know please
16:06:01 <levi> lroca88: You really don't need a specific book to learn haskell.
16:06:06 <elliott> haasn: we explicitly do that.
16:06:07 <elliott> unfortunately.
16:06:57 <ocharles> ReinH: is your code public anywhere?
16:07:58 <ReinH> ocharles: I can throw it on githubs
16:08:08 <ReinH> I'm just organizing a bit now
16:08:24 <lroca88> Well, I need to start with my first book of haskell, and I asking you information about the good ones
16:13:17 <Zenol> lroca88: Real World Haskell or Lear You a Haskell.
16:15:54 <Zenol> lroca88: probably the first one if you knows a bit about fp. And if you know a bit about lisp/scheme take a look at Write Yourself a scheme in 48h. (Those 3 books can be read online. The first two was published).
16:16:04 <spaceships> lroca88: learn you a haskell if you haven't played with functional languages before, RWH if you have
16:17:54 <lroca88> I haven't play before with functional languages, but is interesting to learn about which of this language is more extensively used in world?
16:18:08 <ReinH> edwardk: I'm going to get some benchmarking going with criterion
16:18:13 <ocharles> ReinH: yea do - i am making a pacman game so i think i could make use of this
16:18:36 <ocharles> assuming i've understood that you are doing path finding
16:19:38 <ReinH> ocharles: I am doing a variation of path finding, yes
16:20:03 <ReinH> ocharles: a "dijkstra map" is a map where each cell is numbered with the minimum distance from that cell to a given target(s)
16:20:11 <ReinH> I'm writing a version for one target
16:20:34 <ReinH> ocharles: so a dijkstra map of the player's current location, for example, would be a map where each square is the number of moves it takes to get to the player
16:20:39 <ReinH> I'm using a chessboard metric
16:20:56 <Zenol> benchmarking a pacman?!
16:21:18 <ocharles> ReinH: gotcha
16:21:24 <edwardk> Zenol: more like a pathfinder for a pacman/rogue-like clone
16:22:27 <Zenol> oh, ok. Was trying to imagine how you can benchmark this poor cheese ^^
16:23:26 <Zenol> chessboard metric? is it manhatan metric?
16:24:40 <haasn> Zenol: I benchmark fizzbuzz
16:25:11 <edwardk> chessboard metric is number of moves required by a king in chess. so you can make diagonals
16:25:20 <edwardk> @google chebyshev distance
16:25:21 <lambdabot> http://en.wikipedia.org/wiki/Chebyshev_distance
16:25:21 <lambdabot> Title: Chebyshev distance - Wikipedia, the free encyclopedia
16:25:49 <Zenol> haasn: You know that I learned what fizzbuzz was after reading your messages here? (I never played this game)
16:26:00 <ReinH> Zenol: aka chebysh.... yes right
16:26:06 <edwardk> Zenol: fizzbuzz is a common interview question
16:26:08 <ReinH> edwardk: thanks :)
16:28:02 <Zenol> edwardk: you mean for recruitment?
16:28:23 <edwardk> Zenol: yeah
16:28:30 <Zenol> (and thanks for the chebyshev distance :) didn't know this one )
16:28:31 <Maior> http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html
16:28:52 <shachaf> Journalists sometimes ask it too but it usually doesn't go very well.
16:29:03 <DigitalKiwi> http://vincentsanders.blogspot.com/2010_06_01_archive.html hehe
16:29:09 <dolio> I got asked stuff about fizzbuzz for my current job.
16:30:06 <dolio> It wasn't 'implement fizzbuzz' though.
16:30:08 <hpc> i got asked to describe my home network
16:30:13 <tabemann> what annoys me at jobs, though, is when they ask *language specific* questions
16:32:12 <DigitalKiwi> tabemann: make a memory leak in java
16:32:13 <tabemann> (one should be able to learn any language needed, and it should not be assumed that one necessarily has to know a given language ahead of time to be able to program in it)
16:32:45 <hpc> tabemann: i got asked language questions as an "are you lying on your resume" kind of check
16:33:21 <hpc> so they were roughly along the lines of "how does multiple inheritance work in java", and "how do lambdas work in python" and "what the fresh hell is haskell?"
16:33:35 <tabemann> what annoys me is .NET jobs asking C#-specific questions, when I know I am fully capable of programming in C# but just have never had to at a previous job
16:33:45 <tabemann> hah
16:34:07 <tabemann> DigitalKiwi: define "memory leak"
16:35:01 <hpc> oh man, that reminds me of my favorite double-trick question about java and destructors
16:35:06 <hiptobecubic> hpc, I was asked what a monad is
16:35:09 <tabemann> hah
16:35:27 <hiptobecubic> tabemann, places like that usually aren't where you want to be anyway
16:35:45 <tabemann> hiptobecubic: unfortunately, a lot of places here around the Milwaukee area are C# shops
16:35:52 <DigitalKiwi> memory which is retained but will not be freed and cannot be accessed
16:36:01 <hiptobecubic> unless it's like a C# consultancy shop that requires unnormal expertise
16:36:06 <tabemann> and most of the ones are either Java shops or are embedded places where they program in C
16:36:06 <hpc> because java calls them "finalizers", and they aren't guaranteed to run
16:36:10 <Zenol> hiptobecubic: Then you enswered and endomorphisme? :D
16:36:21 <DigitalKiwi> note: people think you can't have it in java; you can have it though if you really try
16:36:22 <Zenol> answered, andormorphism...
16:37:10 <Zenol> DigitalKiwi: Have you an example ? (not using native libraries)
16:37:16 <hiptobecubic> tabemann, i don't mean C#, i mean doesn't understand in the relationship between programming and programming languages
16:37:16 <tabemann> you really should have done the fake Wadler quote
16:37:26 <hiptobecubic> particularly when they are practically clones
16:37:40 <tabemann> s/the ones/the ones that aren't
16:37:44 <tabemann> hiptobecubic: exactly
16:38:11 <hiptobecubic> Zenol, well.. it's kind of like a chocolate burrito train, traveling backwards through time, only instead of meat it has radioactive waste....
16:38:12 <DigitalKiwi> short answer: "custom class loaders" long answer: http://plumbr.eu/blog/12-year-old-bug-in-jdk-still-out-there-leaking-memory
16:38:39 <tabemann> DigitalKiwi: I do not specialize enough in Java to be aware of that one
16:38:53 <DigitalKiwi> brb
16:39:55 <Zenol> DigitalKiwi: So the GC isn't doing it's job?
16:40:16 <hiptobecubic> maybe there's a reference saved somewhere
16:40:57 <monochrom> w00t. I wrote a custom class loader once. for auto-grading student code, ensuring that their code can't use any other class (one of the things a custom class loader can impose)
16:45:52 <niteria> @type unpack
16:45:52 <lambdabot>     Not in scope: `unpack'
16:45:53 <lambdabot>     Perhaps you meant one of these:
16:45:53 <lambdabot>       `BS.unpack' (imported from Data.ByteString),
16:46:02 <niteria> @type BS.unpack
16:46:03 <lambdabot> BSC.ByteString -> [Word8]
16:46:32 <niteria> how that relates to http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html#v:unpack ?
16:46:32 <hpc> monochrom: i love the things people come up with for grading CS students
16:47:59 <monochrom> oh, it's definitely an arms race of fighting CS tricks by more CS tricks :)
16:50:15 <haasn> grade them based on how many ‘lens’ functions they use
16:50:21 <haasn> but don't tell them this
16:50:36 <dolio> No, you tell them that.
16:50:51 <dolio> But you don't tell them whether using lens functions is good or bad for their grade.
16:51:02 <monochrom> haha
16:51:18 <niteria> there was this question on my exam that asked if there is a turing machine outputing number of states it has, teacher wanted us to use some fixpoint theorem, but you could cheat by making small machine outputing big number and add some irrelevant states :D
16:51:26 <ReinH> edwardk: ping
16:51:35 <edwardk> Pong
16:51:51 <ReinH> edwardk: what fixed point combinator did I just reinvent here and what can you tell me about it?
16:51:54 <ReinH> goFixed f g = until (\g -> f g == g) f g
16:51:58 <monochrom> who knows, it may be a non-monotonic function. use 10 times -> 10 marks. use 20 times -> 90 marks. use 30 times -> 10 marks again.
16:52:46 <edwardk> Well, it computes a fixed point. ;)
16:52:50 <ReinH> edwardk: thanks :)
16:53:02 <hiptobecubic> ReinH, i think that one is as plain as they get
16:53:21 <ReinH> hiptobecubic: yeah, I'm just wondering what the prior art is
16:53:33 <ReinH> edwardk: it does make these heuristic approximation algos nice to write though:
16:53:35 <ReinH> resolve c g = goFixed (resolveApproximate c) g
16:53:41 <hiptobecubic> probably euler. everything is euler.
16:53:45 <ReinH> hiptobecubic: confirm
16:53:56 <edwardk> It gets popped out from time to time. Has no fancy name, it is a fixed point using value equality
16:53:58 <ReinH> edwardk: also what is the proper name for algorithms like this?
16:54:19 <ReinH> and can I prove anything about their termination?
16:54:20 <ReinH> etc?
16:54:33 <monochrom> consider "the classical fixed point search algorithm"
16:54:46 <edwardk> You usually need something meta to say such a fixed point exists
16:55:12 <edwardk> That depends on f, and your initial conditions
16:55:18 <ReinH> edwardk: what I should say is: under what circumstances can I prove that it will terminate?
16:55:19 <hiptobecubic> if g is in the codomain of f and (iterate f) is ergodic and... and...   I'm just rambling here.
16:55:25 <ReinH> isomorphic f, for instance
16:55:27 <monochrom> it is, in fact, very unlikely to terminated. you need very special f for termination, and the proof depends on actual f.
16:56:03 <ReinH> I might write a safe version that kicks out after n attempts just in case
16:56:07 <elliott> ReinH: that implementation is bad.
16:56:09 <elliott> it wastes work
16:56:34 <ReinH> elliott: how so?
16:56:41 <elliott> inline until
16:56:43 <edwardk> ReinH: Depends on the algorithm, conditions on the matrix you have may keep it from being Markov so you might not be able to find, say the fixed point of a transition matrix
16:56:50 <ReinH> elliott: aside from that? :)
16:56:50 <elliott> then ask again :)
16:56:51 <monochrom> but you can go tautological! "f has an attracting fixed point, and the initial value is in the region of convergence".
16:56:58 <elliott> no, I mean inlining until will show you.
16:57:06 <ReinH> monochrom: yep :)
16:57:07 <edwardk> monochrom: :)
16:57:09 <hiptobecubic> monochrom, :)
16:57:22 <hiptobecubic> my favorite proofs
16:57:26 <monochrom> actually, that is not entirely tautological, because it is not a necessary condition.
16:58:05 <ReinH> elliott: ok, consider: goFixed f g | f g == g  = g | otherwise = goFixed f (f g)
16:58:18 <edwardk> Reinh basically you're hill climbing
16:58:23 <monochrom> the other possibility is "the initial value stumbles upon a fixed point, it may be repelling but who cares, you hit the jackpot"
16:58:23 <elliott> ReinH: consider when f g /= g.
16:58:29 <Zenol> and what isn't from euler is from gauss.
16:58:32 <ReinH> edwardk: yes, a hill of possibly infinite height
16:58:47 <elliott> ReinH: in particular, consider what computation the guard requires to check, and then the otherwise branch
16:58:59 <ReinH> elliott: I want to let g' = f g
16:59:07 <elliott> right. that will work
16:59:14 <ReinH> which I actually did in my original version :)
16:59:23 <edwardk> Reinh you're calculating it twice is the point
16:59:30 <ReinH> edwardk: right
16:59:39 <shachaf> foo x f | x f == f = f | otherwise = foo x (x f)
16:59:39 <ReinH> but not any more
17:00:37 <monochrom> shachaf: let e be a group, G be an automorphism of e, and g be e's identity element :)
17:01:56 <Zenol> monochrom: T.T
17:03:51 <monochrom> in fact, why don't we go further. x otherwise f = otherwise f == f = f | foo = x otherwise (otherwise f)  where foo = True
17:05:27 <ReinH> so is this reasonable? https://gist.github.com/reinh/981672f63479bae9ad1f
17:05:59 <monochrom> yes
17:06:15 <ReinH> kk
17:06:49 <ReinH> 2/10 '=' are not aligned.
17:07:07 <hpc> needs more segfault
17:07:58 <Zenol> hpc: then add some insafeCoerce? :)
17:08:00 <monochrom> um, you have a grading bot that grades visual aesthetics? :)
17:08:01 <Zenol> good night.
17:09:27 <ReinH> monochrom: :)
17:09:33 <niteria> can I use forall in instance declarations?
17:09:58 <monochrom> unlikely. but I don't know what you mean.
17:11:30 <benmachine> niteria: why would you want to?
17:11:49 <benmachine> niteria: I can think of a few reasons, and the answers are "you don't need to" or "yes" depending on which one it is
17:11:56 <benmachine> or "I don't know" if it's one I haven't thought of :)
17:12:09 <haasn> note: when you write an instance like “instance Foo (Bar a)” the ‘a’ is implicitly quantified
17:12:16 <haasn> ie. the instance will match for all ‘a’
17:12:18 <monochrom> this is when you start assigning probabilities
17:12:31 <niteria> I'm not sure, "instance Failure e (Handler a b) where" was what I wanted to write
17:12:55 <niteria> for a moment I thought I need "instance Failure e (forall a b. Handler a b) where"
17:13:12 <benmachine> niteria: ah, first category
17:13:13 <monochrom> then what haasn says
17:13:22 <niteria> but turns out I forgot to enable MPTC
17:13:22 <jfischoff> what module is Any in?
17:13:27 <benmachine> hah :)
17:13:33 <benmachine> jfischoff: GHC.Any I think
17:13:37 <monochrom> GHC.Prim, there are others
17:13:37 <jfischoff> ah
17:13:41 <applicat1ve> GHC.Prim i thought
17:13:43 <benmachine> no
17:13:44 <benmachine> I am wrong
17:13:45 <jfischoff> thanks
17:13:50 <benmachine> this teaches me to answer and then check
17:13:56 <benmachine> er
17:14:03 <benmachine> using "teaches" in the colloquial sense
17:14:04 <applicat1ve> data Any a 	-- Defined in `GHC.Prim'
17:14:13 <benmachine> i.e. the exact opposite of its literal sense :/
17:14:18 <elliott> GHC.Exts please!
17:14:27 <elliott> I believe getting Any from Prim is a mistake.
17:15:10 <monochrom> GHC.Exts is better
17:15:19 <applicat1ve> what the heck its doing either of them is a little opaque
17:15:42 <applicat1ve> right next to writeWord8Array# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
17:16:04 <applicat1ve> is where I expect something like Any
17:16:22 <monochrom> GHC.DeepMagic would be best, if I had my way :)
17:16:27 <jfischoff> :)
17:16:42 <applicat1ve> i suppose that is the connecting idea
17:16:45 <applicat1ve> GHC.Occult
17:16:47 <hpc> unsafeImportGHC
17:17:06 <jfischoff> GHC.PHP
17:17:11 <hpc> @hoogle acme-php
17:17:12 <lambdabot> package acme-php
17:17:20 <jfischoff> yeah it should be in there
17:17:41 <hpc> jfischoff: i accept pull requests :D
17:18:01 <jfischoff> oh cool that's yours!
17:19:07 <hpc> jfischoff: i... think i am actually the winner on number of acme-packages right now
17:19:47 <applicat1ve> somehow i cant help now finding https://github.com/jhartikainen/hs-language-php more comical than acme-php
17:20:28 <hpc> applicat1ve: it's useful and therefore automatically less funny
17:20:36 <applicat1ve> though instance Real String is hard to outdo
17:21:06 <applicat1ve> hpc: yes, I have now officially compiled some php with -fllvm
17:21:12 <enthropy> there are about 8 packages providing heredocs on hackage
17:21:43 <applicat1ve> I see, so it's more than the number of implementation of 'beautiful folding'?
17:21:47 <hpc> jfischoff: you also get extra credit for making a pull request that is at least this awesome: https://github.com/headprogrammingczar/php-haskell-prelude/pull/1
17:22:03 <jfischoff> haha
17:22:38 <jfischoff> I work with all these recovering php'ers I need to get them to give me some ideas
17:23:11 <hpc> jfischoff: point them here! i don't have much time to be creatively horrible anymore
17:23:31 <hpc> oh god, i forgot i made the Ntrol category on hackage
17:24:21 <applicat1ve> oh, this acme-microwave is actually helpful
17:25:43 <hpc> bahaha http://hackage.haskell.org/package/acme-lookofdisapproval
17:26:27 <hpc> and http://hackage.haskell.org/package/acme-schoenfinkel
17:26:44 <hpc> hasslich as an alias for unschon is just pure genius
17:27:33 <haasn> whoa, I haven't heard about some of these acme packages before, and I assure you, I regularly go through the Acme section of hackage's package list
17:28:01 <hpc> haasn: i just wrote acme-microwave a week ago
17:28:04 <hpc> not sure about the others
17:28:22 <benmachine> my font doesn't disapprove of me :(
17:28:25 <haasn> I don't get acme-microwave though. My microwave has a rotating dial and each tick increments it by 5 seconds
17:28:43 <haasn> no weirdness involved
17:29:26 <benmachine> I have a microwave like the one featured
17:29:48 <hpc> we're still nowhere near cpan though
17:29:55 <benmachine> I have occasionally put things in it for 1 minute and 90 seconds
17:29:58 <hpc> we need more ridiculousness!
17:30:55 <hpc> haasn: that's actually pretty cool
17:31:30 <haasn> oh, looking through the source demystifies it somewhat
17:31:42 <haasn> do microwaves do that? heh
17:31:53 <hpc> yeah, it's one of their big UI features
17:32:00 <hpc> type in a number, it just works
17:32:14 <hpc> though very few people ever actually trigger the >60 behavior
17:32:39 <niteria> oh, now I get it
17:33:00 <tabemann> http://hackage.haskell.org/package/acme-realworld
17:33:17 <applicat1ve> i think acme-microwave gets the semantics of + wrong...
17:33:34 <haasn> my favorite is still acme-php; especially when you look at the source code and the haddock concurrently
17:34:05 <hpc> haasn: yeah, unfortunately the haddock somewhat spoils things
17:34:11 <hpc> and it doesn't have any jokes itself
17:34:21 <niteria> I'm tempted to create acme-autodestruct, with TH that deletes the current file
17:34:32 <applicat1ve> have you optimized the bubblesort yet?
17:35:44 <pqmodn> why does containers define the Monoid instance for map with mappend = union? isn't this not associative... e.g., fromList [("a",0)] <> fromList [("a",1)] swapping the arguments produces a different result
17:36:29 <pqmodn> i would've expected instance (Ord k, Monoid a) => Monoid (Map k a) with mappend = unionWith mappend, i think
17:36:57 <hpc> applicat1ve: haha, i forgot how terrifying my sort is
17:37:05 <haasn> hpc: introduce a haddock build failure to prevent people from accessing the module documentation, in true PHP style
17:37:28 <hpc> haasn: pull request!
17:37:56 <BMeph_> pqmodn: Associative /= Commutative
17:37:58 <benmachine> pqmodn: you're thinking of commutative
17:38:10 <pqmodn> oh, you're right!
17:38:15 <benmachine> pqmodn: it's associative because there's an unambiguous way to calculate m1 <> m2 <> m3
17:38:27 <benmachine> you take the first value for each key
17:38:41 <benmachine> however, it has been argued that unionWith mappend is more sensible
17:38:55 <niteria> hpc: you need to implement those http://www.quora.com/PHP/What-are-the-most-surprisingly-useful-PHP-functions
17:39:22 <niteria> phpcredits() is crucial to php semantics
17:39:24 <pqmodn> benmachine: thanks, i feel like i should remember by now, but i still mixup those two properties
17:40:18 <haasn> hpc: you need to upload acme-eval
17:41:06 <benmachine> niteria: those are beautiful
17:41:24 * haasn has written eval :: Typeable a => String -> a -- somewhere
17:43:25 <hpc> im still trying to figure out wtf sortBy does lol
17:45:11 <hpc> okay...
17:45:19 <hpc> so if the list is not sorted, it returns the list unmodified
17:45:25 <hpc> if the list is sorted, it doesn't terminate
17:56:16 <mstksg> hpc: sortBy sorts a list with a custom ordering function?
17:56:59 <mstksg> what are you using as your ordering function?
17:57:51 <mstksg> although recognizing who you are i hessitate to insult your intelligence
17:58:59 <Makoryu> mstksg: They were talking about acme-* packages
17:59:23 <Makoryu> Which are jokes, probably
17:59:28 <mstksg> Makoryu: yeah, i see that now haha. please excuse me
17:59:36 <Makoryu> Nah it's all right
18:01:30 <applicat1ve> isn't 90 + 130 = 300 in Microwave?
18:02:24 * applicat1ve is finding this math too hard; it's like Quillen model categories, or Float
18:04:08 <monochrom> hehe
18:05:49 * applicat1ve despairs of writing a patch for acme-microwave and proposes a bug report instead.
18:06:16 <applicat1ve> or an 'issue'
18:06:38 <monochrom> 90+130=300 is right
18:07:25 <applicat1ve> the mind somehow abhors the attempt to implement 90 + 130 = 300, though
18:08:44 <h4199> on my microwave: (1 potato) == 500 does the library handle that as well?
18:08:52 <applicat1ve> haha
18:09:03 <monochrom> 130 is micro wave normal form (MWNF) of 90
18:09:24 <applicat1ve> data Microwave = Potato Int | ... | Lit Int
18:10:31 <Maxdamantus> >> launchMissiles
18:10:37 <Maxdamantus> > launchMissiles
18:10:38 <lambdabot>   Not in scope: `launchMissiles'
18:11:51 <h4199> It gets tricky, because (2 potato) == 730, and I don't even know what (3 potato) is.
18:11:54 <applicat1ve> the question what (1 potato) * (1 frozen dinner) might amount to, is difficult
18:12:13 <h4199> indeed that complicates matters as well
18:13:08 <applicat1ve> we can scrap that, addition seems intuitively clear; first I put it in for 90, then I decide its still cold and put it in for another 130; etc.
18:14:22 <Fuuzetsu> Why is Alternative defined with ‘Applicative f => Alternative f’ and requiring user definitions instead of ‘Monoid f, Applicative f => Alternative f’ where we could lift the functions from Monoid using Applicative by default?
18:14:59 <applicat1ve> Monoid is * -> Constraint; Alternative (* -> *) -> Constraint , to put it that way
18:15:30 <applicat1ve> ie. instance Monoid Maybe where ... is ungrammatical
18:15:42 <Fuuzetsu> Ah, yes, I haven't considered that.
18:15:50 <dwcook> On the other hand, I believe you could create an instance of Monoid given one for Alternative
18:17:01 <edwardk> dwcook: you could, but it isn't always the one you want
18:17:02 <dwcook> Hmm, is there an actual reason Data.Monoid doesn't?
18:17:05 <dwcook> Ah
18:17:18 <edwardk> dwcook: Maybe uses a different Monoid for instance.
18:17:52 <edwardk> also you can't make that instance 'once and for all' without precluding any alternative choices for any type of kind * -> * applied to its argument.
18:18:02 <edwardk> which would be very bad
18:18:16 <dwcook> Ah, I see
18:18:18 <Fuuzetsu> I'm pretty sure Parser doesn't actually form a monoid but it has an Alternative.
18:18:20 <edwardk> e.g Set a forms a nice Monoid, given Ord a, that would be ruled out
18:18:29 <startling> is there a wrapper type for this?
18:18:42 <edwardk> Fuuzetsu: you can always make it be a Monoid, by lifting the definition from its argument
18:18:58 <edwardk> Fuuzetsu: instance Monoid a => Monoid (Parser a) where mempty = pure mempty; mappend = liftA2 mappend
18:18:59 <applicat1ve> i was going to say, it should be a monoid at each type Parser x
18:19:25 <edwardk> now that isn't the only monoid you could make for a parser, so it may not be the right one to pick
18:20:23 <Fuuzetsu> Alright, makes sense.
18:20:23 <startling> newtype Application f a = Application (f a); instance Applicative f => Monoid (Application f a) where mempty = Application mempty; mappend = (<|>);
18:21:17 <arkeet> startling: that exists in lens (internal). it's called Folding
18:21:26 <arkeet> er
18:21:40 <arkeet> never mind.
18:21:43 <applicat1ve> wait you want ..., Monoid a) in there too startling , or am I in a muddle
18:21:55 <edwardk> but it is always an admissable possibility
18:21:58 <startling> oh, should be "Application empty"
18:22:08 <applicat1ve> then Alternative f => ...
18:22:20 <startling> I am all mixed up today.
18:22:25 <startling> applicat1ve, you are correct.
18:22:42 <applicat1ve> that's what i first thought you meant; it was in respond to Fuuzetsu
18:22:53 <startling> It could be useful for e.g. Writing a parser
18:23:27 <applicat1ve> Application Parser a is thus always a Monoid,
18:23:37 <Fuuzetsu> ∎
18:24:47 * startling drinks another coup of coffee.
18:24:56 <startling> um.
18:25:11 <dwcook> The beans are trying to overthrow the throne!
18:25:42 <dwcook> Don't worry, they are mere ground troops.
18:25:47 * startling .oO ( Vive la Revolution! )
18:29:43 <applicat1ve> edwardk: i refreshed the browser and now theres these M folds
18:29:52 <edwardk> M was Reducer
18:30:07 <applicat1ve> oh i see, i hadnt looked there yet
18:30:09 <edwardk> it is a foldMap in amber
18:30:18 <applicat1ve> i like the 'in amber', yes
18:30:22 <edwardk> the comonad for it is _very_ different
18:30:54 <startling> you can extract its dna?
18:30:57 <edwardk> i was talking through the other one with dolio at the office the other day and realized the comonad i had had for Reducer was illegal
18:30:58 <applicat1ve> somehow i have the belief that there is a place for a library just for the original Rabkin type.
18:31:04 <edwardk> startling: yes. that is what the comonad does
18:31:14 <startling> I approve.
18:31:24 <applicat1ve> Tekmo gave up, because wild generalizations occurred to him
18:31:29 <edwardk> the rabkin type?
18:31:33 <applicat1ve> as had happened already to conal
18:31:36 <applicat1ve> yes, L
18:31:39 <edwardk> oh
18:31:45 <c_wraith> a wild generalization has appeared!
18:31:49 <edwardk> when did rabkin write about it?
18:32:33 <applicat1ve> am i in a muddle, isnt the topic 'beautiful folding'
18:32:53 <applicat1ve> http://squing.blogspot.com/2008/11/beautiful-folding.html
18:33:39 <edwardk> ok, so a few months before i started playing with it the first time
18:33:42 <applicat1ve> what convinced me of its strength is seeing that it actually does 'put in amber' some actual things
18:34:07 <applicat1ve> in bos's statistics package, he's forever doing it 'by hand' just a sec
18:34:11 <edwardk> btw- did you notice R, L, and M now have a monad? it is a crappy monad, but it captures the notion of multipass algorithms
18:34:48 <edwardk> so we can define 'median absolute deviation' as a fold for instance.
18:35:24 <edwardk> it'd be better to capture the whole inputs by making something more or less a free monad off the operations we have in Folding
18:35:26 * hackagebot thyme 0.3.0.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.0.0 (LiyangHu)
18:35:30 <applicat1ve> check out every use of 'fini' in https://github.com/bos/statistics/blob/master/Statistics/Sample.hs you see its always exactly the existential type
18:35:35 <edwardk> but its nice that it can exist
18:35:49 <edwardk> yeah
18:35:52 <applicat1ve> he often precedes the definition with his own type definition
18:36:11 <applicat1ve> note also that Foldable is out of the question here
18:36:16 <edwardk> i started working on this because i wanted to make a nice lib with pretty little comonadic HMAC operations
18:36:32 <edwardk> oh?
18:36:38 <edwardk> because of vector?
18:36:39 <applicat1ve> you can use an L for any Foldable and so on; but you can also use it with U.Vector Double
18:36:54 <edwardk> oh in my case i can apply L with any lens-style Fold
18:37:00 <edwardk> so it works fine over U.Vectors
18:37:02 <applicat1ve> classes that make it all about Foldable and so on will make a hash of it
18:37:43 <edwardk> i define a folding in terms of 'runOf' 'prefixOf' and 'postfixOf'
18:38:01 <edwardk> that lets me define folding homomorphisms between the different folding strategies
18:38:26 <edwardk> and it'll let me talk about the benefits of using the right layering of operations in your comonad to avoid polluting the environment
18:38:52 <edwardk> e.g. prefix is cheap on an R, postfix is cheap on an L, both are cheap on M, etc.
18:42:02 <applicat1ve> man i'm not sure about this cabal sandbox; i did cabal sandbox init inside this fold repo and now... yet another installation of the kmett universe!
18:42:15 <edwardk> heh
18:42:24 <applicat1ve> Building bifunctors-3.2.0.1...
18:42:35 <edwardk> i have a few libraries apparently
18:42:50 <applicat1ve> i'm starting to worry about disk space
18:43:21 <S11001001> if you have a problem with a haskell library you should probably email edwardk
18:44:05 <applicat1ve> uhoh build failure src/Data/Fold/Class.hs:5:5:
18:44:13 <applicat1ve>     Ambiguous occurrence `within'
18:44:48 <applicat1ve> one namespace grab is crowding out another!
18:47:21 <applicat1ve> maybe the lens within should be 'innerhalb'
18:47:39 <edwardk> S11001001: =P
18:47:49 <edwardk> applicat1ve: ack do i have a within in lens?
18:47:59 <applicat1ve> it seems so
18:48:08 <applicat1ve>                              (and originally defined in `Control.Lens.Internal.Zipper')
18:48:20 <edwardk> ah
18:48:24 <applicat1ve> but exported by Control.Lens
18:48:32 <edwardk> you're on a normal version of lens that makes sense
18:48:36 <edwardk> i'm building with lens 3.10 here
18:48:39 <edwardk> i'll rename it
18:48:50 <applicat1ve> intra
18:49:16 <applicat1ve> oh, i got lens off hackage, right with cabal sandbox, but not using add-source
18:50:27 * hackagebot clckwrks 0.19.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.19.0 (JeremyShaw)
18:50:29 * hackagebot clckwrks-cli 0.2.7 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.7 (JeremyShaw)
18:50:31 * hackagebot clckwrks-plugin-bugs 0.6.1 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.1 (JeremyShaw)
18:50:33 * hackagebot clckwrks-plugin-ircbot 0.6.1 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.1 (JeremyShaw)
18:51:28 <applicat1ve> uhoh missile attack from greater chicago
18:51:54 <edwardk> applicat1ve: try now
18:52:18 <applicat1ve> bingo
18:53:42 <edwardk> the key to the usability of this i think will be the observation by dolio earlier today that there is a real difference betwen doing run ys . run xs . duplicate  and run xs . extend (run ys) in terms of how things get evaluated
18:54:03 <edwardk> the latter is run xs . fmap (run ys) . duplicate
18:54:08 <applicat1ve> hm, github wont let me withdraw my pull request while Travis CI blah blah
18:54:08 <edwardk> and we want to avoid the fmap
18:54:43 <edwardk> closed
18:54:58 <applicat1ve> oh there
18:55:28 * hackagebot clckwrks-plugin-media 0.5.1 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.5.1 (JeremyShaw)
18:55:30 * hackagebot clckwrks-plugin-page 0.2.2 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.2 (JeremyShaw)
18:55:32 * hackagebot clckwrks-theme-clckwrks 0.3.12 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.3.12 (JeremyShaw)
18:55:42 <edwardk> the reason the fmap is bad is it captures the entire container we would apply until we get around to extracting
18:55:52 <edwardk> but the 'run' on the outside does its work immediately
18:58:02 <applicat1ve> hm, this is complicated. i was worrying about some simpler things. e.g. with Tekmo's L it was all important to get the applicative combinators to inline before anything else happened. then the compiler could perceive the strict left fold in all this; otherwise mud.
18:58:24 <applicat1ve> and things like that.
18:58:41 <edwardk> i mostly just want this for things like resumable hashing
18:58:59 <niteria> what would you use to measure how much time IO action took?
18:59:01 <edwardk> I don't even have the L' type in the repository needed to get decent performance for left folds yet
18:59:40 <applicat1ve> yes, thats more what was in the forefront of my mind, having labored over tekmo's abandoned foldl
19:00:16 <edwardk> fair enough. i'm happy to piggyback on your expertise then
19:00:29 * hackagebot clckwrks-theme-bootstrap 0.2.12 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.12 (JeremyShaw)
19:00:31 * hackagebot clckwrks-dot-com 0.3.1 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.1 (JeremyShaw)
19:00:39 <applicat1ve> its not expertise its, uh , half wit experience
19:00:46 <edwardk> i have a lot of that
19:01:53 <applicat1ve> man the chicago clckwrks attacks keeps coming; i thought the israel lebanon border was the bigger threat to hackage.
19:02:33 <edwardk> i've added you to the repo so you can push fixes directly
19:02:39 <applicat1ve> well, i will try to figure this L M etc out; it will take a little while
19:02:55 <applicat1ve> oh i see yipe
19:02:55 <edwardk> i'm happy to do a walkthru
19:03:12 <edwardk> L is the same as the rabkin fold
19:03:18 <edwardk> its just got a few more instances
19:04:19 <applicat1ve> yes
19:04:30 <edwardk> R is what you get when you flip it around.
19:04:51 <edwardk> M is just making forall m. M (a -> m) (m -> b) (m -> m -> m) m  -- an explicit foldMap
19:05:33 <edwardk> it gets to have an explicit mappend and mempty because i use reflection to turn it into a Monoid for foldMap as needed
19:05:43 <applicat1ve> yes i see
19:05:52 <hpaste> flebron pasted “Why does this not end?” at http://lpaste.net/92621
19:05:57 * applicat1ve senses it will inline better !
19:06:27 <edwardk> L a b is 'Yoneda (Moore a) b)'   so we can borrow the comonad for Moore. Moore a b = Cofree ((->) a) b
19:06:31 <flebron> I can evalState, but it seems I cannot runState (the second part of the tuple never finishes computing).
19:06:31 <edwardk> so the comonad is well known
19:06:37 <enthropy> flebron: take before you sequence
19:07:04 <flebron> Oh, sequence forces everything?
19:07:12 <edwardk> that gives us a comonad that we can use to 'sneak in' before the final 'fini' function gets applied, and capture it as the start of the next fold by duplicating.
19:07:30 <enthropy> flebron: well you're asking for the state after you've run the whole list
19:07:33 <albert> hey everyone, I have a problem: I'm new to haskell, I'm a programmer by hobby (no real training), my real job is not programming related (pilot), and I don't really have a reason to use haskell. I just really, really want to learn/use it. I've read LYAH, some of RWH, and done the first 20 of 99 haskell problems. What do I do now?
19:07:39 <edwardk> the fact that that is what the comonad does wasn't obvious to me at first
19:07:51 <edwardk> i wrote the comonad back in early 2009 and forgot about it for years
19:08:03 <zomg> albert: just do something you think is interesting
19:08:04 <edwardk> it just typechecked, so i figured it was good
19:08:15 <startling> albert: I'd read http://www.haskell.org/tutorial/ and then write something
19:08:26 <applicat1ve> the one for L = Yoneda . Moore so to speak
19:08:32 <edwardk> yep
19:08:38 <flebron> enthropy: Ah, cool :) Thanks!
19:08:48 <edwardk> For M though, if we slavishly applied the same pattern to make a comonad we'd make an illegal monoid to give foldMap!
19:08:56 <edwardk> so I had to look around for another comonad
19:09:21 <albert> that sounds like a good idea
19:09:27 <applicat1ve> this is if M had taken a different form?
19:09:29 <enthropy> @src sequence
19:09:29 <lambdabot> sequence []     = return []
19:09:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:09:29 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:09:58 <edwardk> the comonad for Moore/L can b viewed two ways. it can be viewed as a Store Comonad: (x -> a) x  extended with an environment (x -> b -> x)   and then existentially boxed up to keep you from tampering with the x.
19:10:07 <edwardk> or it can be seen as Yoneda . Moore
19:10:34 <ParaSa1lin> albel727, find some problem that interests you
19:10:38 <edwardk> well, the problem is that if you tried to copy the monad for L/R into M it fails
19:10:48 <edwardk> it'd make you get a new value for the 'zero' for the comonad
19:11:11 <edwardk> so you'd be making folds of trees with other trees growing in the 'cracks' where we'd otherwise be putting mempty!
19:11:37 <edwardk> a whole monoidal result is clearly not mempty for any usable monoid, so we'd be using an illegal monoid everywhere
19:12:10 <edwardk> instead of 'sneaking in before 'fini' and wrapping it up in a new comonad, we were sneaking in before mempty and putting a previous result, which is really really wrong
19:12:27 <albel727> ParaSa1lin: my current problem of interest is why you're talking to me. but it's easy. (note: I'm not albert)
19:12:29 <edwardk> but what we _can_ do is use the fact that (m -> a)   forms a comonad given any monoid m
19:12:35 <edwardk> and in the foldMap case we have a monoid!
19:12:57 <edwardk> the duplicate takes (m -> a)   -> m -> m -> a   by using mappend to glue together the two m's
19:13:01 <edwardk> so that is what we'll do
19:14:01 <edwardk> duplicate (M k h m z) = M (\n -> M (k . m n) h m z) h m z
19:14:49 <applicat1ve> this is why the M module needs this elaborate construction of Tree , N etc
19:15:15 <edwardk> we take M, replacing its 'fini' with a new one that captures the monoid we were going to convert into the output and then give back another copy of M where when it gives _its_ output, we'll mappend it to the one we got the first time
19:15:34 <edwardk> N is used to let us drive foldMap with an arbitrary (m -> m -> m) and m we have in scope
19:15:45 <edwardk> Tree is used to make the Monad for M
19:15:46 <ParaSa1lin> albel727, what problem of interest
19:15:53 <edwardk> the Monad lets us run multi-pass algorithms
19:16:02 <edwardk> its inefficient, but legal
19:16:05 <ParaSa1lin> albel727, erm sorry
19:16:10 <edwardk> i have similar monads for R and L
19:16:25 <edwardk>   m >>= f = R (\xs a -> run xs (f a)) (:) [] <*> m
19:17:11 <edwardk> there what I do is ap something that will capture the entire input stream, so that when i get my answer 'a' i can use it to make a new R, and drive it with the input stream i captured.
19:17:44 <edwardk> Tree is capturing the tree of mappends, injections and mempties from my first pass.
19:18:04 <edwardk>   m >>= f = M (\xs a -> run xs (f a)) One Two Zero <*> m
19:18:19 <edwardk> run can run it because it is a Foldable instance.
19:18:35 <applicat1ve> the monad instances explicitly use run
19:18:59 <edwardk> yeah
19:19:07 <applicat1ve> thats inevitable i think i see
19:19:24 <edwardk> well, it could do it by hand using the m and whatever functions
19:19:31 <edwardk> but i ultimately have to capture something
19:19:35 <edwardk> so i might as well capture it in a Foldable
19:19:40 <edwardk> and use the builtin machinery
19:20:17 <edwardk> an 'explicit' Multipass fold can track a flag of whether it needs multiple passes
19:20:29 <edwardk> and then only capture the stream once
19:20:31 <joe9> http://codepad.org/aen4aA1U . Any thoughts on how I can write showData better, please?
19:20:33 <joe9> I have a list of bytes and I want to show them in groups of 8 each.
19:20:34 <edwardk> and keep replaying it
19:20:42 <edwardk> that may be worth adding
19:21:21 <edwardk> i'm mostly just playing with these to see what shakes loose
19:22:43 <benmachine> joe9: unwords . map printf "0x%02x"?
19:23:29 <applicat1ve> wow, this multipass I haven't looked at before.
19:23:30 <joe9> benmachine: smart, cool. thanks.
19:26:42 <edwardk> the multipass approach? or the multipass package?
19:27:51 <applicat1ve> i was distracted for a second by the package, ignore
19:28:34 <edwardk> np
19:28:37 <edwardk> i wrote that one too =P
19:28:51 <td123> how would I represent a void * when creating bindings to C?
19:29:25 <arkeet> Ptr Void?
19:29:28 <prophile> Ptr () perhaps?
19:29:30 <edwardk> Ptr ()
19:29:33 <arkeet> except Ptr () makes more sense.
19:29:41 <arkeet> I've seen Ptr Void, I guess.
19:30:21 <td123> thanks, that worked
19:30:30 <td123> why does Ptr () make more sense?
19:30:35 <arkeet> because C void is ()
19:31:27 <prophile> Void would correspond to something along the lines of struct A { struct A x; }
19:32:40 <applicat1ve> edwardk: well i will see if i can make progress comprehending
19:32:58 <edwardk> applicat1ve: happy to answer questions
19:34:56 <joe9> benmachine: that worked well. thanks.
19:35:02 <spiridondon> fuck off niggers
19:35:10 <benmachine> @where ops
19:35:10 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
19:35:10 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:35:18 --- mode: ChanServ set +o edwardk
19:35:19 <spiridondon> FUCK YOU!!
19:35:21 <spiridondon> CUNT!!
19:35:22 <spiridondon> CUNT!!
19:35:22 <spiridondon> CUNT!!
19:35:26 --- mode: ChanServ set +o Cale
19:35:33 --- mode: edwardk set +b spiridondon!*@*
19:43:03 <niteria> can I tell cabal to build a static library?
19:43:21 <niteria> s/library/binary
19:43:53 <Fuuzetsu> --disable-dynamic-executable I think?
19:44:09 <Fuuzetsu> --disable-executable-dynamic*
19:53:59 <tel> okay, back to where I was before
19:54:24 <tel> cabal install transformers List semigroupoids fails with Bad interface file: /.../.cabal-sandbox/lib/Control/Monad/Trans/List.hi
19:54:32 <tel> Something is amiss; requested module  transformers-0.3.0.0:Control.Monad.Trans.List differs from name found in the interface file List-0.5.1:Control.Monad.Trans.List
19:54:43 <tel> I'm assuming this is a bug in Cabal 1.18?
19:54:51 <tel> but I'm uncertain
19:55:20 <carter> tel i've been seeing similar thigns lately...
19:55:57 <carter> tel: FILE A TICCKET
19:56:06 <tel> I'm about to
19:56:12 <carter> ok
19:56:14 <carter> link me
19:56:15 <tel> but I'm trying to isolate the error
19:56:17 <benmachine> interesting
19:56:23 <carter> and i'll chime in saying "i've had similar heisenbugs"
19:56:34 <tel> and wanted to be sure it was cabal and not something weird in one of the packages
19:56:40 <tel> carter, cool
19:56:48 <benmachine> that filepath for that interface file looks like it would not handle two modules with the same name from different packages
19:56:50 <tel> I'm downgrading to 1.16 to see if I can replicate
19:56:57 <carter> tel: i thought it was 'cause of my crazy compiler setups
19:57:02 <benmachine> ...1.16 doesn't have sandboxes
19:57:12 <carter> tel replicate it with one version is enough
19:57:24 <carter> 1.18 is enough
19:57:32 <tel> benmachine I just want to see it's a new bug in 1.18
19:57:37 <carter> tel it is
19:57:38 <tel> but I'll go ahead and file
19:57:44 <carter> i never saw it before
19:57:46 <carter> i thin
19:57:57 <carter> can you deterministically repo it with a 1.18 sandbox?
19:58:01 <carter> *repo
19:58:04 <carter> *repro
19:58:17 <benmachine> tel: I mean, it sounds like a bug with sandboxes, so reproducing it with 1.16 would be tricky
19:58:52 <tel> benmachine yeah, I just wanted to isolate it to the sandboxing
19:58:53 <carter> benmachine i've had it happen with my user pkg db
19:59:05 <tel> without having to rebuild the universe too many times
19:59:19 <carter> tel point being: i thought it was an other than cabal problem
19:59:31 <carter> but thaat anyone else has had the problem
19:59:33 <carter> tells me otehrwise
20:01:14 <carter> point being ping me when you post
20:01:20 <carter> so i can say i've had similar issues
20:01:28 <tel> carter: https://github.com/haskell/cabal/issues/1482
20:01:38 <ReinH> edwardk: holy shit Vector is fast.
20:01:42 <benmachine> tel: ...do you actually have a file .cabal-sandbox/lib/Control
20:02:31 <tel> benmachine I rmrf'd it, so I'll check shortly
20:03:26 <tel> benmachine yup, those files all get generated
20:03:41 <benmachine> tel: hm.
20:04:30 <benmachine> tel: I think they should be packaged into per-package directories
20:04:41 <benmachine> what does your .cabal-sandbox/lib folder look like?
20:04:45 <ReinH> holy fast, Batman
20:05:06 <tel> hm, that absolutely isn't happening, heh
20:05:33 <carter> ReinH vector is designed to be fast
20:06:24 <Fuuzetsu> is it fast or is it holy hell what is this magic FAST?
20:06:32 <carter> Fuuzetsu only the former
20:06:50 <carter> though with some work you can give fortran a run for its money with clever haskell
20:07:00 <carter> but takes a bit of work beyond what libs like vector help you with
20:07:11 <benmachine> tel: so uh, where are you putting this sandbox?
20:07:27 <tel> benmachine in the project directory
20:07:37 <tel> should it be somewhere else?
20:07:39 <benmachine> tel: is it a publically available project?
20:07:40 <carter> i imagine its: mkdir name ; cd name ; cabal sandbox init
20:07:56 <carter> and then cabal install List ; cabal install otherlib
20:08:03 * carter and that triggers the error right?
20:08:04 <tel> benmachine well, this is me isolating the bug… but see if you can sandbox install hexpat-lens
20:08:05 <carter> and that triggers the error right?
20:08:06 <benmachine> carter: why tax your imagination when the answer is right here :P
20:08:43 <benmachine> tel: okay, I'm doing that
20:08:45 <tel> benmachine I built hexpat-lens in a different sandbox… so it's not that it's impossible to install all of this stuff together and have it play nicely
20:08:54 <tel> but that sandbox installed lens well before hexpat
20:09:13 <tel> it's only when semigroupoids tries to build atop transformers + List that the bug triggers
20:09:15 <carter> it worked
20:09:21 <carter> tel add that to the ticket
20:09:24 <tel> yeah
20:09:25 <tel> just about to
20:09:27 <carter> kk
20:09:34 <carter> i'll leave this in your hands
20:09:36 <carter> :)
20:09:54 <benmachine> tel: sorry, I'm still stuck somewhere, what do you mean by a fresh sandbox in your ticket?
20:10:39 <benmachine> tel: do you mean you have some pre-existing project and you've just freshly done cabal sandbox init, or do you mean you've freshly created a project
20:10:42 <benmachine> or what
20:10:51 <tel> as in the install command is directly done after `cabal sandbox init`
20:10:58 <benmachine> right, ok
20:11:16 <benmachine> but you're installing things unrelated to the actual package so in principle that shouldn't matter
20:11:52 <tel> I'm replicating the bug by installing only the 3 packages which seem to together trigger it
20:11:55 <carter> which shouldn't matter?
20:11:57 <carter> yeah
20:12:01 <carter> the point is the bug exists
20:12:06 <carter> and should be documented
20:12:11 <tel> but when I do a `cabal install --only-dependencies` on the package itself it fails as well
20:12:12 <carter> with steps to reproduce
20:12:18 <benmachine> tel: right
20:12:28 <benmachine> carter: it already is documented, I'm trying to reproduce it
20:12:28 <carter> i've had this bug happen
20:12:30 <carter> ok
20:12:32 <carter> yeah
20:12:38 <carter> how many cores does your machine have tel?
20:12:44 <carter> and what os?
20:12:53 <carter> and which ghc version
20:12:56 <carter> document all the things
20:13:12 <benmachine> tel: I just successfully ran 'cabal install transformers List semigroupoids' in a fresh sandbox
20:13:20 <benmachine> tel: do you use parallel builds?
20:13:22 <carter> benmachine its a heisenbug
20:13:34 <carter> i've had it hapepn to me
20:13:39 <carter> but i thought it was due to other things
20:13:52 <benmachine> carter: I didn't ask you
20:13:56 <carter> ok
20:14:05 <tel> benmachine nope, it's singlethreaded
20:14:14 <tel> bizarre
20:14:16 <benmachine> tel: ok, I'm trying again with --jobs=1
20:14:16 <carter> huh
20:14:30 <tel> benmachine wait, is the default to use all my cores?
20:14:36 <tel> I'm not specifying jobs
20:14:42 <benmachine> tel: if you set it in your .cabal/config
20:14:45 <tel> ah, nope
20:14:58 <benmachine> I have jobs: $ncpus  in there
20:15:06 <benmachine> it makes things substantially faster
20:15:11 <benmachine> I just failed to reproduce again
20:15:16 <tel> benmachine odd
20:15:25 <benmachine> maybe this is down to differences in our user package databases
20:15:31 <carter> tel: add your cabal convfig to the ticket?
20:15:35 <tel> so, if I explicitly force the build order to be lens -> hexpat it runs
20:15:38 <tel> works
20:15:44 <carter> ok
20:15:57 <benmachine> tel: are you missing a `cd fresh` from your bug report?
20:16:03 <benmachine> er
20:16:04 <benmachine> your comment
20:16:38 <tel> er
20:16:38 <tel> yes
20:16:40 <tel> : )
20:17:27 <benmachine> tel: it might be a good idea to reproduce with -v3 and attach that
20:17:34 <benmachine> even though it'll probably be a wall of text
20:17:52 <tel> the cabal config is actually bog standard as well. I rebooted my whole universe earlier today because I was stuck on 1.17
20:17:59 <tel> benmachine: I'll do that
20:18:18 <benmachine> put it in a gist or something maybe
20:18:39 <benmachine> in some way prevent it taking five minutes to scroll down to the bottom of the bug report :P
20:19:24 <tel> : )
20:19:31 <tel> -v3 is really quite verbose
20:19:39 <benmachine> yeah
20:19:45 <tel> sometimes when programs say they're verbose, they're just talking large
20:19:53 <benmachine> but there is some useful stuff that doesn't show up at -v2 I think
20:19:59 <tel> cabal is right now making a 30 mb file for me :)
20:20:04 <benmachine> hah
20:20:09 <benmachine> impressive :P
20:20:20 <benmachine> okay maybe try -v or -v2 first
20:21:44 <tel> hah
20:21:45 <mstksg> are there any alternative frameworks for composing effects to monad transformer stacks?
20:22:02 <tel> actual size: 20kb
20:22:06 <tel> which is still quite impressive
20:22:15 <ReinH> edwardk: ping
20:22:17 <tel> I'm just glad I'm not still installing all of lens
20:22:23 <benmachine> mm
20:24:22 <benmachine> tel: it looks like the default .cabal/config nowadays /does/ enable parallel builds, fwiw
20:24:28 <benmachine> possibly I mean concurrent builds
20:25:18 <tel> benmachine hm, I guess that's actually true, I'm using Cabal 1.16's default config, not 1.18. I initialized cabal in order to upgrade
20:25:28 <tel> maybe I should wipe that config and try again
20:25:39 <benmachine> tel: don't wipe it!
20:25:44 <benmachine> just move it somewhere it won't be used
20:25:50 <benmachine> we need it in case the bug goes away without it :P
20:26:04 <tel> well, heh, it truly is default cabal 1.16
20:26:12 <tel> but yes, "wipe" was hyperbolic wording
20:26:28 <benmachine> give it to me
20:26:31 <benmachine> I'm still failing to reproduce
20:27:20 <benmachine> actually
20:27:24 <benmachine> I'm failing to stay awake
20:27:27 <benmachine> so I'll go and do that instead
20:27:35 <benmachine> I wish you good luck and good night
20:28:36 <tel> benmachine thanks for taking a look at it
20:28:40 <tel> have a good night :)
20:33:34 <carter> tel btw: you'll laugh at this
20:34:19 <tel> carter what's up?
20:34:24 <carter> you know that simd vector-vectorized lib i was hacking on?
20:34:28 <tel> yeah
20:34:44 <carter> i've decided that while the code is nice, its the wrong approach
20:34:48 <carter> so i'm shelving it
20:35:19 <carter> basiclaly: lifting the element wise operations over the arrays is wrong period
20:35:38 <carter> you should give me your pointwise n ary op, and i should do some sort of mapN analogue
20:36:01 <tel> oomph
20:36:02 <benmachine> tel: ok I lied, I've decided that empty libsubdir and datasubdir are fairly likely to be your problem
20:36:26 <carter> omph??
20:36:28 <tel> benmachine: and I've isolated the bug to only occur when the cabal 1.16 default config is in place : )
20:36:38 <carter> then i've had a darn heisenbug...
20:36:44 <benmachine> tel: is it definitely the default config? it has some things uncommented
20:36:45 <tel> carter shelving libs is always a little painful, yeah
20:36:50 <carter> well
20:36:52 <carter> in this case
20:36:56 <carter> its still nice code
20:36:59 <carter> just the wrong appraoch
20:36:59 <benmachine> tel: possibly it's trying to work out what libsubdir is and failing and ending up an empty string there
20:37:00 <tel> benmachine total reinstall from GHC up just before this ticket
20:37:14 <benmachine> er, libsubdir *should be
20:37:17 <tel> carter well that's a really good discovery then
20:37:26 <carter> tel its not a discovery
20:37:36 <carter> lemem explain differentaly
20:37:53 <carter> if a+b+c*e were done with the lifted binary ops
20:38:05 <carter> you have to allocate lots of intermediate arrays
20:38:11 <carter> well, at least 2
20:38:24 <carter> right?
20:38:26 <tel> benmachine, it seems pretty consistent with what I'm seeing. I'm leaving the ticket up since this is a fairly reasonable stumbling block for new 1.18 installs
20:38:37 <tel> carter yeah
20:38:44 <benmachine> tel: yep, I reproduced once I had the empty libsubdir
20:39:01 <benmachine> tel: to me the real question is why the libsubdir was created empty, but I guess that might be a cabal-1.16 bug
20:39:08 <carter> but if you write it as map4 \a b c d e -> a+b+c*e $ va vb vc ve
20:39:23 <carter> you have no intermediate arrays and a hope for good SIMD in a fancy simdfier
20:39:54 <tel> carter you can give more information to your simdifier, yeah?
20:40:04 <carter> i don't have one yet
20:40:22 <carter> this falls under the umbrella of deep embedding with llvm-general backend
20:40:25 <carter> or ghc plugins
20:40:28 <carter> which i wont' do for now
20:41:16 <carter> tel: basically doing it the mapN way is more robust interms of perf
20:41:16 <tel> but in theory that makes sense ; P
20:41:21 <tel> yeah
20:41:27 <carter> the simd ops are cool when they're "right"
20:41:42 <edwardk> ReinH: how fares?
20:41:44 <carter> and i kinda like that lib at least as a signifier that i know how to write naive but decent simd codes
20:41:53 <carter> tel did you look at the simd c codes i wrote?
20:42:01 <carter> its a really elegant hack at this point
20:42:50 <tel> I haven't seen any recent code—is it on bitbucket?
20:43:09 <carter> yup
20:43:17 <carter> the simd code is prtty nice
20:43:44 <carter> https://bitbucket.org/haskellnumerics/vector-vectorized/src/169601798bc4f2db2547992dd452caadb4c74734/cbits/VectorSIMD.c?at=master
20:44:00 <carter> i also wrote a bunch of haskell ffi wrrappers
20:44:02 <carter> that all do the right thing
20:44:10 <carter> only the low level wrappers mind
20:44:11 <carter> you
20:44:26 <carter> also: currently does unaligned loads and stores because thats more robustly correct to use
20:44:54 <carter> https://bitbucket.org/haskellnumerics/vector-vectorized/src/169601798bc4f2db2547992dd452caadb4c74734/cbits/VectorSIMD.c?at=master#cl-266 is the line that does the magic :)
20:45:16 <carter> i do like the dot products i wrote https://bitbucket.org/haskellnumerics/vector-vectorized/src/169601798bc4f2db2547992dd452caadb4c74734/cbits/VectorSIMD.c?at=master#cl-308
20:46:57 <carter> tel point being: its cute codes
20:47:07 * carter but i think theres better ways
20:47:08 <carter> but i think theres better ways
20:47:39 <ReinH> edwardk: I can calculate the distance map for a roguelike-sized level in about 75ms
20:48:15 <carter> coool!
20:48:22 <ReinH> edwardk: performance seems pretty close to n log n in the total number of cells in the level
20:49:07 * carter ReinH code anywhere
20:49:10 <carter> ?
20:49:11 <ReinH> edwardk: I also figured out that my new approximation, in addition to being much faster per trial, also requires maybe an order of magnitude less trials to find the fixed point
20:49:13 <Moggle> Is there any way to set things up so runIO's order with Template Haskell can be made predictable?
20:49:15 <ReinH> carter: soon, just cleaning up
20:49:19 <carter> cool
20:49:24 <Moggle> What I'd like to do is run a template haskell thing on a few data types
20:49:39 <Moggle> then have a final template haskell thing called which has made a list of all the data types I previously modified
20:49:43 <ReinH> edwardk: which means that instead of finding a fixed point using vector equality, I can just run it 3 times
20:50:06 <ReinH> and it'll find a solution for levels up to about an order of magnitude larger than the ones I'll be using it on
20:50:10 <ReinH> and now slow vector equality checks
20:50:13 <Moggle> I have been thinking of using an IORef [Type or name or something], but runIO apparently doesn't have a way to control the order of splices
20:50:42 <carter> Moggle: look at the language inline c stuff manuel has on github
20:50:48 <carter> @hackage language-inline-c
20:50:48 <lambdabot> http://hackage.haskell.org/package/language-inline-c
20:50:55 <carter> darn
20:50:59 <ReinH> And I can check for pathological cases when I get the map for a coord and rerun it.
20:51:04 <carter> https://github.com/mchakravarty/language-c-inline
20:51:07 <Moggle> carter: I feel like I am quickly descending into horror and madness, but thank you!
20:51:22 <ReinH> carter: old slow method took about 300ms for the same level that now takes 75ms :)
20:51:23 <carter> Moggle also comes up when people want to have inline objective C in haskell
20:51:27 <carter> woot
20:51:40 <ReinH> I'm pretty sure I am not leveraging all the vector speedups I could be
20:51:55 <carter> ReinH thats ok
20:53:13 <ReinH> carter: but ~75ms is good enough to be responsive for a real world roguelike game
20:53:23 <carter> yup!
20:53:28 <ReinH> especially since I'll be kicking the computations off in parallel on initial level generation
20:54:09 <carter> ReinH without seeing the code i can't have ideas
20:54:19 <ReinH> carter: no worries, let me get this up somewhere :)
20:54:24 <carter> cool
20:54:40 <Moggle> carter: ok, so I can inline C code. i'm not really sure how that helps me control the order of execution of template haskell things?
20:54:46 <tel> carter: I really wish I had more experience with the SIMD instructions. It looks pretty tasty, but there's also a lot of magic C going on in my eyes
20:55:59 <niteria> I want to deploy a haskell program somewhere where I can't install GHC (too little disk space), I've tried building static binary and run it there, but it segfaults, possibly because 'gethostbyname' is used. Any ideas how to deal with this?
20:56:32 <carter> tel : tunixman thinks its purdy :)
20:56:59 <tel> carter take his judgement more to heart ;)
20:57:09 <tel> my C brain is subpar
20:57:15 <carter> tel its ok
20:57:35 <carter> i'm honestly unsure if the ghc type ssytem can actually correctly do the code gen for the simd operations i want
20:57:48 <carter> aside from the boring pointwise math ones
20:58:49 <carter> tel basically read the intel manuals
20:58:57 <carter> and you'll understand
20:59:00 <carter> very readable
21:00:44 <fiddlerwoaroof> Is there a library function that does the equivalent of 'do {x <- someFunc; anotherFunc; return x}'?
21:01:26 <startling> someFunc <* anotherFunc
21:01:31 <tel> carter: one day..
21:01:42 <tel> carter: I have an excuse—I'd really like to learn the Salsa20 SIMD trick
21:01:44 <startling> fiddlerwoaroof: (in Control.Applicative, assuming you have an Applicative instance)
21:01:48 <tel> but not today
21:02:04 <carter> tel: have a no allocation bit of c code for it
21:02:40 <shachaf> fiddlerwoaroof: Note that that's pretty boring if someFun and anotherFunc are actual functions.
21:02:41 <startling> niteria, I think you need another flag to statically link GMP in
21:02:56 <tel> tel: bernstein is really particular about his loop optimization. If you read the Salsa20 papers they often talk about how you can shave a few cruicial instructions off the inner-inner loop with SIMD
21:03:08 <tel> tel but I know not enough about SIMD or what the trick might be to follow further
21:03:29 <shachaf> I remember he used the justification that x86 has three-operand addition but not three-operand xor.
21:03:34 <fiddlerwoaroof> shachaf: they're actually Parsec combinators and I want the value of the first
21:03:35 <shachaf> Which is slightly fishy, but eh.
21:03:59 <carter> tel : just use __builtin_shuffle(,,,) and friends on clang
21:04:00 <tel> shachaf, I'm kind of ignorant here—what's fishy?
21:04:02 <shachaf> The "design of salsa20" PDF is nice.
21:04:03 <fiddlerwoaroof> shachaf: s/combinators/parsers/
21:04:12 <startling> fiddlerwoaroof: okay. parserA <* parserB
21:04:25 <shachaf> tel: Not really fishy, just seems like a bit of a silly way to make a decision.
21:04:26 <tel> shachaf agreed—it was great to get into the design space for a thing like salsa20
21:04:30 <tel> shachaf ah
21:04:45 <startling> fiddlerwoaroof: There's also (*>). you point to the one you want to keep.
21:04:54 <fiddlerwoaroof> startling: thanks.
21:05:01 <shachaf> Note that (<*) is not the same as flip (*>).
21:06:00 <startling> (usually)
21:06:21 <Fuuzetsu> fiddlerwoaroof: Out of interest, what are you parsing?
21:06:36 <shachaf> "usually"?
21:06:50 <niteria> startling: it's actually a snap based webapp and it starts correctly and serves basic pages, but when I try to use http-conduit it segfaults. That's why I suspect 'gethostbyname', and I got warnings about it when building, too.
21:06:56 <shachaf> It's not the same function. Sometimes you can instantiate it in a boring enough way to lose that distinction, but it's still a different polymorphic function.
21:06:56 <fiddlerwoaroof> Fuuzetsu: I'm following the wikibook on writing a scheme, and trying to figure out one of the exercises.
21:07:07 <shachaf> Would you say that (\x y -> x) and (\x y -> y) are "usually" different?
21:07:33 <niteria> startling: if it was gmp, wouldn't it segfault right at the beginning?
21:08:57 <startling> niteria, I don't know.
21:09:10 <startling> niteria: you're going to have to use GDB or something if you really want to know.
21:10:59 * hackagebot google-search 0.1.0.0 - EDSL for Google and GMail search expressions  http://hackage.haskell.org/package/google-search-0.1.0.0 (LiyangHu)
21:13:14 <ltrottier> Anyone familiar with hacking on pandoc?
21:13:20 <niteria> fair enough, it shows adns_strerror() at the top of the stack trace
21:13:36 <ltrottier> I need to fix it
21:13:48 <Moggle> After much research and effort, I have determined that Template Haskell is easily the worst-best thing to happen to Haskell.
21:13:54 <Moggle> So... ugly, but so nice.
21:13:58 <Moggle> Also kind of awkward but I can deal.
21:14:49 <joelteon> what does <<loop>> mean?
21:15:19 <fiddlerwoaroof> is <* transitive? (i.e. does 'a <* b <* c' return the result of a?)
21:15:40 <Moggle> :info (<*)
21:15:43 <tabemann> joeltron: it means it tried to enter a black hole in the same thread where the black hole was created
21:15:48 <Moggle> :i (<*)
21:15:51 <startling> fiddlerwoaroof, yes.
21:15:52 <Moggle> here I was thinking that would work!
21:16:00 <tabemann> where a thunk, while being evaluated, is replaced by a black hole
21:16:16 <joelteon> two things tried to evaluate it?
21:16:30 <tabemann> (note that another thread, if it tries to enter a black hole, simply waits until the thunk being evaluated is done being evaluated)
21:16:31 <startling> fiddlerwoaroof: the two possible associations are (a <* b) <* c and a <* (b <* c). Both give the result of a.
21:16:54 <tabemann> joeltron: it means that a thunk tried to directly evaluate itself
21:17:22 <startling> Moggle: I think TH is about as nice as it could be
21:17:37 <startling> barring a blaze-html esque Writer thing I guess
21:17:52 <Moggle> startling: Really? I sort of have an issue with $( ... )
21:18:00 <Moggle> startling: I mean, there's got to be a thousand better ways to do that...
21:18:04 <fiddlerwoaroof> startling: that was easy, should've thought of it on my own.
21:18:58 <startling> Moggle: I don't know. there's not very much unused syntax in haskell
21:19:52 <Moggle> startling: Eh! I just wish I could control the order of runIO at this point.
21:19:53 <startling> not that $(...) isn't unused in some cases, but you know
21:20:23 <Moggle> startling: I guess I've found a more Haskelly solution with lists, no global variables needed, but... I'd like the modularity.
21:20:28 * tabemann personally doesn't like the way that TH has "stolen" $, because the use of $ as (a -> b) -> a -> b shouldn't be whitespace-sensitive
21:20:52 <johnw> it stole $(, not $
21:21:02 <Moggle> tabemann: reasonable, but most people do write operators with spaces do they not?
21:21:10 <johnw> and I don't think you can use ( in an operator name anyway
21:21:16 <tabemann> johnw: well that's what I mean - $ (foo) should be the same as $(foo)
21:21:28 <startling> > (+) 1 $(2 + 2)
21:21:29 <lambdabot>   5
21:21:59 <tabemann> Moggle: that's not what I mean
21:22:18 <tabemann> I mean that normal Haskell operators aren't whitespace-sensitive - they don't need to be separated from other things by spaces
21:22:23 <startling> > (+)1$(2+2)
21:22:25 <lambdabot>   5
21:22:27 <joelteon> tabemann: is this just a case of "I wrote an infinite loop" or is it IO-related or something?
21:22:34 <joelteon> I've written a lot of infinite loops in my life but never seen this
21:22:51 <startling> I kinda wish haskell require whitespace around operators.
21:22:58 <tabemann> joeltron: it means you write wrote something that resulted in a thunk that needed to *strictly* evaluate itself
21:23:06 <Moggle> tabemann: i get that, but it seems to me to be a non-issue, because people always do use whitespace. i suppose i agree with you in the sense that it is theoretically ugly.
21:23:13 <tabemann> startling: like Agda
21:23:16 <joelteon> tabemann: why aren't you tab completing my name
21:23:18 <Moggle> which goes along with what i was saying about TH being... awkward.
21:23:22 <mstksg> it's a bit of an inconsitensy/asymmetry
21:23:34 <mstksg> inconsistency?
21:24:13 <startling> tabemann: right.
21:24:15 <tabemann> joelteon, because I like using colons therefor over using commas
21:24:16 <joelteon> ok
21:24:17 <joelteon> ok
21:24:22 <startling> tabemann: :/
21:24:27 <joelteon> i feel like you should be able to configure that in your client
21:24:41 <tabemann> the thing is that Agda, due to being whitespace-sensitive, allows all kinds of crazy things with syntax which would be impossible in Haskell
21:25:23 <tabemann> e.g. if then else is not syntax, it actually is just a normal operator
21:25:44 <tel> mixfix :)
21:27:05 <pharaun> tabemann: i'm not sure i get that statement, whitespace sensitive as in (a b) is different from (a  b) ?
21:27:13 <Fuuzetsu> aka the best or the worst thing ever, depending on who you ask
21:27:15 <pharaun> or are you referring to like indention ?
21:28:01 <tel> Fuuzetsu, and *when* you ask the
21:28:01 <tel> m
21:28:02 <tabemann> pharaun: I mean that operators in Haskell do not normally need to be separated from what is adjacent to it by whitespace, so hence they are whitespace-insensitive, unlike operators in Agda, which do, and hence are whitespace-sensitive
21:28:22 <startling> whitespace sensitivity gives you more flexibility with operators too
21:28:29 <startling> though there's stuff haskell could do but doesn't.
21:28:55 <startling> like, you could have (<2>) or (<a) with whitespace sensitivity
21:29:04 <tabemann> yes
21:29:35 <startling> also, symbols in non-leading parts of identifiers!
21:29:43 <startling> I'd love lispy do-this-thing identifiers
21:29:54 <joelteon> if :trace is hanging forever on <interactive>: <<loop>>, what do I do?
21:30:11 <tel> startling somehow _ versus - is a more salient syntactic feature to me than all the parens
21:30:34 <startling> not sure what you mean.
21:31:06 <tel> startling as far as the "look of lisp" goes, I miss hyphenated identifiers a lot
21:31:23 <startling> Oh. right. me too! camelcase is ugly and _ is ugly
21:31:29 <tel> yeah
21:31:34 <tabemann> I personally do like the hyphens used in Lisps myself
21:31:51 <tel> it just seems more civilized (?)
21:32:10 <tabemann> even though outside of Lisps I've tended to favor underscores over camelcase (but use camelcase in Haskell because that's what everyone else uses)
21:32:17 <startling> mhm.
21:32:51 <startling> also, question marks!
21:33:20 <tabemann> I do like how Scheme uses ? for predicates and ! for destructive operations myself
21:33:33 <tel> as long as it's consistent!
21:33:36 <lispy> startling: do what things with identifiers?
21:33:51 <tel> I've been programming ruby recently… so I can't trust ? and ! at all right now
21:33:52 <joelteon> ok, ghc is telling me that -prof requires that the library be built with profiling
21:33:54 <startling> > let (?) = id in isDigit? "12"
21:33:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:33:55 <lambdabot>              with actual type...
21:33:57 <joelteon> how do I build it with profiling?
21:34:03 <joelteon> I've done cabal configure --enable-library-profiling
21:34:15 <tabemann> joeltron: you rebuild everything in cabal
21:34:23 <joelteon> ok
21:34:28 <tabemann> and it will rebuild it all with profiling
21:34:37 <joelteon> if you're going to type it out manually, can you type it correctly so I get highlighted?
21:34:44 <startling> oh
21:34:52 <startling> > let (?) = id in isDigit? '1'
21:34:54 <lambdabot>   True
21:35:08 <pharaun> ah thanks tabemann startling
21:35:19 <startling> lispy: :0
21:35:19 <tel> startling hah
21:35:19 <tabemann> joeltron, your client only highlights when it has a comma?
21:35:29 <pharaun> oh... is c++ whitespace sensitive?
21:35:30 <joelteon> no, it highlights when my name is in a line
21:35:42 <joelteon> > "joelteon" == "joeltron"
21:35:43 <lambdabot>   False
21:35:45 <Moggle> startling: it's... beautiful
21:35:45 <startling> joeltoon: eh?
21:35:59 <tel> startling let f p? = filter p? … :(
21:36:03 <tabemann> pharaun: no
21:36:09 <pharaun> IE their what is it?? name is escaping me, template you can't do <Int <Char>> you have to do <Int <Char> > ?
21:36:28 <pharaun> or is that just a different problem/failure of the grammar?
21:36:29 <Moggle> pharaun: I might be wrong, but I *think* C++ 11 fixes that?
21:36:41 <Moggle> pharaun: But you're right, that used to be a problem, due to the >> operator.
21:36:44 <tabemann> pharaun: that's a bug in the parser design for C++, even though C++11 may fix it
21:36:57 <pharaun> tabemann: ah k
21:36:58 <Moggle> pharaun: C++ is so complex you have to keep track of types while parsing to avoid ambiguous syntax.
21:37:05 <Moggle> it is... horrifying.
21:37:11 <startling> tel, too bad you can't assign to sections
21:37:20 <joelteon> > catMaybes $ zipWith (\x y -> if x == y then Nothing else Just (x,y)) "joelteon" "joeltron"
21:37:22 <lambdabot>   [('e','r')]
21:37:23 <pharaun> ok just wanted to make sure i... kept the two separate or made sure i think i understand the whitespace thing
21:37:36 <pharaun> i guess i just have to try out Agda to fully realize this whitespace sensitivity thing :)
21:37:58 <startling> pharaun: if _ then _ else _ : Bool -> a -> a -> a
21:38:01 <pharaun> none of my language that i've used have whitespace sensivity outside of identing
21:38:08 <arkeet> :t filter (uncurry (==)) . zip
21:38:09 <lambdabot>     Couldn't match type `[b1] -> [(a0, b1)]' with `[(b0, b0)]'
21:38:09 <lambdabot>     Expected type: [a0] -> [(b0, b0)]
21:38:09 <lambdabot>       Actual type: [a0] -> [b1] -> [(a0, b1)]
21:38:16 <arkeet> :t (filter (uncurry (==)) .) . zip
21:38:16 <lambdabot> Eq b => [b] -> [b] -> [(b, b)]
21:38:23 <pharaun> startling: that is an example of whitespace sensivity?
21:38:27 <pharaun> ok i guess it is then
21:38:47 <startling> pharaun: that is an example of the crazy places you can go if you give up whitespace insensitivity
21:38:49 <tabemann> startling: I think that's actually declared as if_then_else_
21:38:56 <startling> tabemann: aww
21:40:04 <pharaun> whoa whoa
21:40:09 <pharaun> i can actually define a function like that
21:40:12 <tabemann> yes
21:40:22 <tabemann> you can define types and type constructors like that too
21:40:32 <pharaun> that's... neat i think
21:40:33 <tel> it goes sooo far sometimes
21:40:35 <tabemann> s/type constructor/type and data constructors
21:40:44 <pharaun> sometime i think that could lead to some really horrifying code
21:41:01 <lispy> Moggle: it is possible to separate the two phases using GLR. There is a paper on it. Instead of mixing them you do a clean up pass over the forest of parse trees using the symbols tables to cull out the illegal parses.
21:41:28 <lispy> Moggle: http://scottmcpeak.com/elkhound/
21:41:29 <tel>   _≅⟨_⟩_ : ∀ {a} {A : Set a} (x : A) {y z : A} → x ≅ y → y IsRelatedTo z → x IsRelatedTo z
21:41:32 <Fuuzetsu> pharaun: but it also allows for awesome stuff like the PropositionalEquality proof syntax
21:41:50 <tel> Fuuzetsu, I was just looking for that. I always forget where it is in the stdlib
21:41:57 <Moggle> lispy: interesting!
21:42:09 <pharaun> Fuuzetsu: heh guess i'm going to have to dig into adga then :)
21:42:12 <Fuuzetsu> tel: Me too… I had to think _real_ hard
21:42:14 <pharaun> been pondering about doing so someday
21:42:49 <lispy> pharaun: I'll just leave this here :) http://wiki.portal.chalmers.se/agda/pmwiki.php
21:43:11 <Fuuzetsu> the wiki is so incomplete ;(
21:43:17 <Fuuzetsu> even core stuff like the pattern matching page
21:43:22 <pharaun> lispy: :D
21:43:28 <startling> the thing about mixfix is that it uses associativity graphs rather than a total ordering
21:43:38 <tabemann> http://oxij.org/note/BrutalDepTypes/
21:43:45 <lispy> Fuuzetsu: true, but the links to other documents are worth it. Like the tutorial by Ulf is good
21:43:48 <tel> startling I've wondered about that
21:43:54 <lispy> and the one tabemann just linked is great
21:44:01 <carter> the wiki should be fixed up there
21:44:05 <carter> its soooo spare
21:44:12 <startling> tel, there's a paper
21:44:15 <carter> the brutal doc is nice
21:44:27 <startling> https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CCsQFjAA&url=http%3A%2F%2Fwww.cse.chalmers.se%2F~nad%2Fpublications%2Fdanielsson-norell-mixfix.pdf&ei=kF0pUpHsMMWGyQGG24HgCA&usg=AFQjCNHOQL7kiiMWnMCsh_AELiluniL4yA&sig2=W3dNKpLd2Qlwn5IQEJRSHg
21:44:33 <startling> ugh, fuck you google.
21:44:39 <startling> www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf
21:44:52 <tel> cool!
21:45:14 <lispy> startling: that's different than what is implemented in Agda though. That paper uses graphs but agda itself uses absolute prefix numbers
21:45:26 <startling> lispy: huh.
21:45:54 <lispy> And the parser they give is...hard to implement unless you have a very smart lexer
21:46:10 <carter> lispy so its strictly more general approach in the paper, but harder to use?
21:46:14 <lispy> The parser assumes you know what type of token you have (start, middle, end, closed, or whatever)
21:46:41 <lispy> carter: I think it was an idea that occured to them and seemed neat so they wanted to explore it
21:47:21 <lispy> The paper basically proves that you could, in theory, give an unambiguous grammar with mixfix and precedence graphs and that an applicative parser can parse it
21:48:35 <lispy> Superficially, it looks like they give a parser for the language, but if you try to implement it you will find that they took some conceptual shortcuts. Such as, you need a smart lexer that can classify tokens.
21:49:37 <lispy> I need to finish my implementation of the ideas in there.
21:49:38 <monochrom> I have a cunning plan! force users to provide those tokens directly :)
21:50:08 <arkeet> I have a punning clan. shachaf is in it.
21:50:31 <startling> [{token: '(', type: 'opening'}, ..., {token: ')', type: 'closing'}
21:50:32 <startling> ]
21:50:37 <lispy> I was trying to do it in happy. Initially, I thought it would be straight forward. Then I discovered the lexer thing. I thought I could solve it with a monad but it was gross, so then I started thinking about GLR.
21:51:03 <lispy> the problem is with user defined tokens
21:51:07 <lispy> if_then_else_
21:51:07 <shachaf> arkeet: Is monochrom in it?
21:51:15 <arkeet> I don't know!
21:51:37 <lispy> your lexer needs to either update so that then becomes a middle token or you post process the possible parses (that's what they recommend)
21:51:46 <monochrom> I like puns. please admit me!
21:52:16 <carter> lispy: doesn't idris hack around that with their % notation?
21:52:49 <lispy> carter: I don't know much about parsing in idris and I forgot everything I knew about their syntax extensions
21:52:51 <startling> idris doesn't do mixfix.
21:53:06 <lispy> carter: I just remember that you can define your own syntax :)
21:53:13 <carter> they have a mixfix style syntax extension though
21:53:19 <carter> which is nearly that
21:53:19 <carter> ish
21:53:32 <shachaf> monochrom: Turns out a necessary condition for being in the clan is being in -lens.
21:53:57 <carter> which clan?
21:54:08 <lispy> of the cave bear
21:54:33 <monochrom> Ah, I am too lazy to join -lens.
21:54:35 <carter> tel: someone saying they cant get your SOH examples to work
21:54:42 <carter> on #haskell.au
21:54:57 <carter> https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
21:55:05 <startling> http://alpha61.com/primenumbershittingbear/
21:55:26 <carter> OMGGG
21:55:29 <carter> thats amazing
21:56:30 <startling> presumably he or she has a cave and is in this clan too
21:56:59 <lispy> carter: http://www.imdb.com/title/tt0090848/
21:57:08 * lispy is done being off-topic for today, he promises
21:57:27 <lispy> Has anyone here been trying out Connor McBride's agda course?
21:57:42 <startling> where's that?
21:57:47 <lispy> It has a bunch of category theory in the exercises and I'm getting stuck
21:58:03 <joelteon> "the flag -xc requires the program to be built with -prof"
21:58:21 <joelteon> i *just* rebuilt all the deps with -prof
21:58:24 <joelteon> err, with profiling enabled
21:58:33 <tel> carter which tut?
21:58:42 <carter> the one i just  linked to
21:58:43 <Ghoul_> The `Numbers` package documentation is incorrect -__-
21:58:50 <carter> Ghoul_ how so?
21:58:54 <joelteon> why does it not understand that I have profiling enabled
21:58:55 <carter> please be more specific
21:58:55 <Ghoul_> If someone takes the name Numbers and reserves Data.Numbers they should maintain it
21:58:56 <joelteon> omg
21:58:59 <tel> carter, oh, whoops
21:59:05 <Ghoul_> Oh, numOfFactors returns the number of prime factors not regular factors
21:59:07 <carter> Ghoul_ it doesn't build?
21:59:13 <carter> oh
21:59:17 <carter> whats a regular factor?
21:59:18 <lispy> startling: http://www.cl.cam.ac.uk/~ok259/agda-course-13/
21:59:22 <carter> email the maintainer
21:59:26 <carter> don't complain on irc :)
21:59:32 <carter> unless the maintainer doesnt' reply
21:59:35 <lispy> startling: make a local clone of his github and then watch the lecture on youtube
21:59:51 <Ghoul_> but, but.. I've emailed like 2 maintainers already this week
22:00:14 <lispy> startling: I haven't watched the lecture...it might get me unstuck
22:00:24 <startling> lispy: seems really interesting! thanks
22:01:25 <carter> Ghoul_ remember what happend the last time you didnt
22:01:28 <startling> oh, it seems less interesting once I realize "Introduction Via Vectors" refers to length-typed lists rather than an element of a vector space.
22:01:32 <carter> spj was sad
22:01:37 <carter> :P
22:01:42 <Ghoul_> loll
22:01:43 <carter> "why doesn't windows work"
22:01:52 <carter> i begged you to file a ticket
22:02:01 <carter> didn't i?
22:02:12 <Ghoul_> I can't remember, probably
22:02:16 <carter> i have logs
22:02:18 <carter> i can show you
22:02:23 <Ghoul_> fineee~ I'll send an email
22:02:25 <carter> i at least asked nicely
22:02:27 <carter> yay!
22:02:29 <Fuuzetsu> SPJ must be the only Windows user
22:02:35 * Ghoul_ slaps Fuuzetsu
22:02:36 <carter> and Ghoul_
22:02:53 <monochrom> joelteon: what about the program itself? is it rebuilt too?
22:02:55 <ReinH> carter: https://github.com/reinh/DijkstraMap
22:02:58 <ReinH> edwardk: ^
22:03:00 <joelteon> i haven't built it yet
22:03:23 <joelteon> but yeah, I ran cabal clean
22:03:32 <joelteon> same complaint
22:03:41 <ReinH> edwardk: I wonder if there's a better way to do this https://github.com/reinh/DijkstraMap/blob/master/Dijkstra/Grid.hs#L98-L106
22:03:44 <ReinH> carter: ^
22:04:00 <carter> i'll look tomorrow?
22:04:05 <ReinH> carter: no worries :)
22:04:20 <monochrom> ok, for cabal, it's split personality. it's --enable-library-profiling vs --enable-executable-profiling
22:04:47 <carter> ReinH you're saying "I want the corners of the k radious N dim hyper cube?"
22:04:48 <monochrom> I think you can just look at those two names and guess what they *don't* do
22:04:50 <carter> or just 2d?
22:05:16 <joelteon> sure
22:05:41 <joelteon> it doesn't matter if I have neither, one or the other, or both
22:05:49 <ReinH> carter: I am not sure.
22:05:58 <carter> ReinH doyou want do only do the 2d case?
22:06:07 <ReinH> I only care about 2d
22:06:09 <ReinH> carter: `around v 1` are the direct neighbors of v
22:06:14 <monochrom> then perhaps sidestep cabal
22:06:15 <Fuuzetsu> 2D is best
22:06:17 <carter> ohhh
22:06:19 <ReinH> `around v 2` are the neighbor's neighbors
22:06:20 <ReinH> and so on
22:06:24 <carter> ok
22:06:28 <ReinH> (not including the direct neighbors)
22:06:28 <carter> ok
22:06:44 <joelteon> ok
22:06:48 <ReinH> ok :)
22:06:55 <joelteon> monochrom: I pasted the command that cabal repl -v prints out before it launches GHCi
22:06:59 <carter> is it always a 2d grid?
22:07:05 <startling> ReinH: hey, I wrote something kinda like that once
22:07:06 <ReinH> carter: it's always a 2d grid
22:07:22 <carter> ReinH: ooo: heres a trick you could do then
22:07:23 <startling> ReinH: this is for a roguelike isn't it
22:07:27 <ReinH> startling: yep
22:07:32 <monochrom> what does ghci or cabal repl have to do with -xc?
22:07:41 <carter> generate the column of left most coords
22:07:41 <joelteon> ohhhh, wait
22:07:43 <joelteon> never mind
22:07:46 <carter> oh
22:07:51 <carter> wait, n radius
22:07:51 <joelteon> I was hoping to use rtsopts and ghci at the same time
22:07:53 <carter> ohhh
22:08:01 <carter> no N x N cube
22:08:06 <ReinH> right sorry
22:08:18 <ReinH> `around v 1` is a 3x3 box around v
22:08:28 <ReinH> `around v 2` is a 5x5 box around v
22:08:49 <carter> aroudn v 3 is?
22:08:56 <ReinH> 7x7
22:09:01 <ReinH> only the edge cells, not the interior cells
22:09:04 <carter> are they always primes/?
22:09:15 <ReinH> they're always 2x+1 on a side
22:09:17 <carter> ok
22:09:19 <ReinH> carter: it's easy to visualize, one sec
22:09:22 <carter> yeah
22:09:23 <carter> i got it
22:09:29 <carter> i'm slow at this hour
22:09:41 <carter> so that actually gives you a neat alg
22:09:47 <monochrom> "prime square shitting bear"? :)
22:10:01 <carter> assuming its on an infinite grid
22:10:15 <carter> generate a vector of the left most coords
22:10:26 <carter> and do a fold mapping ove rthem to generate all the right shifts
22:10:34 <carter> untill you hit the right boundary of the box
22:10:46 <carter> and then concact those vectors all at once
22:11:19 <carter> mebe
22:11:28 <ReinH> carter: just so I'm sure I explained it properly: https://gist.github.com/reinh/d8e4caf3085a0c39f1fe
22:11:56 <carter> i think we should use notdan 's diagrams paste site :)
22:12:10 <ReinH> I don't know what that is :)
22:12:42 <edwardk> ReinH: nothing i can come up with that is better
22:12:58 <ReinH> edwardk: I'd like to do some sort of fancy interleave rather than top V.++ right V.++ bottom V.++ left
22:13:16 <carter> http://paste.hskll.org/ ReinH
22:13:42 <ReinH> interleave (x:xs) (y:ys) = x:y:interleave xs ys but 4 ways and correctly handling longer lists
22:13:48 <joelteon> is it possible to pass RTS options to the :main executable?
22:13:51 <joelteon> in ghci
22:14:15 <ReinH> carter: oh that's nice!
22:14:59 <ReinH> edwardk: it should be possible to calculate `around v n` in O(n)
22:15:15 <leroux> joelteon: Try > :set -<flags>
22:15:21 <ReinH> fortunately it's only a constant factor on the runtime of the algo as a whole
22:15:25 <leroux> So.... > :set +RTS ... -RTS
22:15:34 <ReinH> and it's already pretty fast... but it could be faster :)
22:15:42 <joelteon> leroux: none of those are options known to GHCi
22:17:49 <joelteon> if I use ghci, I can continue past exceptions, but I can't get any useful information during the loop
22:18:00 <joelteon> if I run the built executable, exceptions prevent my bot from ever connecting to the server
22:18:24 <shachaf> RTS options do not work that way.
22:18:53 <carter> nor do exceptions
22:19:04 <joelteon> ok
22:19:24 <carter> joelteon you should use the trace tools in ghci
22:19:29 <joelteon> yeah
22:19:38 <joelteon> well, it hits a breakpoint during the loop
22:19:40 <joelteon> but :trace hangs forever
22:19:44 <joelteon> :back doesn't do anything
22:19:52 <joelteon> and forcing the exception just shows me a NonTerminationException
22:19:53 <ReinH> edwardk: the obvious version has retarded combinatoric complexity https://gist.github.com/reinh/cb41ca8da95ce6fab2a1
22:20:16 <ReinH> but if you fill out all the cases it should give you linear complexity right?
22:20:18 <joelteon> if there's another command I should be trying that I missed, that would be cool
22:20:57 <edwardk> ReinH: too tired to think that through and hold the pieces i'm working on in my head =)
22:21:14 <satc_> Is there any special concern while using unsafePerformIO with lazy IO. I have a function which copies a fixed length data from a bytestring to a buffer, calls a c function on that and copies back the changed data to a strict bytestring. In the end I get a list of strict bytestring from which I generate a lazy bytestring. As there are no external side effect and due to the requirements I want this function to be pure.
22:21:54 <ReinH> edwardk: np, it should be the same as merge (x:xs) (y:xs) = x:y:merge xs ys; merge [] ys = ys; merge xs [] = xs
22:21:55 <edwardk> satc_: nothing really beyond the usual unsafePerformIO concerns
22:22:04 <ReinH> just with a lot more cases
22:22:39 <satc_> edwardk: Thanks.
22:23:14 <lispy> carter: we might be able to give notdan a haskell.org subdomain if he emails the committee and explains the thing
22:23:20 <lispy> carter: do you think you could pass that on to him?
22:24:22 <carter> just sent him  amessage
22:24:27 <lispy> thank you
22:24:43 <carter> via app.net
22:24:43 <ReinH> alright, bedtime for me, thanks for the help folks
22:24:54 <niteria> ReinH: what's the problem with your gist? You want arbitrary number of lists?
22:25:13 <ReinH> niteria: no, 4 is fine: I just don't want to have to write all the cases because I am lazy :)
22:25:20 <lispy> carter: contact info on this page if he needs it: http://www.haskell.org/haskellwiki/Haskell.org_committee
22:25:31 <ReinH> but I probably will since it will always be 4... until I need to do this in 3d
22:26:03 <ReinH> niteria: oh, I almost forgot the real problem: I want to do this with vectors, not lists
22:26:10 <ReinH> so no x:xs pattern matching :(
22:26:18 * hackagebot ghc-mod 3.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.0.0 (KazuYamamoto)
22:26:20 <carter> lispy i told him to ping you
22:26:20 * hackagebot combinator-interactive 0.1 - SKI Combinator interpreter  http://hackage.haskell.org/package/combinator-interactive-0.1 (FumiakiKinoshita)
22:26:27 <lispy> carter: that works
22:26:32 <carter> i'm bad at carrying instructions / being go between
22:30:09 <niteria> > concat $ transpose [[1,2,3], [4,5], [6,7,8]]
22:30:12 <lambdabot>   [1,4,6,2,5,7,3,8]
22:30:26 <ReinH> niteria: sure, that works, but it doesn't improve the asymptotics
22:30:31 <niteria> probably unnecesarily strict
22:30:53 <ReinH> the point of doing this is to go from V.++ complexity to linear complexity
22:31:13 <ReinH> I already have a perfectly good solution with concat :)
22:31:24 <scshunt> V.++?
22:31:27 <ReinH> (Data.Vector.++, sorry)
22:33:25 <ReinH> I don't actually need the interleaving order, so `xs V.++ ys V.++ zs V.++ ws` is fine but I'm incurring the concat cost a lot.
22:33:30 <ReinH> in any event, I'm out for the night
22:33:31 <ReinH> ttfn
22:35:26 <carter> ReinH theres another way
22:35:33 <carter> that may swing the concat cost
22:35:36 <carter> do a buildable
22:35:38 <carter> kinda thing
22:35:48 <carter> ie: compute the final result size
22:35:52 <carter> and do it all at once
22:36:18 * hackagebot cryptocipher 0.6.1 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.6.1 (VincentHanquez)
22:36:35 <joelteon> well, huh
22:36:42 <joelteon> this library uses a lot of unsafeInterleaveIO
22:38:16 <ReinH> carter: there's probably a streaming way to do it as well
22:38:27 <ReinH> alright ttfn
22:38:30 <carter> kk
22:38:35 <joelteon> ahhh
22:39:09 <joelteon> so my uneducated guess is that the result of this expression is unsafeInterleave'd but then it's evaluated twice
22:40:14 <joelteon> nope, that's not it
22:41:12 <MrRacoon> hey haskellers: what is your method of choice for incorperating configuration files into your projects?
22:41:59 <MrRacoon> (i want them to be dynamic)
22:42:11 <NemesisD> isn't there an offtopic haskell channel?
22:42:19 <Fuuzetsu> -blah
22:43:08 <joelteon> ok, no, something is definitely wrong here
22:43:19 <joelteon> this is a long shot, but has anyone here used the haskell wordnet library?
22:47:47 <carter> not in years
22:49:32 <joelteon> i wonder how they managed to make it do this
22:50:02 <MrRacoon> do people use configFile at all?
23:15:47 <chexxor> quick Q: What is this called: (\\) Is must mean something, because it has a symbol like this.
23:16:18 <startling> chexxor, it means \ in a string literal, since \ ordinarily is an escape character
23:16:26 <startling> :t '\n'
23:16:28 <lambdabot> Char
23:16:42 <startling> > '\\'
23:16:44 <lambdabot>   '\\'
23:17:13 <shachaf> But in parentheses it's probably not in a string literal.
23:17:21 <shachaf> It's also an operator. Hoogle can find things like that for you.
23:17:23 <shachaf> @where hoogle
23:17:23 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:17:26 <shachaf> @hoogle (\\)
23:17:26 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
23:17:26 <lambdabot> Data.IntMap.Strict (\\) :: IntMap a -> IntMap b -> IntMap a
23:17:26 <lambdabot> Data.IntMap.Lazy (\\) :: IntMap a -> IntMap b -> IntMap a
23:17:46 <startling> oh, I misread chexxor's notation. shachaf is provably write
23:17:51 <startling> *probably right, even
23:17:54 <startling> jesus.
23:18:24 <chexxor> I see the type signature, and I used it
23:18:34 <leroux> chexxor: List (set-like) difference.
23:18:45 <chexxor> it's like deleteFirstsBy (==) ns nDomain
23:19:07 <chexxor> but why choose that symbol?
23:19:22 <leroux> It's a special case of that actually.
23:19:30 <leroux> chexxor: Set notation?
23:19:33 <shachaf> It looks like \
23:19:37 <chexxor> right, a curried version, no?
23:19:41 <shachaf> https://en.wikipedia.org/wiki/Set_difference#Relative_complement
23:20:06 <leroux> chexxor: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:-92--92-
23:20:42 <chexxor> shachaf: that's the direction I want to go. Looks like Set theory/Math uses the \
23:21:24 * hackagebot WordNet-ghc74 0.1.3 - Haskell interface to the WordNet database  http://hackage.haskell.org/package/WordNet-ghc74-0.1.3 (JoelTaylor)
23:22:26 <chexxor> the answer is important for me: \\ is a curried version of deleteFirstsBy. Incorrect?
23:22:44 <leroux> chexxor: Not a curried version.
23:23:04 <leroux> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#%5C%5C
23:24:15 <chexxor> why not? The implementation is a bit different, but the way it's uses feels like a.... partially applied function?
23:24:37 <chexxor> like if I make add2 = (+) 2 -- Something like that
23:24:51 <ion> @check \xs ys -> ((\\) xs ys == deleteFirstsBy (==) xs ys) `const` (xs :: String, ys :: String)
23:24:54 <lambdabot>   +++ OK, passed 100 tests.
23:24:56 <leroux> You can also do (+2).
23:25:17 <ion> Currying makes an (a -> b -> c) out of an ((a, b) -> c)
23:25:29 <ion> add2 = (+) 2 is partial application.
23:25:54 <shachaf> "partial application" is a tricky term.
23:25:54 <h4199> I wrote up a partial first draft of a kleisli composition based intro to monads. I fear I used too much hand-waving in the interest of assuming very little about the reader's background. At the same time I fear that it may be too verbose, or difficult to follow.  Would anyone mind taking a look? https://www.fpcomplete.com/user/Lkey/kleisli
23:26:04 <shachaf> More importantly, it's just application.
23:26:08 <chexxor> ok... maybe I'll come across an application of currying later that will help me understand
23:26:37 <ion> > let f (a,b) = a + b in curry f 3 4
23:26:38 <lambdabot>   7
23:26:47 <ion> > let g a b = a + b in uncurry g (3,4)
23:26:49 <lambdabot>   7
23:27:13 <leroux> :t curry
23:27:14 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:27:15 <leroux> :t uncurry
23:27:16 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:27:20 <startling> chexxor: a more consistent way to think of things, I think, is "every function takes one argument".
23:27:40 <startling> then "a -> b -> c" is naturally "a -> (b -> c)"
23:28:59 <chexxor> right, I understand the basics of the one-arg-functions idea. But I haven't seen a useful application of currying, excepting contrived examples.
23:29:10 <shachaf> h4199: Knowing what I know about introductions to monads, I suspect this one will help people a lot less than you think (for the reasons outlined in byorgey's monad tutorial fallacy post).
23:29:48 <h4199> shachaf: I ought to read that again
23:29:53 <shachaf> Not that that's all that constructive, but I guess that post is worth reading if you haven't.
23:29:58 <startling> chexxor: partial application is commonly used for mapping, for example
23:30:10 <startling> > map (^2) [1..]
23:30:11 <leroux> chexxor: With currying you can more easily do partial application.
23:30:11 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
23:30:33 <satc_> Is there any way to replace the above use of typeclass using some other method (constraintkinds or typefamily)
23:30:40 <satc_> http://lpaste.net/92626
23:30:43 <leroux> :t (^)
23:30:44 <lambdabot> (Integral b, Num a) => a -> b -> a
23:30:46 <ion> chexxor: Sometimes you get values of type (a,b) that you happen to want to pass to a function of type (a -> b -> c). Say,
23:30:48 <ion> @type runState
23:30:49 <lambdabot> State s a -> s -> (a, s)
23:30:55 <leroux> Compare that with...
23:31:00 <leroux> :t uncurry (^)
23:31:01 <lambdabot> (Integral b, Num c) => (c, b) -> c
23:31:41 <leroux> The uncurried version of (^) requires that you provide both the base and power as an arg.
23:31:59 <leroux> Of course you could use a lambda and and partially apply.
23:32:04 <ion> chexxor: I guess there can also be functions that want an (a,b) and you want to apply the “a” partially, but that’s less frequent.
23:33:18 <startling> I sort of get the impression that Monad comes naturally once you have a certain amount of experience with data and typeclasses in Haskell, and by that time you know where to find a good explanation.
23:33:22 <chexxor> hmm, interesting. So if I want to use a function which accepts pairs, I can use currying to better/flexibly use that function.
23:35:25 <startling> h4199: "karrow/komposition" is odd
23:35:31 <joelteon> @pl \a b -> a:[b]
23:35:31 <lambdabot> (. return) . (:)
23:35:41 <h4199> shachaf: I had forgotten how short that entry was, it was my hope that I could bridge the problem of abstraction with the existing intuition that a reader had about the composition of functions.
23:35:43 <joelteon> > zipWith ((. return) . (:)) "joelteon" "joeltron"
23:35:44 <lambdabot>   ["jj","oo","ee","ll","tt","er","oo","nn"]
23:35:49 <startling> Calling them "actions" right from the start might be more productive.
23:36:15 <ion> Incidentally, there’s a neat implementation of join for State that involves uncurry: join act = state (uncurry runState . runState act)
23:36:17 <startling> But introducing composition of functions and then of actions is an interesting thing. I like it!
23:36:34 <h4199> startling: I agree, I used them as short hand so I could just write them out.
23:38:11 <chexxor> thanks for the explanation!
23:38:17 <startling> For these kinds of things I wish there was a "for = flip fmap"
23:38:36 <h4199> startling: Thanks, though it wasn't really my idea, Dan Piponi mentioned it twice a few years ago, though he didn't expand on it too much
23:39:08 <ion> @type (\act -> state (uncurry runState . runState act)) `asTypeIn` \join' -> runState (join' undefined)
23:39:09 <lambdabot> State s (State s a) -> StateT s Identity a
23:55:50 <ReinH> joelteon: I'm partial to this one:
23:56:00 <ReinH> > let [] ++/ ys = ys; (x:xs) ++/ ys = x:ys ++/ xs in "foo" ++/ "bar"
23:56:01 <lambdabot>   "fboaor"
