00:00:01 <Admiral-Bell> Hey all, could I get some help with getting a package off hackage to work?
00:00:37 <Admiral-Bell> It's this one: http://hackage.haskell.org/package/chesshs
00:01:29 <Admiral-Bell> It installs just fine, and the functions in the Chess module work, but the other modules are hidden
00:02:54 <Admiral-Bell> Yet the author clearly intended for the other modules to be used, as a function from Chess.FEN (fromFEN) is used in examples both on github and on his website.
00:03:15 <m3ga> Admiral-Bell: that is pretty standard for a library. it exposes a well defined API and other functions are hidden.
00:03:47 <m3ga> Admiral-Bell: ah ok, maybe you can add those modules to the Exposed-Modules section of the cabal file and reinstall.
00:03:55 <Riccardo> M.fromList [("a", "b")] ^@.. folded
00:04:00 <m3ga> you might also want to send the author an email.
00:04:11 <cirdec> @pl \x -> \y -> x >>= (\left -> fromMaybe y $ fmap (return . Just) left)
00:04:12 <Riccardo> how come it doesn't typecheck? a map is foldable...
00:04:14 <lambdabot> flip ((.) . (>>=)) (flip ((.) . ($) . fromMaybe) (fmap (return . Just)))
00:04:14 <lambdabot> optimization suspended, use @pl-resume to continue.
00:04:36 <Admiral-Bell> Thanks! I was afraid to go messing around with the Cabal files. I didn't want to break anything.
00:04:48 <Admiral-Bell> I'll do that and send him and email.
00:05:16 <arkeet> > M.fromList [("a", "b")] ^@.. folded
00:05:18 <lambdabot>   [(0,"b")]
00:05:23 <arkeet> Riccardo: sure it does.
00:05:28 <arkeet> > M.fromList [("a", "b")] ^@.. ifolded
00:05:30 <lambdabot>   [("a","b")]
00:05:53 <arkeet> folded does the same thing as traversed: it makes up its own index based on position.
00:08:35 <Riccardo> arkeet: Couldn't match type `[Char]  -> Accessor (Data.Monoid.Endo [(i0, a0)]) [Char]'   with `Indexed i0 a0 (Accessor (Data.Monoid.Endo [(i0, a0)]) a0)'
00:08:58 <Riccardo> we're using the same code, and i'm trying with -ignore-dot-ghci
00:09:02 <Riccardo> just in case
00:13:09 <arkeet> Riccardo: ??
00:13:30 <Riccardo> that snipped that ran on lambdabot
00:13:38 <arkeet> are you sure it's the same?
00:13:45 <shachaf> You should paste your full ghci session into hpaste.
00:13:46 <shachaf> @paste
00:13:47 <lambdabot> Haskell pastebin: http://lpaste.net/
00:13:57 <shachaf> Also, what's your lens version etc.?
00:15:38 <Riccardo> http://lpaste.net/4168112211392200704
00:15:44 <Riccardo> lens is at 3.9.0.2
00:16:00 <Riccardo> i think everything is relatively recent
00:18:03 <Riccardo> i'm updating to 3.9.0.3
00:18:17 <arkeet> whoa I didn't even know there was a 3.9.0.3
00:18:29 <Riccardo> ok then i guess it won't fix the problem :-)
00:18:47 <Riccardo> apparently it was uploaded yesterday
00:19:25 <Dodek> hey, i'm trying to use a recent version of containers in my app, but when i add containers >= 0.5.2.1 to my cabal file, i get
00:19:28 <arkeet> hm, doesn't work for me either
00:19:28 <Dodek> cabal: At least the following dependencies are missing:
00:19:31 <Dodek> containers >=0.5.2.1 && ==0.5.0.0
00:19:40 <Dodek> so some package forces it to be ==0.5.0.0
00:19:50 <Dodek> how can i find out who's the culprit?
00:23:01 <arkeet> :t folded
00:23:07 <arkeet> :t Control.Lens.folded
00:23:08 <lambdabot> (Applicative f1, Foldable f, Indexable Int p, Contravariant f1) => p a (f1 a) -> f a -> f1 (f a)
00:23:47 <arkeet> Riccardo: yeah, folded is different on the released version
00:24:17 <shachaf> Works for me.
00:24:22 <shachaf> Hmm, I'm using 3.10
00:24:24 <arkeet> yes.
00:24:25 <arkeet> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs#L208
00:24:47 <arkeet> 3.9 doesn't have it.
00:24:57 <shachaf> What does it have?
00:25:04 <arkeet> folded is just a Fold
00:25:16 <shachaf> Oh.
00:25:18 <shachaf> OK then.
00:25:27 <shachaf> Just use indexing folded or something.
00:25:34 <shachaf> Er.
00:25:56 <arkeet> http://hackage.haskell.org/packages/archive/lens/3.9.0.3/doc/html/src/Control-Lens-Fold.html#folded
00:26:10 <arkeet> yes, that.
00:26:16 <shachaf> Well, use the thing that does the thing.
00:26:22 <arkeet> !
00:26:25 <shachaf> indexing is kind of bad. :-(
00:26:41 <Riccardo> thanks for clearing that up
00:26:58 <arkeet> what does conjoined do?
00:27:04 <shachaf> Evil things.
00:27:12 <arkeet> the type looks like const id
00:27:15 <shachaf> Use a different version of the function when you don't ask for indexing.
00:27:19 <arkeet> oh
00:27:22 <Riccardo> time to go to sleep and dream of contravariants
00:27:23 <arkeet> evil
00:27:24 <shachaf> So you don't spend extra work on it.
00:27:28 <shachaf> Have you seen the class/
00:27:31 <arkeet> no
00:27:34 <Riccardo> one day i'll understand all these fancy words
00:27:47 <shachaf> arkeet: You're going to look it up and then you're going to be sad.
00:27:54 <arkeet> I will
00:28:07 <shachaf> Or maybe you'll type :i Conjoined and then be sad.
00:28:54 <arkeet> I'm merely confused.
00:29:16 <shachaf> All those superclasses don't make you sad?
00:29:23 <arkeet> they make me confused.
00:29:46 <elliott> we need to fix conjoined.
00:30:01 <arkeet> :t fix conjoined
00:30:03 <lambdabot>     Couldn't match kind `*' against `* -> * -> *'
00:30:03 <lambdabot>     Kind incompatibility when matching types:
00:30:03 <lambdabot>       q0 :: * -> * -> *
00:30:18 <shachaf> edwardk thought: "what are all the classes that (->) and Indexed have in common?"
00:30:24 <arkeet> heh
00:30:24 <shachaf> Then he made every one of those a superclass of Conjoined.
00:31:17 <arkeet> oh I get the type of conjoined now.
00:31:21 <arkeet> that's pretty awful.
00:31:24 <shachaf> are you sad yet
00:31:27 <arkeet> yes
00:34:37 <shachaf> edwardk: conjoined made arkeet sad.
00:34:49 <arkeet> :-(
00:34:50 <edwardk> heh
00:34:52 <edwardk> sorry
00:34:54 <edwardk> it made code fast
00:34:58 <edwardk> so i'm not sorry ;)
00:35:51 <edwardk> conjoined as a class is 'everything you can say about both Indexed i and (->)
00:35:53 <shachaf> It's possible that the speed of your code divided by arkeet's happiness is a constant.
00:36:03 <arkeet> sounds likely
00:36:18 <edwardk> then it doesn't look good for arkeet
00:36:29 <edwardk> or wait
00:36:57 <edwardk> wouldn't it be times?
00:37:12 <shachaf> Oh, probably.
00:37:17 <arkeet> oh.
00:37:21 <arkeet> yes.
00:37:25 <shachaf> Yes, well, times.
00:37:30 <edwardk> i'm pretty happy with the speed divided by arkeet's happiness is a constant
00:37:31 <arkeet> or replace happiness with sadness.
00:37:44 <arkeet> I thought it said sadness, I think.
00:37:56 <shachaf> I'm not even sure what I meant anymore.
00:38:02 <edwardk> ok, anyone feel like trying to figure out where i'm being an idiot in this png writer?
00:38:07 <shachaf> But either one of those suggests a novel optimization strategy.
00:38:12 <edwardk> its likely the crc calculator
00:38:32 <edwardk> i have reference code in python to compare with
00:44:51 <charliesome> hey everyone, i'm having some trouble with cabal dependencies - my .cabal file and the output from running 'cabal build' are in this gist: https://gist.github.com/charliesome/ff09972a9adf23c2a7de
00:45:01 <charliesome> is anyone able to spot what i've done wrong?
00:45:35 <arkeet> charliesome: Perhaps you need to add `hscurses' to the build-depends in your .cabal file.
00:45:54 <charliesome> arkeet: it is there, on line 8
00:45:58 <arkeet> ofr the executable.
00:46:01 <charliesome> oh
00:47:45 <charliesome> so that worked
00:48:05 <charliesome> but why do i have to put the dependency? shouldn't it be a dependency of the library, not the executable?
00:48:24 <charliesome> i accidentally a word - why do i have to put the dependency there*
00:49:12 <int-e> charliesome: it's picking up the library source files when compiling the executable, which supersedes the compiled library. you'll have to move the library or the executable and use hs-source-dir, I think.
00:49:33 <absence> how does the <<loop>> detector work? does it trigger after N iterations?
00:49:49 <charliesome> int-e: ah!
00:50:44 <arkeet> absence: http://stackoverflow.com/questions/5126759/curious-about-how-loop-loop-is-evaluated-in-haskell
00:51:14 <charliesome> int-e: thanks, that did the trick
00:51:52 <absence> arkeet: thanks!
00:52:29 <arkeet> np :)
01:17:07 <pratz> Hello guys
01:17:25 <pratz> first time on haskell channel, just started learning
01:17:38 <pratz> here https://dpaste.de/k2uae/
01:19:26 <wollw> pratz: See what happens when you try calling them with "sayMe (1 :: Integer)"
01:21:10 <wollw> Int and Integer both have instances of Integral, but they are different types
01:22:16 <pratz> wollw: yes got it, type classes
01:23:44 <pratz> wollw: so in the paste, the first way I am saying that it should only be 'Int' and in the second way I am saying that it can be 'Int' or 'Integer', correct ?
01:24:22 <wollw> Pretty much, but the second one is also saying it can be anything else that later implements Integral.
01:24:41 <Lethalman> is there any tutorial on sodium that you know?
01:24:45 <AlecTaylor> hi
01:24:48 <Lethalman> i only see the freecell example
01:25:17 <wollw> pratz: See Data.Int for more types that implement Integral
01:26:24 <pratz> wollw: ok, thanks will do that, but for now I am going setp by setp http://learnyouahaskell.com/
01:26:42 <wollw> Fun book. :)
01:28:35 <AlecTaylor> pratz: I love that site :P
01:28:54 <wollw> That's where I got my start.
01:28:57 * AlecTaylor found it in a set of Scala slides a few days ago
01:37:26 <pratz> awesome guys
01:44:11 <Lethalman> or maybe I just stick with netwire
01:53:03 <tpsinnem> hey -- is this thing still true: http://www.haskell.org/haskellwiki/Let_vs._Where#Problems_with_where ?
01:53:13 <Taneb> mm_freak_, are you online?
02:08:00 <newbie2> hello
02:08:15 <newbie2> is composition of two functors a functor
02:08:37 <shachaf> Yes.
02:15:32 <Dodek> newbie2: if you spend a second thinking about it, it's totally obvious. if not, you probably don't know what a functor is, so it's too early to ask such questions.
02:35:04 <mm_freak_> Taneb: yes
02:35:30 <Taneb> mm_freak_, are you the person who writes netwire?
02:36:19 <arkeet> he is
02:36:33 <arkeet> I see he answered you about 26 seconds before you asked, though.
02:36:45 <Taneb> :P
02:36:53 * hackagebot clientsession 0.9.0.3 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.0.3 (MichaelSnoyman)
02:37:13 <Taneb> mm_freak_, I'm looking at the code on darcs
02:38:26 <Taneb> Can I ask why the Num instance etc all have a Monad constraint when the actual code requires Applicative?
02:43:58 <bennofs> Is it possible to call haskell closures from C? I.e. have a ffi function which I can pass a callback, which is a haskell function again?
02:46:35 <bennofs> Hmm, there is an example at http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
02:47:27 <mm_freak_> Taneb: because Applicative without being a superclass of Monad is really awkward
02:47:37 <mm_freak_> you would basically have to write (Applicative m, Monad m) everywhere
02:49:53 <Taneb> mm_freak_, but your code uses liftA2 and fmap rather than liftM2 and liftM
02:50:09 <Taneb> (in darcs HEAD)
02:50:10 <k0ral> Hello, I'm getting segfaults when using SSL with http-conduit; is that a known problem ?
02:56:10 <ManateeLazyCat> Hello, have anyone know a library get bash completions list with feed string?
02:57:12 <Dodek> is there a library that implements Text.Printf.PrintfType for ByteString ?
02:57:25 <Dodek> i just want to format a ByteString
03:14:05 <absence> if i read elements from a file, perform some computation on each element, and then write them to another file, i can lazily work through the file without taking up much memory. however, if the computation can fail using Maybe, sequenceA slurps the entire input and overflows the stack. i could use exceptions instead, are there other alternatives?
03:18:25 <m3ga> absence: other alternatives are the streaming I/O libraries like iteratee, conduit, pipes etc
03:20:54 <absence> m3ga: basically writing each element until there's a Nothing, instead of ensuring that no elements fail up front?
03:23:28 <augur> is there a way to make haskell unable to case on things?
03:26:54 * hackagebot ctrie 0.1.0.1 - Non-blocking concurrent map  http://hackage.haskell.org/package/ctrie-0.1.0.1 (MichaelSchroeder)
03:27:58 <Zenol> augur: Not sure I understand your question. Hidding constructors?
03:28:39 <augur> Zenol: sort of?
03:28:53 <augur> i mean, just to make it so that pattern matching is unavailable for a given type.
03:28:56 <augur> eg
03:29:08 <augur> data Hidden a = Hidden a
03:29:12 <augur> but where you can't do this:
03:29:17 <augur> foo :: Hidden a -> a
03:29:21 <augur> foo (Hidden a) = a
03:29:21 <arkeet> just don't export the constructor
03:29:42 <augur> arkeet: aha, so you'd have to put it into a separate module?
03:29:43 <augur> ok
03:29:44 <arkeet> yes
03:31:18 <augur> that's good. :D
03:31:55 <augur> that means that we can infact define IO as an ADT in Haskell, in a module that doesnt export the constructors
03:32:08 <augur> and as far as the rest of Haskell is concerned, the monad laws are satisfied
03:33:30 <arkeet> that is in fact what we do
03:34:34 <augur> arkeet: is that ALL we do, or does GHC do something cleverer
03:34:41 <augur> i thought it was cleverer than just that
03:35:06 <arkeet> well, there's some magic
03:35:11 <augur> there's always magic :)
03:35:33 <arkeet> anyway, constructor hiding can always be defeated by unsafeCoerce.
03:35:57 <augur> horrible
03:36:08 <augur> what if you unsafeCoerce an IO value?
03:36:14 <mauke> fun
03:36:23 <mauke> @src IO
03:36:23 <lambdabot> Source not found. Abort, Retry, Panic?
03:36:27 <mauke> panic, please
03:36:39 <augur> :t unsafeCoerce
03:36:40 <lambdabot> Not in scope: `unsafeCoerce'
03:36:43 <augur> D:
03:37:14 <arkeet> augur: yes, you can implement unsafePerformIO using unsafeCoerce.
03:37:16 <arkeet> if you're careful.
03:37:32 <augur> > unsafeCoerce (putStr "foo") :: String
03:37:34 <lambdabot>   Not in scope: `unsafeCoerce'
03:37:37 <augur> :(
03:37:45 <arkeet> it's not all that easy to get it to work right.
03:37:54 <haasn> your best bet is to find some public-facing unsafeCoerce in lens and abuse that :)
03:37:57 <arkeet> I can't remember if we figured it out probably.
03:38:11 <elliott> just define your own IO the same way. done.
03:38:17 <augur> elliott: what?
03:38:47 <arkeet> elliott: we tried some things but it would crash sometimes and stuff.
03:38:50 <arkeet> I don't know who "we" is.
03:39:04 <haasn> you, obviously
03:39:28 <newbie2> does Haskell have smth like PEP-8 for Python? I mean, code style.
03:40:50 <int-e> arkeet: I might be the guilty party, see http://lpaste.net/74498
03:41:19 <arkeet> you might have been involved yeah
03:45:19 <int-e> (then again, there's always  \f -> runST (unsafeCoerce f))
03:54:26 <haasn> edwardk: is there any hope for something like ()^!! repeated . (act.const $ fmap read getLine) . takingWhile (/=0)  ?
04:12:47 <Zenol> did someone know how to change the language used with yesod based on user preference ? (Seams that it was thought to translate the whole application at compile time, not to provide many languages to users :/)
04:15:46 <Twey> Zenol: http://www.yesodweb.com/book/internationalization
04:18:47 <Twey> Zenol: (specifically, use ‘setLanguage’)
04:19:36 <Zenol> Twey: oh, sorry, I didn't say there was an internationalization page. Thanks.
04:20:03 <adnap> Can someone explain "impredicative polymorphism"?
04:20:47 <donri> it's the same as copredicative comonomorphism ok not really
04:21:53 <pxqr> adnap: chapter 23 of "Types And Programming Languages" has some explanation
04:22:56 <dmwit> adnap: Can type variables be instantiated at polymorphic types? If yes, impredicative; if no, predicative.
04:23:57 <adnap> dmwit: I saw "at" here too: "This means that you can call a polymorphic function at a polymorphic types..." (http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/other-type-extensions.html) I don't know what is meant by "at".
04:24:02 <Twey> Is it possible to construct a type using ImpredicativeTypes that GHC can't type-check in finite time?
04:24:25 <dmwit> adnap: For example, suppose "cond :: a -> a -> a". In Haskell, "cond id :: (a -> a) -> (a -> a)". With impredicative types, you could have "cond id :: (forall a. a -> a) -> (forall a. a -> a)".
04:24:26 <Twey> adnap: ‘The value of f at x’ = ‘the return value of f applied to x’
04:25:17 <adnap> dmwit: I don't understand the difference
04:25:19 <Twey> The ‘call … at …’ phrasing seems to be a mix of the mathematical (‘value of f at x’) and comp-sci (‘call f with x’) terminologies to me
04:25:29 <pxqr> Twey: it's easier to do with UndecidableInstances
04:25:40 <Twey> dmwit: Isn't RankNTypes sufficient for that type?
04:25:53 <adnap> What is a "type variable"?
04:25:58 <dmwit> adnap: The former says: "pick a type and hand me a function on that type; I'll hand one back". The latter says: "hand me a polymorphic function, and I'll hand you one back".
04:25:59 <adnap> Is that like "a" or "b"
04:26:03 <Twey> adnap: Yes
04:26:03 <dmwit> yes
04:26:35 <adnap> dmwit: Isn'
04:26:45 <adnap> dmwit: Isn't the former implicitly polymorphic?
04:26:47 <pxqr> "cond :: a -> a -> a" is actually "cond :: forall a. a -> a -> a"
04:26:49 <dmwit> Twey: No.
04:26:59 <Twey> dmwit: Why not?
04:27:00 <dmwit> adnap: The polymorphism happens at a different point.
04:27:03 <adnap> pxqr: Oh, I see the difference now
04:27:22 <lpaste> dmwit pasted “cond id” at http://lpaste.net/92408
04:27:24 <pxqr> adnap: explicit forall omitted for clarity
04:28:12 <dmwit> Twey: Because you can't instantiate the "a" in cond's type polymorphically without impredicative types.
04:28:24 <dmwit> Twey: e.g. you can *write* the type I said, but you can't check it.
04:28:44 <Twey> Ah, right.
04:28:51 <pxqr> most types have simple type schemes without impredicativity; so any free type variables automatically bound by inferred foralls
04:29:22 <Twey> donri: ‘When in doubt, dualize’?
04:30:17 <dmwit> Twey: As for your question about ImpredicativeTypes in GHC, well, the answer is that ImpredicativeTypes probably does less than you think it does. =)
04:31:27 <dmwit> I have a vague memory that the right answer is "it does nothing any more". I won't swear by that answer, but at the very least it isn't even enough to give "cond id" my suggested type.
04:31:30 <donri> Twey: :) did you see the haskellcast
04:31:45 <adnap> dmwit: Does a have to represent the same type the function argument and the function result "cond id :: (forall a. a -> a) -> (forall a. a -> a)"?
04:31:47 <Twey> donri: Hehe, yeah
04:31:54 <dmwit> adnap: no
04:32:04 <donri> Twey: "prism is actually colens" "...of course they are"
04:32:31 <Twey> That actually seems pretty intuitive to me, given how edwardk explained it
04:32:43 <adnap> dmwit: I still don't understand "Can type variables be instantiated at polymorphic types?"
04:32:58 <adnap> dmwit: What is a "polymorphic type"?
04:33:04 <dmwit> adnap: One with a forall in it. =)
04:33:09 <donri> Edward Comett
04:33:19 * Twey chuckles.
04:33:20 <adnap> dmwit: What does it mean for a type variable to be instatiated at a polymorphic type
04:33:33 <dmwit> adnap: It means you replace all occurrences of that type variable with a polymorphic type.
04:33:47 <adnap> dmwit: Oh
04:33:58 <Ghoul_> is this regular guard syntax or some extension:
04:34:02 <dmwit> To be precise: you replace all occurrences of that type variable with *the same* polymorphic type.
04:34:14 <adnap> dmwit: So the transformation is actually from specific to general, which is not what I expected
04:34:16 <Ghoul_> | condition, x <- 3 * 3, x > 2 = expr ...
04:34:54 <dmwit> adnap: er, what?
04:34:55 <Twey> adnap: It means you can have x ∷ (∀ a. a → a) and call ‘Just x’ to get a value of type ‘Maybe (∀ a. a → a)’
04:35:09 <Ghoul_> > let f x | x < 2, a = 3 * 3, a >= 6 = 3 in f 1
04:35:11 <lambdabot>   <hint>:1:27: parse error on input `,'
04:35:45 <dmwit> Ghoul_: It's an extension. Not sure which one; maybe ViewPatterns?
04:35:50 <dmwit> Pattern guards?
04:36:03 <dmwit> Probably PatternGuards.
04:36:12 <Twey> PatternGuards
04:36:28 <adnap> "type variable instatiated at a polymorphic type" seems like bad English
04:36:29 <Twey> Assuming a is a pattern or boolean expression
04:36:45 <Ghoul_> its PatternGuards
04:36:48 <Twey> adnap: instantiated** — this is why ;)
04:36:56 * hackagebot HaTeX 3.7.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.7.0.0 (DanielDiaz)
04:36:57 <Ghoul_> I've fallen in love with PatternGuards
04:37:07 <Ghoul_> I first viewed them in the ddc source, and now I can't do anything without them
04:37:08 <adnap> So... a is instatiated at... what?
04:37:18 <Ghoul_> there was that odd syntax gap I could never get rid of, and this fits it perfectly
04:37:18 <Twey> :t Just (3 :: Int)
04:37:19 <lambdabot> Maybe Int
04:37:29 <adnap> Is "impredictive types" a place?
04:37:33 <Twey> :t Just
04:37:34 <lambdabot> a -> Maybe a
04:37:37 <adnap> Er
04:37:42 <adnap> *polymorphic type
04:37:51 <Twey> adnap: The type variable ‘a’ has been instantiated with the type ‘Int’.
04:37:52 <donri> so why did pattern guards make it into 2010 but view patterns didn't?
04:38:05 <Ghoul_> did they? thats cool
04:38:16 <Twey> donri: Aye.  ☹
04:38:16 <dmwit> adnap: Prepositions are pretty much arbitrary in all languages.
04:38:22 <dmwit> adnap: Suppose I shout at you. Are you a place?
04:38:25 <Ghoul_> imo view pattern syntax doesn't make sense to me
04:38:37 <adnap> type variable instatiated at a polymorphic type means "It means you replace all occurrences of that type variable with a polymorphic type."
04:38:38 <Ghoul_> because the arrow symbol means something different in most cases
04:38:45 <dmwit> adnap: "at" is just the preposition that goes with "instantiate". It's nothing to get weird about. =)
04:38:58 <Twey> Ghoul_: Because the arrow symbol totally wasn't overloaded already.  :þ
04:39:01 <adnap> dmwit: No, I really can't understand the concept. I'm not just nitpicking the wording
04:39:05 <Ghoul_> lol
04:39:10 <Twey> It doesn't mean anything there without ViewPatterns, though.
04:39:19 <Twey> (hence requiring the brackets)
04:39:28 <donri> Ghoul_: i think trying to make haskell syntax simple and consistent is a lost cause
04:39:29 <Ghoul_> its just, the arrow has always meant some flow
04:39:35 <dmwit> adnap: Okay, maybe I don't understand your complaint yet, then.
04:39:36 <Ghoul_> whereas they just pulled it out and made it an application
04:39:47 <Ghoul_> and it seems a bit unco imho
04:40:03 <adnap> dmwit: So, this sentence which makes no sense somehow corresponds to taking (a -> a) and making it (forall a. a -> a)
04:40:12 <Twey> Ghoul_: That's vague enough that it can fit if you want it to.  ‘The argument is flowing through the function before being matched.’ :þ
04:40:18 <dmwit> adnap: Are you familiar with substitution in the lambda calculus?
04:40:22 <adnap> dmwit: No
04:40:32 <Ghoul_> thats exactly what came into my head after I wrote that :P
04:40:38 <dmwit> adnap: I see. I won't use that to explain it, then. =)
04:40:47 <adnap> If (a -> a) can be made into (forall a. a -> a) then a is impredictive?
04:40:47 <Twey> Heh
04:41:00 <dmwit> adnap: Let's start slower.
04:41:17 <dmwit> adnap: Because that question is confused, but natural given the discussion so far. So let's back up.
04:41:23 <donri> i want => for -> Just, though
04:41:53 <dmwit> adnap: Starting now, let's always explicitly write "forall" any time we want it. In Haskell 2010, "forall" is never written and always understood to be at the beginning of the type.
04:41:54 <Ghoul_> are MultiParamTypeClasses ever going to be standardised?
04:41:55 <Twey> donri: Why?
04:42:02 <Ghoul_> or GADT's?
04:42:15 <dmwit> adnap: So, for "id"s type, in Haskell we write "a -> a" but this is understood to mean "forall a. a -> a" when we're writing explicit foralls every time.
04:42:18 <dmwit> adnap: Good so far?
04:42:40 <donri> Twey: because it's so common, and it reads more as "if this matches" than "if this is a Just"
04:43:28 <donri> Twey: a bit like guards vs. pattern matching on Bool :p
04:43:39 <Twey> donri: You're suggesting writing f (g ⇒ y) as sugar for f (g → Just y)?
04:43:52 <donri> Twey: yes
04:44:06 <Twey> Nah, don't like it
04:44:12 <donri> Twey: http://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitMaybe
04:44:14 <donri> not my idea :)
04:44:25 <Twey> In principle, sure, but it should be more general
04:44:32 <Twey> Rather than restricted to Maybe
04:44:34 <donri> Twey: you'd still have ->
04:44:41 <dmwit> Twey: Well, would you like it if f (g => y) was sugar for f (g -> SecondConstructorOfWhateverAppropriateType y)? =)
04:44:44 <dmwit> Coq-style
04:44:45 <Twey> I know, I just don't like syntactically privileging Maybe
04:45:02 <Twey> Not the second constructor, no :þ  Possibly some typeclass
04:45:13 <dmwit> I know. It was a joke. =)
04:45:13 <adnap> dmwit: Yes
04:45:14 <donri> Twey: lots of types are syntactically privileged
04:45:23 <Twey> Ah, okay :þ
04:45:34 * Twey makes a note to pay attention to emoticons
04:45:44 <Twey> That's pretty terrifying.  I wish Coq didn't do that.
04:45:57 <donri> Twey: shrug, type class could be fine. OverloadedMaybe? :D
04:46:14 <dmwit> adnap: Okay. So now we can distinguish between "forall a. a" (which is the type of a function that takes a type and returns a value of that type) and "a" (which is the type of a value of some unknown type).
04:46:39 <Twey> donri: Haha
04:46:42 <dmwit> adnap: Now, "substitution" is the act of taking a type with variables in it and replacing those variables with other types.
04:47:10 <donri> Twey: then again, do you also think if/guards should be overloaded?
04:47:24 <dmwit> adnap: Let's write "t1[t2/a]" for the substitution that replaces all occurrences of the variable "a" with "t2" in "t1".
04:47:40 <Twey> donri: I don't think lots of types are.  Lots of *typeclasses* are, but the only type I can think of with syntactic privilege is String, and that's being challenged
04:47:48 <Twey> Oh, and Bool, right.
04:47:59 <donri> Twey: [and list, but also challenged. but bool is my main point here :)]
04:48:02 <Twey> Guards are overloaded with pattern guards
04:48:06 <Twey> I don't really approve of if
04:48:12 <dmwit> adnap: So, for example, "(a -> b -> c)[Int/b]" is "a -> Int -> c".
04:48:32 <Twey> (MultiWayIf + PatternGuards fixes that, anyway)
04:48:39 <donri> Twey: yeah. i wish we had bool :: a -> a -> Bool -> a in the prelude and possibly no if statement at all
04:48:46 * Twey nods.
04:49:05 <dmwit> adnap: And "(a -> a -> a)[String -> String/a]" is "(String -> String) -> (String -> String) -> (String -> String)".
04:49:09 <Twey> Or more generally a → b → Bool → Either a b
04:49:19 <Twey> Or possibly both
04:49:31 <dmwit> adnap: BUT importantly "(forall a. a)[Int/a]" is still "(forall a. a)".
04:49:49 <dmwit> adnap: So we only look at type variables that aren't wrapped up in "forall"s.
04:50:00 <dmwit> adnap: Okay, time to take a breath. Still with me? If not, how far have I dragged you?
04:51:32 <Twey> adnap: (this is the same mechanism function application uses, except the ‘application’ is implicit in Haskell)
04:51:46 <Ghoul_> I agree with the 'get rid of if' thing
04:52:02 <Ghoul_> I would like a way to break into a guard in the middle of a function though
04:52:07 <Ghoul_> like, an anonymous guard
04:52:15 <Ghoul_> anyone know the best way to do that?
04:52:35 <Twey> Ghoul_: You mean, to fail the current pattern and try the next one?
04:52:44 <dmwit> Ghoul_: MultiwayIf?
04:52:52 <Ghoul_> multi-way if, I guess
04:53:00 <Ghoul_> but does that work with the guard extension?
04:53:09 <Ghoul_> because those are awesome..
04:53:09 <dmwit> All extensions work together.
04:53:14 <Twey> Ghoul_: Yes; MultiWayIf is just sugar for case () of () | …
04:53:16 <dmwit> It's a pretty amazing feat, in my opinion.
04:53:22 <Ghoul_> <3
04:53:22 <Twey> Heh.
04:53:41 <Ghoul_> I didn't think of case () of () ...
04:53:43 <Ghoul_> thats clever
04:53:43 <Twey> Yes, it's quite surprising.
04:53:49 <donri> Twey: it's not really, because no layout
04:54:07 <Twey> donri: Layout is sugar too :þ
04:54:08 <donri> Twey: can't nest multiway ifs without parenthesis
04:54:17 <Twey> That's a shame
04:54:50 <Twey> … I think
04:54:51 <donri> and worse it can lead to code compiling that doesn't do what you intended :p
04:55:10 <Eduard_Munteanu> Should something like  foo = mkName "Foo"  declareFoo = [d| type $foo = Bar |]   work? I want to avoid constructing declarations manually in the AST form.
04:55:48 <Eduard_Munteanu> GHC complains about '$foo'.
04:56:03 <dmwit> Eduard_Munteanu: I think any code you call from Template Haskell has to be in a separate module that can be compiled first.
04:56:13 <dmwit> (Which seems like a reasonable restriction to me.)
04:56:29 <Ghoul_> one case I find that the guard extensions help a lot is when I need to check a condition, do something with that result, and then check it again, falling through to my error case or whatever if anything fails
04:56:30 <dmwit> s/first/before the one that's calling it/
04:56:50 <Eduard_Munteanu> dmwit: hm, but what if I have a function that gets some parameters and constructs a declaration?
04:57:30 <Eduard_Munteanu> I guess I have to '/''-quote stuff and call something from a different module?
04:57:33 <donri> Twey: http://ghc.haskell.org/trac/ghc/ticket/4359#comment:89
04:57:47 <Eduard_Munteanu> Actually that doesn't solve the issue.
04:58:08 <dmwit> Eduard_Munteanu: I'm not sure. I don't know too much about Template Haskell. I also don't really understand your question very well; perhaps in part because of the previously-mentioned inexperience.
04:58:09 <Eduard_Munteanu> Because I still want to refer to stuff from a [d| ... |]
04:58:50 <Twey> donri: Is it still eligible for a syntax change?
04:59:16 <mstksg> is there something like a general fromJust?  like i have  a data type that contains a value and i just want to get teh contained value from the container without having to use a case statement for pattern matching
04:59:24 <donri> Twey: no clue how these things work. they do seem to break extensions liberally (cf. type operators)
04:59:30 <Eduard_Munteanu> I see. Let me rephrase that anyway... I want to do something like   foo :: Name -> Q [Dec]   foo n = [d| type $n = Bar |]
04:59:56 * Twey nods.
05:01:01 <Ghoul_> > let f (a b) = b in f (Just 3)
05:01:02 <lambdabot>   <hint>:1:8: Parse error in pattern: a
05:01:07 <donri> honestly maybe it should've been inverted from the get-go: types are lowercase, type variables upper case, because they're a bit like pattern matches :p and then current type operators would be consistent
05:01:07 <Twey> mstksg: What you want to do may not even be allowed by or make sense for the datatype (e.g. IO ‘contains’ a value in some sense, but you can't just pluck it out; you have to execute the action in order to get the value)
05:01:08 <Ghoul_> heh, no.
05:01:12 <Eduard_Munteanu> mstksg: depends on the usecase... if you want to transform stuff you can fmap
05:01:15 <Ghoul_> That was being optimistic.
05:01:28 <Twey> Ghoul_: No, but see http://en.wikipedia.org/wiki/Pattern_calculus
05:01:45 <donri> uuuh but then again no. gah it's all a mess
05:02:12 <Twey> mstksg: Stylistically, it's a bad idea because such a function is necessarily partial
05:02:12 <mstksg> specific usecase is for example, pandoc inline elements are of the type Inline, with a constructor Plain (t :: String)
05:02:17 <Twey> (as with fromJust)
05:02:34 <mstksg> so i'm looking for a generalized way to write fromPlain
05:02:51 <mstksg> but i guess this is something that cannot be type checked
05:03:14 <dmwit> You could write a type class for it. But it wouldn't really save you much, I think; you'd still have to implement all the instances.
05:03:16 <Twey> mstksg: The idea is that you should pattern-match on the argument, thereby simultaneously ensuring that it's the constructor you want *and* extracting the value
05:03:19 * marienz raises an eyebrow
05:03:34 <marienz> is that a misbehaving client of someone who belongs here?
05:03:36 <mstksg> is there a more experssive syntax for pattern match then?
05:03:39 <donri> would it be possible/useful/sensible to allow repeating bindings in a pattern, say, (a,a) as a pattern desugars to say, (a,b) | a == b
05:04:05 <dmwit> donri: Yes. Agda does something like this.
05:04:08 <Twey> donri: Erlang does that
05:04:10 <donri> it privileges Eq which is already the case for Num/IsString...
05:04:11 <mstksg> er, not expressive, but terse.
05:04:30 <Twey> Agda's uses its judgemental equality, I think
05:04:55 <AlecTaylor> What's a nice design pattern for constructing abstract syntax trees; and then evaluating their expressions?
05:05:00 <donri> agda/idris seem crazy to me though, no syntactical hints what's a binding and what's a constructor?
05:05:00 <dmwit> Dude, don't insult Agda's equality.
05:05:01 <Twey> mstksg: Pattern-matching can't really be made any terser :þ
05:05:06 <Eduard_Munteanu> Hm, not even [d| type $(mkName "Foo") = Char |] works. :/
05:05:12 <elliott> donri: you get syntax-highlighting hints
05:05:15 <elliott> well, for agda.
05:05:30 <Twey> donri: Bindings are all explicit
05:05:31 <donri> well, for agda-*mode*?
05:05:38 <dmwit> AlecTaylor: Design pattern?
05:05:41 <elliott> it gets highlighted when you C-c C-l
05:05:51 <AlecTaylor> dmwit: Yeah, you know; like "Visitor Pattern"
05:05:51 <elliott> I agree agda without editor support is wretched pain :p
05:05:57 <Twey> You don't get a different syntax for bindings in Agda for the same reason you don't get a different syntax for function arguments in Haskell :þ
05:06:07 <mstksg> Twey: is there an inline pattern match syntax?
05:06:24 <Twey> mstksg: There is \case now; can't remember what the extension is called
05:06:48 <Twey> LambdaCase, I think
05:06:52 <donri> Twey: i mean if you type "nothing" in a pattern it's either gonna be their "Nothing" constructor or a binding matching anything and binding it to "nothing">
05:06:54 <dmwit> Well, I guess there's Scrap Your Boilerplate and Uniplate and Multiplate and all those.
05:06:54 <donri> ?
05:06:59 <dmwit> AlecTaylor:
05:07:22 <dmwit> ...and GHC's Generic stuff, I guess.
05:07:25 <Twey> donri: Yeah, that happens; I've spent some time debugging that :þ
05:07:26 <donri> Twey: in haskell you can tell by case
05:07:46 <Twey> Yeah, Agda is quite context-sensitive
05:08:01 <donri> Twey: it also seems refactoring-hostile, unless i've misunderstood it. what happens if you later introduce a constructor whose name is used as a pattern binding elsewhere?
05:08:03 <Twey> But, well, that's only one of several things that introduces that problem
05:08:44 <AlecTaylor> dmwit: You sent me a blank expression?
05:09:10 <dmwit> AlecTaylor: I was highlighting your name to let you know that I was talking to you, because there are several discussions. Sorry for not putting your name in front of the actual load-bearing message; it was an oversight.
05:09:26 <Twey> donri: Error
05:09:36 <Twey> It's wise to be careful what you import :þ
05:09:44 <AlecTaylor> oh, read below it not above it
05:09:49 <AlecTaylor> dmwit^
05:09:51 <adnap> dmwit: Everything makes sense except "forall a. a" (which is the type of a function that takes a type and returns a value of that type)". What do you mean it takes a type? functions usually take values, right?
05:10:24 <donri> Twey: sounds nightmarish :p
05:10:30 <Twey> Agda could probably use a type-aware check when deciding whether it's a variable or a constructor; not sure if it's worth it for something that's ultimately meant to be a proof assistant, though
05:10:43 <dmwit> adnap: Usually, yes. We're living in a hypothetical world where forall's are explicit and "function" means something more general than usual.
05:10:46 <Twey> I don't know how Idris handles that
05:11:06 <dmwit> AlecTaylor: Well, both above and below, in this case, but yes. =)
05:11:24 <adnap> dmwit: I don't understand how "forall a. a" takes and returns. It seems only have one parameter
05:11:43 <dmwit> adnap: Okay, let's talk about that, then.
05:12:46 <dmwit> adnap: So, I like to use the function terminology for polymorphism.
05:13:06 <dmwit> adnap: That is, I like to think of polymorphic things as being functions from types to monomorphic things.
05:13:35 <dmwit> adnap: For example, "id :: forall a. a -> a" is the function that takes (for example) the type "Int" and returns the identity function on "Int"s.
05:13:47 <dmwit> adnap: or that takes "Bool" and returns the identity function on "Bool"s.
05:14:15 <dmwit> adnap: We could formalize this if we wanted by adding new syntactic forms for type-functions and type application.
05:14:21 * erisco sighs
05:14:39 <erisco> built a lot of stuff with lists, now I really need a list with length
05:14:58 <dmwit> adnap: For example, we might write /\a -> e is a type function (like \x -> e for value functions) and e @ t for type application (like e1 e2 for value application).
05:15:12 <erisco> simultaneously, not everything needs to keep track of length
05:15:17 <erisco> just some things
05:15:36 <Ghoul_> erisco: do the lists change, or do you just need to cache their length?
05:15:47 <dmwit> adnap: Then for "id" we could write "id = /\a -> \(x :: a) -> x" to be completely clear about what functions we're writing. And Haskell's "id 3" would just be sugar for "id @Int 3".
05:15:54 <erisco> "do the lists change" I don't know what that means, since lists are immutable
05:16:02 * Twey wonders how well-designed a syntax really is when the best way to explain it is to make up an imaginary syntax and talk about that instead
05:16:07 <erisco> but yes, I need to calculate their length in O(1) time, and a "cache" would do that
05:16:25 <dmwit> Twey: Having many intermediate languages is very normal for compilers. =)
05:16:26 <Twey> erisco: Have you considered a Data.Vector?
05:16:34 <dmwit> Twey: Now we're turning ourselves into compilers, so...
05:16:42 <Twey> dmwit: Fair enough, I suppose
05:16:43 <Ghoul_> Twey: I dont think he wants to rewrite his program
05:17:02 <Twey> I'd still welcome more explicit type-functions, though
05:17:06 <Ghoul_> data Length a = Length Int [a]
05:17:25 <Twey> Ghoul_: Integer.  ☹
05:17:31 <Ghoul_> len b = Length (length b) b
05:17:32 <Ghoul_> lol
05:17:49 <dmwit> adnap: As another example, in Haskell, we might write "cond :: a -> a -> a; cond = \x -> \y -> x". In our hypothetical language, we would write "cond :: forall a. a -> a -> a; cond = /\a -> \(x :: a) -> \(y :: a) -> x" instead.
05:17:51 <Ghoul_> I dont think you can fit the maxbound of a 64-bit int on any machine right now
05:17:56 <erisco> oh, I could rewrite the program, but as I said, there are only certain cases where I need to keep track of length
05:17:58 <Ghoul_> in lists
05:18:09 <Twey> Ghoul_: You can quite easily with [()]
05:18:15 <Ghoul_> :|
05:18:23 <erisco> so it seems to beg for a lame typeclass for lists and "lists with length"
05:18:24 <Twey> And Int isn't always 64-bit
05:18:37 <Ghoul_> lists have like a 12-or-so byte overhead anyway, don't they?
05:18:46 <Twey> Also, Int just isn't nice :þ
05:18:55 <dmwit> Twey: There was a student here over the summer adding explicit type application to GHC. So maybe it's coming. =)
05:19:00 <Twey> Ghoul_: IIRC [()] can be/is optimized as a natural
05:19:01 <erisco> (I can keep track of length everywhere, but it is a silly redundancy most of the time)
05:19:03 <Twey> dmwit: \o/
05:19:12 <Ghoul_> anyway, thats close to 100gb
05:19:17 <Ghoul_> with any type plus list overhead
05:19:22 <dmwit> adnap: Pausing again. Let me know if I'm making sense.
05:19:24 <Ghoul_> we'll be able to in the next few years hehe
05:19:40 <Ghoul_> Integer for future-proofing :)
05:19:56 <Twey> Ghoul_: Lazy language, remember?
05:20:12 * Ghoul_ 's thing gets blown out of the ball park
05:20:45 <Twey> A list doesn't have to take up the space of all its elements
05:20:49 <reubensammut> quit
05:20:57 <erisco> Twey, I depend on O(1) cons, but otherwise is a reasonable suggestion
05:21:06 <Twey> And length on such a list should be well-defined, since there's no need to keep seen elements around
05:21:08 <erisco> Twey, Seq would do what I need, I suppose
05:21:22 <adnap> dmwit: "and e @ t for type application" doesn't make sense. What is "type application". Also, I don't see how the syntax matches in "Haskell's "id 3" would just be sugar for "id @Int 3""
05:21:37 <adnap> dmwit: Everything else makes sense
05:21:42 <erisco> Twey, what do you mean "well defined length"? how can it be ill-defined?
05:22:10 * marienz raises another eyebrow
05:22:11 <Ghoul_> A gremlin sneaks a -1 into your length
05:22:25 <Twey> erisco: Seq seems like a good choice, yeah
05:22:45 <Twey> erisco: length doesn't terminate on e.g. [1 ..]
05:22:46 <dmwit> adnap: "type application" is supplying a type to a type function. Haskell's "id 3" matches with hypothetical language's (let's call it hypolang) "(id @ Int) 3" -- first apply "id", which is a type function, to type "Int", then apply the result (which is an "Int -> Int" function) to 3.
05:22:59 <adnap> dmwit: I assume by "value application" you mean function application, like "(+2) 3", but if not, I need clarification on that term too
05:23:07 <erisco> Twey, a list with length is necessarily finite
05:23:09 <Twey> erisco: But there's no reason it shouldn't terminate on [1 .. 1e100]
05:23:16 <dmwit> adnap: correct assumption
05:23:22 <erisco> Twey, and could be constructed as a list of tuples
05:23:24 <Twey> erisco: I know; I was discussing Ghoul_'s choice of length type
05:23:39 <Twey> erisco: Are you talking about type-level length or value-level length?
05:23:55 <Twey> … er, never mind; obviously value-level
05:24:05 <erisco> I am not talking about dependent types, if that is what you mean
05:24:19 <Twey> Not at all.  ☺
05:24:25 <adnap> dmwit: Okay, everything makes sense
05:24:29 <dmwit> adnap: okay
05:25:06 <dmwit> adnap: So, let's see where we've gotten ourselves. We've defined a hypothetical language with explicit polymorphism, and defined "substitution" on types.
05:25:25 <adnap> dmwit: (Everything since we started "slower")
05:25:56 <dmwit> adnap: "instantiation" is essentially another term for "substitution", except that you first strip a "forall". It corresponds to what we have to do at the type level when we use @ on the term level.
05:26:07 <adnap> dmwit: With the forall syntax, are the variable before the period the type variables?
05:26:16 <dmwit> adnap: yes
05:26:33 <kqr1> is there a quick way of doing `Map k (IO a) -> IO (Map k a)'? i couldn't find anything on hoogle immediately
05:26:38 <erisco> Ghoul_, the data constructors would be hidden, of course
05:26:56 <dmwit> adnap: So, again using "id" as an example, its type is "forall a. a -> a". We can instantiate this type at Int by removing the forall and substitution Int for a: "(a -> a)[Int/a]" or just "Int -> Int".
05:26:57 * hackagebot network-conduit-tls 1.0.1.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.1.1 (MichaelSnoyman)
05:27:13 <dmwit> adnap: This is what happens at the type level when we do type application with @.
05:27:43 <kqr1> or wait. never mind. this might be a case for the applicatives
05:28:27 <Twey> kqr1: Looks like some kind of ‘sequence’
05:28:35 <dmwit> adnap: Similarly, we could instantiate the type of "cond :: forall a. a -> a -> a" at type (say) "Maybe Int" to get "cond @ Maybe Int :: Maybe Int -> Maybe Int -> Maybe Int".
05:29:25 <Twey> kqr1: Hm, but I'm not sure it's a great idea.  The result depends on the order of the map.
05:29:38 <adnap> dmwit: What is the "term level"? What does "use @ on the term level" mean?
05:30:39 <erisco> sorry, pretty sure I've had this explained to me before, but why is there no type class for cons and elem?
05:30:40 <kqr1> Twey, true
05:30:55 <erisco> cons :: a -> f a -> f a, elem :: a -> f a -> Bool
05:30:58 <Twey> kqr1: It's sequenceA if Map k is Traversable
05:31:06 <dmwit> adnap: Well, we have a "type level" language: base types like Int, Bool, String; arrow types like t1 -> t2 for types t1 and t2; type variables like a, b, c; forall types like forall a. t1 for variables a and t1; type application like t1 t2 for types t1 and t2; etc.
05:31:18 <Twey> But I suspect there's no Traversable instance around because of the order messiness
05:31:29 <erisco> forall x, xs :  x elem (cons x xs) == True
05:31:46 <erisco> call it "Bag" or something
05:32:11 <dmwit> adnap: And we have a "term level" language: base values like 0, 1, 2, True, False; variables like x, y, z; functions like (\(x :: t) -> e) where x is a variable, t is a type, and e is a term; type functions like /\a. e where a is a type variable and e is a term; etc.
05:32:40 <dmwit> adnap: (oops, forgot term application e1 e2 for terms e1 and e2; type application e1 @ t for term e1 and type t)
05:33:06 <kqr1> Twey, okay
05:33:16 <erisco> could do uncons as well
05:33:55 <dmwit> adnap: So, saying "use @ on the term level" is a bit redundant, since "@" isn't part of the type level language. But I wanted to emphasize that there's a parallel there between something happening at each level.
05:34:08 <Eduard_Munteanu> I'm using GHC 7.4.2. This still doesn't work:    test :: Name -> Q [Dec]    test n = [d| data $n = Foo Char |]    gives me    Malformed head of type or class declaration: $n
05:34:09 <dmwit> adnap: On the type level, the thing happening is instantiation; at the term level, the thing happening is @.
05:34:31 <erisco> uncons :: f a -> Maybe a     forall xs  if uncons xs is not Nothing, then (uncons xs) elem xs is false iff for all y in xs, y != x
05:34:54 <erisco> sorry slightly wrong
05:35:26 <erisco> uncons :: f a -> Maybe (a, f a) ... correct the law as obvious
05:35:27 <adnap> dmwit: But @ is just a term you made up to describe something that happens only at the type level, right? Is there anything in real Haskell at the term level that decribese type application?
05:35:48 <Eduard_Munteanu> Which is annoying because I thought I could avoid writing ugly expressions for that stuff.
05:35:54 <dmwit> adnap: In Haskell, all @'s are implicit. They're inferred for you by GHC during type inference.
05:36:00 <erisco> mm, will play with this I guess.
05:36:08 <adnap> dmwit: Okay, everything makes sense
05:36:20 <dmwit> adnap: (This is similar, but not quite the same as all forall's being implicit: there, nothing is inferred, and they're always put outermost.)
05:36:55 <adnap> dmwit: Wait
05:37:11 <adnap> dmwit: What is the difference between substitution and type application?
05:37:41 <dmwit> Substitution is the name for the process we do to transform one type into another by replacing type variables.
05:37:54 <dmwit> Type application is the name for the term that involves a term and a type.
05:38:08 <dmwit> To check the type of a type application, we'll have to perform substitution.
05:38:24 <adnap> Okay
05:38:41 <adnap> So substitution could also replace a type variable with another type variable
05:38:46 <dmwit> It could!
05:38:57 <kqr1> does #haskell prefer `flip id' or `flip ($)'? the latter seems more descriptive to me than the former, but i don't know if the former has some sort of mathematical rooting that we should take care of. (lambdabot seems so suggest the former when I asked for the pointless version of it)
05:39:15 <dmwit> For example, consider the Haskell term "id id". What would this look like in hypolang?
05:39:35 <Twey> kqr1: You can always do: fmap M.fromList . sequenceA . fmap (uncurry $ fmap . (,)) . M.toAscList
05:39:48 <merijn> kqr1: #haskell prefers & from lens :p
05:39:51 <dmwit> Well, it's a bit tricky to answer, actually! In Haskell, the type of "id id" is "a -> a", so its corresponding type in hypolang should be "forall a. a -> a".
05:40:05 <bergmark> kqr1: i think flip ($) is clearer
05:40:13 <merijn> :t (&)
05:40:14 <lambdabot> a -> (a -> b) -> b
05:40:15 <dmwit> So we can guess it will start with a /\.
05:40:21 <kqr1> Twey, that's what i was afraid of... i prefer my way in this case
05:40:25 <Twey> I like ‘flip id’ more
05:40:32 <Twey> kqr1: What's your way?
05:41:17 <dmwit>  /\a -> (id @ {- hole one -}) (id @ {- hole two -})
05:41:38 <dmwit> Now, we know what hole two should be, since we want the whole thing to be "a -> a".
05:41:50 <kqr1> Twey, i could use <$> to generate an [IO (Map k a -> Map k a)] instead of the [Map k (IO a) -> Map k (IO a)] i thought about first
05:41:58 <kqr1> Twey, and then the rest was just a sequence away!
05:41:59 <dmwit>  /\a -> (id @ {- hole one -}) (id @ a)
05:42:45 <dmwit> But now, since "(id @ a) :: a -> a", we must have "(id @ {- hole one -}) :: (a -> a) -> (a -> a)"!
05:42:56 <dmwit> So the first hole should be filled in like this:
05:43:04 <dmwit>  /\a -> (id @ (a -> a)) (id @ a)
05:43:38 <adnap> id id :: forall a. (forall a. a -> a) -> (forall a. a -> a) ?
05:43:39 <dmwit> So here we have *two* cases where substitution is replacing type variables with other types with variables in them.
05:43:49 <Ghoul_> flip ($) looks clearer to me
05:43:52 <dmwit> adnap: Well, that's the crux of the problem right there.
05:43:57 <Ghoul_> it also looks like an implied $, which is nice.
05:44:20 <adnap> dmwit: You're not very good with puzzles :P You start spoiling them right away
05:44:33 <dmwit> adnap: You might wish that since "id :: forall a. a -> a", we could write "(id @ (forall a. a -> a)) id" and get something of type "(forall a. a -> a) -> (forall a. a -> a)".
05:44:41 <Twey> kqr1: That seems greatly superior in many ways
05:44:50 <dmwit> adnap: er
05:44:52 <dmwit> sorry =P
05:45:17 <dmwit> adnap: But I'm spoiling this one for a good reason, because the obvious thing and the thing Haskell does are very different here.
05:45:42 <dmwit> adnap: Oh, also, that last sentence I wrote with types in it wasn't precise. Let me try again.
05:46:29 <dmwit> adnap: You might wish that since "id :: forall a. a -> a", we could write "id @ (forall a. a -> a) :: (forall a. a -> a) -> (forall a. a -> a)", so that "(id @ (forall a. a -> a)) id :: forall a. a -> a".
05:46:46 <dmwit> adnap: But this is explicitly *not* what happens in GHC or any other Haskell compiler.
05:47:31 <dmwit> adnap: So you should compare carefully this way of annotating "id id" and the other one I suggested to see what differs.
05:47:41 <adnap> dmwit: I am totally lost. I tried reading your answer. I don't understand what a "hole" is or how you knew we--grr
05:48:19 <dmwit> Oh. Well, that was nothing special, really. I was just writing "here's the bits we know and here's the bits we haven't figured out yet".
05:48:27 <dmwit> The holes are the bits of the puzzle we haven't figured out yet.
05:49:23 <Ghoul_> how do I check if something is a multiple of something in a true/false manner
05:49:42 <dmwit> :t \x y -> x `mod` y == 0
05:49:43 <lambdabot> Integral a => a -> a -> Bool
05:49:44 <arkeet> > 6 `mod` 2 == 0
05:49:45 <lambdabot>   True
05:49:50 <jophish> Can anyone point me in the direction of any documentation about going from a language such as Haskell to something like Hindley-Milner or System F?
05:50:08 <Ghoul_> thats what I originally thought, but its more verbose than I was hoping
05:50:13 <jophish> In particular making things like Lists and Tuples efficient
05:50:29 <dmwit> jophish: Hindley-Milner is how you go from Haskell to System F.
05:51:04 <dmwit> jophish: Oh, for a fast implementation you have to extend System F with data types.
05:51:06 <jophish> dmwit: oh, I thought it was a less complex system F
05:51:20 <dmwit> Yes, the mapping is not surjective.
05:52:09 <dmwit> adnap: I still want to help, but not sure how at the moment. Please ask me a question.
05:52:23 <kttm> hello, what can I do for this http://lpaste.net/92409 ?
05:52:29 <tarrasch> Ghoul_, well, part of functional programming is to build bigger functions from smaller ones. If you find yourself doing the divisibility test a lot you should probably make a separate function for it
05:52:54 <jophish> dmwit: Don't you mean bijective? If it's a restriction of System F wouldn't a mapping to HM be Surjective?
05:53:10 <dmwit> jophish: HM is not a system; it's an algorithm.
05:53:22 <dmwit> And I don't mean bijective.
05:53:58 <dmwit> "The mapping is not surjective" is just another way of saying "it translates to a less complex system than system F".
05:54:39 <jophish> dmwit: what should I say to refer to the syntax of HM
05:54:42 <dmwit> (I mean, yes, clearly if it is not surjective it is also not bijective. Saying it is not surjective is stronger.)
05:54:58 <dmwit> jophish: What is the syntax of HM?
05:55:13 <jophish> http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner#Syntax
05:55:51 <Eduard_Munteanu> Looks like this problem: http://ghc.haskell.org/trac/ghc/ticket/4230
05:56:07 <Eduard_Munteanu> I guess I see why lens has [d| ... |] but all commented out. :)
05:56:42 <dmwit> Hm. According to that Wikipedia page, HM is the system and Algorithm W is the algorithm.
05:56:46 <dmwit> I guess I owe you an apology.
05:57:18 <Twey> There's Algorithm M as well
05:57:49 <adnap> dmwit: Okay, your process makes sense. What I "might wish" for also makes sense, but why is that, specifically applying the type (forall a. a -> a) to a in (forall a. a -> a), not allowed?
05:57:55 <tarrasch> kttm, Apparently `wai-app-static` isn't building. I usually end up looking through the project on github and see if there are any recent issues. otherwise I find the offending version constraint and patch it myself.
05:58:11 <dmwit> adnap: Right, so now we get to predicativity.
05:58:28 <dmwit> adnap: "Impredicative" means a type can be instantiated at another type with "foralls" in it.
05:58:53 <dmwit> adnap: "Predicative" is the opposite -- it means instantiation *always* happens at types with no "foralls".
05:59:05 <jophish> dmwit: no worries :)
05:59:07 <dmwit> adnap: It turns out that allowing impredicativity makes lots of useful questions undecidable.
05:59:12 <adnap> My brain keeps jumping back to the beginning of the sentence when I encounter "at"
05:59:28 <dmwit> heh
06:00:40 <dmwit> So yeah, Haskell is predicative to avoid undecidability of so many things, and this is why instantiating the type (forall a. a -> a) at the polymorphic type (forall a. a -> a) is not allowed.
06:00:56 <adnap> "instatiation" means stripping a forall and substituting types for other types...
06:01:15 <dmwit> right
06:01:17 <adnap> But not necessarly applying a type to the type function, right?
06:01:32 <adnap> In fact, there doesn't seem to be a type function when you strip away forall
06:01:42 <kttm> tarrasch: do you patch it and install from source without cabal?
06:01:47 <FreeFull> Dammit, this package wants binary 0.7.1.0 but my distro provides 0.5.1.1
06:01:53 <FreeFull> Should I install it anyway?
06:01:57 <dmwit> Well.
06:02:40 <FreeFull> I have a feeling like I'm not meant to install a newer version without updating ghc
06:02:46 <FreeFull> Even if it will be a local install anyawy
06:02:48 <tarrasch> kttm, Yea, well, to be honest, as of lately I usually install the whole yesod-platform and these issues doesn't arise as much then
06:02:49 <FreeFull> anyway*
06:02:51 <dmwit> adnap: I guess by "applying a type to the type function" you probably meant it the other way around? "applying a type function to a type"?
06:03:02 <FreeFull> Although I guess, worst case I delete .ghc
06:03:03 <adnap> dmwit: Yes
06:03:33 <dmwit> adnap: And what you have before and after stripping foralls is always a type; type functions happen at the term level.
06:03:41 <tarrasch> kttm, but yes, sometimes I have to install from source, and I always take pride in submitting my fix as a pull request, so others don't need to resolve exactly the same issue.
06:04:06 <dmwit> adnap: So instantiation is an operation on types; applying a type function to a type is an operation on terms.
06:04:18 <dmwit> well
06:04:41 <dmwit> The former is an operation that takes two types and returns another; the latter is an operation that takes a term and a type and returns another term.
06:07:37 <dmwit> adnap: gotta run; but I think there are other people on here that can continue answering questions if you have more
06:08:20 <apfelbox> I want to remove a directory (recursively, if it exists), and recreate it
06:08:28 <apfelbox> What is the best way?
06:08:44 <Ghoul_> @src fix
06:08:44 <lambdabot> fix f = let x = f x in x
06:08:44 <erisco> okay here is a first attempt here: http://lpaste.net/92410
06:08:56 <erisco> some interesting ideas on: http://hackage.haskell.org/packages/archive/collections-api/1.0.0.0/doc/html/Data-Collections.html
06:08:59 <apfelbox> Do I really have to check for every case (does it exist, then remove, then recreate all subdirectories, etc..)?
06:09:00 <adnap> dmwit: I think I understand "impredictive" and "predictive" now
06:09:02 <adnap> dmwit: Thanks
06:09:12 <adnap> apfelbox: Are you Heinrich?
06:09:17 <apfelbox> nope
06:09:24 <apfelbox> why? :)
06:09:32 <adnap> Your nick...
06:09:42 <adnap> Is like Apfelmus
06:09:54 <apfelbox> no, not related
06:09:59 <erisco> the idea here is open to comment: http://lpaste.net/92410   thanks :)
06:10:53 <erisco> not sure if all the laws are orthogonal
06:14:29 <absence> what kind of library is good for processing individual bits (for e.g. data compression)? there's a jungle of things called bitvector, bitstream, bitwise, and variations on hackage
06:16:31 <Ghoul_> > take 5 $ fix (\t -> \x y -> let z = x + y in z : t y z) 1 1
06:16:32 <lambdabot>   [2,3,5,8,13]
06:16:36 <Ghoul_> hell yes.
06:16:51 <erisco> I think those laws cover the properties of list... the main defining feature being "Recency"
06:19:24 <d3lxa> I need to find the implementations of 'updateWhere' in Database.Persist.Query.GenericSql (for example) maybe it's an instance somewhere but I cannot find it, why and how can I?
06:20:08 <d3lxa> (i'm using hayoo, haddock, and trying to look at the sources there)
06:20:18 <paolino> hello, anyone knows how to render text in opengl without glut ?
06:20:21 <zomg> d3lxa: Yeah haddock should have sources for that
06:22:02 <d3lxa> zomg: there is no result in hoogle for 'updatewhere', am i wrong?
06:23:37 <kttm> what is ExitFailure 138 in yesod?
06:24:31 <erisco> where can I get a list of common Haskell data types?
06:24:44 <erisco> (list, maybe, seq, vector, stuff like that)
06:26:13 <zomg> d3lxa: I just pasted Database.Persist.Query.GenericSql into google, clicked the top link (to hackage) and clicked "Source"
06:29:09 <d3lxa> zomg: hum… I'm confused… thx =p hum
06:29:38 <zomg> d3lxa: usually the best bet for finding a source to some function would be to just look up the module it's in from hackage and then looking at the module's source
06:40:54 <haasn> randomR (l,h) = over _1 toEnum . randomR (fromEnum l, fromEnum r);  random = randomR (minBound, maxBound) -- surely there are existing functions for these?
06:41:13 <haasn> it seems like a trivial way to write the Random instance for any Enum type (or Bounded for the latter)
06:42:03 * hackagebot groundhog 0.4.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.0 (BorisLykah)
06:42:05 * hackagebot groundhog-th 0.4.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.4.0 (BorisLykah)
06:42:07 * hackagebot groundhog-sqlite 0.4.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.0 (BorisLykah)
06:43:22 <Twey> erisco: Nice identifiers :þ
06:43:53 <erisco> Twey, you mean the class function names?
06:46:09 <Ghoul_> I can't make this typecheck
06:46:12 <Ghoul_> filter (\x -> x `rem` n == 0) [1..(sqrt $ fromIntegral n)]
06:46:19 <Ghoul_> where n is some huge number...
06:46:28 <erisco> :t fromIntegral
06:46:30 <lambdabot> (Integral a, Num b) => a -> b
06:46:37 <erisco> :t sqrt
06:46:38 <lambdabot> Floating a => a -> a
06:47:03 * hackagebot groundhog-postgresql 0.4.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.0 (BorisLykah)
06:47:05 * hackagebot groundhog-mysql 0.4.0 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.0 (BorisLykah)
06:47:09 <Ghoul_> the wiki says sqrt (fronIntegral n) should be fine
06:49:19 <Zenol> is "dates" the right package to use to handle dates (with yesod) ?
06:49:55 <Zenol> (Because dates dependencies are strange and are incompatible avec aeson's ones)
06:50:08 <donri> @hackage time
06:50:08 <lambdabot> http://hackage.haskell.org/package/time
06:51:17 <Makoryu> I have a record that I want to update several times, and I need to reify the updates somehow as they occur. The approach I'm looking at right now is to represent the record as a Map, with data types for all possible keys and value structures. But then when I add or change properties I have two data types to modify. Is there a better way?
06:51:25 <Twey> erisco: Yes
06:51:42 <erisco> Twey, just a bit of thesaurus work :D
06:52:02 <Twey> erisco: It's better to name things the same as existing identifiers (and use qualified imports, if necessary)
06:52:02 <deech> Hi all, I'm use c2hs as a library to process some C bindings. I've added it to the build-tools section of my `.cabal' but `import C2HS' throws an error.
06:52:11 <Twey> It makes the API easier to learn
06:52:45 <Twey> erisco: What should your ‘within’ do for, say, Map?
06:52:56 <Twey> Does it take a key, an element, or a pair?
06:52:57 <erisco> Twey, you want (:) and elem rather than into and within?
06:53:14 <erisco> Twey, I don't know, I'll take a look at Map
06:53:24 <Twey> erisco: Probably cons rather than (:)
06:53:36 <Twey> I think you're going to run into fundeps/type families with this
06:54:03 <erisco> Twey, if that is the case, then the other page I found might be better
06:54:09 <erisco> the Data.Collections library, I think it was
06:54:52 <Twey> Ghoul_: Oh hey, fundeps are another example of arrow syntax that's weird
06:54:57 <erisco> Twey, Map is fine
06:55:09 <Twey> erisco: It's fine, but there are a few different ways it can be fine
06:55:11 <erisco> Twey, as long as it can satisfy Recency
06:56:02 <erisco> Twey, you can fix the key type and within would compare value values
06:56:46 <erisco> and for any type class there may be multiple valid instances for any type
06:57:02 <erisco> that isn't a problem I have to solve... it is already being coped with :)
06:57:03 * hackagebot HPDF 1.4.6 - Generation of PDF documents  http://hackage.haskell.org/package/HPDF-1.4.6 (alpheccar)
06:57:54 <Twey> Ah, Unfoldable is what I was just writing :þ
06:58:13 <Twey> Yeah, this seems to be the way to do it
06:58:17 <erisco> yeah, that library contains some neat abstractions using fundeps
06:58:40 <erisco> but my goal was to merely capture the properties of list so that I could have a counted list with common algorithms
06:59:26 <deech> The c2hs project includes a file called C2HS.hs as a data file, not a source file. It gets thrown into ~/.cabal/share/c2hs-0.16.5/C2HS.hs. How do I use it in my project?
06:59:39 <Twey> erisco: If you use Data.Collections you can mix and match between [] and Sequence
06:59:51 <erisco> Sequence is a class no?
06:59:55 <Twey> Er, Seq
07:00:37 <paolino> @src Seq
07:00:37 <lambdabot> Source not found. Are you on drugs?
07:01:48 <Twey> paolino: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
07:02:51 <paolino> tnx, I just cant stand lambdabot humor
07:03:10 <b2coutts> @src humor
07:03:10 <lambdabot> Source not found. Are you on drugs?
07:03:27 <b2coutts> yeah, lambdabot doesn't seem to have a very extensive repertoire :P
07:03:54 <erisco> Twey, mix and match under what type class?
07:04:07 <donri> @src drugs
07:04:07 <lambdabot> Source not found. Are you on drugs?
07:04:12 <erisco> Sequence I presume
07:04:21 <Twey> erisco: Sequence
07:04:35 <Twey> Or something more general if you don't need Sequence, of course
07:04:55 <erisco> why are those classes so polluted with functions?
07:05:35 <Twey> Efficiency
07:05:44 <erisco> mm, that was my guess
07:06:03 <erisco> seems the wrong way to do this, but a practical solution nonetheless
07:06:12 <Twey> Hm, they could do with more defaults
07:07:29 * paolino is rendering Char values with renderPrimitive Lines and feel dumb
07:12:38 <erisco> Twey, I think this is why overloaded functions make sense
07:12:56 <Kaini> In a do-block, how can I define a multiline function via let?
07:13:10 <erisco> Twey, but that is perhaps too transparent
07:13:16 <erisco> or opaque rather
07:13:25 <Rarrikins> Kaini: Try indenting the following lines.
07:13:35 <erisco> given you don't know calling 'foo' in turn calls 'bar' without looking at the source, so you don't know to optimize 'bar'
07:13:39 <Kaini> Rarrikins, I do
07:13:42 <pure> Hello.
07:13:48 <Twey> erisco: Huh?
07:13:50 <Kaini> I guess I'll paste it
07:14:16 <pure> Without using IO, it is pretty impossible to give a Haskell program state?
07:14:16 <erisco> Twey, @ putting extra functions into type classes for performance reasons
07:14:28 <Rarrikins> pure: You can use the state monads.
07:14:32 <Cale> pure: Depends on what you mean by that?
07:14:35 <Twey> erisco: Yes; what's the problem with it?
07:14:44 <lpaste> Kaini pasted “Syntax Error” at http://lpaste.net/92411
07:14:55 <Cale> pure: A function can have different arguments each time it is applied
07:15:16 <Twey> erisco: You just provide default implementations, e.g. snoc in terms of append; the instances of data structures that can do it more efficiently (e.g. Seq) can override the default
07:15:16 <pure> From my basic understanding of Haskell, it is -generally- stateless?
07:15:19 <Cale> pure: and the values of those parameters can be thought of as a kind of state
07:15:28 <Rarrikins> pure: No, it's just immutable.
07:15:32 <donri> Kaini: it needs to be indented more than "lockFunction"
07:15:34 <Rarrikins> pure: Plenty of immutable state.
07:15:34 <erisco> Twey, I understand how it is being used, but it seems like abuse
07:15:40 <Twey> pure: ‘Stateless’ means different things to different people
07:15:43 <pure> Switching from imperative to functional isn't fun. :)
07:16:01 <Cale> It's really hard to know exactly what's being asked or stated here without specifics :)
07:16:15 <Makoryu> pure: A better way to think about it, in my opinion, is implicit vs. explicit *models* of state
07:16:17 <Twey> pure: You can have ‘state’ by passing arguments between functions.  The State monad also exists to make this look nice when it starts to get out of hand.
07:16:18 <yitz> pure: just at first. then it becomes so much fun that you'll start groaning when you have to switch back.
07:16:22 <donri> switching from functional to imperative isn't voluntary! ^_^
07:16:26 <Kaini> donri, oh, thanks!
07:16:27 <erisco> Twey, it is hoping that you get every function into the type class so that any instance can potentially optimize it
07:16:46 <erisco> Twey, which is a hopeless endeavour
07:16:47 <Kaini> But that looks ugly to be honest :P
07:17:04 * hackagebot uuid 1.2.14 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.14 (AntoineLatter)
07:17:08 <Twey> erisco: Not *every* function, only ones that could be primitive for a reasonable type
07:17:28 <erisco> Twey, someone can always come along with their new type which is more efficient for operation X that didn't make it into the type class
07:17:34 <Makoryu> pure: Haskell's various state models (IO vs. STM vs. Reader...) are explicit, and you can get different behavior (ie. only the behavior you want) by working in different state models. Other languages, not so much.
07:17:39 <Twey> Perhaps
07:17:49 <erisco> I guarantee this :P
07:18:01 <pure> I'm currently considering writing a socket server in Haskell.
07:18:28 <erisco> a type class should be a minimal definition. Entirely orthoganal. all algorithms are then built on top of this minimal definition
07:19:11 <erisco> if you have an efficient way to solve some problem, then  you can define a new type class which describes the minimal properties the data you are operating on needs to have
07:19:31 <pure> Also looking at Control.Concurrent.Async. I suppose I could have a list of sockets, each on asyncly reading then iterate over the list of sockets and poll their async op?
07:19:36 <pure> Or...something like that.
07:19:44 <Twey> erisco: I don't know… it seems to work out pretty well most of the time.  I can see where you're coming from, but I'm not convinced that it's an *abuse* of type-classes to do it the way it's currently done.  Whether it's practical or not is a more empirical question.
07:20:12 <erisco> it is a convenient quick fix
07:20:14 <Rarrikins> pure: http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/telnet-conduit.html
07:20:24 <erisco> but not satisfying to me :(
07:20:28 <Twey> Kaini: In general, a line should be indented more than whatever it's part of
07:20:43 <Eduard_Munteanu> pure: you can share an MVar with the other threads
07:20:53 <Twey> erisco: Submit a patch ;)
07:21:02 <pure> How thread safe is Haskell, anyways?
07:21:06 <Twey> (and a thesis, because this is Haskell)
07:21:19 <Twey> pure: Pretty thread-safe.
07:21:28 <Eduard_Munteanu> pure: it is thread-safe when using just about any of those things
07:21:42 <Twey> You can break thread-safety, but it takes effort.
07:21:45 <erisco> Twey, convenient because it takes a lot of work otherwise, so don't hold  your breath :P
07:22:13 <Twey> erisco: Looking forward to your proposal ☺
07:22:30 <Eduard_Munteanu> pure: you only have to worry about complex concurrent operations... even simply writing a value to an IORef is safe.
07:22:39 <yitz> erisco: do you have a better idea how to provide different implementations of a function for different instances of class when the different implementations are only needed for efficiency reasons?
07:23:00 <yitz> in general
07:23:10 <erisco> yitz, that isn't quite what I said
07:23:41 <yitz> erisco: no i didn't think it was. i was just asking. hoping that you do :)
07:23:59 <erisco> yitz, the class functions should be orthogonal. You can of course provide whatever implementation suits per instance
07:24:46 <erisco> yitz, but when you throw something like splitAt into the class, which overlaps with take and drop (at least), then that is what I am not agreeing with
07:25:16 <erisco> rather you should consider what your efficient splitAt really requires and define a different type class. at least, that seems like a better approach to me, for the reason I stated
07:25:20 <yitz> erisco: classic example: mconcat for Monoid. there is an obvious default implementation, but it is very common for types to require a different implementation for mconcat to be usable in practice. yet it violates your orthogonality rule.
07:25:36 <yitz> erisco: how would you propose to deal with that?
07:25:42 <jophish> I can think of a few ways of applying a function to the second element of each tuple in a list of tuples. What would people here consider the 'cleanest' way of doing this?
07:26:00 <Cale> pure: It's safe enough that it's the default way that you'll wait on multiple things.
07:26:07 <yitz> @type second
07:26:08 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:26:22 <yitz> i know, lenses has something too
07:26:42 <jophish> heh, I thought it might be arrows :
07:26:43 <jophish> )
07:26:49 <Cale> jophish: tbh, I'd probably use a lambda most of the time
07:26:54 <donri> :t over _2
07:26:56 <lambdabot> (Field2 s t a b, Indexable Int p) => p a b -> s -> t
07:27:01 <yitz> yeah
07:27:24 <donri> :t over (traverse._2)
07:27:25 <lambdabot> (Traversable t, Field2 a1 b1 a b, Indexable Int p) => p a b -> t a1 -> t b1
07:27:26 <erisco> @src mconcat
07:27:26 <lambdabot> Source not found. Are you typing with your feet?
07:27:36 <erisco> @src mconcat :: [a]
07:27:36 <lambdabot> Source not found. You type like i drive.
07:27:44 <donri> @src [] mconcat
07:27:45 <lambdabot> Source not found. Wrong!  You cheating scum!
07:27:46 <erisco> shut up lambdabot :P
07:27:56 <pure> So wait, can I have a conduit that represents -all- connected sockets?
07:28:15 <jophish> Thanks all
07:28:38 <yitz> > second (*100) (1,2)
07:28:39 <lambdabot>   (1,200)
07:28:57 <erisco> yitz, I would have to at least see what the optimized version is for a particular type
07:28:59 <Ghoul_> pure: you tend to use a Broadcast TMChan for that
07:29:11 <Twey> I guess you could have ‘optional constraints’.  append ∷ (Sequence (c a) a, Maybe (HasAppend (c a))) ⇒ c a → c a → c a; append (_, Just hasAppend) ⇒ xs ys = getAppend hasAppend xs ys; append (_, Nothing) ⇒ [] ys = ys; append (sequence, Nothing) ⇒ xs ys = cons (getHead sequence xs) (getTail sequence ys)
07:29:43 <Twey> (generalized to more complex type constructors as necessary)
07:30:01 <erisco> yitz, but generally my answer would be: too bad. if you have a better way to achieve the same input to output mapping as mconcat, for your particular type, then I am postulating there is a type class which defines the properties your optimization is based on
07:30:58 <Twey> s/cons/getCons sequence/
07:32:25 <erisco> yitz, is finding that type class easy? not necessarily. I agree the tactic of putting mconcat into Monoid is convenient, but as I said, it is a drop in the ocean
07:33:13 <yitz> erisco: the default for mconcat is foldr mappend mzero. for Text, for example, that would be very inefficient. instead you use the internal encoding of Text. Similarly for bytestring, but with a different internal encoding. yet it would be a terrible breakage of encapsulation of Monoid to require different type-specific mconcats for those.
07:33:41 <yitz> erisco: in general, it would make Monoid almost useless in practice. which would really be a shame.
07:33:49 <erisco> yitz, too bad
07:33:51 <yitz> erisco: yet your point is well taken.
07:33:53 <erisco> monoid is useless then
07:34:00 <erisco> make something more powerful :P
07:34:40 <erisco> in the mean time, yeah, do the convenient thing. I'm just talking about an ideal
07:34:51 <yitz> right
07:36:20 <yitz> erisco: we need some better way of expressing the difference between those two different kinds of methods, other than a human-readable "minimal instance" comment in the haddocks.
07:52:05 * hackagebot bytes 0.11.2 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11.2 (EdwardKmett)
08:00:14 <FreeFull> Well, this is fun
08:00:39 <FreeFull> When I try to compile anything that uses haskell bullet bindings, I get a huge linking error
08:00:52 <FreeFull> I think my version of bullet is too new
08:05:30 <Makoryu> > length (map absurd [undefined..])
08:05:31 <lambdabot>   Not in scope: `absurd'
08:07:07 * hackagebot approximate 0.2 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.2 (EdwardKmett)
08:09:10 <madjestic> I am looking for a emacs extension that would support region indentation (select a block of haskell code, press tab -> get the whole block indented).  Is there such thing?
08:11:43 <arke> Hi, I've got some questions of a somewhat more stylistic nature. I'm relatively new; please feel free to tell me when I just haven't googled hard enough.
08:12:07 * hackagebot bytes 0.11.3 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11.3 (EdwardKmett)
08:12:09 * hackagebot set-cover 0.0.2 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  http://hackage.haskell.org/package/set-cover-0.0.2 (HenningThielemann)
08:13:22 <arke> First off: I've got a function which utilizes about 3 other functions; these functions are only used by that top level function and are not usable for anybody else (they are mutually recursive and implement the states for a parser). The classic method here, it seems, would be to use a let statement to localize those helper functions within the main function.
08:14:40 <arke> However, type signatures cannot be written inside let statements; this is alright for my little toy parser since type inference catches everything, however I'm curious what the usual methodology in "good" haskell code is.
08:14:49 <Twey> arke: Yes they can
08:15:01 <Twey> > let x :: Int; x = 5 in x
08:15:02 <lambdabot>   5
08:15:36 <Twey> Personally I prefer to just put them at the top-level and not export them
08:16:04 <Makoryu> arke: All declaration blocks use exactly the same syntax, whether at the top level or after let/where
08:16:19 <Twey> But a let or a where is okay too
08:16:34 <arke> Hm, then I must have made some other mistake.
08:16:42 <Makoryu> Check your indentation
08:16:46 <Makoryu> Offside rule
08:17:07 * hackagebot haskell-packages 0.2.2 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.2 (RomanCheplyaka)
08:17:58 <Makoryu> arke: By the way, if your helper functions make up the bulk of the definition, sometimes using "where" instead of "let" makes it easier to read
08:18:22 <pure> So, conventions wise and such.
08:18:24 <Makoryu> For example: bigMonadLoop x = go x where go = ...
08:18:33 <arke> Huh, _now_ it works.
08:18:45 <arke> Makoryu: I guess you're right, it was probably the indentation. Thanks!
08:18:48 <pure> Should main come first or should I define my functions prior to defining main?
08:19:03 <arke> Twey: thanks to you also, you basically answered my unasked subquestion :)
08:19:31 * Makoryu fistbumps Twey, activating wonder twin powers
08:19:36 <Twey> Heh
08:20:28 <Twey> pure: I generally like to write functions top-down, so the entry-point would be at the top
08:20:47 <ocharles> mm_freak_: got netwire 5 to build, looks interesting
08:20:51 <Twey> But I'd always put main in a separate module, too, with not much else in it (maybe arg-parsing &c. if appropriate)
08:21:05 <ocharles> mm_freak_: especially like reactimate, which i suppose is what you mean by removing emphasis on discrete time
08:21:23 <ocharles> not entirely sure about events and the switching combinator, but we'll see when i actually write some code with it
08:22:08 * hackagebot haskell-names 0.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.2 (RomanCheplyaka)
08:22:26 <arke> So a 25-line "let" (including type signatures, pattern matching, and encompassing a total of 5 fuctions) would likely be considered "too large", and it would be cleaner \to make separate functions that are not exported, correct?
08:25:07 <ocharles> arke: i don't see why
08:25:11 <ocharles> i do that frequently
08:25:17 <ocharles> the only downside is it can be harder to use with GHCI
08:25:38 <pure> Also, I need to get a hackage before I import it?
08:25:41 <ocharles> but i like to tightly scope stuff. if something only has a single caller, then i put it in the caller
08:26:11 <ocharles> (and I commonly have nested where clauses, for the same reason)
08:26:24 <Makoryu> pure: Yeah. GHC doesn't do automatic package fetching like Go does
08:27:08 * hackagebot hs-gen-iface 0.2 - Utility to generate haskell-names interface files  http://hackage.haskell.org/package/hs-gen-iface-0.2 (RomanCheplyaka)
08:27:22 <pure> So, cabal install network, for example?
08:27:22 <Makoryu> Though at the moment there's some work going on with cabal-install and cabal-dev (which I don't quite follow/understand) to do sandboxing for a local build
08:27:28 <Makoryu> Yes
08:27:36 <Twey> arke: Big functions are harder to read and to debug; I'd suggest breaking it up
08:27:37 <pure> Does it need to be elevated on windows?
08:27:51 <Makoryu> Elevated?
08:27:56 <Makoryu> Oh, you mean privileges?
08:28:07 <pure> Does it need to be ran as admin :)
08:28:34 <Twey> Ooh, haskell-names is cool
08:29:00 <Makoryu> pure: I suppose that depends on where you installed it...
08:29:22 <Makoryu> I've never used Haskell on Windows, so I don't know what the default is
08:29:47 <lpaste> arke pasted “Toy Parser” at http://lpaste.net/8733352582329663488
08:29:57 <Twey> cabal-install in general installs packages in the user's home directory, so shouldn't intrinsically need administrative privileges
08:30:28 <Twey> The λpaste numbers jumped right up O.O
08:30:40 <arke> Oh, cool bot. Yeah, I pasted to demonstrate; I make no claim for cleanliness.
08:30:42 <Twey> arke: Eek
08:31:10 <donri> Twey: private paste
08:31:23 <arke> Twey: That is pretty much the reaction I expected. :)
08:31:28 <Makoryu> arke: Yeah, I'd put all those at the top level...
08:31:40 <Makoryu> And make this whole block its own module, perhaps
08:31:58 <Makoryu> Depends what you're doing I guess
08:33:01 <arke> I'd love constructive criticism on cleaning that up.
08:33:38 <arke> For one, the 'parse' and 'reassemble' steps should be split, that would help.
08:38:41 <Makoryu> arke: Let's see... The first thing I'd do (after putting all that stuff at the top level) is separate the idea of escaping a character from parsing an escape sequence
08:39:08 <Makoryu> So you'd have a function like "escape x = Character x"
08:39:53 <Makoryu> And then you'd write: parseUnescaped ('\\':x:xs) = escape x : parseUnescaped xs
08:40:29 <arke> Ah, that way I don't need parseEscaped at all
08:41:07 <Makoryu> And later on, if you decide to add escape sequences like \n for newline, you can do that in escape without worrying about the recursive call to parseUnescaped
08:45:04 <pure> Would it be more efficient to refer to a socket by its port rather than handle?
08:45:10 <Makoryu> arke: You could separate the work of the assemble* functions in a similar way, though I don't quite follow how you intended them to work
08:46:32 <geekosaur> pure: ?? the OS level uses file descriptors, which are exposed in Haskell as Handles. why would an extra translation layer be more efficient?
08:47:09 * hackagebot wai 1.4.0.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.4.0.2 (MichaelSnoyman)
08:47:11 * hackagebot case-insensitive 1.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.1 (BasVanDijk)
08:48:21 <sclv> johnw: pong?
08:48:41 <pure> Hmm.
08:49:04 <monochrom> eliminating handles (in fact fds) and virtualized memory addresses is more efficient, yes.
08:49:08 <pure> type ConnectionList = [(Handle,Connection)] So that would work as a way of hold connections?
08:49:26 * nu11s37 is away: AFK
08:49:29 <pure> Connection being my type for enscapulating a socket connection
08:49:35 <arke> Makoryu: They turn the [ParseChar] into a list of statements, each statement being a list of individual words ([Char]) in that statement; statements are separated by Separator and words are separated by Space. I'll give it a shot to clean those up.
08:49:35 <geekosaur> maybe I don't understand what you're asking
08:50:07 <geekosaur> monochrom, you have useful distributed shared memory? :)
08:50:32 <Makoryu> arke: In situations like this I sometimes use type synonyms just to make my intention clear
08:51:44 <Makoryu> For example, type Word = [Char]; type Stmt = [Word]
08:51:50 * Makoryu shrugs
08:56:31 <deech> How do I start ghci with a static library?
08:57:09 * hackagebot set-cover 0.0.3 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  http://hackage.haskell.org/package/set-cover-0.0.3 (HenningThielemann)
08:57:11 * hackagebot halberd 0.1 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1 (ErikHesselink)
08:58:19 <monochrom> probably "ghci -ljoy" will work
08:59:51 <monochrom> nevermind, that only tries shared libraries
09:00:23 <shachaf> Tries of shared libraries? That sounds scary.
09:00:50 <monochrom> if you can get your hands at the *.o files, then it is "ghci joy1.o joy2.o joy3.o". but I don't see a way for *.a
09:01:27 <monochrom> a file system may contain tries of shared libraries :)
09:01:41 <deech> monochrom: Yeah, I just found that too ... This bug (http://web.archiveorange.com/archive/v/NrglUaPxPsEVkPty1P1R) seems to suggest that just calling with the library should work.
09:02:56 <shachaf> I suppose Debian has a small trie of shared libraries: http://ftp.debian.org/debian/pool/main/
09:04:01 <monochrom> "warning: may contain nuts and tries of shared libraries"
09:07:35 <Twey> arke: Is a suggestion to use Parsec considered constructive?  :þ
09:08:02 <Twey> arke: I think it's a one-liner with Parsec.
09:08:52 <Makoryu> Twey: That was going to be my next suggestion, but depending on what he's doing, maybe that would be missing the point...
09:08:59 <Makoryu>  ┐(　´〰`)┌
09:09:30 <arke> Twey: Ah, good to know that that exists. This is a learning exercise for myself; blindly reimplementig some ugly C code I wrote about 300 years ago. It's already cleaner than the original as is :)
09:09:49 <applicative> man, this new 'posix-paths' with ultra-fast directory traversal seems ... completely uninstallable
09:10:07 <Twey> arke: *nod*
09:10:44 <Twey> arke: If you don't want to use Parsec, I'd mostly suggest combining parseEscaped and parseUnescaped into one function (which would more properly be called tokenize, since you're not parsing here yet)
09:11:34 <arke> Twey: Yeah, that was Makoryu 's suggestion; have done that already. True on the tokenize point, I'll rename it.
09:12:09 <applicative> wheres you module, arke ?  just wondering what they're saying.
09:12:14 <applicative> your module
09:12:20 <pure> So, listenOn gives me a Socket, I then need to pass that Socket to accept...how do I get the Socket to persist?
09:12:44 <arke> applicative: http://lpaste.net/8733352582329663488
09:13:08 <mr-> applicative: it installed fine for me ;-)
09:13:13 <arke> applicative: my current version looks a bit different after several suggestions.
09:13:29 <applicative> mr-: maybe its an os x thing. somethings going
09:13:33 <applicative> on
09:14:24 <applicative> mr- what platform are you using?
09:16:56 <Kaini> @src try
09:16:56 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
09:17:10 * hackagebot wai-app-static 1.3.1.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.1.4 (MichaelSnoyman)
09:17:12 * hackagebot wai-extra 1.3.4.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.4 (MichaelSnoyman)
09:17:16 <mr-> applicative: linux/ubuntu
09:17:35 <Kaini> @src catch
09:17:35 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
09:18:51 <Kaini> @src catchException
09:18:52 <lambdabot> Source not found. Do you think like you type?
09:19:01 <Kaini> Mmh I don't like magic functions
09:19:04 <applicative> mr- hm, yeah. i am getting 'unknown symbols' for my architecture ... whichever architecture i go with ..
09:19:10 <absence> is it possible to express this as a fold? go f z (x:xs) = y : go f y xs where y = f z x
09:22:10 * hackagebot warp 1.3.9.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.9.2 (MichaelSnoyman)
09:22:12 * hackagebot warp-tls 1.4.1.4 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.1.4 (MichaelSnoyman)
09:22:14 * hackagebot mime-mail-ses 0.2.1.3 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.1.3 (MichaelSnoyman)
09:23:35 <Makoryu> :t let go f z [] = z; go f z (x:xs) = let y = f z x in y : go f y xs in go
09:23:36 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
09:23:36 <lambdabot>     In the second argument of `go', namely `y'
09:23:36 <lambdabot>     In the second argument of `(:)', namely `go f y xs'
09:23:53 <Makoryu> absence: What's your base case
09:23:56 <Makoryu> Wait
09:24:00 <Makoryu> Oops
09:24:03 <applicative> damn, 'posix-paths' doesnt work even with the Official Haskell Platform.
09:24:04 <geekosaur> Kaini, on the one hand, not being in @src does not necessarily mean magic; on the other, exceptions pretty much have to be baked into the runtime one way or another
09:24:09 <Makoryu> :t let go f z [] = []; go f z (x:xs) = let y = f z x in y : go f y xs in go
09:24:10 <lambdabot> (a -> t -> a) -> a -> [t] -> [a]
09:24:26 <Makoryu> :t foldr
09:24:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:24:49 <Makoryu> :t \g -> foldr (flip g)
09:24:50 <lambdabot> (b -> a -> b) -> b -> [a] -> b
09:25:18 <Twey> arke: many ((char '\\' >> anyToken) <|> noneOf " \n\r\0;") `sepBy` char ' ' `sepEndBy` oneOf "\n\r\0;"
09:25:21 <absence> Makoryu: ah sorry. go _ _ = []
09:25:28 * applicative tries to figure out how to get the Platform off his system
09:25:41 <Twey> applicative: Off?
09:25:53 <paolino> :t foldl (\(y:ys) x -> f y z:y:ys)
09:26:02 <lambdabot> (Show t, FromExpr t) => [t] -> [b] -> [t]
09:26:20 <arke> Tmany ((char '\\' >> anyToken) <|> noneOf " \n\r\0;") `sepBy` char ' ' `sepEndBy` oneOf "\n\r\0;"
09:26:28 <arke> oops, accidental paste
09:26:48 <paolino> :t foldl (\(y:ys) x -> f y x:y:ys)
09:26:49 <lambdabot> (Show t, Show b, FromExpr t) => [t] -> [b] -> [t]
09:26:56 <arke> Twey: that's using Parsec?
09:27:10 <Twey> Aye
09:27:40 <Twey> Then you need to call it using parse thatParser "some source location" yourString
09:27:45 <arke> That's ... brilliant, and I don't understand it one bit :D
09:28:33 * arke takes a quick look at the Parsec reference
09:28:53 <applicative> Twey, yeah i was trying to see if the Haskell Platform had special linking sauce that would get me past some System.Posix nonsense
09:29:54 <Twey> arke: You can read it pretty directly.  Many (the character '\\' followed by any token, or a token that isn't \n \r \0 or ;), separated by the character ' ', separated (and possibly ended) by one of "\n\r\0;"
09:30:02 <Makoryu> arke: "x `sepBy` y" takes two parsers x and y, and parses a string like "xyxyxyx" into a list like [x, x, x, x]
09:30:35 <Twey> applicative: And it didn't?
09:30:44 <applicative> no, unfortunately
09:31:19 <Twey> Aw.
09:31:27 <applicative> Twey: i think i will just put an issue on the github site; these things are over my head, but if they dont know much about os x, there might still be trouble
09:31:35 <Twey> arke: It's not quite the same as your parser because yours accepts empty things
09:33:05 <arke> That's pretty amazing.
09:34:23 <arke> I can't imagine even the wildest boost magic doing this in one line (I'm a C++-guy during the day)
09:34:37 <paolino> absence, I think that is scanl
09:35:10 <Twey> arke: option "" (many ((char '\\' >> anyToken) <|> noneOf " \n\r\0;")) `sepBy` char ' ' `sepBy` oneOf "\n\r\0;" — this is a more direct translation
09:35:13 <paolino> @src scanl
09:35:14 <lambdabot> scanl f q ls = q : case ls of
09:35:14 <lambdabot>     []   -> []
09:35:14 <lambdabot>     x:xs -> scanl f (f q x) xs
09:35:38 <Twey> arke: Hey, don't get too enthusiastic — it's at least two lines if you break it properly ;)
09:35:51 <Twey> But yes, Parsec is probably the nicest parsing library.
09:36:48 <donri> Twey: no parsing is ;)
09:37:07 <applicative> parsing is the most austere and elegant
09:38:02 <donri> Twey: uh parsers
09:39:00 <arke> Though I'm already prety happy with my own fumbly haskell parser; I've not looked at my original C implementation for the same thing from 300 years ago but I can't imagine it being in any way cleaner :)
09:39:01 <applicative> @hackage parsers
09:39:01 <lambdabot> http://hackage.haskell.org/package/parsers
09:40:14 <Makoryu> How do you use parsers anyway
09:40:25 <Makoryu> Do you just throw the same code at it as you would at Parsec
09:40:43 <arke> encoding the parser state implicitly through the current function, which just call each other in a mutual recursive way, is pretty neat. My next planned exercise is parsing the byte stream coming from a serial wire. Those protocols like to get relatively hairy quick.
09:40:44 * applicative has installed 4 different ghc's in the last 45 minutes. Probably not a record unfortunately.
09:41:06 <roconnor> applicative: are you using nix?
09:41:09 <donri> Makoryu: the new version includes instances for parsec and readp
09:41:26 <donri> not on hackage yet
09:42:25 <applicative> roconnor: no, osx. nix would have made this experiment a little more rational, surely
09:43:13 <donri> there's a bunch of purely applicative combinators in parsers though, those work with most parsers automatically
09:44:16 <Twey> donri: Oh really?
09:45:40 <Twey> Oh, parsing has been edwardk'd :þ
09:45:56 <edwardk> i'm a verb?
09:46:12 <applicative> Twey: you need to get moving so we can say parsing and so on have been tweyed
09:48:47 <donri> Twey: it was extracted from his trifecta, i believe
09:49:00 <donri> which does actual parsing
09:49:49 <donri> edwardk: i so wish we could add attoparsec instances just so we can say trifecta depends on three parser combinator libraries and uses none of them
09:50:35 <ReinH> edwardk: hai
09:50:53 <applicative> edwardk: i found a copy of the original hutton-meijer ParseLib, maybe i'll make appropriate instances...
09:51:10 <Twey> edwardk: to edwardk, v.  to be working on a larger problem and absent-mindedly spin out a package to satisfy dependencies, accidentally solving the problem more elegantly than existing solutions (but perhaps incomprehensibly to anyone who can't dualize in their head)
09:51:30 <Twey> donri: Oh, I remember the trifecta.
09:51:37 <edwardk> @remember twey  to edwardk, v.  to be working on a larger problem and absent-mindedly spin out a package to satisfy dependencies, accidentally solving the problem more elegantly than existing solutions (but perhaps incomprehensibly to anyone who can't dualize in their head)
09:51:37 <lambdabot> Okay.
09:51:49 <lpaste> arke revised “Toy Parser”: “Toy Parser, rev 2” at http://lpaste.net/8733352582329663488
09:52:05 <edwardk> donri: bos indicated at one point he'd accept patches to attoparsec that exposed enough of the guts that the parsers instances could be written
09:52:19 <edwardk> ReinH: got it generating test pattens on SoH
09:52:29 <edwardk> ReinH: working on the first automaton
09:52:40 <donri> edwardk: ah, so we just need someone to write the patch, and then wait 6 months for bos to pull it ;)
09:52:41 <arke> oops, pasted wrong version >_<
09:52:41 <ReinH> :D
09:52:52 <edwardk> donri: more or less
09:53:29 <Twey> Heh, HLint actually throws an *error* if you fail to η-reduce your functions
09:54:21 <donri> hlint's error/warning distinction always felt completely arbitrary to me
09:54:34 <Twey> HLint feels completely arbitrary to me
09:54:41 <donri> true :p
09:55:15 <Twey> ‘Found: elem c " "  Why not: c `elem` " "’ — um, because it's longer and adds nothing to the expression.
09:56:22 <lpaste> arke revised “Toy Parser”: “Toy Parser, rev 2 (now correct)” at http://lpaste.net/8733352582329663488
09:56:30 <absence> paolino: why yes! with a "drop 1" around it. thanks a bunch
09:57:10 <arke> _now_ it's right.
10:01:17 <monochrom> cat "why not shut up" > hlint
10:01:28 <monochrom> err, s/cat/echo/
10:06:16 <monochrom> if hlint were not inflicted universally on lpaste, I would not even talk about it
10:07:04 <applicative> monochrom: just use http://lpaste.net/raw/ thats what i do
10:07:05 <ijp> why does a paste site run lint on your code?
10:07:06 <kuribas> Is there an equivalent of !! for tuples?
10:07:10 <monochrom> heh
10:07:23 <kuribas> like (1, 2, 3, 5) !! 4 == 5
10:07:31 <applicative> its jolly convenient ijp, just a little too opinionated
10:07:50 <kuribas> Should I use a vector instead?
10:07:52 <monochrom> it runs hlint because it wants to defeat pedagogical purposes
10:07:52 <Iceland_jack> kuribas: Before answering, why do you think you'd ever need that?
10:08:22 <kuribas> Iceland_jack: For use in higher order functions...
10:08:32 <geekosaur> because they've been mistrained by python to think tuples are secretly lists?
10:08:34 <g0d> kuribas: I think you've been masturbating abit too much.
10:08:35 <applicative> conor mcb *totally* cant write haskell as you see from the errors here http://lpaste.net/91686
10:08:41 --- mode: ChanServ set +o geekosaur
10:08:50 <geekosaur> g0d, that's not channel appropriate
10:08:52 <Iceland_jack> No, why would you need tuples that long?
10:09:23 <Iceland_jack> When you're working with unwrapped tuples longer than 3, you're generally better off defining your own datatype
10:09:40 <paolino> :t [_1,_2,_3,_4,_5] !! 4
10:09:40 * applicative hadn't notice geekosaur was an op
10:09:41 <lambdabot> (Functor f, Field5 s t a b, Field4 s t a b, Field3 s t a b, Field2 s t a b, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
10:09:47 * applicative goes on best behavior
10:09:49 <monochrom> kuribas: consider vector, yes
10:09:49 <donri> @hackage tuple-lenses
10:09:49 <lambdabot> http://hackage.haskell.org/package/tuple-lenses
10:10:09 <pure> Am I doing something wrong here? https://gist.github.com/jrobertsgb/6405750
10:10:19 <Iceland_jack> Don't encourage people to index into tuples by providing the answers without disclaimers ;)
10:10:26 <kuribas> Iceland_jack: In the function offsetMax: https://github.com/kuribas/cubicbezier/blob/master/Geom2D/CubicBezier/Outline.hs
10:10:46 --- mode: geekosaur set -o geekosaur
10:11:20 <applicative> pure: what is the problem you're thinking of?
10:11:27 <kuribas> Hm, but I could make an auxiliary datatype for that...
10:11:39 <pure> I can't connect to the socket. :)
10:11:49 <Iceland_jack> kuribas: Why not pattern match?
10:12:23 <monochrom> pure: does the OS allow you to listen on port 23? how do you know?
10:12:35 <pure> It's Windows.
10:12:42 <monochrom> ha, that's easy
10:12:43 <pure> There's no port restrictions. ;)
10:12:48 <kuribas> Iceland_jack: Higher order functions, for example map.
10:12:49 <geekosaur> kuribas, in general tuples are convenient for "temporary" carriers of multiple values, but it's almost always better to create your own type if you're going to make significant use of it. for readability of code, if nothing else
10:13:06 <geekosaur> pure, then you're missing withSocketsDo
10:13:11 <Iceland_jack> kuribas: map (\(a, b, c, d) → …) ?
10:13:13 <pure> I put that in.
10:13:14 <geekosaur> oops, no you aren't
10:13:17 <geekosaur> sorry
10:13:32 <kuribas> Iceland_jack: Yes, I have that defined in my code.
10:13:40 <kuribas> geekosaur: You're probably right.
10:13:45 <monochrom> but then, windows has firewall rules. I mean, it allows you to listen, but it doesn't allow another computer or another program to connect
10:14:05 <Iceland_jack> kuribas: But what geekosaur said
10:14:34 <pure> It asked me to make an exception when I first ran the program.
10:15:17 <Iceland_jack> For example in your case where the tuple is:
10:15:17 <Iceland_jack>     (t_min, t_err, curve, outline)
10:15:17 <Iceland_jack> You should define a record:
10:15:17 <Iceland_jack>     data Something = Something { t_min :: Double, t_err :: Double, curve :: CubicBezier, outline :: CubicBezier }
10:15:40 <pure> *ponders*
10:15:43 <pure> It worked with port 2323
10:15:48 <kuribas> yes
10:16:13 <monochrom> if you agree to make an exception, connections should be allowed
10:16:19 <Iceland_jack> What you were actually looking for is accessor functions:
10:16:20 <Iceland_jack>     ???   :: (Double, Double, CubicBezier, CubicBezier) → Double …
10:16:20 <Iceland_jack> which is exactly what records give you:
10:16:20 <Iceland_jack>     t_min :: Something → Double
10:16:36 <pure> And now it works with port 23...
10:16:39 <pure> *shrugs*
10:16:42 <kuribas> Iceland_jack: Yes, I know.
10:16:43 <monochrom> \∩/
10:16:45 <pure> I stared at it long enough for it to work?
10:16:49 <monochrom> \∩/
10:17:37 <Iceland_jack> kuribas: I didn't mean to point out things you were already aware of, but I have to make some assumptions about people who ask for help
10:17:37 <monochrom> the exception went out for lunch :)
10:18:09 <kuribas> Iceland_jack: sure, I understand.
10:18:44 <lpaste> Twey annotated “Toy Parser” with “Toy Parser (recursive descent)” at http://lpaste.net/8733352582329663488#a3636277453489438720
10:19:20 <Twey> arke: ↑ that's how I'd do your parser without Parsec
10:21:22 <FreeFull> Any idea if anyone is working on bindings for sdl2?
10:22:11 * hackagebot halberd 0.1.1 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.1 (ErikHesselink)
10:22:36 <applicative> 'halberd'?
10:23:17 <geekosaur> ten foot pole that's nice for hacking? :p
10:23:34 <Twey> Heheh.
10:23:39 <applicative> hah
10:24:02 <Twey> A long thing with a chunk of stuff at the top?
10:24:09 <applicative> FreeFull: we will all be grateful when you manage it ;)
10:29:22 <FreeFull> applicative: I am more curious than "I really need this right now"
10:29:33 <FreeFull> So don't expect to see it from me =P
10:29:54 <applicative> there was a discussion FreeFull http://www.reddit.com/r/haskell/comments/1k9wh8/time_to_start_writing_on_the_new_binding_sdl_20/
10:30:01 <applicative> fwiw
10:30:47 <FreeFull> applicative: Huh, how did I miss that
10:31:22 <FreeFull> Oh, I haven't, I just forgot about it
10:32:12 * hackagebot snap-core 0.9.4.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.4.1 (DougBeardsley)
10:32:14 * hackagebot snap-server 0.9.3.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.3.4 (DougBeardsley)
10:32:55 <FreeFull> applicative: Apparently Lemmih is working on it right now
10:43:25 <applicative> FreeFull: oh that sounds promising then
10:44:41 <applicative> oic at 'zurihac' they were supposed to be working on sdl-2
10:45:47 <pure> Is [(String,Connection -> String -> IO ())] valid?
10:46:07 <applicative> there is such a type
10:46:24 <pure> And that would be a list of pairs of strings and functions?
10:46:39 <applicative> yes
10:46:40 <FreeFull> Yes
10:46:54 <pure> Awesome.
10:47:06 * pure has been converted.
10:47:12 * hackagebot hoogle 4.2.21 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.21 (NeilMitchell)
10:47:21 <FreeFull> pure: You could also use a Map instead with the String as the key
10:47:45 <FreeFull> But then you would only be able to have one function with the same string
10:47:48 <pure> Isn't a Map just a symonym for [(k,v)]?
10:48:07 <applicative> no, it doesn't allow many things for one key
10:48:08 <FreeFull> In a valid Map, each key will only occur once
10:48:14 <pure> Right.
10:48:20 <mauke> no, that would be too slow
10:49:07 <FreeFull> Well, the standard Data.Map isn't too fast
10:50:03 <mauke> it's just right
10:50:27 <FreeFull> Data.Goldilocks
10:50:59 <pure> I could do insert (\Connection -> String -> do foo) "cmd" CommandMap then?
10:51:16 <pure> s/CommandMap/commandMap
10:52:37 <FreeFull> pure: (\connection string -> do foo), sure
10:52:54 <elliott> and "cmd" goes first.
10:53:01 <applicative> @type Map.insert "printboth" (\x y -> print (x+y)) Map.empty
10:53:02 <lambdabot> Couldn't find qualified module.
10:53:06 <applicative> bah
10:53:15 <applicative> @type M.insert "printboth" (\x y -> print (x+y)) M.empty
10:53:16 <lambdabot> (Num a, Show a) => M.Map [Char] (a -> a -> IO ())
10:53:25 <applicative> there we are
10:54:17 <FreeFull> Too bad Data.Map isn't an applicative
10:54:42 <applicative> @type M.insert "printbigger" (\x y -> print (max x y)) $ M.insert "printboth" (\x y -> print (x+y)) M.empty
10:54:43 <lambdabot> (Num a, Ord a, Show a) => M.Map [Char] (a -> a -> IO ())
10:55:06 <pure> Unsure if I should pass a String containing args or a [String]
10:55:21 <FreeFull> pure: [String]  is probably better
10:55:35 <FreeFull> pure: Or maybe [CustomType]
10:55:59 <pure> It's whether it would be preferable to split the argstring into words before the command gets them.
10:56:29 <pure> Probably would just be easier to give it the whole string and let it do whatever it wants after that.
10:56:48 <FreeFull> pure: Where are you getting the arguments from?
10:57:39 * applicative hopes pure isn't just *picking them up off the street*
10:58:47 <Twey> FreeFull: You probably want a big record of arguments
10:59:36 <pure> Input from a socket.
10:59:45 <pure> It's a telnet server thingy.
11:06:36 <pure> So what's the cloesest thing to 'map = Map.insert "X" foo map'?
11:06:51 <mauke> map2 = Map.insert "X" foo map
11:07:24 <geekosaur> if you're doinvg a bunch of them, you might start with the list of pairs form and use M.fromList
11:08:22 <pure> Also, can I have my list definition cross multiple lines, for readabilty?
11:08:33 <pentace> yes
11:14:14 <ReinH> applicative: you can use a Map k [a] to handle zero or more things for each key :)
11:15:40 <ReinH> using insertWith
11:17:25 <Iceland_jack> This is made concrete in the package ‘multimap’
11:17:55 <ReinH> Iceland_jack: nice
11:18:08 <pure> Ok. So '(commands ! cmd) connection line' would be the correct way to call my command?
11:19:33 * pure probably meant M.!
11:20:23 <ReinH> pure: ! is dangerous
11:20:43 <ReinH> it's a partial function that throws an error when the element can't be found
11:20:53 <Iceland_jack> Sometimes you need to live dangerously ;)
11:21:06 <ReinH> Iceland_jack: I don't see why you couldn't use >>= here :p
11:21:19 <pure> I've already checked if cmd is a member.
11:21:32 <ReinH> ok
11:21:38 <Iceland_jack> pure: Why not perform checking and accessing in the same call?
11:21:44 <Iceland_jack> Instead of adding a race condition
11:22:10 <ReinH> Iceland_jack: it's not a race condition if there's no race but I get your point :)
11:22:11 <pure> Because I want to send an error message to the user if it's not in the map
11:22:17 <ReinH> pure: you can still do that
11:22:32 <Iceland_jack> case M.lookup k map of Nothing → ERROR; Just v → …
11:22:51 <ReinH> case M.lookup cmd command of ...
11:22:51 <pure> Fair enough.
11:22:52 <ReinH> right that
11:23:00 <pure> And then v connection string?
11:23:00 <Iceland_jack> ReinH: Yes you're right, I'm thinking mutably
11:23:39 <ReinH> pure: right
11:24:15 <Twey> maybe ERROR (\ v → …) (M.lookup k map) :þ
11:24:50 <Makoryu> M.findWithDefault ...
11:24:54 <Iceland_jack> There are many ways to do something in Haskell, news at 11 :)
11:24:58 <ReinH> hah
11:25:37 <Iceland_jack> Also M.findWithDefault requires the error case to have the same type as the expected value
11:25:55 <Makoryu> If your error case is "error foo" then that's trivially true
11:26:44 <ReinH> Makoryu: if your error case is the same type as your return value then your types are wrong :)
11:27:11 <ReinH> you've got peanut butter in my jam.
11:27:18 * hackagebot yesod-static 1.2.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.0.1 (MichaelSnoyman)
11:27:24 * Iceland_jack personally doesn't like maybe/either
11:28:18 <ReinH> errors are not conceptually the same type as members of the map. If they are in your type system then your type system is insufficiently expressive.
11:30:42 <Twey> Iceland_jack: Why not?
11:31:46 <Twey> It's nice to extract the commonly-repeated pattern and avoid some repetition.  It's also not as syntactically heavy as a case.
11:33:14 <Iceland_jack> Sure, you're right that they are common patterns and that they take up fewer characters. However most of the time I find them noisy and don't add to the legibility of the code, especially for longer branch expressions
11:33:15 <pure> I don't quite understand the purpose of Just
11:33:30 <Iceland_jack> pure: What do you mean?
11:33:45 <ReinH> pure: data Maybe a = Nothing | Just a
11:33:55 <pure> Yeah.
11:34:04 <Iceland_jack> pure: You have a value that may or may not be there, what do you return?
11:34:04 <ReinH> pure: a is not a Maybe. Just a is a maybe
11:34:07 <pure> But why not data Maybe a = Nothing | a?
11:34:19 <ReinH> Just is a type constructor that makes a value into a Maybe
11:34:20 <Iceland_jack> pure: Because you need a data constructor
11:34:30 <Twey> pure: How would you write Just Nothing using that scheme?
11:34:55 <Twey> (apart from the syntactic and implementational invalidity)
11:35:25 <Iceland_jack> pure: Would you like 'a' to have types Char, Maybe Char, Maybe (Maybe Char), Maybe (Maybe … (Maybe Char)) …))?
11:35:27 <Makoryu> pure: Haskell doesn't have ad-hoc sum types like Magpie
11:38:44 <apfelbox> I am in a function (GhcMonad m) => .... -> m () and want to call a function (without arguments) which returns IO () (it removes some directories)
11:38:59 <apfelbox> how do I need to call it, that I don't get a type error? oO
11:39:17 <mauke> step 1, it's not a function
11:40:00 <jdoles> apfelbox: given the way your phrased that, that would be impossible.
11:40:01 <mauke> apfelbox: liftIO whatever
11:40:22 <apfelbox> Couldn't match expected type `a0 -> IO a1' with actual type `IO ()'
11:40:23 <ReinH> jdoles: GhcMonad is a transformer stack that includes MonadIO
11:40:35 <apfelbox> I tried liftIO . clearOutputDir
11:40:40 <jdoles> ReinH: well, then it is possible.
11:40:43 <apfelbox> (clearOutputDir) is the function
11:40:55 <Twey> No it isn't
11:41:04 <Twey> And that's the source of your error
11:41:14 <mauke> apfelbox: why did you add that dot?
11:41:25 <Twey> The . (function composition) operator only works on functions.
11:41:30 <apfelbox> because I'm stupid :D
11:41:36 <apfelbox> liftIO $ clearOutputDir
11:41:38 <apfelbox> and it works <.<
11:41:45 <Iceland_jack> apfelbox: You can drop the $
11:41:46 <apfelbox> thanks!
11:41:48 <ReinH> or just liftIO clearOutputDir
11:41:50 <Twey> Also known as liftIO clearOutputDir
11:41:51 <mauke> apfelbox: why did you add that dollar sign?
11:42:01 <apfelbox> (you're right - it became a habit)
11:42:13 <ReinH> we must break you of this bad habit
11:42:13 <mauke> MAKE $$$$$ FAST
11:42:18 * hackagebot special-keys 0.1.0.2 - Simple data types that help me here and there.  http://hackage.haskell.org/package/special-keys-0.1.0.2 (HugoGomes)
11:42:22 <Iceland_jack> …is that how it works
11:51:37 * erisco lubs his dollar
11:51:59 <erisco> I guess that can have other meaning in the Haskell community now :)
11:52:10 <erisco> :t lub
11:52:11 <lambdabot>     Not in scope: `lub'
11:52:11 <lambdabot>     Perhaps you meant `nub' (imported from Data.List)
11:53:03 <Iceland_jack> @let lub = reverse . nub
11:53:04 <lambdabot>  .L.hs:198:17:
11:53:04 <lambdabot>      No instance for (Eq a0) arising from a use of `nub'
11:53:04 <lambdabot>      ...
11:53:39 * ReinH nubs his dollar
11:53:47 <Iceland_jack> @let { lub :: Eq a => [a] -> [a]; lub = reverse . nub }
11:53:49 <lambdabot>  Defined.
11:53:52 <mauke> I loeb Haskell
11:54:04 <Iceland_jack> lub [4,3,5,6,46,5]
11:54:07 <Iceland_jack> > lub [4,3,5,6,46,5]
11:54:13 <lambdabot>   [46,6,5,3,4]
11:56:14 <erisco> Iceland_jack, you can do that? :o
11:56:33 <Iceland_jack> I don't know!
11:56:48 <erisco> :t inf
11:56:49 <lambdabot>     Not in scope: `inf'
11:56:49 <lambdabot>     Perhaps you meant `int' (imported from Text.PrettyPrint.HughesPJ)
11:57:04 <erisco> @let inf ~(x:xs) = x : inf xs
11:57:05 <lambdabot>  Defined.
11:57:09 <erisco> :t inf
11:57:09 <lambdabot> [a] -> [a]
11:57:11 <erisco> cool :D
11:57:14 <Iceland_jack> @let inf = 1/0
11:57:14 <lambdabot>  .L.hs:212:1:
11:57:15 <lambdabot>      Multiple declarations of `inf'
11:57:15 <lambdabot>      Declared at: .L.hs:201...
11:57:17 <Iceland_jack> @let inf' = 1/0
11:57:19 <lambdabot>  Defined.
11:57:19 <Iceland_jack> > inf'
11:57:23 <lambdabot>   Infinity
11:57:30 <erisco> Iceland_jack, you can't overwrite my definition either? heheh
11:57:32 <mauke> > read "Infinity" :: Double
11:57:34 <lambdabot>   Infinity
11:59:43 <erisco> Twey, I think I missed something in my laws :o
11:59:50 <erisco> (not too surprising)
12:00:51 <erisco> an implementation of within which returns true for any non-vacant would pass, it seems, but that is entirely unsatisfying :P
12:01:08 <erisco> need some sort of reachability law =\
12:01:24 <erisco> can't seem to prove from the others
12:06:58 <chrisdone> http://www.reddit.com/r/haskell/comments/1lj39q/port_catch_to_ghc/
12:06:59 <chrisdone> if anyone wants to do this hit me up on reddit or @gmail
12:09:39 <ibotty> would you mentor?
12:09:49 <ibotty> (asking hypothetical)
12:10:16 <tarrasch> chrisdone, didn't know you had money to hire people, nor that somebody wanted that feature that badly ...
12:10:35 <ibotty> and in such a short timeframe :D
12:10:48 <Twey> erisco: Why are you doing this?  :þ  What's wrong with Data.Collection?
12:11:05 <darthdeus> hey guys, i have a little issue ... i have a function like this a :: (Char a) => [a] -> b;  a xs = 3
12:11:05 <darthdeus> and it tells me "'Char' is applied to too many arguments"
12:11:07 <erisco> Twey, thought I explained this? :)
12:11:21 <darthdeus> and it says the same thing even if i change it to   a :: (String a) => a -> b
12:12:19 * hackagebot special-keys 0.1.0.3 - Simple data types that help me here and there.  http://hackage.haskell.org/package/special-keys-0.1.0.3 (HugoGomes)
12:12:22 <tarrasch> darthdeus, you're not using type classes correctly. Maybe you should revise a few chapters from your text book?
12:12:36 <tarrasch> revisit*
12:12:59 <mauke> darthdeus: neither Char nor String are classes
12:13:08 <darthdeus> yeah probably :\ most of the things where i do something like (Ord a) => a -> a works fine, but i guess this something else
12:13:10 <darthdeus> oh
12:13:28 <mauke> and Ord isn't a type
12:13:38 <darthdeus> so this is correct then a :: (Num a) => String -> a
12:13:46 <darthdeus> because Num is a typclass and String is a type
12:13:48 <mauke> yes
12:13:56 <chrisdone> ibotty: not much more than the specified requirements. i don't want to spent time on this myself
12:14:00 <tarrasch> darthdeus, please don't make the habit of calling your function `a`
12:14:03 <darthdeus> perfect :)
12:14:12 <darthdeus> tarrasch: yeah i just shortened it for irc
12:14:19 <darthdeus> don't worry it's called "analyze" :P
12:14:30 <mauke> don't worry it's called "aaaaaa"
12:14:34 <tarrasch> May I suggest `f` or something. `f` usually is a function, `x` the value and `a` the polymorphic type
12:14:39 <tarrasch> mauke,  :)
12:14:52 <darthdeus> tarrasch: cool, that makes sense :)
12:14:52 <ibotty> chrisdone:  because it might be a good idea for people that want start understanding ghc (which i understand are a few)
12:15:01 <tarrasch> darthdeus, happy to help! :)
12:15:17 <darthdeus> this haskell thing is so thought-out
12:15:32 <ibotty> chrisdone: mentoring. maybe someone from ghc might be interested in it. it sounds like a very useful tool!
12:15:53 <S_J> So do SQL databases run an interpreter?
12:15:57 <chrisdone> ibotty: well, i'm familiar with the ghc api, i can mentor a little bit on that. the theory and implementation of catch, however, isn't something i can mentor on
12:16:09 <hebz0rl> oh je
12:16:22 <tarrasch> chrisdone, ibotty  and friends. You might like this article: https://ocaml.janestreet.com/?q=node/64
12:16:42 <chrisdone> tarrasch: i estimate a weekend and a bit. i can pay for that. if others will join, we can pay for more
12:17:02 <erisco> Twey, seems tricky to define without requiring finiteness
12:17:48 <tarrasch> chrisdone, but the weekend is just over! :(
12:18:17 <chrisdone> tarrasch: i've read that article before, but isn't it just saying "oh, look, exhaustiveness warnings aren't turned on by default in ghc"?
12:18:23 <Iceland_jack> tarrasch: The weekend is only over when you want it to be
12:18:35 <chrisdone> tarrasch: the next few weekends this september is reasonable
12:19:16 <ibotty> tarrasch: that article is not so convincing. -Wall warns about them (as i understood not in lambdas, but that's arguably an error in ghc).
12:19:56 <tarrasch> chrisdone, ibotty: You're  both right about the article
12:20:49 <ibotty> tarrasch: and there are reasons you might leave some cases unhandled, because they ought to be impossible. turning them into `error "that shouldn't happen"` will not warn and no static analysis tool will tell you about that
12:22:34 <chrisdone> what catch does is say "i can see that you have an inexhaustive case here, but actually it's only used such that all the cases are matched, so your code is (pattern-wise) total"
12:22:36 <S_J> what do haskellers think about F#? surely it must be good since it helps spread functional programming. is it used much?
12:22:56 <erisco> I think "it isn't Haskell"
12:23:00 <chrisdone> (under the philosophy that as long as the program is total, you shouldn't have to handle cases that cannot happen)
12:23:24 <Iceland_jack> S_J: I prefer F#'s syntax for error handling to Haskell's, apart from that I don't know much about it
12:27:47 <lightquake> when I try to install crypto-random, I get this error: /var/folders/n2/5nphmtgx4cd7l7qxn3b9d1dw0000gq/T/ghc25540_0/ghc25540_0.s:47:0:
12:27:47 <lightquake>     no such instruction: `rdrand %rcx'
12:28:57 <tarrasch> chrisdone, I'm actually looking for doing a bigger ghc project and I'm barely able to compile it. I'm actually thinking of maybe doing a mini-patch for ghc first. Just to gain some confidence before embarking on something big
12:29:01 <Iceland_jack> lightquake: Tried searching for ‘no such instruction: `rdrand’?
12:29:34 <tarrasch> chrisdone, however my work will be on the rts, and "catch" operates on a much higher level
12:29:37 <lightquake> yeah, no luck
12:31:53 <lightquake> it looks like my assembler doesn't think rdrand is a thing
12:32:02 <Iceland_jack> lightquake: I guess you don't have an Ivy Bridge processor? https://en.wikipedia.org/wiki/RdRand
12:32:20 <lightquake> Iceland_jack: that's the thing, it detects rdrand support via cpuid
12:32:21 <codesoup> if i have module Very.Long.Module where { commonName = ... ; foo = ... commonName ... }, can i somehow disambiguate (in the same module) commonName as M.commonName instead of Very.Long.Module.commonName?
12:32:56 <Iceland_jack> Hm…
12:33:09 <chrisdone> tarrasch: okies
12:33:48 <S_J> so clearly to make an sql database i have to make an interpreter right? you connect to a database via a TCP socket normally? so you send it a string in bytes(obv) and teh interpret "select blah from gah" in the db?
12:33:54 <lightquake> hm, it looks like the detection is busted somehow
12:34:13 <lightquake> because this is a sandy bridge machine
12:35:28 <pentace> codesoup: You can give a shorter qualifier name to the imported function
13:02:05 <lightquake> I have some ADT I want to serialize to disk in a reasonably efficient way. is there anything analogous to Show/Read that I can just derive, or do I want to just suck it up and use those and not care about the space usage?
13:03:05 <pentace> @hackage binary
13:03:05 <lambdabot> http://hackage.haskell.org/package/binary
13:04:00 <lightquake> neat, thanks
13:07:20 * hackagebot sourcemap 0.1.1.0 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.1.0 (ChrisDone)
13:10:04 <lightquake> hm, i'm trying to use the generic support but it's not working
13:13:07 <lightquake> oh, huh, I had an old binary
13:15:10 <donri> lightquake: also safecopy/acid-state if you want some extra safety
13:15:32 <lpaste> Umschwung pasted “(.) and flip” at http://lpaste.net/3941935866330480640
13:15:52 <Umschwung> Hi, everyone. Still learning Haskell, got a basic question for you.
13:16:45 <Umschwung> In the code I pasted, how would I be able to flip the arguments for h in its definition, to create h as a function of a -> Int -> a?
13:18:10 <Umschwung> I basically want to flip the definition of h again, after flipping, partially applying and composing f and g
13:18:28 <haasn> the simplest way would be to add ‘flip’ around the entire thing ;)
13:18:34 <haasn> but otherwise, I'd start by eta expanding
13:18:41 <haasn> h n x = (flip g n . flip f n) x
13:18:45 <S_J> is there a good library on Hackage that deals with IP? like writing an application protocol on top of TCP/IP?
13:18:53 <haasn> h n x = flip g n (flip f n x)
13:19:04 <haasn> h n x = g (f x n) n
13:19:14 <haasn> now assuming you want to flip that, just swap n and x on the left hand side
13:19:20 <haasn> h x n = g (f x n) n
13:19:41 <Umschwung> so, basically, performing the flip manually? :P
13:19:52 <arke> Twey: Just now getting around to it, was afk.
13:20:12 <S_J> > f g h i = g . h . i in f (+1) (*5) (-7) 3
13:20:13 <lambdabot>   <hint>:1:9: parse error on input `='
13:20:13 <haasn> h x = flip g <*> f x -- I think ?
13:20:21 <S_J> > let f g h i = g . h . i in f (+1) (*5) (-7) 3
13:20:23 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> c))
13:20:23 <lambdabot>    arising f...
13:20:23 <haasn> @pl h x n = g (f x n) n
13:20:26 <lambdabot> h = id (fix (const (flip (ap . (g .) . f) id)))
13:20:26 <lambdabot> optimization suspended, use @pl-resume to continue.
13:20:32 <haasn> uh never mind that
13:20:37 <S_J> > let f g h i = g . h . i in f (+1) (*5) (+7) 3
13:20:38 <lambdabot>   51
13:20:43 <S_J> > let f g h i = g . h . i in f (+1) (*5) (7-) 3
13:20:45 <lambdabot>   21
13:21:11 <kier> h x n = (g . f x) n n
13:21:11 <kier> h x = join (g . f x)
13:21:17 <S_J> > let f g h i = g . h . i in f (+1) (*5) (\x -> x - 7) 3
13:21:17 <kier> I think :S
13:21:18 <lambdabot>   -19
13:21:58 <Umschwung> haasn: is eta expansion the same thing as eta reduction?
13:22:06 <Umschwung> haasn: abstraction **
13:22:07 <haasn> Umschwung: yes except you're doing the opposite thing :P
13:22:23 <haasn> eta abstraction?
13:22:31 <Umschwung> haasn: yeah, typo, I meant: is abstraction the same thing as expansion
13:22:44 <Umschwung> haasn: since the Haskell wiki only mentions abstraction and reduction
13:22:49 <haasn> also uh h x = flip g <*> f x -- seems right, meaning  h = ap (flip g) . f
13:22:53 <Umschwung> http://www.haskell.org/haskellwiki/Eta_conversion
13:22:56 <haasn> Umschwung: then they probably are
13:23:09 <haasn> h = (g??) <*> f
13:23:11 <haasn> maximum pointless
13:23:33 <arke> Twey: what does the arrow character represent? I can't paste it in my editor and "->" won't compile (and wouldn't have made sense to me either)
13:23:54 <Rembane> > :t (->)
13:23:56 <lambdabot>   <hint>:1:1: parse error on input `:'
13:24:00 <Rembane> :t (->)
13:24:01 <lambdabot> parse error on input `->'
13:24:07 <Rembane> :(
13:24:19 <ekipan> it's a type constructor, it represents functions
13:24:24 <ekipan> :k (->)
13:24:25 <lambdabot> * -> * -> *
13:24:31 <ekipan> :k (->) Int Char
13:24:32 <lambdabot> *
13:24:48 <ekipan> Int -> Char is a base type that can be inhabited by values
13:33:57 <chrisdotcode> hi every one :)
13:41:10 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 is up. anyone feel like a proof-reading pass?
13:42:21 * hackagebot http-types 0.8.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.1 (AristidBreitkreuz)
13:42:22 * hackagebot aws 0.8.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.1 (AristidBreitkreuz)
13:44:52 <luite> edwardk: part 3 will surely include a rasterizer for arbitrary diagrams, right?
13:45:05 <edwardk> luite: obviously
13:45:12 <edwardk> luite: so long as i can keep it under 100 lines
13:45:27 <edwardk> i figured including a custom png renderer made it somewhat practical
13:45:40 <edwardk> as it actually generates a pretty damn efficient png in the end
13:45:51 <luite> didn't they have juicypixels installed? (ok that's less fun of course)
13:46:01 <edwardk> i didn't see it.
13:46:02 <edwardk> it might
13:46:47 <luite> meh annoying hackaton, i only talked to people, hardly coded ;p
13:46:57 <danharaj> You can viw tying off 's' as taking a coend you are so categorically inclined.
13:47:13 <edwardk> danharaj: figured you'd zoom in on that fixing it
13:49:26 <danharaj> edwardk: you might like this article if you could bypass the paywall
13:49:27 <danharaj> http://link.springer.com/chapter/10.1007/978-3-642-04772-5_23
13:49:54 <edwardk> danharaj: bookmarked for when i'm lurking at MIT
13:50:11 <danharaj> save me a copy if you get a chance :P
13:50:47 <luite> hm, zurich is kinda expensive, the pizza i got yesterday was $25
13:50:51 <luite> oh wrong chan
13:50:55 <donri> i wonder what coq is the dual of?
13:51:03 <danharaj> q
13:51:12 <donri> obviously, but what's that?!
13:51:22 <luite> donri: why aren't you at zurihac?
13:51:39 <donri> luite: why indeed!
13:53:35 <danharaj> This strikes me as an incredibly implementation clean pattern for HMACs such as http://en.wikipedia.org/wiki/MD5 and http://en.wikipedia.org/wiki/SHA-1 in Haskell.
13:53:49 <edwardk> heh
13:54:10 <edwardk> fixed
13:54:22 <danharaj> edwardk: what is the relationship between comonads as coroutines and the continuation monad?
13:54:36 <edwardk> danharaj: dunno. figure it out. write something
13:54:40 <edwardk> but there is something there
13:54:48 <donri> the dual of the ntinuation comonad
13:54:50 <danharaj> maybe at icfp I'll have breathing room to think :P
13:54:57 <edwardk> the fact that they make resumable HMACs etc is fun
13:55:02 <donri> nope these jokes never get ol d
13:55:04 <danharaj> that is totes cool
13:55:12 <danharaj> I like that pattern.
13:55:18 <edwardk> donri: the dual of Cont is Cont.
13:55:26 <donri> :(
13:55:48 <danharaj> We'll use Data.Binary to write out the results, mostly because PNG is an annoyingly introspective format, so we'll have to talk about the lengths of fragments we're generating as wel go.
13:56:00 <edwardk> k
13:56:01 <Eduard_Munteanu> edwardk: hey... I was trying to define stuff in TH and it seems like [d| |] can't contain splices because it typechecks too early. I think you also had trouble doing that in lens, no? (I see your [d| |] comments.)
13:56:15 <danharaj> Getting (Endo (Endo (Moore b a))) s b
13:56:17 <Eduard_Munteanu> edwardk: but is there a workaround, maybe in a newer version of GHC?
13:56:17 <danharaj> you deserve to be shot
13:56:29 <edwardk> Eduard_Munteanu: not that i know of
13:56:34 <edwardk> danharaj: hah
13:56:41 <Eduard_Munteanu> Ah. :(
13:57:02 <donri> Eduard_Munteanu: i just did that myself
13:57:14 <Eduard_Munteanu> donri: oh?
13:57:47 <donri> Eduard_Munteanu: https://github.com/dag/safecopy/blob/instances/test/instances.hs
13:58:27 <Eduard_Munteanu> Huh, why doesn't it work for me then...
13:59:11 <Eduard_Munteanu> donri: I was trying a simple   let name = mkName "Foo" in [d| data $name = $name |]
13:59:23 <Eduard_Munteanu> Oh, I see what you did there.
13:59:32 <Eduard_Munteanu> Yeah, that works AFAIK.
13:59:36 <donri> Eduard_Munteanu: yeah that may not work that way
14:00:00 <danharaj> I'll be switching to 4 line minimalist version of Gabriel's foldl library
14:00:05 <danharaj> edwardk: cool example at the end
14:00:08 <edwardk> k
14:00:35 <edwardk> danharaj: did you see the first version?
14:00:41 <danharaj> yeah
14:00:44 <edwardk> in part 1, where it was rendering to svg?
14:00:46 <edwardk> ah k
14:00:54 <edwardk> the next part will have it work on custom topologies
14:01:07 <donri> Eduard_Munteanu: may need to do something like, [d| data $(conT name) = $(not sure, also conT? name) |] brb
14:01:21 <edwardk> maybe part 4 i can do the 'hold-the-session-open and send multiple images so i can do life or other 2d automata as multiple frames
14:01:30 <Eduard_Munteanu> donri: I tried that before
14:01:48 <edwardk> combined with the custom topologies from part 3 that could get interesting
14:02:27 * danharaj wonders if automata can detect the genus of their underlying graphs
14:02:41 <Eduard_Munteanu> It seems to be this issue: http://ghc.haskell.org/trac/ghc/ticket/4230
14:02:59 <joelteon> > foldr f [a,b,c,d]
14:03:00 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr
14:03:00 <lambdabot>                      [D...
14:03:03 <joelteon> > foldr f a [a,b,c,d]
14:03:04 <lambdabot>   f a (f b (f c (f d a)))
14:03:14 <joelteon> > foldl f a [a,b,c,d]
14:03:14 <danharaj> wait
14:03:15 <lambdabot>   f (f (f (f a a) b) c) d
14:03:16 <danharaj> what library is that
14:03:19 <danharaj> I want it for my ghci.
14:03:38 <edwardk> danharaj: simple-reflect
14:03:55 <edwardk> i use it in the AD examples/doctests a lot
14:03:56 <haasn> danharaj: good luck with that
14:04:02 <haasn> I eventually commented out the imports in my ~/.ghci :P
14:04:07 <donri> Eduard_Munteanu: but, quoting is in deed massively broken in TH :p i think they're fixing it for 7.8
14:04:07 <danharaj> :o
14:04:27 <edwardk> danharaj: re genus, not sure. sounds like a fun project. go for it ;)
14:04:42 <danharaj> edwardk: I have too many thoughts and not enough time :<
14:04:54 <edwardk> danharaj: i can empathize ;)
14:04:56 <Eduard_Munteanu> donri: quite unfortunate because it looks so much better than the AST
14:05:05 <donri> Eduard_Munteanu: agreed
14:06:47 <ocharles> edwardk: i can't imagine what would happen if you *did* have enough time
14:06:47 <ocharles> :P
14:07:18 <edwardk> i have a 4 day weekend. look our world
14:07:24 <edwardk> er look out
14:08:00 <donri> the combination of all edward's packages on hackage become self-aware
14:10:43 <haasn> when edwardk's type signatures finally become self aware they will spend their time improving lens
14:11:19 <edwardk> haasn: they do. where do you think we got #haskell-lens from?
14:11:34 <haasn> the real edwardk died a long time ago
14:11:41 <haasn> from sleep deprivation
14:12:03 <edwardk> well, yes. i'm something like the 130th clone
14:13:09 <mcstar> .oO( Moon )
14:15:35 <augur> can i just emphasize again how wrong this is: https://www.fpcomplete.com/school/advanced-haskell-1/the-mother-of-all-monads
14:16:03 <quchen> augur: Go for it.
14:16:04 <mcstar> i almost read that
14:16:14 <augur> quchen: it's very wrong
14:16:15 <augur> :)
14:16:19 <augur> quchen: :P
14:16:27 <quchen> augur: Glad you cleared that up for me.
14:16:34 <augur> quchen: no problem!
14:16:56 <quchen> So what subset of Haskell monads is Cont the mother of?
14:17:07 <augur> quchen: its wrong in that its first line, it's whole purpose in being written -- suppose someone stole all the monads -- is actually NOT whats going on
14:17:09 <quchen> Seems to work listy or maybey.
14:17:20 <augur> it's not the mother of any monads
14:17:26 <augur> its the mother of no monads
14:17:42 <quchen> Well you can emulate some other monads with it.
14:17:48 <augur> no you cant
14:17:59 <augur> the article cons you into thinking you can
14:18:04 <augur> and i think dan piponi conned himself too
14:18:12 <augur> but his words betray the con
14:18:33 <augur> cmd-f ex8 where he says
14:18:37 <augur> "... b <- cont (\fred -> [10,20] >>= fred) ..."
14:18:59 <augur> "Note, we're using monad related functions, but when we do so we're not using do-notation."
14:19:10 <augur> but i thought all the monads were stolen
14:19:18 <augur> now you're saying all that was stolen was do notation?
14:19:20 <augur> poppycock!
14:19:40 <augur> do notation isnt necessary for monads, and is barely important
14:19:51 <quchen> Well you can't steal monads because if you could you could just redefine them.
14:19:59 <quchen> And call >>= concatMap. Tadaa, List is back
14:20:09 <quchen> That's sort of what he does there
14:20:10 <ekipan> they can take the do notation so long as I get my AMP
14:20:24 <geekosaur> I munderstood that to mean he was pretending that >>= was an operator defined only on Cont
14:20:28 <augur> quchen: not if you dont have monads as a type class, and no type classes to define your own monads with
14:20:39 <augur> geekosaur: except it obviously aint
14:20:43 <quchen> ekipan: I think I finished the patch today. Some infrastructure questions remain.
14:20:44 <augur> cause its acting on a list, not a Cont
14:21:14 <ekipan> I know nothing of the status. Is there an idea of the impact on Hackage?
14:21:28 <quchen> ekipan: Devastating would be my estimate
14:21:33 <augur> quchen, geekosaur: this is why i think the article is very problematic
14:21:38 <darksouls> wake wake
14:21:39 <augur> its saying one thing, and doing another
14:21:42 <quchen> ekipan: That's why we didn't go for straight errors but for a long transitional phase
14:21:51 <augur> its giving you general do notation if you only have do notation for Cont
14:22:02 <augur> but it ISNT giving you monads if all you have is Cont
14:22:04 <augur> quite the contrary
14:22:12 <augur> it REQUIRES that all monads exist already
14:22:14 <darksouls> write a book on this literature
14:22:29 <augur> its a scam. noone stole the monads
14:22:32 <augur> they only stole the do's
14:22:34 <haasn> I thought Codensity was the mother of all monads. except Cont
14:22:36 <haasn> or something
14:22:37 <quchen> ekipan: Chances are is that 7.8 will be asking you to fix your code so the AMP won't break it in the future basically.
14:22:38 <augur> but who needs do's!
14:22:46 <darksouls> fuck you
14:22:54 <quchen> Dude.
14:23:01 <darksouls> fuck you
14:23:02 --- mode: ChanServ set +o geekosaur
14:23:11 <ekipan> weird
14:23:19 <augur> if we had to live without do, we could get by easily. it serves only to give us imperative-y looking code
14:23:28 <augur> but really, is this:
14:23:35 <haasn> and vastly more understandable one at that, in many cases
14:23:52 <augur> liftM2 f mx my = do x <- mx ; y <- my ; return (f x y)
14:23:53 <spaceships> what is the purpose of continuations in a lazy language?
14:23:58 <augur> really all that more comprehensible than
14:24:17 <augur> liftM2 f mx my = mx >>= \x -> my >>= \y -> return (f x y)
14:24:18 <augur> ?
14:24:24 <darksouls> agh
14:24:33 <quchen> augur: Yes, especially when you add newlines.
14:24:39 <Twey> I mostly use do-notation for saving brackets
14:24:41 <augur> quchen: but its not
14:24:46 <donri> @pl liftM2 f mx my = mx >>= \x -> my >>= \y -> return (f x y)
14:24:46 <lambdabot> liftM2 = liftM2
14:24:48 <quchen> Also it just feels nicer if you ask me.
14:24:49 <donri> xD
14:24:56 <edwardk> > 2 * do 3 + 4 -- twey like that?
14:24:58 <lambdabot>   14
14:25:00 <ekipan> or better yet (return f `ap` m1 `ap` m2)
14:25:09 <Twey> donri: I started doing that in my head as soon as I saw the code >.<
14:25:12 <darksouls> what do you want from my ass
14:25:13 <augur> all you're doing is substituting   mx >>= \x ->   with   x <- mx
14:25:15 <ekipan> and its prettier-looking applicative spellings
14:25:18 <Twey> edwardk: No, that's further on the evil side :þ
14:25:19 <quchen> augur: Not that it makes much of a difference. I like do notation but I guess if it had never been there I would've gotten used to that too.
14:25:24 <donri> Twey: same
14:25:26 <geekosaur> tone the attitude down, darksouls
14:25:26 <augur> big whoop, you save a few characters and reverse some things
14:25:33 <augur> quchen: exactly!
14:25:39 <darksouls> fuck you you dont neglect your childish nature
14:25:42 --- mode: geekosaur set +b *!brad@199-255-209-157.anchorfree.com
14:25:50 <augur> and do notation is a hack in haskell anyway because of a lack of good syntax magic
14:25:57 <augur> there is no do notation in agda, but we still have do notation
14:26:06 <quchen> augur: 'do' also introduces a new layout block which is sometimes handy.
14:26:06 --- mode: geekosaur set +b *!~brad@199-255-209-157.anchorfree.com
14:26:08 <augur> because we have (better) syntax magic
14:26:12 <darksouls> the brain fucker
14:26:19 --- kick: darksouls was kicked by geekosaur (darksouls)
14:26:28 <haasn> I've gotten to the point where I open up a new .hs file and the first thing I do is write “import Control.Lens”
14:26:36 <haasn> Is there some way I could automate this in vim? :)
14:26:44 <geekosaur> I suspect my client is doing very wrong things there, sigh
14:26:45 <donri> Twey: hah i wonder if edwardk's evil trick could "fix" multiway if
14:26:57 <quchen> Multiway if is broken?
14:27:04 <Twey> donri: No, don't think so
14:27:10 <Twey> Er, well
14:27:11 <donri> quchen: no layout
14:27:11 <augur> latro`a: you're in maryland!
14:27:17 <Twey> I guess you could just stick a do in front of it
14:27:27 <Twey> Boom, instant layout
14:27:27 --- mode: ChanServ set +o edwardk
14:27:39 <donri> yes that's the idea
14:27:41 <augur> quchen: my point tho, right, is that the article is really confusing
14:27:49 <Twey> Hrm
14:27:52 <Twey> I… think that works
14:27:55 <augur> for aaaages i thought it meant precisely that if the only monad you had, period, was Cont, then you could recover the rest
14:28:00 <quchen> augur: Oh. Well yeah. It sounds like it explains Cont but it really doesn't.
14:28:02 --- mode: edwardk set +b *!~brad@199-255-209-167.anchorfree.com
14:28:09 <augur> but after i read it more precisely, i realized it wasnt saying anything of the sort, and was terribly confused
14:28:10 <haasn> nice, I just realized we have an overloaded lens for ‘swap’
14:28:16 <edwardk> haasn heh
14:28:26 <edwardk> haasn: its a bit more restrictive than it could be
14:28:32 <edwardk> i wanted to use it the other day and couldn't
14:28:44 --- mode: geekosaur set -b *!brad@199-255-209-157.anchorfree.com
14:28:47 --- mode: geekosaur set -b *!~brad@199-255-209-157.anchorfree.com
14:28:58 <haasn> edwardk: what's missing?
14:29:05 <augur> why dont you just ban * on that address
14:29:11 <edwardk> just wante to use it for my keys in the sparse matrix code
14:29:15 <quchen> donri: "No layout"?
14:29:17 <augur> *!*@...
14:29:32 <edwardk> augur: easier to remember who the ban was for, automated tool
14:29:37 <donri> quchen: if you nest 'em they don't do what you think
14:29:46 <augur> edwardk: bah!
14:29:51 <quchen> donri: Ah, I see. That sounds inconvenient.
14:30:08 <quchen> donri: And it's unfixable without breaking tons of code?
14:30:25 <quchen> Or whatever was written using it since 7.6
14:30:25 <donri> quchen: http://ghc.haskell.org/trac/ghc/ticket/4359#comment:89
14:30:30 <donri> quchen: duno, is it used that much?
14:30:51 <quchen> donri: I don't know. I certainly never nested it.
14:31:18 <donri> quchen: yeah i don't imagine it coming up *that* often, but it scares me that it could explode
14:31:27 <supki> haasn: au BufNewFile *.hs execute "normal! iimport Control.Lens"
14:31:33 <supki> haasn: I think
14:34:44 <donri> quchen, Twey: hm btw, how does it handle incomplete matches? "if" forces you to write the "else" case, "case" can warn you if you miss a case, but multiway if has no idea... does it make you write an explicit "otherwise" or does it let you write bottom? :p
14:35:25 <quchen> donri: I don't know, but I would imagine it's similar to writing definitions with guards.
14:36:09 <quchen> donri: Also note that if doesn't match, it uses a boolean expression. You can't test whether at least one of them holds.
14:36:14 <Twey> donri: It lets you write bottom, with the usual warnings about non-exhaustive patterns where appropriate
14:36:34 <donri> Twey: ah so you do get a compile time warning at least
14:36:55 <nooodl> hmm. i have a function "pick :: (RandomGen g) => [a] -> Rand g a" that picks a random element out of a list
14:36:56 <donri> quchen: well that's my point, it can't know
14:37:10 <nooodl> and does so by calculating its length, which isn't very efficient for regular linked lists
14:37:24 <nooodl> i also have "foo = pick someConstantHugeList"
14:37:51 <quchen> donri: Hm, right. I guess one fix would be requiring an 'otherwise' as you've mentioned. That may not be such a bad idea.
14:37:52 <nooodl> will that calculate the length of someConstantHugeList each time i call foo?
14:38:24 <quchen> nooodl: Look up 'reservoir sampling'. You can uniformly pick a random element of a list without calculating its length.
14:38:30 <donri> quchen: Twey says it gives a warning, which would be consistent with other things
14:38:55 <haasn> supki: thanks
14:40:14 <chrishart> hi there, i'm interested in writing a webapp that will compile and run arbitrary haskell code that you supply. would it be safe to simply disallow any functions in IO? are there any backdoor-ey ways to "delete system32"?
14:40:36 <donri> chrishart: see safehaskell
14:40:47 <donri> chrishart: but even then it doesn't provide safe *compilation* yet
14:41:19 <nooodl> quchen: strange, http://en.wikipedia.org/wiki/Reservoir_sampling the pseudocode here has "length(S)" in it. am i misunderstanding something
14:41:41 <quchen> nooodl: It never uses that length, that's just to find out when to stop finding a random element.
14:41:51 <nooodl> oh i see
14:42:04 <quchen> nooodl: That look just walks over the array, and Python etc.
14:42:06 <Twey> donri: AIUI it's just sugar for case () of ()
14:42:20 <chrishart> donri: thank you
14:42:22 <nooodl> yeah, gotcha. thanks!
14:42:42 <quchen> nooodl: I had the same objection when dmwit showed me that snippet :-)
14:42:59 <donri> nooodl: hm there's even a web framework specifically built for this but i forgot its name
14:43:04 <donri> oops
14:43:06 <donri> that was for chrishart
14:43:27 <quchen> chrishart: Codepad's 'about' page talks a little about how the compilation is implemented. http://codepad.org/about
14:44:42 <donri> chrishart: and a library spawned from that diagrams pastebin gsoc... hm
14:45:43 <donri> chrishart: https://github.com/co-dan/interactive-diagrams/wiki/Restricted-Workers
14:46:20 <chrishart> neat!
14:52:53 <donri> chrishart: oh http://hackage.haskell.org/package/hails
15:06:28 <Ghoul_> > undefined `asTypeOf` 3
15:06:29 <lambdabot>   *Exception: Prelude.undefined
15:09:55 <Ghoul_> :t foldWhile
15:09:56 <lambdabot> Not in scope: `foldWhile'
15:12:19 <Ghoul_> is there a way to terminate a fold early?
15:12:45 <tikhon> you could use a scan, I think
15:12:56 <tikhon> :t scanl
15:12:57 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
15:12:58 <Ghoul_> ah, cheers
15:13:28 <tikhon> this is one of the reasons I really like laziness
15:13:35 <mlamari> I use a ScanL/First() combination in C# sometimes to get around absence of easy local recursion.
15:13:51 <Ghoul_> I would have to use takeWhile to apply my predicate, right?
15:14:09 <Ghoul_> > tail $ takeWhile (x < 100) $ foldl (+1) [1..]
15:14:10 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
15:14:10 <lambdabot>              with actua...
15:14:16 <Ghoul_> > tail $ takeWhile (< 100) $ foldl (+1) [1..]
15:14:17 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [t0]'Couldn't...
15:14:42 <Ghoul_> ugh
15:15:40 <quchen> Ghoul_: What you're looking for is basically `find` written using `foldr`.
15:16:19 <Ghoul_> > last $ takeWhile (< 100) $ scanl (\a b -> a + 1) 1 [1..]
15:16:20 <lambdabot>   99
15:16:22 <Ghoul_> lemme take a look at find
15:16:48 <quchen> Ghoul_: http://lpaste.net/92417
15:17:19 <quchen> You can make any foldr short-circuit by just not using the accumulator in some definition.
15:17:25 <quchen> When you reach that branch the fold terminates.
15:17:48 <Ghoul_> :t foldr
15:17:49 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:18:39 <quchen> Ghoul_: "foldr f z" takes a list and replaces every (:) with f and [] with z.
15:19:03 <quchen> Ghoul_: http://lpaste.net/92418
15:19:31 <quchen> Now if some of the "f" just don't look at the branch that's coming out on the right side the function terminates
15:19:56 <Ghoul_> ooh
15:20:05 <Ghoul_> thanks for that explanation, it cleared things up
15:21:08 <quchen> Ghoul_: That also explains why "foldr (:) []" is the identity for lists.
15:21:16 <quchen> :t foldr (:) []
15:21:16 <lambdabot> [a] -> [a]
15:29:24 <Kelet> Hello, I'm extremely new to functional programming. I'm trying to flesh out my idea of what it actually is. If an operation is referentially transparent, can it at the same time not be idempotent?
15:29:48 --- mode: geekosaur set -o geekosaur
15:30:02 <Iceland_jack> Kelet: There are at least two definitions of the term ‘idempotent’, are you referring to the mathematical one
15:30:03 <haasn> I don't see how idempotence has any relevance here
15:30:11 <haasn> idempotent is just f∘f = f
15:30:12 <haasn> iirc
15:30:18 <Kelet> I'm referring to the computer science meaning.
15:30:45 <Iceland_jack> Computer science meaning? They're both used in computer science
15:30:47 <Kelet> f(f(x)) = f(x) for any value x
15:30:52 <Iceland_jack> right
15:31:05 <arkeet> http://en.wikipedia.org/wiki/Idempotent#Computer_science_meaning
15:31:12 <jroesch> the "computer science" meaning is just a special case where x is the world state
15:31:18 <haasn> Right, I don't see what this has to do with referential transparency or purity, in a general sense
15:31:22 <haasn> for example consider ‘abs’
15:31:29 <haasn> abs . abs = abs
15:31:59 <Iceland_jack> Do you understand referential transparency Kelet?
15:32:03 <haasn> this is true whether you're using functional programming or not (well, modulo the availability of composition in non-functional languages :)
15:32:08 <Kelet> Iceland_jack, No, that's what I'm trying to figure out.
15:32:22 <Kelet> I'm having trouble wrapping my brain around it
15:32:58 <Iceland_jack> OK, so you can think of it as meaning "you can replate equals by equals"
15:33:24 <Iceland_jack> you can replate (2 + 4) with 6 because the expression (2 + 4) is referentially transparent
15:33:57 <Demos> so is mathey Idempotence sort of a special case of fix f terminating?
15:33:58 <haasn> alternatively
15:34:03 <Iceland_jack> you can replate (do putChar 'a'; putChar 'a') with (let a = putChar 'a' in do a; a) because (putChar 'a') is referentially transparent
15:34:13 <haasn> it means that f (g x) (g x)  =  let x' = g x in f x' x'
15:34:39 <haasn> suppose ‘g’ has side effects, like a hypothetical ‘print’ that doesn't use IO
15:34:55 <haasn> f (print "hello") (print "hello")  might print "hello" twice in an impure language
15:35:03 <haasn> whereas let x' = print "hello" in f x' x'  might only print it once
15:35:16 <haasn> (and re-use the result)
15:35:23 <haasn> in Haskell, this has no distinction
15:35:37 <haasn> because the result of an expression and the expression itself are equivalent in the context
15:37:48 <FreeFull> haasn: Until you use unsafePerformIO
15:37:58 <haasn> shh
15:38:00 <Iceland_jack> Mentioning unsafe* is not helpful
15:39:05 <ekipan> IO is the type of referentially opaque procedures
15:39:19 <ekipan> the constructor of types of*
15:39:22 <FreeFull> The only problem is that lazy languages have a different evaluation order, so are a bit more unpredictable
15:39:49 <ReinH> *non-strict
15:39:54 <FreeFull> As long as you have IO trapped in a monad or uniqueness types you're fine
15:40:09 <FreeFull> ReinH: I guess lazy is a property of the implementation
15:40:41 <augur> Iceland_jack: you've got it backwards
15:40:55 <augur> its not the expression `2 + 4` that is referentially transparent
15:40:55 <ekipan> with (>>=), you can take those procedure and attach functions on them to get more complex procedures
15:41:01 <augur> it is contexts that are transparent (or not)
15:41:15 <Iceland_jack> augur: please elaborate
15:41:37 <ekipan> an executable program constitutes one such procedure, called Main.main
15:41:57 <augur> Iceland_jack: the phrase "referentially transparent" applies to environments/program contexts, and means that within that context, you can replace equals for equals
15:42:32 <Iceland_jack> so is there a context where (2 + 4) can not be replaced by 6?
15:42:40 <augur> Kelet: the notion of referential transparency originates in philosophical logic, going back to frege, at the very least
15:43:36 <augur> Iceland_jack: in haskell? i dont know. i think the unsafe stuff is the only example of a truly referentially opaque context.
15:44:03 <mlamari> The thunks are mutable :P
15:44:19 <ekipan> thunks are implementation detail
15:44:24 <augur> Kelet: a classic example of referential opacity is the "believe" verb in english. We know that Clark Kent = Superman, but these two sentences mean different things:
15:44:59 <Iceland_jack> augur: An expression is said to be referentially transparent if it can be replaced with its value without changing the behavior of a program (in other words, yielding a program that has the same effects and output on the same input).
15:45:03 <Iceland_jack> [from Wikipedia]
15:45:17 <augur> "Lois believes Superman defeated the villain"   --   "Lois believes Clark Kent defeated the villain"
15:45:20 <mlamari> Been learning from the new Marlow/concurrency book - technically, the mutable nature of thunks themselves though is something we kind of have to keep in mind.
15:45:26 <augur> Iceland_jack: well ill have to change that then.
15:45:27 <Iceland_jack> That seems to indicate that referential transparency in Computer Science is a property of an expression
15:45:44 <Iceland_jack> Please do if you have citations for it
15:45:45 <Raydiation> are references side effects?
15:45:54 <augur> Iceland_jack: someone who misunderstood referential transparency wrote that.
15:46:00 <augur> i wouldnt trust wikipedia, anyway.
15:46:09 <Iceland_jack> So how would you phrase what I just said?
15:46:20 <Raydiation> i mean you have to be vary of side effects if you pass stuff by reference right?
15:46:21 <augur> Iceland_jack: which what
15:46:32 <augur> Kelet: does that make sense so far?
15:46:33 <Iceland_jack> For example that you can replace (2 + 4) with 6
15:46:56 <ekipan> "passing" of arguments is a rather procedural term
15:47:07 <augur> Iceland_jack: whether you can do that or not depends on where the expression occurs.
15:47:16 <Iceland_jack> sigh
15:47:26 <Iceland_jack> I'm looking for a way of using ‘referential transparency’ in a sentence
15:47:44 <augur> Iceland_jack: why?
15:47:44 <tiffany> iceland_jack: that's called constant folding
15:47:56 <Iceland_jack> tiffany: That's a totally different context from what I'm talking aobut
15:47:57 <Iceland_jack> *about
15:48:07 <tiffany> I guess
15:48:22 <augur> Iceland_jack: why do you want to use ref. trans. in a sentence
15:48:27 <Raydiation> ekipan: yeah i mean in languages like scala or javascript
15:48:34 <Iceland_jack> augur: I'm sorry for wanting to use words
15:48:40 <Raydiation> regarding memoization
15:48:41 <Iceland_jack> What I'm talking about could also be said of replacing 6 with (4 + 2) without being constant folding
15:49:07 <augur> Iceland_jack: but i mean, you must have some intention behind using them
15:49:23 <augur> its not like you just woke up this morning and thought, "I should use 'referential transparency' in a sentence!"
15:49:30 <Kelet> augur, Sort of. I get that even though the sentence is referencing the same thing, it has a different meaning, hence opaque. But I do not understand why this is the function of the verb 'believe'
15:49:32 <Iceland_jack> Well, normally when I learn concepts I want to be able to use them in a sentence correctly
15:49:40 <Iceland_jack> I wasn't aware that that was something strange
15:49:41 <Kelet> You could replace believe with a host of verbs and it still be opaque I think
15:49:52 <augur> Kelet: right, it's not JUST believe that has this properly
15:50:12 <augur> but you can also replace "believe" with other verbs and it will suddenly not mean different things
15:51:17 <augur> Kelet: some verbs create opaque contexts, some dont.
15:51:18 <Kelet> augur, So you are saying that referring to Clark Kent is opaque or transparent based on the verb used?
15:51:28 <Kelet> what is an example of a transparent verb in this context
15:51:31 <augur> no no, its not about "Clark Kent" vs "Superman"
15:51:39 <augur> its about how "believe" doesn't let you substitute underneat it
15:52:23 * hackagebot sourcemap 0.1.2.0 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.2.0 (ChrisDone)
15:52:26 <Kelet> Well for example if someone knew me by say a shorter version of my name, believe would be transparent for most situations would it not?
15:52:30 <Kelet> Say Chris vs Christopher
15:52:45 <debo> tomato vs tomato
15:52:51 <augur> Kelet: oh thats a tricky thing. lets not go there :)
15:52:53 <Iceland_jack> From most sources I've read, referential transparency in Computer Science has no meaning that is universally agreed upon: but that ‘referential transparency’ is the property where who expressions that reduce to the same value in any context can be interchanged and that such an expression may be called ‘referentially transparent’ within that context
15:52:58 <augur> the point is just for you to get the gist
15:53:14 <augur> Kelet: the idea is, some contexts allow substitution of equals, others dont.
15:53:24 <mm_freak_> ok, which definition of referential transparency in programming languages is the proper one?
15:53:26 <Iceland_jack> If you have a reference that gives a different definition I would be interested in seeing it
15:53:33 <Kelet> Yeah, I never really thought to just think of the meaning of the words actually
15:53:44 <Kelet> That's what happens when something sounds nasty to me sometimes I suppose
15:53:53 <mm_freak_> it seems that linguists love to make fun of computer scientists when it comes to the notion of referential transparency
15:54:14 <augur> mm_freak_: not all computer scientists get it wrong!
15:54:22 <augur> and its not just linguists, its philosophers too
15:54:28 <augur> they invented the notion, after all
15:54:32 <augur> frege and russell!
15:54:48 <ekipan> notation is an attempt to achieve transparency in the murky opaque contextfull pit of language
15:54:52 <augur> probably kripke has some stuff on it
15:55:32 <Kelet> Alright, now another issue I'm trying to overcome is I'm not sure I understand how FRP can be purely functional. Signals and such. I kind of get it - it represents a variable over time, and that representation doesn't change. But it seems like it kind of 'cheats the system'. Or rather, it seems like lifting a value from a signal for example is kind of like having a side effect or global variable.
15:55:45 <Iceland_jack> Computer science ≠ Philosophy
15:55:56 <Kelet> I think I'm just looking at functional programming too much like everything is immutable and not so much as satisfying referential transparency
15:56:14 <Kelet> I'm not even sure if I understand immutability.
15:56:26 <augur> Iceland_jack: that doesnt give computer scientists a pass at misusing the term
15:56:31 <Kelet> For example you have an aggregate data structure and you *replace* one element of the aggregate.
15:56:37 <Kelet> Is the aggregate immutable?
15:56:42 <Iceland_jack> augur: A lot of terms have different meaning between disciplines, this is nothing new
15:56:55 <Kelet> I was reading about something called zippers but I couldn't grasp the concept but it kind of seemed like it was related to such a concept
15:57:06 <augur> Iceland_jack: i think you're misperceiving CS, anyway
15:57:08 <Iceland_jack> Let me get this straight augur, is your objection to my usage of ‘referential transparency
15:57:34 <Iceland_jack> augur: Care to back that up?
15:57:35 <augur> to your usage, yes. ive never seen the issue brought up in a serious CS context where its been misused. but maybe im not paying enough attention.
15:57:49 <augur> back what up
15:57:57 <Iceland_jack> That I'm misperceiving CS
15:58:21 <augur> its a suspicion, so no, there is nothing to back up
15:58:37 <mm_freak_> Kelet: here is a trivially pure FRP system:  type Behavior a = Time -> a
15:59:40 <mm_freak_> getting events into this is difficult, but can be achieved
15:59:43 <Kelet> mm_freak_, What is the relation between pure, immutable, and referentially transparent? Immutability is a way of satisfying referential transparency, and a function is pure if it satisfies referentially transparency?
16:00:00 <mm_freak_> type Event a = Time -> [(Time, a)]
16:00:05 <Iceland_jack> augur: I must admit you're not being very helpful: You claim I misuse a term, then I ask for a correct usage and you ask me to explain why I'd want to be able to use the term correctly. Then I ask you for some resources backing your objections up and offer resources backing my own usage up and you simply say they are wrong and offer nothing in return
16:00:09 <mm_freak_> at each time it's the list of events that have occurred so far
16:00:24 <augur> Iceland_jack: i gave you a correct usage. i dont know what you're complaining about.
16:00:43 <Kelet> mm_freak_, That makes sense, I didn't think of time as an argument since it's often implicit in FRP libs/langs
16:00:53 <Iceland_jack> I asked how I could phrase my original point in terms of your usage and you question why I'd want to do that
16:01:40 <mm_freak_> Kelet: not only implicit, it's usually not even an absolute time that is used internally, but that shouldn't concern you as an FRP user
16:02:20 <Kelet> mm_freak_, Hmm but I guess conceptually, I know this seems like a weird scenario, but
16:02:31 <augur> Iceland_jack: and thats a valid question. im not sure you CAN do it, but so what? why are you so reluctant to explain your motivations?
16:02:54 <Kelet> If time was an argument and the time was '6000' and you "reset your clock" at a later time back to '6000' it could give a different result if you were doing something different at the 'repeated' time
16:03:02 <Kelet> (I realize that it isn't a feasible scenario)
16:03:24 <ekipan> lots of things don't make sense once you implement time travel :)
16:03:26 <mm_freak_> Kelet: real FRP systems generally don't support a notion of "resetting time"
16:03:29 <Kelet> lol
16:03:30 <Iceland_jack> If my example is not an example of referential transparency then that's fine, but if it is an example of referential transparency I'd like to know how to call it that so avoid future nit-picks
16:03:54 <mm_freak_> Kelet: also when running an FRP system you don't do this:  map f [0, 0.1 ..]
16:04:13 <Hodapp> waitwaitwait... I can use Haskell on an MSP430 microcontroller?
16:04:16 * Hodapp blinks
16:04:51 <mm_freak_> if you really were to implement it as naively as that, then the complexity would grow linearly in the number of switches that have occurred to that point
16:05:01 <mm_freak_> and switching is an important ingredient in FRP
16:05:27 <Hodapp> mm_freak_: Are you well-educated in FRP?
16:05:45 <mm_freak_> Hodapp: well, i'm the author of netwire =)
16:05:47 <augur> Iceland_jack: http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf
16:06:01 <augur> this is a good place to look for discussion of the different notions
16:06:10 <Hodapp> mm_freak_: Good to know. I had been looking at some FRP stuff, but put it on hold for a bit - but I'll probably direct some queries at you.
16:06:26 <augur> Iceland_jack: your example isn't precsiely an example of referential transparency, because it's focused on the expression not the context
16:07:04 <mm_freak_> Hodapp: i'm not the only one who can answer your questions though…  we have quite a few people in here who understand FRP very well
16:07:06 <augur> Iceland_jack: its almost meaningless to say, full stop, that you can substitute (2 + 4) for 6, except maybe in that it expresses a claim about the referential transparency of all contexts in the language
16:07:23 <mm_freak_> conal, Cale, and i think sometimes apfelmus is in here as well
16:07:40 <Iceland_jack> Thank you for the resource augur, I'll take a look at it. Since my example was not in fact referentially transparent could you rather give me an example of something that is?
16:07:47 <mm_freak_> in particular conal pretty much invented FRP =)
16:07:56 <augur> Iceland_jack: at best, that's what you can say: if 2+4 and 6 are mutually substitutable, then all contexts are referentially transparent. or something like that.
16:08:20 <augur> Iceland_jack: well, i gave an example of it in natural language, but in programming the examples abound
16:08:27 <Hodapp> mm_freak_: I've read about it a bit (particularly Yampa), but I've written next to nothing. I read far enough, though, to see that FRP was basically something that I had tried to invent, badly, by myself, having not known about FRP or any other kind of RP.
16:08:44 <Kelet> mm_freak_, Well, I'm actually giving an introductory presentation on FRP (~15 minutes) hence my instigation of concepts here. Unfortunately, while I have a fair bit of experience with Lisps and languages with first-class functions (and some Scala), I've never really delved into the Haskell side of the world nor FRP. Seems really interesting. I'm mostly using Elm for my examples because it produces results that are understandable by laymen.
16:08:57 <Iceland_jack> Your way of putting it sounds fairly forced though: ‘if x and y are mutually substitutable, then all contexts are referentially transparent’
16:09:11 <augur> Iceland_jack: yes, it is forced
16:09:14 <augur> because you forced it
16:09:15 <Kelet> But I've seen FRP used in a lot of Haskell stuff, your netwire library for example, and some GUI libraries (fruity loops or something?)
16:09:21 <augur> you wanted me to say something with "referentially transparent"
16:09:26 <Iceland_jack> Right you are
16:09:30 <arkeet> chrisdone: ide.fay-lang.org isn't working (redirects to github). is that supposed to happen?
16:09:34 <augur> that doesnt mean that it was a sensible thing to do!
16:09:44 <Kelet> Seems like a great paradigm for opening up functional languages to event-driven programs and such
16:09:46 <ekipan> ref transparency is a property of the "equals" relation of some context, not of expressions, is that right?
16:09:50 <mm_freak_> Kelet: grapefruit has been used for GUIs, but nowadays i would suggest giving reactive-banana a try for GUIs
16:09:53 <augur> there is no notion of flat-out substitutability, afaik, Iceland_jack. it depends 100% on where the target expression is
16:10:00 <mm_freak_> Kelet: for more real-timy applications netwire is definitely the way to go
16:10:05 <mm_freak_> like games
16:10:19 <Hodapp> mm_freak_: But what's the value of FRP outside of more real-time apps?
16:10:21 <Kelet> mm_freak_, why?
16:10:39 <arkeet> Hodapp: have you ever used a spreadsheet?
16:10:49 <Hodapp> arkeet: I always considered a spreadsheet a more real-timey application.
16:10:53 <arkeet> oh.
16:10:58 <mm_freak_> i don't really like the spreadsheet analogy…  it explains only 1% of FRP
16:11:02 <arkeet> true
16:11:19 <augur> Iceland_jack: the best example, at some level of discussion, is quotations. obviously this fact: 2+4 == 6 does not let us do "2+4" == "6"
16:11:54 <Kelet> mm_freak_, I was going to use that analogy to explain at least the reactive part, because it's something that programmers who don't know about functional/reactive can understand. Do you have a better analogy for laymen? Basically, I'm presenting to some senior C.S. undergrads who should've had perhaps half a semester learning about functional languages (sadly)
16:11:59 <augur> but that's precisely the point -- the quotes dont let you reason normally
16:12:04 <Kelet> well, help explain
16:12:11 <Hodapp> Kelet: that's half a semester more than my curriculum devoted to them.
16:12:13 <mm_freak_> Hodapp: whenever you are dealing with a main loop (possibly with some subloops) and a huge application state that is updated by the individual components, this is probably better expressed as a reactive system
16:12:45 <mm_freak_> Kelet: FRP probably can't be explained to laymen
16:12:57 <Hodapp> mm_freak_: That main loop suggests to me that it's already real-timy - but I might be using 'real-timy' in a very hand-waving way here
16:13:22 <mm_freak_> Hodapp: not at all…  an example of such an application is a chat server
16:13:54 <tiffany> that is a very broad definition of real-timy
16:13:55 <mm_freak_> in fact many concurrent programs that don't really use the concurrency for I/O but rather for the communication part…  each of these applications can be expressed in terms of FRP
16:15:12 <Hodapp> alas, I must run
16:15:48 <mm_freak_> Hodapp: to expand somewhat on the chat server example, a chat client is usually viewed as a concurrent IO thread that reads from the client and may update some global state that in turn may trigger sending other clients stuff
16:15:59 <mm_freak_> but all of this is really just a pure time-dependent function
16:16:03 <Iceland_jack> augur: The reason I asked you for that ‘forced’ line was because your objection ran against other usage I've heard of referential transparency in Haskell, so maybe I should ask you about referential transparency in Haskell: How would you describe it and are there examples of it?
16:16:38 <augur> Iceland_jack: i would describe it the same as before!
16:16:50 <augur> a context is referentially transparent if you can substitute equals for equals in the context
16:17:28 <augur> haskell is almost uniformly referentially transparent, with the exception of a few unsafe operations that let you peak at operational behavior
16:17:47 <hpc> those unsafe operations always (usually) begin with "unsafe"
16:17:48 <Iceland_jack> So assuming your definition, you had problems with overloading the term for the expressions themselves?
16:18:22 <augur> Iceland_jack: it's just wrong to use it for terms. it doesnt make any sense to even speak about terms as being substitutable
16:18:29 <augur> substitution is ABOUT contexts
16:18:35 <mm_freak_> augur: so when you say "if x = y, then f x = f y", then it's not really the 'f' that's referentially transparent, but the whole sentence?
16:18:53 <augur> mm_freak_: it's the context f _
16:19:21 <mm_freak_> how do you establish the context?  quantification?
16:19:32 <augur> what do you mean "establish the context"
16:19:44 <mm_freak_> why is "f _" context?
16:19:53 <augur> because it just is?
16:19:55 <Iceland_jack> augur: http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Referential_transparency_%28computer_science%29.html So you object to this definition as well?
16:19:59 <augur> its a one hole context of an AST, mm_freak_
16:20:08 <Iceland_jack> > and referential opaqueness are properties of parts of computer programs. An expression is said to be referentially transparent if it can be replaced with its value without changing the program (in other words, yielding a program that has the same effects and output on the same input).
16:20:09 <lambdabot>   <hint>:1:43: parse error on input `of'
16:20:23 <augur> Iceland_jack: yes, thats just wrong.
16:20:34 <Iceland_jack> It seems like a lot of resources are wrong
16:20:36 <mm_freak_> augur: is know context as the gamma in the underlying logic…  is that related?
16:20:41 <augur> Iceland_jack: yes.
16:20:50 <augur> mm_freak_: no.
16:21:05 <mm_freak_> then i don't know what "context" means here
16:21:07 <augur> context here is in the sense of "whats around the thing"
16:21:15 <augur> the program around the expression
16:22:21 <jmcarthur> hmm... part of a context is called a continuation, but is there a name for the other part?
16:22:23 <Kelet> What is the relation between pure, immutable, and referentially transparent? Immutability is a way of satisfying referential transparency, and a function is pure if it satisfies referentially transparency?
16:22:42 <augur> Kelet: probably none.
16:23:21 <augur> part of the problem with the typical discussion on RefTrans is that noone knows what "semantics" means
16:23:21 <mm_freak_> Kelet: immutability really just means, if you ever say "x = 3", then you can assume "x = 3" for the whole scope of the definition
16:23:28 <Iceland_jack> I am unable to open the pdf on my computer, are there any other resources that agree with you?
16:23:28 <dwcook> Kelet, in other languages, you can actually have a referentially transparent function that mutates things within itself.
16:23:37 <augur> people say crazy things like "the value of "x++" is x + 1
16:23:39 <augur> which is absurd
16:23:45 <jmcarthur> dwcook: in haskell too (e.g. ST)
16:24:07 <Hodapp> augur: Why's it absurd? Side effects?
16:24:08 <mm_freak_> Kelet: the "x" is then immutable and "x = 3" is an equation, not an assignment/update
16:24:10 <augur> denotationally, the value of "x++" cant be x+1, it has to be some function on state
16:24:22 <augur> but then it becomes obvious that you cant substitute, because they're not equal!
16:24:31 <mm_freak_> referential transparency is so complicated that i don't understand it, so i can't explain it =P
16:24:36 <ekipan> https://docs.google.com/viewer  <- for pdfs
16:24:36 <mm_freak_> and "pure" is an informal notion
16:24:36 <Kelet> If something is immutable, can it be referentially opaque?
16:24:43 <augur> Iceland_jack: uh.. get a better PDF reader
16:24:45 <Kelet> If so, example?
16:25:07 <augur> mm_freak_: you know what a program is, right? :P
16:25:11 <mm_freak_> augur: yes =)
16:25:37 <augur> mm_freak_: ok, so take a program, and pluck out an expression from it, leaving a hole where you can stick something
16:25:46 <mm_freak_> ok
16:25:53 <augur> mm_freak_: call that a context
16:26:01 <mm_freak_> the hole or the program?
16:26:08 <augur> the program-with-a-hole
16:26:13 <mm_freak_> ok
16:26:22 <mm_freak_> \x -> program x
16:26:28 <augur> not quite
16:26:34 <mm_freak_> \x -> programBy x
16:26:36 <augur> but if you want, that's a good approximation.
16:26:44 <mm_freak_> yeah, just informal
16:26:46 <augur> its more a zipper, if you know what those are
16:26:50 <mm_freak_> yeah
16:27:42 <augur> a context K is referentially transparent if, given two expressions M and N with equal values, the values of K{M} and K{N} are equal
16:27:51 <augur> where K{M} is K with M in the hole
16:27:56 <augur> etc.
16:29:00 <augur> the only example i know if this in haskell is this thing that gets you the time. that's the only thing that lets you build ref-opaque contexts in haskell, because you can distinguish runtimes
16:29:13 <mm_freak_> augur: for some equivalence relation i presume?
16:29:30 <augur> mm_freak_: yeah, obviously the notion of equality is going to need to be addressed
16:29:52 <augur> but the point is really that ref opaque contexts force a certain notion of equality, to some extent
16:30:48 <Iceland_jack> augur: So calling a routine in an imperative language ‘referentially opaque’ is also wrong?
16:30:57 <Iceland_jack> Because that's what http://www.cas.mcmaster.ca/~kahl/reftrans.html does
16:31:03 <mm_freak_> augur: can functions be considered contexts in this sense?
16:31:35 <augur> mm_freak_: eh. functions in the haskell sense, or in the mathematical sense?
16:31:44 <mm_freak_> augur: haskell sense
16:31:56 <augur> Iceland_jack: referential transparency is a property of contexts, full stop.
16:32:04 <augur> if by "routine" you mean context, then fine.
16:32:08 <mm_freak_> augur: and the mathematical sense on the grounds of type theory
16:32:26 <augur> mm_freak_: i would say no.
16:32:46 <Iceland_jack> No disrespect, but what you're saying goes against too many resources
16:33:02 <augur> Iceland_jack: good for those sources
16:33:16 <mm_freak_> Iceland_jack: many resources indeed get it wrong
16:33:26 <augur> just because a lot of people are wrong doesnt mean they're right
16:33:39 <Iceland_jack> mm_freak_: No doubt, but it would be foolish to dismiss their usage just because a nick on IRC told me they were wrong
16:33:55 <augur> the notion of an expression being referentially transparent is just 100% incoherent
16:34:12 <mm_freak_> Iceland_jack: i'd say they are not wrong in what they want to express, but they express it wrong
16:34:19 <Iceland_jack> Fair enough
16:34:19 <applicative> oh, augur has figured it out, i see.
16:34:30 <augur> applicative: darn tootin!
16:34:37 <Kelet> All pure functions are referentially transparent. A referentially transparent function does not have to be pure. For a language to be defined as 'purely functional' do all functions have to be pure, or do they have to be referentially transparent?
16:34:40 <augur> ive got it all figured out!
16:34:58 <geekosaur> so would either of you experts like to say something useful *to Haskell programmers*?
16:35:09 * applicative in his youth learn to use 'transparent' and 'opaque' only as modifying 'context'
16:35:11 <mm_freak_> augur: given an expression expr with a free variable x, does (expr, x) count as a context?
16:35:30 <augur> mm_freak_: no, i would avoid conflating holes with variables
16:36:15 <mm_freak_> augur: ok, say x = y → f x = f y…  how do you express this in terms of referential transparency?
16:36:19 <ekipan> is that a quote from somewhere, Kelet?
16:36:21 <applicative> "'believes that ...' generates an opaque context" was the way the jargon worked
16:36:34 <augur> mm_freak_: i wouldnt. its not a fact about referential transparency
16:36:37 <ekipan> the first two sentences
16:36:51 <Kelet> ekipan, More or less from the last answer here: http://stackoverflow.com/questions/4865616/purity-vs-referential-transparency
16:36:54 <applicative> mm_freak_: easy: it is the claim that 'f ...' is transparent
16:37:05 <augur> no applicative thats not true
16:37:11 <mm_freak_> hmm
16:37:13 <augur> its a claim that f respects =
16:37:25 <applicative> x = y -> Jones believes that x is wise -> Jones believes that y is wise, is a bad generalization
16:37:54 <mm_freak_> conclusion:  i'll stop using the term "referential transparency" in the future =)
16:37:55 <augur> mm_freak_: x = y -> f x = f y is just a statement that f respects =
16:38:06 <augur> if this is true about all f's, then it means = is a congruence
16:38:14 <applicative> augur: exactly, the mathematical jargon about a transformation 'respecting' some equivalence is a more abstract version of what quine was doing
16:38:28 <monochrom> I am not an expert (yeah right), but I have a useful suggestion. stop using the word "referential transparency" and its derivative.
16:38:30 <augur> applicative: no, its really not
16:38:48 <augur> applicative: quine, and his antecendents, were talking about expressions, period. not functions, etc.
16:38:49 <applicative> augur: oh, whats the diff? i was trying the suggestion out
16:39:01 <applicative> augur: of course thats true yes
16:39:03 <ekipan> how about "warm, fuzzy, property of contexts"? :P
16:39:04 <augur> and thats a hugely important thing, because this is about how languages relate to their semantics
16:39:14 <augur> NOT about the semantics in isolation
16:39:43 <augur> monochrom: how about we just use it correctly? :P
16:39:58 <mm_freak_> augur: the correct usage doesn't seem very useful to programmers
16:40:02 <augur> applicative: this is why im wary of saying f is reftrans
16:40:04 <applicative> augur: I still think i might be able to make something of what i said above, but i see, yes
16:40:11 <monochrom> the problem is that people argue over what is "correctly".
16:40:22 <augur> applicative: what you said makes sense, but its not ref trans :)
16:40:32 <augur> monochrom: "correctly" is an adverb, duh
16:40:39 <augur> (bam! referential transparency joke!)
16:40:48 <applicative> augur: my point was you need something like a concept of 'identity' of 'x = y', then in certain contexts it carries over, others not
16:40:57 * geekosaur is waiting for one of our experts to suggest something that is actualy useful to new haskell programmers, since apparently it is no longer permissible to use this one
16:41:04 <augur> mm_freak_: so? the orrect usage of "purple" isnt either
16:41:11 <augur> should we redefine purple to mean something useful to programmers?
16:41:18 <augur> or should programmers just use the words that are useful to them?
16:41:32 <applicative> it would good to find some useful words
16:41:37 <mm_freak_> augur: that's not the point…  it must be easier to explain "does not have side effects"
16:41:47 <geekosaur> but of course it;s jusrt wrong to try to teach them what they need to know, they need math degrees before they're allowed to think about it apparentlu
16:41:50 <applicative> 'side effects' means nil.
16:41:50 <augur> applicative: it would be useful for people to be precise about what they want to express too :)
16:42:04 <Iceland_jack> Levels of snark, rising
16:42:31 <augur> mm_freak_: transparency and sideeffects are distinct notions, except maybe to some people like CCShan, who's i think tried to interpret one as the other? i dont know.
16:42:31 <ekipan> precision requires study, i.e. work
16:42:36 <ekipan> and I am far too lazy for that
16:42:53 <monochrom> I am a bit cynical and pessimistic. programmers already use the word "function" wrong.
16:43:07 <ekipan> indeed!
16:43:13 <Iceland_jack> monochrom: wrong ≠ differently from mathematics
16:43:27 <applicative> when i first learned about the cs jargon 'side effects' i thought, man this is nonsense; now i think it even more so.
16:43:32 <augur> monochrom: yeah. well. that term has existed outside of math since before math, so thats a harder one to justify
16:43:49 <applicative> it is based on the experience of throwing a print statement in the middle of some loop and the like
16:44:01 <mm_freak_> programmers used to use the proper term for what they call "function" today
16:44:04 <mm_freak_> "procedure"
16:44:10 <augur> applicative: part of the problem is that noone gives semantics for imperative languages
16:44:19 <mm_freak_> also haskell programmers use the word "method" wrong
16:44:24 <augur> so all they can talk about is "side effects", etc.
16:44:31 <ekipan> it has been fashionable to call them "methods" as well
16:45:52 <applicative> Debug.trace is a sort of model of the source of the idea of a 'side effect'; it is doubtful that such a concept could take us very far.
16:45:55 <mm_freak_> in fact most programmers for most languages get "method" wrong, but i think it's worse in haskell than in other languages
16:46:25 <arke> I've got several fuctions that take a record and returns a new record with only one member different; is there a "clean" way to do this without writing out all record members every time?
16:46:38 <augur> but my earlier point about x++ and x+1 is important. i think that clarifies another reason why i think the expression level usage is just wrong.
16:46:42 <mm_freak_> arke: two clean ways
16:46:44 <applicative> is my operating system a 'side effect'
16:46:52 <mm_freak_> arke: f x = x { field = y }
16:47:00 <mm_freak_> arke: the second clean way is using lenses
16:47:08 <mm_freak_> f = field .~ y
16:47:27 * applicative is the wisest haskeller on #haskell, for he knows that he knows nothing
16:48:08 <ekipan> am I wiser if I know more nothing?
16:48:47 <applicative> yes
16:48:59 <applicative> as you you know you know more nothing
16:49:33 * monochrom disputes applicative. monochrom is wiser, for he can actual suggest wise tautologies, such as "the solution depends on the problem" and "the more you know, the more you know"
16:49:35 <ekipan> oh I definitely know more nothing, but I'm not sure how much more nothing I know that I know, so maybe I'm not wiser after all
16:49:57 <applicative> unlike the dogmatic windbags who tells that e.g. monads arent containers, since obviously the picture is of limited utility
16:50:15 <arke> mm_freak_: ooh, lenses are new to me. The first way is what I was looking for, but the second thing I may have to use as an excuse to procrastinate on what I'm trying to do. Thanks!
16:50:35 <applicative> monochrom: the more you know the greater your vanity, and the stupider and more vicious you become
16:50:48 <edwardk> arke: there is video! and there are many online tutorials for lens
16:51:20 <edwardk> arke: lens is a pretty deep rabbit hole though, so be warned. =)
16:51:44 <applicative> hah http://www.slideshare.net/fullscreen/terriko/how-does-biology-explain-the-low-numbers-of-women-in-cs-hint-it-doesnt/24
16:51:52 <augur> applicative: monads are totally containers, in an abstract sense :)
16:52:16 <monochrom> you had me scared. until I saw "hint it doesn't"
16:52:25 <applicative> augur: oh really? the authorities on haskell call you a corrupt moron if you say that
16:52:43 <augur> the authorities being copumpkin, in this case
16:52:53 <augur> which is ok :P
16:53:15 <monochrom> "monads are containers" is at about the same level as "survival of the fittest"
16:53:34 <augur> the authorities on haskell seem to lack any understanding of pedagogy. quite a common thing among programmers. "just read the code! it explains itself!"
16:54:03 <monochrom> i.e., but what are containers? answer: monads. but what is fittest? answer: survival.
16:54:06 <applicative> this one has a certain charm in the context, though it isn't meant seriously monochrom http://www.slideshare.net/fullscreen/terriko/how-does-biology-explain-the-low-numbers-of-women-in-cs-hint-it-doesnt/14
16:54:07 <joelteon> @pl \(a,b) -> f a >>= \a1 -> f b >>= \b1 -> return (a1,b1)
16:54:07 <lambdabot> uncurry ((. (flip (fmap . (,)) . f)) . (>>=) . f)
16:54:16 <joelteon> I need a mapM that works on a tuple instead
16:54:39 <mm_freak_> "monads are containers" is at about the same level as "functions are referentially transparent"
16:54:42 <mm_freak_> =)
16:54:43 <augur> monochrom: there should ofcourse always be the caveat "not really", but intuitions are important, despite what copumpkin wants to say from atop his learned mountain
16:54:46 <applicative> if monads can be trees with grafting, why not containers?
16:54:56 <copumpkin> o.O
16:55:07 <augur> thats right, copumpkin, im lookin at you
16:55:07 <copumpkin> so either we suck at pedagogy or we say monads are containers?
16:55:30 <augur> no, im saying you _do_ suck a pedagogy. :P
16:55:40 <arke> edwardk: I'm not even at the part where I do anything with monads yet, so maybe I should wait a few days before diving in :)
16:55:44 * applicative doesnt care for containers either, but the snide superior people have even to offer
16:55:49 <applicative> even less
16:55:51 <edwardk> arke: safe bet =)
16:56:11 <augur> copumpkin: you're in good company tho, so its ok
16:56:12 <arkeet> monads are quotients of free monads.
16:56:30 <monochrom> copumpkin: why not both? we suck at pedagogy and we say monads are containers :)
16:56:32 <arke> (I'm picking it up quicker than I had feared though; looking good so far)
16:57:15 <applicative> when 'monad' is used in connection with a type system with constructors, there is more material available that in a purely category theoretic approach. the latter tends to destroy understanding in haskell.
16:57:26 <augur> the best metaphor for monads i think is the monads-as-computations metaphor, but im not sure any one metaphor is perfect for pedagogy
16:57:51 * applicative attempts to assign content to 'computation' 
16:58:01 <augur> applicative: :)
16:58:05 * haasn also likes the ‘computation’ metaphor more than others
16:58:08 <arkeet> I ate breakfast today. was that a computation?
16:58:12 <augur> the point of analogies and metaphors is to bootstrap on existing intuitions
16:58:17 * monochrom has a cunning plan!
16:58:27 <augur> even if noone knows what computation "really" is, thats irrelevant
16:58:30 <haasn> arkeet: was it a monad?
16:58:36 <monochrom> "computation" means Applicative. therefore, a monad is a computation, yes.
16:58:37 <augur> its the intuition we're targeting, not the One True Meaning
16:58:38 <applicative> 'computation' seems to have been introduced by moggi ... out of desperation
16:58:45 <arkeet> haasn: I don't know!
16:59:25 <augur> applicative: it was out of pedagogical utility, i suspect.
16:59:30 <ekipan> a monad is a functor plus return and bind, such that the monad laws hold.
16:59:59 <augur> ekipan: you should change your name to copumpkin2
17:00:11 <mm_freak_> i wonder how you explain Cont as a container
17:00:11 <monochrom> therefore, the sentence "applicative attempts to assign content to 'computation' " is true :)
17:00:44 <ekipan> well, someone asked for a definition, not an explanation :)
17:00:54 <mm_freak_> and how you explain Unit in terms of "computation"
17:01:00 <augur> monochrom: you dont. you choose your battles wisely
17:01:08 <applicative> augur: my point, if there was one, was that he gave it content in the context; basically the explanation was 'different forms of computation' are 'different monads' ; but 'monads are really computations' thus becomes 'computations are computations; monads are monads' which is not an explanation
17:01:17 <mm_freak_> there is no metaphor to rule them all
17:01:18 <augur> er, mm_freak_ ^
17:01:50 <applicative> Cont is a perfectly good container; first you have to be come practiced at view a function Int -> a as a container of an a
17:01:52 <augur> mm_freak_: i mean, you can force it. its not too bad. but at some level you just dont explain, you just say you're going to think of it that way
17:02:00 <augur> which is what we actually do
17:02:04 <augur> i mean, when we write something like
17:02:08 <augur> k $ \x -> m
17:02:18 <augur> with the continuation k
17:02:22 <arkeet> but really, has anyone tried writing a monad tutorial that first describes the universal examples (e.g. free monads) and then observes that all monads are quotients of such things.
17:02:25 <arkeet> it would probably be awful.
17:02:26 <augur> we think of it as feeding a value in for x
17:02:44 <augur> sure it doesnt HAVE to do that, but thats how we think of it, to deal with the practical issue of actually writing programs
17:02:47 <applicative> first you must become practiced at viewing 'Int -> a' as a varying a
17:02:58 <mm_freak_> applicative: complete the sentence:  "the container Cont . const contains …"
17:03:08 <augur> applicative: also know as a generalized element :)
17:03:12 <monochrom> free monad seems to be a rather recent trend. wait one more year for a monad tutorial that starts with free monad
17:03:21 <augur> heaven forbid we use the intuitions that the mathematicians themselves have!
17:03:31 <applicative> exactly augur; i'm sure generalized elements will be attacked by mm_freak_ as well
17:03:56 <mm_freak_> now introduce labels and goto in terms of Cont, complete the sentence: "goto contains …"
17:04:13 <applicative> what is the concrete type?
17:04:14 <roconnor> Cont doesn't meet the tradition definiton of a container (of being isomorphic to a polynomial functor)
17:04:17 <augur> mm_freak_: you're missing the point of an analogy
17:04:29 <mm_freak_> no, i'm not =)
17:04:29 <augur> roconnor: different notion of container
17:04:33 <mm_freak_> i use analogies all the time
17:04:34 <applicative> roconnor: that's a perfectly good account of container too
17:04:38 <augur> mm_freak_: yes, you definitely are
17:04:44 <monochrom> goto contains magic :)
17:04:50 <applicative> roconnor: taken up from the naive use of container in typed programming languages
17:04:53 <mm_freak_> augur: no, i'm not
17:05:07 <augur> those questions are pointless. you're taking the analogy beyond its intended domain of applicability
17:05:53 <applicative> monads are kinda like polynomial functors; lets start out tutorial with that 'intuition'; it wouldnt be so bad
17:06:32 <mm_freak_> augur: yes, i'm doing that on purpose, because metaphors build a bad/constrained intuition about monads, and beginners struggle with that
17:06:48 <mm_freak_> you can think of monads in terms of a metaphor, but you shouldn't introduce them that way
17:06:53 <augur> mm_freak_: beginners struggle with the "real" definition even more so.
17:07:10 <mm_freak_> augur: not if you explain monads the way you should:  by example
17:07:14 <applicative> the evidence for this is nil, mm_freak_
17:07:24 <augur> mm_freak_: yes if you explain it that way
17:07:34 <applicative> whats wrong with 'monads are trees with grafting'
17:08:01 <monochrom> that's just free monads. but ok.
17:08:03 <mm_freak_> applicative: well, not all monads are free monads =)
17:08:21 <augur> the problem ofcourse is that the plethora of monad tutorials was also pedagogically bad
17:08:29 <augur> its not ENOUGH to simply say
17:08:33 <augur> monads are (sorta) containers
17:08:57 <augur> you have to say that, and then some.
17:09:10 <augur> but few monad tutorials ever did the latter part.
17:10:13 <applicative> do cats have four legs and a tail?
17:10:28 <applicative> i mean mm_freak_ do cats have four legs and a tail?
17:10:42 <mm_freak_> applicative: i don't know
17:11:07 <applicative> you're not going to make any progress in pedagogy with that attitude
17:12:13 <ekipan> as someone who already *has* something of an intuition, I wonder why more tutorials don't start with Functor and work the way up
17:12:29 <applicative> the attacks on the 'container analogy', which I don't care for, have all rationality of NO CATS DONT HAVE FOUR LEGS ONLY SOME OF THEM DO: FOUR LEGGED CATS ARE A SPECIAL CASE WE SHOULDNT GETS TO FOCUS ON THEM,
17:12:43 <applicative> they should know right away about legless manx cats too
17:12:47 <ekipan> like this: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
17:12:53 <augur> applicative: part of the problem also is that people want to write things that are like.. three pages long maybe?
17:13:08 <applicative> of course
17:13:08 <monochrom> ekipan: I think it is related to: why there aren't tutorials dedicated to Functor
17:13:08 <augur> but most of these ideas require 10 pages or more to properly teach
17:13:23 <applicative> monochrom: a functor is kind of like a container ...
17:13:32 <ekipan> though that one is guilty of the common mistake of conflating "monad/functor" with actions of them
17:13:40 <monochrom> and I think the answer overall is: Functor is not mysterious enough
17:13:52 <mm_freak_> applicative: the same pedagogy that allows you to teach about cats does not work for everything…  my point is really that you shouldn't start an introduction to monads with: "monads are …"
17:13:52 <applicative> you go in with your function, and you swap everything out.
17:14:09 <applicative> no one says that, where is an example?
17:14:15 <augur> applicative: ive had to write a lens tutorial because slogging through the lens literature for good intuitions has been a pain in the ass. same for iteratees
17:14:40 <augur> applicative: monads are burritos!
17:14:43 <wollw> I stopped feeling so intimidated by Monads etc when I stopped thinking of them as anything other than a typeclass with some rules.
17:14:54 <applicative> good work wollw
17:14:55 <edwardk> lenses are for space suits!
17:15:13 <edwardk> wollw: smart way to think about them
17:15:17 <monochrom> people really like to blog about their opinion on mysterious things. the less they know, the more they want to blog about it.
17:15:25 <danharaj> what ghci command lists imported names
17:15:25 <mm_freak_> applicative: the idea is to let people build their own metaphors by looking at a number of examples
17:15:28 <applicative> the only real difficulty about monads is the same for functor, its grasping (*->*) in the context of an infinite type system
17:15:32 <spaceships> monads are spaceships in the saucer category
17:15:43 <mm_freak_> applicative: that approach has worked very well in my workshops
17:16:12 <applicative> mm_freak_: no, the #haskell conformists who attach these attempts have a quite different agenda
17:16:23 <applicative> who attack these attempts, e.g.
17:16:28 <applicative> container analogies
17:16:35 <danharaj> agdenga: what agda enthusiasts have
17:16:42 <augur> mm_freak_: throwing examples at people is the worst way to achieve anything
17:16:46 <augur> you need examples, but just examples, without a good mental framework, is useless
17:17:05 <pharaun> i never found those blogs on monad to be helpful at all
17:17:19 <augur> danharaj: i have an agdenda :D
17:17:22 * applicative suspects augur may actually have managed to teach something to someone
17:17:25 <pharaun> what helped was looking at the mathmatical notation then trying them out and playing with them then go from there, boom!
17:17:27 <augur> pharaun: they do such :)
17:17:29 <augur> suck*
17:17:35 <danharaj> an agdenda is a pull request to an agda repo on github
17:17:37 <augur> i should write a monad tutorial!
17:17:55 <danharaj> alternatively, an extension to agda
17:18:03 <applicative> agda is off topic
17:18:07 <augur> i actually came to understand monads from watching Catsters about 40 times
17:18:25 <monochrom> yikes, 40 times is many, many times
17:18:26 * applicative just thought he's say that to use the customary device of the #haskell conformists
17:18:31 <augur> not 40 literally, monochrom
17:18:38 <augur> but i think ive watched like 10 times? dunno. its just fun, so
17:18:46 <mm_freak_> augur: assuming that i'm a complete idiot is also not a good way to get any point across in a subjective discussion
17:19:00 <mm_freak_> augur: i know very well that simply putting examples on the table does not work
17:19:48 <applicative> mm_freak_: i don't see why not; thats your attitude to everyone, so it must be a legitimate attitude on #haskell
17:20:15 <mm_freak_> ok, i'll shut up now
17:22:33 * edwardk comes in, notices folks with claws out, and goes away
17:22:49 <Admiral-Bell> :q
17:23:29 <chrishart_> @pl \(a,b) -> (b,a)
17:23:32 <lambdabot> ap (flip (,) . fst) snd
17:23:32 <lambdabot> optimization suspended, use @pl-resume to continue.
17:23:48 <mm_freak_> :t liftA2 (,) snd fst
17:23:49 <lambdabot> (a, b) -> (b, a)
17:24:03 <augur_> stupid crummy internet connection
17:24:04 <tikhon> Catsters? I must be missing something.
17:24:18 <augur_> tikhon: its a youtube series on category theory
17:24:23 <tikhon> aha
17:24:43 <applicative> oh you don't know them. some of its a little rough as i remember, but uniformly charming
17:24:45 <tikhon> seems like it could be quite interesting
17:24:53 <applicative> or well-spirited or something
17:25:08 <chrishart_> @pl \x -> y . f x
17:25:08 <lambdabot> (y .) . f
17:25:08 <applicative> the eckman hilton clock is the best
17:25:16 <augur_> tikhon: edsko's map is best
17:25:45 <augur_> https://www.scss.tcd.ie/Edsko.de.Vries/ct/catsters/linear.php
17:26:39 <augur_> adjunctions were another beast of a concept for me
17:26:52 <augur_> im still not sure i understand them, but
17:27:10 <augur_> bootstrapping my way into categorical logic helped a bit there, oddly
17:28:04 <applicative> just the first 10 of http://www.youtube.com/watch?v=Rjdo-RWQVIY give the spirit of the thing tikhon
17:28:09 <applicative> 10 seconds rather
17:28:39 <augur_> TODAY we're going to talk about ~
17:28:50 <monochrom> MONADS!
17:28:52 <augur_> i think im going to try to start each class with that
17:29:12 <applicative> okay, up to the gasp at 23 sec.
17:29:23 <monochrom> hehe
17:29:45 <augur_> eugenia is also obsessed with baking
17:29:55 <augur_> she did a whole video on how to make the perfect scone
17:30:00 <augur_> and developed a FORMULA!
17:30:29 <applicative> Chang's Scone Lemma has been widely applied
17:30:32 <augur_> shes silly
17:30:36 <augur_> Cheng*
17:30:42 <applicative> CHeng's
17:30:46 <pharaun> edwardk: just declaw those folks or put one of these on them -> http://catgroomingcharlotte.com/wp-content/uploads/2011/09/declaw-soft-paws-claws.jpg
17:31:20 <edwardk> pharaun: putting those on seems like a great way to lose a lot of blood. plus i think augur has teeth ;)
17:31:35 <augur_> om nom nom
17:31:58 <applicative> oh, what happened to the om nom combinators. i confess i found them irresistible
17:32:02 <Rarrikins> Man, chalkboards are the work of Satan.
17:32:15 <augur_> chalk boards are the One True Way to explain things
17:32:16 <edwardk> augur_: i still pretty much start all my blog posts that way. "today i want to talk about … "
17:32:23 <applicative> oh i love teaching with old chalkboards and big railroad chalk
17:32:33 <applicative> i feel like i earned my pay covered in dust
17:32:40 <Rarrikins> I hate the feel of chalk, so watching this video is reminding me of it.
17:32:41 <augur_> i want to find good sidewalk chalk sized chalk
17:32:52 <augur_> like the stuff used in the SICP videos
17:32:58 <augur_> need a nice big eraser too
17:33:16 <pharaun> edwardk: http://2.bp.blogspot.com/_U72qXmrHPj4/SnQDlmrN7-I/AAAAAAAAAbQ/zvBtqjLEaGg/s400/chainglove.jpg which is why these exists :)
17:33:24 <applicative> sidewalk chalk is bad for boards augur look up 'railroad chalk' (I think) i made my deparment get a 10 year supply
17:33:34 <augur_> applicative: ill give it a look!
17:33:39 <pharaun> applicative: there's different kind of chalks?
17:33:42 <augur_> sidewalk chalk doesnt erase. its horrible. :(
17:33:44 <danharaj> yes
17:33:56 <danharaj> I learned the difference between chalks when I got my blackboard a few years ago
17:34:14 <applicative> augur_: yes, don't use it, use the stuff it's a cheap imitation of
17:34:19 <dpwright> I have a concurrency situation I'm working with, and I'm wondering which of haskell's various concurrency constructs are the best fit for this situation
17:34:28 <augur_> applicative: hah
17:35:14 <applicative> http://www.amazon.com/Dixon-88819-White-Railroad-Chalk/dp/B004ZWTW1M/ref=pd_sim_sbs_op_1
17:35:35 <pharaun> oh neat
17:35:41 <applicative> note the commentator says *this is what Harvard uses* so it must be good ;)
17:35:45 <dpwright> I'm using the FFI to interface with a piece of hardware using a C library provided by the vendor, and essentially there are three threads per unit: one which polls the hardware for new events, one which polls the hardware for new log output, and the last one reads commands from the user, passes them to the hardware, waits for returned log output, and passes that back out to the user
17:35:50 <pharaun> applicative: ha
17:36:08 <augur_> applicative: i think thats what they use at MIT too
17:36:18 <pharaun>  they still use blackboards there?
17:36:29 <pharaun> i thought most folks were on whiteboards now days, my univ were all whiteboard
17:36:32 <augur_> everyone still uses blackboards!
17:36:40 <augur_> the only people who use whiteboards are weirdos
17:36:59 <dpwright> the thing is, one of the events that might happen on the event thread is DISCONNECT, and if that event is fired I want to be able to shut down the other threads before they have the opportunity to call any of the C functions that interface with the hardware (because their handles are no longer valid after a DISCONNECT event)
17:37:03 <applicative> i reject Satan and all his works and all his whiteboards and powerpoints
17:37:10 <Rarrikins> Lies!
17:38:09 <dpwright> the simplest thing seems to be just store the other thread ids on the event thread, and use them to kill those threads as soon as I get the event -- but I'm a little concerned as to what would happen if those threads were in the middle of an FFI call when I did that, what would happen to the memory, etc...
17:38:25 <tikhon> at the last place I worked, they just treated their walls so you could use them as whiteboards; it was pretty nice
17:38:40 <augur_> tikhon: its easy to do that
17:38:48 <augur_> you just buy a bunch of plastic and tape it up!
17:39:29 <augur_> i once made an ad hoc whiteboard with some plexiglass and a piece of paper
17:40:18 <applicative> where's the FFI masters?
17:40:25 <dpwright> does anybody have any insight into what is a good construct to use in this sort of situation?  Killing the thread / making use of exceptions seems somewhat messy, but I guess it is simple...
17:48:42 <mm_freak_> dpwright: that raises one question
17:49:27 <mm_freak> dpwright: that raises one question
17:49:33 <dpwright> mm_freak: What's that?
17:49:44 <mm_freak> let's call the event thread E, log thread L and UI thread I
17:50:04 <mm_freak> a disconnect event occurs, but L is still reading…  what happens?
17:51:43 <Rarrikins> zomg!
17:51:53 <dpwright> mm_freak: That is a good question.  I presume the library I'm interfacing with is thread-safe to some degree, since both the pollEvent and pollLog functions are blocking, so it seems there's no other way to use it than to put them on multiple threads
17:52:22 <dpwright> pollLog can return an error code, so my guess is that is what would happen, but the documentation isn't that great so I can't be sure without trying it out...
17:52:41 <mm_freak> dpwright: so you should try it…  if you get an error, you can make L shut itself down
17:52:44 <dpwright> (it just says "returns a negative number if there's an error, otherwise it returns the length of the log" sort of thing
17:53:17 <mm_freak> in any case, this seems to be an actor application
17:53:48 <dpwright> mm_freak: Actually yeah, if the other threads just return error codes in that case it's easy!
17:54:03 <dpwright> I did wonder about making an erlang-style supervisor or something
17:54:11 <dpwright> but thought that might be overkill
17:54:31 <mm_freak> no, that's how i would do it
17:54:36 <mm_freak> STM makes this really easy
17:56:20 <mm_freak> if the UI reads from the terminal you have to do it that way anyway, because conceptually reads from a Handle are all blocking in haskell
17:56:49 <dpwright> right
17:57:21 <dpwright> yeah, I'm using STM channels to communicate between the UI (the actual UI) and the thread that handles sending commands / receiving data from the device
17:57:55 <mm_freak> you could also check out pipes-concurrency
17:58:08 <dpwright> ooh!
17:58:12 <mm_freak> it handles graceful shutdown for you
17:58:29 <dpwright> I'm using pipes-network for the UI (which is over TCP), so that might be a good fit
17:59:17 <joefiorini> is there a mostly defacto standard way to do secure password hashing in Haskell? looking at http://hackage.haskell.org/packages/archive/pwstore-fast/1.0/doc/html/Crypto-PasswordStore.html but want to make sure there isn't something more common first.
17:59:37 <mm_freak> joefiorini: that's the common library
17:59:47 <joefiorini> mm_freak: thanks!
18:00:06 <joefiorini> it was the first result on google, so I figured
18:00:37 <mm_freak> there are some lower level libraries for e.g. PBKDF2 or scrypt, but i suggest just using pwstore-fast
18:01:14 <joefiorini> sounds good to me
18:01:28 <Rarrikins> joefiorini: There's also http://hackage.haskell.org/packages/archive/bcrypt/0.0.3/doc/html/Crypto-BCrypt.html if you like bcrypt.
18:01:38 <mm_freak> you don't like bcrypt
18:01:46 <roconnor> PBKDF2 / scrypt is key stretching which I suppose is a kind of hashing.
18:01:51 <Rarrikins> Why don't you like bcrypt?
18:02:42 <mm_freak> PBKDF2 has a security guarantee, scrypt quickly grows in circuit complexity when implemented in hardware
18:02:47 <mm_freak> bcrypt has neither of these features
18:03:01 <begriffs> Is it common for people on mac to use cabal to manage their packages?
18:03:41 <mm_freak> roconnor: hashing with salt and some computation time to slow down bruteforce attacks
18:03:48 <joefiorini> begriffs: I do, are you coming from another language/dev environment?
18:03:57 <geekosaur> macs are annoying enough to build stuff for that if you can get your haskell platform and packages from macports / homebrew, it's probably a good idea
18:04:08 <begriffs> joefiorini: I'm coming from Ruby and its gems. I've got homebrew.
18:04:14 <scaldwell> homebrew seems the most popular
18:04:34 <joefiorini> begriffs: I used homebrew to install ghc & haskell-platform, I think
18:04:40 <applicative> begriffs: yes, what is the alternative?
18:04:58 <joefiorini> begriffs: yeah, then I use cabal-dev to manage packaes
18:05:00 <joefiorini> packages*
18:05:08 <applicative> begriffs: i oppose getting ghc/haskell platform from homebrew, but i think my grounds may be out of date
18:05:13 <roconnor> mm_freak: what is the security guarntee of PBKDF2?
18:05:23 <joefiorini> applicative: what are your grounds?
18:05:46 <mm_freak> roconnor: IIRC if the hash function is a PRF, PBKDF2 is also a PRF
18:05:54 <applicative> joefiorini: all attempts to get things linked to c-libraries were a torture.
18:06:02 <mm_freak> in other words, it is no weaker than the hash function used
18:06:04 <roconnor> PRF?
18:06:12 <mm_freak> pseudo-random function, a theoretical concept
18:06:14 <applicative> but maybe it works better now; in general homebrew+haskell seems to work better
18:06:18 <joefiorini> applicative: I haven't had that problem yet; I assume I've used SOMETHING that links to a C library
18:06:21 <begriffs> applicative I'm running into issues with cabal/hsenv. Tried erasing all my packages and starting again, but it's pretty weird. I'm working on a Yesod web app and doing cabal install is trying to load incompatible versions of things I think.
18:06:37 <joefiorini> begriffs: try cabal-dev instead of hsenv
18:06:41 <roconnor> mm_freak: thanks
18:06:47 <joefiorini> the workflow will be build into cabal soon
18:07:18 <joefiorini> begriffs: I ran into that exact same problem, and switched to cabal-dev and haven't had it since
18:07:25 * applicative in a fraudulent attempt at avant-guardism has been using cabal sandbox for a month or two
18:07:26 <begriffs> So just cabal install cabal-dev then cabal-dev install?
18:07:28 <mm_freak> roconnor: note that PRFs don't exist on a computer, but these guarantees are strong indicators that a higher order function on a secure hash function is itself a secure hash function
18:07:33 <joefiorini> begriffs: yep
18:07:47 <joefiorini> then you'll use cabal-dev instead of cabal
18:07:58 <begriffs> What is cabal-dev exactly? Vs cabal that is
18:08:07 <joefiorini> it installs deps locally
18:08:12 <roconnor> mm_freak: really?  Surely there is some interpretation where PRFs exist.
18:08:13 <Makoryu> begriffs: Package sandboxing
18:08:15 <joefiorini> kind like doing bundle install --path vendor/bundle
18:08:29 <mm_freak> roconnor: PRFs would need infinite storage
18:08:45 <joefiorini> only downside I've seen so far is I have to point runhaskell at my packages dir (runhaskell -package-db=cabal-dev/packages-7.6.3.conf src/Main.hs)
18:09:22 <joefiorini> and installs take longer since you have to install dependencies fresh in every project
18:09:39 <joefiorini> but it's not bad
18:10:03 <begriffs> joefiorini: I haven't seen runhaskell before. is that like ghc?
18:10:36 <joefiorini> begriffs: it's like an interpreted way of running your code, probably nice for one coming from ruby
18:11:07 <joefiorini> does runhaskell compile code or is it actually interpreted?
18:11:22 <begriffs> Do you use runhaskell rather than ghci?
18:11:29 <joefiorini> sometimes
18:11:50 <joefiorini> it's very nice coming from Ruby & JavaScript workflows
18:12:12 <Makoryu> Huh
18:12:22 <Makoryu> Can you do a hashbang trick
18:12:24 <Makoryu> With runhaskell
18:12:29 <joefiorini> but I can't say much beyond that, haven't gotten far enough into a project yet :)
18:12:55 <joefiorini> Makoryu: interesting question
18:13:07 <geekosaur> for your purposes it's interpreted. I think runhaskell specifically supports hashbang
18:13:11 <geekosaur> without a trick
18:13:23 <Makoryu> I'm gonna try that right now
18:13:27 <joefiorini> me too :)
18:13:34 <geekosaur> back before cabal-install it was not unusua for Setup.hs to start with a hashbang
18:14:31 <joefiorini> Makoryu: worked for me
18:14:38 <applicative> begriffs: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
18:14:54 <applicative> begriffs http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
18:15:10 <Makoryu> joefiorini: I told it to print "Hello, world" and it printed "SIE SIND DAS ESSEN UND WIR SIND DIE JÄGER"
18:15:14 <joefiorini> applicative: how would I know when 1.18 is released?
18:15:18 <Makoryu> I think my path is messed up
18:15:24 <joefiorini> Makoryu: you've got problems :)
18:15:47 <applicative> and to install tibbe has arranged this: cabal install http://johantibell.com/files/Cabal-1.18.0-rc2.tar.gz http://johantibell.com/files/cabal-install-1.18.0-rc2.tar.gz
18:16:07 <Makoryu> Ah, yes, that's how that got there
18:16:29 <begriffs> applicative: so you would recommend using cabal sandboxes rather than cabal-dev?
18:17:00 <applicative> begriffs: I only had minimal experience with cabal-dev but i think the answer has to be yes.
18:17:21 <joefiorini> begriffs: applicative: I'll try it too
18:19:16 <applicative> it's amazing really
18:19:16 <applicative> i upgraded yesterday or the day before to the rc2 version, and 'cabal repl' is too wonderful
18:19:16 <applicative> it could use more tutorials, but i never found a decent one for cabal dev and Mikhail G has said a fair amount on his blog
18:19:16 <applicative> but i think cabal dev already had nice emacs integration and stuff so I cant profess to weigh the imponderables
18:20:27 <joefiorini> what's cabal repl do? Launch ghci?
18:24:20 <Fuuzetsu> it's like cabal-dev ghci
18:24:37 <Fuuzetsu> It launches GHCi confined to your sandbox (cabal sandbox init)
18:24:52 <Fuuzetsu> Well, confined is not the right term…
18:27:54 <joelteon> @pl \x -> f x (g x)
18:27:54 <lambdabot> ap f g
18:28:01 <joelteon> @pl \x -> f (g x) x
18:28:01 <lambdabot> f =<< g
18:28:38 <joefiorini> applicative: thanks for the links, installing to my sandbox now
18:29:54 <applicative> oh, hope it works; it was as simple as tibbe's command yesterday
18:34:36 <begriffs> applicative: after installing cabal 1.18 it still reports being cabal-install version 1.16.0.2
18:34:46 <begriffs> Do I have to change my path?
18:34:49 <applicative> begriffs: yes
18:35:16 <begriffs> Not sure where to find it.
18:35:26 <applicative> if the old cabal-install was in /usr/bin . the new one is in ~/.cabal/bin or wherever they go on your machine
18:35:30 <applicative> what os are you using?
18:35:33 <begriffs> mac
18:35:58 <begriffs> Ohh, found it: ~/Library/Haskell/ghc-7.6.3/lib/cabal-install-1.18.0/bin
18:36:11 <Fuuzetsu> You should be able to download it from git and then ‘cabal install Cabal/ cabal-install/’ it.
18:36:18 <Fuuzetsu> Ah, there you go then.
18:36:22 <applicative> but it will also be in  ~/Library/Haskell/ghc-7.6.3/bin or something
18:36:41 <begriffs> afk. Thanks for the help guys.
18:37:31 <applicative> the haskell platform for mac decided to follow the method used for python and so on, so it's not in step with linuxes anymore where everything is in .cabal/blah in your home directory
18:40:39 <alcuadrado> is import Data.List or import List correct?
18:40:49 <Fuuzetsu> Data.List
18:41:27 <applicative> import List is an older style that can only be used with unpleasant further adjustments
18:42:18 <alcuadrado> good to know
18:42:27 <alcuadrado> that's exactly what I needed
18:42:41 <alcuadrado> a teacher gave me some code full of import List
18:42:48 <alcuadrado> and stuff like that
18:42:58 <alcuadrado> now I had an argument to complaint about that :P
18:42:59 <applicative> its a little more complicated with old code that has import System and import IO
18:43:38 <Fuuzetsu> I bet he has to use Hugs.
18:43:39 <alcuadrado> but any modern implementation would understand import Data.List, right?
18:43:44 <applicative> yes.
18:43:48 <alcuadrado> no I don't have to
18:43:53 <joefiorini> with cabal 1.18, is there an easy way to use runhaskell without manually specifying -package-db path?
18:43:58 <alcuadrado> we can choose ghc
18:43:59 <applicative> even Hugs permits it, but it will except List without a hitch.
18:44:05 <applicative> accept rather
18:44:08 <alcuadrado> probably the teacher uses Hugs
18:44:48 <applicative> you can do it with ghc too, but you need to specify 'haskell98' which i woulnd't know how to do in a complicated scenario
18:45:25 <alcuadrado> I fixed all the imports already
18:45:40 <alcuadrado> I just needed a point for doing that
18:45:50 <applicative> Monad goes to Control.Monad , IO to System.IO , System is a little more broken up I think.
18:46:35 <applicative> if you have ghc you have docs somewhere that link all the base libraries, it'll be pretty clear if you find something else like this
18:47:11 <applicative> oh here they are http://www.haskell.org/ghc/docs/latest/html/libraries/base/
18:47:39 <applicative> Foreign is still called Foreign, that's why I'm so afraid of it
18:48:38 <alcuadrado> haha thanks
18:51:40 <Kelet> Would it be reasonable to say that Turing Machines are to imperative languages as Lambda Calculus is to functional languages?
18:51:56 <Kelet> Or is that overgeneralizing too far
18:52:16 <Fuuzetsu> That's certainly the first time I hear it put this way…
18:52:28 * hackagebot diagrams-haddock 0.1.2.0 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.2.0 (BrentYorgey)
18:52:42 <applicative> theres something in it, isn't there, as long as its stated as a wilful blur
18:52:56 <applicative> the Pope of my Church is Alonzo!
18:53:03 <byorgey> Kelet: yes, I think it is reasonable.
19:30:05 <lpaste> gfredericks pasted “gfredericks' config” at http://lpaste.net/92421
19:31:06 <heatsink> So I'm reading the gnuplot documentation
19:31:15 <heatsink> and it's amazing how versatile this type T is
19:33:05 <mietek> @hoogle Int -> [a] -> [[a]]
19:33:06 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:33:06 <lambdabot> Data.List drop :: Int -> [a] -> [a]
19:33:06 <lambdabot> Prelude take :: Int -> [a] -> [a]
19:33:13 <mietek> @hoogle chunks
19:33:14 <lambdabot> package chunks
19:33:14 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
19:33:14 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
19:33:26 <mietek> Where was the generic chunks function?
19:34:44 <heatsink> Data.List.Split
19:39:54 <mstksg> is persistent's "update" unsafe?  what happens when my data store rejects an update to a unique field?
19:44:28 <Ghoul_> I'm getting a bit confused with short circuiting in foldr
19:44:40 <meretrix> mstksg: I believe it throws an exception, which you can choose to handle.
19:45:14 <Ghoul_> hmm, nevermind. I had a question but I don't really anymore
19:45:26 <mstksg> meretrix: ah, thanks.  i guess there's no built in updateUnique that returns a Maybe?
19:46:27 <SrPx> Is there a way to code in Haskell using S-Expressions and macros?
19:46:39 <meretrix> mstksg: Not that I know of, but you could easily write your own Maybe wrapper.
19:47:08 <heatsink> SrPx, try Data.AttoLisp
19:47:53 <mietek> heatsink: thanks
19:48:37 <heatsink> @hoogle comparing
19:48:37 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:49:53 <SrPx> heaeh ok
19:50:05 <SrPx> heatsink: well ok. thanks!
19:51:59 <mstksg> meretrix: do you think they would be looking for a patch?
19:52:36 <mstksg> i'm new to this whole open source culture thing, not sure what is proper ettiquette
19:52:40 <mstksg> or behavior
19:53:50 <startling> SrPx: there used to be something called "Liskell" but the domain has apparently expired and I bet it's bitrotted pretty badly.
19:54:33 <SrPx> that is an awesome name.
19:54:57 <startling> there's a paper: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
19:56:26 <meretrix> mstksg: Perhaps. The persistent packages are part of the yesod framework, so I would start by asking on the mailing list: https://groups.google.com/forum/#!forum/yesodweb
19:56:55 <meretrix> For smaller packages, I would just create a github issue or contact the maintainer by email.
19:58:00 <SrPx> startling: I was already reading and loving it
20:00:15 <mstksg> meretrix: thanks for the advice
20:07:04 <mm_freak> i'd like to see unionMap in Data.Set
20:07:12 <mm_freak> it corresponds to concatMap for lists
20:07:30 <mm_freak> unionMap :: (Ord a, Ord b) => (a -> Set b) -> Set a -> Set b
20:09:35 <Ghoul_> @pl (\n -> snd p == n)
20:09:35 <lambdabot> (snd p ==)
20:09:51 <Ghoul_> @pl (\p -> snd p == n)
20:09:54 <lambdabot> flip ((==) . snd) n
20:09:54 <lambdabot> optimization suspended, use @pl-resume to continue.
20:12:12 <Ghoul_> Tekmo: luv'ya and your work
20:12:21 <Tekmo> Thanks! :)
20:12:53 <begriffs> Anyone ever have trouble installing crypto-random-0.0.4? I'm seeing the rror "no such instruction: `rdrand %rcx'"
20:13:18 <begriffs> Trying to install on OS X.
20:17:27 <Ghoul_> I need to optimize this list comprehension. Any ideas? [x * y | x <- [100..999], y <- [100..999], palin $ x * y]
20:17:48 <Ghoul_> I would like to be able to move the x * y into a common expression, but I can't figure out how.
20:18:07 <amosr> "z <- x * y" ?
20:18:17 <slack1256> this
20:18:27 <Ghoul_> I thought I tried that, but I got a angry type error
20:18:32 <Ghoul_> I must've made a typo
20:18:35 <Makoryu> z <- [x * y]?
20:18:50 <amosr> oh right
20:19:22 <Ghoul_> that did the trick
20:19:25 <Ghoul_> thanks :)
20:19:44 <Makoryu> Ghoul_: I'm pretty sure most of the overhead there will be just churning through the lists, though, so there may be more work ahead of you
20:19:47 <Ghoul_> I'm unsure what constitutes which parts of the comprehension are lists or inner parts though
20:20:00 <Makoryu> What do you mean
20:20:13 <slack1256> I don't think saving a multiplication makes up for the costs of [x
20:20:17 <slack1256> I don't think saving a multiplication makes up for the costs of [x * y]
20:20:28 <scshunt> on top of that, shouldn't memoization take care of that anyway?
20:20:40 <Ghoul_> I can cut a multiplication out
20:20:52 <Ghoul_> but I cant wrap it around in my head
20:21:08 <slack1256> scshunt: there is no automatic memoization on haskell
20:21:12 <scshunt> Ghoul_: what do you mean you're unsure about what?
20:21:27 <tikhon> scshunt: GHC won't memoize x * y like that
20:21:33 <Tekmo> Note that z <- [x * y] is the same thing as let z = x * y
20:21:34 <Ghoul_> Yes, I'm unsure which parts of a list comprehension are lists and which parts are values
20:21:35 <Ghoul_> like
20:21:36 <amosr> if it's not being fused away, try data.vector, or write it as a recursive loop
20:21:41 <Ghoul_> [z | x <- [100..999], y <- [100..999], z <- [x * y], palin z]
20:21:51 <Tekmo> Can't you just write `let z = x * y`?
20:22:06 <Ghoul_> the `palin z` part operates with my values, but the z <- part errors out unless its a list
20:22:23 <roboguy_> if ghc automatically memoized everything that would use a ton of memory
20:22:31 <Ghoul_> That didn't make sense.. sorry. Forget it, thanks for the help :)
20:22:42 <Tekmo> > [ z | x <- [1..3], y <- [1..3], let z = x * y, z < 5]
20:22:43 <lambdabot>   [1,2,3,2,4,3]
20:22:57 <Ghoul_> o-O didn't know you could do  that
20:23:06 <tikhon> Tekmo: I suspect people don't guess that you can use a let statement inside a list comprehension
20:23:29 <Tekmo> The easy way to remember this is that a list comprehension is (basically) the same thing as the list monad
20:23:38 <tikhon> In general, I've found Haskell syntax allows me to do things that I assumed it wouldn't—it's more thorough and uniform than I expected
20:23:45 <Tekmo> So you can use a `let` within it the same way you would within a `do` block
20:23:54 <Tekmo> It's equivalent to:
20:23:55 <Ghoul_> cool!
20:24:11 <Tekmo> do { x <- [1..3]; y <- [1..3]; let z = x * y; guard (z < 5); return z }
20:24:47 <Tekmo> > do { x <- [1..3]; y <- [1..3]; let z = x * y; guard (z < 5); return z }
20:24:48 <lambdabot>   <hint>:1:60: parse error on input `;'
20:25:11 <Tekmo> > do { x <- [1..3]; y <- [1..3]; let z = x * y; guard (z < 5); return z; }
20:25:12 <lambdabot>   <hint>:1:60: parse error on input `;'
20:25:17 <Tekmo> Hmm
20:25:36 <Ghoul_> odd.
20:26:20 <Tekmo> > do { x <- [1..3]; y <- [1..3]; let { z = x * y }; guard (z < 5); return z }
20:26:21 <lambdabot>   [1,2,3,2,4,3]
20:26:22 <slack1256> do { x <- [1..3]; y <- [1..3]; let z = x * y; guard (z < 5); return z }
20:26:33 <Tekmo> It needed brackets around the `let` for some reason
20:27:03 <scshunt> where "some reason" is that they are necessary in inline code?
20:27:10 <Tekmo> Yeah
20:27:21 <Tekmo> It can't know that the next statements aren't part of the let block
20:27:45 <slack1256> do { x <- [1..3]; y <- [1..3]; let {z = x * y; hommie = 5}; guard (z < 5); return z }
20:28:39 <slack1256> > do { x <- [1..3]; y <- [1..3]; let {z = x * y; hommie = 5}; guard (z < 5); return z }
20:28:40 <lambdabot>   [1,2,3,2,4,3]
20:30:28 <Ghoul_> Anyone who cares may find the final optimized expression interesting
20:30:28 <Ghoul_> [z | x <- [100..999], y <- [x..999], let z = x * y, palin z]
20:30:44 <Ghoul_> y <- [x..999] took a bit of thinking to do :P
20:31:14 <Tekmo> Is this from Project Euler?
20:31:22 <Ghoul_> heh
20:31:25 <Ghoul_> yes, its #4
20:31:26 <Tekmo> :)
20:32:16 <Tekmo> The nice thing about project Euler is that it teaches you that you can optimize a problem a whole lot just by spending more time thinking about it
20:32:41 <Ghoul_> my solution http://lpaste.net/7557688951012589568
20:32:57 <Ghoul_> and yes, I spend more time optimizing my thing to get under the "1 second rule" than solving the problem :)
20:33:35 <Ghoul_> laziness makes solving P.E so easy
20:34:06 <Tekmo> It also makes memoization really easy, too
20:34:15 <tikhon> 1 second? I thought the rule was 1 minute...
20:34:30 <Ghoul_> heh, I can't imagine how anyone would do 415 in a second
20:34:35 <Ghoul_> you're probably right
20:34:59 <Tekmo> Actually, I think 415 is doable in a second
20:35:01 <Hodapp> that's a point that I sometimes cannot get across to people who just want to use whatever language can push the fastest raw numbers
20:35:50 <Hodapp> if a language gives you a clearer view of a problem, you might be able to see some high-level optimizations that give order-of-magnitude improvements
20:36:09 <Ghoul_> Tekmo: really?
20:36:11 <Ghoul_> the titanic one?
20:36:21 <Ghoul_> I made a solution with a friend and ours has been running on a VPS for 2 months now
20:36:27 <Cale> Ghoul_: btw, that implementation of palin is slower for me than  palin p = let s = show p in s == reverse s
20:36:27 <Tekmo> I'm not sure, but I don't see any obvious reason why not
20:36:29 <Ghoul_> we hope to get an answer soon..
20:36:45 <Tekmo> Haha
20:36:46 <Ghoul_> Cale: :\ is it?
20:36:50 <Tekmo> It shouldn't take 2 months
20:37:01 <Tekmo> All the problems are designed to take seconds to compute
20:37:24 <Cale> Ghoul_: Your version takes ~0.22s, while the show/reverse version takes ~0.07s on my machine
20:37:31 <Cale> (when compiled with -O2)
20:37:33 <Ghoul_> aw
20:37:44 <Ghoul_> Oh well
20:37:49 <Ghoul_> I tried not to touch the lexical stuff
20:37:58 <Ghoul_> I dont like dealing with lexical things, and that was my downfall here
20:38:18 <Cale> well, maybe we could approach it in a similar way
20:39:11 <Hodapp> why is "literate Haskell" not a concept I see elsewhere?
20:39:24 <Ghoul_> maybe if I took a log10 to find how many digits, and then split the number in 1 or 2 maths operations (if that's possible) and compared them
20:39:37 <tikhon> Hodapp: because elsewhere it's just "literate programming" :P
20:40:08 <tikhon> literate programming was originally invented by Knuth, I believe—quite a long time ago
20:40:24 <Hodapp> "Haskell is one of the few languages that provides native features to support literate programming. Haskell is one of the few languages that provides native features to support literate programming.", to quoth Haskellwiki
20:40:25 <tikhon> I've seen examples in other languages, but it never caught on
20:40:40 <heatsink> The documentation in the Gnuplot module is terrible.  Can someone suggest a tutorial or something?
20:40:46 <Hodapp> wait, why'd that paste twice? blah
20:40:47 <tikhon> Ah, well, there are some external tools you can use for other languages even if they don't support it natively
20:40:50 <heatsink> > must name every data type "T"
20:40:51 <lambdabot>   <hint>:1:17: parse error on input `data'
20:41:09 <Demos> honestly it adds another step to the build process and many people have found javadoc style documentation to be a little easer, that said the TeX source "book" is really quite something
20:41:32 <tikhon> with any decent build system, another step should not be a big issue
20:41:39 <Hodapp> well, with Javadoc style it's still code-that-contains-documentation, not the other way around
20:41:43 <tikhon> of course, I have never seen a "decent build system" in the wild...
20:41:54 <Cale> Ghoul_: if we define digits 0 = []; digits x = v : digits u where (u,v) = quotRem x 10 -- and use that instead of show, it takes ~0.14s
20:41:59 <Hodapp> I've used CMake, it is... well, a build system
20:42:16 <Cale> Ghoul_: Given that show is probably highly optimised, that's not bad.
20:42:31 <Demos> cmake is the best build system I have ever used, that is not saying much
20:42:39 <Hodapp> what I'm used to at $day_jerb for a build system is Visual Studio 2008
20:42:48 <Hodapp> where the fact that it can build at all is something of a miracle
20:43:07 <tikhon> The one I've spent the most time with was OMake; it was... not great.
20:43:17 <Hodapp> sneeze during a build, and you get errors about precompiled headers
20:43:42 <Ghoul_> hmm
20:43:48 <Cale> Hodapp: I'm really not sure why other languages haven't picked up on the whole literate thing. It's really convenient to be able to have blog and mailing list posts in HTML which can be saved as .lhs files and executed directly
20:44:03 <Cale> (or in plain text of course)
20:44:06 <tikhon> I have a lot of hope for embedded build DSLs like Shake, but I've never actually used them in practice.
20:44:22 <Cale> and of course, the ability to have LaTeX documents which are also programs is pretty nice too :)
20:44:30 <Ghoul_> :t quotRem
20:44:31 <lambdabot> Integral a => a -> a -> (a, a)
20:44:37 <Hodapp> The thing with CMake is that even if it's a farking mess, just having most of the setup be in flat text files is amazingly helpful because of advanced features like "copy and paste" and handling modularity your own way.
20:44:38 <Cale> quotRem 473892 10
20:44:40 <Cale> > quotRem 473892 10
20:44:41 <lambdabot>   (47389,2)
20:44:49 <Cale> quotient and remainder
20:44:52 <Cale> there's also
20:44:56 <Cale> > divMod 473892 10
20:44:58 <lambdabot>   (47389,2)
20:45:08 <Cale> it's the same as quotRem when both the arguments are positive
20:45:29 <Cale> divMod is actually more often the thing you want, but it's ever-so-slightly slower
20:45:30 <Demos> I have seen no evidence that building c++ code is a problem domain with a "clean" solution
20:45:34 <Hodapp> If I want to duplicate a specific module in CMake, I copy the file and change a few names. If I want to duplicate a specific module in a Visual Studio build... uhm, well, I guess I can write a Python script to walk the XML, find the GUIDs, regenerate them, and change a bunch of the filenames, and then it MIGHT work
20:45:51 <Cale> (because quot/rem are typically what gets implemented in hardware)
20:45:54 <Hodapp> Demos: I have seen no evidence that doing anything with C++ code is ever a "clean" solution
20:46:04 <tikhon> Why is copy and paste suddenly good for code reuse if you're working on your build system?
20:46:23 <tikhon> I mean, sure, it's probably easier than XML, but it's still very sub-par.
20:47:05 <Hodapp> tikhon: It's a lot easier than walking a maze in a GUI, and often times when you are copying-and-pasting you'll start to see what can be factored out so that you don't need duplication of it.
20:47:13 <tikhon> A makefile is a program, like any other; why not use a real programming language, with its own features for abstraction and modularity instead?
20:47:32 <Demos> cmake is kinda a real programming language
20:47:34 <Demos> kinda
20:47:36 <Hodapp> kinda.
20:47:38 <tikhon> Oh yes, I agree it's much nicer than using an IDE or something for your build.
20:48:00 <Demos> the thing is I want to use the language that I am building to write my build scripts
20:48:08 <tikhon> It's a programming language with rather limited expressiveness.
20:48:22 <Hodapp> but for "why not use a real programming language": sometimes declarative languages can be preferable here
20:48:32 <heatsink> There is shake
20:48:34 <tikhon> That's why we have a nice DSL in Haskell or OCaml for it.
20:48:47 <Demos> I mean they could provide a DSL written in c++, kinda, with enought templates
20:48:52 <tikhon> I'm not suggesting a C++-based build-system, but mostly because I don't suggest C++ for anything :D.
20:48:59 <Hodapp> well of course Haskell has a nice DSL for it :P
20:49:12 <Hodapp> I'm just reporting my experiences when I've worked with CMake
20:49:28 <Demos> a language that compiles to C may be a good choice for cmakeish build systems
20:49:48 <Hodapp> and how, even if it's not the cleanest solution, it's a far cry from how it feels like trying to fold laundry with boxing gloves on when I want to do anything in VS's build system
20:50:03 <ReinH> Not sure why you need a turing complete language to write a build system
20:50:39 <ReinH> or why "a real programming langauge" is automatically better than... what... a "fake" one?
20:50:42 <tikhon> ReinH: it doesn't have to be Turing-complete per se, but it *does* need good facilities for abstraction and reuse.
20:51:05 <ReinH> why?
20:51:08 <tikhon> In Haskell, we already know how to write code that's elegant, easy to follow and modular; why reinvent all that for a build system?
20:51:30 <ReinH> what kind of abstraction and reuse do you expect to get out of the equivalent of a makefile?
20:51:32 <Demos> honestly I think that having the language impose some kind of organization on libraries and source files helps
20:51:34 <tikhon> So you don't end up with a gigantic file full of slightly-modified, copy paste build code
20:51:43 <Tekmo> ReinH: I think you underestimate the utility of this abstraction
20:51:52 <Tekmo> ReinH: This can be used to automate more than just build systems
20:52:01 <Tekmo> ReinH: It's a general reactive paradigm
20:52:24 <ReinH> Tekmo: Oh, I appreciate the paradigm
20:52:41 <ReinH> I'm talking about build systems
20:53:16 <tikhon> The last place I worked, each time you wanted to build functions against C code or use a preprocessor, you basically ended up copying and pasting the build code from some other project and tinkering with it until it worked for your particular project. I think much of this could have been avoided with a nice edsl for the build system instead of the make-like atrocity they used.
20:53:33 <ReinH> I don't think you need "a real programming langauge" to obtain abstraction and code reuse
20:53:46 <tikhon> ReinH: Well, Make certainly doesn't give it to us.
20:53:51 <Tekmo> ReinH: C++ can always benefit from a better build system
20:54:06 <tikhon> And why try inventing a new language when we already have a perfectly good one available?
20:54:08 <ReinH> Puppet language has excellent abstraction and reuse, for instance
20:54:14 <Cale> In practice, it seems you need more than just a real programming language to obtain abstraction and code reuse.
20:54:36 <Hodapp> Tekmo: If the build system is going to be used as a crutch, I dunno...
20:54:48 <Cale> (at least, more than a tiny fraction of what you might like to have in that regard...)
20:54:49 <tikhon> Yeah. Which is why you want a real programming language with a nice DSL for build-specific functionality.
20:55:00 <Hodapp> Cale: Having *less* than a real programming language doesn't mean you can't have abstraction and code reuse.
20:55:10 <Demos> what you want is build specific functionality
20:55:22 <Demos> *less build specific functionality
20:55:51 <tikhon> besides, just because you're embedded in a general-purpose language does not mean your code can't be declarative
20:56:41 <ReinH> Build systems are a very small domain compared to a general purpose programming language
20:56:49 <tikhon> yes, sure
20:57:16 <tikhon> but essentially *every* domain you ever care about is small compared to that
20:57:20 <Tekmo> I mean, don't you get a kick out of finding a really elegant way to solve a problem?
20:57:28 <ReinH> Can you imagine telling sysadmins "Ok, our build system is an embedded Haskell DSL so you have to learn Haskell if you want to manage our infrastructure"?
20:57:34 <ReinH> seriously?
20:57:41 <tikhon> Well, I could imagine it with OCaml
20:57:53 <tikhon> because that's exactly what the company I was talking about did
20:58:13 <tikhon> besides, learning a Haskell DSL is no worse than learning Make
20:58:20 <Demos> just don't tell them it is haskell
20:58:32 <Tekmo> ReinH: While I don't think Shake is simple enough to make such an argument, I believe that something more elegant than Shake could appeal to non-Haskell programmers
20:58:32 <ReinH> If they can use it without know it's haskell
20:58:36 <ReinH> then it doesn't need to be haskell
20:58:39 <ReinH> obviously
20:58:42 <ReinH> *knowing
20:59:34 <pharaun> shake n' bake :)
20:59:58 <ReinH> Tekmo: Twerk.
21:00:08 <tikhon> If they're working at a Haskell company, they're going to encounter Haskell in other places too; they'll have to pick up at least a basic proficiency.
21:00:12 * Hodapp glares at ReinH
21:00:22 <ReinH> Hodapp: #yolo
21:00:25 <carter> yup
21:00:41 <carter> tikhon: i'm actually going to likely be trying to use shake for a bunch of stuff soon
21:00:46 <Hodapp> I heard the, "We have to use C++ here, because we have no change of finding anyone who knows how to use $better_language!"
21:00:56 <tikhon> carter: ooh, I'd love to hear about your experiences with it
21:01:09 <carter> tikhon i do too
21:01:24 <Hodapp> then it turned out practically no one for hire knew C++ either
21:01:39 <carter> tikhon: : Enigmagic  has a cool bit of shake code https://github.com/alphaHeavy/shake-install
21:01:51 <Tekmo> Ghoul_: I've made a bit more progress on problem 415
21:02:00 <ReinH> I am not arguing that a build system in Haskell wouldn't be useful
21:02:04 <tikhon> carter: Oh, do they use it for everything?
21:02:20 <heatsink> Hodapp, do you mean they've written C++ before but their understanding is flawed and less complete than they think?
21:02:26 <carter> by what i've heard them say publically, yes, though i'm not privy to what they do in practice
21:02:34 <tikhon> I was wondering what real Haskell companies use to build their code.
21:02:45 <tikhon> I guess cabal just doesn't cut it...
21:02:47 <carter> depends on how good their engineers are honestly
21:02:57 <Tekmo> What's wrong with cabal?
21:03:01 <carter> tikhon: apparently you really really want a nice SMT solver for cabal when things get large
21:03:17 <carter> wrt the version plans
21:03:18 <Hodapp> heatsink: No - just that no one who claimed to know C++ seemed to be looking for a job.
21:03:18 <ReinH> tikhon: building the code is honestly the least interesting part
21:03:34 <carter> ReinH: at scale its an interesting problem again
21:03:34 <heatsink> Tekmo, cabal is tightly tied to the way typical Haskell programs are built
21:03:38 <Ghoul_> Tekmo: I have one that works if you wanna see it
21:03:42 <tikhon> ReinH: Yes. So why do we give that a whole different language while everything else gets to be the same?
21:03:44 <Ghoul_> but I dont have enough ram to run the fast sieve <_<
21:03:46 <m3ga> Tekmo: cabal is way slower than Make, Make is better at building specific target
21:03:53 <tikhon> (well, almost everything else)
21:03:53 <carter> Ghoul_: example of what?
21:03:56 <Ghoul_> so it swaps to a really slow n^2 sieve and takes forever
21:04:02 <ReinH> carter: not really. It's just tedious.
21:04:03 <Tekmo> Ghoul_: Well, I'll tell you how I think you can speed it up a lot
21:04:08 <heatsink> Hodapp, interesting.  I thought C++ was just behind Java in terms of how many people used it.
21:04:11 <carter> ReinH what is?
21:04:13 <Cale> Presently the way that GHC works iiuc is that you can have at most one installed package-version combination per package.
21:04:14 <Ghoul_> theres a O(n) way of finding it
21:04:23 <Ghoul_> bt it requires a gigapentahellavalot of ram
21:04:30 <ReinH> carter: build systems for compiling code "at scale"
21:04:32 <tikhon> For what it's worth, I think most standalone DSLs should be embedded instead. Like SQL, for example.
21:04:36 <Tekmo> Ghoul_: You can do better than O(n), I think
21:04:46 <ReinH> The compiler has already done all the interesting bits
21:04:49 <heatsink> tikhon, I think that was the idea behind LINQ
21:04:53 <carter> ReinH : distributed systems are tedious too
21:04:53 <Hodapp> heatsink: it's lost some ground, I think
21:05:01 <Tekmo> Ghoul_: It should be O(# of prime factors of n), I think
21:05:02 <Hodapp> heatsink: C, Java, and maybe C# surpassed it
21:05:03 <tikhon> And LINQ is pretty brilliant
21:05:04 <Cale> and that creates issues because of conflicts between the choices of versions that various packages are built against
21:05:16 <ReinH> carter: I'm not really sure what you're getting at.
21:05:18 <tikhon> Hodapp: what do you mean?
21:05:27 <carter> ReinH if you have 1mm loc
21:05:32 <Hodapp> tikhon: in terms of demand for coders
21:05:34 <carter> you dont want to do the build on a single machine
21:05:42 <tikhon> Hodapp: oh, I thought you were talking about LINQ
21:05:48 <carter> you want to do a parallel distributed batch job
21:05:57 <carter> that does incremental rebuilds on a cluster or something
21:05:58 <Cale> But the alternative is possibly just as bad -- you end up building potentially combinatorially many versions of the same package-version.
21:06:00 <Ghoul_> hm.
21:06:06 <Tekmo> Ghoul_: No wait, it's O(largest prime factor of n)
21:06:12 <Cale> Though, that's not so much a cabal-specific thing.
21:06:15 <ReinH> carter: right, it's a map reduce problem, which is a bit more interesting
21:06:18 <ReinH> but still mostly tedious :p
21:06:28 <carter> its not a map reduce problem
21:06:31 <carter> not at alllll
21:06:49 <tikhon> My biggest problem with Cabal has always been with non-Haskell dependencies
21:06:50 <Hodapp> oh god, somebody dropped the MR bomb
21:07:04 <ReinH> carter: sure it is, once you get past the topo sort
21:07:08 <tikhon> I imagine that's another reason to have a custom in-house build system instead
21:07:22 <Tekmo> Ghoul_: No, it's better than that.  Probably around O(log n)
21:07:33 <carter> ReinH : yes, but then you're going to have it be slower
21:07:52 <carter> tikhon: yeah, actually a number of industiral HS places would love cabal to get better instead
21:08:25 <Tekmo> Yeah, it's a big pain when cabal depends on a package
21:08:34 <tikhon> Unfortunately, as ReinH pointed out, it really isn't a very glamorous problem to solve :(
21:08:41 <carter> idk....
21:08:46 <carter> its a pretty far reaching problem
21:08:51 <ReinH> any build system worth its salt already lets you specify dependencies
21:08:52 <carter> and no one knows how to do it well
21:09:27 <ReinH> once you have the graph, there is a lot of prior art for finding partial orderings and so on
21:09:31 <tikhon> Yeah, but it's purely infrastructure. And while it's indubitability useful and important, it's still not terribly exciting or glamorous.
21:09:43 <ReinH> it's a big problem
21:09:47 <ReinH> it's just not a very interesting one
21:09:54 <ReinH> it's very well understood
21:10:17 <carter> which is?
21:10:48 <ReinH> carter: algorithms for operating on directed acyclic graphs
21:10:49 <dmj`> ss
21:10:52 <carter> oh yeah
21:10:55 <carter> thats understood
21:10:56 <dmj`> disregard that
21:10:57 <Tekmo> No, the algorithms are not the interesting part
21:11:00 <ReinH> it's a pretty well explored space
21:11:03 <Tekmo> The interesting part is making things composable
21:11:14 <carter> having good build systems without gobs of manpower is the hard part
21:11:44 <ReinH> you can take your DAG of compilation dependencies, do a topo sort to obtain a partial ordering, and then distribute that
21:12:04 <carter> you've skipped the tricky parts
21:12:15 <Tekmo> What are the tricky parts?
21:12:20 <ReinH> which tricky parts?
21:12:23 <carter> how to get that next week
21:12:31 <ReinH> throw more machines at it, typically
21:12:31 <carter> :)
21:12:34 <carter> yes
21:12:39 <ReinH> that's why it's boring :)
21:12:50 <carter> the tricky part is making that somethign you could easily do with cabal
21:12:59 <ReinH> oh, but I'm not trying to do that :p
21:13:11 <Tekmo> Just forget cabal for a second
21:13:15 <Ghoul_> I wonder if pipes can be implemented with something like ContT for speed
21:13:15 <carter> ok
21:13:20 <Tekmo> Let's think about things in really abstract terms
21:13:29 <carter> Ghoul_: though that was the point of machiners
21:13:32 <carter> @hackage machines
21:13:32 <lambdabot> http://hackage.haskell.org/package/machines
21:13:43 <ReinH> you can already use reactivity to make re-compilation more efficient
21:13:59 <Tekmo> Ghoul_: `pipes` is probably faster than `machines`
21:14:02 <ReinH> even in a system as simple as redo, you can do some version of that
21:14:03 <Ghoul_> woah thats confusing to look at
21:14:19 <ReinH> which, btw, uses a real programming langauge
21:14:21 <Ghoul_> pipes is certainly much easier too, but honestly, pipes-network needs a rewrite or something
21:14:25 <ReinH> to the extent that shell is a real programming langauge :p
21:14:29 <Tekmo> Ghoul_: The reason I prefer non-CPS style is that any time you have a performance bottle-neck you can optimize it using rewrite ruls
21:14:36 <Tekmo> You can't do that optimization when you use CPS style
21:14:41 <carter> Tekmo you can;t?
21:14:43 <carter> really?
21:14:48 <carter> why not?
21:14:51 <Tekmo> It's very difficult to get rewrite rules to fire on CPS patterns
21:14:53 <carter> just harder to get the rules to fire?
21:14:56 <carter> huh
21:15:03 <carter> are there any trac tickets on that?
21:15:12 <Tekmo> I have no idea
21:15:31 <carter> cause if you have any good toy examples of that
21:15:35 <carter> i'd love to throw that on trac
21:16:05 <Tekmo> Hmmm, let me see what I can throw together
21:16:10 <carter> lately my appraoch to all the "nice things we'd like ghc to have" statements is "lets come up with an example and throw it on trac"
21:16:12 <carter> yay!
21:16:12 <carter> :)
21:17:21 <carter> Tekmo thats a ticket worth writing
21:17:31 <carter> (assuming you can cook up a good toy examples)
21:17:32 <Tekmo> Give me just a second
21:17:51 <carter> kk
21:17:52 <carter> no presure
21:17:55 <carter> i'm just enthusing
21:18:00 <Tekmo> :)
21:18:04 <carter> tikhon back out west?
21:18:56 <tikhon> Yeah, back in the Bay Area
21:19:30 <carter> hehe
21:19:46 <carter> my sister's doing IP focused law school in the bay area
21:19:58 <tikhon> oh, that's good
21:20:01 <carter> yeah
21:20:07 <carter> and she's had years of dealing with me
21:20:08 <tikhon> I think we have several law schools around
21:20:16 <carter> berkeley's is pretty good i hear
21:20:24 <tikhon> and I'm guessing IP is a pretty popular subject in the area
21:20:34 <carter> tikhon: so i figure, years of dealing with me == she can handle any techy folks well
21:21:40 <startling> carter: you're your sister? that must be confusing.
21:21:51 <carter> nope
21:21:53 <carter> i'm saying
21:22:10 <carter> my sister has had years of dealing with me, a loud, obnoxious computer scientist
21:22:17 <startling> "years of dealing with (me == she) [...]" ;)
21:22:33 <carter> read "===" as implies
21:22:43 <carter> natural language magic infix
21:22:47 <carter> like in scala or something
21:22:59 <tikhon> If it's natural language, you don't have to specify that it's magic :)
21:23:09 <carter> true
21:23:47 <carter> actually, its pretty funny, prior to going to college, my sisters thought all comptuer scientists were like me....
21:23:57 <carter> boy were they suprised
21:24:03 <carter> *egad were they surprised
21:27:35 <carter> anyways: tikhon does hackage have any bsd3 sat/smt solver bindings that are fast?
21:27:42 <carter> (i figure you'd know)
21:27:55 <tikhon> I doubt the bindings have that much effect on how fast it is
21:28:01 <tikhon> that's mostly going to depend on the solver
21:28:13 <carter> yes
21:28:28 <tikhon> I've only really used sbv which is under the BSD3 license
21:28:37 <carter> i mean: is there a fast, bsd/apache solver, which has bsd haskell bindings
21:28:41 <tikhon> ah
21:28:42 <tikhon> well
21:28:47 <carter> or mit
21:28:50 <tikhon> depends on what you want to do, I suppose
21:29:04 <carter> good thing i've not thought that far :)
21:29:06 <tikhon> z3 has a stupid license, but that's what most people seem to use
21:29:15 <tikhon> well, people in academia
21:29:32 <carter> yeah
21:29:46 <tikhon> If you want to do bitvector stuff, boolector is good
21:29:59 <tikhon> it's GPL
21:30:06 <carter> v2?
21:30:08 <tikhon> but if you're just using it as a solver, that shouldn't matter
21:30:18 <carter> yeah
21:30:20 <carter>  i guess so
21:30:24 <tikhon> it's just like a compiler
21:30:24 <carter> isn't there that NYU one too?
21:30:36 <tikhon> I mean, it *is* a compiler (or an interpreter), really
21:30:39 <carter> http://cvc4.cs.nyu.edu/web/
21:30:40 <tikhon> Yeah
21:30:43 <tikhon> I don't know much about that one
21:31:06 <tikhon> the stuff I've been playing around with mostly used bitvectors
21:31:08 <carter> yak shaving time :)
21:31:16 <krey_> o/, I remember reading about someone using the free group monad in haskell for something vaguely useful. do you guys have any ideas?
21:31:36 <carter> free monad or free *group* monad
21:31:40 <carter> i know about one
21:31:41 <carter> not the other
21:32:13 <Tekmo> carter: I just tested it and the rule firing actually worked this time
21:32:19 <carter> k
21:32:27 <carter> care to share the example?
21:32:31 <Tekmo> Yeah, it's really simple
21:32:37 <Tekmo> {-# RULES "map" map (\x -> x) = id #-
21:32:50 <carter> hrmm
21:33:07 <augur> Tekmo!
21:33:11 <Tekmo> augur: Hi!
21:33:16 <carter> maybe a better example would be the CPS analoge of map f . map g == map (f. g)
21:33:26 <augur> Tekmo: you owe me a readthrough of my iteratees tutorial :)
21:33:31 <Tekmo> The one I like to test is the associativity law
21:33:32 <augur> or at least the partial tutorial
21:33:38 <Tekmo> for a category
21:33:48 <Tekmo> augur: Which one is it?
21:33:52 <augur> http://www.purelytheoretical.com/programming/iteratees.txt
21:33:59 <carter> Tekmo which ?
21:34:35 <carter> tikhon : http://hackage.haskell.org/packages/archive/sbv/2.9/doc/html/Data-SBV-Bridge-CVC4.html wooot!
21:34:35 <tikhon> carter: you might also want to look at edwardk's ersatz: https://github.com/ekmett/ersatz
21:34:37 <Tekmo> carter: I mean the rule: (f . g) . h = f . (g . h)
21:34:42 <carter> ok
21:34:52 <Tekmo> carter: I tried using the equivalent optimization rule for `pipes` a while ago and never got it to fire
21:35:04 <Tekmo> Give me a second while I read augur's post
21:35:07 <carter> k
21:35:10 <edwardk> heya Tekmo
21:35:13 <Tekmo> Hey!
21:35:15 <augur> Tekmo: you dont have to read it right away
21:35:16 <carter> any "good" example of rules not fire
21:35:21 <carter> might still be a handy ticket to file
21:35:24 <carter> tikhon you're right
21:35:28 <carter> @hackage ersatz
21:35:28 <lambdabot> http://hackage.haskell.org/package/ersatz
21:35:32 <edwardk> did you see the 'tekmo's folds are better than mine' angle in the new automata post?
21:35:35 <carter> i'm out of date on erstatze
21:35:39 <Tekmo> I did :)
21:35:41 <carter> edwardk you said that?
21:35:43 <carter> @hackage foldl
21:35:43 <lambdabot> http://hackage.haskell.org/package/foldl
21:35:45 <edwardk> pretty much
21:35:48 <Moggle> I have something of an interesting problem: I am using an existential data type, and want to automatically derive Read for it. Is there any easy solution for this?
21:35:58 <edwardk> Fold is faster than Moore
21:36:01 <Tekmo> However, I found an interesting variation on the fold type that is a category
21:36:02 <carter> edwardk: does it subsume multipass?
21:36:08 <carter> or should multipass steal foldl?
21:36:13 <Tekmo> Unfortunately, I lost my notes on it :(
21:36:17 <krey_> I found it! http://blog.sigfpe.com/2007/06/monads-from-algebra-and-the-gray-code.html but it's not as interesting as I'd hoped
21:36:28 <carter> Tekmo: is that rule in your repo history?
21:36:30 <Tekmo> Oh, it was not only a category, but an arrow, too
21:36:34 <Tekmo> carter: No
21:36:36 <edwardk> carter: no, it just urges me to consider explicitly adding the seed parameter to machines' implementation of moore
21:36:36 <startling> Moggle, existential quantification? It's not possible in general.
21:36:47 <carter> the fusion rule?
21:36:55 <edwardk> Tekmo: did you find mealy basically?
21:37:04 <Tekmo> carter: The only rules that I've ever committed are the ones that are currently in the code base
21:37:10 <carter> ok
21:37:12 <Tekmo> edwardk: What's the type of mealy?
21:37:19 <carter> darn
21:37:25 <carter> well, if you reconstruct it at som epoit
21:37:35 <Moggle> startling: pity, I suspected that.
21:37:37 <edwardk> Tekmo: if you 'roll' moore a bit you get newtype Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }
21:37:40 <tikhon> startling: couldn't you do it if the existential variable has the appropriate constraints?
21:37:58 <edwardk> a moore machine has a value for each state, a mealy machine has labels attached to the transitions
21:38:28 <startling> Moggle, if you'd care to show the specific code you have, though, it might be possible
21:38:31 <startling> tikhon: yeah.
21:38:31 <edwardk> moore gives you a beautiful comonad, etc. mealy gives you an arrow
21:38:42 <Tekmo> edwardk: Yeah, that looks about right.  It was basically like a scan
21:38:43 <Moggle> startling: give me a bit here
21:39:03 <edwardk> Tekmo: yeah i have both of those in machines, they are pretty fundamental old school automata
21:39:14 <tikhon> Moggle: try using standalone deriving
21:39:44 <edwardk> in theory there is a similar existential hack to take apart mealy like we can take apart moore to get an existential parameter on its own
21:40:05 <edwardk> but it sadly doesn't give rise to the 'resumable hmac' trick
21:40:25 <Tekmo> edwardk: Well, the one I had was decomposed like `Fold`
21:40:30 <edwardk> yeah
21:40:43 <edwardk> i had something similar for mealy once upon a time
21:42:17 <Tekmo> augur: I notice you don't mention that the iteratee forms a monad
21:42:38 <augur> Tekmo: im still wrapping my head around them ;P
21:43:24 <Tekmo> augur: One simple way to describe an iteratee is to just call it a fold
21:43:27 <lpaste> Moggle pasted “No title” at http://lpaste.net/92425
21:43:36 <Moggle> startling: tha
21:43:37 <Moggle> that
21:43:59 <Moggle> is the general idea
21:44:00 <augur> Tekmo: that's all good and well except that doesnt really help to understand whats up with iteratees
21:44:03 <Tekmo> augur: You give it a stream of values and it computes a single result (whatever is in the `Halt`/`Done`)
21:44:04 <Moggle> though you did say specific code, which is a huge mess.
21:44:19 <Moggle> A/B/C can all be deriving read of course
21:45:01 <startling> oh, no, I don't think it's possible at all, because read is return-type polymorphic
21:45:06 <Tekmo> augur: What's the main point that you want to convey?
21:45:18 <augur> Tekmo: what they are and how they work
21:45:30 <startling> there's no general mechanism to list the types a string may be validly read as, you know?
21:45:40 <tikhon> Moggle: I don't think that would work unless class E_ had Read as a superclass or something
21:45:49 <tikhon> after all, what if you add another type to E_?
21:45:53 <startling> tikhon: I think it's more complicated than that.
21:46:06 <tikhon> yeah, it probably is
21:46:10 <tikhon> I'd have to think about it a bit
21:46:13 <elliott> edwardk: your post never defines less for Moore
21:46:20 <startling> since we can't see a string and list what types it is.
21:46:22 <edwardk> it makes it a field accessor
21:46:29 <startling> *what types it can be read as.
21:46:48 <edwardk> oh
21:46:50 <startling> Moggle, you can do it with Show (given the Show constraint on the hidden type) but not with Read, I think.
21:46:55 <edwardk> yeah i guess i don't o that in the definitions i show
21:46:57 <Tekmo> augur: So technically state is not intrinsic to the iteratee
21:47:09 <Tekmo> augur: Your iteratees behave like state machins because you pass around a state argument
21:47:13 <edwardk> fixing
21:47:25 <augur> Tekmo: nope, most of my iteratees dont have a state argument :)
21:47:27 <augur> well
21:47:32 <Tekmo> augur: adder does, for example
21:47:32 <augur> most of the examples, rather
21:47:47 <Moggle> startling: That seems like an odd restriction
21:47:53 <augur> the running example is a stateless iteratee
21:47:59 <augur> (well, a finite state iteratee, but...)
21:48:15 <Tekmo> augur: You are also using "implicit state" by switching between different iteratees
21:48:20 <Moggle> although i guess read's polymorphic type doesn't help much
21:48:21 <startling> Moggle, well, say you have a string. how do you decide what type to read it as?
21:48:24 <edwardk> elliott: fixed
21:48:31 <Tekmo> i.e. `q1''` switching to `q0''` and vice versa
21:48:36 <Moggle> startling: specify it
21:49:04 <Moggle> startling: I guess I see the problem.
21:49:04 <startling> Moggle, right. you could specify it in the Read instance for E, but I assume that's not what you want.
21:49:05 <edwardk> augur: link to your description? the statement form sounds like "It" from trifecta
21:49:07 <Tekmo> augur: This is no different than defining a single `q0` that takes a `Bool` state parameter that it threads through the computation
21:49:21 <augur> Tekmo: yeah probably true.
21:49:24 <augur> edwardk: http://www.purelytheoretical.com/programming/iteratees.txt
21:49:52 <augur> Tekmo: im not sure that people will get the impression that this is about some sort of state thing, but
21:50:04 <Tekmo> augur: The distinguishing feature of iteratees is that they can block and wait for an anonymous source of input
21:50:32 <elliott> edwardk: yay.
21:50:39 <augur> Tekmo: im not sure what you mean by "block"
21:50:44 <Tekmo> edwardk: I had an idea I wanted to run by you regarding machnes
21:50:57 <mm_freak> my lpaste post disappeared…
21:50:58 <Tekmo> edwardk: How many machines form `Arrow`s and `ArrowChoice`s?
21:51:01 <edwardk> elliott: anyways, sadly your favorite moore rep lost to tekmo's in the benchmark-off
21:51:24 <edwardk> Tekmo: well, mealy is arrow and possbly arrowchoice
21:51:33 <mm_freak> Mealy is ArrowChoice
21:51:41 <edwardk> moore gets the comonad instead
21:51:48 <Tekmo> The reason why is that I've been working on a general framework for something FRP-like
21:51:56 <elliott> edwardk: someone should make GHC treat it better.
21:51:56 <Tekmo> It has three basic components
21:52:03 <mm_freak> edwardk: Mealy is also ArrowLoop, btw
21:52:10 <mm_freak> and that's a very useful instance
21:52:11 <edwardk> mm_freak: did i omit the instance?
21:52:20 <mm_freak> yeah
21:52:22 <augur> Tekmo: ?
21:52:32 <edwardk> mm_freak: patch! =0
21:52:58 <Tekmo> augur: I mean the `Next` constructor.  Each time you reach a `Next` you suspend the computation until you receive an argument
21:53:08 <augur> oh, sure
21:53:38 <mm_freak> edwardk: loop (Mealy f) = Mealy $ \x -> let ((y, d), m) = f (x, d) in (y, m)
21:53:43 <mm_freak> that should work
21:53:52 <edwardk> mm_freak: i'll push it in. brb
21:53:55 <shachaf> elliott: I think maybe you'd end up with a sort of unfold-fusion.
21:54:25 <Moggle> I don't suppose it's possible to serialize functions in general, is it?
21:54:40 <Tekmo> edwardk: The reason `foldl` does so well is because it decomposes the fields
21:54:43 <mm_freak> edwardk: newtype MealyT m a b = MealyT { runMealyT :: a -> m (b, MealyT m a b) }
21:54:45 <Tekmo> edwardk: I found this is true of a lot of libraries
21:54:48 <Moggle> I mean obviously you'll have issues serializing something closure-ish but perhaps if the function was 'static' then there would be issues?
21:54:49 <opqdonut> Moggle: that's what compilation does ;)
21:54:54 <mm_freak> that one has:  MonadFix m => ArrowLoop (MealyT m)
21:54:56 <Tekmo> edwardk: If you take out the recursion, ghc does an amazing job of optimization
21:55:03 <Tekmo> edwardk: It's the same principle behind stream fusion
21:55:07 <mm_freak> and MealyT is a lot more useful than Mealy =)
21:55:20 <tikhon> Moggle: I don't know about doing it "in general", but Cloud Haskell has something like that for transmitting closures over the wire
21:55:32 <mm_freak> finally put a "Maybe" in front of the 'b' and you've got Wire =P
21:55:34 <Moggle> tikhon: interesting! i will look into this
21:56:14 <edwardk> Tekmo: yeah. i'm doing something similar with a form of 'matrix fusion' in my toy tensors project and it works really well
21:56:28 <Tekmo> edwardk: The one thing I've learned is that `ghc` is terrible at optimizing recursive code
21:56:43 <edwardk> mm_freak: i've been meaning to add the transformer versions of that and Moore
21:56:48 <mm_freak> Tekmo: GHC is much better at optimizing corecursive code
21:57:08 <startling> Moggle: well, there's ways to cheat using Typeable, Data, et
21:57:09 <Tekmo> mm_freak: You mean like stream fusion?
21:57:09 <startling> c
21:57:18 <mm_freak> in fact i had a problem, where a Stream unfold/fold performed better for me than the straightforward recursive search
21:57:26 <mm_freak> Tekmo: no, regular Stream deconstruction
21:57:32 <augur> Tekmo: what would you suggest is a better example of a non-stateful iteratee
21:57:45 <Tekmo> mm_freak: Maybe I have the wrong name for it
21:57:54 <Moggle> startling: Is this cheating particularly awkward?
21:58:06 <mm_freak> Tekmo: stream folds and unfolds…  GHC seems to deal very well with these
21:58:11 <Tekmo> augur: Well, there are no interesting examples of non-stateful iteratees if you don't use effects
21:58:26 <Tekmo> augur: It's only when you make it a monad transformer that you have useful non-stateful iteratees
21:58:41 <augur> Tekmo: then quite complaining! :p
21:58:44 <augur> quit*
21:58:45 <Tekmo> augur: :)
21:58:58 <edwardk> mm_freak: my local machines repo is a bit fubared, but i do intend to fix up mealy with the monad transformer and maybe even moore as a comonad transformer
21:58:58 <mm_freak> Tekmo: that's basically why pipes performs so well =)
21:59:22 <Tekmo> mm_freak: Actually, `pipes` is horrible for GHC's optimizer
21:59:28 <augur> Tekmo: i dont even understand the monadc ones yet, so i cant write that portion of the tutorial. i just wanted to write something that expressed my current understanding
21:59:37 <edwardk> mm_freak: sadly any form of fusion that needs a tree-like construction, or non-linear usage pattern and it fail miserably
21:59:57 <carter> edwardk: does anyone have good examples of this lying around
21:59:58 <Tekmo> mm_freak: `pipes` only performs well because of rewrite rules.
22:00:03 <mm_freak> Tekmo: yes, but that has little to do with the recursion…  adding a few SPECIALIZEs improved code performance a lot for me
22:00:11 <carter> would be cool to have ghc trac ticket about those fusion needs
22:00:12 <edwardk> carter: the matrix stuff i talked to you about the other day
22:00:13 <carter> and the rules
22:00:15 <carter> ok
22:00:22 <edwardk> carter: but i don't know that it is _possible_ is the key
22:00:23 <carter> GHC couldn't fuse it well/
22:00:26 <carter> ok
22:00:27 <carter> well
22:00:27 <Tekmo> mm_freak: Interesting
22:00:33 <edwardk> so i can't really say its a bug =)
22:00:35 <carter> then its a research problem!
22:00:41 <carter> edwardk is it still in the repo?
22:00:41 <mm_freak> Tekmo: to a point where the monadic binding was the most expensive part
22:00:43 <carter> or in the history?
22:00:44 <edwardk> when i'm not able to figure out something better it could do
22:00:48 <edwardk> its not in a repo i've put up
22:00:51 <carter> ok
22:00:58 <Tekmo> augur: You should also make the code a little more readable
22:01:08 <Tekmo> augur: Do you have syntax highlighting turned on?
22:01:09 <augur> Tekmo: how do you mean
22:01:09 <edwardk> you might find a sketch of a Tensors.hs at the start of the structures repo history
22:01:11 <carter> edwardk: if you push it to a "bad fusion dont' touch this" branch, i'll write a trac ticket
22:01:16 <augur> Tekmo: er??
22:01:18 <carter> and pull out the example codes
22:01:21 <edwardk> but its going to be its own thing
22:01:23 <carter> to nerd snipe someone for ghc
22:01:25 <mm_freak> edwardk: currently i'm not using machines…  i just can't find a use case for it
22:01:25 <augur> its a txt file
22:01:28 <carter> ok
22:01:33 <edwardk> i don't have it in a state i'd want it cited in a ticket
22:01:37 <edwardk> mm_freak: fair nuff
22:01:42 <mm_freak> edwardk: either not powerful enough or already solved by pipes/netwire =)
22:01:47 <carter> ok
22:02:00 <Tekmo> augur: Maybe it's the font I'm using to view the text file
22:02:03 <edwardk> mm_freak: then i'll carry on my own merry way ;)
22:02:12 <carter> edwardk enough people are talking about having bad fusion / rewrites are fragile examples that I wanna write a ghc trac ticket
22:02:16 <Tekmo> augur: The primes are very hard to see, so the state transitions are difficult for my eyes to follow
22:02:26 <mm_freak> edwardk: also i find that i'm already depending on your libraries too much =P
22:02:31 <augur> Tekmo: that's weird
22:02:35 <edwardk> carter: its a 500 line example litered with poly kinds that doesn't compile.
22:02:38 <edwardk> its not trac'able
22:02:40 <carter> ok
22:02:46 <Tekmo> I think we ca nget a simple one for this rewrite rule
22:02:47 <carter> is there a way to clean it up
22:02:50 <mm_freak> even toy project usually import Data.Semigroup or Data.Profunctor
22:02:58 <carter> Tekmo?
22:03:01 <Tekmo> {-# RULES "assoc" forall f g h . (f . g) . h = f . (g . h) #-}
22:03:23 <carter> thats hard to fire?
22:03:30 <Tekmo> carter: Let me check
22:03:34 <edwardk> carter: i'm not planning on thinking about it, as i have enough trouble fitting the whole tensors project in my head let alone letting it serve multiple masters ;)
22:03:40 <carter> ok
22:03:44 <carter> fineeee
22:03:45 <carter> :)
22:03:57 <carter> edwardk: , this is the tensors stuff, not the sparse stuff, go tit
22:03:58 <startling> would that be a performance improvement in general? why?
22:04:04 <carter> startling which what?
22:04:09 <carter> startling: hows the goog?
22:04:15 <amosr> Tekmo: do you have (.) NOINLINE or some later phase for that ?
22:04:16 <startling> {-# RULES "assoc" forall f g h . (f . g) . h = f . (g . h) #-}
22:04:16 <edwardk> yeah
22:04:26 <startling> carter, I've only just responded
22:04:29 <carter> oh
22:04:32 <Tekmo> Nope, never mind
22:04:34 <Tekmo> That rule fired, too
22:04:47 <startling> oh, I see, I read it backwards.
22:04:48 <carter> what would the cp's version of the map fusion rule?
22:04:59 <startling> f . (g . h) is less nesty than (f . g) . h
22:05:09 <carter> why's that?
22:05:19 <carter> for streams i could see that
22:05:27 <startling> oh, wait, no it's not.
22:05:33 <startling> I read it backwards backwards.
22:05:39 <Tekmo> Maybe GHC's rewrite rule firings have improved since the last time I checked
22:05:44 <carter> ok
22:05:47 <carter> well
22:05:47 <shachaf> Compare to join . join vs. join . fmap join
22:05:49 <mm_freak> for regular functions you want to left-associate (.)
22:06:07 <shachaf> Anyway, I don't think rules are the right approach to that for the most part.
22:06:14 <carter> for which?
22:06:22 <amosr> I remember having an issue with operator sections in rewrite rules before
22:06:23 <edwardk> reassociations
22:06:30 <shachaf> I don't even know what people are talking about right now, actually.
22:06:36 <startling> mm_freak: right, since otherwise you need a stackish thing
22:06:58 <carter> shachaf: some folks were saying "i have fusion rewrite rules that are hard to fire!"
22:07:07 <carter> and i'm like "i want examples that make sense so i can put it on ghc trac"
22:07:34 <carter> mwahah
22:07:51 <shachaf> carter: I had an example along these lines a while ago that was really hard to get GHC to fire.
22:08:01 <carter> oh?
22:08:02 <shachaf> But actually it was something I wouldn't even expect GHC to do.
22:08:07 <mm_freak> well, there are some cases, where right-associated (.) works better
22:08:07 <carter> does it still live somehere?
22:08:15 <mm_freak> const x . (g . h)
22:08:16 <shachaf> Never mind that.
22:08:29 <shachaf> You'd need something more powerful than RULES for what I was after.
22:08:39 <mm_freak> but if all functions are strict, left-associated (.) works better
22:09:02 <carter> shachaf thats ok
22:09:07 <carter> still worth documenting!
22:09:12 <shachaf> Nah.
22:09:20 * shachaf is on the train right now anyway. Disappearing in a moment.
22:09:23 <carter> ok
22:09:33 <Tekmo> augur: I don't see any other obvious problems with the text
22:09:37 <carter> shachaf : i mean, theres eg repa4 which is going full compiler plugin
22:09:52 <mm_freak> > foldr (.) id (const 3 : repeat id) 15
22:09:53 <lambdabot>   3
22:10:08 <carter> woulbe be intersting / perhaps useful to have something thats not quite full compiler plugin
22:10:49 <Tekmo> I feel like there needs to be a simpler and more portable version of repa for accessing unboxed vectors using multidimensional indices
22:10:57 <amosr> am I missing something? why do you care about associativity of (.), aren't you just better off making sure it inlines?
22:11:14 <carter> Tekmo: oh
22:11:24 <carter> Tekmo: i'll be finally releasing that this month :)
22:11:27 <mm_freak> Tekmo: which part of repa do you want?  parallelism or shapes?
22:11:30 <carter> shaps
22:11:32 <Tekmo> carter: What is it called?
22:11:36 <Tekmo> mm_freak: None
22:11:39 <carter> its not released yet
22:11:45 <Tekmo> mm_freak: I just want unboxed vectors + multi-dimensional indices
22:11:51 <augur> Tekmo: im primarily concerned with how well it conveys the idea behind iteratees
22:11:54 <carter> Tekmo: plus more than just row major :)
22:12:31 <augur> Tekmo: how does it feel? a nice, easy way to slip into iteratees? or forced and obtuse?
22:12:34 <mm_freak> Tekmo: multidimensional indices a la Ix instead of repa shapes?
22:13:00 <Tekmo> augur: I think it is good the way it is
22:13:14 <Tekmo> augur: You have to remember than any single way of writing about it will never hit the mark for your entire audience
22:13:35 <Tekmo> augur: Usually different people will have a different concept that will help them leap the gap
22:14:00 <Tekmo> augur: I think that some people will definitely get the metaphor in terms of state machines and that's good enough for the scope of this article
22:14:00 <carter> mm_freak: repa has a pretty nice idea for rank
22:14:07 <carter> but … only has one memory layout!
22:14:09 <carter> ish
22:14:12 <mm_freak> carter: i know, but Tekmo seems to disagree =)
22:14:15 <Tekmo> mm_freak: I'm fine with either Ix or repa shapes
22:14:24 <carter> its the rest of repa thats the issue :)
22:14:30 <carter> its not general enough
22:14:33 <carter> its a great research lib
22:14:46 <Tekmo> augur: There is a rule of thumb that people will only take away one thing, maybe, from any post you write
22:14:51 <Tekmo> augur: So you should only say one thing
22:15:09 <Tekmo> augur: And write now what you have is pretty good.  You have a very clear story about state machines
22:15:26 <Tekmo> *right now
22:15:29 <mm_freak> Tekmo: vectors with repa shapes may be easy to get, although Ix may be more powerful and already provides all you need to put a layer around Vector
22:15:42 <mm_freak> with a simpler interface you won't get the parallelism though
22:15:50 <Tekmo> mm_freak: I don't care about parallelism
22:16:18 <Tekmo> mm_freak: I just want C-style multi-dimensional arrays
22:16:24 <Moggle> Uh, what's the easiest way to have a sort of 'extensible' data type that is serializable?
22:16:31 <mm_freak> Tekmo: oh, you have those
22:16:32 <carter> Tekmo messaged yah
22:16:35 <mm_freak> Vector (Vector a)
22:16:39 <Tekmo> mm_freak: Nope
22:16:41 <Moggle> Existential data types are close to ideal but can't be easily serialized.
22:16:44 <Tekmo> mm_freak: The outer vector is not boxed
22:16:46 <carter> Tekmo slices?
22:16:47 <Tekmo> mm_freak: That's the problem
22:16:53 <Tekmo> *not unboxed
22:16:54 <carter> what do you mean?
22:17:03 <carter> ohhhh
22:17:05 <carter> repa does that
22:17:07 <Tekmo> Right
22:17:11 <Tekmo> But that's the issue I originally raise
22:17:15 <carter> yeah
22:17:18 <Tekmo> I want something like repa, but more portable
22:17:18 <mm_freak> Tekmo: that's not really a fundamental problem…  it's rather a missing feature
22:17:24 <carter> portable in what sense?
22:17:30 <Tekmo> Sorry, I mean simpler
22:17:34 <Tekmo> and less experimental
22:17:36 <carter> mm_freak: actually its a deeper design problem than that
22:17:43 <carter> Tekmo: well, you mean imperative apit too?
22:17:45 <carter> :)
22:17:51 <mm_freak> well, yeah
22:17:59 <Tekmo> carter: No, I'm fine with something like `vector`
22:18:01 <carter> yes
22:18:03 <mm_freak> vectors don't encode their length in their type
22:18:08 <mm_freak> if they did, it would be easy
22:18:10 <Tekmo> Really I just want multi-dimensional interface to unboxed vectors
22:18:15 <carter> yeah
22:18:23 <carter> Tekmo: what did you say no to?
22:18:29 <carter> vector has an imperative api...
22:18:34 <carter> along with the functional
22:18:39 <mm_freak> Tekmo: anyway, repa really just lacks many 'vector' operations…  it's not really more complicated
22:18:40 <Tekmo> carter: I was saying No to `Vector (Vector a)`
22:18:45 <carter> oh yea that sucks
22:18:47 <carter> agreed
22:18:58 <Tekmo> Really, boxed vectors are useless
22:19:01 <carter> the bed and breakfast lib made me froth from the mouth in bad locality rage
22:19:03 <Tekmo> Except for memoization
22:19:06 <Tekmo> They rock for memoization
22:19:14 <carter> or if you want to try a tiny matrix with rationals
22:19:28 <carter> to sanity check your math works
22:19:38 <mm_freak> Tekmo: they rock for other things, too…  boxed vectors are sometimes a good replacement for Seq
22:19:39 <carter> (assuming you don't need transcendental functions or square roots)
22:19:43 <Tekmo> Yeah, it also bothers me that there is no `Int`/`Integer` matrix library
22:20:03 <carter> Tekmo: that gets into needing better num type classes though
22:20:09 <carter> slippery slope!
22:20:25 <mm_freak> Tekmo: the 'linear' library can do a lot with integer vectors/matrices
22:20:25 <Tekmo> carter: Well, you don't have to use the `Num` class
22:20:32 <Tekmo> carter: I don't mind custom operators
22:20:47 <carter> Tekmo: 'm trying to not yak shave tooooo much before release
22:21:04 <mm_freak> but it's not really a linear algebra library…  it's more a vector/matrix arithmetic library
22:21:13 <carter> which ?
22:21:17 <mm_freak> carter: linear
22:21:29 <carter> mm_freak: its more what edwardk  wanted for writing games library :)
22:21:41 <Tekmo> Speaking of which, has anybody ever written up this post of Russell O'Connor's: http://r6.ca/blog/20110808T035622Z.html
22:21:55 <mm_freak> carter: yeah, which is pretty much vector/matrix arithmetic =)
22:22:09 <carter> and solvers for 3x3 asnd 4x4 matrices
22:22:16 <mm_freak> also the type classes in 'linear' have some weaknesses compared to conal's vector-space library
22:22:30 <edwardk> linear exists because i had a dozen people ask me to port out the stuff i had in physics
22:22:39 * hackagebot crypto-random 0.0.5 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.5 (VincentHanquez)
22:23:18 <edwardk> you can't give certain types instances, yes. linear was written for a smaller domain, and one where the inability to write those instances was a feature.
22:23:24 <carter> mm_freak how so?
22:23:27 <edwardk> its slowly drifting away from that as folks add sparse vector spaces
22:23:33 <mm_freak> carter: what edwardk said
22:24:09 <carter> Tekmo: point being, i'll be releasing soething that *includes* what you want
22:24:11 <mm_freak> carter: example:  with vector-space you can write this instance:  instance (VectorSpace b) => VectorSpace (F b)
22:24:16 <carter> ok
22:24:26 <carter> where F is what?
22:24:31 <mm_freak> some functor of your choice
22:24:36 <carter> @hackage vector-space
22:24:37 <lambdabot> http://hackage.haskell.org/package/vector-space
22:24:56 <mm_freak> so you can write x ^+^ y instead of liftA2 (^+^) x y
22:24:59 <edwardk> linear is based on the observation that every vector space is a free vector space, and so can be put into the form (e -> r), so we find a representable functor that has representation e, so that (e -> r) ~ f r, then we capture memoization. this doesn't capture unboxed vector spaces though
22:25:04 <carter> mm_freak: so i actually disagre with that design in the performance case
22:25:11 <carter> or at least, i have a different sort of functorality
22:25:13 <carter> ish
22:25:22 <carter> yeah
22:25:23 <mm_freak> carter: performance of linear is fine
22:25:35 <carter> for things that aren't meant to be using blas, yes :)
22:25:39 <carter> i'm competing against blas!
22:25:57 <edwardk> carter: linear was used to back my edsl for generating gpu code. it works fine for sufficiently deep embeddings =P
22:26:01 <carter> ok
22:26:03 <carter> yeup!
22:26:05 <carter> agree with that
22:26:13 <carter> its a great DSL for simd
22:26:23 <mm_freak> Taneb: liftA2 is used in the context of Wire, not the underlying monad (that would be a type error)
22:26:25 <carter> i was planning on doing that .....
22:26:29 <carter> but anyways
22:26:30 <carter> yeah
22:26:41 <edwardk> the problem i was having was every time i turned around someone had crippled their linear algebra libraries by focusing on 'optimizations' like unboxing that made it impossible for me to use the library for actually doing anything deep
22:26:41 <Taneb> mm_freak, ah, right
22:26:51 <edwardk> so i went back and started over from representability
22:26:55 <mm_freak> Taneb: where you can't actually use liftM2 =)
22:27:13 <Taneb> mm_freak, stupid me for not seeing that
22:27:16 <Tekmo> carter: What is your library called?
22:27:18 <Taneb> It feels so obvious now
22:27:33 <carter> Teckmo: its not released yet
22:27:40 <carter> also look at the priv msg
22:28:06 <carter> Tekmo: get the mesage?
22:28:11 <Tekmo> carter: I'm not sure
22:28:22 <carter> did you get a message from me or not?
22:28:28 <Tekmo> I'm not sure :)
22:28:32 <Tekmo> I'm still new to using irc
22:28:34 <carter> ok
22:28:42 <carter> are you using a gui client like textual?
22:28:52 <carter> (thats what i use, and i think a bunch of others here use)
22:28:59 <Tekmo> irssi
22:29:23 <carter> a private message looks like a channel
22:29:25 <carter> or "query"
22:29:36 <Tekmo> Found it
22:29:38 <Tekmo> It's Alt-3
22:30:14 <Taneb> mm_freak, would you mind if I continue working on a library that's very similar to netwire, but different enough to be its own thing (barely)?
22:30:24 <begriffs> Has anyone else ever reached a state of despair trying to fix Haskell dependencies? Is this just a rite of passage? How do I wipe all traces of the haskell platform, cabal, hsenv, and cabal-dev from my system to try a fresh start? Is there a script for this?
22:30:27 <mm_freak> Taneb: why would i mind?
22:30:43 <startling> begriffs: rm -rf ~/.ghc
22:31:02 <Taneb> mm_freak, it feels like I'm encroaching on your territory somewhat, and I'd rather have your permission
22:31:24 <mm_freak> Taneb: FRP is not my territory…  it's conal's and i encroached on it already =P
22:32:12 <mm_freak> Taneb: but that makes me curious…  may i ask what you're working on?
22:32:35 <Taneb> mm_freak, https://github.com/Taneb/Bolt
22:33:02 <dmj``> begriffs: are you using osx or linux?
22:33:04 <mm_freak> "FRP library inspired by (ripping off) netwire"
22:33:05 <mm_freak> =)
22:33:12 <Taneb> The main differences are that I use a different Alternative instance, and have laxer constraints on things where you've used Monad because of AMP
22:33:22 <Taneb> Well, because of AMP not happening yet
22:33:29 <Taneb> mm_freak, hey, at least I'm honest
22:33:34 <mm_freak> AMP?
22:33:47 <Tekmo> Applicative Monad Proposal
22:34:12 <dmj``> begriffs: I use this, sudo /Library/Haskell/bin/uninstall-hs all --remove
22:34:21 <dmj``> begriffs: on osx
22:34:23 <arkeet> I thought it was called FAM.
22:34:41 <Taneb> arkeet, both are used, I think
22:34:47 <begriffs> dmj``: yeah I'm on os x. I'll try that, thank you!
22:34:48 <startling> PAM, if you're french.
22:34:50 <arkeet> I don't like either, fwiw
22:36:08 <dmj``> begriffs: np
22:36:13 <mm_freak> Taneb: i see the different Alternative instance…  why did you choose that one?
22:36:26 <arkeet> I think both are a case of UAS.
22:36:40 <Taneb> mm_freak, because it made sense and the other one's still there in the ArrowPlus
22:37:02 <Taneb> To me it felt obvious, I don't know
22:37:37 <joneshf-laptop> is there a typesafe way to write a function that takes a list of length two to a 2-tuple that also wont make ghc complain about non-exhaustive pattern matching?
22:37:39 * hackagebot timeplot 1.0.22 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.22 (EugeneKirpichov)
22:37:55 <joneshf-laptop> i mean, aside from having a case for everything else just throwing an exception
22:38:13 <arkeet> joneshf-laptop: there is no way to express "list of length two" in the type system.
22:38:23 <mm_freak> Taneb: not sure where i would use it…  if the underlying functor gets an 'empty' your only choice is to start over, resetting to the previous state
22:38:27 <arkeet> unless you want to use a different list type.
22:38:45 <tikhon> or an external extension like liquid types
22:38:58 <Taneb> mm_freak, true, but it's still a valid instance
22:39:17 <mm_freak> Taneb: also (<|>) is the main choice operator to me…  i provide ArrowZero and ArrowPlus mainly for the sake of completeness
22:39:22 <joneshf-laptop> hmm, that's disappointing
22:39:27 <Tekmo> arkeet: type List2 a = (a, a)
22:39:41 <arkeet> Tekmo: that counts as using a different list type :p
22:39:46 <arkeet> and it would be better as a newtype or data anyway.
22:39:52 <tikhon> joneshf-laptop: it's exactly the same reason you can't have a typesafe function that takes even numbers
22:40:03 <Taneb> mm_freak, actually, if the underlying functor recieves "empty" you can (<|>) it
22:40:12 <joneshf-laptop> tikhon: what reason is that?
22:40:55 <aleator> "commitAndReleaseBuffer: invalid argument (invalid character)" really makes for a great morning.. :/
22:40:58 <tikhon> joneshf-laptop: types can't normally depend on runtime values
22:41:02 <Tekmo> arkeet: :)
22:41:09 <tikhon> in Haskell
22:41:22 <mm_freak> Taneb: it's an unfortunate instance…  consider x <|> y where x is empty every other instant
22:41:30 <mm_freak> Taneb: time will now run half as fast for y
22:41:34 <joneshf-laptop> hmm
22:41:51 <Taneb> mm_freak, I think I account for that, but I'm not sure
22:42:01 <mm_freak> Taneb: you don't account for that
22:42:08 <Taneb> At the very least I know how to account for it
22:42:21 <mm_freak> Taneb: then you know more than me =)
22:42:42 <mm_freak> because you can't observe 'empty' in terms of Alternative
22:42:57 <mm_freak> so you don't know when to accumulate and when to pass
22:43:23 <mm_freak> Taneb: and that makes sense…  just check the Alternative instance of Maybe
22:43:23 <Taneb> mm_freak, good point
22:43:27 <mm_freak> Just x <|> _ = Just x
22:43:45 <dwcook> Is there a generally recommended natural number type to use?
22:44:05 <mm_freak> dwcook: what properties do you want?
22:44:12 <dwcook> mm_freak, basically, non-negative integers.
22:44:21 <dwcook> Statically assured, if possible.
22:44:46 <mm_freak> dwcook: fast (like Integer) or flexible (like [()])?
22:45:10 <Fuuzetsu> Why not use TypeNats?
22:45:13 <dwcook> mm_freak, I don't care about performance, I would prefer correctness.
22:45:35 <mm_freak> Fuuzetsu: because they are type-level
22:46:02 <arkeet> dwcook: coq/agda is that way -->
22:46:04 <Fuuzetsu> people still have values in their programs?
22:46:04 <arkeet> ;)
22:46:07 <elliott> dwcook: use the nats package
22:46:07 <mm_freak> dwcook: i'd just write a wrapper around Integer…  something like that likely exists on hackage
22:46:12 <elliott> edwardk approved.
22:46:14 <arkeet> wrappers are fine.
22:46:21 <Taneb> @djinn (a -> b -> c) -> (x -> y -> z) -> (a, x) -> (b, y) -> (c, z)
22:46:21 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
22:46:35 <mm_freak> dwcook: you won't get any static guarantees though
22:46:39 <Taneb> arkeet, as elliott said...
22:46:41 <Taneb> @hackage nats
22:46:41 <lambdabot> http://hackage.haskell.org/package/nats
22:46:46 <mm_freak> but you will get run-time errors, which is better than nothing
22:46:57 <arkeet> yes
22:47:08 <dwcook> Not in the mood to learn Agda just for this, so I will try the nats package. Thanks. :)
22:47:18 <arkeet> nats is a wrapper around Integer.
22:48:04 <Taneb> Damn, the function I want is in bifunctors
22:48:14 <dwcook> mm_freak, actually, [()] is pretty tempting. Is there an already written wrapper for that that provides Num?
22:48:21 <Taneb> But I don't really want to incur the dependency
22:48:34 <mm_freak> dwcook: if you want that, you should really define this:  data Nat = Zero | Succ Nat
22:48:39 <elliott> if you use [()] I'll cry.
22:48:41 <arkeet> the only advantage [()] gives you is laziness.
22:49:18 <mm_freak> dwcook: it's a good type for what it does do…  what it doesn't to is arithmetic with even moderately large numbers =)
22:49:26 <dwcook> mm_freak, haha, fair enough.
22:49:37 <dwcook> My values will be maybe as great as the tens, anyway.
22:49:39 <mm_freak> 500000*500000 might actually take a few minutes ;)
22:50:14 <Taneb> (clearly the correct way is newtype CNat = CNat {forall a. (a -> a) -> a -> a} :P)
22:50:39 <mm_freak> Taneb: if just that weren't a syntax error =P
22:50:52 <Taneb> mm_freak, shh you
22:52:39 * hackagebot bytes 0.11.4 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11.4 (EdwardKmett)
23:04:17 <Taneb> mm_freak, now that you've pointed it out, I think my Alternative instance is broken after the first instant anyway
23:06:24 <Taneb> Oh, I think it still obeys the Alternative laws
23:06:50 <startling> newtype CNat = CNat (forall a. (a -> a) -> a -> IO a)
23:06:55 <startling> otherwise it's just Nat
23:08:49 <mm_freak> i just had a minor epiphany
23:09:00 <mm_freak> netwire is a general stream fuser…
23:15:29 <Vertue> Do anyone know how to convert a sql varbinary to string in haskell?
23:25:42 <ill_logic> Hello Haskell people. I have a question. I am looking at: http://hackage.haskell.org/packages/archive/http-streams/0.6.0.2/doc/html/Network-Http-Client.html I did cabal update, cabal install http-streams, to make sure I have the latest version.
23:25:54 <ill_logic> However the example does not work.
23:26:03 <ill_logic> Couldn't match expected type `Hostname' with actual type `[Char]'
23:26:12 <ill_logic> i got a similar thing when I tried the shortcut version with "get"
23:26:17 <ill_logic> except it wanted a URL
23:26:24 <ill_logic> rather than a Hostname
23:27:03 <ill_logic> I see that Hostname is defined as Bytestring. Well, I imported that. I even tried explicitly casting ("www.example.com" :: Hostname) and it still complains that it's a [Char]
23:28:06 <Moggle> bytestrings are not chars
23:28:10 <mauke> haskell has no casts
23:28:22 <Moggle> you _can_ do the stringlike GHC thing i believe
23:29:07 <tikhon> ill_logic: enable the OverloadedStrings extension
23:29:10 <Moggle> uh, try {-# LANGUAGE OverloadedStrings #-}
23:29:16 <tikhon> it makes string literals behave just like numeric literals
23:29:35 <mauke> :-(
23:29:46 <mauke> you could at least use S.pack
23:29:46 <ill_logic> tikhon: Excellent, does the trick. Thank you!
23:29:57 <ill_logic> I will try S.pack
23:30:03 <mauke> import qualified Data.ByteString.Char8 as S
23:30:10 <mauke> (but it's still slightly evil)
23:30:24 <ill_logic> If that works, I will inform Mr. http-streams to fix their examples with one or the other. i guess preferably the latter.
23:30:31 <ill_logic> why is it evil?
23:30:50 <mauke> because it pretends ByteStrings are strings
23:30:52 <ill_logic> (they also forgot to import Data.Maybe...)
23:31:04 <ill_logic> S.pack changes it explicitly though right?
23:31:08 <ill_logic> what does that pretend?
23:31:09 <mauke> String can contain any unicode character
23:31:17 <mauke> ByteString contains bytes
23:32:07 <mauke> I don't know what pack "é" does but it'll either abort the program or return garbage
23:32:14 <tikhon> so something like "ሴ" will be weird
23:32:24 <mauke> well, pack "€" is probably a better example
23:32:49 <dpwright> Data.Text provides a load of functions to convert between encodings, and I think is generally preferred to ByteString these days (right?)
23:33:46 <tikhon> Text and Bytestring do different things
23:34:07 <tikhon> it doesn't make sense to prefer one or the other because they're largely orthogonal
23:34:27 <dpwright> for texty stuff, then
23:34:34 <tikhon> Use Text if you're dealing with something that is text semantically
23:34:53 <dpwright> I was given to believe that there was a time, before Text was written, when bytestring was the go-to for any fast string-like processing, including texty stuff
23:34:55 <tikhon> and Bytestring for binary data
23:35:11 <dpwright> and that's why it shows up in a lot of books/tutorials/etc
23:35:36 <tikhon> seems plausible
23:36:03 <tikhon> honestly, I just use String for everything, but I never do anything where the string code is a bottleneck
23:36:22 <startling> yeah. it's silly to optimize preemptively.
23:36:45 <startling> especially in cases like ByteString, where your optimization might be semantically wrong.
23:37:37 <Dodek> do you also feel that hackage has a very long response time?
23:44:05 <sopvop> is -XImpredicativeTypes ok?
23:44:21 <dmwit> Does it do something helpful for you?
23:45:15 <sopvop> Hm, it seems some other extension has turned it on
23:45:19 <sopvop> nvm
23:45:27 <dmwit> Are you sure?
23:46:04 <sopvop> Well, it compiled
23:46:27 <dmwit> My understanding is that ImpredicativeTypes doesn't do anything in modern GHCs.
23:46:57 <sopvop> Hm. Oh, It seems I've misinterpreted docs.
23:47:37 <sopvop> Which one allows me to  foo :: ( forall a . [a]->[a]) -> ...   and use that foralled function on different types of lists?
23:47:44 <sopvop> inside foo
23:47:46 <dmwit> RankNTypes
23:47:54 <sopvop> Ok then :)
23:48:02 <dmwit> (Rank2Types is probably enough. But they do the same thing anyway.)
23:49:56 <dmwit> Okay, I'm wrong.
23:50:01 <dmwit> ImpredicativeTypes still does something.
23:50:17 <dmwit> But if you don't need it, avoiding it is better. =)
23:52:15 <sopvop> avoid extensions at all costs?
23:52:44 <dmwit> heh
23:53:05 <startling> avoid costs
23:56:04 <dmwit> Interesting. I really don't understand what GHC is thinking here.
23:58:27 <lpaste> dmwit pasted “GHC's actual type matches my type signature... but it's still a type error” at http://lpaste.net/92431
