00:00:06 <NemesisD> man that sounds like a lot of work
00:00:27 <NemesisD> quinso: im not sure. i chose pathogen early on and haven't tried vundler
00:06:29 <NemesisD> alright i gotta run, later guys
00:06:29 <hpaste> mikeplus64 pasted “not quite jit” at http://lpaste.net/92964
00:06:53 <mikeplus64> ^ something neat i 'discovered' a while ago playing with callbacks for glfw etc
00:24:12 <a3f> I have a function in Graphics.Win32 with type String->String->IO HWND, when the first argument is NULL it uses the second, how can I supply NULL without the type system complaining?
00:25:14 <a3f> using [] doesn't work but writing the ffi wrapper with (if cname == "" then nullPtr else c_cname) does
00:31:16 <a3f> And a somewhat stupid question: is there a goto case statement in Haskell ?
00:37:52 <ion> Maybe String
00:38:02 <ion> What’s a goto case statement?
00:39:13 <mauke> case x of Nothing -> "hello"; Just x -> goto Nothing
00:40:28 <mauke> :t fix $ \goto x -> case x of Nothing -> "hello"; Just _ -> goto Nothing
00:40:30 <lambdabot> Maybe t -> [Char]
00:40:43 <mauke> > (fix $ \goto x -> case x of Nothing -> "hello"; Just _ -> goto Nothing) (Just ())
00:40:43 <ion> hah
00:40:44 <lambdabot>   "hello"
00:51:07 <shachaf> > (fix $ \goto x -> case x of Nothing -> goto (Just "default"); Just x -> map toUpper x) Nothing
00:51:08 <lambdabot>   "DEFAULT"
00:51:14 <shachaf> Clearly the most reasonable way of doing it.
01:03:08 <a3f> I don't get it what fix is doing
01:03:25 <mauke> @src fix
01:03:25 <lambdabot> fix f = let x = f x in x
01:03:45 <a3f> Hmm
01:04:34 <a3f> to me it looks like the id function?
01:05:54 <a3f> shachaf: could you elaborate on what that code does exactly?
01:06:14 <shachaf> help, how did i get involved
01:06:18 <shachaf> Oh, I used goto above.
01:06:32 <shachaf> That's a joke snippet and if you want to understand fix you should look at simpler examples.
01:06:41 <a3f> ah ok
01:06:52 <mauke> I don't understand how fix looks like id
01:08:28 <a3f> they both make me wonder why the hek they exist, if i want to know x why should i write id x and if i want x out of f x why not pattern match against it ?
01:08:35 <a3f> If that spound stupid, kindly ignore ^^
01:08:59 <mauke> f is a function, not a constructor
01:09:08 <mauke> you can't match against arbitrary expressions
01:09:24 <mauke> like, case 10 of (2 * x) -> x doesn't magically give you 5
01:09:44 <mauke> also, you don't have f x to match against in the first place
01:09:47 <mauke> you only have f
01:09:59 <a3f> Ah, I understand
01:10:02 <mauke> :t fix
01:10:03 <lambdabot> (a -> a) -> a
01:10:33 <mauke> > fix (\z -> "a" : z)
01:10:35 <lambdabot>   ["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a...
01:11:17 <a3f> :t Graphics.Win32.findWindow
01:11:18 <lambdabot> Couldn't find qualified module.
01:11:26 <a3f> oh
01:12:09 <a3f> well the type is   :: String -> String -> IO (Maybe Graphics.Win32.GDI.Types.HWND)
01:12:25 <a3f> how do I supply a Null instead of a String ?
01:12:33 <mauke> you don't
01:13:10 <a3f> But what if the first argument needs to be Null ? [] doesn't work
01:13:17 <mauke> no
01:13:27 <a3f> yes?
01:13:32 <mauke> no
01:13:36 <a3f> yes? :(
01:18:40 <ashnur> no
01:18:53 <ashnur> lol.
01:19:18 <ashnur> had to continute the pattern :-S
01:19:52 <a3f> > cycle ["no", "yes?"]
01:19:53 <lambdabot>   ["no","yes?","no","yes?","no","yes?","no","yes?","no","yes?","no","yes?","n...
01:20:08 <a3f> a serious answer would be appreciated though :)
01:23:49 <ReinH> oh hai
01:24:02 <a3f> ello
01:24:56 <ReinH> a3f: relevant: http://stackoverflow.com/questions/4787421/how-do-i-use-fix-and-how-does-it-work
01:25:24 <mauke> > fix fail
01:25:25 <lambdabot>   ""
01:25:40 <a3f> ReinH: CHECKING IT OUT, THANKS
01:25:47 <a3f> ReinH: sorry caps :<
01:25:53 <ReinH> a3f: YOU DO THAT :)
01:25:59 <a3f> ReinH: YOU BET I WILL
01:27:03 <mauke> Tʜᴇʀᴇ's ɴᴏ ɴᴇᴇᴅ ᴛᴏ ʙᴇ ᴜᴘsᴇᴛ
01:27:10 <ReinH> heh
01:29:37 <a3f> The second answer there explained it quite good :)
01:31:09 <a3f> ReinH: If you could take the courtesy of telling me how to "cast" Null to a String, that would be truely awesome :3
01:31:25 <ReinH> a3f: what is Null and how do you want to "cast" it to a String?
01:31:50 <mauke> a3f: are you still repeating this bullshit?
01:31:55 <a3f> hey
01:31:56 <mauke> the answer won't change
01:32:05 <a3f> the function is designed to accept two arguments
01:32:09 <a3f> either Null, String
01:32:11 <mauke> no
01:32:12 <a3f> or String, Null
01:32:15 <mauke> it accepts String
01:32:15 <ReinH> what is Null?
01:32:21 <a3f> nullPtr
01:33:07 <a3f> findWindow gets you the HWND for a process when you supply the classname as first argument and NULL as second one OR windowtitle as second argument and NULL as first one
01:33:14 <mauke> no
01:33:18 <a3f> -.-
01:33:19 <mauke> findWindow takes a String
01:33:34 <mauke> (well, two Strings)
01:33:46 <a3f> but the function only takes *one* string and the other parameter shall be empty!
01:33:56 <mauke> no such thing
01:34:00 <ReinH> where is findWindow?
01:34:13 <a3f> sec
01:34:16 <mauke> http://hackage.haskell.org/packages/archive/Win32/2.2.2.0/doc/html/src/Graphics-Win32-Window.html#findWindow
01:34:30 <a3f> ye that's it
01:34:31 <ReinH> Win32. It had to be Win32.
01:35:00 <a3f> mauke: tell me how you would do it
01:35:05 <mauke> do what?
01:35:17 <a3f> findWindowW(L"TibiaClient", NULL);
01:35:22 <a3f> haskell-ify this please
01:35:23 <mauke> I have no idea what that is
01:35:43 <a3f> meh :/
01:36:07 <a3f> ReinH: What do you think ?
01:36:08 <mauke> all I know is that you've been trying to call a haskell function with a value that doesn't match the type of its argument, repeatedly
01:36:10 <mauke> and that's impossible
01:36:44 <a3f> I know, I rewrote the FFI binding (if that's the correct term) and used nullPtr directly
01:36:49 <ReinH> a3f: I think findWindow is a function that expects two String arguments. Or, alternatively, a function that accepts one String and provides a function that accepts another String.
01:37:03 <ReinH> I don't think it accepts Null.
01:37:07 <mauke> you could also provide an interface that takes Maybe String
01:37:13 <a3f> but findWindow cant be used without one value being nullPtr
01:37:35 <a3f> I am doing something similar, I just wondered why they bothered to implement it when it can't work
01:37:37 <ReinH> that's funny, because it definitely can't be used with either value not being a String.
01:37:47 <a3f> or are these things automatically created from headers?
01:37:58 <mauke> a3f: probably because no one uses win32
01:38:05 <mauke> you could report it as a bug
01:38:29 <saep> maybe the empty string works as a "NULL"
01:38:36 <ReinH> https://github.com/haskell/win32/issues
01:38:38 <a3f> it doesn't tried it out
01:38:38 <applicative> bos is listed as the maintainer
01:38:54 <a3f> It seems to search for a window which has no title ""
01:39:00 <mauke> https://github.com/haskell/win32
01:39:30 <a3f> I will make tickets when I am done, I am writing a DLL injector atm in Haskell as practice for FFI
01:39:44 <a3f> I am sure there will be more things like that, no one likes winapi :(
01:39:48 <Jeanne-Kamikaze> how are you injecting ?
01:40:15 <ReinH> a3f: why would you chose win32 for FFI? o_O
01:40:17 <ReinH> *choose
01:40:51 <a3f> Biggest customer base for MMO bots
01:41:14 <a3f> Jeanne-Kamikaze: http://injector.googlecode.com
01:41:33 <a3f> I am trying to replicate that in Haskell
01:41:40 <a3f> just without the random crashes
01:42:38 <a3f> Still much to do, Ptr's in Haskell are really really mean :(
01:42:49 <Jeanne-Kamikaze> are you gonna upload your code somewhere ?
01:43:13 <a3f> github.com/a3f/clinject
01:43:36 <a3f> you can watch it, I will be uploading it tomorrow or the day after when it's working fully
01:44:10 <Jeanne-Kamikaze> cool
01:46:17 <hpaste> chexxor pasted “Choosing Function Implementation by Type Class” at http://lpaste.net/92966
01:47:27 <chexxor> I'm learning Type Classes now. Can anyone tell me if any part of my notes is completely wrong?
01:50:46 <chrisdotcode> @undo "do { id <- addId idz; foo (biz baz);}"
01:50:46 <lambdabot> "do { id <- addId idz; foo (biz baz);}"
01:52:11 <FreeFull> chexxor: The process is exacty the same as what you get when you do  id 3.0
01:52:36 <chexxor> FreeFull: I'm not familiar with that, heh.
01:52:42 <supki> @undo do { id <- addId idz; foo (biz baz);}
01:52:42 <lambdabot> addId idz >>= \ id -> foo (biz baz)
01:53:03 <FreeFull> chexxor: First argument to the function is a double, so from that point all occurences of a get replaced with Double
01:53:23 <FreeFull> Including the a in  (Num a). Since there is a Double instance for Num, it works
01:54:05 <FreeFull> @do addId idz >>= \ id -> foo (biz baz)
01:54:05 <lambdabot> do { id <- addId idz; foo (biz baz)}
01:54:26 <chexxor> so, instance Num Double where (+) = blah
01:54:40 <chexxor> and instance Num Integer where (+) = blah
01:54:54 <chexxor> when I see Num, I should think of a list like that?
01:55:01 <chexxor> a tree, rather
01:55:07 <mauke> what tree?
01:55:49 <chexxor> Num > Double | Num -> (+)
01:56:06 <mauke> ?
01:57:02 <chexxor> I'm trying to build a mental model of type classes
01:57:24 <mauke> a type class has a list of methods
01:57:32 <chexxor> I think I understand it, just wanted to come here and check
01:58:21 <ReinH> chexxor: a type class contains a list of methods. Instances implement those methods.
01:58:39 <ReinH> the correct implementation for, say, (+) is determined by the type(s) of the argument(s)
01:59:03 <chexxor> ok
02:00:05 <chexxor> that'll do for now. Thanks! ^_^
02:38:11 * hackagebot LogicGrowsOnTrees 1.0.0 - a distributed (parallel) implementation of logic programming via dynamically generated trees  http://hackage.haskell.org/package/LogicGrowsOnTrees-1.0.0 (GregoryCrosswhite)
02:43:11 * hackagebot LogicGrowsOnTrees-processes 1.0.0 - an adapter for the LogicGrowsOnTrees package that uses multiple processes for parallelism  http://hackage.haskell.org/package/LogicGrowsOnTrees-processes-1.0.0 (GregoryCrosswhite)
02:43:13 * hackagebot LogicGrowsOnTrees-network 1.0.0 - a adapter for the LogicGrowsOnTrees package that uses multiple processes running in a network  http://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0 (GregoryCrosswhite)
03:00:57 <AfC> Whoa. That's a monster.
03:04:16 <Ghoul_> does anyone know how to use ImplicitParams with a default value?
03:04:42 <Ghoul_> It'd be handy feature to have *optional* parameters passed via implicit params
03:07:10 <supki> why not use reflection instead?
03:07:19 <supki> (Default a, Reifies s a) => ...
03:07:37 <Ghoul_> never seen those, I'll have to read up
03:07:53 <Ghoul_> implicit params seemed like the perfect kind of concept to override soem but not others though
03:18:46 <PatientZero> Hi all - I am teaching myself Haskell - wondering if this is the best place to ask questions about some code I am trying to write...
03:19:09 <Iceland_jack> PatientZero: Sure, this is a good place to ask!
03:19:38 <Sculptor_> it's not like there are many other places you can ask
03:19:47 <Iceland_jack> You can paste code here: http://lpaste.net/new/haskell
03:19:57 <PatientZero> ahh thanks that was my next question
03:20:33 <Iceland_jack> :)
03:20:33 <hpaste> PatientZero pasted “Removing use of recursion” at http://lpaste.net/92967
03:20:54 <donri> Ghoul_: you can also pass around a record and provide a default value
03:21:33 <PatientZero> so question is, is there a way of re-writing that code so that it does not have an explicit recursive loop
03:21:40 <PatientZero> some sort of fold
03:21:55 <PatientZero> or maybe using foldM in some way would work better...
03:21:56 <Ghoul_> donri: that requires some work by the user though
03:22:13 <Ghoul_> I looked at Data.Reflection and couldn't find any examples that didn't look like just adding more lambdas
03:22:34 <donri> Ghoul_: they only need to do ?x = def or something (haven't really used implicit params)
03:23:05 <Ghoul_> Yeah, I know how they work normally, but I had a really cool idea that could be done by shadowing parameters in reverse but I haven't figured it out yet
03:23:11 <Iceland_jack> PatientZero: So basically you have a list of functions and you apply them to a single value
03:23:12 * hackagebot LogicGrowsOnTrees 1.0.0.0.1 - a parallel implementation of logic programming using distributed tree exploration  http://hackage.haskell.org/package/LogicGrowsOnTrees-1.0.0.0.1 (GregoryCrosswhite)
03:23:20 <Ghoul_> consider a function primes :: [Interger]
03:23:25 <Iceland_jack> Then you want the first element that is not Nothing
03:23:27 <Ghoul_> which uses a wheel sieve
03:23:31 <donri> reflection confuses me too. got any larger examples, supki?
03:23:46 <Ghoul_> I may want to have the function with no arguments, but optionally give them the ability to adjust parameters about the sieve
03:23:52 <PatientZero> Iceland_jack yes that summarizes it well
03:24:05 <Iceland_jack> OK, so for the latter part you can use msum:
03:24:09 <Ghoul_> so the sieve could *somehow* default to 6, and I could do `$ primes where ?wheelSize = 5` or something
03:24:11 <Iceland_jack> > msum [] :: Maybe a
03:24:12 <lambdabot>   Nothing
03:24:16 <PatientZero> as you might guess I am building a parser (I know I could just use a library but there'd be less educational benefit in that)
03:24:25 <Iceland_jack> > msum [Nothing, Nothing, Just 'a', Nothing, Just 'b', Nothing]
03:24:26 <lambdabot>   Just 'a'
03:24:33 <Iceland_jack> > msum [Nothing, Nothing, Nothing, Nothing]
03:24:34 <lambdabot>   Nothing
03:25:04 <PatientZero> ah brilliant!
03:25:09 <Iceland_jack> Applying a list of functions to a single value is easy
03:25:33 <Iceland_jack> possibly the nicest way is using a list comprehension:
03:25:33 <Iceland_jack> > [ fun 5 | fun <- [(+1), (+2), (+3)] ]
03:25:34 <lambdabot>   [6,7,8]
03:25:45 <PatientZero> or just use map I guess
03:25:55 <Iceland_jack> But you can also use map
03:26:11 <Iceland_jack> but that's less clear imo:
03:26:11 <Iceland_jack> > map ($ 5) [(+1), (+2), (+3)]
03:26:12 <lambdabot>   [6,7,8]
03:26:57 <Iceland_jack> PatientZero: But using these two ‘building blocks’, do you reckon you could rewrite your example?
03:27:20 <PatientZero> yes indeed Iceland_jack thank you very much!
03:27:29 <Iceland_jack> :) you're very welcome
03:27:31 <PatientZero> I will post my revised version in a few minutes...
03:28:12 * hackagebot LogicGrowsOnTrees-processes 1.0.0.0.1 - an adapter for LogicGrowsOnTrees that uses multiple processes for parallelism  http://hackage.haskell.org/package/LogicGrowsOnTrees-processes-1.0.0.0.1 (GregoryCrosswhite)
03:28:57 <skypers> hi
03:28:59 <supki> donri: there was that tutorial on school of haskell
03:29:07 <supki> donri: https://www.fpcomplete.com/user/thoughtpolice/using-reflection
03:29:08 <skypers> http://skypers.github.io/portfolio/Portfolio.html#inject-function
03:29:17 <skypers> do you understand the speech I wrote there?
03:29:24 <skypers> or is it wrong?
03:30:50 <Iceland_jack> PatientZero: (If you're not familiar with msum it resides in Control.Monad and also works for lists)
03:31:17 <PatientZero> right - works for anything that has mzero I suppose
03:31:30 <Iceland_jack> Right, anything belonging to MonadPlus
03:31:52 <donri> supki: cool thanks
03:38:12 * hackagebot LogicGrowsOnTrees-network 1.0.0.0.1 - an adapter for LogicGrowsOnTrees that uses multiple processes running in a network  http://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0.0.1 (GregoryCrosswhite)
03:39:47 <PatientZero> Iceland_jack: combine readers s = msum [r s | r <- readers]
03:39:56 <Iceland_jack> Right :)
03:40:06 <PatientZero> sometimes it's just ridiculous how succinct this language can be!
03:42:58 <Iceland_jack> When you have a list of (Maybe a) values you very often want to see if everything succeeded (sequence) or get the first thing that did (msum):
03:42:58 <Iceland_jack> > sequence [Just 1, Just 2, Nothing, Just 3]
03:42:58 <Iceland_jack> > sequence [Just 1, Just 2, Just 3]
03:42:59 <lambdabot>   Nothing
03:42:59 <lambdabot>   can't find file: L.hs
03:43:08 <Iceland_jack> So it's good to keep those in mind
03:44:12 <veggies12> http://lpaste.net/92969 - is this a known thing? I was not expecting -prof to induce a stack overflow
03:44:14 <Iceland_jack> You can also find more general versions of those in Data.Traversable.sequence and Data.Foldable.msum
03:55:31 <PatientZero> Thanks again Iceland: what I missed here is the opportunity that the laziness provided: I didn't think of applying each of the readers first and then picking the first one that worked because in a "strict" language this would be "inefficient"... but of course for lazy evaluation it doesn't *actually* apply the others
03:57:57 <Iceland_jack> Yes :) the most useful part is being able to decompose your problem into smaller components, then it's just a matter of memorization to know how to accomplish those smaller components
03:58:17 * hackagebot LogicGrowsOnTrees-MPI 1.0.0 - an adapter for LogicGrowsOnTrees that uses MPI  http://hackage.haskell.org/package/LogicGrowsOnTrees-MPI-1.0.0 (GregoryCrosswhite)
03:58:37 <Iceland_jack> You could've also rewritten it using a fold but it wouldn't look very clear in my opinion
03:59:27 <magneticduck> http://paste.org/67327
03:59:32 <magneticduck> trying to install the synthesizer package
03:59:48 <magneticduck> I haven't installed packages via cabal in a while
04:00:10 <magneticduck> so something might be escaping me. I tried "cabal install synthesizer" and "sudo install synthesizer"
04:00:21 <magneticduck> the package list is updated
04:01:52 <magneticduck> (I tried to use hpaste.org to paste it but the server doesn't seem to respond..?)
04:02:30 <donri> magneticduck: cabal update?
04:02:51 <magneticduck> yeah
04:02:55 <magneticduck> I updated the package list
04:05:02 <magneticduck> also, what package do you guys reccomend for the eventual goal of electronic music production / synth?
04:05:07 <magneticduck> synthesizer sure giv3
04:05:22 <magneticduck> gives me all the control I want, but maybe there's something out there.. simpler to use? x|
04:06:27 <magneticduck> it's very well documented too, but it's a huge library and will probably take a bit of work to learn to use properly
04:07:33 <magneticduck> I want power to do things like additive, subtractive, and FM synth
04:08:38 <magneticduck> but I'd also like something that's not too complicated / technical / centered around speed
04:08:43 <magneticduck> I'm going to be doing offline processing anyway
04:08:57 <magneticduck> and as for experimenting with sounds, I'm probably going to use some GUI synth
04:09:14 <magneticduck> non-real-time I mean
04:09:29 <magneticduck> anybody figured out my error yet? :<
04:09:47 <magneticduck> I'll just go ahead and try to install the .tar manually from hackage I guess, see if that changes anything
04:20:45 <kuribas> Anyone uses haskell-indentation for emacs?
04:20:51 <kuribas> Is there something you would want to change in it?
04:23:52 <kuribas> I want to change some settings that I am not so happy with.
04:24:07 <kuribas> some defaults I mean.
04:24:40 <chrisdone> haskell-indentation suuuuucks =)
04:25:57 <kuribas> chrisdone: In what way?
04:26:40 <t4nk830> hello
04:27:37 <t4nk830> can i use some logic in case expressions, like http://lpaste.net/92970?
04:28:04 <donri> t4nk830: what are you expecting it to do?
04:28:51 <Iceland_jack> t4nk830: Do you want to be able to apply ‘f’ to the value?
04:29:04 <Iceland_jack> something like: case f x of .. -> ..?
04:29:26 <t4nk830> donri: for example, http://lpaste.net/92971
04:29:34 <kuribas> chrisdone: I mean, what didn't you like, and how would you change it?
04:29:52 <kuribas> t4nk830: You mean guards?
04:29:58 <t4nk830> Iceland_jack: not exactly
04:30:06 <kuribas> case f x of a | a == 1 -> True ...
04:30:10 <donri> t4nk830: still not obvious what you mean :) but you might be looking for pattern guards or view patterns
04:30:14 <Iceland_jack> Maybe t4nk830 is thinking of view patterns
04:30:24 <Iceland_jack> Frankly I'm not sure what they want
04:30:39 <t4nk830> kuribas: i want to apply a function in pattern
04:30:47 <t4nk830> not in case
04:30:54 <Iceland_jack> t4nk830: View Patterns.
04:31:29 <donri> t4nk830: that alone doesn't quite make sense. what do you want to pattern match on? what are you expecting in your length example?
04:31:32 <kuribas> t4nk830: What would the meaning of that be?
04:31:32 <Iceland_jack> Prelude> :set -XViewPatterns
04:31:33 <Iceland_jack> Prelude> case "hello" of (length -> 5) -> "it's 5 characters long!"
04:31:33 <Iceland_jack> "it's 5 characters long!"
04:31:35 <t4nk830> Iceland_jack: let me google for that...
04:31:53 <donri> t4nk830: that looks like an n+k pattern, which are sort of frowned upon and superseded by view patterns
04:32:33 <Iceland_jack> t4nk830: View patterns allow you to run arbitrary functions on a pattern before pattern matching
04:32:35 <FreeFull> > case "hello" of (length -> 5) -> "does lambdabot support view patterns?"
04:32:36 <lambdabot>   "does lambdabot support view patterns?"
04:32:38 <donri> t4nk830: do you want to match when x is one less than length?
04:32:43 <FreeFull> Seems it does
04:33:17 <t4nk830> kuribas: actually i want http://lpaste.net/92972, where h is defined in where, but ghc says Parse error in pattern: h - 1
04:34:05 <Iceland_jack> t4nk830: That's pretty much n+k patterns
04:34:42 <donri> t4nk830: h | h-1 == l -> -- you can do this with a normal guard
04:38:58 <donri> t4nk830: here's an overview of the extension options if you prefer https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/pattern-and-guard-extensions
04:39:33 <t4nk830> donri: thanks, reading that
04:48:20 <bennofs> How does cabal install know which dist directory to use when I'm using sandboxes?
04:48:39 <mangaba_leitosa> Hi All. Anyone compiled Fudgets with ghc 7.x? I'm looking for build instructions.
04:48:53 <_sebastian_> Hi all, is there a reason, that UArray doesn't support strict tuples as elements?
04:49:39 <bennofs> I have 2 dist/dist-sandbox-* directories: dist-sandbox-c242055c and dist-sandbox-cb3efd6
04:51:48 <t4nk830> the problem that i have two cases, and seems like i do some syntax mistakes. Full function code : http://lpaste.net/92973
04:52:13 <t4nk830> tried both view patterns and guards, got syntax errors
04:52:46 <Iceland_jack> t4nk830: why not do (case (h, l) of ...) ?
04:53:19 * hackagebot hackport 0.3.4 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.4 (SergeiTrofimovich)
04:53:26 <Iceland_jack> * (case (x, length xs) of ...)
04:53:46 <t4nk830> Iceland_jack: mm, it's a good idea
04:56:01 <exFalso> Hi, i'm trying to profile a code, in particular i'm trying to use retainer heap profiling (http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/prof-heap.html#retainer-prof), however when run with +RTS -hr i simply get "invalid heap profile option: -hr". Is there a specific flag i need to pass to ghc to enable this feature?
04:57:50 <t4nk830> Iceland_jack: did you mean that : http://lpaste.net/92974? But again i can't use function in left-side of case
04:58:29 <t4nk830> Iceland_jack: seems like Haskell tries to take h-1 as a function, not an expression
04:59:09 <tharper_> Iceland_jack: Íslendingur?
04:59:30 <Iceland_jack> tharper_: Yes
04:59:42 <tharper_> spennandi
04:59:48 <tharper_> there are too few Haskellers on Iceland :D
05:00:09 <Iceland_jack> Most of the Icelandic Haskellers are in Sweden :)
05:00:16 <tharper_> I know
05:00:25 <tharper_> We collect Icelandic developers
05:00:41 <bennofs> @where prof
05:00:41 <lambdabot> I know nothing about prof.
05:01:00 <bennofs> exFalso: Try compiling with -fprof -auto-all
05:01:13 <bennofs> @where stack trace
05:01:13 <lambdabot> I know nothing about stack.
05:02:29 <bennofs> exFalso: Oops, I think it's -prof -fprof-auto actually
05:03:25 <exFalso> bennofs: yes, thank you thats probably it, need to recompile all my libs with profiling first...
05:03:42 <exFalso> btw has anyone figured out an easy way to do that?
05:04:24 <bennofs> exFalso: Are you on linux?
05:05:01 <exFalso> bennofs: yes
05:05:55 <bennofs> exFalso: Try removing ~/.ghc and change library-profiling to True in ~/.cabal/config. Then do cabal install world
05:06:38 <t4nk830> well, rewrote in http://lpaste.net/92976, but it's ugly
05:07:32 <exFalso> bennofs: hah! awesome thanks, this used to be such a pain
05:08:19 * hackagebot language-javascript 0.5.8 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.8 (AlanZimmerman)
05:09:01 <t4nk830> hah, and clever bot advised me correct code :D Even a bot knows Haskell better
05:09:14 <t4nk830> so sad
05:13:05 <gavri> I'm trying to understand how category theory relates to haskell by understanding the very basics of category theory. and from what I understand, category theory came about to understand the connections between different fields of mathematics. does that mean that category theory helps in a sense in formalizing "analogies" between categories? and if so, why is it useful when it comes to haskell? aren't haskell types just a single category that can be handled by set
05:13:15 <gavri> I'm sure that sounds really dumb
05:13:23 <gavri> but I want to summarize my understanding
05:13:37 <gavri> so I can get pointers to what I'm misunderstanding
05:13:44 <gavri> and what to read to understand this better
05:13:57 <gavri> I definitely don't want to read a whole book on category theory though
05:14:08 <Elision> why not :(
05:14:14 <Elision> :p
05:14:40 <gavri> because math is hard lol :P
05:15:07 <gavri> I'm a developer trying to learn haskell
05:15:16 <gavri> I don't want to get lost in math
05:15:38 <Elision> hehe
05:16:08 <Elision> I believe that the idea is that the types in haskell form the objects of a category Hask, and functions between them form the morphisms / arrows
05:16:15 <mm_freak_> are GHC's Sing type literals efficient or should i store value-level representations explicitly?
05:16:42 <Elision> but it's not quite that nice in practice
05:16:55 <gavri> hey, I had to sign back in
05:17:10 <gavri> what did I miss?
05:17:22 <Elision> oops
05:17:24 <Elision> 05:15 < Elision> I believe that the idea is that the types in haskell form the objects of a category Hask, and functions between them form the morphisms / arrows
05:17:27 <Elision> 05:16 < Elision> but it's not quite that nice in practice
05:17:55 <mm_freak_> gavri: think of all the different languages in the world
05:18:06 <mm_freak_> then imagine a universal translator like in star trek
05:18:10 <gavri> does category theory have to be brought up when we're only talking about a single category?
05:18:11 <mm_freak_> category theory is that universal translator
05:18:17 <luite> mm_freak_: String literals? they're stored as utf8 binary data
05:18:26 <mm_freak_> luite: Nat
05:18:52 <mm_freak_> luite: think of a length-indexed binary vector type…  there are two options
05:19:22 <mm_freak_> newtype BinVec :: Nat -> * where BinVec :: Vector Bool -> BinVec n
05:19:33 <mm_freak_> and then use Sing to retrieve the length
05:19:42 <Elision> gavri: but definitions and concepts about general categories can be applied to Hask
05:20:04 <mm_freak_> or:  data BinVec :: Nat -> * where BinVec :: Int -> Vector Bool -> BinVec n
05:20:12 <mm_freak_> then just use the saved integer
05:20:16 <luite> oh
05:20:36 <mm_freak_> is Sing sufficiently efficient so that i don't need the extra Int?
05:20:44 <luite> hmm dunno that
05:21:08 <luite> check the optimized core :)
05:21:34 <mm_freak_> gavri: yes, category theory consists of a few things:  languages (categories), translators (functors), translators between translators (natural transformations), etc.
05:21:45 <mm_freak_> luite: i'll just benchmark =)
05:21:54 <gavri> aren't the definitions and concepts that are applicable to a single category smaller in scope than the definitions and concepts of set theory?
05:22:27 <Elision> I don't think so... you can say a lot about endofunctors and such
05:22:49 <mm_freak_> gavri: the difference between category theory and set theory is that with the former you can study mathematical objects without paying attention to their intrinsic properties…  for example the elements of a set become unimportant
05:24:02 <bennofs> How does cabal install know which dist directory to use when I'm using sandboxes?
05:24:06 <gavri> I apologize for my terrible Internet access
05:24:34 <mm_freak_> bennofs: the dist directory doesn't change
05:24:37 <bennofs> I currently have two dist directories: dist-sandbox-c242055c and dist-sandbox-cb3efd6e
05:24:44 <bennofs> (inside dist)
05:25:23 <bennofs> Because I cabal add-source'd that package to another package and used cabal sandbox
05:26:56 <gavri> mm_freak_: is it the case that haskell is not related to category theory in a fundamental way and it's just that certain (re latively minor) aspects of category theory are helpful to understanding some parts of haskell?
05:27:39 <gavri> I found it quite difficult to understand the category theory haskell connection because I was expecting to see multiple categories in haskell
05:27:46 <Eduard_Munteanu> gavri: it just happens the type system is strong enough to support a fair bit of CT
05:27:53 <mm_freak_> gavri: again, category theory is a language, and you can formulate haskell concepts in that language…  you don't need to use it
05:28:17 <mm_freak_> gavri: i do that in other languages as well
05:28:26 * hackagebot tidal 0.2.2.7 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.2.7 (AlexMcLean)
05:28:30 <mm_freak_> gavri: i do that in other languages as well
05:29:19 <Elision> you can also talk about stuff other than Hask itself
05:29:59 <gavri> sorry about my Internet disconnects. I've missed quite a bit of this conversation I think. I'll ask again later when I'm on a better connection. sorry about this
05:30:27 <mauke> gavri: see /topic for logs
05:31:11 <gavri> mauke: thanks
05:35:05 <Eduard_Munteanu> You can talk about other categories, if they're Hask-enriched (if you can describe them in terms of Hask types).
05:36:38 <gavri> I'm asking this question simply to understand this better, because I think I've lost quite some time expecting more of the ct-haskell relationship than there seems to be. is it right to say that the parts of category theory that have helped formalize concepts and connections across such diverse fields of math aren't really relevant in that broad sweeping sense with respect to caetgory theory's relationship to haskell?
05:36:52 <gavri> I think I've worded that so vaguely that it probably means nothing :(
05:37:18 <gavri> I think I'll read up more on this
05:37:21 <gavri> thanks everyone
05:37:35 <Eduard_Munteanu> Haskell wasn't really designed with CT in mind, if that's what you mean.
05:37:48 <gavri> I didn't mean that
05:38:28 <gavri> but the connection between CT and haskell that was later discovered, I'm wondering if it related to the core of CT as much as it relates to the core of haskell
05:41:16 <Eduard_Munteanu> Mmm, well, type theory is in many ways a set theory of sorts, so it's not really surprising Hask is much like Set. That would hold for different languages if they had powerful enough type systems.
05:42:37 <Eduard_Munteanu> As far as the powerful enough bit, polymorphism and type functions account for quite a bit of CT.
05:54:08 <_sebastian_> Hi all, is there a reason, that UArray doesn't support strict tuples as elements?
06:08:41 <quinso> Should .cabal/bin be in my $path?
06:08:48 <FreeFull> Is there any implementation of type search in ghci?
06:09:02 <chrisdone> quinso: yeah
06:09:39 <chrisdone> what's the command to run the c preprocessor on a file?
06:10:04 <chrisdone> ah, cpp
06:11:17 <Elision> chrisdone: is that a thing people do? run cpp on haskell files?
06:11:30 <chrisdone> sure. that's what -XCPP does
06:11:42 <FreeFull> Elision: It's useful for FFI
06:11:50 <bennofs> {-# LANGUAGE CPP #-}
06:11:56 <chrisdone> useful for all sorts of business
06:12:00 <Elision> huh!
06:12:20 <Elision> today I learned
06:12:25 <alanz> it plays havoc with refactoring.
06:12:27 <mm_freak_> _sebastian_: no technical reason…  the standard array library is pretty much obsolete
06:12:32 * mangaba_leitosa just found an article (in Russian) describing an experience of a hosting company rewriting it's infrastructure functionality from Python to Haskell to solve performance/scalability issues
06:12:56 <hiptobecubic> mangaba_leitosa, link?
06:12:57 <chrisdone> magneticduck: link?
06:12:59 <mm_freak_> _sebastian_: most array libraries (most notably 'vector' and 'repa') treat arrays of tuples as tuples of arrays
06:13:10 <mangaba_leitosa> hiptobecubic: http://habrahabr.ru/company/selectel/blog/135858/
06:14:05 <mangaba_leitosa> the conclusion is: 'we used to write a lot of code in Python. now we write few code in Haskell' :-)
06:15:11 <_sebastian_> mm_freak_: thanks
06:15:53 <chrisdone> magneticduck: cool article! i translated with google translate =]
06:16:32 <mangaba_leitosa> chrisdone: do you refer to me as magneticduck ? :-)
06:17:11 <chrisdone> mangaba_leitosa: oops, yes =)
06:17:28 <mangaba_leitosa> chrisdone: :-)
06:17:49 <hiptobecubic> yes, interesting article
06:37:08 <magneticduck> chrisdone: whuut
06:37:10 <magneticduck> oh okay
06:37:23 * magneticduck was AFK for a while
06:44:30 <chrisdone> can you add exports to a file with template haskell?
06:44:47 <chrisdone> to a module, i mean
06:46:08 <chrisdone> like if i have a module Main (main) where
06:46:15 <chrisdone> can i add main_potato to the exports with TH?
06:46:55 <luite> hm, don't think so, it's not a declaration
06:49:19 <chrisdone> luite: i'm trying to avoid unsafeCoerce. if i can't add additional exports then i can't do the go = … to go_ref = unsafePerformIO (newIORef …); go = join (readIORef go_ref)
06:49:46 <chrisdone> luite: which means my other alternative is to have one big Map Name Dynamic, but then i can only store functions that are Typeable*, meaning no polymorphic stuff
06:50:56 <luite> ack :(
06:51:02 <luite> chrisdone: what was the goal again?
06:51:03 <chrisdone> yeah, ack :[
06:51:29 <chrisdone> making all IO a or r -> IO a types updatable from within ghci
06:51:54 <luite> ah
06:52:29 <chrisdone> i can do the go → go_ref transformation, but i can't change exports. so there's no way to access the ref to update it later
06:53:44 <chrisdone> so i thought "maybe a global IORef containing all functions in a map", but yeah, it's hard to store generic function values
06:54:24 <chrisdone> unless i just use data Updateable = forall a. Updateable a and then unsafeCoerce to/from it
06:54:50 <luite> it almost sounds easier to do at a lower level :)
06:55:08 <chrisdone> as always =(
06:55:21 <S_J> so is the new pipes-network out now? Shouldnt it be 1.0? it says 0.6.0...
06:55:42 * chrisdone tries unsafeCoerce out
06:56:02 * chrisdone fully expects even matching types will just segfault in ghc…
06:59:22 <chrisdone> well, it didn't segfault. ghci's aggressive defaulting just got rid of the type-class polymorphism
07:01:13 <chrisdone> λ> let ref_print = Mutable (print :: Show a => a -> IO ())
07:01:13 <chrisdone> λ> let print' :: Show a => a -> IO (); print' = (case ref_print of Mutable a -> unsafeCoerce a)
07:01:13 <chrisdone> λ> print' "yo"
07:01:13 <chrisdone> ()
07:01:37 <S_J> Renzo Carbonara
07:01:42 <chrisdone> hmm. is it possible to force it to retain the polymorphism?
07:02:36 * chrisdone tries something else
07:03:21 <S_J> does anyone have a client-server example ofr the new pipe slib?
07:04:05 <rtpg> Is there a decent solution for A/B testing with Yesod?
07:05:54 <chrisdone> rtpg: try #yesod
07:06:22 <bennofs> pipes-network links seem to be broken
07:06:49 <bennofs> (not on beta hackage2)
07:09:48 <kuribas> Is vector foldl' faster than list foldl'?
07:10:42 <kuribas> Or should I unroll my function for the best speed?
07:11:01 <kuribas> (tail recursive with bang patterns)
07:11:54 <a3f> What's the right way to define immutable global "variables" ?
07:12:04 <hpc> global constant
07:12:21 <bennofs> kuribas: test/profile it
07:12:25 <a3f> they aren't compile time constants though
07:12:35 <bennofs> a3f: template haskell
07:12:46 <bennofs> a3f: like $(someGlobalVariable)
07:12:54 <hpc> what, no!
07:12:56 <bennofs> hmm. that won't work.
07:13:20 <a3f> Oh, never touched that. Does it need much setup ?
07:13:21 <chrisdone> x = $(lift x') -- would be a constant
07:13:29 <hpc> a3f: well, suppose you wanted as a global constant, an infinite list of fibonacci numbers
07:13:38 <chrisdone> a3f: do you need an actual compile time constant or just something that's evaluated once at runtime?
07:13:52 <hpc> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
07:13:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:14:04 <hpc> a3f: put "fibs = 0:1:zipWith (+) fibs (tail fibs)" at the top level
07:14:07 <a3f> they are evaluated once at runtime
07:14:14 <hpc> a3f: or more likely, a nicer not one-liner
07:14:18 <hpc> and it will be evaluated as needed
07:14:32 <chrisdone> a3f: then just put myconstant = … as normal
07:14:49 <a3f> hpc: ahm, I didn't asks about fibonacci sequences ?
07:15:03 <hpc> a3f: a specific example of what you need
07:15:17 <hpc> it's just a plain old definition and laziness does the rest
07:15:18 <a3f> aha
07:15:31 <hpc> but if you need a particularly large constant (like a fibs list)
07:15:41 <hpc> then you are likely better off keeping it local and recomputing it sometimes
07:16:00 <hpc> because it's defined at the top-level, it never gets freed from memory or "re-thunked" or whatever
07:16:03 <chrisdone> a3f: names bound in lazy are evaluated once and then the original value is updated
07:16:27 <hpc> so you could be only using it once and then for the rest of your program's lifetime you have gigs and gigs of crap in memory that you don't need
07:17:24 <a3f> I just want it to store some options
07:17:41 <hpc> then you shouldn't have a problem :D
07:17:58 <chrisdone> option1  = "hello"
07:17:58 <chrisdone> option2 = 3 * 43
07:17:58 <chrisdone> etc
07:18:39 <a3f> it's inside a monad so I have to use let right?
07:18:51 <a3f> I was using let before but I seem to have forgot that I must place a in at the end
07:19:11 <chrisdone> if it's in a monad then it's in an expression which isn't global
07:19:27 <chrisdone> but yeah, use let if you're in do-notation
07:19:46 <a3f> So, If I want it to be global scope, how can I do that?
07:19:57 <chrisdone> just write like i wrote in your file
07:20:09 <chrisdone> module Demo where
07:20:09 <chrisdone> name = "chris"
07:20:09 <chrisdone> volume = 11
07:20:17 <a3f> I mean define a global scoped variable form inside the monadic do
07:20:40 <chrisdone> oh, no, you can't introduce new names like that
07:20:45 <a3f> I know it's not best practice, but just curious
07:20:47 <a3f> ah ok
07:23:48 <a3f> what's the correct way to save opcodes?
07:23:59 <a3f> or even better, is there any way to inline asm in haskell :D ?
07:24:22 <luite> inline javascript is possible, that's even better!
07:24:58 <chrisdone> a3f: typically you write some C code and then use that from haskell via the FFI
07:25:43 <a3f> I am coding this project to learn more about haskell, don't want to use C
07:26:09 <chrisdone> but do want to use asm?
07:26:13 <chrisdone> get off my lawn!
07:26:19 <a3f> :(
07:26:24 <chrisdone> =p
07:26:33 <oleo> pffft
07:26:48 <kuribas> How do I install profiling libraries?
07:26:51 <S_J> a3f: what are you doing?
07:27:02 <kuribas> For everything?
07:27:06 <a3f> a DLL injector
07:27:34 <chrisdone> void dance(){ asm("movl %ecx %eax"); return NULL; }
07:27:35 <chrisdone> foreign import ccall "dance" dance :: IO ()
07:27:49 <chrisdone> main = dance
07:28:39 <a3f> hmm
07:28:40 <chrisdone> kuribas: generally, set profiling in your .cabal/config and then install stuff
07:29:01 <kuribas> I already have that, but I still don't get profiling libraries.
07:29:16 <chrisdone> did you --reinstall the packages?
07:29:48 <kuribas> no...
07:29:59 <chrisdone> last time i did it, it was
07:30:01 <chrisdone> library-profiling: True
07:30:16 <bennofs> cabal install --reinstall world
07:30:20 <kuribas> ok, I'll try that.
07:30:48 <a3f> Is Template Haskell something like CPP ?
07:30:49 <kuribas> chrisdone: Btw, I'd like to improve haskell-indentation, so if you have any suggestions...
07:31:07 <chrisdone> kuribas: nah, i don't use indenters
07:31:36 <donri> chrisdone writes haskell as a syntax tree and pretty-prints it ;P
07:32:08 <chrisdone> true dat
07:33:25 <kuribas> I cannot live without indenter...
07:34:17 <chrisdone> i beg to differ =p
07:34:50 <chrisdone> what do you use your tab cycle for?
07:35:20 <kuribas> indenting.
07:35:47 <kuribas> Not having to type many spaces.
07:37:36 <jmcarthur> kuribas: one suggestion: sometimes when i hit enter it will auto indent me, and if i decide i don't want that and hit backspace, it goes all the way to the line before instead of just taking me to the beginning of the line
07:37:53 <kuribas> yes
07:37:55 <jmcarthur> kuribas: i notice this the most with class/instance definitions, but probably happens other times i don't notice, too
07:38:45 <kuribas> It will go to the line if it can find no indentation at the beginning of the line.
07:39:17 <jmcarthur> well, in this case, the beginning of the line is perfectly valid
07:39:20 <enthropy> a3f: kind of
07:39:24 <jmcarthur> just means i'm not defining the body yet
07:39:32 <jmcarthur> or maybe ever
07:39:48 <identity> What is the go to library for plotting some points and drawing some lines and such for visually displaying some math related stuff?
07:39:52 <donri> you could look for a "where". do you ever use "where" in an empty instance?
07:40:11 <jmcarthur> i sometimes stub out the where if i intend to fill it in later
07:40:24 <jmcarthur> but it's still valid haskell that way, even if i leave it blank
07:40:28 <kuribas> If it's valid, can you add it as an issue? https://github.com/haskell/haskell-mode/issues
07:40:46 <jmcarthur> okay
07:41:59 <moosefish> Is there any way to get profiling output on a kill'ed process? I've got some code that apparently enters an infinite loop (allocating gigs of memory suddenly) and was hoping to use the profiler to tell me what it's allocating.
07:44:21 <identity> moosefish: Hmm -- couldn't you limit the heap's size through RTS options making it kill itself eventutally when it reaches a certain limit? That should still output the .prof
07:44:46 <kuribas> bennofs: I have reinstalled world, and I still get no profiling libs.
07:44:48 <moosefish> lemme check again, fairly sure I got an empty .prof
07:46:28 <kuribas> Maybe it uses system-wide libraries which don't have profiling...
07:48:49 <kuribas> I seems the newer version isn't used due to conflicts...
07:48:56 <moosefish> kuribas: Got my doubts, I'm using cabal 1.18 sandboxes, pretty much everything is recompiled with profiling
07:49:27 <moosefish> (is it actually everything? or are there still a few ghc-provided libs even then?)
07:50:26 <bennofs> moosefish: kuribas is trying to install profiling libraries, has nothing to do with your problem :P
07:50:34 <moosefish> whups :)
07:52:47 <kuribas> Is it recommended to bypass distribution provided libraries?
07:52:54 <kuribas> And use cabal instead?
07:53:05 <chrisdone> i do
07:53:20 <chrisdone> except hard stuff like webkit or gtk
07:53:38 <chrisdone> just to install the dependencies for me
07:54:29 <moosefish> kuribas: Depends on what you're trying to do. I've come to use the distro-provided libraries, but develop all my stuff with cabal-dev (I'm just switching to cabal 1.18 sandboxes)
07:55:30 <moosefish> allows me to pick the versions I want, and not corner myself in that situation where i've cabal-installed something, and want to distro-install something that ends up depending on a distro-provided lib I've cabal-installed
07:55:47 <kuribas> yes
08:07:01 <a3f> aren't CInt and DWORD the same ?
08:07:07 <a3f> :t CInt
08:07:08 <lambdabot> Not in scope: data constructor `CInt'
08:07:54 <kuribas> Do I need to library-vanilla to False?
08:09:20 <S_J> So the pipes API changed so now I have to connect and spawn connections witht he ordinary Socket modules?
08:12:05 <donri> S_J: not if you use the Safe api
08:12:18 <applicative> S_J: which pipes module are you thinking of, pipes-concurrencu
08:12:45 <donri> i'm assuming pipes-network
08:13:31 <applicative> yes it took a second there
08:13:37 <donri> also looks like the old stuff without Safe is still/also in network-simple
08:14:41 <donri> hey network-simple is possibly neat, high-level api that lets you control what host you bind with listen
08:15:14 <ill_logic> Hi all, got a question about conduit.
08:15:36 <applicative> pipes to conduit in 2 lines; this is confusing!
08:15:36 <ill_logic> http://hackage.haskell.org/packages/archive/conduit/0.2.2/doc/html/Data-Conduit-Binary.html sourceFile and sinkFile require m to be a ResourceIO
08:16:11 <ill_logic> oh sorry is there another conversation about pipes?  I can wait.
08:16:16 <applicative> right,
08:16:25 <applicative> oh no ill-logic, i just found it amusing
08:16:43 <applicative> we can handle up to 113 conversations at once here
08:16:43 <donri> lol waiting in a channel with 1100+ users
08:16:58 <ill_logic> That's what I thought, from my experience sitting around in here.
08:17:09 <applicative> but what about the ResourceIO class?
08:17:11 <ill_logic> So, I'm a beginner here when it comes to IO
08:17:19 <ill_logic> So if I simply try:
08:17:36 <ill_logic> (sourceFile $ "/tmp/in.dat") C.$$ (sinkFile $  "/tmp/out.dat")
08:18:00 <ill_logic> It complains: No instance for (C.MonadResource IO)
08:18:18 <ill_logic> I happened to see in the conduit-http source that I can use withManager and make it magically work
08:18:19 <donri> ill_logic: ghc-pkg list resourcet
08:18:56 <ill_logic> My question is, why is it that I would need a package from conduit-http to make binary work? I'm assuming that there's a more straightforward way that I don't see.
08:19:22 <ill_logic> donri: /var/lib/ghc/package.conf.d /home/haskell/.ghc/x86_64-linux-7.4.1/package.conf.d    resourcet-0.4.7.1
08:19:28 <donri> oh maybe that isn't the problem in this case, ignore that ghc-pkg thing
08:19:36 <ill_logic> ok
08:20:08 <donri> ill_logic: i don't really know conduit but don't you need something like runResourceT somewhere?
08:20:35 <ill_logic> I see. I'm utterly unfamiliar with transformers.
08:20:40 <ill_logic> So that would explain it probably.
08:21:37 <ill_logic> So should I read http://www.yesodweb.com/blog/2011/12/resourcet to inform myself?
08:22:06 <donri> ill_logic: have you read http://www.yesodweb.com/book/conduits
08:22:10 <applicative> sourceFile $ "/tmp/in.dat") $$ (sinkFile $ "/tmp/out.dat") or the like should work
08:22:23 <applicative> woops what happened to the beginning
08:22:37 <applicative> runResourceT $ blah $$ blip
08:23:05 <ill_logic> donri: No I was looking at a different tutorial, which was pretty good, but this one looks a bit more comprehensive. Thanks.
08:23:06 <applicative> as it stands ill_logic , blah $$ blip is in an undifferentiated monad, subject only the to the constraint that it
08:23:30 <applicative> satisfies all the MonadResourceIO constraints or whatever the class was
08:23:41 * hackagebot deepseq-generics 0.1.1.0 - GHC.Generics-based Control.DeepSeq.rnf implementation  http://hackage.haskell.org/package/deepseq-generics-0.1.1.0 (HerbertValerioRiedel)
08:23:48 <ill_logic> So this could run in something other than IO, is the idea?
08:23:51 <donri> ill_logic: follow the types :) $$ takes a source and a sink and makes a ResourceT, which i imagine you tried to use straight in IO?
08:23:54 <applicative> but runResourceT interprets it as having been ResourceT
08:24:18 <donri> although i'd expect a different type error in that case, hm
08:24:22 <applicative> ill_logic: in some transformed version of IO, it couldn't evade being io at some level - i think, i'm a little rusty
08:24:40 <hiptobecubic> i have read a little on syb after discovering it was the most downloaded package on hackage2 and i have to say, *what the hell* is going on there?
08:24:48 <donri> applicative: something that reads files certainly couldn't sensibly avoid IO no :p
08:24:50 <hiptobecubic> i'm looking at this at the moment: http://expressiveprogramming.com/presentations/syb_talk.html
08:25:16 <donri> hiptobecubic: syb is old shit though
08:25:42 <hiptobecubic> well the papers are ~2005 it looks like, but explain this then? http://beta.hackage.haskell.org/packages/top
08:25:50 <applicative> yea hiptobecubic don't read anything more than 1 month old, you'll just be ignorant
08:25:51 <hiptobecubic> Is it just because so many things depend on it now?
08:26:03 <donri> hiptobecubic: yes, old shit has had time to become popular ;)
08:26:20 * elliott plugs lens for your generic programming needs
08:26:32 <ill_logic> applicative: donri: https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview#basics This is the first thing I tried. I see no reference to Resource in the example in this section.
08:26:51 <ill_logic> But, I do now see that there's the ResourceT in the previous one-liner example of file copying, which is exactly what I'm doing :)
08:26:51 <hiptobecubic> Is lens doing the same work as syb then?
08:27:10 <donri> ill_logic: that doesn't seem to do any file handling though
08:27:11 <luite> there is some overlap, with generic traversals
08:27:12 <hiptobecubic> for example this transformation example, distributing the mult exprs over the additions
08:27:12 <ill_logic> so, what's the difference, how come this sink that's defined in Basics doesn't need the ResourceT
08:27:17 <luite> but it takes the uniplate/biplate route
08:27:27 <ill_logic> donri: stdout doesn't count?
08:27:36 <donri> ill_logic: not really no
08:27:39 <elliott> we have uniplate-ish stuff
08:27:42 <ill_logic> oh, a "Resource" is a file on disk?
08:27:44 <elliott> and it's faster than uniplate :P
08:27:50 <luite> elliott: and buggy :(
08:27:55 <luite> but perhaps the original is too
08:27:55 <ill_logic> ok, I will take that and run with it. thanks!
08:27:55 <elliott> we also have interfaces to Data and stuff
08:27:58 <donri> ill_logic: basically conduit needs resourcet when you need to handle finalization of scarce resources like file handles
08:28:13 <elliott> and GHC generics
08:29:12 <donri> ill_logic: well... ResourceT is a monad transformer that allows registering and releasing finalizers :) that are run at the end or on exception
08:29:25 <benmachine> hiptobecubic: I think syb is prety good and I've used it a fair bit
08:29:43 <benmachine> but these days I think the state of the art has moved beyond it
08:29:46 <elliott> I like syb more now that I know you can express it as gtraverse.
08:29:48 <elliott> plus some ugly stuff.
08:29:53 <elliott> the ugly stuff is the problem.
08:29:59 <ill_logic> Ok. So I guess my other question is, why is conduit-http so complicated? Why can't I just make a source and connect it to a file?
08:30:04 <ill_logic> http://hackage.haskell.org/packages/archive/http-conduit/1.9.5/doc/html/Network-HTTP-Conduit.html#v:http
08:30:24 <Beginner> Hi
08:30:27 <ill_logic> whoops, I meant to link to the page head
08:30:40 <Beginner> can someone help me with a problem?
08:30:41 <ill_logic> there's an example use of http right there
08:30:46 <applicative> ill_logic: you mean, e.g. to make a get request and get a file from it?
08:31:02 <ill_logic> yeah.
08:31:07 <applicative> hi Beginner yes of course
08:31:08 <ill_logic> I can do it with httpSimple of course
08:31:25 <ill_logic> er, simpleHttp
08:31:40 <applicative> ill_logic: main = simpleHttp "http:/..." >>= writeFile "a.html"
08:31:45 <applicative> or the like
08:31:48 <hiptobecubic> How do people write code that does what this example does now, then?
08:31:56 <ill_logic> Right. But that acts totally strictly.
08:31:58 <donri> applicative: but then you're not really using conduit
08:32:04 <applicative> donri: yes i know
08:32:12 <ill_logic> That's what my current code looks like actually.
08:32:15 <kuribas> cabal just doesn't build profiling libs, even if I enabled it in .cabal/config :-(
08:32:18 <applicative> the question was, why is it so complicated
08:32:31 <ill_logic> Well my question was, why is http so complicated.
08:32:46 <applicative> ['ppppp45;;;;;
08:32:58 <applicative> sorry, kitten
08:33:04 <ill_logic> haha
08:33:08 <chrisdone> cthulhu f'tagn
08:33:09 <ill_logic> like, why is'nt there just, sourceHttpGet
08:33:30 <ill_logic> sourceHttpGet "http://google.com" $$ sinkFile "out.dat"
08:33:34 <ill_logic> something like that
08:33:52 <elliott> so it can support keep-alive etc.
08:33:58 <gavri> I'm only the second chapter of the "algebra of programming" book and my mind has already been so many times. I can't believe this book isn't even in print.
08:34:06 <elliott> take a look at simpleHttp.
08:34:07 <gavri> already been blown, I mean
08:34:13 <elliott> http requires more because it's the lower-level API
08:34:38 <applicative> gavri: yes it's awesome
08:35:02 <gavri> applicative: any idea why it isn't more popular? it has one review on amazon
08:35:19 <ill_logic> ok. well, I guess I'll read the yesod post on httpConduit, maybe it'll explain to me how this manager works
08:35:55 <ill_logic> I just want to avoid throwing in code bits until it somehow works. Though I guess that's a nice thing about Haskell, that once it compiles you probably somehow got it right :)
08:36:08 <donri> elliott: but you basically need lazy IO to use simpleHttp
08:36:22 <donri> which seems a bit funny for a conduit package
08:36:40 <gavri> I'm also on the second chapter of sicp (which only has five chapters compared to AOP's ten) and I don't feel like I've learned much
08:37:41 <chrisdone> gavri: it is an introductory text
08:37:56 <gavri> I guess it's way too early to comment on either book, but I was wondering why the AOP book isn't more popular
08:38:26 <gavri> chrisdone: yeah, but it comes highly recommended even for those who have been programming for a while, especially if they haven't done functional programming
08:38:33 <dwcook> How do I tell GHC to compile a program only as far as its Core representation, and then give that to me somehow (either on stdout or as a file)?
08:38:38 <gavri> which I haven't. it's mostly been java/ruby/javascript for me
08:39:13 <HaskellBeginner> Hi
08:39:23 <oleo> hello
08:39:32 <HaskellBeginner> could someone help me with a problem with haskell?
08:39:35 <applicative> of course
08:40:03 <elliott> yes, we said that ten minutes ago too :)
08:40:21 <haasn> HaskellBeginner: don't ask to ask, just ask :)
08:41:02 <applicative> the channel is in fact quite good and reliable at answering the question, whether it can answer a question
08:41:41 <applicative> #haskell, can I hereby ask a question?
08:42:01 <dwcook> applicative, I would say you have clearly demonstrated your question-asking ability
08:42:04 <chrisdone> gavri: sure, it's full of good stuff. mostly it's applying Sussman's own personal take on the world which is "convert this into scheme code in  order to understand it"
08:42:32 <applicative> but HaskellBeginner whats the question?  We are starved for content.
08:42:48 <bennofs> dwcook: ghc-core can display pretty syntax-colored core
08:42:53 <bennofs> @hackage ghc-core
08:42:53 <lambdabot> http://hackage.haskell.org/package/ghc-core
08:42:57 * haasn is desperate to help HaskellBeginner
08:43:02 <haasn> please don't tease us
08:43:12 * applicative feels the same
08:43:13 <Clint> you could just pick an arbitrary problem since it wasn't specified
08:43:14 <Iceland_jack> HaskellBeginner teases us with questions…
08:43:15 <dwcook> bennofs, sweet, thanks.
08:43:24 <Iceland_jack> Tantalizing
08:43:29 <chrisdone> dwcook: ghc -fext-core blah.hs
08:43:30 <haasn> HaskellBeginner: w-would you please.. ask me something?!! *blushes*
08:43:56 <chrisdone> then open blah.hcr in emacs and run M-x ghc-core-mode
08:45:09 <applicative> HaskellBeginner: don't listen to haasn, I'm the one with the really awesome answers ... honest
08:45:14 <chrisdone> the ghc-core package was unreliable for me
08:45:23 <dwcook> chrisdone, I'm actually not that familiar with Emacs, but I suppose that'd be a good thing to check out at some point. Thanks.
08:45:29 <HaskellBeginner> I tried to use guards but the ghc throw a parse error at the guard symbol
08:45:42 <HaskellBeginner> what's the problem with the guards?
08:45:46 <chrisdone> @lpaste your code
08:45:46 <lambdabot> Haskell pastebin: http://lpaste.net/
08:45:53 <bennofs> chrisdone: Is there a function to switch to the file of an import in haskell-mode?
08:46:28 <applicative> HaskellBeginner: if you paste first and ask questions next everything proceeds incredibly quickly
08:46:29 <chrisdone> bennofs: i tend use M-. on the import line. are you using haskell-interactive-mode?
08:46:52 <bennofs> chrisdone: is that go-to-tag?
08:47:01 <Iceland_jack> HaskellBeginner: Was it similar to this?
08:47:01 <Iceland_jack>     blah x | x > 5     = "x is larger than 5"
08:47:01 <Iceland_jack>            | otherwise = "x isn't larger than 5"
08:47:12 <gavri> why doesn't haskell error out when functions are only defined on specific data constructors of a type. is this flexibility that is useful to the programmer? or is it something the haskell compiler just don't do?
08:47:19 <chrisdone> bennofs: in haskell-mode it's haskell-mode-tag-find
08:47:29 <bennofs> chrisdone: right. It works, thanks!
08:47:29 <magneticduck> I've asked this question earlier but nobody with an answer was online-- any reccomendations on good synthesizer libraries in haskell with the goal of generating music?
08:47:30 <applicative> gavri: add -Wall etc
08:47:52 <applicative> gavri: it cant secure actual totality of course, see idris agda and company
08:47:53 <chrisdone> bennofs: cool =]
08:47:57 <magneticduck> http://www.haskell.org/haskellwiki/Synthesizer looks like of complicated, and also doesn't install on my machine
08:48:00 <gavri> applicative: thanks
08:48:06 <magneticduck> for some reasons that nobody has yet to figure out
08:48:24 <HaskellBeginner> @Iceland_jack do you know Learn You a Haskell for Great Good?
08:48:24 <lambdabot> Unknown command, try @list
08:48:35 <Iceland_jack> HaskellBeginner: I do, yes
08:48:45 <magneticduck> and Hommage has... no documentation?
08:48:57 <HaskellBeginner> I tried it with the code example for guard from there too
08:49:08 <HaskellBeginner> but it still throws an error
08:49:16 <haasn> @where hpaste
08:49:17 <lambdabot> http://lpaste.net/new/haskell
08:49:20 <haasn> HaskellBeginner: ^ paste your code here
08:49:21 <Iceland_jack> HaskellBeginner: Can you paste the code and the error?
08:49:29 <applicative> where is the code, i can't see anything HaskellBeginner
08:49:46 <applicative> HaskellBeginner: basically you do well to let us simply replicate the error
08:50:04 <magneticduck> actually it does have documentation but the links to the HTML doesn't show up on the hackage page
08:50:06 <magneticduck> *sigh*
08:52:28 * riley_ loves that #Haskell is so welcoming of questions. 
08:52:47 <Iceland_jack> riley_: It's more ‘demanding’ of questions than welcoming ;)
08:53:03 <magneticduck> and there is literally nothing online about hommage
08:53:24 <magneticduck> unless it has to do with sound
08:53:26 <magneticduck> .....
08:53:35 <magneticduck> is, is there anybody out there who does sound in haskell?
08:53:37 <Iceland_jack> magneticduck: Can't help with something I'm not familiar with
08:53:38 <HaskellBeginner> which Title should I give it?
08:53:41 <magneticduck> no? Nobody? Alright :<
08:53:47 <riley_> Iceland_jack: All the same to me!
08:54:48 <Iceland_jack> HaskellBeginner: ‘Trouble with Guards’? It's up to you and doesn't really matter
08:55:38 <HaskellBeginner> @Iceland_hack should I choose private or public?
08:55:39 <lambdabot> Unknown command, try @list
08:56:24 <HaskellBeginner> @Iceland_Jack should I choose private or public?
08:56:24 <lambdabot> Unknown command, try @list
08:56:27 <magneticduck> making music in haskell sure isn't possible
08:56:32 <magneticduck> but it has such amazing potential
08:56:37 <applicative> HaskellBeginner: don't start sentences with @
08:56:37 <Iceland_jack> You'd want it to be public
08:56:45 <applicative> HaskellBeginner: these are commands to a bot
08:56:45 <HaskellBeginner> ok
08:56:52 <HaskellBeginner> oh ok
08:57:00 <hpaste> HaskellBeginner pasted “Guard error” at http://lpaste.net/92978
08:57:08 <applicative> perhaps not the ideal choice for that purpose, admittedly, HaskellBeginner
08:57:11 <magneticduck> @faq can haskell?
08:57:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:57:15 <Iceland_jack> Didn't take my Title suggestion.. ;Þ
08:57:28 <Iceland_jack> HaskellBeginner: You need space before the ‘|’
08:57:29 <applicative> bingo
08:57:33 <applicative> you didnt indent
08:57:59 <HaskellBeginner> space | space condition?
08:58:02 <applicative> oh man i feel so relieved now that you showed me yr code HaskellBeginner
08:58:14 <magneticduck> hpaste: the type should be (RealFloat a) => a -> String
08:58:15 <applicative> space |
08:58:15 <Iceland_jack> You don't need space after the guard, but it helps
08:58:25 <Iceland_jack> Also what magneticduck said
08:58:32 <applicative> HaskellBeginner: having said that, make sure it's not tabs
08:58:50 <HaskellBeginner> but spaces before |?
08:58:50 <applicative> tabs are basically an expert device only in haskell
08:58:51 <Iceland_jack> (RealFloat a) is a context, so it must be followed by =>, not a function arrow
08:58:54 <Iceland_jack> HaskellBeginner: Yes.
08:58:54 <applicative> HaskellBeginner:
08:58:59 <HaskellBeginner> ok
08:59:02 <HaskellBeginner> thanks
08:59:11 <applicative> yes when you return to the left margin you are beginning a new definition
08:59:25 <applicative> It thinks you are defining | which it thinks cant be done
08:59:46 <HaskellBeginner> oh ok
08:59:59 <HaskellBeginner> I'm new in Haskell
09:00:01 <magneticduck> also remove some of the sassiness, ghc might not take it well
09:00:36 <Iceland_jack> LYAH would do well to tone dowh the sassiness at times
09:00:37 <applicative> HaskellBeginner: I sensed that somehow, something about your name maybe
09:00:40 <Iceland_jack> *down
09:00:42 <magneticduck> GuardsExample:10:30: WHO'RE YOU TALKIN TA?
09:00:49 <magneticduck> Failed, GHC refuses to compile sassy code
09:01:28 <magneticduck> GHC has had it with this sassy programmer!
09:02:22 <magneticduck> I was starting to make a kind of synthesizer using the sox utility
09:02:32 <haasn> why RealFloat? ahh.. he left
09:02:37 <magneticduck> but I quickly realized that sox really doesn't have the low-level power I want
09:02:50 <haasn> only needs (Fractional a, Ord a)
09:03:19 <magneticduck> example: there is no way to add the samples of two audio files forming a third
09:03:26 <ill_logic> So, even trying the example in the http-conduit docs, I get this error: http://lpaste.net/92979
09:03:38 <ill_logic> I also tried the example from the http-conduit post on the yesod site
09:04:26 <riley_> I'm on Ubuntu. cabal install is installing happy to ~/.cabal/bin and then can't find the package when I need it later. Is this normal?
09:04:39 <ill_logic> google around it sounded like it might have had something to do with conflicting versions of conduit.
09:04:41 <geekosaur> add ~/.cabal/bin to $PATH
09:04:48 <geekosaur> yes, this is normal
09:04:56 <ill_logic> I ran ghc-pkg check and I found that a broken version of http-conduit was sitting around. I ghc-pkg unregistered it. Still same thing.
09:05:16 <riley_> geekosaur: Perfect. Thanks.
09:05:40 <applicative> ill_logic: that type checks for me
09:05:52 <ill_logic> well damn.
09:06:03 <ill_logic> I guess I have a bad version of something or other-
09:06:03 <magneticduck> rofl
09:06:05 <applicative> ill_logic: what versions of conduit and conduit-http do you have?
09:06:11 <ill_logic> what's the best way to check
09:06:13 <applicative> do 'ghc-pkg list conduit'
09:06:17 <ill_logic> I thought I just upgraded both...
09:06:23 <applicative> i'll do the same
09:06:34 <ill_logic> oh look at that. two versions
09:06:39 <ill_logic> I'll unregister the old one?
09:06:52 <applicative> yes
09:06:53 <ill_logic> or would that be a mistake?
09:07:04 <ill_logic> yes mistake or yes do it? :)
09:07:05 <applicative> ghc-pkg unregister old-conduit-thing
09:07:08 <ill_logic> k
09:07:18 <applicative> ill_logic: there will be some further interaction when it says what breaks
09:07:39 <ill_logic> ghc-pkg: unregistering conduit-1.0.5 would break the following packages: http-conduit-1.9.5 zlib-conduit-1.0.0 blaze-builder-conduit-1.0.0 (use --force to override)
09:07:52 <ill_logic> I unregistered http-conduit-1.9.5 though.
09:07:55 <ill_logic> already
09:07:56 <applicative> right, so explicitly unregister them too
09:08:07 <ill_logic> ok
09:08:16 <applicative> that's not too many things, this is worth it
09:08:26 <magneticduck> just one last time, there is nobody on this channel who has ever done any sound synthesis from inside haskell?
09:08:44 * applicative cant hear magneticduck 
09:09:15 <applicative> ill_logic: then i guess you will have to reinstall http-conduit
09:09:35 <applicative> i wonder what changed though
09:09:43 <ill_logic> what do you mean?
09:10:14 <ill_logic> I was actually wrong about http-conduit, I probably had unregistered another version altogether. I tried unregistering the one listed in this error message and now it's not listed
09:10:20 <applicative> ill_logic: i take it it didn't work with your 'old' http-conduit built with your earlier 'conduit'
09:10:36 <ill_logic> I then unregistered all the other stuff, and the old conduit itself
09:10:46 <ill_logic> now I just have conduit-1.0.7.4
09:10:47 <applicative> don't use --force though
09:10:51 <ill_logic> I did not force.
09:11:03 <applicative> okay, now just do cabal install http-conduit
09:11:10 <ill_logic> So, at this point, do I still want to reinstall something?
09:11:17 <applicative> or maybe 'cabal install http-conduit --dry-run'
09:11:17 <ill_logic> oh
09:11:28 <ill_logic> ok
09:12:01 <ill_logic> ah ok. so it tells me the same versions
09:12:04 <applicative> with the new sandboxing this nonsense can be evaded easily at the cost of more building etc
09:12:16 <ill_logic> so, the idea was
09:12:22 <ill_logic> I had the right version of http-conduit
09:12:28 <zhanrnl> magneticduck: ocharles has done some interesting things with netwire http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
09:12:30 <ill_logic> but it was built against the wrong version of conduit?
09:12:47 <zhanrnl> I don't know if that's what you were looking for?
09:12:48 <applicative> you think your version of http-conduit was the same all along
09:12:52 <magneticduck> are you talking to me?
09:13:02 <applicative> by the way, ill_logic did you do cabal update in there somewhere?
09:13:13 <ill_logic> within the last day I think, yeah
09:13:21 * chrisdone introduces the concept of nick: referencing, a dated but reliable way to reference people on irc
09:13:21 <haasn> magneticduck: he's talking about sound synthesis
09:13:23 <ill_logic> ok she compiles. thank you!
09:13:26 <applicative> oh yeah magneticduck there was a bit of sound in the asteroids demo
09:13:40 <applicative> i don't think it'll be up to your standard
09:13:40 <magneticduck> ah alright
09:13:52 <magneticduck> I was actually checking just now low level ways to generate sound files from a list of samples
09:14:33 <applicative> chrisdone: oh interesting idea.
09:14:39 <magneticduck> oh k, it does sounds in realtime using netwire
09:14:52 <magneticduck> I don't actually even need anything in realtime
09:14:58 <magneticduck> but I'll check it out
09:15:12 <zhanrnl> it looks like it was a bit of an experimental hack though
09:15:34 <magneticduck> yes
09:15:38 <applicative> i don't know if making little explosion sounds once in a while is much of a stress test for 'realtime sound synthesis'
09:16:13 <zhanrnl> you're just trying to do sound synthesis into audio files?
09:18:02 <zhanrnl> maybe take a look at paul hudak's haskell school of music?
09:18:29 <applicative> zhanrnl: oh yes, have you seen the hudak business, magneticduck
09:18:30 <zhanrnl> I haven't read the book all the way through but I think he eventually gets to doing sample-level manipulation in euterpea
09:18:33 <magneticduck> well what I'm trying to do
09:18:48 <zhanrnl> warning, large pdf: http://haskell.cs.yale.edu/wp-content/uploads/2013/04/HSoM1.pdf
09:18:54 <magneticduck> it have a nice simple way to represent sounds with the power of additive, subtractive, and FM symthesis
09:19:04 <magneticduck> not to mention envelopes etc
09:19:22 <magneticduck> and I only need to write it to a file, optimization or time doesn't matter
09:20:01 <magneticduck> what I've already done is I made a litle proof of concept kind of binding to sox, but it doesn't do everything I want it to do
09:20:12 <magneticduck> I will check out hudak
09:21:06 <S_J> network-simple didnt let me give address to the Socket which annoyed me. Im writing a db so i want to have a mainserver-loop that handles connections. I was told this would be easy with pipes-network but i havent got anywhere. I know how to do this using the C socket API but dont get the pipes-interface.
09:21:56 <applicative> magneticduck: maybe the examples in euterpea https://github.com/Euterpea/Euterpea/tree/master/Euterpea/Examples
09:22:08 <applicative> most write .wav files
09:22:37 <applicative> oh god, on the other hand, there is Arrow Notation
09:23:05 <magneticduck> is Euterpeia on hackage?
09:23:11 <magneticduck> Euterpea*
09:23:23 <zhanrnl> what do you have against arrow notation? :P
09:23:24 <magneticduck> no I guess not
09:23:36 <applicative> zhanrnl: nothing, i'm just not an adept
09:24:14 <magneticduck> I will eventually learn arrows
09:24:18 <magneticduck> maybe
09:24:40 <applicative> zhanrnl: its just that my first thought was, these are nice sensible demos anyone can understand, but there was a bit of a sampling error at first
09:25:03 <magneticduck> Euterpea sounds great but I can't really get it can I
09:25:06 <magneticduck> >_>
09:25:12 <magneticduck> oh wait, yes I can
09:25:18 <applicative> what do you mean?
09:25:27 <zhanrnl> umm, http://haskell.cs.yale.edu/euterpea/download/
09:25:33 <magneticduck> yeah I found it
09:26:18 <magneticduck> it's funny when people developing large libraries in haskell advertize them not as a library in haskell but a language embedded in haskell
09:26:55 <zhanrnl> best of luck with it, magneticduck
09:26:59 <magneticduck> thanks
09:27:05 <zhanrnl> you'll probably find arrows are not a terribly difficult concept to understand
09:27:33 <flebron> What's the best way to assign Infinity to a parameter? read "Infinity"?
09:27:57 <magneticduck> I already got stuff like this https://soundcloud.com/magneticduck/testing-1 made using just sox, but there was a lot of synthesis that sox simply didn't support
09:27:58 <applicative> > Infinity
09:28:00 <lambdabot>   Not in scope: data constructor `Infinity'
09:28:08 <magneticduck> > 1/0
09:28:10 <lambdabot>   Infinity
09:28:14 <flebron> Is that "the best"?
09:28:28 <applicative> why do you want to do with Infinity?
09:28:31 <magneticduck> > 1/0 == 2/0
09:28:32 <lambdabot>   True
09:28:45 <magneticduck> I'd reccomend making your own type, Infinity is a bit shady
09:29:01 <magneticduck> I've seen a lot of other people making infinity-supporting types
09:29:35 <elliott> how is it shady?
09:29:39 <elliott> IEEE floats are pretty well-defined
09:29:49 <magneticduck> but they're... foreign
09:30:03 <magneticduck> lol haskell xenophobia
09:30:20 <haasn> > fix succ
09:30:22 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
09:30:25 <haasn> bah
09:30:26 <flebron> applicative: My algorithm is numerical and has a stopping criterion, it can be either number of iterations or predefined in-sample error lower than something. I iterate a function until the in-sample error is, then, smaller than something. The first value of the call then must be the number which is higher than anything.
09:30:27 <magneticduck> what I mean is infinity can't really be read
09:30:27 <haasn> > fix succ :: Nat
09:30:29 <lambdabot>   Not in scope: type constructor or class `Nat'
09:30:33 * haasn cries
09:30:44 <haasn> don't we have any lazy nat type in here?
09:30:47 <flebron> > read "Infinity"
09:30:49 <lambdabot>   *Exception: Prelude.read: no parse
09:30:49 <elliott> we do
09:30:53 <elliott> I think.
09:30:55 <magneticduck> WOAH THIS EUTERPEA LIBRARY IS BIG
09:30:57 <haasn> flebron: that gets defaulted to () either way
09:31:01 <magneticduck> I wonder why it isn't on hackage
09:31:01 <haasn> > read "Infinity" :: Double
09:31:03 <lambdabot>   Infinity
09:31:14 <flebron> Eh, yeah :) Saw that on GHCi.
09:31:34 <magneticduck> never mind then
09:31:42 <magneticduck> > Infinity :: Double
09:31:43 <lambdabot>   Not in scope: data constructor `Infinity'
09:31:47 <magneticduck> alright, no constructor
09:31:53 <magneticduck> but you can read it
09:32:06 <magneticduck> uh, is there a construcotr?
09:32:09 <magneticduck> constructor*
09:32:11 <flebron> But I guess I can rework the structure of the algorithm so that I need not supply the first value of the in-sample error. :)
09:32:12 <magneticduck> > infinity :: Double
09:32:14 <applicative> magneticduck: yeah, i'm building it in a sandbox which would make more sense if i had the haskell platform and wasn't installing opengl nonsense with profiling at the moment
09:32:14 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
09:32:14 <lambdabot>              with actual ty...
09:32:45 <magneticduck> WITH ACTUAL TYPE WHAT LAMBDABOT?
09:32:48 <magneticduck> tell us!
09:32:56 <haasn> elliott: I can't find any
09:33:13 <applicative> @type infinity
09:33:13 <geekosaur> :t infinity
09:33:14 <lambdabot> Natural
09:33:14 <lambdabot> Natural
09:33:20 <chrisdone> yeah that output is so not space-cognizent
09:33:25 <haasn> > fix succ :: Natural
09:33:27 <lambdabot>   *Exception: stack overflow
09:33:27 <applicative> infinity = Succ infinity I guess?
09:33:30 <haasn> > infinity
09:33:31 <chrisdone> all that indentation and newlines are waste of chars
09:33:31 <lambdabot>   *Exception: stack overflow
09:33:34 <haasn> hmm
09:33:35 <elliott> haha
09:33:38 <elliott> > 123 :: Natural
09:33:40 <lambdabot>   123
09:33:42 <elliott> right
09:33:47 <haasn> is that... the strict Natural?
09:33:54 <elliott> I think Show is strict.
09:33:57 <elliott> > gshow infinity
09:33:58 <lambdabot>   Not in scope: `gshow'
09:33:58 <lambdabot>  Perhaps you meant `show' (imported from Prelude)
09:34:00 <elliott> eh.
09:34:03 <elliott> spam.
09:34:15 <haasn> oh
09:34:17 <haasn> Show is strict right
09:34:21 <haasn> of course
09:34:24 <haasn> > 5 < infinity
09:34:26 <lambdabot>   True
09:34:37 <jhormuz> Hey, I just discovered a cool trick....  I've always wanted to be able to trace every call to a function regardless of the pattern matched, but the only way to do it was to put trace in every part.  My realization- you can just put in one dummy pattern at the beginning that looks like this :        f x | trace (show x) $ False = undefined
09:34:47 <chrisdone> > take 10 $ show [1..]
09:34:49 <lambdabot>   "[1,2,3,4,5"
09:35:39 <haasn> chrisdone: rather, the instance Show Natural is strict
09:35:47 <haasn> chrisdone: because it shows them in digit form, rather than as Succ (Succ (Succ ...
09:35:52 <chrisdone> ahh,  ok
09:36:13 <skypers> woh
09:36:27 <skypers> I just read some API pages from Sodium and Netwire
09:36:35 <skypers> sounds hard to get into them :(
09:37:32 <skypers> > getLine >>= putStrLn
09:37:34 <lambdabot>   <IO ()>
09:38:51 <chrisdone> > getLine
09:38:52 <lambdabot>   <IO [Char]>
09:38:56 <chrisdone> > (getLine,getLine)
09:38:57 <lambdabot>   (<IO [Char]>,<IO [Char]>)
09:40:18 <magneticduck> Euterpea is interesting
09:40:30 <magneticduck> it's very.. large
09:41:06 <applicative> skypers: have you looked at the demos for them; in the case of netwire maybe ocharles 's asteroids
09:41:27 <applicative> skypers: the poodle-attack in sodium is much more awesome of course
09:43:00 <magneticduck> attack of the sodium poodles?
09:43:02 <magneticduck> woah
09:43:21 <applicative> "Poodle invasion - click the poodles to keep them under control"
09:43:32 <flebron> Can I mix case options and guards? Say, case x of Just y | y > 0 -> 3, Nothing -> 0
09:43:45 <applicative> basically you are invited to pick off falling poodles; i'm telling the RSPCA
09:44:19 <applicative> flebron: what about the Just y's that arent > 0?
09:44:30 <geekosaur> flebron: yes, but you probably want _ as the pattern instead of Nothing unless you want Just (something <= 0) to throw an error
09:44:35 <applicative> but yes, you can mix them
09:44:46 <flebron> I was going to write another line for that with an | otherwise = ...
09:45:00 <magneticduck> I remember hearing about a cool trick in that line a while back
09:45:06 <magneticduck> I forget what it actually was
09:45:16 <applicative> oh another line for the first case, flebron ?
09:45:22 <flebron> Yep!
09:46:37 * flebron will hpaste it when it's done so you can take a look, I think this is the most reasonable solution, but I could well be wrong :))
09:48:23 <benmachine> flebron: what is allowed in case expressions is very similar to what is allowed in function definitions, with the exception of multiple simultaneous pattern-matches (but even then you can just make a tuple)
09:48:50 <magneticduck> http://www.haskell.org/haskellwiki/Music_of_monads
09:48:54 <magneticduck> .... excuse me?
09:48:57 <magneticduck> xl
09:49:41 <benmachine> magneticduck: user page for the person who wrote that is http://www.haskell.org/haskellwiki/User:Ha$kell
09:50:16 <benmachine> seems to be a real person? maybe?
09:50:27 <magneticduck> what the how the what
09:50:29 <elliott> eh. http://www.haskell.org/haskellwiki/Monad is almost as bad.
09:50:37 <elliott> the wiki is pretty sad
09:50:48 <benmachine> elliott: oh wow, that is terrible
09:51:06 <elliott> benmachine: I don't <i>know</i> what you <b><u><i>mean</i></u></b>
09:51:56 <applicative> its irritating, the wiki idea is really kind of a loser in general for most purposes
09:52:11 <benmachine> I don't know what there is that's better
09:52:19 <applicative> yes, quite true
09:52:45 <benmachine> I did once upon a time decide I would Make Haskellwiki Better
09:52:49 <benmachine> but about two articles later I got bored
09:52:49 <Eduard_Munteanu> What's a recommended crypto lib for Haskell?
09:53:12 <magneticduck> rofl www.googletranslator.com
09:53:21 <magneticduck> that domain must sell for billions
09:53:27 <geekosaur> @quote obra
09:53:27 <lambdabot> adept says: i think I need cobrain to understand coeffects
09:53:32 <geekosaur> bah
09:53:36 <geekosaur> @quote .* obra
09:53:37 <lambdabot> No quotes for this person. Sorry.
09:53:45 <geekosaur> figured it was lost :(
09:53:47 * hackagebot lambdabot 4.3.0.1 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-4.3.0.1 (JamesCook)
09:54:29 <magneticduck> lol www.googletranslator.com is a chinese camper site whos primary attraction is a star rating system where chinese people have rated www.google.com as a 3 star site
09:54:41 <skypers> 18:41 < applicative> skypers: the poodle-attack in sodium is much more awesome of course
09:54:44 <skypers> hm
09:54:48 <skypers> so would be the best FRP lib?
09:54:57 <skypers> are they even comparable?
09:54:59 <magneticduck> also you can use a weird search engine whos logo is a dog's paw
09:55:15 <bennofs> What build system choices are there for a multi-language project using C++/Qt and Haskell, where the Haskell is called via the FFI from C++?
09:56:03 <Eduard_Munteanu> bennofs: you can combine build systems
09:56:20 <Eduard_Munteanu> e.g. cmake with cabal for the Haskell bits
09:56:30 <bennofs> But I need to use ghc for the final link#
09:56:47 <bennofs> I haven't figured out yet how to do that with CMake
09:57:55 <bennofs> Also, that combo gets difficult with the stub headers generated by GHC while it compiles the haskell code
09:58:14 <haasn> magneticduck: I think that might be better suited for #haskell-blah
09:59:49 <applicative> skypers: netwire had been making the most noise lately, but now that reactive-banana has its funny has its threepenny thingy maybe it's moved ahead in the frp baseball stats
10:00:24 <applicative> reading: now that reactivebanana has its funny threepenny thingy
10:01:04 <applicative> skypers: but i've secretly heard some real cognoscenti secretly swear allegience to sodium
10:02:00 <applicative> skypers: the important thing, before deciding among frp libraries is to induce a huge fight about the nature our frp in #haskell and other venues
10:02:38 <applicative> i mean, is reactive-banana *really* frp??
10:03:01 <skypers> applicative: I don’t actually get what is FRP up to now
10:03:05 <skypers> still learning the concept
10:03:53 <applicative> skypers: i recommend taking a dogmatic position as soon as possible. it increases the excitement level.
10:04:25 <FreeFull> FRP is the sound of a fart
10:04:56 <applicative> FreeFull: in that case, reactive-banana is definitely valid FRP
10:05:01 <skypers> ahah
10:05:02 <skypers> :)
10:05:11 <skypers> I’m writing an engine
10:05:13 <skypers> 3D one
10:05:23 <skypers> and hm, I’m getting hands on events handling
10:05:27 <skypers> I thought of FRP
10:05:37 <skypers> a friends told me FRP is nice with events handling
10:05:41 <skypers> a friend*
10:05:44 <red_> how do I pattern match in the ghcinterpreter?
10:05:52 <skypers> not sure you can
10:06:08 <red_> it won't let me use let bindings to specify empty list, then some other stuff
10:06:11 <applicative> > let f (Just x) = 1; f Nothing = 2 in f (Just 3)
10:06:13 <lambdabot>   1
10:06:48 <skypers> is it possible to use guards in ghci applicative ?
10:07:08 <applicative> wont you have trouble without the multiline input method?
10:07:13 <red_> > let f [] = []; f (n:ns) = n * f ns
10:07:14 <lambdabot>   not an expression: `let f [] = []; f (n:ns) = n * f ns'
10:07:19 <bennofs> skypers: yes, use :set +m
10:07:32 <red_> > let f [] = []; f (n:ns) = n*2 : f ns
10:07:33 <lambdabot>   not an expression: `let f [] = []; f (n:ns) = n*2 : f ns'
10:07:38 <red_> > let f [] = []; f (n:ns) = n*2 : f ns in f [1,2,3]
10:07:39 <applicative> red_: yes, lambdabot needs a complete expresson
10:07:39 <lambdabot>   [2,4,6]
10:07:57 <applicative> ghci does't of course
10:07:58 <red_> thanks, sorry for flooding
10:08:12 <skypers> red_: I think you can use lambda bot in private sesions :)
10:08:19 <benmachine> applicative: with or without multiline input you need to specify braces and semicolons explicitly
10:08:25 <skypers> just /msg lambdabot > lol
10:08:42 <benmachine> multiline input in ghci is pretty simplistic, just squishes your lines together into one I think
10:08:52 <benmachine> don't quote me on that
10:08:55 <applicative> i need braces in multiline input?
10:08:59 <red_> benmachine: QUOTED
10:08:59 <FreeFull> skypers: https://github.com/pedromartins/cuboid I wonder if this would be useful for reference
10:09:04 <applicative> well, good thing i dont bother
10:09:18 <red_> @quote quote
10:09:19 <lambdabot> kamatsu says: it should be possible to automate HWN: take every ANN topic from haskell-cafe, some of the top-voted haskell reddit submissions, and all remembered quotes from #haskell in the last
10:09:19 <lambdabot> week
10:09:25 <Iceland_jack> yes
10:09:29 <Iceland_jack> wrong channel
10:09:30 <skypers> holy sh*t
10:09:32 <FreeFull> > case [3] of [] -> 'a'; (x:xs) -> 'b'
10:09:33 <lambdabot>   'b'
10:09:44 <skypers> is there a way to ask lambdabot what type something is?
10:09:50 <skypers> :t Int
10:09:51 <lambdabot>     Not in scope: data constructor `Int'
10:09:51 <lambdabot>     Perhaps you meant one of these:
10:09:51 <lambdabot>       `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
10:09:51 <benmachine> red_: nooo :(
10:09:52 <skypers> ok
10:09:52 <red_> :t 3
10:09:53 <lambdabot> Num a => a
10:09:55 <red_> :k Int
10:09:56 <lambdabot> *
10:09:57 <skypers> :t (>>>)
10:09:58 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
10:10:01 <hpaste> flebron pasted “Use of guards with case statements” at http://lpaste.net/92980
10:10:01 <skypers> ah
10:10:06 <skypers> Category
10:10:07 <skypers> :D
10:10:17 <skypers> still another thing I have to get into :D
10:10:19 <skypers> like Arrow
10:10:24 <FreeFull> :t map (+3)
10:10:26 <lambdabot> Num b => [b] -> [b]
10:10:27 <skypers> oh
10:10:30 <skypers> >>> is composition
10:10:34 <applicative> no it allows formatting like in a file, benmachine at least in this case
10:10:39 <skypers> sounds to be
10:10:50 <flebron> applicative: ^-- That is how I used guards in a case statement )
10:10:50 <benmachine> applicative: oh, fair enough
10:10:54 <benmachine> definitely don't quote me then
10:11:14 <benmachine> skypers: yes, although notice that >>> is the other way around from .
10:11:19 <red_> ls
10:11:23 <flebron> The semantics is that I want to stop the iteration if the condition the user specified is now satisfied.
10:11:29 <skypers> benmachine: why people use so general stuff?
10:12:09 <benmachine> skypers: don't look at me, I don't use it :P
10:12:18 <skypers> :D
10:12:20 <skypers> I mean
10:12:22 <skypers> that thing
10:12:24 <skypers> :t (***)
10:12:25 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:12:27 <skypers> gosh
10:12:28 <skypers> :D
10:12:57 <skypers> I can imagine such concepts are useful when writnig generic and general lib
10:13:00 <skypers> but in game
10:13:11 <skypers> which is very specific and needs concrete concept?
10:13:25 <skypers> I have a lot of things to learn about category and arrows…
10:13:30 <skypers> frightens me :D
10:13:36 <Eduard_Munteanu> skypers: 'a' can be a bunch of useful things
10:13:53 <benmachine> skypers: you don't need to learn about categories or arrows in the mathematical sense
10:13:56 <FreeFull> a can be (->), or Kleisli, or something else
10:14:04 <skypers> benmachine: I’d like to actually
10:14:13 <benmachine> skypers: well what are you complaining about then :P
10:14:32 <skypers> yeah so Arrow (->) b c is quite the same as…
10:14:35 <skypers> b -> c
10:14:36 <skypers> ?
10:15:06 <Eduard_Munteanu> skypers: (<<<) is (.) for a = (->), for example
10:15:24 <skypers> yeah
10:15:24 <skypers> ok
10:15:25 <skypers> got it
10:15:36 <skypers> so why not simply use (.)?
10:15:44 <Iceland_jack> skypers: Because (<<<) is more general
10:15:49 <Eduard_Munteanu> For Monad m, a = Kleisli m, you get (<<<) = (<=<).
10:16:02 <skypers> huh
10:16:06 <benmachine> Eduard_Munteanu: modulo tedious newtype wrappers
10:16:11 <skypers> I always thought Kleisli = Monad
10:16:14 <Eduard_Munteanu> Erm, right.
10:16:23 <Eduard_Munteanu> @src Kleisli
10:16:24 <lambdabot> Source not found.
10:16:44 <skypers> so Arrow represents any thing with input and outputs
10:16:46 <skypers> that’s right?
10:16:52 <benmachine> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
10:17:13 <benmachine> skypers: not *any* thing
10:17:33 <benmachine> skypers: it needs to be able to split inputs and pipeline them separately and stuff
10:17:40 <FreeFull> I think Kleisli exists due to the way Haskell resolves instances
10:17:57 <haasn> Arrow represents one possible generalization of functions
10:17:59 <benmachine> FreeFull: Kleisli exists because otherwise you'd have ambiguity
10:18:15 <haasn> you can compose and combine them, and you can lift regular functions to arrows
10:18:18 <haasn> that's pretty much it
10:18:46 <haasn> they're a bit like applicatives
10:18:46 <Eduard_Munteanu> Kleisli m is actually a subcategory of Hask, and it relates to the Kleisli category for a monad.
10:19:16 <skypers> 19:17 < benmachine> skypers: it needs to be able to split inputs and pipeline them separately and stuff
10:19:18 <ParahSail1n> applicative came about after arrow, correct?
10:19:20 <skypers> jesus christ
10:19:22 <skypers> wait a minuet
10:19:24 <skypers> minute
10:19:45 <benmachine> Eduard_Munteanu: Kleisli m is not a subcategory of Hask
10:19:52 <skypers> benmachine: http://hackage.haskell.org/package/inject-function
10:19:57 <benmachine> Eduard_Munteanu: it has different identities and composition
10:19:58 <skypers> does it mean that my package is hm
10:20:04 <skypers> redundant?
10:20:53 <Eduard_Munteanu> benmachine: err, right, my bad. C_M isn't a subcategory of C either.
10:21:28 <benmachine> Eduard_Munteanu: it's equivalent to a subcategory of C^M though!
10:21:42 <benmachine> skypers: I dunno
10:22:01 <benmachine> skypers: I'm not really well-versed in actually using these various things, so I can't say what approach is better or worse or whatever
10:22:18 <benmachine> skypers: your package makes me think of ReaderT rather than arrows per se
10:22:22 <Eduard_Munteanu> benmachine: by C^M you mean the E-M construction right?
10:22:26 <benmachine> Eduard_Munteanu: right
10:22:49 <benmachine> actually some people define C_M as a subcategory of C^M
10:23:06 <Eduard_Munteanu> Ah yeah, makes sense since you have a whole category of such constructions, where C^M is initial and C_M final.
10:23:27 <benmachine> I don't, but it's kind of interesting that you can
10:23:40 <benmachine> Eduard_Munteanu: other way around, I think
10:23:55 <benmachine> Eduard_Munteanu: unless you're thinking of the dual of the category I'm thinking of, I suppose :P
10:24:10 <Eduard_Munteanu> Possibly, I have a lot of things mixed up today :)
10:24:49 * Eduard_Munteanu reminds #haskell there's a ##categorytheory :D
10:25:12 <applicative> yes, when i saw that package it seemed like ReaderT a (Kleisli m b) c or something skypers not that that's a bad type
10:25:50 * chrisdone noms delicious sushi
10:25:53 <applicative> skypers: the real  problem was the complete lack of examples in the haddocked result!
10:26:21 <benmachine> well Kleisli and ReaderT are actually the same thing but with different parameter order
10:26:55 <benmachine> and class instances, I suppose
10:26:57 <applicative> oh do i have the wrong order. I noticed it when it first ran by here
10:28:52 <applicative> newtype InjFun c i m o = InjFun { cfapply :: c -> i -> m o }
10:29:46 <chrisdone> applicative: what's that?
10:30:00 <applicative> skypers ' s type
10:30:01 <benmachine> chrisdone: skypers' package
10:30:27 <applicative> one question is something like, do his functions reduce to familiar ones, I guess
10:30:35 <chrisdone> what's it useful for?
10:31:00 <applicative> well, i was demanding a few examples in the haddocks
10:31:10 <applicative> http://hackage.haskell.org/packages/archive/inject-function/0.2.1.0/doc/html/Control-InjFun.html
10:32:35 <zomg> Hmm, I wonder what would be the haskell-way to deal with sort of components which may have different state in them
10:32:59 <zomg> I certainly could just do data Component = Foo FooState | Bar BarState but that doesn't seem like such a great idea =)
10:33:56 <slickbob> #go-nuts
10:36:01 <applicative> the thing thats out of the ordinary in skypers package is the explode function and similar where the result is a pair of InjFunction thingies
10:38:00 <MitchellSalad> hi, pipes question - I'm trying to make a Consumer that keeps some state about what it's consumed, say, count the number of "foo"s and "bars"
10:38:25 <MitchellSalad> so it seems like the inner monad should be State, but i'm not sure how to get the state out of the whole computation
10:38:34 <MitchellSalad> if the overall return value is ()
10:40:53 <applicative> MitchellSalad: well the simiple answer - or am i in  a muddle -- is that you can't get rid of the state there
10:41:32 <applicative> MitchellSalad: when you attach it to a producer let stdinLn you have to adjust it , then runStateP the whole pipeline?
10:41:39 <applicative> or am i not getting it
10:43:23 <benmachine> applicative: I assumed "get the state out of" meant "retrieve it from"
10:43:39 <benmachine> rather than "cause it to no longer be there"
10:45:38 <applicative> execStateP (0 ::Int) $ myproducer >-> mypipe , for example
10:45:51 <applicative> only myproducer must be lifted to use StateT
10:46:32 <applicative> e.g. execStateP (0 ::Int) $ hoist lift stdinLn >-> myconsumer
10:46:49 <MitchellSalad> oh, so I had it backwards? Use StateT around a consumer, instead of Consumer around a State?
10:47:13 <gowdru> Hi all! What is cabal sandbox?
10:47:23 <applicative> the type will be Consumer String (StateT Int m) ()
10:47:41 <MitchellSalad> alright, im with ya so far
10:47:43 <applicative> gowdru: awesomesauce?
10:47:54 <applicative> MitchellSalad: but I could be misunderstanding
10:48:26 <MitchellSalad> hm, ill try to phrase it differently, say you were trying to count the number of blank lines in a file, for example
10:48:51 <MitchellSalad> so you have a producer of strings, and a consumer of strings which also needs to bump the int count of blank lines when it consumes one
10:49:29 <gowdru> applicative: LOL! I am new to Haskell, I need to work on an existing project. I am excited, but want to know what are some good ways to set up the development environment.
10:50:20 <MitchellSalad> wouldn't I have to use runEffect before execState?
10:50:54 <applicative>  -- :t \consumer -> runEffect $ execStateP (0 ::Int) $ hoist lift P.stdinLn >-> consumer
10:51:05 <edwardk> tibbe++ # reverting hashable!
10:51:42 <applicative> -- is like Consumer String (StateT Int m) () -> m Int
10:52:43 * applicative is suddenly getting baffled about the order of runEffect and execStateP in this case
10:52:44 * gowdru is reading http://coldwa.st/e/blog/2013-07-30-Cabal-sandbox.html
10:52:52 <MitchellSalad> lol
10:53:05 <MitchellSalad> runEffect :: Effect m a -> m a
10:53:16 <MitchellSalad> the m would be StateT Int IO, yeah?
10:53:33 <applicative> if runEffect is applied inside, yes
10:53:39 <MitchellSalad> I'm not even sure what execStateP is
10:53:45 <MitchellSalad> is it in pipes?
10:53:51 <MitchellSalad> hayoo is down
10:53:53 <applicative> Pipes.Lift
10:54:02 <MitchellSalad> thanks
10:54:05 <acomar> anyone know of a good guide on writing user hooks for cabal builds? I can't seem to find one. I'd like to do some stuff just prior to building my package (so I assume I want to write a preBuild hook).
10:56:40 <applicative> MitchellSalad: it's akin to the usual runStateT evalStateT execStateT which is to say it's a trial to remember
10:56:47 <MitchellSalad> right
10:57:00 <MitchellSalad> it's weird that pipes need to supply these
10:57:24 <MitchellSalad> i trust the two sentence justification at the top of the module is correct though :)
10:59:16 <riley_> Anyone know where I can find some tips on how to modify EclipseFP run configurations? I can only get it to start up in interactive mode.
10:59:54 <applicative> MitchellSalad: it's crucial to the simplification of Pipes-4 that one always transforms the monad inside the Pipe , not the Pipe/Producer/Consumer itself
11:00:14 <MitchellSalad> i see
11:00:32 <applicative> whereas before there were pipe transformers, which were in a way conceptually simpler, but a nightmare in almost every other respect
11:02:04 <applicative> now a regular Pipe i o m r is lifted to Pipe i o (StateT whatever m) r with 'hoist lift'
11:02:09 <acomar> riley_: use a different run configuration, just like you would for a java application
11:02:35 <applicative> MitchellSalad: as I did above with stdinLn
11:02:46 <acomar> you probably have an interactive session chosen, if you instead click the drop down next to the run button and click run configurations, you can mess with it there
11:02:56 <applicative> MitchellSalad: to make it agree with the imagined stateful counting Consumer we had
11:04:02 <MitchellSalad> alright, thanks, still trying to wrap my mind around it...
11:04:38 <applicative> its just the usual monad transformer strain, its kind of pleasant once you get the hang of it
11:05:09 <applicative> MitchellSalad: i'm still not sure that this is the 'recommended' way of say return the number of xs from a given producer.
11:05:15 <applicative> but it is ok
11:06:00 <MitchellSalad> right, it was a contrived example, I'm actually trying to do something that truly needs State - removing block comments from a source file
11:06:08 <MitchellSalad> and of course you need to know when you are inside one
11:06:47 <benmachine> MitchellSalad: just saying that in the first place might have aided understanding :P
11:06:49 <applicative> MitchellSalad: ah indeed
11:06:56 <MitchellSalad> lol
11:07:03 <MitchellSalad> sorry
11:07:19 <riley_> acomar: I see the "Haskell application" setting, but the arguments are totally empty. When I run it, it says that no executable is found to launch. And I can't type in any arguments.
11:07:29 <benmachine> MitchellSalad: no need to apologise, it's not like I helped anyway, but I did find myself wondering why you were doing things that way
11:08:01 <applicative> returning the number of foos that are blah will generally operate directly on the producer, the model being
11:08:04 <applicative> fold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Producer a m () -> m b
11:09:13 <tibbe> edwardk: long overdue!
11:09:37 <benmachine> applicative: just out of interest, why not just have the (x -> b) argument as id and fmap other things over it later if you want?
11:10:02 <applicative> in that case?  id is a typical x -> b
11:10:47 <applicative> benmachine: any it fits it to the L'/Foldl model of the various new beatiful folding libraries
11:11:01 <acomar> riley_: you need to create a new configuration for this application. So click haskell application then click new configuration in the bar above it. You can set arguments there.
11:11:22 <benmachine> fair enough
11:11:31 <benmachine> a free-functor sort of construction, I guess
11:11:56 <benmachine> or, no, ignore that
11:12:16 <benmachine> I don't really know if it's properly "free" and I'm not going to spend the effort working it out :P
11:13:14 <applicative> Tekmo absurdly doesn't use his foldl library because of his dependency mania.
11:13:25 <donri> haha
11:13:58 <donri> interestingly he accepted the void dependency without questions
11:14:06 <donri> that means semigroups, nats, containers, hashable, bytestring
11:14:30 <donri> array deepseq
11:14:39 <applicative> i wondered why he did that in the end. i think it was because he knew he could get rid of it
11:14:46 <aristid> a bunch of those come with ghc, so they don't count.
11:15:09 <aristid> platform deps he also considers fine i think
11:15:18 <applicative> oh maybe the plan was to convince edwardk to have a lighter void
11:15:22 <aristid> semigrups, nats, deepseq aren't either iirc
11:15:27 <riley_> acomar: Done, but still got error. "Could not locate the executable for launch." runhaskell would be a great candidate in this case, but I don't know how to specify it. Only the arguments to it. Do I need to make a cabal configuration?
11:15:31 <donri> well they're moving void to base i think?
11:15:33 <applicative> it's all nonsense since it works fine with data X where
11:15:44 <applicative> which he had for a while
11:15:47 <edwardk> if void moves into base, then i just move its instances out to the other packages
11:15:52 <aristid> applicative: we just need a hugetastic Haskell package which contains everything. no more worries about dependencies.
11:15:55 <benmachine> applicative: don't even need the where
11:16:04 <applicative> edwardk: ah, yes, that's the answer
11:16:09 <applicative> benmachine: right, sorry
11:16:14 <donri> edwardk: oh no current plans? i somehow thought i read about such plans...
11:16:15 <moosefish> Ok, I found out why one of my simulations turned into an eternal allocation loop -- Data.Time.Clock.POSIX.getPOSIXTime and System.Random are borked: getPOSIXTime and the RNG always return 0
11:16:19 <edwardk> convincing me to make a lighter foo inevitably comes at the expensive of making other things heavier.
11:16:23 <benmachine> applicative: why is everyone apologising to me today :P
11:16:29 <edwardk> and it requires me to release 40+ packages. so i don't do it lightly
11:16:37 <moosefish> I suspect this was broken by a recent cabal update… but the funny thing is that I'm using sandboxes
11:16:39 <acomar> riley_: yea, you'll need to write out the cabal file for the application. EclipseFP uses cabal run (I think) to run the application
11:16:42 <edwardk> donri: shachaf made some noises to that effect
11:16:47 <applicative> edwardk: just make each line a separate package
11:16:51 <edwardk> but i don't think there was consensus. i could be wrong
11:16:56 <acomar> riley_: I might be wrong on that last bit though
11:16:58 <edwardk> applicative: i don't like orphans.
11:17:01 <benmachine> moosefish: sounds bizarre
11:17:08 <moosefish> benmachine: Yeah, it is
11:17:17 <edwardk> no offense to any orphans in the crowd. ;)
11:17:19 <donri> edwardk: use reflection for all instances ever!
11:17:23 <oleo> lol
11:17:25 <moosefish> benmachine: Right now it's only broken on my FreeBSD 9 box, it works great on CentOS machines. Same code.
11:17:34 <riley_> acomar: That's what I needed. Thanks.
11:17:39 <applicative> edwardk: no, i see the reasoning you applied above
11:17:41 <shachaf> edwardk: What, Void in base?
11:17:44 <acomar> riley_: no problem :)
11:17:48 <edwardk> shachaf: yeah
11:17:50 <applicative> about if void is in base then etc.
11:18:13 <danilo2> Hello! :) If I've got a structure in Haskell (like AST) and I want to assign each of item in this structure a value, than I have to manually set each of the item a unique "id" value? Or is there any other way in Haskell to map objects to values?
11:18:13 <shachaf> edwardk: I think there pretty much was a consensus, I just didn't follow up like I should've.
11:18:13 <edwardk> applicative: last time i inverted a dependency on semigroups it took me 2 days
11:18:32 <moosefish> Any ideas where to start looking? As far as I can tell from a strace/truss output, the kernel is correctly returning correct values at the right place
11:18:34 <edwardk> shachaf: then it sounds like it'll be a 7.10 thing at least
11:18:44 <edwardk> we're getting down to the wire
11:18:44 <moosefish> I'm wondering if linking's using the wrong version of a lib somewhere
11:18:49 * hackagebot maid 2013.9.14 - A simple static web server  http://hackage.haskell.org/package/maid-2013.9.14 (JinjingWang)
11:19:22 <edwardk> applicative: worse, in the end i had people bitching about the heavier dependencies in the other package after
11:19:31 <edwardk> applicative: so i've just decided to grow thicker skin ;)
11:19:38 <applicative> wise
11:20:06 <applicative> but Tekmo's use of Void seems silly to me in any case, I forget the reasoning.
11:20:14 <applicative> it was better when it was called X anyway
11:20:26 <S_J> So, sorry if some one answered before, I can't find it. I need an example for pipes-network because I dont get it. I want a complete client-server example. does anyone have spmething simple.
11:20:36 <edwardk> i feel badly for the folks who want minimal dependencies, but they must realize that what is minimal to any one person is too little or too much for any other person.
11:20:46 <applicative> so i think you should tell him to go away since he isn't a serious user , edwardk
11:20:47 <S_J> a server listening and forking off connections when someone connects
11:21:12 <MitchellSalad> applicative: mind showing me one more time how to connect these with (>->)? http://lpaste.net/92982
11:21:20 <applicative> edwardk: i dimly remember someone complained on the list that X was obscure, Void was clear.
11:21:20 <danilo2> I'll ask the question a bit clearer: I've got a structure in Haskell. Some kind of tree. I would love to create a map from each item in this structure to a value. To create such map have I to create an "id" field in each item, whcih will contain an unique value, or is it possible to create such map other way?
11:21:31 <edwardk> applicative: i personally think the switch to Void is a good idea. =P
11:21:31 <edwardk> sorry if it makes pipes code a bit more verbose
11:21:41 <applicative> you would
11:21:44 <donri> S_J: isn't that just the serve functions?
11:21:48 <edwardk> in general i like to lean towards there being a canonical instance of things that are definitionally unique
11:22:03 <PatientZero> Hi guys - I have some horrible Haskell code (I'm a newbie) that I'd like to simplify
11:22:15 <moosefish> any easy way to check what libraries (and complete version) a haskell binary has been linked with?
11:22:21 <MitchellSalad> PatientZero: put it here http://lpaste.net/
11:22:22 <k0001_> S_J: let me write some example for you. However, `Network.Simple.TCP.serve` (re-exported by `Pipes.Network.TCP`) already does what you want.
11:22:24 <acomar> danilo2: you want a transformation from your tree type to a map?
11:22:30 <edwardk> and then i load it up with all the instances, because i find that a.) i learn things from them, and b.) i find new applications for them later.
11:22:34 <a3f> Hello, I seek thee wisdom. How do I cast a CInt to DWORD ?
11:22:53 <edwardk> minimalist thinking on instances leads to failure to discover things that are obvious when you 'implement all the things'
11:22:58 <applicative> MitchellSalad: hoist lift myProducer >-> myConsumer
11:22:58 <hpaste> PatientZero pasted “Tokenizer” at http://lpaste.net/92983
11:23:05 <MitchellSalad> right, thanks
11:23:21 <BMeph> danilo2: Super-short answer: Make your "structure" an instance of Traversible.
11:23:41 <PatientZero> so as an educational exercise I'm writing a parser
11:23:47 <danilo2> acomar, BMeph: I want to create map from lets say TreeItem to Int.
11:23:49 <PatientZero> so step one is just to write a tokenizer
11:23:49 * hackagebot air-extra 2013.9.15 - air-extra  http://hackage.haskell.org/package/air-extra-2013.9.15 (JinjingWang)
11:23:59 <PatientZero> "readTokens" reads a list of tokens
11:24:07 <PatientZero> and returns also the string that is left over
11:24:11 <danilo2> acomar, BMeph: I want later in O(1) get these ints based on TreeItem
11:24:14 <PatientZero> but it's pretty ugly as you can see
11:24:17 <applicative> MitchellSalad: i think youi might want 'forever myConsumer' so to speak
11:24:19 <S_J> donri: but the Simple functions dont let me set the address of the Socket myself.
11:24:29 <PatientZero> but I'm not sure of the best way to simplify it
11:24:37 <applicative> MitchellSalad: as it is the consumer only reads one incoming String and closes everything
11:25:04 <aristid> edwardk: i seem to recall that you once dreamed of mixins to solve the where-to-put-the-instances problem :D
11:25:22 <edwardk> aristid: it'd be interesting
11:25:22 <applicative> MitchellSalad: or crudely myConsumer = await >> lift (modify (+1)) >> myConsumer
11:25:39 <donri> S_J: isn't that HostPreference? or what do you mean
11:25:40 <edwardk> but with the language we have i'm going to stick to implementing everything i can implement
11:25:46 <danilo2> acomar, BMeph: aaahhh I'm not tlaking about map, but about Data.Map :) a Dictionary! :)
11:25:59 <applicative> MitchellSalad: then you can do e.g. (`runStateT` 0) $ runEffect $ hoist lift myProducer >-> myConsumer
11:26:14 <acomar> danilo2: If you have a foldable instance for your tree (which I think works better than a traversal in this case) then you can just write your transformation as "fold insert empty your_tree"
11:26:31 <S_J> donri: oh is it, last time i asked someone (normally knowledgable) said they didnt know if it could be done
11:26:48 <acomar> danilo2: that will require a hashable instance for you TreeItem type
11:26:56 * BMeph whacks his head against a brick wall, to get back to understanding OO-style terms...
11:27:01 <donri> S_J: i'm no expert :) talk to k0001_; they're the author
11:27:14 <applicative> MitchellSalad: or the more tasteful *Foo>  runEffect $ runStateP 0 $ hoist lift myProducer >-> myConsumer
11:27:24 <acomar> danilo2: (assuming you want a Data.HashMap)
11:27:30 <danilo2> acomar: but it will still give the same key for 2 identikal nodes in tree?
11:27:42 <applicative> MitchellSalad: note that the official State monad of the Pipes package is Control.Monad.Trans.State.Strict
11:27:45 <acomar> danilo2: depends on how you write the Hashable instance
11:28:15 <danilo2> acomar: So If my tree contains several nodes, which are instances of datatype and contain the same values - can they return different hashes?
11:28:36 <danilo2> acomar: I was asing eactly about it: Do I have to provide unique "id" per tree node?
11:28:53 <acomar> danilo2: if they're likely to contain the same data, then yea you'll want something to differentiate them
11:29:16 <acomar> danilo2: but that begs the question... what are you trying to accomplish?
11:29:36 <danilo2> acomar: I want ot differentiate the nodes in tree - they can be empty, but each node should be "different key"
11:29:50 <acomar> danilo2: no, I mean what problem are you trying to solve
11:29:58 <acomar> danilo2: (trying to avoid an XY problem)
11:30:21 <applicative> MitchellSalad: so thus http://lpaste.net/92984
11:30:28 <danilo2> acomar: This is simple :) I've got an AST from a compiler. Than I'm running "compile passes" based on this ast. each pass generates a value or a map (AST token -> value), which consumes other pass
11:30:34 <benmachine> the XY problem is profoundly uninformatively named
11:31:10 <acomar> benmachine: yea, I don't know why or how it earned that name, but that's what it seems to be called.
11:31:39 <danilo2> acomar: Is it clear now?
11:31:48 <benmachine> acomar: I feel like it ought to be possible to come up with something better, but I can't off the top of my head
11:31:49 <acomar> danilo2: yea, I'm thinking :)
11:32:00 <danilo2> acomar: :)
11:32:09 <benmachine> however do continue to solve actual problems instead of terminology ones :P
11:32:17 * benmachine shuts up
11:33:21 <MitchellSalad> applicative: thanks, going through all that now
11:34:01 <k0001_> S_J: Does this help? http://lpaste.net/92986 -- Try running it and connecting to 127.0.0.1:8000 with more than one client at the same time.
11:34:03 <acomar> danilo2: the input to each pass is I assume the map produced by the previous pass, along with the AST?
11:34:15 <MitchellSalad> I almost came after you with a type error until I realized it was just a lazy/strict State problem which you already mentioned
11:34:32 <acomar> danilo2: in which case, I think tagging with a unique id is probably the easiest answer
11:34:45 <danilo2> acomar: there are dfferent passes. Some produce maps (dictionaries), some other only return different tres and a pass can consume more than one map ofc
11:35:11 <acomar> danilo2: right, fair enough
11:35:19 <danilo2> acomar: I was only asking if there is some magical olution, which will be more pure than this one :)
11:36:33 <k0001_> donri: S_J and yeah, you could use `Host "www.yourwebsite.com"` instead or something else if you want to listen in another host. See the constructors for `HostPreference` (thanks donri)
11:36:45 <acomar> danilo2: I mean, the straight-forward way to generate the ids isn't particularly impure... when you produce the tree, generate each item inside a State monad. The id can be as simple as an incremented counter.
11:37:53 <danilo2> aomar: yeah, that is clear to me - I was rather asking about the "architecture" of such solution. (too much imperative languages in the past, in which each object has got id etc, you now ;) )
11:37:57 <danilo2> *know
11:39:07 <a3f> someone knows how to cast get a Word32 value out of a Ptr ?
11:39:16 <a3f> castget*
11:39:18 <acomar> danilo2: I mean, this is kinda the same idea... add an id field to TreeItem, give it a Hashable instance, give your tree a Foldable instance, etc.
11:39:22 <a3f> cast/get**
11:39:58 <acomar> danilo2: it doesn't strike me as particularly different from the OO approach
11:40:23 <acomar> danilo2: I'm not sure what you mean by the architecture of a solution... maybe lpaste some code and we can iterate through it?
11:40:50 <danilo2> acomar: I know, but it requires doing it manually - If I implement a pass I pattenr mactch against some AST Expressions and produce other expressions - so I have to pass these id's by hand, but its ok :)
11:41:23 <jmcarthur> BMeph: that is indeed the most straightforward procedure for understanding OO
11:41:56 <danilo2> acomar: Maybe "architecture" was wrong word to describe "the solution". Wich requieres me to handle these ids manually when pattern matching :)
11:42:39 <jmcarthur> danilo2: could you describe tersely what it is you're trying to accomplish? i skimmed some backlog, but am not quite sure i understand your goal
11:43:21 <jmcarthur> danilo2: i see stuff about assigning IDs to nodes of a tree. are you really wanting to be able to memoize functions over trees?
11:43:35 <jmcarthur> by identity rather than by value
11:43:56 <jmcarthur> or are these IDs meant for something a bit more complex than that?
11:44:17 <danilo2> jmcarthur: I've got a tree (AST) and I'm writing compiler. each compilation pass can output other threes and maps (dictionaries) from each item to some values
11:44:59 <danilo2> jmcarthur: assigning each node in such tree an id is I think the only way to be able to differentiate the nodes
11:45:15 <jmcarthur> for what purpose are you differentiating them?
11:45:21 <danilo2> jmcarthur: of course - my "id" is an identifier (Int or something) , not id function :)
11:46:28 <danilo2> jmcarthur - because they sometimes need to be mapped to different values (based on their parents)
11:46:55 <jmcarthur> what are these mappings? TreeNode->something?
11:47:11 <danilo2> jmcarthur: exactly
11:47:21 <acomar> danilo2: I would try my hardest *not* to pass the ids around manually... they're only read by these Maps, right?
11:47:25 <jmcarthur> notice how that looks like a function? :)
11:47:50 <jmcarthur> memoization may be what you are after. if so, here's some self-promotion:
11:47:55 <jmcarthur> @hackage stable-memo
11:47:55 <lambdabot> http://hackage.haskell.org/package/stable-memo
11:48:20 <danilo2> jmcarthur: Not exactly, because in tree you can have TreeNodes, which are equal, but we would like to map them to different values (based for example on their position in the tree)
11:48:21 <acomar> even better :) thanks jmcarthur
11:48:40 <jmcarthur> danilo2: this is not value memoization, but identity memoization
11:48:52 <jmcarthur> danilo2: it's based on ghc heap identity
11:49:11 <danilo2> acomar: I know what you mean - I can make my functions which will handle the ids and pass them transparently
11:49:31 <danilo2> jmcarthur: Oh! I was looking for something like that!
11:49:37 <jmcarthur> ASTs are precisely what i had in mind when i wrote that library
11:50:31 <danilo2> jmcarthur, so If I've got a tree A{B,B}, than I can (using this library) assign different values to each of B?
11:51:10 <jmcarthur> danilo2: it still doesn't allow you to distinguish two heap objects that have the same value
11:51:28 <jmcarthur> danilo2: rather, it allows you to save results for when you visit the same heap object twice
11:52:17 <jmcarthur> danilo2: if you truly need to be able to distinguish two things with the same value then you really need to make them not actually have the same value (assigns some sort of ID explicitly as has been discussed already)
11:52:21 <danilo2> jmcarthur: ahh, ok, so its like function value caching library
11:52:28 <jmcarthur> sort of
11:52:46 <danilo2> jmcarthur, acomar : ok than you :)
11:52:55 <acomar> danilo2: no problem :)
11:56:52 <hpaste> applicative pasted “WarmFuzzy Pipes” at http://lpaste.net/92987
11:57:45 * applicative has gotten rid of Void, the obnoxious 'Proxy' type and is left with runHugs :: WarmFuzzy m => Hugs X O X O m r -> m r
11:58:31 <gowdru> Noob question. I can't figure out what to do here: cabal: Error: some packages failed to install:Cabal-1.19.0 failed while unpacking the package. The exception was:user error (File in tar archive is not in the expected directory"Cabal-1.19.0")cabal-install-1.19.0 depends on Cabal-1.19.0 which failed to install. I am trying this: http://codepad.org/VtvlCfVq
11:59:26 <applicative> Cabal-1.19 wow
12:00:32 <gowdru> This happens when I try to cabal-dev install from cabal-install directory after running $ cabal-dev add-source ../Cabal which seems to end correctly.
12:00:53 <applicative> gowdru: enter /path/to/cabal/Cabal first
12:01:18 <applicative> it is presupposed by cabal-install
12:01:28 <applicative> i'm not sure why youre going about it this way?
12:01:44 <k0001_> applicative: Hah! So fluffy!
12:01:54 <applicative> if you want to work on the source of Cabal / cabal install, i recommmend simply installing them first, then repeating this with cabal sandbox
12:02:07 <gowdru> applicative: ah, okay, I did that! That went well
12:02:12 <bennofs> Huh? There is Cabal 1.19 already?
12:02:25 <gowdru> I was just mindlessly following this blog post http://coldwa.st/e/blog/2013-07-30-Cabal-sandbox.html :/
12:02:35 <applicative> bennofs: i think the dev version now numbers itself thusly
12:03:04 <applicative> gowdru: yes its wonderful, he's the principal implementer, bless him
12:03:09 <gowdru> applicative: So I still get 1.14.0 when I do cabal --version
12:03:17 <acomar> gowdru: why do you want the version from git...?
12:03:35 <gowdru> I need cabal sandbox
12:03:45 <gowdru> I am on debian wheezy which has 1.14
12:03:47 <applicative> gowdru: because you installed it with your package manager and /usr/local/bin is ahead of your newer one in $path
12:03:50 <acomar> gowdru: that's in cabal-1.18, just do cabal install Cabal cabal-install
12:04:04 <acomar> gowdru: and export the cabal bin dir in your path
12:04:07 <applicative> gowdru: i'm worried about this, what version of ghc do you have
12:04:15 <applicative> gowdru: as acomar says
12:04:28 <gowdru> acomar: Ah, okay! :)
12:04:52 <gowdru> applicative: version 7.4.1
12:04:53 <applicative> gowdru: i'm worried that your ghc is too old to handle this but i could be hallucinating
12:05:21 <acomar> doesn't ghc keep it's own version of cabal around?
12:05:24 <applicative> it might or might not work i can't rememeber.  if so it maybe time to update ghc
12:05:28 <applicative> acomar: yes
12:05:50 <applicative> the going theory is that catastrophe will be rare with getting a new Cabal
12:06:09 <acomar> ok, that about fits my understanding :)
12:07:19 <applicative> can you just delete the Cabal-1.17 library after getting it's cabal-install? or am i hallucinating again
12:07:27 <hpaste> PatientZero revised “Tokenizer”: “How to simplify this?” at http://lpaste.net/92983
12:07:47 <acomar> applicative: I asked the same question when I first installed 1.18... apparently you can?
12:08:02 <acomar> ghc-pkg unregister, etc.
12:08:06 <applicative> yeah
12:08:32 <applicative> often my cabal-install lives on between ghc installations, so i guess its clear
12:08:39 <applicative> or sort of
12:08:56 <PatientZero> I have a feeling that the code fragment I posted could be done a lot more elegantly...I am a Haskell newbie so would appreciate any advice on if that's possible...
12:09:07 <t4nk089> Hello. Can anyone advise, why the hell ghc says "parse error on input `let'" in http://lpaste.net/92989?
12:09:16 <acomar> heh, the only issue I've noticed so far is that EclipseFP is basically unusable, so I can't test it out
12:09:31 <pavonia> PatientZero: looks a lot like takeWhile
12:09:36 <pavonia> :t takeWhile
12:09:37 <lambdabot> (a -> Bool) -> [a] -> [a]
12:09:45 <pavonia> hmm, no
12:09:51 <benmachine> t4nk089: major problem is you don't have an else in your if
12:10:14 <benmachine> t4nk089: you may be interested in "when"
12:10:25 <t4nk089> :t when
12:10:27 <lambdabot> Monad m => Bool -> m () -> m ()
12:10:55 <PatientZero> pavonia: yes - almost. Except that I also want to keep what's left after the take
12:11:05 <pavonia> > span odd [1,3,5, 2,4,6]
12:11:07 <lambdabot>   ([1,3,5],[2,4,6])
12:11:24 <PatientZero> ah I think I know...
12:11:56 <t4nk089> benmachine: when i add else, i get "parse error on input `let'"
12:12:37 <t4nk089> benmachine: added it after "then b"
12:14:41 <pavonia> t4nk089: you also need to return a value in the else branch
12:14:51 <geekosaur> except they're not doing anything with it
12:15:10 <geekosaur> maybe else do but I have no idea what this code is trying to express
12:15:50 <t4nk089> pavonia: so this http://lpaste.net/92990 fails with same problem
12:16:12 <t4nk089> pavonia: seems like i forgot something obvious, but i can't understand, what
12:16:20 <pavonia> else do
12:16:28 <geekosaur> yes, if you;re going to use let like that then it needs to be in a do block
12:16:44 <geekosaur> no, the outer one does not count, you use if-then-else then you are in an expression and need a new do
12:18:52 <t4nk089> geekosaur: y, replaced "do" after "else", and ghc said OK
12:19:01 <t4nk089> geekosaur: thanks =)
12:19:12 <geekosaur> I still don't know if that actually does what you intend though
12:20:59 <hpaste> PatientZero revised “Tokenizer”: “Can this be simpler?” at http://lpaste.net/92983
12:21:28 <pavonia> PatientZero: have you seen my "span" example above?
12:22:00 <pavonia> @src span
12:22:01 <lambdabot> span _ xs@[]                     =  (xs, xs)
12:22:01 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
12:22:01 <lambdabot>                   | otherwise    =  ([],xs)
12:22:26 <PatientZero> ah!
12:22:34 <PatientZero> thanks pavonia!
12:22:40 <PatientZero> so "predicateRead = span"
12:22:49 <pavonia> yup
12:24:42 <PatientZero> ok here's another one that's slightly harder pavonia
12:25:27 <hpaste> PatientZero revised “Tokenizer”: “How to do "readTokens" without recursion?” at http://lpaste.net/92983
12:27:37 <PatientZero> actually one other question - this "@src" thing is very handy  - is there a ghci command that does similar?
12:28:11 <a3f> Sorry to interrupt, How do I do get the address of a Ptr () in Haskell ?
12:30:02 <geekosaur> PatientZero, @src is a small database inside of lambdabot, so no. there are plugins that can give you access to hoogle which can be more generally helpful
12:30:27 <teneen> why is there no built in combinator: (a -> b) -> (a -> m b)?
12:31:42 <augur> anyone besides peaker interested in a structural code editor? :D
12:32:01 <haasn> teneen: fmap pure
12:32:33 <pavonia> PatientZero: If you flip the result arguments of mustRead you can use span again, I think
12:32:54 <pavonia> PatientZero: erm no, forget that :P
12:33:20 <teneen> haasn: I know it's trivially implemented, I'm just wondering why is not made readily available for convenience
12:34:14 <danilo2> jmcarthur: you've told today that your library bases on "ghc heap identity" - can we normally read the "ghc heap identity" in Haskell?
12:34:26 <PatientZero> I expect my "summarize" function could probably be simpler too...
12:34:58 <fosap2> Hi. What can I do against ambiguity? How do i solve "Ambiguous occurrence `print'   It could refer to either `System.IO.UTF8.print' or imported from `Prelude'" ?
12:35:43 <elifrey> fosap2: import modules that stomp on prelude qualified
12:35:46 <monochrom> by saying "Prelude.print" or "System.IO.UTF8.print" depending on which one you want
12:35:59 <jmcarthur> danilo2: no
12:36:11 <jmcarthur> danilo2: the library uses unsafe functions (but provides a pure interface and should be entirely safe to use)
12:36:24 <danilo2> jmcarthur: Ok, thank you :)
12:36:48 <jmcarthur> danilo2: the implementation uses StableNames, which you normally have access to in IO, but i use it with unsafePerformIO
12:37:48 <fosap2> elifrey: That was too easy. Thanks
12:37:53 <PatientZero> anyway thanks for your help pavonia - very much appreciated. I have to log off now.
12:38:05 <pavonia> you're welcome
12:38:20 <danilo2> jmcarthur: thanks for the information :) It is very interesting :)
12:46:26 <acomar> anyone know why my build hooks aren't firing? http://lpaste.net/92995
12:46:38 <acomar> I've never really done this so I'm not sure what I've done wrong
12:58:57 * hackagebot parcom-lib 0.6.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.6.0.0 (TobiasDammers)
13:07:35 <acomar> also, anyone know how I can pass an option to gcc through cabal?
13:08:08 <acomar> I'm working on bindings to a library that absolutely insists that only a C++ compiler can touch its headers...
13:08:28 <acomar> so configure errors out when ghc just calls gcc on the header
13:08:33 <acomar> :/
13:09:59 <skypers> 19:25 < applicative> skypers: the real  problem was the complete lack of examples in the haddocked result!
13:10:05 <skypers> you mean in my package?
13:11:09 <benmachine> acomar: you mean using a .cabal file, or cabal-install?
13:11:14 <skypers> I’ll write some examples but the library is done done yet (I’d like to add a way to flatten things)
13:11:31 <benmachine> acomar: I think cabal files have a cc-options or gcc-options thing, I forget what exactly
13:12:19 <hrefchef> skypers: Flatten, like... This kind of flatten: http://stackoverflow.com/questions/5994051/is-there-a-function-to-flatten-a-nested-list-of-elements ?
13:12:34 <skypers> 19:21 < benmachine> skypers: your package makes me think of ReaderT rather than arrows per se
13:12:46 <skypers> benmachine: no, it’s not ReaderT at all
13:12:59 <benmachine> skypers: hello, why not?
13:13:04 <skypers> hrefchef: yep but for tuples
13:13:09 <acomar> benmachine: I mean .cabal
13:13:29 <skypers> benmachine: well ReaderT represents actions with environment right?
13:13:47 <benmachine> acomar: cc-options
13:13:56 <acomar> benmachine: thanks
13:14:07 <benmachine> acomar: in here somewhere if you need to know more http://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties
13:14:16 <skypers> my package is used to add extra parameter to each function in a composition chain
13:14:26 <benmachine> skypers: that sounds like the reader monad to me
13:14:28 <skypers> in a way you can control ecah function’s behavior after composition
13:14:42 <skypers> benmachine: hm
13:15:01 <skypers> Reader uses a whole environment
13:15:05 <acomar> ack, it's passing it at the end of the options list now
13:15:15 <acomar> so -x cpp winds up having no effect
13:15:16 <skypers> whereas I use a single a value, with sharing and all
13:15:18 <skypers> but hm
13:15:26 <benmachine> skypers: when you unwrap the newtypes from Reader's >=>, you get (a -> r -> b) -> (b -> r -> c) -> (a -> r -> c)
13:15:27 <skypers> maybe it can be done with reader yeah
13:15:40 <benmachine> skypers: what do you mean by environment, anyway
13:15:53 <skypers> well a type shared over all functions?
13:16:06 <acomar> I was trying -pgmc g++ to force it to use g++ over gcc, but that was getting ignored as well
13:16:08 <benmachine> ah, right
13:16:34 <skypers> in my inject-function package, each function has its own value associated
13:16:47 <skypers> if you have several functions composed
13:16:57 <skypers> the resulting c would be a large tuple
13:17:08 <skypers> (and this is the reason why I want flattening!)
13:17:14 <skypers> (or join for tuples)
13:17:14 <benmachine> skypers: I see what you mean
13:17:26 <acomar> I really don't understand why cabal insists on calling gcc instead of using the -pgmc option I'm trying to pass to ghc
13:17:33 <skypers> benmachine: can it be done with Reader ?
13:17:41 <benmachine> skypers: gotta be honest, don't know why you wouldn't just pass the extra parameters to the functions
13:18:06 <skypers> because it would be shared over all functions
13:18:11 <skypers> and for instance
13:18:14 <skypers> if you have
13:18:18 <skypers> a . b . c . d . e
13:18:39 <skypers> if you want to add a special parameter to d but c and e don’t give a fuck about it
13:19:09 <skypers> passing it as a regular parameter to e would be quite annoying wouldn’t it?
13:19:20 <benmachine> skypers: where does the parameter come from?
13:19:32 <skypers> what do you mean?
13:19:38 <benmachine> why not just pass it to d?
13:19:52 <skypers> because it might change
13:20:18 <skypers> if you pass it to d
13:20:18 <benmachine> then pass the different one to d instead?
13:20:24 <skypers> well
13:20:31 <skypers> it would require to recompose all functions
13:20:35 <skypers> here
13:20:42 <skypers> I do my composition stuff
13:20:56 <skypers> and I can change the internal behavior with the “injected” parameters
13:21:01 <skypers> thinking about it
13:21:06 <skypers> it could be done with Reader
13:21:17 <skypers> the Reader would have a megatype
13:21:22 <skypers> gathering all possible values
13:21:40 <benmachine> skypers: do you have specific applications in mind?
13:21:41 <skypers> and each function would read the value they want with asks
13:21:44 <skypers> yeah
13:21:48 <skypers> I’m writing renderers
13:21:51 <skypers> in my engine
13:22:02 <skypers> renderers are blocs composed
13:22:03 <skypers> like
13:22:10 <chrisdone> try a comma
13:22:28 <skypers> the bloc for culling, the bloc for deferred rendering, the one for shading, the one for shadow mapping
13:22:31 <skypers> and so on
13:22:33 <skypers> so I just do
13:22:49 <skypers> renderer = culling |-> defrender |-> …
13:22:59 <skypers> and if I want to modify the way shading is done
13:23:21 <skypers> I just change the value I pass as injected parameters
13:23:58 * hackagebot sqlite-simple 0.4.3.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.3.0 (JanneHellsten)
13:25:04 <benmachine> skypers: but why not just have renderer be a function of that injected parameter?
13:26:37 <acomar> so anyone know how I can get my headers passed to g++ instead of gcc (in cabal configure) OR pass '-x cpp' to gcc as one of the first options?
13:27:02 <acomar> or is this just not possible with cabal?
13:28:03 <a3f> rename gcc to g++ in the include path
13:28:40 <a3f> oh sorry
13:28:44 <skypers> benmachine: because renderers are flexible
13:28:54 <a3f> acomar: rename g++ to gcc, not the other way round
13:29:03 <skypers> the type has to be [a] -> IO ()
13:29:06 <skypers> or something like that
13:29:20 <skypers> and user compose his own renderer the way he wants
13:29:23 <acomar> a3f: that's a very heavy handed option :/
13:29:40 <acomar> a3f: besides, an alias doesn't work because ghc is searching for the gcc executable
13:29:55 <acomar> a3f: so I'd have to mess with /usr/bin/gcc :/
13:30:03 <skypers> benmachine: what’s the purpose of Reader then?
13:30:12 <skypers> we could pass the environment as a parameter as well?
13:30:13 <benmachine> skypers: honestly I don't use Reader much either :P
13:30:24 <skypers> neither do I :D
13:31:02 <monochrom> consider cc-options
13:31:02 <skypers> then
13:31:07 <a3f> acomar: The end justifies the means.
13:31:11 <skypers> maybe my package is already dead
13:31:19 <skypers> since a ReaderT could be do it
13:31:19 <benmachine> monochrom: I already suggested that, but apparently they get added at the end
13:31:36 <skypers> I have to think of that
13:31:36 <monochrom> yikes
13:31:44 <benmachine> skypers: I don't know; if it's useful to you then don't worry about it too much
13:31:46 <acomar> monochrom: yea, the -x lang flag only affects input files that follow
13:32:07 <skypers> benmachine: I don’t know, I’m still experiencing it
13:32:47 <acomar> a3f: I'm hoping to upload this to hackage when I've done
13:33:16 <skypers> another question
13:33:32 <skypers> monads are control stuff
13:33:50 <skypers> applicative functors are control stuff as well
13:34:05 <a3f> acomar: Oh, can't help then :/
13:34:06 <skypers> functors too but… they’re in Data
13:34:08 <skypers> why?
13:34:14 <acomar> a3f: :/ thanks anyway
13:34:15 <haasn> skypers: Control./Data. is bogus
13:34:17 * haasn grumbles
13:34:24 <haasn> skypers: it's arbitrary.
13:34:42 <a3f> acomar: BUT .. you could assemble the C++ files and inline them into a C file which you feed into gcc!
13:35:07 <jmcarthur> i always link this when the topic of arbitrary namespaces comes up: http://www.shirky.com/writings/ontology_overrated.html
13:35:24 <chrisdone> is taht the post saying namespaces are just to stop name conflicts, not a taxonomy?
13:35:29 <skypers> haasn: :(
13:35:30 <skypers> so
13:35:33 <acomar> a3f: at that point, I may as well preprocess those headers and strip out the very stupid "#error on not C++" crap
13:35:48 <chrisdone> similar enough
13:35:49 <skypers> we don’t move Data.Functor into Control.Functor not to break compatibility?
13:36:02 <skypers> it’s kinda weird though
13:36:05 <acomar> gcc damn well knows how to select the language based on the file type, I don't understand the purpose of those error flags at all
13:36:19 <acomar> except to make binding to this library as difficult as possible
13:36:27 <chrisdone> i'd put functor and monad at the top level tbh
13:36:41 <chrisdone> like it was back in'th'day
13:36:46 <jmcarthur> chrisdone: it isn't specifically about namespaces, but about the notion of categorization
13:36:49 <chrisdone> import List; import IO; etc
13:37:19 <haasn> I think I'd like to put Control. and Data. into the top level instead, but I wasn't around during those days and I have no other experience of what the problems that arise are. However, I feel that distinguishing arbitrarily between eg. Data.Lens and Control.Lens is *not* a good solution
13:37:20 <chrisdone> common libraries should take preference over user's modules
13:37:25 <haasn> since it doesn't help you remember which one is which
13:37:27 <jmcarthur> chrisdone: my takeaway is the name of a module is a poor way of making it discoverable
13:37:52 <skypers> chrisdone: top level hm
13:37:59 <skypers> is there any libs in there today?
13:38:01 <jmcarthur> if i had my way, we would just have a better module system
13:38:17 <jmcarthur> e.g. the ability to nest modules and limit the scope of opened modules
13:38:22 <chrisdone> skypers: the ghc-api puts everything in top-level
13:38:43 <a3f> Someone knows how to "cast" CInt to DWORD ?
13:38:46 <jmcarthur> then we could pretend packages are just big modules and open them up only where it matters
13:38:51 <jmcarthur> or somesuch
13:38:52 <a3f> I just can't find a way to do it :/
13:38:53 <skypers> a3f: fromIntegral?
13:39:17 <a3f> skypers: that gives a normal Integer not a Word32
13:39:28 <jmcarthur> a3f: no, fromIntegral is polymorphic
13:39:29 <acomar> OH duh
13:39:31 <jmcarthur> :t fromIntegral
13:39:33 <lambdabot> (Integral a, Num b) => a -> b
13:39:36 <chrisdone> jmcarthur: for example?
13:39:36 <haasn> jmcarthur: I personally think that the existing ModuleImports feature could probably be more widely used for disambiguation
13:39:37 <acomar> I should be able to undefine the build flag that triggers that error
13:39:39 <skypers> not fromInteger
13:39:43 <skypers> fromIntegral.
13:39:45 <skypers> yeah
13:40:00 <jmcarthur> haasn: you mean PackageImports? eh... it's okay
13:40:13 <a3f> It gives me an error about failing to match Int with Word32
13:40:14 <haasn> jmcarthur: unfortunately, this causes portability issues since you might unknowingly import Lens on a local machine and then wonder why your code doesn't built on one that has data-lens installed too
13:40:26 <chrisdone> i'd prefer it if general modules were at the top-level, and special modules were namespaced
13:40:43 <chrisdone> so import List; import Monad but then import Ghc.Monad; import Ghc.FastString
13:40:53 <danilo2> I've got an Parsec question - In parsec there is function "getPosition ", which returns Position (column, line, etc), but it is possible in an easy way to get "position range" of currently matched string? I mean - I ant to know what is the start and end position of currently matched string?
13:41:00 <chrisdone> at the moment it's the complete opposite. it's weird
13:41:07 <jmcarthur> chrisdone: e.g. standard modules could just be in the Prelude, but by hiding the Prelude i could also hide the other standard modules if i want to
13:41:11 <elliott> well, that's just because the ghc api is ten billion years old.
13:41:26 <jmcarthur> chrisdone: and replace them with alternatives
13:42:00 <haasn> admittedly, having a more flexible module system that draws no distinction between modules and packages might be interesting
13:42:05 <chrisdone> jmcarthur: i see
13:42:08 <jmcarthur> chrisdone: entire packages could serve as drop in replacements for others without being fundamentally incompatible with each other in the same project
13:42:31 <haasn> and what's a ‘package’ now would just be a top-level module
13:42:35 <jmcarthur> chrisdone: (and this leads to ML style functors where you can parameterize modules on each other, but now we're getting into the weeds)
13:42:44 <a3f> skypers: I got a Int from using fromIntegral, still not the Word32 required, what now?
13:43:14 <skypers> :t fromIntegral (CInt 0) :: Word32
13:43:15 <lambdabot> Not in scope: data constructor `CInt'
13:43:20 <skypers> fuck it
13:43:30 <skypers> Prelude Data.Word Foreign Foreign.C> :t fromIntegral (CInt 4) :: Word32
13:43:30 <skypers> fromIntegral (CInt 4) :: Word32 :: Word32
13:43:41 <elifrey> danilo2: I don't know about Parsec, but the other day I was fiddeling around with Trifecta and it had something like this
13:43:42 <skypers> isn’t it what you want?
13:43:55 <mauke> :t 0 :: Word32 :: Word32
13:43:56 <lambdabot> parse error on input `::'
13:44:03 <mauke> :t (0 :: Word32) :: Word32
13:44:04 <lambdabot> Word32
13:44:26 <jmcarthur> a3f: fromIntegral will return whatever you demand from it. if you are getting an Int then something else about your code is causing it to do that
13:44:37 <danilo2> elifrey: Ok, but right now I've got my parser written in Parsec - maybe one day I'll rewrite it and then look into trifecta :)
13:45:29 <jmcarthur> danilo2: trifecta is nice. it gives you syntax highlighted error messages with exerpts of the input and carots pointing to the location of the error
13:45:50 <a3f> Oh, will try this out now :D
13:46:01 <elifrey> danilo2: Trifecta's API is strikingly similar to Parsec, I bet you could just change import statements :P
13:46:05 <mauke> >carots
13:46:07 <jmcarthur> the main issue with it is that the documentation is lacking
13:46:30 <jmcarthur> ^carots
13:46:49 <mauke> no, that's carets
13:46:59 <chrisdone> caret?
13:47:00 <chrisdone> lol
13:47:03 <acomar> nope, you can't undef something defined in the source, and undefing after #include doesn't help...
13:47:03 <elifrey> danilo2: actually, Parsers, which Trifecta is built on is very similar to Parsec in it's api. Trifecta goes above and  beyond the cause
13:47:05 <danilo2> elifrey, jmcarthur, elifrey - ok, but what downsides has trifecta compared to parsec?
13:47:16 <acomar> god this is hostile/evil
13:47:19 <jmcarthur> i think i fail at characters
13:47:26 <jmcarthur> danilo2: documentation
13:47:39 <elifrey> danilo2 jmcarther: dito
13:48:09 <elifrey> danilo2: once you're familiar with Pasec, you might find Trifecta not needing as much documentation as you would before.
13:48:24 <danilo2> jmcarthur, elifrey: Ok, but the documentation is not as **much** necessery if it is simmilar to uu-parsinglib or parsec.
13:48:26 <jmcarthur> my day is done. i have been made fun of by mauke and laughed at by chrisdone.
13:48:38 <jfischoff> does trifecta work with arbitrary stream types?
13:48:42 <mauke> >fun
13:48:45 <mauke> ಠ_ಠ
13:48:45 <jmcarthur> danilo2: yeah, i think that's why edwardk hasn't bothered to fill it in
13:48:53 <elifrey> jfischoff: yes
13:49:00 * monochrom hugs jmcarthur
13:49:16 <jmcarthur> shachaf could just top my day off
13:49:43 <danilo2> Ok, but is triffecta greedy by deafault? I mean, do we have towrite try(...) <|> ... ?
13:50:36 <jfischoff> danilo2: if the first can partially succeed you need to wrap it in a try
13:51:08 <danilo2> jfischoff: Ok, so its greedy by default. So moving from Parsec could be easy
13:51:20 <jfischoff> its pretty much the same api
13:52:16 <danilo2> But could somebody tell me - if we have Parsec, which is being developed for years, is it possible that young library (like trifecta) would be as fast and even better than parsec ?
13:52:29 <nisstyre> danilo2: of course
13:52:39 <nisstyre> danilo2: software quality isn't a function of time
13:52:44 <elifrey> danilo2: attoparsec is much younger than Parsec, and much faster
13:52:47 <jfischoff> has anyone benchmarked the two against each other?
13:53:51 <danilo2> elifrey: attoparsec is not usefeull when you want to create nice diagnostics.
13:53:52 <jfischoff> I tend to use trifecta these days just because I like the maintainters coding style
13:54:34 <jmcarthur> between trifecta and parsec i don't even really care which is faster, to be honest
13:54:35 <elifrey> danilo2: if you arn't parsing bytes off the wire or some other performance intensive task, is your parser really the bottleneck tho?
13:54:41 <jmcarthur> both are probably slower than attoparsec
13:54:52 <jfischoff> I'm sure that is the case
13:54:57 <monochrom> parsec, attoparsec, trifecta have mutually different emphases. where they overlap, you can meaningfully ask "which one is faster". where they are disjoint, "which one is faster" is meaningless or trivial
13:54:59 <shachaf> jmcarthur: help
13:55:34 <shachaf> hi elifrey
13:55:40 <jmcarthur> shachaf: help <command>. Ask for help for <command>. Try 'list' for all commands
13:55:50 <elifrey> hy shachaf
13:55:57 <danilo2> elifrey: No it is not the bottleneck, but I would lie to use "stable" and "fast" technology :) I'm checking trifecta right now :) Does anybody uses it for production things? (asking out of curious)
13:56:07 <shachaf> jmcarthur: what happen
13:56:14 <elifrey> danilo2: edwark uses it at work
13:56:28 <nisstyre> danilo2: attoparsec is fine if you don't need advanced parsing features
13:56:44 <jfischoff> danilo2: I use it at work, but its not for anything super crucial
13:56:49 <nisstyre> danilo2: make sure you use Text + OverloadedStrings with it
13:56:49 <ParahSail1n> so what is the emphasis of trifecta
13:57:00 <elifrey> error messages
13:57:06 <danilo2> monochrom: Ok, I asked only about the "general speed" when usign as "custom language parsers"
13:57:08 <jmcarthur> shachaf: mauke and chrisdone made fun of me! (but okay i've goofed off enough already and don't mean to keep joking around forever)
13:57:11 <monochrom> for example, if you want a "ParsecT (ContT r IO) a", then parsec is the fastest. because the other two take infinite time (because N/A)
13:57:18 <jfischoff> the error messages are so bad from attoparsec, on JSON parse failure I reparse with trifecta for a better message :p
13:57:34 <nisstyre> yeah attoparsec sucks at error messages
13:57:51 <nisstyre> if you don't need to display good errors then it's fine though
13:58:13 <elifrey> if you've ever used Clang, which has some groovy error reporting, Trifecta allows you to do similar things
13:58:19 <jmcarthur> ParahSail1n: the main draw for me is error messages. supposedly it is more amenable to certain kinds of unrealized optimizations, but i doubt speed is a good reason to use it.
13:58:30 <danilo2> monochrom: What is "ParsecT (ContT r IO) a" used for?
13:58:40 <jmcarthur> jfischoff: interesting idea there
13:58:48 <ParahSail1n> hm, id been using parsec for when i wanted good error messages
13:58:50 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
13:59:00 <ParahSail1n> what is the emphasis of parsec
13:59:17 <ParahSail1n> somewhere between attoparsec and trifecta?
13:59:18 <monochrom> the emphasis of parsec is generality
13:59:22 <jfischoff> jmcarthur: it gets the job done (errors are rare)
13:59:43 <monochrom> you can make up your own stream type, token type, base monad
13:59:46 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
14:00:07 <monochrom> the other two are faster because they are ungeneralized
14:00:13 <pr> how do you pronounce the <*> operator, if you pronounce it at all?
14:00:18 <jfischoff> ap
14:00:21 <monochrom> star
14:00:24 <hrefchef> I call it Wingstar.
14:00:28 <jmcarthur> jfischoff: you write something like (forall parser. SomeTypeClass parser => parser a)?
14:00:31 <pr> @type ap
14:00:33 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:01:08 <elifrey> hrefchef: omg I like that, wing is a good qualifier for talking about those guys
14:01:43 <danilo2> monochrom: But is it possible to create online parsers with trifecta (whcih produce output, we can cosnume before end of parsing) ?
14:01:44 * chrisdone presents jmcarthur with a cake
14:02:00 <jfischoff> jmcarthur: in my case the attoparsec parser is the json parser in Aeson, I so I  have completely seperate JSON parser
14:02:04 <monochrom> I don't know
14:02:07 <elliott> pr: "apply"
14:02:10 <elliott> but I prefer silence.
14:02:19 <elliott> (af <*> ax) isn't so different to (f x)
14:04:17 <monochrom> @quote monochrom modem
14:04:18 <lambdabot> No quotes match. stty: unknown mode: doofus
14:04:25 <monochrom> onoes
14:05:24 <benmachine> monochrom: that article is pretty cool
14:05:26 <danilo2> Ok, I'm feeling I'll move over trifecta :D
14:05:28 <geekosaur> other way around? quote then owner
14:05:34 <geekosaur> @quote modern monochrom
14:05:34 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
14:05:37 <geekosaur> bah
14:05:42 <monochrom> thank you for praising monochrom!
14:05:45 <jfischoff> danilo2: I think it is wise to read monochrom's blogs. I learned how to use parser combinators from his writings.
14:06:02 <danilo2> elifrey: Do you know how we can obtain the information about beginning and end of currently parsed string in trifecta?
14:06:31 <danilo2> jfischoff: I'm reading it right now :)
14:06:40 <monochrom> geekosaur: it's modem not modern. something about "you are not a modem, why are you pronouncing symbols?" :)
14:06:44 <elifrey> danilo2: check out spanned and spanning
14:06:53 <elifrey> http://hackage.haskell.org/packages/archive/trifecta/1.1/doc/html/Text-Trifecta-Combinators.html
14:06:56 <danilo2> One more question: does trifecta allows to use custom monad?
14:07:08 <geekosaur> oh, sorry. someday must find a font that has reasonable utf8 and doesn't have some really sucky letterforms
14:07:10 <danilo2> *i'm sorry - i mean custo mstate
14:07:24 <shachaf> Is there anything that can be done about ghci taking a long time (~1s) to start?
14:07:32 <shachaf> I have about a hundred imports in my ~/.ghci.
14:07:37 <geekosaur> I literally have to mess with selecting chars to see the difference between rn and m
14:07:47 <elifrey> danilo2: i don't think so, but I could be wrong
14:08:04 <geekosaur> don't import 100 things into an interpreter?
14:08:24 <monochrom> shachaf: if you don't want to give up those imports, I can only think of: "next time, start ghci 1 second earlier" :)
14:08:33 <hrefchef> Does anyone know of a way to quickly list exposed functions in a module? Right now I'm just opening the source files and look at the module declaration.
14:08:38 <benmachine> shachaf: I have no idea if this will help, but have you tried writing a module that imports all the other modules, and only loading that?
14:08:49 <elifrey> danilo2: looks like Trifecta uses a concrete instance of the combinator classes it provides
14:08:52 <shachaf> benmachine: Well, if nothing else, some of them are qualified.
14:09:00 <elifrey> so ostensibly you could write your ow :)
14:09:03 <elifrey> http://hackage.haskell.org/packages/archive/trifecta/1.1/doc/html/Text-Trifecta-Parser.html
14:09:15 <benmachine> shachaf: have you tried implementing first-class modules in GHC and then using those?
14:09:20 <shachaf> benmachine: More importantly, sometimes I unimport some of them after starting ghci.
14:09:21 <benmachine> shachaf: if not then maybe you should do that
14:09:31 <benmachine> shachaf: have you tried having your cake and eating it
14:09:44 <chrisdone> what's a haskelly name i can use for my scrobbling server?
14:09:52 <benmachine> chrisdone: what on earth is scrobbling
14:09:53 <monochrom> have you tried hugs?  <duck>
14:10:01 * benmachine hugs monochrom 
14:10:11 <monochrom> "hascrobbler"?
14:10:21 <chrisdone> this happens every damn time. cd ~/Projects; mkdir … oh crap. what name?
14:10:24 <shachaf> benmachine: Also, how do I make a module like that and let ghci import it without actually making a cabal package etc.?
14:10:33 <chrisdone> monochrom: *groan* =p
14:10:36 <danilo2> nisstyre: You've told about usage of Text + OverloadedStrings - could you tell more about it please?
14:10:39 <monochrom> or perhaps, "scrobblell"
14:10:49 <benmachine> shachaf: that's a good question. I don't know how you avoid things like :l clobbering it
14:10:50 <chrisdone> benmachine: submitting listened audio tracks to a server. you heard of last.fm?
14:10:59 <benmachine> chrisdone: I've heard of it but not used it
14:11:00 <geekosaur> scrobbell?
14:11:13 <shachaf> You *could* not name it after the language it's written in.
14:11:18 <monochrom> I am bad at inventing names too
14:11:19 <hrefchef> Name it something cool, like "Cleric".
14:11:28 <benmachine> call it benmachine
14:11:32 <elifrey> danilo2: OverloadedStrings allows you to treet string literals as anything that implements IsString
14:11:36 <shachaf> I don't think I see C programs named after the language they're written in. Hopefully it's a good program in its own right, so just name it in its own right.
14:11:59 <elifrey> danilo2: so you don't have to say `fromString "my string"` all the time
14:12:02 <benmachine> I think shachaf's advice is good
14:12:12 <monochrom> I only have a scheme for naming things I will throw away soon. joy, fun, delight, happy, merry, john, mary
14:12:19 <danilo2> elifrey: ah, ok, thank you :)
14:12:31 <shachaf> I agree with benmachine.
14:12:33 <mrotondo> noob question: I'm clearly missing something, but in ghci when I let f = zipWith (/=) and then try f [1,2,3] [3,2,1], I get No instance for (Num ()) arising from the literal `1'
14:12:49 <mrotondo> though just calling zipWith with those arguments directly works
14:12:50 * jfischoff waves at mrotondo
14:12:53 <shachaf> mrotondo: It is the monomorphism restriction.
14:12:57 <haasn> mrotondo: turn off the MonomorphismRestriction
14:12:57 <shachaf> @where mr
14:12:57 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:13:00 * mrotondo hi :D
14:13:28 <monochrom> glibc is named after the language it's written in and/or written for  <duck>
14:13:35 <mrotondo> ah, ok, thanks!
14:13:38 <benmachine> also, question: does anyone object me taking http://www.haskell.org/haskellwiki/User:Benmachine/Non-strict_semantics and clobbering http://www.haskell.org/haskellwiki/Non-strict_semantics with it? I feel like this is really a mailing list question but the cafe frightens me
14:13:47 <benmachine> maybe it's a reddit question
14:13:51 <benmachine> but it isn't really
14:13:56 <shachaf> monochrom: Yes. For a Haskell library I might give different advice.
14:13:56 <hrefchef> It depends on the language. A lot of Java programs are named after Java.
14:14:16 <benmachine> hrefchef: just because Java does something doesn't mean it's a good idea
14:14:24 <chrisdone> lol
14:14:25 <bennofs> Name it AbstractFunctionalMusicScrobblerImplementation
14:14:27 <hrefchef> Basically all of Scala, D, and Lisp as well.
14:14:36 <elifrey> and javascript and go
14:14:37 <chrisdone> "if Tommy told you to jump off a bridge would you do it?"
14:14:46 <chrisdone> "… how high is the bridge?"
14:14:57 <hrefchef> So the only languages that don't is the C language.
14:14:58 <jmcarthur> i would emphasize the language a library is written in if it's just supposed to be an alternative to a better known library in another language
14:15:02 <shachaf> benmachine: I would not object (but I don't know how the wiki works in the first place).
14:15:15 * elifrey agrees with jmcarthur
14:15:19 <jmcarthur> eg:   quickcheckC or something
14:15:37 <shachaf> cuicchecc
14:15:51 <haasn> quickercheck
14:15:53 <benmachine> shachaf: my impression is that it doesn't work very much :P
14:16:02 <chrisdone> when i say haskelly name i like things like xmonad. that's a cool name
14:16:26 <monochrom> oh! that kind of haskelly name
14:16:31 <bennofs> xapplicative :D
14:16:33 <chrisdone> i bet before that dons called it donsescoolwindowmanagerthing
14:16:44 <monochrom> "left Kan scrobbler"
14:16:46 <shachaf> Before "xmonad" it was called "thunk".
14:16:59 <chrisdone> hmm, yeah. thunk makes little sense
14:17:15 <shachaf> And it wasn't dons, either.
14:17:27 <chrisdone> i can't remember who it was, gimmie a break
14:17:44 <jfischoff> you call yourself a haskeller
14:17:48 <chrisdone> monochrom: lol
14:17:56 <hrefchef> They prefer to be callled "Haskies".
14:18:07 <jfischoff> Haskimos
14:18:09 <chrisdone> haskellites
14:18:13 <MedDev> Haskuits
14:18:20 <jfischoff> more pc
14:18:26 * MedDev nods
14:18:36 <benmachine> haskeroids?
14:18:38 <shachaf> I don't approve of naming things that are written in Haskell after Haskell because it suggests that they're not actually good in their own right.
14:18:44 <hrefchef> benmachine: There's cream for that.
14:19:23 <chrisdone> i tend to just pick girls names that i like =/
14:19:30 <chrisdone> fay, oma, amelie
14:19:39 <monochrom> that is a good scheme
14:19:41 <benmachine> call it chris
14:19:43 <tdammers> shachaf: it does make kind of sense if being written in Haskell is one of their unique selling points
14:19:47 <chrisdone> benmachine: hahaha
14:19:53 <danilo2> I've got one question to Trifecta - lets say, we want to output some AST elements, but we want to give each such element unique ID (simple Int). In Parsec I would use custom state - how to do it in trifecta?
14:19:53 <jfischoff> until your married
14:20:04 <monochrom> consider christine. best of both worlds
14:20:13 <shachaf> Being written in Haskell shouldn't be a selling point.
14:20:22 <jfischoff> then better rename them all after your wife
14:20:28 <benmachine> shachaf: well, but we all know that Haskell is the best way to write things, right
14:20:30 <tdammers> it could be for things like web frameworks
14:20:32 <hrefchef> It should be, though. A Haskelll program has unique advantages over others.
14:20:33 <chrisdone> yeah. Christine Done is the reason i'm not first in google for "chris done". *shakes fist*
14:20:47 <hrefchef> How many people would use xmonad if it weren't written in Haskell? Not as many.
14:20:52 <monochrom> oh yikes haha
14:21:03 <danilo2> elifrey:  I've got one question to Trifecta - lets say, we want to output some AST elements, but we want to give each such element unique ID (simple Int). In Parsec I would use custom state - how to do it in trifecta?
14:21:15 <tdammers> hrefchef: I used xmonad before getting into haskell
14:21:15 <donri> hey that's a thought, let's implement an X Monad in php
14:21:20 <monochrom> then consider "christine continuation"
14:21:24 <tdammers> heck, xmonad was my gateway drug
14:21:37 <shachaf> benmachine: The old non-strict semantics page doesn't look that great to me.
14:21:47 <hrefchef> Yeah, but compared to other window managers it's pretty lacking out of the box.
14:21:59 <benmachine> shachaf: right, I'm going to find out if I have page-move permissions
14:22:16 <chrisdone> shachaf: yeah i agree on the language-themed naming implying it's not generally good in its own right. but i do like 'thunk' and stuff like that
14:22:36 <a3f> danilo2: Maybe ask at SO ?
14:22:50 <monochrom> "I thunk, therefore I am lazy"
14:23:11 <elifrey> danilo2: that is a good question :)
14:23:16 <benmachine> aw, I can't clobber pages by moving other pages onto them
14:23:22 <benmachine> in retrospect this is probably sensible
14:23:30 <danilo2> a3f, elifrey : ok :)
14:23:40 <donri> I thunk, therefore I might become, if you force me.
14:23:41 * benmachine employs the wisdom of copy and paste
14:23:41 <chrisdone> monochrom: i thunk therefore i was?
14:23:44 <twopoint718> I'm trying to create non-positional/default function arguments. Is there any way to write email' that works? https://gist.github.com/twopoint718/6565755
14:23:51 <enthropy> danilo2: do you need the ID when your you're actually parsing?
14:23:55 <monochrom> or "I will"
14:24:05 <enthropy> dan64: you can probably do the numbering afterwards
14:24:07 <chrisdone> so deep
14:24:14 <enthropy> oops danilo2
14:24:55 <elifrey> danilo2: you can always layer in state manually? type MyParser a = ID -> Parser (a, ID)
14:25:20 <enthropy> which is then  StateT ID Parser
14:25:28 <enthropy> (which probably has no instance)
14:25:33 <MedDev> twopoint718, look into Lenses, they should let you introspect onto a record like that
14:25:37 <elliott> no instance?
14:25:44 <danilo2> enthropy: No, I need to outpu AST, in whcih easc hnode will have unique ID
14:26:19 <benmachine> chrisdone: I asked sort -R /usr/share/dict/words | head -n 20 for inspiration
14:26:22 <danilo2> enthropy: I cannot do the numbering afterwards, because I want to create additional a map (dictionary) from the ID to the position in code
14:26:22 <enthropy> elliott:
14:26:37 <enthropy> elliott: for danilo2's problem
14:26:46 <hrefchef> I wish that more people talked about /usr/share/dict/words. I manually made one without knowing about that.
14:26:49 <enthropy> instance Monad (StateT Id Parser) -- may not exist
14:26:56 <benmachine> chrisdone: let's not go for "wrongful epileptics", but you may find something you prefer
14:27:01 <hrefchef> Editing a 75,000 line file in Emacs is not fun.
14:27:03 <benmachine> "fleet" isn't a bad name for... something
14:27:08 <chrisdone> @yow
14:27:08 <lambdabot> But was he mature enough last night at the lesbian masquerade?
14:27:13 <chrisdone> O_O
14:27:27 <elliott> enthropy: sure it'll exist
14:27:34 <elliott> assuming Parser is a Monad
14:27:38 <chrisdone> benmachine: yeah i can imagine fleet being good for server management or os
14:27:40 <elliott> StateT s m is a Monad for any Monad m
14:27:44 <danilo2> elifrey: Do I understand good, that you want me to manually pass the incrementing id to every parser ocmbinator I write?
14:27:44 <enthropy> ah there is one Monad m => Monad (StateT s m)
14:27:51 <elliott> that's the point of StateT :P
14:27:51 <twopoint718> MedDev: so I can't (naively) write some function that "lifts" a normal accessor like "email" so that I just call "email {email="foo..."}" ?
14:28:47 <chrisdone> i started recording a podcast about weekly haskell news from haskellnews.com
14:28:57 <chrisdone> and stopped when i couldn't pronounce half of the author names
14:29:23 <chrisdone> yasper van der yoikt… te… tu… oh forgeddit
14:29:45 <inkjetunito> heh, dutch names
14:29:58 <MedDev> twopoint718, not in my experience, there are a few packages to do this (Lenses, Vinyl, named-records)
14:30:10 <MedDev> twopoint718, came across the same limitation. you can pass the record accessor
14:30:11 <elifrey> danilo2: listen to enthropy and elliott. You can layer StateT over Parser instead of layering Parser over State
14:30:36 <twopoint718> MedDev: Thanks. I'll check those out. I'm basically just looking for optargs.
14:30:45 <MedDev> but if you pass it as an argument it doesn't get 'expanded' (?) to the full name when you do myArg {myArg="foo"} the first one will but not the one inside of the {}
14:30:56 <inkjetunito> chrisdone: haskellnews.com doesn't contain haskell news btw
14:31:02 <MedDev> probably because internally ghc uses a dict to do that kind of thing twopoint718
14:31:10 <chrisdone> inkjetunito: ah i meant http://haskellnews.org/
14:31:45 <MedDev> twopoint718, so it's treating the myArg inside of the {} as a string (or some such nonsense)
14:32:12 <danilo2> elifrey: Ok, I'll try this way
14:33:55 <twopoint718> MedDev: yeah I noticed that the "{...}" doesn't act like a normal argument. The type of defaultPerson is also just ":: Person", not expecting an arg.
14:34:05 <twopoint718> I'll go look at those libs. Thanks for the pointers.
14:36:16 <MedDev> twopoint718, you need to put the { right against the defaultPerson as well, whitespace is significant in haskell
14:36:34 <benmachine> MedDev: that doesn't sound right
14:36:36 <geekosaur> um?
14:36:52 <MedDev> really? i always had to do myRec{updatedField="somevalue"}
14:36:56 <benmachine> nope
14:37:01 <geekosaur> spaces and tabs can separate; if it goes on the next line *then* indentation matters
14:37:05 <benmachine> I always do that because I think it's evocative
14:37:26 <romildo> I want a link to the type definition for the representation of the AST for Haskell in the ghc compiler.
14:37:34 <benmachine> particularly, the fact that record update is the only thing that binds tighter than function application motivates me to leave no space
14:37:53 <danilo2> enthropy, elliott, elifrey: Ok, but how can I use "runState" with the functions provided in trifecta?
14:38:17 <chrisdone> i put a space because arbitrary
14:38:56 <elliott> benmachine: it motivates me to dislike that thing. :(
14:38:59 * hackagebot snaplet-sqlite-simple 0.4.5 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.5 (JanneHellsten)
14:39:13 <AnalogFile> ping quchen
14:40:01 <chrisdone> all y'all that don't make an src directory for your projects
14:40:03 <chrisdone> i hate you
14:40:53 <benmachine> elliott: that too
14:41:07 <jmcarthur> romildo: is your google fu that bad?
14:42:02 <a3f> mine isn't! but I am stuck again though :(
14:42:50 <jmcarthur> in the very worst case one could just download the ghc source and search it
14:42:59 <a3f> when i define a let inside a case inside a do block, it gives me errors about the return type of the let expression not returning IO ()
14:43:00 <copumpkin> http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
14:43:11 <copumpkin> my google-fu is amazing
14:43:24 <copumpkin> oh not so good
14:43:26 <copumpkin> this is the core
14:43:29 <carter> oh?
14:43:33 <jmcarthur> fail
14:43:42 <copumpkin> :)
14:43:46 <jmcarthur> i love how simple core is though :)
14:43:48 <jfischoff> which brings up a good point
14:43:56 <jfischoff> which ast?
14:44:06 <jfischoff> arguably template haskell is one
14:44:53 <enthropy> danilo2: you don't. If you like to parse a string, you now have to use   lift (string "foo"). All that pain just so you can access your state with the usual get/modify/put
14:46:12 <enthropy> when you finally want to run the parser, you use something   (evalStateT myParser initialID), where you'd otherwise have myParser
14:46:54 <enthropy> you're probably better off numbering things after parsing
14:47:21 <enthropy> unless your parser is supposed to do things differently after seeing ID 5 than ID 3 for example
14:48:08 <danilo2> enthropy: I'm trying to do it :)
14:48:27 <jmcarthur> this is the first time i've read the actual docs on the Core AST though. it seems there are a lot of invariants on the structure :\
14:48:45 <jmcarthur> or not quite invariants, but i guess little gotchas
14:51:16 <danilo2> enthropy: By telling "lift(string ... )" you mean lifting every basic parser combinator?
14:51:54 <enthropy> well you can pull the lift out
14:52:19 <enthropy>  lift $ do a; b; c  is going to be the same as   do lift a; lift b; lift c
14:52:20 <danilo2> enthropy: I cannot number things after parsing, because I want to create map (number -> position in text)
14:52:57 <danilo2> enthropy: I cannot make it working :( Could you see this example please?: https://github.com/ekmett/trifecta/blob/master/examples/RFC2616.hs
14:53:39 <enthropy> that's not your example (and it doesn't seem to use StateTi
14:53:41 <enthropy> )
14:55:23 <danilo2> enthropy: I know it is not mine, I'm trying to simplu use "put" in eny of these functions
14:55:31 <spaceships> is the reason (fmap . fmap) = \f -> fmap (fmap f) because (.) only does something with the first argument to the resulting function?
14:55:58 * applicative thinks everything should have lift somewhere in front, when in doubt try: runIdentity . runIdentityT . lift . return
14:57:55 <applicative> spaceships: f . g = \x -> f (g x) is the definition of .
14:58:03 <enthropy> danilo2: well what error are you getting after putting lift in places and runStateT/evalStateT in the right place?
14:58:42 <spaceships> applicative: oh right, thanks... so much simpler than I was trying to make it
14:58:47 <enthropy> you could also change your AST to include the source location
14:58:54 <enthropy> haskell-src-exts does that
14:59:10 <danilo2> enthropy: I do not know if I'm putting it in right place :) http://lpaste.net/92999
14:59:12 <applicative> spaceships: the wacky thing is that fmap . fmap is fmap fmap fmap
14:59:32 <spaceships> applicative: ?!?!
14:59:54 <applicative> @type fmap fmap fmap
14:59:55 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:00:03 <applicative> @type fmap `fmap` fmap
15:00:03 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:00:09 <applicative> @type fmap . fmap
15:00:10 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:00:14 <applicative> all the same
15:00:20 <danilo2> enthropy: Ive added compile error message:  http://lpaste.net/92999
15:00:21 <hpaste> enthropy annotated “StateT in Trifecta” with “StateT in Trifecta (annotation)” at http://lpaste.net/92999#a93002
15:00:27 <donri> that always makes me thinks of the aliens in mars attack
15:00:30 <donri> fmap fmap fmap
15:00:46 <enthropy> @type evalStateT
15:00:47 <lambdabot> Monad m => StateT s m a -> s -> m a
15:00:52 <chrisdone> donri: lol
15:01:10 <applicative> now if we just had the om nom combinators we could have martian invaders eating new york or something
15:01:48 <chrisdone> when i first saw that i used to cry laughing at the old woman happily listening to music with headphones while the aliens point a huge laser at her head
15:02:07 <spaceships> applicative: so thats using the functor instance of (->)  or something?
15:02:21 <applicative> spaceships: yes
15:02:47 <spaceships> applicative: which is (.)
15:02:52 <spaceships> okay i get it i think
15:04:11 <applicative> its pretty clear if you dont omit the intervening stage
15:04:15 <applicative> @type fmap fmap
15:04:16 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
15:04:25 <applicative> now I try to apply that to fmap itself
15:04:41 <danilo2> enthropy: Ok, the previous error was simple my error, but now I really do not now how to fix it: http://lpaste.net/93004
15:04:55 <applicative> fmap has to be read as somehow f (a -> b)
15:05:14 <enthropy> danilo2: lift should be on line 18 not 16
15:07:00 <ReinH> :t fmap
15:07:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:07:11 <danilo2> enthropy: it works! Ah I see why. Hmmm , sorry for so simple questions :/
15:08:09 <ReinH> spaceships: the functor is ((->) r), so f a is a function that produces an a.
15:08:43 <ReinH> spaceships: fmap for functions takes a function from an a to a b and a function that produces an a and returns a function that produces a b.
15:08:52 <ReinH> :t (.)
15:08:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:09:27 <ReinH> composition takes a function that produces a b and a function from a b to a c and produces a function that produces a c
15:10:26 <Hafydd> composition takes a function that produces a a and a function from a a to a a and produces a function that produces a a
15:10:31 <ReinH> these are identical up to alpha equivalence (the names of the variables)
15:12:29 <applicative> composition takes a a -> a that produces a a and a function from a a to a a and produces a function that produces a a
15:12:50 <ReinH> thanks :)
15:13:04 <ReinH> a rather unfortunate circumstance
15:14:40 <applicative> really composition takes a a -> a, a a -> a and a application or two to a a -> a
15:14:49 <ReinH> applicative: I hate oyu.
15:15:07 <ReinH> a a a a, a a -> a, a a.
15:15:11 <a3f> ReinH: You were the one who advised me to use let blocks to store the flags this morning, right?
15:15:12 * applicative dreams of alphabet soup
15:15:25 <ReinH> a3f: doubtful.
15:15:45 <ReinH> applicative: Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
15:15:51 <a3f> ReinH: Well, so it's your chance now to do it :D
15:16:03 <ReinH> a3f: ok. You should use let blocks to store the flags.
15:16:23 <a3f> ReinH: But it's not working!!
15:16:25 * applicative is skilled at parsing the Buffalo-satz
15:16:42 <a3f> ReinH: You wanna help me with that :D ?
15:16:43 <ReinH> a3f: Ok!
15:17:27 <a3f> ReinH: the let block is inside a switch statement that parses the flags
15:17:47 <a3f> ReinH: It evaluates to a Ptr and that throws me an error because GHC expects it to evaluate to ()
15:18:05 <a3f> case statement*
15:18:45 <ReinH> a3f: I have no idea what yuo're talking about.
15:20:08 <benmachine> wait wait
15:20:17 <benmachine> I'm trying to write an article about purity for haskellwiki and I got confused
15:20:39 <benmachine> is it "no side-effects" or "no global state" or are they the same?
15:20:42 <applicative> ot
15:20:57 <applicative> pardon
15:21:19 <Hafydd> Why are you writing an article about purity if you're unsure?
15:21:30 <benmachine> Hafydd: no-one else will :P
15:21:38 <Iceland_jack> benmachine: You don't write articles on a topic you don't know
15:21:57 <Hafydd> Consider that no information is better than incorrect information.
15:21:58 <applicative> Iceland_jack: if the haskell community had followed that policy, uh, ...
15:22:02 <benmachine> see, the thing is, whatever the answer to my question is, I still know a lot about the subject
15:22:04 <Iceland_jack> applicative: ;)
15:22:23 <benmachine> just not the definitions precisely
15:22:44 <Iceland_jack> If you don't know the difference between side-effects and global state then I'm not quite so sure
15:22:53 <benmachine> Iceland_jack: of course I know the difference between them
15:23:05 <benmachine> Iceland_jack: I just don't know precisely which we mean when we refer to "purity"
15:23:25 <benmachine> Iceland_jack: I feel like the answer is "both" but I've only really picked that up from folklore
15:24:28 <AnalogFile> well, if by "state" you mean something that "changes with time" then no side effects anywhere implies no state at all, either global or local.
15:24:40 <Iceland_jack> https://en.wikipedia.org/wiki/Pure_function ← have you looked at this?
15:24:51 <Iceland_jack> There are plenty of resources available
15:24:54 <benmachine> AnalogFile: right, but "evaluation has no side effects" does not mean "no side effects anywhere"
15:25:57 <AnalogFile> benmachine: nowhere except for "unsafe*" and the "world" manipulation of the IO monad, of course
15:26:30 <benmachine> AnalogFile: well, IO is kind of a key part of the picture, no?
15:26:33 <applicative> I recommend the learned classic   https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps if you internalize it you can appeal to it smugly in surprisingly many contexts
15:26:53 <AnalogFile> if you ignore "unsafe*" functions there is no real state (not in the sense of "chages with time"
15:26:56 <benmachine> applicative: that is exactly the sort of answer I wanted
15:27:21 <AnalogFile> IO does his magic to the outside world.
15:27:37 <benmachine> AnalogFile: explain to me how to understand the purpose of "getCurrentTime" within your conceptual framework of "there is no state that changes with time"
15:27:55 <benmachine> AnalogFile: I'd say Haskell does have state, but Haskell's *evaluation of expressions* does not have state
15:27:58 <AnalogFile> that's in IO
15:28:14 <benmachine> AnalogFile: IO is a part of Haskell
15:28:44 <benmachine> you cannot understand Haskell programs unless you understand how IO works
15:28:55 <AnalogFile> monads are a way to express sequences of calls. you do not really get state, you get the illusion of state changes
15:29:35 <benmachine> AnalogFile: with IO, you really get state
15:30:32 <AnalogFile> not really. except for the unsafe calls
15:31:17 <AnalogFile> you should think of things like getCurrentTime as "reading from an input file" which is totally immutable but contains a sequence of times.
15:31:32 <benmachine> AnalogFile: how should you think of readIORef and writeIORef?
15:31:41 <AnalogFile> it's just like walking a list of timestamps. no real state changes
15:32:28 <AnalogFile> similarly to the way they work in the ST monad
15:32:41 <benmachine> the way they work in the ST monad is with mutability under the hood :)
15:33:25 <AnalogFile> yup, but it's mostly an implementation detail. you should think matematically
15:33:55 <Hafydd> ITC: AnalogFile draws an analogy to a file.
15:34:01 <applicative> mutamatically
15:34:18 <AnalogFile> Hafydd: hehe
15:34:36 <benmachine> AnalogFile: so what's the difference between thinking mathematically about a stream of values, and mutable state?
15:35:00 <AnalogFile> that you can think of the stream as being immutable
15:35:20 <benmachine> ok, but what difference does that make? at any point in time you still don't have access to what the state used to be or will be
15:35:35 <benmachine> you're always at exactly one moment, from which you have a "view" of reality in exactly one state
15:35:46 <benmachine> so it's exactly the same as viewing the world as being made up of "real" mutable state
15:36:01 <AnalogFile> which is exactly the reason even IO (and all monads) are referentially transparent (no state changes, except OUTSIDE the program, if you use IO)
15:37:12 <applicative> state changes INSIDE the program may however tracked by a version control system
15:37:19 <benmachine> AnalogFile: okay so being "referentially transparent" means that a name used to refer to a value can be replaced with the value without changing the meaning of the program/expression
15:37:20 <anon34928793> does unsafePerformIO break reference transparency, though?
15:37:36 <benmachine> AnalogFile: in IO, this is meaningless, because things like putStrLn don't have a value that they refer to
15:37:56 <benmachine> AnalogFile: so yes, they are referentially transparent, but you still need to think about mutable state to understand what they do
15:38:10 <benmachine> you need a mental model of mutable state to understand the execution of IO
15:38:11 <AnalogFile> anon34928793: all unsafe* functions break referential transparency, that's what the unsafe prefix means
15:38:36 <chrisdone> that's the haskeller armchair semanticist definition of referntial transparency =p
15:38:53 <benmachine> anon34928793: let x = unsafePerformIO (...) in x + x is different from unsafePerformIO (...) + unsafePerformIO (...) with respect to the number of times the IO will be performed
15:39:10 <benmachine> anon34928793: at least in terms of current implementations; this may not be true all the time because of inlining
15:39:25 <jfischoff> ^ this is part of the unsafe
15:39:39 <AnalogFile> you may use a mental model of mutable state or a mental model of immutable sequence of external states
15:39:42 <benmachine> anon34928793: it's kind of hard to talk about referential transparency because it's a semantic notion but unsafePerformIO doesn't really have semantics as such :)
15:40:08 <jfischoff> opening files with performUnsafeIO is very bad
15:40:10 <AnalogFile> does time passes in a movie?
15:40:10 <shachaf> benmachine: Clearly you should talk about the *semantics* of unsafePerformIO instead.
15:40:19 <shachaf> Oops, too late.
15:40:27 <benmachine> shachaf: :)
15:41:57 <benmachine> another part of the unsafe is that unsafePerformIO can be used to bypass the time system, you can implement unsafeCoerce with it
15:42:35 <AnalogFile> the mental model of the world without state is very weird (we know that the real world does have state) but it's still valid from the haskell point of view.
15:42:45 <Hafydd> unsafePerformIO can be used to travel backwards through time.
15:44:43 <anon34928793> hell, we don't need unsafePerformIO to timetravel
15:45:00 <benmachine> also I would like to point out to all the people who were sassing me about writing an article about purity even if I don't know about it, applicative's paper points out that even the academic literature doesn't always agree on what it is
15:45:20 <shachaf> benmachine: Bypass the time system? That's, uh, continuations or something?
15:45:21 <edwardk> danilo2: You can apply StateT to a trifecta parser
15:45:27 <benmachine> although admittedly it was written in 1993 ._.
15:45:38 <benmachine> shachaf: the reverse state monad :P
15:46:21 <anon34928793> see the non-portable acme-realworld package: http://hackage.haskell.org/package/acme-realworld
15:46:38 <Iceland_jack> benmachine: Disagreements on terms is quite different though
15:47:03 <benmachine> Iceland_jack: different from what?
15:47:17 <shachaf> Disagreements on terms, disagreements on types, disagreements on kinds.
15:47:23 <benmachine> :P
15:47:43 <AnalogFile> benmachine: back to your question. generally "pure" refers to "no side effects". the first consequence is that data is immutable, which implies no state (and therefore no global state)
15:47:58 <Iceland_jack> ‘I'm writing an article on something I understand, but that's OK because even experts don't always agree.’?
15:48:02 <AnalogFile> the second consequence is that functions are referentially transparent
15:48:03 <Iceland_jack> *something I don't understand
15:48:10 <Iceland_jack> Not to put too fine a point on it
15:48:21 <anon34928793> I guess we only need unsafeCoerce# to time travel. Derp.
15:48:39 <benmachine> Iceland_jack: when I originally asked my question I was unclear about where my confusion lay
15:49:29 <benmachine> Iceland_jack: I understand why global mutable state is undesirable, and why arbitrary/uncontrolled side effects are undesirable, and I can write about both of those
15:49:36 <Iceland_jack> It is generally my experience that you need to be one or two ‘educational levels’ above a topic to teach it well
15:49:38 <benmachine> Iceland_jack: but what I don't have is a precise definition of purity
15:49:54 <shachaf> No one has a precise definition of "purity".
15:50:07 <benmachine> shachaf: well that answers my question
15:50:08 <shachaf> Or maybe everyone does and they're all different. I don't now. It's not a term worth using when you want to be precise.
15:50:43 <benmachine> shachaf: yet, people will insist on saying "Haskell is a purely functional programming language" and we have to work out how to explain that to people who want to know
15:50:51 <acomar> benmachine: aren't there countless articles on that subject though? I swear I see one of those every time I check /r/programming. What are you planning to add to the discussion?
15:50:58 <shachaf> No one knows what "functional" means, either.
15:50:59 <anon34928793> purely functional /= purity
15:51:19 <benmachine> shachaf: yes yes I know :P
15:51:37 <Iceland_jack> There is no universally agreed upon definition of ‘functional programming’ either, but that doesn't mean that writing about it is a free-for-all
15:51:37 <AnalogFile> there are some edge cases where unsafeCoerce is useful and actually both safe and referentially transparent. for example in the implementation of Data.Typeable.cast
15:51:39 <shachaf> It's at best a good shorthand between people who already basically agree with each other on what they're talking about.
15:51:42 <benmachine> acomar: I want the haskellwiki to have something on the topic, because I think that's where a lot of people wanting to know will end up
15:51:48 <applicative> benmachine: you didn't read sabry fast enough to put these guys down
15:51:51 <benmachine> shachaf: this is my suspicion
15:51:53 <shachaf> As soon as a disagreement comes up, it's best to drop the term, rather than argue about what it should mean.
15:51:54 <hpaste> applicative pasted “secret number monoid ({-# LANGUAGE Trustworthy #-})” at http://lpaste.net/93005
15:51:58 <benmachine> applicative: I was busy :P
15:52:47 <fragamus> Hey
15:53:01 <applicative> benmachine: i'm telling you, you would totally control the situation; even if you could just sort of throw some of the jargon around...
15:53:14 <AnalogFile> haskell wiki already has something about that: http://www.haskell.org/haskellwiki/Functional_programming#Purity
15:53:47 <anon34928793> applicative: but what if your program name changes while it's executing?
15:54:01 * hackagebot pipes-vector 0.5.1 - Various proxies for streaming data into vectors  http://hackage.haskell.org/package/pipes-vector-0.5.1 (BenGamari)
15:54:03 * hackagebot pipes-interleave 0.1 - Interleave and merge streams of elements  http://hackage.haskell.org/package/pipes-interleave-0.1 (BenGamari)
15:54:17 <applicative> anon34928793: onoes, then the monoid laws would be broken!
15:54:40 <applicative> anon34928793: think i should drop the Trustworthy bit? ;)
15:54:58 <Iceland_jack> applicative: That made me cringe a bit
15:55:07 <benmachine> applicative: I've always regarded it as a specious claim anyway
15:55:13 <benmachine> applicative: it's more TrustNecessary, really
15:55:17 <applicative> Iceland_jack: i quickchecked the monoid laws on it
15:55:25 <Iceland_jack> Oh OK, never mind then ;)
15:56:04 <benmachine> applicative: you know about withProgName, right? :P
15:56:30 <applicative> can it be even dirtier than i imagine?
15:56:43 <anon34928793> needs more unsafeInterleaveIO
15:56:44 <applicative> oh withProgName, no i don't
15:57:27 <benmachine> http://beta.hackage.haskell.org/package/base-4.6.0.1/docs/System-Environment.html
15:57:27 <applicative> anon34928793: of course this isn't all that much worse than 'numCapabilities' or does that still exist
15:57:32 <benmachine> "withProgName name act - while executing action act, have getProgName return name. "
15:57:43 <applicative> ha
15:57:49 <benmachine> applicative: numCapabilities is at least hidden in GHC.Conc
15:57:53 <benmachine> (iirc)
15:58:15 <applicative> it used to be just a pure number you could throw around, if i remember
15:58:21 <benmachine> applicative: "pure" :P
15:58:29 <applicative> it was 2, iirc
15:58:45 <benmachine> http://stackoverflow.com/a/12003058/812053
15:58:56 <benmachine> it's my highest-upvoted SO answer
15:59:00 <benmachine> which isn't saying much ._.
15:59:23 <anon34928793> you can make numCapabilities whatever you want iirc O.o
15:59:29 <applicative> ah indeed benmachine
16:01:26 <hpc> anon34928793: it used to be you could only go up, but now down works too!
16:03:41 <anon34928793> so, it seems whenever I ask ghc to make something of a parser-y nature, it decides to suck up all of my ram, then move to causing my system to thrash, and ultimately chug away for a very long while until it spits out a completely ordinary object.. I'm using default settings. Am I doing something particularly egregious?
16:03:43 <applicative>  numCapabilies == 1 is True-for-me-now-inside-ghci-10-Tishrei
16:04:01 * hackagebot hmatrix-svdlibc 0.2.1 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.2.1 (BenGamari)
16:04:58 <applicative> numCapabilities is really disturbing, I had forgotten about it
16:05:03 <geekosaur> o.O you're not supposed to be on irc right now :p
16:05:54 <applicative> geekosaur: but my answers are getting more and more helpful
16:06:53 <applicative> where's all those pipes questions there were earlier
16:07:33 <AnalogFile> ping quchen
16:07:33 <anon34928793> why are conduits so much better than pipes? :D
16:07:47 <a3f> ReinH: You still there :( ? Had to do an errand :/
16:07:49 <jhormuz> Is there an existing way to toggle a transformation on and off, something that has signature (a->a)->Bool->(a->a) (I can easily write this a "f transform condition = if condition then transform else id", but I rather than writing this over and over again, I was curious if something exists....  Hoogle implies not, but perhaps I am missing something.
16:09:41 <anon34928793> well, that can be reduced to a -> Bool -> a or Bool -> a -> a ... I imagine you'd find a lot for those
16:10:16 <S11001001> > mempty :: Int -> Int
16:10:17 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:10:17 <lambdabot>    arising from a use of...
16:10:47 <jhormuz> hmmm, that is if itself.
16:11:03 <jhormuz> almost
16:11:23 <S11001001> ah that is the wrong instance anyway.
16:11:41 <jhormuz> assert
16:11:47 <anon34928793> alternative instance?
16:11:53 <anon34928793> monadplus?
16:11:54 <S11001001> monoid
16:12:28 <anon34928793> for (a->a)->Bool->(a->a)?
16:12:34 <S11001001> iirc it's the forall a b. Monoid a => Monoid (a -> b) instance
16:12:46 <benmachine> S11001001: Monoid b => Monoid (a -> b)
16:12:56 <benmachine> you combine the results of the functions
16:13:07 <S11001001> benmachine: oh that sounds better
16:13:08 <benmachine> the one you were looking for was probably the one provided by the Endo newtype
16:13:18 <S11001001> benmachine: yeah; I didn't know whether it was the default too
16:13:29 <benmachine> S11001001: I think it was once, but nowadays we have this one instead
16:13:30 <S11001001> anyway Category c => c a a -> Bool -> c a a would suit
16:14:21 <benmachine> so would MonadReader r m => m r -> Bool -> m r
16:14:27 <benmachine> both of doubtful utility, if you ask me :P
16:15:14 <anon34928793> actually, they're probably the same thing
16:15:41 <arkeet> I'm pretty sure those don't exist.
16:15:56 <arkeet> well, the category one sure.
16:16:00 <arkeet> @let bool f t b = if b then t else f
16:16:01 <lambdabot>  Defined.
16:16:08 <arkeet> :t bool mempty
16:16:08 <benmachine> jhormuz: I don't know of anything more concise than the if you mentioned; there's a proposal at the moment to add 'bool' so you can write it as 'bool transform id'
16:16:09 <lambdabot> Monoid t => t -> Bool -> t
16:16:15 <arkeet> ^
16:16:23 <benmachine> or possibly 'bool id transform'
16:16:29 * benmachine worries about the difference
16:16:36 <arkeet> the false case comes first.
16:16:45 <benmachine> arkeet: so you claim
16:16:50 <hpaste> a3f pasted “arg parser” at http://lpaste.net/93006
16:16:54 <arkeet> the False constructor comes first.
16:17:06 <jhormuz> fair enough....Not a bit deal, it is just a one line definition at the beginning of any file.
16:17:21 <flebron> If I say f x = 2 * x, do you guys easily see what ((,) <*> f) 4 is?
16:17:33 <arkeet> sure.
16:17:40 <a3f> could someone help me in fixing the error message? I marked the part that throws the error
16:17:48 <quchen> AnalogFile: pong
16:18:07 <arkeet> flebron: just remember g <*> f x = g x (f x)
16:18:10 <arkeet> er,
16:18:12 <arkeet> (g <*> f) x
16:18:18 <arkeet> it's the S combinator.
16:18:21 <flebron> that's in the reader monad, right?
16:18:30 <arkeet> applicative, not monad.
16:18:33 <flebron> err, yeah
16:18:36 <arkeet> but sure.
16:18:40 <arkeet> @src (->) ap
16:18:41 <lambdabot> Source not found.
16:18:42 <arkeet> heh.
16:18:44 <arkeet> duh
16:18:53 <arkeet> > (f <*> g) x :: Expr
16:18:54 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
16:18:55 <lambdabot>    arising from a us...
16:18:56 <ion> (The Monad instance has (f <*> g) x = f (g x) x, too.)
16:18:57 <joelteon> :t liftA2 ($)
16:18:58 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
16:19:02 <arkeet> ion: Monad doesn't have <*>  =(
16:19:07 <ion> err
16:19:08 <joelteon> :t liftM2 ($)
16:19:08 <flebron> @src ((->) a) ap
16:19:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:19:08 <arkeet> it has ap
16:19:09 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
16:19:09 <ion> =<< :-D
16:19:13 <ion> I’m brainfarting.
16:19:29 <arkeet> @src (->) (>>=)
16:19:29 <lambdabot> f >>= k = \ r -> k (f r) r
16:19:51 <arkeet> types aren't quite the same though
16:19:51 <AnalogFile> quchen: Hi. I stumbled on AMP today. Great idea. I was reading the thread on ticket 8004. I see a little possible problem with silencing the warnings just by hiding the prelude imports.
16:19:56 <arkeet> ...or are they
16:20:04 <arkeet> :t (=<<)
16:20:05 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:20:10 <flebron> arkeet: would you prefer that, or \x -> (x, f x)?
16:20:25 <quchen> AnalogFile: Do you mean the way it's currently implemented, or the new patch I sent (and that wasn't merged yet)?
16:20:26 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
16:20:26 <arkeet> flebron: I think the latter is more readable.
16:20:27 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
16:20:27 <benmachine> there's some near-equivalence between (>>=) and (<*>) for functions that involves a flip somewhere
16:20:31 <ion> @type (=<<) `asAppliedTo` (undefined :: a -> b -> c)
16:20:32 <lambdabot> (a -> b -> c) -> (b -> a) -> b -> c
16:20:32 <arkeet> flebron: I also wouldn't mind (id &&& f)
16:20:43 <AnalogFile> quchen: in particular those names will also be injected by any monad even if it comes from somewhere else than the Prelude.
16:20:48 <quchen> AnalogFile: In any case, unfortunately you cannot silence the warnings by "hiding (join)"
16:20:49 <arkeet> :t (=<<) . flip
16:20:49 <lambdabot> (a1 -> a -> c) -> (a1 -> a) -> a1 -> c
16:20:50 <benmachine> @type \f g -> flip f =<< g
16:20:51 <lambdabot> (a1 -> a -> c) -> (a1 -> a) -> a1 -> c
16:20:54 <flebron> oh that's the one, i was thinking of *** and it wouldn't type
16:20:55 <a3f> any good souls :( ?
16:21:17 <anon34928793> break out the arrow operators.. wheee
16:21:33 <arkeet> a3f: putting the full error message would be good.
16:22:21 <a3f> arkeet: I wrote it in a comment in the file, you can;t miss it
16:22:29 <arkeet> a3f: that's not the full error message.
16:22:37 <a3f> well
16:22:39 <a3f> sec
16:22:40 <AnalogFile> quchen: it may be harder to implement, but those warnings should also prepare anyone who uses a monad AND have defined, say, join, in his module. even if it explicitly list prelude imports
16:22:43 <flebron> anon34928793: unfortunately the only arrows i know how to use are tuples :p
16:23:11 <chrisdone> the only arrow i saw in the wild was in hakyll
16:23:18 <chrisdone> and that was then changed to a monad
16:23:29 <anon34928793> monads are arrows :P
16:23:48 <quchen> AnalogFile: I don't follow. There are two types of warnings generated, "missing parent class" and "clash with future Prelude name". I assume you're referring to the latter?
16:24:12 <chrisdone> anon34928793: not in that sense
16:24:33 <quchen> AnalogFile: The thing is that Prelude will export functions named join/<*>/pure in the future, so the warnings tell users that in 7.10 a module will generate "ambiguous reference" errors if not prepared for the switch.
16:24:36 <arkeet> a3f: well, openProcess returns an IO (Ptr ())
16:24:56 <a3f> arkeet: I know
16:24:56 <quchen> AnalogFile: That's semi-independent of making Applicative a superclass of Monad though.
16:24:57 <arkeet> a3f: while your other cases give IO ()
16:25:03 <a3f> arkeet: oh
16:25:04 <anon34928793> fair enough; arrows are relatively hard to find outside the frp crowd
16:25:05 <AnalogFile> quchen: yes. Tibbe suggested they should be silenced if you have somehow excluded them from prelude imports, and the thread there says you recently added a patch for that
16:25:06 <arkeet> a3f:
16:25:08 <arkeet> :t void
16:25:09 <lambdabot> Functor f => f a -> f ()
16:25:18 <ill_logic> Is there a way to actually see the identifying name (ie useful for cabal) of a package when looking on hackage.haskell.org?
16:25:24 <a3f> arkeet: do all cases have to return the same even if I don't make use of the return value ?
16:25:28 <arkeet> yes
16:25:39 <arkeet> what would the type of main be?
16:25:43 <quchen> AnalogFile: Yes, the new patch allows you to silence warnings by having an explicit Prelude import list.
16:25:45 <arkeet> it can't both be IO () and IO (Ptr ())
16:25:47 <ill_logic> oh I suppose it would be on the top-left
16:25:47 <anon34928793> ill_logic: it should be at the top of the page
16:26:03 <a3f> arkeet: can't I just somehow add a return IO () at the end ?
16:26:12 <quchen> AnalogFile: "import Prelude (map, concat)" for example will silence AMP clash warnings for that module.
16:26:12 <arkeet> a3f: void blah is the same as do { blah; return () }
16:26:14 <anon34928793> well you can just jump the ptr
16:26:19 <anon34928793> dump*
16:26:47 <arkeet> a3f: aside, let foo = ... in foo  is the same as just ...
16:26:49 <arkeet> :p
16:26:49 <applicative> chrisdone: i think the arrow you saw in the wild is extinct now.
16:27:03 <AnalogFile> quchen: yes. but isn't it just as important to prepare users that have join/<*>/pure in their module not only for the prelude conflict but also for the conflict with any monad?
16:27:27 <AnalogFile> quchen: may be a later phase, however.
16:27:31 <chrisdone> applicative: i dunno whether jasper removed the instance or just deprecated it
16:27:36 <a3f> arkeet: The thing is I am adding multiple options, like specify by pid, wndclass, wndtitle
16:27:47 <chrisdone> applicative: but yeah, effectively dead
16:28:01 <a3f> and I don't want to repeat same code in each case, I just want to calculate the handle and process everything after the case switch
16:28:05 <arkeet> a3f: ok, then matching on 1-element lists isn't going to work.
16:28:23 <a3f> they are mutually exclusive
16:28:25 <quchen> AnalogFile: Oh, you mean when the AMP goes through and you have a local "join" function, and also Monad instances in the same module? I don't think that's much of a problem
16:28:52 <a3f> arkeet: How should I do it ?
16:29:06 <arkeet> do what?
16:29:12 <AnalogFile> quchen: why not?
16:29:37 <ill_logic> pretty printing is much more straightforward in Python
16:29:58 <a3f> arkeet: get hndProc to store the value so i can use it later
16:30:46 <applicative> ill_logic: what!?
16:30:56 <applicative> > text "ill_logic" $$ text " let's pretty print"
16:30:57 <lambdabot>   ill_logic
16:30:58 <lambdabot>   let's pretty print
16:31:06 <anon34928793> kill the heretic!
16:31:09 <AnalogFile> quchen: isn't changing the prelude a haskell level change too? or are you guys changing GHCs prelude before AMP goes through the language report phase, in which case it's a separate issue, yes.
16:31:28 <ill_logic> applicative: in Python, it's pprint.pprint(any_old_thing)
16:31:36 <ill_logic> and it at least tends to give a sane output
16:31:59 <geekosaur> AnalogFile, there are separate Prelude-s for h98, h2010, and ghc standard
16:32:02 <quchen> AnalogFile: I think class method names are resolved in the AMP's favour here. If you have a function in the "where" part of the class, the name is assumed to be of that class, and it won't complain about a name clash. In other words, local function "join" and having a "instance Monad where join = ..." might not be a problem.
16:32:12 <applicative> ill_logic: import Text.Groom ?
16:32:13 <ill_logic> in my case, I want to print out a list, formatted in a more legible manner
16:32:17 <quchen> Also yes, the AMP is something that will hopefully make it into the report.
16:32:37 <applicative> @type groom
16:32:38 <lambdabot> Not in scope: `groom'
16:32:44 <applicative> :(
16:33:06 <ill_logic> installing groom
16:33:07 <AnalogFile> quchen geekosaur: I see.
16:33:26 <arkeet> a3f: sorry, gotta run.
16:33:28 <applicative> ill_logic: it'll take a while, it presupposes haskell-src-exts
16:33:46 <a3f> arkeet: Ok, I will be here
16:33:46 <ill_logic> No price is to high for well groomed text.
16:33:52 <a3f> arkeet: waiting .. ;(
16:34:25 <geekosaur> also ghc is where proposed language and library changes get tested
16:34:50 <quchen> AnalogFile: Got a guest now though, you caught me in his shower break ;-) I'll be back tomorrow afternoon, or you can send me an email, dluposchainsky@gmail.com
16:35:12 <chrisdone> @hoogle ord
16:35:12 <lambdabot> Prelude class Eq a => Ord a
16:35:12 <lambdabot> Data.Ord class Eq a => Ord a
16:35:12 <lambdabot> Prelude data Ordering :: *
16:35:22 <ill_logic> looking at a blog post, it looks like it's exactly what I want. thanks applicative
16:35:29 <AnalogFile> quchen: ok. but you have clarified my doubt that it's not going to be a problem. thanks.
16:35:31 <chrisdone> ah, it'll be in data.char
16:36:04 <anon34928793> depends on what kind of ord you want
16:37:50 <chrisdone> the parse error messages from cassava suck
16:38:29 <chrisdone> i'm trying to parse an 11mb file and it errors with "parse error (endOfInput) at "1379179759\tLost …" and includes the whole file in the error
16:39:02 <anon34928793> that's absurd
16:39:49 <copumpkin> chrisdone: wow :/
16:40:43 <danilo2> edwardk: I've applied the StateT to triffecta - adding "lift" to all the basic parser combinators (as enthropy suggested).
16:56:54 <chrisdone> csv-conduit parses the file just fine. fortunately the apis are pretty much identical
16:59:41 <tibbe> chrisdone: please file a bug report, at least we should cut off the output somewhere
17:07:14 <jfischoff> syb stuff is so slow. I'm having to pull out everything I wrote :(
17:09:35 <tibbe> @tell chrisdone please file a bug about your cassava experience at https://github.com/tibbe/cassava/issues
17:09:35 <lambdabot> Consider it noted.
17:11:41 <tikhon> hey, has anyone here used the language-python package?
17:20:54 <tibbe> chrisdone: I improved the message some
17:21:38 <FreeFull> Is there any way to have ghci print all functions/values in scope, together with their types?
17:21:59 <geekosaur> :browse
17:22:49 <FreeFull> Oh, right
17:23:20 <FreeFull> Is there any way to find all functions/values whose type matches some string?
17:24:08 <geekosaur> I don't think so. there are plugins that can add hoogle queries, but that's not the same thing
17:24:30 <FreeFull> Yeah, hoogle will just search in its database rather than in the current scope
17:25:09 <benmachine> FreeFull: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-September/011606.html
17:25:54 <benmachine> FreeFull: not sure where the code is for that, but maybe you'll have better luck finding it than me
17:26:12 <Thulsadum> it is perfectly safe to use forkIO heavily beacause haskell manges the spooling, am it geting it right?
17:26:24 <Thulsadum> *manages
17:26:43 <sirspazzolot> so I think I'm understanding curried functions and partial application, but I don't want to find out that I don't later on. I've read the LYAH section; can anyone recommend another brief explanation?
17:26:45 <benmachine> Thulsadum: I don't know quite what spooling means but I'm aware that it's possible to have millions of forkIO threads without ill effects
17:27:22 <FreeFull> benmachine: I have looked into it before, the problem is that ghci doesn't expose a convienient way to get the output of one of its commands
17:27:53 <FreeFull> sirspazzolot: Just write code
17:27:56 <tikhon> sirspazzolot: I don't know of any particular article to read, but it's a pretty simple concept. I assume you're already familiar with lambdas, right?
17:28:05 <sirspazzolot> tikhon: yeah
17:28:10 <Thulsadum> benmachine: yeah, i asked my self, whether i need to have a managing thread, which manages the worker threads in a tcp server. and then realized, that haskell does it for me
17:28:19 <sirspazzolot> FreeFull: i've always had a problem getting around to that heh
17:28:41 <sirspazzolot> alright, I'll proceed. thanks guys
17:29:02 <FreeFull> sirspazzolot: It exposes a lot of problems in your thinking, and isn't the whole point of learning Haskell to write code with it? =P
17:29:02 <tikhon> sirspazzolot: then the basic idea is like this: to have a function with two argument like (f a b = a + b), what you actually do is have a function (f = \ a -> \ b -> a + b). That is, the function takes one argument and returns a lambda for the second one.
17:29:34 <tikhon> You can actually use that exact syntax, and you get exactly the same result as f a b = ...
17:32:02 <sirspazzolot> tikhon: actually, that does help a little bit
17:32:14 <sirspazzolot> heh
17:32:41 <tikhon> at the very least, it should help you figure out what gets returned when you only supply some of a function's arguments
17:47:37 <anon459802> any idea why the ghc simplifier would be doing stuff like this: Result size of Simplifier = {terms: 2,964,696, types: 807,818, coercions: 9,888}?
17:48:16 <edwardk> If anyon feels up to a proof-reading pass, I just posted https://www.fpcomplete.com/user/edwardk/online-lca
17:51:00 <copumpkin> ooh
17:51:57 <edwardk> copumpkin: i figured it was time to write it up as something other than a bunch of slides
17:52:44 <copumpkin> yeah :) glad to see it get out there
17:52:49 <copumpkin> I have so much agda for that it's ridiculous
17:52:51 <copumpkin> and it's all a huge mess :P
17:52:57 <anon459802> well, watching the simplifier at work is hypnotic
17:53:03 <edwardk> copumpkin: heh
17:54:13 <copumpkin> oh so are you picking up that revision control monad again?
17:55:45 <tikhon> revision control monad?
17:55:54 <edwardk> copumpkin yeah
17:56:02 <copumpkin> sweet
17:56:13 <edwardk> tikhon: old project for a way to get nice incremental and parallel computation
17:56:13 <copumpkin> always wanted to see that come to fruition
17:56:26 <tikhon> ah
17:56:32 <tikhon> sounds pretty interesting
17:56:48 <tikhon> I saw three-way merge as one of the applications in your article and got interested
17:57:52 <tikhon> I've been playing with some version control stuff myself, but at a slightly higher level; this might come in useful
18:01:16 <copumpkin> edwardk: is your old code up somewhere?
18:01:41 <edwardk> copumpkin: github.com/ekmett/revisions
18:04:51 <ParahSail1n> ghc 7.8 is going to have javascript backend?
18:05:38 <hrefchef> A quick google search didn't reveal anything about that, Parah. And that sounds odd if it is true.
18:06:06 <m3ga> ParahSail1n: yes, i believe so
18:06:47 <anon459802> through ghcjs ...
18:07:03 <geekosaur> yes, ghcjs is slated to be in 7.8.
18:07:34 <anon459802> I really hope it's changed from the ghcjs I remember.
18:08:24 <geekosaur> I don't think anyone considers ghcjs to be "done"
18:09:09 <haasn> waaaaaaaaaaaaait a minute
18:09:13 <haasn> it's *IN* ghc now?
18:09:16 <haasn> normal ghc?
18:09:41 <hrefchef> Oh, I misinterpretted what he meant. I thought he was claiming ghc would be rewritten in Javascript.
18:09:43 <user123abc> I have a data type whose constructors all take identical arguments
18:09:46 <hrefchef> Too drunk to be doing this.
18:09:56 <user123abc> given a value of the type, I want to extract those arguments regardless of which constructor was used to create it
18:10:01 <user123abc> http://lpaste.net/new/haskell
18:10:30 <user123abc> this attempt to do it results in "Parse error in pattern: _"
18:10:37 <anon459802> user123abc: you posted a link to an empty paste
18:10:44 <user123abc> is this something I can do, or do I have to enumerate all constructors?
18:10:45 <user123abc> derp
18:10:54 <user123abc> http://lpaste.net/2274513761115045888
18:12:37 <anon459802> the only way out of a type is via its constructor unless you want to play around in coercion land
18:13:12 <anon459802> you could define a typeclass to support all of that in one operation, but at some point, you need to go through the constructor
18:14:01 <user123abc> seems like an artificial limit
18:14:11 <user123abc> where is coercion land?
18:14:57 <hrefchef> Due northwest of functor avenue.
18:15:06 <danilo2> Is there in Haskell an equivalent to Functor or Travesable, that works on objects of Kind * (and not *->*) ?
18:15:23 <enthropy> user123abc: rearrange your data as   data Tag = A | B | C | D;  data Tagged a = Tagged Tag a
18:15:33 <shachaf> danilo2: Not really.
18:15:45 <shachaf> danilo2: But lens is pretty much about that sort of thing.
18:16:15 <danilo2> shachaf: really? lens? I was thinking lenses are like getters or setters + few additional things
18:16:30 <elifrey> danilo2: and traversables :)
18:16:31 <shachaf> Yes, but lens isn't about lenses.
18:17:05 <user123abc> enthropy, how would that be in the context of my types?
18:17:11 <user123abc> not sure how it would for me
18:17:16 <user123abc> would work
18:17:28 <enthropy> did you define Bopt64?
18:17:43 <enthropy> Bop64 rather
18:17:50 <elifrey> danilo2: lens lets you say goofy things like: traverseOf both (`Map.lookup` myMap) ( key1, key2 )
18:18:05 <user123abc> I ... think so
18:18:07 <user123abc> http://lpaste.net/2274513761115045888
18:18:10 <user123abc> that's the definition, no?
18:18:42 <enthropy> then you can change it to something that makes your function that extracts the Val a bit shorter
18:19:23 <danilo2> elifrey:I see, but I think I do not need such tool like lenses yet.  simple need to make instance of Traversable of smthing, which Kind is *.
18:19:48 <danilo2> elifrey: Or maybe lenses are the way to go, but I'm afraid of learning them deeply ;)
18:20:23 <elliott> Traversals are just first-class Traversable instances.
18:20:32 <elifrey> danilo2: hold on, I'm looking for the right traversable, but Im p. sure the same trick I just did works for traversing over the bytes in a bytestring too
18:20:53 <elifrey> or other containers of kind *
18:21:47 <haasn> elliott: traversals of the form forall a b. Traversal (t a) (t b) a b -- you mean?
18:22:00 <user123abc> ah, enthropy, I think I see what you mean
18:22:00 <elliott> well, the question is literally about traversing something with kind *.
18:22:17 <user123abc> yeah, thanks
18:24:49 <elifrey> interesting
18:25:15 <elifrey> let myMap = M.fromList [ ('a', 'z'), ('b', 'x') ]
18:25:24 <elifrey> traverseOf chars (`M.lookup` myMap) (fromString "ab")
18:25:58 <elifrey> I get a type error 'eractive>:12:1:
18:25:58 <elifrey>     No instance for (IsByteString t0) arising from a use of `it'
18:26:09 <shachaf> "chars" :-(
18:26:17 <shachaf> Such a bad name for an evil operation.
18:26:22 <elifrey> hah
18:26:36 <Iceland_jack> @ty chars
18:26:44 <elifrey> do I need the codomain of my map to be bytes?
18:27:03 <shachaf> chars is defined on ByteStrings.
18:27:13 <elifrey> sure
18:27:41 <elifrey> ah
18:27:41 <shachaf> Oh, wait, that thing is a ByteString?
18:27:51 <elifrey> I just was missing a type anotation :P
18:28:09 <elifrey> it did not know what fromString to choose
18:28:15 <elifrey> traverseOf chars (`M.lookup` myMap) (fromString "ab" :: ByteString)
18:28:25 <shachaf> Please don't use chars like that. :-(
18:28:53 <elifrey> it was just to show how you can traverse over a container of kind *
18:29:06 <elifrey> would you aprove more of bytes?
18:29:11 <shachaf> OK, but either use ByteString with Word8 or Text with Char.
18:29:39 <shachaf> Sure, bytes is fine.
18:29:40 <elifrey> fair enough
18:30:23 <danilo2> elifrey: where does function "chars" come from ?
18:30:36 <shachaf> See what you've done?
18:30:43 <elifrey> Data.ByteString.Lens
18:31:04 <elifrey> but as shachaf points out, please don't actually use it :)
18:31:10 <shachaf> Data.ByteString.Char8 ought to be taken out of the standard library.
18:31:24 <shachaf> People just don't care.
18:31:41 * haasn curses Data.ByteString.Char8.Lens
18:31:51 <danilo2> hehe :D ok I will not :)
18:32:17 <haasn> shachaf: Every time I've had to track down an encoding issue in darcsden it turned out to be some .Char8 import in one of its dependencies...
18:32:19 * haasn grumbles
18:33:20 <shachaf> Well, who cares about languages that aren't English, right?
18:33:39 <Clint> i almost always speak english in utf-8
18:34:39 <danilo2> elifrey: So If I want to make my custom structure of Kind * be traversable I should make it instance of something like Simple Traversal ... ?
18:34:57 <Maxdamantus> You'd be naïve not to.
18:34:59 <shachaf> No. There is no class for it.
18:35:23 * haasn thinks .Char8.pack should actually just be encodeUtf8
18:35:23 <shachaf> Traversal is a type (synonym), not a class.
18:35:26 <elifrey> shachaf: is there some magic TH for making Traversals?
18:35:35 <haasn> better than what it is right now
18:35:36 <shachaf> elifrey: What sort of magic are you after?
18:35:59 <shachaf> It's no harder than writing a Traversable instance.
18:36:36 <Saizan> danilo2: you'd define a Traversal for it
18:36:39 <elifrey> shachaf: I mean you can get Lens for free with TH, I don't imagine you can magically make a Traversal tho
18:36:50 <shachaf> elifrey: A Traversal for what?
18:37:02 <shachaf> You can get an (affine) Traversal for things that are part of a sum.
18:37:12 <shachaf> If you're looking for something like DeriveTraversable, no, that doesn't exist.
18:37:30 <danilo2> Saizan, elifrey, shachaf: Ok, so I've got datatype data A = B A | C and want to make it traversable - what should I do ?
18:37:32 <shachaf> (And it would be trickier in general than DeriveTraversable is, because it can't rely on using a type class recursively.)
18:37:46 <shachaf> You can't make it an instance of Traversable.
18:38:02 <shachaf> The first step is figuring out what you want. What's the type of the thing you want?
18:38:32 <danilo2> I want to have a function "traverselike" of type (t->t) -> t -> t
18:38:49 <Saizan> danilo2: what should we consider the elements to "traverse" there the recursive occurrences?
18:39:04 <Saizan> missed a comma
18:39:30 <shachaf> What you're saying is too vague for me to help. :-( Where did "t" come from? What is it?
18:39:46 <elifrey> danilo2: you need some thing "in" your traversal, the datatype you provided does not have something "in" it
18:39:50 <Saizan> t is presumably A
18:40:05 <danilo2> Saizan, shachaf: Ok, I'll try to clear it :
18:40:21 <Saizan> danilo2: can you show the actual type you're working with? it'd provide us with more context
18:40:37 <shachaf> Saizan: That still doesn't look like a traversal in that case.
18:40:48 <shachaf> I'd rather not presume these things too much because expressing a question like that clearly is a good exercise.
18:41:09 <danilo2> lets say I've got data Expr = Tuple [Expr] | Var String. Now I want to have function traverselike, which for tuple is defined as: traverse f (Tuple items) = f (Tuple (map t items))
18:41:39 <Saizan> danilo2: map f, i assume?
18:42:00 <danilo2> ouch, moment, there was an error
18:42:16 <danilo2> lets say I've got data Expr = Tuple [Expr] | Var String. Now I want to have function traverselike, which for tuple is defined as: traverse f (Tuple items) = f (Tuple (map (traverse f) items))
18:42:20 <danilo2> now it is good :)
18:42:49 <shachaf> You might be best off parameterizing Expr on, say, String in the first place, incidentally.
18:43:16 <Saizan> danilo2: how would it be defined on Var?
18:43:37 <danilo2> shachaf: Parametrize it only to be able to create Traversable instance? I'd rather create my custom typeclass then, i thin :/
18:43:41 <shachaf> Anyway, traverse doesn't really look like a Traversable instance at all, even disregarding kinds, so I'm confused.
18:44:03 <shachaf> No, parameterize it in order not to restrict it to String.
18:44:04 <danilo2> Saizan:  traverse f (Var Name) = f (Var Name)
18:44:30 <Saizan> yeah, i'm not sure if this, suitably generalized, would make a traversal
18:44:38 <elifrey> danilo2: traverse f (Var name) = Var (f name) ?
18:44:56 <danilo2> elifrey: no, traverse f (Var Name) = f (Var Name)
18:45:20 <danilo2> elifrey: traverse f (Tuple items) = f (Tuple (map (traverse f) items))
18:45:21 <Saizan> it's something more like what you'd find in syb, e.g. everywhere
18:45:39 <Saizan> (being the name of a combinator)
18:45:41 <elliott> Saizan: well, everywhere is kind of a traversal. sort of.
18:45:44 <elliott> but this is weird.
18:45:51 <elliott> well, I guess everywhere itself isn't...
18:45:55 <danilo2> shachaf: Sorry, I dont understand it: "No, parameterize it in order not to restrict it to String." :(
18:46:19 <elifrey> danilo2: he means so you can vary the type of things inside a Var
18:46:26 <shachaf> Never mind.
18:46:29 <chrisdone> shachaf: are you british?
18:46:56 <shachaf> Should I be?
18:46:58 <chrisdone> do americans say 'best off'?
18:46:59 <danilo2> elifrey: Ah, O, but as you can see, I'm not traversing over the String inside Var, I'm traversng over the Expr instances
18:47:24 <tikhon> I think "best off" is a reasonably common phrase here
18:47:32 <Saizan> danilo2: it was a tangential comment, not directly related to the Traversable issue
18:47:59 <elifrey> danilo2: ah, yes, that is certainly not a traversal
18:48:14 <Saizan> danilo2: anyhow the conclusion is that what you're describing wouldn't make a lawful Traversable instance, even without the kind issues
18:48:25 <Saizan> danilo2: so just have your own combinator :)
18:48:41 <shachaf> Starting with the "it type-checks" law.
18:48:59 <shachaf> lens does have some things that might be relevant, maybe in Control.Lens.Plated.
18:49:30 <bennofs> @ty \f -> fmap mconat . traverse f
18:49:31 <Saizan> well, i imagine you could make it typecheck by going from map to mapM and similar, it wouldn't be a stretch
18:49:32 <lambdabot>     Not in scope: `mconat'
18:49:32 <lambdabot>     Perhaps you meant one of these:
18:49:32 <lambdabot>       `mconcat' (imported from Data.Monoid),
18:49:36 <bennofs> @ty \f -> fmap mconcat . traverse f
18:49:37 <lambdabot> (Applicative f, Monoid b) => (a -> f b) -> [a] -> f b
18:49:50 <danilo2> Saizan, elifrey: heh, thank you :) Sorry for misleading you, because I was not looking for "travesable" but something else I guess :)
18:50:28 <elifrey> danilo2: no wories, it was fun anyway
18:51:24 <danilo2> elifrey: :)
18:52:36 <scripty> Hello
18:52:48 <shachaf> In particular, maybe transformOf is relevant?
18:56:59 <Saizan> yeah, or just transform
18:57:36 <Saizan> danilo2: http://hackage.haskell.org/packages/archive/lens/3.9.1/doc/html/Control-Lens-Plated.html#v:transform
18:59:05 <Saizan> the docs are a bit vague, but the implementation is telling
19:02:48 <danilo2> Saizan: yes, transform looksl ike what I was looking for!
19:02:49 <danilo2> :>
19:03:54 <danilo2> Saizan : but does it pay off to make "lenses" a dependency only for using such function? I should probably simply create a function and call it, shouldnt I?
19:04:45 <edwardk> danilo2: i can't tell you where the threshold is for when to bring lens into your project. i will say that when i do bring it in i gradually find more and more places i can apply it
19:05:29 * elifrey agrees with edward
19:05:50 <elliott> you shouldn't make "lenses" a dependency for anything. that package is awful.
19:05:52 <elliott> lens on the other hand is great.
19:05:58 <edwardk> =)
19:11:06 * haasn starts projects by importing Control.Lens, and then removes that line if he ends up not using lenses
19:11:41 <danilo2> edwardk: Ok, I think that it is fair enough to bring it into a project :)
19:12:05 <haasn> It's so liberating to get all of the useful imports in one line like that, too
19:12:20 <haasn> like, I no longer have to do crazy things like import qualified Data.Foldable as F
19:12:59 <edwardk> i still bring in foldable, since lens doesn't re-export it
19:13:15 <haasn> Well, for stuff like mapMOf folded
19:13:19 <haasn> rather than F.mapM
19:13:32 <elifrey> comming soon, lens subsumes transformers and mmorph
19:13:32 <edwardk> *mapM_
19:13:44 <haasn> yes
19:14:10 <elliott> mapMOf folded is a horrific thing to write
19:14:33 <elliott> edwardk: we should strip out the Control. from lens modules like the cool packages do.
19:14:45 <elifrey> @ty mapMOf folded
19:14:46 <lambdabot> (Monad m, Foldable f, Indexable Int p, Contravariant (WrappedMonad m)) => p b (m b) -> f b -> m (f b)
19:14:53 <haasn> import Lens.Lens
19:15:16 <haasn> then we can be as cool as Data.Data.Data
19:15:37 <arkeet> :t mapMOf_ folded
19:15:38 <lambdabot> (Monad m, Foldable f, Indexable Int p) => p a (m r) -> f a -> m ()
19:15:58 <arkeet> :t traverseOf folded
19:15:59 <lambdabot> (Applicative f, Foldable f1, Indexable Int p, Contravariant f) => p b (f b) -> f1 b -> f (f1 b)
19:16:00 <benmachine> coming soon, lens subsumes haskell, becomes lenskell
19:16:06 <arkeet> :t folded
19:16:14 <arkeet> :t Control.Lens.folded
19:16:15 <lambdabot> (Applicative f1, Foldable f, Indexable Int p, Contravariant f1) => p a (f1 a) -> f a -> f1 (f a)
19:16:20 * benmachine votes in favour of calling the module Lens
19:16:34 <arkeet> Control is too long tot ype every time =(
19:16:36 <edwardk> not in a hurry to break backwards compatibility there
19:16:44 <arkeet> and youc an tell how bad I am at typing.
19:16:47 <arkeet> oops
19:17:01 <edwardk> the utility falls below the breaking backwards compatibility threshold for me
19:17:06 <arkeet> I agree.
19:17:25 <arkeet> module Lens (module Control.Lens) where ...
19:18:31 <elifrey> what are you talking about, Haskell modules are so dangerously underqualified, we need com.github.ekmett.control.lens
19:18:56 <edwardk> io.github.ekmett.control.lens
19:19:08 <edwardk> don't want users taking up valuable github.com namespace
19:19:34 <carter> yeah
19:19:47 <carter> we should enrich the package name space a bit...
19:21:20 <elliott> edwardk: we'll just do it in lens 4.0.
19:21:48 <edwardk> so, how should we do bitraversals?
19:21:54 <danharaj> so when are lens errors going to be readable
19:22:39 * S11001001 votes for LensesFoldsAndTraversals.Lens
19:22:41 <mgsloan> Lens should pioneer the usage of a -XNamespaceOperators extension, so that you can do "import :~>"
19:22:57 <edwardk> mgsloan: =)
19:23:18 <edwardk> mgsloan is just bitter about the loss of the :=> alias for Traversal'
19:23:45 <mgsloan> It's true.  It made more sense back when they were SimpleTraversal
19:24:05 <mgsloan> First time operators were /removed/ from lens ;)
19:24:11 <mgsloan> (well, that's not quite true I'm sure)
19:24:42 <elifrey> mgsloan: what are these NamespaceOperators?
19:24:56 <carter> elifrey: hey!
19:25:08 <elifrey> carter: howdy!
19:25:14 <mgsloan> elifrey: A new extension that I'm sure everyone will be behind adding to GHC once they see this awesome use case
19:25:36 <elifrey> mgsloan: sell me
19:25:52 <mgsloan> elifrey: Not gonna, I think it's an awful idea :)
19:25:57 <carter> mgsloan: using kmettian tactics, we'lll get all sort of features into ghc
19:25:58 <carter> mwahaha
19:26:28 <mgsloan> Unless they're used as module-level operators on first class modules, that could be pretty neat
19:26:34 <elifrey> mgsloan: I can't even make heads or tails of "import :~>"
19:27:09 <mgsloan> elifrey: The idea is to extend the syntax for namespaces to also include operator names :)
19:27:20 <mgsloan> In order to make "import Control.Lens" as short as possible
19:27:57 <mgsloan> Because those 9 extra bytes _really_ matter
19:29:30 <elifrey> mgsloan: psh, everybody knows you should optomize for entropy in your modules, increasing the character-space is short sited
19:30:27 <mgsloan> carter: Hmm, yeah, could be a good strategy!
19:30:28 <mgsloan> /me starts writing up how declaration-local imports would be good for things like lens
19:31:41 <mgsloan> (well, I'm not actually going to propose that anytime soon - but I do think something along those lines would be very nice - as long as the import is also at the top of the module)
19:33:39 <benmachine> mgsloan: declaration-local everything!
19:34:08 <benmachine> mgsloan: also, fyi, you can call modules ≡ in Agda
19:34:23 * benmachine sometimes renames Relation.Binary.PropositionalEquality to that
19:35:09 <mgsloan> Benmachine: One step at a time, now :D.  But I agree, that would be elegant.  Not sure what to do about instances, but weird stuff like having a local typeclass should be a sensible, though useless, thing
19:36:06 <mgsloan> I think the only thing a local typeclass would be good for would be to make it impossible to call your function (I suppose it ought to be illegal for it to appear in the type of the function)
19:36:30 <copumpkin> edwardk:  means that we can walk the spine of two random access lists of the same length at the same time in lock-stop"
19:36:40 <edwardk> derp
19:37:16 <edwardk> fixed
19:38:05 <mgsloan> Oh, cool, you published the LCA thing!  I've been kinda wondering / trying to remember how that would work ever since I heard about it!  Neat
19:38:28 <edwardk> i was going to use skew binary in a subsequent post
19:39:10 * elifrey needed to see skew binary at a slower pace than in edwardk's talk to grok it
19:39:26 <mgsloan> I suppose the lca package has been around for a while, so I coulda looked there!
19:39:34 <fryguybob> edwardk: "just a a list..."
19:40:43 <carter> mgsloan: if module names were semi first class
19:41:04 <carter> we'd have a cool way of handling multiple name clash libs
19:41:05 <carter> or something
19:42:30 <mgsloan> Hmm, yeah, or it might make something like "Eternal Compatibility in Theory" feasible
19:42:54 <mgsloan> (not that I think that proposal is a good idea - it ignores pretty much everything but the versioning of functions)
19:43:26 <elifrey> mgsloan's typeclass whosiewhatsit proposal does sound suspiciously like first class modules. I know there's a lot of overlap with typeclasses and first class modules, but I would not be displeased by having them both.
19:44:19 <mgsloan> elifrey: True true.  The big difference being that typeclasses / instances wouldn't belong in first class modules
19:44:49 <mgsloan> Or at least, any implementation of first class modules that supported them would be greatly complicated by doing that
19:45:08 <mgsloan> (barring something extremely clever)
19:45:14 <elifrey> mgsloan: ah yes, you'd destroy the open world assumption wouldn't you
19:46:11 <elifrey> so, I suppose, you could still have them both together, so long as you don't mind loosing confluence :P
19:46:43 <carter> mgsloan: elifrey : first class modules aren't going to happen
19:46:55 <mgsloan> carter: I wasn't holding my breath :)
19:46:55 <carter> unless someone wants to deal with all the work needed for that
19:47:08 <carter> also then we'd have to type modules!
19:47:18 <elifrey> carter: a person can dream
19:47:48 <carter> actually, one interest question needed first is "how can we setup typing rules fo how we can import type classes into a module"
19:47:55 <carter> *interesting
19:49:19 <carter> like
19:49:46 <carter> right now (roughly, and i'm probably roughly wrong) ghc only really checks type classes as definition time, and at resolution time
19:49:59 <carter> we don't really talk about checking type classes at import time
19:50:26 <elifrey> carter: interesting
19:50:33 <mgsloan> Right, getting a gnarly error at import time would suck
19:50:55 <mgsloan> (since import would be equivalent to instantiating the module, leading to some error)
19:50:59 <elifrey> I noticed Backpack completely dodged the issue of typeclasses :/
19:51:13 <carter> elifrey: yeah, shame to
19:51:24 <carter> people were thinking about it 2007 and earlier too
19:51:34 <carter> or at least, i have an email i wrote around then about the issue
19:51:57 <carter> mgsloan: yeah
19:52:03 <carter> so you want to at important time
19:52:12 <carter> specify what consistentcy rules you have on type classes
19:52:18 <carter> when you adjoin the rules together
19:52:25 <carter> like you do at type class deifniton time
19:52:43 <carter> its kinda like having rules for how to add new axioms to a logic
19:52:47 <carter> or something
19:53:05 <carter> i *believe* TWELF has an interesting story that kinda relates to that logical view
19:53:11 <carter> of adding rules to a world
19:53:49 <carter> ish
19:53:58 <elifrey> carter: yikes, my intuition of tells me you would have to revisit all of your conclusions if you did that
19:54:09 <carter> elifrey: which?
19:54:41 <elifrey> carter: if you introduce new axioms, you'de have to revisit every conclusion you made to make sure it still agrees
19:54:47 <carter> elifrey: well
19:55:08 <carter> thats whats going on with OverlappingInstances and all that stuff
19:55:12 <carter> just at definition time
19:55:15 <carter> not import time
19:55:57 <carter> elifrey: you dont hhave to check every instance
19:57:20 <carter> just the things that overlap
19:57:21 <carter> or something
19:58:44 <elifrey> carter: ah, so if you take Haskell2010 typeclasses, the thing you would have to check at import time would be "are there any previous instances that clash with this instance"
19:58:55 <carter> yes
19:59:01 <carter> but also which notion of clash?
20:00:23 <carter> there may be several!
20:00:48 <shachaf> edwardk: Did you get the email about bahaskell?
20:00:59 <carter> how strongly typed will your type class instance checking on import time be?
20:03:27 <carter> elifrey: point being, its an interesting problem
20:03:35 <carter> and honestly a research problem
20:03:55 <shachaf> elifrey: (Are you coming to bahaskell next month? You should!)
20:04:26 <elifrey> carter: I would think without FlexibleInstances/FlexibleContexts/MultiParamTypeclasses it would be simple to see if two instances overlap.  Could you help me see a concrete situation where this would be dificult?
20:04:46 <carter> elifrey: well yeah, but not allowing those would be useless!
20:04:51 <carter> thats why its hard too :)
20:04:51 <levi> carter: The logical view of type class constraints is pretty clear in Haskell, too. Type class constraints are even called predicates in error messages.
20:04:59 <carter> levi: yup!
20:05:21 <carter> we need sort of "logical universe merge rules" to check type class imports into a module sortah
20:05:21 <elifrey> shachaf: I had not heard of it, but I will do everything in my power now!
20:05:27 <carter> elifrey: you're in the bay area?
20:05:28 <carter> 1
20:05:33 <carter> i'm out of date
20:05:36 <elifrey> Kirkland
20:05:42 <jfischoff> edwardk: does the semi indexing JSON thing have pretty printing story or just parsing?
20:06:01 <shachaf> elifrey: Well, it hasn't really been announced yet.
20:06:06 * elifrey wishes was in Seattle
20:06:08 <shachaf> But it'll be Oct 18.
20:06:09 <levi> carter: Just watch out, edwardk will hunt you down if you break confluence of type resolution.
20:06:27 <carter> i don't want to breakthat
20:07:04 <carter> the issue is certain type class imports can break that
20:07:15 <carter> but its only checked at the use sites
20:07:19 <carter> not the import sites
20:08:22 <carter> point being, agreed
20:09:18 <elifrey> ugh, I've been using Scala at work, and It is so depressing shoe-horning typeclasses in without confluence.
20:09:44 <carter> yeah
20:09:57 <carter> the idea being
20:10:08 <carter> you have some consistency of instance rules at import
20:10:14 <carter> into a module
20:10:15 <carter> rather
20:10:21 <carter> than check at use sites
20:10:32 <carter> sort of "merge checking rules"
20:10:33 <carter> idk
20:10:43 <carter> its not something i've dug into sussing out deeply
20:11:13 * mgsloan wishes he was in seattle proper as well
20:11:26 <mgsloan> Soon-ish, maybe :)
20:11:30 <carter> ?
20:11:54 <elifrey> carter: so if you want to check instances with FlexibleInstances, you need to see the call-site?
20:12:04 <carter> which check what?
20:12:15 <carter> lets look at where we "type chekc"
20:12:18 <carter> type classes currently
20:12:26 <carter> 1) we check that they make sense when we define them
20:12:30 <shachaf> mgsloan: You could also come to bahaskell.
20:12:43 <carter> 2) we check we can resolve them at use sites
20:13:05 <levi> I don't have room in my brain to think about type systems at the moment, I'm trying to grok gaussian processes.
20:13:11 <carter> levi: ooo
20:13:42 <mgsloan> Hmm hmm, probably will one of these months!
20:14:03 <mgsloan> shachaf: is it always around the 20th orso of the month, or does it drift a bit?
20:14:35 <shachaf> It hasn't been happening much at all this year.
20:14:57 <shachaf> I think the usual schedule has historically been the third Wednesday, but this time we're timing it with edwardk's trip here.
20:15:24 <elifrey> carter: what I'm getting at is, to clarify for myself, vanilla typeclasses don't need to be resolved at the call site, but in the presence of FlexibleContexts/FlexibleInstances, you now do need to know the types at a call site.
20:15:43 <carter> welll
20:15:56 <carter> theres still some resolution
20:16:26 <carter> even there
20:16:26 <levi> I love the internet. If it weren't for the internet, I would have to go to a university library or something to find all the resources I've currently got at my fingertips.
20:16:28 <mgsloan> shachaf: ahh, cool!
20:16:29 <elifrey> but you can know there will not be a conflict before the resolution (with vanilla typeclasses)
20:17:04 <carter> elifrey: read the haskell type class papers
20:17:05 <carter> :)
20:17:05 <mgsloan> shachaf: I think I will be in the area in early november. But not expecting y'all to schedule around me, haha
20:17:13 <elifrey> carter: fair enough :)
20:18:24 <carter> i htink the outside-in paper is the main one
20:18:29 <carter> im out of date
20:38:25 <edwardk> johnw: one oft requested feature i've had folks ask me for is an RSS feed for a given user or folder on the fpcomplete site. one concern i'd have with the obvious implementation is that whenever i update a post with even a typographical edit, you guys change the date for the whole post, rather than track a separate edit date
20:40:00 <copumpkin> just get it right the first time, duh
20:47:16 <applicative> is this a familiar sort of haskell idiom? http://sprunge.us/eKeF
20:48:08 <applicative> I panicked slightly before I could see it was just a big if ...
20:48:41 <applicative> or is John Lato trying to kill me?
20:48:57 <joelteon> that's a multi-way if
20:49:05 <joelteon> before multi-way if was invented
20:49:18 <geekosaur> ^
20:50:11 <copumpkin> that seems like it could benefit from an ADT
20:51:29 <applicative> hm?
20:52:09 <carter> boolean blindness eh?
20:52:30 <applicative> anyway, yes the 'naive' alternative would be a hideous pile of ifs ; i think I would have cut it all up differently ; i can't tell what i think
20:53:05 <copumpkin> applicative: I mean instead of a multi-way if, make that typ field do more work
20:53:13 <applicative> John Lato suffers from boolean blindness yes; we must make fun, children
20:53:14 <copumpkin> but yeah, I agree that I'd have done it differently :)
20:53:25 <copumpkin> no, we must not make fun
20:53:33 <copumpkin> just saying I would've done it differently, as you were just doing
20:53:43 <shachaf> ==copumpkin
20:53:53 <shachaf> Making fun is unnecessary and also unhelpful.
20:54:51 <applicative> i'm not seeing about the typ field -- anyway it's some hideous posix wrapped Int that tells you what kind of file it is.
20:55:20 <applicative> or maybe that's all the more reason to bury it in an ADT
20:56:42 <applicative> I'm trying to make his amazingly fast 'directory traversal' machine into a proper pipe, or producer, but he's to clever for me.
20:57:54 <copumpkin> oh, if it's a low-level wrapper then maybe it makes sense, but I'd probably translate it to a higher-level representation first
21:04:05 <ParahSail1n> there's MultiWayIf?
21:05:35 <carter> therese case lambda too
21:10:34 <applicative> LambdaCase I do know about; it seemed like yet-another-silly-syntactic frippery to me in advance, but actually its really nice
21:11:01 <applicative> much nicer than a real lambda which it pains me to use
21:13:10 <carter> \case -> of  blah
21:13:11 <carter> right?
21:13:34 <applicative> in line (\case Nothing -> 0; Just _ -> 1)
21:13:47 <applicative> is mercifully brief
21:14:04 <applicative> it doesn't use of
21:14:10 <applicative> "of"
21:17:34 <carter> oh so language pragma + \case trips iit
21:17:35 <carter> got it
21:17:50 <applicative> right, so maybeToList = (\case Nothing -> []; Just x -> [x])
21:18:38 <carter> thats 7.6 onwards right?
21:18:52 <applicative> Yeah, I think it's pretty new
21:20:44 <applicative> its also pleasant where you want an eta reduced form to convince the inliner of something; though I think it no different from a plzInlineMe = \x -> case x of ...
21:22:01 <carter> yeah
21:22:06 <carter> they should be the same wrt core
21:32:27 <flebron> haskell.org is down, right?
21:33:50 <carter> notified haskell ops
21:33:54 <carter> they should be on it shortly
21:37:39 <sirspazzolot> >let fact 0 = 1; fact x = x * fact (x-1) in fact 5
21:38:05 <sirspazzolot> uhh I guess I forgot how lambdabot works
21:38:32 <sirspazzolot> in any case, say we needed to optimize the crap out of the factorial function. tail-recursion, or does haskell do this already under the hood?
21:39:10 <copumpkin> > let fact n = product [1..n] in fact 100
21:39:11 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
21:39:24 <copumpkin> it won't make something tail recursive if you don't write it that way
21:39:36 <copumpkin> but foldl' is effectively tail recursion of the sort you want
21:39:48 <shachaf> Unfortunately product isn't foldl'
21:39:55 <copumpkin> it will be after optimization
21:39:56 <shachaf> (But with optimizations GHC can make it work.)
21:40:05 <ParahSail1n> @src product
21:40:05 <lambdabot> product = foldl (*) 1
21:40:49 <sirspazzolot> I'm failing to even see how tail recursion is a functional concept here
21:40:53 <sirspazzolot> heh
21:41:06 <copumpkin> we don't like writing recursion out by hand wherever we can avoid it
21:41:08 <flebron> i mostly see tail recursion as an implementation concept
21:41:19 <copumpkin> foldl's recursion pattern is inherently tail recursion
21:41:33 <copumpkin> so we've factored it into a function instead of writing it by hand every time
21:41:43 <flebron> you can consider tail reduction in terms of functional programming as seeing that the reductions are always of the same size
21:42:29 <flebron> so for instance fac 0 = 1; fac n = n * fac (n - 1) will have reductions of the form fac ( fac ( fac ( fac ( .... 0  ... ) ) ) ), which grows in size
21:42:35 <sirspazzolot> copumpkin: I've been told to implement everything by hand when youi're learning, heh
21:42:48 <copumpkin> alright
21:43:09 <flebron> whereas something like fac 0 k = k; fac n k = fac (n - 1) (k*n) is always of the same size
21:43:10 <copumpkin> then write the tail recursive version of what you wrote!
21:43:21 <copumpkin> or just take what flebron wrote
21:43:28 <shachaf> Tail recursion is a distinct concept from "tail call elimination", which doesn't really make sense to talk about in Haskell.
21:43:45 <flebron> right, since the concept of a stack frame and a "call" isn't really that well suited
21:43:53 <copumpkin> if you actually want this to be practical on large numbers you'll want some strictness too
21:44:01 <copumpkin> but otherwise, what flebron wrote is tail recursive
21:44:16 <copumpkin> fac 0 k = 1 though
21:44:22 <ParahSail1n> @src foldl
21:44:22 <lambdabot> foldl f z []     = z
21:44:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:44:28 <copumpkin> oh nevermind
21:44:30 <shachaf> copumpkin: ?
21:44:39 <shachaf> Ah.
21:45:06 <haasn> what's the reasoning behind sum/product not being foldl' anyway? Wouldn't it make more practical sense to have that be the default and to use something like genericSum for lazy foldr/whatever?
21:45:28 <copumpkin> haasn: foldl' doesn't exist in the report
21:45:34 <sirspazzolot> thanks guys. I'll revisit this when I know more about haskell if it's still necessary heh
21:45:42 <haasn> copumpkin: But `seq` does?
21:45:43 <Cale> haasn: Well, the original reasoning was that compilers should be good enough to turn foldl into foldl' when it's important.
21:45:58 <Cale> haasn: and in practice, with -O, GHC is good enough.
21:46:03 <haasn> fair enough
21:46:11 <haasn> Too bad I only use GHCi!
21:46:24 * flebron waits for the day ghc can improve fib n = fib (n - 1) + fib (n - 1)
21:46:30 <flebron> ... n - 2.
21:46:51 * shachaf waits for the day people stop arguing about that code.
21:47:18 <flebron> specifically fib?
21:47:24 <dwcook> Hoogle seems to be down. Is there a mirror?
21:47:37 <shachaf> I think fpcomplete.com has one.
21:47:43 --- mode: ChanServ set +o shachaf
21:47:51 <haasn> Oh no, hoogle is down, too? I remember hayoo being down
21:47:59 <haasn> Doesn't the world end when both are down?
21:48:17 <dwcook> That it does. Thanks.
21:48:30 <flebron> only if hackage also dies
21:48:57 --- topic: set to 'http://www.haskell.org/ down (investigating) | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by shachaf
21:49:01 --- mode: shachaf set -o shachaf
21:51:10 <sclv> haasn: fpcomplete hosts a hoogle too https://www.fpcomplete.com/hoogle
21:51:39 <haasn> Let's pray to Haskell Curry it doesn't go down.
22:07:27 <bos> argh, haskell.org is super flaky lately
22:11:01 <haasn> we should port it to haskell
22:12:12 <td123> hello
22:12:49 <td123> is 'binary' still the package to go when trying to encode decode types over the network?
22:16:36 <MitchellSalad> hi, im trying to make a Producer that produces strings from a file. Right now I have "withFile file_path ReadMode fromHandle", but the problem is withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
22:17:01 <MitchellSalad> and fromHandle :: Handle -> Producer' String m ()
22:17:36 <MitchellSalad> so it seems like I need to morph withFile into FilePath -> IOMode -> (Handle -> Producer' String m ()) -> Producer' String m ()
22:17:47 <MitchellSalad> with mmorph
22:17:51 <MitchellSalad> am I on the right track?
22:17:57 <haasn> td123: there's also ‘cereal’
22:17:59 <arkeet> remind me where Producer is from?
22:18:02 <MitchellSalad> Pipes
22:18:59 <haasn> MitchellSalad: I don't think stock pipes will let you wrap a finalizer the way ‘withFile’ does
22:19:07 <haasn> isn't there pipe-safe or whatever for this kind of stuff?
22:19:34 <arkeet> withFile executes the IO action and then closes the handle when it's done.
22:19:40 <MitchellSalad> oh, pipes-safe, so there is :)
22:19:46 <MitchellSalad> I knew only of pipes. Thanks!
22:19:48 <arkeet> what you need is something that closes the file once you're done with the Producer.
22:20:00 <arkeet> I guess pipes-safe is what you need.
22:20:04 <MitchellSalad> yup
22:20:47 <arkeet> what do you know, Pipes.Safe.Prelude.withFile exists.
22:22:45 <haasn> There you go :)
22:23:13 <MitchellSalad> hm, not exactly what i want, since it runs in MonadSafe
22:23:17 <MitchellSalad> which IO is not an instance of
22:24:00 <arkeet> well, you need to modify your things.
22:24:11 <bos> edwardk: does your tree lca algorithm work for DAGs too?
22:24:23 <edwardk> sadly no
22:24:30 <arkeet> MitchellSalad: you'd need to introduce SafeT somewhere.
22:24:47 <shachaf> Does it work for chordal graphs?
22:25:20 <bos> edwardk: fair enough
22:25:20 <MitchellSalad> hmm, SafeT, that's a new one
22:26:02 <bos> edwardk: i have a clever algorithm for DAGs that doesn't improve asymptotics (still linear) but is much faster than the standard algorithm for the cases i care about
22:26:09 <edwardk> you can often restate the DAG problem as a tree problem. thats what i do in the case of the revision control monad stuff
22:26:26 <bos> edwardk: yep
22:27:15 <arkeet> I guess you can make a tree out of any DAG. I dunno how useful that is though.
22:28:29 <arkeet> hm, the thing I was thinking of would make a tree out of any directed graph.
22:28:32 <arkeet> oh well.
22:28:43 <arkeet> acyclic would mean the tree is finite though.
22:30:00 <dwcook> The type signature I want to provide for this function (https://github.com/dwcook/tcgMUD/blob/master/src/Game/TcgMud/Network.hs#L21) is incorrect. I get this error message (which includes the signature): https://gist.github.com/dwcook/6568260 Can someone explain my mistake?
22:30:37 <bos> in my particular case, i have a dag with possibly multiple roots, which further complicates things
22:31:53 <edwardk> multiple roots isn't a problem, just make them all sit below a pseudo-root.
22:32:14 <edwardk> when the answer is that, then you know it doesn't exist
22:33:05 <bos> yeah
22:33:47 <arkeet> dwcook: hm? the line numbers don't make sense.
22:34:26 <dwcook> arkeet, woops, sorry, the code in the commit doesn't contain the faulty type signature.
22:34:32 <edwardk> so what is your dag trick if you don't mind me asking?
22:34:36 <dwcook> Let me add a Gist for that.
22:34:54 <arkeet> edwardk: if the dag has a single root, just make a tree of (paths in the dag starting at the root)
22:35:06 <arkeet> if it's already a tree, you get the same tree.
22:35:19 <dwcook> https://gist.github.com/dwcook/6568279 Better?
22:35:38 <bos> edwardk: it's complicated: http://selenic.com/repo/hg/file/7999f4fa155a/mercurial/ancestor.py#l11
22:36:23 <bos> edwardk: it takes advantage of numeric labels of the topological ordering of the dag
22:36:23 <edwardk> arkeet; the problem then is you wind up neding to compute the lca pairwise across an explosion of possible paths, since there are several paths per entry you are searching with
22:36:28 <arkeet> I agree.
22:36:50 <arkeet> well, maybe there's a better way than pairwise
22:37:02 <edwardk> bos: yeah the monotonic decrease on the labels as you climb the tree was how i originally did this as well
22:37:17 <bos> edwardk: the conventional lca algorithm walks up to the root and then back, so it does a lot of undesirable work
22:37:55 <bos> edwardk: mine finds a set of candidates and races them to the root, hoping that one will win before the root is reached
22:38:17 <arkeet> right.
22:38:29 <edwardk>  mostly wrote this up in article form finally because it serves as a good introduction to skew binary arithmetic, and i wanted to write up my work on getting a COLA-based Map to work in Haskell, and I use a skew-binary progression on the sizes of the vectors
22:38:33 <arkeet> dwcook: the problem is that the 'a' in the signature for handleClient need not be the same 'a' as the one in runServer
22:38:38 <edwardk> bos: makes sense
22:38:44 <dwcook> arkeet, why is that an issue?
22:38:56 <arkeet> well, because somewhere it is trying to unify them.
22:38:56 <dwcook> Don't I make it the same one by passing worldVar?
22:39:08 <bos> edwardk: if you've got a deep DAG with all the interesting action happening out near the leaves (i.e. a revision control system), it pays big to have a better constant factor
22:39:16 <arkeet> hm, let me look again.
22:39:16 <edwardk> definitely
22:39:47 <guspollos> sup
22:39:55 <guspollos> I heard you guys were super friendly
22:39:58 <dwcook> Oh, the Show is no longer of any consequence since I removed the hPrint
22:40:10 <edwardk> that is exactly why i was playing with that same algorithm. =) fortunately in my case while what i have forms a dag, the subset of shapes my revision control tree can form is restricted enough that i can always use the tree algorithm
22:40:22 <arkeet> dwcook: ok, well, Show isn't the problem.
22:40:22 <dwcook> guspollos, I would call this a pretty friendly channel
22:40:34 <bos> edwardk: nice
22:40:35 <edwardk> after a merge i can treat the result as a new child off their common root
22:40:50 <guspollos> I've a sort of on-topic question:
22:40:59 <guspollos> anyone know a good platform to track daily questions / answers?
22:41:43 <arkeet> dwcook: yeah, it's trying to unify them because you're using onConnect and friends inside handleClient
22:41:49 <arkeet> and those are using the 'a' in runServer, not handleClient.
22:42:14 <arkeet> dwcook: if you try removing the type signature for handleClient, does it work?
22:42:29 <dwcook> arkeet, it does. How can I discover what type signature GHC wants to assign?
22:42:41 <arkeet> that's the thing. you can't write the signature, unless...
22:42:46 <arkeet> you use the ScopedTypeVariables extension.
22:42:53 <dwcook> Hmm.
22:42:54 <arkeet> where you'd write
22:42:55 <edwardk> this happens because it is happening in a monad, where the fork operation gives you the reference to the thing you want to join to as the result of a monadic calculation: fork :: Rev s a -> Rev s (Task s a)         and you can only join it with another action: join :: Task s a -> Rev s a, so you can't have dag shapes where the lines 'cross' due to say main merging into branch a. while branch a simultaneously merges into main
22:42:59 <arkeet> runServer :: forall a. (Show a) => PortNumber -> a -> ((HostName, PortNumber) -> a -> a) -> ((HostName, PortNumber) -> String -> a -> a) -> ((HostName, PortNumber) -> a -> a) -> IO ()
22:43:07 <arkeet> handleClient :: TVar a -> Handle -> (HostName, PortNumber) -> IO ()
22:43:18 <edwardk> daan leijen wrote up the properties of these graphs
22:43:32 <arkeet> once you do that, the 'a' in handleClient is the one that's brought into scope by the forall a. in runServer.
22:43:35 <ReinH> edwardk: hi!
22:44:08 <dwcook> Hmm, I think I mostly understand.
22:44:19 <arkeet> :)
22:44:41 <dwcook> Oh, so part of the problem is that the signature for handleClient is too polymorphic?
22:44:59 <arkeet> yes
22:45:13 <edwardk> bos: http://research.microsoft.com/pubs/145511/semantics-revisions-2010.pdf and http://research.microsoft.com/pubs/150431/wodet11-final10.pdf  provide a good overview
22:45:15 <bos> edwardk: by the way, this year is the 40th anniversary of the formulation of the LCA problem
22:45:18 <dwcook> Okay, good. I understand the problem now. I think I'll just go without the signature, then. Thanks for helping me understand.
22:45:36 <edwardk> bos: 1973, hrmm, guess so
22:45:40 <carter> cool!
22:45:51 <arkeet> dwcook: an alternative would be:
22:46:04 <arkeet> uh
22:46:10 <carter> today l learned that the ghc x86 codegen has NOP, but ppc and sparc dont
22:46:22 <carter> hehe, i guess i'm touching all the code gens for this patch
22:46:42 <elifrey> carter: what are you working on in GHC?
22:46:49 <bos> edwardk: cool, hadn't come across those papers before
22:46:51 <carter> elifrey: adding prefetch
22:46:56 <carter> which is mostly useless
22:47:01 <carter> well
22:47:04 <carter> not adding prefetch,
22:47:10 <carter> but making it work on all the code gens
22:47:12 <carter> and have more options
22:47:23 <elifrey> what's prefetch?
22:47:30 <arkeet> dwcook: I dunno if you would like something like this. https://gist.github.com/arkeet/6568322
22:47:46 <carter> "see that pointer over there, i will look at where its pointing soon, load that ahead of time for me, k thx"
22:47:58 <elifrey> ahhhh, cool
22:48:08 <carter> basically the fastest way to load stuff is to know what you're doing ahead of itme
22:48:12 <carter> and do it ahead of time
22:48:21 <carter> yeah
22:48:29 <dwcook> arkeet, on line 19, what binding is the where attached to?
22:48:39 <arkeet> uh
22:48:41 <carter> on modern cpus, doesn't really make a big difference if you're doing regular array loops
22:48:45 <arkeet> maybe you can't write that.
22:48:53 <arkeet> maybe I meant to put that all in a let block.
22:49:07 * arkeet rarely uses where
22:49:07 <carter> like, modern intel cpus have a lot of tricks to guess how your'e looping through memory
22:49:09 <dwcook> Hmm, yeah, let could work. I just think where looks nicer.
22:49:19 <elifrey> carter: I can imagine you could pay sometimes too if you guess wrong
22:49:21 <edwardk> bos: the one that made me start playing with the revision control monad was http://research.microsoft.com/apps/pubs/default.aspx?id=150180 super-linear speedups make me happy and it fits with my long standing "parallel implies incremental" theme.
22:49:43 <carter> elifrey: well, yeah, l1 cache and l2 cache only have so much space
22:49:52 <carter> if you force your stuff you're using, you'll be sad
22:50:05 <carter> this is just work to expose it
22:50:20 <edwardk> bos: after i read that i went and reformulated daan's monad using sparks rather than full threads and started playing with the record functionality via cps
22:50:43 <bos> edwardk: ooh
22:51:04 <carter> oh sweet, sparc does have it
22:51:31 <elifrey> carter: do you mean forcing thunks you can run out of cache?
22:51:45 <carter> i never said thunks
22:51:46 <edwardk> https://github.com/ekmett/revisions/blob/master/Control/Concurrent/Revision/Monad.hs has my first stab at it. i've been meaning to go back and clean it up now that the lca code is in its own package
22:52:05 <carter> as in
22:52:14 <carter> the bucket is full of too much stuff
22:52:17 <carter> some will fall out
22:52:32 <carter> adding more water to a bucket will force some watter to spill out
22:52:39 <carter> link paging
22:52:43 <carter> *think paging
22:52:47 <carter> but cpu caches
22:52:51 <carter> rather than ram and disk
22:52:59 <elifrey> ah, that's what you meant was getting forced
22:53:01 <elifrey> sure
22:53:32 <stelleg> edwardk: how many people are you
22:53:53 <carter> 7
22:54:05 <edwardk> carter: shhh. you'll give away my secret.
22:54:12 <carter> darn
22:54:28 <edwardk> stelleg: depends. i'm not quite sure how big the team is in India...
22:54:30 <carter> i can't patent it and then do an IPO to outshine the twitter one
22:54:48 <carter> "use 7 invisible clones, and never sleep"
22:54:54 <carter> ok
22:55:05 <carter> sparc has NOP in ghc, PPC doesnt
22:55:07 <ReinH> edwardk: btw, link from http://ekmett.github.io/structures/Data-Vector-Array.html to http://ekmett.github.io/structures/best.html is broken
22:55:12 <ReinH> link text is "best"
22:55:19 <stelleg> edwardk: :)
22:55:36 <edwardk> heh
22:55:56 <carter> and it deadlinks
22:56:46 <carter> edwardk: any primop requests while i'm touching code gen
22:57:09 <edwardk> i've gone and redrafted my old 'catamorphism knol' for fpcomplete over the last couple of hours. i should probably post that too
22:57:18 <carter> i want to get an inline asm/ inline llvm ir op into 7.10
22:57:29 <carter> so it doesn't require compiler patches to add nice things
22:57:32 <edwardk> since it doesn't have any place else to live
22:57:34 <ReinH> edwardk: DO IT
22:57:47 <ReinH> edwardk: posted anything else of interest lately?
22:57:59 <ReinH> like cellular automata part 3?
22:58:00 <edwardk> ReinH: the LCA post
22:58:03 <edwardk> hahahaha
22:58:09 <edwardk> ok ok ok, i'll get around to it =)
22:58:21 <ReinH> oh yeah LCA
22:58:36 <ReinH> edwardk: I've still got the code but I'm sure you don't need it. You already have the types.
22:58:40 <edwardk> https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms
22:58:44 <ReinH> the impl is obvious
22:58:52 <edwardk> send the code again to remind me
22:58:55 <carter> if i start trying to design my own cpus, please be concerned. i just wanted to have fast nice math code in haskell
22:58:58 <ReinH> heh ok
22:59:32 <carter> that said, theres a lot of low hanging fruit for improving ghc code gen!
22:59:42 <carter> its kinda exciting and horrifying both
23:00:42 <ReinH> edwardk: https://gist.github.com/reinh/4ac518891a0aef7d6d22
23:01:11 <elifrey> carter: iiiinteresting
23:01:12 <carter> whats it do?
23:01:15 <carter> elifrey:?
23:01:26 <elifrey> low hanging fruit
23:01:28 <carter> yeah
23:01:44 <carter> also its readable if you take the time to read through it with a simple goal in mind
23:02:23 <elifrey> I was talking to step-cut once and he hinted there was much room to compress haskell datastructures in memory
23:02:44 <carter> who's step-cute?
23:02:50 <carter> oh sure
23:02:56 <carter> but that doens't require compiler tricks
23:03:10 <elifrey> jerramy shaw(sp)
23:03:23 <carter> and cool
23:03:30 <carter> compression is a bit subtle
23:03:40 <carter> elifrey: ask edwardk about compression :)
23:03:46 <jnylen_> hi all, how to always give a certain window a specific floating position in xmonad?
23:04:10 * hackagebot markdown 0.1.7 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.7 (MichaelSnoyman)
23:04:14 <ReinH> edwardk: aaaaand you're back. Get my link?
23:04:29 <edwardk> ReinH: got it. thanks!
23:04:33 <ReinH> np
23:04:53 <ReinH> edwardk: the only interesting bit is step, which was a free theorem anyway :p
23:05:22 <edwardk> well, it isn't free with the one parameter Store
23:05:30 <ReinH> k
23:05:52 <ReinH> attemptt to give you a hard time failed
23:06:02 <ReinH> reading your cata post now
23:06:03 <ReinH> fun stuff
23:06:05 <carter> jnylen_: ask on #xmonad?
23:06:08 <ReinH> folds are interesting
23:06:43 <ReinH> "A useful mnemonic is to think of a catastrophe destroying something."
23:06:44 <ReinH> awesome
23:06:45 <jnylen_> carter: tried that first
23:06:51 <carter> jnylen_: its also 2am
23:07:01 <jnylen_> :(
23:07:08 <edwardk> i wrote up that post a few years back. it is a lot more wooden than my more recent writing
23:07:23 <ReinH> edwardk: well give it an edit then :p
23:07:28 <edwardk> i may do that
23:07:35 <carter> ok, crashing for reals
23:07:41 <ReinH> also fuck yeah banana brackets
23:07:53 <ReinH> whoever came up with those is a genius
23:08:07 <ReinH> they make catamorphisms fun!
23:08:48 <tikhon> what, catamorphisms weren't fun without them?
23:08:51 <edwardk> i think it was erik meijer
23:09:42 <ReinH> tikhon: they make catamorphisms *extra* fun!
23:09:55 <tikhon> has anyone here tried using threepenny gui?
23:10:39 <tikhon> I want an easy way to make a UI which is basically a picture you can click
23:10:47 <ReinH> tikhon: someone on reddit did
23:10:56 <ReinH> it seemed good
23:11:46 <tikhon> Hmm, they have example code, but I will probably have to build it myself to see what it looks like
23:11:51 <tikhon> do you have a link to the reddit thread?
23:12:48 <elifrey> http://www.reddit.com/r/haskell/comments/1m2ue6/my_first_haskell_program_fnistash_a_utility_for/
23:16:22 <tikhon> elifrey: thanks
23:22:16 <tikhon> Hmm, threepenny gui looks pretty good.
23:27:24 <dissipate_> is haskell.org down?
23:27:46 <thoughtpolice> it's coming back online as we speak
23:27:52 * thoughtpolice is looking at the tty
23:28:36 <tikhon> I love the feeling when I spend a few hours writing some slightly hairy code and it works the first time round :).
23:28:40 <thoughtpolice> dissipate_: it is online now
23:34:06 <Cale> tikhon: Yeah, there were plenty of times like that when I was working on the FRP system with iPwn. Doing refactorings which touched several hundred lines of code, and then when everything compiled again, it would actually work :)
23:34:40 --- mode: ChanServ set +o shachaf
23:34:59 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by shachaf
23:35:03 --- mode: shachaf set -o shachaf
23:35:18 <tikhon> It's extra special because I'm half asleep—type errors and non-exhaustive pattern warnings caught a *ton* of silly mistakes as I was writing it.
23:35:39 <Cale> yeah
23:36:10 <tikhon> I think the pattern-match warnings should be enabled by default
23:36:31 <Cale> Yeah, I think the only reason they're not is that occasionally they're spurious
23:36:51 <shachaf> You lose quite a lot of the benefit of the type system without them.
23:36:54 <tikhon> Also, GHC is *very* conservative about enabling warnings by default
23:36:58 <Cale> But for the most part, they're the main thing you'd want out of -Wall. Most of the other things -Wall complains about are unnecessary
23:37:04 <tikhon> yeah
23:37:19 <tikhon> some of the -Wall warnings are just annoying, like name shadowing
23:38:25 <tikhon> Hmm, which warnings *are* enabled by default? The only ones I encounter are the ones for missing methods in a typeclass instance.
23:38:49 <tikhon> Which, amusingly, is very similar in spirit to the non-exauhstive patterns
23:38:54 <Cale> Well, heh, I've actually had some pretty nasty bugs happen because of unexpected name shadowing. But I tend to think of things like "you didn't use the result of this IO action" as quite obnoxious to warn about.
23:39:41 <thoughtpolice> https://github.com/ghc/ghc/blob/master/compiler/main/DynFlags.hs#L2916
23:39:50 <tikhon> Yeah, I've actually also been saved by the name shadowing warning, so I fix it—but unlike the patterns, name shadowing is *usually* okay and only bad fairly rarely.
23:39:59 <thoughtpolice> (this is somewhere in the users manual, but i can look up the code faster)
23:40:24 <tikhon> hmm, more of them than I thought
23:40:53 <thoughtpolice> (NB: that's HEAD, not 7.6 or whatever, e.g. -fwarn-amp doesn't exist for anyone else yet)
23:40:58 <shachaf> Hmm, -W turns on some warnings but not as many as -Wall.
23:41:05 <tikhon> Some of them I only ever see in cabal output, like the deprecated one
23:41:19 <shachaf> I wonder whether shadowing should be on by default.
23:41:42 <shachaf> Probably not.
23:41:49 <tikhon> I love how they use the adjective "dodgy" :D
23:41:57 <tikhon> great imagery
23:42:28 <shachaf> GHC has a lot of interesting language in the source.
23:42:58 <thoughtpolice> i'll never get over the word 'Zonking', but that's mostly because I have no idea where the hell it originated from
23:43:01 <shachaf> There's bad_stupid_theta.
23:43:18 <tikhon> I also like funbox-strict-fields
23:43:47 <tikhon> zonking?
23:43:50 <shachaf> GHC doesn't have any fun, safe options, though.
23:44:34 <tikhon> oh wow, that's an actual word; it'll be useful for scrabble :)
23:45:32 <thoughtpolice> tikhon: the typechecker uses mutable variables, so they can be updated. one of the ways they can be updated is during unification, when instantiating a type variable. this process is 'zonking'
23:45:41 <thoughtpolice> i don't know why it is called zonking. i'm not sure anyone else does either, honestly.
23:45:44 <tikhon> heh, wow
23:46:06 <tikhon> why do they do it that way? performance?
23:46:33 <thoughtpolice> (IIRC, to be more clear: type variables are 'zonked' when they are instantiated, since they are represented with mutable variables.)
23:47:10 <thoughtpolice> tikhon: i'd assume so, but i'm also not the authority on the typechecker
23:51:56 <shachaf> @quote JaffaCake zonking
23:51:56 <lambdabot> JaffaCake says: (on zonking) It's named after the noise it makes.
23:52:22 <shachaf> thoughtpolice: There you have it.
