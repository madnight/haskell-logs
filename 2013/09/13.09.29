04:56:56 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
04:56:56 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Sat Sep 14 23:34:37 2013]
04:57:00 <DarkFox> No?
04:57:06 <DarkFox> @pl-resume
04:57:12 <lambdabot> const (((length . filter id $) .) . liftM2 (==))
04:57:12 <lambdabot> optimization suspended, use @pl-resume to continue.
04:57:15 <DarkFox> lol
04:57:44 <quchen>  @pl is usually useless. If you don't see how a function is easier to read with your eyes, asking Lambdabot to convert it does *never* help.
04:58:17 <DarkFox> quchen: I can read it but pointless is fun
04:58:31 <Pleb> I think the result is easier to read.
04:58:42 <DarkFox> Pleb: Not always though
04:59:54 <DarkFox> Ahh
04:59:57 <DarkFox> Int vs Integer
05:00:03 <DarkFox> length :: Int
05:01:23 <DarkFox> @pl listScore ss = map (\x -> (scoreWord x (concat ss)) - (scoreWord x x)) ss
05:01:26 <lambdabot> listScore = id (fix (const (ap (map . flip (ap . ((-) .) . flip scoreWord . concat) (ap scoreWord id)) id)))
05:01:27 <lambdabot> optimization suspended, use @pl-resume to continue.
05:01:30 * DarkFox expected longer haha
05:01:49 <DarkFox> @pl \a -> map (\x -> (scoreWord x (concat ss)) - (scoreWord x x)) ss
05:01:49 <lambdabot> const (map (ap ((-) . flip scoreWord (join ss)) (join scoreWord)) ss)
05:02:01 <DarkFox> Lol
05:02:54 <DarkFox> @let scoreWord a b = length . filter id $ liftM2 (==) a b
05:02:55 <lambdabot>  Defined.
05:03:01 <DarkFox> @let listScore ss = map (\x -> (scoreWord x (concat ss)) - (scoreWord x x)) ss
05:03:02 <lambdabot>  Defined.
05:03:14 <DarkFox> @let rankWords ss = reverse . map snd $ sortBy (comparing fst) (zip (listScore ss) ss)
05:03:15 <lambdabot>  Defined.
05:03:24 <DarkFox> @let wordList = rankWords . (map . map) toUpper
05:03:24 <lambdabot>  Defined.
05:03:32 * DarkFox should have used paste...
05:03:40 <DarkFox> Anyone see how this could be improved?
05:04:46 <kuribas> Wouldn't it be possible for ghc to derive deepseq instances?
05:08:14 <quchen> Generics would allow that I guess. You'd still need -XDeriveGenerics though.
05:08:50 * DarkFox read Genetics.
05:10:36 <donri> there are a few packages for that http://beta.hackage.haskell.org/packages/search?terms=deepseq
05:11:42 <DarkFox> beta.hackage.?
05:13:15 <haskellnoobee> is it possible to nest pattern guards within case of? http://lpaste.net/93588
05:13:50 <DarkFox> haskellnoobee: Not like that
05:13:55 <Rarrikins> DarkFox: http://lpaste.net/93589
05:15:12 <Rarrikins> haskellnoobee: You put the ->s on the guards, I think.
05:15:42 <Rarrikins> haskellnoobee: http://www.haskell.org/haskellwiki/Case#Guards
05:16:19 <DarkFox> Rarrikins: Didn't compile?
05:16:38 <Rarrikins> DarkFox: Oh, I didn't test that. Let's see.
05:19:16 <haskellnoobee> DarkFox: spot on thanks :)
05:19:20 <DarkFox> Rarrikins: I'm confused with it
05:19:30 <DarkFox> haskellnoobee: I didn't reply with the solution?
05:19:44 <haskellnoobee> http://lpaste.net/diff/93588/93590
05:19:58 <Rarrikins> DarkFox: http://lpaste.net/93589
05:20:01 <haskellnoobee> DarkFox: right thanks
05:20:03 <DarkFox> Was about to but Rarrikins got me thinking
05:20:13 <Rarrikins> DarkFox: Had a few errors in it :)
05:20:18 <DarkFox> module Kthx where
05:20:19 <DarkFox> :P
05:21:05 <hiptobecubic> What is the cause of this conflict on line 6? I don't get it. http://bpaste.net/show/136362/
05:22:07 <hiptobecubic> cabal-install==1.18.0.1 and Cabal==1.18.1 are installed
05:22:13 <Rarrikins> It may be more efficient with sum (map (scoreWord x) ys) + sum (map (scoreWord x) xs)
05:22:15 <DarkFox> Thanks Rarrikins
05:22:19 <Rarrikins> DarkFox: No problem
05:23:18 <DarkFox> Rarrikins: :t listScore?
05:23:50 <DarkFox> :t for all? haha
05:23:51 <lambdabot>     Not in scope: `for'
05:23:51 <lambdabot>     Perhaps you meant one of these:
05:23:51 <lambdabot>       `T.for' (imported from Data.Traversable),
05:23:55 <DarkFox> lol
05:24:21 <Rarrikins> Should be [[a]] -> [[a]] -> ([a], Int)
05:24:52 <Rarrikins> Let's see
05:24:55 <DarkFox> Well.
05:25:11 <DarkFox> Ah
05:25:13 <DarkFox>    11 listScore :: [String] -> [String] -> [(String, Int)]
05:25:21 <DarkFox> I missed the [] for the strings
05:26:52 <Rarrikins> DarkFox: Got it: http://lpaste.net/93589
05:27:05 <DarkFox> Thanks again Rarrikins  .. I might be back soon. Got a lot to do still - btw. I'm taking an existing word search generator (that outputted to a latex file!??) and extending it so instead of filling in random letters, fills the blanks with another message which will be for code cracking challenges.
05:27:18 <Rarrikins> Ahh, I see
05:27:42 <DarkFox> ~/build/haskell/Haskword >> ix WordList.hs # http://ix.io/8hf
05:27:45 <DarkFox> Rarrikins: So did I  :P
05:29:27 <DarkFox> Rarrikins: While extending, I'm improving and removing all the bloat. "Little" help from you :D
05:30:03 <Rarrikins> Ahh, not a bad project
05:31:11 <DarkFox> Rarrikins: At first, I had vim in replace mode after setting up a 20x20 grid filled with "." :P
05:31:21 <DarkFox> Then went there has to be a better method for this
05:31:22 <DarkFox> haha
05:31:51 <DarkFox> Also, this "haskword" crap has a LOT of IO where it shouldn't be </3
05:34:31 <DarkFox> Rarrikins: Wanna word together on this? ;)
05:34:34 <Rarrikins> Sounds like someone not very familiar with Haskell did it.
05:35:07 <Rarrikins> Unfortunately, I'm too busy at the moment.
05:35:44 <DarkFox> Rarrikins: I have to give them probs for one section. Kinda. Detecting and inserting words.
05:36:41 <DarkFox> Alright, Rarrikins I'll continue to do what I can. I'll put this on my darcs acc http://hub.darcs.net/DarkFox/ soon. Maybe it'll be more fun to play with later. ;-)
05:36:54 <Rarrikins> OK :)
05:38:50 <hiptobecubic> Is something amiss with dependency resolution in the new cabal sandboxes?
05:38:58 <DarkFox> Much better if I can complete the code challenge generator. Configurable. I.e wordlist = [ ... ]; secretMessage = rot13 "This is a message" ++ hex; hex = "deadbeef(shellcode if will fit at the desired size)"
05:40:45 <DarkFox> Going to have much more for configuring though. Picture manually cracking a 100x100 with 50 words and the rest to be extracted and the algorithm figured out. :P
05:41:07 <haskellnoobee> is something like this possible : http://lpaste.net/93594  assigning data member through guard pattern?
05:41:29 <DarkFox> haskellnoobee: no
05:41:35 <DarkFox> Not like that at least
05:42:42 <DarkFox> haskellnoobee: Better to have something like....
05:43:04 <haskellnoobee> DarkFox: thanks, I guess a where clause would be clearer
05:43:17 <haasn> haskellnoobee: with MultiWayIf you can use bar = if | v == 1 -> 10 | otherwise -> 1000
05:43:28 <haasn> (also across multiple lines as usual)
05:43:37 <haskellnoobee>  unsure if what I'm asking (previous question about case of + guard pattern) tends to look really ugly to others, intuition led met to try those
05:43:37 <DarkFox> data Foo = Foo { bar :: Int }; defaultFoo = Foo { bar = 1000 }; myFoo = defaultFoo { bar = 1 }
05:43:52 <DarkFox> But that is more if yo have a decent data record
05:44:01 <haasn> haskellnoobee: no, I agree, it makes sense
05:44:03 <DarkFox> Not a type Foo = Int  worthy :P
05:44:05 <hiptobecubic> haskellnoobee, i'd say it's hideous :) I'd use a where clause
05:44:22 <haasn> haskellnoobee: with lenses I'd write that as
05:44:33 <haasn> doo f v | v == 1 = bar .~ 10 | otherwise = bar .~ 1000
05:44:38 <haasn> er
05:44:46 <haasn> well, flip the parameters and remove ‘f’ from the parameter list :P
05:44:50 <DarkFox> hiptobecubic: Oh yea, ofc where :D
05:47:18 <haskellnoobee> haasn: I'm still having hard time to handle those parameter drops; guys now I get the deep importance of desugaring in the compiler http://www.aosabook.org/en/ghc.html, with people coming with interesting extensions all the time just to make an expression look just like they intend to
05:47:44 <DarkFox> Rarrikins: I'm gonna leave that for tomorrow too tired for now. Night Rarrikins
05:47:48 <DarkFox> Night everyone else too
05:47:50 * DarkFox o/ *
05:48:48 <bearclaw> hmf, cabal fails configure on network package with checking whether the C compiler works... no
05:49:23 <jophish> yo yo yo
05:49:33 <hiptobecubic> bearclaw, does it?
05:49:58 <bearclaw> if I decompress/configure myself it works, using all the info (env/configure line) I see in the cabal logs
05:50:09 <jophish> Still having trouble with this: http://lpaste.net/93595 If this program can read the input without running out of memory I get a stack overflow in increment
05:50:40 <jophish> I've tried making most things here strict, nothing seems to change the outcome
05:52:02 <jophish> I didn't have any luck using valgrind to check where all my memory was going
05:59:22 <bearclaw> hmm, it's the --with-ld which is not passed correctly
06:01:37 <kuribas> How can I evaluate a function several times for profiling, without it being optimized away?
06:03:37 <kuribas> Wrapping it in an IO action and forcing it?
06:06:31 <Rarrikins> kuribas: http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
06:06:56 <kuribas> Rarrikins: I know criterion, but it produces a lot of garbage in the profile.
06:07:13 <Rarrikins> kuribas: Ahh.
06:07:56 <FreeFull> kuribas: I don't think function calls get optimised away
06:07:58 <kuribas> It's pretty neat for benchmarking though.
06:08:03 <Rarrikins> kuribas: Perhaps map (\n -> f (whatever + n - n)) [1..100]
06:08:07 <FreeFull> At least not at the default optimisation level
06:08:43 <FreeFull> You might end up with some of the data structures getting shared though if they are monomorphic
06:09:12 <kuribas> I was using -O2
06:10:52 <kuribas> My functions aren't showing up in the profile, strange...
06:11:14 <jophish> What would the idiomatic function: f :: Text -> Seq Text, with the same functionality as words
06:11:18 <jophish> splitting on spaces
06:11:30 <aloiscochard> where can I find the sources of a cabal package?
06:13:24 <Rarrikins> jophish: What is Seq?
06:13:32 <jophish> Data.Sequence
06:13:34 <aloiscochard> nm
06:13:37 <jophish> .Seq*
06:14:10 <Rarrikins> S.fromList . T.words
06:15:25 <jophish> Rarrikins, thought so, thanks
06:15:47 <Rarrikins> No problem
06:16:13 <kuribas> I have the impression ghc memoizes my functions.  Otherwise it is to cheap to show up.
06:17:28 <sipa> it does not memoize
06:24:58 <kuribas> My function runs in 18ns according to criterion.
06:25:10 <sipa> what does it do?
06:25:11 <kuribas> 18µs
06:25:47 <kuribas> It turns a path from metafont into a normal path.
06:27:02 <kuribas> I wanted to optimize it, perhaps using vector.  Maybe it's not necessary.
06:28:46 <helmut> Hi. Was the Other ctor of Data.Applicative.Lift.Lift called Lift at earlier times?
06:35:38 <helmut> It appears like the answer to my question is "no". There is another type called Lift in Control.Functor.Combinators.Lift that has a Lift ctor.
06:37:52 <bearclaw> ghci is trying to load two versions of bytestring (one system 0.9, one user 0.10), how can I fix that?
06:40:05 <tdammers> bearclaw: check the dependency chains - most likely, you have two packages somewhere that depend on different versions of bytestring
06:40:21 <tdammers> sometimes, you can fix things by loosening your version dependencies
06:44:46 <bearclaw> ah, when I build network, it seems to chose bytestring 0.9
06:48:34 <bearclaw> ...and I don't see how to tell it otherwise, there is no constraint in the network.cabal on version
06:49:58 <supki> that generally means one of network's dependencies choose bytestring-0.9
06:50:29 <supki> you can add --constraint='bytestring >= 0.10' to see which one in the error message :)
06:50:49 <jaspervdj> FreeFull: are you using the client or server module?
06:51:15 <bearclaw> \o/  --dry-run -v3 tells me everything I need to know
06:51:19 <supki> bearclaw: actually though, I'd suggest to stick to global bytestring version, it's going to be much less painful
06:51:49 <bearclaw> something I need is missing in 0.9. Builder iirc
06:55:49 <yitz> bearclaw: for packages that come bundled with ghc, best to stick to those versions.
06:56:19 <yitz> bearclaw: if you want to try messing around, do it in a sandbox.
06:56:59 <bearclaw> at this point neither "ls" nor anything critical can be impacted by my messing around :)
06:58:53 <yitz> bearclaw: btw when in situations where cabal gets confused about confilcting deps, the --constraint option is very useful
07:02:51 <bearclaw> thanks, it's fixed now (until next time :) )
07:23:26 <FreeFull> jaspervdj: Client. It does seem to wor
07:32:59 <Polarina> Has anyone else had the feeling that they want to work on some project but don't know which or what?
07:33:20 <derdon> Polarina: I have more the feeling that I don't have enough time :(
07:33:53 <Peaker> Polarina: there are tons of projects I'd love to do if only I had the time to
07:34:39 <chrisdone> Peaker: hell, my projects have projects they want to do if they only had time
07:35:41 <Peaker> chrisdone: :)
07:37:34 <Maior> Polarina: I used to, but now it's more ENOTIME
07:37:47 <Polarina> I see.
07:45:39 <jrm2k6> Hi guys! What does => means in a function signature
07:45:50 <jrm2k6> I understand -> but not =>
07:46:10 <Kaidelong> => establishes a context as to what classes the types in the signature belong to
07:46:29 <Kaidelong> if you didn't have typeclasses and had to manually pass everything without => instead of say
07:46:45 <Kaidelong> (Monoid a) => [a] -> a
07:46:49 <Kaidelong> your type would have to look like
07:47:01 <Kaidelong> a -> (a -> a -> a) -> [a] -> a
07:47:09 <jrm2k6> Oh ok
07:47:11 <jrm2k6> got it
07:47:13 <jrm2k6> I think
07:47:14 <jrm2k6> :)
07:47:15 <jrm2k6> thanks
07:51:48 <pavonia> jrm2k6: You might want to read about typeclasses if you don't already know about them: http://book.realworldhaskell.org/read/using-typeclasses.html
07:52:05 <jrm2k6> Thanks
07:52:34 <jophish> Yo yo yo, I'm going to post some code on the internet and I'm fairly new to Haskell, could someone do a quick sanity check to make sure I don't embarrass myself.
07:52:40 <jophish> the code is here: http://lpaste.net/93597
07:53:59 <Kaidelong> jophish is Ord a => RandomGen g =>  even valid syntax? I would normally write (Ord a, RandomGen g) =>
07:54:29 <Cale> I think it was made valid by some extensions, but yeah
07:54:34 <Kaidelong> I actually usually always put my contexts in parens personally, actually, even if there is just one
07:55:02 <mkramer> 80% chance of putting your context in parens 100% of the time
07:55:27 <Kaidelong> that was actually an awkward sentence actually
07:55:42 <sgronblom> All you need in a language to get rid of null pointer exceptions is algebraic data types + pattern matching and a compiler that checks that your function definitions are exhaustive right?
07:56:03 <jophish> Kaidelong, ah, ok
07:57:13 <jophish> fwiw, I'm posting to ask for some help regarding a space leak. I've been looking at it for ages, but don't think I'm experienced enough to tell what's going on
07:57:34 <Kaidelong> do you have some idea what might be causing it?
07:57:46 <jophish> the space usage should be a function of the vocabulary size, but I find that it's actually a function of the size of the training data
07:58:09 <jophish> If I feed it the same token repeated a million times it eats all the memory on my machine
07:58:40 <mkramer> sgronblom: You need a system in which you can construct a type that doesn't include null as a type inhabitant, and a type checker that can enforce that. Then you need to operate on that type in your code. Simply having ADTs doesn't help you
07:58:48 <jophish> Kaidelong, I think that it could be the values in the map are not being evaluated fully
07:59:02 <jophish> (they depend on the value for that key that was there before them)
07:59:41 <Kaidelong> mkramer: do naive implementations of ADTs and pattern matching not accomplish this by themselves?
08:00:31 <mkramer> Mu
08:01:32 <lemao_> ola.. where is this defined: (:|)?
08:04:30 <Kaidelong> Well strict maps only give you WHNF which for a list I think means only the head of the list gets evaluated
08:07:08 <Kaidelong> you could give this library a try, if you're willing to accept the Unbox restriction for your Brain's type parameter: http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed.html
08:07:32 <Kaidelong> Data.Vector is just a nice set of libraries in general, recommend learning them
08:08:08 <Kaidelong> (Data.Vector.Unboxed is essentially like a C array)
08:09:05 <Kaidelong> ^ jophish
08:09:08 <Kaidelong> sorry
08:09:48 <Kaidelong> anyway if it is a strictness issue that should do it, if I understand how unboxed vectors are implemented
08:10:14 <jophish> Kaidelong, alrighty, Would replacing the Value type of the map do the trick?
08:10:40 <pavonia> lemao_: Where did you come across this function?
08:11:02 <jophish> type Brain a = Map.Map [a] (Int, Vector (Int, a))
08:11:10 <Kaidelong> I think it would
08:11:17 <Kaidelong> oh well
08:11:24 <jophish> that Int would still be 1+1+1+1+1
08:11:39 <jophish> oh wait, it's a strict map
08:11:42 <lemao_> pavonia: data     ISig     e a b     =  a :| (Sig e a b)  (monadic-frp)
08:11:44 <jophish> ok, I'll try this
08:11:56 <Kaidelong> I don't think haskell supports "type Brain a = (Unbox a) => Map.Map [a] (Int, Vector (Int, a))
08:12:04 <Kaidelong> but maybe I'm wrong
08:12:23 <pavonia> lemao_: Oh, it's a data constructor
08:12:32 <Kaidelong> anyway there is a caveat
08:12:46 <Kaidelong> your a has to be a value type with a constant size in memory
08:12:57 <pavonia> lemao_: ":|" is defined there
08:13:08 <Kaidelong> like a Char or an Int
08:13:21 <Kaidelong> that's what the "Unbox" typeclass does
08:13:45 <Kaidelong> but if that restriction is okay then this should work quite well
08:17:02 <shiona> an exercise asks me to write take with folds. Is it possible without zipping in extra data?
08:19:34 <Kaidelong> since you're zipping with [0..] you could just use foldr to do that anyway
08:19:44 <Kaidelong> @ty foldr
08:19:45 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:20:13 <haasn> shiona: consider: fst . foldr (\a (xs,n) -> ...) ([], n)
08:20:50 <lemao_> pavonia: :( fucka.... my bad
08:21:04 <shiona> ok, so as I thought there was no trick here to do it
08:21:52 <Kaidelong> > foldr (\v (i,_) -> (i+1,v)) (-1,undefined) ["cat","fred","barney"]
08:21:54 <lambdabot>   (2,"cat")
08:22:20 <Kaidelong> oh right
08:22:46 <Kaidelong> you need to build up the list and reverse it and all that, too
08:23:02 <edwardk> shiona: you need to at least tweak the final answer with fst or snd or something
08:23:26 <shiona> yeah. thanks. I think I'll do it from here myself
08:23:39 <shiona> afterall I'm taking the course to learn
08:27:18 <shiona> ended up with "foldr (\a b -> if (fst a) <= i then (snd a) : b else []) [] . zipWith (,) [1..]". I wanted the function to be non-strict over the second argument
08:27:32 <jophish> Kaidelong, One little thing, I've got no idea how to add an instance for Unbox Text
08:28:46 <Kaidelong> You can't, in any way I can think of, actually achieve that without subverting the whole purpose of unbox in the first place
08:28:48 <Kaidelong> however
08:28:59 <Kaidelong> you could use Foreign.Storable
08:29:14 <Kaidelong> and make a Ptr Text
08:29:49 <jophish> Just to make sure that I'm on the right track, what I was asking to do was create a std::string my_strings[];
08:30:10 <jophish> where the text data is stored contiguously, rather than being behind an indirection
08:31:07 <Kaidelong> you might be fine with boxed vectors if unboxed doesn't work for you
08:31:17 <jophish> I think I'll try that first
08:32:19 <Kaidelong> oh no you won't, I think the original problem was you needed a strict collection, and I was suggesting the unboxed vectors as a neat strict collection
08:32:31 <Kaidelong> I don't know if the boxed vectors are also strict
08:33:06 <jophish> heh, tried it. exactly the same behaviour
08:33:15 <Kaidelong> yeah
08:33:25 <Kaidelong> That's what you'd expect, you've just ended up using lists again
08:34:29 <Kaidelong> you can't unbox text because text is heterogenous
08:34:34 <jophish> Kaidelong, Using pointers and unboxed storage seems to be taking be away from a nice elegant solution. Is there no magic bang I can but in somewhere to force the evaluation of the map values?
08:35:20 <Kaidelong> how about http://hackage.haskell.org/package/deepseq-1.3.0.1/docs/Control-DeepSeq.html
08:36:04 <Kaidelong> (on the other hand you don't actually want to evaluate your text values, right?)
08:36:11 <Kaidelong> (fully anyway)
08:36:23 <jophish> that's correct
08:36:24 <Kaidelong> (deepseq would probably do that, so it might be going too far)
08:36:37 <jophish> It will tell me if the leak is where I think it is though
08:38:03 <Kaidelong> foldr1 seq list `seq` whatever
08:38:09 <Kaidelong> might do it
08:38:48 <Kaidelong> well
08:39:00 <Kaidelong> (map snd list)?
08:44:39 <jophish> Kaidelong, I think that I may have been wrong about where the leak is
08:45:00 <raid> hi there, is there an easy way to suppress the parentheses () around negative Ints when calling show on them?
08:45:05 <Kaidelong> that's a shame cause I was just about to suggest having an intermediate strict data constructor
08:45:07 <ikarus> So, Haskell Road, any opinions on it ?
08:45:34 <jophish> putting deepseq before inserting the new element into the RLE list doesn't help anything
08:46:21 <ikarus> I am wondering how well it works for people who aren't taking a course given by one of the authors
08:46:32 <jophish> Perhaps something is sill holding onto the old maps
08:51:18 <jophish> Kaidelong, This should prohibit space leaks in createBrain, right? http://lpaste.net/93599
08:52:01 <jophish> forcing the evaluation of the map
08:53:23 <Kaidelong> doesn't it?
08:54:13 <jophish> I'm afraid it doesn't
08:55:21 <Kaidelong> I guess I should just go play around with it, how are you profiling this?
08:56:18 <jophish> Kaidelong, I'm feeding it a 50MB file of repeated "a "
08:57:04 <bearclaw> if I do x = fromInteger.toInteger, I end up with signature Integer->Integer, instead of :t fromInteger.toInteger
08:57:13 <jophish> and watching memory usage
08:57:38 <Kaidelong> I'll just use :set +t then
08:59:49 <jophish> hmm
09:00:02 <Kaidelong> grrr what package does Data.Map.Strict live in?
09:00:21 <fizruk> containers?
09:00:31 <Kaidelong> but that's part of haskell-platform
09:01:07 <jophish> Kaidelong, This is interesting, (run 2 (take 1000000 . repeat $ "a")) seems to run really slowly
09:01:35 <fizruk> Kaidelong: probably you have an outdated version?
09:02:19 <fizruk> Kaidelong: Data.Map.Strict is in containers >= 0.5, as I can see: http://hackage.haskell.org/package/containers-0.5.0.0
09:03:54 <Kaidelong> that's possible
09:04:13 <Kaidelong> I probably should uninstall haskell platform and leksah and reinstall them
09:04:22 <Kaidelong> because windows
09:04:29 <Kaidelong> and probably the same for mingw and msys
09:17:56 <jophish> Kaidelong, this is interesting, instead of evaluating the markov chain, I'm just printing the brain, memory usage is fine
09:27:56 <t4nk535> Hello. I have a http://lpaste.net/93600, that generates a list of Double. A nooby question : have can i generate a list of (Double, Double) ?
09:28:15 <t4nk535> *have -> how
09:28:46 <Eduard_Munteanu> t4nk535: do you know any functions [Double] -> [Double] -> [(Double, Double)] ?
09:29:18 <t4nk535> Eduard_Munteanu: zip
09:29:29 <Rarrikins> > let zomg (a:b:xs) = (a, b):zomg xs; zomg _ = [] in zomg [1..10]
09:29:31 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
09:29:41 <Eduard_Munteanu> t4nk535: use that then, if you have a [Double] and you can get another one.
09:31:36 <Eduard_Munteanu> t4nk535: however you should probably use newStdGen once, not every time.
09:34:16 <dmj`> > take 10 $ iterate (first (+1) . second (+1)) (0,1)
09:34:17 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
09:35:06 <joe9> Is there a better way to write this code : http://codepad.org/OLummXfP
09:35:19 <mr-> > take 10 $ zip [0..] [1..]
09:35:22 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
09:36:45 <artyomkazak> joe9: first of all, get rid of guards in isValidInput: isValidInput v s = V.length v > read s
09:37:07 <dmj`> joe9: http://lpaste.net/93601
09:37:50 <Eduard_Munteanu> joe9: you might also want to use do-notation, that's what it's for
09:38:56 <Luke> anyone have a recommendation for testing frameworks for DB query code etc?
09:39:42 <chrisdone> Luke: testing existential properties?
09:40:03 <joe9> Eduard_Munteanu: I agree about the do notation. I want to follow the suggestion in RWH to get used to using the operators before using do.
09:40:05 <Luke> i guess you could call it that - testing side effects basically
09:40:14 <joe9> Eduard_Munteanu: just to learn.
09:40:26 <joe9> artyomkazak: ok, thanks.
09:40:47 <joe9> dmj`: thanks.
09:41:13 <chrisdone> Luke: ah, ok. i don't know ones specifically tailored to database stuff
09:41:55 <Luke> not necessarily tailored to DB stuff necessarily. just something that supports the IO monad and maybe can easily tie into cabal?
09:42:00 <Luke> does that exist?
09:42:55 <monoidal> joe9: isValidInput v s = V.length v > read s
09:43:30 <dmj`> joe9: no problem, might want to check if you have hlint installed.
09:44:10 <chrisdone> Luke: hspec, hunit and test-framework seem all to be fine for IO ime
09:44:39 <Luke> have you used those specifically? I'm actually looking for a personal recommendation
09:44:49 <chrisdone> Luke: we use it at fp complete to test our database operations, e.g. create  record, do operation, check the right result comes back, etc
09:45:15 <chrisdone> i've used test-framework on fay, hunit for a bunch of stuff, and hspec at work
09:45:27 <Luke> that's exactly what i'm looking for
09:45:27 <bennofs> Are there any other libraries for scraping html than HXT and HaXml?
09:45:37 <Luke> chrisdone: personal preference?
09:45:57 <bennofs> And is there a version of HXT without the arrow stuff?
09:46:30 <donri> bennofs: {html,http}-conduit, perhaps
09:47:17 <chrisdone> Luke: maybe hspec. it kind of abstracts over hunit anyway and gives a nice way to declare tests
09:47:38 <Luke> thanks. much appreciated. nothing beats a personal recommendation
09:47:39 <chrisdone> e.g. http://hackage.haskell.org/package/hspec-1.7.2.1/docs/Test-Hspec.html and see the monadic module
09:48:03 <donri> Luke: you can test IO code with quickcheck btw :) but it might be "morally dubious"
09:48:24 <Rarrikins> joe9: A few ideas: http://codepad.org/7hnGiobn
09:48:25 <enthropy> why do you say it's dubious?
09:48:54 <donri> enthropy: because the function is called morallyDubiousIOProperty
09:48:57 <bennofs> @hoogle morallyDubious +QuickCheck
09:48:58 <lambdabot> Test.QuickCheck.Property morallyDubiousIOProperty :: Testable prop => IO prop -> Property
09:49:01 <Rarrikins> joe9: You can also reduce checkInput to an if statement in a lambda.
09:49:04 <enthropy> donri: there's no unsafePerformIO or stuff like that http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Monadic.html
09:49:18 <shachaf> chrisdone: Who cares about "rainbow tables"? They aren't relevant there.
09:49:33 <joe9> monoidal: thanks.
09:49:38 <shachaf> Well, I'm not going to bring an off-topic discussion in here just because you left the other channel.
09:49:48 <bennofs> Wait, there is hxt-monad on github? Why is it not on hackage :(
09:49:53 * chrisdone blinks
09:50:06 <joe9> Rarrikins: thanks.
09:50:10 <Luke> donri: yeah and it's just not well suited for imperative side-effect testing =)
09:50:31 <donri> Luke: depends
09:50:38 <meretrix> Why can I write "f x = max x", but not "f x = (abs . max) x"?  In both cases wouldn't "Num a => x :: a -> a"?
09:51:00 <Rarrikins> @type max
09:51:01 <lambdabot> Ord a => a -> a -> a
09:51:22 <Rarrikins> @pl \x y -> abs (max x y)
09:51:22 <lambdabot> (abs .) . max
09:51:42 <meretrix> Yeah why do i need the second (.)?
09:51:55 <meretrix> @type (.)
09:51:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:52:16 <meretrix> Can't the "a" just be (a' -> a'')?
09:52:22 <Rarrikins> meretrix: abs is (b -> c), but max isn't (a -> b).
09:52:24 <bennofs> Is anyone using hxt-monad?
09:52:35 <enthropy> whose bot was hpaste? Where did it go?
09:52:37 <monoidal> meretrix: that would mean ((a' -> a'') ->  b), a higher-order function
09:52:47 <Rarrikins> meretrix: Unless you're OK with b being (i -> j)
09:52:48 <joe9> Rarrikins: fmap read getLine is a good idea. thanks.
09:52:50 <monoidal> meretrix: it's different from a' -> a'' -> b
09:52:53 <Rarrikins> joe9: No problem.
09:53:21 <Rarrikins> meretrix: When you have abs . max, max takes an input and gives a function. abs doesn't take functions.
09:53:28 <sleezie> What text editor you guys prefer for Haskell? I'm using Note++ atm.
09:53:29 <Rarrikins> @type max 5
09:53:31 <lambdabot> (Num a, Ord a) => a -> a
09:53:41 <Rarrikins> meretrix: That's not a good input to abs.
09:53:41 <monoidal> meretrix: (abs . max) x is the same as abs (max x), but this is attempting to take absolute value of a function
09:54:02 <chrisdone> sleezie: the favourites are: emacs, vim, sublime. all the rest might as well be the same
09:54:11 <meretrix> I was thinking ((a' -> a'') ->  b), that results in a single value.
09:54:16 <enthropy> > (abs . max) -2 5
09:54:17 <meretrix> Not a function..
09:54:18 <lambdabot>   Could not deduce (GHC.Num.Num
09:54:18 <lambdabot>                      (GHC.Integer.Type.Intege...
09:54:23 <enthropy> > (abs . max) (-2) 5
09:54:24 <lambdabot>   No instance for (GHC.Show.Show a0)
09:54:24 <lambdabot>    arising from a use of `M1817842775.sh...
09:54:50 <monoidal> meretrix: (a' -> a'') -> b is not the type of max
09:55:06 <monoidal> meretrix: max needs a -> a -> a
09:55:10 <chrisdone> why don't you guys try asking meretrix a question instead of throwing random facts at him
09:55:13 <meretrix> monoidal: Then why does id work?
09:55:15 <meretrix> @type id
09:55:15 <lambdabot> a -> a
09:55:20 <meretrix> @type id . max
09:55:21 <lambdabot> Ord a => a -> a -> a
09:55:27 <sleezie> chrisdone: Okay, thanks I'll try sublime first, have heared more people talking about that one ;)
09:55:33 <monoidal> meretrix: (id . max) x = id (max x) = max x
09:55:39 <Rarrikins> meretrix: Because id can accept functions.
09:56:21 <meretrix> Ok, I'll try thinking about it some more.
09:56:30 <zugz> how do I strictly read a file *without* closing the handle?
09:57:26 <chrisdone> zugz: use openFile and then use the read functions
09:57:34 <meretrix> Rarrikins: I guess my main confusion is why can id accept functions, but not abs? Where do I see that in the type signature?
09:57:43 <zugz> chrisdone: strictly?
09:58:03 <meretrix> Oh the Num.. duh.
09:58:11 <Rarrikins> meretrix: Yeah :)
09:58:14 <meretrix> Got it, thanks for the help.
09:58:17 <haasn> abs . max -- could work, if we had a perfectly sane instance Num a => Num (r -> a)
09:58:22 <Rarrikins> meretrix: No problem.
09:58:33 <hiptobecubic> what's the normal way to construct a URL with parameters?
09:58:38 <chrisdone> zugz: what does the file contain and what do you want to do with it?
09:59:16 <hiptobecubic> I see urlEncodeVars... I guess just   url ++ "?" ++ (urlEncodeVars vars) ?
09:59:33 <zugz> chrisdone: let's say I want a String
09:59:42 <chrisdone> hiptobecubic: there's Network.URI, but also Network.HTTP.Types.URI (i know, the module name's interminable, right?)
10:01:29 <hiptobecubic> chrisdone, hmm
10:01:32 <hiptobecubic> I'll take a look, thanks
10:01:45 <hiptobecubic> what happened to hayoo?
10:03:21 <ksf> is there any particular reason why ghc 7.7 only supports closed type families, but not data families?
10:03:43 <monoidal> ksf: I thought closed data families are also accepted
10:03:46 <chrisdone> zugz: then System.IO has openFile, which you can use to get a handle of a file in reading mode. then you can run hGetBuf until it returns zero
10:03:46 <monochrom> hayoo weekend vacation :)
10:04:28 <ksf> monoidal, "parse error on where"
10:04:40 <zugz> chrisdone: but that's still lazy, right? I'm trying using Data.Text.IO.hGetLine (repeating until empty)
10:05:10 <monochrom> that is not lazy
10:05:33 <chrisdone> zugz: well, i specifically asked what was in the file, and you said you want a String -_-
10:05:51 <monochrom> what led you to conclude that it is lazy?
10:06:09 <zugz> monochrom: I thought all System.IO stuff was lazy?
10:06:27 <monochrom> well, see, that's an unnecessary presumption
10:06:35 <joe9> this is what I ended up doing: http://codepad.org/7hxgYTTi . Is there a better function than read, that does not fail with *** Exception: Prelude.read: no parse and the exception can be handled more gracefully.
10:06:53 <chrisdone> @hoogle readMaybe
10:06:53 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
10:06:53 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
10:06:55 <chrisdone> ugh
10:07:05 <ksf> @hoogle maybeRead
10:07:05 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
10:07:06 <monochrom> readMaybe is in Text.Read
10:07:13 <chrisdone> http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Read.html#v:readMaybe
10:07:29 <chrisdone> why's lambdabot so out of date - _-
10:07:53 <monochrom> there is also readEither
10:08:01 <monoidal> ksf: seems right. I'm not sure
10:08:25 <Rarrikins> @hoogle Read a => String -> Maybe a
10:08:25 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
10:08:26 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
10:08:26 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
10:08:35 <Rarrikins> A perfect place for it!
10:08:54 <chrisdone> there's a readMay in the 'safe' package which i historically use until i can assume base:Text.Read.readMaybe
10:09:06 <monochrom> readEither is funny. on parse errors, it gives you a String for the error message, but it is always the same error message (see source code) :)
10:09:11 <bennofs> @hoogle readMay +safe
10:09:12 <lambdabot> Could not find some databases: safe
10:09:12 <lambdabot> Searching in:
10:09:12 <lambdabot>   .
10:09:17 <joe9> ksf: chrisdone: thanks.
10:10:29 <joe9> chrisdone: thanks. I like the safe package. will use readMay
10:12:20 <sm> safe is awesome
10:12:43 <sm> should it be in base ?
10:13:01 <monochrom> module Cookie(share_it_maybe) where ...  http://www.youtube.com/watch?v=-qTIGg3I5y8 :)
10:13:03 <zugz> monochrom: so sorry, are you saying that hGetBuf is strict? I don't see any reason to think it is
10:13:17 <monochrom> yes
10:13:37 <monochrom> are you now in rhetorical mode with me?
10:13:53 <zugz> monochrom: not at all
10:14:06 <donri> monochrom: well, looking at the source, there's two error messages
10:14:19 <monochrom> oh, I missed one of them
10:14:42 <ksf> joe9, you could also go enterprise-grade and use a proper parsing library
10:15:17 <ksf> read is fine for the odd number or the other, but once stuff gets a bit more involved you don't want to stay with that.
10:16:08 <jmcarthur> zugz: for IO, strict is pretty much the default.
10:16:15 <joe9> ksf: thanks. agreed. I want something simple and just a little better than read for this particular scenario
10:16:30 <joe9>  is what I ended up doing: http://codepad.org/75x3cTRU
10:16:49 <zugz> jmcarthur: and is there an easier way to do it than hgetbuf? I don't really want to start messing with pointers...
10:16:49 <haasn> > readEither "1"
10:16:50 <lambdabot>   Not in scope: `readEither'
10:16:50 <lambdabot>  Perhaps you meant one of these:
10:16:50 <lambdabot>    `readLitChar...
10:16:57 <jmcarthur> zugz: it was a mistake to make such common-looking IO like readFile and getContents use unsafeInterleaveIO, really
10:17:42 <haasn> monochrom: Well, it's still useful if you want to combine it with other Either String actions I guess
10:17:42 <ksf> jmcarthur, put them up for renaming for the next base version.
10:17:48 <ksf> or rather, Haskell version.
10:18:09 <yitz> jmcarthur: i disagree. it wasn't a mistake - there wasn't any reasonable alternative. we are only now approaching that with conduit, pipes, etc.
10:18:17 <jmcarthur> zugz: you could always use Data.Text or Data.ByteString
10:18:35 <yitz> jmcarthur: but yes, you do need to be aware of it and its consequences.
10:18:52 <jmcarthur> yitz: the alternative would be to use names that make their differences from most IO actions more clear
10:19:22 <yitz> jmcarthur: oh different names, sure. though even that wasn't obvious at the time.
10:19:25 <jmcarthur> e.g. readFileLazily and getContentsLazily
10:19:32 <yitz> right that would have been good
10:20:04 <yitz> things like Data.Text.Lazy and Data.ByteString.Lazy do that now
10:20:18 <jmcarthur> zugz: or if you want to use some of the new hotness you could use pipes/conduit or something
10:21:25 <yitz> ksf: even things like the occasional number have an alternative now in the text library
10:21:40 <yitz> ksf: though i do wish they had provided those for the strict variant too.
10:21:54 <yitz> ksf: having them only as lazy builders is rather disappointing.
10:22:08 <ksf> readMaybe should've been in the standard from the beginning
10:22:40 <yitz> ksf: i thought it is now. but i keep looking for it and not finding it and writing it myself yet again. is it finally in now?
10:22:57 <donri> it's in Text.Read
10:23:03 <chrisdone> i agree with jmcarthur, having lazy io in system.io is mistaken if not labelled explicitly as IO. if i don't want to read the whole file there are plenty of functions for partial reading
10:23:15 <zugz> jmcarthur: thanks, hGet from ByteString is pretty much what I wanted
10:23:21 <chrisdone> and i don't need pipes/conduit just to read some bits of a file
10:24:52 <sm> is there a good trick for saving or easily recreating state in ghci across reloads ?
10:24:58 <joe9>  which is better style:  http://codepad.org/75x3cTRU or  http://codepad.org/WRwkF1bh where I moved the Nothing validation to isValidInput.
10:25:08 <sm> even a way to write multiple let assignments on one line ?
10:25:11 <chrisdone> ho, ho, ho! not without patching it
10:25:31 <geekosaur> > let { a = 5; b = 7; c = 2 } in a + b * c
10:25:32 <lambdabot>   19
10:25:42 <chrisdone> geekosaur: that doesn't introduce two bindings. that's an expression
10:25:47 <sm> right
10:25:51 <yitz> donri: oh how about that. how did i not notice that?
10:25:52 <bennofs> What's people's problem with HXT-Arrows? I think they present a pretty neat approach for filtering an XML-tree, even if they could be made into a monad.
10:25:57 <f8l> sm: What's wrong with a .hs file?
10:26:01 <sm> I was trying let a=1; let b=2
10:26:07 <yitz> donri: but still a bit weird. Why String for error messages?
10:26:08 <chrisdone> f8l: what's right with it?
10:26:15 <sm> f8l: I see, that seems like an option
10:26:29 <geekosaur> so? same thing works with let inside do; you probably need the braces more there to disambiguate which part owns the semicolons
10:26:41 <donri> yitz: that's readEither
10:26:54 <chrisdone> geekosaur: please, demonstrate
10:26:56 <yitz> maybeReadDecimal = either Nothing Just . decimal
10:27:11 <f8l> chrisdone: I don't know. It was just a suggestion. I'm a Haskell newbie (still reading lyah).
10:28:00 <bennofs> > "3" ^? base 10 -- maybeReadDecimal
10:28:03 <lambdabot>   Just 3
10:28:22 <geekosaur> > do let { a = 5; b = 7 }; let {c = 2}; print (a + b * c) -- not that the bot will run this
10:28:24 <lambdabot>   <IO ()>
10:28:45 <geekosaur> hm
10:28:45 <yitz> bennofs: if you happen to be using lens
10:28:45 <chrisdone> geekosaur: we're talking about ghci, not lambdabot
10:28:54 <geekosaur> yes?
10:29:01 <monochrom> bennofs: I sometimes want to use the monad directly. but that's just sometimes. it's ok other times
10:29:05 <sm> f8l: and :script file, I see. That's a help, thanks
10:29:41 <donri> monochrom: it's an ArrowApply though
10:29:45 <f8l> sm: We are learning from one another. I didn't knew about :script. ;-)
10:30:00 <f8l> s/knew/know/
10:30:14 <chrisdone> geekosaur: so your demonstration should've been in ghci. but n/m, you've missed the point and i know it's not possible anyway
10:30:19 <sm> I'd still like to be able to pack a bunch of ghci commands on one line so I could use command history as a cheap memory
10:30:48 <chrisdone> sm: fwiw, one hack that i use is to pattern match on tuples
10:31:03 <monochrom> donri, I'm talking about a library as a human-computer interface, not as a mathematical theory.
10:31:05 <sm> chrisdone: how does that work ?
10:31:07 <chrisdone> λ> let (x,y) = (1,2)
10:31:07 <chrisdone> λ> x
10:31:07 <chrisdone> 1
10:31:07 <chrisdone> λ> y
10:31:10 <chrisdone> 2
10:31:19 <geekosaur> so it looks like you can't insist on completely separate let-s in ghci, but the let {a = 5; c = 7} part works in ghci
10:31:20 <sm> nice! that should work
10:31:36 <JuanDaugherty> that's not what the HCI in ghci means
10:31:39 <sm> for pure values I guess
10:31:47 <sm> or not
10:32:08 <geekosaur> Prelude> let {a = 5; b = 7}
10:32:08 <geekosaur> Prelude> b
10:32:08 <geekosaur> 7
10:32:25 <chrisdone> ok, that's right
10:32:37 <donri> don't need the braces
10:32:58 <sm> geekosaur: nice!
10:33:17 <enthropy> there's also :{ :} for multi-line stuff
10:33:20 * sm 's ghci skills are uplevelling
10:33:25 <geekosaur> possibly someone should file a bug about let a = 5; let b = 7 not working
10:33:29 <geekosaur> that strikes me as wrong
10:33:30 <donri> enthropy: but the point here is repl history
10:33:39 <yitz> sm: can't you set up multiple commands on one line using :def somehow?
10:33:56 <chrisdone> geekosaur: presumably it only accepts one DoStmt
10:34:14 <donri> geekosaur: that's not just let though
10:34:28 <donri> print"";print"" syntax error
10:34:38 <yitz> sm: :script was already possible before using :def
10:35:02 <sm> yitz: thanks, I'll look into :def
10:35:08 <donri> sm: ya know about .ghci right?
10:35:18 <donri> ./.ghci that is
10:35:24 <enthropy> geekosaur: let a = 5; let b = 7   is going to be seen as something like   let { a = 5; let b = 7 }
10:35:37 <enthropy> it probably shouldn't work in .hs files heither
10:35:37 <Hafydd> ././.ghci
10:36:00 <geekosaur> enthropy, yes, probably
10:36:06 <Hafydd> Generally Hard to Comprehend Inode
10:36:30 <geekosaur> it was more the multiple things with semis that I was pointing at (there's a reason I was using the braces...)
10:36:43 <sm> donri: yup.. I didn't want special purpose state that requires certain modules in scope there, I guess :script is similar
10:36:59 <donri> sm: hm?
10:37:32 <sm> in :def <cmd> <expr> , I think expr is a haskell expression ?
10:38:20 <donri> yeah, should have type String -> String or something like that (maybe input is [String])
10:38:29 <sm> hm, I must resort to the manual here
10:38:38 <lykos> mm_freak: Any chance you're on?
10:38:54 <yitz> sm: right. of type String -> IO String
10:39:14 <TeifionJordan> Hi, I'm trying to follow the Yesod quick start guide but I keep getting an error asking me to rebuild some packages. Here's the reddit post - http://www.reddit.com/r/haskell/comments/1ndtwx/cabal_is_telling_me_to_rebuild_packages_im_not/
10:39:28 <sm> ok. So not for memorising ghci commands then
10:39:35 <yitz> sm: then the RHS of your custom :foo command is passed to the expr, and the result is run as a ghci command.
10:39:40 <chrisdone> redit is unable to load the page due to overloading
10:39:58 <chrisdone> try stackoverflow or something reliable
10:40:33 <TeifionJordan> cheers
10:40:44 <magneticduck> alright guys, question I had yesterday that I still haven't solved...
10:41:04 <yitz> TeifionJordan: yesod has a boatload of dependencies. did you try it right after a fresh HP install, or in a sandbox?
10:41:14 <magneticduck> I have a function in my code that I'm using to render audio files; that is, I take a list of sample times, I map the function to it, and then I write the resultant list of samples to an audio file
10:41:21 <magneticduck> in GHCi it seems to run fast
10:41:28 <magneticduck> not much slower than sin for instance
10:41:34 <TeifionJordan> I'm not sure how to sandbox, is there a quick start sandbox guide you'd recommend?
10:41:39 <magneticduck> but when I use it to write a file, it takes forever
10:41:44 <magneticduck> at least 10 times as long as using sin does!
10:41:49 <chrisdone> gnuvince: is it being fully evaluated in ghci?
10:41:50 <magneticduck> what could possibly be causing that
10:41:59 <yitz> magneticduck: that sounds like a really cool function!
10:42:12 <magneticduck> it is!
10:42:13 <chrisdone> woops
10:42:15 <magneticduck> very cool indeed
10:42:43 <chrisdone> magneticduck: is it being fully evaluated in ghci? also it's possible that it's being forced at the wrong time and you should strictify it before doing file IO
10:42:43 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs#L53 is the function in my code
10:43:03 <magneticduck> I'm just doing the very simple :set +s and then map f [0, 0.01..10]
10:43:05 <magneticduck> etc
10:43:16 <magneticduck> so I should stricfity it?
10:43:17 <magneticduck> how do I do that?
10:43:21 <yitz> magneticduck: what do you mean by "run it in ghci" besides writing the output to a file? you mean just Show the first few samples as Haskell values or something?
10:43:29 <magneticduck> I show ALL the samples
10:43:31 <magneticduck> in the terminal
10:43:42 <magneticduck> xD it actually takes less time than is does to render the file
10:43:45 <magneticduck> which is superweird!
10:43:51 <yitz> magneticduck: not a mahler symphony then i suppose
10:44:11 <donri> chrisdone: strictifiabilitarianisticism?
10:44:28 <magneticduck> well it's actually a kind of sound synthesis function
10:44:57 <magneticduck> essentially, it takes a data type that defines an "oscillator" and a datatype that defines an "envelope" that modifys the oscillator's parameters over time, and a start and stop time
10:45:09 <magneticduck> and generates a function (Time -> SampleValue)
10:45:12 <yitz> magneticduck: so you just try to write 1000 samples to a file and it takes a long time?
10:45:22 <magneticduck> well I'm writing 41100 * 10 samples
10:45:29 <magneticduck> 10 seconds at 41100 hertz
10:45:35 <magneticduck> it takes 13 seconds
10:45:41 <magneticduck> sin, for instance, takes 2.
10:45:41 <sm> yitz: thanks, :def (and :cmd) look pretty powerful. I'm studying http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-commands.html
10:46:37 <magneticduck> chrisdone: how would I strictify it?
10:46:43 <magneticduck> that's probably worth a try
10:46:53 <yitz> sm: yw. yeah, :def can be fun :)
10:47:03 <magneticduck> oh, and another note: previous versions of the function that did more or less the same thing also took much less time
10:47:49 <yitz> magneticduck: can you paste your code?
10:47:53 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs#L53
10:47:58 <magneticduck> github, the whole repository's there!
10:48:01 <chrisdone> magneticduck: well i can see that function is lazy in a bunch of places
10:48:11 <magneticduck> yeah
10:48:12 <chrisdone> but where's the IO writing code?
10:48:20 <magneticduck> oh, that's in Raw.hs, if you're interested
10:48:36 <magneticduck> it uses hsndlib, what I wrote doesn't really have any algorithms
10:49:01 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Raw.hs
10:49:09 <yitz> magneticduck: i'm going to say things a little differently than chrisdone here. there is probably some problem that crept into you algorithm. it may or may not have to do with strictness. i think reaching for the strictness hammer too quickly is a common mistake. just debug it.
10:49:31 <magneticduck> it works fine!
10:49:52 <magneticduck> and I looked through the function a thousand times, it does exactly what I think it should do. GHCi has no problem with it
10:50:12 <chrisdone> if it works fine but has unexpected slowdowns in different situations, reaching for the strictness hammer is appropriate
10:50:14 <magneticduck> what I'm wondering is what changes between the tests in GHCi and when I use it to render a file
10:50:31 <magneticduck> yitz: it's not an algorithmic problem, probably
10:51:02 <kuribas> I just oploaded a package to hackage. It says opload-candidate. How do I know my package is uploaded?
10:51:10 <magneticduck> it should show up here!
10:51:14 <magneticduck> <3 hackagebot
10:51:49 <magneticduck> as for why it's not showing up, that's not my area of expertise =P
10:51:55 <donri> kuribas: also it should show up here http://hackage.haskell.org/recent
10:52:07 <sm> hmm. hackagebot ? tap tap tap
10:52:12 <donri> duno if hackage2 changes things
10:52:14 <kuribas> Ok, I'll try again.
10:52:30 <magneticduck> hackagebot
10:52:47 <magneticduck> never mind, thought it had some kind of response to that
10:52:58 <kuribas> Succesfully uploaded :)
10:53:12 <sm> doh.. the feed url for hackagebot has changed
10:53:19 <foobarbaz> Hi guys, was just wondering how Debug.traceShow works?
10:53:22 <lykos> I'm trying to get user input and parse it into a function for a function plotter
10:53:28 <foobarbaz> it clearly mutates without IO ?
10:53:30 <donri> foobarbaz: unsafePerformIO
10:53:31 <lykos> Does anyone have experience with this?
10:53:36 * sm has been spectating the hackage rollout, munching popcorn and completely missed that
10:53:38 <foobarbaz> ah, thanks :)
10:54:23 <magneticduck> lykos: you mean, parse a string as an algebraic expression?
10:54:49 <yitz> magneticduck: we can't see the Sound type or how it is rendered. but yeah, i concur with chrisdone's gut feeling. oscillateSound is just a right fold. you probably want a foldl'.
10:54:50 <lykos> magneticduck: Basically. Parse a string and pass it to something else as a lambda function
10:55:28 <geekosaur> note that using unsafePerformIO without understanding will quickly get you in trouble; it is NOT a get-out-of-jail-free for pure expressions
10:56:21 <magneticduck> yitz: awlright, I'll fit it into foldl'
10:56:28 <monochrom> but it only costs you $50 :)
10:56:32 <magneticduck> that's what those generalized functions are for anyway
10:57:11 <monochrom> interestingly, during late game, you want to stay in jail :)
10:57:15 <donri> sure it is, there just happens to be a moat with sharks around the prison
10:57:25 <yitz> magneticduck: you can write f with guards instead of nested if-then-elses and it will be much easier to read.
10:58:11 <magneticduck> alright
10:58:24 <chrisdone> magneticduck: i installed your library. how do i try your example?
10:58:39 * chrisdone wants to hear duck sounds
10:58:50 * yitz wants to hear a mahler symphony
10:58:52 * hackagebot cubicbezier 0.2.0 - Efficient manipulating of 2D cubic bezier curves.  http://beta.hackage.haskell.org/package/cubicbezier-0.2.0 (KristofBastiaensen)
10:58:52 * hackagebot hydra-hs 1.0.0.0 - Haskell binding to the Sixense SDK for the Razer Hydra  http://beta.hackage.haskell.org/package/hydra-hs-1.0.0.0 (MarcelRuegenberg)
10:59:03 <magneticduck> chrisdone: try renderSound defaultWavSettings (Sound $ const (freqFromString "c4"))
10:59:07 <magneticduck> uh
10:59:18 <magneticduck> chrisdone: try renderSound defaultWavSettings (Sound (const (freqFromString "c4")) 5)
10:59:29 <magneticduck> lol sorry, NEXT one:
10:59:59 <magneticduck> renderSound defaultWavSettings (oscillateSound sinusOsc (const $ freqFromString "c4") 0 5)
11:00:12 <magneticduck> there we are, that should generate a 5 second long clip of a pure note at c4
11:00:13 <chrisdone> final answer? =p
11:00:18 <magneticduck> yes, that is the final answer xD
11:00:30 <magneticduck> after I'm done with this it's going to be so fun
11:01:12 <yitz> magneticduck: it already is!
11:01:16 <magneticduck> I already got some cool sounds out though https://soundcloud.com/magneticduck/native-haskell-sounds
11:01:48 <chrisdone> magneticduck: how long does it normally take? it's churning some CPU
11:02:07 <magneticduck> on my machine it takes like, uh 6 seconds or so for 5 seconds of audio
11:02:10 <magneticduck> because of that strange bug
11:02:17 <magneticduck> it used to take around half a second
11:02:22 <chrisdone> yeah it's just sitting there burning cpu for me
11:02:38 <magneticduck> x|
11:02:40 <chrisdone> i'll try it again
11:02:42 <yitz> chrisdone: each sound you synthesize also mines magneticduck some bitcoin
11:02:47 <magneticduck> it takes a suprising amoung of time!
11:02:53 <chrisdone> yitz: that's what it feels like =p
11:02:57 <magneticduck> lol
11:03:02 <magneticduck> sorry about that
11:03:10 <chrisdone> magneticduck: i'm loading it naively in ghci. i can try -O2 -fobject-code
11:03:24 <magneticduck> has it rendered anything yet?
11:03:29 <magneticduck> just give it some time
11:03:32 <chrisdone> nah i gave it half a minute and nothing happened
11:03:36 <magneticduck> lol
11:03:39 <magneticduck> lol.
11:03:57 <chrisdone> nope. it's definitely spinning the cpu but doesn't want to produce anything
11:04:04 <magneticduck> well give me a few minutes and I'll have the foldl' thing out
11:04:04 <haasn> tax :: Wallet -> IO a -> IO a
11:04:17 <magneticduck> or you can do it yourself
11:04:29 <chrisdone> ah, here we go. after reloading with object-code it's a bit better
11:04:35 <chrisdone> Prelude SoundsOfDuck> renderSound defaultWavSettings (oscillateSound sinusOsc (const $ freqFromString "c4") 0 5)
11:04:36 <chrisdone> it :: ()
11:04:36 <chrisdone> (36.27 secs, 76458049048 bytes)
11:04:54 <chrisdone> your machine's more powerful than mine =p
11:04:59 <magneticduck> rofl
11:05:02 <magneticduck> I do have a good computer
11:05:07 <magneticduck> unfortunately, I have no graphics card
11:05:14 <magneticduck> like, seriously
11:05:29 <chrisdone> i just have a macbook
11:05:49 <magneticduck> maan writing this in foldl' is a bit of a puzzle
11:06:33 <magneticduck> oh I see
11:06:39 <Luke> why did hpaste move to lpaste?
11:06:45 <haasn> rendering a single sine wave doesn't seem like a task that would take 36.27 seconds on any hardware capable of running an IRC client :)
11:07:14 <magneticduck> lol, it didn't use to!
11:07:41 <magneticduck> try renderSound defaultWavSettings (Sound (sin . (* 2 * pi * (freqFromString "c4"))) 5)
11:08:07 <magneticduck> should give the same result, with the sin function instead of my weird lazy blob of difficult to analyze if statements
11:09:08 <Rarrikins> That uses 70 GB of memory.
11:09:08 <chrisdone> k, that completes in 0.11 secs
11:09:19 <yitz> Luke: hpaste died of spam overdose
11:09:22 <magneticduck> you see my point now!
11:09:24 <magneticduck> :D
11:09:30 <magneticduck> well I'm sure you did
11:09:35 <Luke> yitz: so they just moved the URL?
11:09:42 <elliott> hpaste moved to lpaste for domain reasons
11:09:46 <elliott> nothing to do with spam, afaik, same owner
11:09:51 <yitz> Luke: no i think its new code
11:09:59 <elliott> same code too :P
11:10:06 <elliott> new design though
11:10:11 <Luke> ah cool
11:10:20 <Luke> chrisdone: isn't lpaste/hpaste yours?
11:10:21 <yitz> oh that's all? hpaste really did seem to be choking to death on the spam.
11:10:23 <Luke> or am i mistaken?
11:10:33 <chrisdone> Luke: the domain just moved. i don't control the hpaste domain. and a bunch of other languages use it now, anyway =]
11:10:43 <Luke> gotcha
11:10:57 <yitz> chrisdone: cool!
11:10:58 <chrisdone> yitz: i added a spamassassin-based filter
11:11:00 <Luke> shoulda just done a unicode lambdapaste.com or something =D
11:11:17 <chrisdone> Luke: i could've got paste.la =p
11:11:18 <yitz> chrisdone: good show
11:11:37 <Luke> http://xn--paste-1be.com/
11:11:41 <magneticduck> lambdaduck.com would be nice too
11:11:42 <magneticduck> ...right
11:11:44 <magneticduck> ?
11:11:54 <magneticduck> maybe it's just me and my duck obsession
11:12:11 <magneticduck> but ducks make everything classier
11:12:24 <magneticduck> duckduckgo.com
11:12:26 <magneticduck> so classy
11:12:32 <blume> it even has 2 of them.
11:12:50 <int-e> magneticduck: as in http://www.irregularwebcomic.net/435.html ?
11:13:45 <magneticduck> I never saw that before
11:16:38 <magneticduck> trying to remember, how do you use guards inside a case statement?
11:17:14 <int-e> > case True of True | otherwise -> 1
11:17:15 <lambdabot>   1
11:18:51 * hackagebot simple-form 0.1.1 - Forms that configure themselves based on type  http://beta.hackage.haskell.org/package/simple-form-0.1.1 (StephenWeber)
11:18:51 * hackagebot pandoc-types 1.12.2 - Types for representing a structured document  http://beta.hackage.haskell.org/package/pandoc-types-1.12.2 (JohnMacFarlane)
11:19:08 <chrisdone> magneticduck: i can't really follow what's going on in the codebase to pinpoint any weirdness. good luck
11:19:17 <magneticduck> lol sorry about that
11:19:52 <donri> > case succ False of (id -> otherwise) -> not False
11:19:54 <lambdabot>   True
11:20:10 <magneticduck> that code there has a long history
11:21:01 <elliott> donri: that shadows "otherwise"
11:21:04 <magneticduck> what is that donri?
11:21:20 <donri> elliott: hah yeah
11:21:39 <donri> magneticduck: computable nonsense!
11:21:46 <magneticduck> yeah, that's what it looked like! rofl
11:22:26 <magneticduck> case succ (const False) of (id -> otherway) -> otherway otherwise
11:22:31 <magneticduck> > case succ (const False) of (id -> otherway) -> otherway otherwise
11:22:31 <lykos> I'm trying to get user input and put it into a lamda function for a function grapher
11:22:32 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Bool -> GHC.Types.Bool))
11:22:32 <lambdabot>    arisi...
11:22:35 <magneticduck> uhhhhh
11:23:00 <magneticduck> > case succ (const False) of (otherwise -> otherway) -> otherway otherwise
11:23:01 <lambdabot>   Couldn't match expected type `(b0 -> GHC.Types.Bool)
11:23:01 <lambdabot>                       ...
11:23:11 <magneticduck> I suck at computable nonsense
11:23:21 <magneticduck> I also suck at computable sense
11:23:23 <donri> > case True of x | x -> otherwise | otherwise -> not x
11:23:25 <lambdabot>   True
11:23:46 <blume> computable redundance, yay!
11:25:11 <magneticduck> > case flip succ (const False) of (otherwise -> otherway) -> otherway otherwise
11:25:12 <lambdabot>   Couldn't match expected type `(((b0 -> GHC.Types.Bool) -> c0)
11:25:13 <lambdabot>              ...
11:26:19 <magneticduck> > case flip succ (const False) of ((const otherwise) -> otherway) -> otherway otherwise
11:26:21 <lambdabot>   Couldn't match expected type `GHC.Types.Bool -> t0'
11:26:21 <lambdabot>              with actua...
11:26:28 <chrisdone> hum. view patterns don't seem to work in pattern guards
11:26:34 <magneticduck> nop
11:27:16 <enthropy> > case 1 of (succ -> 2) -> ()
11:27:18 <lambdabot>   ()
11:27:44 <enthropy> > case 1 of x | (succ -> 2) <- x  -> ()
11:27:45 <lambdabot>   ()
11:27:51 <donri> > case True of x | (id -> True) <- x -> x
11:27:53 <lambdabot>   True
11:27:56 <donri> chrisdone: sure do
11:28:08 <magneticduck> maaaan
11:28:20 <magneticduck> view patterns are messed ioup
11:28:36 <donri> magneticduck: just you wait until we have pattern synonyms to hide them in
11:28:48 <chrisdone> donri: is lennart implementing that then?
11:28:57 <donri> chrisdone: duno, i think someone was?
11:28:58 <Rarrikins> > case 1 of x | (succ -> 3) <- x -> ()
11:28:59 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
11:29:29 <chrisdone> augustsson mentioned at camhac '10 he was planning on adding them
11:29:41 <magneticduck> donri: I can't wait
11:29:52 <donri> '10 eh, well i vaguely recall hearing about more recent developments
11:30:08 <chrisdone> 3 years is a good turnaround=p
11:30:43 <donri> magneticduck: classic-by-now demonstration http://www.reddit.com/r/haskell/comments/1lvuvl/regex_in_haskell_patterns/cc3cmzc
11:31:05 <enthropy> @quote evar
11:31:06 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
11:31:09 <sm> here's what I've added in .ghci (found in the ghci manual and slightly modified): :def . \f -> readFile $ if null f then ".ghci-state.hs" else f
11:31:30 <sm> then :. or :. somefile any time to run the ghci commands there
11:33:00 <donri> is that any different from :script?
11:33:24 <chrisdone> donri: awesome. i was super excited about that … 3 years ago. now i have to re-excitize myself
11:33:59 <sm> donri: hmm. Perhaps not. But less typing
11:34:04 <lykos> I'm trying to parse user input into a lamda function for graphing equations. How should I go about this?
11:34:23 <sm> plus, I made it myself so now I can do more
11:34:26 <Eduard_Munteanu> Hm, weird... is there no  (a -> b -> m a) -> m a -> m [b] -> m a  among standard libs?
11:34:54 <sm> this yak is done! back to the herd you go!
11:35:02 <Eduard_Munteanu> Not among parser combinators in attoparsec either, since that's what I'm using it for.
11:35:04 <chrisdone> donri: now we won't be embarassed by the lispers whose pattern matching is better than ours
11:35:12 <donri> :D
11:35:25 <chrisdone> (because they're extensible and ours isn't  [yet])
11:35:38 <pqmodn> lykos: you mean the user types something like "f(x) = sin(x)" and you want to graph it?
11:35:57 <enthropy> @type do z <- ?z; foldM ?f z ?xs
11:35:58 <lambdabot> (Monad m, ?z::m b, ?f::b -> b1 -> m b, ?xs::[b1]) => m b
11:36:08 <donri> chrisdone: QQ ;)
11:36:15 <lykos> pqmodn: Yes, basically.
11:36:16 <enthropy> @type liftM2 (foldM ?f) ?z ?xs
11:36:17 <lambdabot> (Monad m, Monad m1, ?f::a1 -> b -> m1 a1, ?z::m a1, ?xs::m [b]) => m (m1 a1)
11:36:24 <chrisdone> donri: dude, lisp
11:36:27 <donri> haha
11:36:39 <magneticduck> lykos: make a data structure, use parsecs, I suppose
11:36:42 <chrisdone> donri: you can't say "QQ" as if it's somehow on par with anything in lisp =p
11:36:49 <Eduard_Munteanu> @type liftM2 (foldl ?f)
11:36:50 <lambdabot> (Monad m, ?f::r -> b -> r) => m r -> m [b] -> m r
11:36:58 <donri> chrisdone: so apparently there's been some talk of a properly lispy frontend for idris
11:37:04 <Eduard_Munteanu> Actually that's better.
11:37:05 <chrisdone> =o
11:37:11 <donri> chrisdone: there *was* a wink in that ;)
11:37:14 <lykos> magneticduck: I'm not quite sure how to do that, I'm still a haskell newbie
11:37:41 <chrisdone> donri: honestly i never know wtf a wink means on irc. nobody in real life winks to me. it's an alien expression
11:37:42 <magneticduck> lykos: why don't you start learning how to make a GUI first
11:37:49 <chrisdone> donri: idris gets better and better
11:37:53 <magneticduck> you can use gloss to get started
11:37:55 <pqmodn> lykos: take a look at parsec to parse the input into an expression tree (of your own design, probably).
11:38:02 <Eduard_Munteanu> @type liftA2 (foldl ?f)
11:38:03 <lambdabot> (Applicative f, ?f::c -> b -> c) => f c -> f [b] -> f c
11:38:20 <donri> chrisdone: it's like agda without the crazy! ;) (i'm going to start wink in every message to you from now on)
11:38:27 <magneticduck> lykos: or learn the hard way, write your own parser
11:38:30 <lykos> magneticduck: I already have a gloss program to graph parametric equations, I just have to hard-code the equations in the source code currently
11:38:40 <magneticduck> alright, cool
11:39:00 <lykos> here's my current code:
11:39:10 <pavonia> "let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x" -- How would that look like without view patterns?
11:39:23 <magneticduck> try something like Expression = AddExpression Expression Expression | MultiplyExpression Expression Expression | VariableExpression Character ...
11:39:32 <magneticduck> just make a data type to define an expression
11:39:44 <magneticduck> and then learn to use parsecs or parse it yourself
11:39:45 <chrisdone> donri: i've always contended haskell with lisp syntax would be perfect. idris—maybe even better =)
11:39:50 <lykos> http://lpaste.net/93603
11:40:06 <donri> chrisdone: have you done anything with dep types?
11:40:12 <lykos> I started writing an expression tree (someone on here was helping me earlier)
11:40:20 <donri> chrisdone: i've been playing with it in haskell a bit lately and it's just awful :p
11:40:36 <magneticduck> lykos: alright then, parse! :D
11:40:43 <chrisdone> donri: i did some type-safe sized lists in haskell
11:41:04 <lykos> Once I parsed the user input into an AST, then what would I do?
11:41:20 <lykos> How could I use it to graph something?
11:41:33 <magneticduck> you'd make a mapping from your syntax tree to your expression dat
11:41:34 <magneticduck> data*
11:41:35 <chrisdone> donri: just to see how it is. with MPTC it's awful, with type famillies it's ok. but nothing on idris
11:41:43 <donri> chrisdone: yeah, that sort of thing works out alright but it gets ugly quick once you need true dependencies between type and term level
11:42:05 <chrisdone> donri: that sort of thing isn't  "true"?
11:42:47 <lykos> (oh, this is a side note, but when I use getLine in the terminal, it doesn't allow me to use backspace?)
11:42:48 <magneticduck> btw one thing lykos: addColor choice = (Color choice) . Pictures
11:43:03 <magneticduck> lykos: no, because you're entering a list of characters
11:43:16 <monochrom> lykos, there may be some interference between ghci and getLine
11:43:50 <lykos> How could I make it so that the user can use backspace when entering something in (say, if they mistype?)
11:43:56 <donri> chrisdone: i think if you have a sized-indexed "vector", that itself is "just" "type level computation" or something like that. but, say, a "take" that guarantees always to return n elements, that's dependently typed
11:44:02 <donri> chrisdone: and that requires "singletons" in haskell
11:44:03 <pqmodn> lykos: in your example, it looks like you are graphing ordinary haskell functions. it will be a big task to convert your custom expression type to something that's compiled by GHC. i would instead change paramCoordList to take your customer expression type and "interpret" it
11:44:16 <magneticduck> lykos: http://hackage.haskell.org/package/ncurses-0.2.6
11:44:28 <magneticduck> ncurses is a good way to draw to the terminal in any way that suits you
11:44:42 <Rarrikins> lykos: What do you get for map ord theLineEntered?
11:44:51 <chrisdone> donri: i thinnk you're entering wishy-washy land. i'll just nod and smile
11:44:54 <donri> chrisdone: because the type of take depends on the term-level Nat, as opposed to computations on the type-level Nat
11:45:13 <donri> chrisdone: oh i forgot to wink ;) ;) ;)
11:45:21 <elliott> basically you use singletones to get Pi
11:45:25 <elliott> as opposed to Haskell's irrelevant/runtime-erased forall
11:45:29 <elliott> *singletons
11:45:29 <lykos> pqmodn: That makes sense, how would I go about that?
11:46:01 <elliott> with forall, you only get to learn about the type you quantify over through the values, GADT-style
11:46:20 <magneticduck> lykos: you know about recursion right x|
11:47:49 <lykos> magneticduck: Of course. I was looking for more of a complete solution to reverse-engineering, but I guess I'll just start parsing from scratch. I'm still new to haskell, so the structure is rather unfamiliar
11:48:12 <magneticduck> lykos: alright
11:48:14 <lykos> magneticduck: earlier when you advised "addColor choice = (Color choice) . Pictures", why did you advise it? What's it do differently?
11:48:26 <pqmodn> lykos: something like interpret :: Expr -> Float -> Float; interpret t (Constant n) = n; interpret t (Variable 't') = t; interpret t (Multiply a b) = interpret t a * interpret t b; etc
11:48:28 <magneticduck> nothing, I just thought it was funny you made it like that
11:49:12 * sm needs a trick for remembering intersperse vs intercalate
11:49:39 <lykos> magneticduck: Why? I'm trying to learn good haskell style, and any tips are appreciated.
11:49:44 <Rarrikins> @type intersperse
11:49:45 <lambdabot> a -> [a] -> [a]
11:50:21 <magneticduck> lykos: oh, well because generally higher order functions like that are preferred over what you did
11:50:25 <magneticduck> at least in my experience
11:50:25 <chrisdone> donri: so in here http://lpaste.net/92328 you're saying
11:50:44 <magneticduck> it doesn't really make a difference, I just wanted to make sure you were aware of the Pictures constructor
11:51:32 <magneticduck> actually it doesn't really do what your function does so disregard it
11:52:33 <lykos> magneticduck: what exactly does "addColor choice = (Color choice) . Pictures" do?
11:52:54 <lykos> magneticduck: Ah, okay, nvm
11:54:43 <chrisdone> donri: woops. you're saying that it's not truly dependent it doesn't count? sure
11:55:35 <sm> I want to print values with varying level of detail when debugging
11:56:02 <donri> chrisdone: duno about "count" :) i think what i'm saying is that this sort of thing isn't that bad in haskell/ghc, particularly with modern kind extensions
11:56:25 <sm> it's seeming best to leave Show showing maximum detail, and add my own DebugShow typeclass that shows less detail
11:57:02 <donri> chrisdone: but it gets ugly if you want to do something like, take :: (n >= x) => x -> Vect n a -> Vect x a, or whatever
11:57:13 <chrisdone> donri: i was (earlier) going to go on to complain that the values and types aren't actually treated as one, so while you can make some external guarantees, internally you don't have any
11:58:37 <chrisdone> well, there's a little bit
11:59:06 <chrisdone> if i write: first :: List a Z -> a then ghc prevents me from writing first (Cons a _) = a
11:59:11 <chrisdone> but,
11:59:13 <donri> chrisdone: i think that's where the modern kind extensions help, if i'm understanding you correctly
12:00:12 <dagano> exit
12:00:17 <chrisdone> unsingleton :: (n ~ S Z) => List a n -> [a]
12:00:18 <chrisdone> unsingleton (Cons a Nil) = [a]
12:00:18 <chrisdone> ^ ghc has no idea that this is not an incomplete number of patterns
12:00:52 <donri> yeah, i think datakinds can help you there
12:01:07 <donri> data Nat = Z | S Nat
12:01:12 <chrisdone> second :: List a (S (S n)) -> a
12:01:12 <chrisdone> second (Cons _ (Cons a _)) = a
12:01:12 <chrisdone> ^ ghc also doesn't know that this is a complete implementation
12:01:52 <chrisdone> i did try encoding the number as a term, too, so that i could associate term with type
12:01:57 <donri> data List :: Nat -> * -> * ...
12:02:19 <magneticduck> question: why do I sometimes get a stack overflow when I get a recursive bug whereas other times my whole machine just stalls?
12:02:42 <magneticduck> and yet other times I can break the process neatly with a ^C
12:03:46 <sm> machines tend to stall when all memory and swap have been maxed out
12:03:55 <donri> chrisdone: yeah it's when you want to "associate term with type" you need singletons and it gets messy, i think. basically, "generate a load of gadts, type families and class instances with TH". :P
12:04:21 <magneticduck> then what's a stack overflow, if not when the memory and swap have been maxed out by a function?
12:04:32 <chrisdone> e.g.
12:04:35 <magneticduck> by the recursive tail of a function I mean
12:04:37 <chrisdone> data ListT :: *  -> * -> * where NilT :: Z -> ListT a Z; ConsT :: n -> a -> ListT a n -> ListT a (S n)
12:04:49 <chrisdone> second' :: ListT a (S (S n)) -> (n,a)
12:04:49 <chrisdone> second' (ConsT _ _ (ConsT n a _)) = (n,a)
12:04:51 <sm> magneticduck: I think GHC sets a limit on stack space, but not on heap space
12:05:04 <mm_freak> lykos: now i am
12:05:31 <sm> magneticduck: ie there are two kinds of memory overflow you can get from a "recursive bug"
12:05:58 <chrisdone> donri: ghc knows that this is the only legitimate implementation of that function, but it doesn't tell me
12:06:10 <chrisdone> donri: and i wonder if that's just a simple limited implementation of pattern matching exhaustiveness
12:06:12 <donri> chrisdone: although in the particular case of naturals, we have type literals with arithmetic and existing instances for singletons, so in this case it could be not-too-shabby
12:06:23 <geekosaur> you can set a limit on heap space, there just isn't one by default?
12:06:28 <sm> right
12:06:29 <chrisdone> donri: e.g. if i write:
12:06:30 <chrisdone> second' (ConsT n a _) = (n,a)
12:06:30 <chrisdone> or
12:06:30 <chrisdone> second' (ConsT _ _ (ConsT _ a (ConsT n a))) = (n,a)
12:06:33 <chrisdone> ghc says both are incorrect
12:07:23 <sm> ghc enforces the stack overflow with a nice error. Your os enforces the heap overflow, in various ways which often include randomly killing processes or freezing the whole system
12:07:51 <sm> osx >:(
12:08:29 <chrisdone> donri: so i would say second' depends on the type and the value in one, but i'd like ghc to confirm that and not give me imcomplete patterns
12:08:40 <donri> chrisdone: this? http://ghc.haskell.org/trac/ghc/ticket/6124
12:09:46 <chrisdone> the lack of syntactic sugar for literals and arithmetic seems just that, syntactic sugar. it's nicer to write but in my experiments i was more concerned with what's reasonably possible. Succ/Z isn't too bad
12:10:03 <chrisdone> donri: ermm
12:10:13 <donri> chrisdone: hm if i'm reading it right i think your ListT does in fact use singletons, more or less
12:10:14 <chrisdone> donri: right, exactly
12:11:37 <chrisdone> i guess so -- i'm associating the value with the type explicitly with the `n'
12:12:00 <chrisdone> (and the Z in NilT, obv)
13:27:04 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
13:27:04 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Sat Sep 14 23:34:37 2013]
13:27:21 <Umbrall> hm, so I can't seem to get a function that goes from f (g (h a)) -> Compose f (Compose g h a), only Compose (Compose f g) h a
13:27:58 <Umbrall> ohwait
13:28:12 <Umbrall> there we go found it
13:29:12 <Umbrall> Well actually no there is still a problem that it only works if you have a functor
13:29:37 <Umbrall> Like you can write Compose . fmap Compose to do this
13:29:53 <Umbrall> but it should be available regardless of whether you have fmap avaialble
13:31:00 <Umbrall> since the constructor itself is identity
13:32:32 <twanvl_> Umbrall: a newtype constructor is not the identity, at least not in the eyes of the type system
13:32:42 <Umbrall> I mean, it's functionally equivalent
13:32:56 <twanvl_> the new version of Ghc will have a way to cast away newtypes
13:33:15 <Umbrall> oh, that's nice then
13:33:38 <Umbrall> so you won't need Functor f for f a -> f (Identity a) then?
13:33:43 <arkeet> indeed
13:33:49 <Umbrall> cool
13:34:21 <twanvl_> you will still need to know something about f, I think
13:34:38 <twanvl_> for example, casting Set Int to Set (Down Int) should not be allowed
13:34:40 <Umbrall> yeah
13:34:49 <enthropy> why do you think so?
13:34:52 <Umbrall> I remember hearing about how it could break sets
13:35:06 <Umbrall> I just remembered hearing about this since you brought it up
13:35:30 <Umbrall> but yeah it needs to be polymorphic in its argument and not 'use' any properties of the argument
13:35:57 <monochrom> if Int's Ord and Down Int's Ord are different, pretending Set Int = Set (Down Int) will give wrong answers
13:48:30 <Eduard_Munteanu> Is there another way to write a type synonym associated with a *class* definition, other than an asstype with a default implementation and not making it visible?
13:49:20 <sipa> asstype? :o
13:49:54 <arkeet> Eduard_Munteanu: what sort of thing do you mean?
13:50:29 <lykos> I'm having some sort of monadic error
13:50:44 <lykos> I'm trying to use the Hint and Gloss packages together
13:50:44 <Eduard_Munteanu> arkeet: I have   class Foo ... where foo :: HugeType a b   bar :: HugeType b c    etc.
13:50:46 <lykos> here's my code:
13:51:02 <Eduard_Munteanu> arkeet: I want to avoid repeating myself
13:51:11 <arkeet> why not just use an ordinary type synonym?
13:51:15 <Eduard_Munteanu> sipa: yeah, it's a common nickname for associated type families :)
13:51:17 <lykos> http://lpaste.net/93612
13:51:49 <Eduard_Munteanu> arkeet: because I'd need to give it a big lump of parameters
13:51:56 <arkeet> like what?
13:52:19 <arkeet> the class parameters, and the stuff that varies.
13:52:23 <lykos> this is the error I get
13:52:24 <lykos> http://lpaste.net/93613
13:52:49 <Eduard_Munteanu> arkeet: yes, class parameters (already 3-4 lines) and the associated types
13:52:56 <lykos> I'm trying to figure out how to either use the display function inside of testHint, or to have testHint give some return type so I can call display from main. Any advice?
13:53:33 <arkeet> lykos: you probably want to lift display.
13:53:35 <geekosaur> you could try liftIO on the display?
13:53:41 <arkeet> ^
13:54:00 <geekosaur> just like with say
13:54:07 <lykos> arkeet: That's what I was figuring. I still don't really understand monads though. How would I go about doing that?
13:54:28 <arkeet> it's not really a monads thing.
13:54:29 <arkeet> but I mean there
13:54:32 <arkeet> is a function called lift.
13:54:36 <arkeet> :t lift
13:54:37 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:54:42 <arkeet> or
13:54:48 <arkeet> :t liftIO -- is probably more appropriate
13:54:49 <lambdabot> MonadIO m => IO a -> m a
13:54:57 <lykos> okay, how would I use it in this case?
13:55:12 <arkeet> your display thing is some IO ()
13:55:17 <Eduard_Munteanu> arkeet: class (CategoryK c, CategoryK d) => FunctorK (c :: obC -> obC -> homC) (d :: obD -> obD -> homD) (obF :: obC -> obD) (arrF :: homC -> homD) where type Source :: homC -> *   type Target :: homD -> *    type FMap :: obC -> obC -> *  type FMap = Functorial c d obF arrF   -- FMap is my "synonym", Functorial is an external datatype
13:55:23 <arkeet> so just pass that whole action to liftIO
13:55:33 <arkeet> Eduard_Munteanu: :s
13:56:05 <Eduard_Munteanu> Because I want to write methods like  kmap :: forall a b. FMap a b
13:56:21 <Eduard_Munteanu> (without doing   Functorial c d obF arrF a b)
13:56:55 <ksf> hackage and lpaste seem to be down
13:57:09 <arkeet> ksf: it's just you
13:57:15 <lykos> arkeet: Thank you! It works!
13:58:38 <ksf> I can *ping* lpaste just fine.
13:58:43 <ksf> http times out, though.
13:59:09 <monochrom> lpaste works here
13:59:24 <Eduard_Munteanu> BTW, given a functor F : C -> D, what do you call the subcategory of D induced by taking the image of F?
13:59:38 <monochrom> hackage works here too
13:59:50 <Eduard_Munteanu> (That's what I'm after.)
14:00:03 <ksf> lpaste.net 176.9.42.8 / hackage 88.198.224.242 ?
14:00:12 <arkeet> Eduard_Munteanu: you call that the image of F.
14:00:47 <Eduard_Munteanu> Hm. I guess ImageCategory might do as a name. Or maybe InducedCategory?
14:00:54 <arkeet> Eduard_Munteanu: it's called the image.
14:00:54 <monochrom> both IP addresses are what I get here
14:01:20 <ksf> what's a bit of strange is that the reverse DNS of both is static.IP.clients.your-server.de
14:01:36 <arkeet> ksf: sounds like your network is broken.
14:01:40 <Eduard_Munteanu> arkeet: yeah, I'm trying to define more general categories in Haskell.
14:02:47 <ksf_> so... they must've messed up the routing or something.
14:02:51 <monochrom> I get static.IP.clients.your-server.de too, but I don't think it matters
14:03:17 <ksf_> the thing is I *can* ping them.
14:03:28 <arkeet> do other sites work?
14:03:34 <ksf_> yeah.
14:03:37 <ksf_> haskell.org works.
14:03:58 <arkeet> and haskell.org is 88.198.224.243
14:04:07 <ksf_> yep.
14:04:50 <arkeet> strsange
14:04:53 <arkeet> or strange
14:05:20 <ksf_> SYN scan says port 80 is open.
14:05:23 <geekosaur> sounds like a confused proxy to me
14:09:10 <ksf_> uh. wtf.
14:09:18 <ksf_> telnet to port 80 works.
14:09:29 <lykos> arkeet: Using liftIO worked, but would it be possible to get my hintTest function to return some data to main?
14:15:27 <Eduard_Munteanu> I also wish implicit parameters worked at the type-level. :(
14:15:57 <Eduard_Munteanu> That's what I get for cheating Agda.
14:20:26 <chrisdotcode> hi everyone :)
14:24:58 <Eduard_Munteanu> chrisdotcode: hi
14:25:08 <chrisdotcode> Eduard_Munteanu: hi :)
14:28:57 <mmaruseacph2> @pl \(x,y,z,t) -> f x y z t
14:28:58 <lambdabot> (line 1, column 7):
14:28:58 <lambdabot> unexpected "z"
14:28:58 <lambdabot> ambiguous use of a non associative operator
14:29:04 <mmaruseacph2> @pl \(x,y,z) -> f x y z t
14:29:04 <lambdabot> (line 1, column 7):
14:29:04 <lambdabot> unexpected "z"
14:29:04 <lambdabot> ambiguous use of a non associative operator
14:29:07 <mmaruseacph2> hmm
14:29:31 <Rarrikins> @type f
14:29:31 <lambdabot> FromExpr a => a
14:30:23 <Maior> is there a way to tell my cabal Test-Suite that the build-depends is "what I've got under executable"?
14:30:26 <Maior> or some other config setting
14:30:29 <Maior> to avoid duplication?
14:31:13 <anonprogrammer12> that inserts an element into every possible place in a list. My code works but I'm having trouble how the recursive case inside the list comprehension works.
14:31:22 <anonprogrammer12> Hi i'm switching over to Haskell from Scala and was wondering if someone could help me wrap my head around recursion inside list comprehensions. I have a function:
14:31:32 <anonprogrammer12> insert x [] = [[x]]
14:31:36 <anonprogrammer12> insert x (y:ys) = (x:y:ys):[y:res|res<-ins x ys]
14:31:38 <anonprogrammer12> that inserts an element into every possible place in a list. My code works but I'm having trouble how the recursive case inside the list comprehension works.
14:32:01 <twanvl> mmaruseacph2: @pl doesn't understand tuples other than pairs
14:32:12 <Maior> oh http://stackoverflow.com/a/18310327/928098
14:32:31 <Maior> that's a bit lame
14:32:56 <anonprogrammer12> *understandign
14:33:00 <anonprogrammer12> *understanding
14:34:05 <twanvl> `[y:res|res<-ins x ys]` is sugar for `map (\res -> y:res) (ins x ys)`
14:34:10 * hackagebot pandoc-types 1.12.2.1 - Types for representing a structured document  http://beta.hackage.haskell.org/package/pandoc-types-1.12.2.1 (JohnMacFarlane)
14:34:40 <jonkri> How can I automatically derive Eq from a StdGen?
14:34:47 <anonprogrammer12> thank you!
14:35:57 <monochrom> oh, you just need to know that :)
14:36:02 <Maior> ugh this also doesn't seem to work
14:36:03 <Maior> sigh
14:36:09 <Maior> this is really nasty
14:37:02 <mmaruseacph2> twanvl: can I make a fold or something over tuples with more elements?
14:37:27 <mmaruseacph2> basically I want a generic piece of code to convert functions from uncurry to curry
14:37:32 <haskellnoobee> can someone explain how I'm supposed to read this expresison : http://hackage.haskell.org/package/gloss-1.7.4.1/docs/src/Graphics-Gloss-Algorithms-RayCast.html  castSegIntoCellularQuadTree   "cells@(_:_)	<-  something"
14:37:43 <mmaruseacph2> I haven't looked at lenses so far to check if there is something there
14:37:56 <mmaruseacph2> haskellnoobee: something returns a list
14:38:00 <mmaruseacph2> you name that list cells
14:38:05 <edwardk> :t Control.Lens.uncurried
14:38:06 <lambdabot> (Functor f1, Profunctor p) => p ((a, b) -> c) (f1 ((d, e) -> f)) -> p (a -> b -> c) (f1 (d -> e -> f))
14:38:09 <mmaruseacph2> and you expect the list to have at least on element
14:38:18 <mmaruseacph2> otherwise the pattern match will fail
14:38:26 <prophile> I like toast
14:38:26 <edwardk> mmaruseacph2: it only does 2 arguments currently
14:38:38 <mmaruseacph2> edwardk: ah, I understand
14:38:40 <mmaruseacph2> thanks :)
14:38:43 <edwardk> mmaruseacph2: if you wanted to upgrade it to use a class and build the first 10 instances or so i could take it
14:39:01 <mmaruseacph2> looks interesting
14:39:10 <mmaruseacph2> if I get a little slacking time I'll do it
14:39:13 <edwardk> :t (+)^.uncurried
14:39:14 <lambdabot> Num c => (c, c) -> c
14:39:15 <haskellnoobee> mmaruseacph2: where does the @ symbol comes from?
14:39:29 <edwardk> :t fst^.curried
14:39:30 <lambdabot> c -> b -> c
14:39:36 <mmaruseacph2> haskellnoobee: the @ allows you to rename the pattern
14:40:03 <mmaruseacph2> that is in f a@(x:b@(y:z)) a refers to list x:y:z while b is the same as the list y:z
14:40:40 <edwardk> mmaruseacph2: did i hear correctly that you'll be taking over the HCAR?
14:40:42 <haskellnoobee> mmaruseacph2: thanks, ok so it names a subpart of the match, that seems interesting
14:41:22 <haskellnoobee> mmaruseacph2: ok I think I got the reference: http://www.haskell.org/haskellwiki/Keywords#.40
14:41:26 <arkeet> for a googleable term, see "as-patterns"
14:42:11 <haskellnoobee> arkeet: right thanks :) I think it might come handy when I want to refer to a 2d point itself as well as it's x and y coordinates
14:42:15 <mmaruseacph2> edwardk: yup, I always wanted to be more active
14:42:28 <mmaruseacph2> and this seems like a good incentive
14:42:48 <edwardk> mmaruseacph2: great! i need to start actually submitting things to the HCAR. i haven't sent any updates to it in years ;)
14:43:06 <mmaruseacph2> well, you really should :D
14:43:24 <edwardk> mmaruseacph2: you have permission to give me crap about not sending you updates until i do
14:43:39 <mmaruseacph2> deal :)
14:46:55 <monochrom> Haskell's "@" is SML's "as". e.g., fun f (whole as (part1, part2)) = ...
14:48:28 <monochrom> you can use English to make sense out of "whole as (part1,part2)"
14:48:53 <Iceland_jack> monochrom: What do you mean?
14:49:27 <haskellnoobee> Iceland_jack: I think monochrom is addressing my question about cells@(_:_)
14:49:48 <Iceland_jack> I see
14:50:00 * haasn wants c{..} for c@C{..} :(
14:50:09 <Iceland_jack> haasn: amen :)
14:50:40 <monochrom> well, c{..} could be called ambiguous because C may not be the only constructor of the type in question
14:50:53 <haskellnoobee> interestingly, in the same expression, several items are bound in a single pattern match (using the "," comma), but without using a tuple or named structure
14:51:12 <Iceland_jack> haskellnoobee: Can you show us the code?
14:51:20 <Iceland_jack> > let cells@(x:xs) = "testing" in printf "'%s' starts with '%c' and ends with '%s'" cells x xs :: String
14:51:21 <lambdabot>   "'testing' starts with 't' and ends with 'esting'"
14:51:32 <haskellnoobee> Iceland_jack: http://hackage.haskell.org/package/gloss-1.7.4.1/docs/src/Graphics-Gloss-Algorithms-RayCast.html just after castSegIntoCellularQuadTree
14:52:20 <Iceland_jack> haskellnoobee: yes, you can do that in a guard
14:52:24 <haasn> monochrom: can't argue against that
14:52:54 <haskellnoobee> this kind of construct awe me because it's using very simple constructs, but has self referencing, ability to name subparts while also naming higher level parts...
14:53:04 <lemao_> I am trying to build a package that depends on SDL, but I am getting the following error: "i686-apple-darwin11-gcc-4.2.1: /opt/local/lib/libSDLmain.a: No such file or directory". I installed SDL with brew and it ends up in /usr/local/lib and pkg-config reflects that. Where does cabal get the path to libs when linking?
14:53:13 <haskellnoobee> is it something I could apply there: https://bitbucket.org/gauthier/haskell-playground/src/7e940db50c5be72c9dc5481a4c367242d4ebaed9/Playground/Gloss/fiddle.hs#cl-48 in someway?
14:53:31 <haskellnoobee> (might look like haskell from guy coming from kingdom of nouns)
14:53:36 <lispy> lemao_: from the .cabal file
14:53:38 <Iceland_jack> > case True of n | False <- not n -> "hi"
14:53:39 <lambdabot>   "hi"
14:53:49 <lispy> lemao_: and also from the command line if you use flags like --extra-lib-dirs=
14:53:50 <Iceland_jack> > case True of n | True <- n, False <- not n -> "hi"
14:53:52 <lambdabot>   "hi"
14:54:39 <pavonia> What is this "<-" here?
14:54:54 <shachaf> It's called a pattern guard.
14:55:08 <mmaruseacph2> you need it in case branches
14:55:08 <haskellnoobee> pavonia: the return value of the expression if the guard is matched
14:55:18 <haskellnoobee> (my uneducated guess)
14:55:19 <Iceland_jack> pavonia: http://www.haskell.org/haskellwiki/Pattern_guard
14:55:50 <Iceland_jack> haskellnoobee: If the pattern isn't matched, the guard moves on to the next condition
14:56:12 <Iceland_jack> > case True of n | False <- n -> "hi" | otherwise -> "bye"
14:56:13 <lambdabot>   "bye"
14:56:49 <lemao_> lispy: from SDL's package .cabal or my package .cabal? Mine has only Build-Depends: .... SDL >= 0.6.0, ...
14:57:06 <lemao_> lispy: you must be referring to SDL's .cabal?
14:57:38 <pavonia> So these pattern guards don't require any language extention?
14:58:43 <Iceland_jack> pavonia: No
14:58:54 <Iceland_jack> or well, PatternGuards
15:00:08 <Iceland_jack> PatternGuards are not in Haskell98 afaik, but they're enabled by default
15:00:32 <shachaf> Haskell 98 is irrelevant.
15:00:33 <pavonia> ok, thanks
15:00:34 <shachaf> The year is 2013.
15:01:03 <lemao_> lispy: looking at the .conf file for the SDL package I see: "ld-options: /usr/local/lib/libSDLmain.a /usr/local/lib/libSDL.dylib", which is correct, but cabal insists on using /opt/local
15:01:37 <Eduard_Munteanu> Hm, would be nice if you could promote a subset of GADTs to typeclasses.
15:02:15 <haasn> Isn't that <- there a ViewPattern?
15:02:45 <shachaf> What <- where?
15:02:49 <haasn> > case () of n | True -> n
15:02:50 <lambdabot>   ()
15:02:53 <shachaf> View patterns use ->
15:03:05 <haasn> shachaf: “case True of n | False <- not n -> "hi"”
15:03:10 <Iceland_jack> That's not a view pattern
15:03:38 <haasn> Oh, okay. I see now
15:03:58 <haasn> Yes, a true view pattern would have ‘not’ and not ‘not n’, either way
15:04:17 <Iceland_jack> that would be:
15:04:17 <Iceland_jack> > case True of (not -> False) -> "hi"
15:04:18 <lambdabot>   "hi"
15:04:27 <haasn> > case False of n | (not -> True) <- n -> "hello"
15:04:28 <lambdabot>   "hello"
15:04:30 <haasn> :)
15:04:39 <Iceland_jack> heh.. horrible
15:04:43 <haasn> That's quite confusing
15:04:53 <Iceland_jack> Yes
15:05:24 <mauke> > let chart f ((f -> y) : (chart f -> ys)) = y : ys; chart _ _ = [] in chart (+1) [1..3]
15:05:26 <lambdabot>   [2,3,4]
15:06:19 <Iceland_jack> ViewPatterns can be fantastic yet so horrible :)
15:06:41 <elliott> > let chart ((\f -> foldr ((:) . f) []) -> g) = g in chart (+1) [1..3]
15:06:42 <haasn> that one isn't too bad
15:06:42 <lambdabot>   [2,3,4]
15:07:15 <Iceland_jack> Yeah but when you start having nested view patterns
15:07:31 <shachaf> > let chart (map -> f) = f in chart (+1) [1..3]
15:07:32 <lambdabot>   [2,3,4]
15:07:53 <haasn> > let f (id -> id -> x) = x in f ()
15:07:54 <lambdabot>   ()
15:09:02 <haasn> > let chart f (over _head f -> over _tail (chart f) -> xs) = xs in chart (+1) [1..3]
15:09:03 <lambdabot>   [2,3,4]
15:10:29 <shachaf> haasn: No good. :-(
15:10:30 <shachaf> :t let chart f (over _head f -> over _tail (chart f) -> xs) = xs in chart
15:10:32 <lambdabot> Cons (->) Mutator t t a a => (a -> a) -> t -> t
15:11:09 <haasn> generalized !
15:11:30 <shachaf> You're not changing the type!
15:11:39 <haasn> ...oh
15:12:05 <haasn> this is why we need overexposures
15:12:07 <haasn> asap
15:12:26 <shachaf> Would that actually work for a thing like _Cons?
15:12:38 <shachaf> > let chart chart f (x:xs) = f x : chart f xs; chart _ _ _ = [] in fix chart (+1) [1..3]
15:12:39 <lambdabot>   [2,3,4]
15:12:40 <haasn> shachaf: sure, why not? expose to (a, [b])
15:13:05 <Eduard_Munteanu> Aww... don't accessors get promoted to type functions?
15:13:27 <haasn> Eduard_Munteanu: I can see that conflicting easily
15:13:55 <Maior> anyone know where I can find actual docs on Distribution.TestSuite.HUnit ?
15:14:22 <SrPx> \j c++
15:14:24 <SrPx> wops
15:14:26 <haasn> Eduard_Munteanu: but we could use ' or '' or something to distinguish them in ambiguous cases :P
15:14:39 <Eduard_Munteanu> I was trying to define classes over record types, so I can lump the 4 type functions into a functor.
15:16:08 <Eduard_Munteanu> data FunctorRep obC obD homC homD = FunctorRep { ... }     class ... => FunctorK (f :: FunctorRep obC obD homC homD)
15:16:40 <Eduard_Munteanu> But I can't find a way to place class constraints on f's fields.
15:16:54 <haasn> shachaf: maybe something could be done by writing Cons instances for the Exposed types themselves? I'm not too familiar with how that class works
15:17:03 * SrPx feels like he just dropped a my little poney poster from his pocket in the middle of a crowded gym 
15:19:28 <haasn> SrPx: Oh, you asked about representing arrays as functions so you get some operations for ‘free’, the other day
15:20:00 <SrPx> haasn: yea, why?
15:20:12 <haasn> SrPx: Just wanted to mention that repa can effectively do this, along with converting it to/from other array representations (eg. for other steps in the algorithm)
15:21:02 <SrPx> haasn: how!?
15:21:09 <haasn> SrPx: http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html
15:21:21 <haasn> In particular, see the ‘D’ (delayed) representation
15:21:36 <enthropy> well you have to tell it to convert
15:21:50 <haasn> yes, you also have to explicitly tell it to delay
15:22:05 <Eduard_Munteanu> Oh, I have an idea.
15:22:14 <haasn> SrPx: but have a look at http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html#g:7
15:22:16 <Eduard_Munteanu> I could make "constructor" classes.
15:22:19 <haasn> That creates a ‘delayed’ array, for example
15:22:57 <haasn> Also stuff like ‘slice’ will also created delayed arrays
15:22:58 <SrPx> Wow.
15:23:53 <SrPx> No, seriously, you mean those zip functions for example, all work on the function? No memory copy, not touching the original array at all?
15:24:01 <Eduard_Munteanu> class MakeFunctorK f c d obF arrF     class (MakeFunctorK f c d obF arrF, CategoryK c, CategoryK d) => FunctorK (f :: FunctorRep c d obF arrF)   I think
15:24:56 <haasn> SrPx: it depends on how you use it; you could throw a ‘compute’ after every operation and it'll create a ‘concrete’ representation at each step
15:25:03 <haasn> SrPx: this way is done mainly so you can fuse together operations
15:25:16 <haasn> eg. map f . map g
15:26:04 <relrod> If I have an IO String and a Maybe String and I want to compare their values (the Strings) to see if they are equal, what is the sanest way to do this (and default to False if the maybe is Nothing). Looking for something like IO String -> Maybe String -> Bool (or IO Bool)
15:26:10 <ReinH> haasn: it's a nice tool but it does break encapsulation a bit. Maybe there isn't a way around it.
15:26:13 <haasn> SrPx: http://hackage.haskell.org/package/repa-3.2.3.3/docs/src/Data-Array-Repa-Operators-Mapping.html#zipWith looks like it
15:26:25 <mauke> relrod: IO String doesn't contain a String
15:26:39 <ReinH> relrod: you can't compare a String with an IO String without performing IO
15:26:52 <relrod> bah, right. ok.
15:26:56 <relrod> hm
15:26:58 <ReinH> So at least you would need IO Bool
15:27:21 <haasn> IO String -> Maybe String -> IO Bool, however, is easily doable
15:27:21 <mauke> relrod: do you want 'foo getLine Nothing' to read a line or just return False?
15:27:33 <Iceland_jack> :t fmap (== "hi") :: Monad m => m String -> m Bool
15:27:34 <lambdabot>     Could not deduce (Functor m1) arising from a use of `fmap'
15:27:34 <lambdabot>     from the context (Monad m)
15:27:34 <lambdabot>       bound by the inferred type of it :: Monad m => m String -> m Bool
15:27:38 <Iceland_jack> :t liftM (== "hi") :: Monad m => m String -> m Bool
15:27:39 <lambdabot> Monad m => m String -> m Bool
15:28:13 <ReinH> where liftM = fmap but with the right constraints so it can be inferred for Monad m ;)
15:28:31 <SrPx> That sounds impressive haaaa
15:28:36 <SrPx> haasn *
15:28:53 <ReinH> SrPx: repa is a very impressive piece of technology ;)
15:29:03 <nicoo> Iceland_jack: Why annote >
15:29:09 <haasn> :t \m -> liftM2 ((==m) . Just) -- one way of writing a function with that signature
15:29:10 <lambdabot>     Couldn't match type `Bool' with `a20 -> r0'
15:29:10 <lambdabot>     Expected type: Maybe a10 -> a20 -> r0
15:29:10 <lambdabot>       Actual type: Maybe a10 -> Bool
15:29:18 <nicoo> :t liftM (== "hi")
15:29:19 <lambdabot> Monad m => m [Char] -> m Bool
15:29:19 <haasn> :t \m -> liftM ((==m) . Just)
15:29:20 <lambdabot> (Eq a1, Monad m) => Maybe a1 -> m a1 -> m Bool
15:29:51 <ReinH> and flip if you want your original argument order
15:30:01 <relrod> awesome, thanks guys!
15:30:22 <ReinH> @pl \m -> fmap ((==m) . Just)
15:30:25 <lambdabot> fmap . flip ((.) . flip (==)) Just
15:30:25 <lambdabot> optimization suspended, use @pl-resume to continue.
15:30:31 <ReinH> hah, don't pointfree it
15:30:52 <SrPx> Is there somewhere (like a forum, not chat) I can ask some questions about haskell productivity?
15:31:08 <SrPx> (things like recommended IDE and auto-importing of libraries)
15:31:11 <nicoo> ReinH: There is probably a song around where the lirics go « Just flip it ... Flip it »
15:31:24 <ReinH> SrPx: maybe StackOverflow, although questions "about productivity" are generally frowned upon unless they are concrete
15:31:26 <haasn> :t liftM  . ((.Just) . (==)) -- ReinH: challenge accepted
15:31:27 <lambdabot> (Eq a1, Monad m) => Maybe a1 -> m a1 -> m Bool
15:31:31 <ReinH> nicoo: flip it, flip it good
15:31:39 <nicoo> SrPx: Recommanded IDE is Emacs :3
15:31:40 <ReinH> haasn: well played :)
15:31:56 <mauke> ReinH: yeah, that's a poll, not an answerable question
15:31:56 <arkeet> @pl \m -> fmap ((m==) . Just)
15:31:57 <ReinH> haasn: wonder why pointfree couldn't get that versoin
15:31:59 <lambdabot> fmap . flip ((.) . (==)) Just
15:32:00 <lambdabot> optimization suspended, use @pl-resume to continue.
15:32:02 <lightquake> i have what looks like a hackage bug; where should I report it?
15:32:06 <arkeet> oh?
15:32:12 <lightquake> http://hackage.haskell.org/package/snap-0.13.0.2/docs/Snap.html all the links here are file://
15:32:13 <arkeet> oh yeah.
15:32:20 <haskellnoobee> SrPx: this might be usefull to get you started with emacs: http://lpaste.net/92858
15:32:41 <Maior> `cabal: There is no package named 'cabal-test-hunit'.` :(
15:32:41 <nicoo> :t (.Just)
15:32:42 <lambdabot> (Maybe a -> c) -> a -> c
15:32:56 <arkeet> :t ($Nothing)
15:32:57 <lambdabot> (Maybe a -> b) -> b
15:33:01 <mauke> haskellnoobee: he's no longer here
15:33:04 <nicoo> :t Just
15:33:05 <lambdabot> a -> Maybe a
15:33:11 * haasn is not sure why SrPx was killed
15:33:15 <nicoo> Ah, I see
15:33:18 <mauke> haasn: spamming
15:33:18 <SrPx> Sorry I was kicked from the server (!), in case anyone answered me
15:33:19 <leroux> lightquake: Hackage or Hackage2?
15:33:25 <arkeet> :t liftA2 (($Nothing) && (.Just))
15:33:26 <lambdabot>     Couldn't match expected type `a0 -> b0 -> c0'
15:33:26 <lambdabot>                 with actual type `Bool'
15:33:26 <lambdabot>     In the first argument of `liftA2', namely
15:33:26 <haskellnoobee> guys, is anyone using scion? in emacs, does it complete symbols from imported packages? does it allow to browse package definition?
15:33:28 <arkeet> hm
15:33:28 <haskellnoobee> SrPx: this might be usefull to get you started with emacs: http://lpaste.net/92858
15:33:30 <arkeet> :t liftA2 (($Nothing) &&& (.Just))
15:33:31 <lambdabot>     Couldn't match type `(b1, a0 -> b1)' with `b0 -> c0'
15:33:31 <lambdabot>     Expected type: (Maybe a0 -> b1) -> b0 -> c0
15:33:31 <lambdabot>       Actual type: (Maybe a0 -> b1) -> (b1, a0 -> b1)
15:33:32 <lightquake> leroux: hackage2
15:33:34 <arkeet> oh ok.
15:33:41 <nicoo> 00:31 < nicoo> SrPx: Recommanded IDE is Emacs :3
15:33:46 <SrPx> haskellnoobee: eh im more of a vim user ?
15:33:51 <leroux> https://github.com/haskell/hackage-server/issues
15:33:54 <leroux> lightquake: https://github.com/haskell/hackage-server/issues
15:34:13 <mauke> you can run vim in an emacs buffer (can't you?)
15:34:15 <haasn> SrPx: vim and emacs are both widely used here, the latter more so than the former. Both have their respective ‘haskell modes’
15:34:57 <ReinH> SrPx: try haskellmode-vim
15:35:01 <SrPx> That's cool with me, you guys know if there is auto-include and tags available for haskell already?~
15:35:05 <SrPx> Ralith: cool!
15:35:54 <haskellnoobee> I just got my hang around setting up flycheck/ghc-mod in emacs, and it's tremendously helping me, now I'm looking if there is any way I could complete symbols of imported packages like I can do in ghci, any hints on that?
15:35:56 <ReinH> @hackage hasktags
15:35:56 <lambdabot> http://hackage.haskell.org/package/hasktags
15:36:10 <ReinH> SrPx: ^
15:36:25 <ReinH> cabal install it and use it to generate your tags file
15:36:45 <ReinH> there's also
15:36:46 <SrPx> (;
15:37:09 <ReinH> @hackage ghc-mod
15:37:09 <lambdabot> http://hackage.haskell.org/package/ghc-mod
15:37:14 <ReinH> and associated vim plugin
15:37:18 <Maior> oh, cabal-test-hunit isn't in wherever-cabal-downloads-packages-from
15:37:19 <ReinH> (or emacs)
15:37:20 <arkeet> there's also hdevtools
15:37:20 <LuisRicardoRC> Anyone of you use yi?
15:37:28 <arkeet> and syntastic
15:37:52 <ReinH> arkeet: hdevtools vs ghc-mod?
15:37:56 <haskellnoobee> ReinH: is there a way to generate CTAGS/ETAGS on already installed packages? or while cabal is installing new packages?
15:38:03 <arkeet> ReinH: never used ghc-mod
15:38:05 <ReinH> haskellnoobee: not sure
15:38:07 <ReinH> arkeet: ok
15:38:20 <haskellnoobee> ReinH: hdevtools doesn't work under windows
15:38:30 <arkeet> windows =9
15:38:31 <arkeet> =(
15:38:33 <ReinH> arkeet: looks like ghc-mod is more featured, perhaps
15:38:37 <haskellnoobee> ReinH: ghc-mod does work fine
15:38:44 <ReinH> thank goodness I don't use windows :)
15:38:54 <arkeet> hdevtools is fast though.
15:39:13 <arkeet> it runs as a daemon and stuff.
15:39:26 <arkeet> no idea about ghc-mod.
15:40:14 <ReinH> not sure but seems like it should if it doesn't
15:40:23 <ReinH> actually
15:40:28 <ReinH> I do have to wait for GHC reloads
15:40:31 <ReinH> so it pretty clearly doesn't
15:40:38 <ReinH> I might try hdevtools
15:40:58 <haskellnoobee> ReinH: seems ghci can generate tags for loaded modules
15:41:04 <haskellnoobee> http://www.haskell.org/haskellwiki/Tags
15:45:01 <ReinH> Man, the ways people (ab)use vim never cease to amaze me.
15:45:43 <eflister> hi -  i've got a parsec parser "many a" where a = b >> many c.  it dies at the beginning of the second a, because it keeps looking for c's.  why doesn't it know to look for a b if c fails?
15:45:59 <newsham> reinh: get restraining order?
15:46:06 <ReinH> newsham: heh
15:46:23 <ReinH> usually it doesn't affect me personally so I try to "live and let live"
15:46:47 <ReinH> but then someone decides that the ghc.vim compiler should set shellpipe in a way that breaks every other use of the make system (like :grep)
15:46:50 <ReinH> and I have a sad
15:47:11 <eflister> any parsec peeps around?
15:47:35 <newsham> eflister: do you have a small working example?
15:47:48 <ReinH> well, a small non-working example? ;)
15:48:01 <eflister> is the description at 15:45 inadequate?
15:48:12 <newsham> is there some ambiguity between what your b and your c starst with?
15:48:26 <newsham> eflister: its a good start, just wondering about more details
15:48:28 <eflister> nope, nonoverlapping
15:48:34 <ReinH> Eduard_Munteanu: descriptions are always more ambiguous than code ;)
15:48:42 <ReinH> er eflister ^
15:49:53 <eflister> ok i'll paste one, but, given the description above, am i thinking about it right that 'many' should work for this?
15:50:27 <ReinH> Maybe.
15:51:31 <eflister> i guess "many (b >> many c)" -- will this ever stop looking for c's?
15:52:21 <dwcook> eflister, once it fails to do so, yes.
15:52:43 <dwcook> s/do so/find one/
15:53:33 <lemao_> how do I change the gcc executable to use in cabal? It is using gcc but I want it to use gcc-4.2
15:53:46 <dwcook> eflister, depending on what you're doing, you might need try
15:53:48 <dwcook> @type try
15:53:49 <lambdabot> Exception e => IO a -> IO (Either e a)
15:53:51 <dwcook> Not that
15:53:54 <dwcook> @type Text.Parsec.try
15:53:55 <lambdabot> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
15:54:10 <eflister> yeah that's what i'm wondering -- seems i need a try
15:54:22 <eflister> but i wouldn't have thought i would need one
15:55:01 <dwcook> Well, if you go down a branch that consumes and eventually fails, you need a try to get back to before that.
15:58:09 <ReinH> lemao_: iinm you can use --with-gcc
15:58:21 <SrPx> thanks guys.
15:58:29 <newsham> http://www.thenewsh.com/~newsham/x/machine/eflister.hs
15:58:30 <eflister> dwcook: it should be failing on the first character, is it consumed?
15:59:08 <SrPx> so, do you think it would be possible to create an auto-include feature? how would I approach this? I'd need to parse the code and look for symbols that are not defined, is this too difficult/impossible?
15:59:17 <SrPx> (for VIM)
15:59:17 <newsham> eflister: this is working fine for me
15:59:59 <lemao_> ReinH: I see. From the help : "--with-PROG=PATH", I guess PROG=gcc|...
16:01:54 <lemao_> that didnt work either. Anyone knows how do I get '/opt/local/lib/libSDL.dylib' in the "*** Linker" phase of cabal when SDL is in /usr/local/lib/libSDL.dylib?
16:02:39 <lemao_> it is explicitly adding /opt/local/lib there, but not sure where is that coming from
16:03:09 <eflister> newsham: thx, that does look like what i'm trying to do, trying to pin it down now...
16:04:12 <newsham> eflister: one thing to keep in mind with parsec combinators is they dont work exactly the same way as a grammar.  the parser will keep marching forwards as far as it can go until it cant go further and wont do any backtrackign to try other alternatives unless you tell it to ("try")
16:04:41 <newsham> ie. if you try to parse a C and C consumes some data before failing, it wont back up to the start of the C and try another A (and hence B)
16:05:39 <newsham> like if C is  string "apple"  and B is string "artichoke"
16:06:06 <newsham> then it wont work because it will do appleappleappleapple.arthichoke and consuem the "a" for apple and fail on the "r" , and error right there
16:06:16 <newsham> instead of backing up to the "a" try tro out string "artichoke"
16:06:34 <newsham> but if C was "apple" and B was "banana" you would have no problem
16:07:53 <finishingmove> any freelancers here, and where do you find gigs?
16:08:44 <Maior> any people have opinions on HUnit vs QuickCheck vs other?
16:09:01 <Maior> atm I'm liking the fact that a Cabal adapter for QC is on Hackage whereas the HUnit one isn't....
16:09:05 <Iceland_jack> Maior: They do quite different things
16:09:10 <Iceland_jack> so you can use them both
16:09:52 <Maior> Iceland_jack: point, thanks
16:11:01 <Iceland_jack> You can also use QuickCheck while developing, if I'm refactoring horribly hard-to-understand code I'll use: quickCheck (\x -> oldVersion x == myVersion x) as a sanity check that I didn't change functionality
16:11:18 <lightquake> i'm trying to build cabal 1.18.1 on ghc 7.6.2 and it's taking minutes, is this normal?
16:11:34 <lightquake> oh, it just finished
16:11:59 <Maior> Iceland_jack: nifty
16:12:11 <Maior> Iceland_jack: right now I just want to write some tests for this project
16:12:31 <Maior> fairly HUnit-y in style, but, well, sigh c-t-h not being in Hackage
16:13:23 <Iceland_jack> Maior: QuickCheck is *proprety*-based testing, so if you can thing of some property that a function is supposed to have, then QuickCheck is an excellent tool
16:13:36 <Iceland_jack> Coming up with good tests and properties is a skill though!
16:13:43 <Maior> Iceland_jack: indeed
16:13:56 <lightquake> Maior: what's c-t-h?
16:14:10 <Maior> lightquake: cabal-test-hunit
16:14:30 <Iceland_jack> If you wanted to test "sort" you might create a test:
16:14:30 <Iceland_jack>     prop_sortLen xs  = length (sort xs) == length xs
16:14:31 <Iceland_jack> or
16:14:31 <Iceland_jack>     prop_sortIdem xs = sort (sort xs) == sort xs
16:14:47 <lightquake> Maior: what's it do?
16:15:10 <Maior> lightquake: turns HUnit-y Tests into Cabal-y Tests so `cabal test` Just Works
16:15:21 <lightquake> Iceland_jack: note that for both of those you'd want to specify a type of something like [Int] -> Bool, otherwise it'll guess [()] -> Bool
16:15:49 <Iceland_jack> lightquake: I'm aware
16:15:50 <lightquake> Maior: huh? i have a test-suit target in my .cabal file and that Just Works for me
16:15:56 <Maior> lightquake: oh really?
16:16:00 <Iceland_jack> I was focusing on the properties themselves
16:16:08 <lightquake> yeah, i'm even using the spec discoverer
16:16:21 <Maior> lightquake: got a link I could look at please/
16:16:36 <lightquake> it's slightly annoying in that i have to duplicate my build-depends from the library, though
16:16:45 <Maior> lightquake: yeah :(
16:16:54 <lightquake> but other than that i don't have to do anything special
16:17:18 <Maior> lightquake: I'm following http://stackoverflow.com/a/11874602/928098
16:17:32 <augur> any ICFP vids up yet?
16:18:21 <lightquake> Maior: https://github.com/lightquake/sym
16:18:33 <Maior> lightquake: thanks!
16:18:46 <Maior> lightquake: ah, you're using exitcode-stdio
16:18:50 <lightquake> ah, yeah
16:18:54 <lightquake> i didn't look at detailed
16:19:05 <Maior> lightquake: I'm aiming for detailed because it, well, Feels Better
16:19:16 <Maior> I could just give up and use exitcode though
16:19:25 <lightquake> i mean, cabal test will still show you the output of your hspec run
16:19:28 <lightquake> it just won't be colorized
16:19:31 <Maior> hspec?
16:19:34 * Maior googles some more
16:19:56 <Maior> (this is my first real Haskell project; still got a lot of learning about, er, "ecosystem")
16:19:58 <lightquake> it's a general-purpose framework with quickcheck and hunit integration
16:20:13 <Maior> oh gosh rspec
16:20:13 * ReinH <3 hspec
16:20:15 * Maior twinges
16:20:21 <ReinH> but it's not for everyone
16:20:57 <Maior> ...actually that looks fairly reasonable
16:21:18 <ReinH> it's quite nice modulo your interest in "BDD" style
16:21:43 <lightquake> http://i.imgur.com/7vMHnnp.png
16:21:53 <lightquake> this is what a failing run of my test suite looks like
16:22:03 <lightquake> the error message is a bit unfortunately vague
16:22:13 <lightquake> but that's due to how my test is set up
16:24:24 <lightquake> anyway, i've never tried using the detailed test format, but in my (limited) experience using exitcode-stdio has been enough; if i really want pretty results i just cabal run spec
16:24:32 <Maior> lightquake: cool, thanks
16:24:47 <lightquake> er… cabal build spec && dist/build/spec/spec
16:25:07 <haasn> doctests looks cool
16:25:35 <haasn> it really blew my mind when I realized all those usage examples in ‘lens’ are actually unit tests at the same time
16:25:52 <Maior> mmm ok, lets do this
16:25:55 <Maior> hspec here I come, thanks
16:26:15 <lightquake> haasn: oh, that's neat
16:28:47 <lightquake> Preprocessing executable 'alex' for alex-3.1.0...
16:28:47 <lightquake> setup: The program alex is required but it could not be found
16:28:50 <lightquake> i appear to be stuck
16:29:10 <haasn> lightquake: hahaha
16:30:16 <lightquake> sudo aptitude install alex; cabal install alex; sudo aptitude remove alex
16:34:45 <donri> cabal's detailed should not be used yet
16:34:55 <Maior> donri: ah
16:34:56 <donri> and isn't very detailed anyway
16:35:20 <Maior> http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites wasn't hugely clear
16:35:34 <Maior> what with it giving an example etc.!
16:36:47 <donri> yeah, and detailed-1.0 doesn't even exist :)
16:37:10 <SrPx> Is anyone aware of a list that compares those Haskell-to-JS libs by showing examples of code and the compiled result? Or I will have to do it one by one?
16:39:42 <donri> SrPx: if you care about the compiled result, fay is really your only answer :p
16:40:06 <SrPx> why?
16:40:35 <SrPx> many of the libs there say they are fast, generate small code and stuff
16:40:39 <donri> the others transform core or similar
16:41:00 <donri> fast and small code isn't necessarily mutually inclusive
16:41:32 <donri> i thought if you wanted to look at the actual code output, you wanted something small and close to the source
16:46:48 <SrPx> I'm not sure, it doesn't **need** to be small, it does need to be really fast though
16:47:04 <SrPx> damn why it is so hard to find one language to do stuff
16:47:36 <user123abc> what's the rationale behind the leading-comma style used for list literals?
16:48:14 <dwcook> user123abc, one is: It's really obvious if you miss a comma.
16:48:30 <user123abc> good point
16:48:48 <user123abc> are there others?
16:49:02 <user123abc> not that I don't like the style, I'm just wondering what sorts of issues people have run into that would motivate it
16:49:57 <Maior> user123abc: I like it as a "work around" for lack of "trailing comma support"
16:50:08 <Maior> user123abc: I can't write [1,2,3,]
16:50:13 <user123abc> yeah, I was just thinking about trailing commas
16:50:15 <geekosaur> mostly that haskell allows you to have things that would not make a lot of sense in other languages (like functions as members of Num or IsString) so the error messages can get rather surprising for a dropped comma in the middle of a list
16:50:56 <geekosaur> having it out in front in a fixed column instead of at the end of the list item makes it more obvious (and harder to drop a comma in the first place)
16:51:05 <Maior> user123abc: so when that's spread across multiple lines, rather than having to edit previous line when appending, so "3" -> "3,", ++ "4"; I just ++ ", 4"
16:51:14 <user123abc> yeah, I see that point, and I definitely agree that it's useful
16:51:21 <Maior> geekosaur: ooh gp
16:51:38 <user123abc> ah, right, easy append is indeed nice
16:51:45 <Maior> I mean
16:51:48 <user123abc> or rather insert
16:51:56 <Maior> arguably that's an artifact of sucky diff functions and editing lulz
16:51:59 <Maior> but, y'know
16:52:10 <enthropy> for export lists you can have   module Foo (a,b,c,) where
16:52:57 <haasn> prepending is difficult with the “leading-comma and [ on same line” style
16:53:00 <haasn> appending is easy
16:54:17 <Maior> enthropy: ah ok
16:56:33 <Maior> so where do people usually put main?
16:57:07 <eflister> dwcook, ReinH, newsham: ah it was cuz the c's started with an option (i think...)  try was necessary...
16:57:21 <eflister> dwcook, ReinH, newsham: thanks for your help!
16:58:00 <Maior> (having just accidentally broken my program by moving main)
17:00:07 <mstksg> Maior: do you mean Main.hs, or the actual main function?
17:00:59 <Maior> mstksg: a bit of both really
17:01:39 <Maior> mstksg: I've just gone from https://github.com/doismellburning/hogstash/tree/5456417daf2b4767efb0079d9c7f4f8447ad8c7c to https://github.com/doismellburning/hogstash and broken things
17:03:48 <pharaun> user123abc: also while i found it really strange but i got used to the leading comma style it also nicely align the code in cases like [ a\n, b\n, c\n]
17:04:49 <mstksg> pharaun: that's really my favorite use of leading comma style
17:05:48 <mstksg> Maior: not sure if this is your problem, but try renamin it to Main.hs and having the module name be Main
17:06:38 <geekosaur> I've actually started using leading-comma in other languages because it's so much easier to verify than trailing comma
17:06:45 <Maior> mstksg: still looking in src alas
17:06:50 <geekosaur> although it tends to break auto-indenters...
17:06:53 <pharaun> i would get murdered if i did that here at work :)
17:07:00 <pharaun> but i'm starting to like that style as well
17:07:11 <Maior> mstksg: my bad, forgot I'd moved it - thanks
17:09:47 <mstksg> leading commas is the one thing i am convinced that every other programming language convention has got wrong
17:14:24 * hackagebot vector-space-opengl 0.2 - Instances of vector-space classes for OpenGL types  http://beta.hackage.haskell.org/package/vector-space-opengl-0.2 (AdamFoltzer)
17:30:36 <dwcook> mstksg, you mean the fact that it's not included in their conventions?
17:41:05 <Mdx> hi #haskell, how does I use criterion to generate graphicalresult? Bos post says to use -k, but it does not work. Is this related to the fact that I'm on windows (and gtk is a pain)?
17:58:07 <sclv> iirc criterion now does html output
18:08:02 <Mdx> sclv:  how can I enable that? Any idea?
18:08:40 <Mdx> sclv: I think i got the answer from SO, running now ;p
18:11:02 <wagle> whats a ~ in a type signature mean, or else what's the google-able keyword to search for?
18:11:39 <enthropy> .google ghc type families type equality
18:12:22 <nimish> is type equality different from unification?
18:12:55 <enthropy>  instance (a ~ b) => Class a b -- is a bit different from
18:12:58 <enthropy>  instance Class a a
18:13:45 <elliott> thingUsingMonadsTF :: (MonadState m, StateType m ~ Int) => m ()
18:14:06 <enthropy> they will both match cases if you have a function with a type like     (Class Int Int) => foo
18:15:16 <enthropy> but if you have the instance with a ~, this will force the int to become a Int    (Class Int int) => foo
18:15:44 <enthropy> or give a compile-time failure if it can't be unified
18:15:53 <mstksg> dwcook: yes, i do mean that.  grammar was slightly awkward, i'll admit
18:28:45 <mstksg> what typeclass do i need to be able to do [A..] to get all the members of my enumerable?
18:28:53 <mstksg> ghci doesn't seem to be happy with just Enum
18:30:25 <joelteon> what datatype should I use for an efficient heterogeneous map?
18:30:55 <geekosaur> mstkeg, add a space? A.. is parsed as operator (.) in module A
18:31:49 <Iceland_jack> @ty \a -> [a..] -- mstksg
18:31:50 <lambdabot> Enum t => t -> [t]
18:32:33 <Iceland_jack> @ty enumFrom
18:32:34 <lambdabot> Enum a => a -> [a]
18:33:45 <mstksg> geekosaur: ah, that was it.
18:34:06 <mstksg> I feel silly
18:34:40 <Iceland_jack> mstksg: To be fair it's not obvious at all
18:35:42 <shachaf> Obvious or not, you should include full code and full error message with your question.
18:39:23 <joelteon> @pl applyAll f = foldr (\a b -> a f <=< b) return
18:39:26 <lambdabot> applyAll = id (fix (const (flip (foldr . ((<=<) .) . flip id) return)))
18:39:27 <lambdabot> optimization suspended, use @pl-resume to continue.
18:39:30 <joelteon> ok no
18:44:34 <ahemmm> anyone recommend an alternative to Real World Haskell if you've been through LYAH
18:45:02 <Iceland_jack> ahemmm: Marlow's book is a good continuation
18:45:07 <lispy> ahemmm: what do you want to learn?
18:45:31 <lispy> (eg., why would you read it or an alternative, what do you plan to get out of it...)
18:45:42 <joejev> Does anyone know if it is possible to fork a process or a thread to run as another user that is not root
18:45:43 <lispy> knowing that makes recommendations easier
18:46:21 <ahemmm> lispy: just looking for some examples of how the language is used for different projects, some good idiomatic code
18:46:31 <lispy> joejev: I think in default unix permissions that requires super user privildges
18:46:45 <Iceland_jack> ahemmm: http://chimera.labs.oreilly.com/books/1230000000929/index.html
18:46:58 <geekosaur> threads can never run with a different uid. processes can, see http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-User.html#v:setUserID ff
18:47:09 <Iceland_jack> Other than that you can read through the standard libraries and other packages
18:47:18 <geekosaur> *but* that requires starting as root; it's an OS permission thing
18:47:25 <joejev> geekosaur thanks
18:47:27 <geekosaur> the compiler and libraries cannot help you
18:47:54 <lispy> ahemmm: that's harder
18:47:55 <ahemmm> thanks Iceland_jack, i'll look into that
18:48:11 <geekosaur> if you are not root, I think the best you can do is spawn a subprocess that invokes su or sudo
18:48:22 <lispy> ahemmm: I think I use Haskell differently depending on the task. I think learning about DSLs and how to embed them is very important.
18:48:38 <geekosaur> (or ksu etc.)
18:48:48 <joejev> hmm, I take it you can not set the group without root privs either
18:48:54 <geekosaur> correct
18:48:55 <lispy> ahemmm: I tend to write code that uses extensions when I'm learning the feature, but when I'm writing code that I plan to maintain I avoid most of them :)
18:49:47 <geekosaur> (exception: usually you can switch between groups in your group vector)
18:50:03 <Iceland_jack> ahemmm: There are a lot of good tutorials on School of Haskell/fpcomplete
18:50:12 <ahemmm> oooh, too high level for me maybe.
18:50:28 <Iceland_jack> ahemmm: Don't give up, I'd recommend Part II of the book (concurrency)
18:50:55 <ahemmm> whoops... lispy: oooh, too high level for me maybe.
18:51:00 <lispy> ahemmm: I'd recommend Bird's book on Haskell. It will prepare you to deeply understand the language.
18:51:01 <Iceland_jack> other than that I'd tell you to complete a pet project in Haskell, and then ask #haskell or some other place to do a code review
18:51:22 <joejev> geekosaur: well, maybe that would work, basically I wanted to have a file that could only be read/wrote to by the program or root, but not a user
18:51:51 <geekosaur> perhaps what you're looking for is setuid executables then
18:52:13 <lispy> ahemmm: http://www.cs.ox.ac.uk/publications/books/functional/
18:52:20 <ahemmm> Iceland_jack: thats what I think I'll try. Yesod maybe
18:52:34 <joejev> geekosaur: I would prefer if the program itself did not need to be invoked through sudo
18:52:36 <lispy> I bet that link doesn't work :(
18:52:42 <geekosaur> and swapping uid (setuid() can be used to switch between real and effective uid, the latter being what a setuid executable gives you)
18:52:54 <geekosaur> I think you misunderstand
18:53:02 <Iceland_jack> Best of luck to you ahemmm, I'm wondering why you wanted an alternative to RWH?
18:53:02 <ahemmm> lispy: awesome. nope, it worked.
18:53:28 <geekosaur> joejev: http://en.wikipedia.org/wiki/Setuid#setuid_on_executables
18:53:37 <lispy> ahemmm: I haven't read that one myself, but I know it's highly regarded
18:53:46 <ahemmm> Iceland_jack: I just like to know what I'm missing :)
18:54:09 <Iceland_jack> Not sure what you mean by missing
18:55:08 <ahemmm> Iceland_jack: Well there aren't a ton of haskell books out there, let alone ones focused on applications, so just wanted to see if there was something else worth checking out
18:55:32 <lispy> ahemmm: This may be too high level again, but I think one of the most important things is to write Haskell code that is understandable. We have a lot of opportunity to go too abstract and convoluted. So it's good to find a way to express what you need in the sane subset :)
18:55:36 <Iceland_jack> Ah I see what you mean, I thought you had some gripe with RWH and thus wanted an alternative
18:55:52 <geekosaur> joejev: also see `man 2 setuid` and `man 2 seteuid` (setUserId and setEffectiveUserId in System.Posix.User, respectively)
18:56:18 <ahemmm> Iceland_jack: nope, not at all.
18:56:43 <lispy> ahemmm: As an example of what I just said, I started making a raytracer in Haskell. Instead of using a type class (or other wizardry) for the objects in the scene I simply used records with functions in the fields. Functions like shapeHit that tell me when a ray collides with the current shape.
18:57:16 <Iceland_jack> I agree with lispy on writing understandable code
18:57:19 <Peaker> lispy: I think a ray tracer was one of my first programs, and indeed I did use the existential+type-class anti-pattern at least at first
18:57:22 <Iceland_jack> sometimes people use type classes needlessly
18:57:36 <lispy> ahemmm: https://github.com/dagit/haray
18:58:10 <joejev> geekosaur: so I could make the file that I want to stay hidden be owned by some new user, and then call setUserID to the user id of the new account?
18:58:15 <lispy> ahemmm: and if you're familiar with the famous (but old) opengl tutorials by nehe, I have a Haskell translation here for some of the lessons: https://github.com/dagit/nehe-tuts
18:58:15 <joejev> and then read the file?
18:58:41 <lispy> Peaker: it's an easy anti-pattern to fall into when starting Haskell
18:58:42 <geekosaur> not like that, again read those manpages I pointed you at
18:59:03 <geekosaur> you make both the file *and the program* owned by that new user, and you `chmod u+s` the program
18:59:21 <geekosaur> now when someone runs that program, it runs *as the user that owns it*
18:59:29 <joejev> ahhh
18:59:30 <joejev> thank you
18:59:34 <ahemmm> thanks lispy, and Iceland_jack for the help. cya
18:59:52 <geekosaur> and you can use seteuid to swap between those permissions, and the permissions of the user who ran it, if needed
18:59:53 <lispy> ahemmm: I think I learned how people actually write Haskell by a) Asking for lots of help here and on the mailing lists, b) writing things and figuring out what's sane and what's not
19:00:11 <joejev> geekosaur: thank you for the help.
19:00:54 <geekosaur> I suggest you study up on Unix security lest you inadvertently write a security hole of some kind that would let a user abuse your program to gain direct access to the file
19:02:50 <joejev> geekosaur: I will, however this is kind of a hobby project, and all that are being stored are seeds that will be modified and then hashed for their final result.
19:03:16 <joejev> so even if the user /did/ have access to them, it wouldn't be much of a security flaw
19:08:22 <lispy> joejev: with security vulnerabilities it's less about attacking something obvious and more about what you can get to *eventually*
19:08:37 <Tene> joejev: another alternative to changing users is selinux
19:08:41 <lispy> anyway, if it's just for a hobby project it probably doesn't too much matter
19:11:30 <begriffs> If I install GHC into a directory by doing "./configure --prefix=/directory && make install" but then I rename the directory, GHC gets messed up because paths are hard coded inside its binaries. Is there a way to rename the directory and keep GHC working?
19:12:09 <geekosaur> they're not hardcoded into binaries, but in wrapper scripts. you can edit those
19:12:22 <begriffs> I'm trying to build it as part of a Heroku buildpack, and Heroku builds it in a a temporary folder and moves it to /app/vendor afterword.
19:12:58 <begriffs> So I search/replaced all path instance in ghc-7.6.3/bin (the wrapper scripts) but then it still freaks out about library paths.
19:13:19 <geekosaur> library paths are in text files under package.conf.s
19:13:20 <geekosaur> er
19:13:23 <geekosaur> package.conf.d
19:13:50 <cschneid> can cabal sandbox point at a hosted github repo directly, or only a local dir (which I can clone into)?
19:14:12 <cschneid> ie, if I want to use somebody's in-development master HEAD, do I have to clone it down and keep it updated
19:14:17 <geekosaur> you will need to use ghc-pkg recache afterward
19:14:24 <zRecursive> begriffs: donot use ghc-7.6.3 which even cannot create normal xmonad on freebsd. suggest using ghc-7.4.x instead
19:15:16 <begriffs> geekosaur: ohhh, recache. Yeah because when I search replaced the paths in all ghc files I got a weird error: While parsing "/app/vendor/ghc-7.6.3/lib/ghc-7.6.3/package.conf.d/package.cache": too few bytes. Failed reading at byte position 51190
19:17:24 <begriffs> zRecursive: is 7.6.3 broken?
19:22:26 <td123> package cache is probably corrupt
19:23:55 <lispy> begriffs: there is some way to make this work. With the ghc binary installs you untar them, type configure (to set the prefix), and then make install. It's already built so the make install just puts the files in place.
19:25:06 <begriffs> lispy: that's true, but for the Heroku building stage I only have write access to /tmp/[random string]. So I set the prefix there. But after my script has done its work then Heroku copies this over into /app, so the paths are all wrong. I am not able to write to /app myself.
19:25:41 <lispy> begriffs: Can you do a final `./configure --prefix=` after it's built?
19:26:00 <lispy> begriffs: If so, then I think that's roughly how the tarball works.
19:26:41 <begriffs> Oh, so do configure --prefix=$BUILD_DIR && make && ./configure --prefix=/app/vendor/ghc-7.6.3 && make install ?
19:27:02 <lispy> begriffs: yeah, you might have some success with that approach
19:27:22 <lispy> begriffs: TBH, I don't know if the first --prefix is even necessary
19:27:53 <lispy> begriffs: it could be that you can just do ./configure --prefix=/app/vendor/ghc-7.6.3 && make && make install
19:28:11 <lispy> (really make all install should work instead of the two separate make commands)
19:28:29 <begriffs> Oh, but then it tries to copy the files into /app/vendor… and at this stage of the process it doesn't have access to this place in the filesystem.
19:29:13 <begriffs> Heroku's $BUILD_DIR is a temporary place where I can do whatever I want, and which then gets copied into /app
19:29:24 <begriffs> But I can't access /app at that stage.
19:29:45 <lispy> I haven't tried this with ghc, but most builds that use configure ignore the --prefix until install, I thought.
19:30:27 <begriffs> Here is what I am doing right now. ./configure --prefix $BUILD_DIR/vendor/ghc-7.6.3 && make install
19:30:34 <geekosaur> I thought make rolled the scripts and there would be some kind of destdir mechanism for the install?
19:30:54 <begriffs> So I don't even run make, only make install, because I am not building from source, I'm just installing binaries.
19:31:38 <lispy> begriffs: in that case, just setting the prefix to the final location should work
19:31:49 * geekosaur thinks it's time to stop guessing and check...
19:32:08 <startling> would this be useful to have published outside of that project? Code review is welcome, too: https://github.com/startling/coatl/blob/master/Language/Coatl/Extra/Graph.hs
19:32:20 <td123> --prefix for configure and DESTDIR for make install is usually the way to go
19:33:03 <startling> I also plan to generalize it further, so that you can preserve information about connections etc for finding cycles.
19:33:04 <geekosaur> but as usual my notwork is sucking so it'll be abit before I can verify
19:34:50 * hackagebot cryptohash 0.11.0 - collection of crypto hashes, fast, pure and practical  http://beta.hackage.haskell.org/package/cryptohash-0.11.0 (VincentHanquez)
19:35:00 <geekosaur> (hooboy, really sucking, gonna be a while...)
19:35:54 <Kevin-_-> is there a way to put a switch on one line?
19:36:13 <Iceland_jack> Switch?
19:36:19 <Iceland_jack> Do you mean "case … of"?
19:36:24 <Kevin-_-> i.e. I want to turn this: http://ideone.com/vrKbRB into an if then
19:36:25 <Kevin-_-> yeah
19:38:15 <Iceland_jack> Well the case takes care of pattern matching on the argument, and you're using the value in the result
19:38:27 <Iceland_jack> so I would stick with case
19:38:43 <Iceland_jack> also you're shadowing x there
19:39:39 <enthropy>  vars xs = foldr (\x xs -> case x of Assign x y -> x : xs; _ -> xs) [] xs
19:39:52 <Iceland_jack> Well.. you can put it on a single line like that
19:40:00 <Iceland_jack> by removing newlines
19:40:07 <Iceland_jack> > case 1 of 1 -> "one"; 2 -> "two"
19:40:08 <lambdabot>   "one"
19:41:44 <enthropy> also slightly neat:     foldr (\case Assign x y -> (x:); _ -> id) [] xs
19:41:51 <enthropy> with -XLambdaCase
19:42:14 <Iceland_jack> I think the original one was quite understandable
19:42:26 <enthropy> yes
19:43:00 <Iceland_jack> if Kevin-_- gave some further information on the data structure they're folding over it might allow more interesting comments, but it looks fine to me otherwise
19:43:34 <startling> foldr (\x xs -> maybe xs ((: xs) . fst) . preview _Assign $ x)
19:43:53 <startling> (with lens and makePrisms ''TypeOfAssign)
19:44:08 <Iceland_jack> startling: Do you find that to be a better version?
19:44:58 <startling> Iceland_jack: yeah. Maybe not in this case, but preview _SomePrism is really really nice for those cases where you want to do one thing if it's one particular case and another if it's anything else.
19:45:16 <startling> Wow, I used the worn "case" way too many times there.
19:45:23 <startling> "Word", too.
19:45:52 <Iceland_jack> :)
19:46:01 <startling> Sometimes you can even write the whole thing as a prism!
19:46:17 <Kevin-_-> lol I'm not even sure on the datastructure
19:46:26 <Kevin-_-> they said import this and here's the prototype :)
19:47:23 <Kevin-_-> yeah I guess just doing ;'s work
19:48:23 <Iceland_jack> I generally avoid ;'s in my own code except possible for do-notation
19:49:53 <startling> it's sort of depressing when you spend a lot of time with traversals and things to get all your crucial algorithms down to like ten lines and then have like two hundred lines each for pretty-printing and for file I/O.
19:50:06 <edwardk> =)
19:50:34 <edwardk> @remember startling it's sort of depressing when you spend a lot of time with traversals and things to get all your crucial algorithms down to like ten lines and then have like two hundred lines each for pretty-printing and for file I/O.
19:50:34 <lambdabot> Done.
19:50:51 <geekosaur> ok, poking at the actual build stuff, ghc does indeed uses DESTDIR for the install, so you configure with the final path but make install DESTDIR=...
19:51:12 <startling> edwardk: see also: that example for "bound"
19:51:21 <edwardk> startling: example?
19:51:30 <geekosaur> begriffs: see my previous
19:51:33 <begriffs> geekosaur: cool, I'll try that.
19:51:49 <startling> edwardk, this part specifically: https://github.com/ekmett/bound/blob/master/examples/Simple.hs#L141
19:52:02 <startling> everything else is so nice and elegant. =(
19:52:06 <edwardk> startling: yeah
19:52:29 <ubikation> hey I'm following a tutorial that uses cabal-dev... should I be using that? I remember seeing a flurry of stuff on reddit about incorporating it into the normal cabal?
19:52:44 <skymaker> Hey all; I'm a newbie having some trouble getting CV to install from hackage using cabal.  Can anyone give me some guidance as to how to get it running?  Pastebin of my console output follows:  http://pastebin.com/C2iknPrx
19:52:50 <mauke> The paste C2iknPrx has been copied to http://lpaste.net/93618
19:53:07 <begriffs> ubikation: use cabal 1.18 with its built-in sandboxes instead of cabal-dev.
19:53:10 <zRecursive> begriffs: sorry, i just come back. The xmonad built with ghc-7.6.3 sometimes will lose response when striking keys. and `spawn` doesnot work normally ,etc.
19:53:13 <startling> edwardk: @hackage print isn't taken yet. 8)
19:53:44 <ubikation> skymaker: what version of ghc and haskell-platform do you have?
19:53:46 <geekosaur> skymaker, if this is the first time you're using cabal-install then you'll need to add $HOME/.cabal/bin to $PATH
19:53:54 <geekosaur> cabal-install can't do that for you
19:54:42 <skymaker> geekosaur: Thanks, that may well be the problem.  I'm a little confused though; if that is the case, then why does the prior package, c2hs, seem to install without problems?
19:54:56 * hackagebot bindings-DSL 1.0.19 - FFI domain specific language, on top of hsc2hs.  http://beta.hackage.haskell.org/package/bindings-DSL-1.0.19 (MauricioAntunes)
19:55:05 <startling> skymaker, it's trying to use the command-line program "c2hs" but isn't finding it.
19:55:12 <user123abc> I'm trying to express the operand restrictions of x86-64 instructions in haskell's type system
19:55:21 <geekosaur> it did install. it did NOT )(and can not) tell your shell to `export PATH=$HOME/.cabal/bin:$PATH`
19:55:26 <edwardk> startling: hah
19:55:37 <edwardk> startling: i have a shorter printer example using the PHOAS stuff
19:55:38 <geekosaur> so since it's not in $PATH, the next run can't find it
19:55:47 <startling> edwardk: PHOAS?
19:55:54 <geekosaur> you'll also want to adjust your shell dotfiles to set $PATH in new shells
19:56:05 <skymaker> startling, geekosaur; Great, that makes sense.  I'll give that a shot, thanks a bunch! :D
19:56:06 <user123abc> a natural way to do it is to nest data types, but the nesting constructors are a nightmare
19:56:22 <edwardk> https://www.fpcomplete.com/user/edwardk/phoas
19:56:28 <user123abc> I've come up with something that can express those restrictions via GADT and phantom types, but then I can't pattern match on it
19:56:34 <user123abc> http://lpaste.net/212541812466778112
19:56:55 <startling> edwardk: cool, thanks!
19:57:02 <user123abc> can I go any further with this approach?
19:57:04 <ubikation> I have ghc 7.4.2 and I'm on fedora. should I uninstall ghc, haskell-platform and install 7.6.3 manually?
19:57:21 <ubikation> cabal is at 1.14... can I force it to go to 1.18?
19:57:42 <startling> user123abc: I've gotten stuck before on that problem too. I'm not sure there is a good solution.
19:57:44 <edwardk> startling: http://www.reddit.com/r/haskell/comments/1mo59h/phoas_for_free_by_edward_kmett/ccbxzoo shows a slightly shorter pretty printer
19:57:55 <zRecursive> ubikation: `cabal install cabal-install` does upgrade it
19:58:05 <user123abc> startling, what did you wind up doing?
19:58:17 <ubikation> zRecursive: thanks!
19:58:19 <startling> user123abc, giving up. :(
19:58:27 <startling> edwardk, that is pretty nice.
19:58:45 <edwardk> startling: still kinda noisy, but okay
19:58:54 <user123abc> anyone have any ideas, to save me from startling's fate?
19:59:51 <user123abc> here's the starting point, and what I'd like to avoid:
19:59:52 <user123abc> http://lpaste.net/6595773910598287360
19:59:57 <startling> edwardk: yeah. I think something like ansi-wl-pprint would help (especially for dealing with spacing and stuff, and doubly so for consoles) but on the other hand ansi-wl-pprint kind of limits things uncomfortably.
20:00:41 <startling> user123abc: (fwiw, my thing was supposed to be a well-typed CSS DSL. There are a lot of freaking types in CSS.)
20:00:50 <ubikation> so I can install cabal-install but it seems like cabal still refers to the 1.14 version?
20:01:20 <user123abc> I'm kind of torn because the code that deals with these types is so hideous that I can barely parse it because of the nesting
20:01:45 <user123abc> but if I remove the type restrictions, I'll lose the help of the type system in designing my code
20:01:59 <begriffs> geekosaur: oh, looks like DESTDIR applies on top of prefix. It's now installing to /app/vendor/ghc-7.6.3/app/vendor/ghc-7.6.3
20:01:59 <startling> user123abc, lenses and prisms might help.
20:02:20 <ezyang> Why are adjunctions in 'adjunctions' representable?
20:02:47 <geekosaur> begriffs, yes, that's how DESTDIR works. normally you'd set it to your temporary install spot /tmp/foo or whatever to get /tmp/foo/app/vendor/...
20:03:11 <geekosaur> (most packaging systems expect that behavior)
20:03:21 <geekosaur> (in fact, most *demand* that behavior)
20:03:36 <dmj`> Is implementing the State Monad from scratch considered difficult?
20:04:37 <Iceland_jack> dmj`: If you're an intermediate Haskeller it shouldn't be that hard
20:04:57 <Iceland_jack> first wrap your head around how the State monad works conceptually, then try to implement
20:04:59 <begriffs> geekosaur: I had it working in a weird way, by rewriting all the strings. The hint about ghc-pkg recache fixed the extremely weird errors I was getting. Now my only problem is that it can't load libgmp.so. The library is in /usr/lib/libgmp.so.3 and I don't have permissions to symlink it.
20:06:32 <Iceland_jack> dmj`: In fact I'd recommend that you emulate the State monad by writing a series of functions that operate on tuples of (state type, return type): this should be fairly simple
20:07:24 <startling> dmj`: no. it's pretty simple.
20:07:54 <skymaker> geekosaur, startlet: Hum.  I tried running `export PATH=$HOME/.cabal/bin:$PATH` in my terminal as you suggested, geekosaur, but I'm still getting the same behavior when I try to install CV.  I tried reinstalling c2hs again, just in case, but no change.  Any idea what else I might be overlooking?  /:I
20:08:02 <skymaker> startling*, pardon me
20:08:21 <startling> skymaker: you didn't sudo cabal install, did you?
20:08:55 <startling> skymaker, might want to ls $HOME/.cabal/bin just to make sure that's where it ended up.
20:08:59 <skymaker> startling: Yes, in fact I did.  It didn't seem to be working correctly when I ran it as a normal user.
20:09:17 <skymaker> I assumed (incorrectly it seems) that it needed elevated privledges.
20:09:29 <geekosaur> that one is harder to fix but consider LD_LIBRARY_PATH or using objcopy to change the mebedded rpath
20:09:34 <startling> skymaker, it should work fine as user. it's actually preferable.
20:09:35 <geekosaur> skymaker: ^^
20:09:45 <geekosaur> oops
20:09:49 <geekosaur> wrong person, sorry
20:10:07 <geekosaur> begriffs: that one is harder to fix but consider LD_LIBRARY_PATH or using objcopy to change the embedded rpath
20:10:13 <startling> geekosaur: I was going to say that reinstalling would be way easier. :)
20:10:14 <skymaker> startling, geekosaur; Thanks, I'll check into it further then.  Now I at least know what I ought to be looking for. /:P
20:11:03 <user123abc> aha!
20:11:32 <user123abc> http://lpaste.net/1255429931442110464
20:11:38 <user123abc> this approach does indeed do what I want
20:12:07 <user123abc> I do have to explicitly leave free type variables in the signatures of my functions, but I can deal with that
20:12:58 <startling> user123abc: free type variables aren't so bad, so long as you don't need more than 26.
20:12:59 <user123abc> but I do get the compile error that I hoped for when I uncomment that commented-out line
20:13:05 <user123abc> hehe
20:13:17 <ubikation> hey what's the deal with this: http://lpaste.net/93619 ?
20:13:25 <user123abc> well, compiling x86 is a good baby step, I'd say
20:13:39 <dmj`> > flip evalState 100 $ modify (+1) >> get
20:13:40 <lambdabot>   101
20:13:54 <startling> user123abc: it's a neat project, anyhow
20:13:56 <geekosaur> begriffs, also there is http://nixos.org/patchelf.html
20:14:29 <user123abc> man, I'm quite happy now
20:14:31 <startling> what was that x86 thing? I want to say it was called "valkyrie", but I guess that's not right.
20:14:37 <user123abc> Haskell, you toy with my heart
20:15:37 <user123abc> startling, haven't heard of it - this is a just a toy compiler for a course
20:15:56 <geekosaur> ubikation, check order in $PATH (first one found is used), also note that shells cache where they found programs, try `hash -r` or `rehash`
20:16:07 <startling> user123abc: sure. I just suddenly wondered whether the other thing did anything nice type-wise like yours.
20:16:38 <user123abc> ah, yeah, that would be interesting to look at
20:16:57 <geekosaur> ubikation, also note that `cabal` is the library package, it comes with your compiler; `cabal-install` is the package for the cabal executable
20:16:59 <user123abc> I kind of assumed that nesting constructors is a common annoyance
20:17:21 <user123abc> since I've found myself writing nesting data type constructors of form "Foo = ... | Bar Bar"
20:17:23 <user123abc> kind of often
20:17:44 <startling> user123abc: the thing to do is write abstractions that make it so you don't need to pattern-match.
20:18:25 <geekosaur> (this is because things like cabal sandbox don't generally require that the library component used by the compiler be updated)
20:18:39 <user123abc> I dunno, I don't really understand types that well, but I think that this is somehow a problem of haskell rather than of the abstraction
20:18:48 <startling> traversable, foldable, etc might make this nicer for you. not exactly sure and also kind of hard.
20:18:59 <startling> maybe Plated from lens?
20:19:04 <user123abc> it should be possible to model the x86 requirements, for instance
20:19:11 <user123abc> (and it is, to be fair)
20:19:58 * hackagebot trifecta 1.2 - A modern parser combinator library with convenient diagnostics  http://beta.hackage.haskell.org/package/trifecta-1.2 (EdwardKmett)
20:20:45 <startling> it's definitely possible. I'm mostly curious whether it's /nice/.
20:22:47 <startling> It's called "harpy". I thought it was "valkyrie". Guess I should get my demigodesses straightened out.
20:23:34 <startling> user123abc: I guess this is another approach: http://hackage.haskell.org/package/harpy-0.5.0.0/docs/Harpy-X86Assembler.html
20:24:22 <user123abc> ah, thanks for tracking that down
20:24:32 <user123abc> but damn, that looks...
20:24:59 <startling> yeah.
20:25:11 <user123abc> oh geez
20:25:21 <user123abc> lol, I was going to ask "could I do this with type classes somehow?"
20:25:25 <user123abc> the answer is no
20:25:36 <joelteon> the answer is "don't"
20:25:40 <startling> "yes, but ..."
20:34:38 <dmj`> startling: Is implementing StateT from scratch considered difficult
20:35:57 <startling> dmj`: it's not so different
20:52:05 <wagle> anyone gotten this before?  what does it mean, exactly:
20:52:06 <wagle> $ ./test4 < knapsack1.txt
20:52:06 <wagle> test4: <<loop>>
20:53:30 <argiopeweb> wagle: It means you have an infinite, unproductive loop.
20:54:00 <argiopeweb> Which the GHC runtime has detected and automagically killed for you.
20:54:27 <wagle> hahah..  impossible, of course, I have "no" unbounded loops
20:54:47 <wagle> oh well, it would have been too simple to be done now
20:54:56 <wagle> argiopeweb: thanks
20:55:06 <argiopeweb> wagle: Are you running 7.6.2? It had a bug which could cause <<loop>>
20:55:29 <argiopeweb> It's the only fix in 7.6.3, amusingly.
20:55:39 <wagle> The Glorious Glasgow Haskell Compilation System, version 7.6.3
20:56:01 <argiopeweb> Hmph. All I can say is, if you know it shouldn't be there: bug report.
20:56:28 <wagle> it will take a bit to prove its not me
20:56:56 <arkeet> interested in sharing the code?
20:56:59 <argiopeweb> Is the code shareable? Many hands...
20:57:28 <wagle> its an assignment, let me first get stuck
20:57:46 <argiopeweb> Ah, okay.
21:02:21 <wagle> found it
21:04:32 <wagle> .. or not
21:09:35 <wagle> argiopeweb, arkeet: is there a way to turn it off (in case its confused)
21:11:17 <argiopeweb> wagle: Not that I'm aware.
21:11:20 <startling> {-# LANGUAGE HaltingProblem #-}
21:12:01 <startling> wagle, you may want to look at ghci's debugging stuff
21:12:18 <argiopeweb> wagle: If you can post your code, I'm sure someone here could give you some advice without giving away any solutions.
21:12:18 <startling> wagle, Debug.Trace might also be useful
21:12:32 <argiopeweb> And everything startling is saying.
21:12:36 <startling> -Wall might come up with something, too.
21:12:46 <startling> (e.g., accidental shadowing)
21:13:11 <startling> (everything I'm saying, except the LANGUAGE pragma -- that was a joke)
21:13:54 <argiopeweb> Right right... Already chuckled over that and moved on. Not the LANGUAGE pragma.
21:17:26 <wagle> prints "chop!" then goes into infinite loop: http://lpaste.net/93626
21:19:20 <RommelVR_> I know this is terrible, but I'm at a loss on how to get it to work :S https://gist.github.com/RommelVR/d75296984c1edbc18bdf
21:20:02 <RommelVR_> I also wanted to stop it at x == 512 && y == 512 :S
21:20:07 <argiopeweb> wagle: I'll give it a look over.
21:20:25 <argiopeweb> RommelVR_: Could you put a brief summary of what you're trying to do in the file?
21:20:38 <RommelVR_> argiopeweb: I
21:21:15 <RommelVR_> argiopeweb: I am trying to print 512x512 lines with 3 values sampled based on the x/y positions (naturally, 0 <= x <= 512 and 0 <= y <= 512)
21:21:24 <wagle> -Wall found it
21:21:37 <argiopeweb> wagle: Heh, just switching over to my laptop. What was it?
21:21:49 <wagle> second <- blah
21:22:02 <wagle> let second = ... second ...
21:22:11 <argiopeweb> Yep, that'd do it.
21:22:30 <xpika> how can i add gcc flags to ghc?
21:22:58 <Shin-LaC> should I avoid having uppercase variables?
21:22:58 <startling> wagle: heh. that's a pretty common way to do yourself in.
21:23:31 <pharaun> i've actually never ran into the <<loop>> by accident
21:23:37 <startling> Shin-LaC, what's a variable?
21:23:46 <pharaun> tho saying that, i probably will be running into it in the next hour or so :)
21:23:57 <Shin-LaC> a function argument, or one set in let
21:24:18 <argiopeweb> Shin-LaC: So, let vARIABLE = ...?
21:24:30 <startling> Shin-LaC, OK. I don't think those are ever allowed to be capitalized.
21:24:34 <Shin-LaC> ah
21:24:39 <enthropy>  _VARIABLE can work
21:24:43 <Shin-LaC> sorry for the dumb question
21:24:49 <argiopeweb> To be pedantic, it's a binding. ;)
21:24:50 <startling> I don't see why you would want that.
21:25:09 <wagle> it worked
21:25:30 <startling> (But I'm the sort of person who uses all-lowercase for even CPP macros, so . . .)
21:25:34 <argiopeweb> enthropy: Good call, though that will may have the unintended side-effect of making the unused binding detector ignore it.
21:25:39 <Shin-LaC> what if I want an uppercase underscore
21:25:39 <wagle> now for the hard part, optimizing the bejeezuz out of it
21:25:52 <startling> > toUpper
21:25:53 <lambdabot>   <Char -> Char>
21:25:58 <startling> > toUpper "_"
21:25:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:25:59 <lambdabot>              with actual type...
21:26:03 <startling> UGH
21:26:09 <startling> > toUpper '_'
21:26:10 <lambdabot>   '_'
21:26:16 <startling> Shin-LaC: use that one ^
21:26:20 <enthropy> probably there's something else that's lowercase and inconspicuous
21:27:02 <enthropy> is there a pre-existing solution for multi-line doctests?
21:27:03 <RommelVR_> argiopeweb: any ideas :S
21:27:23 <startling> enthropy: I wonder if :{ works
21:27:36 <argiopeweb> RommelVR_: Sorry, got caught up in wagle's <<loop>>. Let me take a look.
21:27:36 <enthropy> yes it does with a bit of hacking
21:27:43 <enthropy> startling: but it's quite ugly http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-Record.html#g:9
21:28:09 * enthropy put so much effort into indenting only to have haddock strip it all out
21:28:14 <startling> >:(
21:28:35 <enthropy> as in I had to modify doctest to support this
21:29:10 <startling> it seems like doctesty things are nice in theory but kind of terrible sometimes.
21:29:16 <enthropy> and in this case it's not like we can use leading semicolons
21:29:34 <enthropy> well it's just the presentation that's a bit ugly
21:29:52 <argiopeweb> RommelVR_: I'll just go ahead and comment on the Gist.
21:30:05 <enthropy> don't you think it would be useful if the :{ and :} were not emphasized... and indentation was preserved?
21:30:17 <enthropy> basically formatting like you get with a line of >
21:30:29 <enthropy> plus syntax highlighting of course
21:31:04 <enthropy> Fuuzetsu: are these complaints of mine somewhere in the TODO?
21:31:07 <enthropy> for haddock
21:31:25 <argiopeweb> RommelVR_: Ooh, just noticed the x/z switchover. Give me a sec.
21:35:15 <RommelVR_> argiopeweb: cheers a tonne man
21:35:25 <RommelVR_> argiopeweb: Waiting on a copy of haskell for a great good haha
21:35:40 * wagle OOM's his notebook on the Really Big dataset
21:36:07 <argiopeweb> RommelVR_: Good good book. Also recommend Real World Haskell.
21:36:26 * ijp didn't like "learn you a haskell"
21:38:26 <ijp> is the only reason Data.Set is not a Functor the ordering constraint?
21:38:30 <argiopeweb> RommelVR_: Not 100% sure that's what you're looking for, but try that.
21:38:40 <startling> ijp: no. consider fmap (const 2)
21:39:22 <RommelVR_> argiopeweb: will check it out now sec
21:39:26 <ijp> startling: I considered that, but I wasn't entirely sure it ruled it out
21:39:44 <startling> wait, maybe it doesn't.
21:40:19 <startling> I guess it doesn't. the second Functor law still holds.
21:40:27 <ijp> but it's certainly a weird one
21:40:29 <startling> (since functions are single-valued &c.)
21:40:41 <ijp> because my mental picture was the same as I imagine your is
21:40:55 <ijp> which is that you have a structure, and you are "relabelling" it
21:40:58 <startling> I think the Ord thing might be the only thing, yeah.
21:41:07 <startling> ijp, it's a little bit more complicated than that. :)
21:41:07 <ijp> intuition, a funny thing
21:41:22 <startling> consider fmap on functions.
21:41:34 <ijp> yes, I was carefully avoiding thinking about that one :)
21:41:53 <RommelVR_> argiopeweb: thats awesome (and I mostly understand it, which is better haha), but where does the Control.Monad come into play?
21:42:20 <startling> ijp: Const is another weird one (but I guess it fits with your "relabelling" thing in a fatuous way)
21:42:41 <argiopeweb> RommelVR_: It doesn't any more, my bad. I went through an iteration with forM_ before realizing I was Doing It Wrong.
21:42:58 <argiopeweb> Updated it out.
21:44:50 <Mdx> Hey any ghc hacker around? I just posted a SO question and would appreciate some feedback.
21:44:56 <argiopeweb> RommelVR_: Two big things I try to follow are: 1, Do as much as possible in pure functions (not IO) by building data structures and then outputting them in IO as necessary, and 2, avoid primitive recursion unless entirely necessary.
21:45:08 <argiopeweb> Mdx: Might try #ghc. Mind linking the SO question?
21:45:18 <Mdx> argiopeweb: http://stackoverflow.com/questions/19086059/is-there-an-optimization-similar-to-loop-unroll-for-functional-programming
21:45:42 <Mdx> (SO is not oppening here, can't see what have been posted ¬¬)
21:45:59 <RommelVR_> argiopeweb: I agree with 1 entirely, but am just starting out :S, though coming from system programming (C++/D), the list builder approach seems less intuitive compared to loop/recursion
21:48:19 <argiopeweb> RommelVR_: I come from a similar background (high performance modeling and hard real-time embedded C++/C), and I found that it helped in the beginning to think about what it's actually doing in the background. Conceptually you're building a giant data structure and walking across it, but in actuality that's being evaluated as a loop walking down the list, creating the tuple, printing the tuple, and moving to the next list element.
21:51:42 <argiopeweb> Mdx: Not a GHC hacker, but Daniel Wagner has mentioned everything I would, complete down to the GHC plugin.
21:52:22 <RommelVR_> argiopeweb: yeah that is what I thought would be happening, generators/lazy evaluation everywhere
21:53:30 <Mdx> argiopeweb: well, I can assure you it's not noise. The third value was wrong due to a stupid mistake on the code I've sent.
21:53:58 <argiopeweb> RommelVR_: Pretty much. The one place you might not want it is in the actual calculations, so, were you to require high performance, I'd make a strict 3-tuple data structure to store the output of sample.
21:54:41 <RommelVR_> if its not a problem, could you throw a comment of what a strict 3-tuple might look like?
21:54:45 <argiopeweb> RommelVR_: Though if you mean sample in the context I'm used to (Bayesian statistics), that would likely not be recommended.
21:54:47 <argiopeweb> Sure.
21:55:00 <argiopeweb> Mdx: I'd need to take more of a look to comment give me a sec.
21:55:11 <Mdx> argiopeweb: okk, thanks
21:57:14 <startling> RommelVR_: data Whatever = Whatever !Int !Char !Bool
21:58:03 <argiopeweb> RommelVR_: There you go. Comment on the same gist.
21:59:27 <argiopeweb> RommelVR_: You can drop the UNPACK pragmas if you compile with -funpack-strict-fields. Again though, may not be a performance gain if you're doing anything more significant than basic arithmetic to get those values.
22:00:16 * hackagebot wai-app-file-cgi 0.8.5 - File/CGI/Rev Proxy App of WAI  http://beta.hackage.haskell.org/package/wai-app-file-cgi-0.8.5 (KazuYamamoto)
22:02:21 <RommelVR_> argiopeweb: nice, won't use it, but good to know ;)
22:02:38 <argiopeweb> Mdx: Regardless of the possible performance increases, I don't think it's reasonable for a general solution. The strictness issue that Daniel mentioned is a killer.
22:03:26 <argiopeweb> RommelVR_: Good trick to have. There's an entire chapter on the subject in Real World Haskell, and Don Stewart has written at length on his blog and on Stack Overflow on the topic.
22:03:56 <Mdx> argiopeweb: couldn't be still valuable with some pragma?
22:05:40 <argiopeweb> Mdx: Possibly in an annotation context like the GHC loop unrolling plugin it could be useful, but applying it to an entire file seems excessive. I think you'd run into an issue with control (what are the criteria for stopping the unrolling?)
22:06:45 <argiopeweb> Again though, not a GHC hacker. There are folks with much more knowledge than I who could likely either give a more compelling reason this doesn't exist, or take it under consideration for GHC.
22:08:11 <argiopeweb> Still an entirely valid micro-optimization, assuming it doesn't somehow break list fusion.
22:09:50 <Mdx> It looks like unrolling does exactly what I was talking about
22:10:42 <Mdx> let see if I get the same performance
22:16:18 <Mdx> argiopeweb: to use a ghc-plugin, just using the annotation is enough or I need to use some extra flag while compiling?
22:16:43 <argiopeweb> Mdx: There's a compiler flag too. It's listed in one of the other plugins. Let me check.
22:17:17 <Mdx> argiopeweb:  i guess is -fplugin=LoopUnrolling.Plugin
22:17:23 <argiopeweb> Mdx: Check the front page for http://hackage.haskell.org/package/const-math-ghc-plugin
22:18:06 <argiopeweb> Looks like that should work if you aren't building with cabal (both ways listed in const-math-ghc-plugin)
22:26:49 <Mdx> argiopeweb: it's weird, while compiled it links to the plugin, but on runtime I have 0 effect on time whatsoever. Even playing around with the number of unrolls
22:28:09 <argiopeweb> Hmm. Not sure what's up with that (I've never used that particular plugin before). It's a bit light on documentation as well.
22:28:21 <argiopeweb> Perhaps thoughtpolice could shed some light on it.
22:29:28 <Mdx> I'm probably doing something wrong too, can't remember if I ever used plugins before
22:29:38 <Mdx> maybe bangpattern, but that's overused :p
22:30:27 <argiopeweb> BangPatterns is an extension. Built into the compiler.
22:30:37 <Mdx> oh, true
22:30:39 <user123abc> when I enable the GADTs, working code fails to compile
22:30:51 <user123abc> the GADTs GHC extension, I mean
22:31:10 <user123abc> is this normal? is there something to be done about it?
22:32:06 <argiopeweb> user123abc: Could you paste your compiler errors to hpaste?
22:32:08 <mauke> user123abc: fails how?
22:32:28 <user123abc> derp, 1 sec
22:33:15 <vinz0r> I was just browsing the website at http://www.haskell.org/platform/linux.html, the ArchLinux link is dead, and should be https://aur.archlinux.org/packages/haskell-platform/ instead. Is there anyone here that can fix this?
22:36:24 <user123abc> http://lpaste.net/504359830635413504
22:36:38 <user123abc> I can send the offending code privately as well
22:36:49 <user123abc> looks like an instance of this: http://www.mail-archive.com/haskell-cafe@haskell.org/msg90477.html
22:37:45 <user123abc> the worse thing is that, on a more recent version of the code, this may be breaking parsec as well
22:38:03 <user123abc> (can't totally be sure, since the rest of it won't compile at present either)
22:41:34 <Mdx> well you probably can undefine everything to test if parsec is broken, but all that hassle shouldn`t help you  anyway.
22:42:31 <user123abc> by enabling ScopedTypeVariables, I was able to get my own code compiling
22:42:47 <user123abc> but only far enough to expose the errors in Parsec code
22:44:46 <user123abc> adding the NoMonoLocalBinds extension got everything compiling again
22:45:01 <user123abc> (both of those were suggested by that post)
22:45:23 <user123abc> sadly, now I'm relying on two extensions that I don't understand at all :(
22:45:38 <user123abc> though I guess this means that I didn't understand -XGADTs either
22:48:09 <zRecursive> user123abc: You can use it even if you donot understand it now. And in the future you will understand it.
22:52:28 <Mdx> darn, I have no idea how to read a core dump
23:06:26 <NemesisD> i miss hayoo :(
23:08:39 <NemesisD> i learned a trick one time which I forgot that allowed one to write (<||>) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
23:09:16 <shachaf> liftA2 (||)?
23:11:03 <NemesisD> ah yes! i'm going to need to think a bit about how that actually works
23:11:40 <NemesisD> is that using Applicative ((->) a)?
23:12:42 <pavonia> yes
23:13:14 <NemesisD> how does one read that? i'm hoping it can help me build a better intuition about it
23:13:42 <pavonia> What do you mean, read what?
23:14:28 <pavonia> :t liftA2 (||)
23:14:30 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
23:14:48 <pavonia> :t liftA2 (||) `asAppieldTo` (undefined :: a -> Bool)
23:14:49 <lambdabot>     Not in scope: `asAppieldTo'
23:14:49 <lambdabot>     Perhaps you meant `asAppliedTo' (line 148)
23:14:56 <pavonia> :t liftA2 (||) `asAppliedTo` (undefined :: a -> Bool)
23:14:57 <lambdabot> (a -> Bool) -> (a -> Bool) -> a -> Bool
23:15:12 <NemesisD> read Applicative ((->) a)
23:15:49 <NemesisD> is that like "function application is an instance of the Applicative typeclass"
23:15:51 <pavonia> "(->) a b" is "a -> b"
23:16:51 <arkeet> you can think of (->) a as (a ->)
23:17:03 <ozkar_> hello
23:17:07 <arkeet> hello
23:17:40 <zRecursive> :k (->)
23:17:41 <lambdabot> * -> * -> *
23:21:27 <ozkar_> i have a really bad habit
23:21:49 <ozkar_> i hava functions that convert stuff, like string2Double, Double2String, etc...
23:22:01 <ion> read, show
23:22:14 * ion cringes at “2” :-P
23:22:31 <ozkar_> thing is, my functions definitions are always stuff like: function :: Double -> Double
23:22:45 <ozkar_> i need to change them into (Num a) => a -> b or something like that?
23:23:02 <ozkar_> ive yet to grasp generic definitions...
23:23:08 <ozkar_> is the word maybe polimorphic?
23:23:12 <ion> Remove the type signature and look at what GHC infers for it.
23:23:48 <ion> When you compile with -Wall (and optionally -Werror) it’ll suggest missing top-level type signatures, and you can also load a file in ghci and use :t
23:25:11 <ozkar_> ion: so its better to trus ghci in these kinds of things?
23:25:18 <ozkar_> also, the 2 is awesome :p
23:26:10 <ion> Trust yourself, but feel free to ask GHC for the most generic type signature. You may or may not want to actually use it.
23:27:58 * wagle strictifies for great speedup
23:28:17 <wagle> (ugh?)
23:30:03 <MedDev> my cabal update hasn't worked since the hackage2 switchover :/ anyone else having problems?
23:30:44 <ozkar_> ion: yeah, that works for me.
23:30:52 <ozkar_> so far ive enjoyed haskell a lot.
23:31:00 <ozkar_> making a haskell grup at my uni btw
23:31:01 <ScriptDevil> Hi, I am interested in understanding the following. I get what Monads, Applicative and other typeclasses are. I also see their point. But sometimes people say - We chose to model this as Applicative since it allows structure exploration etc. Is there some resource that indicates the features of these structures beyond the list of functions required to be implemented?
23:31:03 <wagle> macosx?
23:31:33 <wagle> MedDev: macosx?  xcode 5?
23:31:43 <ion> scriptdevil: Category theory, i suppose.
23:32:33 <MedDev> wagle, no, Fedora 18. just gunna reinstall haskell platform see if that fixes it. i probably broke it :)
23:32:59 <wagle> MedDev: ah, i dunno then, anyway
23:34:20 <lulzplzkthx> This is going to be the dumbest question in the world... I'm trying to follow a guide. Here's my code: https://gist.github.com/JohnMaguire2013/6760044
23:34:26 <lulzplzkthx> Code comes from: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/#introduction
23:34:39 <lulzplzkthx> 020_very_basic.lhs line 5: unlit: No definitions in file (perhaps you forgot the '>'s?)
23:34:44 <lulzplzkthx> I get this error and I have no clue why.
23:36:16 <MedDev> in literate haskell all of the code is preceded by >'s look at http://www.haskell.org/onlinereport/literate.html lulzplzkthx
23:36:17 <ScriptDevil> lulzplzkthx: You are using the lhs extension
23:36:46 <ScriptDevil> lulzplzkthx: Which expects > before every code line. Use .hs as your extension and you should be fine
23:36:49 <Kaidelong> why does random-fu have no transformation from Rvar to []?
23:36:51 <lulzplzkthx> ahh
23:37:07 <lulzplzkthx> thank you. in that case i find it weird that my other code ran o.o
23:37:42 <lulzplzkthx> oh, heh, i had named it .hs
23:37:47 <lulzplzkthx> awesome, thanks a lot guys.
23:38:52 <ScriptDevil> ion: Just noticed the reply. Is there a Category theory from a Haskell viewpoint? I am really not keen on picking up some abstract algebra textbook and get lost in rings and groups.
23:39:32 <Kaidelong> runRVar looks like it could work like that but they you see that [] is not an instance of MonadRandom
23:42:24 <ion> scriptdevil: Dunno. FWIW, i have been reading and enjoying http://math.ucr.edu/home/baez/rosetta.pdf
23:44:00 <ScriptDevil> ion: Will check it out. Thansk
23:44:02 <ScriptDevil> *Thanks
23:47:44 <Maior> :type (<|>)
23:47:58 <Maior> :t (<|>)
23:48:00 <lambdabot> Alternative f => f a -> f a -> f a
23:48:32 <Kaidelong> listFromRVar rvar state = v : listFromRVar(rvar,state') where (v,state') = sampleState rvar state
23:48:34 <Kaidelong> this look right?
23:52:05 <JFS2> e
23:52:06 <JFS2> http://believeintheholybible.blogspot.com/2013/09/revelation-1411.html
