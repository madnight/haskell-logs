00:00:05 <carter> Ghoul_: if you can ID whats triggering this extra work
00:00:25 <carter> and help me and otherws better understand what a better sequence *should* be
00:00:29 <carter> please ;
00:00:31 <carter> :)
00:00:34 <carter> i'm crashing though
00:00:35 <carter> night all
00:00:54 <elifrey> carter: night
00:01:34 <Ghoul_> carter: https://gist.github.com/kvanberendonck/6577427
00:01:49 <Ghoul_> that's about all I can really comment on the issue from what I understand
00:03:19 <Ghoul_> you had an idea a while back about fusing basic blocks which would probably reduce this to an extent
00:04:02 <Ghoul_> each time you tell llvm to put things back in the stack, and there's *many* things, it runs out of registers and generates shit code because of, from what I can see, point #4
00:09:54 <johnw> can I set an environment variable so that cabal uses a specific sandbox?
00:10:08 <johnw> for example, I have a sandbox in ~/foo, and I want cabal to use it even though I'm in ~/bar
00:12:24 <ion> Would cabal sandbox init --sandbox work for you?
00:12:53 <johnw> if I could specify that in a CABAL_SANDBOX envvar, it would be perfect
00:18:49 <pharaun> @pl e = L.drop (L.length a - 1) a
00:18:49 <lambdabot> e = L.drop (L.length a - 1) a
00:18:59 <pharaun> hmmph
00:19:13 <joelteon> you might have to parameterize e with a
00:20:48 <pharaun> @pl e a = L.drop (L.length a - 1) a
00:20:51 <lambdabot> e = id (fix (const (ap (L.drop . flip ((-) . L.length) 1) id)))
00:20:52 <lambdabot> optimization suspended, use @pl-resume to continue.
00:21:06 <pharaun> ha that's gross, nah i'll stick with the regular version :)
00:44:43 <johnw> @pl \a -> L.drop (L.length a - 1) a
00:44:46 <lambdabot> ap (L.drop . flip ((-) . L.length) 1) id
00:44:46 <lambdabot> optimization suspended, use @pl-resume to continue.
01:43:19 <Ghoul_> @src join
01:43:19 <lambdabot> join x =  x >>= id
01:43:38 <Ghoul_> johnw: I think you can do that like this
01:43:54 <Ghoul_> join L.drop (L.length . pred) a
01:44:15 <Ghoul_> (which would be reasonably point-less, which I think is what you're going for)
01:44:22 <pharaun> yeah
01:44:41 <pharaun> that would be reasonably but in the end i stuck with the pointfull version ;p read better
01:44:59 <Ghoul_> oh, must've tagged the wrong person :P
01:45:13 <pharaun> nah both :)
01:45:41 <pharaun> i was who did the first pl query then johnw modified it a bit to see if it would work better
02:28:11 <Taneb> What's the easiest way to see if a bunch of lists share any elements?
02:28:36 <danr> @type (==) <*> nub
02:28:38 <lambdabot> Eq a => [a] -> Bool
02:28:56 <Taneb> Bunch of sets, sorry
02:29:54 <scalable> which library in haskell for html decoding string/text?
02:30:42 <scalable> like "M &amp; M" -> "M & M"
02:50:21 <revtintin> is there an equivalence operator in Haskell? (e.g. P <-> Q)
02:56:39 <Ghoul_> hmm
02:56:45 <ion> revtintin: p == q? P ~ Q? (P -> Q, Q -> P)?
02:57:28 <Ghoul_> I'm at that point where I've learnt about all of haskells syntax and extensions and things and I want to go type-crazy with some more esoteric stuff
02:57:34 <Ghoul_> reading list suggestions?
02:58:45 <revtintin> ion: that works beautifully, thanks!
02:58:53 <ion> revtintin: Which one? :-P
02:59:59 <revtintin> ion: (P -> Q, Q -> P)
03:00:42 <ion> revtintin: You can apply the usual logic equations here. (,) is conjunction, Either is disjunction.
03:01:12 <revtintin> ion: ok :)
03:03:04 <ion> And P ↔ Q = (P → Q) ∧ (Q → P)
03:03:40 <revtintin> noted
03:03:53 <donri> revtintin: may want to look at the lens library and its concept of an "Iso"
03:04:57 <revtintin> donri: i got what i needed - the lens library would be a little too much atm :D (me -> very new in haskell)
03:07:08 <donri> > under enum (+1) 'a'
03:07:10 <lambdabot>   'b'
03:09:00 <Taneb> > over enum toUpper 97
03:09:01 <lambdabot>   65
03:10:00 <Craigiedon> hi there, I am trying to use cabal to install the package "gtksourceview2" but when I run cabal install I get the following error: "setup: The pkg-config package gtksourceview-2.0 version >=2.0.2 is required but it could not be found. " Can anyone help me with this? I can't seem to find any information on it from googling the error message
03:10:12 <shiona> what/where are these over and under
03:10:33 <dcoutts_> Craigiedon: as the error message says, it's looking for a pkg-config package
03:10:46 <donri> Craigiedon: what OS?
03:10:46 <dcoutts_> Craigiedon: ie a C library registered with pkg-config
03:11:21 <Craigiedon> donri: I am on a scientific linux distribution at my university
03:11:22 <dcoutts_> Craigiedon: so probably you just don't have the dev files for the gtksourceview C lib installed, e.g. some -dev .deb/.rpm system package
03:11:22 <donri> shiona: lens / Control.Lens
03:11:29 <shiona> donri: thanks
03:12:02 <dcoutts_> Craigiedon: you'll know it's ready to go when pkg-config --list-all shows it as being registered
03:12:11 <donri> Craigiedon: that's redhat based then? try yum install pkgconfig(gtksourceview-2.0)
03:12:20 <dcoutts_> Craigiedon: so it's a matter of finding the right system package to install that provides it
03:12:48 <dcoutts_> donri: what syntax is that?
03:13:06 <donri> dcoutts_: yum requirements syntax
03:13:23 <donri> works in fedora at least
03:13:27 <dcoutts_> donri: I see, so they support pkgconfig deps directly. interesting
03:13:34 <donri> yep, it's awesome
03:13:38 <dcoutts_> yes, nice
03:14:02 <Craigiedon> dcoutts:  The yum and apt-get commands are available, but students are not permitted to be root, is there an alternative way I can install? Perhaps from source? or is it messy?
03:14:07 <donri> files too e.g. yum install /usr/bin/cabal :)
03:15:32 <dcoutts_> Craigiedon: yes, also possible to install the C lib into an alternate location. Then you have to set some pkg-config env var to tell it to look there. See man pkg-config for what that is.
03:15:58 <dcoutts_> Craigiedon: again, once pkg-config says it's listed/registered, then you're good to go with cabal install.
03:20:14 * hackagebot hen 0.1.1 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.1.1 (FedorGogolev)
03:20:16 * hackagebot keter 1.0.1.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.0.1.1 (MichaelSnoyman)
03:50:14 * hackagebot doctest 0.9.8 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.8 (SimonHengel)
03:55:18 <chrisdone> levi: got a link to that luajit post?
04:02:30 <chrisdone> PatrickRobotham: IS THIS PATRICK? {(O _O)
04:06:23 <donri> solirc: say is there any obvious way i'm missing to run doctest on a file with foreign imports?
04:07:02 <donri> solirc: (for a bunch of bundled c-sources, so it's not a simple matter of passing -lbla)
04:08:43 <donri> hm i don't suppose there's any way to run doctest via cabal repl...?
04:13:45 <PatrickRobotham> Hi chrisdone
04:14:00 <PatrickRobotham> Um, which Patrick did you have in mind?
04:48:58 <hpaste> palmje pasted “mysql cabal install failure” at http://lpaste.net/93042
04:50:00 <palmje> does anyone know how I could resolve the compilation error on installing the mysql library via cabal?
04:50:16 * hackagebot bindings-sophia 0.1.0 - Low-level bindings to sophia library  http://hackage.haskell.org/package/bindings-sophia-0.1.0 (EyalLotem)
04:50:18 * hackagebot sophia 0.1 - Bindings to Sophia library  http://hackage.haskell.org/package/sophia-0.1 (EyalLotem)
05:18:07 <danilo2> Hi! Is it possible in haskell to show untyped functions? I mean - I want to write "print f" and get "(a->a)"? It is easy doable on typed functions: http://lpaste.net/93043 , but can be also on untyped?
05:20:27 <Saizan> danilo2: what do you mean by untyped?
05:20:48 <danilo2> Saizan: Comment line 9 in my example code
05:20:55 <khyperia> I think generic, or whatever the term is in haskell - something about paremetric polymorphism
05:21:14 <khyperia> oh
05:21:15 <danilo2> Saizan: after you comment it, we cannot print "f"
05:21:21 <khyperia> ignore me
05:21:40 <Saizan> danilo2: well, without the type signatue f will still be typed, but with a polymorphic type
05:22:30 <danilo2> Saizan: of course :) Sorry - my question was not clear - so I want to print polymorphic functions - (like in example without line 9) is it possible?
05:22:57 <Saizan> danilo2: you could use polytypeable from hackage, but i'm not sure if it's a good idea :)
05:23:08 <Saizan> danilo2: why do you need this? debug?
05:24:08 <donri> if you enable ExtendedDefaultRules you might get (() -> ()) :P
05:25:57 <av> hello fellows, I'm trying to install cairo with cabal and keep getting errors of the kind described here: http://sourceforge.net/mailarchive/message.php?msg_id=31381352
05:26:04 <av> is there any easy solution to this problem?
05:26:51 <dcoutts> av: you can fix the Setup.hs to resolve the import ambiguity
05:27:12 <av> dcoutts: where can I find that? sorry, not too familiar with cabal
05:27:22 <dcoutts> av: it's in the package you're installing
05:27:24 <Saizan> or specify an earlier --cabal-lib-version, maybe
05:27:31 <dcoutts> or that
05:27:41 <dcoutts> that may work, and would be easier
05:27:53 <dcoutts> if you have an earlier Cabal lib version available
05:28:10 <dcoutts> otherwise, change the import of Distribution.Simple.Utils to use hiding (moreRecentFile)
05:28:44 <Saizan> av: "ghc-pkg list Cabal" will tell you which Cabal versions you have, you can then call cabal install with --cabal-lib-version=... using a version earlier than 1.18
05:29:01 <Saizan> av: if you have one
05:29:33 <av> Saizan, dcoutts: thanks, now trying with 1.14.0, which I have, so far it seems to work
06:08:17 <palmje> does anyone know how I could resolve the compilation error on installing the mysql library via cabal? http://lpaste.net/93042
06:09:32 <applicative> hm, did you recently install the new cabal-install?
06:09:44 <palmje> yes
06:10:45 <applicative> it looks like the Setup.hs is presupposing the older version of Cabal
06:11:19 <applicative> what did duncan c. say before; some sensible flag in the end.
06:11:32 <applicative> its not *exactly* the same ...
06:12:56 <applicative> palmje: maybe this sentence will help:
06:12:58 <applicative> av: "ghc-pkg list Cabal" will tell you which Cabal versions you have, you can then call cabal install with --cabal-lib-version=... using a version earlier than 1.18
06:13:05 <applicative> quoting Saizan
06:14:38 <palmje> yeah, using an older version of cabal fixes that issue
06:14:38 <palmje> thanks
06:23:03 <danilo2> Saizan: I'm sorry I'lost internet connection - I need this to my embeded language based on haskell
06:23:40 <danilo2> Saizan: we can thread it something like debug
06:47:10 <mr-> Is there a Data.Set that does not need its elements to be Ord(erable)?
06:48:36 <donri> there's HashSet which requires Hashable instead
06:49:35 <mr-> but there's nothing that simply requires Eq?
06:49:51 <donri> mr-: there's Data.List.nub :p
06:49:52 <chrisdone> i think that might preclude an efficient implementation
06:49:56 <donri> insanely inefficient though
06:50:07 <chrisdone> (just a guess, i don't know)
06:50:45 <chrisdone> presumably Hashable has an ord instance
06:50:49 <mr-> I agree about it not beeing efficient, but sometimes convenience is all that's needed :-)
06:51:04 <donri> chrisdone: hashable is a class
06:51:07 <ocharles> I admit I'm always surprised there is no Eq-only Set
06:51:09 <chrisdone> ah, it's equivalent to an Ord
06:51:13 <chrisdone> hash :: a -> Int
06:51:38 <chrisdone> ocharles: answer me on twitter you horrible man!
06:51:46 <ocharles> you tweeted me?
06:51:51 <chrisdone> yeah. i think
06:51:56 <chrisdone> @acid2, right?
06:51:56 <lambdabot> Unknown command, try @list
06:52:00 <ocharles> yessir
06:52:24 <chrisdone> i asked do you have a haskell api for musicbrainz that lets you get cover art?
06:52:28 <ocharles> chrisdone: pftt, 50 minutes ago!
06:52:36 <ocharles> do you think I live on twitter? :P
06:52:46 <chrisdone> omg, that's, so, like, 50 minutes ago
06:52:54 <ocharles> chrisdone: we don't yet, but it would be great to have one
06:52:54 <chrisdone> you live on irc =p
06:53:00 <ocharles> i do live on irc, this is true :P
06:53:12 <chrisdone> i saw a few musicbrainz packages on hackages but they're all a bit flimsy
06:53:12 <ocharles> chrisdone: are you aware of the http://coverartarchive.org ?
06:53:48 <chrisdone> hmm, interesting
06:53:59 <ocharles> making a Haskell API for that should be really simple. A single JSON schema, and that's about it
06:54:10 <chrisdone> so it should be two calls
06:54:13 <ocharles> and the CAA is the preferred way to deal with album artwork in musicbrainz now
06:54:28 <chrisdone> 1. search the artist's identifier, 2. get the artist's art
06:54:38 <ocharles> if you need to search, yea.
06:54:56 <ocharles> you might already have that in mp3s or whatever, but I don't know what data you have to work with
06:55:03 <chrisdone> http://chrisdone.com/music ← i want to add pics to this, like pics of the artists perhaps
06:55:07 <ocharles> and you mean s/artist/release/
06:55:13 <ocharles> ah, we don't have artist pictures yet
06:55:13 <chrisdone> i just have the artist name and track
06:55:20 <ocharles> we only have packaging pictures
06:55:32 <chrisdone> gotcha
06:55:33 <ocharles> we will be doing an artist image archive at some point too
06:55:53 <ocharles> you could search for all releases that that artist/track pair appear on, and try and find artwork for that
06:56:00 <chrisdone> yeah
06:57:01 <ocharles> also, I'm sure I have a remix of Flux, but I can't remember who it was by
06:57:04 <chrisdone> do you use haskell at musicbrainz?
06:57:18 <ocharles> is where is home on flux? maybe it's the burial remix of that
06:57:18 <chrisdone> you mean JFK remix?
06:57:32 <chrisdone> hum
06:57:37 <chrisdone> where is home is on a weekend in the city
06:57:40 <chrisdone> iirc
06:57:47 <ocharles> odd, wonder why that rings a bell
06:57:51 <ocharles> anyway, we don't use much Haskell sadly
06:58:10 <ocharles> I want to write more and more Haskell, but the rest of the team don't know it as well (well, one other person)
06:58:10 <chrisdone> s/sadly/yet amirite
06:58:17 <ocharles> so it's questionable whether it's really a good idea
06:58:24 <chrisdone> nod
06:58:38 <ocharles> plus, with s
06:58:39 <ocharles> eep
06:58:51 <ocharles> plus, with such a small team and a reliance on volunteers, we don't want to make it harder to contribute
06:59:05 <ocharles> though imo, Haskell is a *better* choice than Python for small teams
06:59:31 <chrisdone> and for large teams?
07:00:00 <ocharles> also the right choice!
07:00:02 <ocharles> :D
07:00:06 <Taneb> ocharles, I think for small teams, the best language is the one most of them know
07:00:08 <chrisdone> just hard to find people for =p
07:00:18 <ocharles> Taneb: in the short term yes, in the long term, no
07:00:24 <Taneb> True
07:00:32 <ocharles> I want languages that guarantee what I built 5 months ago still makes sense, when I start making other changes
07:00:46 <ocharles> but to get off the ground and start iterating, I guess it's best to run with what you know
07:01:05 <ocharles> you'll rarely get the design right first time anyway, so I don't worry too much about doing a rewrite
07:02:05 <chrisdone> manager: we can't hire haskellers, there aren't enough of them
07:02:05 <chrisdone> haskeller: yea but the available ones will fly out of their country to work on haskell
07:02:05 <chrisdone> manager: cool! let's send out a job ad
07:02:05 <chrisdone> manager: turns out haskellers also have standards and self-esteem, they won't work on boring stuff =(
07:03:08 <ocharles> I do have one Haskell job offer that I'm considering... which is pretty awesome
07:03:10 <Maior> what's boring for one is awesome for another
07:03:31 <ocharles> the work isn't necessarily that interesting, but the solution is quite nice and the team sound like they'll be fun to work with
07:03:33 <chrisdone> ocharles: ah, there are loads of Flux remixes o_o
07:03:38 <ocharles> chrisdone: yea :P
07:04:17 <ocharles> "Page 2 of 8,398"
07:04:27 <chrisdone> lol
07:04:42 <chrisdone> Maior: yeah i consider boring to be a function of management
07:05:05 <chrisdone> the less creative freedom/personal investement/pride you can have on a problem the more boring it is
07:05:12 <quchen> chrisdone: A vicious circle :-/
07:05:55 <chrisdone> quchen: i did the boring haskell job so i could get the good job, just like i did the boring jobs to get the haskell job =]
07:06:19 <quchen> chrisdone: And your good job is not boring?
07:06:30 <quchen> And involves Haskell? :-)
07:06:49 <chrisdone> yep =)
07:07:19 <chrisdone> quchen: i work on the fp complete ide
07:07:20 <quchen> Presumably you're working for GaloisWelltypedFPComplete?
07:07:22 <quchen> Ah.
07:07:52 <quchen> That's all in the US though, right?
07:08:00 <chrisdone> nah, everyone works remote
07:08:13 <chrisdone> i'm in italy, snoyberg's in israel
07:08:21 <ParahSail1n> eureka genomics is hiring haskellers
07:08:28 <chrisdone> cool!
07:09:02 <quchen> chrisdone: Which also means that there are no colleagues. Why can't a Haskell company start in my town! With people! And Haskell.
07:09:21 <DMcGill> edwardk: there's a minor typo your cellular-automata 3 post - you generalise the type of rule into "(Enum m, Bounded m, Num n, Bits n) => Rule m n", that should be something like "(Enum m, Bounded m, Bits n) => n -> Rule m Bool" instead and it's already fixed in the summary at the bottom of the page
07:09:34 <chrisdone> quchen: i guess nothing left but to make one!
07:10:19 <quchen> chrisdone: Me as a salesperson, I can see how that ends
07:11:19 <DMcGill> also your use of "... .~ (f <$> [minBound .. maxBound])" was funny, there are still times when plain old 'map' comes in handy, even if it's just to save characters!
07:17:25 <Itkovian> quchen at least you will do better than companies selling air.
07:17:47 <mr-> Ha! Chased all the way down to Cabal to make OpenGoal Ord :-)
07:19:22 <quchen> Itkovian: Not sure. You've got to be damn good to sell air.
07:19:50 <quchen> If I was this good my entire department would run Haskell now ;-)
07:20:00 <Itkovian> But your air would be typechecked
07:20:35 <Itkovian> Ah well, I'm doing Python now too and I wish I wasn't a lot of times.
07:20:42 <quchen> Couldn't match expected type `Air' with actual type `Fart'
07:20:49 <Itkovian> If only for the static compilation/typechecking
07:20:51 <quchen> I can see how a typechecker might come in handy
07:20:57 <Itkovian> :)
07:27:11 <chrisdone> heh, two names for the price of one x@y
07:28:22 <DMcGill> eww
07:28:30 <danr> nice!
07:28:32 <DMcGill> my namespace!
07:28:54 <mauke> > let a@b@c = 1 in a+b+c
07:28:55 <lambdabot>   3
07:28:56 <DMcGill> that should be a compile error *crosses arms*
07:29:21 <danr> mauke: lovely
07:32:00 <chrisdone> ocharles: oh, it does exist
07:32:08 <chrisdone> ocharles: http://grooveshark.com/s/Where+Is+Home+Burial+Remix/2FoKDA?src=5
07:32:14 <applicative> is mingw32_HOST_OS something that would be true whenever compiling on Windows?
07:32:55 <chrisdone> considering mingw is a posixy layer for windows, might not be
07:33:08 <chrisdone> you don't need mingw to build on windows right?
07:33:27 <applicative> thats what was worrying me, but I'm looking at the source for getDirectoryContents
07:33:34 <DMcGill> there are both C and Haskell compilers for windows that don't need mingw
07:34:13 <applicative> oh wait, i get it
07:34:16 <DMcGill> applicative: #else
07:34:24 <ghorn> anybody know where I can find a mirror of http://projects.haskell.org/HaXml/XsdToHaskell.html ?
07:34:33 <ghorn> or know how to use XsdToHaskell ?
07:35:45 <applicative> DMcGill: the line list structured like this:  #ifndef mingw32_HOST_OS Posix.blah >> Posix.blip #else  Win32.dskkshjaga >> Win32.irirueiwwqq
07:35:58 <applicative> the line 'is' structured like that
07:39:14 <applicative> man this is confusing
07:40:24 <b__> I don't really understand ((->) r) instances. (->) is a type constructor like Just?
07:40:30 <applicative> it is becoming clearer and clearer to me that not having a correct ListT in base, indeed in Prelude, is a tragedy
07:40:44 <applicative> b__:  yes, it's like Either
07:40:48 <Saizan> b__: Just is a data constructor, not a type constructor
07:41:03 <Saizan> b__: the type constructor would be Maybe
07:41:04 <applicative> hah, yes I read Just as Maybe
07:41:05 <b__> ah sorry, yeah
07:41:31 <applicative> the better comparison is with Either or (,) (as used at the type level)
07:41:48 <applicative> @kind (->)
07:41:49 <lambdabot> * -> * -> *
07:41:53 <applicative> @kind Either
07:41:54 <lambdabot> * -> * -> *
07:41:59 <applicative> @kind (,)
07:42:00 <lambdabot> * -> * -> *
07:42:06 <DMcGill> @kind Maybe
07:42:07 <lambdabot> * -> *
07:42:20 <Saizan> @kind ((->) r)
07:42:21 <lambdabot> Not in scope: type variable `r'
07:42:35 <applicative> @kind ((->) Char)
07:42:36 <Saizan> @kind ((->) Int)
07:42:36 <lambdabot> * -> *
07:42:37 <lambdabot> * -> *
07:43:03 <b__> What is (->) called?
07:43:09 <applicative> b__: I hope we're not making things worse...
07:43:16 <b__> applicative: no
07:43:17 <applicative> 'function from ..'?
07:43:18 <DMcGill> I've heard "to"
07:43:32 <applicative> 'function from ... to ..'?
07:43:50 <DMcGill> or I suppose ((->) r) would be "to", and (->) would be "from"
07:43:55 <b__> Is there another useful Category instance besides (->)?
07:43:58 <applicative> b__: make a type synonym type To a b = a -> b
07:44:13 <DMcGill> @info Category
07:44:13 <lambdabot> Category
07:44:15 <applicative> used as ord :: Char `To` Int
07:44:38 <DMcGill> b__: the other default Category is Kleisli
07:44:51 <DMcGill> which is to (a -> m b) as (->) is to (a -> b)
07:45:04 <b__> I'd always assumed that (->) was some sort of built-in
07:45:46 <b__> as opposed to being a type contructor
07:46:02 <DMcGill> there are lots of other Categories though - Wires for one
07:46:18 <ocharles> chrisdone: I know that there is a Burial remix of Where Is Home, but for some reason "Flux" rings a bell
07:46:25 <ocharles> I think there was a Flux single that included that remix
07:46:26 <DMcGill> I wouldn't be surprised if a few Lens types are Categories
07:46:39 <ocharles> Lens was originally a category
07:46:44 <ocharles> will, it is a category now - it's just Hask
07:46:49 <applicative> oh yeah the old lens packages were the best use of Category
07:47:12 <b__> ocharles: that's one sick track :}
07:47:20 <ocharles> b__: +1!
07:47:50 <b__> So now next step is reading about this | ~ Type-level magic
07:48:34 <b__> I am rewriting prelude, and the most fun part is figuring out why typeclasses are the way they are in current prelude
07:48:58 <DMcGill> b__: historical and political reasons
07:49:57 <DMcGill> half the time considering newcomers only (Int instead of Integral a, String = [Char]) and half the time not
07:50:02 <b__> I figured, which is why it's fun to experiment with it
07:50:14 <DMcGill> Monoid, Monad etc
07:50:28 * hackagebot bson 0.2.3 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.3 (FedorGogolev)
07:52:02 <b__> I was wondering if Functor can be defined with Category as superclass
07:53:33 <b__> Or perhaps I am not making any sense at all :D
07:54:27 <DMcGill> but not all Functors are Categories, unless I'm missing something
07:54:50 <DMcGill> (Hask aside)
07:55:12 <donri> fmap :: Category c => c (c a b) (c (f a) (f b))  eeehhh
07:55:53 <DMcGill> Ah yes, we could generalise all uses of (->) to Arrow (~>)
07:55:59 <donri> ;)
07:57:20 <DMcGill> What extensions are needed for that to be valid syntax btw?
07:57:23 <ion> donri: fmap :: (Functor f, Category c, Category d) => c (d a b) (d (f a) (f b)) :-P
07:58:16 <DMcGill> speak of the devil: http://conal.net/blog/posts/overloading-lambda
08:10:16 <augur> are there any good obj-c interfaces for haskell?
08:11:02 <augur> well, basically so that i can go back and forth between certain ObjC classes and haskell types? or at least between C types and haskell types?
08:11:34 <enthropy> well which part calls which part?
08:12:03 <augur> ObjC will use the haskell as a plugin, sending data in and expecting data out
08:12:31 <augur> to some extent i imagine i could just use a textual interchange formal but thats kind of a bit of overhead i'd prefer to avoid if possible
08:12:50 <augur> s/formal/format/
08:13:04 <augur> maybe thats the least of my concerns
08:13:22 <edwardk> augur: look up 'hoc'
08:13:37 <augur> edwardk: haskell hoc?
08:13:40 <edwardk> yeah
08:13:44 <augur> ok
08:13:45 <red___> is there a way to do the following without using (x:xs) pattern matching?  ie without specifying an argument to toNums?
08:13:48 <red___> toNums (x:xs) = (map read . words $ x :: [Int]) : toNums xs
08:14:01 <red___> [String] -> [[Int]]
08:14:06 <enthropy> it's more common to call C functions from haskell than the other way around
08:14:32 <cschneid> when I tried, it was really hard to call from Ruby => Haskell. (several years ago, didn't end up making it work)
08:14:39 <mauke> :t map (\x -> map read (words x) :: [Int])
08:14:40 <lambdabot> [String] -> [[Int]]
08:14:55 <enthropy> red___: you already know map apparently
08:14:55 <enthropy> @src map
08:14:55 <lambdabot> map _ []     = []
08:14:55 <lambdabot> map f (x:xs) = f x : map f xs
08:14:56 <augur> enthropy: indeed. but ObjC is nice for mac GUI stuff, and haskell is nice for ADT manipulation :)
08:15:05 <mauke> :t map (map read . words :: ReadS [Int])
08:15:06 <lambdabot> [String] -> [[([Int], String)]]
08:15:10 <mauke> hmm, no
08:15:18 <mauke> :t map (map read . words)
08:15:20 <lambdabot> Read b => [String] -> [[b]]
08:15:38 <mauke> :t fmap (fmap (fmap read) words)
08:15:39 <lambdabot> (Functor f, Read b) => f String -> f [b]
08:16:08 <quchen> Good advice Mauke.
08:16:42 <enthropy> augur: does that mean it only works on mac then?
08:18:18 <augur> enthropy: the thing im making will only work on mac right now, yes. maybe there will be non-mac versions in the future, we'll see
08:18:18 <red___> mauke: thanks .. i still don't really get ReadS .. i knew it was the same structure as mapping .. i just couldn't figure it out
08:18:37 <mauke> red___: ignore ReadS
08:18:42 <mauke> that was wrong anyway
08:18:52 <ocharles> Any tips on how to model http://wiki.libsdl.org/SDL_Keymod in Haskell? SDL_Keymod is usually used a bitmask. I could either have all of those fields as Bool's on my record, or I could have a Set of modifiers
08:18:56 <ocharles> Not sure which to go with...
08:19:15 <enthropy> or you could use a bitmask
08:19:38 * enthropy would go with the Set
08:19:45 <ocharles> enthropy: I could use a bitmask too, but that doesn't feel like very idiomatic Haskell
08:19:50 <DMcGill> yeah, just bitmasking in Haskell and having a bunch of isLShift functions
08:20:01 <DMcGill> which would be your field accessors anyway
08:20:19 <augur> hmm
08:20:24 <ocharles> I could store a bitmask and provides views onto a Set, for use with view patterns...
08:20:29 * hackagebot hflags 0.3 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.3 (GergelyRisko)
08:20:30 <augur> i should have native support for language-defined syntax highlighting shouldnt i
08:21:00 <enthropy> @hackage highlighting-kate
08:21:00 <lambdabot> http://hackage.haskell.org/package/highlighting-kate
08:21:43 <DMcGill> how would the set be used though? "x `S.elem` flags" vs "isX flags"
08:21:50 <augur> which probably means some kind of markup on sourcecode, rather than like ... range-based markup info
08:22:04 <ocharles> DMcGill: you can also test for intersection
08:22:09 <DMcGill> ah, I like it
08:22:15 <ocharles> which is a bit more fiddly if you just provide a -> Bool
08:22:27 <augur> preflex: seen peaker
08:22:27 <preflex>  peaker was last seen on #haskell 13 hours, 32 minutes and 45 seconds ago, saying: Finished wrapping sophia, tomorrow will debug it...
08:22:35 <augur> :(
08:22:58 <augur> @tell peaker does lamdu support things like user-editable layout stuff?
08:22:58 <lambdabot> Consider it noted.
08:25:25 <DMcGill> wait ocharles: `any' and `all' give you unions and intersections on (a -> Bool)
08:25:43 <red___> what is the best channel on this server for general algorithmic discussion?
08:25:52 <red___> (ie i don't know how to constrain /list)
08:26:35 <augur> red___: #algorithms?
08:26:51 <augur> it might be ##, who knows
08:27:50 <DMcGill> this Monoid Pearl is really good - combining newtypes and deriving Monoids like this is certainly something I'd like to try
08:28:42 <DMcGill> "newtype Diagram = Diagram (Dual [Prim]) deriving Monoid"
08:29:15 <DMcGill> rather than having to define your own instance and reverse the arguments to (<>) yourself
08:30:45 <DMcGill> I wish I'd known about Down (which reverses an Ord instance) a week ago
08:33:12 <augur> edwardk: it seems like hoc is for calling objc from haskell, but i really need the other direction
08:34:08 <sellout-> augur: Perhaps using GHC to compile to C can help you there?
08:43:17 <kuribas> I have an idea, maybe it's crazy...  What if you could specify places for ghc to "supercompile", if you find it seems reasonable that it could find an efficient replacement there.
08:43:37 <enthropy> @where hallinone
08:43:38 <lambdabot> I know nothing about hallinone.
08:43:41 <kuribas> Then the compiler wouldn't waste time on trying to supercompile the whole program.
08:45:24 <sellout-> kuribas: You mean like the optimize declaration in Common Lisp? http://www.lispworks.com/documentation/HyperSpec/Body/d_optimi.htm
08:45:41 <enthropy> http://osdir.com/ml/lang.haskell.general/2003-07/msg00149.html <-- is HAllInOne
08:46:41 <kuribas> sellout-: Something like that.
08:47:19 <enthropy> sellout-: I don't get it
08:47:51 <enthropy> that seems to like just having a local -O0 -O1 -O2
08:48:00 <dmj`> does the UnicodeSyntax pragma support ⊥ ? Trying it, but ghci doesn't like it
08:48:07 <enthropy> for each top-level declaration instead of for a single file
08:48:07 <sellout-> enthropy: You tell the compiler how important various qualities are (speed, debugability, etc. at whatever scope you want).
08:48:23 <sellout-> enthropy: Well, you can declare it for the whole file as well if you want.
08:48:32 <elliott> dmj`: it's an operator character (and UnicodeSyntax isn't required to use Unicode identifiers, just actual syntax replacements)
08:49:58 <augur> hmm. edwardk, i think it'll ultimately be better to use hoc anyway, so thank you. :)
08:50:11 <edwardk> augur: my recollection was you can set up hoc to register with events and what not using haskell-based listeners
08:55:54 <dmj`> elliott: h,f ∷ Int → Int; h = (+1) . (+3); f = undefined
08:55:58 <dmj`> when replaced with
08:56:02 <dmj`> h,f ∷ Int → Int; h = (+1) ∘ (+3); f = ⊥
08:56:23 <dmj`> doesn't compile even with unicode syntax pragma
08:56:40 <enthropy> you wuld need to define those things
08:56:52 <enthropy> (∘) = (Prelude..)
08:56:54 <dmj`> I see how top level declarations don't need the pragma
08:57:05 <boothead> I just "upgraded" to Cabal 0.18... does anyone know how to make this work with emacs? I can no longer find any modules
08:57:11 <dmj`> enthropy: ohhhh thank you
08:57:18 <elliott> dmj`: Haskell supports Unicode regardless of any pragma
08:57:25 <elliott> dmj`: all the extension does is let you use fancy symbols for :: and stuff.
08:57:34 <elliott> dmj`: note that ⊥ is an operator symbol
08:57:34 <enthropy> dmj`: there are also editor modes that show you ∘ when you have .
08:57:38 <elliott> i.e., you will have to enclose it in parens.
08:57:53 <elliott> dmj`: there is also http://hackage.haskell.org/package/base-unicode-symbols. btw I strongly disrecommend the use of these things :p
08:57:54 <enthropy> that way your code looks normal to other people
08:59:09 <augur> edwardk: i feel like this is going to be yet another pain in the ass thing to learn
08:59:17 <edwardk> it is
08:59:33 <augur> ok, well ill just write it all in obj-c then, and to hell with hoc :)
09:00:37 <dmj`> elliott: so cool tho... sigh
09:01:13 <edwardk> i started an objective-c package at one point, but i burned out and moved on to other things. too many ABI issues
09:02:08 <edwardk> https://github.com/ekmett/objective-c/blob/master/objective-c.cabal and https://github.com/ekmett/foreign
09:04:59 <kakos> Probably a dumb question, but in SublimeHaskell, I see a repl.sublime-menu file, but I don't see where or how to start the REPL in SublimeText. So, how do I do it?
09:05:39 <augur> edwardk: :)
09:06:10 <augur> surely you should have some fancy solution to the ObjC problem, involving kan so and so's, and comonadic whatsits and ...
09:07:59 <solirc> donri: If you somehow manage to get it working in GHCi, then it works in doctest, too.
09:08:26 <donri> solirc: well it works in cabal repl :)
09:08:33 <solirc> donri: Doctest accepts the exact same parameters as GHC/GHCi
09:09:03 <solirc> donri: Have you tried with the latest version of doctest?
09:09:14 <solirc> donri: Kazu added support for cabal repl.
09:09:20 <donri> oh interesting
09:09:24 <solirc> donri: I'm on may way to the airport
09:09:30 <donri> okies!
09:09:31 <solirc> donri: so don't have much time
09:10:09 <solirc> donri: Anyway, if it works with Cabal repl, it should somehow work with Doctest, too.  Maybe you have to pass some additional args, but it should work..
09:13:20 <applicative> kakos: ye olde Textmate open in ghci is Command-R
09:15:30 <red___> how to sort a list of lists [[x,y,z]] based on some compare of z?
09:15:46 <mauke> what's z?
09:15:47 <applicative> red___: they all have three elements?
09:15:53 <red___> yup
09:15:55 <red___> guaranteeeed
09:16:01 <mauke> why not a tuple then?
09:16:06 <applicative> make them a tuple, put them in reverse order though
09:16:13 <applicative> then sort will work anyway
09:16:28 <red___> this makes me sad
09:16:32 <mauke> sortBy (comparing (!! 2))
09:16:46 <applicative> what's sad?
09:16:47 <red___> mauke: !
09:16:54 <DMcGill> If you have invariants, it's better to force them to be true
09:16:57 <red___> applicative: reversing a tuple to use sort
09:17:07 <applicative> red___: oh you can use sortBy
09:17:16 <red___> :t comparing
09:17:17 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:17:18 <red___> :t compare
09:17:19 <lambdabot> Ord a => a -> a -> Ordering
09:17:20 <applicative> that it should be a tuple is clear for the reason DMcGill mentioned
09:17:33 <RichyB> To be specific, with tuples, it's: sortBy (comparing (\(x, y, z) -> z))
09:17:44 <red___> applicative: ,DMcGill  yeah that was over my head
09:17:57 <RichyB> > sortBy (comparing (\(x, y, z) -> z)) [(1,1,2), (2,2,1)]
09:17:58 <lambdabot>   [(2,2,1),(1,1,2)]
09:18:32 <mauke> > sortBy (comparing thrd) [(1,1,2), (2,2,1)]
09:18:34 <geekosaur> if something is going to always have 3 elements, it is best to represent that in the type so that you get a compile time error if you somehow get something with not 3 elements
09:18:38 <lambdabot>   [(2,2,1),(1,1,2)]
09:18:45 <red___> sortBy (comparing (\[x,y,z] -> z)) [[1,2,3],[3,4,5]]
09:18:48 <red___> > sortBy (comparing (\[x,y,z] -> z)) [[1,2,3],[3,4,5]]
09:18:50 <lambdabot>   [[1,2,3],[3,4,5]]
09:19:03 <RichyB> That pattern match works, until...
09:19:08 <geekosaur> you "can" do it with lists but your checking is at run time (the program will abort)
09:19:14 <RichyB> > sortBy (comparing (\[x,y,z] -> z)) [[1,2,3],[3,4,5],[6,7]]
09:19:16 <lambdabot>   *Exception: <interactive>:3:20-32: Non-exhaustive patterns in lambda
09:19:20 <RichyB> Oh no! An exception!
09:19:20 <applicative> red___: !!
09:19:24 <red___> aaaaaaaah
09:19:30 <RichyB> If I had used tuples, it would have been a compile error, like so:
09:19:39 <red___> trial by explosion
09:19:46 <RichyB> > sortBy (comparing (\(x,y,z) -> z)) [(1,2,3),(3,4,5),(6,7)]
09:19:48 <lambdabot>   Couldn't match expected type `(t0, t1, a0)'
09:19:48 <lambdabot>              with actual type `...
09:20:04 <RichyB> See, that time the *compiler* told me, so I didn't even have to run the program to find my mistake.
09:20:16 <applicative> Thank you, Madame le Type System
09:20:21 <red___> point well-received.  thanks, channel
09:20:30 <DMcGill> this is basically a microcosm of Haskell
09:20:42 <DMcGill> the entire point of strong, static typing
09:20:53 <red___> toNums = map (\x -> map read (words x) :: [Int])
09:21:06 <red___> so i have that function which reads lists of ["num1 num2 num3"]
09:21:12 <red___> i want to build a tuple instead...
09:21:31 <DMcGill> now that inherently has to be unsafe
09:21:33 <pqmodn> > read "(1,2,3)" :: (Int, Int, Int)
09:21:35 <lambdabot>   (1,2,3)
09:21:52 <applicative> that looked safe!
09:22:29 <jfischoff> what is the fastest why to fully evaluate a lazy bytestring?
09:22:32 <DMcGill> parsing can fail at runtime (see ReadS) but this isn't equivalent - the data is in a different format
09:22:36 <jfischoff> deepseq?
09:22:58 <red___> > (map (\x -> map read (words x) :: (Int,Int,Int)) ["1 2 3", "4 5 6"]
09:22:59 <lambdabot>   <hint>:1:68:
09:23:00 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
09:23:03 <donri> jfischoff: probably deepseq or toStrict?
09:23:04 <applicative> toStrict?
09:23:13 <jfischoff> I'll compare
09:23:29 <donri> probably toStrict is slower, but maybe you want a strict bytestring in the end
09:23:43 <jfischoff> it is just for benchmarking
09:23:56 <red___> > (map (\x -> map read (words x) :: [(Int,Int,Int)]) ["1 2 3", "4 5 6"]
09:23:57 <lambdabot>   <hint>:1:70:
09:23:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
09:24:06 <donri> jfischoff: in that case use criterion and 'nf' :)
09:24:07 <red___> ok i'll go experiment elsewhere
09:24:08 <DMcGill> red__: either store your data as "(x,y,z)" in text, or use "f [x,y,z] = (x,y,z); f _ = \"aah, not 3 elements!\""
09:24:24 <jfischoff> donri: I would assume that calls deepseq right?
09:24:36 <red___> DMcGill: thanks
09:24:55 <applicative> jfischoff: toStrict?
09:25:02 <donri> jfischoff: yes
09:25:12 <jfischoff> toStrict will be slower I bet
09:25:27 <DMcGill> red__: you have a choice between using Maybe or error to handle failure
09:25:55 <DMcGill> I'd recommend Maybe but if you're just hacking things together and your program will have to terminate on a parse failure anyway, error is fine.
09:26:29 <jfischoff> the NFData instance of ByteString is efficent
09:26:31 <applicative> donri: oh i missed the remark about 'nf'
09:26:43 <jfischoff> so I don't think I can do better than nf
09:26:51 <jfischoff> i.e. deepseq
09:27:12 <red___> :t comparing
09:27:13 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:27:20 <red___> where defined?
09:27:28 <DMcGill> @i comparing
09:27:29 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect v @ ? .
09:27:32 <DMcGill> @info comparing
09:27:33 <lambdabot> comparing
09:27:40 <DMcGill> @hoogle comparing
09:27:40 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
09:27:50 <red___> thnks
09:28:27 <DMcGill> the idea is that you're actually comparing things of type 'a'
09:30:15 <applicative> > comparing length "California" "Arizona"
09:30:16 <lambdabot>   GT
09:31:49 <applicative> > comparing last "California" "Arizona"
09:31:51 <lambdabot>   EQ
09:32:20 <red___> :info sortBy
09:32:28 <red___> @hoogle sortBy
09:32:29 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
09:32:29 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
09:32:29 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
09:40:08 <DMcGill> red___: @hoogle just uses http://www.haskell.org/hoogle/
09:42:26 <mauke> it's probably a local installation
10:10:38 * hackagebot http-conduit 1.9.5.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.5.1 (MichaelSnoyman)
10:10:41 <haasn> Yes it uses the ‘hoogle’ command locally
10:16:04 <Aka_> Hello!
10:16:34 <WraithM> > sortBy (comparing last) ["California", "Arizonia", "Alaska", "Kansasb"]
10:16:35 <lambdabot>   ["California","Arizonia","Alaska","Kansasb"]
10:16:38 <stelleg> anyone know if there is a fft implemented on MArray? my google/hoogle fu skills arent turning up anything
10:16:51 <WraithM> > sortBy (comparing last) ["California", "Arizonia", "Kansasb" ,"Alaska"]
10:16:52 <lambdabot>   ["California","Arizonia","Alaska","Kansasb"]
10:18:08 <Aka_> I would like to create a Mappable type class to abstract on types which allow their contents to be mapped over. Something like this:
10:18:08 <heath> https://gist.github.com/heath/b544eeea70fa94c6fef1/raw/1d8716fd15e94f79deb3734dd47f7a20d016b123/gistfile1.txt
10:18:11 <Aka_> class Mappable t where     map :: (a -> b) -> t a -> t b
10:18:52 <Aka_> I would like to use it for Lists and Data.Vector.Storable.Vector
10:19:01 <dwcook> Aka_, what's wrong with Functor?
10:19:03 <heath> isn't "automated code creation" what you get with generative programming in the template haskell lib?
10:19:25 <Aka_> ah, that would be my first question (whether there is something like this already)
10:19:32 <dwcook> There sure is
10:19:33 <dwcook> @type fmap
10:19:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:19:39 <Aka_> ok, thanks
10:19:56 <joelteon> huh. that's the first time i've seen somebody who wanted to write a typeclass, but didn't know what Functor is
10:19:59 <Aka_> I'm not yet familiar with the (admittedly huge) library
10:20:08 <Aka_> :)
10:20:19 <Aka_> there's a first time for everything
10:20:26 <joelteon> well now you know
10:20:30 <dwcook> \o/
10:20:40 <Aka_> thanks a lot guys!
10:21:00 <joelteon> functor is the best
10:21:08 <Aka_> I look forward to being able to help newbies myself :)
10:21:45 <brill> Having a bit of trouble reading types
10:22:13 <joelteon> Aka_: your first test
10:22:16 <brill> a -> a -> a is a function taking a returning a function taking a returning a.
10:22:53 <brill> sorry if that sounded convuluted.
10:22:55 <dwcook> brill, yep, that's right.
10:23:08 <hpaste> heath pasted “automated code creation within haskell” at http://lpaste.net/93051
10:23:10 <mauke> a -> (a -> a)
10:23:18 <dwcook> You can also think of it as a function taking "two" a's and giving you an a, if it helps. It's not *as* correct, but it's a fair enough intuition
10:23:32 <brill> Thank you so much. I'm getting there.
10:23:34 <mauke> :t uncurry
10:23:34 <brill> :-)
10:23:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
10:23:42 <dwcook> But to be completely correct, a function only ever has one input and one output
10:25:01 <Aka_> you guys are too quick :)
10:25:30 <dwcook> Oh sorry, did you want to handle that one, Aka_? :)
10:26:07 <Aka_> no worries,
10:26:42 <Aka_> joelteon told me to try it out, I had switched away for a little
10:27:33 <Aka_> I'l hang around, it seems there's a lot to learn
10:27:39 <dwcook> I actually misunderstood what they intended by saying that. Woops.
10:29:31 <mizu_no_oto> Is there any good way to get a sub-array from an IArray?
10:30:02 <mm_freak_> mizu_no_oto: not really
10:30:07 <mm_freak_> you should use vectors for more flexibility
10:35:44 <phulin> How can I derive a GHC.Generics Generic instance for Text?
10:35:56 <phulin> or is there one defined somewhere?
10:38:01 <donri> phulin: possibly you could use StandaloneDeriving, DeriveGeneric and import the constructors from an internal module
10:39:05 <phulin> donri, Data.Text.Array isn't exposed anywhere, and it's used inside Text
10:39:28 <jfischoff> what would you like to do with the Generic Text instance?
10:39:31 <donri> phulin: Data.Text.Array is exposed...
10:39:46 <phulin> rather, its constructors aren't exposed
10:39:50 <donri> ah
10:40:16 <phulin> jfischoff, I'm trying to use cereal's Serialize on a type that contains Text
10:41:13 <donri> phulin: should be easy to write that instance by hand
10:41:16 <jfischoff> I would assume that you would be fine have a binary instance for text
10:41:30 <phulin> donri, good point.
10:41:39 <phulin> oops.
10:41:52 <donri> phulin: e.g. just encode to say utf8 and use the bytestring instance
10:42:33 <donri> put = put . encodeUtf8; get = decodeUtf8 <$> get
10:42:35 <donri> something like that
10:44:31 <donri> phulin: and consider if safecopy makes sense for your application; it includes text instances
10:44:56 <phulin> okay, sounds good
10:45:00 <phulin> donri, thanks for the help
10:45:04 <donri> np
10:50:10 <latro`a> is there a shorthand for going cyclically through a finite enumeration?
10:50:48 <latro`a> basically mapping each one to its corresponding value m in {0,...,n-1} and then making it equivalent to +m (mod n)
10:51:06 <latro`a> I know a way to write it, but this seems common enough that I expect a clever idiomatic trick
10:51:09 <jrm2k6> Hi, https://gist.github.com/jrm2k6/6584074 I need to apply my function to all elements of the list using a map
10:51:18 <jrm2k6> but I have a seocnd parameter to give
10:51:22 <jrm2k6> How can i do
10:51:53 <latro`a> change the argument order
10:51:54 <Heffalump> latro1a: if you have a Bounded restriction then (concat $ repeat [minBound..maxBound]) will give you an infinite list of the enum repeating
10:51:54 <jrm2k6> Like I need to apply the findLongestWord method to all element of the list, but I need to give also "" as a second parameter, this second parameter contains the current longest word.
10:51:57 <latro`a> and then partially apply
10:52:02 <Heffalump> s/latro1a/latro`a/
10:52:09 <latro`a> or you can use a lambda
10:52:20 <latro`a> oh you need to *change* the current longest word
10:52:26 <jrm2k6> Yes
10:52:32 <donri> :t cycle (enumFrom minBound)
10:52:33 <jrm2k6> so this second parameter keeps track of it
10:52:33 <lambdabot> (Bounded a, Enum a) => [a]
10:52:34 <latro`a> that's more like a fold with a map
10:52:46 <jrm2k6> omg yes
10:52:51 <jrm2k6> just a simple fold will work
10:52:54 <jrm2k6> how stupid
10:53:00 <jrm2k6> just a sec.
10:53:04 <latro`a> to get the actual longest, yeah, that's a fold
10:53:15 <latro`a> if you needed a list of "partial longests" or something then you'd have a foldMap
10:53:50 <latro`a> anyway, if I have data Color = Red | Green | Blue and I want to have essentially Red ~ +0, Green ~ +1, Blue ~ +2, is there a shorthand?
10:53:56 <enthropy> is there a haskell type for an array-of-struct?
10:53:56 <jrm2k6> i see
10:53:58 <latro`a> I see how to get the cyclic enumeration itself
10:54:14 <latro`a> I'm essentially just writing a function rotate :: HexDirection -> HexDirection -> HexDirection
10:54:23 <donri> > under enum (+3) 'a'
10:54:24 <lambdabot>   'd'
10:54:26 <bennofs> latro`a: if you use data Color = Red | Green | Blue deriving Enum
10:54:33 <bennofs> you can use fromEnum / toEnum
10:54:36 <latro`a> :t under
10:54:36 <enthropy> as in I want to bind to something that is    struct { int a; int b } dim[32]
10:54:37 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
10:54:44 <latro`a> figures its lens
10:54:46 <latro`a> :p
10:54:48 <donri> :)
10:54:52 <latro`a> *it's
10:54:59 <enthropy> this is an unboxed Vector (Int,Int)?
10:55:03 <monochrom> enthropy: consider Data.Vector.Storable
10:55:17 <ion> latroa: And for the modulus, you can do something like succ (fromEnum maxBound).
10:55:34 <donri> :t under enum
10:55:35 <lambdabot> Enum b => (Int -> Int) -> b -> b
10:55:48 <bennofs> What are the possibilities for representing 2D arrays in haskell currently? (Repa seems a bit overkill for simpler applications)
10:56:24 <donri> > fromEnum . (+3) . toEnum $ 'a'
10:56:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:56:26 <lambdabot>              with actual type ...
10:56:34 <donri> > toEnum . (+3) . fromEnum $ 'a'
10:56:35 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
10:56:55 <bennofs> > toEnum . (+3) . fromEnum $ 'a' :: Char
10:56:57 <lambdabot>   'd'
10:57:08 <bennofs> @ty toEnum . (+3) . fromEnum $ 'a'
10:57:08 <lambdabot> Enum c => c
10:57:30 <monochrom> bennofs: Data.Array allows fairly arbitrary indexes, for example (Int,Int) for 2D array
10:57:53 <latro`a> I remember there's a way in Enum to get the position in the enumeration
10:57:57 <latro`a> but I forget what it is
10:58:04 <latro`a> :t fromEnum
10:58:05 <lambdabot> Enum a => a -> Int
10:58:08 <latro`a> derp
10:58:17 <donri> :)
10:58:28 <enthropy> > listArray ((),()) [()]
10:58:29 <lambdabot>   array ((),()) [((),())]
10:58:44 <enthropy> > listArray ((),()) [()] ! ()
10:58:45 <lambdabot>   ()
10:59:07 <ion> > asTypeOf =<< toEnum . (+3) . fromEnum $ 'a'
10:59:08 <lambdabot>   'd'
10:59:36 <jrm2k6> Whats wrong with this http://lpaste.net/93054
11:00:08 <enthropy> monochrom: yes good idea.
11:00:18 <monochrom> String -> [String] -> String
11:00:26 <ion> jrm2k6: “String [String]”
11:00:39 <jrm2k6> hm
11:00:42 <enthropy> there should be a way to have errors printed out as if LINE pragmas were not there
11:00:52 <enthropy> besides say using sed to drop those lines
11:01:07 <ion> jrm2k6: Also the type of the foldl line isn’t IO Something.
11:01:12 <monochrom> String [String] does *not* mean "I want two parameters, first String second [String]". does *not*.
11:01:23 <jrm2k6> oh ok
11:01:36 <jrm2k6> so yes i fix that by putting -> in between each of the parameters
11:02:05 <jrm2k6> So I shouldnt use foldl?
11:02:29 <ion> jrm2k6: Is your nick a reference to the magazine and/or to what the magazine name is a reference to? :-)
11:02:29 <monochrom> print (foldl findLongestWord "" ["I am stupid", "You are stupid"])
11:02:43 <jrm2k6> I didnt even know a magazine with my nick existed.
11:02:45 <jrm2k6> :)
11:03:10 <ion> http://www.2600.com/
11:03:22 <shachaf> I,I class Foo (c :: k -> Constraint); instance Foo Foo
11:03:33 <jrm2k6> ahah thanks for the info
11:03:46 <jrm2k6> but no, I just created my nick in 2006 voila.
11:04:07 <bennofs> monochrom: Isn't array superseeded by vector? It seems Array is just vector + the Ix class
11:04:10 <jrm2k6> monochrom: this still does not work.
11:05:17 <jrm2k6> actually my iterator needs to be a list
11:05:29 <jrm2k6> which will contain each longest word for each element of the list i am folding on
11:05:51 <monochrom> I do not know why that is important, bennofs. you asked for 2D, I gave 2D. it spares you from hand-calculating 2D indexes to 1D indexed. do you want to hand-calculate it? yes or no?
11:11:12 <jrm2k6> http://lpaste.net/93055 what should i use if i want to get each longest word for each list of words in my list (sounds stupid i know_
11:15:24 <bennofs> monochrom: Maybe it's not. I still like the API of vector more :)
11:15:54 <monochrom> then use vector, and hand-calculate your indexes. ask edwardk about Morton order.
11:17:08 <jrm2k6> anybody to help me I am kind of confused? Can I use a map on a fold?
11:17:22 <jrm2k6> I mean, I need to get the longest word for each list contained in another list
11:18:33 <tromp> where does the fold come in?
11:18:59 <tromp> to get longest word?
11:19:17 <jrm2k6> hm
11:19:23 <jrm2k6> I guess I am really wrong
11:19:30 <jrm2k6> :)
11:19:38 <tromp> you cld use  map (fold ... ) listoflists
11:19:53 <jrm2k6> lemme try
11:20:02 <tromp> but better give a name to that fold
11:20:44 <tromp> :t maximumBy
11:20:45 <lambdabot> (a -> a -> Ordering) -> [a] -> a
11:21:04 <tromp> that may be more suited than fold
11:21:08 <jrm2k6> oh
11:21:09 <ricree> anyone at all familiar with gtk2hs? I'm trying to figure out where Graphics.UI.Gtk.Types is defined, but I can't find the Types.chs file in the repository (https://github.com/vincenthz/gtk2hs ). Anyone know what it's generated from?
11:21:21 <dcoutts> ricree: it's generated
11:21:44 <tromp> :t on
11:21:45 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:21:55 <jrm2k6> how does this maximumBy work on string?Do I have to specify the ordering?
11:21:57 <tromp> :t compare `on` length
11:21:58 <dcoutts> ricree: https://github.com/vincenthz/gtk2hs/blob/master/gtk/hierarchy.list
11:21:58 <lambdabot> [a] -> [a] -> Ordering
11:22:12 <ricree> Thank you dcoutts
11:22:14 <monochrom> also "comparing length" IIRC
11:22:17 <monochrom> @type comparing
11:22:18 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:22:47 <monochrom> "comparing" simply combines "compare" and "on". so you are not missing much :)
11:22:48 <jrm2k6> wait i am a beginner so
11:22:48 <jrm2k6> lol
11:23:09 <monochrom> you can write your own fold.
11:23:34 <jrm2k6> hm
11:23:47 <monochrom> get this to work. foldl ? ?? ["I", "am", "monochrom", "!"] = "monochrom"
11:24:00 <jrm2k6> because combining the foldl and map does not work
11:24:17 <jrm2k6> ok let me try
11:24:19 <ricree> dcoutts: One last thing for now. Any chance you can point me to the doc for how those .list files are used to generate the .hs? My googling is just leading me to things about Data.List
11:24:24 <monochrom> then the bigger picture is map (fold ? ??) [ ["I", "am", "monochrom", "!"], ["I", "am", "not"] ]
11:24:43 <latro`a> :t \x y -> toEnum $ on (+) fromEnum x y `mod` (fromEnum maxBound + 1)
11:24:44 <lambdabot>     Could not deduce (Enum a0) arising from a use of `fromEnum'
11:24:44 <lambdabot>     from the context (Enum a, Enum a1)
11:24:44 <lambdabot>       bound by the inferred type of
11:24:48 <dcoutts> ricree: https://github.com/vincenthz/gtk2hs/tree/master/tools/hierarchyGen
11:24:54 <ricree> thanks again
11:25:46 <monochrom> combining foldl and map totally works. you just have to combine correctly.
11:25:48 <jrm2k6> monochrom: my function findLongestWords takes a string and a list of string in parameter
11:25:57 <jrm2k6> i dont need to use a foldl to make it work
11:26:21 <monochrom> fine, you can do that too
11:26:27 <jrm2k6> this is what i have now
11:26:36 <jrm2k6> my issue is that i need to apply this on a list of list
11:27:00 <monochrom> map (findLongestIdentifierEver "") [ ["I", "am", "monochrom", "!"], ["I", "am", "not"] ] ?
11:28:14 <monochrom> print (map (findLongestIdentifierEver "") [ ["I", "am", "monochrom", "!"], ["I", "am", "not"] ]) ?
11:28:39 <jrm2k6> yep
11:28:43 <jrm2k6> works
11:28:50 <jrm2k6> why i tried to go with a fold them
11:28:53 <jrm2k6> i need to sleep
11:29:01 <FreeFull> > maximumBy (comparing length) ["a", "bb", "cmcmam", "oew!"]
11:29:03 <lambdabot>   "cmcmam"
11:29:09 <monochrom> you can use foldr to write map
11:29:11 <mangaba_leitosa> All, how do I increase the 100 lines limit for $HOME/.ghc/ghci_history file ?
11:29:17 <jrm2k6> hm
11:29:50 <monochrom> map f xs = foldr (\a b -> f a : b) [] xs
11:30:22 <jrm2k6> i see, what does \a means?
11:30:23 <mangaba_leitosa> I looked through GHC doc, no mention of that. I googled and found a reference to System.Console.Readline.stifleHistory, but ghc cannot find this function
11:31:10 <monochrom> "\x -> x+1" is a function that maps x to x+1. for example (\x -> x+1) 5 = 5+1
11:31:34 <monochrom> "\x y -> x+2*y" is syntax sugar for "\x -> \y -> x+2*y"
11:31:38 <FreeFull> You can use a shorthand for   \x -> x+1
11:31:44 <FreeFull> So it ends up being (+1)
11:31:49 <jrm2k6> right
11:31:55 <jrm2k6> anonymous function somehow?
11:32:02 <monochrom> ok, next time I'll use "\x -> x+1+x" to confound that
11:32:07 <monochrom> yes
11:32:38 <ion> Let’s make a proposal for (+1+)
11:33:46 <monochrom> so, I could define "g a b = f a : b" before I use "foldr g [] xs". but I chose to screw that and just "foldr (\a b -> f a : b) [] xs"
11:35:13 <imalsogreg> jfischoff: I heard secondhand you're interested in a native haskell gui library?
11:35:57 <jfischoff> imalsogreg: I am!
11:36:33 <imalsogreg> jfischoff: me too!  I'm wondering what the state of the art is with that?  Have you started?  Can I help?
11:37:17 <imalsogreg> jfischoff: (with the usual humble disclaimer - I'm < 12 months in on Haskell)
11:37:30 <jfischoff> I have looked into building anything for a while unfortunately :(
11:37:56 <jfischoff> I don't much about the state of the art either :(
11:38:12 <jfischoff> my basic thought was diagrams + some FRP things
11:38:31 <jfischoff> not really that different from what others are trying
11:38:52 <imalsogreg> Ah ok.  I was thinking lower level.  More like a replacement for gtk.
11:39:29 <jrm2k6> Thanks guys for the help, this is my final code https://gist.github.com/jrm2k6/6584648 any improvements to do?
11:40:24 <imalsogreg> At any rate, thanks!  I'll let you know if I ever start something :)
11:40:33 <conal> jfischoff: if you're interested in semantically well-defined gui library design, i'd be happy to consult.
11:40:49 <jfischoff> honestly what I most interesting in is the language for describing shapes, and machine description for adaptive computation
11:41:10 <jfischoff> conal: I would love your feedback :)
11:41:26 <conal> jfischoff: cool.
11:41:31 <jfischoff> conal: right now I am work and family focused almost entirely :(
11:41:44 <monochrom> jrm2k6: I think it's good. unless you want to further replace your own code by more use of the standard library
11:41:46 <conal> jfischoff: :)
11:41:50 <jfischoff> which get together in ICFP!
11:42:14 <jfischoff> I really want the update on CCC stuff :)
11:42:33 <jrm2k6> Ok thanks monochrom!
11:47:29 <warp>  uuuuu~.
11:47:38 <warp> woops
11:52:20 <joelteon> > scanr1 (+) [a,b,c,d]
11:52:21 <lambdabot>   [a + (b + (c + d)),b + (c + d),c + d,d]
11:53:30 <ReinH> edwardk: I had a really weird result while profiling my dijkstra map algo yesterday
11:55:43 * hackagebot pianola 0.1.1 - Remotely controlling Java Swing applications  http://hackage.haskell.org/package/pianola-0.1.1 (DanielDiazCarrete)
11:57:04 <red> what are my choices if i need an associative list/dictionary?
11:57:34 <red> or should i just use some combo of tuple/list?
11:58:06 <FreeFull> > scanr1 (+) [0..]
11:58:07 <lambdabot>   [*Exception: stack overflow
11:58:17 <FreeFull> Oh, right
11:58:19 <imalsogreg> red: Data.Map ?
11:58:20 <FreeFull> > scanl1 (+) [0..]
11:58:21 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
11:58:23 <geekosaur> Map, HashMap, IntMap
11:58:38 * mangaba_leitosa still figuring out how to increase the lines limit on .ghci_history :-O
11:58:47 <red> oh yeah maps .. durrr
12:03:54 <beaky> hello
12:03:55 <red> ugh i have never used map before . if i am given an Int = 10 and i want to create a map {1 : [1], 2 : [2], ..., 10 : [10]}
12:03:58 <red> where : is not cons
12:04:00 <beaky> what is the difference between foldr and foldl
12:04:01 <red> how would i go about that?
12:04:55 <FreeFull> red: A map as in the data structure?
12:05:21 <red> FreeFull: yes
12:05:40 <JordiGH> Cale: A while ago you tried to prove to me that there are infinitely many primes in Haskell. You just wrote a program that lists the primes, but this doesn't prove squat. The proving, as far as I'm concerned, is done by the type system. So, how would you really, or do you know of a reference, about how you would prove there are many infinitely primes?
12:05:56 <geekosaur> red, you can't build one directly, the constructors are hidden so that invariants can be preserved. use Data.Map.fromList
12:06:04 <red> JordiGH: euclid
12:06:10 <FreeFull> > M.fromList (zip [1..10] [1..10])
12:06:11 <lambdabot>   fromList [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
12:06:12 <dwcook> Is there an existing typeclass for types that I can take the head and tail of and check for emptiness? Or does that basically just mean "list"?
12:06:13 <red> JordiGH: proof via haskell , i know not
12:06:13 <JordiGH> red: archimedes
12:07:08 <red> JordiGH: ??? really? no way
12:07:17 <JordiGH> red: Really what?
12:07:22 <beaky> @src foldl
12:07:22 <lambdabot> foldl f z []     = z
12:07:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:07:32 <pavonia> beaky: see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
12:07:38 <beaky> ah
12:07:42 <red> JordiGH: what does archimedes have to do with the famous euclid proof for the infinitude of primes?
12:07:57 <beaky> foldl f a (x:xs) = f (foldl f a xs) x -- this is how I defined foldl is it wrong?
12:08:45 <ReinH> beaky: yes
12:08:48 <JordiGH> red: You were mentioning a random mathematician of antiquity without context, and I was mentioning another.
12:08:51 <beaky> why is it wrong
12:08:57 <ReinH> beaky: compare to the above
12:09:17 <red> JordiGH: oh! yeah, euclid first (and last) proved that
12:09:20 <JordiGH> The proof is probably not due to him. Euclid is more of a compiler.
12:09:25 <beaky> :t \f a (x:xs) -> f (foldl f a xs) x
12:09:26 <lambdabot> (a -> b -> a) -> a -> [b] -> a
12:09:35 <beaky> seems correct
12:09:48 <beaky> or did i accidentally define foldr
12:09:50 <JordiGH> red: No, there are more modern proofs of the infinitude a primes. A famous proof by Euler hinges on proving that the sum over the reciprocals of all primes diverges.
12:09:57 <ReinH> @src foldl
12:09:57 <lambdabot> foldl f z []     = z
12:09:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:10:15 <ski> > foldl f z [a,b,c]
12:10:15 <beaky> ah now I get it
12:10:16 <lambdabot>   f (f (f z a) b) c
12:10:18 <ski> > let foldl f a [] = a; foldl f a (x:xs) = f (foldl f a xs) x in foldl f z [a,b,c]
12:10:19 <lambdabot>   f (f (f z c) b) a
12:10:22 <beaky> foldl accumulates on the z parameter
12:10:24 <ski> see the difference ?
12:10:29 <beaky> foldr builds computation
12:10:39 <beaky> i.e. foldl is tailr ecursive
12:10:48 <beaky> (or iterative?)
12:10:54 <beaky> and foldr is good old recursion
12:11:24 <beaky> or did i miss teh point? :D
12:11:28 <ski> yes, `foldl' accumulates, and is tail-recursive. it's its raison d'être
12:11:34 <red> :t zip
12:11:35 <beaky> ah
12:11:35 <lambdabot> [a] -> [b] -> [(a, b)]
12:12:06 <beaky> zip = (,) <$> xs <*> ys
12:12:07 <dwcook> beaky, keep in mind that tail recursion doesn't have exactly the same value in a lazily evaluated language as in a strictly evaluated one
12:12:14 <beaky> ah how come?
12:12:33 <ski> well, it can be nice, but often an incremental solution is nicer
12:12:33 <beaky> oh right
12:12:33 <ReinH> beaky: because applicative is, in some ways, a generalization of zipping
12:12:42 <ReinH> oh you weren't asking that
12:13:01 <beaky> ah i didn't know applicative was generalized zippers
12:13:03 <JordiGH> What does this type constraint mean? Num (a -> b) => whatever
12:13:05 <dwcook> beaky, well, foldl, the non-strict version, can still build up thunks
12:13:11 <JordiGH> How can a function be of type Num?
12:13:15 <ski> (and tail-recursion automatically means that it's not incremental, you only get to the answer when you reach the base case)
12:13:21 <beaky> ah right so foldl is only good in strict languages like ML?
12:13:26 <dwcook> I didn't say that
12:13:29 <ReinH> beaky: not zippers, zipWith
12:13:34 <beaky> oh
12:13:42 <ski> JordiGH : consider the common definition `(f + g)(x) = f(x) + g(x)' in math
12:13:59 <dwcook> Just don't automatically equate "tail recursive" with "doesn't build up anything in memory"
12:14:22 <dwcook> There's also this
12:14:24 <dwcook> @type foldl'
12:14:25 <lambdabot> (a -> b -> a) -> a -> [b] -> a
12:14:27 <dwcook> The strict version
12:14:34 <ski> dwcook : which one shouldn't do in an eager language, either :)
12:14:35 <red> i want a fcn with this type signature [a] -> [(a,[a])] where the internal tuples are (number, singleton list with that number in it)
12:14:40 <red> does this exist?
12:14:53 <beaky> I love recursion
12:14:53 <ski> why singleton list ?
12:14:56 <beaky> because it makes code elegant
12:15:06 <ski> > group "mississippi"
12:15:07 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
12:15:09 <ReinH> beaky: so does iteration
12:15:12 <beaky> ah
12:15:15 <red> ski: just an implementation detail i need to work with .. methinks
12:15:19 <ski> ReinH : you could try go from there
12:15:25 <ski> red ^
12:15:36 <tel> Does anyone have a recommended reference describing parametricity in terms of dinaturality?
12:16:30 <JordiGH> What does that mean? A natural transformation in more than one variable?
12:16:33 <red> > group [1..5]
12:16:35 <lambdabot>   [[1],[2],[3],[4],[5]]
12:16:37 <JordiGH> Dinaturality, I mean.
12:16:37 <ReinH> :t zipWith (,) [1..] [1..] -- beaky
12:16:38 <lambdabot> (Enum a, Enum b, Num a, Num b) => [(a, b)]
12:16:42 <ReinH> :t (,) <$> [1..] <*> [1..]
12:16:43 <lambdabot> (Enum a1, Enum a, Num a1, Num a) => [(a1, a)]
12:18:11 <red> > [(x,[x]) | x <- xs]
12:18:12 <lambdabot>   Not in scope: `xs'
12:18:13 <lambdabot>  Perhaps you meant one of these:
12:18:13 <lambdabot>    `x' (imported from D...
12:18:22 <red> > [(x,[x]) | x <- [1..5]]
12:18:23 <lambdabot>   [(1,[1]),(2,[2]),(3,[3]),(4,[4]),(5,[5])]
12:18:30 <red> i am a genius
12:18:37 <ski> @let instance Num a => Num (rho -> a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = liftA negate; abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
12:18:38 <lambdabot>  Defined.
12:18:41 <ski> > (sin ^ 2 + cos ^ 2) (pi / 8)
12:18:45 <lambdabot>   1.0
12:19:05 <ski> JordiGH : you can do that ^ kind of stuff, given the above instance declaration
12:19:52 <ski> > let x = id in map (x ^ 2 - x + 1) [0 .. 3]
12:19:55 <lambdabot>   [1,1,3,7]
12:19:58 <beaky> why is (,) <$> xs <*> ys different from zip?
12:20:08 <JordiGH> Is ">" how you tell lambdabot to continue in the same scope?
12:20:09 <tel> JordiGH I think so, and it also implies some coherence between covariant and contravariant uses of the parameter
12:20:25 <Jeanne-Kamikaze> because of <*>
12:20:26 <ReinH> beaky: it isn't.
12:20:28 <ski> `> ...' is an abbreviation for `@run ...'
12:20:34 <Jeanne-Kamikaze> oh, my bad :D
12:20:48 <Taneb> beaky, zip is a legitimate interpretation of a possible lift applicative, but the default one goes with the monad
12:20:51 <tel> I just recently read that parametricity has a categorical explanation via dinaturality, and since the relation-based one doesn't sit totally comfortably with me yet I wanted to see it from a different direction
12:21:06 <ski> JordiGH : if you have used `@let ...', then that will be in scope in lambdabot (provided it didn't have errors), until you `@undefine'
12:21:06 <JordiGH> ski: I see.
12:21:16 <Taneb> beaky, see Ziplist
12:21:24 <Jeanne-Kamikaze> no, I was right
12:21:27 <ReinH> beaky: zip = zipWith (,); zipWith (,) as bs = (,) <$> as <*> bs = pure (,) <*> as <*> bs
12:21:34 <ski> in e.g. GHCi, you'd say just `let ...' instead (or better, put it into a module in a file, and load that file)
12:21:43 <JordiGH> ski: How come lambdabot doesn't get cluttered this way?
12:21:59 <ski> `@undefine' wipes the slate clean
12:22:19 <ReinH> oh wait, no
12:22:26 <ReinH> you need ZipList
12:22:52 <ski> (it might be nice to have per-user sandboxes, like rudybot in #scheme (you can give a value to another user as well), but lambdabot doesn't currently support that)
12:23:24 <Taneb> > ((,) <$> "hello" <*> "beaky", getZipList $ (,) <$> ZipList "hello" <*> ZipList "beaky")
12:23:25 <lambdabot>   ([('h','b'),('h','e'),('h','a'),('h','k'),('h','y'),('e','b'),('e','e'),('e...
12:23:31 <Taneb> ...
12:23:38 <ReinH> because the defaykt applicative list is 'list of successes'
12:23:47 <ReinH> *default
12:23:49 <Taneb> > getZipList $ (,) <$> ZipList "hello" <*> ZipList "beaky"
12:23:50 <lambdabot>   [('h','b'),('e','e'),('l','a'),('l','k'),('o','y')]
12:24:17 <Taneb> beaky, can you tell me how pure would behave with ZipList?
12:24:20 <ski> ReinH : because that's the one that extends in the sensible way to the monad on `[]'
12:24:20 <Taneb> No cheating!
12:24:38 <ReinH> ski: yep
12:25:20 <ReinH> ski: well, because that's the monad that was chosen for [] ;)
12:25:48 <FreeFull> ReinH: Well, you can't make a monad for ZipList
12:25:51 <ski> if you want to phrase it that way, yes
12:25:52 <ReinH> but ZipList isn't a... right
12:26:02 <ski> FreeFull : iirc, you actually can
12:26:14 <FreeFull> ski: One that obeys the laws?
12:26:20 <ski> i think so
12:26:37 <beaky> pure makes it lke zip
12:26:56 <ski> for `join', you need to make sure that to yield an element on the diagonal, all the elements to the "left" and "above" of it must exist
12:27:29 <ski> so `join [[0],[1,2]]' is equal to `[0]', not to `[0,2]'
12:27:51 <ski> well, insert the requisite `ZipList's
12:28:23 <ski> iirc, you need this to make associativity work out
12:33:46 <ReinH> :t pure -- beaky
12:33:47 <lambdabot> Applicative f => a -> f a
12:34:00 <ReinH> he left :(
12:34:34 <Clint> on't worry, you can repeat the lesson tomorrow
12:34:40 <ReinH> I'm sure.
12:35:23 <elliott> ski: I believe that violates another law.
12:35:27 <elliott> but I don't know which.
12:35:45 * hackagebot happy 1.19.0 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.0 (SimonMarlow)
12:35:47 * hackagebot alex 3.1.0 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.1.0 (SimonMarlow)
12:37:45 <Thulsadum> i must admit. if you get the type errors fixed in haskell, your program does what you want.
12:38:16 <n-dolio> No, there's no zip monad.
12:38:27 <n-dolio> For lists, at least.
12:40:25 <latro`a> is there a shorthand for f (Foo x) = Foo (g x) in record syntax?
12:40:34 <latro`a> (i.e. where Foo x is a more complicated record)
12:40:59 <latro`a> more precisely, I'm looking for: f (Foo x1 x2 ... xn) = Foo (Foo (g x1) x2 ... xn)
12:41:04 <latro`a> ....
12:41:05 <latro`a> one more time
12:41:16 <latro`a> more precisely, I'm looking for: f (Foo x1 x2 ... xn) = Foo (g x1) x2 ... xn
12:41:39 <shachaf> f = over someLens g
12:45:19 <danr> latro`a: f x = x { x1 = g x1 }
12:45:34 <profmakx> bla
12:45:42 <danr> latro`a: assuming x1 is the name of the record field
12:45:43 <latro`a> was sketchy about the x1 on the right, but yeah that seems to work
12:46:07 <latro`a> wait
12:46:23 <latro`a> shouldn't it be g (x1 x)?
12:46:35 <danr> latro`a: oh, right yes
12:47:13 <danr> latro`a: I think I wrote so because I usually do f x{..} = x { x1 = g x1 }
12:47:16 <red> i neeeeeed state
12:47:40 <danr> uh. that's not correct either. f x@K{..} = ...
12:48:38 <Rc43> Hi, guys.
12:49:01 <Rc43> Anybody knows well-known libraries which extensively use monoids?
12:49:19 <JordiGH> Rc43: Anything that uses addition of numbers?
12:49:21 <Rc43> I want to try simple optimization, which can give nice boost on monoids.
12:49:33 <miro> mio
12:49:34 <JordiGH> Or anything that uses lists?
12:49:47 <Rc43> JordiGH, I think lists would be better.
12:49:57 <Rc43> JordiGH, may be the best.
12:50:26 <Clint> optparse-applicative
12:50:27 <Guest82883> Please, I have a problem importing/including one method
12:50:31 <MitchellSalad> hey, general Pipes question - when designing little pieces of functionality that take input and produce output I'm having a hard time deciding if I should use Foo -> Producer' Bar m (), or Pipe Foo Bar m ()
12:50:46 <MitchellSalad> since I'm not sure ahead of time how the function will be used
12:50:55 <MitchellSalad> are the two type signatures conceptually the same?
12:51:33 <Rc43> miro, I see only reddit thread and a paper about it, is it on hackage?
12:51:33 <Guest82883> How can I add one function from Network.Socket, when the module is included like this?: import Network (listenOn, accept, PortID(..), Socket)
12:52:35 <Guest82883> what I need is to add: setSocketOption server ReuseAddr 1
12:52:44 <Rc43> miro, and its quiet hard to benchmark such thing on dual-core laptop =/
12:53:26 <Rc43> *quite
12:53:58 <Rc43> Clint, is there benchmark for this?
12:54:07 <Clint> Rc43: for optparse-applicative?
12:54:15 <red> will someone private tutor me on a graph algorithm I'm trying to implement? i neeeeed help
12:54:15 <Clint> what
12:54:46 <Rc43> Clint, yeah, something, what I can run and measure performance, then try something to reimplement and measure again.
12:54:54 <Clint> no idea
12:55:28 <Rc43> Clint, will look, maybe it is possible to nvent sintetic test.
12:55:43 <Rc43> *synthetic
12:56:41 <byorgey> Guest96413: just add  setSocketOption to that list
12:56:58 <byorgey> Guest96413:  import Network (listenOn, ......, setSocketOption)
12:57:22 <Clint> does Network re-export that?
12:57:34 <byorgey> oh, sorry, I was addressing the wrong Guest
12:58:16 <byorgey> Clint: good point. problems may have included: needed to import Network.Socket; needed to use a newer version of the network library; etc.
12:58:37 <byorgey> Clint: you're right, it doesn't.
13:13:01 <ericmoritz> what is a stupid theta?
13:13:46 <ocharles> mm_freak_: making good progress with SDL2 bindings
13:13:54 <benmachine> ericmoritz: iirc something related to datatype contexts, not sure what exactly
13:13:55 <shachaf> The constraint in data C a => T a = ...
13:14:09 <ocharles> mm_freak_: hopefully ready to pick your brains about how I can use the power of Events with netwire 5 to do input handling
13:15:03 <mm_freak_> ocharles: feel free to ask any time
13:15:46 * hackagebot HaTeX 3.8.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.8.0.0 (DanielDiaz)
13:16:48 <scripty> >8 `div` 7
13:16:58 <scripty> :(
13:17:34 <scripty> > 8 `div` 7
13:17:35 <lambdabot>   1
13:20:42 <heath> yay! \o/
13:20:43 <heath> http://www.cs.uu.nl/wiki/Center/SyntaxMacrosForFree
13:20:54 <heath> "syntax macros for free"
13:30:46 * hackagebot semigroups 0.10 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.10 (EdwardKmett)
13:33:12 <johnw> yay, a new semigroups
13:33:32 <Taneb> johnw, did you ever take a look at my FP Complete markdown problems?
13:33:53 <johnw> Taneb: no, can you submit it as feedback to the site?  I don't work on that aspect of the site myself
13:34:00 <Taneb> Okay, thanks
13:34:16 <kuribas> Is there a function to rotate a list?
13:34:50 <thirsteh> Does something like this exist? compareJust :: Eq a => a -> Maybe a -> Bool (returning False if the Maybe is Nothing, and the result of == otherwise)
13:35:34 <johnw> you mean, (\(h,t) -> t ++ [h]) . head &&& id?
13:35:35 <edwardk> just embed the first thing in 'Just'
13:35:44 <glguy> thirsteh: \x y -> Just x == y
13:35:47 <thirsteh> edwardk: oh, brilliant, hadn't thought of that
13:36:09 <n-dolio> @type \n l -> zipWith (flip const) l . drop n $ cycle l
13:36:10 <lambdabot> Int -> [c] -> [c]
13:36:19 <thirsteh> thanks edwardk, glguy
13:36:59 <johnw> also: fromMaybe False (x ==)
13:37:16 <n-dolio> Guess that fails on empty list, which is unfortunate.
13:37:18 <thirsteh> doh! :)
13:37:30 <FreeFull> It's nice to have the rotate work with negative numbers too
13:37:31 <kuribas> :t (==) . Just
13:37:31 <lambdabot> Eq a => a -> Maybe a -> Bool
13:37:58 <n-dolio> Way too much work.
13:38:04 <n-dolio> Needs to fit on one line.
13:38:16 <glguy> Yeah, this is IRC
13:38:31 <johnw> edwardk: what is BASE2?
13:38:57 <edwardk> semigroups will compile and run on hugs
13:39:02 <johnw> ah, cool
13:39:12 <johnw> NonEmpty had no length function before?  I never noticed
13:39:28 <edwardk> me neither, greg weber pointed it out
13:39:39 <kuribas> n-dolio: What do you need?
13:39:40 <edwardk> he asked for a few other functions, but they can be pushed out later.
13:40:02 <n-dolio> I don't need anything.
13:40:13 <kuribas> That's great.
13:40:46 * hackagebot pwstore-fast 2.4 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.4 (PeterScott)
13:49:11 <kuribas> Are most haskell apps written actually command line apps?
13:49:55 <edwardk> there are a lot of web apps done in haskell these days, but we don't have much of a general gui focus
13:49:57 <sm> sure, because those are much lower cost
13:50:38 <kuribas> It's more because of lack of interest, than that haskell isn't suited for GUI apps?
13:51:33 <edwardk> its a mishmash of issues. mostly involving portability of gui libraries, haskell not being very good at talking to c++, that 64 bit versions of things like gtk are hard to get working on platforms like mac, so you wind up having to compromise all over the place
13:51:58 <johnw> yeah, without Cocoa bindings, I doubt Haskell GUIs on Mac will ever be taken seriously
13:52:11 <edwardk> i can't point to a single user interface platform i can write to other than the web that i can consistently link to on all platforms in such a way that i can have users just 'cabal install'
13:52:32 <edwardk> consequently i just don't write gui apps.
13:52:35 <johnw> edwardk: ncurses
13:52:41 <edwardk> … other than bare bones opengl that is
13:52:47 <thoughtpolice> johnw: windows :(
13:52:49 <edwardk> even ncurses is a pain in the ass to talk to portably
13:52:58 <kuribas> wxhaskell is supposed to be portable.
13:53:08 <thoughtpolice> you can use stuff like pdcurses and that other jazz, but they're all variously incompatible in some ways a lot of the time
13:53:14 <Earnestly> ncurses is hardly good anyway
13:53:31 <Earnestly> (Doesn’t even support utf-8)
13:53:37 <geekosaur> which wirks as long as you can find its dlls. guess what windows does not provide any consistent way to do?
13:53:58 <sm> kuribas: it's certainly not lack of interest, far from it. GUI programming is just hard/expensive, it requires a lot of investment
13:54:06 <geekosaur> um what? ncurses has been utf8 safe for several years; ncursesw was folded into ncurses
13:54:20 <geekosaur> (which is not to say that (n)curses does not have major issues)
13:54:35 <edwardk> kuribas: it still requires you to jump through some hoops: http://www.haskell.org/haskellwiki/WxHaskell/Mac
13:54:51 <edwardk> as noted there "Even though graphical applications on MacOS X look great, it is a still a developers nightmare to get them working :-). This page describes how to circumvent some of the pitfalls."
13:55:01 <kuribas> sm: I have written a bit of gui programming in ruby/gtk.  It wasn't so diffult, but not portable of course.
13:55:24 <Earnestly> geekosaur: Ah, thanks good news then, thanks
13:55:31 <Earnestly> s/thanks/thats
13:55:41 <edwardk> kuribas: i've managed to get things up and running on each platform in turn, but it always seems like whatever platform i'm not using is always broken ;)
13:55:45 <johnw> True reactive programming: You never implement features, you only fix bugs.
13:56:08 <geekosaur> haskell ncurses bindings may or may not be utf8 safe (there are several, some of which predate ghc supporting full utf8 and may not have been revised to use the new supporot)
13:56:24 <Earnestly> Dijkstra suggested we call bugs by their true name, “errors”.
13:56:46 <edwardk> geekosaur: in general utf-8 and windows console output together have a troubled past.
13:56:59 <johnw> Earnestly: let's call them "dissonance between what the program does and what the user expected to happen"
13:57:15 <edwardk> geekosaur: consider: http://ghc.haskell.org/trac/ghc/ticket/4471
13:57:19 <geekosaur> ncurses is a lose on windows anyway
13:57:22 <Earnestly> johnw: The point was to place the blame where it belongs, the programmer.
13:57:30 <johnw> ah
13:58:07 <geekosaur> ncurses was designed around the idea that cursor positioning and output control is done with escape sequences. windows usually uses ioctl calls instead
13:58:23 <edwardk> Earnestly: sure, flog the developer, not contradictory specifications, not rampant change in specifications. Dijkstra was a bit of a dick. ;)
13:58:49 <Earnestly> edwardk: Those are errors with the specification and blame lies with those who made them
13:59:17 <edwardk> I'm happy that you can live in such a black and white world.
13:59:23 <acowley> Are any OpenGL contributors around?
14:00:13 <Earnestly> edwardk: I’m not sure how blaming the programmer for the errors in their program, or the errors in the specification is related to the concept of “black and white”.
14:00:23 <monochrom> wait, what? who is blaming my favourite Dijkstra?! :)
14:00:59 <kuribas> edwardk: If you develop for mac, do you have to deal with the different processors?  Or is powerpc to old?
14:01:23 <monochrom> also, I agree with saying "error". but this still doesn't always blame the programmer. if the error is in the specification, blame the specifier. but it is still an error.
14:01:26 <edwardk> kuribas: powerpc hasn't been an issue in the mac community in a _long_ time. =)
14:02:07 <acowley> I have a G5 iMac upstairs. It feels lonely.
14:02:26 <monochrom> also, in a team-player setting, you can still safely say "error" without blaming any person. we have an error, let's learn from it and fix it together, no one is blamed.
14:02:28 <Taneb> Why blame when you can just fix
14:02:28 <edwardk> i prefer to focus on how to fix the problem rather than sitting there have everyone play the blame game. i make lots of unforced errors. Pinning the blame on me as a developer is easy. Great. I don't really care. Now that you've found the bug or error, let's fix it and move on.
14:02:45 <sm> kuribas: I didn't mean to say programming guis has to be difficult (far from it!). Just that it requires someone to have put in a lot of work building up infrastructure. Especially if you want to work across platforms
14:02:50 <bergey> acowley: I just found your OpenGL libraries a few days ago.  Thank you!  (alas, I'm just an OpenGL user, not a contributor.)
14:03:09 <Earnestly> edwardk: You’re missing the meaning behind the change of wording :\
14:03:11 <edwardk> There is a cost in trying to accurately model the world at every point.
14:03:22 <edwardk> I got your meaning. I just happen to disagree that it is useful.
14:03:46 <acowley> bergey: Glad to hear it!
14:03:46 <Earnestly> It’s not mine to call my own.  Perhaps it was wrong of me to assume people were familiar with ewd
14:04:08 <ReinH> Earnestly: could you be a little less patronizing please?
14:04:13 <edwardk> Earnestly: i am very familiar with Dijkstra and his various screeds. They just aren't all universally accepted as good ideas. ;)
14:04:40 <Earnestly> ReinH: I wasn’t aware of his work not so long ago myself
14:04:51 <edwardk> e.g. http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD611.html vs. Alan Kay's rebuttal "On the fact that most software is written on one side of the Atlantic Ocean"
14:04:54 <kuribas> sm: Yes, it takes time to think about layout, user experience.  I think a lot of programmers prefer to think about technical matters instead.
14:04:59 <sm> Earnestly: I follow that naming, but not zealously. "bug tracker" is just too well understood
14:05:20 <sm> but in my own notes, they're programmer errors
14:05:22 <Earnestly> edwardk: Then why are you refering to using the term as a “blame game” when that wasn’t the intention?
14:05:48 <sm> kuribas: I wasn't even referring to that, but that's also true
14:05:54 <monochrom> edwardk, perhaps you treat "bug" the same way Dijkstra treats "error". in that case, good for you.
14:06:05 <sm> unless you're using a nice canned framework that has those things baked in
14:08:17 <kuribas> Even then, you have to think about the person using the program.  It bugs me how many "could be great" open source programs are unusable because of the user interface.  Or that you cannot use the program without it crashing 5 times a day.
14:08:20 <edwardk> monochrom: well, the bug as error screed was in EWD1036. " It is much more honest because it squarely puts the blame where it belongs, viz. with the programmer who made the error."   is frankly naive. Most software isn't written by a single individual. It is usually built by a team that have slightly differing views of how the whole system should fit together, that as they hammer on the software they meld those visions into one
14:08:20 <edwardk>  coherent working piece of code.
14:08:49 <ReinH> Earnestly: the idea that a single programmer is responsible for a bug or error is almost always incorrect, Dijkstra's toughts on the matter notwithstanding.
14:08:55 <ReinH> *thoughts
14:09:33 <edwardk> Is it an 'error' to have a disagreement about the semantics a piece of code should have? i'm not sure. i rarely sit down and iron out a concrete perfect specification water-fall style like its the 70s when i sit down to code. i instead turn to evolving a consistent set of tools. along the way i have many of these errors.
14:10:00 <sm> edwardk: from the user's point of view, yes, it surely is ?
14:10:46 <edwardk> sm: sure. in a CMMI level 5 shop where you've got such ridiculous change control processes, I'm happy to call that sort of thing an error. I'm also very happy not to work there.
14:10:55 <sm> it gave the wrong answer.. damn those programmers!
14:11:08 <ReinH> Earnestly: the other fundamental flaw in Dijkstra's reasoning is the idea that there is value in blaming. There isn't.
14:11:13 <ReinH> There is value in accurately assessing the problem.
14:11:15 <edwardk> software is a very pliable medium
14:11:17 <ReinH> This can be done without blaming.
14:11:21 <Earnestly> ReinH: That’s fair but, at least in open source, it usually is a single developer.  Most open source projects are one dev and maybe one contributor but that is rare.  The whole idea is to think of a "bug" as a mistake instead of blaming the machine.  (Although there was the whole FDIV pentium issue...)
14:11:30 <ReinH> Earnestly: open source is usually a single developer? No.
14:11:36 <clahey> So, what is Dijkstra trying to say?  He says that a program with an "error" is "wrong".  But who cares if it's wrong?
14:11:52 <Earnestly> ReinH: Oh yes, taking data from sourceforge, github and bitbucket you’ll find that it usually is.
14:12:02 <ReinH> Earnestly: who is blaming the machine? That sounds like a strawman.
14:12:05 <monochrom> people do not care enough
14:12:34 <ReinH> There are two classes of problem here. There are technical problems, which require technical solutions. Blaming people is not a technical solution.
14:12:38 <clahey> Earnestly, Sure, but if you weight programs by how often they're used, then you come out with an average of more than one developer, and that's a better weighting.
14:12:43 <monochrom> then again, democracy says that, if people do not care enough, so be it.
14:12:46 <ReinH> There are people problems, which require people solutions. Blaming people is not an *effective* people solution.
14:12:57 <ReinH> Teaching or training is.
14:13:05 <Earnestly> clahey: By using the top 100 downloaded projects
14:13:45 <edwardk> Earnestly: i have 30+ folks committing code to lens right now. if i sat down and took them to task every time someone made an unforced error by not understanding the problem perfectly, I'd be back to just me. As it stands, I try to figure out what the semantics should be and just fix it when I get a slightly broken patch, and the extra hands get me closer to a correct model. Those contributors throw in about a fourth of the code
14:13:45 <edwardk>  in lens right now, but it is important code.
14:13:53 <clahey> Earnestly, Hmm.  Perhaps then.
14:13:55 <kqr> Earnestly, taking data how? open source is not the same thing as "hacking something together and putting it up on github for safekeeping"
14:14:15 <kqr> Earnestly, by the time people put actual open source licenses on their projects, they have more than one contributor, is my hypothesis
14:14:28 <clahey> But I don't see how things being one developer doesn't matter.
14:14:37 <clahey> kqr, Well, that's not necessarily true at all.
14:14:46 <elliott> can anyone explain what this has to do with haskell to me?
14:14:47 <clahey> I've put a license on many things that no one else ever cared about.
14:14:51 <clahey> elliott, A good question.
14:14:52 <acowley> elliott++
14:15:24 <Earnestly> clahey: Oh it doesn’t matter that it’s one developer.  Just pointing out that there is a common misconception that the majority of open source projects somehow have more contributors
14:15:29 <edwardk> i open source code i want help with or extra eyeballs on, regardless of how many other contributors i currently have
14:15:29 <ReinH> Earnestly: ok, let's stipulate that most open source projects have only one developer. In that case, assigning blame is trivial and therefore still useless.
14:15:48 <visof> hi
14:16:02 <visof> can anyone help me to understand postfix regexp notation
14:16:02 <visof> ?
14:16:04 <clahey> I still want to understand what the point is, but maybe I'll have to read that whole EWD myself.
14:16:14 <ReinH> visof: nope too busy talking about !Haskell ;)
14:16:17 <ReinH> visof: please ask your question
14:16:17 <acowley> My understanding of open source is that I go on IRC to ask if anyone else has seen a particular surprising behavior, monochrom mocks me for thinking my bug report matters, then I send a pull request on github. It's not a perfect system, but it seems to work.
14:16:20 <mauke> visof: how is that a perl question?
14:16:21 <Earnestly> edwardk: Yeah, it’s great.  I wouldn’t want more to be closed source
14:16:38 <ciaranm> the point is that EWD has this silly idea that software should work rather than be cheap
14:16:42 * monochrom doesn't mock you for that
14:17:01 <ReinH> acowley: he mocks you for other things
14:17:01 <Earnestly> ReinH: I never really considered blame to matter.  I personally think that the two terms are pretty interchangable these days.
14:17:18 * monochrom mocks you for irreproducible behaviour though :)
14:17:19 <acowley> visof: Please, please, please ask a programming question. Questions about perl would improve the milieu.
14:17:38 <acowley> ReinH: He mocks me for many things
14:17:43 <carter> acowley: will you be in boston?
14:17:47 <acowley> carter: No
14:18:15 <acowley> carter: I have to be productive for the next few weeks as I've got a trip in November
14:18:21 <slack1256> is monad-coroutines overshadowed with the advent of streaming libraries? (conduit/pipes/io-streams)
14:18:23 <carter> ok
14:18:25 <carter> gl
14:18:56 <monochrom> acowley: I don't recall mocking you. but ok, I'm sorry!
14:19:09 <acowley> monochrom: It's okay, it usually motivates me to stop whining and do the PR
14:19:23 <haasn> Is there any ‘shortcut’ to getting the divisors of a number (in descending order) other than trial division?
14:19:27 <ReinH> Can we talk about EWD's awesome handwriting and layout skills instead? http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1038.PDF
14:19:31 <edwardk> ciaranm: except for the fact that the man basically didn't use computers, except for a bit of email and web browsing at the end of his career. It is a bit like a wine connoisseur, who never drinks.
14:19:40 <Earnestly> ReinH: It’s not cursive though :(
14:20:04 <ciaranm> edwardk: or an astronomer who doesn't use telescopes
14:20:06 <ReinH> but it is well ordered :)
14:20:13 <slack1256> haasn: project euler?
14:20:24 <jfischoff> edwardk: not an entirely accurate comparison but worth remembering
14:20:34 <red_> .
14:20:35 <haasn> slack1256: yeah, problem 23. I've solved it, but it took about a minute to compute
14:20:40 <Earnestly> ReinH: Yeah, even the indenting of the paragraphs. \o
14:20:43 <haasn> slack1256: there has to be some quicker way
14:20:47 <ReinH> edwardk: more like a wine connoisseur who hates wine :p
14:21:04 <jfischoff> the only time he really made a useful system, but his on admission they had to cut lots of corners to get finish
14:21:04 <red_> > (\(a,b,_) -> (a : b)) (1,2,3)
14:21:05 <lambdabot>   No instance for (GHC.Show.Show a0)
14:21:06 <lambdabot>    arising from a use of `M1178267330.sh...
14:21:10 <slack1256> haasn: there is, half of the divisors are under the square root of the number
14:21:16 <ReinH> Earnestly: some nice examples of equational reasoning there too
14:21:31 <red_> can anyone help? i want [1,2] from above
14:21:39 <haasn> slack1256: divisors n = filter (\m -> n `rem` m == 0) [b,b-1,..1] where b = n `quot` 2
14:21:42 <haasn> b is the ‘upper bound’
14:21:50 <Earnestly> ReinH: I am still far to ignorant to even begin to appreciate it though, one day though
14:21:51 <monochrom> red_: a:b:[]
14:21:56 <slack1256> haasn: so the total number of divisor is the double of that
14:21:59 <monochrom> also, [a,b]
14:22:07 <ReinH> [a,b]... doh
14:22:09 <slack1256> ew, what is that?, some kind of programming language?
14:22:14 <slack1256> we are discussing math here!
14:22:23 <haasn> We are discussing Haskell
14:22:28 <haasn> this is #haskell
14:22:28 <ReinH> same difference
14:22:39 <clahey> slack1256, Well, haskell is more of a math language than a programming language.
14:22:41 <ReinH> obligatory this is sparta reference
14:22:44 <haasn> clahey: no differnce
14:22:45 <red_> > (\(a,b,_) -> [a,b]) (1,2,3)
14:22:46 <lambdabot>   [1,2]
14:23:22 <slack1256> come on guys, can't you take a joke and the context (of the answer to haasn) on a answer?
14:23:50 <ReinH> slack1256: pretty sure they were taking the joke
14:24:02 <clahey> slack1256, We took the joke.  We just ran with it.
14:24:19 <slack1256> yes, but did you take the meta-joke?
14:24:22 <clahey> (we're joke snatchers)
14:24:30 * haasn didn't, apparently
14:24:41 <edwardk> In general I view "computer science" and "software engineering" to be two very different skillsets. Some people are very good at one but not the other. Dijkstra was brilliant on the computer science side of things, but I am less comfortable with his pontifications on the art and practice of software engineering, as he frankly never did it. Expertise in one area doesn't transfer to another. Expertise isn't fungible like that.
14:24:41 <ReinH> slack1256: I guess you missed the meta-meta-joke
14:25:08 <slack1256> I feel like I am trapped in the Cont monad for some reason
14:25:12 * jfischoff nods
14:25:13 <ReinH> iterate lift joke
14:25:36 <Earnestly> edwardk: Well, considering he doesn’t even acknowledge software engineering at all :P
14:25:36 * edwardk goes back to making errors.
14:26:35 <ReinH> edwardk: hey I've got a fun problem for you
14:26:35 <slack1256> haasn: anyways, it's a matter of the algorithm, check out the propeties of the divisors
14:26:37 <edwardk> Earnestly: which goes back to Alan Kay's objection. ;)
14:26:41 <edwardk> ReinH: shoot
14:26:49 <slack1256> code after you have a clear idea of what you want to do, nobody like to shoot in the dark
14:26:55 <Earnestly> edwardk: I should read that, thanks for mentioning it
14:26:58 <ReinH> edwardk: I optimized my `around' function that computes concentric squares around a starting point, which made `bfsOrder' faster.
14:27:01 <slack1256> well, maybe some do.
14:27:17 <edwardk> ReinH: by using the symmetries?
14:27:26 <ReinH> yes, got about 20% speedup
14:27:30 <ReinH> edwardk: but using this new, faster bfsOrder in my distance map makes the distance map algo *slower* by about 20%
14:27:36 <ReinH> and that's the only change
14:27:58 <edwardk> ReinH: more pressure on the cache because you have to read a list twice or something?
14:28:03 <ReinH> the new algo does not preseve order
14:28:18 <ReinH> it may be providing a less optimal ordering to the traversal
14:28:21 <ReinH> but that doesn't seem likely
14:28:48 <ReinH> if anything, the order is continuous now so it seems like it should be faster
14:28:53 <acowley> ReinH: How is performance these days? I still haven't done the incremental version of the distance transform code :(
14:29:16 <ReinH> acowley: I'm down from ~50ms for large maps to 35ms
14:29:30 <acowley> That's great!
14:29:35 <acowley> 100x100?
14:29:36 <ReinH> the main cost center now is updating the grid
14:29:40 <ReinH> like 60%
14:29:51 <ReinH> so switching to a mutable array might help a lot
14:30:05 <ReinH> acowley: something like that, yeah
14:30:32 <acowley> Yeah, I'd definitely use a mutable array for this
14:30:48 * hackagebot kure 2.12.0 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.12.0 (NeilSculthorpe)
14:30:51 <ReinH> acowley: for the roguelike game in particular I only need to calculate up to max vision of ~20 squares so it tops out at around 2.2ms
14:30:54 <ReinH> which is totally usable
14:31:29 <ReinH> edwardk: ix is slooooooow :p
14:31:33 <ReinH> also I realize I'm abusing it :p
14:31:54 <edwardk> ReinH: are you on lens head or 3.9?
14:32:03 <ReinH> edwardk: the package version
14:32:06 <ReinH> I can install head
14:32:07 <edwardk> try head
14:32:13 <ReinH> ok
14:32:24 <ReinH> also I'm going to be dropping ix in favor of in-place array updates shortly
14:32:37 <ReinH> updating Vector (Vector a) is unnecessarily slow
14:32:37 <edwardk> try the upgrade first, but then =)
14:32:37 <acowley> How did ix get faster in head?
14:32:45 <ReinH> edwardk: ok :)
14:32:54 <edwardk> it isn't an indexed lens any more
14:32:58 <edwardk> er indexed traversal
14:33:01 <edwardk> just a traversal
14:33:40 <ReinH> edwardk: I have two main cost centers now: updating a cell and calculating the minimum neighbor. Both will be improved with better asymptotic access to grid elements :)
14:33:48 <Earnestly> edwardk: Could I bother you to help me find a link to the rebuttal?
14:33:57 <slack1256> Anybody knows about a haskell user meeting in south america?
14:34:05 <edwardk> Earnestly: i remember him mentioning it in a talk, but i don't remember ever finding a copy online
14:34:11 <ReinH> edwardk: and that means a different data structure, obv, not a faster ix :)
14:34:21 <Earnestly> Ah, I’m having the same difficulty
14:34:45 <ReinH> edwardk: but I have an obvious hill to climb now :)
14:34:56 <ReinH> although I'm sure acowley could come up with a better hill for me to climb ;)
14:35:09 <ciaranm> *cough*hillclimbingsucksuseanexactalgorithm*cough*
14:35:18 <acowley> haha
14:35:32 <ReinH> ciaranm: well, I don't have a built-in exact algorithm for optimizing code.
14:35:37 <edwardk> Earnestly: http://www.youtube.com/watch?v=9KivesLMncs talks a bit abou tit
14:35:48 <acowley> ciaranm: Distance transform just shows you the hill, it doesn't make you climb it
14:36:03 <ReinH> acowley: although to be fair, my impl of distance transform is a hill climb :)
14:36:20 <Earnestly> edwardk: Thanks
14:36:29 <ReinH> but it's a pretty fast one
14:36:57 <acowley> Ugh, I just don't understand ix enough
14:37:10 <ReinH> edwardk: also it turns out that array equality is super fast, so calculating the fixed point is not where the slow is :)
14:37:18 <ReinH> vector equality, that is
14:37:22 <edwardk> fair nuff
14:38:06 <ReinH> not when I'm also traversing each memmber in the grid and all of its neighbors on each iteration ;)
14:38:57 <edwardk> Earnestly: To be fair, I also generally disgaree with Alan Kay on just about as many things as I do with Dijkstra, but I figured I'd offer him up as a suitable titan to counter the invocation of Dijkstra. ;)
14:39:10 <acowley> Dijkstra is usually funnier
14:39:29 <ciaranm> which is the EWD where he goes on about OOP?
14:39:38 <acowley> My metrics for influential thinkers are probably not very well thought out
14:39:45 <ciaranm> something about it being so dumb it could only have been invented in california
14:40:14 <red_> will someone give me private-time help with a graph alg i'm trying to implement?
14:40:15 <red_> haaaaalp!
14:40:31 <Earnestly> edwardk: Heh, I appreciate it really.  This is all still new to me and finding all of this incredible work done by these people decades ago to be both inspiring and utterly depressing
14:42:11 <ciaranm> red_: which algorithm?
14:42:57 <glguy> red_: IRC works better where you just ask your question publicly to see if anyone will see it and be able to help
14:48:18 <red_> glguy: yeah i don't want to flood the channel
14:48:29 <red_> ciaranm: kinda kruskal .. i'm just clustering
14:50:46 <quchen> red_: Paste what you have, then ask in public. If you find someone who can answer and it gets too floody you can move it to some other channel (such as #haskell-overflow).
14:50:50 <quchen> @paste
14:50:50 <lambdabot> Haskell pastebin: http://lpaste.net/
14:51:31 <red_> i have a list : [(nodea,nodeb,weight), (nodea,nodec,weight), ...] and i want to compute a 4-cluster (aka : [(some nodes here),(same),(same),(same)]
14:52:40 <red_> i think i need a function that goes through first list from an "initial point" that each node is in its own cluster
14:53:49 <huud> 4-cluster?
14:54:13 <red_> but i think i'm appealing to state in my thought process and maybe that is bad
14:54:13 <red_> am i making more than zero sense?
14:54:13 <red_> [(7,8,1),(6,7,2),(9,3,2),(1,2,4),(6,3,4),(9,7,6),(3,4,7),(8,9,7),(2,3,8),(8,1,8),(4,5,9),(5,6,10),(8,2,11)]
14:54:29 <huud> hmmm
14:55:48 <red_> initially each node in a cluster by itself
14:56:08 <red_> after (7,8,_) 7 and 8 are grouped
14:56:19 <red_> after (6,7,_) 6,7,8 grouped
15:01:12 <red_> after (9,3,_) 9 and 3 grouped .. along with 6,7,8 cluster .. and a bunch of singletons
15:01:12 <red_> anyway this is Kruskal MST cut off early .. i'm trying to learn haskell via implementing algorithms
15:01:12 <red_> but i can't see anything other than maintaining state
15:02:07 <jroesch> red_: If you need state just use the State Monad (aka pure state)
15:02:33 <spaceships> looking for a recommended intro to continuations
15:02:55 <red_> jroesch: i don't really have a handle for the state monad yet
15:03:19 <red_> jroesch: i was wondering if there was a non-state way that i was overlooking
15:03:26 <jroesch> red_: you can explicitly thread the intermediate state yourself, it just becomes a lot uglier
15:03:54 <acowley> not that ugly
15:04:15 <jroesch> yeah not 'bad' just not as clean deadening on what you are doing
15:04:20 * glguy also weighs in not knowing the particulars
15:04:24 <jroesch> depending*
15:07:57 <imalsogreg> spaceships: I've seen these  https://www.fpcomplete.com/user/jwiegley/understanding-continuations     and   https://www.fpcomplete.com/school/pick-of-the-week/the-mother-of-all-monads
15:10:52 <spaceships> imalsogreg: thanks
15:11:56 <mbrock> if you can write a function that counts to 10, you know how to do state
15:12:39 <hpaste> haasn pasted “divisors (fast)” at http://lpaste.net/93056
15:12:50 <haasn> I came up with a faster version of the function I was asking about earlier :)
15:21:44 <user123abc> there's a hackage package whose modules I can import in the interpreter and when compiling standalone files, but I get "could not find module" when building a project with a .cabal file via runhaskell, and adding the name of the package to Build-Depends tells me that the corresponding dependency is missing
15:21:59 <user123abc> how do I make this package visible to such a build system?
15:23:43 <bergmark> user123abc: is it the exact same name as what cabal suggests if you leave it out of the .cabal?
15:25:16 <tomejaguar> It seems that -fno-code doesn't check for non-exhaustive pattern matches.  Is there an obvious reason for this?
15:30:46 <bergmark> tomejaguar: ouch! didn't know that
15:33:10 <bergmark> that's really nasty :/ fay typechecks with -fno-code
15:33:31 <user123abc> bergmark, cabal doesn't suggest anything
15:33:57 <geekosaur> ISTR that it requires optimization to be on to detect all cases, so it needs code generation for optimization to happen?
15:34:00 <bergmark> tomejaguar: yay :) http://ghc.haskell.org/trac/ghc/ticket/8101
15:34:17 <user123abc> or rather, it suggests Data.Map from the containers package, which is hardly what I want
15:34:38 <user123abc> do I need to do cabal-install foo --global in order for build-deps to find the package?
15:34:38 <Japella> do I need to do cabal-install foo global in order for build-deps to find the package? now has -1 karma
15:34:51 <user123abc> wat
15:34:55 <bergmark> O_o
15:35:03 <geekosaur> o.O
15:35:11 <Maior> rofl
15:35:14 <mauke> a -- b
15:35:14 <Japella> a  b now has -1 karma
15:35:22 <Maior> yay tedious bot
15:35:31 <user123abc> anyhoo, any ideas?
15:35:43 --- mode: ChanServ set +o mauke
15:35:43 --- kick: Japella was kicked by mauke (Japella)
15:36:04 <geekosaur> (agreed as to kicking)
15:36:53 <bergmark> user123abc: you shouldn't need to install it globally, but it has to be in a pkg db cabal can access for it to know about it
15:37:27 <bergmark> could be some version mismatch also?
15:37:43 --- mode: mauke set -o mauke
15:39:12 <tomejaguar> bergmark: Ah great, thanks!
15:40:38 <bergmark> so when is HP with >=7.8.1 coming out :3
15:40:50 * hackagebot sodium 0.8.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.8.0.0 (StephenBlackheath)
15:47:47 <haasn> @quote mappend.operator
15:47:48 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
15:51:21 <red> @undo do let xs = [1,2,3]; print $ xs
15:51:21 <lambdabot> <unknown>.hs: 1: 32:Parse error: EOF
15:53:01 <geekosaur> I think it needs explicit braces since it doesn't know where the let ends
15:53:26 <geekosaur> (let also does layout)
15:55:05 <Maior> so, is it possible to write indentation-insensitive Haskell?
15:55:29 <argiopeweb> Maior: Indeed.
15:55:49 <argiopeweb> Maior: It ends up looking rather like C, but it's entirely possible.
15:55:50 * hackagebot pbkdf 1.0.0.0 - Haskell implementation of the PBKDF functions from RFC-2898.  http://hackage.haskell.org/package/pbkdf-1.0.0.0 (ChrisDornan)
15:56:06 <Maior> argiopeweb: so, curly braces?
15:56:20 <argiopeweb> Maior: Yes. And semicolon for do notation.
15:56:35 <argiopeweb> Maior: I believe the initial goal there was to make it easier to machine-generate code.
15:57:29 <argiopeweb> And if I could find where it's mentioned in the spec, I'd link it...
15:59:59 <geekosaur> @undo do { let { xs = [1,2,3] }; print xs }
15:59:59 <lambdabot> let { xs = [1, 2, 3]} in print xs
16:00:43 <conal> New blog post: "Circuits as a bicartesian closed category" -- http://conal.net/blog/posts/circuits-as-a-bicartesian-closed-category
16:00:54 <red> oh
16:01:14 <geekosaur> yeh, I was addressing both you and Maior there
16:01:14 <argiopeweb> Maior: See section 2.7: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html
16:01:19 <geekosaur> let also introduces layout like do does
16:01:31 <geekosaur> so there's ambiguity whether that semicolon belongs to the let or the do
16:02:00 <Hari`> hi
16:02:00 <geekosaur> > let { xs = [1,2,3]; ys = [4,5,6] } in xs ++ ys
16:02:01 <lambdabot>   [1,2,3,4,5,6]
16:02:18 <Maior> geekosaur: cheers
16:02:22 <Maior> argiopeweb: thanks
16:04:07 <red> in a do block what is the difference between x <- [blah] and let x = [blah] ?
16:05:00 <geekosaur> you could think of it as: in the first case [blah] is monadic, and x is what's in some sense "inside" the monad. (it actually turns into a use of (>>=) )
16:05:30 <argiopeweb> x <- [blah] == ([blah] >>=)
16:06:00 <geekosaur> more precisely it is: [blah] >>= \x ->
16:06:04 <argiopeweb> More parenthesis would have been appropriate there. Also, generally a lambda. [blah] >>= \x ->
16:06:06 <argiopeweb> Rightio.
16:06:09 <red> > do x <- Just 4
16:06:10 <lambdabot>   The last statement in a 'do' block must be an expression
16:06:10 <lambdabot>    x <- Just 4
16:06:23 <geekosaur> note that it ends on -> which is not a complete expression
16:06:29 <geekosaur> which is why you just got that error
16:06:40 <Maior> is it considered bad for me to semi-shun do notation in favour of explicit >>= and return and such?
16:06:44 <red> > do x <- Just 4; print $ x
16:06:46 <lambdabot>   Couldn't match type `GHC.Types.IO' with `Data.Maybe.Maybe'
16:06:46 <lambdabot>  Expected type: ...
16:06:50 <red> i suck!
16:06:51 <Maior> (except in long chains of IO and stuff)
16:06:56 <Hari`> i think that x <- blah takes a value out of the blah monad and puts that value into x; let x = blah_pure defines a pure (non-monadic) value "from scratch" and puts that into x... correct me if i'm wrong
16:06:59 <argiopeweb> Maior: I've heard it recommended for learning monads...
16:07:10 <Maior> argiopeweb: tbf I'm still at that stage!
16:07:27 <geekosaur> red: everything needs to be in the same monad. you used Maybe for your <- but then you did an IO action which means the first one should have been in IO, not Maybe
16:07:50 <geekosaur> >>= forces the same monad on both sides
16:07:50 <argiopeweb> Maior: Definitely a good call then. It's still perfectly acceptable as long as it isn't messy. Do notation is just there as syntactic sugar.
16:07:53 <geekosaur> :t (>>=)
16:07:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:08:32 <red> either way i think i'll try writing everything without do notation for now .. i start to believe i'm just executing instructions in a do block
16:09:02 <argiopeweb> Maior:  and `x <- doThing1 >>= doThing2` saves binding the result of doThing1  if you were only planning on using it in doThing2.
16:09:48 <Maior> is <- actually an operator at all?
16:09:53 <red> @undo do x <- [1..3]; print $ x
16:09:53 <lambdabot> [1 .. 3] >>= \ x -> print $ x
16:09:55 <Maior> I think that's part of what I don't quite like
16:10:02 <Maior> also, @undo is cool
16:10:52 <geekosaur> note that @undo is mechanical and does not see that the first part is in [] and the second is in IO
16:11:06 <red> :t (>>=)
16:11:07 <Maior> ah
16:11:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:11:16 <Maior> geekosaur: so that answer isn't valid?
16:11:29 <geekosaur> it's syntactically valid but a type error
16:11:33 <Maior> right, ok, yes
16:11:36 <red> ah
16:11:36 <nstdloop> Hey guys. I'm trying to update/use cabal and whenever I run cabal install cabal-install I keep getting:
16:11:41 <nstdloop> Failed to install Cabal-1.18.0
16:11:41 <nstdloop> cabal: Error: some packages failed to install:
16:11:42 <nstdloop> Cabal-1.18.0 failed during the building phase. The exception was:
16:11:43 <Maior> explains why I couldn't follow the types then
16:11:44 <nstdloop> ExitFailure 1
16:11:48 <geekosaur> actually it's also wrong because it doesn't know that $ has low precedence
16:12:13 <geekosaur> (but the $ is pointless there anyway)
16:12:18 <nstdloop> This also happens whenever I try to install any packages form hackage
16:12:30 <red> also .. what does it mean to uncontextualize a list [1,2,3] ?
16:12:37 <red> x <- [1,2,3] ???
16:13:06 <Maior> I assume that's different usage of <-
16:13:12 <argiopeweb> Maior: Yes, <- is a reservedop according to section 2.4 (same link as before).
16:13:18 <geekosaur> what it means depends on the monad. in the case of [], it evaluates the following stuff once for each item in the list and concats the results together
16:13:27 <Maior> argiopeweb: ah, sorry, I jumped straight to 2.7 - thanks
16:13:34 <nstdloop> Can anyone help me with a cabal issue?
16:13:36 <argiopeweb> Maior: No worries.
16:13:39 <red> geekosaur: i buy that .. thanks
16:13:58 <Maior> I don't quite like that I can't seem to `:t (<-)`
16:13:58 <argiopeweb> Maior: The spec isn't particularly light reading. ;)
16:14:23 <dcoutts_> nstdloop: you'll need to use a pastebin with the full log so someone can have a look
16:14:29 <Maior> but I guess I can't for *any* reservedop
16:14:32 <nstdloop> oh it's reeeealy long
16:14:35 <nstdloop> gimme a sec
16:14:55 <geekosaur> it's not actually an operator, it's special syntax
16:14:58 <argiopeweb> Maior: Because it's syntactic sugar, not an actual function. Type would be same as (>>=).
16:15:08 <Maior> sure
16:15:42 <nstdloop> dcoutts_ my terminal doesn't log enough lines
16:16:04 <nstdloop> I have this huge warning stack all the way up
16:16:19 <nstdloop> which doesn't feel particularly enlightening
16:16:23 * ocharles hands nstdloop 'script'
16:16:35 <dcoutts_> nstdloop: use  > log
16:16:39 <hashcat> I finally give up haskell and go with scala
16:16:40 <ocharles> or just redirection
16:16:41 <geekosaur> ... 2>&1 | tee logfile
16:16:55 <acomar> nstdloop: In my experience, it helps to try and tackle the first couple error messages first as they frequently cause the giant explosion of error messages.
16:16:57 <geekosaur> also probably want -v3 to cabal install
16:17:14 <argiopeweb> `do {a <- b; <rest of the do block;>` == `b >>= (\a -> <rest of the do block>)`
16:17:24 <acomar> nstdloop: so | less or > logfile are your best answers :)
16:17:32 <dcoutts_> hashcat: why is that?
16:17:58 <geekosaur> you feel the need to announce this why?
16:18:38 <hashcat> dcoutts_: It's useless for real job
16:18:57 <glguy> Yeah, Twitter is where you are supposed to put messages that you have no one in particular to tell
16:19:13 <dcoutts_> hashcat: you had some particular bad experience?
16:19:26 <Maior> glguy: I tell /dev/null
16:19:38 <blochchain> is there any known justification for why Haskell uses = and == instead of <- and = ?
16:19:52 <hashcat> dcoutts_: not really, but I have great experience with scala
16:20:11 <Hari`> Has anyone here used Yesod and then tested your code with some test suites, etc?
16:20:12 <dcoutts_> blochchain: = is real mathematical equality
16:20:22 <Maior> Hari`: #yesod people might have...
16:20:24 <Hafydd> blochchain: and what would you propose for <-'s current meaning?
16:20:39 <Hari`> yesod people are pretty quiet...
16:20:50 <Hari`> whereas you guys are young and restless
16:20:54 <Hari`> :)
16:21:28 <blochchain> sorry, my internet cut out. did anyone answer my question?
16:21:34 <Hafydd> blochchain: and what would you propose for <-'s current meaning?
16:21:34 <hashcat> dcoutts_: I can quickly start a web app with Play, a grid computing with JCGRID
16:21:59 <dcoutts_> blochchain: == is typical for equality testing
16:22:08 <hashcat> dcoutts_: Hackage has a lot of craps
16:22:26 <dcoutts_> hashcat: sure, any large collection like it does, see cpan etc
16:22:47 <dcoutts_> blochchain: a reason Haskell uses = for definitions, is because it does correspond to proper mathematical quality
16:23:01 <blochchain> Hafydd, because it's more accurate mathematical notation and Haskell seems to be big on proper mathematical notation
16:23:24 <Hafydd> I'm not sure what difference you think there is between the equivalence relation arising from an Eq instance and "mathematical" equality.
16:24:07 <dcoutts_> Hafydd: it's a pretty significant difference
16:24:15 <Hafydd> Maybe you mean equal in terms of Haskell's semantics.
16:24:27 <nstdloop> ok I logged the error to a txt file
16:24:30 <nstdloop> It's 4000 lines
16:24:34 <nstdloop> ...
16:24:41 <dcoutts_> Hafydd: yes
16:25:00 <glguy> In Haskell a=b means that you can replace a with b, they're the same thing. a==b doesn't mean that, it asks if they are equal. It doesn't declare them to be equal
16:25:44 <dcoutts_> and it's an unenforced convention that == follows the expected rules
16:25:46 <nstdloop> Yes, basically == is a question and = is a statement. Using = as a question would not make mathematical sense, that is never what it means.
16:25:47 <Hafydd> blochchain: that didn't answer my question. I was asking for a concrete suggestion.
16:26:34 <Maxdamantus> = as a question makes mathematical sense.
16:26:39 <hashcat_> I have to admit that I also make a crap in hackage -.-
16:26:39 <blochchain> oh, right Hafydd. i don't know its current meaning or i forget it
16:26:45 <Hafydd> It's also an unenforced convention that = follows the expected rules.
16:26:55 <elliott> if anything, = should be comparison and := definition or such.
16:26:56 <Hafydd> (e.g. unsafePerformIO)
16:26:59 <Maxdamantus> fac(x) = { 1 if x = 0; x*fac(x - 1) otherwise }
16:27:04 <Maxdamantus> Fairly standard mathematical notation.
16:27:17 <nstdloop> Yes, you are SAYING that the left side is the same as the right
16:27:20 <nstdloop> you aren't ASKING if it
16:27:20 <elliott> ideally, (x = y) represents the proposition that x and y are equal, of course; this dream is realised in Coq etc.
16:27:20 <nstdloop> is
16:27:30 <elliott> nstdloop: "if x = 0"
16:27:34 <Maxdamantus> but Haskell has to make a distinction, so it adds another syntactic element.
16:27:54 <dcoutts_> there's a level distinction, == is a thing inside the logic, = is a meta-level thing
16:28:01 <geekosaur> <Henzell> epic bugs[1/10]: if (you.religion = GOD_XOM)
16:28:16 <nstdloop> Can someone help me with this cabal thing
16:28:20 <nstdloop> I logged the error
16:28:26 <nstdloop> But it's 4000 lines long
16:28:28 <dcoutts_> normal mathematical notation may use = for both, but if you were doing logic, you'd use different symbols
16:28:29 <nstdloop> I don't know how helpful that is
16:28:31 <Maxdamantus> dcoutts_: that distinction isn't normally made in mathematical notation.
16:28:31 <Hafydd> blochchain: it's used in do notation to bind a variable.
16:28:40 <nstdloop> douctts_ I agree
16:28:41 <dcoutts_> Maxdamantus: it is in formal logic
16:28:45 * elliott nods approvingly in dcoutts_'s direction
16:29:01 <jfischoff> mathematicans abused notation all over the place
16:29:13 <jfischoff> s/abused/abuse
16:29:25 <argiopeweb> nstdloop: http://lpaste.net/ ?
16:29:38 <Hafydd> (a pattern)
16:30:43 <nstdloop> argiopeweb http://pastebin.com/iK3tgBZG
16:30:53 <nstdloop> It's a bajillion lines
16:30:57 <mauke> The paste iK3tgBZG has been copied to http://lpaste.net/93064
16:31:08 <Maxdamantus> dcoutts_: probably depends on the system of formal logic.
16:31:10 <dcoutts_> nstdloop: it's not necessary to use -v3 probably
16:31:15 <dcoutts_> Maxdamantus: sure
16:31:22 <Maxdamantus> dcoutts_: in some model for formal logic, maybe.
16:31:35 <Maxdamantus> dcoutts_: but in mathematical notation itself, you just say things that should be true.
16:31:42 <nstdloop> dcoutts_ what does that mean? I just included stdout and stderr
16:31:47 <Maxdamantus> dcoutts_: if `a = b` should be true, you can say that.
16:32:12 * monochrom disagrees with "two ='s in formal logic"
16:33:12 <dcoutts_> monochrom: or you'd have some other notation to make it really clear when you're writing terms in your logic, or talking about terms
16:33:32 <Maxdamantus> if Haskell more closely followed mathematical notation semantics, you'd be able to say something like: `a :: Bool; a`
16:33:35 <nstdloop> Like having two ='s instead of one...
16:33:40 <Maxdamantus> rather than `a :: Bool; a = true`
16:33:46 <Maxdamantus> True*
16:34:02 <monochrom> ok, that one I agree, but it's more than two ='s. it's two ='s, two ∧'s, two ∨'s, etc etc
16:34:10 <dcoutts_> Maxdamantus: no, again that'd be getting the levels confused
16:34:11 <elliott> Maxdamantus: conflating booleans and propositions is not very nice from a mathematical perspective.
16:34:18 <elliott> especially in a constructive setting, which Haskell is.
16:34:57 <Maxdamantus> elliott: but that's what happens in mathematical notation.
16:35:16 <monochrom> haha, today we have so many off-topic debates, don't we?
16:35:38 <Maxdamantus> Questions and statements have the same form.
16:36:14 <elliott> I disagree that what you said implies what I said is wrong, but this argument is pointless.
16:36:28 <monochrom> @quote monochrom debates
16:36:28 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
16:36:38 <nstdloop> Maxdamantus because you can tell the difference, a computer can't (for the most part).
16:37:20 <Maxdamantus> Yeah, conflating booleans and propositions (which Haskell doesn't do) might not be very nice. But it happens in usual (formal) mathematical notation.
16:37:39 <nstdloop> Back to the important stuff (haha), my Cabal isn't working. If anyone could help me out I would seriously appreciate it.
16:37:40 <monochrom> a computer can. here is how. a statement with a complete proof is a theorem. a statement with an incomplete proof is a question.
16:37:53 <nstdloop> Here's my error when I run cabal install cabal-install
16:37:54 <nstdloop> http://pastebin.com/iK3tgBZG
16:37:54 <mauke> The paste iK3tgBZG has been copied to http://lpaste.net/93064
16:37:57 <niteria> it'd be nice if there was another kind of lazy evaluation, one that forces thunks whenever runtime is bored, hoping to reduce memory usage
16:38:17 <hashcat> go to idris, agda or metamath if you want math notation
16:38:23 <monochrom> or increase memory usage? you never know
16:38:30 <Hafydd> [1..]
16:38:35 <Hafydd> Force that thunk,
16:38:41 <dcoutts_> niteria: see the papers on optimistic evaluation
16:38:51 <argiopeweb> Forcing, stand by...
16:38:53 <monochrom> const True (foldl (+) 0 [1..100]) increases memory usage
16:39:14 <niteria> yeah, I guess it's halting problem all the way down
16:39:31 <dcoutts_> nstdloop: ooohh, it looks like you have gcc = clang
16:39:33 <niteria> but some heuristics would be nice
16:39:40 <monochrom> I guess you can use a conservative heuristic. it helps.
16:39:41 <dcoutts_> nstdloop: so the cpp is screwed up
16:39:57 <nstdloop> The only acronym I am familiar with of those three is gcc
16:40:10 <nstdloop> What does that mean?
16:40:13 <dcoutts_> nstdloop: what platform are you on?
16:40:18 <nstdloop> OS X
16:40:33 <nstdloop> I installed gcc using xcode CL tools
16:40:36 <dcoutts_> latest version using clang I suppose
16:40:44 <argiopeweb> 3.2svn
16:40:54 <nstdloop> I guess? I don't know.
16:41:06 <glguy> I did a bootstrap.sh of cabal-install today on OS X with all the latest xcode and ghc-7.6.3
16:41:14 <Hafydd> clang stands for Compiler, Luckily Also Not GCC.
16:41:21 <glguy> it's not a general os x issue, it's a nstdloop's environment issue
16:41:51 <dcoutts_> I thought people had only just got ghc to work with clang's cpp
16:41:56 * dcoutts_ disappears
16:42:06 <niteria> "We have implemented optimistic evaluation in the Glasgow Haskell Compiler. The results are encouraging: many programs speed up significantly (5-25%), some are dramatically faster, and very few go slower." I don't think it's in the official version, is it?
16:42:13 <nstdloop> I've been running and compiling haskell fine
16:42:33 <nstdloop> I just tried to install the vector-algorithms package
16:42:36 <nstdloop> and everything broke
16:44:16 <monochrom> I am not quite happy when people say "laziness causes memory leaks" etc. It seems that people use algorithms designed for eagerness, therefore they mismatch with laziness, that's the cause of memory leaks. Rather than designing algorithms for laziness, they declare war on laziness.
16:44:21 <argiopeweb> nstdloop: `ghc-pkg check`?
16:44:33 <Maior> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful is a fun read
16:44:37 <Maior> I like the point about >>
16:44:37 <hashcat> another crap..
16:44:44 <nstdloop> Warning: haddock-interfaces: /Library/Haskell/ghc-7.6.3/lib/haskell-platform-2013.2.0.0/doc/html/haskell-platform.haddock doesn't exist or isn't a file
16:44:45 <nstdloop> Warning: haddock-html: /Library/Haskell/ghc-7.6.3/lib/haskell-platform-2013.2.0.0/doc/html doesn't exist or isn't a directory
16:45:02 <nstdloop> argiopeweb ^
16:45:03 <hashcat> I mean that package
16:46:33 <argiopeweb> nstdloop: Yeah, I'm bowing out on this one. I recommend the country doctor advice, "If it hurts to do that, don't do it".
16:46:38 <sm> nstdloop: I could be wrong, but it seems unlikely installing vector-algorithms broke your installation. More likely you upgraded your osx system or dev tools somehow ?
16:47:16 <nstdloop> It didn't break it, I just noticed it was broken.
16:47:22 <nstdloop> Like everything else works fine
16:47:28 <nstdloop> just installing packages doesn't work
16:47:45 <monochrom> if those warnings are the only messages of "ghc-pkg check", you can ignore them.
16:48:00 <argiopeweb> nstdloop: You could always download the newest version of cabal's code and run bootstrap.sh.
16:48:11 <argiopeweb> cabal-install, even.
16:48:23 <glguy> I had to delete all of my packages that were installed with cabal 1.16 once I installed the new cabal/cabal-install
16:48:30 <glguy> new cabal-install couldn't install over existing versions
16:48:40 <glguy> ghc would keep using the old one
16:49:11 <monochrom> that sounds strange
16:49:18 <niteria> monochrom: laziness is not a local property, you can understand laziness, but if the library author didn't you're out of luck
16:49:21 <acowley> I upgrade my cabal and cabal-install without cleaning house
16:49:22 <glguy> (e.g. dependency changed causing a need to reinstall the same version of a package after bumping the dependency)
16:49:33 <glguy> acowley: Usually that works for me, too
16:50:08 <sm> nstdloop: so you installed with haskell platform, and you've never successfully installed something with cabal since ?
16:50:20 <acowley> glguy: I will admit I've been doing more in sandboxes lately, so my 16 -> 18 transition may have issues I just haven't discovered yet. I did have trouble with packages previously configured by older cabal-installs.
16:50:23 <nstdloop> Basically yes
16:50:32 <nstdloop> I installed from the big haskell package
16:50:42 <nstdloop> have been learning haskell/writing some small programs
16:50:47 <nstdloop> everything works fine but I wanted a really fast sort
16:50:56 <nstdloop> So I tried downloading some packages
16:51:03 <nstdloop> and things don't work
16:51:26 <Maior> so I don't really understand when I might want to use Reader
16:51:44 <Maior> (currently working through examples at http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html)
16:52:10 <sm> nstdloop: which version of osx are you on ?
16:52:12 <monochrom> ReaderT may be more useful
16:52:22 <nstdloop> sm 10.8.4
16:52:38 <monochrom> at the end, if you find neither useful, don't worry about it
16:53:14 <Maior> monochrom: that does look a little more useful
16:53:32 <sm> nstdloop: did you install xcode or command line tools for xcode as part of HP installation ? or did you already have xcode installed ?
16:53:36 <Maior> but yeah, still not seeing obvious usecase
16:53:40 <Maior> ok, cheers
16:53:41 <nstdloop> I already had that
16:53:50 <nstdloop> I wrote some small programs in c in the past just to get myself familiar
16:53:55 <argiopeweb> Maior: I generally just see it as a nice way to not pass a read-only variable.
16:54:05 <nstdloop> so my gcc def. works
16:54:09 <argiopeweb> explicitly pass, even.
16:54:17 <Maior> argiopeweb: but, functions are pure, so everything's read-only...
16:54:18 <monochrom> guess what? I have written a few Haskell programs in daily use, and I still haven't used lens.
16:54:44 <monochrom> it is not a requirement that every hot-topic library must be useful to me
16:54:58 <sm> nstdloop: it might be that your xcode is too new for haskell/cabal to deal with. I wonder if installing the "Command Line Tools for Xcode." mentioned http://www.haskell.org/platform/mac.html could help
16:55:33 <argiopeweb> Maior: This is true, but (particularly for recursive functions) sometimes you end up passing the same thing around a lot without changing it.
16:55:34 <glguy> The lastest os x 10.8.5 and xcode command line tools are fine for ghc 7.6.3
16:55:39 <nstdloop> Says 4.3 or late
16:55:42 <Maior> monochrom: well sure, but I keep seeing Reader come up...
16:55:50 <Maior> argiopeweb: mmm, ok
16:55:59 <sm> glguy: dcoutts said nstdloop was using gcc = clang
16:56:00 <argiopeweb> `go :: Settings -> Int -> ()` `go s i = go s (pred i)`
16:56:09 <sm> before he vanished in a puff of smoke
16:57:13 <nstdloop> sm haha
16:57:14 <monochrom> or a puff of logic :)
16:57:30 <nstdloop> sm is there a way I can verify that?
16:57:36 <nstdloop> or fix it
16:57:40 <nstdloop> or both
16:57:40 <glguy> sm: well, if he changes his settings he'll have ot tell us
16:57:52 <Guest45018> if I use recursion with the state monad, with a function "f" that ends with "rest <- f; return (something ++ rest)", will this be tail recursive?
16:57:56 <sm> nstdloop: I don't know, if I were in your shoes I'd try the steps at http://www.haskell.org/platform/mac.html next
16:58:17 <nstdloop> sm that's how I installed already.
16:58:19 <scshunt> Guest45018: try writing it out in monadic notation
16:58:22 <sm> ok :/
16:58:28 <scshunt> rather than do notation
16:58:31 <nstdloop> Ya this is kind of annoying.
16:58:41 <nstdloop> Any ideas on how I can do a reinstall of cabal alone?
16:58:54 <nstdloop> or a manual update
16:59:00 <sm> then, I would search the interweb for some characteristic part of your error message. It seems unlikely you're the first to hit this
16:59:19 <nstdloop> I don't even know where to look. The thing is four THOUSAND lines long.
16:59:34 <Guest45018> scshunt: let me try, one sec
16:59:47 <nstdloop> Just gives ExitFailure 1
16:59:51 <nstdloop> which is apparently super generic
17:00:08 <ReinH> Ok, I'm not sure why I can't figure this out :/
17:00:46 <sm> nstdloop: this search's first result seems helpful: https://www.google.com/search?q=%22warning%3A+missing+terminating+%27+character+[-Winvalid-pp-token]%22&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a&channel=fflb#channel=fflb&q=%22warning%3A+missing+terminating+%27+character+[-Winvalid-pp-token]%22+osx+cabal+install&rls=org.mozilla:en-US%3Aofficial
17:00:54 <haasn> Guest45018: a more interesting question would be “why do you want to know”?
17:01:54 <Guest45018> haasn- I just changed over to the state monad (instead of directly passing a stack around), but in this form it didn't look tail recursive, I was worried about performance.
17:01:58 <user123abc> can I use cabal to fetch the sources of a package and its dependent packages?
17:02:00 <ReinH> I want to update an STArray using a list of indexes. How do I iterate over the indexes inside runSTArray and do readArray and writeArray as necessary for each coordinate?
17:02:38 <ReinH> let's say I have a function mutate ixs arr = runSTArray $ do ...
17:02:48 <ReinH> I'm assuming I need some version of mapM or traverse here?
17:03:09 <Guest45018> haasn: If the last line was just a call to the function itself, it would appear to be, but I need to prefix the result, and needed to add a return.
17:03:42 <haasn> Ah, so the question is “you're worried about performance”. Have you benchmarked it, as compared with the non-recursive version?
17:04:04 <haasn> Whether or not it's ‘tail recursive’ seems irrelevant
17:04:34 <monochrom> Guest45018: it looks to me, inefficiency will come not from which kind of recursion you use, but more simply from ((s0++rest0)++rest1)++rest2...  that is a recipe for building a list that costs you quadratic time to traverse later, and it doesn't matter what recursion you used to build it.
17:05:08 <nstdloop> sm ok I'm trying his "interim fix"
17:05:10 <Guest45018> haasn- I haven't, but don't non tail recursive funct's keep a full call stack?
17:05:14 <nstdloop> to try and get 1.18
17:05:19 <nstdloop> which will hopefully fix it
17:05:33 <Guest45018> monochrom: what is a better alternative?
17:05:47 <geekosaur> Guest45018, call stack approaches meaningless in Haskell
17:06:27 <geekosaur> it's significant with strict evaluation, but Haskell evaluation is very different
17:06:45 <pqmodn> Guest45018: s0 ++ (rest0++(rest1++(rest2++...)))
17:07:11 <sm> nstdloop: you were installing Cabal 1.18
17:07:12 <Guest45018> geekosaur- I am not sure what to call it, but doesn't tail recursion throw away the info on the fly, where as non tail recursion keep all the info until the internal stuff is created?
17:07:37 <nstdloop> sm I was running cabal install cabal-install to update
17:07:50 <sm> oh right, I see
17:07:59 <geekosaur> Guest45018, you are trying to find a name for something that is not relevant to Haskell evaluation
17:08:12 <geekosaur> not "different name", but *not relevant*
17:08:17 <nstdloop> Guest45018 Haskell is lazy, so unless you tell it to be strict it won't care or behave differently in different cases of recursion
17:08:21 <sm> the quickest way might be to install cabal-install 0.18 directly using its bootstrap.sh
17:08:32 <nstdloop> sm If this doesn't work I'm trying that
17:08:34 <sm> anyway good luck
17:08:43 <sm> don't break your system 8-)
17:10:09 <hashcat> also, try cabal-uninstall and hsenv
17:10:15 <nstdloop> sm Thanks for your help
17:10:24 <johnw> spaceships: what was the question?
17:10:26 <Guest45018> I guess I am confused....  Let me start with something simple.  If I want to change all of the 'q's in a string to "puppy", would a good match case be....    f ('q':rest) = "puppy" ++ f rest?
17:10:42 <Guest45018> Or what would be better?
17:11:11 <haasn> concatMap (\case 'q' -> "puppy"; c -> return c) -- would be my first approach :)
17:11:12 <monochrom> that is the best
17:11:24 <geekosaur> heh
17:11:34 <hashcat> the best is nothing.
17:11:42 <nstdloop> Yes haasn is right
17:12:13 <monochrom> and I mean: f ('q':rest) = "puppy" ++ f rest is the best
17:12:14 <Guest45018> haasn- Your way is cleaner than mine, but would the performance differ?
17:12:20 <acowley> Apparently I'm adding things: F.sum . F.sum . V.sum <$> summer
17:12:38 <haasn> Guest45018: Modulo some constant factor, “no”
17:12:49 <haasn> Guest45018: keep in mind that haskell is pure, you're not mutating anything, you're returning a new data structure
17:13:00 <haasn> so whether or not you ‘recurse’ elegantly or not doesn't matter, you're returning new constructors one way or the other
17:14:38 <hashcat> Should Haskell have dependent type in the future?
17:14:41 <nstdloop> Guest45018 There are cases where you CAN force haskell to be strict and gain significant memory boosts in tail end recursion, but if you don't explicitly set it up that way your work will be for naught.
17:15:19 <monochrom> Guest45018: I misread. you build s0++(rest0++(rest1++...  it is fine there
17:15:24 <shachaf> win . win . win <$> winter
17:15:43 <argiopeweb> fall . fall . fall . <$> fall?
17:16:07 <argiopeweb> Well, guess I broke the 3 character mold... I'll go away now.
17:16:30 <Guest45018> I think most of you are saying that the ++ is OK (performance wise) to use....
17:16:44 <monochrom> I don't think you should worry but tail vs non-tail recursion for the specific case of Control.Monad.State. you will regret that you worry. I'll tell you why, so you will regret that you even hear about it
17:16:58 <haasn> ala Endo foldMap (replicate 3 win) winter
17:18:12 <Guest45018> monochrom- I guess I read somewhere that non-tail recursive stuff can become reaaaaaally slow for large inputs, I just want to make sure I don't fall into that trap.
17:18:45 <monochrom> Control.Monad.State = Control.Monad.State.Lazy. its control flow is unusual. the simple dichotomy of "tail", "non-tail" does not even begin to fathom it.
17:18:57 <geekosaur> Guest45018, yes, and it's important in strict languages
17:18:58 <ReinH> Guest45018: (++) is expensive.
17:19:14 <monochrom> tail recursive stuff can become really slow too
17:19:22 <Guest45018> monochrom- I mean, it makes sense....  Tail recursion allows you to throw out all memory used in the computation, it actually compiles as a loop.
17:19:24 <monochrom> all programming can be really slow
17:19:40 <hashcat> Guest45018: why not bytestring or text
17:19:48 <ReinH> ...tail call elimination is a space optimization
17:19:59 <haasn> (++) is “expensive” if you use it incorrectly
17:20:27 <Guest45018> ReinH- I think you can't avoid it sometimes....  In my example you can always write 'p':u':'p':'p':'y':rest, but what if puppy is a variable?
17:20:40 <monochrom> Control.Monad.State.Lazy examples: http://lpaste.net/41790/
17:21:01 <red> does peyton-jones hang out here? and tell funny anecdotes?
17:21:14 <ReinH> Guest45018: you can use a more efficient data structure
17:21:15 <monochrom> unfortunately no
17:21:23 <Guest45018> ReinH- But space optimization becomes time optimazation (ever run your computer out of memory?)
17:22:15 <hashcat> I remember hackage has noted time and space complexity
17:22:18 <ReinH> Guest45018: it's still inaccurate to call tail call elimination a time optimization
17:22:53 <Guest45018> RainH- I would also use another data structure, but I was just focusing on one point for this discussion (ie- tail recursion)
17:23:00 <monochrom> I am done arguing against conventional wisdom and "I read somewhere"
17:23:19 <Guest45018> ReinH- point taken
17:23:26 <monochrom> my wisdom is truer than both conventional wisdom and what other puny people write
17:23:36 <ReinH> monochrom: :p
17:24:14 <ReinH> Guest45018: Haskell's evaluation model is different enough to make most received wisdom from imperative langauges inapplicable
17:24:15 <monochrom> and I show actual code examples that you can test and see for yourself.
17:24:16 <geekosaur> Guest45018, so it sounds like you read something somewhere, are not actually sure why it matters, but still insist on applying it to something where it is irrelevant
17:24:22 <Hafydd> I wouldn't call LCE an "optimisation" in the case of functional programming.
17:24:27 <ReinH> Guest45018: so be careful when you say "well in X langauge I would need tail call recursion here"
17:24:49 <ReinH> Guest45018: because in Haskell you have very different evaluation semantics
17:24:54 <ReinH> and it's best to approach them on their own terms
17:25:28 <Guest45018> ReinH and geeosaur- are you guys saying that tail recursion isn't something to be worried about in Haskell?
17:25:39 <ReinH> Guest45018: that is one of the first things we said, actually :)
17:25:46 <geekosaur> yep
17:25:50 <Guest45018> Oh
17:26:22 <geekosaur> in fact, the more correct statement would be that, because Haskell does nto evaluate things the way strict languages do, trying to apply tail call "optimization" is often a pessimization instead
17:26:26 <ReinH> Guest45018: for instance, TCR is about call stack optimization, right?
17:26:59 <ReinH> Guest45018: specifically, TCR elimination uses a jump instead of creating a new frame
17:27:13 <ReinH> Guest45018: so it might interest you to know that Haskell does not have a call stack.
17:27:49 <Guest45018> Hmmm.... my mind is twisting as I process this new info....
17:28:04 <ReinH> Guest45018: so you can see why conventional wisdom about TCR might not apply :)
17:28:15 <geekosaur> non-strict evaluation is very, very different
17:28:25 <ReinH> Guest45018: that's not to say that Haskell can't stack overflow. It just does it in different ways than what you are used to. Check out http://www.haskell.org/haskellwiki/Stack_overflow
17:28:50 <Guest45018> The kernel of understanding is forming, but I will probably have to sleep on it to really get it.
17:29:12 <geekosaur> a lot of stuff you "know" from strict languages is wrong in non-strict languages, and can mislead you into hard-to-diagnose and harder to untangle problems
17:29:27 <ReinH> Guest45018: and this might give you a bit more insight into why tail recursion isn't as important in Haskell http://www.haskell.org/haskellwiki/Tail_recursion
17:29:44 <juhp> what is up (down?) with hayoo?
17:29:52 <geekosaur> I wish I knew :/
17:30:16 <jmcarthur> (ghc sort of has a call stack. it's just that the stack frames are for thunks rather than haskell functions.)
17:30:32 <ReinH> jmcarthur: well, it has a stack.
17:30:38 <acowley> Hey jmcarthur, did you ever do anything with the distance transform code?
17:30:46 <ReinH> I thought it best to be clear that this stack is not what you would normally think of as a call stack :)
17:30:47 <jmcarthur> acowley: not yet, but i still intend to
17:30:53 <jmcarthur> acowley: it may be a while before i get to it
17:30:56 <ReinH> Now, who can help me with a stupid STArray question
17:30:59 <Guest45018> Well, let me read that and contemplate what you have all said....  Thanks for the mind expanding discussion....  If I still am confused tomorrow, will let you know :)
17:31:00 <acowley> k, I had forgotten about it then saw ReinH talking about his code again today
17:31:08 <ReinH> acowley: :p
17:31:14 <geekosaur> you will probably be confused for more than just tomorrow :)
17:31:28 <geekosaur> just go with it and you'll start to develop the intuitions you need
17:31:30 <acowley> ReinH: The "S" doesn't stand for "stupid"
17:31:37 <ReinH> Guest45018: don't fight the confusion. Let it wash over you like the sea.
17:31:46 <jmcarthur> acowley: i plan to use it for rendering text and perhaps other decal-like images
17:31:47 <ReinH> acowley: the monad is not the stupid party here.
17:31:50 <acowley> Yes, in #haskell we breath confusion
17:32:21 <Guest45018> geekosaur- I am sure....  I thought I was the master of the computer when I was learning languages left and right, then I tried out Haskell, been at it for at least a year and still feel like a newbie.
17:32:25 <jmcarthur> acowley: well, as a preprocessing step for the rendering, at least
17:32:33 * acowley flexes his confusion gills
17:32:42 <ReinH> Let's say I have an IArray and a list of coords. I want to write something to each coord by doing something like this:
17:32:51 <geekosaur> Guest45018, I spent a couple years trying to igure it out, what ultimately helped me was getting involved with xmonad
17:33:01 <geekosaur> actually working with it to solve real problems helps a lot
17:33:13 <ReinH> updateAry arr ixs val = runSTArray $ do arr' <- unsafeThaw arr ...
17:33:32 <Guest45018> geekosaur- I am actually doing a project with it right now....  Has helped a lot!
17:33:33 <ReinH> how do I iterate over ixs and writeArray arr' ix val for each?
17:34:05 <acowley> mapM_?
17:34:08 <ReinH> (Yes, I know about //, what I want to do is more complicated)
17:34:12 <Guest45018> geekosaur- I now understand monads (well, a lot better than before)
17:34:13 <acowley> what's hte type of ixs?
17:34:23 <ReinH> acowley: that's what I was assuming. I can make it typecheck but I can't make it actually update the array o_O
17:34:48 <ReinH> acowley: let's just say Ix i => [i]
17:35:03 <acowley> ReinH: can you keep the whole thing in ST so we don't have to keep one eye on the unsafe parts?
17:35:10 <ReinH> it's actually a Vector (V2 Int) and my array is an IArray (V2 Int), bvut but that's immaterial
17:35:13 <ReinH> acowley: sure
17:35:38 <ReinH> I will just need to swap Data.Vector.mapM_ for mapM_
17:35:54 <acowley> ReinH: Maybe boil this down into a standalone STArray test to confirm for yourself how things are working?
17:35:59 <acowley> That's what I usually do
17:36:23 <ReinH> acowley: hmm
17:36:37 <ReinH> acowley: you do some STArray stuff in your distance transform package right?
17:36:50 <acowley> ReinH: I use mutable vectors
17:36:53 <ReinH> ah
17:36:57 <ReinH> what's the link again?
17:37:02 <ReinH> I might still glean something of use
17:37:18 <zRecursive> Can i call a function if Foo.hs from ghc command line ?
17:37:27 <zRecursive> s/if/in
17:37:34 <acowley> ?hackage DistanceTransform
17:37:35 <lambdabot> http://hackage.haskell.org/package/DistanceTransform
17:38:18 <elifrey> zRecursize: ghci Foo.hs should load Foo.hs into the toplevel namespace
17:40:08 <zRecursive> elifrey: can ghci automatically quit after evaluation ?
17:40:55 <elifrey> zRecursive: you want something like *imagines* ghci -e 'foo x' Foo.hs?
17:40:57 <ReinH> acowley: I mean, I know how to do it the sequence [writeArray arr x val | x <- xs ] way, but for some reason I can't manually translate that to mapM_ or forM_
17:41:14 <ReinH> even thought I know how they are defined in terms of sequence.
17:41:16 <ReinH> I am stupid.
17:41:20 <ReinH> *though
17:41:21 <acowley> mapM_ (flip (writeArray arr) val) xs
17:41:26 <elifrey> zRecursive: what do you know, -e does work
17:41:43 <geekosaur> huh
17:41:57 <zRecursive> elifrey: yeah, i just want to show user the function result
17:43:57 <elifrey> zRecursive: blast, I can't get -e to work with a file on the command line
17:44:17 <zRecursive> => ghc: on the commandline: cannot use `--interactive' with `-e'
17:44:42 <elifrey> zRecursive: oh
17:44:47 <elifrey> just use ghc not ghci
17:44:57 <elifrey> ghc -e 'expr' MyModule.hs
17:45:23 <zRecursive> elifrey: thx
17:46:37 <ReinH> acowley: so the version that works looks exactly like what I did before.
17:46:39 <ReinH> acowley: except it works.
17:46:41 <ReinH> sigh
17:47:03 <acowley> You had a bug in your whitespace
17:47:04 <acowley> :P
17:47:09 <ReinH> probably
17:47:48 <zRecursive> `ghc -e 'expr' MyModule.hs` is much slower than OCaml, why ?
17:49:25 <elifrey> zRecursive: slower how?  what are you compairing? startup time, execution of code?
17:49:31 <argiopeweb> zRecursive: That's a very vague question. There's a small world of things that could be slowing you down.
17:50:07 <zRecursive> just `time ghc -e 'funcX' TestMod.hs`
17:51:28 <geekosaur> ghc is interpreting the source file, not compiling it, and the interpreter has no optimization whatsoever
17:51:32 <argiopeweb> I'd start with the fact that you're interpreting (via -e) a compiled language. That's a big slowdown there.
17:52:14 <zRecursive> OCaml is still a compiled language,isnot it ?
17:52:35 <argiopeweb> zRecursive: Have you tried putting `main = print funcX` and compiling/running?
17:52:53 <argiopeweb> zRecursive: It can be. Are you comparing the interpreters?
17:53:18 * geekosaur has no idea what if any interpretation or optimization ocaml has
17:53:28 <argiopeweb> Because there's still a small world of things that could be different there.
17:53:44 <elifrey> zRecursive: strict evaluation is much more amenable to fast interpretation than lazy.  GHC does many really neat optimizations when it compiles.  I've heard code-gen is dwarfs type-checking for compile time in haskell.
17:54:07 <zRecursive> argiopeweb: no, just show user the function result in command line
17:55:00 <argiopeweb> zRecursive: In that case, I yield the floor to elifrey.
17:55:04 <elifrey> zRecursive: whereas OCaml is netoriously "straightforward" in it's compilation model
17:55:34 <zRecursive> ok, maybe we can compile TestMod.hs first
17:55:39 <geekosaur> anyway, because we generally use ghci for testing or debugging, and speed generally doesn't matter, very little effort has been put into making ghci fast
17:56:02 <geekosaur> It *could* be done, but I imagine there's a lot of possible and even likely simple optimization that just isn't done
17:57:09 * elifrey is just speculating
17:57:24 <argiopeweb> geekosaur: I'd much prefer it not be done. I'll take a few slow evaluations over a constant performance hit every time.
17:58:05 <geekosaur> I will note it can also be helpful for figuring out if you've found a case where an optimization turns out to not be an optimization for your use case
17:58:41 <geekosaur> (there are a number of options to ghc to turn off things that are normally optimizations but sometimes play very badly, notably -fno-state-hack)
17:58:45 <argiopeweb> I've actually not run into such a situation (knowingly)
17:59:52 <argiopeweb> Looking over the docs, I'd likely see it if I did more in ST.
18:00:54 <hpaste> flebron pasted “Can this be made to compile with a ghc --make?” at http://lpaste.net/93073
18:01:44 <flebron> I'm getting a stack overflow while compiling, which is reasonable. Is there any way to make that compile, without changing compiler flags (i.e. ghc --make)?
18:02:38 <zRecursive> Can i sometimes make ghc ignore ~/.ghci ?
18:03:25 <flebron> Sorry, client died.
18:03:46 <argiopeweb> flebron: No answers while you were gone, but I'd guess no. Not a TH expert though.
18:03:47 <elifrey> zRecursive: -ignore-dot-ghci
18:03:49 <flebron> (I'll take "Things your lawyer shouldn't say for $300", Alex.)
18:04:21 <zRecursive> elifrey: big help, thx
18:05:54 <argiopeweb> flebron: Though there may be a better solution to your problem than creating a string of 33 million '0's at compile time.
18:06:32 <flebron> argiopeweb: It's for a programming competition, I'm trying to see if I can use template haskell so that I output the very long thing I need to output, but incur no runtime processing time, only output time :)
18:07:13 <flebron> It also seems I can't use {-# OPTIONS_GHC +RTS -K100000000 #-}.
18:07:46 <argiopeweb> Clever, though I'd hope there's a compile time limit, or a compile meomory limit, or a "the clock starts now and you have till time T to compile and run" limit, or something.
18:07:46 <monochrom> flebron: "ghc +RTS -K500M -RTS --make". if you don't want to do that, use environment variable, export GHCRTS='-K500M'. either gives you 500MB stack
18:08:15 <flebron> monochrom: Unfortunately, I can't change those things. It's a programming competition, my code's compiled for me.
18:08:19 <argiopeweb> monochrom: I want to say he's compiling in a hostile environment (programming competition)
18:08:24 <flebron> (Or, in this case, against me ;))
18:08:33 <monochrom> that's too bad
18:09:10 <monochrom> wait for the future, stack default limit will be raised or lifted
18:10:03 <monochrom> because, afterall, guess what, GHC RTS stack is growable and steals from the heap anyway!
18:10:03 <flebron> Why can't I do OPTIONS_GHC +RTS -K500M though?
18:10:09 <Saizan> flebron: tried $(stringL (replicate 33333333 '0')) ?
18:10:25 <monochrom> I think because it is not considered part of OPTIONS_GHC at all
18:10:44 <monochrom> it is part of RTS not GHC itself
18:10:46 <flebron> a.hs:4:7: Not in scope: `stringL'
18:10:52 <argiopeweb> flebron: You might be able to replicate and concat a longer string, though I won't even conjecture that that would help.
18:13:43 <cschneid> is anybody familiar with a library in haskell that is compatible with the ruby queue system resque? (redis backed background workers)
18:14:58 <YayMe`> ...F# is really damn annoying... I wish even suggesting Haskell wouldn't just alienate FP to my colleagues making it so I couldn't even use F#
18:15:02 <argiopeweb> flebron: Also, you may see performance benefits from setting a large buffer on stdout.
18:15:21 <flebron> argiopeweb: How is that done?
18:15:54 <argiopeweb> flebron: hSetBuffering from System.IO.
18:15:58 <flebron> Thanks :)
18:15:58 <YayMe`> F#, I hate you - You lack recursion; Crap! - F#, you bastard. - My haiku for the day...
18:16:01 <argiopeweb> flebron: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering
18:16:43 <argiopeweb> YayMe`: Okay, now I have to go look at F#... Even Fortran 77 had a dirty icky form of recursion.
18:18:26 <Hodapp> YayMe`: ...F# lacks recursion?
18:19:05 <josephle> surely you just use the rec construct like in OCaml...?
18:19:20 <argiopeweb> josephle: That seems to be what I'm seeing.
18:19:47 <argiopeweb> `let rec someFunction = ...`, from the wikibook.
18:23:08 <Hafydd> Even MS can't be that bumbling.
18:23:54 <josephle> MS just copied Ocaml, cut out the module system, and switched the object system for their own
18:24:06 <josephle> I'm not sure anything else was really touched in the process
18:27:43 <acowley> To my knowledge, F# has far better async support over multiple cores than OCaml
18:28:50 <copumpkin> O look, it's harrop in disguise
18:29:17 <acowley> hahaha
18:34:49 <jmcarthur> acowley: i don't know about F#, but OCaml does lack pretty much anything multicore.
18:35:56 <Hodapp> jmcarthur: I did not know that.
18:36:06 <acowley> jmcarthur: Yes, I'm just hedging against the day when they address that and it's no longer the most obvious knock against using the language :/
18:36:08 <Hodapp> jmcarthur: why is that? just never been written?
18:36:15 <elifrey> jmcarthur: The other day I was told you can do IO on ALL THE CORES, just not anything CPU bound
18:38:05 <thoughtpolice> elifrey: that is correct, yes
18:40:24 <jmcarthur> Hodapp: there have actually been arguments made that it would not be worth implementing because using different processes for each core is better anyway
18:40:37 <jmcarthur> Hodapp: i am not trying to say i agree with this...
18:41:22 <jmcarthur> elifrey: that is basically right. OCaml has threads, and each can be blocked on a syscall, but there is a global lock that means only one can use CPU at once
18:41:48 <jmcarthur> acowley: i doubt they will ever address it
18:42:20 <acowley> jmcarthur: Really? That seems to be fighting inevitability to a rather extreme extent
18:42:35 <jmcarthur> acowley: they are very conservative about big changes like that and probably will continue to fight the trend tooth and nail
18:42:49 <acowley> yeesh
18:43:00 <elifrey> acowley: nodejs fanboys seem to think multithreading is the devil
18:43:13 <elifrey> they're getting along pretty healthy
18:43:31 <jmcarthur> yeah all these callback library fans are poisoning our minds, too
18:43:49 <jmcarthur> "our" = "everybody's"
18:44:31 <acowley> In my particular Internet echo chamber, I hear nothing but critiques of those things, so I feel safe in my biases
18:44:33 <jmcarthur> it always surprises me how many people think threads are inherently complicated/inefficient/whatever
18:44:46 <elifrey> "if you just don't have any cuncurrent parallelism, you can keep using global variables and nothing bad ever happens!"
18:45:03 <jmcarthur> elifrey: :(
18:45:26 <jmcarthur> "if i never do anything interesting then it doesn't matter if my code is crazy by default"
18:46:12 <acowley> If we used Strings for everything, we could get rid of the Show type class. Seems legit.
18:47:02 <coburrito> acowley: The problem with Haskell, is that people use too many types. You really should choose just one and stick with it. I like how you think.
18:47:21 <user123abc> I'm dealing with types (Set and Vector) that have/(are?) instances of foldeable and functor
18:47:23 <elifrey> acowley: weakly typed dynamic languages might as well be stringly typed
18:47:31 <pqmodn> x * "10" = x ++ "0"
18:47:38 <josephle> Dynamic, the one type to rule them all
18:47:40 <user123abc> how can I exploit this to avoid "ambiguous instance of foldl" errors?
18:47:40 <johnw> user123abc: how is your Set an instance of Functor?
18:47:55 <user123abc> good point, the foldeable is the one I care about there
18:48:24 <acowley> johnw: Just unsafeCoerce it to a String then back again. Strings save the day!
18:48:36 <acowley> user123abc: import qualified Data.Foldable as F
18:48:48 <acowley> user123abc: alternately, import Prelude hiding (foldl)
18:48:55 <user123abc> thanks
18:55:55 <khyperia> @pl \x y z -> f $ g x y z
18:55:58 <lambdabot> (((f $) .) .) . g
18:55:58 <lambdabot> optimization suspended, use @pl-resume to continue.
18:56:04 <khyperia> ... oh dear
18:56:16 <khyperia> what have I done?
18:58:25 <Hafydd> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> f $ g a b c d e f g h i j k l m n o p q r s t u v w x y z
18:58:28 <lambdabot> ((((ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . ((flip . (ap .))
18:58:28 <lambdabot>  .)) .)) .)) .) . ((((flip .) .) .) .) . (((flip .) .) .) . ((flip .) .) . (flip .) . flip . flip id
18:58:28 <lambdabot> optimization suspended, use @pl-resume to continue.
18:58:49 <khyperia> although it appears to do this fine -
18:58:57 <khyperia> @pl \x y z -> f (g x y z)
18:58:57 <lambdabot> ((f .) .) . g
18:59:20 <Susy_40_Inglesa> hello
19:02:21 * dwcook can't imagine needing a function taking more than, like, five parameters
19:05:34 <applicative> dont people often end up with more than five fields in a record?
19:06:10 <dwcook> Even though you can't curry them (as directly), there's a point at which I think records are saner than more parameters
19:06:51 * Clint squints.
19:07:02 <dwcook> Wait, of course you can curry records. Their constructors are functions too
19:07:46 <dwcook> @pl \x y z -> (y, z, x)
19:07:46 <lambdabot> flip (flip . (,,))
19:09:07 <dwcook> Yeah, so, my statement was not exactly coherent I guess
19:10:23 <monochrom> sometimes, I have an algebraic data type consisting of 5 cases. the "fold" of that type therefore takes 6 parameters. at that point, of course, I would rather write explicit recursion than use its "fold" :)
19:10:55 <nstdloop> Hey guys
19:11:01 <nstdloop> If anyone remembers from earlier
19:11:03 <dwcook> I've been wondering, is there a way to derive the fold for an algebraic data type?
19:11:08 <dwcook> I guess with TH
19:11:09 <nstdloop> I'm having a problem with my cabal installation
19:11:16 <nstdloop> Because I have gcc = clange
19:11:18 <nstdloop> clang*
19:11:29 <monochrom> I think "Data.Generic" can, too
19:11:30 <nstdloop> So I get tons of warning for unbound ' characters whenever I try anything
19:11:47 <nstdloop> I solved the issue by messing around a lot with brew and reinstalling gcc, ghc, and cabal from brew
19:12:02 <nstdloop> but the problem is whenever I call cabal from the CL is still calls the old installation
19:12:11 <nstdloop> and I want it to use the new, 1.18 version
19:12:19 <nstdloop> How can I get rid of/disable the old one?
19:12:42 <monochrom> then, either you erased the new one, or you have to play with PATH
19:13:06 <monochrom> I don't know which is better :)
19:13:48 <monochrom> also, I don't know mac, I only know linux. my advice ends where their commonality ends
19:14:11 <dwcook> It sort of reminds me of how I wish there were a (a -> [a] -> b) -> b -> [a] -> b
19:14:35 <dwcook> (Note the subtle difference from foldr's signature)
19:14:36 <nstdloop> Ugh. This has been an exhausting experience. I've spent the last four hours rebuilding ghc and gcc from brew
19:14:40 <nstdloop> Took FOREVER.
19:15:43 <dagano> @quote mississipp
19:15:43 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
19:16:25 <nstdloop> Does anyone know of a nice way to get cabal to play nice with gcc = clang?
19:17:09 <dagano> what function adds elems to a list but doesn't add extras if they already exist?
19:18:01 <dagano> and how do I use @quote when looking for something someone said?
19:18:11 <dagano> soomanyquestions
19:18:17 <dwcook> \x xs -> nub (x:xs)
19:18:35 <dwcook> Wait no, that's wrong
19:18:40 <dwcook> Because that removes existing duplicates too
19:18:56 <dwcook> \x xs -> if x `elem` xs then xs else x:xs
19:19:50 <acowley> dagano: Don't use a list for that, use a Set!
19:19:53 <monochrom> Give a man a fire, and he is warm for a day. Show him how to build GHC, and he is warm for life. :)
19:20:25 <nstdloop> I wish I could learn how to use haskell before I had to learn how to build it
19:20:27 <dwcook> monochrom, because he'll want to set himself on fire after learning how?
19:20:33 <Hafydd> Hahah.
19:20:48 <monochrom> haha no, because the computer keeps him warm
19:21:20 <ReinH> acowley: guess how long my STArray version takes?
19:21:29 <acowley> -0.1s
19:21:38 <acowley> I'm terrible at this
19:21:40 <acowley> 2
19:21:45 <acowley> It takes 2!
19:21:52 <nstdloop> I feel like I am going to irreversibly screw something yp
19:21:54 <chirpsalot> acowley: 2 factorial?
19:21:56 <dagano> acowley: ok but i really want to use a list
19:22:13 <acowley> chirpsalot: I never know when to use 2 or 2 factorial
19:22:17 <ReinH> acowley: 8ms
19:22:31 <chirpsalot> acowley: I know! It's almost like the have the same value.
19:22:43 <nstdloop> If I just swap the cabal files currently in usr/local/bin... and usr/bin... will that work?
19:22:45 <acowley> dagano: But your accumulation operation is suited perfectly to a Set. You can toList it at the end.
19:22:50 <acowley> ReinH: That's awesome!
19:22:50 <monochrom> 8ms = 2joy, where 1joy = 4ms
19:22:51 <nstdloop> or will that just break everything?
19:23:08 <ReinH> acowley: yeah!
19:24:12 <dagano> @quote
19:24:12 <lambdabot> mstr says: haskell is like  f'gg'fggf'fg'g'fg'foldliftM2 f g ''f' :)
19:24:14 <monochrom> swapping files sounds like really high risk
19:24:22 <ReinH> acowley: and I realized that I can use a second array with the same shape filled with False as a checklist per Bird's pearl
19:24:36 <ReinH> acowley: and use that to keep track of which squares I need to revisit on the next run
19:24:52 <acowley> ReinH: Is that the Sudoku pearl?
19:25:09 <ReinH> acowley: no, chapter 1 of his functional pearls of algorithm design book
19:25:20 <dwcook> Functional Perl sounds nonetheless terrible
19:25:44 <spaceships> dwcook: that would be the book "Higher Order Perl" and it's quite all right
19:25:54 <ReinH> heh
19:26:08 <dwcook> Wow, that exists
19:26:29 <ReinH> acowley: I can also keep another piece of state for "was I able to update anything this run"
19:26:43 <dwcook> I almost feel like taking up Perl so I can explore this
19:26:49 <ReinH> acowley: rather than finding a fixed point via array equivalence
19:26:55 <acowley> ReinH: mutation, mutation everywhere!
19:27:01 <ReinH> acowley: yeah, I feel dirty!
19:27:08 <acowley> ReinH: The hard part with going down that road is keeping your sanity
19:27:16 <ReinH> acowley: I should be able to get down to ~4ms or so, I think
19:27:29 <acowley> ReinH: I tend to dig myself holes using the mutation shovel
19:27:35 <acowley> ReinH: That would be great
19:29:38 <nstdloop> Can somebody who like... knows this stuff help me?
19:29:46 <nstdloop> I am completely lost.
19:30:27 <carter> nstdloop: you're on a mac with xcode 5 right?
19:30:31 <nstdloop> Yes
19:30:38 <nstdloop> I have gcc = clang or something
19:30:42 <carter> github.com/darinmorrison
19:30:52 <carter> use his brew
19:30:53 <carter> https://github.com/darinmorrison/homebrew-haskell
19:30:59 <carter> it has a workaround
19:31:00 <dagano> if i import qualified Data.Set as S
19:31:05 <nstdloop> I already have like 3 layers of stuff installed
19:31:10 <nstdloop> do I need to do anything to it?
19:31:12 <dagano> what is my typedef? ie [Int] -> S
19:31:13 <dagano> ?
19:31:27 <carter> nstdloop: you could dl the 4.6 CLI tools and reinstall those
19:31:31 <carter> thats probably the fastest way
19:31:37 <carter> you ahve to DL and run that installer
19:31:41 <carter> not switch via xcode
19:31:57 <nstdloop> Ok. Is that going to cause any problems elsewhere?
19:32:09 <nstdloop> I already reinstalled gcc and ghc and cabal from brew
19:32:11 <monochrom> [Int] -> S.Set Int? anyway the set type is S.Set, but like Maybe, you have to say S.Set Int or S.Set Char or something
19:32:14 <nstdloop> after installing them all through the package
19:32:20 <ReinH> acowley: it's not too ugly either https://gist.github.com/reinh/8c5b077ef47933eb12fb
19:32:21 <acowley> Why not just use the available binary?
19:32:29 <acowley> I don't brew my own GHC
19:32:37 <nstdloop> Ya I did that
19:32:40 <nstdloop> but it doesn't work
19:32:44 <carter> nstdloop: don't use normal brew
19:32:45 <nstdloop> the cabal is broken when you have clang
19:32:49 <carter> don't brew  with normal brew
19:32:51 <dagano> monochrom: because Set is parameterized?
19:32:52 <carter> nstdloop: nope
19:32:55 <nstdloop> carter if I did already
19:32:59 <nstdloop> what should I do
19:33:03 <nstdloop> I've been trying to work this out all day
19:33:04 <carter> delete it
19:33:11 <monochrom> yes
19:33:12 <carter> 1) don't use brew
19:33:17 <carter> 2) if you must, use darin's formula
19:33:30 <nstdloop> My first move was to use the given binary
19:33:34 <nstdloop> I did that
19:33:34 <dagano> is Set an instance of any fancy typeclasses?
19:33:36 <nstdloop> but it didn't work
19:33:37 <carter> nstdloop: which ?
19:33:39 <carter> nstdloop: whos?
19:33:40 <acowley> ReinH: That looks really nice
19:33:42 <carter> 1) don't use brew
19:33:43 <nstdloop> The binary on haskell.org
19:33:45 <carter> ok
19:33:59 <carter> 2) dl the xcode 4.6 CLI tools
19:34:03 <carter> and install those again
19:34:06 <carter> you'll be happy again
19:34:10 <nstdloop> install from?
19:34:12 <acowley> Alright, I'm off for the night
19:34:14 <carter> apple
19:34:18 <nstdloop> ok
19:34:19 <carter> use the googles
19:34:20 <carter> :)
19:34:20 <dwcook> :i Set
19:34:21 <nstdloop> where do I delete those?
19:34:27 <carter> down load
19:34:29 <carter> install
19:34:30 <carter> done
19:34:35 <monochrom> not sure what's fancy, but it has Typeable1, Foldable, Eq, Data, Ord, Read, Show, Monoid, NFData
19:34:44 <nstdloop> So I don't have to delete the old ones, just redownload
19:34:47 <carter> sure
19:34:55 <carter> also don't use brew
19:35:00 <monochrom> you probably like Foldable
19:35:00 <dwcook> Hmm, what prevents Set from being a Functor?
19:35:12 <carter> darin and I have some plans to fix up the 7.6 support story
19:35:16 <carter> burt don't use normal brew
19:35:18 <nstdloop> Ok
19:35:19 <carter> they fuck shit up
19:35:24 <dagano> dwcook: my question
19:35:25 <nstdloop> I found some other guys workaround that used brew
19:35:29 <carter> don't use brew
19:35:31 <nstdloop> didn't work... <.<
19:35:34 <carter> unless its darin's formula
19:35:36 <nstdloop> OK
19:35:37 <carter> darin's tap
19:35:38 <nstdloop> I won't
19:35:49 <carter> nstdloop: in exchange, you need to pass this wisdom on :)
19:35:50 <monochrom> "Set a" wants "Ord a"
19:35:57 <nstdloop> I will
19:35:58 <dwcook> @hoogle Set
19:35:58 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
19:35:58 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
19:35:58 <lambdabot> Data.Set module Data.Set
19:35:58 <nstdloop> believe me
19:36:00 <carter> dagano: also value uniqueness
19:36:02 <dwcook> Hrm
19:36:04 <nstdloop> I would love to have been spared this
19:36:13 <carter> nstdloop: with ghc 7.8, xcode 5 is ok
19:36:16 <dwcook> dagano, listed here http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html
19:36:18 <carter> but thats not out yet :)
19:36:23 <nstdloop> I had to learn how to build ghc before I learned how to write haskell
19:36:28 <carter> nstdloop: thats wrong
19:36:31 <nstdloop> not fun
19:36:39 <carter> nstdloop: it was worse this summer
19:36:54 <carter> with the right patches / hacks you can use ghc 7.6 and xcode 5
19:37:06 <carter> but only after i made sure apple had downstreamed patches thoughtpolice  did
19:37:18 <carter> i spent a month this summer pestering people to make sure it'd happen
19:37:37 <carter> nstdloop: i hope i'm not being too brusque
19:37:47 <dagano> what prevents Set from being a Functor?
19:37:54 <carter> dagano: uniqueness of values
19:38:02 <nstdloop> No
19:38:04 <nstdloop> It's great
19:38:05 <carter> fmap isn't a bijection
19:38:07 <carter> nstdloop: k
19:38:27 <dagano> hmmm i will have to go draw a diagram to think about that one
19:38:29 <carter> dagano: you need a fmap that only takes bijections/
19:38:32 <carter> or something
19:38:41 <nstdloop> CLI for xcode 4.6.2 should work?
19:38:50 <carter> sure
19:38:58 <carter> any CLI Tools for 4.6.x
19:39:03 <nstdloop> great
19:39:04 <carter> but it has to be one from online
19:39:09 <nstdloop> Ya
19:39:12 <carter> not the switcher that xcode gives
19:39:17 <carter> because they just deleted it
19:39:17 <nstdloop> On developer.apple.com etc.
19:39:27 <nstdloop> I'm downloading one from April
19:39:36 <carter> nstdloop: darin and I will provide an unofficial 7.6.4 hotfix for os x
19:39:45 <carter> at some point
19:39:50 <nstdloop> carter Awesome
19:39:53 <carter> but it somehting we're doing on volunteer time
19:39:57 <carter> so its going to take a few weeks
19:40:13 <nstdloop> Any idea when it will make it in to the official ghc build?
19:40:19 <carter> 7.8 is fine
19:40:26 <carter> theres no more official 7.6.x s though
19:40:40 <nstdloop> Ok
19:40:40 <carter> nstdloop: 7. 8 is going to be out in at least RC status next month
19:40:48 <nstdloop> Good good
19:40:48 <carter> but not every lib will work with it yet
19:40:55 <nstdloop> I'm just learning
19:40:57 <carter> soke
19:40:59 <nstdloop> So I'll probably be ok
19:41:29 <carter> yeah
19:41:45 <carter> nstdloop: your first lesson in why upgrades shouldn't be done 'cause its newer :)
19:41:50 <carter> upgrades can break things
19:41:54 <carter> and then everyone is sad
19:41:55 <nstdloop> Ugh
19:41:56 <nstdloop> Yes
19:42:04 <nstdloop> I was using meteor to build a site
19:42:06 <carter> also why brew is a ghetto :)
19:42:08 <nstdloop> 0.6.5 came out
19:42:11 <nstdloop> updated
19:42:14 <nstdloop> whole site goes down
19:42:15 <carter> types lacking
19:42:20 <carter> == mega sads
19:42:32 <carter> nstdloop: with 7.8, you could use luite 's ghcjs instead
19:42:40 <carter> mwahahah
19:42:51 <carter> theres cool demos online
19:43:03 <nstdloop> I'll check it out
19:43:10 <nstdloop> js drives me crazy
19:43:14 <nstdloop> nothing works the way you think it will
19:43:29 <carter> nstdloop: irony about me complaining about brew, i made one of the bigger donations https://github.com/mxcl/homebrew/blob/master/SUPPORTERS.md
19:43:35 <nstdloop> haha
19:43:43 <carter> so i'm allowed ot talk shit
19:43:50 <carter> the mugs i got are nice though
19:44:04 * sm notes nstdloop installed the haskell platform, not latest-bleeding-edge
19:44:15 <carter> sm: yes, but he had xcode 5
19:44:21 <cschneid> can somebody help out with some Aeson parsing? https://gist.github.com/cschneid/d7c5907d81eb17ad9d97 -- trying to parse dynamic key/val pairs
19:44:21 <carter> thats why it broke
19:44:39 <nstdloop> YES
19:44:40 <sm> it's unfortunate, should be noted loudly in the HP release notes or platform notes I think
19:44:42 <nstdloop> IT WORKS
19:44:44 <cschneid> I'm not sure what to do with the vals arg in that gist.
19:44:44 <nstdloop> WOOOOOO
19:44:58 <sm> it doesn't appear in either of those places or in the HP but tracker
19:45:01 <sm> bug
19:45:11 <nstdloop> It is nowhere on the internet
19:45:13 <nstdloop> Been at it for hours
19:45:16 <nstdloop> really should be
19:45:22 <carter> nstdloop: its me yelling at people
19:45:31 <carter> ok
19:45:35 <carter> i'll do a PSA to cafe
19:46:00 <nstdloop> I'm gonna put a little github REAME up that just has indicators for this error and how to fix it.
19:46:04 <nstdloop> README*
19:46:12 <carter> nstdloop: better yet, i'm going to email cafe
19:46:16 <sm> nstdloop: so was the fix to.. install the command line dev tools, like I suggested a while back ?
19:46:17 <carter> so its on the googles
19:46:19 <nstdloop> Somebody else did that, but it's wrong.
19:46:27 <carter> which what?
19:46:39 <carter> sm: it has to be the 4.6 CLI tools
19:46:39 <nstdloop> Install CLI from developer.apple.com for xcode 4.6.x
19:46:44 <nstdloop> Somebody wrote a brew solution
19:46:45 <sm> aha
19:46:53 <nstdloop> brew ghc and gcc
19:47:01 <khyperia> Someone at my school is learning programming for the first time, C++, so I took one of their apps, rewrote it in Haskell, and threw it at their face.
19:47:03 <nstdloop> then manually edit this obscure file to use gcc4.7 instead of gcc
19:47:17 <nstdloop> completely does not work
19:47:29 <carter> nstdloop: it does
19:47:34 <carter> i used that for a while
19:47:38 <nstdloop> I did it wrong then
19:47:40 <nstdloop> (likely)
19:47:42 <carter> yup
19:47:50 <carter> soke
19:47:57 <carter> thats why 'm saying "do it my simple way"
19:48:39 <sm> it's been really well investigated and discussed in a few places, the simple end-user workaround just needs to be added  to official docs
19:48:59 <nstdloop> Yes. Installing the CLI for 4.6 is def. the easiest solution
19:49:06 <sm> thanks a lot carter and helpers, that's tedious stuff
19:49:11 <nstdloop> Yes
19:49:15 <nstdloop> carter you saved me
19:49:17 <nstdloop> thank you so much
19:49:21 <nstdloop> and sm for your help earlier
19:49:22 <carter> sm: yeah
19:49:23 <nstdloop> much appreciated
19:49:36 <carter> sm the problem is whats an official source?
19:49:54 <sm> carter: the HP platform notes for mac
19:50:00 <carter> hahaha
19:50:08 <carter> sm: i've been keeping mzero appraised of this
19:50:15 <sm> http://www.haskell.org/platform/mac.html
19:50:17 <carter> yeah
19:50:37 <carter> i'll gchat him about this
19:53:53 <sm> on another note. Does anyone know if cmdargs typically accepts flags before subcommands ? Like "command --flag subcommand" ? I'm really confused
19:54:40 <carter> no clue
19:54:50 <carter> i should learn that stuff though
19:55:11 <ReinH> I can't say I am super happy with VTY
19:55:23 * Clint abandoned cmdargs for optparse-applicative
19:55:28 <ReinH> Should I switch to ncurses or hscurses?
19:56:34 <sm> ReinH: what don't you like ?
19:56:53 <ReinH> sm: the interface is wonky and inconsistent
19:57:02 <ReinH> they can't even decide between camelCase and snake_case ffs ;)
19:57:48 <sm> I found it a bit slow, but guessed curses is similar
19:59:29 <sm> but vty has a nice ui lib or two
19:59:33 <sm> Clint: do you think optparse-applicative would be flexible enough for hledger ?
20:00:36 <ReinH> vty-ui is pretty ok
20:01:54 <ReinH> I also wish Attributes formed a more useful structure
20:01:59 <Clint> sm: i think so
20:02:00 <ReinH> like an Arrow or something
20:02:51 <ReinH> it could even just use the (a,b) monoid instance
20:03:10 <ReinH> so I can say (background white, mempty) <> (mempty, foreground red)
20:03:11 <ReinH> or w/e
20:03:30 <ReinH> well, background white could just produce (white, mempty)
20:03:33 <ReinH> actually I am going to do that
20:03:37 <ReinH> because not having it is stupid
20:04:18 <ReinH> I shouldn't need both with_fore_color and _with_back_color
20:04:37 <sm> nod
20:04:38 <ReinH> background red <> foreground white --> (white, red)
20:05:56 <ReinH> just throw a couple Last newtypes on there and bob is your uncle
20:08:14 <sm> Clint: does optparse-applicative accept prefixes of flags and commands ?
20:10:55 <TallerGhostWalt> I am really interested in using haskell cloud but am worried about using for real apps yet.  is this unfounded
20:12:11 <ReinH> sm: or hell, just make data Attr = Attr { _fore, _back :: Color, _style :: Style } a lens
20:12:16 <cschneid> given a newtype like:   `newtype Foo = Foo String`. How do I get at the wrapped string?
20:12:21 <ReinH> then attr & fore .~ white
20:12:47 <ReinH> cschneid: pattern matching, or provide an unwrapper
20:12:49 <Hafydd> cschneid: I believe it's only possible by pattern-matching, unless you've named rhe field.
20:12:56 <ReinH> newtype Foo = Foo { getFoo :: String }
20:13:03 <cschneid> ReinH: ok, so the style of  getFoo is common then
20:13:07 <ReinH> cschneid: very.
20:13:14 <ReinH> getFoo, runFoo, whatever is appropriate
20:13:22 <Hafydd> Or just "foo", IMO.
20:13:43 <cschneid> ReinH: sure. playing with Aeson parsing into newtypes and then realized I had no idea how to get back into it :)
20:13:44 <ReinH> Hafydd: sure
20:13:48 <ReinH> cschneid: also http://hackage.haskell.org/package/newtype is fun
20:13:58 <elliott> lens obsoletes newtype
20:14:04 <edwardk> :t ala
20:14:08 <ReinH> elliott: sort of :p
20:14:14 <edwardk> > ala Sum foldMap [1,2,3]
20:14:16 <lambdabot>   6
20:14:29 <carter> anyone have any objections to me emailing out a PSA on xcode 5 + ghc 7.6 woes?
20:14:51 <ReinH> elliott: I find ala, under and over nicer than au and their lens counterparts for newtype wrapping/unwrapping
20:15:01 <elliott> ala is in lens
20:15:02 <cschneid> ReinH: haha, sorta funny of a package.
20:15:06 <ReinH> oh it is now.
20:15:09 <ReinH> huh.
20:15:16 <ReinH> elliott: I don't know things I guess.
20:15:22 <carter> TallerGhostWalt: some real business (FB and otheres) have hused cloud haskell in huge deployments
20:15:25 <edwardk> ReinH: that ala code was using lens =P
20:15:29 <ReinH> edwardk: ok :p
20:15:31 <ReinH> FINE THEN
20:15:40 <cschneid> so lens does this too huh
20:15:50 <ReinH> the ala in lens that does the same thing as the ala from newtype is also nice :p
20:16:12 <cschneid> ReinH / edwardk,   ala is saying "pull each of the things into this Sum type, then monoid them together", right?
20:16:24 <ReinH> cschneid: foldMap is the monoid them together part
20:16:37 <ReinH> ala just manages the newtype isomorphism
20:16:57 <TallerGhostWalt>  carter: cool! I was all gung ho till I started reading the dev notes and they sounded like so much would be changing
20:17:05 <ReinH> cschneid: so foldMap operates on [Sum 1, Sum 2, Sum 3] and then the result is automatically getSum'd
20:17:18 <carter> TallerGhostWalt: well, if things can be made more awesome, they will
20:17:21 <ReinH> well, foldMap gets Sum [1,2,3]
20:17:21 <carter> the great thing about types
20:17:33 <cschneid> ReinH: ahh, that prevents having to say Sum and getSum in the line
20:17:34 <carter> is that you know your code is borked before you try to deploy it
20:17:36 <cschneid> the ala handles both the directions
20:17:45 <carter> bombs away, with the xcode ghc psa
20:17:46 <ReinH> ala Sum foldMap [1,2,3] = getSum (foldMap Sum [1,2,3])
20:17:55 <carter> nstdloop: read my psa email on cafe
20:18:01 <carter> does it explain well enough?
20:18:05 <Clint> sm: i don't understand the question
20:18:07 <cschneid> ReinH: cool, thanks for the explaination.
20:18:07 <nstdloop> where can I read that?
20:18:23 <ReinH> cschneid: np
20:18:33 <cschneid> I ran across a go-lang version of ruby/redis's resque library (background job worker). Now I'm going to try it in haskell now
20:18:35 <spaceships> why does lambdabot know "ala" but won't provide its type?
20:18:51 <cschneid> but for now, just learning how to do json decoding...
20:18:55 <carter> http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
20:19:00 <carter> you should subscribe to cafe
20:19:09 <nstdloop> I just discovered what that is
20:19:10 <nstdloop> I will
20:19:11 <nstdloop> thakns
20:19:38 <nstdloop> ghc-ios is a thing?
20:19:39 <nstdloop> awesome
20:19:43 <ReinH> cschneid: monoid homomorphisms ftw :)
20:20:04 <carter> nstdloop: yes it is
20:20:05 <nstdloop> This looks good
20:20:08 <sm> Clint: like, cmdargs accepts hledger pr --disp for hledger print --display
20:20:08 <carter> cool
20:20:12 <cschneid> I swear most of haskell is learning silly words like monoid and homomorphisms.
20:20:13 <nstdloop> Just what I would have needed
20:20:18 <carter> i'm glad i used 5 minutes of my attention well
20:20:27 <carter> nstdloop: does it layout all the sane choices  clearly?
20:20:31 <nstdloop> Yes
20:20:37 <nstdloop> And it leaves off the not-sane options
20:20:40 <nstdloop> which is good
20:20:42 <carter> yes
20:20:55 <carter> dealing with support on crazy shit would make me grumpy
20:21:04 <carter> even when its just me
20:21:13 <nstdloop> You don't know what I tried
20:21:15 <nstdloop> it was bad
20:21:20 <ryant5000> this is a bit of a shot in the dark, but does anyone happen to have a script for eliminating redundant module imports?
20:21:28 <ryant5000> i have... a lot of them, lol
20:21:55 <carter> ryant5000: only in exchange for your monies :P
20:22:00 <ryant5000> haha
20:22:00 <carter> i think hlint can?
20:22:03 <carter> or something
20:22:15 <carter> or was it ghc-mod
20:22:19 <carter> or some crazy thing i dont' remember
20:22:21 <ReinH> cschneid: false, that's actually about 75% of Haskell
20:22:28 <carter> nstdloop: i know what you tried
20:22:35 <carter> i had it working pretty darn well for my ghc :)
20:22:57 <carter> ryant5000: ghc -Wall might work
20:23:03 <carter> and then do it by hand
20:23:24 <carter> might be faster than finding such a script
20:24:05 <thoughtpolice> -Wall can't really tell you if an import is *really* unused, because it may also bring instances into scope. you must typecheck in order to resolve instances and determine if they're used (GHC fails at this since it does import checking in the renamer, IIRC)
20:24:52 <thoughtpolice> you basically just have to remove them until it breaks, and then suppress the ones which may only import instances ('import Foo()')
20:24:57 <nstdloop> I was brewing individual pieces and trying to manually put together my path
20:25:11 <carter> nstdloop: brew is a ghetto
20:25:12 <nstdloop> It was going to end badly
20:25:30 <nstdloop> It even sounds like it
20:25:30 <enthropy> @hackage module-management ryant5000
20:25:30 <lambdabot> http://hackage.haskell.org/package/module-management ryant5000
20:25:33 <nstdloop> is the best part
20:25:40 <nstdloop> I "brewed" my own components
20:25:57 <carter> nstdloop: I did have a setup using gcc-4.8 and a patched settings file that mostly worked for me
20:26:10 <carter> apple gcc is OLD
20:26:12 <enthropy> which just uses ghc's -ddump-minimal-imports (so it doesn't get rid of the import Foo() -- possibly instances only)
20:26:27 <nstdloop> I tried that but since I had regular cabal already installed it was running the unmodded one.
20:26:42 <carter> nstdloop: nope
20:26:44 <nstdloop> and while knowing nothing about editing PATHs I decided heck I'll give it a try
20:26:45 <carter> you were doing it worng
20:26:52 <carter> cabal just uses the ghc stuff
20:26:54 <nstdloop> I am sure
20:27:05 <carter> nstdloop:  do ghc-pkg list
20:27:11 <carter> and the first line of the result should be a path
20:27:14 <carter> path/...
20:27:22 <carter> $path/..
20:27:26 <carter> should have a settings file
20:27:42 <carter> so do
20:27:47 <carter> open  path/..
20:27:50 <carter> and you'll see it :)
20:27:55 <nstdloop> ya
20:27:57 <nstdloop> I see it now
20:28:05 <carter> thats the settings file you were uspposed to mod
20:28:19 <Clint> sm: oh, hmm, there's some disambiguation stuff but i've never used it and i'm not sure it applies
20:28:42 <nstdloop> I modded some other one.
20:28:49 <nstdloop> It definitely wasn't that.
20:29:08 <nstdloop> Well everything works now
20:29:09 <nstdloop> thankfully
20:29:22 <carter> nstdloop: down vote the wrong
20:29:53 <carter> well, now you have a good document to link to for directions for new folks at lesat
20:30:08 <sm> Clint: it looks a bit less mature than cmdargs. Interesting though
20:30:34 <ricree> is there any good way to handle a variadic c function with ffi?
20:30:43 <jmcarthur> ryant5000: -ddump-minimal-imports
20:31:25 <carter> ricree: witchcraft and wizardy
20:31:37 <carter> or writing a suitable magic wrapper than gives a more typeable interface
20:31:51 <cschneid> is there an easy way to write multi-line strings?
20:32:05 <ricree> carter: about what I expected, I suppose.
20:32:13 <ryant5000> jmcarthur: haha amazing, thanks
20:32:15 <ricree> carter: but thanks
20:32:16 <enthropy> carter: do yuo have descriptions of the first option?
20:32:22 <Clint> sm: i can't even remember what i switched for
20:32:29 <carter> enthropy: magic?
20:32:32 <thoughtpolice> ricree: you can use the libffi package,
20:32:42 <carter> oh yeah
20:32:48 <thoughtpolice> and just let libffi do the (ridiculous) magic
20:32:51 <carter> yeah
20:32:53 <jmcarthur> ryant5000: i'm not very familiar with the package enthropy linked, but it looks pretty cool too
20:34:12 <ricree> thoughtpolice: nice, thanks.
20:34:32 <carter> libffi is a good call
20:36:25 <niteria> is it possible that small ByteStrings use the whole page?
20:37:46 <carter> what size is small?
20:37:57 <carter> are they all the same size?
20:38:02 <carter> what fraction of page size are they?
20:38:42 <niteria> they are 20ish bytes
20:38:59 <carter> niteria: what ghc version?
20:39:11 <niteria> it looks like each of them takes 4k
20:39:21 <carter> how're you measuring?
20:39:32 <niteria> 7.6.3
20:40:54 <niteria> I'm guessing at this point, I just know when I use BS.copy str vs show str I use 9mb vs 800kb of memory
20:43:48 <ryant5000> enthropy: thanks for the link to that package :) i didn't see it earlier
20:44:42 <carter> niteria: could you show us the overall code
20:44:47 <carter> because it may be a bit more tha that
20:44:52 <cschneid> so - how do Data.Data, and Data.Generic differ? They both claim to be SYB related.
20:45:02 <carter> niteria: also you may want to just use slices
20:45:05 <carter> rather than copies
20:45:20 <carter> depending on the work load
20:45:25 <enthropy> cschneid: Data.Generics has more functions
20:45:26 <carter> zero copy >> some copy
20:45:45 <enthropy> cschneid: and it re-exports Data.Data
20:46:29 <niteria> carter: I want to copy, because I want to keep it in memory, and it's a slice of a whole http request
20:46:29 <cschneid> enthropy: ok - is there a reason to use Data.Data, if Data.Generics is better? (for whatever more-powerful version of better makes sense)
20:46:51 <carter> niteria: tell us more
20:46:56 <carter> becauese we know nothing
20:47:00 <carter> share the code even
20:47:14 <enthropy> cschneid: well it's not good to have more names in scope if you won't be using them for sure
20:47:24 <enthropy> since there's a bigger chance you'll have conflicts
20:47:53 <enthropy> and actually Data.Data is in base, not syb
20:47:58 <cschneid> enthropy: how does typeable play into it?
20:48:15 <enthropy> so more installations will have Data.Data than have Data.Generics
20:48:39 <enthropy> @src Data
20:48:39 <lambdabot> Source not found. :(
20:48:52 <NemesisD> i've got a project that's nothing but executables, but how do i get cabal to also package all the source files
20:49:00 <NemesisD> do i have to enumerate everything in extra-modules
20:49:18 <niteria> carter: code has too many irrelevant things, I just wanted to know if it's possible
20:50:00 <carter> niteria: make some minimal code to test your hypotheiss
20:50:02 <enthropy> NemesisD: stuff tends not to work when you forget to name other-modules:
20:50:20 <NemesisD> i wonder if someone has made a tool to do this
20:50:56 <NemesisD> there would be value in automating it, each executable doesn't need the entire tree of modules
20:51:02 <enthropy> that module-management comes with a command line tool that sort of can change those listings
20:51:10 <user123abc> do you all get proper fill-paragraph behavior in emacs? In my setup, it's not preserving the comment prefix
20:51:14 <user123abc> in haskell-mode
20:51:37 <NemesisD> i was really excited about module-management until i found it is really poorly optimized for the common case
20:51:39 <enthropy> as in, it will add more lines to things like other-modules, if you split a module
20:51:50 <enthropy> what is the common case?
20:51:54 <NemesisD> unless i'm thinking of another package, i remember you had to load it into ghci and fiddle with it
20:52:07 <enthropy> it comes with a half-decent command line tool
20:52:22 <enthropy> which wasn't the case a month or two ago
20:52:37 <NemesisD> ah ok i checked longer ago. i'll give it a try!
20:53:07 <NemesisD> i like that the binary is called "hmm"
20:53:23 <enthropy> the cabal file editing could be greatly improved I think
20:54:54 <NemesisD> i'm all for powerful tools for power users but i really appreciate when a tool makes it dead simple to do the thing that everyone wants to do
20:55:50 <enthropy> well let me know if there are things that can be improved / fixed
20:55:57 <enthropy> that aren't listed in the README already
20:56:13 * enthropy put quite a bit of effort into improving the hmm
20:56:59 <enthropy> one missing feature that might be useful would be to go from restictive imports to something less restrictive
20:58:09 <NemesisD> the repl could really use documentation
20:58:17 <enthropy> there's some overlap with HaRe I think
20:59:39 <carter> latermuse: got the email!
20:59:40 <carter> thanks
20:59:43 <carter> a bit buried
20:59:52 <carter> but if i see opts, i'll figure out passing em along
21:00:33 <NemesisD> enthropy: how do you even use the repl? its just a blank prompt
21:00:51 <enthropy> NemesisD: ah you didn't just try stuff?
21:00:54 <enthropy> "help" invalid - expected quit, exit, bye, ., , v, q, verse, clean, dir, split, merge, cabalPrint, cabalRead, cabalWrite
21:01:06 <NemesisD> help invalid ;)
21:01:19 <enthropy> and then if you run any of the commands with no arguments (and it needs arguments)
21:01:28 <enthropy> it will tell you what it's expecting
21:02:08 <NemesisD> none of those things seem like what i need
21:03:05 <enthropy> well you can start your project with one Main.hs file
21:03:37 <user123abc> haskell-mode is supposed to be able to properly reflow comments via fill-paragraph, but a clean install of emacs with just haskell-mode shows this to not happen with "--" comments
21:04:09 <nstdloop> Is there a way to do imports so you don't clog up your namespace?
21:04:13 <nstdloop> It's quite annoying.
21:04:50 <NemesisD> nstdloop: import qualfied Data.Text as T
21:04:59 <enthropy> NemesisD: then when you cabal init, there's just one or two modules to list there
21:04:59 <applicative> you mean 'import qualified Data.X.Y.Z as X' and so on, or are you saying you're against that
21:05:17 <nstdloop> I mean if I just write import Some.Thing
21:05:26 <nstdloop> I get all the functions in Some.Thing as their regular names
21:05:31 <nstdloop> and I get namespace collissions
21:05:33 <applicative> right
21:05:39 <NemesisD> enthropy: i'm confused. i have an existing projects with 2 executables that i'd like to get a module list for
21:05:40 <enthropy> NemesisD: then if hmm works properly (probably it doesn't look at main-is:), you can split and merge to get functions into their own modules
21:05:41 <nstdloop> does qualified eliminate that?
21:05:45 <applicative> but if you import qualified Some.Thing as X
21:05:55 <enthropy> NemesisD: oh then it doesn't really help you
21:05:56 <nstdloop> it doesn't do that
21:05:58 <nstdloop> excellent
21:06:00 <nstdloop> that's what I needed
21:06:02 <applicative> then you write X.thing and it doesn't collide with Y.thing
21:06:05 <shachaf> @google what does "import qualified" do in haskell?
21:06:05 <lambdabot> http://www.haskell.org/haskellwiki/Import
21:06:05 <lambdabot> Title: Import - HaskellWiki
21:06:13 <nstdloop> Thanks
21:06:14 <shachaf> That page has a detailed explanation of import behavior.
21:07:08 <haasn> you can qualify names without ‘qualified’, that keyword just *forces* you to qualify those
21:07:14 <haasn> ‘as’ is entirely tangential
21:07:15 <NemesisD> enthropy: oh ok. fair enough. do you know if HaRe will do this? the other-modules list is actually rather tricky because the executables have different deps so i don't want to just show the whole tree of modules in other-modules
21:07:37 <enthropy> NemesisD: you have some choices where you put those modules in the cabal file. A tool could assume something, but that might be wrong
21:07:53 <jfischoff> can multiple threads read the same tvar without blocking?
21:08:01 <applicative> given the absurd module names on hackage, I recommend 'as' nstdloop
21:08:05 <enthropy> your choices are at least other-modules:, or exposed-modules:  (if you also have a library in there)
21:08:09 <nstdloop> Yes
21:08:10 <NemesisD> enthropy: seems like it would be possible to determine all modules involved with a particular build target
21:08:12 <nstdloop> Thank you
21:08:35 <NemesisD> that seems like knowable information
21:08:37 <enthropy> yeah that should be possible
21:08:50 <applicative> dont forget that it was Data.X.Y.Z.Strict not Data.X.Y.Z, which is reprehensibly lazy, that you probably wanted
21:08:56 <enthropy> and assume those ones go in the other-modules: list of an executable
21:09:27 <NemesisD> enthropy: yeah i think wer'e on the same page. is this possible to do not by hand
21:12:39 <jmcarthur> just tried simple typechecking with terms defined using Bound for the first time. turns out it's super easy. whenever you encounter a lambda, instantiate the bound variable with its type. no need to even keep an environment explicitly.
21:12:50 <carter> jfischoff: what do the docs say?
21:13:02 <jfischoff> not much
21:13:12 <carter> jmcarthur: you disnt see my talk right?
21:13:39 <jmcarthur> carter: i caught it on video
21:13:51 <carter> hat andall
21:14:30 <jmcarthur> yup
21:14:45 <jmcarthur> i don't remember the hat, but i'm sure it's there
21:16:17 <NemesisD> this is the one time where i'd actually appreciate an IDE
21:16:41 <enthropy> NemesisD: no I think it should possible to do something helpful, just that it might be wrong sometimes
21:16:58 <NemesisD> enthropy: for what to do something helpful?
21:17:23 <carter> but yeah, bound is nice
21:17:35 <enthropy> to add a list of things to your cabal file that you might have to put somewhere else
21:17:35 <carter> hbound is tempting
21:18:05 <enthropy> NemesisD: for example `cabal init' conveniently puts all the packages you're using in there
21:18:15 <NemesisD> im not sure what you mean by put somewhere else, i basically need a list of modules used by an executable
21:18:18 <enthropy> but that doesn't mean you might have to change some version bounds later on
21:18:21 <enthropy> or add some yourself
21:19:05 <jmcarthur> NemesisD: well, ghc has a flag for generating a dependency tree for Make. it's -M.
21:19:50 <jmcarthur> NemesisD: you just pass it the modules you intend to expose and it will write a makefile listing all the files it needs to build
21:20:02 <jmcarthur> or roughly that, at least
21:20:13 <enthropy> you can also load your Main.hs in ghci
21:21:24 <enthropy> example:
21:21:26 <enthropy> ghci Main.hs `pkg-config --libs opencv` | grep 'interpreted )' | awk -F' ' '{print $5}'
21:22:03 <NemesisD> enthropy: genius!
21:22:04 <enthropy> you likely don't need that opencv bit in there
21:22:17 <NemesisD> my project has a flag to disable either one of the executables
21:22:24 <carter> thoughtpolice: ghc/package-vector on github is very very stale :(
21:22:34 <NemesisD> cabal configure --fno-client; cabal repl, bam module list right at the bottom
21:22:48 <NemesisD> lather and repeat with -fno-server
21:23:07 <enthropy> hmm, hmm should do that too :p
21:23:31 <NemesisD> cabal 1.18 is so good
21:23:39 <carter> blah
21:24:04 <NemesisD> cabal 1.18 feels like the haskell gods took pity on us mortals and delivered us from development hell
21:28:41 <NemesisD> hmm, should i be pushing new packages to old hackage?
21:29:15 <enthropy> the new hackage mirrors the old one I think
21:29:37 <NemesisD> old hackage it is then if it goes old -> new
21:29:51 <NemesisD> unless mirroring is bidirectional...
21:32:16 <AfC> Is cassava the current hotness in CSV parsing?
21:32:36 <NemesisD> i've not use anything else but i really like it
21:32:38 <copumpkin> if you like huge error messages like what chrisdone was getting :)
21:32:58 <NemesisD> copumpkin: from new-hackage?
21:33:05 <shachaf> i like monoids
21:33:20 <copumpkin> I'm more of a dioid kinda guy
21:33:23 <NemesisD> cassava has usability on par with aeson, muy bueno
21:34:25 <AfC> NemesisD: thanks. Will try it. Is the FromRecord typeclass the moral equivalent of FromJSON?
21:34:53 <NemesisD> AfC: yeah, the named versions as well are for csvs with a header row
21:35:08 <NemesisD> i find myself using that more often, i don't do positional csv processing if i can help it
21:35:52 <AfC> Oh, yeah. Ewww
21:36:02 <AfC> NemesisD: I might not have noticed that right away. Thanks
21:39:55 <NemesisD> np!
21:43:47 <NemesisD> package upload on old hackage takes an unnerving amount of time
21:46:30 * hackagebot vigilance 0.1.0.0 - An extensible dead-man's switch system  http://hackage.haskell.org/package/vigilance-0.1.0.0 (MichaelXavier)
21:47:35 <daniel-s> Hi
21:48:10 <daniel-s> I got to about the end of chapter 3 of the oreilly haskell book then gave up. I'm now going to start on this: http://learnyouahaskell.com and maybe go back to the oreilly one.
21:48:17 <daniel-s> Is that the dumbed down child version?
21:48:57 <Dodek> oreilly haskell book is Real World Haskell?
21:49:32 <latermuse> carter: thanks!
21:49:40 <carter> latermuse: ahve you slept yet?
21:50:06 <daniel-s> Dodek: Yeah, that one.
21:50:09 <jfischoff> is there a package that will generate hashable instances?
21:50:22 <carter> hashable?
21:50:44 <jfischoff> err th for hashable
21:52:07 <carter> problem is, hteres more than one way to do it
21:52:12 <carter> theres no canonical solution
21:52:19 <carter> who is solution
21:52:34 <Enigmagic> jfischoff: i think it has a Generic instance now
21:52:46 <Dodek> daniel-s: it's certainly not dumbed down
21:52:57 <Dodek> in some aspects it's deeper than RWH
21:52:59 <jfischoff> yeah that is the route I am taking now, but it is slightly more work ...
21:53:09 <Dodek> daniel-s: as for whether it's a child version...
21:53:45 <Dodek> daniel-s: it's certainly much more playful. :P
21:53:47 <Enigmagic> jfischoff: more work than TH? shouldn't it be about the same?
21:54:10 <jfischoff> about two more lines of code
21:54:30 <jfischoff> three actually
21:54:51 <Enigmagic> pragma derivinggeneric, deriving generic, instance Hashable
21:55:32 <jfischoff> import Data.Hashable.TH deriveHashable ''Foo
21:55:46 <Enigmagic> also the PRAGMA templatehaskell :P
21:55:47 <jfischoff> and you forgot a line
21:55:55 <jfischoff> import GHC.Generics
21:56:14 <Enigmagic> seems like a wash
21:56:16 <jfischoff> naw template haskell is always on with yesod
21:56:28 <jfischoff> lives hang in the balance
21:57:54 <jfischoff> It always frustrates me that it is DeriveGeneric and import GHC.Generics. I screw up the plurals
22:01:48 <Enigmagic> jfischoff: you need some autocomplete. i hit tab instead.
22:02:22 * jfischoff nods
22:05:45 <spaceships> favorite curses-like terminal gui-y library? currently checking out vty-ui because it has a manual
22:07:44 <Enigmagic> vty has the best docs and a fairly sane api. the one project i was considering using it for i just used haskeline instead and didn't do anything fancy.
22:08:46 <ReinH> Enigmagic: VTY has pretty meh docs. vty-ui has a nice manual.
22:08:57 <ReinH> I've been disappointed with vty so far... but I'm not sure there's anything better.
22:10:00 <ReinH> VTY just has such a weird design
22:10:20 <ReinH> Attributes should be a monoid but instead it's this weird tuple of MaybeDefaults, which are themselves weird
22:10:54 <ReinH> and MaybeDefault doesn't have any useful instances so you're really restricted in how you use it
22:11:06 <Enigmagic> ReinH: i thought it was the best of the worst :)
22:11:06 <ReinH> and this sort of thing is how the entire library is
22:11:11 <ReinH> Enigmagic: seems so
22:11:51 <Enigmagic> but not good/easy enough for me to bother, vs haskeline which took me maybe an hour to hack in with tab completion and color.
22:12:05 <ReinH> Enigmagic: well they do different things
22:12:09 <ReinH> I need an ncurses-like
22:12:14 <ReinH> not a readline-like
22:13:03 <ReinH> and that Vty object is so weird http://hackage.haskell.org/packages/archive/vty/4.6.0.6/doc/html/src/Graphics-Vty.html#Vty
22:13:07 <Enigmagic> ReinH: i understand that, but i dropped my requirement for an ncurses like library after looking at vty/hscurses/ncurses/...
22:13:14 <ReinH> Enigmagic: fair enough :)
22:13:28 <ReinH> I'm really tempted to write my own library
22:13:44 <ReinH> but $TERM is such a ghetto
22:13:49 <ReinH> I don't really want to have to deal with all that crap
22:15:58 <ReinH> also reading snake_case everywhere in vty source makes my eyes bleed. Why on earth would you do that...
22:16:22 <ReinH> it's not so bad by itself, but when you have normally named library functions everywhere it gets really painful
22:29:39 <latermuse> carter: no sleeping for me
22:51:43 * hackagebot snap 0.13.0.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.0.2 (DougBeardsley)
23:07:35 <bwr> 3
23:07:41 <bwr> oops sorry
23:11:44 * hackagebot vigilance 0.1.0.1 - An extensible dead-man's switch system  http://hackage.haskell.org/package/vigilance-0.1.0.1 (MichaelXavier)
23:24:30 <hari__> Does anybody know how to use the getStr function in Hscurses?
23:24:47 <hari__> There appears to be no getStr function in HSCurses
23:26:45 <tpsinnem> i've just begun to get into the habit of searching for things by type on hoogle. that's just too easy. feels like i'm working on borrowed karma.
23:33:37 <johnw> is there anything like a surjective Map, where multiple keys can refer to the same object, and if it is updated the other keys will reference the update?'
23:34:31 <johnw> ah, I can do this with Map k (TVar a)
23:36:49 <shachaf> That won't be persistent anymore, of course.
23:38:58 <johnw> yes, i'll have to sacrifice that
23:39:41 <shachaf> You can choose to sacrifice it, at least!
23:40:03 <shachaf> I'm not sure what this property has to do with surjectivity, though?
23:40:16 <johnw> multiple keys mapping to the same value, isn't that surjectivity?
23:40:37 <johnw> and that every value is mapped to by at least one key
23:41:09 <shachaf> That second thing is surjectivity.
23:41:16 <johnw> ah, ok
23:41:25 <johnw> overlapping keys is not a requirement
23:41:43 <shachaf> And even if it was I'm not sure what that has to do with updates.
23:42:19 <johnw> it may not, actually
23:42:40 <shachaf> Anyway, there are certainly ways to do that thing without resorting to mutable variables.
23:42:48 <johnw> like?
23:43:35 <shachaf> That depends on the exact behavior you're after, which I haven't really understood.
23:43:36 <napping> johnw: sounds like the composition of two maps to me
23:43:42 <shachaf> But it sounds like you can map keys to ids, and then ids to values.
23:43:47 <hari__> There appears to be no getStr function in HSCurses,
23:44:07 <napping> mutable variables may be a convenient way to do that, if you don't have a natural identity
23:44:08 <johnw> shachaf: that's a good idea; I thought of an ancillary map for a few seconds, but apparently not long enough
23:44:28 <hari__> Is there any alternative to HSCurses with support for reading input string from command line?
23:45:42 <napping> I suspect you'll want the explicit control anyway
23:46:04 <napping> or is the semantics supposed to be that if two keys ever happen to map to the same set, they are forvermore equivalent?
23:46:17 <johnw> napping: one reason the ancillary mapping may be better is that it makes it easier to determine the inverse mapping
23:46:27 <johnw> forevermore
23:46:38 <napping> say I've got 1 |-> "A", 2 |-> "A"."B", and insert 1 |-> "B"
23:46:55 <napping> then even though they were not the same before, deleting something from 2 after that will affect 1?
23:47:06 <napping> because that sounds kinda like some sort of union-find structure
23:47:26 <shachaf> Like I said, I haven't really understood the exact behavior. :-)
23:47:53 <johnw> shachaf: I won't blame you if it doesn't work :)
23:48:20 <napping> and if so, it's hard to compete with the O(1) imperative version
23:53:38 <hari__> I am unable to find any haskell curses binding with the getStr functionality. neither hscurses nor ncurses nor nanocurses seem to have it
