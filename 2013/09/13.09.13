00:00:05 <hvr> edwardk: for some reason I can only guess, all Data instances in `base` are handwritten
00:00:07 <johnw> but my real reading queue is Pocket anyway
00:00:22 <edwardk> hvr heh i can sketch one out if you want to go through the nonsense to get it committed
00:00:51 <hvr> thoughtpolice: ...do you have any objections to add a Data instance for Data.Version in base? :)
00:01:07 <edwardk> i don't think anyone piped up with an objection on the thread
00:01:10 * hvr wants to get rid of that Cabal orphan instance warning during GHC build
00:01:22 <johnw> man, i've been fighting types all day.  my code last compiled 7 hours ago
00:02:41 <thoughtpolice> hvr: i do not, and i know i've had to make orphans before
00:02:44 <johnw> success!
00:02:47 <thoughtpolice> IOWs: do it :)
00:02:50 <johnw> Proxy was my salvation
00:02:51 <hvr> thoughtpolice: for Data.Version specifically?
00:03:31 <hvr> edwardk: so, give us something to add to http://git.haskell.org/packages/base.git/blob/HEAD:/Data/Data.hs and I'll take care it makes it into 7.8 :-)
00:04:32 * hvr is quite overwhelmed by all those class methods of Data
00:05:23 <MercurialAlchemi> I make orphans all the time, usually by stuffing third-party typeclass implementations into a dedicated module, and I sleep well at night
00:05:42 <thoughtpolice> hvr: yes, i know i've had to make orphans of Version before
00:05:50 <thoughtpolice> (not like, this week, but I know I've done it)
00:07:15 <edwardk> hvr: written. one sec.
00:10:16 <hpaste> edwardk pasted “Data.Data for Data.Version” at http://lpaste.net/92938
00:10:22 <edwardk> hvr: there you go
00:10:50 <edwardk> hvr: you only have to implement those
00:11:02 <edwardk> plus 1 or 2 more if you have type parameters
00:11:53 <edwardk> gfoldl lets you tear it down, gunfold lets you built it up, toConstr lets you know what the constructor is, dataTypeOf lets you get the data constructor description so it can reflect on how many constructors it has, etc.
00:12:29 <edwardk> i mostly wind up having to roll a lot of these by hand because i wind up with non-trivial types involved and i can't get them auto-derived
00:12:57 <edwardk> all the gmapQ, etc. stuff is automatically defined and is never overridden
00:13:50 <edwardk> dataCast1 or dataCast1 and dataCast2 should also be implemented if you take 1 or 2 type parameters
00:13:54 <edwardk> but Version doesn't
00:18:02 <scripty> Howdy
00:18:18 <sp3ctum> hey
00:27:46 <hvr> edwardk: btw, does the GHC.Generics facility supersede Data.Data ?
00:27:51 <edwardk> no
00:27:56 <edwardk> they overlap but neither subsumes the other
00:28:04 <hvr> I see
00:28:47 <edwardk> GHC.Generics makes it possible to write things that depend on the shape of the data being known at typechecking type. Data.Data gives you more tools for exploring on an ad hoc basis
00:29:02 <edwardk> also GHC.Generics is generally a lot harder to use
00:29:39 <edwardk> Also Data.Data can be tricked into supporting polymorphic recursion, while GHC.Generics can't
00:30:12 <edwardk> its a bit of a wash
00:35:31 * edwardk &
00:37:08 * arkeet $
00:40:06 * mbrock >>= mbrock . napM
00:44:28 <raichoo> luite: Hi, I heard that you are working on ghcjs. I'm working on the idris javascript backend. May I ask you what you are using for big integers on the js side?
00:59:21 <tdammers> I think I need a heads up
00:59:27 <tdammers> cabal-dev ghci now fails
00:59:51 <tdammers> cabal-dev: user error (cabal: Can't parse --info output of GHC
01:01:56 <tdammers> ghc is: The Glorious Glasgow Haskell Compilation System, version 7.4.1
01:02:00 <tdammers> from debian
01:17:43 <kuribas> The joys of cabal!  I am trying to install the examples of the parallel concurrency book (parconc-examples).  "cabal install --only-dependencies" gives me a long list of packages, including packages that are likely to break"
01:17:49 <kuribas> What's the best solution?
01:18:09 <tdammers> cabal-dev, apparently :P
01:18:24 <dcoutts_> or the latest cabal which has sandboxing
01:21:17 <hardliner_> test
01:22:34 <tdammers> so why does cabal-dev ghci suddenly fail for me? any clues?
01:28:26 <akegalj> for those using yesod, if i do [ireq textField "a", ireq textField "b"]  i will get  [FormInput ... a] , how to sequence that to get   FormInput ... [a] ?
01:31:21 * hackagebot biosff 0.3.5 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.3.5 (KetilMalde)
01:31:23 * hackagebot inject-function 0.2.0.0 - Monadic functions with injected parameters.  http://hackage.haskell.org/package/inject-function-0.2.0.0 (DimitriSabadie)
01:36:42 <npouillard> I'm looking for an example of a monadic function (such as mapM) that is truly using the extra power of monads (which would not work with applicative then)
01:38:00 <lieven_> if I have foo :: IO(a) and bar :: a->b, why is f = do mya <- foo; bar mya  complaining about not matching IO and Maybe?
01:38:32 <Kinnison> 'bar mya' is not an IO action
01:38:41 <npouillard> lieven_: what is your 'b' type
01:39:01 <lieven_> b is a Maybe String
01:39:26 <quchen> And Maybe String is not IO String.
01:39:27 <Clint> and what is your function's type supposed to be?
01:39:53 <tdammers> ah, cool, figured it out
01:40:03 <tdammers> cabal sandbox init; cabal install; cabal repl
01:40:07 <lieven_> I'd like f to return a Maybe String
01:41:01 <lieven_> I'm still in the newbie stage of slapping half understood constructs here and there to try to appease the compiler :)
01:41:08 <Clint> then you can't call foo
01:41:10 <shelf> that never ends, my friend
01:42:52 <Maior> lieven_: I call that "programming"
01:43:11 <lieven_> ok, maybe a bit more background. I have in my program a thing that can come from a command line argument, from a previously saved version or from a compiled in default. So I thought to make a list of [Maybe things], use laziness and head catMaybes to get the first one that exists. but I'm struggling with the IO interactions for this.
01:46:25 <lieven_> so maybe I need to make that [IO(Maybe things)] and find some way to pack bar and foo together to return IO(b)?
01:46:33 <Kaini> lieven_, because what you want to do is impossible. You cannot escape IO (IO a to Maybe a is an impossible conversion). You might want your list to be IO [Maybe a]
01:47:12 <kuribas> npouillard: mapM doesn't work work with applicative, does it?
01:47:35 <lieven_> Kaini: ok, but how can I map a function bar :: a->b to IO(a)->IO(b) then?
01:47:36 <quchen> kuribas: mapM = traverse
01:48:11 <quchen> kuribas: mapM is unnecessarily specialized, what it does can be accomplished with only Applicative and not Monad
01:48:50 <Kaini> lieven_, do you really want IO a -> IO b, or a -> IO b? Use <$> for the first case, return (and =<<) for the second
01:48:52 <kuribas> I see.
01:49:23 <Kaini> Control.Applicative.(<$>)
01:49:30 <lieven_> Kaini: thanks for the tip. I need to think about this for a while :)
01:49:54 <donri> :t fmap id `asAppliedTo` getLine
01:49:55 <lambdabot> IO String -> IO String
01:50:02 <quchen> kuribas: It's one of the things that make Applicative =/=> Monad annoying. :-)
01:50:34 <donri> Kaini: return and bind is equivalent to fmap
01:50:39 <donri> @src liftM
01:50:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:50:53 <donri> @. undo src liftM
01:50:53 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1);
01:51:07 <donri> @. pl . undo src liftM
01:51:08 <lambdabot> (line 1, column 42):
01:51:08 <lambdabot> unexpected ';'
01:51:08 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
01:51:32 <hpaste> ghorn pasted “unexpected(?) parse error” at http://lpaste.net/92940
01:51:49 <ghorn__> ^ this surprised me
01:52:24 <donri> ghorn__: you can't partially apply infix operators without a section
01:52:44 <ghorn__> donri: what is a section?
01:53:09 <donri> ghorn__: a partially applied infix operator :) the parenthesis
01:53:46 <kuribas> quchen, npouillard:  What about foldM?  It uses bind for folding the arguments.
01:54:12 <quchen> foldM is monadic only, yes.
01:54:36 <kuribas> So a lot of monad functions are actually applicative.
01:55:13 <quchen> "A lot" is hard to check, but an annoying amount at least.
01:55:32 <npouillard> On #haskell-lens supki suggested the monad-loops package and of that I think whileM or andM are good examples
01:56:52 <quchen> Those are non-standard though.
01:57:10 <quchen> foldM might be more familiar.
01:57:27 <quchen> Anyway, you're covered with examples now I guess :-)
01:58:42 <npouillard> Yeah thank you all
02:06:22 * hackagebot inject-function 0.2.1.0 - Monadic functions with injected parameters.  http://hackage.haskell.org/package/inject-function-0.2.1.0 (DimitriSabadie)
02:07:20 <kuribas> How do I use the cabal-dev packages with ghc?
02:07:59 <notdan> what do you mean?
02:08:36 <notdan> you can add the cabal-dev/ to the lib path, I guess
02:08:54 <kuribas> ok
02:20:45 * scripty haskell is crazy
02:27:46 <yesthisisuser> I don't know if it's just me but doesn't it feel like Haskell documentation a lot of times lacks good examples...
02:29:11 <yesthisisuser> not to go on a rant or anything.. hehe
02:29:18 <quchen> yesthisisuser: When frustrated, look at pipes. :-D
02:29:32 <yesthisisuser> I find that a good example often communicates a concept much better
02:30:18 <yesthisisuser> http://hackage.haskell.org/package/pipes ?
02:31:46 <luite> raichoo: jsbn
02:32:41 <raichoo> luite: Thanks a lot, hows the performance?
02:33:09 <raichoo> Uh benchmarks on the site nevermind :D
02:33:10 <luite> not great, but i don't know a better alterative
02:34:07 <raichoo> fair enough.
02:36:23 * hackagebot ghc-parmake 0.1.8 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.8 (MikhailGlushenkov)
02:36:38 <raichoo> luite: I'm currently using https://github.com/peterolson/BigInteger.js I was hoping for something faster.
02:41:45 <scripty> I just cant understand haskell errors
02:42:16 <luite> raichoo: i added some patch from the force project to make jsbn faster in ie and firefox
02:42:21 <luite> forge porject
02:43:12 <luite> raichoo: unfortunately at the time their version wasn't based on the latest JSBN, so i added it manually, perhaps it's better now
02:44:41 <raichoo> luite: I'll definitly take a look. Thanks a lot :)
02:46:42 <luite> raichoo: https://github.com/ghcjs/shims/commit/733081246be8946e8130c712d5b5c223e2cc0084
02:48:24 <pharaun> scripty: give it time, it'll eventually become more and more clearer :)
02:48:48 <pharaun> lots of it for me fwiw was just spending time screaming at the errors, or reading wiki and asking or etc and i started to be able to read em :)
02:56:16 <merijn> scripty: Do you have an example that stumps you? It helps to just paste the error and ask people how you should read them
02:56:50 <merijn> I agree that GHC errors aren't ideal, otoh, they aren't terrible either
02:57:14 <pharaun> ^, anyway pb like i said the channel is usually pretty helpful :)
02:57:18 <pharaun> its how i got used to the type errors
02:58:12 <scripty> In other functional languages i feel error pretty helpful to understand what is going wrong i just started haskell now i feel wht heck is this :(
02:59:22 <scripty> min 7 -5 gives an error and i didnt understand
02:59:28 <merijn> scripty: oh
02:59:32 <pharaun> oh
02:59:36 <merijn> scripty: I can guess what that is
02:59:41 <quchen> The good old "-" issue.
02:59:44 <pharaun> scripty: min 7 (-5)
02:59:45 <pharaun> yeah
02:59:51 <pharaun> bite me in the arse the first time :)
03:00:15 <quchen> min 7 -5  ≡  (min 7) - 5
03:00:40 <merijn> scripty: It thinks you meant "(min 7) - 5" and complains that functions (min 7) aren't numbers
03:00:43 <quchen> min 7 (-5)  ≡  (-5)
03:00:45 <pharaun> i forgot why the parser has issues with that one
03:01:42 <merijn> The parsing of - is really dumb sometimes...
03:01:46 <quchen> pharaun: "-" has a special grammar rule for negative numbers so that (-3) is not a section for subtracting 3, and describes a negative number instead.
03:02:11 <scripty> what if i do this succ -9  error
03:02:15 <merijn> Sometimes I think we would've been better of if subtraction had a different operator than -
03:02:18 <Hafydd> Oh, I suppose that makes ~ as unary negation more senseible.
03:02:22 <donri> honestly i wish whitespace was required around operators and that we could have special characters in normal identifiers :p
03:02:30 <donri> go agda ;)
03:02:33 <merijn> donri: word
03:02:44 <merijn> donri: Lisp style question marks in identifiers <3
03:02:50 <quchen> scripty: that is  succ - (9 error)
03:02:53 <pharaun> hehe i tend to like whitespace around operators *shrugs*
03:03:05 <donri> merijn: lisp style hyphenation <3
03:03:28 <merijn> donri: Though I'm afraid that breaks too much code to ever happen
03:03:35 <donri> merijn: quite
03:03:40 <scripty> i'm just not getting it
03:03:57 <donri> merijn: but i did discover yesterday that you can create such identifiers with TH ;)
03:04:00 <merijn> scripty: The problem is with the minus, it's an artifact of an unfortunate design decisions years ago
03:04:13 <donri> merijn: works with haddock and everything but you can't refer to them without TH :D
03:04:36 <Hafydd> . o O ( 0-x )
03:04:38 <pharaun> scripty: so as a rule of thumb if you don't intend minus just make sure to () your negative number
03:04:43 <quchen> scripty: "f -3" does not stand for "apply f to negative 3" as you might expect, but parses as "f - 3", standing for "subtract 3 from this function", which is why the compiler complains.
03:05:11 <quchen> scripty: If you want to apply f to -3, add parentheses.
03:05:16 <quchen> > min 7 (-5)
03:05:17 <lambdabot>   -5
03:05:28 <donri> > min 7 $ 0 - 5
03:05:30 <lambdabot>   -5
03:05:44 <merijn> > min 7 3 -5
03:05:45 <lambdabot>   -2
03:05:51 <donri> :P
03:06:27 <pharaun> > min 7 -4
03:06:29 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
03:06:29 <lambdabot>    arising from a use ...
03:06:36 <pharaun> scripty: ^ look familiar ?
03:06:56 <donri> > 7 `min` 0-5
03:06:57 <lambdabot>   -5
03:06:58 <merijn> pharaun: No, because that's lambdabot's unhelpful error trying to display functions
03:07:06 <quchen> pharaun: I think his error is more like "No instance Num".
03:07:11 <pharaun> oh?
03:07:17 <pharaun> :|
03:07:21 <donri> :t min 7 -5
03:07:22 <lambdabot> (Num (a -> a), Num a, Ord a) => a -> a
03:07:23 <pharaun> nvm :)
03:07:38 <pharaun> yeah just got 3 type error, ord stuff :)
03:07:39 <pharaun> my bad
03:08:12 <Hafydd> min 7 $ negate 5
03:08:55 <scripty>  No instance for (Num (a0 -> a0)) arising from a use of `-'
03:08:55 <scripty>     Possible fix: add an instance declaration for (Num (a0 -> a0))
03:08:55 <scripty>     In the expression: min 7 - 4
03:08:55 <scripty>     In an equation for `it': it = min 7 - 4
03:09:52 <scripty> how come a beginner can understand from this error :?
03:10:05 <donri> scripty: they can't; this is one of the stupid parts of haskell
03:10:10 <merijn> scripty: It's an unfortunate issue with the way numbers work
03:10:13 <pharaun> btw scripty next time plz pb -> lpaste.net :) but yeah
03:10:50 <pharaun> scripty: yeah these errors can be a bit rough, i know i've had rough days dealing with some of them but it *really* does get easier as you get more comfortable with the language and etc
03:11:13 <merijn> scripty: It's parsing "min 7 -4" as "(min 7) - (4)", and since numbers are polymorphic ("4 :: Num a => a", i.e. 4 can be any numeric) it's complaining that functions (i.e. "min 7" aren't an instance of Num)
03:11:25 <quchen> scripty: As a take-away message, "No instance Num" usually means it's very unrelated to Num, and you can ask this channel.
03:11:41 <donri> heh
03:11:58 <pharaun> i *think* i've had it related to num once ;p
03:12:01 <donri> :t min (7 :: Int) -5
03:12:02 <lambdabot>     No instance for (Num (Int -> Int)) arising from a use of `-'
03:12:02 <lambdabot>     Possible fix: add an instance declaration for (Num (Int -> Int))
03:12:02 <lambdabot>     In the expression: min (7 :: Int) - 5
03:13:13 <donri> probably ghc could add more helpful error messages special cased for this situation
03:13:26 <donri> it already does special casing for some error messages like function arities
03:13:34 <scripty> i have no clue on what is polymorphic is merijn
03:14:12 <pharaun> scripty: there are a few type of Num such as - Integer, Float, etc...
03:14:34 <pharaun> :t min (7 :: Float) -5
03:14:34 <lambdabot>     No instance for (Num (Float -> Float)) arising from a use of `-'
03:14:35 <lambdabot>     Possible fix:
03:14:35 <lambdabot>       add an instance declaration for (Num (Float -> Float))
03:14:56 <donri> :t min 7 - (5 :: Int)
03:14:57 <lambdabot>     Couldn't match expected type `a0 -> a0' with actual type `Int'
03:14:57 <lambdabot>     In the second argument of `(-)', namely `(5 :: Int)'
03:14:57 <lambdabot>     In the expression: min 7 - (5 :: Int)
03:15:15 <chrisdone> scripty: poly - many, morphic - having form. polymorphism in haskell means not being concrete. the function of type a -> a is polymorphic, whereas Int -> Int or Char -> Char are concrete.
03:16:33 <pharaun> scripty: a -> [a] -> [a] -- This could be a function that takes one element of A type and add it to a list of A types, so you can have a list of Int, list of HttpRequest/whatever, etc
03:16:44 <merijn> scripty: Numbers can be many things, Int, Fractions, Complex numbers, rationals, etc.
03:16:47 <merijn> > 4 :: Int
03:16:48 <lambdabot>   4
03:16:51 <merijn> > 4 :: Double
03:16:52 <lambdabot>   4.0
03:17:30 <Iceland_jack> > 4 :: Ratio
03:17:31 <lambdabot>   Expecting one more argument to `GHC.Real.Ratio'
03:17:42 <pharaun> > 4 % 6
03:17:43 <lambdabot>   2 % 3
03:18:04 <chrisdone> scripty: has a haskell newb, what information can you garner out of “(Num (a0 -> a0))”?
03:18:09 <Iceland_jack> > 5 :: Rational
03:18:10 <lambdabot>   5 % 1
03:19:45 <donri> chrisdone: "it isn't working halp"
03:21:00 <Iceland_jack> chrisdone: It means you're treating a function as a number
03:21:00 <Iceland_jack> > succ + 2
03:21:02 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
03:21:02 <lambdabot>    arising from a use ...
03:21:17 <Iceland_jack> @ty succ + 2
03:21:17 <lambdabot> (Enum a, Num (a -> a)) => a -> a
03:23:17 <chrisdone> Iceland_jack: i know what it means. but scripty isn't replying anymore, so nevermind
03:25:14 <scripty>  I never knew polymorphism is applied on numbers , i know its applied on method / function , but this is somewhat new to me :/
03:26:42 <dwcook> @type 10
03:26:42 <lambdabot> Num a => a
03:27:11 <dwcook> That says that 10 is a value of any type with a Num instance.
03:28:33 <Iceland_jack> scripty: They're called polymorphic constants in this case, you can also use it for other things
03:28:38 <Iceland_jack> > maxBound :: Char
03:28:39 <lambdabot>   '\1114111'
03:28:40 <Iceland_jack> > maxBound :: Int
03:28:41 <lambdabot>   2147483647
03:31:10 <exFalso> Hi, how do I debug multithreaded programs with ghci? I basically want it to break on exceptions, however only the throwing thread stops. Is there a way to make the others stop as well?
03:31:19 <scripty> i guess i need time btw
03:32:39 <merijn> exFalso: What do you mean by "stop"?
03:34:02 <exFalso> merijn: not sure how thats disambiguous...
03:34:41 <pharaun> exFalso: oh when thread 1 dies youw ant all of the other thread to die as well?
03:34:41 <exFalso> *ambiguous:)
03:34:44 <pharaun> so they don't linger around?
03:35:25 <exFalso> pharaun: I want the execution to break so that i can inspect the throwing thread's state and then resume
03:37:35 <Clinteger> oops Clint sorry about that name confusion :)
03:37:46 <Clint> what
03:38:17 <merijn> exFalso: I'm not sure there is a pause mechanism for threads
03:38:58 <exFalso> the problem is that the first exception is caught (but ghci breaks anyway) and while i'm resuming the exception that i'm actually interested in has already been thrown by another thread
03:39:33 <merijn> tbh I'm not really familiar with how ghci deals with threads
03:41:04 <exFalso> grr haskell exceptions are a pain
03:43:02 <Clinteger> Clint I got highlighted a few times, people were trying to talk to you. though I assume you saw
03:43:23 <Clint> ah
03:48:16 <mstksg> and my three day long journey/headache of getting my web app to deploy is finally complete.
03:48:35 <merijn> mstksg: \o/
03:48:54 <mstksg> merijn: thanks
03:48:59 <mstksg> now just to automate it haha
03:49:11 <donri> Cl(forall a. Num a => a)
03:50:49 <mstksg> this is one case where "i won't go to sleep until i finish this" ended with a reasonable result.
03:50:52 <mstksg> one case of very few.
03:50:53 <mstksg> good night all.
03:56:58 <hFreshman> Hello?
03:57:44 <mauke> hFreshman: hello
04:02:31 <shiona> is there a mapMaybe for sets somewhere?
04:04:35 <int-e> shiona: do the operation on lists and wedge it between fromList and toList. The set has to be rebuilt anyway because the order of elements may change.
04:10:26 <shiona> int-e: ok
04:31:56 <paolino> hello, I cannot understand  this problem http://lpaste.net/92943, I think it has to do with the Functor f => not appearing but it's beyond my knowledge
04:38:28 <supki> paolino: well, SimpleLens type synonym expansion is rank-2 type
04:38:50 <supki> btw, Simple* is deprecated
04:38:54 <paolino> Lens also
04:38:58 <supki> yes
04:39:22 <supki> you need -XRank2Type enabled for them to typecheck
04:40:02 <paolino> ok, I though there was an error
04:40:42 <paolino> why Simple* is deprecated ?
04:40:47 <paolino> too simple ?
04:41:24 <supki> too long to type I think
04:41:31 <supki> Lens' is current way to say SimpleLens
04:41:54 <paolino> ah, thanks
04:42:28 <paolino> now I see the '\'' in the hint
04:45:29 <Thulsadum> i realy have problems unterstanding monads. well, i understand it's definition, but i don't get how it benefits to haskell the way it does.
04:47:01 <Thulsadum> or put it that way, I understand the Identiy, Maybe monad and partialy the IO monad, but the state monad is to much for me :D
04:47:52 <paolino> Thulsadum, it takes sometime btw
04:48:58 <paolino> maybe the Reader is somewhat an easier concept
04:49:21 <Thulsadum> yeah, but I need some simple examples to learn from
04:49:42 <Thulsadum> ah, thanks I'll have a look into that
04:49:50 <k00mi> Thulsadum: one benefit is that you can write functions over all monads (such as mapM)
04:51:18 <paolino> for the Reader just try to implement 'ask'
04:52:12 <mauke> :t ask `asTypeOf` asks
04:52:13 <lambdabot> (r -> a) -> r -> a
04:52:31 <Thulsadum> ok, thanks for the information. I'll have a look into that after lunch. brb.
04:52:58 <mauke> :t id `asTypeOf` ask `asTypeOf` asks `asTypeOf` ($)
04:52:58 <lambdabot> (r -> a) -> r -> a
04:53:47 <paolino> :t asTypeOf
04:53:48 <lambdabot> a -> a -> a
05:11:06 <quchen> :t [id, ask, asks, ($), local] -- Yeah, that one as well
05:11:07 <lambdabot> MonadReader (m a) m => [(m a -> m a) -> m a -> m a]
05:16:22 <quchen> mauke: I think someone mentioned you being the wizard of abusing RebindableSyntax, got any examples handy? :-)
05:17:49 <hiptobecubic> go ##c
05:17:50 <merijn> quchen: mauke is the wizard of any form of syntax and preprocessor abuse
05:17:55 <hiptobecubic> ugh
05:18:11 <quchen> merijn: Proof? :-D
05:27:20 <paolino> :t findMax
05:27:21 <lambdabot>     Not in scope: `findMax'
05:27:21 <lambdabot>     Perhaps you meant one of these:
05:27:21 <lambdabot>       `IM.findMax' (imported from Data.IntMap),
05:28:15 <paolino> how do I get next free key in a Map , to insert a new value ?
05:28:41 <quchen> There's no general way. "next" is "succ" which needs Enum.
05:28:56 <quchen> Map only requires Ord, not Enum.
05:29:39 <paolino> for IntMap ?
05:29:44 <paolino> or Map Int
05:29:46 <paolino> ?
05:29:54 <jmcarthur_mobile> Is there no getMax sort of thing for map? I think there is one for set.
05:30:05 <quchen> For Map. In case of IntMap you have the Enum instance for the keys though of course.
05:30:26 <jmcarthur_mobile> Not exactly what you asked for, but should work for a large enough domain
05:30:38 <merijn> jmcarthur_mobile: I believe there is
05:30:38 <a3f> Is building dll's out of haskell modules broken? It can compile the dll fine but linking against it gives me errors
05:31:05 <quchen> findMax should give you the maximal key for an IntMap though.
05:31:55 <a3f> I am following the example in the official docs but it throws an compile error about multiple declaration of main :/
05:31:57 <quchen> (That's what Lambdabot suggested, but I thought you asked for the general case of Map.)
05:33:55 <paolino>  thanks, I will go with it, a firstFree would be useful, but I see there is no way for it
05:34:39 <merijn> paolino: Well, there is, but it'd be O(n)
05:34:49 <merijn> paolino: Assuming you have an Enum keytype
05:34:49 <quchen> merijn: So is findMax
05:35:00 <merijn> quchen: eh, no
05:35:10 <merijn> quchen: findMax should be O(log n) in Map
05:35:15 <merijn> Map's are sorted
05:35:25 <merijn> hence the Ord constraint
05:35:41 <quchen> That's not what the docs say though
05:35:48 <quchen> O(min(n,W)). The minimal key of the map.
05:35:52 <quchen> ^ in quotes.
05:36:05 <merijn> quchen: W is the bits of Int
05:36:12 <merijn> quchen: That's even less than O(log n)
05:36:19 <quchen> Oh.
05:36:25 <quchen> That makes sense
05:36:43 <merijn> Else why would anyone use IntMap :)
05:37:16 <merijn> quchen: Quote from the start "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)"
05:38:04 <merijn> And Data.Map has findMin/findMax with O(log n)
05:38:33 <a3f> someone tried compiling a module into a dll recently ?
05:39:00 <H1FuelCell> I was worried the discussions in #laravel slipped out of my grasp of understanding - then noticed where I was
05:39:20 <H1FuelCell> keep \m/-ing gentlemen
05:39:23 <merijn> a3f: You might wanna try StackOverflow/mailing list with windows specific questions, there's a bigger likelihood of experienced windows users seeing them there
05:40:01 <a3f> ah ok, i wanted to check here first before formulating a full question there
05:40:03 <a3f> thanks
05:40:20 <merijn> a3f: Not that you can't ask them here, but the density of windows users is not very big here, so there might not be anyone around that knows how to answer/troubleshoot your issue
05:40:52 <merijn> a3f: Another idea would be to ask again during peak times when there's more people around
05:41:32 <a3f> That would be when ? not really sure where the biggest userbase for haskell is
05:42:00 <merijn> a3f: Between 20 and 23 UTC, apparently: http://ircbrowse.net/
05:43:09 <a3f> ah ok, i will check back later then
05:59:00 <Technoman> Prepare for the Worst: a real Prophet saw the endtimes in multiple Visions: The Pre-Sign before the wordwide Stock  Market Collaps are "S&P downgrades Malaysia", when you see this in your TV , then buy food supplies: Watch my  genuine Visions here : http://worldwen.vs120101.hl-users.com/?p=4674
05:59:18 <mauke> quchen: https://raw.github.com/mauke/poly.poly/master/poly.poly ?
05:59:51 <quchen> mauke: Wat. That looks like "head /dev/urandom".
05:59:57 <quchen> Is that a single source file?
06:00:02 <mauke> yes
06:00:29 <quchen> Ah, "poly" for "polyglots"
06:00:33 <quchen> Now it makes more sense
06:02:47 <quchen> Speaking of excessive use of \ in code, I randomly stumbled upon the multiline-string-syntax part in the Haskell report yesterday.
06:03:20 <quchen> All the time I've explicitly concatenated my stuff when lines were too long, haha.
06:04:07 <magicman> Just the Haskell bit of that with the language pragma detection is neat.
06:04:24 <magicman> And by that I mean "Take this one bit, and it's still neat." not "That's the only neat bit".
06:05:52 <merijn> quchen: Told you he was a master of syntax and preprocessor abuse :p
06:06:23 <quchen> merijn: I don't see abuse, I just see noise. I'm still interpreting, I'll get back to you guys after I found out what the heck is going on there ;-)
06:06:44 <merijn> quchen: Define abuse then?
06:07:03 <quchen> I was just joking.
06:08:46 <quchen>  > bangPatterns = [True] ! 0 where foo !bar = False
06:08:50 <quchen> My head
06:09:26 <quchen> This line alone is just great
06:09:33 <magicman> Also, the MagicHash one.
06:09:55 <quchen> magicman: I don't know about magic hashes though.
06:10:06 <quchen> >> looks promising as well.
06:10:30 <int-e> quchen: you can write   where  _!_ = False   :-)
06:10:46 <quchen> _!_?
06:10:50 <quchen> Strict bottom?
06:11:04 <magicman> The extension allows # as part of any identifier, not just as part of an infix identifier. That's all it does.
06:11:20 <int-e> > let _!_ = False in [True] ! 0
06:11:21 <lambdabot>   <hint>:1:5: Parse error in pattern: _
06:11:30 <int-e> meh?
06:11:47 <quchen> Oh, you need spaces there.
06:11:51 <quchen> _ is a letter after all.
06:12:19 <mauke> int-e: I think that's turning into a destructuring bind, not a function definition
06:13:07 <quchen> How does that one work?   overloadedStrings = "" /= ""
06:13:08 <int-e> mauke: right. my bad. quchen's code doesn't really work like that.
06:13:52 <mauke> quchen: look for default
06:14:11 <quchen> "" is either "" (normal) or `fromString ""` (overloaded strings), no?
06:14:52 <quchen> mauke: Oooooh
06:14:53 <quchen> Wow :-D
06:15:05 <quchen> Hidden in the import list, you monster
06:15:56 <quchen> Boy that file is good
06:16:09 <quchen> Is the C/Brainfuck/... stuff as good or is it in a different style
06:16:34 <kuribas> I am trying to parallelize my code.  I only get a 50% speedup with two cores for my function.  Is that even worth it?
06:16:45 <kuribas> (using the eval monad)
06:17:25 <quchen> 50 % is 150 % as fast as your normal program.
06:17:43 <zomg> 50% is pretty significant...
06:17:53 <mauke> quchen: the C/C++ stuff is slightly interesting; the brainfuck code does no feature detection (I mean, what features?)
06:18:04 <kuribas> quchen: Only for my function, not the whole program
06:18:25 <quchen> mauke: Brainfuck can detect a lot of things! How is integer overflow handled? Is the tape infinite (this one is challenging)?
06:19:00 <kuribas> I was hoping for 100% or 90% :)
06:19:09 <quchen> mauke: When you say "slightly interesting" is that a humble way of saying it, ir is the Haskell the highlight
06:19:18 <kuribas> Probably being to optimistic.
06:19:19 <quchen> kuribas: You never get 100% speedup with two cores.
06:19:25 <int-e> quchen: too bad a lot of things require a program to predict whether it will terminate
06:19:49 <mauke> quchen: it's all trivial :-)
06:19:56 <quchen> int-e: That's why I said it's challenging
06:20:06 <quchen> mauke: Accept your crown, stop resisting
06:20:19 <int-e> what does - do? (there are a few implementations that simply refuse to decrement zero)
06:21:15 <bscarlet> kuribas: whether or not it's worth it depends on external factors. Is 50% speedup good for a first attempt at parallelizing a particular thing? Yes, IMHO.
06:21:27 <quchen> Originally the tape was full of bytes I think, so only 0-255 were allowed.
06:21:54 <int-e> quchen: yes, but - on 0 would result in 255.
06:22:11 <quchen> int-e: That's up to the implementation.
06:22:20 <int-e> quchen: originally.
06:22:36 <merijn> kuribas, bscarlet: Also depends on the initial absolute runtime and how fast the code actually needs to be...
06:22:55 <kuribas> merijn: I used criterion to test the particular function.
06:23:20 <kuribas> That eliminates initial runtime.
06:23:37 <merijn> kuribas: I meant "what is the initial absolute runtime before you parallelized"
06:23:42 <cschneid> kuribas: the newish book Parallel and Concurrent Programming in Haskell is pretty good at explaining all the various bits of this, including what you can reasonably expect. http://chimera.labs.oreilly.com/books/1230000000929
06:23:54 <cschneid> and how to debug parts of it and get an idea of what's really happening in the app
06:23:56 <merijn> 50% on a process lasting 10 hours is more relevant than speed up on a piece of code that only took 50 ms
06:23:58 <kuribas> cschneid: Yes, I am reading it now :)
06:24:13 <kuribas> It may matter for realtime code too.
06:24:24 <chrisdone> merijn: indeed
06:24:42 <kuribas> merijn: The change was rather trivial.
06:24:55 <merijn> kuribas: Yes, but without you telling us what your usecase/goal/whatever is, it's kinda hard to say whether it "was worth it"
06:25:06 <kuribas> It's a library for manipulating bezier curves.
06:25:45 <kuribas> This particular function generates a piecewise approximation of an outline with tolerance.
06:27:00 <kuribas> merijn: I may use it for realtime if it is fast enough.
06:27:23 <kuribas> for example dragging a curve, and generating the outline.
06:28:08 <cschneid> kuribas: sounds like a good candidate for optimization then. Both parallelism and also the normal kind.  Maybe go figure out how to hunt down the sequential parts of the function that are keeping your speedup down to 50%.
06:28:45 <cschneid> kuribas: if I remember the book right, 80%ish speedup going from 1->2 cores was pretty typical. But of course lots of it depends on your problem, and how much is truely parallelisable.
06:29:52 <kuribas> yes
06:30:26 <kuribas> It's recursively subdevides until the required precision, so that should be good for optimization.
06:30:46 <cschneid> kuribas: (I've only read the book, not really played with code much).
06:31:15 <cschneid> kuribas: if I remember right, what kills speedup percents was serial code. ie, splitting up a problem in one thread before spawning a bunch to do the work.
06:31:55 <merijn> kuribas: Yes, but what sort of realtime? Realtime animation? How many FPS? etc.
06:32:05 <kuribas> I don't think that's happening in my code though.
06:32:18 <kuribas> merijn:   <kuribas> for example dragging a curve, and generating the outline.
06:32:32 <merijn> kuribas: My point is, without a baseline "it needs to be this fast" there's no way to specify whether it is fast enough and/or worth it
06:32:39 <kuribas> That's true.
06:32:46 <merijn> kuribas: ok, so that'd probably get by with like 10FPS or so
06:33:04 <merijn> More would be prefferable, but like 10-40 FPS would probably be plenty
06:34:06 <chrisdone> preferable
06:34:55 <merijn> So basically if rendering takes, say 1/30-1/60 of a second (build in some slack for all sorts of other overhead), you're probably plenty fast
06:39:26 <shiona> more stupid questions: is there a nice way of getting a cross product of two sets with a given function?
06:40:23 <Thulsadum> shiona: list comprehension might do that: [(x,y) | x <- xs, y <- ys]
06:40:49 <shiona> yeah, so again I'll make the most of toList and fromList?
06:41:15 <sipa> fromAscList even, if xs and ys are already sorted :)
06:42:04 <shiona> I don't think I can make sure
06:42:38 <chrisdone> @faq can haskell make the sun come out?
06:42:39 <lambdabot> The answer is: Yes! Haskell can do that.
06:42:49 <merijn> chrisdone: Not over here it can't >.>
06:44:11 <bscarlet> merijn: He didn't say how long it would take...
06:44:47 <chrisdone> it's lazy sun
06:44:54 <chrisdone> run outside and look up and it will appear =p
06:45:34 <merijn> chrisdone: Already tried that
06:45:34 <pjdelport> shiona: f <$> xs <*> ys ?
06:46:46 * hackagebot hscrtmpl 1.1 - Haskell shell script template  http://hackage.haskell.org/package/hscrtmpl-1.1 (DinoMorelli)
06:50:10 <shiona> pjdelport: is set applicative?
06:50:46 <applicative> no
06:50:49 <merijn> shiona: No, it's not even Functor
06:52:03 <applicative> mapping over a set is a somewhat dubious concept if you think what 'Set' means in this context
06:52:46 <shiona> well mapping over a set isn't. at least to me. but whatever this cross product thing is is
06:53:27 <applicative> you can define setmap :: Ord a, Ord b  => (a -> b) -> Set a -> Set b easily enough
06:53:39 <mmathis> I was writing some haskell once, and found a thing that analyzes haskell code and gives you suggestions on how to make it better. Anyone know what that is off the top of their head?
06:53:42 <shiona> there is such function in set already
06:53:42 <applicative> but then it will occur to you that you probably shouldn't have been using Set
06:54:13 <shiona> mmathis: hlint?
06:54:19 <mmathis> yes, that's it
06:54:22 <mmathis> ty shiona <3
06:54:26 <applicative> shiona: yes, and it is generally not rational to use it
06:54:26 <shiona> np
06:54:32 <merijn> You could define the cross product is a double fold
06:54:45 <applicative> the order that existed in the Set you are mapping out of is completely lost.
06:55:05 <applicative> you should have been using e.g. fromList (map f xs) if you want to end up with a Set
06:55:21 <shiona> applicative: your statement is noted, but for now I will continue using it. Maybe if I get my code to a usable state I will let you point out my flaws
06:55:42 <applicative> but what are you looking for now?
06:55:57 <Sculptor> hi
06:56:07 <applicative> hi Sculptor !
06:56:11 <Lethalman> shiona, just to say, you aren't completely wrong, it's just that Functor you find in haskell does not take in account constraints
06:56:27 <shiona> applicative: In short I'm doing parallel composition of labeled transition systems
06:56:53 <shiona> if you want it as a longer version I can try writing it out tonight, but at the moment I'm in train and the network is horrible
06:57:14 <Sculptor> hi applicative
06:57:20 <applicative> Lethalman: still, its sensible to do this with Set, why would I want to destroy the complicated sorting and thinning that goes into Set construction all at once by applying a function, which doesn't respect order
06:58:09 <Lethalman> applicative, well, as long as some laws are respected maybe
06:58:15 <applicative> a class for monotonic functions would make sense of this. But it doesn't seem like it would be very usable
06:59:43 <shiona> applicative: I have data (states) that is most sensible to store as a set (need to run unions on it), but I also need to have a function (transitions) run over all the states so I get to new states. These also, in my opinion, should be in sets since I will again be doing unions on them
07:00:21 <shiona> I could manually fromList . map f . toList. But I guess that's what the Set.map is already doing for me
07:01:19 <applicative> yes.  mapmonotonic does something different, if i understand, but it presupposes a monotonic function
07:01:42 <shiona> yes. I think I cannot provide that
07:01:52 <shiona> but I guess I'll have to think about it
07:02:12 <applicative> this strongly suggests that you don't want Set, but I don't know
07:06:48 * hackagebot cblrepo 0.9.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.9.1 (MagnusTherning)
07:07:00 <magicman> Eh. (Ord a, Ord b) => Set a -> Set b -> Set (a,b) makes sense.
07:08:24 <applicative> yes for sure
07:08:26 <int-e> true, that's  foo sa sb = mapMonotonic (\a -> mapMonotonic ((,) a) sb) sa
07:08:55 <int-e> almost ;-)
07:09:24 <DanC__> any suggestion for streaming large amounts of data from one database to another?
07:09:59 <DanC__> the connection reader monad pattern won't work, since the value to be computed from the source DB doesn't fit in memory
07:10:10 <applicative> is this a question about databases or about streaming large amounts of data
07:10:10 <magicman> Yeah, needs more join, but that won't make use of the fact that it can 'just' splice in the sub-sets, because the order is respected, and there are no sudden equal elements.
07:10:46 <DanC__> I don't know enough to be sure which, applicative
07:11:22 <DanC__> I know that one of the complications is that both DBs have to be open for the whole transaction
07:11:40 <danilo2_> Hi! Is it possible to print the GHC AST from Haskell code?
07:12:01 <applicative> which AST?
07:12:38 <danilo2_> applicative: I mean - I have Haskell code and I woudl love to see the Haskell's AST generated by the GHC Parser, if it is possible
07:12:58 <mauke> there are a few -ddump options somewhere
07:13:04 <applicative> i don't know all the ways you can intervene at different stages
07:13:13 <applicative> yes
07:13:23 <applicative> for core there is -ddump-simpl
07:13:40 <applicative> or one of the prettified versions, i seem to be using
07:13:41 <applicative> ghc -O2 -ddump-prep -dppr-case-as-let  -ddump-simpl -dsuppress-module-prefixes
07:13:43 <applicative> by default
07:14:13 <applicative> danilo2_: but it sounds like you want something a bit earlier
07:14:29 <danilo2_> applicative: I'll check it out :) Thank oyu :)
07:14:47 * zammy is away: I'm busy
07:14:52 <applicative> danilo2_: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/options-debugging.html
07:15:07 <applicative> there is e.g. --ddump-ds which could be interesting
07:15:33 <danilo2_> applicative: after mauke's coment I found this site - it seems it has a lot of useful options :)
07:16:05 <Lethalman> -ddump-parsed?
07:16:27 <Lethalman> -ddump-rn also
07:16:50 <applicative> hah the top of the page says
07:16:51 <applicative> HACKER TERRITORY. HACKER TERRITORY. (You were warned.)
07:17:13 <Yaniel> Area 0xDEADBEEF
07:17:37 * DanC__ wonders if applicative has any more thoughts on streaming from one DB to another
07:18:19 <applicative> later someone gives the example of -ddump-ds on skip2 m = m : skip2 (m+2)
07:18:31 <applicative> and comments, (“It's just a simple functional language” is an unregisterised trademark of Peyton Jones Enterprises, plc.)
07:18:45 <magicman> ... I just realized something about that polyglottal piece. In order for it to be valid brainfuck, every +-<>., in other source code must be kept into account. That is wonderful o_o
07:18:58 <magicman> Oh, and []
07:19:25 <applicative> polyglottal piece?
07:19:25 <merijn> magicman: Did you see the multi-quine by a Ruby hacker I forgot the name of?
07:19:33 * zammy is away: I'm busy
07:19:40 * zammy is back (gone 00:00:03)
07:19:45 <applicative> thanks zammy
07:19:56 <magicman> applicative: https://raw.github.com/mauke/poly.poly/master/poly.poly (by mauke)
07:20:11 <magicman> merijn: Is that the one that cycles between 7 languages or so?
07:20:14 <applicative> haha, i was going to say, *is mauke behind this?*
07:21:07 <merijn> magicman: 50
07:21:09 <quchen> magicman: Not fully. [-][ .,,,...+++- ]   ← the second thing is a multiline comment.
07:21:30 <merijn> Ah, quchen just found me the link I was looking for :)
07:21:31 <merijn> https://github.com/mame/quine-relay
07:21:34 <quchen> The first loop resets the counter to zero, the second is never entered.
07:21:36 <quchen> Anyway, OT.
07:21:49 * hackagebot haeredes 0.2.0 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.2.0 (MichaelOrlitzky)
07:23:33 <applicative> hah, I was going to say, 'surely this isn't a whitespace program' but wspace mauke.ws says 'I am a whitespace program'
07:23:51 <quchen> That explains the crazy               \
07:24:01 <mauke> quchen: the backslashes are for make, actually
07:24:10 <applicative> it does actually explain a lot
07:24:16 <quchen> mauke: I was more referring to the spaces there
07:24:28 <quchen> mauke: Wait, make alone?
07:24:28 <mauke> yes, those are code
07:24:34 <mauke> make -f poly.poly
07:24:34 <quchen> Or make to make C
07:24:45 <quchen> What the fuck.
07:24:58 <quchen> Is there a list of languages not supported by your program?
07:25:07 <applicative> hahahaha
07:25:08 <quchen> Malbolge maybe? (Not even sure about that.)
07:25:09 <mauke> quchen: http://youtu.be/ygr5AHufBN4
07:25:23 <quchen> Can I make a screenshot of the source and run it as Piet?
07:26:09 <magicman> If you save it as font file, and use that to read it, sure <_< >_>
07:26:31 <mauke> quchen: https://github.com/mauke/poly.poly/blob/master/t/chk.t is the closest thing
07:26:35 <quchen> mauke: But seriously, what languages are in there?
07:26:49 * hackagebot jacobi-roots 0.2.0.1 - Roots of two shifted Jacobi polynomials (Legendre and Radau) to double precision  http://hackage.haskell.org/package/jacobi-roots-0.2.0.1 (GregHorn)
07:27:14 <quchen> Ah, I see.
07:27:42 <merijn> See, I can never decide whether mauke 1) is a super-genius, 2) just has a lot of spare time or 3) is a bored AI of superhuman intelligence running in some US military research lab
07:28:18 <merijn> or 4) all of the above
07:28:36 <quchen> Was about to say "there's an && in at least one position there" ;-)
07:28:45 <mauke> super-genius? I don't even understand arrows or lenses
07:29:03 <edwardk> neither do i
07:29:09 <merijn> No one does
07:29:16 <quchen> Lenses don't have much to do with genius. You need to be edwardk level for that.
07:29:20 <merijn> edwardk just relies on the type checker to tell him what works :p
07:29:24 <Philippa> can anyone even be arsed sending that to HWN?
07:29:26 <edwardk> I'm pretty much throwing paint at a wall and seeing if it typechecks.
07:29:36 <mauke> merijn: and when it doesn't: unsafeCoerce
07:29:38 <quchen> Philippa: ?
07:29:41 <Philippa> edwardk: *nod*. Often the best way
07:29:49 <Philippa> quchen: Quote of the Week bait
07:29:51 <merijn> Philippa: I can barely be arsed to check HWN to see if I'm funny enough to make it that week ;)
07:30:18 <Philippa> merijn: eh. Myself I actively try not to, but then there were certain trends in what people'd quote coming from me...
07:30:23 <quchen> Philippa: I think he just greps the logs for "@-remember" things.
07:30:36 <quchen> So do that to win a chance to get into HWN I guess.
07:31:09 <Philippa> quchen: I'm not worried about how to get myself quoted. Been there, done that, usually for something involving horrific sexual imagery (and no quoting that, folks)
07:31:17 <merijn> quchen: I don't think so, it had a bunch of stuff from me that's not @remembered
07:31:19 <applicative> somehow they rarely seem to be funny; i guess mostly by depending on more context than @remember can take in
07:31:24 <mauke> poly.poly started out as a simple counterexample to "C++ is a superset of C (or at least of all C that's valid C++)!"
07:31:35 <merijn> I know this, because I obsessively check my quotes :p
07:31:42 <mauke> then came C99 feature detection
07:31:52 <mauke> then other languages, bit by bit
07:32:47 <Itkovian> Ah hi Philippa  :-D
07:32:48 <mauke> python3 was a PITA to integrate. I had to get rid of `...` and completely restructure that part
07:33:03 <Itkovian> It usually was not _that_ horrible iirc
07:33:27 <Philippa> well yeah. Whoever's republishing it has to make sure they're not committing a criminal offence themselves :p
07:34:06 <Philippa> and to be fair, the worst one I remember requires you to know what I was alluding to
07:34:48 <mauke> para-related: http://pingpawn.com/
07:37:23 <ericmoritz> hopefully I won't start a holy war with this but Snap or Yesod?
07:37:35 <ericmoritz> or other...
07:37:46 <donri> ericmoritz: happstack!
07:38:38 <merijn> ericmoritz: Depends ;)
07:38:59 <donri> ericmoritz: use yesod if you want rapid prototyping for content-driven apps
07:39:25 <donri> ericmoritz: use snap if you need to integrate with existing databases and work with non-programmer designers and system administrators
07:39:42 <donri> ericmoritz: use happstack if you want the haskell experience of web dev ;)
07:41:51 * hackagebot jacobi-roots 0.2.0.2 - Roots of two shifted Jacobi polynomials (Legendre and Radau) to double precision  http://hackage.haskell.org/package/jacobi-roots-0.2.0.2 (GregHorn)
07:42:47 <mbrock> I'm playing with an idea for a web app whose main part involves streaming text lines from another network system to/from JavaScript-based clients...
07:43:21 <mbrock> it should be possible to do something elegant with pipes and Server-Sent Events, perhaps...
07:43:32 <mbrock> anyone know of any similar work?
07:43:54 <donri> there's a websockets library...
07:44:11 <mbrock> yeah, I played around with that... I think WebSockets are actually overkill for this
07:44:23 <mbrock> it'd be nicer to keep it pure HTTP
07:44:49 <merijn> You are making me sad :(
07:45:17 <mbrock> me? :(
07:46:51 * hackagebot pandoc-citeproc 0.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.1 (JohnMacFarlane)
07:46:53 * hackagebot snap-blaze 0.2.1.1 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.2.1.1 (JasperVanDerJeugt)
07:46:59 <merijn> Anyone that contemplates using HTTP for any sort of interactive client-to-client protocol makes me sadm
07:47:51 <mbrock> oh, heh... the idea is to have a thin HTTP bridge thing, to let users on from mobile or the library or whatever
07:48:26 <mbrock> like using irssi in screen, but with a web browser instead of ssh :)
07:49:04 <merijn> Why not just use some normal networking protocol for that?
07:49:20 <mbrock> like HTTP? (:
07:49:24 <merijn> Any sensible phone supports native apps that can just do networking...
07:49:39 <merijn> HTTP has no state, no notion of connection and no notion on notifications
07:49:42 <merijn> So no, not HTTP
07:50:05 <merijn> The entire fucking world is using HTTP because it's apparently the only protocol they heard of
07:50:18 <merijn> HTTP is a freaking terrible protocol for anything that is not downloading websites
07:50:27 <merijn> In fact, it's pretty terrible for downloading websites too...
07:51:52 * hackagebot websockets 0.7.4.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.4.1 (JasperVanDerJeugt)
07:55:52 <ijp> merijn: at least it isn't email...
07:59:30 <mbrock> that may be, but my goal is precisely to enable participation with only a web browser, so HTTP it is, for better or worse...
08:00:31 <mbrock> Server-Sent Events + POST requests seem workable for this particular application
08:05:07 <hardliner_> why in c++ channel 400 users, and in haskell channel 1100 users?
08:05:21 <hardliner_> is haskell more popular than c++?
08:05:46 <merijn> hardliner_: #haskell is nicer than the c/c++ channels :)
08:05:51 <Itkovian> hardliner_ here is is :-p
08:05:58 <mauke> C is off-topic in ##c++
08:06:08 <mbrock> perhaps the C++ programmers are busy coding :)
08:06:30 <mauke> do you know geordi?
08:08:31 <dolio> mbrock: Yeah. C++ requires keeping track of a lot more irrelevant details in your programs, so there's less time for IRC.
08:09:09 <Itkovian> besides that, managers are trained with C-programmers, so they think everything takes that much time.
08:10:31 <boothead> Hi Guys, are there any shims for multiplexing pipes together with either? (is this even the right way to think about it?)
08:12:31 <merijn> boothead: pipes-concurrency maybe?
08:14:14 <yesthisisuser> Are there any HaskellDB masters in here?
08:16:35 <Apocalisp> data Foo f a = forall b. (f b) (b -> a)
08:16:45 <Apocalisp> is there a good name for Foo here?
08:17:13 <Apocalisp> I want to say it's a right Kan extension
08:17:52 <dolio> Is the constructor tag after the forall b?
08:18:30 <haasn> Apocalisp: Yoneda
08:18:34 <dolio> Anyhow, it looks like CoYoneda.
08:18:36 <Apocalisp> Coyoneda!
08:18:36 <thoughtpolice> that's CoYoneda
08:18:41 <haasn> oh, yes
08:18:47 <Apocalisp> ok cool
08:18:48 <haasn> http://hackage.haskell.org/packages/archive/kan-extensions/3.1.1/doc/html/Data-Functor-Yoneda-Contravariant.html
08:18:50 <haasn> Apocalisp: ^
08:18:53 <Apocalisp> I don't quite see it though
08:18:54 <haasn> you may not have to write it yourself :)
08:19:03 <thoughtpolice> haasn: it's in Data.Functor.Coyoneda, now
08:19:11 <haasn> thoughtpolice: ah, good to know
08:19:15 <haasn> thoughtpolice: that had always confused me a bit
08:19:21 <Apocalisp> ah ok, I do see it now
08:19:29 <haasn> well, they're pretty similar either way, isomorphic if you have a functor constraint :)
08:19:29 <dolio> Contravariant yoneda is something else, too.
08:19:34 <Apocalisp> thanks guys
08:19:39 <dolio> There's yoneda, coyoneda, and contravariant versions of each.
08:20:25 <dolio> All based on whether you do C -> D, C^op -> D, C -> D^op or C^op -> D^op, I imagine.
08:21:02 <Saizan> btw coyoneda is a left kan extension along identity, so you weren't that far off :)
08:21:07 <haasn> Apocalisp: also isn't that a left kan extension? Foo = Lan Identity
08:21:11 <haasn> yes..
08:25:18 <boothead> merijn, actually just stumbled across Pipes.Monoidal in pipes-code which looks ideal - but old. Any idea if any of that stuff made it into pipes?
08:28:09 <haasn> isn't there a Floating instance for HasResolution a => Fixed a ?
08:29:22 <geekosaur> no, and strictly speaking there can't be because Floating is the transcendantals
08:29:30 <geekosaur> *transcendentals
08:29:58 <haasn> oh, I want BigFloat I think
08:30:04 <ericmoritz> thanks donri
08:34:11 <jfischoff> in general are there any tricks for speeding up syb?
08:36:57 <ocharles> Does anyone know if the state files produced by acid-state are portable?
08:37:14 <ocharles> e.g., can I just copy them between machines without worry?
08:37:57 <merijn> ocharles: I think they are
08:38:06 <merijn> ocharles: They use Binary/Cereal instances, don't they?
08:38:12 <merijn> ocharles: Those should both be portable
08:38:15 <ocharles> no idea, used it for the first time today!
08:38:21 <bitonic-work> is there any way to get the OS pid that a ProcessHandle refers to?
08:38:25 <ocharles> but acid-state is da bomb for whipping up small web sites
08:38:28 <elliott> they use SafeCopy instances
08:38:51 <merijn> elliott: Which internally uses cereal
08:39:00 <ocharles> I have a little application that listens on a RabbitMQ message queue (a queue for "failures"), stores things in acid-state, and uses Snap to let people retry events. All in 240 lines.
08:39:23 <ocharles> knowing acid-state uses safecopy just makes me re-phrase my question as "is safecopy portable?" :)
08:39:26 <elliott> merijn: but it doesn't use the cereal instances. so I win this pedantry round :)
08:40:06 <sclv_> what machines to people ever use that have the opposite byte order?
08:40:21 <sclv_> when does this even come up
08:40:32 <merijn> sclv_: SPARC?
08:40:56 <merijn> motorola chips? What does ARM use?
08:41:00 <sclv_> yeah but sparc is semi dead, no?
08:41:08 <merijn> sclv_: Also, 32bit vs 64bit
08:41:49 <elliott> sclv_: there's network order
08:42:05 <merijn> sclv_: Alpha, PowerPC
08:42:06 <sclv_> yes but who cares for a serialization format, it just needs to be the same in host and target machine
08:42:12 <sclv_> i know that other processors exist
08:42:26 <sclv_> but basically we care about intel and maybe arm
08:42:27 <merijn> (these last two are bi-endian, I think)
08:42:33 <sclv_> and arm is historically little-endian too
08:42:40 <sclv_> (bi-endian now)
08:42:45 <geekosaur> alpha's not bi-endian that I recall; you may be thinking of mips
08:42:48 <merijn> sclv_: That's not enough
08:42:59 <merijn> sclv_: Like I said, 32bit vs 64bit matters for serialisation
08:43:13 <sclv_> like 'it is portable as long as you're not trying to run on a sparc or an old 6800' is fine
08:43:32 <sclv_> merijn: true, you can screw that up too. but that's easier to not screw up
08:43:36 <geekosaur> 32 v 64 is the main thing I'd be worried about
08:43:59 <sclv_> i suppose in haskell the way to do that is just to serialize all Int as 64 bit
08:44:08 <sclv_> i think that's the only architecture dependent size we have in the spec
08:44:09 <merijn> sclv_: If you're gonna bother implementing that portably, the endianess is almost trivial to add too
08:44:18 <sclv_> its a royal PITA tho
08:44:21 <sclv_> performancewise
08:44:42 <sclv_> plus network byte order functions are all f**d up on os x, or have been
08:44:54 <sclv_> you have like htonl but not the converse or something
08:45:08 <Discoloda> I am having trouble making a instance with an array, like `instance MyClass a => [a] where ...`
08:45:40 <merijn> sclv_: Eh, wut
08:45:46 <merijn> sclv_: Yes you do
08:45:56 <Discoloda> i see Eq and Ord have instances like that
08:46:06 <sclv_> i've had trouble with those bindings at least
08:46:13 <sclv_> maybe one is a macro or something.
08:46:25 <merijn> sclv_: Most likely, yes
08:46:32 * sclv_ strangles os x
08:46:35 <Philippa> pointedly disallowing instances for Int might not be a bad idea
08:46:41 <merijn> sclv_: That's very common, not OSX specific
08:46:49 <sclv_> well then
08:46:57 <merijn> sclv_: But rejoice! GHC can FFI bind macro's!
08:46:57 <Philippa> then again: if we had a better module system, reconfiguring Int as needed would be trivial
08:47:09 <merijn> s/macro's/macros
08:47:14 <sclv_> merijn: is that new or did i just not know about it?
08:47:18 <merijn> sclv_: 7.6
08:47:19 <Saizan> Discoloda: those are lists not arrays btw, but you'll need to give us more details like the actual code and what trouble you're havin
08:47:22 <sclv_> oooh
08:47:24 <sclv_> shiny
08:47:37 <Philippa> ("tweak the environment so Int is a type synonym for..." as an outer wrapper around everything else, basically)
08:47:58 <jfischoff> shachaf: is the CoYoneda trick the same trick edwardk is using with folds?
08:48:07 <merijn> sclv_: The new capi ffi does that, for example, see: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L224-L235
08:49:03 <sclv_> so we can bind defines too?
08:49:38 <merijn> sclv_: Yes: "Rather than generating code to call f according to the platform's ABI, we instead call f using the C API defined in the header header.h. Thus f can be called even if it may be defined as a CPP #define rather than a proper function"
08:49:49 <Saizan> jfischoff: yeah, though strictly speaking neither are coyoneda but in haskell they look the same as a proper coyoneda
08:50:00 <merijn> sclv_: "When using capi, it is also possible to import values, rather than functions. For example,"
08:50:08 <merijn> sclv_: See: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ffi.html#ffi-capi
08:50:17 <jfischoff> Saizan: cool
08:50:18 <sclv_> awesome, that eliminates the need for a whole bunch of tools!
08:50:28 <sclv_> would have saved me a chunk of work ~3 years ago
08:51:41 <Saizan> since lan (Identity : Hask -> Hask) would require the other argument to be a functor from Hask too, but here we don't impose that
08:57:01 <quicksilver> merijn: what does that acutally mean? Does it generate a C stub?
09:01:08 <merijn> quicksilver: I think so?
09:01:19 <merijn> quicksilver: I'm just copy pasting the GHC manual >.>
09:01:39 <merijn> quicksilver: I'd have to look at header.h to see what it's actually doing
09:03:14 <TallerGhostWalt> so I got hit with the broken ness on a Data.Aeson update.
09:03:39 <TallerGhostWalt> I have a type data Permission = Read|Write
09:04:00 <TallerGhostWalt> which used to become { read:[]} or {write:[]}
09:04:24 <TallerGhostWalt> but now becomes {tag:"read",contents:"write"}
09:04:39 <TallerGhostWalt> I wrote a custom ToJSON but I can't figure out the fromJSON
09:04:50 <TallerGhostWalt> posting on stack too but I thought someone might have a quick answer
09:10:07 <hardliner_>  happy programmer's day!!!
09:12:26 <Hafydd> What is happy programmer's day?
09:12:52 <donri> day 2⁸ of the year
09:13:37 <Hafydd> What about day 2^7?
09:14:47 <monochrom> also happy programmer's day!
09:15:26 <Hafydd> Are days 1 and 2 also happy programmer's days?
09:15:30 <haasn> every day is happy programmer's day in #haskell
09:15:33 <monochrom> yes!
09:15:34 <Hafydd> Heh!
09:16:58 <monochrom> a wise person once said: if (on day 0 you are a happy programmer, and (for all n, if on day n you are a happy programmer, then on day n+1 you are a happy programmer)), then every day is a happy programmer's day
09:18:02 <mbrock> it all depends on one's day job...
09:18:25 <Kaini> just redefine day 0 if you're unhappy :)
09:18:47 <mbrock> sometimes I have this channel open while browsing around our Java code for complex tree manipulations...
09:19:09 <Sizur> function of function of day day job
09:19:37 <mm_freak_> data _is-happy : ℕ → Set where 0-day-happy : 0 is-happy; n-day-happy : {n : ℕ} → n is-happy → suc n is-happy
09:20:00 <pjdelport> mbrock: i joined today because this legacy PHP code is too depressing to bear alone
09:21:14 <ocharles> mm_freak_: glad to see you're proving happiness. you must be a riot at parties
09:21:15 <ocharles> :P
09:21:37 <mm_freak_> =)
09:21:40 <ocharles> (actually, talking agda would be fantastic party conversation for me, so i'm not necessarily being sarcastic)
09:21:52 <mm_freak_> ocharles: i agree
09:22:09 <mbrock> pjdelport: :) as good a reason as any
09:22:43 <mbrock> one night danr tried to explain free comonads for me on a napkin three beers down
09:22:56 <mbrock> "yeah... that sort of sounds like it makes sense..."
09:23:32 <haasn> other people go out and party on a nice friday evening
09:23:36 <haasn> I /join #haskell
09:23:50 <Sizur> evening is relative
09:23:55 <mbrock> speaking of which, cheers
09:24:01 <joelteon> it's not friday evening, silly
09:24:11 <haasn> to be fair, I only recently woke up
09:24:56 <joelteon> the only way #haskell could be better is if we were all in the same place with alcohol
09:25:56 <mbrock> playing beer golf
09:27:56 <Walther> Can I straight-off print something without assigning it to a "variable"?
09:28:03 <quicksilver> yes of course
09:28:08 <quicksilver> print "something"
09:28:10 <Walther> say, "putStrLn <- take 100 [1..]" or something
09:28:22 <quicksilver> putStrLn (show (take 100 [1..]))
09:28:24 <mm_freak_> Walther: putStrLn (take 100 [1..])
09:28:29 <mm_freak_> uhm
09:28:30 <mm_freak_> yeah
09:28:38 <mm_freak_> or 'print' instead of 'putStrLn'
09:28:42 <quicksilver> or: print (take 100 [1..])
09:28:47 <Walther> great, thanks
09:28:58 <quicksilver> > take 100 [1..]
09:28:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:29:12 <quicksilver> Walther: ^^ lambdabot effectively just calls 'print' on what you type
09:29:18 <quicksilver> that's how it works. Well, roughly.
09:29:26 <haasn> > do putStrLn <- take 100 [1..]; [putStrLn, -putStrLn]
09:29:27 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
09:29:33 <haasn> not the same thing at all :)
09:30:01 <Walther> quicksilver: nod, but I was just trying to find the "simplest" print function and how to use it, as (way too many) tutorials focus on "let's make IO safe and keep our other code pure" etc
09:30:08 <haasn> :t print
09:30:09 <lambdabot> Show a => a -> IO ()
09:30:57 <spaceships> haasn: what just happened there..?
09:31:51 <spaceships> oh
09:31:55 <haasn> spaceships: binding “take 100 [1..]” to a variable named ‘putStrLn’ :)
09:31:55 <mm_freak_> Walther: it's not exactly a focus, since haskell effectively forces you to do that
09:32:13 <haasn> > [putStrLn | putStrLn <- "putStrLn"]
09:32:14 <lambdabot>   "putStrLn"
09:32:29 <spaceships> haasn: what about the negation?
09:32:47 <haasn> > take 100 [1..] >>= \a -> [a, -a]
09:32:48 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
09:32:53 <haasn> just the list monad
09:33:05 <spaceships> haasn: oh it has nothing to do with the function putStrLn
09:33:07 <haasn> :t concatMap (\a -> [a, -a]) [1..100]
09:33:08 <lambdabot> (Enum b, Num b) => [b]
09:33:11 <haasn> > concatMap (\a -> [a, -a]) [1..100]
09:33:13 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
09:33:15 <mm_freak_> > [ y | x <- [1..10], y <- [x, -x] ]
09:33:16 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10]
09:33:17 <haasn> > map (\a -> [a, -a]) [1..100]
09:33:18 <lambdabot>   [[1,-1],[2,-2],[3,-3],[4,-4],[5,-5],[6,-6],[7,-7],[8,-8],[9,-9],[10,-10],[1...
09:33:27 <haasn> spaceships: exactly :)
09:33:34 <spaceships> cute
09:34:18 * spaceships was imagining partial application somehow.. drinks more coffee.
09:34:19 <haasn> not as cute as {-# LANGUAGE RebindableSyntax #-}  do (>>=) <- foo; ...
09:34:32 <spaceships> lol
09:34:32 <haasn> okay but that's not cute, just ugly
09:35:12 <conal> New blog post: "Overloading lambda" - http://conal.net/blog/posts/overloading-lambda
09:35:16 <mm_freak_> changing the monad in the middle of the do-block?
09:35:24 <mm_freak_> do (>>=) <- …
09:35:35 <haasn> mm_freak_: something like that but the types would still have to line up I guess
09:36:08 <haasn> mm_freak_: since it desugars to ... >>= \(>>=) -> {- the rest of the do block -}  -- and with RebindableSyntax, it just uses whatever (>>=) is in scope, it affects all subsequent binds
09:36:22 <mm_freak_> weird
09:36:42 <mm_freak_> so i can switch from State to RState in the middle of a do-block
09:36:43 <haasn> rebind (>>) as well for ideal results :)
09:36:50 <haasn> mm_freak_: try it!
09:37:01 <haasn> RebindableSyntax also doesn't require (>>=) to have any type in particular
09:37:06 <haasn> so you could use anything that type checks
09:37:10 <haasn> it just literally desugars the do block
09:37:12 <mm_freak_> i don't think i'm gonna use that =)
09:37:55 <Walther> Just to point it out here, I'm having a bit of a hard time here forcing myself through compulsory ...java. If only I could do this course in haskell, i'd be so much more motivated >_>
09:38:39 <Walther> "for (int i=1; i<=100; i++) { System.out.println(i); }" <-- why would you create such syntax
09:40:32 <Discoloda> you can do that with haskell?
09:41:20 <haasn> Walther: doesn't Java have lambda functions now or something?
09:41:39 <haasn> so you could conceivably create something like a pure FP subset :)
09:41:42 <haasn> and implement your own mapM_ etc.
09:42:03 <pjdelport> Java 8 will, but it's not released yet
09:42:06 * hackagebot snaplet-acid-state 0.2.5 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.5 (DougBeardsley)
09:42:27 <haasn> pjdelport: what's the timeframe on that? It needs to be released before I start university!!
09:42:29 <pjdelport> haasn: it's just syntax, so you can do it in current Java too; it's just too ugly for words
09:42:40 <haasn> ah, okay
09:52:35 <zebr> hi all. this is slightly on the theory side, but am i right in thinking that any lambda term can be represented as a supercombinator only if currying is present?
09:54:50 <ReinH> edwardk: So I'm also reading MacLane and Awodey.
09:54:58 <edwardk> good start
09:55:04 <ReinH> edwardk: I'm pretty sure my brain is going to explode soon
09:55:36 <merijn> haasn, pjdelport: Lambda's were originally announced for 6, then pushed back to 7, now pushed back to 8
09:55:47 <merijn> haasn, pjdelport: In other words, don't hold your breath
09:55:51 <ParahSai1in> im not sure why i had to add a "try" statement in a particular parsec
09:56:58 <ParahSai1in> http://lpaste.net/7362496319635587072 the P.try here
09:57:07 * hackagebot maid 2013.9.13 - A simple static web server  http://hackage.haskell.org/package/maid-2013.9.13 (JinjingWang)
09:57:08 <edwardk> Yes, but if you can keep your brain from shedding mess in the explosion you'll get a miniature black hole through which you can glimpse how the universe is put together, and can use that knowledge to power your haskell.
09:57:27 <ReinH> edwardk: that's the plan!
09:57:50 <ReinH> I've also been recommended Borceux but I think I'll start with these
09:58:19 <edwardk> http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/barrwells.pdf is another amazing resource
09:58:49 <edwardk> http://math.ucr.edu/home/baez/rosetta.pdf is a good summary of why you should care about category theory as a lingua franca across domains
09:59:43 <edwardk> It really does let you just tackle a new domain and immediately get down to the fundamental questions.
10:02:52 <ReinH> edwardk: I'm still trying to figure out how Data.Functor relates to the category theoretical functor.
10:03:34 <elliott> it's a functor Hask -> Hask that has to map an object a to one of the form (f a), where f is a fully-fledged Haskell type constructor
10:03:50 <elliott> which you can just think about as a functor Hask -> Hask, the other part is a technicality.
10:03:56 <ReinH> Ah, they're morphisms from Hash
10:03:59 <ReinH> *Hask
10:04:07 <elliott> um, I don't know what you mean by that :)
10:04:47 <ReinH> morphisms in the category of haskell categories, I guess
10:05:37 <ReinH> they're homomorphisms from Hask to the subcategory of Hask defined on that functor's type
10:06:39 <ReinH> so the list functor is a homomorphism from a to [a]
10:07:53 <Discoloda> https://gist.github.com/discoloda/6550a301fb5d54379626 - gist for my instance [a] question
10:08:17 <ReinH> and fmap takes morphisms in Hask to morphisms in the new category
10:08:27 <ReinH> and that makes it a functor
10:08:27 <ReinH> woo
10:09:49 <ReinH> (that and the functor laws)
10:14:22 <jfischoff> So I have a design question. I want to use a GADT to encode a path type. Like data Path a b where Foo :: Path Int String;  Bar :: String Int; (:::) :: Path a b -> Path b c -> Path a c
10:14:36 <jfischoff> but it can only have a most four pieces
10:14:58 <jfischoff> and I want to track the index
10:15:34 <haasn> ReinH: yes, they're also injective
10:15:42 <jfischoff> also the type is even more complicated
10:16:27 <Iceland_jack> jfischoff: You can make a specific datatype containing four indices, it's not very pretty though
10:17:05 <jfischoff> Iceland_jack: I'm struggling to write down all the requirements :p
10:17:16 <jfischoff> let me see if I can get to the question
10:17:42 <Iceland_jack> jfischoff: (btw, I assume you meant ‘Bar :: Path String Int’?)
10:17:56 <jfischoff> yeah
10:19:12 <jfischoff> is it better to have more type variables, like Foo :: level rootType leafType TagStart TagEnd or combine them Foo :: TagStart rootType -> TagEnd leafType
10:20:30 <jfischoff> I would think the latter, but I am unsure if the type checker would prefer types are not wrapped up in other types like TagStart rootType
10:21:02 <jfischoff> s/ Foo :: TagStart rootType -> TagEnd leafType/ Foo :: Path (TagStart rootType) (TagEnd leafType)
10:29:45 <joelteon> hey, ok
10:29:55 <joelteon> is this the place to contribute ideas for new hackage
10:30:45 <YayMe> Is this a familiar common form grammar to anyone? It doesn't look like a grammar form I've seen before but I've not studied grammars much: <length> := {<digit>*4}
10:32:44 <dwcook> YayMe, is that supposed to mean exactly four digits?
10:34:41 <YayMe> dwcook: That's the thing, this document doesn't detail the grammar form it's using, and so it's not clear to me how to interpret it
10:34:59 <YayMe> was hoping someone here might have seen it before and say "O yeah, that's blabla form" so I could google it
10:35:57 <dwcook> Yeah, search engines are admittedly pretty bad at pattern matching and symbols.
10:36:41 <Clint> YayMe: EBNF or so?
10:37:14 * hackagebot wai-graceful 0.1.0.0 - Graceful shutdown for WAI applications.  http://hackage.haskell.org/package/wai-graceful-0.1.0.0 (AlexanderBondarenko)
10:37:15 <Ikarus> so if I use "any" with a list comprehension, will is stop taking elements as soon as it has found the first true one ?
10:37:27 <dwcook> Ikarus, correct, or with any list at all.
10:37:44 <dwcook> > any (= 10) [1..]
10:37:45 <lambdabot>   <hint>:1:6: parse error on input `='
10:37:49 <dwcook> > any (== 10) [1..]
10:37:50 <lambdabot>   True
10:44:34 <joe9> can anyone please advise me? I have a lot of unit tests or test hunit functions that run on a device.  I want to use the Reader monad to pass the device along to the test functions. I could change the functions to have a Device -> parameter.  but, that would be almost for all functions and I feel Reader is the cleaner way to go. But, when I am trying to convert Assertion -> Test. I am getting stuck with the usage of ReaderT vs Reader.
10:44:46 <joe9>  I can use Reader Device Test to hold the tests and ReaderT Device  IO () to hold the assertions.
10:44:54 <joe9>  but, to convert Assertion to Test using TestCase, I have to run asks and convert the ReaderT's to Reader.
10:45:21 <joe9> Is there a better way of using the Reader monad across both Assertions and Tests?
10:46:46 <Clint> joe9: no, you need to run the ReaderT's into Assertions or you need to lift the test performance into ReaderT before running it
10:52:28 <haasn> Ikarus: note that this is a natural consequence of nonstrictness and the way ‘any’ etc. are defined
10:52:43 <Ikarus> haasn: I was just verifying my mind
10:53:01 <haasn> Ikarus: any f xs = foldr (||) False (map f xs) -- and True || _ = True; hence the rest of the fold never needs to be inspected in this case
10:53:03 <haasn> ah, okay
10:53:33 <ericmoritz> I'm trying to create a parsec parser to choose either http:// or https:// but it doesn't seem to work
10:53:36 <ericmoritz> parse (choice [string "http://", string "https://"]) "-" "https://"
10:54:58 <napping> is there an instance like (Monoid v, Ord k) => Monoid (NewtypeOfMap k v) anywhere}
10:55:19 <joelteon> damn
10:55:27 <ericmoritz> I tried <|> as well with the same result
10:55:30 <joelteon> attoparsec and parsec have very different behavior, but only parsec supports state
10:55:54 <joe9> Clint: is there a way I could create my own monad of the MonadReader typeclass that can  use a reader monad for both Assertions and Tests?
10:57:18 <Clint> joe9: yes, but again, you're going to have to lift everything if you do that
10:58:23 <k0001_> pp
11:02:14 <phischu> ericmoritz: parse (choice [try (string "http://"), string "https://"]) "-" "https://" the problem here is that if the first parser comsumes any input (which it does because "http" matches) then the second parser is not even tried
11:02:53 <joe9> is there some implementation of Effects in Haskell?
11:03:48 <ericmoritz> phischu, ok. thanks
11:04:17 <joelteon> > foldr1 f [a,b,c,d]
11:04:18 <lambdabot>   f a (f b (f c d))
11:04:37 <joelteon> > foldr1 (\x y -> f (x n) y) [a,b,c,d]
11:04:38 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> t0'
11:04:38 <lambdabot>         ...
11:04:46 <joelteon> > foldr1 (\x y -> f (x n) y) [a,b,c,d :: Expr -> Expr]
11:04:48 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
11:04:48 <lambdabot>                ...
11:04:49 <ReinH> Ikarus: also note that this requires a right fold. :)
11:06:38 <ReinH> This is because right folds immediately return the application of f to the head of the list and the recursive case.
11:09:06 <danilo2_> Could osmebody tell me why I cannot pattern match against "b (a x y)" if I can pattern match against "(a x y)" and "(b x y"), where "let a x y = (x,y)" and "let b (x,y) = (y,x)"? for example it fails: let b (a x y) = (3,4)
11:09:57 <geekosaur> you seem to be confusing function calls with patterns?
11:10:16 <Iceland_jack> danilo2_: You can pattern match on constructors
11:10:18 <napping> the "a x y" isn't really a pattern, but defining a function a
11:10:22 <geekosaur> patterns involve *constructors* not functions
11:10:35 <napping> it's more or less sugar for let a = \x y -> ...
11:10:48 <danilo2_> Iceland_jack: Ok, nvm - that was my mistake :)
11:10:51 <danilo2_> thanks :)
11:10:56 <Iceland_jack> No problem!
11:12:20 <napping> There are some languages where partial functions applied to the wrong sort of data just hang around and you can pattern match on them.
11:13:13 <napping> You could probably fake up something similar if you know the heap representation of thunks - Making map f (map g l) = map (f . g) l  an actual clause of the function definition might be interesting
11:13:27 <napping> rewrite rules at runtime
11:15:10 <ReinH> napping: fmap :)
11:15:53 <ReinH> (Set.map breaks that rule)
11:15:54 <napping> I suppose it should go for fmap, yes
11:16:08 <ReinH> it's guaranteed to be true for fmap, but not for map :)
11:16:22 <napping> I was just thinking the plain Prelude.map
11:16:32 <ReinH> sure :)
11:16:50 <napping> I double you could do that generically for fmap - the idea is to mess with generated code for map so rather than forcing the list it gets right away, checks if it's a thunk to apply map
11:17:19 <ReinH> you don't need to know anything about the heap to do it though
11:17:20 <napping> and if so, manually rips out the function and list argument of the inner map to call something different
11:17:29 <napping> ?!
11:17:29 <lambdabot> Maybe you meant: v @ ? .
11:17:37 <Clint> does anyone use optparse-applicative to emulate function composition?
11:17:58 <ReinH> fmap fusion can be done at the langauge level and GHC will often optimize that away
11:18:07 <ReinH> (the core level)
11:18:14 <napping> I mean to do it dynamically, in connection with lazy evaluation
11:18:33 <ReinH> but... you can do it statically...
11:18:46 <napping> say you've got an unforced call to map stored in a cell of data.map
11:19:27 <ReinH> napping: how would the runtime know that?
11:19:39 <napping> I just explained that
11:20:05 <ReinH> so map has a special case for thunks containing another map
11:20:23 <napping> I'm not yet suggesting you could do it automtically
11:20:50 <ReinH> I guess I don't understand why you'd want to do it dynamically when it can be done at compile time as an optimization step
11:21:03 <napping> because it can't always be done sanely at compile time
11:21:17 <napping> consider Map.alter (fmap (map (+1))) k
11:21:43 <napping> you have a Data.Lazy.Map storing lists, and randomly and dynamiclly pick cells to (map (+1)) over
11:22:15 <ReinH> but... that's not the same case as fmap f . fmap g, is it?
11:22:15 * hackagebot parcom-lib 0.4.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.4.0.0 (TobiasDammers)
11:22:34 <ReinH> that's (fmap . fmap) f ?
11:22:48 <napping> the fmap there is just for the Maybe on alter
11:22:57 <ReinH> ok
11:23:09 <napping> adjust (map (+1)) k if you assume the key exists
11:23:14 <ReinH> ok
11:23:31 <napping> statically doing (fmap f . fmap g) for every fmap is stronger
11:23:45 <napping> but I have in mind calls dynamically happening to come together, even if it's not statically apparent
11:24:00 <napping> (here you can of course do something like manually defunctionalize to a pair of list and pending increment)
11:24:11 <napping> (but GHC won't do that automatically)
11:28:04 <joe9> anyone using Effects for real world haskell programming? Would you mind sharing some example code, please?
11:32:15 * hackagebot parcom-lib 0.3.0.1 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.3.0.1 (TobiasDammers)
11:37:15 * hackagebot module-management 0.17.2 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.17.2 (DavidFox)
11:42:44 <enthropy> joe9: the example for Control.Effects.State looks very much like code that uses Control.Monad.ST (of which there should be plenty "real world" uses on hackage)
11:57:02 <jhormuz> In Control.Lens, is there a way to export all generated lenses in bulk, much like I can export all field records using "Item(..)"?
11:57:15 * hackagebot jacobi-roots 0.2.0.3 - Roots of two shifted Jacobi polynomials (Legendre and Radau) to double precision  http://hackage.haskell.org/package/jacobi-roots-0.2.0.3 (GregHorn)
11:57:17 * hackagebot parcom-lib 0.4.0.1 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.4.0.1 (TobiasDammers)
11:58:11 <shachaf> jhormuz: Not really, no.
11:58:22 <jhormuz> shachaf: bummer....
11:59:07 <jhormuz> thx anyway
12:00:13 <joe9> can anyone please help with this: program: http://codepad.org/spBoaq4u , error: http://codepad.org/kKnU2QxT
12:00:57 <joe9> enthropy: I could not find a reader in the Effects http://hackage.haskell.org/package/effects and I also did not see any commits in the last year.
12:01:06 <joe9> not sure if it is maintained actively.
12:01:49 <enthropy> maybe it's doesn't need any changes?
12:01:54 <enthropy> *it
12:02:23 <enthropy> the reader effect would just be passing an argument in, no?
12:03:18 <sclv_> joe9: i don't think the effects library is much more than a proof of concept?
12:03:53 <joe9> Isn't there a program / app/ website which tells you what functions I need to add to join 2 functions?
12:04:10 <joe9> I have these 2 functions that I want to string together.
12:04:31 <joe9> I recall that there was some functionality to tell how they can be joined, lift, etc..
12:04:35 <joe9> any thoughts, please?
12:05:11 <sclv_> joe9: also what is the type of readTransactionsShowFilePath  ?
12:05:21 <sclv_> and what do you mean "join two functions" ?
12:05:29 <sclv_> compose them?
12:06:01 <sclv_> for your error I think you should be using liftIO instead of "lift"
12:06:07 <sclv_> since you're lifting through readerT and then identity
12:06:08 <joe9> http://codepad.org/z2qYl1Y0 sclv_ I am trying the one in the second line.
12:06:19 <sclv_> so (lift . lift) would work, but liftIO is more idiomatic
12:06:27 <joe9> sclv_ : thanks.
12:06:59 <ericmoritz> is there a prefered HMAC package?  There's quite a few
12:07:05 <sclv_> liftIO universally lifts anything of type IO a to m (IO a) for any depth monad transformer stack
12:07:19 <sclv_> or m IO a rather
12:07:28 <sclv_> for any depth monad transformer stack with IO at base
12:07:48 <FreeFull> Is there a liftReader or liftState?
12:08:05 <n-dolio> No.
12:08:12 <n-dolio> Well, actually.
12:08:16 <n-dolio> There is now, I think.
12:08:18 <n-dolio> @type state
12:08:18 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
12:08:33 <joe9> sclv_: I seem to be missing something: http://codepad.org/V9E3x2ma
12:08:34 <n-dolio> @type reader
12:08:34 <lambdabot> MonadReader r m => (r -> a) -> m a
12:08:55 <n-dolio> Yeah, those.
12:09:35 <sclv_> oh word, your type signature is goofy
12:09:46 <sclv_> do you really want to produce something in monad reader that contains IO actions
12:09:53 <sclv_> or do you want a readerT over IO ?
12:09:55 <FreeFull> n-dolio: That works if you are making a new state/reader function, but what if you have something of type   State a ?
12:10:05 <FreeFull> Well, not function
12:10:12 <n-dolio> Then unwrap it.
12:10:18 <joe9> sclv_ : no, I want to use Reader and not ReaderT. As I want to be able to use Reader Device Test or Reader Device Assertion.
12:10:31 <n-dolio> @type state . runState
12:10:32 <lambdabot> MonadState s m => State s a -> m a
12:10:39 <FreeFull> Oh, I guess you could   state . runState
12:10:52 <joe9> I could use ReaderT Device IO () for Reader Device Assertion. But, I would have to use ReaderT Device Identity Test for Reader Device Test.
12:11:01 <joe9> sclv_: does that make sense?
12:11:25 <elliott> I don't see why to use Reader rather than (->) here.
12:11:28 <elliott> if it was ReaderT then OK.
12:12:03 <sclv_> i don't know what you want enough to know if it makes sense
12:12:30 <joe9> elliott: if you do not mind me asking, why is it for ReaderT?
12:13:23 <sclv_> yeah i'm leaning towards elliott here if i understand your code -- just passing around Device directly seems to make sense here.
12:13:28 <sclv_> or using a ReaderT over it
12:13:48 <sclv_> but even then i don't think it cleans much up :-)
12:18:31 <joe9> program: http://codepad.org/obJumtZy , error: http://codepad.org/wNWU1Mox
12:18:44 <joe9> I am trying with ReaderT.
12:19:21 <k0001_> ReaderT makes more sense because it probably means that you also want another monad transformer, and you could happily use both. But if you don't really need another monad transformer besides Reader, then you can get around with just passing Device around.
12:20:51 <joe9> k0001_: ok, thanks.
12:21:29 <joe9> Any suggestions on how I can change this function:  Device -> IO [Word8] to return a type of ReaderT Device IO [Word8]
12:22:35 <k0001_> :t ReaderT
12:22:35 <lambdabot> (r -> m a) -> ReaderT r m a
12:22:54 <joe9> k0001_: oh, that simple. thanks. sorry for the bother.
12:23:19 <k0001_> joe9: no problem :)
12:26:59 <user123abc> data Loc = Temp Int | Mem Int
12:28:02 <user123abc> I want to have a function that's only defined for things of form Temp Int, but I don't want to do newtype Temp = Temp Int because I want my Loc constructor to be named Temp
12:29:10 <user123abc> is there some way to solve this except for renaming my Loc constructor? (data Loc = LTemp Temp ...)
12:29:21 <user123abc> I'm pretty new, obviously
12:31:40 <chrisdone> user123abc: that Loc as defined above can't be distinguished in the type of a function
12:32:08 <Eduard_Munteanu> user123abc: naming and what your function operates on are distinct things, which of those is your goal?
12:32:46 <user123abc> both these responses confuse me, tbh
12:32:53 <user123abc> could you rephrase that, chrisdone?
12:33:31 <Eduard_Munteanu> user123abc: your function has to handle any Loc regardless of how you name the data constructors.
12:34:19 <Eduard_Munteanu> Unless you use some tricks like GADTs.
12:34:26 <chrisdone> so you have data Loc = Temp Int | Mem Int, and you have some function f :: Loc -> …, but you're saying this `f' only cares about the Temp constructor, correct?
12:34:28 <user123abc> but I don't want my function to handle any Loc
12:34:30 <geekosaur> user123abc, you seem to think that `data Loc = Temp Int | Mem Int` defines two types. it's only one
12:35:02 <chrisdone> user123abc: what is the function?
12:35:05 <inkjetunito> is it a common convention to begin a haskell file name with a capital letter? :o
12:35:11 <Eduard_Munteanu> user123abc: well, think about it... what is it going to do if given a wrong Loc?
12:35:12 <geekosaur> you don't get to specify a function type that only matches one data constructor of a type
12:35:12 <chrisdone> inkjetunito: yes
12:35:22 <inkjetunito> chrisdone: ok. thanks
12:35:22 <user123abc> I can't give the type of this function, since my issue is with the type system
12:35:33 <chrisdone> user123abc: sure, but what does the function do?
12:35:41 <chrisdone> give a limited code definition
12:35:55 <pavonia> user123abc: Why don't you just pass it an Int?
12:36:30 <user123abc> it treats a temp as a destination for a computation and takes Loc args as data sources for computation
12:36:52 <user123abc> pavonia, that's a good point, though I was hoping to be able to document that my Int is supposed to represent a temp
12:36:58 <merijn> inkjetunito: In fact, you almost always have to. Module names must begin with a capital letter and files must be named the same as the module in them
12:37:09 <user123abc> but temps can also be Locs
12:37:17 <inkjetunito> merijn: ah. makes sense
12:37:17 <Eduard_Munteanu> user123abc: you could use a type synonym to make things more clear
12:37:31 <merijn> inkjetunito: So the only way you can have non-capital file names is 1) it's not exporting a module (i.e. just your main program) or 2) it's on a case insensitive filesystem
12:37:44 <user123abc> Eduard_Munteanu, good idea - I think that could do it
12:37:59 <user123abc> thanks
12:41:45 <user123abc> yeah, that works exactly like I wanted it to
12:42:47 <chrisdone> yay
12:42:56 <chrisdone> hey kamatsu
12:49:50 <jhormuz> Does anyone know a point free/lambda free way to duplicate an item, ie- this "\x -> (x, x)" without the lambda or new function written?
12:50:04 <pavonia> :t join (,)
12:50:04 <Clint> @pl \x -> (x, x)
12:50:04 <lambdabot> join (,)
12:50:05 <lambdabot> a -> (a, a)
12:50:23 <jhormuz> awesome!
12:50:37 <jhormuz> thanks
12:50:45 <chrisdone> :t id&&&id
12:50:46 <lambdabot> a -> (a, a)
12:50:50 <chrisdone> just for variation
12:51:54 <haasn> :t runState get
12:51:55 <lambdabot> s -> (s, s)
12:52:00 <haasn> more variation :)
12:52:05 <chrisdone> clever!
12:52:22 <chrisdone> ʘ‿ʘ
13:01:34 <edwardk> jhormuz: use makeClassy ''Foo then export HasFoo(..)
13:02:19 <acowley> edwardk: Did anything come out of your exceptional powwow with Snoyman and Tekmo?
13:02:29 <edwardk> i missed it =/
13:02:30 <haasn> edwardk: at first I thought that was supposed to be a solution on how to write \x -> (x, x) in a pointfree way..
13:02:33 <edwardk> they came up with some useful stuff
13:02:48 <jhormuz> edwardk- thanks, I will look at that
13:02:48 <edwardk> :t join (,)
13:02:49 <lambdabot> a -> (a, a)
13:03:05 <acowley> edwardk: One thing that I do in some of my code is register cleanup actions, but explicitly make the caller run them
13:03:22 * edwardk scrolls up and see that in the history and goes 'oh'
13:03:41 <acowley> edwardk: It lets me kick off encapsulated processes that are intended to run asynchronously to some kind of top-level logic that shuts things down some time later
13:04:13 <shachaf> Oh, I guess makeClassy is possible. But it's hardly the same thing.
13:04:20 <edwardk> acowley: yeah, but that is pretty heavy systems-wise, you have to have the top level monitor, it doesn't play well when you don't all the control flow, etc.
13:04:39 <edwardk> er when you don't own all
13:04:41 <FreeFull> :t \f g -> fmap f . ap g
13:04:41 <lambdabot> (Monad f, Functor f) => (a -> b) -> f (a1 -> a) -> f a1 -> f b
13:05:01 <acowley> edwardk: Yeah, I don't think it's by any means ideal, but more continuing on with what I said the other day about it being easy to over-think this.
13:05:08 <edwardk> acowley: sure
13:05:22 <edwardk> i honestly don't think the MonadBaseControl stuff is _that_ bad.
13:05:30 <acowley> edwardk: I have processes that allocate scarce resources, but it's hard to scope the use of those resources
13:05:38 <edwardk> i have a few things i'd like to liberalize is all
13:07:23 <elliott> monad-control is sad :(
13:10:00 <FreeFull> :t \f g -> liftM f . ap g
13:10:01 <lambdabot> Monad m => (a1 -> r) -> m (a -> a1) -> m a -> m r
13:11:33 <FreeFull> :t (liftM reverse . ap (+3)) (,)
13:11:34 <lambdabot>     Occurs check: cannot construct the infinite type:
13:11:34 <lambdabot>       a1 = b0 -> (a1 -> [a0], b0)
13:11:34 <lambdabot>     Expected type: (a1 -> [a0]) -> a1
13:12:04 <FreeFull> :t (liftM const . ap (+3)) (,)
13:12:05 <lambdabot>     Occurs check: cannot construct the infinite type:
13:12:05 <lambdabot>       a0 = b0 -> (a0 -> a10, b0)
13:12:05 <lambdabot>     Expected type: (a0 -> a10) -> a0
13:18:51 <FreeFull> :t (liftM reverse . ap (join (+3))) (,)
13:18:52 <lambdabot>     Occurs check: cannot construct the infinite type:
13:18:52 <lambdabot>       a1 = a1 -> (b0 -> (a1, b0)) -> [a0]
13:18:52 <lambdabot>     Expected type: a1 -> a1 -> (b0 -> (a1, b0)) -> [a0]
13:18:55 <FreeFull> :t (liftM reverse . ap (join (+3)))
13:18:56 <lambdabot>     Occurs check: cannot construct the infinite type:
13:18:56 <lambdabot>       a2 = a2 -> a1 -> [a0]
13:18:56 <lambdabot>     Expected type: a2 -> a2 -> a1 -> [a0]
13:20:04 <Thulsadum> ok, slowly but surely the clouds about monads are clearing.
13:20:40 <Thulsadum> but i guess they will come back, when i'm going to take a look in more advanced ones :D
13:21:50 <YayMe> Clint: That looks like EBNF to you?
13:22:21 <Clint> YayMe: or some other kind of BNF
13:23:37 <YayMe> Clint: Yeah it has similarities to some of the BNF like grammars I've seen, however the part that i don't recognize is the * in {<alpha>*4}
13:24:15 <Clint> YayMe: that's in ebnf
13:24:39 <YayMe> I can pretty much parse it just by common sense except for that because I don't know if it's saying up-to 4 times or specifically 4 times
13:26:45 <YayMe> Clint: I'm looking on wikipedia and don't see anything of the nature.. it uses * as a comment modifier according to wikipedia
13:27:32 <YayMe> Ah here it is "* repetition-symbol"
13:27:33 <Clint> YayMe: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions
13:27:57 <YayMe> Cool, thanks! I'll devour this wikipedia article so I can understand the grammar I'm reading more correctly.
13:28:43 <YayMe> Thought EBNF doesn't use the := from appearances...
13:31:26 <YayMe> Whatever. I think I have a feel for their grammar after poking at it for a bit of a while.. I think they're just using pseudo form
13:33:44 <acowley> Hmm. If you have an executable named Foo, and you say "cabal run foo", Foo will be built, but the executable won't be run on a case-sensitive filesystem
13:33:52 <joe9> when using emacs with ghci-mod, how do I see the compiler errors / warningn?
13:34:03 <acowley> Not sure if there's a better outcome there
13:34:09 <joe9> I see the color changing  whene there is an error, but , no message.
13:34:49 <acowley> joe9: M-?
13:34:59 <acowley> Well, that's with ghc-mod
13:35:16 <joe9> acowley: it says M-? is undefined.
13:35:43 <joe9> acowley: do you recall the function name, by any chance?
13:35:44 <acowley> joe9: Yeah, I'm not sure I've used ghci-mod, actually.
13:37:02 <joe9> acowley: ok, thanks.
13:37:35 <FreeFull> Huh, mapM id is sequence
13:38:13 <FreeFull> I can see why
13:38:30 <ezyang> What's the standard cpp macro for checking if you are on Windows?
13:40:31 <joe9> this function http://codepad.org/mhSay1ls . I want to change it to commented line without using the txns variable. Is that possible?
13:40:54 <joe9> error: http://codepad.org/6BLUrrHU
13:41:01 <joe9> is there a flipM oslt?
13:41:32 <bergmark> @pl (\txns -> readTxn (head . filter isEepromTxnOutput $ txns))
13:41:33 <lambdabot> readTxn . head . filter isEepromTxnOutput
13:42:03 <joe9>  @pl (\txns -> readTxn (head . filter isEepromTxnOutput $ txns) 8)
13:44:50 <acowley> I can't parse your paste
13:45:03 <acowley> The working version has imbalanced parens
13:45:17 <tdammers> *sigh* I need a better computer
13:45:25 <Thulsadum> how could I do IO (i.e. O) on monadic data?
13:45:36 <joe9>  acowley: sorry about that.
13:45:42 <tdammers> compiling lens takes ages... I don't even want to think about yesod
13:47:00 <benmachine> Thulsadum: do you have specific data or specific IO in mind?
13:47:21 <Thulsadum> printing an Int
13:47:25 <merijn> Thulsadum: In what sense? Do you mean "I have an 'IO a' and an 'a -> IO ()' (say, print) how do I combine them?"
13:48:19 <Thulsadum> I have an Identiy' (my own implementation) containing an Int, and I would like to print the Int, merijn. :)
13:48:36 <merijn> Thulsadum: Well, you'd have to get it out of the identity first
13:49:00 <Thulsadum> I thought the concept of monads is to prevent that?
13:49:11 <merijn> Thulsadum: Monads are just an interface
13:49:19 <merijn> Thulsadum: Lists are a monad, you can get things out of lists
13:49:37 <merijn> Thulsadum: There is no way to get things out *using the monadic interface*
13:49:50 <merijn> Thulsadum: And IO doesn't provide a way to get things out at all
13:49:50 <Thulsadum> ah ok
13:50:10 <merijn> Thulsadum: For other types, if that type provides a way of getting things out (pattern matching, a function, etc.) you can just use that
13:50:11 <Thulsadum> so simplye pattern match the Monadic type agains a function and leave the binding stuff?
13:50:17 <merijn> Thulsadum: Yeah
13:50:55 <FreeFull> @hoogle MonadPlus m => Bool -> m a -> m a
13:50:56 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
13:50:56 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:50:56 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:51:01 <Thulsadum> ah. purely overwheelming this stuff, but i like it. :D a challanging language/subject of research
13:51:14 <Thulsadum> ty, merijn :)
13:51:28 <FreeFull> Huh, I wonder why the standard libraries don't have a function with that type signature
13:52:06 <FreeFull> > let when' False _ = mzero; when' True x = x in (when' True (Just 2),when' False (Just 3))
13:52:07 <lambdabot>   (Just 2,Nothing)
13:52:19 * hackagebot acme-php 0.0.3 - The flexibility of Haskell and the safety of PHP  http://hackage.haskell.org/package/acme-php-0.0.3 (JoeQuinn)
13:53:02 <napping> FreeFull: I usually define something like that too. \b m -> (guard b >> m) has that type
13:53:17 <merijn> Thulsadum: Basically, the monadic interface provides users with a way to combine things, without needing access to the internals of said things. Think of >>= in case of IO "IO a -> (a -> IO b) -> IO b" I can combine IO actions, without being able to see how IO is implemented (i.e. it's a nice form of encapsulation)
13:53:32 <enthropy> too bad hackage search doesn't have a way to just show "newest package"
13:53:36 <FreeFull> napping: It is useful
13:53:47 <enthropy> so you're stuck looking at foo-0.1 foo-0.2 ...
13:53:54 <jhormuz> edwardk- The makeClassy thing worked for me (thanks), but now I have another question....  How can I initialize a record (from nothing), avoiding the underscore names, but labeling the values (ie- I don't want to just use a nameless list, cuz I have many values and I wouldn't know which is which)
13:54:49 <Thulsadum> merijn: am i assuming right, that i group functions by the return value to a certain monad?
13:55:20 <merijn> Thulsadum: However, if you *do* expose the implementation details (like list, Maybe, Identity, etc) then you do get to use those details. It's just the in some cases the pre-built monadic interface lets you save a lot of time, because you can build generic code that works for any monad and automatically reuse it. Take a look at for example the monad-loops package which has a whole bunch of looping things pre-built
13:55:48 <merijn> Thulsadum: I'm not sure exactly what you mean by "grouping functions by the return value to a certain monad"?
13:57:12 <Thulsadum> mh, let's take foo:: a->b->MondadicType () ; bar :: a->b->MonadicType (), these function are 'bound' to the monad, aren't they?
13:57:55 <Thulsadum> (well they will create an instance of that MonadicType thingy, and thus force you into the monadic interface)
13:58:06 <merijn> Thulsadum: They don't force anything
13:58:29 <merijn> Thulsadum: Take "replicate :: Int -> a -> [a]" does that force you to use the list monad?
13:58:54 <merijn> You can, if you want too, of course
13:59:01 <Thulsadum> mh
13:59:09 <merijn> > replicate 5 () >>= \x -> [1,2]
13:59:10 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
13:59:25 <merijn> > replicate 5 ()
13:59:26 <Iceland_jack> > [1..5] >> [1,2]
13:59:26 <lambdabot>   [(),(),(),(),()]
13:59:27 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
13:59:30 <donri> m a -> a is not part of the monad interface and not provided by many monads, but it is separately provided by some
14:00:21 <merijn> Thulsadum: I personally believe many people over think this monad thing, I tend to encourage people to use >> and >>= directly to write code and ignore do notation at the start
14:00:38 <merijn> Thulsadum: This helps you get used to the fact that >>= is just a normal function
14:00:54 <phulin> How do I get an SYB Generic instance for Text?
14:00:55 <Thulsadum> yeah, i ommit it atm as well, because it hides too much, to understand
14:01:09 <merijn> Take a look at the implementation for Maybe, for example
14:01:09 <merijn> @src Maybe >>=
14:01:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:01:18 <merijn> @src Maybe (>>=)
14:01:18 <lambdabot> (Just x) >>= k      = k x
14:01:18 <lambdabot> Nothing  >>= _      = Nothing
14:01:22 <benmachine> phulin: depends if you're ok with it being inefficient
14:01:33 <Thulsadum> i implemented that just a moment ago :D
14:01:39 <jfischoff> phulin: it has one
14:01:56 <phulin> jfischoff: where?
14:02:01 <Thulsadum> where does lambdabot take the source from?
14:02:08 <merijn> Thulsadum: It's hard coded
14:02:21 <jfischoff> Instances …. Data Text I'm looking at the doc
14:02:23 <merijn> Thulsadum: But you can search on Hoogle and the documentation will have a link to the source
14:02:28 <donri> Thulsadum: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
14:02:40 <merijn> Thulsadum: For instances of typeclasses, the source is usually in the same module as the datatype
14:02:53 <donri> [or the class]
14:03:01 <enthropy> johnw: using c2hsc, shouldn't  --cppopts="-B/usr/share/R/include/" let the cpp find a file  /usr/share/R/include/R_ext/Arith.h, which is #include <R_ext/Arith.h>?
14:03:13 <Thulsadum> ha, never seen that small source link on top :D
14:03:20 <Thulsadum> guess, i need new glasses. :p
14:03:27 <merijn> Thulsadum: Individual functions/datatypes have links too
14:03:36 <merijn> Thulsadum: Just look on the right side of the screen :)
14:04:08 <Thulsadum> rediscovering the docs... :D
14:04:23 <merijn> Thulsadum: The thing that forces you to use the monadic interface is the fact that IO doesn't export it's constructors, so you can't pattern match to get values out of IO
14:05:22 <Thulsadum> so hiding the constructors will force it into a jail?
14:06:07 <merijn> Thulsadum: Yes, no exported constructors == no pattern matching, think of it as making instance variables "private" in something like Java/C++
14:06:33 <Thulsadum> mh, nice :)
14:06:34 <merijn> Thulsadum: It lets you hide implementation details and stops people from messing around with things they shouldn't
14:06:48 <Thulsadum> yeah, I see.
14:07:16 <merijn> Thulsadum: semi-relatedly, I was working on an explanation of IO. It's not quite done, but if you have any feedback on what is helpful or what is confusing, that's always good
14:07:19 <merijn> Thulsadum: https://gist.github.com/merijn/6478573
14:07:44 <Thulsadum> i'll have a look right now. :)
14:19:50 <Iceland_jack> Thulsadum: As a silly example you might want to represent numbers from 5 to 20: so you make a ‘smart constructor’ like so:
14:19:50 <Iceland_jack>     smart n | 5 <= n && n <= 20 = Just (Foo n)
14:19:50 <Iceland_jack>             | otherwise         = Nothing
14:19:50 <Iceland_jack> Then you hide the Foo constructor and you will know that everything with that constructor is between 5 and 20
14:19:51 <Iceland_jack> So it's a way to maintain invariants
14:21:00 <Thulsadum> yeah, that's quite cool, Iceland_jack
14:21:21 <[elvin]> hey anyone knows, vty-ui is for terminal  ?
14:21:49 <Iceland_jack> Thulsadum: Another thing you can do is to use it to make restricted IO monads
14:21:59 <merijn> [elvin]: Yes
14:22:05 <Iceland_jack> where you know that some monad can only perform a specific action (check the time, read from a file, ...)
14:22:19 <[elvin]> god and has all these widgets seems very cool
14:33:27 <Thulsadum> merijn: it's nice written, but has not much new stuff to me. i like the analogy of getline to ls ;)
14:34:11 <merijn> Thulsadum: That's good, if not much of that is new, then you're already on your way to knowing most you need to know :)
14:35:17 <merijn> Thulsadum: The neat thing is that you can actually make IO actions without executing, for example, try this in ghci
14:35:26 <merijn> > map print [1..10] !! 3
14:35:27 <lambdabot>   <IO ()>
14:36:38 <arkeet> but ghci would execute that
14:36:49 <hpc> and print 4
14:36:57 <leroux> I think he's trying to point out that (!! 3) is where it is executing it.
14:37:00 <arkeet> yes
14:37:02 <leroux> > map print [1..10]
14:37:04 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
14:37:20 * hackagebot hashable 1.2.1.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.1.0 (JohanTibell)
14:37:37 <merijn> Well, rather I was pointing out that it *wasn't* executing the other 9
14:37:39 <hpc> Thulsadum: it's common practice in haskell to make an infinite computation and then just take the parts you need
14:37:45 <merijn> But that's largely the same thing
14:38:37 <arkeet> > print 4 `seq` ()
14:38:39 <lambdabot>   ()
14:39:22 <arkeet> merijn: I dunno, it never even constructs the other 9
14:39:23 <hpc> > [error "aha! crashed", "nope! not crashed"] !! 1
14:39:25 <lambdabot>   "nope! not crashed"
14:39:36 <Thulsadum> hpc: i've already noticed that :)
14:39:47 <hpc> > fix error -- have you noticed this?
14:39:48 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:39:49 <merijn> arkeet: It constructs th first 3, so you're wrong ;)
14:40:04 <merijn> Well, actually
14:40:05 <merijn> hmm
14:40:06 <arkeet> no, it makes the cons cells
14:40:12 <merijn> pfft
14:40:18 <arkeet> but never evaluates the inside
14:40:42 <hpc> it constructs the beginning cons cells of the lists, which contain thunks to (print x) for x in [1,2,3,4]
14:40:47 <hpc> then it evaluates the thunk for 4
14:40:50 <hpc> then it executes it
14:42:38 <[elvin]> what would be the imperative equivalent? like a loop with an if and a counter for elements?
14:42:57 <hpc> the imperative equivalent is (print 4)
14:43:02 <hpc> :P
14:43:10 <[elvin]> haha no it is not and you know it
14:44:14 <hpc> [elvin]: it's more of a lazy/strict thing than a functional/imperative thing
14:44:59 <[elvin]> yes thats right. i have in mind that imperative is never lazy
14:45:00 <Thulsadum> is there an alternative way for something like that? getLine >>= (\x -> return $ reverse x) >>= putStrLn
14:45:20 <Thulsadum> well the anonymous function ist somewhat awkward
14:45:20 <hpc> :t getLine >>= (\x -> return $ reverse x) >>= putStrLn
14:45:21 <lambdabot> IO ()
14:45:28 <arkeet> getLine >>= putStrLn . reverse
14:45:48 <Iceland_jack> :t fmap reverse getLine >>= putStrLn
14:45:48 <lambdabot> IO ()
14:46:00 <hpc> interact reverse
14:46:08 <Iceland_jack> hpc: Not the same
14:46:09 <hpc> one line of input is enough for everyone
14:46:10 <Thulsadum> interact is to specific
14:46:11 <arkeet> :t getLine >>= putStrLn . reverse
14:46:12 <lambdabot> IO ()
14:46:37 <arkeet> the ordering is nicer with =<<
14:46:51 <hpc> "nicer" meaning linear ;)
14:47:02 <Thulsadum> but i guess, the composition operator was the thing, i was looking for :D
14:47:03 <Iceland_jack> :t do line <- getLine; putStrLn (reverse line)
14:47:04 <lambdabot> IO ()
14:47:30 <arkeet> yes, that corresponds to the one I wrote
14:47:39 <Thulsadum> yep
14:48:29 <YayMe> Graa why does F# need in-order declarations... that is so damned annoying when you want to declare a mutually recursive type
14:48:47 <hpc> YayMe: because the type-checker is in-order too
14:48:56 <YayMe> well the type-checker is dumb then.
14:49:00 <YayMe> grumble
14:49:02 <hpc> YayMe: see also, the order of parameters of (|>)
14:50:46 <YayMe> I shouldn't complain, were it not for F# and fparsec I wouldn't have any chance of convincing colleagues to let me write anything in an FP language.
14:52:03 <lcfrs_> Is anyone here working with Thrift?
14:52:26 <lcfrs_> I've got the Haskell example to work
14:52:38 <Thulsadum> merijn: if you write an article like the one about IO, in the near futur, about State, I'd like to read it. :D
14:54:06 <lcfrs_> Thrift Compiler needs some work. It doesn't hide functions that the current module exports, so compile fails because of the ambiguous defn
14:54:08 <arkeet> but there's nothing magic about State
14:54:26 <merijn> Thulsadum: State is actually much simpler than IO
14:54:46 <arkeet> a -> State s b  =  (a, s)  -> (b, s)
14:55:02 <merijn> Thulsadum: Do you understand the conceptual idea that you can simulate state by passing it in as an extra argument and then returning it as an extra result?
14:55:20 <merijn> Thulsadum: State does *exactly* that, but it hides the ugly extra parameter/result
14:55:44 <YayMe> merijn: The control flow and side effecting types are a lot more clear to me as a normally imperative programmer than the stateful abstractions
14:55:46 <merijn> Thulsadum: The best advice is, try to implement Monad and get/put for State yourself
14:56:05 <merijn> Thulsadum: Here's your hint: "data State s a = State (s -> (a, s))"
14:56:32 <Thulsadum> ok :D
14:56:41 <YayMe> maybe/either mimic behaviours I deal with every day in imperative programming, IO and STM as well, but in imperative programming I never work with anything that behaves like the State, Reader, or Writer types (that I can identify...)
14:57:03 <quchen> Seconding merijn's suggestion. Writing State myself was probably the most valuable thing I did to learn about Monads.
14:57:08 <merijn> YayMe: I'm always recommend trying to implemennt them yourself
14:57:41 <merijn> YayMe: Further hints for reader/writer "data Reader r a = Reader (r -> a)" and "data Writer w a = Writer (a, w)"
14:57:50 <Thulsadum> yeah, i implemented Identity and Maybe thus far, was quite educational
14:58:31 <YayMe> merijn: Yeah... I just don't understand what I'm supposed to use the state/reader/writer monads for which is where it get's confusing. Maybe/Either have an obvious purpose, but the purpose of those ones is ?
14:58:47 <joelteon> the purpose of those is their name
14:59:09 <merijn> YayMe: Imagine your application has a global config read from a file, what's the easiest way to make sure you have access to the config everywhere? Reader
14:59:22 <merijn> YayMe: You want to collect log interactions? Writer.
14:59:35 <merijn> YayMe: Generic "I want to maintain some state." State
15:00:49 <YayMe> merijn: That is possibly the most helpful explanation I've heard. The state I kind of figured that from the name but then I'd heard people refer to it as for functional composition which made it less clear.
15:02:00 <merijn> YayMe: Functional composition is what it does, state is what it's for
15:02:21 * hackagebot parcom-lib 0.5.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.5.0.0 (TobiasDammers)
15:02:21 <merijn> YayMe: Like I said, State *literally* works by just adding an extra input argument and extra return value everywhere
15:02:45 <merijn> YayMe: The monad implementation of State then carefully hides this from you and thus all the argument passing for you
15:03:59 <inkjetunito> can haskell do implicit conversions, like String to Data.Text?
15:04:04 <YayMe> merijn: Aye, I just need to implement it I suppose. Moreover, I need to use it for something so I can have a sense about how it's used. The other thing that confuses me is all of those types have functions other than bind that you have to use to work with them
15:04:23 <joelteon> inkjetunito: at compile-time, kind of
15:04:26 <Rarrikins> inkjetunito: For literals, yes.
15:04:32 <joelteon> yeah, for literals
15:04:39 <YayMe> inkjetunito: haskell doesn't do any run-time conversions. something is a certain type and that's the type it is
15:04:48 <merijn> inkjetunito: Did you mean "I'm to lazy to write "Data.Text.pack" for all my String literals?
15:04:56 <inkjetunito> merijn: yes!
15:05:09 <merijn> inkjetunito: {-# LANGUAGE OverloadedStrings #-}
15:05:33 <inkjetunito> thanks guys
15:05:41 <merijn> inkjetunito: You know how numeric literals are "Num a => a"
15:05:45 <Rarrikins> No problem.
15:05:59 <merijn> inkjetunito: That turns String literals into "IsString a => a" (where Text is of course an IsString instance)
15:14:48 <joe9> :t TestCase
15:14:49 <lambdabot> Not in scope: data constructor `TestCase'
15:15:20 <joe9> TestCase :: Asertion -> Test -- What should I do to get this to be ReaderT Device Test?
15:15:30 <joe9> Or, should it be ReaderT Device Identity Test
15:16:51 <joe9> :t TestCase $ return () :: Test
15:16:52 <lambdabot> Not in scope: data constructor `TestCase'
15:16:52 <lambdabot> Not in scope: type constructor or class `Test'
15:18:21 <joelteon> couldn't you do ReaderT Device IO () and then liftIO all your assertions?
15:19:07 <arkeet> I'd rather emit  MonadReader Device m => m Test
15:26:44 <enthropy> johnw: nevermind, it works if I leave off the final /include/
15:45:38 <Thulsadum> Num ist not an instance of Eq?
15:46:04 <geekosaur> Num is a class. specific Num instances may not be instances of Eq
15:46:40 <yng> hello, how do I get a partial applied function such as "func = (++) _ [1]"?
15:46:44 <geekosaur> (this allows evil things like Num instances for functions)
15:46:46 <Thulsadum> mh, ok
15:47:05 <geekosaur> yng, you can use lambda notation, or flip, or sections
15:47:35 <geekosaur> (++ [1])   <-- operator section
15:47:44 <enthropy> Thulsadum: it used to be   class Eq a => Num a
15:47:54 <yng> ty I will check it out
15:47:59 <Thulsadum> make sense for floating point numbers, i guess that's why, an instance of Num is not automaticly an instance of Eq
15:48:09 <geekosaur> sadly floats are still Eq
15:48:40 <FreeFull> Nums also used to be Show
15:49:00 <ReinH> geekosaur: "evil" :p
15:49:26 <FreeFull> What is evil is this:
15:49:30 <FreeFull> > (1/0) == (1/0)
15:49:30 <geekosaur> eeeeeeeeeebil :p
15:49:31 <lambdabot>   True
15:49:42 <FreeFull> > (0/0) == (0/0)
15:49:43 <lambdabot>   False
15:49:48 <ReinH> yng: it would generally be more efficient to cons onto the front of the array (1:) than concat onto the end (++ [1])
15:50:03 <chrisdone> hehe, ocaml guys
15:50:08 <ReinH> yng: so it might make more sense to build your array in reverse using (:) and then reverse once at the end
15:50:51 <chrisdone> "can ocaml do shared memory parallelism?" "no, but we tend not to do that anyway, it's bad"
15:51:43 <chrisdone> it's sort of like
15:52:00 <chrisdone> "can haskell update functions in-place in ghci while running?" "no, but we tend not to do that anyway, it's bad"
15:52:46 <ijp> if we can do it, it's good. if we can't, it's bad.
15:53:03 <enthropy> there's plenty of bad stuff you can do
15:53:09 <luite> chrisdone: it kind of can replace code at runtime now though, simonm was talking about loading new libs and unloading the old ones without restarting
15:53:21 <luite> chrisdone: used at facebook, and patches already in HEAD
15:53:31 <hpc> @hackage acme-php -- bad things you can do
15:53:31 <lambdabot> http://hackage.haskell.org/package/acme-php -- bad things you can do
15:53:58 <chrisdone> ijp: pretty much
15:53:59 <geekosaur> updated with more evil just today!
15:54:18 <hpc> slightly less evil, really
15:54:22 <hpc> i made sortBy work
15:54:27 <chrisdone> luite: hmm, that seems like a totally different thing?
15:54:45 <hpc> it previously failed to terminate on sorted lists, and returned unsorted lists as if it were id
15:55:06 <joe9> joelteon: what would the type for Test be? just Test? I mean runReaderT on all Assertions?
15:55:15 <chrisdone> luite: you mean i can update a loaded library in ghci, :reload my module and start using the new library version?
15:55:15 <luite> chrisdone: oh perhaps, i just thought it was cool that that worked. you meant like erlang?
15:55:22 <hpc> i fixed it with unsafeCoerce
15:55:54 * geekosaur feels like that's a punch line
15:55:55 <chrisdone> luite: sure. erlang, or smalltalk/lisp for a more ancient example
15:55:56 <ReinH> ijp: No true Haskeller.
15:55:58 <luite> chrisdone: no compile new code to a dynamic lib, load it at runtime, and unload the old one automaticlly when no code refers to it anymore
15:56:04 <quchen> hpc: You can't just change core functionality like that, at least provide a compatibility module
15:56:30 <hpc> quchen: nah, just stay on 0.0.2
15:56:45 <ReinH> chrisdone: except that GHC hot code loading is a thing now right? :)
15:56:46 <hpc> and then backport security fixes
15:56:58 <hpc> what could possibly go wrong!
15:57:26 <ijp> ReinH: no true scotsman would make a no true scotsman argument
15:57:28 <chrisdone> luite: the simple example is, i run this in ghci: forkIO $ forever $ go  and then i tell ghci: let go = print "yo" to update 'go' and the loop now prints "yo"
15:57:31 <ijp> irony aside
15:58:02 <chrisdone> luite: can you do that with the loading/unloading business?
15:58:09 <donri> chrisdone: not ghci but you can achieve something similar with "plugins"
15:58:23 <chrisdone> donri: plugins, don't make me laugh.  have you ever tried it?
15:58:27 <donri> hm or maybe not
15:58:34 <donri> yeah it's rather crude
15:58:42 <donri> plus it wouldn't do your example, i realized
15:58:55 <donri> you'd have to restart that thread
15:59:15 <luite> chrisdone: hm, i'm not quite sure, i think there's still some explicit connection to the lib, not seamless replacement, but i don't really know for sure
15:59:22 <chrisdone> i don't know why ghc HQ never cared about this, i thought all the original haskellers were lispers, but it just seems it didn't matter much to anyone
15:59:34 <FreeFull> I tried   forkIO $ forever $ return ()   and it hung ghci
15:59:48 <chrisdone> FreeFull: lol. why did you try it?
15:59:55 <chrisdone> "i wonder what this'll do" =p
16:00:17 <donri> guys i tried rm -rf /  but it's just sitting there doing nothing
16:00:27 <chrisdone> system "sudo killall X & xeyes"
16:00:29 <ReinH> donri: just give it time
16:00:33 <FreeFull> chrisdone: Updating go shouldn't change anything that depended on the previous go
16:00:36 <donri> ReinH: ok thanks good advice
16:00:39 <FreeFull> Because of how Haskell's semantics work
16:00:53 <chrisdone> FreeFull: i disagree
16:01:07 <chrisdone> introducing a _new_ binding to go shouldn't change any previous uses of it
16:01:15 <chrisdone> but _updating_ that go should change _that_ go
16:01:31 <FreeFull> You're not updating the go though
16:01:42 <chrisdone> not presently, that's kinda the point of the discussion
16:01:46 <chrisdone> i want an update facility
16:01:48 <Saizan> FreeFull: chrisdone is asking for a new feature in ghci
16:01:50 <FreeFull> You're making a new binding that happens to have the same name
16:02:06 <FreeFull> Which isn't something that makes sense in the IO monad
16:02:26 <FreeFull> You basically want an implicit IORef?
16:02:34 <chrisdone> i looked at ghci's source and it scared me, so i haven't started work on it yet =p
16:02:54 <Saizan> he wants to mess with ghci's implicit environment :)
16:03:10 <FreeFull> I'm pretty sure changing ghci to do that would break things for people, including their mental models
16:05:47 <chrisdone> FreeFull: think of it like stopping your program, re-defining that function, re-running it from scratch and continuing from where you were at. there's nothing weird about that. now just imagine you can do that in one operation
16:06:48 <chrisdone> or actually just like everything is in an IORef. which _might_ be a cheeky way to achieve it in ghci
16:07:06 <FreeFull> chrisdone: Just don't get into problems with sharing and laziness
16:07:49 <Saizan> chrisdone: well, you won't get the same result by just updating go, it won't change the result of past uses
16:08:09 <Saizan> unless they are still thunks :)
16:08:10 <chrisdone> Saizan: sure
16:08:43 <Saizan> so it ends up being quite weirder then what you described
16:09:17 <Saizan> but i guess people have found its uses
16:09:19 <chrisdone> on a scale of 1 to 11 how weird would you characterize it?
16:09:25 * chrisdone holds mic to Saizan
16:09:57 <Saizan> dunno, call/cc in pure code weird?
16:10:30 <chrisdone> Saizan: i came up with (along with mgsloan) one idea of transforming all declarations of IO actions into IORef'd wrappers that would lookup that value every time they ran
16:11:37 <chrisdone> so let go = print "yo", would become, let go = unsafePerformIO $ do r <- newIORef (print "yo"); return (join (readIORef r))
16:11:37 <Saizan> yeah, that'd be just "global IORef" weird
16:12:10 <Saizan> *nod*
16:12:46 <chrisdone> ah, not quite right, missing:
16:13:06 <chrisdone> let (go,go_ref) = unsafePerformIO $ do r <- newIORef (print "yo"); return (join (readIORef r),r)
16:13:34 <chrisdone> (but go_ref would be some generated/non-conflicting name)
16:15:04 <chrisdone> i can't remember what the down-sides were. hmph
16:15:22 <enthropy> it's not implemented yet?
16:15:40 <enthropy> /and it doesn't seem like you could fake it with built-in stuff (quasiquotes for example)
16:15:59 <luite> chrisdone: you could walk the heap, replace closure headers with the new version
16:16:06 <luite> hm
16:16:08 <Saizan> but if you are at the ghci prompt can't you just make a combinator for that?
16:16:22 <luite> chrisdone is quite good at things that i have to implement in ghcjs :(
16:16:26 <luite> +suggesting things
16:17:18 <Saizan> well, you'd have to keep go_ref around, but that's not so much of a pain
16:17:38 <elliott> did anyone figure out how to reliably re-thunk evaluated stuff?
16:17:45 <elliott> that's something that would be useful for things like this
16:20:00 <enthropy> elliott: like what?
16:20:03 <FreeFull> elliott: Would something like ((\() -> x) ())   work?
16:20:33 <FreeFull> I don't think it would
16:20:36 <luite> elliott: hm, that sounds kind of impossible to do in a practical way, you'd have to track dependencies for everything
16:20:54 <elliott> well, it's kind of vague.
16:21:05 <elliott> I think rwbarton did something like that for a Map that was stored on disk and automatically swapped out unused parts after a while?
16:21:08 <luite> but it seems like a good challenge :)
16:21:09 <elliott> and used unsafePerformIO to load them back again
16:21:14 <elliott> horrific but cute
16:21:17 <FreeFull> You just need to thunk the constructors
16:21:20 <luite> hehe
16:21:22 <chrisdone> Saizan: sure, a combinator would help define it. personally, i'd like to load in X.hs into ghci with this applied to all top-level IO forms, e.g. from emacs, and then i go to one of the forms, edit the code, hit C-M-x (which is what i do in lisp) and it updates the function by writing the ioref
16:21:27 <ion> rethunk ¡x = x
16:21:35 <chrisdone> elliott: that's pretty cool
16:21:41 <ericmoritz`> what is the common practice in distributing private packages?
16:22:06 <chrisdone> ericmoritz`: i've seen a bunch of haskell companies using their own hackage server
16:22:33 <chrisdone> ericmoritz`: or do you just mean like sending a haskell package to your dad by email?
16:22:38 <danilo2_> Hi! I've go ont small question to you :) Is it possible in Haskell to write an instance of show for empty untyped list? I would love this code: "let a = []; print a" to ouptut "[]". I need this to my domain language (so this would be not used in "production Haskell code")
16:22:57 <enthropy> ericmoritz`:  like seereason.com make debian packages I think
16:23:00 <enthropy> ones like
16:24:05 <enthropy> danilo2_: maybe you can turn on -XExtendedDefaultRules and have ghc decide that a :: [()]
16:24:33 <enthropy> which will print what you're asking for
16:24:35 <FreeFull> > show ([] :: String)
16:24:36 <lambdabot>   "\"\""
16:25:07 <danilo2_> enthropy: I think this is exactly what I was looking for
16:25:12 <danilo2_> enthropy: thank you! :)
16:25:20 <ericmoritz`>  chrisdone: in the a company sense.  We have a number of sites that would use the same packages that I would like to include when building them
16:25:35 <chrisdone> Saizan: after all, without having everything else in the module reeferring to that IORef'd version, the live update is useless
16:26:59 <Saizan> chrisdone: yeah, i was naively hoping you'd be appeased with this working only for definitions at the prompt :)
16:27:41 <chrisdone> Saizan: hehe
16:27:56 <enthropy> chrisdone: you could have {-# OPTIONS_GHC -F -pgmF somethingYouNeedToWrite #-} that'll do your unsafePerformIO etc.
16:28:28 <chrisdone> indeed
16:28:44 <chrisdone> i wonder, can that be turned on in ghci globally? the pgmf stuff?
16:28:45 <enthropy> there are still some details to be filled in though
16:28:58 <chrisdone> like "i'm hacking now, use my preprocessor"
16:29:20 <chrisdone> enthropy: what details?
16:29:50 <enthropy> well sending your updated function to ghc can't use :reload
16:30:04 <chrisdone> ah, sure, i'd use emacs to do that
16:30:06 <enthropy> since that wipes out things you've done before
16:30:30 <chrisdone> just send e.g. modifyIORef go_ref $ <new go definition>
16:30:42 <FreeFull> This would work so much easier in a strict language
16:30:59 <FreeFull> {-# LANGUAGE StrictHaskell #-}
16:31:23 <elliott> chrisdone: maybe write a ghc plugin
16:32:33 <chrisdone> elliott: as a core-to-core transformation?
16:32:58 <chrisdone> hmm =)
16:33:48 <jmcarthur_mobile> FreeFull: what would be easier in a strict language?
16:34:08 <elliott> chrisdone: wrap every IO action in that mess! and then let you use a structural editor to edit arbitrary subexpressions and reload seamlessly
16:34:13 <elliott> kittens!
16:35:03 * chrisdone reads the compiler plugins manual entry
16:35:24 <chrisdone> holy beans this looks well easy
16:36:07 <elliott> there's an example plugin on hackage that makes the language strict, that might be good to look at for reference and stuff
16:38:54 <chrisdone> happily, i'm already familiar with core. so from this docs http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/compiler-plugins.html i can see how to write it
16:39:14 <benmachine> chrisdone: not that this is helpful to you, but your idea terrifies me
16:39:23 <chrisdone> lol
16:41:39 <chrisdone> hm, yeah. i can use modguts to get all the top-level decls, use the core to check the type is an IO action
16:41:42 * chrisdone fiddles
16:41:59 <benmachine> chrisdone: it does seem like the semantics are a bit hairy, like, you seem to need to have a consistent idea of what it means to "restart" something and how much you actually need to restart
16:43:27 <chrisdone> me and sloan couldn't think of a way to do updates for pure values in a consistent way
16:43:58 <chrisdone> but IO values are easy!
16:44:34 <elliott> chrisdone: I do think this kind of thing is going to be inherently a hack with Haskell.
16:44:41 <elliott> you want to design your language holistically around this kind of hot-swapping goal
16:44:55 <chrisdone> elliott: even for just IO?
16:45:01 <elliott> well, less so.
16:45:04 <elliott> but it's still kinda hairy :)
16:45:14 <elliott> if you restrict yourself to top-level definitions then I guess it's not so bad.
16:45:17 <elliott> (except inlining?)
16:45:17 <chrisdone> hmm with IO it seems equivalent to using IORefs manually fo reverything
16:45:41 <chrisdone> true. probably unsafePerformIO complicates matters
16:46:31 <benmachine> I wondered about inlining but it's not a problem with the just-redefine-everything interpretation
16:46:35 <chrisdone> though ghci doesn't aggressively inline
16:46:39 <benmachine> at least conceptually
16:47:46 <benmachine> but I'm going to stop talking about this because I'm not the target audience nor terribly well-placed to help :P
16:50:08 <teburt> looking for help with ghc-iphone cross compiler, but haskell-iphone is empty
16:50:55 <sclv> teburt: feel free to ask here but i imagine that email to the authors would probably be better
16:51:01 <sclv> its a small group of ppl familiar with that stuff
16:51:51 <copumpkin> has anyone ever wished they had something like a replicateM that took a Kleisli arrow?
16:52:10 <copumpkin> something like foldr (>=>) return $ replicate n f
16:52:44 <benmachine> copumpkin: I've definitely used foldr (<=<) return before
16:52:48 <benmachine> don't think with replicate
16:53:59 <copumpkin> hmm, maybe I'm thinking of it wrong
16:55:21 <chrisdone> :t \n f -> foldr (>=>) return $ replicate n f
16:55:22 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
16:55:51 <copumpkin> that might not be quite what I'm after either
16:55:53 * copumpkin thinks harder
16:57:36 <chrisdone> yay, my ghc plugin says ‘Hello!’
16:57:44 <benmachine> :D
16:57:53 <benmachine> no further work necessary
16:58:05 <chrisdone> job done. pack everything up lads
17:02:51 <chrisdone> phew
17:03:13 <chrisdone> running it with ghc inlines too much, but in ghci i get a top-level go definition
17:03:46 <chrisdone> like this http://lpaste.net/8375821732035952640
17:04:22 <joe9> is there a better way of writing this: http://codepad.org/YL4R6eJw
17:04:44 <joe9> i think the checkBit functions can be put in a sequence or something like that.
17:04:50 <joe9> without the need for the \status.
17:04:57 <chrisdone> >=> could do the trick
17:04:57 <joe9> but, I cannot figure it out.
17:05:07 <joe9> chrisdone: thanks.
17:05:48 <chrisdone> or, yeah, mapM_ ($ status) [checkbit …, checkbit …, …]
17:05:50 <chrisdone> something like that
17:06:11 <chrisdone> ah, point-free
17:06:45 <chrisdone> forM_ [checkbit …, checkbit …] . ($) but maybe that's too fancy
17:07:16 <elliott> flip ($) surely
17:07:28 <joe9> chrisdone:  thanks. let me put it together. the forM is too fancy for me.
17:07:30 <chrisdone> yeah
17:07:33 <joe9> I would not understand it later.
17:07:34 <chrisdone> hm unless checkBit returns a useful value at the end, in which case probably >=> is best
17:07:52 <rogovski> :t surely
17:07:52 <lambdabot> Not in scope: `surely'
17:07:55 <joe9>  checkbit: http://codepad.org/Ra0Okc5K
17:07:57 <chrisdone> elliott: so fancy i got it wrong =p
17:08:04 <chrisdone> rogovski: don't call me surely
17:08:07 <elliott> you have a weird way of spelling ugly
17:09:27 <chrisdone> elliott: no u
17:09:51 <rogovski> sorry. im a bit tense. i almost hung myself today trying to decipher the scalaz documentation
17:10:42 <chrisdone> what's that?
17:11:10 <joe9> chrisdone: http://codepad.org/jSG0v8zo I could not figure out how to fit the >=> with the mapM_
17:12:19 <joe9> does not work: http://codepad.org/8cMsJqgE
17:12:25 * hackagebot cookbook 0.1.3.1 - An independent library of common haskell operations.  http://hackage.haskell.org/package/cookbook-0.1.3.1 (NatePisarski)
17:12:35 <chrisdone> joe9: ah, i meant either: >>= (checkBit … >=> checkBit … >=> checkBit …) or >>= (\status -> mapM ($ status)  [ … ])
17:12:57 <chrisdone> :t (>=>)
17:12:57 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:13:28 <joe9> chrisdone: using mapM_ , is there any way I can get rid of the \status?
17:13:37 <joe9> flip mapM_?
17:13:39 <chrisdone> ah, wait. what does checkBit return?
17:13:46 <chrisdone> umm
17:13:57 <chrisdone> i don't think so, not without doing a bunch of flips
17:14:31 <joe9> chrisdone: ok, thanks.
17:16:40 <ellipsis> I'm trying to install pipes-network-tls and I'm getting this error when cabal tries to install network-simple-tls: http://lpaste.net/92464
17:16:49 <ellipsis> any ideas?
17:17:56 <chrisdone> ellipsis: presumably there's a library version mismatch where the version the author of network-simple-tls used a different crypto-random (or whichever) package version to the one you're compiling with
17:18:06 <a3f> Is there some wayto achieve failthrough in case statements? (like omitting the break in C)
17:18:40 <a3f> fallthrough*
17:18:44 <chrisdone> ellipsis: i'd probably check out when the package was uploaded and bisect the dependency it's failing to build with back to when it worked, and then add a constraint for that specific version
17:19:04 <chrisdone> ellipsis: and then maybe notify the author that their package don't build nomore with latest version of X
17:19:51 <chrisdone> a3f: not that i'm aware of
17:19:53 <ellipsis> chrisdone: how do I add a constraint?
17:20:05 <chrisdone> ellipsis: i think it's --constraint foo==1.2.3
17:20:28 <chrisdone> cabal install --help | grep constraint
17:20:52 <ellipsis> it's in a cabal-dev environment - can I add that to my .cabal file?
17:20:59 <chrisdone> sure
17:21:07 <chrisdone> in your build-depends
17:21:33 <chrisdone> can also pass it to cabal-dev install afaik
17:21:56 <ellipsis> it seems a little weird to say "I need this package at this version" when it's actually a package I need that requires that version
17:22:03 <ellipsis> but :/
17:22:10 <chrisdone> yeah, i feel ya buddy
17:22:39 <chrisdone> this is why people advocate adding maximum versions to dependencies
17:22:53 <yng> b
17:23:13 <chrisdone> haha, i knew that guy was an emacs user
17:23:31 <chrisdone> he typed C-x b RET but messed it up =)
17:24:28 <enthropy> a3f: closest might be:   `do when (x == 1) blah; when (x == 2) blah2; ...`
17:26:09 <a3f> I just tried out getOpts and i got a case tree(?) i want to process now, you need to specify a process in the arguments, you can do that via window name, class name, process id, handle .... etc.
17:26:24 <a3f> and there's much repetitive code I think I should be able to eliminate
17:26:27 <a3f> just dont know how
17:27:47 <enthropy> there are alternatives to getopt that promise to work out with less code
17:27:58 * enthropy uses cmdargs
17:28:54 <enthropy> a3f: if you can paste that repetitive code maybe somebody here will see the pattern/how to eliminate it
17:29:21 <a3f> I am still writing it atm, it's like
17:29:49 <a3f> windowstitle -> HWND -> pid -> Handle
17:29:57 <a3f> HWND -> pid -> Handle
17:30:15 <a3f> for windowstitle and and HWND respectively
17:30:35 <hpaste> flebron pasted “Comments on clarity, design, being idiomatic, improvements?” at http://lpaste.net/92954
17:30:42 <a3f> it just appeared to me in C I would just omit the break; and arrange them under each other
17:30:54 <a3f> and wondered if i couldnt just do the same in Haskell
17:37:53 <Ghoul_> implicit variables are cool
17:37:58 <Ghoul_> err, parameter. things.
17:38:14 <Ghoul_> are there any famous real world uses?
17:38:25 <Thulsadum> my phone book application works :D
17:38:44 <Thulsadum> and this without states.
17:42:13 <hpaste> DanBurton pasted “Diagonal list monad” at http://lpaste.net/92955
17:42:22 <DanBurton> Hey all, is this the right "diagonal list monad"? ^
17:43:09 <elliott> there is no ZipList monad
17:43:21 <elliott> therefore, find the law you violated :)
17:43:33 <dmj`> @typ flip concatMap
17:43:34 <lambdabot> [a] -> (a -> [b]) -> [b]
17:43:34 <DanBurton> >,<
17:43:50 <elliott> the problem is that the lists aren't required to be the same size
17:43:56 <elliott> (if they were, it would be iso to Reader)
17:44:40 <DanBurton> suppose that instead of List, it were "Vect n" for some n. ooohhh I know what to do...
17:45:05 <pavonia> What is a diagonal list, btw?
17:45:29 <elliott> then it is iso to reader
17:45:34 <elliott> (Fin n ->)
17:45:57 <DanBurton> pavonia: it's not the list that's diagonal, it's the monad instance that I'm trying to write
17:46:11 <DanBurton> where "join" selects the diagonal of a matrix [[a]] -> [a]
17:46:37 <pavonia> Ah
17:46:43 <jmcarthur> yeah there is indeed a problem with this idea :)
17:47:45 <DanBurton> I'm messing around with reflection, so I wanted to write "using1 diagonalListMonad $ do x <- [1,2,3]; y <- [11, 22, 33]; return (x, y)" and get "[(1, 11), (2, 22), (3, 33)]" as the result
17:48:16 <jmcarthur> another problem with this monad is just operational. it tends to be inefficient
17:48:49 <jmcarthur> DanBurton: that expression could be written with just Applicative
17:48:56 <jmcarthur> DanBurton: and then you can just use ZipList
17:49:15 <jmcarthur> of course i imagine you have something more complex in mind
17:49:20 <elliott> that constraints stuff is very unsafe, by the way.
17:49:26 <elliott> if you use it to override existing instances.
17:49:42 <thoughtpolice> man, everyone loves that 'using' function
17:49:45 <DanBurton> jmcarthur: indeed. But I am less interested in lists, and more interested in the idea of being able to do exactly what elliott is saying is unsafe
17:50:01 <DanBurton> love love love
17:50:03 <pavonia> :t using
17:50:03 <jmcarthur> elliott: you mean reflection?
17:50:04 <lambdabot> Not in scope: `using'
17:50:09 * thoughtpolice isn't sure he should have included it considering it's so unsafe
17:50:16 <jmcarthur> oh
17:50:20 <thoughtpolice> but it was too good of a trick to pass up writing about
17:50:58 <hpaste> DanBurton pasted “using1 with reflection” at http://lpaste.net/92956
17:51:27 <elliott> jmcarthur: the constraints stuff.
17:51:31 <elliott> reflection is fine.
17:51:34 <elliott> using it to do that is not
17:51:54 <DanBurton> What exactly would you say makes it so "unsafe"? I mean, I get the same sense of unsafety, but I cannot articulate why.
17:52:00 <jmcarthur> i'm afraid i am not familiar enough with the constraints stuff to know the difference
17:52:02 <elliott> GHC can and will use the *real* instance if you break things up enough.
17:52:10 <elliott> two instances is not allowed, something will go wrong.
17:52:15 <thoughtpolice> DanBurton: because GHC will just pick an instance if you fiddle too much
17:52:16 <elliott> if it works it's by accident. don't rely on it
17:52:25 <elliott> for instance, try separating into another top level definition, try separating into another module
17:52:30 <jmcarthur> using it to override an existing instance does sounds scary to me
17:52:32 <thoughtpolice> it's entirely possible for example, for you to just change the scope in which 'using' occurs, and your program will change
17:52:35 <thoughtpolice> which is pretty damn unsafe
17:52:37 <elliott> try poking at it slightly with a stick and watch it topple over
17:52:45 * thoughtpolice actually has an example of this
17:52:47 <DanBurton> lol
17:52:50 <jmcarthur> what happens if i override an Ord instance and use it with a Set?
17:52:55 <thoughtpolice> https://gist.github.com/thoughtpolice/6059758
17:53:10 <thoughtpolice> oh, and that one is super fun too, because it only happens on GHC 7.6, not HEAD, and not 7.4
17:53:20 <thoughtpolice> so yes, it makes your reasoning capabilities go bye-bye
17:53:40 <a3f> main = print =<< findWindow "Tibia" [] -- someone got an idea why this always returns Nothing? In C I would prefix with L for Unicode but Haskell strings are Unicode by default aren't they?
17:54:16 <jmcarthur> a3f: what is findWindow?
17:54:20 <thoughtpolice> hence why i was hesitant to include it in my article. but again it's a neat trick of tying constraints together
17:54:38 <thoughtpolice> (perhaps i should have just left it at 'with', and left 'using' as an exercise for the reader)
17:54:54 <DanBurton> I just like the idea of being able to use first-class instances
17:55:14 <a3f> @jmcarthur Graphics.Win32.findWindow returns the HWND of the process with the specified title
17:55:14 <lambdabot> Unknown command, try @list
17:55:43 <thoughtpolice> sure, i'd suggest just using 'with' if you really want that in a sane manner. using saves you some verbosity, but it has a large cost comparatively.
17:57:12 <a3f> <lambdabot> this works?
17:57:26 <a3f> ahm... how do I specify  auser by name ? ^^
17:57:59 <DanBurton> thoughtpolice: it would be nice to at least have a quasiquoter or something so one doesn't have to sprinkle "Lift" everywhere in a given chunk of code manually
17:59:36 <DanBurton> I just want to be able to syntactically say "this chunk of code uses *this* monad instance"
18:00:04 <DanBurton> instead of dealing with newtypes and lift lift lift everywhere
18:00:53 <DanBurton> and the only other way to get that right now is to bind the relevant function names yourself for your given scope with RebindableSyntax
18:21:01 <flebron> Should I try to align equal signs in a multiline let binding?
18:28:23 <DanBurton> flebron: only if it makes you happy
18:28:37 <copumpkin> liftM f (g =<< x)
18:28:41 <copumpkin> can that be rearranged?
18:29:00 <copumpkin> according to the monad laws, that is
18:29:02 <DanBurton> f `liftM` x >>= g -- does that count?
18:29:05 <DanBurton> ;P
18:29:12 <copumpkin> :)
18:30:10 <DanBurton> well if g = return . h, then it's liftM (f . h) x, if I didn't get that mixed up
18:30:30 <conal> New blog post: "Optimizing CCCs" http://conal.net/blog/posts/optimizing-cccs
18:30:35 <copumpkin> yeah, but g isn't that simple :)
18:30:57 <copumpkin> I think I can move the liftM in
18:31:05 <DanBurton> (g . liftM f =<< x) -- like this
18:31:23 <DanBurton> wait no
18:31:26 <DanBurton> other way around
18:31:34 <DanBurton> (liftM f . g =<< x)
18:32:03 <DanBurton> seems legit
18:32:11 <copumpkin> yup
18:32:38 * hackagebot thyme 0.3.0.1 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.0.1 (LiyangHu)
18:34:22 <copumpkin> perfect, thanks :)
18:36:09 <elliott> conal++
18:36:15 <conal> :)
18:44:24 <DanBurton> bind g >>> fmap f  ==>  bind g >>> bind (f >>> return)  ==>  bind (g >>> bind (f >>> return))  ==>  bind (g >>> fmap f)
18:45:16 <DanBurton> from laws about how fmap f = bind (f >>> return) and how bind f >>> bind g = bind (f >>> bind g)
18:45:40 <CaptainK> is there a printed mailed version of a haskell magazine?
18:46:48 <DanBurton> CaptainK: I am not aware of any such thing. Academic journals for PL, perhaps?
18:46:56 <CaptainK> sure would like to get an ol fasion magazine subscription
18:47:42 <CaptainK> like the old days when programming my zx81
18:48:10 <CaptainK> feature a company using haskell
18:48:22 <CaptainK> feature some cool programming tips
18:49:10 <CaptainK> version debates and future trends
19:04:55 <alastor__> is this the correct way to define a function that takes a list and returns a list of lists? pack :: (Eq a) => [a] -> [[a]]
19:05:29 <pavonia> that isn't really a definition
19:05:31 <alastor__> i mean, does using double [[ like that actually *mean* a list of lists?:
19:05:43 <pavonia> yes
19:07:15 <alastor__> why isn't that a definition? do you mean it's just a signature, without the actual function body?
19:07:42 <pavonia> exactly
19:08:03 <alastor__> ah i see. thanks pavonia
19:08:12 <pavonia> you're welcome
19:17:14 <jhormuz> does anyone know a clever point free way to write (\x -> [x])? (other than "replicate 1", which feels dirty to me)
19:17:39 <glguy> jhormuz: "return" works
19:17:49 <jhormuz> cool
19:18:33 <jhormuz> I didn't think of that, but indeed it does (and I like it better than replicate 1)
19:18:34 <jhormuz> thanks
19:19:02 <ekipan> :t (:[]) -- also the ever-faithful monkey operator
19:19:03 <lambdabot> a -> [a]
19:20:17 <jhormuz> I like that also....  Actually better, because you don't have to figure out what monad is in play when you see it.
19:20:24 <jhormuz> thanks
19:32:04 <user123abc> I'm trying to use a reified type to determine the context of a bunch of nested functions
19:32:50 <user123abc> the top level function has type Asm a => AST -> a -> [a]
19:33:03 <user123abc> and it calls functions which return [a]
19:33:52 <user123abc> however, those functions don't take any argument of type a (for example: Asm a => TAlloc -> Expr -> Loc -> [a])
19:34:37 <user123abc> and I'm getting "Could not deduce (Asm [a]) arising from a use of [called function]"
19:35:16 <user123abc> how can I propogate the type information (?) which the top-level function has down to the others?
19:37:18 <jhormuz> In Control.Lens, is there a better way to write "x %~ (f <$>)", in particular, is there an operator instead of %~ that can allow me to remove the <$>?
19:37:27 <applicative> does this error arise even if you drop the top level signature user123abc ?
19:38:10 <mm_freak_> jhormuz: i think there is:  x . mapped %~ f
19:38:24 <jhormuz> let me try, one sec
19:38:26 <mm_freak_> personally i'd prefer:  x %~ fmap f
19:38:36 <applicative> i was going to side with fmap
19:38:42 <mm_freak_> infix is only good if it's actually infix =)
19:38:59 <enthropy> user123abc: are you using let/where?
19:39:08 <enthropy> user123abc: use case instead
19:39:13 <applicative> well, sections are good, but here its seeming a little deadly
19:40:11 <user123abc> let me paste some relevant snippets
19:40:59 <applicative> user123abc: what type does the compiler infer if you drop the signature, or is that impossible too?
19:41:09 <jhormuz> yup, it worked mm_freak....  thanks.  Now I have to go try to understand why.
19:41:31 <applicative> @type mapped
19:42:03 <applicative>   :: (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
19:42:43 <elliott> mapped is nicer.
19:42:53 <elliott> though it should have a shorter name.
19:43:26 <applicative> if you can stick to the leading four lens combinators, you are doing better, I think
19:43:48 <elliott> I don't know what that means. but mapped is fundamental.
19:43:50 <applicative> else it's like carefully arranging to use >=>
19:43:51 <elliott> it's the original SEC.
19:44:15 <elliott> and composes perfectly uniformly with everything else. in fact it's the prototypical setter so in a way ideal for use with (%~)...
19:44:19 <jhormuz> what are the leading four lens combinators?
19:44:20 <applicative> no, what is fundamental is evading the existing record system
19:44:41 <applicative> well, there is the additional crowd for state, so it isn't really four
19:45:37 <user123abc> http://lpaste.net/4546101455500607488
19:45:48 <applicative> getting and setting are the main operations
19:45:57 <user123abc> note that codeGen takes an argument of type a
19:46:24 <user123abc> I want to enable the type system to deduce that all nested calls take type [a]
19:46:31 <user123abc> rather, return
19:46:52 <applicative> the two forms of setting are simple replacement and modification by a function.
19:46:54 <user123abc> do I just need to insert type annotations, or is this something I can't do?
19:46:57 <applicative> thats about it
19:47:57 <jhormuz> I played with it a bit, and I like mapped because I can chain it in a new lens definition- ie lensA = lensB . mapped . lensC . mapped
19:48:13 <jhormuz> very clean
19:48:24 <user123abc> and yes, applicative dropping the type signatures changes nothing
19:53:06 <applicative> with "Could not deduce (Asm [a]) arising from a use of [called function]" what is the called function?
19:57:29 <user123abc> spotty connection
19:58:10 <user123abc> one example of such a message is: Could not deduce (Asm a1) arising from a use of `genExp'
19:59:08 <user123abc> the issue should be present in the snipped I posted above, but let me try a more complete paste, with the resulting compiler output
20:01:00 <xshay> hello, I'm trying to get runhaskell to work with cabal sandbox. Is this supported?
20:01:00 <user123abc> http://lpaste.net/5343179980421464064
20:01:23 <xshay> I tried using -package-db .cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d
20:01:32 <xshay> but that fails with an error: "Not in scope: `main'"
20:01:52 <acomar> try also passing -main-is?
20:03:23 <jhormuz> so, the docs clearly state that (^~) is an infix version for "set", but when I substitute "a `set` b" with "a ^~ b", I get an error.  What am I missing?
20:04:28 <acomar> set is a function on the State type, ^~ behaves like it, but uses lenses
20:05:17 <acomar> compare them in ghci to see what I mean
20:05:57 <jhormuz> acomar- I am using lenses....  I have been setting my lenses using "theLens `set` value", and wanted to convert to something nicer looking.
20:06:47 <applicative> set is .~
20:07:00 <applicative> but you were already using that
20:07:25 <acomar> jhormuz: shoot, I got set mixed up with put
20:07:31 <applicative> _1 ^~ 2 $ (3,"hi") is (9,"hi")
20:07:41 <applicative> i think
20:08:09 <jhormuz> applicative- that is what I am looking for!  Thanks (sorry, my understanding of lenses is really basic)
20:08:18 <applicative> ^ is here being used in relation to 2 ^ 3 , as in the state us acomar is mentioning ^=
20:08:40 <jhormuz> acomar- no problem
20:09:20 <jhormuz> applicative- oh, interesting....  so ^~ only works on numbers (that explains the error I saw)
20:09:25 <user123abc> applicative, any thoughts on the context issue?
20:10:26 <applicative> jhormuz: yes, exactly it goes with +~ and so on; the same recyling of arithmetic symbols is used with = in ^=, += etc for state context
20:10:44 <applicative> but i always get the characters backward, so dont trust my order ... ;)
20:11:35 <applicative> I take it lambdabot is awol?
20:11:43 <elliott> > ()
20:11:44 <lambdabot>   ()
20:12:14 <xshay> acomar: ah I was passing my option wrong, but now getting "ghc: can't find a package database at :.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d" so I'm guessing that's the wrong option/path
20:12:31 <jhormuz> applicative- I get it, but why is (.~) that?  Shouldn't it just be (~)?  I guess that is already used somewhere else?
20:13:20 <acomar> xshay: no, that should be right. I just made all this work over the last two days :)
20:13:24 <applicative> is ~ already taken up outside the type system? it's not coming to me
20:13:36 <elliott> irrefutable pats
20:13:38 <applicative> > let (~) = (+) in 1 ~ 1
20:13:39 <lambdabot>   <hint>:1:7: parse error on input `)'
20:13:45 <elliott> > let f ~ x = x in f ()
20:13:45 <jhormuz> :t (~)
20:13:46 <lambdabot>   ()
20:13:46 <lambdabot> parse error on input `)'
20:13:49 <applicative> bingo, like elliot says, its taken
20:14:42 <xshay> acomar: https://gist.github.com/xaviershay/c8ea6631fabeaed2b120 does this look right?
20:15:27 <acomar> xshay: "-package-db .cabal-sandbox/blahblah"
20:15:35 <acomar> not "-package-db:.cabal-sandbox/blahblah"
20:16:52 <xshay> acomar: if I do that it interprets that argument as the haskell file to run, and I get that "Not in scope: main" error
20:17:12 <jhormuz> thanks, I didn't know what an irrefutable pat was, I am looking it up now.
20:17:19 <acomar> xshay: it works for me if I pass the haskell file first and options to ghc after
20:17:21 <xshay> ah though in the verbose output is says it is searching in that path
20:17:27 <joelteon> irrefutable patterns rock
20:22:20 <xshay> acomar: how does that work? From runhaskell --help: "Usage: runghc [runghc flags] [GHC flags] module [program args]"  anything after haskell file is program args?
20:22:36 <xshay> (and that's the behaviour I'm seeing - putting -package-db after file name doesn't add package to search path)
20:23:12 <acomar> xshay: one sec, let me check in the terminal
20:23:36 <xshay> acomar: thanks, I added extra output to that gist if it's helpful
20:26:04 <acomar> xshay: try wrapping the -package-db argument in quotes
20:26:32 <acomar> -v3 says it's actually searching for packages there when I do it that way
20:26:46 <xshay> acomar: works! <3 <3 <3
20:26:49 <xshay> thanks you so much
20:26:58 <acomar> no problem
20:27:17 <latermuse> I made a haskell server that is doing 5k connections a second. However, my users are asking for me to implement secure http. Is there a quick and easy way to implement https in haskell?
20:29:12 <haasn> latermuse: you are making this from scratch or using some framework like yesod, warp or happstack?
20:29:17 <latermuse> scratch
20:30:00 <latermuse> using these imports: Network, Network.Uri, Network.HTTP.Conduit
20:30:02 <haasn> well, I don't know if I can be of much help but there seems to be an implementation of TLS (the encryption layer HTTPS uses) here http://hackage.haskell.org/package/tls
20:30:35 <haasn> http://hackage.haskell.org/package/network-conduit-tls
20:30:37 <haasn> relevant?
20:31:27 <latermuse> haasn: Very. Thank you :)
20:31:49 <haasn> but be very careful, and very afraid. I wouldn't trust it to be secure, personally
20:31:50 <skirmish> @pl \x -> (x, id x)
20:31:50 <lambdabot> join (,)
20:32:12 <skirmish> @pl \x -> (x, 2 * x)
20:32:12 <lambdabot> ap (,) (2 *)
20:32:57 <latermuse> haasn: I dont need it to be secure. I just need security theater for my users. The stuff im doing doesnt even necessitate https, im not sure why they are requesting it.
20:33:06 <skirmish> @pl \(a,b) (c,d) -> compare b d
20:33:09 <lambdabot> ap (const (flip (ap . flip ((.) . const . compare) fst) snd) . fst) snd
20:33:09 <lambdabot> optimization suspended, use @pl-resume to continue.
20:33:16 <haasn> latermuse: there are also bindings to openssl which is probably a more secure implementation than whatever high level crypto ‘tls’ is doing
20:33:17 <haasn> ah, okay
20:33:24 <haasn> not like SSL is very secure in the first place :)
20:33:31 <latermuse> yeah
20:33:48 <haasn> I guess it's just there to stop noname third parties from reading your data
20:33:51 <latermuse> im just running a forum. no need for NSA-level security
20:33:58 <acomar> latermuse: maybe they're afraid of a man in the middle attack?
20:34:07 <acomar> password theft, that sort of thing?
20:34:10 <skirmish> @pl-resume
20:34:14 <shachaf> haasn: Not very secure how?
20:34:16 <lambdabot> ap (const (flip (ap . flip ((.) . const . compare) fst) snd) . fst) snd
20:34:16 <lambdabot> optimization suspended, use @pl-resume to continue.
20:34:27 <haasn> shachaf: what is that a reply to? SSL in general?
20:34:49 <shachaf> Yes (but off-topic in this channel; better to talk in the other one).
20:34:51 <Cale> latermuse: There's some stuff for specific frameworks... http://hackage.haskell.org/package/happstack-server-tls and the snap server includes TLS support if configured for it.
20:34:55 <latermuse> acomar: yes. they are scared of MITM. My authentication and login servers are running openssl. They are requesting https on my file serer now (which is written in haskell)
20:42:15 <leroux> @pl \x y -> head $ repeat x y
20:42:18 <lambdabot> ((head $) .) . repeat
20:42:18 <lambdabot> optimization suspended, use @pl-resume to continue.
20:42:31 <carter> latermuse the tls lib is probably fine
20:42:44 <carter> but if you can use a tls baked into snap or something
20:42:47 <carter> ti'll probably be nicer
20:43:59 <latermuse> probably would be, but i dont have time to rewrite my code into snap :(
20:44:52 <carter> latermuse ask the folks on #snapframework
20:45:00 <carter> they have have good advice
20:45:02 <carter> and be helpful
20:45:08 <latermuse> okay! Thanks carter
20:45:18 <carter> if they're not helpful, i'll know :)
20:45:34 * carter laughs with thunder in the background
20:45:48 <latermuse> hehehe, do you work on snap?
20:47:35 <carter> nope
20:47:39 <carter> i'm just really loud
20:47:46 <carter> and i know some of the people
20:47:46 <latermuse> do you write a blog?
20:47:50 <carter> and they'll want to help
20:47:52 <carter> latermuse i should
20:47:53 <YayMe`> So I have something to parse, no big deal I started using parser combinators which is all fun and good, but as I'm going along, it feels like for this particular type of thing parser combinators are more than necessary. It's fixed length defined data, what might be a better approach?
20:48:05 <latermuse> I wish I lived in europe or america, I would show up to every damn haskell get together
20:48:14 <carter> need tofinish updating my site
20:48:21 <carter> latermuse: i gave a nyc haskell talk 3 months ago
20:48:29 <carter> and i tweet wayyyy too much
20:48:41 <YayMe`> basically 3 digits for this followed by 4 digits for that followed by 20 digits for this and so on and so forth, minimal need for alternatives or for many, no need for recursion etc
20:48:50 <latermuse> YayMe` Is it the same every time guaranteed?
20:48:59 <latermuse> carter: whats your twitter? ill follow you
20:49:01 <carter> latermuse go on that irc channel and ask!
20:49:03 <carter> google me
20:49:06 <carter> simpe
20:49:12 <carter> *simple
20:49:17 <latermuse> google "carter"
20:49:17 <carter> @cartazio though
20:49:17 <lambdabot> Unknown command, try @list
20:49:36 <carter> do a  /whois for full name first
20:49:37 <carter> :p
20:49:38 <YayMe`> latermuse: I don't have to be flexible, if I get something that doesn't match their spec I drop it on the floor, and their spec guarantees fixity, no delimiters etc
20:50:11 <leroux> carter: It's funny how you teach people while leading them to their goal instead of telling them the solution to fulfill their goal.
20:50:14 <leroux> =)
20:50:16 <leroux> It's great.
20:50:22 <carter> leroux i do?
20:50:36 <latermuse> leroux: its the mark of a good teacher
20:50:40 <leroux> It is.
20:50:41 <carter> when have i done this?
20:50:42 <Cale> YayMe`: Even though parser combinators might be overkill, they're probably good enough at handling a case like that.
20:50:47 <YayMe`> I started going down the path of just using list destructuring, but that falls apart when I run into needing 20 digits, so I started thinking about just using take and drop which actually might be ok though threading it together may not be super clear
20:51:10 <leroux> carter: Tip to /whois instead of mentioning your name, I guess.
20:51:10 <latermuse> YayMe` take and drop could work, but its not easy to read
20:51:11 <carter> leroux i want examples!
20:51:15 <carter> oh
20:51:17 <YayMe`> Cale: they do the job great sure, I already wrote half of them, they're just kind of something I feel I lean on too much (because they're fun and easy)
20:51:22 <carter> thats just me being lazy in a perverse way
20:51:25 <Cale> heh, you could use the State monad
20:51:43 <carter> leroux though you may note how whenever say "do X"
20:51:47 <latermuse> Try nested if statements
20:51:48 <YayMe`> latemuse: that was my thought as well, I'd have to implement my own abstraction to thread the take/drop together at which point I may just be better off using the parser combinator abstraction already available
20:51:52 <Cale> If you're interested in performance, it should be easy to switch to something like attoparsec
20:51:54 <carter> i do like to say "heres how to do it concretely"
20:51:58 <carter> attoparsec is nice
20:51:58 <Cale> Or the Zepto module inside of that
20:52:34 <Cale> http://hackage.haskell.org/packages/archive/attoparsec/0.10.4.0/doc/html/Data-Attoparsec-Zepto.html -- this is optimised for your case
20:52:51 <carter> latermuse #snapframework
20:52:52 <carter> go there
20:52:53 <YayMe`> Cale: Just thought I should ask because there might be something out there that's better for super easy no-search parsing like this
20:53:09 <carter> YayMe` for binary formats, binary and cereal are nice too
20:53:09 <YayMe`> not concerned with performance
20:53:22 <latermuse> carter: The thing about snap is that I dont have time to rewrite my code into snap. My system is already live and running 5k connections a second on one of the biggest websites in the world
20:53:40 <YayMe`> carter: ascii only (it's actually a protocol implemented ages ago specifically for 7/8-bit rs232 line transmission
20:53:50 <carter> latermuse whats your time scale?
20:53:53 <latermuse> 1 day
20:54:09 <carter> can you name the site?
20:54:09 <latermuse> need to deploy https today
20:54:14 <latermuse> 2ch.net
20:54:17 <carter> ok
20:54:28 <carter> proprietary code base?
20:54:31 <carter> or oss
20:54:32 <carter> ?
20:54:56 <YayMe`> I could do it bite-wise but at the end of the day everything I'm parsing is either a fixed-width string, or a fixed-width numeric with leading 0s
20:55:07 <YayMe`> *byte-wise
20:55:15 <carter> latermuse: importantly, do you have a HTTPS cert for the domain yet?
20:55:24 <YayMe`> so using string parser combinators
20:55:27 <carter> and all that that entails?
20:56:25 <carter> latermuse you probably want a decent HTTPS cert so the site works for everyone...'
20:56:50 <carter> latermuse more importantly, why do you operationally need https "today"
20:57:02 <enthropy> latermuse: you can run apache or lighttpd that proxies your haskell server
20:57:07 <latermuse> mostly proprietary
20:57:25 <carter> ok
20:57:26 <latermuse> I have an HTTPS cert
20:57:39 <carter> honestly thats probably the best "will work in 1 day"
20:57:41 <carter> approach
20:57:49 <latermuse> operationally, I dont need https at all. but the users are requesting it because we are just recovering from a huge hack
20:58:19 <carter> ok
20:58:20 <latermuse> the fucktard engineers before me didnt setup any security at all
20:58:24 <carter> ok
20:58:31 <carter> so for initial pr mitigatio
20:58:37 <carter> the proxy approach is probably best
20:58:37 <latermuse> yes
20:58:54 <carter> you also need to get a GOOD https cert for the domain
20:58:59 <carter> i'm not sure whats needed for htat
21:01:53 <YayMe`> Well, if nothing else a simple abstraction on take/drop to thread it along in a declarative fashion makes for a fun exercise to see what I can come up with, and I'm not at work so let's see what I can come up with I suppose..
21:02:30 <YayMe`> though translating abstractions from Haskell back into F# is annoying
21:09:53 <bryanvick> Just read 5 chapters of a Scala book for homework...made me miss Haskell
21:10:29 <hpaste> flebron pasted “Comments on clarity, design, being idiomatic, improvements?” at http://lpaste.net/92961
21:10:46 <flebron>  /me is looking for comments on the above code :o
21:15:08 <flebron> ... also apparently I can't /me.
21:15:37 <ReinH> flebron: use pattern matching instead of case for drawShape
21:16:06 <flebron> Hrm, that was something I had read in some style guide, that cases were preferred to multiple definitions. I initially had used multiple definitions :)
21:16:21 * flebron changes
21:16:23 <ReinH> That style guide is dumb.
21:16:28 <ReinH> pattern matching exists to be used.
21:17:41 <ReinH> you also have a lot of functions a -> IO (), which implies that you could probably do more to separate pure functions from IO
21:18:24 <flebron> Hrm unfortunately most OpenGL functions I see are -> IO () :(
21:18:30 * flebron looks for a better way
21:18:41 <ReinH> thing about intermediate representations
21:18:44 <ReinH> *think
21:20:20 <flebron> Perhaps as an object with 3 things, a color, a primitive, and a set of Vertex2's
21:21:00 <flebron> (since it seems I'm always doing color, then renderPrimitive ___, then a series of vertices)
21:21:32 <bss> So, https://github.com/eagletmt/ghcmod-vim OR ( https://github.com/bitc/vim-hdevtools AND https://github.com/scrooloose/syntastic ) or BOTH?
21:21:54 <bss> Or is there a better vim-oriented option?
21:22:13 <YayMe`> emacs wins haskell.
21:22:18 * ReinH shrugs
21:22:20 <ReinH> vim is pretty good
21:22:49 <acomar> bss: I like ghcmod-vim + haskellmode-vim + syntastic
21:23:06 <YayMe`> ReinH: Yes, but.. emacs wins :D
21:23:08 <ReinH> +1
21:23:13 <ReinH> YayMe`: thanks.
21:23:32 <ReinH> enjoy your illusory superiority
21:25:15 <highlighters> Thanks.
21:26:09 <bss> acomar: Thanks.  I was going to add haskellmode-vim defintiely.
21:26:31 <bss> acomar: Does syntastic do much without vim-hdevtools?
21:26:39 <highlighters> ?
21:26:50 <acomar> bss: yea, there's no requirement on vim-hdevtools
21:27:37 <acomar> bss: was there some functionality in you were looking for in particular?
21:28:13 <bss> acomar: Not really, I've been using plain vim to do Haskell development for a couple of years.
21:28:32 <acomar> bss: yea, then as far as I know it'll do everything you want :)
21:28:51 <acomar> bss: make sure you eventually check out and configure neco-ghc + neocomplete or neocomplcache
21:29:33 <bss> acomar: I was just trying to find the best "enhancements".  Getting vim to recognize GHC errors and jump to them would be a step forward.
21:29:44 <acomar> bss: yea, small steps are best :)
21:32:46 <acomar> bss: take a look at vim2hs as well -- it generally makes vim play nicer with haskell with better syntax coloring, indentation support, hlint, etc.
21:47:25 <NemesisD> any yesod folks around, johnw perhaps?
21:48:12 <shachaf> @where yesod
21:48:12 <lambdabot> #yesod - http://yesodweb.com/
21:48:30 <NemesisD> its rather dead in there atm
21:50:52 <spaceships> if you had a fold, how could you test to see whether it was foldl or foldr?
21:51:26 <enthropy> > foldr (/) 1 [2,3,4]
21:51:27 <lambdabot>   2.6666666666666665
21:51:30 <enthropy> > foldl (/) 1 [2,3,4]
21:51:31 <lambdabot>   4.1666666666666664e-2
21:51:45 <spaceships> ah, cool, thanks
21:52:50 <NemesisD> foldl/foldlr just changes the argument order right
21:53:06 <NemesisD> of the accumulator function*
21:53:35 <dwcook> > (foldr (flip const) 0 [2, 3, 4], foldl (flip const) 0 [2, 3, 4])
21:53:35 <carter> the commutative
21:53:36 <lambdabot>   (0,4)
21:53:38 <carter> or lackthereof
21:53:48 <augur> are there any standard techniques for associating substrings of a show-ed term with the parts of the term it comes from?
21:53:49 <carter> also the space behavior
21:54:10 <carter> you mean source location mapping?
21:54:18 <augur> carter: is that to me?
21:54:22 <carter> augur yes
21:54:35 <augur> i dont know what source location mapping is, but maybe!
21:54:42 <carter> seems liek you'd have a  tree of an AST
21:54:52 <carter> and then you do a FoldL over teh tree
21:55:07 <carter> keeping track of the shift in so far
21:55:11 <carter> and in tandem
21:55:25 <carter> generate a new version of teh treee with the "i start here in the text im merging"
21:55:30 <carter> while also rendeirng the string
21:55:34 <augur> what
21:55:38 <augur> what are you saying
21:55:40 <carter> ok
21:55:40 <augur> are you drunk
21:55:43 <carter> nope
21:55:44 <carter> tried
21:55:46 <carter> *tired
21:55:47 <carter> ok
21:55:49 <carter> so you're saying
21:55:55 <carter> "I have an AST i want to pretty print"
21:56:13 <carter> "when someone clicks on a bit of text, i want to select the associted bit of AST internally"
21:56:20 <carter> yes or no?
21:56:35 <augur> well, not entirely, but sort of, sure
21:56:38 <carter> (as in structure aware editor)
21:56:56 <carter> which part am i being confusing wiht?
21:57:06 <augur> actually yeah, that, lets just say that
21:57:17 <augur> the rest of what you said is nonsense to me :P
21:57:20 <carter> ok
21:57:50 <augur> but i need more than just hit testing
21:57:50 <bss> NemesisD: Sort of.  One fold is 1 + (2 + (3 + 4)) the other is ((1 + 2) + 3) + 4
21:58:03 <carter> augur what do you want?
21:58:20 <augur> hit testing is, i guess, sort of easy. you can just count up the size of the subterms and store it, then do a tree search
21:58:29 <carter> oh
21:58:34 <carter> augur zippers
21:58:38 <bss> spaceships: I'd probably use the First / Last Monoids.
21:58:50 <augur> what i want to do is highlight the substring for a given term
21:59:03 <spaceships> i was missing the flip in foldl "f z x = appEndo (getDual (foldMap (Dual . Endo . flip f) x)) z"
21:59:13 <carter> highlight it when you ...?
21:59:19 <augur> when its selected
21:59:20 <NemesisD> bss: so if the function is associative(?) then they are equivalent but with different accumulator arg order?
21:59:23 <shachaf> Is that lens code?
21:59:31 <spaceships> bss: to build foldl/r?
21:59:38 <carter> augur could you be more precise?
21:59:47 <carter> by having selected it, isn't it highlighted>
21:59:47 <augur> carter: er.. whats to be more precise about?
21:59:50 <bss> spaceships: No, to detect if a fold was left or right.
21:59:54 <carter> ?
21:59:56 <augur> carter: no? why would it be highlighted
22:00:14 <carter> because when i've selected some text, its a different color :)
22:00:25 <carter> i'm being pedanticly detailed oriented
22:00:25 <augur> who said im selecting text
22:00:31 <carter> i need more info :)
22:00:44 <bss> NemesisD: For associative operations, the parenthesis group left/right.
22:00:45 <carter> could you explain the interaction more?
22:01:01 <carter> that said
22:01:03 <carter> i do have an idea
22:01:03 <spaceships> bss: neat idea, trying it
22:01:12 <augur> nevermind carter
22:01:15 <bss> NemesisD: For non-associative operations, where the accumulator has a different type than the element, the acccumulator is on the left/right.
22:01:39 <carter> augur: one thing you could do, is have the text intervals be associated with a zipper into the AST
22:01:41 <bss> (afk)
22:01:51 <carter> and use those to directly go to the right ast subtree
22:02:05 <carter> because a zipper is just a path into a tree!
22:02:10 <carter> (or a least it can be)
22:02:22 <carter> i'm tired, so i'm probably not helping
22:32:13 <YayMe`> ReinH:
22:32:16 <YayMe`> oops
22:48:46 <NemesisD> YES
22:49:01 <NemesisD> i've painstakingly wresteld control of the logging stream from yesod
22:49:07 <NemesisD> good lord
22:53:13 <carter> oh?
22:53:23 <carter> is that hard to do?
22:57:28 <NemesisD> if you don't want the logs to go to a file it is non obvious
22:58:21 <NemesisD> after a few unsuccessful tries, the solution was to reproduce the middlware stack but substitute your own requestlogger middleware
23:01:56 <carter> so its like figuring out how to do something complicated with Setup.hs the first time
23:02:03 <carter> really painful to figure out
23:02:06 <carter> but easy in retrospect
23:02:48 <carter> ?
23:03:22 * carter i'm crashing, night all
23:09:32 <NemesisD> carter: kinda, my solution has a bit of a maintenance problem
23:09:58 <NemesisD> if the yesod team ever changes the default middleware stack i won't benefit from it unless i happen to discover tht
23:10:18 <carter> NemesisD: hows that compre vs the happstack or snap architectures?
23:11:16 <NemesisD> ive never tried happstack, but i usually hit a wall with snap and end up abandoning it for yesod
23:11:35 <carter> NemesisD: which walll
23:11:42 <carter> the batteries aren't included wall?
23:12:13 <NemesisD> snap is nice because it is easy to reason about most of the time but im not a fan of the snaplet pattern and don't like how much work I have to put in to get typesafe routing on par with yesod
23:12:38 <carter> NemesisD: can't you just use the routing lib from yesod in snap?
23:12:50 <NemesisD> yesod's model of having a foundation type fits my needs almost every time
23:12:56 <carter> ok
23:12:57 <carter> i know nothing
23:13:18 <NemesisD> carter: not easily no. i've tried for a few hours before to port some manner of typesafe routing to a snap app with no success
23:13:29 <carter> huh
23:13:35 <carter> email them and ask how
23:14:21 <NemesisD> eh. it seems like it isn't their preferred method of routing, id rather use yesod than try to force snap to be yesod
23:14:34 <carter> k
23:15:36 <NemesisD> i endorse the snap team's http client (http-streams) over the yesod team's (http-conduit?) if that counts for anything ;)
23:15:57 <carter> i've just had beer with oz and mightybyte a number of times
23:16:10 <carter> and mightybyte/doug really cares about doing things well
23:16:30 <NemesisD> is mightybyte cowie or gregory collins?
23:17:32 <Enigmagic> upside of http-conduit: we've crawled hundreds of millions of web pages with it and found/fixed some bugs in the process
23:18:03 <Enigmagic> every http client has issues, needs lots of real world testing to find them though.
23:18:42 <NemesisD> Enigmagic: true story. the http-streams guys fixed a bug i found where 204 requests from some servers (notably warp) would hang forever
23:19:13 <NemesisD> i think i'm waiting for most people writing stream libraries to give up or merge and then I can just learn the winner
23:19:20 <Enigmagic> yeah, so i don't really care which one is better... i think it's stupid we have 5 different http clients.
23:19:46 <NemesisD> i've found that time pays dividents on Snoyman's APIs, the longer I hold off on using them the nicer and nicer they get
23:19:58 <carter> yeah
23:20:01 <carter> this is true
23:20:06 <carter> which is why i don't use them
23:20:07 <NemesisD> Enigmagic: oh boy you would not enjoy the ruby ecosystem then ;)
23:20:33 <NemesisD> i work on a web app at work in Ruby that uses 4 or 5 http clients just in the project
23:20:36 <Enigmagic> NemesisD: if there was a single test suite that everyone used that'd be fine.
23:20:59 <carter> i tried to find a BNF for ruby once
23:21:13 <carter> the parser code for ruby winked back at me
23:21:29 <NemesisD> did it tussle your hair "that's so cute" :P
23:21:49 <NemesisD> the tyranny of choice is real
23:22:29 <NemesisD> whenever someone needs to build a feature into our app that does stuff with HTTP, they remember how crap the last HTTP client was and adds a dep for the next one up
23:23:13 <NemesisD> none is worse than the one in the stdlib
23:23:49 <joneshf-laptop> NemesisD: for ruby?
23:23:49 <NemesisD> some of the worst idiomatic ruby programmers are the ones that write the standard libraries, but i digress :P
23:23:54 <NemesisD> joneshf-laptop: yeah
23:30:05 <quinso> Is haskellmode-vim here http://projects.haskell.org/haskellmode-vim/ up to date? The current hyperlink says 20101118 while on github https://github.com/lukerandall/haskellmode-vim latest commits are a year ago.
23:35:06 <chas_> from /r/haskell: "You can replace it with the cofree comonad over a base functor." - can someone point me to an explanation of "cofree comonad," thanks!
23:35:55 <chas_> source: http://www.reddit.com/r/haskell/comments/1kzwlg/ideas_for_annotating_an_ast_with_custom_data/
23:36:09 <shachaf> data Cofree f a = Cofree a (f (Cofree f a)), in Haskell.
23:37:29 <AfC> NemesisD: mightybyte is Doug Bearsley. I am Andrew cowie
23:39:11 <NemesisD> Hey Andrew! How's it going?
23:40:33 <AfC> NemesisD: yo. I'm usually in #haskell; you can reach out to me anytime if you need to ask something about the http-streams library.
23:40:53 <AfC> NemesisD: I'm pretty pleased with it at this point; there are one or two bugs but nothing glaring.
23:41:38 <AfC> NemesisD: I've also committed to Tekmo that I'm going to port http-streams to Pipes as pipes-http and will maintain the two in parallel with morally equivalent (if not ABI compatible, of course) API faces.
23:42:01 <NemesisD> AfC: yeah i've found it and io-streams to be pretty easy to pick up and reason about. there really aren't a lot of concepts/types at play
23:42:07 <AfC> I should have that done by the end of the month; had to wait for pipes 4 to stabilize before I could make any more headway on it.
23:42:44 <AfC> NemesisD: yeah. I intend to keep using it, and once gcollins lands the io-streams based Snap server it'll be a knocked-out-of-the-park situation for my use case.
23:42:49 <NemesisD> AfC: is there a pragmatic reason to choose one or the other between http-streams and pipes-http?
23:43:16 <AfC> NemesisD: but I'm enthuisastic about Gabriel's work, and want to have the "same" HTTP client library there. So I'm doing it.
23:43:24 <AfC> NemesisD: nope
23:43:55 <AfC> well, with the possible exception that type errors from io-streams don't have seven type variables in them :)
23:44:09 <NemesisD> lol
23:44:42 <NemesisD> i'm glad i don't currently deal with any problems that require one of the major streaming libraries
23:44:44 <AfC> I ***really*** wish Haskell would respect type aliases in compiler errors
23:45:02 <AfC> ie, if I have type Object = HashMap Text Value (as one does working with Aeson) and get a compiler error,
23:45:02 <NemesisD> oh my god yes
23:45:17 <AfC> I really want to hear about Object and not "missing instance for blah blah blah"
23:45:42 <AfC> Old Haskell hands are willing to put up with a lot, but this is a killer for newcomers.
23:48:30 <Ghoul_> how do I have a type only for the sake of being a type I can do typeclass things with
23:48:47 <Ghoul_> I don't want it to carry any data but I want it to be able to be instantiated for
23:48:57 <NemesisD> newtype?
23:49:02 <Ghoul_> newtype A = A -- ?
23:49:19 <NemesisD> yeah or newtype A = A { unA :: _ }
23:49:37 <Ghoul_> is it possible for it to be empty
23:49:43 <NemesisD> also i hear that Iso from lens might fit the bill too
23:49:55 <NemesisD> if you make it a Maybe
23:51:25 <quinso> How do I install haskellmode-vim from github that is an unpacked copy of vimball?
23:52:01 <Enigmagic> Ghoul_: data A = A
23:52:15 <NemesisD> quinso: do you use vundler or pathogen
23:52:48 <quinso> NemesisD: I don't, should I?
23:52:52 <quinso> I am pretty new to vim
23:53:32 <NemesisD> quinso: i like it. i'd check out vundler first because i use pathogen and it isn't perfect
23:53:52 <NemesisD> for vim plugins i add a git submodule to my vim dir (which is a git repo)
23:54:04 <NemesisD> but i also don't know how submodules work so.. :P
23:54:39 <haasn> NemesisD: an.. interesting set of circumstances
23:55:25 <NemesisD> works okay, i suspect vundler may have a better way
23:55:48 <haasn> I was referring to adding git submodules but not knowing how git submodules work :P
23:55:53 <NemesisD> if submodules weren't so awful it would be perfect, the point of pathogen is you store plugins in separate directories and it makes sure those are available to vim
23:56:04 <NemesisD> so when you want to get rid of a plugin you just trash that directory
23:56:54 <haasn> I handle vim plugins through my OS package manager, along with everything else
23:56:57 <Ghoul_> thanks Enigmagic
23:58:46 <NemesisD> i'm certain some plugins i use are not available through that method
23:58:47 <quinso> Can I use vundle for plugins that weren't specifically written to work with it?
23:59:17 <haasn> NemesisD: I'd make my own packages for them, as I do routinely with obscure stuff diagrams HEAD
23:59:30 <haasn> obscure stuff like*
