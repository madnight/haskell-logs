00:04:38 <Ghoul_> wow the crypto packages are just confusing
00:04:54 <Ghoul_> Theres like 5 or 6 of them and between versions all the things they have or had just randomly change
00:05:33 <thirsteh> On the Haskell wiki it says one of the biggest performance mistakes is to move small computations up in scope, i.e. where result = someSmallComputation; x = result + 1; y = result + 2 is much worse than x = someSmallComputation + 1; y = y someSmallComputation + 2. Is this really true? If so, how small are we talking? Does this mean doing where afield = dataField v; x = afield + 1; y = afield + 2 is also worse?
00:06:51 <Ghoul_> probably negligible
00:07:10 <Ghoul_> because of the strictness analyser?
00:08:00 <thirsteh> Ghoul_: Yes... I've also heard the advice that it doesn't matter if you have 2x someComputation because it's clever enough to do the equivalent of adding a shared where binding, so I'm confused
00:08:20 <carter> thirsteh: Ghoul_  link to the wiki article so i can see wha tyour'e thinking of?
00:08:28 <thirsteh> the former seems much more right to me.
00:08:33 <thirsteh> just a second. let me find it
00:08:52 <thirsteh> I'm asking mainly because people inhere have adviced against stuff on the wiki more times than I can count
00:09:17 <carter> thirsteh: the best way to answer these questions
00:09:21 <carter> is to benchmark :)
00:09:26 <thirsteh> yeah, I know
00:09:57 <carter> thirsteh: therese many tecniques you can do, based upon understanding how the compiler works
00:10:03 <carter> but eventhen, benchmarking is king
00:10:09 <johnw> thirsteh: can you link to the page where you read that?
00:10:24 <carter> johnw: i asked too
00:10:26 <carter> :)
00:10:41 <thirsteh> I read it earlier, and of course I cleared my history when I cleared cache a while ago, so give me a min
00:11:09 <thirsteh> it was on one of the profiling pages I was reading when figuring out -fprof-auto existed earlier
00:11:17 <thirsteh> or rather, when you told me it existed
00:12:17 <Ghoul_> carter: Idk, never seen that on the wiki
00:12:24 <Ghoul_> I just answered his Q.
00:12:27 <carter> the wiki has many crufty corners
00:12:36 <Ghoul_> its really really really old
00:12:46 <carter> Ghoul_: i don't thinki its the strictness
00:12:52 <carter> i think its got to do with inliing
00:12:59 <Ghoul_> the wiki is probably talking about generating a thunk for the shared computation
00:13:05 <Ghoul_> where its more expensive to do so than computing it twice
00:13:20 <fylwind> how old? :)
00:13:23 <Ghoul_> the strictness analyser would pwn that probably
00:13:27 <Ghoul_> I hope.
00:14:00 <johnw> i can only think of one case where that advice might be true
00:14:10 <johnw> say that someSmallComputation, when evaluates, return a really huge data structure
00:14:18 <carter> lazily
00:14:21 <Ghoul_> anyhow, I'm probably in the guilty basket. I float everything out because I don't trust GHC to do it for me. I almost /always/ get a performance improvement in 7.6.3 by floating stuff out manually :|
00:14:21 <carter> or something
00:14:26 <johnw> which is forced by evaluating x
00:14:40 <johnw> however, y is still a thunk, except that now it holds a reference to this really big data structure in *its* thunk
00:14:43 <carter> also theres some inlining that happens when a value is used only once, and not when its used twice
00:14:49 <carter> Ghoul_: i'm worse,
00:14:51 <johnw> so, even if y is never evaluated, or doesn't need to hold onto all of that data, it will
00:14:57 <carter> i write teh code to generate the asm i want :)
00:15:13 <thirsteh> johnw: the wiki mentioned that it would "cause the whole mapping to remain in memory", but it wasn't clear that it was talking about a gc rather than a performance "issue"
00:15:28 <carter> oh
00:15:30 <thirsteh> what you said makes sense, but the description was vague/made it sound like it was more expensive to share e.g. 1..1000
00:15:32 <johnw> well, I think it means that evaluating x changes the memory footprint of y
00:15:41 <carter> yeah
00:15:42 <carter>  that
00:15:42 <johnw> so even if you evaluate x and throw the result away, y will now hold onto the data
00:15:48 <thirsteh> yeah
00:15:49 <carter> somtimes its cheaper to recompute things
00:15:52 <thirsteh> reference is kept
00:15:56 <johnw> right
00:15:58 <thirsteh> but cheaper memory-wise, not computationally
00:15:58 <carter> because memory usage  / cache thrash
00:16:04 * thirsteh nods
00:16:07 <carter> thirsteh: no, could make things slower
00:16:09 <thirsteh> can't find the wiki page *sigh*, but I'm sure that's it
00:16:10 <johnw> by splitting the reference, you may win, you may lose
00:16:14 <Ghoul_> the smarter way to do that is to use lists and do hackery so you only hold references to head points with tails you need
00:16:21 <Ghoul_> then it can throw away heads of lists and keep tails shared
00:16:27 <carter> the best way is
00:16:28 <johnw> but that at any rate one shouldn't assume he will win, the way you would in a strict language
00:16:31 <carter> "i tepends"
00:16:35 <carter> *it depends
00:16:36 <thirsteh> all I know is that it's on the haskell wiki and they used the words "cheap", "mapping", "memory" and [1..1000], heh
00:16:43 <carter> and that you should first write the correct code
00:16:45 <carter> and then fix it up
00:16:50 <carter> unles syou're trying to beat fortran
00:17:23 <thirsteh> the only thing I don't love about FP is that sometimes there's too much magic going on to easily understand what's good or bad
00:17:35 <johnw> yes, I tend to try to write the clearest code possible, ignoring performance subtleties, and then read over the code looking for obvious issues once it's working; and then profile to find the real issues after that
00:17:40 <thirsteh> granted, a lot of the stuff that goes on isn't possible in many compilers for other languages, so it's not exactly bad...
00:17:57 <johnw> plus, GHC is always getting better
00:18:12 <johnw> so it never really pays to assume a better operational understanding than the compiler; profiling is your friend, always
00:18:13 <thirsteh> johnw: nod, profile if you end up having a problem is a good philosophy. I'm mainly just curious
00:18:23 * thirsteh agrees violently
00:20:22 <carter> i agree even more
00:20:34 * thirsteh agrees to the death
00:20:41 <carter> i finish writing my first (small) ghc patch this past week
00:20:50 <carter> and it totally reinforces my "benchmark it"
00:20:51 <carter> stance
00:21:10 <carter> thirsteh: ghc will have prefetch on -fasm!
00:21:18 <thirsteh> cool
00:21:31 <carter> ok
00:21:34 <carter> i need to crash
00:21:35 <carter> night all
00:22:09 <johnw> better that you crash than GHC!
00:22:12 <Ghoul_> you and your benchmark it
00:25:19 <carter> Ghoul_: jokes on you, on ppc and sparc, -fasm prefetch is a noop
00:25:36 <carter> :P
00:25:52 <carter> though if someone writes a patch for that, and can test it on real hardware
00:25:57 <carter> it'd get in
00:26:15 <Ghoul_> who on this blue dot actually has a ppc and sparc at disposal
00:26:22 <Ghoul_> I've never seen one of those machines in my life ;_;
00:26:29 <carter> ppc is on some crazy IBm enterprise hardware I hear
00:26:39 <thirsteh> haha
00:27:06 <carter> i think the modern ibm power7 chips, you can even do hot CPU swapping
00:27:28 <Ghoul_> I've always had those moments
00:27:28 <carter> http://en.wikipedia.org/wiki/POWER7
00:27:40 <Ghoul_> where it's like "damn, I wish I could swap my CPU while my computer was running"
00:28:02 <carter> theres also a really funny "turbo mode"
00:28:14 <carter> that turns off all but one core, but overclocks the core
00:28:25 <carter> because some enterprise software gets PRICEY for the multicore version
00:28:28 <carter> and they enforce it
00:30:37 <Ghoul_> lol
00:31:17 <carter> like, i think  oracle software is 50k per core
00:31:22 <Ghoul_> actually now that you mention it, I remember hearing from a friend doing engineering that the place he did a placement at uses their software in a huge virtual thing that does balancing because the software they were using was 5-digits per core
00:32:39 * Ghoul_ isn't very impressed by the state of crypto on hackage
00:35:04 <carter> Ghoul_: which libs?
00:35:22 <carter> https://github.com/vincenthz?tab=repositories has a bunch
00:35:33 <carter> Ghoul_: use hackage beta to explore
00:35:38 <carter> http://beta.hackage.haskell.org/package/crypto-api
00:35:38 <thirsteh> the stuff written by Vincent Hanquez is usually okay
00:35:44 <carter>  http://beta.hackage.haskell.org/package/crypto-pubkey
00:35:53 <carter> thirsteh: yeah
00:36:00 <carter> thats the main person hacking on that stuff
00:36:14 <thirsteh> https://www.google.com/search?q=vincent+hackage+crypto&oq=vincent+hackage+crypto&aqs=chrome..69i57.1571j0&sourceid=chrome&ie=UTF-8#q=vincent+hanquez+hackage+crypto
00:36:20 <thirsteh> yeah, he wrote like 80% of the crypto code on there
00:36:30 <carter> yup
00:37:20 <thirsteh> a lot of his stuff are just c bindings to e.g. openssl too, which is great if you don't trust something-not-so-widely-used (and usually better performance)
00:37:36 <thirsteh> not so great for portability, but haven't had big problems yet
00:41:12 <carter> thirsteh: hehe, reminds me of a feature request for ghc Ghoul_  made
00:41:25 <carter> for the aes instructions to be exposed as primops :)
00:41:47 <carter> i think my answer was "no, ghc should not be expected to provided correct crypto"
00:41:50 <thirsteh> ah interesting. aesni and rdrand could be interesting I suppose
00:41:53 <carter> true
00:41:58 <carter> but shouldn't be baked in
00:42:03 <Ghoul_> vincents stuff is excellent
00:42:07 <thirsteh> yeah primops is a little hardcore
00:42:16 <Ghoul_> I emailed him a feature request like yesterday and he added it in 2 hours
00:42:17 <carter> thirsteh: i have some ideas for enabling inline asm
00:42:27 <carter> its clear is also a labor of love
00:42:48 <Ghoul_> However, what on earth is one to do when we actually want to use the crypto stuff for practical things
00:43:08 <carter> Ghoul_: either use a standard protocol
00:43:09 <Ghoul_> like let's say I want to generate a 1024-bit RSA key, keep it in ASN1 format in a bytestring, and then use it through AES CBC128
00:43:14 <thirsteh> aesni will help you make a mean (cs)prng
00:43:22 <Ghoul_> that's pulling in like 4 different packages!
00:43:24 <carter> Ghoul_: to do what?
00:43:28 <carter> Ghoul_: yes
00:43:29 <carter> thats ok
00:43:29 <thirsteh> much better distribution than mwc
00:43:35 <carter> thirsteh: oooo
00:43:36 <Ghoul_> they all use different interfaces and stuff
00:43:47 <carter> well, you can write connectors
00:43:48 <Ghoul_> some use bytestrings, some use Integers as intermediate storage, some have funny types
00:44:03 <Ghoul_> some are optimized and some state they aren't.
00:44:04 <carter> and give the authors feedback
00:44:08 <carter> yes
00:44:14 <carter> and thats ok
00:44:17 <carter> not perfect
00:44:18 <carter> but ok
00:44:30 <thirsteh> Ghoul_: to be honest, I try to just use NaCl unless I absolutely can't avoid it nowadays
00:44:46 <thirsteh> there is a haskell implementation but haven't used it much: http://hackage.haskell.org/package/saltine-0.0.0.2
00:44:47 <Ghoul_> mhm, the fact they are there is better than nothing, but it feels a bit derpy for what looks like a really simple thing in something like C#
00:45:06 <carter> Ghoul_: C# is written by MSft
00:45:10 <carter> and had a HUGE commitee
00:45:12 <Ghoul_> where you just import a certain certificate kind, generate it, and call a single uniformly defined interface method
00:45:13 <carter> for having epic libs
00:45:20 <Ghoul_> So let's work towards it :P
00:45:34 <carter> Ghoul_: give me msft sized  monies then  lets talk
00:45:49 <Ghoul_> thirsteh: thanks
00:45:58 <carter> thirsteh: doesn't thoughtpolice  have another variant of nacl?
00:45:59 <thirsteh> Ghoul_: I hate that too, but I guess it's inevitable when you give people too many options
00:46:24 <carter> thoughtpolice: ://github.com/thoughtpolice/salt
00:46:29 <thirsteh> oh yeah, that's the one I was thinking of
00:46:31 <carter> https://github.com/thoughtpolice/salt
00:46:37 <thirsteh> not the one I linked, sorry. Misgoogled
00:46:54 <carter> i'd trust any libs written by thoughtpolice
00:46:59 <carter> esp since he's doing core ghc work now
00:47:13 <carter> ifi don't mostly assume he does good work, we're hosed :)
00:47:35 <thirsteh> yeah, I was using that. Remember thinking "uh oh", seeing "Well-Typed" and thinking "it's probably okay then"  :)
00:48:12 <carter> thirsteh: nope, he only just joined them like, last month
00:48:18 <carter> h'es been doing security work for years though
00:48:59 <thirsteh> openssl is a doubleedged sword. when it fails, it fails hard. crypto in a language like haskell and in a very specialized lib can be more trustworthy even if it's not as ubiquitous
00:49:17 <Ghoul_> wow its really hard to find salt on hackage
00:49:21 <carter> thirsteh: also it uses nacl
00:49:27 <carter> Ghoul_: use beta.hackage
00:49:29 <thirsteh> salt is nacl
00:49:39 <thirsteh> djb wants you to pronounce it salt, too. Pretty annoying
00:49:40 <carter> thirsteh: yup
00:50:06 <Fuuzetsu> hvr: hoogle backend is quite lacking and there's a bunch of stuff to fix but I wouldn't hold my breath
00:50:06 <thirsteh> but djb knows what he's doing
00:50:30 <carter> Fuuzetsu:?
00:50:33 <Ghoul_> I still cant find it
00:50:39 <Ghoul_> oh, its called "nacl"
00:50:41 <Ghoul_> ?
00:50:49 <thirsteh> carter: might've been some other project then... but that is the website I remember
00:50:51 <carter> Ghoul_: https://github.com/thoughtpolice/salt
00:50:54 <Ghoul_> github says `cabal update && cabal install salt`
00:50:58 <Ghoul_> I wanna find it on hackage
00:51:03 <carter> Ghoul_: why?
00:51:06 <thirsteh> https://github.com/thoughtpolice/salt/blob/master/salt.cabal
00:51:11 <thirsteh> salt 0.0.0.0
00:51:16 <Ghoul_> because its nice to view things on hackage
00:51:19 <thirsteh> might not be uploaded
00:51:22 <carter> yeah
00:51:26 <carter> i'm off
00:51:31 <carter> Ghoul_: you mean haddocks
00:51:35 <carter> use a cabal sandbox :)
00:51:38 <carter> night all
00:51:42 <Ghoul_> night
00:51:46 <thirsteh> nn
00:53:11 <Ghoul_> *SIGH*
00:53:13 <haasn> http://hub.darcs.net/nand/csharp/browse/PureIO/PureIO.cs#66 :)
00:53:18 <Ghoul_> random stuff internally based on /dev/urandom
00:53:22 <Ghoul_> thanks for thinking about windows.
00:54:13 <Ghoul_> oh god it looks like haskell
00:55:05 <thirsteh> I want to believe...
00:55:36 <thirsteh> ah, it's using LINQ, gotcha. :)
00:55:38 <arkeet> how's performance?
00:55:48 <haasn> arkeet: who knows? :)
00:56:01 <haasn> Probably horrible since the IO stuff isn't CPS'd
00:56:20 <haasn> It's a free monad so every time you chain a bind the result will go through the entire tree
00:57:19 <Ghoul_> salt isn't really what I need :(
00:59:03 <shachaf> haasn: If it's a free monad how come it's so expensive? Explain that.
01:00:28 <arkeet> shachaf: freedom has a price.
01:00:52 <thirsteh> MURICA...?
01:01:43 <Fuuzetsu> carter: it was just Re: issue tracker report
01:02:02 <thirsteh> The person who first described free monads is obviously American
01:11:55 <mr-> thirsteh: how come?
01:15:23 <thirsteh> mr-: It was a bad joke. Americans are freer than everyone else... free monads... :)
01:19:11 <yesthisisuser> Is "undefined" exported by Prelude a nullary function or what is the correct terminology?
01:19:35 <haasn> it's a value
01:19:46 <haasn> there's no such thing as a ‘nullary function’ (at least not in Haskell)
01:19:53 <haasn> every function is 1-ary
01:20:17 <thirsteh> i.e. a function
01:21:51 <yesthisisuser> i think the terminology is a bit unclear.. for example if a search on Hoogle
01:21:53 <arkeet> functions are values, not the other way around.
01:21:58 <yesthisisuser> "allows you to search many standard Haskell libraries by either function name, or by approximate type signature. "
01:22:03 <arkeet> good point.
01:22:19 <arkeet> someone should remove the word "function" from that sentence.
01:22:29 <haasn> yes
01:22:43 <haasn> you can search for type and module names too, after all
01:22:46 <haasn> (and package!)
01:22:48 <yesthisisuser> but name of what then?
01:22:55 <arkeet> value, or type, or module.
01:22:56 <arkeet> or package.
01:23:06 <yesthisisuser> is "undefined" simply a value exported by Prelude
01:23:09 <arkeet> yes
01:23:19 <arkeet> http://www.haskell.org/hoogle/?hoogle=undefined
01:23:35 <arkeet> A special case of error. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which undefined appears.
01:23:38 <arkeet> this seems to never happen in practice.
01:24:11 <yesthisisuser> Standard types, classes and related functions
01:24:27 <yesthisisuser> the documentation says types, classes and functions
01:24:33 <yesthisisuser> it doesn't say "values"
01:25:12 <yesthisisuser> maybe i am just pedantic here but
01:25:35 <mauke> "values" isn't right either
01:26:00 <mauke> but the Prelude does export functions so it's not wrong
01:26:19 <Maxdamantus> The direct heading is "miscellaneous functions"
01:26:30 <Maxdamantus> It could just call them "definitions" or something.
01:27:18 * Maxdamantus wonders how seq is defined.
01:27:33 <Maxdamantus> //doc/html/src/GHC-Prim.html was not found on this server.The requested URL /packages/archive/
01:27:35 <arkeet> I thought seq was magic.
01:27:37 <Maxdamantus> O_o odd
01:27:44 <shachaf> seq is magic.
01:27:48 <arkeet> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html
01:27:54 <Maxdamantus> It even has an unexpanded URL.
01:27:56 <shachaf> seq !x y = y -- naturally!
01:27:57 <arkeet> seq is magic.
01:28:08 <shachaf> Not to be confused with seq !x = id
01:28:11 <Maxdamantus> archive/%01/%02/doc/..
01:28:41 <haasn> either ‘seq’, strict data types or strict functions have to be magic
01:29:05 <shachaf> Or something else.
01:29:11 <shachaf> But at any rate magic has to exist.
01:29:26 <arkeet> @src seq
01:29:26 <lambdabot> Source not found. I am sorry.
01:29:28 <arkeet> seq :: a -> b -> b
01:29:28 <arkeet> seq = let x = x in x
01:29:32 <arkeet> magic.
01:29:49 <shachaf> Hmm, you could have force :: a -> () as a primitive, and then pattern-match on the ().
01:30:21 <arkeet> that seems like a waste of a ()
01:30:52 <shachaf> Well, no reason for it to actually exist at runtime.
01:48:49 <monoidal>  I personally prefer force as a primitive to seq.
01:50:32 <johnw> :t force
01:50:33 <lambdabot> Not in scope: `force'
01:50:49 <johnw> doesn't force use DeepSeq?
01:51:16 <johnw> if so, you prefer a recursive application of seq as a primitive to seq?
01:51:21 <monoidal> DeepSeq's force is different from force :: a -> ()
01:51:26 <johnw> ah
01:51:38 <johnw> i didn't realize shachaf was suggesting a function to write
01:51:56 <arkeet> :t seq ?? ()
01:51:57 <lambdabot> a -> ()
01:52:43 <arkeet> :t seq ?? id
01:52:44 <lambdabot> a -> a1 -> a1
01:52:47 <arkeet> :t seq ?? id ?? id
01:52:48 <lambdabot> a -> a1 -> a1
01:52:51 <arkeet> :t seq ?? id ?? id ?? id ?? id ?? id ?? id ?? id ?? id
01:52:52 <johnw> > seq undefined ()
01:52:52 <lambdabot> a -> a1 -> a1
01:52:53 <lambdabot>   *Exception: Prelude.undefined
01:53:33 <johnw> i'd probably call it seq_, just to avoid confusion with DeepSeq's force
01:54:50 <arkeet> @let force x = x `seq` ()
01:54:51 <lambdabot>  Defined.
01:56:29 <arkeet> :t \a b -> force a & \() -> b
01:56:30 <Fuuzetsu> :t (??)
01:56:30 <lambdabot> t -> b -> b
01:56:31 <lambdabot> Functor f => f (a -> b) -> a -> f b
01:56:36 <arkeet> (??) = flip
01:56:57 <arkeet> monoidal: seq seems more useful in practice.
01:56:57 <Fuuzetsu> huh, :t doesn't look like flip
01:56:58 <Fuuzetsu> :t flip
01:56:59 <lambdabot> (a -> b -> c) -> b -> a -> c
01:57:09 <arkeet> it's a generalization of flip.
01:57:23 <johnw> imagine f is (->) r, and the types will match
01:57:37 <monoidal> arkeet: agreed. but if Seq was a class, it would be easier to define things in terms of force
01:57:40 <arkeet> :t (??) `asAppliedTo` (undefined :: r -> a -> b)
01:57:40 <lambdabot> (r -> a -> b) -> a -> r -> b
01:57:50 <monoidal> arkeet: bit like >>= is more often used than join, even though the second is more "primitive"
01:57:56 <arkeet> monochrom: perhaps
01:58:10 <Fuuzetsu> cool
01:58:18 <Fuuzetsu> @src (??)
01:58:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:58:27 <Fuuzetsu> is it in lens
01:58:30 <arkeet> yes
01:58:41 <edwardk> yep
01:59:58 <ktimothy> Hi, haskellers.
02:00:57 <Fuuzetsu> What's Haskell?
02:02:16 <haasn> Fuuzetsu: Depends, how much do you think is left of him?
02:02:31 <Fuuzetsu> haasn: …
02:03:18 <Fuuzetsu> edwardk: Looking at your docs, you don't need to put a blank line between examples. ‘>>> foo\nbar\n>>> baz\nqux’ is fine
02:03:27 <mauke> all curry
02:03:47 <edwardk> the line is more for me =)
02:04:01 <Fuuzetsu> Well, it makes for a slightly different result so if that's what you want!
02:04:24 <edwardk> yeah i know that haddock will group them tighter in the resulting haddocks if i don't
02:04:36 <edwardk> it just looked too jumbled iirc
02:04:42 <ktimothy> I'm trying to compile "network-2.4.1.1" on my mac but I got error with linker — "ld: library not found for -lgmp" because network.buildinfo not contain "ld-options: -L/usr/local/lib". LDFLAGS=-L/usr/local/lib cabal build nothing change. How to do it right without hand changing buildinfo?
02:04:51 <Fuuzetsu> Cool. I think tools like doctest care about that though if you ever want to use it.
02:05:13 <Fuuzetsu> (On an offnote, I wrote some new docs for Haddock yesterday but still unreleased)
02:06:22 <statusfailed> Anyone got any tips for building haskell code against older libc versions?
02:06:42 <statusfailed> I'm thinking chroot + manually install dependencies
02:11:53 <beaky> hello
02:12:32 <Fuuzetsu> Greetings.
02:13:20 * ksf is sick and tired of the state of records in haskell.
02:13:28 <beaky> what are records?
02:13:36 <Fuuzetsu> record syntax
02:13:37 <beaky> like ADTs?
02:13:39 <beaky> ah
02:13:45 <Fuuzetsu> ksf: new records are coming
02:13:48 <beaky> why does it suck
02:13:55 <ksf> well, yes. I mean extensible, actually.
02:13:59 <Fuuzetsu> http://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
02:14:02 <beaky> ah like record inheritance?
02:14:11 <Ribas1981> http://Fun4Days.com/sms/sms.php?share=63274
02:14:26 <arkeet> Fuuzetsu: that's coming?
02:14:41 <Fuuzetsu> AFAIK it was done as part of GSOC which ends… in 2 days
02:14:54 <Fuuzetsu> and last I heard it was implemented… I might be making it all up in my mind though
02:14:56 <ksf> there's enough libraries that support it, and with -XDataKinds vinyl manages to have a very nice implementation, but the inferred types and everything still suck.
02:15:05 <monoidal> Fuuzetsu: it's http://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan
02:15:15 <monoidal> Fuuzetsu: and unfortunately won't make GHC 7.8 afaik
02:15:59 <Fuuzetsu> Well, I use HEAD most of the time anyway but still, too bad
02:18:03 <beaky> how does the list monad know to choose all elements of a list
02:18:17 <arkeet> have you seen its definition
02:18:54 <beaky> no but i guess (>>=) is for lists concatMap
02:19:01 <ksf> @src concatMap
02:19:02 <lambdabot> concatMap f = foldr ((++) . f) []
02:19:04 <arkeet> yes
02:19:06 <arkeet> (well, flipped)
02:19:15 <arkeet> @src [] (>>=)
02:19:15 <lambdabot> xs >>= f     = concatMap f xs
02:19:32 <monoidal> > concatMap (\x -> concatMap (\y -> [x+y]) [10,20]) [3,4]
02:19:33 <lambdabot>   [13,23,14,24]
02:19:51 <beaky> an now it makes sence
02:20:06 <hvr> edwardk: I'm adding a few docs to finitieBitSize, is that function supposed to be totally lazy in its argument?
02:20:24 <edwardk> it shouldn't use it at all, yes
02:20:31 <hvr> thx
02:20:44 <arkeet> I really hope they don't take . for record projections.
02:20:47 <arkeet> :(
02:21:00 <edwardk> i'd prefer saying unused to saying 'totally lazy' as i'm not sure quite what that means
02:21:13 <hvr> Fuuzetsu: btw, who's currently in charge of haddock?
02:21:16 <Fuuzetsu> arkeet: there was a bkeshedding thread on the mailing lists few weeks ago about it
02:21:20 <edwardk> hvr: are you going to be at ICFP this week?
02:21:26 <hvr> edwardk: sadly, no
02:21:29 <Fuuzetsu> hvr: Simon Hengel and David Waern are the official maintainers
02:21:34 <arkeet> Fuuzetsu: did anything come of it?
02:21:35 <Fuuzetsu> (solirc)
02:21:53 <Fuuzetsu> I don't remember, let me try to find the thread.
02:22:10 <edwardk> monoidal: yeah gundry's work is punted off to 7.10 at this point
02:22:12 <hvr> Fuuzetsu: I was wondering, if  either, a) haddock's Trac could move to ghc.haskell.org, or b) move to Github
02:22:48 <hvr> Fuuzetsu: as with the current situation, it's git repo is on a different machine from the Trac instance
02:23:25 <Fuuzetsu> hvr: That's not up to me to decide I'm afraid (and I wouldn't want to be the one to migrate all the tickets either)
02:23:30 <Fuuzetsu> arkeet: http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/23759
02:24:17 <hvr> Fuuzetsu: moving to ghc.h.o would then be the least effort :-)
02:24:31 <hvr> Fuuzetsu: I'll take it up w/ simon h and david w then
02:24:45 <Fuuzetsu> k
02:25:22 <hvr> Fuuzetsu: the reason I was looking at --hoogle's output is, that I'm using that for a proof of concept
02:25:31 <hvr> Fuuzetsu: for generating API deltas, such as in https://gist.github.com/hvr/6648575#file-base-4-6-0-1-vs-4-7-0-0-md
02:25:41 <Fuuzetsu> hvr: there are multiple hoogle bugs known, might want to have a look at those
02:25:43 <hvr> Fuuzetsu: but I'm realizing, we really need a new backend for that
02:26:13 <Fuuzetsu> hmm, pretty cool project
02:26:14 <hvr> Fuuzetsu: which is more general than what --hoogle does
02:26:24 <hvr> Fuuzetsu: it's just a 80-line python script :-)
02:26:27 <Fuuzetsu> I don't think Haddock is the tool you should be using for it though, except as proof of concept
02:26:49 <hvr> Fuuzetsu: interesting, dcoutts  argued differently :-)
02:27:08 <Fuuzetsu> What was his reasoning behind _documentation engine_ doing the lifting?
02:28:00 <Fuuzetsu> (not to even mention that Haddock's output can change based on GHC version and Haddock version, on the very same source files)
02:28:30 <hvr> actually, I just got
02:28:31 <hvr> 21:37 < dcoutts> hvr: and indeed haddock is the right tool to produce this interface format, that would then be used by hoogle, haddock, tags, interface checkers, ides etc etc
02:28:37 <hvr> from him
02:29:02 <ktimothy> There is someone who has successfully build ghc head on os x 10.9? I successfully installed ghc-7.6.3  and cabal from homebrew but when I'm trying compile 7.7 from sources I get this http://lpaste.net/93217
02:29:08 <beaky> how do i write unit tests for my haskell methods
02:29:09 <Fuuzetsu> …Haddock interface files are for use by Haddock
02:29:37 <Fuuzetsu> there is a ticket to make it more accessible (don't require Haddock to process it as much) but I still don't think that's what you should be using
02:30:10 <hvr> Fuuzetsu: well, for what I'd like to do, I also need access to normalized haddock comments
02:30:14 <Fuuzetsu> What you probably should be doing is source diving into Haddock and ripping out just the bits dealing with function visibility
02:30:36 <Fuuzetsu> hvr: Normalized? You mean post-parsing?
02:31:26 <hvr> Fuuzetsu: yes, in an abstract way, so that I can render it for an IDE , or analyze it, e.g. for checking if it contains certain patterns
02:31:47 <hvr> (like e.g. if something like "/Since: 1.2.3.4/" occurs in there)
02:31:59 <Fuuzetsu> Well, that's a lot better argument for using Haddock then.
02:32:00 <ksf> ghc can't even parse back the type signatures it infers for vinyl records
02:32:25 <ksf> ...gets stuck in the type level lists syntax, scattering * all over the place.
02:32:59 <ksf> and choking on its own ': , too.
02:33:16 <remdezx> Hi! How can I make a server for inter process comunication that listen on specific address? There is no such oprion in "listen" method. I need to specify "localhost" to make server work even there is no network card in the computer
02:34:03 <hvr> remdezx: http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:bind
02:34:17 <beaky> how do i be a better haskell
02:34:19 <Fuuzetsu> hvr: You probably want a tool for reading Haddock interface files (look at InterfaceFile.hs) into whatever it is you want to do with it. You might want a new Haddock backend for this indeed. If you look at the existing ones (XHtml notably), it should be easy to produce one based on it but in a format you need
02:34:27 <arkeet> beaky: use haskell
02:34:43 <arkeet> write haskell
02:34:45 <arkeet> read haskell
02:34:50 <Fuuzetsu> haskell haskell
02:34:56 <hvr> Fuuzetsu: so the haddock interface files are more reliable?
02:34:58 <beaky> there are tons of js frameworks for webdev like node.js and angularjs, but no haskell that gets evangelized :(
02:35:00 <remdezx> hvr: thank you! ;)
02:35:24 <beaky> why is js more popular than haskell for webdev
02:35:26 <hvr> remdezx: however, by default I'd expect a socket to be bound to 0.0.0.0
02:35:41 <arkeet> hvr: that excludes IPv6 =(
02:35:43 <beaky> (though I've heard of some functional reactive thing for the web)
02:35:49 <beaky> that looks an awful lot like haskell
02:35:52 <ksf> remdezx, in general, use the man pages for the C functions or any UNIX networking guide.
02:35:53 <donri> elm
02:35:56 <beaky> aha
02:35:59 <beaky> yes elm
02:35:59 <Fuuzetsu> hvr: Hoogle backend output is not reliable: for example, you won't be getting any class method docs
02:36:10 <ksf> the API is kinda brain-damaged, but works well in practice.
02:37:08 <remdezx> hvr, ksf, thank you very much! I overlooked bind function ;p
02:37:40 <beaky> why do people use e.g. go over haskell
02:37:48 <beaky> for server-side scripting
02:37:50 <Fuuzetsu> hvr: but yes, interface files _should_ do fine I think… I'm not sure if we save the hidden functions we don't end up showing though. Do you care about those or just visible API changes?
02:37:54 <hvr> edwardk: ...just checking: finiteBitSize is supposed to be total?
02:38:01 <arkeet> beaky: because they don't know better ;)
02:38:07 <hvr> edwardk: as opposed to bitSize
02:38:10 <edwardk> yes
02:38:17 <edwardk> otherwise it would just be bitSize
02:38:37 <edwardk> it is expected to be a constant value for each instance. the argument is just to pick the instance.
02:39:03 <hvr> edwardk: I wonder how hard it would be to encode that in the types
02:39:08 <canndrew> Hey people. Is there a standard operator in haskell with the type Functor f => f (a -> b) -> a -> (f b)
02:39:17 <hvr> edwardk: i.e. that an argument is never forced to WHNF
02:39:18 <arkeet> canndrew: no, but lens provides (??)
02:39:20 <arkeet> :t (??)
02:39:21 <lambdabot> Functor f => f (a -> b) -> a -> f b
02:39:22 <canndrew> or maybe that should be Monad f
02:39:31 <edwardk> it'd be easy, if finiteBitSize :: p a -> Int   -- was used instead of a -> Int
02:40:09 <edwardk> the only 'evil' thing you could do to the arg then would be force it
02:40:37 <edwardk> but a type system for knowing if something can be forced to whnf is trickier. janis voightlander has one
02:40:39 <Lethalman> @src (??)
02:40:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:40:50 <canndrew> arkeet: I just want a clean way to apply a function in a Maybe to an argument that's not in a Maybe
02:40:59 <arkeet> canndrew: (??) is it.
02:41:06 <arkeet> f ?? x = fmap ($ x) f
02:41:06 <edwardk> hvr: http://www.iai.uni-bonn.de/~jv/papers/RefinedTypingToLocalizeTheImpactOfForcedStrictnessOnFreeTheorems.pdf
02:41:21 <edwardk> hvr: but i don't think it is ready for mainstream haskeller consumption yet
02:42:20 <canndrew> arkeet: cool thanks
02:42:24 <Lethalman> :t \x -> fmap ($ x)
02:42:25 <lambdabot> Functor f => a -> f (a -> b) -> f b
02:42:35 <edwardk> canndrew:    f <*> pure a
02:42:55 <Lethalman> ah right now I got it with f <*> pure a :P
02:42:57 <edwardk> canndrew: ($a) <$> f
02:43:13 <Fuuzetsu> edwardk: do you hate spaces?
02:43:15 <Lethalman> oh wasn't right? :S
02:43:22 <Lethalman> :t \f a -> f <*> pur a
02:43:23 <lambdabot>     Not in scope: `pur'
02:43:23 <lambdabot>     Perhaps you meant one of these:
02:43:23 <lambdabot>       `pure' (imported from Control.Applicative),
02:43:25 <Lethalman> :t \f a -> f <*> pure a
02:43:26 <lambdabot> Applicative f => f (a -> b) -> a -> f b
02:43:26 <arkeet> they both work.
02:43:31 <arkeet> but one requires Applicative.
02:43:31 <Lethalman> ok
02:43:39 <Lethalman> f <*> pure a is more clear to me
02:43:41 <edwardk> Fuuzetsu: which ones in particular?
02:43:46 <Fuuzetsu> around operators
02:43:49 <edwardk> Lethalman: thats why i led in with it =)
02:43:56 * arkeet would rather use (??)
02:44:05 <edwardk> Fuuzetsu: i don't hate them, but i find lens code reads better when it is more dense
02:44:19 <edwardk> Fuuzetsu: so we tend to drop the spaces around .'s in lens code in particular
02:44:39 <hvr> edwardk: please check wording: http://lpaste.net/93218
02:44:44 <edwardk> > (1,(2,3))^._2._1
02:44:46 <lambdabot>   2
02:44:50 <edwardk> reads pretty well to me
02:44:56 <edwardk> > (1,(2,3)) ^. _2 . _1
02:44:58 <lambdabot>   2
02:45:01 <hvr> edwardk: thx
02:45:03 <edwardk> feels like it is trying too hard =)
02:45:04 <Fuuzetsu> ($a) wasn't lens code
02:46:23 <hvr> edwardk: ...was the "reads pretty well to me" related to the haddock doc?
02:46:25 <edwardk> Fuuzetsu: oh that. meh. i leave out one space and you overlook the 2 completely unnecessary ones i left in. lets just say spaces are going through a difficult separation.
02:46:36 <edwardk> hvr: hah, no, sorry. reading now
02:47:18 <edwardk> hvr: hrmm
02:47:32 <hvr> edwardk: just annotate what you'd like differently
02:47:48 <edwardk> hvr: one thing worth doing would be noting that finiteBitSize = bitSize and possibly setting that as a default definition
02:48:11 <edwardk> the default definition would get in the way of eventually phasing out bitSize though
02:48:12 <hvr> edwardk: but that would risk it being non-total
02:48:17 <edwardk> no
02:48:31 <edwardk> any _instance_ of FiniteBits should have bitSize defined
02:48:44 <hvr> ah, ok
02:48:48 <edwardk> there are just instances of Bits that are not instances of FiniteBits for which bitSize isnt definable
02:49:00 <edwardk> e.g. Integer
02:49:19 <hvr> edwardk: but we've also bitSizeMaybe, which would lateron become mandatory
02:49:38 <hvr> edwardk: so later we can switch to "fromJust . bitSizeMaybe"
02:49:49 <edwardk> true
02:50:07 <hvr> edwardk: which brings me to the "RFC" posting which nobody seems to care about in libraries@ :-)
02:50:15 <edwardk> then i don't see the harm in picking the default definition
02:51:23 <hvr> edwardk: specifically, http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/20324
02:52:16 <edwardk> there was a lot of resistance to defining things in terms of the 'Maybe' functions by default for these as these are pretty low level primitives and the box would suck
02:52:46 <hvr> but it's just a transitional definition
02:52:49 <edwardk> hence iirc lennart and a few others were against having definitions for stuff default to being in terms of the more general bitSizeMaybe
02:52:58 <hvr> + default
02:53:37 <edwardk> well, if we take the finiteBitSize thing and define that in trms of bitSize, we've propagated it out
02:53:52 <hvr> edwardk: so what is now, do we want convenience at the cost of unboxing, or the other way round? :-)
02:53:54 <edwardk> so now unless ghc sees through the instances we're farting around with a box
02:54:26 <edwardk> we absolutely do not want a performance hit for finiteBitSize is really the take away I had from the initial discussion
02:54:35 <edwardk> so convenience is a secondary concern
02:54:54 <edwardk> there are relatively few producers of these instances, and relatively many consumers who care about every cycle
02:54:55 <hvr> edwardk: but wouldn't that rule out the default-impl you just suggestewd?
02:55:21 <edwardk> the default impl i suggested was that finiteBitSize = bitSize, no?
02:55:27 <hvr> edwardk: exactly
02:55:40 <hvr> edwardk: but we have access to 'bitSize' only for a short lifespan
02:55:51 <hvr> edwardk: what shall happen after bitSize is removed?
02:56:07 <hvr> shall code depending on the default-impl break?
02:56:17 <edwardk> that would seem to indicate we shouldn't put in the default then
02:56:23 <edwardk> but we should leave the law
02:57:17 <hvr> ok, so the law being that if bitSizeMaybe == Just . finiteBitSize  iff FiniteBits is defined for that type?
02:57:48 <edwardk> http://lpaste.net/93218
02:57:59 <edwardk> yeah
02:58:39 <edwardk> i like your statement of it better
02:58:47 <edwardk> http://lpaste.net/93218 updated
02:58:50 <jonkri> How can I split a list into sublists based on an element? a -> [a] -> [[a]]? Example: f ' ' "hello world" = ["hello", "world"]
02:59:08 <hvr> edwardk: I'll take your last edit, before you change your mind again :-)
02:59:17 <fizruk> edwardk: hi! I just came up with this function http://lpaste.net/93222
02:59:28 <edwardk> heh
02:59:44 <fizruk> edwardk: if I haven't made mistakes, you might be interested in it
02:59:53 <edwardk> hvr: it is good to keep the superposition of all possibilities open until we're forced to collapse it to a final state =)
03:00:09 <arkeet> jonkri: in your specific example, you could use the words function
03:00:28 <edwardk> fizruk: sounds right
03:00:51 <fizruk> edwardk: it works for my examples, yet I'm not sure about performance
03:01:10 <hvr> edwardk: and 'measuring' == compiling?
03:01:15 <edwardk> fizruk: it could likely go in as liftLiftF or something as a default definition for liftF
03:01:37 <hvr> edwardk: i.e. all is possible, until the compiler tells otherwise? =)
03:02:02 <edwardk> hvr: why do you think i go so long between coherent builds ;)
03:02:26 <fizruk> edwardk: am I right that all current MonadFree instances for transformers may be replaced with wrap = wrapT ?
03:02:45 <edwardk> fizruk: could, but not ncessarily should
03:02:54 <edwardk> that is a lot less efficient i think
03:03:39 <edwardk> i wouldn't switch to it for them, but i wouldn't object to adding it as a viable definition, or even as a viable default definition for the class member
03:03:56 * hvr just noticed there should be alot more FiniteBits instances
03:03:59 <fizruk> edwardk: couldn't wrapT be implemented in an efficient way?
03:04:11 <hvr> specifically for all {Int,Word}{8,16,32,64}
03:04:21 <jonkri> arkeet: Thanks. I have a list, but the delimiter is not a space. I guess I'll use split.
03:04:25 <edwardk> the problem is the cost of the join is more expensive than what most of the instances pay
03:04:30 <edwardk> hvr: yep
03:04:32 <arkeet> jonkri: that's why it exists :)
03:04:58 <jonkri> arkeet: I was just surprised that there was no standard function for this. Thought I might have missed something.
03:05:12 <hvr> edwardk: nevermind, they do exist
03:05:17 <arkeet> does "in the haskell platform" count as standard?
03:06:00 <jonkri> arkeet: I meant a base function.
03:06:04 <arkeet> :)
03:06:11 <fizruk> edwardk: ok, I should think a bit more about it.
03:06:14 <hvr> edwardk: btw, that byte-swap typeclass proposal   didn't go anywhere, did it?
03:06:16 <jonkri> Thanks. :-)
03:07:13 <edwardk> fizruk: going back and checking your def, one sec.
03:07:19 <edwardk> hvr: not that i can recall
03:07:26 <edwardk> hvr; i think it died on the vine
03:07:45 <hvr> edwardk: maybe for base-4.8 then :-)
03:07:46 <edwardk> fizruk: it is starting to make me feel uncomfortable when it comes to ordering
03:07:56 <edwardk> hvr: well, i don't think it belongs in Bits
03:08:08 <hvr> edwardk: /me neither, I suggested a Bytes class
03:08:24 <hvr> edwardk: which got a little bit of support
03:08:57 <edwardk> let's resume the discussion once we have the committee in full swing and are making much more active changes in 7.9
03:09:19 <edwardk> but it is also the kinda thing that is bing pretty adequately served by libraries now
03:09:27 <edwardk> between bytes and typesafe-endian, etc.
03:09:32 <thirsteh> what version of ghc was/is Mio included in? 7.8?
03:09:33 <hvr> edwardk: I'm looking forward to the big changes in base for 7.9+
03:09:42 <thirsteh> hvr: is there a list?
03:09:43 <hvr> thirsteh: yeah, 7.7+
03:09:43 <edwardk> likewise
03:09:46 <thirsteh> thanks
03:09:56 <fizruk> edwardk: you mean join . lift ?
03:10:11 <arkeet> :t join . lift
03:10:12 <lambdabot> (Monad (t m), Monad m, MonadTrans t) => m (t m a) -> t m a
03:10:29 <hvr> thirsteh: dunno, but edward mentioned a bit in a recent videoblog
03:10:39 <edwardk> fizruk: yeah not sure what is being joined has the right semantics there
03:10:42 <thirsteh> ok will take a look
03:10:52 <edwardk> the join moves 'when' things happens around quite a bit
03:10:59 <hvr> thirsteh: http://www.reddit.com/r/haskell/comments/1l45c3/the_haskell_cast_episode_1_edward_kmett_on_lenses/
03:11:11 <thirsteh> cheers
03:12:06 <hvr> edwardk: btw, was that a samsung smartphone headset you were using?
03:12:10 <edwardk> that expands out to join . lift . wrap . fmap return
03:12:51 <edwardk> hvr: ah no, just a pair of earpods
03:12:55 <fizruk> edwardk: didn't get the idea. join makes t m (t m a) -> t m a, if I'm correct
03:13:36 <edwardk> fizruk: 'wrap' is wrapping only a return, not the original monadic effect there
03:13:43 <edwardk> you've shuffled it outside, and then done it later
03:14:44 <thirsteh> would it be "safe" to upgrade to ghc-7.7 now? Lots of packages break, etc? I'm on 7.6.2 now
03:15:04 <edwardk> fizruk: i'm not saying its broken necessarily, just that i'm not sure its correct either =)
03:15:15 <fizruk> edwardk
03:15:21 <thirsteh> could really use those improvements for 8+ cores
03:15:54 <hvr> thirsteh: tbh, ghc-7.7 is still a bit unstable
03:16:28 <thirsteh> ok, "no" then. this is for production, heh
03:16:56 <hvr> thirsteh: but you're encouraged to try it as a preview and for bug-hunting :-)
03:17:19 <thirsteh> I might try it out
03:17:35 <fizruk> edwardk: m... wrap is wrapping a return and join is concatenating it back, is't it?
03:18:43 <edwardk> join is concatenating back the result of wrap, which isn't necessarily quite the same 'm' you put in. so you need some universal property for wrap that we don't state in the laws
03:19:35 <edwardk> e.g. naturality
03:21:06 <hvr> edwardk: is isLeft/isRight the only thing that passed the Data.Either proposal(s)?
03:21:14 <edwardk> if we have something like:     wrap . fmap f = f . wrap   then join . lift . wrap . fmap return = join . lift . return . wrap  = join . return . lift . wrap = lift . wrap  -- or something like that
03:21:31 <edwardk> hvr: that sounds plausible to me, but i don't have the thread handy
03:22:14 <edwardk> fizruk: that condition is probably too strong though
03:22:40 <edwardk> perhaps it holds for any f where f is a monad homomorphism though
03:22:41 <hvr> edwardk: http://comments.gmane.org/gmane.comp.lang.haskell.libraries/19976
03:22:43 <edwardk> which may be enough
03:23:11 * hvr doesn't see a clear summary/conclusion in that thread
03:23:25 <hvr> but isLeft/isRight was added to base by Simon H
03:23:33 <edwardk> yeah there is a whole lot of wankery in there
03:24:00 <edwardk> isLeft/isRight seem pretty non-controversial (even if they are made redundant by lens) ;)
03:24:17 <hvr> edwardk: just use your influence to fold lenses into base =)
03:24:20 <edwardk> the rest seem to lack any sort of consensus
03:24:40 * hvr is just going over the changes in base for changelog and since-annotations
03:25:30 <edwardk> Working on it. I have SPJ giving a talk on them at the Haskell Exchange. Gundry's changes will incorporate more lens logic into record mutation. Next year we may tackle 'over exposed' multi-hop record updates...
03:25:54 <edwardk> The transformation to lenskell will be a slow but inexorable process ;)
03:26:49 <edwardk> besides base already has everything you need to define lenses in it
03:27:10 <hvr> I was surprised a bit to see SPJ being the one talking about lenses
03:27:41 <edwardk> > let _2 f (a,b) = (,) a <$> f b; let s ^. l = getConst (l Const s) in (1,2)^._2
03:27:43 <lambdabot>   <hint>:1:79:
03:27:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
03:27:59 <mauke> s/; let/;/
03:28:04 <edwardk> > let _2 f (a,b) = (,) a <$> f b; s ^. l = getConst (l Const s) in (1,2)^._2
03:28:05 <lambdabot>   2
03:28:17 <fizruk> edwardk: i don't think wrap . fmap f = f . wrap is good, yet wrap . fmap return = return . wrap makes makes more sense to me
03:28:47 <edwardk> fizruk: not sure i'm convinced it holds yet, but it seems plausible
03:29:19 <edwardk> in fact i'd highly doubt it holds
03:32:43 <beaky> how do i name my variables?
03:33:02 <beaky> should they be abreviated or verbose? camelCase or snake_case
03:33:16 <beaky> (though PascalCase is enforced for types)
03:33:38 <edwardk> beaky: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
03:34:03 <beaky> ah thanks
03:34:16 <beaky> aww I am used to two-space indents (with 1 space for where clause) :D
03:34:24 <hvr> beaky: only upper-case is enforced for types
03:34:33 <hvr> beaky: or rather, capitalized
03:34:47 <beaky> ah
03:35:48 <edwardk> beaky: likewise indent wise
03:36:30 <edwardk> the only additional convention i've taken to is _THIS_IS_A_CONSTANT
03:37:05 <edwardk> which looks better to me than tHIS_IS_A_CONSTANT
03:37:48 <beaky> ah neat underscore. always wanted to name my constant values in all caps snake_case as I used to in other langs
03:43:01 <ReinH> edwardk: irt lenskell, resistance is useless.
03:46:02 <edwardk> ReinH: re that article, turns out i read it before, doh
03:57:28 * hackagebot lens-aeson 0.1.1 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-0.1.1 (EdwardKmett)
04:00:13 <simon> @pl \op f g x = (f x) `op` (g x)
04:00:13 <lambdabot> (line 1, column 11):
04:00:13 <lambdabot> unexpected "="
04:00:13 <lambdabot> expecting pattern or "->"
04:00:26 <simon> @pl \op f g x = op (f x) (g x)
04:00:48 <lambdabot> (line 1, column 11):
04:00:48 <lambdabot> unexpected "="
04:00:48 <lambdabot> expecting pattern or "->"
04:00:51 <arkeet> @pl \op f g x -> op (f x) (g x)
04:00:52 <lambdabot> liftM2
04:01:04 <arkeet> well, liftA2
04:01:07 <simon> whoops :)
04:01:09 <simon> thanks.
04:04:44 <donri> edwardk: you use two spaces for indents pretty consistently IME
04:04:54 <donri> tibbe suggests four
04:05:17 <notdan> four for do-blocks, two for where clauses
04:05:32 <notdan> according to tibbe's style guide
04:05:35 <donri> i tend to think of them as "half indented" ;)
04:05:39 <notdan> heh
04:05:58 <donri> i actually misinterpreted the guide first with the result that vim2hs doesn't follow it fully
04:06:18 <donri> it assumes 2 spaces for indent and double indent for function body
04:07:56 <Ghoul_> what's a fast random number generator?
04:08:31 <Ghoul_> nvm, I'm restrained to the crypto typeclass which only has one
04:10:12 <donri> Ghoul_: edwardk's concurrent-supply can be used purely once initialized
04:12:25 <Ghoul_> thanks it might help me elsewhere
04:13:48 <Eduard_Munteanu> Am I seeing things, or can the indexed store comonad (data Store i o a = Store (i -> a) o) also be a monad if you squint? Consider  bindStore :: Store i j a -> (j -> Store j k a) -> Store i k a
04:15:28 <Eduard_Munteanu> If you let Store' t = Store i t a, it seems it makes a normal, non-indexed monad.
04:15:55 <monoidal> @djinn (i -> a, j) -> (j -> (j -> a, k)) -> (i -> a, k)
04:15:55 <lambdabot> f (a, b) c =
04:15:55 <lambdabot>     case c b of
04:15:56 <lambdabot>     (_, d) -> (a, d)
04:16:44 <Eduard_Munteanu> Actually isn't that State?
04:17:39 <Eduard_Munteanu> Erm, maybe not.
04:27:28 * hackagebot rethinkdb 1.8.0.0 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-1.8.0.0 (EtienneLaurin)
04:52:32 <haasn> Eduard_Munteanu: isn't that just (,) (i -> a) ?
04:53:01 <haasn> oh, I'm misreading
04:53:45 <Eduard_Munteanu> Looks like a monad on the index category... bind :: S a i j -> (j -> S b j k) -> S b i k,   Store was I x I -> Monad(C)  and S is C x I -> Monad(I)
04:54:06 <Eduard_Munteanu> (pretend C and I aren't Hask)
04:54:37 <Eduard_Munteanu> Err.
04:54:49 <Eduard_Munteanu> Store :: I x I -> Comonad(C)
04:56:45 <arkeet> Eduard_Munteanu: I'm more interested to see how you write return.
04:58:07 <Eduard_Munteanu> arkeet: return o = Store id o  ?
04:58:16 <arkeet> how does that have the correct type?
04:59:37 <arkeet> if you fix i = a, then you get nothing but Writer (Endo a)
04:59:52 <arkeet> but that seems like a really strange thing to do.
05:00:02 <arkeet> with Store, I mean.
05:00:46 <Eduard_Munteanu> arkeet: lets use S... return :: j -> S i i j  , that seems reasonable
05:00:53 <arkeet> and it would have nothing to do with the Store *comonad*.
05:01:22 <arkeet> ???
05:01:47 <Eduard_Munteanu> arkeet: I know, it's not the same functor
05:02:38 <Eduard_Munteanu> arkeet: return = S id  if we use S.
05:02:45 <arkeet> I have no idea what S is.
05:03:05 <arkeet> data S a b c = S (a -> b) c ?
05:03:50 <Eduard_Munteanu> arkeet: no, newtype S a i j = S (Store i j a)
05:04:15 <arkeet> S id looks like a type error then.
05:04:17 <Eduard_Munteanu> Anyway, I'm a bit lax on types.
05:04:26 <arkeet> too lax, I would say.
05:04:33 <arkeet> when I don't understand what you're doing.
05:05:31 <Eduard_Munteanu> arkeet: ok, return j = S (Store id j)  I think
05:05:43 <arkeet> where Store is
05:05:54 <arkeet> right.
05:06:00 <Eduard_Munteanu> arkeet: data Store i j a = Store (i -> a) j
05:06:03 <arkeet> yes.
05:06:29 <arkeet> so sure, Store a j a is a monad in j. (the Writer (Endo a) monad.)
05:06:35 <arkeet> so what.
05:06:48 <Eduard_Munteanu> Ok, maybe it's trivial on Hask, but is there more to it if the index category is different?
05:07:18 <arkeet> or, Store a j b is a (a->b) indexed monad in j. (because (->) is a category.)
05:07:45 <Eduard_Munteanu> arkeet: I'm actually working with an indexed store comonad on the partial Hask category.
05:07:52 <hvr> Fuuzetsu: btw, I found out why having support from haddock for /Since: .../ would be nice
05:07:55 <arkeet> I don't know what that is.
05:07:56 <Eduard_Munteanu> newtype Partial a b = Partial (a -> Maybe b)
05:08:09 <arkeet> aka Kleisli Maybe.
05:08:20 <Eduard_Munteanu> Yeah.
05:08:42 <arkeet> and then what.
05:10:02 <Eduard_Munteanu> arkeet: not sure, that's what I'm asking, if it's interesting at all :)
05:10:29 <arkeet> it doesn't seem so.
05:10:47 <arkeet> it's still just a product.
05:11:00 <Eduard_Munteanu> arkeet: my initial goal was to see if the indexed store comonad on Partial can make a good API for parsers, then I stumbled onto this
05:11:18 * Eduard_Munteanu is still not done
05:12:22 <Eduard_Munteanu> (Namely extend letting you run a parser and use its output for a different parsing stage)
05:12:42 <arkeet> any category C gives you an indexed monad \i j a -> (C i j, a)   (excuse the notation)
05:13:12 <Hodapp> "excuse the notation"? Only in #haskell :P
05:13:27 <Eduard_Munteanu> arkeet: is that an indexed category?
05:13:35 <arkeet> indexed by i,j yes.
05:13:57 <arkeet> an ordinary monad is indexed by the trivial category.
05:14:26 <arkeet> anyway, what you get is as interesting as Writer (except with a category instead of a monoid).
05:14:33 <arkeet> (regardless of the category)
05:14:40 <Eduard_Munteanu> arkeet: oh, sure, you can trivially make an indexed (co)monad from a normal (co)monad, I guess.
05:15:13 <Eduard_Munteanu> Given the functor is like \_ _ a -> a
05:15:42 <Eduard_Munteanu> Erm, \_ _ a -> F a
05:15:43 <arkeet> @quote indexed.monad
05:15:44 <lambdabot> ky3 says: Indexed monads are just categories in the category of endofunctors, what's the problem?
05:16:57 <Eduard_Munteanu> arkeet: you also get that monad even for the non-indexed store comonad, though
05:17:21 <merijn> Man, I wish Haskell got do sugar for indexed monads, that'd be sweet
05:17:23 <arkeet> what I'm saying is that it has nothing to do wtih comonad.
05:17:43 <aristid> merijn: i hear GHC is open source :P
05:18:10 <arkeet> and you need it to be the indexed store. because one of the indices becomes the parameter for your monad.
05:18:23 <Eduard_Munteanu> arkeet: it doesn't? What if you can't get the index out of a particular comonad?
05:18:29 <merijn> @quote chrisdone yak
05:18:29 <lambdabot> chrisdone says: [on being invited to help with idris development] dude i've already got 20 yaks lined up waiting to be shaved, don't send me a whole truck full
05:18:31 <arkeet> indeed!
05:18:39 <haasn> merijn: if you can type them normally, RebindableSyntax?
05:18:52 <merijn> haasn: oh, good point, that might work
05:18:55 <arkeet> it does.
05:19:06 <arkeet> but then old-fashioned monads won't.
05:19:12 <arkeet> unless we have something like kind classes?
05:19:22 <arkeet> hm, I mean type classes
05:19:25 <haasn> who needs old-fashioned monads when you have ~indexed~ monads? :)
05:19:27 <merijn> old-fashioned monads are overrated!
05:19:32 <arkeet> :)
05:19:33 <Eduard_Munteanu> Well, you can make an indexed monad from any normal monad using a newtype and instances.
05:19:42 <arkeet> yes, but then you need a newtype.
05:19:43 <Eduard_Munteanu> Though the indices may be ambiguous.
05:19:50 <arkeet> you can index it by ()
05:19:55 <arkeet> (the kind () )
05:20:02 <Eduard_Munteanu> Oh.
05:20:08 <haasn> overlapping instances?
05:20:37 <Eduard_Munteanu> Hm, can you make instances for closed type families?
05:20:47 <arkeet> I thought you couldn't, and that was the point?
05:21:42 <merijn> You can't for open type families, because that could result in brokenness. For closed and terminating type families it should be (theoretically) possible, but I don't think GHC lets you
05:21:58 <merijn> I don't think GHC can determine whether a closed type family terminates, for one
05:22:18 <arkeet> I'm confused.
05:22:26 <arkeet> the solution to being confused is to go to bed.
05:22:26 <Eduard_Munteanu> merijn: it has to, if you ever want to use such a type, I think
05:22:30 <haasn> merijn: in the absence of UndecidableInstances shouldn't all?
05:22:50 <Eduard_Munteanu> arkeet: thanks for listening to my ramblings :)
05:23:32 <merijn> Eduard_Munteanu: Why? GHC allows infinite types, doesn't it?
05:23:33 <Eduard_Munteanu> TBH I'm not against possibly non-terminating typechecking.
05:24:02 <Eduard_Munteanu> merijn: mm, I don't think so, besides said infinite types should be productive anyway
05:24:15 <chrisdone> z
05:24:23 <Eduard_Munteanu> So something like  type Foo a = Foo a  would never do any good.
05:28:57 <merijn> Man, I wish I could write functional programming prose as well as pigworker...
05:30:56 <Fuuzetsu> hvr: Let's hear it.
05:34:47 <beaky> what is lenskell
05:35:02 <Fuuzetsu> the future
05:35:21 <beaky> so lens will be part of base?
05:35:30 <merijn> oh god
05:35:35 <merijn> Poor SPJ :p
05:35:55 <Fuuzetsu> ‘part of’… I'm sure some people would have that part be 100%
05:36:35 <beaky> i want to build a webapp with haskel
05:36:49 <beaky> maybe I can host it in heroku?
05:37:43 <beaky> http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
05:39:52 <merijn> Anyone feel fairly at home with Cabal internals? I don't really understand the semantics of some of the flags datatypes
05:44:23 <xenocons_> offtopic but must share: https://plus.google.com/116951145888391044655/posts/FTgUfxudaT6
05:46:18 <merijn> Alternatively, does anyone know of a ctags generator for Haskell?
05:46:30 <donri> merijn: hasktags?
05:47:48 <paolino> hello, is there any class for values that have partition and null and filter ?
05:49:08 <merijn> donri: I'll take a look, thanks
05:49:54 <beaky> how do people define fmap using foldr
05:50:20 <hpc> @src map
05:50:20 <lambdabot> map _ []     = []
05:50:20 <lambdabot> map f (x:xs) = f x : map f xs
05:50:21 <beaky> fmap f = foldr ((:) . f) []
05:50:43 <hpc> @src foldr
05:50:43 <lambdabot> foldr f z []     = z
05:50:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:50:44 <Ghoul_> @src fmap
05:50:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:50:53 <beaky> so it replace the normal ctor with f?
05:50:57 <beaky> and reconstructs the list?
05:51:03 <paolino> that's only for []
05:51:05 <beaky> oh
05:51:22 <beaky> maybe in general if a type has foldr, you can define fmap
05:51:53 <Fuuzetsu> you mean all Foldable are also Functors?
05:51:54 <donri> beaky: no you need pointed too, and it apparently has law problems
05:51:54 <paolino> you need the constructor (:)
05:52:26 <donri> only Traversable is always also Functor
05:52:26 <beaky> so not all foldables are functor?
05:52:28 <beaky> oh
05:52:45 <beaky> are all foldables monoids too?
05:52:52 <beaky> (and monads)
05:52:53 <Fuuzetsu> no
05:52:57 <beaky> :(
05:53:17 <paolino> monoid is * kind
05:53:22 <Fuuzetsu> that … yeah
05:55:07 <beaky> @k []
05:55:07 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind v @ ? .
05:55:16 <beaky> @kind []
05:55:17 <lambdabot> * -> *
06:00:42 <hvr> Fuuzetsu: basically, the ability to inherit the "since-version" as property from enclosing symbols
06:01:28 <hvr> Fuuzetsu: e.g. if you declare '/Since: .../' in the module haddock comment, it would apply to all symbols defined in that module
06:02:34 <hvr> Fuuzetsu: moreover, Haddock could decide when to actually render that information; as in some cases it's rather obvious visually
06:03:51 <Fuuzetsu> I'm not too convinced about the benefit vs implementation chore of this…
06:04:11 <Fuuzetsu> Is there actual demand or is it just ‘it would be cool to have it and if it had all these bells and whistles’?
06:04:16 <hvr> Fuuzetsu: the real problems start when inter-package re-exports occur
06:04:57 <hvr> Fuuzetsu: then the version in the haddock comment doesn't necessarily make sense in the package re-exporting that comment
06:05:52 <Fuuzetsu> Yes, it's indeed non-trivial to implement if we want to do some kind of inheritance/version resolution which is why I'm asking whether it's worth the hassle.
06:06:10 <hvr> whether it's worth I don't know :-)
06:06:22 <hvr> we can just wait till the pain gets big enough
06:06:23 <Fuuzetsu> Personally I think it's just much simpler to stick with what you're doing now, just add the line as a convention.
06:07:40 <Fuuzetsu> Of course if you feel that it'd be a good addition and worth implementation + maintenance burden, you're free to create a ticket.
06:19:46 <paolino> whenever I switch to a Map + Set solution of a naive all list one I get all this Map.f Set.f f carosello particularly f being partition or null or filter
06:23:49 <paolino> so the all point of having those in a class is to avoid some namespacing
06:25:38 <paolino> at least we have fmap in place of Map.map and Set.map
06:34:31 <beaky> what is agda? is it like haskell?
06:35:00 <oleo> no
06:35:07 <oleo> it's like my overengineered ma!
06:38:33 <beaky> ah
06:40:06 <exFalso> Hi, if i'm defining a commutative binary function, is there a nice way of defining the mirror cases without repeating all cases (and recursing)?
06:42:20 <mangaba_1eitosa> exFalso: f x y = f y x ?
06:43:18 <exFalso> mangaba_1eitosa: well that's what i'm trying to avoid, thought maybe there is a weird way of pattern matching that allows something like this
06:43:39 <exFalso> hmm i'll just write out all cases
06:48:24 <mangaba_1eitosa> exFalso: if you have cases e. g. (f "x1" "y1" =), (f "x1", "y2 =)", (f "x2" "y1" =), (f "x2", "y2" =), then just adding one more line 'f x y = y x' looks like an adequate decision
06:48:39 <paolino> f x y = f y x as last pattern matching ?
06:48:54 <mangaba_1eitosa> exFalso: of course, your previous definitions must be exhaustive so that f x y = f y x  not cause infinite loop
06:48:59 <mangaba_1eitosa> paolino: yes
06:49:06 <paolino> yep
06:49:18 <paolino> <<loop>>
06:49:30 <mangaba_1eitosa> = (infinite recursion)
06:57:27 <beaky> :t join
06:57:28 <lambdabot> Monad m => m (m a) -> m a
06:57:35 <beaky> how does join work for IO monad
06:58:00 <kier> Am I right in thinking that 'exp' and 'log' are specialisations of '(**)' and 'logBase' to a base of e?
07:03:02 <dwcook> @src join
07:03:02 <lambdabot> join x =  x >>= id
07:03:06 <geekosaur> @src logBase
07:03:06 <lambdabot> Source not found. Where did you learn to type?
07:03:09 <geekosaur> bah
07:03:10 <dwcook> beaky, does that help?
07:03:28 <geekosaur> logBase is implemented with ln and division
07:03:36 <geekosaur> because ln etc. are typically in hardware
07:04:44 <dwcook> Another way to write join: join m = do { x <- m; x }
07:05:01 <beaky> ah thanks
07:05:50 <beaky> wow scotty is awesome
07:05:57 <beaky> so easy to make a website in haskell
07:06:29 <geekosaur> kier, from the Prelude: logBase x y         =  log y / log x (default implementation)
07:06:32 <kier> ah, I wasn't worried about the implementations of the functions, just checking what they did (the Floating class is almost completely undocumented)
07:07:30 <geekosaur> yeh, it's almost all primops
07:07:36 <geekosaur> hard to do otherwise
07:09:46 <magneticduck> Ima having problems with a library called hsndfile which is a wrapper to the C library libsndfile; yesterday I got some example code using hsndfile and properly rendered a square wave at 1000 Hz, but now that I added the code to my library, got it to install and called it up with GHCi, it doesn't work anymore
07:09:58 <magneticduck> fails with the error that it can't find the shared library file
07:10:11 <magneticduck> oading package hsndfile-0.7.1 ... can't load .so/.DLL for: libsndfile.so (libsndfile.so: cannot open shared object file: No such file or directory)
07:10:46 <magneticduck> (that's what it gives me after I enter a command that uses an IO function from hsndfile that should call a routine from the library)
07:10:58 <magneticduck> any ideas?
07:11:26 <bennofs> magneticduck: did you do updates since it worked last time?
07:11:33 <magneticduck> I'm going to see if I can isolate the code and try to execute it from outside the library
07:11:40 <magneticduck> no, I did no updates
07:12:01 <Rembane> magneticduck: Have you always used GHCi to run the code?
07:12:30 <magneticduck> no
07:12:46 <magneticduck> the first time I did it, I just ran the code with runhaskell
07:12:57 <magneticduck> I didn't ever call any functions from GHCi
07:14:08 <magneticduck> alright, I isolated the code, made a test main, and ran it with ghc
07:14:11 <magneticduck> same error
07:14:18 <magneticduck> I'm going to try the original sample code I had that worked so well yesterday
07:15:39 <magneticduck> the same error!
07:16:48 <magneticduck> I'm reinstalling the library
07:17:44 <beaky> how do monads let you invent DSLs for anything
07:18:00 <beaky> e.g a parser dsl, html dsl, a dsl for IO,
07:18:41 <magneticduck> well monads are just handy ways to talk about doing.. things =P
07:19:23 <magneticduck> I mean, you could do all that without monads, but it would be more tedious, and you might end up using something suspiciously monad-like
07:19:41 <beaky> so monads do things behind the scenes as you chain them?
07:19:48 <beaky> that is why they make dsls so tidy?
07:20:09 <magneticduck> monads are about making nice chains of computation, is one way to look at it
07:21:21 <magneticduck> it's a pretty universal concept, monads just package it nicely
07:21:33 <magneticduck> I am by no means an authority on this subject btw
07:22:33 <magneticduck> basically, you do a "computation" that results in a "thing", and then you want to chain another "computation" that acts as a function on the previous "thing" and returns another "thing"
07:23:02 <chrisdone> mmmm. things
07:23:04 <chrisdone> tell me more
07:24:09 <magneticduck> by implementing the "bind" function for a monad, you express how that chaining works out; you can't simply apply a function to the thing in the package as if it were a thing on its own, you have to deal with the context of the thing
07:24:17 <magneticduck> lol this is hilarious, but I think I'm making a kind of point
07:24:55 <magneticduck> beaky: do you know how to use monads, or are you asking about their philosophy?
07:24:55 <Eduard_Munteanu> Are closed type families available in GHC 7.6.3?
07:25:10 <Eduard_Munteanu> Or is it unreleased yet?
07:25:24 <Eduard_Munteanu> *are they
07:26:00 <bennofs> Eduard_Munteanu: they are only in HEAD, and will be in GHC 7.8
07:26:07 <Eduard_Munteanu> Ah, thanks.
07:26:37 <beaky> yes monads are easy to use
07:27:10 <magneticduck> why, they're obvious! but only after you know they're obvious
07:27:15 <magneticduck> =P
07:31:08 <Rembane> magneticduck: What happens if you add the library with a command line option, like this: -llibsoundfile -L <the path the .so-file resides in>
07:31:13 <Rembane> magneticduck: +?
07:32:13 <magneticduck> sorry, was away
07:32:19 <magneticduck> uh, let me see
07:32:40 <magneticduck> I'm quite a newbie when it comes to c libraries
07:33:55 <magneticduck> "unrecognized flags: -L"
07:34:08 <magneticduck> ghc --make -llibsoundfile -L ./usr/local/lib/libsndfile.so Main.hs
07:34:13 <magneticduck> was what I used
07:34:40 <magneticduck> Rembane
07:34:45 <Rembane> magneticduck: Interesting.
07:35:06 <Rembane> magneticduck: Oh. Stupid conventions. Try: -L./usr/local/lib/libsndfile.so instead
07:35:28 <magneticduck> (btw lol typo, I meant to put "/usr/local...")
07:35:42 <magneticduck> I'm not compiling my source at root! l|
07:36:01 <Rembane> ^____^
07:36:03 <magneticduck> alright I got a different error
07:36:07 <magneticduck> [1 of 1] Compiling Main             ( Main.hs, Main.o )
07:36:10 <magneticduck> Linking Main ...
07:36:12 <magneticduck> /usr/bin/ld: cannot find -llibsoundfile
07:36:14 <magneticduck> collect2: ld returned 1 exit status
07:36:17 <Rembane> Interesting
07:36:22 <enthropy> use -lsoundfile
07:36:27 <magneticduck> same thing
07:36:36 <Rembane> magneticduck: What enthropy said :D
07:36:50 <magneticduck> ld always returns the same error
07:36:53 <enthropy> ghc --make -lsoundfile -L usr/local/lib Main.hs
07:36:57 <enthropy> something like that
07:37:01 <magneticduck> just the library it couldn't find it different
07:37:07 <enthropy> the order of the flags can matter
07:37:26 <magneticduck> yeah same thing
07:37:31 <enthropy> (usually Main goes before the -l... but maybe it doesn't matter with ghc)
07:37:44 <enthropy> did you add the leading slash?
07:37:48 <magneticduck> first the -L unrecognized error, then after I took out the space, the same old /usr/bin/ld error
07:37:49 * enthropy made a typo
07:37:51 <magneticduck> yes
07:38:01 <magneticduck> removed the space and added a forward slash
07:38:19 <magneticduck> I'm trying every possible name I know
07:38:23 <magneticduck> for that library
07:38:26 <paolino> :t (<$>)
07:38:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:38:39 <paolino> :t ap
07:38:39 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:38:47 <Rembane> magneticduck: Can you pastebin your testcode? I want to play with it too! :D
07:38:54 <magneticduck> alright
07:38:57 <enthropy> magneticduck: oh if your file is libsndfile.so you need  -lsndfile
07:39:05 <magneticduck> http://www.mega-nerd.com/libsndfile/
07:39:09 <magneticduck> you have to get the c library from there
07:39:15 <magneticduck> then the cabal package hsndfile
07:39:18 <paolino> @hoogle Monad m => m (a -> b) -> m a -> m b
07:39:18 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:39:18 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
07:39:18 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:39:55 * enthropy never uses --make with ghc
07:39:58 <Rembane> magneticduck: ArchLinux has installed it for me.
07:40:08 <merijn> enthropy: It's been redundant for a couple of releases :p
07:40:09 <enthropy> except maybe if cabal puts the flag in there
07:40:38 <magneticduck> and then my modified test code which compiles fine is http://pastebin.com/YXNQLWXd
07:40:44 <mauke> The paste YXNQLWXd has been copied to http://lpaste.net/93225
07:40:48 <beaky> can you use Either or tuples in a newtype?
07:42:09 <Fuuzetsu> Why not?
07:42:18 <beaky> maybe it is cheating
07:42:27 <Fuuzetsu> Uh, cheating?
07:42:42 <beaky> yes in newtype you can only have one member
07:42:53 <magneticduck> newtype just means "data", but it runs faster and it can only take one one-parameter constructor
07:42:56 <magneticduck> ...
07:43:04 <magneticduck> I'm missing something here
07:43:12 <beaky> what if that one-parameter is a tuple
07:43:15 <hpc> magneticduck: so you have
07:43:15 <beaky> and has eithers in it
07:43:17 <magneticduck> oh, that's fine
07:43:19 <beaky> wow
07:43:21 <hpc> "data Foo = Foo Int"
07:43:22 <magneticduck> lol I'm a bit mixed up
07:43:31 <magneticduck> yes I see your point
07:43:32 <hpc> magneticduck: or better, "data foo = Foo ()"
07:43:34 <magneticduck> well that should work fine
07:43:50 <hpc> magneticduck: Foo has 3 possible values, undefined, Foo undefined, and Foo ()
07:43:59 <hpc> magneticduck: "newtype Bar = Bar ()"
07:44:08 <hpc> magneticduck: this has only two values, undefined and Bar ()
07:44:16 <deech> Hi all, I'm trying to get hoogle working locally. I have created all the databases with "hoogle data all", but when I search it says that it couldn't find the "default" database.
07:44:18 <beaky> e.g. "data 3dpoint = 3dpoint Float Float Float" vs "newtype 3dpoint = 3dpoint (Float, Float, Float)"
07:44:28 <magneticduck> I wasn't arguing about how it's not morally correct for newtype to hold data with more than one constructor
07:44:35 <magneticduck> I was just a bit mixed up
07:44:36 <magneticduck> x|
07:44:39 <magneticduck> all better now
07:44:47 <chrisdone> duck typing =p
07:44:56 <magneticduck> luls
07:45:14 <magneticduck> newtype Foo = Quack.
07:45:30 <Fuuzetsu> beaky: why not just use ‘data’?
07:45:40 <beaky> maybe newtype is more eficient
07:45:49 <magneticduck> that's the point of newtype
07:45:57 <hpc> because you don't want the semantics of "this is a data type containing X"
07:46:02 <beaky> ah
07:46:04 <hpc> you want "this is a new type that's the same as X"
07:46:29 <magneticduck> it's for putting essentially a wrapper on a piece of data so you can remake type class instances and giving it special meaning
07:46:32 <hpc> any performance you gain is a side-effect of the actual semantics of newtype
07:46:39 <magneticduck> give*
07:47:00 <chrisdone> it's also for adding invariants to otherwise too permissive types
07:47:09 <chrisdone> e.g. newtype UserId = UserId Int
07:47:12 <magneticduck> Rembane: how's it going?
07:47:19 <magneticduck> the first day it worked fine for me
07:47:22 <Rembane> magneticduck: Slowly forward, I'm installing ALL THINGS! :D
07:47:25 <magneticduck> but now it can't find the library
07:47:35 <hpc> chrisdone: another application of it, but not what it actually is :P
07:47:37 <chrisdone> and then you don't export your UserId constructor, and you can only construct a UserId from the user database
07:47:51 <magneticduck> uh, hsndfile requires only base if I'm not mistaken
07:48:08 <magneticduck> oh, did you have to install the libsndfile after all?
07:48:24 <magneticduck> I had a discussion about newtype the other day
07:48:28 <Rembane> magneticduck: It needs happy and c2hs too.
07:48:35 <magneticduck> what?!
07:48:43 <magneticduck> oh yeah that's right I forgot about that
07:49:04 <beaky> http://ideone.com/36ItxI what does this function do
07:49:06 <Rembane> magneticduck: cabal install goes FAtal ERror 1 if you don't have them installed.
07:49:27 <chrisdone> "ooo what does this function do? *press*" "DEEDEE NOOOO"
07:49:51 <beaky> I wrote this ages ago and now I have no idea what it does
07:49:55 <beaky> nor how to improve it
07:50:03 <Rembane> beaky: What's the output?
07:51:05 <beaky> ah
07:51:39 <beaky> it takes a big string (s), and returns all possible ways of substituting substring (t) with (u)
07:51:51 <beaky> is it possible to write it better?
07:51:54 <beaky> e.g. with applicatives
07:52:31 <ManateeLazyCat> Long time no see.
07:52:35 <beaky> hello
07:53:06 <beaky> e.g. f "foo" "bar" "foofoo" returns ["foofoo", "barfoo", "foobar", "barbar"]
07:53:12 <magneticduck> Rembane: installing package is fun isn't it >___>
07:54:34 <magneticduck> I've been searching a week now for a good way to render sound in haskell
07:54:50 <magneticduck> I started trying to use a command line utility called sox to render sound
07:54:57 <magneticduck> I got kind of far (https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs)
07:55:34 <magneticduck> but eventually I realized it didn't have the power I wanted, (I couldn't actually, for instance, ADD two sound files)
07:55:57 <magneticduck> so I went searching for simple offline software synthesizers, upon which I found csound-expression, hommage, and synthesizer
07:56:22 <magneticduck> none of them seemed to install, hommage and synthesizer haven't seen much love lately, and csound-expression also didn't really have the control I wanted
07:56:43 <magneticduck> so I found hsndfile, which looks good and worked the first day
07:56:50 <magneticduck> but now it's broken?!?! I am so mad :<
07:57:24 <Rembane> magneticduck: Yeah, this brings me back to the RedHat RPM-days. It was a dark age.
07:57:49 <Rembane> magneticduck: If this continues I need to find somekind of wrapper around cabal that makes it easier to manage dependencies.
07:57:59 <magneticduck> I was going to try to salvage hommage for useful code.. but it seems dependant on some old, dark libraries
07:58:26 <rck> fairly new to haskell - how do you handle a situation where you need to track state? imperitive languages you would mutate some variable. ex: you have a list of people and a list of hats. you want to assign hats to people based on some criteria. what is the idiomatic way to keep track of this pairing later in your program? hash table? IORef? return new list of tuples with (person, hat)?
07:58:30 <wlangstroth> I've found cabal-dev helpful, fwiw
07:58:38 <Earnestly> Is it possible to make cabal use a different directory than .cabal in my $HOME?
07:58:38 <magneticduck> also, it had "base" AND "haskell98" in the build dependencies list simultaneosly
07:58:49 <magneticduck> to give you.. an idea of the kind of library it was
07:58:50 <merijn> rck: Sounds like a use case for the State monad
07:58:58 <bennofs> rck: I think you can just return a list of new tuples
07:59:21 <bennofs> rck: or use a map
07:59:27 <rck> merijn: thanks, I'll research more
08:00:10 <rck> bennofs: in that trivial example zipping into a tuple would work yeah, but if you have a lot more than 2 associations (person, hat, sunglasses, shirt, shoes, belt, etc) then it becomes unweildy
08:00:16 <merijn> rck: Basically, the State monad adds an extra (hidden) input argument and output value (the state) to a function which you can then chain together
08:00:37 <magneticduck> do you know about monads rck?
08:00:49 <rck> magneticduck: I know enough to know I need to know more :)
08:00:51 <magneticduck> I'm not sure what kind of a "beginner" you are
08:00:59 <magneticduck> heh
08:01:04 <merijn> rck: In your case you'd have the map of "hat, person" pairings as that extra argument, which makes it look like you're mutating state
08:01:14 <merijn> rck: I believe LYAH has a nice chapter illustrating State
08:01:49 <rck> merijn: thanks, I'll go read up before I ask more questions
08:02:29 <merijn> rck: quick warning though, the State/Writer/Reader data constructors mentioned in LYAH no longer exist, use the state/writer/reader functions instead
08:02:49 <merijn> rck: Don't worry too much about why, as that's not that important to know
08:02:59 <rck> is that a recent thing?
08:03:16 <rck> or is LYAH older
08:03:16 <magneticduck> I hate foreign. Too bad 90% of everything is written in C
08:03:34 <merijn> rck: Fairly recent (somewhere in the past few years?)
08:04:21 <rck> LYAH 2011, nice tip thanks
08:04:25 <geekosaur> couple years ago, whenever mtl2 was first released
08:04:25 <Hafydd> Due to Heron's law, 90% of everything is crap - so at least 80% of everything is both written in C and crap.
08:04:56 <geekosaur> sadly for LYAH, the change came shortly after it was published
08:06:04 <Rembane> magneticduck: This is a very frustrating library to install. base and haskell98 at the same time...
08:06:11 <geekosaur> (possibly even before the actual book as opposed to the online one)
08:06:13 <magneticduck> 'es
08:06:22 <magneticduck> but I wasn't talking about hsndfile
08:06:29 <magneticduck> hsndfile installation actually went quite smoothly
08:06:45 <Rembane> :D
08:06:56 <magneticduck> "hommage" was the thing with that interesting design choice
08:07:20 <magneticduck> I have a feeling that the cabal file didn't get properly synced with the dev's computer or something like that
08:07:41 <Rembane> magneticduck: Oh
08:07:53 <magneticduck> maybe he made one mistake, exported everything, and then forgot to re-export the cabal file
08:07:56 <magneticduck> I've done that a few times
08:08:00 <Rembane> magneticduck: Hackage says that hsoundfile is obsolete. http://hackage.haskell.org/package/HSoundFile
08:08:03 <rck> what about lenses? fancy wrappers around state?
08:08:16 <magneticduck> ohhh
08:08:20 <magneticduck> you're using the wrong package!
08:08:22 <magneticduck> rofl
08:08:24 <magneticduck> "hsndfile"
08:08:30 <Rembane> Nice :D
08:08:36 <magneticduck> lol
08:08:47 <Rembane> Stupid brain macros
08:08:54 <magneticduck> woah that thing is MESSED UP
08:09:01 <magneticduck> and I thought hommage was bad
08:09:07 <Rembane> Installing hsndfile was trivial. Sweet.
08:09:14 <Rembane> Trivial = Just works
08:09:22 <Rembane> Instead of Nothing
08:09:40 <magneticduck> hehe
08:09:46 <magneticduck> alright, see if you can execute my code
08:09:52 <magneticduck> it should generate a small amount of silence
08:09:56 <magneticduck> (the samples are all at 0)
08:10:41 <Rembane> magneticduck: It runs and generates a 2.0K big Wave-file.
08:10:48 <Rembane> magneticduck: runghc main.hs
08:10:50 <magneticduck> > (concat $ replicate 1000 (concat [(replicate 50 0), (replicate 50 1)])
08:10:51 <lambdabot>   <hint>:1:71:
08:10:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
08:10:52 <magneticduck> for square wave
08:10:58 <magneticduck> > (concat $ replicate 1000 (concat [(replicate 50 0), (replicate 50 1)]))
08:11:00 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:11:06 <magneticduck> alright
08:11:09 <magneticduck> that's about right
08:11:13 <magneticduck> I guess it wasn't really small
08:12:13 <magneticduck> wait, 1000 samples at 41100 sample rate?
08:12:17 <Rembane> I really think Hackage needs an obsolete-flag which shows a warning and forces a confirmation from the user trying to install that package.
08:12:26 <magneticduck> hehe
08:12:35 <Rembane> That's not many seconds.
08:12:41 <magneticduck> no it isn't
08:12:48 <magneticduck> how long is the generated file?
08:12:52 <magneticduck> in time?
08:13:33 <magneticduck> oh well, at least you have it working
08:13:40 <Rembane> Duration                        : 0.02 s
08:13:48 <Rembane> But exiftool thinks it's broken
08:13:51 <magneticduck> run ghc --make -libsndfile -L/usr/local/libsndfile.so Main.hs
08:14:06 <magneticduck> what is broken?
08:14:11 <Rembane> I do have toe sndfile-library installed by my pacman though.
08:14:17 <Rembane> Warning                         : Encountered empty null chunk. Processing aborted
08:14:24 <magneticduck> ..oh
08:14:29 <magneticduck> I think I know what's causing that
08:14:36 <magneticduck> but it should be easily fixable
08:15:31 <magneticduck> try making the square wave just to make sure it's all good =P
08:18:38 <enthropy> magneticduck: ghc knows to call pkg-config to get the -l and -L
08:18:54 <magneticduck> I know
08:19:19 <magneticduck> but I'd just like to know if it works
08:19:34 <magneticduck> uh, that option would override whatever GHC is doing automatically right?
08:20:35 <enthropy> well -L needs a directory
08:20:49 <magneticduck> a directory?
08:21:06 <merijn> -L specifies a directory to search for library files
08:21:10 <enthropy> as in   /usr/local/
08:21:15 <merijn> -l specifies directories to link with
08:21:17 <enthropy> not /usr/local/libsndfile.so
08:21:33 <merijn> "-libsndfile" is also not right
08:21:39 <enthropy> also, you probably don't have a   libibsndfile.so anywhere
08:21:46 <monochrom> ghc -L /usr/local Main.hs -lsndfile
08:21:57 <merijn> If you want to link with libsndfile.so in /usr/local you want "-L/usr/local -lsndfile"
08:22:04 <magneticduck> what does the last -lsndfile do?
08:22:11 <magneticduck> alright
08:22:21 <merijn> magneticduck: Specify which library to link with
08:22:21 <monochrom> it means libsndfile.so or libsndfile.a
08:22:32 <magneticduck> woo it works!
08:22:40 <magneticduck> ghc --make -L/usr/local/lib/ -lsndfile Main.hs
08:22:44 <magneticduck> huh.
08:22:52 <geekosaur> hm
08:22:55 <magneticduck> wait a second
08:22:55 <merijn> --make should be unnecessary in recent ghc's
08:22:56 <geekosaur> don't move the -l before
08:23:04 <magneticduck> but now it works without the option
08:23:10 <geekosaur> it's position dependent (it's a macro, not an option)
08:23:22 <geekosaur> if it's a shared object it *might* work out of position
08:23:38 <magneticduck> lol maybe some higher level lifeforms who live in my hard drive are playing some sort of a sophisticated practical joke
08:23:48 <monochrom> yes
08:23:54 <magneticduck> so, what could change between then and now?
08:23:58 <magneticduck> I executed the same code
08:24:04 <magneticduck> but then ld couldn't find the library
08:24:07 <magneticduck> and now it works smoothly
08:24:25 <magneticduck> uhh
08:24:29 <monochrom> computer backdoor
08:24:40 <monochrom> and a spy
08:24:41 <magneticduck> actually, I think I know what it was
08:24:48 <magneticduck> for some reason that I am not sure of
08:24:58 <magneticduck> between yesterday and when I logged on today, the library file got removed (??!?!?)
08:25:06 <magneticduck> I tried compiling the code, didn't work
08:25:07 <monochrom> yes
08:25:11 <magneticduck> I tried adding a bad option, didn't work
08:25:27 <magneticduck> I reinstalled and rewrote the library file, but I didn't try without a well constructed option, still didn't work
08:25:32 <magneticduck> and now I take the option away and magically it works
08:25:45 <magneticduck> =P
08:26:03 <monochrom> 24 hours is a long time
08:26:30 <magneticduck> the key to our front door is actually quite eccentric and supposedly lockpick proof
08:26:43 <magneticduck> (it has these funny holes with convex dents on them on the side)
08:26:49 <magneticduck> but maybe the spy entered through the window
08:26:52 <monochrom> but the backdoor
08:27:00 <magneticduck> we live on the 7th floor of an apartment
08:27:18 <magneticduck> we are talking about a very determined, subtle spy with a bizzare sense of humor
08:27:22 <monochrom> software backdoor. does software have 7 floors?
08:27:40 <magneticduck> sometimes
08:27:43 <monochrom> I guess OSI network software does
08:28:16 <Eduard_Munteanu> Would closed type families allow truly identity functors to be defined?
08:28:36 <dagano> how do I flatten this list [(1,2)] -> (1,2) ?
08:28:40 <Eduard_Munteanu> Or some other extension. Newtypes are getting on my nerves.
08:28:41 <dagano> :t join
08:28:42 <lambdabot> Monad m => m (m a) -> m a
08:28:53 <scshunt> dagano: what if you have [(1, 2), (3, 4)]?
08:28:53 <dagano> nope
08:28:59 <dagano> i will never have that
08:29:01 <dagano> :)
08:29:04 <scshunt> then use head?
08:29:04 <Eduard_Munteanu> dagano: head :)
08:29:07 <dagano> OH
08:29:09 <dagano> thnks
08:29:32 <Eduard_Munteanu> dagano: note pairs aren't monads
08:30:04 <dagano> yeah
08:30:06 <dagano> but
08:30:13 <enthropy> Eduard_Munteanu: I think closed type families get you about the same as overlapping instances + fundeps
08:30:15 <dagano> > join [[1,2]]
08:30:17 <lambdabot>   [1,2]
08:30:18 <magneticduck> wait a sec, but now it stopped working again
08:30:19 <dagano> lists are
08:30:23 <enthropy> with a much nicer notation / assurance that things will be sane
08:31:29 <enthropy> Eduard_Munteanu: your problem is that you need something with kind (* -> *) that's like id?
08:31:31 <Eduard_Munteanu> enthropy: I'm not aware of any way to accomplish that with overlapping instances and fundeps, though. I mean stuff like    fmap = id  for f = Id
08:31:40 <Eduard_Munteanu> enthropy: yeah
08:32:07 <magneticduck> where is the GHC search path for C libraries stored?
08:32:09 <enthropy> well you can make your own Functor that's polykinded
08:32:30 <Eduard_Munteanu> enthropy: yeah, that's my workaround as well, I was wondering if there are plans to improve that somehow
08:32:43 <merijn> magneticduck: GHC has no search path, it just calls your system's linker
08:32:45 <monochrom> I know exactly what happened. Day 1: you put libsndfile.so in /usr/local/lib, then try "ghc Main.hs -lsndfile" or even just "gcc cprogram.c -lsndfile", it says not found. This is because you haven't run "sudo ldconfig -a" yet. Day 2: someone else ran "sudo ldconfig -a". henceworth, "ghc Main.hs -lsndfile" finds it.
08:33:09 <geekosaur> magneticduck is on OS X, I think
08:33:12 <geekosaur> ldconfig is not a thing
08:33:16 <Eduard_Munteanu> enthropy: but I'm not exactly sure what you mean by polykinded
08:33:20 <merijn> ldconfig? Sounds like newfangled linuxism nonsense
08:33:40 <monochrom> oh, oops. then nevermind
08:34:00 <magneticduck> no, I'm on linux
08:34:05 <geekosaur> oh
08:34:09 <monochrom> haha
08:34:14 <Eduard_Munteanu> enthropy: currently I'm defining a separate typeclass that lets me do  (f a -> f b) -> a -> b   for f = Identity
08:34:15 <merijn> Even on linux you shouldn't need ldconfig
08:34:31 <magneticduck> alright, so that would be.. pkg-config or something?
08:34:46 <magneticduck> lol never mind
08:34:57 <magneticduck> well I need it
08:35:02 <magneticduck> my package doesn't install without those flagsa
08:35:08 <magneticduck> options*
08:35:16 <magneticduck> supposing that those options mean something to ldconfig
08:35:38 * ksf can't manage to apply oleg's variants-in-terms-of-extensible-records trick to vinyl
08:35:40 <monochrom> why someone else ran "sudo ldconfig -a": because "sudo apt-get upgrade", and it happened that some upgrade was about a lib in /usr/lib and the upgrade script included "ldconfig -a"
08:36:40 <monochrom> I have not heard of ghc being aware of pkg-config. cabal-install sure.
08:37:03 <enthropy> Eduard_Munteanu:   class F2 (f :: k) where fmap :: (a -> b) -> F f a -> F f b;   type family F f a :: *; type instance F (f :: * -> *) a = f a; type instance F 'Identity a = a
08:37:42 <monochrom> anyway, "sudo apt-get upgrade" in turn may even be run by a daily cron job
08:37:56 <Eduard_Munteanu> Oh, so you can define instances for type (synonym) families.
08:37:58 <monochrom> like I said, 24 hours is a long time
08:37:59 <enthropy> then again I don't see the utility of a class to do  (f a -> f b) -> a -> b   for f = Identity
08:38:17 <enthropy> it seems only useful for Identity
08:39:10 <Eduard_Munteanu> enthropy: I'm unnecessarily making things more polymorphic, cargo culting edwardk :P
08:39:42 <enthropy> you could/probably should make that F type family associated with F2
08:40:21 <Eduard_Munteanu> Hm.
08:41:09 <monochrom> merijn: do you mean "empirically not needed on today's most linuxes"? or "not needed if one improved linux"? because the former is false and can be demonstrated.
08:42:00 <magneticduck> so anyway, where do I put that magically little friend -L/usr/local/lib/ -lsndfile in the cabal file so cabal appends it to "GHC --make" when it builds my code?
08:42:05 <dagano> :t ()
08:42:05 <magneticduck> magical*
08:42:06 <lambdabot> ()
08:42:11 <dagano> is that unit .. or empty tuple?
08:42:28 <enthropy> magneticduck: you put it in a file that pkg-config knows how to find
08:42:32 <magneticduck> that's the logical continuation of the tuple
08:42:43 <enthropy> since hsndfile has extra-libraries: sndfile
08:42:47 <ksf> I'd say unit, as we don't have 1-tuples.
08:43:05 <magneticduck> enthropy: the library is in /usr/local/lib/ but "ld" consistantly fails to find it
08:43:10 <merijn> monochrom: I meant more "I've never needed ldconfig while working on linux, so it is at best only needed for usecases I haven't personally tried (which may or may not be the majority of usecases, I dunno)"
08:43:16 <dagano> :k IO ()
08:43:17 <lambdabot> *
08:43:28 <magneticduck> what.
08:43:29 <enthropy> magneticduck: why don't you use a distro package instead?
08:43:37 <merijn> dagano: It's unit
08:43:39 <magneticduck> oh well yes that makes sense actually
08:43:47 <enthropy> your distro probably worked out where to put things
08:43:50 <magneticduck> enthropy: there are no libsndfile packages for my distro
08:43:56 <ksf>  /usr/*local*/lib
08:43:58 <magneticduck> just some test programs
08:44:00 <magneticduck> it's..weird
08:44:05 <ksf> it's not supposed to find it without additional flags.
08:44:07 <magneticduck> probably because it's new?
08:44:07 <enthropy> get another distro then?
08:44:24 <magneticduck> lol I'm going to keep this simple for now
08:44:36 <magneticduck> I'm using the ubuntu because it was too difficult to install arch on top of windows 8
08:44:47 <magneticduck> I'm going to redo everything one day since I'm not using windows 8
08:44:50 <dagano> > head []
08:44:51 <lambdabot>   *Exception: Prelude.head: empty list
08:44:52 <magneticduck> but not today
08:44:54 <dagano> explode
08:44:56 <enthropy> well the ubuntu has a libsndfile package
08:45:26 <magneticduck> "unable to locate package libsndfile"
08:45:34 <monochrom> magneticduck: read the man page of dlopen. it is how I learned why "ldconfig -a" is needed for some libs but not others.
08:45:38 <enthropy> you have to install it of course
08:47:01 <magneticduck> sudo apt-get install libsndfile right?
08:47:13 <magneticduck> it doesn't find the package.
08:47:55 <geekosaur> you might try apt-cache search sndfile
08:48:04 <magneticduck> I did that a while ago, nothing
08:48:21 <magneticduck> wait lol I found it
08:48:23 <magneticduck> >_>
08:48:34 <magneticduck> oh, I see, apt-cache doesn't work with regex
08:49:03 <magneticduck> "libsndfile1-dev"
08:49:24 <monochrom> "aptitude search" accepts regex
08:49:41 <magneticduck> wonderful, I finally am making sound!
08:50:21 <magneticduck> now I just need to learn about header formats and sample formats
08:50:38 <magneticduck> because only about half the sound playing programs I'm using seem to like my files
08:51:12 <magneticduck> I'm writing floats to a files with pcm16 sample format
08:51:16 <magneticduck> however that works!
08:51:34 <Rembane> magneticduck: libsndfile should convert things magically to wave files.
08:52:01 <monochrom> if I taught a linux course for a fee to cover my living cost, people would not come, because they already get free instructions from IRC. my road to rotting hell is paved by IRCers' good intention.
08:52:33 <magneticduck> you could teach a class on how to use IRC
08:52:41 <magneticduck> but nobody would stay for long
08:52:58 <magneticduck> Rembane: actually I believe the poing of libsndfile is to support a huge variety of formats
08:53:21 <merijn> monochrom: The same goes for me teaching Haskell >.<
08:53:25 <Rembane> magneticduck: Indeed.
08:53:35 <geekosaur> Rembane, WAV files are just a container. not everything that speaks .WAV understands all the formats it can contain
08:53:50 <magneticduck> and there are a lot of them
08:54:03 <Rembane> geekosaur: Indeed, I was a uberly fuzzy there. :/
08:54:05 <monochrom> the Haskell is more understandable. it has a lower demand to begin with.
08:54:17 <monochrom> s/the Haskell/the Haskell case/
08:56:06 <magneticduck> lol I can't seem to make sox happy
08:56:24 <magneticduck> it seems to want an extra "FmpExt" chunk
08:56:32 <magneticduck> "FmtExt"*
08:56:59 <magneticduck> google seems to say that sox it pretty notorious about this
08:57:09 <Rembane> magneticduck: Regardless of what output format you choose?
08:58:08 <magneticduck> http://old.nabble.com/Re%3A-sox%3A-wave-header-missing-FmtExt-chunk-p29812171.html lol that guy is pretty helpful?
08:58:10 <magneticduck> yes
08:58:21 <magneticduck> there is actually only one header format, called HeaderWav
08:58:35 <magneticduck> nothing I change in the sample format seems to fix the problem
09:00:52 <copumpkin> Cale: more things we can blame on the silent overflow behavior of Int and friends: the loss of the Deep Impact probe :P
09:02:24 <Eduard_Munteanu> I wonder if I should index the hom map and do away with the object map for indexed (co)monads.
09:03:14 <Eduard_Munteanu> I have  class (CategoryG c, CategoryG d) => FunctorG (c :: obC -> obC -> *) (d :: obD -> obD -> *) (f :: ix -> ix -> obC -> obD) where fmapG :: (a |~c~> b) -> (f i j a |~d~> f i j b)
09:03:29 <Eduard_Munteanu> Maybe I should give c and d indices.
09:04:20 <Eduard_Munteanu> I'd make the categories indexed in that case, I guess.
09:05:57 <roconnor> I wish haskell had formal semantics.
09:05:58 <Eduard_Munteanu> But that makes stuff like a -> f i j a difficult.
09:06:06 <roconnor> I find seq confusing.
09:07:14 <Eduard_Munteanu> I could make that  a |~f i j~> a  but I don't even know what that is. Some sort of hybrid category?
09:08:20 <monochrom> roconnor: it appears that John Hughes contributed to seq. you may ask him! :)
09:08:41 <beaky> how do the different haskell webapp platforms differ
09:08:44 <beaky> which should I use?
09:08:54 <beaky> i am using scoty and it is nice and barebones
09:09:46 <monochrom> it is also possible that John Hughes doesn't work much on formal semantics
09:10:29 <Eduard_Munteanu> That is, given F : C -> D, you have E such that Ob(E) = C U F(C) U F(F(C)) U ...,  --   nah, it's stupid.
09:12:20 <roconnor> monochrom: I'm thinking about whether there is any reasonable way that we can define (\x. _|_ x) and _|_ to be denotationally equal wrt seq so that we can get eta-equality in Haskell.
09:12:34 <monochrom> I think you accept "WHNF for function means lambda", and you just don't know what if the implementation uses combinators instead. does the follow help? "then the implementation has to behave as though WHNF for functions means lambda"
09:12:59 <roconnor> monochrom: the Haskell report doesn't say WHNF AFAIU.
09:13:07 * roconnor goes to double check.
09:15:29 <monochrom> it doesn't say WHNF. but it says ⊥ is not the same as (\x -> ⊥). or does it mean that it says that implementations are allowed, but not required, to make ⊥ different from (\x -> ⊥)?
09:16:18 <roconnor> monochrom: I'm not sure how to read that sentnce to me.
09:16:25 <int-e> magneticduck: it's not a chunk, it's an optional part at the end of the fmt  chunk
09:16:27 <FreeFull> monochrom: bottom isn't the same as  (\x -> bottom) because lambda is a constructor
09:16:51 <dougdougdoug> @pl zadehUnion f1 f2 x  =  max (f1 x) (f2 x)
09:16:51 <lambdabot> zadehUnion = liftM2 max
09:17:04 <roconnor> To me it reads that "⊥ is not the same as (\x -> ⊥)" is supposedly a consequence of the definition of seq, but I don't beleive that to be a theorem myself.
09:17:45 <magneticduck> int-e: ah
09:17:58 <int-e> magneticduck: (going by  http://www.sonicspot.com/guide/wavefiles.html#fmt  and the sox sources)
09:17:58 <roconnor> And even if it were true, it does it have any consequence regarding ⊥ vs (\x -> ⊥ x)
09:18:05 <magneticduck> int-e: it seems that sox is the only program I've seen so far that has had any problem with its absence
09:18:07 <magneticduck> thanks
09:18:28 <haasn> :t is . only -- best (==)
09:18:29 <lambdabot>     Not in scope: `is'
09:18:29 <lambdabot>     Perhaps you meant one of these:
09:18:29 <lambdabot>       `id' (imported from Data.Function),
09:18:31 <haasn> :(
09:18:37 <roconnor> ... or does it follow from the fact that  ⊥ x = ⊥?
09:18:41 <roconnor> ... I guess it does.
09:20:01 <roconnor> monochrom: when I implement Haskell, (\x -> ⊥) will equal ⊥.
09:20:53 <int-e> magneticduck: sox requires it for formats other than 1 (PCM), 6 (aLAW) and 7 (muLAW) .
09:21:16 <shachaf> roconnor: It's impossible for that to happen in an implementation of Haskell.
09:21:31 <shachaf> Oh, wait, that's what you're talking about.
09:21:33 <shachaf> Never mind.
09:21:47 <roconnor> shachaf: I will reduce function to HNF in seq. :D
09:22:42 <shachaf> :t has . only
09:22:43 <lambdabot> Eq a => a -> a -> Bool
09:23:01 * hackagebot cookbook 0.1.4.0 - An independent library of common haskell operations.  http://hackage.haskell.org/package/cookbook-0.1.4.0 (NatePisarski)
09:23:18 <magneticduck> int-e: interesting, when I encode it with PCM16 format, it doesn't give the error but it doesn't recognize that my file has any samples!
09:25:48 <copumpkin> roconnor: ICFP?
09:29:09 <FreeFull> I am tempted to write Haskell bindings for libcaca
09:29:22 <FreeFull> Since there are none for either aalib or libcaca
09:30:17 <FreeFull> :t has
09:30:18 <lambdabot> Getting Any s a -> s -> Bool
09:30:18 <roconnor> copumpkin: ICFP?
09:30:20 <FreeFull> :t only
09:30:31 <FreeFull> :t Control.Lens.only
09:30:32 <lambdabot> (Eq a, Applicative f, Choice p) => a -> p () (f ()) -> p a (f a)
09:31:04 <haasn> http://lpaste.net/93226 !
09:32:22 <copumpkin> roconnor: you going? :P
09:32:41 <FreeFull> haasn:  main = mapM_ (print . fizzBuzz) [1..100]    ????
09:32:53 <haasn> FreeFull: yes
09:32:58 <haasn> err
09:33:01 <haasn> putStrLn . fizzBuzz
09:33:09 <haasn> but that bit is boring :)
09:35:22 <FreeFull> haasn: But the world must see the quotes!
09:36:00 <haasn> I can't help but feel this ‘beside’ thing could be generalized to something like :: [Fold a x] -> Fold a x
09:36:26 <haasn> cloned.beside x y -- that is
09:36:33 <dfan> I'm particularly looking forward to FARM  http://www.cis.upenn.edu/~byorgey/farm13/
09:37:52 <roconnor> copumpkin: nope; where is it?
09:38:23 <dfan> Boston
09:39:03 <FreeFull> :t \x y -> cloned.beside x y
09:39:04 <lambdabot> Not in scope: `cloned'
09:39:13 <FreeFull> :t \x y -> L.cloned.beside x y
09:39:14 <lambdabot> Not in scope: `L.cloned'
09:39:22 <FreeFull> :t \x y -> L.cloned . beside x y
09:39:23 <lambdabot> Not in scope: `L.cloned'
09:39:27 <FreeFull> Oh well
09:42:23 <donri> what is the best type/package if i need something like a Builder but * -> *? Seq? DList?
09:42:54 <benmachine> donri: in what way like a builder?
09:43:06 <monochrom> consider also vector :)
09:43:24 <donri> benmachine: cheap append, i guess
09:44:03 <roconnor> donri: Seq is a good default choice for needing cheap append
09:44:20 <roconnor> donri: DList is reasonable in many situations too.
09:44:40 <benmachine> I'd say Seq is more general-purpose
09:44:41 <donri> i vaguely recall people recommending against the "dlist" package though?
09:45:17 <elliott> donri: Endo [a]
09:45:20 <roconnor> donri: I just used Endo [a] instead of Dlist
09:45:28 <donri> oh right that trick
09:45:32 <roconnor> donri: or more often I just use Dlists directly.
09:45:41 <roconnor> as [a] -> [a]
09:46:14 <roconnor> Dlists are probably most appropriate when you want to eventually get a list, but want a bunch of cheap appends for a while.
09:46:22 <roconnor> otherwise I'd use Seq.
09:46:23 <donri> yeah
09:46:34 <elliott> Endo is nice because you get a Monoid
09:47:02 <donri> basically i have [Either ByteString Text] and need to encode/decode in IO and then concat them
09:47:12 <donri> i don't really care about the intermediate structure
09:47:28 <roconnor> donri: Dlists seem appropriate for that.
09:47:49 <benmachine> elliott: Monoids aren't hard to come by
09:48:25 <elliott> benmachine: but it's the DList monoid.
09:48:28 <flebron> "Rho, rho, rho of x / always equals one / rho is dimension / rho rho rank / APL is fun"
09:48:32 <elliott> ([a] -> [a]) doesn't have that monoid
09:48:42 <benmachine> elliott: ah, I see what you mean
09:49:02 <elliott> Endo ([1,2,3] ++) <> Endo ([4,5,6] ++) = Endo ([1,2,3,4,5,6] ++)
09:49:25 <scshunt> flebron: row, row, row, reduce, madly down the page. one mistake and you'll be baked so check at every stage
09:49:38 <donri> does it matter if you do (++ xs) or (xs ++) there
09:49:43 <scshunt> donri: yes
09:49:51 <donri> performance wise
09:49:58 <scshunt> donri: (++ xs) = \y -> y ++ xs
09:50:06 <scshunt> (xs ++) = \y -> xs ++ y
09:50:17 <donri> i'm quite aware
09:50:18 <benmachine> donri: if you're building up a big list piece by piece, you want the little pieces to be appended on the left
09:50:24 <roconnor> donri: um, denotation wise..
09:50:29 <benmachine> because smallList ++ bigList is much faster than bigList ++ smallList
09:50:39 <roconnor> >  runEndo (Endo ([1,2,3] ++) <> Endo ([4,5,6] ++)) []
09:50:48 <donri> roger, thanks
09:50:48 <lambdabot>   Not in scope: `runEndo'
09:50:48 <applic_tive> apEndo
09:50:55 <roconnor> > apEndo (Endo ([1,2,3] ++) <> Endo ([4,5,6] ++)) []
09:50:57 <lambdabot>   Not in scope: `apEndo'
09:50:57 <lambdabot>  Perhaps you meant `appEndo' (imported from Data.Mon...
09:50:59 <applic_tive> appEndo?
09:51:01 <roconnor> > appEndo (Endo ([1,2,3] ++) <> Endo ([4,5,6] ++)) []
09:51:03 <applic_tive> sorry
09:51:03 <lambdabot>   [1,2,3,4,5,6]
09:51:16 <roconnor> > appEndo (++Endo ([1,2,3]) <> Endo (++[4,5,6])) []
09:51:17 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo [a3]'
09:51:18 <lambdabot>              with actu...
09:51:25 <roconnor> > appEndo (Endo (++[1,2,3]) <> Endo (++[4,5,6])) []
09:51:26 <lambdabot>   [4,5,6,1,2,3]
09:51:28 <roconnor> ta
09:51:31 <roconnor> semantic difference
09:51:57 <benmachine> roconnor: right, but you could also use, say, Dual (Endo (++ xs))
09:52:25 <benmachine> roconnor: that would be semantically the same (I think?) but slower
09:52:27 <applic_tive> and really get awesome performance ...
09:52:31 <roconnor> benmachine: okay, but I don't think there is any asymtotic performance difference then.
09:53:04 <roconnor> benmachine: I take that back
09:53:09 <roconnor> benmachine: you are right
09:53:23 <benmachine> woo
09:54:11 <applic_tive> I take it that none of the 'ListT done right' libraries ever become the orthodox one?
09:54:14 <dougdougdoug> @pl FuzzySet (zadehUnion (shape a) (shape b)) (domain a)
09:54:14 <lambdabot> FuzzySet (zadehUnion (shape a) (shape b)) (domain a)
09:55:51 <int-e> magneticduck: hmm, for comparison, this seems to work with sox: http://lpaste.net/93227
10:09:47 <redscare> is anyone here familiar with emacs for haskell? when i use C-c C-t to get the type of anything i get the error "ghc-show-type0: Wrong type argument: sequencep, Dummy:0:0:Error:Could"
10:10:05 <meow45> I'm learning Template Haskell and am making a custom QuasiQuoter. I need a function of String -> TypeQ. How could I do this?
10:10:27 <magneticduck> nice int-e, thanks
10:10:27 <scshunt> meow45: You build up a template AST using the functions in Language.Haskell.TH
10:11:19 <meow45> scshunt: Oh, sorry, I asked the wrong question. I was wondering if there's a function to do this already, seeing as how [t| ... |] does the same thing.
10:11:25 <magneticduck> redscare: uh, paste the code
10:11:30 <magneticduck> and the value you're trying to get the type of
10:11:57 <magneticduck> that is a pure haskell error, not an emacs error
10:11:58 <redscare> so in my file, i just have "testf a = a + 3"
10:12:04 <meow45> scshunt: So what I'd like to do is reuse the [t| ... |] functionality withing a custom QuasiQuoter.
10:12:07 <magneticduck> that's all you have?
10:12:20 <redscare> magneticduck: yep
10:12:26 <magneticduck> Error:Could
10:12:27 <scshunt> meow45: it depends on what semantics you want exactly
10:12:33 <scshunt> meow45: but look into reify and mkName
10:12:42 <magneticduck> huh. I don't use the haskell setup for emacs so I'm not really sure what's going on
10:12:45 <scshunt> or lookupTypeName
10:12:46 <magneticduck> but what are you trying to get the type of?
10:13:01 <redscare> so if i have my cursor over testf it's supposed to look up testf right?
10:13:19 <magneticduck> try defining the type of testf like this: "testf :: Int -> Int"
10:13:28 <magneticduck> on the line above the function
10:13:31 <magneticduck> and then try it again
10:13:51 <redscare> magneticduck: didn't fix it. pretty sure something's up with ghc-mod?
10:13:56 <meow45> scshunt: Thanks! I'll see where it leads me.
10:14:07 <magneticduck> yeah that could be it
10:14:16 <magneticduck> because it should give you "Num a => a -> a"
10:14:31 <magneticduck> maybe it's not cool with deducing types
10:14:49 <magneticduck> but anyway, adding the type signature is good practice =P
10:15:05 <magneticduck> good style I mean
10:15:13 <magneticduck> helps avoid silly errors and the like
10:16:42 * roconnor must ... resist desire to ... give formal semantics to Haskell in Coq.
10:17:47 <monochrom> ha ha ha
10:17:51 <magneticduck> nah, let yourself go =P
10:18:03 <monochrom> consider instead HOL4, PVS, ACL2
10:18:11 <monochrom> hey, even Alloy
10:18:13 <roconnor> monochrom: *lol*
10:18:48 <monochrom> have you considered: write Haskell formal semantics in Haskell?
10:19:36 <roconnor> monochrom: I'm not sure that would clarify anything.
10:22:31 <magneticduck> redscare: did you get ghc-mod from hackage?
10:25:08 <mescalinum> why haskell has tails but not heads?
10:25:23 <mescalinum> tails $ reverse is the best replacement?
10:25:34 <roconnor> mescalinum: inits
10:25:38 <mescalinum> oh
10:25:39 <roconnor> > inits [1,2,3]
10:25:41 <lambdabot>   [[],[1],[1,2],[1,2,3]]
10:26:55 <roconnor> > [(x,y) | x <- inits [1,2,3] | y <- tails [1,2,3]]
10:26:57 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
10:28:34 <magneticduck> mescalinum: btw it would be (tails . reverse) == inits
10:28:40 <applic_tive> ooh ParallelListComp
10:29:21 <haasn> :t \m e -> m >>= mapMOf _Nothing (const e)
10:29:22 <lambdabot> Monad m => m (Maybe a) -> m () -> m (Maybe a)
10:29:47 <dougdougdoug> Can a functor not be made from a concrete type?  I am having trouble here: http://lpaste.net/7269013530349666304
10:29:52 <mescalinum> roconnor: why not  zip (inits [1,2,3]) (tails [1,2,3])
10:30:28 <roconnor> > zip <$> inits <*> tails $ [1,2,3]
10:30:30 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
10:30:34 <magneticduck> dougdougdoug: yeah, functors have to have kind * -> *
10:33:48 <dougdougdoug> magneticduck: so am i taking the wrong approach?  there is a context I am dragging around, but it is always tuple of (Double, Double).
10:41:09 <magneticduck> just make a function to transform the value in question
10:41:30 <magneticduck> functors are for when you make a type that "wraps" itself around another type, adding context
10:41:38 <beaky> hello
10:41:39 <magneticduck> but you want to be able to transform the type that you wrapped up
10:41:44 <beaky> how do I define my own monad
10:41:44 <magneticduck> woah
10:42:02 <monochrom> first define your own functor
10:42:04 <beaky> I want to define the identity monad
10:42:06 <magneticduck> data MyMonad a = <Constructor> a | <Constructor> a
10:42:15 <monochrom> first define the identity functor
10:42:16 <magneticduck> instance MyMonad a where <instances>
10:42:24 <magneticduck> id, >>=
10:42:26 <magneticduck> and return
10:43:07 <magneticduck> btw you can have as many constructors in your data type as you want, I just put two down and forgot to put a ... at the end
10:46:44 <linziyi> hi
10:46:46 <linziyi> noob here
10:46:51 <linziyi> just want to ask a little question
10:47:27 <linziyi> http://pastebin.com/fGkiRDvH this function
10:47:29 <mauke> The paste fGkiRDvH has been copied to http://lpaste.net/93228
10:47:52 <linziyi> can anyone "translate" it into human language?
10:47:57 <linziyi> I don't quite get it
10:48:06 <Iceland_jack> linziyi: The length of an empty list is 0
10:48:18 <Iceland_jack> The length of a non-empty list is the 1 plus the length of the rest
10:48:30 <magneticduck> haskell is cool ain't it?
10:48:32 <linziyi> but why does it use the tuple?
10:48:37 <Iceland_jack> linziyi: It doesn't
10:48:45 <linziyi> but the parethese?
10:48:49 <magneticduck> that's not a tuple, it's just to isolate the constructor
10:49:02 <magneticduck> (x:xs) means x:xs
10:49:04 <Iceland_jack> The parentheses are just to group the constructor and its arguments together
10:49:06 <linziyi> oh
10:49:15 <linziyi> oh!
10:49:20 <magneticduck> if you didn't use it it would fail with a syntax error
10:49:23 <Iceland_jack> I donfer if this works:
10:49:26 <Iceland_jack> :i []
10:49:29 <Iceland_jack> *wonder
10:49:29 <magneticduck> we make a good team Iceland_jack =P
10:49:29 <linziyi> !
10:49:32 <Iceland_jack> heh
10:49:34 <Iceland_jack> indeed!
10:49:40 <magneticduck> answering questions 2* the speed BAM BAM BAM
10:49:42 <linziyi> I see it now
10:49:44 <Iceland_jack> linziyi: So a list in Haskell can have two forms and two forms only
10:50:14 <Iceland_jack> empty ([]) or nonempty (a:as) where ‘a’ is some element (head) and ‘as’ is the rest (tail) of the list
10:50:26 <linziyi> i see
10:50:37 <linziyi> so that's what the first line is for
10:50:40 <linziyi> thank you very much!
10:50:51 <linziyi> I am using http://learnyouahaskell.com/chapters to learn it
10:51:00 <Iceland_jack> > let a:as = "hello!" in a
10:51:01 <Iceland_jack> lambdabot down?
10:51:06 <lambdabot>   'h'
10:51:14 <Iceland_jack> right, just a bit of lag :)
10:51:15 <Iceland_jack> > let a:as = "hello!" in a
10:51:15 <Iceland_jack> > let a:as = "hello!" in as
10:51:16 <lambdabot>   'h'
10:51:18 <lambdabot>   "ello!"
10:51:24 <Iceland_jack> No problem linziyi, feel hesitate to ask!
10:51:42 <magneticduck> *don't hesitate
10:51:46 <linziyi> :|
10:51:47 <magneticduck> lol =P
10:51:49 <monochrom> feel free to ask when you feel free to ask :)
10:51:54 <magneticduck> feel free to not hesitate
10:52:11 <Iceland_jack> :D
10:52:11 <Iceland_jack> We do make a good team
10:52:22 <magneticduck> linziyi: stumped?
10:52:42 <magneticduck> > let (a:as) = 'h':'e':'l':'l':'o':[]
10:52:43 <lambdabot>   not an expression: `let (a:as) = 'h':'e':'l':'l':'o':[]'
10:52:45 <magneticduck> > let (a:as) = 'h':'e':'l':'l':'o':[] in a
10:52:46 <linziyi> wow!
10:52:47 <lambdabot>   'h'
10:52:49 <monochrom> complementary team members compliment each other :)
10:53:01 <Iceland_jack> > "hello" == 'h':'e':'l':'l':'o':[]
10:53:02 <lambdabot>   True
10:53:09 <linziyi> self refering function is just too powerful
10:53:14 <Iceland_jack> > [1,2,3] == 1:2:3:[]
10:53:15 <lambdabot>   True
10:53:19 <Eduard_Munteanu> How do you index a category? Arguably the hom-set would be indexed (so you can define an indexed (Co)Kleisli category for example).
10:53:20 <magneticduck> recursive data structures
10:53:24 <Eduard_Munteanu> Should I index objects too?
10:53:25 <linziyi> I get it now
10:53:28 <linziyi> thanks
10:53:28 <Iceland_jack> OK :)
10:53:50 <magneticduck> oh shit here's a guy with questions I can't answer, I'll just sulk off and work on my sound library
10:56:04 <magneticduck> well huh my keyboard is resonating
10:56:13 <dougdougdoug> magnticduck: I am looking for hehavior such that I can "lift" a function that operates on on Double->Double to FuzzySet  (which is dragging around the context, the (Double, Double) tuple.
10:56:27 <magneticduck> yes, that is the term
10:56:31 <monochrom> when you work on sound, your keyboard works on sound too
10:56:42 <roconnor> Eduard_Munteanu: don't you index a category the same way you index anything?  Consider functors from Set (or whatever) to it?
10:57:00 <Eduard_Munteanu> Is this reasonable? class CategoryG (hom :: ix -> ix -> (ix -> ob) -> (ix -> ob) -> *) where idG :: a i |~hom i i~> a i;    composeG :: (b j |~hom j k~> c k) -> (a i |~hom i j~> b j) -> (a i |~hom i k~> c k)    ?
10:57:05 <magneticduck> you'd say "liftFuzzySet :: (Double -> Double) -> (FuzzySet -> FuzzySet)"
10:57:18 <haasn> Your keyboard? That's nothing, my *mouse* makes ringing noises when I click it in the wrong way
10:57:36 <magneticduck> "liftFuzzySet f s = s {domain = (f $ domain s)}
10:58:06 <Eduard_Munteanu> roconnor: I could define them as functors from Hask, yeah, but I'm not sure how to express it as a functor on products of categories
10:58:06 <magneticduck> hehe
10:58:13 <haasn> luite: Does the ghcjs RTS implement lightweight forkIO?
10:58:21 <magneticduck> dougdougdoug: that should work
10:58:57 <Eduard_Munteanu> a |~cat~> b  is convenient notation for  cat a b
10:59:10 <haasn> for some meaning of ‘convenient’
10:59:25 <Eduard_Munteanu> haasn: looks nicer, harder to type, yeah :)
10:59:27 <BMeph> Is there a channel that spends time on the whole data/codata thing?
10:59:30 <dougdougdoug> magneticduck: and skip the Functors/Applicative functors altogether?
10:59:38 <BMeph> Besides, occasionally, this one? ;)
10:59:41 <Eduard_Munteanu> BMeph: #agda
10:59:46 <magneticduck> yeah, Functors and Applicative functors are useless for your context
11:00:05 <magneticduck> they require data with a kind of * -> *
11:00:07 <dougdougdoug> k thanks
11:00:14 <magneticduck> I see why you would think they would be useful
11:00:26 <magneticduck> but everything you want can be achived simply with "lift" functions, there's not really a better way
11:01:11 <haasn> lenses?
11:01:15 <dougdougdoug> ok, otherwise I could put in an unused type thingy (data FuzzySet z = …) if i needed other Applicative or Functor behavior.
11:02:53 <applic_tive> BMeph, on #agda, (->) and False arent codata, so it's a little confusing ;)
11:03:35 <roconnor> False doesn't seem like codata any more than True is.
11:03:44 <applic_tive> there's no similarity at all
11:03:55 <roconnor> between False and True?
11:04:06 <applic_tive> right
11:04:14 <beaky> http://codepad.org/pjQE4Hx8 is there a name for this function?
11:04:38 <roconnor> False and True are both data types with a finite number of 0-argument constructors.
11:04:47 <roconnor> they seem fairly similar.
11:04:48 <applic_tive> in cpl it was so, thats how i gained my feeble understanding; it is also implicitly so in the paper on copattern matching
11:05:01 <haasn> I see applic_tive has enjoyed his upgrade to GHC 7.8
11:05:06 <roconnor> cpl?
11:05:22 <applic_tive> where the codata/data distinction was introduced by hagino
11:05:35 <BMeph> Eduard_Munteanu, applic_tive: Hmm, I'll give it some thought. Not sure if I want to go wading into the Agda morass just yet, but thx! :)
11:05:42 <roconnor> applic_tive: and they say False is codata while True is data?
11:06:05 <applic_tive> what is put on the table as an empty type yes
11:06:15 <applic_tive> they also say records are codata and tuples data
11:06:31 <roconnor> applic_tive: ah
11:06:37 <applic_tive> which was interesting; I never before saw a theoretical position for the record concept
11:06:53 <roconnor> yes, records do seem like codata
11:07:10 <applic_tive> haskell is the only language with genuine records!
11:07:23 <applic_tive> ;)
11:07:27 <Eduard_Munteanu> roconnor: was the above reasonable at all? It pretty much indexes every object (given an index category / set), and arrows have their domains and codomains indexed, and indexes must match with objects.
11:07:33 <magneticduck> beaky: http://www.haskell.org/hoogle/?hoogle=String+-%3E+String+-%3E+String+-%3E+[String]
11:07:37 <magneticduck> learn to love hoogle =P
11:07:40 <roconnor> Though it seem like False should be data since it is the empty sum and True should be codata since it is the empty record.
11:07:52 <magneticduck> there doesn't seem to be any functions with that type on hackage
11:08:10 <linziyi> so I read this: There's also a thing called as patterns. Those are a handy way of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing. You do that by putting a name and an @ in front of a pattern. For instance, the pattern xs@(x:y:ys). This pattern will match exactly the same thing as x:y:ys but you can easily get the whole list via xs instead of repeating yourself
11:08:18 <roconnor> Eduard_Munteanu: I'm not in a position ATM to follow what you said.  Sorry.
11:08:27 <applic_tive> roconnor: yes, i cant say i totally get how to piece thoughts like those together
11:08:28 <linziyi> wouldn't xs = [x:y:ys] do the job?
11:08:34 <merijn> linziyi: No
11:08:37 <beaky> wow
11:08:39 <applic_tive> roconnor: or how they do, rather, in the copattern paper
11:08:39 <linziyi> :O
11:08:47 <joeyh> hmm, reallyUnsafePtrEquality# has changed in ghc head to return an Int not a Bool. I wonder if it's 0 on equality?
11:08:50 <Eduard_Munteanu> Ok, no problem.
11:09:00 <Iceland_jack> linziyi: [x:y:ys] matches a list of lists
11:09:03 <merijn> linziyi: "[x:y:ys]" matches a list that has a single 3 item list inside
11:09:09 <d3lxa> I'm using debian testing and Text.Read.readMaybe is not there, how can I identify the package which serve this module function? maybe upgrade it, all that?
11:09:22 <haasn> joeyh: it's so unsafe, even the type randomly changes!
11:09:32 <roconnor> applic_tive: yeah, I'm only at the intuitive level.  I reworked my lens-coalgebra proofs using records-as-codata and they read much more pleasently now.
11:09:33 <applic_tive> roconnor: there is a tradition of not worrying about False in martinism-lofism, but in earlier intuitionism it was a constant torment
11:09:39 <merijn> linziyi: "[x:y:ys]" = "[(x:y:ys)]" = "(x:y:ys) : []"
11:09:42 <geekosaur> also, even igf you do it right (xs = (x:y:ys)) you are making a *new* list
11:09:45 <Eduard_Munteanu> Stochastic type system? :P
11:09:55 <merijn> d3lxa: Text.Read.readMaybe is a new addition in ghc 7.6
11:09:58 <Eduard_Munteanu> Seems to be a good buzzword.
11:09:58 <geekosaur> not referencing the existing one
11:10:01 <applic_tive> roconnor: there was for example the negationless mathematics struggle
11:10:19 <roconnor> applic_tive: really?
11:10:24 <linziyi> i See
11:10:29 <geekosaur> (actually the parentheses are not necessary in that form)
11:10:36 <d3lxa> merijn: oh :( any fallback or do I need to go unstable?
11:10:38 <joeyh> well, unordered-containers seems to think it's a Bool anyway
11:10:50 <applic_tive> roconnor: its all antediluvian but google-scholar 'negationless mathematics brouwer' or something
11:10:52 <merijn> d3lxa: Well, you can just define it yourself using reads
11:10:57 <merijn> :t reads
11:10:58 <Iceland_jack> linziyi: Maybe you mean [a, b, c] which only matches a list of length 3
11:10:59 <lambdabot> Read a => ReadS a
11:11:13 <merijn> > reads "'c'" :: [(Char, String)]
11:11:15 <lambdabot>   [('c',"")]
11:11:20 <merijn> > reads "'c'" :: [(Bool, String)]
11:11:25 <roconnor> @wn antediluvian
11:11:27 <lambdabot>   []
11:11:29 <lambdabot> *** "antediluvian" wn "WordNet (r) 3.0 (2006)"
11:11:29 <lambdabot> antediluvian
11:11:29 <lambdabot>     adj 1: of or relating to the period before the biblical flood;
11:11:29 <lambdabot>            "antediluvian man" [syn: {antediluvian}, {antediluvial}]
11:11:29 <lambdabot>     2: so extremely old as seeming to belong to an earlier period;
11:11:31 <lambdabot> [5 @more lines]
11:11:46 * applic_tive take 2
11:12:05 <magneticduck> boy this channel is active right now. I can feel the pure haskell energy resonating!
11:12:15 <shachaf> There was silence supreme! Not a shriek, not a scream, / Scarcely even a howl or a groan, / As the man they called "Ho!" told his story of woe / In an antediluvian tone.
11:12:23 <merijn> d3lxa: Google should probably turn up an example of how to implement readMaybe using reads, it's just a simple pattern match that unpacks the result list or returns Nothing if the result of reads is empty list
11:12:35 <d3lxa> merijn: I'm dev'ing with 7.6 here but the server is on testing (which is not normally safe), don't know if I should install GHC 7.6 over there? =)
11:12:37 * applic_tive tries to imagine that tone
11:12:47 <applic_tive> @wn antebellum
11:12:48 <lambdabot> *** "antebellum" wn "WordNet (r) 3.0 (2006)"
11:12:48 <lambdabot> antebellum
11:12:48 <lambdabot>     adj 1: belonging to a period before a war especially the
11:12:48 <lambdabot>            American Civil War
11:12:58 <merijn> ...
11:12:59 <merijn> Wow
11:13:00 <d3lxa> merijn: thx, sorry for the sysadmin question, never mind
11:13:06 <merijn> That is horrifically US centred
11:13:14 <geekosaur> yep
11:13:19 <applic_tive> yes, but we needed a word I guess
11:13:33 <merijn> d3lxa: It depends what's easier, but anyway, implementing readMaybe is fortunately only like 2 lines
11:13:58 <d3lxa> merijn: I hope it's the only addition of GHC 7.6 I used :(
11:14:04 <BMeph> listMaybe . reads? ;)
11:14:04 <applic_tive> not long ago 'the war' meant something definite again; so it was in e.g. 1880 in the US
11:14:12 <monochrom> does data mean "specified by constructors", i.e., initial algebra? does codata mean "specified by selectors", i.e., final co-algebra?
11:14:21 <roconnor> applic_tive: I didn't realize tuples were data.  I presumed they were co-data since records were.
11:14:50 <applic_tive> monochrom: that's one way people try to explain it; but then they get clobbered of course
11:15:44 <applic_tive> roconnor: take data Stream a = Stream {head : a ; tail : Stream a}
11:15:51 <applic_tive> this shouldn't type check
11:15:54 <d3lxa> BMeph: seem it's listToMaybe, thx
11:16:03 <BMeph> roconnor, applic_tive: Wouldn't tuples be codata in ML?
11:16:03 <applic_tive> but codata Stream a ... should
11:16:23 <monochrom> when the planets align, some things are both data and codata. so I am not thrilled at strictly keeping a dichotomy, "x is data => x is not codata", things like that
11:16:27 <applic_tive> roconnor: the distinction only really shows itself in the recursive record/tuple
11:16:32 <applic_tive> or anyway thats one way
11:16:33 <roconnor> applic_tive: of course.
11:16:44 <BMeph> d3lxa: Glad I got one right; now I'll have to wait for next week... ;)
11:16:53 <dougdougdoug> @pl liftFuzzySet f s = FuzzySet (f $ shape s) (domain s)
11:16:56 <lambdabot> liftFuzzySet = fix (const (flip ap domain . (FuzzySet .) . (. shape) . ($)))
11:16:56 <lambdabot> optimization suspended, use @pl-resume to continue.
11:17:31 <Peaker> optparse-applicative has "helper" that adds --help support, but in the usage, --help doesn't appear :(
11:17:48 <d3lxa> BMeph: but it's not the whole story, it should be: fmap fst . listToMaybe . reads
11:18:35 <BMeph> d3lxa: <nods> Mmm, right; good catch. :)
11:18:39 <d3lxa> BMeph: btw there is the source here http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Read.html#readMaybe
11:19:02 <applic_tive> monochrom: whether you specify a connective by the elimination or introduction rules is irrelevant really; since either can be inferred from the other once someone specifies 'data' or 'codata'
11:19:24 <applic_tive> monochrom: thus in haskell we say Stream a = Cons a (Stream a) and all is clear
11:19:46 <dougdougdoug> @pl FuzzySet  (f (shape sa) (shape sb)) (domain sa)
11:19:46 <lambdabot> FuzzySet (f (shape sa) (shape sb)) (domain sa)
11:20:24 <joelteon> ReinH: how do you get haskellmode-vim to indent properly?
11:21:43 <applic_tive> monochrom: but in a language like cpl, the way you specify it is the choice of using the introduction rules or the elimination rules.
11:22:47 <roconnor> applic_tive: I'll give you an example where I use copatterns to define duplicate for the store comonad:
11:22:55 <roconnor> pos (duplicate x) = pos x
11:22:56 <roconnor> pos (peek (duplicate x) i) = i
11:22:58 <roconnor> peek (peek (duplicate x) i) j = peek x j
11:23:15 <roconnor> This definition feels much easier to work with in practice IMHO.
11:24:15 <roconnor> than duplicate (Store h i) = Store (Store h) i
11:25:23 <applic_tive> or it fits with underling idea better, you mean?
11:25:41 <shachaf> quchen: No, but it involved roconnor.
11:26:09 <shachaf> quchen: In Core, you can force any expression with case, unlike Haskell. Maybe that's what you're after.
11:26:12 <roconnor> applic_tive: Well, when doing proofs I often doing manipulations of the terms that look like (peek (peek (duplicate x) i) j)
11:26:28 <roconnor> applic_tive: from the copattern match it is easy to read off the simplication of that.
11:26:52 <elliott> joeyh: I don't think it ever returned a Bool?
11:26:58 <quchen> shachaf: Ah, that clarifies what parcs meant with his "unfold as case" comment in #ghc, thanks.
11:27:50 <shachaf> case x of _ { DEFAULT -> ... } forces x.
11:28:02 <shachaf> See the GHC commentary on Core.
11:28:17 <byorgey> dfan: cool, looking forward to seeing you at FARM =)
11:28:22 <roconnor> shachaf: is that the definition of seq?
11:28:29 <applic_tive> roconnor: oh i see
11:28:30 <joelteon> is anybody here good with haskellmode-vim?
11:28:32 <quchen> Time to venture in Core land again then. Didn't even know about DEFAULT.
11:28:32 <joelteon> i need to pick your brain
11:28:56 <shachaf> roconnor: I don't know. Probably not.
11:29:06 <shachaf> But it's how you force something in Core.
11:30:10 <elliott> quchen: DEFAULT is just like _ in Haskell
11:30:29 <roconnor> applic_tive: I think the point is that I often do (peek (peek (duplicate (some_store_expression)) i) j) and rarely if ever have the expression (duplicate (Store expr1 expr)).
11:30:30 <shachaf> Similar to _.
11:31:03 <roconnor> applic_tive: Still i'm not sure if this is objective or subjective.
11:31:47 <roconnor> applic_tive: I guess I can, and used to eta-expand (some_store_expression) and then simplify.
11:32:19 <roconnor> applic_tive: I should actually go back to my old proofs and see if there is and objective improvement in quality that I can demonstrate.
11:32:22 <roconnor> and blog about it.
11:33:15 <applic_tive> that would be interesting, yes
11:34:32 <roconnor> applic_tive: do you have a link to this cpl paper?
11:34:50 <joelteon> is there any way to make haskellmode-vim respect hs-source-dirs
11:36:03 <magneticduck> hey guyyys I have a problem -- audicatiy plays my audio files fine but mplayer plays them with audio clicks
11:36:27 <elliott> ...
11:36:39 <applic_tive> roconnor: http://scholar.google.com/scholar?cluster=14624588388488318207&hl=en&as_sdt=0,39 but there's another
11:36:41 <joeyh> elliott: seems that the real problem is that my ghc thinks that 1# ==# 1# has type boxed int, not bool
11:36:46 <joeyh> (this is a ghc head build)
11:37:06 <magneticduck> anybody know any good channels servers for technical sonic discussion? =P
11:37:19 <joeyh> er, unboxed int obviously
11:40:35 <applic_tive> roconnor: this was in a way more awesome, in my memory, but it's behind a wall http://www.sciencedirect.com/science/article/pii/S0747717189800653
11:40:58 <BMeph> Just as a curiosity, but would anyone be interested in a "commonPrefixes" function in .List.Split, hopefully with a better name, if someone (else) could think of one?
11:41:11 <BMeph> Assuming that it isn't already in it?
11:43:47 <enthropy> what should it do?
11:44:28 <bennofs> @let commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b
11:44:29 <lambdabot>  .L.hs:142:1: Warning:
11:44:29 <lambdabot>      Pattern match(es) are overlapped
11:44:29 <lambdabot>      In an equat...
11:44:32 <bennofs> @undef
11:44:32 <lambdabot> Undefined.
11:44:33 <bennofs> @let commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b
11:44:34 <lambdabot>  Defined.
11:44:38 <FreeFull> I assume something like  commonPrefixes ["Meoo","Meow","Mein"] == "Me"
11:45:00 <applic_tive> roconnor: oh yeah the 'codata types in ml' paper -- now almost 25 yrs old -- is one of the awesome ones. the type theorists made sure to get rid of him
11:45:26 <bennofs> > foldl1 commonPrefix ["Meoo", "Meow", "Mein"]
11:45:30 <lambdabot>   "Me"
11:46:00 <FreeFull> bennofs: I think  foldl commonPrefix []   would be good
11:46:17 <FreeFull> Actually, maybe not
11:46:33 <bennofs> It's not :p
11:46:37 <FreeFull> > foldl commonPrefix [] ["Meoo", "Meow", "Mein"]
11:46:41 <lambdabot>   ""
11:46:53 <roconnor> applic_tive: you sound a little resentful.  I've never seen any hostility towards the idea of codata. ... just difficulty in implementing it.
11:46:53 <FreeFull> Yeah, you'd have to pattern match for the [] case
11:48:16 <BMeph> Hmm, okay, what I'd rather have is more like a "stripCommonPrefix" than the "commonPrefix" one. Does that sound interesting? :)
11:49:53 <shachaf> I usually prefer to view seq as a compiler hint rather than an actual function, semi-operationally.
11:49:58 <shachaf> Well, more than a hint.
11:51:25 <BMeph> where "stripCP xs ys = (,) <$> stripPrefix cp xs <*> stripPrefix cp ys; cp = commonPrefix xs ys"
11:51:54 <roconnor> shachaf: is that comment for me?
11:52:08 <FreeFull> BMeph: Maybe it'd be better to take and return a list
11:52:43 <shachaf> roconnor: No, quchen/thoughtpolice/whoever.
11:52:54 <shachaf> I know that you're above operational concerns. :-)
11:52:55 <BMeph> shachaf: Not so much a _hint_, as a compiler-understandable wink-and-a-nudge? (say no more, say no more) :)
11:53:30 <Fuuzetsu> and some money changing hands
11:54:04 <BMeph> FreeFull: "take and return a list" for which?
11:56:10 <roconnor> shachaf: I've been trying to find the source of the conversation you hare having with quchen but I have failed.
11:56:35 <quchen> roconnor: It was in #ghc.
11:56:52 <FreeFull> BMeph: stripCP
11:57:10 <quchen> I was wondering how the difference between "f" and "\x → f x" comes about in GHC, basically.
11:57:25 <roconnor> oh man
11:57:36 <roconnor> Are there #ghc logs?
11:57:48 <shachaf> It wasn't much of a conversation.
11:57:50 <FreeFull> quchen: Lambda is a constructor
11:58:14 <quchen> roconnor: For what it's worth, here's a paste. http://lpaste.net/5744612457406529536
11:58:59 <FreeFull> quchen: It's the same how there is a difference between using $ and brackets (Although GHC has a hack to get rid of the difference)
11:59:08 <shachaf> Pasting unlogged channels. :-(
11:59:23 <quchen> I meant "here's a mental transcript".
11:59:51 * shachaf sighs.
12:00:09 <roconnor> quchen: okay you can delete it now if it makes shachaf more comfortable.
12:01:17 <roconnor> quchen: the arguments about why (const _|_) and _|_ are distinct seem circular.
12:01:50 <roconnor> quchen: (const _|_) and _|_ are distinct because seq disinguishes them.  Seq distiguishes them because (const _|_) and _|_ are distinct.
12:02:19 <elliott> roconnor: well, demonstrating a function f such that f x =/= f y is enough to prove x =/= y...
12:02:27 <elliott> f g = g `seq` ()
12:02:40 <elliott> f _|_ = _|_, f (const _|_) = (), () =/= _|_, therefore _|_ =/= const _|_?
12:02:46 <roconnor> elliott: that's one half of the circular arugment. :)
12:03:18 <elliott> roconnor: saying _|_ and () are different is a circular argument too then, because you can prove it in the same way? :p
12:03:30 <roconnor> elliott: why is  f (const _|_) = () ?
12:03:50 <shachaf> I think roconnor's point is about seq distinguishing _|_ and const _|_.
12:04:13 <FreeFull> roconnor: Because lambda is a constructor, and seq stops at the outermost constructor
12:04:23 <elliott> I am proving things about what is true, not about what they should be.
12:04:27 <roconnor> FreeFull: that's not what the Haskell report says.
12:04:34 <elliott> we know f (const _|_) = () because we have an f-evaluating oracle :p
12:04:59 <FreeFull> > let f x = x `seq` () in f (const undefined)
12:05:00 <lambdabot>   ()
12:05:18 <roconnor> elliott: your reasoning is that f (const _|_)  = (const _|_) `seq` ()  and  (const _|_) `seq` () = ().
12:05:34 <Peaker> Laziness/thunks appearing in the types, with explicit "force" and a special form for "suspend" (putting call-by-name into a thunk) instead of "seq" horrors might free up the optimizer to do more interesting optimizations.. seq is terrible :(
12:05:36 <roconnor> but that second set is only valid under the assumtion that (const _|_) = _|_
12:05:43 <roconnor> which is the fact that you were trying to prove to me.
12:05:50 <roconnor> That is why the argument is circular.
12:05:54 <roconnor> er
12:06:02 <roconnor> that second set is only valid under the assumtion that (const _|_) =/\ _|_
12:06:06 <roconnor> that second set is only valid under the assumtion that (const _|_) =/= _|_
12:06:13 <roconnor> (bah, keyboards)
12:06:17 <elliott> roconnor: but I have a seq-evaluating oracle called GHCi.
12:06:23 <elliott> it proves things about the result of seq for me.
12:06:29 <FreeFull> For me, const _|_ isnt _|_ for the same reason _|_ :[]  isn't _|_
12:06:52 <FreeFull> > let f x = x `seq` () in f (undefined:[])
12:06:53 <lambdabot>   ()
12:06:55 <roconnor> elliott: or it proves that GHC is broken.  Or the Haskell standard is ambigous.
12:07:23 <Peaker> FreeFull: (const _|_) has no discernable information whereas (:) has?
12:08:02 <Peaker> When I wonder why GHC was too dumb to perform some pretty useful optimization, the answer is usually "because of lifted bottoms and seq", bah
12:09:08 <applic_tive> the variant augussts described does whichever of those optimizations it pleases, Peaker, and then blames you when things go wrong
12:09:11 <Peaker> I am in the minority opinion, perhaps, that some UB in some cases is justified, and that C and C++ may have too much of it, but UB definitely helps the compilers generate faster code. Maybe some UB around _|_ in Haskell could be helpful for optimization
12:09:13 <applic_tive> which might not be so bad
12:09:19 <roconnor> FreeFull: I'm fairly comfortable with lifted product spaces, hence the distinction between _|_ and _|_:[].
12:09:28 <Peaker> applic_tive: it sounds good!
12:09:31 <roconnor> FreeFull: I'm less comfortable with lifted function spaces.
12:09:58 <Peaker> roconnor: But _|_ vs _|_:[]  is a lifted sum, not a lifted product, iiuc?
12:10:13 <roconnor> Peaker: I guess it is both.
12:10:20 <Peaker> _|_ vs (_|_, _|_) is lifted product, and I hate this
12:10:43 <applic_tive> _|_ : _|_ at least knows it's not []
12:10:44 <roconnor> Peaker: Right.
12:10:47 <Peaker> would be so nice to know that pattern-matching products is a no-op, that (a, (b, c)) is isomorphic to (a, b, c)
12:10:50 <FreeFull> const _|_ has the type a -> b, _|_ has the type a (which does unify with a -> b)
12:11:10 <roconnor> FreeFull: I'm talking about _|_ :: a -> b.
12:11:30 <Peaker> but we can't have nice things because people want to "seq" polymorphic function results to force the function to do its work, which is problematic if it happens to return a product. To which I reply, seq'ing a result to force evaluation is probably a bad idea!
12:11:50 <roconnor> FreeFull: in fact I'm talking about _|_ :: A -> B.
12:12:03 <Peaker> that's a good argument to having explicit Thunk types. That way, we can have explicitly lifted products:  Thunk (a,b,c)
12:12:05 <markamber>  
12:12:30 <applic_tive> roconnor: you're talking about _|_ :: () -> ()
12:12:41 <chrisdone> Peaker: like in Idris? =]
12:12:51 <Peaker> chrisdone: Probably, I haven't done much Idris :)
12:12:58 <dolio> Like in Scala.
12:13:00 <dolio> Which sucks.
12:13:05 <chrisdone> me neither, but i know it has lazy types
12:13:14 <FreeFull> roconnor: What about partial functions? Bottom for some arguments and not for others.
12:13:26 <roconnor> applic_tive: that type is probably sufficent to address my concerns.
12:13:29 <chrisdone> foo :: a -> |b -> c to mean "b is lazy"
12:13:33 <beaky> I love haskell
12:13:39 <beaky> haskell has taught me how to program
12:13:51 <Peaker> chrisdone: this kind of approach is probably going to work better in an IDE that can hide the Thunks/forcings syntax when you don't care about evaluation order, and show them when you do
12:14:18 <roconnor> FreeFull: what about partial functions?  I have no problem with them (for the purposes of this discussion).
12:14:20 <fizruk> beaky: haskell is still teaching me)
12:15:07 <roconnor> Peaker: I'm a little worried that function programming is just a bad way to program...
12:15:21 <Peaker> roconnor: what do you mean?
12:15:22 <FreeFull> roconnor: What's the difference between const _|_ and a partial function that's bottom for all inputs?
12:16:13 <chrisdone> roconnor: as opposed to e.g. stacks?
12:16:20 <roconnor> Peaker: My concern largely stems from the fact that two beta-equivalen lambda terms can have vastly differenent complexity when executed by lazy evaluation.
12:16:44 <roconnor> chrisdone: as opposed to some imperitive nonsense.
12:16:49 <chrisdone> gotcha
12:17:01 <beaky> I love imperative nonsense
12:17:18 <roconnor> FreeFull: there is no difference.
12:17:19 <beaky> all my textbooks think the only way to program is imperative nonsense
12:17:28 <Peaker> roconnor: imperative programs can be equivalent in terms of their effect, and have vastly differing algorithms too?
12:17:29 <beaky> (all except for a couple)
12:17:47 <chrisdone> i see what you mean
12:18:05 <roconnor> Peaker: yes but no one claims thos vasty different algorithms are beta-equivalent.
12:18:05 * hackagebot extractelf 0.1.0.0 - Extract an ELF's metadata and sections into files  http://hackage.haskell.org/package/extractelf-0.1.0.0 (EyalLotem)
12:18:07 <FreeFull> roconnor: Would you expect  seq head x   to be _|_ because head is partial?
12:18:28 <Peaker> roconnor: so the problem is with beta equivalence, specifically?
12:18:32 <chrisdone> (\x.f x) may or may not evaluate x depending on whether 'f' is strict or not, but are beta equivalent
12:18:38 <roconnor> FreeFull: head is not the same as (const _|_).
12:18:46 <FreeFull> True
12:18:50 <roconnor> Peaker: It might be.
12:19:10 <FreeFull> Rather than  a -> b   you need   Something Specific -> b   if you want a partial function that is only partial for some inputs
12:19:37 <dolio> roconnor: Just switch to call-by-name. Problem solved.
12:19:56 <Peaker> beta equivalence can be useful for proofs, or to prove correctness of a runtime definition, even if it doesn't guarantee the usefulness of applying the actual function in runtime
12:19:58 <Eduard_Munteanu> Can non-associated type families instance declarations have contexts, possibly including explicit foralls?
12:20:02 <chrisdone> roconnor: i suppose the problem specficially exists in the present of non-termination?
12:20:12 <roconnor> dolio: I'm fairly certain that makes the problem worse :D
12:20:25 <Peaker> chrisdone: he mentioned different complexities, basically differing algorithms to implement the same function
12:20:26 <dolio> roconnor: No. Beta doesn't change performance then.
12:20:29 <dolio> It's just always terrible.
12:20:33 <applic_tive> hah
12:20:42 <chrisdone> lol
12:20:52 <Peaker> but I'm not sure I know exactly what beta-equivalence is -- I am only guessing/speculating :)
12:21:28 <quchen> beta = (b)ackwards eta? :-)
12:21:45 <chrisdone> two expressions are β-equivalent, if they can be β-converted into the same expression
12:21:49 <roconnor> Peaker: beta-equivalence is the transitive-symetric closure of beta-reduction.
12:22:08 <chrisdone> roconnor: in english?
12:22:09 <roconnor> Peaker: and is equialent to what chrisdone said by Church-Rosser.
12:22:42 <luite> haasn: yes
12:22:48 <twanvl> roconnor: also reflexive-
12:22:58 <roconnor> twanvl: right.
12:23:18 <roconnor> twanvl: and also that thing than lets you beta-reduce sub-expressions.
12:23:26 <roconnor> congruent
12:23:46 <roconnor> beta-equivalence is the reflexive-symetric-transitive-congruence closure of beta-reduction.
12:24:15 <roconnor> But lets just say "they can be β-converted into the same expression".
12:24:54 <chrisdone> =p
12:25:09 <haasn> edwardk: Thoughts on this combinator? http://lpaste.net/93230
12:25:30 <shachaf> haasn: What makes it a combinator rather than just a function or a value or something?
12:25:40 <haasn> shachaf: it combines lenses!
12:26:34 <haasn> (or folds, rather)
12:29:27 <shiona> It blows my mind. well, I guesss lenses do that
12:29:45 <bennofs> haasn: I think that combinator is just (<>) with a monoid instance for Accessor?
12:30:39 <haasn> bennofs: you're right! mconcat it is
12:30:55 <haasn> No wonder it doesn't exist :)
12:32:11 <luite> haasn: though there's also an rts that doesn't have it, and you get a bit smaller code in return, but that's currently extremely out of date, i started working on a new one based on the new code generator, but keep letting it fall behind as other things are more important right now
12:32:21 <Shin-LaC> which is faster between IntMap and HashMap (from unordered collections)?
12:32:56 <roconnor> FreeFull: like applic_tive said, we can just talk about () -> () if you want.
12:32:58 <shachaf> haasn: See https://github.com/ekmett/lens/pull/311
12:34:41 <haasn> bennofs: my ‘foo’ seems to be more general than ‘mconcat’, though
12:35:05 <haasn> in particular, the latter doesn't type check when used in place of ‘foo’ inside fizzBuzz
12:36:08 <haasn> () ^.. mempty `failing` id -- type error
12:36:18 <haasn> () ^.. foo [] `failing` id -- returns [()]
12:36:38 <dougdougdoug> @pl hedgeVery a = a*a
12:36:38 <lambdabot> hedgeVery = join (*)
12:36:45 <dougdougdoug> @pl hedgeVery a = a*a*a
12:36:46 <shachaf> haasn: Type error or just ambiguity?
12:36:46 <lambdabot> hedgeVery = (*) =<< join (*)
12:36:56 <roconnor> haasn: give the type system a little help there.
12:37:03 <dougdougdoug> @pl hedgeVery a = a*a*a*a
12:37:04 <lambdabot> hedgeVery = (*) =<< (*) =<< join (*)
12:37:35 <roconnor> haasn: () ^.. (mempty `asTypeOf` foo []) `failing` id
12:37:37 <applic_tive> that's a surprisingly handsome @pl report
12:38:37 <haasn> roconnor: no dice, I get a ‘No instance for (Monoid (BazaarT (->) (Accessor (Endo [()])) () () ()))'
12:38:40 <haasn> or something like that
12:38:52 <applic_tive> @pl  hedgeVery a = a*a*(a*a)
12:38:52 <lambdabot> hedgeVery = ap ((*) . join (*)) (join (*))
12:38:55 <haasn> I tried (mempty :: Fold s a) vs. (foo [] :: Fold s a) also
12:39:12 <applic_tive> dougdougdoug: there ^^^ perfectly hideous ;)
12:39:41 <dougdougdoug> applic_tive: :)
12:40:38 <haasn> in fact, ‘mempty :: Fold s a’ doesn't type-check; ‘foo [] :: Fold s a’ does
12:40:42 <dougdougdoug> @pl (a*a)*(a*a)
12:40:42 <lambdabot> a * a * a * a
12:40:46 <dougdougdoug> nice
12:40:55 <dougdougdoug> @h a = pl (a*a)*(a*a)
12:40:56 <lambdabot> Maybe you meant: hackage haskellers help hitchcock hoogle hoogle+ v @ ? .
12:41:06 <haasn> dougdougdoug: (^4)
12:41:09 <dougdougdoug> @pl h a =  (a*a)*(a*a)
12:41:09 <lambdabot> h = ap ((*) . join (*)) (join (*))
12:41:21 <dougdougdoug> @pl h a =  a^4
12:41:24 <lambdabot> h = id (fix (const (^ 4)))
12:41:24 <lambdabot> optimization suspended, use @pl-resume to continue.
12:41:37 <haasn> uhm
12:41:45 <applic_tive> @type join (join (*))
12:41:45 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
12:41:46 <lambdabot>     Expected type: a1 -> a1 -> a1 -> a0
12:41:46 <lambdabot>       Actual type: a1 -> a1 -> a1
12:41:52 <applic_tive> oh of course
12:41:58 <applic_tive> pardonnez moi
12:42:10 <dolio> Wow.
12:42:32 <dougdougdoug> i think for small integer powers  its preferable to use multiplication.  I like to see what I can learn from @pl though.
12:42:35 <shachaf> Yes, @pl is broken.
12:42:44 <roconnor> Is beta-equivalence undecidable in the STLC with fixpoints (aka PCF)?
12:43:06 * hackagebot modulo 1.5 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.5 (HansHoglund)
12:43:11 <pavonia> @help hitchcock
12:43:11 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
12:43:46 <dolio> Is PCF Turing complete?
12:44:04 <roconnor> dolio: yes.
12:44:10 <dolio> Then probably.
12:45:23 <dolio> Rice's theorem, or something.
12:45:32 <Eduard_Munteanu> By chance, do implicit type-level parameters work?
12:46:08 <roconnor> dolio: so this is why (const _|_) cannot be equal to _|_?  Because otherwise seq would be uncomputable (despite beint continous? and monotone?)
12:46:41 <Eduard_Munteanu> Like  data Foo :: (?Something :: *) -> ... where
12:46:47 <Eduard_Munteanu> (that doesn't work)
12:46:53 <roconnor> *being
12:47:45 <dolio> There is nothing seq could do to reliably detect const _|_.
12:47:49 <dolio> If that's the issue.
12:48:47 <roconnor> dolio: seq only needs to semi-decide (const _|_) ... possibly even less.
12:49:16 <int-e> @unpl join (*) . join (*)
12:49:16 <lambdabot> (\ c -> ((*) >>= \ d -> d) (((*) >>= \ f -> f) c))
12:49:47 <NemesisD> how can i make the main thread sleep forever? i think i tried having it wait on an mvar that never gets written but i'm pretty sure that errored out
12:50:17 <NemesisD> i'm writing a test that sends signals to a process so they need to only terminate when they receive those signals
12:50:29 <dolio> It needs to determine whether an arbitrary expression is equivalent to const _|_ or whether there is at least one input for which it is more defined.
12:51:18 <dolio> I don't think I believe that is monotone and continuous.
12:51:32 <roconnor> dolio: what?!
12:51:59 <roconnor> dolio: surely it is monotone.
12:52:16 <roconnor> and I don't see why it wouldn't be continuous.
12:53:11 <dolio> I expect it isn't continuous.
12:53:25 <dolio> And your incredulity isn't sufficient proof. :)
12:53:51 <roconnor> dolio: I admit it is the weaker part of my argument.
12:59:44 <dolio> roconnor: Actually, you may be correct.
12:59:54 <dolio> Except the algorithm for seq is so shitty you would never want to use it.
13:00:04 <roconnor> dolio: I want to use it!!
13:00:14 <dolio> Because it's: enumerate all elements of the domain, and test if they are bottom.
13:00:36 <roconnor> dolio: What if the domain is uncountable?
13:00:37 <dolio> If you find one, you are non-bottom. If you don't,  you never terminate, so the input was bottom.
13:00:38 <int-e> which you do by interleaving all those computations. ouch.
13:01:04 <dolio> But non-termination in that case is okay.
13:01:16 <NemesisD> hmm in otherwords: how do i get around a thread blocked indefinitely on mvar error. i want to block indefinitely
13:01:54 <roconnor> dolio: What if the domain is uncountable?
13:02:13 <dolio> It isn't.
13:02:22 <dolio> Enumerate the Haskell programs with the right type.
13:02:23 <roconnor> dolio: by some input is non-bottom I mean some input in the domain-theory, not some lambda-term.
13:02:26 <dolio> And evaluate them.
13:03:09 <roconnor> dolio: I'm not a Russian constructivist.  If some non-recursive input is non-bottom, I still want my seq to succeed.
13:03:43 <roconnor> dolio: that said, I wouldn't be surprised if the answer is the same.
13:03:55 <roconnor> by some continuity argument.
13:04:15 <elliott> dolio: that's a beautiful algorithm.
13:04:36 <dolio> It would stop people from using seq on functions, at least.
13:04:55 <int-e> ... ouch :)
13:05:00 <ubikation> hey how do I find how much ram is there/available?
13:05:15 <ubikation> I've been writing a parser to 'free' but it doesn't seem to be the best idea...
13:05:31 <dolio> roconnor: Anyhow, this isn't something you can write in the language anyway.
13:05:32 <roconnor> ubikation: cat /proc/meminfo
13:05:34 <dolio> It has to be built in.
13:05:53 <roconnor> dolio: yes, seq would be a built-in.
13:06:09 <int-e> NemesisD: I'd probably go with  forever (threadDelay 1000000000)
13:06:23 <dolio> Also, it doesn't work for '\n -> if n == 0 then sum [1..] else 1'
13:06:33 <dolio> Because you can't detect that _|_.
13:06:38 <roconnor> int-e: I think conal ended up doing that. :(
13:07:04 <ubikation> I am using (_, Just hout, _, _) <- P.createProcess (P.proc "cat" ["/proc/meminfo"]){ P.std_out = P.CreatePipe }
13:07:05 <roconnor> dolio: I don't see the problem.
13:07:17 <paragbaji> According to you what is the path one should make towards making a career in Computer Security?
13:07:21 <ubikation> but it's still going to stdout when I am executing it via runhaskell
13:07:28 <roconnor> dolio: you just dovetail all inputs.
13:07:44 <roconnor> "just"
13:08:09 <dolio> Oh. I guess.
13:08:12 <ReinH> hai
13:08:22 <dolio> So it's even slower.
13:08:41 <paragbaji> Errr... excuse me people
13:08:42 <roconnor> good. >:-|
13:08:43 <paragbaji> According to you what is the path one should make towards making a career in Computer Security?
13:08:53 <dolio> Send a patch to GHC HQ.
13:09:28 <Earnestly> GCHQ?
13:09:29 <roconnor> dolio: I'm still not entirely satified with your solution wrt uncountable domains.
13:09:50 <dolio> I don't care about your domains. :)
13:09:55 <Maior> Earnestly: iswydt :P
13:10:25 <roconnor> dolio: though perhaps the bottom of the domain lattice is always countable.
13:11:26 <dolio> If you care about domains, I don't know why you would accept an algorithm at all.
13:13:21 <dolio> Wouldn't  you just ask if the alleged seq function is continuous and monotone?
13:13:25 <roconnor> dolio: why would you say that?  If you give me an algorithm that means seq is monotone and continuous.
13:13:27 <dolio> And if the answer is yes,  you're done?
13:13:34 <Peaker> why is findSubstrings in Data.ByteString.Char8, and why is it deprecated in favor of breakSubstring (which seems like a lower-level interface you might want to use)?
13:15:05 <roconnor> dolio: the Haskell report gives the semantics of seq wrt to some sort of domain theory.  I'm trying to reverse engineer possible solutions.
13:15:42 <dolio> Where are the uncountable domains in the Haskell report?
13:16:21 <roconnor> dolio: [()] -> Bool
13:16:30 <roconnor> dolio: [()] -> [()]
13:17:20 <roconnor> dolio: I think the domains for these types are implicity uncountable domains;  Can we make sense of the Haskell report otherwise?
13:18:19 <roconnor> dolio: I mean the intepretation of -> is a bit up in the air, but I've need no proposals that would entail a domain that isn't uncountable.
13:18:35 <int-e> roconnor: continuous functions
13:18:47 <roconnor> dolio: the questions are about is -> lifted?  Is the codomain always lifted first?  etc.
13:19:06 <int-e> ah. all of them would be uncountable, but take the computable ones ...
13:19:14 <roconnor> int-e: yes, continious, montone, (sometime strict) function.
13:19:53 <roconnor> int-e: then the question is what is ([()] -> Bool) -> Bool?
13:20:18 <dolio> http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
13:20:24 <roconnor> int-e: does that domain only operate on computable inputs?  That would be a fairly unusual interpretation of that type.
13:21:27 <int-e> roconnor: it's a very practical one if you ask me.
13:22:50 <roconnor> int-e: I don't think so.  I'm not an expert, but it seems like restricting the domain to computable functions would completely destroy the natural topolgy of ([()] -> Bool) -> Bool
13:23:10 <roconnor> It wouldn't be even obvious to me that ([()] -> Bool) -> Bool would remain countable.
13:24:15 <roconnor> int-e: I mean, maybe you can make sense of it. I've never seen anyone try.
13:25:00 <Saizan> doesn't the escardo seemingly impossible search rely on the computable assumption? or only continuity?
13:25:27 <roconnor> Saizan: AFAIU it only relies on continuity (and totality).
13:25:36 <dolio> My point is more: check the topology if you want to know if it works for whatever uncomputable domains you care about.
13:25:42 <dolio> Er, uncountable.
13:25:53 <roconnor> dolio: I intend to.
13:26:09 <roconnor> ... I was hoping I could get you check for me. :P
13:26:12 <dolio> My algorithm works as a realization for whatever elements of the domain actually matter: the ones that are in the image of the semantic function of Haskell programs.
13:26:23 <Saizan> roconnor: mh, i guess you don't need to be computable to have modulus of continuity
13:26:50 <Saizan> *a modulus
13:27:15 <roconnor> Saizan: ... I actually don't know.  I suspect there are non-comptuable continuous monotone functions, say in the Cator Space or at least the Baire Space.
13:27:26 <int-e> hmm, having seq recognize const _|_ is not quite the same as defining const _|_ = _|_, is it? what about const (const _|_)  `seq` b ?
13:27:32 <roconnor> well I guess it is actually obvious
13:27:47 <roconnor> since every total function from Nat -> Bool is continous.
13:27:53 <dolio> const (const _|_) just nests the algorithm, so it's really slow.
13:27:55 <roconnor> and they are not all computable.
13:28:29 <dolio> I guess, it's always slow for _|_.
13:28:45 <dolio> Since it runs forever, using infinite amounts of parallel processing.
13:28:59 <Saizan> roconnor: yeah, an halting oracle is continuous :)
13:29:03 <dolio> If your domain is infinite, at least.
13:29:42 <int-e> newtype T = T (T -> T); let f = T . const f in f `seq` b
13:30:23 <int-e> so what should this be?
13:30:40 <cschneid> I am attempting to write a haskell implementation of the resque model of background workers (resque is a ruby library to enable background workers like in rails. It pushes to redis a json blob, which is picked up by workers).
13:30:50 <roconnor> int-e: it *should* be _|_.
13:30:58 <cschneid> how would I go about defining an application / library to handle the infrastructure, and then allow the user to plug in their own handler code easily.
13:31:00 <dolio> roconnor: Anyhow, I think you're on the wrong track.
13:31:08 <Saizan> the question is more if there are continuous total functions (Nat -> Bool) -> Bool that look at infinite positions of the input stream
13:31:21 <dolio> _|_ /= const _|_ not because of some theoretical underpinnings, but because it's easy and fast to implement.
13:31:51 <dolio> So unless you can demonstrate that that is unsound, you can't just complain that it's circular.
13:32:47 <roconnor> dolio: "_|_ /= const _|_  because it's easy and fast to implement" is not a circular argument.
13:33:05 <roconnor> dolio: "_|_ /= const _|_  because seq distinguishes them" is the circular argument.
13:33:29 <dolio> seq distinguishes them because it's easy and fast to implement.
13:34:07 <roconnor> dolio: I think it would be insightful to observe that (_|_ /= const _|_) is an implementation choice, if that is indeed the case.
13:35:12 <dolio> It seems obvious to me.
13:35:16 <dolio> :)
13:36:00 <roconnor> dolio: When I read the Haskell report it sounds like (_|_ /= const _|_) is a necessary consequence of the existance of seq.
13:36:36 <danilo2> Hello! :) Is there any library, which will convert a DataType instance to a tuple of its field names and values? for example: data X {x::Int, y::String}; x= X 5 "test"; y = convert x; and y should be (("x",5), ("y", "test")). I know it is doable using generics, but maybe somebody has implemented it lready?
13:37:03 <int-e> dolio: But how would you hadle that newtype T = T (T -> T); let f = T . const f in f `seq` b example? you can enumerate all the arguments, but then you have to check whether the result - which is again f - is bottom. How do you break the loop?
13:37:42 <roconnor> dolio: And we GHC changed to my horrible definition of seq, we could add eta-contraction as a safe optimization and make asymtontic improvements in code that uses newTypes.
13:37:57 <dolio> int-e: f is bottom, isn't it? So it will spin forever, correctly.
13:37:58 <int-e> (well, the result is T f, but T f is bottom iff f is.)
13:38:10 <int-e> dolio: oh.
13:38:12 <int-e> dolio: right.
13:38:13 <elliott> roconnor: I would pay money to see you argue for that.
13:38:41 <roconnor> elliott: well, I'd like to first be sure that the horrible seq algorithm actually works.
13:38:42 <dolio> roconnor: I'm not sure if you can add it to polymorphic seq.
13:38:59 <dolio> You'd need a type class. And at that point, why not get rid of seq on functions?
13:39:52 <roconnor> dolio: do Scott domains handle polymorphic types?
13:39:56 <dolio> Or is that terrible algorithm actuall useful if, say, the function is immediately non-bottom?
13:40:20 <roconnor> heh, maybe the horrible algorithm works well in practice. :D
13:40:43 <dolio> roconnor: Does it matter? The issue is that you have to choose the algorithm you run based on the type, which you may not even know statically.
13:40:49 <dolio> How are  you going to do that?
13:41:03 <elliott> by retaining type information!
13:41:15 <roconnor> dolio: hmm.
13:44:58 <dolio> To be honest, I don't really want to add machinery to the runtime system capable of generating values of arbitrary types just to fuzz functions for seq.
13:45:07 <dolio> That sounds like a huge waste of resources. :)
13:45:25 <roconnor> dolio: small-check does it.
13:45:41 <dolio> Small-check isn't good enough.
13:45:55 <dolio> It needs to be more elaborate, and it goes in every Haskell program.
13:46:18 <roconnor> dolio: People who seq functions deserve it.
13:46:52 <roconnor> dolio: anyhow, the point isn't about seq.
13:47:02 <roconnor> dolio: the point is about eta-reduction.
13:47:10 <dolio> Yes.
13:47:36 <roconnor> In practice I'd just get rid of seq for functions.
13:48:14 <roconnor> But the Computer Scientist in me want to know if it is theoretically possible for eta-equivalence and seq to coexist.
13:48:59 <FreeFull> @hoogle Int -> m a -> m [a]
13:48:59 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:48:59 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
13:48:59 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
13:49:55 <NemesisD> oh regrets... this project is meant for posix systems, but uses process for running child processes, because windows compatibility, exposes no functions for sending arbitrary unix signals :(
13:50:12 <elliott> NemesisD: use the unix package?
13:51:03 <dolio> roconnor: I'm not sure I would even be against just saying, "we're doing eta reduction, use seq on functions at your own risk."
13:51:17 <roconnor> :)
13:52:27 <shachaf> hooray for eta reduction
13:52:33 <darinm> Any suggestions for a Haskell program providing C bindings? Just need an example for some testing
13:53:27 <NemesisD> elliott: may require some significant rewriting for this simple feature
13:53:30 <lpvb> System.CPUTime.cpuTimePrecision says the highest precision I can measure is .01 seconds
13:53:34 <lpvb> is there anythoing more precise
13:53:37 <NemesisD> *peeks into System.Process.Internals*
13:55:59 <chrisdone> don't do it
13:56:29 <NemesisD> *after peeking into System.Process.Internals* http://i.imgur.com/pxGRwXP.gif
13:57:11 <dolio> roconnor: Like, what would you have to be doing for that to break your program? You'd be calling seq on a function, and relying on eta expansion to top it from looping somehow?
13:57:21 <dolio> Stop, even.
13:57:39 <roconnor> dolio: yep :)
13:57:46 <dolio> That seems like it'd be a pretty rare and unadvisable scenario.
13:58:40 <roconnor> dolio: this is how languages with broken semantics begin.  :D
13:59:20 <roconnor> acutally this isn't how they begin at all...
13:59:48 <roconnor> justly some guy just implements a language with some random program and declares it to be sementically sound.
13:59:55 <roconnor> *usually
14:00:15 <roconnor> I'm looking at you PHP.
14:00:35 <pharaun> php makes for great quickcheck on the programmer's sanity
14:01:07 <pharaun> s/for/a/
14:02:14 <roconnor> dolio: Actually I'm all for it.
14:02:41 <roconnor> dolio: I think GHC should have a mode where it is allowed to make arbitrary sub-experessions more total.
14:02:50 <dolio> I don't think PHP's author would make any claims about soundness. From what I've heard, he's pretty cognizant of what it is.
14:02:52 <roconnor> ... which implies it could just drop seq whenever it wanted to.
14:02:55 <dolio> It's other people that are the problem. :)
14:03:19 <roconnor> dolio: I'm not talking about claims of soundness; just lack of it.
14:03:45 <roconnor> with such an optimization mode, the seq would really be just a hint.
14:04:20 <lpvb> anyone know how I can get better timing precision thatn getCPUTime?
14:04:25 <FreeFull> I wish there was a way to share a where binding between two different pattern matches when defining a binding
14:04:41 <roconnor> the more I think about this, the more I like it.
14:04:47 <lpvb> it's not even accurate to a millisecond
14:05:21 <roconnor> lpvb: what does criterion use?
14:05:31 <Kaidelong> okay so people have been talking about it since I went off baffled as to why seq and eta reduction can't coexist
14:06:35 <dolio> > (undefined :: () -> ()) `seq` ()
14:06:36 <lambdabot>   *Exception: Prelude.undefined
14:06:47 <dolio> > ((\x -> undefined x) :: () -> ()) `seq` ()
14:06:48 <lambdabot>   ()
14:07:16 <Kaidelong> ah
14:07:22 <dolio> If you replace \x -> f x with f in general, someone might be doing something dumb and the program will blow up where it wouldn't before.
14:07:45 <haasn> mm_freak: what happened to ertes.de?
14:07:49 <dolio> They probably shouldn't be doing something like that, but they might.
14:07:52 <haasn> mm_freak: I can't load your arrows tutorial
14:07:57 <Kaidelong> but why would you want to use seq on a function?
14:08:08 * hackagebot pipes-csv 1.0.0 - Fast, streaming csv parser  http://hackage.haskell.org/package/pipes-csv-1.0.0 (WilliamCasarin)
14:08:54 <dolio> You mostly wouldn't. But someone might, and so GHC won't assume they don't.
14:09:16 <Yaniel> :t seq
14:09:16 <lambdabot> a -> b -> b
14:10:08 <dolio> There are certain situations where it makes doing certain other things a bit faster.
14:10:17 <dolio> By constant factors.
14:10:58 <Kaidelong> I always thought evaluating and caching a closure was something you generally wanted to avoid
14:11:56 <Kaidelong> more space intensive than just feeding the arguments all at once
14:13:30 <dolio> The only thing I've seen is an example Ed has by Wren Thornton, where he does some stuff like...
14:14:04 <dolio> foo f = let g = <something involving f> in \y -> ...
14:14:16 <int-e> There are some special cases where `seq` on functions may be helpful. Imagine you're producing an ensemble of functions (to be used later) that do some precomputation. You might define  foo x = let x' = <precompute> in x' `seq` \y -> ...; and then  foo x1 `seq` ...  would force the precomputation to take place (allowing x1 to be freed)
14:14:42 <dolio> Where pulling the g out lets you compute some things in the body of the \y -> ... once rather than for every y.
14:14:56 <roconnor> Oh oops, eta-contraction *decreases* the definedness of values.
14:15:01 <dolio> And if you do some seqing of f, it doesn't have to go through an indirection or something.
14:15:03 <roconnor> ... that is less good.
14:16:13 <roconnor> dolio: I didn't really understand wren's example.
14:16:21 <Kaidelong> couldn't you achieve the same ends by pulling the things you want to precompute out of the function and evaluating them as values, then passing them in as parameters?
14:16:38 <roconnor> dolio: I mean I understand the lifting; but not the seq'ing
14:16:55 <dolio> Yeah, I'm not sure what the seqing does.
14:17:17 <dolio> Other than that it allegedly lets GHC generate code with fewer levels of indirection.
14:17:18 <roconnor> 'cause the value will get just evaluated when it is needed
14:17:25 <roconnor> and will happen only once.
14:17:37 <roconnor> I mean he does say constant factor ....
14:17:41 <int-e> Kaidelong: in principle, yes. but then it becomes more awkward to use the functions.
14:17:55 <roconnor> I just don't see how it is a big constant factor.
14:18:13 <dolio> Yeah. But I haven't benchmarked, either.
14:22:56 <dagano> i desire a function that returns the head of a list .. or an empty list
14:23:04 <dagano> can't have 2 return types
14:23:30 <dagano> :t reverse . tail
14:23:31 <lambdabot> [a] -> [a]
14:23:45 <Makoryu> > take 1 "pizza"
14:23:47 <lambdabot>   "p"
14:23:49 <Makoryu> > take 1 ""
14:23:50 <lambdabot>   ""
14:23:51 <dagano> > reverse . tail $ []
14:23:52 <lambdabot>   *Exception: Prelude.tail: empty list
14:24:15 <dagano> take 1 []
14:24:19 <dagano> > take 1 []
14:24:20 <lambdabot>   []
14:24:21 <dagano> thnks
14:26:37 <dagano> nope .. i want "pizza" -> 'p'  ... "" -> ""
14:26:54 <Makoryu> dagano: So you want 'p' and "" to be the same type?
14:27:00 <dagano> which they won't
14:27:16 <dagano> i have a condition in a function that needs the head of a list
14:27:23 <dagano> but the list might be empty
14:27:38 <ubikation> I have a guard for calling hgetcontents if there is something and returning "" if there is nothing, but apparently I have to return IO String instead. How do I do that?
14:28:01 <int-e> ubikation: return ""
14:28:08 <Igloo> a
14:28:17 <int-e> @type return "" :: IO String
14:28:17 <lambdabot> IO String
14:28:24 <int-e> @type return ""
14:28:25 <lambdabot> Monad m => m [Char]
14:28:43 <Iceland_jack> > return "" :: Either String
14:28:44 <lambdabot>   Expecting one more argument to `Data.Either.Either GHC.Base.String'
14:28:48 <Iceland_jack> > return "" :: Either a String
14:28:49 <lambdabot>   Right ""
14:29:08 <geekosaur> f [] = {- whatever for empty list -}; f (x:_) = {- whatever for nonempty -}
14:31:00 <dagano> > join []
14:31:01 <lambdabot>   []
14:31:04 <dagano> > join [[]]
14:31:05 <lambdabot>   []
14:31:42 <arkeet> join = concat
14:31:52 <arkeet> > join [[[]]]
14:31:52 <lambdabot>   [[]]
14:34:38 <Maior> any ideas why I might be getting https://travis-ci.org/doismellburning/hogstash for `cabal build` on https://github.com/doismellburning/hogstash (which works fine locally for me...)
14:35:47 <Maior> oh, does `module Hogstash.Outputs.Stdout` / `import Hogstash.Outputs.Stdout`  mean I should be calling things Stdout.hs ?
14:36:17 * Maior finds a case-sensitive fs
14:36:41 <lpvb> When trying to use Criterion's example of running a benchmark, I get "not in scope, data constructor 'B'
14:36:45 <lpvb> http://hackage.haskell.org/packages/archive/criterion/0.4.1.0/doc/html/Criterion-Main.html
14:40:24 <pharaun> hmm - <file descriptor: 8>: hGetBufSome: invalid argument (Bad file descriptor)
14:40:26 <pharaun> *sigh*
14:40:33 <chrisdone> D:
14:41:45 <pharaun> time to reconsider how i'm doing this @_@
14:49:01 <pharaun> happening in random place
14:49:21 <pharaun> this is the one where you run out of FD right?
14:50:07 <pharaun> hm i'm doing it in conduit the opening/hashing/closing so it should be timely
14:50:39 <dagano> i am trying to mix guard conditions and pattern matching .. i think someone here said I can't do that .. but i would like a fcn like :
14:50:42 <dagano> Prelude L> let f x | x == [] = [] | [(x,rs)] = rs
14:51:00 <chrisdone> monoids! monoids everywhere!
14:51:13 <dagano> where f returns empty if argument is empty ,, and the second element of a tupe (a list) if it's a list with a single tuple
14:51:20 <chrisdone> take cover! they won't think twice about append you to their collective
14:51:32 <dagano> is this a possibility?
14:51:45 <chrisdone> yeah you can use pattern guards
14:51:47 <chrisdone> looks like this
14:51:52 <chrisdone> foo | pat <- val = …
14:52:17 <chrisdone> so yours would be:
14:52:18 <chrisdone> foo x | x == [] = [] | [(x,rs)] <- x = rs
14:52:18 <elliott> dagano: f [] = []; f [(x,rs)] = rs
14:52:39 <elliott> no point whatsoever to use (==) here, and it makes the type more restrictive.
14:52:56 <chrisdone> assuming dagano's example isn't contrived to demonstrate a point
14:53:06 <dagano> ! it is
14:53:27 <dagano> thanks
14:53:52 <dagano> Prelude L> let f x | x == [] = [] | [(whocares,rs)] = rs
14:54:07 <dagano> actually the second guard has nothing to do with x
14:54:16 <chrisdone> wat
14:54:24 <elliott> can you write some example expression using f and their results?
14:54:26 <elliott> for instance,
14:54:32 <elliott> f []     =      []
14:54:37 <dagano> f [] = []
14:54:47 <elliott> ok, what about f [(a,b)]?
14:55:15 <dagano> f [(a,b)] = b .. where b is a list
14:55:37 <elliott> f [(a,b),(c,d)]?
14:55:45 <dagano> should never occur
14:55:47 <chrisdone> @  _@
14:55:49 <elliott> ok, then I claim
14:55:51 <elliott> f [] = []
14:55:54 <elliott> f [(_,rs)] = rs
14:55:56 <elliott> is correct.
14:56:00 <elliott> (btw, this function is crazy :))
14:56:06 <dagano> sooo crazy
14:56:15 <dagano> i agree with claim
14:56:16 <dagano> thanks
14:58:16 <chrisdone> god damn my structured editing mode is awesome. i need to release this soon. coding haskell like a super hero
14:58:32 <pharaun> hmm
14:58:45 <Shin-LaC> I was making a graph type using a HashMap label [label], but then I thought I should perhaps represent adjacent nodes with integers so I can save a label lookup… so I figured I should represent nodes as Int [Int] and have a HashMap label Int. and then I might store the nodes in an Array… but then that might have bad performance if I have to insert or delete nodes? am I overthinking this?
14:59:25 <FreeFull> I'd have f _ = [] instead of f [] = [] and plop it at the bottom
14:59:32 <FreeFull> Then you don't have to worry about it being partial
14:59:53 <Shin-LaC> reading those slides about performance-oriented haskell has caused my haskelling to grind to a halt
15:00:04 <FreeFull> Unless you do want your program to crash
15:00:04 <elliott> less partial should never be the goal.
15:00:08 <elliott> more sensemaking is the goal.
15:00:18 <elliott> silent junk results are not better than errors (hence tail [] = [] is wrong)
15:00:36 <chrisdone> yeah if you want that there's drop 1
15:00:48 <arkeet> :t view (folded._2)
15:01:03 <arkeet> :(
15:01:07 <arkeet> :t lambdabot
15:01:10 <lambdabot> (Foldable f, Monoid b, MonadReader (f t) m, Field2 t t b b) => m b
15:01:15 <lambdabot> Not in scope: `lambdabot'
15:01:53 <arkeet> :t concat . map snd
15:01:54 <lambdabot> [(a1, [a])] -> [a]
15:02:26 <arkeet> :t (>>= snd)
15:02:27 <lambdabot> Monad m => m (a, m b) -> m b
15:03:05 <NemesisD> if only i could get System.Process to give me a pid. it does not look straightforward to switch from process to unix
15:04:14 <NemesisD> anyone know of any child process management libraries built on top of the unix package
15:04:39 <chrisdone> hm i should submit a doc change to optparse-applicative
15:04:51 <chrisdone> it deprecates & but still uses it in the examples
15:05:17 <pharaun> ahh
15:05:20 <NemesisD> i imagine there isn't a way to see packages that depend on a package
15:05:28 <pharaun> i think i've tracked down where that dang thing is coming from
15:05:28 <elliott> chrisdone: https://github.com/pcapriotti/optparse-applicative/commit/0cacaaee87bbc97483375b304291c5f0cc834136 ?
15:06:20 <chrisdone> hmm looks like the git version doesn't have it, just the hackage version: elliott:
15:06:22 <chrisdone> http://hackage.haskell.org/package/optparse-applicative
15:06:53 <chrisdone> which was uploaded in 2012 @ _@
15:08:14 <quchen> NemesisD: Yes there is! http://packdeps.haskellers.com/reverse
15:11:40 <NemesisD> HOHO!
15:12:13 <NemesisD> unix-process-conduit uses processhandle from process and lets you send signals from unix.
15:14:18 <chrisdone> @hoogle IO a -> IO (Either SomeException a)
15:14:19 <lambdabot> Control.Exception.Base tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:14:19 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:14:19 <lambdabot> Control.OldException tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
15:14:51 <chrisdone> :t try
15:14:52 <lambdabot> Exception e => IO a -> IO (Either e a)
15:14:55 <chrisdone> a'ight
15:16:48 <Peaker> Hoogle ought to find "try" before "tryJust", esp. given that instances do exist
15:16:56 <chrisdone> yeah, was thinking the same
15:17:11 <chrisdone> does it do such clever instance deriving?
15:17:18 <chrisdone> @hoogle Int -> Integer
15:17:18 <lambdabot> Data.Bits bit :: Bits a => Int -> a
15:17:18 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
15:17:18 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
15:17:24 <chrisdone> seems to
15:18:16 <donri> i like how every result ever is unsafeCoerce
15:18:18 <Peaker> I'm not sure how Hoogle works, but it often finds weird matches.. it would be nice if it put stuff that could match the type (i.e: by being more general) before stuff that doesn't match the type (but could with extra arguments)
15:18:23 <donri> at least when i hoogle on the command line :(
15:18:49 <chrisdone> last time i spoke to neil about it it seemed that the search is particularly liberal and less formally predictable than i'd thought
15:19:07 <chrisdone> agree
15:20:45 <chrisdone> Eelis: long time no see!
15:20:50 <Eelis> chrisdone: hi :)
15:21:22 <chrisdone> i don't remember where i know you from. lojban?
15:21:27 <Eelis> could be!
15:21:36 <chrisdone> you don't remember me? ;_;
15:21:40 <Eelis> sorry i suck with names
15:21:42 <chrisdone> we have a child!
15:21:49 <Eelis> it does ring a bell
15:21:52 <Eelis> but no more than that
15:22:00 <Eelis> oh cool, what did we name it?
15:22:11 <chrisdone> Dumbo
15:22:16 <chrisdone> Eelis: what about kiris?
15:22:23 <Eelis> hmm
15:22:25 <Eelis> nope
15:22:57 <Eelis> i'm on x86_64 yet when i use ghc -cpp, __x86_64__ is not defined. how come? i'm using ghc 7.6.3
15:23:42 <Peaker> Eelis: maybe you installed ghc 32 bit version?
15:23:50 <Eelis> Peaker: hm, how can i check?
15:24:11 <Eelis> ah no, i have this rpm: ghc-7.6.3-2.1.x86_64
15:24:21 <int-e> ghc --info
15:24:37 <Peaker> Eelis: maybe __x86_64__ is the wrong macro to check?
15:24:50 <chrisdone> it works in gcc but not ghc?
15:25:29 <Eelis> chrisdone: yes
15:26:28 <Eelis> ghc --info confirms x86_64 across the board
15:27:33 <lpvb> why can i not do "nf (const myBenchmarkedFunction) 0" in criterion?
15:29:19 <Eelis> oh, and i can reproduce this on a machine with a different linux distro and ghc 7.4.1
15:29:19 <lpvb> in other words, why does my function need an argument to be benchmarked?
15:29:28 <int-e> Eelis: try  x86_64_HOST_ARCH  (http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor)
15:29:47 <Eelis> int-e: well, i'm not using the __x86_64__ myself. it's used in a system header i'm trying to use
15:29:53 <Eelis> so i don't get to change it
15:30:14 <int-e> and you're including it into a haskell file?
15:30:25 <Eelis> int-e: yes, with FFI
15:30:50 <Eelis> (this is normal ;) )
15:35:06 <int-e> Eelis: not quite; for accessing constants from header files it's probably better to use hsc2hs or c2hs.
15:35:45 <Eelis> ah, you're right. i copy pasted from a .hsc file and forgot the extra processing step is needed. so akward.. thanks! :)
15:35:50 <Eelis> *awkward
15:36:28 <dagano> IntMap is confusing me .. i'd like to build an IntMap from a ls = [1,2,3] such that {1 : [1], 2 : [2], 3 : [3]}, any hints?
15:37:14 <dagano> actually such that {1 : Set containing 1, 2 : ....}
15:38:03 <int-e> dagano: so just Map.fromList [(i, Set.singleton i) | i <- [1,2,3]] ?
15:38:51 <dagano> yeah, I guess taht is the idea
15:39:02 <dagano> | i <- [..]
15:39:06 <dagano> i only see that notation in do blocks
15:39:23 <chrisdone> is there a standard library trick to get a functor on the right of an Either?
15:39:59 <int-e> > M.fromListWith S.union [(i `mod` 3, S.singleton i) | i <- [0..4]]
15:39:59 <chrisdone> i have mapEither in data-extra, but curious if there's something
15:40:00 <lambdabot>   fromList [(0,fromList [0,3]),(1,fromList [1,4]),(2,fromList [2])]
15:40:20 <shachaf> Do oy mean left?
15:40:25 <chrisdone> sorry, yes
15:40:26 <shachaf> you
15:40:41 <int-e> dagano: oh that's a list comprehension. Equivalently, one could write  Map.fromList (map (\i -> (i, Set.singleton i)) [1,2,3])
15:41:06 <shachaf> bifunctors has the closest thing to what you're looking for, I think.
15:41:09 <chrisdone> a newtype wrapper could do it, or an iso
15:41:18 <chrisdone> hmm bifunctors, i'm not familiar with that
15:41:21 <donri> _Left ?
15:41:37 <chrisdone> woah, cool. never heard of bifunctors
15:41:49 <shachaf> lens has "over _Left", of course.
15:42:00 <chrisdone> ah, gotcha
15:42:10 <Makoryu> Are there more idiomatic ways to write "foo &&& id" or "id &&& foo"
15:42:18 <quchen> There was a discussion about this recently on the libraries mailing list, it proposed functions like mapEither etc.
15:42:26 <donri> Makoryu: isn't that first/second?
15:42:27 <int-e> Makoryu: first foo and second foo
15:42:27 <chrisdone> Makoryu: first foo and second foo
15:42:39 <dagano> int-e: thanks that was helpful
15:42:40 <chrisdone> from Data.Arrow or… as i've just now learned, Data.Bifunctor =)
15:42:46 <quchen> donri, int-e: first f = f *** id, no?
15:43:01 <shachaf> :t (&&&)
15:43:01 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:43:06 <donri> duno, i never remember which of those operators is which
15:43:12 <Makoryu> :t \foo -> [first foo, foo &&& id]
15:43:13 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = (b0, d0)
15:43:13 <lambdabot>     Expected type: (b0, d0) -> c0
15:43:13 <lambdabot>       Actual type: b0 -> c0
15:43:35 <Makoryu> :t \foo -> [first foo, foo *** id]
15:43:35 <int-e> haha.
15:43:37 <lambdabot> (b -> c) -> [(b, a) -> (c, a)]
15:43:37 <int-e> quchen: yes.
15:43:42 <chrisdone> *** might be defined in terms of arr of first and second, i vaguely recall doing that as an exercise =p
15:43:49 <int-e> @type ap (,) ?f
15:43:49 <lambdabot> (?f::a -> b) => a -> (a, b)
15:44:18 <Makoryu> Whoa, that's a neat trick
15:44:25 <shachaf> The answer is no, as far as I know.
15:44:34 <int-e> Makoryu: ok, then I have no better idea. (the trick is not nice because it destroys the symmetry)
15:44:48 <quchen> chrisdone: Anyway, there are some Either combinators in Arrow if you really need a "standard" (GHC-distributed), but Bifunctor seems to be the more suitable abstraction.
15:45:13 <quchen> Add "module" somewhere in that sentence
15:45:21 <shachaf> People write id &&& foo with categories, too.
15:46:07 <int-e> (and besides 'ap' is an awful name for the S combinator)
15:46:08 <donri> chrisdone: speaking of arrow, isn't "left" from ArrowChoice also what you want
15:47:08 <donri> and +++ is mapEither?
15:47:51 <quchen> (+++) for (->) is mapEither.
15:48:18 <Makoryu> :t show +++ id
15:48:18 <lambdabot> Show a => Either a a1 -> Either String a1
15:48:53 <Makoryu> :t show ||| length
15:48:54 <lambdabot>     Couldn't match type `String' with `Int'
15:48:54 <lambdabot>     Expected type: [a0] -> String
15:48:54 <lambdabot>       Actual type: [a0] -> Int
15:49:03 <chrisdone> yeah bifunctors is cool, i'm all over that
15:49:06 <dagano> :: (Num a, Ord a) => Map.Map a (Set.Set a)
15:49:08 <dagano> :: (Num a, Ord a) => Map.Map a (Set.Set a)
15:49:12 <quchen> But Arrow abstracts generalizes function application, which is not really what you want when you want to map over the second part of something. So - Bifunctor.
15:49:16 <dagano> :: (Num a, Ord a) => Map.Map a (Set.Set a)
15:49:20 <dagano> :: (Num a, Ord a) => Map.Map a (Set.Set a)
15:49:20 <chrisdone> donri: hmm i don't know arrowChoice
15:49:22 <dagano> :: (Num a, Ord a) => Map.Map a (Set.Set a)
15:49:26 <chrisdone> :t left
15:49:27 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
15:49:42 <chrisdone> not bad
15:49:49 <dagano> sry .. does Map have 2 type parameters?
15:49:57 <chrisdone> yeah, key and value
15:49:58 <geekosaur> yes, key and value
15:50:06 <chrisdone> geekosaur: i win
15:50:20 <int-e> @quote fugue
15:50:20 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:50:23 <shachaf> chrisdone: What you really want is "covariant in the first argument out of two". That's awkward in Haskell, though.
15:50:34 * geekosaur does not claim to be fast. especially today, between tired (slow mind) and crap network (slow everything else)
15:51:04 <chrisdone> arrowchoice does seem to be what i wanted
15:51:13 <dagano> @quote nambla
15:51:13 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:51:21 <chrisdone> and bifunctor seems a generalization away from merely either
15:51:35 <Makoryu> shachaf: Would there be a point in generalizing that to a library somehow (so it works on stuff besides Either) or would it make more sense just to use lenses
15:51:39 <chrisdone> i wonder if you could extend arrowchoice to take a bifunctor to bifunctor
15:52:03 <monochrom> http://www.youtube.com/watch?v=QZM4yxbE0ZE
15:52:06 <shachaf> Makoryu: Depends.
15:52:33 <zenzike> so, is anybody here at Boston? I'm about to grab some food, and happy to share with some fellow Haskellers
15:52:52 <chrisdone> e.g. left :: a b c -> a (Either b d) (Either c d) could be
15:52:52 <chrisdone> left :: Bifunctor p => a b c -> a (p b d) (p c d)
15:53:06 <chrisdone> < _<
15:53:15 <elliott> chrisdone: ok, what is inserting spaces in your emoticons?
15:53:16 <Ghoul_> hey
15:53:18 <elliott> I must know.
15:53:19 <chrisdone> zenzike: wish i was, buddy, wish i was =)
15:53:20 <Ghoul_> when I use Double#
15:53:20 <quchen> chrisdone: Biarrow? ;-)
15:53:22 <Ghoul_> how do I get a quotient?
15:53:35 <zenzike> chrisdone: will you be coming to ICFP at all this year?
15:54:13 <chrisdone> elliott: it determins direction somewhat o_ o   @  _@
15:54:30 <Makoryu> （　°д°）
15:54:32 <chrisdone> zenzike: i won't be
15:54:34 <chrisdone> Makoryu: lol
15:54:48 <chrisdone> zenzike: couple buddies from fp complete will be! are you going?
15:54:53 <brooke_peterson> :Ghoul i used div before
15:55:36 <zenzike> chrisdone: yep, just got here, and will be around for the week
15:56:00 <brooke_peterson> :Ghoul never mind, i see i was wrong
15:56:01 <quchen> div on Double# doesn't sound like a good idea.
15:56:24 <brooke_peterson> :quchen now i'm curious
15:56:30 <chrisdone> ha… i'm making a simple command-line/IPC, just realise i can use optparse-applicative for that, too
15:56:34 <chrisdone> applicatives for all!
15:56:41 <chrisdone> zenzike: nice one =)
15:57:23 <Ghoul_> :\
15:57:32 <edwardk> chrisdone: you need to be able to deal with arbitrary sums (arrowchoice) and products (arrow), which gets you polynomial bifunctors, but i don't know that you can handle ones that contain (->) internally.
15:57:33 <quchen> brooke_peterson: div is for Integral instances. Double isn't Integral, and surely neither is Double#.
15:57:43 <Ghoul_> okay, I just ended up using /## but now how do I change my Double# into a Double?
15:57:56 <quchen> Ghoul_: "D" constructor?
15:58:01 <Makoryu> :t [Control.Arrow.first, Data.Bifunctor.first]
15:58:02 <lambdabot> [(a -> b) -> (a, c) -> (b, c)]
15:58:06 <quchen> D :: Double# → Double  iirc
15:58:06 <geekosaur> wrap it in D#? but then, why are you using Double# anyway?
15:58:06 <Makoryu> Neat
15:58:16 <Ghoul_> oh okay
15:58:16 <geekosaur> @src Double
15:58:16 <quchen> Eh, plus "#", right
15:58:17 <lambdabot> data Double = D# Double#
15:58:26 <edwardk> :t GHC.Types.D#
15:58:27 <lambdabot> GHC.Prim.Double# -> Double
16:02:30 <Ghoul_> D# works great, thanks
16:02:39 <haasn> best fizzbuzz ever http://lpaste.net/93233
16:03:06 <haasn> only builds on GHC 7.7+
16:03:35 <quchen> And the code looks beautiful!
16:03:40 <hpc> needs more type alias combinatoriasplosion
16:04:29 <dagano> > Set.insert 4 $ Set.singleton 5
16:04:30 <lambdabot>   Not in scope: `Set.insert'
16:04:30 <lambdabot>  Perhaps you meant one of these:
16:04:30 <lambdabot>    `S.insert' (...
16:04:36 <dagano> > S.insert 4 $ S.singleton 5
16:04:37 <lambdabot>   fromList [4,5]
16:04:43 <dagano> is fromList a function or a type constructor?
16:05:09 <haasn> dagano: a function
16:05:11 <dagano> > S.fromList [1,2]
16:05:12 <lambdabot>   fromList [1,2]
16:05:28 <haasn> dagano: type constructors are types, not values; are you thinking of data constructors? In any case, both start with capital letters
16:05:41 <FreeFull> fromList is a smart constructor
16:05:47 <haasn> dagano: in this case we're dealing with a custom Show instance that basically prints "fromList " ++ ...
16:05:50 <quchen> haasn: Does that code compile? Lines 32 and 35 look strange (lower-case "proxy")
16:05:55 <hpc> a type constructor is a type-level Capitalized Identifier
16:05:58 <dagano> haasn: aah that makes sense
16:06:01 <haasn> That isn't actually the internal representation
16:06:02 <hpc> like Int, Maybe, IO
16:06:20 <dagano> haasn: so fromList isn't a context like 'Just' or something?
16:06:24 <elliott> lower-case proxy is best practice
16:06:26 <haasn> quchen: it compiles in 7.7.20130131 here, lowercase proxy is just a trick
16:06:26 <elliott> in negative position.
16:06:42 <quchen> elliott: "Negative position"?
16:06:43 <hpc> elliott: not negative enough!
16:06:49 <quchen> haasn: Explain this sorcery! :-)
16:06:58 <quchen> Oh wait
16:06:59 <quchen> Haha.
16:07:05 <quchen> Nevermind.
16:07:40 <Ghoul_> Anyone know why I get this error? https://gist.github.com/kvanberendonck/6655053
16:07:44 <elliott> quchen: (- -> +)
16:07:52 <elliott> ((+ -> -) -> +)
16:08:09 <int-e> Ghoul_: you can't use $ for unboxed stuff
16:08:17 <Ghoul_> oh
16:08:24 <quchen> Negative position = somewhere left of a (->)? And negativer is lefter?
16:09:58 <FreeFull> I think a -> always makes everything left of it negative
16:10:04 <int-e> quchen: (a -> b) -> c <-- a and c are positive; b is negative
16:10:17 <FreeFull> Actually, that's wrong
16:10:20 <FreeFull> - -> - -> +
16:10:32 <int-e> FreeFull: that's a -> (b -> c).
16:10:59 <elliott> quchen: negative position = contravariant
16:11:03 <elliott> positive position = covariant
16:11:08 <elliott> consume "proxy", produce "Proxy"
16:11:17 <FreeFull> int-e: Yeah
16:11:49 <quchen> Co-/contravariant again. I think people should have learned from relativity that those aren't very descriptive names. Argh ;-)
16:12:18 <int-e> :t \(f :: a -> a') (g :: (a -> b) -> c) h -> g (h . f)
16:12:19 <lambdabot> (a -> a') -> ((a -> b) -> c) -> (a' -> b) -> c
16:12:57 <quchen> Anyway, let's suppose I understand what co-/contravariant mean, why is it practical to write "proxy" instead of "Proxy" there?
16:13:24 <quchen> Your reactions sounded like it was more than "more polymorphic because why not".
16:13:29 <int-e> the names aren't so bad if you think in terms of fmap variants ... co-variant: fmap :: (a -> b) -> f a -> f b; contravariant: cofmap :: (a -> b) -> f b -> f a.
16:13:33 <elliott> so you can use other types too.
16:13:46 <elliott> for instance, in reflection you often have newtype Foo s = ...
16:13:52 <elliott> and can pass that Foo to reflect directly
16:14:00 <elliott> rather than using scopedtypevariables and writing reflect (Proxy :: Proxy s)
16:14:01 <elliott> much less noisy.
16:14:22 <elliott> or you can write foo ([] :: [Int]), which doesn't require importing Proxy and is shorter.
16:14:29 <elliott> lots of things.
16:14:41 <elliott> foo (const s), if you have an actual value of the type in question
16:14:56 <elliott> plus it's just good practice to accept it this way.
16:15:05 <elliott> you should never depend on actually getting a Proxy, because a Proxy isn't anything at all.
16:15:08 <elliott> you just want the type.
16:15:10 <quchen> Are we talking about the same Proxy here? I'm still in haasn's FizzBuzz example.
16:15:30 * elliott looks.
16:15:32 <elliott> yes, we are
16:16:28 <quchen> Hm. What's reflect then?
16:16:59 <elliott> @hackage reflection
16:17:00 <lambdabot> http://hackage.haskell.org/package/reflection
16:18:28 <quchen> Hm, that seems to be beyond scope. :-/
16:18:46 <mangaba_leitosa> someone knows if "the haskell school of expression" by paul hudak is available in PDF?
16:19:14 <mangaba_leitosa> (or HTML)
16:19:59 <quchen> It seems to be, yes. Ask a search engine.
16:20:37 <mangaba_leitosa> quchen: I asked, and found a million of broken links
16:20:45 <mangaba_leitosa> quchen: to filesharing sites
16:21:22 <mangaba_leitosa> actually, I was asking search engines for about 40 minutes so far
16:22:12 <quchen> I was asking Google and the third link in response to "the haskell school of expression paul hudak pdf" was a PDF from haskell.cs.yale.edu, which seems legal and relevant.
16:22:37 <elliott> quchen: reflection uses Proxy.
16:22:40 <elliott> it is a good example of Proxy use.
16:22:44 <elliott> that is why I used it as an example
16:22:45 <monoidal> quchen: isn't that haskell school of *music*?
16:23:16 <quchen> No.
16:23:34 <quchen> It's the Haskell school of expression from 1998.
16:24:32 <joelteon> How does ghc-mod figure out the types of subexpressions?
16:24:51 <monoidal> quchen: how many pages?
16:25:03 <dfan> Haskell School of Music is kind of the next revision of Haskell School of Expression, using music instead of graphics
16:25:19 <mangaba_leitosa> quchen: on haskell.cs.yale.edu, you can download a PDF with ONE chapter "Composing Music" from Haskell School of Expression
16:25:20 <hpc> the haskell school of music was the best $60 i ever spent
16:25:33 <hpc> if it wasn't for the haskell school of music i would still have $60
16:25:40 <mangaba_leitosa> quchen: as for "Haskell School of Music", I cannot use it because I'm not into music
16:26:20 <quchen> Oh indeed it's just a single chapter.
16:26:21 <mangaba_leitosa> quchen: or maybe I missed the link to the entire book, could you provide it please?
16:26:24 <mangaba_leitosa> quchen: ah, ok
16:26:32 <quchen> It starts with a full-fledged title page though.
16:28:42 <mangaba_leitosa> so far, I found the full text in HTML on safarionlinebooks, available under free trial, but you cannot download it
16:28:52 <mangaba_leitosa> only online reading
16:29:24 <mangaba_leitosa> (well, you can page by page) :-)
16:29:39 <quchen> I'm guessing if it's not readily available from yale.edu or the author's personal website, it's pretty safe to say that there's no free and legal version online.
16:30:01 <mangaba_leitosa> too bad
16:31:17 <dfan> If you are able to afford it, it is indeed an excellent book
16:32:12 <mangaba_leitosa> dfan: right, in the comments on http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ it is said that it contains one of very few introduction to using monads with enough really useful practical examples
16:32:49 <mangaba_leitosa> "introductions"
16:36:04 <quchen> Monads taught me to be careful when people tell you "there's this way of understanding it easily".
16:36:38 <quchen> I don't know how well that book explains them though. Maybe there's a silver bullet explanation after all.
16:38:45 <shachaf> Monads are just free monad monad algebras.
16:39:13 <quchen> In particular, everyone here seems to have his own understanding of what monads are.
16:39:26 <quchen> I picture monads as ..., shachaf doesn't picture them at all. ;-)
16:39:58 <shachaf> A monad is just a functor composed with its right adjoint!
16:39:59 <ion> Monads are just recursion.
16:40:02 <FreeFull> I picture monads as little cows
16:40:03 <shachaf> OK, I'm not helping.
16:40:06 <mangaba_leitosa> quchen: after understanding a concept, the next stage is making use of it, so from the comments it seem that this book covers this next stage :_)
16:40:12 <shachaf> In fact I'm being actively harmful, so I'll stop.
16:40:16 <mangaba_leitosa> "it seems"
16:40:28 <shachaf> mangaba_leitosa: I also like the path where you make use of it first, and then understand it.
16:40:31 <monoidal> mangaba_leitosa: pick a monad, and write a program with it
16:40:58 <ion> mangaba_leitosa: Make use of a concept to understand it.
16:41:40 <quchen> mangaba_leitosa: My recommendation for learning about Monads is actively using Maybe, List, State, Reader, Writer without worrying too much about how they are Monads. Get used to how ">>=" works for each of them, and regard the fact that it's the same operator as a neat feature. After a while, you'll start seeing the common pattern.
16:41:43 <dfan> My favorite monad explanation was in LYAH, because it took its time getting there and built its way up in a motivated way instead of presenting them as magic
16:41:44 <shiona> Otherwise a great read, but for the love of god.. "Tries for a week and then get's an 'aha' moment." It's been like a year for me and no progress so far
16:41:52 <Eduard_Munteanu> How do you index a category, assuming the 2 indices style? Is something like  a i  ->_i,j  b j  reasonable? How do you connect that with indexed functors?
16:42:08 <Thulsadum> is there a function, which transforms a list of monadic values to a list inside that monad? (i.e. [IO a] -> IO [a])
16:42:17 <Eduard_Munteanu> Thulsadum: sequence
16:42:20 <Eduard_Munteanu> :t sequence
16:42:21 <ion> @hoogle [IO a] -> IO [a]
16:42:21 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:42:21 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:42:21 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:42:21 <lambdabot> Monad m => [m a] -> m [a]
16:42:31 <chrisdone> dfan: http://blog.stackoverflow.com/wp-content/uploads/then-a-miracle-occurs-cartoon.png
16:42:52 <onur> hi guys I have a stupid beginner question. lets say I compiled a haskell program in my debian gnu/linux. Can I distribute my program as binary? Does it work on all linux systems?
16:42:58 <Eduard_Munteanu> For functors, a definition like  F : I x I -> D^C  seems reasonable if I is a category as well.
16:42:59 <Thulsadum> ah, i knew, i saw that, but can't remember my vocabulary :D thanks, Eduard_Munteanu.
16:43:05 <quchen> mangaba_leitosa: The coolest thing about Haskell Monads is actually how remarkably clear they are once you understand them ;-)
16:43:34 <mangaba_leitosa> quchen: well, my problem is that when working very actively with Lists and Maybe, I didn't yet figure out how the fact that they are monads is helping to manipulate them better :-)
16:43:44 <shachaf> Thulsadum: That's why ion's answer was much more valuable than "sequence".
16:43:47 <quchen> … which is probably part of the reason most tutorials aren't very helpful: Either you don't understand them so you can't write up a good explanation, or you do understand them so you can't write up a good explanation for one who doesn't.
16:43:50 <shachaf> Thulsadum: So learn from ion.
16:43:55 <shachaf> lion
16:44:09 <Eduard_Munteanu> onur: no, not really
16:44:27 <quchen> mangaba_leitosa: "Being a Monad" doesn't help a type much. The strength comes from other functions that can be written generically for any Monad.
16:44:41 <quchen> mangaba_leitosa: If Maybe was the only Monad the abstraction wouldn't be very useful.
16:44:59 <Eduard_Munteanu> onur: only Haskell libraries are statically-linked in by default, but there's other stuff like libgmp or other C libs that aren't.
16:45:05 <mangaba_leitosa> quchen: and I just cannot generalize what I know about IO, List and Maybe to write any useful functions that apply two all of them
16:45:24 <mangaba_leitosa> "to all"
16:45:27 <Thulsadum> shachaf: yep, i try to stick to hoogle... :)
16:45:42 <ion> mangaba_leitosa: You could look at the source of Control.Monad for examples.
16:46:21 <quchen> > liftM2 (+) (Just 3) (Just 5) -- liftM2 (+) adds two monad values. Here is an example where it adds two things of type Maybe Int.
16:46:22 <lambdabot>   Just 8
16:46:38 <quchen> > liftM2 (+) [3] [5] -- Same thing, but with lists.
16:46:39 <lambdabot>   [8]
16:46:43 <Eduard_Munteanu> onur: nevertheless it will work sometimes, and you may try attempt to link everything statically
16:46:45 <monoidal> mangaba_leitosa: do you know only IO, List and Maybe? I would look at others (Reader, Writer, Either)
16:46:59 <quchen> You could also write "liftM2 (+) readLn readLn", which would prompt you for two numbers and add them.
16:47:08 <arkeet> > liftM2 (+) [1,2] [10,20,30]
16:47:09 <lambdabot>   [11,21,31,12,22,32]
16:47:25 <FreeFull> > sequence [Just 1, Just 3, Just 5]
16:47:26 <mangaba_leitosa> ion: returning to where we started (the haskell school of expression), people say that it contains much more practical examples  :-)
16:47:26 <lambdabot>   Just [1,3,5]
16:47:38 <arkeet> > fix sequence
16:47:40 <FreeFull> > sequence [[1],[3],[5]]
16:47:40 <mangaba_leitosa> ion: "it" = "this book"
16:47:41 <lambdabot>   [[1,3,5]]
16:47:45 <Mdx> hey, does anyone have some haskell exercises on this style? http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
16:47:45 <lambdabot>   mueval-core: Time limit exceeded
16:47:51 <quchen> I'm not sure throwing more complex examples at mangaba_leitosa is going to help much.
16:47:51 <FreeFull> :t fix sequence
16:47:52 <arkeet> > sequence [[1,2],[3,4]]
16:47:52 <lambdabot> [[a]]
16:47:53 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
16:48:16 <onur> Eduard_Munteanu: I see. I thought static linking is dead in linux (at least for C/C++).
16:49:00 <Eduard_Munteanu> onur: you can do it, at least for the basic libraries many distros provide .a's in some -dev package or they're needed for initramfs building
16:49:19 <mangaba_leitosa> monoidal: also, I also know the abstract concept as introduced by popular tutorials. I even liked the concept of State and Monad and implemented a similar approach in an ocaml project (5000 lines), emulating monads... Yet it didn't lead to full generalization of the concept in my head
16:49:22 <Eduard_Munteanu> onur: but you should consider distributing the source instead, and perhaps distros should make their own packages.
16:49:28 <quchen> mangaba_leitosa: When all the monads you know are Maybe and List, you should really have a look at Reader, Writer, State. In particular I don't think List is a very good beginner monad. It's easy to implement, but it feels "different" from most other monads. Anyway, that's just what I think.
16:50:01 <mangaba_leitosa> monoidal: also, I had to eventually take out monads of the projects and rewrites parts of the code using mutable structures for performance reasons :-)
16:51:19 <mangaba_leitosa> quchen: I will. so far, I only implemented (emulated in ocaml) my own state monad :-)
16:52:29 <Eduard_Munteanu> Hm, nlab and other things suggest an indexed category can be defined as a functor from Cat to S^op, for S a category.
16:52:47 <mangaba_leitosa> quchen: so, I have a basic understandic of a monad as a state (IO being one of them), yet I fail to understand what e. g. lists have in common with states
16:53:01 <quchen> Monads are not states.
16:53:04 <arkeet> mangaba_leitosa: monads are not states.
16:53:17 <quchen> State-like things can be modeled as monads. Big difference.
16:53:21 <mangaba_leitosa> arkeet: ok, I mean, I undestand how to represent a state using monads
16:53:23 <FreeFull> mangaba_leitosa: Have you looked at what the state monad actually does?
16:54:21 <shachaf> The phrase "represent a state using monads" suggests a misunderstanding to me.
16:54:25 <Iceland_jack> mangaba_leitosa: Work with different monads (without worrying too much that they are monads) instead of attempting to find some executive summary of them, that's my suggestion
16:54:28 <mangaba_leitosa> FreeFull: I didn't look at the actual state monad in haskell so far. Only read papers on modelling states using monads
16:54:35 <arkeet> Monad is just a typeclass.
16:54:43 <arkeet> various things are instances of it.
16:55:02 <arkeet> you can model state with State.
16:55:10 <arkeet> it happens that State is a monad.
16:55:12 <monoidal> mangaba_leitosa: do you understand functors?
16:55:18 <quchen> mangaba_leitosa: You should definitely have a look at LYAH then, it sounds like you're not familiar with that book.
16:55:25 <arkeet> @where lyah
16:55:25 <lambdabot> http://www.learnyouahaskell.com/
16:55:43 <mangaba_leitosa> Iceland_jack: sure. and for this my immediate plan is to look at the haskell school of expression :-)
16:55:45 <quchen> mangaba_leitosa: It's what (presumably) a lot of people in this channel used as their first book.
16:55:51 <FreeFull> mangaba_leitosa: Basically, it's a wrapper around functions   \s -> (a,s)
16:56:03 <arkeet> no \ there
16:56:08 <Eduard_Munteanu> mangaba_leitosa: you should avoid labeling things, it may get in the way later on
16:56:09 <arkeet> =(
16:56:25 <FreeFull> mangaba_leitosa: So ones that take an s (the state) and return a result and a new state
16:56:33 <mangaba_leitosa> monoidal: functors as I class of types having a map functions, yes, I understand
16:57:27 <arkeet> :t liftA2 (.)
16:57:28 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
16:57:44 <monoidal> mangaba_leitosa: do you know how does the functor instance look for common cases such as Either e, Maybe, (->) r, (,) r?
16:57:45 <mangaba_leitosa> quchen: I will, thanks
16:58:11 <quchen> mangaba_leitosa: Contrary to that Haskell School of Expression, LYAH is available for free online.
16:58:22 <mangaba_leitosa> monoidal: no, I don't know how to use fmap for e. g. Maybe
16:58:38 <Iceland_jack> > fmap (++ "!!!") (Just "hello")
16:58:39 <lambdabot>   Just "hello!!!"
16:58:41 <Iceland_jack> > fmap (++ "!!!") Nothing
16:58:42 <lambdabot>   Nothing
16:58:51 <Iceland_jack> That's all
16:59:06 <monoidal> mangaba_leitosa: can you write the definition of fmap :: (a -> b) -> Maybe a -> Maybe b?
16:59:08 <mangaba_leitosa> Iceland_jack: ah, I see what you mean.
16:59:20 <quchen> mangaba_leitosa: You can view Maybe as a list that can only have one (or no) element. If you understand the List Functor instance, then you understand Maybe's almost for free.
16:59:38 <Iceland_jack> > fmap (+ 50) ("Amy Sanders", 34)   -- etc.
16:59:38 <lambdabot>   ("Amy Sanders",84)
16:59:47 <mangaba_leitosa> monoidal: I'll try to think this question over :-)
17:00:12 <mangaba_leitosa> quchen: yes, I understand this, too. 'Monad as a container' concept
17:00:46 <mangaba_leitosa> monoidal: as for definitions, I wonder how I define my type e. g. (Tree) and deriving Functor knows how to implement map for my type
17:00:59 <mangaba_leitosa> monoidal: I know how to use it, but I don't know how it works
17:01:03 <Mdx> Iceland_jack: how does fmap nows how to act on the snd of the tuple? just because it fulfills the type?
17:01:08 <monoidal> mangaba_leitosa: I would look at how does it work, then.
17:01:18 <Eduard_Munteanu> @quote /bin/ls
17:01:19 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:01:23 <shachaf> Mdx: Yes.
17:01:25 <Iceland_jack> Mdx: fmap always operates on the second object of a tuple
17:01:26 <shachaf> hi lambdabot
17:01:30 <mangaba_leitosa> monoidal: i. e. I can write fmap for my Tree type myself, but I don't know how deriving Functor does it automatically
17:01:41 <Iceland_jack> Mdx: Try to specialize the fmap type! :)
17:01:59 <mangaba_leitosa> monoidal: and yes, I can write a definition of fmap for maybe just like I can (and did) for my Tree type
17:02:04 <Iceland_jack> @ty fmap (,)
17:02:05 <lambdabot> Functor f => f a -> f (b -> (a, b))
17:02:05 <quchen> mangaba_leitosa: "deriving Functor" is something nontrivial, and you should not worry about it as a beginner.
17:02:06 <Mdx> Iceland_jack:  So if I do
17:02:15 <Iceland_jack> no wait..
17:02:23 <quchen> mangaba_leitosa: It's not even standard Haskell, but a special GHC feature.
17:02:26 <Mdx> > fmap (+ 50) (34, "Amy Sanders")
17:02:27 <lambdabot>   Could not deduce (GHC.Num.Num [GHC.Types.Char])
17:02:27 <lambdabot>    arising from a use of `G...
17:02:39 <monoidal> Mdx: use "first" for this.
17:02:39 <Iceland_jack> Mdx: Always applied to the second part
17:02:47 <Mdx> I see
17:03:25 <monoidal> mangaba_leitosa: what about Functor ((->) r)?
17:03:36 <mangaba_leitosa> monoidal: what I don't understand, however, how knowing the fact that types having fmap are functors is anyhow useful to me :-)
17:04:17 <monoidal> mangaba_leitosa: it's common abstraction, much simpler than monads. IMO you should know it fluently before doing monads.
17:04:19 <Iceland_jack> Mdx: Normally the type of fmap is like so:
17:04:20 <Iceland_jack>     fmap :: Functor f => (a -> b) -> f a -> f b
17:04:20 <Iceland_jack> but with the tuple it's actually:
17:04:20 <Iceland_jack>     fmap :: (a -> b) -> (c, a) -> (c, b)
17:05:09 <arkeet> fmap :: (a -> b) -> (,) c a -> (,) c b
17:05:36 <Mdx> I got it, thanks !
17:05:41 <mangaba_leitosa> monoidal: I don't know what Functor ((->) r) is, reading haskell.org now....
17:05:41 <Iceland_jack> :)
17:05:50 <arkeet> (->) r a = r -> a
17:06:00 <arkeet> we'd write it as (r ->) if that was possible.
17:06:09 <Eduard_Munteanu> I wonder if I can derive a definition for indexed categories from the one for indexed functors.
17:06:21 <quchen> mangaba_leitosa: It's also known as "Reader".
17:06:25 <arkeet> what's an indexed functor?
17:06:25 <Iceland_jack> mangaba_leitosa: Is there any reason why you just don't check out LYAH?
17:07:01 * quchen thinks LYAH is what you're hoping to find in that other book, except that LYAH is still up to date and everyone loves it.
17:07:50 <Eduard_Munteanu> arkeet: something like  F : I x I -> D^C  AFAICT... in Haskell, it goes like  class IxFunctor f where imap :: (a -> b) -> (f i j a -> f i j b)   (or more complex for non-Hask functors)
17:08:00 <mangaba_leitosa> Iceland_jack: well, know that it has been suggested, there is no particular reason
17:08:02 <shachaf> I don't love it.
17:08:11 <arkeet> Eduard_Munteanu: sure.
17:08:15 <arkeet> so it's just a collection of Functors.
17:08:29 <quchen> s/everyone/everyone*
17:08:38 <Eduard_Munteanu> arkeet: err, not really, you want it to be functorial in indices too I think
17:08:42 <mangaba_leitosa> Iceland_jack: before that, "A beginner's guide" in the title didn't suggest that it's somthing for learing advanced things :-)
17:08:48 <arkeet> Eduard_Munteanu: not really?
17:08:49 <Eduard_Munteanu> arkeet: where I is an index category
17:08:57 <arkeet> well
17:09:20 <Eduard_Munteanu> arkeet: the IxFunctor above is an oversimplification I think.
17:09:24 <mangaba_leitosa> Iceland_jack: i. e., knowing having implemented a compact prolog interpreter in Haskell I don't actually feel like the absolute beginner :-)
17:09:29 <quchen> mangaba_leitosa: Yes, it's not for advanced things. For the same reason you don't start off with field theory in physics but with marbles falling in vacuums.
17:09:49 <FreeFull> mangaba_leitosa: fmap over ((->) r) is function composition
17:09:57 <mangaba_leitosa> Iceland_jack: but I check the book out for useful info for typeclasses :-)
17:10:02 <Iceland_jack> mangaba_leitosa: Did you do that without learning about monads?
17:10:08 <Iceland_jack> That surprises me
17:10:10 <mangaba_leitosa> FreeFull: so it's (.) ?
17:10:22 <FreeFull> Yes
17:11:00 <Iceland_jack> Even intermediate programmers can learn from ‘Beginner's guides’
17:11:43 <mangaba_leitosa> Iceland_jack: well, I did it after TRYING to learn about monads, like reading "What the hell are monads" by Noel Winstanley, Monads made easy by Ahmed Hammad, and similar papers by Wadler and Simon Peyton Jones
17:11:57 <arkeet> don't try to learn about monads.
17:12:00 <k0001> What could go wrong if have a `Handle` (`NoBuffering` mode) for a file descriptor (`CInt`) and when done I decide to close the file descriptor somehow, instead of closing the `Handle` using `System.IO.hClose`? (Because I don't have a reference to such `Handle`, but I do know its `CInt` file descriptor).
17:12:03 <arkeet> that's where the problems start.
17:12:03 <mangaba_leitosa> Iceland_jack: but you are right at thinking that I haven't actually learned everything about monads
17:12:08 <Iceland_jack> don't try to learn about monads.
17:12:47 <arkeet> just start using a few specific ones.
17:12:53 <arkeet> get some intuition for some concrete cases.
17:13:10 <mangaba_leitosa> FreeFull: ok, so (.) is a speciall case of mapping values for functions. I see
17:13:22 <Eduard_Munteanu> arkeet: anyway, I was thinking maybe I can look at F : I x I -> D^C  then perhaps squint and  I x C -> D^I  but I'm unsure what I can make of that. Any ideas? :/
17:13:39 <arkeet> Eduard_Munteanu: I don't think that gets you anywhere. :p
17:13:43 <arkeet> it's all I x I x C -> D anyway
17:13:50 <Eduard_Munteanu> Yeah. :/
17:14:04 <mangaba_leitosa> arkeet: re indexed functor, know idea just yet :-)
17:14:20 <arkeet> mangaba_leitosa: the question wasn't directed at you.
17:14:51 * arkeet confusion with multiple threads of discussion in one channel.
17:14:57 <Eduard_Munteanu> arkeet: the reason I wanted an indexed category was to be able to define indexed functors for Kleisli / CoKleisli categories.
17:15:04 <mangaba_leitosa> arkeet: sorry, it's diffult to chat on a channel with 1000+ members :-)
17:15:06 <shachaf> I recommend the monad thing be taken to #haskell-overflow.
17:15:06 <NemesisD> what is the common way to terminate an monadic action early without resorting to errors like mzero
17:15:21 <arkeet> NemesisD: ??
17:15:24 <quchen> NemesisD: Pack it in a "when"?
17:15:35 <mangaba_leitosa> shachaf: and what #haskell-overflow is for? :-)
17:15:40 <Eduard_Munteanu> Since (Co)Kleisli is indexed too for indexed (co)monads.
17:15:42 <shachaf> It's for long conversations.
17:15:56 <NemesisD> i've got an IO () action and i just want t stop if a given predicate is true
17:16:07 <arkeet> stop when?
17:16:20 * Iceland_jack wants a penny for every monad conversation they've seen
17:16:30 <FreeFull> mangaba_leitosa: ((->) r) is also a monad, which is why stuff like   join somefunction   works
17:16:34 <NemesisD> stop executing any further actions in the monad
17:16:39 <FreeFull> > join (,) 3
17:16:39 <lambdabot>   (3,3)
17:16:46 <arkeet> NemesisD: "the monad"?
17:16:55 <Eduard_Munteanu> NemesisD: like exit the program?
17:17:00 <NemesisD> arkeet: in the do block
17:17:10 <NemesisD> Eduard_Munteanu: no, just short circuit and return ()
17:17:20 <Mdx> NemesisD:  can't you make if predicate then return () else rest?
17:17:28 <Eduard_Munteanu> NemesisD: ah, in that case you probably want MaybeT, ErrorT or ContT
17:17:29 <arkeet> NemesisD: you can't do that just with IO.
17:17:37 <arkeet> Eduard_Munteanu: I would suggest MaybeT.
17:17:38 <FreeFull> > replicateM 10 (+3) 0
17:17:38 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
17:17:54 <quchen> whenM might also be enough.
17:18:03 <NemesisD> hmm never used ContT, and the terminate early case is actually a non-error case, it is the success case
17:18:05 <arkeet> Eduard_Munteanu: ContT is definitely overkill, and ErrorT sucks.
17:18:16 <arkeet> NemesisD: look at MaybeT.
17:18:19 <mangaba_leitosa> Iceland_jack: answering your question the other way round re 'Did you do that without learning about monads? That surprises me', I can use Haskell to the same extend as I can OCaml, which lacks monads. I can implement a prolog interpreter in ocaml without monads and I can do the same on haskell. But I understand that in Haskell I could do it easier with monads and other things that ocaml is missing
17:18:29 <Eduard_Munteanu> arkeet: compared to MonadFail and other finer grained things?
17:18:55 <arkeet> Eduard_Munteanu: no, ErrorT just sucks. one should use EitherT instead.
17:19:00 <FreeFull> Cont is the mother of all monads
17:19:24 <Iceland_jack> mangaba_leitosa: Fair enough, I did not meant to sound disparaging.
17:19:47 <NemesisD> arkeet: should i not worry about how many times the word failure is mentioned in the docs (under transformers anyhow)
17:19:47 <Peaker> arkeet: there's the "either" package for EitherT
17:19:59 <arkeet> Peaker: I just mentioned EitherT.
17:20:00 <arkeet> =(
17:20:11 <Peaker> oh, sorry, I just skimmed my screen :)
17:20:14 <arkeet> :)
17:20:20 <merijn> mangaba_leitosa: You can implement monads in ocaml no problem, the thing you lack in ocaml is typeclasses, but you could have a monad module using ocaml's functor stuff
17:20:23 <Peaker> (and saw the MaybeT/ErrorT message)
17:20:51 <merijn> mangaba_leitosa: In fact, implementing monads in ocaml is, like in haskell, a mostly trivial and simple exercise
17:21:06 <FreeFull> I wonder what Haskell would be like with OCaml's module system
17:21:11 <FreeFull> Also, better records
17:21:31 <merijn> FreeFull: SPJ is overseeing a GSoC project working on improving record syntax atm
17:21:37 <arkeet> > runMaybeT $ do { tell "hello"; mzero; tell "world" } :: (String, Maybe ())
17:21:38 <lambdabot>   Not in scope: `runMaybeT'
17:21:43 <arkeet> @let import Control.Monad.Trans.Maybe
17:21:44 <arkeet> @let import Control.Monad.Trans.Maybe
17:21:44 <lambdabot>  Defined.
17:21:45 <lambdabot>  Defined.
17:21:46 <arkeet> > runMaybeT $ do { tell "hello"; mzero; tell "world" } :: (String, Maybe ())
17:21:47 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
17:21:47 <lambdabot>                    ...
17:21:50 <arkeet> oh.
17:21:52 <mangaba_leitosa> merijn: yes, I implemented a monad-like approach for states in ocaml... because I did grasp the 'modelling states with monads' part of the concept :-)
17:21:55 <arkeet> > runMaybeT $ do { lift $ tell "hello"; mzero; lift $ tell "world" } :: (String, Maybe ())
17:21:56 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
17:21:56 <lambdabot>                    ...
17:21:58 <arkeet> oh well.
17:21:59 <arkeet> I quit.
17:22:06 <quchen>  /q lambdabot?
17:22:14 <arkeet> or /quit
17:22:23 <merijn> mangaba_leitosa: Did you read "You Could Have Invented Monads"? It's the only tutorial worth reading
17:22:30 <quchen> Right, that was a very client-dependent suggestion.
17:22:45 <FreeFull> arkeet: Maybe you have to provide a MonadWriter instance
17:22:54 <arkeet> yes.
17:22:56 <FreeFull> Depends on the full error message
17:22:56 <arkeet> =(
17:22:59 <merijn> But someone else will have to find you the link, 'cause I'm going to sleep :p
17:23:15 <quchen> @google you could have invented monads
17:23:15 <mangaba_leitosa> merijn: not this one, but it was on my TODO list. thanks, will go ahead with that :-)
17:23:17 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:23:19 <quchen> MAGIC
17:23:19 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
17:23:25 <enthropy> > runWriter $ runMaybeT $ do { lift $ tell "hello"; mzero; lift $ tell "world" }
17:23:26 <lambdabot>   (Nothing,"hello")
17:24:29 <arkeet> lift isn't necessary.
17:24:42 <arkeet> but that's just because MonadWriter is a class.
17:24:49 <arkeet> and things.
17:25:28 <enthropy> @let import Unsafe.Coerce
17:25:29 <lambdabot>  .L.hs:120:1:
17:25:29 <lambdabot>      Unsafe.Coerce: Can't be safely imported!
17:25:29 <lambdabot>      The module i...
17:25:35 <enthropy> ah that's good
17:27:31 <NemesisD> i'm not seeing how i'd use maybeT here
17:27:46 <NemesisD> turn all my actions into ones that return a Maybe?
17:27:59 <arkeet> lift all your actions.
17:28:04 <arkeet> possibly with liftIO.
17:28:28 <arkeet> :t runMaybeT $ do { liftIO $ putStrLn "hello"; mzero; liftIO $ putStrLn "world" }  -- only prints "hello"
17:28:29 <lambdabot> MonadIO m => m (Maybe ())
17:28:48 <NemesisD> arkeet: and then am i using the monadplus and guard for the parts where i want to break out early (not an error case)
17:28:54 <arkeet> sure.
17:28:57 <arkeet> mzero = guard False
17:29:21 <arkeet> so you could use guard and a boolean.
17:29:32 <arkeet> if you want to break out with a return value, you could use EitherT.
17:29:34 <arkeet> :t runEitherT
17:29:35 <lambdabot>     Not in scope: `runEitherT'
17:29:35 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
17:29:46 <arkeet> @let import Control.Monad.Trans.Either
17:29:46 <lambdabot>  .L.hs:52:1:
17:29:46 <lambdabot>      Failed to load interface for `Control.Monad.Trans.Either'
17:29:46 <lambdabot>  ...
17:29:48 <arkeet> =(
17:30:05 <arkeet> @let import Control.Monad.Trans.Error
17:30:06 <lambdabot>  Defined.
17:30:12 <arkeet> (although you should use EitherT instead)
17:30:49 <arkeet> :t runErrorT $ do { liftIO $ putStrLn "hello"; throwError "blah"; liftIO $ putStrLn "world" }  -- prints Hello and returns Left "blah"
17:30:52 <quchen> I wonder how much of a bang 7.10 will be every time somebody mentions EitherT. It seems to be consensus that that's a good idea to have, then there's Foldable/Traversable for Prelude and the AMP, and that's only the stuff we know about right now.
17:31:06 <lambdabot>     Ambiguous occurrence `throwError'
17:31:06 <lambdabot>     It could refer to either `Control.Monad.Error.throwError',
17:31:06 <lambdabot>                              imported from `Control.Monad.Error' at /home/lambdabot/.lambdabot/State/L.hs:43:1-26
17:31:11 <arkeet> oh great.
17:31:52 <FreeFull> @undef
17:31:52 <lambdabot> Undefined.
17:32:15 <arkeet> runEitherT $ do { liftIO $ putStrLn "hello"; left "blah"; liftIO $ putStrLn "world" } :: IO (Either String ()) -- this is what it would look like with EitherT
17:33:17 <FreeFull> :t runEitherT
17:33:17 <lambdabot>     Not in scope: `runEitherT'
17:33:17 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
17:33:22 <NemesisD> arkeet: how should i decide whether to use lift or liftIO if the underlying monad is IO. is there a performance advantage to one
17:33:30 <FreeFull> @let import Control.Monad.Trans.EitherT
17:33:30 <lambdabot>  .L.hs:52:1:
17:33:31 <lambdabot>      Failed to load interface for `Control.Monad.Trans.EitherT'
17:33:31 <lambdabot> ...
17:33:32 <FreeFull> @let import Control.Monad.Trans.Either
17:33:32 <lambdabot>  .L.hs:52:1:
17:33:33 <lambdabot>      Failed to load interface for `Control.Monad.Trans.Either'
17:33:33 <lambdabot>  ...
17:33:40 <arkeet> liftIO lets you lift an IO action all the way through a big transformer stack.
17:33:50 <Maior> :t liftIO
17:33:50 <lambdabot> MonadIO m => IO a -> m a
17:33:58 <FreeFull> NemesisD: Always use liftIO
17:34:01 <arkeet> ^
17:34:09 <arkeet> lift only lifts one level.
17:34:14 <NemesisD> oh ok
17:38:07 <mescalinum> why this causes an error about constructing an infinite type?
17:38:09 <mescalinum> combFactors (pf:pfs) = map (\x -> x ++ r) $ tails pf
17:38:10 <mescalinum>     where r = combFactors pfs
17:40:02 <mescalinum> what I'm trying to do here, is to turn [[a],[b,b],[c]] into [[],[c],[b],[b,c],[b,b],[b,b,c],[a],[a,c],[a,b],[a,b,c],[a,b,b],[a,b,b,c]]
17:40:03 <shachaf> Because it's wrong, probably.
17:40:18 <shachaf> (If you want a more detailed answer you should e.g. say what the error is.)
17:40:20 <NemesisD> arkeet: thanks for the advice on MaybeT, it worked perfectly
17:40:40 <mescalinum> shachaf: Occurs check: cannot construct the infinite type: a0 = [a0]
17:40:49 <monochrom> do you want combFactors :: [[a]] -> [[a]]?
17:41:00 <mescalinum> yes
17:41:12 <shachaf> Then give GHC the type, and it'll give you a better error.
17:41:29 <shachaf> Well, somewhat better.
17:41:42 <monochrom> tails pf :: [[a]], do you agree?
17:42:07 <arkeet> :t sequence . map tails
17:42:08 <lambdabot> [[a]] -> [[[a]]]
17:42:13 <arkeet> hm, not quite.
17:42:15 <monochrom> therefore when you do map (\x -> whatever) (tails pf), x :: [a], do you agree?
17:42:36 <monochrom> r = combFactors pfs :: [[a]], do you agree?
17:42:54 <monochrom> therefore (x :: [a]) ++ (r :: [[a]]) is a mismatch, do you agree?
17:43:02 <shachaf> I agree.
17:43:23 <arkeet> :t map concat . sequence . map tails
17:43:24 <lambdabot> [[a]] -> [[a]]
17:43:28 <arkeet> I think that's it.
17:43:50 <mangaba_leitosa> 04:05 < arkeet> we'd write it as (r ->) if that was possible.
17:43:50 <mangaba_leitosa> 04:05 < arkeet> we'd write it as (r ->) if that was possible.
17:43:54 <mangaba_leitosa> oops, sorry
17:44:08 <arkeet> although not in the same order.
17:44:24 <NemesisD> hmm this seems strange. sending a SIGKILL to a (haskell) process returns an exit status of 0
17:44:37 <arkeet> and then you could just reverse the output.
17:44:38 <mangaba_leitosa> I'm taking notes copy/pasting parts of the discussion :-)
17:44:44 <NemesisD> i'd expect violent process death to return a nonzero exit status
17:45:30 <Kaidelong> how feasible would it be to cross-compile a wxHaskell application to a windows target, without actually being on windows?
17:45:33 * arkeet seems to get an exit status of 137
17:45:43 <Kaidelong> because setting up the haskell platform on windows and getting it working properly is a slight nightmare
17:45:47 <monochrom> is 137 prime?
17:45:57 <arkeet> https://www.google.com/search?q=is%20137%20prime%3F
17:46:00 <arkeet> google says yes
17:46:13 <monochrom> > map (\x -> 137 `mod` x) [2, 3, 5, 7, 11, 13]
17:46:14 <lambdabot>   [1,2,2,4,5,7]
17:46:21 <monochrom> that's good
17:46:33 <Kaidelong> you only have to check up to 11
17:46:38 <monochrom> 1337 is probably not prime, too bad
17:46:47 <NemesisD> i guess its a linux thing. sleep 100 (in another window pkill -KILL -f sleep), echo $! prints 0
17:46:49 <arkeet> > product [1..136] `mod` 137
17:46:50 <lambdabot>   136
17:47:07 <monochrom> Kaidelong, I am very bad at squaring and squarrooting
17:47:08 <int-e> 137 = 11^2 + 4^2 = (11 - 4i) (11 + 4i)
17:47:13 <geekosaur> that sounds wrong
17:47:21 <arkeet> int-e: shush you.
17:47:25 <geekosaur> (the SIGKILL thing that is)
17:47:32 <monochrom> think of me as a redundant array of brain matter
17:47:39 <Kaidelong> you don't have 12*12 = 144 memorized from elementary school?
17:47:39 <int-e> arkeet: why, Gaussian integers are fun :)
17:47:45 <monochrom> redundant array of cheap brain matter, too
17:47:56 <Kaidelong> we had to learn multiplication tables up to 12
17:48:07 <monochrom> sometimes I have
17:48:10 <int-e> poor ghc, my fizzbuzz takes 42 seconds to compile.
17:48:14 <shachaf> I learned the multiplication table up to 5.
17:48:28 <int-e> (but it compiles to a putStr call with a constant string, yay)
17:48:30 <roconnor> int-e: oh god
17:48:46 <Kaidelong> anyone tried cross compiling with GHC and GCC?
17:48:47 <arkeet> haha./
17:49:14 <monochrom> everyone has learned the multiplication table from exactly 0 to 10. everyone just may have a different version of 10.
17:49:16 <int-e> http://int-e.eu/~bf3/tmp/FizzBuzz.hs :)
17:49:25 <monochrom> ("I use base 10. what is 4?" :) )
17:49:33 <mangaba_leitosa> int-e: 42 seconds to compile?! but how?
17:50:11 <int-e> mangaba_leitosa: spending a lot of time on typechecking. (since the program does all the work in the type system)
17:50:18 <shachaf> http://cowbirdsinlove.com/43
17:50:23 <quchen> ♥
17:50:26 <monochrom> I love Gaussian integers. they are so complex.
17:50:57 <int-e> mangaba_leitosa: obviously this is just for fun.
17:51:28 <mangaba_leitosa> int-e: :-)
17:51:41 <Kaidelong> maybe it'll be easier to stick to .NET and try to target mono instead of trying to develop something in haskell
17:51:44 <mangaba_leitosa> int-e: was it your intention?
17:51:48 <Kaidelong> and target windows
17:52:51 <int-e> mangaba_leitosa: Besides having fun I was curious whether ghc would inline things down to a constant string, which it did :)
17:52:52 <mangaba_leitosa> int-e: I checked, it consists entirely of type definitions :-)
17:53:04 <int-e> there are two type classes!
17:53:35 <arkeet> int-e: is that some skew binary there?
17:54:14 <int-e> arkeet: sort of. it's using only digits 1 and 2.
17:54:20 <arkeet> hmm.
17:54:42 <int-e> (the idea being to avoid the 00 = 0 problem)
17:54:56 <int-e> i.e., having a unique representation for numbers.
17:57:37 <quchen> int-e: What's D1/D2?
17:57:49 <quchen> E = 0?
17:58:06 <int-e> "digit 1", "digit 2", "empty" (yes, I should call it Z)
17:58:32 <int-e> (see the Nat class)
17:59:47 <quchen> int-e:  But then what does "Succ (D1 a) = D2 a" mean? That reads like "succ 1 = 10" to me, given what you just said.
18:00:07 <quchen> Or is the "1" in D1 just an arbitrary label
18:00:34 <int-e> the numbers are <empty>, 1, 2, 11, 12, 21, 22, 111, ...
18:01:13 <quchen> Ah, it's some sort of binary encoding
18:01:15 <frx> > map (^2) [0..]
18:01:16 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
18:01:23 <frx> > map (2^) [0..]
18:01:24 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:01:36 <quchen> You're doing that because the program logic is easier to state in that representation I assume?
18:01:44 <dagano> how to get at the 4 in Just 4?
18:01:59 <shachaf> How to get at the ??? in Nothing?
18:02:00 <int-e> quchen: e.g. D2 (D2 (D1 E))) = 122_2 = 1*4 + 2*2 + 2 = 10.
18:02:05 <arkeet> dagano: answer shachaf's question first.
18:02:08 <arkeet> and then try pattern matching.
18:02:25 <dagano> get at the value in a context
18:02:30 <dagano> Functor or Monad
18:02:47 <arkeet> see above.
18:02:48 <shachaf> I thought you were asking about Maybe.
18:02:55 <dagano> Maybe is a funcctor
18:03:00 <dagano> & monad yes?
18:03:04 <arkeet> sure, but that's not relevant.
18:03:29 <dagano> > join [[3]]
18:03:30 <lambdabot>   [3]
18:03:34 <shachaf> Maybe is many things.
18:03:44 <arkeet> most importantly, Maybe is Maybe.
18:03:47 <arkeet> so you can pattern match on it.
18:04:01 <shachaf> The most important things in life are trivial.
18:04:11 <kazagistar> join #C++
18:04:30 <arkeet> how to get at the (bin,etc,usr,...) in /bin/ls ?
18:04:51 <kazagistar> ....and I forgot a /
18:04:53 <kazagistar> awkward
18:05:07 <dagano> i get that I can pattern match on a Maybes
18:05:28 <shachaf> Then you're done.
18:06:11 <quchen> dagano: As a side note, there's no general way of getting a value "out of a context", that depends on the data type you're dealing with. Functor/Monad slone is not enough to do this.
18:06:14 <dagano> arkeet: good point ... i just thought there was a function to suck a value out of a context .. but what is 'a value' in the list context?
18:06:46 <joelteon> that's a good question
18:06:58 <shachaf> More importantly, "what is a context?".
18:07:01 <mescalinum> how to make all concatenations from a list of lists? i.e. [[a1,a2],[b1,b2]] should give [[a1,b1],[a1,b2],[a2,b1],[a2,b2]]
18:07:05 <arkeet> mescalinum: sequence
18:07:44 <Hafydd> How are those "concatenations"?
18:08:10 <doomlord_> i wonder if wings3d could be converted to haskell. (its erlang)
18:08:21 <dagano> shachaf: i just think of them as extensions to a type
18:08:22 * arkeet ignored the first sentence in the question
18:08:41 <shachaf> dagano: I asked what they are, though.
18:09:31 <dagano> shachaf: can't say
18:09:33 <applicative> mescalinum: and [[a1,a2],[b1],[]] ?
18:09:36 <shachaf> Is there a meaning to the word "context"? People certainly use it a lot.
18:10:10 <dagano> i assume there is a meaning depending on what you are talking about
18:10:19 <joelteon> yeah, you need to use context clues.
18:10:21 <joelteon> :P
18:10:23 <mescalinum> applicative: [a1:b1:[], a2:b1:[]]
18:10:32 <dagano> in a statement, I can have a modal context
18:10:35 <dagano> or a belief context
18:10:36 <Hafydd> @_@
18:10:37 <mescalinum> applicative: so, [[a1,b1],[a2,b1]]
18:10:42 <quchen> mescalinum: (:) is "cons", not "concatenation".
18:10:49 <arkeet> mescalinum: but the third list is empty.
18:10:56 <Hafydd> And [[],[a1,b1]]?
18:11:07 <arkeet> > sequence [[a,b],[c,d]]
18:11:08 <lambdabot>   [[a,c],[a,d],[b,c],[b,d]]
18:11:24 <arkeet> > sequence [[a],[b,c],[d,e,f]]
18:11:25 <lambdabot>   [[a,b,d],[a,b,e],[a,b,f],[a,c,d],[a,c,e],[a,c,f]]
18:11:26 <applicative> > sequence [[a,b],[c]]
18:11:26 <lambdabot>   [[a,c],[b,c]]
18:11:27 <arkeet> > sequence [[a],[b,c],[d,e,f],[]]
18:11:28 <lambdabot>   []
18:11:29 <mescalinum> sorry, you're right, the nested lists cannot be empty
18:11:52 <quchen> Huh?
18:12:07 <quchen> :t [] :: [[[Int]]]
18:12:08 <lambdabot> [[[Int]]]
18:12:19 <quchen> That's an empty triple-nested list.
18:12:29 <applicative> ?
18:12:32 <enthropy> shachaf: stuff to the left of => and probably a hundred other meanings
18:12:32 <quchen> For suitable definitions of "triple".
18:12:41 <applicative> mescalinum: so does sequence seem wrong?
18:13:05 <shachaf> enthropy: In particular I'm talking about the whole "monads are contexts" thing. As far as I can tell it's not a useful word here.
18:13:08 <mescalinum> nope. sequence does exactly what I was looking for:
18:13:21 <mescalinum> > sequence $ map tails $ group $ [a,a,b]
18:13:22 <lambdabot>   [[[a,a],[b]],[[a,a],[]],[[a],[b]],[[a],[]],[[],[b]],[[],[]]]
18:13:40 <int-e> so contexts are the new burritos.
18:14:15 <joelteon> > sequence [[a,b,c],[d,e,f]]
18:14:17 <lambdabot>   [[a,d],[a,e],[a,f],[b,d],[b,e],[b,f],[c,d],[c,e],[c,f]]
18:15:00 <quchen> int-e: I'm still decyphering your code :-D What are the Fizz/Buzz types, what numbers do they contain?
18:15:13 <int-e> quchen: ascii codes for strings to be printed
18:15:24 <quchen> Good thing I asked 8)
18:15:38 <dagano> shachaf: i've stolen it from talk in philosophy. joe believes that p is a belief context .. i then saw it on some haskell beginners tutorail..and i thought it made sense . maybe i'm way off
18:16:15 <dolio> shachaf: Need to whip out the new slogan.
18:16:20 <Hafydd> I found "computational context" to the best most useful first approximation of what a Monad is. What would you say instead?
18:16:58 <shachaf> dolio: Go for it.
18:17:57 <dolio> Monads are just algebras of the free monad monad.
18:18:02 <quchen> I never got the "context" explanation either. A box on the other hand I could picture.
18:18:16 <shachaf> I wish people would stop with the "box" nonsense.
18:18:27 <int-e> Hafydd: monad. I know of no analogy that doesn't break down for at least one of the state, maybe, list or continuation monads.
18:18:28 <shachaf> Better to say free monad monad algebras.
18:18:36 <Hafydd> Let's assume the audience doesn't know algebra.
18:18:44 <dolio> No, that's wrong.
18:18:44 <quchen> I wish people would stop calling analogies nonsense because they personally don't like them.
18:18:49 <dolio> Free monad monad monad algebras.
18:19:02 <dolio> Three monads.
18:19:12 <dolio> That's why they're called triples, right?
18:19:27 <Hafydd> int-e: for which of those does "computational context" break down?
18:19:27 <shachaf> Three monad monad monad algebras?
18:20:13 <int-e> Hafydd: I guess it doesn't, but only because the term has no actual meaning.
18:20:35 <Hafydd> I think it has a small amount of meaning.
18:20:59 <shachaf> @quote kmc "monad"
18:20:59 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
18:21:59 <dolio> That's okay. The people who talk about "containers" in type theory want you to forget everything you know about the word "container," too.
18:22:27 <Hafydd> Welcome to the shipyard. First, forget everything you know about containers.
18:22:43 <shachaf> Like slipcovers?
18:23:08 <int-e> actually "monad" is a nice term precisely because most people have no preconception about the word before they learn haskell (or category theory ...)
18:33:34 * hackagebot word8 0.0.4 - Word8 library  http://hackage.haskell.org/package/word8-0.0.4 (KazuYamamoto)
18:33:36 * hackagebot hermit 0.3.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.3.0.0 (AndrewFarmer)
18:33:56 <chrisdone> Hafydd: lol
18:36:15 <joelteon> is it possible to peek N characters using attoparsec?
18:36:20 <joelteon> or even parsec, i'll use that if i have to
18:39:47 <pavonia> joelteon: You mean look ahead without consuming?
18:49:47 <joelteon> yes
18:50:51 <mescalinum> > seq 13 where seq 1 = [1]; seq n = n : if even n then seq (n `div` 2) else seq 3 * n + 1
18:50:53 <lambdabot>   <hint>:1:8: parse error on input `where'
18:51:37 <mescalinum> > let seq 1 = [1]; seq n = n : if even n then seq (n `div` 2) else seq 3 * n + 1 in seq 13
18:51:38 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
18:53:17 <mescalinum> > let seq 1 = [1]; seq n = n : if even n then seq (n `div` 2) else seq (3 * n + 1) in seq 13
18:53:18 <lambdabot>   [13,40,20,10,5,16,8,4,2,1]
18:53:27 <mescalinum> gah, it's always parentheses giving me troubles
18:54:42 <pavonia> joelteon: attoparsec and Parsec both have lookAhead functions, with Parsec you can also get the current input stream directly, IIRC
18:55:31 <joelteon> attoparsec has peekChar
18:55:33 <joelteon> i need more than one
18:57:26 <MedDev> i'mn trying to profile a program with threadscope but running the program with the flag -la  ($>./MyProgram +RTS -N2 -la) doesn't log all events like it says it should here http://www.haskell.org/haskellwiki/ThreadScope_Tour/RTS
18:57:39 <arkeet> :t unfoldr
18:57:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:57:41 <MedDev> using ghc 7.4.1 is that the problem?
18:58:22 <arkeet> > unfoldr (\a -> guard (a == 1) <$ Just (a, if even n then n `div` 2 else 3*n+1)) 13
18:58:23 <lambdabot>   Could not deduce (GHC.Num.Num ()) arising from the literal `1'
18:58:23 <lambdabot>  from the co...
18:58:41 <arkeet> :t (<$)
18:58:41 <lambdabot> Functor f => a -> f b -> f a
18:58:57 <arkeet> > unfoldr (\a -> guard (a == 1) >> Just (a, if even n then n `div` 2 else 3*n+1)) 13
18:58:58 <lambdabot>   []
18:59:00 <arkeet> heh.
18:59:05 <arkeet> > unfoldr (\a -> guard (a /= 1) >> Just (a, if even n then n `div` 2 else 3*n+1)) 13
18:59:06 <lambdabot>   [13,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3...
18:59:11 <arkeet> oh oops.
18:59:16 <arkeet> > unfoldr (\a -> guard (a /= 1) >> Just (a, if even a then a `div` 2 else 3*a+1)) 13
18:59:17 <lambdabot>   [13,40,20,10,5,16,8,4,2]
18:59:21 <arkeet> oh well.
19:03:35 <adelbert_> could anyone take a look at this? http://pastie.org/private/mkgxecjsnqpemejyyg73sg i copied this off ch4 of real world haskell, ran it with 7.6.3 of ghc and doesn't seem to work. i was told some stuff in rwh may no longer work, wondering if this is one of those cases
19:03:38 <FreeFull> > (x^2 + 3) 0
19:03:39 <lambdabot>   Couldn't match expected type `a0 -> t0'
19:03:39 <lambdabot>              with actual type `Debu...
19:03:54 <FreeFull> > (id^2 + 3) 1
19:03:55 <lambdabot>   No instance for (GHC.Show.Show a0)
19:03:55 <lambdabot>    arising from a use of `M1354282387.sh...
19:04:20 <arkeet> adelbert_: your indentation is wrong.
19:04:22 <FreeFull> > (id^2 + 3) 3 'a'
19:04:23 <lambdabot>   No instance for (GHC.Show.Show a0)
19:04:23 <lambdabot>    arising from a use of `M306457723.sho...
19:04:34 <FreeFull> :t (id^2 + 3)
19:04:34 <arkeet> adelbert_: the inside of the do block must be indented at least as far as mainWith
19:04:34 <lambdabot> Num (a -> a) => a -> a
19:04:49 <FreeFull> :t (id^2 + 3) 4
19:04:50 <lambdabot> (Num (a -> a), Num a) => a
19:04:53 <arkeet> er
19:05:00 <arkeet> more than as far as.
19:05:03 <FreeFull> > (id^2 + 3) 4 :: Integer
19:05:04 <lambdabot>   No instance for (GHC.Num.Num
19:05:04 <lambdabot>                     (GHC.Integer.Type.Integer ...
19:05:20 <arkeet> FreakyPe1guin: no NumInstances.
19:05:21 <adelbert_> arkeet - aha. that did the trick
19:05:22 <arkeet> FreeFull: *
19:05:24 <FreeFull> I was pretty sure lambdabot had a Num instance for a -> b
19:05:25 <adelbert_> thanks!
19:05:32 <geekosaur> it did once
19:05:36 <geekosaur> it's gone
19:05:40 <arkeet> @let import Data.NumInstances
19:05:41 <lambdabot>  Defined.
19:05:49 <FreeFull> > (id^2 + 3) 4
19:05:50 <lambdabot>   19
19:08:18 <arkeet> @let import Control.Monad.Loops
19:08:19 <lambdabot>  Defined.
19:08:24 <arkeet> oh handy.
19:09:25 <arkeet> I forget what I was going to use it for.
19:10:14 <arkeet> @let next x | even x = x `div` 2 | True = 3*x+1
19:10:15 <lambdabot>  Defined.
19:10:20 <arkeet> > takeWhile (/= 1) $ iterate next 13
19:10:21 <lambdabot>   Ambiguous occurrence `next'
19:10:21 <lambdabot>  It could refer to either `L.next', defined at ...
19:10:24 <arkeet> ...
19:10:26 <arkeet> @undefine
19:10:26 <lambdabot> Undefined.
19:10:32 <arkeet> @let collatz x | even x = x `div` 2 | True = 3*x+1
19:10:34 <lambdabot>  Defined.
19:10:35 <arkeet> > takeWhile (/= 1) $ iterate collatz 13
19:10:43 <lambdabot>   [13,40,20,10,5,16,8,4,2]
19:11:55 <FreeFull> Is making a string x into a d-string as simple as doing  (++x) ?
19:12:02 <arkeet> (x++)
19:12:52 <arkeet> :t (++)
19:12:52 <lambdabot> [a] -> [a] -> [a]
19:12:56 <arkeet> :t Endo . mappend
19:12:57 <lambdabot> Monoid a => a -> Endo a
19:13:15 <arkeet> :t ($ mempty) . appEndo
19:13:15 <lambdabot> Monoid c => Endo c -> c
19:13:55 <shachaf> arkeet: So what about the (forall r. k b r -> k a r) thing?
19:13:59 <arkeet> I don't know!
19:14:21 <arkeet> @let improve = Endo . mappend; disprove = ($ mempty) . appEndo
19:14:21 <lambdabot>  .L.hs:139:18:
19:14:22 <lambdabot>      No instance for (Monoid a0) arising from a use of `mappen...
19:14:31 <arkeet> ugh, really
19:14:41 <FreeFull> Damn monomorphism
19:14:44 <arkeet> @let improve :: Monoid a => a -> Endo a; improve = Endo . mappend; disprove :: Monoid a => Endo a -> a; disprove = ($ mempty) . appEndo
19:14:45 <FreeFull> Give it type signatures
19:14:45 <lambdabot>  Defined.
19:14:46 <shachaf> I,I @let {-# LANGUAGE NoMonomorphismRestriction #-}
19:14:47 <arkeet> I know.
19:15:01 <arkeet> > (a <> b) <> c
19:15:02 <lambdabot>   (a <> b) <> c
19:15:10 <arkeet> > disprove $ (improve a <> improve b) <> improve c
19:15:13 <lambdabot>   a <> b <> c <> mempty
19:15:16 <FreeFull> > improve "lambdabot"
19:15:16 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo [GHC.Types.Char]))
19:15:17 <lambdabot>    aris...
19:15:22 <arkeet> :)
19:16:43 <FreeFull> Huh, my show instance does have the ++ the right way around
19:17:32 <arkeet> shachaf: you should figure out how to improve semigroups.
19:17:35 <FreeFull> show' x = ("toList "++) . showList (fromList x) $ ""    I know usually fromList would be  [a] -> Something a   but my type is called List
19:17:51 <arkeet> :t shows
19:17:52 <lambdabot> Show a => a -> ShowS
19:18:13 <shachaf> arkeet: ?
19:18:23 <arkeet> shachaf: (a <> b) <> c -> a <> (b <> c)
19:18:24 <FreeFull> Well, technically it's  Mu (ListF a)  and I had to enable FlexibleInstances
19:18:25 <arkeet> no mempty
19:18:35 <FreeFull> That reminds me, are there any bad downsides to FlexibleInstances?
19:18:37 <shachaf> Oh, "improve" in this sense.
19:18:40 <arkeet> FreeFull: not really.
19:18:54 * arkeet wonders what a good downside is
19:19:16 <FreeFull> arkeet: A downside that doesn't affect you, only your enemy
19:19:20 <arkeet> haha
19:20:06 <shachaf> > N a <> N b <> N c
19:20:09 <lambdabot>   N a â (N b â N c)
19:20:10 <shachaf> > (N a <> N b) <> N c
19:20:13 <lambdabot>   (N a â N b) â N c
19:20:17 <shachaf> :-(
19:20:47 <FreeFull> You could also say feet are the downsides of human bodies
19:20:51 <shachaf> arkeet: Would you be satisfied with accepting an argument for disprove?
19:21:08 <arkeet> no
19:21:09 <FreeFull> shachaf: â
19:21:14 <arkeet> you are free to use something other than Endo, however.
19:21:21 <shachaf> Too bad.
19:21:30 <arkeet> :t N
19:21:31 <lambdabot> a -> Nonoid a
19:21:37 <centrinia> Faces are parts of the downsides of human bodies that have tripped.
19:21:38 <FreeFull> ShowS is basically like Endo but not a newtype, and only for String
19:21:41 <shachaf> arkeet: Because data NonEmpty a = End a | Cons a (NonEmpty a)
19:22:00 <FreeFull> :t appN
19:22:00 <lambdabot>     Not in scope: `appN'
19:22:01 <lambdabot>     Perhaps you meant `app' (imported from Control.Arrow)
19:22:22 <shachaf> So if you're abstracting away the constructor, clearly you should take it as an argument.
19:22:25 <centrinia> NonEmpty is isomorphis to lists.
19:22:47 <enthropy> centrinia: what is [] for NonEmpty?
19:23:00 <centrinia> Uh, nonempty lists. :p
19:23:02 <FreeFull> End undefined
19:23:08 <shachaf> Thanks.
19:23:19 <shachaf> That would've made defining it much easier.
19:23:21 <FreeFull> It has the sameish type
19:23:35 <FreeFull> :t []
19:23:36 <lambdabot> [a]
19:23:39 <FreeFull> :t End undefined
19:23:40 <lambdabot>     Not in scope: data constructor `End'
19:23:40 <lambdabot>     Perhaps you meant `Endo' (imported from Data.Monoid)
19:23:57 <shachaf> arkeet: Anyway, that's (a -> r -> r) -> (a -> r) -> r if you abstract both, or (a -> r) -> r if you just abstract End.
19:24:00 <shachaf> So I'll use Cont!
19:24:18 <FreeFull> @let data NonEmpty a = End a | Cons a (NonEmpty a)
19:24:19 <lambdabot>  Defined.
19:24:21 <johnw> is there an implementation of Dijkstra algorithm for Data.Graph?  I'm looking for Vertex -> Vertex -> Graph -> [Edge]
19:24:24 <FreeFull> :t End undefined
19:24:25 <lambdabot> NonEmpty a
19:24:42 <FreeFull> See, [] is just a specialisation of End undefined
19:24:44 <arkeet> undefined is not allowed.
19:24:54 <arkeet> ;(
19:25:02 <FreeFull> End (fix id)
19:25:19 <arkeet> bottom is not allowed.
19:25:30 <shachaf> data NonEmpty = End Int# | Cons Int# NonEmpty
19:25:47 <FreeFull> arkeet: No bottoms?
19:25:53 <FreeFull> Not even head [] ?
19:25:54 <monoidal> probably !NonEmpty
19:26:22 <FreeFull> shachaf: Obviously everything is encodable as a list of Int#
19:26:42 <arkeet> data NonEmpty = Integer
19:26:44 <dolio> roconnor: I'm having trouble constructing an example that shows a difference between seqing a function and not seqing it.
19:26:44 <arkeet> oops.
19:26:50 <arkeet> you know what I mean.
19:26:53 <dolio> Any difference at all.
19:27:05 <johnw> I guess I'll use fpl
19:27:07 <johnw> fgl
19:30:03 <FreeFull> We should abolish all compiler-defined types other than Integer
19:30:11 <FreeFull> Let users define everything else
19:30:24 <Makoryu> type Maybe = Either Void
19:30:40 <Makoryu> No, wait, that's not what you're going for
19:31:14 <FreeFull> Also abolish data and type, leaving only newtype
19:31:30 <Makoryu> Great
19:32:02 <Makoryu> How would you do lists
19:32:22 <Makoryu> I'm sure there's a way to hack it into the type system
19:32:22 <arkeet> shachaf: I guess you could embed the semigroup into a monoid, Improve that, and then (scary partial function)
19:32:30 <shachaf> arkeet: Ew?
19:32:34 <arkeet> yes
19:32:43 <arkeet> not sure why I capitalized Improve.
19:32:44 <shachaf> (That was an elliott quote.)
19:33:12 <FreeFull> Makoryu: I think you could only do finite lists
19:33:25 <Makoryu> FreeFull: How would you even do those
19:33:36 <Makoryu> You don't have tuples now
19:33:59 <arkeet> shachaf: oh, I think I have a better one.
19:34:02 <FreeFull> Well, you can pack any finite-size data into an Integer
19:34:24 <Makoryu> Oh wait you could hard-code stuff as functions
19:34:43 <kazagistar> why would you use integers? Just have sets, its more pure that way
19:35:08 <Makoryu> Sets of what though
19:35:17 <arkeet> hmm
19:35:43 <FreeFull> newtype List = List Integer; nil = List 0; cons a as = as * (2^sizeof a) + a
19:36:07 <FreeFull> sizeof is part of a typeclass
19:36:13 <Makoryu> I guess you could pretend an empty set is (), wrap it with a newtype, and then....
19:36:46 <pavonia> FreeFull: What if a = Integer?
19:36:46 <FreeFull> Woops, forgot the List constructor for cons
19:37:02 <FreeFull> pavonia: Then sizeof a is infinite and you end up with bottom
19:37:20 <FreeFull> pavonia: Although Integer probably wouldn't be part of the Size typeclass
19:37:27 <Makoryu> FreeFull: How do you uncons, then
19:37:37 <Makoryu> I'm not following your thing very well
19:37:44 <FreeFull> Makoryu: You need to know the type of what you want to uncons
19:37:48 <pavonia> So you don't have lists of Integers anymore
19:38:01 <FreeFull> pavonia: You don't have any infinite structures
19:38:14 <Makoryu> Oh wait
19:38:19 <Makoryu> I get it now
19:38:59 <Makoryu> FreeFull: You're gonna implement an interpreter for this, right?
19:39:00 <arkeet> shachaf: ok.
19:39:02 <FreeFull> You could add a phantom type parameter to List so you can track your types though
19:39:05 <shachaf> arkeet: help
19:39:10 <shachaf> arkeet: What's your better one?
19:39:16 <FreeFull> So  newtype List a = List Integer
19:39:23 <arkeet> shachaf: I kinda don't like it but.
19:39:26 <arkeet> well maybe it's fine.
19:39:47 <arkeet> lpaste hello
19:39:48 <arkeet> http://lpaste.net/93234
19:39:55 <FreeFull> Makoryu: It's just modified Haskell
19:40:00 <lpvb> what happened to hpaste
19:40:15 <NemesisD> anyone know what's going on here? http://lpaste.net/93235
19:40:16 <arkeet> shachaf: ↑
19:40:21 <shachaf> That's weird.
19:40:25 <arkeet> it seems to work.
19:40:39 <FreeFull> @undef
19:40:39 <lambdabot> Undefined.
19:40:48 <FreeFull> @let newtype List a = List Integer
19:40:49 <lambdabot>  Defined.
19:40:56 <arkeet> hm, maybe it shouldn't be so strict.
19:41:50 <arkeet> hm, that didn't help.
19:42:19 <arkeet> oh
19:42:35 <FreeFull> @let nil :: List a; nil = List 0; cons :: Int -> List Int -> List Int; cons a as = List (as * (2^64) + a)
19:42:36 <lambdabot>  .L.hs:149:19:
19:42:36 <lambdabot>      Couldn't match expected type `Integer' with actual type `...
19:42:42 <arkeet> yeah.
19:42:48 <FreeFull> @let nil :: List a; nil = List 0; cons :: Int -> List Int -> List Int; cons a as = List (as * (2^64) + fromIntegral a)
19:42:49 <lambdabot>  .L.hs:149:19:
19:42:49 <lambdabot>      Couldn't match expected type `Integer' with actual type `...
19:42:53 <arkeet> I made everything too strict when it should be lazier.
19:43:14 <arkeet> shachaf: http://lpaste.net/revision/93236
19:43:32 <FreeFull> :t cons
19:43:33 <lambdabot>     Ambiguous occurrence `cons'
19:43:33 <lambdabot>     It could refer to either `L.cons',
19:43:33 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:149:1
19:43:37 <FreeFull> :t L.cons
19:43:37 <lambdabot> Int -> List Int -> List Int
19:43:45 <FreeFull> I can't define a proper cons without the right typeclasses
19:43:51 <FreeFull> But you understand what I mean, right?
19:45:20 <FreeFull> @let head' :: List Int -> Int; head' (List as) = fromInteger (as `rem` 64)
19:45:21 <lambdabot>  Defined.
19:45:55 <FreeFull> @let tail' :: List a -> List a; tail' (List as) = List (as `div` (2^64))
19:45:58 <lambdabot>  Defined.
19:46:57 <FreeFull> > let xs = L.cons 3 (L.cons 5 (L.cons 7 nil))) in (head xs,head (tail xs), head (tail (tail xs)), head (tail (tail (tail xs))))
19:46:58 <lambdabot>   <hint>:1:44: parse error on input `)'
19:47:02 <FreeFull> > let xs = L.cons 3 (L.cons 5 (L.cons 7 nil))) in (head xs,head (tail xs), head (tail (tail xs)), head (tail (tail (tail xs)))
19:47:03 <lambdabot>   <hint>:1:44: parse error on input `)'
19:47:22 <FreeFull> > let xs = L.cons 3 (L.cons 5 (L.cons 7 nil)) in (head xs,head (tail xs), head (tail (tail xs)), head (tail (tail (tail xs))))
19:47:23 <lambdabot>   Couldn't match expected type `[t0]'
19:47:23 <lambdabot>              with actual type `L.List G...
19:47:25 <arkeet> shachaf: http://lpaste.net/93237
19:47:31 <arkeet> seems lazy enough now.
19:47:51 <FreeFull> > let xs = L.cons 3 (L.cons 5 (L.cons 7 nil)) in (head' xs,head' (tail' xs), head' (tail' (tail' xs)), head' (tail' (tail' (tail' xs))))
19:47:54 <lambdabot>   (3,5,7,0)
19:48:11 <FreeFull> Proof of concept for Int, except it doesn't work for negative numbers
19:48:40 <FreeFull> It could work as long as you restrict Integer to be only positive and convert all your types properly
19:48:44 <arkeet> shachaf: the idea is to hang onto the rightmost thing in a big tree of <>s
19:48:54 <FreeFull> And you can tag your types to still keep some resemblance of safety
19:50:28 <FreeFull> Of course, for it to be practical, you'd need to put in some IO as well
19:56:10 <FreeFull> I am tempted to make IntegerPrelude now
19:57:24 <hiptobecubic> does arch linux no longer have a haskell-platform package?
19:59:11 <FreeFull> hiptobecubic: It doesn't, the haskell stuff is split into several packages
19:59:16 <geekosaur> stable versions seem to be anathema to them
19:59:45 <FreeFull> hiptobecubic: pacman -Ss haskell  should list all the haskell packages
19:59:57 <FreeFull> Just install the ones you feel you'll need
20:02:40 <hiptobecubic> geekosaur, so it seems :)
20:03:17 <NemesisD> am i the only one that prefers to install packages from cabal instead of the distro package manager
20:06:40 <FreeFull> Time to delve into RebindableSyntax
20:08:21 <enthropy> NemesisD: use waitForProcess instead?
20:08:36 <enthropy> regarding your System.Process issue earlier
20:09:23 <enthropy> on my system that makes a ExitFailure 15, which might be closer to what you're looking for
20:10:10 <NemesisD> enthropy: i need to not block in my case which is why i use getProcessExitCode
20:10:33 <enthropy> fork a thread to get the exitcode
20:10:55 <NemesisD> enthropy: really weird that you get an ExitFailure, what's wrong with my machine?
20:11:18 <NemesisD> enthropy: how would that help
20:11:33 <NemesisD> i realize the sleep is dumb but i should not be getting an exitSuccess
20:11:55 <NemesisD> this is for a test i'm writing, i don't really care so much about it being bad production code
20:12:01 <enthropy> the blocking would happen in that thread
20:13:01 <NemesisD> enthropy: i'm testing code that is supposed to kill a process, but in some cases it won't. waitForProcess isn't really the right thing to do, waitForProcess just needs to not return bogus values i think
20:17:32 <enthropy> NemesisD: I'm not really sure what's different between the getExitCode here http://lpaste.net/93235, and what a correct getProcessExitCode will do
20:18:59 <NemesisD> enthropy: that's bizarre, that does return 15 for me
20:19:17 <augustss> howdy
20:21:44 <chrisdone> augustss: hey. do you still have the source for your HBC compiler lying around? i can't find anything but dead links
20:21:58 <augustss> I believe I do.
20:22:40 <augustss> I'd have to see if it can still be compiled, somehow.
20:22:48 <FreeFull> How do I construct a value of type IO ?
20:23:06 <augustss> FreeFull: return works.
20:23:07 <chrisdone> augustss: does it bootstrap from another haskell compiler?
20:23:38 <FreeFull> augustss: Only if I have the Monad typeclass around
20:23:42 <augustss> chrisdone: No, it's written in LML, so it needs the LML compiler (which is the same as hbc) to bootstrap.
20:23:46 <FreeFull> But I'm trying to make my own Prelude
20:23:47 <joelteon> is it fold or traverse that you'd use to sum up the number of nodes in a tree that have an even value
20:24:14 <augustss> FreeFull: IO is magic, you can't really produce values of that type yourself.
20:24:34 <FreeFull> augustss: GHC.IO does export a constructor
20:24:40 <chrisdone> augustss: ah, heh. it's turtles all the way down
20:25:02 <FreeFull> I'm having kind problems though
20:25:11 <augustss> FreeFull: If you are willing to make it GHC specific then you can use GHC.IO.
20:25:34 <joelteon> or foldMap
20:27:01 <FreeFull> augustss: I'm getting kind errors though ):
20:28:11 <augustss> FreeFull: Well, that's because you made an error. :)
20:29:23 <FreeFull> augustss: I think I just need to look at what GHC uses for its Prelude
20:30:47 <enthropy> FreeFull: why can't you just import qualified Prelude?
20:31:38 <enthropy> chrisdone: here's a mirror it seems ftp://ftp.mimuw.edu.pl/mirror/ftp.cs.chalmers.se/pub/haskell/chalmers/
20:32:10 <FreeFull> enthropy: Won't that still import the Monad class unqualified?
20:32:33 <FreeFull> I guess I could try it
20:32:42 <enthropy> no why do you think so?
20:32:49 <chrisdone> enthropy: thanks!
20:34:04 <FreeFull> Huh
20:34:05 <FreeFull> No instance for (P.Monad IO) arising from a use of `P.>>='
20:34:44 <hiptobecubic> FreeFull, this should be updated then... http://www.haskell.org/platform/linux.html
20:34:58 <FreeFull> hiptobecubic: It's been like that for a while now
20:37:32 <qz> does ghci support doing :t on things with special chars like . or >> ?
20:37:35 <FreeFull> I can't find where the monad instance for IO is defined
20:37:49 <FreeFull> qz: Yes, wrap it in brackets
20:37:51 <FreeFull> :t (.)
20:37:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:37:54 <qz> oh
20:37:56 <qz> thanks
20:38:42 <arkeet> you can do that outside of :t too ;)
20:39:38 <FreeFull> Brackets turn an infix function into a normal function
20:40:42 <mm_freak_> haasn: currently offline
20:41:02 <qz> and `backticks` turn normal function into infix notation?
20:41:13 <Makoryu> qz: Yep
20:41:18 <Makoryu> :t zip `ap` tail
20:41:19 <lambdabot> [b] -> [(b, b)]
20:41:33 <pavonia> :t (`ap`)
20:41:34 <lambdabot> parse error on input `)'
20:41:40 <NemesisD> enthropy: now i don't believe the output with your code
20:41:55 <enthropy> you get something else?
20:42:02 <enthropy> how are you running it?
20:42:16 * enthropy used either ghci, or  ghc -threaded file.hs; ./file
20:42:36 <NemesisD> enthropy: so in my code i'm sending specific signals, with a program that handles SIGTERM successfully it is now always returning exit status of 15, but on the command line it returns 0
20:44:15 <FreeFull> Turns out the IO in the error message was my IO
20:44:42 <FreeFull> I probably shouldn't make my own IO though
20:46:08 <joelteon> @pl \a b -> a nn <|> b
20:46:08 <lambdabot> (<|>) . ($ nn)
20:47:07 <enthropy> NemesisD: then I guess something has to be changed with the process library, or how we're using it
20:47:31 <enthropy> maybe bring up the problem somewhere else (libraries@ ?)
20:49:26 <monoidal> > ((fromIntegral . floor) $ -5.467881373802522) :: Data.Word.Word8
20:49:27 <lambdabot>   250
20:49:43 <monoidal> Mac users: can you check whether the above line works in GHC 7.6 or causes a segfault?
20:49:55 <Makoryu> Sure, one moment
20:49:56 <joelteon> 250
20:50:00 <joelteon> looks good
20:50:27 <Makoryu> 250
20:50:43 <Makoryu> monoidal: I'm curious what prompted that
20:50:52 <monoidal> http://ghc.haskell.org/trac/ghc/ticket/7475
20:52:24 <Makoryu> I'm on 7.6.3
20:52:32 <Makoryu> VKS was on 7.6.1
20:52:33 <monoidal> 64bit?
20:52:36 <Makoryu> Yeah
20:52:49 <monoidal> I don't think there are changes in 7.6.x that could fix it
20:53:26 <monoidal> I mean, 7.6.3 and 7.6.1 should behave the same
20:54:15 <arkeet> has anyone else reproduced it?
20:55:20 <FreeFull> I'm tempted to do the mad thing and instead of using Integer, do unary naturals and call those Integer
20:55:26 <FreeFull> Because I'm too lazy to do binary
20:55:41 <Mdx> Can someone help me for a sec? I wanted to use GHCI to help me understand some  function composition and the results seem funny to me (http://lpaste.net/93241 - where did type b and c came from?!)
20:56:30 <arkeet> Mdx: t and a are type variables.
20:56:31 <FreeFull> I guess I could do something like a list of Word32
20:56:36 <monochrom> you have f.a, not f.g. what is a?
20:56:44 <monochrom> err, nevermind
20:56:58 <arkeet> Mdx: type variables can be freely renamed
20:57:10 <monoidal> Mdx: whether they are called "b" or "c", it doesn't really matter; the names stem from the type of (.) which has a,b,c
20:57:19 <arkeet> Mdx: try something like
20:57:29 <arkeet> data T; data A; let g = undefined :: T -> A; ...
20:58:00 <arkeet> Mdx: because right now, g is a function from any type to any other type.
20:59:42 <Mdx> monoidal hmmm i see
21:00:02 <Mdx> arkeet: Ohh thanks for the fix !
21:01:15 <arkeet> !!
21:01:16 <arkeet> http://www.haskell.org/pipermail/ghc-commits/2013-September/003548.html
21:01:41 <monochrom> nice
21:01:59 <monoidal> note that the first argument is the False case - somewhat logical but might be nonintuitive
21:02:00 <FreeFull> arkeet: :DDDD
21:02:19 <arkeet> monoidal: but that's the right way.
21:02:24 * arkeet foldr has its arguments backwards.
21:02:27 <FreeFull> Enum order
21:02:32 <monochrom> that is the True way
21:02:33 <FreeFull> :t foldr
21:02:34 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:02:38 <arkeet> :t flip foldr
21:02:38 <lambdabot> b -> (a -> b -> b) -> [a] -> b
21:03:40 <monochrom> consider (a -> b -> b) -> [a] -> b -> b :)
21:04:11 <monochrom> I love permutations. they are so shuffled.
21:04:15 <arkeet> that looks just weird.
21:04:21 <arkeet> :t flip . foldr
21:04:22 <lambdabot> (a -> c -> c) -> [a] -> c -> c
21:04:28 <arkeet> acc
21:04:37 <monoidal> it looks good, upgrades a -> b -> b to [a] -> b -> b
21:04:48 <arkeet> I like it.
21:04:49 <monoidal> more generally, Monoid m => (a -> m) -> [a] -> m
21:04:58 <arkeet> (a -> Endo c) -> [a] -> Endo c
21:04:59 <arkeet> yeah.
21:05:24 <arkeet> well, that's the right way to get foldr from foldMap anyway.
21:05:29 <arkeet> for Foldable in general.
21:05:29 <monochrom> yikes. when I am drunk, my random permutations are deep theoretical discoveries
21:05:36 <arkeet> haha
21:06:20 <Makoryu> :t (flip .)
21:06:21 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
21:06:32 <arkeet> :t flip . (flip .) . flip
21:06:33 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
21:06:38 <arkeet> :t (flip .) . flip . (flip .)
21:06:38 <lambdabot> (a1 -> b -> a -> c) -> a -> b -> a1 -> c
21:06:51 <arkeet> permutations =)
21:08:37 <Makoryu> Thought experiment: Implement a permute function that dispatches on lifted type arguments to index into arguments
21:17:00 <arkeet> I like the observation that:
21:17:10 <arkeet> adjacent transpositions generate the symmetric group. proof: bubble sort
21:17:30 <mangaba_leitosa> FreeFull, monoidal, Iceland_jack: btw, I forgot to mention how I mostly missed monads and stuff when learning Haskell. I learned it using introduction to functional programming by Bird & Wadler, which was based on Miranda, yet applies almost literally to Haskell. Every example from the book worked like a charm,
21:17:39 <mangaba_leitosa> yet the book never mentioned the word monad because Miranda did not have them
21:17:45 <edwardk> arkeet: hahahaha
21:17:54 <arkeet> is it that funny? :)
21:18:21 <edwardk> it is very succinct =)
21:18:26 <arkeet> :)
21:19:45 <mangaba_leitosa> edwardk: hi, I looked at the links you gave me about transforming trees. really good stuff :-)
21:20:14 <edwardk> =)
21:21:06 <arkeet> edwardk: do you happen to have thought about a purely functional solution to longest common subsequence?
21:21:51 <FreeFull> mangaba_leitosa: You could look at what Learn You A Haskell says about typeclasses, and eventually monads
21:22:13 <mangaba_leitosa> FreeFull: sure
21:24:54 <edwardk> arkeet: its typically done with dynamic programming, so a dynamorphism should do
21:29:02 <arkeet> edwardk: dynawhat
21:29:03 <arkeet> D:
21:29:28 <edwardk> http://math.ut.ee/~eugene/kabanov-vene-mpc-06.pdf
21:29:34 <edwardk> kabanov and vene
21:30:08 <Hodapp> huh, that is the paper I found when looking up what 'dynamorphism' means
21:30:10 <monochrom> onoes
21:30:27 <Rarrikins> What's a decent way to create a persistent http-conduit Manager the first time a connection is made without recreating it later?
21:30:35 <monochrom> next, we will have dinomorphisms too :)
21:32:06 <Rarrikins> I'm guessing tryPutMVar would be best.
21:32:46 <arkeet> I'm sorry I couldn't help but laugh at the variety of morphisms in the opening paragraph http://comonad.com/reader/2008/dynamorphisms-as-chronomorphisms/
21:34:18 <arkeet> oh heh, LCS is one of the problems in the intro there
21:35:45 <matthiasgoergens> Has anyone ever found a use for an Haskell equivalent of a object-relational mapper?  (And how would such a beast look like?)
21:35:50 <edwardk> chrono didn't turn out to be all that useful a box to put both histo and dyna in
21:36:01 <edwardk> er histo and futu
21:38:44 * hackagebot pipes-csv 1.1.0 - Fast, streaming csv parser  http://hackage.haskell.org/package/pipes-csv-1.1.0 (WilliamCasarin)
21:41:28 <beefcube> does anyone know how to effectively design and deal with a multiple monad/monad transformer types? I feel utterly bottlenecked in by the fact that I chose to use Either on many of my functions, so that is rippling out into having to use EitherT with Reader, State and so on
21:45:32 <beefcube> nevermind
21:49:55 <Rarrikins> Data.Global is nice :)
21:50:19 <NemesisD> sane child process management in haskell is a god damn mystery
21:51:25 <Makoryu> Anything that has crazy differences from one OS to the next is gonna be weird and awkward in some permutation of (language, platform)
21:51:46 <NemesisD> yeah except i don't care a lick about windows
21:57:22 <NemesisD> does anyone by chance know if haskell programs reserve exit status 15 for something
21:57:22 <applicative> oh, looks like i just missed augussts
21:57:38 <NemesisD> i can't find it documented anywhere in linux's signal headers
23:08:00 <Ghoul_> "yeah except i don't care a lick about windows" :(
23:08:12 <Ghoul_> aww, he left.
23:18:46 * hackagebot proj4-hs-bindings 0.1 - Haskell bindings for the Proj4 C dynamic library.  http://hackage.haskell.org/package/proj4-hs-bindings-0.1 (PavelPenev)
23:23:46 * hackagebot d3js 0.1.0.0 - Declarative visualization on a web browser with DSL approach.  http://hackage.haskell.org/package/d3js-0.1.0.0 (nebuta)
23:57:38 <wagle> what's the best emacs indentation for haskell?  (I guess I'm asking for a vote)
23:58:03 <zRecursive> 4 ?
23:58:08 * haasn .oO( futumorphism? I hope we don't arrive at futamorphisms )
