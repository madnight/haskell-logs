00:40:01 <jaya_>  /msg NickServ identify samtron
00:41:19 <jack_rabbit> lol
00:43:48 <shachaf> jaya_: Might want to change your nickserv password, if you haven't yet.
00:43:57 <jaya_> Changed
00:45:15 <jaya_> That was soo stupid :(
00:47:21 <pharaun> oyvey
00:47:26 <pharaun> sneaky space :)
00:49:11 <jaya_> yeah pharaun
01:23:58 <jaya_> >> :)
01:52:02 <b__> What's the proper way to treat Num a => [a] as Num a => a? Ie. I want to add [1, 3, 5] and 3 for some numeric type, as 'sum [1, 3, 5] + 3'
01:52:21 <b__> instance [MyType]?
01:53:07 <Ralith> what output do you expect from that?
01:53:33 <b__> 12
01:53:39 <Hafydd> (+) cannot have operands of different types.
01:53:46 <b__> ah right
01:54:55 <b__> I had a slightly similar problem once with concatting the results of parsers that would return Char, String, or [String]
01:55:17 <b__> I wrote a Stringy typeclass based on pointers of edwardk
01:55:29 <b__> This feels similar(ly stupid)
01:57:16 <b__> class Stringy a where stringy :: a -> String, instance Stringy Char where stringy = return, instance Stringy String where stringy = id, etc, utter silliness
01:57:33 <Ralith> b__: typeclasses are usually the wrong solution.
01:57:52 <Ralith> the right solution in this case, for example, is just calling 'sum'.
01:58:19 <b__> I agree, I'm probably trying to be too DSLy
01:58:43 <Ralith> being DSLy is fine, but this isn't how you do it
01:59:07 <b__> Half-assed DSLy I mean
01:59:17 <Ralith> indeed :p
01:59:47 <Hafydd> Define Some Lasagna
02:01:18 <b__> I should probably write a sensible API first, and then go Parsec with it
02:02:51 <jack_rabbit> or define some lasagna and dine.
02:08:46 <Zenol> Is there a way to tell in project.cabal I want the -Wall flag?
02:09:33 <supki> Zenol: yes,  ghc-options: -Wall
02:09:47 <supki> this need to be repeated for each section though
02:09:49 <Zenol> supki: oh, thanks.
02:11:43 <hape02> "A Predicate is a Contravariant Functor, because contramap can apply its function argument to the input of the predicate. "    Unfortuntely I did not yet understand why a predicate function is special in this case. I am missing a example where I can catch this intuitivly ;-) Any hints?
02:11:55 <hape02> a->Bool
02:14:25 <Zenol> I have a really strange link error.
02:14:30 <hpaste> Zenol pasted “link error” at http://lpaste.net/92628
02:14:55 <supki> hape02: it's not special
02:15:09 <supki> hape02: e.g. a -> Char is contravariant functor too
02:15:58 <hape02> supki: I can follow, that a -> Char is contravariant too, but why?
02:15:59 <supki> more generally; if  newtype T a b = T (b -> a)  then T a is a contravariant functor
02:16:30 <supki> hape02: because you can define  contramap :: (b -> a) -> (a -> Char) -> (b -> Char)
02:16:37 <supki> that obeys the (usual) laws
02:17:41 <hape02> supki: Ah, yes :-) Thx for the example!
02:24:11 <chalm> Hey, I've read several papers with suggestions for how to model open type classes in Haskell
02:24:23 <chalm> are there any plans on actually implementing them?
02:24:37 <chalm> Without having to result to something like in datatypes a la carte (compdata)
02:35:09 <git_> > print "hey guys"
02:35:10 <lambdabot>   <IO ()>
02:39:42 <mm_freak_> who would i contact to report a problem with lambda-the-ultimate.org?
02:39:57 <mm_freak_> ideally via IRC or jabber
02:40:26 <merijn> mm_freak_: I was going to look on the site for that info, but I see your problem :p
02:40:37 <git_> :)hahaha
02:40:41 <mm_freak_> ah, so it's not just me =)
02:40:49 <mm_freak_> ok, then it probably doesn't need reporting =)
02:41:48 * mm_freak_ wanted to find out what open type classes are
02:42:19 <merijn> Aren't haskell typeclasses already open?
02:42:32 <merijn> I'd much rather have the option to have closed typeclasses
02:42:52 <merijn> Or better yet, steal instance chains from Habit
02:42:52 <mm_freak_> i don't know what they are, so i can't answer that
02:43:10 <mm_freak_> judging from the search results they have something to do with dynamic typing
02:43:14 <chalm> no sorry, open functions
02:43:25 <mm_freak_> ok, what are open functions?
02:43:26 <merijn> mm_freak_: You know how the type checker complains about overlap because it can't prove some instance X doesn't exist?
02:43:37 <mm_freak_> merijn: sure
02:43:42 <chalm> the standard example is an expression Val | Add | Mul,..
02:43:45 <merijn> mm_freak_: Closed typeclasses let you tell GHC "there will never be another instance except these few"
02:43:57 <chalm> and later on you want to add Neg
02:44:00 <mm_freak_> merijn: what would those be good for given type families and fundeps?
02:44:07 <chalm> without having to recompile the others (basically solving the expression problem)
02:44:10 <mm_freak_> chalm: ah, open data types
02:44:13 <chalm> right
02:44:22 <merijn> mm_freak_: Fundeps are an ugly hack to approximate closed typeclasses
02:44:24 <chalm> messed that up :)
02:44:38 <mm_freak_> chalm: that's actually quite easy…  say you have a language that supports some primitives, but you don't want to constrain the set of possible primitives
02:45:05 <merijn> mm_freak_: fundeps let you deal with overlap, but they don't stop other from implementing instances for your class
02:45:09 <mm_freak_> data Exp p a = Add (Exp p a) (Exp p a) | Mul (Exp p a) (Exp p a) | IntLit Integer | Var a | Prim p
02:45:25 <merijn> mm_freak_: If you want to export a class, but not allow other instances than your own, you can't do that
02:45:29 <chalm> Yeah but that feels very hacky, and ends up being difficult to work with imo
02:45:55 <git_> ugh. i'm at the programming course at Uni. we're learning C#...
02:45:55 <mm_freak_> merijn: not sure what closed type classes would be useful for…  we have so may ways to express "we want only specific types here"
02:45:59 <git_> well at least C# LINQ is fun :)
02:46:00 <mm_freak_> merijn: like DataKinds for example
02:46:23 <mm_freak_> class C (a :: T)
02:46:51 <merijn> mm_freak_: oh, sure, you can probably actually implement all this with DataKinds and closed typefamilies
02:47:06 <merijn> mm_freak_: But closed typeclasses are *much* more likely to make it into the standard
02:47:19 <mm_freak_> chalm: why is that hacky?  it's actually a very clean way…  open data types would in fact be hacky, because they would destroy the "algebraic" in algebraic data types, and they wouldn't have any reasonable theoretical foundation
02:47:23 <merijn> mm_freak_: The whole GADT/existentials/typefamilies thing will be bikeshed for ages
02:47:43 <chalm> mm_freak_: well you'd have to declare the data type to be open
02:48:10 <mm_freak_> chalm: which effectively would mean, "could be anything"
02:48:11 <merijn> mm_freak_: atm they have no chance to make it in the standard, there is however, a fairly clear, unambiguous, conservative and backwards compatible way to introduce closed typeclasses
02:48:27 <mm_freak_> chalm: could just as well use Dynamic then =)
02:48:34 <chalm> :\
02:48:44 <chalm> For compilers, open data types are very nice
02:48:51 <merijn> mm_freak_: Also, those would eliminate the need to OverlappingInstances and FunDeps for mtl, in turn make all that more portable too
02:49:23 <mm_freak_> merijn: how would that eliminate the need for fundeps?
02:50:35 <merijn> mm_freak_: fundeps only exists to disambiguate the overlap in mtl, no overlap means no need for fundeps either
02:50:55 <mm_freak_> merijn: yes, but how would you solve it differently?  make MonadReader opaque?
02:50:57 <mm_freak_> uhm
02:51:02 <mm_freak_> … closed?
02:51:15 <supki> wait, mtl uses overlapping instances?
02:51:26 <mm_freak_> supki: not as far as i know
02:52:15 <merijn> oh, wait
02:52:30 <merijn> my bad, I'm confusing undecidable with overlapping
02:52:40 <merijn> ok, maybe it won't help with mtl
02:52:45 <mm_freak_> nope =)
02:52:46 <merijn> mm_freak_: http://dl.acm.org/citation.cfm?id=1863596
02:53:16 <tomejaguar> What does @ mean in GHC core?
02:53:18 <mm_freak_> merijn: the point is, if a type class is closed, it probably shouldn't be a type class in the first place
02:54:43 <mm_freak_> merijn: sometimes people ask for optional constraints on type classes, to which my response is:  you probably don't want type classes at all
02:55:08 <mm_freak_> instances are global and open…  it is simply wrong to assume that no other instances exist
02:55:57 <merijn> mm_freak_: What do I want instead, then?
02:56:08 <merijn> tomejaguar: I think that refers to types? Not sure, though
02:56:45 <mm_freak_> merijn: types and functions
02:57:08 <tomejaguar> merijn: Seems to be list append, or similar.
02:58:50 <fser> Hi there
02:58:54 <tomejaguar> Core seems to be in polish notation
02:59:04 <fser> I'm learning haskell reading http://learnyouahaskell.com
03:01:23 <fser> I'm wondering wether it's possible to have a function mymax lst using something like let max = if max > x then max else x in x <- lst
03:03:31 <mm_freak_> fser: no, that doesn't work
03:04:23 <mm_freak_> fser: first write a separate function for determining the maximum of two values given as arguments, then use that function to traverse a list element by element
03:05:52 <arkeet> @let newtype Max a = Max { getMax :: a } deriving (Show,Eq,Ord)
03:05:54 <lambdabot>  Defined.
03:06:13 <arkeet> oops.
03:06:34 <arkeet> @undefine
03:06:34 <lambdabot> Undefined.
03:06:46 <merijn> arkeet: Defining a Max monoid doesn't seem particularly simple and helpful for a beginner :p
03:06:50 <arkeet> :p
03:07:29 <arkeet> but there's no mempty.
03:08:21 <merijn> Sure there is, just constraint a to be Bounded and use minBound
03:08:41 <quchen> arkeet: mempty = fix succ ;-)
03:08:55 <arkeet> =(
03:09:02 <arkeet> fine.
03:09:08 <arkeet> @let newtype Max a = Max { getMax :: a } deriving (Show,Eq,Ord)
03:09:09 <lambdabot>  Defined.
03:09:41 <arkeet> @let instance (Ord a,Bounded a) => Monoid (Max a) where mappend = max; mempty = Max minBound
03:09:42 <lambdabot>  Defined.
03:10:18 <arkeet> > getMax $ foldMap Max "fser"
03:10:23 <lambdabot>   's'
03:10:39 <mm_freak_> Max can be a Semigroup without the Bounded constraint
03:10:43 <arkeet> I know.
03:10:53 <mm_freak_> also i don't think that mempty = minBound is such a sensible thing to have
03:11:01 <arkeet> I know.
03:11:02 <arkeet> =(
03:11:04 <arkeet> but whatever.
03:11:09 <merijn> mm_freak_: But foldMap relies on Monoid, I think so semigroup doesn't get you very far
03:11:14 <mm_freak_> i'd find it better for the minimum of an empty list to be undefined
03:11:24 <arkeet> but you couldn't use undefined in a fold.
03:11:32 <arkeet> I'd rather use some Maybe thing.
03:11:35 <mm_freak_> you could use NonEmptyList
03:11:39 <arkeet> I could.
03:11:40 * merijn gives arkeet a cookie for most succesful "overkill" solution
03:11:48 <quicksilver> data Below a = Bottom | Below a
03:12:06 <mm_freak_> hah
03:12:09 <quicksilver> instance Ord a => Monoid (Max (Below a))
03:12:09 <merijn> Does no one here have real work to do? :p
03:12:11 <quicksilver> etc.
03:12:17 <arkeet> @undefine
03:12:17 <lambdabot> Undefined.
03:12:21 <quicksilver> do I get a cookie for extra overkill?
03:12:26 <mm_freak_> merijn: haskell is my real work =P
03:12:30 <merijn> quicksilver: I ran out of cookies :(
03:12:36 <quicksilver> hot damn
03:12:52 <mm_freak_> quicksilver: you call that overkill?  type Below a = forall b. b -> (a -> b) -> b
03:13:08 <arkeet> @let newtype Max a = Max { getMax :: Maybe a } deriving (Show,Eq,Ord)
03:13:09 <lambdabot>  Defined.
03:13:21 <arkeet> @let instance Ord a => Monoid (Max a) where mappend = max; mempty = Max Nothing
03:13:22 <lambdabot>  Defined.
03:13:23 * mm_freak_ is waiting for the first to provide a type-level solution
03:13:26 <arkeet> > getMax $ foldMap Max "fser"
03:13:27 <lambdabot>   Couldn't match type `GHC.Types.Char' with `Data.Maybe.Maybe a0'
03:13:27 <lambdabot>  Expected t...
03:13:29 <arkeet> oops.
03:13:33 <arkeet> > getMax $ foldMap (Max . Just) "fser"
03:13:37 <lambdabot>   Just 's'
03:13:41 <arkeet> > getMax $ foldMap (Max . Just) ""
03:13:45 <lambdabot>   Nothing
03:13:48 <arkeet> bleh.
03:14:02 <arkeet> > maximum "fser"
03:14:03 <lambdabot>   's'
03:14:15 <arkeet> maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe aSource
03:14:18 <arkeet> heh, Endo Endo.
03:14:32 <arkeet> alright, bedtime.
03:15:01 <mm_freak_> :t foldl' (\x y -> fmap (min y) x) Nothing
03:15:02 <lambdabot> Ord b => [b] -> Maybe b
03:15:27 <merijn> Did anyone actually answer fser's question yet? >.>
03:15:45 <mm_freak_> i did…  not sure it came across though =)
03:15:46 <merijn> Or was it a bit unclear what that was?
03:16:32 <arkeet> mm_freak_: good, now write minimum.
03:16:33 <arkeet> :c
03:16:34 <Zenol> If someone have any knowledge around linking errors that can occure using GHC with shared libraries... :)
03:16:46 <tomejaguar> Oh i see what @ is now
03:16:49 <tomejaguar> It's type application
03:16:51 <mm_freak_> :t foldl1' min
03:16:52 <lambdabot> Ord a => [a] -> a
03:17:26 <mm_freak_> Zenol: a question would be useful =)
03:17:52 <Zenol>  < hpaste> Zenol pasted “link error” at http://lpaste.net/92628 :p
03:18:19 <Zenol> Was wondering what this 'relocation R_X86_64_PC32 against undefined symbol' means.
03:18:45 <Zenol> The error appared when I moved my lens from the place where they are used to a separated module.
03:18:48 <merijn> Zenol: What OS? What architecture? Which compiler? WHich linker?
03:19:17 <Zenol> Archlinux, GHC 7.6.3, er, linked I don't know which is the default one..
03:19:41 <Zenol> also, 64-bits.
03:20:26 <supki> Zenol: did you add that module to  other-modules:  section?
03:20:34 <fser> thanks anyway :)
03:20:42 <Zenol> supki: X.X
03:20:43 <mm_freak_> i'm stunned that nobody noticed the bug in my Maybe-based 'minimum' =)
03:20:45 <fser> so <- is limited in list expansion
03:20:47 <mm_freak_> quiz: what's the error?
03:21:00 <mm_freak_> :t foldl' (\x y -> fmap (min y) x) Nothing
03:21:01 <lambdabot> Ord b => [b] -> Maybe b
03:21:14 <mm_freak_> hint: it's subtle =)
03:21:17 <Zenol> supki: It's probably that. Thanks...
03:21:48 <donri> mm_freak_: always Nothing?
03:21:50 <int-e> mm_freak_: it's nothing.
03:21:58 <mm_freak_> hehe
03:22:38 <int-e> > Nothing < Just ()
03:22:39 <lambdabot>   True
03:22:45 <int-e> pity ;)
03:22:59 <mm_freak_> :t foldl' (\x y -> fmap (min y) x <|> Just y) Nothing
03:23:00 <lambdabot> Ord a => [a] -> Maybe a
03:23:09 <mm_freak_> still has a bug…  even more subtle =)
03:24:54 <int-e> :t (<|>)
03:24:56 <lambdabot> Alternative f => f a -> f a -> f a
03:25:23 <mm_freak_> > foldl' (\x y -> fmap (min y) x <|> Just y) Nothing "fser"
03:25:25 <lambdabot>   Just 'e'
03:26:09 <mm_freak_> it's of the kind of bugs for which haskell's type system is no cure =)
03:27:41 <SrPx> What if unix was coded in Haskell...
03:27:57 <mm_freak_> hello to you too =P
03:28:08 <SrPx> hi (:
03:28:12 <SrPx> good morning
03:28:22 <int-e> mm_freak_: I don't know what you're after.
03:28:34 <donri> i don't know what the code is *meant* to do
03:28:41 <mm_freak_> finding the minimum
03:28:48 <mm_freak_> a safe 'minimum'
03:28:48 <donri> but why involve Maybe?
03:28:56 <mm_freak_> because the minimum may not exist
03:28:57 <int-e> > minimum []
03:28:58 <lambdabot>   *Exception: Prelude.minimum: empty list
03:29:01 <donri> ah
03:29:12 <mm_freak_> foldl' (+) 0 [1..]
03:29:13 <mm_freak_> result?
03:29:40 <donri> is that the new bug? that a list may not be finite?
03:30:00 <mm_freak_> donri: it's related
03:30:01 <int-e> is that a bug?
03:30:11 <int-e> > minimum $ repeat False
03:30:13 <mm_freak_> obviously it gives Just ⊥ for an infinite list
03:30:20 <lambdabot>  Terminated
03:30:30 <mm_freak_> foldl' (+) 0 [1..] :: Int
03:30:32 <mm_freak_> space usage?
03:30:42 <mm_freak_> O(1) or O(t)?
03:30:59 <notdan> lispy, carter: thanks for the advice! I still wonder which subdomain do I choose, if I apply. I think chrisdone wanted to get paste.haskell.org
03:31:28 <donri> O(1) because it's strict? i dunno!
03:31:33 <mm_freak_> yeah
03:31:35 <mm_freak_> foldl' (\x y -> fmap (min y) x <|> Just y) Nothing [1..] :: Maybe Int
03:31:38 <mm_freak_> space usage?
03:32:27 <int-e> @type ap ((>>) . maybeToList) (return . minimum)
03:32:29 <donri> i feel you want me to say O(t) but i'm not sure i understand why :)
03:32:32 <lambdabot>     Couldn't match type `Maybe a0' with `[b0]'
03:32:32 <lambdabot>     Expected type: Maybe a0 -> [b0]
03:32:32 <lambdabot>       Actual type: [b0] -> [b0]
03:33:14 <mm_freak_> well, Just 3 :: Maybe Int can be THUNK, Just THUNK or Just 3
03:33:16 <int-e> @type ap ((>>) . listToMaybe) (return . minimum)
03:33:18 <lambdabot> Ord b => [b] -> Maybe b
03:33:33 <donri> :t spoon . minimum
03:33:35 <lambdabot> Not in scope: `spoon'
03:33:37 <donri> :(
03:33:39 <mm_freak_> given an unevaluated let x = Just 3 in x `seq` ()
03:33:42 <mm_freak_> what does x now look like?
03:33:55 <mm_freak_> (when you evaluate the ())
03:34:22 <donri> Just _ ?
03:34:27 <mm_freak_> yeah
03:34:30 <mm_freak_> that's the bug
03:34:31 <donri> whnf?
03:34:35 <mm_freak_> foldl' evaluates to WHNF
03:34:44 <int-e> a space leak. fine.
03:35:01 <mm_freak_> so it evaluates up to the Just, but the argument will still be an infinite unevaluated expression
03:36:16 <donri> <|> Just $! y ?
03:36:42 <mm_freak_> that's not enough (ignoring the precedence error)
03:37:01 <mm_freak_> fmap' f = maybe Nothing ((Just $!) . f)
03:37:14 <donri> guess we need a <$!> :)
03:37:32 <mm_freak_> which is not possible without fmap' in Functor =)
03:39:10 <donri> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/Data-Strict-Maybe.html :)
03:39:32 <donri> but then it's not "really" Maybe anymore
03:40:08 <quicksilver> I'm not sure I agree with the caveat "Note that strict Maybe is not a monad"
03:40:29 <quicksilver> I don't think monad laws can ever be taken to work correctly in the presence of _|_
03:40:32 <merijn> blah, blah, bottom, blah, blah
03:40:37 <merijn> quicksilver++
03:40:48 <quicksilver> all we require of equations is that they hold when both sides are fully defined, normally
03:42:30 <mm_freak_> i think that laws can actually respect bottom when they require all functions and constructors to be strict, but that's a bad requirement
03:42:48 <mm_freak_> then after all ⊥ is really just a fixed point
04:04:11 <hpaste> danilo2 pasted “nested runStateT question” at http://lpaste.net/92630
04:04:59 <danilo2> Hi! I've got a little question. Is ti possible to create function "test" in RWS Monad, which will call itself recursively (see the example) - each time creating new State (so using something like runStateT), but be able to modify the Writer monad?: http://lpaste.net/92630
04:05:35 <hpaste> danilo2 revised “nested runStateT question”: “No title” at http://lpaste.net/92630
04:06:50 <merijn> danilo2: test and test2 have no types
04:07:52 <danilo2> merijn: Of course, but if you remove line 25 (test $ i-1) everything orks - all the types needed are there and type inferencer shoudl do the work.
04:08:29 <danilo2> merijn: I dont think it is no type problem, because the compiler complains about infinite type
04:08:33 <merijn> danilo2: I meant "I (and probably many others) can't be arsed to figure out wtf you're doing if there's no types to tell me"
04:09:06 <danilo2> merijn: ah Ok - brb
04:10:01 <jmcarthur> quicksilver: it is the case, though, that if return _|_ >>= f = _|_ doesn't hold it does make reasoning about your code more difficult.
04:10:04 <merijn> danilo2: For two reasons: 1) when annotating the types frequently what goes wrong becomes obvious and 2) having to figure out complex types from code is annoying
04:10:49 <jmcarthur> i might normally expect     return x >>= const m = m
04:10:55 <jmcarthur> for example
04:11:24 <quicksilver> jmcarthur: generally perhaps
04:11:38 <elliott> jmcarthur: um, I think you need an extra negation somewhere
04:11:39 <quicksilver> jmcarthur: in this exact case I think you'd understand pretty well that you can't hide _|_s in the strict maybe monad
04:11:44 <quicksilver> jmcarthur: it's kind of the point :)
04:12:13 <quicksilver> jmcarthur: but I generally don't expect to reason about _|_s, I expect not to use them.
04:12:59 <jmcarthur> i write polymorphic code a lot, assuming that the monad laws hold true
04:13:11 <jmcarthur> i don't always know what monad will be used. i just assume it will be a monad
04:14:20 <quicksilver> yup
04:14:43 <quicksilver> but if your polymorphic code turns into _|_ because someone instantiated it into the strict maybe monad
04:14:50 <quicksilver> I don't think that seems unexpected at all.
04:15:00 <quicksilver> good polymorphic code doesn't do anything useful with _|_
04:15:11 <danilo2> merijn: I do not know how to type this example ... I was trying to do this, but hmm, the idea is simple: "test" is in Monad RWS, it calls "test2" with new State, but should allow it to modify the Writer Monad.
04:15:12 <quicksilver> and I'm sure there are lots of other cases where this might happen
04:15:25 <jmcarthur> the example i used above can be polymorphic
04:15:40 <jmcarthur> :t \x m -> return x >>= const m
04:15:41 <lambdabot> Monad m => a -> m b -> m b
04:15:41 <hpaste> danilo2 revised “nested runStateT question”: “No title” at http://lpaste.net/92630
04:15:46 <quicksilver> jmcarthur: yes, I know.
04:16:04 <danilo2> merijn: I modified the example and added few types: http://lpaste.net/92630
04:16:16 <quicksilver> you'll need to step back a bit to convince me there is a real problem here
04:16:34 <quicksilver> or that the problem is any worse than all the other equational reasoning problems we have with _|_
04:16:47 <quicksilver> (look at the monad laws for the state monad and the difference between _|_ and \_ -> _|_)
04:17:00 <quicksilver> the solution is easy - just don't use _|_.
04:18:10 <quchen> quicksilver: State violates the Monad laws?
04:18:22 <quchen> quicksilver: (In the presence of bottom)
04:18:45 <elliott> so does Reader
04:18:56 <jmcarthur> one can also use _|_ to informally reason about operational semantics (to answer questions about whether something will be evaluated). i think that's pretty important. in polymorphic code, all i have to go on are the laws advertised by the interfaces i'm using.
04:19:23 <quicksilver> quchen: not in what I personally consider "important" ways.
04:19:36 <quicksilver> jmcarthur: equational transformations often lose information about what is evaluated.
04:19:43 <quicksilver> the GHC optimiser itself does this from time to time.
04:19:58 <quicksilver> whilst this is a real problem I'm not convinced data.strict.maybe makes it worse
04:20:06 <quchen> quicksilver: Which law is broken by State? (And Reader)
04:20:31 <elliott> quchen: const _|_ =/= _|_
04:20:33 <elliott> rest left as an exercise :)
04:21:31 <jmcarthur> elliott: i don't see where i need an extra negation
04:21:44 <quchen> That would be "return x >>= f" violated then
04:21:50 <ciaranm> jmcarthur: you don't not need one
04:22:33 <elliott> jmcarthur: not having return _|_ >>= f = _|_ is confusing, because you expect return x >>= const m = m
04:22:37 <elliott> jmcarthur: yet the former is required to have the latter
04:22:57 <danilo2> Could somebody please loook at the example: http://lpaste.net/92630 ? I want simply to create function "test" which writes logs and has a state and call from it function "test2" , which writes to THE SAME Writer, but has separate state. Additional "test2" should call "test" recursively.
04:23:31 <jmcarthur> elliott: "if return _|_ >>= f = _|_ doesn't hold"  <-- has a negation
04:23:43 <quchen> danilo2: Same writer/different state sounds like you want a StateT/StateT/WriterT stack in the general case.
04:24:01 <elliott> jmcarthur: yes, if it DOESN'T hold then reasoning is more difficult, is what you said
04:24:08 <jmcarthur> right
04:24:08 <elliott> jmcarthur: you gave an example: you'd expect return x >>= const m = m
04:24:22 <elliott> jmcarthur: but if return _|_ >>= f = _|_, then fill in x = _|_ in your example
04:24:42 <danilo2> quchen: Could you please look at the example? The compiler complains it cannot construct recursive type (if you enable line 30)
04:24:44 <jmcarthur> that was exactly intended to exemplify my claim
04:24:56 <danilo2> quchen: I'm trying to do this this way
04:25:06 <jmcarthur> when the former doesn't hold, neither does the latter, which i claim is confusing
04:26:15 <elliott> jmcarthur: wat
04:26:15 <quchen> danilo2: "put $ state {val=1+val state}" is pretty odd, you're setting the state to a new State value. So the state of your function is another State?
04:26:22 <elliott> jmcarthur: let's say (return _|_ >>= f = _|_) holds
04:26:24 <elliott> (you say this is good)
04:26:31 <elliott> therefore (return _|_ >>= const m = _|_) holds
04:26:32 <jmcarthur> no
04:26:48 <jmcarthur> bah
04:26:51 <jmcarthur> i see what went wrong
04:26:53 <elliott> therefore (return x >>= const m = m) doesn't hold (by filling in x = _|_)
04:26:59 <elliott> (but you said this is bad!)
04:27:01 <quchen> danilo2: Instead of threading along another State in a State you should really be using a double State stack
04:27:03 <jmcarthur> i copied that property from something quicksilver said, which i misinterpreter
04:27:06 <jmcarthur> *misinterpreted
04:27:18 <danilo2> quchen: this is veery limited example - this function puts a state and can call **another** function, which uses its state. Right now the state it sets is not used, but could be.
04:27:27 <jmcarthur> i meant the actual monad law
04:27:47 <jmcarthur> it wasn't my english, it was my math
04:28:00 <danilo2> quchen: the idea is, that "test" calls "test2" with empty state. And "test2" can modify it, do whatever it likes, but should write to the same writer.
04:28:41 <danilo2> quchen: Additional the recursive functions are written only to show the problem. Normally they call themselves based on some conditions (it is used in a compiler generating code)
04:28:48 <jmcarthur> elliott: i meant to use  (return _|_ >>= f = f _|_)
04:29:14 <elliott> right, okay
04:29:15 <elliott> that makes more sense :P
04:32:28 <danilo2> quchen: but double state stack is not enough - the "test" can in some cases call "test2" with new states the third, fourth, fifth etc time
04:33:11 <quchen> danilo2: You basically want to fork new States with a shared log?
04:33:25 <danilo2> quchen: exactly
04:36:11 <jmcarthur> elliott: i don't see how  const _|_ =/= _|_  means Reader violates the monad laws
04:36:48 <elliott> undefined >>= return = const undefined
04:38:29 <danilo2> quchen: Is it doable somehow (this state forking)?
04:39:04 <jmcarthur> elliott: ah, this is because we can distinguish _|_ and const _|_ using seq
04:39:21 <elliott> people use this to prove "IO isn't a monad" every now and then
04:39:23 <elliott> which is silly.
04:39:39 <jmcarthur> i think it's seq that's wrong in this case ;)
04:39:42 <quchen> danilo2: I can't come up with a pretty solution. You could give each new State a new Writer, and when you run that StateWriter incorporate the Writer's log into the parent's Writer.
04:40:06 <danilo2> quchen: Ok, but the logs can be long, so it could easly become slow :(
04:40:14 <quchen> danilo2: DList?
04:40:37 <quchen> You're using list-based logs for Writer right now, which is usually not a good idea
04:41:09 <danilo2> quchen: Ok, that should work. I understand it cannot be made prettier? :(
04:41:16 <jmcarthur> quchen: which is really a shame, since lists are probably the most obvious candidate to use with Writer :(
04:41:28 <quchen> danilo2: *I* cannot make it any prettier right now.
04:42:05 * hackagebot holey-format 1.0.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/holey-format-1.0.0 (ChrisDone)
04:42:07 * hackagebot holey-format 1.1.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/holey-format-1.1.0 (ChrisDone)
04:42:37 <jmcarthur> it just occurred to me that applying codensity to a writer monad probably fixes the problem
04:42:46 <quchen> jmcarthur: Assuming String is the most obvious candidate for writing stuff, which is another shame
04:42:51 <jmcarthur> as an alternative to use dlist
04:43:03 <danilo2> quchen: Ok, thank you :) I'll ask here though the second time - maybe somebody has any better idea. I wanted to simply not use this solution and was searching for something prettier :)
04:43:09 <quchen> I don't know what a Codensity is :-(
04:43:56 <jmcarthur> http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/Control-Monad-Codensity.html
04:43:58 <danilo2> So maybe somebody has an idea - Is it possible in haskell to "fork" new States with a shared "log" (in Writer Monad)?
04:44:17 <jmcarthur> not sure what that one was the first in google
04:44:28 <jmcarthur> i would have thought some edwardk package would have been the top one
04:44:46 <jmcarthur> danilo2: with concurrency?
04:45:05 <quchen> jmcarthur: No, just State+Writer.
04:45:19 <jmcarthur> i mean what does "fork" mean here?
04:45:21 <quchen> He wants to create new State objects inside States (that's what I called "forking")
04:45:22 <danilo2> jmcarthur: No, I want to simply being in State Monad call a new function with separate state: see: http://lpaste.net/92630
04:45:45 <jmcarthur> ah, like reader's "local" function or something
04:46:03 <quchen> CODENSITY HAS NO APPLICATIVE
04:46:11 <quchen> >:-C
04:46:22 <jmcarthur> quchen: that one doesn't. as i said, that isn't the package i really wanted to link to, but it came up first in google
04:46:26 <danilo2> jmcarthur: something like that - simply create empty state for new function call, but share the writers log
04:46:44 <jmcarthur> danilo2: maybe you could put a backtracking monad like LogicT under your StateT
04:46:46 <Ghoul_> mannn, haskell cool crew in euler 13
04:46:57 <quchen> Ghoul_: ?
04:47:04 <Ghoul_> the answer to euler 13 is literally
04:47:10 <Ghoul_> main = print $ sum numbers
04:47:15 <Ghoul_> Because we have Integer :)
04:47:23 <jmcarthur> danilo2: yeah so perhaps something like   StateT s (LogicT (Writer w))
04:48:15 <jmcarthur> anyway, i gotta go, so i can't go into detail right now. sorry
04:48:24 <ciaranm> project euler considered harmful
04:48:37 <Ghoul_> ciaranm: ? :O
04:48:56 <ciaranm> Ghoul_: it encourages a voodoo haxx approach to mathematics
04:49:10 <danilo2> jmcarthur: This sound interesting. I would be very hankful for any working exampel with it. I do not yet completely get how can I use it.
04:49:14 <Ghoul_> lol
04:49:25 <jmcarthur> danilo2: another possibility would be to just use runState directly
04:49:29 <jmcarthur> *runStateT
04:49:42 <jmcarthur> danilo2: that would allow you to feed in whatever state you want
04:50:02 <jmcarthur> danilo2: then you get back a Writer a, and you can lift that into your current state monad
04:50:17 <danilo2> jmcarthur: It is not possible, since I want these functions to call recursively (it is part of the compiler code generation) - the simplified exampel is here: http://lpaste.net/92630
04:50:23 <jmcarthur> anyway, really gotta go now
04:50:29 <hpaste> danilo2 revised “nested runStateT question”: “No title” at http://lpaste.net/92630
04:50:38 <jmcarthur> i don't think that doesn't allow you to call recursively
04:50:45 <jmcarthur> sorry... bye
04:50:53 <danilo2> no problem
04:50:54 <danilo2> bye :)
04:50:56 <danilo2> thank you :)
04:52:06 * hackagebot holey-format 1.2.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/holey-format-1.2.0 (ChrisDone)
04:52:26 <quchen> There should be a Project Euler problem that encourages idiomatic Haskell. You have to look for the possibility to use >>= with a magnifying glass otherwise.
04:52:44 <quchen> concatMap makes a good excuse.
04:54:29 <Ghoul_> is there a version of fix that produces a list of all the intermediate things?
04:54:55 <ciaranm> :t iterate
04:54:56 <lambdabot> (a -> a) -> a -> [a]
04:55:03 <ciaranm> might be what you want
04:55:15 <Ghoul_> ah, thanks
04:57:06 * hackagebot labyrinth 0.4.0.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.4.0.0 (AlexeyKotlyarov)
04:57:12 <Ghoul_> oh iterate isn't quite what I want
04:57:18 <Ghoul_> it doesn't have a short circuit I don't think
04:57:38 <quchen> Add a "takeWhile <results differ>".
04:57:57 <Ghoul_> good idea
04:58:44 <elliott> bad idea, duplicates work
04:59:07 <hpaste> danilo2 revised “nested runStateT question”: “No title” at http://lpaste.net/92630
04:59:52 <danilo2> Hello! I've simplified an example, where I want to share Writer Monads log between recursively created States: http://lpaste.net/92630 . Could somebody help me with fixing it?
04:59:57 <Ghoul_> A may have found a meuval glitch
05:00:05 <Ghoul_> Get ready for the .. wierdness(?)
05:00:10 <Ghoul_> > takeWhile (/= 1) . iterate (\x -> if (even x) then n `quot` 2 else 3 * n + 1) $ 5
05:00:11 <lambdabot>   [5,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 * n + 1,3 ...
05:00:30 <quchen> Not a glitch.
05:00:41 <quchen>  > takeWhile (/= 1) . iterate (\n -> if (even n) then n `quot` 2 else 3 * n + 1) $ 5
05:00:46 <quchen> > takeWhile (/= 1) . iterate (\n -> if (even n) then n `quot` 2 else 3 * n + 1) $ 5
05:00:50 <lambdabot>   [5,16,8,4,2]
05:01:12 <quchen> You had unbound "n" in your expression, and Lambdabot assumes you're building up an Expr.
05:01:14 <quchen> Like
05:01:17 <Ghoul_> Oooh
05:01:18 <quchen> > x + y :: Expr
05:01:19 <lambdabot>   x + y
05:01:23 <elliott> n is bound!
05:01:24 <elliott> to n.
05:01:28 <Ghoul_> I knew the var was named wrong, but I wasn't sure why it was printing out my code
05:01:34 <quchen> elliott: "free", pardon
05:01:50 <elliott> it's not free though, because lambdabot defines n! :p
05:01:53 <elliott> well, it's no more free than takeWhile.
05:01:59 <quchen> Pfff.
05:02:18 <quicksilver> it was morally free
05:02:36 <quicksilver> it's not our fault lambdabot has too much predefined ;)
05:03:07 <romildo> I am running a Haskell application inside emacs (using haskell-mode). How can I input the EOF character? It is used to finish the application.
05:03:10 <quicksilver> also, it was free in what Ghoul wrote - freeness is a syntax property.
05:03:24 <elliott> right. I was wrong about it not being free.
05:03:27 <elliott> but then takeWhile was too.
05:03:30 <quicksilver> quite
05:03:35 <quicksilver> romildo: C-d probably?
05:03:35 <quchen> Let's take this trivial code error and discuss the meaning of free variables instead.
05:04:12 <quicksilver> although
05:04:21 <romildo> quicksilver, C-d does not work to send EOF to the application :(
05:04:26 <quicksilver> I'm not sure how to send eof to a ghci command without sending eof to the whole ghci
05:04:37 <quicksilver> maybe it's not possible?
05:05:00 <elliott> ^D works
05:05:04 <elliott> if it's asking for input
05:05:06 <quicksilver> in plain ghci?
05:05:08 <elliott> with emacs you need C-c C-d or something.
05:05:13 <elliott> because emacs takes every key
05:05:16 <elliott> quicksilver: yes
05:05:19 <quicksilver> romildo: ok if ^D works in plain ghci then ^Q ^D should work
05:05:23 <quicksilver> in emacs
05:06:18 <quicksilver> although I'm sure I remember reading about some ghci/eof related bugs at some point
05:07:44 <romildo> it seems that ^D does nort work inside ghci to send EOF to the application :(
05:10:45 <romildo> Then I am using ^C (C-q C-c inside emacs) to interrupt the application.
05:11:36 <b__> Does it make sense to define data EUR = Identity Decimal? Where I only export a constructor eur = Identity . Decimal 2 in order to ensure the right precision for any newly made EUR? I'm inclined to use Identity in order to get fmap and other freebies while still having a specialized EUR type, but is it non-idiomatic?
05:12:29 <merijn> b__: The usual approach would be to use newtype + GeneralizedNewtypeDeriving
05:13:07 <merijn> b__: newtype's are treated as separate types by the type checker (giving you type safety), but have no runtime overhead
05:13:15 <b__> Okay
05:13:20 <b__> I had that approach
05:13:25 <merijn> b__: data adds some (small) runtime overhead and type doesn't enforce type safety
05:13:37 <b__> But I wondered if it was general enough
05:13:53 <donri> technically newtype can have overhead
05:14:49 <merijn> b__: The GeneralizedNewtypeDeriving lets you derive any typeclass instance from the original type, so you could do "newtype EUR = EUR Decimal deriving (anything); eur = EUR . Decimal 2"
05:15:09 <Saizan> b__: using Identity as the constructor won't make it related to the Identity type from e.g. transformers
05:15:17 <merijn> donri: Other than the strictness it creates?
05:15:59 <b__> Saizan: good point, I meant type EUR = Identity Decimal
05:16:11 <donri> merijn: http://ghc.haskell.org/trac/ghc/ticket/7542
05:16:35 <b__> Somehow I have an amazing knack for mixing up data, newtype & type when asking questions in this channel
05:16:42 <merijn> b__: That'll still let people do wrong things
05:16:58 <Saizan> b__: then everyone can see through the definition and mess with the abstraction if they want
05:17:00 <merijn> b__: If I did "Identity 2" or something the compiler wouldn't complain
05:17:00 <b__> merijn: yeah you're right
05:17:16 <merijn> b__: My version prevents that (as long as you don't export the EUR constructor)
05:17:32 <b__> yeah
05:21:35 <b__> Initially I had type EUR = Decimal, which is very convenient when writing functions that consume EUR, but nothing prevents you from pushing in any old Integral i :(
05:22:16 <Saizan> isn't there a type that has the precision as an index?
05:22:36 <donri> Data.Fixed ?
05:22:59 <Saizan> yeah
05:22:59 <b__> There's Data.Fixed, but I remember having rounding issues (very likely my own fault)
05:23:07 <liyang> I recommend against Data.Fixed. It's slow.
05:23:23 <donri> where is Decimal coming from
05:23:33 <b__> Data.Decimal
05:23:38 <b__> Decimal package
05:23:48 <liyang> Also, when dealing with currency, as long as you don't need to do rounding, just take the smallest increment as your unit. So EuroCents rather than Euros.
05:23:58 <b__> liyang: I do
05:24:21 <liyang> You only really care about where the decimal point goes when displaying it. Otherwise it's just pointless.
05:24:35 <donri> nice pun
05:24:44 <b__> yeah, completely pointless
05:24:55 <b__> but I do care about rounding
05:25:23 <Saizan> uhm, Data.Fixed implements a lot of operations by going through Rational
05:26:11 <liyang> b__: how many decimal digits should you preserve? Is that well-defined?
05:26:27 <liyang> And Rational is twice as slow as Integer...
05:26:52 <b__> liyang it is not well defined
05:27:22 <b__> I believe it's locale/a-million-other-things related
05:28:41 <liyang> b__: I mean, does the (any?) rules say that you ought to preserve 4 decimal digits after the smallest unit, using banker's rounding or something...
05:29:03 <liyang> (And exactly 4 digits, no more, no less.)
05:30:37 <liyang> FWIW we just use a newtype of Double, but we don't have to be particularly exact.
05:31:14 <b__> I want to use it for personal finance, but also calculate interest on the resulting totals etc
05:31:14 <liyang> Whereas if you're writing an accounting package, that does matter.
05:32:03 <b__> I'm trying to figure out how to deal with both needs
05:32:15 <liyang> (In our case we needed speed.)
05:35:30 <liyang> b__: Wikipedia claims http://en.wikipedia.org/wiki/Rounding#Round_half_to_even is "widely used in bookkeeping."
05:37:30 <liyang> You may find http://hackage.haskell.org/package/fixed-point useful.
05:37:54 * liyang pokes jmcarthur 
05:38:34 <b__> liyang: that looks interesting
05:43:17 <pxqr> lookupModify :: Eq a => a -> (b -> b) -> [(a, b)] -> Maybe [(a, b)] ?
05:43:37 <liyang> Or at least has ideas you can steal from. It doesn't do round-to-even as far as I know.
05:47:12 * hackagebot yaml-config 0.1.0 - Configuration management  http://hackage.haskell.org/package/yaml-config-0.1.0 (MaximMitroshin)
05:47:22 <exicer> I'm having trouble using yesod, and I suspect it is because I somehow have a problem with my packages. Is there some way I can re-install everything?
05:53:37 <quchen> exicer: Your installed packages are in the 'world' file which is somewhere in .cabal.
05:54:18 <quchen> But if you're reinstalling everything anyway, you might as well just delete the entire folder and start from scratch
05:54:37 <quchen> Also have a look at Cabal 1.18's sandboxes, which were probably invented because of Yesod ;-)
05:54:57 <Kinnison> cabal has sandboxing now?
05:55:04 <Kinnison> so I don't need cabal-dev ?
05:55:33 <quchen> Yes.
05:55:51 <Kinnison> coolness
05:56:04 <quchen> Kinnison: http://www.haskell.org/pipermail/haskell-cafe/2013-September/108722.html
05:56:19 <exicer> so sandboxes are like pythons virtualenvironment or something ?
05:56:37 <donri> yes
05:56:40 <simukis_> exicer: yes, something like that.
05:56:42 <exicer> badass
05:57:08 <donri> well, not completely. hsenv is closer to that (also sandboxing ghc etc)
06:02:14 <christiaanb> is there a way to have haddock documentation (re)generated for a package on hackage that failed to build? (which does't involve emailing the hackage maintainer, or uploading a new version)
06:02:19 <exicer> Hm, I didn't have a world file.
06:02:52 <Cale> christiaanb: Well, if it failed to build, it'd probably fail to build if reattempted?
06:02:56 <exicer> Or well, it wasn't in .cabal. There was something in /Users/Exicer/Library/Haskell/logs/world
06:03:01 <exicer> but it was just text
06:03:39 <christiaanb> Cale: it was a dubious build failure. One of the dependencies failed to build (the lens package) even though it's working fine
06:03:45 <Cale> hmm
06:04:16 <christiaanb> here' the log message: http://hackage.haskell.org/packages/archive/clash-lib/0.2/logs/failure/ghc-7.6
06:04:16 <Cale> That is weird
06:05:23 <christiaanb> and here's the failure: http://lpaste.net/92635
06:07:05 <merijn> More importantly, cabal has finally done away with the silly need to manually reconfigure before building
06:09:51 <Cale> christiaanb: Yeah, I found that too. Quite strange. It builds MonadCatchIO-transformers above that, but it doesn't appear to say what the package hash was when it did it.
06:10:36 <christiaanb> Cale: there are also earlier references to the package hash which don't generate any failures...
06:10:46 <edwardk> odd
06:12:14 * hackagebot sodium 0.6.0.2 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.6.0.2 (StephenBlackheath)
06:14:55 <christiaanb> it's only the abi-hash generation which appears to fail
06:16:44 <merijn> sodium is an unfortunate name, given the existence of libsodium...
06:18:38 <ocharles> mm_freak_: where did reactimate go? :)
06:25:02 <mm_freak_> ocharles: it's no longer provided…  it should be provided by frameworks, not by netwire itself
06:25:13 <mm_freak_> ocharles: also i'm preparing netwire-frp right now
06:27:20 * hackagebot patch-combinators 0.2 - A library for patching functions and data structures  http://hackage.haskell.org/package/patch-combinators-0.2 (EmilAxelsson)
06:29:00 <ocharles> mm_freak_: oh, I see
06:29:45 <ocharles> I was going to try translating my keypresses in my little SDL + Netwire 5 app into Events, but I can't run it anymore :)
06:29:51 <ocharles> i'll wait a bit longer
06:30:22 <Lethalman> that patch combinators look much like arrows
06:32:21 <mm_freak_> ocharles: netwire-frp should be up shortly…  then i will start working on netwire-gloss…  that one should show you how to write a framework
06:32:34 <ocharles> mm_freak_: sounds good!
06:32:35 <mm_freak_> ocharles: if you don't use a framework for your application, you will have to write a mini-framework
06:33:16 <hari_> can anybody tell me what these "reduce duplication" errors mean: http://lpaste.net/92636
06:35:02 <`Jake`> You have the same lines in that function a lot of times, just slightly adapted.
06:35:12 <`Jake`> It tells you to write it shorter
06:35:12 <merijn> hari_: Those aren't errors, that's hlint output
06:35:29 <hari_> merijn, I know.
06:35:46 <hari_> But what is the effect on the program of removing those?
06:36:05 <`Jake`> The source code looks nicer
06:36:06 <Cale> hari_: By abstracting out the common parts of your code, you could make your program much shorter and perhaps easier to maintain.
06:36:22 <merijn> hari_: hlint is a code style/code smell checker, and it's basically telling you can do it nicer by combining the code at 140 and 151 in a function
06:36:48 <merijn> hari_: "reduce duplication" doesn't mean "remove them" it means "replace identical bits of code with a functions that does the same"
06:36:50 <hari_> Cale, merijn, thanks
06:37:30 <hari_> I love learning this language. I never imagined writing a parser would be so simple!
06:37:50 <merijn> hari_: I see you have a bunch of "parse level 6", "parse level 5" etc. comments
06:38:18 <merijn> hari_: Which look mostly the same, why not write "parseLevelNHeading :: Int -> Parser ?"
06:38:54 <merijn> and the do "parseHeading 6 <|> parseHeading 5 <|> ..."
06:39:18 <hari_> merijn, OK
06:39:46 <merijn> The only difference seems to be in the number of = passed to string, you could do "parseHeading n = do { string (replicate n '='); ...}"
06:40:26 <merijn> hell, why not make "data HLevel = Level Int" while you're at it? Then you don't need to implement "Int -> HLevel"
06:40:39 <hari_> merijn, yes, I think that would be a good idea. I had a vague idea I could abstract it.
06:41:18 <ben__> Hi guys, I'm just playing with lens and it seems like this should be pretty easy: I want to go from a data Thing = Thing { _a::_, _b::_} to a tuple of (a, b) is there a way to compose two lenses to do that?
06:41:52 <merijn> hari_: btw, record field update with {} binds stronger than function application, so you almost never need parentheses around them
06:41:59 <edwardk> ben: makePrisms ''Thing  then you can use the _Thing prism (or iso depending on if there is an extra constructor) to do the match
06:42:24 <hari_> merijn, OK
06:42:47 <edwardk> ben__: sadly there isn't a general way to take two lenses into th same structure and compose them to get a lens. consider what happens when you'd try to compose _1 with _1, the result wouldn't be a lens
06:42:59 <ben__> so I've got to (,) <$> view a <*> view b edwardk is this the equivalent to what makePrisms does?
06:43:31 <merijn> hari_: Other than that it looks mostly ok (although it looks like you can simplify/deduplicate *a lot*)
06:43:32 <edwardk> ben__: no, makePrisms makes something smarter. a prism is like a traversal you can 'run backwards'
06:43:35 <edwardk> consider
06:43:43 <edwardk> > Left 12 ^? _Left
06:43:43 <hari_> merijn, I seem to get a lot of parentheses in my code.
06:43:46 <lambdabot>   Just 12
06:44:02 <merijn> hari_: My only complaint is: import qualified Data.ByteString.Char8 as DBC ಠ_ಠ
06:44:09 <edwardk> > Right 12 ^? _Left
06:44:10 <hari_> maybe because I am not yet confident of how associativity works.
06:44:11 <lambdabot>   Nothing
06:44:18 <edwardk> so it works like a traversal
06:44:23 <edwardk> but we can also use it to
06:44:26 <edwardk> > _Left # 12
06:44:28 <lambdabot>   Left 12
06:44:32 <haasn> what's the technical term for 0-or-1 traversal again?
06:44:33 <haasn> affine?
06:44:38 <edwardk> haasn: affine traversal
06:44:39 <hari_> merijn, what should I import?
06:44:43 <merijn> hari_: The simple rule of thumb is "{} binds strongers, function application next most, everything else uses fixity"
06:44:50 <haasn> I have got to get some mnemonic for that
06:44:57 <edwardk> haasn: affine and relevant logic
06:45:00 <ben__> edwardk, /me is off to the documentation again!
06:45:16 <merijn> hari_: You can use ":i (+)" in ghci to find the fixity of something, the default (if nothing is printed) is 'infixl 9'
06:45:42 <edwardk> ben__: makePrisms makes a prism (named _Foo for each constructor Foo) for the constructors in your data type, upgrading them to Isos if it can (IIRC)
06:45:57 <merijn> hari_: Char8 is filled with vile lies
06:46:05 <ParaSa1lin> what exactly does bang patterns do? i was looking at some old code of mine from when i just started and saw those in some pattern matches
06:46:08 <merijn> hari_: You probably want to use Data.Attoparsec.Text?
06:46:12 <hari_> merijn, OK.
06:46:20 <merijn> ParaSa1lin: Makes patterns strict
06:46:40 <merijn> "f !x !y = ..." evaluates x and y before evaluating the right hand side
06:46:48 <hari_> I followed the tutorial here: https://www.fpcomplete.com/school/text-manipulation/attoparsec
06:46:53 <ParaSa1lin> merijn, the ghc's strictness analyser mostly makes that redundant?
06:47:31 <merijn> hari_: The problem with Char8 is that it only works on ASCII, any non-ascii will break your code
06:47:45 <ben__> thanks edwardk
06:47:51 <merijn> hari_: Text let's you deal with proper unicode data
06:47:51 <hari_> merijn, I actually parsed a document with some unicode text in it and it seemed to render it fine.
06:48:08 <hari_> I mean, in the final HTML
06:48:19 <hari_> I also wondered why it worked.
06:48:20 <merijn> hari_: That is only by accident, then
06:48:49 <merijn> hari_: anyway, Data.Attoparsec.Text should be mostly (if not completely) the same as Attoparsec.Char8
06:49:06 <hari_> merijn, does ByteString simply ignore Unicode and work with individual bytes?
06:49:10 <arnsholt> A good example of occasionally brokenness when treating UTF-8 data as bytes is splitting accentuating characters in two
06:49:28 <merijn> hari_: ByteString == bytes
06:49:43 <arnsholt> So if you take the first 100 characters of a post or something, you end up with dangling diacritics once in a while
06:49:48 <merijn> hari_: The String bit is an unfortunate misnomer that is only around because changing it now would break to many code
06:50:01 <hari_> merijn, OK.
06:51:02 <merijn> hari_: So ByteString is only for raw binary data, for unicode text you almost always want Text, String is really only for small literals, code golfing and helping newbies
06:51:25 <hari_> merijn, ok.
06:51:56 <merijn> hari_: For example, Text probably takes only slightly more than 1 byte per character (depending on how many foreign characters you have, of course). String can take as many as 30-40 bytes per character on some architectures
06:52:08 <tdammers> I like how String is one of Haskell's worst historically-grown fuckups
06:52:10 <hari_> So the String type should be avoided?
06:52:30 <tdammers> String is fine for simple things
06:52:31 <hari_> merijn, hmm... didn't realize that String was so expensive.
06:52:50 <merijn> hari_: Rule of thumb, if it's gonna be longer than like 10-20 characters OR you're gonna have more than 1000 of something, use Text
06:52:55 <tdammers> and it's not as bad as a linked list in, say, Lisp would be for representing strings, because of laziness
06:53:23 <tdammers> I'd think whether String is appropriate or not is more a matter of what you do with them
06:53:31 <merijn> hari_: I remember someone coming by asking why his program reading in a million 20-40 character lines ran out of memory, he changed the code to Text and it suddenly ran fine :)
06:53:57 <hari_> merijn, OK I was under the impression that Text was more heavy than String
06:54:25 <merijn> hari_: Well, keep in mind that String is really just a linked list of unicode characters. So you have like 4 bytes for the code point, 4 bytes for the boxing, 3*4 bytes for the cons cell
06:54:30 <ParaSa1lin> Text is a finger tree of arrays, right?
06:55:24 <hari_> merijn, Ok
06:55:25 <merijn> hari_: No, Text is really cheap. They are linked blocks (a few thousand or maybe even kb per block), that are densely packed (think like C array) of unicode text
06:55:43 <Saizan> ParaSa1lin: simpler, just one array for the strict version, or a list of them for the lazy one, unless it changed recently
06:55:47 <merijn> hari_: So the overhead for Text is 1 ptr + size per block and then one list entry per block
06:55:50 <tdammers> merijn: but then, if all you do with the string is lazily loading from a file and traversing linearly once, it doesn't matter whether one character consumes four bytes or 20, because you'll never have to work on more than one at a time
06:55:57 <merijn> tdammers: Oh, sure
06:56:14 <ParaSa1lin> Saizan, ah same as ByteString then
06:56:15 <tdammers> but then, lazy IO... hrmph
06:56:23 <merijn> tdammers: But you have lazy Text too
06:56:30 <tdammers> true
06:56:39 <Saizan> ParaSa1lin: similar, yes
06:57:29 <merijn> hari_: Usually it's not very hard to change working String code into Text code, though. So usually I start sketching code using String and then once the design starts becoming clear, switch to Text
06:57:56 <hari_> merijn, I see
06:58:34 <ParaSa1lin> difference seems to be that Text uses ByteArray# and ByteString uses pinned foreign ptr
06:58:48 <ParaSa1lin> is there clear performance difference between those two?
07:01:01 <saml> is there restful atompub service?
07:01:24 <hari_> So will a program using Data.Text be full of pack and unpack for literals? Or will {-# LANGUAGE OverloadedStrings #-} remove that requirement?
07:02:01 <Cale> hari_: OverloadedStrings will basically put the pack in for you.
07:02:20 <hari_> Cale, Ok
07:02:21 * hackagebot memexml 0.0.2 - Library for reading Meme XML output  http://hackage.haskell.org/package/memexml-0.0.2 (FlorianEggenhofer)
07:02:37 <Cale> (on literals only, of course)
07:03:06 <Saizan> ParaSa1lin: ByteArray# interacts better with the GC while the foreign ptr is better for FFI, afaiu
07:04:45 <liyang> Has someone already written a type-level arithmetic library using a binary representation?
07:05:23 <hari_> Why does the {-# LANGUAGE OverloadedStrings #-} not work in ghci?
07:05:47 <Eduard_Munteanu> Wow, I stumbled upon a GHC bug it seems: ghc: panic! (the 'impossible' happened) (GHC version 7.4.2 for x86_64-unknown-linux): metaTvRef ( k{tv acd} [sk] :: ghc-prim:GHC.Prim.BOX{(w) tc 347} )
07:05:53 <hari_> OK, I remember that ghci had some limitations.
07:06:22 <Eduard_Munteanu> hari_: you can supply it to ghci on the cmdline like: ghci -XOverloadedStrings
07:06:37 <hari_> Eduard_Munteanu, thanks
07:10:56 <geekosaur> hari_, or ":set -XOverloadedStrings" might work
07:11:14 <hari_> geekosaur, OK
07:11:41 <hari_> What is the difference between a recursive descent parser and a parser combinator?
07:13:54 <Philonous> hari_:  You don't need to restart ghci for that. ":seti -XOverloadedStrings" should work
07:14:18 <hari_> Philonous, thanks.
07:15:27 <paolino> hello, how does it work to write a Lens for a product type ?
07:15:38 <hari_> I get this "Some flags have not been recognized: XOverloadedStrings"
07:15:56 <hari_> OK, I forgot the -
07:17:36 <paolino> I see there is Prism but I'm cannot guess if it is for any type like Either
07:17:52 <paolino> (are those product types ?)
07:18:27 <supki> Either is a sum
07:18:30 <supki> (,) is a product
07:18:35 <geekosaur> hari_, re your parser question, it's somewhat ill-founded. parser combinators are one way to implement recursive descent parsing.
07:18:57 <paolino> ah, sorry, then I meand sum types
07:19:10 <hari_> geekosaur, am reading the wiki page on recursive descent parsing now.
07:19:14 <supki> paolino: you can't (generally) write a lens into sum type
07:20:31 <elliott> if you can write a lens into a sum type it can be factored out to be a product type :)
07:20:38 <elliott> in fact, the lens is such a factoring.
07:20:38 <supki> paolino: consider  data Foo a = Foo a | Bar  your can't write a lens to a  a  field because there is no way to get/set a if you have a Bar
07:21:40 <paolino> supki it seems the Prism works witn Just
07:21:48 <paolino> Just a
07:24:16 <paolino> I'm using it with Either a b also, but it's more like trial and error then knowing what I do :-/
07:28:23 <paolino> Now I'm trying a A a | B a | C maybe I refactor in (Either a (Just a)) , but it seems a bad path.
07:34:55 <mm_freak_> paolino: A a | B b | C seems to be a clean solution…  perhaps just give them more meaningful names =)
07:39:49 <quchen> mm_freak_: Like B a | C b | A!
07:44:10 <Philonous> org_haskell_standard_constructor_A a | org_haskell_standard_constructor_B b ...
07:45:36 <anakreon> How can I constrain the s and p type variables to be of class Enum in the following declaration: type T s p v v' = s -> [(s, p, v -> v, v -> Bool, v -> v')]
07:46:11 <mm_freak_> quchen: like Produce a | Inhibit e | Skip
07:46:12 <mm_freak_> ;)
07:46:20 <mm_freak_> data Signal e a = …
07:47:27 <paolino> mm_freak_: I'd like to make a Lens like operation on them, the meaning is not crucial now
07:48:47 <mm_freak_> paolino: rather prism-like i guess
07:48:53 <paolino> yes
07:50:24 <byorgey> anakreon: you can't.  Instead, just put those constraints on the type signatures of other functions which make use of T.
07:52:22 <paolino> mm_freak_, but I'm almost sure I break the laws so I just stop
07:52:44 <Cale> anakreon: I would strongly consider replacing that tuple with a record type of some sort.
07:53:58 <anakreon> This works type T s p v v' = (Enum s, Enum v) => s -> [(s, p, v -> v, v -> Bool, v -> v')] with RankNTypes extension
07:54:22 <mm_freak_> paolino: you can let the library derive the prisms for you
07:54:29 <mm_freak_> paolino: that makes sure you don't break laws
07:54:43 <paolino> with prism' ?
07:54:48 <mm_freak_> makePrisms ''MyType
07:54:57 <ski> anakreon : yeah, but it's still often not what you want
07:55:02 <paolino> oh
07:55:07 <mm_freak_> just like you say:  makeLenses ''MyType
07:55:24 <ski> anakreon : consider `blah :: T s p v0 v1 -> ...' -- this is likely not what you intended
07:56:31 <ski> (being able to state presuppositions for type definitions could perhaps be useful, if implemented properly)
07:57:51 <paolino> mm_freak_, A {_ca::a}, B {_cb::b} , C {_c::?}
07:58:20 <paolino> or _A a | _B b |_C ?
07:58:57 <mm_freak_> paolino: A, B, C
07:59:03 <mm_freak_> the prisms will be named _A, _B and _C
07:59:19 <paolino> like _Left, _Right
07:59:25 <mm_freak_> exactly
07:59:35 <paolino> I see
07:59:45 <mm_freak_> and yeah, i don't like that naming scheme either =)
08:00:30 <paolino> it has been supercarefully chosen I guess
08:01:28 <mm_freak_> i don't like underscores in general for that application
08:01:37 <mm_freak_> asLeft, asRight, …
08:05:33 <donri> isLeft = is _Left  -- but then people didn't want "is" exported from Control.Lens :p
08:05:48 <ocharles> isLeft = has _Left
08:10:06 <ParahSailin> @hoogle comparing
08:10:07 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:15:42 <shachaf> Oh well.-Right
08:15:56 <danilo2> is there in Haskell an equivalent function to this one: \a -> case a of Just x -> return x; Nothing  -> fail "error" ? (I want to use it in MaybeT monad)
08:17:03 <shachaf> Just pattern-match.
08:17:31 <ocharles> danilo2: there is in 'errors'' iirc
08:17:49 <ocharles> danilo2: sounds like you want to 'join' Maybe into MaybeT
08:17:52 <ski> @type \a -> do Just x <- a; return x
08:17:54 <lambdabot> Monad m => m (Maybe b) -> m b
08:18:04 <ski> oh, right
08:18:05 <RevJohnnyHealey> There is fromJust in Data.Maybe
08:18:12 <ski> @type \a -> do Just x <- return a; return x
08:18:13 <lambdabot> Monad m => Maybe b -> m b
08:18:25 <danilo2> ocharles: Yes, I want to "join" Maybe into MaybeT
08:18:30 <ocharles> danilo2: http://hackage.haskell.org/packages/archive/errors/1.4.2/doc/html/Control-Error-Util.html see the first bunch of functions
08:18:38 <ocharles> danilo2: hoistMaybe might be what you want
08:18:43 <ocharles> ?? is also useful
08:18:43 <lambdabot>  is also useful
08:18:46 <danilo2> RevJohnnyHealey: fromJust does nto work - it throws an error and cannot be used like this
08:18:46 <ski> RevJohnnyHealey : which will not give file and line number for the use of `fromJust' ..
08:19:19 <danilo2> ocharles: Thats exactly what I was searching for! thank you :)
08:19:22 <ocharles> yw
08:19:24 <shachaf> Don't use fromJust pretty much ever.
08:19:29 <ocharles> handy little module that
08:19:37 <ski> danilo2 : btw, it's not clear why you want this for the `MaybeT m' monad
08:19:41 <shachaf> But in this case you can just pattern-match. This behavior is built into Haskell!
08:20:01 <shachaf> do { Just x <- ...; ... }
08:20:11 <danilo2> ski: I simply have a nested runMonadT functions and I want to promote one result into another MaybeT :)
08:21:04 <donri> @undo do { Just x <- y; return x }
08:21:04 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
08:21:40 <donri> this is exactly why fail is in Monad
08:22:19 <danharaj> no reason why it can't be specialized to a MonadFail class and make it error by default.
08:22:31 * hackagebot boomerang 1.3.4 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.3.4 (JeremyShaw)
08:22:40 <elliott> error by default isn't quite workable
08:22:43 <elliott> breaks open world assumption
08:22:43 <donri> danharaj: i'd rather it failed to type check by default
08:23:22 <donri> it can detect partial patterns, so it could desugar conditionally to fail and thus infer a MonadFail constraint
08:23:41 <danilo2> btw. hoistMaybe is implemented as: MaybeT . return  ... This was so simple :D
08:29:11 <danilo2> Ok so one more question - Is there in haskell an equivalent to "fail" function, which do not need a String argument? When I'm in MaybeT monad, the Strign argument to fail is not used (the result of computation is Nothing)
08:29:28 <ocharles> empty from MonadPlus
08:29:39 <ocharles> erm
08:29:45 <ocharles> mzero from monadplus, empty from alternative :)
08:30:18 <danilo2> ocharles: Thank you! :)
08:36:19 <paolino> mm_freak_, thanks. It worked
08:38:43 <paolino> for a Map a (b,c)  I can access (Maybe (b,c)) with at , how can I access Maybe c ?
08:39:16 <paolino> I tried at x . traverse but the Maybe disappears
08:39:17 <shachaf> Are you talking about lens's at?
08:39:21 <shachaf> Ah, yes.
08:39:30 <shachaf> Once you're talking about accessing Maybe c, it's not a lens anymore.
08:39:36 <shachaf> (Since you can't use it to insert without having a b.
08:39:56 <S11001001> a traversal might be good enough though
08:40:17 <paolino> shachaf, , right
08:40:20 <shachaf> So you might just use ix k . _2, which is  atraversal.
08:40:32 <shachaf> Then you can preview with it to get the Maybe.
08:40:42 <shachaf> (Note that ix k = is just at k . traverse.)
08:40:57 <shachaf> s/= //
08:42:55 <paolino> mh, at k . traverse is not a lens
08:44:12 <paolino> but it asks c to be a Monoid
08:45:04 <shachaf> Yes. Hence the thing I said above about preview.
08:46:12 <paolino> a function that cancel a constraint
08:46:27 <elliott> it's view that gives the constraint, not the thing itself
08:47:34 * hackagebot xilinx-lava 5.0.1.6 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.6 (SatnamSingh)
08:47:36 * hackagebot xilinx-lava 5.0.1.7 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.7 (SatnamSingh)
08:50:07 <applicative> this 'wtf' haskell has some pretty good devices https://github.com/thomastechsoft3d/yesno/blob/master/Main.hs
08:50:07 <applicative> (=:) = readIORef is just common sense
08:51:39 <applicative> but static = const newIORef , thus permitting eg x <- static unsigned_int 1 is okay
08:52:35 * hackagebot xilinx-lava 5.0.1.8 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.8 (SatnamSingh)
08:53:48 <applicative> function = const return ; do { rand <- function int$ \x-> do.. }
08:55:05 <ski> `Exit_Code <- static int 1' ?
08:56:09 <applicative> Exit_Code is eliminated by the cpp into _1 which is ...
08:56:41 <applicative> somewhere in there!
08:57:14 <applicative> right it's just a variable like x <- blah
08:58:02 <applicative> i think he didn't end up using the perversity he was hoping for from Exit_Code = _1
08:58:04 <ski> yeah, but why do it ?
08:58:30 <applicative> i think he had more pretentious plans
08:58:32 <ski> it wouldn't have the effect of forcing the next `Exit_Code' to be an int, e.g.
08:59:12 <applicative> oh i see, he has two in a row, 'shadowing', is this doing something?
08:59:51 <ski> not that i can see
09:00:28 <joelteon> is there a good way to debug <<loop>>s?
09:00:30 <applicative> i see, your point to begin with was that line 82 is pure blather
09:01:28 <applicative> but these devices where things like function and static become complicated forms of 'asTypeOf' has a certain charm
09:02:19 <merijn> joelteon: Judicious application of Debug.Trace.trace?
09:02:26 <joelteon> heh
09:02:33 <applicative> joelteon: maybe the lowest of the low, Debug.trace will keep the compiler from going to <<loop>>
09:02:38 <applicative> oh like merijn says
09:02:45 <joelteon> well, the loop it was hitting was inside a library function
09:02:49 <joelteon> as far as I can tell
09:02:51 <merijn> ah
09:03:27 <applicative> well, if the library function was e.g. Control.Applicative.many or something, its not too surprising .
09:03:42 <joelteon> yeah
09:03:47 <joelteon> no, it was inside the wordnet library
09:04:43 <applicative> hm, oh is this you who's been updating it
09:04:49 <joelteon> well
09:05:00 <joelteon> I uploaded WordNet-ghc74, which does NOT encounter the error
09:05:04 <joelteon> but WordNet does indeed
09:05:08 <applicative> oh
09:05:11 <joelteon> maybe I'll take a look at the internals
09:05:48 <applicative> you should give it a more pretentious name, your 'fork', WordNet-moderne or something
09:05:54 <joelteon> yeah
09:06:14 <joelteon> I should give it a better name, for sure. it didn't actually compile *on* 7.4 until last night
09:06:20 <joelteon> but it worked fine on 7.6.3, which is what I always use
09:06:22 <applicative> there needs to be a system for saying 'i forked this because frankly i don't care to communicate with Hal Daume who hasn't been heard from for years'
09:06:28 <joelteon> yeah
09:06:28 <applicative> like -moderne
09:06:39 <joelteon> -moderne is nice
09:07:28 <applicative> i was thinking of it somewhere else, just because a lot of this potentially useful but utterly bitrotted stuff also uses string and stuff where it emphatically shouldn't
09:07:42 <applicative> in that case it should be -idiomatic
09:08:19 <applicative> or -sensible
09:08:36 <applicative> try e.g. MissingH-sensible
09:08:43 <joelteon> yeah
09:08:49 <joelteon> MissingH-sensible would be an empty package
09:08:55 <applicative> hah
09:09:18 <joelteon> update: i have downloaded WordNet and am attempting to debug the source of the loops
09:21:42 <joelteon> oh
09:21:51 <joelteon> huh. ok
09:22:08 <joelteon> let rest4 = splitAt n rest4
09:22:10 <joelteon> that'll do it
09:24:26 <Maior> so I'm trying to reimplement logstash in Haskell - what do people recommend for writing daemons? System.Daemon?
09:25:51 <joelteon> solved!
09:27:07 <unK_> hello. can anyone explain, why this: http://codepad.org/Kf4Gb1YH doesn't compile?
09:28:25 <joelteon> unK_: the type system can't guarantee that those two types are equivalent
09:28:27 <haasn> unK_: X contains *some* ‘a’, so pattern matching (X a) means a has some type
09:28:35 <haasn> whereas wX is required to have *any* type
09:28:47 <haasn> the only valid inhabitant of wX is bottom
09:29:14 <joelteon> any reason why you're doing it this way?
09:29:31 <haasn> wX :: forall a. Wrapped X -> a;  X :: forall a. a -> X;  wX . addContext "" . X :: forall a b. a -> b
09:29:41 <unK_> oh, right. thanks
09:30:01 <applicative> oh, i was about to answer unK_ 's question; this channel is too fast
09:30:37 <applicative> the 'a' inside X on line 13 could be an Int which is hardly an occupant of all types
09:30:46 <unK_> joelteon: I want to be able to catch any exception, add some context to it and rethrow it. I can rethrow SomeException, but I initially did it this way and was wondering why it doesn't work. silly me.
09:31:27 <haasn> unK_: if you want to existentially quantify again you can use WrappedX = forall a. WrappedX { ... wX :: a }
09:31:29 <haasn> rather than what you wrote
09:31:45 <haasn> (or,  as you say, just re-throw SomeException)
09:31:58 <unK_> oh, lol, yeah. I see now, I placed forall in the wrong place.
09:32:03 <unK_> eh
09:32:32 <unK_> thanks
09:32:35 <applicative> forall a. a is the losingest of rank2 types
09:33:21 <applicative> > let a :: forall a . a; a = a in a
09:33:28 <lambdabot>   mueval-core: Time limit exceeded
09:34:02 <applicative> ... is about as good as it gets
09:36:49 <haasn> huh, it's odd that ghc accepts data X = forall a. X { unX :: a } -- but actually using ‘unX’ anywhere causes an error
09:36:59 <applicative> Maior: ooo I see a pipes-ified daemon library. It *must* be these best.  Even if it will be out of date tomorrow.
09:37:08 <applicative> the best, rather
09:37:18 <Maior> pipes? will take a look, thanks
09:38:20 <applicative> Maior: i was looking at this one http://hackage.haskell.org/packages/archive/daemons/0.1.2/doc/html/System-Daemon.html but I think the new 'pipes platform' due out this week will make some chunks of the code unnecessary and others slightly wrong, maybe
09:39:31 <applicative> but the pipes angle isn't the main point of the library anyway. for all i know it's completely incompetent.
09:40:40 <Maior> I'm still very much getting into Haskell, and while I could happily build something similar in Python/Java/etc., have no idea of where to start in Haskell, so it seemed a fun thing to try
09:41:01 <applicative> you can't go wrong with brutalKill :: FilePath -> IO ()
09:41:23 <Maior> lol
09:42:40 * hackagebot heist 0.13.0 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0 (DougBeardsley)
09:43:20 * haasn seems to remember some similar package that basically provides foo :: (Serialize a, Serialize b) => String -> (a -> IO b) -> a -> IO b -- which starts the daemon if it isn't running already
09:43:26 <haasn> or something like that
09:43:36 <haasn> but I guess that may be the same package, just using ensureDaemonRunning and runClient together
09:43:36 <applicative> Maior: oh btw do you know http://packdeps.haskellers.com/reverse which can tell you a bit about what is used.  of course it will give wrong signals about newer things, which may or may not be much better
09:43:48 <Maior> I don't even really want a daemon I guess
09:44:01 <Maior> an event handling loop of sorts
09:44:08 <Maior> applicative: looks good - thanks!
09:45:37 <merijn> Maior: Event handling loop usually ends up being a Chan with one or more threads reading from it and handling them and one or more putting events in it
09:46:21 <applicative> there's a nice elementary example in the beginning discussion of concurrency is S Marlowe's manual
09:46:30 <applicative> a logger of things
09:46:41 <applicative> does that sound like the right kind of program?
09:47:09 <Maior> applicative: I'm thinking really I should just look at the source/deps of some of the "server" things written
09:48:03 <applicative> there's a little progress of increasingly complicated examples, but the emphasis is concurrency http://chimera.labs.oreilly.com/books/1230000000929/ch07.html#sec_conc-logger
09:48:25 <Maior> applicative: excellent, thanks!
09:48:55 <merijn> Maior: You're already familiar with other languages, no? Might want to also directly take a look at the Control.Concurrent hierarchy of modules
09:49:21 <merijn> Maior: threads, MVar's and Channels are really use to use in haskell and make server stuff so much nicer
09:49:40 <Maior> merijn: yeah could (fairly) trivially write such a thing in Python/Java; just looking to learn more Haskell in something brutally real-world...
09:49:47 <Maior> merijn: cheers
09:50:49 <merijn> Maior: Haskell has lightweight threads and the runtime uses epoll/kqueue/select internally to block/wakeup, so unlike many other language where you end up writing async/callback code, the haskell approach is to just write synchronous code with 1 thread (or more) per client/connection
09:51:21 <Maior> merijn: oh excellent
09:51:32 <Maior> merijn: watching gevent monkeypatch things in Python always makes me a bit sad/scared
09:52:50 <merijn> Maior: In terms of overhead they should be about comparable to stuff like Go, so running 10k or 100k threads on a desktop machine should be no problem (well, IO threads, that is, obviously that many computational threads make no sense unless you have 10k cores ;))
09:56:20 <monochrom> oh, the recent hot talk about semigroup is just to help use foldr and foldl
09:58:03 <monochrom> or rather, just to give names to parameters to foldr and foldl
10:00:13 <MeepyTheParrot> Hello, haskell chat! Can somebody explain "reads" function to me? I understand I can use it as an alternative to exception handling for "read invalidInput :: Int", but I do not understand what (reads cs :: [(Integer, String)]) means :(. The [(Integer, String)] Throws me off.
10:00:29 <joelteon> it's a list of (Integer, String) pairs
10:00:40 <joelteon> the String is the unconsumed input
10:00:50 <joelteon> > reads "2abc" :: [(Integer, String)]
10:00:53 <lambdabot>   [(2,"abc")]
10:00:59 <monochrom> see my http://www.vex.net/~trebla/haskell/reads.xhtml , has many examples
10:01:06 <Maior> ...that's so cool
10:01:16 <MeepyTheParrot> :( That made me even more confused.
10:03:28 <MeepyTheParrot> I feel like  there is such a gap between what is tought online and what is expected to be understood as a given in this chat :(
10:03:34 <MeepyTheParrot> So frustrating.
10:03:39 <joelteon> MeepyTheParrot: which part don't you understand?
10:03:49 <joelteon> reads "2abc" -> "2" is a valid integer, so it's the first item in the pair
10:03:55 <joelteon> "abc" isn't an integer, so it's the second item in the pair
10:04:07 <joelteon> i.e. "leftovers"
10:04:10 <merijn> MeepyTheParrot: In recent versions of GHC you probably want to use Text.Read.readMaybe
10:04:13 <merijn> :t readMaybe
10:04:14 <applicative> MeepyTheParrot: there's also readMaybe is it, in Text.Read
10:04:14 <lambdabot> Not in scope: `readMaybe'
10:04:19 <joelteon> oh hey
10:04:20 <merijn> :t Text.Read.readMaybe
10:04:21 <lambdabot> Read a => String -> Maybe a
10:04:25 <applicative> merijn: you are too fast
10:04:28 <joelteon> how recent is readMaybe?
10:04:32 <merijn> 7.6
10:04:35 <joelteon> neat
10:04:42 <applicative> pretty recent
10:04:45 * applicative continues to echo merijn  it seems
10:04:45 <merijn> Because reads is a sucky function :p
10:04:49 <joelteon> I don't use reads much but it's always a pain in the ass to extract the information you want from reads
10:05:06 <applicative> the equivalent is in the safe package, MeepyTheParrot or maybe it imports that one now
10:05:12 <erisco> > init [1,2,3]
10:05:13 <lambdabot>   [1,2]
10:05:24 <merijn> > Text.Read.readMaybe "123" :: Maybe Int
10:05:24 <erisco> is there another function for [3]?
10:05:25 <lambdabot>   Not in scope: `Text.Read.readMaybe'
10:05:29 <merijn> bah
10:05:34 <joelteon> erisco: last
10:05:38 <erisco> nope
10:05:39 <joelteon> head/tail, init/last
10:05:40 <merijn> @let import Text.Read (readMaybe)
10:05:40 <erisco> =\
10:05:41 <lambdabot>  Defined.
10:05:46 <joelteon> > last [1,2,3]
10:05:46 <merijn> > readMaybe "123" :: Maybe Int
10:05:47 <lambdabot>   3
10:05:47 <lambdabot>   can't find file: L.hs
10:05:51 <merijn> > readMaybe "123" :: Maybe Int
10:05:52 <lambdabot>   Just 123
10:05:55 <merijn> > readMaybe "123" :: Maybe Char
10:05:56 <lambdabot>   Nothing
10:06:10 <joelteon> erisco: yep
10:06:14 <erisco> > last []
10:06:15 <lambdabot>   *Exception: Prelude.last: empty list
10:06:36 <MeepyTheParrot> My ghci import Text.Read does not contain readMaybe :(
10:06:43 <erisco> :t safeLast
10:06:44 <lambdabot> Not in scope: `safeLast'
10:06:48 <joelteon> MeepyTheParrot: you probably have an older GHC
10:06:52 <joelteon> do you know what version it is?
10:06:59 <merijn> MeepyTheParrot: Are you on Ubuntu by any chance?
10:07:12 <MeepyTheParrot> 7.4.2
10:07:17 <joelteon> yeah, you won't have it then
10:07:31 <erisco> joelteon, guess I'll have to wrap a bit of extra logic around it
10:07:32 <applicative> try cabal install safe and import Safe readMay; or better cabal install errors, and import Control.Error
10:07:56 <MeepyTheParrot> I still want to understand reads but I do not understand how [(Int, String)] turns into []
10:08:02 <MeepyTheParrot> on invalid input
10:08:19 <joelteon> reads only ever returns a 0 or 1-item list, doesn't it?
10:08:19 <merijn> MeepyTheParrot: [] is the empty list, it can be a list of any type
10:08:25 <applicative> > reads "hello" :: [(Int,String)]
10:08:27 <lambdabot>   []
10:08:37 <merijn> MeepyTheParrot: So on no parse you get an empty list of type [(Int, String)]
10:08:53 <merijn> :t [] :: [Int]
10:08:54 <lambdabot> [Int]
10:08:54 <zebr> hey all. is there any way to get non-left-linear pattern matching in haskell? e.g. f (t:xs) (t:ys) = []. i know it used to exist.
10:09:01 <merijn> :t [] :: [(String, Int)]
10:09:02 <lambdabot> [(String, Int)]
10:09:11 <applicative> did it really exist? zebr
10:09:20 <MeepyTheParrot> My mind is blown, again :|
10:09:26 <merijn> :t []
10:09:28 <lambdabot> [a]
10:09:32 <zebr> applicative: hm, i *think* so. i know it was in miranda. i may be wrong about its being in haskell.
10:09:53 <merijn> MeepyTheParrot: See, [] has type [a], i.e. [] is a list for all possible types a
10:10:08 <Saizan> zebr: f (x:xs) (y:ys) | x == y = ... is the closest you get
10:10:15 <applicative> oh, i don't know. i think the system as we have it wouldn't make sense of it
10:10:21 <MeepyTheParrot> I understand that much merijn
10:10:23 <NovaDenizen> I've got a medium-to-advanced type problem http://lpaste.net/92644
10:10:34 <applicative> i was going to then say what Saizan said, there is an implicit Eq going on
10:10:49 <merijn> NovaDenizen: newtype
10:11:08 <merijn> NovaDenizen: type introduces a "textual" substitution and doesn't allow infinite types
10:11:13 <merijn> NovaDenizen: newtype/data do
10:11:19 <applicative> miranda may have had a fancy way of handling what in Haskell is done with Eq?
10:11:30 <Saizan> zebr: or maybe as a view pattern "f (x:xs) (((==x) -> True):ys) = ...", it might look better with better names
10:11:43 <NovaDenizen> I should use newtype to define Fix?  Or CExpression?
10:11:55 <merijn> NovaDenizen: This should work: "newtype Fix f = FixC (f (Fix f))"
10:12:00 <zebr> Saizan: yeah, i thought so. but i can't use guards like so, can i? f x y | x == y = [] ; f x y = x -- otherwise
10:12:11 <joelteon> sure you can
10:12:25 <merijn> NovaDenizen: (The FixC is to clarify that it is a constructor, not a type, you could change it to Fix, but I wanted to avoid confusion)
10:12:27 <Saizan> zebr: yep, you can
10:13:01 <applicative> zebr: it took me a while to recognize that, I remember, I thought with one guard I was committing myself to the whole series
10:13:20 <zebr> oh wow, that compiles! neat, thanks. that solves everything. :)
10:13:22 <NovaDenizen> Ok, I'm trying it out...
10:13:23 <merijn> NovaDenizen: Of course the use of newtype does mean explicitly wrapping/unwrapping, but that's the price you pay
10:13:40 <zebr> wasn't aware guards could be used to 'abort' a successful match
10:14:21 <NovaDenizen> I used to have a bunch of cases like "Binary BInaryOperator (CExpression l i t) (CExpression l i t)" but I'm trying to use the same thing for SSA and recursive expressions...
10:14:23 <merijn> zebr: Once a pattern matches, all guards of the pattern are tried in lexical order, the first succesful guard is selected
10:14:34 <merijn> zebr: If no guard matches, it continues to the next pattern
10:14:42 <zebr> that's very cool. i like that.
10:14:56 <applicative> the second point is the one i was missing at first.
10:15:02 <MeepyTheParrot> Why does (reads "9" :: [(Integer, String)]) yield [(9, "")] yet (reads "9" :: [(String, String)]) yield []?
10:15:20 <merijn> MeepyTheParrot: Because 9 is not a String?
10:15:27 <elliott> > reads "9" :: [(Integer, String)]
10:15:28 <lambdabot>   [(9,"")]
10:15:35 <merijn> > read "\"test\"" :: String
10:15:36 <elliott> oh, right.
10:15:36 <lambdabot>   "test"
10:15:41 <merijn> > read "test" :: String
10:15:42 <lambdabot>   "*Exception: Prelude.read: no parse
10:16:07 <MeepyTheParrot> >.>
10:16:15 <applicative> > reads "\"9\"" :: [(String,String)]
10:16:15 <applicative> sorry, lambdabot
10:16:16 <lambdabot>   [("9","")]
10:16:27 <applicative> ah there
10:16:41 <applicative> "\"9\"" is the name of "9"
10:16:55 <applicative> "9" is the name of 9
10:16:59 <merijn> MeepyTheParrot: Read expects values to look like haskell literals (for the proper instances of Read, anyway)
10:17:05 <MeepyTheParrot> oh
10:17:17 <merijn> MeepyTheParrot: And String's are thus expected to be surrounded in quotes
10:17:37 <merijn> MeepyTheParrot: If you want more advanced parsing you should look at Parsec, it's much better at these things than Read is
10:17:39 <joelteon> :t (>>= reads)
10:17:40 <lambdabot> Read a => [String] -> [(a, String)]
10:17:44 * hackagebot haskell98libraries 2.0.0.2 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98libraries-2.0.0.2 (ThomasHallgren)
10:17:58 <ReinH> applicative: hai
10:18:00 <S_J> > let f = return . (+1) in Just 5 >>= f
10:18:01 <lambdabot>   Just 6
10:18:06 <applicative> hi ReinH
10:18:24 <S_J> > Just 6 >> 7
10:18:25 <lambdabot>   No instance for (GHC.Show.Show b0)
10:18:26 <lambdabot>    arising from a use of `M1889876805.sh...
10:18:27 <jfischoff> m bra -> m ket … hmm someone likes physics
10:18:30 <applicative> "\"9\"" is the name of the name of 9
10:18:31 <S_J> @type (>>)
10:18:32 <lambdabot> Monad m => m a -> m b -> m b
10:18:40 <MeepyTheParrot> Is there a way of extracting 9 out of [(9, "")] without using case, of?
10:18:43 <S_J> > Just 6 >> Just 7
10:18:44 <lambdabot>   Just 7
10:18:48 <S_J> > Just 6 >>= Just 7
10:18:50 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe b0'
10:18:50 <lambdabot>              with ...
10:18:58 <S_J> > Just 6 >>= return 4 Just 7
10:18:59 <lambdabot>   Could not deduce (GHC.Num.Num
10:18:59 <lambdabot>                      (GHC.Integer.Type.Intege...
10:19:02 <S_J> > Just 6 >>= return $ Just 7
10:19:03 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0 -> t0'
10:19:03 <lambdabot>              with ...
10:19:04 <merijn> MeepyTheParrot: Not one that is safe
10:19:05 <applicative> MeepyTheParrot: that would be wrong
10:19:13 <joelteon> MeepyTheParrot: well, the reason the list is there is for a rudimentary sort of error handling
10:19:20 <merijn> S_J: "return (Just 7)" is not a function
10:19:24 <merijn> S_J: >>= wants a function
10:19:31 <MeepyTheParrot> so the best way is case,of?
10:20:02 <S_J> > Just 6 >>= return . Just
10:20:04 <lambdabot>   Just (Just 6)
10:20:30 <S_J> > sequence (Just 6 >>= return . Just )
10:20:31 <lambdabot>   Couldn't match type `Data.Maybe.Maybe' with `[]'
10:20:31 <lambdabot>  Expected type: [a0]
10:20:31 <lambdabot>    Ac...
10:20:37 <S_J> :t sequence
10:20:38 <lambdabot> Monad m => [m a] -> m [a]
10:20:45 <applicative> :t fromMaybe 0 . readMaybe
10:20:46 <lambdabot> (Num c, Read c) => String -> c
10:20:50 <S_J> > join (Just 6 >>= return . Just )
10:20:51 <lambdabot>   Just 6
10:21:06 <applicative> > fromMaybe 0 . readMaybe $ "hello" :: Int
10:21:07 <lambdabot>   0
10:21:13 <ReinH> S_J: return = Just for Maybe
10:21:15 <applicative> > fromMaybe 0 . readMaybe $ "9" :: Int
10:21:16 <lambdabot>   9
10:21:49 <applicative> > map (fromMaybe 0 . readMaybe) ["hello", "9","10","_10!"]
10:21:51 <lambdabot>   [0,9,10,0]
10:23:06 <eacameron1> anyone have a suggestion for a good IDE that supports Haskell? Any experience with Leksah?
10:23:45 <S_J> eacameron1: i think leksah is ok, not more. there is also functional programming mode for eclispe which is decent. but in the end i stuck with emacs
10:23:49 <applicative> eacameron1 the #haskell answer is 'oh have you heard of this new ide emacs'
10:23:50 <merijn> eacameron1: I think most people here just use vim/emacs/sublime
10:23:58 <WraithM> I've never gotten Leksah to run. vim works well enough for me. I've heard that Eclipse works with a plugin.
10:24:07 <merijn> applicative: I think there's a vim majority, actually
10:24:21 * applicative still uses nano and textmate 1 for haskell
10:24:37 <merijn> There's EclipseFP, but I can't imagine anything with Eclipse being good
10:24:57 <WraithM> lol
10:24:59 <WraithM> true
10:25:18 <merijn> eacameron1: There's also yi, but if you have an editor you're already comfortable with, I'd just use that
10:25:24 <applicative> eacameron1: if you are a user of vim or emacs, they are probably the way to go; if you abhor them, there are various alternative, none I think, with the qualities of an ide
10:25:39 <notdan> How is Sublime Text compared to Textmate2 by the way?
10:25:43 <merijn> I think Sublime had REPL integration at least?
10:25:46 <notdan> Not that I am moving away from Emacs, just wondering
10:25:52 <S_J> for bigger projects emacs is perhaps not optimal but for small projects i think it is the best option.
10:26:02 <applicative> i dont think it has repl integration, there is some python repl thingy
10:26:12 <merijn> S_J: Why not? How small is small according to you?
10:27:01 <applicative> eacameron1: if you already use some editor X or editors X and Y it is probably a question of figuring out what haskellers do with them
10:27:16 <NovaDenizen> I can't figure out a way to salvage deriving Eq, Ord, Show http://lpaste.net/92644
10:27:29 <applicative> eacameron1: thus i use the rather simple-minded textmate 1 but have about 300 little executables i wrote in haskell attached to it
10:27:30 <merijn> S_J: I've worked on codebases of 100k SLOC of C in mostly vanilla vim (command-t for opening files, but that's about it), never had any real problems. Can't imagine emacs being different
10:28:24 <MeepyTheParrot> What is the correct way of saying if [] == [] then putStrLn "wrong" else putStrLn "right"
10:28:48 <applicative> > [] == []
10:28:48 <shachaf> putStrLn "wrong"
10:28:49 <lambdabot>   True
10:28:49 <merijn> MeepyTheParrot: That looks like valid (albeit silly) haskell to me
10:29:05 <applicative> > if otherwise then text "wrong" else text "right"
10:29:06 <lambdabot>   wrong
10:29:13 <MeepyTheParrot> originally it was if x == [] then putStrLn "wrong" else putStrLn "right"
10:29:14 <joelteon> :t text
10:29:15 <lambdabot> String -> Doc
10:29:15 <NovaDenizen> putstrln $ if [] == [] then "wrong" else "right" ?
10:29:19 <applicative> > if not otherwise then text "wrong" else text "right"
10:29:20 <lambdabot>   right
10:29:22 <joelteon> huh. Doc?
10:29:26 <applicative> yes
10:29:36 <Taneb> MeepyTheParrot, null x
10:29:40 <applicative> ghci has a special response to > someDoc
10:29:43 <merijn> Taneb++
10:29:44 <Taneb> @type null
10:29:45 <NovaDenizen> or just putStrLn "wrong"
10:29:45 <lambdabot> [a] -> Bool
10:29:53 <joelteon> > quotes $ text "test"
10:29:54 <lambdabot>   'test'
10:29:58 <merijn> Taneb: Nice guess :)
10:30:01 <joelteon> what's Doc for?
10:30:04 <merijn> > null [1]
10:30:05 <lambdabot>   False
10:30:05 <applicative> oh indeed
10:30:07 <merijn> > null []
10:30:08 <lambdabot>   True
10:30:09 <applicative> Taneb++
10:30:38 <Taneb> merijn, what makes you think it's a guess? I've seen people ask this question a dozen times
10:30:51 <applicative> joelteon: it's the builtin prettyprint type
10:30:55 <merijn> Taneb: Well, the rest of us were confused what the question was :p
10:31:02 <S_J> merijn: without some sort of extension? for big projects i want to be able to overlook it. i guess you can add that to emacs.
10:31:08 <applicative> lambdabot messes it up a little for security
10:31:17 <applicative> > text "hello" $$ text "world"
10:31:18 <lambdabot>   hello
10:31:18 <lambdabot>  world
10:31:23 <applicative> > text "hello" $$ text " world"
10:31:24 <lambdabot>   hello
10:31:24 <lambdabot>   world
10:31:28 <S_J> small for me is less than say, 5 files.
10:31:54 <notdan> NovaDenizen: Try 'deriving instance Eq (f (Fix f)) => Eq (Fix f)'
10:32:09 <applicative> @type space
10:32:09 <lambdabot> Doc
10:32:11 <notdan> and StandAloneDeriving instead of GeneralizedNewtypeDeriving
10:32:25 <joelteon> oh, awesome
10:32:29 <applicative> > text "hello" <> space <> text "joelton"
10:32:30 <MeepyTheParrot> i got it, it was if [] == [] then (putStrLn "wrong") else (putStrLn "right")
10:32:31 <lambdabot>   hello joelton
10:32:35 <merijn> S_J: Well, like I said, command-t which is a file opening plugin (it lets you fuzzy match filenames) and syntax highlighting was about the only stuff I used for C
10:32:58 <notdan> merijn: not even ctags?
10:32:58 <merijn> S_J: With a couple hundred files, I just use find/grep/more and ctags a lot
10:33:03 <notdan> oh ok
10:33:20 <merijn> notdan: tbh, I only started really using ctags afterwards
10:33:27 <merijn> notdan: Most of my time I didn't really use it
10:34:13 <applicative> > text "hello" <> space <> text "joelton" $$ hcat (words "this is #haskell")
10:34:14 <lambdabot>   Couldn't match type `[GHC.Types.Char]'
10:34:14 <lambdabot>                with `Text.PrettyPrin...
10:34:19 <applicative> uhoh
10:34:30 <applicative> > text "hello" <> space <> text "joelton" $$ hcat (map text $ words "this is #haskell")
10:34:31 <lambdabot>   hello joelton
10:34:31 <lambdabot>  thisis#haskell
10:34:40 <applicative> > text "hello" <> space <> text "joelton" $$ ccat (map text $ words "this is #haskell")
10:34:41 <lambdabot>   Not in scope: `ccat'
10:34:41 <lambdabot>  Perhaps you meant one of these:
10:34:41 <lambdabot>    `cat' (imported fr...
10:34:47 <applicative> > text "hello" <> space <> text "joelton" $$ vcat (map text $ words "this is #haskell")
10:34:48 <lambdabot>   hello joelton
10:34:48 <lambdabot>  this
10:34:48 <lambdabot>  is
10:34:48 <lambdabot>  #haskell
10:34:53 <applicative> pardon obnoxious spam
10:35:30 <applicative> somehow irssi makes it less practical to /query lambdabot
10:37:56 <Maior> I'm reading http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf which is good, but it's been so long since I looked at operational / denotational semantics and the like, that, well, I could use something a bit less hardcore - any recommendations?
10:38:22 <Maior> (reached from http://www.haskell.org/haskellwiki/Concurrency)
10:38:40 <Taneb> ...I was about to say "I don't know, try in #haskell maybe?"
10:38:45 <Taneb> Anyway, I'm off
10:39:56 <ReinH> :t vcat
10:39:57 <lambdabot> [Doc] -> Doc
10:40:20 <applicative> that paper is hard for the simple reason that its topic is close to the limits of possible language
10:40:33 <applicative> not to be confused with hcat ; most people wont have this problem
10:40:39 <ReinH> applicative: I made a thing yesterday :D
10:41:13 <applicative> a thing? Thing One or Thing Two?
10:41:32 <ReinH> applicative: heh, I made a "dijkstra map" algorithm
10:41:38 <Maior> applicative: mmm yes
10:41:57 <Maior> applicative: it's a bit more than I can manage at 6 on a Friday
10:43:14 <applicative> http://static.seekingalpha.com/uploads/2009/1/20/saupload_things.jpg has things
10:43:37 <Maior> <3 seekingalpha
10:44:11 <ReinH> applicative: it uses a tropical semiring and a lot of Vector for SPEED
10:47:20 <applicative> ooh vector good, speed very good
10:47:47 <Dodek> hey, why i see "tropical semiring" mentioned in haskell channel?
10:47:49 <applicative> tropical semiring i will have to study
10:48:52 <applicative> Tropical surfaces are exactly the non-Archimedean amoebas over ...
10:51:42 * applicative is distracted by the amoeba-begriff "A two-dimensional amoeba has a number of "tentacles" which are infinitely long and exponentially narrowing towards infinity."
10:52:24 <ReinH> Dodek: because it's relevant?
10:52:51 <Dodek> ReinH: what i'm wondering is how it's relevant
10:52:56 <MeepyTheParrot> Can somebody hint at what is the de-sugared form of case [(9, "")] of [(n, _)] -> Just n; _ -> Nothing?
10:53:05 <ReinH> applicative: tropicall semirings are naturals + infinity with min as plus and + as times
10:53:12 <ReinH> Dodek: well, I'm using them for pathfinding
10:54:46 <ReinH> Dodek: *-semirings are very useful in general http://r6.ca/blog/20110808T035622Z.html
10:54:57 <FreeFull> You can also use negative infinity, max and minus
10:54:58 <applicative> i see, its pretty straightforward yes. it makes min more usable.
10:55:04 <sclv_> tropical geometry is amazing
10:55:06 <ReinH> FreeFull: true
10:55:18 <sclv_> you can also use maxplus as i recall
10:55:22 <ReinH> roconnor's blog post is amazing
10:55:52 <sclv_> one neat intuition is that its the 'limit case' of working in logspace
10:55:57 <sclv_> since times goes to plus
10:56:00 <erisco> um what module are the io functions in?
10:56:17 <sclv_> and for numbers where one sufficiently dominates the other, then 'max' is as good as plus
10:56:21 <erisco> System.IO found em thanks
10:56:47 <ReinH> sclv_: neat!
10:57:13 <ReinH> applicative: https://github.com/reinh/DijkstraMap/blob/master/TropicalSemiring.hs
10:57:15 <Dodek> ReinH: i'm an algebraic geometer by trade, so i'm kind of surprised about seeing this stuff here
10:57:51 <sclv_> i'm only a dabbler, but idempotent/tropical semirings arise fairly frequently in CS applications
10:57:56 <ReinH> Dodek: ah! There's a lot of algebra in Haskell :D
10:58:04 <pavonia> MeepyTheParrot: What do you mean by de-sugared here?
10:58:16 <ReinH> sclv_: I am even more of a dabbler, but that is my impression as well
10:58:21 <sclv_> any time you want to maximize some quantity and do some transitive accumulation they sort of fall out of the algos naturally
10:58:22 <MeepyTheParrot> I mean without the do notation
10:58:23 <ReinH> Dodek: you might enjoy that blog post :)
10:58:43 <Dodek> ReinH: yeah it seems so :)
10:58:43 <applicative> infinity = Tropical Nothing
10:58:57 <pavonia> MeepyTheParrot: There is no do there
10:59:09 <MeepyTheParrot> hmm sec
10:59:52 <ReinH> applicative: you just need a sum type Infinity | Finite a. Maybe is isomorphic and gives me lots of free properties :)
11:00:05 <ReinH> the monad instance is particularly easy to write ;)
11:00:29 <erisco> :t getContents
11:00:31 <lambdabot> IO String
11:00:35 <erisco> wha
11:00:37 <MeepyTheParrot> sorry let me try to fix my question :\
11:00:58 <erisco> how is getContents supposed to work
11:01:02 <FreeFull> ReinH: I still find it very cool that one can take some concept from maths and embed it into Haskell so easily
11:01:06 <donri> erisco: lazy IO
11:01:15 <ReinH> FreeFull: me too!
11:01:15 <erisco> the type signature
11:01:18 <erisco> how does that make sense
11:01:30 <arkeet> MeepyTheParrot: that's as desugated as it gets. :)
11:01:32 <donri> erisco: String is a list of Char, getContents uses lazy IO
11:01:33 <monochrom> getContents is a bit of built-in, so it can do special things
11:01:34 <arkeet> a lot of things desugar to case.
11:01:44 <FreeFull> erisco: It reads from stdin
11:01:46 <ReinH> Dodek: also check out basically any of edwardk's packages
11:01:46 <erisco> donri, I don't understand... how does it know what file to read from
11:01:47 <donri> erisco: lists are lazy
11:01:49 <erisco> FreeFull, ohhh
11:01:53 <arkeet> unless you want to desugar the list syntax too.
11:01:54 <donri> erisco: oh. it's from stdin.
11:01:57 <ReinH> Dodek: he brings a LOT of math, more than I can deal with frankly :)
11:02:01 <donri> :t hGetContents
11:02:02 <lambdabot>     Not in scope: `hGetContents'
11:02:02 <lambdabot>     Perhaps you meant one of these:
11:02:02 <lambdabot>       `BSC.hGetContents' (imported from Data.ByteString.Char8),
11:02:10 <donri> @hoogle hGetContents
11:02:10 <lambdabot> System.IO hGetContents :: Handle -> IO String
11:02:10 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
11:02:10 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
11:02:17 <FreeFull> :t readFile
11:02:18 <lambdabot> FilePath -> IO String
11:02:31 <ReinH> Dodek: https://github.com/ekmett?tab=repositories
11:02:32 <donri> @src readFile
11:02:32 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
11:02:41 <applicative> ReinH: are the grids always secretly n >< m ?
11:02:49 <Dodek> ReinH: yeah, i already follow lots of his stuff
11:02:52 <ReinH> applicative: what do you mean?
11:03:00 <ReinH> applicative: as in, are they all rectangular?
11:03:06 <ReinH> Dodek: cool :)
11:03:14 <applicative> ReinH: yes
11:03:15 <FreeFull> I wonder how many typesafe implementations of matrices there are
11:03:23 <ReinH> applicative: yes, it is assumed so
11:03:42 <ReinH> I don't guarantee it but I don't particularly care to try either
11:04:07 <erisco> I'm missing how you resolve the file name... from String to Filepath to Handle
11:04:52 <ReinH> applicative: Using V2 Int to index the Vector (Vetor a) and provide the TraversableWithIndex instance makes it very easy to hide the implementation of the grid :D
11:05:00 <applicative> ReinH: i was just thinking how i could express this with unboxed vectors without getting into a repa-ish nightmare
11:05:49 <ReinH> applicative: yeah, but I'm getting pretty good speeds.
11:06:04 <applicative> unbox instances for V2 and Tropical u are easy enough.
11:06:16 <applicative> ReinH: yes, I was just thinking about it while looking
11:06:17 <ReinH> ~30ms to calculate a roguelike-sized map
11:06:25 <ReinH> applicative: I have been thinking about it too :)
11:07:10 <applicative> how big are typical Grids?
11:07:25 <FreeFull> erisco: FilePath is a String
11:07:42 <MeepyTheParrot> oh... it really is desugared, silly me
11:07:45 <FreeFull> @src openFile
11:07:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:07:45 <MeepyTheParrot> Thanks a lot ^_^
11:07:51 <ReinH> applicative: well, traditional roguelike grids fit into a 80x24 terminal window...
11:08:13 <ReinH> I'd say 50 >< 50 or so is a decent size
11:08:24 <applicative> oh ok that is pretty small. Maybe Vector (Vector ..) is exactly the right concept anyway
11:08:30 <arkeet> ×
11:08:38 <ReinH> yeah pretty small
11:08:52 <arkeet> took me a while to figure out what >< was.
11:08:59 <ReinH> applicative: I could use a fancy distance field transformation and I talked to acowley about that too
11:09:02 <ReinH> but this works pretty well
11:09:14 <notdan> Is there a way to force GHC to use a .hs-boot file?
11:09:16 <ReinH> arkeet: me too, I just tried to roll with it :)
11:09:24 <ReinH> arkeet: I've also seen it mean /=
11:09:35 <arkeet> :<
11:09:39 <monochrom> force? does it need forcing?
11:09:59 <ReinH> "sudo use the .hs-boot file"
11:10:16 <applicative> use .!hs.boot as the extension
11:10:25 <monochrom> haha
11:10:47 <monochrom> anyway, it works for me
11:11:02 <notdan> oh nvm, for some reason I thought that ghc was supposed to pick up .hs-boot files, turns out cabal does that
11:11:20 <ReinH> my biggest problem with Haskell is that it's really hard to go back to other langauges after using it :/
11:11:31 <erisco> cool my first IO in Haskell
11:11:34 <ReinH> Like I'm supposed to go write some Ruby today for, you know, work or whatever
11:11:37 <ReinH> but I don't wanna
11:11:43 <ReinH> erisco: high five!
11:11:48 * erisco returns!
11:11:49 <monochrom> ghc picks up .hs-boot files alright. does not need cabal.
11:12:34 <erisco> did I do it right? http://lpaste.net/92646
11:12:48 <ReinH> applicative: the algorithm is slightly clever. It pre-computes a breadth-first traversal order and then uses that to find a fixed point of the dijkstr map
11:13:25 <monochrom> err, nevermind, different notions of "pick up"
11:13:41 <applicative> good work erisco !
11:13:42 <applicative> its certainly not a cabal related device, to boot file
11:13:42 <applicative> the boot file, rather
11:14:19 <applicative> erisco: but what are you going to do with the Grammar, once you get it?
11:14:30 <erisco> applicative, oh, some devious things. why?
11:15:02 <applicative> erisco: this could be fmap parseGrammer . readFile I think
11:15:10 <monochrom> erisco: you do it wrong. you get an hClose too early
11:15:19 <erisco> :t readFile
11:15:20 <applicative> readFile is basically openFile file ReadMode >>= hGetContents
11:15:20 <monochrom> err wait, I misread. you do ok.
11:15:20 <lambdabot> FilePath -> IO String
11:15:33 <monochrom> but readFile is even better
11:15:50 <applicative> erisco: this is lazy io so it's a bit delicate, but at the moment, I think readFile will do fine
11:16:12 <erisco> yes readFile works well and shortens it up
11:18:45 <ReinH> applicative: I'm thinking about applying the algorithm monatically instead. Using mutable arrays and state so I can track "did I change anything in this iteration" so I can terminate more efficiently.
11:18:58 <ReinH> Right now I'm doing vector equality checks, which are unnecessarily inefficient.
11:19:08 <ReinH> *monadically
11:23:25 <erisco> applicative, why delicate?
11:23:58 <arkeet> lazy IO is scary. =(
11:24:00 <ReinH> erisco: it's hard to reason about lazy IO.
11:24:12 <ReinH> how much IO will it do when? Who knows?
11:24:15 <erisco> when just reading?
11:24:23 <erisco> I don't care when it does it
11:25:16 <ReinH> edwardk: have a sec?
11:27:23 <amyers> erisco: Even when just reading it can be difficult to know when you can safely close the file.  If you don't mind letting the file handle hang around till the GC gets to it that doesn't matter though
11:28:07 <erisco> amyers, ah
11:29:09 <merijn> I'll take "Why does pipes exist for 200, Alex."
11:29:22 <merijn> eh, wrong quotation marks there, but you get the idea
11:29:26 <sclv_> in general on the -libraries discussion, does anyone thing there's a good reason for printf in base?
11:29:42 <sclv_> my inclination is to pull it out of base, and toss a well maintained package into the platform
11:29:43 <merijn> sclv_: printing floating point numbers and the like?
11:29:52 <sclv_> we can do that via the numeric libs
11:30:13 <erisco> $2000 question was what MSDOS stood for once, I believe
11:30:23 <sclv_> cf: http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Numeric.html
11:30:40 <erisco> makes you realize how common place the questions are if only you were an expert on everything
11:31:01 <sclv_> although it drives me a bit nuts that those functions are only in a top level module
11:31:04 <amyers> erisco: err, I'm thinking of the handle API, you can't close the file opened with readFile :p
11:31:10 <sclv_> they really should be nested one level down maybe
11:31:26 <applicative> ooh, expel printf from base; sclv_ is my kind of libraries-lister
11:31:39 <erisco> amyers, I presume it auto-closes after all data has been lazily read
11:31:41 <joastbg> hi, i am quite new to haskell, but have been using F# for a while, in F# here is a function called Seq.windowed n, where n is the length of the window, does haskell has an eq?
11:31:47 <amyers> erisco: yep
11:32:05 <applicative> wait, what is a window joastbg
11:32:14 <ReinH> joastbg: what does it do?
11:32:28 <merijn> applicative, sclv_: I'll back moving printf out of base, in exchange for more pressure behind implementing AMP and the migration of Foldabel and Traversable to Prelude ;p
11:32:47 <joastbg> window, is a function in F#, Seq.windowed, does take a list, ie [1,2,3,4] where, suppose n = 2, [1,2], [2,3], [3,4] etc
11:32:47 <sclv_> current printf has been unmaintained for years too
11:32:53 <merijn> applicative: Presumably a sliding window over a list/sequence
11:32:55 <amyers> joastbg: Sounds like recursively applying splitAt to the snd of the result of splitAt
11:32:59 <applicative> joastbg: import Data.List.Split
11:33:15 <arkeet> > transpose $ tails [1..10]
11:33:16 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
11:33:18 <arkeet> hmm.
11:33:27 <arkeet> heh, haha.
11:33:27 <merijn> Something with iterating (take n . drop x)
11:33:57 <arkeet> figures that transpose . tails = tails
11:34:12 <arkeet> > take 2 <$> tails [1..5]
11:34:14 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5],[]]
11:34:24 <arkeet> @where clever
11:34:24 <lambdabot> I know nothing about clever.
11:34:27 <arkeet> @where sneaky
11:34:27 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
11:34:30 <arkeet> @@ @let @where sneaky
11:34:31 <lambdabot>  Defined.
11:34:36 <arkeet> > take 2 . dropFromEnd 2 <$> tails [1..5]
11:34:40 <applicative> oh i see now what joastbg means, yes
11:34:43 <lambdabot>   [[1,2],[2,3],[3],[],[],[]]
11:34:46 <arkeet> hm.
11:34:58 <applicative> at first I thought it was Data.List.Split.chunk
11:35:00 <arkeet> > map (take 2) . dropFromEnd 2 $ tails [1..5]
11:35:03 <lambdabot>   [[1,2],[2,3],[3,4],[4,5]]
11:35:07 <joastbg> yes, that is what I mean, a sliding window
11:35:09 <amyers> applicative: That's what I was thinking as well
11:35:39 <arkeet> > zip`ap`tail $ [1..5]
11:35:41 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
11:35:46 <erisco> hmm so I hear monads could also let me deal with Maybe types
11:35:51 <arkeet> Maybe is a monad.
11:35:51 <joastbg> thanks, I will check the snippets posted here
11:35:53 <joelteon> > zip <*> tail $ [1..5]
11:35:55 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
11:35:55 <applicative> tails is the bread and butter function that goes with this idea joastbg
11:35:59 <arkeet> @where zip`ap`tail
11:36:00 <lambdabot> I know nothing about zip`ap`tail.
11:36:02 <arkeet> @quote zip`ap`tail
11:36:02 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
11:36:08 <applicative> thats so amazing
11:36:33 <applicative> almost as good as
11:36:35 <erisco> > liftM (+1) $ Nothing
11:36:36 <lambdabot>   Nothing
11:36:37 <applicative> @quote oasis
11:36:38 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:36:39 <erisco> okay cool
11:36:43 <joastbg> btw, I found Haskell to be more expressive than F#, more conscience code, so I am changing territory
11:36:48 <MeepyTheParrot> Hello again. I am trying to write a haskell function which accepts string inputs until "done" and returns the list of all the inputs. So far I have http://hastebin.com/letekanoyi.coffee, but it complains that IO [String] cannot be cons'd to [String], thanks ahead of time.
11:36:50 <bennofs> @ty ap
11:36:51 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:36:59 <ski> @type (<*>)
11:37:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:37:05 <merijn> erisco: basically, the maybe monad is "m >>= f" is Nothing if m is nothing, otherwise it returns the result of f
11:37:13 <erisco> so to work on IO (Maybe Grammar), I lift twice
11:37:20 <ski> @src Maybe (>>=)
11:37:20 <lambdabot> (Just x) >>= k      = k x
11:37:20 <lambdabot> Nothing  >>= _      = Nothing
11:37:25 <arkeet> MeepyTheParrot: time to learn about IO.
11:37:34 <arkeet> @wiki introduction to IO
11:37:35 <lambdabot> http://www.haskell.org/haskellwiki/introduction_to_IO
11:37:35 <applicative> joastbg: i think it's good to study haskell and a strict ml-ish language like f# together; about the oo-ness of F# i dunno
11:37:45 <merijn> Time to quote shachaf? :p
11:37:49 <arkeet> yes
11:37:49 <merijn> @quote shachaf /bin/ls
11:37:50 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:38:04 <shachaf> "It's always time to quote shachaf."
11:38:06 <joastbg> Yes I know, I currently write a book about F#, will be out in jan 2014
11:38:06 <shachaf> -- shachaf
11:38:18 <ReinH> shachaf: :)
11:38:20 <ski> joastbg : the module system of SML and OCaml is interesting
11:38:40 <applicative> oic joastbg so your case is different from what i thought!
11:38:41 <arkeet> well, a tiny modification to the last line could do it.
11:38:47 <arkeet> n -> fmap ([n] ++) getLines
11:39:07 <joelteon> fmap (n:) getLines
11:39:12 <arkeet> or... n -> do { ls <- getLines; return ([n] ++ ls) }
11:39:15 <arkeet> ah, fair.
11:39:16 <joastbg> F# is a good newcomer to the field, and I think F# is a great lang. for pragmatic usage, combining .NET and ML, great for real world applications
11:39:18 <joelteon> [x] ++ makes me wince
11:39:20 <arkeet> :P
11:39:35 <ReinH> joelteon: one thing at a time :)
11:39:57 <arkeet> case l of
11:40:10 <applicative> [x] <> blah has a certain charm compared to x : blah , though
11:40:14 <MeepyTheParrot> yay it works ^_^
11:40:18 <MeepyTheParrot> thanks
11:40:18 <ReinH> applicative: does it really? :p
11:40:26 <arkeet> MeepyTheParrot: now understand *why* it works.
11:40:31 <arkeet> or rather, why the other one didn't.
11:40:32 <applicative> if it continues with a number of <>'s
11:40:55 <MeepyTheParrot> I do not that is why I am studying it :)
11:40:56 <applicative> maybe i just love my shine new, or newish, <>
11:40:58 <ReinH> applicative: I'd prefer x : y : z : ws to [x] <> [y] <> [z] <> ws :p
11:41:12 <applicative> okay there you certainly win
11:41:13 <MeepyTheParrot> I am terrified of fmap >.>
11:41:23 <ReinH> MeepyTheParrot: are you terrified of map for lists?
11:41:26 <applicative> fmap is the whole secret
11:41:36 <MeepyTheParrot> I spent weeks trying to understand fmap
11:41:41 <MeepyTheParrot> and i am still nowhere
11:41:43 <applicative> MeepyTheParrot is right to be terrified!
11:41:43 <ParahSailin> @ty fmap
11:41:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:41:48 <erisco> ah I could use maybe applicative as well
11:41:49 <shachaf> Terrified of fmap? Minimize your fmap use with CoYoneda!
11:41:50 <joelteon> fmap (+1) (Just 3)
11:41:54 <joelteon> > fmap (+1) (Just 3)
11:41:56 <applicative> hah
11:41:56 <lambdabot>   Just 4
11:41:57 <MeepyTheParrot> I even went as far as trying to read maclane to understand functors
11:42:04 <quchen> shachaf: I'm sure that cleared things up!
11:42:06 <ReinH> arkeet: and for the love of god, fmap (n:) getLines :p
11:42:06 <MeepyTheParrot> I even annoyed 5 professors at university asking questions
11:42:08 <MeepyTheParrot> >.>
11:42:13 <applicative> MeepyTheParrot: thats one way to keep the panic going
11:42:18 <arkeet> ReinH: I mentioned the fmap thing first.
11:42:34 <arkeet> but one thing at a time. :p
11:42:38 <ReinH> arkeet: touche :D
11:42:39 <Quadrescence> fmap: the computation injector
11:42:41 <Quadrescence>     the syringe of computer science
11:42:41 <arkeet> MeepyTheParrot: you don't need to read maclane.
11:42:43 <arkeet> :p
11:42:49 <ReinH> fmap: the magic burrito transmogrifier
11:42:59 <applicative> mac lane is on the index of forbidden books!
11:43:03 <joastbg> of course, I like the ML nature of F#, and how easy it is to create oo-objects etc, and the leveraging of .NET platform, like Clojure and JVM, the future is about virtual machines and functional langunages
11:43:09 <monochrom> I no longer suggest people "concrete before abstract". because they don't listen anyway.
11:43:15 <ReinH> fmap: it takes a thing out of a thing, does something to the thing, and puts the new thing'd thing back in the thing.
11:43:18 <ReinH> How easy is that?
11:43:23 <thoughtpolice> ReinH: fmap takes burrito internals and replaces them with taco internals
11:43:36 <ReinH> thoughtpolice: we've secretly replaced the contents of your functor...
11:43:46 <applicative> monochrom thats because 'concrete' is the most abstract of all concepts
11:44:05 <MeepyTheParrot> My mind is blown yet again
11:44:24 <monochrom> is it a Functor or a Monad? it's both! http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
11:44:31 <shachaf> ReinH: It's wrong, so it doesn't matter how easy it is. :-(
11:44:35 <joastbg> also found an existing function in a blog, http://www.markhneedham.com/blog/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/
11:44:38 <ski> applicative : hm, i'm reminded of problems with defining "finite" ..
11:44:58 <applicative> ReinH: the #haskell spinal cord says: try that with ContT!
11:44:58 <arkeet> I have a copy of maclane =(
11:44:58 <joastbg> another guy with the same question, maybe it should fit into the standard lib?
11:45:01 <ReinH> shachaf: I know. I was hoping it would slide as a joke.
11:45:02 <arkeet> but not because of haskell
11:45:16 <ski> arkeet : i also "have" one
11:45:32 <arkeet> define "have"
11:45:38 <ReinH> MeepyTheParrot: do you know the Identity fuctor?
11:45:58 <MeepyTheParrot> I read about it several times, but I still do not know
11:46:04 <ski> i borrowed it from uni lib (there's several exemplars), and now it appears to have forgotten that i've borrowed it
11:46:07 <arkeet> if monads are like burritos, then Identity is like a burrito with no wrap
11:46:14 <arkeet> ski: ah, nice.
11:46:18 <arkeet> :p
11:46:28 <monochrom> hahah ski wins
11:46:40 <applicative> no, lets begin at the beginning
11:46:41 <applicative> with the Constant functor
11:46:43 <quchen> Maybe stop using words like "burrito" and "easy" while someone is struggling with understanding Functors.
11:46:52 <applicative> or maybe data Blank a = Blank; instance Functor Blank where fmap f Blank = Blank; it's all so clear
11:47:13 <applicative> or not
11:47:15 <ReinH> MeepyTheParrot: Identity is a wrapper around a single value.
11:47:16 <MeepyTheParrot> I'll write that down
11:47:34 <ReinH> > Identity 1
11:47:37 <lambdabot>   Identity {runIdentity = 1}
11:47:42 <ReinH> MeepyTheParrot: you get the value back out with runIdentity:
11:47:46 <ReinH> > runIdentity (Identity 1)
11:47:48 <lambdabot>   1
11:47:53 * monochrom has a cunning plan. {-# LANGUAGE EmptyDataDecls, DeriveFunctor #-} data Void a deriving Functor
11:47:55 <ReinH> MeepyTheParrot: ok? That's it.
11:48:03 <ParahSailin> @ty runIdentity
11:48:04 <lambdabot> Identity a -> a
11:48:16 <ReinH> MeepyTheParrot: let's say I have a value and I want to apply some function to it
11:48:26 <ReinH> > succ 1
11:48:27 <lambdabot>   2
11:48:30 <ReinH> easy, right?
11:48:39 <ReinH> But what if that value is wrapped in Identity?
11:48:58 <applicative> monochrom: works fine, i wonder what is derived
11:48:58 <ReinH> succ (Identity 1) won't work
11:49:11 <ski> MeepyTheParrot : do you understand the rough "generic-collection" intuition of `Functor's ?
11:49:13 <erisco> > succ (Identity 1)
11:49:15 <lambdabot>   No instance for (GHC.Show.Show a0)
11:49:15 <lambdabot>    arising from a use of `M1792964574.sh...
11:49:30 <MeepyTheParrot> >.> i'm trying to follow but it's taking a while
11:49:36 <ReinH> MeepyTheParrot: what we want to do is apply succ to the value that is wrapped by Identity
11:50:05 <ReinH> > Identity (succ 1)
11:50:07 <ReinH> right?
11:50:09 <lambdabot>   Identity {runIdentity = 2}
11:50:29 <MeepyTheParrot> what is "Identity"
11:50:37 <arkeet> data Identity a = Identity a
11:50:40 <MeepyTheParrot> ah
11:50:42 <ReinH> MeepyTheParrot: it is just a data type
11:50:46 <ReinH> that contains a single value
11:50:48 <joelteon> it's the datatype version of id
11:50:49 <arkeet> well, newtype Identity a = Identity { runIdentity :: a }
11:50:54 <monochrom> the generic collection idea works fine for [], Maybe, etc. But then to do IO, STM etc you will need a generic effect idea.
11:51:08 <ReinH> MeepyTheParrot: so, here's the key insight for fmap:
11:51:19 <ski> *nod*, or generalize "collection" to cover those appropriately
11:51:25 <ski> monochrom : still, it's a start
11:51:28 <applicative> does lambdabot have its own show instance for Identity?
11:51:31 <ReinH> fmap succ (Identity 1) = Identity (succ 1)
11:51:41 <elliott> yes, a derived one
11:51:49 <merijn> applicative: Pretty sure the derived one is there by default?
11:51:50 <elliott> it's annoying not having it
11:51:52 <elliott> it isn't.
11:51:55 <merijn> aww
11:52:13 <applicative> merijn: there isn't a derived one, or do I have the wrong Identity
11:52:31 <applicative> merijn: vide http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/transformers/src/Data-Functor-Identity.html#Identity
11:52:53 * hackagebot derive 2.5.13 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.13 (NeilMitchell)
11:52:53 <merijn> applicative: According to elliott I'm wrong
11:52:55 <ReinH> > fmap succ (Identity 1)
11:52:59 <lambdabot>   Identity {runIdentity = 2}
11:53:04 <ReinH> MeepyTheParrot: do you see how that's the same as Identity (succ 1)?
11:53:17 <applicative> yes it's always been a problem with Identity
11:53:22 <MeepyTheParrot> I'm not sure, is it that if I make a data type, eg, data Something a = Something a, then if I want to apply some function on "Something a", I would need to define a fmap that would turn myfunction "Something a" into Something "myfunction a" or am I completely off?
11:53:27 <ReinH> MeepyTheParrot: fmap "moves" the function to the "inside" of the functor.
11:53:54 <merijn> MeepyTheParrot: Naah, Functor is for wheny you have "Something a", but want to apply a function to "a"
11:54:14 <MeepyTheParrot> so if I have Maybe 2, and I want to sqrt(Maybe 2)?
11:54:16 <ReinH> MeepyTheParrot: if you have a Something a (which is exactly what Identity a is) and you have a function that works on a
11:54:18 <MeepyTheParrot> Just 2*
11:54:24 <merijn> MeepyTheParrot: Yes
11:54:25 <arkeet> > fmap sqrt (Just 2)
11:54:27 <lambdabot>   Just 1.4142135623730951
11:54:30 <ReinH> MeepyTheParrot: yes, exactly
11:54:37 <arkeet> > fmap sqrt [2,3,5]
11:54:38 <lambdabot>   [1.4142135623730951,1.7320508075688772,2.23606797749979]
11:54:38 <merijn> MeepyTheParrot: In fact, Maybe is a Functor too as you can see
11:54:41 <MeepyTheParrot> ooh :)
11:54:45 <applicative> maybe we should also say that everything  we cant publically recommend a patch for should be thrown out of base too
11:55:02 <arkeet> > fmap sqrt (+3) 2
11:55:03 <lambdabot>   2.23606797749979
11:55:06 <ReinH> MeepyTheParrot: you want to take a function on a's and turn it int function on Something a's
11:55:09 <ReinH> so you use fmap
11:55:10 <applicative> communicating the obvious with Prof. Patterson is hopeless.
11:55:13 <arkeet> > fmap sqrt ("hello",2)
11:55:16 <lambdabot>   ("hello",1.4142135623730951)
11:55:25 <merijn> arkeet: I think the functor instance for functions is counteproductive at this point in time
11:55:28 <arkeet> ok fine.
11:55:34 <erisco> tuple functor is a bit bleh
11:55:43 <ski> > fmap f [x,y,z]                           :: [Expr]
11:55:44 <arkeet> > [fmap sqrt (Left "hello"), fmap sqrt (Right 2)]
11:55:44 <lambdabot>   [f x,f y,f z]
11:55:45 <merijn> erisco: How so?
11:55:45 <lambdabot>   [Left "hello",Right 1.4142135623730951]
11:55:47 <paolino> I don't understand why I have to get back what I put in with a lens, what's wrong if I put a Just 1 and read a Nothing with the same lens ?
11:55:52 <erisco> merijn, why the snd?
11:56:05 <arkeet> erisco: Functor ((,) a)
11:56:11 <merijn> erisco: Because Functor requires kind "* -> *"
11:56:15 <applicative> man ski how do you figure out what Simple.Reflect will and wont accept?
11:56:16 <erisco> no no :P
11:56:17 <MeepyTheParrot> Okay, so now I understand one use of fmap
11:56:22 <ReinH> paolino: because lenses should compose
11:56:27 <MeepyTheParrot> my head hurts a little less
11:56:28 <ski> applicative : try before buy
11:56:32 <merijn> erisco: Tuple is * -> * -> *, which means you need to partially apply it
11:56:36 <applicative> hah
11:56:39 <ReinH> MeepyTheParrot: now, I said "inside" earlier and that's not always accurate
11:56:43 <erisco> merijn, I did not get my question across correctly
11:56:45 <ReinH> MeepyTheParrot: some functors don't have a value "inside" them
11:56:45 <erisco> never mind
11:56:46 <arkeet> > (over both) sqrt (2,3)
11:56:48 <lambdabot>   (1.4142135623730951,1.7320508075688772)
11:56:58 <ReinH> MeepyTheParrot: IO a is a functor, but IO String doesn't "contain" a string
11:56:58 <paolino> ReinH, isn't it a problem of types ?
11:57:03 <arkeet> @quote /bin/ls
11:57:03 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:57:37 * ski suspects that MeepyTheParrot would be happier with a little less side-noise (from the perspective of understanding `fmap')
11:57:44 <erisco> > (1,)
11:57:45 <lambdabot>   Illegal tuple section: use -XTupleSections
11:57:54 <ReinH> MeepyTheParrot: consider this:
11:58:00 <ReinH> :t fmap toUpper getChar
11:58:01 <lambdabot> IO Char
11:58:04 <joelteon> @let -XTupleSections
11:58:04 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:58:06 <ski> (perhaps moving to #haskell-overflow or #haskell-in-depth could be useful here ?)
11:58:06 <applicative> the correct way to say it is: the action of writing a letter to your mother is not a letter to your mother
11:58:21 <MeepyTheParrot> Ah
11:58:30 <ReinH> MeepyTheParrot: getChar is an IO Char but it is not "IO containing a Char". It is "IO that will produce a Char when run"
11:58:31 <MeepyTheParrot> n      -> fmap ([n] ++) getLines makes sense kinda
11:58:33 <erisco> joelteon, was just checking for a 1-tuple
11:58:44 <ReinH> MeepyTheParrot: fmap toUpper getChar is "IO that will produce an uppercase Char when run"
11:58:48 <joelteon> a 1-tuple is...just a value
11:58:51 <MeepyTheParrot> I map ([n] ++) inside the IO, creating a new IO [String]
11:58:54 <ReinH> MeepyTheParrot: see how fmap works there?
11:58:59 <merijn> MeepyTheParrot: Correct
11:59:11 <ReinH> MeepyTheParrot: exactly
11:59:20 <arkeet> =)
11:59:25 <merijn> MeepyTheParrot: The usual answer to "How do I get X out of IO?" is "You don't, you get the rest *into* IO"
11:59:27 <enthropy> is there a Gtk2HsSetup.hs that works with Cabal-1.18?
11:59:36 <ReinH> fmap ([n]++) getLines is: IO that will produce n ++ lines when run.
11:59:42 <MeepyTheParrot> merijn, that makes sense
11:59:43 <arkeet> enthropy: dmwit might know.
11:59:51 <MeepyTheParrot> I just never knew how to do that, now I know
11:59:53 <paolino> enthropy, no, there is a name clash
11:59:57 <applicative> the action of baking a loaf of bread is not a loaf of bread; the question 'how do i extract a loaf of bread from the action of baking a loaf of bread' is ill posed. And so on.
12:00:06 <ReinH> MeepyTheParrot: so does fmap make more sense now?
12:00:09 <MeepyTheParrot> yeah
12:00:10 <enthropy> paolino: it's more than that, some stuff got rearranged
12:00:17 <ReinH> MeepyTheParrot: high five :D
12:00:17 <merijn> MeepyTheParrot: Well, there's more ways than just fmap and other conveniences, but I'll leave those to ReinH
12:00:22 <MeepyTheParrot> :)
12:00:26 <paolino> yes I gave up
12:00:28 <MeepyTheParrot> I know but this is a start
12:00:30 <ski> @quote recipe
12:00:30 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
12:00:43 <MeepyTheParrot> before, I thought fmap was just there to scare beginners
12:00:44 <merijn> ski: What if I wrote the recipe on a cake?
12:00:45 <applicative> the bad part of that is the 'recipe' part
12:00:46 <MeepyTheParrot> and I'm sure it is
12:00:51 <ReinH> MeepyTheParrot: this is the key insight for fmap and functors imo :)
12:00:53 <MeepyTheParrot> but at least it has other uses
12:01:05 <arkeet> :t fmap fmap fmap
12:01:06 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:01:10 <ReinH> arkeet: don't you start :p
12:01:12 <arkeet> :p
12:01:13 <ski> merijn : then the denotation of the writing on that cake is a recipe
12:01:30 <merijn> MeepyTheParrot: Well, you could write "putFIntoIO :: (a -> b) -> IO a -> IO b", but it turns out that it's so general, you see it all over the place
12:01:35 <applicative> if getLine were a recipe, who would follow it?
12:01:38 <applicative> main = runRTS $ getLine >>= ...
12:01:57 <applicative> main = followRecipe $ getLine >>= ...
12:02:00 <merijn> MeepyTheParrot: The advantage of fmap/Functor is, if you learn it once, you can use it almost everywhere. Because everyone else is using it for other stuff
12:02:31 <merijn> MeepyTheParrot: As you saw, Maybe, list, tuples all work with fmap and many more advanced things too
12:02:47 <MeepyTheParrot> :)
12:02:54 <applicative> merijn: there's nothing to be said against supercake :: IO (Cake, IO Cake)
12:02:56 <monochrom> now is a good time for my question
12:02:58 <ski> applicative : you have similar problems with "execution"
12:03:04 <monochrom> @quote monochrom IO.String
12:03:04 <lambdabot> monochrom says: How do I extract the IO out of IO String?
12:03:12 <paolino> ReinH, can you elaborate on first lens law on values ?
12:03:14 <joelteon> heh
12:03:17 <applicative> execution isn't a word in this language, ski
12:03:26 <merijn> monochrom: Applicative and or Monad :p
12:03:30 <ski> "this language" being ?
12:03:36 <applicative> haskell?
12:03:38 <ski> monochrom : i've been pondering that a little bit ..
12:03:40 <merijn> monochrom: Or Pointed, I guess, if you're one of those deviants
12:03:45 <monochrom> to some extent, I answered that question yesterday. (not here. in my own code)
12:03:58 <ski> ("recipe" isn't a word in the Haskell language either)
12:04:06 <applicative> it's your word, ski
12:04:14 <monochrom> (it uses ConstraintKinds)
12:04:25 <ski> yes. both might be words we could use to talk about Haskell
12:04:28 <merijn> ConstraintKinds is one of my favorite new extensions!
12:04:39 <merijn> Too bad it horribly infects all your modules
12:05:01 <applicative> but what's wrong with what's actually mean, getChar is the action of finding out what the next character is
12:05:20 <levi> MeepyTheParrot: It's sometimes a good exercise, when faced with a really general typeclass like Functor, to practice writing instances (or finding that they can't be written) for various data types and then thinking about what you've just written *does*.
12:05:26 <ski> applicative : i have no complaint with that
12:05:50 <MeepyTheParrot> yeah, but it's really hard to look at those instances before understanding fmap
12:05:58 <merijn> Doesn't typeclassopedia have exercise to write Functor instances for things?
12:06:07 <MeepyTheParrot> now i can look into Maybe monad and possibly understand what fmap in it means
12:06:09 <MeepyTheParrot> maybe
12:06:13 <byorgey> yes, it does
12:06:13 <MeepyTheParrot> i havent looked recently
12:06:15 <merijn> MeepyTheParrot: Depends on the instance, some are embarassingly simple ;)
12:06:19 <enthropy> mr-: as in you should be able to those constraints without the extension?
12:06:21 <merijn> @src fmap Maybe
12:06:22 <lambdabot> Source not found. Sorry.
12:06:24 <enthropy> merijn: ^^
12:06:26 <merijn> @src Maybe fmap
12:06:27 <lambdabot> fmap _ Nothing       = Nothing
12:06:27 <lambdabot> fmap f (Just a)      = Just (f a)
12:06:29 <levi> MeepyTheParrot: The idea is that the intuition for what fmap is comes through exposure to various versions of it.
12:06:56 <ReinH> paolino: the first lens law is view l (set l b a) = b
12:06:58 <MeepyTheParrot> yeah I got no idea still what that means
12:06:59 <MeepyTheParrot> :(
12:07:05 <merijn> enthropy: In the sense that you have to enable it in every module using your synonyms, yes
12:07:08 <ReinH> paolino: or, you get back what you put in
12:07:25 <merijn> MeepyTheParrot: Ah, is there anything specific that confuses you there? Or just general confusion?
12:07:26 <arkeet> I like the lens laws in terms of view and over =(
12:07:27 <MeepyTheParrot> I kinda get fmap f (Just a) = Just (f a), but isn't that obvious?
12:07:29 <enthropy> merijn: just keep everything in one module :p
12:07:35 <arkeet> view l (over l f a) = f (view l a)
12:07:38 <MeepyTheParrot> but the _ Nothing...
12:07:40 <merijn> MeepyTheParrot: Well, sure, it *is* obvious
12:07:46 <arkeet> well, view l . over l f = f . view l
12:07:53 <merijn> MeepyTheParrot: '_' is an unused pattern
12:08:02 <ReinH> MeepyTheParrot: you still have to tell a computer things even when they're obvious ;)
12:08:04 <MeepyTheParrot> ah
12:08:04 <levi> MeepyTheParrot: Well, look at the type signature, for example, of the list type. Then look at the type signature for fmap. Then write a function that fits the type!
12:08:04 <merijn> MeepyTheParrot: It basically says "I don't care about this argument"
12:08:11 <ReinH> well, most of the time
12:08:12 <paolino> ReinH, as long as I've used lenses for caching I didn't break it
12:08:18 <MeepyTheParrot> so for any function applying to nothing, yields nothing
12:08:22 <merijn> MeepyTheParrot: The compiler won't produce warnings for _ patterns
12:08:26 <merijn> MeepyTheParrot: Correct
12:08:32 <arkeet> and over l f . over l g = over l (f . g)
12:09:01 <ski> MeepyTheParrot : often, you have a function signature like `tryBlah :: Foo -> Maybe Result' that when called may either yield a `Just result' or plain `Nothing' -- often you'd want to do some post-processing on `result', in case it's there, otherwise "do nothing" -- that's what `fmap' for `Maybe' will give you
12:09:04 <enthropy> MeepyTheParrot: do you know why you can't have the second case as:  fmap _ x = x?
12:09:11 <ReinH> paolino: I guess that law is self-evident for me, so I'm not sure what your question is
12:09:57 <ReinH> a lens where I wasn't guaranteed to get what I set wouldn't be a very useful lens
12:10:25 <paolino> as long as it's not hiding a logic
12:10:27 <MeepyTheParrot> so fmap ensures that any function that applies to Some a works on ScaryInstanceTypeThingyWrapper (Some a)
12:10:33 <MeepyTheParrot> ?
12:10:43 <merijn> MeepyTheParrot: Yes
12:10:49 <jgross_> How do I pattern match on the result of a function call?  In Coq I'd do match f n with ... end, in agda I'd do foo x y | f x \n ... | case1 = bar \n ... | case2 = baz.  What do I do in haskell?
12:10:49 <levi> MeepyTheParrot: Actually, all the instances for Functor are 'kind of obvious' in a meaningful way.
12:10:58 <ReinH> MeepyTheParrot: assuming ScaryInstanceTypeThingyWrapper is a Functor (which can be derived), yes
12:11:11 <arkeet> jgross_: case?
12:11:18 <merijn> MeepyTheParrot: Another simple example would be "fmap _ [] = []; fmap f (x:xs) = f x : fmap f xs"
12:11:23 <arkeet> case f n of { ... -> ... }
12:11:45 <arkeet> @src map
12:11:46 <lambdabot> map _ []     = []
12:11:46 <lambdabot> map f (x:xs) = f x : map f xs
12:12:06 <arkeet> :t map
12:12:07 <lambdabot> (a -> b) -> [a] -> [b]
12:12:08 <arkeet> :t fmap
12:12:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:12:32 <arkeet> I should probably go.
12:13:22 <levi> MeepyTheParrot: Not 'obvious' in the 'any dummy would see this!' sense, but 'obvious' in the sense that they can be obtained from some simple algebraic manipulations that the compiler can even do automatically.
12:13:43 <tomejaguar> "obvious" is a very dangerous word
12:13:44 <ReinH> levi: the compiler?
12:13:48 <merijn> Any Hakyll users? Is there a technical reason to use a "html" file extension for templates? That strikes me as "wrong"
12:13:58 <jfischoff> which is more fully supported in GHC higher ranked types or type families/associated types?
12:14:00 <jgross_> arkeet: Thanks.  But how do I separate cases?  I keep getting "parse error on input `|'"
12:14:13 <merijn> jfischoff: I would say both equally?
12:14:20 <levi> ReinH: I assume that's who you ask to derive it when you use -XDeriveFunctor
12:14:23 <MeepyTheParrot> I kinda feel the second part of Maybe monad is kinda redundant, :|
12:14:33 <tomejaguar> jgross_: with new lines, or ;
12:14:46 <merijn> jfischoff: I think type families are newer, though. So it depends on how backwards compatible/portable you wanna be?
12:14:55 <levi> MeepyTheParrot: Which part?  The 'Just x' part?
12:15:12 <jfischoff> merijn: Type families seem to affect inference more negatively than higher ranked types
12:15:15 <jgross_> tomejaguar: Great, thanks!
12:15:20 <jfischoff> but I'm not sure
12:15:20 <paolino> ReinH, say we have a data Even = Even Int and want to constraint the value to be even, a lens can do it, ceiling the values to next even on set operation. Is it wrong ?
12:15:25 <MeepyTheParrot>     fmap f (Just a) = Just (f a)
12:15:33 <jfischoff> that is my experience at least
12:15:34 <MeepyTheParrot> shouldn't the compiler already know this?
12:15:53 <johnbender> I have a package installed from a local copy of a package repo
12:15:56 <tomejaguar> paolino: it breaks a lens law
12:16:12 <ReinH> levi: Well, GHC does it, so in that sense it's the compiler. But it's not (iinm) done in System FC? I guess it depends on which parts of GHC you consider "the compiler"?
12:16:14 <merijn> MeepyTheParrot: Well, in case of Functor, it does. There's a "DeriveFunctor" extension that lets you write "deriving (Functor)" with your data and then it automatically generates the code for you
12:16:17 <johnbender> it lists in cabal list but when I attempt to use it a cabal install with a sandbox it can't find it
12:16:38 <johnbender> my question: is there any way to tell cabal install (using a sandbox) to consult the globaly installed packages?
12:16:54 <johnbender> My google-fu failed me
12:17:00 <ReinH> paolino: it's wrong in the sense that it breaks the first lens law, but such "pseudo-lenses" might still be useful
12:17:58 <ReinH> MeepyTheParrot: if I write a Maybe-like data type: data Possibly a = Nope | Yep a
12:18:12 <ReinH> MeepyTheParrot: GHC can derive the correct (same as Maybe) Functor instance
12:18:17 <jgross_> Next question: What tool do I want to turn a .lhs file into a .pdf file if I want the abilities to: include extra LaTeX packages, choose my own documentclass, colorize my code automatically, hide code from haskell (e.g., '< code' for lhs2TeX), and, preferablly, have blocks of code ('\begin{code} ... \end{code}')?  I'm using lhs2TeX right now, but it doesn't seem to be able to colorize my code, and HsColour doesn't seem to allow me to use '<
12:18:17 <jgross_> ...'.
12:18:31 <paolino> ReinH, in what sense it doesn't compose ? If that is the point of first law ?
12:18:41 <Lethalman> jgross_, looking into that as well.... can't read the ghc source code
12:18:45 <ReinH> paolino: you're right, it does compose.
12:18:59 <ReinH> paolino: as in, the types line up
12:19:06 <ReinH> paolino: but you might be surprised at the values that come out :)
12:19:13 <Lethalman> (though it gives an error for me, not even translates .lhs to tex :S)
12:20:06 <ReinH> paolino: violating the first lens law makes it impossible to reason about the behavior of compositions of gets and sets, basically
12:21:39 <paolino> ReinH, I don't see how is it different for a computation cache lens for which the values are the same
12:21:48 <supki> johnbender: by "globally" you mean "installed in user-wide package db"?
12:22:01 <applicative> johnbender: for me it does use the globally installed packages
12:22:05 <ReinH> MeepyTheParrot: also if I write a newtype wrapper for a functor: newType MyMaybe a = { runMyMaybe :: Maybe a }, GHC can derive the functor instance for that as well.
12:22:18 <applicative> johnbender: not the ones in my local .cabal-land
12:22:44 <MeepyTheParrot> ah, so fmap sqrt (Just 2) works only because fmap f (Just n) = Just (f n)
12:22:49 <MeepyTheParrot> otherwise it's non exhaustive
12:22:54 <ReinH> paolino: you might want to ask in #haskell-lens :)
12:23:01 <ReinH> paolino: I'm sure there are better reasons than the ones I am giving you
12:23:24 <tomejaguar> Reading the same value out of a lens that you put in is a crucial property of a lens
12:23:32 <pavonia> MeepyTheParrot: fmap works for Nothing too
12:23:52 <MeepyTheParrot> but shouldnt Haskell know that fmap f (Functor g) = Functor (f g)?
12:23:58 <joastbg> I have a question, why doesn't this compile in the REPL: http://pastebin.com/yvnPepcn
12:23:59 <MeepyTheParrot> what else could it possibly be
12:23:59 <mauke> The paste yvnPepcn has been copied to http://lpaste.net/92649
12:24:00 <ReinH> MeepyTheParrot: well, Maybe is a sum type, so there are two possibilities: fmap Nothing or fmap (Just a)
12:24:09 <joastbg> the file takes a String and returns an Int
12:24:40 <geekosaur> joastbg, to use readFile it must be in IO
12:24:46 <ReinH> MeepyTheParrot: Haskell (GHC) *can* know that if you instruct it to. That's what the DeriveFunctor extension does
12:24:53 <applicative> joast length $ lines $ a is a number not action
12:24:58 <ReinH> MeepyTheParrot: just like you can say data Foo = Foo deriving Show
12:25:15 <geekosaur> and the result will be an IO Int and you must use `return` to "promote" the result into IO
12:25:17 <ReinH> you can also say data Foo a = Foo a deriving Functor
12:25:19 <applicative> so, you can write return $ length $ lines a or, e.g. print $ length $ lines a
12:25:24 <ReinH> MeepyTheParrot: if you enable the extension
12:25:33 <joastbg> yes I know, but isn't a <- ..., supposed to make action to string?
12:25:44 <geekosaur> only temporarily
12:25:53 <ski> MeepyTheParrot : `fmap f (Functor g) = Functor (f g)' is unfortunately nonsense. `Functor' here (as in the current discussion) exists on the type level, not on the value level on which functions like `fmap' are defined
12:25:57 <geekosaur> it can't *stay* there, ultimately you have to go back into IO
12:26:03 <ReinH> MeepyTheParrot: the reason the instances for things in Prelude, etc, are explicitly defined is because they cannot assume they will have access to DeriveFunctor when compiled
12:26:03 <applicative> joastbg: yes, if you put it that way, but each line in a do block must be in the ambient monad
12:26:10 <KainAbel007> where to find some milfs to sex them? they can be married
12:26:18 --- mode: ChanServ set +o geekosaur
12:26:22 <KainAbel007> ?
12:26:23 <KainAbel007> why
12:26:24 <applicative> joastbg: so line 4 there should be in IO
12:26:25 --- kick: KainAbel007 was kicked by geekosaur (KainAbel007)
12:26:38 <joastbg> alright, because if i use main, then it works
12:26:42 <ReinH> MeepyTheParrot: since it might be compiled by a compiler that does not have the DeriveFunctor langauge extension
12:26:49 <FreeFull> ski: I don't think fmap id == id lets you change constructors
12:27:04 --- mode: geekosaur set -o geekosaur
12:27:17 <Jeanne-Kamikaze> doesn't ghc support rewrite rules or something like that ?
12:27:23 <ski> FreeFull : i'm not sure what that is a response to
12:28:19 <applicative> joastbg: so this makes sense, http://pastebin.com/AmHWrMjv
12:28:21 <FreeFull> ski: What you wrote to MeepyTheParrot
12:28:23 <mauke> The paste AmHWrMjv has been copied to http://lpaste.net/92650
12:28:31 * applicative cant believe he just used pastebin
12:29:02 <monochrom> eh? yeah, why did you use pastebin? :)
12:29:22 <applicative> because joastbg did; it was peer pressure monochrom!
12:29:26 <MeepyTheParrot> ah, for collections fmap f (InstanceOfFunctorThingy I) = InstanceOfFunctorThingy (f I) is not quite right, eg fmap sqrt [1, 2, 3] needs to be a bit more clever.
12:29:28 <merijn> monochrom: momentary insanity?
12:29:42 <MeepyTheParrot> I guess it makes sense to have to write it yourself.
12:29:44 <monochrom> that is good enough. don't feel bad. :)
12:30:04 <merijn> MeepyTheParrot: Exactly, there's not many instances as trivial as Maybe :)
12:30:07 <ReinH> MeepyTheParrot: your pseudocode there isn't quite correct but the ideas are
12:30:13 <ski> FreeFull : i don't follow
12:30:17 <ReinH> MeepyTheParrot: here's a fun exercise for you
12:30:34 <joastbg> applicative: thanks, from that I understand you have to be in the IO, some side effects, so the first let will use the temporary value from a?
12:31:00 <johnbender> supki: yes!
12:31:06 <johnbender> applicative: really? hmm
12:31:12 <johnbender> when I setup a new sandbox
12:31:24 <johnbender> and I do a cabal list from the project dirctory it doesn't list the installed version
12:31:26 <ReinH> MeepyTheParrot: define the functor instance for a binary tree
12:31:36 <johnbender> applicative: when I do a cabal list outside the project directory it does
12:31:39 <MeepyTheParrot> ouch, gonna try that
12:31:41 <johnbender> :(
12:31:48 <johnbender> applicative: I just ended up installing my project deps globally
12:31:59 <johnbender> I'll suffer later as necessary
12:32:04 <monochrom> ReinH: better to specify the exact declaration of the binary tree type first
12:32:06 <merijn> MeepyTheParrot: You can use this tree: "data Tree a = Leaf a | Branch (Tree a) (Tree a)"
12:32:16 <ReinH> monochrom: I was writing that but merijn beat me to it :)
12:32:26 <monochrom> ok! that will do
12:32:27 <merijn> Fastest man in the channel ;)
12:32:31 <ReinH> :D
12:33:04 <ski> MeepyTheParrot : imho, you should strive to distinguish clearly between the value level and the type level (unless you know the distinction and think those you talk to will auto-correct it into what you intended) -- do you understand what i'm referring to ?
12:33:18 <monochrom> . o O ( the binary tree functor can lead to another rabbit hole. "free _____" ...)
12:33:27 <applicative> johnbender: oh maybe i'm still understanding.  there are certainly a lot of things to clarified about it
12:33:27 <merijn> Also, ReinH apparently managed to come ahead of me on the activity rankings, I should strike back by stealing his lines :p
12:33:28 <ReinH> monochrom: Cofree.
12:33:37 <FreeFull> Functor instances are easy to write, since I think there is only one way to do it and satisfy the laws
12:33:38 <ReinH> merijn: I did? o_O
12:33:38 <applicative> johnbender: woops, meant 'still not understanding'
12:33:44 <ReinH> merijn: where are these rankings?
12:34:21 <FreeFull> There are types for which there are no functor instances though
12:34:22 <merijn> ReinH: http://ircbrowse.net/
12:34:25 <ReinH> oh duh
12:34:31 * applicative hereby advances himself in the rankings 
12:34:46 <ReinH> merijn: I absolutely love that edwardk is only slightly less active than lambdabot
12:35:00 <ReinH> and both are 2x anyone else
12:35:19 <edwardk> hah
12:35:28 <erisco> > 1+1
12:35:30 <lambdabot>   2
12:35:31 <erisco> the race continues
12:35:37 <ReinH> lmao
12:35:38 <edwardk> shachaf used to be more active than me
12:35:44 <MeepyTheParrot> fmap f (Leaf a) = Leaf (f a)?
12:35:47 <ReinH> but then he took an arrow to the knee?
12:35:52 <merijn> edwardk: So that's why you make him maintain Lens?
12:35:53 <ReinH> MeepyTheParrot: that's one, yes
12:35:57 <applicative> you'll never catch up with lambdabot that way erisco
12:35:59 <ReinH> MeepyTheParrot: now what do you do for branches?
12:36:02 <edwardk> merijn: yes
12:36:12 <edwardk> sadly it is hard to type while wearing shackles
12:36:16 <monochrom> "humans come and go. LAMBDABOT MARCHES ON!"
12:36:19 <MeepyTheParrot> it applies to both doesn't it?
12:36:20 <Redz> is there a function that connect input and output of two handles to each other?
12:36:28 <ReinH> MeepyTheParrot: no, it only applies to the leaf
12:36:37 <haasn> wooh, I'm on the first page! (I don't really spam that much.. do I?)
12:36:40 <MeepyTheParrot> but there are two leaves on a branch
12:37:04 <MeepyTheParrot> ah
12:37:05 <MeepyTheParrot> nvm
12:37:06 <merijn> MeepyTheParrot: A branch can have branches too
12:37:09 <edwardk> haasn: apparently about a third of how much I do ;)
12:37:26 <haasn> ReinH: that's because edwardk keeps sending lens examples to lambdabot to evaluate :)
12:37:27 <merijn> @let data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show)
12:37:27 <lambdabot>  .L.hs:149:23:
12:37:28 <lambdabot>      Ambiguous occurrence `Tree'
12:37:28 <lambdabot>      It could refer to either...
12:37:29 <ReinH> MeepyTheParrot: what do you do for branches?
12:37:31 <merijn> aww
12:37:32 <applicative> hGetContents h >>= hPutStr h' for maximum chaos Redz
12:37:51 <monochrom> use a dfferent name from "Tree". "Tree" is already Data.Tree
12:37:55 <ReinH> MeepyTheParrot: no, and this is the key: there are two *trees* on a branch :)
12:37:57 * hackagebot pontarius-xmpp 0.3.0.1 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.3.0.1 (JonKristensen)
12:37:59 <erisco> I'm only 21? my word
12:38:06 <ReinH> merijn: BTree
12:38:09 <Redz> applicative: i build
12:38:09 <Redz> 	forkIO $ B.hGetContents h2 >>= B.hPutStr h
12:38:09 <Redz> 	forkIO $ B.hGetContents h >>= B.hPutStr h2
12:38:09 <Redz> but i think, it would broke.
12:38:15 <MeepyTheParrot> so I have to define an fmap for a BinaryTree as well?
12:38:22 <MeepyTheParrot> I can't imagine what this would be
12:38:23 <monochrom> you're 21? halfway to 42? :)
12:38:24 <erisco> for 1172 people I did not expect to be that high up
12:38:33 <ReinH> MeepyTheParrot: no, you have to define fmap for Branch (Tree x) (Tree y)
12:38:41 <erisco> monochrom, not in age, in number of message ranking
12:38:47 <monochrom> darn
12:39:04 <applicative> Redz: i think in the context of forkIO youre going to need more sophisticated machinery
12:39:11 <ReinH> MeepyTheParrot: let's start with this: fmap f (Leaf a) = Leaf (f a)
12:39:24 <ReinH> MeepyTheParrot: now write: fmap f (Branch a b) = ?
12:39:31 <MeepyTheParrot>     fmap f (Branch (Tree x) (Tree y)) = Branch (Tree (f a)) (Tree (f a))
12:39:32 <MeepyTheParrot> ?
12:39:34 <erisco> monochrom, you are at 18 its okay :)
12:39:46 <MeepyTheParrot> a, being x and y
12:39:47 <ReinH> MeepyTheParrot: not quite, and that's my fault
12:39:55 <monochrom> "I am 17, going on 18"...
12:39:56 <ReinH> MeepyTheParrot: it's not Branch (Tree a)... Tree is not a constructor.
12:39:58 <Redz> applicative: do you know some sophisticated machinery i could use? ;)
12:40:08 <ReinH> It's Branch a b
12:40:14 <monochrom> (It's from The Sound of Music)
12:40:28 <applicative> Redz: it depends what you by 'know' ;)
12:40:37 <MeepyTheParrot>     fmap f (Branch a b) = Branch (f a) (f b)?
12:40:50 <ReinH> MeepyTheParrot: not quite.
12:40:55 <ReinH> MeepyTheParrot: consider this specific case
12:40:56 <applicative> you need channels or something Redz, no?
12:41:13 <ReinH> fmap f (Branch (Leaf a) (Leaf b))
12:41:25 <Redz> applicative: no. just one handle to one other handle. nothing more.
12:41:32 <monochrom> a,b are trees. can't f them.
12:41:39 <ReinH> monochrom: f you
12:41:54 <ReinH> monochrom: equational reasoning is about to happen :)
12:41:58 <monochrom> but if b is a tree, and you want to f its leaves, what can you do?
12:41:59 <merijn> Any Hakyll users? I have a question on how to do nested loops :\
12:42:05 <ReinH> monochrom: just give it a second
12:42:16 * haasn .oO( couldn't have picked a better quote: “maximum pointless” — haasn )
12:42:35 <applicative> Redz: but you want each of two handles to writing to other?
12:42:38 <MeepyTheParrot> >.>
12:42:40 <ReinH> MeepyTheParrot: if I have two leaves and I want to apply f to each, what do I do?
12:42:56 <ReinH> MeepyTheParrot: given: fmap f (Leaf a) = Leaf (f a)
12:42:58 <edwardk> ReinH: anyways, i'm back now. what was your question?
12:42:59 <MeepyTheParrot> fmap f (Leaf a)?
12:43:23 <ReinH> MeepyTheParrot: now substitute that for fmap f (Branch (Leaf a) (Leaf b))
12:43:38 <MeepyTheParrot>     fmap f (Branch a b) = Branch (fmap f (a)) (fmap f (b))?
12:43:43 <Redz> applicative: yes. is this so complicated?
12:44:14 <ReinH> MeepyTheParrot: fmap f (Branch a b) = Branch (fmap f a) (fmap f b), yes
12:44:17 <ReinH> MeepyTheParrot: now, why?
12:44:44 <MeepyTheParrot> because f(Leaf n) is undefined
12:44:47 <MeepyTheParrot> or meep
12:45:09 <ReinH> MeepyTheParrot: what happens if a and b are both branches?
12:45:18 <applicative> Redz: if those are strict bytestrings then surely it is truly incoherent, or am i wrong?
12:45:21 <MeepyTheParrot> they will eventually be leaves
12:45:25 <MeepyTheParrot> or nothings
12:45:33 <ReinH> MeepyTheParrot: no nothings. Always eventually leaves :){
12:45:42 <merijn> ReinH: *bzzt*
12:45:48 <ReinH> merijn: ?
12:45:50 <merijn> ReinH: They could be infinite branches :p
12:45:55 <ReinH> merijn: well crap
12:45:59 <ReinH> you are ofc right
12:46:13 <ReinH> MeepyTheParrot: they are always leaves or more branches :)
12:46:29 <Redz> applicative: oh, i should make them lazy.
12:46:42 <ReinH> MeepyTheParrot: so fmap for branches is a recursive definition that applies fmap to each branch
12:47:21 <MeepyTheParrot> yeah
12:47:28 <ReinH> MeepyTheParrot: now, define fmap for lists. Start off with fmap f [] = []; now define fmap f (a:as)
12:47:35 <ReinH> MeepyTheParrot: hint: it's quite similar
12:48:07 <ReinH> MeepyTheParrot: you know the notation (a:as) btw?
12:48:21 <ReinH> it's a pattern match on the head (a) and tail (as) of a list
12:48:22 <MeepyTheParrot> yeah x:xs
12:48:28 <ReinH> ok, go :)
12:49:31 <MeepyTheParrot> dat List l = List l | List (List l) (List l)?
12:49:39 <ReinH> MeepyTheParrot: you can do it directly on the a and as
12:50:10 <ReinH> MeepyTheParrot: remember that this also works:
12:50:15 <ReinH> > 1:[2,3]
12:50:16 <lambdabot>   [1,2,3]
12:50:47 <MeepyTheParrot> I dont know what the data declaration would be
12:50:54 <ReinH> MeepyTheParrot: there's no data declaration
12:50:59 <ReinH> you are building a new list
12:51:23 <MeepyTheParrot> yeah, but I need data List a = ...
12:51:28 <ReinH> MeepyTheParrot: you don't
12:51:31 <MeepyTheParrot> O_o
12:51:41 <ReinH> MeepyTheParrot: you need to do something to the a and then something to the as and then stick them together
12:52:07 <ReinH> hint: your answer will be in the form of fmap f (a:as) = ???? a : ????? as
12:52:30 <MeepyTheParrot> That's the functor instance, I don't even know what the thing is defined as
12:52:43 <ReinH> MeepyTheParrot: let's just walk through this.
12:52:47 <ReinH> MeepyTheParrot: what do you want to do to the a?
12:53:26 <MeepyTheParrot> wrap and concatenate?
12:53:32 <ReinH> MeepyTheParrot: just specifically to the a
12:54:13 <ReinH> MeepyTheParrot: remember that the goal is to apply f to every element of the list
12:54:23 <ReinH> what do you want to do to the first element of the list?
12:54:55 <MeepyTheParrot> apply f?
12:54:58 <ReinH> MeepyTheParrot: yep
12:55:07 <ReinH> ok, so now you have fmap f (a:as) = f a : ???? as
12:55:10 <ReinH> what do you do to the rest of the list?
12:55:16 <S_J> what address doesn listenOn bind to? i want to bind to localhost. Id like a simple complete server client example
12:55:19 <ReinH> hint: it's a lot like what you did to branches of the binary tree
12:55:44 <MeepyTheParrot> f as?
12:55:58 <ReinH> MeepyTheParrot: f only applies to single as
12:56:03 <ReinH> you want to apply f to every element of as
12:56:17 <MeepyTheParrot> fmap f (as)
12:56:22 <ReinH> yep
12:56:25 <ReinH> now put them together
12:57:18 <MeepyTheParrot> fmap f (a:as) = f a : fmap f as?
12:57:24 <ReinH> bingo
12:57:28 <ReinH> MeepyTheParrot: now what does that do?
12:57:50 <MeepyTheParrot> recursively applies to the first
12:57:53 <ReinH> ep
12:57:55 <ReinH> yep
12:58:02 <ReinH> until you hit the base case, fmap f [] = []
12:58:03 <ReinH> where it stops
12:58:09 <ReinH> (assuming you ever do)
12:58:12 <MeepyTheParrot> i didn't define that quite yet
12:58:14 <MeepyTheParrot> but yeah
12:58:17 <ReinH> MeepyTheParrot: I did for you :)
12:58:42 <ReinH> MeepyTheParrot: but like merijn said, fmap f [1..] is totally valid, just like fmapping an infinite binary tree
12:58:46 <ReinH> f will be applied lazily
12:59:16 <ReinH> non-strictly, to be technical
12:59:21 <ReinH> MeepyTheParrot: so that's fmap for lists
12:59:25 <ReinH> MeepyTheParrot: do you see why it's the same as map?
12:59:39 <MeepyTheParrot> yeah
12:59:43 <ReinH> cool
12:59:58 <MeepyTheParrot> thanks
13:00:08 <ReinH> np
13:00:37 <ReinH> merijn: there, that should cement my activity lead for August. ;)
13:00:50 <ReinH> pretty sure I'm a lock
13:01:17 <merijn> :\
13:01:22 <ReinH> :D
13:01:31 <merijn> You probably mean September, though?
13:01:37 <ReinH> hah what month is it?
13:01:40 <ReinH> lmao
13:03:06 <ReinH> merijn: on the plus side, I'm pretty sure I understand functors now. Next I need someone to ask me to explain applicative ;)
13:04:25 <ReinH> edwardk: I forget what I wanted to ask you.
13:06:22 <merijn> Anyone here know if and how I can embed LaTeX math into rST files and have pandoc transform it into MathJax?
13:07:21 <levi> merijn: I think you can just by including it between $ $
13:07:40 <levi> merijn: But the Pandoc documentation is very good and will tell you exactly what it supports.
13:08:36 <merijn> I was googling, but Google didn't turn up any relevant hits in the docs :\
13:08:48 <merijn> Now I have to read documentation like a peasant...
13:08:54 <ReinH> hahahahahaha
13:09:52 <mm_freak_> ocharles: i think i'm ready for release, but i'll wait a day…  feel free to experiment with it and give last-minute feedback =)
13:10:00 <mm_freak_> in the meantime i'll write the gloss framework
13:12:20 <ReinH> I feel like I was just doing something important... but I can't figure out what it was.
13:14:28 <ReinH> wtf is wrong with my brain
13:21:43 <Zenol> ReinH: It's definitely an human brain. Nothing wrong :)
13:21:47 <levi> ReinH: I feel like that all the time.
13:22:15 <donri> guys you all have adhd ;)
13:23:43 <merijn> Bah, pandoc supports tex embedded in markdown, but no sign of support for rst :(
13:24:41 <sclv_> if anyone feels like chipping in on the wiki i have a suggestion!
13:24:48 <sclv_> we just added IDEs, Editors, and Tools to the main page
13:24:55 <sclv_> all three of the pages are somewhat grotty
13:25:01 <worldsayshi> Hello Haskellers :) , Trying to get my head around some strange type deduction error mysteries. Doing some toy examples. To begin with, I don't quite understand why this one doesn't compile: http://lpaste.net/92657 -- Thanks if you want to help out.
13:25:18 <sclv_> they're not bad actually, but a little editing and cleanup would go a long way
13:26:10 <shachaf> worldsayshi: When you ask a question like that, it's considered polite to also provide the error (and what you expected would happen).
13:26:28 <enthropy> worldsayshi: the `b' in the middle isn't fixed by the type signature
13:26:38 <worldsayshi> Ah, although the error is quite long
13:26:48 <levi> merijn: Pandoc's rST is definitely a second-class citizen, unfortunately.
13:27:13 <shachaf> Not as long as it'd take 1000 people to make a new file, paste that code into it, and run ghci!
13:27:14 <enthropy> you could turn on -XScopedTypeVariables, then you could write   conv2 :: forall a b c. (Cast a b, Cast b c) => a -> c; conv2 = conv . (`asTypeOf` (undefined :: b)) . conv
13:27:17 <worldsayshi> Could not deduce (m ~ t0 m1)
13:27:18 <worldsayshi>     from the context (MonadReader (Context t2) m)
13:27:19 <worldsayshi>       bound by the inferred type of
13:27:21 <worldsayshi>                foo :: MonadReader (Context t2) m => t -> t1 -> m ()
13:27:22 <worldsayshi>       at Parse.hs:(53,1)-(55,14)
13:27:24 <worldsayshi>     or from (t2 ~ collection object,
13:27:26 <worldsayshi>              FacetedCollection m1 collection object query)
13:27:27 <worldsayshi>       bound by a pattern with constructor
13:27:27 <shachaf> worldsayshi: Not here!
13:27:28 <worldsayshi>                  D :: forall (m :: * -> *) (collection :: * -> *) object query.
13:27:30 <worldsayshi>                       FacetedCollection m collection object query =>
13:27:31 <worldsayshi>                       collection object -> Context (collection object),
13:27:32 <worldsayshi>                in a pattern binding in
13:27:33 <worldsayshi>                     'do' block
13:27:40 <shachaf> worldsayshi: Paste it along with the code.
13:27:40 <worldsayshi> Oh. sorry. :S
13:27:48 <worldsayshi> I enter with grace
13:28:01 <enthropy> that error is mentioning stuff that's not in your paste
13:28:04 <shachaf> Also, I know that error isn't related to the thing you pasted.
13:28:11 <shachaf> Your file doesn't have MonadReader or line 53.
13:28:26 <shachaf> enthropy: ScopedTypeVariables doesn't help here...
13:28:44 <worldsayshi> Oh my. I will create a new paste
13:28:57 <joelteon> everything has gone wrong
13:29:39 <levi> merijn: You might try embedding some LaTeX between $ $s and see what happens. It could be a generic text filtering post-processor.
13:30:00 <enthropy> shachaf: it lets ghc accept the file at least
13:30:17 <worldsayshi> Now http://lpaste.net/92658
13:30:31 <enthropy> but you're right that it probably won't help decide what `b' is actually supposed to be
13:31:01 <enthropy> except maybe if you had things like    instance (b ~ Int) => Cast String b
13:32:28 <joelteon> (conv :: b -> c) . (conv :: a -> b) ?
13:32:32 <shachaf> Even then.
13:33:12 <levi> merijn: Looks like the 'tex_math_dollars' extension enables it.
13:33:29 <merijn> levi: That's a markdown extension, afaict
13:35:33 <Umbrall> Is it possible for m (r -> a) to be a monad. I'm pretty sure it's not but just want to make sure
13:35:55 <scshunt> Umbrall: (->) r is a monad
13:36:06 <Umbrall> but Monad m => m (r -> a) is not
13:36:11 <Umbrall> as far as I can tell
13:36:27 <scshunt> Umbrall: for fixed r?
13:36:33 <Umbrall> with the exception of those few monads which can go over any monad
13:36:36 <worldsayshi> joelteon: wont help as a, b and c isn't seen as the same as those in the type signature
13:36:38 <Zenol> ei see, you could have a -> String, String -> c and a -> Int, Int -> c, and then you can't choose... :/
13:36:39 <Umbrall> what do you mean fixed r?
13:36:45 <enthropy> @unmtl ReaderT r m a
13:36:45 <lambdabot> r -> m a
13:36:47 <joelteon> i just responded to your PM
13:36:51 <scshunt> Umbrall: as in, is, say "IO (Int -> a)"
13:37:04 <Umbrall> yeah
13:37:11 <scshunt> Umbrall: it's always a monad
13:37:15 <Umbrall> er
13:37:16 <scshunt> the composition of any two monads is a monad
13:37:20 <Umbrall> no not true
13:37:25 <Umbrall> not for all monads
13:37:39 <Umbrall> that's only true up to applicative
13:37:54 <Zenol> worldsayshi: There is a GHC extention (scopedtypevariable) which allow making the a inside and in the type signature beeing the sames.
13:39:19 <donri> that'll make this code type check, but uses of conv2 will still be ambiguous i think
13:40:21 <worldsayshi> Zenol: Thanks, I'll try
13:40:27 <Umbrall> but yeah unless anyone has found code that works for it I'm assuming that an instance does not exist
13:40:38 <Umbrall> which is annoying because I want there to be one
13:42:18 <Zenol> worldsayshi: It won't works.
13:42:34 <worldsayshi> I'm creating a new paste
13:43:43 <worldsayshi> http://lpaste.net/92660
13:44:13 <Zenol> worldsayshi: What should be b? Let's say you have : conv Something -> String, conv Something -> Int, and then conv String -> Word and conv Int -> Word. Whats the corect way to convert from Something to Word? Why is String or Int better than the over?
13:44:42 <Zenol> worldsayshi: There is no way to choose, and actualy the result might be completely different.
13:44:47 <worldsayshi> ah
13:45:26 <worldsayshi> hmm
13:45:39 <levi> merijn: Do something like :math:`3*x^2+4x-2`
13:45:44 <enthropy> worldsayshi: your error message doesn't fit the file you posted
13:46:20 <enthropy> the error message is from a file without -XScopedTypeVariables
13:46:22 <shachaf> scshunt: Monads don't compose.
13:46:31 <donri> worldsayshi: you could add a functional dependency to make this unambiguous, but then you probably can't use this the way you wanted
13:46:32 <shachaf> (But adjunctions do!)
13:46:48 <worldsayshi> whait.. hmm. It seems to compile now...
13:47:13 <mercwithamouth> hi, would you say haskell is harder to get a grasp on than clojure?
13:47:21 <donri> worldsayshi: yes, you can make that alone type check, but try use conv2 and it's still ambiguous :)
13:47:52 <donri> mercwithamouth: if you come from a lisp and/or jvm background, yes, certainly. :p
13:48:08 <mercwithamouth> donri: and if not?
13:48:21 <JuanDaugherty> ur fucked anywho
13:48:22 <worldsayshi> hmm. Yes that makes sense now.
13:48:29 <Zenol> worldsayshi: I'm not a good haskeller, but if I would really need a way to convert beetwen some types, then I'll choose a 'UniversalType' and write conv :: a -> Universal and conv :: Universal -> b
13:48:42 <worldsayshi> I'll see what the message is when I try to use it
13:48:47 <mercwithamouth> i'm giving each language a few weeks...haskell does look a little more scary though cleaner...if that makes sense
13:48:54 <Zenol> worldsayshi: Then, you want (conv :: Universal -> c) . (conv :: a -> Universal).
13:49:47 <JuanDaugherty> no it doesn't, unless somebody has defined "clean" in a mathematical sense
13:49:59 <donri> worldsayshi: you could pass the type for b as a proxy :)
13:50:16 <donri> conv2 (Proxy :: Proxy Int) "1"
13:50:30 <ReinH> JuanDaugherty: s/clean/pure ;)
13:51:12 <ReinH> you can convert any value you want between any types you want
13:51:17 <ReinH> as long as that value is _|_
13:51:18 <worldsayshi> Zenol: Heh, that seems like an interesting approach. I'm actually trying to understand how deduction works when Type classes and GADTs work together. This seemed like a decend first step
13:51:19 <JuanDaugherty> ReinH, :)
13:51:39 <worldsayshi> *decent
13:51:51 <ReinH> JuanDaugherty: so fresh and so pure
13:52:10 <JuanDaugherty> like vagasil
13:52:26 <JuanDaugherty> oder
13:52:31 <mercwithamouth> JuanDaugherty: well visually i like haskels blocks a little more though from there it's a nightmare(foreign)  I'd assume after a while everything would become a little more clear
13:52:45 <donri> mercwithamouth: i don't know clojure myself so i can't compare. haskell is known to be different from what most programmers are used to, though, yes.
13:52:48 <mercwithamouth> anyhew..i'll give them both more time
13:52:54 <ReinH> mercwithamouth: the syntax is the least interesting part of a language imo
13:53:47 <ReinH> the most interesting is what tools it provides for abstraction
13:53:48 <JuanDaugherty> mercwithamouth, you'll find most here will, if honest, sneer in their hearts at clojure as a fake ass lisp
13:53:53 <ReinH> that's where Haskell really shines, imo
13:53:54 <JuanDaugherty> (i think)
13:53:55 <Lethalman> emacs has problems with multiline string literals that you know?
13:53:57 <Zenol> ReinH: the fact that you can makes as many operators as you want, and monad/arrow syntax help a bit :)
13:54:02 <Lethalman> it gives parse error though the syntax seems ok
13:54:26 <donri> Lethalman: are you asking about haskell or emacs?
13:54:35 <ReinH> Zenol: it's not uninteresting :)
13:54:37 <Lethalman> donri, haskell mode of emacs
13:54:41 <donri> Lethalman: in haskell you need to end the previous line with \ and start the next line with \
13:54:44 <FreeFull> Is (\x y -> isUpper x && isUpper y || isLower x && isLower y || x == y)  a valid equality relation?
13:54:51 <Lethalman> donri, I know, probably doing it wrong
13:55:05 <donri> @lpaste example
13:55:05 <lambdabot> Haskell pastebin: http://lpaste.net/
13:56:04 <ReinH> Zenol: but you could give, say, Python a superficially similar syntax to Haskell.
13:56:18 <Zenol> FreeFull: Transitive : OK. Reflexive : Ok
13:56:19 <mercwithamouth> JuanDaugherty: lol, good to know.
13:56:36 <mercwithamouth> ReinH: hmmmm
13:56:43 <JuanDaugherty> s/vagasil/Summer's Eve/
13:56:44 <Zenol> FreeFull: and of course symetric. So it is.
13:56:47 <ReinH> JuanDaugherty: I'm not sure that's a valid generalization
13:57:20 <ReinH> JuanDaugherty: I'd like to think that Haskellers in general don't go around sneering at other langauges
13:57:23 <JuanDaugherty> ReinH, maybe; could be projecting.
13:58:16 <JuanDaugherty> well I know that would be the case in #lisp, though as stated I'd expect a veneer of tolerance and acceptance both there and here
13:58:23 <ReinH> I don't think that python-with-haskell-sugar would be as powerful a langauge as Haskell
13:58:33 <donri> #lisp sneers at everything
13:58:54 <ReinH> JuanDaugherty: I'd prefer to think of it as a deep, abiding core of tolerance and acceptance
13:58:58 <ReinH> but sure
13:59:19 <JuanDaugherty> ReinH, I wouldn't go that far
13:59:23 <ReinH> I'm just saying that syntax is, in some ways, a superficial trait of langauges
13:59:39 <ReinH> and semantics are often far more interesting
14:00:11 <mercwithamouth> it's definitely superficial...but comfort levels..and wanting to get something done
14:00:36 <ReinH> mercwithamouth: totally
14:00:48 <ReinH> I wouldn't use brainfuck if it had the most powerful semantics in the universe
14:01:02 <mercwithamouth> meh...i'd have no problem learning both. haskell seems like something you tinker with for a few years and once down pat decide that it's a great tool for a project
14:01:14 <ReinH> (and yes, I realize that there is fundamentally a turing/church equivalence going on here)
14:02:17 <FreeFull> ReinH: You can compile other languages to brainfuck
14:02:25 <donri> haskell is full of addictive sugar that is fun to play with and lets you design cute EDSLs but that in the end tend to bite you because it's just so crazy liberal
14:02:43 <donri> i want a dependently typed lisp :P
14:03:01 <Ralith> donri: we've been tinkering with ideas for making a lispy front-end for idris!
14:03:04 <Ralith> donri: wanna help :D
14:03:08 <donri> Ralith: cool!
14:03:22 <donri> Ralith: i'm certainly curious anyway. any links?
14:03:53 <Ralith> donri: nothing but a sexpr parser yet; irene-knapp was going to wire it into the implementation but had some stuff come up
14:04:14 <Ralith> donri: there's a lot of interesting syntatic questions to consider, many of which would probably be solved best by reader macros.
14:04:35 <donri> there are preprocessors for sexpy haskell but in the end that won't really give you the full "lisp experience"...
14:04:35 <FreeFull> I want to find out if Dijkstra ever said anything about Haskell in particular but all google is giving me is lots of implementations of Dijkstra's algorithm ):
14:04:47 <Ralith> yeah, we were working on making a properly integrated one
14:05:10 <ReinH> FreeFull: that's funny, I just implemented a special case of dijkstra's algo yesterday :)
14:05:37 <JuanDaugherty> Haskell was after Djikstra died (it became popular after).
14:05:52 <JuanDaugherty> he prolly had an opinion on ML
14:06:08 <JuanDaugherty> and his statements on aesthetics could be taken as applicable
14:06:54 <JuanDaugherty> (assuming you meant Edsger)
14:07:44 <JuanDaugherty> became popular and took it's current form
14:07:46 <S_J> regarding sockets, what is ProtocolNumber (CInt) ?
14:08:37 <Zenol> Is it now that some "famous" developers are speacking about haskell? Or it was also the case some years ago?
14:08:43 <JuanDaugherty> prolly a mapping to an ordered list of net protocols
14:09:06 <lispy> Zenol: I've been talking about Haskell for years :)
14:09:15 <hpc> ooh, can i be famous?
14:09:17 <lispy> (you did put quotes around famous...)
14:09:27 <lispy> hpc: you can be "famous"
14:09:28 <Zenol> x)
14:09:29 <JuanDaugherty> all the lisp people are in here today
14:10:17 <lispy> Zenol: are you asking because of John Carmack's recent talks?
14:10:24 <Zenol> lispy: Yes
14:11:07 <Zenol> although I heard about John Carmack only because he was speacking about haskell and one tolds me he was a "famous" developper.
14:11:18 <lispy> Zenol: Carmack has been learning Haskell for a while and tweeting about it
14:11:27 <lispy> he's pretty famous yes
14:11:51 <donri> he's not "famous" though
14:12:03 <lispy> He's done a lot to push the boundaries of what is possible with graphics in real-time and he also laid a lot of foundation for the FPS genere of games
14:12:03 <Zenol> I put quote because I don
14:12:29 <Zenol> *don't know what means beeing famous for a developper, and I don't know those famous developpers.
14:13:18 <JuanDaugherty> *its
14:13:59 <lispy> Zenol: http://www.youtube.com/watch?v=7YreEwtV7D0&list=PL26D021A7580EA83F
14:14:55 <haasn> whoa, just downloaded GHC 7.3.1 in 2 seconds
14:15:03 <haasn> I didn't realize haskell.org had that much upload :D
14:15:07 <S_J> type HostAddress = Word32, Word32, can i pass a string? how do i pass localhost? "localhost" or "127.0.0.1"?
14:15:17 <donri> haasn: why 7.3.1
14:15:21 <haasn> 7.6.3
14:15:23 <haasn> sorry
14:15:29 <haasn> no idea how I got that mixed up
14:15:48 <donri> S_J: use the high-level interface
14:15:59 <donri> S_J: import Network
14:16:35 <geekosaur> I have no idea why, when you've been working with Haskell (or at least been in this channel) as lomng as you have, you'd be asking "can I pass a String" to something that is clearly Word32
14:17:05 <S_J> donri; why?
14:17:10 <ParahSailin> im a little confused by pipe-attoparsec
14:17:27 <donri> S_J: why not?
14:18:39 <haasn> geekosaur: I think he's asking how he gets :: String -> Word8 to ‘decode’ human-provided addresses
14:18:41 <haasn> Word32*
14:18:51 <S_J> donri: how do I listen to localhost? where does listnOn listen by default, hwo do I change it?
14:19:47 <donri> S_J: true, that's bothered me too. i don't know the answer.
14:19:53 <S_J> 0x7F000001 is Word32 for localhost but i dont want to write that
14:22:01 <edwardk> switching to a bloom filtered COLA with untuned settings gets us reatively close to map performance wise. 2x instead of 3-100x at 100k elements
14:22:13 <edwardk> now i just need to figure out how big to make the blooms
14:23:01 * hackagebot lca 0.2.4 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing  http://hackage.haskell.org/package/lca-0.2.4 (EdwardKmett)
14:23:32 <donri> S_J: inet_addr :: String -> IO HostAddress
14:25:01 <leroux> S_J: It listens on 0.0.0.0, I believe.
14:25:37 <edwardk> i think if i switch to a redundant binary counter though, that i can perhaps cut the overhead way down for merging
14:26:07 <FreeFull> Let's say fail gets removed from Monad
14:26:32 <edwardk> please, let's
14:26:40 <FreeFull> Would that mean that something like do { [x,y] <- [[1],[1,4],[5,3,6]]; [x,y] }   would no longer work?
14:26:59 <edwardk> FreeFull: it'd upgrade it to a larger constraint, e.g. MonadPlus
14:27:01 <FreeFull> > do { [x,y] <- [[1],[1,4],[5,3,6]]; [x,y] }
14:27:03 <lambdabot>   [1,4]
14:27:16 <FreeFull> Ah, I guess lists have MonadPlus instances
14:27:20 <edwardk> FreeFull: yeah
14:27:42 <edwardk> currently removing fail isn't on the radar
14:28:06 <edwardk> maybe in a couple of years after the current wave of improvements =)
14:28:20 <FreeFull> Well, AMP is coming
14:28:29 <FreeFull> So at least there is that
14:28:41 <Lethalman> :t intercalate
14:28:42 <lambdabot> [a] -> [[a]] -> [a]
14:28:56 <donri> i'm disappoint AMP is just warnings for 7.8 :p
14:29:18 <Lethalman> :@hoogle a -> [a] -> [a]
14:29:21 <Lethalman> @hoogle a -> [a] -> [a]
14:29:21 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:29:22 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:29:22 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:29:50 <Zenol> lispy: thanks for the video, was interesting.
14:30:18 <FreeFull> Lethalman: (:) is also a -> [a] -> [a]
14:30:39 <Lethalman> indeed, needed intersperse though
14:30:53 <Lethalman> I want to add an action in the middle of many actions
14:31:19 <Lethalman> :t sequence $ intersperse (putStr "foo") []
14:31:20 <lambdabot> IO [()]
14:31:23 <FreeFull> Intersperse will insert it all over
14:31:26 <S_J> listen :: Socket -> Int -> IO (); what is the int?
14:31:33 <Lethalman> mh but wanted an IO ()
14:31:54 <Lethalman> :t Monad m => [m ()] -> m ()
14:31:55 <lambdabot> parse error on input `=>'
14:32:04 <Lethalman> @hoogle Monad m => [m ()] -> m ()
14:32:04 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
14:32:04 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
14:32:04 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
14:32:07 <FreeFull> :t void
14:32:08 <lambdabot> Functor f => f a -> f ()
14:32:09 <Lethalman> ah right sequence_
14:32:27 <FreeFull> sequence_ is void . sequence
14:32:42 <Lethalman> ok
14:33:01 * hackagebot aws-route53 0.0.2 - Route53 plugin for the aws package  http://hackage.haskell.org/package/aws-route53-0.0.2 (DavidTerei)
14:34:00 <Saizan> except for performance
14:34:45 <FreeFull> Yeah, sequence_ is faster and doesn't leak
14:39:40 <leroux> Hey, I compiled a list of haskell resources and would love some feedback on it. https://gist.github.com/leroux/6395804
14:44:28 <S_J> inet_addr :: String -> IO HostAddress , why the IO?
14:44:41 <leroux> S_J: It does a lookup.
14:44:49 <leroux> Which means it's doing something in the outside world.
14:45:30 <leroux> One sec...
14:45:38 <carter> a DNS lookup?
14:45:59 <carter> blackdog has some fun DNS lookup stories involving haskell when he's online
14:46:12 <ski> preflex: xseen blackdog
14:46:13 <preflex>  blackdog was last seen on freenode/#haskell 7 days, 10 hours, 46 minutes and 40 seconds ago, saying: ah, there we go, there's a solution at https://github.com/tonymorris/course/tree/master/projects/TicTacToe/haskell/src/Data/TicTacToe
14:46:17 <leroux> carter: Yeah.
14:46:28 <leroux> I'm looking up the src...to make sure.
14:46:33 <carter> he's @mwotton on twiter
14:49:33 <acowley> cabal sandboxes are not small.
14:49:56 <acowley> Mine tend to be >300mb each
14:50:02 <acowley> That adds up pretty quickly
14:50:15 <carter> acowley have you seen the cabal list chatt about the Nix os style stuff as the next step?
14:50:22 <monochrom> hrm, what's in the sandbox to make it so large?
14:50:32 <carter> ALL THE LIBRARIES :)
14:50:33 <acowley> carter: I haven't followed it too closely
14:50:36 <carter> yeah
14:50:43 <donri> 2,5G	.cabal/
14:50:45 <donri> heh
14:50:46 <acowley> I need to setup a scratch sandbox
14:50:53 <acowley> and just use that whenever possible
14:50:59 <monochrom> that can't be right, right? it doesn't duplicate what already comes with GHC, right?
14:51:17 <acowley> My ~/.cabal is 2.4GB
14:51:45 <monochrom> that is like 2 versions of GHC and 3 versions of Haskell Platform
14:51:45 <acowley> monochrom: Most of the sandbox space is in lib
14:51:57 <acowley> I told you I was hardcore?
14:52:07 <monochrom> I guess you're hardcore
14:52:10 <acowley> I don't use the HP
14:52:33 <acowley> I probably have profiling libs
14:52:40 <acowley> but it's nothing particularly weird
14:52:48 <acowley> The sandboxes tend to not have multiple versions of things, either
14:53:28 <donri> apparently 1,1G of my .cabal is the hoogle databases
14:53:29 <acowley> But, yeah, it would be really nice if the sandbox could somehow intelligently use a db in ~/.cabal of all version combinations
14:53:37 <acowley> I don't have a hoogle db
14:53:49 <acowley> I guess I'm due to wipe everything
14:53:51 <donri> i had it generate databases for all of hackage
14:54:47 <acowley> I do try to use everything on hackage in everything I do
14:55:35 <donri> haskell-src-exts is some 30M compiled plus 50M for the profiling version
14:55:39 <donri> these things add up...
14:58:02 * hackagebot snap 0.13.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.0 (DougBeardsley)
15:06:15 <S_J> isnt it the following sequence to create a server socket: create socket, bind it then accept? i get this error: Main: user error (accept: can't perform accept on socket ((AF_INET,Stream,0)) in
15:06:15 <S_J>  status Bound)
15:07:03 <hpaste> aaaa pasted “socket problems” at http://lpaste.net/92664
15:07:14 <S_J> ^^
15:09:00 <monochrom> no. between bind and accept, listen (just once)
15:09:49 <haasn> hmm
15:10:19 <monochrom> hmm!
15:10:24 <acowley> There are worked examples at the end of http://hackage.haskell.org/packages/archive/network/2.4.1.2/doc/html/Network-Socket-ByteString.html
15:10:43 <acowley> Which bear out monochrom's advice
15:11:17 <haasn> I'm getting an odd error trying to build GHC 7.6.3, hang on
15:11:36 <monochrom> I learned socket programming at the C level in 1992 or something
15:11:48 <haasn> Can't create output index file /tmp/tmpPozUKm/users_guide.ind.
15:12:06 <haasn> I can write to /tmp just fine, and create directories too
15:12:10 <haasn> so I don't know what the issue could be
15:12:20 <haasn> can I just skip this? seems to be documentation related
15:13:16 <S_J> and when I connect i never bind? i just create the socket and then call connect sock?
15:13:40 <haasn> ugh, I re-ran configure with --disable-doc and now it wants to rebuild everything
15:13:44 <haasn> I just spent an hour on this :(
15:14:04 <monochrom> no. create, bind, connect.
15:14:06 <haasn> I'll just use the binary, w/e
15:14:38 <acowley> monochrom: Not in the example I linked
15:15:26 <acowley> haasn: Why are you building your own?
15:15:55 <haasn> acowley: no particular reason, I just like building things from source
15:17:25 <monochrom> yikes, no bind, you're correct, I just checked my C programs
15:18:18 <acowley> You still have your code from back then?
15:18:35 <monochrom> some
15:19:05 <acowley> Mine's all gone
15:19:17 <acowley> there was even a fork-bomb assignment in some C & Unix class I took in the 90s!
15:19:54 <monochrom> that is the most favourite C-Unix assignment of all times all generations :)
15:20:43 <acowley> It's certainly the one I remember the best.
15:22:28 <ReinH> acowley: hai
15:23:03 * haasn is reminded he needs to salvage some old code off an unused harddrive that's now collecting dust
15:23:04 <acowley> ReinH: Hey! Any progress?
15:23:04 * hackagebot unordered-containers 0.2.3.2 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.3.2 (JohanTibell)
15:23:06 <haasn> I forgot it in my round of backups :(
15:23:15 <haasn> them memories..
15:26:03 <Lethalman> > "foo" =~ "(f)oo"
15:26:04 <lambdabot>   Not in scope: `=~'
15:26:04 <lambdabot>  Perhaps you meant one of these:
15:26:04 <lambdabot>    `==' (imported from ...
15:26:16 <Lethalman> > "foo" Text.Regex.Posix.(=~) "(f)oo"
15:26:17 <lambdabot>   Not in scope: data constructor `Text.Regex.Posix'Not in scope: `=~'
15:26:17 <lambdabot>  Perhap...
15:27:51 <haasn> what's the easiest way to get a binary version of cabal-install?
15:28:14 <hpc> platform, probably?
15:28:16 <leroux> haasn: Haskell Platform , maybe?
15:28:17 <Lethalman> how do I get multiple outputs out of =~ ?
15:28:27 <hpc> :t (=~)
15:28:28 <lambdabot>     Not in scope: `=~'
15:28:28 <lambdabot>     Perhaps you meant one of these:
15:28:28 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
15:28:38 <sm> or a ghc binary
15:29:04 <leroux> :t Text.Regex.Posix.Wrap.(=~)
15:29:04 <lambdabot> Couldn't find qualified module.
15:29:21 <arkeet> :t (Text.Regex.Posix.Wrap.=~)
15:29:22 <lambdabot> Couldn't find qualified module.
15:29:29 <arkeet> (that's how you qualify operators btw)
15:29:38 <leroux> Okay, thanks.
15:29:38 <haasn> leroux: I tried installing the haskell platform but couldn't since it depends on the GLUT C library
15:29:51 <S_J> NOTE: blocking on Windows unless you compile with -threaded (see GHC ticket #1129).. what does that mean? wont change thread?
15:29:53 <haasn> well, then again, there should be a flag to disable this
15:30:08 <leroux> What OS, haasn?
15:30:12 <haasn> leroux: no idea
15:30:18 <haasn> something Linux-based
15:30:23 <monochrom> haasn: if trust me, I can give you one
15:30:27 <enthropy> freeBareImage ptr = with ptr {#call cvReleaseImage#} -- this is problematic no?
15:30:33 <haasn> no monochrom I don't want your NSA backdoors :)
15:30:36 <leroux> xD
15:30:53 <Lethalman> mh
15:30:53 <arkeet> doesn't the HP package contain a cabal binary?
15:30:58 <monochrom> if you don't trust me, I'll plant you one anyway :)
15:31:28 <enthropy> the documentation for `with' says "passing as argument a pointer to a temporarily allocated block of memory into which val has been marshalled"
15:31:38 <haasn> shouldn't it be possible to build the haskell platform without a dependency on GL, though?
15:31:59 <haasn> I can't find the appropriate documentation
15:32:27 <enthropy> that means it copies the ptr, which is distinct from getting the address of it?
15:32:32 <enthropy> of the original ptr
15:33:00 <acowley> enthropy: It allocates a fresh bit of memory and pokes the Haskell value into it, then gives you that pointer.
15:33:27 <enthropy> acowley: so that's different from  cvReleaseImage(&ptr), right?
15:33:31 <acowley> haasn: Why not just download a binary from http://www.haskell.org/ghc/download_ghc_7_6_3
15:33:35 <haasn> u
15:33:37 <haasn> oops
15:33:47 <acowley> enthropy: what's the type of freeBareImage?
15:33:52 <monochrom> but GHC doesn't come with cabal
15:33:56 <acowley> Oh
15:33:57 <acowley> bootstrap.sh
15:34:02 <haasn> acowley: yes, I have GHC running now
15:34:06 <Lethalman> ok, :: [[String]] is the most generic one, otherwise I'm going mad :P
15:34:22 <haasn> just need cabal-install so I can install everything else
15:34:37 <monochrom> yeah, download cabal-install's tarball, untargz, run bootstrap.sh
15:34:39 <haasn> worst comes to worst I could manually install all of its dependencies, but that's awful :)
15:34:56 <acowley> haasn: You can download the cabal package and run bootstrap.sh
15:35:09 <acowley> sorry for the dup
15:35:16 <haasn> thanks
15:35:27 <monochrom> if you wonder which version, consider the version that matches your GHC
15:35:50 <acowley> latest and greatest or bust!
15:36:19 <monochrom> well, I don't know whether bootstrap.sh goes as far as setting up another Cabal lib version
15:36:25 <acowley> cabal install hackage --constraint=yolo
15:36:35 <haasn> yuck, curl spits out a 404 (but doesn't mention which URL)
15:36:43 <acowley> That bug was reported on reddit
15:36:46 <acowley> it's fixed in head
15:37:21 <haasn> seems like it's trying http://hackage.haskell.org/packages/archive/Cabal/1.18.0.0/Cabal-1.18.0.0.tar.gz
15:37:23 <acowley> It's okay, though, this is all part of the yolo constraint
15:38:00 <acowley> http://www.reddit.com/r/haskell/comments/1lqo13/cabal_1180_released/cc1ss2n
15:38:32 <haasn> oh, because it has 1.18.0.0 instead of 1.18.0, how odd
15:38:43 <monochrom> yeah
15:38:58 <monochrom> I guess you can edit bootstrap.sh to fix it
15:39:02 <haasn> yeah that's what I did
15:39:33 <enthropy> acowley:  ForeignPtr BareImage   it seems
15:39:48 <enthropy> with newtype BareImage = BareImage (ForeignPtr BareImage)
15:40:35 <enthropy> maybe that part is fine, and the memory leak in my use of the CV library is due to some other error
15:40:49 <acowley> enthropy: What library are you hacking on?
15:41:09 <enthropy> http://hackage.haskell.org/package/CV
15:41:16 <acowley> Take a look at https://github.com/acowley/HOpenCV too!
15:41:26 <acowley> It's got some fancy optimizations, but terrible API coverage
15:41:31 <enthropy> oh that one might be better :)
15:41:36 <acowley> OpenCV is a bear to wrap
15:41:47 <acowley> And I can never find the time to work on it
15:44:18 <Makoryu> Suppose I wanted to write a perfect hash of a lambda expression. What constraints would I need to place on the complexity of the expression and the values to which it could be applied?
15:47:05 <Lethalman> eeeeeeeek, ViewPatterns + regex is awesome!!!!
15:47:22 <Lethalman> pat p s = s =~ p  ----> win
15:47:47 <Lethalman> and pat :: String -> String -> [[String]]
15:48:06 <Lethalman> then case x of (pat "pattern" -> [[_,....]]) -> ...
15:48:31 <Lethalman> awesome, regex in haskell patterns...
15:48:34 <hpaste> edwardk pasted “cola wins!” at http://lpaste.net/92665
15:48:41 * Lethalman feels cool now
15:48:47 <acowley> OMG
15:49:01 <edwardk> wins by a lot
15:49:11 <edwardk> and i still haven't tuned the bloom filter acceptance rate
15:49:27 <acowley> I'm going to be doing some sparse matrix ad soon, I think
15:49:32 <arkeet> neat
15:49:49 <arkeet> 22 ms for 100k inserts?
15:50:04 <acowley> The old benchmark I wrote doesn't go as fast
15:50:23 <sclv> zounds!
15:50:24 <acowley> Oops, new patch
15:50:41 <edwardk> i was expecting a win, but by a slightly smaller margin
15:51:07 <edwardk> it should get better as the data set grows
15:51:23 <edwardk> i will add the 1 million entry benchmarks back in
15:51:27 <edwardk> and see how the trend looks
15:51:37 <Lethalman> what is cola?
15:51:42 <arkeet> edwardk: make a pretty graph.
15:51:47 <acowley> dang you really did it
15:51:53 <acowley> With small sizes Map is still faster
15:51:55 <edwardk> oh i will =)
15:51:57 <edwardk> sure
15:51:59 <sclv> well, for inserts :-)
15:52:02 <edwardk> i expected it to be
15:52:04 <lispy> Lethalman: do you have some complete examples?
15:52:05 <acowley> I bumped my old bench to 1k and yours wins on inserts
15:52:16 <Lethalman> lispy, let me write it down
15:52:18 <sclv> if we're only optimizing for inserts i can make a *real* fast structure :-P
15:52:27 <edwardk> did you take the 'blowing the doors off' patch or the patch before?
15:52:29 <haasn> Okay, installed cabal-install, base and lens. Now I can't think of any other essential must-have libraries :P
15:52:44 <acowley> just got the doors blow off one
15:52:44 <edwardk> sclv: well, lookup can be tuned by playing with the bloom filter rate
15:52:56 <lispy> Lethalman: awesome. I've recently wanted regexp patterns on strings so I'm interested :) Does this allow you to extract the match too?
15:53:19 <Lethalman> lispy, yes, needs -XViewPatterns
15:53:21 <acowley> haasn: http://hackage.haskell.org/packages/archive/acme-year/2013/doc/html/Acme-Year.html
15:53:36 <edwardk> sclv: the main difference in favor of this is that it is both cache oblivious and stuff sits nicely next to each other in memory. so it gives us an unboxed Data.map
15:53:38 <sclv> with specialized hardware, you can optimize for inserts even better http://www.repeater-builder.com/humor/signetics-wom.pdf
15:54:02 <edwardk> sclv: well, i was benchmarking a mixture of inserts and updates earlier
15:54:12 <edwardk> er inserts and searches
15:54:14 <donri> acowley: nice source
15:54:17 <sclv> yeah i'm teasing
15:54:17 <ion> acowley: :-D
15:54:23 <edwardk> but we gained ~24x in the last couple of hours.
15:54:42 <edwardk> the power of skew binary arithmetic strikes again
15:54:48 <haasn> acowley: ah yes, perfect :)
15:54:55 <edwardk> it ensures that i have a fixed shape for the 2 stream fusion cases i have to deal with
15:55:01 <edwardk> so stream fusion can work really really well
15:55:05 <sclv> oooh
15:55:15 <edwardk> before it had to deal with a tree of streams
15:55:18 <edwardk> not its just two
15:55:21 <edwardk> er now
15:55:22 <lispy> Lethalman: I don't know if it is compatible with shake, but that's where I want to use it
15:55:28 * lispy suspects it is compatible
15:55:37 <acowley> Wow, it's a nice simplification, too
15:55:40 <edwardk> and because of the fixed shape it can fuse it all the way down to the vector reads
15:55:42 <edwardk> yeah
15:55:45 <Lethalman> lispy, I don't think so, it's called by shake there
15:55:48 <sclv> Lethalman: COLA in this case is a cache-oblivious lookahead array (but edwardk's has a bunch of special tweaks)
15:55:56 <edwardk> it not only got faster but simpler
15:56:09 <Lethalman> sclv, ah
15:56:10 <Lethalman> thanks
15:56:31 <Lethalman> lispy, http://paste.debian.net/36219/
15:56:38 <lispy> Lethalman: thanks!
15:56:39 <Lethalman> this is awesome, I'm going to blog about it :P
15:56:44 <acowley> edwardk: How's memory usage?
15:56:47 <edwardk> this is a modified cache oblivious lookahead array based where the redundant binary counter they use is replaced with skew binary arithmetic, it is made a functional data structure, and the fractional cascading is replaced with bloom filtering for each array
15:56:51 <edwardk> acowley: haven't checked
15:57:11 <lispy> Lethalman: ah, even simpler than I realized
15:57:15 <edwardk> with all those substitutions it really its its own beast
15:57:16 <acowley> I really didn't think the bloom filter was going to help
15:57:17 <Lethalman> lispy, yeah
15:57:19 <acowley> Glad to be wrong
15:57:24 <edwardk> acowley: heh
15:57:42 <edwardk> the loss of fractional cascading meant inserts touch 1/8th the memory of before
15:57:54 <edwardk> the simplified fusion means the inserts get unboxed
15:58:15 <edwardk> there are two magic constants we need to tune.
15:58:45 <edwardk> the base rate of false positives is to tune off the cost of a bf lookup against the cost of a cache miss in the binary search
15:58:51 <sclv> i'm not sure i understand the use of blooms to replace fractional cascade
15:59:07 <edwardk> and i don't know the right threshold to turn on the blooms at
15:59:19 <edwardk> sclv: the idea is very simple.
15:59:32 <edwardk> a bloom filter lookup is O(1)
15:59:40 <edwardk> because i've used a hierarchical bloom filter
15:59:47 <edwardk> so it'll load at most one page of memory
16:00:21 <edwardk> and i set up the probabilities in such a way that we increase bloom filter size fast enough that the rate of bloom filter work to cache miss work should remain constant
16:00:44 <edwardk> but in the end we scan up to log n bloom filters, then given the ones that hit I search the array with a binary search
16:00:50 <edwardk> we expect O(1) false positives
16:01:24 <edwardk> so it serves the same purpose. the cascade was to cause is to do one O(log n) time search and then log n  O(1) time search
16:01:46 <edwardk> here we just do log n O(1) filter lookups and O(1) O(log n) time search
16:02:43 <sclv> hm i feel like i'm missing something still
16:03:01 <edwardk> each level of the map is an array in sorted order
16:03:22 <edwardk> associated with each level is a bloom filter with failure rate O(baseRate / log n)  for the n entries in it
16:03:34 <edwardk> er failure rate baseRate / log n
16:03:56 <edwardk> we treat the smaller/newer arrays as overwriting data in the old arrays
16:04:12 <edwardk> and we merge to ensure we never have more than 2 arrays of the same size and they are the smallest arrays
16:04:35 <sclv> so the bloom at each level just says what entries are in that level?
16:04:44 <sclv> that's what i'm missing
16:04:45 <edwardk> to search i just start at the bottom and check the bloom filter, if it rejects it then i keep going deeper
16:04:46 <edwardk> yep
16:04:53 <edwardk> the bloom filter is just of the keys for that level
16:05:09 <edwardk> so it has to be big enough to hold n entries at a given false positive rate
16:05:14 <edwardk> so i just compute the optimal false positive rate
16:05:20 <edwardk> er the optimal bucket and key count
16:06:00 <sclv> ok so it amortized probabalistically saves you from looking in the whole level
16:06:16 <sclv> how do you know if something is overwritten tho?
16:06:51 <edwardk> i check the smaller + newer vectors first
16:07:00 <edwardk> when i merge i throw away the old content
16:07:07 <edwardk> i do one merge per insert
16:07:14 <edwardk> the size of the merges varies wildly
16:08:28 <sclv> ok i sort of feel the picture now -- yeah, i can see why this feels elegant
16:08:31 <edwardk> but the overall workload is amortized O(log N/B) loads for every cache with blocksize B
16:08:59 <edwardk> i can add deletes by putting a bitvector back in and doing some rank tricks
16:09:11 <edwardk> but my first goal was to get something that beat map at _anything_
16:09:23 <sclv> yeah, i dig. this is exciting stuff.
16:09:44 <edwardk> unboxed maps that are 8x faster than map, just add theory
16:11:53 <edwardk> now, I can add a knob to trade-off between search and insert performance by changing out the number system
16:12:27 <edwardk> if we go from skew binary skew ternary then search gets slower and inserts get faster, but the trade-off is the COLA tradeoff!
16:13:25 <edwardk> switching to a 4-cola would be about where the theory says the ideal tradeoff is
16:13:51 <edwardk> and right now the only code that changes is insert
16:14:18 <edwardk> it picks up more stream fusion cases to handle, but they just 1 each
16:14:37 <edwardk> er they are just 1 more case each
16:14:45 <FreeFull> I like -- -}
16:14:51 <FreeFull> Toggleable comments
16:15:11 <enthropy> acowley: do you know of an example using createVideoWriter? I get "user error (Null Pointer)" so something is off with the format or size or something
16:15:59 <acowley> enthropy: I'll give it a shot!
16:16:06 <edwardk> i feel a lot like i've been wasting my time on this thing now =)
16:16:08 <enthropy> acowley: it does better than the CV library since it produces a file with the right header but 0 frames
16:16:12 <edwardk> er a lot LESS like
16:18:52 <edwardk> i suppose for testing i can write a version of insert with tunable thresholds
16:19:49 <sclv> now what we need is a testsuite that runs gradient descent to tune all the things at once
16:20:38 <hpaste> enthropy pasted “HOpenCV” at http://lpaste.net/92667
16:20:52 <enthropy> acowley: ^^ is what I'm doing
16:22:51 <enthropy> opencv is allowed to return a null pointer from cvCreateVideoWriter
16:23:27 <enthropy> so maybe there should be something to look for that and say "you asked for an unsupported format"
16:23:42 <edwardk> sclv: sounds good. i nominate you =)
16:24:15 <edwardk> sclv: in practice though, the baseRate is just a constant we don't know, the other threshold should be tunable independently
16:24:50 <acowley> enthropy: I'm seeing another problem I think
16:26:04 <enthropy> seems I was mistaken about opening the same file twice
16:26:09 <enthropy> that part works just fine
16:26:11 <edwardk> acowley: i do seem to trash a fair bit more memory than Map
16:29:37 <acowley> enthropy: I get an assertion failed in color.cpp
16:30:11 <acowley> This may take a little bit to debug as my OpenCV install may be flaky
16:57:18 <monochrom> eh? HaRe lives again?
16:58:22 <haasn> @hoogle Int -> (a -> a) -> a -> a
16:58:23 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
16:58:23 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
16:58:23 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
17:00:11 <monochrom> "unlimited stack for less" hahaha  http://thread.gmane.org/gmane.comp.lang.haskell.libraries/20113/focus=107139
17:15:14 <wellHashed> Hi. Is there a way to alias multiple type qualifiers, e.g. alias Foo k = (Bar k, Qux k) => k
17:15:53 <startling> wellHashed, you can do that with Rank2Types
17:15:58 <startling> (and "type")
17:16:18 <wellHashed> Is the syntax as I guessed?
17:17:13 <shachaf> I suspect you won't be able to accomplish what you're actually trying to accomplish.
17:17:23 <shachaf> Did you try it?
17:18:31 <startling> wellHashed, yes, with s/alias/type, but you probably want type Foo = (Bar k, Qux k) => k instad
17:18:36 <wellHashed> And several variants.
17:19:35 <hiptobecubic> #define Foo(k)....
17:19:36 <wellHashed> startling: Doesn't seem to work
17:19:39 <arkeet> startling: does he?
17:19:41 * hiptobecubic wanders off
17:19:49 <shachaf> If it doesn't work then I suggest you fix it.
17:19:51 <arkeet> wellHashed: well, what are you actually trying to do?
17:20:16 <Makoryu> Another way you could do it is with an extra typeclass
17:20:24 <wellHashed> I want a short way to apply many class qualifiers.
17:20:25 <startling> arkeet: maybe! I don't see what what wellHashed said would give you.
17:20:27 <Makoryu> Not that that's a *good* idea, but it could work
17:20:33 <Makoryu> Oh god
17:20:37 <wellHashed> To keep my code readable.
17:20:41 <arkeet> wellHashed: you could
17:20:47 <shachaf> wellHashed: If you just want a quantifier, why do you have the "=> k" thing at the end?
17:20:57 <wellHashed> I suppose I could just define an empty class...
17:21:01 <arkeet> class (Bar k,Qux k) => Foo k; instance (Bar k, Qux k) => Foo k
17:21:10 <arkeet> that would need some extensions.
17:21:16 <shachaf> If you want a constraint Foo a such that Foo a = (Bar a, Vaz a), that's a very different thing from the type synonym Foo a = (Bar a, Vaz a) => a
17:21:17 <arkeet> a nicer way would be  type Foo k = (Bar k, Qux k)
17:21:22 <arkeet> but that also requires an extension
17:21:28 <wellHashed> Yes, constrain.
17:21:38 <arkeet> in either case you could later write blah :: Foo k => ...
17:21:47 <startling> arkeet: which extension?
17:21:52 <wellHashed> An.
17:22:12 <arkeet> startling: probably some sort of (Flexible/Undecidable/?)Instances for the former.
17:22:14 <wellHashed> (I'm assuming a non-existant one)
17:22:15 <arkeet> ConstraintKinds for the latter.
17:22:22 <arkeet> ghc will tell you.
17:22:39 <startling> oh, I've never used ContraintKinds. good to know.
17:23:32 <wellHashed> You'd think what i'm trying to accomplish would be a commonly requested thing.
17:24:35 <shachaf> Well, that's why it was implemented.
17:24:50 <shachaf> But it helps if you say what it is you're actually trying to accomplish. :-)
17:25:27 <haasn> > print "foo"
17:25:29 <lambdabot>   <IO ()>
17:40:09 <wellHashed> Bah. ConstaintKinds required GHC 7.6. I'm stuck on 7.4 :(
18:01:36 <haasn> you should be able to simulate ConstraintKinds using MPTCs+FunDeps, no?
18:04:38 <arkeet> haasn: how so?
18:04:52 <djahandarie> There's no way that's possible.
18:05:31 <augur> i wish i knew what constraint kinds were :D
18:05:55 <enthropy>  type C a b c = (C1 a b c, C2 a b c);  instead you can have     class (C1 a b c, C2 a b c) => C a b c;
18:07:37 <shachaf> ConstraintKinds does a lot more than type synonyms equivalent to #define
18:07:47 <augur> how interesting
18:08:16 <augur> constraint kinds: yet more approximation of dependent types :)
18:09:39 <arkeet> enthropy: COnstraintKinds can do much more than that.
18:11:18 <haasn> arkeet: well, maybe I'm mistaken, but by turning constraints into classes?
18:11:19 <hpaste> niteria pasted “haskell platform build error” at http://lpaste.net/92669
18:11:49 <arkeet> and?
18:11:56 <monochrom> augur: I recently wrote: instance (Dispatch cls r, cls f) => ...  look at that "cls f", "cls" is being a *variable* class
18:11:57 <niteria> ^ what could be the problem here?
18:12:13 <enthropy> acowley: I think createVideoWriter never ever worked. One of the arguments is a struct CvSize which the haskell side was trying to pass as two CInt arguments
18:12:25 <acowley> enthropy: That actually works out fine
18:12:35 <augur> monochrom: indeed. Looks like just some approximation to dependent types! :)
18:12:35 <acowley> enthropy: It's fragile
18:12:42 <monochrom> to permit that, I create my class Dispatch as: class Dispatch (cls :: * -> Constraint) r where ...
18:12:59 <enthropy> acowley: well with that change it works here
18:13:00 <acowley> enthropy: But the way it goes wrong is alignment, and, at least in the past, we were okay just pushing the two ints onto the stack
18:13:04 <acowley> enthropy: !
18:13:19 <acowley> enthropy: Did you write a C wrapper?
18:13:22 <enthropy> yes
18:13:28 <augur> monochrom: yes, indeed. Agda does it better. :)
18:13:34 <acowley> enthropy: pull request?!
18:13:41 <monochrom> a concrete type signature that instantiates cls looks like: joy :: Dispatch Show Int => ...
18:14:08 <monochrom> well, I have no doublt full-blown higher-order logic does everything
18:15:01 <augur> monochrom: not eventhing, just lots. :p
18:15:05 <lispy> Luke, use the lambda cube
18:15:16 <augur> you cant do natural modal reasoning in Agda, for instance
18:16:08 <monochrom> the mother of existential types: data Mother cls = forall a. cls a => Mom a.  (cls :: * -> Constraint is automatically inferred, or you can write it yourself)
18:16:39 <monochrom> so you can have Mother Show, Mother Enum, Mother Read etc
18:16:47 <acowley> enthropy: Can you do the pull request or would you rather just lpaste it?
18:16:48 <shachaf> Of existential types for class constraints, anyway.
18:17:05 * enthropy will figure out the github
18:17:06 <monochrom> well, it is just Mother, not Gaia :)
18:17:08 <augur> data Mother (Cls : Set -> Set) : Set1 where Mom : forall {A} -> Cls A -> Mother Cls
18:17:26 <shachaf> There's always data Mom f = forall a. Mother (f a)
18:17:42 * lispy keeps reading data Mother as dear Mother
18:17:48 <acowley> enthropy: What OS are you using, btw?
18:18:22 <enthropy> an ubuntu precise x86_64
18:18:25 <augur> ofcourse, agda doesnt have true type classes, you do everything explicitly, as shachaf's doing
18:18:26 <augur> so
18:18:31 <acowley> I'll reinstall my brewed opencv in the meantime rather than my custom build
18:18:42 <monochrom> is precise 12.04 LTS?
18:18:48 <lispy> augur: instance arguments come pretty close, right?
18:19:00 <enthropy> monochrom: yes
18:19:48 <dwcook> I believe I'd like a mutable container that my many threads will use. Should I use TVar for that?
18:20:43 <monochrom> that is one option
18:21:00 <monochrom> it is the easiest to finish
18:21:01 <fryguybob> dwcook: Depends on how you want to use it.  If there is only one perhaps you want an MVar, but if you need to coordinate multiple TVars and access atomically then you want STM.
18:21:32 <augur> lispy: nah, instance arguments are just a way of not having to write the argument sort of ever
18:21:54 <augur> lispy: but they can be for anything, not just classy records
18:22:12 <augur> lispy: and more over, the type checker doesnt infer anything deeply, its very shallow. its just a lookup
18:22:48 <dwcook> fryguybob, I'm not sure, actually. My idea is to give a message queue to each thread that represents a network client, and also have a world that is shared between them.
18:23:48 <dwcook> fryguybob, in your opinion, would that be a use case for multiple such containers?
18:23:54 <monochrom> message queue is good. but you need not implement it yourself. any of existing Chan, TChan will do
18:24:02 <dwcook> monochrom, oh cool.
18:24:43 <monochrom> if you want to know, Chan is a lot of MVars, TChan is a lot of TVars. you could probably re-invent it yourself
18:24:44 <enthropy> acowley: should be sent
18:25:32 <dwcook> monochrom, the thread running the world will be the only thing writing to client queues, the respective clients the only thing reading. What kind of Chan should I use?
18:25:53 <monochrom> both will do. toss a coin.
18:25:58 <dwcook> Haha. Okay.
18:26:35 <acowley> enthropy: merged
18:40:47 <ReinH> acowley: well, I wrote a different algorithm
18:40:53 <ReinH> it's not as fast as yours, obv, but it's fast enough
18:51:43 <acowley> enthropy+++++
18:53:39 <ReinH> acowley: ~50ms for large roguelike-sized maps
18:53:49 <acowley> ReinH: 100x100?
18:53:52 <acowley> That's not bad
18:54:29 <ReinH> ~50ms for 50x50, ~100ms for 100x100
18:54:54 <ReinH> but it seems to average n log n performance in the total size of the map
18:55:10 <acowley> That's pretty good complexity
18:55:14 <ReinH> and I haven't been brutally optimizing it
18:55:25 <acowley> I still want to do the iterative Meijster and get it down to 10ms or less for 100x100
18:55:30 <ReinH> mostly I've just been making Vector happy and avoiding stupid mistakes
18:55:36 <ReinH> acowley: that would be nice :D
18:57:19 <jfischoff> are higher ranked types part of ghc's core?
18:57:44 <acowley> enthropy: Thanks again for the fix, this is great!
18:59:01 <hpaste> acowley pasted “Yay enthropy” at http://lpaste.net/92670
19:02:42 <hpaste> enthropy pasted “hopencv referential transparency breach?” at http://lpaste.net/92671
19:03:20 <enthropy> hmm, acowley is gone
19:04:29 <enthropy> but maybe somebody else can suggest why I am having repeated frames with that code
19:05:46 <danilo2> Hi! How can I in Haskell use both IO and MaybeT monad? I want to do something like "runIO (runMaybeT f)". I simply want to use IO monad with other monad transformers in stack.
19:06:08 <copumpkin> there is no runIO
19:06:16 <copumpkin> MaybeT IO should be fine though
19:09:10 <danilo2> copumpkin: Could you please look at this small example please?: http://lpaste.net/92673
19:12:09 <niteria> what are .p_o files?
19:12:41 <jmcarthur> niteria: they are for profiling
19:12:41 <startling> :t runMaybeT
19:12:42 <lambdabot> Not in scope: `runMaybeT'
19:12:53 <arkeet> @let import Control.Monad.Trans.Maybe
19:12:54 <lambdabot>  Defined.
19:12:56 <arkeet> :t runMaybeT
19:12:57 <lambdabot> MaybeT m a -> m (Maybe a)
19:12:59 <danilo2> startling: Control.Monad.Trans.Maybe
19:13:30 <danilo2> startling: its in mtl
19:14:14 <startling> danilo2: I'm aware. I was showing you the type.
19:14:35 <startling> :t :t \x -> runMaybeT (x :: MaybeT IO Int)
19:14:36 <lambdabot> parse error on input `:'
19:14:41 <startling> :t \x -> runMaybeT (x :: MaybeT IO Int)
19:14:42 <lambdabot> MaybeT IO Int -> IO (Maybe Int)
19:14:58 <arkeet> :t runMaybeT `asAppliedTo` (undefined :: MaybeT IO Int)
19:14:58 <lambdabot> MaybeT IO Int -> IO (Maybe Int)
19:15:23 <danilo2> lambdabot: Hm, ok, I'm testing it :)
19:15:23 <startling> :t asAppliedTo
19:15:25 <lambdabot> (a -> b) -> a -> a -> b
19:17:01 <startling> danilo2, you could define runIO = id :: IO (Maybe a) -> IO (Maybe a) if you like. ;)
19:17:38 <copumpkin> runIO = return . unsafePerformIO
19:17:42 <copumpkin> safe! >_>
19:18:21 <arkeet> <_<
19:18:24 <danilo2> startling, copumpkin - I'm trying to use it with runRWS and runMaybeT, maybe it will work :) Thank you :)
19:18:30 <thoughtpolice> kindaSortaMaybeSafeIO
19:18:42 <copumpkin> unsafeExtraleaveIO
19:18:52 <arkeet> unsafeLeaveIO
19:18:55 <startling> unsafePerformIO . return
19:19:18 <danilo2> but isnt unsafeperformio unsafe? :)
19:19:50 <startling> danilo2, we're joking around. sorry if that wasn't clear.
19:20:34 <danilo2> startling: ah ok :) hehe :)
19:20:35 <Makoryu> Both mtl and transformers have ErrorT stuff
19:20:41 <Makoryu> Which makes actual sense to use?
19:21:44 <arkeet> neither. use EitherT instead.
19:21:44 <arkeet> ;)
19:21:48 <startling> Makoryu, mtl just reexports transformers' stuff.
19:21:55 <Makoryu> startling: Gotcha
19:21:57 <startling> but yeah, EitherT is often what you want.
19:22:08 <Makoryu> What's the main difference
19:22:17 <Makoryu> I mean
19:22:22 <arkeet> ErrorT has an annoying Error constraint on the e type.
19:22:24 <startling> ErrorT needs an "Error" instance for any sanity
19:22:27 <Makoryu> Obviously ErrorT can have other implementations
19:22:45 <startling> and Error requires you to be able to make an error out of any string.
19:22:57 <startling> :t strMsg
19:22:57 <Makoryu> Control.Monad.Trans.Either?
19:22:57 <lambdabot> Error a => String -> a
19:23:05 <Makoryu> startling: I expected to be able to do that anyway
19:23:07 <arkeet> yes, from the either package.
19:23:20 <startling> Makoryu: ok! Then maybe ErrorT works fine for you.
19:23:29 <Makoryu> Hmm
19:24:11 <danilo2> startling: I'm trying but cannot get it working (the IO stuff). Could you please look here and tell me - what should I change to make it working?: http://lpaste.net/92673
19:24:15 <startling> I wonder why ml does reexports like that.
19:24:32 <startling> (historical reasons, probably?)
19:25:38 <arkeet> hm.
19:25:38 <arkeet> EitherT should totally be a Bifunctor.
19:25:38 <arkeet> and so on.
19:25:51 <startling> danilo2: you might need to add a type signature for 'f'.
19:26:12 <startling> danilo2: (btw, NoState is ())
19:27:02 <startling> oh, no, I see.
19:27:22 <startling> you want a few lifts, or liftIO if the right instances exist (I forget whether they do)
19:27:37 <startling> before line 10, that is.
19:28:38 <danilo2> startling: Thank you for the tip with NoState = (). hmm I'm trying with the lifts, but still no success :(
19:29:25 <startling> danilo2, import Control.Monad.IO.Class and try liftIO $ print "!!!"
19:29:46 <arkeet> maybe you need RWST.
19:30:00 <startling> oh, that too.
19:30:05 <danilo2> arkeet: If I use RWST I would need something like runIO
19:30:15 <arkeet> you mean runRWST?
19:30:17 <startling> danilo2: no.
19:30:23 <startling> danilo2, oh
19:30:31 <startling> runIO while you're in IO is just >>=.
19:30:40 <danilo2> startling: I've imported used liftIO - still not working
19:31:06 <startling> danilo2, you also need (a, b, c) <- runRWST (runMaybeT f) 0 NoState on line 14
19:31:21 <startling> I guess "join" is runIO in this case.
19:31:31 <danilo2> startling: It works!
19:31:40 <startling> danilo2, do you understand why?
19:31:40 <danilo2> startling: hmm, but why we need liftIO there?
19:31:53 <startling> danilo2, because MaybeT is not IO.
19:31:59 <startling> well, MaybeT IO is not IO.
19:32:05 <danilo2> startling: yes, yes I see the point of using (a,b,c) <-  ... in IO Monad -its clear now to me
19:32:13 <arkeet> neither is RWST r w s (MaybeT IO)
19:32:14 <danilo2> a,b,c) <- : but i do not yet see the point of liftIO
19:32:26 <startling> danilo2, well, what's the type of 'f'?
19:32:27 <arkeet> print "!!!" has type IO ().
19:32:35 <arkeet> f cannot have type IO ().
19:32:40 <startling> :t liftIO
19:32:41 <lambdabot> MonadIO m => IO a -> m a
19:32:52 <danilo2> ah ok! thats clear :)
19:32:58 <danilo2> thank you for the help!
19:32:59 <arkeet> you should ask it ofr the type of f.
19:33:16 <arkeet> it's probably something like MaybeT (RWST Integer String NoState IO)
19:33:21 <arkeet>  ()
19:33:27 <arkeet> which is not IO ().
19:34:29 <danilo2> arkeet, startling: but why print is defined like this? look - I can use "tell" without lift - and it works in both MaybeT, and RWST (and Writer of course).
19:35:04 <arkeet> well, sure, someone could have made it print :: (Show a, MonadIO m) => a -> m ()
19:35:13 <danilo2> arkeet, startling: or maybe my question was wrong - why we need to lift print if we do not need to lift f.e. tell ?
19:35:28 <startling> :t tell
19:35:29 <lambdabot> MonadWriter w m => w -> m ()
19:35:31 <startling> :t print
19:35:32 <lambdabot> Show a => a -> IO ()
19:35:46 <arkeet> the only reason I can think of for not making the type of something more general is because that usually makes type inference not work as nicely.
19:35:50 <startling> the dumb answer is "MonadIO is not in the Prelude and print is"
19:35:58 <arkeet> well, sure.
19:36:03 <danilo2> startling: so I understand the limitation is only the type in definition of print?
19:36:11 <startling> danilo2, well, the definition of print.
19:36:29 <danilo2> startling: ok, thank you :)
19:37:53 <danilo2> startling: Ok one more simple question :D Is it ok to define my own print? Or it is something ugly :D (as print = liftIO . Prelude.print)?
19:38:13 <startling> danilo2: no reason not to just use liftIO . print there, is there?
19:38:55 <danilo2> startling: maybe you're right, but it is not very elegant to me :)
19:39:03 <arkeet> http://www.reddit.com/r/haskell/comments/1jjkbr/is_there_any_reason_to_use_io_over_monadio_m_m/
19:40:49 <danilo2> arkeet: thanks :)
19:47:25 <CaptainK> @spell agnostic
19:47:26 <lambdabot> agnostic
19:49:00 <startling> CaptainK, you should renick to Captainλx.λy.x
19:50:40 <CaptainK> :P
19:51:00 <zomg> Oh, I did not know John Resig was a Haskeller
19:51:16 <zomg> This is assuming jeresig is the same person I'm thinking he is of course
19:51:52 <startling> I thought he was just a mod on every fricking subreddit
19:52:01 <zomg> That's possible too I guess =)
20:08:02 <Makoryu> Hmm
20:08:03 <Makoryu> @paste
20:08:03 <lambdabot> Haskell pastebin: http://lpaste.net/
20:10:49 <hpaste> Makoryu pasted “No title” at http://lpaste.net/92678
20:10:57 <Makoryu> Is there a less terrible way to write this
20:11:02 <Makoryu> Or an existing function I should use
20:17:06 <niteria> Makoryu: maybe some version of union can help you
20:17:19 <niteria> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map-Lazy.html#v:union
20:17:42 <Makoryu> Yeah... I'm trying to decide how I would put these to work
20:21:38 <niteria> I don't think you can use them, there's no way of bubbling up inability to unify
20:22:10 <jgross_> Is there a way to load a module and then evaluate code in that module, from the command line?
20:22:13 <Makoryu> I'd have to do something like Map k foo -> Map k (Maybe foo)
20:22:23 <Makoryu> And then see if anything failed there
20:22:29 <Makoryu> Which is ridiculous
20:22:58 <Makoryu> At least I can make this more generic though
20:23:21 <niteria> there's mergeWithKey, that looks generic enough for your case
20:23:56 * hackagebot combinator-interactive 0.1.1 - SKI Combinator interpreter  http://hackage.haskell.org/package/combinator-interactive-0.1.1 (FumiakiKinoshita)
20:24:35 <niteria> jgross_: what do you mean by evaluate code in module? you can always call main from ghci
20:24:59 <geekosaur> I wonder if jgross_ wants ghc -e
20:29:41 <Makoryu> @pl \x y -> do { xys <- f x y; xyss <- g xs ys; return (xys : xyss); }
20:29:41 <lambdabot> (line 1, column 12):
20:29:41 <lambdabot> unexpected '{'
20:29:41 <lambdabot> expecting variable, "(", operator or end of input
20:29:59 <Makoryu> Wait
20:30:01 <Makoryu> Dang
20:30:33 <jgross_> geekosaur: Yes, I want ghc -e.	But also something else, so it knows about things in my file.  If I define "foo" in "bar.hs", what do I want instead of "ghc -e 'foo'"?
20:30:47 <enthropy> you can add multiple -e flags
20:31:03 <enthropy>  ghc -e "import Foo" -e "print somethingFromFoo"
20:31:24 <geekosaur> although `bar.hs` won't probably work for that...
20:31:46 <Makoryu> @pl \a b -> (k, a) : b
20:31:46 <lambdabot> (:) . (,) k
20:33:38 <jgross_> Yeah, it's telling me parse error on bar, and could not find module Bar on Bar.
20:33:56 * hackagebot pandoc-types 1.12 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12 (JohnMacFarlane)
20:35:40 <liyang> Shurely there's a canonical library (or two) to work with GHC.TypeLits? Anyone?
20:36:27 <geekosaur> jgross_, you may need to use hint, or maybe play ugly games with ./.ghci
20:36:29 <edwardk> liyang: what do you want to do with them?
20:36:37 <enthropy> they are used in some places
20:36:39 <edwardk> liyang: i abuse them here and there
20:36:44 <enthropy> say for labels in vinyl and HList
20:36:57 <edwardk> liyang: e.g. reflection supplies instances for them so they can be used as reflections of the numbers, ec.
20:37:13 <edwardk> to match up with their behavior through SingI, etc.
20:37:15 <hpaste> Makoryu revised “No title”: “No title” at http://lpaste.net/92678
20:37:17 <liyang> edwardk: I'm not sure yet. Fixed-point arithmetic library for example. As things stand there aren't even type instances for (+) &c.
20:37:25 <Makoryu> This is as good as I can do, probably
20:37:35 <Makoryu> Well
20:37:39 <edwardk> liyang: without a working type family for (+), etc. they are kinda useless
20:37:54 <Makoryu> (I guess I could make "go" its own list merge thing)
20:38:02 <liyang> right, and I'm surprised they're not provided.
20:38:13 <edwardk> liyang: that is why it is still work in progress
20:38:18 <edwardk> the solver for all that is off in a branch
20:38:25 <liyang> Oh. :<
20:39:13 <liyang> The "Source Code" links are all broken on http://ghc.haskell.org/trac/ghc/wiki/TypeNats
20:40:37 <Fuuzetsu> Is there an example of using Data.Data anywhere?
20:40:46 <Fuuzetsu> It's kind of hard to search for.
20:42:29 <shachaf> everywhere in SYB
20:42:33 <liyang> I was also half-wondering if anyone had gotten around to implementing binary (rather than unary) numbers in Agda yet.
20:42:57 <Fuuzetsu> shachaf: SYB?
20:43:06 <shachaf> A library.
20:43:07 <Fuuzetsu> Ah, nvm got it
20:43:07 <shachaf> @where syb
20:43:07 <lambdabot> <http://www.haskell.org/haskellwiki/Scrap_your_boilerplate>,<http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/>,<http://homepages.cwi.nl/~ralf/syb2/>,<http://homepages.cwi.nl/~ralf/
20:43:07 <lambdabot> syb3/>
20:43:09 <Fuuzetsu> Thanks
20:43:18 <shachaf> The joke is that it exports a function named "everywhere".
20:43:26 <shachaf> But it's also used everywhere.
20:43:48 <shachaf> SPJ's slides are a straightforward introduction.
20:43:57 <shachaf> http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
20:44:59 <jgross_> ghc -e "import Bar" bar.hs works, if I have "module Bar where" in Bar.hs.
20:49:10 <sordina> Hey!
20:49:30 <sordina> What's a good way to build bytestrings from bits?
20:50:52 <ParaSa1lin> Data.Bits has bit twiddling functions
20:52:09 <startling> sordina, build a list of Char8 first
20:53:48 <shachaf> startling: :-(
20:54:03 <sordina> startling: Are there any good funcitons of the form [Bool] -> Char8 / Word8?
20:54:07 <shachaf> Char8 isn't a type, and if it was a type, you shouldn't use it.
20:54:10 <geekosaur> wtf is Char8
20:54:27 <startling> ugh, sorry, Word8
21:02:06 <lispy> geekosaur: there is a Char8 module
21:02:23 <lispy> in bytestring
21:02:55 <Taneb> But there is no Char8 type
21:03:02 <lispy> right
21:03:14 <lispy> but geekosaur asked what Char8 is
21:04:02 <geekosaur> yes, but someone suggested making a "list of Char8"
21:04:14 <geekosaur> in order to build a ByteString from it
21:07:38 <startling> (me)
21:07:42 <startling> (I meant Word8)
21:10:49 <sordina> startling, geekosaur: Something like this? https://gist.github.com/sordina/6472761
21:13:03 <startling> looks good.
21:14:18 <edwardk> At about 100k entries the COLA is currently hovering about 5x faster than Data.Map.
21:14:42 <sordina> I would have thought there would be a library with this functionality somewhere...
21:17:50 <bscarlet> edwardk: 5x faster doing what?
21:18:26 <edwardk> bscarlet: right now inserting, some lookups
21:18:42 <edwardk> looking for better benchmarks
21:19:02 <edwardk> github.com/ekmett/structures feel free to pull, benchmark, test/beat/hammer on it
21:19:24 <bscarlet> edwardk: what are you using for your contiguous storage?
21:19:39 <edwardk> vector
21:19:54 <edwardk> it has has a class that can be used to select the 'best' vector for a given type
21:20:13 <edwardk> and all writes to the vectors are done sequentially
21:20:18 <edwardk> so they stream nicely
21:20:28 <edwardk> it gets to use stream fusion when copying data across
21:21:05 <bscarlet> any way to used mapped storage for more permanent data?
21:21:11 <edwardk> absolutely
21:21:26 <edwardk> the vectors could be Storable vectors
21:21:38 <edwardk> and they could be mmap'ed in
21:22:02 <edwardk> my current goal is to just make this simple simple version as fast as i can
21:22:07 <edwardk> then play with variants, deletes, etc.
21:22:10 <bscarlet> sure.
21:24:07 <pharaun> finally got rid of all ascii-ism in my code
21:24:17 <pharaun> trickier than expected
21:25:13 <ayhid> should I use leksah or go for eclipseFP ? I usually use Vim + ghci + tmux, but that isn't a perfect setup ?
21:25:30 <edwardk> for a better mixed persistence story more of the stratified b-tree tricks can be used. that could also be used to just make an 'MVCC' Map, where you can explicitly make versions and continue on with tem
21:30:39 <bscarlet> edwardk: If more tricks could be used, can you easily enumerate which you currently aren't using but think you might, the better that I might understand more precisely what you're doing?
21:31:09 <edwardk> bscarlet: what i'm doing now is i replaced the fractional cascade with bloom filters
21:31:15 <edwardk> that sped things up a lot
21:31:32 <ayhid> ^ ?
21:32:07 <bscarlet> edwardk: neat
21:32:23 <edwardk> i also replaced the binary counter with a skew binary counter
21:32:28 <edwardk> so every merge only every carries once
21:32:32 <edwardk> that was the critical difference
21:32:50 <pharaun> skew binary counter, never heard of one, looking it up
21:32:51 <edwardk> i've been trying out in the 4-cola branch ways to say that instead of working through one insert + merge pair at a time what we should do is merge 2 vector pairs at a time, doing the second one in parallel via spark if it is big enough to warrant sparking
21:33:08 <bscarlet> skew binary counter? like a gray code?
21:33:32 <edwardk> pharaun: http://www.cl.cam.ac.uk/teaching/2004/IntroFuncProg/lecture08.html
21:33:47 <pharaun> edwardk: heh i arrived at that just a few moment ago :)
21:33:59 <edwardk> bscalet: make a number system where your digits are worth 2^(k+1)-1    1,3,7,15,31,...
21:34:32 <edwardk> bscarlet: now, you're allowed 0s and 1s, and a single '2' as your digits, but the 2 just be at the least significant non-0 entry if it is present
21:34:44 <edwardk> 0,1,2,10,11,12,20,100...
21:34:50 <pharaun> edwardk: does this really actually make a difference, well if you are doing the binary number manually but wouldn't the hardware take care of it?
21:35:04 <edwardk> under this system increasing by one never carries more than one place
21:35:22 <edwardk> pharaun: the 'counter' here is representing enormous arrays
21:35:47 <edwardk> pharaun: the usual use of skew binary counting as a data structure is a skew binary random access list
21:35:53 <pharaun> ahh
21:36:22 <edwardk> you have a linked list of complete trees, and you're willing to have 2 trees of the same height only if they are the first two trees in your list, and after that they must all be of increasing height
21:36:30 <bscarlet> edwardk: what were you doing when you had multiple carries? I'm used to systems where lots of carrying would be good because it'd mean a single n-way merge.
21:37:00 <edwardk> you can merge two complete trees of the same height into one of the next larger height, so adding 1 to a '2' means making a new tree of the next larger size
21:37:05 <edwardk> bscarlet: that was my intuition here as well
21:37:20 <bscarlet> not so much, then? Hmm.
21:37:20 <edwardk> but it turns out to be bad for haskell in that the fusion can't fire so it doesn't get all unboxed.
21:37:25 <bscarlet> ah!
21:37:38 <edwardk> here the pattern is simple enough that vector stream fusion can go off
21:37:54 <edwardk> every insert results in at most one merge
21:38:17 <Fuuzetsu> How can I pass Haddock options to cabal-dev/cabal-install? There's --with-haddock but I don't see any docs on passing any haddock flags.
21:38:24 <edwardk> but it is a funny 1-lement + 2 streams merge
21:39:27 <bscarlet> So n-way might be better in principle, but not under the constraints of using fusion in vectors for your merging? (i.e. if I want to jit my own merges or something I shouldn't necessarily learn from this)?
21:39:33 <pharaun> edwardk: no way to provoke/force it to fusion?
21:39:38 <edwardk> bscarlet: https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs#L128 is the insert
21:39:50 <edwardk> pharaun: i tried more complex trees, i tried lots of variants
21:40:05 <edwardk> it might be somthing that with some llvm craziness we could jit into something sexy
21:40:23 <edwardk> bscarlet: the theory says a 4-cola should b more or less ideal
21:40:46 <edwardk> like https://github.com/ekmett/structures/blob/4-cola/src/Data/Vector/Map.hs#L139 but stronger because it should do a 4-way merge not 2 2-way merges
21:41:22 <edwardk> sadly that doesn't seem to pay out right now
21:42:07 <carter> edwardk bscarlet : for Nway merges, the series fusion repa4 stuff + the accelerate fan-in fusion stuff may be relevant
21:42:10 <bscarlet> The day I have enough tooling built up to manage any such llvm craziness in ~4 lines I will be very happy indeed.
21:42:25 <carter> but you basically need a compiler plugin to do such
21:42:36 <edwardk> nicely all this logic is very compact and it is all contained in the insert function for now, so it gives us lots of room to play with knobs
21:42:46 <edwardk> it used to be spread out across a bunch of functions
21:42:54 <carter> cool!
21:43:05 <edwardk> carter: did you see this since it started beating Map?
21:43:19 <carter> edwardk see which?
21:43:25 <carter> just read the scrollback
21:43:26 <edwardk> the not-quite-cola
21:43:32 <carter> that you got shit fast with blooms?
21:43:43 <edwardk> 5-8x faster for inserts at 100k+
21:43:46 <bscarlet> edwardk: 7up?
21:44:00 <edwardk> and it should get faster with scale
21:44:05 <edwardk> 7up?
21:44:15 <carter> 100k > l2 right?
21:44:17 <bscarlet> edwardk: the un-cola. sorry.
21:44:26 <edwardk> bscarlet: ahahahaha
21:44:41 <edwardk> carter: pretty sure it thrashes a lot more than l2 by then
21:45:26 <carter> so basically on large enough sizes, the locality gain of being able to have cachelines be useful overwins the administrative constant factors vs map?
21:45:30 <edwardk> been trying to come up with a good name for this thing. i'm just calling it a vector map for now
21:45:47 <edwardk> well it starts pulling away from map below 1k entries
21:45:52 <carter> oh
21:45:53 <carter> ok
21:45:56 <edwardk> i didn't find the cross-over point
21:46:04 <edwardk> benchmarks start around there =)
21:46:05 <carter> its faster at 1k?
21:46:07 <carter> ok
21:46:08 <edwardk> yeah
21:46:12 <edwardk> 3x or so
21:46:21 <bscarlet> edwardk: how big are your entries?
21:46:27 <edwardk> Ints
21:46:38 <carter> so its a bulk insertable map with good locality
21:46:40 <edwardk> feel free to throw more benchmarks at it
21:46:48 <carter> sweet
21:46:59 <edwardk> and where you should be able to do range scans efficiently
21:47:12 <carter> so like a db
21:47:14 <carter> but smaller
21:47:15 <carter> :)
21:47:16 <edwardk> yep
21:47:20 <bscarlet> why smaller?
21:47:24 <edwardk> it is a COLA for all intents and purposes
21:47:28 <carter> less code :)]
21:47:32 <carter> :)
21:47:35 <edwardk> so b-tree comparable
21:47:36 <Fuuzetsu> It was --haddock-options.
21:48:18 <carter> now we just need to figure out the deletes!
21:48:25 <carter> and filters
21:48:27 <carter> right?
21:48:27 <edwardk> couple options.
21:48:37 <carter> oh?
21:48:46 <edwardk> we can insert a bitmap, or we can allow for a set of keys we're deleting as just another vector in our level
21:48:59 <edwardk> that is probably easier than the bitmap
21:49:27 <carter> insert a bitmap?
21:49:38 <carter> oh and drop them the next time we merge
21:49:59 <carter> and have an accilary compact with a threshold that does it
21:50:02 <carter> *ancillary
21:50:07 <carter> too
21:50:09 <edwardk> the bitvector would be things that are deletes, so we don't check them in the next file
21:50:09 <carter> right?
21:50:15 <carter> yeah
21:50:19 <edwardk> and when we merge they cancel out
21:50:42 <carter> the bitvector gets washed
21:50:45 <edwardk> done right they can be updates by doing a delete and insert in the same vector
21:50:58 <edwardk> the bitvector is probably too much adminstrative overhead comparably
21:51:09 <carter> why does https://github.com/ekmett/structures/blob/master/src/Data/Vector/Bloom/Mutable.hs#L49 have Int16max?
21:51:19 <edwardk> that would make inserts slower though, because to do it right you'd want to make the inserts do a lookup first
21:51:32 <edwardk> that means that i have to force my lazy bloom filters more often
21:51:46 <edwardk> since right now if you insert 100k entries and then lookup i don't start making blooms until the last second
21:51:47 <carter> which done right?
21:52:03 <carter> how're you using the blooms btw?
21:52:04 <edwardk> to do deletes
21:52:13 <edwardk> the blooms replace the fractional cascading
21:52:29 <carter> how so?
21:52:38 <edwardk> phone handy?
21:52:48 <carter> sure
21:52:49 <carter> gimme a minute
21:52:50 <bscarlet> edwardk: hey!
21:52:52 <edwardk> ring when free
21:53:02 <bscarlet> I'd like to hear this too...
21:53:14 <edwardk> ok, gimme a phone number and i'll conference you =P
21:53:42 * startling wants to join in
21:55:09 <carter> are you bringing marshmellows?
21:55:32 <leroux> Skype sounds handy at a time like this.
21:55:41 <leroux> carter: I'm out of marshmallows....
21:55:54 <edwardk> ok, maybe a google hangout makes more sense
21:56:49 <startling> ha
22:00:32 <carter> https://plus.google.com/hangouts/_/799584d5a34e04c0ed587fc325521be551b95952?hl=en might work?
22:01:28 <carter> bscarlet startling  try joining?
22:02:05 <carter> leroux: we can't see or hear you
22:02:06 <leroux> I disabled my audio and video.
22:02:15 <leroux> Just here to listen in.
22:02:18 <carter> ahh lurking
22:03:00 <shachaf> What's that?
22:03:14 <h4199> click it and find out
22:03:28 <carter> its edwardk explaining structures :)
22:03:29 <edwardk> shachaf: chatting about the COLA stuff
22:05:09 <Taneb> I may also lurk
22:07:52 <shachaf> Hmm, my connection isn't good enough to lurk.
22:07:54 <carter> joint!
22:07:56 <carter> *joint
22:07:59 <carter> *join
22:08:31 <mlamari> Does getDirectoryContents potentially leak some resource if its result is not read to the end?  (lazy io)?
22:10:04 <mm_freak> mlamari: that one isn't lazy as far as i know
22:11:36 <Taneb> Looking at the video conference, do I need a beard to be a Haskell hacker?
22:23:43 <carter> Taneb not really :P
22:24:07 <startling> that comes later.
22:24:21 <Taneb> Good, facial hair looks awful on me :P
22:24:39 <startling> Facial hair is so uncomfortable. Also I hate shaving. Catch-22.
22:24:52 <Taneb> I probably ought to change my profile pic to something more "professional" some time in the next 5 years
22:25:27 <carter> startling shave the neck, problem solved
22:26:14 <Taneb> carter, but the neck is the most annoying bit to shave!
22:27:48 <td123> startling: I heard facial hair grows on you after a week
22:28:45 <startling> td123: more like 36 hours
22:49:15 * hackagebot llvm-general-pure 3.2.8.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.8.1 (BenjaminScarlet)
22:49:17 * hackagebot llvm-general-pure 3.3.8.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.8.1 (BenjaminScarlet)
22:54:15 * hackagebot llvm-general 3.2.8.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.8.1 (BenjaminScarlet)
22:54:17 * hackagebot llvm-general 3.3.8.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.8.1 (BenjaminScarlet)
23:41:17 <NemesisD> i'm trying to benchmark 2 algorithms with a bunch of data lazily loaded from disk
23:41:57 <NemesisD> but the problem is that by the second algorithm, the data would presumably all be evaluated
23:43:49 <scripty> installed haskell , it took a long time :)
23:44:42 <arkeet> NemesisD: using criterion?
23:47:18 <NemesisD> arkeet: will the pure coombinators take care of laziness-fairness there?
23:47:26 <NemesisD> i'm assuming it duplicates the thunks or something?
23:47:33 <arkeet> ??
23:49:22 <NemesisD> so i load a bunch of data lazily from a file, it us unevaluated. i run 2 tests against that data and use "nf" to evaluate it to normal form
23:49:48 <NemesisD> i'm trying to ensure the second test gets unevaluated input data just like the first one so the comparison is fair
23:50:28 <arkeet> can't you just load the data once for each run?
23:52:36 <NemesisD> i guess so..
23:54:29 <scripty> Can Haskell be first Language ?
23:54:29 <arkeet> or, if it fits in memory, load it and fully evaluate it before doing any runs.
23:55:25 <arkeet> NemesisD: and if it didn't fit in memory, you wouldn't be able to hold onto the same lazy result anyway, since it wouldn't be GC'd
23:56:09 <arkeet> lazy IO makes me sad. =(
23:59:31 <roboguy_> scripty: sure
