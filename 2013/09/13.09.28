00:01:17 <gienah> hmm, that did not seem to override my config file which tells yi to look like emacs
00:02:49 <gienah> the yi pango frontend seems to work as well
00:03:20 <ethercrow> yes, --as=something doesn't override user config
00:03:50 <ethercrow> if user has config, it's assumed that he knows, what he's doing :)
00:13:07 <gienah> ethercrow: it needs a little patch for the vte frontend
00:13:17 * gienah tries patching it
00:18:12 * gienah tries the yi 0.6.7.0 vte patch: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/app-editors/yi/files/yi-0.6.7.0-vte.patch
00:22:16 <ethercrow> afaik, the only frontends that are not deprecated are pango and vty
00:22:46 <gienah> ethercrow: that patch allowed the vte frontend to compile
00:22:51 <ethercrow> but who cares, you can undeprecate anything you want
00:23:03 <ethercrow> if you make it work
00:24:31 <gienah> ethercrow: well, it compiled, running it though it crashes: zsh: segmentation fault  yi --frontend=vte accfun.hs
00:25:16 * gienah sees why the vte frontend is deprecated :)
00:27:06 <pdxleif> vte? Is that like vty?
00:29:16 * gienah does not know. vte wants gtk2 stuff.
00:30:59 <ethercrow> git log says it's "Gtk with integrated terminal"
00:47:57 <adelbert_> would i be correct in saying that for doing effects in haskell, say IO, each function that needs to side effect instead returns an IO which is a kind of "computation" that describes the effect, and at the "end of the world" in "main" an implicit unsafePerformIO() is called?
00:49:04 <paolino> hello, is there a way to have an Map.adjust for monadic changes ?
00:49:14 <paolino> :t M.adjust
00:49:15 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
00:49:16 <arkeet> adelbert_: ehh
00:49:43 <arkeet> adelbert_: this is a good read http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351#13538351
00:50:45 <adelbert_> arkeet - will take a look, thanks
00:50:56 <pdxleif> ethercrow: Trying to build, I get a compile failure, after a configure warning about two different versions of binary being depended on: 0.5.1.1, and 0.7.1.0
00:51:05 <paolino> I need a (Ord k, Monad m)  => (a -> m a) -> k -> M.Map k a -> m (M.Map k a)
00:51:29 <pdxleif> Compile error is src/library/Yi/Dynamic.hs:135:19:  No instance for (Binary ConcreteTypeRep) arising from use of 'put'.
00:52:35 <ethercrow> pdxleif: ghc-7.6 depends on binary-0.5-something
00:52:50 <ethercrow> can you figure out what package depends on 0.7.1 one?
00:54:26 <arkeet> paolino: do you mind using lens?
00:54:54 <ethercrow> ghc-pkg dot | grep binary could help
00:55:00 <shachaf> paolino: This is proposed for containers but not in yet.
00:55:19 <shachaf> paolino: lens has a function which does roughly the same thing.
00:55:39 <paolino> lens is ok
00:55:44 <arkeet> ix does it
00:55:51 <shachaf> ix :: (Ord k, Applicative f) => k -> (a -> f a) -> Map k a -> f (Map k a)
00:56:03 <shachaf> at :: (Ord k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a) -- also relevant
00:57:01 <paolino> mh, I have Monad m
00:57:17 <shachaf> You can make it work with Monad, of course.
00:57:20 <shachaf> Applicative is more genral.
00:57:21 <shachaf> e
00:57:34 <paolino> ah, right
00:57:52 <shachaf> In particular, traverseOf (ix k), mapMOf (ix k), ...
00:58:01 <arkeet> > M.fromList [(1,'a'),(2,'b')] & ix 2 %%~ (\x -> [x,x])
00:58:04 <lambdabot>   [fromList [(1,'a'),(2,'b')],fromList [(1,'a'),(2,'b')]]
00:58:08 <arkeet> hm.
00:58:31 <arkeet> > M.fromList [(1,'a'),(2,'b')] & ix 2 %%~ (\x -> [succ x, succ$succ x])
00:58:32 <lambdabot>   [fromList [(1,'a'),(2,'c')],fromList [(1,'a'),(2,'d')]]
00:58:35 <arkeet> good enough
00:58:49 <arkeet> > ix 2 (\x -> [succ x, succ$succ x]) M.fromList [(1,'a'),(2,'b')]
00:58:51 <lambdabot>   Couldn't match type `(->) [(t0, GHC.Types.Char)]' with `[]'
00:58:51 <lambdabot>  Expected type:...
00:58:52 <arkeet> oh
00:58:54 <arkeet> > ix 2 (\x -> [succ x, succ$succ x]) $ M.fromList [(1,'a'),(2,'b')]
00:58:55 <lambdabot>   [fromList [(1,'a'),(2,'c')],fromList [(1,'a'),(2,'d')]]
01:00:07 <arkeet> > ix 5 (\x -> [succ x, succ$succ x]) $ M.fromList [(1,'a'),(2,'b')]
01:00:09 <lambdabot>   [fromList [(1,'a'),(2,'b')]]
01:02:07 <arkeet> it's implemented in terms of lookup.
01:02:43 <shachaf> I implemented it directly in terms of Map once.
01:02:46 <shachaf> I posted it to the list.
01:02:55 <shachaf> Then I abandoned it because ugh, benchmarking.
01:03:07 <shachaf> (Other people were doing some benchmarking but they were doing it wrong.)
01:03:20 <shachaf> (Or I was. I don't remember.)
01:03:26 <arkeet> lol
01:04:25 <paolino> http://lpaste.net/93536
01:05:00 <paolino> I need a new brain with lens plugin
01:05:37 <arkeet> the plural of vertex is vertices btw =(
01:06:04 <paolino> and english plugin
01:06:04 * arkeet finds it weird using lensy operators together with $ instead of &
01:07:06 <paolino> what happens to the %~ inside the adjust when f is monadic ?
01:07:40 <arkeet> %%~
01:07:45 <arkeet> aka id
01:08:01 <arkeet> :t (%%~)
01:08:01 <lambdabot> Overloading p q f s t a b -> p a (f b) -> q s (f t)
01:08:05 <arkeet> (it's id)
01:08:28 <paolino> from very far
01:08:40 <arkeet> (%%~) :: Applicative f => Traversal s t a b -> (a -> f b) -> s -> f t
01:08:44 <arkeet> and so on.
01:09:49 <arkeet> compare (%~) :: Traversal s t a b -> (a -> b) -> s -> t
01:10:01 <arkeet> (or really any Setter there)
01:11:26 <user123abc> I'm trying to import a type that happens to share the same name as a data constructor but ghc fails to do it and tells me to import the constructor instead
01:11:37 <user123abc> http://lpaste.net/2529131650193817600
01:11:56 <user123abc> what am I doing wrong?
01:13:17 <pdxleif> ethercrow: Got rid off all the binary-0.7 related stuff and it compiles now - thanks
01:15:07 <arkeet> user123abc: interesting!
01:15:11 <arkeet> sounds like a bug.
01:15:16 <user123abc> oh, I see, I'd rolled back the file that was being included and it was attempting to include an Expr constructor that no longer existed
01:15:22 <arkeet> oh, well then.
01:15:32 <arkeet> :)
01:15:34 <user123abc> that caused ghc to assume that I was trying to include the Expr constructor instead
01:15:54 <user123abc> I'd say that the error message is bad
01:16:08 <arkeet> why so?
01:16:17 <user123abc> since I added a list of constructors, it's way more likely that I'm trying and failing to import a type
01:16:27 <arkeet> heh
01:16:34 <user123abc> rather than trying to import a constructor and for some reason attaching a list of constructors to the constructor import
01:16:36 <pdxleif> ethercrow: It noticed my config.hs needed recompiling.  Changed the theme.  Now after that, I just get a black terminal that says "yi-linux-x86_64: <<loop>>" at the top when I launched it.
01:16:50 <pdxleif> Let me get rid of the config file - it looked nice before that.
01:17:50 <ethercrow> Well, I can only guess
01:18:13 <ethercrow> maybe you accidentally used "self" instead of "super" in overriding theme?
01:18:22 <user123abc> in fact, I think it should have told me "could not find constructor Etop for type Expr" or something
01:18:28 <ethercrow> so the overriding looped
01:18:38 <ethercrow> or something like that
01:19:38 <pdxleif> I blew it away, typed "yi" by itself, then hit "v" (for vi) when prompted to choose to create a config file
01:19:59 <pdxleif> But I don't know what keybindings to use to save this file - doesn't seem to recognize anything vi
01:22:34 <ethercrow> pdxleif: :w or :wq works fine here in this situation
01:22:40 <haasn> “No wait, monads are like space suits, and functions of type a -> M b are like space brothels where you take off your suit, get space herpes and then put your suit back on.” oh boy
01:22:44 <ethercrow> what did you try?
01:23:29 <pdxleif> :w just enters that into the text. Esc says "Unrecognized input: Esc"
01:24:00 <pdxleif> Not sure how to exit. I'll just kill the process, I guess
01:24:21 <monoidal> pdxleif: maybe ctrl-[?
01:25:22 <pdxleif> Huh - seems like just a one-time thing.  2nd time around, I got a vi keymap after hitting "v"
01:26:22 <ethercrow> maybe you hit c instead of v
01:26:35 <ethercrow> it restults in what you just described
01:27:08 <pdxleif> Possibly.  Anyway - seems to be working fine now.  Thanks!  Good work!
01:28:48 <pdxleif> Should I uncomment the import Yi.UI.Vty (start)?
01:30:24 <ethercrow> pdxleif: it's default anyway
01:31:34 <ethercrow> I would start with yi/example-configs/yi-vim2.hs
01:37:10 <pdxleif> It doesn't seem to recognize the :split command
01:37:34 <pdxleif> And ctrl-W doesn't seem to be working for switching back & forth between the quickfix window.
01:44:07 <ethercrow> pdxleif: omg, we have quickfix window?
01:45:21 <KingsleyT> aaaaaaaa haskell is too beautiful for my pathetic mortal mind
01:47:08 <Iceland_jack> KingsleyT: It is? :)
01:47:49 <pdxleif> ethercrow: If there's an error in the yi.hs conf, pops up what looks like a quickfix window.
01:48:09 <ethercrow> pdxleif: ok, I'm able to split using ":yi splitE" and switch back and forth using <C-w><C-w>
01:48:11 <pdxleif> I think before trying this yi-vim2.hs I could ctrl-W switch in and out of it.
01:48:45 <ethercrow> implementation of C-w is different in vim and vim2, but they should both work
01:48:55 <KingsleyT> Iceland_jack: after programming in C# for years and seeing equivalent implementations of common algorithms in Haskell, I simultaneously never want to go back, and yet am too inexperienced to write Haskell well
01:49:07 <KingsleyT> so I am now temporarily and totally ruined as a programmer .D.
01:49:29 <pdxleif> Cool, works for me.
01:50:08 <ethercrow> KingsleyT: one more lisp and you remove "temporarily" from that sentence
01:50:53 <pdxleif> In vim I think I'm used to Ctrl-W + arrow in direction I want to go, but Ctrl-W Ctrl-W might be a better habit.
01:51:04 <ketil> I get 403 Forbidden when trying to upload to Hackage?
01:51:06 <Iceland_jack> KingsleyT: Please carry on!
01:51:08 <haasn> KingsleyT: sounds a bit like me; I moved to Haskell from C# as well
01:51:28 <pdxleif> :yi splitE seems to take a second, though.
01:51:37 <KingsleyT> haasn: how long did it take you to adjust?
01:51:40 <ethercrow> it fires up an interpreter
01:51:48 <haasn> Then after drudging on with Haskell for a while I eventually got to the point where I could start effectively using it in practice, and these days I'm stuck inside lens satori
01:52:03 <haasn> KingsleyT: No idea, it's a continuous process. I've been using Haskell for something like 2 years now I think
01:52:16 <Iceland_jack> KingsleyT: (a more poetic person might call it a cathartic process)
01:52:27 <haasn> KingsleyT: I never really had any problems ‘unlearning’ C#, though. I know a lot of people struggle using Haskell since it requires a fresh approach
01:52:42 <pdxleif> Ah, that explains the hint dep
01:52:46 <KingsleyT> Iceland_jack: I'd have to agree..
01:53:18 <KingsleyT> and here I was hoping to learn haskell in ~2 months
01:53:23 <KingsleyT> :|
01:53:33 <haasn> One does not simply ‘learn’ any language in ~2 months
01:53:51 <haasn> Even after 2 years I routinely learn new things or get surprised
01:53:56 <KingsleyT> I mean be able to at least think in it
01:54:11 <KingsleyT> it's been about a month and a half and I'm still surprised by simple things :P
01:54:16 <haasn> Oh, fair point; Well, that gets better over time as well, increasing with the number of Haskell source you've been exposed to I'd say
01:54:30 <haasn> the amount of*
01:54:55 <KingsleyT> I'm running through the Learn You a Haskell book, and one thing I'm finding hard is that it's putting IO off for so long
01:55:13 <Iceland_jack> KingsleyT: Yes, IO could be introduced sooner
01:55:19 <haasn> I'm not sure it should, though
01:55:19 <KingsleyT> almost to it now, but I'm used to writing some sort of console program I can route around in
01:55:31 <KingsleyT> yeah, I understand why it's put off so long
01:55:41 <KingsleyT> and to some extent the repl makes up for it
01:55:48 <haasn> KingsleyT: Haskell is the first language where I routinely work more with the REPL rather than writing actual programs
01:55:55 <haasn> (Note: I don't know any other languages that have good REPLs)
01:56:06 <haasn> Personally I think LYAH should just put a stronger emphasis on how to use GHCi interactively
01:56:12 <haasn> Because then you don't need IO to do pretty much everything
01:56:20 <KingsleyT> I feel almost like a good first program would be something that works on data sets, rather than a traditional extrapolated-text-adventure
01:57:03 <Iceland_jack> haasn: Also the small differences between interactive usage (many of whom have been fixed in the latest version of ghci) made it difficult to go through it
01:57:13 <KingsleyT> since its whole thing is basically applying functions to data and getting neat results
01:57:28 <haasn> Yeah, it's improved a lot; especially now that you can define data types, classes, instances etc. directly from within GHCi
01:57:28 <KingsleyT> but applying zip to [1,2,3] ['a','b','c'] gets old quickly :|
01:57:45 <haasn> (Which is relatively recent in terms of GHC versions)
01:58:30 <Iceland_jack> You mean (zip [1..] "abc")? ;)
01:58:42 <Iceland_jack> Have you done any IO in Haskell KingsleyT?
01:58:42 <KingsleyT> SEE
01:58:43 <KingsleyT> SEEE
01:58:46 <haasn> Iceland_jack: heh, I was debating saying exactly that. :P
01:58:52 <KingsleyT> and no I'm just finishing chapter 4
01:58:54 <KingsleyT> :[
01:59:21 <haasn> Wait.. I have to ask. Is your name a pun on monad transformers?
01:59:28 <Iceland_jack> well, if you want IO you can do:
01:59:28 <Iceland_jack> ghci> content <- readFile "/tmp/test.txt"
01:59:29 <Iceland_jack> ghci> zip [1,2,3] content
01:59:54 <Iceland_jack> Monad transformers on chapter 4 of LYAH?
01:59:59 <Iceland_jack> Doubt it
02:00:10 <KingsleyT> haasn: mine? nope
02:00:34 <Iceland_jack> “KingsleyT Identity a”
02:00:35 <haasn> Ah, okay. So it's an amusing coincidence :)
02:00:45 <KingsleyT> although I'm going to keep an eye out for that now :P
02:01:11 <mangaba_leitosa> haasn: ocaml, scala, python, ruby, seem to have equally good REPLs
02:01:25 <mangaba_leitosa> haasn: some of them have autocompletion, which ghci lacks
02:01:31 <haasn> GHCi has autocompletion
02:01:35 <KingsleyT> ^
02:01:43 <mangaba_leitosa> oh really
02:01:47 <haasn> tab completion, you mean?
02:01:52 <mangaba_leitosa> I have not discovered it yet then :-)
02:01:53 <haasn> Or something else? (ie. code generation)
02:01:58 <mangaba_leitosa> haasn: yes, tab completion
02:01:59 <Iceland_jack> KingsleyT: but yeah, IO is fairly easy in Haskell (but when you start using higher-order functions they look trickier)
02:02:23 <Iceland_jack>     do print 1
02:02:23 <Iceland_jack>        putStrLn "hello world"
02:02:26 <Iceland_jack> easy
02:02:34 <haasn> IO is ‘easy’ but you have to understand the semantics of it
02:02:41 <haasn> It's not like any other language I've ever used
02:02:47 <mangaba_leitosa> haasn: I, well, it works for me, just forgot about it somehow :-)
02:02:51 <Iceland_jack> haasn: In what way?
02:03:33 <Iceland_jack> the main difference is that IO actions are values
02:03:43 <haasn> Iceland_jack: In that IO actions are pure representations of side effects that ‘could be’, and you combine these together instead of actually ‘executing’ anything
02:03:52 <Iceland_jack> and you can't write:
02:03:52 <Iceland_jack>     print (getLine + getLine)
02:03:52 <Iceland_jack> like you would in other languages
02:04:03 <mangaba_leitosa> haasn: that is, it works to complete function names, but if you write Module. and press tab, it won't list and complete existing function names in Module
02:04:09 <haasn> It's important to keep in track of what's an IO action, what's a pure function, etc.; unless you want to get confused
02:04:17 <mangaba_leitosa> haasn: (at least it doesn't for me)
02:04:25 <KingsleyT> interesting
02:04:26 <Iceland_jack> mangaba_leitosa: ghci does complete function names
02:04:47 <mangaba_leitosa> Iceland_jack: it does, but does not do so for 'Module.' + tab
02:04:58 <mangaba_leitosa> Iceland_jack: without this, it's not as useful :_)
02:05:04 <Iceland_jack> Wait, yes it does?
02:05:05 <haasn> mangaba_leitosa: typing Con<tab> here brings up a completion list containing everything I imported from matching modules (as well as some constructors)
02:05:32 <mangaba_leitosa> haasn: 'Con'?
02:05:35 <haasn> Contro tab complets to Control, inserting another dot and hitting tab now shows a list of all functions from all modules inside Cotrol.*
02:05:41 <Iceland_jack> mangaba_leitosa: Control ... something
02:05:48 <haasn> Control.* even
02:05:57 <haasn> mangaba_leitosa: just as a random example. I had ‘Control.Lens’ in mind :)
02:06:05 <Iceland_jack> If I do: Data.List.^I get asked if I want to see all possible competions
02:06:21 <Iceland_jack> So you may have a broken build
02:06:23 <mangaba_leitosa> Iceland_jack: hmm, not my case...
02:06:27 <haasn> mangaba_leitosa: GHC version?
02:06:48 <mangaba_leitosa> The Glorious Glasgow Haskell Compilation System, version 7.6.3
02:06:54 <Iceland_jack> You should have it...
02:06:58 <Iceland_jack> where are you using ghci?
02:07:05 <mangaba_leitosa> gentoo linux
02:07:05 <haasn> Weird! 7.6.2 here and everything ‘works fine’
02:07:07 <Iceland_jack> If you use it in say Emacs...
02:07:08 <haasn> Gentoo also
02:07:40 <mangaba_leitosa> Iceland_jack, haasn: maybe I need some special $HOME/.haskeline setting?
02:07:45 <Iceland_jack> You shouldn't
02:07:54 <Iceland_jack> are you running it in a regular terminal?
02:07:58 <haasn> (does GHCi even use haskeline?)
02:08:36 <mangaba_leitosa> haasn: it does, for example I set 'maxHistorySize: Nothing' to prevent ghci from trimming the history file at 100 lines
02:08:55 <mangaba_leitosa> haasn: in ~/.haskeline
02:08:56 <monoidal> autocomplete won't suggest a module that is not loaded, except for an import
02:09:30 <Iceland_jack> Is it possible that mangaba_leitosa has some other setting in .haskeline that disables the completion?
02:09:31 <haasn> mangaba_leitosa: whoa! useful
02:09:32 <monoidal> so if you attempt "Prelude> Data.List.<tab>" you won't see it. you can do "import Data.L<tab>" and then Data.List.<tab> should
02:09:53 <monoidal> ... work
02:10:05 <saep> Iceland_jack: What is your ghci-commandline when you try to autocomplete modules?
02:10:19 <mangaba_leitosa> Iceland_jack, monoidal: my bad! I did not do import Data.List before trying this
02:10:36 <mangaba_leitosa> Iceland_jack, monoidal: works after import Data.List :-)
02:10:54 <Iceland_jack> I'm not sure what you're asking saep
02:11:09 <saep> ``:m + Control.<Tab> `` completes all installed modules, whereas ``Control.<Tab>`` would only complete loaded modules (as it completes functions)
02:11:25 <Iceland_jack> saep: (you can use "import" on newer ghcis)
02:11:47 <Iceland_jack> rather than :m +, along with specifying imports and hiding
02:12:04 <saep> nice to know :)
02:12:37 <mangaba_leitosa> haasn, Iceland_jack: BTW, what about automatic brace matching? I miss it so I currently use 'rlwrap ghci' instead of actually using ghci's line editor
02:12:58 <mangaba_leitosa> haasn, Iceland_jack: (but with rlwrap, any tab completion is unavailable, of course)
02:13:11 <haasn> I don't tend to use braces personally
02:13:25 <haasn> (or parentheses, not sure if you were including those or not)
02:13:34 <Iceland_jack> mangaba_leitosa: I use ghci in Emacs where Emacs takes care of that
02:13:34 <mangaba_leitosa> haasn: yes, I'm refering to parentheses :_)
02:13:40 <mangaba_leitosa> Iceland_jack: I see
02:14:05 <monoidal> it is true that autocomplete could complete e.g. Data.List.gr to Data.List.group, even if the module is not loaded, but it would probably slow down ghci with tons of packages installed
02:14:06 <haasn> mangaba_leitosa: yeah, I like to avoid them; usually I'll just go one or two nestings deep, not very much to the point where I need to keep track of them. :)
02:14:10 <Iceland_jack> also if you're working in ghci you shouldn't have to use that many parentheses that it becomes a problem, frankly
02:15:15 <Iceland_jack> if you have something like:
02:15:15 <Iceland_jack>     print (head (sortBy (comparing length) (group (sort …))))
02:15:15 <Iceland_jack> you can change it to:
02:15:15 <Iceland_jack>     print $ head $ sortBy (comparing length) $ group $ sort …
02:15:16 <mangaba_leitosa> haasn: I have to construct complex structures such as [[(a, b, Node (Leaf 1) (Node (Leaf ....) (Leaf 3))],  often enough
02:15:24 <Iceland_jack> mangaba_leitosa: Use an editor?
02:15:58 <haasn> mangaba_leitosa: Ah that makes sense. I don't really do that very often but when I do I like to write parentheses in matching pairs so I don't have to take care of them later (Also whenever I write TemplateHaskell code :)
02:16:10 <mangaba_leitosa> Iceland_jack: that's the whole point of REPL. being able to do things ineractively :-)
02:16:17 <mangaba_leitosa> Iceland_jack: interactively
02:16:26 <haasn> mangaba_leitosa: eg. start with [] then go inside and type out (,,) and then fill those with a, b, and Node () [] -- or whatever, respectively
02:16:28 <Iceland_jack> mangaba_leitosa: Yes but you don't write everything in the repl..
02:17:07 <mangaba_leitosa> Iceland_jack: I don't. I usually write my function in a file, but then I need to test it interactively and pass complex structures to it
02:17:10 <Iceland_jack> If you're working on a cipher and you have an s-box you don't write it out by hand in ghci, you work it out once in an editor in a file and then load that to ghci
02:17:35 <Iceland_jack> If they're too complex to write in ghci you can either write them to a file or make functions that generate the structures
02:17:50 <Iceland_jack> e.g. using fold + insert to create a tree
02:18:40 <mangaba_leitosa> Iceland_jack: [[(a, b, Node (Leaf 1) (Node (Leaf 2) (Leaf 22) (Leaf 23)) (Leaf 3))] is not as complex :-)
02:18:52 <mangaba_leitosa> Iceland_jack: just sufficient for testing a functin
02:18:56 <Iceland_jack> well you can write it out by hand then
02:19:26 <mangaba_leitosa> Iceland_jack: I do, and  brace matching is handy in this case, so I have to use rlwrap ghci :-)
02:19:47 <mangaba_leitosa> Iceland_jack: (instead of running ghci in emacs)
02:20:18 <Iceland_jack> It doesn't sound like you have a problem
02:20:42 <mangaba_leitosa> haasn: yes, I understand this approach, yet having brace matching in vim makes you lazy
02:21:11 <mangaba_leitosa> haasn: so I don't have a habit writing a closing paren knowing that vim will always check paren balance for me :_)
02:21:12 <haasn> mangaba_leitosa: I do this in vim, too! :)
02:22:05 <mangaba_leitosa> haasn: also, I'm used to 'ledit ocaml', which also does this for you
02:22:11 <haasn> mangaba_leitosa: while I think that approach works fine if you just need to close a bunch of braces, I find it gets much harder when there are further parameters you have to specify *after* closing some level of braces
02:22:15 <haasn> Which is often case with TH
02:22:27 <mangaba_leitosa> haasn: right :-)
02:22:30 <haasn> so I start with Con Foo [] [] [] Bar -- or whatever, and then fill them out :)
02:22:48 <haasn> Or even sometimes if you have to close different types of braces, eg. ))])]]
02:23:07 <mangaba_leitosa> haasn: right, like interleaving [] with () as in my example above :-)
02:23:25 <haasn> mangaba_leitosa: though I guess it would be possible to provide a command that closes the ‘last opened’ braces
02:23:36 <haasn> so instead of typing ) ) ] manually you hit <close><close><close>
02:24:03 <mangaba_leitosa> haasn: there is such a setting for haskeline but that is not exactly the same
02:24:11 <haasn> I wonder if that could be integrated with type checking as well so vim notifies you if there are further parameters you have to specify, now! (But that would probably get ugly very fast for higher order or polymorphic stuff :)
02:24:16 <mangaba_leitosa> haasn: I don't want the editor to write code for me :-)
02:24:23 <mangaba_leitosa> haasn: just assisnt in checking parens :-)
02:24:27 <mangaba_leitosa> haasn: just assist
02:24:35 <haasn> fair enough. Have you heard of/used rainbow parens?
02:24:42 <haasn> I have a script for them installed but I've never actually set them up..
02:24:47 <mangaba_leitosa> haasn: no
02:26:01 <haasn> They might come in handy for something like this; basically matching parens are colored the same. I wonder if a GHCi wrapped could provide that?
02:26:03 <haasn> wrapper*
02:26:05 <mangaba_leitosa> haasn: googled and it looks like something for vim. but vim's ':set showmatch' is all I need :-)
02:26:24 <haasn> https://github.com/kien/rainbow_parentheses.vim
02:26:44 <mangaba_leitosa> haasn: thanks, maybe will try it
02:26:57 <mangaba_leitosa> haasn: but if I get used to it, I will also want this feature in REPLs
02:27:04 <haasn> hehe
02:27:04 <mangaba_leitosa> haasn: and my life will get even harder
02:27:20 <haasn> I want syntax highlighting in GHCi, too
02:27:27 <mangaba_leitosa> :-)
02:27:37 <haasn> ..and in my IRC client, for #haskell!
02:27:43 <mangaba_leitosa> :-))
02:27:59 <gauthier> is it possible to use "where" in a pattern guard or "let in" is mandatory?
02:28:37 <haasn> I wonder if it would be possible to write a weechat script for that. I know there are command line programs that will just neatly highlight whatever you feed into them, and weechat should easily be able to detect “> foo” inside #haskell, strip off the > prefix and pass that into said program
02:28:52 <haasn> gauthier: you can, but the where covers all guards afaik
02:29:27 <mangaba_leitosa> haasn: anyway, rlwrap ghci implements paren matching via the standard readline feature 'set blink-matching-paren on', I think that haskeline should have it as well :-)
02:30:02 <haasn> mangaba_leitosa: submit a patch? :)
02:30:19 <mangaba_leitosa> haasn: good idea, yes :-)
02:30:50 <haasn> Hmm.. time to go look at haskeline settings. I never knew GHCi used it!
02:31:11 <mangaba_leitosa> haasn: yes, its use by ghci is very poorly documented, almost kept in secret
02:31:17 <gauthier> haasn: thanks, so I can't reference members I deconstruct (I might be mixing pattern guards and pattern matching) http://lpaste.net/93540 ?
02:31:31 <haasn> mangaba_leitosa: what does “editMode Vi” do?
02:31:32 <mangaba_leitosa> haasn: I only found this info in stackoverflow questions
02:32:12 <mangaba_leitosa> haasn: it will enable vi mode just like in bash (you can exit insert mode using Esc and use vim's command letters)
02:32:23 <mangaba_leitosa> haasn: and vi mode does have % for paren matching
02:32:43 <mangaba_leitosa> haasn: but you have to press % every time you need it then :-)
02:34:06 <haasn> gauthier: I see what you are trying to do now. No, I think you need a ‘let’ for that. But note that in your case you'd probably be better off just pattern matching in the first place :)
02:34:12 <haasn> handleEvent (EventMotion p) w = ..
02:34:21 <mangaba_leitosa> haasn: in bash, the equivalent command is set -o vi
02:34:31 <haasn> mangaba_leitosa: interesting
02:34:58 <haasn> mangaba_leitosa: huh, but it doesn't seem to be vim; eg. I can't do ‘ciw’ to replace a word
02:35:09 <mangaba_leitosa> haasn: no, it's just 'vi' mode :-)
02:35:21 <haasn> I guess so.. Oh well, might still be nice to get used to :)
02:35:35 <mangaba_leitosa> haasn: why ciw, not cw?
02:35:40 <haasn> mangaba_leitosa: habit I guess
02:35:43 <mangaba_leitosa> haasn: cw should work
02:35:55 <gauthier> haasn: that would make far more sense, yes :)
02:36:32 <maverick_> Hmm I'm stuck with code, I need to achieve: http://lpaste.net/1688938018762653696 and that I have now is http://lpaste.net/4167146041319096320
02:36:51 <mangaba_leitosa> haasn: actually, what's the difference between ciw and cw?
02:36:55 <haasn> mangaba_leitosa: ‘cw’ in vi mode replaces everything until the end of the current word, I'd have to use bcw or whatever to replace the ‘current’ word
02:37:11 <haasn> oh, of course; ‘cw’ behaves the way it does in vim; too
02:37:17 <haasn> mangaba_leitosa: in vim, ‘ciw’ replaces the current (inner) word
02:37:25 <mangaba_leitosa> haasn: ah, got it
02:37:34 <haasn> So if you type, say, putStrLn and you have your cursor on ‘t’ and hit ciw, the entire putStrLn disappears
02:38:07 <haasn> there's also ‘caw’ to replace the current ‘outer’ word (including trailing whitespace, basically)
02:38:14 <mangaba_leitosa> haasn: I'm used to just cw at the beginning of putStrLn :-)
02:38:23 <haasn> and ciW and stuff to match on all non-whitespace symbols instead of just letters
02:38:33 <haasn> Very handy, it's my primary way of entering insert mode :)
02:41:01 <haasn> mangaba_leitosa: oh, neat, completionPaging: False -- I like to use my terminal to scroll
02:41:20 <mangaba_leitosa> haasn: :-)
02:41:35 <haasn> now I just have to figure out what MenuCompletion does
02:42:32 <mangaba_leitosa> haasn: it interates over all variants when you press tab repeatedly instead of showing the list
02:42:37 <mangaba_leitosa> iterates
02:42:50 <mangaba_leitosa> not my way :-)
02:43:30 <haasn> oh yes. Not my style either
02:44:13 <haasn> mangaba_leitosa: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings See ‘Sequence macros’ at the bottom :)
02:44:49 <mangaba_leitosa> haasn: yes, I saw this, but it's not what I want :-)
02:45:20 <mangaba_leitosa> haasn: btw, using this setting prevents you from being able to type ')' altogether :-)
02:45:33 <mangaba_leitosa> haasn: even if you want to do let c = ')' :-0
02:45:33 <haasn> I noticed :P
02:45:58 <haasn> I'll just keep ) ] } as what they are and use right arrow for it, I guess
02:46:21 <mangaba_leitosa> right
02:46:34 <haasn> maverick_: Is the broken formatting intentional? O.o
02:47:25 <maverick_> haasn: What do you mean by that?
02:47:40 <haasn> maverick_: lines 12 and 23 in your usage example
02:47:51 <haasn> Seems to me like a pretty-printer like that should make sure all the | line up :)
02:48:14 <maverick_> Ah yes, that's should be the case, it just got changed like that when I pasted it :)
02:48:30 <haasn> anyway, I would just split the input into lines (using ‘lines’), ignore the ones that start with +, and split the rest into fields using splitOn '|' -- or similar
02:48:32 <mauke> tabs
02:48:35 <maverick_> But I got a function that prints it in a good way now, so no worries :P
02:49:05 <maverick_> Well I have the function to pretty print the table already
02:49:13 <maverick_> So I only need a projection now
02:49:19 <haasn> Hmmm.. :: [Map k v] -> Map k [v] -- this seems doable
02:49:22 <maverick_> Like in that example too
02:50:36 <maverick_> So the parameters of that projection function are [Field] and a table, with [Field] the name of the columns that we have to project
02:51:05 <maverick_> If the column names don't exist in the input table I just have to do nothing
02:51:15 <haasn> What is your Table type?
02:51:26 <maverick_> type Field = String type Row   = [Field] type Table = [Row]
02:51:47 <FreeFull> jaspervdj: Since you say the websockets io-streams branch is better than the main branch, how about making it the main branch?
02:52:54 <haasn> maverick_: my first thought would be using something like fmap (Map.fromList . zip fields) to build a map, then mconcating the resulting maps together into a structure you can query effectively, but that might be overkill/not as efficient as possible :P
02:54:31 <haasn> oh, come to think of it, you need to traverse them row by row either way; so never mind whatever I just said
02:55:58 <maverick_> http://lpaste.net/4167146041319096320 is what I tried to do now
02:56:29 <fizruk> maverick_: are you trying to implement relational algebra in haskell?
02:57:11 <maverick_> Yup, Projection (π) part of it
02:58:41 <bennofs> Could netwire's Wire type be made into an ArrowApply? In fact, ocharles' stepWires function (https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs#L499) looks like it could be implemented with app and multicast
02:59:07 <haasn> maverick_: simplest way I think would be to store your rows as [(k,v)] and use something like ‘catMaybes . mapM lookup fields’ to filter out the fields you're interested in
02:59:10 <haasn> (simple and slow)
02:59:38 <fizruk> maverick_: you might probably be interested in this SO question http://stackoverflow.com/questions/9234205/safe-modelling-of-relational-data-in-haskell
03:00:47 <haasn> bennofs: ArrowApply is equivalent to Monad, right?
03:01:16 <haasn> bennofs: I somehow suspect that if Wire was capable of being a Monad we wouldn't have gotten umpteen blog posts by mm_freak about how great arrows are and how many non-monads you can model using them :)
03:07:03 <fizruk> maverick_: it looks like implementing safe relational algebra in haskell is not that simple (taking into account haskelldb implementation http://hackage.haskell.org/package/haskelldb)
03:08:22 <fizruk> maverick_: I at least recommend you to separate Table's metainfo (column names) from Table's contents (rows)
03:10:22 <KingsleyT> I'm just playing with the LYAHFGG quicksort algorithm on strings, and I'm getting interesting results when the input contains unusual characters
03:10:44 <mauke> sample input/output?
03:10:46 <haasn> “quicksort”
03:10:49 <KingsleyT> quicksort "abcdefÜ"   gives me   "abcdef\220"
03:11:04 <haasn> > 'Ü'
03:11:05 <lambdabot>   '\220'
03:11:05 <mauke> what does that have to do with quicksort?
03:11:23 <haasn> KingsleyT: the Show instance on Char is conservative
03:11:24 <danr> > putStrLn ['Ü']
03:11:25 <lambdabot>   <IO ()>
03:11:30 <danr> :(
03:11:36 <haasn> > doc "Ü"
03:11:37 <lambdabot>   Not in scope: `doc'
03:11:56 <haasn> > text "Ü"
03:11:57 <lambdabot>   Ü
03:12:02 <danr> yay
03:12:08 <mauke> > var "Ü"
03:12:09 <lambdabot>   Ü
03:12:10 <KingsleyT> show "abcdefÜ"  gives  "\"abcdef\\220\""  / :D
03:12:20 <mauke> KingsleyT: what did you expect?
03:12:30 <haasn> KingsleyT: yes, because the string itself gets ‘show’'n again when GHCi prints it to the screen :)
03:12:33 <KingsleyT> something that's not \220 I guess
03:12:38 <mauke> why not \220?
03:12:45 <KingsleyT> why not Ü?
03:12:49 <mauke> because it's not ascii
03:12:57 <KingsleyT> oh, it's working with ascii?
03:13:03 <mauke> and the Show instance for Char only uses ascii
03:13:08 <KingsleyT> I thought the chars/strings were unicode
03:13:12 <KingsleyT> through and through
03:13:13 <mauke> they are
03:14:11 <haasn> KingsleyT: again, because the Show instance on Char are conservative; since in the end we have no idea what kind of encodings peoples environments use
03:14:17 <haasn> Better to keep things simple and compatible
03:14:30 <KingsleyT> ..so they're stored as unicode, but they're shown as ascii?
03:14:35 * KingsleyT scratches head
03:15:15 <mauke> what
03:15:24 <mauke> 'show' is a library function
03:15:34 <KingsleyT> yeah, I know
03:15:38 <mauke> it serializes data to strings
03:15:51 <KingsleyT> but if a char in haskell is a unicode char and not an ascii char
03:15:56 <KingsleyT> by default
03:16:01 <haasn> a Char in haskell is neither a unicode char nor an ascii char
03:16:03 <mauke> not "by default", it just is
03:16:05 <haasn> It's a unicode code point
03:16:47 <blippeds> Here: http://stackoverflow.com/questions/10361579/are-unicode-and-ascii-characters-the-same
03:17:11 <blippeds> That might help explain the difference/overlap
03:17:33 <mauke> I doubt it
03:17:53 <blippeds> So pessimistic
03:18:11 <mauke> I just don't see how it's related to the problem
03:18:25 <blippeds> He seems confused first on what it means to be unicode and ascii
03:18:49 <KingsleyT> no, blippeds, I get it
03:19:01 <KingsleyT> its just that  the language just stores unicode code points and doesn't worry about how to display the code points that bothers me
03:19:03 <haasn> KingsleyT: “they're shown as ascii” this is also not true, they're just shown in a way that's essentially compatible with ASCII
03:19:19 <haasn> KingsleyT: the String that comes out of ‘show’ is still a list of unicode code points, and nothing will change that
03:19:23 <KingsleyT> in C# it defaulted to UTF-16 for display
03:19:30 <mauke> KingsleyT: that doesn't even make sense
03:19:45 <mauke> UTF-16 is an encoding
03:19:48 <haasn> KingsleyT: ‘show’ does not ‘display’ a string, it converts it to another String. Are you thinking about STDOUT/output?
03:20:22 <merijn> edwardk: Your cellular automata post on School of Haskell suggest implementing the comonad instances for Pretext, Bazaar and FunList yourself, I was wondering if there's a reference implementation online to check my own attempts against?
03:20:28 <KingsleyT> haasn: perhaps? :D
03:20:41 <merijn> edwardk: I saw lens has a Pretext/Bazaar but it's more complicated than the ones in the post
03:20:48 <haasn> merijn: lens exports and/or imports a few of these instances
03:21:00 <merijn> haasn: See my second remark ;)
03:21:06 <mauke> KingsleyT: putStrLn "Ü"
03:21:25 <haasn> KingsleyT: putStrLn :: String -> IO ()  -- this will display a string ‘natively’ to stdout, I think this uses the system encoding or something
03:22:04 <haasn> I'm not 100% sure what it does internally, but the observable net effect on my machine is that strings come out as UTF-8 (my system encoding) and my terminal decodes and renders it ‘correctly’. :)
03:22:12 <KingsleyT> I'm coming at it from this angle: in C/C++, chars were bytes, which were ascii encoded. You do any basic output/display work on them in the console, and it shows them in that encoding.
03:22:22 <mauke> I thought every Handle had its own encoding settings, defaulting to locale
03:22:22 <haasn> in C/C++, chars are not ascii encoded
03:22:35 <merijn> blippeds: In the future you might wanna links this instead to explain unicode to people :) http://www.joelonsoftware.com/articles/Unicode.html
03:22:35 <haasn> mauke: I don't know, I'd take your word for it over mine
03:22:50 <haasn> well, in C. I don't know about C++
03:23:04 <mauke> I'm pretty sure C++ doesn't require ascii either
03:23:06 <KingsleyT> in C# it was the same except chars were two bytes since it stored them as unicode and output accordingly
03:23:17 <mauke> KingsleyT: unicode doesn't fit in 16 bits
03:23:22 <mauke> it needs 21 bits
03:23:34 <haasn> mauke: what does Char do? 32 bits?
03:23:35 <FreeFull> > fromEnum (maxBound :: Char)
03:23:36 <lambdabot>   1114111
03:23:37 <KingsleyT> mauke: http://stackoverflow.com/questions/2134002/size-of-char-type-in-c-sharp
03:23:39 <merijn> KingsleyT: Read this first: http://www.joelonsoftware.com/articles/Unicode.html
03:23:42 <haasn> mauke: in GHC, I mean
03:23:43 <mauke> also, a C "byte" isn't necessarily 8 bits
03:23:57 <mauke> haasn: see ^ FreeFull
03:23:58 <FreeFull> haasn: It goes up to 1114111 and stops there
03:24:00 <KingsleyT> (perhaps I have glossed over the details of 'encoding' since I've never really needed to know :V)
03:24:07 <KingsleyT> merjin: thanks, reading
03:24:09 <merijn> haasn: In GHC I believe it's either 32bit or a machine word?
03:24:22 <haasn> > logBase 2 1114111
03:24:23 <lambdabot>   20.087461546321563
03:24:25 <mauke> KingsleyT: why are you linking me to that?
03:25:10 <theorbtwo> mauke: In theory.  In practice, if you find a working computer that does not have 8 bit bytes, please notify the museum of computing.
03:25:19 <KingsleyT> mauke: top answer says "A char is unicode in C#, therefore the number of possible characters exceeds 255. So you'll need two bytes."
03:25:39 <KingsleyT> mauke: KingsleyT: unicode doesn't fit in 16 bits
03:25:40 <mauke> KingsleyT: top comment on that answer says "With Unicode being a 21-bit code it's a bit of a stretch to say that that's why you need two bytes."
03:25:54 <theorbtwo> KingsleyT: That is very bad advice, since a unicode character can go up to U+10FFFF.
03:26:03 <theorbtwo> > logBase 2 0x10FFFF
03:26:04 <lambdabot>   20.087461546321563
03:26:43 <KingsleyT> the 2 byte char size seems interesting in that light :|
03:26:59 <mauke> s/interesting/stupid/
03:27:06 <mauke> it's java's mistakes all over again
03:27:30 <theorbtwo> Sadly, windows and java standardized on unicode meaning 16 bits just before it became blindingly clear that 16 bits wouldn't do.
03:27:39 <haasn> Microsoft in charge of encoding
03:27:39 <KingsleyT> oh boy
03:27:50 <Fuuzetsu> Microsoft in charge
03:27:52 <mauke> hah, MS also thinks "ANSI" is an encoding
03:27:57 <KingsleyT> well that clears up one misconception / :D
03:29:59 <haasn> merijn: sizeOf 'a' => 4
03:30:09 <haasn> Not sure if that answers anything. :)
03:30:42 <haasn> Do Storable instances have anything to do with how GHC actually stores that value? As far as I can tell they might as well just define an external ‘serialization to memory’ interface
03:30:43 <Maxdamantus> Doesn't "ANSI" refer to some union between ISO/IEC-8859-1 and CP-1251 or whatever it is?
03:31:39 <donri> ANSI is a standards body like IETF or ECMA
03:31:42 <mauke> Maxdamantus: no, ANSI is the american national standards institute
03:31:57 <mauke> (also, the "ANSI encoding" is not approved by ANSI)
03:32:01 <haasn> I think he meant Microsoft's definition of "ANSI"
03:32:02 <Maxdamantus> Yes, but sometimes they use it as a shorthand for some standard.
03:32:07 <mauke> it's not a standard
03:32:15 <Maxdamantus> like how "ISO" often refers to ISO 9660 images.
03:33:00 <donri> WP:ASCII "Not to be confused with MS Windows-1252, also known as "ANSI", or other types of Extended ASCII, often just called "ASCII"."
03:33:01 <theorbtwo> Maxdamantus: Very much like that, since it also refers to images of non-compliant copy-protected media, and even games that are deliberately rather far from iso-anything.
03:33:19 <KingsleyT> http://stackoverflow.com/questions/3611656/haskell-io-with-non-english-characters
03:33:22 <KingsleyT> :U
03:33:42 <theorbtwo> Yeah.  If it includes characters above 127, it's not ascii.
03:34:04 <donri> KingsleyT: don't use "show" for that
03:34:24 <Maxdamantus> The first 255 unicode codes come from ASCII, ISO/IEC-8859-1 and I think some MS codepage.
03:34:38 <KingsleyT> I'm starting to get that, yeah
03:34:40 <haasn> (ASCII doesn't have 255 characters)
03:34:46 <haasn> Oh
03:34:48 <haasn> My bad
03:34:49 <KingsleyT> seems like a misconception over what show is actually used for
03:34:50 <haasn> I misread your statement
03:34:51 <theorbtwo> Maxdamantus: They come from iso latin 1, directly.
03:35:05 <Maxdamantus> theorbtwo: and something else.
03:35:12 <Maxdamantus> theorbtwo: Latin 1 doesn't define all 255 codes.
03:36:08 <mauke> Maxdamantus: show me
03:36:20 <KingsleyT> hoogle says it's to "Convert a value to a readable String."
03:36:20 <haasn> Oh, UTF-16 is variable length? Makes sense now
03:36:37 <KingsleyT> but it seems more like a convenience than a be-all tool
03:36:37 <haasn> KingsleyT: Yes that makes sense
03:36:46 <haasn> KingsleyT: It's true that it's a convenience
03:37:06 <theorbtwo> Maxdamantus: Neither does unicode.
03:37:10 <haasn> KingsleyT: One common pattern is that Show will produce “valid Haskell code” to construct your value, but this isn't universal
03:37:43 <mauke> 😼
03:37:45 <tiffany> utf-16 is variable length but a lot of windows software assumes that it isn't, such as command prompt (I think)
03:37:47 <haasn> KingsleyT: hence ‘show’ on String using valid Haskell escape sequences and stuff, to construct something you could just use a string literal
03:37:51 <Maxdamantus> Mm .. my UnicodeData file has 0x80 etc as defined control characters.
03:37:59 <Maxdamantus> not letters though, apparently.
03:39:00 <haasn> > "foo\"barÜ"
03:39:01 <lambdabot>   "foo\"bar\220"
03:39:05 <haasn> > "foo\"barÜ" == "foo\"bar\220"
03:39:06 <lambdabot>   True
03:39:06 <theorbtwo> utf-16 is variable-length, ucs-2 isn't.
03:39:21 <Maxdamantus> Yeah, right. That's the CP-1252 bit.
03:40:05 <mauke> unicode is a superset of latin-1 is a superset of ascii
03:40:39 <mauke> unicode ⊂ latin-1 ⊂ ascii  -- yay, unicode
03:40:55 <Maxdamantus> Other way around.
03:41:02 <KingsleyT> haasn: alright, I think I see
03:41:12 <mauke> I have failed :-(
03:42:03 * mauke commits sashimi
03:42:22 <haasn> KingsleyT: if I were to define the purpose of Show, it would be “to have GHCi use it to display values”
03:42:30 <KingsleyT> so the idea is it will output text that will work with anything, functionally
03:42:38 <KingsleyT> even if it doesn't look pretty
03:42:40 <haasn> the idea is to represent data structures
03:42:47 <haasn> as strings
03:42:51 <KingsleyT> alright
03:43:08 <KingsleyT> I was thinking it was more akin to... printf, I guess
03:43:19 <Iceland_jack> KingsleyT: You probably mean sprintf
03:43:24 <KingsleyT> pretty printing
03:43:30 <Iceland_jack> printf doesn't do pretty printing?
03:43:33 <haasn> No, not really :) It isn't even related to printing
03:43:41 <mauke> > length "Üß€ツಠ"
03:43:42 <lambdabot>   5
03:43:45 <KingsleyT> Iceland_jack: thus my hesitation :V
03:43:48 <Iceland_jack> printf does formatting if that's what you mean
03:43:55 <KingsleyT> aye
03:44:09 <haasn> KingsleyT: we have actual printf-like things, if you're interested in that
03:44:12 <Iceland_jack> Well you can do what you want with sprintf with show and (++)
03:44:19 <Iceland_jack> but you can also use Text.Printf.printf
03:44:20 <haasn> But they're not very widely used at least to my knowledge
03:44:39 * Maxdamantus was fixing UTF-16 support for FAT in Rockbox a while ago (it normally only supports UCS-2), but then noticed Linux's VFAT also only handles UCS-2. -_-
03:44:40 <KingsleyT> haasn: that'd be interesting, yeah
03:45:30 * Maxdamantus just changed it to store/read UTF-8 sequences in the 16-bit strings, which match's Linux's VFAT's default behaviour.
03:45:31 <Iceland_jack> > printf "Hello, %s: I'm %d years old!" "#haskell" 4 :: String
03:45:33 <lambdabot>   "Hello, #haskell: I'm 4 years old!"
03:45:41 <mauke> > length "🐵😣🕑"
03:45:42 <lambdabot>   3
03:45:48 <haasn> KingsleyT: well there's one http://hackage.haskell.org/package/printf-mauke-0.5.2/docs/Text-Printf-Mauke.html which acts like the C ‘printf’ but it doesn't do static type checking or anything of that sort, and you might have to help the type system figure out the number of parameters
03:46:03 <mauke> haasn: the TH version does static types
03:46:08 <haasn> Oh yes, I forgot to mention that
03:46:15 <Iceland_jack> > "Hello, " ++ "#haskell" ++ ": I'm " ++ show 4 ++ " years old!"
03:46:16 <lambdabot>   "Hello, #haskell: I'm 4 years old!"
03:46:23 <haasn> However, there are higher level ways of formatting data in printf-like ways; hang on
03:46:24 <Iceland_jack> KingsleyT: Note that the latter version uses "show"
03:47:05 <Maxdamantus> :t printf "Hello, %s: I'm %d years old!" "#haskell" 4
03:47:06 <lambdabot> (Num a, PrintfType (a -> t)) => t
03:47:16 <Iceland_jack> Maxdamantus: Don't scare them!
03:48:00 <Iceland_jack> But of course the type is wrong:
03:48:00 <Iceland_jack> :t printf "hi %d" :: String
03:48:01 <lambdabot> String
03:48:02 <haasn> KingsleyT: this is one I stumbled upon a while ago: http://hackage.haskell.org/package/xformat-0.1.1/docs/Text-XFormat-Show.html
03:48:05 <simukis_> Is there any faster alternative to read in https://gist.github.com/anonymous/e1808cb11bdd843a6766 which doesn't use obscure packages – only things you'd get from base haskell install, preferably?
03:48:20 <haasn> But it's not exactly highly-documented and the classes will be confusing if you're a newcomer :)
03:48:37 <KingsleyT> haha, alright
03:48:41 <t4nk215> Hello. I have a task to write a multithreaded programm, using Haskell. The task is simple, but i never worked with threads in Haskell. Can you advice some books, or, better, repos? Also, i have basic knowladge up to monads, but nothing more.
03:48:43 <KingsleyT> nice to know they're there though, thanks :)
03:48:56 <mauke> t4nk215: do you understand IO?
03:48:58 <Iceland_jack> t4nk215: Simon Marlow's book!
03:48:59 * KingsleyT will keep em around
03:49:02 <t4nk215> mauke: yes
03:49:21 <Iceland_jack> t4nk215: http://chimera.labs.oreilly.com/books/1230000000929/index.html ← You're in luck
03:49:28 <Iceland_jack> Fantastic book, tell a friend
03:49:33 <mauke> t4nk215: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html
03:49:34 <Iceland_jack> etc
03:49:45 <t4nk215> Iceland_jack: thanks a lot, i ll check it
03:49:53 <mauke> > printf "hi %d" :: String
03:49:54 <lambdabot>   "hi *Exception: Printf.printf: argument list ended prematurely
03:49:56 <haasn> KingsleyT: example usage could be showf ("[" :%: Align R 8 Num :%: "]") 2   which evaluates to "[       2]"
03:50:08 <mauke> haasn: ew
03:50:23 <Iceland_jack> t4nk215: To launch a thread that runs an action continuously you simply write: forkIO (forever action)
03:50:26 <Iceland_jack> that's all
03:50:36 <Iceland_jack> forkIO returns its thread ID, couldn't be simpler
03:50:48 <t4nk215> Iceland_jack: well, i have to communicate between threads
03:50:50 <mauke> haasn: I'd rather use printf "[%8d]" than that abomination
03:50:51 <mr-> t4nk215: http://hackage.haskell.org/package/async may be interesting for you
03:50:56 <Iceland_jack> t4nk215: It's all explained in the book
03:51:02 <haasn> t4nk215: channels, vars, STM, etc. just look at the book :)
03:51:06 <mauke> t4nk215: checkout MVar or STM then
03:51:14 <Iceland_jack> But you use MVars, STM, ... for that
03:51:15 <t4nk215> Iceland_jack: ok, thanks again, going read it =)
03:51:30 <haasn> mauke: to each his own :)
03:51:37 <Iceland_jack> depending on your needs, if you have any questions feel free to ask
03:51:40 <mauke> http://mauke.hopto.org/stuff/haskell/stress.hs <- threads!
03:51:56 <haasn> mauke: I haven't really planned on using it either, but it's a neat proof of concept for type-safe printf-like stuff without TH
03:52:05 <mauke> haasn: it's not printf-like
03:52:24 <haasn> printf-like in that you provide it with a format descriptor and the required number of parameters
03:52:28 <mauke> the essence if printf is its compact formatting DSL
03:52:30 <haasn> and it assembles a string from that
03:52:34 <mauke> s/if/of/
03:52:46 * Iceland_jack is reminded of their FORMAT days in CL
03:52:48 * Iceland_jack shudders
03:52:58 <mauke> if you need stuff like :%: Align R 8 Num :%: it's no longer printf
03:53:12 <haasn> hence printf-like
03:53:17 <mauke> -like
03:54:04 <haasn> What would you call it then? String formatting?
03:54:19 <mauke> an abomination! \o/
03:54:24 <haasn> hehe
03:54:59 <haasn> mauke: how about a wrapper that used TH to generate an ‘xformat’ format descriptor? :)
03:55:11 <haasn> I guess that would be the same net result as Text.Printf.Mauke.TH
03:55:12 <mauke> I mean, at that point, why not write "[" ++ padRight 8 (show 2) ++ "]"?
03:55:23 <mauke> except I guess it's padLeft
03:55:24 <haasn> But you could combine it with other format descriptors, too
03:55:50 <haasn> mauke: yeah good point
03:56:54 <mauke> mostly unrelated but I often use printf "%vd\n" for debugging encoding problems in perl
03:57:35 <tiffany> I've always liked format functions more than string concatenation, you only need to look in one place (the format string) to know what the output will look like
03:57:58 <Iceland_jack> I agree with that, as long as the format string isn't too gnarly
03:57:59 <tiffany> with concatenation it's easier to forget spaces, as well
03:58:12 <haasn> tiffany: with xformat's format descriptor it is, too
04:02:17 <haasn> mauke: XFormat's approach is also extendable, I can provide my own format descriptors in an ad-hoc way; even (:%:) has no special treatment by ‘showf’
04:03:44 <haasn> mangaba_leitosa: I've gotten rid of the bind ( stuff, it's too annoying inside string literals :)
04:09:40 <SrPx> does anyone know the name of this? -> http://cstheory.stackexchange.com/questions/19179/is-there-an-array-structure-that-allows-for-o1-complexity-for-reverse-zip-sl
04:10:51 <haasn> I know it in the form of ‘Store’
04:10:59 <haasn> But not specifically to store arrays
04:11:07 <SrPx> Store?
04:11:45 <haasn> http://hackage.haskell.org/package/comonad-transformers-3.1/docs/Control-Comonad-Trans-Store.html
04:12:55 <haasn> It also doesn't really offer any functions in the form of ‘slice’ etc.
04:14:18 <mangaba_leitosa> haasn: sure :-)
04:14:26 <jaspervdj> FreeFull: I should polish it up a bit more, add some documentation and some tests. Then release it as 1.0
04:14:48 <haasn> Oh, on second thought, that's not really the same thing at all
04:15:02 <SrPx> hmm .!
04:15:05 <jaspervdj> FreeFull: but I moved to zurich two weeks ago for a new job so I've been kind of busy
04:15:06 <mangaba_leitosa> haasn: so, if I implement a 'set blink-matching-paren on' for haskeline, I need to consider '(' and "(" when matching parents :-)
04:15:15 <mangaba_leitosa> parens
04:15:31 <haasn> mangaba_leitosa: the easiest way out would be to just ignore anything inside a string/char literal
04:15:52 <mangaba_leitosa> haasn: right...
04:15:53 <haasn> Though it might be cool to track those separately, ie. blink all matching parens inside literals :)
04:16:13 <haasn> (I guess char and string literals should be treated as equals, eg. '(' : show x ++ ")")
04:16:17 <mangaba_leitosa> haasn: yes, readline does thiss
04:16:27 <mangaba_leitosa> haasn: (blink all matching parens inside literals)
04:17:02 <mangaba_leitosa> haasn: it has difficulties with J language code, though
04:17:08 <mangaba_leitosa> haasn: where [ and ] are functions
04:17:17 <haasn> mangaba_leitosa: thinks also get more complicated when considering template haskell quasiquoters
04:17:19 <haasn> things*
04:17:43 <mangaba_leitosa> haasn: right...
04:22:52 <SrPx> nobody has an idea what that was?
04:25:35 <FreeFull> jaspervdj: I see, I don't mind waiting a bit longer for 1.0 to come out
04:27:54 <mangaba_leitosa> hmm, installed hoogle, typed hoogle data and got http://hackage.haskell.org/packages/archive/00-hoogle.tar.gz ERROR 404: Not Found
04:28:12 <mangaba_leitosa> the hoogle-4.2.21.conf config file does not seem to have this URL
04:28:51 <FreeFull> Possibly related to the recent hackage 2.0 switchover
04:29:50 <haasn> Speaking of which, I really want hayoo to work again :(
04:29:57 <haasn> Hoogle indexes way too conservatively
04:30:35 <merijn> haasn: Word.
04:30:53 <merijn> haasn: You can install a local hoogle indexing more, if you have a metric asston of RAM
04:31:02 <mangaba_leitosa> FreeFull: the correct URL seems to be http://hackage.haskell.org/packages/index.tar.gz but I cannot find the place where I can replace http://hackage.haskell.org/packages/archive/00-hoogle.tar.gz with that
04:31:11 <merijn> haasn: (The merge operation fails on my machine with a mere 4GB)
04:34:49 <mangaba_leitosa> FreeFull: aha, the URL is hardcoded in the /usr/bin/hoogle binary. neat!
04:37:37 <FreeFull> mangaba_leitosa: You'll probably have to wait until a new version of hoogle comes out
04:37:43 <FreeFull> Or fix it yourself
04:38:38 <mangaba_leitosa> FreeFull: I see
04:47:13 <maverick_> How should I create a function project that does something like http://lpaste.net/2316470755463790592? I asked it before, but this example is more clear of what has to be done. I made a function that gives the indices of the column names, but I don't know what to do next
04:48:52 <ClaudiusMaximus> SrPx: reminds me of http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa-Repr-Delayed.html
04:49:37 <nooodl> maverick_: something like [[row !! i | i <- indices] | row <- rows] ?
04:49:58 <nooodl> (where `rows` is the whole thing you pass it)
05:51:31 <mangaba_leitosa> FreeFull: eventually, I managed to provisionally patch the gentoo ebuild for hoogle (make it use old.hackage.haskell.org)
05:56:48 <gienah> mangaba_leitosa: local hoogle db info is here: http://wiki.gentoo.org/wiki/Haskell#Hoogle_with_local_installation
05:57:26 <gienah> mangaba_leitosa: it may not work at the moment though due to the hackage 2 issue you mentioned earlier
05:57:40 <mangaba_leitosa> gienah: thanks
05:58:01 <gienah> mangaba_leitosa: because even with the localdb, it wants to download stuff as well
05:58:11 <gienah> initially, after that is uses the localdb
06:03:50 <mangaba_leitosa> gienah: I think I will limit myself to hoogle database of locally installed packages for now and will wait a new version of hoogle
06:05:40 <mangaba_leitosa> gienah: hmm... no, it doesn't seem to work this way... I just re-emerged data-lens with USE=hoogle, but hoogle makeLenses fails
06:06:29 <mangaba_leitosa> gienah: ah, no, online hoogle fails for this one, too
06:10:20 <gienah> mangaba_leitosa: to update the local hoogle db requires running /usr/sbin/hoogle-build-localdb # it takes a while so it is not run after each emerge of haskell pkgs, it needs to be run manually
06:11:06 <mangaba_leitosa> gienah: ah, I see. I assumes USE=hoogle is meant to do exactly this
06:11:12 <mangaba_leitosa> "assumed"
06:11:15 <mangaba_leitosa> gienah: thanks
06:11:17 <gienah> mangaba_leitosa: you can chat to us in #gentoo-haskell
06:27:07 <Augmental> I've made it, the Haskell IRC channel!
06:27:14 <Augmental> Welp, thats one ticked off the Bucket list.
06:51:52 <edwardk> mangaba_leitosa data-lens /= lens
06:53:00 <mangaba_leitosa> edwardk: yes, I know. I tried lens first, and if failed to work with my type due to unknown bug, then I tried data-lens
06:53:47 <mangaba_leitosa> edwardk: and it worked :-)
06:54:51 <mangaba_leitosa> edwardk: I mean, makeLenses from 'lens' had failed (on a type that case constructors without field labels)
06:55:07 <mangaba_leitosa> "that has constructors"
06:57:57 <paolino> What is the standard structure for undo/redo in GUIs ? Data.List.Zipper ?
07:00:49 <paolino> (supposing there is state)
07:01:46 <edwardk> mangaba_leitosa: i think there was a bug reported the other day, was that you?
07:01:57 <edwardk> i'll happily fix it. i just need to get free of the conference long enough to do so
07:02:47 <mangaba_leitosa> edwardk: yes
07:03:03 <mangaba_leitosa> edwardk: but the bug was reported about lens, not data-lens
07:03:21 <mangaba_leitosa> edwardk: I though you are the author of the latter, or you contribute to both?
07:03:51 <mee> paolino: this might be a useful reference https://github.com/yi-editor/yi/blob/master/yi/src/library/Yi/Buffer/Undo.hs
07:04:52 <donri> mee: linear eh? :(
07:04:58 <donri> paolino: how about a tree
07:05:04 <mee> looks that way
07:05:30 <paolino> donri, how should it work to select the branch ?
07:05:33 <mangaba_leitosa> edwardk: I, you are the author of the former. sorry :-)
07:06:12 <paolino> I always have seen Ctrl-z and Ctrl-y
07:06:41 <donri> paolino: either by displaying the history as a tree, or by traversing it linearly, maybe also with an option to not traverse branches at all (perhaps as the default undo mechanism)
07:07:15 <donri> paolino: but in any case it is useful to keep undo branches
07:07:58 <paolino> mh, then I need a Tree zipper
07:08:09 <edwardk> mangaba_leitosa: i wrote data-lens and i wrote lens
07:08:12 <donri> paolino: lens' zippers are traversal-generic
07:08:39 <paolino> lens zipper ?
07:08:44 <donri> @hackage lens
07:08:44 <lambdabot> http://hackage.haskell.org/package/lens
07:09:05 <mangaba_leitosa> edwardk: oh, I see. And what is the purpose of maintaining two different libraries?
07:09:29 <donri> mangaba_leitosa: ed doesn't maintain data-lens anymore though
07:09:43 <mangaba_leitosa> ah
07:10:30 <mangaba_leitosa> anyway, why two different incompatible(?) libraries?
07:12:09 <donri> mangaba_leitosa: because the genius of van laarhoven's lenses was lost on people for some time :)
07:12:35 <donri> and changing data-lens would be more or less completely backwards incompatible anyway
07:15:03 <edwardk> mangaba_leitosa: i handed off maintainership of data-lens to roconnor.
07:15:30 <edwardk> donri: lens started as a smaller library focused on exploiting the benefits of a new lens representation
07:15:50 <edwardk> i started objecting to what was happening in data-lens as i find myself singularly unable to reason about "monadic lenses"
07:15:56 <edwardk> nobody can tell me the laws for them
07:16:03 <mangaba_leitosa> edwardk: so, lens is like improved data-lens?
07:16:16 <donri> first he handed data-lens to roconnor, then roconnor made a library for van laarhoven lenses, then ed made his own ;)
07:16:21 <edwardk> so lens was put together to explore all the alternative generalizations. it turned to have a much larger 'top end'
07:16:39 <edwardk> mangaba_leitosa: yes. i consider data-lens to basically exist solely for legacy code at this point
07:17:23 <mangaba_leitosa> edwardk: I see. Then it makes sense for me to switch from data-lens to lens when the bug is fixed, if I don't know too much about either of them yet anyway?
07:18:06 <donri> yes. everything is better about "lens" :)
07:18:24 <edwardk> mangaba_leitosa: definitely.
07:18:29 <donri> except maybe grokkability
07:19:04 <edwardk> data-lens provides some basic lenses. lens provides lenses, isomorphisms, getters, setters, folds, traversals, prisms, equalities, indexed versions of these things that all compose together with Prelude's (.)
07:19:08 <donri> in the sense that it's easier to grok concrete/monomorphic types
07:19:26 <edwardk> and which also support type-changing update
07:20:23 <mangaba_leitosa> edwardk: aha, thanks. once thing that confused me about lens (besided the bug I found) is that for a type with more than one, constructor it's 'view' method won't work, so I have to use 'preview' which will wrap the value into Maybe. Is there still some way to avoid Maybe and just generate exception when getter is given a constructor that does not have the required field?
07:20:51 <donri> :t (^?!)
07:20:52 <lambdabot> s -> Getting (Endo a) s a -> a
07:20:54 <edwardk> mangaba_leitosa: view works for types with more than one constructor… if the field is in all of the constructors!
07:21:04 <edwardk> mangaba_leitosa: if it isn't what should i give you if you match on the wrong one?
07:21:15 <Athan> Can someone help me install haddock?
07:21:19 <Athan> I'm getting mad errors
07:21:23 <donri> > Nothing ^?! _Just
07:21:24 <lambdabot>   *Exception: (^?!): empty Fold
07:21:32 <Athan> Main.main not exported
07:21:34 <edwardk> mangaba_leitosa: you can assert you know it is there with the much more scary looking    foo^?!someFieldIReallyKnowIsThere
07:21:54 <edwardk> and you can safely ask if its there giving you a Maybe a      using foo^?someFieldThatMightBeThere
07:22:07 <edwardk> data-lens will just lie and give you the lens that crashes on you
07:22:40 <mangaba_leitosa> edwardk: basically, data-lens will provide a getter identical to the standard getter generated by Haskell
07:23:02 <donri> yeah, record notation encourages partial accessors :/
07:23:06 <mangaba_leitosa> edwardk: that will crash on failed pattern match if the wrong constructor is passed. And it's OK in some cases
07:23:41 <donri> mangaba_leitosa: anyway, ^?! is basically fromJust . preview
07:23:48 <edwardk> mangaba_leitosa: while lens wil give you something mor principled that you can still set, but that to read you should use 'preview' or (^?) or you can still lie by using (^?!)
07:24:33 <donri> so it does what you want here, plus works for every other type of getter
07:24:35 <mangaba_leitosa> edwardk: will try it now....
07:25:44 <donri> > [a,b,c] ^?! folded
07:25:45 <lambdabot>   a
07:27:44 <edwardk> basically when you want the evil partial behavior (^?!) always works for everything and gives you the partial lens behavior. that way the lens package never has to supply a crash-prone partial lens and the user can always blame himself for using (^?!) and not checking when it blows up =P
07:28:02 <edwardk> rather than blame the lens library for not supplying a traversal he could check instead
07:28:27 <mangaba_leitosa> edwardk, donri: aha, so ^?! does what I wanted, thanks!
07:28:46 <donri> mangaba_leitosa: for anything you can fold! :)
07:28:55 <edwardk> the name is deliberatelu chosen to make you stop and go wtf^?!
07:29:03 <mangaba_leitosa> :-)
07:29:21 <donri> edwardk: any reason there's no unsafeView or unsafePreview or whatever?
07:29:57 <edwardk> you can always use singular
07:30:02 <edwardk> view (singular ...)
07:30:05 <mangaba_leitosa> donri, edwardk: and what's the unsafe version of 'set', which would also crash on wrong constructor?
07:30:10 <donri> aha
07:30:15 <edwardk> singular is the traversal -> lens converter that does the same thing as (^!?)
07:30:21 <edwardk> mangaba_leitosa: 'failover'
07:30:25 <donri> not scary enough name though ;)
07:31:09 <mangaba_leitosa> edwardk: aha thanks
07:32:25 <edwardk> :t singular
07:32:29 <edwardk> :t unsafeSingular
07:32:36 <edwardk> :t Control.Lens.unsafeSingular
07:32:37 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a b) s t a b -> Over p f s t a b
07:37:37 <applicat1ve> Its strange that the vector library doesn't export 'uncons'
07:41:35 <int-e> all this s t a b bing makes me sad.
07:42:16 * geekosaur hands int-e a p a b s t
07:42:37 <Athan> Anyone here know yesod's templating?
07:45:36 <applicat1ve> Athan: my impression is detailed yesod questions have better luck on stack overflow or maybe #yesod
07:49:18 <mgsloan> Athan: I can possibly help in #yesod
07:49:56 <deech> Hi all, what's the best way of binding functions with void pointer in C? I can use `Ptr ()` but I'd like ot use a concrete type if possible.
07:52:49 <donri> deech: should work fine to just make an empty data type
07:53:10 <donri> or use the existing Void type in the void package
07:53:54 <donri> hm although perhaps don't do the latter :p
07:55:12 <applicat1ve> i was going to say, 'somehow i think you dont want Ptr Void' ...
07:55:16 <applicat1ve> ha
07:56:23 <donri> yeah, Void is meant for truly uninhabited types (as always, ignoring bottom) whereas empty data decls with the ffi is meant for things you can only construct via the ffi
07:56:54 <deech> donri, applicat1ve: Ah, thanks!
07:57:31 <applicat1ve> newtype VoidPtr = VoidPtr (Ptr VoidPtr)
07:57:54 <deech> applicat1ve: Why is that preferable over just Ptr ()?
07:58:07 <donri> or just data Void; foreign import ... -> Ptr Void
07:58:16 <chrisdone> “I'd like ot use a concrete type if possible.”
07:58:19 <applicat1ve> deech: it isn't I'm just modifying Void from the void package
07:58:29 <applicat1ve> () is a concrete type
07:58:36 <applicat1ve> that was the trouble at the outset deech
07:59:03 <chrisdone> in #haskell even answers are lazy
07:59:04 <donri> the void package wants to be haskell98, but empty data decls is haskell2010 and you're using the ffi anyway (also haskell2010)
07:59:46 <applicat1ve> chrisdone: the questions can be a little underdeveloped too
08:00:02 <applicat1ve> dear #haskell, _|_?
08:00:03 <sarfraz> hello, does anyone know about hxt and xml? i need help with the following : http://stackoverflow.com/questions/19066603/how-do-you-map-over-a-hxttree
08:00:37 <deech> applicat1ve: My question was underdeveloped it's because I'm new at this. Thanks for the taking the time.
08:01:01 <applicat1ve> deech: I wasnt objecting at all
08:01:24 <donri> sarfraz: easiest to use arrow syntax for this
08:02:16 <applicat1ve> deech: i was just making a silly response to chrisdone 's remark earlier.
08:02:28 <sarfraz> yeah I tried looking for an arrows that allowed me to iterate but did not found any
08:02:42 <sarfraz> iterate on the tree
08:03:43 <donri> sarfraz: not sure what you mean by iterate on the tree
08:03:46 <deech> applicat1ve: Thanks!
08:04:49 <donri> sarfraz: but basically, >>> proc recipient -> do name' <- getTheNameText -< recipient; ...; returnA -< Recipient { name = name', ... }
08:05:12 <donri> throw in RecordWildCards if you want to be silly
08:06:26 <sarfraz> ohh that seems cool will try that
08:07:06 * applicat1ve didn't know donri was an *arrow syntax user*
08:07:07 <donri> and to get the Maybes, try this: getMaybe a = (Just ^<< a) `orElse` constA Nothing
08:07:09 <sarfraz> by iterate I only mean to aply my function to each node of the tree
08:07:30 <donri> applicat1ve: "one of *those* people"
08:08:51 <donri> sarfraz: hxt does that for you
08:08:54 <donri> it's a list arrow
08:08:56 <lamefun> Why isn't "do" called "chain" and "return" called "wrap"?
08:09:26 <FreeFull> Why would they be called that?
08:09:46 <donri> why would they be called do and return ;)
08:09:56 <FreeFull> Let's call them squiggle and borog
08:10:38 <lamefun> because do doesn't cause anything to be done and return doesn't return from do
08:11:53 <sarfraz> do and return do sound more imperative
08:12:23 <donri> "return" isn't *that* wrong, it's just unfortunate because of usage in other languages
08:29:31 <haasn> ‘return’ should be ‘pure’
08:29:36 <haasn> ‘do’ is short enough :)
08:29:52 <avizit> I need some help with conduits. I have a file which contains series of integers , and the source has to send downstream a list of integers , the length of which would be given in the very first byte of the file. I have code at http://lpaste.net/93555  but I seem to be unable to read the file and do what i want
08:32:30 <elliott> return > pure
08:32:41 <hpc> > "return" > "pure"
08:32:42 <lambdabot>   True
08:32:49 <avizit> Conduit
08:34:38 <Clint> avizit: you could just read one value and then invoke your conduit-sink using that
08:36:23 <jophish> Yo yo yo
08:36:43 <jophish> Is it possible to have vim run GHCReload automatically?
08:36:59 <jophish> I find myself running it lots manually
08:37:16 <mangaba_leitosa> @pl f x y = x + y
08:37:16 <lambdabot> f = (+)
08:37:30 <mangaba_leitosa> @pl f x = if x == 0 then 0 else 1
08:37:33 <danr> jophish: you can make an autocmd on BufWrite to run GHCReload
08:37:34 <lambdabot> f = flip (flip if' 0 . (== 0)) 1
08:37:34 <lambdabot> optimization suspended, use @pl-resume to continue.
08:37:37 <danr> for instance
08:37:41 <mangaba_leitosa> what if if' ?
08:37:46 <mangaba_leitosa> where it comes from?
08:38:02 <jophish> danr I'm not too experienced with vim, vould it be possible for you to share a .vimrc?
08:38:20 <geekosaur> mangaba_leitosa, it doesn't, it's a bit of a hack used by @pl
08:38:33 <geekosaur> if' p t f = if p then t else f
08:39:05 <avizit> Thanks Clint , can i do that within the source function ( which is Source IO L.ByteString )
08:39:23 <mangaba_leitosa> geekosaur: ah, thanks. I though that maybe there a was a module with such a definition, because the 'pointfree' tool also generates if'
08:39:37 <Clint> avizit: you don't want to
08:39:43 <geekosaur> no, I don't think there's a standard one
08:40:45 <mangaba_leitosa> @pl f x = case x of 0 -> 0
08:40:46 <lambdabot> (line 1, column 21):
08:40:46 <lambdabot> unexpected '>'
08:40:46 <lambdabot> expecting operator
08:41:36 <geekosaur> hasn't been updated to know about lambdacase
08:41:45 <geekosaur> (which requires an extension anyway)
08:42:26 <mangaba_leitosa> I see
09:13:25 <jophish> I'm using haskellmode-vim, Is there a way to get it to keep up with the source for autocompletion?
09:13:35 <jophish> without having to write the file
09:26:33 <qwebirc16477> hey i have a design question: I have an adt: data MyADT = AA | BB | CC  and I want to delegate to different modules depending on that ADT
09:27:07 <qwebirc16477> fn myadt = do    case myadt of       AA -> A.dosomething myadt       BB -> B.dosomething myadt       ...
09:27:46 <qwebirc16477> in A I have to write something like dosomething AA = ...      then dosomething _= error
09:28:28 <qwebirc16477> is there anyway to promote MyADT values to real types?
09:30:28 <fizruk> qwebirc16477: not sure what you are trying to achieve, could you please hpaste current implementation that you want to impove?
09:34:10 <qwebirc16477> http://lpaste.net/93559
09:35:42 <qwebirc16477> how do i make this more sturdy: at the moment i could pass BB to A.dosomething? any ideas?
09:36:42 <shiona> I assume AA, BB and CC carry some information, right?
09:36:53 <fizruk> qwebirc16477: first thought is to use GADT
09:36:54 <qwebirc16477> yes they can
09:38:48 <qwebirc16477> would i still be able to do a 'case of' on the gadt but also treat as a unique type in the submodule A/B etc? i sort of want the best of both worlds
09:40:39 <fizruk> qwebirc16477: something like http://lpaste.net/93559 (annotated)
09:40:56 <fizruk> qwebirc16477: I haven't checked the code with GHC though
09:41:48 <fizruk> qwebirc16477: note that "error" cases eliminated because you cannot construct a valid (MyGADT AType) with other constructor than AA
09:43:22 <qwebirc16477> that makes sense.  thanks, i'll give that a try
09:45:41 <kqr> is there any particular reason @pl doesn't suggest `on' for \a b -> f (g a) (g b)?
09:45:46 <kqr> and what does the @pl-resume thing mean?
09:47:11 <ParaSa1lin> @pl  \a b -> f (g a) (g b)
09:47:14 <lambdabot> flip ((.) . f . g) g
09:47:14 <lambdabot> optimization suspended, use @pl-resume to continue.
09:47:23 <sipa> @pl-resume
09:47:29 <lambdabot> flip ((.) . f . g) g
09:47:29 <lambdabot> optimization suspended, use @pl-resume to continue.
09:48:24 <Cale> kqr: on didn't exist when @pl was written
09:48:50 <derdon> hello everyone. this is my solution of projecteuler problem #12: http://lpaste.net/6381358427238563840 it works, but it's really slow for big numbers (running for over 30 minutes now for the input 500)
09:48:55 <derdon> how can I make it faster?
09:49:03 <Cale> and the @pl-resume thing is that it takes a certain number of steps trying to simplify the expression it comes up with, and then stops. Sometimes that process won't terminate.
09:49:12 <derdon> projecteuler problem 12 is: http://projecteuler.net/problem=12
09:49:18 <Cale> So it lets you resume and try harder to simplify.
09:49:22 <ParaSa1lin> what is this, java? "firstTriangleNumberWithMoreThanNDivisors"
09:49:52 <derdon> ParahSailin: :D
09:49:58 <Cale> > length "firstTriangleNumberWithMoreThanNDivisors n"
09:49:59 <lambdabot>   42
09:50:09 <Cale> > length "find((>n).length)$map(getFactors.triangleNumber)[1..]"
09:50:10 <lambdabot>   53
09:50:11 <derdon> do you have a better name?
09:50:13 <ParaSa1lin> hm, well ill tell you what doesnt make it faster, skipping whitespaces before and after infix operators
09:50:22 <Cale> seems legit
09:50:35 <derdon> haskell is good for golfing
09:50:57 <Cale> derdon: Well, here's a hint: there's another way to express the nth triangle number
09:51:01 <Rembane> J > Haskell
09:51:07 <Rembane> When it comes to golfing
09:51:21 <derdon> Cale: oh, fuck. how come I didn't see it?
09:51:30 <kqr> Cale, okay, thanks
09:51:36 <derdon> thanks Cale
09:51:40 <Cale> no problem :)
09:52:19 <Cale> Also, this is a tiny constant factor thing, but if you leave the type signatures polymorphic like that, you'll pay for it a little bit with performance.
09:52:49 <Cale> If you were defining constants, it might make things really much slower though, by turning them into functions of the typeclass dictionary.
09:53:06 <Cale> (i.e. they'd have to be re-evaluated on each use rather than computed once and for all)
09:53:45 <derdon> Cale: ah, so calling functions with concrete types is faster than calling ones with generic signatures?
09:53:56 <Cale> Ever so slightly
09:54:09 <Cale> Well, the typeclass dictionary is another secret parameter
09:54:17 <quchen> How safe is "unsafePerformIO newTVarIO"? The docs mention it as one of newTVarIO's benefits
09:54:31 <quchen> Are there scenarios I could run into problems with this?
09:54:37 <Cale> So when you have Integral a there, that means the implementation is going to pass your function a record of the operations for the Integral typeclass.
09:54:54 <quchen> More specifically, I've got a tuple type full of TVars, and it's pure, but in IO due to the TVars.
09:55:08 <Cale> So if you had something like   bigConstant :: (Integral a) => a; bigConstant = product [1..1000]
09:55:15 <quchen> s/tuple type/product type
09:55:20 <Cale> then bigConstant would be recomputed at each point that you used it
09:55:24 <derdon> Cale: ah, that's good to know. thank you!
09:55:36 <Cale> because it's a function of the typeclass dictionary rather than an honest constant
09:55:53 <Cale> but if you made it an Integer, it would stay computed as long as it's in scope
09:56:23 <Eduard_Munteanu> ski: not sure if it's relevant, but it looks like the two notions of mapFocus combined generate an indexed store comonad and they also seem to be profunctorial: index :: (i -> s) -> (s -> o) -> w s a -> w__ i o a. You can also define a profunctor on \i o -> w__ i o a which is almost identical to pairing the two mapFocuses.
09:57:41 <ParaSa1lin> > let trangls = scanl (+) 0 [1..] in take 10 trangles
09:57:42 <lambdabot>   Not in scope: `trangles'
09:57:42 <lambdabot>  Perhaps you meant one of these:
09:57:42 <lambdabot>    `trangls' (lin...
09:58:40 <Eduard_Munteanu> newtype IxS w a i o = IxS (w i o a)  instance (IndexedStore w__) => Profunctor (IxS w__ a) where  promap (f :: j -> i) (h :: o -> p) (IxS st) = IxS $ toIndexed (g . f :: j -> a) (h o :: p) where (g, o) = fromIndexed st
09:59:40 <Eduard_Munteanu> promap is basically the two combined, and I guess it's reasonable to require them to be bifunctorial.
10:01:36 <Eduard_Munteanu> Actually it's probably an internal hom functor for IxS a, but I'm not entirely sure how to define that as a category (perhaps except as the image of a functor).
10:03:54 <Eduard_Munteanu> (given you can convert from tuples to the store and back, it seems like it would obey the products in Hask)
10:10:45 <derdon> this is the new code, which is still very slow: http://lpaste.net/8813355509382905856
10:11:10 <derdon> I think the getFacors function is written in a quite naive way. can it be improved?
10:13:27 <tobygoodwin> hayoo seems to be broken again :-(
10:14:00 <geekosaur> every weekend, it seems :(
10:14:53 <geekosaur> someone needs to move the backend off whatever desktop machine is getting turned off at COB :p
10:16:21 <sshine> can anyone tell me of a smarter approach to comparing N assignments for plagiarism than doing the cross-product of my edit-distance function? this would give me a complexity of O(n^2 * m^2) for n assignments of length m.
10:16:48 <pavonia> derdon: It should suffice to check the numbers [1 .. n/2] in getFactors
10:18:45 <sshine> either by using a cheaper comparison function or some kind of clustering/sorting method of avoiding all those comparisons.
10:18:49 <pavonia> derdon: also, calculating the prime factors and constructing all possible divisors from them would probably be even faster
10:19:50 <derdon> pavonia: ah, good catch. but why do you think that generating the prime numbers first and then generating all remainding divisors from them should be faster?
10:20:09 <derdon> isn't generating prime factors also a slow task?
10:21:17 <pavonia> yes, but for calculating the prime factors (the simple way) you only need to traverse the numbers [1 .. sqrt n]
10:21:27 <monochrom> one-time identification of prime numbers + many times dividing by just those prime numbers < many times dividing by all numbers
10:22:06 <monochrom> e.g., if you have tried dividing by 2, there is no point dividing by 4, 6, 8, 10, 12...
10:22:27 <derdon> yeah, I see that. thanks
10:25:39 <pavonia> I guess it's a bit more tricky to construct the divisors from that
10:26:13 <monochrom> the divisors of 2^3 5^1 7^2 are: 2^0 5^0 7^0, 2^0 5^0 7^1, 2^0 5^0 7^2, 2^0 5^1 7^0, 2^0 5^1 7^1, 2^0 5^1 7^2, 2^1 5^0 7^0, ...
10:26:46 <pavonia> oh
10:26:56 <monochrom> generally { 2^i 3^j 7^k | i is 0 to 3, j is 0 to 1, k is 0 to 2 }
10:27:04 <pavonia> s/a bit more tricky/pretty simple/ :)
10:27:30 * derdon sets #haskell to autojoin
10:27:34 <derdon> you are awesome :)
10:27:46 <monochrom> therefore, 2^3 5^1 7^2 has exactly (3+1)*(1+1)*(2+1) divisors
10:31:12 <monochrom> if you are only asked: does 2^3 5^1 7^2 have more than 5 divisors? then it's even better
10:32:19 <monochrom> you don't even care it is 2^3 5^1 7^2 vs 2^3 5^1 blahblah. (3+1)*(1+1) is already 6.
10:33:07 <tromp__> it you're asked for the smallest number with exactly 11 divisors...
10:33:10 <tromp__> if
10:33:39 <derdon> ah, that's really interesting! monochrom: is there some name for this theorem?
10:34:21 <monochrom> no. but it's in every textbook on number theory
10:35:04 <tromp__> Fundamental theorem of arithmetic
10:35:05 <derdon> monochrom: it may come later in the book "The Haskell Road to Logic, Math and Programming" in the chapter about number theory
10:35:20 <tromp__> unique factorization theorem
10:36:22 <Fuuzetsu> I wonder if anyone cited #haskell logs in a paper yet.
10:36:24 <monochrom> this is a case of "the PE website told you so". the problem set is more than 95% about knowing math and less than 5% about coding tricks
10:36:50 <derdon> monochrom: I know that. I use it to learn more about math
10:37:35 <derdon> and haskell is a nice tool for solving the problems after you have solved it in your head of by using pen&paper and math
10:38:25 <haasn> It seems like “Haskell requires a 500 MB installation” is the new popular thing to troll with
10:38:41 <haasn> Which makes me wonder. Wasn't GHC going to switch over to dynamic linking or something a while ago to avoid the 4x binary explosion?
10:38:59 <Cale> 500 MB is a trivial amount of space.
10:39:05 <monochrom> it's in fact 950MB here :)
10:39:19 <derdon> 500MB? Who has a hard dribe with 500MB free space?!
10:39:21 <derdon> that's insance
10:39:24 <derdon> *insane
10:39:24 <geekosaur> the switchover is happening in 7.8
10:39:25 <Cale> A single episode of most TV shows is more than that.
10:39:31 <haasn> Cale: not on an SD card or flash drive, perhaps :P
10:39:48 <bearclaw> texlive-base is probably more than that :)
10:39:54 <derdon> haasn: SD cars have 8 or 16GB
10:39:56 <monochrom> but yes GHC is about switching to dynamic linking
10:40:12 <Fuuzetsu> derdon: 500MB is a significant part of those
10:40:14 <donri> only for ghci though i think?
10:40:22 <Fuuzetsu> yes, only for GHCi
10:40:27 <donri> meaning it will build twice now, even more disk usage ;)
10:40:35 <monochrom> this doesn't help with Haskell Platform install size though. too few executables to matter.
10:41:04 <Cale> I actually think that static linking makes sense for Haskell binaries, given that we're not quite to the point where everyone is using Haskell for everything.
10:41:19 <haasn> Yes I agree
10:41:36 <haasn> Static linking for binaries is fine, they don't need four versions for profiling and dynamic usage, either :)
10:41:41 <Fuuzetsu> I swear there was a GHC Wiki page on this switchover
10:41:54 <haasn> I think linking haskell libraries themselves dynamically might be useful
10:42:17 <donri> dynamic linking kills performance for ghc built executables
10:42:18 <Fuuzetsu> http://ghc.haskell.org/trac/ghc/wiki/DynamicByDefault
10:42:45 <monochrom> does it kill performance on 32-bit x86?
10:42:58 <haasn> donri: because of inlining?
10:43:24 <donri> haasn: plausible, yes
10:44:08 <donri> i only know, i once built an app dynamic, and the executable shrank almost out of existence but everything was some four times slower :P
10:44:18 <Eduard_Munteanu> You should still be able to do dynamic linking for the non-inlined symbols.
10:45:16 <Eduard_Munteanu> I mean you should be able to both inline and link dynamically.
10:45:51 <haasn> The only other plausible idea I have is something to do with locality but that's a stab in the dark since I have no idea how binaries work and how linux loads them etc.
10:46:26 <Eduard_Munteanu> Is it just the startup delay? Or does it run slower for longer tasks too?
10:46:44 <donri> Eduard_Munteanu: everything, when i tested id
10:46:53 <merijn> haasn: Binaries are loaded lazily
10:47:04 <donri> haasn: i think in theory shared libs can help by putting shared code in the page cache, duno
10:47:20 <merijn> haasn: The OS (on BSD, linux, OSX at least. Althought I'd be surprised if windows does this differently)
10:47:27 <donri> that's assuming something else already loaded the same lib
10:47:30 <Eduard_Munteanu> Yeah, libraries are COWed in Linux.
10:47:37 <merijn> So pages are loaded from disk on demand as you try to access them
10:47:46 <Eduard_Munteanu> COW-mmaped, even.
10:47:56 <merijn> Eduard_Munteanu: Not just libraries, loading binaries from disk is lazy too
10:48:03 <merijn> iow binary size is irrelevant to startup time
10:48:08 <Eduard_Munteanu> Yeah, I meant the lib code is shared.
10:48:18 <Natch> anyone know what System.Info.os is on Android?
10:51:51 <donri> os :: StringlyTypedGoodness
10:52:14 <merijn> donri: Presumably he was wondering about the contents >.>
10:52:23 <donri> merijn: exactly
10:52:35 <donri> which is only a problem because it's stringly typed :)
10:53:18 <monochrom> well, either a string or an open sum type
10:54:21 <donri> why open though? you'd think if someone bothers to port a haskell compiler to a platform they could bother to add a constructor to a sum type in base
10:54:30 <jophish> Is there a hash table which won't keep a reference to the keys
10:54:35 <mangaba_leitosa> What are opinions on the Curry language? E. g. on using it instead of Haskell?
10:54:39 <jophish> I can get around this by prehashing my keys
10:54:48 <jophish> but most maps will hash them again
10:55:14 <jophish> my map is from Strings to Strings, and the total size of all the keys is many GB
10:55:22 <monochrom> I didn't think. you are right.
10:56:42 <schoppenhauer> can I build the haskell platform without opengl (have no ogl installed)
10:57:13 <joelteon> does anyone here use Dash?
10:57:16 <joelteon> the documentation search app
10:57:24 <merijn> schoppenhauer: Haskell Platform is just a set of "blessed" packages, you can just install GHC + cabal and manually install what you need
10:57:34 <schoppenhauer> merijn: ok thx
10:58:08 <merijn> schoppenhauer: So if you just dig up a list of haskell platform packages you can just install whatever selection you want and skip anything opengl related
10:58:27 <schoppenhauer> merijn: thanks!
10:58:34 <schoppenhauer> merijn: will do so!
10:59:21 <merijn> Might want to consult the cabal linky people post here every so often, I forgot what it was, though
10:59:24 <merijn> @where sicp
10:59:25 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
10:59:25 <lambdabot> Packages"
10:59:57 <merijn> hmm, the last one, but I'm not sure that's the right one
11:00:36 <schoppenhauer> thank you! I dont have much dependencies.
11:01:07 <schoppenhauer> just want to test a program many times on a server
11:34:39 <redscare> if I have a type signature like (Num a) => a -> a, is a allowed to be two different types that are both instances of Num?
11:34:51 <merijn> redscare: Nope
11:35:22 <redscare> ok. and just to check, type signatures like (Num a, Num b) => a -> b are OK?
11:35:33 <merijn> redscare: Yup, that's ok
11:36:46 <merijn> redscare: Obviously that function needs to do some form of conversion inside, but there's no conceptual issues with that type or functions that do that
11:38:18 <shachaf> That type is valid but not very useful.
11:38:30 <mangaba_leitosa> anyone familiar with curry/kics? there is no IRC channel for curry :-)
11:39:03 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs#L51
11:39:09 <magneticduck> I'm writing a kind of sound library
11:39:24 <mangaba_leitosa> I just installed kics in order to play with curry, and REPL exits(1) on any error in the input
11:39:34 <haasn> Removing MinGW from the GHC source and recompressing the rest shrinks it down to 8 MiB. Do we really need that in there?
11:39:34 <magneticduck> and I'm not aiming at performance... but it seems like it takes 13 seconds for this function (above) to render a 10 second file
11:40:08 <magneticduck> any tips on making it faster?
11:40:17 <merijn> magneticduck: Have you profiled the code to see what's making it so slow?
11:40:26 <magneticduck> also, previous versions of it ran much faster (more like 3 seconds for 10 seconds)
11:40:34 <magneticduck> I don't really know how to do profiling
11:40:44 <merijn> magneticduck: Real World Haskell has a chapter on profiling
11:40:44 <magneticduck> how do I?
11:40:46 <merijn> @where rwh
11:40:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:40:47 <lightquake> why does cabal tell me I need to rerun cabal configure instead of just doing it for me :(
11:41:00 <merijn> lightquake: New versions do that, it's glorious :)
11:41:12 <kuribas> http://book.realworldhaskell.org/read/profiling-and-optimization.html
11:41:15 <merijn> lightquake: Upgrade to 1.18 to get rid of the suffering :)
11:41:32 <merijn> magneticduck: Also, are you compiling with -O2?
11:41:35 <magneticduck> no
11:41:40 <magneticduck> what does it do
11:41:41 <lightquake> merijn: I just did!
11:41:44 <merijn> magneticduck: Ah, might wanna try that too
11:42:03 <slack1256> Any haskell meeting on brazil between January and March?
11:42:14 <magneticduck> but I have a pretty simple problem at the moment, which is that previous versions of the function ran much much faster then this one does
11:42:18 <merijn> magneticduck: -O specifies the optimisation level, the default is -O0, -O2 is maximum optimisation
11:42:27 <magneticduck> m
11:45:07 <magneticduck> actually I have no idea what's going on because the pure function runs fast enough
11:46:04 <merijn> magneticduck: Hence why profiling should help ;)
11:47:13 <magneticduck> BUT it used to run so much faster
11:47:20 <magneticduck> what the <removed wordddddd>
11:47:55 <magneticduck> AND it seems like printing each sample value to the terminal takes less time than rendering the actual file does
11:47:57 <magneticduck> >_>
11:48:07 <magneticduck> uh, maybe I have some process hogging the drive?
11:48:40 <magneticduck> I'll do deh profiling
11:50:08 <magneticduck> where do I put the -O2 option in the cabal file?
11:50:34 <magneticduck> ah ghc-options
11:50:39 <merijn> magneticduck: yeah
11:51:24 <argiopeweb> Doesn't Cabal enable optimization by default on supported compilers?
11:53:16 <magneticduck> I'm going to restart the machine >_>
11:54:27 <kttm> hi, what is the Haskell equivalent of this function http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/every-pred ?
11:55:30 <haasn> :t \f -> all ($f) -- kttm
11:55:32 <lambdabot> a -> [a -> Bool] -> Bool
11:56:49 <mauke> :t (and .) . sequence
11:56:50 <lambdabot> [a -> Bool] -> a -> Bool
12:01:56 <magneticduck> alright, so my problem has boiled down to: I have a pure function in my code that seems to run fast when tested in GHCi with +s
12:02:01 <magneticduck> at 0.00 seconds actually
12:02:08 <magneticduck> but when I try to use it to write samples to a file
12:02:11 <magneticduck> it's slow
12:02:26 <magneticduck> I mapped it to lists in GHCi and printed the results to the screen
12:02:31 <mcstar> well, GHCi stands for GHC improved, so thats understandable
12:02:41 <magneticduck> and it takes much less time than it does to write to a file
12:02:44 <magneticduck> hm
12:03:05 <magneticduck> I've had functions in the past that do the same thing and run more or less the same in GHCi
12:03:06 <mcstar> j/k
12:03:20 <magneticduck> but they take much less time when used to write a file
12:03:50 <magneticduck> (what writing to a file consists in is creating a list of values, mapping the function on them, and writing each value into a file)
12:03:52 <sshine> mcstar, you're probably thinking of GHCIM, the variant of GHC with syntax highlighting and obscure keybindings.
12:03:53 <magneticduck> it makes
12:03:55 <magneticduck> no
12:03:57 <magneticduck> sense
12:04:21 <mcstar> sshine: probably :)
12:04:21 <magneticduck> :|
12:04:22 <sshine> magneticduck, writing to files takes a lot of time compared to computing things.
12:04:28 <magneticduck> I understand
12:04:30 <sshine> mcstar, (I don't think it exists, though)
12:04:44 <magneticduck> but when I use other functions to do it, it takes a small fraction of the time
12:05:16 <magneticduck> sin: runs in about 0.01 seconds in GHCi, takes 0.74 seconds to write to a file 411000 elements long
12:05:36 <magneticduck> my function: runs in about 0.00 seconds (never registers a time), take 13 seconds to write a file the same length
12:05:48 <magneticduck> what the <explicitave>
12:05:52 <mcstar> you cant display 411k elements of things in a console in 0.01 seconds... i think
12:05:56 <magneticduck> no
12:06:07 <magneticduck> I mean, it takes that time on average to render a single result
12:06:18 <argiopeweb> magneticduck: So, what functions are you using in yours that you aren't using in the sin test?
12:06:28 <magneticduck> it's all pure
12:06:36 <magneticduck> https://github.com/MagneticDuck/SoundsOfDuck/blob/master/src/SoundsOfDuck/Sound.hs#L51
12:06:37 <magneticduck> is the code
12:06:41 <magneticduck> it's in a small library
12:06:46 <mcstar> maybe it takes time to actually compute those things
12:06:48 <magneticduck> the stuff it's using shouldn't be hard to find
12:06:55 <mcstar> but you dont see that in ghci, since it is already computed
12:06:58 <magneticduck> what do you mean?
12:07:03 <mcstar> on the first run, probably
12:07:05 <kttm> mauke: thanks
12:07:11 <magneticduck> I run it with different values
12:07:18 <magneticduck> I know about cacheing or whatever it's called
12:07:21 <magneticduck> caching*?
12:07:55 <argiopeweb> That's a side effect of thunk evaluation at the top-level (GHCI).
12:08:08 <argiopeweb> Definitely not explicit caching.
12:08:19 <magneticduck> mm
12:08:23 <argiopeweb> Though I could see it being construed as implicit.
12:09:09 <magneticduck> btw it's totally easy to install the library if you're as vexed about this as I am
12:09:15 <magneticduck> you just need libsndfile
12:09:57 * mcstar doesnt think any of us is vexed, really
12:10:36 <argiopeweb> Not even particularly curious, honestly.
12:10:40 <mcstar> anyway, timing haskell is tricky, thats for sure
12:11:45 <magneticduck> lol
12:11:50 <magneticduck> >:<
12:11:58 <jophish> Does anyone feel like they have a nice .vimrc for Haskell. I'm working on mine and can't seem to get autocomplete working a a pleasing way
12:12:36 <danr> jophish: github.com/dag/vim2hs
12:13:55 <jophish> danr, awesome, I'll give that a try
12:16:49 <magneticduck> how would I strictly set a value in GHCi without displaying it?
12:16:58 <magneticduck> not used to the strictness syntax
12:17:06 <magneticduck> you put a ! somewhere I heard
12:17:52 <khyperia> Could someone look at this http://lpaste.net/93562 ? It's a question.
12:17:57 <k00mi> magneticduck: what do you mean by set?
12:18:30 <pavonia> he means "let !x = ...", I guess
12:18:35 <magneticduck> I mean, I want to have a name hold a value without laziness
12:18:38 <magneticduck> everything at once
12:18:47 <Iceland_jack> magneticduck: value `seq` ()
12:19:14 <magneticduck> flip seq ()
12:19:16 <magneticduck> ?
12:19:28 <magneticduck> huh
12:19:33 <Iceland_jack> Sure I guess
12:19:47 <magneticduck> uhh, I don't really see how that works
12:19:56 <Iceland_jack> Well do you know what seq does?
12:19:58 <magneticduck> seq a b = b, n'est pas
12:20:12 <magneticduck> ...so seq () b just reduces to b, right?
12:20:17 <magneticduck> there's something I@m not getting
12:20:37 <Iceland_jack> magneticduck: You can search for "seq Haskell" online
12:20:37 <Iceland_jack> Prelude> let x = 2 + 2
12:20:37 <Iceland_jack> Prelude> :sprint x
12:20:38 <Iceland_jack> x = _
12:20:40 <Iceland_jack> Prelude> x `seq` ()
12:20:44 <Iceland_jack> ()
12:20:47 <Iceland_jack> Prelude> :sprint x
12:20:50 <Iceland_jack> x = 4
12:20:59 <Iceland_jack> but seq only evaluates to WNHF
12:21:04 <magneticduck> huh
12:21:08 <magneticduck> what's that?
12:21:24 <Iceland_jack> It means that it will be evaluated to the next constructor, very simply speaking
12:21:33 <magneticduck> I see, seq is a bit of a magical operator?
12:21:58 <Iceland_jack> magneticduck: Try the same that I wrote abote with: let y = map (+1) [1,2,3] instead of x
12:22:01 <Iceland_jack> tell me what you see
12:22:16 <d3lxa> if you have a list of objets of variable type a: KeyBackend a => m a, can you put them into a single list of type [KeyBackend a => m a] somehow? by creating a type alias for all KeyBackend a (in m a), is this possible?
12:22:27 <pavonia> Iceland_jack: Why not simply "let !x = 2 + 2"?
12:22:27 <k00mi> it's "magical" as in it's primitive, can't be implemented in haskell
12:23:17 <khyperia> Sorry for asking a second time, but http://lpaste.net/93562 ?
12:23:20 <haasn> You could make your own ‘seq’ with type classes and writing an instance for every type
12:23:30 <Iceland_jack> pavonia: Because you'd have to enable a language extension and using seq is more general
12:23:34 <haasn> Sort of like how deepseq works
12:23:50 <magneticduck> k00mi: yeah, that's what I was thinking of
12:23:57 <mcstar> well, data fields can have strictness annotation, maybe you could use that to write 'seq'?
12:24:29 <magneticduck> uh, doesn't seem to work in my GHCi Iceland_jack
12:24:30 <d3lxa> khyperia: why not a "bridge" function?
12:24:38 <haasn> mcstar: Aren't those implemented with ‘seq’ internally? :)
12:24:39 <magneticduck> let y = map (+1) [1, 2, 3]
12:24:40 <Iceland_jack> magneticduck: What doesn't seem to work?
12:24:42 <magneticduck> sprint y is _
12:24:48 <Iceland_jack> magneticduck: Yes
12:24:53 <k00mi> haasn: well, it wouldn't be :: a -> b -> b
12:24:56 <magneticduck> sprint returns the same thing after I use seq ()
12:25:04 <magneticduck> applied to the expression
12:25:05 <Iceland_jack> after you use: seq y ()?
12:25:07 <khyperia> The trouble that I'm forseeing is that the sum types could get up to 20-30 options, and it's annoying to have to write out the same thing over and over again, with very minor differences.
12:25:24 <magneticduck> no, after I use let y = seq () $ map (+1) [1, 2, 3]
12:25:33 <Iceland_jack> yeah, that's not what I asked you to do
12:25:44 <Iceland_jack> if you look up, it's not what I wrote
12:25:59 <magneticduck> alright
12:26:01 <d3lxa> khyperia: and you don't want to wrap again your Number type in OtherNumber type?
12:26:06 <mcstar> a `seq` b means evaluate a to whnf and return b (which could possibly contain a)
12:26:25 <magneticduck> hmm
12:26:31 <haasn> Iceland_jack: “let y = map (+1) [1,2,3]” “y `seq` ()”  “:sprint y” gives me y = _; even if I “case y of _:_ -> ()”
12:26:39 <magneticduck> I gtg now, I'll think about that, still not completely clear on what's up with seq
12:26:42 <magneticduck> thanks
12:26:43 <Iceland_jack> the list has to be the first argument to seq magneticduck :)
12:26:47 <Iceland_jack> sorry for not making that more clear
12:26:49 <khyperia> That's a possibility, but if I had to choose between those two, writing them out would probably be easier
12:27:07 <haasn> Iceland_jack: oh, I think it's due to polymorphism
12:27:11 <d3lxa> khyperia: hl me if you want me to answer, cannot watch contiounsly the channel for your messages
12:27:15 <haasn> Iceland_jack: If I give ‘y’ a monomorphic type signature, it works as expected
12:27:34 <Iceland_jack> haasn: Had you disabled the MonoRestr?
12:27:46 <haasn> Iceland_jack: obviously :)
12:28:07 <Iceland_jack> Well there's your problem :)
12:28:47 <ReinH> edwardk: oh hai!
12:28:50 <d3lxa> khyperia: you could do something very nasty with the Read/Show instance =) but I don't advice you to used it
12:33:49 <chrisdone> hm, can you reify a module in haskell with template haskell to look at its exports?
12:34:26 <khyperia> d3lxa, I guess what I'll do is have a "master" sum type with all options, then all "sub-sum types" each provide a conversion to/from the master type
12:34:50 <Eduard_Munteanu> Can you apply (co)monad transformers to any endofunctor? I'm considering applying the indexed store comonad transformer to Maybe to get a partial indexed store comonad.
12:36:57 * arkeet wonders whether what remains is a comonad
12:37:20 <d3lxa> khyperia: if you do that, won't you have one extra copy of your types case again?
12:37:53 * arkeet wonders whether you get a comonad on the kleisli category
12:37:57 <arkeet> of Maybe
12:38:08 <Eduard_Munteanu> arkeet: yeah, that's what I want.
12:38:31 <khyperia> I don't know else how to do it, since if I do a everything convertable to everything system, then there's going to be massive amounts of conversion functions
12:38:57 <Eduard_Munteanu> arkeet: actually, well, that's what you get if you make a comonad on Kleisli Maybe (aka partial Hask), but a transformer for Maybe would be nicer
12:39:38 <Eduard_Munteanu> arkeet: because it would eliminate the need for a 'distribute :: t (m a) -> m (t a)', AFAICT.
12:40:31 <tobygoodwin> anyone know anything about timezones? i've hit a problem that i can't find an elegant solution for: http://lpaste.net/93563
12:43:10 <Heffalump> tobygoodwin: I think you first need to refine your spec - if something is supposed to happen the next day at the same local time, how does that requirement work with DST changes?
12:43:41 <Heffalump> in particular 2:30 in the morning when there's a DST change in the UK is ill-defined - it happens either 0 times or 2 times.
12:43:48 <Eduard_Munteanu> Er, no, it probably doesn't make sense for the usual notion of (co)monad transformer. :/
12:44:26 <Eduard_Munteanu> Dang.
12:44:35 <Eduard_Munteanu> Working with foreign categories is rather annoying.
12:46:26 <mardakos> hello, what nice books on haskell do you recommend other that LYAH ?
12:47:30 <mangaba_leitosa> mardakos: I heard very good opinions about http://www.cs.yale.edu/homes/hudak/SOE/ but did not try it myself yet
12:48:19 <mangaba_leitosa> mardakos: it's available for reading online for free if you register a trial account on safaribooksonline
12:48:42 <mangaba_leitosa> (but you cannot download the text from there) :-(
12:49:05 <tobygoodwin> Heffalump: thanks for looking - that's a good point, and in fact form my application I only care about "reasonable" times in office hours, so the failure close to the boundaries isn't important
12:49:21 <arkeet> tobygoodwin: have a look at the timezone-series package
12:49:25 <tobygoodwin> it was the ugliness I was hoping to fix :-)
12:49:26 <mangaba_leitosa> mardakos: so I'm going to try it soon
12:49:39 <arkeet> and timezone-olson (for getting a timezoneseries from a zoneinfo file)
12:49:50 <mardakos> i remember someone recommind me an old book that is useful but I can't remember it..
12:49:57 <mardakos> sort of a math book..
12:50:05 <tobygoodwin> arkeet: fantastic! thank you
12:50:07 <elliott> gentle introduction? mac lane? :P
12:50:14 <mangaba_leitosa> mardakos: bird & wadler?
12:50:25 <arkeet> elliott: haha
12:50:38 <chrisdone> waddle he write next?
12:51:22 <arkeet> time zones are one of those tricky things to get right =(
12:51:27 <mardakos> nope i read this already..
12:53:39 <arkeet> would be nice if timezone-series had some TimeZoneSeries -> UTCTime -> (LocalTime, TimeZone)
12:53:48 <Eduard_Munteanu> I think I want something like  Kleisli Maybe s (Store s a) <-> CoKleisli (Store s) a (Maybe b)   but that looks a lot like 'distribute'. Perhaps I should work with polymorphic (co)monads and only use the typeclasses in question.
12:54:43 <arkeet> hm, maybe it's not that bad.
12:55:50 <ReinH> damn it edwardk
12:56:23 <Eduard_Munteanu> The idea is to get something like   extract :: w s a -> Maybe a   extend :: (w s a -> Maybe b) -> (w s a -> w s b)
12:56:29 <tomejaguar> Suppose I have "f :: C x => ...", is there a way of building a dictionary of C operations and passing it to f dynamically?
12:56:34 <tobygoodwin> so timezone-series looks like what I need, except I don't see where I get the local TimeZoneSeries from?
12:57:25 <krakrjak> mardakos: Real World Haskell
12:57:25 <arkeet> tobygoodwin: that's what the second package I mentioned is for.
12:57:27 <Eduard_Munteanu> tomejaguar: what do you mean dynamically, at runtime?
12:57:31 <tomejaguar> Eduard_Munteanu: ys
12:57:54 <arkeet> tobygoodwin: unfortunately I don't know what you'd do if you're on windows.
12:58:19 <tobygoodwin> arkeet - apologies (this channel is hard to follow sometimes)... and I don't care about windoze
12:58:22 <arkeet> :)
12:58:44 <tomejaguar> Eduard_Munteanu: suppose C was Show.  I want to be able to pass explicitly an "x -> String" that may not be statically known.
12:58:45 <Eduard_Munteanu> tomejaguar: well, typeclass instance resolution works at runtime (it's a pointer to a dictionary)
12:59:08 <tomejaguar> Yeah I want to pass that dictionary by hand
12:59:16 <elliott> Eduard_Munteanu: that extend looks weird.
12:59:17 <tomejaguar> because I don't want x to actually have to be an instane
12:59:27 <elliott> the kleisli thing would be w s (w s a) -> Maybe (w s a), I think.
12:59:27 <arkeet> tomejaguar: you may be intererested in reflection
13:00:01 <tomejaguar> arkeet: I was worried someone would say that!
13:00:07 <arkeet> haha
13:00:17 <Eduard_Munteanu> tomejaguar: if you want to do things manually, use a GADTs
13:00:28 <Eduard_Munteanu> s/things/dispatch/
13:00:43 <tomejaguar> I can't.  I basically want to override postgresql-simple's FromRow instances
13:00:47 <arkeet> tomejaguar: but it solves exactly that problem.
13:00:49 <arkeet> ;)
13:00:55 <tomejaguar> or provide *more* rather than override
13:01:00 <tomejaguar> but I want to construct them at runtime
13:01:08 <tomejaguar> arkeet: Ah well I better look at it more closely
13:01:13 <arkeet> tomejaguar: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
13:01:22 <Eduard_Munteanu> tomejaguar: wrap things in a different typeclass?
13:01:40 <Eduard_Munteanu> elliott: what's wrong with the 'extend'?
13:02:25 <Eduard_Munteanu> elliott: if (~~>) = Kleisli Maybe, then  extend :: (w s a ~~> b) -> (w s a ~~> w s b)
13:02:46 <elliott> Eduard_Munteanu: sure, but extend is weird.
13:02:56 <Eduard_Munteanu> Kleisli Maybe a b ~ a -> m b
13:03:00 <elliott> yes, I know.
13:03:11 <arkeet> do you? that looks false.
13:03:16 <arkeet> or at least wrong
13:03:18 <Eduard_Munteanu> elliott: you mean it's weird in general, or mine?
13:03:19 <elliott> it's like you have fmap :: (a -> Maybe b) -> w s a -> w s b, extract :: w s a -> Maybe a, extend :: w s a (w s a) -> w s a, I guess.
13:03:20 <arkeet> :p
13:03:24 <elliott> s/extend/duplicate/
13:03:36 <arkeet> you forgot a Maybe.
13:03:41 <elliott> no, I didn't.
13:03:43 <elliott> that's what's so weird.
13:03:52 <arkeet> in extend.
13:03:55 <elliott> I know.
13:04:00 <arkeet> huh
13:04:04 <elliott> (it's duplicate, not extend)
13:04:07 <arkeet> right.
13:04:14 <elliott> because you have extend :: (w s a -> Maybe b) -> w s a -> w s b
13:04:17 <Eduard_Munteanu> elliott: don't you mean join?
13:04:23 <arkeet> you do?
13:04:24 <elliott> ok, ok, flip the arrow, sheesh :P
13:04:29 <elliott> arkeet: yes, because Eduard_Munteanu said you have that.
13:04:33 <arkeet> oh.
13:04:34 <arkeet> ok
13:04:35 <elliott> I just split it into the mappy part and the duplicate part.
13:04:41 <arkeet> no, but he used ~~> twice.
13:04:53 <elliott> ok, then <Eduard_Munteanu> The idea is to get something like   extract :: w s a -> Maybe a   extend :: (w s a -> Maybe b) -> (w s a -> w s b)
13:04:56 <elliott> was a lie :P
13:04:57 <arkeet> in extend.
13:04:59 <arkeet> oh ok.
13:05:10 <arkeet> anyway the proper way to do it is
13:05:25 <arkeet> look at the category definition of a comonad
13:05:28 <arkeet> in that kleisli category
13:05:34 <Eduard_Munteanu> arkeet: oh, you're right, I only want the first arrow
13:05:41 <Eduard_Munteanu> The first (~~>).
13:05:43 <arkeet> no!
13:06:10 * Eduard_Munteanu thinks it over
13:06:36 <arkeet> you want fmap :: (a -> Maybe b) -> w a -> Maybe (w b); extract :: w a -> Maybe a; extend :: w a -> Maybe (w (w a))
13:06:41 <arkeet> er, duplicate.
13:06:44 <arkeet> damn you elliott.
13:06:51 <elliott> see, arkeet's thing looks reasonable.
13:06:53 <arkeet> I dropped the s because who needs it.
13:07:00 <elliott> it's a comonad in the kleisli thing thing thing thing Maybe thing.
13:07:03 <tomejaguar> arkeet: What is this magic?  8D
13:07:08 <arkeet> tomejaguar: 8D
13:07:14 <arkeet> it's reflection.
13:07:15 <tomejaguar> I can't quite believe it works.
13:07:17 <elliott> this is why (>>=)/extend are kind of evil; they're not the actual arrows you're working with.
13:07:34 <tomejaguar> I read edwardk's post on fpcomplete about the library
13:07:36 <tomejaguar> but it does seem magic
13:07:36 <arkeet> in other words: fmap :: (a ~~> b) -> (w a ~~> w b), etc.
13:07:40 <Eduard_Munteanu> arkeet: wait, I want 'w' a monad on Kleisli Maybe, so it needs to be an endofunctor on that. So it maps a (~~>) to another (~~>)
13:07:46 <Eduard_Munteanu> Yes.
13:07:47 <chrisdone> you think that's arrows you're breathing right now? hmph
13:07:53 <arkeet> Eduard_Munteanu: yes that's what I said.
13:08:23 <Eduard_Munteanu> Ok, that's alright.
13:08:52 * arkeet wouldn't mind a version of Functor, etc. that took a Category as an argument.
13:09:04 <arkeet> or maybe two categories.
13:09:39 <tomejaguar> reflection is black, black, black magic, but it's also exactly what I was looking for, so don't quote me on that :)
13:10:00 <arkeet> tomejaguar: see, I told you you might be interested. :P
13:10:03 <chrisdone> what kind of reflection?
13:10:04 <elliott> a comonad w on Kleisli m is either { extract :: w a -> m a; extend :: (w a -> m b) -> w (w a) -> m (w b) } or { fmap :: (a -> m b) -> w a -> m (w b); extract :: w a -> m a; duplicate :: w (w a) -> m (w a) }
13:10:14 <elliott> (equivalently.)
13:10:15 <Eduard_Munteanu> arkeet: yeah, I've implemented a few versions of that before.
13:10:53 <Eduard_Munteanu> elliott: er, why? Why do those things commute?
13:10:57 <Eduard_Munteanu> The m's and w's.
13:11:00 <arkeet> ??
13:11:04 <arkeet> nothing's commuting.
13:12:02 <Eduard_Munteanu> extend :: (w a -> m b) -> w (w a) -> m (w b)   looks odd, no?
13:12:07 <elliott> Eduard_Munteanu: { extract :: w a ~> a; extend :: (w a ~> b) -> (w (w a) ~> w b) } or { fmap :: (a ~> b) -> (w a ~> w b); extract :: w a ~> a; duplicate ;: w (W a) ~> w a }
13:12:14 <arkeet> extend :: (w a ~~> b) -> (w a ~~> w b)
13:12:15 <elliott> *duplicate ;: W a -> w (W a)
13:12:17 <elliott> oh my god.
13:12:23 <elliott> *duplicate :: w a ~> w (w a)
13:12:27 <elliott> and then set a ~> b = a -> m b
13:14:50 <tomejaguar> chrisdone: the reflection package
13:15:30 <Eduard_Munteanu> Bottom line... fmap :: (a -> Maybe b) -> (Store s a -> Maybe (Store s b)),   extract :: Store s a -> Maybe b   extend :: (Store s a -> Maybe b) -> (Store s a -> Maybe (Store s b))
13:17:20 <tomejaguar> Seems unlikely that Store a is comonad on Kleisli Maybe then.  Can you give those sensible definitions?
13:18:07 <Eduard_Munteanu> Er... extract :: Store s a -> Maybe a
13:19:56 * Eduard_Munteanu is thinking whether he really wants that
13:20:42 <tobygoodwin> arkeet: thanks, timezone-series + timezone-olson works a treat
13:20:59 <arkeet> :)
13:23:05 <Eduard_Munteanu> Bah, I need to think this through some more.
13:23:53 <Eduard_Munteanu> Perhaps I should tell you the motivation behind this.
13:24:48 <Eduard_Munteanu> @hoogle runParser
13:24:48 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
13:24:48 <lambdabot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
13:24:49 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
13:26:18 <Eduard_Munteanu> Basically, I had the idea that the partial Store looks like a fed parser, and thought you can use the Store comonad to combine parsers.
13:27:28 <Eduard_Munteanu> Because you sometimes need to run a Parser and feed the output to another Parser, and it looked a bit like (=>>)
13:27:36 <Eduard_Munteanu> But anyway, I have to think this through.
13:29:02 <tomejaguar> Eduard_Munteanu: I spent some time a while ago thinking of monads in Kleisli categories.  I didn't come up with any interesting ones, unfortunately.
13:29:25 <tomejaguar> The reason I was considering them was that I wanted to know if there could be any genuine monads in an impure language!
13:29:50 <tomejaguar> So for example, are there any monads on a -> IO b?  If not, OCaml doesn't have monads :)
13:30:06 <Eduard_Munteanu> tomejaguar: hm, interesting idea
13:31:15 <arkeet> there is always the identity monad.
13:31:19 <arkeet> at least.
13:31:23 <arkeet> :P
13:31:45 <arkeet> start by looking for adjunctions, perhaps
13:31:48 <tomejaguar> Lucky old OCaml
13:32:08 <arkeet> :t (<*>)
13:32:08 <tomejaguar> I don't think I could even get Maybe to work, but it's been a long time since I was considering this.
13:32:09 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:32:49 <Eduard_Munteanu> PolyKinds and a bunch of other extensions are *very* useful when you want to talk about foreign categories.
13:33:50 <Eduard_Munteanu> Because without those, you're programming in STLC at the type level given the very simple kind system. :)
13:34:11 <tomejaguar> What's STLC?
13:34:12 <tomejaguar> Oh
13:34:16 <tomejaguar> I know what it is :)
13:34:46 * mangaba_leitosa installed kics2 (curry to haskell compiler) and is playing with the code from " Bookmark the permalink.
13:34:53 <mangaba_leitosa> A taste of Curry" http://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/
13:40:15 <haruka> hurd
13:41:35 <joelteon> is it possible to unimport prelude is ghci
13:41:37 <joelteon> in
13:42:06 <foobarbaz> joelteon 'hiding' ?
13:42:11 <tromp__> try :m -Prelude
13:42:15 <tomejaguar> joelteon: I guess you could do -XNoImplicitPrelude
13:42:16 <joelteon> yeah, that doesn't work
13:42:23 <joelteon> setting NoImplicitPrelude doesn't work either
13:43:00 <foobarbaz> http://www.haskell.org/haskellwiki/Import
13:43:05 <foobarbaz> "Hiding Prelude"
13:43:49 <foobarbaz> if it's module conflictions you're trying to solve that could work, `as P`
13:59:32 <spaceships> is it possible to trigger actions in a monad like StateT Blah (ConfigT Blah IO) from a key handler that is of type IO ()? do i need to set up a queue or something, of IORefs to my monad's actions? thanks
14:00:18 <spaceships> perhaps it would be easier to do everything in IO :P
14:00:24 <tomejaguar> What do you mean trigger actions?
14:01:21 <spaceships> I'd like to set up a key handler with vty-ui, the action which needs to be IO (), to cause a screen update (IO ()) update and also a state update
14:01:42 <monochrom> does liftIO help?
14:02:19 <spaceships> it lets me bind events from within my trans monad, but the events inside need to be the same kind of monad
14:02:35 <chrisdone> sounds to me like someone needs monad base
14:02:45 <chrisdone> given that you already have StateT, you already have it
14:02:52 <spaceships> what is monad base?
14:03:07 <monochrom> yeah, monad-base may help. but I wonder what it can do to ConfigT
14:03:08 <chrisdone> http://hackage.haskell.org/package/monad-control-0.3.2.1
14:03:13 <spaceships> thanks
14:03:23 <chrisdone> yeah, not sure about ConfigT -- is that from the ConfigFile package?
14:03:35 <spaceships> mtl
14:03:45 <spaceships> it is not strictly necessary
14:05:02 <chrisdone> the description of monad-control is not helpful, essentially it's solving this same old problem of inversion of control forcing you to pass an IO something when you want to pass a SomeTransformerT Foo IO something, but you don't want to have to do a get call and a runStateT call just to pass to a handler, so this monad-control package defines a class to do that
14:05:08 <chrisdone> never used it m'self, let's see…
14:06:00 <chrisdone> what's the type of the function that takes an event handler?
14:06:26 <spaceships> Widget a -> (Widget a -> Key -> [Modifier] -> IO Bool) -> IO ()
14:06:27 <NemesisD> i've been looking at the async library and i'm curious what uses there would be for the STM operations http://hackage.haskell.org/package/async-2.0.1.4/docs/Control-Concurrent-Async.html#g:5
14:06:49 <spaceships> "onKeyPressed"
14:07:39 <spaceships> chrisdone: that sounds promising
14:08:48 <chrisdone> okay so we need a function from monad-control/base that is like: StateT Blah (ConfigT Blah IO) a -> IO a
14:09:00 <watermind> what are the laws for Alternative? i.e. for empty and <|>
14:09:18 <watermind> asside for empty being neutral and <|> associative
14:09:26 <watermind> anything else?
14:10:35 <enthropy> @unmtl StateT Blah (ReaderT Blah IO) a
14:10:35 <lambdabot> Blah -> (ReaderT Blah IO) (a, Blah)
14:10:54 <watermind> I'm guessing it should relate these operations with pure and <*>
14:11:21 <spaceships> chrisdone: oh that's right - not ConfigT, but ReaderT
14:11:27 <chrisdone> i can't really figure this one out. the library is berefct of useful example code
14:12:11 <enthropy> ReaderT doesn't seem to actually contain the Blah
14:12:24 <enthropy> chrisdone: so where is the Blah going to come from?
14:13:21 <spaceships> chrisdone: perhaps i could just write my own keyBinderFunction in my monad :P
14:13:53 <chrisdone> yeah… i'm too stupid to figure out this package from the types alone
14:14:00 <chrisdone> i'd just define a lifted version of onKeyPressed
14:14:33 <enthropy> chrisdone: it helps to write out the types on paper
14:14:44 <chrisdone> onKeyPressed' f = do r <- ask; onKeyPressed (\widget key modifier -> runReaderT (f widget key modifier) r
14:14:45 <enthropy> at some point I think I understood that library
14:15:29 <chrisdone> onKeyPressed' w f = do r <- ask; onKeyPressed w (\widget key modifier -> runReaderT (f widget key modifier) r)
14:15:31 <chrisdone> something like that
14:16:11 <spaceships> the handler needs to modify state
14:16:15 <d3lxa> can someone explain me the error when I use "unSB" of data ShowBox = forall a. (Show a) => SB { unSB :: a } , that is "Cannot use record selector `unSB' as a function due to escaped type variables", please?
14:16:31 <shachaf> What would the type of unSB be?
14:16:50 <spaceships> i need to use IORefs here, sorry for being confused
14:16:57 <d3lxa> shachaf: for each a instance, ShowBox -> a
14:17:17 <chrisdone> spaceships: IORefs in the reader? seems fine
14:17:31 <d3lxa> shachaf: I see it like this: for type a in (all types) do define ShowBox fieldrecord unSB :: a …
14:17:41 <jophish> Yo yo yo
14:18:27 <jophish> I'd like to return an infinite list of values generated using a strict ST monad
14:18:28 <joe9> I am trying to figure out how to join these 2 functions: http://codepad.org/Sj89eExg to make a function that has the signature of : Device -> IO Bool
14:18:54 <joe9> i tried (>>=) getDeviceDesc (return . identifyDevice), but, could not figure out how.
14:19:11 <jophish> the values are generated by looking up values in a Data.HashTable.ST.Cuckoo.HashTable
14:19:55 <d3lxa> shachaf: my reasoning must be wrong. How do you see unSB then?
14:20:32 <aloiscochard> hey guys,  what's the differenc between '(Foo a, Bar a) =>' and 'Foo a => Bar a', when should I use one vs an other?
14:20:39 <shachaf> d3lxa: I don't understand what you said, but unSB can't be typed in (GHC) Haskell.
14:20:58 <monochrom> I use (Foo a, Bar a) => because I am old-school
14:21:06 <shachaf> Also note that ShowBox is a completely useless type because it's isomorphic to String.
14:21:36 <d3lxa> seem there is my very exact question, there: http://stackoverflow.com/questions/10192663/why-cant-existential-types-use-record-syntax I didn't searched well, sorry
14:22:05 <shachaf> If we had first-class existentials we could write unSB :: ShowBox -> exists a. Show a *> a or something. But we don't.
14:22:21 <monochrom> technically, you can still use some record syntax, just not all of record syntax
14:23:07 <d3lxa> shachaf: why you think it's completely useless? I can pack Show'able things in a list or anywhere and do show them for instance, it's not that useless
14:23:10 <monochrom> "case x of SB{unSB=y} -> show y" is still legal and still counts as record syntax :)
14:23:33 <enthropy> can gfoldl be written for a HList?
14:23:52 <monochrom> you can also pack strings in a list
14:24:35 <d3lxa> ok, yes you're right, so in this example it's useless, but it's serve as illustration of course for more complicated case when you cannot do that
14:24:57 <chrisdone> spaceships: hang on, i'm installing gtk to test this out. i think it's just a case of using liftBase and maybe control
14:25:16 <chrisdone> spaceships: can you give me a gtk hello world with an event handler?
14:25:19 <haasn> d3lxa: “when you cannot do that” example?
14:26:16 <simukis_> How could I read :: ByteString -> Int64 without converting ByteString to String first? What I'm trying to achieve is more effective read after all.
14:26:20 <monochrom> have you seen Oleg's article on existential types? it shows how to get rid of existential types in a large class of more complicated cases.
14:26:44 <d3lxa> haasn: I faced great challenge the other day to factorize my code: I have (KeyBackend a) things and want's to call 'get' over all of them, 'get' requires the KeyBackend instance and runs in a Monad
14:26:48 <monochrom> not to say all cases, but that articles raises the bar very high, probably higher than you'll ever run into
14:27:57 <shachaf> d3lxa: It's surprising how often you can do it. If nothing else, looking at a non-existential alternative will give you some insight about your type.
14:28:23 <d3lxa> monochrom: is this, this article http://okmij.org/ftp/Computation/Existentials.html ?
14:28:24 <chrisdone> spaceships: n/m got a hello world code
14:29:03 <haasn> d3lxa: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:29:11 <haasn> Offers some insight on how you might be able to avoid the existential
14:29:27 <monochrom> yes. you can see I stole from its first example, "you can just use strings themselves" :)
14:29:37 <d3lxa> haasn: it's the 3rd time I've been linked this, so please stop =) I don't *want* to copy paste my bloated lines N times
14:30:04 <haasn> Heh, sorry (I just jumped in to the conversation)
14:30:23 * elliott wonders what copy-pasting has to do with it
14:30:32 <d3lxa> haasn: don't worry, it was a few days ago so, you couldn't possibly know
14:31:20 <chrisdone> `a0 -> b0 α0' -- ugh, i hate it when pople use unnecessary greek in their types
14:31:38 <chrisdone> reeeel easy to read -_-
14:31:57 <sellout-> chrisdone: Is it really harder to read than any other symbol?
14:32:03 <haasn> I hate it when people suffix their type variables with numbers
14:32:12 <chrisdone> sellout-: a and α?
14:32:15 <S11001001> I love using λ and α in my typelambdas
14:32:29 <enthropy> haasn: don't you run out of letters sometimes?
14:32:36 <monochrom> did you know: SML's naming scheme for type variables was to workaround lack of Greek letters back then. 'a was meant to be Greek alpha
14:32:38 <S11001001> oh wait, wrong channel
14:32:57 <haasn> enthropy: no, I don't work with iteratee libraries :)
14:33:07 <chrisdone> the problem is ghc generates names so i'm reading α and a
14:33:11 <sellout-> chrisdone: They look quite distinct to me.
14:33:12 <chrisdone> the potential for confusion is unnecessary
14:33:26 <d3lxa> elliott: basically if I can't use existential quantifiers and do a Any type, I cannot do a forM on my list, I will need to copy/paste the code N times instead of using it once in forM, or so I think
14:33:31 * monochrom has a cunning plan!
14:33:42 <elliott> d3lxa: hmm. I'm not sure I believe that's true, but ok :)
14:33:51 <enthropy> here is what I've got for gfoldl for HLists: http://lpaste.net/93565
14:33:56 <enthropy> it doesn't work
14:34:02 <monochrom> machine-generated type variable names should be like: eh, bee, sea, dii, ...
14:34:21 <d3lxa> elliott: what's bad about a list containing objects with some common instance, then use it and that's all, end of story?
14:34:29 <haasn> monochrom: alpha, bravo, charlie /bravo
14:34:34 <haasn> oops
14:34:37 <enthropy> the problem seems to be hiding that `c'
14:35:11 <haasn> there goes my failed attempt at looking up the list :)
14:35:35 <enthropy> in error messages ghc could use bare numbers
14:35:59 <enthropy> > "a" : "a"
14:36:00 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
14:36:00 <lambdabot>  Expected type...
14:36:10 <Maior> favourite haskell parser lib, anyone?
14:36:16 <enthropy> > join (:) undefined
14:36:17 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
14:36:17 <lambdabot>  Expected type:...
14:36:30 <enthropy> that message could be   0 = [0]
14:36:32 <haasn> Maior: parsec and lookalikes are pretty common
14:36:35 <chrisdone> ideally we wouldn't have to deal with text and argue about what should be presented =)
14:36:41 <haasn> Maior: there's also trifecta which is supposed to be cool but I've never really used it
14:36:46 <Maior> haasn: cheers
14:36:58 <dwcook> joe9, getDeviceDesc >=> return . identifyDevice
14:36:59 <chrisdone> we should be able to access a type error concretely and display them how we prefer
14:37:43 <monochrom> lift :: (Monad bee, MonadTrans eh) => bee a -> eh bee a
14:37:59 <haasn> monochrom: yuck :(
14:38:30 <haasn> GHC should somehow magically pick ‘m’ for Monad and ‘t’ for MonadTrans constraints :)
14:38:50 <haasn> Perhaps something to do with the ‘initials’? I would be fine with ‘mt’ for MonadTrans also
14:39:02 <d3lxa> btw, is there a name for this ~ in typeclass: myFunc :: (Thing m ~ OtherThing val) => … ?
14:39:17 <chrisdone> it's type equality
14:39:24 <enthropy> well it already tries to keep the original type variable name
14:39:24 <monochrom> lift :: (Monad m, MonadTrans t) => m tea'em -> t m tea'em
14:39:26 <chrisdone> @google ghc manual type equality
14:39:27 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
14:39:27 <lambdabot> Title: GHC/Type families - HaskellWiki
14:39:40 <d3lxa> chrisdone: thank you =)
14:40:07 <chrisdone> monochrom: you could also display types as colors =)
14:41:04 <chrisdone> lift :: (Monad <red>, MonadTrans <blue>) => <red> <green> -> <blue> <red> <green>
14:41:14 <monochrom> lift :: (Monad colour7f7f7f, MonadTrans colour6f6f6f) => colour7f7f7f colour040404 -> colour6f6f6f colour7f7f7f colour040404
14:41:18 <chrisdone> =]
14:41:21 <enthropy> couldn't match expected type <blink>a</blink>
14:41:39 <Maior> iä
14:41:44 <haasn> chrisdone: lift :: (Monad █, MonadTrans █) => █ █ -> █ █ █?
14:41:57 <copumpkin> is that the NSA type?
14:42:02 <monochrom> hahaha
14:42:10 <chrisdone> haasn: i have to enable colors in my irc client. hang on
14:42:30 <d3lxa> ahah, what the :P
14:42:38 <enthropy> colors aren't enabled in this channel I think
14:42:50 <haasn> enthropy: indeed they aren't. :(
14:42:52 <Gracenotes> I yes, it's +c
14:42:53 <monochrom> no need, by my Decree, this channel has +c, colour codes are killed
14:43:04 <elliott> I wish we had colours. that would be so cool.
14:43:19 <chrisdone> monochrom: temporarily re-enable so we can see the rainbow types!
14:43:31 <monochrom> yeah
14:43:32 --- mode: ChanServ set +o monochrom
14:43:37 --- mode: monochrom set -c
14:43:39 <haasn> lift :: (Monad 3█, MonadTrans 4█) => 3█ 7█ -> 4█ 3█ 7█?
14:43:43 <chrisdone> hahaha. awesome!
14:43:44 <monochrom> \∩/
14:43:47 <haasn> :)
14:43:58 <haasn> Somebody write this patch to GHC.
14:44:01 <Maior> cute
14:44:06 <chrisdone> we are all suddenly experiencing synesthesia
14:44:16 <elliott> finally I can express myself!
14:44:24 <elliott> this might get out of hand.
14:44:34 <enthropy> monads are like green
14:44:38 <chrisdone> hahaha
14:44:46 <chrisdone> 'transformers are like red blobs...'
14:44:59 <enthropy> the start of a new age of monad tutorials
14:45:24 <chrisdone> monads are just blues in the filter of yellows
14:45:28 <chrisdone> problem?
14:45:43 <monochrom> I prefer gray scale. simple gray scale
14:45:50 <haasn> We don't even need variables in the context
14:46:04 <haasn> lift :: (3Monad, 4MonadTrans) => 3█ 7█ -> 4█ 3█ 7█
14:46:08 <chrisdone> ohhhhh. nice
14:46:33 <chrisdone> that is actually cool. haha
14:46:34 <haasn> That would create some interesting opportunities for MPTCs
14:46:41 <haasn> Blend the colors together?
14:47:03 <haasn> Even better, gradient
14:47:09 <chrisdone> lol
14:47:14 <haasn> Blended colors would be equality constraints
14:47:20 * oleo screws haasn's monads!
14:47:40 <enthropy> background color + foreground color for MPTCs
14:47:49 <enthropy> most are two parameters anyways, right?
14:49:03 <tomejaguar> Is there a good reason I can't do "let x = Maybe \a b -> ..." but instead I have to do "let x = Maybe (\a b -> ...)"?
14:49:32 <monochrom> easier for the compiler writer
14:49:39 <chrisdone> i don't think so, i think it's just convenience for parsing
14:49:40 <joe9> dwcook: not sure why: http://codepad.org/xVe9XYi7 but I get this message
14:50:00 <monochrom> also, I love parentheses
14:50:11 <chrisdone> i love parentheses more than you, monochrom 
14:50:26 <monochrom> that's good to hear
14:50:28 <chrisdone> i love them \  (o  __o)     / this much
14:50:34 <enthropy>  0308MonadState => 
14:50:39 <enthropy> oops
14:51:07 <tomejaguar> Where did everyone get these colours from?  Is it Christmas?
14:51:09 <chrisdone> monochrom: i basically code haskell like lisp these days. haters gonna hate, but i can edit it easily
14:51:14 <haasn> chrisdone: http://youtu.be/D1sXuHnf_lo
14:51:56 <monochrom> do you mean, you write "f x = (g x x)" for "f x = g x x"?
14:53:20 <aloiscochard> monochrom: so 'Foo a => Bar a' is a syntax which was introduced after '(Foo a, Bar a)' ? only syntax difference?
14:53:22 <chrisdone> monochrom: often, yeah. i tend to cut them out of the top-level expression so as not to be *too* obnoxious
14:53:33 <monochrom> yes aloiscochard
14:53:38 <aloiscochard> ty :)
14:54:02 <haasn> ncatlab is like tvtropes
14:54:34 <haasn> each paragraph has a handful of unknown terms with links to other pages :|
14:56:10 <chrisdone> haasn: in before zah lee complains that it's not ergonomic enough
14:56:16 <chrisdone> er, xah lee
14:57:28 --- mode: monochrom set +c-o monochrom
15:03:25 <derdon> does haskell only have modules or also packages? is there a possibility to group serveral modules that belong together?
15:04:09 <aloiscochard> derdon: soon my friend http://research.microsoft.com/en-us/um/people/simonpj/papers/modules/
15:04:31 <donri> it does have packages
15:05:23 <derdon> hi donri :)
15:05:50 <chrisdone> derdon: one package system is Cabal
15:06:23 <chrisdone> @hoogle cabal manual
15:06:23 <lambdabot> No results found
15:06:27 <chrisdone> @google cabal manual
15:06:28 <lambdabot> http://www.haskell.org/cabal/users-guide/
15:06:28 <lambdabot> Title: Cabal User Guide
15:07:02 <derdon> chrisdone: I don't mean packages in that sense. I mean it as part of the haskell language. e.g. in Go you combine several files to one package. in Python, you can group several modules in one package
15:07:26 <derdon> can packages be part of other packages? how does the syntax look like then?
15:08:10 <chrisdone> nope there's no language level support like that
15:08:20 <aloiscochard> derdon: look at that link I just sent...
15:08:25 <chrisdone> there're some extensions for package imports, but it's an extension
15:08:28 <Maior> derdon: look at cabal etc.
15:08:28 <byorgey> recursive packages would be very cool, I think
15:08:32 <haasn> chrisdone: I was just wondering about that.. what does the PackageImports pragma do, on a theoretical levle?
15:08:35 <byorgey> but we don't have them
15:08:50 <derdon> ok, thanks for the answers
15:08:56 <chrisdone> it's not like common lisp with a language-level package system
15:09:04 <haasn> GHC (which is not Haskell) provides a concept of ‘packages’ via ghc-pkg, doesn't it?
15:09:41 <chrisdone> yeah
15:09:59 <chrisdone> most haskell implementations assume cabal as the package system
15:10:08 <quchen> watermind: No, there are no laws connecting Applicative and Alternative. Most of the time `empty <*> x ≡ empty` though.
15:10:35 <enthropy> derdon: a module can re-export other modules which covers some use-cases
15:10:38 <quchen> watermind: And there is another difference between Alternative and Monoid, they work on different-kinded types.
15:11:33 <derdon> enthropy: so it's not bad style if one imports some value from module B, although module B only exposes this value by importing it from module A?
15:11:53 <aloiscochard> sounds like cyclic dependency
15:11:56 <derdon> no
15:12:02 <derdon> it's not cyclic
15:12:08 <derdon> A -> B -> C
15:12:14 <aloiscochard> oh yeah, I miss the C
15:12:41 <enthropy> derdon: I think that's a pretty common thing to do
15:12:49 <derdon> in Python it would be bad style, because one should import the objects from the place where they have been defined
15:13:22 <derdon> so how does one solve the issue of organising modules in a hierarchy?
15:13:35 <enthropy> a library might be organized as  X.A X.B X.C, and then users can get everything with just an  import X
15:15:04 <derdon> enthropy: but if I do ``import X``, I import only all values that are accessible in the file X.hs, don't I?
15:15:37 <enthropy>  module X ( module X.A, module X.B ) where import X.A; import X.B -- this is allowed
15:15:39 <derdon> so then I would import all public functions in X.hs so that they are accessible directly from there?
15:15:49 <derdon> ah
15:16:10 <NemesisD> i'm trying to write a function that's like mOpenFile :: Maybe FilePath -> IO (Maybe Handle), currently trying to use MaybeT IO Handle but i'm having trouble
15:16:30 <Iceland_jack> Why do you want the input to be wrapped in a maybe?
15:17:04 <dwcook> joe9, did you read my message?
15:17:09 <danr> NemesisD: what's mOpenFile Nothing supposed to do?
15:17:27 <enthropy>  return Nothing
15:17:27 <dwcook> joe9, maybe you misread (>=>); that was not a typo
15:17:28 <NemesisD> danr: return Nothing
15:18:02 <Iceland_jack> NemesisD: fmap?
15:18:08 <NemesisD> the implementation right now looks something like mOpenFile mPath = runMaybeT $ do path <- mPath; openFile path WriteMode
15:18:28 <NemesisD> this seems like i'm taking the wrong approach here
15:18:53 <enthropy> @type openFile
15:18:53 <lambdabot> Not in scope: `openFile'
15:19:06 <NemesisD> openFile :: FilePath -> WriteMode -> Handle
15:19:11 <NemesisD> IO Handle*
15:19:23 <NemesisD> erm FileMode or something, you get the point
15:19:51 <enthropy> you could have:    runMaybeT $ do path <- MaybeT (return mPath); fmap Just (openFile path WriteMode)
15:19:59 <Iceland_jack> Yes but why do you want the (Maybe Handle) wrapped in the IO monad?
15:20:04 <Maior> I fear I'm about to use typeclasses inappropriately because I'm thinking in oop-y ways
15:20:06 <enthropy> you could have:    runMaybeT $ do path <- MaybeT (return mPath); MaybeT (fmap Just (openFile path WriteMode))
15:20:27 <enthropy> but you might notice that MaybeT is making things longer
15:20:29 <NemesisD> Iceland_jack: because i'm using it in a large IO in main
15:20:48 <haasn> :t traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
15:20:48 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
15:20:49 <NemesisD> later i need to conditionally act on it if its a Just, conditionally close the handle if its a Just
15:20:56 <enthropy> might be that fail does the right thing for MaybeT
15:21:29 <haasn> :t traverse readFile
15:21:30 <lambdabot> Traversable t => t FilePath -> IO (t String)
15:21:34 <enthropy>  runMaybeT $ do Just path <- return mPath; h <- lift (openFile path WriteMode); return h
15:22:52 <NemesisD> ooh the traversable solution is pretty slick
15:23:09 <NemesisD> might need to flip openFile
15:23:41 <haasn> traverse (openFile ?? ReadMode) :)
15:23:43 <Maior> :t flip
15:23:43 <lambdabot> (a -> b -> c) -> b -> a -> c
15:23:51 <joe9> dwcook, ok, thanks.
15:23:55 <spaceships> :t (??)
15:23:56 <NemesisD> haasn: is that a real thing?
15:23:56 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:24:00 <haasn> NemesisD: yes
15:24:04 <NemesisD> waaaat?
15:24:09 <haasn> NemesisD: (??) = flip
15:24:25 <NemesisD> oh man i'm not sure if that's evil or brilliant
15:24:44 <haasn> both
15:24:55 <NemesisD> haasn: is that from somewhere standard or did you define it?
15:25:09 <joe9> dwcook: thanks. I thought you meant >>=. thanks. it works.
15:25:14 <haasn> NemesisD: yes, it's from Control.Lens ;)
15:25:20 <NemesisD> i read it as infix for why th earguments for this backwards??
15:27:47 <Guest39484> I'd love to hear opinions on whether it is better to post Haskell questions on reddit or stackoverflow....
15:27:57 <haasn> #haskell
15:28:39 <derdon> ack. here are the best ones :)
15:29:04 <chrisdone> stackoverflow is the best place to get answers
15:29:13 <chrisdone> reddit is the best place to get some answers and some irrelevant discussion
15:29:27 <derdon> #haskell is the best place to learn something
15:30:16 <Maior> for long-form questions, I like SO + IRC
15:30:35 <chrisdone> although the socratic method doesn't quite work out because it's like there are ten socrateses all at different levels of competencies asking you questions at once and contradicting and correcting oneanother
15:30:36 <Guest39484> derdon- agreed, but when things turn a bit more esoteric, I think posting becomes more important, to get a larger pool or respondents.
15:30:39 <haasn> Post on SO and link it to IRC so I can see and respond :)
15:31:20 <Guest39484> OK, SO it is then....
15:32:20 <Cale> If you ask me, I would recommend always trying IRC first
15:32:54 <bennofs> I think reddit is better suited for more opinion-based questions, whereas stackoverflow is better for technical questions
15:32:56 <Cale> and then, if nobody seems to know, *maybe* you could try SO, but you're probably better off just going straight to the mailing lists.
15:33:09 <derdon> bennofs: haha, that was good
15:33:22 <Cale> (i.e. haskell-cafe probably)
15:33:38 <chrisdone> i think SO is better for the immediate community
15:33:51 <chrisdone> answers in haskell-cafe tend to get lost in a sea of irrelevancy
15:34:07 <derdon> bennofs: the last threads I have seen on SO were something like "what are the best computer science/programming books?", "what is the most surprising equation/formula?", "what is your favourite proove?"
15:34:07 <chrisdone> SO gets you google results every time and the question/answer get updated to be more appropriate, etc.
15:34:31 <chrisdone> but it's true that more people are reading the mailing list (i think) than SO
15:35:41 <Thulsadum> if a module hasn't a list of exported functions, it exports everything by default. does that also affect imported symbols from other modules?
15:35:56 <chrisdone> you mean will it re-export things you imported? no
15:36:09 <Thulsadum> yep, thank you
15:36:09 <Cale> Well, and if the question is hard enough that we can't answer it here, then at least I know the *right* people are watching cafe to maybe be able to answer something more technical.
15:37:08 <Thulsadum> so circular dependencies of modules are not a problem? if module A imports B and vice-versa?
15:37:22 <Thulsadum> (yes, it's a design flaw)
15:37:45 <chrisdone> in haskell, circular dependencies are not supposed to be problematic, but in ghc it's disallowed
15:38:04 <chrisdone> there's some fiddling/messing you can do with special files to facilitate it, but it's more of a kludge
15:38:15 <quchen> Thulsadum: A module only exports its own top level definitions, not everything it has in scope. If you want to re-export, you'll have to do it explicitly.
15:38:36 <derdon> I'm an idiot. ``ghc foo.hs && ./foo.hs`` is of course much faster than ``runhaskell foo.hs``
15:38:47 <chrisdone> so in general you have to do dependency separation and make an AB module which both A and B import
15:38:48 <quchen> derdon: Is it? Why?
15:38:54 <joe9> what is the [] equivalent for Data.Vector?
15:38:59 <chrisdone> empty
15:39:07 <joe9> chrisdone: ok, thanks.
15:39:18 <chrisdone> (although i tend to use the monoid function mempty for monoids)
15:39:48 <derdon> quchen: because ghc foo.hs compile the source file to binary which you can run later whereas runhaskell runs it "directly"; I guess it's interpreted then instead of compiled first
15:39:58 <joe9> chrisdone: this has an error : http://codepad.org/pRIkGrrA
15:40:10 <quchen> derdon: Ah, runhaskell is GHCi-based? Makes sense then
15:40:18 <derdon> quchen: yep, I think so
15:41:02 <chrisdone> does it definitely use ghci? it could compile with -O0 and run the binary
15:41:34 <joe9> chrisdone: what is the equivalent of x:[] for vector?
15:42:06 <chrisdone> joe9: i don't think any constructors are exported for vectors =(
15:42:27 <enthropy> there's probably a function singleton
15:42:33 <ubikation> hey what is a good example snap project I can learn from on github or something?
15:42:42 <enthropy> singleton :: a -> Vector a
15:42:43 <joe9> chrisdone: so, I would have to explicitly use pattern guard then?
15:43:08 <chrisdone> joe9: yeah, or a view pattern
15:43:25 <joe9> chrisdone: thanks, let me read up on view patterns.
15:44:29 <chrisdone> joe9: it doesn't seem like vector provides a useful deconstructing function for getting the 'head'
15:44:54 <chrisdone> the closest i can tell is: V.find (const True)
15:45:10 <joe9>  chrisdone: I want to match when it is an empty or a one element vector.
15:45:34 <bennofs> joe9: Use V.length < 2 ?
15:45:50 <joe9>  http://codepad.org/SAkQgxkf
15:45:51 <arkeet> please don't.
15:46:03 <arkeet> oh, vector. not list
15:46:12 <arkeet> carry on.
15:46:21 <joe9>  http://codepad.org/v5OrJ6UG
15:47:07 <bennofs> arkeet: what is the recommended solution for lists? I find myself often using null xs || null (drop 1 xs)
15:47:29 <chrisdone> seems like a good approach
15:47:33 <bennofs> Hmm, I don't need that first null at all.
15:47:41 <chrisdone> or just (_:_:_)  = "woot"
15:47:59 <arkeet> bennofs: null (drop 1 xs) is enough.
15:48:04 <Ghoul__> is there any reason why the solution to circular dependencies isn't just to parse and compile types separately to bodies and functions
15:48:07 <arkeet> because drop 1 [] = []
15:48:09 <watermind> quchen: indeed they are defined in different kinded types, but that seems irrelevant... since it imposes a restriction that is not needed at all by those laws
15:48:20 * bennofs thinks he wrote null xs || null (tail xs) || null (tail $ tail xs) somewhere ....
15:48:23 <chrisdone> joe9: yeah that's alright i guess
15:48:26 <arkeet> oh dear.
15:48:35 <chrisdone> joe9: although myDevice = V.find (const True) is equivalent
15:48:44 <arkeet> or use a version of length for lazy nats
15:48:45 <arkeet> ;)
15:49:00 <watermind> quchen: it just seems a bit weird because it feels rather hackish -  all we want is Monoid + Applicative, but we may want another monoid other than the default one, so we just call it Alternative and make it a super class of Applicative for no reason other than that's what we want you use it with
15:49:03 <bennofs> arkeet: are lazy nats somewhere in base?
15:49:17 <arkeet> I don't think so.
15:49:24 <Iceland_jack> > length (zip [1..2] "hi") == 2 -- ? :)
15:49:25 <lambdabot>   True
15:49:36 <arkeet> Iceland_jack: =(
15:49:41 <bennofs> :P
15:50:00 <chrisdone> myDevice = V.foldr (const . Just) Nothing
15:50:01 <Iceland_jack> or rather, < 3
15:50:04 <chrisdone> is also equivalent
15:50:29 <quchen> watermind: I think the main reason there are no laws for Alternative+<*> is that people can't agree on which ones there should be.
15:50:30 <bennofs> Iceland_jack: that list's length will always be < 3
15:50:33 <chrisdone> or simply
15:50:40 <chrisdone> myDevice = listToMaybe . V.toList
15:50:50 <Iceland_jack> ah derp, stupid of me
15:50:53 <bennofs> :)
15:50:54 <haasn> > hasn't (ix 100) [1..]
15:50:56 <lambdabot>   False
15:51:02 <chrisdone> * bennofs thinks he wrote null xs || null (tail xs) || null (tail $ tail xs) somewhere ....
15:51:02 <chrisdone> bennofs: why not just pattern match?
15:51:08 <watermind> quchen: that sounds like a good reason not to have Alternative ...
15:51:11 <quchen> watermind: Morally, you should assume at least empty <*> x = empty.
15:51:35 <watermind> quchen: reminds me of MonadPlus long ago
15:51:37 <bennofs> chrisdone: Idk, I don't remember the place where I did that anymore
15:51:47 <quchen> watermind: MonadPlus is Alternative plus some laws.
15:51:51 <watermind> quchen: where everybody was using it but no one was sure of its semantics
15:51:58 <quchen> watermind: People also disagree on the MonadPlus laws by the way. :-)
15:52:07 <watermind> quchen: yes my point precisely :/
15:52:31 <quchen> Yup … well, at least Alternative has some Monoid-y laws attached to it so it's not completely void
15:52:43 <chrisdone> joe9: i think myDevice = V.foldr (const . Just) Nothing is best
15:52:45 <watermind> yeap but still
15:52:53 <burbul> :t foldl (>>=)
15:52:54 <lambdabot> Monad m => m a -> [a -> m a] -> m a
15:53:04 <burbul> :t foldM (flip ($))
15:53:05 <lambdabot> Monad m => a -> [a -> m a] -> m a
15:53:14 <burbul> I can't decide which of those is nicer.
15:53:27 <burbul> [Obviously the type signatures cvary a bit, but
15:53:34 <chrisdone> well, they're different, so…
15:53:36 <burbul> I can use either.]
15:53:38 <quchen> watermind: By the way, the AMP will introduce Alternative => MonadPlus, giving empty = mzero; <|> = mplus as default implementations. That means Alternative will be more likely to obey some laws. And by "more likely" I mean "depends on the programmers really".
15:53:41 <joe9> chrisdone: thanks.
15:53:57 <burbul> I have a value of type m a
15:54:09 <joe9> it kinda sucks that you cannot pattern match with vector.
15:54:10 <chrisdone> burbul: foldl (>>=) is nicer to me
15:54:11 <burbul> I can either use it directly in foldl or
15:54:23 <burbul> >>= into the result of foldM
15:54:31 <joe9> http://codepad.org/baSqIX6Q MyDevice.hs:52:11: Qualified name in binding position: V.empty
15:54:41 <watermind> quchen: that (most likely) makes sense
15:54:57 <haasn> :t foldr (>=>) id
15:54:58 <lambdabot> Monad m => [m c -> m (m c)] -> m c -> m c
15:55:02 <haasn> :t foldr (>=>) return
15:55:03 <lambdabot> Monad m => [c -> m c] -> c -> m c
15:55:06 <Maior> :t (>=>)
15:55:06 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:55:17 <c_wraith> joe9: you can only match on constructors, not expressions
15:55:22 <Maior> :t (.)
15:55:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:55:41 <Maior> :t flip .
15:55:41 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:56:04 <burbul> :t flip (.)
15:56:05 <lambdabot> (a -> b) -> (b -> c) -> a -> c
15:56:12 <Maior> heh cheers
15:56:38 <watermind> quchen: do you know if the AMP is really going to be part of some near future standard?
15:56:39 <haasn> c_wraith: this is why we need first class support for prisms!!
15:57:39 <quchen> watermind: It's part of GHC 7.8. Seeing how GHC is the standard compiler and the proposal was unanimously accepted, I'd say the chances of it becoming *Haskell* are pretty good.
15:57:41 <chrisdone> you could implement a Match class like Match t cs where match :: t -> Maybe cs
15:57:58 <watermind> quchen: oh I didn't know it was part of 7.8
15:58:24 <arkeet> quchen: a lot of GHC extensions aren't *Haskell*
15:58:24 <arkeet> =(
15:58:27 <chrisdone> and then instance Match (Vector a) (a,Vector a) and then
15:58:27 <chrisdone> and then foo (match -> (x,xs)) = …
15:58:27 <quchen> watermind: Phase one is, to be precise. Applicative => Monad is not in there, but it warns you if you have a Monad without Applicative.
15:58:36 <chrisdone> if Just was implicit in viewpatterns
15:58:42 <quchen> watermind: The actual switch will probably be in 7.10.
15:58:52 <watermind> right
15:58:53 <chrisdone> but you have to write foo (match -> Just (x,xs)) = … -_ -
15:59:10 <mangaba_leitosa> LOL "Inverting functions can make our lives a lot easier. Consider the example of parsing. A parser takes a string and returns a syntax tree. Writing a parser directly is a non-trivial task. However, generating a string from a syntax tree is just a simple functional programming exercise. So we can implement a parser in a simple way by writing a converter from syntax trees to strings and inverting it"
15:59:30 <quchen> arkeet: But the AMP isn't some experimental cool new feature, it fixes something that has been regarded as an error for a long time.
15:59:43 <mangaba_leitosa> an example of Curry at work :-)
15:59:44 <c_wraith> ...  sure.  If you want to parse only exactly the strings your pretty-printer generates
16:00:10 <chrisdone> c_wraith: is that so?
16:00:29 <c_wraith> chrisdone: well, that's what inverting a pretty-printer would do.
16:00:37 <mangaba_leitosa> c_wraith: you can make you pretty printer to generate all possible variants (with arbitrary amount of whitespace included)
16:01:38 <chrisdone> c_wraith: yeah, i suppose starting from a printer is the restricted side
16:02:08 <mangaba_leitosa> c_wraith: that is, instead of "a+b" returning a list ["a+b", "a + b", "a+ b", "a +b", ...]
16:02:39 <chrisdone> hmm
16:03:03 <c_wraith> mangaba_leitosa: yes, you could introduce nondeterminism to make it better-behaved - but at that point, you're doing all the work required for a parser anyway.
16:03:27 <chrisdone> but the inversion presumably means changing 'consume' to 'produce', so it seems more complicated
16:04:41 <mangaba_leitosa> c_wraith: no, I think that generating the list like above is still easier than parsing :-)
16:05:33 <c_wraith> It's more or less identical to writing a parser with a good library.  Indicate places where there are optional tokens, etc.
16:05:36 <chrisdone> mangaba_leitosa: are you sure that's sufficient to generate a parser with? doesn't seem right
16:05:57 <c_wraith> chrisdone: it is sufficient, though *sloooow* if done naively.
16:06:38 <mangaba_leitosa> chrisdone: this is from "A taste of Curry" where there is tiny example for parsing (2 + 2) demonstrating this approach: http://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/
16:07:19 <mangaba_leitosa> chrisdone: Curry is like Haskell with Prolog-like features :-)
16:08:02 <chrisdone> ah, it's logic programming. ok
16:08:06 <mangaba_leitosa> chrisdone: so I installed it just to play with the code from the article
16:08:12 <mangaba_leitosa> chrisdone: "functional logic"
16:08:29 <chrisdone> call it what you like =p
16:09:16 <enthropy> my question earlier is now here: http://stackoverflow.com/questions/19072648/gfoldl-data-data-data-instance-for-hlists-without-unsafecoerce
16:09:16 <mangaba_leitosa> chrisdone: the syntax is identical to haskell and you can write it without using logic features, then it will be just haskell :-)
16:09:33 <mangaba_leitosa> chrisdone: so functional, too
16:10:17 <chrisdone> mangaba_leitosa: sure, i meant the methodology, not the language. i presumed you were writing a straight functional parser in plain haskell and inverting it
16:10:30 <chrisdone> s/parser/printer
16:10:49 <mangaba_leitosa> chrisdone: yes, that would be a LOT trickier, so I LOL at the quote :-)
16:11:15 <chrisdone> it's an interesting idea tho
16:11:37 <chrisdone> there's a haskell library for parsing/printing your data types with json but you write it as one thing
16:12:36 <chrisdone> boomerang!
16:12:49 <chrisdone> http://hackage.haskell.org/package/boomerang-1.4.0
16:13:07 <mangaba_leitosa> chrisdone: cool
16:13:15 <chrisdone> “Boomerang is a DSL for creating parsers and pretty-printers using a single specification. Instead of writing a parser, and then writing a separate pretty-printer, both are created at once. This saves time, and ensures that the parser and pretty-printer are inverses and stay in-sync with each other.”
16:13:18 <chrisdone> :3
16:13:29 <mangaba_leitosa> yes, the same approach :-)
16:14:52 <NemesisD> in any code where i need to use json and I define FromJSON/ToJSON instances i always have a quickcheck property for ToJSON/FromJSON roundtrip
16:15:36 <chrisdone> yeah. don't bother with quickcheck. use boomerang! =)
16:16:23 <NemesisD> are there any examples of boomerang for json?
16:17:40 <chrisdone> hmm
16:17:57 <chrisdone> seems that martijn's only json example is with his old jsongrammar library http://martijn.van.steenbergen.nl/journal/2011/05/08/introducing-jsongrammar/
16:18:06 <mangaba_leitosa> Haskell's Data.List.subsequences is defined in Curry as easily as 'subsequences (_ ++ l ++ _) = l'
16:18:10 <chrisdone> seems that boomerang possible supercedes it if it is generic upon the token type
16:18:15 <NemesisD> because now the task is write an equivalent or better JSON parsing/encoding library than bos. no small feat ;)
16:18:55 <chrisdone> well, you wouuld use aeson as a token type
16:18:59 <chrisdone> and parse the json
16:19:06 <derdon> can I describe the signature of inner functions? If yes, how does the syntax look like?
16:19:12 <chrisdone> i mean, parse the JSON as in, the Value, not the string
16:19:25 <NemesisD> derdon: inner functions?
16:19:32 <chrisdone> weird, there doesn't seem to be an example online of using aeson with boomerang
16:19:34 <derdon> the inner function is defined by using "let f = ... in"
16:19:51 <Eduard_Munteanu> Let  'data Index = Foo | Bar' 'data Entity :: Index -> * where ...'  and I want to do  'entityP :: Parser (Entity i)' 'entityP = fooP <|> barP'. However that won't work, I want a 'Parser (exists i. Entity i)' possibly.
16:20:08 <Eduard_Munteanu> What's a good approach to get that sort of thing working?
16:20:33 <FreeFull> How can I use cabal to compile some example code for a library, when the library is only installed in a sandbox?
16:20:53 <tomejaguar> derdon: http://lpaste.net/93568
16:20:59 <FreeFull> Actually, not necessarily using cabal
16:21:01 <FreeFull> Just some way
16:21:11 <Eduard_Munteanu> Can I avoid boxing it in an existential wrapper?
16:21:41 <derdon> tomejaguar: ah, thank you!
16:22:04 <tomejaguar> derdon: you're welcome
16:22:30 <copumpkin> Eduard_Munteanu: yeah
16:22:35 <copumpkin> I mean, no
16:22:38 <copumpkin> that's what you need to do
16:22:56 <Eduard_Munteanu> Aw...
16:23:04 * Eduard_Munteanu cries for Agda
16:23:05 <copumpkin> one approach is to avoid it in the parser altogether
16:23:05 <chrisdone> lol
16:23:11 <copumpkin> well, you'd need something like that in Agda too
16:23:12 <chrisdone> yeah! i mean no. NEVER!
16:23:14 <copumpkin> you'd just have exists
16:23:20 <copumpkin> which is a data type
16:23:54 <copumpkin> you could construct an unindexed Entity and have the parser produce that, and then another function to recover the index in a universally quantified continuation
16:23:57 <Eduard_Munteanu> copumpkin: yeah, I was hoping to be able to index my parsed data and make it harder to break.
16:24:37 <copumpkin> well, you can still do that :) you'll just need to do more work in the parser where it's kind of awkward
16:24:53 <Eduard_Munteanu> Maybe I should avoid combining different indexes in the same parser.
16:25:22 <copumpkin> it seems like some combinations should be possible to make non-existential
16:25:30 <copumpkin> then when you cross the boundary you'd need the existentila
16:28:10 <Eduard_Munteanu> copumpkin: is something like sigma possible with 7.6, have you tried it? I'm hoping to return a  Sum Index Entity
16:28:39 <copumpkin> nope, haven't tried it
16:29:32 <Eduard_Munteanu> But Index :: BOX, Foo, Bar :: Index and those two aren't inhabited. I'd need to map them to * I suppose.
16:30:18 <Eduard_Munteanu> data IndexSet :: Index -> * where  Foo' :: IndexSet Foo   Bar' :: IndexSet Bar
16:32:51 <Eduard_Munteanu> Then   data Entity :: Index -> * where ...   reflectFoo :: (IndexSet Foo, Entity Foo)   might work.
16:33:23 <Eduard_Munteanu> If I can tie them together. :/
16:43:01 <applicative> FreeFull: something like alias ghc-sandbox="ghc  -package-db ../.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d/"
16:43:10 <applicative> maybe ..
16:45:00 <Eduard_Munteanu> I can just use Either, though. I'll just do that.
16:56:18 <Maior> documentation pointers on "cabal test"?
16:56:38 <Maior> (just reading http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites atm)
16:57:39 <dwcook> I'm having trouble thinking this out fully – What's the least powerful typeclass I need to implement separatedBy1 :: f a -> f b -> f [a], which, e.g., could be used to make a parser that, given "a,b,c", returns ["a", "b", "c"].
16:58:10 <dwcook> Parsec just implements it in terms of its own Parser type, but it uses Monad operations, and I'm wondering if Monad is *necessary*.
16:58:37 <dwcook> Relevant source: http://hackage.haskell.org/package/parsec-3.1.3/docs/src/Text-Parsec-Combinator.html#sepBy1
16:59:02 <dwcook> And when I say "returns", I mean into the functor
16:59:14 <fizruk> dwcook: Applicative f is sufficient, not sure it's minimal
16:59:27 <dwcook> fizruk, that's what I suspected, though the sequencing part sort of got me
16:59:35 <chrisdone> :t sequenceAa
16:59:36 <lambdabot>     Not in scope: `sequenceAa'
16:59:36 <lambdabot>     Perhaps you meant one of these:
16:59:36 <lambdabot>       `F.sequenceA_' (imported from Data.Foldable),
16:59:51 <fizruk> dwcook: on the second though, Alternative might be necessary too
16:59:57 <applicative> dwcook: this sort of question is developed in https://github.com/ekmett/parsers/blob/master/src/Text/Parser/Combinators.hs#L117
17:00:25 <dwcook> applicative, perfect, that's exactly how I should have implemented it. :)
17:01:12 <dwcook> Oh, what caught me was that I forgot why I would need Alternative there, when I'm sequencing, not taking alternatives… but I *am* taking alternatives
17:01:20 <Makoryu> @pl \_ -> return
17:01:20 <lambdabot> const return
17:02:12 <applicative> dwcook: it's a really cool library. any one thing is sort of obvious, but together its pretty amazing
17:02:53 <fizruk> is there a reason why every Alternative must be an Applicative?
17:02:54 <dwcook> Indeed. I especially like the fact that the "not" parser combinator generalizes.
17:03:10 <dwcook> fizruk, because otherwise it'd just be a monoid?
17:03:37 <dwcook> Or, maybe you're asking why you couldn't have something of kind * -> * that forms a monoid but isn't Applicative, in which case I don't know offhand
17:04:50 <dwcook> fizruk, some and many are implemented in terms of (<*>)
17:04:55 <dwcook> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Applicative.html#some
17:05:22 <fizruk> dwcook: by Alternative I mean empty and <|>
17:05:59 <dwcook> I think it's because that'd be no better than Monoid
17:06:46 <fizruk> dwcook: perhaps :)
17:07:01 <dwcook> See also MonadPlus
17:07:14 <dwcook> which I suspect wouldn't be necessary if Monad implied Applicative
17:07:39 <dwcook> I just implement Alternative's methods exactly as MonadPlus's methods, for example
17:07:47 <dwcook> (Assuming I have Monad for my type)
17:09:12 <dwcook> Hmm, come to think of it, *that* has nothing except mzero and mplus
17:09:37 <dwcook> Maybe there's some language-level complication with just using Monoid?
17:13:41 <fizruk> dwcook: yeah, MonadPlus seems redundant in presence of Applicative
17:14:44 <arkanum> have you seen:
17:14:45 <arkanum> Hewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know, but were afraid to ask)
17:14:55 <arkanum> a video on channel 9 from ms
17:15:09 <dwcook> I've thought of two reasons you'd want monoid specifically for * -> *: (1) The type argument can be anything and it doesn't change the instance used. (2) You want instances to follow certain laws.
17:16:44 <Makoryu> http://bestinclassblog.tumblr.com/post/21867047812/pitting-j-against-haskell-clojure
17:16:47 <Makoryu> Hmmm
17:16:54 <arkanum> at minute 23:45 Hewitt says that checking account cant be done on functional programming
17:17:09 <fizruk> dwcook: is ArrowChoice somehow a "monoid" for kinds * -> * -> * ?
17:17:52 <arkanum> to be able to implement it on haskell, should actors be used?
17:19:56 <jmcarthur> arkanum: could you describe the problem?
17:20:10 <dwcook> fizruk, I'm unfamiliar with ArrowChoice.
17:20:48 <fizruk> dwcook: me too, just looking here: http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Control-Arrow.html#t:ArrowChoice
17:20:50 <Maior> can anyone point me at a cabal package doing decent testing please?
17:22:17 <dwcook> fizruk, it's not obvious to me that it represents a monoid, but I suppose it could?
17:22:29 <fizruk> dwcook: ah, there exist ArrowZero and ArrowPlus classes
17:22:30 <dwcook> Well, to have a monoid, you need an identity
17:22:32 <dwcook> What would it be?
17:22:40 <dwcook> Aha
17:23:33 <Thulsadum> @hoogle [a]->[b]->[(a,b)]
17:23:34 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
17:23:34 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
17:23:34 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
17:24:32 <pxqr> does Data.HashMap.Strict.toList produce a _sorted_ list?
17:25:26 <applicative> Maior: https://github.com/bos/text/blob/master/text.cabal for example?
17:25:29 <pxqr> ok, it doesn't
17:25:41 <Thulsadum> pxqr: that's not the point of a HashMap
17:26:14 <pxqr> Thulsadum: well I should use a Data.List.sortBy (comparing fst) then?
17:26:40 <pxqr> I should sort a bunch of bytestrings
17:26:57 <pxqr> Data.List.sortBy kinda slow, doesn't it?
17:27:37 <Thulsadum> I'm not that deep into haskell, yet, sry. but a HashMap should destribute the keys optimal and that's mostly not in sequence :D
17:28:05 <applicative> Maior: hah, check out https://github.com/JHawk/enterpriseFizzBuzz
17:28:52 <Maior> applicative: cheers
17:29:31 <Maior> applicative: got any with detailed-whatever?
17:30:43 <Eduard_Munteanu> Grr, why doesn't Haskell have a type-level lambda yet?
17:33:09 <Iceland_jack> Eduard_Munteanu: And type-level lets!
17:33:43 <Eduard_Munteanu> That'd be nice too, yeah.
17:33:46 <Eduard_Munteanu> Agda has those.
17:34:27 <Iceland_jack> yeah, some people that I know were aware of the type-level lambda in Agda but not that you could write lets or define if_then_else_s
17:34:47 <Iceland_jack> It's obvious.. perhaps in retrospect
17:34:56 <sm> hi all. I need a little data structure advice for a hledger report. I'm building up a 2d array of values (balances) indexed by strings (account names) on one axis and dates on the other. I need to construct it from column values (eg) and then query for specific rows or columns or whatever.
17:35:01 <sm> I was using lists and transposing which worked but seems a bit error-prone. Now I'm thinking about arrays and maps.
17:35:47 <sm> and wondering is there such a thing as a 2d map ?
17:36:37 <Maior> how true is http://stackoverflow.com/a/18686329/928098 wrt ?There is not much support for detailed-0.9 out there?
17:38:19 <Maior> https://github.com/search?q=detailed-0.9+extension%3Acabal&type=Code&ref=searchresults isn't inspiring
17:38:31 <arkanum> jmcarthur: they were discusing that a checking account can make a withdrawal from anywhere
17:38:38 <sm> the amount of data is small. I'm looking for a structure that makes the implementation clear and easy to get right.
17:38:50 <arkanum> and the checking account is somewhere else
17:39:03 <arkanum> http://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask
17:39:29 <arkanum> 23:30
17:39:33 <zRecursive> when running bootstrap.sh in cabal-install, it reports "curl: (22) The requested URL returned error: 404 \nError during cabal-install bootstrap:"
17:39:59 <Maior> oh, as an aside, does anyone know anything about bootstrapping a ghc build?
17:40:35 <arkanum> zRecursive: check the url you're using
17:40:46 <zRecursive> arkanum: where ?
17:40:54 <arkanum> script
17:41:08 <arkanum> ping it, maybe link is broken
17:41:40 <zRecursive> in bootstrap.sh there is HACKAGE_URL="http://hackage.haskell.org/packages/archive"
17:42:30 <jmcarthur> arkanum: i think they are just talking about nondeterminism
17:42:55 <jmcarthur> arkanum: there are many ways to implement this in haskell. most involve some sort of nondeterminism.
17:43:02 <jmcarthur> s/most/all/ from the right point of view
17:43:42 <zRecursive> arkanum: when visiting http://hackage.haskell.org/packages/archive, it reports "page not found" in browser
17:43:42 <jmcarthur> arkanum: you could use actors, sure, or you could just use one of the other concurrency primitives like MVars, Chans, STM, whatever
17:44:00 <jmcarthur> s/other/existing/
17:45:59 <zRecursive> can anybody visit http://hackage.haskell.org/packages/archive now ?
17:46:15 <arkanum> zRecursive: check what package it needs, look it on hackage and copy paste the link
17:46:58 <zRecursive> arkanum: how to check what package it needs ?
17:47:43 <zRecursive> when "Downloading Cabal-1.19.0...", bootstrap.sh exits
17:49:12 <augur> i dont see why its so hard for people to understand what referential transparency is about
17:49:40 <arkeet> it is?
17:50:18 <arkanum> zRecursive: what os are you using? are you trying to install cabal?
17:50:21 <augur> arkeet: it seems to be. everyone i talk to about it is just thoroughly baffled
17:50:27 <arkeet> weird
17:50:45 <arkeet> maybe they just don't get how effectful stuff is possible in a RT world
17:50:57 <arkeet> I dunno.
17:51:01 <augur> what?
17:51:02 <zRecursive> arkeet: freebsd 9, seems no cabal-1.19.0, i will try cabal-1.18.1
17:51:10 <arkeet> what?
17:51:19 <augur> im not sure what you mean to say there, arkeet
17:51:33 <arkeet> I meant to say what I said, I think.
17:51:54 <augur> yeah but i dont know what you mean by that :P
17:52:14 <arkanum> zRecursive: install it from the ports
17:52:16 <arkeet> maybe they're just confused about how stuff like getLine works when everything is supposed to be referentially transparent.
17:52:30 <arkeet> I dunno.
17:52:35 <augur> arkeet: no no
17:52:44 <augur> they just dont get what referential transparency is in the first place
17:52:47 <arkeet> oh, well.
17:52:49 <arkeet> I don't know what to say, then.
17:52:54 <augur> and even when i explain it, they think "isnt that what i said?"
17:52:55 <augur> and its like
17:52:56 <zRecursive> arkeet: is cabal-install in ports ?
17:53:01 <augur> no, its definitely not
17:53:04 <arkeet> zRecursive: why are you asking me
17:53:20 <augur> arkeet: because arkanum
17:53:34 <arkeet> wuh
17:53:38 <zRecursive> arkanum: is cabal-install in ports ?
17:53:39 <arkanum> jmcarthur: so, there is no actor package from haskell? is either STM or forks?
17:53:42 <augur> arkeet: ark-tab
17:54:12 <jmcarthur> arkanum: it's not hard to roll your own actors
17:54:42 <sm> there are a bunch of them on hackage
18:02:33 <zRecursive> i guess there is problem in haskell site
18:03:42 <sclv> cloud haskell is actors based
18:03:47 <sclv> i.e. distributed-process
18:03:58 <sclv> that's the supported actively developed erlang-alike
18:04:43 <Iceland_jack> sclv: Do you know if there has been any recent development with distributed-process?
18:04:53 <sclv> yes
18:05:01 <sclv> it is under active development
18:05:06 <sclv> although there hasn't been a new release in a while
18:05:15 <sclv> the list is active and has discussions
18:05:41 <Iceland_jack> I see, I haven't been following the lists for a year or so
18:06:42 <Iceland_jack> Any nifty features/fixes? Is it long until usable in production? :)
18:06:56 <sclv> it is usable and used in production now
18:07:06 <sclv> the main action afaik is in the additional libs on the side
18:07:22 <sclv> also overhauls of backends
18:07:26 <Iceland_jack> Oh I see, shame on me for not keeping up
18:07:27 <sclv> to make them more stable and also flexible
18:08:27 <Iceland_jack> So currently TH is used to handle the closures, someone mentioned making it a part of the compiler/language?
18:08:28 <fryguybob> sclv: I didn't get to say an offical goodbye.  It was great to see you again and thanks so much for the wonderful community building that you do!
18:10:40 <enthropy> Iceland_jack: well TH is part of the compiler/language
18:11:23 <Iceland_jack> Yes, I meant doing it without the need for TH: sorry for the ambiguity
18:11:29 <enthropy> there's a good outline of the problem with trying to make everything serializable somewhere on the haskellwiki I think
18:11:31 * enthropy looks
18:16:10 <sclv> fryguybob: yeah, i had to take off for work. sounds like i missed a great day of talks. great to see you too, sure i'll see you at the next hacphi if not sooner :-)
18:16:33 <sclv> Iceland_jack: you can do the closures w/o template haskell. i sent a patch to the list showing how to do this ages ago
18:16:42 <sclv> i think it got stalled behind other work for merging it in.
18:16:50 <sclv> its a bit more noisy, but equally expressive
18:16:57 <sclv> full serialization is an entirely different issue
18:17:25 <Iceland_jack> Hm
18:23:38 <FreeFull> jaspervdj: The io-streams version of websockets is working perfectly so far. The client.hs example has unnecessary liftIO (Probably left over from old version)
18:35:35 <sm> is it possible to document the elements of a tuple with haddock ?
18:36:32 <sm> similar to the fields of an ADT ?
18:37:35 <chrisdone> preflex: sup
18:38:10 <chrisdone> @quote
18:38:10 <lambdabot> Makoryu says: The C type system is only there to facilitate compiler-blessed operator overloading and occasionally warn you if the building is on fire
18:38:39 <chrisdone> @faq  can haskell warn me about combustible construction?
18:38:39 <lambdabot> The answer is: Yes! Haskell can do that.
18:38:42 <prefIex> chrisdone: not much
18:39:09 <chrisdone> prefIex: was it worth it?
18:39:16 <prefIex> chrisdone: definitely
18:39:24 <chrisdone> ヽ (＾▽＾) ﾉ
18:39:30 <prefIex> I hope you're not using a fixed-width font :(
18:39:40 <chrisdone> of course i am, this is irc
18:39:47 * prefIex weeps at the antiquity
18:40:00 <Makoryu> Huh
18:40:04 <Makoryu> Did I really say that
18:40:20 <chrisdone> http://i.imgur.com/QqVrzuH.gif ← the pipe is irc, the cat is us
18:40:29 <copumpkin> lol
18:46:51 * zRecursive i still cannot install cabal-install :(
18:48:35 <enthropy> sm: the best you can do is probably     (a,b) -- ^ @(a,b)@ \n\n -- [@a@] blah blah\n\n -- [@b@] blah blah
18:48:44 <dwcook> zRecursive, just get it off of cabal
18:48:59 <dwcook> Surprisingly relevant nick
18:49:04 <zRecursive> dwcook: what do you mean ?
18:49:09 <dwcook> zRecursive, I was making a joke
18:49:27 <zRecursive> the hackage seems broken now
18:50:23 <sm> enthropy: I think haddock doesn't allow -- ^ beside tuple elements
18:50:29 <applicative> zRecursive: do you already have a cabal-install executable?
18:51:02 <zRecursive> applicative: not yet, i just install ghc-7.6.3 on freebsd
18:51:07 <applicative> zRecursive: what version of Cabal does 'ghc-pkg list Cabal' say you have
18:51:45 <zRecursive> ghc-pkg list Cabal => ~/ghc/lib/ghc-7.6.3/package.conf.d:\n  Cabal-1.16.0
18:52:27 <tippenein> 'hoogle data' tried to get this url http://hackage.haskell.org/packages/archive/00-hoogle.tar.gz
18:52:42 <applicative> hm, right so get the tarbal at the bottom of http://hackage.haskell.org/package/cabal-install-1.16.0.2
18:53:02 <applicative> zRecursive: that will I think not require you to install a new Cabal library^^^
18:53:11 <zRecursive> applicative: then i canot use bootstrap.sh ?
18:53:36 <applicative> zRecursive: then use bootstrap.sh
18:53:37 <enthropy> sm: works here http://i.imgur.com/7OAfB5J.png
18:53:59 <hiptobecubic> What happened to hayoo :( ?
18:54:21 <zRecursive> applicative: then i cannot use the newest bootstrap.sh in cabal-install-1.18.0.1 frist
18:56:08 <applicative> zRecursive: i think it will be easier if you have a cabal-install.
18:56:18 <applicative> then you can do 'cabal install cabal-install'
18:56:47 <zRecursive> applicative: but where do i find cabal-install :)
18:57:04 <Maxdamantus> Can you always cabal install cabal-install with a cabal-install install?
18:57:10 <applicative> yes
18:57:23 <zRecursive> in cabal-install-1.16.0.2, bootstrap.sh reports "tar: Error opening archive: Failed to open 'transformers-0.3.0.0.tar'"
18:58:17 <applicative> hm just a sec
19:03:12 <applicative> hm.  zRecursive does it seem to be getting transformers for you
19:03:54 <enthropy> sm: oh I see what you mean. You just get one comment for the whole tuple. But that's not so confusing since you can write about both elements
19:05:27 <sm> enthropy: I have a couple of big tuples with complex docs. I was resisting the use of ADTs here for reasons I can't remember, but it might be time to switch
19:05:29 <FreeFull> type HList a = Mu ((,) a)
19:05:38 <zRecursive> applicative: frustrated, i will wait until the BUGS is fixed in the future
19:05:40 <sm> thanks
19:05:43 <FreeFull> I guess this isn't a real HList since it only contains one type
19:06:20 <enthropy> yes you might call it stream I guess
19:06:27 <applicative> zRecursive: I'm not getting what the trouble is, is it that bootstrap.sh is corresponding badly with hackage?
19:06:59 <zRecursive> maybe
19:07:18 <applicative> zRecursive: there is also the expedient of building the Haskell platform from source, though it includes rather more than you want http://www.haskell.org/platform/linux.html instructions are here http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
19:07:40 <applicative> the source for the Haskell Platform includes the versions of transformers, network, http etc that you need
19:08:18 <applicative> on the other hand it has this gui stuff and you should check you have the c libraries monochrom isolates at the top of the page
19:09:30 <zRecursive> too complicated for a newbie
19:10:05 <zRecursive> i am using ghc-7.6.3-i386-unknown-freebsd.tar.bz2  from haskell.org
19:11:38 <smith_> How can I compose with a function that takes multiple arguments?
19:11:48 <smith_> > (1 - ) . (+)
19:11:49 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
19:11:49 <lambdabot>    arising from a use ...
19:12:28 <arkeet> :t (.).(.)
19:12:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:12:45 <pavonia> :t ((1-) .) . (+)
19:12:46 <lambdabot> Num c => c -> c -> c
19:13:03 <smith_> Ah hah.
19:14:47 <smith_> Now, say I'm passed in a function that could takes an arbitrary number of arguments, and I want to return a function that takes the same arguments, applies them to the function I was passed, and applies something to the result of that?
19:16:04 <smith_> So, (1 - ) . fn -- fn is a function outputting (Num a) and taking arbitrary arguments
19:16:46 <shachaf> There's no such thing.
19:16:50 <shachaf> Every function takes exactly one argument.
19:17:05 <lispy> :k (->)
19:17:05 <mangaba_leitosa> shachaf: if it's not Text.Printf.printf :_)
19:17:05 <lambdabot> * -> * -> *
19:17:13 <smith_> Well yes, I know that technically that's how it works, but I'm trying to describe the problem at hand.
19:17:34 <smith_> If I do (1 - ) . fn ; it seems to me that this only works if fn "takes" "one" "argument"
19:17:35 <FreeFull> :k (,)
19:17:35 <lambdabot> * -> * -> *
19:18:31 <shachaf> Even printf.
19:18:48 <pavonia> @pl \f g a b -> f (g a b)
19:18:48 <lambdabot> (.) . (.)
19:18:55 <pavonia> @pl \f g a b c -> f (g a b c)
19:18:55 <lambdabot> (.) . (.) . (.)
19:18:56 * mangaba_leitosa doesn't know yet how printf works
19:19:21 <mangaba_leitosa> But it's fine with consuming any number of arguments :-)
19:19:36 <shachaf> Yes, so is id.
19:19:39 <shachaf> > id id id id id id id 5
19:19:40 <lambdabot>   5
19:20:04 <mangaba_leitosa> shachaf: but id will not consume id 1 2 3 4 5, and printf will :-)
19:20:17 <FreeFull> > do do do do do do id id id id id id 5
19:20:18 <lambdabot>   5
19:21:16 <khyperia> :t id id id id id
19:21:17 <lambdabot> a -> a
19:21:42 <mangaba_leitosa> shachaf: what about an example that consumes integer constants rather than functions? :-)
19:22:11 <FreeFull> typeclasses are basically a portion of dependent typing in disguise
19:23:22 <shachaf> @let import Data.NumInstances
19:23:23 <lambdabot>  Defined.
19:23:27 <shachaf> > 1 2 3 4 5 6 7
19:23:28 <lambdabot>   Could not deduce (GHC.Num.Num t)
19:23:28 <lambdabot>    arising from the ambiguity check for `e...
19:23:43 <shachaf> > 1 2 3 4 5 6 7 + 1
19:23:44 <lambdabot>   2
19:23:56 <khyperia> ... what just happened?
19:24:00 <pavonia> that's cheating
19:25:17 <FreeFull> Num instance for functions
19:25:27 <FreeFull> > (id + id^2 - id^3) 5
19:25:29 <lambdabot>   -95
19:25:43 <shachaf> Someone ought to make that work like APL.
19:25:46 <shachaf> Now that would be something.
19:26:07 * khyperia 's brain just exploded
19:26:28 <mangaba_leitosa> shachaf: ($) redefined for Nums?
19:26:44 <shachaf> I didn't use ($), so no.
19:27:07 <Iceland_jack> mangaba_leitosa: Check out "Data.NumInstances" :)
19:27:07 <Iceland_jack>  
19:27:09 <johntromp> > 1 5
19:27:10 <lambdabot>   Could not deduce (GHC.Num.Num t)
19:27:10 <lambdabot>    arising from the ambiguity check for `e...
19:27:20 <shachaf> Anyway, if you want to try it out, you can /msg lambdabot.
19:27:35 <smith_> So, if I have this --> http://paste.hskll.org/get/91 <-- is there any way to change "modifier" so that it works with (+) as well as (+ 2)?
19:27:43 <FreeFull> > 1 5 :: Integer
19:27:44 <lambdabot>   1
19:27:46 <mangaba_leitosa> > 1 2 + 1
19:27:47 <lambdabot>   2
19:27:51 <luite> +1 for using paste.hskll.org
19:27:54 <mangaba_leitosa> > (($) 1 2) + 1
19:27:54 <lambdabot>   2
19:27:55 <FreeFull> > 1 'a'
19:27:56 <shachaf> Public lambdabot queries are for showing things to other people.
19:27:56 <lambdabot>   1
19:28:22 <mangaba_leitosa> shachaf: I read that when you write 'f x', ($) is implicitly used, is that wrong?
19:28:24 <Iceland_jack> smith_: Can you tell me the type of "modifier"?
19:28:26 <shachaf> It's wrong.
19:28:38 <Iceland_jack> mangaba_leitosa: ($) is just a regular function
19:29:11 <Iceland_jack> When you write (f $ x) it evaluates to (f x), but (f x) has nothing to do with ($)
19:29:27 <smith_> Iceland_jack: I would guess... something like: Num num => (a -> num) -> a -> num
19:29:33 <applicative> > let x = id in x + x^2 - x^3 $ 5
19:29:34 <Iceland_jack> smith_: Right
19:29:34 <zRecursive> @src ($)
19:29:34 <lambdabot> f $ x = f x
19:29:35 <lambdabot>   -95
19:29:35 <mangaba_leitosa> Iceland_jack: ok. Then I wonder how you redefine (f x) :-)
19:30:01 <FreeFull> mangaba_leitosa: You don't
19:30:07 <mangaba_leitosa> Iceland_jack: is Data.NumInstances from vector-space?
19:30:10 <Iceland_jack> smith_: Can you tell the type of (+ 2) and (+)
19:30:23 <zRecursive> @src ($!)
19:30:23 <lambdabot> f $! x = x `seq` f x
19:30:24 <FreeFull> mangaba_leitosa: There is a Num instance for (a -> b)
19:30:52 <FreeFull> mangaba_leitosa: 3 is actually implicitly (fromInteger 3)
19:31:02 <smith_> Iceland_jack: Integer -> Integer and (Num a) => a -> a -> a
19:31:21 <mangaba_leitosa> FreeFull: ah :-)
19:31:22 <Iceland_jack> smith_: not quite but close enough
19:31:43 <Iceland_jack> now try to match both of those up with the first input to ‘modifier’ :)
19:32:01 <Iceland_jack> Note that (+) has two inputs and (+ 2) has only one
19:32:06 <smith_> Right, buuuuut.
19:32:20 <smith_> > map (+) [1, 2, 3]
19:32:21 <lambdabot>   [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
19:32:25 <smith_> :t map
19:32:26 <Iceland_jack> yes
19:32:26 <lambdabot> (a -> b) -> [a] -> [b]
19:33:11 <mangaba_leitosa> > 1 2 3 4 + 5 6 7 8
19:33:12 <lambdabot>   6
19:33:31 <mangaba_leitosa> weird 'vector', it just ignores other numbers :_)
19:33:39 <smith_> Why does some (a -> b) fit into the b in map, but not into (.) ?
19:33:55 <smith_> If that makes sense.
19:34:22 <Iceland_jack> smith_: It does "fit", just not in the way you'd want
19:34:37 <Iceland_jack> @ty (1 -) . (+ 2)
19:34:38 <lambdabot> Num c => c -> c
19:34:48 <Iceland_jack> One number in: one number out.
19:34:52 <Iceland_jack> @ty (1 -) . (+)
19:34:52 <lambdabot> Num a => a -> a -> a
19:34:56 <arkeet> smith_: hm?
19:35:07 <arkeet> note that that is a -> (a -> a)
19:35:11 <arkeet> one number in, one function out.
19:35:33 <Iceland_jack> Normally that would be:
19:35:33 <Iceland_jack> @ty (1 -) . (+) :: (Num a, Num (a -> a)) => a -> a -> a
19:35:34 <lambdabot> Num a => a -> a -> a
19:35:39 <arkeet> @undefine
19:35:39 <lambdabot> Undefined.
19:35:41 <smith_> Hm, I think I see.
19:35:43 <arkeet> @ty (1 -) . (+)
19:35:43 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
19:36:33 <mangaba_leitosa> 'instance Num b => Num (a->b) where fromInteger = pure . fromInteger'
19:36:44 * mangaba_leitosa checked NumInstances
19:38:02 <Iceland_jack> mangaba_leitosa: Are you familiar with type classes/instances, Num, applicative functors…? It's not a standard instance and may be more confusing than helpful
19:38:16 <smith_> Is there no way to do what I want to do, then?
19:38:29 <Iceland_jack> What do you want to do?
19:38:45 <mangaba_leitosa> Iceland_jack: to some extent, I implemented Data.Ratio as an exercise :-)
19:39:15 <Iceland_jack> I would recommend not to put too much thought into NumInstances
19:39:33 <Iceland_jack> It makes things numbers that quite possibly shouldn't be :)
19:39:52 <mangaba_leitosa> :_)
19:39:59 <smith_> Iceland_jack: Take one function with arbitrary arguments; output a function that takes the same arguments, applies them to another function, and applies a third function to the result of that.
19:40:24 <smith_> Sorry, that should be "applies them to that function", not "applies them to another function".
19:40:59 <Iceland_jack> Can you show me at least two invocations to this function with different arities?
19:41:34 <Iceland_jack> Haskell doesn't not (really) support variadic functions
19:42:13 <smith_> Iceland_jack: http://lpaste.net/93570
19:43:23 <Iceland_jack> modifier = id
19:43:59 <Iceland_jack> > let modifier = id in (modifier (+2) 2, modifier (+) 2 1)
19:44:00 <lambdabot>   (4,3)
19:44:37 <smith_> Iceland_jack: What about: http://lpaste.net/93570
19:45:09 <smith_> Where `x` would add two the argument and subtract the result from 1; and `y` would add 2 and 3 and subtract the sum from 1.
19:45:52 <mangaba_leitosa> smith_: is it homework? :-)
19:46:33 <smith_> mangaba_leitosa: Nope, a problem I've run into a bunch of times, and was hoping to find a solution for. :)
19:47:00 <smith_> Have been getting familiar with Haskell by using it in a personal project.
19:47:10 <mangaba_leitosa> @pl f x = 1-(x + 1)
19:47:13 <lambdabot> f = id (fix (const ((-) 1 . (+ 1))))
19:47:13 <lambdabot> optimization suspended, use @pl-resume to continue.
19:48:39 <Iceland_jack> smith_: Do you get why you can do (map (+) [1,2]) and (map (+2) [1,2])?
19:48:44 <Iceland_jack> that may be a starting point
19:48:49 <mangaba_leitosa> @pl f x y = 1 - (x + y)
19:48:49 <lambdabot> f = (-) . (-) 1
19:49:09 <mangaba_leitosa> smith_: your y seems to be (-) . (-) 1 :-)
19:49:39 <smith_> Iceland_jack: Sort of - because it doesn't touch the result of the passed-in function.
19:49:46 <FreeFull> :t (-) . (1-)
19:49:47 <lambdabot> Num b => b -> b -> b
19:49:58 <Iceland_jack> Are you familiar with the definition of map? If so work the reduction out
19:50:06 <Iceland_jack> for both cases
19:50:43 <Iceland_jack> Then you may want to read up on partially applied functions: http://learnyouahaskell.com/higher-order-functions
19:52:54 <wagle> how to get this to typecheck?  (tried a bunch of things, this isn't what i think is the most likely): http://lpaste.net/93572
19:53:15 <Iceland_jack>     map :: (a -> b) -> [a] -> [b]
19:53:16 <Iceland_jack> when passing in (show :: Char -> Int) "a" gets replaced by "Char", "b" by "Int"
19:53:16 <Iceland_jack>     map ord :: [Char] -> [Int]
19:53:23 <smith_> Iceland_jack: http://paste.hskll.org/get/109
19:53:55 <Iceland_jack> smith_: How does it reduce though?
19:54:19 <derdon> putStrLn "Good night, #haskell"
19:54:40 <smith_> Iceland_jack: Define "reduce".
19:54:55 <Iceland_jack> map (+) [1,2] ↝ (+) 1:map (+) [2] ↝ (+) 1:(+) 2:map (+) [] ↝ [(+) 1, (+) 2]
19:56:31 <Iceland_jack> smith_: Assume we have a binary function (f :: A -> B -> C), what is the type of (map f)?
19:57:18 <smith_> Iceland_jack: [A] -> [B -> C], no?
19:57:21 <Iceland_jack> right
19:57:54 <Iceland_jack> and if we have a terniary function (g :: A -> B -> C -> D), what would the type of (map g) be
19:58:01 <Iceland_jack> *ternary
19:58:44 <smith_> [A] -> [B -> C -> D]
19:58:48 <zRecursive> After `git clone https://github.com/haskell/cabal` and modify cabal version from 1.19.0 to 1.16.0 in cabal-install/boostrap.sh,  `bootstrp.sh` works now :)
19:59:12 <Iceland_jack> right, even though the type of map only (apparently?) specifies (a -> b), a unary function
20:00:06 <Iceland_jack> You need to remember that type arrows are right associative meaning that:
20:00:06 <Iceland_jack>     a -> b -> c -> d
20:00:06 <Iceland_jack> is really:
20:00:06 <Iceland_jack>     a -> (b -> (c -> d))
20:00:40 <Iceland_jack> so if you try to match (a -> b) with (Int -> String -> Bool), 'a' becomes Int, 'b' becomes String -> Bool
20:00:46 <zRecursive> :t (->)
20:00:46 <lambdabot> parse error on input `->'
20:00:55 <smith_> Mm hm. I understand that bit.
20:01:01 <brainsturgeon> :k (->)
20:01:02 <lambdabot> * -> * -> *
20:01:16 <Iceland_jack> Then I'm not quite sure where the confusion lies, I'm sorry
20:02:12 <brainsturgeon> smith_: can you explain exactly what you are looking for? I jumped in late and I'm not sure I follow.
20:02:39 <Iceland_jack> I think smith_ wants to compose with both a unary function and binary function
20:02:44 <Iceland_jack> Maybe this will be of some help: http://stackoverflow.com/questions/6599119/composition-with-dyadic-operator
20:02:53 <smith_> brainsturgeon: basically, `modifier` in http://lpaste.net/93570
20:03:12 <smith_> And, yes, compose with a function of arbitrary arity.
20:03:24 <Iceland_jack> Well let's look at the type of (.):
20:03:24 <Iceland_jack> @ty (.)
20:03:25 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:03:49 <Iceland_jack> If you make the first function concrete, then you must also make the second function concrete
20:04:07 <Iceland_jack> (at least regarding it's output)
20:04:37 <smith_> and `b` in (.) cannot become (Int -> Int) because that's not how functions work.
20:04:42 <dwcook> @type ("Hello, " ++) . show
20:04:43 <lambdabot> Show a => a -> [Char]
20:04:58 <Iceland_jack> well the b /can/ become (Int -> Int)
20:05:22 <Iceland_jack> but then the specialized type would be:
20:05:22 <Iceland_jack>     (.) :: ((Int -> Int) -> c) -> (a -> Int -> Int) -> a -> c
20:06:00 <smith_> But not in the case of (.) (-1) (+) because the arguments to (+) do not form a function of type (Int -> Int), because -> is right-associative.
20:06:36 <dwcook> @type (-1) . (+)
20:06:36 <Iceland_jack> Well (-1) is not a function
20:06:37 <lambdabot> (Num ((a -> a) -> c), Num a) => a -> c
20:06:50 <smith_> (- 1)
20:06:51 <smith_> sorry.
20:06:51 <Iceland_jack> @ty subtract 1 -- is
20:06:52 <lambdabot> Num a => a -> a
20:07:09 <smith_> (1 -), even.
20:07:25 <Iceland_jack> That is a function granted
20:07:40 <smith_> I get why (.) doesn't work, more or less; what I'm looking for is to see if there's something that *does* work in this case.
20:09:20 <smith_> Such that I can wrap something around an arbitrary function.
20:10:09 <dwcook> smith_, can you give sample outputs of your x and y functions?
20:10:26 <dwcook> But basically, you need something that is polymorphic enough to cover the types of all the outputs you would want
20:10:28 <Iceland_jack> Well like I said earlier, if you want to compose something and fix the first element you've effectively fixed the arity of the second function
20:10:51 <Iceland_jack> dwcook: http://paste.hskll.org/get/109
20:10:53 <smith_> dwcook: http://lpaste.net/93570
20:11:02 <Iceland_jack> oh sorry, wrong paste
20:11:28 <Iceland_jack> You can use type classes to do this
20:11:32 <Iceland_jack> but you wouldn't want to
20:12:02 <dwcook> So x :: (Num a) => a -> a and y :: (Num a) => a -> a -> a
20:12:08 <smith_> Iceland_jack: Sorry, can you explain what you mean by "fix the first element" i nthis case?
20:12:16 <smith_> And, yep, dwcook.
20:13:13 <smith_> Oh, I see. The "first element" being the outermost function of the composition.
20:13:19 <brainsturgeon> modifier :: (a -> b) -> (b -> b) -> (a -> b)
20:13:35 <brainsturgeon> if I understand you correctly?
20:13:44 <dwcook> brainsturgeon, that doesn't fit y
20:13:58 <dwcook> (+) does not unify with (b -> b)
20:14:06 <brainsturgeon> of course, you're right
20:14:15 <brainsturgeon> have you figured out the type of modifier then?
20:14:23 <dwcook> I haven't. I suspect it's untypeable.
20:15:00 <smith_> Yeah. Not necessarily using a function that works like "modifier", but somehow wrapping one function around another, arbitrary function.
20:15:05 <dwcook> Well, heres one idea.
20:15:21 <smith_> Mm hm?
20:15:32 <dwcook> :t let modifier = undefined ; x = modifier (1 -) (+ 2) ; y = modifier (1 -) (+) in x
20:15:33 <lambdabot> t
20:15:38 <dwcook> Er.
20:15:59 <Iceland_jack> dwcook: modifier :: a
20:16:06 <Iceland_jack> so it fits anywhere, no unification needed
20:16:21 <dwcook> But it needs to be applied, so it would have to be a function.
20:16:29 <Iceland_jack> Does it?
20:16:35 <Iceland_jack> a unifies with (b -> c)
20:16:55 <dwcook> Wait, better idea.
20:17:03 <dwcook> :t let modifier = undefined ; x = modifier (1 -) (+ 2) ; y = modifier (1 -) (+) in x 2
20:17:03 <lambdabot> t
20:17:17 <dwcook> Hmm, I'm not sure why it's saying it's fully polymorphic.
20:17:36 <Iceland_jack> :t undefined 5
20:17:36 <lambdabot> t
20:17:38 <Iceland_jack> :)
20:17:41 <dwcook> Iceland_jack, when you said modifier, did you in fact mean x?
20:17:54 <Iceland_jack> well both
20:18:24 <dwcook> Oh, actually what I *should* have checked is modifier's type, but I suspect *that* will be t as well.
20:18:25 <Iceland_jack> @ty \magicFunction -> (magicFunction 1 2, magicFunction 2) -- smith_
20:18:26 <lambdabot> (Num a, Num a1) => (a -> a1 -> t) -> (t, a1 -> t)
20:18:27 <dwcook> :t let modifier = undefined ; x = modifier (1 -) (+ 2) ; y = modifier (1 -) (+) in modifier
20:18:28 <lambdabot> a
20:18:30 <dwcook> Yep.
20:18:41 <dwcook> Ah, that is better.
20:18:49 <Iceland_jack> So as you can see above, only one of the outputs may be a number
20:19:26 <Iceland_jack> tl;dr you don't do this in Haskell
20:19:35 <smith_> Drat. I was afraid of that.
20:19:42 <Iceland_jack> and you certainly don't need it
20:20:10 <smith_> Well, it forces you to write out func1, func2, ... for each number of arguments you need.
20:20:43 <Iceland_jack> Yes, and yet the Haskell standard library gets fine without those (except in rare cases)
20:20:47 <dwcook> You can actually create a "variadic" function with typeclass magic
20:20:54 <dwcook> Though not in a way that is fully general
20:20:57 <Iceland_jack> > printf "Hi, %s" "world" :: String
20:20:58 <lambdabot>   "Hi, world"
20:21:04 <Iceland_jack> > printf "Hi, %s: %d" "world" 4 :: String
20:21:05 <lambdabot>   "Hi, world: 4"
20:21:08 <Iceland_jack> > printf "Hi, %s: %d" "world" 4 102434534 :: String
20:21:09 <lambdabot>   "Hi, world: 4*Exception: Printf.printf: formatting string ended prematurely
20:21:33 <dwcook> @type printf
20:21:33 <lambdabot> PrintfType r => String -> r
20:21:41 <dwcook> PrintfType is where the magic lies
20:21:55 <smith_> Lovely. :)
20:21:57 <Iceland_jack> smith_: You may believe that variadic functions are important but they really aren't
20:22:11 <Iceland_jack> most of the time you pass it a list where in Lisp or Python you might make it variadic
20:22:20 <Iceland_jack> > maximum [1,4,3,6,5,6]
20:22:21 <lambdabot>   6
20:23:06 <smith_> Iceland_jack: Unfortunately doesn't work all the time.
20:23:11 <smith_> To give a specific case...
20:23:13 <Iceland_jack> I beg your pardon?
20:23:30 <dwcook> Plus that means you don't need an extra function that says "turn this variadic function into a function accepting a list"
20:23:36 <brainsturgeon> It works in the case you pasted.
20:23:49 <brainsturgeon> let modifier = (+1).sum
20:24:15 <brainsturgeon> or rather let sumplus1 = (+1).sum
20:24:30 <brainsturgeon> that saves you defining multiple cases, right?
20:24:43 <smith_> Not if you're fitting into a library that already expects binary and ternary functions to be passed to it.
20:25:09 <Iceland_jack> smith_: Can you give me an example of such a library in Haskell?
20:25:11 <smith_> eg. Text.Parsec.Expr, where `Prefix` and `Infix` expect type `Parser (a -> a)` and `Parser (a -> a -> a)` respectively.
20:25:49 <Iceland_jack> Not the same thing
20:25:51 <smith_> Say you have one data type representing an expression with one argument, and another representing an expression with two arguments.
20:26:34 <Iceland_jack> That isn't related to variadic arguments, but rather that different constructors have different ways of being constructed
20:27:15 <pavonia> smith_: You probably would use the Applicative functions for these parsers
20:27:37 <zRecursive> has newtype only one constructor ?
20:27:44 <smith_> The way you do this with Parsec is to construct eg. `Prefix LogicalNot` and `Infix Addition`, where data Expr = LogicalNot MExpr | Addition MExpr MExpr
20:27:49 <Iceland_jack> zRecursive: yes
20:28:03 <zRecursive> Iceland_jack: thx
20:28:12 <Iceland_jack> smith_: Yes? And LogicalNot and Addition are separate functions
20:28:13 <smith_> So if you had a function that turned Expr into MExpr, and wanted to wrap it around LogicalNot and Addition, you would have to write that function twice.
20:28:31 <Iceland_jack> why?
20:28:36 <hiptobecubic> Is there a way to use ghci in the new cabal sandboxes?
20:28:44 <smith_> Eg. `Prefix $ someFunc LogicalNot` and `Infix $ someFunc Addition`
20:28:51 <Iceland_jack> no..
20:29:02 <smith_> someFunc doesn't work in this case because LogicalNot and Addition have different arities.
20:29:04 <smith_> No?
20:29:16 <Iceland_jack> The function would simply take:
20:29:16 <Iceland_jack>     foo :: Expr -> MExpr
20:29:16 <Iceland_jack>     foo (LogicalNot a)     = undefined
20:29:16 <Iceland_jack>     foo (LogicalAnd e₁ e₂) = undefined
20:29:21 <Iceland_jack> that's a single function
20:29:42 * zRecursive `cabal install cabal-install` now :)
20:30:56 <Iceland_jack> You can have constructors with different arities belonging to the same data type: that is a different thing from a single function being variadic
20:31:26 <smith_> To make it more clear, say MExpr is `MExpr String Expr`, and `someFunc LogicalNot` would, when called with x, generate a String y, apply x to LogicalNot to yield z, and construct `MExpr y z`
20:32:19 <smith_> Writing out pattern matches for each constructor is even worse than writing the generalized function out twice, if you have more than two cases of Expr.
20:33:49 <smith_> If I'm missing something obvious in this, I'd really, really love to know. :)
20:34:04 <Iceland_jack> Please elaborate on how you propose "someFunc" work
20:34:18 <Iceland_jack>     someFunc (LogicalNot expr) = ...
20:34:48 <acomar> ack, this is starting to irritate me. Anyone have any ideas about why vim2hs conceal characters are showing up with their own background color (distinct from my normal colorscheme or background color)?
20:35:15 <Iceland_jack> For example I doubt you meant to "apply x to LogicalNot"
20:35:39 <Iceland_jack>     z = x LogicalNot -- ?
20:35:45 <acomar> it only happens on this one machine, but it doesn't seem like a font issue since it's the same in all fonts. And it's not a colorscheme issue since it happens in all color schemes...
20:36:11 <smith_> That's not quite the case, though. someFunc is :: (MExpr -> Expr) -> MExpr -> MExpr ; not :: Expr -> MExpr -> MExpr
20:36:22 <smith_> someFunc takes the unapplied data constructor, not a value of Expr.
20:36:41 <Iceland_jack> wait... it takes an *unapplied* data constructor? why on earth
20:36:46 <smith_> Here, let me mock up a more complete case.
20:36:59 <Iceland_jack> sure..
20:38:10 <Obfuscate> acomar: Most color schemes don't define Conceal. You might need to define it yourself to override whatever the default is.
20:38:23 <smith_> Iceland_jack: http://lpaste.net/93574
20:38:31 <acomar> Obfuscate: Thanks, I'll look into it
20:39:05 <Iceland_jack> It would be nice if you provided type signatures, but I'll try to make sense of this
20:39:07 <smith_> And you would use this in, say, Prefix $ op (char '!') $ LogicalNot
20:39:16 <smith_> Sorry, sec.
20:39:26 <Iceland_jack> (along with data type definitions)
20:40:26 <Iceland_jack> I think I see where the problem lies, but I'll wait a moment
20:40:38 <joelteon> wasn't there a NonEmpty list somewhere that used (|:) as the cons operator?
20:40:52 <Iceland_jack> joelteon: Yes there was! Data.NonEmpty iirc
20:40:59 <monochrom> have you seen my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements ?
20:41:12 <smith_> Iceland_jack: http://lpaste.net/93574
20:41:14 <enthropy> have you suggestions for tracking down a <<loop>>?
20:41:24 <smith_> I just wrote that up, so hopefully there are no mistakes.
20:41:44 <smith_> monochrom: and yes! that was a helpful introduction to Parsec. Though it gets more complicated when you're dealing with more than just integers.
20:41:54 <smith_> i.e. more than one type.
20:42:21 <smith_> but yes, that was really useful :)
20:42:33 <Iceland_jack> smith_: where is the third argument?
20:43:12 <smith_> Iceland_jack: `MExpr position . container` has type `MExpr -> MExpr`
20:43:38 <Iceland_jack> Which monad are you using then?
20:44:04 <Iceland_jack> Should it be: Parser (MExpr -> MExpr) ?
20:44:31 <FreeFull> Should you even be using a monad rather than just applicative?
20:44:31 <smith_> Woops, you're right.
20:44:32 <smith_> http://lpaste.net/93574
20:44:34 <acomar> Obfuscate: thanks, I located a version of the color scheme with conceal support and it works fine now.
20:44:46 <smith_> Wait. No.
20:44:59 <smith_> http://lpaste.net/93574
20:45:01 <smith_> There we go.
20:46:02 <Iceland_jack> So, rather than accepting the "arguments" to the data constructor: why not accept the fully-applied data constructor to the function?
20:47:06 <smith_> Iceland_jack: Because then you're taking position information after the parser has already passed the point you're looking at.
20:48:10 <smith_> `getPosition` gets the current parser position; then `parser` checks for a '!' and, if it's there, moves the parser forward a character.
20:48:32 <smith_> Also, you'd still have the problem with composition and arity, and have to write more than one of the same function, I believe.
20:48:47 <Iceland_jack> Yes but "MExpr position . container" is a pure function
20:49:05 <Iceland_jack> You can simply parametarize the data constructor by it
20:50:01 <Iceland_jack> i.e. Position -> Expr, rather than passing the container
20:50:10 <applicative> zRecursive: did cabal install cabal-install work in the end?
20:52:07 <Iceland_jack> Assumed we have a simple expression language:
20:52:07 <Iceland_jack>     data Expr = Val Pos Int | Add Pos Expr Expr
20:52:07 <Iceland_jack> we could do:
20:52:07 <Iceland_jack>     op ∷ Parser a → (Pos → Operator) → Parser Operator
20:52:10 <Iceland_jack>     op parser operator = do
20:52:13 <Iceland_jack>         pos ← getPosition
20:52:16 <Iceland_jack>         parser
20:52:19 <Iceland_jack>         return (operator pos)
20:53:16 <Obfuscate> acomar: Good to hear. :)
20:53:24 <Iceland_jack> In any case, it's 5:52 on my end
20:53:33 <Iceland_jack> and my birthday :)
20:53:40 <smith_> But then you need Pos in every definition, which is something I was trying to avoid.
20:53:42 <Iceland_jack> so I'm heading off
20:53:52 <smith_> Thanks for sticking around so long. :)
20:54:15 <acomar> Obfuscate: it had been annoying me for weeks
20:54:29 <Iceland_jack> smith_: (well if pos is defined the same way for each one of the operators, you don't need to)
20:54:45 <Iceland_jack> Like it is in your case
20:54:49 <smith_> Iceland_jack: Hm. I see what you're getting at.
20:54:55 <smith_> Thanks! I'll work something out from this.
20:55:18 <Iceland_jack> Good luck :)
20:55:33 <bananagram> Iceland_jack: happy birthday
20:55:36 <Obfuscate> acomar: Ack. I'd be abusing grep within the hour. (Hint.)
20:55:41 <Iceland_jack> haha thanks bananagram
20:56:00 <Iceland_jack> sadly this weekend is all-nighter weekend though
20:56:15 <Iceland_jack> feel free to congratulate me in a week when I'll actually celebrate!
20:56:35 <bananagram> mhm
20:57:04 <acomar> Obfuscate: It's such a small thing, right? You just put it off and decide you'll deal with later.
21:01:22 <wagle> yay..  cabal-install has hundreds of warnings
21:03:27 <Obfuscate> acomar: Well, I can understand that, but I actually had the same issue a long time ago and I don't think my patience lasted a minute. A quick search and grep usually makes for the best first steps, and I'd rather do that immediately rather than twitch every ten seconds for the next week.
21:04:35 <acomar> Obfuscate: you're a more pro-active person than I am :)
21:05:01 <acomar> Obfuscate: but yes, you're right
21:05:39 <Obfuscate> Either way. You can twitch if you want to. ;)
21:05:46 <acomar> haha
21:06:03 <acomar> you can only twitch for so long
21:16:46 <wagle> does haskell cope with the latest xcode on macosx yet?
21:17:44 <Makoryu> There's a patch somewhere for making it work
21:18:04 <Makoryu> 7.8 is supposed to fix it, I heard, but it's not out yet
21:18:04 <Makoryu> Or is it
21:28:25 <wagle> haskell platform is still 2013.2.0
21:28:54 <wagle> and cabal is still barfing up a storm when you install the new one
21:29:20 <wagle> and if all goes as I expect, bytestring wont compile
21:29:58 <Makoryu> The GHC people were taken by surprise by that bug
21:30:26 <Makoryu> Basically Apple stopped supporting a C preprocessor thing that they relied on even though it had been deprecated like 30 years ago
21:30:40 <Makoryu> (Oops)
21:35:48 <Makoryu> Anyway there was chaos in the Republic of Haskell for a while there while people worked out a patch
21:39:05 <Guest39484> I just posted a question about HLists to Stackoverflow, and would love to hear any  opinions about the question: http://stackoverflow.com/questions/19074441/can-one-convert-an-either-list-to-an-hlist-in-haskell
21:43:29 <shachaf> eir wants (==) to mean type-level Boolean equality.
21:43:34 <shachaf> Is there actually a use for that?
