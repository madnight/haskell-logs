00:08:35 <haasn> Can every type :: * -> * be either a Functor or a Contravariant ?
00:08:58 <haasn> Oh, no; newtype Foo a = Foo (a -> a)
00:09:47 <elliott> haasn: any type * -> * that isn't weird can be made Invariant.
00:09:50 <elliott> IORef is weird.
00:10:14 <elliott> Rank2Types etc. break this.
00:12:06 <LMolr> i am writing a function that needs to apply the same input to a collection of functions until some condition is met. I think it can be modeled with a fold. What type restriction should i use for the collection?
00:12:39 <haasn> elliott: okay
00:13:08 <Iceland_jack> LMolr: Until some condition is met on the input or on the result of the application?
00:13:19 <Iceland_jack> sounds like a job for takeWhile
00:13:20 <LMolr> Iceland_jack, on the result
00:13:26 <Iceland_jack> yup, takeWhile
00:14:01 <LMolr> so i must restrict to monads for the collection
00:14:14 <Iceland_jack> Why do you say that?
00:14:41 <LMolr> ops takeWhile is defined for lists
00:15:06 <Iceland_jack> Prelude> takeWhile even [ f 1 |  f <- [(+1), (+3), (+5), (+6), (+7)] ]
00:15:06 <Iceland_jack> [2,4,6]
00:15:19 <Iceland_jack> does that match what you want to do?
00:15:30 <LMolr> i was wondering whether i could accept a more generic type than list
00:15:56 <Iceland_jack> Any reason why?
00:16:32 <LMolr> Iceland_jack, no. Maybe I am just overthinking..
00:16:33 <Iceland_jack> You could use Traversable/Foldable
00:17:16 <Iceland_jack> if you're thinking of some particular structure other than lists you should maybe implement it for that one
00:17:25 <Iceland_jack> But does that solve your original problem?
00:17:47 <LMolr> Iceland_jack, yes, for the moment a list just suffice :)
00:18:11 <Iceland_jack> Look into Traversable/Foldable
00:18:30 <Iceland_jack> apart from that most data structure functions are very much specialized
00:19:10 <LMolr> Iceland_jack, ok. After all, i'm programming something just to learn :)
00:19:50 <Iceland_jack> There were really two different answers to your question, I sort of gave you both of them
00:20:08 <Iceland_jack> one for actually using it and one for just learning how stuff works
00:21:02 <Iceland_jack> You may want to look at classy-prelude, which includes far more generalized functions
00:22:06 <LMolr> installing it
00:22:23 <Iceland_jack> You might rather want to check out the source instead :)
00:22:48 <Iceland_jack> it's trickier to use than the standard Prelude for multiple reasons, but it should give you an idea of what you can do
00:23:56 <arkeet> foldable/traversable are most likely going to be in the prelude in ghc 7.10 anyway.
00:24:00 <arkeet> or whatever comes after 7.8
00:24:09 <Iceland_jack> good times!
00:27:40 <gauthier> Hello, I need help addressing a linker related issue: http://lpaste.net/93478 , I'm unclear what I should look for (running on linux sabayon / gentoo's haskell overlay if that matters)
00:54:07 <fragamus> how does one    map f xs     in scala
00:56:12 <jbracker> fragamus: My guess: xs.map(f)
00:56:38 <fragamus> yup
00:56:41 <fragamus> thanx
00:57:17 <jbracker> fragamus: Though maybe you can also (xs map f), because of their built-in operator syntax
00:59:24 <bartavelle> is there a library that would let me generate XML, validate it with an XSD, and write it on a file in one pass (a streaming solution) ?
01:07:34 <quicksilver> it's not possible for validation to be single-pass is it?
01:07:41 <quicksilver> in general.
01:17:44 <jartur> quicksilver: Isn't it possible to generate a grammar from schema and basically do a syntax analisys on data as a validation? Isn't it possible in XML for some reason?
01:17:59 <jartur> quicksilver: It would depend on properties of such grammar
01:24:52 <bartavelle> I know almost nothing about all xml-y things, so I can't really say
01:29:23 <adnap> Apparently I have to import GHC.IO.Handle for the Handle type
01:30:15 <adnap> Or System.IO
01:31:26 <danr> go for the latter :)
01:31:51 <quicksilver> jartur: XSDs are not context-free
01:32:09 <quicksilver> jartur: validation can require whole-tree analysis
01:32:19 <quicksilver> which is not what people normally mean by 'single pass'
01:33:25 <jartur> quicksilver: Oh, ok.
01:33:44 <bartavelle> so it is an empty dream
01:33:56 <bartavelle> so much for constant memory usage
02:08:49 <LMolr> after some eta-reduce, my code has disappeared. hm...
02:10:17 <bergmark> :D
02:18:21 <Thulsadum> ok, I have monadception (a monad within a monad). how could I bind (>>=) to the inner monad?
02:18:39 <Thulsadum> (i.e. IO (Either a b))
02:19:01 <sipa> liftIO ?
02:19:36 <merijn> Thulsadum: well, you could "fmap (>>=myFunc)" or "liftM2 (>>=)"
02:19:41 <merijn> :t liftM2 (>>=)
02:19:42 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (a -> m1 b) -> m (m1 b)
02:20:46 <merijn> Thulsadum: Also, this might be the time to read up on monad transformers and EitherT (or whatever that one is called nowadays)
02:21:05 <supki> still EitherT
02:21:21 <merijn> @unmtl EitherT a m b --let's see if I get this right
02:21:21 <lambdabot> EitherT a m b
02:21:22 <supki> and yeah, EitherT over IO is going to be much more pleasant to work with
02:21:57 <Thulsadum> ok, thanks for the hints. :)
02:23:50 <maverick_> Does someone know how I can implement the select function for a table for Haskell?
02:24:35 <merijn> maverick_: Define "the select function" and "a table"
02:24:37 <adnap> I have yet to use a monad transformer. Do you think it's because my programs consist of very long functions with many parameters?
02:25:32 <adnap> I just don't know when to use one
02:26:09 <merijn> adnap: Well, do you ever use State?
02:26:15 <adnap> merijn: No
02:26:16 <maverick_> merijn, http://lpaste.net/3706787420486762496
02:26:50 <merijn> maverick_: Right, but there's no data structure there, might want to worry about that first
02:27:02 <maverick_> I know how to create a table like that
02:27:08 <maverick_> Already have a function for it
02:27:13 <merijn> adnap: It depends on the programs you write, I guess.
02:27:21 <maverick_> And the select function should be select :: Field -> Field -> Table -> Table select column value table@(header:rows) = undefined
02:27:25 <adnap> I like to do graphics programming, so I have a lot of IO that sets up a loop and then a function that computes what to draw
02:28:19 <adnap> I guess I'll eventually publish something and then I can get tips for how to refactor it
02:28:51 <merijn> adnap: One example I have is using pipes (incidentally a monad transformer itself), I have a connection whose behaviour is specified separately from the network connection, it's defined of a ReaderT Handle to get access to the handle and StateT ByteString to store "left-over" input when I finish parsing, so that the next connection step can use said left-overs
02:29:30 <merijn> adnap: So I can compose the entire thing together and only need to provide a Handle + empty ByteString to run the thing
02:29:41 <adnap> merijn: Huh. I don't really get what you're saying
02:30:37 <adnap> merijn: Why do you ever close a handle?
02:30:43 <merijn> adnap: I parameterise the implementation (i.e. communication primitives) of a protocol over the actual network Handle I want to communicate with
02:31:00 <merijn> adnap: Who said anything about closing a Handle?
02:31:08 <adnap> merijn: That didn't make sense either
02:31:56 <adnap> merijn: You mentioned "next connection"
02:31:57 <merijn> adnap: My protocol consist over 4 different phases, handshake, authentication, negotiation, actual communication. I want to construct a specific interaction by composing those
02:32:10 <merijn> adnap: I should maybe have said "next phase"
02:33:03 <merijn> adnap: So the handshake does some IO on a handle, parses some stuff, but doesn't consume the entire ByteString it read from the network. So this leftover stuff should be handed to the next phase (negotiation), because otherwise your missing some bytes
02:33:23 <adnap> merijn: I see
02:33:56 <adnap> merijn: Why don't you just have a bunch of Handle -> IO () and call them in order?
02:34:14 <adnap> Er
02:34:23 <adnap> Handle -> (IO (), ByteString)
02:34:27 <adnap> Er
02:34:33 <adnap> Handle -> IO ByteString
02:34:40 <adnap> Yeah
02:34:49 <merijn> adnap: Because I have multiple possible authentication mechanisms, different negotiation approaches, etc.
02:35:03 <merijn> adnap: Also, that means plumbing the left overs around by hand for no good reason
02:35:06 <adnap> I guess it would have to be ByteString -> Handle -> IO ByteString
02:35:15 <adnap> Well
02:35:26 <adnap> You just use (>>=)
02:36:00 <merijn> adnap: Right now I just have "parseConnection :: (MonadReader Handle m, MonadState ByteString m, MonadIO m) => Get a -> m a"
02:36:18 <adnap> data Crap = Crap OtherCrap ByteString. OtherCrap -> Handle -> IO OtherCrap
02:36:22 <merijn> adnap: And now I never need to worry about forgetting to forward some state somewhere
02:36:22 <adnap> Er
02:36:25 <pamojarpan> hey, I'm starting with haskell. I'm using Sublime Text, but I'm not confortable at all. Do you recommend me Vim or Emacs?
02:36:28 <adnap> Crap -> Handle -> IO Crap
02:36:42 <merijn> pamojarpan: I would recommend whichever of those two you're comfortable with
02:36:57 <adnap> merijn: Well, maybe you can see why I don't use transformers
02:37:01 <merijn> adnap: What if my connection needs to return something in addition to Crap? i.e. the result of parsing something from the wire
02:37:12 <adnap> merijn: That's what OtherCrap is
02:38:29 <merijn> adnap: It means every function of type "Crap -> Handle -> IO Crap" needs to reimplement the "is the remaining ByteString empty?" check
02:39:12 <merijn> adnap: As opposed to implementing it once inside a parse action and never worrying about it anymore
02:39:15 <adnap> merijn: Yeah, don't you have to do that if you want to send the remaining ByteString to the next phase?
02:40:06 <pamojarpan> merijn: but which is the editor for haskellers? I mea, there will be always vim and emacs people en each language, but which one has the best integration, documentation tools,etc?
02:40:26 <merijn> adnap: no
02:40:47 <adnap> merijn: Well, please explain how your method avoids this
02:41:14 <merijn> adnap: Since the ByteString is just kept in State the state monad does that for me, the only place is the "parseConnection" where I do "get" to check the current state, do my parsing and at the end do "put" to store any leftovers
02:41:52 <merijn> adnap: Since the parseConnection thing is the only thing reading it's also the only thing needing to check and the State monad will forward all this stuff through whatever phase the connection is currently in
02:41:54 <adnap> merijn: Can you elaborate? I still don't understand
02:41:58 <quicksilver> pamojarpan: the ghc-mod project producs quite clever tools
02:42:02 <quicksilver> pamojarpan: they work in emacs and vim
02:42:04 <oddsignals> oh well, at least I can fix it now
02:42:10 <quicksilver> pamojarpan: http://hackage.haskell.org/package/ghc-mod
02:42:13 <oddsignals> meh sorry
02:42:19 <oddsignals> up+enter in wrong window
02:42:32 <adnap> merijn: Oh, You have ByteString -> (a, ByteString)?
02:42:49 <merijn> adnap: I don't know what you mean by that?
02:43:06 <adnap> merijn: Then just ignore it and please elaborate
02:43:24 <merijn> I'm also not really sure what more there is to elaborate?
02:43:29 <bartavelle> maverick_, I think your type is wrong, it shouldn't be "select :: Field -> Field -> Table -> Table" but "select :: Field -> Value -> Table -> Table"
02:43:37 <adnap> merijn: "the state monad does that for me"
02:44:06 <merijn> adnap: Yes, what's unclear there?
02:44:07 <pamojarpan> quicksilver: thank you. I will take a look :)
02:44:10 <adnap> merijn: Everything
02:44:35 <merijn> adnap: Forwarding state around throughout computations is what the State monad does
02:44:46 <adnap> merijn: And is the state a ByteString?
02:44:53 <merijn> adnap: Yes
02:45:01 <adnap> i.e ByteString -> (a, ByteString)?
02:45:23 <merijn> And when I start a new parse, I first use the leftovers before continuing with reading new stuff
02:45:37 <adnap> merijn: Don't you still have to check if there is more ByteString data before putting it in the state?
02:46:04 <merijn> adnap: The thing is, no one uses State by having functions "ByteString -> (a, ByteString)", you just use get/put
02:46:28 <merijn> adnap: Yes, but since I have a generic function that does parsing, I only implemented that code in that function and then use that everywhere
02:47:04 <adnap> merijn: How is that different from calling that function in each phase of a Crap -> Handle -> IO Crap function?
02:47:28 <merijn> adnap: Because there every single function has to copy+paste that exact same functionality
02:47:51 <adnap> merijn: Every phase you wrote calls "generic parsing function"
02:48:15 <adnap> every Crap -> Handle -> IO Crap could call "generic parsing function"
02:49:03 <merijn> adnap: Except how would it deal with what the new state is? You'd have to implement your parsing function as "Crap -> Handle -> IO Crap" too and essentially copy every function argument to every other function...
02:49:18 <merijn> + the output of all those functions
02:49:20 <adnap> The parsing function takes Crap
02:49:33 <merijn> And then you decide to change one minor detail and have to update all intermediate functions
02:50:04 <adnap> merijn: I don't understand
02:50:09 <merijn> In my version the *only* thing that has to change if I decide to completely change my parsing approach is the parsing function. The rest will literally be unchanged, including type signatures, etc
02:50:29 <merijn> adnap: Then I don't know how to explain this to you
02:50:33 <adnap> I think it would be easier to see code
02:50:50 <adnap> That uses transformers and shows their advantages
02:51:10 <adnap> ...by comparing them to code that does the same thing without transformers
02:51:57 <adnap> Instead of describing two programs and comparing their advantages in English
03:02:35 <adnap> Ah, nice: http://stackoverflow.com/questions/12968351/monad-transformers-vs-passing-parameters-to-functions
03:23:18 <ScriptDevil> Hi, is there a way to ask parsec to ignore spaces between two lexemes? I am trying to parse PDDl and putting >> spaces between each pair of lexical units is painful.
03:23:35 <petapetapeta> What does the error message: "Too strict if" from HLint mean?
03:31:45 <chrisdone> ScriptDevil: petapetapeta: paste your code
03:31:50 <chrisdone> @where lpaste
03:31:50 <lambdabot> http://lpaste.net/new/haskell
03:34:50 <supki> petapetapeta: the difference between  if c then f x and f y  and   f (if c then x else y)  is that in the former case if  c  is _|_ then the whole expression is _|_, in the latter case it might be not
03:35:08 <supki> > if undefined then const 1 2 else const 3 4
03:35:09 <lambdabot>   *Exception: Prelude.undefined
03:35:25 <supki> oops
03:35:29 <supki> > if undefined then const 1 2 else const 1 4
03:35:31 <lambdabot>   *Exception: Prelude.undefined
03:35:40 <supki> > const 1 (if undefined then 2 else 4)
03:35:41 <lambdabot>   1
03:35:42 <petapetapeta> supki: Ahh that makes sense :) THank you very much
03:37:10 <supki> :)
03:51:34 <ibotty> hi,
03:52:00 <ibotty> i have a (i guess simple) braino on pipes
03:52:27 <ocharles> ibotty: go ahead
03:52:37 <ibotty> how can i get rid/consume the rest, the r
03:52:51 <ibotty> as in pipe a b m r
03:52:56 <exFalso1> Hi, is there a way to use pattern guards in case expressions?
03:53:02 <ocharles> ibotty: you want r?
03:53:37 <ocharles> ibotty: runEffect $ for (producer >-> pipe) (const $ return ())
03:53:46 <ibotty> in a way it might be the error-handling path for my application
03:53:47 <donri> exFalso1: yes, "just do it" :)
03:53:57 <ibotty> so, yes, kind of :D
03:54:38 <ScriptDevil> chrisdone: http://lpaste.net/93484
03:54:59 <exFalso1> donri: i meant pattern guards with <-
03:55:12 <donri> exFalso1: yes, just do it :)
03:55:16 <ibotty> i have a Proxy Void () () PB.ByteString m (Producer PB.ByteString m ()) and want to somehow connect that to PB.stdout :: Proxy () PB.ByteString y' y m ()
03:55:24 <exFalso1> donri: :) well it gives syntax error
03:55:36 <donri> exFalso1: case .. of .. | guard stuff -> ...
03:55:50 <donri> exFalso1: did you include the | ?
03:56:00 <ScriptDevil> chrisdone: I was trying to parse the string (define (domain foobar)). Without all the >> space, it only parses (define(domainfoobar)), putting >> space everywhere seems like a clutter.
03:56:04 <exFalso1> donri: nope, thats it:)
03:56:07 <exFalso1> donri: thank you
03:56:10 <donri> np
03:56:37 <ibotty> Proxy Void ()                    ()  PB.ByteString m (Producer PB.ByteString m ())
03:56:37 <ibotty> Proxy   ()   PB.ByteString y'  y                     m ()
03:57:04 <ScriptDevil> chrisdone: Flex for instance lets you ignore spaces by declaring an empty corresponding action. I do not know how to do that using parser combinators
03:59:09 <chrisdone> ScriptDevil: hm, there is a `between' combinator, but i'm not sure how to ignore spaces in another way
03:59:26 <donri> isn't this what token parsing is for
03:59:27 <ibotty> the usecase is (you might be aware):
03:59:27 <ibotty> PT.decodeUtf8 (PB.stdin) >-> PT.encodeUtf8 >-> PB.stdout
03:59:27 <ibotty> but the last composition does not work because of the last parameter (that is (Producer PB.ByteString m()) and not ()...
03:59:28 <chrisdone> actually not between, sepBy
03:59:29 <silasdavis> Can someone explain the type of (2 3), as in :t (2 3)
03:59:32 <silasdavis> I half get it...
03:59:51 <silasdavis> (Num (a -> t), Num a) => t
03:59:55 <silasdavis> incidentally
04:00:46 <ibotty> silasdavis: for num instances that are functions (your 2) that's defined
04:00:52 <Maxdamantus> 2 is a `Num (a -> t) => a -> t` while 3 is a `Num a => a`
04:01:21 <ibotty> that might be useful for matrices, but not in the usual case...
04:01:27 * Maxdamantus wonders if people talk about "polytypes" or something in Haskell.
04:02:49 <JamesM> Do we like today's xkcd?
04:03:02 <silasdavis> yeah I'm just wondering how the type contraint maps on to the type
04:03:21 <ibotty> JamesM: i like it. i like math and math notation though
04:03:23 <silasdavis> is the order of the type constraints significant?
04:03:30 <Maxdamantus> silasdavis: no.
04:04:13 <Maxdamantus> silasdavis: given what I said above, if you apply `3` (`a`) to `2` (`a -> t`), you get something of type `t`
04:04:31 <silasdavis> why does a -> t have to be Num?
04:04:44 <Maxdamantus> silasdavis: the reason it has the Num stuff is because you need a Num instance to use the literals `3` and `2`
04:04:54 <Maxdamantus> :t 3
04:04:55 <lambdabot> Num a => a
04:05:31 <donri> :t 1 "two" '3'
04:05:32 <lambdabot> Num ([Char] -> Char -> t) => t
04:05:56 <silasdavis> but why is 2 a a -> t?
04:06:15 <donri> silasdavis: because you're applying it to an argument, which means it must be a function
04:06:26 <silasdavis> perhaps the fact there is no instance 3 that is a -> t that makes a bit of a nonsense
04:06:34 <Maxdamantus> silasdavis: `2` has to be a function, because it's being applied something, and it has to have a Num instance, because it's generated by a number literal.
04:06:36 <silasdavis> sorry I mean why does it need to be a Num
04:06:45 <donri> silasdavis: because number literals are polymorphic
04:06:49 <silasdavis> what if (3 a) was a non NUm
04:06:59 <donri> :t (1 :: Int, 2 :: Integer)
04:06:59 <lambdabot> (Int, Integer)
04:07:08 <Maxdamantus> `3 a` doesn't have to be a `Num t => t`
04:07:25 <Maxdamantus> `3` has to be a `Num t => t`.
04:07:43 <Maxdamantus> `3` in `3 a` has to be an `a -> b`
04:07:57 <silasdavis> I though it has to be Num (a -> t)
04:08:08 <silasdavis> as per the output of :t
04:08:18 <Maxdamantus> merge the constraints, and you get: `3` has to be a `Num (a -> b) => a -> b`
04:08:41 <donri> silasdavis: it's both a number (because 3) and a function (because " a" being function application)
04:09:12 <silasdavis> ah sorry I think I see now
04:09:59 <Maxdamantus> (the fact that you can type this doesn't mean the instances actually exist, which is what's required to produce an actual value)
04:10:31 <ScriptDevil> chrisdone: I saw sepBy. It separates 0 or more occurences of a token by " ". This is more like chaining multiple combinators
04:10:32 <silasdavis> yes I think that was the point of my experiment
04:10:50 <silasdavis> why can't I get a type for ("3" 2)
04:11:13 <donri> silasdavis: because string literals aren't polymorphic
04:11:21 <donri> silasdavis: it should type check with OverloadedStrings though
04:11:54 <Maxdamantus> > 4 :: Int
04:11:55 <lambdabot>   4
04:11:57 <Maxdamantus> > 4 :: Double
04:11:58 <lambdabot>   4.0
04:12:17 <Maxdamantus> "3" only works with `:: String`
04:12:27 <silasdavis> so for :t it is sufficent that a type being applied in an expression is polymorphic, not that any suitable instance of that polymorphic type exists?
04:12:30 <Maxdamantus> (or an equivalent denotation of that type)
04:24:34 <shiona> btw thanks to whomever it was that posted the functional-programming.jyu.fi link here yesterday or so. That university does co-operation with mine so I just found myself a haskell course worth credits.
04:25:54 <Maxdamantus> Funny "whomever"
04:26:15 <Maxdamantus> They usually say both sides of the copula should be subjective.
04:27:57 <Maxdamantus> (hence "who are you?", rather than "whom are you?")
04:32:13 <McManiaC> is there a way to see the haskell code generated from template haskell?
04:32:30 <quicksilver> Maxdamantus: thanks to isn't a copula. I "give thanks to him" not "give thanks to he".
04:33:20 <Maxdamantus> shiona: it's not "thanks to whomever" though.
04:33:27 <Maxdamantus> er, quicksilver*
04:33:35 <Maxdamantus> quicksilver: it's thanks to (whomever it was that ..)
04:33:48 <Maxdamantus> s/thanks/"thanks/; s/$/"/
04:35:01 <quicksilver> oh, I see
04:35:19 <quicksilver> yes you're probably right
04:36:03 <Maxdamantus> I think "whomever" would be the logical thing to put there though.
04:36:38 <Maxdamantus> because disregarding who/whom/etc, the subjective form only really occurs as a grammatical subject.
04:42:10 <dw399> Hi Guys - I am new to haskell and functional programming languages in general
04:42:31 <schoppenhauer> hi dw399
04:42:57 <dw399> I have created a basic XML SAX parser to data structure parser (which works) and would like some feedback on how to do it better
04:43:05 <dw399> code is at http://lpaste.net/93485
04:43:17 <dw399> any comments are appreciated
04:45:28 <shiona> English isn't my first language but I stand by my sentence until it's proven wrong by an authority I should trust in the case
04:45:55 <shiona> but I think we've spent enough time offtopic for now
04:47:20 <ibotty> ocharles: did you think about the problem earlier re pipes?
04:56:33 <fizruk> dw399: how about basic error handling?
05:37:18 <merijn> McManiaC: Yes, there is a dump-splices or similar flag that outputs the haskell generated, take a look at the GHC manual to find the actual flag
05:38:30 <McManiaC> merijn: k thx
05:55:14 <DMcGill> there's no Show instance for Compose?
05:56:03 <DMcGill> instance Show (f (g a)) => Show ((Compose f g) a) where
06:12:48 <ashnur> is this old? http://xkcd.com/1270/
06:13:03 <mr-> 3
06:14:19 <merijn> ashnur: What do you mean by "is this old?"?
06:14:20 <int-e> ashnur: it's several hours old :)
06:14:36 <ashnur> i meant here. :)
06:14:53 <int-e> you were the first to bring it up
06:14:56 <int-e> I think.
06:15:06 <ashnur> don't like double posting stuff, especially when it's just fun :)
06:15:10 <ashnur> kewl :D
06:15:24 <int-e> ah, no, you were third, but the other two people didn't link by number
06:15:31 <ashnur> basterds!
06:15:44 <ashnur> no one thinks of the future log readers but me!
06:16:24 <int-e> (And I can't count up to three. Oh well. Sorry for the noise.)
06:24:07 <merijn> Does anyone know if the actual instances of Comonad for the stuff listed in https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1 are available somewhere?
06:24:40 <merijn> I wanna check my implementation for Pretext s against someone else's implementation
06:25:03 <merijn> And the usual equational proof of the laws is a bit cumbersome for this example :\
06:28:47 <quchen> merijn: Store is in comonad-transformers
06:29:06 <merijn> quchen: I know, but Store is simple
06:29:13 <merijn> I meant Pretext and Bazaar
06:29:32 <kqr> ashnur, to be fair, future log readers could quite easily find out which comic is being referred to by looking at when it was posted ;)
06:29:47 <maverick_> Could someone help me with the select function I'm making --> http://lpaste.net/3706787420486762496 I'm kinda stuck
06:30:20 <ocharles> merijn: Pretext and Bazaar are part of lens, is that what you mean?
06:31:55 <quchen> maverick_: fromJust is usually not a good idea.
06:32:14 <acomar> does pipes 4.0 still have the arrow choice combinators? it seems to be removed from the documentation
06:32:32 <merijn> ocharles: My question was just a simple "I'm implementing the instances as exercise like edwardk suggest and was wondering where I could check my code"
06:33:21 <maverick_> quchen: I think I have to use mabye instead, because if the column name you want to select is not in your table you have to give the same output as the input, but I don't really know how to use the mabye here
06:33:28 <merijn> acomar: I don't know, but if it doesn't there's a fairly simple solution. Since Proxy is a monad it is trivially possible to add them by using the Kleisli arrow
06:34:10 <merijn> acomar: Since you have "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }; instance Monad m => Arrow (Kleisli m)"
06:34:22 <merijn> acomar: I'm pretty sure Kleisli is an ArrowChoice too
06:34:23 <fizruk> maverick_: shouldn't the type be Field -> FieldValue -> Table -> Table ?
06:34:56 <acomar> merijn: yea, fair enough
06:34:56 <merijn> acomar: Actually, I just realised I'm not just "pretty sure", I'm 100% sure since any monad is (by definition) an instance of all Arrow classes :)
06:34:59 <ashnur> kqr: that requires more work than just clicking it
06:35:49 <merijn> acomar: For a more useful answer on whether they still exist directly you'd have to bug the pipes people
06:36:56 <acomar> merijn: Thanks, will do
06:38:59 <maverick_> fizruk: how come?
06:39:13 <ocharles> merijn: I got that, and I wondered if the Bazaar and Pretext in lens would help you with that
06:39:27 <ocharles> acomar: no, arrows for pipes will be coming in a separate library
06:39:42 <ocharles> (pipes-frp or pipes-mvc or whatever Tekmo is calling it atm)
06:40:01 <acomar> ocharles: oh, didn't realize it was getting moved out like that. Saw the combinators pop up in 3.2 and assumed it'd stay with the core library
06:40:05 <fizruk> maverick_: (select "gender" "male") filters rows with value "male" for field "gender", right?
06:40:11 <merijn> ocharles: I dunno? are they the same as the ones defined in the article I linked? :)
06:40:35 <ocharles> merijn: no idea, but it's written by Kmett and has the same name, so i'd expect it has at least the same semantics :)
06:41:04 <maverick_> fizruk: Yes
06:41:18 <merijn> ocharles: Aww, Pretext from lens is much more complicated :\
06:41:40 <merijn> For values of complicated that mean "more type variables"
06:41:49 <ocharles> merijn: does it Reflect Reflect Reify Reflect Reflectify?
06:41:51 <ocharles> I usually find that these days
06:41:55 <fizruk> maverick_: so first parameter is Field (or FieldName) and second should be FieldValue (even if they are synonyms)
06:42:17 <ocharles> merijn: ah. maybe you can just fix the extra ones
06:42:42 <maverick_> I see, but they both remain String right?
06:44:54 <fizruk> maverick_: yes, they can both be String
06:46:24 <jophish> Yo yo yo,
06:47:24 <jophish> I have a text file, several GB in size. I'd like to process this in parts, one word at a time.
06:48:04 <jophish> The end goal is to create a map of all the n-grams of some length to a list of following words and probabilities
06:48:23 <jophish> The data structure behind a Markov chain
06:48:35 <maverick_> :fizruk So with elemIndex column header I can look for the right column in my header, but what must I do after?
06:48:43 <jophish> I've been trying to do this efficiently in haskell, but I'm really not sure how
06:48:52 <merijn> jophish: You probably want to look at something like Data.Text.Lazy or a pipes/conduits approach to reading the data in
06:49:05 <jophish> merijn: ah, there is a text.lazy
06:49:09 <jophish> Super
06:49:09 <jophish> thanks
06:49:31 <jophish> All the attempts I've tried have had terrible memory performance
06:49:34 <merijn> jophish: The pipes/conduits approach will be more reliable in terms of resource requirements
06:51:16 <jophish> merijn: I'll give text.lazy a try first because it should be a little easier to hack in here
06:51:38 <fizruk> maverick_: first, why do you use `maybe` function?
06:51:50 <fizruk> maverick_: I believe it should be removed
06:52:41 <fizruk> maverick_: select should work once you remove it, though it will lose the header (you forgot to prepend it after filter)
06:52:53 <maverick_> fizruk: Because in some way I only have to change the table when a column name is actually in my table, else it must remain how the table is, I thought I could do it with a mabye
06:52:59 <boothead1> Hi folks does anyone know offhand if it's acceptable to post jobs or /r/haskell?
06:53:11 <fizruk> maverick_: oh, I see
06:53:21 <fizruk> maverick_: just a sec
06:54:14 <ocharles> boothead1: i think it is
06:54:27 <ocharles> boothead1: you might also want to look at haskellers and functional jobs
06:54:31 <ocharles> also the cafe
06:56:16 <fizruk> maverick_: you should do case analysis on the return value of `elemIndex`
06:57:06 <fizruk> maverick_: something like this: http://lpaste.net/93490
06:57:49 <cinimod> Can anyone point me at a rationale as to why signum is part of Num?
06:58:36 <merijn> :t signum
06:58:37 <lambdabot> Num a => a -> a
06:58:56 <applicative> cinimod: kinda gross, isn't it?
06:59:30 * applicative has defined signum many many more times than he has used it
06:59:35 <merijn> boothead1: As long as you avoid spamming (i.e. only post once per job or not more than once every week or so) I think job offers in r/haskell, here and -cafe are fine
06:59:50 <cinimod> applicative: yes but I didn't want to be definitive on that
06:59:53 <fizruk> maverick_: I don't know your exact use case, but I believe it would be better to handle invalid arguments separately
07:00:24 <cinimod> applicative: it means complex numbers can't really be an instance of Num :-(
07:00:37 <maverick_> fizruk: Hold on, checking your code
07:00:39 <applicative> cinimod: I don't know what the arguments were. Everyone makes fun of Num but that's not an aspect mentioned
07:00:53 <bennofs> How was that Either-Or-Both type called?
07:00:53 <applicative> cinimod: oh what do they do in e.g. Data.Complex
07:01:17 <supki> bennofs: These
07:01:26 <bennofs> supki: thanks
07:01:31 <jophish> f as n = length as > n
07:01:46 <jophish> What's the complexity of this? O(length(as)) or O(n)
07:02:09 <merijn> jophish: length(as)
07:02:13 <jophish> I thought so
07:02:41 <applicative> cinimod:     signum z@(x:+y)     =  x/r :+ y/r  where r = magnitude z
07:02:43 <jophish> merijn: Is there an equivalent in the prelude which is O(n)?
07:02:55 <merijn> jophish: Unless you use genericLength and a lazy Peano instance of Num, then it's min(length(as), n)
07:03:24 <merijn> jophish: Not really, but it's of course trivial to define yourself
07:03:28 <applicative> cinimod: with a ludicrous special case for signum (0:+0)
07:03:40 <supki> jophish: not . null . drop n
07:03:43 <merijn> (Please don't use my lazy peano suggestion, it's terrible :p)
07:03:45 <fizruk> maverick_: a variant, using Maybe: http://lpaste.net/93491
07:03:53 <boothead1> merijn, ocharles - thanks here's the ad: http://hackerjobs.co.uk/jobs/2013/9/27/digital-logistics-haskell-developer  feel free to share it far and wide! I'll also post an announcement on reddit
07:04:10 <merijn> boothead1: oh, and there is haskellers.com of course
07:04:38 <jophish> merijn: :) thanks
07:04:43 <jophish> supki: Looks, good, cheers
07:05:18 <merijn> pound/day seems an odd unit for salary
07:06:14 <applicative> ooh 'the pipes ecosystem of libraries providing the plumbing and technical rigour that we're looking to achieve'
07:06:28 <merijn> boothead1: Also, I'm totally open to putting more time into my pure haskell zeroMQ implementation for money ;) (although slightly less open to moving to London)
07:06:50 <applicative> 'Hair shirt not supplied, please bring your own :-)'
07:07:31 <boothead1> merijn, where are you in the world?
07:07:48 <boothead1> applicative, you gotta be serious maaan!
07:07:56 <applicative> haha
07:08:01 <cinimod> applicative: I wonder what they were thinking
07:08:11 <merijn> boothead1: Currently in Edinburgh, but moving back to Netherlands once my contract finishes monday next week ;)
07:08:34 <cinimod> applicative: I have heard many programmers say that mathematicians shouldn't really be allowed to code
07:08:45 <cinimod> applicate: perhaps the reverse applies
07:09:25 <cinimod> applicative: oops mis-spelt your name
07:09:56 <boothead1> merijn, the pounds per day is the contract rate - my employers are open to both contract and permanent employees
07:11:09 <ocharles> Having read Out of the Tar Pit should be a requirement in more job postings ;)
07:11:55 <boothead1> ocharles, and having a hair shirt too!
07:12:26 <boothead1> merijn, will you be moving onto something interesting back in NL?
07:12:36 <ocharles> that reference is lost on me, what's a hair shirt?
07:13:06 <Clint> @wikipedia cilice
07:13:07 <lambdabot> Unknown command, try @list
07:13:09 <Clint> dammit
07:13:25 <quchen> @google wikipedia cilice
07:13:26 <lambdabot> http://en.wikipedia.org/wiki/Cilice
07:13:26 <lambdabot> Title: Cilice - Wikipedia, the free encyclopedia
07:13:28 <quchen> :-)
07:13:56 <cinimod> ocharles: one must mortify the flesh
07:14:10 <ocharles> ha
07:15:09 <boothead1> ocharles, http://research.microsoft.com/~simonpj/.../haskell.../HaskellRetrospective.pdf‎
07:15:28 <boothead1> damnit google! you had one job!
07:15:46 <bennofs> How would I actually make use of the Coproduct monoid from monoid-extras? The function unMCo :: m :+: n -> [Either m n] is not exported
07:15:53 <ocharles> oh, I don't think I've read that paper
07:15:57 <boothead1> http://lmgtfy.com/?q=wearing+the+hair+shirt+haskell
07:16:00 <chaoslynx> what is the recommendend way of dealing with bitflags?
07:16:26 <ocharles> chaoslynx: I tend to use a Set
07:16:35 <applicative> is it 'purity' that the hair shirt mostly refers to? I cant remember
07:17:26 <chaoslynx> ocharles: what if I have a Word32 to start with? I would like to have an equivalent of if(a & b)
07:17:35 <chaoslynx> in c
07:17:43 <quchen> chaoslynx: Data.Bits?
07:17:49 <chaoslynx> Data.Bits allows to test single bits
07:17:53 <quchen> if a & b /= 0 then …
07:17:53 <applicative> no its 'So why wear the hair shirt of laziness?'
07:18:07 <quchen> Eh, ".&.", not "&"
07:18:07 <ocharles> chaoslynx: if you want to do bitmasks in Word32, then yea - just use Data.Bits
07:18:25 <boothead1> applicative, yes I think so. Something along the lines of "it's uncomfortable to begin with, but it makes you a better person" :-)
07:18:40 <applicative> But we wear the hair shirt of laziness for the higher ideal of Purity
07:19:55 <applicative> Then there is a picture of a monk illuminating a scroll ...
07:22:40 <fizruk> maverick_: I'm leaving in 10 minutes
07:23:45 <maverick_> fizruk: I think I'm fine, thanks for the help :)
07:24:28 <fizruk> maverick_: ok :)
07:25:44 <Raydiation> the let ... in confuses the hell out of me. in every other language in is used to iterate over a list like: for elem in list
07:26:15 <Maior> Raydiation: s/every other language/every other language I've used/
07:26:23 <Raydiation> yes
07:26:40 <Maior> in the first language I was taught, that's how let-in works
07:26:40 <applicative> its very MLish just as it stands
07:27:35 <Raydiation> is the stuff that follows in a block that uses that binding?
07:27:47 <Maior> applicative: heh, and that was the language
07:27:52 <Maior> Raydiation: pretty much
07:28:24 <DMcGill> Raydiation: "let name = defn in code"
07:28:41 <DMcGill> 'name' is in scope for 'defn' and 'code'
07:28:49 <Raydiation> ty
07:29:22 <applicative> Raydiation: it can often be redone using the 'where' style
07:29:30 <Raydiation> Maior: did you study at MIT? iirc they use scheme for introduction courses
07:29:46 <applicative> code where name = defn
07:30:00 <Maior> Raydiation: Cambridge (it was ML)
07:30:18 <applicative> at CMU they must all learn ML now
07:30:53 <applicative> Standard ML is taking over the planet!
07:31:48 <bennofs> Can anybody explain to me how the Action class in monoid-extras is supposed to be used?
07:33:26 <applicative> scalar multiplication would be an example bennofs
07:35:40 <applicative> it does look a little impractical
07:35:56 <DMcGill> @where monoid-pearl
07:35:56 <lambdabot> I know nothing about monoid-pearl.
07:36:15 <DMcGill> it's definition (and inspiration) is in here: http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
07:36:19 <DMcGill> its*
07:37:10 <DMcGill> under "Variation V: Transformations and monoid actions"
07:37:33 <applicative> hah, its one method act :: m  -> a -> a has the default implementation act _ a = a
07:38:08 <DMcGill> because that is the only possible definition when you know nothing about your types
07:38:37 <applicative> yes, the amusing thing is that he provides it
07:39:44 <DMcGill> ah I see what you mean now. Possibly some sort of use in prototyping? Punishment for not enabling FlexibleInstances?
07:44:28 <ParahSailin> is this reverse ByteString -> [Char] going to have good performance? http://lpaste.net/93492
07:47:11 <DMcGill> it looks similar to the definition of unpack except that yours isn't amenable to fusion.
07:47:36 <ParahSailin> so thats what the black magic of "build" in the library definition does?
07:47:51 <applicative> this is supposed to yield the reverse
07:48:22 <applicative> ParahSailin: if its defined with build it can be eliminated in pleasant ways by the consumer
07:48:35 <ParahSailin> updated to show the second candidate http://lpaste.net/93492
07:49:30 <DMcGill> the way I understand fusion is that if you have f = build . streamF . unbuild; g = build . streamG . unbuild and {-# RULE unbuild . build = id #-} then f . g = build . streamF . streamG . unbuild
07:49:46 <DMcGill> i.e. you eliminate some intermediate structure.
07:49:50 <ParahSailin> the second is straight modification of the unpack in the library, but im not quite sure why this would have good performance
07:50:16 <applicative> DMcGill: this is the build / foldr sort of fusion though
07:51:15 <applicative> ParahSailin: it is in the spirit of things; i've never seen build (\cons nil -> ...) use pointers like this but why not
07:51:20 <ParahSailin> how exactly is the second good performance when it seems to allocate the entire thing from the bottom
07:52:03 <ParahSailin> applicative: this is exactly how unpack in bytestring is defined
07:52:19 <ParahSailin> except with the direction of the pointer traversal reversed
07:52:20 <applicative> it should be the same as the first but with f replacing : and ch replacing [], to put it crudely
07:53:21 <ParahSailin> so starting at zero and then iterating all the way to len?
07:53:28 <applicative> since build op = op (:) []
07:53:55 <ParahSailin> does build do some very secret things?
07:54:51 <applicative> its just that if then you 'consume' with foldr f n (build op) , you can writre op f n instead
07:55:00 <applicative> or am i getting terms mixed up
07:55:14 <applicative> basically foldr replaces : and [] with the folded operation and the seed
07:55:37 <applicative> build makes sure that the definition abstracts over : and [], thus the list can be eliminated
07:56:41 <ParahSailin> what setting in ghci shows you the time and space used?
07:56:58 <timvishe`> anyone know where i can get 2009.2.0?
07:57:15 <ParahSailin> :set -?
07:57:20 <applicative> so if i have mysum = foldr (+) 0 then the result of rewriting will be  withPtr fp $ ..., where ... is the stuff that follows in your definition, but with + for f and 0 for ch
07:57:35 <geekosaur> :set +s
07:57:55 <ParahSailin> ah, i knew it was s, forgot it was a plus
07:58:11 <applicative> ParaSailin: i mean if i do foldr (+) 0 (unpackRev'' bs)
08:02:07 <timvishe`> i'm trying to get pandoc running on centos5 and i need, apparently, that version
08:03:17 <seanparsons> Is anyone using Cassandra from Haskell here at all? I'm tempted to think the two libraries I've seen so far might as well not have been written.
08:03:47 <ParahSailin> hm, ghci +s is not really helping me get the answer which one is better
08:04:36 <applicative> timvishe`: that is a 'haskell platform' number, are you sure it is needed?
08:05:11 <ParahSailin> at least the first one looks like it is lazy in forming the entire list
08:05:27 <ParahSailin> the second looks like it has to form the entire list first
08:05:37 <timvishe`> applicative: working with https://gist.github.com/896921/81b18ee8bdc6e94004025a03e68c8b5d8db0540a
08:05:39 <timvishe`> :)
08:06:53 <applicative> yes this material is way too old
08:08:09 <timvishe`> applicative: any suggestions then?
08:08:39 <applicative> you should look into installing ghc in a more recent version hm.
08:08:40 <timvishe`> i'm on Linux 2.6.18-308.1.1.el5xen i686
08:08:54 <applicative> oh
08:09:36 <applicative> you don't have access to a ghc
08:10:13 <ParahSailin> hm, looks like the pragmas in bytestring unpack do some magic too
08:10:31 <ParahSailin> how do you get started in optimization with ghc pragmas
08:10:38 <ParahSailin> i have no idea about any of that stuff
08:11:56 <applicative> timvishe`: i mean does the usual package managing give you one?  you might take a look at http://www.vex.net/~trebla/haskell/haskell-platform.xhtml though for pandoc only you dont need the whole haskell platform
08:12:56 <merijn> applicative: The problem seems to be that GHC no longer supports his linux version
08:13:58 <timvishe`> applicative: the default package repositories do not have ghc, and as merijn says, ghc no longer supports my system
08:14:05 <timvishe`> that's why i'm looking for the old packages
08:14:12 <timvishe`> they've been removed from the hackage site, it seems.
08:14:52 <rootnode> linux 2.6? wow
08:14:59 <ibotty> timvishe`: what about upgrading your linux distro then? or maybe run a virtual machine?
08:15:19 <merijn> Terminology check "polynomial functor" = fancy way of describing "newtype Rec f a = Rec (f (Rec f a))"?
08:15:19 <timvishe`> ibotty: not an option, unfortunately. at least not an easy one. :)
08:15:26 <ibotty> ic
08:15:49 <ibotty> may i ask why? hardware issues? not root?
08:16:09 <toddaaro> easy haskell question, but I failed to figure this out via google, how does one do a monadic operation inside a conditonal test? something like "if readIORef someBooleanIORef then do ..."?
08:16:55 <merijn> toddaaro: Do the IO first, use the result in the if
08:16:58 <timvishe`> ibotty: organizational. this is the ami we use for all developers and it'd be a real headache to get the whole organization to upgrade just for pandoc
08:17:00 <stevely> readIORef someBooleanIORef >>= \b -> if b then ..."
08:17:18 <merijn> toddaaro: i.e. "do { x <- myIO; if predicate x then doMoreIO else doOtherIO }"
08:17:26 <timvishe`> i might be able to argue for a newer box just to run pandoc, but that also seems a little extreme. :)
08:17:37 <toddaaro> merijn stevely : ah, is that the only way? if so that is pretty straightforward but quite verbose
08:17:40 <ibotty> politics then...
08:17:47 <applicative> ParahSailin: it looks like https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L364 is the main work behind ByteString.Char8.unpack
08:17:48 <ibotty> well, well.
08:17:48 <DMcGill> I'm struggling to abstract my comonad instance for Triple (Triple a). I have it working but there's some duplicated code that I feel like I should be able to get rid of. http://lpaste.net/93496
08:18:12 <DMcGill> For example the Comonad instance for Triple a isn't used in the one for Triple (Triple a) which seems off
08:18:14 <merijn> toddaaro: I think so, if you need to do it a lot, you could define "ifM :: IO Bool -> IO a -> IO a -> IO a"
08:18:23 <merijn> @hoogle ifM
08:18:23 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
08:18:23 <lambdabot> Foreign.C.Error throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
08:18:23 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
08:18:25 <applicative> ParahSailin: the pragma attached to unpack itself is just an INLINE
08:18:35 <merijn> toddaaro: Doesn't look like it exists yet
08:18:49 <toddaaro> merijn: ok, I'll consider that. Thanks for the info (and stevely too)
08:19:28 <merijn> toddaaro: Basically, there's a million of functions like this and you need to stop including stuff somewhere. So the usual approach is to just define a function like that yourself
08:21:52 <DMcGill> The point of my code is to set the pointer to each of the 9 elements then replace the value at each point with the value of f applied to the structure while that element is being pointed at
08:22:07 <DMcGill> so f still needs to be given the whole structure with only the pointer modified
08:23:12 <ParahSailin> what exactly do INLINEs do
08:24:32 <ParahSailin> there's also this one {-# RULES
08:24:33 <ParahSailin> "ByteString unpack-list" [1]  forall p  .
08:24:33 <ParahSailin>     unpackFoldr p (:) [] = unpackBytes p
08:24:33 <ParahSailin>  #-}
08:25:23 <rootnode> ugh, I'm starting to hate haskell more and more
08:25:59 <applicative> timvishe`: you just need to start at http://www.haskell.org/ghc/ and find the first one that works.
08:26:06 <rootnode> going back from haskell to other languages takes the fun out of them
08:27:06 <merijn> ugh, I need a McBride-to-mere-mortal translator
08:27:19 <rootnode> McBride?
08:27:50 <rootnode> ok, quick google search tells me: Conor McBride?
08:27:52 <merijn> rootnode: He's FP researcher
08:27:54 <merijn> rootnode: Yeah
08:27:58 <rootnode> ah
08:28:02 <rootnode> nice. didn't know him
08:28:09 <rootnode> seems like I have to read his blog
08:28:22 <TallerGhostWalt> Man, is hayoo down for anyone else?
08:28:26 <merijn> rootnode: Good luck :)
08:28:58 <rootnode> TallerGhostWalt: counterquestion: who uses yahoo? ^^
08:29:10 <rootnode> even the japanese people here stopped using it :D
08:29:11 <merijn> rootnode: Hayoo /= Yahoo
08:29:22 <merijn> rootnode: In the same way Hoogle /= Google
08:29:24 <rootnode> oh
08:29:34 <applicative> merijn: ha what are you reading?
08:29:34 <rootnode> my brain is misconfigured :D
08:29:35 <merijn> @where hayoo
08:29:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
08:29:39 <TallerGhostWalt> hehe
08:29:47 <TallerGhostWalt> that was funny
08:29:50 <merijn> applicative: Clowns to the Left of me, Jokers to the Right
08:29:52 <applicative> timvishe`: this seems to be the version under discussion http://www.haskell.org/ghc/download_ghc_6_10_2
08:30:03 <merijn> TallerGhostWalt: Down here too
08:30:05 <applicative> merijn: oh man forget it, yes ;)
08:30:35 <merijn> applicative: Although reading might be an overstatement for what I'm doing with that
08:30:39 <TallerGhostWalt> merijn: anyone talk about what is going on... It just came back!
08:31:00 <merijn> applicative: Perceiving letters and becoming confused is a more accurate description
08:32:08 <TallerGhostWalt> well what I wanted to see was if there was a "readEither" like "readMay"
08:32:34 <applicative> see the errors package TallerGhostWalt
08:33:49 <luite> carter: if i update to xcode 5, what do i need to do?
08:33:53 <applicative> TallerGhostWalt: http://hackage.haskell.org/package/errors-1.4.2/docs/Control-Error-Safe.html#v:readErr
08:33:53 <merijn> TallerGhostWalt: There is in GHC7.6
08:34:12 <merijn> TallerGhostWalt: Text.Read exports readEither and readMaybe in 7.6 and newer
08:34:21 <applicative> oh theres a readEither so to say too
08:34:49 <merijn> luite: Do you know if there's a write up of the technical design and implementation of ghcjs somewhere?
08:34:57 <ParahSailin> i did everything the same, but its still slow http://lpaste.net/93498
08:35:04 <rootnode> damnit...I wanted to go for a midnight snack and they are out of fried stuff
08:35:21 <timvishe`> applicative: thanks for the pointer.
08:35:40 <applicative> i see readErr is different, you attach your own 'error' for the left value
08:35:42 <merijn> luite: Specifically, I'm interested of what exactly was necessary to implement the ghcjs RTS and code generation
08:36:03 <timvishe`> so you're saying that pandoc doesn't depend on the whole haskell platform, but it does recommend being installed through cabal.
08:36:05 <timvishe`> does this get me cabal?
08:36:15 <timvishe`> (sorry, but i'm a bit of a haskell n00b)
08:37:44 <ParahSailin> im at my wit's end here
08:38:55 <applicative> no, the ghc build does not give you cabal-install; you will need to build cabal from source, which is not too horrible. when you have a ghc that works, do 'ghc-pkg list Cabal' and it will tell you the number of the 'library' Cabal you are using, then get the tarball for the corresponding version of cabal-install; there will still be plenty of trouble of course ;)
08:39:53 <sray> quit
08:40:07 <timvishe`> applicative: well that's encouraging. :)
08:40:10 <cschneid> merijn: Either [Clown] [Joker] ?
08:40:31 <applicative> timvishe`: you won't have this, http://hackage.haskell.org/package/cabal-install but you will have this http://hackage.haskell.org/package/Cabal
08:40:52 <merijn> Right, does anyone know of a slightly less brutal intro to this clowns to the left, jokers to the right stuff than the paper?
08:42:01 <ystael> merijn: holy bunny buckets, you aren't kidding
08:42:06 <applicative> that would presuppose that someone understood it
08:44:11 <merijn> applicative: I understand what he's doing, I was just hoping for a slightly slower and gentler intro. This one requires careful scrutinisation of every line, I'd prefer a slower presentation :p
08:44:36 <acomar> merijn: you'll have to write it for us :)
08:44:44 <merijn> The idea itself isn't even that complex
08:49:34 <t7> proving matrix transpose is an inverse of itself is a fair bit harder than list reverse :(
08:51:04 <TallerGhostWalt> merjn: thanks
08:51:13 <acomar> t7: it shouldn't be, what issue are you having?
08:51:19 <ReinH> t7: think about it pairwise
08:51:50 <ReinH> t7: what happens to the (i,j) entry of A? A^T? A^TT?
08:51:53 <luite> merijn: not yet, haven't really had time to do so
08:52:13 <ReinH> well, not pairwise, but entry-wise
08:52:50 <t7> i defined my transpose like this:  (where m is a list of list) transpose m = map head m ∷ transpose (map tail m)
08:53:09 <t7> :: is concat
08:53:28 <luite> merijn: had earlier this week a short demo at the haskell symposium but that hardly had technical info
08:53:29 <ReinH> sure
08:53:52 <merijn> luite: Let me know when you do (or else I will just bug you until you give in once I need it ;)
08:53:56 <luite> merijn: nest week i'll have a bit more time at the nyc haskell user group, i think the slides could give some high level info
08:54:12 <luite> merijn: but just ask if you want to know anything specific
08:55:15 <merijn> luite: I have nothing specific yet, I was just curious how much work is required to reimplement the GHC RTS and mess with the code generation and ghcjs is the most recent effort in this area that came to mind :)
08:56:27 <luite> merijn: there are basically two backends, one is the concurrent backend which uses its own stacks like GHC, and a non-concurrent which just uses js calls
08:56:32 <luite> on the js stack
08:57:04 <luite> the latter is not yet done (only for the old ghcjs, port to gen2 is not yet completed), wanted to do the version with full haskell support first
09:00:04 <ParahSailin> oh i see, the rules pragma tells it to disregard the above code and just use a faster version defined somewhere else?
09:03:12 <timvishe`> ghc 6.10.2 installed fine after installing libedit
09:03:56 <timvishe`> cabal is failing on 51 of 51 when doing `ghc --make Setup` because `/usr/bin/ld: cannot find -lgmp`
09:03:58 <timvishe`> any thoughts?
09:05:21 <enthropy> you need a  libgmp.so or libgmp.a
09:06:07 <timvishe`> enthropy: thanks. i'll try that.
09:06:25 <timvishe`> that seems to have been the problem!
09:06:59 <luite> merijn: the main chunks are here: https://github.com/ghcjs/shims/blob/master/src/thread.js , https://github.com/ghcjs/shims/blob/master/src/stm.js <- threading and stm
09:07:03 <luite> merijn: https://github.com/ghcjs/ghcjs/blob/master/src/Gen2/Rts.hs , https://github.com/ghcjs/ghcjs/blob/master/src/Gen2/RtsApply.hs  <- various RTS things and thunks, and all the STG optimized function application paths (autogenerated)
09:10:40 <merijn> luite: Thanks, I'll check it out :)
09:10:56 <luite> merijn: although none of this is really required if you want to know the minimum to make running haskell somewhere work
09:11:44 <merijn> luite: I'm just curious to see what others are doing so I can get an idea of where to look and where to start :)
09:12:41 <luite> merijn: the making a fast curry paper is a useful start for the stg basics
09:15:59 <ski> @tell roconnor "Stealthy Dopant-Level Hardware Trojans" by Georg T. Becker,Francesco Regazzoni,Christof Paar,Wayne P. Burleson in 2013-08 at <http://people.umass.edu/gbecker/BeckerChes13.pdf>
09:15:59 <lambdabot> Consider it noted.
09:16:26 <iamarto> Hi Haskdevs
09:16:39 <iamarto> How's everyone hasking today?
09:17:06 <luite> merijn: what target are you going to do?
09:17:23 <iamarto> I need to talk to haskers.. I am a haskell noob and I want to know more about the community
09:18:42 <iamarto> So.. Is haskell good at GUI yet?
09:19:39 <chrisdone> iamarto: what does that mean?
09:19:51 <sellout-> iamarto: I haven’t done any Haskell GUI, but I think the functional GUI libs are at least cool in concept.
09:20:09 <fryguybob> iamarto: Can you give an example of something that you consider "good at GUI"?
09:20:54 <jrslepak> any idea why cabal doesn't want to install cabal-install?  error result: http://pastebin.com/btGC4PyG   .cabal/config: http://pastebin.com/gw7x0eci
09:21:04 <mauke> The pastes btGC4PyG gw7x0eci have been copied to http://lpaste.net/93499 http://lpaste.net/93500
09:21:40 <osfameron> iamarto: presuambly "has mature libraries that are capable of producing powerful and appealing UIs, and a vibrant community developing and maintaing the tools" ?
09:22:57 <rootnode> iamarto: looking at leksah I'd say yes
09:23:10 <osfameron> iamarto: http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html might be a good place to look?
09:24:12 * osfameron hasn't tried leksah, should really check it out
09:24:14 <HugoDaniel> has anyone tried the fpcomplete ide ?
09:24:26 * ReinH doesn't understand why every new Haskell developer wants to do GUI
09:24:32 <ReinH> there are so many more interesting things to do
09:24:41 <HugoDaniel> like calculating fib numbers
09:24:43 <osfameron> HugoDaniel: that's the cloud-based one isn't it?
09:24:44 <HugoDaniel> :)
09:24:45 <ReinH> (granted that Haskell still does not have a very good GUI story)
09:25:08 <HugoDaniel> osfameron: yes, at least they say so
09:25:15 <HugoDaniel> i haven't tried it yet
09:25:29 <osfameron> I watched a video on it, it looked like a great idea
09:26:03 * osfameron wonders whether to install leksah on windows, or inside an ubuntu VM... presuambly I can X-tunnel leksah out of that?)
09:26:43 <HugoDaniel> osfameron: why not use vim ?
09:26:48 <osfameron> this is where the whole "run windows, dev in ubuntu via vagrant" story gets complicated.
09:26:56 <osfameron> HugoDaniel: oh, curiosity mostly
09:27:03 <HugoDaniel> ok :)
09:27:15 <osfameron> but also as haskell is well introspectable, I'm interested to see how an IDE allows it to do Clever Things
09:27:29 <ReinH> osfameron: why not dual boot?
09:27:45 <osfameron> ReinH: because that's a faff, and I'd end up just running ubuntu
09:27:52 <ReinH> I can't imagine doing any serious dev work on any non-MS language in Windows
09:28:00 <ReinH> (if I had a choice)
09:28:13 <osfameron> indeed.  hence all my dev work is in Ubuntu via Virtualbox / Vagrant / ConEmu
09:28:28 <osfameron> it's remarkably painless (except for running GUI apps)
09:28:36 <iamarto> rootnode, osfameron what about developing with Haskell for Android? Any links?
09:29:13 <osfameron> iamarto: I'm sure it's possible, but it's probably not the most commonly used language for it.  Why do you ask?
09:29:20 <osfameron> s/probably/almost certainly
09:29:24 <osfameron> s/almost//
09:30:35 <osfameron> iamarto: if you love and know haskell, you can do anything with it.  If you don't, then frankly it'd be easier to do Android dev in Scala/Java/JS/Go/whatever
09:31:07 <iamarto> osfameron, because I was learning Java but when I stumbled upon the concept of  Haskell being Purely Functional.. I just felt that THIS IS what I was looking for.. I don't want to write code in a random way.. a concise, functional program will work without any risk for bugs or bad writing habbits..
09:31:16 <rootnode> iamarto: not that I know of
09:31:33 <rootnode> I know that there's haskell + iOS
09:31:37 <rootnode> but I don't know about android
09:32:08 <osfameron> iamarto: great!  I'd very much recommend learning haskell.  If you are learning Java for Android specifically, then why not look at one of the functional languages on the JVM - Scala or Clojure?
09:32:35 <jeltsch> iamarto: Well, you always have the risk of introducing bugs or using bad style. However with Haskell, this risk is much smaller.
09:32:39 <osfameron> iamarto: on the basis that there is better tooling, and more advice and support from developers that have done it before.
09:32:50 <osfameron> iamarto: and learn Haskell in the meantime doing something simpler.
09:32:57 <iamarto> osfameron, it was said that Scala is very complex for a beginner who is starting to learn programming.. and also the tools for Scala. I felt that the documentaion was very complex for Scala..
09:33:12 <sellout-> Yeah, both Scala and Clojure are interesting and good languages, IMO, especially if you’re tied to the JVM.
09:33:19 <iamarto> osfameron, java was more well documented. But as for clojure.. not sure. Is it purely functional?
09:33:30 <elliott> scala as a first language sounds like a nightmare.
09:33:46 <sellout-> iamarto: Clojure pretty much is, and probably much simpler to start with than Scala.
09:34:01 <jeltsch> iamarto: If you want to do pure functional programming (which I recommend), use Haskell.
09:34:07 <sellout-> Even as a not-first language, Scala is pretty complex. I think knowing something like Haskell is helpful beforehand.
09:34:16 <iamarto> I agree
09:34:36 <iamarto> So what is the benefit of Clojure.. what's the selling point it has?
09:34:55 <Rembane> Scala seems ubercomplex. But quite managable if you want to keep the code sane.
09:34:59 <jeltsch> sellout-, iamarto: I dont think that Clojure is anything like purely functional.
09:35:08 <osfameron> iamarto: there is some documentation on http://www.haskell.org/haskellwiki/Android (and more via a google search).  But my guess is that it will be "fun", and not necessarily the most streamlined development process.
09:35:43 <iamarto> osfameron, so you think JNI is mature yet?
09:35:43 <chrisdone> jeltsch: immutible core data types is a very good start at being functional programming, imo
09:36:20 <osfameron> iamarto: I don't know.  What I'm trying to tell you is that it's possible, but probably not simple.
09:36:20 <chrisdone> jeltsch: making your data types immutible tends to impose a functional style
09:36:45 <iamarto> I am confused in regards to Haskell about Loops.. let's say I want to make a Watch program.. how can I do it without loops??
09:36:46 <osfameron> iamarto: are you *most* interested in:  a) learning Haskell.   b) writing a GUI app for Android.
09:36:52 <chrisdone> that's a distinct difference between Clojure and Common Lisp/Scheme
09:36:55 <sellout-> jeltsch: Why not? Because of transients? (Admittedly, I haven’t done any “real” Clojure, just played with it)
09:36:58 <iamarto> osfameron, ab
09:37:18 <roconnor> dolio: okay I'm fairly conviced that enumerating all haskell programs is a via implementation even for type 2 computability people like me.  This is because, all though you may not enumerate all points in the domain, you will enumerate all the "finite" points in the domain, which should be good enough as any function can only be called a finite number of times if a non-bottom value is returned.
09:37:40 <fizbin> Hey, anyone know how to set the ghci prompt that's used for when you're in the middle of a multiline :{ expression?
09:37:56 <fizbin> Because my prompt explodes once I do that.
09:38:08 <chrisdone> CL/Scheme folk like to say that these languages are functional, but in practice people write imperative code for everything
09:38:24 <osfameron> iamarto: they are 2 completly different things...  my recommendation would be to learn Haskell, while also continuing to develop against Android in a *common* framework.  Once you've learnt enough of Haskell and Android (separately) *then* look at writing Haskell on Android.
09:38:32 <osfameron> iamarto: otherwise you'll just find both a and b annoying.
09:38:53 <iamarto> osfameron, I see. But Haskell looks like more fun than Java :)
09:39:31 <iamarto> osfameron, I am a fan of concise single line expressions.. Java is the opposite.. strongly typed but more like an essay
09:39:32 <osfameron> iamarto: then learn both.  Learning Haskell will help you program Java better.  Learning *anything* new and different (even Java) will help you develop.
09:39:38 <sellout-> chrisdone: I don’t think actual CL people say it’s functional, in fact, when people come into #lisp with that idea, they are quickly dissuaded. Racket does try to take Scheme in a more functional  direction, though, like not including mutable conses in the default language.
09:39:56 <iamarto> osfameron, What do you think about Clojure?
09:39:58 <monochrom> @quote monochrom lisp
09:39:58 <lambdabot> monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
09:40:04 <stevely> fizbin: I don't think there's a way to do it currently. the 7.8 notes say there's going to be a "prompt2" setting for that, though
09:40:20 * monochrom always quotes himself :)
09:40:24 <sellout-> My CL code (my primary language) leans toward a functional style, but more than most people, and I still wouldn’t say it’s a very functional language.
09:40:26 <chrisdone> sellout-: true, the CLers I know in person know it's about as imperative as python. but i still read such claims online
09:41:04 <osfameron> iamarto: it looks nice... on my list of things to play with.  tbh just play with whatever you want to :-)  just be *aware* that some things might be more frustrating with platforms that are less commonly used for a given task.
09:41:16 <sellout-> chrisdone: Yeah, I think it’s a popular view by the people who haven’t written it, along with “it’s slow” and “it’s elegant”.
09:41:17 <chrisdone> monochrom: “don't quote me on that. because it's my quote to use”
09:41:27 <monochrom> haha
09:42:35 <ReinH> monochrom: ironic, because most of your time in lisp is spent processing syntax trees.
09:42:49 <iamarto> I am running on Manjaro Linux now.. and I didn't find any Leskah packages to install
09:42:56 <sellout-> ReinH: Which are just lists of lists, of course.
09:43:27 <jeltsch> sellout-, chrisdone: Clojure allows sideeffects during expression evaluation, right? So its not purely functional.
09:43:40 * chrisdone squints
09:43:49 <chrisdone> is that what purely functional means?
09:43:53 <jeltsch> Its similar for ML: Ordinary variables are not mutable, but you can mutate other things.
09:43:59 <jeltsch> chrisdone: Yes.
09:44:11 <chrisdone> mmk
09:44:40 <iamarto> Sorry, just found it
09:44:41 <sellout-> jeltsch: That’s true. I buy it. No IO monad. Boom.
09:45:23 <ReinH> sellout-: touche
09:45:52 <sellout-> Also, you can call arbitrary Java/JVM stuff, so basically anything on the JVM (that actually gets some benefit from being on the JVM) isn’t going to be purely functional.
09:47:14 <stevely> technically, the IO monad just describes IO actions that are run outside of haskell, so it's pure in the context of haskell
09:47:14 <chrisdone> how does that differ to using unsafePerformIO or the FFI?
09:48:43 <levi> So clean's not purely functional either? It's got no IO monad.
09:49:04 <chrisdone> jeltsch: f x = unsafePerformIO getCurrentTime -- is f purely functional?
09:49:32 <acomar> these arguments are always so unproductive...
09:50:07 <jeltsch> chrisdone: Of course not.
09:50:07 <mr-> (and not even fun)
09:50:38 <chrisdone> jeltsch: but it has no side effects. isn't that what purely functional means?
09:50:41 <monochrom> Clean uses uniqueness types to track IO. so you don't get a monadic type, but you still get a distinguished type.
09:50:45 <jeltsch> But unsafePerformIO is not real Haskell. Its just a low-level hack that you should only use inside core libraries.
09:50:59 <jeltsch> chrisdone: Okay, I see your point.
09:51:04 <monochrom> or shall I say i/O
09:51:07 * elliott sighs the biggest sigh in the universe.
09:51:28 <jeltsch> chrisdone: Most important for purely functional is that results of expressions dont depend on some current state.
09:51:43 <sellout-> acomar: I think as arguments, they are, but as a conversation it can be informative.
09:51:44 <chrisdone> monochrom: i should check out clean some time, the uniqueness thing and performance seems enticing =)
09:51:49 <jeltsch> chrisdone: However expression evaluation also shouldnt cause changes of the state.
09:52:14 <jeltsch> Of course, every expression evaluation changes some state: memory usage, CPU temperature, you name it.
09:52:40 <carter> luite: well
09:52:41 <shachaf> elliott: Wow, that's a pretty big sigh.
09:52:48 <carter> luite: still tere?
09:53:18 <jeltsch> chrisdone: But if expression evaluation opens a GUI window (as it can happen in Clojure AFAIK), then the language is not purely functional.
09:53:29 <elliott> shachaf: it did not work.
09:53:32 <acomar> sellout-- maybe, but it gets old at some point. I'm starting to view "purely functional" as a linguistic trap because the definition depends on the reader
09:54:05 <acomar> talking about various specific things like immutability be default, segregation of effects, etc. is much more productive
09:54:10 <elliott> most things #haskell gets into once a week would be more tolerable if they weren't so frequent, yes :p
09:54:57 <imalsogreg> I'm having a problem with pipes if you want a distraction :)
09:55:25 <monochrom> you don't have to make a judgement "is it pure?" to be informative. you can just state: what are the restrictions on effects? what are the restrictions on mutations? that is all you need to know.
09:55:26 <haasn> daily reminder that C is purely functional (if you squint hard enough)
09:55:28 <sellout-> jeltsch: Yeah, I’ve been working on a (at least partially Haskell) project, that attempts to provide information flow control, and beyond the usual abstract stuff, it really restricts a lot of stuff under the idea that runtime, mem usage, temp, etc. can leak info.
09:55:30 <jeltsch> acomar: I would say purity is about segregation of effects. The point just is what is considered an effect. Opening a GUI window is clearly an effect. But is allocating memory an effect?
09:55:48 <chrisdone> jeltsch: possibly one interesting part is that clojure doesn't distinguish between expressions and not-expressions
09:55:49 <sellout-> I feel like it’s too restrictive, or at least too complicated to get right, but I’m not really in charge.
09:56:11 <sellout-> Or wasn’t – I haven’t been on the project for a few weeks now.
09:56:18 <imalsogreg> I have a Producer MyThing m (Either ( complicated ) () ), which I can link to Pipes.print with (>->).  But piping it through Pipes.Prelude.take doesn't work b/c take has specific return type ()
09:56:28 <chrisdone> jeltsch: i wonder if this distinction should be part of your definition, and whether static typing is required to make it?
09:56:45 <levi> chrisdone: BLISS was an expression-oriented language, but was definitely not functional, let alone purely so.
09:57:02 <ReinH> haasn: daily reminder that Haskell is an imperative langauge if look deep enough.
09:58:13 <acomar> jeltsch- I'm not really looking to argue about what purity is and isn't. As for allocating memory, it depends on your notion of identity. If you're depending on pointer identity, then yes it's an effect. Otherwise, probably not.
09:58:37 <haasn> ReinH: obligatory https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
09:58:42 <foobarbaz> Hi guys, I was just wondering why haskell uses lowercase letters for polymorphic types
09:59:00 <foobarbaz> whilst the normal notation uses capitals  i think? ie `f: X -> Y`
09:59:11 <chrisdone> hm, dunno
09:59:13 <haasn> I'm not sure there has to be a reason. It looks better?
09:59:16 <monochrom> lower case for variables, upper case for constants.
09:59:17 <haasn> rather than the other way around
09:59:38 <foobarbaz> I thought upper case was for Data types?
09:59:43 <foobarbaz> a -> M a
09:59:48 <monochrom> but it's unimportant. someone chose a convention he/she liked, and it stuck.
09:59:51 <acomar> jeltsch- perhaps there's a more succinct way of putting that. Basically, if you care about the reference, it's probably effectful. If you care about the value, it's probably not.
09:59:59 <jeltsch> I think as soon as side effects are an intended part of expression evaluation, the language becomes impure. So if you evaluate an expresson for the purpose of opening a GUI window, you have an impure language; however evaluation causing just an annoying side effect you dont intend (e.g., memory consumption) doesnt make your language impure.
09:59:59 <monochrom> M is a constant
10:00:18 <lightquake> foobarbaz: right, in the type a -> Integer, Integer is a constant type, but a is a type variable
10:00:24 <monochrom> or, if you don't like "constant", how about non-variable?
10:00:51 <foobarbaz> ah, thanks :)
10:00:52 <monochrom> "variable" = can be instantiated. "non-variable" = cannot be instantiated, already stands for itself
10:01:00 <foobarbaz> So is `f: X -> Y`
10:01:04 <jeltsch> acomar: Its not just about references. If you dont have any mutable variables, but expression evaluation can fetch data from stdin or put data to stdout, then your language is impure.
10:01:07 <foobarbaz> Actually types, rather than variables
10:01:18 <foobarbaz> I'm looking at http://en.wikipedia.org/wiki/Surjective_function you see
10:01:37 <acomar> jeltsch- like I said, I'm not arguing about purity. I was answering your question about effects and memory allocation.
10:02:54 <monochrom> is Haskell liberal or conservative? :)
10:03:16 <acomar> lawful good
10:03:19 <stevely> it's flexible enough for both, you can fold left or you can fold right
10:03:30 <monochrom> haha
10:03:51 <chrisdone> probably pure functional should just be 'pure' given that the criteria so often specified for what pure functional is focuses soley on the former word, and zero attention paid to the latter. a pure stack language or prolog would qualify to most definitions people give and they don't have functions
10:04:26 <ski> foobarbaz : nitpick, it's not "polymorphic types" (which would be another thing), it's "type variables"
10:05:11 <haasn> stevely: (but we all know left folds are just glorified right folds)
10:06:38 <ski> papers often use minuscule greek letters for type variables
10:06:43 <foobarbaz> ski I seem to remember reading them referred to as 'polymorphic types', perhaps in learn you a haskell?
10:07:01 <foobarbaz> But i'm new, so i'll remember that thanks
10:07:19 <ski> foobarbaz : maybe. in any case, "polymorphic types" is a minunderstanding. it's not the type which is polymorphic here, it's the *value*
10:09:03 <ski> foobarbaz : so, if we have `length :: [a] -> Int', then `length' is a polymorphic type, because it can be used in any specific instance you get by susbtituting the type variable `a' with another type, so that `length' can be used as having types `[Double] -> Int',`[String -> Maybe Int] -> Int',`[(Int,Maybe b)] -> Int',&c.
10:09:05 <jeltsch> chrisdone: Prolog is by no way pure. Side effects are done via special predicates. Such an impurity is even worse for logic programming languages like Prolog, since then non-obvious execution order becomes important.
10:09:08 <acomar> foobarbaz: to expand on ski's point, a type variable labels a polymorphic value
10:09:48 <ski> foobarbaz : if we want to be explicit here, we could write the signature of `length' like `length :: forall a. [a] -> Int', to emphasize that `length' has type `[a] -> Int' for *all* choices of a type for the type variable `a' that we like
10:10:40 <elliott> ski: length *is* a polymorphic type?
10:11:09 <ski> er, sorry, typo
10:11:28 <ski> foobarbaz : "then `length' is a polymorphic type" should be "then `length' is a polymorphic *value*"
10:11:32 <chrisdone> jeltsch: i said "a pure (stack language or prolog)". i know that normal prolog can do side-effects
10:12:20 <ski> foobarbaz : using this idea, we can then say that a polymorphic value (usually, but not always, a function) is a value that has a type that starts with `forall' -- if we wanted to, we could perhaps call such a type a "universal type"
10:13:07 <ski> chrisdone : Mercury is a pure declarative logic programming language
10:13:09 <chrisdone> ski: if x <> y = y <> x = y, then x is the identity. if x <> y = y = y <> x = y = y, what's y?
10:13:18 <ski> (incidentally also supports functional programming)
10:13:27 <chrisdone> i forgot about mercury. mercury is cool =)
10:13:39 <ski> indeed :)
10:13:46 <DMcGill> what's the standard fixity of (.:)?
10:14:02 <ReinH> chrisdone: zero :)
10:14:13 <chrisdone> ah, d'oh
10:14:29 <ski> DMcGill : i often say `infixr 9'
10:14:35 <chrisdone> i noticed this guy's question is a monoid: http://www.reddit.com/r/haskell/comments/1n8o5a/are_all_values_of_a_list_equal/
10:14:43 <ski> perhaps one could argue that `infixl' would be nicer -- not sure
10:14:55 * ski ponders it
10:15:02 <chrisdone> VacuousTruth is identity, SomeDifferent is zero
10:15:09 <haasn> I still need rational fixities..
10:15:23 <haasn> Or arbitrary in-betweens of some sort, at any rate
10:15:29 <ReinH> chrisdone: but you need a semiring: multiplication by zero annihilates
10:16:03 <quchen> chrisdone: Distinct identity and zero in one monoid? Sounds like a manyoid to me
10:16:05 <chrisdone> ReinH: that's what i want. _ <> SomeDifferent = SomeDifferent <> _ = SomeDifferent
10:16:19 <ReinH> actually you don't need a semiring, you need a monoid with an additional "zero" element
10:16:31 <ReinH> chrisdone: like Monoid a => Maybe a
10:16:33 <DMcGill> ski: it needs to bind looser than (.) though because: (f . Compose .: fmap . setIx)
10:16:34 <quchen> Ah, you were multiplying by zero, nevermind :-)
10:16:36 <chrisdone> AllEqual a <> AllEqual b | a == b = AllEqual a | otherwise = SomeDifferent
10:16:45 <ski> `(f . g) .: h' is `\a b -> f (g (h a b))', while `f . (g .: h)' is `\a -> f (\b -> g (h a b))'
10:17:03 <ski> so with `infixl', `f . g .: h' is the former, and with `infixr' it is the latter
10:17:16 <chrisdone> that gives you:
10:17:17 <chrisdone>     λ> mconcat (map AllEqual "aa") -> AllEqual 'a'
10:17:17 <chrisdone>     λ> mconcat (map AllEqual "") -> VacuousTruth
10:17:17 <chrisdone>     λ> mconcat (map AllEqual "ab") -> SomeDifferent
10:17:17 <ski> DMcGill> :t setIx
10:17:31 <DMcGill> you say that but: cannot mix `.' [infixr 9] and `.:' [infixl 9] in the same infix expression
10:17:40 <DMcGill> setIx is in my code
10:17:45 * chrisdone likes monoids
10:17:46 <ReinH> chrisdone: newtype Monoid a => AllEqual { runAllEqual :: Maybe a }
10:17:51 <elliott> chrisdone: these constructors have awful names :P
10:17:53 <ski> chrisdone : anyway, i'm not clear on how you're quantifying in your "if x <> y = y <> x = y, then x is the identity. if x <> y = y = y <> x = y = y, what's y?"
10:17:55 <elliott> chrisdone: btw, mconcat . map f = foldMap f
10:18:01 <ReinH> chrisdone: er, with an actual constructor and syntax that works
10:18:14 <chrisdone> hm, where's foldMap?
10:18:16 <chrisdone> @hoogle foldMap
10:18:17 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:18:17 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
10:18:18 <ReinH> chrisdone: SomeDifferent is just Nothing
10:18:20 <chrisdone> nice =)
10:18:25 <ski> DMcGill : yes, i assumed so. i asked you what its type is
10:18:29 <elliott> chrisdone: I think I prefer it being a semigroup.
10:18:34 <elliott> then you can layer Option on top to get a monoid
10:18:35 <DMcGill> ski: http://lpaste.net/93502
10:18:39 <elliott> giving you VacuousTruth
10:18:49 <DMcGill> setIx :: TripleIndex -> Triple a -> Triple a; setIx ix (TripleP _ a b c) = TripleP ix a b c
10:18:54 <ReinH> heh, yeah you don't need a monoid of a at all
10:18:58 <ReinH> since you aren't using plus
10:19:06 <chrisdone> @hoogle Semigroup
10:19:06 <lambdabot> package Semigroup
10:19:07 <lambdabot> package semigroupoid-extras
10:19:07 <lambdabot> package semigroupoids
10:20:11 <elliott> chrisdone: data Equating a = Diff | Same a
10:20:12 <chrisdone> needs moar examples
10:20:38 <ski> DMcGill : and you want `f . Compose .: fmap . setIx' to be `\i tta -> f (Compose (fmap (setIx i) tta))' ?
10:20:39 <elliott> chrisdone: instance Eq a => Semigroup (Equating a) where p@(Same a) <> Same b | a == b = p; _ <> _ = Diff
10:20:41 <chrisdone> elliott: that should be sufficient to implement the equality part yeah
10:20:51 <DMcGill> ski: yes
10:20:55 <elliott> chrisdone: then Option (Equating a) is a Monoid that you can get Maybe (Equating a) out of
10:20:55 <chrisdone> that's what i think was missing from ReinH's Maybe
10:20:59 <elliott> where Nothing corresponds to VacuousTruth
10:21:03 <elliott> (so you can fold it over a list)
10:21:08 <DMcGill> ski: \i -> f . Compose . fmap (setIx i) was what it was before
10:21:15 <ReinH> chrisdone: yeah, that's the type I meant to write :)
10:21:22 <DMcGill> it's probably better as that than to introduce (.:) if I'm honest
10:21:54 <ReinH> you obv need an Eq constraint if you want to compare things :p
10:22:05 <ski> DMcGill : how about something like `f .: Compose .: fmap . setIx' ?
10:22:10 <Athan> Anyone here know how to change the stack / heap size of executables? What's the command line syntax?
10:22:15 <chrisdone>     `.++.' is not a (visible) method of class `Semigroup'
10:22:16 <ski> (with `.:' being `infixr')
10:22:16 <chrisdone> huh
10:22:23 <ReinH> elliott: does that satisfy the semigroup laws?
10:22:32 <jfischoff> operationally, what is the value of coyoneda?
10:22:33 <elliott> ReinH: it's associative, so yes.
10:22:47 <ReinH> elliott: but id <> zero /= id
10:22:54 <ReinH> er
10:22:59 <ReinH> that's dumb and I am dumb
10:23:00 <elliott> ??
10:23:05 <jfischoff> if I understand correctly yoneda can avoid expansive fmaps. When does one reach for coyoneda?
10:23:08 <ReinH> elliott: never mind
10:23:12 <elliott> ok :P
10:23:12 <chrisdone> (ah, i'm reading the docs of one semigroup and using another)
10:23:24 <elliott> chrisdone: http://hackage.haskell.org/package/semigroups-0.11/docs/Data-Semigroup.html
10:23:27 <elliott> it's just a Monoid without mempty.
10:23:34 <chrisdone> yeah, i was looking at http://hackage.haskell.org/package/Semigroup-0.0.7/docs/Data-Semigroup.html
10:23:38 <elliott> and then Option gives you a Monoid from a semigroup by jamming on Nothing as the identity.
10:23:39 <chrisdone> which is the same but different operator
10:23:43 <DMcGill> ski: you're making it clear to me that .: isn't really what I want and I should just use the (\ix -> ...) formulation :)
10:23:54 <DMcGill> going beyond the realm of point-free into point-less
10:24:14 <ski> DMcGill : why wouldn't `f .: Compose .: fmap . setIx' work ?
10:24:45 <DMcGill> it would absolutely but I feel that it's too hard to read/unintuitive in what it does.
10:24:51 <ReinH> chrisdone: semigroups is the one I use
10:24:58 <ski> the first `.:' passes two arguments on to the remainder. the `.:' there passes those two on again. and the `.' passes the first of them on to `setIx', leaving the second as a separate argument to `fmap'
10:26:10 <DMcGill> whereas a single lambda is as many characters as much clearer. I know what it does now but for 1) other people and 2) me in a week it's much harder to grok than a lambda. I feel that the cost in grokability/benefit in fewer keys/names is too high for the expression with double .:
10:26:32 <DMcGill> if you can understand where I'm coming from
10:26:44 <ski> jfischoff : `CoYoneda' can be used when you can't `fmap', e.g. `CoYoneda IORef' .. so you delay mapping until such time you can extract the internal contents
10:26:51 <ReinH> elliott: is there an algebraic structure with just an associative binary operator and a zero element distinct from a semigroup?
10:27:02 <jfischoff> ski: thanks
10:27:44 <elliott> ReinH: associative binary operator + zero element = monoid...
10:27:48 <elliott> semigroup = monoid without identity
10:28:06 <ReinH> elliott: zero element is not an id element
10:28:07 <haasn> “Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.” I chuckled
10:28:12 <ReinH> that's what I meant to say the first time
10:28:16 <ReinH> semigroup + zero does not form a monoid
10:28:24 <ReinH> a + zero /= a
10:28:34 <chrisdone> elliott: i'm gonna post this just to freak the guy out lol
10:28:45 <ReinH> I actually do know the difference between a semigroup and a monoid :p
10:29:26 <ski> ReinH : not directly what you asked for, but <http://en.wikipedia.org/wiki/Quasigroup>,<http://en.wikipedia.org/wiki/Moufang_loop>,<http://en.wikipedia.org/wiki/Bol_loop> might be interesting cases of where associativity (in the general sense) needn't hold
10:29:48 <DMcGill> ReinH: what properties does your zero have? That a + zero = zero?
10:29:54 <ReinH> that zero annihilates, yes
10:30:14 <ReinH> DMcGill: think a semi-ring's zero
10:30:15 <elliott> ReinH: oh, right. sure.
10:30:27 <chrisdone> what's your thing with annihilation? =p
10:30:31 <ski> jfischoff : iow, `CoYoneda IORef' is `ReadIORef', a view of an `IORef' that you can only read from. one could have `CoYonedaOp IORef' (good name ?) that would be `WriteIORef', a view of an `IORef' that you can just write to
10:30:31 <chrisdone> Rein in Terror?
10:30:32 <ReinH> chrisdone: :p
10:30:33 <elliott> ReinH: you were the first person to talk about zeroes, though.
10:30:43 <ReinH> elliott: because that's what chrisdone was asking for :p
10:30:46 <shachaf> ski: What's CoYonedaOp?
10:30:58 <elliott> ReinH: some people consider monoids as (+,0) rather than (*,1) because they're weirdos.
10:31:05 <jfischoff> interesting
10:31:07 <DMcGill> ski: I've changed my mind again, you were right after all w.r.t. (.:)
10:31:07 <ski> jfischoff : you can also use any other datastructure instead of `IORef', that can similarly only be interpreted in some context (in this case, an `IO' context)
10:31:17 <jfischoff> right
10:31:18 <ReinH> elliott: sure, I'm using "zero" as in the annihilative element of a semi-group
10:31:20 <ReinH> which is called zero
10:31:28 <elliott> sure.
10:31:34 <ReinH> can see how that might confuse here
10:31:41 <ReinH> but thought I did a decent job of defining my terms :p
10:31:48 <ReinH> *semi-ring
10:31:50 <ReinH> I need more coffee
10:32:18 <ReinH> elliott: my point is that the structure you described above is a semigroup + annihilative zero, which strangely doesn't seem to have a name
10:32:18 <chrisdone> i like that ghc can handle a haskell module indented at n spaces
10:32:25 <elliott> ReinH: even Haskell uses (+,0) for monoids -- mzero / mplus
10:32:32 <elliott> right.
10:32:40 <DMcGill> ReinH: are these proposed structures interesting at all though?
10:32:41 <ReinH> yes but I don't have another word :(
10:32:46 <chrisdone> for monadplus you mean?
10:32:47 <DMcGill> they sound a little trivial
10:32:49 <ReinH> DMcGill: well, they can be used to solve at least one problem
10:32:56 <chrisdone> (but yeah, it's the same)
10:32:57 <ski> shachaf : if `data CoYoneda f b = forall a. FmapIncl (a -> b) (f a)' (with `incl :: f a -> CoYoneda f a'), then `data CoYonedaOp f b = forall a. FmapInclOp (b -> a) (f a)'
10:32:58 <ReinH> DMcGill: monoids are trivial but useful
10:33:43 <ski> shachaf,jfischoff : so `CoYoneda f' is always a (covariant) functor, regardless of what `f' is; and `CoYonedaOp f' is always a contravariant functor, regardless of what `f' is
10:33:55 <DMcGill> ReinH: hmm. Are you sure you don't have a semiring (a second operation) or a monoid (an identity element)?
10:33:58 <ski> shachaf,jfischoff : btw, note that `Yoneda f' is also always a (covariant) functor, regardless of what `f' is
10:34:09 <nisstyre> DMcGill: monoids are important for describing a lot of things in math and CS
10:34:18 <nisstyre> they may be in general trivial to define yeah
10:34:18 <ReinH> DMcGill: you don't need either, no
10:34:40 <nisstyre> oh and linguistics has monoids too
10:34:48 <jfischoff> ski, shachaf: I had mixed up Coyenda and Yoneda :s
10:34:59 <DMcGill> nisstyre: I never said otherwise, I was talking about this proposed structure which has even less structure than a monoid
10:35:05 <ReinH> DMcGill: I built up from monoid first but then it was rightly pointed out that id is not necessary
10:35:11 <nisstyre> DMcGill: oh ok
10:35:20 <ski> jfischoff,shachaf : in some sense, `CoYoneda f' can be thought of as the "least" functor that includes `f', while `Yoneda f' can be thought of as the "greatest" functor that is included in `f'
10:35:50 <nisstyre> DMcGill: ReinH's response there confused me
10:35:51 <ReinH> DMcGill: semigroups have less structure too but are still quite useful as a number of useful binary operations form semigroups over common sets but not monoids
10:36:03 <DMcGill> ski: when looking at my code did you happen to see anything else that could be abstracted? It's just not as elegant as I would like :/
10:36:07 <ReinH> DMcGill: min, max over Z for instance
10:36:23 <ReinH> nisstyre: I confused myself as well :( can I clear something up?
10:36:25 <nisstyre> there is a semigroup class somewhere on hackage IIRC
10:36:29 <ReinH> I'm having a shitty time of communicating all around
10:36:30 <DMcGill> semigroups come up in the monoidal pearl which is nice :)
10:36:38 <ReinH> nisstyre: semigroups, yes.
10:36:38 <DMcGill> nisstyre: it's called Option
10:36:53 <DMcGill> Option a => Monoid (Maybe a) is a nicer definition
10:37:11 <DMcGill> because it doesn't throw away the zero element for the a, unlike the Monoid a => Monoid (Maybe a) defn
10:37:29 <ReinH> DMcGill: Option is Maybe with saner monoid behavior
10:37:45 <ReinH> any semigroup can be made a monoid by introducing an arbitrary element that serves as id
10:37:45 <DMcGill> ooh, I was getting confused between Semigroup and Option
10:37:46 <DMcGill> oops
10:38:00 <ReinH> so Semigroup a => Maybe a is a monoid
10:38:08 <ReinH> but Maybe has weird monoid semantics so Option is designed to fix that
10:38:41 <ski> jfischoff : btw, note that with `newtype Yoneda f a = PamfJorpPilf {FlipProjFmap :: forall b. (a -> b) -> f b}' (with `proj :: Yoneda f a -> f a'), a value of type `Yoneda f a' is a delayed `fmap' that will happen when we apply `proj', so what you said wasn't that wrong
10:38:49 <kuznero> Hi All!
10:39:05 <stevely> howdy
10:39:07 <Cale> hello!
10:39:26 <ReinH> DMcGill: I love roconnor's article on tropical semirings for introducing this construction of monoids http://r6.ca/blog/20110808T035622Z.html
10:39:27 <jfischoff> ski: yeah I'm looking at the source of kan-extensions and I see that
10:39:38 <elliott> ski: PamfJorpPilf...
10:40:06 <elliott> ReinH: to be fair, the Maybe
10:40:10 <elliott> monoid semantics are reasonable.
10:40:14 <elliott> they just need the constraint weakening.
10:40:47 <ReinH> elliott: and you can also newtype wrap Maybe to provide your own mappend, which is what roconnor does
10:41:12 <ReinH> elliott: that's totally more correct than what I said :)
10:41:28 <ski> jfischoff,shachaf : exercise : write conversions from `f a' to `Yoneda f a' (under which condition) and from `CoYoneda f a' to `f a' -- then write conversions `CoYoneda (CoYoneda f) a -> CoYoneda a' and `Yoneda f a -> Yoneda (Yoneda f) a', and conclude that `CoYoneda' is a kind of "monad at higher types", while `Yoneda" is a kind of "comonad at higher types"
10:41:37 <ReinH> (and, for that matter, what Option does)
10:41:54 <ski> elliott : i would prefer if i could avoid having to name the constructor there at all, only naming the record selector ..
10:42:51 <elliott> ski: with lens, you can!
10:43:05 <elliott> ski: actually, you can't.
10:43:07 <ski> shachaf,jfischoff : you'll also need instances of `tmap :: (forall a. f a -> g a) -> (forall a. t f a -> t g a)' for `t' being `CoYoneda' respectively `Yoneda'
10:43:09 <chrisdone> lol
10:43:11 <elliott> since it's a polymorphic field.
10:43:15 <elliott> oh well.
10:43:37 <ski> elliott : real record types would be nice :)
10:43:39 <chrisdone> i think @faq should be changed to "The answer is: Yes! Haskell can do that. Make sure to import Control.Lens"
10:44:01 <ocharles> haha
10:49:31 <applicative> oh ReinH did you see the icfp paper http://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf
10:50:44 <ReinH> applicative: no but that looks a lot like roconnor's work :)
10:50:48 <foobarbaz> Hi guys; How do i get the type of `let a = 5`  in GHCI?
10:51:00 <foobarbaz> I'm hoping it's M Int, maybe
10:51:02 <chrisdone> :t let a = 5 in a
10:51:02 <lambdabot> Num a => a
10:51:07 <foobarbaz> fail =[
10:51:13 <chrisdone> or > let a = 5
10:51:13 <chrisdone> :t a
10:51:14 <lambdabot> Expr
10:51:19 <ReinH> applicative: yep, seems to cover a lot of the same ground but I love multiple presentations for learning things
10:51:25 <ReinH> thanks :D
10:51:27 <applicative> it sort of goes to town with a corresponding abstraction, adding closure :: r -> r to the semiring
10:51:54 <foobarbaz> hm, does the type of let change under 'do' chrisdone?
10:52:18 <ParahSailin> is it possible to link an arbitrary .o file with ghc without --make'ing?
10:52:28 <foobarbaz> learn you haskell says you can write 'main = do a <- return "hell"' like 'main = do let a = "hell"'
10:53:17 <chrisdone> the "let" in a do isn't an expression, do statements should end in a final expression
10:53:37 <chrisdone> so do let a = "hell" isn't valid syntax
10:53:39 <applicative>     The last statement in a 'do' block must be an expression
10:53:51 <foobarbaz> ah true
10:54:01 <foobarbaz> hence the putStrLn a
10:54:08 <chrisdone> sure
10:54:18 <ReinH> applicative: is that different from start-semirings?
10:54:22 <ReinH> *star
10:54:59 <quchen> foobarbaz: "let" in "do" is special, it's part of do notation. You can read `do let <definitions>; <morestuff>` as `let <definitions> in do <morestuff>`.
10:55:02 <applicative> ReinH: that is one of the things he puts under his (closed) semiring class
10:55:30 <quchen> foobarbaz: Or maybe stated more clearly: in "do" notation the "in" for "let" is automatically added.
10:55:45 <chrisdone> do a <- return "hell"; return a  and do let a = "hello"; return a are equivalent, but not in general. let bindings can be self-referential, do bindings can't (by default)
10:56:23 <chrisdone> it's more like a lambda
10:56:25 <applicative> the regular languages form a <times> is concatenation ; <plus> is union and closure is Kleene's star, as he says
10:56:44 <applicative> the regular languages form a closed semiring where <times> is concatenation ; <plus> is union and closure is Kleene's star, as he says
10:56:53 <chrisdone> do a <- return "hell"; …   is desugard more like   return "hell" >>= \a -> …
10:57:30 <ski> @hoogle (i -> e -> f) -> Array i e -> Array i f
10:57:30 <lambdabot> Data.Array accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
10:57:30 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
10:57:38 <ski> @hoogle (IArray a e,Ix i) => (i -> e -> f) -> (a i e -> a i f)
10:57:38 <lambdabot> Data.Map.Lazy mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
10:57:38 <lambdabot> Data.Map.Strict mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
10:57:38 <lambdabot> Data.Map.Lazy filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a
10:58:59 <foobarbaz> thanks, i didn't quite get the last bit, but i'm not done with the chapter yet
10:59:05 <foobarbaz> So hopefully i'll be able to understand that soon :)
11:00:39 <quchen> foobarbaz: You don't need to understand what *exactly* do notation does in the IO chapter there. A decent gut feeling is enough at that point.
11:08:37 <mstksg> dmj`: hey, dmj`, i remember you telling me earlier to let me know if i got favicons to work with scotty
11:08:50 <mstksg> dmj`: they seem to work fine for me without any extra work than normal favicon support
11:13:11 <Eduard_Munteanu> Is there a standard-ish extension for runhaskell scripts?
11:13:22 <Eduard_Munteanu> Filename extension, I mean.
11:13:34 <ion> eduard_munteanu: ""
11:13:44 <Eduard_Munteanu> Hm, makes sense, thanks.
11:16:12 <Eduard_Munteanu> Meh, I can just write a makefile to ghc --make them.
11:18:31 <monochrom> you can use any filename you want. just have the right #! line
11:18:56 <monochrom> and the right chmod. I just tried.
11:20:33 <ocharles> mm_freak: playing with integralWith more... the MonadState/MonadReader we're using isn't the same monad as the underlying wire
11:20:56 <ocharles> which means you can't easily share 'Reader World' with the correction of integralWith
11:21:04 <ocharles> i wonder if that's something that we would like to have
11:21:18 <ocharles> at the moment I have to use a 'ask' wire, and then thread that into integralWith
11:21:53 <chrisdone> for my runhaskell scripts i use .hs but lowercase filename
11:22:14 <iamarto> I found a pure functional programming language better than Haskel. It's called Pure-lang. No need to explain.. self explanatory :) (just kidding)
11:22:40 <chrisdone> pretty sure Pure isn't pure
11:22:53 <monochrom> I usually use lowercase filenames for everything that allows lowercase filenames :)
11:23:04 <iamarto> chrisdone, how do you know? You checked it?
11:23:33 * lispy thinks he should start using StUdLy cApS for filenames
11:23:34 <chrisdone> iamarto: no i just read the basic literature about it
11:23:49 <iamarto> I see
11:24:04 <chrisdone> having seen it a couple years ago
11:24:26 <iamarto> chrisdone, any language without a community is pointless :)
11:24:48 <chirpsalot> iamarto: define community :P
11:25:19 <iamarto> chirpsalot, I was talking about Pure.. seems like there is not much work done on Pure.. that's how I define community, by the work produced.
11:25:21 <lispy> > let community = community in community
11:25:28 <lambdabot>   mueval-core: Time limit exceeded
11:25:28 <monochrom> I have designed a very, very pure language. it is so pure, its programs give you nothing observable apart from turning electricity into heat. and even that is only when you turn on debugging mode. :)
11:25:54 <chrisdone> monochrom: does that mean i can do hotswapping? =p
11:26:04 <monochrom> haha
11:26:08 <chirpsalot> iamarto: so if there is one person just pumping out the applications it can be a community? :)
11:26:31 <iamarto> chirpsalot, what do you mean?
11:26:57 <chrisdone> you can't commune without cohorts
11:26:58 <chirpsalot> If only one person uses a programming language but produces an absurd amount of work would it be a community?
11:27:10 <ReinH> TIL edwardk is a community
11:27:19 <iamarto> chirpsalot, of course not.
11:27:26 <chrisdone> and oleg
11:27:28 <monochrom> hahaha
11:27:46 <iamarto> chirpsalot, But if you do good work, people will follow you. If you did bad work.. no one will
11:28:00 * monochrom follows oleg
11:28:04 * chrisdone considers php
11:28:08 <chrisdone> define 'good work'
11:28:13 <ReinH> people follow bad work all the time...
11:28:14 * ReinH coughs and it sounds like Windows Vista
11:28:19 <monochrom> I know that one!
11:28:31 <iamarto> chrisdone should consider C. Best language in the world if you know how to write with it.
11:28:37 <chrisdone> the good thing about bashing php is that it deserves it
11:28:42 <monochrom> "good work" = work that attracts people to follow. "fittest" = survives.
11:28:48 <chrisdone> bashing most other languages aren't that deserving, it seems to me
11:29:00 <ReinH> monochrom: right, work that attracts people will attract people.
11:29:01 <monochrom> thus, survival of the fittest, and good work is followed :)
11:29:04 <FreeFull> chrisdone: Why write PHP when you can write Haskell that writes PHP
11:29:06 <iamarto> chrisdone, good work = work appreciated by many.
11:29:16 <chrisdone> that's popular work =p
11:29:25 <chrisdone> like britney spears
11:29:27 <monochrom> ReinH: have you seen my http://www.vex.net/~trebla/humour/tautologies.html :)
11:29:33 <ReinH> Debate protip: any argument can be successfully won by defining words to form a tautology
11:29:41 <ReinH> monochrom: yes
11:29:45 <monochrom> \∩/
11:29:54 <chrisdone> \∩_∩/
11:29:54 <chirpsalot> iamarto: why would you say C is the best language in the world?
11:30:21 <chrisdone> i don't think c deserves a lot of bashing, tbh
11:30:28 <chrisdone> i think it deserves the popularity it has
11:30:30 <chirpsalot> I mean, I am a proficient C programmer and I love it, but the language has a few warts.
11:30:39 <monochrom> comparing community sizes is a popularity contest :)
11:30:55 <iamarto> chirpsalot, I am just laughing.. I don't think it's the best language, I just think it's the toughest (due to pointers etc.) but it's also the most commonly used for Real Time processing programs (etc. Nasa)
11:31:12 <monochrom> that may be a good one for #7 :)
11:31:16 <chrisdone> it has warts but the notion of objects being vectors of bytes and pointers are pretty nice
11:32:22 <chrisdone> php is just a hack, admitted by a self-described hack, with nothing well-designed that wasn't already in perl
11:33:13 <ReinH> PHP is just a set of sufficiently advanced C preprocessor directives...
11:33:22 <chirpsalot> iamarto: yeah :). I'll agree. I mean I wouldn't say any language is the "best" language. C is most well suited to a lot of areas, and that probably isn't going to change for a long time.
11:33:36 <chrisdone> ReinH: i wish -- then it would have some measure of performance
11:33:54 <ReinH> chrisdone: sufficiently advanced to not be constrained by you meager understanding of "performance"
11:33:59 <ReinH> or "works"
11:33:59 <iamarto> chirpsalot, you have to also agree that when a program is made in C, we automatically think it will be *fast* and it is..
11:34:01 <chrisdone> had to work with drupal a couple times
11:34:17 <chrisdone> that software is not badly designed, but php makes it a house built on sand
11:34:32 <ReinH> iamarto: C is not automatically fast. I can show you an enormous number of counterexamples
11:34:45 <chrisdone> not automatically, but generally
11:34:55 <chrisdone> correct? well, generally probably not =p
11:34:57 <ReinH> It's about as fast as the programmer makes it.
11:35:07 <iamarto> ReinH Haskell faster than C? You mean in runtime or typing?
11:35:08 <geekosaur> C is like that saying about coffee letting you make more errors faster
11:35:11 <chrisdone> sure -- but naive c is often faster than naive anything else
11:35:17 <ReinH> iamarto: did I say that?
11:35:21 <chrisdone> geekosaur: indeed =)
11:35:31 <iamarto> ReinH, :) give examples
11:35:34 <chirpsalot> iamarto: what ReinH said, and also the "speed" boost C gives isn't always necessary, plus you are more likely to run into nasty bugs in a language like that I feel.
11:35:51 <ReinH> iamarto: a 40 year history of shitty C programs?
11:35:52 <chrisdone> it's more of a certainty, i think
11:35:59 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
11:36:08 <chrisdone> c programming is like sifting for gold in a river of segfaults
11:36:09 <ReinH> I appeal to Sturgeon's Law ;)
11:36:14 <iamarto> chirpsalot, I agree. C is the opposite of what Haskell is trying to do.. more freedom in coding to generate a virus than a functional program..
11:36:25 <chirpsalot> chrisdone: haha :).
11:37:08 <ReinH> given infinite time I can write an infinite number of non-performant C programs.
11:37:17 <chirpsalot> I'm still more proficient with C than Haskell. I need to fix that :(.
11:37:34 <chrisdone> ReinH: i expect you can write more non-performant haskell ones in less time
11:37:43 <Dodek> C programmer is also more likely to use a dumber data structure instead of smarter data structure
11:37:50 <ReinH> chrisdone: well I was going to generate them with Haskell...
11:37:59 <Dodek> because they are pain to use in C
11:38:02 <chrisdone> it kind of bugs me that the haskell community is so defensive about performance concerns
11:38:04 <Dodek> it's no longer the case with C++, though
11:38:15 <prophile> they're ALL a pain to use with C++
11:38:16 <ReinH> chrisdone: I'm not sure why? Haskell is plenty performant.
11:38:32 <chrisdone> a guy makes a legitimate observation that his naive python code is faster than the one he did in haskell
11:38:36 <chirpsalot> ReinH: was it always, though?
11:38:40 <bennofs> C++ is not that bad. The error messages suck, through.
11:38:40 <ReinH> But any time someone makes a statement like "X is always Y", there's an assumption to be challenged.
11:38:44 <chrisdone> then people tell him, you shouldn't be doing this, doing that, using those, etc. etc.
11:38:46 <shachaf> ski: Oh, CoYoneda being a monad and Yoneda being a comonad is neat.
11:39:17 <chrisdone> which are all valid helpful points -- but ignore the underlying problem which is the defaults are inefficient. the first function you see to read a file is readFile, it uses String and lazy IO
11:39:28 <iamarto> I would like to know what's the use of a programming language without a GUI interface in 2013???? I would tend to think that most applications in our modern day needs a GUI.
11:39:33 <Dtgr> performance of haskell strings, anyone? :)
11:39:47 <chirpsalot> chrisdone: oh! I ran into that. I had a python and haskell program for the same thing and the Python one ended up being faster (for a few reasons). It was neat because it was a little unexpected, but it made sense in the long run.
11:39:58 <bennofs> iamarto: what's the use of php?
11:40:07 <chrisdone> chirpsalot: right
11:40:19 <iamarto> bennofs, nice question... web programming.
11:40:34 <chrisdone> chirpsalot: it's not that (ghc/ajhc) haskell can't be fast it's more that you have to work for it and you have to know the lore
11:40:47 <chirpsalot> chrisdone: I think Python can run surprisingly fast sometimes, but I guess a lot of the stuff behind the scenes are essentially speedy C libraries?
11:41:06 <chrisdone> indeed, most of those times of newbies presenting comparisons i've the python uses some C code underneath
11:41:46 <ReinH> iamarto: looks like you just answered your own question
11:41:50 <chrisdone> python itself, as bos has noted a bunch of times in presentations, you can't really squeeze speed out of. you *have to* drop to c. there's still some lore about what constructs not to use, tho
11:42:11 <chirpsalot> chrisdone: I was actually using a tree instead of a hash table in the Haskell version because it was easier to write - but obviously it was slower. The Python dictionaries are pretty fast, though.
11:42:19 <iamarto> ReinH, so Haskell is mainly useful for web programming?
11:42:33 <ReinH> iamarto: no, Haskell is mainly useful for the large set of programming tasks that aren't web programming
11:42:39 <ReinH> er that aren't GUI programming
11:42:44 <Clint> and also web programming
11:42:52 <prophile> i've done fast python by generating bytecode and constructing functions from that before
11:42:55 <chirpsalot> Aren't there Haskell web frameworks?
11:42:58 <prophile> you don't necessarily have to drop down to C
11:42:59 <iamarto> ReinH, yeah in list processing you mean etc..
11:43:14 <ReinH> iamarto: Do you really think that the only programming tasks are GUI, web, and list processing?!
11:43:25 <Clint> chirpsalot: there are several
11:43:41 <bennofs> You can write IRC bots in haskell
11:43:41 <iamarto> Personally I am trying to learn Haskell for fun.. to be able to think in different ways than I have learned other imperative languages...
11:43:51 <chirpsalot> Clint: but you said it's not useful for it?
11:43:51 <chrisdone> chirpsalot: i quite enjoy being given programs in X language and shown the same program in haskell and being asked how to make the other faster. it takes up my time, but i can't resist tackling it =p
11:43:53 <arkeet> and there less "frameworks" and more "collections of tools that work nicely together"
11:43:56 <arkeet> they're
11:44:12 <arkeet> and you can mix and match :p
11:44:21 <ReinH> chrisdone: now I know how to get you to solve my haskell performance problems
11:44:29 <ReinH> port to another langauge and then ask you to make it in haskell
11:44:33 <chrisdone> iamarto: i'd say haskell is best suited to sharing code and making large systems
11:44:44 <chrisdone> ReinH: lol =)
11:44:47 <Clint> chirpsalot: i said the opposite of that
11:45:02 <chirpsalot> Clint: oh, I see. I got confused :).
11:45:02 <iamarto> chrisdone, large systems for which industry (for example)?
11:45:12 <ReinH> iamarto: financial is the most obvious
11:45:35 <chrisdone> iamarto: what you're sharing or making in particular isn't that a big deal, but at scale the purity and type system really help keep everything in line when you're sharing, re-using or building upon it
11:45:42 <chirpsalot> Clint: I want to learn a bit of web-dev... I would like to try to do that with Haskell, but would that be a bad place to start?
11:45:50 <chrisdone> iamarto: sure!
11:45:57 <ReinH> iamarto: you could also look at http://www.haskell.org/haskellwiki/Haskell_in_industry
11:46:04 <Clint> chirpsalot: do you already know haskell?
11:46:15 <prophile> there was some interesting stuff about large haskell systems in the last haskellcast
11:46:27 <ReinH> prophile: :)
11:46:30 <chrisdone> prophile: yeah it was good =)
11:46:43 <ReinH> Don was awesome :)
11:46:47 <chrisdone> ReinH: i ended up listening to it all in the end
11:46:52 <ReinH> cool
11:47:02 <chirpsalot> Clint: "know" is kind of relative. Can I write programs in it... Yes.
11:47:09 <chrisdone> ReinH: chris is quiet isn't he?
11:47:19 <luite> hm
11:47:23 <chirpsalot> But I am not super familiar with all of the idioms and ins and outs yet, if you know what I mean.
11:47:23 <Clint> chirpsalot: then go for it
11:47:45 <chrisdone> chirpsalot: real horroshow, if you know what i mean
11:47:57 <iamarto> Cool
11:47:58 <chirpsalot> chrisdone: hmmmm?
11:48:05 <ReinH> chrisdone: yeah probably because I talk too much :)
11:48:07 <chrisdone> chirpsalot: n/m, a clockwork orange reference =p
11:48:14 <Dodek> iamarto: https://github.com/meiersi/HaskellerZ/blob/master/meetups/20130829-FPAfternoon_The_Haxl_Project_at_Facebook/The%20Haxl%20Project%20at%20Facebook.pdf
11:48:20 <ReinH> chrisdone: I just get so excited...
11:49:31 <iamarto> haskell comes after scala in google trends ranking: http://www.google.com/trends/explore?q=clojure+langauge#q=scala,%20clojure,%20F#,%20haskell&cmpt=q
11:49:47 <chirpsalot> iamarto: is that surprising?
11:50:00 <chrisdone> ReinH: lol
11:50:09 <chrisdone> iamarto: hahaha
11:50:31 <chrisdone> scala is stairs/scale/ladder in italian
11:50:35 <chrisdone> all the scala results are from italy
11:51:33 <chirpsalot> iamarto: F# seems to be surprisingly unrelated to programming languages :P.
11:51:43 <iamarto> chirpsalot, just information :) I'm not even sure of Google Trends reliablity after the Prism thing...
11:51:58 <chrisdone> f# in google gives me only results about the programming language
11:52:01 <chrisdone> google knows me too well
11:52:05 <ReinH> iamarto: not useful information
11:52:24 <ReinH> that's like comparing "ruby" and "python"
11:52:27 <chrisdone> (actually, it seems unrelated to my account)
11:52:29 <ReinH> turns out those words have other uses too
11:52:33 <iamarto> chirpsalot, yeah.. well I believe Microsoft is starting to fail.. Windows Mobiles are sucking day after day as Nokia also falls.. iPhones same.. Androids rising.
11:53:38 <iamarto> ReinH, would you say the same if Haskell was pioneering on Google Trends :P hehe
11:53:40 <chirpsalot> iamarto: I don't think iPhones are in any danger. Maybe Windows phones / Nokia phones.
11:54:23 <chrisdone> windows/nokia dropped the ball, too late for them
11:54:26 <ReinH> iamarto: yes.
11:55:41 <iamarto> chirpsalot, not anytime soon.. but the death of Steve Jobs.. anyway.
11:56:07 <elliott> perhaps take this to #haskell-blah?
11:56:38 <acomar> hey all, for anyone who's interested in OpenCV -- I've been hard at work on a new set of OpenCV bindings that directly wrap the C++ API. The bindings are far from finished, but I would love some input on the direction they're heading.
11:56:39 <iamarto> elliott, I was just waiting for you to write some haskell code in chat.
11:56:47 <ReinH> elliott: oh there's another haskell channel I'm not in. Huh.
11:56:48 <acomar> they're available at www.github.com/arjuncomar/revelation
11:56:58 <chrisdone> acomar: will they work with the microsoft Kinect?
11:57:13 <acomar> chrisdone: I don't own a Kinect, so I can't promise that easily :/
11:57:16 <elliott> ReinH: it isn't a haskell channel :)
11:57:36 <chrisdone> acomar: i've got one, just curious. i have my haskell freenect library for talking to it, but opencv would be spiffy
11:57:37 <acomar> chrisdone: that said, if opencv provides them, I can at the very least expose the functions in Haskell
11:57:43 <ReinH> elliott: http://tvtropes.org/pmwiki/pmwiki.php/Main/SuspiciouslySpecificDenial
11:57:51 <chrisdone> elliott: don't click it
11:57:52 <acomar> I just can't do any testing myself
11:58:05 <ReinH> it's harmless
11:58:08 <ReinH> aside from the nerd sniping
11:58:20 <saml> you nerd?
11:58:20 <acomar> so pull requests, suggestions, feature requests, etc. are all very very welcome
11:58:21 <chrisdone> i think what's where mmorrow went
11:58:28 <chrisdone> he opened a tvtropes link and every came back
11:58:40 <ReinH> (saying this as someone who has literally had a browser OOM crash from too many tvtropes tabs)
11:58:51 <chrisdone> acomar: you also announce this to the cafe and reddit?
11:59:03 <haasn> tvtropes is a devilish trap designed to destroy any and all productivity
11:59:08 <acomar> chrisdone: not yet, wanted to do a bit of writing first
11:59:22 <acomar> chrisdone: after I write up two blog posts I have planned on this, I'll do that
11:59:40 <chrisdone> ReinH: i once linked tvtropes to someone at the office and said "careful… it's addictive" he laughed in derisive disbelief. i looked back 5 minutes later and he had five tabs open
11:59:40 <acomar> although, I guess one of them is covered by the README
12:00:35 <chrisdone> acomar: cool. just saying because not everyone's online right this second of course, so your announcement in here will hit only 10% or whatever of people who might be interested =)
12:00:44 <acomar> chrisdone: of course
12:01:07 <Eduard_Munteanu> I was thinking about declaring datatypes, parsers and related types all at once. I think there's a name for this, but I don't remember.
12:01:18 <ski> shachaf : yeah :)
12:01:25 <Eduard_Munteanu> Not that specific, but a more general theory.
12:02:02 <Eduard_Munteanu> Something involving the word "attributes"? Bah, TotT.
12:03:31 <chrisdone> Eduard_Munteanu: like attribute grammar?
12:03:50 <Eduard_Munteanu> chrisdone: that rings a bell, it's something close to that
12:03:58 <chrisdone> http://en.wikipedia.org/wiki/Attribute_grammar ?
12:04:14 <ReinH> acomar: so FFI bindings, any good resources on how to write them?
12:05:05 <Eduard_Munteanu> chrisdone: it was a paradigm related to / parallel to aspect-oriented programming
12:05:49 <chrisdone> ahh
12:06:22 <ski> <http://www.haskell.org/haskellwiki/Attribute_grammar>,<http://www.haskell.org/happy/doc/html/sec-AttributeGrammar.html>,<http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter>
12:06:24 <Eduard_Munteanu> Perhaps https://en.wikipedia.org/wiki/Attribute-oriented_programming
12:06:26 <ski> <http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem>;"Atribute Grammars in Haskell with UUAG" by Andres Löh in 2005-02-10 at <http://www.andres-loeh.de/AGee.pdf>
12:06:48 <Eduard_Munteanu> ski: hm, I think it was attribute grammers after all.
12:07:15 <acomar> ReinH: depends, did you have a specific type of library in mind?
12:07:18 <Eduard_Munteanu> I'll start there.
12:07:59 <acomar> ReinH: bindings-dsl provides a relatively painfree way to automatically interface with functions, types, and macros in C
12:08:18 <acomar> it's documentation is a little light, but the tutorial covers most of what you need anyway
12:08:47 <acomar> And ezyang has a few blog posts up on the subject
12:09:02 <ReinH> acomar: was thinking about libtcod perhaps
12:09:08 <acomar> I pretty much used that and what's up on the haskell wiki to figure it out
12:09:10 <ReinH> although there's an older binding available
12:10:42 <acomar> ReinH: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
12:12:29 <ReinH> acomar: oh cool
12:12:47 <ReinH> <3 ezyang
12:13:36 <acomar> yea, he's one of those people in that small group of haskell programmers who I frequently find has already done whatever it was I'd planned on doing :)
12:13:58 <ReinH> acomar: if it isn't him, edwardk, or Conal just don't bother ;)
12:14:06 <acomar> haha, pretty much
12:20:02 <ski> "Attribute Grammars as a Functional Programming Paradigm" by Thomas Johnsson in 1987 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8549>
12:21:09 <ski> "Purely Functional Implementation of Attribute Grammars" (thesis) by João Alexandre Baptista Vieira Saraiva in 1999-12-09 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.2497>
12:22:13 <ReinH> ski: how are you formatting those citations?
12:22:20 <ski> manually
12:22:28 * ReinH impressed
12:28:35 <carter> anyone have opinions on command line parsing libs?
12:28:52 <carter> theres optparse, commandargs
12:28:52 <carter> and a few others
12:29:42 <Clint> i have opinions about optparse-applicative and cmdargs
12:30:04 <ParahSailin> yeah use optparse-applicative
12:32:46 <carter> is that the current favorit wrt usability?
12:32:57 <carter> i know nothing
12:33:18 <carter> Clint: whats your opinions?
12:33:22 <carter> wrt "which to use"
12:33:43 <carter> prototyping some stuff for a client in haskell before i *gasp* figure out how to write something in node
12:35:34 <bgamari> optparse-applicative is awesome
12:35:38 <ReinH> looks nice
12:35:58 <bgamari> it's my first choice
12:36:23 <ReinH> carter: I did a thing recently with getopts and lens but this looks nicer (https://gist.github.com/reinh/7880188e1b251bb51e6e)
12:37:58 <lightquake> @type either (const Nothing) Just
12:37:58 <lambdabot> Either a a1 -> Maybe a1
12:38:06 <lightquake> is there a nicer way to write that?
12:39:22 <ski> "The FNC-2 Attribute Grammar System" by Martin Jourdan,Didier Parigot at <http://web.archive.org/web/20071009212022/http://www-rocq.inria.fr/oscar/www/fnc2/index.html>
12:39:48 <ski> "A Tutorial Introduction to Attribute Grammars" by Martin Jourdan,Didier Parigot at <http://web.archive.org/web/20070630103723/http://www-rocq.inria.fr/oscar/www/fnc2/manual/node32.html>
12:42:06 <schell> ReinH: weren't you just talking about applicative options parsing a couple days ago?
12:42:11 <schell> ah - i see now
12:42:20 <schell> i have a habit of writing before reading
12:48:47 <prophile> so Cofree f is a monad when f is Alternative, but there's nothing analogous for CofreeT - is that by necessity or is it just missing?
12:57:40 <k00mi> "Couldn't match type `0 + 1' with `1'" :/
12:57:52 <k00mi> am I missing something or is GHC (7.6) not capable of that?
12:58:05 <int-e> k00mi: the latter.
12:58:11 <k00mi> eh
12:58:23 <carter> bgamari: ReinH  thanks!
12:58:26 <pqmodn> k00mi: type literals?
12:58:26 <ReinH> k00mi: what did you actually do?
12:58:36 <int-e> (7.8 will be able to do it.)
12:58:38 <k00mi> yes
12:58:45 <k00mi> good
12:58:46 <ReinH> ah
12:58:49 <fizruk> prophile: what's the meaning of Cofree f as a monad when f is an Alternative instance?
12:58:53 <pqmodn> k00mi: i think that's a recent feature and that specific problem is a documented bug. not sure if it's been fixed though
12:59:09 <k00mi> pqmodn: according to int-e it has :-)
12:59:14 <pqmodn> k00mi: yay! :)
12:59:43 <carter> ReinH: so you also are on the opt-arse-applicatives
12:59:45 <carter> *parse not arse
13:01:43 <prophile> fizruk: in what sense?
13:02:18 <fizruk> prophile: I think I meant an example
13:04:13 <ReinH> carter: freudian?
13:04:21 <ReinH> carter: I haven't used yet but it seems like the right thing
13:04:27 <ReinH> (applicative)
13:04:38 <prophile> fizruk: well, one can define an alternative on futures/promises and get FRP-style reactives from cofree future
13:05:00 <ReinH> prophile: what does cofree future look like?
13:06:52 <prophile> ReinH: purple, reflective and vaguely Reactive a = (a, Future (Reactive a)) shaped
13:07:20 <prophile> it's actually basically the same as how conal elliott does futures in the push pull frp paper
13:07:58 <ReinH> prophile: ah
13:08:17 <ReinH> prophile: that one is on my list, probably should be bumped up
13:08:19 <ReinH> my reading list is not a priority queue :(
13:12:19 <ski> int-e : would `1 + 0' match with `1', though ?
13:13:55 <acomar> chrisdone: ok, posted to reddit and the cafe :)
13:15:09 <int-e> ski: yes, current head does that (I used this line to test it: let t :: ((1 + 0) ~ 1) => Bool; t = True in t)
13:15:55 <int-e> and my "current" version is 5 days old.
13:17:06 <Clint> carter: optparse-applicative unless you have special needs
13:19:51 <bearclaw> I'm stuck again, to goof around I wanted to implement Monad on Set. But Set needs ord, so it complains on definition of >>= with "No instance for Ord(b)". Is there a way around this?
13:20:08 <acomar> bearclaw: look up indexed monads
13:20:14 <bearclaw> I get the idea, for Set to be Monad, Set x has to comply for all x
13:20:56 <bearclaw> but relaxing this constraint does not compromise safety I guess, it could be a compile-time error to try to use it with the wrong x
13:20:57 <FreeFull> bearclaw: Set isn't a normal Monad but I think it is an indexed monad
13:21:19 <acomar> http://blog.omega-prime.co.uk/?p=127
13:21:24 <acomar> scroll down to indexed constraints
13:22:11 <bearclaw> I'll look it up thanks
13:22:39 <bearclaw> hehe, "We can use this to solve the well-known problem where lists can be an instance of the Monad type class, but sets cannot"
13:23:05 <bearclaw> I was well aware that I was reinventing the wheel, but I did not expect such a straight answer :)
13:23:23 <acomar> if you add these classes/instances, hide bind and return from the Prelude, and use RebindableSyntax, you can even recover do notation :)
13:24:03 <acomar> bearclaw: one of my favorite things about the haskell community is that whenever I've thought of something, someone has already written a lengthy post on the subject :)
13:25:18 <ski> int-e : but it doesn't match `0 + 1' with `1' yet, correct ?
13:25:43 <FreeFull> acomar: I'm waiting for websockets to reach its io-streams goodness point
13:26:24 <acomar> FreeFull - is that in reference to something?
13:26:43 <int-e> ski: as I understand the question, yes it does, that's what happens with ((1 + 0) ~ 1).
13:27:13 <FreeFull> acomar: There is exactly one library for writing a websocket client in haskell, and its stable version doesn't do Hybi13 ):
13:27:19 <FreeFull> The experimental branch does though
13:27:27 <FreeFull> At least, I think it does
13:27:58 <acomar> my point is more that someone has written about the problem, not that a good solution exists :)
13:28:17 <FreeFull> jaspervdj: Would you say I could use the io-streams branch of websockets to write something and it won't break too badly as websockets gets updated? Also, how's the hybi13 support in the branch?
13:28:19 <bennofs> How can I handle collisions in netwire? If I have a Wire "a" for the position of one object, and another Wire "b" for another object, how can I do collision detection? I somehow need to interchange information between different wires, no?
13:28:55 <FreeFull> bennofs: I'd look at how it was done in that asteroids clone
13:29:07 <ocharles> "that asteroids clone" pfft, show some respect!
13:29:17 <FreeFull> ocharles: Your asteroids clone =P
13:29:21 <ocharles> :)
13:29:23 <FreeFull> http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
13:29:44 <ocharles> bennofs: there are a few different ways you can do it
13:29:50 <ocharles> bennofs: what type of thing are you building?
13:30:15 <bennofs> ocharles: nothing yet, just playing around with netwire :P
13:30:16 <ocharles> In asteroids a collision leads to an event - so I step everything in isolation, and then check what collisions would now occur and respond
13:30:27 <ocharles> I'm now making a mario platformer, and this one is a bit different
13:30:43 <NemesisD> guys why are hackage password stored as unsalted md5s? was this on purpose? :(
13:30:48 <ocharles> There is a function called 'integralWith' that can integrate velocity -> position with a correction function
13:31:01 <FreeFull> With a platformer you probably want to check if a collision would occur before you actually do the movement
13:31:26 <ocharles> bennofs: so in mario I have a velocity wire and a position wire. I step the velocity wire, and feed that into the position wire
13:31:45 <ocharles> The position wire also outputs any collisions that had to be corrected
13:31:55 <ocharles> that information gets fed back into velocity as "corrections" the next instant
13:32:20 <ocharles> so I optimistically apply velocity to mario, and then correct it. if I did have to do some correction, then his velocity in one or both axis needs to be zeroed
13:32:32 <bennofs> ocharles: How does the position wire know the position of other objects? Or do you have a position wire that calculates the new position for all objects at once?
13:33:02 <ocharles> bennofs: so far - it doesn't. i haven't got that far :) but I would probably step all objects and then resolve them externally and dispatch events
13:33:15 <ocharles> right now i'm making sure mario can walk around a tile based world
13:33:46 <ocharles> bennofs: http://lpaste.net/1639922507655938048 is where it stands atm
13:34:33 <FreeFull> ocharles: If you do it optimistically, what will stop your mario from getting stuck or going through objects?
13:35:03 <ocharles> FreeFull: the position wire should only ever output position that has been resolved for collisions
13:35:15 <ocharles> position takes velocity in, integrates it, and then applies a correction
13:35:32 <FreeFull> I see
13:35:43 <ocharles> so mario shouldn't be able to get stuck in anything unless that correction is buggy. right now he falls through the floor, so it's probably buggy
13:35:46 <ocharles> :)
13:36:07 <FreeFull> ocharles: You could flip the velocity when Mario reaches the bottom of the screen
13:36:10 <FreeFull> So he bounces =P
13:36:36 <ocharles> FreeFull: nah, it's just something in my collision detection. it works fine if he only falls vertically - moving to the right and falling breaks it somehow
13:36:40 <ocharles> but this bit is a wip :)
13:37:13 <joelteon> ocharles: I know the pain of trying to implement physics, heh
13:37:37 <ocharles> it's been quite fun so far. got to doodle on graph paper, which always makes you feel professional
13:37:41 <joelteon> yeah, agreed
13:37:48 <joelteon> mine is a top-down 2D kind of thing
13:37:52 <joelteon> which means a lot of conversion to polar
13:38:15 <ocharles> are you working on a game?
13:38:23 <joelteon> it'll become a game eventually
13:38:28 <joelteon> at the moment it's just a "physics engine"
13:38:35 <ocharles> fantastic :)
13:38:37 <ocharles> in haskell?
13:38:38 <joelteon> and I'm doing all the updating manually
13:38:40 <joelteon> maybe I should try netwire
13:38:43 <joelteon> yes in haskell
13:38:47 <ocharles> awesome
13:38:56 <ocharles> i'm in love with netwire
13:39:00 <joelteon> well i'll try it
13:39:09 <jaspervdj> FreeFull: yeah it should work well
13:39:12 <ocharles> it has an insane learning curve due to being both a new library and a new paradigm
13:39:18 <ocharles> but it's so fun when you start to "get it"
13:39:26 <jaspervdj> FreeFull: I think its better than the master branch in fact
13:39:32 <ocharles> in asteroids - towards the end I felt so comfy with it, I added ufo's in an hour or so
13:40:00 <ocharles> mario is proving a bit more of a challenge in the collision area, but that's new work for me. i feel like i'm mostly having to think about the interesting problems
13:40:06 <FreeFull> jaspervdj: So just pull and cabal install?
13:40:15 <jaspervdj> yep
13:40:23 <FreeFull> Thanks
13:40:25 <jaspervdj> and let me know if you run into trouble :-)
13:40:37 <FreeFull> Your library is the only choice for this
13:45:31 <Eduard_Munteanu> Is there no way to make kind synonyms in GHC 7.6? :(
13:45:32 <enthropy> acomar: re. the opencv bindings... I'm not sure that you really have the problems of lazy IO, if your image processing functions are  (Image -> Image), then have some final  (writeImage :: Image -> IO ())
13:45:45 <donri> ocharles: so frp, how do you feel about it now, worth it?
13:46:03 <acomar> enthropy: the problem is getting functions that look like Image -> Image
13:46:06 <ocharles> donri: definitely
13:46:08 <donri> Eduard_Munteanu: are type synonyms not promoted?
13:46:24 <acomar> aleator has been struggling with that in his CV library
13:46:33 <donri> Eduard_Munteanu: i do think i've seen things like type Kind = Any
13:46:34 <enthropy> acomar: how do you mean? The HOpenCV takes that approach
13:46:49 <ocharles> donri: and I love arrowized frp. however, I do find arrows can be a pita sometimes. having to work with (foo, bar, baz) rather than foo -> bar -> baz feels awkward in Haskell
13:47:01 <Eduard_Munteanu> donri: hm, let me try some more, type Size = Nat  and trying to index a data by Size failed.
13:47:15 <ocharles> but usually splitting things apart eases the pain there and gives you nicer code
13:47:21 <acomar> enthropy: the C++ API isn't always very clear about where and how it copies a matrix versus does manipulation on the matrix
13:47:46 <acomar> enthropy: So you get a situation where you think you've got a series of referentially transparent functions
13:48:04 <acomar> and but the end result depends on the exact sequencing
13:48:15 <enthropy> it should still be referentially transparent
13:48:56 <acomar> enthropy: https://github.com/aleator/CV/issues/22
13:49:09 <lamefun> what a world.... even Lua(!) doesn't come with a GPG signature...
13:49:11 <enthropy> it is confusing that     let { imgA = ..; imgB = ..  }; writeImage imgA; writeImage imgB -- can depend on the order that you writeImage
13:49:50 <acomar> enthropy: I'll ask aleator for a specific example when he's on tonight
13:50:12 <acomar> enthropy: as it stands though, it's very hard to verify what is and isn't safe to unsafePerformIO
13:50:12 <chrisdone> ocharles: what about arrow syntax?
13:50:29 <donri> chrisdone: don't think that's the problem here
13:50:39 <donri> chrisdone: still need proc (a,b,c) -> ... etc
13:50:40 <acomar> enthropy: I'm happy to be wrong on that point though, it would certainly make a lot of things easier
13:50:49 <enthropy> http://lpaste.net/92671 is one example
13:50:55 <chrisdone> oh. i've never looked at arrow syntax (never needed it)
13:51:16 <ski> int-e : ok
13:51:38 <enthropy> it's not entirely clear that it's wrong to do in-place changes for a function  (Image -> Image)
13:51:39 <donri> isn't it funny how we have arrow syntax that no one uses but no idiom brackets that everyone wants
13:51:57 <enthropy> they want what they can't have
13:52:03 <enthropy> or is too much trouble to get
13:52:09 <ocharles> chrisdone: arrow syntax has the same problem
13:52:17 <ocharles> then <- itsJust -< (foo, bar, baz, cram, in, parameters)
13:52:21 <acomar> enthropy: the problem is that the new API will claim it's giving you back a new matrix when it's really just a shallow copy with pointers back to the original data
13:52:24 <ocharles> and the types are equally horrible
13:52:30 <acomar> so manipulating the new matrix changes the old matrix as well
13:52:44 <ocharles> but if it wasn't for arrow syntax, I doubt netwire would be usable for me
13:52:44 <enthropy> acomar: yes, but you don't get to see that it changed without doing any IO
13:52:48 <ocharles> 'rec' binding is just way too convenient
13:53:16 <acomar> enthropy: yea, if you copy the data into Haskell and do your manipulations on the Haskell side
13:53:17 <donri> yeah some arrows without arrow syntax get real weird and ugly quickly
13:53:29 <int-e> but arrows quickly become unusable without arrow syntax; applicatives not so much :)
13:53:34 <donri> once you start having to deal with first/second manually...
13:53:43 <donri> yeah
13:54:16 <int-e> and a couple of variations on shuffling pairs, like  pure (\((a,b),c) -> (a,(b,c)))
13:54:25 <acomar> enthropy: I need to take the dog on a walk, shoot me an email or post an issue about it, and I'll work it out when I get back
13:54:34 <ocharles> oh yea, netwire rocks for Wire being an instance of so much stuff
13:54:34 <chrisdone> i suppose idom brackets can easily be achieved with th?
13:54:35 <acomar> enthropy: back in about an hour
13:54:42 <enthropy> acomar: ok
13:54:50 <ocharles> if some of the haskell numeric classes weren't so stupid, it would be easier nicer
13:54:53 <donri> at least the arrow operators are nice
13:54:56 <donri> >>>>>>>>>>
13:55:01 <importantshock> chrisdone: you can use the Strathclyde Haskell Enhancement for idiom brackets
13:55:07 <donri> it's like conflict markers
13:55:12 <chrisdone> the what cylde?
13:55:13 <ocharles> isn't someone writing a ghc plugin for idiom brackets?
13:55:20 <ocharles> chrisdone: scottish university
13:55:27 <importantshock> chrisdone: conor mcbride's preprocessor https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/
13:55:33 <enthropy> ocharles: there are plugins for ghc's parser?
13:55:34 <donri> "she" doesn't really handle ghc extensions though does it
13:55:42 <enthropy> @hackage applicative-quoters
13:55:43 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
13:55:45 <ocharles> enthropy: i thought that was kinda the point of ghc plugins?
13:55:57 <chrisdone> ghc plugins just transform core
13:56:02 <donri> ocharles: yes, someone said they were gonna work on idiom brackets in ghc
13:56:07 <importantshock> neat!
13:56:07 <chrisdone> they're kinda useless =)
13:56:30 <donri> yeah ghc plugins can't mess with syntax at all; you get the type checked code in the abstract
13:56:39 <donri> AIUI
13:56:41 <ocharles> oh
13:56:55 <chrisdone> yeah exactly, qq's make a decent idiom bracket [i| … |] is decent
13:57:19 <ocharles> bah, juicy pixels doesn't like my bitmap. apparently a black and white bitmap has (255,255,0) at one pixel
13:57:27 <donri> chrisdone: except it's using HSE plus hacks
13:57:58 <enthropy> maybe the solution is to make ghc use HSE
13:58:00 <ocharles> yay, png works
13:58:23 <joelteon> ocharles, you're using juicypixels for graphics?
13:58:24 <enthropy> nevermind that HSE is kind of lagging behind
13:58:25 <importantshock> apparently SHE can help with the fix/unfix µ-trick for infinite types
13:58:31 <importantshock> which intrigues me
13:58:46 <ocharles> joelteon: no, i just drew a level in gimp and wanted to load it :)
13:58:50 <chrisdone> donri: big deal?
13:58:51 <joelteon> oh
13:58:54 <ocharles> an 'level' being an Array (Point V2 Int) Bool
13:59:37 <donri> chrisdone: somewhat. no fixities for starters. haskell-packages might make that possible eventually though.
13:59:42 <Athan> gtk sucks - anyone else agree?
13:59:56 <elliott> Athan: off-topic.
14:00:14 <Athan> correction: gtk2hs sucks - anyone else agree?
14:00:30 <elliott> inflammatory and contentless.
14:00:42 <copumpkin> that's the way I like my IRC
14:00:55 <geekosaur> gtk2hs does inherit a lot of stupid from gtk, actually
14:01:09 <Athan> edit: is there any way to get more error reporting other than ExitFailure 1?
14:01:11 <inkjetunito> Athan: gtk is quite awful to use in general
14:01:16 <glguy> copumpkin: Policed or contentless?
14:01:21 <haasn> copumpkin: Now we just need to figure out what the ‘R’ stands for
14:01:34 <gseitz> nkpart: awesome presentation on FRP
14:01:36 <Athan> I really want to just make my app's UI a website haha
14:01:38 <copumpkin> glguy: all of the above, and inflammatory
14:01:45 <geekosaur> various other interfaces to gtk also have very annoying behavior caused more or less by the fact that they have to do horrible things to interface to gtk to begin with
14:01:50 <copumpkin> I want post-apocalyptic IRC
14:02:32 <Athan> yep, I'm going for a web-based UI then haha
14:02:46 <Athan> I've been struggling on getting gtk2hs installed, so screw it
14:03:03 <justinleitgeb> Does anyone know if there is a way to reload the cabal package within cabal repl?
14:04:15 <chrisdone> copumpkin: /j #haskell-postapocalypse
14:04:35 <copumpkin> chrisdone: all alone :(
14:04:44 <chrisdone> that's accurate, right? =p
14:04:45 <copumpkin> just the way post-apocalyptic wastelands should be
14:04:46 <copumpkin> yeah
14:04:46 <geekosaur> there you gp, then
14:04:50 <geekosaur> *go
14:04:55 <quchen> Got a question about Async behaviour. Every time an Async started using `withAsync` is killed using `cancel`, a ThreadKilled exception is thrown to that thread. This exception should propagate all the way up out of the `withAsync`, am I right?
14:05:18 <quchen> Because I feel like I have a lack of exceptions of that sort, and I'm wondering where the fault is.
14:05:19 <chrisdone> i suppose in the true spirit there'd also be #haskell-postapocalypse-punk-themed-gang
14:06:13 <copumpkin> lol
14:06:44 <chrisdone> they'd raid our channel every so often and steal all our existential types =p
14:07:20 <copumpkin> noooo
14:07:32 <copumpkin> http://nooooooooooooooo.com/
14:07:39 <bennofs> The context function from netwire is cool! :P
14:08:19 <chrisdone> what's it do?
14:08:54 <bennofs> Switch between multiple wires based on a predicate :)
14:09:16 * lispy is really skeptical about frp libs after trying a few
14:09:18 <chrisdone> what's a wire?
14:09:20 <lispy> what makes netwire different?
14:09:30 <chrisdone> something like an event stream?
14:10:28 <lispy> I had reasonable performance with Yampa (arrows) but I wasn't fond of the hurdles/hoops that I have to go through to be properly declarative and whatnot.
14:11:05 <lispy> I declare that I can't think of a game in a declarative way!
14:11:28 <ocharles> chrisdone: a time indexed function, i think would be the tl;dr
14:12:11 <ocharles> chrisdone: in netwire 4, Wire :: e m a b Time -> a -> (m (Either e b), Wire e m a b)
14:12:14 <ocharles> iirc
14:12:38 <chrisdone> what are the variables?
14:12:47 <ocharles> a b ~ a -> b - so that's just a function
14:12:59 <ocharles> m is a base monad, e is the inhibition value, which is a bit like partiality
14:13:00 <lispy> What I really disliked was: I almost always had to define things in terms of other things (in a cyclic way) and use the delayed arrows. One small mistake in that cycle and you get an infinite loop :(
14:13:27 <ocharles> lispy: yes, there's nothing in the types to help there. i'd like to research that. i'm hoping bentnib's talk on Guarded Recursion reaches the youtubes
14:13:39 <ocharles> because i'm hoping clock variables might provide me some help
14:25:52 <joelteon> I kinda like netwire so far
14:25:56 <joelteon> ocharles: what are you using for drawing?
14:26:00 <joelteon> er uh, graphics
14:27:48 <foobarbaz> Hi guys, is `when` from 'do c <- getChar when( ...)'
14:27:55 <foobarbaz> a function or a language feature
14:28:02 <roconnor> @src when
14:28:02 <lambdabot> when p s = if p then s else return ()
14:28:16 <foobarbaz> thanks
14:45:04 <acomar> enthropy: back. I got an email from Anthony Cowley with an explanation about how HOpenCV guarantees referential transparency
14:45:23 <acomar> apparently there's an implicit deep copy before every operation
14:45:47 <acomar> but RULES are used to rewrite away the extra duplications
14:45:59 <acomar> so only one is necessary for any sequence of functions Image->Image
14:46:02 <acomar> it's quite interesting
14:52:41 <enthropy> yes that's a much better approach than some enumerator thing
14:53:36 <acomar> I'm not sure going via pipes or conduits is such a bad idea, it does provide a nice way to actually write algorithms, at least at the high level
14:54:20 <acomar> it's useless for image processing, but very natural for video processing
14:54:30 <Thulsadum> how do i compile a haskell module as a library without cabal?
14:55:11 <monochrom> is "ghc -c MyModule.hs" enough for you?
14:55:36 <monochrom> it gives you MyModule.o
14:55:54 <monochrom> and MyModule.hi, which you will also need
14:56:30 <Thulsadum> mh, yeah, that seems to be to simple :D
14:56:38 <Thulsadum> *too
14:58:39 <monochrom> if you want to get a libMyLib.a, you will need to read the GHC User's Guide section 4.9.7, which begins with "you should use cabal". but after that it will tell you what is needed manually
14:58:42 <Thulsadum> ok, cabal archives them together, thus just like static library creation in C, i guess
15:00:52 <lightquake> if i have a cabal project sym that has both a library with some exposed modules and an executable, how do I avoid duplicating the build-depends between the library and the executable?
15:01:27 <acomar> lightquake - pass the library as an argument in the build-depends section
15:01:44 <lightquake> acomar: i'm doing that, it's not working
15:01:57 <acomar> you're using the name of your project?
15:01:59 <Peaker> lightquake: the executable depends on the library, so that removes the need to depend on the stuff you *indirectly* need. You still need to explicitly list your direct dependencies, which may differ or be similar, but are not the same
15:02:30 <Peaker> lightquake: if both your library and your executable modules are importing some package's module, then both depend on the package, since your library isn't re-exporting that module
15:02:37 <lightquake> right
15:02:46 <lightquake> here's what I have: REPL.hs, which is part of the executable target, imports Parser.RPN
15:03:01 <lightquake> Parser.RPN is exposed by the sym library
15:03:28 <lightquake> it depends on parsec, among other things; when I try to do cabal build repl, it says that the package parsec-3.1.3 is hidden
15:03:31 <acowley> I'm going to define all my Ord instances backwards from now on so I can use getDown
15:04:01 <acomar> lightquake: add parsec as an explicit dependency of your library then
15:04:06 <lightquake> it is already
15:04:13 <lightquake> the library builds fine
15:04:13 <acomar> that's odd o.O
15:04:21 <acomar> right, add it in the executable section
15:04:53 <acomar> acowley! I was just replying to your email. I'm pretty intrigued by the approach you outlined
15:05:12 <acowley> acomar: Oh, good!
15:05:25 <acowley> I was really happy to see someone else looking to put some work into this area
15:05:51 <acomar> yea, I'd been waiting for about two years for someone else to get around to doing this work >.>
15:06:09 <acomar> a lot of the functionality I need is hidden away in the C++ only parts of the API
15:06:15 <acowley> Yes, it's somewhat hopeless without automatic bindings generation
15:06:18 * ski looks at <http://hackage.haskell.org/package/comonad-transformers-3.1/docs/Control-Comonad-Trans-Store.html>
15:06:27 <Eduard_Munteanu> ski: I *think* you can make zippers and everything else provide a generic store comonad  class ComonadStore s w where toStore :: s -> a -> w s a; fromStore :: w s a -> (s, a); mapFocus :: (s -> s) -> w s a -> w s a; mapValue :: (a -> b) -> w s a -> w s b   which you can use to get a   instance (ComonadStore s w) => Comonad (w s)
15:06:28 <acowley> and yes, the transition to C++ really stinks for our needs
15:06:57 <acomar> yea, so I'm hoping to get them to incorporate either these C wrappers or the generators
15:06:58 <acowley> acomar: What always happens is someone needs some part of OpenCV, so they wrap that part then run out of steam immediately afterwards
15:07:02 <Eduard_Munteanu> ski: but for certain instances of ComonadStore you'll be able to provide different implementations, I think.
15:07:43 <acomar> acowley: I'm a bit too lazy to do it that way :) why do by hand what you can have the computer do for you
15:08:06 <acowley> acomar: You've got the right attitude
15:08:35 <ski> Eduard_Munteanu : hm, in `Apply sa s', it seems one could view `s' as an index, alternatively `sa' as an index
15:08:44 <acomar> acowley: so the truth is, there are a few important modules that aren't correctly parsed by the header parser that they use to generate their python bindings
15:08:53 <fizruk> is it possible to write C function that can be exported with non-IO monadic type? e.g. String -> State Int ()
15:09:01 <acomar> so they've manually wrapped things like Mat, Point, Size
15:09:02 <lightquake> acomar: ok, I got it to sort-of work by moving some files, around, but now I get this: http://pastebin.ca/2459282
15:09:04 <acowley> acomar: is your plan to fix that parser or write a new one?
15:09:10 <acowley> Ah, well Mat is fairly complicated
15:09:17 <ski> Eduard_Munteanu : in `Apply (ar !) i', `i' is the index into the array, while in `Apply fst (5,2)', `fst' is the index into the tuple .. hmm
15:09:28 <acomar> acowley: it's a bit too complicated to wrap automatically without an actual C++ parser :/
15:09:31 <Eduard_Munteanu> ski: hm...
15:09:45 <acomar> so I'm slowly wrapping those parts manually
15:10:13 <ski> Eduard_Munteanu : `mapValue' is `fmap', yes ?
15:10:19 <Eduard_Munteanu> ski: yeah
15:10:33 <acomar> lightquake: it looks like your library is missing a module? I get those errors when I forget to add a module to the list of exposed modules or other modules
15:10:52 <acomar> possibly Parser.hs, or something like it?
15:10:53 <lightquake> acomar: ah, yeah that's it
15:10:58 <acowley> acomar: When I was working most heavily on it, the transition to C++ wasn't as far along and the C API still had all the pieces I wanted
15:11:14 <ski> Eduard_Munteanu : `toStore s a' produces a store where every cell holds `a', and the current cell index is `s' ?
15:11:14 <acowley> acomar: Wrapping all the Mat stuff doesn't seem like it buys us a lot
15:11:32 <acomar> acowley: yea, they've started to drop the C api entirely
15:11:49 <argiopeweb> acomar: I'm also glad to see someone working on this. I've used a restricted subset of the C++ bindings that I've built over a few years to do firm realtime video processing (in a non-allocating loop), so I'll be interested to see how appropriate your new bindings are for similar tasks.
15:11:50 <acowley> acomar: Hm, so we need Mat. But do we need all of its templated magic?
15:12:02 <ski> Eduard_Munteanu : also, `(s,a) = fromStore wa' means `a' is `extract wa' (element at current index), while `s' is current index ?
15:12:04 <Eduard_Munteanu> ski: actually I don't think so: s -> a promises to be total in 's' but it could be partial in 'a'. It won't really work except on Hask^op I suppose
15:12:08 <acomar> acowely: There's just enough templated magic that we can't wrap it automatically
15:12:24 <acomar> acowley: but check out what I've done with it in Bindings/Mat.hsc and Mat.hs
15:12:26 <Eduard_Munteanu> ski: yeah
15:12:49 <acomar> acowley: I'm working around the templated parts while maintaining type safety on the haskell side
15:12:49 <Eduard_Munteanu> (or when s is isomorphic to a)
15:12:57 <acomar> it should be an improvement over the pure C++ api
15:13:04 <acomar> since the C++ mats are dynamic
15:13:14 <ski> fizruk : "is it possible to write C function that can be exported with non-IO monadic type? e.g. String -> State Int ()" -- yes, but not with `State Int ()' in the result (though that could be a wraper)
15:13:31 <acowley> acomar: This does look great
15:13:36 <acowley> acomar: Something else I forgot to mention
15:13:47 <acowley> acomar: I added type safety for color depth and number of color channels
15:13:55 <ski> Eduard_Munteanu : "actually I don't think so" -- disagreeing with what ?
15:14:02 <acomar> argiopeweb: that's basically what I need it for too :)
15:14:03 <acowley> acomar: I thought that was a nice thing to have on the Haskell side to prevent you from, say, passing a color image to canny
15:14:03 <monochrom> also, not with "String". :)
15:14:22 <Eduard_Munteanu> ski: I'm not sure you can view 'a' as an index and 's' as a value.
15:14:24 <acomar> acowely: I was working on it and talking about in here, and enthropy pointed me at your work on the same thing
15:14:27 <fizruk> ski: yes, wrapper is ok. there's one more issue though: I want to use `get` inside of that C code, how do I do that?
15:14:40 <acowley> acomar: But the way Mat can be different things to different people seems to muddy the waters, which is why I like just thinking about it for images
15:14:53 <acowley> acomar: Yes, enthropy fixed a bug a couple weeks ago
15:14:55 <monochrom> anyway, C function int f(int) <-> Haskell function f :: CInt -> Cint is allowed
15:15:01 <augur> today i've learned that redditors who claim to know what tail recursion is, dont
15:15:07 <ski> Eduard_Munteanu : well, the `store fst (1,5)' example at <http://hackage.haskell.org/package/comonad-transformers-3.1/docs/Control-Comonad-Trans-Store.html> suggested that to me -- i'm not sure whether it works out fine or not
15:15:19 <acomar> acowley: yea, Aleator (author of CV) was saying the same thing
15:15:24 <Eduard_Munteanu> ski: or did you mean (s -> a) is an index and s is the store?
15:15:31 <acowley> augur: Learning something about the average redditor's knowledge of tail recursion is its own reward
15:15:34 <Eduard_Munteanu> Actually that makes sense.
15:15:44 <monochrom> augur: is it part of the fallout of today's xkcd? :)
15:15:58 <Eduard_Munteanu> Ah.
15:16:02 <ski> fizruk : the wrapped would probably have type like `CString -> Int -> Int' or something
15:16:03 <augur> acowley: :)
15:16:04 <augur> monochrom: yes
15:16:27 * monochrom has his opinion on what is the gain in using Haskell, or generally the gain in using a restrictive language
15:16:29 <argiopeweb> acomar: Well then, thanks for taking the time to do it properly. Last time I messed with it I was rather focussed on graduating and I haven't gotten back to it.
15:16:35 <ski> (or possibly `CInt' instead of `Int')
15:16:49 <acomar> argiopeweb: hah, you're assuming it's being done properly
15:16:53 <sellout-> augur: I’m almost tempted to check reddit to see for myself, but I think I have enough restraint to resist.
15:17:05 <augur> sellout-: yeah i should learn to do that
15:17:22 <acowley> acomar: One downside to adding type safety is it involves reading the documentation to discover requirements. This is hard-to-impossible to generate automatically.
15:17:29 <augur> they think tail recursion and self-reference are the same thing
15:17:32 <monochrom> also, C function HsInt g(HsInt) <-> Haskell function f :: Int -> Int  is also cool
15:17:33 <augur> ok i should get going
15:17:38 <acowley> acomar: So we would need an escape hatch type for functions nobody's firmed up
15:17:39 <argiopeweb> acomar: It's a good bit better than what I did, which was essentially to manually write restricted bindings, use them in their lowest-level form, and not release anything into the wild.
15:17:47 <fizruk> ski: you mean State Int turns into (Int -> (Int, ()), which turns into Int -> Int ?
15:18:03 <ski> fizruk : the wrapper would do that (in the other direction), yes
15:18:17 <monochrom> err, s/f ::/g ::/
15:18:26 <ski> Eduard_Munteanu : yes
15:18:35 <acomar> acowley: I think my approach actually handles that ok since you can give those functions a forall declaration and wrap it in a type synonym or newtype to "lose" the type information
15:18:57 <fizruk> ski: thanks, I'll try to implement that!
15:19:00 <ski> Eduard_Munteanu : i suspect that these two different views will get you different implementations of `mapFocus :: (s -> s) -> w s a -> w s a'
15:19:28 <ski> fizruk : note that an `Int' in Haskell won't be an `int' in C (if you need `int', first convert to `CInt' in Haskell)
15:19:33 <acowley> acomar: Yeah, just leaving them as type variables is sufficient
15:19:45 <fizruk> ski: thanks, I'm aware of that
15:19:52 <acomar> acowley: I mean for those functions that truly need a dynamically typed matrix
15:20:04 <ski> fizruk : as monochrom said it
15:20:08 <acomar> I think there are a couple, but I haven't been that deep in the documentation in a while
15:20:23 <argiopeweb> acomar: Incidentally, while I can't promise that I can throw any development time at helping, I'd be happy to run some tests on ARM if you'd like. I seem to recall it was a sticking point with some of the other Haskell -> CV bindings (which is why I was hand-rolling bindings).
15:21:15 <monochrom> in fact, under one practical circumstance, C int has 32 bits, Haskell Int has 64 bits
15:21:21 <acomar> argiopeweb: awesome, I haven't really tried running anything but the standard javacv stuff on android
15:21:31 <ski> Eduard_Munteanu : if `s' in the index and `s -> a' is the function that looks up the index in some current hidden store, then clearly `mapFocus' will only touch the `s' part, changing the index/focus but not the store
15:21:49 <monochrom> but HsInt is carefully crafted to have 64 bits under that circumstance
15:22:19 <ski> Eduard_Munteanu : if `s' is the store and `s -> a' is the function that looks up the current index/focus in the store provided to it, then `mapFocus' will want to change the `s -> a' (though note the "backward" thing here)
15:22:43 * monochrom is tempted to joke: "this is why I still use 32-bit linux, so that int and HsInt are still 32 bits and interchangeable" :)
15:22:53 <acomar> acowley: your image operation rewriting -- is there any module in particular I could look at in HOpenCV for some detail on how it's implement it?
15:23:17 * ski is tempted to make a "Let's ..." joke
15:23:33 <acowley> acomar: the bottom of https://github.com/acowley/HOpenCV/blob/master/src/OpenCV/Core/CVOp.hs
15:23:47 <monochrom> let's go back to 8088 :)
15:23:49 <ski> Eduard_Munteanu : makes any sense ?
15:23:56 <acomar> acowley: awesome, thanks
15:24:10 <monochrom> wait, it would have a 64K stack :)
15:24:42 <Eduard_Munteanu> ski: yeah, I was trying to write it down explicitly.
15:24:47 <monochrom> if 8MB stack gives people so many stack overflows, imagine 64KB stack :)
15:24:50 * ski much prefers 680x0 to 8088 or similar
15:25:00 <fizruk> ski: hmm... so get_c should have type like Int -> (Int, Int) and I would be forced to use explicit parameter passing?
15:25:10 <monochrom> but I'm trying to make your life harder!
15:25:48 <ski> fizruk : it's not clear what you're doing ..
15:27:30 <chrisdone> Let's make a ball pool with lambdas instead of balls
15:27:38 <Eduard_Munteanu> ski: mapFocus (g :: s -> s) (Apply (f :: a -> s) (a :: a)) = mapFocus (g . f :: a -> s) a   seems reasonable
15:27:49 <fizruk> ski: m... actually State does not reveal my original problem... I'll try another example
15:27:52 <monochrom> hmm lambda pool
15:27:54 <Eduard_Munteanu> Err, the last mapFocus should be Apply.
15:29:32 <ski> Eduard_Munteanu : `f :: a -> s' ?
15:29:40 <ski> shouldn't that be `f :: s -> a' ?
15:30:00 <ski> (how will you code `extract' otherwise ?)
15:30:04 <ReinH> AH HA!
15:30:13 <Eduard_Munteanu> Er, right, I got mixed up trying to reverse conventions.
15:30:17 <ReinH> chrisdone: semigroup + zero = null semigroup http://en.wikipedia.org/wiki/Null_semigroup
15:30:25 <ReinH> elliott: ^
15:30:32 <ReinH> I knew there had to be a term for it
15:30:54 <ReinH> wait, no
15:30:55 <ReinH> crap
15:31:22 <ReinH> we don't want ab=0
15:31:22 <hrefchef> I cannot get any package to install via cabal except my own. The error messages are variable. Would running ghc version 7.6.2 and cabal 0.14.0 cause these problems?
15:31:36 <hrefchef> I may move to Fedora, because it has 7.4.x and haskell-platform.
15:32:45 <ReinH> holy crap there are a lot of special classes of semigroups http://en.wikipedia.org/wiki/Special_classes_of_semigroups
15:34:22 <monochrom> no, hrefchef, that is not a cause.
15:35:08 <Eduard_Munteanu> ski: the original one is  mapFocus (g :: s -> s) (Apply f s) = Apply (f . g) s   and the other one would be   mapFocus (g :: s -> s) (Apply f s) = Apply f (g s)
15:35:29 <Eduard_Munteanu> Or the other way around, my brain is exploding. :)
15:35:58 <Eduard_Munteanu> Yes, since mapFocus changes the focus.
15:36:16 <ski> yeah, those were the two implementations i had in mind of `mapFocus'
15:36:58 <ski> the latter corresponds to `s' being the index. the former corresponds to `f' being the index (and then `g' translates the index "backwards")
15:38:20 <Eduard_Munteanu> The form of that makes me wonder if there's a connection to Yoneda's lemma.
15:38:42 <ski> hm, why ?
15:39:01 <ReinH> Eduard_Munteanu: ReinH's Lemma: There's always a conection to Yoneda's Lemma.
15:39:17 <monochrom> haha
15:39:24 <Eduard_Munteanu> Heh.
15:39:31 <monochrom> @remember ReinH ReinH's Lemma: There's always a conection to Yoneda's Lemma.
15:39:32 <lambdabot> I will never forget.
15:39:46 <ReinH> monochrom: can you fix my typo please
15:39:52 <ReinH> :p
15:39:52 <monochrom> oh!
15:40:00 <monochrom> @forget ReinH ReinH's Lemma: There's always a conection to Yoneda's Lemma.
15:40:00 <lambdabot> Done.
15:40:10 <monochrom> @remember ReinH ReinH's Lemma: There's always a connection to Yoneda's Lemma.
15:40:11 <lambdabot> Okay.
15:40:23 <fizruk> ski: consider this code: http://lpaste.net/93519
15:40:48 <Eduard_Munteanu> ski: it looked like one of them "floats" out a Hom(X, -), but it isn't clear to me.
15:40:49 <ReinH> monochrom: high five
15:41:02 <fizruk> ski: I want to write C function of type, say, `DSL ()` and use `output` and `input` commands in it
15:41:56 <fizruk> ski: the problem as I see it is in nested commands
15:41:59 <ski> Eduard_Munteanu : well, `Cxt s' is `(,s) . (s ->)', while `State s' is `(s ->) . (,s)' ..
15:42:29 <ski> Eduard_Munteanu : and `(,s) --| (s ->)' -- and we all know that if we compose an adjunction one way, we get a monad, and the other way, we get a comonad
15:43:04 <ski> (`Cxt'/`Store' is sometimes called "state-in-context", perhaps highlighting this connection to `State')
15:43:06 <acomar> acowley: so this looks really nice for image processing operations. I think I've got the gist of it.
15:43:27 <ski> fizruk : btw, i just read your "nested commands" as "nested comonads" ..
15:43:43 <fizruk> ski: that's normal :)
15:43:48 <acowley> acomar: I'm sorry the code is so ridiculous. I started with the old HOpenCV bindings and kept hacking away at it over the years without stepping back for a redesign.
15:44:06 <ski> (well, as i was talking about comonads with Eduard_Munteanu ..)
15:44:13 <shachaf> I,I class Functor w => Comonad w where comonad :: w a -> Cofree w a
15:44:13 <acowley> acomar: It would be really nice if we could use your new substrate as the foundation
15:44:46 <ski> fizruk : btw, `(Return x)   >>= f' can be written as simply `Return x   >>= f' (no need for brackets there)
15:44:50 <acomar> acowley: I mean, I think everyone feels that way about any project they've been working on for years :) it doesn't look that bad to me, I just don't always know what I'm looking at
15:45:10 <acomar> acowley: yea, I'll separate out the raw bindings tonight or tomorrow and put them up on hackage
15:45:15 <acomar> opencv-raw or something
15:45:55 <acowley> acomar: Ha, that's true, but this really is in an awful state. I spent a long time thinking I'd try to merge back upstream. Only a year or two ago did I give up on that and make more drastic changes, but I never properly rationalized things.
15:46:05 <ski> fizruk : hm, so your C function should call Haskell `input' and `output' ?
15:46:55 <ReinH> Fun fact: Neither zero semigroups nor null semigroups nor nil semigroups are the semigroup I want
15:47:03 <fizruk> ski: I want C code to (lazily) return DSL structure which could be in turn interpreted with whatever interpreter I prefer
15:48:05 <ReinH> naming things is so hard
15:48:35 <acomar> acowley: I don't really see that much point in totally re-inventing the wheel here
15:48:38 <fizruk> ski: I can, of course, export output as (runDSL . output) and input as (runDSL input)
15:48:58 <acomar> acowley: my c++ bindings are a nice base, we could see about doing this correctly
15:49:22 <acowley> acomar: Some wheels should be retired to make way for new, better wheels :)
15:49:35 <fizruk> ski: but that means peaking interpreter a priori and puts some restrictions on it
15:49:44 <acomar> acowley: fair enough :)
15:50:02 <fizruk> ski: e.g. interpret (m >> n) == interpret m >> interpret n
15:50:29 <acomar> acowley: I see your point about the lack of applicability for a pipes or conduit based approach and image processing problems
15:50:46 <acowley> acomar: Yeah, it's just that it's hard to incrementally process individual images
15:50:59 <acomar> acowley: but as some one interested in tracking/slam type problems, those kind of building blocks would be very nice
15:51:10 <acowley> acomar: I do the same kind of research
15:51:20 <acomar> acowley: oh! awesome!
15:51:40 <acowley> acomar: I usually use something like T = m (a, T m a)
15:51:42 <acowley> acomar: as in roshask
15:51:50 <acowley> acomar: Now I'm trying to bring machines to bear
15:51:59 <ReinH> I wonder what you can actually use zero semigroups for... (newtype ZeroSemigroup a = ZeroSemigroup (Maybe a); instance Semigroup a => Semigroup (ZeroSemigroup a) where _ `mappend` _ = Nothing)
15:52:16 <acomar> acowley: ahh, yea. I just happen to be familiar with pipes and not machines
15:52:27 <ReinH> actually you don't even need the constraint. Anything can be a ZeroSemigroup.
15:52:28 <acowley> acomar: machines is much less complete
15:52:46 <acowley> acomar: I've made some huge changes to it over the past week that I haven't pushed upstream
15:52:58 <acowley> acomar: So it now supports various interesting processing topologies with various types of concurrency
15:53:32 <acomar> acowley: oh sweet, that's one of the things I've been concerned about with pipes -- it's a little more difficult to express things that aren't strict pipelines
15:53:33 <acowley> acomar: My use-case is feeding RGBD images through OpenCL GPU and CPU processing, visualization, and performance monitoring
15:53:50 <fizruk> ski: so far I thought of an extra object that is passed to output_c and input_c, which represents the currently built DSL structure
15:53:52 <acowley> acomar: Yes, I hope the changes I'm making to machines makes sense
15:54:08 <acomar> acowley: do you have some portion of the ocl interface wrapped? or is there some other opencl library for Haskell?
15:54:41 <acowley> acomar: I write OpenCL kernels in the OpenCL language, but I interface it to Haskell via https://github.com/acowley/CLUtil
15:55:02 <acowley> acomar: But that library is well overdue for a new tutorial blog post as I've changed it quite a bit since I first wrote about it
15:55:07 <fizruk> ski: though I have no clear vision of how to block on input_c call
15:55:16 <acowley> I've added bits of type safety for CLImage and CLBuffer objects
15:55:20 <acomar> acowley: ahh, kk. I keep hoping accelerate will move to OpenCL, but it hasn't happened yet.
15:55:27 <acowley> and richer interop with Vector and, of course, linear
15:55:31 <acomar> right
15:55:35 <acowley> acomar: Yeah, I hear ya
15:56:03 <acowley> I really don't mind writing raw OpenCL, actually. I'd gladly take a good DSL, but I wouldn't want to lose any expressivity.
15:56:26 <acowley> It's hard enough to arrange things to get good performance without any extra pieces getting in the way
15:57:02 <acowley> acomar: Let me know if you want to start using OpenCL soon and I'll bump up the CLUtil cleanup to make it more clear how to use it effectively
15:57:03 <acomar> acowley: yea, I understand that that's why accelerate was so tightly tied to cuda for a while (I think they've separated it abit out since)
15:57:23 <acowley> acomar: There's an in-development OpenCL backend that's been sitting around somewhere for a couple years now
15:57:30 <acomar> acowley: my hands are going to be a bit full with this for a while, so it'll be a bit
15:57:41 <acomar> is it really a couple of years old?
15:57:42 <acomar> wow
15:58:13 <acowley> I think so, but my relationship with time is very fluid
15:58:36 <marchdown>  /j #dd-wrt
15:58:44 <acowley> acomar: https://github.com/HIPERFIT/accelerate-opencl
15:58:44 <marchdown> oops
15:59:15 <acomar> acowley: oh wow, yea. I thought the work to separate the backend from the frontend was much newer than that in accelerate
16:00:49 <acomar> acowley: but yea, I won't really have much of a chance to play with OpenCL again for a bit -- I've committed to developing this OpenCV library, and I intend to see that through
16:00:58 <acowley> acomar: That's awesome
16:01:07 <acomar> so that's my free time for the next while
16:01:16 <acowley> acomar: Did you take a look at the examples directory of my repo?
16:01:43 <acomar> acowley: yep, I was poking through to see if I could figure out how the RULES worked in practice
16:02:18 <acowley> acomar: If things are building for you, give the VideoFunhouse demo a try
16:02:29 <acowley> acomar: It lets you see framerates
16:02:47 <acowley> acomar: I think the par annotations aren't buying anything now
16:03:04 <acowley> acomar: But you can run it, then kill the rewrite rules and build it again to see the change in performance
16:03:13 <acowley> Not that it's that surprising
16:03:29 <acomar> acowley: is your repo compiling with opencv 2.4?
16:03:51 <acomar> I don't have multiple branches set up yet (I should get on that)
16:03:53 <acowley> acomar: I have 2.4.5
16:04:01 <acomar> acowley: fantastic
16:04:09 <acomar> the README didn't mention it so I was worried
16:04:52 <Raydiation> is it normal that haskell code sucks in regard of variable naming?
16:05:24 <acomar> Raydiation: if by that you mean that variable names tend to be shorter, then probably
16:05:33 <Raydiation> well yeah
16:05:38 <Raydiation> single characters
16:05:48 <acomar> Raydiation: code tends to be much more generic in Haskell, there are rarely good names to give to variables
16:06:08 <Raydiation> what about (head:rest) instead of (x:xs)
16:06:24 <acomar> the thing is, x:xs is a very common pattern
16:06:39 <elliott> head is taken.
16:06:42 <elliott> and that doesn't support (y:ys)
16:06:50 <acomar> so common that when you see it, you'll learn to read it as first:rest
16:06:54 <NemesisD> anyone here used par-monad io? how does it compare to async
16:07:35 <Raydiation> sure its fast to see but i think confusing in the rest of the block
16:07:37 <acomar> it'd be like for(int integer = 0; integer `LessThan` otherInteger; integer++) in a C like language
16:07:56 <acomar> the long names get in the way of understanding what the code does, counterintuitively
16:07:59 <acomar> (idioms matter :))
16:08:09 <merijn> Raydiation: The idea behind "x:xs" is one thing, multiple thingS, one x, multiple xS
16:08:33 <Raydiation> i see
16:08:45 <merijn> Raydiation: Variable name length should be proportional to importance and inversely proportional to the size of the scope in which it can be used
16:08:53 <acowley> Raydiation: The use of short names leans heavily on the type checking, too
16:08:58 <merijn> eh
16:09:04 <merijn> proportional to the scope too
16:09:13 <acomar> acowley: hah, I'm surprised it built on the first shot, I expected issues with the headers
16:09:22 <acowley> acomar: Yeah, that's kid of amazing
16:09:39 <acomar> acowley: I've been wrestling with cabal and gcc versus g++ issues for two weeks now :/
16:09:47 <merijn> So global things, long names. Important things, long names. Local things, shorter names, unimportant things shorter names. Frequently used things shorter names, infrequently used things longer names
16:10:06 <Raydiation> not really fair but looking at this http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_C
16:10:10 <acomar> (the latest headers check to make sure you're running a C++ compiler and error out, even when that's not necessary)
16:10:13 <Raydiation> im not sure if thats good
16:10:14 <acowley> acomar: It's a rite of passage… that we must face over and over and over :(
16:10:40 <acomar> acowley: a rite of passage implies that you do it once then laugh at everyone else who has to go through it
16:10:41 <Raydiation> i also feel like p should be pivot in http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
16:10:55 <acowley> acomar: If you can't laugh at yourself, Haskell isn't the language for you
16:10:58 <acowley> :P
16:10:59 <acomar> hahaha
16:11:03 <acomar> fair enough
16:11:06 <fizruk> ski: I hope, I didn't scare you? :)
16:12:25 <acomar> Raydiation: that they used p rather than x is significant -- it's a break from the normal idiom. I read that as pivot without any prompting.
16:12:43 <acomar> Raydiation: it's a pattern thing, the more familiar you are with Haskell code, the more the names and patterns start to make sense
16:13:04 <acomar> like i,j,k for indices in C/C++
16:13:12 <Raydiation> hm, right
16:13:28 <ski> fizruk : i suspect something like fizruk : `foreign export ccall "input_c" stableInput :: StablePtr (DSL String); foreign export ccall "output_c" stableOutput :: StablePtr (String -> DSL ())' might be what you want
16:13:40 <ski> s/like fizruk ://
16:14:33 <ski> fizruk : iiuc, you want to call Haskell from C, getting back Haskell values, which you may then use to call into Haskell again
16:14:47 <acomar> acowley: I'm off for now. It's been good talking to you.
16:14:55 <acowley> acomar: Likewise, keep in touch
16:15:03 <elliott> the meeting of the acos
16:15:13 <ski> iiuc, to C to be able to handle the Haskell values without marshalling, you must use a `StablePtr' to it
16:15:17 <fizruk> ski: exactly!
16:15:24 <acomar> elliott: lol
16:15:47 <ski> maybe you could use `foreign export ccall "output_c" stableOutput :: CString -> StablePtr (DSL ())' instead
16:15:56 <fizruk> ski: as I can see StablePtr it is
16:16:00 <ski> and perhaps `foreign export ccall "input_c" stableInput :: StablePtr (DSL CString)' as well
16:16:17 <fizruk> ski: yes, I though of the latter form for output_c
16:17:17 <ubikation> hey what is the => operator called?
16:18:00 <ski> fizruk : so, you probably also need to export an operation of type `StablePtr (a -> b) -> (StablePtr a -> StablePtr b)', to be able to, from C, dynamically apply a Haskell function to a Haskell value
16:18:09 <ski> (perhaps for some specific types `a' and `b')
16:18:34 <ski> .. like maybe just a few specializations of this to what you need
16:19:18 <fizruk> ski: thanks a lot! I'm going to process all of this now...
16:19:40 <ski> fizruk : iiuc, if a Haskell value of (foreign) type `A' is bound by an identifier in a module, you can export it directly -- otherwise you'd have to wrap in `StablePtr' before exporting
16:20:04 <ski> so the `apply :: StablePtr (a -> b) -> (StablePtr a -> StablePtr b)' would then not need to be `StabePtr (StablePtr (a -> b) -> (StablePtr a -> StablePtr b))'
16:20:53 <ski> fizruk : hm, perhaps all these operations should have `IO' wrapping their result types, as well -- they probably need it to allocate new `StablePtr's anyway, and it's nicer if you don't have to `unsafePerformIO'
16:21:07 <ski> (and from the POV of C, any function can side-effect anyway)
16:21:48 <fizruk> ski: yes, I believe so. Thanks again!
16:22:35 <Raydiation> btw, does haskell use a VM?
16:22:45 <Raydiation> looking at http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&lang=java&lang2=ghc&data=u32
16:22:50 <ski> fizruk : however see "It is important to free stable pointers that are no longer required by using freeStablePtr. Otherwise, the object referenced by the stable pointer will be retained in the heap." at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-310005.6>
16:22:53 <Raydiation> its basically on par with java
16:23:10 <ski> fizruk : i'm not sure what the best way to use `freeStablePtr' would be here
16:23:12 <Raydiation> which is kinda amazing
16:23:20 <fizruk> ski: just was typing question on freeing StablePtr =)
16:23:50 <ski> fizruk : if you use a GC (like Böhm) in C, then you could tell it to call `freeStablePtr' when freeing, possibly
16:24:11 * ski can't recall whether Böhm supports something like finalizers
16:24:14 <ubikation> hey what is the => operator called?
16:25:44 <fizruk> ski: the intention is to export DSL API for many languages (I see C as a proxy here)
16:26:47 <ski> ubikation : i'm not sure it has a pronounced way
16:26:53 <ski> er, s/way/name/
16:27:16 <ubikation> ski: err... what does it mean?
16:27:25 <ski> fizruk : yeah. Haskell has no idea when the foreign language is done with the `StablePtr a'
16:28:15 <ski> ubikation : `=>' is used with a sequence of constraints (usually class constraints) at the left side
16:29:18 <xico> is there any impact on performance with functions typed with Floating a => instead of specific Double types?
16:30:11 <ski> those constraints are often called a "context"
16:30:26 <nisstyre> xico: it probably depends, and you probably shouldn't worry
16:30:35 <nisstyre> what are you writing?
16:30:38 <ski> ubikation : its interpretation depends on the context in which this "context" appears -- often it means that the context is assumed as an extra condition
16:30:56 <ubikation> ski: thanks! that really helps me googling stuff :)
16:32:08 <ski> fizruk : in case the other language has a GC, you could try setting it up to call `freeStablePtr' (or a C wrapper around it, also see `void hs_free_stable_ptr (HsStablePtr sp);') in a finalizer in the other language
16:33:01 <ski> fizruk : .. i think it's more common to let Haskell call out to other language libraries than the other way around -- but iiuc, you should do something like what i sketched above
16:33:14 <ski> (note i haven't tried something like this)
16:33:37 <ubikation> I don't understand how flip works with partial application... I want to say intuitively that it's running the function backwards but that can't be right cant it? or is just a reordering of the arguments?
16:33:54 <ski> the latter
16:34:01 <ubikation> ski: thanks!
16:34:05 <geekosaur> @src flip
16:34:05 <lambdabot> flip f x y = f y x
16:34:08 <ski> > flip (*) a b
16:34:08 <fizruk> ski: yes, "the other way around" is my intention :)
16:34:09 <lambdabot>   b * a
16:34:10 <ski> > (*) a b
16:34:11 <lambdabot>   a * b
16:34:43 <ski> fizruk : yea :) just noting that this isn't as common, and hence people know less about how to go about doing it
16:36:03 <nisstyre> ubikation: (\a b -> b) 3 returns a function (equivalent to id), does that help you grok things a bit?
16:36:11 <ski> fizruk : afaiu, you want to keep `DSL' abstract, as regards the FFI (and obviously the other side of the border)
16:36:24 <nisstyre> > let f = (\a b -> b) 3 in f "a"
16:36:25 <lambdabot>   "a"
16:36:35 <ski> though i suppose since `DSL' is a monad, you can still go from `DSL String' to `DSL CString'
16:36:47 <nisstyre> > let f = flip (*) 2 in f 3
16:36:48 <lambdabot>   6
16:37:30 <gaze__> http://lpaste.net/93475 Would you mind having a look at this? I'm having some trouble understanding how to avoid the existential antipattern
16:38:01 <ski> fizruk : btw, for converting into strings in C land, you probably sooner or later want C (or third foreign party) to have responsibility for freeing those
16:39:46 <ubikation> nisstyre: err that sort of helps... I understand that your lambda function is a reordering but I guess I still have trouble seeing how it works with partial application. it seems like flips makes a function that buffers arguments until it can run the function completely?
16:39:46 <ski> fizruk : either that, or keep accessing the Haskell-allocated `String' (which then needs a `StablePtr' wrapper)
16:40:05 <fizruk> ski: certainly. moreover, I use free monads in my actual code to keep the possibility of DSL extension.
16:41:30 <fizruk> ski: I believe it would be either CInt (or similar) or more complex Haskell data structure than String, so this String/CString is not a big deal
16:42:03 <nisstyre> ubikation: (\a b -> b) is desugared to (\a -> (\b -> b))
16:42:18 <nisstyre> desugared means it gets transformed to that by the compiler
16:42:48 <ski> fizruk : however, `malloc' and `free' in Haskell need not correspond to the C variants, iirc. so then you either want the C side to eventually call Haskell `free', or you want to copy over to C `malloc'ed (e.g.) memory and Haskell `free' immediately
16:42:48 <nisstyre> (not in that textual form, abstractly)
16:43:20 <nisstyre> ubikation: you know that Haskell functions can return functions right?
16:43:35 <ski> fizruk : and this is probable best done from the Haskell side, so that Haskell can still see the `String' / `CString', so that you don't need to wrap it in `StablePtr'
16:44:02 <ubikation> flip f x y = f y x ~ (\f -> (\x -> (\y -> f y) x))?
16:44:16 <monochrom> though, GHC User's Guide says that its malloc and free are wrappers around C's
16:44:18 <ski> fizruk : that's only my understanding, though; i might be mistaken
16:44:27 <ski> (FFI stuff is tricky)
16:44:35 <ski> monochrom : ok
16:44:52 <nisstyre> flip f x y is the same as flip f = (\x -> (\y -> ((f x) y)))
16:44:57 <monochrom> this is probably not entirely promised at the Haskell 2010 level
16:45:33 <ubikation> nisstyre: but that doesn't reorder anything does it?
16:45:53 <Raydiation> what is cabal-dev?
16:45:55 <nisstyre> > let flip' f = (\x -> (\y -> ((f x) y))) in flip (:) [1,2,3] 4
16:45:56 <lambdabot>   [4,1,2,3]
16:45:58 <Raydiation> header files for cabal?
16:46:13 <monochrom> cabal-dev is http://hackage.haskell.org/package/cabal-dev
16:46:31 <nisstyre> ubikation: oh yeah sorry
16:47:31 <ski> fizruk : btw, note that stuff like `newCString' and `withCString' at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise6.html#x10-420006.3> does unicode conversion to some multi-byte representation, and you probably don't want to attempt to duplicate this, so it's probably better to then use `withCString' and then copy over to a C `malloc'ed string (unless you want to rely on the GHC promise by monochrom above)
16:47:36 <ubikation> but this is helping me a lot though... I guess I still need to keep reading lyah
16:47:57 <fizruk> ski: thanks!
16:48:34 <monochrom> GHC's withCString and alloca, however, do not use C's malloc or GHC's malloc
16:48:52 <monochrom> they do it for speed
16:48:59 <ski> ok (it might be that that was what i vaguely remembered)
16:49:07 <monochrom> because C is too slow! :)
16:49:08 <xico> nisstyre: numerical algorithms (recursive filtering here) on large multidimensional data
16:49:17 <xico> nisstyre: (for the Floating a =>)
16:49:22 <Ghoul__> I think theres a glitch in decodeFloat which can cause a stack overflow
16:49:41 <Ghoul__> anyone seen this before?
16:50:10 <alas> > let flilp' f = (\x -> (\y -> ((f x) y))) in flip' (:) [1,2,3] 4
16:50:11 <lambdabot>   Not in scope: flip'
16:50:12 <lambdabot>  Perhaps you meant one of these:
16:50:12 <lambdabot>    flilp' (line 1), `f...
16:50:13 <ski> btw, shouldn't `realloc' say that it's allowed to use it on memory allocated by itself ?
16:50:28 <alas> > let flip' f = (\x -> (\y -> ((f x) y))) in flip' (:) [1,2,3] 4
16:50:29 <lambdabot>   No instance for (GHC.Show.Show t0)
16:50:30 <lambdabot>    arising from a use of `M768125363.sho...
16:50:34 <nisstyre> ubikation
16:50:36 <nisstyre> > let flip' f = (\x -> (\y -> ((f y) x))) in (flip (:)) [1,2,3] 4
16:50:37 <lambdabot>   [4,1,2,3]
16:50:38 <merijn> ski: Eh, in my experience malloc/free in haskell *do* correspond with the C ones
16:50:57 <monochrom> oh, heh, lawyers :)
16:51:01 <merijn> Actually
16:51:04 <merijn> Maybe not
16:51:08 <ski> merijn : may i assume you only tried with GHC ? ;)
16:51:11 <merijn> Maybe GHC is just linking in its own GHC
16:51:14 <merijn> eh malloc
16:51:21 <merijn> Does GHC link with libc?
16:51:58 <merijn> ski: Yes, but I just realised it doesn't matter because there is no "C malloc"
16:52:00 <alas> nisstyre, what you told lambdabot doesn't test flip'
16:52:15 <merijn> ski: I guess all that matters is whether your haskell compiler links with libc or not
16:52:15 <nisstyre> alas: yeah I just noticed that, typo
16:52:24 <nisstyre> > let flip' f = (\x -> (\y -> ((f y) x))) in flip' (:) [1,2,3] 4
16:52:25 <lambdabot>   [4,1,2,3]
16:52:28 <nisstyre> there
16:52:29 <Ghoul__> forget it, quick test shows thats impossible. Some laziness screw-up on my end heh
16:53:16 <monochrom> merijn: GHC User's Guide says that GHC's malloc and free are wrappers around C's. this likely doesn't generalize to other Haskell implementations
16:53:22 <ubikation> nisstyre: but see that kind of confuses me because it's like it magically creates a function (f y) which doesn't make sense to me
16:53:48 <nisstyre> ubikation: anyway the point is that all multi-parameter functions in Haskell actually get desugared to ones that take a single parameter and return new functions
16:54:06 <nisstyre> ubikation: the idea is that functions are actually values
16:54:14 <merijn> monochrom: Yes, I was just pointing out that that entire notion is actually nonsensical
16:54:42 <merijn> monochrom: There's no "C malloc" and your haskell compiler can link in whatever malloc it likes and your C code will just use that
16:55:12 * monochrom rejects "there is no C malloc"
16:55:15 <nisstyre> merijn: as I understand it some versions of malloc are more suited to certain types of programs
16:55:21 <merijn> nisstyre: Sure
16:55:24 <nisstyre> like the linux kernel's version of malloc
16:55:25 <nisstyre> and so on
16:55:53 <merijn> nisstyre: kernel malloc are very different from userspace mallocs, you can easily implement your own malloc and use that
16:55:54 <nisstyre> I'm assuming it doesn't *really* matter and is just a performance thing, is that right?
16:56:18 <nisstyre> merijn: yeah of course
16:56:25 <nisstyre> although it would suck if I did it
16:56:58 <merijn> monochrom: Oh, and what is C malloc according to you, then?
16:57:22 <merijn> monochrom: There's just a (trivial) interface and you can link in your own version of it no problem
16:57:51 <ubikation> nisstyre: I guess I'm just stuck on how reordering arguments can work with partial application... I mean I know what flip does I just don't get how it does it... and I've been staring at the various synonym definitions of it for a while. I guess It'll come to me.
16:58:52 <merijn> ubikation: "flip f x y = f y x"
16:59:17 <geekosaur> the trick is that in Haskell, every function actually takes a single parameter. if it "takes multiple parameters" then it returns another function which takes another parameter
16:59:50 <geekosaur> so this happens until flip has everything it needs, then it feeds those to the function you applied it to
17:00:20 <nisstyre> ubikation: like I said, you have to understand that functions can return functions, that functions are really just values, and that multi-param functions get transformed into single param ones that return new functions for each parameter
17:00:21 <geekosaur> see nisstyre's version of flip which uses lambdas; that's just the explicit form of what haskell is doing for you automatically
17:00:30 <merijn> ubikation: Maybe clearer if you know lambda notation in Haskell: "flip f = \x -> \y -> f y x"
17:01:08 <merijn> ubikation: That version and the previous one I typed are identical
17:01:22 <merijn> for some value of identical
17:01:52 <nisstyre> ubikation: the function call syntax is also designed to make it less apparent that you're really calling a function that returns a function and so on
17:02:25 <merijn> ubikation: Do you know any other languages? (Preferably with first class functions...)
17:02:38 <ubikation> okay I think I'm getting it now.
17:02:46 <ubikation> I know java, python and a bit of cl.
17:02:58 <nisstyre> ubikation: in python it would be flip(f)(x)(y) to call it
17:03:12 <ubikation> I don't know any of them particularly well though
17:03:22 <nisstyre> def flip(f) : return lambda x: lambda y: f(y,x)
17:03:29 <nisstyre> if you know lambda in python
17:03:51 <merijn> Yeah, that was my example gonna be too
17:04:31 <ubikation> that makes it a bit easier :)
17:04:41 <alas> or def flip(f): return lambda x: lambda y: f(y)(x)
17:04:49 <nisstyre> yeah, if f is curried
17:05:35 <ski> merijn : yes, but will Haskell `mallocBytes' be (calling) the same as the one you get with `foreign import ccall "stdlib.h malloc" malloc :: CInt -> IO (Ptr a)' (or whatever is the correct incantation for `size_t') (when having linked with `libc', say)
17:05:36 <nisstyre> btw, curried = the word for this single parameter function transformation
17:05:40 <ski> ?
17:05:47 <acowley> There seem to be a lot of broken links in hackage docs
17:06:39 <merijn> ski: No, but if your haskell compiler just exports a "malloc" C symbol that uses mallocBytes and links with that, things would work again
17:06:46 <merijn> acowley: Example?
17:07:03 <acowley> merijn: All the links in http://hackage.haskell.org/package/pipes-binary-0.2.0/docs/Pipes-Binary.html
17:07:11 <ski> merijn : granted
17:07:12 <acowley> They're all local file links
17:07:56 <geekosaur> oooops...
17:08:06 <merijn> acowley: That's user error
17:08:14 <merijn> acowley: The comments link to BS.ByteString
17:08:14 <acowley> oh?
17:08:23 <merijn> acowley: But ByteString is imported qualified as B
17:08:24 <ski> merijn : by "C malloc" i think monochrom meant the one specified by `stdlib.h' -- of course this is only an interface (as you said), and you don't need to link with the usual provider of `malloc'
17:08:35 <merijn> acowley: So haddock can't find the BS.ByteString symbol
17:08:43 <acowley> merijn: But all the links are file links, not just ByteString
17:08:48 <acowley> e.g. Monad
17:09:42 <merijn> acowley: oh, in the type signature
17:09:46 <merijn> Yeah, that's weird
17:09:53 <ski> hm, would it be possible to tell GHC not to link C code linked with the program with `libc' ?
17:09:59 <ski> i assume it would be
17:10:11 <merijn> ski: Presumably, and if not it shouldn't be hard to add
17:10:19 <merijn> acowley: Go complain at dcoutts? ;)
17:10:23 <fizruk> ski: I've attached DSLFFI module and "Hello, world!" example, which works http://lpaste.net/93519
17:10:51 <fizruk> ski: now I'm stuck with using `input`...
17:11:11 <acowley> merijn: I think I saw someone else report it somewhere, but I didn't realize how widespread it was
17:11:33 <fizruk> ski: actually i need to export (>>) for DSL monad to combine several outputs at least...
17:15:27 <fizruk> ski: I think desired C code is like http://lpaste.net/93526
17:15:38 <gaze__> ski? anyone? I'm really confused about what the right way to do this is http://stackoverflow.com/questions/19061828/existential-antipattern-how-to-avoid
17:18:07 <ski> fizruk : yes, of course
17:19:10 <fizruk> ski: referring to the "desired C code" I suppose?
17:20:54 <ski> no, haven't looked at that yet
17:22:12 <fizruk> ski: while exporting (>>) is simple, exporting (>>=) is not obvious to me (wrt the desired C code look)
17:23:56 <ski> hm, exporting `(>>=)' would require C to be able to dynamically (in think) export back a function to Haskell, probably using <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-300005.5>
17:24:03 <ski> s/in think/i think/
17:27:54 <ski> hm, "Dynamic import" at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-160004.1> is possibly relevant
17:28:12 <fizruk> ski: that way I need to declare new function each time I need to use `input`-like command in C code?
17:28:25 <ski> hm
17:28:36 <ski> i was about to ask about that before, actually
17:28:55 <ski> do you want `test' to construct a `DSL'-action, and pass it off to Haskell ?
17:29:34 <ski> well, do you want to be able to construct `DSL'-actions, without immediately executing them in Haskell ?
17:29:38 <merijn> gaze__: You mention wanting to "mutate" Paint's, but your code doesn't have any examples of how/what?
17:29:43 <fizruk> i think, i'd like to block C function on any command until Haskell interprets it
17:30:23 <ski> fizruk : so calling `input' from C should no just create a `DSL'-action, but should actually block until Haskell responds in the execution thereof ?
17:30:56 <ski> (by `input', i mean the one you envision calling in your `test' there, not necessarily the existing Haskell `input' thing)
17:30:58 <fizruk> ski: I believe so. Keeping syntax abstract though.
17:31:43 <ski> fizruk : and what happens on the Haskell side ?
17:32:10 <gaze__> merijn: Yeah... well, I'm not sure what it should even look like. The API that most graphics APIs expose might be translated to haskell as { p <- newPaint; setBg p red; drawText (Point 0 0) p "hi world" }
17:32:12 <ski> is it just connected to some library code on the Haskell side, or is there an "active" program on that side responding, that you want to be able to program directly ?
17:32:28 <gaze__> but again I wouldn't know how to implement such a thing with an abstracted "newPaint" procedure
17:33:23 <Athan> Hey does anyone know how to debug cabal installs? All I get back for an error is "ExitFailure 1"
17:33:28 <fizruk> ski: currently, main = test_c >>= deRefStablePtr >>= runDSL
17:33:32 <Athan> Like is there a local log or anything?
17:33:52 <fizruk> ski: so, I guess, it is "library code" case
17:34:08 <merijn> Athan: Have you tried running with -v3?
17:34:15 <merijn> Athan: That should dump out all individual actions
17:35:48 <merijn> gaze__: Paint is supposed to wrap some form of object from an external framework, right?
17:35:55 <gaze__>  yes.
17:36:38 <merijn> gaze__: And mutations need to update that underlying value?
17:36:58 <fizruk> ski: actually, I don't get the difference with "active" program
17:37:17 <gaze__> possibly. They either need the value (which is a pointer into an external framework), or it is indeed some mutating value.
17:38:06 <gaze__> either way we DO know that a paint can have his background set, his font set, his foreground color set, and that he can be passed to drawing routines who know how to use him
17:38:10 <merijn> gaze__: Have you considered simply storing whatever mutatable value in an IORef/MVar? Mutating underlying things in an external framework is in IO anyway
17:38:19 <ski> fizruk : i just mean that you either just want `input' and `output' over in C land to do something specific in Haskell land; or you want the interpretation of `input' and `output' in Haskell land to depend on how you receive and decide to handle the requests coming from C
17:39:21 <ski> gaze__ : i'm not quite sure what you want here, but would hiding `p' above in an environment monad help any ?
17:39:40 <gaze__> but what's the type of the monad then?
17:40:07 <gaze__> p is just a "thing" that a backend knows how to work with
17:40:08 <gaze__> and provides
17:40:13 <gaze__> but it's supposed to be opaque
17:40:25 <ski> what is the goal you're reaching for ?
17:40:54 <merijn> gaze__: Just IO? tbh, it's not really clear what problem you are having and thus what to suggest
17:40:58 <ski> (i already learned you don't want to recreate `Paint's needlessly)
17:41:02 <fizruk> ski: I don't want to make interpretation difference between `input_hs` and `input_c` commands
17:41:13 <Eduard_Munteanu> ski: I just realized, for the indexed store comonad, the two things are quite legitimate and separate, one maps the input index and the other the output index.
17:41:16 <merijn> gaze__: Maybe you want to clearly write down "this pseudo code is what I want to write, how do I do this?"
17:41:48 <ski> fizruk : yes, but is `input_hs' fixed once-for-all, or would the user of your "library" be able to provide the definition of `input_hs' (more or less) ?
17:42:16 <ski> Eduard_Munteanu : yes, of course :)
17:42:32 <merijn> gaze__: Because right now, we're just kinda guessing what you want to write, which makes it difficult to suggest something useful :)
17:42:36 <ski> the question is whether both make sensible implementations of `mapFocus' in `ComonadStore'
17:43:05 <fizruk> ski: no, the API (input/output in this case) is fixed from the user's point of view
17:43:18 <gaze__> say something like drawLineOnCanvas c = do { p <- newPaint c; setBg p Black; drawLine c p (Point 3 3) (Point 0 0) }
17:43:26 <ski> (so, that question if then partly about what the point of `mapFocus' should be -- e.g. expressed in terms of laws)
17:43:36 <ski> fizruk : ok
17:44:29 <ski> gaze__ : instead of ?
17:44:47 <merijn> gaze__: Right, so if you're in IO anyway (presumably newPaint is an IO action) why not have setBg/drawLine, etc. be IO?
17:44:50 <ski> fizruk : hm, now i've forgotten why i asked the question :)
17:45:20 <fizruk> ski: =)
17:45:40 <gaze__> because there need to be some number of implementations of setBg for each backend.
17:45:52 <merijn> gaze__: But that's simple, hide that inside the Paint
17:46:52 <gaze__> yes! okay. So then how does the drawLine of Canvas { drawLine :: Paint -> Point -> IO () } get the platform specific bits back out of the Paint object?
17:47:07 <merijn> "data Paint { paintSetBg :: Colour -> IO () }" "setBg :: Paint -> Colour -> IO (); setBg p c = paintSetBg p c" or something like that
17:47:49 <ski> fizruk : hm, do you want to define an interpretation `runDSL', and then somehow have that magically being called by the `input_c' and `output_c' commands ?
17:48:35 <merijn> "somePlatformBg :: PlatformSpecificInfo -> Colour -> IO ()" "Paint { paintSetBg = somePlatformBg platformspecificPaintState }"
17:49:05 <fizruk> ski: no, I want to be able to choose interpreter *after* or even write another one
17:49:11 <merijn> gaze__: Just have a platform specific argument and partially apply it, store the partially applied function in Paint
17:49:54 <fizruk> ski: basically, I guess, I need lazy C
17:49:55 <gaze__> but where's the pointer?
17:50:13 <merijn> gaze__: Which pointer? Your example code on SO doesn't have any pointers anywhere
17:50:15 <gaze__> ohhh wait I see...
17:50:33 <ski> fizruk : "after" what ?
17:50:44 <ski> after C has been started ?
17:50:45 <gaze__> platformSpecificPaintState could be an IORef if it needs to be mutable
17:50:46 <gaze__> fine.
17:50:50 <merijn> gaze__: Good, that sounds like the sound of enlightenment.
17:50:54 <merijn> gaze__: Yeah, exactly
17:50:56 <ski> after C program has been written and compiled ?
17:51:01 <merijn> gaze__: Since your end result is in IO anyway
17:51:02 <gaze__> Okay! I'm totally okay with all that.
17:51:07 <fizruk> ski: after DSL library is defined and C code written and compiled
17:51:18 <fizruk> ski: both written and compiled
17:51:23 <gaze__> merijn: Now the question I was originally after... how does drawLine obtain the platformSpecificPaintState?
17:51:39 <gaze__> err... platformSpecificDrawLine
17:51:58 <ski> fizruk : "DSL library" being the Haskell parts you sketched ?
17:52:18 <fizruk> ski: DSL and DSLFFI modules, yes
17:52:39 <fizruk> ski: without runDSL (it should be placed elsewhere)
17:53:01 <ski> fizruk : anyway, i think letting the user specify `runDSL' is akin (though perhaps weaker than) allowing the user to specify `input_hs' and `output_hs'
17:53:16 <merijn> gaze__: Presumably you have multiple functions inside Paint, right? Just have "newPaint :: IO Paint; newPaint = do { whatever <- ioAllocationStuff; return (Paint { paintSetBg = platformspecificBg whatever, paintDrawLine= platformspecificDrawLine whatever, paintFoo = platformSpecificFoo whatever })"
17:54:22 <fizruk> ski: you're probably right. I guess, I meant runDSL is written by another kind of user (which only creates interpreters)
17:54:25 <merijn> gaze__: i.e. just pass the same platform specific state to every platform specific function, resulting in a generic Paint object that works regardless of platform
17:54:35 <ski> fizruk : so, at some point, we need to bind `runDSL' as seen from FFI/C code to the actual `runDSL' you want to use
17:54:38 <merijn> gaze__: Now you just need to have a platform specific newPaint action
17:54:52 <ski> fizruk : should `runDSL' be fixed when linking in Haskell code defining it ?
17:55:16 <ski> fizruk : or could it be linked dynamically, by passing a value of type `DSL a -> IO a' somewhere appropriate ?
17:55:51 <merijn> gaze__: In fact, you could have a generic library working on this Paint data structure and then have a library per platform that just imports all generic functionality from the generic library and provides a platform specific way of creating the generic Paint/Canvas/whatever datatypes
17:56:04 <ski> fizruk : anyway, after we have bound it, `input_c' and `output_c' will have specific fixed interpretations (in terms of `runDSL')
17:56:39 <merijn> gaze__: i.e. have all the platform specific stuff only define newPaint/newCanvas/etc and reexport all functionality that uses those from a core "generic" library
17:56:54 <ski> fizruk : so, in some way, we need to start `runDSL' off in a Haskell thread, even though C hasn't fully created the `DSL a' it will be called on, yet
17:57:00 <ski> fizruk : do you agree ?
17:57:50 <merijn> Is anyone here aware of work on languages with type systems that have multiple (orthogonal) domains of typing judgements?
17:58:04 <ski> (since given `runDSL', there's no easy way to decompose it into `input_hs' and `output_hs' again, without starting off such a thread)
17:58:23 <ski> merijn : "domains" here meaning ?
17:58:28 <fizruk> ski: do you mean that output_c = runDSL . output (ignore CString/String conversion)?
17:59:02 <gaze__> hmmm... alright
17:59:34 <merijn> ski: Well, to give an example, I have a colleague working on types for memory layouts, plus type inference for that. This if, of course, completely orthogonal to the "semantic" types like "Int -> Int" or whatever
17:59:55 <fizruk> ski: and runDSL can be "switched" by switching, say, "import DSL.Interpreter (runDSL)" to "import MyCustomInterpreter (runDSL)"
17:59:58 <merijn> ski: And there's of course many more conceivable things to describe in types (like GC domains, etc)
18:00:30 <ski> ("GC domains" being similar to regions as in Region-based memmory management ?)
18:00:34 <merijn> ski: In haskell I would have to try and encode all these things in a single type, even though they're semantically orthogonal and could be type checked independently of eachother
18:01:27 <merijn> ski: I don't know about region-based memory management, I mean having multiple GCs in a single program, avoiding global GC freeze (at the cost of not being able to share all data in a program, because there is no global store, conceptually)
18:01:46 <merijn> ski: You could type check that values don't accidentally get shared between different GCs
18:02:02 <Eduard_Munteanu> ski: the other mapFocus is actually mapValues I think: mapValues (g :: a -> a) (Apply (f :: s -> a) s) = Apply (g . f) s. So it boils down to g . f (maps s to a then a) vs f . h (maps s to s then a). Aren't these equivalent?
18:02:23 <gaze__> merijn: I wish I could sorta separate the things that operate the paint state a bit from the things that operate WITH the paint state
18:02:26 <ski> merijn : so you're talking about `Gamma_a |-_a e : t_a' and `Gamma_b |-_b e : t_b', where the types of `Gamma_a',`t_a' may differ from `Gamma_b',`t_b' ?
18:02:27 <gaze__> I think that was my original hope.
18:02:29 <fizruk> ski: if I got you right, it takes us back to the restriction runDSL `(m >> n) = runDSL m >> runDSL n` which is not desired
18:02:48 <fizruk> s/runDSL `/`runDSL /
18:03:21 <merijn> ski: Yes, in the sense that I should be able to make valid judgement for both Gamma_a and Gamma_b for something to be considered well-typed, but with Gamma_a and Gamma_b being completely orthogonal
18:03:44 <ski> Eduard_Munteanu : i thought `mapValues' had a different type
18:04:20 <gaze__> because ooh... here's another problem
18:04:38 <ski> fizruk : "if I got you right" -- regarding "do you mean that output_c = runDSL . output (ignore CString/String conversion)?" ?
18:04:46 <gaze__> actually wait... no.
18:04:53 <fizruk> ski: aha
18:05:13 <ski> (fizruk : i'm not sure whether the answer to "do you mean that output_c = runDSL . output (ignore CString/String conversion)?" would be yes)
18:05:47 <merijn> ski: To use the example of my colleague's work, Gamma_a would be the typical typing used in PL, but Gamma_b would be the physical memory layout of data. Things can be polymorphic in layout, or have a fixed layout, etc. which is inferred and type checked, and I can easily imagine additional things to encode in orthogonal types
18:06:03 <merijn> ski: I was just curious if anyone had looked into something like that yet
18:06:12 <merijn> It seems such an obvious idea
18:06:19 <ski> (fizruk : i don't see how you could do something like `input_c = ..runDSL..input..', anyways)
18:07:04 <fizruk> ski: runDSL input :: IO String, so I don't see any problems
18:07:19 <ski> merijn : ok, so ounds like two separate (though maybe you want some interaction as well to be possible ?) type systems for the same source language (expressions)
18:07:24 <ski> s/ounds/sounds/
18:07:30 <Eduard_Munteanu> ski: hm right, a restricted mapValues then? Think what happens if you change the focus some other way... when you extract the value and focus, you get changed values, and the same focus as you put in.
18:08:21 <Eduard_Munteanu> mapValues :: (a -> b) -> w s a -> w s b
18:08:30 <fizruk> ski: I need C code to construct DSL structure up to the input-like command (which should block until value is available)
18:09:32 <merijn> ski: I'm cautiously open to the idea of having interactions, although I currently think that would actually be an unneccesary complication and completely separate systems would be easier for programmers
18:09:37 <fizruk> ski: first thought is to pass a new function to the input (next computation)
18:10:18 <fizruk> ski: this, however, makes C code impossible to write/read for a human
18:10:20 <Eduard_Munteanu> Actually you might be right if the store comonad is something that's not a function.
18:10:41 <joelteon> what should I use for drawing vector graphics in a window?
18:10:48 <ski> fizruk : anyway, the idea could be that we might have `runDSL = loop 0 where loop n (Input sma) = loop (n+1) . sma =<< getLine; loop n (Output s ma) = putStrLn s >> loop (n+1) ma; loop n (Return a) = report n >> return a' or something like that, that keeps track of an internal state while interpreting
18:11:17 <Hodapp> joelteon: I think I had heard the Cairo bindings for Haskell are quite good?
18:11:21 <ski> fizruk : then we couldn't safely recover `input_c' and `output_c' from `input' and `output', merely by calling `runDSL' once
18:11:48 <ski> fizruk : this might be what you meant by "it takes us back to the restriction runDSL `(m >> n) = runDSL m >> runDSL n` which is not desired"
18:12:04 <Hodapp> joelteon: http://fhtr.blogspot.com/2008/12/drawing-tree-with-haskell-and-cairo.html ?
18:12:29 <ski> fizruk : so, we really only want a single call to `runDSL', not one for every call to `input_c' and `output_c', agree ?
18:13:14 <fizruk> ski: precisely, single call
18:13:16 <ski> merijn : i'm not aware of any such work, but it seems like an obvious idea to try, as soon as one had an application with two such type systems in mind
18:14:03 <ski> (as you said)
18:15:24 <joelteon> Hodapp: ideally I'd like to use openGL
18:15:36 <ski> Eduard_Munteanu : i don't see how to go from `mapFocus :: (s -> s) -> (w s a -> w s a)' to `mapValues :: (a -> b) -> (w s a -> w s b)' (or the variant where `a' is `b') or vice versa
18:16:01 <merijn> ski: Well, another use case I can think off is the kind of stuff in the Kleisli Arrows of Outrageous Fortune paper, i.e. tracking stuff like filestate/whatever without needing to switch all your stuff to indexed monads or indexed whatever datatypes :)
18:16:18 <Hodapp> joelteon: What sort of vector graphics are you talking?
18:16:27 <joelteon> For a game
18:17:16 <ski> fizruk : my vague idea here is that you might want something like futures -- in the sense that you hand off a `DSL a' value to `runDSL' that you haven't actually computed yet. calls in `C' will "instantiate" the future more and more
18:17:46 <ski> fizruk : btw, i don't see what you mean by "first thought is to pass a new function to the input (next computation)", elaborate ?
18:18:26 <ski> merijn : hm, haven't seen that paper
18:19:24 * ski looks at <http://lambda-the-ultimate.org/node/4273>
18:19:30 <fizruk> ski: I mean passing ForeignPtr pointing to another C function (continutation, that takes CString and returns DSL ())
18:19:34 <ski> (titled "Kleisli Arrows of Outrageous Fortune")
18:19:50 <fizruk> ski: e.g. input(process_name);
18:20:08 <Eduard_Munteanu> ski: mapValues (f :: a -> a) :: w s a -> w s a, mapValues id = mapFocus id, duplicate . mapValues f = duplicate . mapFocus f    for the nasty mapFocus.
18:20:15 <Eduard_Munteanu> I think the duplicate bit is important.
18:20:25 <fizruk> ski: that line beeing last line of the function body
18:21:15 <merijn> ski: It's essentially indexed monads, with examples like tracking whether a file was closed in the typesystem
18:21:51 <Eduard_Munteanu> Because mapFocus shuffles the store's input but leaves the focus unchanged, I'm not sure it does the right thing in a chain of (=>>)s.
18:22:11 <Eduard_Munteanu> ski: sorry, I need some sleep, I'll think about it tommorow :)
18:23:33 <fizruk> ski: using "futures" in this case is not clear to me, could you give some more details?
18:23:48 <Eduard_Munteanu> The above is a bit wrong too, I meant there's f and g such that duplicate . mapValues f = duplicate . mapFocus g
18:23:52 * Eduard_Munteanu out
18:26:47 <kiba> Hello
18:26:54 <kiba> Trying to install hakyll
18:27:23 <kiba> https://gist.github.com/kiba/6737398
18:28:29 <ski> fizruk : so instead of `name = input(m); output(m,foo(name)); ...' you'd have to say `input(m,receiver);' and define `receiver(char *name) { output(m,f(name),continuation); }' and define `continuation' to continue with `...' ?
18:28:31 <fizruk> ski: maybe it is possible to turn C program into a coroutine in a sense that `input_c` somehow "saves" the context and packes it as a whole in a (DSL String) value?
18:28:36 <ski> fizruk : is that what you meant ?
18:28:57 <fizruk> ski: yes
18:29:46 <ski> well, i was considering the case where we wanted to keep (basically) the simple structure at <http://lpaste.net/93526>
18:29:48 <gienah> kiba: what does this say: ghc -V
18:30:01 <fizruk> ski: except that output may be implemented without continuation (though with exported (>>))
18:30:02 <kiba> version 7.6.3
18:30:27 <fizruk> ski: yes, I want to stick to that simple structure
18:30:45 <fizruk> ski: I just don't know how to implement it =)
18:31:22 <gienah> kiba: what does this say: ghc-pkg list network
18:31:43 <ski> @tell Eduard_Munteanu hm, so you're saying `mapFocus' and `mapValues' would in some cases at least be "two sides of the same coin" .. hm
18:31:43 <lambdabot> Consider it noted.
18:31:56 <kiba> /usr/lib/ghc-7.6.3/package.conf.d
18:31:56 <kiba> /home/kiba/.ghc/x86_64-linux-7.6.3/package.conf.d
18:31:56 <kiba>    network-2.4.1.2
18:32:32 <ski> merijn : ok
18:33:29 <ski> merijn : istr some talk somewhere about attempting to type protocol states sensible -- that would probably be related to what that paper tried to do
18:34:19 <ski> fizruk : "maybe it is possible to turn C program into a coroutine ..." -- yes. or using concurrency as i think i was imagining
18:35:10 <gienah> kiba: I don't understand that error, as I built it with those ghc and network versions
18:35:35 <ski> @hackage ivar-simple
18:35:35 <lambdabot> http://hackage.haskell.org/package/ivar-simple
18:35:36 <ski> @hackage data-ivar
18:35:36 <lambdabot> http://hackage.haskell.org/package/data-ivar
18:35:37 <fizruk> ski: oh, concurrency (forkIO) should be easier to work with
18:35:51 <ski> fizruk : see those ^ for two variants of futures
18:36:03 <kiba> gienah: WHat about cabal?
18:36:10 <kiba> Mine is 1.16.0
18:36:18 <gienah> kiba: what does this say: ghc-pkg list cereal
18:36:31 <gienah> kiba: the Cabal version will not matter
18:36:42 <Hodapp> joelteon: that doesn't really tell what sort of vector graphics you want.
18:36:56 <kiba> /usr/lib/ghc-7.6.3/package.conf.d
18:36:56 <kiba> /home/kiba/.ghc/x86_64-linux-7.6.3/package.conf.d
18:36:56 <kiba>    cereal-0.4.0.0
18:36:56 <kiba>  
18:36:58 <joelteon> Hodapp: to be honest, I'm not sure yet
18:37:09 <Hodapp> joelteon: then what makes you certain vector graphics are what you need?
18:37:11 <joelteon> I'm using gloss right now and it's working pretty well, but I wanted to decouple the game logic from the frontend
18:37:19 <gienah> kiba: well that seems to be the difference, I have: cereal-0.3.5.2
18:37:25 <joelteon> and gloss provides a "play" function that basically manages framerate for you
18:37:44 <gienah> kiba: and hoogle 'Fail' | grep -i serial says: Data.Serialize.Get Fail :: String -> Result r
18:38:53 <ski> fizruk : another variant would be to directly bind a variable to a concurrent operation (instead of delaying the binding of the variable and the computation, as in the two above), and to be able to register actions that should happen when that computation finished (often either succeeding or failing)
18:39:35 <kiba> gienah: googling doesn't seems tot turn up anything related to haskell
18:40:06 <gienah> kiba: you could try adding a constraint, something like: cabal configure hakyll --constraint='cereal < 0.4'
18:40:32 <ski> fizruk : see <http://en.wikipedia.org/wiki/Futures_and_promises> for "Promise pipelining", "Thread-specific futures", "Blocking vs non-blocking semantics", and "I-var" as mentioned at "Related constructs"
18:41:00 <kiba> gienah: is it possible for me to upgrade cereal?
18:41:08 <gienah> or maybe it might work like (I don't use cabal-install): cabal install hakyll --constraint='cereal < 0.4'
18:41:28 <gienah> kiba: I'm suggesting downgrading cereal
18:43:35 <gienah> kiba: or patch socks: https://github.com/vincenthz/hs-socks/pull/5
18:44:07 <kiba> gienah: Thanks. Hakyll successfully installed.
18:44:18 <gienah> kiba: no worries
18:46:29 <fizruk> ski: in http://lpaste.net/93526 what type should `m` have? As far as I can see, neither StablePtr (DSL ()) not StablePtr (TVar (DSL ()) fit.
18:48:29 <fizruk> ski: though, I guess TChan will work
19:06:32 <kayloos> I got a question: How do you pack something in IO when defining a monad instance? Normally you use return for IO, but when defining a new monad instance, which has the return type of IO, return is overwritten and I do not quite get how to do it. Here is a paste that might explain it a bit better: http://lpaste.net/93527
19:10:01 <applicative> kayloos: this is slightly delicate, just a sec
19:10:21 <kayloos> ok
19:11:26 <applicative> kayloos: like this, for example http://lpaste.net/93530
19:12:10 <applicative> you apply x to handle and have an IO thing; so then you have to 'extract' ...
19:12:22 <applicative> then you can pattern match on the Either.
19:12:53 <applicative> note i had to add "return $ ..." to the case for Left err
19:14:33 <kayloos> Ahhhh... thanks. So it assumes that when you're using '<-' (or '>>=') it is IO's instance of '>>=' and not the instance you have just defined?
19:15:16 <applicative> kayloos: yes exactly
19:16:16 <kayloos> Ok, thanks a bunch, was scratching my head on this one for a few hours
19:17:07 <applicative> this type could be rewritten as a 'monad transformer stack' though I'm not sure what the benefit would be.
19:18:41 <applicative> it's newtype DB a = DB {runDB :: ReaderT RethinkDBHandle (EitherT DBError IO) a}
19:18:48 <applicative> or ErrorT
19:20:32 <applicative> or abstracting from IO newtype DB m a = DB {runDB :: ReaderT RethinkDBHandle (ErrorT DBError m) a} deriving (MonadTrans, MonadThisThatTheOther) using 'GeneralizedNewtypeDeriving'
19:20:47 <kayloos> But anything that can be defined with transformers can be defined manually if you write out the bind and return functions right? I wanted to avoid transformers to gain a better understanding of what was really going on
19:20:54 <applicative> yes
19:21:08 <kayloos> ok
19:21:11 <applicative> kayloos: there's everything to be said for that point of view
19:22:39 <applicative> but it does bring out the point that if you abstract from IO in your original formulation and continue as you did with Monad m => Monad (DB m) where ...
19:22:48 <applicative> then you also have your own monad transformer
19:23:44 <applicative> but i agree there is no need to enter into transformer land to express what you are trying to express.
19:24:13 <applicative> certain general functions you might define might then be tested though, without IO, for example
19:24:35 <applicative> test :: DB Identity Int or whatever
19:25:38 <applicative> i mean if you generalized on the IO position in the definition of the DB type
19:28:06 <kayloos> What i wanted to do was have a type that could handle "database computations" -- queries, so that i could: 1. avoid having to manually pass a handle around and 2. use the Either type for the domino error messages.
19:28:45 <kayloos> So the type needs to be called from an IO function since the real type is (IO RethinkDBHandle). But the result of the queries are also (IO Result).
19:29:31 <kayloos> So I think in my example i would return something like IO (Right (IO Result))
19:30:27 <ijp> let me see if I have my understanding of free monads correct: It's just a way to turn a functor into a monad, which will follow all and only the monad laws.
19:30:44 <ijp> and the constructors kinda look like return and join
19:32:53 <ski>   data FreeMonad f a = Return a
19:32:55 <ski>                      | JoinIncl (f (FreeMonad f a))
19:33:49 <ski>   incl :: Functor f => f a -> FreeMonad f a
19:34:06 <ski>   incl = JoinIncl . fmap Return
19:34:09 <fizruk> how do I get the contents of a TChan lazily?
19:36:00 <monochrom> only way I can think of is unsafeInterleaveIO
19:36:15 * Mortenberg_ assumes you've all seen http://xkcd.com/1270/ ?
19:36:19 <monochrom> you should probably give up
19:36:40 <ijp> ski: is that a yes? :)
19:37:48 <heatsink> There's a thousand people here, it's quite likely that someone here hasn't seen it.
19:37:56 <fizruk> monochrom: atomically (readTChan chan) does not work inside of unsafeInterleaveIO, as I can see
19:38:30 <ski> @type GHC.Conc.unsafeIOToSTM . System.IO.Unsafe.unsafeInterleaveIO . GHC.Conc.atomically  -- not sure if this would do the right thing
19:38:31 <lambdabot> GHC.Conc.Sync.STM a -> GHC.Conc.Sync.STM a
19:38:36 <ijp> Mortenberg_: I stopped reading xkcd years ago, but somehow they all still get brought to my attention :)
19:39:09 <ijp> but I actually saw it earlier on #guile
19:39:26 <monochrom> unsafeIOToSTM has restrictions checked during runtime, probably will just fail at runtime for this
19:41:49 <applicative> kayloos: right this is exactly the sort of case where people devise this sort of monad; in the case of ReaderT, there is some feature of the environment that need to be 'read', but you don't want to pass it around explicitly, it will e.g. be introduced by an IO action in main or something
19:42:01 <monochrom> getContent chan = do { x <- atomically (readTChan chan); xs <- unsafeInterleaveIO (getContent chan); return (x:xs) }
19:43:14 <fizruk> oh, thanks! I applied unsafeInterleaveIO to the atomically...
19:44:54 <monochrom> you could, you know, do that too
19:45:12 <saml> @ide
19:45:12 <lambdabot> Maybe you meant: id cide
19:45:20 <saml> what's good ide for haskell? intellij?
19:45:21 <monochrom> slackContent chan = do { x <- unsafeInterleaveIO (atomically (readTChan chan)); xs <- unsafeInterleaveIO (slackContent chan); return (x:xs) }
19:45:37 <saml> https://github.com/NICTA/course  i'm trying to do this and it has intellij project file
19:47:16 <kayloos> applicative: It's actually working quite nicely now, printing the result of each interaction with the database. What confused me was when '>>=' doesn't work like normal functions when declaring it (ie. a normal function would call itself recursively)
19:48:06 <ski> ijp : aye
19:49:29 <heatsink> It's nifty how I can write parallel code in Haskell that works the first time it runs.
19:49:30 <kayloos> But I think I understand now: when inside the lambda scope, it looks to its 'scoped type', for example: handle = DB $ \h -> return $ Right handle, return in that instance will be IO's return
19:49:36 <ski> monochrom : looks odd, make even ?
19:50:30 <ijp> ski: ah good, I read a few descriptions, and I finally got to that point and thought "is that it?"
19:51:25 <ski> ijp : the monad laws hold basically because nesting forms a monoid
19:52:37 <fizruk> ski: so far I have this implementation http://lpaste.net/93531
19:52:48 * ski . o O ( <http://en.wikipedia.org/wiki/Operad_theory> )
19:53:08 <NemesisD> anyone have any opinions on how async compares with Control.Monad.Par.IO?
19:53:15 <fizruk> ski: it works except for the unsafePerformIO part
19:53:49 <NemesisD> it seems like they both attempt to solve the problem of building dependency graphs of io computations and resolving them in parallel
19:53:59 <fizruk> ski: how to force unsafePerformIO to be computed?
19:56:12 <ski> force the result
20:00:46 <monochrom> ski: http://lpaste.net/93533
20:05:49 <ski> ok, `chaosContent = slackContent'
20:06:10 <monochrom> "chaos" is more accurate :)
20:06:29 <ski> though i was referring to `getContent' by the even odd
20:06:42 <monochrom> how is that even odd?
20:06:48 <ski> monochrom : reminds me of a certaing function definable by `unsafeInterleaveST' :)
20:08:00 <ski>   evenGetContent chan = unsafeInterleaveIO (liftM2 (:) (atomically (readTChan chan)) (evenGetContent chan))
20:08:27 <ski>   oddGetContent chan = liftM2 (:) (atomically (readTChan chan)) (unsafeInterleaveIO (oddGetContent chan))
20:09:10 <ski> (in the sense of the Wadler paper)
20:09:44 <monochrom> oh, "without even being odd"
20:10:48 <monochrom> I guess getContents is even
20:11:18 <monochrom> but I prefer chaos :)
20:11:53 <ski> @where+ even-odd "How to add laziness to a strict language, without even being odd" by Philip Wadler,Walid Taha,David MacQueen in 1998-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#lazyinstrict>
20:11:53 <lambdabot> Done.
20:23:16 <fizruk> ski: I got that to work! Thanks a lot for you help! =)
20:24:57 <ski> fizruk : ok ?
20:26:19 <dolio> roconnor_: Ah. I was thinking something like that earlier today.
20:27:11 <heath> https://gist.github.com/heath/63488f37d1ebd07f78c1
20:29:47 <heath> ignore
20:46:44 <heath> https://gist.github.com/heath/ee94a8499333b169d769
20:47:38 <heath> let countChars input = toList $ fromListWith (+) [(c, 1) | c <- input]
20:47:43 <heath> :t countChars
20:47:44 <lambdabot> Not in scope: `countChars'
20:47:54 <heath> lambdabot: let countChars input = toList $ fromListWith (+) [(c, 1) | c <- input]
20:47:57 <heath> :t countChars
20:47:58 <lambdabot> Not in scope: `countChars'
20:48:39 <acomar> Hey all, I broke the raw opencv bindings out into their own package: https://github.com/arjuncomar/opencv-raw
20:48:57 <acomar> Those are just the c wrappers around the C++ OpenCV API, and Haskell bindings to them
20:48:58 <pavonia> heath: toList will give you a list of pairs
20:50:16 <epta> Could function that collapse all nested `Maybe (Maybe (Maybe (... x)...)` to `x` possibly exists?
20:51:03 <dwcook> epta, I believe you could at least do it if you fixed x
20:51:09 <dwcook> Using a typeclass
20:51:32 <epta> Why do you mean by `fixed x`?
20:52:00 <dwcook> Instead of a general x, some type you've chosen
20:52:18 <epta> Could function that collapse all nested `Maybe (Maybe (Maybe (... Int)...)` to `Int` possibly exists?
20:52:23 <epta> Not much easier :(
20:55:26 <pavonia> epta: Why do you need that for arbitrarily deep nested Maybes?
20:56:20 <epta> In not from the real world, just wanna generalize `Maybe (Maybe x) -> Maybe x` question.
20:56:31 <dwcook> epta, by the way, if you want to come up with some x rather than a Maybe x, you are going to have a partial function
20:57:05 <dwcook> (More partial than usual, anyhow)
20:57:06 <epta> Oh, sorry, I mean `Maybe Int` in the end, right
20:57:23 <dwcook> Okay, well in that case, you could make a typeclass and two instances of it
20:57:24 <shachaf> epta: Maybe you're thinking of free monads and retract?
20:57:44 <epta> shachaf: maybe, just don't realized it yet
20:57:46 <shachaf> data Free f a = Pure a | Free (f (Free f a))
20:57:54 <shachaf> retract :: Monad m => Free m a -> m a
20:59:49 <heath> expected type: String -> String, actual type: [Char] -> [(Char, a0)]
20:59:55 <heath> i could use some help in debugging this
21:00:13 <epta> heath: right
21:01:22 <dwcook> Hmm, my idea is unsound, actually
21:02:06 <dwcook> Because it would require you to write instances that could overlap
21:02:12 <pavonia> heath: Look at the result type of toList and the result type of the function expected by interact
21:02:35 <heath> aaah
21:03:37 <heath> [(Char,  a0)] /= String
21:04:27 <epta> shachaf: maybe it is usable somehow, but I don't quite got the idea :(
21:05:33 <shachaf> epta: It's a useful idea so it's probably worth figuring out. Not that my explanation was sufficient for that.
21:07:13 <shachaf> epta: The first question is how to represent Maybe (Maybe (Maybe (... x)....))
21:07:20 <epta> Yep
21:07:40 <shachaf> Er, without one of those .s.
21:08:08 <epta> In the defenitions of maybe libraries I saw that people end with 15
21:08:16 <epta> of many*
21:08:25 <shachaf> What?
21:08:33 <epta> For tuple cases or smth like that
21:08:49 <shachaf> What?
21:09:17 <epta> Nevermind
21:09:25 <shachaf> Anyway, let's say x=Int like you said. Possible types that you want to represent are: Int, Maybe Int, Maybe (Maybe Int), ...
21:09:43 <epta> Yep
21:10:00 <shachaf> This is sounding like a recursive type. In particular, we can define data Foo = End Int | More (Maybe Foo)
21:11:08 <shachaf> Do you see how that works?
21:11:19 <epta> Yep
21:11:37 <shachaf> OK. Free is a generalization of that, parameterizing on Int and Maybe.
21:11:48 <shachaf> data Free f a = End a | More (f (Free f a))
21:21:52 <epta> shachaf: ok, in the other words, Maybe nesting could be represented with Free and collapsed with retract, pretty easy. But if `Maybe (Maybe (Maybe (... x)...)` means all possible cases for nested Maybe types, not my own wrapper type. Could some generic function that collapses (Maybe (Maybe a)) to (Maybe a) and so on for all possible number of nesting exist?
21:23:57 <Hrumph> hi
21:27:08 <fizruk> epta: iter/iterM?
21:28:31 <pavonia> Maybe there's a way using closed type families
21:54:05 <monochrom> https://twitter.com/runarorama/status/383648832174583808/photo/1/large  "monad/comonad annihilation"
21:54:37 <monochrom> (that's Phil Wadler and edwardk together. monad/comonad annihilation!)
21:55:07 <djahandarie> Staring copumpkin in the background!
21:57:39 <shachaf> He's not staring!
21:59:34 <monochrom> I am staring copumpkin in the background. he is starring in the picture. :)
22:23:42 <krakrjak> has anyone had luck getting ghc to compile in the last week or so?
22:25:30 <shachaf> Maybe people in #ghc would know? I've heard something about some problems lately, I think.
22:27:15 <krakrjak> Yeah I've been having a tough time.  The bugs keep on changing.  Now it's that Either isn't building due to a kindness issue with Typeable.
22:27:26 <krakrjak> Thanks shachaf I'll hop on #ghc
22:28:37 <shachaf> Typeable is not kind to parametricity, that's for sure.
22:29:04 <krakrjak> Seems it.
22:45:04 <texnoti> Hello! Introducing myself, just started with haskell. QlikView developer.
22:45:48 <apples> hey, hope you're liking things so far
22:46:53 <texnoti> I do, hence my presens here. Know from experience that there will be questions :-)
22:47:50 <texnoti> And accoring to what I read this is the place for answers.
22:48:14 <apples> yup, hopefully
22:50:09 <Iceland_jack> hey texnoti, welcome!
23:01:28 <krakrjak> welcome texnoti! ask away, this place has helped me tremendously in the past.
23:01:36 <krakrjak> and continues to be a great resource.
23:14:52 <sclv> @remember BetaZiliani We escape from monads in the same way that we escape from a building on fire: we run.
23:14:52 <lambdabot> Okay.
23:17:13 <ethercrow> If you're interested, please try out master branch of https://github.com/yi-editor/yi We are about to release 0.7
23:18:12 <ethercrow> Major change is new vim emulation called vim2 (yes, not creative enough)
23:21:27 <krakrjak> a better vim mode...  thanks!
23:21:52 <scshunt> everything should be vim modes
23:34:17 <pdxleif> I use ghcmod-vim to get some feedback from ghc while editing in vim - does yi have something along those lines?
23:34:50 <pdxleif> It'd be cool to get something like the agda interactive mode in a vim-like environment, maybe for haskell and idris, too...
23:35:56 <ethercrow> pdxleif: not yet, please create a ticket
23:37:10 <ethercrow> hopefully someone will get motivated or annoyed enough and will implement it
23:37:19 <ethercrow> or it could be a GSoC project
23:48:17 <gienah> ethercrow: I wonder if gtk would be a better name for the pango flag
23:50:30 <ethercrow> gienah: that's historical accident
23:50:46 <ethercrow> there was already a frontend called gtk
23:51:35 <ethercrow> anyway, pango doesn't have an active maintainer now
23:52:25 <gienah> ethercrow: ok, thanks, I kicked off some builds to try it out
23:52:30 <ethercrow> and different frontends reimplement lots of code that should be shared
23:52:45 <ethercrow> for example, wrapping logic is different in vty and pango
23:57:38 <gienah> ethercrow: It built fine with ghc 7.6.3 on Gentoo, and runs in simple tests with the vty frontend
23:58:47 <ethercrow> good, thanks
23:59:40 <ethercrow> now you could try yi --as=vim2 and count number of seconds until you encounter some unimplemented vim feature
