00:08:11 <thoughtpolice> shachaf: fair enough!
00:29:12 * hackagebot esqueleto 1.3.4 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4 (FelipeLessa)
01:12:00 <TIHan> Is it ok that I still don't understand monads yet? It has been a few months still..
01:13:02 <Kaini> TIHan, well, can you use them? That should be enough :)
01:14:00 <TIHan> Barely. Still new to Haskell as a language. I've been in F# land for a while now, which has monads through computed expressions... though I have no idea what I'm doing.
01:14:47 <TIHan> F# doesn't have an IO monad - still wondering how to create one through its computed expression
01:15:10 <TIHan> There are examples, but I want to understand how it all works rather than just using them.
01:15:18 <dmj`> TIHan: F# doesn't need a monad to do IO, it is an impure language
01:15:49 <shachaf> dmj`: That doesn't exacly make sense to say.
01:15:55 <TIHan> dmj`: It doesn't need it; but if I want to discipline myself, and make pure functions in F#.
01:15:59 <shachaf> If F# did I/O the way Haskell did, then it would need a type like Haskell uses.
01:16:03 <shachaf> It doesn't, so it doesn't.
01:16:23 <shachaf> Haskell doesn't "need a monad" either.
01:16:35 <TIHan> I'm aware there is unsafeIO in haskell?
01:16:47 <prophile> we don't talk about unsafePerformIO
01:16:59 <prophile> it's a massive violation of the type system
01:17:00 <shachaf> TIHan: That's for experts who understand how IO works normally. Forget about it.
01:17:22 <Kaini> TIHan, I do not know F#, but in Haskell I finally understood Monads after writing code that had to deal with excessive amounts of Maybe. (Getting information out of XML with "xml") But you could as well try one of the 100 articles about monads :)
01:17:25 <TIHan> Well, that's fine. I wouldn't want to talk about unsafeIO in haskell either. :)
01:17:30 <shachaf> prophile: I'd say that it doesn't have anything to do with the type system. But whatever.
01:18:17 <prophile> shachaf: my thinking is that IO a -> a should be uninhabited (aside from const undefined, naturally)
01:18:21 <TIHan> I've been reading a ton of articles on monads. I'm almost there; but I think I'm just looking for confirmation that it is still ok at point for me not understanding them fully.
01:18:28 <prophile> for any definition of IO
01:18:40 <shachaf> How about this definition: newtype IO a = IO a
01:19:09 <prophile> hm
01:19:21 <warp> TIHan: try implementing a monad, that should help a bit in understanding them.
01:19:21 <prophile> anything IO implementation that can handle IORefs then
01:19:28 <TIHan> What I know is that the IO monad is essentially a type around something that indicates that a function is performing a side effect? So, it's like IO<string> instead of string right?
01:19:59 <shachaf> No functions involved.
01:20:01 <shachaf> @quote /bin/ls
01:20:01 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:20:18 <prophile> that's a nice analogy
01:20:37 <TIHan> hmm, that makes some good sense. :)
01:21:22 <shachaf> Also, for the most part there's no need to say "the IO monad".
01:21:22 <dmj`> TIHan: If a pure function is defined as a function that doesn't permit IO and preserves referential transparency, then F# can write pure functions w/o monads.
01:21:30 <shachaf> It's a type that happens to be a monad.
01:21:52 <TIHan> dmj
01:21:59 <TIHan> dmj`: yes
01:22:40 <TIHan> So, sorry for regurgitating - A monad is a type safe way of handling side effects? *please don't shoot me :( *
01:22:51 <shachaf> No.
01:23:09 <shachaf> Is your goal to understand IO, or to understand "monads"?
01:23:34 <TIHan> I may be getting confused. I want to understand "monads" in its entirety.
01:23:48 <TIHan> Without reading category theory..
01:23:56 <shachaf> OK. "monad" is the name of an abstract API that many types implement.
01:24:19 <shachaf> IO happens to implement it, but IO is very unusual as monads go.
01:24:57 <shachaf> Have you read the FAQ?
01:24:59 <shachaf> @where faq
01:24:59 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:25:41 <TIHan> Not the whole thing, but portions
01:25:59 <TIHan> I assume the monad section is where you want me to go :)
01:26:32 <levi> Well, monads *are* a way to manage effects. That's not the definition of a monad, though, it's just a use for them.
01:26:59 <shachaf> Well, either the monad section or the IO section. It depends on your goal.
01:27:36 <arbn> TIHan: I encourage you to think of Monad, or any other type class, as the operations that define it. It's an abstraction, so you should think of it abstractly, rather than trying to conceptualize it in terms of a particular example.
01:27:46 <mauke> class Monad m where { return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b }
01:27:53 <shachaf> 8.3 would be a good section to read.
01:27:54 <TIHan> OK. That is clearing things up a bit.
01:28:24 <TIHan> This is what confused me in F# computed expressions - now it makes sense when you call it an abstract API
01:28:59 <TIHan> And that it isn't used for one specific purpose.
01:29:25 <ReinH> edwardk: reading your catamorphisms post
01:29:29 <mauke> TIHan: do you know monoids?
01:29:32 <ReinH> I need to learn more algebra
01:29:44 <edwardk> ReinH: i've almost finished the automata post
01:29:50 <ReinH> edwardk: nice
01:29:52 <arbn> The fact that it's so abstract basically why it has a silly, obscure name. It's hard to name things that are really generally applicable to lots of different structures and use-cases.
01:29:53 <TIHan> mauke: probably just as much as monads.
01:30:05 <edwardk> ReinH: decided to let @djinn derive 'step'
01:30:10 <mauke> ok, monoids are also an abstract structure but much simpler
01:30:11 <arbn> is basically why*
01:30:16 <ReinH> edwardk: that's what you did last time iirc
01:30:16 <edwardk> ReinH: so the article goes through how to use djinn to work it out
01:30:18 <mauke> monoids are everywhere
01:30:19 <edwardk> yep
01:30:24 <levi> Managing the effects in the formulations of denotional semantics for imperative programming languages was the motivating purpose for introducing monads to programming language theory, though.
01:30:34 <TIHan> mauke: so, monoids make up monads? or are they separate?
01:30:41 <mauke> TIHan: separate
01:30:48 <arbn> levi: Historical coincidence? :P
01:30:50 <mauke> TIHan: there's a connection but it involves abstract nonsense
01:30:50 <TIHan> ok :)
01:30:57 <levi> arbn: Not at all.
01:31:05 <shachaf> Hey, it's reasonably concrete nonsense!
01:31:13 <ReinH> hah
01:31:38 <levi> The connection happens to be related to *why* they are useful for managing effects.
01:31:51 <mauke> class Monoid a where { mempty :: a; mappend :: a -> a -> a }
01:32:10 <mauke> instance Monoid [a] where { mempty = []; mappend = (++) }
01:32:12 <TIHan> "it's definitely not adding magical new capabilities to the language"
01:32:25 <TIHan> That makes me feel more sane.
01:32:52 <mauke> we'll fix that later
01:33:12 <ReinH> TIHan: these things are defined in terms of Haskell, not the other way around.
01:34:19 <TIHan> Right. And that makes sense.
01:35:08 <mauke> the class Monad is defined in a normal library
01:35:20 <mauke> the IO implementation of Monad is magic but that's because IO is magic, not Monad
01:35:34 <TIHan> At first it's confusing as you see "do" - but is only syntax sugar.
01:35:55 <mauke> > do { x <- [1,2,3]; y <- "ab"; return (x, y) }
01:35:57 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
01:36:01 <TIHan> I guess that's a good way to put it.
01:36:05 <levi> The magical new capability for Haskell was when type classes were extended to support * -> * kinds.
01:36:21 <mauke> "constructor classes"
01:36:47 <levi> Yeah, I couldn't remember what gofer called them before they were folded back into Haskell type classes.
01:37:23 <shachaf> [a] is a very special monoid.
01:37:52 <mauke> apart from being the quintessential monoid?
01:38:10 <levi> That made it so you could make Monad a type class and they were suddenly way less awkward to use.
01:38:10 <shachaf> Does "quintessential" mean "free"?
01:39:41 <mauke> shachaf: what does "free" mean exactly?
01:42:26 <shachaf> It roughly means that it does the least possible work required to satisfy the laws.
01:42:37 <TIHan> "IO actions are just descriptions of IO which could be performed."
01:42:54 <ReinH> mauke: http://en.wikipedia.org/wiki/Universal_property
01:42:56 <shachaf> I guess you said "exactly", not roughly.
01:43:11 <levi> It means that no more laws/axioms hold for it than are defined by the structure it is an example of.
01:43:14 <mauke> [] essentially right-associates everything
01:43:25 <shachaf> It means that it's left adjoint to a forgetful functor (OK, "forgetful functor" isn't really well-defined).
01:43:49 <shachaf> Well, the important part is that there's just one possible association.
01:44:05 <ReinH> shachaf: that's what a free *functor* is...
01:44:36 <mauke> levi: I'm missing something because [] supports length
01:44:52 <shachaf> ReinH: Yes. The free functor maps a set to the free monoid of that set.
01:44:55 <edwardk> ReinH: i posted https://www.fpcomplete.com/user/edwardk/cellular-automata/part-3
01:45:16 <shachaf> mauke: [] also gives you the empty list, unlike NonEmpty (which is the free semigroup).
01:45:20 <mikeplus64> @hackage free
01:45:20 <lambdabot> http://hackage.haskell.org/package/free
01:45:21 <ReinH> edwardk: "moves like jagger"?
01:45:26 <ReinH> edwardk: :p
01:45:32 <edwardk> ReinH: needed something that included 'move'
01:45:33 <edwardk> =)
01:45:33 <mauke> length (mappend a b) = length a + length b
01:45:38 <ReinH> edwardk: :p
01:45:38 <edwardk> and i was slap-happy
01:45:42 <mauke> that's not something other monoids do
01:45:53 <levi> The free functor builds the free object from its carrier set.
01:46:15 <levi> oh, I am lae.
01:46:16 <levi> late
01:46:33 <TIHan> Ok, that is definitely helping. thank you all so far!
01:46:54 <ReinH> mauke: it doesn't mean that the object *only* has those laws.
01:47:24 <shachaf> mauke: Looking at types like this also be relevant: newtype FreeMonoid a = FM { runFM :: forall r. Monoid r => (a -> r) -> r }
01:47:30 <shachaf> Replace Monoid with Semigroup, Group, etc.
01:49:33 <levi> mauke: You can do more things with the free object because it retains all the information necessary to make a homomorphism with the other objects.
01:50:25 <wagle> whyy can i never remember how to write a read-print loop in haskell? </rhetorical-question>
01:50:34 <mauke> wagle: interact
01:51:37 <edwardk> :t interact
01:51:38 <lambdabot> (String -> String) -> IO ()
01:52:06 <wagle> yeah, i can do the rest, thanks
01:52:22 <edwardk> if you need something more complicated i usually base it on an example from haskelline
01:52:49 <wagle> thanks
01:52:51 <edwardk> https://github.com/ermine-language/ermine/blob/master/repl/Main.hs#L45
01:53:23 <edwardk> you can rip out all the lens and configuration options from that and get something more like a real repl loop out of it
01:54:12 <mauke> shachaf: if I'm reading this right then FreeMonoid stores 0 or more a's
01:54:32 <mauke> because of the foralls and the structure of Monoid
01:55:04 <shachaf> Right. It's isomorphic to [] (well, other than behaving differently with infinite structures, but we generally ignore that sort of thing).
01:55:53 <shachaf> The function can only combine things in the ways allowed by the Monoid type class, and the associativity law flattens out how it combines them.
01:56:16 <mauke> oh, and I can just get the elements out by passing it (: [])
01:56:28 <shachaf> You can pick whichever monoid you want for r -- but since it doesn't know anything about it, it has to use only the Monoid API.
01:56:33 <shachaf> Right.
01:57:58 <shachaf> Let me see if I can translate the Wikipedia definition of free object to this context.
01:58:05 <ReinH> mauke: you mentioned that other monoids don't have length, but that's not quite true.
01:58:45 <shachaf> The idea of a monoid homomorphism -- i.e. a function f between two monoids such that f mempty == mempty, f x <> f y = f (x <> y) -- is important here.
01:59:42 <ReinH> shachaf: the monoid of the natural numbers (including zero) under addition consists of all sequences like "1", "1+1", "1+1+1", and so on. The *length* of this sequence is the same as its evaluation result.
01:59:46 <ReinH> er
01:59:49 <ReinH> mauke: ^
01:59:53 <shachaf> ReinH: Thaat monoid is free.
01:59:57 <shachaf> It's [()]
02:00:05 <ReinH> shachaf: right, that's my point
02:00:06 <shachaf> s/a//
02:00:17 <ReinH> mauke was saying that you don't get length for free
02:00:33 <ReinH> but you do
02:00:45 <ReinH> by isomorphism
02:00:47 <mauke> hah, should've spotted the homomorphic structure of length
02:03:10 <shachaf> So say you have some type X. And you have some monoid M, and a function inj : X -> M.
02:03:58 <levi> Initial algebras are also relevant to the concept of free objects.
02:04:35 <shachaf> We say that M is a free monoid over X if for any other monoid N, and any function f : X -> N, there exists a unique monoid homomorphism f' : M -> N such that f = f' . inj
02:05:18 <arkeet> in other wirds, (. inj) is a bijection between functions X -> N and monoid homomorphisms M -> N.
02:05:21 <shachaf> (s/other // -- it could be the same monoid.)
02:05:23 <arkeet> words.
02:06:10 <mauke> berd is the werd
02:06:40 <mauke> that sounds suspiciously like a commutative diagram thing
02:06:51 <shachaf> Yep.
02:06:54 <shachaf> https://en.wikipedia.org/wiki/Free_object
02:07:35 <shachaf> Well, it sounds suspiciously like a universal property thing.
02:07:39 <arkeet> well, it is.
02:07:46 <shachaf> Right, that's why.
02:08:18 <arkeet> M is the initial (monoid over X).
02:08:24 <arkeet> er, under.
02:08:55 <ReinH> edwardk: Not in scope: type constructor or class `Topology'
02:08:59 <edwardk> fixed
02:09:00 <edwardk> try again
02:09:01 <ReinH> kk
02:09:17 <mauke> I'm getting tangled up again
02:09:20 <shachaf> (M,inj) and (N,f) are the same kind of thing. (M,inj) is special because there's a unique homomorphism from it to any (N,f) you choose.
02:09:32 <ReinH> edwardk: it's so pretty
02:09:35 <mauke> let's say X = ()
02:09:48 <arkeet> fact: the free monoid on X is [X]
02:09:49 <mauke> and inj = const m
02:09:53 <edwardk> ReinH: hah. it's basically your image, so it should be =)
02:10:07 <arkeet> (with (:[]) as inj)
02:10:10 <edwardk> did the explanation in terms of monoid actions make more sense?
02:10:12 <shachaf> inj isn't const m, it's (:[])
02:10:24 <ReinH> edwardk: :p
02:10:32 <mauke> shachaf: why?
02:10:40 <shachaf> It's part of the free monoid. I guess I didn't specify that.
02:10:40 <ReinH> edwardk: yeah, I need to read that paper now :)
02:10:40 <edwardk> i wanted to have a slightly more principled explanation than just throwing out the world 'topology'
02:10:41 <arkeet> because that's the thing that gives you a free monoid.
02:10:44 <ReinH> I <3 pearls
02:10:53 <edwardk> i have <3 pearls too
02:11:00 <ReinH> er.
02:11:02 <arkeet> it's the pair (M, inj) that we call a free monoid.
02:11:33 <mauke> all you said I have was some monoid M and some function X -> M
02:11:46 <shachaf> Yep. I didn't specify the whole thing.
02:11:58 <shachaf> M is "the free monoid over X with respect to inj".
02:12:08 <arkeet> well, "(M,inj) is the free monoid on X".
02:12:35 <arkeet> where inj: X -> M.
02:12:48 <arkeet> and inj is a function.
02:12:53 <arkeet> because given any other (N, f: X -> N), where f is a function
02:13:06 <arkeet> there's a unique monoid homomorphism f': M -> N such that f' . inj = f
02:13:23 <arkeet> (in other words, (M,inj) is the initial object in the category of such pairs.)
02:14:45 <arkeet> exercise:
02:14:56 <arkeet> prove that M = [X], inj = (:[]) : X -> [X] satisfies this property.
02:15:42 <shachaf> You can start with X=(), M=Nat, inj () = 1
02:15:51 <shachaf> (Or not.)
02:16:22 <arkeet> so given a monoid N, you want a way to turn functions X -> N into monoid homomorphisms [X] -> N.
02:17:04 <arkeet> (such that it's the unique way to fill in that triangle.)
02:18:17 <arkeet> (if you also prove it for X and (Nat, inj () = 1) then you get that Nat ~ [()] for free, since free objects (as with anything defined by a universal property) are unique)
02:18:39 <shachaf> (up to isomorphism)
02:18:52 <arkeet> (up to unique isomorphism)
02:21:45 <shachaf> I think this is one of the more complicated sorts of simple universal properties.
02:27:52 <ReinH> "The rest of the paper relies on two simplifying assumptions... the foating-point type Double is a well-behaved representation of the real numbers R
02:27:57 <ReinH> let me stop you right there...
02:33:52 <wagle> i have 4 Integers that I want to do pairwise double division on..  do I haveta do 4 fromIntegrals?
02:34:15 * hackagebot haskdeep 0.2.0.0 - Computes and audits file hashes.  http://hackage.haskell.org/package/haskdeep-0.2.0.0 (MauroTaraborelli)
02:34:35 <mauke> I've made an unsettling discovery: neutral elements aren't unique
02:34:59 <mauke> also, p <> x = y and q <> x = y does not imply p = q
02:35:29 <quchen> mauke: Better write a paper and win a Field's medal on that then?
02:35:29 <edwardk> wagle: or you can just write a combinator to help
02:35:32 <shachaf> Neutral elements aren't unique?
02:36:01 <edwardk> @let (/.) :: Int -> Int -> Double; x /. y = fromIntegral x / fromIntegral y
02:36:02 <lambdabot>  Defined.
02:36:07 <edwardk> > 1 / 2
02:36:08 <lambdabot>   0.5
02:36:10 <edwardk> > 1 /. 2
02:36:17 <lambdabot>   mueval-core: Time limit exceeded
02:36:21 <edwardk> > 1 /. 2
02:36:26 <lambdabot>   0.5
02:36:35 <mauke> shachaf: take an element x and assume p <> x = x. what can we say about p?
02:36:57 <shachaf> This is in a monoid?
02:37:00 <mauke> yes
02:37:28 <mauke> I've gotten as far as mconcat (replicate n p) <> x = x for all n >= 0
02:37:50 <shachaf> Oh, you mean neutral for a specific x, not for the entire monoid.
02:38:48 <wagle> thanks, thought of that, even, though I like your name for it
02:39:10 <edwardk> wagle: i think i stole it from haasn
02:39:14 <shachaf> mauke: Or, wait, do you?
02:39:33 <mauke> shachaf: yes
02:39:38 <shachaf> mauke: Are you saying that it's impossible that p <> p = q, and q <> x /= x, but p <> x = x?
02:40:32 <mauke> shachaf: yes
02:40:59 <shachaf> Oh, fair enough.
02:41:29 <edwardk> mauke: what gives you the idempotence of p?
02:41:54 <shachaf> edwardk: p <> (p <> x) = p <> x = x
02:42:02 <edwardk> ok
02:42:03 <shachaf> So p <> p might not be p, but it's a left identity of x.
02:42:16 <edwardk> sure
02:42:34 <mauke> let x = repeat 0 and p = [0]
02:46:22 <shachaf> That's a nice example.
02:47:46 <wagle> if i want arrays (O(1) access) what do the cool kids use these days?  what if I want O(1) update too?
02:48:35 <quchen> wagle: Vector or Array
02:48:57 <quchen> O(1) update is a little harder though, you'll have to look into the ST monad for that
02:49:28 <quchen> And even then you'll probably have to make at least one copy of the vector at some point.
02:50:00 <wagle> ok..  the Array documentation I found was for h98, hence my cool kids slant
02:50:19 <wagle> thanks, will look into those
02:50:25 <arkeet> Vector is nicer.
02:50:35 <quchen> Yeah I prefer Vector's API as well
02:51:04 <wagle> trying to implement algorithms for which N is large..
02:51:17 <shachaf> mauke: On the other hand in groups this isn't true.
02:51:25 <levi> mauke: I'm not sure what you're getting at.
02:51:32 <mauke> shachaf: duh, everything is easy with inverse elements :-)
02:51:48 <shachaf> I thought it was monoids that were easy. :-(
02:52:06 <quchen> shachaf: He said "is", not "iss".
02:52:08 <mauke> levi: I was thinking about how to prove uniqueness and then I noticed that I can't get 'p = q' from 'p <> x = y' and 'q <> x = y'
02:52:48 <arkeet> mauke: it's much easier than that.
02:53:13 <levi> mauke: Are you considering that it must be both a left- and right-identity?
02:53:22 <arkeet> mauke: still trying to prove the free monoid thing?
02:53:49 <mauke> arkeet: yes, but not even the general case
02:54:01 <arkeet> ok, well it should be fairly easy.
02:54:09 <arkeet> well, it shouldn't involve any tricks.
02:54:15 <mauke> I was just thinking about the specific example of M = [X], N = [X], f = const n
02:54:16 <arkeet> which part are you trying to prove exactly?
02:54:31 <wagle> quchen: Vector looks like what I want, thanks
02:54:32 <arkeet> I think it's easier to do for N and f arbitrary.
02:54:37 <mauke> and whether homomorphy was sufficient to nail down the rest of f'
02:54:56 <arkeet> idea:
02:55:03 <arkeet> f tells you what to do on one-element lists.
02:55:15 <arkeet> everything in [X] can be built from one-element lists.
02:56:02 <mauke> no, not []
02:56:17 <arkeet> that can be built from zero one-element lists.
02:56:52 <arkeet> (although any monoid homomorphism must satisfy f' mempty = mempty, in any case.)
02:57:25 <shachaf> "built" means "using mempty and <>"
02:57:28 <shachaf> (And f.)
02:57:35 <arkeet> (no, not f here.)
02:57:38 <mauke> shachaf: in how many steps?
02:57:51 <levi> Finitely many
02:58:01 <arkeet> let's not worry about infinite structures =(
02:58:03 <mauke> ok, so this is the other [X]
02:58:07 <wagle> is there a version of foldl that gives access to the total so far, or do I fake it / roll my own?
02:58:11 <arkeet> wagle: scanl?
02:58:28 <shachaf> If you remember the "Monoid r => (a -> r) -> r" thing -- (a -> r) is f, and Monoid r => tells you what operations you can use.
02:58:54 <arkeet> > scanl (+) 0 [1..10]
02:58:55 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
03:03:26 <wagle> arkeet: close/interesting, but not quite I think..  might end up with it after thinking hard about it though
03:03:54 <arkeet> wagle: well, not quite sure what else you were looking for.
03:04:19 <wagle> yeah, i think my question was confused, give me 15 minutes
03:05:54 <Hafydd> @djinn Monoid r => (a -> r) -> r
03:05:54 <lambdabot> Error: Class not found: Monoid
03:06:22 <shachaf> Error: Tried to use classes with @djinn.
03:06:56 <Hafydd> @djinn Enum a => a
03:06:56 <lambdabot> Error: Class not found: Enum
03:07:24 <Hafydd> I see.
03:07:37 <Hafydd> Well, shachaf, maybe you can be my Djinn.
03:07:41 <shachaf> But it's pointless. Even if it knew the classes, it would be pointless.
03:07:50 <shachaf> (No @pl jokes, please.)
03:08:10 <Hafydd> Or, actually...
03:08:15 <Hafydd> @hoogle  Monoid r => (a -> r) -> r
03:08:15 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
03:08:15 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:08:15 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:08:47 <shachaf> Also, you can try these things out in /msg. :-)
03:08:55 <Hafydd> :---)
03:10:08 <Hafydd> Alright; is there a value of Monoid r => (a -> r) -> r apart from const mempty?
03:10:38 <shachaf> Depends on a.
03:10:44 <Hafydd> forall a.
03:10:58 <shachaf> No.
03:11:42 <shachaf> There are as many values of that type as there are of (forall a. [a]).
03:11:47 <rtb> hi there :) -- small noob question (I hope)
03:12:05 <Hafydd> Ah, yes.
03:12:26 <rtb> why does "map read ["3","1"] :: Int" no compute?
03:12:41 <rtb> when red "3" :: Int does
03:12:41 <tikhon> because the result of map has to be a list
03:12:43 <shachaf> rtb: Because map ... ... is always a list.
03:12:46 <Hafydd> > map read ["3", "1"] :: [Int]
03:12:47 <lambdabot>   [3,1]
03:13:37 <rtb> yes of course I want a list..
03:14:47 <shachaf> When you say (x :: t) that means that x has type t
03:14:54 <shachaf> But "Int" is not the type of a list.
03:15:04 <rtb> ok got it.. just overseen you're correct type decl @ hafydd
03:15:09 <rtb> thx all :)
03:16:06 <shachaf> I think sometimes people are looking for type application a la Core.
03:22:20 <Cale> It would be nice sometimes
03:22:33 <shachaf> Yes.
03:24:14 <Hafydd> What is Core?
03:24:45 <shachaf> @google What is Core? #haskell
03:24:46 <lambdabot> http://www.reddit.com/r/haskell/comments/1h5ml0/ghc_core_by_example_episode_1_hello_core/
03:24:46 <lambdabot> Title: GHC Core by example, episode 1 - Hello Core! : haskell
03:24:56 <teneen> I would like to read a file and append line numbers to each line in the file. I want to write to the same file without using a temporary file. Which functions should I use?
03:25:23 <Hafydd> Ah.
03:25:29 <levi> mauke: foldr (<>) mempty
03:25:55 <mauke> mconcat
03:26:32 <mauke> teneen: you'd have to read the whole file into memory first
03:27:02 <teneen> mauke: The file is huge
03:27:12 <mauke> then you better have huge memory
03:27:41 <teneen> mauke: Are you sure what I want is not possible?
03:28:00 <mauke> just write to a different file
03:28:39 <albel727> > To see the GHC Core code generated for the above Haskell code, simply run the following:
03:28:41 <lambdabot>   <hint>:1:62: parse error on input `,'
03:28:47 <albel727> > several lines worth of command
03:28:48 <lambdabot>   <hint>:1:21: parse error on input `of'
03:29:16 <mauke> teneen: you could do it in constant memory by repeatedly rewriting the file using seek/tell
03:29:16 <Hafydd> #haskell.lhs
03:29:26 <mauke> but it would be slow as fuck
03:29:40 <mauke> well, a single pass would be slow as fuck
03:29:48 <teneen> mauke: why slow?
03:29:52 <mauke> in this case we also have to whole O(n^2) problem
03:39:57 <shachaf> mauke: Hmm, see also 5.3 in http://pine.cs.yale.edu/pinewiki/AlgebraicStructures
03:43:13 <arkeet> :t foldMap
03:43:14 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:44:51 <shachaf> mauke: Also, FreeFoo is a monad.
03:46:46 <arkeet> :t foldr
03:46:48 <lambdabot> (a -> b -> b) -> b -> [a] -> b
03:46:50 <arkeet> :<
04:03:49 <mauke> shachaf: so I've read the beginning of that and it sounds like syntax
04:04:24 <mauke> data FreeMonoid = Mempty | Mappend FreeMonoid FreeMonoid or something
04:04:54 <mauke> xy is not equal to x or y because the AST is different, and you only have the axioms to transform ASTs
04:05:23 <shachaf> But that type doesn't obey the laws.
04:05:37 <mauke> oh, my FreeMonoid isn't right because the explicit Mappend lets you recover structure
04:05:52 <shachaf> Right.
04:05:57 <mauke> and the associativity rule says you can't see associativity
04:06:03 <mauke> so you end up with [X]
04:06:12 <shachaf> (It also isn't "over some set S" -- it needs to contain all the elements of S.)
04:08:07 <shachaf> I wonder if this is a good exercise: What if you take (for some particular type R): (A :: *, inj :: X -> (R -> A)), such that for any (B :: *, f :: X -> (R -> B)), there exists a unique f' :: (R -> A) -> (R -> B) such that fmap f' . inj = f -- what would A be?
04:08:31 <shachaf> I think at this point it's probably more confusing than good.
04:08:33 <shachaf> But it's the same idea in a different context.
04:10:28 <lovelove> How do I define a datatype that only consists of printable ascii characters? I need that for quickcheck, when I tell it to use Char, it also tries non-printable characters. So I need a "Subtype" of Char with only the printable characters
04:10:45 <shachaf> There are no subtypes.
04:10:50 <shachaf> But QuickCheck has a mechanism for this.
04:11:04 <shachaf> I don't remember how it works, but there are things for e.g. positive numbers, I think. Look in the documentation for that.
04:11:12 <lovelove> okay thanks
04:11:29 <lovelove> sad that it's not that easy xD
04:11:42 <lovelove> but thanks you very much I'll look it up
04:11:48 <shachaf> It's pretty easy.
04:12:10 <shachaf> @check \(Positive x) -> x > 0
04:12:14 <lambdabot>   +++ OK, passed 100 tests.
04:15:58 <byorgey> lovelove: just make a newtype wrapper around Char, and make your own custom Arbitrary instance which generates only printable ASCII characters
04:16:25 <wagle> IH(0) = "I can't do algorithms in haskell"
04:16:34 <byorgey> lovelove: for an example, see the 'Elt' type here: http://hub.darcs.net/byorgey/split/browse/test/Properties.hs
04:17:17 <lovelove> okay I'll check it out
04:17:34 <mauke> newtype Printable = Printable Char
04:26:57 <donri> is there an "original" paper for the introduction of IO as a monad?
04:27:55 <niteria> @where awkward squad
04:27:56 <lambdabot> I know nothing about awkward.
04:28:23 <niteria> donri: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/ I think that's it, but I'm not 100% sure
04:28:38 <donri> cool thanks
04:32:19 <Bram> hello humans, I'm trying to pattern match on the IO data constructor in a function declaration but I can't managed to find it nor from where to import it (I've tryed System.IO). I'm trying to do this: "unpackIO (IO a) = a". Is it possible to do this? If yes, what is the name of the IO data constructor I'm trying to use (and in which pkg is it?)? Am I trying to perpetrate a blasphemy?
04:32:48 <niteria> why do you want to do that?
04:34:28 <S_J> So I need to write my own very simple protocol on top of sockets, is pipes really the right library to use for this?
04:35:29 <Bram> I want to be able to write 'getTodos = unpackIO $ Yaml.parseYamlFile "pouet.yaml"' and 'handleCLIArguments [] = printDescriptions getTodos' instead of 'getTodos = Yaml.parseYamlFile "pouet.yaml"' and 'handleCLIArguments [] = getTodos >>= printDescriptions', looks nicer and I'm just playing arround and was curious on how to do that
04:36:13 <Bram> (sorry for the hightly contextualised snippets)
04:36:14 <niteria> there's unsafePerformIO :: IO a -> a, but you have to have good reasons to use that
04:36:35 <Bram> why?
04:37:05 <arkeet> just don't use it.
04:37:34 <shachaf> Don't use it and don't tell people about it when they ask questions about how to do I/O.
04:38:09 <artyomkazak> Bram: because by using it you’re losing a very important property of Haskell: if a function signature doesn’t have “IO” in it, it isn’t doing any IO.
04:38:40 <artyomkazak> Therefore, using it can be considered lying to people.
04:38:53 <artyomkazak> And you don’t lie unless for very good reasons, do you
04:38:56 <artyomkazak> DO YOU
04:39:26 <Bram> haha, I see, thanks for the explanation
04:42:03 <donri> Bram: you don't have to put handleCLIArguments in IO for this though, you can fmap it over getTodos
04:42:28 <donri> Bram: oh wait i misread your code
04:44:45 <donri> Bram: if it's only about how the code look, maybe try the =<< operator which is just >>= flipped, so it reads like function application
04:46:05 <Bram> donri: oh good idea, thanks!
04:47:10 <donri> Bram: see also http://www.haskell.org/haskellwiki/Avoiding_IO
04:52:49 <Bram> donri: ok, thx
04:53:20 <Sculptor> howdy
04:54:25 <chrisdone> successfully moved from last.fm to my own server. \o/ wrote a wee greasemonkey script for grooveshark =p
04:55:24 <donri> chrisdone: libre.fm?
04:55:30 <donri> uh -blah
04:58:49 <hiptobecubic> We should make a team to compete with ed at blog posting / package creation. Maybe 10 vs 1 to keep it fair.
04:59:39 <donri> @quote delegate
04:59:39 <lambdabot> No quotes match. My brain just exploded
04:59:55 <donri> @quote delegation
04:59:55 <lambdabot> merijn says: edwardk's delegation has reached the point where he can have the language implementor explain his libraries...
05:00:32 <chrisdone> donri: yeah php, perl and python? for a trivial service i can write in haskell in an evening? nnnnnnaaaahhh
05:00:41 <donri> :)
05:00:49 <donri> chrisdone: did you write the greasemonkey script in fay? :D
05:02:31 <chrisdone> nah, that's harder
05:04:13 <chrisdone> took me way too long to write it, there seems to be zero debug information for greasemonkey scripts and firefox's web developer bar crashes the whole browser, kinda hated writing it
05:04:30 <chrisdone> firefox is generally sluggish and fat at doing everything compared to chrome =(
05:05:10 <chrisdone> scotty is quite cute though
05:05:31 <chrisdone> that guy on reddit was saying how easy it is to get running. it's not much different to snap, but it does require fewer dependencies
05:05:41 <hpc> chrisdone: it helps for performance that chrome doesn't render things correctly ;)
05:05:48 <chrisdone> and it knows wtf text and string are so i don't have to manually decode bytestrings
05:06:00 <donri> chrome is so fast, it scrolls whole lines instantly!
05:07:31 <donri> hpc: i think it ignores the specs on several caching stuff too (ie. caches too heavily)
05:07:45 <hpc> yeah, i've run into that before
05:08:03 <hpc> also, firefox is quite fast now
05:08:23 <hpc> pretty much the only way to make sluggish is to install an awful extension like firebug
05:08:46 <chrisdone> i don't even have firebug =(
05:09:20 <chrisdone> granted, i use a bunch of heavy apps on firefox like gmail and grooveshark
05:09:28 <hpc> that'll do it too
05:09:30 <chrisdone> i say 'heavy', because on firefox they _feel_ heavy. on chrome it's just another tab
05:09:34 <donri> my firefox startup is pretty sluggish (a bunch of extensions plus loads of tabs / pinned tabs / tab groups) but once started no problems really
05:09:57 <chrisdone> firefox is all "hey guise i'm fast like chrome! but not for that… not for stuff that matters, guys"
05:10:10 <hpc> firefox's javascript is still single-threaded because architecture reasons
05:10:15 <donri> "not for stuff that google made, and tailored for chrome" :p
05:10:24 <chrisdone> grooveshark?
05:10:25 <hpc> so misbehaving ads like you see on every damn square inch of grooveshark are going to screw up your performance
05:10:44 <chrisdone> well i have adblock so i don't see any ads
05:10:48 <donri> but yeah firefox is still measurably slower than chrome/blink
05:10:59 <chrisdone> i blame the single-threaded architecture mostly
05:11:11 <chrisdone> the benchmarks show the engines themselves to be mostly on par
05:11:18 <hpc> i have found that adblock doesn't actually work for truly getting rid of ads
05:11:26 <hpc> it makes them not appear, but they still slow down the page
05:11:28 <hpc> try noscript
05:11:50 <donri> noscript is a bit of a sledge hammer though
05:11:55 <chrisdone> noscript is a pita
05:13:05 <donri> http://ro-che.info/ccc/21.html  hey kid, is firefox using servo yet?
05:13:08 <hpc> it is a bit, but once you get a good whitelist going it's hardly noticable
05:13:46 <hpc> donri: hahaha
05:14:04 <applicative> do you use chrome? it always uses as many threads as the rest of my machine together. there is something deeply pathological about it, but its fast
05:14:41 <hpc> oh, that reminds me of another thing chrome does that's evil for the sake of fast
05:14:41 <pharaun> i have firebug but i keep it disabled most of the time
05:15:07 <pharaun> but fwiw i often have 200-500 tabs open cross a dozen+ window in firefox
05:15:08 <hpc> i have no idea what it does, but there's some kind of agressive network trickery going on
05:15:12 <pharaun> and it handles it fine
05:15:26 <donri> hpc: predictive pre-fetching or something like that
05:15:33 <hpc> one day my office had a packet loss issue
05:15:40 <hpc> ssh was slow, firefox was slow
05:15:43 <hpc> but chrome was fast
05:15:47 <donri> plus it's probably sending your porn stash to google in the background
05:15:58 <hpc> because when chrome is running, literally nobody else can access anything
05:16:13 <hpc> so one jerk is using chrome, "i don't see anything wrong"
05:16:20 <hpc> and stopping work for everyone else in the office
05:16:22 <chrisdone> donri: or google already predicted your porn stash and has it already
05:16:28 <donri> hahaha
05:16:53 <donri> "we don't spy on you; we already know what you're going to do"
05:17:19 <pharaun> haha
05:17:32 <applicative> i hadn't heard attacks on chrome, i guess i'm not interested in browsers, but chrome is very very often at the bottom of the need to reboot.
05:17:37 <chrisdone> yeah, when they gave a statement about RSA it wasn't "We didn't cooprate on this! Outrageous!" it was "Pfft, spying? That's so last century.”
05:17:45 <pharaun> applicative: *reboot* ?
05:17:49 <chrisdone> (er, nsa)
05:18:05 <applicative> it mixes very poorly with my depraved tendency to have 10 copies of ghci open ... ;)
05:18:56 <hpc> applicative: what you don't hear about are sandbox attacks, where something on a webpage affects your system
05:19:07 <hpc> applicative: but there's really not much good stuff on the system anymore
05:19:15 <hpc> meanwhile, XSS is alive and well in chrome
05:19:38 <hpc> http://xkcd.com/1200/
05:19:51 <pharaun> applicative: 10? :)
05:19:56 <applicative> pharaun: but i always have the mac 'activity monitor' open and it's amazing how half of it is chrome, chrome renderers, Chome helpers
05:20:00 <pharaun> ahh
05:20:04 <pharaun> hahahaha yes
05:20:06 <applicative> pharaun: this is an unjustifiable vice
05:20:23 <arkeet> hpc: haha, I never read the alt text before.
05:21:13 <applicative> my belief that its behind absurd spinning pinwheels that dont stop, pharaun, is a little speculative ;)
05:21:48 <pharaun> applicative: :D
05:22:06 <pharaun> i used to have a work mac laptop, i'm *familiar* with chrome and osx, they both were my nemeses
05:22:10 <pharaun> to productiveness
05:23:00 <hpc> bahaha: http://ro-che.info/ccc/20
05:23:55 <chrisdone> i tried to use OS X and couldn't overcome my profound disgust for it. i've never been hardcore "free software" but working with OS X made me temporarily channel RMS's deep hatred
05:24:05 <pharaun> haha
05:24:13 <pharaun> for me it was more of death by thousands papercut
05:24:19 <mauke> arkeet: that's not what alt text means
05:24:28 <hpc> chrisdone: it was only a matter of time before RMS ranted about something that was legitimately bad ;)
05:24:28 <arkeet> that's what everyone calls it
05:24:29 <arkeet> :|
05:24:46 <arkeet> mauke: pedantry.
05:24:47 <pharaun> i've been linux user for *years* and got used to it so when i tried osx i got really peeved at how i couldn't just rip up the source and rewrite to customize the system to exactly what i wanted
05:24:52 <applicative> chrisdone: mac land is totally gross, but i've been using it for years now, having only paid for one program, TextMate
05:24:58 <chrisdone> it's because ALT="…" was for a while what would pop up and then TITLE="…" became standard
05:24:58 <mauke> arkeet: then what do you call alt text?
05:25:12 <mauke> s/pop up/& in internet explorer/
05:25:25 <arkeet> mauke: I call it that because everyone calls it that.
05:25:30 <arkeet> even though it's technically wrong.
05:25:32 <arkeet> because who cares.
05:25:34 <arkeet> other than pedants.
05:25:36 <mauke> arkeet: then what do you call alt text?
05:25:42 <hpc> it's the alt text and the title text
05:25:49 <hpc> because you need both for it to actually work
05:25:55 <hpc> woo, browsers!
05:26:03 <pharaun> wait what
05:26:11 <pharaun> i still use only alt
05:26:23 <mauke> pharaun: for what?
05:26:27 <donri> alt is for if the image can't be displayed / before it's loaded and rendered
05:26:30 <applicative> in the end everything will be made of javascript
05:26:32 <hpc> alt="" {- internet explorer -} title="" {- every other browser in the friggin universe -}
05:26:36 <donri> title is for "tooltip text"
05:26:37 <mauke> hpc: no
05:26:38 <applicative> this can be proven through the scriptures.
05:26:42 <mauke> hpc: they're for different things
05:26:49 <pharaun> mauke: img tags
05:26:51 <chrisdone> nah alt is for missing objects
05:26:54 <mauke> pharaun: go on
05:27:12 <hpc> you can say they're different all you want
05:27:13 <chrisdone> i.e. "alternative" instead of just showing nothing
05:27:20 <hpc> but IE ignores title text
05:27:23 <pharaun> i'm not much of a html coder :) i've only used alt tags on img and never was aware of the title="" thing
05:27:29 <hpc> and IE alt text does what other browsers' title text does
05:27:32 <pharaun> brb looking up the specs
05:27:35 <hpc> so they are functionally the same
05:27:38 <mauke> pharaun: you say you've only used alt tags. I'm asking you: for what?
05:27:43 <pharaun> oh
05:28:02 <pharaun> to describe the image for text reader and so on
05:28:06 <mauke> good
05:28:10 <hpc> if browsermakers ignore the specs, what possible reason would i have for following them ;)
05:28:12 <mauke> pharaun: you're doing it right
05:29:08 <pharaun> mauke: i used to do some webpage accessibility at ibm a while ago so got to study up on the correct way of doing stuff like that
05:29:11 <pharaun> and *shrugs* yeah
05:29:16 <applicative> browser makers would ignore the specs without i.e. surely
05:29:36 <chrisdone> surely ou mean IE, and don't call me shirley
05:30:06 <hpc> http://cdn.memes.mugglenet.com/2013/6/2/memes.mugglenet.com_593_1370397740.jpg
05:30:06 <applicative> for one thing, 'the specs' change but the internet is pages from 20 odd different years
05:30:30 <chrisdone> hpc: lol
05:30:36 <S_J> So I need to write my own very simple protocol on top of sockets, is pipes really the right library to use for this?
05:30:43 <applicative> YES
05:30:55 <pharaun> hpc: ha i actually never saw that one movie, saw all the other
05:31:09 <applicative> S_J: what went wrong yesterday, i though renzo was advising you
05:31:25 <applicative> S_J: (I dont profess to know if its the right library for you)
05:32:13 <donri> hpc: https://i.chzbgr.com/maxW500/2507519232/h2B6586EF/
05:33:03 <pharaun> now i never expected to see a chzbgr link in here wow
05:33:59 <shachaf> Why? The signal-to-noise ratio is certainly low enough for it.
05:34:21 <pharaun> shachaf: its... usually... better.. sometime
05:34:23 <hpc> pharaun: for serious discussion, goto -blah
05:34:45 <applicative> it's usually much better, but where did S_J go?
05:35:15 <applicative> mentioning the signal-to-noise ratio is however a hostile act
05:36:14 <pharaun> applicative: its an act of war
05:36:43 <donri> i suggested -blah long ago, don't look at me! :P
05:37:11 * applicative opened -blah once or twice over the millenia
05:37:15 <chrisdone> eh, "off topic" is only applicable when it's actually interrupting/discouraging on topic discussion imo
05:37:38 <applicative> "off topic" is basically always trolling
05:37:43 <chrisdone> cabal installing a web server and one of the dependencies is ansi-terminal, heh
05:38:00 <applicative> though then there are the cases when its necessary
05:38:50 <mauke> <applicative> "off topic" is basically always trolling  <- /me raises all eyebrows
05:40:06 <applicative> mauke: its crucial to distinguish the thing itself, which is bad, and the assertion of it
05:40:29 <chrisdone> pharaun: how about this-plt-life: http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
05:40:33 <applicative> there are much better solutions, and they are used much more frequently without being noticed
05:40:46 <mauke> only a sith deals in absolutes
05:41:30 <chrisdone> mauke: *only* a sith? sounds absolutist to me. are you a sith?
05:42:29 <pharaun> chrisdone: ha ive seen that one actually
05:42:41 <applicative> i wonder what the person who made this 'this plt life' peyton jones thing, was thinking.
05:43:28 <chrisdone> it was probably bob harper
05:43:31 <applicative> 'simon peyton jones added the io monad to haskell' already seems like a loser proposition
05:45:05 <chrisdone> everything i read by bob harper is like "<something insightful>, oh and haskell sucks"
05:45:21 * applicative lives down the street from bob
05:45:49 <chrisdone> http://fc02.deviantart.net/fs71/f/2010/004/8/5/At_first_I_was_like_2_by_BalanceSplashRhyme.png
05:46:08 <applicative> the mental strain is too much for me
05:49:31 <h0071> could someone tell me how tree annotations would work in Haskell? so if i have a basic tree type and want to find the size of nodes, I could just write a function for that, or I could encode the size info in the data type itself, or I could use tree annotations... The last one, I am not very sure to do.
05:50:23 <h0071> would be great if you could point me to some resources, i couldn't find by just googling
05:54:31 <benneh> I have a piece of code which works fine. But if I move one of the functions into another file and import it from there, I get a stack overflow. What could cause that?
05:55:50 <hpc> @hpaste
05:55:50 <lambdabot> Haskell pastebin: http://lpaste.net/
05:56:00 <hpc> benneh: paste your code perhaps?
05:56:17 <chrisdone> can we make that one the same as
05:56:18 <chrisdone> @where lpaste
05:56:19 <lambdabot> http://lpaste.net/new/haskell
05:56:27 <chrisdone> because it includes the channel
05:56:57 <hpc> we should make @hpaste and @lpaste both insert the current channel name automatically
05:57:04 <hpc> so in #agda, it would be lpaste/new/agda
05:57:10 <chrisdone> yeah
05:57:18 <hpc> and then remove the @where
05:58:23 <benneh> hpc: http://lpaste.net/93019, the definition of maximumOn in Util is the same as the commented out definition in this file, yet this causes a stack overflow and using the commented out version instead doesn't
05:58:27 <donri> and then map channels to default languages so /new/happs uses haskell and #happs ;)
05:59:45 <chrisdone> so i was thinking it might be related to the generated code being generic or not
05:59:55 <chrisdone> maximumOn in a separate module wouuld be forced to take an instance dictionary
06:00:00 <chrisdone> in the same module it can be inlined more
06:00:13 <chrisdone> and specialised
06:00:19 <chrisdone> that might be related
06:02:08 <h0071> tree annotations in haskell, anyone? simple example>
06:03:40 <benneh> chrisdone: well that's not nice. are there any ways round this? it seems a bit absurd to have to copy this fairly generic function every time a want to use it :/
06:04:09 <chrisdone> benneh: you're compiling with -O2 i presume?
06:04:14 <benneh> chrisdone: yes
06:04:20 <FreeFull> edwardk: Hey, in World in a Bottle, flat's type signature doesn't seem to agree with its definition
06:04:21 * hackagebot data-extra 2.5.3 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.5.3 (ChrisDone)
06:04:22 <chrisdone> let me see…
06:04:27 <donri> heh bot is still "hpaste"
06:04:44 <chrisdone> i changed the nick to lpaste but vnc is stoopid
06:08:55 <Walther> I'm doing the 99 haskell problems, and i'd like someone to explain me the difference between [x,_] and [x:_]
06:09:24 <mauke> [x,_] is syntactic sugar for (x : _ : [])
06:09:36 <mauke> [x:_] is syntactic sugar for (x : _) : []
06:09:45 <FreeFull> edwardk: The article says its type is  flat :: Int -> Act Move Int  but looking at it its type would just be  flat :: Act Move Int
06:09:58 <Walther> mauke: Oof. With implications of?
06:10:20 <mauke> Walther: [x:_] is a list containing a single element, which is a list again
06:10:23 <hpc> h0071: as far as i can tell from googling, tree annotations are where you just put the information as another element of the data type
06:10:28 <mauke> the inner list has at least one element (called x)
06:10:44 <mauke> [x,_] is a list containing exactly two elements. the first element is called x
06:10:48 <Eduard_Munteanu> > [1:_]
06:10:48 <Eduard_Munteanu> No bawt? :(
06:10:50 <lambdabot>   Pattern syntax in expression context: _
06:10:57 <Walther> (I was intuitively going for the myButLast'' version at http://www.haskell.org/haskellwiki/99_questions/Solutions/2 but had [x:_] instead of [x,_] and it failed
06:11:05 <Eduard_Munteanu> Err, right :)
06:11:06 <FreeFull> :t \[x,_] -> x
06:11:07 <lambdabot> [t] -> t
06:11:12 <FreeFull> :t \[x:_] -> x
06:11:12 <lambdabot> [[t]] -> t
06:11:29 <mauke> Walther: you may have wanted (x : _)
06:12:29 <Walther> let's see if i get this right
06:12:37 <Walther> , implies elements of same list
06:12:46 <Walther> : implies a list of lists
06:13:26 <Walther> 0 : 1 would be [[0],[1]], and 0,1 would be [0,1] (in terms of syntactic sugar
06:13:32 <Walther> or am I completely wrong
06:13:40 <mauke> you're completely wrong
06:13:49 <Walther> Nod, elaborate please
06:13:49 <mauke> : is an operator
06:14:02 <mauke> it takes an element and a list, and returns a new list
06:14:08 <mauke> > 1 : [2, 3]
06:14:09 <lambdabot>   [1,2,3]
06:14:16 <hpc> Walther: [this, list, syntax] is syntactic sugar for (:)
06:14:16 <mauke> it glues a new head on top of a list
06:14:21 * hackagebot pqc 0.8 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.8 (KidoTakahiro)
06:14:28 <mauke> > "hello" : []
06:14:29 <lambdabot>   ["hello"]
06:14:36 <FreeFull> :t (:)
06:14:37 <lambdabot> a -> [a] -> [a]
06:14:46 <Walther> (I mean, I understand what x:xs does but with the context of myButLast why [x:_] didn't work but [x,_] works goes over my head)
06:15:23 <mauke> Walther: when pattern matching, x:_ matches a list of at least one element. the first element is bound to x, the rest of the list is bound to _ (i.e. thrown away)
06:15:35 <FreeFull> Walther: [x] will match a single-element list
06:15:41 <mangaba_leitosa> Walther: because you want 'x:_', not [x:_]
06:16:12 <FreeFull> [x] is the same as (x:[])
06:16:15 <geekosaur> [x:_] is a list containing a list
06:16:19 <mauke> > case [1,2,3] of x : xs -> (x, xs)
06:16:20 <lambdabot>   (1,[2,3])
06:16:26 <mauke> > case [1,2,3] of [x : xs] -> (x, xs)
06:16:27 <lambdabot>   No instance for (GHC.Show.Show t0)
06:16:27 <lambdabot>    arising from a use of `M1528077481.sh...
06:16:29 <Walther> mauke: ahhhh
06:16:39 <mauke> > case [[1,2,3], [4,5]] of [x : xs] -> (x, xs)
06:16:40 <lambdabot>   *Exception: <interactive>:3:1-44: Non-exhaustive patterns in case
06:16:46 <mauke> tee hee
06:16:47 <chrisdone> FreeFull: if you use: maximumOn f = maximumBy (comparing f)
06:16:47 <chrisdone> FreeFull: then it doesn't stack overflow, but it's about 4 times slower
06:17:08 <Walther> and that's why in myFunction x:xs = myFunction xs -recursion the : is needed, because you need to make sure the "rest of elements but first" is a new *list*
06:17:11 <Walther> there we go, thanks
06:17:11 <FreeFull> chrisdone: Why are you telling me this?
06:17:21 <mauke> Walther: any use of [ ] (except for [] itself) is syntactic sugar
06:17:24 <chrisdone> oh
06:17:27 <chrisdone> i meant benneh
06:17:42 <FreeFull> Walther: You'll want to wrap the  x:xs  in () brackets
06:17:46 <eccstartup> leave
06:17:52 <mauke> [1,2,3] is 1 : [2,3] is 1 : (2 : [3]) is 1 : (2 : (3 : []))
06:18:26 <FreeFull> Maybe if the syntax sugar didn't exist beginners wouldn't be confused
06:18:31 <FreeFull> But then it'd be ugly
06:18:54 <benneh> chrisdone: there are other places where I use maximumOn with very expensive f, so I do need the faster version
06:19:13 <Walther> Nod. I was under the assumption that x:xs foo xs implied [1,2,3]to 2,3 but of course it needs to make it a new *list* so it
06:19:48 <Walther> it's funny, so far i had only needed : in its reverse form, basically, then
06:20:24 <FreeFull> Walther: Pattern matching is a bit weird but extremely awesome
06:20:51 <chrisdone> benneh: ok, what you can do is indicate to GHC that you want it to specialize the function on specific types
06:21:17 <FreeFull> :t \[Just 3,Nothing,Just x] -> x
06:21:18 <hpaste> chrisdone annotated “No title” with “Util using SPECIALIZE (for benneh)” at http://lpaste.net/93019#a93020
06:21:18 <lambdabot> (Eq t, Num t) => [Maybe t] -> t
06:21:40 <Walther> FreeFull: Aware.
06:22:33 <benneh> chrisdone: and GHC would basically just do that automatically if the definition weren't in an external file?
06:23:03 <chrisdone> benneh: yeah, i think it's able to specialize the local one but isn't doing it cross-module in this case
06:23:25 <chrisdone> benneh: i doubt it's for any semantic reason, it just doesn't do that optimization, doesn't go that far
06:24:12 <benneh> chrisdone: well that's annoying. is there any way to tell GHC to specialise it for all types as it would if the function were defined locally?
06:25:07 <benneh> chrisdone: or to tell GHC to treat everything imported from Util as if it were local
06:25:16 <benneh> that would be more convenient
06:25:33 <chrisdone> the first one, not sure. the latter you can
06:25:55 <chrisdone> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/pragmas.html#id643313
06:26:28 <chrisdone> iow, you declare your function inlinable in the Util module, and then when you import it, you say which typess it should specialize
06:28:47 <Walther> Uh, okay, don't straight-out yell me the answer, but could someone clarify why this doesn't work / always matches to the first element http://lpaste.net/540627243152441344
06:29:18 <benneh> chrisdone: that works perfectly, thanks
06:29:26 <chrisdone> welcome =)
06:30:23 <Maxdamantus> Walther: elementAt [1, 2] 2 = elementAt [1, 2] 1 = head [1, 2] = 1
06:30:53 <Walther> ah, derp, i forgot to reduce the first element :)
06:32:24 <chrisdone> benneh: hmm, implementing it in a more efficient way is an alternative
06:33:49 <hpaste> chrisdone annotated “No title” with “Efficient maximumOn (for benneh)” at http://lpaste.net/93019#a93021
06:34:10 <chrisdone> ah, balls, he left
06:34:22 * hackagebot snaplet-redis 0.1.3 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.3 (DmitryDzhus)
06:34:45 <donri> also it specializes for types used at the call site for imported inlinable functions for you
06:35:36 <mangaba_leitosa> Anyone compiled Fudgets with ghc 7.x? I'm looking for compliation instructions
06:38:06 <chrisdone> @tell benneh use this http://lpaste.net/4099483985531371520
06:38:06 <lambdabot> Consider it noted.
06:41:51 <shachaf> mauke: Maybe a slightly different way of saying it is: foldMap f (inj a <> inj b <> inj c) = f a <> f b <> f c
06:42:02 <shachaf> Where inj is (:[]) and foldMap is the thing that turns f into f'
06:42:25 <shachaf> And this works for any f, so the free monoid must keep as much information as possible.
06:42:43 <shachaf> But it can't keep the associativity of the <>s, because then it wouldn't be a monoid anymore.
06:43:54 <chrisdone> it would be cool if "hiding" would apply to all modules that exported the same Name
06:44:04 <chrisdone> so import Prelude hiding (head) would also hide head from Data.List imports
06:44:23 <chrisdone> i can't imagine a case where hiding one but not the other is any use
06:44:39 <chrisdone> they're _the same_ name
06:52:59 <chrisdone> donri: yay http://chrisdone.com/listens/100
06:53:21 <shachaf> mauke: And also: There's an isomorphism between functions : (X -> N) and homomorphisms : ([X] -> N)
06:54:02 <shachaf> That is, a homomorphism is entirely determined by what it does on a one-element list.
06:54:22 * hackagebot mwc-random-monad 0.7 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.7 (AlexeyKhudyakov)
06:54:38 <shachaf> s/That is/In particular/
07:02:07 <Walther> Huh. Why does myReverse (x:xs) = myReverse xs : x not work, but myReverse (x:xs) = myReverse xs ++ [x] does?
07:02:19 <chrisdone> because the type of (:)
07:02:21 <chrisdone> :t (:)
07:02:22 <lambdabot> a -> [a] -> [a]
07:02:28 <chrisdone> the second arg should be a list
07:02:35 <chrisdone> and the first arg an element of that list
07:02:50 <chrisdone> :t (++) -- takes two lists
07:02:51 <lambdabot> [a] -> [a] -> [a]
07:03:07 <Walther> agh, i'm still thinking : in the wrong way. It doesn't concatenate lists.
07:03:57 <Walther> I think I still don't quite understand the direct use of :, only the special case of function (x:xs) = function xs recursion
07:04:27 <Walther> where it makes a list of the rest of the items in the list
07:04:36 <geekosaur> haskell lists are linked lists, not arrays/vectors. (:) adds a link
07:04:42 <chrisdone> well, : is for constructing lists
07:04:48 <geekosaur> links can only be added onto the head
07:05:00 <geekosaur> (directly added that is)
07:05:02 <chrisdone> x : [] is [x], x : y : [] is [x,y]
07:05:05 <GGuy> hi everyone... if I have a "data Word256 = Word256 Word32 ... Word32" is there a shorthand for contructing it from a size 8 list? (e.g. Word256 (wordlist !! 0) (wordlist !! 1) etc)
07:05:34 <chrisdone> Walther: the [x,y,z] is just syntactic sugar for x : y : z : []
07:06:34 <chrisdone> you couuld make your own with: data List a = Nil | Cons a (List a) and then write Cons 1 (Cons 2 (Cons 3 Nil)) to represent 1:2:3:[],  or [1,2,3]
07:07:10 <applicative> GGuy: I think you shouldn't let lists get involved; just write it by hand
07:07:22 <applicative> GGuy: only, not the function from lists...
07:09:11 <applicative> GGuy: but who knows?  have you seen largeword by the way
07:09:16 <applicative> https://github.com/idontgetoutmuch/largeword/blob/master/Data/LargeWord.hs
07:10:01 <FreeFull> :t (/.)
07:10:02 <lambdabot> Int -> Int -> Double
07:10:36 <applicative> whoa is that in base? do I want to know?
07:10:42 <FreeFull> :t let (fromIntegral -> x) /.. (fromIntegral -> y) = x / y in (/..)
07:10:43 <lambdabot> (Fractional a2, Integral a, Integral a1) => a -> a1 -> a2
07:10:52 <applicative> ah
07:11:04 <FreeFull> Ok, I do sorta understand view patterns
07:12:49 <S_J> So I'm writing an SQL-parser and obv there can be optional conditions for example "SELECT colname FROM tablename" or "SELECT colname FROM tablename WHERE cond". so first I need to parse both but then I need a datatype that supports both. How do I write a parser that always terminates on "\n\0" but can optionally parse a WHERE clause?
07:14:06 <donri> S_J: (parseThis <|> parseThis *> parseWhere) *> parseNewlineNul?
07:14:22 <Walther> Maybe?
07:14:24 <applicative> FreeFull: did you see that fancy exhibition of regexs+view patterns? http://lethalman.blogspot.it/2013/09/regex-in-haskell-patterns.html
07:14:28 <donri> or, well, "optional"
07:14:38 <donri> :t optional
07:14:39 <lambdabot> Alternative f => f a -> f (Maybe a)
07:14:40 <GGuy> Thanks chrisdone/applicative, I'll have to think about if what i'm trying to do with lists actually makes sense... I might be better off using a tuple anyways. I decided against Largeword because I'm implementing specific typeclasses which wouldn't generically make sense...
07:16:28 <applicative> GGuy: a tuple introduces a slightly different danger, of extremely laziness, but for most purposes the compiler will see past this.
07:17:23 <FreeFull> applicative: I have
07:18:03 <FreeFull> applicative: /. isn't in base, it's in lambdabot's user-defined stuff
07:18:10 <FreeFull> applicative: A simple @undef will get rid of it
07:18:11 <applicative> it was pretty cool, though tailbalance's addition of the semi-imaginary pattern synomyms was really wild.
07:18:29 <applicative> hah
07:19:01 <zomg> applicative: what on earth are "semi imaginary pattern synonyms"
07:19:05 <zomg> :D
07:19:27 <applicative> see the demo http://www.reddit.com/r/haskell/comments/1lvuvl/regex_in_haskell_patterns/
07:19:45 <applicative> using the she-preprocessor, neverending source of mysterious magic
07:19:57 <GGuy> applicative: in my instance the might actually make more sense since at time I will only need partual evaluation... and the size of the tuple should give me enough type distinction for my needs
07:20:07 <applicative> oh
07:20:42 <zomg> heh
07:20:43 <FreeFull> applicative: Where did URL come from?
07:20:51 <applicative> zomg: somehow the PatternSynonyms started seeming dangerous. I had thought of them as making synonyms for complexs of constructr
07:21:37 <applicative> constructors, but here its just a function associated with a regex, is appearing as URL
07:21:57 <applicative> man my typing is more out of control than ever.
07:22:04 <FreeFull> I suppose that is she magic
07:22:28 <applicative> FreeFull: you saw the program i mean?
07:22:45 <FreeFull> applicative: In tailbalance's post?
07:22:45 <applicative> FreeFull: it's apparently being implemented by someone, though, PatternSynonyms
07:22:55 <applicative> yeah http://www.reddit.com/r/haskell/comments/1lvuvl/regex_in_haskell_patterns/cc3cmzc
07:23:03 <applicative> his comment
07:23:10 <donri> well the URL example uses view patterns too, no?
07:23:42 <FreeFull> donri: view patterns and she
07:23:51 <applicative> donri: that's the point, both at once
07:24:22 * hackagebot hatex-guide 1.2.0.0 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.2.0.0 (DanielDiaz)
07:24:33 <applicative> thus exhibiting the depravity of each!
07:24:38 <donri> what's weird is, i assume, URL is neither a type nor a constructor
07:24:55 <donri> but then that's sort of the point, i guess
07:25:07 <applicative> donri: right, you are thinking like I was about pattern synonyms
07:25:32 <applicative> maybe he's just using an unintended feature of the she implementation?
07:25:42 <donri> don't know how you thought about them. i understand them perfectly fine :)
07:26:47 <applicative> but dont you think the idea was that the pattern should be a pattern in the Pattern matching sense
07:27:11 <applicative> or maybe i'm not understanding tailbalances program
07:27:13 <donri> and how isn't it?
07:27:54 <donri> it's just translating to a view pattern. i don't see what's any more crazy about it than using view patterns directly.
07:28:53 <donri> not really different from a view pattern returning a Maybe (proto,host)
07:28:53 <S_J> Right (SELECT "x" FROM "y" (WHERE "10"))
07:28:56 <applicative> well, yes, but what is this pattern a synonym for? I'm certainly not objecting
07:29:25 <S_J> Right (SELECT "x" FROM "y" (WHERE "10")) #### i dont set the parentheisis around WHERE myself so is it because it is a parser in a parser? can i remove it?
07:29:49 <donri> applicative: it's a synonym for strings that match urlRegex
07:30:28 <applicative> donri: by contrast we expect pattern WayLeftPair a b = Left (Left (Left (a,b))
07:30:51 <satc> @pl \a -> length a == 2
07:30:54 <lambdabot> flip ((==) . length) 2
07:30:55 <lambdabot> optimization suspended, use @pl-resume to continue.
07:31:05 <S_J> if I use Parsec choice and pass [whereParser, noneParser]  and noneParser succeeds i shouldnt get a parse error because whereParser fails right?
07:31:22 <applicative> donri: I mean, this is the intended use; though maybe tailbalance's reduces to it
07:31:49 <donri> applicative: it's just ViewPatterns
07:33:31 <applicative> donri yes, but this seems to make them completely different in character
07:34:11 <donri> applicative: i don't see why
07:34:30 <donri> you could literally substitute the pattern synonym for its expansion to a view pattern
07:34:31 <hpc> S_J: you should not get a parse error; the "entire parser" that you are running is "whereParser, or noneParser if that fails" (i assume)
07:34:51 <donri> foo ((=~ urlRegex) -> [[_,proto,host]] :: [[String]]) = Just (proto,host)
07:35:11 <applicative> donri: yes, then i am viewing the Pattern Synonym as a macro...
07:35:20 <hpc> S_J: like if it wanted to parse an expression, it could try and parse a parenthesized (expression); it sees an opening ( and then immediately a ), so it fails
07:35:30 <hpc> it continues through other parsers for expressions until it hits ()
07:35:33 <donri> applicative: so, what's the problem? :)
07:35:34 <hpc> and poof, it parses
07:35:42 <hpc> no error, it just had to try a few things
07:36:27 <applicative> donri: maybe none; but you think for example that it's obvious any implementation of PatternSynonyms will have this result with ViewPatterns enabled.
07:36:40 <S_J> hpc ^^
07:36:42 <S_J> http://lpaste.net/93022
07:36:46 <S_J> ^^
07:37:52 <hpc> S_J: you probably need to add try
07:37:56 <donri> applicative: i'd assume so yes?
07:38:01 <applicative> hm
07:38:09 <hpc> choice [try whereParser, try noneParser]
07:38:11 <applicative> this language is going to the dogs!!
07:38:41 <hpc> parsec assumes that by default, if a nested parser action fails, the whole thing fails
07:39:08 <donri> applicative: maybe what you mean is that view patterns are sort of magical (arbitrarily call functions inside patterns), and pattern synonyms help to hide that making it *look* even more magical
07:40:20 <hpc> S_J: er, that last part is wrong
07:40:30 <applicative> yes, probably. I was thinking though that my personal PatternSynonym implementation -- which probably make no sense -- only permits constructors on the RHS and moreover checks for totality, which is trivial in this case
07:40:34 <hpc> too tired to explain how it actually works though :P
07:40:52 <applicative> donri: i mean my personal imaginary implementation
07:40:52 <S_J> hpc: but hwat part is wrong?
07:41:29 <donri> applicative: maybe you're going for "constructor synonyms" more than "pattern" synonyms
07:41:31 <hpc> "choice [whereParser, noneParser]" => "choice [try whereParser, try noneParser]" -- i believe this will do it
07:42:08 <applicative> donri: but isn't a pattern of constructors what a pattern in the sense of pattern matching is; and isn't that the Pattern in PatternSynonyms
07:42:18 <donri> applicative: so yours wouldn't allow pattern One = 1, or pattern Nil = []
07:42:30 <applicative> just like that no
07:42:31 <donri> or it might allow that last one, that's debatable :p
07:42:49 <applicative> donri: i was adding that i didn't like the second if it werent accompanied
07:43:57 <applicative> pattern Nil = [] ; <space> One x = x:[];      Two x y = x:y:[];     Many xs = xs
07:44:07 <applicative> which exhausts the cases
07:44:22 <donri> they're synonyms not "newpattern"
07:44:33 <donri> you can still match exhaustively as before
07:45:24 <applicative> yes, i guess i'm following, i was reading something different into it. on the other hand, mcbrides justification pertains to generic programming
07:45:47 <applicative> so he can write something humane but under the hood it's whatever loathesome generic system he has going
07:47:26 * applicative looking at the aitken reppy paper mcbride mentions is suspecting donri must be right
07:47:30 <applicative> about the intention
07:48:14 <applicative> but maybe i'm right in the limited sense that mcbride was really interested in what you called newpattern
07:48:47 <applicative> or something like that
07:49:05 <donri> perhaps :)
07:53:40 <stelleg> S_J: you have two problems, one, your first "select x from y" fails because it should fail: you need one of "\n\0" at the end. see your noneParser definition. Second, hpc is right, because whereParser and noneParser overlap in their parsing of the first character, you have to add try, so that it can backtrack when the whereParser fails after consuming the first character
07:54:30 <niteria> can other thread wake up a thread that's suspended by threadDelay?
07:54:48 <hpc> evil thought: take advantage of the non-backtracking default behavior to make a larger parser out of one that guarantees failure and another that actually parses what you want
07:55:15 <hpc> niteria: try it and find out!
07:55:41 <hpc> niteria: however, see the docs for threadDelay
07:55:49 <hpc> "the thread will never continue to run earlier than specified"
07:57:12 <donri> applicative: an important thing to consider though i guess is whether "URL" requires both extensions downstream, or only pattern synonyms
07:57:57 <niteria> but maybe if I throw an exception to that thread I can wake it up
07:59:25 <hpc> niteria: depending on what exactly your threads are doing, perhaps you want to just block on an mvar instead of threadDelaying?
07:59:39 <hpc> or something
08:00:31 <niteria> I want my thread to wait 5 min, but have a way to wake it up sooner
08:00:53 <niteria> if there was tryTakeMVarWithTimeout I would use it
08:01:16 <benmachine> niteria: two ideas come to mind
08:01:21 <benmachine> niteria: one is using System.Timeout
08:01:37 <benmachine> niteria: the other is throwing/catching async exceptions (which is what System.Timeout does)
08:02:04 <mauke> niteria: just spawn another thread that sleeps 5 min, then writes to the mvar
08:02:11 <S_J> hpc: i needed to add \0 or \n to the string...
08:02:54 <niteria> I like mauke's solution
08:03:06 <hpc> haha, i was just about to say that
08:03:32 <hpc> you get a thread, you get a thread, everyone gets threads!
08:04:01 <hpc> http://1.bp.blogspot.com/-Q3BDeDdkObY/UGNgOCyhs5I/AAAAAAAADQw/bXDbsZbJxDU/s1600/oprah-bees.gif
08:06:13 <S_J> is there a way to capitalize a word?
08:06:20 <S_J> bith A->a and a->A
08:06:25 <S_J> > toUpper 'a'
08:06:27 <lambdabot>   'A'
08:06:31 <benmachine> hpc: I like how the url contains AAAAAAA
08:06:32 <S_J> > toLower 'a'
08:06:33 <lambdabot>   'a'
08:06:35 <S_J> > toLower 'A'
08:06:36 <lambdabot>   'a'
08:06:43 <hpc> > map toUpper "you didn't say what kind of capitalization"
08:06:44 <lambdabot>   "YOU DIDN'T SAY WHAT KIND OF CAPITALIZATION"
08:08:06 <S_J> @where toUpper
08:08:07 <lambdabot> I know nothing about toupper.
08:08:09 <niteria> I have to be careful though, to not double putMVar
08:08:18 <S_J> where is toUpper?
08:08:28 <klugez> Data.Char
08:08:35 <hpc> niteria: make another thread that constantly takes from the mvar!
08:08:38 <hpc> niteria: no wait, don't do that ;)
08:09:08 <hpc> @where hoogle
08:09:08 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:09:34 <hpc> "see also hayoo, which has been 503 for four days now"
08:09:48 <niteria> haha
08:11:41 <chrisdone> hpc: oh look middle class people being gifted a c—BEEEEEEEEES
08:12:05 <hpc> if i ever become a high school teacher...
08:12:13 <hpc> "you get a B, you get a B, everybody gets a B!"
08:14:01 <klugez> niteria: Could you make the tryTakeMVarWithTimeout with System.Timeout.timeout waitTime (takeMVar mvar)?
08:15:01 <niteria> yeah, I think that'll work
08:16:13 <chrisdone> hpc: "my bee stung me and died" "oh, would you like another?" "but i'm allergic t—" "here you go!"
08:18:39 <haasn> > "you didn't say what kind of capitalization" & iso words unwords.traverse._head %~ toUpper
08:18:41 <lambdabot>   "You Didn't Say What Kind Of Capitalization"
08:18:47 <haasn> and please never use ‘iso words unwords’
08:18:51 <haasn> in actual code
08:19:24 * hackagebot yst 0.3.1.2 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.3.1.2 (JohnMacFarlane)
08:20:36 <hpc> that's some acme-php level code
08:20:59 <applicative> in title case, i think we would skip "Of" there haasn.
08:21:14 <chrisdone> niiiiice
08:21:22 <chrisdone> i always wanted to make debian packages for deployment
08:21:24 <chrisdone> http://lulf.dimling.net/blog/haskell/Haskell_and_continuous_delivery_on_debian/
08:22:07 <hpc> snazzy
08:22:49 <FreeFull> hpc: I'd probably write a mapFirst instead
08:27:26 <benmachine> > unfoldr (\b -> case b of (_, []) -> Nothing; (True, c:cs) -> Just (c, (False, cs)); (False, c:cs) -> Just (toUpper c, (isSpace c, cs))) "you didn't say what kind of capitalization"
08:27:27 <lambdabot>   Couldn't match expected type `(GHC.Types.Bool, [GHC.Types.Char])'
08:27:27 <lambdabot>          ...
08:27:36 <benmachine> aw, frig
08:27:44 * benmachine ghci for a bit
08:28:20 <benmachine> > unfoldr (\b -> case b of (_, []) -> Nothing; (True, c:cs) -> Just (c, (False, cs)); (False, c:cs) -> Just (toUpper c, (isSpace c, cs))) (True, "you didn't say what kind of capitalization")
08:28:21 <lambdabot>   "yOU dIDN'T sAY wHAT kIND oF cAPITALIZATION"
08:28:28 <benmachine> oh, um, oops.
08:28:34 <applicative> haha
08:28:35 <cinimod> :)
08:28:37 <geekosaur> *snrk*
08:28:42 <geekosaur> still true though :p
08:28:50 <benmachine> :P
08:28:56 <applicative> i think that's a *kind* of capitalization
08:29:06 <benmachine> ooh ooh I have a better one
08:29:19 <riley_> re
08:29:52 <benmachine> > unfoldr (\b -> case b of (_, []) -> Nothing; (b, c:cs) -> Just (if b then toUpper c else toLower c, (not b, cs))) "you didn't say what kind of capitalization"
08:29:53 <lambdabot>   Couldn't match expected type `(GHC.Types.Bool, [GHC.Types.Char])'
08:29:54 <lambdabot>          ...
08:30:01 <benmachine> > unfoldr (\b -> case b of (_, []) -> Nothing; (b, c:cs) -> Just (if b then toUpper c else toLower c, (not b, cs))) (True, "you didn't say what kind of capitalization")
08:30:03 <lambdabot>   "YoU DiDn't sAy wHaT KiNd oF CaPiTaLiZaTiOn"
08:30:09 <benmachine> yesss
08:31:38 <applicative> I think the correct answer should use conduits, like drb226 http://www.reddit.com/r/dailyprogrammer/comments/wjzly/7132012_challenge_76_easy_title_case/c5e7zpi
08:31:58 <applicative> this is title making with a list of 'exceptions' admittedly
08:36:58 <jmcarthur> applicative: why is a conduits solution better?
08:38:51 <edwardk> FreeFull: fixed
08:38:53 <applicative> jmcarthur: it isn't it's mad
08:39:12 <applicative> though no worse than an equivalently powerful lens solution ...
08:39:34 <jmcarthur> ah, i missed the part where it was a joke :)
08:39:44 <applicative> it solves various problems with space and punctuation that title-making involves
08:40:07 <applicative> jmcarthur: sorry, maybe it was obscure; it arose from the lens golfing earlier
08:40:11 <FreeFull> edwardk: Did you start with modulo and forget to change the type signature?
08:41:13 <applicative> jmcarthur: i was looking for Haskell attempts to formulate titling proper, and hit on that, which seemed pleasantly bonkers, though the writer is good, I think
08:41:48 <applicative> in general, i do prefer conduit golfing to lens golfing
08:42:06 <edwardk> FreeFull: yes
08:42:21 <jmcarthur> applicative: i like to cherry pick stuff from lens, but can't say i really like "lens style"
08:42:54 * applicative is a secret zoom enthusiast
08:43:05 <niteria> > zipWith (\a b -> if a then toUpper b else b) (cycle [True, False]) "you didn't say what kind of capitalization"
08:43:07 <lambdabot>   "YoU DiDn't sAy wHaT KiNd oF CaPiTaLiZaTiOn"
08:43:17 <niteria> unfoldr is so brutal
08:43:34 <applicative> ? It's my favorite function
08:43:44 <mauke> > zipWith id (cycle [toUpper, id]) "you didn't say what kind of capitalization"
08:43:45 <lambdabot>   "YoU DiDn't sAy wHaT KiNd oF CaPiTaLiZaTiOn"
08:43:55 <applicative> we just dont have enough x -> Maybe (y,x) functions
08:44:04 <jmcarthur> my main problem with unfoldr is that it's tough to write the coalgebra
08:44:09 <jmcarthur> yeah
08:44:25 <applicative> when it already exists, it's like a dream
08:44:37 <applicative> e.g. Vector.unfoldr ByteString.uncons
08:45:08 <applicative> ByteStringLazy.unfoldr ByteStringStrict.uncons
08:45:10 <applicative> etc
08:45:23 <niteria> I don't use zipWith id enough
08:46:09 <applicative> i don't include id among my list elements enough ;)
08:47:16 <applicative> > zipWith id (cycle [toUpper, id, id]) "you didn't say what kind of ..."
08:47:18 <lambdabot>   "You diDn'T sAy WhaT kInd of ..."
08:48:56 <FreeFull> > getZipList $ ZipList (cycle [toUpper, id, id, id]) <*> ZipList "You didn't say what kind of capitalisation!!!!!!!!!!"
08:48:57 <lambdabot>   "You Didn't sAy wHat Kind of CapiTaliSatiOn!!!!!!!!!!"
08:50:12 <jmcarthur> > unwords . (map . zipWith id) (toUpper : repeat id) $ words "you didn't say what kind of capitalization"
08:50:13 <lambdabot>   "You Didn't Say What Kind Of Capitalization"
08:51:45 <jmcarthur> @let asWords = (unwords .) . (. words)
08:51:46 <lambdabot>  Defined.
08:52:06 <jmcarthur> > (asWords . map . zipWith id) (toUpper : repeat id) "you didn't say what kind of capitalization"
08:52:06 <benmachine> :t asWords
08:52:08 <lambdabot> ([String] -> [String]) -> String -> String
08:52:10 <lambdabot>   "You Didn't Say What Kind Of Capitalization"
08:52:16 <benmachine> jmcarthur: nice
08:52:21 <danr> > asWords (\ (x:xs) -> toUpper x : xs) "you didn't say what kind of capitalization"
08:52:23 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
08:52:23 <lambdabot>  Expected type...
08:52:26 <danr> :(
08:52:41 <benmachine> > words "  "
08:52:42 <lambdabot>   []
08:53:39 <applicative> @type (\case ' '->toUpper;_ -> id)
08:53:40 <lambdabot> parse error on input `case'
08:53:42 <applicative> bah
08:54:22 <jmcarthur> danr: you still have to use map to get to the individual words
08:54:25 * hackagebot OpenGLRaw 1.4.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.4.0.0 (SvenPanne)
08:54:27 * hackagebot GLURaw 1.4.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.4.0.0 (SvenPanne)
08:54:34 <jmcarthur> woot opengl!
08:54:36 <applicative> scanl (\x -> case x of ' ' -> toUpper; _ -> id) ' ' "you didn't say"
08:54:48 <applicative> > scanl (\x -> case x of ' ' -> toUpper; _ -> id) ' ' "you didn't say"
08:54:49 <lambdabot>   " You Didn't Say"
08:54:58 <applicative> forgot tail.
08:56:17 <danr> jmcarthur: oh right.
08:56:48 <danr> applicative: nice
08:57:10 <jmcarthur> danr: you can use (asWords.map) pretty conveniently, though
08:57:31 <danr> > (asWords . map) (\ (x:xs) -> toUpper x : xs) "you didn't say what kind of capitalization"
08:57:35 <lambdabot>   "You Didn't Say What Kind Of Capitalization"
08:58:26 <danr> > unwords [ toUpper x : xs | x:xs <- words "I find this style easiest to read and maintain" ]
08:58:28 <lambdabot>   "I Find This Style Easiest To Read And Maintain"
08:59:06 <jmcarthur> i do not :)
08:59:25 * hackagebot OpenGL 2.9.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.9.0.0 (SvenPanne)
08:59:27 * hackagebot GLUT 2.5.0.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.5.0.0 (SvenPanne)
08:59:57 <jmcarthur> or at least, list comprehensions are annoying to me because they do not compose as easily
09:02:58 <dougdougdoug> Any idea what is wrong with the cabal file http://lpaste.net/93023?
09:03:35 <dcoutts_> dougdougdoug: don't use -any
09:04:25 * hackagebot esqueleto 1.3.4.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4.2 (FelipeLessa)
09:04:46 <geekosaur> also, it should be a package name not a module name (Test.Framework)
09:09:12 <dougdougdoug> :geekosaur that was it, though I got rid of then -any first.  Thanks
09:12:25 <hpc> wow, i didn't even know -any was valid syntax there
09:13:36 <benmachine> hpc: well, it's at least redundant
09:24:55 <jd0e> hey
09:28:06 <hpaste> bennofs pasted “Var/Type length mismatch” at http://lpaste.net/93025
09:28:12 <spaceships> jmcarthur: asWords isn't coming up in hoogle, where is it defined?
09:28:52 <hpaste> bennofs annotated “Var/Type length mismatch” with “Var/Type length mismatch [Error message]” at http://lpaste.net/93025#a93026
09:29:26 * hackagebot parcom-lib 0.7.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.7.0.0 (TobiasDammers)
09:29:34 <bennofs> Does anyone have an idea what is wrong with that paste?
09:29:41 <bennofs> Or is the warning meaningless?
09:32:14 <S_J> doesnt cabal configure add pipes-network if it is imported in a module in the program?
09:32:33 <donri> S_J: no, cabal init does
09:32:35 <S_J> cabal rather seems to check the opposite, is all build-depends imported int he program
09:32:54 <S_J> donri: but doesnt init create a new cabal file as well?
09:33:15 <donri> yes
09:33:41 <donri> to add a dependency to an existing cabal project, you have to edit the cabal file yourself
09:34:26 * hackagebot daemons 0.2.0 - Daemons in Haskell made fun and easy  http://hackage.haskell.org/package/daemons-0.2.0 (AlexandruScvortov)
09:35:24 <S_J> cabal: At least the following dependencies are missing:
09:35:25 <S_J> base ==4.5.*
09:35:34 <S_J> when i run configure
09:35:51 <S_J> if not in .cabal i get     Could not find module `Prelude'
09:35:51 <S_J>     It is a member of the hidden package `base'.
09:35:51 <S_J>     Perhaps you need to add `base' to the build-depends in your .cabal file.
09:35:57 <bennofs> S_J: what does ghc-pkg list base print?
09:38:38 <S_J> a lot, base is 4.6.soemthing
09:38:47 <isomorphismes> this is not a code question but a design one.
09:40:00 <S_J> isomorphismes?
09:40:02 <bennofs> S_J: so maybe change base ==4.5* to base < 5 && base >= 4 ?
09:40:26 <isomorphismes> http://www.ctan.org/pkg/watermark → PDF → §2 the authors say they needed to use X and then release X
09:42:24 <isomorphismes> That seems totally unreasonable to me that developers should have to keep track of this kind of thing. So two questions: 1) if LaTeX (¿TeX?) were written in Haskell would this kind of thing take care of itself? 2) Surely this isn't just H; what's the property or class of languages that don't make developers worry about releasing Y after they've used it?
09:42:51 <S_J> ah got it
09:45:07 <elliott> isomorphismes: I admit I don't understand your question at all.
09:50:58 <jmcarthur> spaceships: i defined it in lambdabot myself
09:51:10 <jmcarthur> spaceships: asWords = (unwords .) . (. words)
09:51:28 <FreeFull> :t (unwords .) . (. words)
09:51:28 <lambdabot> ([String] -> [String]) -> String -> String
09:52:16 <FreeFull> > asWords head "Meow moew meow!"
09:52:18 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
09:52:18 <lambdabot>  Expected type...
09:53:00 <jmcarthur> (unwords .) . (. words)  ==>  \f -> (unwords .) ((. words) f)  ==>  \f -> (unwords .) (f . words)  ==>  \f -> unwords . f . words
09:53:20 <FreeFull> > asWords (drop 1) "Meow moew meow!"
09:53:24 <lambdabot>   "moew meow!"
09:53:37 <spaceships> thats awfully cute
09:53:40 <spaceships> thanks!
09:54:31 <wereHamster> is tehre alibrary that will pretty-print time durations (eg. "X seconds ago")?
09:54:44 <osa1> has anyone written SDL 2 bindings yet?
09:54:45 <FreeFull> I think  (a .) . (. b) is the same as a .: b
09:54:58 <jmcarthur> wereHamster: friendly-time came up in a google search for me
09:55:08 <FreeFull> osa1: I don't think so
09:55:17 <benmachine> also the same as (. b) . (a .)
09:55:29 <jmcarthur> :t (.:)
09:55:32 <lambdabot>     Not in scope: `.:'
09:55:32 <lambdabot>     Perhaps you meant one of these:
09:55:32 <lambdabot>       `.' (imported from Data.Function),
09:55:36 <wereHamster> jmcarthur: thanks. Couldn't figure out the right google kkeywords
09:56:04 <jmcarthur> FreeFull: i thought (.:) was (.).(.)
09:56:05 <osa1> FreeFull: do you know if  anyone is currently working on it?
09:56:07 <wereHamster> btw, Data.Time.Format.Human, as opposed to Format.Dog ?
09:56:17 <jmcarthur> FreeFull: which is not really the same thing, i think
09:56:21 <benmachine> wereHamster: as opposed to Machine, I suppose
09:56:25 <jmcarthur> :t \f g -> (f.).(.g)
09:56:26 <lambdabot> (b -> c) -> (a -> b1) -> (b1 -> b) -> a -> c
09:56:28 <FreeFull> @let infixr 9 .: ; (.:) = (.).(.)
09:56:28 <jmcarthur> :t (.).(.)
09:56:29 <lambdabot>  Defined.
09:56:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:56:39 <FreeFull> jmcarthur: Ah, you're right
09:56:41 <wereHamster> dogReadableTime X = "Woof Woof Wuf Rawr"
09:56:46 <jmcarthur> @pl \f g -> (f.).(.g)
09:56:49 <lambdabot> flip ((.) . (.) . (.)) (flip (.))
09:56:49 <lambdabot> optimization suspended, use @pl-resume to continue.
09:56:55 <jmcarthur> meh
09:56:58 <monochrom> Data.Time.Format.Data
09:57:46 <jmcarthur> FreeFull: i personally prefer (fmap.fmap) over (.:). the latter just seems like unnecessarily confusing infixness, to me.
09:58:12 <tomejaguar> (.:) is so lovely
09:58:38 <benmachine> jmcarthur: fmap fmap fmap!
09:58:53 <jmcarthur> benmachine: :(
09:59:52 <tomejaguar> Apparently I have 21 uses of .: in my 38k-line codebase.  More than 0.5% of my lines use .:!
10:00:05 <FreeFull> jmcarthur:   head .: map   seems so much nicer to me over   (fmap . fmap) head map
10:00:29 <jmcarthur> FreeFull: and what about when you want to go another level deeper?
10:00:47 <tomejaguar> jmcarthur: You mean .:.?
10:00:54 * jmcarthur facepalms
10:00:58 <jmcarthur> when does it stop?
10:00:59 <FreeFull> jmcarthur: .:. .:: .::. etc.
10:01:04 <jmcarthur> so arbitrary
10:01:06 <FreeFull> It stops when you run out of dots
10:01:28 <monochrom> use Template Haskell to produce more dots
10:01:31 <FreeFull> Of course all this makes concatenative programmers feel smug
10:02:09 <jmcarthur> FreeFull: these are just our own versions of stack manipulators. there isn't really a difference
10:03:00 <FreeFull> jmcarthur: I mean function composition is a no-op in concatenative languages
10:03:17 <FreeFull> (fmap . fmap) head map becomes    map head
10:03:33 <isomorphismes> elliott: It requires to read the beginning of section 2 of that PDF.
10:03:48 <tomejaguar> FreeFull: how do they distinguish between one- and two-argument functions
10:04:07 <FreeFull> tomejaguar: Functions aren't curried
10:04:15 <isomorphismes> elliott: It's a statement of the form "We needed to call X but later another common package is going to call X so we needed to restore X to the state it was given to us." That seems functional to me
10:04:24 <FreeFull> tomejaguar: Although you still get partial application
10:04:27 <tomejaguar> FreeFull: what about functions that return functions?
10:04:46 <chrisdone> partial application seems one way of describing "explicit stack"
10:04:49 <FreeFull> tomejaguar: You can do that but higher level functions involve quoting
10:05:09 <tomejaguar> isomorphismes: TeX is an astonishingly poorly designed programming language, if you are using today's standards as a judge.
10:05:21 <chrisdone> don't push enough things on the stack and the function is “partially ‘applied’”
10:05:50 <FreeFull> Which basically means that instead of writing    map (+3) [1,2,3]   you end up writing  [1,2,3] {3 +} map
10:06:16 <copumpkin> what if you want to write map (+) [1,2,3], how do you go and apply it later?
10:06:29 <copumpkin> :t map (+) [1,2,3]
10:06:30 <lambdabot> Num a => [a -> a]
10:06:39 <chrisdone> the {3 +} is a stack aiui
10:06:49 <FreeFull> copumpkin: You'll have to curry + then
10:09:26 * hackagebot pandoc 1.12 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12 (JohnMacFarlane)
10:13:22 <chrisdone> oh, i just realised what pandoc means
10:13:35 <mauke> a panda doctor?
10:13:41 <chrisdone> weird. i always read it like 'panda document', not pan- all, doc-document
10:13:43 <chrisdone> =p
10:14:01 <Rarrikins> It's a doctor for a pandemic.
10:14:14 <chrisdone> z
10:14:19 * Clint squints.
10:14:21 <monochrom> Dr. Peter Pan
10:20:54 <jmcarthur> after reading that, i still don't know what pandoc means
10:21:39 <chrisdone> pan as in "all", like panthea, panacea, pansexual, etc.
10:21:59 <jmcarthur> ah!
10:22:08 <jmcarthur> that makes sense
10:23:23 * monochrom remembers Pan Am
10:23:56 <elliott> pan am a
10:34:53 <ReinH> edwardk: that rosetta stone paper is great but damn you for adding so much to my reading list
10:34:58 <edwardk> np
10:35:25 <edwardk> it is one of those things that just takes a whole lot of obtuse subjects and makes them all make sense at the same time
10:35:51 <ReinH> yeah seems good
10:36:04 <ReinH> I am never going to finish reading this stuff
10:36:12 <edwardk> isn't that a good thing?
10:36:16 <thoughtpolice> yes, it's a very good paper. i really enjoyed it when i found it a few months ago
10:36:17 <edwardk> if you ran out what would you do?
10:36:19 <ReinH> my list is growing without bound
10:36:26 <ReinH> edwardk: ... find more stuff...
10:36:42 <edwardk> i recommend learning to read faster, how to skip details and get the gist
10:36:50 <edwardk> it helps keep the queue down
10:36:52 <ReinH> working on it
10:37:46 <edwardk> you can usually get through the introduction, most of the prose, work out an example or two, and try to get to the conclusion. i find that reading a half dozen or so papers that way before i tackle them in more depth lets me get a better sense of the importance of each relative to each other
10:37:52 <thoughtpolice> i almost always skim details in a first read to absorb it, you can always review in fine detail after you've let it settle some.
10:37:55 <edwardk> vs. how important the author of the paper _wants_ their results to be
10:38:12 <thoughtpolice> otherwise i'd probably spend like, a week per paper
10:38:35 <jmcarthur> i have a tendency to skim a set of ten or so papers multiple times over the course of a week or two
10:39:02 <jmcarthur> and then occasionally take the time to read one of them slowly if i find that it is as relevant as it seemed at first
10:39:10 <edwardk> for me it is mostly that i go looking for all of the papers in a space, then bounce off something and start chasing references
10:39:16 <jmcarthur> yeah
10:39:41 <edwardk> usually it starts by me guessing some way to do something, then going to figure out if it has been done before.
10:39:47 <ReinH> my reading list is already pretty well curated by edwardk though
10:39:50 <jmcarthur> i do sometimes find that a paper i had deemed irrelevant early on turns out to be the best one. i am not good at filtering accurately
10:40:07 <ReinH> it's just daunting
10:40:37 <edwardk> i'll say for me the best trick i know for reading papers is to go in like you want to tear down some core aspect of their premise. remove one of their constraints, do it in a more general setting, and work through the paper. if it works, you're a genius. if it doesn't, you get insight into why those constraints are there
10:40:59 <S_J> does anyone have a good .gitignore file for haskell?
10:41:03 <edwardk> that insight is really the main thing the authors gained from writing the paper in the first place
10:41:18 <edwardk> S_J: https://github.com/ekmett/lens/blob/master/.gitignore
10:42:05 <jmcarthur> edwardk: do you have a recent example of this in mind? i don't often find myself inclined toward the adversarial approach to reading papers, but i realize there is probably value in it
10:42:36 <edwardk> the cach oblivious lookahead array paper uses fractional cascading, but if you remove it and replace it with a bloom filter, you get a simpler, faster result
10:43:26 <edwardk> daan leijen's work on a revision control monad laments the fact that he has to use full threads and complains about having to kill unused tasks,  so i tackled it with sparks instead
10:43:30 <ReinH> S_J: https://github.com/github/gitignore/blob/master/Haskell.gitignore
10:43:57 <edwardk> lowest common ancestor is done with preprocessing because the naive algorithm was seen as O(h). fixed that ;)
10:44:02 <thoughtpolice> edwardk: you mean the Concurrent Revisions work?
10:44:07 <edwardk> thoughtpolice: yes
10:44:16 <thoughtpolice> re: daan
10:44:26 <edwardk> thoughtpolice: that is what i was starting to lead up to with the LCA post
10:44:44 * thoughtpolice has not read over edwardk's recent posts in the past 2 days
10:44:46 <edwardk> thoughtpolice: if i do a follow up i'll likely go into how to do the spark-based concurrent revisions
10:45:00 <edwardk> and then show how to do record
10:45:01 <thoughtpolice> edwardk: i thought the concurrent revisions paper was pretty interesting, so sign me up!
10:45:24 <edwardk> but i wanted the LCA post so i could show how skew binary worked, so i could use it in the explanation of the COLA
10:45:59 <edwardk> jmcarthur: lets me dig further back. speculation started as me challenging the assumption that speculation should be a 15 page paper.
10:46:34 <edwardk> lens started with me challenging the idea that shrinkling monads in the definiton of a lens was the best way to generalize them
10:46:54 <benmachine> edwardk: are these tips for people who want to read papers, or write them? :P
10:46:59 <edwardk> analytics with the fact that a b-tree was the best way to represent lots of data
10:47:44 <edwardk> benmachine: i read papers by picking some assumption the paper makes and ripping it out. it fails more often than it works, but it definitely helps me appreciate the motivation for all the constraints the paper writer put down
10:48:34 <edwardk> otherwise they seem like magic. the hard part of science in general is formulating the hypothesis, so the better i can model the understanding of the author the better i can grasp why they chose that particular hypothesis
10:48:59 <thoughtpolice> edwardk: i need to get back to looking at what you've done with the COLA stuff in structures, but i still like the bloom filter approach for its great simplicity. have you looked over the Bw-tree paper stuff?
10:49:14 <thoughtpolice> well, 'the' paper
10:49:15 <edwardk> thoughtpolice: i currently have the bloom filters disabled
10:49:23 <edwardk> they aren't carrying their weight in terms of constant factors
10:49:24 <elliott> edwardk: I remember that lens library with two monads wedged in.
10:49:32 <elliott> I remember the tears...
10:49:32 <edwardk> elliott: *shudder*
10:50:12 <edwardk> i also would like to note the relative paucity of examples that generalization seems to have led to compared to the profusion of traversals, prisms, etc. that we get from the lens-style generalization
10:51:07 <FreeFull> Wedging monads into random places sounds painful
10:51:10 <edwardk> worrying that particular bone long enough finally paid off
10:51:49 <edwardk> FreeFull: that's pretty much my assessment
10:51:49 <edwardk> the lens clearly wasn't a willing participant
10:53:19 <jfischoff> are there any haskell libraries out there that encode JSON faster than aeson?
10:53:41 <jfischoff> encoding to ByteStrings that is
10:54:22 <jfischoff> Constructing all of the HashMaps just to tear them down seems wasteful
10:54:44 <elliott> edwardk: I'm just annoyed that twanvl figured out all this stuff years before we did but wrote it off as not useful in practice :)
10:55:47 <edwardk> jfischoff: write one!
10:55:47 <edwardk> when i release a semi-indexing library then between us we can take over the web
11:00:10 <jfischoff> edwardk: your on!
11:00:40 <edwardk> i figure twanvl has to find it amusing that people keep rambling on about that old one-off post ;)
11:00:41 <monochrom> :S
11:00:57 <twanvl> :)
11:00:59 <edwardk> and that his FunList stuff also turned out to be so damn useful for the same thing
11:05:10 <S_J> i assume there is a Module that provies stuff to parse command line arguments passed to a program. what is it called?
11:06:25 <monochrom> optparse-applicative. there are others. but I recommend optparse-applicative
11:07:05 <edwardk> +1 for optparse-applicative
11:07:43 <monochrom> but you could also say, System.Console.GetOpt already comes with GHC
11:09:59 <thoughtpolice> optparse-applicative is great. i've come to like it much more than any of the alternatives
11:13:01 <edwardk> the best endorsement i can give it is that i was going to write my own, then tried it and stopped bothering. ;)
11:14:10 <monochrom> the edwardk's seal of approval
11:14:23 <monochrom> err, s/the/
11:14:36 <Yaniel> hehe
11:14:41 <edwardk> I think I use at least 3-4 libraries i didn't write.
11:15:00 <edwardk> Give me a minute and I'll come up with them =P
11:15:31 <monochrom> base, ghc-prim, stm :)
11:25:09 <S_J> how do I make a HUnit testsuite fail if it fails. (the testlogfile says it failed but i think you have to return some errorcode form the program too)
11:25:27 <niteria> (.) f g x = f (coerce (g x)) -- yay php
11:26:26 <enthropy> is cabal-install supposed to update the documentation index even when you installed no documentation?
11:32:52 <Saizan> enthropy: i don't think so
11:33:38 <Sonarpulse> edwardk: is there any way to "flatten" sum types with generics
11:34:20 <Sonarpulse> so for example with data Asdf = A | B | C | D Int Int
11:34:54 <Sonarpulse> the derived Bytes instance would put D Int Int
11:34:55 <edwardk> the way i do it is by using a lot of typeclass hackery
11:35:02 <edwardk> its a pain in the ass
11:35:08 <edwardk> i haven't adapted that to Bytes
11:35:13 <edwardk> but that is a good idea
11:35:47 <Sonarpulse> yeah, I wish the GHC devs had made sum type a newtype on list so we wouldn't have this problem
11:36:17 <edwardk> you wind up needing to have two classes or a class with two parameters for how it works when being made part of a sum and how it works otherwise
11:36:18 <Sonarpulse> nvrmind that wouldn't work. but surely there is a better way
11:36:53 <joelteon> vim2hs doesn't recognize multiline comments, does it?
11:37:01 <joelteon> or am I doing something wrong?
11:37:15 <Sonarpulse> Ok. (nvmind... was my list suggestion)
11:37:31 <Sonarpulse> Also, I am sorry, but I just realized that the GSerialEndian I wrote makes no sense
11:38:29 <Sonarpulse> in the current release. I think when we combined SerialLE and SerialBE, I broke it combining the serial isntances
11:38:29 <edwardk> hah
11:38:42 <S_J> So how do you make HUnit return error when there is an error?
11:39:02 <Sonarpulse> *combining the GSerial instances
11:39:33 <edwardk> i'm probably going to write a few new MonadPut and MonadGet instances soon
11:39:54 <edwardk> i can compute CRCs and lengths with them via "Put transformers"
11:40:00 <Sonarpulse> oh cool, for what?
11:40:13 <edwardk> and i can compute the CRC and length while loading via a get transformer, so you can know how much you read or the crc of what you read
11:40:42 <edwardk> and if i use identity as the identity put basis then they work just like normal monad transformers
11:40:54 <edwardk> e.g. instance MonadPut Identity -- which doesn't do anything
11:41:14 <edwardk> and then instance MonadPut m => MonadPut (CRC32T m) where ...
11:41:34 <Sonarpulse> intersting
11:42:31 <Sonarpulse> lastly, what do you think of using your unsigned and signed data families in polymorphic instances?
11:42:44 <edwardk> ?
11:42:48 <Sonarpulse> instance (Unsigned i, Signed u, SerialEndian u) => SerialEndian i where....
11:42:57 <edwardk> that isn't a sound instance
11:43:10 <edwardk> you just clobbered every other SerialEndian instance
11:43:29 <edwardk> the head (i) conflicts with every other choice of SerialEndian instance
11:43:50 <edwardk> instance resolution doesn't work like that
11:44:20 <edwardk> think of an intance like pattern matching
11:44:48 <edwardk> SerialEndian i   says pattern match on the instance's type constructors, call that i, now proceed and never look back, looking for Unsigned i. Signed u, SerialEndian u...
11:45:01 <edwardk> that 'pattern' overlaps every other possible pattern
11:45:19 <edwardk> you have to read instances backwards from the instance head
11:45:43 <Sonarpulse> Ah ok, I came across that with a project of mine using binary
11:45:52 <Sonarpulse> but doesn't overlapping instances safely resolve that?
11:46:27 <joelteon> does dag ever come in here?
11:46:38 <edwardk> no
11:46:42 <elliott> if you mean donri then yes
11:46:43 <edwardk> overlapping instances are not a good idea
11:46:47 <edwardk> they don't work when you want them to
11:46:58 <edwardk> they cause problems with other language features like constraint kinds
11:47:04 <joelteon> whoever dag is
11:47:06 <joelteon> the person that wrote vim2hs
11:47:16 <edwardk> if you find yourself reaching for them, back away slowly and re-evaluate your solution =P
11:47:48 <edwardk> in general overlapping instances only _ever_ properly fire if the instance that is 'too big and overlaps' and the more specific instance are both defined in the _same_ module.
11:48:16 <edwardk> if you define a later refinement in another module, overlapping instances can _very_ easily miss giving that instance a chance to fire!
11:48:28 <levi> chrisdone: So, I saw an interesting page where a guy is implementing a LuaJIT bytecode interpreter in javascript and trying to find the fastest way to do 'goto'-style jumps. It turns out the way that's fastest for Chrome is slowest for Firefox, and vice versa.
11:48:28 <jmcarthur> sometimes i am able to come up with types that guarantee properties i want but am dumbfounded when i try to figure out how to resulting code works
11:48:34 <elliott> compare https://github.com/dag and /whois donri :)
11:48:43 <Sonarpulse> ok
11:48:46 <Sonarpulse> good to know
11:48:52 <edwardk> this means that you should only ever use overlapping instances in the few cases where you expect a closed universe and are closely supervised by both oleg and simon ;)
11:49:03 <joelteon> oh neat
11:49:31 <edwardk> joelteon: thats donri
11:49:41 <joelteon> i hope donri comes back eventually because his screenshots are confusing
11:49:45 <jfischoff> edwardk: and your fine with very few people understanding your code :p
11:49:56 <edwardk> jfischoff: heh
11:51:39 <Sonarpulse> can something be done with SerialEndian (Unsigned i)
11:51:54 <Sonarpulse> and somehow add constraints to show that Unsigned is invertable?
11:53:12 <Sonarpulse> like (Signed u ~ i, Unsigned i ~ u)
11:53:46 <DMcGill_> make an Iso between Signed and Unsigned?
11:53:55 <jfischoff> or (Signed (Unsigned i) ~ i)
11:54:18 <jfischoff> I don't know why I said that, I have no idea what you are trying to do :p
11:54:39 <Sonarpulse> (Signed (Unsigned i) ~ i) might be good because (Unsigned Word__) is defined
11:54:46 <DMcGill_> well, just putting such constraints on all the functions that use them isn't a great idea I don't think
11:54:47 <jfischoff> there is a trick with associated types that uses a constraint like that
11:54:51 <DMcGill_> I mean it works for Data.Set
11:55:15 <edwardk> Unsigned is a typeclass, so no
11:55:55 <edwardk> Signed (Unsigned i) ~ i also doesn't hold. since Unsigned Word32 ~ Word32. it is however, idempotent
11:56:37 <jfischoff> I find I any time I think I am being clever with type system, something later breaks with either my code of GHC. Simple is safest.
11:59:45 <jmcarthur> edwardk: you may be interested to know that i have found a way to perform reductions under lambdas with generalized de bruijn indices without having to fully collapse them. you are only required to push a succ node down if it is immediately above a lambda.
12:00:22 <edwardk> sounds right
12:00:34 <jmcarthur> edwardk: unfortunately, this is tough with Bound. i ended up having to do something like   Term (Maybe (TermWithoutLambda a))
12:00:51 <Sonarpulse> well isn't the (Signed (Unsigned i) ~ i) restriction what we are looking for because we don't want to define instances like like SerialEndian (Unsigned (Usigned Word32))
12:00:58 <edwardk> yeah, daan leijen calls those rho terms i think
12:01:23 <edwardk> Unsigned is a type family. you can't dispatch on it
12:02:02 <edwardk> you can't define any instances on Unsigned Foo
12:02:14 <jmcarthur> edwardk: oh is there some paper this was done before?
12:02:15 <edwardk> you can define them on what Unsigned Foo evaluates to, and you can put constraints on that
12:02:21 <edwardk> jmcarthur: not exactly
12:02:31 <edwardk> jmcarthur: but its based on insights from working on HMF
12:02:36 <Sonarpulse> that is true for all type functions, right?
12:02:42 <edwardk> Sonarpulse: sure
12:03:07 <Sonarpulse> ah ok, and if you define it based on what it evaluates to, then you are stuck with the overlapping isntances problem again.
12:04:03 <jmcarthur> edwardk: ah. i discovered it playing with hereditary substitutions (i wanted a type for beta-normal form with generalized de bruijn indices)
12:05:45 <jmcarthur> edwardk: it worked out in my favor because i already had a TermWithoutLambda due to the usual representation of beta-normal terms
12:06:51 <jmcarthur> not sure if this result quite counts as hereditary subtitution, since there is a sense in which these are not fully normalized, but it seems morally okay at least
12:06:53 <S_J> HUNIT HUNIT  So how do you make HUnit return error when there is an error? Now it says tests PASSED even when the log shows they failed
12:07:51 <joelteon> S_J: you have to run them yourself, and exitFailure if there are any errors
12:07:56 <joelteon> had that same problem
12:12:10 <Sonarpulse> jmcarthur: was it you a couple of weeks ago talking about redoing GHC's build system with shake?
12:13:46 <jmcarthur> Sonarpulse: no, although i do remember somebody saying something about this...
12:14:11 <jmcarthur> Sonarpulse: i think carter had said some stuff about it, but i don't think he was interested in doing it himself. maybe he knows who was thinking about doing it, if anybody?
12:14:13 <S_J> joeltoon: how do I exitFailure?
12:14:45 <geekosaur> import System.Exit; exitWith ExitFailure
12:14:46 <DMcGill_> @hoogle exitFailure
12:14:46 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
12:14:46 <lambdabot> System.Exit exitFailure :: IO a
12:15:01 <DMcGill_> don't even need exitWith
12:15:05 <geekosaur> oops, right, wants an exit code
12:15:25 <Sonarpulse> thanks.
12:18:46 <hpaste> enthropy pasted “alternative to overlapping type family” at http://lpaste.net/93030
12:19:46 <td123> hello, I'm looking to play some audio from a stream (contains the audio frames and metadata along with it)
12:19:53 <td123> what audio library is suggested?
12:20:04 <mangaba_leitosa>   -    finite state transducer?
12:20:06 <mangaba_leitosa> oops, sorry
12:20:08 <td123> the haskell bindings for openal seem to be dead
12:20:22 <td123> and alsa-pcm looks like an unmaintained project
12:22:17 <carter> jmcarthur: Sonarpulse : lispy knows more :)
12:29:31 <jfischoff> has anyone used this? http://hackage.haskell.org/package/json-builder
12:29:46 <jfischoff> and maybe benchmarked it against Aeson
12:30:17 <donri> joelteon: hi
12:30:22 <joelteon> hi
12:30:34 <joelteon> donri: i see that makeLens in one of your screenshots is highlighted differently
12:31:01 <donri> joelteon: i think that got removed because it wasn't reliable
12:31:02 <joelteon> for me, makeLens doesn't even have a syntax group
12:31:06 <joelteon> oo
12:31:07 <donri> old screenshots :)
12:31:10 <joelteon> what about multiline comments?
12:31:16 <joelteon> can i somehow get them highlighted as comments
12:31:23 <donri> they should be...
12:31:39 <joelteon> huh, really
12:32:05 <donri> but then i'm not even using vim2hs myself and have pulled a few untested pull requests ;)
12:32:13 <donri> so stuff could have broken
12:32:25 <joelteon> are they supposed to be a different color?
12:32:36 <joelteon> oh wait, nvm
12:32:42 <joelteon> no syntax group for those either
12:32:48 <donri> ?
12:33:03 <joelteon> http://puu.sh/4sbNO.png
12:33:03 <Sonarpulse> thanks carter
12:33:10 <joelteon> cursor is over "handler" which is highlighted as hsType
12:33:16 <joelteon> but there's nothing if I put the cursor over "a comment"
12:35:41 <donri> joelteon: ah that could be a bug with something else eating it up in that position
12:36:09 <donri> joelteon: what if you put some spaces in front of them?
12:36:17 <joelteon> hmm
12:36:35 <joelteon> let me disable rainbow parentheses, hang on
12:37:25 <donri> or it could be something like that, yeah
12:37:43 <joelteon> it was indeed
12:37:48 <donri> \o/
12:37:48 <joelteon> weird.
12:37:54 <joelteon> well i never use rbp so shouldn't be a problem
12:38:11 <joelteon> are all the parentheses supposed to be red?
12:38:23 <S_J> did anyone here ever code a database?7
12:39:12 <donri> joelteon: they're supposed to be Delimiter, which solarized helpfully decides are the most important thing ever
12:39:18 <joelteon> I see
12:39:23 <donri> joelteon: i tone it down in my solarized
12:39:23 <joelteon> should probably change that myself
12:39:52 <joelteon> what do you have in yours?
12:40:29 <donri> joelteon: i have it set as Comment but without italics
12:43:02 <Sonarpulse> my emacs+ghci has a nasty habit of :cd-ing out of the src folder when a module is :load ed
12:43:17 <Sonarpulse> like if I have project/src/module
12:43:30 <Sonarpulse> and I load the module
12:43:33 <Sonarpulse> I get in ghci
12:43:37 <Sonarpulse> :cd project
12:43:46 <Sonarpulse> :load src/module
12:44:03 <Sonarpulse> which naturally prevents GHC from finding other modules in the project
12:44:17 <Sonarpulse> does anybody know a solution to this?
12:44:30 * hackagebot inspection-proxy 0.1.0.2 - A simple proxy for debugging plaintext protocols communication  http://hackage.haskell.org/package/inspection-proxy-0.1.0.2 (MariusGhita)
12:45:14 <joelteon> oh, that is better
12:45:14 <carter> Sonarpulse jmcarthur  theres a few folks who want to work on it
12:45:43 <Sonarpulse> ^ GHC  build system you mean?
12:46:03 <Sonarpulse> not the emacs problem?
12:46:50 <benmachine> Sonarpulse: I don't really understand your problem but you might be able to use :set -isome/include/dir
12:47:01 <benmachine> to make GHC look in additional places for files
12:50:18 <Sonarpulse> thanks. The problem is haskell mode in emacs tries to help by automatically telling ghci to chagne to what is the root of your source tree
12:50:27 <jcande> I'm having some issues with mapArray, as far as I can tell. I'm trying to implement the mersenne twister prng and STArrays seem like the best bet. Here's the code: http://lpaste.net/6983931047398342656 . Any help or direction is appreciated
12:50:53 <carter> yes
12:50:57 <carter> for ghc build system awesomes
12:51:31 <Sonarpulse> ^cool
12:51:49 <Sonarpulse> benmachine: that feature is great if it gets it right. But here it gets it wrong, I don't know how to correct it nor tell it to stop trying.
12:51:51 <johnw> stepcut: hello! :)
12:52:46 <WraithM> johnw: Nice meeting you yesterday!
12:52:56 <johnw> you too, WraithM!
12:52:57 <WraithM> stepcut: Nice meeting you as well!
12:53:06 <johnw> it's fairly rare that I get to talk to physically-present people about Haskell
12:53:28 <WraithM> Yep, me too
12:53:36 <WraithM> lol
12:56:46 <DMcGill> jcande: change "g :: ST s ..." to "g :: forall s. ST s ..."
12:57:17 <DMcGill> if that still doesn't work, remove that signature completely and specificy the list as Int somewhere else
12:57:49 <DMcGill> same with the type of Transform - you need "forall s. ST s ..." there
12:58:31 <jcande> it's yelling at me about an illegal '.' in the type
12:58:57 <WraithM> johnw: I'm installing coq now. I've been meaning to go through Software Foundations for a while.
12:58:59 <jcande> if I remove the "elems" before runSTArray, and replace (transform a) with id in the arguments to mapArray, it compiles
12:59:03 <enthropy> jcande: you forgot a `return' on your line 278
12:59:20 <DMcGill> remove all the type annotations with ST in
12:59:35 <enthropy> hmm, or not
12:59:38 <DMcGill> or you can add an extension to allow foralls in types
13:00:00 <DMcGill> the name of which I can't remember off the top of my head right now but I'm sure somebody here knows
13:00:10 <johnw> WraithM: beware, addictive :)
13:00:15 <WraithM> :D
13:00:21 <DMcGill> also enthropy is right
13:00:32 <DMcGill> ah wait
13:00:34 <hpc> RankNTypes implies the appropriate extension
13:00:47 <jcande> I thought it was just a function from e' -> e
13:00:48 <DMcGill> you can't end a do block without still being in that monad
13:00:57 <jcande> ah, ok
13:01:03 <DMcGill> transform needs to end in an ST s Int
13:01:13 <hpc> use the types, DMcGill
13:01:21 <hvr> Sonarpulse: inf-haskell or haskell-interactive?
13:02:33 <jcande> is there a way to read values from STArray without ending up in another monad?
13:03:18 <jcande> I was hoping letting mapArray handle all of the updates would keep me nice and ignorant of what is going on
13:04:06 <jcande> this is my first time dealing with ST and STArray and all that too, so apologies if I'm coming off as a bit dense
13:04:46 <DMcGill> mapArray is not what you want to do - it only lets you inspect each element of the array individually one at a time
13:04:48 <benmachine> jcande: you can only read values from an STArray inside the ST monad, because your reads have got to be sequenced with respect to the appropriate writes
13:05:19 <jcande> ok, dag. That is disheartening
13:05:44 <benmachine> jcande: you can turn an STArray into other kinds of array, as you've done with runSTArray
13:05:46 <NemesisD> anyone use travis CI for builds? especially with lots of deps
13:06:38 <NemesisD> before i was getting this build failure https://travis-ci.org/MichaelXavier/vigilance/builds/11223235 forcing reinstalls times out https://travis-ci.org/MichaelXavier/vigilance/builds/11374217
13:06:57 <jcande> benmachine: I was thinking about that, but I don't think I could access any subsequent updates so some of the new array would be incorrect from the stale values
13:07:08 <jcande> but I'm not sure
13:07:42 <benmachine> jcande: right, that's kind of by design
13:07:59 <jcande> alright that makes sense
13:08:01 <DMcGill> STArrays are mutable and give you inplace updates. Once you freeze it with runSTArray, then it's immutable and you can't update it like that anymore
13:08:12 <jcande> but it wouldn't be useful for this, I guess
13:08:28 <bennofs> NemesisD: Maybe you can steal the script that installs some of the dependencies via apt-get from lens
13:08:49 <jcande> basically, I just want to replace each element in the array, one at a time, based on other values in the array
13:08:57 <jcande> so after I finish traversing, it can be frozen
13:09:13 <benmachine> jcande: right
13:09:14 <jcande> but until I reach the end, I can access any element at will (and have it be the most recent edit)
13:09:29 <jcande> so STArrays and not using mapArray would be the solution then?
13:09:49 <DMcGill> jcande: try: mapM_ (f array) [lower bound .. upper bound]
13:10:00 <jcande> alright, thanks
13:10:15 <jcande> really appreciate the help guys
13:10:32 <benmachine> jcande: do you actually use the first component of g anywhere?
13:10:44 <jcande> in other functions, but not in here
13:10:56 <jcande> I should rename it from test to something more descriptive, but it started out as me just playing with STArrays
13:10:58 <DMcGill> where f array i = do {value <- readArray array i; e <- readArray array (res $ i+1); e' <- readArray array (res $ i+mersennePeriod); ...}
13:11:17 <DMcGill> taking care to deal with indexing errors
13:11:23 <jcande> DMcGill: awesome, thanks
13:11:44 <benmachine> fair enough
13:12:26 <DMcGill> that way you map over the indexes (meaning you don't need to zip them in first), you traverse each element one at a time and you can access the rest of the array at any time.
13:12:36 <benmachine> jcande: also, you know there are already Haskell mersenne twister libraries, right?
13:13:16 <jcande> DMcGill: smart. I was feeling a bit annoyed at that zip
13:13:30 <jcande> benmachine: I figured, but I just wanted to get more experience with a real problem and haskell
13:13:46 <jcande> I like the language but don't use it enough to gain real understanding
13:13:54 <jcande> so I am just kind of forcing things
13:14:01 <benmachine> jcande: sure, that's a sensible reason, just wanted to make sure you knew :)
13:14:06 <DMcGill> remember to "return $ e' `xor` (x `shiftR` 1) ..." as the last statement of the do block that is f
13:14:06 <jcande> I don't plan on using this for anything serious :)
13:14:07 <jcande> thanks
13:15:11 <DMcGill> wait no, you have to options: inplace update in the array
13:15:26 <DMcGill> in which case the last statement of f needs to be "writeArray array i ..."
13:16:12 <DMcGill> and you need mapM_ instead
13:16:20 <jcande> oh sure
13:16:23 <DMcGill> OR collect the results in a list, by using return as the last statement of f
13:16:52 <DMcGill> leaving the STArray untouched - but if you do that, you don't need inplace updates and can use a normal array rather than a mutable one
13:17:08 <DMcGill> s/to/two
13:17:29 <jcande> oh I see
13:18:01 <jcande> I'll play around with it a bit and see if I can cobble something together
13:20:23 <S_J> how do I cbala confugre disbale tests?
13:21:28 <bennofs> S_J: cabal configure --disable-tests?
13:22:17 <johnw> can "cabal sandbox" install an alternate GHC to use, the way that hsenv can?
13:22:52 <benmachine> johnw: I don't believe so, but I have several GHCs installed systemwide and they don't tread on each other
13:23:12 <johnw> well, it's not just for me, I ask because our build system currently depends on this
13:23:26 <johnw> it downloads a GHC tarball via git-annex and then uses hsenv to install it as a local environment and build within it
13:23:50 <johnw> i may just have to do what hsenv --ghc is doing manually first, fix up the envvars, etc.
13:25:45 <NemesisD> i've got a project with a client/server component. they both share code with eachother but in some installations, you'll want the client binary and server binary, some you'll just want the client
13:25:58 <NemesisD> should i use a cabal flag for this?
13:26:16 <elifrey> iset
13:26:29 <benmachine> NemesisD: sounds like a reasonable idea
13:26:45 <enthropy> NemesisD: in one cabal file you can have a bunch of executables and a library
13:26:54 * elifrey accidentally forgot his /
13:27:14 <enthropy> which I guess you know about
13:27:54 <NemesisD> enthropy: yeah its just that the server component has a lot more dependencies to it. the project's typical deployment would be 1 machine with the server component, and then installing the client component on N other machines
13:29:17 <enthropy> all those extra dependencies might not get drawn in by the library part?
13:29:52 <NemesisD> enthropy: they have a separate list of dependencies, the client executable and the server executable
13:30:16 <NemesisD> most notably, the server executable relies on yesod
13:30:58 <S_J> is there no simple command line parser?
13:31:10 <S_J> i just want tosafely access command line args
13:31:18 <enthropy> S_J: what did you try?
13:31:22 <S_J> how can that be advanced like opt-parse
13:31:31 <S_J> maybe i should just roll my own
13:31:37 <NemesisD> ive used at least 2 or 3 command line argument parsers and i wouldn't consider any that simple
13:31:38 <enthropy> "simplest" might be System.Environment.getArgs
13:31:47 <NemesisD> i like optparse-applicative but it is not necessarily simple
13:33:18 <bennofs> cmdargs is "simple" imo
13:35:48 <elifrey> I second opt-parse
13:36:28 <elifrey> I think cmdtheline is more simple, but I've stopped maintaning it so :P
13:37:41 <donri> name rather sucks though :P
13:37:53 <donri> spelling optparse-applicative is about as fun as digestive-functors
13:39:09 <donri> S_J: if you want simple but still safe try simpleargs
13:39:39 <Sonarpulse> hvr?
13:39:45 <Sonarpulse> refering to my emacs problem?
13:40:17 <Sonarpulse> inferior haskell I think
13:41:14 <elifrey> ah! it looks like Paolo stopped working on optparse around the same time I stopped working on cmdtheline. Maybe I should get back on that horse
13:42:09 <donri> elifrey: you should collaborate because optparse does bash completions and i personally like its design better, but yours did manpages...
13:43:20 <NemesisD> hmm looks like you can't wrap executable sections in If flag() clauses in cabal
13:43:24 <bennofs> optparse-applicative is unmaintained? :O
13:43:34 <donri> NemesisD: buildable: False
13:43:57 <donri> NemesisD: you probably want to wrap the build-depends in an "else" for that too
13:44:01 <elifrey> bennofs: I don't know about that, stail might be a better word
13:44:18 <elifrey> now that I'm looking at the commit logs, mine is more stail :)
13:44:41 <NemesisD> donri: ah ok. thank you!
13:45:28 <bennofs> wow. Even cabal update on travis gives a timeout
13:47:42 <NemesisD> i have not been thrilled with travis' level of haskell support
13:49:50 <deech> Are there examples of binding a C linked-list to a Haskell list?
13:51:38 <NemesisD> but ocharles endorsed optparse-applicative :(
13:52:14 <S_J> why does print print the "" in the shell?
13:52:45 <bergmark> bennofs: wrap stuff in travis_retry
13:52:59 <elifrey> deech: how do you mean?  do you want to provide C linked-lists as an implementation of the list Abstract DataType, or do you want to turn a C linked list into a Haskell linked list?
13:53:02 <Rarrikins> S_J: Because it uses show.
13:53:12 <Rarrikins> S_J: You can use putStrLn instead.
13:53:52 <michas> Hi, a literal number |5| can just be any Num type. But writing |read "5" :: Num| does not work. Why is this? And what does the resulting "Expecting one more argument" message mean?
13:54:02 <NemesisD> ugh is there no way to embed a url into haddock with link text different than the url
13:54:17 <elifrey> michas: Num is not a concrete type
13:54:21 <elifrey> it is a typeclass
13:54:33 <elifrey> you have to pick the concrete instance of num you want
13:54:44 <elifrey> read "5" :: Int
13:55:21 <michas> elifey, but just writing 5 does not force me to pick a concrete instance of num...
13:55:28 <bennofs> NemesisD: there is. I think th syntax is something like <url name>
13:55:41 <enthropy> NemesisD: <http//blahblah what appears in the text>
13:55:41 <deech> elifrey: Basically want to be able bind something like `typedef struct Payloads { int payload; struct LinkedList* next;} Payloads` to `data Payloads = Payloads [CInt]`
13:55:52 <michas> elifrey, but just writing 5 does not force me to pick a concrete instance of num...
13:55:57 <Rarrikins> You can also use read "5" :: (Read a, Num a) => a
13:56:14 <DMcGill> michas: Num defaults to Int
13:56:48 <benmachine> michas: the expecting-argument bit is because Num is a typeclass, so (Num a) is a constraint that says a has to have an instance of Num
13:57:02 <benmachine> michas: so Num expects an argument, if it is going to appear in a type
13:57:37 <michas> benmachine, ah, that makes sense, thanks.
13:57:54 <elifrey> deech: I don't think you can do that.  You need to turn your C linked list into a Haskell linked list.
13:57:57 <DMcGill> although bear in mind that if you use functions like "/" on this unspecified type, then it won't default to int anymore
13:58:22 <DMcGill> type inference is cool
13:58:40 <michas> Rarrikins, I think this is exactly what I was looking for. - How could I find out this by myself?
13:58:59 <DMcGill> michas: have you read Learn You A Haskell?
13:59:13 <DMcGill> It covers typeclasses, constraints, Num and Read
13:59:31 <michas> DMcGill, I just started reading it.
14:00:14 <bennofs> Does cabal 1.18 require the use of sandboxes?
14:00:24 <benmachine> bennofs: no
14:01:28 <bennofs> benmachine: Oops. I had a cabal.sandbox.config in that project
14:04:21 <applicative> bennofs: cabal sandbox delete
14:04:52 <bennofs> applicative: or just rm cabal.sandbox.config. I didn't actually have a .cabal-sandbox dir
14:05:02 <applicative> ah
14:06:49 <Rarrikins> michas: It just depends on knowing about typeclasses and the syntax. I'd also recommend a book like Learn You A Haskell, but a short intro is that Num is a typeclass, which isn't a type but a whole collection of similar-in-some-way types. When you write Num a, it means that a is one of the Num types. You can declare that any of your type variables are in any typeclass by putting them to the left of => as well (like I did with (Read a, Num a), 
14:09:51 <khyperia> Is Learn You A Haskell online somewhere? Is it (legally) somewhere free to obtain? I really want to read it.
14:10:05 <bennofs> khyperia: it's freely available online, legally
14:10:11 <elliott> @where lyah
14:10:11 <lambdabot> http://www.learnyouahaskell.com/
14:10:18 <khyperia> Ah. Thanks.
14:11:22 <khyperia> ... I like how "Hello, world!" is chapter nine.
14:12:00 <bennofs> NemesisD: I think in your case it's totally worth the time to install cabal 1.18 on travis and build the packages in parallel: https://travis-ci.org/bennofs/vigilance/builds/11392875
14:13:15 <appendonly> Rarrikins: thanks for that explanation :-)
14:14:15 <dcoutts_> bennofs, NemesisD: the previous release also did parallel builds of independent packages
14:14:24 <Rarrikins> No problem
14:14:31 <bennofs> dcoutts_: travis uses cabal 1.14
14:14:37 <bennofs> (by default)
14:14:57 <dcoutts_> ah
14:15:28 <bennofs> dcoutts_: btw, why does cabal compile files twice when installing Cabal?
14:15:44 <dcoutts_> bennofs: it's bootstrapping using itself
14:15:58 <dcoutts_> the Setup.hs uses the local Cabal sources
14:16:08 <bennofs> Is there a way to bootstrap using an older cabal?
14:16:19 <dcoutts_> no, it's using the local code
14:16:39 <dcoutts_> and Cabal relies on that, so it can use recent features
14:17:07 <dcoutts_> bennofs: I mean you could, but it's not supported
14:17:19 <dcoutts_> no guarantee it'll work
14:17:34 <dcoutts_> just compile the Setup.hs against the package rather than the local files
14:17:42 <johnw> dcoutts_: hi!
14:17:51 <dcoutts_> hia
14:17:54 <johnw> dcoutts_: how do you recommend going about using a custom GHC within a cabal sandbox?
14:17:58 <johnw> ala hsenv --ghc=TARBALL?
14:18:30 <dcoutts_> johnw: same as with normal cabal, just give the path to the ghc you want to use
14:18:42 <johnw> ok
14:18:44 <dcoutts_> so you can use whichever install you like
14:19:40 <dcoutts_> johnw: that works fine, I use it all the time
14:36:16 <Sonarpulse> edwardk: I wonder if some template haskell would be easier than crazy multiple type classes for the generics problem
14:38:40 <Sonarpulse> I think I'll make a github issue about it
14:39:07 <edwardk> Sonarpulse: ?
14:39:44 <edwardk> template haskell is worse in that it requires action on the behalf of the user and screws up profiling
14:40:27 <Sonarpulse> didn't know about profiling issues
14:41:09 <flebron> What would be a bad side effect of memorizing f x in let g x = f x + f x?
14:41:38 <hpc> flebron: map g [1..]
14:41:43 <hpc> poof, leak
14:41:56 <flebron> Ignorant question: Why is that a leak?
14:42:15 <flebron> (Suppose f t = length [1..^t] for instance)
14:42:22 <flebron> err, 1..t.
14:42:35 <Peaker> hpc: I suppose he means memoizing it in the context of g (and after g returns, forget about it)
14:42:48 <hpc> what Peaker says makes more sense
14:42:58 <Peaker> basically local CSE
14:42:59 <mauke> I think flebron means CSE, not memoization
14:43:04 <hpc> and is what i was going to suggest, since "memorizing" implies at top-level
14:43:13 <flebron> Oh, OK,  no, I meant within that expression.
14:43:19 <hpc> so you would have g x = let y = f x in y + y
14:43:26 <sipa> flebron: you mean turning it i to let t = f x in t + t
14:43:27 <flebron> Saying "I have something of the form Q + Q, let's compute Q and reuse its result."
14:43:32 <flebron> Sure.
14:43:57 <flebron> Is there any formal issue with that?
14:44:03 <flebron> Does something break?
14:44:27 <hpc> no
14:44:35 <hpc> well, maybe
14:44:51 <hpc> if you are the kind of horrible person who uses unsafePerformIO for side effects, they will only run once
14:45:22 <joelteon> just tried it, q is evaluated twice
14:45:22 <flebron> If no unsafe things were used, this is formally the same?
14:45:40 <hpc> yes
14:45:47 <sipa> it's really just applying referential transparency
14:46:13 <sipa> so yes
14:47:04 <enthropy> is it possible to make Fun and Fun' one constructor in http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-FakePrelude.html#t:Fun ?
14:47:10 <Peaker> flebron: for "g" specifically, CSE would make sense. For other cases, it may not make sense. GHC lets you partially control it by using (monomorphic/unclassy) name binders as hints to do CSE, and applications to do no CSE.
14:47:14 <flebron> Does ghc ever do that? Transform g x = f x + f x into g x = let t = f x in t + t, I mean.
14:47:59 <hpc> flebron: no
14:48:22 <Peaker> enthropy: you could parameterize it on the direction of the arrow or the func type itself, but that doesn't sound like a good idea
14:48:57 <hpc> flebron: it is a hard (undecidable) problem to figure out when such a thing would introduce a space leak (which it can)
14:49:47 <benmachine> hpc: it may be a hard problem with easy subcases
14:50:03 <benmachine> it's only undecidable to do it in general, that's pretty far from it never being a good idea
14:50:27 <hpc> well yeah
14:50:31 <benmachine> flebron: personally I'm inclined to say it's good practice to do it yourself anyway
14:50:31 <enthropy> Peaker: so you mean something like     data Fun arr cxt getOther = Fun (forall a. FunCxt cxt a => a `arr` FunApp getOther a)?
14:51:14 <dwcook> hpc, could you link to something with details on why that's undecidable?
14:51:48 <Peaker> enthropy: yeah, but why?
14:51:50 * enthropy is wondering if ghc could figure out which direction it should go when you just say Fun
14:51:51 <hpc> dwcook: it's the halting problem for memory consumption
14:52:02 <ciaranm> rice's theorem
14:52:06 <benmachine> hpc: probably more like rice's... yeah that
14:52:17 <benmachine> there's still a little work to do
14:52:29 <enthropy> Peaker: well now you need to use Fun' with read, Fun with show
14:52:31 <benmachine> but it's at least very plausible that it involves working out the runtime behaviour of some code
14:52:40 <benmachine> which you can't do, statically
14:53:29 <enthropy> Peaker: also this design seems somewhat related to syb-with-class
14:53:50 <Rarrikins> What's a decent solution for queuing HTTP requests from various threads so that the requests for each specific user are executed strictly in the order they're submitted (the relative ordering for two separate users doesn't matter) and the results are returned via the function that made the request? I've got the HTTP request maker written with http-conduit, but I'm not sure how I should incorporate concurrency.
14:54:32 * hackagebot yst 0.4 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.4 (JohnMacFarlane)
14:55:17 <hpc> Rarrikins: smells like a Chan kind of thing
14:55:53 <Rarrikins> Thanks. I'll look into those.
14:55:56 <hpc> Rarrikins: you have an accept thread that pushes to the Chan, then workers take and finish the request
14:57:06 <Rarrikins> Can it have multithreaded pushing and single-threaded request-handling?
14:57:17 <hpc> sure
14:57:20 <Rarrikins> OK :)
14:57:27 <hpc> a Chan is fundamentally a threadsafe queue
14:57:36 <Rarrikins> Ahh, I see
14:58:11 <enthropy> Rarrikins: sending MVars and Chans through Chans can also be useful too
14:58:38 <Rarrikins> Yeah, I was about to ask how to get the results back, but that answers it :D
14:59:16 <joelteon> send a chan through a chan?
14:59:18 <joelteon> that sounds awesome
14:59:33 * hackagebot yst 0.4.0.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.4.0.1 (JohnMacFarlane)
14:59:53 <hpc> joelteon: in one project, i send (IO ()) through a Chan
14:59:56 <hpc> i forget why
15:00:19 <quchen> hpc: Dedicated print thread?
15:00:50 <mauke> I've sent a Chan through itself before
15:00:50 <quchen> That's typically what I use (T)Chan (IO ()) for
15:01:08 <arkeet> haha mauke.
15:01:11 <arkeet> what for?
15:01:13 <quchen> mauke: Why that? As an "answer here" channel?
15:01:21 <Rarrikins> Hmm, sending IO a might be nice. It could work like a callback or...I forget the technical term.
15:01:26 <mauke> I don't quite remember but it's in preflex
15:01:29 <hpc> Rarrikins: callback
15:01:32 <mauke> probably part of the restart logic
15:04:33 * hackagebot shelly 1.3.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.1 (GregWeber)
15:04:55 <hashTag> I'm attempting to install and run the Verilog package from hackage. It depends on Polyparse. I'm attempting to debug an issue where the polyparser can't find the EOF. I wouldn't ask here if I hadn't spent several hours trying myself.
15:05:58 <hashTag> I've narrowed it down a bit, but there's too much advance stuff going on for my newbie brain to solve it.
15:05:59 <enthropy> hashTag: what did you try? Is this a parser that other people have claimed works properly?
15:06:22 <enthropy> oh I guess it's supposed to work
15:06:28 <hashTag> I've tried 3 different version, and all of them have the same issue. One is in hackage, the other two version are on Github.
15:07:38 <hashTag> The specific error is: Left "Expected end of input (EOF)  Token KW_module \"module\" :1:1"
15:07:57 <hashTag> I found one repo on github with examples, they have the same issue.
15:08:18 <hashTag> I tried using older versions of polyparse (I'm on 1.9) but it's the same issue.
15:08:35 <Fuuzetsu> is there a reason why operator sections like (foo ++ bar ++) don't work?
15:08:51 <Fuuzetsu> > ("a" ++ "b" ++) "c"
15:08:52 <lambdabot>   The operator `GHC.Base.++' [infixr 5] of a section
15:08:53 <lambdabot>      must have lower pre...
15:09:22 <arkeet> the error message explains it.
15:09:39 <enthropy> well it could mean   (\x -> "a" ++ "b" ++ x)
15:09:45 <arkeet> but it can't
15:09:55 <arkeet> it should, but it can't.
15:09:57 <Fuuzetsu> enthropy: which is what I'd hope for and which is exactly what I have put down here
15:10:02 <arkeet> because it could only mean ("a" ++ "b") ++ "c"
15:10:07 <hashTag> I've also narrowed it down to this function: https://github.com/tomahawkins/verilog/blob/master/Language/Verilog/Parser.hs#L25
15:10:08 <arkeet> which isn't what it should mean.
15:10:19 <arkeet> and ++ is infixr
15:10:34 <arkeet> > (++ "b" ++ "c") "a"
15:10:35 <lambdabot>   "abc"
15:11:07 <hashTag> That is, everything up until that function works. The preprocesing, tokenization, etc.
15:11:09 <enthropy> arkeet: would there be an inconsistency?
15:11:54 <arkeet> enthropy: (a % b &) c  should be  a % b & c  right?
15:12:07 <arkeet> but if & has higher precedence than %, or if they have the same precedence but are infixr
15:12:11 <benmachine> enthropy: you can't have let zs = xs ++ ys in (zs ++) being different from (xs ++ ys ++)
15:12:13 <arkeet> then a % b & c means a % (b & c)
15:12:30 <khyperia> Speaking of operators... how the heck does haskell figure out precedence?
15:12:33 <hashTag> Line 78 of that file has an eof, but I'm not sure what's going on.
15:12:35 <khyperia> for custom operators
15:12:39 <benmachine> enthropy: well, in principle you could, but that would either break referential transparency or make operator sections way more complicated
15:12:49 <enthropy> benmachine: well adding a variable there is like adding some parentheses
15:12:49 <benmachine> khyperia: the default is infixl 9 but you can specify your own
15:12:54 <khyperia> ah
15:13:21 <arkeet> benj_: I don't know what it has to do with referential transparency.
15:13:38 <arkeet> it's just that there is no sane way to make sense of that section
15:13:47 <arkeet> so instead of doing something weird, it blames you.
15:13:51 <enthropy> > (let x = 2/3 in 1 / x, 1/2/3)
15:13:52 <lambdabot>   (1.5,0.16666666666666666)
15:14:03 <arkeet> > (0$0/)
15:14:04 <lambdabot>   The operator `GHC.Real./' [infixl 7] of a section
15:14:05 <lambdabot>      must have lower prec...
15:14:09 <benmachine> arkeet: I mean in the sense that you substitute the value of the variable and the meaning changes
15:14:18 <arkeet> substitute at what level?
15:14:27 <benmachine> enthropy: that's kinda weird because then if you have (xs ++ ys ++) there's no way to abstract the xs ++ ys bit
15:14:30 <joelteon> :t (3/4$)
15:14:31 <lambdabot> Fractional (a -> b) => a -> b
15:14:38 <benmachine> actually I suppose that's not so weird
15:14:51 <khyperia> does ((xs ++ ys) ++) work?
15:14:54 <arkeet> of course.
15:15:00 <benmachine> but it does at least mean that operator sections aren't ([expr] [op]) but ([weird not-quite-expr thing])
15:15:22 <khyperia> > (("a" ++ "b") ++) "c"
15:15:23 <lambdabot>   "abc"
15:15:29 <benmachine> this assuming you want (xs ++ ys ++) to translate to (\zs -> xs ++ ys ++ zs)
15:15:41 <arkeet> khyperia: it's much easier to observe when your operator isn't actually associative.
15:15:52 <hashTag> Is there any chance this is a Windows v. Linux thing? I'm on a Linux box.
15:15:53 <hpc> :t (- 5 +)
15:15:54 <lambdabot> Num a => a -> a
15:15:56 <ricree> could someone give me a hand with FFI? I'm having an issue with the linker when building.
15:16:10 <ricree> Here's a paste with my code, the error message, and my .cabal http://lpaste.net/92619
15:16:31 <Peaker> Are Int32/Word32/friends compatible with C's int32_t, etc?
15:16:35 <ricree> I have the pkgconfig-depends defined, is there something else I need to include?
15:18:07 <enthropy> hashTag: you could remove that eof... but it seems more like your file doesn't match what the module_ parser needs
15:18:35 <arkeet> Peaker: did you look in Foreign.C.Types?
15:18:45 <Peaker> arkeet: yes
15:18:53 <applicative> hashTag: did you look at https://github.com/tomahawkins/verilog it seems hackage hasn't been updated?
15:19:00 <hashTag> enthropy: It doesn't match when I do that.
15:19:11 <hashTag> applicative: Yes. I'm on v_0_1_0
15:19:19 * arkeet wonders what the question is, then
15:19:26 <Peaker> arkeet: it uses them internally, but I'm not sure it's "portable" to rely on this
15:19:30 <hashTag> My current hunch is it's windows v. linux
15:19:39 <johnw> Peaker: I can't imagine how Int32 might not be compatible with int32_t
15:19:41 <Peaker> (assuming a world where there's more than just ghc, or maybe just the next ghc version)
15:19:49 <hashTag> Is there a literal EOF character?
15:19:52 <applicative> somehow i don't think tomahawkins is much of a windows person
15:19:53 <johnw> unless you're talking about types from different machines
15:20:17 <Peaker> johnw, arkeet: Thanks, I'll go ahead with that assumption then :)
15:21:03 <hashTag> Heh.
15:21:14 <hashTag> Maybe it's an Ubuntu thing?
15:22:23 <benmachine> hashTag: would be surprising
15:22:58 <Peaker> man, what a terrible error, if you import the CInt type without the data constructor, and try to use it in FFI, it just says it's an "unacceptable type" for FFI positions, rather than saying "has no data constructor in scope" or such
15:23:12 <applicative> hashTag: just to make plain, it github repo has had more than a years worth of patches since the last hackage upload
15:23:40 <benmachine> hashTag: btw, to answer your earlier question, 'eof' doesn't match a character
15:23:42 <hashTag> applicative: I am using that newest one. But the 0.2.0 version gives me the identical error.
15:23:47 <benmachine> it matches "there is no more input"
15:24:00 <hashTag> benmachine: I see. So then that's probably not my issue at all.
15:24:06 <benmachine> (at least, I'm pretty sure, reading the source)
15:24:09 <applicative> I think  you should communicate to the github page
15:24:13 <benmachine> hashTag: is the file you're parsing publically available?
15:24:39 <hashTag> benmachine: Ok. I can live with the just the tokenizer for a few days anyway.
15:24:58 <hashTag> Thanks everyone. If anyone has a brilliant idea though...
15:25:02 <Fuuzetsu> arkeet: Well, I was just hoping that a (foo ++) would be translated to (\x -> foo ++ x) and only then checked for fixity problems at which point it would work
15:25:04 <benmachine> oh, by the source I mean docs
15:25:14 <Fuuzetsu> AFAIK TupleSections do something like this
15:25:18 <arkeet> Fuuzetsu: I still think there's no sane way to do it.
15:25:25 <arkeet> tuples are different, they always have parentheses.
15:25:32 <benmachine> Fuuzetsu: I don't think tuple sections do something like that
15:25:37 <benmachine> the question doesn't really arise with tuples
15:25:41 <Fuuzetsu> arkeet: Why? It should be a mechanical translation. And yes, tuples are different, it was just an example.
15:26:17 <arkeet> Fuuzetsu: source-string-level translations don't really make sense.
15:26:31 <Fuuzetsu> for any op ‘?’, (foo ?) or (? foo) should be perfectly doable mechanically
15:26:55 <benmachine> hashTag: soo I tried to install github verilog and got stuck on no suitable released version of vcd
15:26:58 <arkeet> you could do that at the AST level but then you could end up with something unexpected.
15:26:59 * benmachine does some more digging
15:27:00 <arkeet> which is why it's invalid.
15:27:19 <arkeet> unless the fixity works out in a way that makes sense at both levels.
15:27:23 <applicative> vcd is also on his github site of course
15:27:24 <Fuuzetsu> arkeet: Can you provide an example of a scenario where we'd end up with something ‘unexpected’?
15:27:40 <arkeet> > (0$0<>)
15:27:41 <lambdabot>   The operator `Data.Monoid.<>' [infixr 6] of a section
15:27:41 <lambdabot>      must have lower ...
15:27:47 <arkeet> would you expect (a <> b <>) c to mean a <> b <> c ?
15:27:54 <hashTag> bemachine: I downloaded 3.0 manually
15:28:00 <arkeet> (assume for the moment that <> isn't associative.)
15:28:20 <arkeet> would you also expect that (a <> b <>) only depends on the value of a <> b ?
15:28:21 <applicative> ooh it wants old containers
15:28:33 <hashTag> benmachine: https://github.com/tomahawkins/vcd
15:28:45 <arkeet> Fuuzetsu:
15:29:10 <hpc> arkeet: obviously it should parse as (a <> (b <>))
15:29:12 <Fuuzetsu> arkeet: I would assume that it would translate to (\x -> a <> b <> x) at which point it gets parenthesised based on whatever the fixity of <> is
15:29:15 <hashTag> applicative: Oh?! Really?!
15:29:24 <arkeet> Fuuzetsu: ok, what about the second question?
15:29:33 <hashTag> applicative: I'd have never tried that. Ever.
15:29:33 <enthropy> Fuuzetsu: a quasiquote that does such a thing should be doable
15:29:40 <arkeet> should (foo <>) only depend on foo?
15:29:44 <arkeet> (and <>, obviously)
15:30:02 <Fuuzetsu> I'm not sure what you mean by depend.
15:30:21 <Fuuzetsu> enthropy: Right? This is what I'm thinking so I was wondering why it's not the default.
15:30:32 <arkeet> Fuuzetsu: I mean, if foo = bar, then should (foo <>) = (bar <>) ?
15:30:51 <arkeet> where = means they denote the same value
15:30:54 <Fuuzetsu> Sure.
15:31:01 <NemesisD> i like that cabal flags by prefixing -f. I tend to read -fno-server as "F no, I don't want your damn server, cabal"
15:31:07 <arkeet> ok, well, your expectations can't be satisfied with what you propose.
15:31:14 <hpc> @quote funbox
15:31:14 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
15:31:15 <arkeet> consider: let ab = a <> b
15:31:24 <dcoutts_> NemesisD: :-)
15:31:25 <arkeet> then (a <> b <>) and (ab <>) would be different.
15:31:36 <hashTag> applicative: I'm at 0.4.2.1
15:31:37 <arkeet> because a <> b <> c = a <> (b <> c), while ab <> c = (a <> b) <> c
15:31:43 <hashTag> applicative: How old are we talking?
15:31:44 <arkeet> and if <> isn't associative, those aren't the same.
15:31:57 <arkeet> Fuuzetsu: right?
15:32:13 <Fuuzetsu> arkeet: Okay, but why does it matter for just the simple ‘put lambda in, then do the usual stuff’ case?
15:32:20 <arkeet> Fuuzetsu: huh?
15:32:21 <NemesisD> anyone notice that hackage's candidate package feature doesn't quite fully process haddock format?
15:32:27 <benmachine> hashTag: for me it died saying Illegal bang-pattern
15:32:29 <applicative> hashTag: oh it may be okay, then; my ghc comes with containers-0.5
15:32:37 <arkeet> Fuuzetsu: this contradicts your expectation.
15:32:44 <hashTag> applicative: I'll upgrade.
15:32:45 <arkeet> that foo = bar  =>  (foo <>) = (bar <>)
15:33:01 <applicative> bizarre i had no trouble building, once i insisted on my version of containers
15:33:07 <hashTag> applicative: Actually, wait.. so it's not verified to be container?
15:33:10 <applicative> which I think has substantive changes ...
15:33:25 <arkeet> Fuuzetsu: because even though ab = a <> b,  (ab <>) and (a <> b <>) are two different things.
15:33:29 <Fuuzetsu> I'm asking about an example where (a <> b <> c <>) wouldn't be exactly the same as (\x -> a <> b <> c <> x).
15:33:32 <applicative> hashTag: no, it's not clear thats relevant. it's a pretty stable library of coursse
15:33:32 <hashTag> applicative: So, I'm not having trouble building. Just parsing Verilog.
15:33:49 <arkeet> > ((1 / 2) /) 3
15:33:50 <lambdabot>   0.16666666666666666
15:34:00 <arkeet> > (\x -> 1 / 2 / x) 3
15:34:01 <lambdabot>   0.16666666666666666
15:34:06 <arkeet> er
15:34:09 <arkeet> oh right / is infixl
15:34:15 <Fuuzetsu> arkeet: Well, you're right but that's a problem either way. I simply don't see why it matters for this case.
15:34:20 <applicative> hashTag: you used the hackage vcd, just to make things clear
15:34:29 <arkeet> Fuuzetsu: it matters because it's a problem.
15:34:33 <quchen> Fuuzetsu: Are you asking about monoids or some arbitrary binary "<>" operation?
15:34:40 <Fuuzetsu> quchen: any operator
15:34:42 <quchen> (Tuned in late, but sounds interesting)
15:34:44 <Fuuzetsu> with any fixity
15:34:53 <hashTag> applicative: No, I used the github v. 3.0. However, when I used v. 0.2.0 of Verilog, it didn't depend on VCD, and I had the same issue.
15:34:57 <arkeet> Fuuzetsu: rather than choose between two things that both have problems, it just gives up.
15:35:23 <applicative> hashTag: hm, but is there a simple test
15:35:24 <Fuuzetsu> quchen: my question is why (foo ? bar ?) isn't translated to (\x -> foo ? bar ? x) and then checked for fixity issues and such.
15:35:25 <arkeet> instead of silently doing something weird that surprises the user later.
15:35:34 <arkeet> what do you mean, "checked for fixity issues"?
15:36:02 <arkeet> > (a + b *) c
15:36:03 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
15:36:03 <lambdabot>      must have lower prece...
15:36:08 <Fuuzetsu> arkeet: well, fixity clashes, if we do something like (foo ! bar ?)
15:36:12 <quchen> Fuuzetsu: Ah, that example fails with "section operator of equal precedence" or something like that, right?
15:36:13 <arkeet> > (\x -> a + b * x) c
15:36:14 <lambdabot>   a + b * c
15:36:19 <Fuuzetsu> quchen: yes
15:36:20 <hashTag> applicative They don't have tests, but... dilawar's branch has a simple run file and a bunch of examples: https://github.com/dilawar/verilog
15:36:21 <joelteon> > (a * b +)
15:36:23 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
15:36:23 <lambdabot>                     Debug....
15:36:23 <arkeet> > ((a + b) *) c
15:36:25 <lambdabot>   (a + b) * c
15:36:41 <hashTag> I did notice a different error on the default sort search example in that repo.
15:36:48 <Fuuzetsu> arkeet: sure but (a + b) * c is different than a + b * c
15:36:51 <arkeet> yes
15:37:52 <arkeet> @let data Foo x y = x :% y deriving Show; infixr 5 (:%)
15:37:52 <lambdabot>  Parse failed: Parse error: (
15:38:02 <arkeet> @let data Foo x y = x :% y deriving Show; infixr 5 :%
15:38:03 <lambdabot>  Defined.
15:38:04 <Fuuzetsu> indeed arkeet I think that your example should expand to <arkeet> > (\x -> a + b * x) c and then it should Just Work™ or only then GHC should complain instead of trying to resolve precedence first
15:38:19 <arkeet> > (\x -> a :% b :% x) c
15:38:22 <lambdabot>   a :% (b :% c)
15:38:34 <arkeet> > (a :% b :%) c
15:38:36 <lambdabot>   The operator `L.:%' [infixr 5] of a section
15:38:37 <lambdabot>      must have lower precedence...
15:38:38 <arkeet> > ((a :% b) :%) c
15:38:42 <lambdabot>   (a :% b) :% c
15:38:55 <arkeet> > let ab = a :% b in (ab :%) c
15:38:59 <lambdabot>   (a :% b) :% c
15:39:15 <arkeet> wouldn't you expect that ab = a :% b implies (ab :%)c = (a :% b :%) c ?
15:39:20 <arkeet> if (a :% b :%) made sense.
15:39:47 <Fuuzetsu> No, I wouldn't because that's not Haskell resolves it.
15:39:55 <monochrom> > (a * b +) c
15:39:57 <lambdabot>   a * b + c
15:40:04 <Fuuzetsu> Effectively we can think of ab as (ab) and expanding inside of the parenthesis
15:40:24 <Fuuzetsu> that's not how*
15:40:35 <hashTag> So on SearchSort.v I get: Left "failed to parse any of the possible choices  Token KW_begin \"begin\" :42:23"
15:40:36 <arkeet> no, Haskell doesn't even parse it.
15:40:57 * monochrom jokes about "if fx = f x then g fx = g f x" :)
15:41:06 <arkeet> heh.
15:41:11 <hashTag> But, the very basic example of a 'module foo();\nendmodule' gets the EOF error.
15:41:29 <monochrom> to your delight, shell scripts do that :)
15:41:38 <Fuuzetsu> Well, that does seem like what arkeet is trying to use to show why mechanically expanding with a lambda first somehow doesn't work and I'm just not seeing it.
15:42:02 <hpaste> enthropy pasted “RelaxedSections quasiquoter” at http://lpaste.net/93032
15:42:14 <arkeet> Fuuzetsu: of course it works. the problem is that what it does is different from what people might expect.
15:42:28 <quchen> Fuuzetsu: I think translating to Lambda changes strictness behaviour
15:42:29 <quchen> > let (<>) = undefined; infixr 6 <> in (1 <> 2 <> 3) `seq` ()
15:42:30 <lambdabot>   *Exception: Prelude.undefined
15:42:34 <quchen> > let (<>) = undefined; infixr 6 <> in (\x -> 1 <> 2 <> x) `seq` ()
15:42:35 <lambdabot>   ()
15:42:52 <Fuuzetsu> arkeet: and at this point it's just up to personal opinion!
15:43:00 <_Vi> How to write content of Data.Primitive.ByteArray.MutableByteArray to stdout ?
15:43:02 <arkeet> quchen: you're comparing different things.
15:43:04 <quchen> Oops, forgot the "3" there.
15:43:09 <arkeet> > let (<>) = undefined; infixr 6 <> in (\x -> 1 <> 2 <> x) 3 `seq` ()
15:43:10 <lambdabot>   *Exception: Prelude.undefined
15:43:17 <Fuuzetsu> I came asking whether there is a  _technical_ reason why it's not being done this way, rather than just arbitrary choice.
15:43:17 <enthropy> Fuuzetsu: do we file a ghc bug/feature request :p ?
15:43:27 <hashTag> BTW, if I open an issue on github what useful environment information should I include? Is there a cabal command to give all the libraries I'm using in my build?
15:43:28 <arkeet> Fuuzetsu: the principle of least astonishment.
15:43:31 <hashTag> By version.
15:43:34 <arkeet> is a very good reason.
15:43:55 <Fuuzetsu> hashTag: ‘ghc-pkg list’ might be what you want
15:44:07 <applicative> hashTag: i think i see the phenomenon; God knows what's up
15:44:15 <hashTag> Heh.
15:44:17 <dcoutts_> hashTag: if you configure with -v, it prints lots of useful env info
15:44:31 <hashTag> dcoutts_ Thank.
15:44:48 <monochrom> Fuuzetsu: if I had my way: I'm an idealist, I want everything fully parenthesized.
15:44:52 <enthropy> hmm, there's another option I forgot which is   (++ "x" ++)  becoming   \x y -> x ++ "x" ++ y
15:45:08 <Fuuzetsu> enthropy: does that even work
15:45:18 <Fuuzetsu> > (++ "x" ++) "a" "b"
15:45:19 <lambdabot>   <hint>:1:11: parse error on input `)'
15:45:32 <enthropy> I mean it should work
15:45:44 <enthropy> with some extension that other people can turn their noses at
15:45:58 <benmachine> hashTag: try "module foo(x);\nendmodule"
15:46:10 <quchen> arkeet: But if you take away the 3 from the first example it works as (un)desired
15:46:10 <quchen> > let (<>) = undefined; infixr 6 <> in ((1 <> 2) <>) `seq` ()
15:46:10 <quchen> > let (<>) = undefined; infixr 6 <> in (\x -> 1 <> 2 <> x) `seq` ()
15:46:11 <lambdabot>   *Exception: Prelude.undefined
15:46:11 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
15:46:18 <Fuuzetsu> enthropy: Well, if you want to go through GHC people for this then maybe RelaxedSections could become the next big thing ;)
15:46:21 <Fuuzetsu> I'd certainly use it!
15:46:33 <applicative> hashTag: it's telling you "Unexpected end of input: EOF ..." ?
15:46:49 <arkeet> > let (<>) x = undefined; infixr 6 <> in ((1 <> 2) <>) `seq` ()
15:46:50 <lambdabot>   *Exception: Prelude.undefined
15:46:55 <applicative> oh benmachine has an idea
15:47:17 <arkeet> > let (%%) x = x + 1 in (3 %%)
15:47:18 <lambdabot>   4
15:47:21 <arkeet> right, because of that extension.
15:47:25 <applicative> parses very well benmachine; I can see you are a verilog master
15:47:35 <enthropy> Fuuzetsu: for it to be useful it probably has to be in ghc. 1. haskell-src-meta can't parse everything and 2. it doesn't know fixities
15:47:38 <benmachine> applicative: definitely. whatever verilog is.
15:47:47 <enthropy> beyond some limited set
15:47:53 <benmachine> enthropy: you can give your own fixities to it
15:48:02 <Fuuzetsu> enthropy: yes, which is why I said ‘…if you want to go through GHC people for…’
15:48:25 <benmachine> enthropy: but there is a limited extent to which this can possibly work; I blame HSE
15:48:27 <enthropy> benmachine: it should discover them from the environment
15:48:27 <applicative> hashTag: i meant, the error is "*** Exception: Expected end of input (EOF)  Token KW_module "module" adder.v:1:1
15:48:33 <applicative> hashTag: or the like
15:48:33 <benmachine> enthropy: I blame HSE :)
15:48:41 <benmachine> enthropy: actually no, you have a fair point
15:48:46 <enthropy> you could for example reify '++
15:48:48 <hashTag> Ugh. It does look like that parses.
15:48:51 <benmachine> but I can't be bothered writing that :P
15:49:06 <arkeet> you can't parse a haskell source file on its own.
15:49:27 <benmachine> arkeet: you can parse it up to fixity ambiguity, which is not /bad/
15:49:27 <arkeet> because fixities depend on imported modules and stuff.
15:49:28 <applicative> hashTag: I think the problem is we don't know quite what to be giving parseFile for the final string argument
15:49:30 <arkeet> true.
15:49:38 <enthropy> out of $(reify '(++) >>= stringE . show), you can get a (Fixity 5 InfixR)
15:49:44 <benmachine> applicative: huh? what do you mean?
15:49:52 <applicative> hashTag: clearly the contents of existing files frequently fail the parser
15:50:06 <enthropy> benmachine: HSE supports re-associating things I think
15:50:11 <hashTag> Ok, so this is 99.999% my idiocy. I fell for this because the examples in dilawar/verilog's branch supports that.
15:50:17 <benmachine> hashTag: it looks to me like the comma-separated list in the brackets is expected to be nonempty
15:50:24 <hashTag> Sorry, not supports, has that example.
15:50:35 <hashTag> E.g., a module foo()...
15:50:38 <applicative> benmachine: it fails for all the verilog i'm chancing upon on the so called internet
15:50:44 <enthropy> so you can parse, get all infix things, lookup all fixities, re-associate
15:51:07 <benmachine> enthropy: yeah, I think this is true
15:51:15 <benmachine> however I'd be a little bit surprised if it actually worked
15:51:21 <benmachine> HSE has, iirc, zero unit tests :P
15:51:40 <enthropy> it's test are all parsing and pretty-printing
15:51:45 <hashTag> Ok, it parses module Foo;\nendmodule
15:51:48 <benmachine> it doesn't even do that perfectly
15:51:56 <applicative> hashTag: I think you should communicate with tomahawkins he presumably wrote this for a definite practical purpose
15:52:21 <hashTag> applicative: Yes, he states it's mostly to work with machine generated code. The error confused me to no end though.
15:52:39 <hashTag> applicative: I'm going to be enhancing it. I'll see if I can get approval from some folks to push my changes back.
15:53:14 <hashTag> Thanks everyone. Sorry I was an idiot.
15:53:28 <benmachine> hashTag: we all are sometimes :P
15:53:29 <enthropy> > let (!) x = product [1 .. x] in (5!)
15:53:30 <lambdabot>   120
15:53:33 <hashTag> That said. For the love of all that's holy, Hackage should require tests :)
15:53:41 <benmachine> :)
15:53:47 <enthropy> that postfix operators extension looks like it would conflict
15:54:23 <enthropy> then again it looks like it conflicts with normal section syntax
15:55:09 <joe9> can anyone please help with this: http://codepad.org/p3UjmcMb . I am trying to join the functions using >>= but cannot figure out what I should be using.
15:55:15 <joe9> to convert IO to Identity.
15:55:22 <arkeet> joe9: where's the code?
15:55:30 <arkeet> oh.
15:55:30 <arkeet> :)
15:55:36 <arkeet> well uh
15:55:41 <joe9> arkeet: hello
15:55:44 <geekosaur> "convert IO to Identity" sounds quite wrong
15:55:54 <hpaste> enthropy annotated “RelaxedSections quasiquoter” with “RelaxedSections quasiquoter (annotation)” at http://lpaste.net/93032#a93033
15:56:39 <joe9> geekosaur: Assertion = IO () , TestCase :: Assertion -> Test. So, I do not need the IO anymore. it is compressed into Test.
15:57:01 <applicative> hashTag: it is parsing fair chunks of stuff, but failing at curiosities; I wonder if he means to be parsing something machine produced
15:57:43 <applicative> for example, it doesn't want two 'parameter' declarations on the same line, hashTag
15:58:17 <monochrom> yikes, all my jokes about "convert IO String to IO" are now outdone by "convert IO to Identity" :)
15:58:33 <hashTag> applicative: He specifically says in a readme somewhere it's for machine generated stuff.
15:58:46 <applicative> ah
15:58:56 <hashTag> applicative: That said, I'm looking at a codebase with an enormous number of module <name>();... instances.
15:59:09 <hashTag> I'll just update my instance of the parser.
16:00:15 <Shin-LaC> I have a question on a possible approach to learning haskell
16:00:33 <Shin-LaC> I usually prefer to learn a new programming language by doing some project with it
16:00:59 <Shin-LaC> right now I'm working through a number of interview-style questions dealing with data structures and algorithms
16:01:13 <enthropy> Fuuzetsu: http://ghc.haskell.org/trac/ghc/ticket/8304
16:01:19 <DMcGill_> that works if you're just changing the syntax, less for for changing paradigms
16:01:30 <Shin-LaC> I thought I may solve them in haskell, but it seems that its functional nature makes it a bad fit for the problem
16:01:34 <DMcGill_> say you've been doing Fortran all your life, would you expect to be able to jump into Java?
16:01:49 <enthropy> this is a relatively simple one, might get me into ghc dev work
16:02:28 <Shin-LaC> DMcGill_: that's another issue that may be worth considering, but now I'm concerned that there may be an objective mismatch with this problem and haskell
16:03:48 <Shin-LaC> for example, let's say I have to implement a union-find data structure
16:03:49 <Fuuzetsu> enthropy: great
16:04:13 <Shin-LaC> normally I'd use a forest with Tarjan-style optimizations
16:04:25 <Shin-LaC> but that's a mutable structure
16:04:53 <Shin-LaC> it seems that implementing union-find in a purely functional way would require a completely different approach
16:05:48 <Shin-LaC> what do you guys think? should I avoid using haskell for this kind of thing? should I look for a different problem?
16:06:40 <elifrey> Shin-Lac: might you not use ST?
16:07:25 <johnw> Shin-LaC: isn't union-find just: catMaybes $ alignWith (\x -> case x of These y y -> Just y; _ -> Nothing)  xs ys
16:07:46 <Peaker> does the RTS prevent duplicate invocation of a ForeignPtr's finalizer? e.g: when explicitly calling finalizeForeignPtr and later upon GC
16:08:07 <elifrey> ST allows you to to prove through the typesystem that you have benign local mutability
16:08:09 <johnw> oh, wait, align with align on indices
16:08:13 <Shin-LaC> elifrey: that's what one would use in haskell, it seems. then the question becomes: is that a good idea for a haskell newbie?
16:08:15 <johnw> n/m
16:08:32 <johnw> Shin-LaC: http://hackage.haskell.org/package/union-find
16:08:38 <johnw> you can see how Thomas did it there
16:08:51 <johnw> he has an ST implementation
16:08:54 <applicative> or on the github page ...
16:09:28 <jmcarthur> persistent union-find: https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.pdf
16:10:20 <AnalogFile> http://jng.imagine27.com/index.php/2012-08-22-144618_purely-functional-data-structures-algorithms-union-find-haskell.html
16:10:26 <jmcarthur> ^^ just uses baker arrays, i think
16:10:32 <johnw> heh, so I guess Haskell is appropriate then :)
16:10:33 <elifrey> Shin-Lac: when I was learning haskell, I used ST for mutable array updates.  I found it pretty simple at the time.
16:11:13 <Shin-LaC> hm, I see
16:11:35 <Shin-LaC> I guess I'll try looking into ST, then
16:12:20 <Shin-LaC> jmcarthur: thanks, but note that union-find was only an example. in general, having to change all algorithm may be possible, but is undesirable
16:13:18 <elifrey> Shin-Lac: what it amounts to is, libraries will provide mutable operations that return ST actions.  You just glue them together as you would IO, then when you're done mutating use runST to get a pure value
16:13:25 <applicative> oh interesting, if i understand, nominolo has three implementations, one in IO one in ST and the other in the State monad?
16:14:02 <Shin-LaC> elifrey: is ST the preferred way to deal with this kind of thing, then? in general?
16:14:20 <applicative> ST is good.
16:14:22 <ReinH> edwardk: monoid pearl is fantastic. Great uses of free objects and newtype deriving to construct useful stuff.
16:14:33 <edwardk> yep
16:14:51 <ReinH> edwardk: love the general idea of Maybe (Option) providing a free mempty for semigroups
16:14:51 <elifrey> Shin-Lac: ST is what you want to use, whenever you have benign local mutability, unless you're already in IO
16:15:15 <Shin-LaC> ok
16:15:20 <edwardk> the current crappy monoid instance for maybe is why i wish we had semigroup in base
16:15:46 <ReinH> edwardk: right
16:15:49 <elliott> edwardk: says the guy who voted against it :p
16:15:59 <edwardk> i am conflicted =)
16:16:02 <ReinH> heh
16:16:06 <applicative> which function do I choose to make my Semigroup instance for Int?
16:16:17 <edwardk> i want it but i don't want it now. i'm fickle ;)
16:16:26 <ReinH> applicative: there are lots to choose from :p
16:16:33 <applicative> i sensed that
16:16:57 <ReinH> applicative: +, *, min, max, etc
16:19:45 <jmcarthur> Shin-LaC: ST allows you to port native algorithms to Haskell. note that you can also "naively" turn pointers-into-heap into keys-in-IntMap and get the same asymptotic complexity in totally pure code.
16:19:47 <ReinH> edwardk: I want a cheat sheet for commonly used algebraic structures
16:20:15 <jmcarthur> Shin-LaC: although the constant factors will be higher when you do the IntMap trick, of course
16:20:49 <shachaf> "same" because log n is a constant, right?
16:20:57 <shachaf> Oh, IntMap.
16:21:31 <jmcarthur> shachaf: right, IntMap, although O(k) = O(log n) anyway, and the constant-time argument is just a trick ;)
16:22:09 <shachaf> Yep.
16:23:39 <Shin-LaC> jmcarthur: hm, interesting
16:23:52 <Shin-LaC> jmcarthur: what is the k in O(k) = O(log n)?
16:24:22 <edwardk> ReinH: start with http://en.wikipedia.org/wiki/Magma_(algebra)
16:24:43 <shachaf> http://slbkbs.org/out.pdf
16:24:49 <shachaf> Note: That has at least one lie.
16:26:14 <jmcarthur> Shin-LaC: k would be the size of the keys in the map. in the case of IntMap, the keys are of fixed size, which is the motivation for the O(1) argument.
16:26:28 <arkeet> edwardk: magmas are commonly used?
16:26:41 <jmcarthur> Shin-LaC: an IntMap is a trie, which is why O(k) is relevant
16:27:06 <elifrey>  edwardk: isn't a magma pretty boring tho?
16:27:34 <jmcarthur> elifrey: but the wikipedia page isn't! lots of good links to branch out to
16:27:59 <Shin-LaC> jmcarthur: ah, I see!
16:28:04 <edwardk> elifrey: yes, but you cn start there and build up
16:28:13 <edwardk> > [1..3]^.magma traverse
16:28:15 <lambdabot>   .. <$> Magma 0 1 <*> (.. <$> Magma 1 2 <*> (.. <$> Magma 2 3 <*> pure ..))
16:28:55 <edwardk> elifrey: and i do a _lot_ of work with very weak algebraic structures. eg. non-associative right seminearrings
16:29:40 <jmcarthur> weak algebraic structures? ha! i prefer my algebraic structures to put up more of a fight.
16:30:01 <Shin-LaC> jmcarthur: but with optimizations, forests can essentially get down to O(1) instead of O(log n)
16:30:03 <luite> how acceptable is it to let the API of a package depend on the target platform? I was considering not exporting the J# and S# constructors for integer-gmp (GHC.Integer.GMP.Internals) when the package is built for JavaScript with GHCJS, since their internal data is different.
16:30:25 <Shin-LaC> so a conversion using intmap will have increased complexity, won't it?
16:30:42 <elifrey> luite: *lemongrab voice* unacceptable!
16:30:48 <haasn> edwardk: Doensn't Plucker let me represent planes in 3d space, too?
16:31:04 <jmcarthur> Shin-LaC: the argument is that operations on IntMap are constant time anyway. there is still a constant time overhead, but arguably not a O(log n) overhead
16:31:39 <edwardk> @remember jmcarthur weak algebraic structures? ha! i prefer my algebraic structures to put up more of a fight.
16:31:39 <lambdabot> Done.
16:31:43 <Shin-LaC> hm, I see
16:32:00 <ReinH> edwardk: yeah I want that flowchart but for ALL the things
16:32:03 <luite> elifrey: hmm, are there existing packages that export a somewhat different API (perhaps only in an Internal module) on Windows for example?
16:32:05 <ReinH> I guess I should build it
16:32:58 <jmcarthur> Shin-LaC: anyway, using ST to port an imperative algorithm is going to be faster than using IntMap for the same purposes. there's a tradeoff
16:32:58 <luite> CInt etc can be different depending on the architecture
16:33:06 <luite> so i guess it's not that uncommon :)
16:33:28 <elifrey> luite: I think it's cosure for /values/ to verry from platform to platform, but altering the shape of your ADT?
16:33:47 <jmcarthur> Shin-LaC: one may or may not be more awkward to write than the other. the latter provides some benefits for otherwise mutable data structures since the result is persistent, but this isn't always useful.
16:34:58 <Shin-LaC> hm, I see
16:35:19 <luite> elifrey: oh i can also export a different J# / S# if necessary, but i'm not sure if it's really conceptually different
16:35:30 <NemesisD> anyone know where haskell jobs typically get posted? I'm doing some feasability research to see what kind of job I could land with my current haskell skills
16:36:02 <edwardk> haasn: how so? in 3d you get 6 coordinates out of the plucker quadric from 4 choose 2. so the co-flat of a line should be a line, points and planes interchange, not planes and lines.
16:36:15 <elifrey> luite: the trouble is, how does a user write total functions on your ADT
16:36:42 <jmcarthur> NemesisD: i know of functionaljobs.com. some go to stackoverflow. also, i'm going to plug http://janestreet.com/ because we are always hiring, although it's ocaml, not haskell.
16:37:50 <NemesisD> jmcarthur: yeah much to my surprise  there's only 1 haskell job on functionaljobs and they do not mention if they allow remote work. also when i search for haskell on the SO jobs site i get nothing but python and C#?
16:38:20 <jmcarthur> NemesisD: well, there aren't that many to go around!
16:38:34 <NemesisD> im assuming the jobs are towing that line of "experience with FP like Haskell a plus, because it makes you write python better or something"
16:38:47 <jmcarthur> a lot do that, yeah
16:38:54 <luite> elifrey: i don't see the point. for example CInt might be CInt Int32 or CInt Int64, you can't pattern match on it or construct one in a general way. not exporting the data constructor itself just prevents you from doing the same things, and nothing more
16:38:55 <NemesisD> jmcarthur: i suppose that answers my job search feasability question
16:39:33 <jmcarthur> NemesisD: my take is that there are not many haskell jobs, not even that many functional jobs, but those jobs that do exist are better than average
16:40:49 <ricree> so, any idea why cabal would be giving me a "The program c2hs version >=0.15 is required but it could not be found." error? I have c2hs 0.16.4 installed, and can run it fine from the terminal
16:41:31 <tabemann> I'm used to just not bothering with FP jobs and doing primarily C++ and Java jobs IRL, doing work in FPs in my spare time
16:41:34 <geekosaur> you have $PATH set wrong. note that bash will handle a $PATH containing a directory specified as ~/... but other programs will not
16:41:35 <NemesisD> jmcarthur: yeah i'm just doing some research now in case things ever take a turn for the worse at my current employer. im somewhat interested in a job where i don't end up spending most of my time solving problems that using haskell would solve for free :/
16:41:43 <edwardk> NemesisD: there are a number of places looking for good haskell developers, but they are definitely looking for _good_ haskell developers
16:42:22 <geekosaur> so if you have "~/.cabal/bin" (literally) in $PATH, fix it
16:42:23 <dcoutts_> ricree: it's likely not on the $PATH
16:42:39 <mauke> ricree: what does 'type -a c2hs' say?
16:42:41 <NemesisD> edwardk: where do these places congregate? i'm no edwardk but i consider myself a capable haskell dev
16:43:07 <ricree> "c2hs is /home/ricree/.cabal/bin/c2hs"
16:43:12 <thoughtpolice> jmcarthur: i'd say there's a reasonable amount of stuff you can find for FP jobs, but you may have to compromise on the 'Haskell' part. individual languages in this space tend to be quite competetive, IMO
16:43:18 <mauke> ricree: echo $PATH
16:43:40 <luite> aw only good developers, what a horrible requirement :(
16:43:52 <ricree> mauke: I checked. "/home/ricree/.cabal/bin" is there
16:44:01 <jmcarthur> NemesisD: Standard Chartered Bank has a large haskell team, for example.
16:44:03 <Peaker> why does ByteString.useAsCString make a copy? :(
16:44:09 <Peaker> I want an O(1) useAsCString
16:44:17 <edwardk> NemesisD: we're hiring at capital iq. i know there are a few shops down in new york that do haskell. my old employer is starting to sniff around doing a haskell offering. standard chartered popped up recently looking for people willing to work in singapore. there is tsuru capital, well-typed popped up with a job offer a while back, galois still exists, bluespec is here in the area
16:44:19 <luite> jmcarthur: but they use a weird strict haskell variant!
16:44:21 <geekosaur> Peaker, it needs to append \0
16:44:23 <mauke> ricree: env | grep '^PATH='
16:44:29 <haasn> edwardk: ah, in the sense of https://en.wikipedia.org/wiki/Pl%C3%BCcker_coordinates#Plane-line_meet
16:44:33 <jmcarthur> luite: which they maintain themselves, one should add
16:44:35 * hackagebot effects-parser 0.1 - Parser Effect for the Control.Effects Library  http://hackage.haskell.org/package/effects-parser-0.1 (JesseMcDonald)
16:44:35 <geekosaur> C srings suck
16:44:36 <Peaker> geekosaur: I want the one with the length, though
16:44:39 <Peaker> geekosaur: don't need a \0
16:44:46 <geekosaur> C strings don't do length-based
16:44:49 <jmcarthur> luite: and it has really cool features
16:44:50 <geekosaur> C strings do \0 terminated
16:44:52 <NemesisD> thoughtpolice: i may need to find a second choice FP language. i'm in a mindset right now where i'm comparing languages and only noticing the things from haskell that the language is lacking
16:44:59 <thoughtpolice> Standard Chartered is perhaps the biggest one, i think Don said that they were hiring 40+ Haskell people in Singapore
16:45:04 <Peaker> geekosaur: it's a convention/library thing.. the library I'm looking at is using explicit length
16:45:07 <thoughtpolice> not too long ago
16:45:13 <enthropy> Peaker: then you can get the pointer out of the Bytestring
16:45:18 <Peaker> enthropy: how?
16:45:20 <edwardk> thoughtpolice: yeow that is a much bigger hiring binge than i thought
16:45:24 <luite> thoughtpolice: whoah that's quite a lot
16:45:36 <thoughtpolice> edwardk: yeah, Don mentioned it on twitter not too long ago
16:45:41 <luite> thoughtpolice: are they letting less-dev, more-analyst people use the haskell tools now?
16:45:42 <AnalogFile> anyone here is working on GHC and using GHC Head?
16:45:52 <mauke> Peaker: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Unsafe.html#v:unsafeUseAsCStringLen
16:45:58 <enthropy> Peaker: try unsafeUseAsCStringLen
16:46:00 <Peaker> thanks
16:46:09 <thoughtpolice> luite: no, they seemed to want Haskell programmers from what I could tell.
16:46:24 <thoughtpolice> AnalogFile: yes
16:46:28 <adelbertc> anyone have recommendations/suggestions for vim plugins for haskell development? (remote ssh-friendly if possible - i heard haskell-mode hoogle doesn't play nice)
16:46:29 <luite> ah then 40 is really a lot :)
16:46:36 <NemesisD> edwardk: thoughtpolice to make things even pickier, i'm sniffing around for remote work or work in the seattle area. at this point it is preferable to keep doing Ruby on Rails drudgery if it means I don't have to move. plenty of rails jobs
16:46:38 <thoughtpolice> luite: yeah, i was kinda mind-blown at that number
16:46:55 * geekosaur had some interest from janestreet when he was job hunting, but was having worse impostor syndrome issues than usual and panicked... sigh
16:46:57 <AnalogFile> thoughtpolice: can you check if the following still panics? {-# LANGUAGE DataKinds #-} data Foo a = Foo (Foo 1)
16:46:57 <edwardk> remote work is always harder to find.
16:47:18 <geekosaur> not helped by that I've been more or less sysadmin since 1996
16:47:28 <AnalogFile> thoughtpolice: if it does not I will not post a bug report
16:47:34 <ReinH> adelbertc: haskellmode is good
16:47:54 <ReinH> I don't doubt that its hoogle support over ssh would be mediocre
16:47:55 <NemesisD> edwardk: yeah maybe if FP complete is successful and starts growing that will be my best bet. web dev is my forte anyways
16:47:57 <thoughtpolice> AnalogFile: works fine in HEAD from earlier today
16:47:58 <ReinH> but I don't use that much anyway tbh
16:48:13 <elifrey> geekosaur: I made it to their second coding-over-the-net interview, but they were leading me to talk about cach replacement algos and I was ignorant of them at the time
16:48:15 <NemesisD> also i think janrain uses haskell
16:48:17 <ricree> mauke: I figured the issue. It was when I was installing, and didn't realize that sudo was changing my PATH
16:48:36 <mauke> sudo ಠ_ಠ
16:48:48 <AnalogFile> thoughtpolice: ok. then I will not report a bug and save you guys the trouble to say it's already fixed :P
16:48:50 <tabemann> I personally just wouldn't use sudo myself
16:49:02 <geekosaur> I am not a very good programmer, I'm largely self taught and algorithms are still something of a void I'm backfilling as I go :/
16:49:27 <adelbertc> ReinH - cool thanks!
16:49:38 <thoughtpolice> NemesisD: perhaps just email them? they say they're normally looking for contract stuff or people to do that sorta stuff, so just send something in
16:49:47 <hpc> geekosaur: i am pretty sure every good programmer is self-taught ;)
16:49:48 * edwardk is more of a reformed autodidact ;)
16:49:49 <luite> geekosaur: interleave your real work with reading about new things (and playing with them in code)!
16:49:52 <thoughtpolice> i looked at it before i landed my gig now
16:49:57 <elliott> geekosaur++ -- I relate
16:50:20 <geekosaur> oh, I do that. (I mean, I did teach myself Haskell by contributing to xmonad...)
16:50:34 <luite> geekosaur: (i ahve to admit that i often find that hard to do when you must (or want to) finish something)
16:50:54 <geekosaur> but there's still a lot of underpinning that I am not at all comfortable with my knowledge
16:50:55 <jmcarthur> i wouldn't say *every* good programmer is self taught, but there is a high correlation
16:51:14 <NemesisD> thoughtpolice: i will when/if the time comes. i'm really more of a full time worker. i'm feeling out the waters because i'm not sure where the company I work at now will be in a year or 2
16:51:15 <geekosaur> *knowledge level
16:51:35 <monochrom> it is safe to say: every good programmer must self-teach at some point
16:51:51 <thoughtpolice> geekosaur: i feel very similarly, and i sorta choked when i looked at Jane Street too (felt intimidated as a dropout, etc)
16:51:58 <luite> jmcarthur: hmm, a general requirement is the attitude to find out and learn things by themselves
16:52:07 <monochrom> only tenured undergrad students can stay taught-by-others for life
16:52:19 <NemesisD> monochrom: probably. i worried for classmates in my CS program who showed no initiative to study/do programming beyond homework assignments
16:52:36 <hpc> monochrom: you have clearly never worked in a php shop
16:52:47 <jmcarthur> geekosaur, thoughtpolice: jane street isn't going to intetionally penalize you for stuff like that
16:52:58 <jmcarthur> *intentionally
16:53:14 <geekosaur> yeh, but impostor syndrome :/
16:53:15 <hpc> jane street hiring flowchart:
16:53:32 <hpc> 1. is your first name simon? no - step 2; yes - hired
16:53:44 <hpc> 2. is your first name edward? no - fired; yes - hired
16:53:50 <thoughtpolice> jmcarthur: of course not, it's a self-induced thing
16:53:53 <geekosaur> I can tell myself that all I want and it doesn't matter much. (add that I was under severe stress and a bit malnourished, which is why I was having it worse than usual)
16:54:28 <elifrey> geekosaur: when I was entering the indurstry I was sharing food stamps with my mom :)
16:54:43 <ricree> mauke: actually, now that you mention it, it does seem kinda odd that it even complains about not having sudo, considering that everything is in the home directory. Any idea what's up with dist/package.conf.inplace? It's what's giving me a permission denied
16:54:57 <mauke> ricree: probably wrong owner
16:54:58 <luite> geekosaur: dunno, the best way to work is probably to be a bit of an impostor all the time. if you do something you completely know how to do you're doing the wrong thing
16:55:11 <jmcarthur> hpc: we have no developers named simon or edward.
16:55:17 <geekosaur> ricree: if you used sudo once, then a lot of ~/.cabal will be owned by root instead of you
16:55:25 <elliott> jmcarthur: sounds like you need to follow your flowchart better.
16:55:33 <jmcarthur> elliott: yeah... :)
16:55:42 <hpc> jmcarthur: i might be thinking of msr ;)
16:56:44 <ricree> thanks geekosaur and mauke
16:56:52 <jmcarthur> luite, geekosaur: IMO, the best way to go is to not be an imposter at all and be entirely honest about how good or not good you think you are.
16:57:11 <geekosaur> impostor syndrome isn't about that
16:57:24 <jmcarthur> well i admit i don't really have a good understanding
16:57:33 * jmcarthur reads up on it
16:57:49 <geekosaur> it's about misjudging your own abilities downward especially when under related stress
16:58:22 <luite> jmcarthur: oh i wasn't talking about overselling or misrepresenting your abilities.
16:58:32 <jmcarthur> confidence tends to vary inversely with competence...
16:59:02 <luite> jmcarthur: yeah dunning-kruger effect
16:59:11 <elifrey> the more you know the more you know you don't know
17:01:22 <elifrey> Lately I've been learning how to deal with the situation where you think you know about something, but then you try to communicate it to someone else and you discover just how impresise your thoughts are
17:01:35 <jmcarthur> definitely been there
17:01:37 <shachaf> Good situation.
17:01:43 <elifrey> so I try to spend more time explaining things to people
17:01:53 <jmcarthur> this is one argument for blogging
17:01:57 <dcoutts_> or teaching
17:02:10 <shachaf> Or IRC.
17:02:56 <Peaker> doh! unsafePackMallocCStringLen seems to have been added in the newest bytestring version
17:03:03 <Peaker> (can't use it yet with 7.6.3)
17:03:05 <luite> hm, blogging is harder (and works better maybe?) because it forces yout o have longer coherent story
17:04:05 <ReinH> edwardk: what tools do you use for performance profiling these days?
17:04:06 <luite> i really shoudl start blogging more, i've been writing stuffs all this time with the intention to make blogging better, without doing much blogging at all...
17:04:08 <Peaker> I wish ByteString was just a specialization of some unboxed vector library
17:04:15 <edwardk> #haskell
17:04:18 <hpc> elifrey: just keep learning until you can hold a conversation in this channel
17:04:37 <luite> Peaker: hmm, it's hard to combine, with the different underlying representation
17:04:37 <edwardk> i've also been known to use thoughtpolice and acowley from time to time.
17:04:47 <ReinH> elifrey: listening is usually a good strategy in those situations :)
17:04:52 <Peaker> luite: what's the different repr?
17:04:54 <edwardk> shachaf used to be a good profiling tool, but i can't seem to get that to work any more
17:05:01 <luite> Peaker: ByteArray# vs ForeignPtr
17:05:05 <ReinH> edwardk: well played
17:05:14 <ReinH> edwardk: any software that helps as well?
17:05:20 <thoughtpolice> edwardk: :)
17:05:21 <luite> Peaker: although i think there might've been some talk about switching ByteString? i'm not sure though
17:05:22 <jmcarthur> ReinH: weechat
17:05:23 <edwardk> i use criterion
17:05:27 <arkeet> jmcarthur: :)
17:05:35 <Peaker> luite: doesn't sound like a fundamental problem
17:05:46 <luite> Peaker: foreign-allocated data would be a bit of a problem
17:05:47 <enthropy> Peaker: might be you can unsafePackCStringFinalizer and use whatever you do for freeing malloc'd things
17:06:12 <Peaker> enthropy: it's the Len variant that's missing
17:06:19 <luite> Peaker: if you allocate on the haskell site, and use a pinned ByteArray#, then it can mostly work, i guess
17:06:34 <enthropy> that one has a Word8, which I thought was the length
17:06:37 <Peaker> enthropy: not the malloc variant
17:06:46 <Peaker> oh, right! thanks
17:07:09 <Peaker> enthropy: the Int is the length, indeed
17:07:09 <enthropy> well actually it's an Int
17:07:10 <luite> but i don't really know if pinned ByteArray# are worse than malloc+ForeignPtr for fragmentation
17:07:11 <enthropy> yeah
17:07:15 <ReinH> edwardk: oh look http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/profiling.html :p
17:07:24 <luite> can a ByteArray# be pinned after the fact, and unpinned?
17:07:27 <enthropy> and maybe the finalizer can be Foreign.Marshal.Alloc.free
17:07:43 <thoughtpolice> ReinH: you can use the built in profiler + criterion to get very far in my experience
17:08:02 <thoughtpolice> if you need ridiculous amounts of low-level detail, you can use whatever software can utilize the PMU in your machine
17:08:05 <Peaker> enthropy: weirdly, the finalizer is IO () and not a FunPtr as usual
17:08:11 <thoughtpolice> (on linux, this is 'perf' or 'instruments' on OS X)
17:08:54 <jmcarthur> <3 perf, although i don't have much experience using it with ghc
17:09:03 <thoughtpolice> perf is quite fantastic, yes
17:09:09 <luite> ah hmm, parcs_ requested 'perf' for testing his -j patch on my server. i should probably try it some time :)
17:09:31 <thoughtpolice> although it moderately annoys me that on e.g. ubuntu they don't give you an uncompress vmlinux image along with the -dev setups it seems :(
17:09:58 <jmcarthur> i can't think of many times ubuntu has surprised me in a good way ;)
17:09:58 <Peaker> weird, I don't get how unsafePackCStringFinalizer type-checks.. newForeignPtr is supposed to get a FunPtr, not IO ()
17:10:10 <thoughtpolice> this sucks when you're trying to profile things that e.g. have disproportionate amounts of system time used
17:10:11 <luite> thoughtpolice: oh! i had that problem before, do you know the easiest way to work around that?
17:10:21 <thoughtpolice> luite: compile a kernel :P
17:10:25 <luite> i think i rebuilt the kernel from source package with some mods
17:10:36 <thoughtpolice> yes, that's basically your only option, AFAIK
17:10:38 <Peaker> perf is the new oprofile?
17:11:10 <thoughtpolice> i don't know the relation between the two, but perf is the Official Linux Performance Monitoring tool
17:11:25 <thoughtpolice> and integrated into the performance subsystem in the kernel, maintained by the devs
17:11:33 <Peaker> oh, i'ts from Foreign.Concurrent, not from Foreign.ForeignPtr
17:11:46 <thoughtpolice> (you could write your own perf even: they expose system calls to userspace that lets you talk to the PMU)
17:12:01 <thoughtpolice> although the system call comes with a not-necessarily-negligable amount of constant time overhead
17:12:26 <Peaker> enthropy: sounds like the IO () finalizer there is going to be run in a separate thread, expensively, ouch!
17:12:42 <Peaker> enthropy: I'll just put a dependency on very new bytestring and hope for the best
17:13:08 <enthropy> maybe there's access somewhere else to a ForeignPtr in the ByteString
17:13:18 <luite> wait what does new bytestring do differently?
17:13:35 <Peaker> luite: it exports unsafePackMallocCStringLen
17:13:47 <Peaker> which the one in GHC 7.6.3 does not
17:13:49 <mikeplus64> that's a mouthful
17:14:14 <luite> Peaker: hehe now you're just throwing a bunch of random words together aren't you? ;)
17:14:50 <luite> i thought it had something to do with finalizers
17:15:08 <luite> i'm not quite sure what's the correct way to run them, should each finalizer get its own thread?
17:15:45 <Peaker> I'm about 70% done at wrapping http://sphia.org/, I think
17:16:11 <Peaker> and I put the C code inside the bindings so no C dependency involved, would be nice to finally have a real key/value store library without dependency hell :)
17:16:17 <edwardk> :t Data.ByteString.Unsafe.unsafePackMallocCStringLen
17:16:19 <lambdabot>     Not in scope: `Data.ByteString.Unsafe.unsafePackMallocCStringLen'
17:16:39 <Peaker> :t Data.ByteString.Unsafe.unsafePackMallocCString
17:16:40 <lambdabot> Foreign.C.String.CString -> IO BSC.ByteString
17:17:11 <edwardk> ah too new
17:17:11 <edwardk> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Unsafe.html#v:unsafePackMallocCStringLen
17:17:51 <Peaker> yeah, I'm depending on the new bytestring in my bindings, and hoping for the best
17:21:03 <ricree> I'm trying to use c2hs, and when I tried using {#call ...} rather than writing the call manually, I'm getting "Unknown identifier" errors. any idea what I'm doing wrong?
17:21:49 <elifrey> is it incorrect to say that catamorphisms generalize folds to arbitrary ADTs?  Put another way, are there ADTs for which we can not describe a catamorphism?
17:22:45 <elifrey> the way I typically think of catamorphisms are that they replace n-ary constructors in our ADT with n-ary functions
17:23:00 <elifrey> this would lead me to thing they generalize to arbitrary ADTs
17:23:12 <arkeet> sure they do.
17:23:27 <elifrey> cool
17:23:52 <arkeet> like
17:23:53 <arkeet> why the doubt?
17:24:05 <elifrey> I'm trying to write up a less-abstract School of Haskell piece on them, and I wanted to make sure I didn't say something wrong
17:24:17 <arkeet> people say wrong things all the time. :p
17:24:29 <enthropy> ricree: c2hs comes with a module C2HS.hs you should import
17:24:53 <danilo2> Hello :) I've got very strange question (but It has'got a deep sense :D). In Haskell the "do" block and "<-" are magical. The "<-" translates to (>>=) and lambdas. The problem is, that (>>=) is defined as "(>>=) :: m a -> (a -> m b) -> m b". Is it possible to use the "do" and "<-" notation, but ask hasell to translate it not to ">>=", but my own operator of different signature than default >>+ ?
17:25:02 <danilo2> *>>=
17:25:22 <enthropy> -XNoImplicitPrelude
17:25:58 <elifrey> danilo2: enthropy is suggesting that you define your own Monad typeclass in place of the one in prelude.
17:26:39 <danilo2> enthropy, elifrey: Ok - If it is so simple than I should have thought it myself :D brb :)
17:26:57 <ricree> enthropy: thanks, but I don't think that's it. I think the issue is that it can't find the required .h file, but I'm not sure how to specify that. Somewhere in the .cabal, presumably, but I can't figure out where
17:27:06 <ReinH> edwardk: my next goal is getting a 10x speedup to my distance mapping algo, either by improving my current algo or switching to a better one.
17:27:26 <edwardk> sounds like a plan
17:27:56 <ReinH> edwardk: the ray tracing / shadow mapping plan seems good.
17:27:57 <enthropy> ricree: oh I thought you got to the point of having a .hs file
17:28:07 <ricree> no
17:28:21 <ReinH> edwardk: I also realized that I only need to map distances up to the max vision distance, so I can keep my n reliably small.
17:28:30 <edwardk> *nods*
17:28:40 <ReinH> here's no point calculating the distance to points I don't know exist.
17:28:43 <enthropy> ricree: if you're missing a .h you either have to get the header, or call cabal with --extra-include-dirs
17:29:09 <enthropy> if you have that header somewhere, but it's not in the default places to look
17:29:38 <ReinH> edwardk: luckily I already control a depth parameter to my algo :)
17:29:43 <ReinH> so that's a trivial change
17:30:59 <ricree> enthropy: in theory, shouldn't pkg-config-depends be enough for cabal to take care of that? It was when I was writing my own foreign import definitions
17:31:43 <enthropy> yes. There are lots of things that can explain why it didn't work this time.
17:32:08 <ReinH> edwardk: I do want to implement LoS/FoV anyway, so I should try that plan
17:32:27 <ReinH> edwardk: was also thinking about exploiting the symmetries from JPS
17:38:52 <ReinH> edwardk: do I have any better data structure options for representing my grid? IntMap? Something something morton order?
17:39:27 <ReinH> thoughtpolice: thanks, I'm going to start there :)
17:39:39 <ReinH> thoughtpolice: the cost center reporting looks super useful already
17:40:07 <thoughtpolice> indeed
17:41:23 <Peaker> bah, sophia's default key comparison function compares just the MIN(lengths) first bytes of keys
17:43:43 <ReinH> edwardk: I'm sort of surprised that no one has written a 2d array on top of Vector that maps to/from (i,j) keys.
17:44:13 <edwardk> re morton order do you need it dense or sparse?
17:44:14 <danilo2> elifrey, enthropy: I feel my question was misunderstood (or simply I do not know how to solve this problem with  enthropy's solution). Could you please look at the example?: http://lpaste.net/93036  The functions f1 and f2 work as expected and I want now to be able to write them as f1' and f2' (using do notation) - is it possible?
17:45:00 <ReinH> edwardk: dense, I would think
17:45:25 <edwardk> then i'd recommend looking at the notion of dilated integer arithmetic and doing the dense representation that way
17:45:54 <ricree> so, is there something I need to be adding to tell c2hs where the C headers are? I have pkg-config-depends defined in my .cabal, and it's not clear to me what else I need to be doing
17:46:10 <ricree> even so, I'm getting "Unknown identifier" when I try to build
17:46:26 <edwardk> you can name the types of the two dilated integer types X and Y, then you can index right into the array buy oring the two dilated indices together
17:46:26 <enthropy> danilo2: http://www.haskell.org/ghc/docs/7.6-latest/html/users_guide/syntax-extns.html#rebindable-syntax
17:46:41 <edwardk> and you can add, subtract, etc. to edit them easily
17:47:06 <edwardk> ReinH: i'd be wlling to cooperate on a dilated package or something
17:48:47 <danilo2> enthropy: Yay! You've saved my life! :) Thank you very very much!
17:49:06 <Ghoul_> > (`sub` 3) 2
17:49:08 <lambdabot>   Not in scope: `sub'
17:49:08 <lambdabot>  Perhaps you meant one of these:
17:49:08 <lambdabot>    `sum' (imported fro...
17:49:14 <liyang> Does anyone else think the behaviour of "directory" regarding symlinks is totally wrong? (i.e. pretending that they don't exist.)
17:49:20 <Ghoul_> Sub. Really.
17:49:34 <Ghoul_> > (`rem` 3) 2
17:49:35 <lambdabot>   2
17:49:42 <Ghoul_> > 2 `rem` 3
17:49:43 <lambdabot>   2
17:49:46 <edwardk> ReinH: pm =)
17:51:35 <geekosaur> "directory" where? (normally I'd ask hayoo but it's been down all weekend >.< )
17:56:05 <geekosaur> if you mean the directory package, are you sure you're not hitting either a POSIXism or system dependent behavior? (for example behavior of a symlink to a former directory which has been removed is undefined)
18:01:22 <dobblego> for some GHC versions, I want to hide Prelude#catch and for others, it is not even exported (resulting in a compile-time error) — what is the typical strategy to work with multiple GHC versions here?
18:01:45 <jfischoff> #ifdef
18:02:43 <enthropy> import Prelude hiding (catch) -- is accepted by ghc 7.6.3
18:03:15 <enthropy> you probably don't have to support whatever 7.6 that would make that an error
18:03:16 <joelteon> dobblego: CPP
18:04:31 <dobblego> yeah actually, it is a warning, sorry
18:05:05 <hpaste> ricree pasted “C2HS Header Error” at http://lpaste.net/93037
18:05:15 <ricree> any idea what I'm doing wrong here?
18:05:31 <ricree> I know it's probably something stupid, but I'm going crazy trying to figure out what
18:09:36 <jfischoff> what is the difference between blaze-builder  and Data.ByteString.Builder?
18:11:59 <liyang> geekosaur: yes, System.Directory, all of it.
18:12:43 <liyang> It only purports to support Win32 and POSIX, and Win32/NTFS has had different flavours of reparse points / volume mount points / actual symlinks for years.
18:14:11 <geekosaur> jfischoff, I believe Data.ByteString.Builder is just blaze-builder incorporated into ByteString
18:14:18 <jfischoff> ah
18:14:37 <liyang> I've run this problem twice (different programs; other people's code…) over the last month already.
18:19:08 <joe9> is there a function to do m [a] -> m [b] -> m [a+b] , basically concatenate lists encapsulated withun a monad?
18:19:27 <Makoryu> :t liftM2 (++)
18:19:28 <danilo2> How do you pronouce (>>) operator in Haskell? (>>=) is a bind, so what is (>>) ? :)
18:19:28 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
18:19:37 <Iceland_jack> danilo2: then
18:19:44 <joe9> Makoryu: thanks.
18:19:56 <danilo2> Iceland_jack: thank you :)
18:20:16 <Iceland_jack> (putChar 'a' >> putChar 'b') may be read ‘put the character 'a' and then 'b'’
18:20:17 <Makoryu> joe9: You could also do it applicative-style: (++) <$> foo <*> bar
18:20:30 <Hodapp> someone make a pronunciation guide for Haskell
18:20:38 <Makoryu> joe9: I mean, assuming the monad you're working in is also an applicative functor
18:20:49 <Makoryu> (Which it ought to be)
18:20:50 <Iceland_jack> Hodapp: It's already available on StackOverflow for what it's worth :)
18:21:17 <applicative> danilo2: and then; >>= is pronounced: and then, with the result ... ;)
18:21:19 <Hodapp> Iceland_jack: there's Literate Haskell, why not Vocal Haskell?
18:22:04 <Iceland_jack> Hodapp: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators there you go
18:22:42 <danilo2> applicative: In the book http://learnyouahaskell.com/a-fistful-of-monads , there is a sentence: The next function is >>=, or bind.  So is "bind" an official name or is it only name used by the author?
18:23:07 <applicative> 'bind' is used all the time, sure
18:23:16 <Iceland_jack> Bind is what (>>=) is called, I'm not sure how official it is though
18:23:30 <danilo2> Iceland_jack: I was searching for it but not found that question. thank you! :)
18:25:18 <khyperia> Why is cons called cons? I mean... what's its root?
18:25:26 <applicative> khyperia: its really ancient
18:25:31 <Iceland_jack> Have you checked Wikipedia?
18:25:35 <Iceland_jack> https://en.wikipedia.org/wiki/Cons
18:25:43 <Iceland_jack> > In computer programming, cons (/ˈkɒnz/ or /ˈkɒns/) is a fundamental function in most dialects of the Lisp programming language. cons constructs memory objects which hold two values or pointers to values.
18:25:43 <applicative> khyperia: its a Lisp thing
18:25:44 <lambdabot>   <hint>:1:24: parse error on input `,'
18:25:57 <khyperia> Ah, constructs.
18:26:24 <applicative> why khyperia should have suspected the existence of such a wikipedia article, I don't know ;)
18:26:53 <khyperia> I have a nasty habit to be lazy and ask people in irc instead of googling.
18:26:56 <Iceland_jack> Why khyperia should not expect the existence of /anything/ computer related, I don't know :)
18:27:10 <Iceland_jack> on Wikipedia that is
18:27:52 * Iceland_jack just had flashbacks of dotted lists in CL
18:28:05 <applicative> that there's an article on cons kind of freaks me out, given that the editors have thrown most of wikipedia out in the last few years on grounds of e.g. non-notability
18:28:55 <Iceland_jack> To be fair the articles on CAR and CDR could easily be merged into Lisp
18:28:56 * applicative proposes an article on 'intercalate_(Haskell_function)"
18:29:26 <applicative> one on each? wow
18:29:46 <Iceland_jack> No, one entry on both!
18:29:48 <Iceland_jack> https://en.wikipedia.org/wiki/CAR_and_CDR
18:30:04 <applicative> i'm doing DEFMACRO
18:30:23 <Iceland_jack> (car, cdr) = (head, tail) …
18:30:30 <Iceland_jack> the way god intended
18:31:15 <applicative> are you sure its not (car,cdr) = (fst,snd) , but without a type system to speak of ...
18:32:33 <Iceland_jack> It's hard to translate the concepts directly between untyped Lisp and typed Haskell but car/cdr do operate on lists
18:32:42 <Iceland_jack> Just because they're heterogeneous
18:32:52 <applicative> wait, I know, I'm writing an article on 'snoc'
18:33:07 <Sakako> What's 'snoc'?
18:33:11 <deech> How do I set a pointer to NULL using the FFI? I tried `free ptr` but that didn't work. `free ptr /= nullPtr`.
18:33:14 <Iceland_jack> Sakako: Cons at the end
18:33:24 <Sakako> Oh, so right-associative
18:33:27 <Sakako> yeah, I had a hunch
18:33:30 <Iceland_jack> no not right associative
18:33:40 <Sakako> ohhhhh
18:33:41 <Sakako> right
18:33:42 <Sakako> I see.
18:34:00 <Sakako> so !t snoc = [a] -> a -> [a]?
18:34:01 <applicative> : in Haskell, for example, car and cdr become fst and snd when dealing with a pair type. Exact analogs of car and cdr are thus rare in other languages." thats what wikipedia told me
18:34:21 <Sakako> or a -> [a] -> [a]
18:34:26 <Iceland_jack> 5 `snoc` [1,2,3,4] ⇒ [1,2,3,4,5]
18:34:32 <Sakako> right
18:34:53 <Sakako> interesting
18:34:57 <applicative> it is explicitly named so in libraries where it doesnt make a difference to the expense of the library
18:35:23 <applicative> Sakako: see https://www.fpcomplete.com/hoogle?q=snoc&env=ghc-7.4.2-stable-13.09
18:35:44 <applicative> sorry, where it makes no difference the operations expense
18:35:57 <applicative> but even that is illiterate
18:36:04 <thoughtpolice> deech: poke ptr nullPtr
18:36:13 <Sakako> Okay, so it is [a] -> a -> [a]
18:36:32 <Iceland_jack> Sakako: Why do you say that?
18:36:46 <Sakako> Well, an analogue at least
18:37:04 <applicative> yes, but it woulnt be good to define a list snoc calling it snoc I think since (++[x]) is more expensive than (x:) or however we should say it
18:37:06 <Iceland_jack> Are you still talking about the ‘snoc’ that I mentioned?
18:37:20 <applicative> we love snoc
18:37:24 <Iceland_jack> Because that one was: snoc ∷ a → [a] → [a]
18:37:31 <Iceland_jack> just like cons
18:37:41 <applicative> same signature
18:37:53 <Iceland_jack> In any case the order of the inputs isn't integral to the function itself
18:37:57 <Sakako> Oh, right. But the ones in Hoogle have the list first
18:38:04 <applicative> but snocs always are x -> y -> x where y is the bitty thing
18:38:06 <Iceland_jack> (exactly)
18:38:07 <Sakako> like Text -> Char -> Text
18:38:09 <Sakako> yeah
18:38:35 <Iceland_jack> You could just as well define (:) ∷ [a] → a → [a], it would just be odd
18:38:38 <applicative> its just a sensible tradition of naming
18:39:03 <applicative> snoc and snoclists and so on are not a specifically haskellish thing either
18:39:07 <Sakako> sure
18:39:16 <Sakako> at any rate, it's cons at the end
18:39:21 <Sakako> order doesn't really matter. :p
18:41:48 <deech> thoughtpolice: That didn't work.  `poke p nullPtr >> print (p == nullPtr)` outputs "False"
18:42:03 <jmcarthur> there are good reasons to use snoc lists every once in a while
18:42:30 <jmcarthur> left-leaning free applicatives are essentially snoc lists with some extra type information
18:42:42 <jmcarthur> and, IMO, the left-leaning variants are the nicest
18:43:06 <jmcarthur> since ap is constant time that way
18:43:47 <ion> deech: That’s not how it works. If p is a null pointer, poking a value into it will crash. Also, to dereference a pointer (which is hopefully not a null pointer), you can use peek.
18:43:58 <thoughtpolice> deech: oh, right, i misunderstood your question, sorry
18:44:34 <jmcarthur> deech: you don't really change the pointers themselves, only the addresses they point to.
18:44:52 <jmcarthur> deech: even if you do pointer math, the original pointer is still there for you to use
18:45:06 <sirspazzolot> > let sum' xs = foldl (\acc x -> acc + x) 0 xs in sum' [1..100000]
18:45:07 <lambdabot>   5000050000
18:45:34 <sirspazzolot> I understand what it's doing, but the syntax of the lambda is throwing me off
18:45:49 <deech> ion, thoughtpolice, jmcarthur : Hmm. So there's no equivalent of `p = NULL` in Haskell?
18:46:05 <ion> deech: p itself is immutable.
18:46:11 <jmcarthur> deech: that would be mutable assignment, so no
18:46:18 <ion> Just like any Haskell value.
18:46:27 <jmcarthur> deech: you could have an IORef (Ptr a) or something, if you really want
18:46:37 <Iceland_jack> sirspazzolot: (\acc x -> acc + x) is the same as (+)
18:46:42 <ion> (But you probably don’t really want that.)
18:46:47 <jmcarthur> yeah
18:47:14 <sirspazzolot> oh my confusion was thinking of acc as a function name ._.
18:47:19 <jmcarthur> i do use state monads with pointers sometimes, when i am using them as cursors
18:47:27 <Iceland_jack> @src foldl
18:47:27 <lambdabot> foldl f z []     = z
18:47:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:48:11 <Iceland_jack> sirspazzolot: Try to substitute f with (+), z with 0 and try to work it out for: foldl (+) 0 [10,20,30]
18:48:13 <ion> sirspazzolot: (Btw, for future reference, you’ll almost certainly want foldl' instead of foldl for that.)
18:48:55 <jmcarthur> > foldl f z [a, b, c]
18:48:56 <lambdabot>   f (f (f z a) b) c
18:48:59 <Iceland_jack> > foldl f 0 [a,b,c,d]
18:49:00 <sirspazzolot> ion: noted. going through lyah right now :)
18:49:00 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
18:49:01 <lambdabot>    arising from a us...
18:49:04 <Iceland_jack> > foldl f z [a,b,c,d]
18:49:06 <lambdabot>   f (f (f (f z a) b) c) d
18:49:26 <Peaker> great. Memory corruption apparently in the C binding tests..
18:49:42 <Peaker> Finished wrapping sophia, tomorrow will debug it...
18:52:22 <jfischoff> what's sophia?
18:53:15 <thoughtpolice> a new on-disk key value store.
18:53:23 * jfischoff nods
18:53:54 <thoughtpolice> i've been waiting for SQLite4 to be released, it has a nice on disk log-structured merge tree included in the implementation
18:54:05 <thoughtpolice> although sophia looks interesting
19:08:26 <ricree> I figure I'll give this one more try before logging for the night.  Anyone able to help me with a c2hs issue? I've been reading through the c2hs docs, and I still can't figure out why the function I'm trying to use gets an unknown identifier
19:08:27 <ricree> http://lpaste.net/93037
19:10:06 <danilo2> Could somebody explain to me why Haskells type inferencer gives such strange result? I've got a function f. If I type it wrong "f::Int", i see an error, that f should be "A Int -> A Int -> m2 b0", but If I type it like this I get error that couldnt match b0 with Int, and then error bout not existing instance. If I do NOT type this function it works.
19:10:37 <danilo2> The correct type is "A Int -> A Int -> A Int", but if Haskell knows the type of untyped function, then why he tells such strange errors?
19:12:38 <ricree> try pasting the actual function into lpaste for us. The issue might be more obvious there
19:13:42 <Makoryu> danilo2: Sometimes, when it says "I can't find an instance" it really means "this WOULD work if you wrote an instance for this particular type."
19:14:33 <danilo2> ricree, Makoryu: I think I have to make a simple example of this. brb :)
19:14:36 <spaceships> pattern matching & binding inside guards with (<-) .. must have skipped over this in the haskell report :P i thought all guard expressions were booleans -- i take it it fails on unsuccesful pattern match? (found in xmonad: view i s | Just x <- find ... = use x)
19:15:01 <Makoryu> spaceships: That's a GHC extension
19:15:09 <elliott> spaceships: that's in haskell 2010
19:15:12 <spaceships> Makoryu: oh! cool
19:15:15 <elliott> previously it was an extension
19:15:44 <spaceships> okay, neat. seems useful
19:24:44 * hackagebot ghc-mod 3.0.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.0.1 (KazuYamamoto)
19:28:19 <cschneid> I see comments on stackoverflow about "use applicative style" - is there a good blog post walkthrough on solving a problem in that way?
19:30:18 <Makoryu> cschneid: You can mostly think of it as a syntax rewrite of monad-style application
19:30:53 <Makoryu> For example: do { x <- foo; y <- bar; return (x + y); } ...becomes... (+) <$> foo <*> bar
19:31:01 <danilo2> Makoryu, ricree: I dont think I owuld be able to past today a simple example f the problem :( I'll do it tommorow. Thanks for help :)
19:31:57 <cschneid> Makoryu: just seems like a name for the style of writing code that is used as a shorthand "applicative style". As a semi-noob that's hard to hunt down what it means :)
19:32:04 <Makoryu> cschneid: Applicative style is more flexible than that, though, and generally just implies different intent than writing it as a monad
19:32:07 <cschneid> Makoryu: specifically, I'm reading http://stackoverflow.com/questions/7880555/st-monad-code-smell
19:32:40 <cschneid> "Use Applicative style often." in one of the answers. I know I've seen it elsewhere too
19:34:29 <Makoryu> cschneid: Yeah, that guy links to the Haddock documentation, which doesn't give an especially clear demonstration of what it's actually like
19:35:05 <cschneid> Makoryu: exactly. I can read the doc and use the simplest example (the (+) <$>.... type stuff). But seeing how to solve realish problems that way is the next step
19:36:18 <Makoryu> cschneid: Well, for example, in the question you linked, I might write: mkStRefPair a b = STRefPair <$> newSTRef a <*> newSTRef b
19:36:46 <Makoryu> It's just to make it shorter and easier to read, in the sense that you're abstracting what you mean from how you do it
19:37:09 <cschneid> Makoryu: sure, since it is basically just assigning names to use later. Collapsing that down to a single line is clearer
19:37:31 <cschneid> Makoryu: ie, the "power" that monad gives you wasn't being used, so might as well drop to applicative which is actually what is needed
19:37:46 <Makoryu> Yeah, pretty much
19:37:58 <cschneid> Makoryu: this has a decent answer to it
19:37:58 <cschneid> http://stackoverflow.com/questions/2104446/how-do-you-use-control-applicative-to-write-cleaner-haskell
19:38:02 <Makoryu> That, and monad syntax tends to imply an order of operations, whereas that may not be the case
19:40:32 <Makoryu> The RWH Parsec chapter is probably the best explanation I've seen so far
19:40:38 <Makoryu> Of that last point, I mean
19:41:31 <cschneid> Makoryu: parsec seems to be too popular for its own good. Lots of "look at how cool applicative is" ends up being "look at how cool parsec is"
19:41:40 <cschneid> without being easily expandable to other, non-parsing ideas :)
19:42:01 <Makoryu> I'm not sure I can speak to Parsec's popularity in any capacity
19:43:15 <cschneid> well, most people use it as the cannonical example of applicative code, and ends up explaining the library, and not applicative.
19:43:25 <cschneid> I have like a hundred blog posts to write as I've been learning haskell.
19:43:31 <cschneid> need to get around to it
19:47:52 <jfischoff> So I just profiled the difference between directly constructing a ByteString of JSON with Data.ByteString.Builder and using Aeson, and the difference was smaller than I would have expected
19:48:12 <jfischoff> I was expected like a 10x improvement, but only got 3x
19:48:44 <jfischoff> I have a feeling if I understand more about optimizing Haskell performance I could do much better
19:49:39 <ReinH> So I guess I should have cabal installed all my libraries with -p if I wanted to ever profile anything ever.
19:50:21 <carter> jfischoff: in some performance areas 3x is a huge accomplishment!
19:50:54 <carter> i've example codes where 3x improvement with the same level of code complexity would probably violate physics
19:51:23 <jfischoff> carter: Its proves the thesis for sure
19:51:43 <jfischoff> err hypothesis
19:51:58 <jfischoff> I have feeling the same is true with parsing
19:52:33 <jfischoff> Aeson's approach of creating an intermediate AST is slow, but attoparsec is fast
19:53:05 <td123> hello, I'm trying to build my first networked application in haskell, I have a server: https://gist.github.com/anonymous/6576258 and a client: https://gist.github.com/anonymous/6576244 the server gets the msg from the client correctly, but then stalls when it trys to echo it back with "B.hPut handle request" can anyone gif me a hint?
19:53:44 <jfischoff> if you going to types anyway it would be better to having parsing combinators for json then use aeson in some cases atleast.
19:53:52 <jfischoff> aeson is pretty great though
19:54:44 <td123> I'm wondering if it has something to do with me using a lazy string
19:55:09 <td123> but then I can decode the request just fine
19:55:16 <td123> so I'm kind of stuck
19:58:31 <elifrey> ReinH: you can set that in your .cabal/config
19:59:00 <elifrey> I try to do that when I first install cabal, so I don't have to go back and recompile everything :P
19:59:12 <ReinH> elifrey: weird, it is set.
19:59:22 <ReinH> if you're talking about library-profiling
19:59:37 <ReinH> or do I also need executable-profiling?
19:59:57 <elifrey> ReinH: only if you're building an executable
20:00:20 <ReinH> ah. So how do I run profiling if I don't build an executable? runghc?
20:01:25 <elifrey> ReinH: do you mean your getting the binary from a third-party?
20:01:40 <elifrey> e.g. <your distro's package manager>
20:02:36 <ReinH> elifrey: when I compile with -prof I get "Dynamic linking required, but this is a non-standard build (eg. prof)."
20:03:18 <ReinH> elifrey: (oh, you meant if the library builds an executable that you want to profile.)
20:03:37 <elifrey> ReinH: hoo-boy, I don't know I've not messed with dynamic lynking in haskell
20:04:05 <ReinH> I just want ghc -prof to build :)
20:05:00 <ReinH> oh it's TH's fault
20:05:09 <elifrey> oh joy
20:05:21 <ReinH> but there's a fix http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/template-haskell.html#id3029367
20:05:24 <ReinH> so that's good
20:09:55 * hackagebot ghc-mod 3.0.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.0.2 (KazuYamamoto)
20:10:11 <jfischoff> ReinH: try ghc -c first
20:10:16 <jfischoff> then ghc --make
20:10:31 <jfischoff> you have to build it twice
20:14:47 <carter> jfischoff: I mean if i could have my mostly haskell matrix multiply be 3x faster than it currently is: i've have the worlds fastest CPU based matrix multiply
20:14:54 <carter> i think
20:14:59 <carter> or nearly the fastest
20:15:03 <jfischoff> really
20:15:11 <jfischoff> well that is very good then
20:15:11 <carter> well
20:15:45 <jfischoff> for haskell to be with in 10x of optimized c/c++/Fortran is very good
20:15:53 <carter> jfischoff: nah, its really sloppy code
20:16:01 <carter> i've tricks to make it faster still
20:16:06 <jfischoff> nice
20:16:12 <carter> but not doing those for now
20:16:21 <carter> because the ROI among the things i could do righ tnow is low for htat
20:17:05 <jfischoff> I curious about the difference in server. Directly streaming bytes over vs using Aeson. I bet it becomes 10x then.
20:17:34 <carter> jfischoff: the trick is minimize the number of copies you need to do
20:20:40 <pharaun> 10x? i thought haskell could approach 1x in lots of cases ?
20:20:42 <MedDev> i'm trying to take a list from [ [1,2,3], [1,2,3] ] to [ [1, 1], [2,2], [3,3]] but for some reason the answer is eluding me :/ any tips/ideas?
20:21:21 <carter> pharaun: yup
20:21:22 <elifrey> transpose
20:21:40 <MedDev> elifrey, thanks :)
20:21:54 <jfischoff> pharaun: very special cases
20:22:15 <Makoryu> pharaun: There are still issues with (for example) GC implementation that can ruin your day, but yeah, sometimes
20:22:28 <Makoryu> jfischoff: It's not quite as rare as you seem to imply
20:22:52 <jfischoff> Makoryu: ok
20:23:13 <carter> pharaun:: in my case, the stuff i'm benchmarking against is handwritten assembly customized to the CPU generation
20:23:13 <pharaun> i guess i was under the impression that haskell could approach c in most general cases except number crunching, branching/gc/cache issues, etc
20:23:24 <carter> pharaun: i'm doing the number crunking
20:23:42 <pharaun> carter: ah
20:23:43 <carter> i've actually got osme work planned out for ghc 7.10 that will make it fast as / faster than c / fortran
20:23:56 <carter> C and Fortan are actually kinda a terrible fit for modern hardware too
20:24:54 <carter> Fortran is just ugly and hard to use sanely
20:25:21 <carter> C …. pretends all your operations are in Ram on a single core machine
20:25:31 <pharaun> heh was just mainly wondering cuz i've done hand-crafted asm for x86-64 before
20:25:34 <Makoryu> pharaun: The biggest hurdles for Haskell performance right now are probably pointer indirection (especially when it interacts with cache size) and lack of GC optimization for certain kinds of data structures (so it does more work than necessary, and takes more memory)
20:25:41 <pharaun> guess when i need to i'll still do that then :)
20:25:52 <carter> Makoryu: true, but it depends
20:26:01 <carter> the GC hasn't been a problem for me
20:26:10 <pharaun> nor me, but i've heard it can be a problem
20:26:19 <carter> it can be if you're sloppy
20:26:26 <carter> most of the time its your friend
20:26:42 <Makoryu> It's only really a problem when you need to store your data in memory in certain ways
20:26:49 <carter> which ways?
20:26:59 <carter> mutable pointer data structures I guess?
20:27:09 <Makoryu> If you make giant arrays of things and do certain things to them... I forget what
20:27:15 <carter> Makoryu: yes, pointers
20:27:17 <carter> boxed
20:27:18 <carter> arrays
20:27:20 <carter> update
20:27:26 <carter> 7.8 has some improvments for that
20:27:45 <carter> pharaun:i wrote some pretty cool SIMD intrinsics C last month
20:27:51 <Makoryu> I may be thinking of things that aren't really problems anymore
20:28:00 <Makoryu> My memory of them is poor at any rate
20:28:44 <pharaun> carter: heh simd intrinsics can be fun :)
20:30:28 <carter> Makoryu: the real problem is if you have frequent GCs with lots of live data
20:30:34 <carter> instead of mostly dead data
20:31:03 <carter> because a GC on a generation has complexity like O(| live data |)
20:31:15 <carter> so make sure your data is dead,
20:31:18 <carter> if you want fast gcs
20:31:36 <carter> pharaun: sadly 7.8 SIMD will be crippled :(
20:31:38 <carter> won't be able to shuffle
20:31:57 <carter> i have some plans i hope to get into 7.10
20:32:03 <carter> for making full simd  doable
20:32:48 <pharaun> carter: :( guess i'll keep on dropping down to c/simd for that for now but glad to hear improvements are coming
20:33:04 <carter> pharaun: what sort of simd do you write?
20:33:32 <pharaun> nothing really complicated atm, but mostly image comparing algos/hashing
20:33:41 <ricree> Anyone able to help me wrap my head around c2hs. I seriously can't get even a simple example (that uses --cppopts) to run
20:33:59 <pharaun> i have a old codebase that is c/python that i was looking into porting it over mostly to haskell except for the hot-bits, was going to keep it in c/simd
20:34:09 <carter> yeah
20:34:20 <ricree> could someone show me what the command line instruction would be if I wanted to run a simple .chs that called a function from math.h?
20:34:34 <Clint> run a .chs?
20:34:51 <ricree> err, I mean run c2hs with a .chs that does that
20:35:03 <Clint> let cabal do it for you
20:35:12 <ricree> that hasn't worked for me either
20:35:13 <carter> pharaun: yeah calling out to c is pretty fast
20:35:14 <ricree> like, at all
20:35:16 <pharaun> carter: so for my usecase its probably still best to do what i can then drop down to c/simd for the hot-bits and go from there and revisit :)
20:35:23 <carter> yup
20:35:27 <carter> the ffi is pretty pain free too
20:35:34 <pharaun> yeah good to hear, i haven't had a chance to play with the ffi yet been reading up on it
20:35:45 <pharaun> but gotta finish other project first >_< then i'll get to play with this one, should be fun
20:36:02 <ricree> Clint: Here's the more complex example I was trying earlier http://lpaste.net/93037. Right now, I'm trying to go super basic and get something working at all
20:36:32 <ricree> Clint: but if you don't mind, could you look at my .cabal file (at the bottom of the paste I linked), and let me know what's missing?
20:37:19 <Clint> ricree: you're not #including the .h?
20:40:20 <ricree> Clint: no. How does that fit in. I didn't see it in any of the examples I came across
20:43:56 <ricree> Clint: ok, so that works. That said, for whatever reason, the cabal file isn't including '-I/usr/includes/ganv-1' when it builds. Works when I add that in manually, but why isn't that getting included on it's own? I have ganv-1 in my extra-libraries and pkg-config-depends
20:44:07 <ricree> Clint: but either way, thanks for the help
20:44:24 <hpaste> Clint pasted “math.h example for ricree” at http://lpaste.net/93038
20:44:48 <Clint> ricree: /usr/includeS?
20:45:32 <ricree> ... getting late, apparently.
20:45:39 <ricree> that said, my point still stands
20:46:30 <Clint> and pkgconfig is providing the right include dir?
20:51:01 <ricree> Clint: yes. I just doublechecked
20:52:26 <ricree> Clint: never mind. I think I have it now
20:52:34 <ricree> Clint: thanks a ton for your help
20:53:30 <ricree> Clint: One last question, more as a point of curiosity than anything else. I notice that the gtk2hs .chs files don't use #include anywhere, but still work. Why is that?
20:53:59 <ricree> (though I'll totally understand if you're done answering questions for now. Again, I really appreciate the help)
20:56:40 <Clint> ricree: dunno, maybe x-c2hs-Header does that
21:00:12 <ricree> oh darn, apparently I don't have my cabal file working after all. It was just taking the manually generated .hs file and using that
21:00:23 <ricree> since the .chs hadn't been modified since
21:02:05 <pharaun> man records pattern matching is yucky
21:02:49 <haasn> prisms!
21:04:28 <pharaun> its a list of records and well yeah its just yucky
21:04:36 <pharaun> i should peek at lens
21:04:48 <arkeet> lens is great
21:04:57 <edwardk> i've heard it is interesting
21:05:00 <johnw> pharaun: that's like staring at the time vortex at the heart of the Tardis
21:05:19 <pharaun> ha
21:08:52 <shachaf> I heard that edwardk has been reviewing lens to make it more gettable, eternal mutator that he is. But it'll never be completely accessible.
21:09:08 <edwardk> =P
21:09:37 <carter> johnw: its a great show
21:09:43 <carter> whens the next season starting?
21:09:51 <johnw> no clue
21:09:57 <shachaf> In #-blah, I think.
21:09:59 <carter> i hear its traversable
21:13:25 <ion> clue from #-blah? There’s a prism for that.
21:14:13 <pharaun> i am having a brain fart moment but how do i do this - [Nothing] -> Nothing, and [Just x, Just y] => Just [x, y] ? I'm aware of catMaybes but is there no way i can get out having to check for a null list and replacing it with Nothing and Justing the list i get out of catMaybe ?
21:14:37 <arkeet> sequence
21:14:38 <shachaf> Start with the type.
21:14:43 <arkeet> or listen to shachaf
21:14:52 <shachaf> Then, when you know the type, ask Hoogle.
21:15:18 <pharaun> let's see if it knows this one ;p
21:15:42 <pharaun> sequence
21:15:52 <pharaun> yeah like arkeet said, ok like i said, branfart moment >_<
21:15:59 <pharaun> i've totally used that before *sigh*
21:16:15 <arkeet> make sure it does what you intended when there's mixed Nothing and Just values
21:16:19 <arkeet> > sequence [Just 1, Nothing]
21:16:20 <lambdabot>   Nothing
21:16:32 <pharaun> not what i want :) but i can filter the nothings out
21:16:37 <arkeet> then again, you'd want catMaybes if it wanted the other thing.
21:16:47 <arkeet> you should probably use catMaybes.
21:17:15 <pharaun> arkeet: basically i'm getting a list of [Just a, Nothing, whatever] -> catMaybe will reduce it to [a, whatever], but if its all Nothing it'll be reduced to []
21:17:21 <arkeet> indeed!
21:17:25 <pharaun> i want to have that reduced instead to Just [a], and Nothing
21:17:28 <haasn> is Just [] a meaningful output?
21:17:28 <arkeet> why?
21:17:30 <shachaf> OK, then that's not sequence.
21:17:38 <pharaun> and don't want to have to null check the empty list
21:17:41 <arkeet> what haasn said.
21:17:47 <pharaun> haasn: no
21:17:56 <arkeet> checking for empty list is no worse than checking for Nothing.
21:18:24 <pharaun> sure but the code already is checking for a Just [whatever] or Nothing
21:18:30 <pharaun> meh i'll look at the caller, brb
21:20:54 <ricree> could someone take a look at my .cabal file at the bottom of this paste : http://lpaste.net/93037 ? The <ganv/canvas.h> isn't getting found by c2hs. When running cabal with -v, I notice that there's a missing --cppopts=-I/usr/include/ganv-1. When I add it in manually it works, but I can't figure out why that isn't getting included by cabal in the first place
21:21:24 <pharaun> looked up the parent case, its cos i'm dumping it out to json, so i want a null in the json not a [] in the json
21:21:44 <pharaun> *shrugs* i can probably just put the list/null check at the json dumping step
21:23:26 <pharaun> ok nvm, i'm going to rework the types to be a bit better here then
21:34:44 <simon> hi. I'm trying to fuse Reader with Maybe. http://lpaste.net/8782754863831318528 -- can anyone give a hint?
21:36:08 <ReinH> edwardk: I am a fucking genius
21:36:08 <monochrom> runFoo (f x) env
21:36:46 <edwardk> ?
21:37:14 <arkeet> simon: look at the types of things.
21:37:19 <carter> ReinH: what'd you figureout?
21:37:23 <arkeet> Foo m >>= f = Foo $ \env -> ___
21:37:34 <arkeet> if f :: a -> Foo b
21:37:41 <arkeet> then the thing in ___ better have type Maybe b
21:37:51 <arkeet> f x definitely doesn't have that type.
21:38:00 <ReinH> my around method for calculating a squares of coords
21:38:14 <ReinH> I realized that I can calculate one side and then flip it around using Linear.V2.perp
21:38:21 <edwardk> ReinH: heh
21:38:42 <ReinH> which is quite a bit faster
21:39:30 <carter> yay
21:39:34 <carter> use all the symmetries
21:39:45 <ReinH> :D
21:39:48 <simon> thanks, monochrom and arkeet.
21:39:49 <ReinH> about 30% faster, in fact
21:39:52 <carter> rotaitonally and flip!
21:40:40 <ReinH> but I'm trying to figure out how to do this more elegantly using an unfold or similar:
21:40:44 <ReinH> top V.++ (V.map perp top) V.++ (V.map (perp.perp) top) V.++ (V.map (perp.perp.perp) top)
21:40:52 <applicative> simon: you forgot that f here returns a Foo, but you want a Maybe, as things are .
21:40:55 <ReinH> I can use iterateN but then I get a vector of vectors
21:41:14 <ReinH> and V.concat is [Vector a] -> Vector a
21:41:30 * arkeet V.map <&> iterate perp id
21:41:40 <ReinH> oh.
21:41:40 <arkeet> I dunno.
21:41:42 <ReinH> maybe
21:41:48 <arkeet> er
21:41:52 <arkeet> iterate (perp.)
21:41:52 <carter> idea! what if you view every coord wrt it delta distance from the point
21:41:59 <arkeet> that's probably not very nice though.
21:42:01 <arkeet> I dunno.
21:42:16 <arkeet> why not iterate (V.map perp) top
21:42:18 <carter> then all of a (x,y)   (-x,-y)  (-x,y) and (x,-y)
21:42:23 <carter> all use (x,y)
21:42:24 <carter> right?
21:42:38 <jfischoff_> if I compile with threaded and don't pass +RTS -N in how many cores will be utlitized?
21:42:47 <carter> 1?
21:43:04 <carter> unless you compile wiht -RTS -N :)
21:43:06 <ReinH> carter: I think so?
21:43:10 <carter> ok
21:43:13 <carter> cool
21:43:13 <ReinH> carter: *run with
21:43:19 <jfischoff> right that's what I thought
21:43:22 <luite> yeah 1 is default
21:43:29 <carter> luite: is the expert
21:43:29 <luite> ReinH: you can bake in default rts opts
21:43:35 <ReinH> ahhh
21:43:37 <carter> he ported the rts to js, he'd better know :_
21:43:38 <ReinH> seems good
21:43:39 <carter> :)
21:43:46 <luite> carter: well no -N on js :(
21:43:52 <carter> luite: not yet
21:44:04 <carter> why aren't you on the ECMA7 committe?
21:44:07 <luite> seems unlikely that they're ever going to add it
21:44:20 <carter> "i want parallelism, optional types,  and tail calls"
21:44:30 <luite> i mean shared memory multithreading, that's evil, right?
21:44:31 <carter> luite: could you have mutliple tabs collaborate?
21:44:43 <carter> using websockets?
21:44:48 <luite> sure you can already have multiple processes in a single tab, web workers
21:44:54 <luite> but they don't have shared mem
21:44:57 <carter> soke
21:45:07 <carter> just get a way to have zero copy semantics!
21:45:08 <luite> no par for you
21:45:24 <carter> no user land async neither then
21:45:25 <carter> :P
21:45:26 <luite> there is an api to migrate data to workers, but you have to do so explicitly
21:45:47 <carter> what would the ghcjs api for that look like?
21:47:05 <ReinH> arkeet: I was trying to avoid intermediary lists but then I realized that Vector is smarter than I am and fuses things :)
21:47:20 <ReinH> arkeet: so this is another 30% speedup: V.concat $ take 4 $ iterate (V.map perp) top
21:47:44 <luite> carter: dunno, it could be something like deepseqOnWorker :: NFData a => a -> IO a
21:48:03 <carter> huh
21:48:19 <carter> luite: you could use webworkers inyour compute demos!
21:48:21 <luite> heck it can even be a -> a
21:48:26 <carter> really?
21:48:31 <luite> sure the haskell thread can block
21:48:48 <arkeet> ReinH: but if you're using all the intermediate Vectors then you don't even need to rely on fusion, I think.
21:49:27 <luite> carter: but it'd require quite a bit of RTS machinery
21:49:32 <carter> whys that?
21:49:44 <ReinH> arkeet: intermediate vectors are being reused by iterate, sure
21:49:50 <carter> luite: why not have a Futures a ? :)
21:49:58 <ReinH> arkeet: but I'm hoping that fusion can improve memory usage too
21:52:01 <ReinH> arkeet: btw I was wrong about the speedup for the iterate version :( it had a bug
21:52:26 <luite> carter: find out what parts of the thunk are shared (so they can't be migrated but need copy), so you need to walk the stack, and use some gc machinery to collect all objects
21:52:26 <ReinH> arkeet: it's actually only ~2%
21:52:42 <arkeet> ReinH: oh, well.
21:52:43 <ReinH> huh, actually it's not even statistically significant
21:52:45 <carter> oh
21:52:46 <ReinH> arkeet: but it's cleaner
21:52:48 <ReinH> and it's not slower :)
21:52:48 <carter> for the pure looking one?
21:52:52 <arkeet> ReinH: I was expecting 0%, anyway.
21:52:57 <ReinH> arkeet: well there you go :)
21:53:03 <luite> carter: the thunk objects themselves would probably need to be copied, but the win is in detecting wheter you can move a large ByteArray# to the other side without copying
21:53:07 <ReinH> I was pretty surprised by my initial result but I thought... well Vector is magic...
21:53:18 <arkeet> it sure is.
21:53:27 <carter> ReinH: its magic is called inline all the things + stream fusion :)
21:58:26 <latro`a> is there a way to make a field in a record be the record?
21:59:19 <latro`a> here I have essentially a tree structure, where an island has beaches, and I want to be able to construct an island and at the same time construct beaches whose location is that island
21:59:26 <ReinH> well, it's down from 16.0ms to 10.2ms for a square of 1000 distance from origin
21:59:30 <ReinH> so that's pretty good
22:01:03 <elifrey> latro`a: do you mean having a self-referencing structure?
22:01:08 <latro`a> yes
22:01:52 <elifrey> latro`a: You can make cyclic datastructures with lazy evaluation
22:01:57 <latro`a> sure
22:02:04 <latro`a> I'm asking more precisely how you'd write it
22:02:08 <Makoryu> latro`a: You can exploit laziness to accomplish this ("tying the knot") but if you need to change a part of the resulting data structure, you'll have to rebuild *everything*
22:02:21 <latro`a> hrm
22:02:32 <elifrey> Makoryu: that's when you use a zipper
22:02:35 <latro`a> except that changes happen bottom to top
22:03:01 <latro`a> the top references are essentially just retrievals
22:03:06 <latro`a> er, *top to bottom references
22:03:20 <latro`a> as in, I only update an Island by updating its beaches
22:04:00 <ReinH> arkeet: just grabbed another 20% by fusing a map that Vector couldn't fuse for me
22:04:05 <latro`a> is it actually just
22:04:12 <elifrey> latro`a: have you looked at "tieing the knot" before, are you asking how specifically to do it in your situation?
22:04:14 <ReinH> so I'm at about a 2x speedup now. So that's good.
22:04:17 <latro`a> f x = Foo { bar = f x }
22:04:46 <latro`a> yes, I know what is going on, I just am not entirely sure how to write it, especially in a way that would be able to use sharing to some extent
22:04:54 <latro`a> (similar to the "let x = f x in x" definition of fix)
22:05:07 <ReinH> arkeet: also the code is muuuuch cleaner :) https://gist.github.com/reinh/384a47f6840e27662bfa
22:05:13 <elifrey> latro`a: I've never seen it done with self-recursion, just mutual recursion, so I'm not sure
22:05:31 <elifrey> you can always fire up ghci :) *fires up ghci*
22:06:10 <latro`a> what I wrote seems to result in an infinite type
22:06:27 <latro`a> ...hang on
22:07:03 <elifrey> works for me
22:07:24 <elifrey> data SelfRecurse = SelfRecurse { self :: SerfRecurse }
22:07:38 <elifrey> let x = SelfRecurse { self = x }
22:07:38 <latro`a> should be an r over on the far side, I take it?
22:08:01 <latro`a> OK
22:08:05 <latro`a> that's fine then
22:08:20 <latro`a> I suspect this isn't exactly the idiomatic way to do what I meant, though
22:08:41 <latro`a> what I have in mind is basically a tree where you can do updates from bottom to top and retrievals from both ends
22:09:11 <latro`a> but where the types of the different levels of the tree are different
22:10:06 <elifrey> interesting
22:10:35 <Makoryu> latro`a: So you want to do island -> beach and beach -> island mapping?
22:10:41 <latro`a> yes
22:11:12 <elifrey> latro`a: you could just use an adjacency list
22:11:38 <latro`a> it's not quite that simple
22:11:48 <latro`a> because the beach changes
22:12:28 <latro`a> but yes, that was basically what I was already writing
22:15:55 <hpaste> latro`a pasted “Island” at http://lpaste.net/93039
22:16:08 <latro`a> that's the data declarations I have now
22:17:06 <Makoryu> Huh
22:17:19 <Makoryu> Do you ever actually have cases of Boats without locations?
22:17:50 <latro`a> depends how I decide to think about it
22:18:03 <latro`a> the player has 15 boats, which begin off the board, which I'm thinking of as Nothing
22:18:21 <latro`a> but Boat could instead refer to the boats on the board, and then a player could have a boat counter attribute
22:18:25 <latro`a> that's probably significantly simpler
22:18:30 <Makoryu> (Also these types can't all be in the same module)
22:18:39 <Makoryu> (But I'm sure you know that)
22:18:47 <latro`a> sure
22:19:56 <Makoryu> What other information might you need to know about a beach?
22:20:13 <Makoryu> For example, maybe its position relative to the center of the island?
22:20:15 <elifrey> latro`a: is your name lojbo?
22:20:19 <latro`a> yes
22:20:29 <latro`a> @ elifrey
22:21:03 <latro`a> hmm...its position would be a good thing to track, but that could probably be tracked by jumping back to the island itself
22:21:29 <latro`a> incidentally, that makes me realize that the beach list at an island is of a static length, if I change the type to Maybe Beach
22:21:30 <chrisdone> is this anepisode of LOST?
22:21:32 <Makoryu> latro`a: What I'm saying is, if two beaches have the same island, what distinguishes them from each other?
22:21:44 <latro`a> which boats they have, and which directions they can go
22:21:55 <latro`a> and how many boats they hold
22:21:58 <latro`a> (total)
22:26:41 <Makoryu> latro`a: Would it be outlandish to generate ID numbers for each boat/beach/island?
22:27:38 <Makoryu> In C (and C++) an object's address in memory is implicitly a unique ID, and so you can get away with certain things just by comparing pointers
22:27:49 <Makoryu> In Haskell, not so much
22:28:21 <joelteon> Data.Unique is for that
22:28:41 <elifrey> Makoryu: incidentally, I think this makes equality in Haskell >9000 times better than <other language>
22:29:04 <Makoryu> joelteon: That looks obscenely useful and I wish I knew about it sooner
22:29:27 <elifrey> in haskell, comparison is just lexicographical
22:29:37 <elifrey> how beautifull
22:29:43 <joelteon> yeah
22:29:47 <Ralith> arbitrary unique IDs are usually not the right solution
22:29:50 <joelteon> but performance-wise, comparing two ints is faster than comparing a bunch of record fields
22:30:08 <Makoryu> Hi Ralith
22:30:12 <johnw> joelteon: I remember there being a more fundamental facility for doing that
22:30:30 <joelteon> doing what?
22:30:45 <johnw> making objects "pointer comparable" in effect
22:30:54 <joelteon> oh
22:30:58 <joelteon> i didn't know that
22:31:09 <johnw> but at the moment the name escapes me
22:32:46 <Ralith> (and in this case they are obviously the wrong solution)
22:33:36 <Makoryu> Yeah
22:33:41 <latro`a> umm
22:33:43 <latro`a> well
22:33:49 <latro`a> there's some a priori structure in the shape of the graph
22:34:11 <Makoryu> latro`a: Just to review, you have a logical island, and then several different data structures representing the state of the island at different points in time, correct?
22:34:13 <latro`a> in particular I can just place the islands on a hexagonal lattice
22:34:17 <latro`a> right
22:34:54 <latro`a> but the islands can go in a hexagonal lattice, and the possible beaches can be placed in an array that is always of length 6 and which has the directions built into the position of the island in the array
22:35:18 <Makoryu> My point being, the thing you want to uniquely identify is the logical island, not the representations of its state
22:35:22 <latro`a> indeed
22:35:35 <elifrey> latro`a: does that that lattice give you some intuition?  If so, do you have any pointers on how to gane an intuition on such things?
22:35:38 <latro`a> the internal parts is just for convenience of modification/reference
22:35:49 <latro`a> you mean the hexagonal lattice?
22:35:54 <elifrey> yes
22:36:03 <latro`a> it's not much different from an ordinary rectangular 2D array
22:36:09 <latro`a> except each node has 6 neighbors instead of 4
22:36:35 <Makoryu> I saw a library somewhere for working with such layouts
22:37:17 <latro`a> the downside to representing it in a 2D array is that the node to the northwest of a node should be the same distance as the node to the north
22:37:25 <latro`a> since the nodes themselves are regular hexagons
22:37:56 <Makoryu> latro`a: Again, the logical entity being represented is not synonymous with the representation
22:38:02 <latro`a> quite
22:38:07 <Makoryu> Or, in plainer terms: The map is not the territory
22:38:20 <latro`a> which is why mapping it in a nice way is important
22:38:26 <carter> yup, theres a really nic elib
22:38:28 <carter> @grids
22:38:28 <lambdabot> Unknown command, try @list
22:38:33 <carter> @hackage grid
22:38:33 <lambdabot> http://hackage.haskell.org/package/grid
22:38:43 <carter> http://hackage.haskell.org/package/grid is relaly nice
22:38:46 <latro`a> huh
22:38:52 <latro`a> that's rather fitting
22:39:10 <carter> i don't know who Amy is, but they've been doing some great work on this lib over the past year
22:39:15 <Makoryu> That's the one I was thinking of
22:39:20 <carter> i've really enjoyed watching the evolution of it on hackage
22:41:31 <Makoryu> latro`a: Anyway, let's assume that you build your map of the world as a pure, mutually self-referential data structure
22:41:41 <Makoryu> By tying the knot all over the place
22:42:55 <Makoryu> Every time you update any part of the object graph, you have to rebuild literally everything, because you don't know which nodes are part of a cycle and you have no way of finding out
22:43:06 <latro`a> indeed :(
22:43:23 <Makoryu> Even assuming you can do this in a painless way, what happens when the map is very large?
22:43:49 <Makoryu> For example, if you have thousands of islands, each with dozens of beaches, each with dozens of boats
22:43:58 <latro`a> how would you enforce a system where update is possible bottom to top while examination is possible top to bottom?
22:44:16 <latro`a> and thereby gain the efficiency of not having cycles
22:45:41 <latro`a> it seems like it should be feasible to sort of assemble a graph with "mutable" and "immutable" edges
22:45:57 <Makoryu> latro`a: The first thing I'd try is to find information which uniquely identifies each part of the object graph and can function as an index into some collection
22:46:23 <Makoryu> For example, maybe for islands, that would be their locations on the grid
22:46:40 <latro`a> sure, that much is not hard
22:46:48 <elifrey> sounds vaguely like atribute gramars?
22:47:00 <Makoryu> In cases where no such information can be discovered from the definition of the object I'm representing, I would have to invent it
22:47:24 <latro`a> an island can be identified by its position in the grid; a beach can be identified by its position on the island; a port can be identified by its island and which direction it goes in; and a boat is identified by what beach it's on
22:47:28 <latro`a> (and its color)
22:47:51 <Makoryu> latro`a: But a boat can move from beach to beach, right?
22:47:59 <latro`a> yes
22:48:06 <Makoryu> And still be the same (logical) boat
22:48:17 <Makoryu> And multiple boats of the same color can be on the same beach?
22:48:20 <latro`a> arguably, but why does that need to be tracked?
22:48:28 <latro`a> the board state is the game state
22:48:39 <Makoryu> That's what I mean to ask
22:48:39 <latro`a> the boat is essentially memoryless
22:48:44 <Makoryu> *Does* it need to be tracked?
22:48:44 <Makoryu> Okay
22:48:58 <latro`a> and yes, multiple boats of the same color can be on the same beach
22:49:11 <Makoryu> Can a boat be anywhere besides a beach?
22:49:23 <latro`a> technically it can be in the player's supply
22:49:27 <latro`a> ah sorry
22:49:41 <latro`a> it can be on the sea as a turn is resolved
22:49:53 <latro`a> but at the start and end of each turn it is on a beach
22:50:23 <Makoryu> If a boat is en route from one place to another, do you need to keep track of where it's going at any point?
22:50:30 <latro`a> being in the supply doesn't need to be encoded; seeing as the boat is memoryless, you can just treat the supply as an integer
22:50:56 <latro`a> technically, once it has left a beach, its direction is predetermined by the game mechanics
22:51:01 <carter> latro`a: could you draw some pictures to share with us?
22:51:05 <Makoryu> May I suggest that you can also treat each beach as a supply of boats?
22:51:13 <latro`a> I'm actually just describing tongiaki, which you can google
22:51:14 <latro`a> :)
22:51:31 <latro`a> I should probably have said that
22:51:43 <latro`a> hmm...that's an interesting idea
22:51:53 <latro`a> a single type of "boat supply"
22:59:02 <Makoryu> latro`a: The information I'm finding isn't clear. Does every island have exactly six beaches, one per side?
22:59:13 <latro`a> every island has exactly six possible beach locations
22:59:27 <latro`a> it is possible that some of these locations have no beach actually present
22:59:37 <latro`a> in this case you can land on that side but cannot leave via that side
22:59:52 <latro`a> and cannot place a boat on that side, either
23:00:02 <Makoryu> But there's never a case where two beaches share the same side of the same island?
23:00:35 <latro`a> the beach can be identified by what side of the island it's on, but I *think* sometimes beaches share a port
23:00:44 <latro`a> i.e. two adjacent beaches both let you go out in the same direction
23:00:51 <Makoryu> Hmm
23:01:42 <latro`a> a simpler way of thinking about it is just that, say, the NE beach might let you go N, NE, or E, depending on the island
23:01:49 <latro`a> and it could be more than one, too
23:02:25 <latro`a> err...wrong identifiers, seeing as there are 6 directions, not 8, but that's the gist
23:02:47 <Makoryu> Let me just ask this
23:02:59 <peteretep> Anyone tried to teach a Haskell course based off The Little MLer - how did it go?
23:03:24 <peteretep> My team want to expand their mind a little and learn Haskell, and LYAH takes too long to be fun
23:04:12 <Makoryu> latro`a: If you have some enumeration representing direction of movement (NW, N, NE, SW, S, SE, or however you want to label them) and an island is identified by its (X, Y) coords, could beaches be uniquely identified by (x, Y, Dir)?
23:04:55 <peteretep> Makoryu: Only on regular octogons (or lessergons)
23:05:23 <Makoryu> peteretep: latro`a is working with hexagons, actually
23:05:23 <latro`a> no, because it depends on the orientation in which the island was placed on the board
23:05:38 <peteretep> ah
23:05:40 <latro`a> which is an issue I forgot about
23:06:01 <peteretep> latro`a: So (Side,Orientation)?
23:06:05 <Makoryu> latro`a: Then instead of "direction," read "side number"
23:06:40 <latro`a> one or the other, yeah
23:07:36 <benl23> nominolo: ping?
23:09:12 <latro`a> you can also turn it into just "direction"
23:09:15 <latro`a> on the turn the tile is played
23:10:16 <latro`a> that is, once the tile is on the board, the direction is a sufficient identifier, but just the name and the location is not
23:10:33 <latro`a> er, *name of the island and the direction
23:11:39 <Makoryu> latro`a: When I ask if something is uniquely identifiable by some property, I mean that if two entities in the game both have the same value for that property, they must be the same entity
23:12:38 <Makoryu> If an island is not uniquely identifiable by its location, that must mean two different islands can have the same location
23:12:42 <johnw> joelteon: I was thinking of StableName
23:12:47 <joelteon> oh
23:13:47 <Makoryu> latro`a: There may be additional information about an entity which is necessary for describing it completely but not for uniquely identifying it
23:14:45 <Makoryu> If an island faces in a particular direction, I'd expect it to be the latter kind of property, not part of its unique identifier
23:21:45 <ReinH> edwardk: haskell performance is now officially confusing the crap out of me :(
23:23:12 <ReinH> edwardk: a 10% speedup in an inner function caused the outer function to be 15% slower. o_O
23:23:17 <ReinH> I don't even.
23:23:46 <pharaun> how are you measuring the performance anyway?
23:23:58 <flebron> haskell has performance?
23:24:04 <ReinH> pharaun: criterion
23:26:07 <carter> ReinH: faster but fuses less?
23:26:20 <carter> have you tried adding inline pragmas eeverywhere yet? :)
23:26:55 <ReinH> carter: the thing is, this function is only called once.
23:27:02 <carter> ok
23:27:09 <carter> you could still fuse the inside bits
23:27:26 <ReinH> what do you mean?
23:27:34 <carter> is the function made of other function you define
23:27:40 <carter> or is it that one liner ?
23:27:48 <ReinH> it is composed, yes
23:27:59 <ReinH> but it's faster per se than the previous version
23:28:14 <carter> ok
23:28:23 <carter> i'm just thinking of tricks to make it faster
23:28:25 <Ghoul_> flebron: shhh
23:28:27 <Ghoul_> haskell is fast
23:28:31 <ReinH> both generate a vector that is then used as the traversal order for the iterative part of the algo
23:28:43 <ReinH> the only difference is that the ordering is slightly different in one
23:28:58 <ReinH> I don't think that would make a difference but perhaps it does
23:29:01 <Ghoul_> people say java beats it and java is slow, yadda yadda, but the so-called java that beats our beautifully naive haskell looks like a dogs breakfast
23:29:09 <Ghoul_> the more real-world something is, the faster haskell feels.
23:29:44 <peteretep> And yet ... I still find myself breaking out the profiler from time to time
23:29:54 <peteretep> which may be because I'm a newb
23:29:57 <Makoryu> latro`a: I have to go now, but maybe ask people in #haskell-game if you're still having trouble
23:31:34 <carter> edwardk: https://ryanseys.com/blog/177-days-of-github/ tricks to up your hotstreaks
23:32:27 <carter> Ghoul_: which beats which?
23:32:29 <edwardk> heh that guy made it ~20 days longer than i did
23:32:45 <carter> but with less interesting commits no doubt
23:33:42 <carter> Ghoul_: after 7.8 is cut / out, lets relook at the shake stuff? theres a bunch of folks who'll be game then
23:37:48 <latro`a> hmm...if anyone wants to continue that discussion, I guess I have a question about this issue of unique identifier vs. relevant attribute
23:38:39 <latro`a> you may have a pre-generated collection of attributes for an object that uniquely identify it before a certain state change, and then new attributes become required after the state change
23:38:48 <latro`a> should it then be a new object, perhaps even with a new type?
23:39:20 <Ghoul_> carter: sure
23:39:24 <carter> woot
23:39:27 <carter> :)
23:39:43 <Ghoul_> carter: Java beats Haskell if both languages push the boundaries of esoteric'ness
23:39:49 <latro`a> for example, tiles that *can* be played vs. tiles that *have* been played: the first can be identified by name with the proper function, but the second needs a position (and in my case an orientation or something equivalent thereto)
23:39:55 <Ghoul_> but for idiomatic *real* code, Haskell smashes java.
23:40:03 <carter> yeah
23:40:16 <carter> Ghoul_: once i get my array lib out, i suspect youll have fun
23:40:16 <ReinH> carter: inline ALL THE THINGS
23:40:32 <Ghoul_> we should get people together and redo all the computer language benchmark game stuff
23:40:32 <carter> ReinH: except when it blows up your I-cache or makes ghc die
23:40:41 <ReinH> carter: :)
23:40:50 <carter> i did the latter by accident :)
23:40:53 <Ghoul_> some of those benchmarks are really really dated and we could do better nowadays
23:41:00 <carter> Ghoul_: true!
23:41:03 <carter> once 7.8 lands
23:41:18 <Ghoul_> I heard cabal 1.18 is shipping in HP w/ 7.8?!
23:41:19 <Sakako1> latro`a: why not have position as part of the tile type?
23:41:21 <carter> heck, also worth having that suite as a mini nofib
23:41:28 <carter> Ghoul_: HP will have 7.6
23:41:34 <carter> and 1.18
23:41:38 <Sakako1> tiles that haven't been placed can have position -1,-1 or something
23:41:40 <Ghoul_> Awww
23:41:55 <carter> Ghoul_: and we acutlaly should give mark a hot fixed GHC for mac
23:41:56 <Ghoul_> How long do I have to wait to get 7.8 in HP :/
23:42:04 <carter> Ghoul_: why do you want HP?
23:42:10 <latro`a> Sakako1, I guess, but that's a basic, static thing, something that probably could live in the types
23:42:12 <Ghoul_> because windows
23:42:16 <carter> oh?
23:42:17 <Ghoul_> we dont have a package manager in windowsland
23:42:37 <carter> Ghoul_:: use HP to get a nice cabal, then install newer ghc
23:42:42 <latro`a> though I suppose it is mechanically clean to simply put them in an inaccessible location
23:42:50 <elifrey> TIL: there is a seperate cache for instructions and data
23:42:50 <Ghoul_> hmm, maybe if someone builds one
23:42:54 <Ghoul_> I still cant get mine to build.
23:42:56 <Sakako1> Yeah, I mean that's the simple way to do it
23:43:18 <elifrey> is there such a thing as a cache-oblivious algorithm?
23:43:36 <carter> elifrey: "cache oblvious *optimal*" yes
23:43:48 <carter> google em
23:43:49 <carter> lots of them
23:43:51 <carter> handy
23:43:55 <carter> easier to write than you expect
23:44:09 <carter> elifrey: also ask edwardk  :)
23:44:15 <carter> i've writeen a few
23:44:20 <elifrey> carter: obvs
23:44:21 <carter> but he's written more
23:44:42 <latro`a> actually, you could just have position in a Maybe
23:45:01 <latro`a> that's more explicit than adding an arbitrary inaccessible index
23:46:20 <Sakako1> oh yeah
23:46:22 <Sakako1> of course!
23:46:44 <carter> elifrey: context?
23:47:28 <elifrey> carter: I said obvs as in obviously as in *rolls eyes of course edwark has*
23:47:35 <carter> no
23:47:45 <carter> i mean context of why you wonderd if they existed
23:47:57 <elifrey> oh
23:48:08 <elifrey> well, I was aware of cache oblivious datastructures
23:48:22 <elifrey> but I'de never thought that your instructions could be cache-unfriendly
23:48:34 <elifrey> so when I looked up I-cache I was like *strokes beard*
23:49:03 <carter> well
23:49:05 <carter> ohhh
23:49:26 <carter> cache obliv algs === cache oblive data structures for most folks
23:49:33 <carter> its really hard to lie to the icache
23:49:48 <carter> or at least , you could do crazy dynamic code gen things
23:49:54 <carter> that make it bad
23:50:12 <elifrey> but having too much inlining can make your code i-cache unfriendly?
23:50:20 <carter> well
23:50:39 <carter> cache oblivious is usually read to mean "optimal, even ifyou don't know cache size"
23:50:50 <elifrey> right
23:51:05 <carter> if your inlining makes your innner loop > 64kb, that'd be bad
23:51:12 <carter> probbably
23:51:19 <carter> but thats a HUGE algorithm
23:51:42 <carter> that said, control flow is easier than data accessf flow
23:51:51 <peteretep> latro`a: It's going to come down to how you want to /use/ it, rather than any form of higher truth
23:52:03 <latro`a> true
23:52:12 <peteretep> peteretep: Do you need to be able to look it up via an identifier?
23:52:21 <peteretep> latro`a: or just by its attributes
23:52:41 <peteretep> Do events or other things needs to be able to be related to it, and do those relations change based on attribute changes?
23:52:50 <latro`a> oh, you're speaking rhetorically
23:52:53 <latro`a> I started writing an answer
23:52:54 <latro`a> :)
23:52:59 <peteretep> Am I?
23:53:01 <latro`a> oh
23:53:04 <latro`a> did you want to know?
23:53:15 <peteretep> Oh, I see what you mean
23:53:30 <peteretep> I can help you make a decision if you'd like, but I think one will be obvious to you
23:53:37 <Ghoul_> :| at the end of the day, you're at mercy to #8048 as to whether your code fits in the cache or not
23:53:43 <latro`a> I'd say islands and beaches need an identifier, since you should be able to point to an island or a side of an island and grab the island or the beach
23:53:50 <carter> Ghoul_: which gbug?
23:53:51 <latro`a> but boats don't need one
23:54:00 <Ghoul_> the one that causes pages of mov spills
23:54:02 <peteretep> latro`a: What does "grab" mean? Does something have ownership of it?
23:54:04 <Ghoul_> <_<
23:54:17 <latro`a> to retrieve what's there, such as for display or modification
23:54:38 <latro`a> (pretty much just one of those two, I guess)
23:54:44 <carter> Ghoul_: didnt you also recently learn that register renaming solves tha tmostly? :P
23:54:52 <peteretep> Perhaps, but you might be able to simply derive what you're going for based on searching via attribute
23:55:15 <Ghoul_> it reduces the performance impact, but it's still there
23:55:15 <latro`a> well, maybe, it depends on how the IO pipeline ultimately goes I guess (seeing as this is meant to be interactive)
23:55:22 <carter> Ghoul_: that said, a clear proposal for how to fix it is wellcome
23:55:23 <Ghoul_> it doesn't cause the code to magically fit in the cache though
23:55:27 <carter> if you can cook one up
23:55:42 <peteretep> Anyway, the point remains. Work out what you need to be able to do, and then pick the data model that makes it easiest :-)
23:55:53 <Ghoul_> I have /no idea/ why it spills like that. It's illogical, and probably some shit tier edge in that is present in both the ncg and llvm O_o
23:56:04 <latro`a> it's apparent what's needed, I'm just still new at extracting the data model to make it easy
23:56:05 <carter> Ghoul_: well
23:56:14 <carter> if you could id whats triggering it
23:56:17 <Ghoul_> Although, I bet if ghc didn't use Sp[], llvm would solve it
23:56:26 <carter> explain?
23:56:44 <Ghoul_> but llvm seems obliged to want to put things back onto the stack because ghc tells it to
23:56:56 <carter> eh?
23:57:00 <carter> explain this more please?
23:59:12 <carter> Ghoul_: explain more?
