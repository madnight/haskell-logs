00:05:23 <mrotondo> arkeet: I could have some kind of correspondence for tokens in the grammar to prompts in the interface, so that (roughly) if I expect a location next, I can say "Where?" to the user
00:05:40 <arkeet> I agree.
00:06:01 <arkeet> I just don't know how suitable existing parser libraries are for that.
00:06:01 <mrotondo> and do online parsing instead of after some "finish" token is received
00:06:18 <arkeet> yup
00:06:18 <mrotondo> mm
00:06:33 <mrotondo> well, I'm gonna sleep on it
00:06:41 <arkeet> I'm gonna sleep too.
00:06:44 <mrotondo> but thanks again for the thinks
00:06:46 <arkeet> :)
00:06:47 <mrotondo> g'night
00:06:47 <arkeet> cya
00:09:05 <Kaidelong> I just wanted to say that the frequent need for mingw and perl is really, really unfortunate for hackage
00:09:44 <Kaidelong> it isn't fun when you need to reconcile things that only work with mingw with things that don't work with it
00:10:55 * hackagebot cabal-db 0.1.3 - cabal-db  http://hackage.haskell.org/package/cabal-db-0.1.3 (VincentHanquez)
00:31:18 <elifrey> Kaidelong: yikes, that does sound painfull
00:33:41 <elifrey> I have an application I wrote for windows that is now in maintenance mode, but WX was my only native dependency
00:41:33 <Kaidelong> elifrey: I found a lovely sourceforge page just after I griped about that http://sourceforge.net/projects/mingwbuilds/
00:43:43 <Kaidelong> it at least gave me the Qt dependency I was needing
00:57:40 <cinimod> hamishmack: https://github.com/bgamari/gtk2hs/pulls
00:59:24 <hamishmack> cinimod: cool
01:02:37 <cinimod> hamishmack: I sent an email to the gtk2hs mailing lists.
01:03:15 <cinimod> hamishmack: Perhaps it would be worth doing a "bugfix" release?
01:09:56 <Suit_Of_Sables> howdy folks, anyone have any books on haskell they really enjoyed that they could recommend?
01:10:45 <brooke_peterson> hi, i like: http://learnyouahaskell.com/
01:20:25 <Ghoul_> LYAH then RWH
01:20:34 <Ghoul_> that is, learnyouahaskell and real world haskell
01:20:48 <Ghoul_> but beware, RWH is really hard to begin with - it's much faster paced.
01:21:08 <Ghoul_> covers more stuff like performance and unit testing though
01:22:14 <brooke_peterson> :Ghoul_ you're right, I have RWH and went back to LYAH to learn the basics
01:23:06 <t7> file not found: *hs-boot
01:24:10 <t7> wtf m8
01:24:47 <t7> is this repo missing a file?
01:27:52 <t7> ah was missing bnfc, my fault
01:47:04 <xpika> whats the most concise way to convert from a Data.Tree to another tree shaped ADT?
01:48:56 <johnw> you mean, a function from Data.Tree a to TreeShaped a?
01:51:02 * hackagebot OpenAFP 1.3.2 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.3.2 (AudreyTang)
01:52:54 <quicksilver> data.tree seems to be missing some natural functions
01:53:16 <quicksilver> it doesn't have the generic tree fold
01:53:40 <quicksilver> (although several variations of *un*fold)
01:53:59 <quchen> quicksilver: "generic tree fold"? Is that different from Foldable?
01:54:04 <quicksilver> yes
01:54:24 <quicksilver> I was referring to the natural ....-morphisms
01:54:30 <quicksilver> btu I always forget which is which
01:54:34 <quicksilver> catamorphism possibly
01:56:04 <quicksilver> f :: (a -> r) -> ([r] -> r) -> Data.Tree a -> r
01:56:05 <quicksilver> I think.
01:57:24 <quchen> Hm. I always thought "catamorphism" is a fancy way of saying "fold".
01:57:35 <johnw> pretty much
01:57:43 <johnw> a natural transformation is what the original question was about
01:57:55 <johnw> mapping Data.Tree a to some other Functor f => f a
01:58:42 <quicksilver> so, then, f (\l -> Node l []) (\l xs -> Node l xs) is id
01:58:43 <johnw> a catamorphism in this case applies a Tree algebra in order to map Data.Tree a -> b
01:58:57 <quicksilver> and by replacing 'Node' with the constructor(s) of your other tree-like ADT
01:59:03 <quicksilver> you can convert your tree to a different type
01:59:08 <quicksilver> and, I got the type of f wrong :)
01:59:15 <quicksilver> f :: (a -> r) -> (a -> [r] -> r) -> Data.Tree a -> r
01:59:27 <quicksilver> missed that Data.Trees are labelled at each point.
01:59:36 <quicksilver> quchen: yes but "fold" is less precise.
01:59:55 <quicksilver> quchen: sometimes fold is used for things which lose all structure and can essentially only produce monoid-like summaries
01:59:56 <quchen> So it would be more accurate to say "a catamorphism is a function that replaces constructors with functions", such as List.foldr, maybe, either
02:00:20 <quicksilver> quchen: the fold from Data.Foldable, in particular, flattens structure in this way
02:00:26 <quicksilver> so it couldn't be used to answer the questioner's question.
02:00:38 <quicksilver> 'Yes' to replacing constructors with functions, that's right.
02:00:55 <quchen> … the "such as" part was wrong then?
02:01:08 <quicksilver> no, the suchas part was also right
02:01:13 <quchen> Oh.
02:01:19 <quicksilver> foldr, maybe, either are all catas.
02:01:40 <quicksilver> however with recursive types you can do two slightly different things with the recursive bit
02:01:46 <quicksilver> and they have different names.
02:02:22 <quicksilver> but I've forgotten what.
02:02:31 <JuanDaugherty> was "id" a typo?
02:02:42 <quicksilver> no.
02:02:45 <quchen> I don't understand how that concept is mightier than Foldable though.
02:02:59 <quicksilver> quchen: on list they are equivalent
02:03:10 <quicksilver> quchen: but try to use foldable to convert between two types of binary tree
02:03:32 <JuanDaugherty> -empotent?
02:03:52 <quchen> No, he meant "id" as in "id x = x".
02:03:56 <quicksilver> JuanDaugherty: I just got it wrong, basically. Because Data.Tree only has one constructor.
02:04:08 <quicksilver> JuanDaugherty: I really did mean 'id' but I got the wrong catamorphism.
02:04:13 <JuanDaugherty> ah
02:04:25 <b__> Is mappend = (+) theoretically correct?
02:04:31 <quicksilver> f :: (a -> [r] -> r) -> Tree a -> r
02:04:43 <b__> for Num types
02:04:45 <johnw> b__: for the Sum monoid that is true
02:04:53 <johnw> but not for the Product monoid
02:05:05 <b__> okay
02:05:47 <johnw> quicksilver: that's almost a paramorphism
02:05:54 <johnw> which would be (Tree a -> [r] -> r) -> Tree a -> r
02:07:32 <quicksilver> edwardk wrote something fairly detailed about this stuf - https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms
02:07:59 <quicksilver> but, it fails to clearly satisfy my vague "there were two different ways to handle recursion" niggle ;)
02:08:01 <b__> the Num type is confusing me. Why both (*) and (+)?
02:08:34 <quchen> b__: You'd be doing it wrong if the numeric typeclasses weren't confusing you.
02:08:42 <quchen> My advice is to accept them.
02:09:15 <b__> I'm exploring other possible hierarchies, to learn
02:09:42 <b__> But while writing them I get more and more confused by the current state of affairs
02:11:03 * hackagebot OpenAFP-Utils 1.3.1.2 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.3.1.2 (AudreyTang)
02:12:16 <boothead> Morning all, does anyone have any experience of testing things that have date and time properties with smallcheck?
02:13:48 <quchen> quicksilver: That article is fairly vague on anything. It just throws code at the reader :-/
02:17:02 <brooke_peterson> :boothead still learning, but it looks cool
02:18:58 <boothead> brooke_peterson, i'm just worries that I'm going to be adding Serial instances all the way down!
02:20:41 <b__> How do I shut up GHC's "Could not deduce .. (Num a) .. literal ..." :(
02:20:51 <copumpkin> it's not something you shut up
02:20:56 <copumpkin> it's trying to help you understand what's wrong
02:21:04 <mauke> b__: 2>/dev/null
02:21:14 <copumpkin> the compiler is not your adversary that you need to appease
02:21:36 <b__> Well, I want to write my own Num-ish typeclasses
02:25:48 <b__> I'd like it to read my 1 as an Integer, not as some Num a
02:26:38 <Suit_Of_Sables> Thanks guys, I was looking at both those books. Fast paced isn't bad. I get bored quickly with books on programing languages start: "so lets talk about what variables are" *groan* I'd rather they assume I know basic programming concepts and just show me the implementation in the specific language
02:26:41 <brooke_peterson> :boothead I found a pdf about smallcheck http://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf
02:27:08 <b__> nvm I could define the mult. identity as 1 and then work from there >_>
02:27:25 <brooke_peterson> :Suit_Of_Sables :) cool
02:27:42 * JuanDaugherty is missing sumthin
02:28:52 <johnw> b__: what about "default (Integer)"?
02:30:38 <boothead> brooke_peterson, thanks. It makes me feel important and clever when I have to read a thesis before I can use a piece of software :-D
02:31:07 <brooke_peterson> :boothead :)
02:55:21 <Flonk> for some reason I don't quite understand whats going on when you compose higher order functions.. maybe someone in here can give me the intuition. Consider this:
02:55:32 <Flonk> @let ones = let x = take 10 . repeat in map x $ x 1
02:55:35 <lambdabot>  Defined.
02:55:59 <Flonk> @run (foldl'.foldl') (+) 0 ones
02:56:03 <lambdabot>   100
02:56:16 <Flonk> Why does this work?
02:56:32 <copumpkin> > map (replicate 10) $ replicate 10 1
02:56:33 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1...
02:56:44 <copumpkin> take 10 . repeat = replicate 10
02:56:51 <Flonk> Good to know, thanks
02:56:53 <copumpkin> just substitute it in
02:57:23 <copumpkin> > replicate 10 1
02:57:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
02:57:28 <copumpkin> now for each of those, replicate it 10 times
02:57:44 <Flonk> The problem is the foldl' part, I don't quite see how the arguments are applied
02:58:02 <Flonk> Like, how does the outer foldl' know that it should (+)
02:58:03 <copumpkin> expand it out
02:58:05 <copumpkin> @src (.)
02:58:05 <lambdabot> (f . g) x = f (g x)
02:58:05 <lambdabot> NB: In lambdabot,  (.) = fmap
02:58:20 <copumpkin> ((foldl'.foldl') (+)) 0 ones
02:59:03 <copumpkin> > foldl' (foldl' (+)) 0 ones
02:59:06 <lambdabot>   100
02:59:27 <copumpkin> in other words, the outer foldl' doesn't know about (+) at all
02:59:56 <Flonk> Okay yeah, I think I see what's going on
03:00:14 <copumpkin> > foldl' (foldl' (+)) 0 ones :: Expr
03:00:19 <lambdabot>   0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +...
03:00:22 <copumpkin> lol
03:01:08 <Flonk> copumpkin: Thanks a bunch, that simple expansion helped a lot
03:01:16 <copumpkin> np :)
03:01:21 <copumpkin> when in doubt, expand it out!
03:01:36 <Lethalman> @where Expr
03:01:37 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
03:01:46 <Lethalman> what Expr is that?
03:01:55 <Lethalman> simple-reflect?
03:02:01 <copumpkin> I think so
03:04:57 <exicer> Perhaps someone can help me understand
03:05:19 <exicer> People keep saying that you should separate io code from pure code, which sounds like a good idea
03:05:30 <exicer> but if the pure code has to use a value that comes from IO, how are you supposed to do it ?
03:05:39 <exicer> just promote all of the pure code to the IO monad ?
03:06:28 <exicer> as an example, say I want to generate a list of all of the days from 1960 to the current date.
03:06:32 <Ghoul_> :| C looks crap when I use the haskell naming conventions in it. It sucks they had to go ahead and make all the built-in's lowercase
03:06:48 <exicer> I can get the current date using getCurrentTime
03:06:56 <exicer> which is in IO
03:07:11 <chrisdone> exicer: you tend to get all the stuff you need up front and then pass it down to the pure code
03:07:40 <Ghoul_> unless you're writing a server, and then you're basically condemned to the IO monad
03:07:45 <exicer> chrisdone: When you say pass it down, do you mean lift it into IO or something ?
03:07:49 <boothead> exicer, you'll tend to use IO's functor instance a lot and map
03:07:54 <Ghoul_> because if aggressive "monad creep"
03:07:57 <Ghoul_> *of
03:07:58 <dalaing> exicer: date <- getCurrentTime
03:07:58 <dalaing> putStrLn (daysFrom1960 date)
03:08:02 <hvr> IOW, pure-code lives in a time-frozen world
03:08:09 <dalaing> exicer: where daysFrom1960 is a pure function
03:08:28 <exicer> dalaing: right, but won't date still be in IO ?
03:08:40 <Ghoul_> No, it's pure on the left of the <-
03:08:55 <exicer> hmm, but it still has to live in an IO do block ?
03:08:56 <Ghoul_> to confirm this, make it the last thing in the do expression and see the error you get
03:09:05 <Ghoul_> to promote it back to IO, you need to use return
03:09:18 <exicer> Ghoul_: Ah, okay
03:09:31 <dalaing> exicer: daysFrom1960 is pure, it doesn't need to live in an IO block
03:09:39 <Ghoul_> It's because of how >>= works actually
03:09:43 <Ghoul_> if you want to go into the specifics.
03:09:49 <dalaing> it just happens to be used in an IO block for the particular problem you're describing
03:09:56 <exicer> dalaing: Ohhh
03:10:16 <exicer> I was imagining that it would all.. I don't know, not happen in a do block I guess :p
03:10:34 <copumpkin> ultimately main is an IO action
03:10:35 <dalaing> so you can test it with QuickCheck, compose it from other pure functions, generally have a rollicking good time
03:10:45 <copumpkin> so everything needs to be in IO by the time you run the program
03:10:45 <exicer> Okay, so that sounds fine - but what if in the course of this IO you find you need to use some other monad ?
03:10:51 <exicer> Maybe for instance
03:10:55 <boothead> exicer, it doesn't have to be in a do block you could also do it like this: daysFrom1960 <$> getCurrentTime where daysfrom1960 is UTCTime -> [UTCtime], getCurrentTime is IO UTCTime and the whole thing is IO [UTCTime]
03:10:59 <exicer> how do you deal with this death by monads
03:11:01 <copumpkin> it's not like you have a "monad in scope"
03:11:05 <copumpkin> and you can only use one at a time
03:11:39 <copumpkin> just use Maybe in your function and nothing changes
03:11:57 <copumpkin> if you want to interleave it with IO, there's a monad transformer for that, but most of the time you won't
03:12:10 <mauke> monads are a tool you can use, not an encumberance
03:12:29 <copumpkin> exicer: Maybe is, among other things, a Monad instance
03:12:32 <copumpkin> it is many other things
03:12:37 <exicer> mauke: Yeah, I do get that, but it is quite hard to go from reading a text book to seeing how you actually use the things
03:12:38 <copumpkin> and the fact that it is a monad only adds power
03:12:58 <Ghoul_> and performance overhead
03:13:06 <copumpkin> really?
03:13:15 <dalaing> exicer: http://www.seas.upenn.edu/~cis194/lectures.html <- awesome resource
03:13:29 <Ghoul_> well, monads not really. Transformers are brutal though
03:13:30 <dalaing> exicer: although monads are only near the end
03:13:41 <exicer> dalaing: Will have a look.
03:14:00 <copumpkin> monads are really overhyped
03:14:08 <exicer> I am also wondering if I am just too stupid to get haskell :P
03:14:10 <dalaing> exicer: it's introductory though - RWH is pretty nice for getting used to using monads / monad transformers
03:14:15 <Ghoul_> reading from the trac though it looks like IO doesn't get unboxed
03:14:16 <copumpkin> exicer: no you aren't
03:14:16 <exicer> it is taking me a long time to get these concepts
03:14:18 <copumpkin> if you haven't been doing haskell for a while, just forget about the word
03:14:23 <Ghoul_> so IO particularly might have some extra overhead
03:14:25 <copumpkin> you don't need to understand what a monad is to do 99% of haskell
03:14:42 <dalaing> exicer: you're asking questions that indicate that you'll do fine with haskell if you keep trying stuff
03:15:03 <mauke> (in particular, you don't need to grok "monads" to understand IO)
03:15:09 <exicer> dalaing: copumpkin Well that is a relief :p
03:15:18 <exicer> I think I actually do get monads on some level
03:15:26 <boothead> exicer, my approach is to keep banging my head against it... Over the last two years I've started to feel a bit less stupid - it never goes away though :-)
03:15:32 <exicer> but then I read about monadPlus or whatever and don't really get it
03:15:48 <Ghoul_> haha boothead
03:15:49 <copumpkin> the hype around them is annoying, because someone will pick up haskell and on their first day try to figure them out, fail, and then will say haskell is impractical
03:16:23 <copumpkin> the hype around them is mostly not from experienced haskellers
03:16:24 <exicer> I think the thing is that there seems like there is so much more
03:16:33 <exicer> it is a bottomless pit of stuff you should know :p
03:16:36 <mauke> @src MonadPlus
03:16:37 <lambdabot> Source not found. Just try something else.
03:16:43 <exicer> mauke: I might mean mplus
03:16:45 <copumpkin> yup, you can pick up as much of it as you're interested in :)
03:17:10 <mauke> instance (Monad m) => MonadPlus m where mzero :: m a; mplus :: m a -> m a -> m a
03:17:20 <mauke> MonadPlus adds two operations
03:17:29 <exicer> mauke:  Yeah, and for lists it makes sense
03:17:36 <Ghoul_> monoid is like a squashing thing
03:17:38 <exicer> but I don't really see why Maybe works like it does
03:17:40 <boothead> exicer, that it true. but the more you learn the more it all starts to have a very similar underlying structure.
03:17:45 <Ghoul_> monadplus is like a nicely *adding* thing
03:17:54 <exicer> Ghoul_: Not for maybe!
03:17:55 <mauke> @src Maybe mplus
03:17:55 <lambdabot> Nothing `mplus` ys = ys
03:17:56 <lambdabot> xs      `mplus` ys = xs
03:18:09 <mauke> oh, for Maybe it keeps the first success
03:18:26 <exicer> mauke: I can see that, but I don't have any intuition for why that is the case
03:18:36 <exicer> If I were implementing it that is not what I would have done
03:18:37 <mauke> that's because MonadPlus is ill defined
03:19:09 <mauke> @src Maybe mappend
03:19:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:41:24 <haasn> now what's the difference between Alternative and MonadPlus?
03:41:49 <Taneb> haasn, one has to be a monad, the other has to be an applicative functor
03:42:01 <Taneb> Also MonadPlus has more documented rules
03:42:40 <haasn> Taneb: oh, yes, MonadPlus has more laws
03:43:06 <Taneb> Although Alternative should really have the laws "f <*> empty == empty" and "empty <*> x == empty"
03:43:30 <haasn> in that case they'd be equivalent again?
03:43:39 <Taneb> As far as I know, yeah
03:43:49 <Taneb> Both of those can be derived from the MonadPlus laws
03:47:23 <haasn> if we assume those alternative laws and ap = (<*>) can we derive the MonadPlus laws though?
03:48:02 <haasn> maybe we need an extra law connecting ‘empty’ and join
03:48:03 <haasn> I don't know
03:49:03 <ocharles> mm_freak: Looked into --> again, and I think it is either broken, or has very confusing semantics. '1 --> 2 . when (const False)' produces 2, and doesn't inhibit
03:49:33 <ocharles> the way you've written composition means that '1 --> 2' is stepped with 'Left e' from 'when (const False)', which means that it looks like '1' inhibits, so --> switches
03:49:48 <ocharles> if that's intentionally, it's surprising behaviour :(
03:51:05 * hackagebot haskell-names 0.3 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3 (RomanCheplyaka)
03:51:51 <Taneb> haasn, well, I think "join empty = empty" feels obvious...
03:52:21 <Taneb> join empty = empty >>= id (by definition of join)
03:52:35 <Taneb> = empty (by MonadPlus laws)
03:53:06 <haasn> yes, it's clearly a law
03:53:30 <haasn> main question is whether we need it (in addition to Alternative's ‘laws’)
03:54:36 * ocharles has to run
03:59:43 <Taneb> x >>= f = join (fmap f x)
03:59:56 <Taneb> empty >>= f = join (fmap f empty) = join empty = empty
04:00:06 <Taneb> gotta run aaah
04:00:14 <Taneb> The rest is an exercise for the reader
04:03:34 <haasn> v >> empty = v *> empty = empty -- given ap = (<*>) which we assumed earlier
04:04:16 <wojtekM_> How would one approach creation of an html combinator library, that would statically ensure that only valid trees are constructed?
04:05:28 <wojtekM_> I found xhaskell, but it doesn't seem under active develpment
04:05:52 <haasn> GADTs?
04:06:31 <wojtekM_> GADTs do help, but I dont' know how to limit lists of children
04:06:53 <wojtekM_> Limit the list of children to legal tags only
04:07:53 <quchen> haasn: MonadPlus is effectively a law-only class.
04:07:53 <bergey> wojtekM_: I think HaXml can do that for XML with a DTD available.  You could look at their code.
04:08:09 <quchen> haasn: Alternative has no rules on how empty and <*> interact. MonadPlus adds these.
04:08:59 <wojtekM_> Okay, so HaXml and MonadPlus are my starting points, thanks.
04:12:04 <oddsignals> @pl f e = fmap (map e . fromMaybe [])
04:12:07 <lambdabot> f = id (fix (const (fmap . flip ((.) . map) (fromMaybe []))))
04:12:08 <lambdabot> optimization suspended, use @pl-resume to continue.
04:12:30 <oddsignals> @pl-resume
04:12:38 <lambdabot> f = id (fix (const (fmap . flip ((.) . map) (fromMaybe []))))
04:12:38 <lambdabot> optimization suspended, use @pl-resume to continue.
04:17:52 <donri> wojtekM_: you could probably do it in haskell98 with a *lot* of ADTs, but anyway, for the GADT version maybe DataKinds
04:18:51 <donri> wojtekM_: what's "xhaskell"?
04:19:39 <donri> wojtekM_: there's xhtml-combinators which enforces valid xhtml for elements, but not for attributes though
04:20:38 <wojtekM_> donri: xhaskell is an extension of haskell data types with regular expressions.
04:21:27 <wojtekM_> donri: http://www.cs.mu.oz.au/~sulzmann/manuscript/xhaskell-tr.ps
04:21:40 <donri> sounds like HaRP
04:22:28 <copumpkin> http://link.springer.com/chapter/10.1007%2F3-540-46584-7_18
04:23:29 <wojtekM_> donri: As far as I could tell, xhaskell is (or was) more like GADTs on steroids.
04:31:12 <Taneb> haasn, I was trying to start with the Alternative laws and join empty = empty and build the x >> mzero law
04:35:40 <haasn> which is doable via (>>) = (*>) and the x <*> empty = empty law
04:36:06 * hackagebot push-notify-ccs 0.1.0.0 - A server-side library for sending/receiving push notifications through CCS (Google Cloud Messaging).  http://hackage.haskell.org/package/push-notify-ccs-0.1.0.0 (MarcosPividori)
04:37:12 <Taneb> a >> b = a >>= const b = join (fmap (const b) a)
04:37:47 <Taneb> a >> b = a >>= const b = join (fmap (const b) empty) = join empty = empty
04:38:16 <haasn> or that yes
04:39:31 <Taneb> Wait, that proof is incorrect
04:39:42 <haasn> you mean other than ‘a’ should be ‘empty’?
04:39:52 <Taneb> it's a >> empty = a >>= const empty = join (fmap (const empty) a)
04:40:18 <Taneb> = join (pure (const empty) <*> a)
04:40:39 <Taneb> = join (const <$> empty <*> a) -- check this step, please?
04:40:43 <haasn> oh the first proof you gave is for empty >> b
04:40:59 <Taneb> = join ((const <$> empty) <*> a)
04:41:03 <Taneb> = join (empty <*> a)
04:41:06 * hackagebot push-notify-general 0.1.0.0 - A general library for sending/receiving push notif. through dif. services.  http://hackage.haskell.org/package/push-notify-general-0.1.0.0 (MarcosPividori)
04:41:07 <Taneb> = join empty = empty
04:41:41 <merijn> Is there a way to have cabal run 'hlint' on my code? Or even better, does cabal have a way to define an alias? (i.e. while coding I want a build command that runs hlint and doesn't bother with profiling, but normally building *should* build profiling too)
04:41:50 <haasn> pure (const empty) = const <$> pure empty
04:42:19 <dcoutts_> merijn: sadly no
04:43:02 <merijn> dcoutts_: To the yak shaving-mobile!
04:45:07 * dcoutts_ wonders if merijn intends to ride the yaks, or just ride in the yak-shaving-mobile to somewhere with lots of yaks
04:45:28 <merijn> dcoutts_: I'm already there...
04:45:47 <dcoutts_> that was quick
04:45:56 <dcoutts_> then time to get shaving!
04:45:57 <merijn> If I'm not gonna be productive today, I might as well be "not productive" in a way that makes my live suck less
04:46:33 <merijn> The question is, will I solve this properly or just hack arbitrary shell commands into cabal :p
04:46:59 <mr-> properly!
04:47:04 <dcoutts_> merijn: we'd all love if you did it properly :-)
04:47:10 <haasn> Taneb: we don't have pure empty = empty -- do we?
04:47:11 <merijn> That sounds like a lot of work :(
04:47:17 <Taneb> haasn, no
04:47:22 <haasn> then that doesn't seem right
04:47:52 <Taneb> Right, so I can't prove that a >> empty = empty from a <*> empty = empty, empty <*> a = empty, and join empty = empty
04:47:58 <Taneb> Unless I try harder
04:48:19 <merijn> dcoutts_: I'm unsure what the proper way would be, though
04:50:11 <merijn> I'm guessing a way to define an alias that runs a cabal command with different flags from normal plus a way to include arbitrary shell hooks for running stuff like hlint
04:50:35 <haasn> Taneb: don't forget we have ap = (<*>) as a law of Applicative
04:50:59 <Taneb> haasn, I'm taking ap = (<*>), pure = return as givens
04:51:07 * hackagebot phybin 0.3 - Utility for clustering phylogenetic trees in Newick format based on Robinson-Foulds distance.  http://hackage.haskell.org/package/phybin-0.3 (RyanNewton)
04:54:02 <merijn> I'm not hearing any objections, so I assume that everyone concurs that this is the most brilliant possible design :p
04:55:07 <haasn> Taneb: a >> empty  =  do { x <- a; y <- empty; return (flip const x y) }  =  do { x <- fmap (flip const) a; y <- empty; return (id x y) }  =  liftM2 id (fmap (flip const) a) empty -- by the definition of liftM2
04:55:19 <haasn> Taneb: = ap (fmap (flip const) a) empty -- by the definition of ap
04:55:33 <haasn> = fmap (flip const) a <*> empty -- by the law ap = (<*>)
04:55:40 <haasn> = empty -- by x <*> empty = empty
04:56:19 <dcoutts_> merijn: first thing I think would be to find a suitable point in Setup.hs build, probably after a component, and to gather together all the bits of information needed such as file paths, src dirs, flags etc
04:56:21 <Taneb> Nice one :)
04:56:40 <dcoutts_> merijn: I fear it may be a bit hard to do generically since different tools need different info
04:56:43 <haasn> that law is the only thing that makes it possible, afaik
04:57:15 <haasn> but that's just the verbose way of proving (>>) = (*>), which I've mentioned earlier. :)
05:00:19 <merijn> dcoutts_: Which is why I was actually thinking of something simpler, essentially there seem to be two separate things I want 1) run build/test with different flags in a simple way (i.e. quick "does this build/not burst in flames" while developing) and 2) running a command on each file while building (preferably controlled by some flag, so it plays well with the former)
05:02:03 <dcoutts_> merijn: 1 is easy, we just need a build --check flag, that skips code gen, uses -O0 etc
05:02:15 <Taneb> I'm going to get some lunch now, haasn
05:02:30 <haasn> and I'm going to get some sleep :)
05:02:33 <Taneb> I wonder if it's possible to do it with just class Applicative m => Monad m where join :: m (m a) -> m a
05:02:41 <dcoutts_> merijn: it's 2 that I was saying is harder than it looks, running a command on each file is not enough, it needs more info about the environment the package is using
05:02:50 <haasn> Taneb: as long as you have the laws governing ‘join’
05:02:58 <haasn> you can derive the usual (>>=) and its laws
05:03:05 <dcoutts_> merijn: and running per-file may not be right, it might need to be per-component
05:03:27 <dcoutts_> merijn: and then there's the issue that actually cabal build does not know all the files, it delegates that to ghc --make
05:03:31 <merijn> dcoutts_: The problem with that is, that designing that might quickly become generic to the point of being useless
05:03:42 <merijn> dcoutts_: Are there any tools that actually do things on a "per component" basis?
05:03:55 <dcoutts_> merijn: anything that needs to look at multiple modules at once
05:04:10 <merijn> Yes, but do things like that exist? :p
05:05:24 <dcoutts_> merijn: ok, I cannot immediately think of any
05:05:45 <merijn> dcoutts_: Seems overkill to engineer such a system on the off-chance that someone invents one in the misty future :)
05:06:12 <dcoutts_> module dep graph visualisation tools
05:06:16 <merijn> Especially since the end result would probably make the immediate goal of "hlint every file" trickier than the simple solution :)
05:06:23 <dcoutts_> I suspect more sophisticated tags / code browsers would need it
05:06:38 <dcoutts_> merijn: true, can just implement hlint support directly of course
05:06:47 <dcoutts_> and not try to generalise until there's a second one...
05:06:53 <merijn> Well, I'll promise to upgrade the implementation when someone implements those tools ;)
05:07:27 <dcoutts_> merijn: you'll need to use a new patch that's not been applied yet that gives us the module graph for a component
05:07:56 <dcoutts_> merijn: see https://github.com/haskell/cabal/pull/1455
05:07:58 <merijn> dcoutts_: Well, it'd be neat if I could use the same mechanism to also call things like lint on the cbits of my code
05:08:22 <dcoutts_> merijn: that's more doable since you cannot get away with not listing c files so easily
05:09:08 <dcoutts_> merijn: as I said, the problem is that people can currently often get away with not listing all modules, and we don't currently discover them ourselves
05:09:17 <dcoutts_> so you'd need that patch
05:09:27 <merijn> dcoutts_: Anyway, I think step one is the --check bit, because that annoys me the most :)
05:09:44 <dcoutts_> merijn: yes, I've thought about that one, should be easy enough
05:10:11 <dcoutts_> merijn: just watch out for TemplateHaskell, cannot use the flag to not do code gen if the component uses TH at all
05:10:28 <merijn> dcoutts_: Although I think it should extend to both build and test, so you can have a "simple" and "extended" suite to run
05:10:43 <dcoutts_> merijn: hmm?
05:10:56 <merijn> Or maybe those should just be different test suites
05:11:51 <merijn> dcoutts_: In the sense of "cabal test --check" running some minimal "smoke test" set, but maybe that should just be a different set of tests.
05:12:36 <dcoutts_> merijn: we don't have enough info to do that with the basic test suite interface, but we would with the detailed one
05:12:46 <dcoutts_> merijn: I'd leave that extension for now
05:15:32 <merijn> hmmm, I guess the best thing would be to have a "ghc-check-options" similar to "ghc-prof-options", but the difficulty there is that ghc-prof-options includes "ghc-options", but the check probably shouldn't (to avoid copying stuff like -O2 from there)
05:15:38 <merijn> So that's a bit inconsistent
05:15:43 <merijn> (or would be)
05:17:08 <yesthisisuser> I have started reading "Implementing Functional Languages: a tutorial" by Simon Peyton Jones and David R Lester. Does anyone know if the Core language used in this book is identical to the GHC Core language?
05:17:26 <yesthisisuser> the language used in the book is Miranda
05:18:21 <aleator> Can I start cabal repl in a given sandbox without first making a .cabal file?
05:18:25 <merijn> yesthisisuser: I would bet on "probably similar, but probably not identical"
05:19:14 <quicksilver> yesthisisuser: it is the ancestor of it.
05:19:33 <quicksilver> there have been changes both to core and to STG since Simon's book and paper on the subject
05:19:51 <yesthisisuser> ok. thanks. well i seems worth reading anyway
05:19:52 <quicksilver> they are still excellent reading to cover the issues involved but they're out of date w.r.t. some of the specific design choices
05:20:03 <dcoutts_> aleator: not yet, sorry
05:20:11 <yesthisisuser> sure. btw, can i compile Core using GHC?
05:20:11 <mangaba_leitosa> s/thounds/thousands/
05:20:18 <mangaba_leitosa> oops, wrong channel
05:20:21 <dcoutts_> aleator: we don't have a way yet to use repl without any component
05:20:46 <dcoutts_> merijn: btw, none of this would live in the .cabal file
05:21:20 <dcoutts_> merijn: hmm, well. tricky
05:21:21 <aleator> dcoutts_: Does this need more than passing the right -package-db flag to ghci?
05:21:32 <dcoutts_> aleator: no, that's about it
05:21:58 <aleator> dcoutts_: Well, then I can probably figure the right options for plain ghci.
05:22:24 <dcoutts_> right, just use the sandbox's package db
05:22:31 <dcoutts_> and not the user one
05:22:49 <aleator> dcoutts_: What else does cabal repl do besides that?
05:23:15 <dcoutts_> aleator: well, when you're using it with a component in a package, then it's using the right environment for that component
05:23:29 <dcoutts_> aleator: ie same environment as is used to build
05:24:06 <dcoutts_> aleator: e.g. source search path, any .o files needed, C libs, only the packages used by the component, include dirs etc
05:24:47 <aleator> dcoutts_: Ah. Indeed. What I need is just way to play with ghci with the given installed packages, so the -package-db is enough. Thanks
05:24:59 <dcoutts_> aleator: right
05:27:41 <merijn> dcoutts_: The alternative would be to have an implicitly defined "check" (or whatever) flag, and let people use that flag to specify which flags to use when compiling with the different modes
05:28:03 <merijn> dcoutts_: Added bonus would be that it allows you to selectively only build some stuff while developing
05:28:27 <dcoutts_> merijn: well, we can already build selected components
05:28:33 <merijn> dcoutts_: Downside seems to be that it could require a reconfigure and allows people to do silly things
05:29:16 <dcoutts_> merijn: I think having check just build as fast as possible, and not doing .o files or linking (unless .o files needed for TH) is good enough
05:29:37 <merijn> dcoutts_: I should disable profiling too
05:29:48 <merijn> (to avoid building twice)
05:29:50 <dcoutts_> right
05:30:40 <merijn> dcoutts_: Well, just disabling optimisations is probably not hard (I guess ghc just uses the last specified -O flags?), but you might want a different warning set while developing
05:35:30 <Taneb> haasn, what are the join laws, again?
05:36:02 <Taneb> f . join = join . fmap f?
05:36:18 <Eduard_Munteanu> Can you declare kinds (say in a class definition) with some extension? I think (k :: BOX) doesn't work.
05:36:30 <donri> Eduard_Munteanu: DataKinds?
05:36:41 <merijn> Eduard_Munteanu: KindSignatures
05:36:42 <Eduard_Munteanu> donri: hm, you mean using a lifted kind?
05:37:06 <merijn> Eduard_Munteanu: Is BOX supposed to be a polymorphic kind?
05:37:06 <Eduard_Munteanu> merijn: no, not kind signatures, I want sort signatures
05:37:24 <Eduard_Munteanu> merijn: it's the BOX sort, all kinds belong to that IIRC
05:37:27 <haasn> Taneb: join . join = join . fmap join;  join . return = id;  join . fmap return = id;  return . f = fmap f . return
05:37:32 <merijn> Eduard_Munteanu: I think KindSignatures includes sort signatures
05:37:38 <Eduard_Munteanu> Lemme try again.
05:37:47 <merijn> Eduard_Munteanu: in 7.6 the sort is AnyK, I think
05:38:04 <haasn> Taneb: also join . fmap (fmap f) = fmap f . join
05:38:09 <Eduard_Munteanu> Oh.
05:38:19 <Taneb> haasn, right
05:38:20 <haasn> but I feel like that last one can be derived from the others
05:38:26 <Eduard_Munteanu> merijn: wait, isn't AnyK a polymorphic kind instead of a sort?
05:38:35 <merijn> Eduard_Munteanu: I'm not sure :\
05:38:46 <haasn> Taneb: https://en.wikibooks.org/wiki/Haskell/Category_theory#Application_to_do-blocks
05:38:50 <haasn> gives the full derivation/proofs
05:38:53 <Eduard_Munteanu> I'm not sure how I can ask ghci for sorts.
05:39:03 <Taneb> haasn, thanks
05:39:12 <merijn> Eduard_Munteanu: What's the code you need this for?
05:40:00 <Eduard_Munteanu> merijn: I'm defining a   class GenCategory (arr :: k -> k -> hom)   and I wanted to bind the ks explicitly.
05:41:04 <Eduard_Munteanu> class Test (foo :: BOX) (t :: foo) where   doesn't work, it can't find BOX
05:41:11 <Eduard_Munteanu> It also fails with AnyK.
05:41:57 <haasn> BOX isn't a Kind so I'm not sure what sense that would make
05:42:11 <Eduard_Munteanu> I even tried Foo instead of foo thinking it can't bind variables.
05:42:20 * haasn actually reads the backlog
05:42:24 <haasn> isn't BOX the only sort in Haskell?
05:42:28 <Eduard_Munteanu> haasn: BOX is a sort, so foo would be a kind, and t a type
05:42:34 <Eduard_Munteanu> haasn: yes
05:42:45 <haasn> not sure what sort signatures would be useful, then :)
05:42:47 <Eduard_Munteanu> I just wanted to make things more explicit.
05:44:16 <Eduard_Munteanu> Hm, maybe I can make a datakind, and lift the type to a kind and use that to "mark" stuff.
05:44:30 <haasn> huh, apparently :k picks up sort signatures too
05:44:38 <haasn> @kind Constraint
05:44:39 <lambdabot>     Not in scope: type constructor or class `Constraint'
05:44:39 <lambdabot>     Perhaps you meant `Contains' (imported from Control.Lens)
05:44:51 <haasn> well :k Constraint gives me Constraint :: BOX in GHCi
05:45:18 <Eduard_Munteanu> haasn: hm, what version?
05:45:21 <haasn> 7.6.2
05:45:39 <haasn> which is a bit weird because Constraint isn't a type either way
05:45:39 <Eduard_Munteanu> Maybe I need -XConstraintKinds, lemme try again
05:45:45 <haasn> so I'm not sure why :k would even pick it up
05:45:59 <haasn> there must be something I'm missing here because it seems a bit ad-hoc to me
05:46:05 <Eduard_Munteanu> Doesn't work here...
05:46:12 <Eduard_Munteanu> GHCi, version 7.6.3
05:46:24 <Eduard_Munteanu> ghci -XConstraintKinds
05:46:41 <haasn> Works even without ConstraintKinds here; import GHC.Prim
05:46:50 * Eduard_Munteanu googles the release notes for 7.6.3
05:47:04 <Eduard_Munteanu> haasn: oh, now it works with that import
05:47:16 <haasn> yes it isn't in scope by default
05:47:35 <Eduard_Munteanu> Maybe that makes it work in my case too.
05:48:16 <haasn> data BOX  -- Defined in `GHC.Prim'
05:48:20 * haasn scratches head
05:49:21 <Eduard_Munteanu> `BOX' of kind `BOX' is not promotable   In the kind `BOX'
05:49:53 <Eduard_Munteanu> That was for   class Test (foo :: BOX) (t :: foo) where
05:49:58 <haasn> oh, I don't think you can provide the kind parameters for kind-polymorphic types either way
05:50:07 <haasn> that's just something GHCi seems to add
05:51:15 <haasn> data Proxy (a :: k) = Proxy;  :t Proxy  gives Proxy :: k a
05:51:33 <haasn> and I think in your declaration the ‘foo’s have nothing to do with eachother
05:51:35 <haasn> nor would GHC know they do
05:52:26 <haasn> sorry, Proxy :: Proxy k a
05:52:59 <Eduard_Munteanu> data Foo :: * -> * where FooType :: k -> Foo k    works with   class Test (t :: Foo k) where
05:53:02 <haasn> which can get quite confusing actually; data Proxy3 a b c = Proxy3; now Proxy3 :: Proxy3 k k1 k2 a b c
05:53:38 <Eduard_Munteanu> haasn: well, I'd use Foo for a specific kind, and make another datakind for other stuff.
05:54:14 <haasn> that Foo is just Identity
05:54:35 <haasn> nothing shiny sort-signatures-y going on
05:54:50 <Eduard_Munteanu> haasn: it gives the kind a name though
05:54:59 <haasn> Where?
05:55:03 <haasn> the only kind there is :: * -> *
05:55:13 <haasn> and :: Foo k -- but that's just a regular kind variable
05:55:43 <Eduard_Munteanu> haasn: actually I want Foo without parameters I guess
05:56:22 <Eduard_Munteanu> haasn: but in any case, Foo k can't unify with a Bar k, no?
05:56:22 <haasn> wait a minute, now I'm a bit confused; GHC claims Identity with kind * -> * is not promotable, but it happily promotes Foo :: * -> *
05:56:40 <merijn> haasn: Isn't Identity a newtype?
05:56:49 <haasn> oh, yes, it is
05:56:53 <Eduard_Munteanu> haasn: is Identity really * -> *, or k -> * ?
05:57:03 <haasn> it will happily promote data Identity x = Identity x
05:57:15 <merijn> haasn: I think it can only promote actual datatypes, not newtypes
05:57:18 <haasn> Eduard_Munteanu: * -> *
05:57:21 <haasn> merijn: confusing error message
05:57:30 <Eduard_Munteanu> Hm.
05:57:47 <haasn> Eduard_Munteanu: Proxy is :: k -> *, for an example
05:57:55 <Eduard_Munteanu> Ah.
05:58:08 <haasn> Eduard_Munteanu: Foo k can unify with Bar k if Foo or Bar are type families
05:58:30 <haasn> unless you meant on the kind level, in which case no
05:58:52 <Eduard_Munteanu> haasn: on the kind level, yes, since I'm not using Foo per se, but Foo promoted to a kind
05:58:52 <haasn> ...how long until we get KindFamilies?
05:59:28 <Eduard_Munteanu> t :: Foo k  is unambiguous since classes can't have values as parameters
05:59:54 <haasn> yes
06:01:12 <Eduard_Munteanu> My actual use is I want to define general categories, without forcing the objects universe to be Hask.
06:02:42 <Eduard_Munteanu> I'm considering   class GenCategory (ob :: Ob c) (arr :: ob -> ob -> *) or somethine like that
06:03:29 <haasn> I found another perhaps slightly confusing error message
06:03:47 <haasn> type family Bad :: Foo  -- `Foo' of kind `* -> *' is not fully applied. In the kind `Foo'
06:03:53 <haasn> Foo here should not have a kind signature
06:03:55 <haasn> I guess
06:03:58 <haasn> A sort signature? No idea
06:04:03 <haasn> is (->) a valid sort?
06:04:17 <Eduard_Munteanu> haasn: I think it doesn't promote until things are fully applied
06:04:46 <haasn> seems like it
06:05:15 <Eduard_Munteanu> And there's only BOX for sorts.
06:05:24 <merijn> dcoutts_: Should something like this --check flag be defined in Cabal or in cabal-install?
06:06:59 <haasn>     `Bar' of type `forall (k :: BOX) (f :: k -> *) (t :: k).
06:07:00 <haasn>                    f t -> Bar k f t' is not promotable
06:09:09 <mr-> merijn: is it going to be cabal install --check? That would go in cabal-install's Setup.hs
06:09:14 <haasn> Eduard_Munteanu: seems like it
06:09:29 <mr-> merijn: other stuff might go in there too, though ;-)
06:09:32 <Eduard_Munteanu> haasn: you can only promote stuff that has a kind made of * and (->) I think (before application)
06:09:54 <Eduard_Munteanu> haasn: IIRC you can promote things manually, that might make things more obvious
06:10:04 <mr-> merijn: yes, other stuff goes in there too
06:10:05 <dcoutts_> merijn: the build system lives in Cabal
06:10:58 * quicksilver switched channel to fast and thought dcoutts_ had just said "the build system lives in Canada".
06:11:20 <quicksilver> some of the weirdnesses I had experiences with cabal might have been down to moose and bears all this time.
06:11:20 <haasn> Eduard_Munteanu: it's really weird that GHC likes to print these type signatures that aren't actually valid input in any context
06:14:36 <ski> > show (Node () [])
06:14:37 <lambdabot>   "Node {rootLabel = (), subForest = []}"
06:14:41 <ski> > read "Node {rootLabel = (), subForest = []}" :: Tree ()
06:14:42 <lambdabot>   Node {rootLabel = (), subForest = []}
06:14:45 <ski> > read "Node {rootLabel = (),subForest = []}" :: Tree ()
06:14:46 <lambdabot>   Node {rootLabel = (), subForest = []}
06:14:48 <ski> > read "Node { rootLabel = () , subForest = [] }" :: Tree ()
06:14:49 <lambdabot>   Node {rootLabel = (), subForest = []}
06:14:56 <ski> > read "Node () []" :: Tree ()
06:14:57 <lambdabot>   *Exception: Prelude.read: no parse
06:15:22 <haasn> > read "Node { rootLabel = (),\nsubForest = [] }" :: Tree ()
06:15:24 <lambdabot>   Node {rootLabel = (), subForest = []}
06:16:26 <ski> a bit sad that it doesn't parse the record-less notation
06:16:35 <mm_freak> ocharles: oh, indeed
06:16:40 <mm_freak> ocharles: i'm fixing it
06:19:13 <haasn> > 0^.adding 10
06:19:14 <lambdabot>   Not in scope: `adding'
06:20:29 <merijn> mr-: No, "cabal install --check" doesn't really make sense, imo
06:21:22 <mm_freak> ocharles: fixed
06:21:46 <mr-> merijn: still, It hink those options are defined in Setup.hs
06:22:40 <merijn> mr-: Well, dcoutts just said all the build stuff lives in Cabal, so I'll start there
06:23:22 <ski> > 2 :+# 3
06:23:25 <lambdabot>   (:+#) {a0 = 2, a1 = 3}
06:31:28 <hiptobecubic> why doesn't hashmap store the number of elements in the map?
06:31:50 <hiptobecubic> the strict version
06:32:42 <dwcook> For an assignment for a class, I am looking for a job posting to which I could hypothetically apply (not yet having a Bachelor's). I've looked at http://www.haskell.org/haskellwiki/Jobs and not been able to find anything satisfactory – Are there any similar job posting sites?
06:33:10 <Eduard_Munteanu> dwcook: http://www.haskellers.com/
06:33:26 <dwcook> I looked there already.
06:33:32 <Eduard_Munteanu> Ah.
06:33:40 <argiopeweb> dwcook: Jane Street is normally accepting applications.
06:33:43 <hiptobecubic> I guess you could have an infinite map of strict keys,values actually. nevermind :)
06:34:13 <Eduard_Munteanu> dwcook: try the usual freelancing coder websites, if that job fits your description
06:34:23 <Eduard_Munteanu> That sort of job.
06:35:19 <kqr> dwcook, checked with careers 2.0?
06:35:51 <dwcook> argiopeweb, looks interesting, thanks.
06:35:57 <dwcook> Eduard_Munteanu, I actually don't know the usual ones, but I suppose that phrase would make a good search term. Thanks.
06:36:12 <argiopeweb> dwcook: Pleasure. General caveat, I'm in no way affiliated with Jane Street.
06:36:16 <Eduard_Munteanu> dwcook: I meant stuff like getafreelancer, rentacoder ...
06:36:20 <argiopeweb> s/caveat/disclaimer/
06:36:46 * argiopeweb needs more coffee
06:39:31 <dwcook> kqr, are you referring to SO?
06:42:28 <dwcook> Hmm, Jane Street looks the most promising. Thanks, everyone.
06:43:34 <latermus1> do some heavy preparation if you do decide to actually apply. i hear its pretty tough
06:43:56 <latro`a> is there a data structure for a finite "map" that is required to be total?
06:44:21 <Eduard_Munteanu> latro`a: a function :)
06:44:34 <latro`a> functions are also not total, but at any rate updating them is too lazy
06:44:52 <Eduard_Munteanu> latro`a: for that matter nothing in Haskell is really total
06:44:59 <latro`a> true
06:45:28 <latro`a> I guess I'm irrationally annoyed by the M.! everywhere
06:46:05 <ocharles> mm_freak: yay!
06:46:14 <Eduard_Munteanu> latro`a: stick a MaybeT / ErrorT into your transformer stack and let matches on M.lookup's result fail.
06:46:44 <latro`a> though, hm...if I have an actual meaning to something not being at a particular key, should the map return a Maybe, or should I just use lookup?
06:46:56 <latro`a> it doesn't matter for efficiency in this case, my map is only 6 entries long
06:47:07 <Eduard_Munteanu> latro`a: that's what lookup does, and what you're usually supposed to use, not (!)
06:47:17 <latro`a> I know what lookup does
06:47:34 <latro`a> I'm just not sure whether it's the "right thing" when I frequently expect to have nothing at some keys
06:48:00 <latro`a> as in, it's not that there's going to be something put there later, it's that there not being anything there is a static fact
06:48:06 <Eduard_Munteanu> latro`a: why not a record instead?
06:48:25 <latro`a> I'm not sure what I'd call it
06:48:55 <latro`a> there's also the problem that my "map" needs to have something like mapKeys
06:49:04 <latro`a> which is awkward with a record
06:49:23 <DMcGill> latro`a: you could put your own wrapper around lookup or (!) which screens for those values. Not sure it'd really give you anything but a little efficiency if you have a small-but-often-searched-for set of null values in a big map
06:50:32 <DMcGill> agonising over the design of a 6-entry map feels a little like premature optimisation though
06:50:47 <latro`a> I'm not trying to be fast, I'm just trying to be semantically correct
06:51:01 <latro`a> right now my map returns Maybe and I use !
06:51:32 <DMcGill> if you use a record, wouldn't deriving Functor let you map over the contents?
06:52:54 <Eduard_Munteanu> latro`a: since you mentioned Map, I expect all fields have the same type.
06:53:03 <latro`a> that's correct
06:53:43 <DMcGill> if you know the number of entries in your map ahead of time and you know that number won't change then a record seems like a much better idea than a map
06:53:47 <DMcGill> you have an invariant, use it
06:53:53 <latro`a> valid point
06:54:09 <latro`a> I assume you mean a record of a new type
06:54:55 <DMcGill> and deriving a few typeclasses/lenses on said record will provide you with functions on it
06:56:11 <DMcGill> huh, I'm not sure how I'd design it - I meant more like Data SixMap k a = SM {first :: (k, a); ...; sixth :: (k, a)} deriving Functor
06:56:12 <DMcGill> but that will only work if you can prove that all the 'k's are distinct
06:56:58 <latro`a> uh...why do you need the k there at all?
06:57:19 <DMcGill> if the keys are static then you don't
06:57:24 <latro`a> they are
06:57:25 <ocharles> mm_freak: yep, works perfectly. now mario can run again
06:57:36 <exFalso> Hi, is there a package that defines a TH Lift instance for Data.Text?
06:57:43 <latro`a> data AtEdges a = { west :: a, ..., southwest :: a}
06:58:14 <DMcGill> you could use a newtype on (,,,,,) I suppose too, you can't define your own strictness on it though
06:58:29 <DMcGill> I'd rather use 'data' imo
06:58:47 <ericmoritz> p
06:59:24 <DMcGill> also I couldn't recommend lens more for using with big/unwieldy/nested data structures like this
06:59:32 <Eduard_Munteanu> latro`a: so you want to permute west etc. ?
06:59:38 <latro`a> yeah
07:00:18 <latro`a> one of the main operations in the game is placing tiles. they have an orientation in advance, but the orientation is changed depending on how they were placed on the board
07:00:52 <latro`a> essentially there's a mark on the tile that shows where it attaches to the tile you were coming from
07:01:08 <DMcGill> is there a way of doing that that isn't "rotLeft t = Tile {west = southwest t, ...}"?
07:01:14 <deas> Hello, how is it possible that Just (Just 5) >>= id  works? Function id doesnt really seem to match the type...
07:01:19 <DMcGill> storing the rotation in the Tile seems like a nice cheat
07:02:17 <latro`a> wait, what?
07:02:38 <Eduard_Munteanu> deas: that's join :: m (m a) -> m a, for m = Just
07:03:38 <Eduard_Munteanu> deas: join = x >>= id, so start with (>>=) :: m a -> (a -> m b) -> m b
07:03:59 <latro`a> m (m a) -> (m a -> m a) -> m a
07:04:10 <latro`a> is what you get from specialization
07:04:10 <DMcGill> data Tile a = Tile {rot :: Int; west :: a; ...}; rotLeft = rot %~ mod 6 . pred; rot %~ mod 6 . succ;
07:04:34 <Eduard_Munteanu> deas: if you give it  id  in the second argument, you must unify   (c -> c)  with   (a -> m b)
07:04:34 <deas> but id is not type (a -> mb)
07:04:46 <DMcGill> hmm, I'm just spitballing here
07:04:57 <Eduard_Munteanu> deas: but it can be... in case a = m b
07:05:06 <DMcGill> it seems a good way to avoid having to do multiple updates to rotate a tile
07:05:20 <deas> ahaa... I see now
07:05:26 <deas> thanks
07:05:48 <latro`a> it seems more intuitive to just pick a particular orientation that every tile has in the pile
07:05:51 <latro`a> and then update that
07:06:05 <DMcGill> you push the cost of rotating to when you actually access a field, that way rotLeft . rotLeft . rotLeft only does the work once rather than 3 times
07:06:08 <latro`a> in my case I picked East (pretty much arbitrarily)
07:06:15 * hackagebot sign 0.2.0 - Arithmetic over signs and sets of signs  http://hackage.haskell.org/package/sign-0.2.0 (MasahiroSakai)
07:06:33 <latro`a> a tile will require a couple updates to be rotated
07:06:47 <latro`a> you have to rotate the keys and then the values also have some updates built into them
07:06:55 <latro`a> at least with the way I have it set now
07:07:27 <latro`a> for example, many of the edges have beaches, and different beaches have ports in different directions
07:07:34 <DMcGill> if you simply store the "difference updates", you can reduce the cost of multiple rotations to the cost of a single one
07:07:38 <Eduard_Munteanu> latro`a: why not define rotation as an enumeration?
07:07:47 <latro`a> it is now
07:08:07 <latro`a> data HexDirection = West | Northwest | Northeast | East | Southeast | Southwest
07:08:07 <latro`a>                        deriving (Show,Eq,Enum)
07:08:20 <latro`a> rotate travel dir = toEnum $ on (+) fromEnum travel dir `mod` 6
07:08:41 <Eduard_Munteanu> latro`a: no, I mean NoRotation | Rot90 | Rot 180 | Rot 270
07:08:54 <latro`a> it essentially is that already
07:09:09 <latro`a> I identify direction in space with rotation
07:09:15 <latro`a> via that function up there
07:09:28 <Eduard_Munteanu> latro`a: yeah, but you can make it relative to a coord system.
07:09:40 <latro`a> huh?
07:09:44 <latro`a> these are hexagonal tiles
07:09:53 <latro`a> a square coordinate system is awkward
07:10:41 <DMcGill> latro`a: how are you storing your hex coords?
07:10:48 <DMcGill> I did this a few years ago: https://github.com/Swooshed/Fight-puck/blob/master/Game.hs
07:10:54 <DMcGill> before I knew about lens :'(
07:10:56 <latro`a> (Int,Int), the same convention as Math.Geometry.Grid
07:11:12 <DMcGill> probably better than my homegrown method
07:11:27 <Eduard_Munteanu> latro`a: I only suggested tracking rotations with respect to something, instead of global rotations.
07:11:49 <latro`a> I don't follow
07:12:21 <latro`a> right now I'm doing rotations by calling "rotate travel", where travel is the direction that the boats approaching the new tile are going
07:14:01 <mm_freak> ocharles: haha, great
07:14:38 <ocharles> mm_freak: did you get my messages about infinite timelines?
07:14:56 <latro`a> Eduard_Munteanu, that makes them "relative" to the direction of travel; the only "globalness" is that there's a default orientation to tiles before they get rotated
07:15:22 <Eduard_Munteanu> Ah, I thought west and such were global coords.
07:16:11 <mm_freak> ocharles: oh, yes
07:16:16 * hackagebot drClickOn 0.1 - Monadic FRP  http://hackage.haskell.org/package/drClickOn-0.1 (AtzeVanDerPloeg)
07:16:20 <mm_freak> ocharles: Timeline isn't really meant for animation
07:16:42 <mm_freak> ocharles: it's used internally by .Analyze for interpolation
07:16:59 <mm_freak> ocharles: so the name "timeline" may be unfortunate =)
07:19:50 <latro`a> I do agree with you, Eduard_Munteanu and DMcGill, that "you have an invariant, use it" seems appropriate
07:20:52 <latro`a> though it is rather tedious to write the rotation function with a record :/
07:21:34 <DMcGill> don't get me wrong, sometimes invariants are super super tedious to encode: http://stackoverflow.com/questions/18594882/representing-map-constraints-as-a-adt/18597022#18597022
07:22:26 <argiopeweb> latro`a: On hex grids, have you seen http://www.redblobgames.com/grids/hexagons/?
07:22:34 <DMcGill> writing a bunch of manual rotLeft = t{west = nwest t} is why I suggested having a 'rotated' field to alleviate that
07:23:10 <DMcGill> thanks argiopeweb, that looks super interesting
07:23:14 <latro`a> I still don't get what you meant by that
07:23:28 <latro`a> argiopeweb, interesting
07:23:47 <DMcGill> give me a sec to cobble a proper example together on lpaste then
07:23:58 <argiopeweb> DMcGill: My pleaure. I tend to futz with hex grids on occasion, and that's one of the best resources I've found.
07:24:18 * kuribas has setup ECB for haskell project management under emacs.  It works pretty well!
07:24:41 <argiopeweb> kuribas: ECB?
07:24:47 <kuribas> emacs code browser
07:25:06 <kuribas> It's a package under ubuntu.
07:25:15 <Lethalman> oh, haskell automatically enforces file locking?
07:25:40 <Lethalman> now I'm wondering, is there any application use case you don't want file locking?
07:26:08 <Lethalman> +where
07:26:15 <argiopeweb> kuribas: What benefit does ECB provide over, say, the speedbar?
07:26:28 <geekosaur> Lethalman, for databases you often want record locking instead of whole file
07:26:29 <ocharles> mm_freak: ok, so that was just wrong tool for the job
07:26:38 <kuribas> argiopeweb: I used the speedbar, but I found it annoying that it's not inside the frame.
07:26:54 <Lethalman> geekosaur, right, and how can you open a file without lock? is there some haskell library without locking?
07:27:17 <kuribas> argiopeweb: And the ecb directory browser keeps it content when browsing other files.
07:27:40 <kuribas> argiopeweb: If you use ecb-layout-name left15 it will show the files in the directory buffer.
07:28:01 <geekosaur> I don'tthink there's a standard one (the Report specifies, somewhat stupidly, that all files *must* be locked; this is mostly intended as a hackaround for lazy I/O, as I understand it)
07:28:28 <geekosaur> I believe there's some intent for GHC specific unlocked opens but don't know what state it's in
07:28:56 <Lethalman> ok thanks
07:29:57 <argiopeweb> kuribas: Neat. I'll look into it.
07:30:02 <kuribas> argiopeweb: You have to customize a few variables to set it up nicely.
07:30:44 <argiopeweb> Though the extra window thing with the speedbar never bothered me since I use XMonad.
07:31:19 <kuribas> Yes.  But ECB has other niceties.
07:31:41 <latro`a> DMcGill, I think I may have just come up with a clever trick, namely mapping directions (in an Enum type) to the field functions
07:32:15 <kuribas> argiopeweb: What bugged me about the speedbar is that it changes content all the time.
07:32:31 <latro`a> as in, f West = west; f East = east; etc.
07:33:02 <argiopeweb> kuribas: That is moderately annoying.
07:34:05 <kuribas> argiopeweb: It looks better :)
07:34:28 <DMcGill> latro`a: that's what I was talking about :) see http://lpaste.net/93196
07:35:19 <latro`a> uhh
07:35:30 <exFalso> If i have a TH splice like this: [|f (g a))|] will this result in an Exp that contains two applications or will (g a) be evaluated at compile time? will let b = g a in [| f b |] make sure that it is?
07:35:32 <latro`a> oh, now I see, the rot steps you through the cycle list
07:35:48 <DMcGill> oops, in line 19 getDir should have a param t
07:36:21 * hackagebot BiobaseInfernal 0.7.1.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.7.1.0 (ChristianHoener)
07:36:23 * hackagebot haskhol-core 1.0.0 - The core logical system of HaskHOL, an EDSL for HOL theorem  proving.  http://hackage.haskell.org/package/haskhol-core-1.0.0 (EvanAustin)
07:36:25 * hackagebot pipes-bytestring 1.0.1 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-1.0.1 (GabrielGonzalez)
07:36:31 <latro`a> I'm still not sure this is much better than   rotate travel dir = toEnum $ on (+) fromEnum travel dir `mod` 6
07:37:45 <latro`a> that combined with lookups on directions seems to be at least maximally succinct
07:37:51 <latro`a> even if it's not maximally expressive
07:38:34 <DMcGill> latro`a: if you then combine your rotate with `f East = east; ...', then its pretty similar except that in mine the Direction is a field of the Tile
07:38:42 <DMcGill> which is a trivial difference really
07:38:55 <DMcGill> so uh, I guess we agree that it's a good solution!
07:43:04 <dagano> can someone show me how to recursively build up a set using insert ... without using fromList
07:43:35 <dagano> :t Set.insert
07:43:36 <lambdabot> Couldn't find qualified module.
07:43:40 <dagano> :t S.insert
07:43:41 <lambdabot> Ord a => a -> S.Set a -> S.Set a
07:43:58 <saraza0001> Hi!
07:44:10 <mauke> preflex: ? .ar
07:44:11 <preflex>  Argentina
07:44:23 <DMcGill> @source fromList
07:44:23 <lambdabot> Unknown command, try @list
07:44:23 <saraza0001> I was wondering.. What does deriving (Ord) do in a recursive data type?
07:44:25 <Rarrikins> Land of pirates
07:44:28 <DMcGill> @source Data.Set.fromList
07:44:32 <lambdabot> Unknown command, try @list
07:44:34 <mauke> saraza0001: the obvious thing :-)
07:44:50 <mauke> DMcGill: @src is not @source
07:44:57 <DMcGill> @src Data.Set.fromList
07:44:57 <lambdabot> Source not found. My mind is going. I can feel it.
07:45:05 <Rarrikins> saraza0001: It goes based on the order you define the constructors.
07:45:16 <saraza0001> mauke: it doesn't seem so obvious to me :(
07:45:37 <dagano> @src S.fromList
07:45:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:45:50 <DMcGill> "Data.Set.fromList xs = foldl insert empty xs" anyway
07:45:57 <dagano> ok thnks
07:45:57 <saraza0001> Rarrikins: but for example, in a list it would work as expected (first with first, second with second.. etc) but in something like a tree?
07:46:08 <dagano> aaaah empty is the neutral for a fold
07:46:17 <mauke> data Tree a = Empty | Leaf a (Tree a) (Tree a)
07:46:32 <ski> @type foldr S.insert S.empty
07:46:33 <lambdabot> Ord a => [a] -> S.Set a
07:46:43 <ski> @type foldl (flip S.insert) S.empty
07:46:45 <lambdabot> Ord b => [b] -> S.Set b
07:46:46 <Rarrikins> saraza0001: It first compares the outermost constructor, then, if they're both the same, it recurses from left to right over the constructor's arguments.
07:46:56 <saraza0001> Oh thanks :)
07:47:03 <saraza0001> Rarrikins: thank you
07:47:04 <Rarrikins> saraza0001: No problem
07:47:08 <mauke> wtf
07:47:08 <ski> possibly the latter is better here
07:47:10 <mauke> s/Leaf/Node/
07:47:21 <dagano> performance wise?
07:47:24 <DMcGill> ski: that's what I get for needing to look up the types of foldl and foldr every time I use them!
07:47:50 <mauke> instance (Ord a) => Ord (Tree a) where { compare Empty Empty = EQ; compare Empty _ = LT; compare _ Empty = GT; compare (Node x tx1 tx2) (Node y ty2 ty2) = compare x y <> compare tx1 ty1 <> compare tx2 ty2 }
07:48:01 <ski> DMcGill : it's simple to recall. the type for `foldr' is the naturally expected one. the one for `foldl' is the other way around
07:48:12 <mauke> the "obvious" part is that it calls compare recursively on all fields
07:48:26 <Rarrikins> @type foldr
07:48:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:48:31 <DMcGill> so foldr is the 'right' fold
07:48:34 <DMcGill> that makes sense
07:48:42 <dagano> > foldr S.insert S.empty [1,2,3]
07:48:43 <lambdabot>   fromList [1,2,3]
07:49:24 <dagano> > foldr S.insert S.empty [1,2,3] !! 2
07:49:26 <lambdabot>   Couldn't match type `Data.Set.Base.Set a1' with `[a0]'
07:49:26 <lambdabot>  Expected type: a1 -...
07:49:32 <dagano> yeah that wouldn't work would it
07:49:39 <DMcGill> foldl being the 'wrong' fold
07:50:03 <ski> it's the right fold for `data SnocList a = Nil | Snoc (SnocList a) a'
07:50:20 <DMcGill> I meant more for the order of the args to the function like you said
07:51:15 <DMcGill> obviously in terms of actual usage patterns there are reasons to use either - foldr is less strict and can result in productive infinite recursion for example, whereas foldl is more strict and foldl' is a godsend
07:53:04 <ski> DMcGill : `foldl' is like if you do a `reverse :: [a] -> SnocList a; reverse [] = Nil; reverse (a : as) = Snoc (reverse as) a', then composing with the natural fold on `SnocList'
07:54:07 <ski> hm, actually, that's not right
07:54:30 <DMcGill> > foldl (flip const) [a,b,c]
07:54:34 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
07:54:34 <lambdabot>                     Debug....
07:54:55 <DMcGill> > foldr1 const [1,2,3]
07:54:56 <lambdabot>   1
07:55:06 <ski> `reverse' here is conceived as taking a sequence of elements, represented as a cons-list, reversing the sequence, and return the result represented as a snoc-list
07:55:09 <DMcGill> > foldl1 (flip const) [1,2,3]
07:55:11 <lambdabot>   3
07:55:50 <ski> what i should have in the above composition instead of this `reverse' is instead a variant of `id', that takes a sequence represented as a cons-list, and returns the same sequence, represented as a snoc-list
07:56:22 <ski> (so in terms of term nesting, the former `reverse' doesn't reverse the nesting, while this `id' does reverse the nesting. that's why i confused them)
07:57:13 <kuribas> > foldr1 const [1, 2, 3, undefined]
07:57:14 <lambdabot>   1
07:57:33 <kuribas> > foldr1 const [1..]
07:57:35 <lambdabot>   1
07:57:41 <ski> if one wants a type for folding over an associative list, one could try `(r -> r -> r) -> (a -> r) -> r -> ([a] -> r)'
07:58:20 <DMcGill> > take 5 $ foldr (+) 0 [1..]
07:58:22 <lambdabot>   No instance for (GHC.Show.Show a0)
07:58:22 <lambdabot>    arising from a use of `M157682574.sho...
07:58:25 <kuribas> foldr is always strict on the list, right?
07:58:47 <kuribas> foldl I mean.
07:58:58 <DMcGill> foldl can't be used infinite lists iirc, yeah
07:59:37 <DMcGill> > take 5 $ foldr (:) [] [1..]
07:59:38 <lambdabot>   [1,2,3,4,5]
08:00:07 <kuribas> foldl will always evaluate the whole spine of the list, while foldr may evaluate the list lazily.
08:00:19 <ski> > foldr (const . const ()) () []
08:00:20 <lambdabot>   ()
08:00:22 <ski> > foldr (const . const ()) () (undefined : undefined)
08:00:23 <lambdabot>   ()
08:01:02 <ski> kuribas : yes
08:01:33 <ski> (that's because `foldl' is tail-recursive, and has consumed the whole list when reaching the base case)
08:02:37 <kuribas> > error "Prelude.undefined"
08:02:40 <lambdabot>   *Exception: Prelude.undefined
08:04:08 <DMcGill> clear exploit vector
08:04:20 <DMcGill> error "GHC says send me your bank details"
08:04:47 <Fuuzetsu> and people say Haskell is safe…
08:05:18 <geekosaur> error is rarely what they mean by "safe" :p
08:08:40 * ski . o O ( `{-# LANGUAGE Trustworthy #-}' -- would you trust anyone who expressly and forcefully testifies they are trustworthy ? )
08:09:04 <quicksilver> is that one of those puzzles with the knight that always lies in it?
08:09:06 <Adeon> would these emoticon eyes lie to you
08:09:08 <nalkri> About as much as I trust a country with ‘people's’ in the name
08:09:09 <Adeon> ;_;
08:09:16 <dagano> with libraries .. what, generally, is the diff between Data.UnionFind.ST and Data.UnionFind.IO
08:09:20 <dagano> ?
08:09:50 <DMcGill> @user DMcGill {trustworthy=True}
08:09:51 <lambdabot> Unknown command, try @list
08:10:06 <quicksilver> dagano: one works in the ST monad and one in the IO monad?
08:10:26 <dagano> ok i don't know what the ST monad is...so I should avoid that one?
08:10:31 <mauke> > runST
08:10:33 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
08:10:33 <lambdabot>                     (foral...
08:10:33 <dagano> ST monad = statemonad?
08:10:36 <mauke> sweet
08:10:53 <mauke> dagano: ST provides mutable variables on the inside with a pure interface to the outside
08:11:13 <latermus1> carter: hey, talked with art. went well. will email you in approx 12 hours about details.
08:11:17 <DMcGill> you can escape the ST monad when you're done being mutable
08:11:19 <mauke> > runST (do v <- newSTRef 0; writeSTRef v 42; readSTRef v)
08:11:21 <lambdabot>   42
08:11:26 <mauke> ok, stupid example
08:11:31 <DMcGill> you can't* escape the IO monad
08:12:01 <ski> dagano : "ST" is short for "State Thread"
08:12:10 <DMcGill> for example there's a nice paper on dfs in haskell - the interface is pure even though a few of the functions use mutable updates behind the scenes
08:12:26 <quicksilver> dagano: it means both modules are implemented using mutation internally, but the 'ST" version lets you use it from pure code
08:12:41 <quicksilver> the actual implementations will be the same, in most cases.
08:12:58 <dagano> ok thanks..more to read
08:13:17 <mauke> why even provide the IO version? you can trivially turn ST into IO
08:13:21 <DMcGill> use IO if you need to use IO, use ST if you don't and just want the mutation
08:13:24 <ski> @google lazy functional state threads
08:13:28 <lambdabot> http://research.microsoft.com/~simonpj/papers/lazy-functional-state-threads.ps.Z
08:13:30 <ski> dagano : read that paper ^
08:14:24 <ski> mauke : well, perhaps they have combinators like `frob :: IO Blah -> IO Bleh' in there
08:14:37 <quicksilver> mauke: if you want to interleave your own actions between bits that use the thread
08:14:48 <quicksilver> mauke: then you need to have different ST types
08:14:55 <ski> what quicksilver said
08:15:04 <quicksilver> if they're all packaged up completely then they don't need to be IO or ST at all, they can just be pure :)
08:15:09 <Taneb> Can someone explain to me why the many law is that way round?
08:15:10 <Taneb> many v = some v <|> pure []
08:15:27 <Fuuzetsu> Taneb: as opposed to?
08:15:31 <Taneb> If it was "many v = pure [] <|> some v", some and many would be well-defined for []
08:15:47 <Fuuzetsu> Taneb: because that will always just give you pure []
08:15:53 <Fuuzetsu> and you would never get any results
08:15:56 <mauke> quicksilver: I don't get it
08:15:58 <ski> Taneb : i think `(<|>)' usually will try the left alternative first
08:16:00 <Taneb> Fuuzetsu, makes sense
08:16:01 <Fuuzetsu> (that aren't [])
08:16:07 <Taneb> Yeah, didn't think of that
08:16:08 <Taneb> :)
08:16:23 <ski> quicksilver : elaborate on "if they're all packaged up .." ?
08:17:00 <ski> Taneb : btw, what did you mean by "would be well-defined for []" ?
08:17:01 <quicksilver> ski: if the only things exported where complete actions with no threads in the return types - the kind you can just run runST on - then they might as well have just run runST on them for you.
08:17:21 <quicksilver> s/return/return or argument/
08:17:28 <Taneb> ski, there is a definition for the [] alternative that matches those types and those rules
08:17:46 <mauke> :t runST
08:17:47 <lambdabot> (forall s. ST s a) -> a
08:17:49 <Taneb> I think
08:17:53 <mauke> quicksilver: I don't get it
08:18:00 <ski> quicksilver : hm. possibly not if there's combinators taking actions as inputs
08:18:15 <quicksilver> ski: yes, hence my regexp sub.
08:18:23 <dagano> > [a | \(a,_) -> [(1,2),(3,4)]]
08:18:25 <lambdabot>   Couldn't match expected type `(t0, t1) -> [(t2, t3)]'
08:18:25 <lambdabot>              with act...
08:18:34 <Taneb> No, nevermind
08:18:35 <dagano> massive confusion
08:18:36 <Taneb> I'm double wrong
08:18:51 <ski> quicksilver : consider `newReadWriteSTCell :: a -> ST s (ST s a,a -> ST s ())'
08:18:57 <ski> hm
08:19:14 <quicksilver> mauke: Data.UnionFind.ST has lots of actions which return values which actually have state thread parameters
08:19:18 <ski> no that has `s' in the monadic result, so no good
08:19:41 <mauke> quicksilver: is that the s?
08:19:42 <quicksilver> mauke: you can't use those in IO.
08:19:44 <quicksilver> yes.
08:19:44 <ski> quicksilver : your "regexp sub" ?
08:19:46 <mauke> quicksilver: why not?
08:19:52 <dagano> > map (\(a,_) -> a) [(1,2),(3,4)]
08:19:53 <lambdabot>   [1,3]
08:19:56 <quicksilver> ski: 16:16 < quicksilver> s/return/return or argument/
08:20:11 <quicksilver> mauke: because runST won't let you.
08:20:18 <mauke> why not?
08:20:25 <ski> oh, didn't notice that
08:20:33 <quicksilver> because it will complain that the type variable escaped.
08:20:49 <quicksilver> it's a compile error in rank-N haskell
08:20:51 <latro`a> hmm....if you're still free, DMcGill, I just realized that I might want to have two different kinds of storage, one that can (and should) fail, and one that can't fail
08:20:55 <ski> mauke : `ioToST :: ST RealWorld a -> IO a' ?
08:21:09 <mauke> ski: what about it?
08:21:10 <DMcGill> latro`a: feel free to link a lpaste
08:21:52 <DMcGill> but updating two different representations of the same data is annoying and error prone
08:22:00 <latro`a> not what I meant
08:22:03 <ski> sorry, `stToIO'
08:22:10 <latro`a> I meant that I have two kinds of Maps right now
08:22:22 <latro`a> one I know will never fail
08:22:33 <latro`a> the other is designed to frequently fail
08:22:39 <ski> mauke : it will instantiate the `s' in the state thread to `RealWorld', so that you can't use `runST' on it
08:22:54 <latro`a> the latter can be made into the former by making the output into Maybe, if I want
08:23:09 <latro`a> but I'm still not sure which way makes more sense
08:23:12 <mauke> ski: why would I use runST on IO a?
08:23:37 <DMcGill> latro`a: could you link some code please? I'm not really sure what you mean - how can a Map 'fail' without returning Nothing or crashing?
08:23:50 <latro`a> returning Nothing is what I meant
08:24:17 <ski> hm, i think i'm probably getting confused. and i'm not quite sure what the contested statement is atm
08:24:46 <latro`a> for example, my sea tiles have a map from direction to direction that tells you where to go after you land on them (basically representing the way the current takes you)
08:24:50 <latro`a> this is total
08:24:58 <Sculptor> yo
08:25:11 <latro`a> the grid itself has a map from indices to tiles, which is not in the slightest bit total
08:25:24 <ski> retake : if you use `stToIO', then you couldn't pass the result of that, composed with some other `IO'-actions, to a combinator of shape `ST s Foo -> ST s Bar' in the library
08:25:36 <ski> i'm not sure if that was quicksilver's point here, though
08:26:40 <DMcGill> latro`a: there is no reason for them to be modelled by the same data structure then - the former can be written as a field 'Dir -> Dir' or something while the latter makes sense as an actual Data.Map.Map
08:28:34 <latro`a> that's what I was thinking
08:31:35 <chrisdone> @quote xeyes
08:31:36 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
08:32:32 <latro`a> .....oh god
08:32:40 <Fuuzetsu> it's beautiful
08:32:50 <Fuuzetsu> I just need to install xeyes
08:33:10 <tdammers> xeyes should be a mandatory part of any base install
08:33:35 <Fuuzetsu> I'm sure you could file a ticket on Gentoo bugzilla
08:34:05 <tdammers> pro tip: xeyes looks funny on a tiling window manager with two side-by-side windows
08:35:26 <DigitalKiwi> One time my heater broke, so I installed gentoo on my desktop...to this day I still don't have a heater! ;)
08:35:58 <chrisdone> when i'm cold i build ghc
08:36:06 <DigitalKiwi> and mine bitcoins
08:36:20 <Fuuzetsu> he said cold and not in need of a house fire
08:36:40 <DigitalKiwi> http://xkcd.com/1172/
08:36:58 <chrisdone> SUSHI TIME
08:37:09 <DigitalKiwi> YOUR UPDATE MURDERS CHILDREN
08:41:23 * hackagebot hyphenation 0.4 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.4 (EdwardKmett)
08:42:15 <t7> http://xkcd.com/1264/
08:46:24 * hackagebot hpaco-lib 0.24.0.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.24.0.0 (TobiasDammers)
08:55:20 <edvo> I'm trying to parse RSS feeds using HXT and Arrow notation, but it does not work (it gives an empty result). Can anyone tell me, what the error is? http://lpaste.net/93200
08:55:52 <edvo> It does work as expected btw, when I comment out the "descr <- " line and use some dummy value instead
08:57:03 <magneticduck> hey I'm having some trouble installing a package from hackage that uses a c library
08:57:08 <magneticduck> it's called hsndfile
08:57:38 <magneticduck> and I installed everything there is in the ubuntu repositories under that name but it seems like it doesn't want to install
08:57:42 <magneticduck> anybody have any experience with it?
08:58:01 <ski> edvo : what if you comment out instead `title <- ...', and use a dummy value for that ?
08:58:28 <tapuu> magneticduck: post the error
08:59:16 <monochrom> edvo: the same item cannot be both a "title" element and a "description" element, no?
08:59:19 <magneticduck> actually never mind, I just had to download the actual library from its site
08:59:25 <edvo> ski: it also works
08:59:32 <edvo> monochrom: ah
08:59:40 <edvo> monochrom: makes sense
09:00:20 <magneticduck> man there are a lot of things on hackage that simply do. not. install.
09:00:52 <tapuu> I've never managed to install anything that involves wx or yesod
09:01:13 <edvo> monochrom: thank you very much, I moved getChildren to both title and descr and now it works
09:01:24 <monochrom> I think you should move "getChildren ." to lines 4 and 5. yes do it twice.
09:01:25 <monochrom> yeah
09:06:24 * hackagebot haskintex 0.2.0.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.2.0.0 (DanielDiaz)
09:06:43 <magneticduck> rofl I've been having so much trouble getting a simple offline synthesizer to work in haskell
09:06:54 <magneticduck> either it doesn't install or it's waaaay over my head and it doesn't install
09:07:09 <magneticduck> I'm going to write something from scratch with hsndfile; at least this seems to be working
09:11:55 <magneticduck> wooo it's working
09:15:11 <ocharles> mm_freak: i seem to have got stuck again considering events of infinitely small time :( I wanted to make mario jump, so i have an acceleration wire which is '-9.8 + (100 . hold . keyDown SDL.Space <|> 0)' which means that when I hit space i constantly apply acceleration
09:15:37 <ocharles> mm_freak: it feels like I want to apply it for an instant... but a change in acceleration for an inifinely small amount of time doesn't sound right
09:15:52 <ocharles> maybe I should apply acceleration for a small amount of time instead...
09:16:22 <mm_freak> ocharles: you can add an instant push to the velocity
09:16:31 <mm_freak> gravity acceleration will then take care of the rest
09:16:49 <mm_freak> ocharles: instant jumps in value are not wrong
09:17:12 <ocharles> ok, but then i'd have to observe an Event for an instant, and I didn't think that was right
09:17:20 <mm_freak> this graph is fine:  ______--------
09:17:26 <ocharles> right
09:17:28 <mm_freak> but this graph is not:  ______|______
09:18:12 <mm_freak> ocharles: it's a good idea to think of time as a topological space
09:19:02 <ocharles> mm_freak: now i have two problems :)
09:19:19 <mm_freak> hehe
09:19:21 <ocharles> (I sadly don't know anything about topology, so i can't make those associations yet)
09:19:31 <notdan> is it any better to have one IORef holding a pair or two IORefs?
09:19:46 <ocharles> mm_freak: but I don't see how I can say 'holdForSteps 1 . keyDown SDL.Space', without breaking semantics
09:19:47 <notdan> s/or/rather than/
09:19:54 <ocharles> because afaik that is the kind of thing you don't want people doing
09:19:57 <ocharles> that's akin to 'occured'
09:20:27 <mm_freak> ocharles: just don't have one-instant spikes
09:20:39 <mm_freak> instantanous jumps are fine, but spikes are not
09:20:59 <mm_freak> so the easy way to "jump" is to shift the velocity
09:21:00 <ocharles> ok, i'll chew one that
09:21:06 <mm_freak> not to spike the acceleration
09:21:10 <ocharles> sure, but I can't see how to generate the signal to do the shift
09:21:35 <mm_freak> the integral wires don't support that right now
09:21:43 <mm_freak> you'll have to implement your own integral for that
09:21:55 <mm_freak> i'll add event handling to integrals soon
09:22:01 <ocharles> that would still require 'vel <- (100 . forInstant 1 . keyDown SDL.Space) + integral 0 . (-9.8)' or something
09:22:08 <ocharles> oh, ok.
09:22:54 <mm_freak> the resulting code would look about like this:  v <- integralEv (\_ -> (+ 10)) -< (a, jumpEv)
09:23:24 <ocharles> right. so when an event occurs, I apply a transformation
09:24:32 <ocharles> i'll try hacking that up now. i guess it's a little hard to see the boundaries between the semantics I want to preserve, and when I somewhat break the semantics internally in a wire
09:24:58 <ocharles> cause I mean the velocity signal still differentiates to something with an infinite spike
09:31:24 * hackagebot kure 2.14.0 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.14.0 (NeilSculthorpe)
09:33:24 <ski> edvo : hm, ok
09:34:17 <ski> notdan : often a single `IORef' holding a structure is nicer than a structure containing lots of `IORef' holding individual parts
09:35:55 <ski> notdan : in the former case, if you have a function that computes a new structure from an old one, you can then atomically replace the old structure in the `IORef' with the new one, lazily evaluated. only when someone accesses the new structure will it be computed (or perhaps you prefer to compute it directly after the atomic swap)
09:36:38 <ski> notdan : otoh, with lots of "small" `IORef's, other concurrent agents can see intermediate stages, when you haven't replaced all of them yes
09:36:44 <ski> (which is often not so good)
09:36:46 * geekosaur o.O wonder if -beginners can reject messages based on comic sans...
09:38:56 <notdan> ski: fair nough, thanks :)
09:38:58 <elliott> geekosaur: what do you have against spj?
09:39:32 <ski> i think one could probably use `TVar' for the "small pieces" case, and wrap the update around all the `TVar's in an `atomically' -- to get something similar to the single `IORef', but still with the possible convenience of having several `TVar's for parts
09:40:01 <ski> also, it might be that you want to allow incremental update like above, so you need something like the "small `IORef'" case -- then using something like `MVar' can be better (depending on what you want)
09:41:34 <ski> notdan : e.g. you could have a pool of concurrent agents which remove the values of some substructures in `MVar's and work awhile before they insert the new values -- and other agents will simply block if they attempt to read those substructures, until the other agent fills in the new value
09:41:56 <geekosaur> elliott: I imagine I have been all but unable to read his messages....
09:42:12 <ski> s/until the other agent/until one of the former agents/
09:45:15 <joeyh> is there any way to make ghc warn whenever a particular instance of a type class is used?
09:45:54 <joeyh> I'm asking because I have an instance of Ord that I want to reorder, so I want to see everywhere it's used
09:47:36 <narens> question: I installed gsl-devel using macports and I am trying to do "cabal install hmatrix" but it still says it can't link to the GSL library. Any idea why? (Obvisouly, i had no trouble on linux).
09:48:53 <geekosaur> I hope you did not install gsl-devel ebcause yout hought you needed it for development headers/libs
09:49:35 <narens> geekosaur: I tried it with the normal gsl package in macports as well. Didn't work.
09:50:07 <geekosaur> actually with cabal you just need to point it at /opt/local to find headers/libs
09:50:37 <narens> geekosaur: using the --configure-option flag?
09:50:46 <geekosaur> and you do not want gsl-devel at all, it's the last alpha release
09:52:05 <geekosaur> --extra-include-dirs, --extra-lib-dirs
09:55:44 * geekosaur moderately amazed that [redacted] has not injected an irritated comment about people using Not The Only Acceptable Package System
09:55:56 <joelteon> nice
09:56:07 <joelteon> so after setting -auto-all and -caf-all in my profiling options
09:56:24 <joelteon> instead of getting one 100% cost center in MAIN, i have 98.1% in MAIN and 1.9% in Main
09:56:31 <joelteon> that's much easier
09:57:32 <monochrom> perhaps it is just because [redacted] is away
09:58:08 <monochrom> [redacted] is not a 24/7 high-availability server, you know :)
09:58:50 <mavam> Is the Process package the de-facto way to implement actors in Haskell?
10:00:22 <monochrom> I don't even know that people do actors in Haskell
10:01:13 <monochrom> actor is cool but probably fits other languages instead
10:01:48 <ReinH> mavam: take a look at cloud haskell
10:02:12 <ReinH> which uses a message passing model
10:02:24 <mavam> ReinH: is that industrial-strength? I've only seen a research paper and sample implementation
10:02:41 <mavam> yeah, I'm looking for message-passing related distributed programming
10:02:56 <ReinH> mavam: then cloud haskell is what you want
10:03:14 <ReinH> not sure how "industrial strengh" it is, but it's more industrial strength than anything else
10:03:19 <mavam> how does it differ from Process?
10:03:41 <mavam> I thought (based on a first glance) that it also provides a message-passing interface
10:05:03 <ReinH> it's significantly more mature than Process
10:05:19 <mavam> good to know
10:05:53 <ReinH> mavam: http://haskell-distributed.github.io/
10:06:20 <ReinH> If you want to do Erlang in Haskell, Cloud Haskell is the way to go
10:06:50 <mavam> exactly, I'll have a look at it. It looks well-maintained.
10:07:34 <ReinH> dcoutts: we're talking about you :)
10:07:45 <dcoutts> what what what!?
10:08:11 <dcoutts> :-)
10:08:15 <ReinH> :)
10:08:41 <dcoutts> mavam: it's onto its second implementation already
10:08:51 <dcoutts> not just that original sample impl
10:09:18 * dcoutts and edsko designed and implemented the new one
10:10:41 <joelteon> i've narrowed it down to a call to persist's runPool
10:10:41 * hyperthunk hears people are talking Cloud Haskell …..
10:11:11 <dcoutts> oh and hyperthunk is our awesome Cloud Haskell maintainer :-)
10:11:33 <mavam> dcoutts, hyperthunk: sweet, so I can pepper you guys with questions here once I get started :-p
10:11:41 * hyperthunk blushes
10:12:12 <hyperthunk> mavam: questions are most welcome, but you'll find me on #haskell-distributed rather than here. It's a bit too busy in this room and I have a day job. ;)
10:12:21 <paolino> hello, is there a function , or it's easily obtained , in Data.Graph to test for acyclicity ?
10:12:24 <joelteon> time to insert a cost center by hand
10:12:33 <joelteon> do cost centers work on IO actions?
10:12:40 <joelteon> or is it just the cost of evaluating the action?
10:12:41 <ParahSailin> im not good with fiddling with infixity-- how do i make it so i can do away with the parentheses around the value after the =<<
10:12:44 <ParahSailin> http://lpaste.net/93201
10:13:34 <dwcook> ParahSailin, well, you could use a prefix function and just use $ all the way
10:13:58 <bgamari_> dcoutts, Do you suppose it might be appropriate at this point for someone to commandeer test-framework on hackage?
10:13:58 <dwcook> One problem is that $ is the lowest precedence possible
10:14:25 <dcoutts> bgamari_: probably, but do ask Max, he'll probably be happy to hand over
10:14:41 <dcoutts> bgamari_: in particular it needs to be integrated with the new Cabal test API
10:16:36 <bgamari_> dcoutts, Yep, not to mention there have been outstanding pull requests waiting for 6 months now
10:18:46 <paolino> it would be ok an inefficient function for a list of pairs, I didn't come out with a correct one
10:20:12 <dcoutts> bgamari_: sadly what happens when people finish their PhDs and go get real jobs :-(
10:20:18 <mr-> paolino: you could check if the spanning tree happens to be your graph
10:20:31 <ReinH> paolino: http://hackage.haskell.org/packages/archive/Graphalyze/0.11.0.0/doc/html/Data-Graph-Analysis-Algorithms-Common.html
10:20:33 <bgamari_> dcoutts, heh, yep
10:21:49 <joelteon> i would absolutely love something like ruby's ability to set a global trace statement
10:24:20 <joelteon> does interrupting a process taking a lot of CPU make the profiling report useless?
10:24:39 <Tekmo> joelteon: Do what I do an catch the interrupt in a catch-all block
10:24:52 <Tekmo> This causes the profiling to terminate gracefully and generate a correct report
10:25:45 <joelteon> oh
10:25:50 <joelteon> ok cool
10:26:30 <paolino> ReinH, thanks. I thought it was simpler than that, something like fibonacci
10:27:53 <blochchain> there's no such things as pointer references between items in a list, right? not in the sense of redirecting the user, but in the sense of referencing another item's value in its own calculation. For example, if mylist[4]'s value in memory was 5 + (the value in mylist[3]).
10:28:02 <blochchain> i'm just trying to fully understand how thunk accumulation works
10:28:12 <dwcook> I've discovered a reason why Set isn't a Functor that's more compelling than the one I was given here, which is that Set requires its content type to be Ord but there's not a good way to do that in Haskell 98.
10:28:48 <dwcook> But what if you had a less efficient Set that didn't require it? Then couldn't it be a Functor?
10:28:51 <elliott> you were given another resaon?
10:28:54 <shachaf> blochchain: Sure there could be, if I unedrstand what you mean.
10:28:55 <Tekmo> dwcook: Yes
10:29:13 <shachaf> dwcook: That would be a mighty inefficient Set if it didn't even require Eq.
10:29:19 <mr-> dwcook: don't you at least need an Eq constraint?
10:29:20 <dwcook> shachaf, ha, good point.
10:29:26 <Iceland_jack> dwcook: http://hackage.haskell.org/package/set-monad
10:29:28 <joelteon> okay, well, this still isn't working
10:29:32 <elliott> blochchain: xs = [0,1,2,3,5 + xs!!3]
10:29:38 <shachaf> But you can use a CoYoneda-style trick: data Set' a = forall x. Ord x => Set' (Set x) (x -> a)
10:29:39 <blochchain> shachaf, basically from my perspective it would depend on the decision made when the compiler was written and wouldn't affect the language's functionality at all.
10:29:41 <shachaf> That's a Functor.
10:30:00 <joelteon> runSql from persistent is causing an infinite loop in my app
10:30:00 <Tekmo> mr-: In theory it can work if you never apply the constraint on set manipulations and you only apply it on the way out (i.e. converting to a list when done)
10:30:04 <joelteon> or something.
10:30:13 <shachaf> But of course it comes with small caveats (and a Monad would come with much bigger caveats).
10:30:14 <Iceland_jack> já
10:30:19 <joelteon> when it enters runSql it hangs and consumes 100% CPU, so I'm guessing that's an infinite loop
10:30:20 <Tekmo> mr-: You'd just never sort or order things or remove duplicates until the las tmoment
10:30:24 <joelteon> but I have no idea how to debug it
10:30:48 <blochchain> > let xs = [0,1,2, 3 + xs!!2] in xs!!3
10:30:50 <lambdabot>   5
10:30:55 <blochchain> thanks elliott
10:31:06 <mr-> Tekmo: So you'd constraint it so that it does not always have a way out?
10:31:11 <joelteon> it's not helpful that -xc reports every single thrown exception
10:31:15 <mr-> Tekmo: never mind, Ok
10:31:39 <Tekmo> mr-: After all, in theory you could simply store a set as a list of all operations applied to it
10:31:50 <Tekmo> mr-: Without actually competing them until you converted the set to something else
10:31:51 <joelteon> I can't even figure out which thing is being evaluated when I interrupt it
10:31:52 <elliott> shachaf: hmm, can you use newtype Set' a = Set' (Ord a => Set a)?
10:31:58 <Tekmo> *computing
10:32:00 <joelteon> it's just a bunch of THUNK_1_0
10:32:09 <mr-> Tekmo: Yeah, makes sense :-)
10:32:09 <joelteon> am I missing a profiling flag somewhere?
10:32:09 <elliott> oh, you can't.
10:32:45 <blochchain> elliott: i guess my question, though, is whether the value of xs[3] in memory after the let is executed is 3 + 2 or 3 + (the value in x[2]). obviously, the value in x[2] can't change, but i'm trying to figure out whether it copies the thunk over or actually evaluates x[2] and then uses that when x[3] is first called
10:33:07 <elliott> "the let is executed" is not really a defined concept.
10:33:15 <elliott> so it's hard to answer.
10:33:28 <joelteon> or do I need to compile all my dependent libraries with -auto-all or something
10:33:39 <Tekmo> blochchain: How would you detect the difference?
10:33:40 <elliott> when you evaluate xs!!4 or whatever, it will look up the previous element in xs.
10:33:49 <elliott> that element happens to be 2.
10:34:04 <blochchain> Tekmo, you wouldn't as a user, it's a compiler thing that effects performance
10:34:10 <blochchain> ah right elliott
10:34:17 <blochchain> i forgot how far laziness reaches
10:34:22 <shachaf> elliott: No, that has the wrong variance on the dictionary.
10:34:45 <Tekmo> blochchain: A good rule of thumb is that `let` never executes code
10:35:03 <blochchain> they're all just values waiting to be evaluated lazily when called upon
10:35:05 <joelteon> wtf
10:35:18 <joelteon> i compiled with --enable-executable-profiling and --enable-library-profiling and it's still telling me to link with -rtsopts
10:35:24 <Tekmo> blochchain: Only case statements force things to be demanded
10:35:30 <joelteon> how do I link with -rtsopts
10:35:40 <Tekmo> blochchain: Or case equivalents (like equality or FFI calls)
10:36:38 <Tekmo> joelteon: Yes, this is a pain in the butt
10:36:52 <Tekmo> joelteon: For any library that you want detailed profiling information you need to compile it with profiling enabled
10:37:03 <FreeFull> > let xs = [xs!!1,xs!!2,3] in xs
10:37:05 <lambdabot>   [3,3,3]
10:37:23 <shachaf> elliott: You can use a Yoneda-style type instead of CoYoneda-style, though.
10:37:40 <joelteon> okay so I ran +RTS -B and when it hits the infinite loop, or whatever, there are a LOT of garbage collections
10:37:43 <joelteon> does that sound right
10:38:04 <dagano> newtype Point a = Pt (IORef (Link a)) deriving Eq
10:38:12 <shachaf> data Set' a = Set' (forall b. Ord b => (a -> b) -> Set b)
10:38:16 <dagano> i would like to make a Point with the above definition
10:38:31 <shachaf> As usual, I don't know of an obvious advantage of one over the other.
10:38:32 <Tekmo> joelteon: That's totally possible.  If the loop is constantly allocating and deallocating it will generate garbage
10:38:38 <joelteon> Tekmo: I've compiled all my libraries with profiling enabled, but do I have to do something else to get useful cost centers?
10:38:48 <joelteon> rather than MAIN.MAIN
10:39:02 <Tekmo> joelteon: If you use -auto-all and -caf-all it tags all top-level values as cost-centers
10:39:13 <joelteon> okay, I did that
10:39:18 <Tekmo> joelteon: You can get even more detailed cost-centers by using `{-# SCC name #-}` annotations
10:39:24 <joelteon> and it says 98% of time was spent in MAIN and 2% was spent in Main
10:39:29 <Tekmo> joelteon: That basically attaches a cost center to the expression to its right
10:39:33 <joelteon> I used the SCC annotation and it doesn't show up in the prof report
10:39:46 <Tekmo> joelteon: It should show up at least once
10:40:02 <Tekmo> joelteon: It will show up under whatever label you gave it
10:40:10 <joelteon> oh hey, so it does
10:40:20 <ellipsis> I'm trying to run "cabal-dev ghci", but it spits out "cabal-dev: user error (cabal: Can't parse --info output of GHC)"
10:40:23 <joelteon> it used 0.2 time and 0.1 alloc
10:41:05 <Tekmo> joelteon: First off, do you suspect the infinite loop is in your own code or in some library that you are using?
10:41:09 <joelteon> In a library
10:41:25 <joelteon> It happens in persistent's runSql. if I remove one of the runSql calls it happens in the call before it
10:42:09 <joelteon> basically the last call in the block is an infinite loop
10:42:39 <Tekmo> joelteon: It might be possible that you are passing a parameter to `runSql` that when evaluated produces an endless loop
10:43:29 <joelteon> ok, that makes sense
10:44:13 <joelteon> Why would it always be the last statement in the block though?
10:44:30 <Tekmo> joelteon: That is definitely weird
10:44:51 <Tekmo> joelteon: Try this test: add *another* runSql statement after your current last one and see if it still triggers on the last call
10:45:00 <joelteon> Yeah
10:45:04 <joelteon> That's what I just did, and that's what happened
10:45:32 <Tekmo> joelteon: What's the library that provides `runSql`?
10:45:34 <Tekmo> Oh yeah, you said persistent
10:45:35 <joelteon> persistent
10:45:55 <joelteon> here, https://gist.github.com/joelteon/fc6fcfb72bf415492f1c
10:46:01 <joelteon> if I remove lines 7 and 8, "got tags" is never printed
10:46:06 <joelteon> but if I add them in, it is
10:46:12 <joelteon> and "got useless entity" is not
10:47:29 <Tekmo> joelteon: Where are these `runDB` and `getBy404` commands?  I don't see them in the API for `persistent`
10:47:52 <joelteon> Those are yesod builtins
10:48:03 <joelteon> runDB just fetches the current sql connection and pool and runs the query
10:48:07 <joelteon> hang on a second, I'll get the code
10:48:16 <Tekmo> joelteon: Do any of these libraries use lazy `IO`?
10:48:25 <joelteon> don't know
10:48:32 <Tekmo> joelteon: The reason I ask is that if it triggers on the last one, that sounds like something is happening upon garbage collection
10:48:47 <Tekmo> joelteon: ... which usually only happens if they are using garbage collection for resource management
10:49:24 <joelteon> this is defaultRunDB https://gist.github.com/anonymous/0448c29550bd34a078ae
10:49:32 <joelteon> Oh, that sounds like something that could happen, yeah
10:49:39 <Tekmo> joelteon: Actually
10:49:51 <Tekmo> joelteon: What happens if you insert this as your new last line:
10:50:05 <Tekmo> joelteon: `evaluate e`
10:50:12 <joelteon> what's e
10:50:15 <joelteon> oh, right
10:50:19 <Tekmo> joelteon: The input to your function
10:50:30 <joelteon> Right I remember now
10:50:58 <Tekmo> joelteon: The idea is that if garbage collection is triggering this then you can verify that by keeping each variable alive longer using `evaluate` and see if that delays the symptoms
10:51:03 <joelteon> okay
10:51:34 <joelteon> Okay it's still getting stuck. let me add some "tracing" statements
10:51:41 <applicative> oh Tekmo, hi!
10:51:44 <Tekmo> applicative: Hi!
10:52:13 * applicative was just trying to figure out this accursed directory category
10:52:20 <Tekmo> applicative: You mean for Dag's stuff?
10:52:28 <applicative> yeah
10:52:38 <Tekmo> I still don't understand the issue
10:52:44 <joelteon> Tekmo: if I replace the useless entity line with evaluate e, the behavior is as if there was no evaluate line
10:52:50 <joelteon> be back in 10 min
10:52:55 <Tekmo> joelteon: Okay
10:53:16 <Tekmo> applicative: I read his last e-mail but I don't understand what the `anything` is that he is referring to
10:54:00 <applicative> Tekmo: I'm still at the point of actually trying to name a file with it; I might have a thought later
10:54:32 <applicative> I had a question that may be stupid but came into my head with the dirstream business
10:54:54 <applicative> this cranks out filepaths -- if say you ask it just to print all subordinate files
10:55:00 <Tekmo> Shoot
10:55:23 <applicative> the nice feature is that there isn't the familiar  memory nightmare
10:55:34 <applicative> but there is a problem about buffers and writing, no?
10:56:03 <applicative> if i print all the filenames, i pass a huge succession of bitty bytestrings to stdout
10:56:26 <applicative> or wherever
10:56:27 <luite> /usr/bin/ld: dist/build/Gen2/RtsApply.dyn_o: relocation R_X86_64_PC32 against undefined symbol `ghcjszm0zi1zi0_Gen2ziUtils_identBothzulvl_closure' can not be used when making a shared object; recompile with -fPIC  <- what can be the reason of this, when running TH? shouldn't it build PIC automatically if TH needs it?
10:56:50 <applicative> Tekmo: that is, the sort of reason Builders exist -- or one of them, isn't taken into account?
10:57:59 <applicative> this is a blur because I don't know much about it, but it is clear there is some unpleasant irregularity, a halting and starting on the write end with for (fastproducer) (lift.lift.print)
10:58:06 <donri> applicative, Tekmo: hi, i'm dag
10:58:15 <applicative> haha hi dag
10:59:42 <applicative> donri: i was about to compose another benchmark to see if i could figure out your types
10:59:58 <donri> oh you're michael t :) hi
11:00:04 <applicative> yeah
11:01:00 <Tekmo> donri: Hey!
11:01:21 <donri> too bad i have to go dinner right now :(
11:01:26 <Tekmo> applicative: Yes, builders would be more efficient
11:01:32 <applicative> I'm not sure i want Builders in these paths at the moment; openDirectoryStream wants strict bytestrings, and readDirStream produces them...
11:02:16 <Tekmo> donri: It's okay :)
11:02:27 <applicative> Tekmo: i was looking into the Builder internals. They're a nightmare of course
11:02:29 <Tekmo> applicative: You're michael t?
11:02:38 <applicative> but sort of interesting from the present point of view
11:02:38 <applicative> yes
11:02:45 <Tekmo> Thanks for all the benchmarks! :)
11:02:56 <applicative> just practicin'
11:03:04 <Tekmo> applicative: Actually, builder is really simple
11:03:19 * applicative knew Tekmo would think that...
11:03:59 <Tekmo> Think of it like a `Producer` of pointer operations
11:04:14 <Tekmo> Rather than transmitting the data you just transmit instructions for how to read and write it
11:04:15 <applicative> Yes, exactly
11:04:25 <applicative> its the pointer part...
11:04:33 <joelteon> Tekmo: back
11:04:36 <Tekmo> joelteon: Hey
11:04:44 <joelteon> can I disable GC?
11:04:55 <Tekmo> I have an interview in a few minutes, so I need to take a break for a moment
11:04:55 <joelteon> Or manually perform it
11:05:13 <applicative> haha, the interviewer can wait, we  more important questions ...
11:05:16 <applicative> have
11:05:20 <Tekmo> :)
11:05:34 <applicative> good luck i will ask later
11:05:36 <Tekmo> Alright
11:05:39 <Tekmo> Thanks!
11:05:48 <joelteon> ok I'll try performGC and see if that helps
11:06:32 * hackagebot read-bounded 0.1.0.0 - Class for reading bounded values  http://hackage.haskell.org/package/read-bounded-0.1.0.0 (ThomasEding)
11:06:35 <joelteon> okay, it doesn't look like it's GC-related.
11:06:39 <joelteon> a performGC call before the tag list fetch returns fine
11:06:48 <joelteon> but the tag list fetch itself hangs
11:08:21 <joelteon> maybe I'll evaluate the things returned by runDB
11:08:41 <joelteon> no, that doesn't help either.
11:09:00 <dagano> what does this mean ? newtype Point a = Point Int
11:09:09 <dagano> is Point already a Prelude type?
11:09:36 <geekosaur> no
11:09:45 <geekosaur> you may have newtype confused with type
11:09:49 <Iceland_jack> dagano: You define the constructor at the same time
11:09:58 <dagano> yeah .. newtype is more than an alias, right?
11:10:30 <acomar> dagano: yea, it's a wrapper. You have to do the wrap and unwrap work to get at the type inside
11:10:49 <dagano> given the above, how do I 'make' a Point 4?
11:10:55 <Iceland_jack> Point 4
11:10:59 <dagano> or is that a question that reveals how confused i am?
11:11:18 <acomar> Point is your type constructor, just like for a data declaration
11:11:30 <shachaf> dagano: You're probably confused because the same name is being used for the type constructor and data constructor.
11:11:34 <acomar> if you had data Point = Point Int, how would you make Point 4?
11:11:41 <Iceland_jack> dagano: You probably want:
11:11:41 <Iceland_jack>     newtype Point a = Point a
11:11:41 <Iceland_jack> where you can make something of type (Point Double) by:
11:11:41 <Iceland_jack>     Point 3.1415 :: Point Double
11:11:45 <geekosaur> given `newtype X a = Y a`, you use Y to either create an X or in a pattern to unwrap it
11:12:04 <Iceland_jack> But yes, the same name for the type and data constructors is probably what's confusing you
11:12:15 <applicative> in old textbooks the practice was to write data Point a = MkPoint a, which was actually just as confusing
11:12:23 <dagano> Iceland_jack: that is what i want...having trouble getting it
11:12:44 <Iceland_jack> dagano: You can skip the parameter for now and just allow Int pointers
11:13:05 <Iceland_jack> You can define that with:
11:13:05 <Iceland_jack>     newtype Point = Point Int
11:13:13 <dagano> so I import Data.UnionFind.IntMap as UF
11:13:20 <dagano> UF.Point 4 :: UF.Point Int
11:13:24 <dagano> should yield something useful
11:13:31 <applicative> there seems even to have been a special pronunciation of Mk, 'mook'
11:14:07 * geekosaur pronounces it "mc-" like mcfoo names
11:14:21 <Iceland_jack> dagano: Sure, maybe you'd like to try it with your own datatypes for now
11:14:21 <chrisdone> 'mook' is pretty funny
11:14:25 <Iceland_jack> to get a feel for it
11:14:30 <chrisdone> i might start adopting that just because it's so random
11:14:31 <dagano> Iceland_jack: probably good advice
11:14:54 <Hafydd> What's wrong with "make"?
11:15:13 <chrisdone> dunno
11:15:24 <joelteon> oh, man.
11:15:27 * monochrom says "make" too. "mkvar" -> "make var"
11:15:31 <joelteon> I just tracked down my problem.
11:15:44 <chrisdone> somehow i like 'make-' for pure things, and new- for impure things
11:15:47 <shachaf> The trouble with "Mk" is that it's equally used for pattern matching.
11:16:09 <applicative> then you pronounce it 'made'
11:16:20 <monochrom> haha
11:16:41 <chrisdone> if i become a made data structure can i force any thunk i want?
11:17:00 <monochrom> no, in soviet russia, they force you!
11:17:07 * chrisdone wonders if Goodfellas references are lost on #haskell
11:17:24 <monochrom> I don't even know Goodfellas
11:17:39 <joelteon> i saw goodfellas
11:17:41 <joelteon> what a film
11:17:44 <monochrom> (was he/she a good fellow?)
11:17:47 <joelteon> he was
11:17:50 <joelteon> unti he ratted them out
11:17:58 <joelteon> that son of a bitch
11:23:42 <chrisdone> monochrom: Goodfellas is a movie based on a book by an Italian-American mobster, in which becoming a "made man", provided you're of 100% Italian descent, you're now part of a crew, meaning you are pretty much untouchable and can pretty much do what you want to people (who aren't also members) =)
11:24:07 <roconnor> Can someone explain to me what seq does to a value of function type?
11:24:21 <roconnor> beyond just using the words "weak head normal form"
11:24:32 <chrisdone> it can still force it
11:24:47 <monochrom> work on it until you see lambda. then stop.
11:25:08 <roconnor> monochrom: Is that how it looks on a STG manchine?
11:25:19 <roconnor> What if everything is compiled to combinators?
11:25:30 <monochrom> example: if True then (\a -> if True then a else a) else undefined --> (\a -> if True then a else a) --> stop
11:25:48 <monochrom> then I don't know
11:25:51 <chrisdone> for example (snd (fst,snd)) -- this is type (a,b) -> b, but you still have to force the thunk to get it
11:25:57 <Saizan> it's probably going to look like a partial application often
11:26:02 <roconnor> @pl if True then (\a -> if True then a else a) else undefined
11:26:03 <lambdabot> if' True (join (if' True)) undefined
11:26:12 <roconnor> okay what if you seq that?
11:26:50 <roconnor> Hmm, I guess you keep reducuing untill you get to a partially applied combinator.
11:26:58 <Saizan> i guess it depends on how join is compiled
11:41:05 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
11:41:05 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Sat Sep 14 23:34:37 2013]
11:41:24 <acomar_> ifthenelse: the worst case is that you create an empty SMat (with svdNewSMat()), and then write your data into that matrix
11:41:32 <acomar_> but there's probably a more efficient way to do that transformation
11:42:15 <ifthenelse> acomar_: Where is the ffi documentation? I can't find it...
11:42:42 <acomar_> http://www.haskell.org/haskellwiki/Foreign_Function_Interface
11:42:46 <acomar_> ifthenelse: ^
11:44:09 <acomar_> if you're willing to add a dependency to your program, the bindings-dal library provides a few macros that make wrappers like this very easy to write.
11:44:27 <carter> ifthenelse: if all goes well, i'll have a snazzy sparse lin alg thing in another month or two
11:44:37 <carter> trying to get my snazzy dense lib out before the end of this month
11:44:59 <acomar_> ifthenelse: all that said
11:45:07 <acomar_> ifthenelse: someone already released a binding for this library
11:45:19 <ifthenelse> acomar_: Yeah, I saw that, but it's for hmatrix
11:45:47 <ifthenelse> acomar_: Which would be fantastic, but hmatrix doesn't support sparse matrices, so I have no idea why they would do that
11:46:21 <acomar_> ifthenelse: fair enough, consider putting your wrapper on hackage when you're done with it
11:46:34 <acomar_> I can't imagine you're the only one who's wanted that binding
11:46:48 <ifthenelse> acomar_: I have never done any binding ever, so this will be extaordinarily difficult
11:47:08 <acomar_> ifthenelse: nah, it's set up to be fairly easy
11:47:33 <ifthenelse> I think I tried it in Python once
11:47:37 <ifthenelse> Didn't go too well
11:47:51 <ifthenelse> I like staying in the same language ahha
11:48:16 <carter> acomar_: ifthenelse  which lib ffi'd?
11:48:25 <acomar_> carter: libsvdc
11:48:55 <carter> google isn't helping me :(
11:48:55 <acomar_> there's an hmatrix binding, but no general wrapper
11:49:10 <acomar_> http://tedlab.mit.edu/~dr/SVDLIBC/
11:49:19 <ifthenelse> and hmatrix doesn't even support sparse matrices, so it's annoying
11:49:38 <ifthenelse> hmatrix should just be standard and have all of the different matrices use it
11:49:47 <carter> ifthenelse: nope
11:49:53 <ifthenelse> we have like 3 different sparse matrix libraries
11:49:54 <carter> hmatrix has lots of bad design stuff
11:49:57 <ifthenelse> oh
11:50:00 <carter> ifthenelse: and they're all bad
11:50:01 <elliott> ifthenelse: I don't know the ocntext but maybe look at http://hackage.haskell.org/package/sparse
11:50:03 <ifthenelse> well we need SOME standard
11:50:23 <carter> ifthenelse: well, i'll be trying to get people to standardize on my stuff once i get it out *asap*
11:50:29 <acomar_> ifthenelse: https://github.com/bgamari/hmatrix-svdlibc/blob/master/Numeric/LinearAlgebra/SVD/SVDLIBC.hs it actually has everything you need already
11:50:30 <carter> elliott: it doesn't have solvers or things
11:50:49 <carter> i'm aiming to get the dense api out this month
11:50:56 <carter> and sparse out in another month or three
11:51:18 <ifthenelse> acomar_: But it uses another format...
11:51:24 <acomar_> ifthenelse: if you import that module, you get all the functions from svdlibc. From there, you just need to write a conversion function two and from sparsematrix
11:51:28 * hackagebot Cabal 1.18.1 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1 (JohanTibell)
11:51:33 <carter> theres lots of good formats
11:51:35 <acomar_> ifthenelse: don't use that dvd function
11:51:37 <acomar_> *svd
11:51:37 <carter> memory locality mattes
11:51:39 <acomar_> damn autocorrect
11:52:51 <carter> *matters
11:53:39 <acomar_> ifthenelse: yea, so having read those bindings, that particular file has nothing at all to do with hmatrix. it's just a very simple ffi wrapper around svdlibc
11:55:23 <ifthenelse> acomar_: I thought of doing that a while back, but the sparse matrix type is confusing to me.
11:55:31 <ifthenelse> For instance, where the heck is it
11:55:39 <acomar_> ifthenelse: agh, yea. it's a foreign pointer
11:55:44 <acomar_> *ahh
11:55:58 <acomar_> ifthenelse: meaning there's no representation of it in Haskell
11:56:02 <ifthenelse> yay
11:56:17 <acomar_> ifthenelse: the only way to deal with the type is through the functions provided in that module
11:56:41 <carter> hehe, you'll like the api i have planned then
11:56:41 <ifthenelse> Which module, the hmatrix sparse svd module?
11:56:44 <carter> for handling all the layouts
11:57:03 <ifthenelse> carter: THEN STOP TALKING ABOUT IT AND GET TO WORK! :P
11:57:15 <carter> first lemme finish my patch for ghc
11:57:22 <ifthenelse> haha
11:57:36 <carter> http://ghc.haskell.org/trac/ghc/ticket/8256#comment:25
11:57:47 <carter> adding prefetch support to the native code gen
11:58:09 <carter> and making it so we have all the standard x86 prefetch variants
11:58:26 <acomar_> prefetch?
11:59:08 <carter> "i'll be looking at that place in memory soon, load it into cpu cache ahead of time, but i'll be doing other stuff in the mean time before i need it"
11:59:19 <acomar_> oh cool
11:59:24 <carter> yeah
11:59:35 <acomar_> that sounds particularly useful...
11:59:36 <tomejaguar> unsafeCoerce# = let x = x in x.  Is that just a dummy definition to pass the type checker, and the real "implementation" elsewhere?
11:59:42 <carter> yup
11:59:44 <carter> dummy
11:59:54 <shachaf> Yes, all the primops are that way.
11:59:55 <carter> all the primops have dummy defns
12:00:05 <argiopeweb> carter: Ooh, I had been wondering (in a lazy, don't want to research way) if that was implemented in GHC.
12:00:17 <carter> which was?
12:00:22 <tomejaguar> Ah right.  How come they don't just have no definition?
12:00:23 <carter> prefetch?
12:00:25 <argiopeweb> Prefetching
12:00:38 <carter> geoff mainland added it sometime over the past year
12:00:41 <carter> but was llvm only
12:00:41 <argiopeweb> Seems like it should have gone in with SIMD
12:00:42 <ifthenelse> acomar_: So it seems like those wrappers are more difficult than it seems--is there a quick and easy way to improve on what I am doing now while we wait for carter's revolutionary library?
12:00:56 <ReinH> edwardk: currently trying to convince myself to buy this http://www.amazon.com/dp/9027725616
12:00:57 <tomejaguar> Oh yeah, they're all "let x = x in x" in GHC.Prim!
12:01:08 <ifthenelse> acomar_: That is, instead of writing the string to a file and reading the result back in, can I do this in memory?
12:01:19 <carter> ReinH: jaap sutter tutorial is good too
12:01:25 <acomar_> ifthenelse: talk through what you're struggling with, I can't help if I don't know what you're stuck on
12:01:35 <edwardk> ReinH: i'd personally put it off. it is a powerful tool, but it is quite a rabbit hole
12:01:42 <ReinH> edwardk: kk
12:01:50 <ReinH> but it sounds so interesting
12:01:51 <edwardk> and yeah jaap suter was an old flipcoder. his tutorial is an excellent introduction
12:02:00 <ReinH> carter: link?
12:02:03 <carter> http://www.jaapsuter.com/geometric-algebra/
12:02:06 <ReinH> ty!
12:02:17 <carter> np
12:02:19 <ReinH> edwardk: btw where are your old game dev articles?
12:02:29 <edwardk> flipcode has some of them
12:02:30 <ifthenelse> acomar_: I want to find the svd for a sparse matrix. I am converting the sparse matrix into a string, writing that string to a file, executing svdlibc on the file, reading the output back into haskell, and converting that string into my result.
12:02:32 <carter> ifthenelse: the answer is theres no good systematic substrate
12:02:41 <carter> yet
12:03:04 <edwardk> www.flipcode.com/harmless  has som that i wrote as i was leaving the space to summarize what i'd learned about visibility structures
12:03:05 <carter> but the good news is i've been convinced to start doing really ghetto intial prototyp releasees
12:03:18 <Umbrall> Can anyone point me to the definitions for All and Any? I can't really seem to find the types cause the names are so hard to search for
12:03:28 <acomar_> so barring waiting for carter's library, your best bet is to figure out how to create a SparseMatrix from your sparse matrix type
12:03:31 <edwardk> newtype All = All { getAll :: Bool }
12:03:32 <donri> Umbrall: Data.Monoid
12:03:37 <acomar_> ifthenelse: ^
12:03:38 <ifthenelse> carter: As long as they are accurate! People's lives are at steak!
12:03:40 <edwardk> i bet you can guess the definition for Any ;)
12:03:42 <ifthenelse> stake
12:03:43 <ifthenelse> whatevs
12:03:47 <carter> accurate in which sense?
12:03:53 <Umbrall> oh okay thanks
12:03:59 <carter> numerically stable on well conditioned inputs?
12:04:12 <edwardk> ifthenelse: but what if they ordered the chicken?
12:04:16 <ifthenelse> acomar_: Okay, I guess I was afraid of that. Last thing--where is that Sparse Matrix defined?
12:04:27 <ifthenelse> edwardk: God help the vegans.
12:04:38 <acomar_> ifthenelse: in that file I linked: newtype SparseMatrix = SMat (ForeignPtr SparseMatrix)
12:04:39 <acomar_>                      deriving (Eq, Ord, Show)
12:05:09 <ifthenelse> But...what IS that Sparse Matrix? Format wise...
12:05:15 <acomar_> ifthenelse: take a look at the C header
12:05:22 <acomar_> ifthenelse: it describes the SMat structure
12:05:31 <acomar_> ifthenelse: SparseMatrix is a pointer to that struct
12:05:55 <carter> yeah
12:05:59 <carter> you have touch some c codes :)
12:09:22 <ifthenelse> *shiver*
12:09:52 <acomar_> ifthenelse: the dense matrix is easy to construct, it's just a wrapper around a C array. The sparse matrix will take a little work. Your sparse matrix type is basically IntMap (IntMap a) where a is the matrix value type
12:11:15 <ifthenelse> I already converted my matrix to a string--can't I just call the C function that takes a file (in this format) and converts it into an SMat?
12:11:29 <acomar_> ifthenelse: yea, of course
12:11:39 <acomar_> ifthenelse: I thought you wanted something more efficient?
12:11:40 <ifthenelse> YAY!
12:11:53 <ifthenelse> I do, but the conversion to string can't be THAT long...
12:12:13 <ifthenelse> unless that's the problem
12:12:14 <geekosaur> I am confused as to what you meant by that, actually. or perhaps you are confused as to what you are asking for
12:12:20 <ifthenelse> then yes, yes I do
12:12:38 <geekosaur> why are you now asking about something taking a file, if you're trying to avoid using a file?
12:12:58 <acomar_> geekosaur: he won't have to write it to a file if he just calls the C function on the string directly
12:12:58 <ifthenelse> I was just trying to avoid the HDD
12:13:07 <acomar_> although...
12:13:08 <geekosaur> what do you believe a file is?
12:13:15 <acomar_> ifthenelse: this says it takes a file handle
12:13:21 <ifthenelse> oh
12:13:22 <ifthenelse> drat
12:13:23 <acomar_> ifthenelse: not the file contents
12:13:33 <ifthenelse> yeah that was my next quesiton haha
12:13:54 <acomar_> ifthenelse: I don't think it'll be that hard to write a conversion from a sparse matrix to SMat
12:13:58 <acomar_> (and back)
12:14:03 <ifthenelse> acomar_: So it looks like I'll need to convert
12:14:19 <ifthenelse> acomar_: It wouldn't be hard--if I knew what I was doing
12:15:11 <acomar_> ifthenelse: I mean, you need to make a couple of C arrays that hold the data the structure is looking for, make the structure and stick in your values
12:15:14 <ifthenelse> acomar_: I haven't used C in a looooong time, and even then it was just for around a month--so I know extremely little about it.
12:15:22 <acomar_> ifthenelse: ohhhh
12:15:27 <ifthenelse> mhm
12:15:55 <acomar_> ifthenelse: If I have some time in a bit, I'll write the conversion functions
12:15:58 <ifthenelse> acomar_: Maybe I should just code my own sparse svd funciton.
12:16:01 <acomar_> or that
12:16:35 <ifthenelse> acomar_: My fear is that I would choose the wrong algorithm and have a super slow one as opposed to this blazing fast C library.
12:16:37 <kqr> dwcook, yeah, SO
12:16:59 <acomar_> ifthenelse: yea, I try to avoid rolling my own if there's already a high performance library out there
12:17:38 <ifthenelse> acomar_: Exactly
12:17:46 <acomar_> ifthenelse: if my opencv library were closer to being usable, I'd point you at that… it has a sparse matrix type and svd on that type already implemented
12:18:00 <dagano> homework help me please : i want to write a function that takes a [(Int,Int)] and groups the elements into new lists based on whether they are connected : [(2,3),(3,5),(6,8)] -> [[2,3,5],[6,8]]
12:18:10 <dagano> how should I be thinking about this?
12:18:23 <ifthenelse> I wish it were that simple
12:18:48 <tromp_> what if you have  [(3,5),(2,3),(6,8)] ?
12:19:02 <tromp_> does order matter?
12:19:07 <dagano> [[3,5,2],[6,8]]
12:19:08 <argiopeweb> dagano: tromp_: Assume sorted tuples?
12:19:09 <dagano> nope
12:19:17 <dagano> tromp_: no
12:19:21 <dagano> argiopeweb: not necessary
12:19:44 <tromp_>  http://en.wikipedia.org/wiki/Special:Search?go=Go&search=3,5,2],[6,8 makes no sense
12:19:47 <dagano> imperatively...i would assume that every "object" is in its own list .. alone
12:20:00 <tromp_> i meant  http://en.wikipedia.org/wiki/Special:Search?go=Go&search=3,5,2],[6,8 makes no sense
12:20:02 <acomar_> dagano: so it's basically the graph connectivity algorithm?
12:20:04 <tromp_> what the heck
12:20:19 <dagano> acomar_: basically, yes
12:20:37 <dagano> acomar_: or exactly yes
12:21:26 <acomar_> dagano: my hint is to fold through and build the connectivity lists. an inefficient approach is to keep folding the resulting list until you get no change.
12:21:49 <acomar_> dagano: a more efficient approach is to build up a map that tracks connectivity
12:22:02 <dagano> i'll start with inefficient
12:22:08 <argiopeweb> Cycle detection might be an issue.
12:22:14 <acomar_> ^
12:22:36 <monoidal> dagano: what do you expect for [(2,3),(1,8),(3,5)]?
12:23:03 <dagano> monoidal: [[2,3,5],[1,8]]
12:23:28 <argiopeweb> But I suppose you can suppose an acyclic graph for the inefficient prototype...
12:23:30 <dagano> argiopeweb: yeah .. this is actually my first steps in an MST algo..cycle detection is an issue..but not there yet
12:23:30 <tromp_> what about [(2,3),(2,4),(1,2)] ?
12:23:54 <dagano> tromp_: a spanning tree if V={1,2,3,4]
12:24:06 <shanse> somebody's doing the coursera course
12:24:14 <dagano> shanse: hah! yes
12:24:24 <dagano> shanse: somebody's struggling with the coursera work
12:24:50 <dagano> i could murder these assignments in an imperative language .. but apparently i would rather have a headache
12:25:56 <dagano> acomar_: folding through and building the connectionlist...
12:26:28 <acomar_> think about it one piece at a time
12:27:03 <acomar_> your connection list so far looks like [[2,3], [1,8]] and you get the next piece [3,5]
12:27:07 <acomar_> how do you update?
12:27:36 <dagano> connection list is x:xs
12:27:47 <dagano> check to see if 3 or 5 is elem of x
12:27:53 <dagano> or xs
12:27:55 <dagano> ?
12:28:16 <dagano> so i would use guards
12:28:44 <dagano> | 3 or 5 elem of x = 3 and 5 : x (weeding out duplicates)
12:28:49 <acomar_> oh, just thought of another case
12:29:08 <acomar_> [(2, 3), (5, 3), (1, 8)]
12:29:11 <dagano> | otherwise put 3 and 5 in their own list
12:29:31 <dagano> this assumes i have a connection list to begin with
12:29:32 <dagano> is this what I
12:29:36 <dagano> am building with a fold?
12:29:39 <acomar_> dagano: yep, it does assume that :)
12:30:12 <dagano> (am i flooding the channel?)
12:31:38 <acomar_> dagano: I think you're doing fine, this isn't off topic or anything
12:32:07 <dagano> so i have a function that takes a list of tuples and BUILDS the connection list
12:32:26 <acomar_> dagano: that's what you're trying to write, right?
12:32:28 <dagano> i can't really search through the supposed connection list in my function
12:32:40 <dagano> acomar_: yes
12:32:48 <acomar_> dagano: start writing some code :)
12:33:01 <dagano> have been trying
12:33:09 <ReinH> edwardk: I need to convince you to work with me on this roguelike.
12:33:55 <MedDev> ReinH, link to your rougelike?
12:34:02 <MedDev> roguelike*
12:34:12 <acomar_> dagano: what does your folding function look like so far?
12:34:29 <dagano> acomar_: i was doing explicit recursion with guards
12:34:45 <ReinH> MedDev: no link yet, just some explorations in distance map algos and such
12:35:03 <dagano> acomar_: which can be reduced to a fold if the pattern is correct, rigjht?
12:35:05 <acomar_> dagano: good haskell style is to try and avoid explicit recursion unless it's necessary
12:35:06 <ReinH> MedDev: https://github.com/reinh/DijkstraMap
12:35:24 <acomar_> dagano: I think you'll have an easier time if you write out just the update step then write out the fold
12:35:50 <ReinH> acomar_: it's nice to start with explicit recursion and then manually transform into folds so that you get an intuition
12:36:10 <acomar_> ReinH: ahh, I had to go the other way
12:36:25 <acomar_> ReinH: to stop writing out the recursion and start seeing the folds and maps
12:37:29 <ReinH> acomar_: the idea that folds generalize constructors for recursive data types was a useful one for me
12:37:53 <ParahSailin> what is the extension that allows implicit null constructors?
12:37:58 <ReinH> i.e. thinking about a list as a:b:c:d:[] and then replacing (:) with my update and [] with my base value gives me a fold
12:38:10 <monochrom> what is implicit null constructors?
12:38:18 <acomar_> ReinH: that was exactly what got through to me as well
12:38:29 <acomar_> ReinH: I think there's a nice diagram of that some place...
12:38:36 <ReinH> wikipedia
12:38:44 <ReinH> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
12:38:51 <ParahSailin> i see the following line "data Z;" somewhere, wondering if that is an actual thing
12:39:17 <MedDev> EmptyDataConstrutors
12:39:19 <ReinH> that and an intuition for how foldl and foldr parenthesize
12:39:21 <monochrom> it is an actual thing. but not remotely implicit or null.
12:39:23 <acomar_> ReinH: yea, that's the one
12:39:50 <ReinH> acomar_: so you can get to folds that way, but you can also get there by generalizing fmap
12:39:58 <MedDev> ParahSailin, EmptyDataDecls
12:40:02 <MedDev> that's the one :)
12:40:03 <ParahSailin> MedDev: thanks
12:40:11 <acomar_> ReinH: I'm not familiar with that approach, got a link?
12:40:37 <monochrom> it is, in fact, explicitly lack of constructors
12:41:22 <argiopeweb> Uninhatibed* type, yes?  (* -- except by bottom)
12:41:27 <monochrom> yes
12:41:42 <monochrom> so, it is explicitly uninhabited
12:42:03 <ReinH> acomar_: consider the difference between:
12:42:15 <ReinH> > fmap id [1,2,3]
12:42:15 <lambdabot>   [1,2,3]
12:42:20 <ReinH> > foldr (:) [] [1,2,3]
12:42:21 <lambdabot>   [1,2,3]
12:42:38 <ReinH> fmap and foldr parameterize different parts of the same underlying recursive production
12:43:27 <acomar_> oh, do you just mean the fmap f xs = foldr ((:) . f) [] xs transformation?
12:43:52 <ReinH> acomar_: basically
12:44:47 <acomar_> ReinH: ahh, ok, I thought you were referencing something deeper
12:45:14 <ReinH> it's actually not a generalization of fmap, that's incorrect: it's a parallel specialization of traverse :)
12:45:18 <ifthenelse> carter: What is the name of your future package so I can check it out when it's finished?
12:46:07 <ifthenelse> carter: Assuming it has support for sparse matrices, sparse svd, sparse multiplication, mapping over columns, rows, values, folding, etc. that all the other libraries have?
12:46:44 <carter> ifthenelse: yes
12:47:00 <ifthenelse> cater: It's called "yes"? :)
12:47:30 <carter> nope
12:47:31 <carter> brb
12:50:09 <ReinH> acomar_: the only deeper thing is that you can implement a general recursive function from which you can then implement both fmap and foldr, and implementing that general recursive funciton gives a good intuition about how both fmap and foldr work :)
12:50:14 <monochrom> perhaps the name has not been settled. it's the hardest part of software engineering.
12:50:29 <acomar_> ReinH: ahh, yea
12:51:00 <ReinH> fmap f xs = foldr ((:) . f) [] = go (:) f empty xs
12:52:05 <ReinH> where go f g empty xs yields foldr when g = id and fmap when f = (:) and empty = [] :)
12:52:53 <ReinH> and explicitly writing go out and then comparing to recursive forms you build yourself can help you decide how to use foldr
12:53:02 <ReinH> since your brain will start to find the patterns
12:53:17 <monochrom> what is the type of go?
12:53:32 <ReinH> monochrom: how general do you want it to be? :)
12:53:39 <monochrom> for []
12:53:54 <MedDev> glad i'm not the only one who uses the function names go and step :)
12:54:06 <ReinH> sec
12:55:01 <monochrom> actually, for [] first, then for type constructor F of your choice
12:55:40 <carter> ifthenelse: tentative name : "numerics"
12:55:43 <carter> subject to change
12:55:45 <carter> i'm pretty loud
12:55:47 <carter> so don't worry
12:55:52 <thirsteh> When I'm profiling my own executables, my whole program is only ever "MAIN", and I can't see any of the actual cost centres. How can I see them without splitting every part of my program into different libraries?
12:55:52 <carter> you'll hear about it once its out
12:56:10 <carter> thirsteh: theres -auto-all --caf-all flags or osmething
12:56:19 <carter> check teh ghc manual
12:56:27 <argiopeweb> carter: Isn't if -fauto-all (or somesuch) now?
12:56:31 <carter> no clue
12:56:34 <argiopeweb> -fprof-auto-all
12:56:37 <carter> you'r probably right
12:56:42 <bennofs> Btw, does anyone know what's the difference between -fprof-auto, -auto-all, -fprof-cafs, -auto-cafs ?
12:56:53 <thirsteh> ah, perfect. thank you
12:56:54 <argiopeweb> -auto* are the old ones.
12:56:56 <argiopeweb> They're deprecated.
12:57:08 <bennofs> argiopeweb: thanks
12:57:37 <argiopeweb> thirsteh: bennofs: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/prof-compiler-options.html
12:58:30 <thirsteh> perfect. I was looking at http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/prof-heap.html and thought step #1 was just going to describe -prof :)
12:59:12 <argiopeweb> thirsteh: Nah, that'd be silly. ;)
13:00:45 <keelo> i'm following along with the tutorial here http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/
13:00:53 <ReinH> monochrom: the rather unexciting (b -> c -> c) -> (a -> b) -> c -> [a] -> c
13:00:56 <keelo> and i'm stumped on an error
13:01:04 <keelo>  Couldn't match expected type `Complex'
13:01:04 <keelo>                 with actual type `Float -> Complex'
13:01:19 <keelo> the problem seems to be int he "instance Num Complex" part
13:01:31 <augur> arg
13:01:32 <keelo> where we're making our custom Complex data type an instance of Num
13:01:34 <MedDev> keelo, you have a function expecting another argument (namely a float)
13:01:51 <augur> functional programming has ruined me. i cant think of how to properly write this code using an OO language >|
13:01:53 <augur> damn you haskell!
13:02:05 <Zetetic> Write it functionally
13:02:09 <Zetetic> And ignore the OO
13:02:13 <keelo> MedDev but my declaration is
13:02:14 <keelo> data Complex = C Float Float deriving (Show,Eq)
13:02:23 <keelo> that's two floats.
13:02:36 <keelo> which i'm giving it in the right side of fromInteger
13:02:41 <monoidal> keelo: fromInteger n = C (fromIntegral n,0.0) should be C (fromInteger n) 0.0
13:03:17 <geekosaur> yeh, that's a typo on the web page
13:03:17 <keelo> oh. the first is passing one argument, a tuple?
13:03:25 <MedDev> yup
13:03:38 <keelo> ah :D still getting used to the syntax
13:03:40 <keelo> thanks a bunch guys
13:04:52 <monochrom> ReinH: it looks to me, at this point, go f g empty xs = foldr (\a c -> f (g a) c) empty xs
13:05:21 <MedDev> keelo, this: http://themonadreader.wordpress.com/2012/08/25/issue-20/ was a huge help to me in the beginning.  there's an article called "Understanding basic haskell error messages" it really helps with ghc's sometimes esoteric error messages
13:05:28 <augur> Zetetic: if only :(
13:05:31 <ReinH> monochrom: https://gist.github.com/reinh/ca9efaed7c257b482634
13:06:04 <keelo> MedDev: thank you! yeah, i sort of grokked that i had a curried version of my C constructor
13:06:06 <ReinH> monochrom: it's not at all surprising, but I think writing go explicitly in terms of recusion is a useful intuition pump
13:06:08 <keelo> i just didn't see it in the code
13:06:53 <monochrom> well, then it is pedagogically equivalent to writing foldr explicitly in terms of recursion
13:07:18 <MedDev> keelo, also using ':t' on partially applied functions in ghci is your friend :) it's helped me numerous times
13:07:28 <ReinH> monochrom: yes
13:07:56 <elliott> monochrom: foldr (f . g) empty xs, even
13:08:02 <ReinH> yep
13:08:47 <ReinH> although it does help highlight the fact that f is producive imo
13:08:50 <augur> ReinH: you've been reading dan dennett, i see!
13:08:53 <ReinH> *productive
13:08:58 <ReinH> augur: heh :)
13:09:29 <monochrom> @pl \a c -> f (g a) c
13:09:29 <lambdabot> f . g
13:10:45 <ReinH> also when I do explicit guarded recursion it's usually easier (for me) to get it into this form where I can specify f and g separately
13:10:49 <ReinH> even though they are indeed equivalent
13:11:23 * MedDev agrees
13:11:36 <ReinH> and then it's more obvious for me how to write the fold version
13:11:40 <MedDev> but i'm a newb compared to the wizards here :)
13:12:02 <ReinH> so yeah, it's rather trivial, but I think not completely useless as a pedagogic tool :)
13:13:09 <monochrom> have you seen my http://www.vex.net/~trebla/haskell/scanl.xhtml ?
13:13:14 <ReinH> A lot of my folds are things that combine both fmap and fold behavior: I want to insert a the results of a bunch of calculations into a map, so f = M.insert and g = the calculation
13:13:15 <mstksg> i have noticed that i've reached the point where i take currying for granted and am surprised when other languages don't have it
13:13:51 <ReinH> monochrom: nope :)
13:14:17 <ReinH> monochrom: this looks good
13:14:18 <MedDev> mstksg, if only every language could pass around functions as data :)
13:14:22 <Lethalman> mstksg, not to say partial application
13:14:44 <Lethalman> MedDev, many can, but they are not as convenient
13:14:47 <argiopeweb> Partial application is the main thing I miss. Most languages can pass functions around in some hackneyed way.
13:15:17 <Lethalman> not to say operators... you won't have (.) in most languages
13:15:36 <MedDev> Lethalman, true. I don't want to have to take in the remaining arguments as an array or some mutant 'object' (as per the language spec)
13:15:37 <ReinH> I think there's a marked differencein expressive power between FP langauges with ubiquitous currying/PA and FP langauges without
13:15:57 <mstksg> Lethalman: ah i must be referring to partial application then.  the ability to just call a function with one argument and return a function with one less argument
13:16:01 <ReinH> c.f. all the hackish ways people have tried to add this to JavaScript
13:16:13 <ReinH> mstksg: that's partial application, yes.
13:16:19 <Lethalman> mstksg, same concept in haskell, functions are curried
13:16:29 <ReinH> Although the distinction between currying and PA is usually only important for pedantic arguments on stackoverflow ;)
13:16:47 <ReinH> in practice, where you see one you usually see the other
13:16:59 <MedDev> ReinH, but that's all that gives my life meaning. I need to prove other people wrong on a daily basis or else I don't know I'm right!
13:17:03 <ReinH> MedDev: ;)
13:17:04 * Lethalman prefers saying PA to avoid clash with the curry function
13:17:11 <mstksg> ah. maybe currying refers to the process of turning a "normal" function into one that can be partially applied?
13:17:22 <ReinH> :t curry
13:17:23 <lambdabot> ((a, b) -> c) -> a -> b -> c
13:17:40 <ReinH> curry takes a function of two arguments (2-tuple) and turns it into a function of 1 argument that returns a function of 1 argument :)
13:17:46 <Lethalman> mstksg, currying makes f x y be \x -> \y -> f x y
13:18:14 <Lethalman> therefore partial application is behind the corner
13:18:26 <mstksg> ReinH: I was referring more to the lambda calc/language concept of currying
13:18:37 <ReinH> mstksg: I know, I was just using the haskell function to demonstrate that concept :)
13:18:47 <mstksg> ah, i see :)
13:18:54 * elliott thinks currying-by-default was a mistake. I'm a heretic.
13:19:11 <MedDev> a witch! ;)
13:19:14 <quchen> elliott: What's the alternative?
13:19:18 <erisco> get the tar and feathers!
13:19:28 <ReinH> do witches float in water?
13:19:34 <erisco> lets see
13:19:37 <elliott> quchen: taking products.
13:19:38 <MedDev> what else floats?
13:19:40 <ReinH> what else floats in water?
13:19:41 <mstksg> i don't know, when i specify a function with only its first argument, i expect to get a function with that first argument "assumed".  every time i work in another language now, this bites me
13:19:42 <ReinH> small rocks!
13:19:46 <MedDev> apple cider!
13:19:47 <ReinH> a duck!
13:19:53 <elliott> quchen: wouldn't you love to never have to use (.:) or some such abomination again?
13:20:21 <quchen> elliott: Sure. How would "taking products" work though? That expression doesn't ring a bell
13:21:35 * hackagebot route-generator 0.6 - Utility to generate routes for use with yesod-routes  http://hackage.haskell.org/package/route-generator-0.6 (StephenWeber)
13:21:52 <Lethalman> :t (.:)
13:21:54 <lambdabot>     Not in scope: `.:'
13:21:54 <lambdabot>     Perhaps you meant one of these:
13:21:54 <lambdabot>       `.' (imported from Data.Function),
13:22:03 <quchen> Lethalman: (.:) = fmap . fmap
13:22:06 <Lethalman> ah
13:22:09 <quchen> = fmap fmap fmap ;-)
13:22:25 <elliott> quchen: (a, b) -> c
13:22:28 <Lethalman> well, how can you avoid fmap . fmap anyway even without currying?
13:23:20 <quchen> elliott: That is pretty much what all other languages do, or am I missing something?
13:23:28 <elliott> quchen: some syntax for partial application would be nice, of course. you could borrow the common mathematical notation and say f(x,-) is \y -> f(x,y). then the current `f . map g` becomes `f . map(g,-)`
13:23:29 <quchen> i.e. requiring a list of all parameters
13:23:43 <elliott> sure. I think Haskell probably made the wrong choice here. although the alternative has warts too.
13:23:56 <joelteon> :t fmap fmap fmap
13:23:57 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:24:00 <ReinH> elliott: I would rather have .: in a few places than that syntax everywhere :)
13:24:12 <quchen> elliott:  I find it very practical. In particular, I miss currying when I use Mathematica a lot.
13:24:15 <elliott> "everywhere" is hyperbole. anyway, there are other advantages.
13:24:24 <quchen> But Mathematica is probably not a good example of a functional language.
13:24:34 <ReinH> elliott: everywhere I expect partial application, which is a lot of places
13:24:38 <elliott> for example, writing code in categories where exponentials aren't cheap.
13:24:54 <elliott> or say, imagine a -> that doesn't close over variables in the context.
13:24:58 <elliott> (like a C funptr)
13:25:08 <elliott> then a -> b -> c no longer works, but (a, b) -> c works just fine.
13:25:10 <mstksg> but how will we hold on our point free lusts
13:25:27 <elliott> also, it makes isos/prisms more natural to work with
13:25:29 <mstksg> it wouldn't be as pretty :/
13:25:48 <augustss> Howdy
13:25:50 <augustss> Howdy
13:25:53 <joelteon> hi
13:26:00 <shachaf> hi augustss
13:26:09 <quchen> elliott: Those are pretty specific use cases compared to how useful currying is in everyday programming. But maybe I haven't seen the other side (in Haskell) enough.
13:26:18 <Cale> Hello!
13:26:27 <erisco> Cale, hello!
13:26:34 <erisco> oh wait
13:26:41 * erisco wonders back into the shadows awkwardly
13:27:06 <elliott> quchen: well, I want optics as a language feature. my priorities may not be everyone else's.
13:27:38 <quchen> Optics? Is that yet another functional construct I've never heard of? :-s
13:27:40 * shachaf hopes optics people don't start talking about isomorphisms.
13:27:41 <MedDev> augustss, Yarrr
13:27:43 <quchen> Or is it a lens pun
13:27:51 <shachaf> It means "lenses, prisms, etc."
13:28:07 <elliott> I haven't heard a better term for "everything lens provides and related concepts" than "optics".
13:28:11 <elliott> so I use it.
13:28:15 <augustss> What good is lenses without photons?
13:28:17 * MedDev sees what was done there
13:29:40 <shachaf> augustss: You should invent a meaning for photons!
13:30:10 <quchen> -XFieldTheoreticSemantics
13:30:13 <augustss> I wish I had a lens related idea for a package.
13:30:23 <shachaf> Maybe you'll get ideas in #haskell-lens.
13:30:48 <quchen> augustss: That's fairly easy. The hard part is finding one edwardk didn't think of yet.
13:30:55 <MedDev> :D
13:31:03 <shachaf> You should invent a way to reverse p a (f b) -> p s (f t) lenses. We only know how to do with with p a b -> p s t.
13:31:33 <shachaf> What are our other open lens problems?
13:31:57 <augustss> In general, it's hard to come up with an idea edwardk didn't already implement.
13:32:17 <nooodl> half the enjoyment in inventing lens concepts: thinking up lens-metaphoric names for the concepts you invent
13:32:21 <elliott> shachaf: nice pure profunctor lens traversals?
13:32:43 <shachaf> Oh, yes.
13:32:55 <shachaf> I'd really like to see a solution to that.
13:33:10 <MedDev> i'm always weary to use lenses. what happens if edwardk gets hit by a bus?
13:33:28 <joelteon> there are other maintainers
13:33:28 <quchen> MedDev: The library stops working immediately.
13:33:35 <joelteon> but version 4 won't come out, ever
13:33:41 <shachaf> It's OK, lots of people understand lens.
13:33:48 <MedDev> well he did cut his hair so his guru status is now limited
13:33:50 <elliott> edwardk doesn't do much to lens these days. and there are several people who know enough to take over.
13:34:03 <augustss> Will version 4 have 800 operators?
13:34:10 <elliott> though none of them do any work.
13:34:11 <shachaf> augustss.tibbe.moed++
13:34:36 <MedDev> he should have at least kept a rat tail
13:34:41 <MedDev> preserve some of that power
13:34:50 <tomejaguar> Why is GHC trying to use an old version of hashable?
13:34:57 <joelteon> dependency hell
13:35:01 <tomejaguar> When I have 1.2.1.0 installed?  How does it choose what to use?
13:35:15 <tomejaguar> Can I force it to use 1.2.1.0?
13:35:17 <tibbe> augustss: I think the combination of calling aeson following by sending an email doesn't have an operator yet ;)
13:35:23 <argiopeweb> tomejaguar: It uses what it was compiled with.
13:35:23 <joelteon> tomejaguar: --constraint='hashable installed'
13:35:24 <nooodl> i don't get the "lenses are magic and nobody understands them" thing
13:35:24 <donri> tomejaguar: ghc or ghci or cabal?
13:35:28 <joelteon> then cabal will complain, and you can find out
13:35:46 <tomejaguar> ghc
13:35:52 <joelteon> oh never mind then
13:35:53 <shachaf> When I use lens I hardly use any of the operators. I like names.
13:35:54 <nooodl> then again i don't understand them either. but they don't look *that* crazy
13:36:03 <tibbe> tomejaguar: I think it prefers installed versions
13:36:12 <donri> tomejaguar: ghc is really bad at that, you should use cabal
13:36:19 <tomejaguar> Argh
13:36:26 <shachaf> nooodl: People like mystique.
13:36:29 <tomejaguar> I just want to compile a snippet without setting up cabal and stuff
13:36:35 <augustss> Lenses are magic.  So is Haskell.
13:36:40 <MedDev> shachaf, she can shape shift that's why
13:36:45 <donri> timemage: but, you can do something like -package=hashable-1.2.1.0
13:36:53 <nooodl> maybe it's the operators! too perly
13:36:54 <donri> tomejaguar: ^ that was for you, sorry timemage
13:37:05 <MedDev> augustss, all too often i feel like i'm standing on the shoulders of giants and am afraid of heights ;)
13:37:40 <augustss> MedDev: Keep looking up.
13:37:57 <donri> tomejaguar: you can also ghc-pkg [hide or unregister] hashable-[older version], or, just do cabal init which automates most of it for you
13:38:17 <MedDev> augustss, i do a good southern baptist preacher... soon i will be on THE shoulders of THE LORD himself
13:39:15 * mstksg claps
13:40:18 <n-dolio> Does anyone use the operators in lens?
13:40:41 <n-dolio> I feel like most are there just because there's a naming convention that spits them all out.
13:41:07 <Sonderblade> ~.~
13:41:18 <n-dolio> And there are like, 6-8 that anyone actually uses.
13:41:36 * hackagebot scotty-hastache 0.1.0 - Easy Mustache templating support for Scotty  http://hackage.haskell.org/package/scotty-hastache-0.1.0 (DaniilFrumin)
13:41:37 <augustss> The same 6?
13:41:39 <elliott> I would say there's about 10-15 people actually use.
13:41:55 <n-dolio> Yeah. Used globally I mean.
13:42:01 <elliott> maybe more since ~ vs. =
13:42:35 <elliott> though I think people tend to use one starting with << or whatever once in their life and then forget about it.
13:42:53 <n-dolio> If more are used, it's when people troll through the list looking for one-liners in #haskell-lens.
13:42:59 <tomejaguar> donri: I did cabal init.  It *still* looks for 1.2.0.5 rather than 1.2.1.0 even though I put hashable >= 1.2.1.0 in the cabal file
13:43:03 * tomejaguar confused
13:43:23 <geekosaur> something else depends on 1.2.0.5 then
13:43:26 <MedDev> tomejaguar, edit your .cabal file?
13:43:34 <augustss> Lens is the new Perl.
13:44:37 <elliott> lens would be so much more elegant as part of the language.
13:44:45 <MedDev> augustss, i think it's more like "record syntax blows lets use something else"
13:45:05 <elliott> lens has very little to do with just replacing record syntax.
13:45:20 <augustss> That's how it started.
13:45:23 <elliott> you can use it solely for that but you'll be underwhelmed :)
13:45:47 <elliott> well, data-lens started like that. I think "lens" itself has always had greater ambitions, though I wasn't around for the first few months.
13:47:10 <augustss> I wonder if Benjamin Pierce has seen all the crazy things lenses can do now.  He coined the name.
13:47:18 <argiopeweb> elliott: I have to date primarily used it to replace record syntax and supplement Control.Exception. What would you say is the greater ambition?
13:47:51 <tomejaguar> Ha, so many of my things are compiled against so many different versions.  I need to start using this sandbox thing everyone's talking about.
13:47:53 <elliott> argiopeweb: try composing in some traversals and prisms :)
13:47:59 <elliott> and very powerful control structures start emerging.
13:48:19 <elliott> you can do a lot of data manipulation succintly and make a lot of your "loops" implicit
13:48:38 <n-dolio> Last I heard, he went in a totally different direction based on an incompatible idea of what lenses fundamentally are.
13:48:49 <elliott> especially if you start defining your own lenses to make "virtual" fields, and your own prisms to make "virtual" constructors
13:48:58 <ReinH> elliott: please go on
13:48:59 <elliott> e.g. lens's "base"
13:49:12 <ReinH> elliott: and perhaps write a SoH post about "higher-order lenses" :)
13:49:27 <elliott> I don't know what's higher-order about it. traversals are pretty fundamental :)
13:49:41 <ReinH> elliott: lenses built of other lenses, or lenses into virtual things :)
13:50:11 <ReinH> can you give an example of a virtual constructor prism?
13:50:28 <MedDev> please write the tutorial in a style of "your mother is so lens that lens of lens is true"
13:50:33 <n-dolio> _Left
13:50:36 <argiopeweb> elliott: Fascinating. I'll need to go spend more time reading up on lenses now.
13:50:37 <n-dolio> @type over _Left
13:50:38 <lambdabot> (a -> b) -> Either a c -> Either b c
13:50:49 <elliott> well, _Left isn't very virtual.
13:50:49 <n-dolio> @type isn't _Right
13:50:50 <lambdabot> Either c a -> Bool
13:50:53 <elliott> it corresponds to an actual constructor.
13:50:55 <ReinH> that's virtual?
13:50:59 <ReinH> right
13:51:02 <elliott> but e.g. base, _Cons
13:51:07 <joelteon> @type isn't _Cons
13:51:09 <lambdabot> Cons (Control.Lens.Internal.Prism.Market (a, s) (b, t)) Mutator s t a b => s -> Bool
13:51:10 <Denommus> hi
13:51:33 <MedDev> Denommus, howdy
13:51:35 <elliott> > has (base 16) "8f43"
13:51:38 <elliott> > has (base 16) "q"
13:51:38 <lambdabot>   True
13:51:40 <lambdabot>   False
13:52:02 <ReinH> elliott: huh
13:52:14 <ReinH> Denommus: hi
13:52:17 <Denommus> any Emacs user here? What modes do you use for Haskell development?
13:52:28 <argiopeweb> Denommus: Haskell-mode
13:52:34 <bennofs> Denommus: flycheck + hdevtools + haskell-mode
13:52:39 <elliott> and the exception machinery is a good use of prisms.
13:52:58 <argiopeweb> Denommus: http://www.haskell.org/haskellwiki/Emacs
13:53:04 <n-dolio> In our compiler, we have lenses for when you construct things like 't -> u'.
13:53:05 <bennofs> Does anyone know how to tell cabal to *ignore* a sandbox?
13:53:19 <acomar> move the sandbox?
13:53:26 <acomar> fix .cabal-sandbox?
13:53:31 <chrisdone> put ants in the sandbox
13:53:43 <n-dolio> If u has a forall in it, you want to lift it to the outside. But then you can also match on it by looking at whether all the quantified variables in a forall only appear in u.
13:53:57 <bennofs> hmm, I often test things in a sandbox, but then like to have it installed globally. So renaming is the only way to do that?
13:54:06 <n-dolio> If they do, then the -> prism matches, if they don't it doesn't.
13:54:12 <Denommus> okay
13:54:22 <elliott> n-dolio: that's clever.
13:54:24 <n-dolio> Oops, that first thing should have been prisms.
13:54:48 <elliott> ReinH: basically if you ever wanted to be able to define your own patterns, there's a good chance lens helps you a lot.
13:54:52 <elliott> but it would be much nicer baked into the language.
13:55:03 <ReinH> elliott: what do you mean by "your own patterns"?
13:55:03 <bennofs> view patterns already
13:55:15 <elliott> lens does it nicer than view patterns :)
13:55:43 <elliott> ReinH: like http://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms.
13:55:52 <elliott> but prisms can use much more elaborate logic than the simple stuff there.
13:56:04 <elliott> you can do arbitrary amounts of work to present your view of the data type, like n-dolio's example shows.
13:56:32 <n-dolio> Prisms don't get you very amazing pattern matching syntax, though.
13:56:54 <elliott> essentially the ideal of lens is letting you abstract the mangling and casing you do on data so you can more directly express what you're actually trying to access/modify.
13:57:07 <ReinH> elliott: right, and how would you use these since you can't actually use them as patterns?
13:57:11 <elliott> > [Just (1,2), Nothing, Nothing, Just (3,4), Nothing] ^.. traverse._Just._2
13:57:13 <lambdabot>   [2,4]
13:57:17 <ReinH> or are you just saying that you wish you could use them as patterns?
13:57:35 <elliott> ReinH: well, you can compose them along with your lenses and traversals. you can use them with view patterns by saying (preview (...) -> Just x), etc.
13:57:49 <elliott> it's true that it would be nice to be able to actually pattern match with them; that's why I want language support.
13:57:49 <ReinH> right
13:58:03 <elliott> > [Just (1,2), Nothing, Nothing, Just (3,4), Nothing] ^. traverse._Just._2.to Sum
13:58:04 <lambdabot>   Sum {getSum = 6}
13:58:53 <argiopeweb> I see what you meant about implicit loops.
13:58:59 <argiopeweb> That's very clever.
13:59:03 <ReinH> elliott: is there a way to do this instead:
13:59:14 <ReinH> [Just (1,2), Nothing, Nothing, Just (3,4), Nothing] ^. traverse._Just._2.foldAla Sum --> 6
13:59:30 * MedDev needs more bourbon than this to understand lenses
13:59:31 <ReinH> a lens version of \x -> ala x foldMap
13:59:44 <elliott> :t ala Sum (view ?x) [Just (1,2), Nothing, Nothing, Just (3,4), Nothing]
13:59:46 <lambdabot> (Num t, Num t1, ?x::(([Maybe (t, t1)] -> Sum s) -> Accessor ([Maybe (t, t1)] -> Sum s) ([Maybe (t, t1)] -> Sum s)) -> (s -> Sum s) -> Accessor ([Maybe (t, t1)] -> Sum s) (s -> Sum s)) => s
13:59:51 <elliott> um. maybe.
14:00:05 <elliott> I mean, at the very least you can just & getSum.
14:00:09 <ReinH> right
14:00:21 <elliott> I think there is a way to express what you want but I forgot it. :)
14:00:27 <bennofs> > [Just (1,2), Nothing, Nothing, Just (3,4), Nothing] ^. traverse._Just._2.to Sum
14:00:31 <lambdabot>   Sum {getSum = 6}
14:00:34 <ReinH> elliott: reading ghc type inferences for lenses is the worst thing ever
14:00:37 <Fuuzetsu> Lenses are like a child with burritos: they pick out the ingredients they want and do things to them.
14:00:39 <ReinH> ghc y u no type synonuym
14:00:44 <Fuuzetsu> #burritotutorials
14:00:51 <ReinH> Fuuzetsu: hah
14:01:06 <ReinH> elliott: ok, no worries :)
14:01:19 <elliott> ReinH: yes, that's another reason I want language support.
14:01:26 <elliott> the compiler reports could be so much better.
14:01:50 <ReinH> elliott: I asked edward about it on the podcast and his response was basically "yeah it sucks sorry" ;)
14:02:56 <Eduard_Munteanu> How do you bind multiple type variables with the same kind signature?   forall (a b c :: *)  doesn't work.
14:03:44 <elliott> n-dolio: I forget if we have a nice way of doing exhaustivity checking for prism pattern matching, even in theory.
14:03:55 <elliott> I guess the bokeh stuff probably lets you get about as good as it gets.
14:03:58 <geekosaur> I would expect commas
14:04:02 <geekosaur> at the very least
14:04:19 <bennofs> elliott: do we have bokeh stuff yet?
14:04:23 <ReinH> elliott: wait, bokeh? That's the best/worst lens-related pun ever.
14:04:24 <Eduard_Munteanu> geekosaur: tried that too, doesn't seem to work
14:04:26 <ReinH> what is bokeh?
14:04:36 <Eduard_Munteanu> :k (a :: *)
14:04:36 <geekosaur> since (a b c :: *) is saying that the kind of `a b c` is *
14:04:37 <lambdabot> Not in scope: type variable `a'
14:04:50 <bennofs> ReinH: The unfocused part of a structure, afaik
14:05:05 <Eduard_Munteanu> geekosaur: yeah, that's Agda's notation
14:05:12 <elliott> bennofs: we figured out a way to do the "over exposed" stuff without bokeh.
14:05:17 <elliott> also it'd be horribly ugly in Haskell.
14:05:26 <elliott> so probably lens will never have it unless edwardk goes mad again.
14:05:30 <geekosaur> it is possible that haskell does not have a good shorthand for that
14:05:33 <ReinH> bennofs: of course it is lmao
14:05:48 <geekosaur> kinds are still in many ways second class, despite recent advances
14:06:29 <n-dolio> elliott: I don't know how you'd do it well.
14:06:36 * hackagebot epub-metadata 4.0 - Library for parsing epub document metdata  http://hackage.haskell.org/package/epub-metadata-4.0 (DinoMorelli)
14:07:20 <Fuuzetsu> is bokeh meant to be a cross-lingual pun?
14:08:47 <ReinH> Fuuzetsu: bokeh is a photography term
14:09:04 <ReinH> (in addition to being an actual word in a non-english langauge ;)
14:09:17 <quchen> Although it means something different in that language.
14:09:54 <Fuuzetsu> ReinH: Okay, that kind of makes sense then.
14:10:17 <Fuuzetsu> Soon photographers will be looking for things and only find Edward's library!
14:10:37 <Eduard_Munteanu> I remember there was syntax for declaring a type sig for multiple terms, what was it?
14:10:45 <quchen> Or they will be calling their lenses "type operator" or something.
14:10:53 <bennofs> Eduard_Munteanu: a, b,c :: X -> Y
14:10:55 <Eduard_Munteanu> Ah, thanks.
14:21:37 * hackagebot wai-util 0.4 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.4 (StephenWeber)
14:24:07 <mel-> hi
14:24:23 <mel-> is it currently not possible to edit the Haskell Wiki? I don't have an account yet.
14:24:38 <banister> are string literals 'value constructors'?
14:25:06 <augustss> Sorta
14:26:55 <beefcube> I often find myself wanting the composable generators of quickcheck, but without the rest of quickcheck - is the current alternative just to role your own using System.Random?
14:29:44 <Cale> mel-: You need an account to edit it, from what I recall.
14:29:54 <Cale> mel-: This happened because spammers :(
14:29:56 <beefcube> well, okay, http://hackage.haskell.org/package/rand-vars seems close
14:30:41 <acomar> beefcube: I've just used quickcheck when I've wanted their generators
14:30:47 <acomar> it's not a great solution, but it works
14:30:57 <acomar> I kinda wish they'd split that part off into its own package
14:31:59 <Athan> Hi yall!
14:32:20 <Athan> Is it possible to make pattern matching statements inside a where clause?
14:33:31 <monochrom> yes
14:33:31 <beefcube> Athan: you can create function bindings, that perform pattern matching, within the where clause, if that's what you're asking
14:33:52 <Athan> Yeah, I'm getting some incorrect # of parameters errors
14:34:01 <Athan> here's my code:
14:34:07 <Cale> lpaste.net
14:35:21 <Athan> http://lpaste.net/93209
14:35:45 <Athan> I have no idea why my handler isn't working
14:36:12 <monochrom> string Nothing = "". don't add _ there
14:36:59 <monochrom> err, stringer Nothing = ""
14:41:37 * hackagebot xturtle 0.1.13 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.13 (YoshikuniJujo)
14:43:35 <ReinH> :t fromMaybe
14:43:37 <lambdabot> a -> Maybe a -> a
14:44:45 <ReinH> Athan: also keep in mind the fmap law:  map f . map g = map (f . g)
14:47:03 <Athan> thank you!!!!!!!!!!!!!!!!!!!!!!!!
14:47:43 <ReinH> and that concat . map f = concatMap f
14:48:00 <ReinH> concatMap (renderListElement . fromMaybe "") (liftIO artists)
14:48:12 <osa1> code listed here http://en.wikipedia.org/wiki/Polymorphic_recursion are Haskell 98, right? I didn't know we have Haskell 98 code that has undecidable type.
14:50:20 <monochrom> if this were not a Friday afternoon, I would make you think more clearly by first asking "what do you mean by undecidable type and decidable type"?
14:50:56 <osa1> monochrom: by undecidable I mean "impossible to infer"
14:51:04 <ReinH> that's unpossible!
14:51:11 <osa1> what?
14:51:12 <Athan> Gah, still not working :\
14:51:22 <ReinH> Athan: what is not working?
14:51:32 <hpc> https://www.youtube.com/watch?v=-rMVx2JbztU IMPOSSIMPABLE
14:51:42 <monochrom> well, impossible-to-infer happens a lot. I don't think anyone is surprised.
14:52:03 <tomejaguar> monochrom: I'm surprised
14:52:08 <monochrom> it is possible-to-check that everyone wants.
14:52:12 <tomejaguar> I thought that only happened with type clasess.
14:52:34 <osa1> monochrom: I thought Haskell 98 has a notion called "principal types" or something like that that basically suggests "all types in Haskell 98 expression can be inferred"
14:52:42 <osa1> monochrom: but now I see this is wrong
14:53:09 <ReinH> hpc: the possimpible. I love that guy.
14:53:26 <monochrom> SML bans polymorphic recursion. therefore, you would be right if you were looking at SML
14:53:58 <Athan> Anyone know how to write yesod handlers?
14:54:08 <Clint> many people do
14:54:09 <monochrom> polymorphic recursion isn't used a lot in Haskell (the community), so you are also right about Haskell in practice :)
14:54:15 <Athan> ...or haskell? lol
14:54:36 <Athan> I'm having some trouble with Persistent
14:54:40 <ReinH> Athan: probably. What we don't know how to do is read minds. ;)
14:54:54 <Athan> hahaha
14:54:59 <pavonia> Also, "In Haskell, unlike for most other functions definitions, the type signature cannot be omitted." is wrong (or lacks context)
14:55:02 <ReinH> Athan: the more clearly you can express your problem, the more likely you are to get help :)
14:55:28 <Athan> I'm having trouble matching types correctly
14:55:28 <joelteon> yeah
14:55:32 <Athan> I have my basic idea down
14:55:39 <joelteon> however, in some cases, adding a type signature will make code compile!
14:55:40 <ReinH> Athan: how about a paste with some code and the exception you are getting?
14:55:52 <Athan> I'd like to render a list of html from a sqlite table
14:56:05 <Athan> you got it!
14:56:19 <ReinH> /topic or gist.github.com are fine
14:56:20 <tomejaguar> osa1: I was under the same impression
14:56:36 <ReinH> (as opposed to pasting directly into the channel)
14:56:39 <Athan> http://lpaste.net/93209
14:56:58 <tomejaguar> Maybe it's H-M that has principal types, and Haskell has somewhat more than this.
14:57:17 <osa1> yeah
14:57:24 <Athan> I'm getting a lot of errors:
14:57:41 <ReinH> :t liftIO
14:57:42 <lambdabot> MonadIO m => IO a -> m a
14:58:00 <osa1> HM has principal typing, thats for sure. (I think this is one of the reasons why it's called "sweet-spot" of type systems)
14:58:35 <ReinH> Athan: is one of them perhaps related to the fact that MonadIO is not a list?
15:01:06 <Athan> actually, it's just one now o.o
15:01:25 <monochrom> polymorphic recursion goes outside HM
15:01:30 <ReinH> Athan: add the error to your lpaste :)
15:02:49 <Athan> http://lpaste.net/93209
15:02:58 <Athan> Whaddido?
15:04:52 <Denommus> ok, I'm starting with Haskell, and I don't know how to use the function sortBy
15:05:11 <danharaj> :t sortBy
15:05:12 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:05:48 <danharaj> > sortBy compare [1..12]
15:05:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12]
15:05:58 <danharaj> > sortBy (flip compare) [1..12]
15:05:59 <lambdabot>   [12,11,10,9,8,7,6,5,4,3,2,1]
15:06:07 <Athan> you supply an ordering function to sort!
15:06:19 <danharaj> > sortBy (\x y -> compare x (y^2)) [1..12]
15:06:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12]
15:06:23 <Denommus> yes, like I would in Lisp
15:06:30 <Denommus> the problem is that I get out of scope
15:06:58 <danharaj> It is not in the Prelude. You need to import it from Data.List.
15:07:37 <Athan> is the Entity higher-order datatype kindof like Maybe? (it's in Persistent)
15:07:55 <ReinH> :t concatMap
15:07:56 <lambdabot> (a -> [b]) -> [a] -> [b]
15:08:13 <ReinH> :t Data.Foldable.concatMap
15:08:14 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:08:17 <Denommus> thanks
15:08:48 <ReinH> Athan: your concatMap is trying to operate on the the outer IO when you want it to operate on the inner list
15:09:24 <ReinH> liftIO artists >>= concatMap (renderListElement . stringer)
15:09:31 <mstksg> Athan: not qute; persistent's Entity is just a fancy tuple
15:09:38 <mstksg> with labeled fields
15:10:27 <mstksg> the first is the Key instance and the second is a data type containing the actual 'value'
15:12:06 <ReinH> > fromMaybe "" (Just "foo") -- Athan
15:12:07 <lambdabot>   "foo"
15:12:23 <ReinH> liftIO artists >>= concatMap (renderListElement . fromMaybe "")
15:13:24 <ReinH> Athan: depending on the type of selectList, you might not need to liftIO at all
15:13:32 <ReinH> you might be lifting IO into... IO.
15:14:31 <mstksg> Athan: can you specify the type of what you are expecting from getArtistR
15:14:38 <ReinH> in fact, the type inferrer thinks that's exactly what you're doing.
15:15:38 <mstksg> oh, it's a yesod route
15:16:38 * hackagebot epub-tools 2.3 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.3 (DinoMorelli)
15:17:04 <mstksg> i'm not totally sure why you want Maybe's from selectList
15:17:21 <mstksg> surely you want just a list of artists
15:17:50 <ReinH> mstksg: that too
15:17:55 <ReinH> mstksg: one problem at a time ;)
15:18:07 <mstksg> stringer shoul be stringer = artistName, or whatever record accesses the artist name
15:18:43 <mstksg> er, stringer = artistName . entityVal
15:19:22 <mstksg> entityVal gets the actual artist data instance from the entity, and artistName accesses the name.
15:21:02 <Peaker> forkIO also evaluates the given IO action in the new thread before executing it, right?
15:21:50 <Peaker> i.e: forkIO (putMVar $! expensive)  will evaluate "expensive" expr in the new thread?
15:24:15 <ubikation> hey what's the best way to run a system command and capture the text output of it? rawSystem only captures the exitcode it seems?
15:26:44 <psii> ubikation: I use System.Process.createProcess
15:27:21 <dagano> when pattern matching on a list of tuples can I (x,y,z):rest ?
15:27:34 <dagano> or something of the kind?
15:27:53 <psii> maybe there is something in System.Process.* that fits your needs more
15:28:06 <psii> dagano: yes
15:33:13 <dwcook> dagano, patterns can be nested arbitrarily.
15:34:01 <dwcook> foo (Just (Left "x":_)) = …
15:35:36 <dagano> thx
15:36:12 <dagano> if i have this ugly monster :
15:36:14 <dagano> ((point:[incidents]):cs) (x,y,z)
15:36:40 <dagano> i can nest recursion and get into the incedents one by one?
15:37:03 <dagano> ((point:[i:is]):cs) (x,y,z)
15:37:27 <argiopeweb> ((point:i:is):cs) (x,y,z), I believe.
15:37:41 <argiopeweb> Ah, unless point is [a].
15:37:44 <argiopeweb> My bad.
15:38:04 <dwcook> dagano, keep in mind that [whatever] means a list whose entire contents is whatever
15:38:06 <argiopeweb> Though that does imply that it's a 2-element list.
15:38:07 <dagano> also i mean points,[incedents]
15:38:17 <argiopeweb> Ah, okay.
15:38:27 <argiopeweb> Makes much more sense.
15:38:28 <monochrom> I am very skeptic about [incidents] and [i:is]
15:38:43 <geekosaur> so am I. remember that in a pattern, [] indicates a fixed size list
15:38:45 <dagano> like it doesn't work that way?
15:38:49 <dwcook> Yes, [i:is] has type [[a]], which I'm not sure you meant :P
15:39:05 <geekosaur> and [i:is] is a single element list containing an indefinitely sized list
15:39:08 <monochrom> I don't know what is "that way".
15:39:20 <Cale> (the indefinitely sized list must be nonempty)
15:39:25 <geekosaur> yes
15:39:36 <dagano> ((point,[incidents]):cs) (x,y,z)
15:39:53 <dagano> [(Int,[Int])] (tuple)
15:40:02 <geekosaur> no
15:40:13 <geekosaur> unless that [Int] is always of size 1
15:40:25 <Athan> how do I include the functions that a Persistent model needs in order to access it's data (included in a handler, I mean?)
15:40:27 <dagano> nope
15:40:33 <monochrom> why is it not: (point, incidents):cs
15:40:41 <dagano> why does it have to be of size 1?
15:40:51 <geekosaur> [20 22:38] <geekosaur> so am I. remember that in a pattern, [] indicates a fixed size list
15:40:53 <dwcook> dagano, [incidents] matches a value of type [a], where incidents is the a
15:40:55 <geekosaur> FIXED size
15:41:17 <monochrom> how about I use an example?
15:41:19 <geekosaur> x:xs is a list with a head and an indefinite tail. [x] is a list with a single element which is captured in x
15:41:38 <monochrom> @let monojoy [xs] = xs
15:41:39 <lambdabot>  Defined.
15:41:42 <geekosaur> [x:xs] is a list with a single element; *that element* is itself a list
15:41:53 <monochrom> guess what happens to monojoy [4]?
15:41:54 <dagano> geekosaur: agreed
15:42:20 <dwcook> A non-empty one, specifically
15:42:23 <geekosaur> [x:xs] does not match [4,5], it matches [[4,5]]
15:42:30 <dagano> geekosaur: agreed
15:43:00 <dagano> i'm talking about a list of tuples where the tuple's snd is a list
15:43:03 <dagano> i guess i'm confused
15:43:32 <geekosaur> (and matching a fixed size list in a pattern always makes me think that the fixed size list is a mistake, unless that list is [] (special case) or there are other patterns handing other cases (but even then it's dubious)
15:43:49 <geekosaur> your tuple's snd is a list of lists
15:44:06 <geekosaur> but the outer list has exactly one item
15:44:22 <geekosaur> and if you're doing that, what do you do when it's got zero, or more than one, item?
15:44:34 <dagano> 18:39 < dagano> ((point,[incidents]):cs) (x,y,z)
15:45:01 <geekosaur> that does not answer my question
15:45:02 <dagano> i guess the 's' at the end of incidents is misleading
15:45:07 <dagano> i mean it to be a list of Int
15:45:21 <geekosaur> it is a list, with exactly ONE item
15:45:24 <Cale> incidents can have any type in that pattern
15:45:32 <geekosaur> if so, why is it only one item
15:45:37 <geekosaur> ?
15:45:46 <Cale> [incidents] must be a list with one element, whose value is bound to incidents
15:45:52 <Athan> Anyone here have success with persistent?
15:46:20 <mstksg> Athan: what's your question?
15:46:25 <dagano> I don't understand why it has to have one item
15:46:34 <mstksg> you can just import Database.Persistent.Postgresql or what ever handler you are using
15:46:34 <dagano> i can have a tuple (a,b)
15:46:36 <geekosaur> because you used [] around [incidents]
15:46:38 <dwcook> dagano, because that's what [a] means for any pattern a
15:46:38 <Athan> How do I include the functions described in /config/models in a yesod handler?
15:46:52 <Cale> dagano: because [5] for example, is a list with one element
15:46:57 <geekosaur> that matches a list with exactly one item
15:47:02 <mstksg> *backend
15:47:03 <dagano> AH!
15:47:04 <Cale> If you wanted a list with two elements, you might use [x,y]
15:47:14 <Cale> (exactly two elements)
15:47:29 <dagano> so I can have a type (Int,[Int])
15:47:32 <dagano> but when pattern matching
15:47:49 <dagano> I can't just say : (a,[b])
15:47:56 <Cale> You *can* say that
15:48:07 <geekosaur> you can say that but it does not mean what you probably intend
15:48:07 <dwcook> > let length [] = 0; length [_] = 1; length [_, _] = 2; length (x:xs) = 1 + length in map length [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]
15:48:08 <Cale> but that will only match in the case that the list has exactly one element
15:48:08 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [t0] -> a0
15:48:11 <dwcook> Woops
15:48:21 <dwcook> > let length [] = 0; length [_] = 1; length [_, _] = 2; length (x:xs) = 1 + length xs in map length [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]
15:48:23 <lambdabot>   [0,1,2,3,4]
15:48:26 <mstksg> well, (Int,[Int]) can be realzed as (a,b) ... where a :: Int and b :: [Int]
15:49:02 <mstksg> if you had (a,[b]), a :: Int and b :: Int, which isn't what you want
15:50:22 <ReinH> Oh good news. Latest libtcod doesn't build on OS X
15:50:24 <ReinH> :(
15:51:18 <Hari`> hello
15:51:21 <jgross> Say I want to have [|\x y -> x y True|] be intepreted as (ELambda "x" (ELambda "y" (EApp (EApp (EVar "x") (EVar "y")) (EPrim (PBool True)))), can I do this with template haskell, and, if so, is there a tutorial somewhere I can look at to do this?
15:51:30 <ReinH> dwcook: monoid homomorphisms ftw :)
15:51:39 * hackagebot LambdaHack 0.2.8 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.8 (MikolajKonarski)
15:51:54 <dwcook> ReinH, sorry, I'm not sure what I said that relates to that.
15:52:17 <ReinH> length is a monoid homomorphism of the free monoid
15:52:30 <ReinH> to the sum monoid
15:52:40 <geekosaur> dagano: it might be better to pretend that [] list syntax doesn't exist for a while. it's syntactic sugar; lists are *actually* in : syntax. item:item:item:[] with that final [] representing the end of the list. (If you're familiar with Lisp, you might recognize this as cons syntax with : as infix cons and [] as nil. Which is exactly what it is.)
15:52:54 <shachaf> sum monoids are better than others.
15:53:24 <ReinH> shachaf: :p
15:53:44 <geekosaur> [] list syntax is handy in normal code but behaves unintuitively in patterns because of the fact that it hides the final [] and therefore it's ALWAYS matched while matching the list
15:53:54 <dwcook> ReinH, you mean to the monoid (Z, +)?
15:54:00 <dagano> geekosaur: yeah . i am aware of that.. it just doesn't often filter into my thinking
15:54:03 <geekosaur> [x] is (x:[])
15:54:16 <geekosaur> [x,y] is (x:y:[])
15:54:20 <shachaf> It's not exactly hidden
15:54:24 <geekosaur> both in normal code and in patterns
15:54:39 <ReinH> dwcook: sure
15:54:42 <geekosaur> but in patterns it's easy to overlook that it's always sticking that final :[] in there
15:54:48 <dagano> so if i want to pattern match on some (Int, [Int]) which is the head of a [(Int,[Int])]
15:54:51 <hpc> shachaf: hidden from inattentive people
15:54:54 <dwcook> Oh, I see what you mean.
15:55:00 <ReinH> dwcook: or to [()]
15:55:05 <shachaf> Well, I mean that it's the same in patterns and expressions.
15:55:10 <dwcook> So, (N, +)?
15:55:37 <ReinH> N including 0, yes :)
15:55:48 <dwcook> Yeah, sorry, I just assume N includes zero most of the time
15:55:55 <ReinH> just clarifying
15:57:57 <ReinH> dwcook: another way to say this is that (N,+) is a free monoid on a singleton free generator, the number 1
15:58:09 <monochrom> dagano: (x, ys):more?  x::Int, ys::[Int], more :: [ (Int, [Int]) ]
15:58:22 <dwcook> ReinH, up to isomorphism, you mean?
15:58:25 <Athan> Do I need to do anything special with Persistent to make it work with yesod handlers?
15:58:29 <Athan> from it's scaffold?
15:58:41 <ReinH> dwcook: yes
15:59:04 <ReinH> where this monoid consists of all sequences like "1", "1+1", etc including "" and mapping each sequence to its evaluation result (and "" to 0) establishes this isomorphism
15:59:16 <dwcook> Sounds legit
15:59:17 <dagano> monochrom: yeah i think i get it . that looks good
15:59:24 <ReinH> dwcook: it's totally legit ;)
15:59:44 <ReinH> dwcook: also I'm just looking for opportunities to use my new math chops :)
15:59:50 <dwcook> \o/
15:59:52 <dagano> > fst (1,2)
15:59:53 <lambdabot>   1
15:59:58 <ReinH> \o/
16:00:17 <monochrom> do not throw in [] just because "I expect a list". that's Prolog's mistake.
16:00:22 <dwcook> I think last I attempted any abstract mathematics, I was struggling to figure out adjunctions
16:00:41 <dwcook> Well, besides the everyday stuff involved in programming, of course
16:00:52 <dwcook> Like moe-nahds
16:01:58 <monochrom> dwcook: do you want to figure out both IO and pushouts at the same time? http://www.vex.net/~trebla/photo/unorganized/IO-String.png hehe
16:02:02 <johnw> dwcook: how far did you get with adjunctions?
16:02:29 <dwcook> monochrom, well, I can't say I figured out much from that diagram. :)
16:02:52 <ReinH> all I know is that a free functor is left-adjoin to a forgetful functor
16:02:52 <dwcook> johnw, that they are pairs of functors, basically. :P
16:02:56 <ReinH> *adjoint
16:03:20 <NickeNyfiken42> Hi, yesterday ReinH was kind and directed me to Async / waitAnyCancel regarding how to let two processor cores race to e.g. find a prime number. Now I don't understand how to deal with the IO stuff of async
16:03:54 <ReinH> NickeNyfiken42: the IO stuff basically means that you have to run it inside the io monad, which means io actions produced by async stuff at some point have to be evaluated in main so that they can be performed
16:03:55 <Umbrall> Just wondering. Has anyone made a Void functor?
16:04:07 <dwcook> Isn't Void a concrete type?
16:04:11 <dwcook> (kind *)
16:04:12 <ReinH> Umbrall: sounds like a particularly forgetful functor ;)
16:04:17 <Umbrall> well I mean something like data Vacuum a
16:04:29 <Umbrall> I believe it's a valid functor, applicative and comonad
16:04:49 <shachaf> It is.
16:05:05 <dagano> > [1,2] : [3,4]
16:05:06 <lambdabot>   No instance for (GHC.Show.Show t0)
16:05:06 <lambdabot>    arising from a use of `M1626267895.sh...
16:05:08 <shachaf> Er, no.
16:05:10 <shachaf> Not Applicative.
16:05:11 <dagano> thought not
16:05:15 <shachaf> But it's a functor and a comonad.
16:05:25 <dagano> :t join
16:05:26 <lambdabot> Monad m => m (m a) -> m a
16:05:27 <Umbrall> Why can't it be applicative?
16:05:34 <shachaf> That's left as an exercise.
16:05:43 <Umbrall> V (a -> b) -> V a -> V b
16:05:47 <joelteon> I wonder if anybody's written a shell in haskell
16:05:53 <shachaf> @src Applicative
16:05:53 <lambdabot> class Functor f => Applicative f where
16:05:54 <lambdabot>     pure  :: a -> f a
16:05:54 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:06:05 <NickeNyfiken42> ReinH: If I just do "do  <newline>  w1 <- async (searchPrime startValue)" it complains since searchPrime returns an integer
16:06:07 <Umbrall> oh duh pure
16:06:11 <Umbrall> forgot about that
16:06:11 <ion> ſmap :: (m -> n) -> m a -> n a; ſmap _ getLine :: Maybe String
16:06:17 <chrisdone> any competent vim users here?
16:06:20 <dwcook> I'm actually not seeing why pure is a problem there
16:06:22 <joelteon> yes
16:06:22 <ReinH> chrisdone: yes
16:06:24 <joelteon> i am competent
16:06:26 <joelteon> hopefully
16:06:27 <Umbrall> Write a -> Void then
16:06:55 <dwcook> Oh, duh, the type is "uninhabited"
16:07:17 <dwcook> So I can't write a function to give you one
16:07:27 <chrisdone> ReinH: can you have a file in vim for some project directory that specifies a variable like "project ID" that vim will be able to associate with any file buffer opened automatically?
16:08:00 <ReinH> NickeNyfiken42: main = do; asyncAction <- async doStuff; -- now you have access to asyncAction, which is an Async of whatever IO doStuff does
16:08:29 <ReinH> chrisdone: automatically? no
16:08:41 <chrisdone> ReinH: is it possible?
16:08:44 <ReinH> you have to have some way of defining "project directory", which is not a concept vim understands natively
16:08:54 <chrisdone> hmm
16:09:05 <ReinH> if you can detect the root, like for instance by the presence of a *.cabal file, you can do stuff based on that
16:09:12 <chrisdone> ideally you would open a file and it would search from that file's directory upwards until it finds a ".project" file or w/e and read in the variables from that
16:09:13 <mstksg> not too hard to write a simple vimscript plugin, though
16:09:14 <ReinH> like set variables
16:09:22 <NickeNyfiken42> ReinH: Thanks, I'll give it a shot
16:09:25 <ReinH> NickeNyfiken42: np
16:09:30 <dagano> :t notElem
16:09:31 <lambdabot> Eq a => a -> [a] -> Bool
16:09:37 <chrisdone> so it's easily doable then. that's good
16:09:39 <dagano> @info notElem
16:09:40 <lambdabot> notElem
16:09:40 <ReinH> chrisdone: check out http://www.vim.org/scripts/script.php?script_id=441
16:09:47 <ReinH> should give you a framework for doing this
16:09:50 <copumpkin> dagano: it's not . elem, except better
16:09:54 <ReinH> er https://github.com/embear/vim-localvimrc
16:10:00 <dagano> copumpkin: where is it defined?
16:10:04 <copumpkin> Data.List, I'd guess
16:10:18 <ReinH> chrisdone: specifically https://github.com/embear/vim-localvimrc/blob/master/plugin/localvimrc.vim#L116
16:10:31 <ReinH> and please don't look directly into the vimscript for your own safety
16:10:58 <chrisdone> ReinH: cool that sounds good enough. we're implementing a cabal package for interfacing with the fp complete IDE from emacs and vim. i'm an emacser, don't know vim, but want to know that that is possible so that your local file system can be associated with an fp complete project id
16:11:10 <Umbrall> what word would be left to name Vacuum a -> b though?
16:11:20 <Umbrall> when vacuous is used up
16:11:40 <ReinH> chrisdone: you can have a project-local .fpcomplete, sure
16:11:56 <ReinH> the recursive search is ridiculously verbose because vimscript but not particularly complex
16:12:34 <ReinH> chrisdone: you might consider using python or ruby bindings though
16:12:58 <ReinH> because vimscript is literally the worst programming language I have ever used in anger
16:13:25 <ReinH> chrisdone: also #vim is full of people who know more about vim than me :)
16:13:39 <chrisdone> awesome
16:13:52 <NickeNyfiken42> ReinH: What's the requirements on doStuff? I keep getting a   Couldn't match expected type `IO t1' with actual type `Int'
16:13:53 <chrisdone> sure but it's relevant to haskellers so i thought i'd ask here, and you guys are friendly =]
16:14:01 <ReinH> NickeNyfiken42: doStuff has to be an io action
16:14:23 <ReinH> NickeNyfiken42: you should read the async chapter in parallel & concurrent haskell :)
16:14:38 <NickeNyfiken42> so if I have a function f that  is what I really want to call ... what's the missing link between f and doStuff?
16:14:49 <NickeNyfiken42> Ok, fair enough -- I'll try and read it
16:14:56 <dagano> > filter (/=3 . fst) [(1,33),(2,44),(3,99)]
16:14:57 <lambdabot>   Couldn't match expected type `(b0, b1) -> c0'
16:14:57 <lambdabot>              with actual type...
16:15:07 <dwcook> What's the closest you can get to an empty function?
16:15:28 <chrisdone> lol
16:15:42 <chrisdone> ace question
16:15:49 <dagano> > filter (\(a,_) -> a /= 3) [(1,33),(2,44),(3,99)]
16:15:50 <lambdabot>   [(1,33),(2,44)]
16:16:07 <chrisdone> dwcook: that's such a weird question. what prompted it?
16:16:11 <chrisdone> :D
16:16:22 <dwcook> chrisdone, the discussion of "uninhabited" types above
16:16:42 <Umbrall> There's not really an empty function
16:16:43 <elliott> you can write (\case {}) in new enough GHCs.
16:16:59 <chrisdone> > let in ()
16:17:00 <lambdabot>   ()
16:17:04 <Umbrall> I wrote my function with = a where a = a
16:17:05 <johnw> foo _ = Void?
16:17:09 <ion> monochrom: type family Foo a :: * -> *; type instance Foo (IO String) = IO
16:17:13 <Umbrall> Void doesn't have a constructor you can use
16:17:20 <johnw> foo _ = absurd?
16:17:23 <dwcook> Apparently mine isn't new enough.
16:17:28 <johnw> just means you can never call foo
16:17:32 <elliott> again, you can write (\case {}) in new enough GHCs. precisely because there are no constructors
16:17:41 <elliott> :: Void -> a
16:17:45 <Umbrall> yeah with absurd there it's a -> Void -> b
16:17:50 <Umbrall> with that one
16:18:13 <Umbrall> basically there's Void -> Void which can be written several ways, Void -> a which is the unique function absurd, a -> () which == a
16:18:17 <Umbrall> as 'empty' functions
16:18:39 <dwcook> @src absurd
16:18:39 <lambdabot> Source not found. Are you typing with your feet?
16:18:39 <elliott> I'm confused.
16:18:44 <Umbrall> though there's only one valid Void -> Void function
16:19:00 <Umbrall> I'm looking at it now absurd's source is weird
16:19:01 <shachaf> Except in Haskell, where there are two.
16:19:05 <Umbrall> http://hackage.haskell.org/packages/archive/void/0.5.10/doc/html/src/Data-Void.html
16:19:12 <Umbrall> that are mathematically the same
16:19:14 <Umbrall> or should be
16:19:18 <Umbrall> well
16:19:22 <Umbrall> it's not really well-defined
16:19:34 <Umbrall> so I'm not sure if there can be two or can't or whether they are the same
16:19:40 <nooodl> wow (\case {}) looks like LaTeX syntax
16:19:53 <dwcook> What the heck? Why is absurd that?
16:20:26 <Cale> Personally I think lambdacase should have just been case sections. i.e. you leave out the scrutinee and apart from that the syntax is the same as ordinary case.
16:20:28 <Umbrall> I have no idea, that's with data Void = Void Void btw
16:20:42 <Umbrall> which technically could be constructed
16:20:57 <Cale> data Void = Void !Void rather
16:20:59 <dwcook> Void undefined
16:21:02 <dwcook> Oh
16:21:48 <ReinH> elliott: can I use something like filtered for this?
16:21:51 <ReinH> > filter ((/=3).(^._1)) [(3::Int,20), (4,0)]
16:21:53 <lambdabot>   [(4,0)]
16:22:33 <elliott> um, maybe.
16:22:36 <elliott> not sure.
16:23:11 <ReinH> I figured there would be a simpler way to make predicates out of lenses
16:24:23 <shachaf> You could say view (_1 . to (/=3))
16:25:23 <Umbrall> still don't know a great name for the version of absurd for this Void functor
16:27:58 <ReinH> > filter (^._1.to (/=3)) [(3,20), (4,0)]
16:27:59 <lambdabot>   [(4,0)]
16:28:06 <ReinH> shachaf: what is filtered for?
16:28:25 <Peaker> Is using Data.Vector.cons recursively to build a Vector sane? (I'm looking at some benchmark code, and quite puzzled to see this)
16:29:07 <copumpkin> no?
16:31:11 <ReinH> shachaf: you could define an kind of nice operator
16:31:13 <ReinH> > let (./=) l = views l . (/=) in filter (_1 ./= 3) [(3,20), (4, 10)]
16:31:15 <lambdabot>   [(4,10)]
16:31:30 <chrisdone> hmm
16:31:32 <joelteon> do you guys put language extensions on the same line or separate lines?
16:31:52 <ReinH> joelteon: I'm probably weird but I use a single comment per extension, one per line
16:32:01 <chrisdone> i put them on separte lines because my emacs adds new ones automatically
16:32:11 <joelteon> well, I might as well look like an emacs user
16:32:19 <ReinH> chrisdone: how does it add new ones automatically?
16:32:46 <joelteon> i would love to automatically add new ones
16:32:46 <chrisdone> when ghc suggests them it says "add FlexibleInstances (y/n)?" and i hit y and it adds it
16:33:13 <ReinH> chrisdone: that's nice, the closest I get is _lang gives me a list with autocomplete
16:33:31 <ReinH> I keep wanting to pick up emacs again for haskell integration
16:34:06 <chrisdone> =)
16:34:17 <elliott> I use vim! so does edwardk.
16:35:16 * haasn wants the edwardk plugin for his editor
16:35:17 <ReinH> confirm
16:35:34 <ReinH> I mean, I've been using vim for about a decade and I'm pretty happy
16:35:36 <chrisdone> it also prompts to remove imports i'm not using, but i don't have anything to _add_ imports automatiaclly, sadly =p
16:35:38 <Peaker> changing it to use a length/List pair made it worse, hmm
16:35:38 <ReinH> but emacs has some nice stuff
16:36:17 <donri> chrisdone: there's one or two new packages for managing imports i've been meaning to try
16:36:28 <chrisdone> yeah i saw one by one of the dutch folk
16:37:06 <chrisdone> hmmm
16:37:28 <donri> chrisdone: btw do you actually use structure-mode daily or is it still an experiment?
16:37:36 <donri> or whatever you're calling it :p
16:37:39 <chrisdone> i use it daily yeah
16:38:11 <chrisdone> it's still experimental so sometimes it acts like an idiot or annoys me, but it's always enabled
16:38:33 <ReinH> chrisdone: haskellmode-vim has a few nice features
16:38:45 <chrisdone> what stuff?
16:38:48 <Peaker> interestingly, Vector.cons outperforms (:) in this case, maybe it's a small enough list, or maybe because it's being re-traversed multiple times
16:38:53 <ReinH> chrisdone: emacs might have some of these, but
16:39:01 <donri> haskellmode.vim is kind of crap
16:39:23 <ReinH> _ie will make an import explicit by parsing the 'not in scope' errors for removing the module
16:39:30 <ReinH> donri: but there's nothing better :/
16:40:03 <chrisdone> that's cool
16:40:22 <ReinH> _i will give me a list of imports that provide the current identifier
16:40:36 <chrisdone> by doing the same operation?
16:40:38 <donri> oh that sounds interesting, i should try it again
16:41:13 <chrisdone> yeah i don't have that in emacs
16:41:13 <ReinH> so _i with cursor on toList and selecting Data.Set will add Data.Set(toList) to imports
16:41:40 * hackagebot unexceptionalio 0.1.0 - IO without any non-error, synchronous exceptions  http://hackage.haskell.org/package/unexceptionalio-0.1.0 (StephenWeber)
16:41:50 <chrisdone> how does it do that?
16:42:26 <ReinH> chrisdone: searches your hackage index iinm
16:42:37 <ReinH> it won't merge multiples, unfortunately
16:42:40 <chrisdone> hackage index?
16:42:43 <ReinH> er
16:42:47 <ReinH> haddock index
16:42:52 <chrisdone> ahh
16:43:02 <chrisdone> hm, good point. i could implement that with haskell-docs
16:43:15 <chrisdone> could patch it to search modules
16:43:27 <chrisdone> does it have a tool that does it?
16:43:50 <chrisdone> or is it reading the HTML files with grep or something?
16:44:04 <Peaker> https://github.com/Peaker/Levgen-Parallel-Benchmarks/blob/master/H.hs <-- 50% slower than the best solutions in C++/etc measured at http://togototo.wordpress.com/
16:44:32 <Peaker> I thought the V.cons part was an obvious place to optimize, or the use of Strings, but neither actually help
16:45:10 <ReinH> chrisdone: I don't know.
16:45:20 <ReinH> chrisdone: it also makes gf (goto file under cursor) understand local modules
16:45:21 <chrisdone> funny, i never considered how trivial it would be to parse the haddock index
16:45:29 <joelteon> ReinH: what plugin is that?
16:45:36 <ReinH> joelteon: haskellmode-vim
16:45:41 <joelteon> i gotta try that
16:45:48 <ReinH> http://projects.haskell.org/haskellmode-vim/screencasts.html
16:45:51 <joelteon> I hate going back up and adding to my import list again
16:46:35 <ReinH> yeah, it's really nice to add the unqualified identifier you want and then use _i to insert the import statement
16:46:40 * hackagebot Allure 0.4.8 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.8 (MikolajKonarski)
16:46:49 <chrisdone> ReinH: that i do have in emacs. ct for type, ci info, g. for jump to definition
16:47:18 <ReinH> there's also a nice in-memory ctags-based tag browser that I sometimes use
16:47:22 <ReinH> also ctags is generally awesome
16:47:31 <chrisdone> yeah etags is cool too
16:47:36 <ReinH> confirm
16:48:03 <chrisdone> one feature i use a lot these days that i never did in the past is seeing a list of call sites
16:48:36 <chrisdone> but you can get that by ack/grepping the codebase. it's just nice to be able to "jump" between them
16:48:43 <Athan> Anyone else hate ExitFailure1?
16:48:53 <chrisdone> you mean
16:48:55 <joelteon> sorta
16:49:17 <chrisdone> Cabal: "X failed to install. The error was ExitFailure"
16:49:18 <chrisdone> You: "uh, great?"
16:50:14 <dwcook> At least it wasn't SomewhereInTheMiddleFailure?
16:50:40 <chrisdone> technically that's usually what it is
16:50:40 <dwcook> (That would imply it failed and then kept going)
16:51:04 <chrisdone> ExitFailure doesn't mean "failed at exiting", means "exiting due to failure"
16:51:24 <dwcook> Ah, I see
16:51:32 <chrisdone> yeah, useless right =)
16:51:32 <ReinH> chrisdone: vim has [I
16:51:57 <chrisdone> ReinH: protip: when talking to emacs users about vim commands, just say what they do, we can't read yours anymore than you can read ours =p
16:52:31 <ReinH> chrisdone: lmao
16:52:42 <joelteon> ReinH: wow, haskellmode is amazing
16:52:55 <ReinH> [I displays all lines that contain the keyword under the cursor, with file and line number
16:53:00 <ReinH> joelteon: it's pretty good :)
16:53:00 <Hodapp> M-x spook
16:53:27 <chrisdone> ReinH: ah, gotcha. yeah, in emacs i type g,
16:54:14 <chrisdone> i must learn the secret of haskellmode-vim's haddock index searching
16:55:44 <chrisdone> oh yeahhh
16:55:55 <chrisdone> it's so dirty. dirty vimscript code
16:56:01 <chrisdone> i love it
16:56:22 <chrisdone> regexes on html
16:56:24 <chrisdone> mmmm
16:56:29 <donri> ahaha
16:56:42 <ion> nice
16:57:01 <ReinH> chrisdone: :D :D
16:57:12 <ReinH> chrisdone: don't ever expect vimscript to be pretty and you will never be surprised
16:57:23 <chrisdone> still, it works! technically even hoogle parses the html of haddock so we're all contaminated
16:57:27 <ReinH> :D
16:57:46 <ReinH> chrisdone: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
16:57:51 <chrisdone> =p
16:58:02 <chrisdone> i know what that post is gonna be
16:58:09 <ReinH> you do
16:58:16 <ReinH> best. answer. ever.
16:58:30 <ReinH> "This post has been locked while disputes about its content are being resolved."
16:58:31 <chrisdone> (」ﾟoﾟ)」 HE COMES
16:58:33 <ReinH> lmao
16:58:44 <tassni> Does anyone know of a way to create a Data.Map keyed by String to arbitrary functions (i.e. unlike types) in a safe way?
16:59:14 <Dodek> tassni: how would you want to use it?
16:59:15 <chrisdone> ummm, for a limited definition of arbitrary, you could use Data.Dynamic
16:59:32 <chrisdone> speaking of that, i was going to ask that in here too
16:59:46 <tassni> It's for a small interpreter where I want to define a bunch of builtin functions written in Haskell instead of the interpreter language.
16:59:50 <Peaker> this sounds inherently unsafe (at least in Haskell when we can't index the type of Data.Map on the strings to guarantee what differing types are mapped to each str)
16:59:51 <ReinH> The short answer is that you can't and probably don't want to do that
17:00:29 <tassni> I know the # of arguments and types at execution time of the interpreter, and I could just hardcode everything but it ends up being a ton of boilerplate and kind of inextensible.
17:00:42 <chrisdone> well, typeable can do it typesafely, but you need to limit your arity and typity (yeah, that's a word, shutup)
17:01:11 <ReinH> and if typeable can't do it, you can just make a non-compliant instance of typeable and do whatever the hell you want ;)
17:01:13 <chrisdone> tassni: then Data.Dynamic is for you
17:01:20 <tassni> I know the arity and the types are all simple 1:1 mappings to machine types.
17:01:25 <tassni> Double, Int, etc
17:01:34 <chrisdone> :t toDyn -- (wonder if this is in lambadbot?)
17:01:35 <lambdabot> Typeable a => a -> Dynamic
17:02:10 <tassni> What would be the Typeable instance?
17:02:12 <chrisdone> :t fromDynamic (toDyn (\() -> "Hej!"))
17:02:13 <lambdabot> Typeable a => Maybe a
17:02:19 <joelteon> i like the syntax highlighting of vim2hs better :/
17:02:33 <chrisdone> tassni: well if your function is
17:02:44 <chrisdone> :t \() -> "Hej!"
17:02:45 <lambdabot> () -> [Char]
17:02:54 <chrisdone> then that's your instance
17:03:20 <chrisdone> > case fromDynamic (toDyn (\() -> "Hej!")) of Nothing -> "oh noes"; Just f -> f ()
17:03:21 <lambdabot>   "Hej!"
17:03:23 <tassni> chrisdone: oh I see
17:03:58 <Peaker> existential types directly are nicer than Dynamic I think
17:04:15 <copumpkin> preflex: seen augustss
17:04:15 <preflex>  augustss was last seen on #haskell 2 hours, 39 minutes and 8 seconds ago, saying: Sorta
17:04:23 <chrisdone> yeah, existentials would be like this: http://chrisdone.com/posts/generic-map
17:04:55 <chrisdone> Peaker: but somehow i recall Dynamic is more efficient, but i don't recall why
17:05:09 <ReinH> chrisdone: I think I just threw up in my mouth a little bit :)
17:05:35 <chrisdone> ah, because Dynamic stores the TypeRep and does unsafeCoerce directly
17:05:39 <joelteon> would you make NoImplicitPrelude a project-wide extension, or put it in a pragma for each file?
17:05:49 <copumpkin> I always liked the HMap :: (* -> *) -> *
17:05:50 <chrisdone> whereas the existential is keeping a dictionary around, i guess
17:05:52 <elliott> chrisdone: but an existential would store the TypeRep and do guarded unsafeCoerce too.
17:06:00 <elliott> I guess the TypeRep would be hidden behind a lambda, but...
17:06:05 <chrisdone> i guess it's equivalent, not sure which is more efficient
17:06:13 <elliott> I hear it's actually faster or something though? but I don't see why.
17:06:50 <tassni> efficiency is not all that important for my case, more just trying to find a semi-safe way so that I don't have to hardcode every builtin in a giant pattern match loop
17:06:52 <chrisdone> tassni: but if you don't care much, Dynamic is already there, so ja
17:07:12 <chrisdone> ReinH: you don't like existentials or Dynamic? =)
17:07:31 <chrisdone> elliott: are you familiar with Data.Reflection?
17:08:05 <tassni> chrisdone: I have to go try them first, didn't know about the Dynamic trick until just now. Thanks for the hints!
17:08:12 <chrisdone> sure!
17:08:17 <elliott> chrisdone: I should hope so, I've worked on it :)
17:10:05 <chrisdone> elliott: i'm wondering if the nice trick used in reify is helpful for a task i'm trying to do. i want to store an arbitrary function in an opaque type, like dynamic, but i want to also store any and all class constraints, too. so if i put print in there, i can get print back and use that function on () or Int or w/e
17:10:55 <elliott> chrisdone: hmm, I'm not quite sure what the types would look like here?
17:11:12 <chrisdone> the trick that reify says Reifies s a | s -> a and then a -> (forall s. Reifies s a -> …) is a clever way to provide a "witness" or the a where maybe you only care about the 's' as a dictionary, if i'm reading it right
17:11:33 <chrisdone> elliott: i'm not sure either. not sure it's possible. i'm wondering if some class or implicitparams tricks are possible
17:13:36 <acowley> I wish something cool happened why I accidentally type threadDealy
17:13:54 <chrisdone> elliott: the problem with doing function update for arbitrary IO actions in GHCi via a ghc plugin is that you can't generate new names like foo :: IO () and foo_ref :: IORef (IO ()), you can only transform… but you can possibly have one big table like IORef (Map Name Dynamic) and then update the definitions like that, but if you have `print' then you can't put that in/get from a Dynamic
17:15:02 <elliott> chrisdone: just use Any and unsafeCoerce?
17:15:06 <chrisdone> i *could* generate a new existential type for every function in the module with TH and then use that for update, but then you've gotta shove a TH call in all your modules that you want update for
17:15:21 <chrisdone> elliott: hmmmm. i'm not sure GHC will let you get past the constraint
17:15:24 <chrisdone> e.g.
17:16:01 <chrisdone> :t unsafeCoerce -- this in scope?
17:16:02 <lambdabot> Not in scope: `unsafeCoerce'
17:16:24 <elliott> of course it's not in scope, are you mad? :P
17:16:31 <chrisdone> just for type info, why not? =)
17:16:37 <elliott> it'd be in scope for values too.
17:16:39 <elliott> anyway, do you have an example?
17:16:42 <chrisdone> anyway, (unsafeCoerce print) :: () <- ghc won't accept this
17:16:43 <elliott> I might be misunderstanding the problem.
17:16:52 <chrisdone> ghci will, because ghci defaults print's first arg to ()
17:17:03 <elliott> why do you ever have to do that though?
17:17:06 <elliott> print isn't an IO action, for one :)
17:17:22 <enthropy> you could turn on -XExtendedDefaultRules
17:17:23 <chrisdone> sure, it's a function to an IO action, but i want to be able to update those
17:17:52 <chrisdone> if i can only update IO x values, that'd be pretty lame
17:18:12 <chrisdone> any ideas?
17:18:16 <enthropy> maybe you can have a hlist of your functions
17:18:21 <enthropy> how to store it is another problem
17:18:26 <chrisdone> hmmmmm
17:18:48 <chrisdone> interesting
17:19:33 <chrisdone> storing it could be done with some module in some library that exports a list = unsafePerformIO (newIORef mempty)
17:19:52 <enthropy> hmm, not sure
17:20:09 <enthropy> isn't your idea to have a :r that doesn't erase everything?
17:20:13 <chrisdone> yeah
17:20:17 <enthropy> (I mean equivalent to)
17:20:29 <ReinH> How do I get ghc(i) to spit out the generated code for derived instances?
17:20:35 <enthropy> so if a function is changed, you send to ghci something like:
17:20:44 <chrisdone> ReinH: in core?
17:21:01 <enthropy> recordOfFunctions <- return ( add_definition ... $ recordOfFunctions )
17:21:06 <enthropy> ReinH: -ddump-deriv
17:21:16 <ReinH> -ddump-deriv
17:21:17 <ReinH> yep thanks
17:21:31 <enthropy> ghci tab-completes all those flags
17:21:32 <chrisdone> enthropy: sure
17:21:35 <enthropy> very convenient
17:21:51 <dagano> can i have a guard statement within a guard statement?
17:22:04 <dagano> nested guards?
17:22:07 <monoidal> no
17:22:18 <lispy> You can have pattern guards though
17:22:26 <lispy> which fill a similar need
17:22:40 <dagano> patterned guards ?
17:22:42 <lispy> http://www.haskell.org/haskellwiki/Pattern_guard
17:22:50 <dagano> thanks
17:23:01 <lispy> This probably has better examples: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
17:23:34 <chrisdone> enthropy: and if you have foo = putStrLn "Hello!", that becomes:
17:23:34 <chrisdone> enthropy: foo = do let origCode = putStrLn "Hello!"
17:23:34 <chrisdone>                    foo' <- fmap (lookup "foo") (readIORef record)
17:23:34 <chrisdone>                    case foo' of Nothing -> do modifyIORef (insert "foo" origCode) record
17:23:36 <lispy> the "clunky" example is probably similar to what you want?
17:23:37 <chrisdone>                                               origCode
17:23:41 <chrisdone>                                 Just newCode -> newCode
17:23:54 <chrisdone> enthropy: so that whenever you update 'record', foo will be reading the latest value
17:24:17 <enthropy> sure, but that has the problem you identified with polymorphic stuff
17:24:22 <chrisdone> yep
17:25:37 <chrisdone> the gfold function has a neat implicitparams trick and makes the actual class parametrized somehow
17:25:38 <chrisdone> hum
17:26:21 <chrisdone> gtraverse :: (Applicative f, ?c :: p c) => (forall d. c d => d -> f d) -> a -> f a
17:26:30 <chrisdone> but that's just one class D:
17:26:53 <dagano> can a where clause have guards?
17:26:56 <dagano> where thing
17:27:08 <dagano> | x==0 = something
17:27:11 <chrisdone> where thing | yep = "ja" | otherwise = "nope"
17:27:16 <dagano> |otherwise = something else
17:27:17 <argiopeweb> where go x | x == 0 -> "cats"?
17:27:25 <chrisdone> -> is for cases
17:27:31 <argiopeweb> Rightio.
17:27:39 <chrisdone> because, maths and stuff
17:27:45 <argiopeweb> Hit enter and went, "Ah shoot."
17:27:54 <argiopeweb> Still, that desugars to case...
17:27:57 <chrisdone> i often write = or -> in the wrong place
17:28:01 <chrisdone> the distinction kinda bugs me
17:28:02 <enthropy> chrisdone: where's that gtraverse from?
17:28:07 <chrisdone> http://hackage.haskell.org/packages/archive/traverse-with-class/0.1.1/doc/html/Data-Generics-Traversable.html
17:28:34 <haasn> Why isn't the Loongson a tier-1 GHC platform? ;~;
17:29:40 <chrisdone> enthropy: it's a pretty cool way to travers and add a class constraint to the objects you want to work on. can't do that in normal typeable
17:30:18 <enthropy> that probably was done before constraintkinds by syb-with-class
17:30:27 <enthropy> but that one has it's own Data class
17:31:17 <chrisdone> i mean if you have gtraverse :: c -> (forall a.Data a => a->a) -> c
17:31:34 <chrisdone> you can't generically use Show for the 'a'
17:31:59 <chrisdone> you have to cast it to a concrete type first and then use show
17:32:30 <elliott> chrisdone: Typeable only works with actual concrete types
17:32:34 <chrisdone> gtraverse like in that package lets you make like
17:32:34 <chrisdone> gtraverse :: c -> (forall a.(Show a,Data a) => a->a) -> c
17:32:47 <elliott> so you can't really do this kind of constrainty stuff.
17:32:53 <chrisdone> elliott: yeah that's what i was saying
17:33:24 <dagano> with guards .. does the evaluation fall through if it got a success (one guard condition is true?)?
17:33:50 <chrisdone> it stops on the first True or throws an exception if none were True
17:34:11 <chrisdone> (unless you have subsequent patterns, then it'll try them)
17:35:01 <chrisdone> elliott: i wonder if defered type errors would let me do it!!
17:35:03 <chrisdone> =o
17:35:36 <elliott> :(
17:35:45 <chrisdone> Now You're Thinking In Dynamic Languages
17:38:49 <haasn> Deferred type errors won't actually let you do anything you can't do with static type checking, right? It just replaces type erroneous statements by “error”
17:38:55 <dagano> can i filter a list with two booleans in one expression?
17:39:00 <haasn> s/statements/expressions/
17:39:06 <dagano> or do i need a comprehension?
17:39:09 <chrisdone> hassn: i'm not sure. it gets weird with type class trickery
17:39:52 <dagano> > filter (<8) . filter (>3) $ [1..10]
17:39:53 <lambdabot>   [4,5,6,7]
17:39:57 <chrisdone> > typeOf (error "boo" :: Int)
17:39:58 <lambdabot>   Int
17:40:08 <chrisdone> stuff like that is legit even if the expression is an error
17:40:29 <chrisdone> but yeah maybe in this use case it won't work. installing ghc 7.6 to find out…
17:40:44 <joelteon> :t let php_eq a b = typeOf a == typeOf b in php_eq
17:40:47 <haasn> chrisdone: but instead of -fdefer-type-errors you can just use ‘error’ yourself in this case
17:40:59 <lambdabot> (Typeable a, Typeable a1) => a -> a1 -> Bool
17:41:06 <joelteon> 14 seconds of latency
17:41:31 <haasn> > let php_eq a b = typeOf a == typeOf b in php_eq 3 4
17:41:32 <lambdabot>   True
17:41:59 <chrisdone> haasn: i'm curious to see what it outputs
17:42:07 <dwcook> haasn, that's unfair, PHP equates lots of things that aren't of the same type :)
17:42:23 <chrisdone> $x/0 in php is: false
17:42:32 <chrisdone> everything you thought you knew about anything is wrong
17:43:12 <joelteon> > :t let php_eq _ _ = unsafePerformIO (fmap (randomR (False, True)) newStdGen) in php_eq
17:43:13 <lambdabot>   <hint>:1:1: parse error on input `:'
17:43:19 <joelteon> oh whoops
17:43:29 <johnw> ah, I love it when #haskell discusses PHP
17:43:44 <haasn> PHP is too mainstream, I prefer Acme.PHP
17:44:15 <haasn> joelteon: randomIO :: IO Bool
17:44:24 <haasn> or randomRIO for that matter
17:44:31 <joelteon> oh sure
17:44:58 <dwcook> I think PHP solidly captures the fundamentals of programming language theory by the very act of rebelling against them, an act of art whose relevance cannot be denied.
17:45:10 <chrisdone> lol
17:45:25 <johnw> dwcook: it reveals by contrast, you mean? :)
17:45:33 <dwcook> johnw, precisely!
17:46:02 <chrisdone> rasmsus is the andy warhol of programming language authors?
17:46:39 <joelteon> interestingly, my version of php_eq *can* always be correct
17:46:44 <joelteon> and more performant than traditional equality
17:46:46 <chrisdone> wadler: look, i painted mona lisa. rasmsu: look, i painted a tin of beans
17:47:41 <acowley> concurrent machines are happening
17:48:03 <johnw> acowley: I got excited there for a moment that you were talking about edwardk's library
17:48:07 <acowley> I am
17:48:09 <johnw> oh!
17:48:13 <acowley> indeed!
17:48:15 * johnw is officially excited
17:48:48 <acowley> I hope it works out
17:48:55 <acowley> johnw: Do you have any good test cases?
17:49:04 <acowley> I'm not sure how much I want implement before getting someone to try it out
17:49:07 <johnw> no, i've never used machines
17:49:15 <acowley> I know I'll use it, but my uses will probably be somewhat narrow
17:49:19 <johnw> edwardk libraries fit a certain pattern for me
17:49:27 <acowley> I have asynchronous connection and concurrent tee so far
17:49:42 <acowley> I guess I'll just do wye and see what Ed says
17:49:56 <johnw> (1) hear about them, (2) wonder what they do, (3) learn lots of Haskell in the interim, (4) realize edward's library was a solution to a problem I wasn't aware of yet, (5) encounter a problem which I now recognize is suited to his library, (6) use said library
17:50:21 <acowley> This code is amazingly hideous, but I hope we get everything we need from very few primitives
17:50:22 <argiopeweb> And, by the time 6 rolls around, there have been 7 new libraries.
17:50:30 <johnw> argiopeweb: no kidding
17:50:33 <johnw> which is great, actually
17:50:34 <acowley> johnw: That sounds exactly right
17:50:48 <johnw> i just used 'tables' for the first time yesterday, and it really saved my bacon
17:50:54 <johnw> but I've "known" about the existence of tables for maybe 11 months
17:50:57 <acowley> Lucky bacon
17:51:01 <acowley> I haven't used tables yet
17:51:11 * argiopeweb doesn't know about table
17:51:12 * argiopeweb doesn't know about tables
17:51:17 <johnw> it makes so much sense, once you've made sense out of it!
17:51:19 <haasn> johnw: it's a shame most of his libraries don't include batteries the way lens does
17:51:24 <argiopeweb> Gah, pulled a bash and corrected with up arrow...
17:51:28 <johnw> 'reflection' was also like that for me
17:51:35 <johnw> and 'tagged'
17:51:50 <acowley> everyone can use linear, at least
17:51:57 <johnw> slowly I am graduating toward the Kmettiverse
17:51:58 <haasn> johnw: trifecta?
17:52:04 <johnw> trifecta I use and love, linear I use and love
17:52:13 <johnw> and, of course, lens
17:52:21 <johnw> exceptions is a new one
17:52:30 <johnw> and semigroups
17:52:31 <ReinH> acowley: hai
17:52:38 <johnw> man, I bet a large number of libraries that I now depend on daily are his
17:52:48 <acowley> I hope to be pushing more machines code over the next week. I touched on it in a talk, so there will at least be some "real world" uses of it
17:53:06 <johnw> machines are essentially pipes?
17:53:09 <acowley> ReinH: Greetings and salutations!
17:53:11 <acowley> johnw: Yes
17:53:24 <chrisdone> simplified pipes aiiu
17:53:25 <acowley> johnw: But simpler and less fancy
17:53:27 <chrisdone> less type variables
17:53:32 <acowley> less everything, really
17:53:34 <johnw> like conduit?
17:53:35 <haasn> you mean ‘generalized’
17:53:45 <acowley> machines is what you'd right if you sat down to solve this kind of problem
17:53:47 <chrisdone> conduit is complex too by comparison
17:53:50 <acowley> s/right/write
17:53:52 <haasn> machines lets you recreate pipes by choosing the appropriate underlying types, no?
17:54:11 <acowley> machines does one fancy thing in terms of the input "language" accepted by a machine
17:54:16 <haasn> it just defers boilerplate to the user, rather than the library, afaik
17:54:32 <acowley> I don't think there's much boilerplate
17:54:58 <johnw> can machines just wrap around pipes or conduit?
17:55:26 <haasn> It could be I was just using it incorrectly but when I wanted to mix inputs (like (r ->) and IO) I had to use lots of boilerplate to manually make sure all of the :+: etc. line up the way the combinators expect them to
17:55:52 <johnw> ah, I see
17:55:53 <acowley> johnw: I really can't say. Both of those libraries emphasize things that machines doesn't explicitly mention
17:55:57 <johnw> a Plan has await/yield, as I'm used to
17:56:07 <acowley> wait, what?
17:56:11 <haasn> yes it's simple for machines which only have one input
17:56:17 <johnw> http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Plan.html
17:56:58 <johnw> so, I wonder now if I could write a Conduit Producer instance for PlanT...
17:56:59 <acowley> I can now write: tee (buffer 5 a) (buffer 20 b) c and have a and b run concurrently with bounded buffers that c taps into using the awaits function to select which input it wants
17:57:32 <haasn> http://ekmett.github.io/machines/index.html
17:57:43 <johnw> acowley: I added $$& to conduit, which does something similar
17:59:18 <johnw> and I guess pipes-concurrency must also do
18:00:04 * haasn scratches head
18:00:35 <haasn> I have some local machines commits lying around but they don't seem to be in the repo and I don't have a fork either.. did I forget to ever submit them?
18:00:41 <elliott> acowley: can you make machines itself nicer?
18:00:54 <acowley> elliott: You have high standards
18:01:10 <acowley> elliott: what's wrong with it?
18:02:19 <johnw> wow, the core types for conduit (Pipe) and pipes (Proxy), are super similar
18:02:59 <elliott> acowley: well, it's ugly. just ask edwardk.
18:03:18 <elliott> acowley: take a look at the code for "wye".
18:03:25 <elliott> there's a lot to go wrong in that code.
18:03:30 <acowley> elliott: You're going to love my async versions of those parts
18:03:35 <acowley> elliott: It doubles down on ugly
18:03:39 <elliott> also, the duplication between Machine and Plan is ugly.
18:04:17 <acowley> elliott: Well, I figure the Plan/Machine division is edwardk's business. I'm going to get my concurrent tee and wye working, then I'll see if I can help things
18:04:38 <acowley> elliott: But frankly, concentrating ugly in just three places (for the concurrent versions) isn't the end of the world in my book
18:04:42 <elliott> edwardk gave up, though.
18:04:45 <elliott> that's why you're my only hope.
18:05:13 <acowley> elliott: I am curious how much the Plan/Machine division buys you
18:05:48 <elliott> edwardk started unifying it, then he stopped and claimed it can't work and breaks everything or something.
18:06:05 <elliott> but I don't understand what he means at all, so I think someone with blissful ignorance as to what's wrong with it should try!
18:06:32 <acowley> Well, ignorance is my forte, so I can give it a shot.
18:06:37 <elliott> like, the whole constructing machines from plans is okay. it's just that they're almost the same type with like, one extra constructor and reordered type parameters, and one is CPS'd.
18:06:49 <elliott> I don't know why they couldn't share an underlying representation.
18:06:52 <acowley> The CPS'ing is what brings the ugly
18:07:26 <elliott> right. all the casing on machines gets even uglier. but OH WELL.
18:07:27 <acowley> My understanding is pretty cloudy. I thought you'd tell me how it makes construction of the Machine more efficient
18:07:39 <acowley> casing on steps happens in all these libraries
18:07:47 <elliott> yes. but it's uglier if you CPS it :P
18:07:52 <elliott> GHC should support {-# CPS #-}
18:07:54 <acowley> Yeah, I don't look at the Plan code
18:08:03 <acowley> I tried, and it spit on me
18:08:38 <elliott> I think pipes is more elegant than machines right now, and I don't even like pipes.
18:08:44 <elliott> but machines looks like it could be really nice.
18:10:20 <johnw> i wonder how lensy it would look if edward redid it now
18:10:25 <acowley> Well I'd definitely be interested in cleaning it up. But I honestly don't really have any feeling at all for how much the Plan CPSing buys you.
18:10:30 <johnw> lenses make for such a great API in 'tables'
18:12:46 * acowley kind of hopes elliot never sees the concurrent machines code
18:21:49 * hackagebot pandoc 1.12.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.0.1 (JohnMacFarlane)
18:27:08 <valroadie> Quick qeustion if anyone would be so kind to help, I am playing with my xmonad.hs (been for awhile now) and I want to setup a hot key to open a terminal and RUN a command in the terminal, is this possible?
18:27:53 <chrisdone> fwiw the #xmonad channel is a more reliable place to ask this
18:28:10 <valroadie> Ah ok thanks chrisdone
18:38:36 <MoneyMake> Ever wanted to make money filling out surveys? http://131e361mqf-m3rb6xp3o2stqxy.hop.clickbank.net/
18:38:36 <MoneyMake> Tired of scams on "How To" make money on the internet. Try the new Google Sniper. I have made over $1,000,000 my first year. http://231df18klfxu0v1atcqnhjbt12.hop.clickbank.net/
18:38:36 <MoneyMake> Want to make money? Heres the best way in 2013 to become an instant millionare watch this short video and get started today! http://fee36z8hkhyp6x69w-4vdscqdf.hop.clickbank.net/
18:48:12 --- mode: ChanServ set +o johnw
18:48:18 --- mode: ChanServ set +o johnw
18:48:39 --- mode: johnw set -o johnw
18:52:27 <Athan> Hey does anyone know the type signature of (<-)?
18:52:34 <Athan> What exactly is it used for?
18:52:45 <chrisdone> <- is syntactic sugar
18:52:54 <Athan> for what?
18:53:12 <chrisdone> it's used in various places, in do notation, list comprehensions, pattern guards
18:53:18 <monoidal> ... x <- e; ... is sugar for ... e >>= (\x -> ...
18:53:31 <Athan> OH!!!!
18:53:32 <Athan> AWESOME!
18:53:39 <Athan> is there a name for it?
18:53:41 <Athan> like
18:53:43 <Athan> post-bind
18:53:45 <Athan> or something?
18:53:47 <chrisdone> tend to call it bind
18:54:00 <Athan> well I know (>>=) is bind
18:54:12 <Athan> is (=<<) and (<-) bind as well?
18:54:15 <johnw> it's kind of like a monadic let
18:54:19 <dfan> I pronounce it 'gets'
18:54:21 <Iceland_jack> <- is sometimes called drawing from a generator
18:54:37 <YayMe`> dfan: I pronounce it from, but I don't know how accurate that is
18:54:45 <chrisdone> i call all the bind equivalents 'bind', personally
18:54:45 <Athan> hmmm
18:54:48 <Athan> so
18:54:52 <Athan> the traditional bind
18:54:54 <Athan> >>=
18:54:59 <Iceland_jack> Athan: http://www.haskell.org/haskellwiki/Keywords look up <- there
18:55:07 <YayMe`> in a list comprehension it's element of, and you could argue it has the same semantics as element of in normal monads as well
18:55:12 <Athan> expects to have a monadic function of the same type
18:55:13 <Athan> ie
18:55:35 <Athan> (>>=) :: m a -> ( a -> m a ) -> m a
18:55:37 <Iceland_jack> Do notation: Draw from.
18:55:37 <Iceland_jack> List comprehension: Is drawn from (a generator).
18:55:37 <Iceland_jack> Pattern guard: Matches.
18:55:47 <Athan> does (<-) have such a restriction?
18:56:00 <Athan> I see it used in versitile forms
18:56:13 <Iceland_jack> Athan: <- is exactly the same as (>>=) when used in do notation, all the same restrictions apply
18:56:34 <hiptobecubic> What makes this game of life implementation slow down exponentially? I thought maybe the way the domain is implicitly represented by the function bar, but the profiler says it's the neighbor checking. I *did* expect that to be slow, but why is it progressively slower with each generation? http://lpaste.net/93213
18:56:41 <monoidal> Athan: your type of >>= is wrong. it's m a -> (a -> m b) -> m b
18:56:58 <YayMe`> Athan: http://www.haskell.org/haskellwiki/Do_notation_considered_harmful some agree with what's said here, some disagree, but you are stumbling towards the reason that article was written
18:58:03 <YayMe`> in a monad <- gets a 'b' from the 'a->m b
18:58:10 <YayMe`> in do notation
18:58:14 <monoidal> Athan: >>= can also be given m a -> (a -> m a) -> m a type, but that's a special case of the more general type
18:58:25 <YayMe`> it's really m b, but in the context of the do you get to treat it as just a b
18:58:41 <monoidal> > do x <- [1,2]; y <- ["ab"]; return (x,y)
18:58:42 <lambdabot>   [(1,"ab"),(2,"ab")]
18:58:47 <Iceland_jack> YayMe`: It's confusing when you use ‘a’ in front of a single letter type variable ;)
18:58:53 <Iceland_jack> just a b
18:58:55 <monoidal> > do x <- [1,2]; y <- ["a","b"]; return (x,y)
18:58:57 <lambdabot>   [(1,"a"),(1,"b"),(2,"a"),(2,"b")]
18:59:06 <YayMe`> Iceland_jack: That's why I used quotes but yeah heh
18:59:09 <monoidal> [1,2] >>= (\x -> ["a","b"] >>= \y -> return (x,y))
18:59:12 <monoidal> > [1,2] >>= (\x -> ["a","b"] >>= \y -> return (x,y))
18:59:13 <lambdabot>   [(1,"a"),(1,"b"),(2,"a"),(2,"b")]
18:59:18 <monoidal> Athan: ^ see above
19:00:12 <joelteon> the problem with haskellmode is it doesn't highlight nearly as well as vim2hs does
19:00:22 <YayMe`> Mumble... I cannot come up with a functor for this fixed-width take/drop type data parser I'm trying to define...
19:01:51 <YayMe`> data Result i o = Result { output::o, restOfInput::i } makes sense until I try to take some off of restOfInput and put it into output... this not is a correct approach...
19:02:56 <YayMe`> Maybe I'll be better served just implementing the functionality I want and then trying to generalize the implementation rather than trying to design towards the generalization
19:10:11 <Athan> yo guys I got a question
19:10:18 <Athan> why are modules different from packages?
19:10:35 <Athan> Why can't I just install a module and use it's exposed stuffs?
19:10:44 <YayMe`> A package may have many modules; a module is roughly similar to a class
19:10:50 <Athan> I'd really like to install Yesod.Hamlet (for hamletToContent function)
19:10:53 <insha> Hi all. I upgraded to Xcode 5 and now I am unable to install anything using cabal.
19:10:56 <haasn> if by ‘roughly similar to’ you mean ‘not at all’
19:10:58 <Athan> but I can't find what package it's located in
19:11:01 <nstdloop> insha
19:11:07 <nstdloop> You need to go back to xcode 4.6.x
19:11:14 <nstdloop> Cabal won't work otherwise
19:11:19 <haasn> Athan: have you tried asking hoogle?
19:11:22 <Tekmo> Athan: Several packages can define the same module (although it's considered a bad thing if they do)
19:11:31 <YayMe`> Athan: http://hackage.haskell.org/packages/archive/yesod/0.5.4.2/doc/html/Yesod-Hamlet.html
19:11:37 <monoidal> insha: http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
19:11:38 <insha> nstdloop: That blows!
19:11:40 <YayMe`> yesod.hamlet is it's own package
19:12:01 <nstdloop> insha Ya, it will be fixed in ghc 7.8, but as of right now ghc can't use clang for an important preprocessing step
19:12:06 <Athan> how do I know what package a module belongs to?
19:12:13 <Athan> how can I find it out
19:12:19 <nstdloop> insha You can download the correct command line tools from the apple developer website. Make sure you get 4.6.x
19:12:28 <YayMe`> Athan: you can just search hackage
19:12:36 <YayMe`> or hoogle
19:12:46 <Tekmo> You can use either Google, Hoogle, or Hayoo
19:12:50 <haasn> Athan: if hayoo doesn't pick them up, the package likely doesn't exist on hackage
19:12:51 <YayMe`> hoogle is helpful when you know the type signature you want but not what functions implement it etc
19:12:58 <haasn> Last resort would be google/github for me I guess
19:13:01 <insha> nstdloop: Can I install gcc using brew and configure ghc to use that?
19:13:13 <haasn> Athan: are you thinking of http://hackage.haskell.org/package/hamlet ?
19:13:29 <Tekmo> Athan: One trick.  It helps to prefix all searches with "hackage"
19:13:36 <Tekmo> Athan: i.e. "hackage Yesod.Hamlet"
19:13:45 <Tekmo> I find that improves search quality more than anything else
19:13:48 <YayMe`> Tekmo: That's how I found it...
19:13:48 <nstdloop> insha Yes... but it's a messy workaround. It is probably MUCH easier to just revert to 4.6.x
19:13:54 <Athan> Wow!
19:13:57 <Athan> Aweomse!
19:14:03 <ReinH> Ooh I can mess with 24-bit terminal colors now!
19:14:21 <nstdloop> insha more info: http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
19:14:33 <hpc> ReinH: write a terminal gif viewer
19:14:39 <YayMe`> Athan: Just remember hackage is basically the online package repository for haskell packages, if you want a haskell package that's where it'll come from and it's completely searchable and very well indexed by google.
19:14:40 <ReinH> hpc: ok!
19:14:42 <insha> nstdloop: Thank dude!
19:14:57 <ReinH> hpc: I'm going to write a 24-bit terminal roguelike :D
19:14:58 <nstdloop> Sure. I had the same problem, took me hours to figure out what was going on.
19:16:06 <ReinH> the only problem is detecting terminal support
19:16:09 <ReinH> terminfo is useless here
19:16:52 <Tekmo> Oh god, I've been working with terminal stuff recently, too
19:16:56 <Tekmo> It's such a pain in the butt
19:17:28 <Tekmo> I still cannot figure out a portable way to backspace that wraps around the left margin
19:18:37 <YayMe`> Tekmo: the trick is begging
19:18:46 <ReinH> Tekmo: keep a char buffer and do everything in the buffer, then just redraw the term :p
19:18:48 <Tekmo> Haha
19:18:54 <Tekmo> ReinH: I tried that
19:18:58 <Athan> I wish there was a --verbose argument on hackage
19:19:08 <ReinH> Tekmo: use ncurses or similar
19:19:13 <Athan> how?
19:19:21 <Athan> is ncurses a standalone program?
19:19:22 <hpc> Tekmo: to redraw the terminal, start with system "clear"
19:19:23 <hpc> ;)
19:19:29 <Tekmo> ReinH: The problem is that now I can't figure out a portable way to delete my char buffer
19:19:32 <Athan> I thought it was just a terminal formatting library..?
19:19:37 <johnw> Tekmo: hello!
19:19:38 <YayMe`> Athan: ncurses is an old-school C terminal drawing library
19:19:38 <ReinH> Tekmo: why do you need to delete it?
19:19:41 <Tekmo> johnw: Hey!
19:19:46 <Tekmo> Ok, so let me outline my problem
19:19:51 <Athan> derp
19:19:56 <Tekmo> I want a terminal prompt that doesn't get clobbered by output
19:20:05 <Tekmo> And it has to support multi-line input
19:20:27 <ReinH> ok
19:20:34 <johnw> would about haskeline?
19:20:40 <Tekmo> I tried Haskeline
19:20:50 <Tekmo> The problem is that Haskeline gets clobbered by concurrent outputs
19:21:00 <YayMe`> Tekmo: How does it not get clobbered by output? Does the output stay above the input line or below it?
19:21:08 <Tekmo> YayMe`: Above the input line
19:21:13 <hpc> Tekmo: synchronize your writes?
19:21:16 <ReinH> use ncurses :p
19:21:32 <Tekmo> ncurses is too much
19:21:33 <YayMe`> Tekmo: Have you tried inverting; keep the input on top of the console and the output scrolling below it
19:21:40 <Tekmo> I want this to play nice with preexisting ocnsole output
19:21:54 <ReinH> what do you mean?
19:21:59 <Tekmo> Sort of like how `octave` and `ghci` do
19:22:14 <Tekmo> i.e. not like `vi`
19:22:25 <ReinH> I'm not sure that's possible
19:22:33 <Tekmo> I think it is
19:22:40 <Tekmo> The hacky way I've figured this out
19:22:41 <YayMe`> ReinH: ghci does it... granted it likely uses ncurses
19:22:41 <hpc> vi misbehaves but vim works just fine for me
19:22:50 <hpc> somehow
19:23:01 <ReinH> maybe I don't know what "play nice" means
19:23:01 <Tekmo> Is that every time you print output you delete the char buffer, print hte output, then reprint the char buffer
19:23:19 <Tekmo> The problem is that I still have trouble reliably deleting multiline char buffers
19:23:30 <ReinH> I am confused
19:23:35 <ReinH> how does deleting the char buffer help?
19:23:48 <Tekmo> I mean, let's say that I have a prompt open
19:23:53 <Tekmo> The user is typing input into it
19:23:57 <Tekmo> Now an output is coming in
19:24:14 <Tekmo> I delete the user's input and the prompt, print the output, then re-print the prompt and user input
19:24:56 <YayMe`> Tekmo: This smells like you're doing manual transactions (reverting the users input, applying the overriding write, then retrying the user input), you know what's good at automatic transactions? STM
19:25:07 <YayMe`> I wonder if having your output buffer in STM could make this play more nicely for you
19:25:42 <Tekmo> The problem is that the user's input needs to be visible while they are typing
19:26:12 <YayMe`> So they get the atomic lock in the STM; the other input will patch in between their key strokes
19:26:15 <Tekmo> I already have a transactional system set up to control access to the console
19:26:17 <Tekmo> That's not the problem
19:26:35 <Tekmo> All inputs to the console feed through a single queue in STM
19:26:40 <YayMe`> Ah
19:26:41 <Tekmo> *All outputs
19:26:53 <YayMe`> The problem is just that you only print to the bottom line?
19:26:55 <Tekmo> So the synchronization is not a problem
19:27:04 <Tekmo> The problem is that I have trouble reliably deleting multiline inputs
19:27:12 <Tekmo> It's difficult to find a portable way to do it
19:27:14 <YayMe`> regardless of whether it's user input or other input
19:27:18 <Tekmo> Right
19:28:02 <ReinH> Tekmo: the only portable way is to read raw chars and manipulate your own buffer
19:28:10 <Tekmo> That's already what I'm doing
19:28:30 <Tekmo> There are several issues:
19:28:54 <Tekmo> A) I don't now how to reliably compute the display width of the input characters
19:28:55 <YayMe`> What's harder about multi-line user input? Do you currently only remove the last line from the buffer rather than having knowledge of what the users input was to remove all of it from the buffer?
19:29:20 <Tekmo> B) I can't find portable terminfo sequences for deleting lines and scrolling back up
19:29:29 <Tekmo> C) I don't know how to deal with terminal resizing
19:29:47 <ReinH> Tekmo: are you using https://github.com/ekmett/ansi-terminal ?
19:29:54 <Tekmo> I'm using the terminfo package
19:30:08 <ReinH> A) terminfo can give you screen size
19:30:23 <ReinH> B) There are ANSI codes for this stuff
19:30:30 <Athan> does anyone know how to directly connect a shamlet quasi-quote with a yesod handler?
19:30:31 <ReinH> C) you trap WINCH signals
19:30:33 <Athan> ie:
19:30:52 <ReinH> Tekmo: ansi-terminal provides a nice wrapper around said ANSI codes
19:31:01 <Athan> getSomeResourceR = *what the hell?* [shamlet| <span>Yeah!|]
19:31:17 <Tekmo> What about computing display width?
19:31:27 <YayMe`> Athan: #yesod might have some more information about the yesod ecosystem DSLs
19:31:28 <Tekmo> i.e. for dealing with combining characters or for weird languages
19:31:37 <YayMe`> (or is it #yesod-web ? I can't remember)
19:31:47 <Athan> THANK YOU!!!!
19:32:09 <ReinH> Tekmo: $LC_CTYPE or $LANG
19:32:21 <ReinH> will give you the encoding
19:32:33 <YayMe`> Tekmo: Do you have any access to buffer height or is it only appear as a big string of characters to you?
19:34:14 <ski> ReinH : "24-bit terminal colors" ?
19:34:28 <ReinH> Tekmo: fun story about WINCH: there's a Ruby application server that (used to) trap WINCH signals and and do a soft restart even when connected to a TTY
19:34:32 <Tekmo> YayMe`: Big string of characters, currently
19:34:35 <ReinH> so resizing your terminal would cause your dev server to restart
19:34:36 <ReinH> good times
19:34:47 <Tekmo> Haha
19:35:14 <hpc> ski: maybe it's a bitmask
19:35:17 <joelteon> yeah, but who resizes their terminal
19:35:24 <hpc> ski: like there's only 24 colors, but it can be all of them simultaneously
19:35:26 <Tekmo> Pathological users, that's who
19:36:11 <ReinH> ski: yeah, ISO-8613-3, briefly mentioned (but not referenced) in http://en.wikipedia.org/wiki/ANSI_escape_code#Colors
19:36:24 <ReinH> ESC[ … 38;2;<r>;<g>;<b> … m Select RGB foreground color
19:36:40 <ski> hpc : i was wondering if they were talking about 256-color support (e.g. in XTerm), which allows you to set the 256 colors in the palette to new RGB values (which could be 24-bit, i'm not sure)
19:37:09 <ReinH> it's a 3 year old extension that's currently supported by konsole and iterm2 nightly and that's about it
19:37:23 <ReinH> and there's no reliable way to detect whether it's supported
19:37:29 <YayMe`> Tekmo: getCapability :: Terminal -> Capability a -> Maybe a
19:37:57 <ReinH> tput colors on my supporting iterm2 gives 8, which is pretty clealy wrong
19:38:25 <ski> ReinH : well, that's the SGR escape sequence for setting forground color from 88/256 -color palette in XTerm (and possible some other terminals)
19:38:45 <ReinH> ski: no, look closely
19:38:46 <YayMe`> What happens if you try to getCapability with the Capability from cursorLeft when you're all the way to the left? You could bol, then cursorLeft until getCapability gives Nothing
19:38:50 <hiptobecubic> Hmm, I guess what's happening is that it has to replay the entire Game across the entire board up to the current generation for *each* cell... I don't know why I expected that to be memoized somehow.
19:38:57 <ski> oh, `;2', ok
19:39:11 <ReinH> ski: right, 256-color mode is ;5
19:39:19 * ski nods
19:39:21 <Athan> if you were a yesod handler, how would you make a simple hamlet quasi-quote render on each request?
19:39:28 <hiptobecubic> Is there a way to fix that problem and keep the implicit domain representation?
19:39:28 <ski> ReinH : ok, so this doesn't go through the palette at all ?
19:39:42 <YayMe`> Athan: First I'd read the quasiquote documentation because that shit's magic
19:39:46 <ReinH> ski: no, it should be directly rendered as a 24-bit RGB value
19:39:52 <ski> ok, interesting
19:40:01 <ReinH> but like I said, basically nothing supports it
19:40:05 <ReinH> even though it's 3 years old
19:40:06 <ReinH> wah
19:40:27 <edwardk> ReinH: how fares the visibility optimization?
19:40:49 <ski> "and there's no reliable way to detect whether it's supported", the proper way would be to allocate new termcap/terminfo capability names, and update that DB to include info on which terminals support it
19:40:55 <ReinH> edwardk: haven't messed with it yet
19:41:12 <ReinH> edwardk: I want to update ansi-terminal to support 24-bit color codes
19:41:22 <edwardk> ReinH: sounds fun
19:41:35 <ReinH> edwardk: it is, except that almost no terminals support the standard
19:41:45 <edwardk> ReinH: it'd be easier to just fix up my terminal project and check terminfo/termcap, no?
19:41:56 <ReinH> edwardk: except that terminfo doesn't report correctly
19:42:05 <edwardk> blech
19:42:08 <ReinH> tput colors gives 8 for iterm2 nightly, which supports it
19:42:26 <ReinH> edwardk: wait, isn't your terminal project ansi-terminal?
19:42:46 <ReinH> well, not yours, but you forked it, made a commit, and pushed a new version to hackage
19:42:50 <ReinH> :p
19:42:56 <ReinH> which one and where is yours?
19:43:02 <edwardk> https://github.com/lens/terminal
19:43:06 <edwardk> i didn't push it, did i?
19:43:11 <ReinH> well, it got pushed
19:43:12 * ReinH shrugs
19:43:19 <edwardk> whew =)
19:43:20 <ski> "even though it's 3 years old" -- well, change happens slowly
19:43:32 <ReinH> ski: it's 2013 and I want my 24-bit color terminals damn it
19:43:33 <ReinH> :p
19:43:52 <edwardk> anyways "terminal" was me starting a lensy cross-platform terminal, but i got distracted
19:43:56 <johnw> next you'll be wanting terminal CSS
19:44:07 <edwardk> johnw: sounds good. patch!
19:44:22 <johnw> sure, right after I finish writing Terminalscript
19:44:42 <ski> ReinH : and linear (spline ?) interpolation between four corners of a terminal cell perhaps ?
19:44:43 <edwardk> what happened was work got busy, so i just patched up max's version and shipped an updated trifecta off of that rather than finish terminal
19:44:59 <dwcook> johnw, base it on Haskell but make it object-oriented so Java programmers will feel comfortable with it
19:45:07 <ReinH> ski: maybe!
19:45:13 <dwcook> And don't forget; braces and semicolons everywhere
19:45:15 <edwardk> ReinH: just render with libtcod, and get an SDL-based console with truecolor on all platforms
19:45:28 <ReinH> edwardk: except libtcod 1.5.2 doesn't build on OS X
19:45:29 <johnw> I should call it Haskellscript, but have it really not have anything to do with Haskell except for superficial syntactic resemblance.  History shows that works
19:45:40 <Hafydd> Brendan, base it on Smalltalk, but make it semicolon-oriented so Java programmers will feel comfortable with it.
19:45:40 <edwardk> ReinH: that is a bit of a barrier to entry
19:45:47 <hpc> dwcook: all you need to do is make the lambda syntax significantly more verbose and java gui programmers will be right at home
19:46:00 <edwardk> ReinH: so it sounds like it is time to build a new libtcod clone in haskell, borrowing the sdl trick ;)
19:46:36 <hpc> what's the sdl trick?
19:46:39 <edwardk> johnw: it should also just be a reskinned lisp given a surface syntactic similarity to haskell
19:46:56 <johnw> edwardk: how did you know!
19:46:57 <edwardk> hpc: they render a text console using sdl is all
19:47:27 <ReinH> edwardk: I would totally be on board for that.
19:47:36 <ski> ReinH : anyway, ty for this info. i'm slowly learning more and more of the strange world of terminals and their capabilities
19:47:38 <ReinH> What's the state of the art for SDL wrappers in Haskell?
19:47:39 <dwcook> Hafydd, were you talking back in time just now?
19:47:41 <hpc> oh i see
19:47:59 <edwardk> ReinH: i think its just called 'SDL' ;)
19:48:03 <ReinH> yeah
19:48:08 <ReinH> was wondering if that's still *it*
19:48:12 <edwardk> @hackage SDL
19:48:12 <lambdabot> http://hackage.haskell.org/package/SDL
19:48:12 <Hafydd> Yes.
19:48:16 <elliott> SDL 2 is a thing now.
19:48:29 <Hafydd> #haskell came up with the idea for Javascript, from the future.
19:48:55 <edwardk> ReinH: maybe try in #haskell-game for more info
19:49:09 <ReinH> edwardk: good idea
19:51:31 <dwcook> Hafydd, I take it that if you took advantage of hindsight, it would cause a time paradox?
19:52:21 <ReinH> edwardk: so our options seem to be sdl for SDL 1 or GLFW-b for GLFW 3
19:52:27 <ReinH> there's no SDL 2 binding as of yet
19:52:41 <ReinH> but a roguelike doesn't need sprites or audio or other SDL-extras stuff, does it?
19:52:42 <edwardk> ReinH: sounds like you've found your yak
19:52:50 <ReinH> so maybe GLFW-b is the yak for me to shave :D
19:52:58 * edwardk hands ReinH a razor
19:53:02 <ReinH> oh god here we go
19:54:17 <elliott> ReinH: there is an SDL 2 binding in progress on github.
19:54:25 <ReinH> elliott: cool!
19:54:52 <ReinH> I'm going to jump on GLFW-b for now, I think
19:54:58 <elliott> I feel compelled to note that I am about to shave the particular yak of "fake terminal based on some graphics library for the purposes of a roguelike". this statement is not a commitment to release anything within the next decade, or a suggestion that you postpone your own work.
19:55:13 <ReinH> elliott: oh are you?
19:55:15 <ReinH> neat
19:55:23 <ReinH> elliott: we should at least compare notes :)
19:55:40 <elliott> whoa, nobody told me to take notes.
19:55:44 <ReinH> ok fine
19:55:53 <elliott> :)
19:56:30 <ReinH> one thing I really want to do is use the data join approach from D3 to make transitions between frames more efficient and elegant
19:57:17 <ReinH> elliott: so for instance if the user char was at point (5,4) in the previous frame and is now in (5,5), we can animate the '@' char's transition between cells
19:57:33 <ReinH> I want to do the same for dynamic lighting, etc
19:58:14 <ReinH> so the presentation is somewhere between brogue's 24-bit color depth but static and a more real-time game
19:58:37 <elliott> that's definitely fancier than what I was aiming for in the short-term. which is a surprise, usually I'm the one with the pipe dreams
19:58:47 <ReinH> elliott: well, this is what I've been wanting to build for a while :)
20:00:23 <ReinH> elliott: so basically you do a diff by "object" identity between the old frame and new frame so you can determine if entities are transitioning between frames vs being added or removed
20:00:51 <ReinH> and then you can render a tweened animation from old_pos to new_pos or old_color to new_color or whatever
20:01:16 <ReinH> I've already done a pretty simple JS version of this with D3
20:06:40 <mlamari> Is doing foo <- rpar and reading foo somewhere else the equivalent of rseq-ing it, or just some sort of runtime error (if it hasn't completed)?
20:06:45 <ReinH> elliott: oh, I found it. http://reinh.com/coffeequest/
20:07:07 <ReinH> (hjkl movement)
20:07:34 <Mikicacarica> FREE BRAZZERS ACCOUNTS ---> http://gratisbrazzers.blogspot.com
20:07:43 <copumpkin> lol
20:08:04 <elliott> the input lag it causes burns :p
20:08:12 <ReinH> I know
20:08:24 <ReinH> it's very naive
20:08:43 <elliott> if you hit yubn quickly around a block things get weird.
20:08:55 <elliott> you start phasing through it.
20:08:57 <ReinH> yes, yes, it's not very good :p
20:09:06 <ReinH> I just wanted to show you the idea
20:09:22 <elliott> :)
20:10:55 <ReinH> what I really like about D3 is that you say "here's the new set of data, here's how you transition in new data points, here's how you transition out removed data points, here's how you transition updated data points
20:11:05 <ReinH> and it computes the data join between old and new data sets and then does the appropriate things
20:12:08 <ReinH> so what I'd like to do is compute join :: World -> World -> DataJoin and then determine how to update the display in terms of the data join
20:12:31 <ReinH> or something like that
20:14:02 <ReinH> I'm pretty sure there's a simple data-flow or FRP interpretation of this
20:14:09 <elliott> I think I prefer making the transitions between states explicit and the worlds implicit in general.
20:14:16 <elliott> rather than inferring the former from the latter.
20:14:20 <ReinH> elliott: right
20:15:03 <ReinH> elliott: well, you can do update :: World -> Stream Event -> IO World or something
20:15:21 <ReinH> where you get back the new representation and do IO to display it
20:15:53 <ReinH> that gives you the option to do IO based on the stream or to compute the new world and render it directly, etc
20:15:58 <ReinH> anyway I have to go eat
20:16:37 <ReinH> ttfn
20:23:19 <Shin-LaC> how should I represent graphs in haskell?
20:25:39 <Makoryu> Shin-LaC: Depends on whether you want to modify the graph after creating it, or whether you want to be able to test nodes for equality
20:26:17 <Shin-LaC> Makoryu: let's say I don't need to modify it
20:27:08 <augustss> Then you can use    data Graph a = Node a [Graph a]
20:27:30 <augustss> And build a circular data structure.
20:27:55 <johnw> isn't that just a rose tree?
20:27:59 <Makoryu> Shin-LaC: If all you want to do is follow connections from one node to the next to retrieve some kind of data in order, then even if your graph contains cycles you can use knot-tying to model the connections directly with pointers
20:28:13 <augustss> johnw: Not if it has cycles.
20:28:51 <augustss> Well, it's equivalent to an infinite rose tree.
20:29:24 <johnw> so he could use http://hackage.haskell.org/packages/archive/containers/0.5.3.1/doc/html/Data-Tree.html#t:Tree
20:29:42 <Shin-LaC> Makoryu: ok, I'll try
20:30:47 <Makoryu> Shin-LaC: If that turns out to be hard, then represent nodes and edges separately, stored in separate lists
20:31:25 <johnw> Makoryu: is that an adjacency list?
20:31:29 <Makoryu> Yes
20:32:04 <Makoryu> There's a lot of leeway in how you actually represent it though
20:32:10 <Makoryu> In terms of the data structures involved
20:36:52 * hackagebot pandoc 1.12.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.0.2 (JohnMacFarlane)
20:56:53 * hackagebot ghc-mod 3.1.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.0 (KazuYamamoto)
21:34:18 <Shin-LaC> Makoryu: I have made the graph with knot-tying, but is there a way to avoid infinite loops in Show when there's a cycle?
21:34:26 <Makoryu> Nope
21:35:18 <Shin-LaC> I shouldn't make a Show that prints something that is not an actual haskell expression, right?
21:35:50 <Tekmo> Shin-LaC: The problem is that your graph is not really a graph
21:36:06 <Tekmo> Shin-LaC: It's really a tree, like augustss said
21:36:24 <Shin-LaC> hm
21:36:33 <Tekmo> A really good example of this is a "cyclic linked list"
21:36:40 <Tekmo> Such as: let zeros = 0:zeros
21:36:46 <Tekmo> That's not an actual cyclic linked list
21:36:53 <Tekmo> It's just an ordinary list defined recursively
21:37:11 <Shin-LaC> is it better to represent a graph with indirect links?
21:37:53 <Tekmo> You have to if you want changes to any element in the graph to have the right effect
21:38:10 <Tekmo> For example, going back to the `zeros` function
21:38:16 <Tekmo> If I replace the first element in that list
21:38:23 <Tekmo> That replacement will not update any subsequent zeroes
21:39:01 <Tekmo> Whereas, if I used an indirect reference to the head of the list then I could change the zero and the cyclic reference would update correctly
21:40:25 <Tekmo> This is a general pattern for a lot of functional algorithms that have cycles or graphs
21:40:35 <Tekmo> You end up implementing some sort of reference system
21:41:04 <Shin-LaC> I see
21:41:38 <Tekmo> In fact, there is a well known way to translate any imperative algorithm to a functional algorithm with only an O(log N) slowdown (where N is the number of elements with references), just by simulating references
21:41:57 <Tekmo> You just store your references in a binary tree
21:42:15 <Shin-LaC> yes, I can see that
21:42:43 <Tekmo> Like you, I used to wonder if there was a more elegant way to do cycles or graphs without simulating references, but I'm not aware of one
21:42:45 <Shin-LaC> but for the same reason, I thought that using knot tying would be "cleaner" or more elegant or something
21:42:51 <Tekmo> Yeah, I know
21:42:54 <Tekmo> It's disappointing
21:43:17 <Tekmo> So, *technically* you can still use knot tying
21:43:26 <Tekmo> But your update function would have to be recursive
21:43:31 <Tekmo> Again, going back to the `zeros` example
21:43:34 <Shin-LaC> yep
21:43:40 <Tekmo> If I wanted to update the zero and have the change propagate correctly
21:43:44 <Tekmo> I'd have to use the `map` function
21:43:49 <Tekmo> map (+1) zeros
21:43:53 <ski> Shin-LaC : "I shouldn't make a Show that prints something that is not an actual haskell expression, right?" -- imo, no you shouldn't do that
21:44:03 <Tekmo> In other words, `map` is update for a cyclic list of length one
21:44:34 <Shin-LaC> btw, to build the graph with knot tying, I actually have to have a map from node labels to node objects internally
21:44:49 <Shin-LaC> I'm using an association list, but probably that's not the best
21:45:19 <Shin-LaC> what's the go-to data structure in haskell for an association? the equivalent to a python dictionary, I mean
21:45:21 <Tekmo> You can use a hashmap or intmap for that
21:45:27 <Shin-LaC> ok
21:45:31 <Tekmo> So the two libraries that you should always go to for all data structures are:
21:45:36 <johnw> IntMap++
21:45:40 <Tekmo> `containers` and `unordered-containers`
21:45:46 <Tekmo> and `vector`
21:45:49 <johnw> yep
21:45:57 <Tekmo> `IntMap` is damn fast
21:46:03 <Tekmo> So is `HashMap`
21:46:04 <ski> hm, it would be nice with `newIVar :: a -> IO (IVar a); getIVar :: IVar a -> a'
21:46:26 <ski> and perhaps something like `newCyclicIVar :: (IVar a -> a) -> IO (IVar a)'
21:47:24 <Tekmo> Shin-LaC: I forgot to mention that `containers` already has a graph type
21:47:31 <Tekmo> Shin-LaC: See the `Data.Graph` module
21:48:30 <johnw> Tekmo: is that new?
21:49:47 <johnw> Tekmo: I wrote up a summary on how monad-control works
21:50:06 <Tekmo> johnw: Data.Graph has been around a while
21:50:09 <Shin-LaC> Tekmo: "HashMap" seems to only be in the "hashmap" package, according to hoohle
21:50:11 <Shin-LaC> *hoogle
21:50:13 <Tekmo> johnw: Neat!
21:50:33 <johnw> https://www.fpcomplete.com/user/jwiegley/monad-control
21:50:34 <Tekmo> You can find HashMap here:
21:50:35 <Tekmo> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.2/doc/html/Data-HashMap-Strict.html
21:50:49 <Tekmo> Shin-LaC: One tip if you are new to Haskell
21:51:01 <Tekmo> Shin-LaC: The best search engine is Google if you add "hackage" to every search
21:51:08 <Tekmo> Shin-LaC: i.e. "hackage HashMap"
21:51:10 <Shin-LaC> oh
21:51:29 <Tekmo> Also, note that `hoogle` does not search every package
21:51:34 <Tekmo> But Hayoo, does
21:51:42 <johnw> and fpcomplete.com/hoogle indexes a LOT more
21:51:51 <ski> well, forget to say that we should have `instance Eq (IVar a)'
21:52:12 <ski> .. but the question then is how to `fmap' over graphs constructed using `IVar's ?
21:52:46 <ski> also, we'd like to be able to do e.g. control flow or data flow analysis algorithms over such a graph
21:52:55 <Shin-LaC> Tekmo: what's the advantage of that HashMap being strict?
21:53:36 <ski> iow, a kind of fold where nodes add info monotonically, and where we propagate new information around the loops until it stabilizes
21:54:07 <Makoryu> Shin-LaC: I saw a rule of thumb somewhere that data structures should be strict by default, and *functions* are where you usually want your laziness
21:54:36 <Tekmo> Shin-LaC: Basically it guarantees that values stored in the map are evaluated to weak-head-normal-form using `seq`
21:55:06 <Tekmo> The general rule of thumb is that only two things should ever be strict
21:55:15 <Tekmo> Data types and accumulators for folds
21:55:28 <Tekmo> Not that I mean "data type" in a narrow sense
21:55:43 <Tekmo> i.e. something intended to hold data, not to be used as a control structure
21:55:54 <Tekmo> A simple example is a `Point` data type
21:56:06 <Tekmo> The expert way to define it would be something like:
21:56:22 <Tekmo> data Point = Point { x :: {-# UNPACK #-} !Double, y :: {-# UNPACK #-} !Double }
21:56:29 <Tekmo> That definition does two things
21:56:45 <Tekmo> First, it ensures that if you evaluate `Point`, you also evaluate the `x` and `y` sub-fields
21:57:02 <Tekmo> That's what those exclamation marks are doing right to the left of the `Double` types
21:57:17 <Tekmo> The second thing it does is remove indirection using the `UNPACK` pragmas
21:57:25 <Tekmo> That improves memory usage and locality
21:57:52 <Tekmo> So a well-defined data type will have "bang-patterns" (i.e. exclamation marks) all the way down
21:58:06 <Tekmo> This ensures that if you `seq` the outermost type it will `seq` all sub-fields in turn
21:58:37 <Tekmo> So, let's say that I had a game unit type:
21:58:58 <Tekmo> data Unit = Unit { position :: {-# UNPACK #-} !Point, health :: {-# UNPACK #-} !Int }
21:59:11 <Tekmo> If I `seq` a Unit, then that will `seq` it's position and health
21:59:28 <Tekmo> And when I se the position, since it is a Point, that will in turn `seq` the x and y fields of the position
21:59:34 <Tekmo> *when I `seq` the position
22:00:23 <Tekmo> If you open up the source for the `HashMap` module, you will notice that the hashmap type has bang patterns (i.e. exclamation marks) all the way down
22:00:26 <Tekmo> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.2/doc/html/src/Data-HashMap-Base.html#HashMap
22:00:48 <Tekmo> This means that if you `seq` a `HashMap` that will ensure the entire data structure is strictly evaluated
22:00:56 <haasn> What types of fields can be unpacked?
22:01:12 <Tekmo> Fields that are not polymorphic
22:01:38 <Shin-LaC> Tekmo: I haven't used seq yet
22:01:42 <haasn> Is there a reason strict fields aren't unpacked by default?
22:01:48 <haasn> (without -funpack-strict-fields or whatever)
22:01:52 <Tekmo> Shin-LaC: `seq` is a way that you can force things to be evaluated within Haskell
22:02:09 <Makoryu> Tekmo: Meaning "fields where no type information is carried around at runtime," or "fields which are not parameterized over any types?"
22:02:29 <haasn> Shin-LaC: seq is similar to pattern matching, except that it doesn't care about the type/constructor
22:02:31 <Tekmo> Shin-LaC: When you type "seq a b", it evaluates the "outermost level" of `a` and then returns `b`
22:02:36 <johnw> haasn: wouldn't they have to not only be strict, but also strict all the way down to be unpackable?
22:02:56 <haasn> > case undefined of _ -> ()
22:02:57 <lambdabot>   ()
22:03:04 <haasn> > case undefined of True -> (); False -> ()
22:03:05 <lambdabot>   *Exception: Prelude.undefined
22:03:10 <haasn> > undefined `seq` ()
22:03:11 <lambdabot>   *Exception: Prelude.undefined
22:03:16 <Tekmo> Makoryu: Basically: not this: data T a = T { x :: {-# UNPACK #-} !a }
22:03:19 <haasn> johnw: good point
22:03:36 <Shin-LaC> I see
22:03:43 <haasn> johnw: what happens if you {-# UNPACK #-} a field that isn't strict all the way down? or a polymorphic field?
22:03:50 <johnw> i was just wondering
22:04:01 <Tekmo> haasn: You can unpack something that is not strict all the way down
22:04:07 <Makoryu> Tekmo: ...Right! I forgot about the generic-pointer-code caveat
22:04:09 <johnw> oh, interesting
22:04:13 <Shin-LaC> and the idea is that if, for instance, have a list that is constructed by calling some function, I may want to built the whole list eagerly at once, when the function's code is in the cache
22:04:23 <Tekmo> here, let me pull up some slides by Johann that help a lot
22:04:23 <haasn> Tekmo/johnw: Oh, right, the indirections that are part of its own fields will just be unpacked this way, right?
22:04:29 <Shin-LaC> rather than having to bring back that function every once in a while to build the list in bits and pieces
22:04:40 <Shin-LaC> right?
22:05:09 <Tekmo> Everybody here who cares about performance should read this: http://www.slideshare.net/tibbe/highperformance-haskell
22:05:14 <haasn> Shin-LaC: the idea is that instead of a list, you use something like a strict unboxed vector
22:05:18 <Makoryu> Shin-LaC: Well, a list is probably a bad example...
22:05:21 <haasn> Tekmo: thanks!
22:05:25 <Tekmo> haasn: You're welcome!
22:05:36 <Shin-LaC> Tekmo: thanks
22:05:43 <Tekmo> Shin-LaC: You're welcome!
22:05:48 <haasn> (not that I care about performance, you should see my code ;)
22:06:00 <Shin-LaC> Makoryu: hm, ok
22:06:15 <Tekmo> haasn: :)
22:06:24 <Shin-LaC> haasn: but way, that's unboxing, isn't it?
22:06:34 <Tekmo> Shin-LaC: Those slides will also explain things like laziness and how to keep things strictly evaluated
22:06:34 <Shin-LaC> no wait
22:06:47 <Shin-LaC> yeah, I'll read the slides before continuing
22:07:34 <Makoryu> Shin-LaC: The native list type in Haskell does have some advantages when used as a control structure (ie. fusion) but as soon as you're actually storing data you want to avoid it like the plague
22:07:35 <haasn> Tekmo: now I just have to figure out how to view the next slide..
22:07:44 <Tekmo> haasn: Click the right arrow at the bottom of the slide shower
22:07:59 <Tekmo> You can also try the PDF version: http://johantibell.com/files/slides.pdf
22:08:05 <haasn> ...slide shower... I need a screen in my shower, no
22:08:12 <haasn> now* and thanks, that's much better
22:08:13 <Shin-LaC> THANKS for the pdf
22:08:17 <Tekmo> You're welcome
22:08:22 <Shin-LaC> I don't like slideshare
22:10:07 <Tekmo> johnw: Your part with `control` made a lot more sense to me than all the documentation in the `monad-control` package
22:10:19 <johnw> yeah, that documentation confused me for many months
22:10:55 <johnw> it's unfortunate too, since the core idea is so straightforward and useful
22:11:06 <johnw> the very beginning of the monad-control Haddock starts in pretty much the worst way possible
22:11:20 <carter> latermuse: yo!
22:11:24 <carter> things wen wellt?
22:11:59 <Tekmo> johnw: Wait, where is the `control` function within the library?
22:12:03 <johnw> yes
22:12:11 <Tekmo> johnw: Or did you just define it yourself?
22:12:17 <johnw> no, it's there
22:12:28 <johnw> because that pattern is so common, it's mainly the function you end up using
22:12:32 <ski> Makoryu : "data structures should be strict by default" would make writing incremental algorithms harder ?
22:12:38 <johnw> in fact, typically, "control" is pretty all you ever use!
22:12:45 <Tekmo> What is the type of `control`?
22:12:48 <ski> (also, i'm not quite sure what you mean by "*functions* are where you usually want your laziness)
22:12:52 <ReinH> edwardk: well, ping here probably
22:13:01 <johnw> control :: MonadBaseControl b m => (RunInBase m b -> b (StM m a)) -> m a
22:13:15 <carter> what lib is that?
22:13:19 <johnw> monad-control
22:13:35 <johnw> carter: we're discussing https://www.fpcomplete.com/user/jwiegley/monad-control
22:13:48 <Tekmo> ski: We mean "data" structures as in "not codata" structures :)
22:13:58 <Tekmo> i.e. finite structures designed to hold data
22:14:09 <Tekmo> as opposed to potentially infinite structures designed to be used for control flow
22:14:54 <Tekmo> So if you expand out `RunInBase m b`, you get: MonadBaseControl b m => (RunInBase m b -> b (StM m  a)) -> m a
22:14:57 <Tekmo> Oops
22:15:20 <Tekmo> MonadBaseControl  b m => ((forall x . m x -> b (StM x)) -> b (StM m  a)) -> m a
22:16:32 <johnw> MonadBaseControl  b m => ((forall x . m x -> b (StM m x)) -> b (StM m a)) -> m a
22:16:34 <Tekmo> Yeah
22:16:54 <ski> Tekmo : yeah. but consider various stream transducers
22:17:02 <Tekmo> ski: I know
22:17:09 <Tekmo> Those fall under control flow
22:17:16 <Tekmo> Those you don't want strictness annotations
22:17:26 <ski> ah, i see what you mean
22:17:44 <ski> how about something like a search tree for positions in a game ?
22:17:49 <Tekmo> Same thing
22:17:51 <Tekmo> Control flow
22:17:57 <ski> being control ?
22:17:58 <Tekmo> I consider linked lists to be a control flow structure
22:17:58 <ski> ok
22:18:22 <ski> well, at least if you use them ephemerally and incrementally
22:18:24 <Tekmo> Well, lazy linked lists, to be precise
22:18:29 * ski nods
22:20:34 <Tekmo> I still feel like there should be something more elegant than `monad-control`
22:20:46 <Tekmo> Even if it is just specialized to `bracket` or similar functionality
22:21:21 <johnw> I'd be interested to hear your ideas on that
22:21:27 <Tekmo> All zero of them :)
22:21:32 <johnw> it's useful for a lot more than just exceptions, though
22:21:36 <johnw> cf. lifted-
22:21:38 <johnw> lifted-async
22:21:57 <johnw> I also use this a lot: liftBaseDiscard forkIO $ someAction x
22:22:17 <johnw> so that someAction inherits the state from the monad transformer, but doesn't return back any changes to that state within the thread
22:22:24 <johnw> great for inheriting a logging function from MonadLogger, for example
22:24:56 <Tekmo> Well, I have some vague and inarticulate ideas
22:25:28 <Tekmo> First off, in each case the `monad-control` is basically using an isomorphism between the transformed monad and the base monad given some "existentially quantified return valu"
22:25:35 <Tekmo> In other words, something like:
22:26:07 <Tekmo> exists f . Iso (t m a) (m (f a))
22:26:17 <Tekmo> That is probably completely wrong, but humor it for a second
22:26:53 <Tekmo> Any time I have an existentially quantified isomorphism, I think "lens"
22:27:16 <Tekmo> See this post to see what I'm talking about: http://twanvl.nl/blog/haskell/isomorphism-lenses
22:27:31 <johnw> nice, I will read that
22:28:03 <Tekmo> So you can then use `Compose` to combine `m` and `f` into a single functor
22:28:14 <Tekmo> exists f . Iso (t m a) (Compose m f a)
22:28:22 <johnw> the isomorphism is between m a and b (StM m a), right?
22:28:34 <Tekmo> Yeah, that's the idea
22:28:42 <Tekmo> `StM m` is playing the role of `f`
22:28:48 <Tekmo> I may have it backwards
22:28:59 <johnw> i see where you're going
22:29:05 <edwardk> Tekmo: hah
22:29:06 <Tekmo> So, now let's take that isomorphism
22:29:10 <Tekmo> and lift it into a higher-order isomorphism
22:29:17 <Tekmo> i.e. an isomorphism between functors
22:29:29 <Tekmo> Iso' f g = forall a . Iso (f a) (g a)
22:29:35 <Tekmo> Something like that
22:29:45 <johnw> is that like an isomorphic natural transformation or something?
22:29:58 <Tekmo> Yeah, or something :)
22:30:16 <Tekmo> So then the idea is that `monad-control` could be trying to encode a higher-order lens on functors
22:30:21 <Tekmo> i.e. a lens from `m` to `b`
22:30:22 <johnw> right
22:30:28 <johnw> now prove it :)
22:30:37 <Tekmo> And then a miracle occurs!
22:30:39 <Tekmo> :)
22:30:58 <johnw> i like this line of thinking a lot though
22:31:04 <johnw> i will continue to ponder it, if you don't beat me to the punch
22:31:09 <Tekmo> Go ahead
22:31:18 <Tekmo> This is low on my list of priorities at the moment
22:32:05 <johnw> ok.  this could be just the thing we needed; snoyberg and I both agree that monad-control is invaluable -- and that it may need a better formulation to get it out of the slump it seems to be in
22:32:14 <edwardk> natural isomorphism
22:32:20 <johnw> ah
22:32:35 <Tekmo> What we want though is a natural lens!
22:32:52 <johnw> does lens support higher-order lenses?
22:33:34 <haasn> higher order lenses?
22:33:37 <edwardk> not currently. there is a notion of such a thing i've tossed around, but they don't compose with anything
22:33:49 <haasn> like, a lens from one lens to another?
22:33:59 <johnw> haasn: a lens that lets me focus on the functor, rather than the value
22:33:59 <Tekmo> A lens from a functor to a sub-functor
22:34:10 <haasn> ah
22:34:20 <johnw> that would be like a "structural" lens
22:34:48 <johnw> a telescope, really
22:34:59 <edwardk> haasn: well, if you think of Lens s t a b = (a -> f b) -> s -> f t   you could upgrade that to allow for things like (forall i. a i -> f (b i))  in the argument position
22:35:13 <edwardk> but then you need to play games with the result, and composition gets hairy
22:35:26 <haasn> yes
22:35:37 <edwardk> this is necessary to cover the existing usecases handled by MultiRec that lens can't do
22:35:49 <haasn> MultiRec?
22:36:09 <edwardk> er MultiCompos or whatever the thing used by jmacro internally.
22:36:31 <Tekmo> I have to go now, but keep me posted on your progress with this and if I have any more exact ideas I will let you know
22:36:45 <edwardk> http://hackage.haskell.org/packages/archive/jmacro/0.6.8/doc/html/Language-Javascript-JMacro-TypeCheck.html#t:Compos1
22:36:55 <johnw> Tekmo: sure, maybe we can even discuss at ICFP :)
22:37:06 <Tekmo> I won't be able to go
22:37:11 <johnw> NOOOOOO
22:37:13 <Tekmo> :(
22:37:16 <haasn> ‘eitherIsLeft :: Either a b -> Bool’ -- is _left  ;_;
22:37:18 <haasn> _Left
22:37:35 <edwardk> actually that seems to have lost its magic
22:37:39 <Tekmo> But definitely next year!
22:37:52 <Tekmo> Once I have more money and I'm not swamped with my thesis
22:38:42 <Tekmo> Alright, I'll talk to you guys later
22:39:16 <johnw> night, Tekmo
22:40:15 <joelteon> aw
22:40:19 <joelteon> i forgot to tell him i fixed my thing
23:38:24 <kwos> hello!
23:45:30 <ReinH> kwos: hi
