00:02:04 <haasn> for the record: it would have been (return . ("Current directory: " ++)) =<< getCurrentDirectory
00:02:20 <haasn> of course as applicative rightly pointed out, (return . f) =<< x = fmap f x
00:02:37 <haasn> (parens for safety, I keep forgetting the fixity on these)
00:02:59 <sp3ctum> oh so I was pretty close I guess
00:03:13 <joelteon> ohh
00:03:14 <joelteon> nvm
00:03:18 <sp3ctum> but a lot uglier
00:03:33 <haasn> yeah, or (\d -> return ("Current directory: " ++ d) =<< getCurrentDirectory
00:03:38 <shachaf> haasn: . has the highest stickiness.
00:03:46 <shachaf> (And $ has the lowest.)
00:03:51 <haasn> shachaf: 9?
00:03:56 <shachaf> Yes, 9.
00:04:03 <haasn> ok. Good to know!
00:04:06 <shachaf> But "highest" is easier to remember, and . is special.
00:04:21 <shachaf> I use the word "stickiness" because I could never remember which way precendence went.
00:04:25 <applicative> me demands fractional stickinesses
00:05:02 <shachaf> haasn: Not that I disapprove of extra parentheses for clarity.
00:05:11 <haasn> I want to specify stickiness in terms of relations to other operators! like (^.) should be lower than (.) but higher than ($)
00:05:14 <shachaf> And using fmap would've solved it anyway!
00:05:15 <haasn> and have GHC figure out the internal numbering
00:05:27 <hpaste> dmj pasted “haskell mode shturf” at http://lpaste.net/92873
00:05:27 <applicative> qualitative stickinesses now!
00:05:28 <shachaf> Yes, of course.
00:05:32 <dmj`> in haskell-mode.el there is a C-c C-r that is commented out, but would essentially let you send code to ghci *and* run it. I've uncommented it, eval'd the buffer, even restarted, can't seem to allow C-c C-r to work. Any ideas?
00:05:44 <dmj`> see paste above too
00:07:32 <applicative> ooo mr lato has gotten the snazzy 'posix-paths' traversals to work on os x. time to write 'du' all over again
00:14:42 * hackagebot wai-app-static 1.3.2.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.2.1 (MichaelSnoyman)
00:26:17 <johnw> applicative: or use 'sizes' :)
00:26:43 <johnw> i should update sizes to use posix-path traversals actually
00:29:42 * hackagebot crypto-cipher-tests 0.0.7 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.7 (VincentHanquez)
00:34:42 * hackagebot control-bool 0.2 - Useful combinators for boolean expressions  http://hackage.haskell.org/package/control-bool-0.2 (FumiakiKinoshita)
00:37:36 <Krisostoomus> check out this http://webchef.netau.net and comment on contact information->comments!
00:42:58 * haasn finds the usage of the word ‘traversals’ in applicative's statement to be disappointingly misleading
00:46:24 <akegalj> when i have case block testing Maybe a value, i do not need to cover all cases? haskell will drop down to next function after case (for example in do block)
00:46:45 <mauke> haskell will never drop
00:47:21 <akegalj> mauke: why then ghc compiles, and throws only "Non-exhaustive patterns in case
00:47:31 <akegalj> warning
00:48:22 <mauke> because it trusts you
00:49:01 <akegalj> mauke: why should it trust me if its not legal to not cover all cases?
00:49:26 <mauke> it is legal
00:49:48 <Phlogistique> it is also legal to write "a = a"
00:50:36 <akegalj> mauke: ok, i get the point
00:50:48 <mauke> Phlogistique: 2 = 3
00:51:52 <zyg> I cant install happy: Could not find module `Control.Monad.Writer'  running ghc 7.6.3
00:53:19 <shachaf> Orwell says: "Freedom is the freedom to say that two plus two make four." And that's certainly necessary. But freedom is also the freedom to say that two plus two make nineteen.
01:07:51 <shachaf> @remember Saizan <shachaf> Are you reading Mac Lane now? <Saizan> yeah, it's not so bad if you skip the examples
01:07:51 <lambdabot> I will remember.
01:08:06 <Saizan> :D
01:15:35 <arkeet> good quote.
01:15:45 <simon> http://lpaste.net/4967795492244160512 -- I'm using (==) on the result of floor(someDouble * 100) and I get this warning. I assume it's because it cannot infer which specific type I want to equate, because all floor gives is an Integral a. so my question is, is there a way to avoid this warning without type annotating e.g. floor(...)? (This is for an instance of Eq.)
01:17:53 <arkeet> simon: not really. you could define floor' :: blah -> Integer; floor' = floor  in a where clause or something, if you want.
01:18:10 * arkeet aside, wondering why *100 is outside the floor
01:19:51 * Maxdamantus would also wonder how likely it is that there should be an equality test on the rest of flooring doubles there.
01:21:06 <earthy> sounds fishy yeah
01:21:51 <Maxdamantus> >> floor $ (0.4 - (0.1 + 0.2)) * 10
01:21:57 <Maxdamantus> > floor $ (0.4 - (0.1 + 0.2)) * 10
01:21:58 <lambdabot>   0
01:22:15 <Maxdamantus> > (0.4 - (0.1 + 0.2)) * 10
01:22:17 <lambdabot>   0.9999999999999998
01:31:54 <kosmikus> Nimatek: hi
01:32:05 <Nimatek> kosmikus: Hey :)
01:33:21 <simon> arkeet, that's because it's an error. ;-)
01:34:43 <AnalogFile> google isn't good at googling symbols. what's the name of those patterns with a ~ ? I've seem them somewhere yesterday and I'm trying to figure out what they mean (no need for an explanation, just the name so I can google)
01:35:24 <Kinnison> I don't know their real name, but I think you might be talking about type unification thingies
01:35:33 <Kinnison> i.e. where you have things like a ~ b
01:35:39 <Kinnison> meaning that a and b must be the same type
01:35:45 <AnalogFile> thanks, will google that
01:35:47 <Kinnison> bicbw.
01:35:55 <dmj`> irrefutable patterns
01:35:56 <Kinnison> And as I said, that's probably not the real name
01:36:02 <Kinnison> dmj`: bingo :-)
01:36:15 <dmj`> http://www.haskell.org/tutorial/patterns.html
01:36:32 <AnalogFile> I think I've seen something like a lambda with that as the argument. Something like \ ~(a, b) ...
01:37:11 * Kinnison forgets that ~ can be used like that
01:37:12 <AnalogFile> oh, thanks.
01:37:14 * Kinnison is a numpty
01:37:18 <AnalogFile> lazy, that means!
01:38:12 <AnalogFile> ok, studying that tutorial (too many tutorials, lol)
01:38:23 <dmj`> AnalogFile: yes, Data.List is where I first encountered these wild beasts.
01:38:30 <dmj`> @src unzip4
01:38:30 <lambdabot> Source not found. Whoa.
01:40:46 <dmj`> > print "test"
01:40:48 <lambdabot>   <IO ()>
01:41:10 <quchen> AnalogFile: "Irrefutable patterns" is what you're looking for. (The linked article mentions the term in a few places.)
01:41:28 <dmj`> @def foo ~(Just x) = "hello"
01:41:29 <lambdabot>  .L.hs:170:1:
01:41:29 <lambdabot>      Equations for `foo' have different numbers of arguments
01:41:29 <lambdabot>   ...
01:44:00 <dmj`> @def hmmmm ~(Just x) = "hello"
01:44:01 <lambdabot>  Defined.
01:44:13 <dmj`> > hmmmm Nothing
01:44:19 <lambdabot>   "hello"
01:44:28 <dmj`> AnalogFile: ^
01:45:12 <Maxdamantus> @src windows8
01:45:12 <lambdabot> Source not found.
01:45:32 * Maxdamantus wonders why it said "Whoa" before.
01:45:57 <dmj`> > foo
01:45:58 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable L.F)
01:45:59 <lambdabot>    arising from a use...
01:46:20 <dmj`> Maxdamantus: being used for something else prob
01:46:57 <quchen> @undef
01:46:57 <lambdabot> Undefined.
01:47:04 <quchen> There you go.
01:47:50 <arkeet> since when is @def = @let ?
01:47:53 <Maxdamantus> > (\(a, (b, c)) -> if a == 0 then 0 else a*b*c) (0, undefined)
01:47:54 <lambdabot>   *Exception: Prelude.undefined
01:47:59 <Maxdamantus> > (\(a, ~(b, c)) -> if a == 0 then 0 else a*b*c) (0, undefined)
01:48:01 <lambdabot>   0
01:48:28 <arkeet> > fix $ \ ~(a,b) -> (0,1:b)
01:48:29 <lambdabot>   (0,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:48:40 <arkeet> > fix $ \ (a,b) -> (0,1:b)
01:48:47 <lambdabot>   mueval-core: Time limit exceeded
01:48:58 <satc> How to you write tests for types defined in other-modules rather than exposed-modules?
01:50:40 <AndChat228864> Given that the functional language(stateless) is a special case of stateful language, why do we need funtional languages? Maybe we can make our compiler smarter so that it can optimize for those cases.
01:50:54 <veryrandomname> I'm writing a default instance with GHC.Generics and my default instance loops because it can not distinguish between something like Int and SomeConstructor Int. They look nearly the same: from (5::Int): D1 GHC.Generics.D_Int (C1 GHC.Generics.C_Int (S1 NoSelector (Rec0 Int))) x and from $ Po (5::Int) : D1 Turtle.D1Po (C1 Turtle.C1_0Po (S1 NoSelector (Rec0 Int))) x. How do I distinguish between these without hardcoding their constructors? And wh
01:51:37 <Maxdamantus> AndChat228864: why have static types?
01:51:50 <AndChat228864> Also that too :)
01:53:25 <AndChat228864> Similar to asm.js fashion
01:54:07 <Maxdamantus> asm.js is basically a workaround.
01:54:26 <Maxdamantus> Why not just get it right from the start?
01:54:42 <dreixel> veryrandomname: if you post the whole code on hpaste or so, it's easier for me to have a look at what you're trying to do
01:54:46 <AnalogFile> thanks dmj` I think I'm getting them now. At least I'm getting enough. And I know what to google in case I'm unsure.
01:55:24 <veryrandomname> ok here's the code, ready to run https://gist.github.com/veryrandomname/6522738
01:57:17 <dmj`> AnalogFile: np
01:59:51 <SrPx> Wait, Haskell is just the lambda calculus with a type system that maks certain application illegal in compile time !
01:59:55 <SrPx> Eh
02:00:04 <SrPx> And that is probably obvious for everyone here
02:00:08 <SrPx> but I just realized that
02:00:26 <dmj`> SrPx: oh hey
02:00:32 <SrPx> dmj`: hey
02:00:40 <dmj`> SrPx: ;)
02:00:56 <SrPx> dmj`: do you know this site? http://okmij.org/ftp/
02:01:30 <dmj`> SrPx: no, but looks intellesting..
02:01:48 <Maxdamantus> Haskell is the lambda calculus typed by the simply typed lambda calculus.
02:02:00 <exicer> What is the suggested library to do css-selector like html parsing ?
02:02:17 <dmj`> SrPx: So this is where all the good haskell resources have been hiding
02:02:23 <dmj`> exicer: HXT is good
02:02:34 <dreixel> veryrandomname: Int is a base type, you really need to define the |instance Interpolate Int|
02:02:34 <dmj`> exicer: http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
02:03:13 <dreixel> veryrandomname: else it gets resolved to |Rep Int|, which is basically |K Int|, which again requires the |Interpolate Int| instance, and your code loops.
02:03:17 <exicer> Someone mentioned xml-conduit to me - any idea how the two compare ?
02:03:58 <veryrandomname> dreixel: exactly! I just wasn't able to communicate that, but I hoped there is another option to defining the base case
02:04:37 <dmj`> exicer: tagsoup is good too, never used xml-conduit
02:04:39 <veryrandomname> dreixel: and I wonder why Ints generic description looks as if it had a constructor
02:05:07 <dreixel> veryrandomname: well, no. the base case is pretty much part of the semantics of your function. no one can guess what interpolating Ints means...
02:05:46 <veryrandomname> dreixel: I just thoght it may work because it works for Bool
02:06:06 <dreixel> veryrandomname: oh, but Bool is not really a base type. it's just a choice between two units.
02:06:41 <dreixel> veryrandomname: it will work for lists and maybe too... but not for Int, Float, Char, ...
02:06:44 <exicer> Huh, so after a quick noob scan, it seems like conduits and arrows are pretty similar ?
02:06:52 <veryrandomname> dreixel: isn't Int just a choice between an infinite number of units?
02:07:15 <dreixel> veryrandomname: well, yes, but that's not an algebraic datatype. it's baked-in
02:07:50 <dreixel> veryrandomname: if you define |data Nat = Z | S Nat deriving Generic|, it'll work for those numbers.
02:08:16 <dreixel> but Int isn't really defined as data Int = 0 | 1 | 2 | -1 | -2 | ...
02:08:23 <dreixel> so that's also not its generic representation.
02:08:40 <arkeet> Int is defined as data Int = I# Int#
02:08:43 <arkeet> and Int# is magic.
02:08:49 <dreixel> exactly
02:09:04 <dreixel> for generic-deriving purposes, though, Int is opaque. I don't even go into Int#
02:09:08 <arkeet> quite.
02:09:15 <veryrandomname> can magic be added afterwards? or am I safe if I define my function for all current magic types
02:09:17 <dreixel> type Rep0 Int = K0 Int
02:09:18 <dreixel> and that's it
02:09:32 <dreixel> veryrandomname: magic can always be added later, but so can instances.
02:09:41 <dreixel> what you should not do is define empty instances for base types :)
02:09:52 <dreixel> now you get a loop. if you don't define the instance, yuo'll just get a missing instance error
02:09:59 <veryrandomname> dreixel: how can I do that?
02:10:06 <veryrandomname> dreixel: I want just that!
02:10:16 <dreixel> remove line 34 of your code
02:10:30 <dreixel> though you actually want to fill something into line 35, I think.
02:10:37 <dmj`> exicer: conduits are iteratees, arrows are more like boxed computations
02:11:15 <veryrandomname> dreixel: what would I want to fill in there?
02:11:34 <dreixel> veryrandomname: I don't know. whatever interpolateInt :: Double -> Int -> Int -> Int should do.
02:11:48 <dreixel> if such function doesn't make sense, then indeed you just want to remove the instance altogether
02:12:00 <dreixel> and users cannot interpolate values containing Ints in them.
02:12:55 <veryrandomname> dreixel: i think a int instance of interpolate is ambigious, can users overwrite isntances later with some extension if they don't like mine?
02:13:12 <dreixel> veryrandomname: no, instances are global.
02:13:32 <dreixel> they would have to define a newtype MyInt = MyInt Int, and use and give an instance for that instead.
02:13:41 <veryrandomname> dreixel: so I just won't define them, ok. thanks for your help
02:13:48 <Lethalman> that's the unfortunate thing about haskell type classes :(
02:13:51 <dreixel> veryrandomname: glad I could help ;-)
02:14:00 <arkeet> veryrandomname: you should define them.
02:14:03 <arkeet> if only because no one else should define them.
02:14:07 <arkeet> because orphan instances are sad.
02:14:09 <Lethalman> if there's an Ord a => a and you can't specify a custom ordering for a, you're dead
02:14:34 <dreixel> arkeet: that's a good point. but if you argue that there's no clear choice...
02:14:44 <dreixel> arkeet: it's like Monoid for Int, perhaps
02:14:54 <arkeet> :(
02:16:12 <veryrandomname> I could just implement the instance I like the most and if everyone else hates it I'll change it. I think its really annoying for the user to define interpolate for int
02:16:17 <mstksg> anyone here ever run into problems with deploying to heroku?
02:16:59 <dmj`> mstksg: yes
02:17:01 <veryrandomname> mstksg: I tried it once, but getting all the heroku specic information on runtime was too annoying for me
02:17:25 <dmj`> mstksg: worked on that for like 2 hours today
02:17:49 <dmj`> mstksg: finally got it to work tho: https://github.com/dmjio/scotty-starter
02:17:55 <mstksg> i have uploaded small projects before, but this is my first time trying to do one of a large scale ish
02:18:10 <mstksg> things seem to go well until it tries to compile the libraries from cabal
02:18:25 <mstksg> about ten or twenty mionutes in each time, it just randomly stops
02:18:31 <mstksg> and says buildpack fail
02:18:32 <mstksg> :/
02:18:35 <dmj`> mstksg: what buildpack are you using? are you using yesod?
02:19:06 <mstksg> i'm using scotty, and i've been trying out different forks of that haskell buildpack on github that has a hundred forks
02:19:58 <dmj`> mstksg: Check out my starter-kit project I posted above. Its on heroku, paste your failed terminal output. You want to use puffnfreshs's buildpack
02:20:18 <merijn> I wonder what happened that changed proposals like bool/AMP/etc from only being bikeshed into getting almost universal acceptance...
02:20:28 <merijn> Did libraries@ just grow tired of the nonsense? :>
02:20:48 <mstksg> dmj`: sure, give me a sec
02:21:57 <quchen> merijn: Continuous poking?
02:22:28 <quchen> merijn: AMP warnings were merged today by the way :-)
02:22:37 <dmj`> mstksg: this might help you too: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
02:24:00 <merijn> quchen: \o/
02:24:13 <merijn> quchen: It looks like bool is finally on it's way into the libraries too
02:24:13 <quchen> merijn: I think what makes a big impact is when the proposal starts with something the majority accepts, and when the alternatives aren't good enough to object. For example `cond` was suggested in the `bool` discussion as a remark, and it quickly became "`liftA3 bool` does that".
02:24:47 <merijn> Time to move my "oldest supported GHC version" from 7.6 to 7.8 >.>
02:25:21 <quchen> Everyone agreed the AMP is would be a good thing for (apparently) a long time, and the discussion often got lost in "remove return? remove pure, move return?"
02:25:33 <jsch> i just tried to update cabal-install, which fails with "cannot satisfy -package-id HTTP-4000.2.8-cdf033f9d7051824f52cd5101df67509" - is that a known issue in some way? am i missing something?
02:25:50 <quchen> There wasn't much attack surface beyond inertia
02:26:06 <mstksg> dmj`: yeah, i was following the deploy instructions from that blog post
02:26:07 <quchen> Similarly I'm hoping the Foldable/Traversable topic is resolved
02:26:30 <mstksg> i have followed them in the past and they've worked for me, it's just this project that seems to be giving me problems, and always at a different package download every time
02:26:46 <merijn> quchen: Wasn't it already accepted and in "bikeshed implementation phase"?
02:27:09 <quchen> merijn: Foldable/Traversable? Not sure. There were some concerns with fusion.
02:27:10 <merijn> quchen: I thought the only objection was "what if monomorphic code becomes less efficient?" and people proposing to benchmark things
02:27:42 <mstksg> dmj`: i'm pushing two copies of the starter kit to heroku; one unchanged and the other with all of the packages my actual app is using in the cabal file
02:28:10 <dmj`> mstksg: are you specifying version #'s for each dep?
02:28:29 <quchen> merijn: "Proposing to benchmark things" is like a roadblock that nobody is really keen on getting rid of though
02:28:53 <mstksg> dmj`: i didn't at first, but those errors showed up on the log pretty clearly
02:29:00 <mstksg> as version conflicts, etc.
02:29:17 <mstksg> but in my case it just crashes unexpectedly during a compile/configuration
02:29:42 <mstksg> i could try to go and add them all, i was rather careless with keeping my cabal file up to date
02:30:21 <hpaste> jsch pasted “failing update: cabal-install” at http://lpaste.net/92874
02:30:59 <quchen> merijn: Is there any other "big" desirable change apart from reworking Prelude and Foldable/Traversable though?
02:31:12 <quchen> The only thing I could think of is moving fail to its own typeclass maybe
02:31:24 <dmj`> mstksg: hard to know w/o seeing logs
02:31:27 <quchen> But apart from that the biggest bumps seem to be gone or at least in scope
02:31:47 <mstksg> dmj`: where can i find these logs?  what is outputted by `heroku logs` does not illuminate anything
02:33:14 <arkeet> I don't know how one would move fail to its own typeclass. :<
02:33:42 <dmj`> just copy whats in your stdout and put it on lpaste after you run git push heroku master, and your cabal file. Were you able to push the starter-project(s)?
02:34:19 <mstksg> dmj`: unmodified starter project deploys without any problems, still waiting on the one with the extra packages
02:34:58 <dmj`> good
02:37:35 <satc> merijn: What is the usual way to write tests for types (and/or constructors) which I dont want to expose and hence are in other-modules?
02:37:45 <dmj`> mstksg: in other news, blaze is kick ass. Just ran blaze-from-html on the html5 boilerplate index.html, generates haskell code. Every other web framework I know of reads html from disk.
02:38:20 <mstksg> i do love blaze
02:38:55 <mstksg> it helps me keep in haskell mode throughout my entire workflow
02:39:10 <nh2> satc: I think you can't cleanly. That is a big problem also for me
02:40:12 <nh2> satc: you can do the following: give your cabal test-suite the same source directory as the library. Then it can use all code (no mattter if exposed or not, because it just uses the source files) and you can test it
02:40:47 <nh2> the problem with that now your executable can no longer cabal-depend on your library, which means all code will be compiled twice when you enable tests
02:40:50 <dmj`> mstksg: what are you using on the client-side?
02:40:56 <dmj`> for js
02:41:01 <nh2> satc: does that make sense?
02:41:03 <quchen> arkeet: That one would be tough, yeah.
02:41:34 <arkeet> yeah. it doesn't belong in Monad, but it's needed for the desugaring. :<
02:41:37 <arkeet> sort of
02:41:45 <dmj`> mstksg: there's some clay CSS in there as well...
02:41:45 <nh2> quchen: so how does that currently work with fail? Will Just 3 <- Just 3 fail to compile?
02:41:47 <mstksg> dmj`: ah.  well that admittedly the main gap in my workflow.  sass as well, sort of.
02:42:11 <quchen> arkeet: Not really. Think of desugaring "fail" to "const mzero". The block will get a MonadPlus constraint, done.
02:42:19 <merijn> satc: Usually the approach is to have a Internal.hs that exports those types (but not exporting that module from your package) and write your tests using that, re-exporting the relevant bits elsewhere
02:42:28 <arkeet> quchen: I don't like that.
02:42:32 <arkeet> what if I don't have a MonadPlus?
02:42:40 <quchen> arkeet: That's where MonadFail comes in.
02:42:45 <mstksg> haven't looked at clay before; it seems interesting
02:42:55 <merijn> Speaking of this, btw
02:43:02 <arkeet> quchen: so are you saying the desugaring should depend on what instances are in scope?
02:43:19 <nh2> quchen: yes that was my question, when I don't have MonadFail, will it fail to compile with <- pattern matches? I'd find that great
02:43:21 <dmj`> mstksg: would be nice if there was a from-clay-css to convert to haskell
02:43:26 <arkeet> I think that's even more evil than fail being in Monad, tbh.
02:43:27 <merijn> I just recently saw a Racket talk where they determined exports by phase, so you could export different things during testing then during compilation
02:43:38 <mstksg> dmj`: huh. it's basically a edsl for css like blaze is for haskell
02:43:43 <mstksg> i could definitely grow to like this
02:43:44 <quchen> arkeet: No, MonadPlus was just the easiest example. If you desugar what currently becomes "Monad.fail" to "MonadPlus.fail" if there's a non-irrefutable pattern, then you could add a MonadFail constraint on the whole thing.
02:43:46 <merijn> This would allow you to not have to export internal functions while still being able to test them
02:44:03 <quchen> arkeet: Woops, s/MonadPlus/MonadFail there
02:44:06 <nh2> arkeet: why do you find that evil?
02:44:31 <hpaste> Justin pasted “heroku deploy failure” at http://lpaste.net/92875
02:44:35 <dmj`> mstksg: yea, but let's say I already have a large .css file, re-coding that by hand into clay would be tedious. Would be nice to have a converter
02:44:41 <arkeet> nh2: changing behaviour depending on what instances are in scope?
02:44:53 <quchen> nh2: Well, that's debatable. Suppose Maybe has no MonadFail instance, then yes, "Just 3 ← X" should fail with a type error.
02:44:57 <mstksg> dmj`: here is the log of my most recent attempt at deplying to heroku http://lpaste.net/92875
02:45:07 <mstksg> i omitted a bunch of lines in the middle
02:45:14 <arkeet> I don't think it should ever fail to compile, either. just like how "let 3 = blah" shouldn't.
02:45:27 <quchen> nh2: On the other hand, if you're matching against a newtype, maybe there shouldn't be a constraint, like in "Identity x ← FOO".
02:45:32 <quchen> But those are details.
02:45:35 <nh2> I wish that failed to compile too !
02:45:37 <arkeet> or let x:xs = blah, for a less contrived example.
02:45:40 <arkeet> nh2: I'm fine with a warning.
02:45:50 <dmj`> mstksg: post .cabal too
02:45:56 <arkeet> unfortunately, not enough people use -Wall.
02:46:07 <nh2> arkeet: I guess you worry about multiple MonadFail instances for the same thing?
02:46:10 <arkeet> no.
02:46:15 <quchen> arkeet: -W is not enough for warnings here?
02:46:26 <nh2> quchen: right about newtype
02:46:35 <dmj`> mstksg: that's quite abrupt, you sure that's all of it
02:47:09 <arkeet> quchen: anyway I'm just saying.
02:47:12 <arkeet> there's no clear good way of doing this.
02:47:31 <mstksg> dmj`: yup, it happens every time, and at a different line
02:47:42 <quchen> That may be true, but I would also say that there are many ways that are clearly better than what we currently have.
02:47:47 <mstksg> i suspect it might be a timeout issue
02:47:52 <dmj`> mstksg: is multipackapp the name of the buildpack?
02:48:02 <mstksg> yeah, multipackapp is
02:48:14 <quchen> arkeet: In the light of the ad-hoc AMP warnings, one could emit things like "warning, this bining may fail, but your type has no Fail instance" to ease transition at least.
02:48:20 <mstksg> but the same thing happens when i use the haskell buildpacks
02:48:36 <mstksg> multipackapp lets me run ruby buildpack scripts so i can download gems like compass
02:49:01 <nh2> quchen: I guess that kind of warning could already be displayed without -Wall?
02:49:19 <mstksg> dmj`: cabal file https://github.com/mstksg/Blog/blob/f-heroku_test/blog.cabal
02:49:51 <mstksg> version numbers are missing but it installs cleanly on a fresh system
02:50:06 <quchen> nh2: Let's see. (In my experience -W is usually enough and -Wall is annoying.)
02:51:19 <mstksg> the scotty starter kit + extra packages in cabal file is still hanging on the "Updating cabal" stage.  not sure why
02:51:43 <quchen> nh2: I think shadowing and missing type sigs are what -Wall mainly complains (and that are sometimes useful). Haven't had a useful "unused do bind" warning yet.
02:51:57 <mstksg> it doesn't even say "downloading the latest ..."
02:52:30 <dmj`> mstksg: does it install locally?
02:53:23 <mstksg> dmj`: ah, right, should have checked that.
02:53:41 <mstksg> well, it doesn't, because i have a different version of base
02:53:59 <merijn> And my new favorite quote is...
02:54:03 <merijn> @quote elliott DLC
02:54:03 <lambdabot> elliott says: lens is the DLC expansion pack for Haskell
02:54:16 <mstksg> let me see if it installs if i change it to 4.6
02:55:05 <mstksg> thank you for the help by the way, i've been stuck on deploying for the past few days.  i've been looking at alternative hosts but keep on running into unrelated problems
02:55:10 <nh2> quchen: I see. I think shadowing is bad though, because it can hide unused variable warnings
02:55:39 <mstksg> dmj`: i do fear that changing base to 4.6 might break the buildpack
02:56:18 <dmj`> mstksg: I would start small, add features in incrementally. We know the starter-kit works, now begin porting in db access etc, testing locally, then deploying and ensure that it runs. Baby steps, we're in unchartered territory
02:57:15 <mstksg> dmj`: yeah, that would probably be the smartest thing to do.  might be time now to stop trying to rush things and just take it one step at a time.
02:58:41 <dmj`> mstksg: and if you get heroku to recognize your favicon.ico from scotty do tell. Time for sleep
02:59:25 <mstksg> thank you for the help
03:00:00 <quchen> arkeet: I just found the Gist I've written about MonadFail a couple of months ago. https://gist.github.com/quchen/5642483 It's basically what I've said above, and I don't see any obvious bad things about it.
03:00:11 <dmj`> mstksg: np, will be cool to see your app
03:01:21 <arkeet> quchen: why should one constructor cause a warning?
03:02:43 <arkeet> it should definitely say: let f ~pattern = more
03:03:06 <arkeet> or something
03:05:22 <quchen> arkeet: Yeah, one constructor should probably also not create a MonadFail requirement.
03:06:02 <quchen> Wait, that's what the gist says anyway.
03:07:01 <quchen> (By "adding MonadFail constraint" I mean using MonadFail.fail and having the typechecker add the constraint, not some voodoo magic.)
03:11:41 <supki> we already have unused-do-bind thing, let's not add another stupid warning
03:13:01 <nh2> supki: unused-do cannot make your program break though
03:13:33 <merijn> I think a fail warning would be much better than unused-do
03:14:06 <nh2> merijn: full ack
03:17:09 <merijn> I always have unused-do disabled, but I'd enable fail warnings
03:19:23 <h007> parallel haskell question: is (rpar `dot` rdeepseq) the same as doing (rparWith rdeepseq)?
03:45:47 <mm_freak_> sometimes a seq-like non-IO combinator for 'yield' would be handy
03:46:01 * arkeet wonders what that is
03:46:08 <mm_freak_> fair x  -- like x, but when evaluating this, first see if other threads are waiting
03:46:16 <arkeet> hm
03:47:04 <merijn> mm_freak_: "unsafePerformIO yield; {-# PRAGMA NOINLINE #-}" ;)
03:47:48 <mm_freak_> well, yeah
03:47:54 <mm_freak_> fair x = unsafePerformIO (yield >> return x)
03:48:12 <mm_freak_> but i'm sure there is a more efficient primitive implementation =)
03:50:37 <quchen> h007: The docs answer your question: "instead of saying rpar dot strat, you can say rparWith strat." http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html#v:rparWith
03:51:43 <quchen> In other words, rparWith is preferrable.
03:53:46 <h007> quchen: great! I've been using rpar `dot` most of the time, as it's composable. but surely rparWith seems more appropriate in most cases
03:57:26 <merijn> mm_freak_: Are you sure? Yield should be pretty cheap, I'm not sure about the cost of unsafePerformIO, but surely that's not very expensive?
04:00:11 <exicer> In the Text.XML package from xml-conduit, there is a function readFile :: ParseSettings -> FilePath -> IO Document. In an example I'm looking at, it is used as follows: doc <- readFile def "test.xml"
04:00:19 <nh2> somebody with ghc 7.4 around who can test if my library compiles?
04:00:20 <exicer> I can't work out what def is - how should I do so ?
04:01:13 <nh2> exicer: def is a typeclass function from http://hackage.haskell.org/packages/archive/data-default/0.5.3/doc/html/Data-Default.html
04:01:22 <nh2> it gives you the default value for some datatype
04:02:42 <exicer> nh2: Ah. Okay!
04:02:46 <exicer> Thanks
04:19:20 <mm_freak_> merijn: i'm worried mainly about the cost of (>>)
04:19:47 <arkeet> (unsafePerformIO yield `seq`)
04:20:20 <arkeet> I have no idea if this does anything anyone would expect.
04:20:25 <tpsinnem> monad transformer noob question: can i turn a 'Nothing' into a value of 'MaybeT foo bar' ?
04:20:40 <tpsinnem> and if, how
04:21:07 <arkeet> tpsinnem: mzero works.
04:21:08 <donri> merijn: there is a bit of overhead for checking that the iO is only performed by one thread
04:21:37 <arkeet> tpsinnem: not exactly sure what you mean by "turn into"
04:21:44 <donri> merijn: unsafeDupablePerformIO can be much cheaper, and even more unsafe ;)
04:21:56 <mm_freak_> arkeet: that could work actually
04:22:02 <byorgey> @type MaybeT
04:22:03 <lambdabot> Not in scope: data constructor `MaybeT'
04:22:11 <arkeet> @let import Control.Monad.Trans.Maybe
04:22:12 <lambdabot>  Defined.
04:22:25 <tpsinnem> arkeet: well perhaps the better question is, is there a 'Maybe a -> MaybeT foo a' ?
04:22:32 <byorgey> tpsinnem: MaybeT . return
04:22:44 <arkeet> :t MaybeT . return
04:22:44 <lambdabot> Monad m => Maybe a -> MaybeT m a
04:23:15 <arkeet> :t mapMaybeT (return . runIdentity)
04:23:16 <lambdabot> Monad n => MaybeT Identity b -> MaybeT n b
04:23:22 <arkeet> hm, not quite.
04:23:25 <donri> merijn: it's NOINLINE though. text and bytestring both have internals for "inlinePerformIO" which is the super unsafe version of INLINEd unsafeDupablePerformIO
04:23:27 <tpsinnem> arkeet, byorgey: ok thanks a much!
04:23:42 <arkeet> :t maybe mzero return
04:23:43 <lambdabot> MonadPlus m => Maybe a -> m a
04:23:49 <arkeet> tpsinnem: I like this better ;)
04:26:36 <donri> the errors package provides hoistMaybe = MaybeT . return
04:41:41 <tpsinnem> a follow-up question to the previous: would there have been some natural thing to study that would've made me inclined to look at 'Maybe . return' on my own?
04:41:55 <tpsinnem> uh
04:41:58 <tpsinnem> MaybeT . return
04:42:50 <donri> tpsinnem: well for one newtype MaybeT m a = MaybeT (m (Maybe a)) :)
04:43:00 <Maior> Any advice on why https://github.com/doismellburning/hogstash/blob/master/hogstash/hogstash.hs#L13 (which uses https://github.com/doismellburning/hogstash/blob/master/hogstash/inputs/redis.hs#L31) might end up causing `Too many open files` for something DNS-y?
04:43:01 <b__> After updating ghc-mod to 3.0.0 ghcmod-vim doesn't seem to work for me
04:43:52 <b__> Anyone else having problems with it? The qf window doesn't come up after calling make and check
04:44:02 <b__> I have to Ctrl-C and then it does
04:45:58 <donri> b__: did you update ghcmod-vim and vimproc?
04:46:04 <b__> yes
04:46:22 <tpsinnem> donri: ok - i'm reading http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html though, and it displays that info a bit differently
04:46:27 <donri> b__: did you try it before updating those?
04:46:35 <b__> yes
04:46:35 <tpsinnem> got to get better used to reading these i suppose
04:46:51 <DMcGill> are there uses of unsafeCoerce that don't involve converting between newtypes? Something to do with Ptrs or Ints?
04:46:53 <tpsinnem> in addition to getting used to reading 'newtype' as in many ways the same as 'data'
04:46:59 <donri> tpsinnem: that's just record notation :)
04:47:04 <tpsinnem> yeah
04:47:46 <donri> MaybeT { runMaybeT = return Nothing }
04:47:48 <donri> same thing
04:48:50 <donri> DMcGill: are you asking about "safe" uses or any uses?
04:49:04 <DMcGill> I'm just curious mostly, feel free to answer either.
04:49:06 <donri> DMcGill: you can unsafeCoerce any a to any b (but some will segfault)
04:49:16 <tpsinnem> yeah -- i'm basically on my first haskell project so i have quite a few blind spots even on the basics
04:49:37 <DMcGill> I guess then 'any uses' is an uninteresting question. How about "safe" or "legitimate" uses?
04:50:02 <kayloos> How does (+++) and (<|>) differ from each other when writing a parser using ReadP? Isn't (<|>) also symmetric choice? (and what does symmetric choice actually mean?)
04:50:44 <donri> DMcGill: Typeable cast uses unsafeCoerce safely and legitimately
04:51:03 <donri> assuming your Typeable is derived, which is enforced in HEAD
04:51:58 <donri> kayloos: <|> = mplus = +++
04:52:03 <DMcGill> kayloos: (<|>) is from Alternative, (+++) is for ReadP only. (<|>) for ReadP is defined as (+++) so there's not much difference for your case
04:52:43 <DMcGill> you'll get more annoying error messages by using <|>
04:53:16 <donri> OTOH you can write an implementation agnostic parser with <|> :)
04:53:20 <donri> @hackage parsers
04:53:20 <lambdabot> http://hackage.haskell.org/package/parsers
04:53:30 <kayloos> Ah, ok... I was confused because I've been used to using (<|>) using Parsec and I was wondering what this new (+++) was.
04:53:36 <kayloos> DMcGill: How are they more annoying?
04:53:54 <DMcGill> It's interesting how attoparsec gives a 'try' function which is a no-op, just for compatibility with parsec source
04:54:40 <donri> try = id for the ReadP Parsing instance too :)
04:54:41 <DMcGill> kayloos: instead of "expected type ReadP x" you'll get "expected type Applicative a => a x" or something similar
04:55:08 <kayloos> Yeah, I can see how that is a bit more confusing
04:55:21 <DMcGill> in some situations that is anyway
05:02:48 <ment> hi, any suggestions for weird virtual machines? (something akin balance from icfp, but i'm open to anything as long as its small)
05:06:16 <Phlogistique> [A
05:12:14 <danilo2> Hello :) Does anybody knows if is it possible to generate an Instance of typeclass "X", having implementation of it method? Im thinking about some automatic soltion - to reify the signature of such function and SOMEHOW tell Haskell to assign appriopriate parts of signature to the params of typeclass?
05:13:46 <danilo2> like for exampel we have class: class X a b c | a b -> c where x :: a b -> c and a function f :: (A Int) -> Int; f (A a) = a ?
05:17:08 <donri> danilo2: i don't understand what you're asking
05:25:01 <supki> danilo2: what do you mean by "generate"?
05:26:05 <supki> danilo2: you can construct instances in runtime with reflection package, if that's what you're asking for
05:29:49 * hackagebot postgresql-simple 0.3.7.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.7.1 (LeonSmith)
05:51:34 <danilo2> supki: I want to "generate the code" - not in runtime - in compile time
05:52:14 <donri> danilo2: you'd usually use generics or templates to generate instances
05:52:53 <danilo2> donri: I'm asking about something like this: We ave defined class X a b c | a b -> c where x :: a b -> c AND function f :: (A Int) -> Int; f (A a) = a AND I want to generate automaticvally the following "code": instance X A Int Int where x = f
05:53:13 <danilo2> donri: And I want to generate it in compile time
05:54:57 <donri> may need TH for that
05:58:00 <Tinned_Tuna> If you see an example where OverloadedStrings is used, how easy is it to convert the snippet of code away from using OverloadedStrings?
05:59:08 <shiona> is there a nice way of making (x, Maybe y, z) into Maybe (x, y, z) ?
05:59:26 <mauke> Tinned_Tuna: mostly trivial
05:59:42 <Iceland_jack> shiona: That is a very odd request imo
05:59:55 <int-e> Tinned_Tuna: it's a matter of importing Data.String and then using fromString wherever the typechecker complains about something being a string instead of something else
06:00:14 <Iceland_jack> So I'm guessing (a, Just x, y) ↦ Just (a, x, y); (a, Nothing, y) ↦ Nothing?
06:00:24 <Iceland_jack> What do you need it for?
06:00:42 <int-e> (or just insert a 'fromString' call on all string literals)
06:00:54 <shiona> I'm running parallel computation for LTS's. I'm checking if two LTS's can make the same transition
06:01:09 <tomejaguar> Iceland_jack: it's not odd at all.  It's basically traverse.
06:01:09 <Tinned_Tuna> int-e: then ... why do we even need OverloadedStrings, if the process for making it run without is usually trivial?
06:01:12 <shiona> and if they can it returns the end point of the transition, if not then nothing
06:01:16 <tomejaguar> Err I mean sequence.
06:01:32 <Iceland_jack> tomejaguar: sequence for tuples where only a single value is a Maybe?
06:01:51 <shiona> but since I'm making new transitions, I need also the start point and the alphabet used for the transition
06:01:52 <int-e> Tinned_Tuna: it's just eye candy
06:02:02 <Tinned_Tuna> int-e: fair enough
06:02:27 <int-e> Tinned_Tuna: "foo" is nicer to read than s"foo" or (s"foo") which is about the shortest you get without extensions.
06:05:01 <tomejaguar> Iceland_jack: Well, this is exactly what a lens gives you.
06:05:36 <Tinned_Tuna> int-e: is it bad that I have some form of inate hatred of language extensions?
06:05:53 <tomejaguar> Tinned_Tuna: No, it's good.  Or at least I have it too, so I hope it's good :)
06:06:02 <Iceland_jack> tomejaguar: Sure, but those types indicate codesmell to me
06:06:14 <tomejaguar> Iceland_jack: The types of a lens?
06:06:22 <Iceland_jack> No, that particular type
06:07:06 <Tinned_Tuna> tomejaguar: lol, it makes me think that we need a tiny haskell compiler that implements Haskell2010, for so that we have two compilers to do things like John Regher is doing with C compilers (basically, highly advanced randomised bug testing)
06:07:21 <Tinned_Tuna> although, you'd need 3 compilers for his methodology to work ;-)
06:07:38 <tomejaguar> Tinned_Tuna: This is a good idea, but the community doesn't currently have the manpower, AFAICS.
06:08:01 <Tinned_Tuna> tomejaguar: this is saddening :-(
06:10:27 <donri> i think maybe it'd be more valuable to make existing compilers standards-compliant. you can simply opt not to enable extensions, you know.
06:11:19 <int-e> tomejaguar: I suspect the manpower would be there, but we need a much better reason than "try and keep ghc in check".
06:11:22 <donri> it's rather silly how haskell2010 depends on base rather than the other way around, for starters
06:11:58 <danilo2> donri: I'm sorry I had a phone call and now I'm back
06:11:59 <int-e> And a lot of the extensions in ghc are exciting and useful. It's hard to stay away from them. Finally, ghc *is* a research project.
06:12:08 <danilo2> donri : I know TH could be used for that (and reify in TH)
06:12:39 <danilo2> donri: but I'm asking if ist it possible to automatically assign in TH parameters of typeclass to apprioriate function signature parts
06:13:24 <donri> danilo2: there is no way (without hacks) in TH to see what's in scope without knowing its name
06:13:37 <donri> danilo2: you'd have to pass in 'f to the splice
06:14:29 <danilo2> donri: Yeah, I'm passing the ''X, 'f and 'x, but the problem is in "matching" the signature of f to the params of X
06:15:44 <tomejaguar> shiona, Iceland_jack: http://lpaste.net/92880
06:15:51 <hpaste> romildo pasted “parser for natural number” at http://lpaste.net/92881
06:16:00 <donri> danilo2: you can reify the names to get those type signatures, and you can compare the nodes for equality, but i think you'd have to implement a type checker to do it "properly"
06:16:28 <romildo> What is the most general type for the parser at http://lpaste.net/92881 ?
06:16:52 <danilo2> donri: I was afraid the answer will be lie that, but ok - I'm able to do it manually but with a little more effort from me :)
06:16:58 <danilo2> danri: thanks :)
06:17:20 <merijn> ocharles: The way to contribute patches to base is to just open a ticket on the GHC Trac with a path and a link to the mailing list discussion
06:18:19 <paolino> @hoogle Identity
06:18:20 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
06:18:20 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
06:18:20 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
06:18:21 <donri> danilo2: though you might be able to automate it under certain constraints, if there is sufficient generality. like, it isn't hard to do things like "get the type of the first argument to this function"
06:19:03 <donri> danilo2: but if you want/need full type inference, well, you need a type inference engine and TH doesn't quite provide that
06:19:17 <danilo2> donri: yeah, i know it, buit I was thinking of automatic matching the signature to type class params
06:19:49 <donri> danilo2: well that does sound like type inference / unification :)
06:20:00 <romildo> @pl \d n -> 10*n + d
06:20:03 <lambdabot> flip ((+) . (10 *))
06:20:03 <lambdabot> optimization suspended, use @pl-resume to continue.
06:20:33 <donri> romildo: you can :load the file in ghci and look at :type natural
06:20:57 <danilo2> donri: I know, but I was thinking that maybe TH gives access to some inferencel ike this. If I can reify functions to see their signature I wast thinkign that there is something like reify to match signatures against template classes :)
06:20:58 <donri> romildo: ghc infers the most general type it can
06:21:01 <romildo> donri, ghci does not accept it without a type annotation
06:21:13 <Maior> I've put my redis / open files / getAddrInfo question on StackOverflow, in case anyone has any ideas or debugging hints - http://stackoverflow.com/q/18765463/928098
06:21:20 <donri> romildo: try :set -XNoMonomorphismRestriction
06:21:36 <Maior> I'm wondering if it might be a laziness thing
06:23:49 <merijn> @where dmr
06:23:50 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:23:56 <merijn> romildo: Read that
06:24:30 <Maior> (is there a better place to ask concurrent haskell questions?)
06:25:16 <Kaini> Maior, without taking a closer look at your code, but I think you create an endless amount of since you main = forever $ do.
06:25:27 <Kaini> *endless amount of connections
06:25:53 <merijn> Maior: Please don't use "import qualified Data.ByteString.Char8 as BSC"
06:25:56 <romildo> With no monomorphism restriction, I get natural :: (Num b, Stream s m Char) => ParsecT s u m b. But ghc accpets this type only with -XFlexibleContexts. I would like a type for natural that does not make me use language extensions. Is that possible?
06:26:02 <Maior> merijn: ok, what should I use?
06:26:05 <merijn> Maior: ByteString.Char8 is terrible
06:26:07 <Maior> Kaini: ...of course
06:26:09 <merijn> Maior: Data.ByteString
06:26:20 <Maior> merijn: and to convert a String to ByteString?
06:26:26 <Maior> Kaini: that was silly of me
06:26:32 <Maior> Kaini: I wanted to block the main thread indefinitely
06:26:46 <Maior> Kaini: so I loop while forking
06:26:55 <Maior> Kaini: thanks!
06:26:57 <merijn> Maior: But that means you're forking an infinite number of threads
06:26:59 <Maior> es
06:27:01 <Maior> *yes
06:27:07 <Maior> which is rather silly
06:27:08 * Maior fixes
06:27:16 <donri> romildo: probably not without specializing the type
06:27:30 <Maior> what's a good way to be, well, "I've forked, block indefinitely"?
06:27:31 <tomejaguar> So many complaints about Char8 here. Shouldn't the package just be deleted?
06:27:34 <merijn> Maior: If you want to wait infinitely use "forever (threadDelay <some long time>)"
06:27:46 <Maior> merijn: thanks muchly
06:27:46 <merijn> Maior: That, or use an empty MVar and do "takeMVar"
06:27:58 <merijn> Maior: Then you can shutdown by writing something to that MVar
06:27:59 <Kaini> Or waitForTermination, but I am not sure where I've got this function from
06:28:03 <lurkorg> Hi all, I'm getting really confused about the Colour module, in particular how to specify a colour as hsv. Getting a RGB value from Data.Colour.RGBSpace.HSV.hsv, then feeding the r g b coordinates into sRGB doesn't appear to get the right colours from the colour wheel I'm familiar with
06:29:03 <merijn> Maior: As for going from String to ByteString, you need to use a proper encoding. There's "encodeUtf8 :: Text -> ByteString" and you can either use "Data.Text.pack :: String -> Text" or use OverloadedStrings to write Text literals
06:29:38 <merijn> Maior: ByteString is for dealing with raw bytes, String deals with unicode text, you need to encode to a specific encoding
06:29:45 <Kaini> Oh, waitForTermination is from Happstack.Server, you probably don't want to use it then
06:29:55 <Maior> huzzah, this works, thank you all muchly
06:30:08 <romildo> donri, could you give an example of how the type (Num b, Stream s m Char) => ParsecT s u m b can be specialized, so that the extensions is not needed?
06:32:38 <donri> romildo: Parser Int, say, but could be less specialized probably
06:33:36 <donri> romildo: but note that you need the extension because parsec uses it, so there's no way to use your code without using the extension during compilation anyway
06:33:47 <bscarlet> Can anyone help me understand this type error: http://lpaste.net/92882?
06:34:23 <donri> romildo: (ie. to compile your code, you must first compile parsec, which requires extensions)
06:35:33 <DMcGill> there's still value in reducing the number of extensions of a source file when it wouldn't cost much to do so though, if only to simplify your code a little
06:35:35 <S11001001> bscarlet: sounds like let polymorphism problems
06:36:15 <merijn> bscarlet: It doesn't know the type of 'd', so the application of "asTypeOf" is problematic
06:36:19 <merijn> :t asTypeO
06:36:20 <lambdabot>     Not in scope: `asTypeO'
06:36:20 <lambdabot>     Perhaps you meant one of these:
06:36:20 <lambdabot>       `asTypeOf' (imported from Prelude), `asTypeIn' (line 148)
06:36:21 <merijn> :t asTypeOf
06:36:22 <lambdabot> a -> a -> a
06:36:47 <bscarlet> but but but...
06:36:47 <donri> DMcGill: certainly, but there's no portability loss in this case
06:36:49 <merijn> bscarlet: But this code makes me cringe to begin with, what are you trying to do?
06:37:11 <donri> merijn: nice typeO
06:37:15 <ocharles> merijn: is it you who has a dimensions library?
06:37:21 <ocharles> I forget who I was talking to about one...
06:37:29 <bscarlet> merijn: It's boiled down from a larger example. Suspend cringing for the moment, please.
06:37:56 <merijn> ocharles: Nope, did you get my earlier remark on the way to contribute patches to base?
06:38:03 <ocharles> merijn: I didn't
06:38:04 <merijn> ocharles: (Since you were asking on libraries@)
06:38:12 <ocharles> this IRC bouncer is useless at notifying me :(
06:38:17 <ocharles> I need to spend some time working out a better solution
06:38:22 <ocharles> who is it who own 'dimensions' then?
06:38:23 <merijn> ocharles: You should just create a diff and open a ticket on the GHC Trac with it and a link to the mailing list
06:38:32 <ocharles> merijn: ok, that sounds easy enough
06:38:41 <ocharles> thanks!
06:39:23 <merijn> bscarlet: THe problem is, how does it know whether "bar" returns a 'D Float', a 'D Double' or a 'D (Tree ByteString)'?
06:39:56 <bscarlet> merijn: It doesn't. Hence the need for the explicit type on lines 22, 23, etc.
06:40:18 <lurkorg> never mind, my colour troubles are elsewhere in my code
06:40:29 <merijn> bscarlet: Yeah, but stuff like asTypeOf doesn't always play well with this kind of polymorphism
06:41:13 <bscarlet> merijn: I'd have thought this was exactly was "asTypeOf" was for.
06:41:32 <merijn> bscarlet: Also, your recursive binding in the working version of bar makes me sad
06:41:43 <bscarlet> merijn: goodness. Why?
06:42:23 <merijn> bscarlet: Well, why is it there, for one
06:43:23 <merijn> bscarlet: Anyhoo, I don't really have a solution for this as you seem to hitting a rather nasty corner of the type checker
06:44:23 <bscarlet> merijn: Actually, I've got a solution. What I don't have is understanding. Thanks though.
06:44:24 <S11001001> bscarlet: works with ScopedTypeVariables and a more refined d type, if you're wondering.
06:44:31 <ocharles> ah, it's haasn who has 'units' - that's the one I'm thinking of
06:44:50 <bscarlet> S11001001: I wasn't able to do it with ScopedTypeVariables. What do you mean by a more refined d type?
06:45:14 <hpaste> S11001001 revised “Could not deduce...”: “a patch for bscarlet” at http://lpaste.net/92882
06:46:01 <bscarlet> S11001001: Oh blah. When I tried ScopedTypeVariables I forgot I needed the explicit "forall", so I never really tried it at all. Thanks.
06:46:16 <merijn> oh!
06:46:24 <ocharles> haasn: you confuse me because your library is called 'units', but 'units' is already on Hackage as something else...
06:46:29 <merijn> bscarlet: Can you try your original example without MMR?
06:46:30 <int-e> bscarlet: hmm, I expected MonoLocalBinds to allow your code to compile, but it still fails.
06:46:58 <S11001001> int-e: mightn't that be too strong medicine?
06:47:27 <bscarlet> merijn: I added "NoMonomorphismRestriction", but still get the same error.
06:47:31 <merijn> hmmm
06:48:28 <int-e> S11001001: that's not the point; I don't know why it still fails then
07:03:50 <ethercrow> YayMe`: yes, yi does work
07:06:11 <mm_freak_> when will closed type families be introduced?  GHC 7.8?
07:06:37 <mm_freak_> and will that work for data/newtype families as well?
07:06:37 <S11001001> bscarlet: easy to remember when you had to use it all the time in early versions of ermine :)
07:08:03 <bscarlet> S11001001: Heh. It's been a little while since I used ScopedTypeVariables. I'm still stumped as to what's actually wrong with the original, though.
07:09:24 <merijn> mm_freak_: 7.8, yes, not sure about data/newtype families
07:09:25 <S11001001> bscarlet: well, d :: forall a. Foo (D a) => D a is too much polymorphism, so if that got inferred you lose
07:09:42 <wojtekM_> Dear list, hello again. This time I cannot figure out how to use ParsecT with Writer. Is there, perhaps, an example hiding from me somewhere? Currently I am using it with IO, as in the excellent "Parsec generally". I replaced IO with Writer, and it does compile, but how do I actually write anything?
07:10:13 <b__> I'm rewriting Prelude (for fun), and I get a warning for `filter p (x:xs) = if p x then x : filter p xs else filter p xs' saying `Couldn't match expected type `Bool' with actual type `Bool'', even when using NoImplicitPrelude
07:10:19 <mm_freak_> thanks
07:10:54 <wojtekM_> type Parser = ParsecT ByteString TheState (Writer String)
07:11:07 <DMcGill> b__: can you use RebindableSyntax to write your own if_then_else?
07:11:13 <donri> b__: you need RebindableSyntax and an ifThenElse :: Bool' -> a -> a -> a function
07:11:14 <wojtekM_> type Parser = ParsecT ByteString TheState IO -- was before
07:11:24 <b__> thanks
07:12:15 <bscarlet> S11001001: I'm confused, which is good. What do you mean by it being too much polymorphism? How is that type different from what's needed to call foo?
07:13:00 <wojtekM_> debug = liftIO . Prelude.putStrLn -- was before
07:13:40 <wojtekM_> debug = return () -- is now, and it compiles, but how do I write anything?
07:14:10 <DMcGill> wojtekM_: have you tried using 'tell'? It is, as far as I know, the main way to deal with Writer
07:14:24 <DMcGill> It's not much but hopefully it's a starting point
07:14:56 * hackagebot google-search 0.1.0.1 - EDSL for Google and GMail search expressions  http://hackage.haskell.org/package/google-search-0.1.0.1 (LiyangHu)
07:14:58 * hackagebot google-mail-filters 0.0.1.1 - Write GMail filters and output to importable XML  http://hackage.haskell.org/package/google-mail-filters-0.0.1.1 (LiyangHu)
07:15:18 <wojtekM_> DMgGill, I figured out I should use tell, but I have no idea how to do it in the debug method. If I try, the types expode on me.
07:15:51 <S11001001> bscarlet: (foo :: forall a. Foo a => a -> String) (d :: forall b. Foo (D b) => D b) :: String
07:16:19 <lurkorg> Ok my earlier colour problem is an SDL problem.
07:16:28 <lurkorg> where white comes out cyan
07:16:37 <lurkorg> http://stackoverflow.com/questions/3286864/why-is-this-haskell-sdl-line-cyan-when-it-should-be-white
07:17:03 <lurkorg> the "rgbColor" solution there doesn't work for my 64 bit linux laptop
07:18:25 <ocharles> lurkorg: I manually create colours for that reason
07:18:59 <ocharles> though https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs#L158 which I think is the same rgbColor works for me
07:19:09 <ocharles> I guess you don't have a 32 bit display?
07:19:27 <ocharles> lurkorg: can you paste some code that shows how you are initializing your SDL display?
07:20:31 <wojtekM_> Perhaps I have to make an instance?
07:22:00 <DMcGill> wojtekM_: try debug2 :: String -> ParsecT ByteString TheState (Writer String); debug2 = lift . tell
07:22:31 <DMcGill> is that what you were looking for?
07:23:00 <merijn> wojtekM_, DMcGill: If you're debugging, why not Debug.Trace.trace?
07:23:44 <bscarlet> S11001001: Then I guess my question is: Why does the asTypeOf not have the same effect as using ScopedTypeVariables?
07:23:49 <DMcGill> merijn: I was under the impression that wojtekM_ was using Writer to collect the debug calls, as putStrLn in IO was doing the job of trace before
07:24:04 <wojtekM_> merijn: I want to switch from writing to console to gathering errors.
07:24:29 <wojtekM_> I want to run the parser on many testcases and select failures
07:26:13 <DMcGill> wojtekM_: `lift . tell' is what you want then - just as liftIO will take an IO action to a MonadT IO, so will lift take a Writer action to a MonadT Writer
07:26:39 <wojtekM_> Looking at Text.Parsec.Prim, I see instance (MonadIO m), but nothing analogous for MonadWriter
07:26:48 <wojtekM_> let me give it a try
07:27:18 <DMcGill> ParsecT is an instance of MonadTrans
07:27:25 <DMcGill> thus allowing things to be lifted into it
07:28:36 <wojtekM_> DMcGill: Yeah, hooray, thans!
07:29:15 <wojtekM_> DMcGill: Although I have no idea why, but I'm getting better
07:29:19 <DMcGill> note that liftIO is slightly different from lift because you can't lift IO actions into any old monad - only MonadIOs
07:29:24 <statusfailed> I thought strings in Haskell were tricky... python is about 100x worse ;_;
07:29:34 <enthropy> bscarlet: it might have something to do with ghc not inferring RankNTypes
07:29:59 <DMcGill> wojtekM_: sounds like you need to read an intro to monad transformers :)
07:30:22 <enthropy> @type let f g = 1 `g` 2 in f
07:30:23 <lambdabot> (Num a, Num a1) => (a -> a1 -> t) -> t
07:30:23 <Tinned_Tuna> DMcGill: everyone loves monad-related tutorials.
07:30:34 <wojtekM_> DMcGill: I already printed it, and fogot it at home
07:30:36 <Mortomes|Uni> If I could have a nickel for every monad tutorial.
07:30:58 <DMcGill> try http://en.wikibooks.org/wiki/Haskell/Monad_transformers or http://book.realworldhaskell.org/read/monad-transformers.html
07:31:03 <DMcGill> unless somebody else wants to recommend a paper
07:31:37 <Tinned_Tuna> I need to write more "production" code in Haskell ...
07:32:04 <Maxdamantus> > product [1..4]
07:32:05 <lambdabot>   24
07:34:16 <bscarlet> enthropy: I am not experienced w/ type theory. What's higher-rank here?
07:34:56 * hackagebot biosff 0.3.4 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.3.4 (KetilMalde)
07:34:58 * hackagebot flowsim 0.3.3 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.3.3 (KetilMalde)
07:35:22 <wojtekM_> For now I'm hapy I can continue with my parser, I will understand why it works next week.
07:35:33 <enthropy> having a forall that's not at the very left
07:36:47 <Sculptor> hi
07:36:51 <bscarlet> enthropy: I got that much from HaskellWiki, but I'm not seeing where I've made that happen in my code.
07:36:58 <enthropy> > let { f :: Num b => (forall a. Num a => a -> a -> a) -> (Int,Double); f g = (g 1 1, g 1 1) } in f (+)
07:37:00 <lambdabot>   (2,2.0)
07:37:26 <DMcGill> bscarlet: note that for all type signatures of the form "Show a => b -> Int", there's an implicit "forall a b. Show a => b -> Int"
07:37:37 <DMcGill> a terrible example but I hope it gets my point across
07:37:43 <lurkorg> ocharles: thanks a lot, cracked the cyan thing, and my underlying problem was that I had saturation / value as 1, instead of 0.9999
07:37:53 <ocharles> lurkorg: good to hear
07:37:58 <enthropy> oops, I didn't need tha Num b =>
07:38:06 <ocharles> lurkorg: just to let you know, me and the author of the SDL bindings have just started work on bindings for SDL2
07:38:11 <enthropy> > let { f :: (forall a. Num a => a -> a -> a) -> (Int,Double); f g = (g 1 1, g 1 1) } in f (+) -- a bit simpler
07:38:13 <lambdabot>   (2,2.0)
07:38:46 <enthropy> bscarlet: without that signature, you aren't allowed to use the (+) argument at two different types
07:39:08 <lurkorg> ocharles: good to know thanks, I'm having fun with it http://yaxu.org/texture-2-0-bug-exposure/
07:39:34 <ocharles> lurkorg: you're the author of this?
07:39:38 <enthropy> @where syb
07:39:41 <lambdabot> <http://www.haskell.org/haskellwiki/Scrap_your_boilerplate>,<http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/>,<http://homepages.cwi.nl/~ralf/syb2/>,<http://homepages.cwi.nl/~ralf/
07:39:43 <lambdabot> syb3/>
07:40:15 <lurkorg> ocharles: yes
07:40:21 <enthropy> that library makes use of RankNTypes
07:40:27 <ocharles> lurkorg: awesome, it's a really cool project!
07:41:05 <enthropy> @type runST
07:41:06 <lambdabot> (forall s. ST s a) -> a
07:41:17 <wojtekM_> Let me express my gratitude towards all people, who helped me so far. The claim that this channel is extremely friendly, is fully justified.
07:41:30 <bscarlet> enthropy, DMcGill: I think you're helping, but I'm still not seeing it. Can you tell me in terms of my original post?
07:41:38 * enthropy didn't see it
07:42:02 <yaxu> ocharles: thanks
07:42:08 <yaxu> ocharles: and it just got a lot more colourful :)
07:42:18 <enthropy> > let { f g = (g 1 1 :: Int , g 1 1 :: Double ) } in f (+)
07:42:19 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:42:19 <lambdabot>              with actual ty...
07:42:37 <bscarlet> enthropy: Didn't see the problem or didn't see the post (http://lpaste.net/92882)?
07:42:54 <ocharles> yaxu: it's remarkebly little code,
07:42:55 <ocharles> nice
07:48:42 <hpaste> enthropy annotated “Could not deduce...” with “Could not deduce... (annotation)” at http://lpaste.net/92882#a92886
07:49:07 <enthropy> bscarlet: I think there are a couple things involved
07:49:34 <bscarlet> Yes?
07:49:39 <enthropy> 1. monomorphism restriction, since bar has no arguments
07:49:52 <enthropy> but you want a polymorphic type for it
07:50:09 <bscarlet> Isn't it's declaration enough?
07:50:23 <enthropy> which declaration?
07:50:29 <bscarlet> line 9
07:50:43 <enthropy> in your paste yeah
07:50:55 <enthropy> that signature stops it
07:51:34 <bscarlet> So in my original MMR isn't an issue, yes?
07:51:38 <shachaf> hi Philippa
07:51:47 <enthropy> yes, but if you drop the type signature it's an issue
07:51:47 <Philippa> hey shachaf, how's things?
07:51:51 <bscarlet> Right.
07:52:23 <bscarlet> (I had never intended to drop it)
07:52:47 <bscarlet> I'm still trying to grok what you did.
07:53:37 <enthropy> well it's the same thing you did with the type signature
07:53:54 <enthropy> restrict the type where d is defined, not where it is used
07:54:49 <bscarlet> Weird. That matters?
07:55:46 <enthropy> apparently
07:55:55 <bscarlet> oh. d is less polymorphic with the asTypeOf?
07:56:13 <enthropy> if you switch it to using case expressions it works too
07:56:19 <enthropy> yeah
07:56:33 <enthropy> ie. bar = case D "dummy" of d -> case D (foo d) of f -> f `asTypeOf` d
07:57:22 <enthropy> or: bar = case D "dummy" of d -> D (foo d) `asTypeOf` d
07:58:03 <bscarlet> That seems really strange to me.
07:58:39 <bscarlet> Anyway, thanks. I've at least got something of a handle on what's happening, however strange it seems to me. Much appreciated.
07:58:41 <enthropy> http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf <-- at some point they were deciding to change ghc to not generalize let
07:59:10 <wereHamster> how do I debug a sigsegv?
07:59:11 <enthropy> but now I have  -XMonoPatBinds is deprecated: Experimental feature now removed; has no effect
07:59:25 <wereHamster> the stacktrace in gdb is less than useless
08:06:06 <applicative> enthropy http://ghc.haskell.org/trac/ghc/ticket/2357
08:10:52 <wereHamster> one has got to love undocumented functions which accept arbitrary (and obviously invalid) input and then overwrite random portions of memory.
08:11:28 <Maior> wereHamster: I call them "C++ programs" :P
08:12:02 <enthropy> applicative: good to see that got confirmed
08:12:41 <wereHamster> Maior: interesting. I compiled that particular program with a compile that goes by the name 'GHC'
08:12:41 <applicative> enthropy: there is this which simon pj also wrote. http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
08:13:33 <enthropy> anyways, this stuff is mostly for bscarlet to read :)
08:17:58 <DRiKE> anyone successfully cross-compiled ghc for raspberry pi? arm-linux-gnueabihf-nmm complains it doesn't recognize the file format of a tmp.o file during compilation
08:18:56 <quchen> DRiKE: Raspbian comes with a GHC package, maybe ask its maintainer?
08:19:15 <DRiKE> that might be useful
08:19:24 <quchen> This question was asked a couple of times here already, and I don't think someone knew the answer.
08:19:25 <Taneb> DRiKE, it's GHC 7.2 without TH, I thnk
08:19:40 <DRiKE> TH being ?
08:19:45 <Taneb> Template Haskell
08:20:47 <Taneb> Might be GHC 7.4, I'm not sure
08:21:05 <applicative> about monolocal binds etc there was a really interesting bunch of letters from d mazieres about it http://www.haskell.org/pipermail/haskell-cafe/2011-May/091252.html followed by http://www.haskell.org/pipermail/haskell-cafe/2011-June/091255.html then later a really impossible exchange
08:21:10 <applicative> http://www.haskell.org/pipermail/haskell-cafe/2011-June/092157.html
08:21:42 <applicative> i remember nearly being killed by it
08:26:15 <applicative> only a few exchange of -cafe and libraries are known to be potentially fatal; children, the elderly and those with 'special conditions' should immediately be innoculated
08:26:28 <applicative> exchanges on, rather
08:37:06 <danilo2> Does anybody know haw can we make multiparam instance in Tempalte Haskell ?
08:40:25 <danilo2> Is it even possible to somehow printTH representation of some Haskell structure (like class or datatype)? I want something simmilar to runQ [| \x -> 1 |]
08:44:59 <Xack> Is https://launchpad.net/ubuntu/+source/haskell-platform okay to use?
08:45:19 <elliott> the ubuntu haskell platform package is okay
08:45:32 <elliott> it is a little bit behind, though
08:45:40 <Matrixiumn> Okay, thanks. :0
08:45:42 <Matrixiumn> *:)
08:45:44 <Philippa> yeah, sitting on 12.04 isn't happy here
08:51:22 <applicative> does it have ghc-7.6 ? I'm not following this Ubuntu page
08:54:04 <applicative> Matrixiumn: monochrom a nice page on doing it by hand -- which is pretty simple; he uses ubuntu
08:54:24 <applicative> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
08:54:53 <applicative> he 'has' a nice page ^^^ rather
08:55:08 * hackagebot flowsim 0.3.4 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.3.4 (KetilMalde)
08:57:46 <Matrixiumn> applicative: Okay, thank you. :)
09:01:51 <applicative> "you should watch a movie while building ghc from source. I recommend  the Ten Commandments, Ben-Hur, the Robe, Cleopatra, the King and I, the Sound of Music, Fantasia…"
09:06:29 <applicative> Myself I recommend just watching the terminal while ghc builds; it may be one of those things that works best with some kind of psycho-pharmacological enhancement.  The bits where a giant mass of `sed` rolls by are like the kung-fu sequences.
09:06:35 <ocharles> In the following line, is GHC's RTS allowed to free 'r' in the getLine call?
09:06:36 <ocharles> withInit [InitEverything] $ createWindow "Hello" 0 0 800 600 >>= \w -> createRenderer w FirstSupported [Accelerated] >>= \r -> setRenderDrawColor r 255 0 0 255 >> renderClear r >> renderPresent r >> getLine
09:07:05 <edwardk> applicative: the 4 hour version of Dune works well also
09:07:12 <applicative> hah
09:07:36 <ocharles> likewise, is it allowed to free 'w' from any point after 'createRenderer'?
09:08:29 <ocharles> Because in these SDL bindings we have a finalizer on these foreign pointers that call's Destroy{Window,Renderer} and when I run this in GHCI, the window appears for a short period of time and then closes - but GHCI is still waiting for me to type a line
09:09:18 <applicative> I see, this is as much a 'mysteries of the ghci' question as any other
09:09:43 <ocharles> applicative: oh?
09:10:37 <applicative> I'm just thinking it adds another layer of complexity, that the really program here is ghci.
09:10:47 <applicative> i don't get the sdl method
09:11:10 <ocharles> I'm trying some 'withWindow' and 'withRenderer' type methods now, which would hold onto to w and r
09:12:33 <Maerten> Hi, beginner question: I'm trying to run a file that imports a module called 'Locale' that is missing on my system. What's the easiest way to find which package i need to install? 'cabal list locale' didn't really help me..
09:12:47 <applicative> or put otherwise, are you detecting a difference between ghci and a compiled version?
09:13:06 <applicative> Maerten: in this case it's "System.Locale"
09:13:10 <dcoutts> Maerten: System.Locale probably right?
09:13:25 <Maerten> could be ;D i'll have a look. thanks!
09:13:39 <dcoutts> Maerten: in which case it's in a package called old-locale that comes with your installation
09:13:41 <applicative> Maerten: Locale, Monad, List, IO and other supershort names from older material, need to be expanded now.
09:14:04 <ocharles> applicative: haven't tried compiling anything yet
09:14:10 <applicative> crudely to System.Local, Control.Monad, Data.List, System.IO and so on according to someone's fancy
09:14:21 <applicative> System.Locale rather
09:14:42 <applicative> ocharles: oh, maybe I was distracted by the ghci element.
09:14:57 <Maerten> alright, thanks for the info! kind of lost here as a newbie haskeller :)
09:15:23 <ocharles> using withWindow and withRenderer (which are just brackets) seems to keep the window open
09:15:49 <ocharles> so I guess the answer is yes - at that point nothing does and will refer to 'w' or 'r' so the RTS can garbage collect it at will
09:17:33 <ocharles> I suppose due to IO being a monad ghc is able to easily know that something is never referred to again
09:17:36 <ocharles> that's pretty bad
09:17:37 <ocharles> erm
09:17:37 <ocharles> rad*
09:19:43 <Taneb> ocharles, that sounds too good to be true...
09:23:43 <Enigmagic> ocharles: it's just normal garbage collection, nothing special about IO
09:25:09 * hackagebot colada 0.5.5 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.5.5 (GrzegorzChrupala)
09:25:28 <ocharles> Enigmagic: I know
09:25:34 <applicative> Enigmagic: but the w and r are somewhat strange
09:25:48 <ocharles> Enigmagic: but the fact that a big IO action is made using >>= means that that property comes quite naturally
09:25:55 <applicative> oleg will probably tell ocharles he's being Unprofessional
09:26:10 <applicative> real "men" kill stuff off themselves, by hand
09:26:22 <ocharles> hum?
09:26:33 <ocharles> i'm wrapping foreign code... would you rather I just leak memory?
09:26:46 <Enigmagic> ocharles: the RealWorld# state token doesn't actually reference any variables so it doesn't have much to do with >>=
09:26:52 <applicative> it is a typical complaint about lazy io that it uses this feature and e.g. lets the garbage collector take care of handles etc
09:27:53 <ocharles> applicative: well sure it's that and unsafeInterleaveIO though
09:28:42 <applicative> yes
09:29:02 <ocharles> good thing I'm not magically going IO a -> a then too :)
09:29:03 <applicative> oh, i am trying to port https://github.com/JohnLato/posix-paths/blob/master/src/System/Posix/Directory/Traversals.hs to something like pipes-dirstream
09:30:06 <applicative> 'port' here meaning shamelessly copy, or 'ringing the changes' or whatever
09:31:50 <ocharles> how far have you got?
09:31:51 <chrisdone> liar!
09:31:59 <chrisdone> anyone got a prolog implementation in haskell?
09:32:18 <ocharles> @hackage LogicT
09:32:18 <lambdabot> http://hackage.haskell.org/package/LogicT
09:32:19 <ocharles> there you go!
09:32:20 <ocharles> :P
09:32:21 <Philippa> heh. I don't have one to hand: I keep implementing lower-level logic languages
09:32:24 <chrisdone> nooo a real one
09:32:39 <chrisdone> huh. that link appears dead. humph
09:33:14 <Philippa> chrisdone: How real, OOI? I mean, beyond parsing-and-interpreting (because who wants to compile?) a language that looks a lot like prolog and does unification and cut?
09:33:15 <chrisdone> Philippa: yeah i implemented a simple logic querying language with assertions and rules, but just curious if someone already made one
09:33:17 <ocharles> @hackage logict
09:33:17 <lambdabot> http://hackage.haskell.org/package/logict
09:33:23 <ocharles> there you go
09:33:39 <ocharles> I forgot lambdabot is stoopid and just concatenates whatever I say
09:34:08 <ocharles> @hackage logict I think? I dunno, I'm just a robot.
09:34:08 <lambdabot> http://hackage.haskell.org/package/logict I think? I dunno, I'm just a robot.
09:34:25 * ocharles cackles
09:35:24 <chrisdone> Philippa: sure, a simple logic language that can be used to query a database of facts is all i need. cut isn't neccessary
09:35:30 <Philippa> chrisdone: I can't imagine it'd be too hard to build a basic WAM implementation, no idea whether anyone bothered publishing it or what's the preferred way of doing it
09:35:47 <Philippa> oh, if that's all then edwardk probably has way more than you need
09:35:49 <bos> we don't happen to have some clever library for gluing tuples together, do we?
09:35:49 <unK_> hello. does anyone know how to extract in a fast and reliable way from Pico (Fixed E12) type its integral and fractional part (both as integers)?
09:36:11 <geekosaur> afaik it does not have separate parts
09:36:26 <geekosaur> it's an Integer with an implied decimal point
09:36:42 <edwardk> chrisdone: i have a bunch of code in an old analytics branch that makes a datalog go, alec heller has a version of datalog he's calling 'hokeylog' as well
09:36:57 <unK_> yeah. and additionally constructor is hidden (if it wasn't, then it wouldn't be a problem)
09:37:29 <chrisdone> edwardk: is it open sauce?
09:37:38 <edwardk> chrisdone: my current datalog efforts hinge on my matrix multiplication / tensors code, but thats not out there yet.
09:37:43 <edwardk> the hokeylog stuff is on github, one sec.
09:37:56 <bos> @hoogle (a,b) -> (c,d) -> (a,b,c,d)
09:37:56 <lambdabot> No results found
09:37:58 <edwardk> https://github.com/deviant-logic/hokeylog
09:37:59 <bos> bah
09:38:17 <edwardk> @bos fraid there's nothing really
09:38:18 <lambdabot> Maybe you meant: yow docs do bug bid bf b52s
09:38:19 <joelteon> :t \(a,b) (c,d) -> (a,b,c,d)
09:38:20 <lambdabot> (t, t1) -> (t2, t3) -> (t, t1, t2, t3)
09:38:22 <edwardk> er bos:
09:38:35 <edwardk> @b52s
09:38:36 <lambdabot> Girl from Ipanema, she goes to Greenland
09:39:07 <ocharles> ...
09:39:38 <edwardk> lambdabot was a little less focused when she was younger
09:40:29 <ocharles> :)
09:41:39 <bscarlet> unK_: properFraction perhaps?
09:43:01 <unK_> bscarlet: that kinda works, but still there is a problem of converting fractional part to integer
09:43:11 <bscarlet> unK_: Yeah.
09:43:40 <chrisdone> edwardk: cool, this looks like what i'm after. i implemented a trivial datalog-ish from the SICP chapter: http://lpaste.net/92731 but i wanted someone else to have done the work and have a fairly tested implementation =) happily this is code is pretty much similar. hmm i can't see where it supports AND/OR/etc. is that achieved by the Function relation?
09:43:48 <aumji> I quit OO world (even my job)  to come to functional World
09:44:25 <edwardk> chrisdone: another place you may look is in my github.com/analytics/analytics repo. if you go far enough back in history there is a DatalogT monad transformer
09:44:37 <chrisdone> edwardk: (i used vixey's unification algorithm. remember her? =])
09:44:42 <chrisdone> edwardk: on master branch?
09:44:56 <edwardk> chrisdone: we started working on doing a newer version and then it switched focuses almost completely and the datalog was scrapped
09:45:02 <edwardk> yeah. way back off master
09:45:04 <scriptor> aumji: serious question, how's that working out?
09:45:39 <edwardk> we found a nicer encoding for the variables later on
09:46:00 <aumji> scriptor: It's hard :'( . But i loved C it will be Okay
09:46:25 <bscarlet> Anyone know if GHC will optimize out (a * x) `div` x for constant x, for Integers?
09:46:31 <edwardk> chrisdone: see the readme on https://github.com/analytics/analytics/tree/88d9e72b70740978d65fcc9bf48a1fde7581cbe4 and the RBAC example at https://github.com/analytics/analytics/blob/88d9e72b70740978d65fcc9bf48a1fde7581cbe4/examples/RBAC.hs
09:46:34 <chrisdone> edwardk: yeah… i'm not sure how much i liked my use of Text for vars and then converting them to STRefs for unification
09:46:49 <chrisdone> edwardk: ah, cool =)
09:47:13 <geekosaur> unK_, I think the way Fixed works is not conducive to splitting it the way you want
09:47:26 <edwardk> the version we started doing switched to a more HOAS-like way to introduce variables rather than the Term class
09:47:27 <chrisdone> edwardk: what was your use-case for a datalog?
09:47:38 <chrisdone> edwardk: what's HOAS?
09:48:20 <edwardk> chrisdone: analytics was being built on a superset of datalog i've been working on that supports aggregations using omega-continuous semirings, later on it switched to focus almost exclusively on the aggregates so the datalog was dropped for a while
09:49:24 <edwardk> the major usecase is i wanted a user exposable datalog that could be exposed and made persistent
09:49:36 <monochrom> HOAS is when you use "data Expr = ... | Function (Expr -> Expr)" instead of "data Expr = ... | Function Var Expr" to represent functions, for example
09:49:40 <edwardk> to make it easy to write rule-based systems for things like access control
09:49:51 <chrisdone> monochrom: ahhh, familiar with that approach
09:49:59 <edwardk> HOAS is a trick where you borrow the host language's substitution to implement your own
09:50:06 <unK_> geekosaur: well, the problem is that I'm putting separate sec + usec as Pico into TimeOfDay and I need to be able to get separate sec and usec from it later.
09:50:13 <chrisdone> did that for a trivial lazy lisp implementation
09:50:36 <chrisdone> edwardk: ah, access control, nice use-case
09:51:19 <geekosaur> oh. that's not encoded in a single Fixed though; there is a TimeOfDay constructor
09:51:33 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/time-1.4.0.1/Data-Time-Clock.html#t:UTCTime
09:51:47 <chrisdone> edwardk: my use-case is i want to store information as facts and rules, and then generate exercise questions for people to learn a topic. and most probably with a step that will convert from attempto controlled english to/from the DSL as a front-end
09:52:01 <edwardk> here it is more so i can say rules $ \ u s p -> [userRole u s :- userRole u r <* roleRole r s, userPermissions u p :- userRole u r <* rolePermissions r p]  -- etc.
09:52:12 <geekosaur> it's a record, you can pattern match on it or use the destructors utctDay and utctDayTime
09:52:25 <edwardk> and have those get added to the datalog IDB
09:52:38 <geekosaur> wait, wrong thing
09:52:50 <unK_> geekosaur: that's UTCtime, I'm taking about TimeOfDay ;p
09:52:53 <edwardk> er $ \ u s r p ->
09:53:03 <geekosaur> yes, "wait, wrong thing"
09:53:07 <edwardk> and i can mix and mach that with strongly typed fields
09:53:22 * geekosaur throws out lunch since can't apparently do 2 things at once todat...
09:55:18 <edwardk> chrisdone: anyways, with analytics i was focused on dealing with very very large datasets gracefully, so i eventually got to where i had a good aggregate story that came at the expense of my join story completely. at that point it stopped looking like datalog
09:55:42 <edwardk> and started looking more like an OLAP cube built on morton ordered compressed data
09:55:53 <chrisdone> edwardk: what's that, user u has role r if user u has a role s whose permissions that subsume the permissions for role r. or something
09:55:58 <monochrom> why would you throw out lunch for IRC? :)
09:56:00 * chrisdone runs back to the kitchen to stop chicken burning
09:56:29 <geekosaur> I don't even see how to use separate seconds and picoseconds to make a TimeOfDay
09:56:46 <edwardk> userRole u s :- userRole u r <* roleRole r s -- says that user u  has role s   if user u has role r, and the role r has role s
09:57:09 <edwardk> roleRole lets you make roles inherit all the properties of other roles
09:57:27 <edwardk> userPermissions u p :- userRole u r <* rolePermissions r p  -- gives a user all the permissions each of their roles have
09:57:52 <edwardk> rolePermissions r p  :- roleRole r s <* rolePermissions s p -- gives each role each of the role permissions thier super-roles have
09:58:19 <chrisdone> ahh roleRole
09:58:21 <edwardk> then you can do things like query $ \u -> row (userPermissions u "ScrubToilets")
09:58:48 <chrisdone> you need permission to scrub toilets? =p
09:59:00 <edwardk> and it'll give you all the users permitted to scrub toilets
09:59:18 <geekosaur> security thearter strikes again!    :p
09:59:24 <edwardk> it was written in the RBAC example as a joke when i was discussing it with ozataman and mightybyte
09:59:25 <edwardk> https://github.com/analytics/analytics/blob/88d9e72b70740978d65fcc9bf48a1fde7581cbe4/examples/RBAC.hs#L24
09:59:47 <edwardk> Oz had permission to MakeMoney, Doug had permission to ScrubToilets.
09:59:56 <chrisdone> lol
09:59:58 <monochrom> security theatre is so theatrical
10:00:03 <unK_> geekosaur: like that: sec + fromRational (usec % 1000000). well, actually I think I got it. properFraction + multiplying fractional part by 10^6 will give correct results.
10:00:17 <edwardk> but because of role inheritance Oz could also ScrubToilets if he wanted to
10:02:41 <edwardk> chrisdone: anyways the real motivation was for er.. slightly larger workloads of a few billion entries.
10:04:46 <edwardk> along the way i came up with a nice form of 'partial grounding' that comes up from the morton order that makes it really nice to evaluate datalog rules
10:04:48 <geekosaur> unK_: fromEnum gets you the "inner" value of a Fixed
10:05:43 <edwardk> if i can get the COLA to be fast enough to use as an in memory backing store, then i'll probably dust this off
10:05:49 <geekosaur> you still need to deal with the scale yourself, but since you know it in this case you can divMod or quotRem
10:06:34 <unK_> geekosaur: oh, nice. thanks
10:06:58 <benmachine> fromEnum? sounds icky
10:07:08 <geekosaur> it is a bit icky
10:08:50 <ski> monochrom : though even better is if you can match on the functions in the HOAS ..
10:08:55 <ski> (like in lambdaProlog, e.g.)
10:09:53 <benmachine> properFraction and multiplying sounds "correct" to me
10:10:10 <benmachine> or multiplying, applying some rounding, and then divModding
10:10:43 <chrisdone> edwardk: so what i'm thinking is that i have a bunch of facts about a topic, e.g.
10:10:43 <chrisdone> (rule (lives-in ?city ?president) (and (president ?president ?country) (capitol-of ?country ?city))) ;; iow. the president of a country lives in the capitol city of that country
10:10:43 <chrisdone> and then given some facts about all the countries of the world, all their capitol cities, and their presidents (or political representative, w/e), that's three sets of knowledge that you can test a person on. but because it's a logic database, you can _generate_ queries,  like "who is the president of america?" and then "where does the president of france live?", that simple question tests three kinds of knowledge at once. but just
10:10:46 <chrisdone> randomly generated from a knowledge base created by some teacher or w/e. no two users will likely see the same questions, or ever again
10:10:58 <coventry`> What's an example of a computation which is awkward to express without the monad abstraction?
10:11:30 <Philippa> coventry`: that of mapping a function across a list that decides to carry out arbitrary effects
10:11:31 <chrisdone> edwardk: (the attempto controlled english comes in so that it's asking the questions in plain english rather than FoL or some weird DSL)
10:11:42 <levi> chrisdone: Prolog!
10:11:43 <Philippa> (but controllably so)
10:11:53 <chrisdone> levi: more or less, datalog
10:12:14 <edwardk> levi: datalog is prolog lobotomized
10:12:22 <Philippa> ("decides to" => is allowed to use higher-order functions etc etc to decide which effects to enact based on other effects)
10:12:56 <levi> Sorry, missed the context. It just made me think of Prolog.
10:13:13 <coventry`> Thanks, Philippa.  Do you know where could I find source code of an example like that?
10:13:39 <Philippa> coventry`: mapM from Control.Monad, then search HackageDB for calls that use it?
10:13:45 <levi> I went to a summer computer camp at a university after my junior year of HS and they taught us Prolog.
10:13:54 <chrisdone> levi: i like the idea of a book being generated from a knowledge base. the "chapters" could be the weight of the nodes in the graph of knowledge, and you put the weightier ones first, assuming they're important fundamentals
10:13:57 <Philippa> (note that I can use mapM when I'm writing parsers that aren't allowed to do IO!)
10:14:04 <coventry`> Thanks, Philippa.
10:14:07 <Philippa> (I can also use it to do IO)
10:14:14 <edwardk> your rule would be written rule $ \ city pres country -> [livesIn city p :- president pres country <* capitalOf country city]  -- in the last version of the datalog dsl
10:14:30 <edwardk> er
10:14:46 <edwardk> rules $ \ city p country -> [livesIn city p :- president p country <* capitalOf country city]
10:15:11 <Philippa> coventry`: having access to do notation for any embedded DSL you write the relevant two functions for is also pretty nice
10:15:29 <levi> chrisdone: That's an interesting idea. I think information management systems like that could be very useful.
10:15:34 <chrisdone> edwardk: right. is the hoas necessary for the lib? if i'm converting from user input, seems awkward. doable but awkward
10:15:52 <edwardk> the old way it'd be: livesIn City President :- president President Country <* capitalOf Country City
10:16:02 <chrisdone> ahh
10:16:09 <chrisdone> yeah, that's more amneable
10:16:09 <edwardk> its not necessary. it is just a lot more convenient for me when i want to express it as a nice embedded dsl
10:16:18 <chrisdone> sure
10:16:32 <edwardk> the key here is my users are haskellers, not external DSL users
10:16:39 <chrisdone> nod
10:16:44 <edwardk> hokeylog focuses on being a real datalog for external users
10:16:58 <edwardk> my focus is on a pretty embedded dsl
10:16:58 <chrisdone> gotcha
10:16:59 <levi> chrisdone: I did a bit of research into content management systems for my group at work to help with dissemination of knowledge about the stuff we were developing. I couldn't get my coworkers to buy into any of it, though.
10:17:28 <applicative> ocharles: so far i am failing; i can define childo' :: RawFilePath -> ListT (SafeT IO) RawFilePath
10:17:43 <applicative> ocharles or childOf' :: RawFilePath -> ListT (SafeT IO) (DirType, RawFilePath)
10:17:53 <chrisdone> levi: what kind of CMSs?
10:18:18 <chrisdone> i discovered there's an attempto controlled english wiki. pretty nice idea, insert english, receive logic database
10:18:37 <chrisdone> and possibly bacon
10:18:48 <applicative> ocharles, but these are just 'getDirectoryContents' so to say; the 'recursive' traversal I am getting wrong. I have to find more out about file statuses and all this posix + posix.bytestring nonsense
10:19:00 <levi> I was looking at a variety of things, but what I found most interesting was DITAA.
10:19:24 <chrisdone> levi: ah, sort of a non-obnoxious uml
10:19:42 <levi> No, not the ASCII art thingy.
10:19:45 <aranea> Hi. Is it possible to shorten \a b -> Sum a (negate b) ?
10:19:45 <Maerten> Hi, I'm trying to learn haskell (coming from using PHP daily). I just compiled my first program that does this: take all records in mysql, each containing two datetime columns `begin` and `end`, compute the time difference between them, and print all rows in this format: "Timer 123 duration: 1h20m5s"
10:19:46 <chrisdone> we did something similar at one place, messed around with graphviz
10:19:52 <chrisdone> oh
10:19:53 <levi> Maybe I got the acronym wrong...
10:19:58 <chrisdone> get it right!!
10:20:08 <applicative> good work Maerten
10:20:09 <Maerten> it works fine, my question is just that. In php i made an identical program and it's actually twice as fast as the haskell version. is this to be expected?
10:20:30 <applicative> Maerten: no
10:20:31 <levi> Yeah, only one A. DITA.
10:20:34 <Maerten> applicative: i should give you some credit ;-)
10:20:34 <chrisdone> Maerten: nope, problem exists in implementation
10:20:42 <chrisdone> Maerten: paste your haskell codes, all of them!
10:20:50 <levi> Darwin Information Typing Architecture.
10:20:56 <Maerten> chrisdone: pastebin good or something?
10:20:59 <applicative> Maerten: but database querying may be a bit of a bottleneck for haskell-land? i'm totally ignorant about it though
10:21:14 <chrisdone> @lpaste
10:21:14 <lambdabot> Haskell pastebin: http://lpaste.net/
10:21:27 <applicative> Maerten: it is likely to be something simple though
10:21:52 <applicative> Maerten: I remember the first week i learned haskell solving project euler problems with like [[[[[Int]]]]
10:21:59 <ski> applicative : `\a -> Sum a . negate', or even `(. negate) . Sum'
10:22:00 <ski> er
10:22:07 <ski> aranea ^
10:22:12 <haasn> applicative: that seems overly familiar
10:22:49 <chrisdone> guessing, i'd suspect: php probably makes prepared queries, php probablly doesn't decode unicode bytes into strings, laziness probably a factor somewhere
10:23:14 <Maerten> chrisdone: http://lpaste.net/865260503679631360
10:23:15 <chrisdone> also, mysql-simple should ideally be the library, hdbc-mysql is slow
10:23:27 <applicative> i keep thinking 'is this process going to take 10 minutes, or 10 million years?"
10:23:31 <chrisdone> hdbc. *check*
10:23:47 <levi> chrisdone: It's basically a way to write your documentation in small, re-usable chunks and then be able to create a document by combining the chunks together in a parent document that structures them.
10:24:05 <chrisdone> levi: sounds suave. ever used it?
10:24:29 <chrisdone> Maerten: so the program as presented there takes some hours?
10:24:32 <levi> chrisdone: Nope.  Like I said, I couldn't get anyone on my team to buy into it.
10:24:53 <Maerten> no not at all, i have only 1600 records so it takes like 0.2s
10:25:03 <Maerten> was just wondering why it's twice as slow as my php version
10:25:04 <unK_> hdbc is super slow, at last for postgresql
10:25:12 <unK_> *least
10:25:40 <applicative> Maerten: somehow i feel we need a little more happening to make a comparison PHP v. GHC
10:25:42 <levi> I did eventually force everyone to write documents relating to a project I led in Pandoc Markdown instead of Word, though.
10:26:04 <elliott> Maerten: I assume you're compiling it with -O and everything? but yes, this benchmark seems far too micro
10:26:10 <applicative> levi: good work!!
10:26:17 <Philippa> levi: awesome!
10:26:23 <elliott> too much overhead and not enough processing
10:26:26 <levi> Combining that with Review Board and our mandated Perforce usage led to much sanity at document review time.
10:26:36 <Maerten> i copied these params from somewhere: ghc -O2  -fexcess-precision -optc-O3 -optc-ffast-math -fforce-recomp --make
10:26:50 <Maerten> -O2 made a bit of a difference
10:27:35 <applicative> Maerten: you don't need the ones after -O2 i don't think, except -fforce-recomp where other nonexecutable modules areinvolved
10:27:36 <k0001> Anyone here knows if there will be any Haskell-related event during the first weeks of October in San Francisco?
10:27:37 <chrisdone> Maerten: hold up, i'll convert this to mysql-simple for you and then you can try running that
10:27:56 <elliott> hah, those are odd options for a MySQL benchmark
10:28:05 <benmachine> Maerten: I think quite a few of those flags are redundant now that -fvia-C is no longer the default
10:28:17 <applicative> elliott: yes, i was thinking
10:28:19 <benmachine> (hasn't been for a while, if I remember correctly, but quite possibly I don't)
10:28:29 <elliott> anyway, I suggest using 10x or 100x the records to print out at the very least
10:28:34 <elliott> then there will be more to measure.
10:28:36 <applicative> note though that this shows the catastrophic failure of all haskell tutorials
10:28:48 <applicative> it is like a giant secret how just to compile with ghc
10:28:49 <geekosaur> it became non-default several years ago and has been unsupported since 7.2ish?
10:28:57 <Maerten> true there is not so much going on in this program, but i was curious at this point if I'm doing something completely wrong. I used "read" instead of parseTime because someone on stackoverflow said it's slow. but it took me an hour to get the program to compile again.. so i'd thought to ask you guys first :D
10:28:59 <aranea> ski: thanks
10:29:00 <applicative> i learned by chance from a blogpost by stepcut
10:29:01 <geekosaur> as in -fvia-C doesn't exist any more
10:29:30 <chrisdotcode_> @src maximum
10:29:30 <lambdabot> maximum [] = undefined
10:29:30 <lambdabot> maximum xs = foldl1 max xs
10:29:34 <stepcut> \o/
10:29:45 <applicative> every tutorial of every kind should contain at least one line in which the command given to ghc is explicitly stated
10:29:47 <elliott> that definition is so silly.
10:29:51 <chrisdotcode_> shouldn't the maximum of an empty list be the empty set? >_>
10:29:54 <benmachine> geekosaur: hah, fair enough
10:30:02 <Maerten> I'm glad I can help by sharing my beginner problems :-)
10:30:12 <chrisdotcode_> (same with head, IMO, but I know that's a flame war...)
10:30:37 <benmachine> elliott: it's not necessarily the actual definition
10:30:38 <Maerten> chrisdone: thanks, really curious to see what you would make of it!
10:30:42 <elliott> chrisdotcode_: um, I don't understand.
10:30:44 <Maerten> brb
10:30:46 <benmachine> elliott: lambdabot doesn't consult official sources, she just makes things up
10:30:47 <elliott> you want maximum [] to be []? and head [] to be []?
10:30:56 <elliott> benmachine: I know, I run the thing ;)
10:31:01 <elliott> benmachine: but the first line is completely redundant
10:31:02 <benmachine> elliott: fair enough :P
10:31:03 <applicative> that doesn't typecheck!
10:31:06 <elliott> since foldl1 f [] is already undefined
10:31:08 <chrisdotcode_> elliott: well, I was under the impression that that makes more sense, practically speaking
10:31:11 <elliott> applicative: exactly
10:31:12 <benmachine> elliott: true. go and edit it?
10:31:17 <elliott> chrisdotcode_: but it doesn't type.
10:31:20 <elliott> head :: [a] -> a
10:31:22 <applicative> take 1 [] is [] chrisdotcode_
10:31:29 <elliott> what if a = Int? [] doesn't have type Int
10:31:42 <haasn> are we still having this argument in 2013?
10:31:42 <applicative> > let safehead = take 1 in safehead []
10:31:43 <lambdabot>   []
10:31:48 <haasn> :t preview _head
10:31:49 <lambdabot> (MonadReader s m, Cons (->) (Accessor (First a)) s s a a) => m (Maybe a)
10:31:53 <haasn> :t maximumOf folded
10:31:54 <lambdabot> (Ord a, Foldable f) => f a -> Maybe a
10:32:08 <chrisdotcode_> haasn: I've heard two sides of the story: 1. that it was a mistake 2. that it's mathematically correct
10:32:17 <bennofs> :t listToMaybe
10:32:17 <lambdabot> [a] -> Maybe a
10:32:18 <haasn> we have both alternatives
10:32:18 <benmachine> chrisdotcode_: even in principle, the maximum of the empty list should not be the empty set
10:32:19 <applicative> this is a really advanced safe head haasn
10:32:20 <haasn> no need to complain about it
10:32:41 <elliott> chrisdotcode_: ok, but your proposal cannot even be implemented
10:32:42 <benmachine> chrisdotcode_: inasmuch as it is not a set of any kind, let alone an empty one
10:32:43 <elliott> it just doesn't typecheck :P
10:32:50 <chrisdotcode_> so why was the current head implementation choosen over, say, [a] -> Maybe a?
10:32:59 <chrisdone> Maerten: i think it should be much simpler than written in your paste, won't take a min
10:33:08 <elliott> well, to consume the Maybe you'll have to pattern match on it
10:33:12 <benmachine> chrisdotcode_: that's an interesting question
10:33:13 <elliott> so you might as well just pattern match on the list directly
10:33:22 <elliott> but yes, not defending head here
10:33:27 <benmachine> elliott: that's not *very* convincing an argument :P
10:33:32 <applicative> chrisdotcode_: i can't hear you, i tore out the bit of my brain where Prelude.head used to be...
10:33:43 <chrisdotcode_> haha
10:34:03 <chrisdotcode_> so is there any valid reason for head to *not* return a Maybe a?
10:34:18 <chrisdotcode_> I mean, I'm sure this has been discussed to death, but I personally haven't heard an answer
10:34:19 <benmachine> chrisdotcode_: I think a lot of people would say no
10:34:28 <benmachine> chrisdotcode_: some other people might say "convenience"
10:34:33 <Philippa> hysterical raisins
10:34:37 <benmachine> those
10:34:44 <Philippa> that's about it, though
10:34:50 <elliott> listToMaybe exists if you want it
10:34:52 <elliott> and can stomach the name
10:34:56 <benmachine> heh
10:35:31 <n-dolio> head returning Maybe a is pointless.
10:35:36 <chrisdotcode_> Philippa: but that makes even less sense to me, considering the AMP is getting fixed next year, right? Did nobody also suggest head return Maybe a?
10:35:55 <benmachine> n-dolio: do you think listToMaybe is pointless?
10:35:55 * haasn will take ‘preview _head’ over ‘listToMaybe’ any day
10:36:04 <elliott> changing head like that would break backwards compatibility a trillion times more than AMP
10:36:06 <n-dolio> Yes.
10:36:11 <benmachine> chrisdotcode_: the thing about AMP is it's not ignorable or work-around-able, whereas head totally is
10:36:21 <haasn> (or xs^?_head if you like conciseness)
10:36:24 <n-dolio> Unless you have something that specifically takes a Maybe or something.
10:36:25 <ski> @type foldr (mplus . return) mzero
10:36:26 <lambdabot> MonadPlus m => [a] -> m a
10:36:39 <chrisdotcode_> benmachine: I don't like runtime errors in my haskell, though...
10:36:49 <Philippa> DDTT
10:36:53 <benmachine> :P
10:37:04 <benmachine> chrisdotcode_: neither do I
10:37:04 <applicative> > fromMaybe 0 $ listToMaybe []
10:37:05 <lambdabot>   0
10:37:07 <applicative> > fromMaybe 0 $ listToMaybe [1]
10:37:08 <hpaste> chrisdone pasted “mysql-simple (for Maerten)” at http://lpaste.net/92891
10:37:09 <lambdabot>   1
10:37:28 <chrisdotcode_> to me, haskell has the *exact* opposite philosophy of run-time errors, so head returning errors really surprised me the first time.
10:37:33 <n-dolio> There's just no reason to turn a list into a Maybe and then do something with the maybe instead of just doing it directly with the list.
10:37:41 <elliott> :t foldr (Just . const) Nothing
10:37:41 <levi> chrisdone: Anyway, although there are a few open tools around DITA, it's developed in a very 'enterprisey' space (i.e. IBM's technical documentation system uses it) so the tools around it are kind of clunky and/or expensive.  But the core ideas are open and sound relevant to your documentation ideas.
10:37:42 <lambdabot>     Couldn't match type `Maybe (b0 -> a0)' with `Maybe a1 -> Maybe a1'
10:37:42 <lambdabot>     Expected type: (b0 -> a0) -> Maybe a1 -> Maybe a1
10:37:42 <lambdabot>       Actual type: (b0 -> a0) -> Maybe (b0 -> a0)
10:37:46 <applicative> n-dolio: i think there should be more such functions around, but also more maybe-using combinators
10:37:47 <elliott> :t foldr (const . Just) Nothing
10:37:48 <lambdabot> [a] -> Maybe a
10:37:59 <benmachine> n-dolio: fair point
10:38:02 <chrisdone> Maerten: run: cabal install mysql-simple, and then try compiling that with ghc --make X.hs -O2
10:38:14 <applicative> more functions for unfoldr would be awesome
10:38:28 <chrisdotcode_> :t safeHead
10:38:29 <lambdabot> Not in scope: `safeHead'
10:38:36 <applicative> VU.unfoldr BS.uncons is too wonderful
10:38:40 <chrisdotcode_> :t safehead
10:38:40 <elliott> foldr should be (Maybe (a, b) -> b) -> [a] -> b
10:38:41 <lambdabot> Not in scope: `safehead'
10:38:48 <benmachine> n-dolio: just out of curiosity, are all your objects of morphisms (n-1)-dolios?
10:38:49 <chrisdone> Maerten: does that work?
10:38:52 <elliott> then listToMaybe would be foldr (fmap fst).
10:38:53 <elliott> I think.
10:39:05 <elliott> and foldr and unfoldr would be actually dual.
10:39:11 <n-dolio> Yes. Clearly. :)
10:39:11 <jfischoff> its frustrating to have to explain to new haskellers that many innocent looking prelude functions are crashes wait to happen
10:39:54 * benmachine wishes unicode was permitted in IRC nicks
10:39:55 <chrisdotcode_> elliott: so essentially, if the type constraints could be satisfied, then head :: [a] -> a, could return []?
10:40:02 <chrisdone> minimum often bites me in the ass. for some reason i'm wired to think that minimum of an empty list will just return 0
10:40:07 <chrisdone> benmachine: it is in hulk! =p
10:40:09 <chrisdotcode_> because you're right [] doesn't satisfy a
10:40:16 <elliott> chrisdotcode_: if you removed Haskell's type system then yes it would work
10:40:18 <chrisdotcode_> chrisdone: yeah, that makes sense to me
10:40:23 <jfischoff> the partial functions should just go in my opinion.
10:40:28 <elliott> I have no idea how you'd have to actually modify it to have head [] return [] without completely breaking the type system.
10:40:28 <chrisdotcode_> ^
10:40:38 <chrisdotcode_> elliott: what about a type constraint or something?
10:40:45 <elliott> you could certainly no longer use (head (xs :: [a])) as an a directly, which seems to rather defeat the point.
10:40:48 <elliott> because what if it's [] instead?
10:41:13 <benmachine> principally, head [] is asking for an element of a list that has no elements
10:41:18 <chrisdone> elliott: i'm in favour of ndm's catch :3
10:41:19 <applicative> maxView :: Map k a -> Maybe (a, Map k a)
10:41:21 <benmachine> ain't no way you can have a good answer to that question
10:41:23 <elliott> you could say that (f (head xs)) would be [] for any (xs :: [a]), (f :: a -> b)
10:41:26 <applicative> this is a good function ^^
10:41:29 <elliott> but um, that's just taking undefined and calling it [].
10:41:33 <McManiaC> which GHC version supports closed type families?
10:41:35 <elliott> and making the type system really really weird in the process :P
10:41:52 <benmachine> McManiaC: no released version, I think
10:41:53 <elliott> er, *for any (xs :: [a]) equal to [],
10:41:57 <McManiaC> oh ok
10:42:07 <McManiaC> benmachine: so not before 7.8?
10:42:09 <chrisdotcode_> so it's either loose the great partial functions, turn them all into maybes ... or ignore it?
10:42:22 <McManiaC> looks like a super cool feature :)
10:42:36 <benmachine> chrisdotcode_: probably we should lose them
10:42:41 <n-dolio> Just run Catch on your programs.
10:42:43 <elliott> what great partial functions? :)
10:42:50 <chrisdotcode_> elliott: head, maximum, etc.
10:42:54 <elliott> they're not great.
10:43:02 <elliott> they're awful, or we wouldn't be complaining about them!
10:43:03 <chrisdone> there's always lpaste.net/92328 with first :: List a (S n) -> a; first (Cons a _) = a -- then first Nil is a type error
10:43:07 <chrisdotcode_> hahah
10:43:35 <benmachine> chrisdone: that's a pretty nice solution, although sometimes (sometimes!) you know more about your values than the type system does
10:43:38 <chrisdone> n-dolio: yeah, catch is awesome
10:43:43 <chrisdotcode_> catch?
10:43:55 <jfischoff> does catch still work?
10:43:57 <chrisdone> chrisdotcode_: http://community.haskell.org/~ndm/catch/
10:44:06 <benmachine> basically, much as they baulk at the idea, Haskellers do tend to occasionally want to turn what could be a type error into a runtime error
10:44:08 <chrisdone> jfischoff: no, needs porting to ghc
10:44:08 <n-dolio> jfischoff: Probably not.
10:44:15 <benmachine> so that they can properly ignore it
10:44:17 <n-dolio> Like several other awesome tools.
10:44:18 <elliott> I thought ndm was working on it or something.
10:44:24 <jfischoff> yeah that's what I thought
10:44:29 <chrisdotcode_> chrisdone: oh, that looks cool, thanks :)
10:44:55 <chrisdone> i posted to reddit that it wouuld be good to revive but that i didn't personally want to do the work, but would pay towards someone else doing it especially in a crowdsourcing thing
10:44:56 <n-dolio> chrisdone: Add Buddha to your list of things that people should resurrect.
10:45:01 <benmachine> chrisdone: here's a fun thing about length-typed lists: they kind of aren't a monoid
10:45:02 <n-dolio> Or hat.
10:45:11 * ski seconds n-dolio's suggestion
10:45:15 <chrisdone> n-dolio: was that lennart's cool haskell implementation?
10:45:25 <benmachine> chrisdone: identity works fine but (xs ++ ys) ++ zs doesn't even have the same type as xs ++ (ys ++ zs)
10:45:27 <n-dolio> No, I don't think so.
10:45:33 <n-dolio> It's a 'declarative debugger'.
10:45:34 <chrisdone> ah. i forgot what buddha was
10:45:49 <benmachine> chrisdone: except of course it sort of does, but GHC doesn't know that :P
10:45:55 <benmachine> chrisdone: even in agda it's kind of a pain
10:45:56 <n-dolio> You drill into subexpressions of something that doesn't work until you find exactly what the core problem is.
10:46:11 <benmachine> that sounds cool
10:46:14 <chrisdone> benmachine: hehe, weird
10:46:20 <jfischoff> So I have a frustrating problem. A derived Data instance works in ghci but fails with ghc. Also I have {-# LANGUAGE MonomorphismRestriction    #-} set.
10:46:44 <CoolYo> Haskell is hard :( , I feel like quitting
10:46:54 <ski> and the declarative debugger helps deduce which parts of the program can't be responsible for the mismatch between result and expectation
10:46:57 <chrisdone> CoolYo: never quit! get mad and throw lambdas at people
10:46:58 <chrisdotcode_> what about dependent types as a solution to partial functions?
10:46:58 <haasn> how hard is Haskell on the mohs scale of language hardness?
10:47:13 <chrisdotcode_> head :: [a]{i>=1} -> a?
10:47:20 <benmachine> chrisdotcode_: dependent types are great, but we're still working out how to make them nice
10:47:22 <chrisdone> paper about buddha: http://www.berniepope.id.au/docs/BerniePope.Hons.Thesis.pdf
10:47:22 <n-dolio> 7.3
10:47:25 <jfischoff> I would other extensions should I turn on to make ghci operate like ghc?
10:47:29 <levi> CoolYo: Don't quit! It gets easier. Or rather, the frontiers of what's hard expand.
10:47:30 <benmachine> when I say "we" I mean "other people who are cleverer than me"
10:47:43 <elliott> chrisdotcode_: look at Liquid Haskell.
10:47:48 <ski> chrisdotcode_ : see chrisdone's suggestion <http://lpaste.net/92328>
10:47:51 <chrisdone> n-dolio: what was hat?
10:47:52 <benmachine> chrisdotcode_: look at idris
10:47:55 <nichthus> jfischoff: extended defaulting, I guess
10:47:59 <elliott> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/
10:48:12 <chrisdotcode_> elliott: I checked it out (and idris too), and it looked awesome. can you mix liquid with normal haskell, though?
10:48:20 <n-dolio> chrisdone: Hat did tracing of Haskell programs, but it could also take a trace and do something similar to Buddha, I think.
10:48:32 <chrisdone> yeah liquid types are also awesome. i like that they're an addition to an otherwise valid haskell program
10:48:37 <elliott> I don't know anything about Liquid Haskell beyond the blog posts.
10:48:43 <chrisdotcode_> they're templates, right?
10:48:46 <jfischoff> how do I turn off extended defaulting?
10:48:46 <chrisdotcode_> *template haskell
10:49:05 <chrisdone> n-dolio: gotcha
10:49:22 <jfischoff> nv
10:49:23 <chrisdotcode_> so, would I be correct mathematically speaking i I said, "dependent types are the 'solution' to partial functions"?
10:49:27 <geekosaur> -XNoExtendedDefaultRules
10:49:46 <chrisdone> i was thinking just recently of using the ghc-api's debugger stuff to do something like benmachine's stepeval
10:49:50 <levi> chrisdone: Anyway, the other area you might want to look at is the 'semantic web' stuff with its Resource Description Framework, which is all about establishing (predicate, subject, object) triples about resources and querying them and doing inference.
10:50:00 <luite> chrisdone: way ahead of you ;)
10:50:02 <nichthus> jfischoff: NoExtendedDefaultRules
10:50:17 <jfischoff> yeah thanks, that wasn't it though :p
10:50:25 <chrisdone> luite: well i already did it =p
10:50:28 <ski> elliott : ooh, refinement types, shiny
10:50:37 <jfischoff> is there a way to list the extensions that are on in ghci?
10:50:39 <luite> chrisdone: i did it 3 months ago or so :p
10:50:45 <chrisdotcode_> are refinement types and dependent types the same thing?
10:50:48 <benmachine> chrisdotcode_: I think that statement is not strictly false, but it's not something I would say personally
10:50:54 <chrisdone> luite: i did it a year ago when Inventing On Principle came out
10:50:54 <ski> chrisdotcode_ : no
10:50:59 <luite> chrisdone: booh
10:50:59 <nichthus> jfischoff: I don't think so. =(
10:51:03 <chrisdotcode_> benmachine: thank you :)
10:51:05 <benmachine> chrisdotcode_: dependent types are both much more than that and not really that :P
10:51:17 <benmachine> chrisdotcode_: I mean, there are solutions to partial functions without dependent types
10:51:20 <chrisdotcode_> ski, benmachine: so where could I learn more about the difference?
10:51:26 <luite> chrisdone: but i've never had time to integrate it with notdan's pastebin sandbox and improve the ui
10:51:28 <chrisdotcode_> benmachine: well, are they 'a' solution?
10:51:45 <benmachine> chrisdotcode_: it's difficult to say
10:51:46 <jfischoff> ah :showi
10:51:51 <chrisdone> luite: actually i did it using ghci itself, scrapped it, was too slow to do what i wanted (which was displaying evaluation steps as-you-type your code, a la IOP)
10:52:00 <n-dolio> Many dependently typed languages don't have partial functions because they want to use arbitrary functions in types, but still have type checking terminate.
10:52:02 <benmachine> chrisdotcode_: dependent types help you with programming in general, so in that sense yes, but not really in any other sense
10:52:02 <chrisdone> luite: code online?
10:52:21 <benmachine> chrisdotcode_: as n-dolio says, it's more a case that you need totality for dependent types, than you need dependent types for totality
10:52:25 <n-dolio> But also, some dependently typed languages have partial functions, and some even try to make sure type checking still terminates.
10:52:27 <luite> chrisdone: oh mine doesn't show the expression itself but the graph
10:52:38 <chrisdone> ahh, so different. interesting
10:52:41 <Philippa> benmachine: and even then you don't, you just might /want/ it
10:52:42 <benmachine> and yes, you don't strictly need them :P
10:52:42 <nichthus> chrisdotcode_: I think as a rule of thumb refinement types are typically implemented as dynamic checks and dependent types are typically implemented primarily as static checks.
10:52:43 <chrisdone> i could add that to lpaste
10:52:44 <luite> chrisdone: but i haven't added the ui to do the stepping yet
10:53:22 <n-dolio> Well, dependent types can help with totality, because the compiler can be dumber about what it counts as total, so long as you can supply fancier evidence that something non-obvious is total.
10:53:24 <chrisdotcode_> nichthus: I thought liquid haskell checked at compile time?
10:53:26 <luite> chrisdone: it's kind of heavyweight: compile the code with ghcjs and hook into the main loop to get the heap out
10:53:30 <chrisdone> (i discovered that if you repeatedly demand 10 steps of evaluation n times per secood from the ghci bugger it kinda gobbles up memory and dies)
10:53:34 <elliott> the Liquid Haskell refinement stuff is static, AIUI
10:53:39 <chrisdotcode_> nichthus: and what does totality mean?
10:53:40 <elliott> otherwise there'd be not much point
10:53:46 <chrisdotcode_> ^ yeah, I wouild hope so
10:54:16 <nichthus> nichthus: It claims to! I'm now suddenly very glad I said "rule of thumb" rather than claiming it was always true. =D
10:54:22 <luite> chrisdone: needs some polish :) http://hdiff.luite.com/reduce/
10:54:23 <nichthus> uh
10:54:31 <nichthus> chrisdotcode_: That was at you, not me.
10:54:31 <chrisdone> luite: ahh… heh. yeah did you see this? https://www.youtube.com/watch?v=ABmRkWS3wIU
10:54:57 <chrisdotcode_> nichthus: gotcha. where can I find out more about totality? is there a haskell/wiki article/one sentence summary somewhere?
10:54:57 <luite> the function names etc are all availbel in the metadata, but i haven't used them there yet
10:55:00 <n-dolio> However, supplying the fancy evidence can quickly get non-trivial.
10:55:02 <benmachine> chrisdotcode_: a function is total if it is not partial
10:55:04 <jfischoff> luite: that's cool, just needs music :)
10:55:19 <chrisdotcode_> benmachine: oh, so it's not "complete" and "partial", it's "total" and "partial"?
10:55:21 <nichthus> chrisdone: As for totality, well, I don't know the formal definition. But informally a function is total when it returns an output for every input.
10:55:24 <luite> chrisdone: i think i already commented on that? :p
10:55:25 <chrisdone> luite: ahhh, i've seen that before back when you wrote it
10:55:26 <benmachine> chrisdotcode_: right
10:55:37 <chrisdotcode_> got it, thanks :)
10:56:00 <chrisdone> luite: ah, ok
10:56:06 * monochrom recommends: complete partial order! :)
10:56:10 <ski> chrisdotcode_ : i've seen "entire" as well, but "total" is the usual terminology, i think
10:56:27 * ski . o O ( completely partial order )
10:56:39 <luite> chrisdone: oh wait not this one
10:56:43 <luite> chrisdone: cool :)
10:56:47 <jfischoff> luite: its going to fast for my brain. I need a pause and step forward button
10:57:12 <Philippa> ski: one must, of course, be careful of the capitalisation when talking about CPOs
10:57:15 <luite> jfischoff: yeah it's really something i hacked together in one day
10:57:26 <jfischoff> luite: no excuse ;)
10:57:37 <luite> jfischoff: what you really want is to be able to enter an expression, and then step around the reduction
10:57:46 <jfischoff> oh that would be so cool
10:57:52 <ski> Philippa : ok ?
10:57:56 <jfischoff> really helpful for teaching
10:58:08 <luite> jfischoff: so notdan has already set up the whole thing where ghc and ghcjs are sandboxed, for his gsoc
10:58:18 <luite> jfischoff: it just needs some work to be all integrated
10:58:32 <waterlaz_> Hello setmeaway and welcome to #haskell
10:58:48 <chrisdone> jfischoff: yeah it needs tetris music
10:58:49 <jfischoff> sandboxed for using with a webserver?
10:59:09 <luite> chrisdone: that's converted from core?
10:59:23 <Philippa> ski: Complete POS  might be awkward :-)
10:59:24 <luite> jfischoff: yeah, resource and time limits, and restrictions on allowed syscalls
10:59:42 <chrisdone> luite: yeah
11:00:02 <ski> heh, not very familiar with that one
11:00:05 <waterlaz_> Hello Lethalman and welcome to #haskell
11:00:07 <levi> I haven't gotten to haskell-level management yet, but I'm working on using Linux Containers for sandboxing. Is notdan using them for his work?
11:00:07 <jfischoff> chrisdone: http://www.youtube.com/watch?v=AY-IoRnCgns&list=TLTm4AY4yLryQ
11:00:18 <chrisdone> luite: if you compile as Interpreted then expressions are annotated with breakpoints, which contain source locations back to the .hs file =)
11:00:19 <Lethalman> woot
11:00:26 <Philippa> ski: I've certainly described hardware in those terms before...
11:00:35 <waterlaz_> Hello augur and welcome to #haskell
11:00:43 <luite> chrisdone: oh cool
11:00:46 <chrisdone> guys, that's a bot
11:00:53 <Lethalman> levi, I'm using docker at work (nothing related to haskell)
11:00:54 <chrisdone> waterlaz_  ← someone want to mute this bot?
11:00:56 <luite> chrisdone: hm, ok, you might have given me even more work for today
11:01:01 <chrisdone> luite: haha
11:01:17 <augur> lol
11:01:18 <luite> chrisdone: i'm finalizing the ghc api hooks for review
11:01:19 <ski> waterlaz_ : i'm sure augur appreciates your welcome, but you do know they're a regular, yes ?
11:01:19 <waterlaz_> Hello azm and welcome to #haskell
11:01:20 <augur> waterlaz_ lol
11:01:21 <Eduard_Munteanu> levi: luite was working on something similar, IIRC. What sort of sandboxing do you need?
11:01:25 --- mode: ChanServ set +o monochrom
11:01:27 <waterlaz_> Hello nikita-0 and welcome to #haskell
11:01:29 <waterlaz_> Hello augur and welcome to #haskell
11:01:32 --- mode: ChanServ set +o elliott
11:01:35 --- mode: ChanServ set +q *!*@109.106.20.63.sumtel.ua
11:01:37 <augur> hah. it IS a bot!
11:01:38 --- kick: waterlaz_ was kicked by elliott (turn off your bot)
11:01:39 <augur> interesting
11:01:49 --- mode: ChanServ set -q *!*@109.106.20.63.sumtel.ua
11:01:50 <luite> chrisdone: so now i need to check if i can make (or use) a hook to get these annotations in regular compiled code
11:01:50 <elliott> whoa, you can +q people from chanserv?
11:01:52 --- mode: monochrom set -o monochrom
11:02:00 <luite> chrisdone: since source maps would be pretty cool to have in ghcjs
11:02:13 <elliott> oh, I didn't notice monochrom opping.
11:02:17 --- mode: elliott set -o elliott
11:02:21 <monochrom> but you're faster anyway
11:02:31 <augur> skchrko: forget being a regular, when the bot greeted me, i had literally just left the channel then returned
11:02:31 <elliott> I'm actually an op bot.
11:02:32 <waterlaz_> sorry for that
11:02:35 <augur> and then it did it again!
11:02:36 <luite> levi: notdan is using selinux
11:02:36 <chrisdone> luite: i found that interpreted + -O2 breaks when generating core, there's a ticket for it on trac. sadly -O code and non-optimized code is quite different. e.g. IO isn't done as real-world passing
11:02:48 <elliott> waterlaz_: hehe, no big deal
11:02:53 <augur> waterlaz_: your bot is not smart enough. obviously you need to make it do full AI
11:03:10 <chrisdone> luite: simon marlow said it's buggy because nobody uses -O2 in combination with ghci, or so
11:03:16 <luite> chrisdone: non-optimized is just going through the bind function of the monad, right?
11:03:20 <chrisdone> righht
11:03:26 <waterlaz_> it wasn't supposed to be working on this channel anyway
11:03:34 <luite> internally it would still use the realworld passing :)
11:03:58 <luite> chrisdone: you have source-map utility stuff on hackage, right?
11:04:10 <chrisdone> luite: yep! updated it a few times to work for this demo, should be solid
11:04:17 <waterlaz_> Hello milessabin and welcome to #haskell
11:04:18 <luite> awesome :)
11:04:58 * nichthus tries to imagine a channel where that bot would be anything but annoying
11:05:00 <arkeet> waterlaz_: so.
11:05:11 <waterlaz_> wth...
11:06:03 <luite> chrisdone: well i think that the concurrent ghcjs runtime might not benefit as much from source maps since the js code is rather weird, but i definitely want it when i finally finish updating the non-concurrent runtime to gen2/jmacro
11:06:05 <ski> waterlaz : perhaps try your experimenting with a different client process ?
11:06:23 <chrisdone> luite: initially i had trouble with figuring out whether lines and columns start from 1 or 0, but there's a site that gives you a visual representation of your source map from your from/to files that was really helpful. let me find it…
11:06:29 <elliott> hello waterlaz and welcome to #haskell :)
11:06:33 <luite> ah
11:06:34 <waterlaz> :3
11:06:40 <waterlaz> should be fixed now
11:06:41 <monochrom> onoes
11:06:52 <monochrom> /mode +q elliott!*@*
11:07:08 <chrisdone> luite: for your bookmarks! http://sokra.github.io/source-map-visualization/#coffee
11:07:17 <luite> chrisdone: i don't really have to debug the generated js very often though :)
11:07:39 <luite> tnx added
11:07:42 <chrisdone> yeah =)
11:08:27 <chrisdone> i also mapped exception throwing so that the console would show the original line/col
11:08:35 <luite> and i'm finally getting some proper generated code size reductions in ghcjs
11:08:44 <chrisdone> if your exceptions are implemented not as js exceptions it probably isn't relevant
11:08:53 <chrisdone> cool =]
11:09:21 <luite> xs :: [Int], xs = [1,2,4,8,16,32] used to generate 50 lines or so, now it's h$xs = h$cl([1,2,4,8,16,32]);
11:10:13 <chrisdone> luite: tiny code is possible from core too: http://lpaste.net/5332270355467730944
11:10:29 <Maerten> chrisdone i just came back to my computer, i cant see if you posted a new lpaste.net with your faster version of the program (irc log goes back only 30 minutes :/ )
11:11:18 <Maerten> chrisdone: if not, no worries, it's not really important as it was just a curiousity about the performance, and i'm sure i'll learn how to do better as i get more experience with haskell
11:11:19 <chrisdone> luite: i saw that core/stg makes unboxing and boxing explicit so with -O2 that code should generate a much faster fib, but i didn't implement that yet. i should look at haste properly before continuing
11:11:19 <ski> Maerten : try <http://tunes.org/~nef/logs/haskell/13.09.12> ?
11:11:23 <luite> chrisdone: yeah i prefer to do eval/apply though, fully currying has a rather bad effect on performance :)
11:11:28 <chrisdone> Maerten: hang on, i'll re-paste
11:11:38 <luite> chrisdone: yeah -O2 will use the worker/wrapper transformation
11:11:41 <luite> for this
11:11:45 <Maerten> luite: thanks!
11:11:51 <chrisdone>  Maerten: http://lpaste.net/92891
11:12:00 <Maerten> very fast and helpful responses from you guys here!
11:12:03 <chrisdone> Maerten: cabal install mysql-simple
11:12:07 <luite> chrisdone: ghcjs can run the inner loop without doing any allocations in js :)
11:12:13 <chrisdone> Maerten: and then ghc --make whatever.hs =)
11:12:19 <luite> for fib with -O2
11:12:43 <Maerten> chrisdone: thanks!!
11:12:58 <chrisdone> luite: nice =)
11:13:06 <chrisdone> Maerten: welcome, let me know if it works ;)
11:13:52 <luite> chrisdone: well the problem with xs = [1,2,3,4,5] in core is that wil generate lots of top-level xs5i = I# 5, xs5c = (:) xs5i [], xs4i = I# 4, xs4c = (:) xs4i xs5c ...
11:14:08 <Maerten> chrisdone: 'm sure it will work. but now i'm stuck here: mysql-simple-0.2.2.4 depends on mysql-0.1.1.4 which failed to install.
11:14:09 <chrisdone> luite: surely closure inlines all that
11:14:14 <Maerten> will report later when i fixed it ;D
11:14:26 <chrisdone> Maerten: why did mysql fail to install?
11:14:53 <chrisdone> you *might* need to install  mysql_config  or something like that with your OS's package manager
11:14:57 <Maerten> chrisdone: i get a lot of errors.. i'll paste them at lpaste
11:15:04 <chrisdone> Maerten: yeah paste it
11:15:06 <luite> chrisdone: it doesn't seem to, and even if it did with some tweaking, the code would be not terribly great:
11:15:46 <chrisdone> jfischoff: i like pluxus!
11:15:52 <jfischoff> :)
11:16:00 <Maerten> chrisdone: http://lpaste.net/6066720844099354624
11:16:08 <Maerten> chrisdone: i'm on osx
11:16:11 <notdan> levi: I thought about LXC but never got around to actually implementing support for it. I use plain CGroups though
11:17:08 <luite> chrisdone: xs = [1,2,3] -> xs = h$c2(cons,h$c1(I#,1),h$c2(cons,h$c1(I#,2),h$c2(cons,h$c1(I#,3),nil)));
11:17:13 <chrisdone> Maerten: ah, mysql_config was related, but not in the way i expected =) umm
11:17:47 * ski idly wonders how LPaste (apparently ?) got to such high paste numbers
11:18:10 <benmachine> ski: private pastes
11:18:22 <benmachine> they try to have less guessable numbers
11:18:40 <ski> i see, ty
11:18:43 <chrisdone> benmachine: the oopma lambdas try so hard
11:18:47 <luite> chrisdone: although that's before unboxing the ints
11:18:59 <luite> in reality ghcjs unboxes all ints
11:19:14 <chrisdone> luite: yeah, no point boxing them
11:19:29 <chrisdone> Maerten: hmm. i'm guessing it's a ghc version diff, just checking
11:19:47 <luite> chrisdone: well the 'enter thunk' code gets slightly more complex, having to do typeof checks
11:19:52 <chrisdone> Maerten: the latest version of mysql compiles with ghc 7.4: http://hackage.haskell.org/package/mysql
11:19:56 <luite> but overall it's a win
11:20:12 <Maerten> i've got 7.6.3
11:20:14 <chrisdone> Maerten: so i would guess that your ghc 7.6 is too new
11:20:17 <nichthus> data BF = Branch [BF] | Branchless { increments :: Zipper Word8, headMotion :: Integer }
11:20:27 <benmachine> chrisdone: I'd guess it's Cabal version that's the important thing
11:20:35 <benmachine> but I suppose that's tied to GHC version
11:20:37 <chrisdone> benmachine: yeah
11:20:48 <benmachine> although you're allowed to upgrade Cabal
11:20:51 <Maerten> chrisdone: i've got cabal 1.18.0..
11:20:55 <benmachine> downgrading it? umm...
11:21:01 <luite> chrisdone: works for all types that have one small unboxed field, so Char, Word, Word8, Word32, Word16, Int16, Int8, Int32, Double, Float and everything that looks like those are unboxed
11:21:24 <chrisdone> benmachine: i think downgrading cabal would kill maerten's future children
11:21:35 <benmachine> chrisdone: :P
11:21:42 <dcoutts> benmachine: downgrading is probably ok, but it's not guaranteed to build of course
11:22:06 <benmachine> dcoutts: but you'd have to somehow persuade the Setup.lhs to build with the old version, I've no idea how you'd do that
11:22:34 <chrisdone> yeah, this is embarassing. newbie comes to use mysql, can't even install the package
11:22:36 <monochrom> consider --cabal-lib-version=...
11:22:44 <chrisdone> Maerten: don't worry, we'll figure it out
11:22:50 <luite> chrisdone: btw this was a dicussion in #ghcjs yesterday about bindings and non-haskell libs. if you have jquery and you expect your own code to be minified with closure compiler and load jquery from a cdn, you have to use x['y'] properties for jquery, or you need a closure externs definitions file
11:22:50 <benmachine> monochrom: :o I didn't know there was such a thing
11:23:03 <dcoutts> benmachine: the Setup.hs for Cabal itself builds using itself
11:23:16 <dcoutts> benmachine: I don't think I see the problem you see
11:23:28 <joe9> I am getting these error messages: http://codepad.org/U6ImWisJ not sure how to fix them. any thoughts, please?
11:23:29 <benmachine> dcoutts: yes, but I mean, once you've installed this old version, and you want to use it to compile some Setup.lhs of some other package
11:23:35 <Maerten> chrisdone: great service you guys give here ;D
11:24:09 <dcoutts> benmachine: you mean how will you select it over the new one? using ghc -package I suppose, or using cabal --cabal-lib-version=
11:24:12 <luite> chrisdone: but say you bind jquery-ui, where it's potentially beneficial to also minify it with closure (if it works, i haven't checked that), then you have an incompatibility, if oyu use x['y'], you can't include jquery-ui in the closure bundle, if you use x.y you can't use it separately. how to solve this?
11:24:13 <Maerten> at least someone is thinking of the children
11:24:15 <benmachine> dcoutts: but I didn't know about --cabal-lib-version, that sounds like it would do the trick
11:24:39 <dcoutts> benmachine: or manually using ghc --make Setup.hs -package Cabal-1.16.0.3 or whatever
11:24:58 <chrisdone> hmm, so maybe try: cabal install mysql --cabal-lib-version=1.16.0.3 ?
11:25:32 <chrisdone> Maerten: try that, if that fails we can try the manual route
11:25:45 <dcoutts> you need that version installed already
11:26:00 <chrisdone> can it be installed from hackage without causing breakages?
11:26:01 <monochrom> well, it comes with GHC
11:26:08 <Maerten> user error (The package 'mysql' requires Cabal library version ==1.16.0.3 && >=1.6 but no suitable version is installed.)
11:26:10 <benmachine> the thing that confuses me is that it looks like findProgramLocation hasn't had a ProgramSearchPath argument for ages
11:26:11 <chrisdone> monochrom: the problem is he has a newer ghc
11:26:19 <monochrom> how new? 7.8?
11:26:22 <chrisdone> 7.6
11:26:33 <benmachine> chrisdone: what setup do we /know/ compiles mysql?
11:26:43 <monochrom> that's going to be 1.16.0 or 1.16.something
11:26:51 <chrisdone> hackage says ghc 7.4 can build mysql
11:26:53 <dcoutts> Maerten: you've got some older Cabal, just do ghc-pkg list Cabal to find out
11:27:11 <monochrom> oh, I see, we want the Cabal that came with 7.4
11:27:27 <dcoutts> benmachine: the extra path arg is new in 1.18
11:27:33 <benmachine> dcoutts: ah, okay
11:27:46 <chrisdone> dcoutts: surely he has a newer cabal?
11:27:47 <benmachine> of course, I was reading the error the wrong way around
11:27:55 <monochrom> 7.4.2 is 1.14.0
11:27:59 <chrisdone> ahh
11:28:04 <Maerten> dcoutts: hm i guess i got both 1.16 and 1.18
11:28:41 <Maerten> i could delete everything and reinstall.. what should i do? just install the newest or some specific version?
11:28:54 <benmachine> Maerten: it's probably not necessary to do that
11:29:00 <monochrom> don't delete what comes with GHC. just don't.
11:29:06 <chrisdone> Maerten: what's the precise 1.16 version you have?
11:29:19 <dcoutts> Maerten: so for explanation, the Setup.hs that the mysql package uses does not work with the new Cabal lib. Eventually someone will update it, but for now you can build it using the older one: --cabal-lib-version=1.16.0
11:29:28 <Maerten> 1.16.0
11:29:35 <chrisdone> cool, like dcoutts said then
11:29:38 <dcoutts> Maerten: a small number of Setup.hs scripts are affected by this
11:29:49 <dcoutts> so you likely will not run into it much
11:30:11 <Maerten> ok thx
11:30:25 <chrisdone> will it blend?
11:30:54 <monochrom> blending is too easy. I want unblending.
11:31:09 <Maerten> " Installed mysql-0.1.1.4 "
11:31:11 <Maerten> ;P
11:31:25 <joe9> can anyone please help with this: http://codepad.org/QotHlABU
11:31:40 <chrisdone> Maerten: yay! so try cabal install mysql-simple
11:32:06 <Maerten> with or without the --cabal-lib-version flag?
11:32:12 <chrisdone> without, i think
11:32:24 <Maerten> yeah it worked
11:32:27 <chrisdone> woot
11:32:29 <Maerten> ::D
11:32:34 <chrisdone> so does the original program i pasted work? =p
11:33:49 <chrisdone> joe9: sorry, i don't know what would cause such an error
11:34:02 <Maerten> yeah it works. the duration is a negative number though ;p anyway it's a bit faster, even with -O2
11:34:09 <joe9> I deleted dist folder and tried multiple times. same error.
11:34:11 <chrisdone> jfischoff: http://www.youtube.com/watch?v=ZE6At3u1aVM
11:34:21 <chrisdone> Maerten: ahh, i got the diffUTCTime wrong
11:34:26 <joe9> chrisdone: any suggestions on who could help, please?
11:34:34 <chrisdone> Maerten: just flip the args of the diffUTCTime call =p
11:34:42 <joe9> chrisdone: or how to go about trying to fix it.
11:35:01 <Maerten> chrisdone: i will. so what's the best way to compile? ghc -O2 --make <program> ?
11:35:21 <chrisdone> joe9: at a guess, maybe someone in #ghc might know about common linking problems. or otherwise email the author of the package
11:35:27 <chrisdone> Maerten: yeah
11:35:40 <joe9> chrisdone: looks like it has to do with Exposed-modules. thanks and sorry for the bother.
11:35:44 <chrisdone> Maerten: ghc --make Foo.hs -O2
11:36:29 <chrisdone> joe9: haven't a clue, the error is greek to me
11:37:09 <chrisdone> Maerten: is it slower than the php version still?
11:37:09 <Maerten> chrisdone: so yours is about 0.13s average, mine was 0.16s. so that's good :D the php version still runs in 0.09s though
11:37:22 <chrisdone> outrageous!
11:37:39 <chrisdone> Maerten: can i see the php code?
11:37:49 <Maerten> it is! sure i'll paste it
11:38:28 <Maerten> http://lpaste.net/5703195211597873152
11:38:53 <chuzz> >  Module `Data.Binary.Get' does not export `runGetOrFail'
11:38:54 <lambdabot>   <hint>:1:26: parse error on input `does'
11:38:59 <chuzz> what the hell :<
11:39:34 <geekosaur> leading "> " tells the bot to evaluate an expression
11:39:50 <skypers> hi
11:39:58 <skypers> I added a package on hackagedb
11:40:01 <Yaniel> literal haskell or what was it called
11:40:08 <skypers> but I don’t have any link to the documentation I wrote
11:40:10 <skypers> any idea? :(
11:40:11 * hackagebot inject-function 0.1.0.0 - Lets you write regular monadic functions with the extra feature to be able to inject parameters that can be shared over function composition  http://hackage.haskell.org/package/inject-function-0.1.0.0 (DimitriSabadie)
11:40:12 <geekosaur> no, this is not literate haskell
11:40:13 * hackagebot inject-function 0.1.0.1 - Monadic functions with injected parameters.  http://hackage.haskell.org/package/inject-function-0.1.0.1 (DimitriSabadie)
11:40:22 <geekosaur> just a shortcut to @run
11:40:26 <monochrom> lambdabot is unrelated to literate haskell
11:40:29 <nichthus> skypers: Wait a bit. Hackage only builds documentation once a day or so.
11:40:35 <skypers> oooh
11:40:36 <skypers> ok
11:40:38 <skypers> thank you :)
11:41:23 <chuzz> geekosaur, not because of lambdabot, but Data.Binary.Get HAS runGetOrFail :<
11:41:51 <geekosaur> in what version?
11:42:13 <monochrom> I don't have runGetOrFail here
11:43:00 <chuzz> hmm, http://hackage.haskell.org/packages/archive/binary/latest/doc/html/Data-Binary-Get.html here it exists
11:43:17 <chuzz> but ghci doesn't show it
11:43:32 <monochrom> "latest" != "yours"
11:43:32 <elliott> APIs change over time
11:43:42 <chrisdone> Maerten: hmm. i can't see anything particularly different. i suggest increasing the data set to check we're benchmarking the query and not start-up time
11:43:54 <monochrom> in this case it's 0.5.1.1 vs 0.7.1.0
11:44:20 <monochrom> please use the doc that matches your version. please.
11:44:59 <monochrom> in fact, binary comes with GHC, its doc comes with GHC too, it's somewhere on your hard disk
11:45:23 <monochrom> people spend 9 lives browsing the web and not 1 minute browsing their own disk
11:45:44 <Maerten> chrisdone: will do, thanks a lot! though i would expect the startup time of a compiled program to shorter than running a php script.. i'll be back next time!
11:45:58 <k0001> monochrom: Wait.. what? Can you save stuff outside the Internet?
11:46:25 <Yaniel> if you can hide it from the cats
11:46:26 <chuzz> yup, that's the reason :>
11:46:35 <monochrom> yes. clearly, you have never installed GHC on the internet
11:46:43 <chrisdone> Maerten: a trivial way to increase the data set to three times bigger is: SELECT id, begin, end FROM issue_timer UNION ALL SELECT id, begin, end FROM issue_timer UNION ALL SELECT id, begin, end FROM issue_timer;
11:46:52 <chuzz> i have binary-0.7 in cabal-dev folder, but "cabal list" gives me 0.5
11:47:19 <monochrom> "cabal list" lies. use "ghc-pkg list"
11:47:46 * k0001 wishes he could install GHC on the Internet, whatever that means.
11:47:50 <chrisdone> Maerten: yeah i'm not sure what the start-up time is, or time to connect to the server or the time to actually get the results without clocking them
11:47:58 <chrisdone> k0001: fp complete ide!
11:47:58 <monochrom> but ghc-pkg is not aware of your cabal-dev folder. use a cabal-dev command
11:48:00 <jfischoff> chrisdone: http://grooveshark.com/#!/s/Even+Spring/53zfAv?src=5 The first part is the construction of the thunks, the second the reduction.
11:48:43 <k0001> chrisdone: hah, yes, quite appropriate answer!
11:49:09 <Maerten> chrisdone: ok i'll try that quickly
11:50:14 <monochrom> good abstraction > no abstraction > leaky abstraction
11:50:15 <k0001> `cabal-dev ghc-pkg list` exists
11:50:15 <chrisdone> jfischoff: nice =)
11:50:46 <chrisdone> Maerten: what're the times with thrice the data set?
11:51:25 <monochrom> good abstraction makes you learn just one layer. no abstraction makes you make just one layer too, just that it's lower level. still, just learn one layer
11:51:34 <monochrom> leaky abstraction makes you learn two layers.
11:52:03 <monochrom> may as well screw the leaky abstraction layer and just learn one low level layer.
11:52:48 <k0001> Two if you are lucky. Some leak really deep.
11:53:26 <luite> chrisdone: are local installations coming soon?
11:53:40 <Maerten> chrisdone: i did 5x the dataset. php 0.3s   haskell version 0.8s   your version 0.6s
11:53:55 <nicoo> Maerten: What kind of application ?
11:54:00 <chrisdone> Maerten: huh? more data made it take less time?
11:54:12 <chrisdone> ah, seconds
11:54:26 <Maerten> nicoo: i'll give you the url of the source, sec
11:54:54 <Hexagenic> Maerten: Having negative complexity is the dream.
11:55:20 <chrisdone> luite: i think that's planned for december
11:55:46 <nicoo> Hexagenic: There is a joke amongst Googlers about the inventor of MapReduce wanting so much speedup that he invented the first O(1/n) algorithm :)
11:56:01 <Apocalisp> so, Writer lets you do monoidal things "on the side". Is there a monad that lets you do abelian group things instead?
11:56:05 <Maerten> http://lpaste.net/5703195211597873152 <-- php version     http://lpaste.net/92891 <-- haskell version by chrisdone    http://lpaste.net/7481677581880655872 <-- my haskell version
11:56:11 <luite> chrisdone: ok
11:56:17 <nicoo> Maerten: Thanks
11:56:27 <Maerten> one note: only my version has the update query that generates 5x more data as suggested by chrisdone
11:56:33 <monochrom> Apocalisp: perhaps your monoid happens to be an abelian group. such as Int.
11:56:34 <Maerten> updated* query
11:56:42 <Maior> I have a Thing, and a set of BoundedChans - what am I looking for if I want to write to them all, blocking 'til the last is done?
11:57:09 <chrisdone> Maerten: hmm. in the php version, strtotime is converting to an int
11:57:39 <chrisdone> i suppose that's an algorithm difference
11:58:00 <Maerten> chrisdone: i wanted to do that with haskell but this is all i could get to compile ;D
11:58:06 <chrisdone> Maerten: haha
11:58:29 <chrisdone> Maerten: how about commenting out the mapM_ line, what is the speed for my version?
11:58:49 <Maerten> chrisdone: so just the sql query?
11:58:51 <chrisdone> Maerten: i'm curious to see whether the printing costs anything
11:58:52 <chrisdone> yeah
11:59:18 <chrisdone> ah wait
11:59:29 <chrisdone> it'll give you an ambiguous type error
11:59:36 <Maerten> indeed :<
12:00:01 <chrisdone> put :: IO [(Int,UTCTime,UTCTime)]
12:00:10 <chrisdone> at the end of the query conn line
12:00:26 <chrisdone> then it knows what types to convert
12:00:37 <Maerten> 0.12s
12:00:48 <chrisdone> interesting. so printing costs 500ms?
12:01:31 <ski> Apocalisp : why group ?
12:01:53 <ski> (iow, what would make it invoke the group inverse ?)
12:01:54 <monochrom> perhaps group because an "untell" is wanted
12:01:58 <Maerten> chrisdone: yeah or the calculating the time diff.. when i redirect the output to /dev/null there is 0.1s speedup
12:02:22 <chrisdone> Maerten: let's try ints
12:02:22 <monochrom> class Monoid a => Group a where inverse :: a -> a
12:03:28 <Okasu> w0rp: Advantage over what?
12:03:29 <Apocalisp> ski: I want to do provenance tracking in queries. The inverse comes into play when a query is filtered.
12:03:34 <monochrom> class (MonadWriter m w, Group w) => MonadUnwriter m w where { untell :: w -> m (); untell x = tell (inverse x) }
12:04:10 <monochrom> I forgot a "| m -> w"
12:04:14 <nicoo> monochrom: That Monoid a => Group a instance is scary :o
12:04:34 <monochrom> I wrote no such instance.
12:04:37 <Maerten> chrisdone: i have to go afk now though.. if you are interested to see how it goes you could leave a PM, then i'll get back here with the results in a few hours
12:04:57 <chrisdone> Maerten: sure
12:04:59 <Maerten> chrisdone: but no worries, you already helped a lot :D
12:05:07 <Maerten> thanks again!
12:05:16 <chrisdone> welcome =)
12:05:23 <joe9> any thoughts on how I can join these 2 functions, please? *Main ControlTransactions System.USB Test.HUnit Text.Groom Text.Printf> :t mapReader (TestLabel "test" . TestCase . checkBit "test" False 1)
12:05:24 <joe9> mapReader (TestLabel "test" . TestCase . checkBit "test" False 1)
12:05:24 <joe9>   :: Reader r Word8 -> Reader r Test
12:05:24 <joe9> *Main ControlTransactions System.USB Test.HUnit Text.Groom Text.Printf> :t check wrdi
12:05:27 <joe9> check wrdi :: ReaderT Device IO Word8
12:05:30 <joe9> *
12:05:33 <joe9> sorry for the above paste.
12:05:43 <joe9> I meant to paste it to codepad.
12:05:53 <joe9> mistyped /mis-pasted it here.
12:06:09 <joe9> paste: http://codepad.org/YVGlUY9d
12:06:42 <nicoo> monochrom: Funnily enough, it would mean that all monoids are (Z/2Z) vector spaces :)
12:06:57 <ski> Apocalisp : hm, what does "provenance tracking" mean ? (any relation to "truth/reason maintainence" ?)
12:07:13 <tpsinnem> hey -- what does the '~' mean in 'Could not deduce (a1 ~ FingerTree (Sum Integer) a1)' ?
12:07:29 <geekosaur> type equality
12:07:43 <tpsinnem> ok
12:07:47 <tpsinnem> thanks
12:08:14 <Apocalisp> ski: Say you join two tables t1 and t2. The provenance of the result would be a set [t1, t2].
12:08:40 <ski> "tables" as in relational database model relations ?
12:08:40 <monochrom> why do people read what I never wrote, and never read what I wrote?
12:08:48 <Apocalisp> ski: Yeah
12:09:31 <ski> i still don't understand
12:09:37 <chrisdone> monochrom: 'cause you ain't fresh, y'unastand?
12:10:02 <Apocalisp> ski: Say you then filter out all the elements from t1. Then the provenance is just [t2], and I want to reflect that.
12:10:47 <ski> is the provenance which base/extensional relations the query depends on ?
12:11:21 <Apocalisp> ski: Something like this http://db.cis.upenn.edu/DL/07/pods07.pdf
12:11:30 <Apocalisp> ski: Yes
12:13:01 <joe9> I am trying to get the Word8 from the "check wrdi " function into  mapReader (TestLabel "test" . TestCase . checkBit "test" False 1)
12:13:54 <Apocalisp> ski: Could be used for other applications as well, like a probability monad. Say you had a biased die and a fair die. For any given distribution, I'd like to know how much of it was contributed by fair dice.
12:17:49 <ski> Apocalisp : interesting
12:18:35 <ski> tpsinnem : looks like you confused a finger tree for an element of a finger tree, or vice versa, somewhere
12:18:59 <tpsinnem> ski: yeah, i have the original problem actually figured out
12:19:40 <tpsinnem> but that part of the error message i hadn't understood with certainty
12:21:56 <mstksg> i wish that the only problems i had to deal with during development were programming problems
12:22:13 <identity> Does anyone here use haskellmode-vim? I'm having trouble getting it to work properly. There are a bunch of commands listed in the documentation, such as _T and _t, but nothing simply happens when I press that key combination. Is _ a placeholder for something else, or something of that nature?
12:22:42 <mstksg> identity: i use it; the _ really is the actual key binding out of the box
12:23:01 <mstksg> some of them just seem to be unresponsive for me, though ... i've never really looked too far into it
12:23:43 <identity> mstksg: I've been happy just using ghcmod until now thb, but wanted to see if I could enhance my experience further. I can see _? works, but very few other commands seem to work, such as :GHCi, _T or _t and so on.
12:26:42 <mstksg> identity: do you have your documentation directory set properly?
12:27:19 <identity> mstksg: Aye, it seems to work fine
12:29:02 * monochrom reads Haskell Weekly News!
12:29:16 <mstksg> i'm sorry to say i haven't pursued the issue much further, just wanted to add my two cents to confirm that _ commands really are _ commands.  maybe someone else here can help
12:29:25 <aristid> monochrom: hoogle doesn't find it. i'll try google next.
12:29:33 <identity> mstksg: well, that was a big part of what I needed to know, thanks ;)
12:30:01 <monochrom> I receive Haskell Weekly News right in my haskell-cafe subscription
12:30:02 <Zenol> Hi,
12:30:03 <aristid> monochrom: your quote is last place.
12:30:09 <aristid> monochrom: clearly you lost.
12:30:12 <mstksg> identity: np, and if you find any solutions please let me know :)
12:30:27 <monochrom> no, I think last place is the punch line, I won :)
12:30:37 <Zenol> I have a strange warning about pattern matching on Word8 http://lpaste.net/92902 Seams that GHC isn't smart enougth to understand that 0x100 = 0x00.
12:32:03 <arkeet> 273# ???
12:33:03 <mauke> Zenol: dispatchCB, not dispatch
12:33:13 <arkeet> heh.
12:33:21 <Zenol> Yes, sorry, dispatchCB.
12:33:31 <mauke> show real code
12:33:33 <arkeet> so you wrote 256 cases from 0x00 to 0xff?
12:33:37 <arkeet> that too
12:34:39 <identity> mstksg: For what it's worth, it's possible haskellmode-vim is just outdated tbh. Looks like it hasn't been updated for a year, possibly more
12:35:20 <Zenol> mauke: You really want to see 256 lines of dispatchCB? If so it's available here : https://github.com/Zenol/hgb/blob/master/src/HGB/CPU.hs line 252. But as you can see in the error message, all 0->255 values are tested.
12:35:46 <Zenol> arkeet: Yes, 0x00 to 0xff. But ghc think that 0x100, 0x101, etc. are missing.
12:36:25 <Zenol> (I tested with dispatchCB 0x100 = undefined and then the value was added to the list in the error message)
12:36:35 <mauke> Zenol: what's the error message?
12:37:09 <arkeet> sort of understandable. Word8 has values beside 0x00 - 0xff. (as can be seen by usnafeCoerce)
12:37:21 <arkeet> unsafeCoerce
12:37:22 <geekosaur> they already pasted it, it's in the comment in http://lpaste.net/92902 ? (hence arkeet's comment about 273# showing up out of nowhere for a Word8)
12:37:35 <mauke> geekosaur: where's the filename and line number?
12:38:43 <Zenol> mauke: The error message is here : http://lpaste.net/92902
12:39:02 <mauke> Zenol: where's the filename and line number?
12:39:51 <joe9> Is it possible to compose a function returning ReaderT with a function looking far a Reader input?
12:40:06 <mstksg> is there some kind of convention for version numbering where i can specify a range and feel safe about api changes?
12:40:52 <arkeet> @where pvp
12:40:52 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
12:40:58 <mstksg> arkeet: thanks
12:41:21 <Zenol> arkeet: But it 'should' pattern match on one of these values, right?
12:41:43 <hpaste> Zenol annotated “Wrong warning on pattern matching a Word8 value.” with “For mauke” at http://lpaste.net/92902#a92904
12:41:47 <arkeet> Zenol: let say I gave you unsafeCoerce (0x100 :: Word32)
12:41:49 <arkeet> what would you do?
12:42:04 <bjorkintosh> i would watch some television.
12:42:18 <bjorkintosh> and pretend i was not coerced.
12:42:22 <bjorkintosh> :D
12:42:22 <arkeet> data Word8 = W8# Word#
12:42:24 <Zenol> arkeet: 0x00 ?
12:42:29 <arkeet> Zenol: that's the thing.
12:42:31 <arkeet> it doesn't equal that.
12:42:55 <Zenol> arkeet: Arg, it's horrible :)
12:43:13 <mauke> arkeet: dispatchCB op' = error $ "Pefix CB not implemented for: " ++ (printf "0x%02x" op')
12:43:19 <mauke> it should match that
12:43:23 <mstksg> arkeet: the article explains as much as i had assumed.  i've run into packages that disregard it, so i was hoping there was some grander scheme in place. i guess not :/
12:43:26 <Zenol> mauke: I removed it.
12:43:36 * mauke gives up
12:44:15 <arkeet> mstksg: yeah :<
12:44:27 <joe9> which should I use? Control.Monad.Reader or Control.Monad.Trans.Reader?
12:44:35 <Clint> i like transformers
12:44:55 <Zenol> arkeet: Then, I suppose I should write something like "dispatchCB _ = undefined -- Can't happen from a safe Word8" ?
12:45:13 <arkeet> Zenol: you already have that.
12:45:16 <mstksg> it's a fairly well-established package that is used everywhere, so i had hoped it followed this.  is it proper for me to alert the maintainer about this?  or is there really nothing that could be done
12:45:16 <arkeet> dispatchCB op' = error $ "Pefix CB not implemented for: " ++ (printf "0x%02x" op')
12:45:39 <arkeet> mstksg: what package? what api change?
12:45:41 <Zenol> arkeet: I removed it. It was here when some opcode was still missing.
12:46:27 <Zenol> arkeet: Is it better to leave an error, or just "undefined" ?
12:46:47 <arkeet> I would personally leave the error I guess.
12:47:14 <mstksg> arkeet: it's aeson, and Data.Aeson.TH.deriveJSON changed from :: (String -> String) -> Name -> Q [Dec] to :: Options -> Name -> Q [Dec], where Options is a data type containing multiple functions that can be configured, instead of just offering one configurable function as before
12:47:16 <Lethalman> joe9, you can ask = <runReader
12:47:18 <Lethalman> ops
12:47:22 <mstksg> from 0.6.1.0 to 0.6.2.0
12:47:26 <arkeet> I would kind of rather put that big thing not as some big branchy thing in your function though. I dunno.
12:47:38 <mstksg> although i guess if you "drop" the first digit, it makes sense if you consider it as 6.1.0 and 6.2.0
12:47:43 <Lethalman> joe9, you can ask >>= runReader
12:48:10 <Lethalman> or something like that
12:48:11 <sclv_> haha yeah that's unfortunate
12:48:13 <arkeet> mstksg: well, we shouldn't consider it like that. :p
12:48:17 <joe9> Lethalman: good idea. thanks.
12:48:45 <sclv_> too late to fix it now, but aeson tries to be a good citizen usually, so i think this was an oversight on the part of bos
12:48:59 <hpaste> aranea pasted “parsec whitespace problem” at http://lpaste.net/2247930838425534464
12:49:04 <sclv_> lots of the generic stuff i think he considers less 'core' and it tends to be maintained by other ppl
12:49:31 <arkeet> mstksg: but yeah, sometimes people don't follow the PVP and it's sad. =(
12:49:32 <arkeet> aranea: what is the problem?
12:50:08 <aranea> Hi. I'm parsing math expressions with Parsec's buildExpressionParser. The pasted parser is the second argument for that function, and I want it to ignore whitespace
12:50:13 <Zenol> arkeet: What do you means? Looking through a [(Word8, VmS Clock)] list?
12:50:24 <mstksg> sclv_: is this something that is worth bringing up to him/to the issue tracker?
12:50:44 <mstksg> it's not really a major API change so it wasn't too hard to fix; i was just surprised at things breaking suddenly.
12:50:46 <arkeet> Zenol: something like that? except I wouldn't use a list since that's slow.
12:50:53 <aranea> you can see how I tried it, but it doesn't seem to work
12:51:14 <Zenol> arkeet: Yeh, dispatch/dispatchCB are the cost center of the app. Any change shouldn't reduce efficiency :/
12:51:44 <mstksg> sclv_: oh, apparently i am not the first one to figure this out, there is already discussion about it on the issue tracker
12:52:10 <arkeet> Zenol: I dunno. you could try using Vector and see what the performance is like.
12:52:16 <monochrom> aranea: I cannot see how you tried, because I cannot see what is num, var, etc
12:52:48 <aranea> monochrom: they all don't match on spaces
12:53:11 <aranea> my try was the "many (char ' ') *> (...)
12:53:34 <aranea> before, it was just the (...)
12:53:38 <monochrom> and I cannot see how term is used
12:54:17 <aranea> as I said, as the second argument to buildExpressionParser
12:54:40 <monochrom> that may not be enough information
12:54:55 <aranea> should I paste everything? it's quite much
12:55:04 <monochrom> it's up to you
12:55:13 * hackagebot ghc-parmake 0.1.7 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.7 (MikhailGlushenkov)
12:57:14 <aranea> one moment
12:59:43 <Zenol> good night :)
13:01:21 <skypers> hey
13:01:35 <skypers> I have a data written with record syntax
13:01:36 <skypers> like
13:01:48 <skypers> newtype A a = A { foo : … }
13:02:07 <skypers> I want to export all symbols but th ctor
13:02:11 <skypers> I thought something like
13:02:20 <skypers> module A ( A(foo) ) where ( …
13:02:21 <skypers> would make it
13:02:27 <skypers> but I don’t have foo in haddock
13:02:29 <skypers> is it normal?
13:03:08 <monochrom> you have too many A's. but it's module ModuleName(A(..)) or module ModuleName(A(A, foo))
13:03:36 <monochrom> oh, you don't want that A
13:03:41 <skypers> yeah
13:03:41 <skypers> so
13:03:46 <skypers> (A, foo)
13:03:46 <skypers> ?
13:04:02 <monochrom> I don't know. try that. but if that doesn't work either, I don't know
13:04:04 <skypers> or just (A(foo))
13:04:11 <skypers> gonna try that
13:04:21 <elliott> haddock not documenting it doesn't mean it's not exported, necessarily.
13:04:23 <skypers> yeah A(foo) doesn’t work
13:04:25 <arkeet> not that that woudl prevent anyone from constructing their own values of type A.
13:04:32 <arkeet> undefined{foo = ...}
13:04:37 <skypers> elliott: yeah yeah
13:04:39 <skypers> but hell :
13:04:44 <skypers> http://hackage.haskell.org/packages/archive/inject-function/0.1.0.1/doc/html/Control-InjFun.html
13:04:49 <skypers> something is missing here
13:04:53 <skypers> you can look the source
13:05:01 <skypers> the cfapply function is not documented as it should be
13:05:04 <monochrom> well, we want proper docs, don't we? :)
13:05:04 <elliott> I disagree, looks fine.
13:05:10 <ski> > undefined{rootLabel = (),subForest = []}
13:05:11 <lambdabot>   *Exception: Prelude.undefined
13:05:11 <elliott> you did not give cfapply any documentation
13:05:17 <arkeet> skypers: if you don't want people constructing your A, don't export the constructor or its accessors.
13:05:22 <elliott> ski: it's a newtype
13:05:25 <arkeet> you can export another function equal to an accessor.
13:05:29 <skypers> arkeet: look at my package
13:05:34 <skypers> I don’t export the ctor at all :)
13:05:42 <elliott> skypers: it doesn't matter.
13:05:46 <elliott> it's a newtype so you can do undefined { cfapply = ... }
13:05:49 <ski> hm, point
13:05:56 <skypers> elliott: what do you mean?
13:06:02 <elliott> I mean it's a newtype so you can do undefined { cfapply = ... }. try it.
13:06:10 <skypers> huh
13:06:13 <arkeet> > undefined { getSum = 5 }
13:06:14 <lambdabot>   Sum {getSum = 5}
13:06:17 <skypers> I don’t understand that syntax :D
13:06:17 <arkeet> no Sum needed.
13:06:20 <arkeet> record update.
13:06:23 <skypers> ah
13:06:29 <skypers> I didn’t understand
13:06:33 <ski> @let newtype T a = C {s :: a} deriving Show
13:06:34 <lambdabot>  .L.hs:155:9:
13:06:34 <lambdabot>      Multiple declarations of `T'
13:06:34 <lambdabot>      Declared at: .L.hs:141:6...
13:06:40 <monochrom> isn't Haskell exciting? :)
13:06:50 <skypers> ok so hm
13:06:54 <skypers> I just have to write
13:06:56 <ski> @let newtype NewType a = C {s :: a} deriving Show
13:06:57 <lambdabot>  Defined.
13:07:01 <skypers> InjFun, cfapply
13:07:02 <arkeet> now s is ambiguous.
13:07:06 <ski> > undefined {s = ()}
13:07:06 <skypers> not InjFun(cfapply)
13:07:07 <lambdabot>   Ambiguous occurrence `s'
13:07:07 <lambdabot>  It could refer to either `L.s', defined at L.hs:1...
13:07:14 * ski sighs
13:07:22 <arkeet> > undefined{ L.s = () }
13:07:25 <lambdabot>   C {s = ()}
13:08:09 <ski> > fix (\t -> t {L.s = ()})
13:08:12 <lambdabot>   C {s = ()}
13:08:12 <Taneb> I'm having a little trouble with FP Complete's SoH
13:08:49 <arkeet> Taneb: maybe johnw can help
13:08:58 <arkeet> hi johnw
13:09:15 <Taneb> The problem is, I want an active haskell thingy but it starts hidden and has the shown bit near the end
13:09:25 <elliott> why do you define inject rather than just exporting the constructor, skypers?
13:09:43 <skypers> yeah
13:09:53 <skypers> haddock sees the function if out of the type
13:10:03 <enthropy> does haddock properly support type families (when they aren't attached to a class)?
13:10:10 <skypers> type families ?
13:10:12 <enthropy> http://www.haskell.org/pipermail/haskelldoc/2008-July/000256.html suggests it was going to be done
13:10:14 <arkeet> @let data Foo = Foo { bacon :: Int }
13:10:14 <hpaste> aranea pasted “full code” at http://lpaste.net/660097311883395072
13:10:15 <lambdabot>  Defined.
13:10:18 <arkeet> @let foo = Foo 3
13:10:19 <lambdabot>  Defined.
13:10:26 <arkeet> > foo{bacon = 5}
13:10:28 <lambdabot>   No instance for (GHC.Show.Show L.Foo)
13:10:28 <lambdabot>    arising from a use of `M1482149704...
13:10:30 <arkeet> guhhhhhhhhh
13:10:36 <aranea> and now I want that parser to ignore whitespace
13:10:37 * ski grins
13:10:54 <ski> @let deriving instance Show Foo
13:10:54 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
13:10:56 <arkeet> my point is that even if it wasn't a newtype, just having a value with the right constructor would be enough
13:11:10 <arkeet> StandaloneDeriving is one of the most useful extensions to use in ghci
13:11:14 <Taneb> It's just printing out the -- show and -- /show literally in the tutorial
13:11:23 <enthropy> ski: look for -XTypeFamilies in the ghc manual
13:11:34 <enthropy> skypers: ^^ that was for you
13:11:38 <nichthus> > bacon foo{bacon = 5}
13:11:42 <lambdabot>   5
13:11:49 <skypers> ok, thank you
13:11:55 <notdan> Hi! I am looking on some help with TH. I've writen a QuasiQuoter which deals returns Q [Dec]. I've only initialized the quoteDec field, but it appears that TH expects quoteExp for 'runQ'
13:12:08 <notdan> So, how do I actually unroll those declarations I've generated?
13:14:00 <ski> "The OCaml system - 7, Language Extensions - 7.9, Private Types" <http://caml.inria.fr/pub/docs/manual-ocaml-4.01/extn.html#sec221> allows exporting variant and record types so that you can only destruct using the constructors and selectors, not construct
13:14:16 <enthropy> notdan: it will call quoteDec if you put your  [myQuoter| |]  at top-level, or maybe some other place you can have Dec
13:14:37 <notdan> enthropy: so I can't test it in GHCi?
13:14:45 <enthropy> something like    let [myQuoter| ... |] in blah -- might work
13:15:07 <aranea> monochrom: seen my paste?
13:15:13 * hackagebot inject-function 0.1.0.2 - Monadic functions with injected parameters.  http://hackage.haskell.org/package/inject-function-0.1.0.2 (DimitriSabadie)
13:16:14 <benmachine> notdan: what kind of declarations do you generate?
13:16:14 <enthropy> ok so it doesn't work to stick it in a let there
13:16:23 <benmachine> enthropy: are you sure?
13:16:46 <notdan> benmachine: data + instances
13:16:49 * enthropy tried it and has  " parse error on input `in'"
13:18:09 <enthropy> benmachine: is it supposed to work?
13:18:23 <benmachine> enthropy: I'm testing to see if I get the same thing
13:19:39 <hpaste> enthropy pasted “try this benmachine” at http://lpaste.net/92906
13:20:41 <luite> chrisdone: doesn't ghc also add the line info with native code generation (and optimization) if you enable -prof-auto-all through dynflags?
13:20:49 <enthropy> if the quote was allowed, you'd get a stage restriction error
13:21:48 <nichthus> Is there a module out there for modular division? e.g. 3*4=5 mod 7, is there a handy function that I can give 3,5, and 7 as inputs and get 4 as an output? (or [4] or some such thing)
13:21:59 * benmachine wonders why that hpaste line didn't highlight him
13:22:05 <luite> chrisdone: also what is the exact thing that you get the line info from?
13:22:20 <nichthus> maybe benmachine doesn't get highlighted unless it appears at the beginning of the line
13:22:23 <elliott> benmachine: probably your client only highlights at start of line?
13:22:36 <benmachine> nichthus' line did highlight me
13:22:43 <benmachine> so I'm blaming the double quota
13:22:45 <benmachine> *quote
13:23:52 <elliott> whatever you say, "benmachine"
13:23:58 <elliott> if that really IS your real name.
13:24:06 <benmachine> huh, but that highlighted me as well
13:24:14 <nichthus> different quotes
13:24:17 <benmachine> yeah
13:24:26 <benmachine> " vs. ”
13:24:31 <nichthus> try benmachine” perhaps
13:25:03 <enthropy> benmachine: it seems like that quasiquote should be accepted though, right?
13:25:31 <benmachine> enthropy: yes
13:25:32 <nichthus> Failing a module, can anybody tell me the math term to search for so I can implement it myself? "modular division" has been a spectacular failure on Google so far.
13:25:49 <hpaste> chrisdone annotated “mysql-simple (for Maerten)” with “using thyme (for Maerten)” at http://lpaste.net/92891#a92907
13:26:06 <chrisdotcode_> @src maximum
13:26:06 <lambdabot> maximum [] = undefined
13:26:06 <lambdabot> maximum xs = foldl1 max xs
13:26:10 <benmachine> nichthus: I didn't notice your successful non-highlight :P
13:26:13 <chrisdotcode_> @src max
13:26:13 <lambdabot> max x y = if x <= y then y else x
13:26:22 <nichthus> benmachine: ha!
13:26:39 <benmachine> elliott: also, unsurprisingly, it's not my real name :P
13:26:46 <chrisdone> $ time (php x.php > /dev/null) →  real 0m0.066s
13:26:46 <chrisdone> $ time (./x > /dev/null) → real	0m0.022s
13:26:50 <chrisdone> how's that for a slice of fried gold?
13:26:55 <benmachine> it's my real pseudonym? I guess?
13:27:00 <elliott> Ben M. Achine
13:27:12 <chrisdotcode_> chrisdone: heh, bash is faster than php?
13:27:21 <luite> chrisdone: you use the Tickish thing in a Tick in Core?
13:27:23 <chrisdone> no, haskell
13:27:33 <chrisdone> luite: yeah
13:27:53 <chrisdone> luite: er hang on, i'll get it
13:28:03 <benmachine> nichthus: I don't know of any mathematical word specifically for modular division, but I'd imagine any modular arithmetic library would cover it
13:28:13 <luite> chrisdone: the cost centre location in that?
13:28:44 * dwcook wonders if there's a boundedMaximum xs = foldl max minBound xs
13:28:49 <benmachine> enthropy: note that if you just put [x| blah |] at the ghci toplevel, you get a message about the stage restriction
13:29:09 <hpaste> chrisdone pasted “src span info from ticks” at http://lpaste.net/92908
13:29:21 <chrisdone> luite: that's the useful bits from my code, if that helps
13:29:27 <chrisdotcode_> > maximum [1]
13:29:28 <lambdabot>   1
13:29:40 <enthropy> benmachine: yes that can be worked around though
13:29:48 <chrisdotcode_> :t fold1
13:29:49 <lambdabot>     Not in scope: `fold1'
13:29:50 <lambdabot>     Perhaps you meant one of these:
13:29:50 <lambdabot>       `foldl1' (imported from Data.List),
13:29:53 <chrisdotcode_> :t foldl
13:29:54 <lambdabot> (a -> b -> a) -> a -> [b] -> a
13:30:10 <elliott> dwcook: that's what maximum should be. and minBound/maxBound should be in their own class
13:30:14 * hackagebot HaRe 0.7.0.5 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.5 (AlanZimmerman)
13:30:14 <chrisdone> luite: oh yeah, that's the key ingredient i didn't mention. the breakpoint is just an id, but i use that id to lookup the breakpoints of the module, which themselves contain src spans
13:30:34 <dwcook> elliott, you could also easily formulate a safeMaximum :: [a] -> Maybe a
13:30:36 <elliott> dwcook: and there should be types that lift other types to have MinBound/MaxBound instances with -infinity and +infinity tacked on.
13:30:37 <luite> chrisdone: ah ok
13:30:39 <dwcook> Err, with Ord
13:30:46 <elliott> dwcook: that you can extract to Maybe, hence getting the safe version out naturally
13:31:14 <dwcook> Ah yes
13:31:37 <elliott> dwcook: maybe the Maybe version would be less fuss to start with, but this seems cleaner somehow :)
13:31:52 <elliott> it makes minimum/maximum fall in line with sum/product etc. as using the natural identity elements of their operation
13:31:52 <dwcook> elliott, yes, I have to say what you suggest would be an elegant formulation.
13:31:55 <luite> chrisdone: I think I'd have to use ProfNote annotations instead, but that should be reasonably doable with some DynFlags massaging
13:32:03 <sebastian> Hey all, is it possible to store strict pairs in an unboxed array?
13:32:03 <chrisdotcode_> hey guys, is this nice source for maximum wrong? foldl is missing it's default value.
13:32:04 <elliott> oh, and you can make a monoid out of it too, turning it into a foldMap!
13:32:06 <chrisdotcode_> :t maximum
13:32:06 <lambdabot> Ord a => [a] -> a
13:32:13 <chrisdotcode_> @src maximum
13:32:13 <lambdabot> maximum [] = undefined
13:32:13 <lambdabot> maximum xs = foldl1 max xs
13:32:35 <dwcook> I'm curious, though, why it uses a left fold
13:32:45 <chrisdotcode_> dwcook: isn't that code also wrong?
13:32:48 <chrisdone> luite: yeah i couldn't get profiling to work too easily, good luck
13:32:52 <dwcook> chrisdotcode_, which?
13:32:54 <chrisdotcode_> shouldn't maximum [one element] not work?
13:32:56 <luite> chrisdone: oh what was the problem?
13:33:00 <dwcook> chrisdotcode_, why wouldn't it?
13:33:03 <elliott> dwcook: sum uses a foldl (not foldl') too
13:33:08 <aranea> (re) I've build a Parsec parser for arithmetical terms. But I don't manage to ignore whitespace. Could so help me? http://lpaste.net/660097311883395072
13:33:17 <elliott> it's kinda arbitrary.
13:33:22 <chrisdotcode_> dwcook: because the maximum of an element and undefined is undefined?
13:33:24 <elliott> foldr is probably right for max, since there's no accumulation?
13:33:31 <elliott> or, no, you'd want foldl'
13:33:33 <elliott> for Int etc.
13:33:35 <ParahSai1in> :ty foldl1
13:33:39 <ParahSai1in> @ty foldl1
13:33:40 <lambdabot> (a -> a -> a) -> [a] -> a
13:33:42 <luite> chrisdone: it doesn't need to be fully profiled, just needs to be convinced to insert the ProfNotes :)
13:33:42 <benmachine> chrisdotcode_: it needn't be
13:33:43 <johnw> Taneb: hi
13:33:46 <Taneb> Hi
13:33:48 <dwcook> chrisdotcode_, that's not exactly a base case, it's a deficient case
13:33:52 <elliott> chrisdotcode_: the largest element of [x] is x
13:33:56 <benmachine> chrisdotcode_: e.g. the maximum of Just x and undefined could be Just undefined
13:33:56 <dwcook> chrisdotcode_, notice how maximum doesn't use itself
13:34:07 <nichthus> benmachine: I only see Modulo on Hackage, and the line "instance Bounded Integer" at the top isn't inspiring a lot of confidence... still reading, though...
13:34:12 <Taneb> johnw, I'm trying to do an ``` active haskell that starts hidden
13:34:16 <benmachine> nichthus: hah hah, what
13:34:19 <chrisdotcode_> oh. I'm still thinking in terms of maximum comparing two things in other languages
13:34:31 <Taneb> But it's not hiding anything and just has the -- show and -- /show displayed
13:34:42 <chrisdotcode_> but in any case, the way this code works, it calls `max' in the fold. and max takes two arguments. so how does that work?
13:34:44 <chrisdotcode_> @src max
13:34:45 <lambdabot> max x y = if x <= y then y else x
13:34:50 <dwcook> chrisdotcode_, most formulations of maximum in other languages also give, as the maximum of a single-element collection, that element.
13:35:09 <chrisdone> @tell Maerten for what it's worth, the thyme library is 6x faster than the standard time library in base, this makes it twice as fast as the php version: http://lpaste.net/92891
13:35:09 <lambdabot> Consider it noted.
13:35:12 <elliott> > foldl1 (fun "max") [a,b,c,d]
13:35:13 <lambdabot>   max (max (max a b) c) d
13:35:19 <elliott> chrisdotcode_: that happens
13:35:21 <chrisdone> i'm impressed. thyme is claimed to be fast, but it actually is
13:35:28 <joelteon> no way
13:35:40 <chrisdone> Liyang++
13:35:44 <elliott> thyme is that thing they use at tsuru or whatever, right?
13:35:45 <joelteon> so do you just s/Time/Thyme/?
13:35:45 <chrisdotcode_> elliott: right, but the one element case makes no sense, yet it works
13:35:53 <johnw> Taneb: ah, I remember there being a way to do that...
13:35:53 <elliott> chrisdotcode_: the one element case makes perfect sense
13:35:55 <elliott> @src foldl1
13:35:56 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:35:56 <lambdabot> foldl1 _ []     = undefined
13:35:57 <chrisdotcode_> so there's a difference between the code lambabot gives me and the implementation
13:36:02 <elliott> there isn't
13:36:07 <elliott> well, there probably is
13:36:09 <elliott> but not an observable one.
13:36:13 <dwcook> chrisdotcode_, trace through lambdabot's definition in your head with a single-element list.
13:36:13 <elliott> (except in terms of performance etc.)
13:36:15 <Taneb> johnw, do tell
13:36:16 <dwcook> Or on paper.
13:36:26 <chrisdone> joelteon: pretty much, had to implement Result for thyme's type, but that's needed
13:36:28 <ski> chrisdotcode_ : `maximum xs' should be the greatest element in `xs', if any. in case `xs' is `[x]', then surely `x' is greatest
13:36:32 <dwcook> You'll also need this
13:36:35 <johnw> Taneb: surround the whole block with @@@
13:36:38 <dwcook> @src foldl1
13:36:38 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:36:38 <lambdabot> foldl1 _ []     = undefined
13:36:38 <n-dolio> maxBound = setBit $ (unsafePerformIO memorySizeInBits)
13:36:41 <johnw> see https://www.fpcomplete.com/school/how-to-use-the-school-of-haskell/soh-markdown, under "Hide solution"
13:36:49 <chrisdone> bos: getting thyme support in mysql-simple might be cool, it's fast =)
13:36:52 <chrisdotcode_> dwcook: maximum [1] = foldl max [1] = max 1 _ = ??
13:37:04 <n-dolio> Whoops, left my parens in.
13:37:04 <elliott> chrisdotcode_: maximum [1] = foldl1 max [1]
13:37:05 <elliott> @src foldl1
13:37:06 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:37:06 <lambdabot> foldl1 _ []     = undefined
13:37:14 <elliott> foldl1 max [1] = foldl1 max (1:[]) = exercise for reader
13:37:30 <joelteon> ok
13:37:32 <chrisdotcode_> I know how it works conceptually, I'm just confused as to how lambadot's code works.
13:37:32 <joelteon> i'll try it, chrisdone
13:37:54 <benmachine> chrisdotcode_: foldl1 is different from foldl
13:38:11 <chrisdotcode_> elliott: so doesn't "foldl max (1:[])" become (max 1 []), which doesn't work?
13:38:16 <chrisdotcode_> @src foldl1
13:38:16 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:38:16 <lambdabot> foldl1 _ []     = undefined
13:38:17 <luite> chrisdone: hmm, i wonder if this is easy to do without changing the ghc api
13:38:32 <mbrock> chrisdotcode_: look closer! you get foldl max 1 []
13:38:33 <Taneb> johnw, either I've misunderstood you or that doesn't help
13:38:48 <chrisdotcode_> oh, I misssed "foldl1" not being "fold1"
13:38:53 <elliott> chrisdotcode_: foldl1 is not foldl
13:38:59 <elliott> yeah.
13:39:05 <dwcook> There's no fold1, you mean foldl
13:39:10 <Taneb> johnw, I'm tyring to do a few lines of hidden setup and behind the scenes stuff, then a shown bit
13:39:13 <dwcook> Which means "fold left"
13:39:20 <chrisdotcode_> yeah, I just have bad fonts :)
13:40:00 <chrisdotcode_> elliott: foldl max 1 [] = max 1 [] ?
13:40:09 <mbrock> foldl and foldl1 are maybe not the best names in the Prelude...
13:40:10 <nichthus> foldl is not "fold left"
13:40:19 <nichthus> foldl is "fold a left-associative function"
13:40:35 <johnw> Taneb: can you show me an example of what you're trying to do?
13:40:45 <johnw> I don't quite follow
13:40:50 <monochrom> edwardk: very clever method to ensure rnf is done at most once!
13:41:10 <nichthus> chrisdotcode_: Nope. Stare at the definition of foldl again. =)
13:41:25 <chrisdotcode_> @src foldl
13:41:26 <lambdabot> foldl f z []     = z
13:41:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:41:31 <elliott> foldl f z [] = z
13:41:34 <elliott> ergo foldl max 1 [] = 1
13:41:35 <monochrom> at first I wondered "but what's the () doing there in Once () a". then I looked again at "rnf :: a -> ()" haha
13:41:43 <chrisdotcode_> got it!
13:41:47 <chrisdotcode_> okay, thanks guys :)
13:42:01 <chrisdotcode_> my confusion was the similarities between "foldl" and "foldl1"
13:42:03 <Taneb> johnw, like the example in https://www.fpcomplete.com/school/pick-of-the-week/part-2 under "Folding via Comonad Transformers"
13:42:16 <Taneb> (after "Give it a shot!")
13:43:18 <johnw> he's using "-- show" marker
13:43:19 <johnw> s
13:43:40 <johnw> like so: https://gist.github.com/6543490
13:44:27 <tippenein> is there a way to cabal install something and have it saved in the project.cabal deps ?
13:44:43 <johnw> tippenein: no
13:45:05 <dcoutts> tippenein: what do you mean exactly?
13:45:16 <aranea> aww, solved
13:45:38 <tippenein> cabal install aeson -S would add aeson to project.cabal
13:45:42 <Taneb> johnw, doing that, I'm not quite sure where I'm going wrong
13:45:43 <tippenein> or something like that
13:45:59 <dcoutts> tippenein: oh I see, for something not already mentioned there
13:46:02 <nichthus> tippenein: "cabal init" will take a (pretty darn good!) guess at dependencies
13:46:10 <benmachine> nichthus: in fairness, there is no such thing as a "left-associative function"
13:46:20 <edwardk> monochrom: thanks =)
13:46:20 <edwardk> Taneb: surround the code you want to show with -- show    and -- /show
13:46:23 <tippenein> nichthus: I found that "solution" except that it goes through all the options
13:46:26 <bergmark> yeah i wish you could do the cabal init magic to just add dependencies!
13:46:26 <luite> chrisdone: ok one of the hooks that nominolo or edsko requested is exactly at the right place to just run the desugarer with different settings to get it to insert the ticks
13:46:27 <dcoutts> tippenein: no, sorry. cabal init does it first time but we don't have any equiv for adding more later
13:46:31 <nichthus> tippenein: But back up the old cabal file before you run that.
13:46:33 <nichthus> tippenein: yeah
13:46:57 <dcoutts> part of the problem is we don't have a good way to rewrite .cabal files without messing up the formatting
13:47:01 <nichthus> benmachine: er, why not?
13:47:04 <Taneb> I've got http://hastebin.com/rudogotoli.txt, johnw
13:48:56 <benmachine> nichthus: well, what does that even mean? that x * (y * z) = (x * y) * z but not the other way around?
13:49:20 <nichthus> benmachine: It means when we write "x * y * z" this means "(x * y) * z".
13:49:35 <johnw> Taneb: hmmm
13:49:37 <dwcook> I took it more as a statement about the type
13:49:40 <dwcook> @src foldr
13:49:40 <lambdabot> foldr f z []     = z
13:49:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:49:42 <benmachine> nichthus: hmm. I object that that is notational convention and not a property of the function
13:49:43 <dwcook> Woop
13:49:47 <dwcook> @type foldr
13:49:48 <johnw> edwardk: do you know what he might be doing wrong?
13:49:48 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:49:49 <dwcook> @type foldl
13:49:50 <lambdabot> (a -> b -> a) -> a -> [b] -> a
13:49:55 <nichthus> benmachine: admitted
13:50:14 * hackagebot multiarg 0.24.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.24.0.0 (OmariNorman)
13:50:22 <dwcook> There is of course the intersection where a ~ b where this notion gets confusing
13:50:24 <nichthus> benmachine: I reword my complaint: foldl is not "fold left"; foldl is "fold a function, associating to the left"
13:50:37 <dwcook> nichthus, yes, I think that's a better way to phrase it.
13:51:14 <dwcook> I was more trying to give a mnemonic than fully explain what it does, which may have been erroneous.
13:51:15 <benmachine> nichthus: fair enough
13:51:24 <benmachine> nichthus: this is acceptable to me
13:51:29 <chrisdotcode_> @src tail
13:51:30 <lambdabot> tail (_:xs) = xs
13:51:30 <lambdabot> tail []     = undefined
13:51:34 <joelteon> can you not ignore hlint parse errors using annotations?
13:51:36 <benmachine> nichthus: well, also, so is the other thing, but this is even more acceptable
13:51:55 <nichthus> pedantic level 9, please
13:51:57 <nichthus> BRING IT ON
13:52:00 <benmachine> joelteon: if hlint encounters a parse error it doesn't know what to do
13:52:18 <benmachine> joelteon: it's not so much that it refuses to check your code, it's just not clever enough to do so
13:52:42 <joelteon> ok
13:52:48 <joelteon> I wish it knew how to parse recursive do
13:52:50 <joelteon> :(
13:52:55 <joelteon> I should open a ticket
13:54:08 <aristid> copumpkin: subtext 5 looks quite underwhelming
13:54:30 <copumpkin> aristid: oh, I was talking more about the discussion below
13:54:34 <copumpkin> than the actual post
13:54:41 <aristid> copumpkin: yeah i know.
13:55:14 * hackagebot matchers 0.12.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.12.0.0 (OmariNorman)
13:56:09 <chrisdotcode_> haskell's compiler catches so much for me, it should play shortstop...
13:57:45 <simon> @pl \x xs -> f (x:xs)
13:57:45 <lambdabot> (f .) . (:)
13:59:18 <copumpkin> aristid: but yeah, I haven't looked at it yet :)
13:59:32 <aristid> copumpkin: ah then i shouldn'
13:59:38 <aristid> copumpkin: ah then i shouldn't spoiler it for you:)
14:00:14 * hackagebot penny 0.30.0.0 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.30.0.0 (OmariNorman)
14:00:15 <joe9> any tasty users here? do you prefer it over hunit?
14:03:04 <Sonarpulse> I used the template haskell package to derive an Unboxed instances for my type, and then I used Vector's generic replicate with my type
14:03:16 <Sonarpulse> but GHC complains their is no Data.Primitive.Types.Prim instance for my type
14:03:27 <Sonarpulse> I have no problem defining the Unbox instance
14:03:40 <Sonarpulse> and replicate doesn't mention a Prim class
14:05:14 * hackagebot rewrite 0.6 - open file and rewrite it with new contents  http://hackage.haskell.org/package/rewrite-0.6 (OmariNorman)
14:08:39 <madjestic> I can't reach hayoo for a while.  Is there a known issue?
14:09:34 <byorgey> madjestic: looks down for me too.
14:10:19 <byorgey> madjestic: note that unlike e.g. Hoogle and Hackage, hayoo is not hosted on an official haskell.org server
14:11:28 <Siod> i'm trying to install ghc 7.6 (on ubuntu 12.10) using the binary package, but ./configure reports "permission denied" for ghc-pwd. any ideas?
14:12:47 <madjestic> byorgey: I find hayoo generally more responsive than hoogle.  I think it deserves a better attention.
14:13:10 <Ralith> Siod: install the haskell platform instead
14:13:37 <Siod> Ralith: unless there's another way, i have to install the latest ghc to install the latest haskell-platform
14:14:07 <Ralith> Siod: haskell-platform includes ghc; install all of it by running 'sudo apt-get install haskell-platform'
14:14:18 <Ralith> on linux, downloading and manually installing stuff is usually wrong.
14:14:19 <Siod> Ralith: that isn't the latest haskell platform
14:14:45 <Ralith> so?
14:15:13 <Siod> it's version 2012.1 and the latest version is 2013.2
14:16:07 <erisco> what is a compelling case for having guards?
14:17:45 <Siod> (on fedora this would be easy)
14:21:45 <carter> question:
14:21:50 <carter> for any type class of the form
14:21:52 <carter> instance ReverseTupleC tup => ReverseTupleC (a:* tup)
14:22:01 <carter> do I always need to have undecidable instances?
14:22:04 <carter> i'd rather not....
14:22:10 <bos> uh oh: http://lpaste.net/92910
14:22:30 <luite> bos: yeah that's been reported alread
14:22:31 <luite> y
14:25:04 <bos> luite: do you happen to have a bug link?
14:25:49 <luite> bos: uh lemme check, killy9999 reported it earlier today
14:25:59 <jfischoff> carter: what is this syntax? a:* tup
14:26:11 <carter> i have a tuple tye!
14:26:12 <carter> type
14:26:28 <carter> data Z  = Z
14:26:29 <carter> and
14:26:31 <luite> bos: http://ghc.haskell.org/trac/ghc/ticket/8276
14:26:37 <carter> infixr 3 :*
14:26:37 <carter> data head :* tail
14:26:37 <carter>     = !head :* !tail
14:26:52 <jfischoff> oh got it
14:27:10 <bos> luite: thanks
14:27:46 <jfischoff> are there any fundeps involved with that class?
14:28:07 <carter> i was trying to do type families instead...
14:28:14 <carter> but maybe fundeps are the way to go
14:28:34 <carter> i was trying to be too clever
14:28:40 <elliott> you can just use a type family and no class
14:28:45 <elliott> no?
14:29:38 <carter> elliott nope
14:29:44 <carter> because its an HList
14:30:08 <carter> i need type based dispatch for Z vs ( a :* b) cases
14:31:17 <hpaste> carter pasted “blah” at http://lpaste.net/92912
14:31:31 <carter> that lacks all the language pragma voodoo mind you
14:31:50 <jfischoff> ah you type equality constraints
14:32:01 <carter> yeah
14:32:10 <carter> i'm trying to do quality constraints intead of fundeps
14:32:30 <carter> oh
14:32:34 <carter> partial constraint is wrong
14:33:01 <carter> hrmm
14:34:08 <carter> if releax the constraint its fine
14:34:13 <carter> but i still need undecidable instances
14:34:27 <hpaste> carter revised “blah”: “fixed” at http://lpaste.net/92912
14:35:46 <carter> any thoughts?
14:36:13 <jfischoff> I have two thoughts. What's wrong with fundeps, what's wrong with undecideable instances
14:36:24 <carter> yak shaving  / experimentation
14:36:32 <jfischoff> fair enough
14:36:42 <carter> also in this case, fundeps won't be strictly more exprssive i think
14:36:51 <padrian> Hello Haskellers
14:37:05 <carter> mostly i'm not understanding why i need undecidable instancere here
14:37:50 <jfischoff> Here is my bet
14:37:58 <carter> go on
14:38:31 <jfischoff> the constraints on reverseTuple' perhaps can be lifted to constraints on the class ReverseTupleC
14:39:05 <jfischoff> then you end up with types in the constraint of the instance not mentioned instance head
14:39:13 <jfischoff> that's a guess ;p
14:39:15 <carter> ok
14:39:17 <carter> i'll try
14:40:42 <carter> so like
14:40:43 <carter> class (Tuple input, Tuple partial , Tuple res ) ReverseTupleC  input partial res | input, partial -> res where
14:40:43 <carter>     reverseTuple' :: input -> partial -> res
14:40:44 <carter> ?
14:40:59 <jfischoff> I'm not really proposing a solution
14:41:06 <carter> ok
14:41:17 <jfischoff> I'm just trying to understand the behavior
14:41:58 <carter> lemme look at how HLIST does it again
14:42:04 <jfischoff> I don't think a vanilla class would complain about the instance, but maybe I misinformed or confused
14:42:33 <enthropy> carter: don't put commas in the fundep
14:42:43 <carter> yeah
14:45:13 <carter> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-HListPrelude.html#hReverse%27 is the classic solution
14:45:38 <carter> g2g
14:45:42 <carter> i'll pester yalll later
14:46:02 <padrian> how come the expression ((>1) . length ) is possible
14:46:07 <haasn> edwardk: I hereby coin the adjective ‘myopic’ to describe a problem that could be greatly improved by using lenses ;)
14:46:17 <edwardk> haj
14:46:21 <edwardk> hah
14:47:00 <padrian> ?
14:47:16 <haasn> padrian: well, why wouldn't it be?
14:47:19 <jfischoff> @type (>1)
14:47:20 <lambdabot> (Num a, Ord a) => a -> Bool
14:47:32 <jfischoff> @type length
14:47:32 <lambdabot> [a] -> Int
14:47:33 <edwardk> yeah, well the opposition will just choose to call their thinking far-sighted
14:47:35 <padrian> @type length
14:47:35 <haasn> ((>1) . length) = \x -> (>1) (length x) = \x -> length x > 1
14:47:36 <lambdabot> [a] -> Int
14:48:27 <S_J> > map (<8) [1,2,3]
14:48:28 <lambdabot>   [True,True,True]
14:48:40 <padrian> haasn: de-sugared version makes sense
14:48:48 <S_J> @type all
14:48:49 <lambdabot> (a -> Bool) -> [a] -> Bool
14:48:52 <S_J> @src all
14:48:53 <lambdabot> all p =  and . map p
14:49:37 <padrian> haasn: from what I know f . g, the return type of f should mach the input type of g
14:51:48 <haasn> padrian: other way round
14:52:03 <haasn> padrian: (f . g) x = f (g x) -- so ‘f’ accepts what ‘g’ returns
14:52:13 <haasn> hence, the parameter of ‘f’ must have the same type as the output of ‘g’
14:52:15 <haasn> :t (.)
14:52:16 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:52:21 <haasn> ‘b’ in this case
14:52:42 <haasn> jfischoff quoted the types involved in your example, earlier
14:53:11 <mteverest> how can i make an infinite list consisting of the same value repeated over and over?
14:53:17 <haasn> :t repeat
14:53:17 <lambdabot> a -> [a]
14:53:41 <haasn> > repeat "mteverest"
14:53:42 <jfischoff> @src repeat
14:53:42 <lambdabot> repeat x = xs where xs = x : xs
14:53:42 <lambdabot>   ["mteverest","mteverest","mteverest","mteverest","mteverest","mteverest","m...
14:53:52 <Hafydd> @pf \x -> (f x, g x)
14:53:53 <lambdabot> Maybe you meant: pl bf
14:53:58 <Hafydd> @pl \x -> (f x, g x)
14:53:58 <lambdabot> liftM2 (,) f g
14:54:01 <haasn> Hafydd: f &&& g
14:54:06 <padrian> haasn: thanks!
14:54:33 <Hafydd> @hoogle &&&
14:54:33 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
14:54:54 <Hafydd> Ty.
14:56:11 <mteverest> > repeat "20"
14:56:12 <lambdabot>   ["20","20","20","20","20","20","20","20","20","20","20","20","20","20","20"...
14:56:43 <joelteon> > repeat "shut up marie"
14:56:44 <lambdabot>   ["shut up marie","shut up marie","shut up marie","shut up marie","shut up m...
14:57:00 <mteverest> ok, how do i fold over the list so that my statement evaluates the same as sqrt(20+(sqrt(20+(sqrt(20+...)
14:57:11 <dacc> > repeat "all work and no play makes jack a dull boy"
14:57:12 <lambdabot>   ["all work and no play makes jack a dull boy","all work and no play makes j...
14:57:26 <joelteon> > foldr1 (sqrt . (20+)) [a,b,c,d]
14:57:27 <lambdabot>   Couldn't match type `Debug.SimpleReflect.Expr.Expr'
14:57:27 <lambdabot>                with `De...
14:57:30 <joelteon> damn
14:58:21 <haasn> > foldr1 (sqrt `on` (+)) $ replicate 3 20
14:58:22 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
14:58:23 <lambdabot>  Expected t...
14:58:41 <joelteon> > scanl (sqrt . (20+)) [1..10]
14:58:42 <lambdabot>   Couldn't match type `[t0]' with `b0 -> [t0]'
14:58:42 <lambdabot>  Expected type: [t0] -> b0 -> ...
14:58:43 <haasn> oh
14:58:46 <joelteon> > scanl1 (sqrt . (20+)) [1..10]
14:58:47 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
14:58:48 <lambdabot>  Expected t...
14:58:50 <joelteon> ugh
14:58:59 <haasn> > let (.:) = (.).(.) in foldr1 (sqrt .: (+)) $ replicate 2 20
14:59:00 <lambdabot>   6.324555320336759
14:59:06 <haasn> > let (.:) = (.).(.) in foldr1 (sqrt .: (+)) $ replicate 2 20 :: Expr
14:59:07 <lambdabot>   sqrt (20 + 20)
14:59:13 <haasn> > let (.:) = (.).(.) in foldr1 (sqrt .: (+)) $ repeat 20 :: Expr
14:59:14 <lambdabot>   sqrt (20 + sqrt (20 + sqrt (20 + sqrt (20 + sqrt (20 + sqrt (20 + sqrt (20 ...
14:59:17 <haasn> mteverest: ^
14:59:21 <joelteon> so scan is just fold + all the intermediate values
15:01:39 <mteverest> awesome
15:01:53 <mteverest> this is such a cool language but i just can't make my brain think the way it needs to
15:01:57 <mteverest> it seems like
15:03:34 <jfischoff> think less :)
15:04:23 <acowley> mteverest: You'll get there!
15:07:26 <haasn> oh, apologies for the (.:)
15:07:41 <dwcook> @type (.) . (.)
15:07:42 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:07:45 <haasn> (sqrt .: (+)) is just (\x y -> sqrt (x + y))
15:08:56 <mteverest> that single line of code just made my computer freeze really bad =)
15:10:07 <mteverest> looks like i have to kill ghci before icewm will even refresh
15:10:24 <ion> ಠ_ಠ
15:10:47 <w0rm_x> ಠ_ಠ
15:11:16 <mteverest> does anyone see how to get the result of that using a quadratic equation, btw?
15:12:57 <haskellnoob> I'm trying to implement simple manipulation over a list to create tuples with overflow http://pastebin.com/BBmdW8Jv , starting with tuples of 2, some hint to put me in the right direction would be appreciated
15:13:01 <mauke> The paste BBmdW8Jv has been copied to http://lpaste.net/92915
15:16:24 <haasn> mteverest: probably because it doesn't terminate :)
15:17:05 <danilo2> Hi! Is there an easy way to instance Show of custom data Type in such way that it will result not only the String representation of data constructor name, but also data type name? I mean - for "data X = Y Int; show(Y 5)" it should return "X.Y 5"
15:17:10 <applicative> haskellnoob: the [1..4] on the left hand side is not a genuine 'pattern' so it's not legitimate.  [1,2,3,4] is a genuine pattern
15:17:33 <haasn> haskellnoob: are lines 3-4 supposed to be examples, or are those meant to be part of the function definition?
15:17:36 <merijn> danilo2: You can write whatever show instance you like
15:17:50 <merijn> danilo2: However, you probably shouldn't do that
15:17:50 <haasn> and I remember we had this exact same question a few days ago
15:17:51 <haskellnoob> applicative/haasn: sorry yes it's meant as examples
15:18:00 <merijn> danilo2: Why not define a pretty print for that?
15:18:26 <haasn> > let xs = [1..4] in zip xs (tail (cycle xs)) -- haskellnoob one way
15:18:28 <lambdabot>   [(1,2),(2,3),(3,4),(4,1)]
15:18:42 <danilo2> merijn: I know, but If I've got a lot of data ocnstructors it is not easy task. What do you mean by defining pretty print?
15:18:55 <merijn> danilo2: Just defining a function to do it
15:19:03 <merijn> danilo2: Rather than a show instance
15:19:10 <applicative> haskellnoob: yes i see now, i panicked ....
15:19:44 <applicative> oh haasn's way is good. i was thinking of someting like that
15:20:01 <applicative> as a starting point,
15:20:19 <haskellnoob> haasn : great, cycle is exactly what I was looking for :)
15:20:24 <applicative> > let xs = [1..4] in zip xs (tail xs)
15:20:25 <lambdabot>   [(1,2),(2,3),(3,4)]
15:20:36 <applicative> but cycle gives you the extra material
15:20:39 <danilo2> merijn: again there is a problem. Imagine I've got datatype, which got lets say 30 constructors (an AST Expression data type) - if I will define such function I need manualy check what data constructor am I [printing and handle it underlying structure - It will e a lot of code, which can really fast get obsolete if the structure changes
15:20:40 <haasn> :t zip <*> tail . cycle
15:20:41 <lambdabot> [b] -> [(b, b)]
15:20:44 <haasn> :)
15:20:52 * applicative saw that coming
15:21:04 <haasn> I wouldn't have expected any less from a guy named ‘applicative’
15:21:10 <applicative> > zip `ap` (tail.cycle) $ "California"
15:21:11 <lambdabot>   [('C','a'),('a','l'),('l','i'),('i','f'),('f','o'),('o','r'),('r','n'),('n'...
15:21:21 <applicative> > zip `ap` (tail.cycle) $ [1..4]
15:21:22 <lambdabot>   [(1,2),(2,3),(3,4),(4,1)]
15:21:29 <haasn> those parens are unnecessary! . has the highest stickiness! shachaf taught me this
15:21:33 <haasn> > zip `ap` tail.cycle $ [1..4]
15:21:34 <lambdabot>   Precedence parsing error
15:21:34 <lambdabot>      cannot mix `Control.Monad.ap' [infixl 9] and ...
15:21:37 <haasn> w-what
15:21:39 <haasn> oh not
15:21:41 <merijn> danilo2: Define a TH function to generate the function for you?
15:21:41 <haasn> or*
15:21:53 <merijn> danilo2: Or use Generic
15:22:02 <applicative> bah, the haskell stickiness masters are not to be trusted!
15:22:43 <danilo2> merijn: ahh the generics... I have heard about them before (maybe even from you) - but I didnt ever dig into them - maybe its time to do it :)
15:23:12 <danilo2> merijn: I dont like the idea of doing it in TH, but if I have to I'll do it :(
15:23:13 <shachaf> haasn: Yes, things have the highest stickiness by default too.
15:23:17 <shachaf> Except infixl.
15:23:17 <merijn> danilo2: I'm not sure this can be done with generics, but now would be the time to find out ;)
15:23:30 <w0rm_x> > zip `ap` (tail.cycle) $ ""
15:23:31 <lambdabot>   []
15:23:34 <merijn> danilo2: At least you'll learn something! ;)
15:24:00 <haasn> > zip <*> tail.cycle $ [1]
15:24:01 <lambdabot>   [(1,1)]
15:24:29 <danilo2> merijn: I love learning new things, especiaqlly when it comes down to haskell, but now I'm looking for the fastest solution, because I will probably not sleep for few nights because of deadline :D
15:24:54 <applicative> > zip [] undefined
15:24:55 <lambdabot>   []
15:25:53 <haasn> > let show' a = show (typeOf a) ++ "." ++ show a in show' (Just 3)
15:25:54 <lambdabot>   "Maybe Integer.Just 3"
15:26:02 <haasn> danilo2: ^ crude but something like this?
15:26:45 <haasn> preferably with something nice like showsPrec to insert parens or something if needed, I don't really know this stuff very well
15:28:56 <danilo2> haasn: No :( It prints only the "top result" qualified. For example for this code: data X = X Int deriving(Show, Typeable); show' (X 5) it results in "X.X 5" and not "X.X Integer.5" :(
15:30:15 <haasn> ah!
15:30:23 <haasn> Data.Data.Data.. hmm
15:30:50 <haasn> I don't know how to do it for monomorphic types! sorry
15:31:14 <haskellnoob> > let (x:xs) = [1..5] in  zip (x:xs) (cycle (tail (x:xs)++[x]))
15:31:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
15:33:54 <joelteon> tail (x:xs)?
15:34:26 <dwcook> tail (x:xs) = xs
15:34:29 <haskellnoob> joelteon: right, I'll work on expression reduction now :)
15:34:58 <joelteon> haskellnoob: tail (cycle (x:xs))
15:35:26 <haskellnoob> joelton: then on defining overflow3
15:35:32 <joelteon> ok
15:35:48 <applicative> haskellnoob: but for this idea, i think you don't need cycle? you're moving the head to the tail, so to speak
15:35:59 <applicative> then zipping
15:36:01 <joelteon> but cycle *will* do that
15:36:22 <Itkovian> Anybody here by any chance who also uses python and happens to know a viable alternative for list-tries? (http://hackage.haskell.org/packages/archive/list-tries/0.5.1/doc/html/Data-ListTrie-Patricia-Map.html)
15:36:23 <applicative> joelteon: yeah that was haasn s original point
15:36:32 <joelteon> oh
15:36:58 <applicative> but this is the more direct expression i think, the one haskellnoob is working on
15:37:36 <applicative> > let xs = [1..4] in zip xs (tail xs ++ head xs)  -- I should be punished for this
15:37:37 <lambdabot>   No instance for (GHC.Show.Show b0)
15:37:37 <lambdabot>    arising from a use of `M1009478821.sh...
15:37:47 <applicative> woops
15:37:56 <haskellnoob> > let (x:xs) = [1..5] in  zip (x:xs) (xs++[x])
15:37:57 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
15:38:00 <applicative> > let xs = [1..4] in zip xs (tail xs ++ [head xs])  -- I should be punished for this
15:38:01 <lambdabot>   [(1,2),(2,3),(3,4),(4,1)]
15:38:06 <haasn> > let xs@(h:t) = [1..5] in zip xs (t ++ [h])
15:38:07 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
15:38:34 <applicative> right haskellnoob so the general definition needs also to take care of the trivial [] case on a separate line
15:39:15 <applicative> > let haskellnoob [] = []; haskellnoob (x:xs) = zip (x:xs) (xs++[x]) in haskellnoob [1..4]
15:39:16 <lambdabot>   [(1,2),(2,3),(3,4),(4,1)]
15:39:40 <applicative> the cycle idea dispenses with the distasteful append
15:40:09 <haskellnoob> applicative: right, ends up with a very simple solution :)
15:40:47 <applicative> it shouldn't be any worse from the point of view of efficiency; maybe better depending on compiler cleverness
15:41:04 <cariveri> Hi! is there a powerof,** :: Int -> Int -> Int ?
15:41:17 <applicative> in general one tries to avoid ... ++ [x] if it's coming up too much
15:41:18 <benmachine> cariveri: you may want ^^
15:41:34 <benmachine> applicative: sure but in this case ++ [x] is doing exactly the amount of work that cycle would
15:41:58 <benmachine> applicative: think of cycle xs as xs ++ cycle xs, then basically you're just using the fact that [x] is a prefix of cycle xs
15:42:02 <applicative> benmachine: i was thinking so too, but other cases like this can be better than the hand-crafted nonsense
15:42:28 <benmachine> applicative: all I'm saying is, one append is not the end of the world :P
15:42:31 <applicative> benmachine: i'm making a general point, not to be afraid of something like cycle --- except of course when you should be
15:42:35 <applicative> benmachine: yes  i said that
15:42:40 <benmachine> fair enough
15:42:43 * benmachine onlyhalf paying attention
15:43:32 <benmachine> I think the trouble is that xs ++ [y] is so often the wrong thing that some people shudder at the very sight of it
15:43:40 <benmachine> but it is occasionally actually what you want
15:43:53 <applicative> yes, i have both these reactions
15:44:35 <applicative> secretly i have an aesthetic reaction to x:ys++[z]
15:45:45 <monochrom> xs++[y] is ok as long as you don't use a loop to make it (((xs0++[y0])++[y1])++[y2])++...
15:46:05 <cariveri> benmachine: Ok, I jsut did it myself.
15:46:25 <benmachine> cariveri: sorry, I realise my comment was a bit ambiguous
15:46:29 <benmachine> cariveri: I meant
15:46:34 <benmachine> :t (^^)
15:46:35 <lambdabot> (Fractional a, Integral b) => a -> b -> a
15:46:40 <benmachine> > 2 ^^ 7
15:46:41 <lambdabot>   128.0
15:46:53 <benmachine> oh, actually, you probably don't want that
15:46:58 <benmachine> you rpobably want ^
15:47:02 <benmachine> :t (^)
15:47:02 <lambdabot> (Integral b, Num a) => a -> b -> a
15:47:06 <benmachine> > 2 ^ 7
15:47:07 <lambdabot>   128
15:47:34 <benmachine> cariveri: there are three different exponentiation operators in Haskell
15:47:55 <benmachine> cariveri: this corresponds to how there are really three different exponentiation operators in mathematics, but sometimes people try to cover this up :P
15:48:43 <applicative> > Seq.empty
15:48:44 <lambdabot>   fromList []
15:48:54 <haasn> @src subsequences
15:48:54 <lambdabot> Source not found.
15:49:07 <applicative> > let xs = Seq.fromList [1..4] in 0 <| (xs |> 5)
15:49:08 <lambdabot>   fromList [0,1,2,3,4,5]
15:49:28 <applicative> dont the precedences of |> and <| seem wrong?  or maybe there's no solution
15:50:03 <mstksg> if i have three and want to concat and map both of them into one big list, is ++ the wrong thing to do? map f (xs ++ ys) ?
15:50:51 <monochrom> map f (xs ++ ys) looks alright
15:50:51 <benmachine> cariveri: ^ does repeated multiplication, ^^ may also do division, ** does irrational things
15:51:07 <applicative> if you are appending you are appending mstksg
15:51:31 <monochrom> looks alright out of context, anyway
15:51:36 <monochrom> the devil is in the context
15:51:50 <shachaf> the devil is in the pretext
15:51:57 <danilo2> I remember some time ago somebody posted al ink to a Haskell Generics Show implementation, but I have lost this link :( Does anybody knows where can I find it?
15:52:02 <applicative> monochrom presumably thinks the devil is everywhere
15:52:09 <benmachine> applicative: Seq.empty |> 5 |> 7
15:52:09 <monochrom> even xs++[y] is alright in "const True (xs++[y])"
15:52:20 * applicative misread 'Haskell Generics Show'
15:52:47 <monochrom> it is futile to ask about a subexpression taken out of context. it really is.
15:53:04 <applicative> > Seq.empty |> 5 >< Seq.empty |> 7
15:53:05 <benmachine> monochrom: also: to seek meaning in life
15:53:06 <lambdabot>   Couldn't match expected type `Test.QuickCheck.Gen.Gen a0
15:53:06 <lambdabot>                   ...
15:53:09 <danilo2> i mean show implementation based on Haskell generics mechanism
15:53:22 <danilo2> ohh I've got it: https://github.com/dreixel/generic-deriving/blob/master/src/Generics/Deriving/Show.hs
15:53:28 <applicative> oh another >< is in scope
15:53:38 <benmachine> applicative: use <> instead :)
15:53:56 <benmachine> > [1 .. 3] <> [9 .. 12]
15:53:57 <lambdabot>   [1,2,3,9,10,11,12]
15:53:59 <applicative> benmachine: ah
15:54:00 <benmachine> oh good, it does work
15:54:15 <benmachine> applicative: you have to use the typeclass instances for folding, might as well use them for appending as well
15:54:40 <applicative> wait is this in favor of <>?
15:55:42 <applicative> i am now officially accustomed to <> for Text, ByteString and Builder, but it seems not to have taken for List yet
15:57:08 * applicative demands a new mempty, o = mempty
15:59:27 <ski> applicative : not `o = mappend', then ?
16:00:01 <ocharles> applicative: surely you just want 0 and ·
16:00:13 <ocharles> erm
16:00:23 <ocharles> 1 and ·, 0 and +
16:00:36 <ocharles> have I lost the plot? It just turned midnight so I'm allowed to play that card now
16:04:49 <applicative> ski ocharles yeah i guess i don't know what i want.  i = mempty; o = mappend.  only I never learned the backtick keys so xs `o` ys is out
16:06:36 <applicative> Monoid should be a multiparameter class, View -> * -> Constraint, where data View = Additive | Multiplicative
16:06:43 <applicative> then we'd have real chaos
16:07:07 <applicative> instance Num n => Monoid Additive n where mempty = 0; mappend = (+)
16:08:14 <ski> @kind Sum
16:08:15 <lambdabot> * -> *
16:08:53 <ski> > (getSum . foldr (mappend . Sum) mempty) [2,3,5,7]
16:08:54 <lambdabot>   17
16:08:58 <applicative> it 'should' be the same with Applicative :: Order -> (* -> *) -> Constraint; data Order = Parallel | Sequential;  etc
16:09:25 <enthropy> is ghc-7.7 supposed to have less kind inference?
16:09:37 <applicative> it's always been rather unkind
16:09:44 <arkeet> lol
16:10:10 <enthropy> for example I have   class C a where { type T a; f :: HList (T a) }
16:10:17 <enthropy> where HList :: [*] -> *
16:10:26 <enthropy> ghc-7.6 accepts that
16:10:50 <applicative> i have a month-old ghc 7.7 do you have a little module?
16:11:27 <enthropy> it's not a small module
16:11:27 <A3F> does anyone have experience with injecting haskell code into other processes?
16:11:48 <enthropy> it's bits of the rather large HList library
16:11:54 <applicative> ah i see
16:12:16 <applicative> enthropy: well, there's no pleasure greater than building ghc from source ;)
16:12:35 <applicative> as monochrom says it gives you occasion to watch e.g. The King and I and Ben Hur
16:13:13 <applicative> there's presumably popcorn somewhere in the repo
16:13:24 <enthropy> well the 7.7 I have is a binary Igloo apparently made
16:13:38 <applicative> oh, nnice
16:13:58 <enthropy> from in here http://darcs.haskell.org/ghcBuilder/uploads/igloo-m/
16:15:13 <haasn> ski: yuck!
16:15:25 <haasn> > ala Sum concatMap [2,3,5,7]
16:15:26 <lambdabot>   Couldn't match type `[b0]' with `Data.Monoid.Sum s0'
16:15:26 <lambdabot>  Expected type: (s0 ->...
16:15:50 <haasn> > ala Sum foldMap [2,3,5,7]
16:15:51 <lambdabot>   17
16:16:04 <applicative> foldMap is the only known argument to ala
16:16:09 <haasn> applicative: :)
16:16:16 <arkeet> :t ala
16:16:21 <arkeet> :t Control.Lens.ala
16:16:21 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
16:16:35 <applicative> there used to be another in Control.Newtype
16:16:50 <applicative> @type under
16:16:51 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
16:16:52 <haasn> Only foldMap examples in Control.Lens.Wrapped ;-;
16:17:00 <haasn> we need edwardk to find another and add it
16:17:02 <haasn> just to break the pattern
16:17:23 <applicative> haasn: i'm not sure, it predates lens and no on could think of another
16:17:26 <haasn> applicative: (foldMapOf l) also
16:17:31 <haasn> not sure if that counts :)
16:17:54 <applicative> whats the Sum iso, _Sum ?
16:18:06 <haasn> :t _Sum
16:18:07 <lambdabot> Not in scope: `_Sum'
16:18:10 <haasn> :t wrapping Sum
16:18:11 <lambdabot> (Functor f, Profunctor p) => p (Sum s) (f (Sum s)) -> p s (f s)
16:18:14 <applicative> @type under _Sum
16:18:14 <lambdabot> Not in scope: `_Sum'
16:18:18 <arkeet> :t wrapping Sum
16:18:18 <lambdabot> (Functor f, Profunctor p) => p (Sum s) (f (Sum s)) -> p s (f s)
16:18:20 <hpaste> dmj pasted “Tic Tac Toe winner” at http://lpaste.net/7268504585315024896
16:18:24 <applicative> oh
16:18:31 <haasn> > 50^.adding 5
16:18:33 <lambdabot>   Not in scope: `adding'
16:18:35 <haasn> :(
16:18:38 <applicative> @type under (wrapping Sum)
16:18:39 <lambdabot> (t -> t) -> Sum t -> Sum t
16:18:44 <haasn> so lambdabot doesn't have those yet
16:18:54 <mstksg> has anyone here had any luck deploying large-ish projects to heroku?
16:19:02 <mstksg> all of my builds seem to be force-quitting after 15 minutes exactly
16:19:08 <arkeet> > 50 ^. iso (+5) (subtract 5)
16:19:09 <lambdabot>   55
16:19:10 <mstksg> (by large i mean with many dependences)
16:19:15 <applicative> @type under (wrapping Sum) (*17) (Sum 1)
16:19:16 <lambdabot> Num t => Sum t
16:19:21 <haasn> > ala Sum (foldMapOf each) (1,2,3,4,5) -- applicative
16:19:22 <applicative> > under (wrapping Sum) (*17) (Sum 1)
16:19:23 <lambdabot>   15
16:19:24 <lambdabot>   Sum {getSum = 17}
16:20:11 <haasn> > Sum 1 & unwrapping Sum *~ 17
16:20:12 <lambdabot>   Sum {getSum = 17}
16:20:22 <applicative> oh, well that certainly exceeds anything we could think of with Control.Newtype
16:20:35 <haasn> that line is strangely beautiful
16:20:56 <applicative> they all are when the conditions are exactly right
16:21:41 <applicative> @type unwrapping Sum *~ 17
16:21:42 <lambdabot> Num s => Sum s -> Sum s
16:21:57 <applicative> so this is definitely the new under
16:24:47 <A3F> anyone xd ?
16:24:59 <A3F> anyone tried injecting a haskell dll into a process before?
16:26:40 <cariveri> how to Int -> Float ? I got f (g x) where f is reveiving Float g returning Int
16:26:54 <arkeet> cariveri: fromIntegral
16:27:50 <enthropy> A3F: it might be you're searching for the wrong terms? You can call haskell functions from c, which might involve making a dll from your haskell code
16:28:24 <ocharles> If a natural transformation is forall a. f a -> g a, what do you call it if you have forall a. f a -> f a?
16:28:38 <applicative> a natural transformation
16:28:43 <ocharles> no endo or anything there?
16:29:15 <arkeet> a natural transformation from f to f.
16:29:27 <applicative> well in the category of functors and natural transformations, it will be an endo something ;)
16:29:35 <arkeet> endomorphism ;)
16:30:23 <A3F> enthropy: hmm, so does that mean the i am trying to think of the best way to achieve it
16:30:53 <A3F> enthropy: I want to start learning about pathfinding algorithms and wanted to test it out on an  online game but not sure what's the best practice in doing it
16:31:28 <applicative> and the pathfinding bit will be written in haskell
16:32:01 <A3F> ye, i found out how the map structure is layed out in memory
16:32:08 <applicative> well that's  'calling heaven from hell' all right ...
16:32:10 <A3F> but not sure what's the most effecient way to process it
16:32:18 <cariveri> arkeet: thanks. worked.
16:32:44 <A3F> is it possible to populate a haskell type with a pointer to struct?
16:32:46 <applicative> what kind of 'process' will be using the Haskell? are you writing it in C or something?
16:33:36 <A3F> I am still not sure what parts I should write in C and what's the proper method of interfacing between C and haskell
16:33:44 <A3F> that's why i am asking
16:34:07 <elliott> you want to read about the FFI
16:34:50 <A3F> I read about it but didn't find too many comments on its performance
16:34:59 <applicative> it's a pretty black art, but there's plenty of material around.  I wonder if theres a lot on SO. See e.g. http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
16:35:39 <A3F> well, what about the structs?
16:35:51 <applicative> the advantage might not be speed, but that the Haskell makes visible sense.
16:36:04 <A3F> for example sometimes, the C compiler adds padding and the like is there an easy way to accommodate for that in haskell ?
16:36:59 <ReinH> edwardk: hai
16:37:00 <applicative> oh man, the example on the wiki curdles the blood http://www.haskell.org/haskellwiki/FFI_cook_book#Working_with_structs
16:37:03 <ReinH> edwardk: this is... interesting http://gameprogrammingpatterns.com/
16:37:15 <ReinH> applicative: hi
16:37:24 <applicative> hey ho ReinH
16:38:01 <enthropy> applicative: hsc2hs is probably the lowest-level tool
16:38:36 <enthropy> with c2hs I don't think you can just have {# poke fieldName #} or something like that
16:38:42 <enthropy> *I think
16:39:36 <A3F> hmm, what i meant is for example can i reuse an existing C struct in haskell? without copying i mean
16:39:53 <A3F> so for example a haskell record directly points to a C struct
16:40:38 <ski> not the latter, i think
16:40:46 <edwardk> ReinH: we all started there
16:40:57 <ski> but it should be possible to access it without needing to copy over it
16:41:04 <applicative> with game programming patterns?
16:41:10 * haasn started with game development
16:41:14 <edwardk> applicative: yes
16:41:18 <haasn> and I know a bunch of programmers who did the same
16:41:23 * applicative never played a computer game to speak of 
16:41:36 * applicative isn't even a Methodist, so to say
16:41:40 <edwardk> even _i_ have an article on a game programming design pattern on the internet ;)
16:41:43 <sipa> you're playing multiplayer notepad right now
16:41:45 <edwardk> http://www.flipcode.com/archives/Harmless_Algorithms-Issue_03_Design_Patterns_And_3D_Gaming.shtml
16:41:50 <applicative> haha
16:42:17 <thoughtpolice> edwardk: oh man, i haven't seen flipcode in so long
16:42:39 <edwardk> thoughtpolice: heh there are several of us over on enterthegame.com #flipcode still
16:43:17 <A3F> a slightly offtopic question, how useful are software firewalls against udp flooding attacks? my vps has just been knocked out
16:43:18 <A3F> again :/
16:43:35 <applicative> edwardk: i take it that throwing monadic sauce into these Folds, like Tekmo's FoldM (x -> a -> m x) (m x)  (x -> m b) will generate a theoretical disaster, like e.g monadic lenses or something?
16:43:35 <ReinH> edwardk: I'd like to see more about functional algorithms and data structures for  game programming
16:44:03 <edwardk> applicative: nothing disastrous. just exacerbate the explosion of types
16:44:43 <applicative> yeah, now i keep seeing them though. but presumably there is a better way of looking at them.
16:44:55 * flebron shamelessly avoided operational/denotational semantics discussions by telling his freshmen students parametric constructors (as in Just) were "functions which are already in normal form". Not sure how I'll sleep tonight.
16:44:56 <edwardk> applicative: i'm currently working on exploiting the "third homomorphism theorem" -- which isn't as terrifying as it sounds to try to make a version of the folds that work on arbitrary ADTs for parallelizing the synthesizing and inheriting of attributes
16:45:07 <applicative> hm
16:45:34 <applicative> like here's the main export from Lato's posix-dirstream thingy traverseDirectory :: (s -> RawFilePath -> IO s) -> s -> RawFilePath -> IO s
16:45:48 <edwardk> basically there is this notion of a 'list homomorphism' which is a fancy constructive algorithmics version of a fold.
16:46:19 <edwardk> and there is a theorem that shows that if you can construct an answer via a left fold as well as by a right fold then there is a list homomorphism (basically a foldMap) that can construct it
16:46:31 <edwardk> which is a particularly neat result
16:46:48 <edwardk> now, if we take apart a data type and talk about its zippers the path for the zipper looks like a list.
16:47:15 <edwardk> and we can talk about path-dependent folds that start at the top and push information down or that start at the bottom and pull information up
16:48:27 <edwardk> these wind up looking a lot like inherited and synthesized attributes, or histo- and cata- morphisms, etc.
16:48:44 <yng> @help
16:48:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:48:48 <applicative> i was going to say, something in this suggested you'd come full circle...
16:48:56 <yng> @help list
16:48:56 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:49:06 <yng> @list
16:49:06 <lambdabot> What module?  Try @listmodules for some ideas.
16:49:17 <yng> @info
16:49:17 <lambdabot> Error: expected a Haskell expression or declaration
16:49:22 <yng> @info Either
16:49:22 <lambdabot> Either
16:49:23 <edwardk> so i've been spending the last day or so playing around with the third homomorphism theorem and trying to get a nice formulation of a divide and conquer comonad for any computation over an ADT that can be calculated bottom up or top down.
16:49:27 <applicative> @info Map
16:49:27 <lambdabot> Map
16:49:35 <elliott> yng: lambdabot responds in /msg
16:49:45 <enthropy>  @info do x; y
16:49:50 <enthropy> @info do x; y
16:49:51 <lambdabot> x >> y
16:50:04 <edwardk> applicative: http://www.prg.nii.ac.jp/publications/2009/popl09.pdf talks a bit about the use of the third homomorphism theorem to describe computations over zippers: http://www.prg.nii.ac.jp/publications/2009/popl09.pdf
16:50:14 <edwardk> er meant to link once
16:50:17 <ski> yng,enthropy : there is no `info' lambdabot command
16:50:20 <applicative> oh i see a little pearl by gibbons from the 19th c
16:50:29 * hackagebot jacobi-roots 0.1.0.0 - roots of two shifted jacobi polynomials to double precision  http://hackage.haskell.org/package/jacobi-roots-0.1.0.0 (GregHorn)
16:51:08 <applicative> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.2247&rep=rep1&type=pdf
16:51:13 <edwardk> applicative: yeah thats the one
16:51:26 <edwardk> he codified something that up til then had been mostly folklore
16:51:38 <edwardk> now, the third homomorphism theorem itself kinda sucks
16:51:39 <applicative> that might be a place to starts since in any event I like him ...
16:51:41 <enthropy> ski: yeah it becomes undo
16:51:47 <edwardk> it just says one exists, not that its very fast
16:52:21 <edwardk> yeah Jeremy is a great guy
16:52:21 <applicative> and thats where the later discussion goes
16:53:31 <ReinH> edwardk: what are the best books on /ways to learn game programming?
16:53:38 <w0rm_x> edwardk, Jermey who?
16:54:14 <monochrom> Jeremy Gibbons
16:54:39 <edwardk> ReinH: by doing =)
16:54:44 <applicative> w0rm_x: http://patternsinfp.wordpress.com/ to make an unlikely link
16:55:51 <Clinteger> hi, is there a french speaking haskell channel? :)
16:56:23 <applicative> Clinteger: there have been two in the past , hm where is the list?
16:56:37 <monochrom> I think yes, try #haskell-fr and #haskell.fr
16:56:50 <ReinH> edwardk: ok, but by doing *what*? :p
16:56:50 <monochrom> but, if neither exists, then I don't know, probably none
16:56:54 <applicative> #haskell-fr (note the hyphen!) says the wiki
16:57:12 <Clinteger> #haskell-fr has 12 other users :P
16:57:17 <edwardk> ReinH: go write a bunch of code and license it to game companies. worked for me =)
16:57:19 <applicative> there are few present, but several are quite sound
16:57:25 <monochrom> good good
16:57:34 <Clinteger> well, i am heading to bed. goodnight and thanks for the help (?)
16:58:08 <edwardk> Clinteger: well that is 12 more than you had access to before =P
17:00:23 <applicative> #haskell-fr is a 'salon dédié au langage de programmation Haskell'
17:01:04 <applicative> Apprendre Haskell!! lyah.haskell.fr How pleasing
17:06:35 <ReinH> edwardk: I was thinking about cool stuff like the Abrash's black book
17:06:38 <ReinH> s/the //
17:06:51 <edwardk> i loved that book back in the day
17:18:43 <meretrix> Is there a more efficient way to achieve the following grouping without sorting?
17:18:44 <meretrix> > group $ sort [3, 1, 2, 1, 3]
17:18:45 <lambdabot>   [[1,1],[2],[3,3]]
17:20:52 <napping> > Map.fromListWith (+) (zip [3, 1, 2, 1 ,3] (repeat 1))
17:20:53 <lambdabot>   Not in scope: `Map.fromListWith'
17:20:53 <lambdabot>  Perhaps you meant one of these:
17:20:53 <lambdabot>    `M.fro...
17:20:58 <napping> > M.fromListWith (+) (zip [3, 1, 2, 1 ,3] (repeat 1))
17:20:59 <lambdabot>   fromList [(1,2),(2,1),(3,2)]
17:21:53 <joe9> I want to join these 2 functions : http://codepad.org/7g7poDYB . I cannot figure out how. Can you please help? ReaderT Device IO [Word8] is a function and I want to convert it to a Reader Device Assertion. Is that even possible without using runReader, etc.?
17:22:14 <joe9> or Can I have a function with a return type of ReaderT Device Identity Assertion?
17:22:40 <joe9> http://codepad.org/imDzWWKK
17:23:01 <meretrix> napping: Interesting, but not quite what I need. I'll actually be using groupBy and need the actual elements, not just a count.
17:23:10 <napping> meretrix: and something like map ((uncurry . flip) replicate) . Map.toAscList if you really need it as lists of replicated items like that
17:24:03 <napping> wait a minute, group . sort should be O(n log n) anyway
17:24:31 <napping> so asymptotically no
17:25:07 <enthropy> > M.fromListWith (++) $ map (\x -> (x,[x])) [3, 1, 2, 1 ,3]
17:25:08 <lambdabot>   fromList [(1,[1,1]),(2,[2]),(3,[3,3])]
17:25:31 <enthropy> that still sorts the input
17:25:58 <meretrix> Couldn't simply grouping without sorting be O(n)?
17:26:08 <napping> it should be, yes
17:26:27 <napping> Ah, I guess the map things are really n * log (#classes)
17:26:51 <napping> and assume your groupBy predicate is actually an equivalence relation, and you have a compatible order
17:28:47 <meretrix> Ok that does make sense, thanks.
17:30:42 <adas> is it possible to write raw strings in haskell? Like python's raw string syntax for example ..
17:31:07 <Dodek> adas: what do you mean by "raw strings"?
17:31:24 <jfischoff> heredocs? No interpolation?
17:31:43 <napping> you can make a quasiquoter
17:32:42 <k0001> Dodek: I think adas means being able to write "foo\nbar" and that the "\n" part means is interpreted as the two chars '\\' and 'n', not as the single character '\n'.
17:32:56 <mstksg> dmj`: hey, in case you are interested, i have resolved that my errors with heroku had nothing to do with my build, it is almost definitely a timeout error.  i looked at the logs and checked all of the the timestamps and noticed that the crashes all happened **exactly** 15 minutes after the build begins.  i'm trying to explore my options to precompile now.
17:33:15 <Dodek> k0001: ah.
17:33:27 <k0001> That's how they work on Python, at least.
17:33:30 <adas> Dodek: where "\n" is intepreted as 2 strings as opposed to a character
17:33:43 <adas> * 2 character string
17:33:54 <dmj`> mstksg: nice! well done
17:33:55 <adas> napping: quasiquoter?
17:35:06 <napping> http://www.haskell.org/haskellwiki/Poor_man%27s_here_document#Quasiquoting
17:35:17 <napping> maybe also http://hackage.haskell.org/package/heredoc
17:36:31 <YayMe> (>>=) ($) (guard::Maybe a) makes for an interesting function, would it be accurate to call that a morphism (homomorphism?) from the algebra of boolean values under the operation && to the... set of Just() and Nothing under the operation >> or something?
17:37:36 <dmj`> how do I use lenses on a list?
17:37:44 <dmj`> like [1..10].^_2
17:37:54 <edwardk> > [1..10]^?ix 2
17:37:55 <lambdabot>   Just 3
17:37:58 <edwardk> > [1..10]^?ix 100
17:38:00 <lambdabot>   Nothing
17:38:31 <conal> New blog post: "From Haskell to hardware via cartesian closed categories" http://conal.net/blog/posts/haskell-to-hardware-via-cccs
17:38:42 <conal> more to come over the next few days
17:38:54 <dmj`> edwardk: very cool, thanks
17:39:08 <edwardk> conal: nice =)
17:39:24 <fryguybob> conal: The architecture sounds very interesting, I'm looking forward to hearing more!
17:39:24 <conal> :) comments appreciated, as always.
17:39:58 <elliott> conal: quickest click of my life from that title :)
17:40:10 <conal> hah
17:41:09 <jfischoff_> ah crap I just missed the link, conal can you repost?
17:41:20 <shachaf> 17:38 <conal> New blog post: "From Haskell to hardware via cartesian closed categories" http://conal.net/blog/posts/haskell-to-hardware-via-cccs
17:41:26 <jfischoff_> killer
17:41:28 <ReinH> edwardk: what does "zero-byte compression mean here: "Size was a concern; initially, a raw, uncompressed potentially visible set (PVS) was several
17:41:31 <ReinH> megabytes in size. However, the PVS could be stored as a bit vector, with 1 bit per leaf, a
17:41:35 <ReinH> structure that shrunk a great deal with simple zero-byte compression."
17:41:37 <ReinH> argh sorry for multiple lines
17:41:45 <elliott> conal: I haven't read the post yet, but in terms of compiling functional languages to hardware I know a guy who works on http://www.veritygos.org/, which might interest you -- compiling a functional language with a substructural type system (based on affine logic, IIRC) direct to hardware, which I guess relates to your stuff.
17:41:57 <arkeet> ReinH: compressing the zero bytes, maybe.
17:41:58 <elliott> conal: (though beware, draconian EULA to even get to see example code)
17:41:58 <edwardk> ReinH: they just count runs of 0 bytes
17:42:01 <ski> conal : "represent morphisms as objects" is a bit inaccurate
17:42:01 <elliott> now to read.
17:42:09 <ReinH> edwardk: ah
17:42:45 <conal> ski: oh yeah. thx. could you suggest an accurate rewording.
17:42:52 <conal> ski: ?
17:43:11 <conal> hot dang: comments already.
17:44:27 <ski> "represent morphisms as points/values in (certain) objects" might be better. but perhaps you don't want to mention "points/values" here as it's uncategorical
17:44:34 <jmcarthur> conal: you're such a tease
17:44:44 <jmcarthur> "here's what's coming up!"
17:44:46 <conal> jmcarthur: hah -- yeah
17:45:32 <jmcarthur> somebody came to jane street to give a talk on something related once, but i totally forgot who it was
17:45:36 <jmcarthur> it was very interesting though
17:45:40 <edwardk> conal: re: the parallel tree scanning stuff on your blog, had you seen the material on how to apply the third list homomorphism to trees? http://www.prg.nii.ac.jp/publications/2009/popl09.pdf the original third list homomorphism paper talks quite a bit about the connection to inits/tails/scans as well. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.2247&rep=rep1&type=pdf
17:46:03 <edwardk> conal: just came up because i was _just_ playing with this stuff again and you popped on channel =)
17:46:28 <jmcarthur> they were targetting fpgas, but with the intent of only using them to simulate synthesizing hardware
17:46:46 * conal edwardk
17:47:00 <conal> edwardk: yes, but it's been a while, and i've forgotten what's in those papers.
17:47:12 <conal> edwardk: thanks for the reminder.
17:47:38 <ReinH> conal: hey :)
17:48:00 <conal> i'm very interested in hearing about related work
17:48:07 <conal> ReinH: hi
17:48:42 <osa1> sorry for off-topic question -- what is name of left-hand side identifiers in BNF notation? like WhatIsNameOfThis ::= .... ?
17:48:46 <edwardk> the scanl f z = map (foldl f z) ∘ inits    and scanr f z = map (foldr f z) ∘ tails   examples are straight up included in the original paper.     i started playing around with this because i've been using a form of 'fold as a comonad' for strict left and monoidal folds in my posts lately
17:49:05 <monochrom> osa1: non-terminal
17:49:22 <osa1> ah okay thanks
17:49:45 <ski> osa1 : also "(syntactic) category"
17:49:55 <conal> edwardk: i like those specifications as a starting point, but i don't know how to generalize them past lists. do you?
17:49:58 <edwardk> conal: re beautiful folding https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 and https://www.fpcomplete.com/user/edwardk/parallel-crc go into some extra structure the folds have
17:50:00 <ski> (not related to category theory)
17:50:35 <conal> edwardk: thx. i'll check them out.
17:50:43 <edwardk> conal: i spent today putting together a version of this that works on arbitrary polynomial functors by using the list homomorphisms on the zippers.
17:51:17 <conal> edwardk: oh, wow
17:51:19 <edwardk> i'm currently trying to get all my comonad-as-resumption and monad-as-multipass machinery to work in the general setting
17:51:49 <jmcarthur> conal: i think it's hard not to run into his work even with very obvious google search terms, but this is the guy i was thinking of who has interesting work related to your blog post: http://www.cs.columbia.edu/~sedwards/
17:51:51 <edwardk> for the comonad i appear to need the leaves to be trivial in a way i'll need to figure out how to articulate for a writeup
17:52:06 <edwardk> but the monad works pretty much regardless
17:52:22 <conal> jmcarthur: thanks. i've been looking at his stuff.
17:52:34 <adas> napping: thanks for the link. that helped
17:53:06 <elliott> conal: (did you see my possibly-related link earlier? just checking it didn't get drowned :))
17:53:54 <conal> elliott: the veritygos link?
17:54:13 <elliott> conal: right
17:54:27 <conal> elliott: thanks. i meant to ack at the time. guess i got distracted.
17:54:44 <jmcarthur> conal: are you planning to support laziness?
17:54:46 <elliott> it can go from very functional recursiveish type code straight to vhdl (or was it verilog?), is my understanding
17:55:04 <elliott> (and non-trivially)
17:55:07 <conal> jmcarthur: non-strictness?
17:55:13 <dalaing> is there any consensus on which of mtl / transformers / etc... should be used for new code?
17:55:39 <jmcarthur> conal: non-strictness with sharing
17:55:45 <dalaing> I remember various mailing list and blog post discussions on the topic from a while ago, but my google-fu is failing me
17:55:50 <monochrom> mtl builds upon transformers. so first of all you don't need to choose between those two.
17:56:25 <monochrom> now I don't know what's etc. I really don't.
17:56:41 <conal> jmcarthur: we plan to support full haskell semantics, including non-strictness. probably sharing, but more likely something like speculation than the usual lazy evaluation.
17:57:43 <jmcarthur> conal: cool! i can't want to read more then
17:57:50 <joe9> I have this function http://codepad.org/XTPZJVMF that I am trying to convert to >>= or >> usage.  similar to this: http://codepad.org/wHKVCr08 . but, I cannot get it to work. Any suggestions on how to go about it, please?
17:57:53 <jmcarthur> well, not that i wasn't before...
17:57:53 <dalaing> there were some others a few years ago - monadlib, monads-fd, and so on, I think some have been subsumed by mtl since then
17:58:03 <jmcarthur> ugh
17:58:13 <jmcarthur> conal: sorry, i sometimes hit enter before reading what i wrote :)
17:58:20 <jmcarthur> s/want/wait/
17:58:49 <conal> jmcarthur: funny typo. i hadn't even noticed. read what you meant instead.
17:58:50 <arkeet> joe9: what didn't work?
17:58:54 <arkeet> can you show what you tried?
17:59:04 <niteria_> can I get memory profile of a running haskell program?
17:59:05 <monochrom> yes, that was many many years ago. everything said back then no longer hold.
17:59:11 <joe9> arkeet: sur, 1 sec.
17:59:17 <conal> jmcarthur: it's a very ambitious project, and so far i'm the only one working on it anything close to full time. i'm hoping that this series of blog posts will stir up collaboration.
17:59:53 <joe9> arkeet: program : http://codepad.org/y6WaWPNy , error: http://codepad.org/FW6j3Uzo
18:00:32 <dalaing> monochrom: nice, that simplifies things
18:00:40 <arkeet> joe9: I think you want
18:00:45 <conal> unrelated note: i found out how i recently kept typing "ftp" when i meant "frp". my irc client (textual) auto-corrects, and with the small font, i rarely notice that the change had been made.
18:00:45 <arkeet> ask >>= \device -> return $ (...)
18:01:07 <joe9> conal, what is the project about? did not catch it.
18:01:15 <arkeet> @undo do { device <- ask; return $ foo }
18:01:15 <lambdabot> ask >>= \ device -> return $ foo
18:01:31 <dalaing> I finally found at least one example of the kind of mtl vs transformers discussion I was remembering
18:01:34 <joe9> arkeet: brilliant, thanks.
18:01:38 <dalaing> on mtl vs transformers from the pipes mailing list - " `mtl` is more powerful than `transformers`, but the     `transformers`/`mmorph` style leads to better type inference and     error messages and the code is easier to understand because it is     more theoretically principled. "
18:01:38 <ski>   asks $ \device -> ..device..
18:01:40 <conal> joe9: compiling haskell to hardware. see http://conal.net/blog/posts/haskell-to-hardware-via-cccs
18:01:48 <arkeet> that's one too.
18:01:59 <jmcarthur> conal: i look forward to your upcoming post detailed the lambda->ccc compiler. this is something i have been vaguely interested in but never really researched
18:02:07 <jmcarthur> *detailing
18:02:34 <ReinH> conal: I look forward to my 3d circuit printed haskell program/machines
18:02:46 <ReinH> and step 3, which is skynet
18:02:57 <conal> jmcarthur: cool. the next two posts are about just that. one about the basic translation, and the other about optimizing the result. that part is working fairly well.
18:03:10 <dmj`> is there a way to modify the value of a list using lenses? like, [[1,2,3],[4,5,6]].^_1_2 *= 4 = [[1,2,3],[4,5,24]]
18:03:31 <dmj`> oops, thats assuming index base 0
18:03:44 <ReinH> > [1,2,3] & ix 1 .~ 3
18:03:46 <lambdabot>   [1,3,3]
18:04:27 <dmj`> [[1,2,3],[4,5,6]] & ix 1 & ix 2 .~ 20
18:04:33 <dmj`> > [[1,2,3],[4,5,6]] & ix 1 & ix 2 .~ 20
18:04:34 <elliott> > [[1,2,3],[4,5,6]] & ix 1 . ix 2 *~ 4
18:04:35 <lambdabot>   Couldn't match type `p0 (Control.Lens.At.IxValue m0)' with `[]'
18:04:35 <lambdabot>  Expected t...
18:04:36 <lambdabot>   [[1,2,3],[4,5,24]]
18:04:39 <napping> edwardk: what's this about comonads as resumptions? I've recently used resumptions while experimenting with GLL parsing, but as a free applicative
18:05:14 <dmj`> ReinH, elliott: Nice thanks!
18:05:29 <elliott> dmj`: note that it will "silently fail" if the index is out of bounds.
18:05:39 <ReinH> > [[1,2],[3,4]] & (ix 1 . ix 1) .~ 2
18:05:41 <lambdabot>   [[1,2],[3,2]]
18:05:44 <mstksg> dmj`: out of curiosity, have you yourself ever tried to deploy a project with many dependencies to heroku that would take longer than 15 minutes to build?  am i the only one who is getting timeout errors or simply the first to have so big a project?
18:05:56 <joe9> conal, thanks.
18:06:05 <arkeet> > [1,2,3] & singular (ix 5) .~ 20
18:06:07 <lambdabot>   [1,2,3]
18:06:09 <arkeet> heh.
18:06:21 <ReinH> singular?
18:06:25 <dmj`> > ["ab","cd"] & (ix 1 . ix 1) .~ 'z'
18:06:26 <lambdabot>   ["ab","cz"]
18:06:30 <joe9> what is the mtl equivalent for ReaderT or Reader?
18:06:42 <joe9> ski, thanks.
18:06:43 <arkeet> ReinH: turns a traversal into a lens into the first target
18:06:51 <arkeet> fails if there are no targets.
18:07:02 <arkeet> > "abc" ^. ix 1
18:07:04 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
18:07:04 <lambdabot>    arising from a use o...
18:07:04 <edwardk> napping: the comonad lets me do things like take a left folding and 'pre-apply' it to some input, then resume the fold with more input
18:07:05 <arkeet> > "abc" ^. singular (ix 1)
18:07:07 <lambdabot>   'b'
18:07:10 <arkeet> > "abc" ^. singular (ix 5)
18:07:11 <lambdabot>   *Exception: singular: empty traversal
18:07:37 <arkeet> > "abc" ^? ix 5
18:07:38 <lambdabot>   Nothing
18:07:39 <arkeet> > "abc" ^?! ix 5
18:07:40 <napping> edwardk: Ah, I was thinking "resupmtion monad" not resuming folds
18:07:40 <lambdabot>   *Exception: (^?!): empty Fold
18:07:48 <edwardk> napping: e.g. run (run (duplicate crc32) [1,2]) [3,4]      -- calculates a crc32 for [1,2,3,4]
18:07:52 <dmj`> elliott: thanks good to note
18:07:56 <joe9> :r
18:08:21 <napping> I saw the folding stuff, it looks nice
18:08:22 <edwardk> napping: the 'duplicate' sneaks in before the comonad applies the last change to the crc
18:08:29 <jfischoff> edwardk: when I think of polynomial functors I think of things like GHC.Generics. You said your making something work for polynomial functors in general, what does that mean specifically?
18:08:57 <jfischoff> what representation of polynomial functors, and am I even thinking of the right thing...
18:09:02 <edwardk> i started working with ghc generics first. i have a bunch of code. it got hard to reason about so i stopped and started a simpler version
18:09:35 <jfischoff> what's the simplier way?
18:10:19 <edwardk> let me paste
18:10:25 <edwardk> this is _very_ much a work in progress
18:10:29 * jfischoff nods
18:11:02 <hpaste> edwardk pasted “comonadic divide-and-conquer tree-traversals” at http://lpaste.net/92921
18:11:26 <edwardk> the other version used ghc generics to determine the base functor
18:11:45 <edwardk> but the derivatives themselves were nigh unreadable
18:11:51 <edwardk> i stopped working mid-edit
18:11:59 <edwardk> but i'll paste a broken version so you can compare
18:12:03 <jfischoff> cool
18:12:46 <hpaste> edwardk pasted “broken version i was working on using ghc generics” at http://lpaste.net/92922
18:13:03 <edwardk> the new one is rather tidy
18:13:16 <edwardk> the old one was frankly horrifying ;)
18:13:49 <edwardk> the new version makes some simplifying assumptions about leaves though
18:13:54 <jfischoff> M1 is so annoying, not to mention the extensions
18:13:55 <edwardk> so i can mak the comonad easier
18:14:15 <edwardk> the current code assumes that all leaves are trivially equivalent to unit
18:14:24 <edwardk> which is a lie, but makes it easier to code the stuff i care about for now
18:14:41 <ReinH> edwardk: the leaf is a lie?
18:15:03 <edwardk> well, i might have a polynomial functor that has values at the leaves
18:15:09 <edwardk> so their structure would be more interesting
18:15:17 <edwardk> but then i lose my comonad
18:15:17 <jfischoff> yeah
18:15:31 <edwardk> i'm okay with that. in the folds package i have 'scans' that fit that structure
18:15:31 <jfischoff> huh
18:15:35 <edwardk> and i can still work with them
18:15:38 <edwardk> but they kinda suck
18:15:41 <edwardk> and i prefer the comonads
18:15:43 <dmj`> mstksg: the slug size will be bigger due to the RTS. Maybe go with a VPS (linode,ec2). Automate with chef or fabric
18:15:51 <dmj`> mstksg: http://stackoverflow.com/questions/11214167/how-to-run-snap-haskell-webapp-in-production
18:15:52 <edwardk> so i'm playing with this case first
18:17:51 <edwardk> Conquery t a is a calculation that represents the consumption of a 'wedge' of a tree. you can feed it a zipper into the tree, and it'll represent the calculation of an algorithm  that can work both bottom up and top down on the zipper along that path. collapsing it out.
18:17:58 <edwardk> er Conquer t a
18:18:19 <edwardk> then it can be defined in terms of itself on the other holes of the derivative
18:18:47 <jfischoff> edwardk: Alright something more to read at the Haskell meetup tonight thanks
18:18:49 <edwardk> so given a tree with n nodes and operations that take O(1) you can run in time O(log n) on n / log n cores over a tree of n nodes
18:19:25 <edwardk> this should be sufficient to calculate most path-dependent calculations on trees, e.g. maximum path weight, tree height, etc.
18:19:55 <edwardk> and you can 'pre-apply' Conquer to a tree-top or tree-bottom
18:20:03 <edwardk> that is what the comonad gives
18:20:37 <edwardk> so i can add below :: Z t -> Conquer t a -> Conquer t a        above :: Conquer t a -> Z t -> Conquer t a
18:20:50 <edwardk> and you can mix them to describe the tree as you get parts of it
18:21:16 <edwardk> then one can adapt these to compute modified trees as a scan spitting out a cofree comonad as they go
18:21:35 <edwardk> and multipass algorithms would be represented via the monad that you can have for Conquer t
18:22:15 <edwardk> still working on it. it doesn't quite do everything i want yet
18:25:17 <carter> conal COOOl!
18:34:59 <osa1> sorry for another off-topic question but -- I'm looking for LaTeX snippets to copy->paste->edit to show some operational semantics and some other derivation/inference rules ... if you have that can you please share with me?
18:41:33 <joe9> ski, love the asks . Thakns.
18:43:57 <sinistersnare> also: is TextInputListener working on iOS? im assuming no...
18:45:25 <sinistersnare> jk, loooks like its implemented
18:52:55 <carter> sinistersnare are you playing with ghc-ios?
18:53:54 <sinistersnare> no, why? i posted that on the wrong chan
18:54:02 <sinistersnare> sorry, thanks for letting me know why no one was answering me :D
19:00:52 * hackagebot dns 1.0.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.0.0 (KazuYamamoto)
19:06:47 <dmj`> if I have a class (Set :: (* -> *) -> Constraint), and a type (RBTree :: (* -> *), but want to include an Ord constraint, do I have to use undecideable instances? instance Ord a => Set RBTree a where ... gives "set is applied to too many arguments" instance Ord a => Set RBTree where ... works with udnecideable instances. instance Ord a => Set (RBTree a), makes RBTree a have the kind "*", which isn't compatible with Set
19:07:18 <dmj`> from okasaki's book
19:09:25 <ski> the `instance Ord a => Set RBTree' isn't right
19:09:40 <ski> you probably need to change `Set'
19:09:59 <carter> you kinda need a bijection
19:10:10 <carter> unless you define merge rules
19:11:34 <hpaste> dmj pasted “RBTree” at http://lpaste.net/92923
19:14:36 <dmj`> verbatim from okasaki, no pragmas
19:15:11 <dmj`> DOH
19:15:19 <dmj`> class Set s a where :)
19:15:25 <dmj`> don't mind me
19:16:00 <k0001> ~
19:16:58 <dmj`> ski: note to self, read code before posting
19:18:59 <onemouth> wc
19:21:16 <TallerGhostWalt> What are the best libraries to use for compression in haskell?
19:22:00 <carter> TallerGhostWalt which type of compression?
19:22:02 <carter> storage?
19:22:05 <carter> communication?
19:22:05 <TallerGhostWalt> yeah
19:22:07 <carter> batch?
19:22:08 <carter> streaming?
19:22:15 <carter> which?
19:22:20 <TallerGhostWalt> storage and streaming
19:22:22 <TallerGhostWalt> not batch
19:22:24 <TallerGhostWalt> or comm
19:22:31 <carter> streaming storage?
19:22:37 <carter> explain your use case more!
19:22:46 <TallerGhostWalt> yep
19:23:00 <TallerGhostWalt> I am working on a simple Time Series Database
19:23:09 <carter> ohhh
19:23:10 <TallerGhostWalt> I want to store old entities
19:23:16 <carter> and fast reads and writes?
19:23:23 <carter> with ok cmpression
19:23:26 <carter> or GOOD compression
19:23:35 <carter> with slow writes, and fast reads?
19:23:59 <carter> lz4 and snappy are worth checking out
19:24:10 <TallerGhostWalt> will do
19:24:16 <carter> if you can serialize to to a binary bytestirng format
19:24:19 <TallerGhostWalt> I want staged compression eventually
19:24:22 <TallerGhostWalt> I can
19:24:23 <carter> i also started a binding for BLOSC
19:24:28 <carter> i still need to finish it
19:24:49 <carter> might get around to fiddlign with blosc and snappy and lz4 a bit in a month
19:25:19 <crunc>      ,
19:25:21 <crunc>     g'   4f xM9=*     4g    ]&_  4f A  &  pMF~~~!
19:25:23 <crunc>    J!    7  .q_,N     4~_   ]8B  M B'  f  0g
19:25:25 <crunc>    0    /!   6^`$     &mQL  ]& *jT 0  .8    ~~"W,
19:25:27 <crunc>   ]T_ .N    *}   #   pX  Nc ]#  0! 0 _#   q,_,g0
19:25:29 <crunc>    ""~'     `^   ~   `   ~'  ^  "  ~~~    `````
19:25:31 <crunc>   _____,    ,g,           _g
19:25:33 <crunc>   ``Z``    _M  ""         0&c
19:25:34 <crunc>     .I     4&g,_         #V_p
19:25:36 <crunc>      $      ___jp       y!"~~&
19:25:38 <crunc>   wr0#gae   ~~~"`            "
19:25:40 <crunc>                                                   
19:25:53 * haasn scratches head
19:26:06 <carter> is that one of those crazy 2d langs?
19:26:12 <haasn> like befunge?
19:26:14 <haasn> or piet?
19:26:26 <haasn> it could be perl, I don't know
19:26:39 <flebron> Is there a recommended way to do 3D graphics in Haskell?
19:26:56 <haasn> flebron: there are OpenGL bindings but I don't think they're very pretty
19:26:58 <carter> flebron realtime or releaistic?
19:27:03 <haasn> 3d graphics is a sector I feel haskell is really lacking in, btw
19:27:07 <flebron> carter: Either.
19:27:09 <haasn> haskel llibraries I mean
19:27:12 <k0001> The imperative folks are trying boycott #haskell.
19:27:35 <joe9> i have a function definitions showing up with :t . I cannot figure out which library or file it is being read from. Any thoughts on how I can figure it out , please?
19:27:46 <k0001> joe9: try :info
19:27:53 <joe9> k0001: thakns.
19:27:55 <joe9> thanks.
19:29:46 <edwardk> woot. i've got the divide and conquer comonad actually working
19:29:57 <haasn> comonad and conquer
19:30:03 <edwardk> hahaha
19:30:12 <edwardk> i may steel that as a post titl
19:30:18 <haasn> no copyright. :)
19:30:25 <edwardk> er steal even
19:30:29 <edwardk> wow i typo today
19:30:36 <carter> edwardk are you tired early for a chagne?
19:30:43 <haasn> this is why english needs a typo system
19:31:16 <TallerGhostWalt> hehe
19:32:04 <ReinH> edwardk: divide and conquer comonad?
19:32:50 <hpaste> edwardk pasted “Comonad and Conquer” at http://lpaste.net/92925
19:33:04 <edwardk> >>> run mpw (Bin (Bin Tip 1 Tip) 2 (Bin (Bin Tip 2 Tip) 3 Tip))    ==> 7
19:33:14 <edwardk> where mpw = maximum path weight
19:33:24 <edwardk> but its computed in such a way that all the answers can be computed in parallel
19:33:39 <arkeet> monoids!
19:33:48 <edwardk> and you can fuse it with other computations
19:34:34 <haasn> wait a minute.. does sumList execute in parallel?
19:34:46 <haasn> or is that still naive
19:35:13 <edwardk> it can. its not yet doing so
19:35:20 <carter> omgurd, and theres no crazy ghc generics too :)
19:35:32 <edwardk> carter: i wanted a simple bloggable version
19:35:36 <carter> thanke you
19:36:01 <ReinH> edwardk: I am buying ALL the books on game/graphics development/math
19:36:08 <carter> you're on a pedagogical rampage
19:36:10 <arkeet> ALL the books
19:36:12 <arkeet> D:
19:36:15 <carter> ReinH physcially based rendering
19:36:16 <ReinH> well, all the ones that look good
19:36:17 <edwardk> ReinH: sounds like a start
19:36:20 <carter> is the one everyone recommends
19:36:25 <haasn> ReinH: every last copy?
19:36:28 <ReinH> carter: eh?
19:36:30 <ReinH> haasn: perhaps not
19:36:31 <arkeet> every e-copy too
19:36:36 <ReinH> all your bits are belong to me
19:36:39 <haasn> ReinH: because I'll have you know I'll fight ov-- oh
19:36:43 <carter> http://www.amazon.com/Physically-Based-Rendering-Second-Edition/dp/0123750792
19:36:59 <carter> the graphics book EVERYONE who does real graphics recommends
19:37:03 <ReinH> carter: o_O seems good! Physically Based Rendering
19:37:05 <ReinH> er
19:37:08 <ReinH> seems good!
19:37:18 <carter> edwardk and a data vis researcher i'm friends with said its the only one worth starting with
19:37:50 <ReinH> textbook prices o_O
19:37:51 <carter> because all the stuff that isn't the general principles, is a performance hack specific to a particular generation of hardware / software and its whatever quirks
19:37:52 <haasn> edwardk: no import of Control.Lens either. :(
19:37:58 <carter> 64 dollars?
19:37:59 <carter> yeah
19:38:08 <haasn> I've gotten into habit of importing that even if I don't end up using it just because it makes me feel safe
19:38:09 <carter> threres pdfs online if you look i htink
19:38:37 <joe9> I have this function : http://codepad.org/9zfMiIqc . Any suggestions on how I can shorten it, please?
19:39:08 <joe9> I am calling runReaderT multiple times. I wish there was a way to do one call.
19:39:23 <joe9> and bind the inner functions.
19:39:27 <heath> hoogle
19:39:30 <heath> !hoogle
19:39:34 <heath> !hoogle halp
19:39:38 <joe9> but, I could not figure out how to bind the assertEqual statement.
19:39:44 <arkeet> runReaderT x r >> runReaderT y r = runReaderT (x >> y) r
19:39:50 <arkeet> what are the types of things?
19:39:55 <heath> lambdabot: Network.Transport.TCP
19:40:00 <ski> @hoogle heath
19:40:00 <lambdabot> No results found
19:40:23 <joe9> arkeet: thanks. but, the assertEqual line is not a runReaderT function.
19:40:46 <arkeet> I'm not asking what it's not.
19:40:54 <joe9> I need to use something like lift or such to convert it to a ReaderT Device function.
19:41:07 <arkeet> what us ut>
19:41:09 <arkeet> what is it?
19:41:31 <joe9> arkeet: http://codepad.org/CL4ZXXcu
19:41:34 * heath is curious how many concurrent connections an http server written in haskell can handle
19:41:47 <edwardk> ReinH: PBR is great especially if you want to learn the hows and whys everything works the way it does
19:41:53 <heath> 2-3 million for erlang and scala/akka
19:41:57 <joe9> arkeet:  Assertion == IO ()
19:42:11 <edwardk> also CGP&P is just coming out with a new edition. that book pretty much shaped my 20s ;)
19:42:14 <haasn> heath: your best bet would probably be to look up some warp benchmarks or maybe test it yourself
19:42:22 <heath> haasn: already did it
19:42:31 <arkeet> joe9: have you tried liftIO?
19:42:32 <heath> and my warp code is terrible
19:42:38 <haasn> “http server” is vague, though
19:42:47 <haasn> I'm sure there are far more and far less efficient servers out there
19:42:49 <carter> heath depends on the hardware also!
19:43:11 <arkeet> liftIO . assertEqual ...
19:43:22 <haasn> unrelated: can operating systems even handle millions of connections? don't port numbers cap out at 2^16 or something? Or are you talking about distributed systems, too?
19:43:22 <heath> https://gist.github.com/heath/6086184
19:43:23 <joe9> arkeet: will try that. thanks.
19:43:29 <heath> carter: sure, but i'm using my hardware for now
19:43:47 <carter> whats your hardware?
19:43:52 <carter> and whats the benchmark?
19:44:03 <haasn> heath: I found http://www.yesodweb.com/blog/2011/02/warp-speed-ahead which seems to promise staggering numbers
19:44:09 <haasn> might want to try and find out what code they used
19:44:10 <haasn> for some reference
19:44:18 <carter> heath: also GHC HEAD / 7.8 is what ypou really wanna bench with
19:45:08 <heath> https://gist.github.com/heath/6546295
19:45:24 <heath> you would think `runhaskell HerroWorld.hs' would launch a tcp server, no?
19:45:46 <carter> wait what
19:45:49 <joe9> arkeet: this worked http://codepad.org/kotkzPAN thanks.
19:45:57 <heath> carter: 200,000 versus 2,000,000
19:45:59 <carter> heath why are you using distributed process + mvars for benchmarking?
19:46:05 <heath> i want 10x the speed
19:46:08 <carter> what versus what?
19:46:10 <heath> and i figure it can happen
19:46:19 <carter> explain more please?
19:46:25 <heath> scala/akka or erlang versus ze haskell
19:46:34 <carter> ok
19:46:40 <carter> distirbuted process won't be right for that though
19:47:02 <heath> re: why distributed process, distributed haskell is the closest to the actor model of computation
19:47:16 <heath> that's what the scala/akka and erlang benchmarks are using
19:47:31 <carter> yeah
19:47:43 <heath> so why wouldn't it be right?
19:47:43 <carter> but distirbuted process does a lot on top
19:47:52 <heath> okay
19:48:09 <carter> so like
19:48:23 <carter> lemme break out my networking spec / books
19:48:35 <carter> do you have links to the scala/erlang codes in question?
19:48:51 <napping> heath: are those benchmarks actually using multiple processes?
19:48:52 <carter> like, how are they handling the sockets
19:49:13 <heath> napping: i don't know how they could get those numbers without multiple processes
19:49:20 <carter> and are they using tcp or udp?
19:49:25 <heath> tcp
19:49:35 <napping> having a decent runtime that can use multiple cores with a single OS process (at least for Erlang)
19:49:48 <carter> heath link to the other codes?
19:49:52 <heath> sure
19:50:02 <heath> http://uberblo.gs/2011/12/scala-akka-and-erlang-actor-benchmarks
19:50:07 <napping> Erlang's distribution stuff is *very* nice, but I doubt it's being used
19:50:13 <carter> agreed
19:50:33 <carter> for the haskell code, you'll want n= # of cores capiblities
19:50:36 <carter> and a worker per core
19:50:46 <carter> and also you'll want to use ghc 7.8
19:50:50 <carter> err head
19:51:46 <carter> oooo
19:51:49 <carter> they're not using TCP
19:51:53 <carter> they're doing in memory messaging
19:52:07 <heath> wuh
19:52:22 <carter> just use pipes-concurrent
19:52:26 <carter> and see how fast that is
19:53:21 <carter> https://github.com/PaulKeeble/ScalaVErlangAgents/blob/master/scala/Client.scala right?
19:53:40 <carter> via looking at http://uberblo.gs/2011/12/scala-akka-and-erlang-actor-benchmarks
19:53:43 <carter> no TCP going on
19:54:24 <carter> https://github.com/PaulKeeble/ScalaVErlangAgents
19:54:26 <carter> yup
19:54:39 <carter> just try writing a "paralle pipes concurrent thingy"
19:54:47 <carter> that has an "add this number"
19:54:54 <carter> and reset to zero command
19:55:58 * hackagebot classy-prelude 0.5.10 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.10 (MichaelSnoyman)
19:56:17 <carter> heath doing it with TCP adds A LOT of heavy lifiting :)
19:56:36 <NemesisD> any of you guys use Angel by chance?
19:57:11 <carter> whats that?
19:57:37 <NemesisD> a process monitor in haskell. i maintain it and i wanted to do some quick surveying of users
19:57:38 <kloplop321> Exception: compiler/rename/RnSource.lhs:430:14-81: Irrefutable pattern failed for pattern Data.Maybe.Just
19:57:42 <kloplop321> I am scared.
19:58:06 <dwcook> Does anything ever use Bounded as a constraint?
19:58:48 <carter> @hackage Angel
19:58:48 <lambdabot> http://hackage.haskell.org/package/Angel
19:59:00 <carter> http://hackage.haskell.org/package/angel
19:59:18 <NemesisD> dang case sensitive package names
19:59:24 <carter> yeah
19:59:35 <carter> means i always need to grab both :)
19:59:41 <carter> errr
19:59:59 <carter> NemesisD sounds handy!
20:00:02 <carter> iddn't know about it
20:00:05 <carter> and i don't do much ups
20:00:08 <carter> ops
20:00:12 <carter> whats a good exampel use case?
20:00:23 <carter> oh, reading the readme now
20:00:35 <carter> NemesisD you should promote it more maybe :)
20:00:47 <carter> what would i use it for?
20:01:26 <NemesisD> well at my job we use a ruby process monitor that is a piece of crap, but we use process monitoring for making sure long running processes stay running
20:01:26 <acomar> NemesisD: you might want to ask on the mailing list or post on /r/haskell, you're more likely to get a more complete survey
20:01:42 <NemesisD> so web servers, logging services, background job workers, etc
20:01:53 <carter> ok
20:01:59 <carter> ask on those lists
20:02:02 <carter> but also view asking
20:02:09 <carter> as a marketing opportunity
20:02:14 <carter> because many folks won't know about it
20:02:39 <carter> and so a short explnation / link to the readme/tutorial in your survey inquiry will probably also induce an uptick in usage!
20:02:49 <NemesisD> i always feel stuff like this is too small and nitpicky for /r/haskell, considering like 5 posts hit that site a day and they are usually a big deal
20:02:53 <carter> no
20:02:57 <carter> share
20:03:01 <carter> good ops tools are a big deal
20:03:02 <carter> :)
20:03:18 <carter> knowing that tools exist is half the battle
20:03:32 <carter> i just discovered browser inspectors yesterday
20:03:34 <NemesisD> i really just wanted to get opinions on a minor feature i was contemplating.
20:03:38 <carter> oh
20:03:41 <carter> sorry
20:03:50 <NemesisD> maybe cafe is the place to go
20:04:19 <zhanrnl> hey, any vim users here?
20:04:38 <NemesisD> zhanrnl: i use vim
20:04:38 <carter> probably
20:04:49 <zhanrnl> nemesis: what do you use for indentation?
20:05:00 <acomar> zharnl: I'm a vim user as well
20:05:02 <NemesisD> zhanrnl: mostly agony
20:05:15 <cschneid>  >> and <<
20:05:24 <zhanrnl> I haven't heard of agony
20:05:28 <zhanrnl> what is it?
20:05:30 <NemesisD> considering *all* i code in my free time is haskell, my haskell rigging in vim is pretty dreadful
20:05:36 <NemesisD> lol actual agony
20:05:45 <cschneid> zhanrnl: haha, a feeling of sadness.
20:05:47 <acomar> >.> I mostly make up a macro on the spot and use that to indent or un-indent a block
20:05:49 <zhanrnl> ... I see
20:05:50 <zhanrnl> :P
20:05:51 <NemesisD> and yeah i use >> and << to indend blocks around till i get it right
20:05:53 <cschneid> zhanrnl: note the insert mode  ctrl-t and ctrl-d
20:06:08 <cschneid> zhanrnl: :help i_ctrl-d
20:06:22 <zhanrnl> I did not know about the insert mode keybindings, thanks
20:06:29 <NemesisD> i think theres a distribution of vim that has nice haskell support but my config is precarious enough
20:07:05 <cschneid> syntastic and hdevtools is all I have. Seems reasonable - does save-time compile to check syntax, and I can ask for ad-hoc types of things
20:07:21 <NemesisD> cschneid: nice! been using vim for like 5 years and i didn't know that one
20:07:22 <zhanrnl> is there just no interest in autoindentation a la emacs haskell-mode?
20:07:39 <NemesisD> i'd like a syntax/type check in vim that integrates properly with cabal sandbox
20:07:47 <cschneid> NemesisD: yeah, it's slick. I need to get back to it, but I was doing www.vimdrills.com for a while, and researching the just-out-of-reach things.
20:07:55 <dalaing> NemesisD: like ghcmod?
20:07:55 <zhanrnl> cschneid: I have those and they're great
20:07:58 <NemesisD> the minute i started using sandboxing tools (and finally the official ones) was the minute most of my vim haskell stuff broke
20:08:07 <acomar> I mean, the vim haskell-mode works pretty well and it gets the indent level fine initially
20:08:20 <acomar> but when the code changes around it, it's tricky to fix the indentation
20:08:27 <cschneid> NemesisD: how so? I tweaked my hdevtools config a bit: let g:hdevtools_options = '-g-isrc -g-Wall'
20:08:30 <zhanrnl> acomar: are you talking about http://projects.haskell.org/haskellmode-vim/ ?
20:08:32 <acomar> NemesisD: I actually just got that working today
20:08:48 <acomar> zharnl: yea, that + ghcmod-vim take care of most of my needs so far
20:09:25 <NemesisD> cschneid: acomar how does ghcmod-vim + haskellmode-vim compare with hdevtools
20:09:30 <acomar> NemesisD: I had to add a bunch of autocmds to pass the sandbox dir to everything as a package-dir
20:09:44 <acomar> NemesisD: I couldn't say, I've never used hdevtools
20:09:57 <cschneid> ghcmod-vim and hdevtools seem similar I think - this is just the one I used. really, it just lets me put my cursor somewhere, and get the type of the expression
20:10:02 <dalaing> NemesisD: it might be heretical, but I have ghcmod-vim and hdevtools running at the same time
20:10:05 <cschneid> and expand it larger if I hit it again
20:10:23 <cschneid> not played with haskellmode-vim. Does more?
20:11:08 <cschneid> hmm, haskellmode seems slick, I'll give that a go later
20:11:10 <johnw> hey, I actually just used dijnn to write a real function :)
20:11:33 <dalaing> ghcmod-vim / neco-ghc / neocomplcache / syntastic is a nice vim combo
20:11:51 <zhanrnl> nothing seems to be quite as intelligent as the emacs indentation plugin, from what I've tried
20:12:01 <haasn> johnw: callCC? :)
20:12:02 <acomar> I need to figure out what neco-ghc does... I have it installed but never set up keybindings and the like for it
20:12:14 <zhanrnl> and it's awfully tempting to try to write my own for vim
20:12:17 <johnw> haasn: no, I needed a function Either (k, a) (k, b) -> (k, Either a b)
20:12:29 <haasn> costrength
20:12:38 <haasn> sort of
20:12:39 <acomar> zharnl: give haskellmode-vim a try first, it does most of what you want
20:12:39 <haasn> not really
20:12:41 <haasn> nvm
20:12:55 <zhanrnl> acomar: okay, I will, thanks
20:12:58 <acomar> zharnl: I just need to figure out how to get it to re-auto-indent a block
20:13:34 <NemesisD> i feel like if vim's native language wasn't such a disaster we'd be closer to feature parity than with emacs' haskell stuff
20:14:11 <zhanrnl> has anyone figured out how to script vim in haskell? :)
20:14:15 <NemesisD> i'm just assuming emacs support for haskell is awesome because everything about emacs seems more advanced than vim except for their cretenous editing mode
20:14:57 <dalaing> acomar: the images at https://github.com/ujihisa/neco-ghc give a bit of an idea of what neco-ghc does
20:15:13 <dalaing> with the usual vim completion key bindings (Ctrl-N / Ctrl-P and so on)
20:15:14 <haasn> :t view $ choosing _1 _1 `alongside` choosing _2 _2 :: Either (k, a) (k, b) -> (k, Either a b)
20:15:15 <lambdabot>     Couldn't match type `Either (k, a) (k, b)'
20:15:15 <lambdabot>                   with `(Either s0 s'0, Either s1 s'1)'
20:15:15 <lambdabot>     When using functional dependencies to combine
20:15:20 <haasn> :(
20:15:28 <haasn> oh, that's not how alongside works
20:15:31 <acomar> NemesisD: generally, that's not really the case. Vim starts more basic is what it boils down to; you have to add plugins to make it do what you want
20:15:36 <NemesisD> i've got supertab in vim which is a little easier on the hands than the regular autocomplete
20:15:42 <haasn> :t view (choosing _1 _1) &&& view (choosing _2 _2) :: Either (k, a) (k, b) -> (k, Either a b)
20:15:43 <lambdabot>     Couldn't match type `a' with `Either a b'
20:15:43 <lambdabot>       `a' is a rigid type variable bound by
20:15:43 <lambdabot>           an expression type signature:
20:15:57 <haasn> oh, that's not how choosing works
20:16:00 <NemesisD> acomar: yeah but the people who write plugins are the people who can tolerate vimscript, which is a special breed
20:16:17 <haasn> :t view (choosing _1 _1) &&& view (either snd snd) :: Either (k, a) (k, b) -> (k, Either a b)
20:16:17 <lambdabot>     Couldn't match type `Either
20:16:18 <lambdabot>                            (a0,
20:16:18 <lambdabot>                             Either (k, a) (k, b)
20:16:29 <acomar> NemesisD: do you know vimscript? the more I learn, the less horrified I feel :)
20:16:29 <johnw> haasn: heh, still not simpler than the djinn version :)
20:16:41 <dalaing> the only problem with neco-ghc is that it feels a little like I'm cheating
20:17:07 <haasn> :t join either fst &&& join either (Left . snd)
20:17:07 <lambdabot> Either (a, b) (a, b) -> (a, Either b b1)
20:17:09 <haasn> hmph
20:17:30 <NemesisD> acomar: what i've seen seems pretty bad. i follow/know of a lot of developers and only one of them has the stomach to write vim plugins
20:18:22 <acomar> NemesisD: yea, I'm not anywhere near being able to write plugins, but I'm starting to get a feel for the language. It's not well thought out, but it's not awful. It's actually relatively functional.
20:18:39 <acomar> dalaing: thanks, I'm gonna have to play with it
20:19:10 <acomar> I was just thinking the completions I was getting weren't very good (limited to the current module / what has been used locally)
20:20:17 <johnw> haasn:
20:20:18 <johnw>         unwrap (Left (b, c))  = (b, Left c)
20:20:19 <johnw>         unwrap (Right (d, e)) = (d, Right e)
20:20:49 <johnw> about twice as long
20:20:50 <cschneid> zhanrnl / NemesisD: there's a nice ruby type language that compiles down to vimscript. Anything really to make vimscript less terrible. https://github.com/luke-gru/riml Maybe a new haskell-mode project is needed?
20:21:03 <cschneid> acomar: ^^
20:22:12 <ski> @type either fst fst &&& bimap snd snd
20:22:12 <lambdabot> Either (c, b) (c, b1) -> (c, Either b b1)
20:22:54 <NemesisD> i may check out a branch of my vim config and give hdevtools or something a quick go. basically i think i need to wait-and-see what haskell dev tooling learns how to use cabal 1.18 properly first
20:23:09 <haasn> ski's is cooler, and also way more correct, than my last attempt :)
20:23:42 <acomar> cshneid: looks interesting, I'll check it out, thanks
20:23:45 <joe9> is there a better way of writing this function: http://codepad.org/LMAb0dKh
20:24:03 <acomar> NemesisD: want my vimrc hack?
20:24:05 <NemesisD> i'm not interested in spending lots of time rigging my editor anymore. I'm fast enough that unless someone does a lot of the work for me in a plugin, i'll just manage indentation and dev feedback myself
20:24:27 <acomar> NemesisD: I just made cabal sandboxes work
20:24:28 <NemesisD> acomar: if it is concise and works with cabal sandbox ;)
20:24:28 <ski> @type second Left ||| second Right
20:24:29 <lambdabot> Either (d, a) (d, b) -> (d, Either a b)
20:24:34 <NemesisD> sock it to me
20:24:54 <dwcook> Has someone published a module with safeMaximum :: [a] -> Maybe a?
20:24:56 <Ghoul_> joe9: you can put a flip before mapM
20:25:10 <joe9> regarding the editor, I used to be a vim fanboy until I stumbled upon evil of emacs.
20:25:10 <flebron> How can I convert Foreign.C.Types.CFloat to Float?
20:25:13 <dwcook> I searched Hoogle to no avail
20:25:24 <arkeet> joe9: you can use forM
20:25:25 <joe9> now, I seem to have the best of both worlds. vimscript gets crazy.
20:25:26 <Ghoul_> and then move xs as the first argument there, and add more dots for the lambda part so you dont need the outer \device -> lambda
20:25:26 <arkeet> wait.
20:25:28 <arkeet> never mind.
20:25:34 <Ghoul_> Oh yeah forM is good
20:25:38 <Ghoul_> arkeet is right
20:25:42 <dwcook> Sorry, that should be safeMaximum :: (Ord a) => [a] -> Maybe a
20:25:43 <arkeet> yeah.
20:25:52 <joe9> Ghoul_: I tried flip but could not figure it out.
20:25:56 <joe9> let me try forM
20:26:10 <Ghoul_> Im not sure if forM_ exists. hayoo is down for me
20:26:11 * arkeet wonders why you're using ReaderT so much when you have asks and ReaderT construction everywhere
20:26:15 <arkeet> it does.
20:26:19 <ski> @hoogle forM_
20:26:19 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
20:26:19 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
20:26:27 <acomar> NemesisD: http://lpaste.net/92928
20:26:41 <Jurily> I wonder if hdevtools can be integrated with KDevelop's custom buildsystem
20:27:08 <acomar> NemesisD: I actually stole s:find_basedir() straight from ghcmod-vim, it just doesn't expose the function. But essentially it finds the project dir by looking for the .cabal file.
20:27:45 <NemesisD> acomar: exactly what plugins do i need to bundle for this?
20:28:25 <mstksg> after using haskell for a bit i wonder why people ever put commas at the end of lines isntead of the beginning
20:28:25 <acomar> NemesisD: ghcmod-vim, and possibly haskellmode-vim
20:28:49 <acomar> NemesisD: can't remember which b:ghc_staticoptions comes from
20:29:47 <acomar> the downside is that this isn't properly and truly sandboxed -- it'll still read from the normal environment rather than just from the sandbox
20:29:53 <acomar> I'll figure out how to fix that if it ever bites me
20:30:19 <joe9>  arkeet, I could not figure out how to represent Assertion (== IO ()). I have a lot of functions which return Assertions.
20:30:23 <dalaing> acomar: what version of ghcmod do you have installed?
20:30:34 <joe9> I converted them to instead return ReaderT Device IO ()
20:30:34 <acomar> dalaing: the latest, 3.0.0
20:30:37 <arkeet> joe9: I'm just wondering why you're using ReaderT everywhere.
20:30:40 <xxpor> mstksg, oh man I just realized that today. I forgot commas so often when I'm editing code thats 1 item per line, but having it at the beginning makes it impossible because it's so visually obvious.
20:30:58 <joe9> arkeet. I would love to use something as Reader Device Assertion.
20:31:03 <joe9> but, that did not work.
20:32:06 <arkeet> or Reader.
20:32:19 <NemesisD> acomar: thanks. i keep my user package db pretty clean so i should be okay
20:32:29 <napping> mstksg: I've though having strict terminators would be uniform than separators when you need to edit lines, but I never considered strict initiators
20:32:53 <NemesisD> as soon as i stopped being afraid of nuking my user ghc packages and installing cabal from source, all of my fears melted away
20:33:47 <acomar> yea, I try to keep my user installed packages to stuff I actually need outside of any specific projects
20:34:06 <acomar> like vim plugin dependencies and xmonad
20:34:22 <acomar> but I only started using the sandboxes like...yesterday
20:34:27 <NemesisD> btw what's the official indentation size in vim? i use 2 and am unwilling to go any hire than that
20:34:27 <acomar> so there's some polution there
20:34:31 <NemesisD> higher*
20:34:47 <acomar> whatever you set it to
20:34:55 <acomar> I have mine set to 4. *shrug*
20:35:28 <elliott> that kind of limits your choices unless you're expecting 1-space indentation to be official.
20:35:36 <NemesisD> madness
20:35:42 <NemesisD> how about 0
20:35:49 <haasn> I use 2-space indentation
20:37:14 <joe9> arkeet: http://codepad.org/ezaLJhiH code . line 103, I want to change it to Reader Device Assertion,but, could not figure out how. error: http://codepad.org/PzqUJfqh
20:37:48 <joe9> arkeet, let me try it again.
20:37:52 <joe9> give me a min.
20:38:38 <monochrom> I use pi spaces. some friends ask me to use tau spaces instead. so I sometimes do that.
20:39:06 <haasn> monochrom: averaged over the number of lines? :)
20:39:09 <NemesisD> lol
20:39:24 <NemesisD> monochrom: you're a haskell weekly newsletter quote machine
20:40:43 <flebron> How could one fix "    Couldn't match type `Foreign.C.Types.CFloat' with `Float'"? I thought CFloat was a newtype for Prelude.Float.
20:42:31 <monochrom> since you know it's a newtype, why are you expecting them to match, instead of needing manual wrapping and unwrapping?
20:43:06 <flebron> Would the wrapping be using fromRational . toRational?
20:43:23 <monochrom> no. using the constructor and pattern matching
20:43:46 <joe9> arkeet, if I change the ReaderT Device IO () to Reader Device Assertion. I find that I am using Identity a lot more. Is that expected?
20:44:04 <monochrom> well, wrapping: constructor. unwrapping: pattern matching
20:44:20 <acomar> dalaing: are you using neco-ghc with neocomplete, or just as an omni-complete function?
20:44:22 <flebron> monochrom: Floats have constructors? CFloats do as well?
20:44:32 <arkeet> joe9: I don't know.
20:44:45 <arkeet> joe9: have you tried seeing what happens if you remove Reader/ReaderT entirely?
20:44:46 <monochrom> "CFloat is a newtype" = CFloat has a constructor
20:44:49 <arkeet> and just go with e.g. Device -> IO ()
20:44:53 <arkeet> instead of ReaderT Device IO ()
20:44:56 <monochrom> is this your first day with newtype?
20:45:03 <flebron> Yep :)
20:45:13 <arkeet> newtype is very similar to data.
20:45:17 <monochrom> ok, I'll tell more
20:45:27 <dalaing> acomar: with neocomplcache
20:45:33 <joe9> arkeet, and then pass Device as a parameter?
20:45:51 <acomar> dalaing: is there some specific advantage to doing it that way?
20:46:00 <arkeet> joe9: yeah. I'm just wondering how much of the asks/runReaderT/etc it would clean up.
20:46:03 <monochrom> "newtype X = Ctor Bool". this means "Ctor False" has type X, and "case x of Ctor b -> b" gives you the Bool back
20:46:04 <joe9> arkeet, ok,I am adding too many Device
20:46:05 <arkeet> since you seem to have a lot of it.
20:46:05 <flebron> Oh OK, so it's CFloat Float.
20:46:15 <dalaing> acomar: I can't remember, it might have just worked at the time
20:46:22 <joe9> arkeet: I agree. let me try with Reader Device Assertion.
20:46:27 <joe9> That should help.
20:46:30 <dalaing> acomar: or someone else had success with it and I followed like a sheep
20:46:37 <flebron> monochrom: Cool :) Thanks!
20:46:38 <joe9> arkeet, thanks for raising it up.
20:46:45 <acomar> dalaing: kk, I'm going to try it as an omni-complete function for now, and see if there any issues with that before I upgrade
20:46:55 <monochrom> but it also means that the type checker will pretend that X and Bool are different
20:47:11 <arkeet> joe9: you know that (->) r is also a monad, right?
20:47:17 <arkeet> isomorphic to Reader r
20:47:31 <arkeet> where ask = id, asks = id, runReader = id, etc.
20:47:52 <flebron> monochrom: Is this used to hide implementation from abstract datatypes?
20:48:05 <monochrom> usually yes. there are other uses
20:48:08 <ski> that's one use
20:48:08 <bscarlet> > map (\x -> encodeFloat 1 (shiftL 1 x)) [30,31]
20:48:09 <lambdabot>   [Infinity,0.0]
20:48:35 <flebron> Implement a typeclass in two different ways?
20:48:46 <monochrom> yes
20:48:56 <napping> flebron: often you would just not export the implementation, if it's a data type. But if you want some existing type like Map Int Int to be considered abstract you could put a newtype around it
20:49:04 <bscarlet> okay, I know it's weird to use encodeFloat with such a ridiculously large value, but isn't that just wrong?
20:49:31 <arkeet> > encodeFloat 1 60
20:49:32 <lambdabot>   1.152921504606847e18
20:49:40 <arkeet> er.
20:50:43 <bscarlet> down in the sane range I suspect it's just fine.
20:51:05 <bscarlet> > encodeFloat 1 1000
20:51:06 <lambdabot>   1.0715086071862673e301
20:51:14 <bscarlet> > encodeFloat 1 10000
20:51:15 <lambdabot>   Infinity
20:51:20 <bscarlet> That's sane.
20:51:25 <arkeet> > encodeFloat 1 (2^31)
20:51:26 <lambdabot>   0.0
20:51:35 <bscarlet> That's what I think is weird.
20:51:42 <carter> bscarlet floats are weird
20:51:45 <arkeet> > encodeFloat 1 (2^31-1)
20:51:46 <lambdabot>   Infinity
20:51:59 <arkeet> @index encodeFloat
20:51:59 <lambdabot> Prelude
20:52:04 <NemesisD> acomar: man haskellmode-vim hasn't been updated in a year
20:52:05 * ski idly wonders how bscarlet floats differ from ordinary ones
20:52:13 <bscarlet> carter: don't blame it on the floats.
20:52:29 <carter> i blame it on the rats
20:52:40 <monochrom> whatever floats your boat
20:52:40 <carter> and computable reals
20:53:22 <bscarlet> ski: Heh. Actually, that's exactly what I'm doing. I'm implementing floats in Haskell, and checking them against the real thing.
20:53:28 <carter> oo
20:53:29 <carter> cool
20:54:21 <k0001_> Boy… programming does get boring without a bit of Haskell here and there!
20:54:30 <bscarlet> Where do I file a bug for this? GHC?
20:54:58 <carter> hrmm
20:55:04 <carter> is it a bug or semantics issue?
20:55:14 <carter> bscarlet email libraries list
20:55:27 <carter> plus do a tentative ghc trac ticket
20:56:25 <carter> libaries list is where all libraries changes get ok'd
20:56:30 <carter> this is a semantics bug
20:56:48 <bscarlet> carter: What do you mean by "semantics bug"?
20:57:14 <carter> most things in prelude were defined in some haskell standard at some point ish
20:57:31 <carter> :info encodeFloat
20:57:39 <carter> blah
20:58:47 <acomar> NemesisD: why fix what isn't broken?
20:59:16 <acomar> NemesisD: this cabal update is the only thing I can think of that needs some love
20:59:19 <monochrom> perhaps it is not a fix, it is a new feature
21:00:19 <carter> bscarlet ie: a bunch of the stuff the prelude was defined ish in H98 or H1.4
21:00:21 <carter> http://www.haskell.org/onlinereport/standard-prelude.html
21:00:34 <carter> so its either a) underspecified semantics in those
21:00:36 <carter> or wrong semantics
21:01:42 <acomar> dalaing: do you get completions for modules you haven't already loaded/imported? was hoping this would add that kind of indexing ability :/
21:01:55 <NemesisD> acomar: this is going surprisingly well with just ghcmod
21:01:57 <carter> but point being: ghc trac + libraries list both
21:01:59 <carter> is probably a goo diea
21:02:52 <acomar> dalaing: like Control.A<C-x><C-o> lists nothing, but Control.<C-x><C-o> automatically completes to Control.Monad since it's already loaded.
21:03:05 <bscarlet> carter: The report doesn't say much, so I suppose it's underspecified, but the haddock says it should be returning Infinity. Given that the switch from Infinity to 0.0 happens at 2^31, which would be where Int became negative on 32-bit, I suspect it's just plain a bug.
21:03:49 <acomar> NemesisD: yea, that's primarily where you need the cabal integration since ghcmod-vim is what calls all the various ghc functions
21:03:49 <carter> ok
21:04:12 <carter> bscarlet i'd say email the libraries list to report the bug
21:04:26 <acomar> NemesisD: maybe I should figure out how to actually sandbox this and submit it upstream...
21:05:27 <joe9> arkeet, I did not understand what you mentioned about -> r, isomorphic, etc.
21:05:38 <joe9> Any place where I can read more about it, please?
21:06:23 <arkeet> joe9: Reader r a  is the same as  r -> a
21:06:27 <arkeet> (it's a newtype for it, after all)
21:06:42 <arkeet> (->) r  is just the syntactically correct way to write  (r ->)
21:07:04 <arkeet> > (do { a <- (+1); b <- (*3); return (a,b) }) 10
21:07:05 <lambdabot>   (11,30)
21:07:34 <arkeet> > runReader (do { a <- asks (+1); b <- asks (*3); return (a,b) }) 10
21:07:35 <lambdabot>   (11,30)
21:07:40 <NemesisD> acomar: i am noticing a lot of weird warnings about redundant imports in my test helper, even though it reexports them
21:07:43 <arkeet> this is why I said asks = id, runReader = id
21:07:54 <NemesisD> seems like if you import a function and eexport it shouldn't be marked redundant
21:08:11 <acomar> NemesisD: is that coming from HLint?
21:08:24 <joe9> arkeet, Yes, I understand that.
21:08:55 <NemesisD> acomar: GhcModCheck, so it must be warnings from GHC -Wall
21:09:17 <arkeet> I wonder why mtl doesn't use Reader r a = ReaderT r Identity a
21:09:40 <joe9> I think it does.
21:09:50 <arkeet> it doesn't.
21:09:54 <arkeet> wait.
21:09:54 <acomar> NemesisD: might need to set a specific no warn on option, I'm not sure
21:10:00 <joe9> most of my errors when I convert from ReaderT to Reader r are from that.
21:10:04 <arkeet> I'm looking at an old version.
21:10:28 <joe9> I changed ReaderT Device IO [Word8] to Reader Device (IO [Word8])
21:10:36 <joe9> and am getting errors about the identity stuff.
21:10:49 <arkeet> what a pain. =(
21:11:03 <acomar> NemesisD: if you think it's a bug, file a ticket on ghc -- GhcModCheck is just reporting what ghc -Wall says
21:11:54 <NemesisD> acomar: meh, ghcmod actually reads OPTIONS_GHC pragmas in the file, that seemd to do it
21:13:35 <NemesisD> acomar: do you run any hooks as "async" in your vim? i noticed on mine that even though they are async, they take control of the cursor from me till they finish
21:14:36 <NemesisD> erm not when run explicitly only on autocmd BufWritePost *.hs GhcModCheckAndLintAsync. interesting
21:17:19 <acomar> NemesisD: yea, that's the one
21:17:56 <acomar> oh, focus grabbing... I find it's weird
21:18:20 <acomar> the cursor seems to jump, but if I :x the frame, it frequently closes the wrong window
21:18:36 <NemesisD> i wonder if its syntastic
21:19:09 <acomar> I'm not sure; I have syntastic installed but not well set up
21:20:05 <acomar> I installed a whole bunch of plugins a year ago on third-party recommendations, but didn't bother to configure them correctly or learn how they worked... I'm regretting that now
21:23:13 <NemesisD> acomar: sure enough it was syntastic. since i will be getting type checking for free and asynchronously, i just made syntastic passive for haskell :)
21:24:19 <acomar> NemesisD: awesome :). I'm going to fix syntastic when I finish with this neco-ghc stuff.
21:31:04 <joe9> once in a monad, the monad remains in the return type, correct? I do not understand how this works: :t TestLabel "a" . TestCase :: Assertion -> Test
21:31:20 <joe9> Assertion is IO () and Test does not have IO in it.
21:33:08 <haasn> data Example = Example { runExample :: IO () } -- just an example
21:35:32 <joe9>  http://codepad.org/LrXd58lm
21:36:19 <joe9> I do not see where Test has an IO in it.
21:36:28 <Clint> joe9: TestCase Assertion
21:36:48 <Clint> but your question is a bit flawed
21:37:19 <joe9> Isn't that more like a monad then. similar to say, State IO ()
21:37:44 <Clint> are you trying to solve a particular problem?
21:38:22 <joe9> I am lost figuring out trying to use : Reader r Assertion ->  Reader r Test
21:38:37 <joe9> I find using ReaderT r IO () is easier than Reader r Assertion.
21:38:54 <joe9> but, I notice that to convert the Assertion to Test, I am using quite a lot of asks, etc.
21:39:21 <joe9> I am trying to figure out why I cannot simply use Reader r Assertion and not worry about Identity , etc.
21:40:03 <Clint> you're trying to write a hunit assertion that uses Reader?
21:40:36 <joe9> Clint, yes.
21:40:46 <joe9> all my tests run on a particular device.
21:40:58 <joe9> I want to send the device as a parameter to the tests.
21:41:14 <joe9> and reader seems to be the way to go about it.
21:41:51 <Clint> hmm
21:53:15 <joe9> clint, any thoughts on how to go about it instead of using Device -> for each function and not using ReaderT ..
21:55:23 <joe9> or, is HUnit a wrong choice for these kind of tests. Should I be using a different testing library?
21:57:04 <Clint> hunit should be fine, but i think Device -> is going to be less headache for you unless you like lifting everything
21:59:56 <ReinH> edwardk: I am reading ALL the books
22:00:21 <flebron> Is something like this idiomatic? "type Radius = Float; type Position = (Float, Float); type Color = (Float, Float, Floar); data Shape = Circle Radius Position Color | Line Position Position Color".
22:05:22 <ReinH> flebron: you probably want Double http://www.haskell.org/haskellwiki/Performance/Floating_point
22:05:44 <flebron> I'm more worried about designing the thing correctly, but thanks also :)
22:06:18 <flebron> So far most of my programs have been toys and competition solutions, no real experience with large (>1 KLOC) Haskell code, so was trying to write things idiomatically.
22:07:36 <dalaing> flebron: this is a nice resource (although unrelated to idiomatic design of data types) - http://www.seas.upenn.edu/~cis194/lectures.html
22:07:50 <ReinH> flebron: it's idiomatic enough, although you might prefer something like: newtype Position = Position { _x, _y :: Double }; newtype Color = { _r, _g, _b :: Double }
22:08:15 <ReinH> or even: type X = Double; type Y = Double; newtype Position = Position { _x :: X, _y :: Y }
22:08:16 <flebron> ReinH: Those would be the same but with accessors?
22:08:24 <flebron> dalaing: I was up to Applicatives (part 2) in that :)
22:09:08 <dalaing> ReinH: I think you need data instead of newtype
22:09:21 <dalaing> ReinH: newtype only works for wrapping a single value
22:09:22 <ReinH> dalaing: yep whoops
22:09:36 <ReinH> in fact that's totally wrong
22:09:39 <ReinH> but it gets the idea across :)
22:10:04 <ReinH> flebron: depends on whether you think not being able to create a color from an X coordinate is an important thing for your type system to verify, etc
22:10:28 <ReinH> flebron: but tuples everywhere is a form of string typing imo
22:10:35 <flebron> Makes sense.
22:10:39 <ReinH> so I prefer type constructors
22:11:03 <flebron> Is Real World Haskell the current standard material on Haskell software architecture?
22:11:41 <ReinH> it's still a good start imo
22:12:09 <ReinH> flebron: Chris Forno has been doing some nice screencasts too https://www.youtube.com/jekor
22:12:31 <flebron> Oh yeah I'd caught some of those :))
22:15:59 <joe9> Isn' there some function/app that will show how two functions can be put together based on the function types.
22:16:24 <flebron> Is there a way to name parameters in a data constructor? (That's why I used type Radius = Float, so I could say Circle Position Radius Color instead of Circle Position Float Color)
22:17:13 <dalaing> flebron: the types of parameters? or the values?
22:17:38 <flebron> The names of the parameters, so one can know what Circle expects.
22:17:46 <dalaing> flebron: for naming the types, you're already on the right path, for naming the values, there's record syntax
22:18:23 <dalaing> flebron: ie data Circle = Circle { position :: Position, radius :: Float, color :: Color}
22:19:07 <flebron> Suppose I had data Shape = Rectangle Float Float. Is there any way to indicate to a user that the first is the width, the second is the height, in a way that they can know without looking at how I named my accesors?
22:19:37 <flebron> (That is, other than Rectangle { width, height :: Double})
22:20:10 <dalaing> flebron: you could use type Width = Double and type Height = Double, but then you're users are going to have to look those up to work out what they are
22:20:23 <flebron> Right.
22:20:26 <dalaing> one way or another, if they're going to use them, they need to know what they're dealing with
22:21:00 <ReinH> Which is pretty easy to do
22:21:14 <ReinH> and shouldn't be a barrier to using a nicer set of types
22:21:16 <dalaing> I've seen more code with record syntax used to solve that problem than code with type aliases
22:22:04 <ReinH> I might use more type aliases than the average haskeller :)
22:23:32 <dalaing> ReinH: there might be selection bias in the code I've been looking at :)
22:31:59 <flebron> I guess my issue is solved more properly with documentation. Is there a general way of knowing when to export a constructor function, and when to create a separate function that returns instances of that type?
22:36:24 <dalaing> whatever causes the least pain for the user?
22:37:11 <dalaing> I think writing heaps and heaps of code will help guide your intuition :)
22:37:36 <edwardk> I've just posted https://www.fpcomplete.com/user/edwardk/conquering-folds in case anyone feels like doing a proof-reading pass
22:38:40 <ReinH> edwardk: oooooooooh :D
22:38:53 <ReinH> comonadic, parallel folds
22:38:55 <ReinH> SEEMS USEFUL
22:39:13 <edwardk> it will be once someone tells me how to make them run fast in parallel =)
22:39:24 <dalaing> edwardk: paragraph 2 - "enable computing certain computations" reads a bit funny "perform certain computations" instead?
22:39:28 <edwardk> but the code i had seemed nicely self-contained
22:39:35 <edwardk> dalaing: sure
22:40:31 <edwardk> ReinH: i blame you. you know i hadn't really thought about a comonad for 3 months before that interview =P
22:40:33 <acomar> dalaing: ended up having to set up neocomplete (I decided that was easier than typing neocomplcache) to get neco-ghc working correctly; I absolutely love it, thanks for the tip.
22:41:19 <dalaing> acomar: not a problem - one day I'll clean up / fully understand my various haskell / vim plugins and put it on github / write a blog post about it
22:41:27 <ReinH> edwardk: it's totally my fault
22:41:35 <ReinH> edwardk: now write cellular automata part 3
22:41:37 <ReinH> kthx
22:41:40 <edwardk> i figured you wouldn't object too hard
22:41:41 <edwardk> hahahah
22:41:43 <edwardk> forgot about that
22:41:50 <ReinH> ofc you did
22:41:53 <edwardk> maybe this weekend
22:41:59 <edwardk> i want it to run fast first
22:42:03 <ReinH> edwardk: at some point I am going to convince you to write a roguelike with me that uses all these new concepts
22:42:11 <ReinH> (new to me)
22:42:24 <edwardk> this post is about stuff that is new to me too
22:42:32 <edwardk> hence the 'asking for help' ending
22:42:53 <ReinH> either that or I will cunningly trick you into writing half of it by asking you questions that prompt you to write more SoH articles
22:42:58 <carter> NemesisD nice theme on your hakyll site1
22:43:01 <dalaing> acomar:  although I'm considering ramping up my emacs-fu for Agda / proof-general mode in Coq / other assorted goodness, so I might end up turning to the chordal side before too long
22:43:45 <ReinH> dalaing: god I might need to re-learn emacs
22:47:27 <joe9> what is the function to convert: IO [Word8] -> ReaderT r IO [Word8]
22:48:04 <mauke> lift
22:50:22 <joe9> mauke thanks.
22:50:32 <Hafydd> @hoogle IO [Word8] -> ReaderT r IO [Word8]
22:50:32 <lambdabot> Did you mean: IO [Word8] -> ReaderT r (IO r) [Word8]
22:50:32 <lambdabot> No results found
22:50:57 <Hafydd> @_@
22:51:24 <Hafydd> @hoogle IO [Word8] -> ReaderT r (IO r) [Word8]
22:51:25 <lambdabot> No results found
22:51:39 <Hafydd> Thanks, lambdabot. Very helpful.
22:53:11 <ReinH> lmao
22:53:23 <ReinH> Did you mean x? Why yes, yes I did. No results for x.
22:53:29 <joe9> mauke, can you please advise if I am asking for too much. I have a lot of unit tests or test hunit functions that run on a device.
22:53:49 <joe9> I want to use the Reader monad to pass the device along to the test functions.
22:54:02 <joe9> I could change the functions to have a Device -> parameter.
22:54:09 <carter> i'll read the post too
22:54:26 <joe9> but, that would be almost for all functions and I feel Reader is the cleaner way to go.
22:54:56 <joe9> But, when I am trying to convert Assertion -> Test. I am getting stuck with the usage of ReaderT vs Reader.
22:55:24 <joe9> I can use Reader Device Test to hold the tests and ReaderT Device  IO () to hold the assertions.
22:55:52 <joe9> but, to convert Assertion to Test using TestCase, I have to run asks and convert the ReaderT's to Reader.
22:56:24 <dalaing> joe9:  can you define the function in terms of MonadReader?
22:57:10 <linduxed> hey guys
22:57:34 <linduxed> is there a name for "float that equals an integer?
22:57:44 <linduxed> as in 2.0 or 14.0?
22:57:55 <joe9> dalaing: isn't MonadReader == Reader?
22:57:59 <linduxed> and i don't mean a haskell type, but some general mathematical term
22:58:12 <linduxed> because i don't think "even float" is the right expression
22:58:19 <dalaing> joe9: MonadReader is a typeclass - Reader and ReaderT are instances of it
22:58:23 <johnw> mathematically, I think 2 and 2.0 are the same entity
22:58:52 <johnw> the difference is notational, not one of "type" like the way numbers are represented differently inside a computer
22:59:33 <joe9> dalaing: that is a good idea. any examples that I can check out, please?
23:00:18 <dalaing> joe9: off the top of my head - the monad transformers chapter of Real World Haskell? other than that I'd just be googling
23:00:32 <joe9> ok, thanks.
23:03:17 <ReinH> johnw: that depends on how you define 2, 2.0, "same" and "entity".
23:03:56 <dalaing> 2.0 is an integer, it's just spelled funny
23:04:15 <mbrock> integral float? integer-valued float? float representation of an integer? JavaScript integer? :P
23:04:49 <ReinH> linduxed: I think it's called a "float that equals an integer" :D
23:05:16 <ReinH> you might be able to get away with integer-valued in context
23:05:27 <linduxed> ReinH: yeah, i'm currently leaning towards "whole number float"
23:05:33 <linduxed> that has a nice ring to it
23:05:42 <linduxed> integer-valued is also nice though
23:07:39 <dalaing> joe9: this is semi-related http://stackoverflow.com/questions/13007123/modular-program-design-combining-monad-transformers-in-monad-agnostic-function
23:08:06 <dalaing> joe9: there's a better example out there that I've come across before, currently unable to find it though
23:17:47 <MercurialAlchemi> one thing I find aggravating about Haskell is how much error handling sucks
23:18:13 <johnw> do you have a more constructive question perhaps?
23:18:18 <sp3ctum> how are you doing error handling, and why do you think it sucks?
23:18:24 <MercurialAlchemi> it's inconsistent, and you rarely know which function is liable to blow up in your face
23:18:45 <sp3ctum> can't you see by the type?
23:19:12 <MercurialAlchemi> You can't see it by the type when people handle problems by using exceptions or fail ()
23:20:11 <MercurialAlchemi> I use EitherT, personally, but it doesn't help with third-party libraries
23:20:17 <sp3ctum> yeah
23:20:42 <thoughtpolice> ah, yes, asynchronous exceptions, the bane of modern Haskell programs. having done some async-heavy stuff recently, it's definitely not as composable as i would like (i still feel better with Haskell opposed to a lot of other things)
23:20:54 <thoughtpolice> and just wrapping Control.Exception.try around everything is of course a bit much
23:21:50 <MercurialAlchemi> (Not to mention people who think it's OK to use Either String a in supposedly reusable code, because weakly-typed errors are the future of error handling)
23:21:58 <johnw> well, and try won't catch an async exception that happens immediately after the try :)
23:22:20 <MercurialAlchemi> it's a bit disappointing for a language which prides itself in safety
23:22:45 <thoughtpolice> johnw: sure, IME although when you're talking about third party interfaces, most of the time you're talking about exceptions being thrown 'up front'
23:22:49 <MercurialAlchemi> even Java with non-runtime Exceptions does better
23:23:21 <johnw> MercurialAlchemi: do you have any suggestions for improving things?
23:23:59 <sp3ctum> do throwing exceptions show up in a function's type?
23:24:15 <johnw> sp3ctum: not unless you use a package to provide that
23:24:30 <sp3ctum> how does a package provide it then?
23:24:51 <johnw> see http://hackage.haskell.org/package/control-monad-exception
23:25:06 <sp3ctum> thanks
23:25:28 <elliott> async exceptions make for some very scary carefulness required in IO code
23:25:56 <johnw> i rather like that async exceptions are part of the exception framework, rather than being something completely separate like signals
23:26:07 <flebron> Is it always recommended to explicitly list the symbols one imports from a module?
23:26:10 <MercurialAlchemi> well, I don't know
23:26:37 <MercurialAlchemi> There is a lot of "Haskell is so powerful, feature XXX is a library"
23:26:51 <thoughtpolice> elliott: yeah, you can very easily wind up in a situation where you throw in the middle of modifying an MVar or something if you're not careful. async has helped me quite a bit here, but it still requires a lot of care
23:26:53 <k0001_> The "Cancellation and Timeouts" chapter in Simon Marlow's new book talks about how to deal with async exceptions in detail. I found it quite helpful http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
23:27:36 <elliott> I do wonder how much we'd lose without async exceptions.
23:27:42 <johnw> thoughtpolice: I tend to use ResourceT so I don't have to worry quite as much
23:27:44 <elliott> well, a lot.
23:27:44 <MercurialAlchemi> unfortunately, the truth is usually:  "Haskell is so powerful, feature XXX is five separate and incompatible libraries"
23:27:46 <thoughtpolice> the whole second half of the book is IMO, required reading if you want to write a lot of concurrent Haskell programs
23:27:46 <elliott> but still.
23:28:46 <johnw> elliott: you'd sort of lose the ability to model what is going to happen anyway
23:30:43 <MercurialAlchemi> johnw: but ResourceT doesn't help with, say, catching all your errors and turning them into user-friendly messages
23:31:24 <johnw> MercurialAlchemi: I'm working with a few others on improving the state of error representation in Haskell right now, but it's going to take time for these things to mature
23:32:11 <MercurialAlchemi> johnw: interesting, what plans do you have?
23:32:34 <johnw> at the moment we're just pooling all the various methods, libraries, etc., and reviewing what is the best of all of them
23:33:05 <johnw> it's going well so far, but I'm not ready to discuss any actual choices yet
23:33:17 <johnw> but trust me, a lot of people feel your pain
23:33:52 <flebron> I am writing "  import Graphics.Rendering.OpenGL.GL.VertexAttributes (Color3)". How come I get "    Not in scope: data constructor `Color3'"?
23:34:13 <MercurialAlchemi> johnw: I'd imagine that :)
23:36:00 <flebron> Oh, I had to say Color3(Color3), because as a newtype, one's the type, the other the ctor. :)
23:36:03 <k0001_> flebron: You probably want `import Graphics.Rendering.OpenGL.GL.VertexAttributes (Color3(Color3))`. The “Color3” in the inner parentheses is the constructor, the one outside is the type.
23:36:12 <flebron> ;)
23:36:13 <MercurialAlchemi> johnw: at the moment, the best thing I've come up with is using EitherT with a global error type, a string explanation and a sum type for an error flag, but it doesn't come with a source location or makes it easy to wrap another error in it
23:36:38 <johnw> you could use monad-loc to add source location info
23:37:15 <MercurialAlchemi> woohoo
23:37:24 <MercurialAlchemi> I had no idea this thing existed
23:38:28 <johnw> also, the 'attempt' package has a way of unifying multiple error types, but it's more of a convenience thing
23:38:53 <MercurialAlchemi> which kind of reinforces my point that essential features like this should be part of the language as opposed a third-party solution
23:39:31 <sp3ctum> I agree
23:39:32 <johnw> Haskell was always meant for research; allowing language features to be a third-party solution means that experimentation and research can continue without requiring language changes
23:39:54 <johnw> locking Haskell down to what is most practical for real-world code was never the objective
23:39:58 <sp3ctum> we could have the best of both worlds easily too
23:40:22 <sp3ctum> with some sort of a community-driven "real world" version perhaps
23:40:35 <MercurialAlchemi> johnw: I get the point, but you have to draw a line somewhere
23:41:02 <johnw> have to?
23:41:31 <MercurialAlchemi> johnw: well, unless you want ten different ways of doing pattern matching
23:41:41 <johnw> some people want that, some don't
23:42:59 <MercurialAlchemi> johnw: but you can't have a usable ecosystem if your "language" is a group of mostly-heterogeneous dialects, and that's kind of silly, especially with how much real-world code for Haskell exists now
23:43:54 <johnw> I don't disagree with you in terms of making Haskell a more practical language; I'm just saying that not everyone has this objective by any means.  That's kind of what "avoid success at all costs" was about, since success brings requirements and restrictions which often impede experimentation
23:44:24 <johnw> one of the things that makes Haskell so awesome is that it's been a playground language for so long, people's minds could really run free
23:44:38 <johnw> and so some awesome solutions have evolved over time, even if some of their intermediate stages kind of sucked
23:46:35 <MercurialAlchemi> I understand your point, but I'd say that at least for some problems, we've come up with something could enough that it can be bolted on per default
23:47:12 <MercurialAlchemi> for instance, if we had some bolted-on support for Control.Lens, we wouldn't have to export each accessor manually
23:47:48 <edwardk> we're actually getting in the lead up to 7.10 thanks to adam gundry's work
23:48:04 <MercurialAlchemi> edwardk: really?
23:48:15 <edwardk> MercurialAlchemi: yes. that is sort of the goal of his whole summer of code project
23:48:56 <edwardk> basically we get field accessors that automatically upgrade themselves to (some styles of) lenses, and which you can use combinators to lift them to the rest
23:49:11 <MercurialAlchemi> edwardk: brillliant
23:49:38 <edwardk> i'm just glad he was so amenable to reworking his proposal once i started throwing curveballs his way =)
23:50:05 <MercurialAlchemi> edwardk: so you could declare data MyType = MyType { field::Foo } and get a 'field' lens for free?
23:50:56 <edwardk> field becomes overloaded and usable between different data types, and then you should be able to use it directly as an old-style data-lens, fclabels or data-accessor lens, and with a combinator as-yet-to-be-named you could turn it into a lens-style lens.
23:51:27 <edwardk> say for lack of a better name le, then you can compose foo.bar like normal or use "le bar . le foo" to get lenses out of it
23:52:07 <edwardk> they actually have to upgrade through a combinator because foo.bar has the opposite meaning/inference properties as foo.bar as lenses would
23:52:13 <thoughtpolice> TBQH, the records debate is something that has been going on for *years*, and that's not entirely without a good reason: the design space is just totally massive, and you can literally ask 10 people what they want in a record system and get 10+ answers
23:52:31 <thoughtpolice> personally i got pretty fed up with it and figured it'd never go anywhere, but Adam's proposal seemed to go over pretty well
23:52:32 <MercurialAlchemi> edwardk: I see
23:52:35 <edwardk> thoughtpolice: that is why i consider this summer's gsoc to be such a milestone
23:53:03 <edwardk> adam's original proposal struck me as a huge step backwards, but the way we've been able to steer it since strikes me as a good step forward
23:53:04 <thoughtpolice> edwardk: yes, i was also very surprised at how little controversy Adam's proposal generated, but it also had years and years of of a papertrail leading up to it
23:53:16 <thoughtpolice> (well, the final proposal he implemented anyway)
23:53:24 <thoughtpolice> it also went through a few revisions with him and SPJ, I think
23:53:41 <edwardk> especially since it can combine well with the 'exposed' stuff we've been talking about for lens, and eventually get you the multiple-lens setting thing
23:53:50 <edwardk> yeah, we basically spent the first half of the summer talking it through
23:54:05 <edwardk> which had to be endlessly frustrating for adam =)
23:54:17 <MercurialAlchemi> well, with these good news, I'm done ranting for this morning
23:54:20 <edwardk> but i think it led to the first implementable specification
23:55:08 <thoughtpolice> edwardk: yes, i agree. hopefully I'll get to work with Adam on more stuff soon :) (he's WT now as well)
23:55:16 <MercurialAlchemi> I raise my empty cup of tea to the future, a future with lenses and safe exceptions
23:58:49 <johnw> edwardk: I finally needed Proxy in anger today
23:59:04 <edwardk> fun
23:59:13 <edwardk> did you see the new article?
23:59:16 <hvr> edwardk: just wondering: do you have experience in writing manual `Data` instances?
23:59:22 * edwardk continues to backlog poor johnw
23:59:26 <johnw> con folds?
23:59:27 <edwardk> hvr: yes
23:59:28 <johnw> on folds?
23:59:35 <johnw> yeah, it's all in my queue
23:59:40 <edwardk> johnw: the conquering folds one yeah
23:59:48 <hvr> edwardk: ...would you mind writing one for Data.Version, to put in base/Data/Data.hs ? :-)
23:59:56 <johnw> the new evernote web clipper can't clip that article, which is odd
