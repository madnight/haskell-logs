00:00:13 <tikhon> normal order evaluates under lambdas, I believe
00:00:41 <tikhon> it isn't really used in practice
00:01:22 <shachaf> But maybe you're concerned with strict vs. non-strict semantics?
00:02:08 <shachaf> Applicative-order, call-by-value, etc. are implementations of strict semantics. Normal-order, call by name, lazy, etc. are implementations of non-strict semantics.
00:02:24 <rishi_> Yes, I believe so.
00:02:49 <rishi_> I'm not sure I understand the benefits of strict evaluation
00:03:02 <shachaf> Well, if you're a mathematician, non-strict evaluation is probably better.
00:03:19 <tikhon> if you care about performance, you might like strict evaluation more
00:03:30 <shachaf> Everything that evaluates to some value with strict evaluation evaluates evaluates to the same value with non-strict evaluation.
00:04:00 <tikhon> also, every single popular language aside from Haskell is basically strict
00:04:33 <tikhon> if you allow side-effects when an expression gets evaluated, you want to be strict
00:05:10 <tikhon> and—what a coincidence—every single popular language aside from Haskell has rampant side-effects
00:06:52 <dmj`> dissipate_: The language itself allows for the expression of algebraic structure like monads and functors. I wouldn't say category theory can be used to extend haskell though, moreso mathematics I'd assume. IO as a monad seemed like a good design choice though.
00:08:18 <dmj`> shachaf: correct me if I'm wrong
00:09:30 <arkeet> analogy:
00:09:37 <arkeet> I wouldn't try to teach category theory to someone who is learning linear algebra.
00:10:02 <shachaf> arkeet: But I was going to learn linear algebra. :-(
00:10:09 <tikhon> I'd try to convince them to learn Haskell instead
00:10:23 <arkeet> shachaf: :-(
00:10:26 <tikhon> I figure everything else is pointless without a nice dose of functional programming :)
00:10:27 <arkeet> guess you're out of luck
00:10:52 <shachaf> arkeet: What if I learn about linear logic?
00:10:58 <arkeet> I don't know!
00:11:00 <shachaf> I hear that, like, comonoids and stuff, man.
00:11:01 <arkeet> I don't know linear logic.
00:11:13 <tikhon> linear types seem fun
00:11:31 <arkeet> are linear types subsumed by dependent types?
00:11:37 <shachaf> class Comonoid w where comempty :: w -> (); comappend :: w -> (w,w)
00:11:59 <shachaf> arkeet: How does that work?
00:12:02 <levi> You learn to generalize algebraic concepts to Fields in Linear Algebra, which is one step further towards the extreme generalization of category theory.
00:12:05 <arkeet> how does what work?
00:12:17 <shachaf> subsuming
00:12:23 <arkeet> shachaf: I don't know!
00:12:56 <shachaf> arkeet: You should work out laws for class Functor m => Monad m where monad :: Free m a -> m a
00:13:04 <arkeet> shachaf: I thought that was your job?
00:13:27 <shachaf> I have another job now.
00:13:38 <jfischoff> yeah what's up with that ;)
00:13:41 <arkeet> anyway, I thought the laws were monad makes m a free monad monad algebra.
00:13:49 <arkeet> makes `m` a
00:14:47 <shachaf> Hmm, that sounds like a nice law.
00:15:12 <shachaf> Let's see what it would mean.
00:15:16 <arkeet> (the free monad monad being a monad on the category of endofunctors.)
00:15:46 <arkeet> the worst thing about that sentence is that it is meaningful.
00:15:55 <shachaf> I guess you mean a T-algebra, not an F-algebra?
00:16:15 <shachaf> You should call T-algebras "monad algebras" to distinguish them from the other kind.
00:16:17 <arkeet> it's an algebra for the "free monad
00:16:19 <arkeet> I did.
00:16:25 <arkeet> that's why I said free monad monad algebra, not free monad algebra.
00:16:38 <shachaf> Ah.
00:17:00 <shachaf> What do the laws work out to?
00:17:12 <arkeet> I don't know. there are some commutative diagrams.
00:17:20 <akegalj> what's the name of function in Prelude which [1,1,1,2,2,2,1,1] -> [1,2,1] ?
00:17:21 <arkeet> just instantiate them for the free monad monad.
00:17:23 <shachaf> Yes, but it's past midnight.
00:17:29 <arkeet> akegalj: map head . group
00:17:40 <arkeet> (that's 4 functions in Prelude, but whatever)
00:17:44 <akegalj> arkeet: thanks :)
00:18:30 * hackagebot crypto-cipher-types 0.0.5 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.5 (VincentHanquez)
00:18:33 * arkeet prefers the version where head and group are from Data.List.NonEmpty
00:18:59 <shachaf> arkeet: That's the great thing about unqualified names.
00:19:00 <arkeet> (not map, though)
00:19:03 <arkeet> shachaf: :)
00:19:55 <arkeet> shachaf: and of course, don't forget the law "monad is a natural transformation"
00:20:19 <Hafydd> what's the name of function in Prelude with [1,1] -> [1,2,1] -> [1,3,3,1] -> [1,4,6,4,1] -> ...?
00:20:35 <arkeet> that would be more than 4 functions, I reckon.
00:20:46 <tikhon> that's just Pascal's triangle, isn't it?
00:20:48 <shachaf> arkeet: Oh, so the reason I was asking about monoids being monads was to see where the monoid laws come from.
00:20:56 <shachaf> When you have an adjunction.
00:21:09 <shachaf> Since one of the monad laws is a naturality law so I wanted to figure out what naturality would be in the first place.
00:21:12 <shachaf> And so on.
00:21:15 <arkeet> shachaf: but a monoid is just a 2-category with one 1-cell.
00:21:48 <arkeet> where naturality is trivial, or something.
00:21:54 <Hafydd> > (\xs -> zipWith (+) (0 : xs) (xs ++ [0])) [1,3,3,1]
00:21:56 <lambdabot>   [1,4,6,4,1]
00:21:56 <arkeet> I don't know.
00:22:22 <arkeet> > iterate (\xs -> zipWith (+) (0 : xs) (xs ++ [0])) []
00:22:23 <lambdabot>   [[],[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[...
00:22:26 <arkeet> aw.
00:22:27 <arkeet> > iterate (\xs -> zipWith (+) (0 : xs) (xs ++ [0])) [1]
00:22:28 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
00:23:24 * arkeet imagines there ought to be some log-time recursive way to calculate binomial coefficients, by vague analogy with exponentiation by squaring
00:25:33 <jfischoff> has anyone messed with a type like this: newtype FixRef s f = FixRef (STRef s (f (FixRef s f)))?
00:25:45 <jfischoff> sort of a mutable Fix
00:26:13 <shachaf> Sounds fishy.
00:26:22 <tikhon> hmm, could you express that with normal Fix?
00:26:33 <shachaf> Since it's not a functor.
00:26:48 <jfischoff> type FreeF f a = f :+: K a; type Free' s f a = FixRef s (FreeF f a)
00:27:14 <jfischoff> then I can do efficient substitution
00:27:22 <shachaf> Free' f is also not a Functor.
00:29:02 <arkeet> I only see kind errors.
00:29:20 <arkeet> hm.
00:29:23 <jfischoff> where?
00:29:24 <arkeet> I'm bad at kind inference, probably.
00:30:15 <jfischoff> I feel like there should be some representation of a free monad that allows for efficient substitution
00:30:51 <arkeet> what do free monads have to do with substitution?
00:31:40 <jfischoff> you can use monads to do variable substitution
00:38:35 * hackagebot hspec 1.7.2.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.7.2.1 (SimonHengel)
00:41:09 <joelteon> anybody happen to know if there's an aptitude package for hlint?
00:41:10 <joelteon> and what it's called
00:41:13 <joelteon> if one exists
00:41:17 <joelteon> and what version it is
00:41:29 <johnw> you can't find it with apt-cache search?
00:41:33 <tikhon> you can install it with cabal, you know
00:41:33 <hvr> aptitude?
00:41:47 <joelteon> tikhon: it requires src-exts which takes like 2 minutes to install
00:41:52 <joelteon> and these test runs are pretty slow anyway
00:41:56 <joelteon> and I don't have apt-cache because this is OSX
00:42:03 <hvr> fwiw, here's a .deb package for ubuntu: Filename: pool/universe/h/hlint/hlint_1.8.43-1_amd64.deb
00:42:06 <leroux> joelteon: brew search ?
00:42:11 <johnw> aptitude on Mac?
00:42:13 <johnw> never heard of that
00:42:15 <tikhon> woah, using aptitude on a mac?
00:42:16 <joelteon> leroux: my CI builds run on an ubuntu box
00:42:28 <arkeet> your ubuntu box might have apt-cache
00:42:28 <tikhon> can you run apt-cache on that box?
00:42:29 <leroux> Ahh, that makes more sense.
00:42:35 <joelteon> i don't have SSH access to it, it's travis-ci
00:42:41 <tikhon> ah
00:42:42 <joelteon> boy i should've clarified all this a lot earlier
00:42:47 <tikhon> probably :)
00:42:57 <arkeet> ah, that would explain why 2 minutes matters.
00:43:00 <johnw> yeah, just a bit :)
00:52:35 <Ikarus> Is there a clean and easy way to "invert" the outcome of something that returns Bool
00:53:10 <Iceland_jack> Ikarus: Do you mean True ↦ False, False ↦ True? not?
00:53:51 <Ikarus> Iceland_jack: okay, I am going to commit a sin, as I would in many C-like languages, !f
00:54:06 <tikhon> @ty not
00:54:07 <lambdabot> Bool -> Bool
00:54:19 <Iceland_jack> Ikarus: Depending on your purpose that may not be what you want, what are you trying to do?
00:54:24 <tikhon> and if you have a function, you could do (not .)
00:54:27 <tikhon> @ty (not .)
00:54:28 <lambdabot> (a -> Bool) -> a -> Bool
00:54:38 <Ikarus> tikhon: ah, that is more what I want :)
00:54:59 <joelteon> :t ((not .) .)
00:54:59 <lambdabot> (a -> a1 -> Bool) -> a -> a1 -> Bool
00:55:41 * Iceland_jack has a feeling Ikarus is doing something wrong
00:56:11 <Ikarus> Iceland_jack: oh, I know I am, but let me break stuff, I need to learn
00:56:44 <Iceland_jack> Do that :)
01:56:31 <anakreon> I have this tree definition data CDef p = P p | T [CDef p] | S [CDef p] where P is a leaf and T and S are two different node types. I want to store simple lenses in the leafs (e.g Lens' a1 b, Lens' a2 b, ...). All get methods return the same type. Any advice on how to achieve this?
01:58:21 * arkeet is confused. a tree of lenses?
01:58:56 <anakreon> I think a starting point is the paper by O. Kiselyov on "Strongly typed heterogeneous collections"
01:59:30 <anakreon> Yes, a tree of setter and getter functions
02:01:15 <anakreon> Do you know what e and l stand for in that paper in "data HCons e l = HCons e l"?
02:04:17 <quicksilver> anakreon: if they have unknown/varying source types a1 a2 how will you use it?
02:04:39 <quicksilver> you could easily enough abstract over the a1 and store that but, that would be useless.
02:05:25 <quicksilver> data SomeLens b = forall a1 . MkSL (Lens' a1 b) -- probably useless
02:06:49 <anakreon> I just need to process the tree.
02:07:41 <quicksilver> that's not enough of an answer I'm afraid
02:07:46 <quicksilver> what kind of processing?
02:11:17 <anakreon> The idea is still vogue for me as well.
02:17:47 <quicksilver> anakreon: ok, well there isn't a general answer to your question. (Except 'yes you can'). The correct way to apply type discipline to your problem depends on how you need to be able to use that structure.
02:24:53 <anakreon> quicksilver: This declaration typechecks: "type SomeLens b = forall a1 . Lens' a1 b" and data CDef p = P (SomeLens p) | .. with RankNTypes extension.
02:25:10 <quicksilver> yes, it does.
02:25:16 <quicksilver> as I remarked it's probably useless
02:25:20 <quicksilver> but it certainly works.
02:38:49 * hackagebot bdo 1.0.1 - Update CSS in the browser without reloading the page.  http://hackage.haskell.org/package/bdo-1.0.1 (ChrisDone)
02:53:53 <adnap> Is there a command in GHCI to print the source of a function defined by let in GHCI?
02:54:04 <merijn> adnap: nope
02:57:30 * adnap cue sad trombone
02:58:28 * Kinnison only tends to use ghci to explore code written in a file.  Using it to define new code seems risky -- you might lose it more easily.
02:59:49 <merijn> Yeah, not to mention editing in ghci is rather annoying
03:00:40 <adnap> I was experimenting and I got carried away!
03:00:56 <Kinnison> hehe
03:01:06 <Kinnison> Your history or scrollback might help :-)
03:01:07 <donri> adnap: C-r let nameoffunction
03:01:08 <adnap> GHCI should just make a temporary module when you define stuff
03:02:23 * merijn just permanently has a text file + ghci loading it open for experimentation
03:03:10 <donri> also ghci has :e[dit]
03:03:55 * hackagebot diagrams-builder 0.4.0.4 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.0.4 (BrentYorgey)
03:05:38 <donri> ...which a also :reloads it if loaded
03:29:11 <kuribas> I use emacs and c-c c-l, it works well with ghci.
03:32:29 <amgarching> Hi. Haskellers are know for abstract thinking. There is an fmap that takes a tree and produces a tree of the same shape given a function f: number -> number. There is differentiation that takes a tree and produces a tree of the same shape given a function f: tree -> number. Compare the overall structure of fmap and dd here http://pastebin.com/uRrFpYGh Arent these two somehow related? I have a feeling of re-inventing a wheel here.
03:32:34 <mauke> The paste uRrFpYGh has been copied to http://lpaste.net/92844
03:35:08 <merijn> amgarching: tbh I can't really tell what dd is doing
03:36:36 <int-e> but they're both folds.
03:36:56 <merijn> int-e: I figured it was probably a fold, yeah
03:39:07 <merijn> oh, g is being fmapped and f is the merge that combines leaves together?
03:39:15 <amgarching> (ddd f x), which is partially appplied dd, differentiates f :: Tree -> Double with respect all tree elements. Derivatives are returned as a Tree of the same shape.
03:39:18 <merijn> Except
03:39:27 <merijn> Why is the terminal case then "g f x"?
03:40:01 * merijn is confused
03:40:18 <amgarching> g takes a function of a single argument and differentiates it at a point, for example.
03:41:47 <amgarching> fold translates a Tree to anything. Here the shapes of the in/out Trees are the same
03:42:06 <amgarching> so it is too general an opertion.
03:44:42 <int-e> Oh no, dd is not easily expressed as a fold; the accumulated g argument spoils the structure.
03:45:28 <Cale> int-e: wait, is g accumulated?
03:45:34 <int-e> how can you apply f to a cons?
03:45:44 <int-e> Cale: along spines. not over the tree.
03:46:19 <amgarching> g isnt an accumulator. It is the constant input. In the example below (g f x) is specialized to a procedure of numerically differentiaing f(x) at x.
03:46:52 <amgarching> f :: Tree -> Double
03:47:30 <amgarching> Tree is represented as nested lists (cons cells).
03:48:02 <int-e> Cale, amgarching: I'm mixing up f and g.
03:48:34 <amgarching> The terminal case f :: Double -> Double can be differentiated by "usual means". That is what g is doing.
03:49:20 <Cale> This kind of abuse of weakly-typed lists as trees makes me feel uneasy
03:49:36 <int-e> how does (lambda (x) (f (cons x t)))  work? How can f be applied to a pair?
03:49:36 <Cale> I want to replace this with a proper tree type so that I can see what's going on
03:49:51 <merijn> Cale: Yeah, that was my thought too
03:50:02 * merijn still has a hard time figuring out what dd is doing exactly
03:51:08 <amgarching> Original x ,where f(x) is differentiated, is also a pair in this case. This lambda makes a different pair and applies f, which is legal.
03:58:29 <Cale> Heh, the fact that we're consing together the results of two recursive applications of dd there is probably what makes it most confusing to Haskell programmers -- it has the appearance of a type error ;)
04:00:43 <int-e> ok, so dd is polymorphic, something like   dd :: (Diff t a) => (a -> b) -> (t a -> a) -> t a -> t b, and the pair case defines an implementation instance (Diff h a, Diff t a) => Diff (h,t) a.
04:01:18 <int-e> (the 't' in Diff t a represents a tuple of elements of type a)
04:02:01 <quicksilver> if 't' is a type of kind * -> *
04:02:10 <quicksilver> then how is (h,t) well formed?
04:02:16 * quicksilver may have missed some context here
04:02:32 <int-e> err, the first argument should have type ((a -> a) -> b).
04:02:47 <hpaste> Cale pasted “Haskell version (typechecks)” at http://lpaste.net/92845
04:03:06 <Cale> lol, that hlint
04:09:05 <int-e> quicksilver: http://lpaste.net/92846
04:09:22 <int-e> quicksilver: you were right about (h,t) not being well-formed, of course.
04:09:57 <int-e> or well-kinded, really.
04:12:35 <quicksilver> int-e: ah. You wanted a higher-kinded (,)
04:12:39 <quicksilver> and, indeed, you wrote one.
04:13:09 <Cale> Okay, so hmm, this doesn't appear to be a straightforward catamorphism of this Tree type that I defined.
04:13:45 <Cale> It might be expressible somehow as a function-producing one...
04:15:15 <hpaste> Cale revised “Haskell version (typechecks)”: “Haskell version of dd + foldTree” at http://lpaste.net/92845
04:16:40 <kuribas> amgarching: This is for differentiating polynomials?
04:17:10 <int-e> it's for finding partial derivatives given a function that produces derivatives for single variable functions
04:17:32 <Cale> It's easy to write fmap with foldTree though.
04:17:56 <amgarching> for differentiating a function of arbitrary many arguments structured as nested lists, kuribas
04:17:57 <Cale> fmap f = foldTree Nil f Pair
04:18:56 * hackagebot crypto-cipher-tests 0.0.5 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.5 (VincentHanquez)
04:21:26 <amgarching> at the beginning I though of converting a tree of numbers into a tree of lambdas, Tree Double -> Tree (Double -> Tree Double), where each lambda takes a single argument and returns a Tree with that number at the proper position. I guess you call that "lenses" or similar.
04:23:11 <Cale> oh, I suppose it might be more consistent for my dd to produce Atom (g f x) in the Atom case
04:25:22 <Cale> dd :: ((Tree a -> t) -> a -> b) -> (Tree a -> t) -> Tree a -> Tree b
04:25:25 <Cale> then
04:26:00 <Cale> What type is t expected to be?
04:26:53 <Cale> hm!
04:27:05 <amgarching> f :: Tree Double -> Double, I think
04:27:19 <Cale> ah, okay
04:27:26 <kuribas> amgarching: Are you calculating the jacobian of a multivalued function?
04:28:11 <amgarching> the function is singe-valued so far. So just partial derivatives.
04:28:46 <amgarching> single-valued but *multivariate*
04:30:17 <amgarching> Jacobian (as a matrix) is more appropriate for multivalued multivariate functions, I think.
04:30:24 <Cale> So, eliminating g and replacing it with (,) then gives dd :: (Tree a -> t) -> Tree a -> Tree (Tree a -> t, a)
04:30:42 <Cale> and moreover, the second component of the pairs will always be the element which was there in the original tree
04:30:48 <Cale> so maybe we should eliminate that too...
04:33:00 <Chawitsch> Hey guys, could you help me with something? I'm learning Haskell from LYAH and reached the part that talks about the State Monad. While I was writing some really basic code that works on list based stacks to test my knowledge I realized that I couldn't figure out why this piece of code works: runState (pop >>= return pop) [1..5].
04:33:08 <Chawitsch> When I use >> everything is clear as the value from the first pop is simply ignored, but I don't understand what happens exactly when I use the >>= function this way. It expects a function as its second argument, but the result of return in the Monad instance for State is a function wrapped in State. How does that work in this case?
04:33:43 <Cale> Chawitsch: Well, it must not be a State computation then!
04:34:08 <Cale> Chawitsch: If the second argument to >>= must be a function, then the return had better be the return for the function monad :)
04:35:04 <Chawitsch> Hmm, shouldn't everything belong to the same monad when I use function from the Monad class? I thought that was the case.
04:35:10 <Cale> i.e. instance Monad ((->) e) where return x v = x; (x >>= f) v = f (x v) v
04:35:35 <Chawitsch> It would make perfect sense to me if return in this case would be the return from the function monad. :)
04:35:48 <Chawitsch> I just thought that's not possible.
04:36:09 <Cale> Well, it'll be whatever return its type demands it to be
04:36:32 <Cale> and so if you put it in a context which needs a function, it'll have to be producing a function, so that's the instance which will be selected
04:36:58 <amgarching> dd :: (Tree a -> t) -> Tree a -> Tree (a -> t, a), would be a list/tree of univariate lambdas paired with inital values. Also nice.
04:37:38 <Cale> amgarching: I haven't gotten that far yet :)
04:38:09 <Chawitsch> Alright, thanks Cale.
04:38:41 <Cale> Chawitsch: for reference, you probably shouldn't abuse the function monad like that -- it still *is* confusing to see that code :)
04:39:24 <Chawitsch> Yeah, I know, that's probably the reason I got confused as well. :)
04:40:25 <Chawitsch> LYAH sticks to the do notation, but I wanted to make sure I understand how to use >>= as well.
04:40:53 <merijn> Chawitsch: Smart, I support that approach :)
04:41:04 <Chawitsch> pop >> pop is much simpler though. :)
04:41:12 <Cale> @free dd :: Tree (Tree a -> t) -> Tree a -> Tree (Tree a -> t)
04:41:12 <lambdabot> (forall h. (forall k p. g . k = p . $map_Tree f                        =>                         h k = p)           =>            $map_Tree h x = y) => (forall f1 f2. g . f1 = f2 . $map_Tree f
04:41:12 <lambdabot>          =>                q f1 = f2) => $map_Tree q (dd x z) = dd y ($map_Tree f z)
04:41:17 <Cale> heh
04:41:52 <merijn> Chawitsch: As Cale pointed out, which monad is used for a function like return or >>= depends on the type inferred for it
04:42:31 <merijn> > return 3 $ 5 -- Chawitsch: It's inferred here that the result of "return 3" must be a function type, as it is applied to 5, so it uses the return of the function monad
04:42:32 <lambdabot>   3
04:42:59 <Cale> That free theorem is a barrel of monkeys
04:43:39 <merijn> Cale: Funny, but flinging slightly too much poo?
04:43:57 <quicksilver> I think Cale meant "illegal to import into the USA"
04:44:10 <Cale> I meant all of these things
04:44:29 <Cale> hmm
04:44:47 <donri> alternatively you could say which function you get when you type return or >>= depends on the type
04:45:19 <kuribas> amgarching: What does your tree represent?  A single multivariate function?
04:45:55 <Chawitsch> So just to makes sure I understand things. When I use return and give it a function, then it will be the return from the function monad. If I use return this way on the right side of >>= when the left side is a stateful computation, then "return someFunction" must give back a State as well. Is that right?
04:45:56 <Cale> Chawitsch: It's also worth noting that this is nothing special about monads, it's just how type classes work -- you get the same context-dependent behaviour from 'read', for example.
04:46:03 <Cale> > read "123" + 5
04:46:04 <lambdabot>   128
04:46:19 <Cale> > read "[123,456]" ++ [789]
04:46:21 <lambdabot>   [123,456,789]
04:47:37 <donri> a bit like methods on an object, except it can depend on any variable type like the return value
04:47:37 <Cale> (but it is a reason that monads tend not to be a useful abstraction in most other programming languages, because obtaining this kind of type-dependent polymorphism is usually hard)
04:48:46 <merijn> :t (>>=)
04:48:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:49:06 <merijn> Chawitsch: As you see, the right hand side of >>= is a *function* that returns a value of type "m b"
04:49:33 <merijn> Chawitsch: So if the left hand side (m a) is "State Int Char" then the right hand side must be "Char -> State Int b"
04:49:59 <kuribas> :t \a b -> a >>= return b
04:50:00 <lambdabot> Monad m => m a -> m b -> m b
04:50:32 <merijn> Chawitsch: iow, if you have "return whatever" on the right hand side of ">>=" type inference will see "oh, the right hand side needs a function, so 'return' must result in a function, which can only happen if this is the return of the function monad"
04:50:43 <Chawitsch> I think I understand now. The implementation of >>= in the State monad applies the value from the first computation to the right hand side, therefore if I use return there like I did in my example it has to return a function.
04:50:56 <hpaste> int-e annotated “Haskell version (typechecks)” with “Haskell version (fold)” at http://lpaste.net/92845#a92849
04:51:12 <merijn> Chawitsch: Correct
04:51:45 <int-e> Cale: so it's a function producing fold (and I wasted way too much time on it.)
04:51:55 <merijn> Chawitsch: The same happens in my example of "(return 3) 5"
04:53:31 <Chawitsch> Alright, thanks guys for clearing things up for me. :)
04:56:15 <Cale> int-e: Well done!
04:56:33 <Cale> int-e: Now let's see the proof of equivalence! ;)
04:56:58 <Cale> (no, I'm pretty sure I believe it, supposing that this typechecks)
04:59:58 <veryrandomname> I'm using GHC.Generics to automatically derive new instances for a class  I made. When I try to automatically derive something like Double and  Int the compiler accepts, but I get <<loop>> on program  start. As a generic instance I'd like interpolerate d a b = b and I think I've done that, can somebody point me to the mistake? https://gist.github.com/veryrandomname/6522529
05:00:50 <Cale> btw, are you sure you aren't looking for the word "interpolate"?
05:01:08 <veryrandomname> fuu
05:02:28 <veryrandomname> I'm probably expecting too much work from others with this question, right?
05:03:13 <Hugh> hello - please can someone point me to an article or tutorial etc about the build process in haskell. specifically, what .hi files are and how linking works? thanks
05:03:24 <Cale> veryrandomname: Well, hmm -- you're saying that this module here loops?
05:03:39 <Hugh> I am a little confused as to the role cabal plays in all this...
05:03:48 <Cale> veryrandomname: What's your main?
05:04:30 <veryrandomname> Cale: oh you think the main would be responsible? I can send upload it, but I'm pretty sure the generic derivation is the problem
05:04:49 <dcoutts> Hugh: familiar with gcc + make ?  the analogy is ghc + cabal. The .o and .hi files are related to the compiler, and then cabal just manages where files go, dependencies etc
05:04:54 <Cale> veryrandomname: It might be, but it's hard to see where the loop is if I don't know how to reproduce it :P
05:05:20 <veryrandomname> just try instance Interpolerate Int
05:05:43 <dcoutts> Hugh: or perhaps more accurately, cabal has equivalent features to ./configure + make + make install, plus some automation for installing dependencies
05:05:57 <veryrandomname> Cale: oh wait you're right. instance Interpolerate Int will work, but if you try to actually use the function it will loop
05:06:07 <Hugh> yes, thanks that is clear. So the .hi files are 'headers' and the .o files are binaries?
05:06:59 <veryrandomname>  Cale: I'll set something up, but let me first change Interpolerate to Interpolate^^
05:07:03 <Cale> veryrandomname: I'm just saying, if you want help with stuff, it's generally more helpful to give a module which can be compiled (or which at least evokes the compile errors you're having trouble with) :)
05:07:21 <veryrandomname> Cale: I'll do that
05:07:58 <nh2> Hugh: close, but .hi files are not written by the programmer as compared to .h files, and do more. Try running `ghc --show-iface` on one
05:08:18 <Cale> veryrandomname: The instance you have for Int works for me
05:08:45 <veryrandomname> Cale: yeah sure, but try the generic derivation
05:09:09 <Hugh> @nh2 wow there is a bunch of stuff there!
05:09:10 <lambdabot> Maybe you meant: thx ghc
05:09:19 <nh2> Hugh: they specify types, dependencies (for checking and compilation avoidance), inlinings (for cross-module code inlining -> performance) and a few other things
05:09:30 <kuribas> Can I see which function definitions are in the interface file?
05:09:39 <Hugh> (btw, on this chanel how does one reply to another person specifically?)
05:09:52 <nh2> kuribas: yes, also ghc --show-iface
05:10:23 <Hugh> so to clarify, doing a standard ghc on a single .hs file will produce a single .hi and a single .o file?
05:10:24 <nh2> Hugh: just mention their name in the text, like "Hugh: .."
05:10:33 <Hugh> nh2 got it
05:10:42 <Hugh> nh2: got it
05:11:11 <nh2> Hugh: yes, that's what it will typically produce
05:11:15 <kuribas> nh2: I don't see any function definitions, only types.  Does it mean ghc doesn't inline any definition?
05:12:14 <Hugh> nh2 thanks for your help on this one!
05:12:16 <Cale> ghci> to $ ginterpolerate 0.4 (from $ Just (20 :: Int)) (from $ Just (50 :: Int)) :: Maybe Int
05:12:16 <Cale> Just 32
05:12:22 <Cale> veryrandomname: Well, that much worked
05:12:49 <nh2> kuribas: If ghc inlines functions inside your module, that won't be reflected in the interface file, but if ghc thinks a function might be useful to be inlined in *another* module, it will put the code (core form of it) into the interface file. You have to compile with -O or -O2 for that
05:13:36 <nh2> Hugh: if you want to learn more about the build process with ghc only or with cabal, you can pass a -v to both of them; you can get more output with -v3
05:13:57 <veryrandomname> Cale: ok you misunderstood me. just wait a sec, I'll upload a file
05:15:34 <exFalso> Hi, is there a way to use hxt with a ByteString input html?
05:15:52 <donri> exFalso: decode it to text and unpack it to string :p
05:16:14 <exFalso> donri: sounds... efficient
05:16:21 <donri> nope
05:16:51 <donri> exFalso: hxt isn't very efficient anyway, might want to look at hexpat or xml-conduit
05:16:56 <Cale> HXT is a bit older than ByteString
05:16:57 <exFalso> hxt has really nice features and its so weird that it needs a String input
05:17:09 <kuribas> nh2: Thanks, I didn't know this.
05:17:10 <donri> agreed
05:17:21 <veryrandomname> Cale: try this https://gist.github.com/veryrandomname/6522738
05:17:31 <exFalso> donri: will look into xml-conduit, ty
05:17:52 <Cale> I can also vouch for the usability of hexpat-pickle
05:18:15 <donri> i prefer xml-picklers
05:18:23 <Cale> veryrandomname: oh
05:18:27 <Cale> er...
05:18:28 <nh2> exFalso: "haskell has really nice features so it's weird that it has string as a default datatype, duplicate elimination takes n² and it stack overflows on large input" :P
05:18:57 * hackagebot http-conduit 1.9.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.5 (MichaelSnoyman)
05:19:16 <merijn> exFalso: I have a good experience with html-conduit for dealing with HTML
05:19:25 <Cale> I like String as a default.
05:19:37 <Cale> It's good for many many small programs.
05:19:38 <merijn> exFalso: It plays very nicely with http-coduit too, giving you an easy way to fetch documents
05:19:43 <Cale> and it's reasonably easy to work with
05:19:56 <nh2> exFalso: just mind that the input might not be wellformed ... depending on the purpose
05:19:57 <merijn> exFalso: (html-conduit is essentially the html variation of xml-conduit, the API is mostly the same)
05:20:04 <Cale> The other two are strawmen :)
05:20:41 <kuribas> hackage doesn't like -O2.  Is there any reason not to use it?
05:20:45 <donri> string is nice in the same way lazy io is nice: sort of beautiful in theory, often awful in practice :p
05:21:00 <donri> kuribas: slower compilation
05:21:05 <merijn> kuribas: Not really, it might increase compile time a bit
05:21:11 <merijn> kuribas: That's about it
05:21:28 <nh2> Cale: never would I dare employing such! :D
05:22:11 <nh2> kuribas: often -O2 does not help you much over O
05:22:26 <exFalso> merijn: thanks, my use case is scraping that's why i liked the hxt arrows
05:23:00 <donri> exFalso: hxt doesn't really need to be an arrow though
05:24:34 <beaky> hello
05:24:44 <beaky> how to do for loop in haskel
05:24:58 <beaky> ah forM_
05:24:58 <merijn> exFalso: ok, then definitely check out http-conduit and html-conduit together
05:25:34 <kuribas> I also find that -Wall gives a lot of garbage.
05:25:35 <donri> exFalso: but, hxt can handle the http side for you too with hxt-{http,curl} (and you can speed it up a bit with hxt-hexpat)
05:26:15 <nh2> kuribas: -Wall is great. You should always use it. Which output do you not like? I can convert you :)
05:26:26 <merijn> donri: Sure, but why bother if you're going to use html/xml conduit? Might as well use http-conduit then
05:26:30 <donri> -Wall is too lenient :(
05:26:42 <merijn> -Wall -Werror!
05:26:43 <donri> merijn: i meant if you're already using hxt
05:27:03 <donri> merijn: i didn't mean that it only warns, i mean that it excludes some useful warnings
05:27:08 <kuribas> For example: Warning: Defined but not used: `dmin'
05:27:22 <nh2> donri: what would you like to have more than -Wall?
05:27:33 <donri> -fwarn-tabs and -fwarn-missing-import-lists comes to mind
05:27:37 <kuribas>  Warning: Top-level binding with no type signature:
05:28:00 <donri> kuribas: why is it garbage to know that code is unused?
05:28:18 <merijn> kuribas: defined but not used == delete
05:28:31 <nh2> kuribas: look at this: https://github.com/meteficha/mtl/commit/a60fc2695c5e1bfe72e564c53b88ef266957a00d it breaks the world
05:28:54 <nh2> a simple -Wall would have immediately revealed this error
05:28:59 <merijn> donri: What's -fwarn-missing-import-lists do?
05:29:22 <kuribas> I use the variable in another definition of the function.
05:29:23 <donri> merijn: warn for open imports
05:29:36 <nh2> donri: granted
05:29:41 <merijn> donri: But <3 open imports
05:29:54 <donri> merijn: i tend to use qualified imports
05:30:10 <donri> merijn: open imports make proper PVP awful
05:30:11 <nh2> kuribas: if you want to name something that you really do not want to use, you can write an underscore in front of it: _dmin
05:30:13 <kuribas> donri: line 45 https://github.com/kuribas/cubicbezier/blob/master/Geom2D/CubicBezier/Intersection.hs
05:30:15 <merijn> I have better things to do than specify all of Control.Applicative,Control.Monad,Control.Conccurrent every time
05:30:20 <merijn> donri: Why?
05:31:01 <donri> merijn: you are allowed to add new exports without bumping the A.B, which means if you depend on A.B.* and use an open import you can get name conflicts
05:31:06 <merijn> kuribas: Use _ or _dmin instead?
05:31:35 <merijn> kuribas: Variables starting with _ don't cause unused warnings
05:31:37 <nh2> kuribas: yes, _ would be appropriate here, as it is used for the last argument
05:31:41 <kuribas> Oh, I see.
05:33:09 <merijn> donri: meh, I'd rather fix that once, should it ever happen than write out the imports every single time
05:33:24 <donri> merijn: or use qualified imports ;)
05:33:31 <donri> granted, they suck for operators
05:33:40 <merijn> donri: They suck for functions too
05:33:53 <nh2> donri: do you do it with Prelude as well? :P
05:34:05 <nh2> sb. might hide catch from the prelude
05:34:35 <kuribas> Also, do I need to specify all typesignature?  Even when it is obvious?
05:34:39 <donri> you'd love my code, all qualified imports, named like the origin package, with ' on strict modules, very few operators and parenthesis preferred over ($) ;)
05:34:46 <merijn> kuribas: And as far as the "top level binding with no signature" I'm a firm believer that top level definitions should always have type signatures
05:35:12 <donri> also i avoid layout alignment, only indenting
05:35:32 <merijn> kuribas: Define obvious? I just looked at findOuter and aside from the 2nd argument being a list, I have no clue what it's type is
05:35:55 <nh2> kuribas: yes, top level functions with type signatures is great for defining your api, like you do in a .h file as well. Due to type inference, many things are not obvious, e.g. x = 1 can have all kinds of types
05:36:11 <donri> nh2: i do it with prelude if i would otherwise need a "hiding"
05:36:22 <donri> and i don't "as" it ;)
05:36:38 <beaky> how do you bubble sort a list in haskell
05:36:46 <merijn> kuribas: Or, for example, what the type of 'd' in intersectPt is
05:36:47 <kuribas> I see...
05:37:05 <kuribas> Double
05:37:22 <merijn> kuribas: Try looking at this code 3 years from now and see if you remember ;)
05:37:37 <nh2> beaky: use e.g. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:insert if you don't want to implement that yourself
05:37:38 <kuribas> That's a good point :)
05:37:54 <beaky> ah
05:37:55 <merijn> kuribas: I could find out that it's Double, by looking up the definition of Point, but I'm lazy. It'd be much nicer if it said right there what it was
05:37:57 <beaky> thanks
05:39:01 <quchen> You don't bubblesort in Haskell. :-s
05:39:06 <merijn> kuribas: Usually if I'm exploring a haskell codebase I'll be looking at the types and not so much at the actual code.
05:39:33 <quchen> Bubblesort is used only because it's super simple to implement and the algorithm is easy to understand. Both of these are done better by Haskell's list quicksort. :-)
05:40:17 <beaky> ah
05:40:31 <beaky> but i heard the list qsort is actually bad even though it looks very elegant
05:40:37 <donri> merijn: better still when i *do* use unqualified imports, i use import lists and *one import line per imported name*" :)
05:40:40 <donri> i'm crazy, i know
05:40:59 <quchen> You wouldn't want to use that list quicksort in production, no.
05:41:02 <merijn> donri: How are your modules not 1500 lines of imports?
05:41:08 <quchen> If you want to sort a list, use Data.List.sort.
05:41:11 <donri> merijn: because i mostly use qualified imports
05:41:21 <quchen> (List.sort is Mergesort on steroids.)
05:41:31 <nh2> donri: you should use Cucumber Haskell!
05:41:40 <quchen> nh2: Get out ;-)
05:41:58 <donri> merijn: i'm still experimenting with style though. the idea is to optimize for tool friendliness. tools are line-oriented.
05:42:26 <donri> merijn: this makes for fewer merge conflicts, and if there's an error or warning for an import it points at the *exact* imported name
05:42:49 <nh2> donri: "when I want to define the module MyModule, I better import the module Data.List, but qualified, with the beautiful short-cut name List, and I import the function foldl and also foldr and also foldl1 but I do not wish to see the function nub"
05:43:09 <quchen> donri: Speaking of explicit import lists, is there a nice way to find out where a name was defined if there is no import list? (Grep is my current approach.)
05:43:43 <quchen> (Or searching the Haddock index.)
05:43:46 <donri> quchen: yeah that's another point in favor or "proper imports". but you can use hdevtools for example to find out what ghc thinks.
05:44:14 <donri> :HdevtoolsInfo in vim gives you the ghci :info for the name under cursor, basically
05:44:38 <veryrandomname> How can I see the value of GHC.Generics.from (5::Int)? Or does somebody know what GHC.Generics representation Numbers have?
05:44:45 <nh2> quchen: how is that AMP stuff going, I'm very interested
05:45:08 <donri> veryrandomname: if you bind it to a name you can :t the name
05:45:24 <veryrandomname> donri: cool thanks!
05:45:27 <donri> veryrandomname: and it should give you the concrete type rather than the type family
05:45:48 <donri> veryrandomname: you could also use standalone deriving to derive Show for the generic representation types
05:46:06 <donri> veryrandomname: (i've proposed that for inclusion upstream, but it's not there yet)
05:48:57 <nh2> have to go, quchen I will annoy you later with my questions :)
05:51:57 <quchen> @tell nh2 Coding is finished, what's left is hoping thoughtpolice can manage my nooby patches
05:51:58 <lambdabot> Consider it noted.
05:55:32 <beaky> is archlinux the best linux distro for haskell
05:56:04 <quchen> No.
05:56:21 <shiona> My understanding is that since everyone install everything with cabal the underlying system doesn't really matter
05:56:45 <beaky> ah
05:56:47 <veryrandomname> shiona: but ghc isn't installed with cabal
05:57:57 <veryrandomname> ghc on ubuntu is probably older than ghc on arch
05:58:44 <shiona> can be, but I don't think that having one fresher package in the repositories is quite worth the extra work that is to keep arch running
06:04:06 <kuribas> Where can I find a description of the strictness annotations in the interface file?
06:05:09 <kuribas> For example:  {- Arity: 2, HasNoCafRefs, Strictness: U(LLLL)U(L)
06:06:04 <kuribas> Ok, I found it in the manual.
06:09:09 <donri> beaky: arch is bad for haskell because they prefer packaging the latest ghc over packaging a correct haskell-platform (but they still pretend to package platform, but broken)
06:09:22 <beaky> ah
06:09:26 <beaky> thats bad
06:09:38 <beaky> no wonder my haskell is always broken in arch :(
06:09:42 <merijn> donri: Linux distro's shipping a broken haskell platform? No, that can't be :p
06:10:00 <beaky> so i should use haskell on osx?
06:10:01 <donri> merijn: sarcasm?
06:10:12 <donri> it's never been broken on fedora...
06:11:17 <k00mi> beaky: are you aware of the haskell repos for arch?
06:11:22 <merijn> donri: Maybe, but the only people I ever see complain/ask questions about/have problems with broken platform tend to be on linux
06:11:28 <beaky> i never tried those repo
06:11:33 <bergmark> beaky: you could also just install the regular HP
06:11:38 <donri> merijn: yeah i think ubuntu likes to ship it broken too
06:11:43 <merijn> donri: My logical conclusion has been that them breaking it is not very rare
06:11:50 * ocharles is a happy NixOS & Haskell user
06:12:02 <beaky> nixos wow
06:12:30 <donri> merijn: although i think we might be talking about different kinds of brokenness. i mean shipping a haskell-platform package but with versions not specified for that platform version.
06:13:44 <quchen> Eh?
06:13:58 <quchen> It's a package full of things that are sort of related to the current release of the HP?
06:14:17 <donri> quchen: something like that. the same packages, but different versions.
06:14:21 <veryrandomname> donri: I've looked up haskell platform on arch. it seems all cool https://aur.archlinux.org/packages/haskell-platform/
06:14:42 <donri> veryrandomname: that's on AUR and ancient
06:15:00 <veryrandomname> donri: there isn't anything else
06:15:13 <quchen> Just compile the HP yourself (bonus points: that checks whether your build system is setup alright) and those problems seize to exist
06:15:47 <donri> veryrandomname: i could be misremembering or they stopped shipping it
06:17:10 <veryrandomname> I don't think the os is that important. all I read is that using windows + haskell is annoying, everything else seems ok.
06:18:08 <sellout-> veryrandomname: s/\+ haskell//
06:18:36 <arianvp> > map (+3) [1,2,3]
06:18:37 <lambdabot>   [4,5,6]
06:19:04 <veryrandomname> sellout-: what does 's/\+ haskell//' mean?
06:21:56 <saep1> veryrandomname: replace the literal string "+ haskell" with the empty string ""
06:22:30 <veryrandomname> saep1: oh
06:24:11 <beaky> how do I use haskell to make apps
06:24:39 <Taneb> beaky, what kind of apps?
06:25:07 <quchen> 1. You learn to program things in Haskell.
06:25:10 <donri> beaky: you export main :: IO a from a Main or unnamed module
06:25:13 <quchen> 2. You apply these skills to make apps.
06:26:04 <beaky> i want to make tetris
06:28:36 <veryrandomname> beaky: what you call app is just a program with things to see. Once you know the basics of haskell you can use sdl to make a game http://www.haskell.org/haskellwiki/SDL
06:28:47 <totte> donri: Sorry, what is wrong about the way Arch packages GHC?
06:28:56 <totte> I don't get it.
06:29:02 <donri> totte: apparently nothing currently
06:30:30 <veryrandomname> totte: there maybe was a broken haskell platform package, but now the haskell platform package is ok. nothing with ghc
06:31:06 <totte> Why is the Haskell platform package preferable to GHC on its own plus packages for Hackage packages?
06:31:32 <donri> totte: that's arguable, but it's certainly wrong to ship a haskell-platform package if it doesn't follow the "spec"
06:32:17 <donri> it might make sense for arch linux to prefer ghc over platform, though
06:34:05 <quchen> totte: I think the Haskell platform's purpose is to be a package of things you install right after GHC. It's usually available to all users (as a standard lib sbould be), and everything that depends on it is guaranteed to work without version conflicts.
06:34:30 <quchen> On the other hand, if you install packages from the HP on a per-need basis, you may find yourself in dependency hell much easier.
06:34:50 <totte> I've never used it. Is the platform a bundle of packages from Hackage?
06:34:56 <quchen> Pretty much, yes.
06:35:19 <merijn> totte: A tested, playing together nicely, stable precompiled bundle of packages, to be precise
06:37:14 <totte> Are these: https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal#L65-L100 the included packages?
06:38:10 <veryrandomname> totte: I think its only the 4 things at the top
06:38:32 <veryrandomname> totte: cabal-install alex happy haddock and ghc of cource
06:39:50 <dcoutts> totte: yes, plus the build-tools
06:40:29 <dcoutts> totte: see the comments begin/end platform packages
06:42:05 <totte> Yikes. Thanks. Guess I ought to give the platform a shot instead of compiling 20+ Hackage packages myself.
06:42:17 <statix> guys is haskell a good choice as first experience with functional programming if you only have experience with C/C++/Java?
06:43:05 <fizbin> statix: Language is less important than book/course/mentor/whatever else you're using to learn FP.
06:43:43 <statix> fizbin: I'm using the learnyouahaskell.com
06:43:54 <ocharles> statix: good choice
06:44:15 <fizbin> Okay, that's a fair enough choice. Given that, then use Haskell.
06:44:51 <fizbin> Some people find the approach in things like SICP or SIOD more to their liking; if that, then use scheme.
06:44:53 <totte> statix: I like that book.
06:45:07 <veryrandomname> statix: I started with C++ too and got very happy with haskell as my first functional programming language.
06:45:18 <quchen> SICP isn't about Scheme though.
06:45:22 <statix> good to know, thanks
06:45:36 <statix> maybe i mess with haskell for a while and try a couple of other language later on
06:45:48 <fizbin> quchen: Not directly, no. But it's written assuming that you'll be using scheme.
06:45:55 <statix> still kinda confused with this one
06:46:07 <jeff_s1> Does anyone know how to improve the performance of abs on Ints? I'm finding that it's quicker to just generate another random Int until I get a positive one than to take its absolute value.
06:46:24 <jeff_s1> Maybe inlining or specialization?
06:47:08 <ocharles> jeff_s1: you're saying that generating a bunch of random integers and picking the first > 0 is faster than calling abs?
06:47:12 <Hafydd> What do you do when you get 0?
06:47:20 <fizbin> jeff_s1: What about bitmasking?
06:47:27 <quchen> jeff_s1: The fastest thing I can think of is bitwise and on the sign bit.
06:47:38 <arianvp> Does the anology between Monads and LINQ hold well?
06:47:39 <jeff_s1> ocharles: yes
06:47:39 <quchen> If you need even more performance you'll probably need primops.
06:47:46 <jeff_s1> fizbin & quchen: Good ideas.
06:47:53 <arianvp> I need to explain a friend monads. and he knows some java and C#
06:48:06 <veryrandomname> what is it about SICP that I keep reading the name?
06:48:09 <jeff_s1> I just tried checking that x < 0 before calling abs, and that is much faster than just calling abs.
06:48:11 <arianvp> (I think it holds well, though LINQ is llimited to 'enumerable' types)
06:48:17 <ocharles> jeff_s1: what type are you taking abs on?
06:48:29 <jeff_s1> ocharles: Int (Int64 on my machine)
06:48:33 <arianvp> veryrandonname. SICP is an introductory course on programming in Scheme
06:48:41 <arianvp> it's a legendery book of 800 pages of magic
06:48:44 <arianvp> worth the read
06:48:56 <quchen> SICP is an introductory course on programming. It uses Scheme.
06:48:59 <ocharles> jeff_s1: that seems very strange as abs on Int is just a check for == 0 and otherwise negating it
06:49:02 <quchen> That way round. ^^
06:49:16 <ocharles> jeff_s1: are you sure your Int isn't actually a big thunk? how are you benchmarking this?
06:49:17 <jeff_s1> So I think this is kind of silly: why is "if x < 0 then abs x else x" faster than "abs x"?
06:49:37 <quchen> jeff_s1: s/abs x/-x
06:49:38 <arianvp> you shouldn't bother with such micro-optimisations
06:49:38 <jeff_s1> ocharles: That's worth checking. I'm just using time on the command line.
06:49:49 <fizbin> jeff_s1: What optimization settings are you passing the compiler?
06:50:11 <jeff_s1> -O3
06:50:30 <fizbin> Whoa. That should have inlined abs on Int64.
06:50:31 <Excedrin> are you sure abs isn't implemented as sqrt(x^2) ?
06:51:11 <ocharles> jeff_s1: well forec whatever you are taking abs of before benchmarking
06:51:14 <ocharles> force*
06:51:26 <ocharles> e.g, x `seq` benchmarkAbs x
06:51:45 <merijn> Excedrin: wut
06:51:53 <merijn> Excedrin: That would be the most god awful idea *ever*
06:51:56 <merijn> :t abs
06:51:57 <lambdabot> Num a => a -> a
06:52:20 <merijn> Excedrin: Also, impossible, sqrt only works on Floating and friends, Num also supports Integrals et al
06:52:20 <ocharles> merijn: well, not quite so awful on constructive reals
06:52:22 <ocharles> but still quite awful :)
06:52:23 <merijn> :t sqrt
06:52:24 <fizbin> > let x :: Int64 = minBound in abs x
06:52:24 <lambdabot> Floating a => a -> a
06:52:26 <lambdabot>   -9223372036854775808
06:52:50 <fizbin> jeff_s1: Another reason to not trust abs of a random number. ^^^
06:52:55 <merijn> > let x :: Int64 = minBound + 1 in abs x
06:52:57 <lambdabot>   9223372036854775807
06:53:15 <fizbin> Not that it's that likely, but...
06:53:20 <Excedrin> looks like it uses negateInt
06:53:52 <ocharles> I am still curious about jeff_s1's benchmarking. I have a feeling that maybe 'abs' forces its argument, whereas a hand-rolled version just produces a thunk
06:54:03 <merijn> Any Hakyll users? Does anyone know what flavour of regex it uses?
06:54:06 <ocharles> so comparing them is pointless, one is doing work, the other isn't
06:54:27 <fizbin> > let mask :: Int64 = maxBound; x :: Int64 = minBound in mask .&. x
06:54:28 <jeff_s1> The prize goes to ocharles. "x `seq` abs x" is much faster than just "abs x".
06:54:29 <lambdabot>   Ambiguous occurrence `.&.'
06:54:29 <lambdabot>  It could refer to either `Data.Bits..&.',
06:54:29 <lambdabot>      ...
06:54:31 <quchen> ocharles: For Int,  abs n  = if n `geInt` 0 then n else negate n
06:55:05 <quchen> ocharles: I don't think anything is forced "more" than "n > 0" there.
06:55:31 <fizbin> jeff_s1: You shouldn't use abs of rand for "random non-negative number" anyway though for correctness reasons.
06:55:52 <quchen> fizbin: Why's that?
06:56:03 <quchen> Counting the 0 differently?
06:56:14 <ocharles> quchen: yes, I'm aware of what the definition is
06:56:30 <ocharles> quchen: well, that could be checked in ghci
06:56:46 <fizbin> jeff_s1, quchen: Counting the zero, and the fact that (abs minBound) == minBound.
06:56:47 <ocharles> my general point is this discussion is pointless until I see proof that abs is so much slower :P
06:58:20 <fizbin> jeff_s1, quchen: Also, many people wanting a "random non-negative number" actually want "random number in the range 0 .. N" and plan to use modulo on their random non-negative number to get there, which has additional correctness issues.
06:59:17 <quchen> fizbin: Is there an easy and correct way to get such a random number then?
06:59:37 <mkramer> mersenne twister
07:00:11 <ocharles> unless you want something cryptographically secure
07:00:15 <ocharles> in which case, not mersenne twister.
07:00:59 <quchen> Not?
07:01:01 <quchen> Hm.
07:01:13 <quchen> Stop destroying all my randomnedd knowledge.
07:01:19 <quchen> s/dd/ss
07:01:46 <ocharles> https://en.wikipedia.org/wiki/Mersenne_twister#Disadvantages apparently maybe it can be made secure
07:02:54 <quchen> Oh, I was aware of the "bad initial state" problem, but not the predictability.
07:03:29 <jeff_s1> It looks like using Data.Bits to get the absolute value of an Int is the same speed as using abs.
07:03:42 <fizbin> quchen: The usual way is to do what the java j.u.Random class does: if N is a power of 2, take the appropriate number of bits off the top; else, take (random int) & (max positive int) and if that's less than N*(max positive int / N), take modulo N, otherwise choose a new random number.
07:04:11 <quchen> Stochastically terminating? Oh.
07:04:17 <quchen> I wouldn't have expected that here.
07:05:12 <fizbin> quchen: Yeah, it sucks, but fast stochastic termination is really your best bet. Also, picking N to be a power of 2 where possible.
07:06:52 <quchen> Stochastic termination isn't too bad, it's just not very elegant.
07:07:13 <quchen> This sounded like something that has an "oh wow" solution :-)
07:07:37 <kuribas> Is (_|_, _|_) equivalent to _|_?   As for as strictness is concerned?
07:07:47 <quchen> kuribas: No
07:07:54 <ocharles> jeff_s1: you still haven't posted your benchamrk anywhere
07:07:58 <quchen> > (undefined, undefined) `seq` ()
07:07:59 <lambdabot>   ()
07:08:09 <quchen> > undefined `seq` ()
07:08:12 <lambdabot>   *Exception: Prelude.undefined
07:09:06 <quchen> kuribas: At least in Haskell bottom and (bot, bot) are different. There are people here that can help you further with the logical side of things, where that distinction may be wrong.
07:09:13 <quchen> (I'm not one of them, unfortunately.)
07:09:34 <quchen> Similarly, const ⊥ /= ⊥.
07:10:09 <mr-> :t const undefined -- :-)
07:10:10 <lambdabot> b -> a
07:10:19 <jeff_s1> ocharles: I'm working on https://github.com/logicchains/Levgen-Parallel-Benchmarks
07:10:51 <quchen> :t (`seq` undefined) -- mr: use this one to avoid space leaks
07:10:52 <lambdabot> a -> b
07:11:44 * mr- greps his code for const undefined
07:11:45 <kuribas> quchen: I have a lazy function which compiles to an unboxed function by gh: "splitBezier undefined 0.5 `seq` ()" => undefined
07:12:53 <quchen> And splitBezier's return type is a tuple?
07:12:56 <kuribas> But a written out constructor on the LHS is always strict right?
07:13:15 <quchen> ..?
07:13:24 <kuribas> Ok, I am being stupid...
07:13:33 <kuribas> splitBezier (CubicBezier a b c d) t = ...
07:14:05 <kuribas> So it is strict in the first argument.
07:14:06 <quchen> Well, pattern matching will have to evaluate the first argument.
07:14:11 <quchen> Right.
07:14:22 <quchen> You can make the pattern irrefutable using ~ though in order to avoid that.
07:14:41 <kuribas> Yes, I see.
07:15:28 <kuribas> I used lazy matching to get state into a comonadic structure.  It's pretty cool.
07:16:26 <fizbin> > minBound :: Int32
07:16:28 <lambdabot>   -2147483648
07:17:40 <fizbin> > let iLogBase b i = if i < b then 1 else 1 + iLogBase b (i `div` b) in iLogBase 2147483561 30
07:17:43 <lambdabot>   1
07:19:02 * hackagebot diagrams-lib 0.7.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.7.1 (BrentYorgey)
07:24:02 * hackagebot diagrams-svg 0.8.0.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.8.0.1 (BrentYorgey)
07:25:29 <jeff_s1> So genRandomPos at https://github.com/shawjef3/Levgen-Parallel-Benchmarks/blob/master/H.hs fixes the problem of abs being lazy causing a performance problem. Thanks ocharles! Now I'm wondering why I needed to make genRandomPos using seq when I'm doing deepseq later.
07:27:54 <Taneb> Anyone know how Graphics.Rendering.Cairo.getCurrentPoint behaves if there is no current point? Throw an exception?
07:28:28 <dcoutts> Taneb: quickest answer is probably to try it and see
07:28:38 <Taneb> dcoutts, I was worrying someone might say that
07:29:50 <magneticduck> hey everybody, I've done a little bit of browsing through System.Process, but I haven't found a function that simply executes a process, waits for it to finish, and returns all of the stdout collected
07:29:55 <magneticduck> how would I do something like that?
07:30:03 <magneticduck> preferably using only things from the process package
07:30:38 <magneticduck> do I really have to deal with handles?
07:30:38 <edvo> magneticduck: readProcess
07:30:54 <magneticduck> wonderful thanks
07:31:00 <edvo> you are welcome
07:31:39 <magneticduck> uhh, why do I have to give it a filename and parameters?
07:31:50 <magneticduck> I'm actually running in this case a bit of a complex bash script
07:31:56 <magneticduck> I mean, with pipes and all
07:32:11 <magneticduck> sox out.wav -n stat 2>&1 | sed -n 's#^Length (seconds):[^0-9]*\([0-9.]*\)$#\1#p'
07:32:33 <edvo> well, it does not work with pipes
07:32:33 <geekosaur> "/bin/sh", ["-c", yourpipelinehere]
07:32:50 <geekosaur> note that it's a single parameter string
07:33:02 <magneticduck> oh ofc
07:33:04 <Taneb> dcoutts, thanks, it gives "(0, 0)"
07:33:12 <magneticduck> yes I gotcha
07:33:16 <Taneb> Which to me feels like the wrong behaviour :(
07:34:02 * hackagebot diagrams-builder 0.4.0.5 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.0.5 (BrentYorgey)
07:35:54 <yoeight_> Hi everybody. Do someone already have this weird error message 'No instance for (At (M.IntMap [Char])) arising from a use of `at'' with that expression 'IntMap.fromList [(1, "hello")] ^. at 1' ?
07:36:08 <yoeight_> when using lens package
07:36:54 <yoeight_> some setup info: ghc 7.6.3 on Arch 3.10
07:37:15 <supki> > IM.fromList [(1, "hello")] ^. at 1
07:37:18 <lambdabot>   Just "hello"
07:37:22 <supki> what lens version?
07:37:34 <yoeight_> 3.9.1
07:38:01 <supki> uhm
07:38:13 <supki> can you paste the code somewhere?
07:38:23 <ocharles> I think you might have a different version of containers loaded
07:38:36 <ocharles> lens defines an At instance for a specific version of containers (the one it was compiled against)
07:38:59 <ocharles> my guess is you have two versions of containers installed
07:39:00 <supki> shouldn't the version be in the error message then?
07:39:25 <ocharles> supki: No, yoeight_ has imported an IntMap qualified, and that one doesn't have an instance, no need to say any more there
07:39:34 <ocharles> yoeight_: what is the output of ':i At' ?
07:40:00 <yoeight_> No it's not but I both 0.5.0.0, 0.5.3.1 version installed on my machine
07:40:38 <kuribas> Are inlined arguments always lazy in ghc, even when they are obviously strict?
07:41:05 <kuribas> For example: vectorMag (Point x y) = sqrt(x*x + y*y)
07:41:09 <kuribas> x and y :: Double
07:41:14 <yoeight_> Prelude Control.Lens> :i At
07:41:14 <yoeight_> class At m where
07:41:14 <yoeight_>   at :: Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
07:41:14 <yoeight_>   	-- Defined in `Control.Lens.At'
07:42:46 <kuribas>  Strictness: U(U(L)U(L))m
07:42:53 <ocharles> yoeight_: that's not the full output. use http://lpaste.net
07:43:05 <magneticduck> rofl is "Network.CGI.Protocol" the only place where a "maybeRead" function is implemented?
07:43:18 <ocharles> magneticduck: that's in the latest base
07:43:42 <magneticduck> oh it is
07:43:43 <ocharles> magneticduck: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#v:readMaybe is what you are looking for, right?
07:43:48 <magneticduck> huh, didn't show up on hoogle
07:44:06 <ocharles> magneticduck: it's also in 'safe'
07:44:07 <magneticduck> I searched for (Read a) => String -> Maybe a
07:44:10 <magneticduck> cool
07:44:22 <ocharles> if you need to support earlier versions of base
07:44:54 <magneticduck> uh, I guess my base isn't the latest
07:46:37 <kuribas> Or does U(L) mean S for Double's ?
07:48:48 <yoeight_> ocharles actually it is, I'll make a lpaste
07:50:42 <ocharles> yoeight_: oh, so it is, my apologies. normally it shows you instances
07:50:45 <ocharles> I wonder why it isn't here
07:51:52 <yoeight_> ocharles edkmett makes it work
07:52:05 <yoeight_> someone had the answer
07:52:30 <yoeight_> just unregister last containers package makes it work
07:52:53 <yoeight_> thanks for your time guys
07:52:57 <edwardk> np
07:53:48 <ocharles> so it was multiple containers versions as I thought?
07:54:05 <ocharles> edwardk: how come :i At doesn't show all the instances?
07:54:26 <yoeight_> yes sir
07:56:20 <quchen> edwardk: Fairly basic question, why does Lens use `type` for `Getting` etc? GHC isn't very good at printing type synonyms when errors occur so newtypes would get rid of that problem. I suspect there's a good reason to use `type` then?
07:56:39 <ocharles> quchen: the whole point is to allow people to write lens stuff without depending on lens
07:56:45 <ocharles> you can't do that if you start introducing newtypes
07:56:46 <edwardk> quchen: yes, if you newtype them then all the magic subtyping that drives lens wouldn't work
07:56:49 <elliott> quchen: because it wouldn't work with newtype.
07:56:58 <elliott> you can pass a Lens and a Getter and a Traversal as a Getting
07:57:03 <elliott> because the types fit the same form
07:57:11 <edwardk> basically the whole library would be a mess of foo.asTraversal bar   or some god awful mess
07:57:12 <elliott> and you get subtyping from the constraints they place on the f and p
07:57:12 <quchen> Ah, okay.
07:57:28 <elliott> this is why we need a lens language :)
07:57:40 <edwardk> lens is definitely putting some pressure on ghc to support better type alias preservation though =)
07:57:53 <ocharles> yea, I'd love to see that happen
07:58:02 <ocharles> I'm just about able to figure things out these days
07:59:02 <elliott> lens is a pretty good argument for subtyping being a good thing.
07:59:20 <edwardk> or at least that one can reason about subtyping through class relationships
07:59:36 <beaky> why is functional programming significant
07:59:44 <beaky> apart from treating data as code
07:59:47 <beaky> code as data*
08:00:05 <quchen> @google why functional programming matters
08:00:07 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
08:00:07 <lambdabot> Title: Why Functional Programming Matters
08:01:05 <beaky> even in functional languages, I seldom use functions as a type for holding type (i.e. a substitute for records declared with 'data')
08:02:36 <Sonderblade> beaky: what is your question?
08:02:51 <beaky> what is functional programming and why is it significant
08:03:18 <magneticduck> @FAQ
08:03:19 <lambdabot> Unknown command, try @list
08:03:38 <magneticduck> uh, anyway, read the www.haskell.org website, they have an good article on that
08:03:51 <magneticduck> ask questions after reading that
08:04:00 <beaky> yes haskel.org has many cool recourses
08:04:05 <beaky> (wow i am bad at typing)
08:04:15 <magneticduck> http://www.haskell.org/haskellwiki/Introduction
08:04:19 <beaky> my typing has become worese over time
08:05:48 <beaky> wow i like the speradsheet analogy
08:08:51 <beaky> but the qsort example doesn't sit well with me :(
08:10:12 <beaky> i wonder what an actual haskell qsort looks like
08:10:52 <ericmoritz> is there an idiom to make (read) return Nothing if the parse fails?
08:11:23 <beaky> so all that functional programming offers over traditional paradigms is improved modularity due to referential transparency of pure functions and first-class functions?
08:11:44 <merijn> ericmoritz: Text.Read.readMaybe in GHC 7.6
08:11:49 <ericmoritz> thanks
08:11:56 <merijn> ericmoritz: In older versions you need to implement it using reads
08:12:06 <merijn> > reads "1" :: Int
08:12:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:12:08 <lambdabot>              with actual type ...
08:12:16 <merijn> oh, duh
08:12:22 <merijn> > reads "1" :: [(Int,String)]
08:12:24 <lambdabot>   [(1,"")]
08:12:28 <merijn> > reads "1" :: [(Char,String)]
08:12:30 <lambdabot>   []
08:12:36 <mkramer> beaky: http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
08:13:06 <mkramer> you're right beaky, Haskell examples are often sneaky in that nobody would really write things that way other than for didactic purposes
08:13:14 <merijn> ericmoritz: Although (depending on what you're doing) it might be better to switch to a proper parsing approach
08:13:17 <luite> beaky: i think it captures the characteristics of the quicksort algorithm quite nicely actually. it doesn't have worse asymptotics than a regular (not recursion-to-loop optimized) imperative implementation does it?
08:13:30 <mkramer> of course, all language pedagogy employs that dichotomy to some extent
08:13:37 <elliott> beaky: I would say that the advantage of functional programming is that <beaky> haskell achieves safety, modularity, and speed through functional programming :D
08:14:03 * hackagebot diagrams-haddock 0.2.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1 (BrentYorgey)
08:16:01 <beaky> ah
08:17:14 <beaky> so the real haskell qsort is quite imperative :D
08:17:32 <merijn> That's because quicksort is quite imperative
08:17:33 <beaky> maybe it is more accurately representing the nature of qsort as an imperative algorithm
08:17:41 <merijn> If you want a functional sort, look at merge sort
08:17:50 <luite> merijn: really? it's quite functional i think
08:18:00 <beaky> ah didn't know mergesort played nice with functional language
08:18:00 <merijn> luite: When compared to merge sort?
08:18:19 <luite> merijn: oh wait, are you referring to more optimized implementations or the simple one?
08:18:39 <beaky> but the thing I like about haskell (which might not be common to all functional language) is the expressiveness of the type system
08:19:00 <beaky> maybe its not a property unique to purely functional language though
08:19:01 <e98> does the ghc 7.8 dynlib changes imply that by default ghc will not build static executables anymore?
08:19:15 <luite> by default executables are still static
08:19:25 <luite> but the ghc programs themselves are not
08:19:30 <luite> on linux at least
08:19:35 <luite> perhaps windows not yet
08:20:09 <merijn> luite: I mean *actual* quick sort, not this example everyone trots out
08:20:15 <e98> luite: ah, does that mean in 7.6 the binaries in bin/ do run without lib/?
08:20:23 <e98> luite: to some extent 'run' I suppose
08:20:38 <merijn> luite: The filter+append recursion isn't actually quicksort, it doesn't even have the same complexity
08:21:16 <merijn> mergesort is elegant and efficient even if you have a naive functional implementation
08:21:26 <luite> merijn: where is the complexity different?
08:22:09 <luite> (other than stack usage because it doesn't optimize sorting the larger partition)
08:22:36 <merijn> luite: See the blog post earlier: http://augustss.blogspot.co.uk/2007/08/quicksort-in-haskell-quicksort-is.html
08:22:48 <luite> merijn: it doesn't say anything about the complexity
08:22:58 <edwardk> beaky: did you wake up and decide to troll today?
08:24:01 <merijn> luite: Oh, I thought it was that blogpost, I'd have to look up which post that was that discusses quicksort complexity
08:25:28 <merijn> luite: I don't immediately see an explanation of what's wrong here, but the consensus that is not O(n log n): http://stackoverflow.com/questions/11355621/pseudo-quicksort-time-complexity
08:25:44 <luite> merijn: but where is it actually different? it copies the lists a few times, but that doesn't change the complexity (you have to traverse the whole list for partitioning anyway), appending is the same, you only append every time you partition
08:26:31 <luite> merijn: stack space use is different if you don't carefully choose your tail calls, but fixing that doesn't require switching to destructive update
08:27:00 <merijn> luite: Which still doesn't change the fact that merge sort is equally elegant *AND* better performing
08:27:14 <beaky> btw, how do i go about writing mergeSort :: (Ord a) => [a] -> [a] in haskell
08:27:14 <luite> merijn: sure but that totally isn't the point...
08:27:48 <merijn> luite: I'm saying quickosrt is terrible example because the speed is horrendous and merge sort is much better, and you respond by saying "it's quite functional"
08:28:26 <merijn> luite: How is it "functional" if there are significantly better implementations of the same behaviour
08:28:53 <merijn> By that logic you can call anything that has an elegant implementation functional, regardless of how sucky the runtime
08:28:56 <luite> merijn: i meant functional as opposed to imperative, since you claimed that quicksort is really an imperative algorithm
08:29:25 <mkramer> the reason why quicksort is important is because it has an imperative implementation that is fast on real hardware
08:29:28 <merijn> luite: I did, and I stand by that. Quicksort is elegant and speedy in imperative code and in functional code it is merely elegant
08:29:44 <merijn> While merge sort is both elegant *and* speedy in functional code
08:29:50 <donri> arguably the usual functional implementation isn't even "quicksort"
08:29:58 <luite> donri: argh you again
08:30:00 <luite> err
08:30:01 <donri> :D
08:30:02 <merijn> donri: Yes, that was what I said at first
08:30:02 <luite> not you
08:30:03 <luite> but again
08:30:11 <luite> donri: why isn't it? i'm not convinced
08:30:26 <luite> it's not a well-performing implementation, sure
08:30:29 <donri> luite: i said arguably because i'm not smart enough to judge myself ;)
08:30:44 <donri> but the argument goes, quicksort by definition uses mutation
08:30:51 <donri> qsort without ST in haskell, doesn't
08:31:05 <merijn> luite: The argument provided in the SO link is that the key idea of quicksort is it's smart partitioning, which the naive qsort in haskell doesn't do
08:31:28 <merijn> luite: If the partitioning is not they key idea that makes it quicksort, what is?
08:31:31 <hpaste> edwardk pasted “CRCs: support for multiple CRC types” at http://lpaste.net/92851
08:31:33 <merijn> luite: The fact that it sorts?
08:31:50 <merijn> Then I might as well call merge sort quicksort and call it a day
08:32:02 <edwardk> finally found a way that doesn't suck when it comes to encoding multiple versions of the galois field
08:32:03 <n-dolio> Is that meant to be a bad argument?
08:32:10 <edwardk> go reflection!
08:32:25 <n-dolio> There are many higher level details that distinguish quick sort from merge sort.
08:32:43 <merijn> n-dolio: It was reductio ad absurdum
08:32:46 <n-dolio> Or, maybe not 'many,' but some obvious ones.
08:33:05 <merijn> n-dolio: See my lines above that
08:33:06 <luite> merijn: the key is choosing a pivot and then partitioning around that. the fact that other implementations make it easier to make a pivot-chooser that handles common practical scenarios (in particular already sorted data) better, really doesn't make it a different algorithm
08:33:54 <merijn> luite: But you don't partition around a pivot in the functional one
08:34:03 <n-dolio> Yes, you do.
08:34:05 <luite> merijn: you do!
08:34:18 <merijn> There is no around if you have no left hand side...
08:34:18 <luite> the pivot is just the first element of the list, since that's easily accessible
08:34:33 <luite> merijn: uh?
08:35:41 <sellout-> merijn: qsort [5, 2, 9, 7, 3] –> qsort [2, 3] ++ [5] ++ qsort [9, 7]
08:35:45 <merijn> Anyway, I should do something more constructive, so I will leave it at this with the parting shot that if you say that quicksort is a nicer functional sort than merge sort, you're clearly insane (ad hominem bonus + 10!)
08:35:57 <sellout-> merijn: See the lefthand side?
08:36:14 <luite> merijn: i never said that...
08:36:22 <Cale> beaky: fwiw, I think the non-in-place version can rightfully be called quicksort too
08:36:29 <merijn> sellout-: I don't consider copying and duplicating all smaller elements in a list "partitioning"
08:36:57 <Cale> beaky: But some people are more picky about what characteristics are required to call something "quicksort"
08:37:04 <n-dolio> I guess we should rename the 'partition' function, then.
08:37:16 <beaky> ah
08:37:27 <merijn> luite: Then I wonder what the point was of disagreeing with me when I stated that I thought quicksort was quite imperative compared to merge sort
08:37:41 <merijn> n-dolio: There's different usages of partitioning going on there
08:38:07 <merijn> n-dolio: partition the function refers to logical grouping, the partitioning in quicksort is about dividing a space
08:38:16 * elliott cries.
08:39:29 <luite> merijn: you said that quicksort is in essence an imperative algorithm. i disagree with that, arguing that the common quicksort example is still quicksort, and nicely functional. i never said anything about nicer than merge sort, or about it being a good practical implementation
08:39:32 <Cale> beaky: To write mergesort, I would recommend first writing merge :: (Ord a) => [a] -> [a] -> [a], which merges two sorted lists to get another, and then applying it to pairs of even/odd adjacent elements in map (:[]) xs (i.e. take your list, make each element of it into a singleton list which is trivially sorted, and then merge adjacent pairs together recursively until you're done.
08:39:34 <Cale> )
08:40:04 <luite> merijn: i have to leave for dinner now, sorry :p
08:41:06 <merijn> luite: I wonder how you turned "<merijn> That's because quicksort is quite imperative" into "you said that quicksort is in essence an imperative algorithm"
08:42:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/Data-List.html#sort
08:42:28 <Cale> The implementation of sort in GHC happens to be such a mergesort
08:43:12 <Cale> oh, it looks like it chops into already-sorted sequences though
08:43:39 <Cale> I recall at one point it just did the simple thing of splitting into singletons
08:44:34 <Cale> beaky: ^^
08:47:59 <kuribas> How can I see the assembler output from ghc?
08:48:38 <merijn> kuribas: Disassemble the binary?
08:48:49 <bartavelle> kuribas, ghc-core is handy
08:48:59 <donri> kuribas: the ghc-core package is helpful for that, but you will probably find looking at Core more useful
08:49:03 <kuribas> I already have core output...
08:49:06 <donri> (which it also does)
08:49:15 <bartavelle> ghc-core displays both
08:49:23 <Cale> -ddump-asm
08:49:36 <geekosaur> -ddump-asm is a thing, but is not going to be very enlightening
08:49:45 <kuribas> thanks
08:49:49 <merijn> geekosaur: Depends on why you wanna look at it :)
08:49:50 <kstt> hello
08:50:01 <kuribas> I want to see what Core translates to.
08:50:38 <geekosaur> it translates to cmm, I believe :)
08:50:56 <hpaste> beaky pasted “merge” at http://lpaste.net/92852
08:51:06 <kuribas> Well, I mean how it translates into asm...
08:51:12 <beaky> I think I nailed down merge, but I don't know how to do the mergeSort bit :(
08:51:31 <Cale> beaky: If you'd like to cheat a little, have a look at the code I linked
08:52:02 <beaky> yeah reading the haskell base source is enlighening
08:52:04 <Cale> beaky: Start with a function which takes a list of lists, and applies merge to adjacent even/odd pairs of lists
08:52:23 <Cale> beaky: and then write something which applies that function until there's only one list left
08:53:09 <Cale> i.e. you'll cut the number of lists roughly in half each time
08:53:22 <kstt> My application must read a hand-written data file, representing a n-tree of tuples. From your experience, what data format should I use ? XML, YAML, JSON, haskell show/read ?  Performance is not an issue, I prefer simplicity, conciseness of the code and of the data file, and robustness against format error. Thx
08:55:17 <merijn> s-expressions are usually not a terrible data format :p
08:56:21 <Cale> Nothing is going to beat haskell show/read for simplicity, but 'read' will error out if there's a problem with the format, and even reads/readsPrec won't tell you what's wrong (but you'll get an empty list of parses)
08:56:35 <Cale> There are some nice JSON libraries
08:56:55 <donri> yaml might be optimal for the hand-writing part of it
08:57:17 <donri> but it's rather liberal so format error robustness is questionable
08:57:38 <gwern> http://lpaste.net/92853 type error; apparently the value is too general for the function I apply to it, but I'm not sure how I would narrow it down
08:57:48 <ocharles> JSON generated by Aeson and GHC.Generics can be a nice way to get going with it - but that ties your JSON schema to your code schema, so you might not want that in the long run
08:57:57 <gwern> (more frustratingly, this only became a problem upon upgrading pandoc, it ran just fine yesterday!)
08:58:34 <Cale>  Couldn't match expected type `V.Vector GoodReads'
08:58:34 <Cale>                 with actual type `vector-0.9.1:Data.Vector.Vector a0'
08:58:42 <Cale> This looks like package mismatch
08:59:07 <Cale> Normally, if those occurrences of 'Vector' were the same type, those would unify with GoodReads ~ a0
08:59:09 <gwern> package mismatch? where would that be coming from
08:59:12 <donri> ghc-pkg list vector?
08:59:50 <gwern> donri: '/var/lib/ghc/package.conf.d    vector-0.9.1 /home/gwern/.ghc/x86_64-linux-7.4.1/package.conf.d    vector-0.10.0.1'
09:00:20 <donri> i've never had that problem with cabal, but it seems to show up easily with ghci and runhaskell is basically ghci isn't it?
09:00:33 <gwern> I get the same error using just ghc too
09:01:02 <donri> but you're not passing explicit -package options, surely? cabal will, though
09:01:05 <Cale> Data.Csv depends on Vector
09:01:19 <Cale> But which version was it built against?
09:01:40 <kuribas> Does ghc do supercompilation?  For example, can it transform sum [a, b, c
09:01:43 <gwern> hm. I don't know. I don't think pandoc depends on cassava so it probably didn't get upgraded last night
09:01:53 <kuribas> ] into a + b + c?
09:02:00 <Cale> By current guess is that your pandoc and cassava are built against two different vector packages
09:02:19 <Cale> kuribas: no
09:02:22 <gwern> '$ cabal install Resolving dependencies... In order, the following will be installed: cassava-0.2.2.0 (reinstall) changes: vector-0.9.1 -> 0.10.0.1 Warning: Note that reinstalls are always dangerous. Continuing anyway... Configuring cassava-0.2.2.0...' <-- looks like it
09:02:50 <Cale> My*, heh
09:03:30 <kuribas> Cale: Is there no incentive to enable supercompilation for ghc?
09:04:39 <Cale> kuribas: I seem to recall that Neil Mitchell (ndm when he's online) has done a bunch of work on supercompilation.
09:04:51 <gwern> Cale: yep, that fixed it, thanks
09:04:54 <ocharles> I think Max Bolingbroke did work on that
09:04:56 <Cale> gwern: no problem
09:04:57 <ocharles> (also)
09:05:01 <ocharles> kuribas: is sum [a, b, c] -> a + b + c really supercompilation though?
09:05:08 <e98> is there any way to run ghci inplace in a 7.8 build tree? 7.8's 'make install' fails and I wanted to check the utf-8 issue reported to see if it affects me
09:05:11 <gwern> Cale: yeah, ndm's thesis was aon supercompilation, wasn't it? but iirc his work never made it into ghc (as usual)
09:05:39 <ocharles> http://vimeo.com/16753555 that's Max's work on supercompilation
09:06:05 <kuribas> ocharles: Well, supercompilation would do the transform.
09:06:06 <gwern> ghc - where theses and summer of codes go to die
09:07:08 <ion> What’s the Community’s favorite type-safe printf replacement? I’ll accept any method, including quasiquotes.
09:07:23 <Cale> I like show and concat
09:07:45 <ion> cale: I need formatting like %5.2f
09:08:18 <donri> printf-mauke doesn't look like complete crap, but haven't used it
09:09:21 <kstt> merijn, Cale, donri, ocharles: thx. Failing without error message is too bad. ocharles, data won't be generated, but hand-written.
09:09:33 <kuribas> gwern: Didn't his paper work with the Yhc compiler?
09:09:52 <gwern> kuribas: yes, but he was comparing with GHC (to show the value of his techniques) and was hoping to get it into ghc, iirc
09:10:06 <Cale> kstt: If it were me, it would probably come down to asking what format I'd like to enter the data in
09:10:34 <Cale> kstt: and then either writing a Parsec parser for that format, or using something existing if I decided on something like JSON
09:11:01 <kstt> Cale : Indeed, and that would certainly be YAML. But I don't know what exists to read a data structure from Yaml.
09:11:19 <Clint> @hackage yaml
09:11:19 <lambdabot> http://hackage.haskell.org/package/yaml
09:11:24 <Cale> http://hackage.haskell.org/package/yaml
09:11:26 <n-dolio> Max's work was on GHC, I think.
09:11:52 <n-dolio> (Unsurprisingly.)
09:11:56 <ion> donri: Thanks. That’s one of the alternatives i was looking at. I suppose i’ll just pick that one.
09:12:07 <n-dolio> I don't know what came of it, though.
09:12:35 <Cale> Yeah, ndm's work was on Yhc, though there was, I think, a standalone source -> source supercompiler (supero?)
09:12:54 <kstt> Cale, Clint : can I just *derive* the n-tree and have the YAML parser for free, like with JSON and built-in read ?
09:13:09 <kstt> It does not seem so, at first glance
09:14:14 <kstt> http://hackage.haskell.org/packages/archive/yaml/0.8.5/doc/html/Data-Yaml.html#g:5  <- Is that a documentation bug ? Yaml package with Aeson doc ?
09:14:39 <donri> kstt: you can derive the json instances
09:14:57 <Clint> not a bug
09:15:03 <geekosaur> "This module reuses most of the infrastructure from the aeson package."
09:15:07 <geekosaur> right at the very top
09:15:12 <donri> "For the most part, YAML content translates directly into JSON, and therefore there is very little data loss. If you need to deal with YAML more directly (e.g., directly deal with aliases), you should use the Text.Libyaml module instead."
09:15:15 <kstt> ah, yes, indeed ...
09:15:45 <kstt> cool, good news. Thank you
09:16:14 <beaky> @hoogle [a] -> [[a]]
09:16:14 <lambdabot> Data.List inits :: [a] -> [[a]]
09:16:14 <lambdabot> Data.List permutations :: [a] -> [[a]]
09:16:14 <lambdabot> Data.List subsequences :: [a] -> [[a]]
09:16:17 <merijn> I've started to dislike JSON as a serialisation format
09:16:29 <merijn> Mostly because of it's ridiculous treatment of numbers
09:16:30 <Kinnison> It's faster than YAML :-(
09:17:17 <hpaste> beaky pasted “Improving mergesort” at http://lpaste.net/92854
09:17:42 <beaky> how do I improve my mergesort?
09:19:17 <beaky> wow haskell mergesort looks very elegant
09:19:24 <beaky> in C  it would take me dozens of lines
09:19:30 <beaky> (in c++ only 3 lines)
09:21:05 <beaky> btw is there a generic merge in the prelude
09:22:04 <dmwit> Not in Prelude, but data-ordlist has it.
09:23:37 <beaky> aww :(
09:24:13 <ion> I wonder if PEBKAC? λ> let n = 42 :: Double in (Text.Printf.Mauke.printf "%10.1f" n, Text.Printf.printf "%10.1f" n) :: (String, String)
09:24:15 <ion> ("42.0","      42.0")
09:25:26 <int-e> ion: looks like a bug in the first printf.
09:26:11 <ion> "%010.1f" makes Mauke.printf return "00000042.0", "% 10.1f" makes Mauke.printf return " 42.0"
09:27:45 <geekosaur> I think that's a longstanding bug in Text.Printf?
09:27:53 <geekosaur> oh, hm, wrong one
09:27:59 <geekosaur> maukes produced the wrong output
09:28:27 <geekosaur> it *was* a bug in Text.Printf for a long time though, so understandable that later replacements copied it
09:30:42 <sellout-> Man, my :lalex definition for ghci streamlines things so much.
09:31:43 <ion> I suppose i’ll try this one next. http://hackage.haskell.org/packages/archive/holey-format/1.2.0/doc/html/Text-Format.html
09:32:16 <magneticduck> hey is there a simple way to get show for floats to not use scientific notation?
09:32:32 <magneticduck> > 1/100
09:32:34 <lambdabot>   1.0e-2
09:32:48 <magneticduck> > 1/100 :: CReal
09:32:50 <lambdabot>   0.01
09:33:05 <magneticduck> oh, I guess I just solved my problem; now the question is "is there a faster way?"
09:33:14 <magneticduck> without having to use CReal
09:33:30 <dmwit> magneticduck: Yes, see the show?Float functions in Numeric.
09:33:43 <geekosaur> yeh, I'd poke at Numeric for formatting functions
09:34:09 <geekosaur> showFFloat specifically
09:34:29 <donri> ion: how about xformat :)
09:36:03 <int-e> > liftM2 (\f x -> f Nothing x "") [Numeric.showEFloat, Numeric.showFFloat, Numeric.showGFloat] [1e10,1,1e-10]
09:36:04 <lambdabot>   ["1.0e10","1.0e0","1.0e-10","10000000000.0","1.0","0.0000000001","1.0e10","...
09:36:49 <donri> ion: and perhaps talk to mauke who's here
09:37:45 <danilo2> Hello! Is it possible in Haskell to write such newtype: "newtype MyIO a = MyIO (IO a) ", which will be instance of Show in such way,  that it will return "MyIO Int" for MyIO (IO Int) ?
09:38:04 <ion> donri: I picked holey-format over it because its authors were more familiar to me. :-P Or is xformat better in some way?
09:38:41 <danilo2> Or is it possible sismply to add Show instance to IO ?
09:38:50 <ion> danilo2: You could do that with instance (Typeable a) => Show (MyIO a), i think.
09:39:27 <ion> Adding an orphan Show instance to IO would also be possible similarly.
09:39:29 <donri> nah that'll show it as MyIO <IO Int>
09:39:45 <donri> uh <<IO Int>> even, maybe
09:40:02 <leroux> danilo2: You may need to use FlexibleInstances and TypeSynonymInstances.
09:40:15 <ion> > putStrLn "hai"  -- Did lambdabot have that instance?
09:40:16 <lambdabot>   <IO ()>
09:40:53 <donri> ion: no clue re xformat
09:41:35 <Maior> @hoogle (Monad m) => (a -> b) -> (a -> m b)
09:41:36 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:41:36 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
09:41:36 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:42:52 <danilo2> ion, leroux, donri: thank you - I'm trying it right now :)
09:44:45 <donri> uh ignore me danilo2 i misread ion
09:44:54 <beaky> why is my mergesort so inefficient
09:45:11 <hpaste> danilo2 pasted “Show IO” at http://lpaste.net/92855
09:45:15 <hpaste> beaky pasted “inefficient mergesort” at http://lpaste.net/92856
09:45:32 <danilo2> ion, leroux, donri: The following code "hangs" when running: http://lpaste.net/92855
09:46:46 <donri> danilo2: you need to define show too
09:46:59 <int-e> beaky: ouch. you're merging a list of increasing lists with a bunch of singleton lists
09:47:24 <donri> danilo2: https://github.com/mokus0/show/blob/master/ShowFun.hs
09:47:45 <danilo2> donri: ahhh ok!
09:47:55 <danilo2> donri: thanks!
09:48:25 <beaky> ah
09:48:35 <hpaste> int-e annotated “inefficient mergesort” with “inefficient mergesort (binary fold)” at http://lpaste.net/92856#a92857
09:48:36 <beaky> so my mergesort is just as crappy as the qsort example?
09:49:07 <int-e> beaky: if I haven't messed up (I typed it directly into lpaste), that version should perform fine
09:49:57 <int-e> beaky: your code is essentially a naive insertion sort, which is O(n^2) on average. (The qsort example is still O(n log n) average.)
09:50:00 <beaky> yes yours works very fast
09:50:08 <beaky> almost as fast as prelude one :D
09:52:37 <beaky> hmm the naive qsort is slow too :(
09:52:51 <int-e> beaky: on random input?
09:53:02 <beaky> whent he list is reversed
09:53:11 <beaky> (is that the worst case? :D)
09:53:22 <int-e> beaky: close enough, it will be quadratic.
09:54:00 <int-e> ... yes, that is actually the worst possible, along with the sorted list.
09:54:06 <beaky> :D
09:55:15 <joe9> I have a function whose return type is Test. I want to change it to ReaderT Device Test. I get this error though: http://codepad.org/Uj8U7Gkd . Any suggestions on how to go about fixing it, please?
09:57:37 <donri> joe9: either add a monad parameter or use Reader
09:58:01 <joe9> donri: oh, I could use Reader. got it. thanks.
10:00:48 <ion> I have trouble figuring out how to compose, say, fixed 1 with right 8 ' ' with holey-format.
10:02:37 <donri> ion: (.) ?
10:03:08 <ion> donri: right 8 ' ' . fixed 1 seems to behave like "%8s%.1f"
10:07:08 <acomar> hmm... so I'm installing cabal 1.18 via the method suggested on the announce page. When my package manager updates to the latest version (or newer) and I want to use that over the locally installed version, is it just a matter of removing the package from the cabal bin and lib dirs or is there some other stuff that has to be cleaned up as well?
10:07:30 <acomar> (that is, I want to remove the package from cabal entirely)
10:07:42 <dcoutts> acomar: you'd need to rebuild anything that depended on it
10:08:01 <dcoutts> which would be obvious since ghc-pkg tells you when you're breaking things by removing dependencies
10:08:05 <donri> acomar: ghc-pkg unregister Cabal; rm ~/.cabal/bin/cabal
10:08:05 <dcoutts> and lists broken packages
10:09:18 <acomar> thanks dcoutts, donri
10:09:37 <yitz> trivia question: what binds more tightly than function application in an expression?
10:10:05 <donri> yitz: record notation
10:10:35 <yitz> donri: i had no doubt you knew the answer :)
10:10:36 <Peaker> yitz: record syntax
10:10:45 <dcoutts> bah, beaten to it
10:10:51 <yitz> Peaker you too :)
10:11:23 <dcoutts> f x { y = z }
10:11:30 <yitz> > let add3 = fmap (+3) . getFirst in add3 (First $ Just 10) { getFirst = Just 20 }
10:11:31 <lambdabot>   Just 23
10:11:54 <elliott> yitz: module qualification
10:12:42 <yitz> elliott: aha ok. but that's more connected with tokenization than with expression precedence
10:13:54 <donri> > 5 * do 3 + 2
10:13:55 <lambdabot>   25
10:13:59 <Peaker> Lots of people like to add parenthesis in Haskell code for these "lesser known" rules, but I find it so arbitrary.. either you go maximally parens (Lisp), or minimal parens (hlint, yay)
10:16:05 <sleepynate> I think you mean (L (i (s (p))))
10:16:35 <donri> H $ a $ s $ k $ e $ l l
10:21:02 <aristid> donri: argh it must be l $ l to look regular *panics*
10:21:34 <sleepynate> donri: No instance for (t0 -> t0)
10:21:37 <donri> aristid: H . a . s . k . e . l $ l
10:21:53 <donri> sleepynate: good point
10:22:07 <artyomkazak> s
10:22:24 <aristid> donri: i'll let that pass because H . a . s . k . e . l $ l = H $ a $ s $ k $ e $ l $ l
10:23:01 <donri> sleepynate: actually what?
10:24:30 <sleepynate> donri: passing a function to itself takes other arguments without an assignment should cause a No Instance error
10:24:50 <donri> > id id
10:24:51 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
10:24:51 <lambdabot>    arising from a use ...
10:24:56 <donri> :t id id
10:24:57 <lambdabot> a -> a
10:25:07 <donri> :t const const
10:25:07 <lambdabot> b -> a -> b1 -> a
10:25:32 <donri> sleepynate: what do you mean
10:26:11 <sleepynate> if you call id id with saying like, let x = id id, you'll get No Instance
10:26:33 <sleepynate> > let l = id
10:26:34 <lambdabot>   not an expression: `let l = id'
10:26:39 <Hafydd> > let x = id id in x 1
10:26:40 <lambdabot>   1
10:27:09 <YayMe`> :t const . const
10:27:10 <lambdabot> a -> b -> b1 -> a
10:27:14 <joe9> I am trying to change a function (checkMaintenance1 ) with return type Test to a function (checkMaintenance2 ) with return type Reader Device Test. http://codepad.org/vORWuB7I . Any thoughts on what I am missing please?
10:27:20 <sleepynate> > let l = id in l l
10:27:21 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
10:27:22 <lambdabot>    arising from a use ...
10:27:24 <sleepynate> see?
10:27:33 <donri> :t let l = id in l l
10:27:34 <lambdabot> a -> a
10:27:50 <joe9> error message is : http://codepad.org/Cqvh62zD
10:27:59 <donri> problem is you're trying to Show a generic function
10:28:01 <Hafydd> > let l = id in l l 1
10:28:02 <lambdabot>   1
10:28:02 <YayMe`> > let l = const in const . const
10:28:03 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b1)
10:28:03 <lambdabot>    arising from a use ...
10:28:07 <donri> > id
10:28:09 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
10:28:09 <lambdabot>    arising from a use ...
10:28:14 <donri> > id :: Int -> Int
10:28:14 <merijn> sleepynate: lambdabot can't print functions
10:28:15 <lambdabot>   <Int -> Int>
10:28:20 <donri> sure it can ;)
10:28:24 <merijn> sleepynate: At least not polymorphic ones
10:28:29 <donri> yeah
10:28:38 <merijn> donri: I know, but that's an ugly hack no to be relied upon
10:28:47 <Hafydd> That error message is pretty misleading.
10:29:05 <donri> Hafydd: well it's cut off
10:29:07 <ekipan> joe9: checkmaintainance2 label = return (checkmaintenance1 label)
10:29:12 <donri> it'd probably say that a0 is ambiguous
10:29:13 <merijn> Hafydd: Yes, but I think that's mostly caused by the show instance for non-polymorphic functions
10:29:25 <donri> and it wants typeable because of special Show instances in lambdabot
10:29:43 <merijn> If you type "id" into ghci it will report there's not show instance for "a -> a"
10:29:48 <donri> > id `asAppliedTo` 5  -- does it work with defaulting though?
10:29:54 <lambdabot>   <Integer -> Integer>
10:30:02 <Hafydd> merijn: well, yes; that's my point.
10:30:10 <merijn> Hafydd: Blame elliott
10:31:10 <joe9> ekipan: cool, thanks.
10:31:15 <donri> would be nice if lambdabot could display complete but shortened down type error messages
10:51:27 <paolino> > do {Nothing >> Just 1}
10:51:28 <lambdabot>   Nothing
10:51:45 <paolino> > do {Nothing >>=  Just 1}
10:51:46 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe b0'
10:51:47 <lambdabot>              with ...
10:52:05 <paolino> > do {Nothing >>=  \_ -> Just 1}
10:52:06 <lambdabot>   Nothing
10:52:13 <donri> > Nothing >>= Just
10:52:14 <lambdabot>   Nothing
10:52:32 <ekipan> Nothing >>= _ = Nothing -- from definition of (>>=)
10:53:03 <t4nk406> hello
10:53:11 <t4nk406> i am reading a http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
10:53:47 <t4nk406> but this one fails with exception Not in scope: type variable `a' : data Complex = Num a => Complex { real :: a, img :: a}
10:54:12 <paolino> data Complex a = ..
10:54:44 <ekipan> an error in the tut
10:54:50 <t4nk406> umm?
10:55:02 <satc> I have the following situation, data Foo = A | B | C | D | E.   type family isA (x :: Foo) :: Bool ; type instance isA A = True; Now how to declare isA to be false for rest of the types of kind Foo. I dont want to write each one of them saying they are False?
10:55:19 <ekipan> the tutorial text is erroneous, paolino gives the correction
10:56:01 <paolino> satc True is not a type
10:56:13 <paolino> or you lifted it ..
10:56:43 <notdan> A also is not a type
10:56:47 <tromp> i cannot fathom any good reason for using isA
10:56:50 <merijn> satc: You can't in GHCs older than 7.7
10:57:06 <t4nk406>  Data constructor `Complex' has existential type variables, a context, or a specialised result type        (Use -XExistentialQuantification or -XGADTs to allow this)
10:57:09 <merijn> paolino, notdan: Clearly he is using DataKinds
10:57:14 <t4nk406> should i do that?
10:57:44 <geekosaur> hm
10:57:49 <notdan> ok well then you need closed type families
10:57:50 <paolino> t4nk406, you have to add 'a' after Complex
10:57:52 <merijn> satc: Basically, GHC prior to 7.7 only supports open type families where that functions isn't possible. GHC >7.7 also supports closed type families, which *do* allow this
10:58:04 <geekosaur> paolino, it's whining about the Num a => constraint
10:58:13 <satc> merijn: How ?
10:58:33 <geekosaur> which, yes, is deprecated these days because it doesn't do what most people hope
10:58:40 <joe9> program: http://codepad.org/fKeQaPhb, error: http://codepad.org/HPrnzL7W . Any suggestions on how to get it working please?
10:58:44 <paolino> oh sorry
10:58:46 <joe9> ekipan: any thoughts on this, please?
10:58:47 <merijn> satc: I don't know the syntax in 7.7, it got changed but googling for "ghc closed type families" should probably turn up a manual/explanation
10:58:50 <t4nk406> paolino: did that
10:59:12 <t4nk406> paolino: and now it asks me for some flags
10:59:31 <paolino> take away the constraint Num a =>
10:59:34 <ekipan> I'd personally delete the Num a => context
10:59:48 <paolino> *context
10:59:58 <ekipan> same diff
11:00:10 <t4nk406> helped, thanks =)
11:00:16 <paolino> and add it to the functions later
11:00:59 <paolino> function having args Complex a will need it
11:01:20 <t4nk406> y, thanks
11:06:01 <satc> merijn: What ghc version is syntax type family Foo a where Foo Int = Bool ... supported?
11:06:43 <satc> merijn: I can see the syntax in haskell wiki but trying that says parse error.
11:07:23 <joe9> i cannot figure out what I am doing wrong here: http://codepad.org/fnMqOfH6 . it says that Reader does not exist.  Not in scope: data constructor `Reader'
11:07:23 <joe9> a
11:07:25 <geekosaur> 6.12.1 looks like'
11:07:31 <mr-> satc: you'll have to enable it
11:07:45 <joe9> and I imported control.monad.reader
11:07:50 <geekosaur> erm
11:08:45 <notdan> satc: GHC 7.7 aka GHC HEAD
11:08:46 <satc> mr-: I am already using TypeFamilies extension. How else do I enable it?
11:09:01 <notdan> you'll have to either compile it yourself or get a nightly build maybe
11:09:14 <merijn> satc: That syntax only works in 7.7, if your compiler is older it doesn't support it yet
11:09:18 <Thulsadum> mh, i'm quite new and i wonder what would be the way to append an item received via IO to an existing list?
11:09:25 <satc> merijn: Thanks
11:09:56 <merijn> Thulsadum: Appending to lists is almost universally a bad idea, it's an operation that takes O(n)
11:10:06 <joe9> Thulsadum: item <- io_action; let list1 = list ++ [item]
11:10:10 <merijn> Thulsadum: Perhaps you want a queue or other FIFO stucture?
11:12:00 <Thulsadum> merijn: prepending would work as well ;) the problem is to alter that data
11:13:02 <merijn> Thulsadum: You can't, the list is immutable. You can create a new list by simply appending the item to the old one, though
11:13:18 <Thulsadum> assume i have a global collect (list, fifo, queue, w/e) with phonebook entries, initialy read from a file. now i would like to add an item during runtime by user input and want du add it there
11:13:40 <joe9> Thulsadum: State monad?
11:13:54 <merijn> Thulsadum: I'd keep the list in an IORef/MVar and put the new one in and/or the State monad, depending on the application
11:13:58 <Thulsadum> yep, that's my problem, i can't :D but i can't figure out how to do it the haskell way
11:14:23 <Thulsadum> ok, so i'll have a look at the state monad
11:14:28 <Thulsadum> thanks for the input
11:15:29 <merijn> Thulsadum: Will you have multiple threads accessing this list of entries in parallel?
11:15:39 <merijn> Thulsadum: If so, you might want to take the MVar approach
11:16:16 <Thulsadum> multi threading is in far feature atm.
11:16:44 <joe9> can anyone please help with this reader monad usage: http://codepad.org/i3W1CSZr is the program, error message: http://codepad.org/nUL7jWxb . I tried ask >>= , but could not get it to compile. Any thoughts, please?
11:16:54 <Thulsadum> it's as mentioned a simple phonebook for educational prupose :D
11:17:10 <Thulsadum> nothing huge, big. just to get used with haskell
11:17:11 <merijn> Thulsadum: You might be pleasantly surprised how much easier multithreading is in Haskell compared to other languages :)
11:18:09 <Thulsadum> merijn: I'll if the time is right. for now i'm quite surprise how everything is described in a quite elegant way
11:21:25 <mauke> joe9: why are you mixing -X and LANGUAGE?
11:23:03 <mauke> joe9: what's the type of TestCase?
11:24:09 * hackagebot printf-mauke 0.5.2 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5.2 (LukasMai)
11:24:54 <mauke> ion: can you try again?
11:25:06 <satc> Where are the ghc nightly builds available? All I could find is the git source.
11:27:06 <joelteon> I don't think anybody provides GHC nightly builds at the moment
11:29:13 <Athas> Is there a way to speed up ghci loading up files, by doing preprocessing or something?
11:29:32 <mauke> yeah, compile them
11:29:34 <Athas> One of my modules depends on a happy-generated parser, and it takes a very long time to load, despite not changing.
11:30:23 <Athas> mauke: how do I do that?
11:30:28 <mauke> with ghc
11:30:31 <merijn> Athas: By calling ghc? ;)
11:31:09 <Athas> Well, this is a Cabal project, so I suppose there are .o files lying around somewhere in the dist directory.  Should I just add them to the include path?
11:31:48 <dcoutts> Athas: use :set -fobject-code
11:31:51 <dcoutts> in ghci
11:31:54 <joelteon> i might set up some nightly builds eventually satc
11:31:58 <joelteon> but for now you might try using hsvm
11:32:00 <joelteon> /plug
11:32:16 <joe9> mauke, regarding -X and LANGUAGE, should I not do that?
11:32:22 <joe9> regarding type of TestCase: TestCase :: Assertion -> Test
11:32:23 <merijn> I believe johnw has nightly builds somewhere
11:32:25 <Athas> dcoutts: wow, thanks, that did the trick.  I'll read up on that flag.
11:32:36 <johnw> merijn: http://ghc.newartisans.com
11:32:39 <mauke> joe9: I'm just wondering why
11:32:57 <merijn> joelteon: There you go ;)
11:33:05 <mauke> joe9: also, why not {-# OPTIONS_GHC -XUnicodeSyntax #-} {-# LANGUAGE DoAndIfThenElse #-} ?
11:33:25 <merijn> satc: Yeah, haskell.org is no longer hosting nightly builds, but see johnw's URL
11:33:27 <mauke> joe9: what's Assertion?
11:34:00 <joe9> IO ()
11:34:26 <mauke> joe9: IO doesn't provide ask
11:35:54 <joe9> mauke, makes sense. Thanks. How do I change a Test to a Reader Device Test?
11:36:06 <joe9> without using just return.
11:36:16 <mauke> hwat
11:36:23 <joe9> I want the Test function to read the device from the env and then use it.
11:36:28 <mauke> what env?
11:38:14 <joe9> mauke: I have this function checkMaintenance:  http://codepad.org/ZzNgf9rc and I want to change the return type of it from Test to Reader Device Test.
11:39:02 <joe9> so, I do not call the "(Just device) <- getMyDevice " in that  function, but, the caller function sends it as a parameter.
11:39:14 <joe9> mauke, does that make sense?
11:39:20 <mauke> ... = do device <- ask; TestLabel (...) . TestCase $ do ...
11:40:01 <joe9> mauke: http://codepad.org/Z1CcCGUJ
11:40:25 <joe9> mauke, I tried that but could not get it to work: http://codepad.org/4xg2f5Tq
11:40:28 <mauke> getting closer
11:40:52 <mauke> you need a return
11:41:20 <mauke> TestLabel returns Test, not Reader Device Test
11:43:26 <joe9> mauke: that helped. thanks a lot.
11:44:09 * hackagebot hdbi 1.1.1 - Haskell Database Independent interface  http://hackage.haskell.org/package/hdbi-1.1.1 (AlekseyUymanov)
11:46:54 <joe9> mauke: -X converts a language pragma to a command line pragma. got it. thanks.
11:49:09 * hackagebot hdbi-tests 1.1.1 - test suite for testing HDBI  http://hackage.haskell.org/package/hdbi-tests-1.1.1 (AlekseyUymanov)
11:49:11 * hackagebot hdbi-postgresql 1.1.1 - PostgreSQL driver for hdbi  http://hackage.haskell.org/package/hdbi-postgresql-1.1.1 (AlekseyUymanov)
11:49:13 * hackagebot hdbi-sqlite 1.1.1 - SQlite driver for HDBI  http://hackage.haskell.org/package/hdbi-sqlite-1.1.1 (AlekseyUymanov)
11:59:21 <ion> mauke: Thanks! Seems to work now.
12:07:48 <paolino> :t (&)
12:07:48 <lambdabot> a -> (a -> b) -> b
12:08:12 <joelteon> :t (<&>)
12:08:13 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:09:28 <paolino> is 'id' an ASetter ?
12:09:32 * monochrom imagines: do { v <- newTVar 0; ... } & atomically
12:09:43 <joelteon> "do all that...oh, and atomically"
12:09:53 <shachaf> paolino: id is pretty much every lens thing.
12:10:04 <joe9> type Assertion = IO ()  -- Defined in `Test.HUnit.Lang'
12:10:04 <shachaf> :t id :: ASetter a b a b
12:10:05 <lambdabot> ASetter a b a b
12:10:09 <edwardk> paolino: yes
12:10:17 <joe9> why cannot I use ReaderT Device Assertion?
12:10:23 <joe9> instead of Reader Device Assertion?
12:10:47 <edwardk> paolino: id can be used as a setter, fold, traversal, lens, prism, iso, getter, equality...
12:11:01 <monochrom> it's "ReaderT r m a" in general. what is your m? what is your a?
12:11:03 <edwardk> paolino: and (.) can be used to compose them all
12:11:56 <joe9> monochrom: type Assertion = IO (), doesn't that make m= IO, and a = ()
12:12:12 <monochrom> no. that would be too easy
12:12:38 <paolino> :t liftIO
12:12:39 <lambdabot> MonadIO m => IO a -> m a
12:13:34 <monochrom> ReaderT Device Assertion = (ReaderT) (Device) (Assertion) = (ReaderT) (Device) (IO ())
12:15:02 <monochrom> well, I guess "that would be too easy" is the simplest explanation
12:17:50 <joe9> monochrom: ok, thanks.
12:25:29 <paolino> :t id & id
12:25:30 <lambdabot> a -> a
12:25:32 <joe9> is there a simpler way of writing the function checkMaintenance : http://codepad.org/jJwyvK54 , line 44
12:26:15 <joe9>  removed the do there: http://codepad.org/k1lJo4OQ
12:27:04 <joe9> Is there any way I could write that function without using the 'ask' there (line 47)?
12:27:10 <paolino> do lens compose horizontally ?
12:27:19 <edwardk> sadly, no
12:28:09 <paolino> ah well it doesn't make sense for the getter
12:28:16 <edwardk> consider _1 `asWellAs` _1  or whatever the notation would be, that fails to be a lens
12:28:39 <edwardk> :t alongside
12:28:47 <edwardk> :t Control.Lens.beside
12:28:49 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a
12:28:49 <lambdabot> b
12:28:50 <joe9> edwardk: thanks.
12:28:55 <edwardk> :t Control.Lens.alongside
12:28:56 <lambdabot> Functor f => ALens s t a b -> ALens s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
12:29:08 <edwardk> there are various things like that that retain legality
12:29:31 <edwardk> but they all require factoring through a tuple to ensure they avoid overlap
12:30:14 <edwardk> we spent a bunch of time working on theory to avoid this need, but it doesn't didn't pay out.
12:31:32 <paolino> I need a special lens to read the signature of beside =)
12:31:44 <edwardk> heh
12:31:48 <edwardk> the haddocks describe it better
12:31:48 <tpsinnem> noob question: is there a standard way of turning something like a 'Maybe IO x' into an 'IO Maybe x' ?
12:32:00 <monochrom> hahaha
12:32:20 <paolino> kind flip
12:33:01 <monochrom> there is no standard way. because it is underspecified
12:33:13 <supki> @ty Control.Monad.Trans.Maybe.runMaybeT
12:33:14 <lambdabot> Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
12:33:23 <tpsinnem> monochrom: ok, i'll think harder on it
12:33:26 <mauke> :t maybe (pure Nothing) (fmap Just)
12:33:27 <lambdabot> Applicative f => Maybe (f a) -> f (Maybe a)
12:34:01 <shachaf> :t Data.Traversable.sequenceA :: Maybe (IO a) -> IO (Maybe a)
12:34:02 <monochrom> do not think harder. code harder.
12:34:02 <lambdabot> Maybe (IO a) -> IO (Maybe a)
12:34:21 <joe9>  program: http://codepad.org/o0SNhaIk : Is there any way I can have a function instead of lines 70 thru 74. I will be repeating those lines quite a lot. (I do not want to use Template Haskell.)
12:34:30 <monochrom> I guess that is a standard way and I haven't thought about it
12:34:41 <joe9>  these lines specifically: http://codepad.org/U3MqoA5R
12:36:53 <tpsinnem> shachaf: ok looks good, i'll play with that
12:37:54 <paolino> > Data.Traversable.sequenceA $ Just [1]
12:37:55 <lambdabot>   Not in scope: `Data.Traversable.sequenceA'
12:41:51 <paolino> > T.sequenceA $ [Just 1,Just 2]
12:41:52 <lambdabot>   Just [1,2]
12:42:24 <paolino> > sequence $ [Just 1,Just 2]
12:42:25 <lambdabot>   Just [1,2]
12:42:57 <arkeet> > T.sequenceA $ Just [1,2]
12:42:58 <lambdabot>   [Just 1,Just 2]
12:43:09 <arkeet> > T.sequenceA . T.sequenceA . T.sequenceA . T.sequenceA . T.sequenceA $ Just [1,2]
12:43:10 <lambdabot>   [Just 1,Just 2]
12:43:28 <arkeet> > both id $ ((1,2),(3,4))
12:43:29 <lambdabot>   No instance for (Data.Monoid.Monoid t0)
12:43:29 <lambdabot>    arising from a use of `e_11234'
12:43:29 <lambdabot> ...
12:43:33 <arkeet> oh
12:43:42 <arkeet> right
12:46:00 <tpsinnem> shachaf: another thanks, that indeed was just what i need
12:53:12 <cdsmith> So is there still no way in pipes-4.0 to write a pipe that collects all incoming values into a list?
12:53:36 <leroux> 0.o
12:53:52 <leroux> cdsmith: Can you use a Sink for that?
12:54:56 <cdsmith> leroux: pipes doesn't have a Sink.  It has Consumer, but that fails because as soon as there's no upstream input, the pipeline terminates with the upstream result value.
12:55:01 <leroux> Btw cdsmith, thanks for https://www.youtube.com/user/cdsmithgoogle
12:55:03 <leroux> Oh.
12:55:11 <leroux> Oh, I'm thinking about conduit.
12:55:37 <mauke> can't you do that with IO?
12:55:41 <cdsmith> leroux: Right, you can definitely do it with conduit
12:56:03 <k0001> cdsmith: what are you trying to accomplish? Perhaps Pipes.Prelude.toList can help.
12:56:21 <cdsmith> mauke: Okay, so if the underlying monad is IO (or ST), you can use references.  That's not entirely satisufying, but possible...
12:57:08 <cdsmith> k0001: Thanks!  toListM is actually what I wanted
12:57:54 <TOMODO> FUCKERS
12:57:57 <TOMODO> FU
12:58:11 <TOMODO> haskell bitches
12:58:15 <cdsmith> And I didn't have a specific goal in mind... just a general re-evaluation of the state of pipes, since I haven't looked at it for a year or so
12:58:16 <TOMODO> you  are my bitches
12:58:17 <companion_cube> winner
12:58:18 --- mode: ChanServ set +o mauke
12:58:18 --- kick: TOMODO was kicked by mauke (TOMODO)
12:58:45 <beaky> hello
12:58:49 <johnw> interesting, he tailored that epithet just for us
12:58:54 <johnw> it wasn't just generated spam
12:59:22 <beaky> when I compile my program with -dynamic, it says it cannot find Data.Vector, but by defaut it compiles fine. What should I do?
12:59:25 <ion> Well, it *could* have still been generated automatically. This is #“haskell” after all.
12:59:28 <companion_cube> do you think that on the other chan he would have said "haskell-blah bitches"?
12:59:37 <johnw> it's always possible, you are right
13:00:04 <beaky> btw, is Data.Vector an immutable data structure
13:00:12 <beaky> (and Data.Text?)
13:00:18 --- mode: mauke set -o mauke
13:00:20 <johnw> there are mutable and immutable vectors
13:00:39 <beaky> ah
13:00:43 <leroux> johnw: companion_cube: Probably not, he's using the freenode webchat client.
13:00:44 <johnw> Data.Vector.Mutable
13:00:45 <beaky> so the default one is immutable?
13:00:45 <cdsmith> beaky: Vector is immutable.  MVector is mutable
13:00:53 <beaky> when should I use which?
13:01:15 <johnw> when you need mutability? :)
13:01:45 <johnw> if you're doing operations with large vectors where you typically just need to change one element, mutable vectors will save you lots of copying
13:01:46 <beaky> who needs mutability when you have monads :D
13:01:51 <beaky> ah
13:01:55 <johnw> but if you're transforming vectors left and right, mutability gains you little
13:03:02 <paolino> mutability is done in monads ST or IO
13:04:11 * hackagebot mono-foldable 0.1.0.0 - Folds for monomorphic containers  http://hackage.haskell.org/package/mono-foldable-0.1.0.0 (JohnLato)
13:04:13 * hackagebot mono-foldable 0.1.0.1 - Folds for monomorphic containers  http://hackage.haskell.org/package/mono-foldable-0.1.0.1 (JohnLato)
13:04:47 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
13:05:18 <ion> :-D
13:09:49 <kennyp> 3/wc
13:18:56 <beaky> how do I make haskell console output faster
13:21:21 <tromp> avoid buffering?
13:21:33 <beaky> ah how do i do that
13:21:34 <tromp> nec versapro ultralite atom
13:21:38 <tromp> oops
13:21:54 <tromp>   hSetBuffering stdout NoBuffering
13:23:49 <mauke> avoiding buffering will make things slower
13:24:41 <aristid> beaky: use a faster terminal emulator
13:25:08 <beaky> also how do I read from a file faster
13:25:24 <beaky> i am using Data.Text.IO
13:25:30 <mauke> make the file smaller
13:27:20 <aristid> beaky: i wasn't joking by the way. there are significant speed differences between terminal emulators.
13:28:08 <beaky> right
13:28:24 <beaky> some do some magic to scroll faster :D
13:29:11 * hackagebot mono-foldable 0.1.0.2 - Folds for monomorphic containers  http://hackage.haskell.org/package/mono-foldable-0.1.0.2 (JohnLato)
13:29:22 <beaky> maybe I can use mmap so I don't have to read the whole file
13:29:38 <beaky> or is that a bad idea
13:29:57 <mauke> why does that require mmap?
13:30:21 <beaky> i need to pick a random line from the file
13:30:38 <Clint> how will you know where the lines are?
13:31:05 <arnsholt> Was about to say the same thing
13:31:12 <beaky> ah
13:31:27 <arnsholt> To pick a random line, you first need to find out how many lines there are and where they are
13:31:28 <beaky> what i do now is read the file into a Vector Text
13:31:32 <mauke> arnsholt: not really
13:31:41 <sellout-> Well, how good does the distribution have to be?
13:31:43 <mauke> you can do it in one pass, streaming
13:32:32 <arnsholt> How do you avoid first finding the lines and then picking one? Not obvious how that works
13:32:50 <arnsholt> I didn't mean to imply that you have to store the whole shebang in memory
13:33:18 <sellout-> You could pick a random byte and then find the newline on either side of it. It makes long lines more likely than short ones, though.
13:33:39 <arnsholt> True, true
13:33:42 <Clint> weighted distribution
13:33:54 <mauke> arnsholt: perldoc -q "random line"
13:34:55 <sellout-> Yeah, there’s some thing where you grab each line with probability 1/lines_read or something like that.
13:35:11 <sellout-> Then, at the end, you have your random line.
13:37:09 <beaky> ok i will stick to loading the entire file to a vector
13:37:16 <beaky> since it is probably fastest
13:39:06 <arnsholt> mauke: Ooooh, that's clever!
13:41:01 <arnsholt> I'm gonna have to look that up in TAoCP tomorrow. Sounds like a useful trick to know more about
13:52:06 <veryrandomname> What kind of types are Int, Double and Char ? They have no visible constructors!?
13:52:35 <joelteon> They do have constructors, they're just in GHC.*
13:53:05 <elliott> veryrandomname: built-in ones.
13:53:13 <elliott> it's up to your implementation.
13:53:25 <joelteon> veryrandomname: you can just give a numeric literal a type signature, and you'll magically get a value of that type for free.
13:54:22 <beaky> "liftM2 (>>) print playHangman =<< playHangmanTurn h" what does this line do?
13:54:37 <mauke> excessive cleverness
13:55:06 <beaky> how do I refactor it now that I forgot what it did :(
13:55:20 <beaky> I think the part on the right of =<< runs first?
13:55:35 <mauke> http://mauke.hopto.org/tmp/flow.png
13:55:52 <beaky> then it prints the result and applies playHangman to it?
13:55:54 <beaky> ah
13:56:46 <shachaf> mauke: =<< and ap's pictures are mirrors of each other? That sounds suspicious.
13:57:02 <shachaf> (Since one is Applicative and one is Monad.)
13:58:18 <veryrandomname> are the numbers constructors?
13:58:40 <mauke> shachaf: this is the (e ->) instance
13:58:48 <shachaf> Oh.
13:59:10 <veryrandomname> They are treated like constructors without arguments right?
13:59:39 <veryrandomname> no they're not
14:00:25 <YayMe`> Is Yi promising or mostly a dead project?
14:01:25 <edwardk> dead afaik
14:02:29 <acowley> emacs and ghc-mod are so good, I wish it was easier to get them setup
14:04:46 <johnw> acowley: I think hdevtools in some cases is even better
14:04:54 <johnw> and i prefer to use hdevtools with flycheck
14:04:55 <kakos> Anyone manage to successfully install glib in cabal 18?
14:04:56 <acowley> johnw: Yeah, I believe it.
14:05:12 <johnw> i think modern flycheck even come preconfigured to use hdevtools as a Haskell checker
14:05:14 <acowley> johnw: I worry that I'll lose some ghc-mod facility with just flycheck
14:05:20 <acowley> But that's self-inflicted FUD
14:05:41 <johnw> SIFUD
14:06:02 <acowley> Does it do all the type insertion and completion stuff ghc-mod does?
14:06:33 <johnw> no
14:06:39 <johnw> none of it
14:06:53 <hpaste> kakos pasted “glib Install Failure” at http://lpaste.net/92863
14:07:01 <acowley> Oh, well that's a downside
14:07:22 <kakos> So, when I try to install glib with Cabal 1.18, I get that error
14:07:34 <johnw> what do I import to get Constraint?
14:07:34 <Saizan> anything good for "jump-to-definition", or should i use hasktags?
14:07:38 <kakos> Any ideas how to resolve that?
14:07:59 <YayMe`> My haskell install may be borked; i had a good while ago updated to current GHC and pretty much pushed everything up to current stuff so as to no longer be on the "platform" (in windows), no real issues with anything until now I'm getting some errors installing hashable so failing lens, and some other stuff about can't find CULLong
14:08:19 <shachaf> @google what do I import to get Constraint? ghc
14:08:20 <lambdabot> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html
14:08:20 <lambdabot> Title: GHC.Exts
14:08:26 <shachaf> Looks like GHC.Exts. :-)
14:08:28 <johnw> haha
14:08:36 <johnw> i never thought to google with my full question as the query
14:08:45 <johnw> was googling "ghc constraint kind", but just not finding it
14:09:10 <acowley> I hope that's fixed in 7.8
14:09:12 * hackagebot HaRe 0.7.0.4 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.4 (AlanZimmerman)
14:09:14 <acowley> I always have to google for it, too
14:09:26 <Saizan> kakos: seems like you'd need to edit the source
14:09:35 <acowley> Saizan: I think that's the best way
14:10:40 <YayMe`> acowley: much though I like emacs, I've never been able to get any of the advertised haskell facilities beyond coloring and C-c,C-l to work. Which alone does ok since I only play Haskeller but some autocompletion and checking would be very nice. I've installed a hand full of things to try and get it but none of them ever seem to work.
14:10:43 <monochrom> Saizan: if emacs and haskell-mode, (add-hook 'haskell-mode-hook 'imenu-add-menubar-index), then you get a menu "Index" that let's you jump to definitions.
14:10:52 <joe9> I have this function: runTestTT . TestList :: [Test] -> IO Counts , I want to convert it to [Reader Device Test] -> Reader Device IO Counts. I cannot figure out how to do so. Any thoughts, please?
14:11:12 <joe9> How do I extract the Test portion of Reader Device Test.
14:11:26 <acowley> YayMe`: You've tried following the instructions on http://www.mew.org/~kazu/proj/ghc-mod/en/install.html
14:11:33 <Saizan> monochrom: how does it determine where to jump?
14:11:45 <monochrom> I don't know. it's magic.
14:12:09 <YayMe`> acowley: this is new, I only ever find http://www.haskell.org/haskellwiki/Emacs
14:12:37 <monochrom> it does not use hasktags or etags or any tags
14:12:51 <acowley> YayMe`: Give ghc-mod a shot. I'm also trying out the new haskell-interactive mode for its cabal repl support, but it's not 100% great
14:12:55 <joe9> mapReader (runTestTT . TestList) :: Reader r [Test] -> Reader r (IO Counts)
14:14:21 <joe9> :t mapReader (runTestTT . TestList) . sequence
14:14:21 <lambdabot> Not in scope: `runTestTT'
14:14:22 <lambdabot> Not in scope: data constructor `TestList'
14:14:27 <monochrom> kakos: --cabal-lib-version=1.16.0 may be useful. (replace 1.16.0 by whichever actual version you have)
14:18:04 <YayMe`> edwardk if Yi is dead, was it ever any quality? Is it still open source and functional to the point that I could play with the source code? (Was the code terrible?)
14:18:34 <YayMe`> or rather, does anyone know?
14:19:58 <Lethalman_> YayMe`, #yi
14:20:28 <acowley> YayMe`: I think any lack of enthusiasm for Yi is more due to the enormity of the task than the code itself.
14:21:29 <YayMe`> acowley: So if I could wrap my head around the available code, I could play with it for fun?
14:22:01 <acowley> YayMe`: I don't know anything about the code base
14:38:06 <S_J> What does haskell simplify in terms of concurrency for the programmer? or is it more of a benefit with parallellism?
14:38:21 <haasn> both
14:38:29 <haasn> it simplifies concurrency because actions are first class
14:38:37 <S_J> as i see it for data shared between threads the code might be neater in haskell but it is still the same ideas
14:38:55 <haasn> that too
14:39:18 <monochrom> that is a deep question
14:39:37 <monochrom> it is a suitable essay topic for an essay-writing class
14:40:06 <haasn> I want to have classes where I write essays on Haskell :|
14:40:28 <Reite> how can I do "myVar <- someAction <|> otherAction" where someAction and otherAction have the signature IO (Maybe a)
14:40:48 <monochrom> you can write on your blog. it doesn't get you a grade, but you get to write essays
14:41:22 <Hafydd> What if #haskell is my blog?
14:41:25 <Lethalman_> :t liftA2 (<|>)
14:41:25 <lambdabot> (Applicative f, Alternative f1) => f (f1 a) -> f (f1 a) -> f (f1 a)
14:41:40 <monochrom> then I may have to ban you for flooding :)
14:42:27 <monochrom> but if your "blog" means 80 characters per day, that is not flooding :)
14:43:16 <arkeet> #haskell doesn't make for a good blogging platform.
14:43:45 <monochrom> it doesn't even support CSS or javascript XD
14:44:09 <arkeet> if you do 80 characters per day, consider twitter
14:44:13 * hackagebot snap 0.13.0.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.0.1 (DougBeardsley)
14:46:28 <edwardk> dolio: An interesting corollary to the third homomorphism theorem would seem to be that if tip is a unit, then all sequence algebras are monoids.
14:47:15 <edwardk> How is that for obscure interests coinciding?
14:49:26 <edwardk> Without it I think I can get them all to be semi groups
14:50:23 <edwardk> Er semigroup homomorphisms
14:56:37 <Reite> Lethalman_: thanks!
15:08:34 <YayMe`> edwardk why might lens gripe that hashable didn't work for it when hashable is already installed?
15:10:06 <hpaste> YayMe` pasted “Lens install fail” at http://lpaste.net/92864
15:12:41 <YayMe`> ah maybe it's my cabal being outdated, updating that..
15:14:08 <edwardk> That looks like something pretty independent of lens
15:14:51 <YayMe`> edwardk: plausibly. Figured worth asking anyway
15:15:58 <acowley> YayMe`: Try removing hashable and let cabal-install reinstall it with lens
15:16:29 <YayMe`> acowley: Alrighty. I think i'm going to see if I can't get my whole system refreshed first...
15:16:33 <YayMe`> What's current stable GHC?
15:16:36 <levi> Hashable has been causing lots of trouble lately. :/
15:16:44 <YayMe`> I'm running 7.6.3 which I think is *somewhat* current
15:16:51 <donri> YayMe`: that is
15:17:24 <donri> levi: i like how they decided to finally include it in the haskell platform, but not the then-new version with breaking changes
15:17:25 <YayMe`> levi: that's the response I was hoping to hear, gives me hope it may be less my system and more the dependency cloud
15:17:42 <donri> YayMe`: it's not hashable in your case
15:17:52 <YayMe`> and problems in the dependency cloud had been solved by others
15:18:07 <YayMe`> donri: yeah, but maybe... or not...
15:18:27 <donri> if you're getting symbol errors chances are your whole ghc/cabal setup is f*cked :)
15:18:44 <levi> donri: Well, it probably had something to do with all the hashable version constraints and resulting package re-installs.
15:18:50 <YayMe`> donri: Nonsense, my ghc/cabal setup is uh..colorful...totally different situation...
15:19:15 <donri> levi: ?
15:20:22 <levi> Well, there were segfaulting versions of hashable, so some packages now have version constraints that disallow certain version ranges.
15:20:53 <donri> that sounds fun, though i don't think that's what YayMe` is seeing
15:21:18 <YayMe`> levi: How do I uninstall hashable?
15:21:34 <donri> ghc-pkg unregister hashable
15:21:37 <YayMe`> (there's no uninstall facility in all of haskells package-land is there?)
15:21:40 <YayMe`> Oh good
15:23:15 <geekosaur> there is no true uninstall, that just makes ghc forget it's installed
15:23:40 <geekosaur> but you can typically do the rest (if it's a user package) by removing its tree under ~/.cabal if you really feel the need to expunge it completely
15:24:02 <acowley> When I have multiple executables in a single package, it's frustrating that cabal-install hits them all when I just want to build/run one
15:26:27 <donri> acowley: with the new cabal-install you can do cabal run name-of-exe
15:26:33 <donri> similarly with cabal build
15:26:38 <acowley> donri: That's what I'm talking about
15:26:52 <acowley> donri: It still does "Preprocessing executable 'oops'..."
15:27:11 <donri> oh ok. i think "build" isn't supposed to do that, anyway, not sure about "run"
15:27:17 <acowley> donri: Both do it
15:27:21 <dcoutts_> donri: did we implement "run"?
15:27:28 * dcoutts_ wasn't aware of that
15:27:36 <donri> dcoutts_: seems so!
15:27:40 <dcoutts_> hmm
15:27:41 <dcoutts_> ok
15:27:43 <acowley> I've been heavily using run exename for the past week
15:27:53 <YayMe`> So I did the ghc-pkg unregister and recache of that (had to do a couple others to get rid of hashable), lens still failed, is hashable 1.2.0.10 the correct version of hashable?
15:27:57 <dcoutts_> acowley: works ok?
15:28:02 <acowley> dcoutts_: Except for this issue
15:28:33 <acowley> dcoutts_: A related issue is that running one executable requires the build-depends of all executables be satisfied
15:28:51 <donri> YayMe`: the correct version is either the one haskell-platform ships or whatever is the latest on hackage
15:28:55 <dcoutts_> acowley: sorry, you're saying that cabal run blah, causes all exes in the package to be built?
15:29:03 <YayMe`> ohh I know what's wrong
15:29:35 <dcoutts_> acowley: oh that you can't really avoid, we do still need to configure the package, and that does require all components deps to be satisfied
15:29:39 <acowley> I'm cleaning and rebuilding now
15:29:53 <acowley> I asked it to build one executable in particular
15:30:12 <dcoutts_> acowley: unlike with test-suite/benchmarks we don't have any way to selectively turn off certain components when configuring
15:30:24 <acowley> dcoutts_: What's happening in the Preprocessing executable stage?
15:30:36 <dcoutts_> acowley: I don't know, you tell me
15:30:38 <acowley> (build from clean still running)
15:30:46 <acowley> D:
15:30:57 <Ghoul_> Oh my, by far the greatest thing about haskell
15:31:16 <Ghoul_> is to be able to just *make up* crazy syntax and find it already exists when a few extensions are enabled
15:31:18 <acowley> My highly insightful observation is that it prints "Preprocessing executable" to the terminal and thinks for a bit before moving on
15:31:48 <dcoutts_> acowley: it's probably actually running pre-processors
15:32:04 <dcoutts_> acowley: why do you suspect otherwise? and if you want to find out, use -v
15:32:15 <acowley> (still rebuilding)
15:33:12 <acowley> Okay interesting
15:33:19 <acowley> cabal build was well behaved
15:33:27 <acowley> I did "cabal build foo" and it did that
15:33:35 <acowley> then I did "cabal run foo" and it's building "bar"
15:33:48 <acowley> I'm confident it will run "foo"
15:33:57 <acowley> but this slows down the iteration time
15:34:06 <dcoutts_> this is what happens when I don't review patches :-)
15:34:31 * dcoutts_ wrote the "cabal build target" code that selects just the right components to build
15:34:41 <acowley> copy/paste the good code
15:34:43 <acowley> :P
15:34:47 <dcoutts_> acowley: can you file a ticket please?
15:34:54 <acowley> dcoutts_: Yes
15:35:07 <dcoutts_> acowley: indeed, that's the solution, or calling the good code :-)
15:35:10 <dcoutts_> acowley: thanks!
15:35:12 * dcoutts_ disappears
15:35:32 <YayMe`> levi: has anybody seen issue with hashable in the case of 64-bit system?
15:40:09 <YayMe`> There any way to tell ghc-pkg to unregister everything cabal has installed (as in not base or whatever primitives etc) ?
15:40:46 <monochrom> no, but see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove . in fact see the whole thing.
15:41:31 <sm> usually the essentials are installed in your system-wide package db, so you can just remove your user's package db
15:42:39 <YayMe`> levi: thanks for the mention, a little googling and it's *not* my fault https://github.com/tibbe/hashable/issues/46
15:42:52 <YayMe`> sm: which is where?
15:43:23 <YayMe`> "We're being screwed by the fact that MinGW expects our object file to be linked against its library so that the forwarding thunks can be linked in, but the ghc runtime linker isn't in on the game, doesn't load it, and we die."
15:46:42 <Ghoul_> Heads up installing the "AES" package breaks mtl in ghc-pkg
15:46:49 <acowley> Seems like some progress was made on that: http://ghc.haskell.org/trac/ghc/ticket/7097#comment:19
15:53:26 <YayMe`> acowley: So if I replace my mingw-w64 headers as it dictates, and rebuild my GHC I might have it all solved eh
15:53:34 <YayMe`> or do I even need to rebuild GHC for that?
15:53:53 <acowley> YayMe`: I don't know
15:54:21 <kuribas> Is there something better than "reverse $ scanl f x l"?
15:54:25 <YayMe`> acowley: Fair. I suppose I can try and find bryan's mingw-w64 headers and give them a shot then if no go, rebuild GHC afterwards
15:54:49 <acowley> Is crypotgraphically sound hashable critical to your intended uses?
15:55:03 <acowley> He offered a flag as a workaround
15:56:09 <YayMe`> acowley: I didn't catch the flag... but there's a couple different things I was having failures with which are likely caused the same way, rather just right the system so I can have less package building failures
15:59:57 <adnap> Can I get lambdabot to join a channel? I want to show somebody things in private
16:01:23 <Clint> apt-get install lambdabot
16:01:51 <shachaf> ...lambdabot is in an APT repository somewhere?
16:01:53 <shachaf> That can't be good.
16:02:38 <Clint> for over a year now
16:02:55 <Clint> actually over two years
16:03:39 <jfischoff> so is data-reify an effective way to turn an AST into ASG for efficent substituion?
16:06:59 <quchen> kuribas: scanr might be worth a look. It's not reverse-scanl, but it's somewhat reversed. Maybe it's something you can work with.
16:07:20 <kuribas> quchen: I looked at it, but the seeed value needs to be at front.
16:07:43 <tibbe> YayMe`: hopefully that will be fixed soon
16:08:06 <kuribas> It's 0(n) anyway :)
16:08:15 <quchen> Then I guess you're out of luck. However, to calculate the head of "reverse <scanl>", you'll have to calculate the full foldl it encapsulates, and in the process all the other values as well.
16:08:24 <quchen> So the performance overhead shouldn't be too bad.
16:09:16 <kuribas> no, probably a small constant.
16:09:31 <quchen> (That is me doing tired evaluation of Haskell. The small constant could be Graham's Number.)
16:09:50 <kuribas> lol
16:10:04 <kuribas> It's O(n) either way.
16:10:14 <quchen> Asymptotics isn't all that matters.
16:10:39 <quchen> More precisely it's something that doesn't matter at all many cases.
16:10:47 <quchen> +in
16:11:11 <enthropy> have people seen instances of Data for extensible records?
16:12:04 <quchen> kuribas: There should be big-O notation for running profilers. O(fair enough), O(awful) and son on. :-)
16:12:52 <kuribas> My fear of reverse and append is probably unjust.
16:13:03 <enthropy> O(h no)
16:13:05 <arkeet> reverse is fine if you only do it once.
16:13:22 <quchen> So is append.
16:14:22 <kuribas> I am going to leave it, because I doubt this will be a bottleneck.
16:14:26 * haasn solemnly laments the fact that splitOn/intercalate do not form proper inverses
16:14:46 <arkeet> they do when you restrict one of the domains.
16:17:06 <kuribas> quchen: It would be an interesting exercise to benchmark the difference between "reverse $ scan ..." and a worked out "reverseScanl".
16:17:30 <quchen> On a side note, many "append" operations can be done using minimal cost and laziness. "foldr (:) []" sort of appends the remaining list to each cons cell.
16:17:44 <kuribas> yes
16:18:12 <quchen> Anyway, yes, I encourage you to give out that scanl problem to your students and get a solution for free. It's called "free theorems". ;-)
16:18:31 <kuribas> haha, I don't have programming students.
16:19:14 <kuribas> But when I have I will :-)
16:19:17 <quchen> Then you're left with the choice between a) solving the problem yourself or b) getting students! :-P
16:19:33 <quchen> Anyway, I'm off to sleep, have a good night
16:19:47 <kuribas> yes, good night
16:20:32 <Dodek> hmm
16:20:47 <Dodek> i need to generate ten thousand _different_ random numbers
16:21:14 <Dodek> do you have any suggestions about the easiest way to do it?
16:21:20 <joelteon> what range
16:21:34 <Dodek> from 0 to 2^32-1
16:21:50 <arkeet> might be easiest just to generate a bunch, remove duplicates, and take the first 10000.
16:22:24 <Dodek> hm
16:22:43 <arkeet> nub is lazy =)
16:22:57 <Dodek> i wonder how much i have to generate to have 0.5 probability that there will be ten thousand different numbers in there
16:23:05 <Dodek> how many, i mean
16:23:21 <arkeet> that is the https://en.wikipedia.org/wiki/Birthday_problem
16:23:46 <Dodek> it's close, but it's not the same
16:23:55 <arkeet> well it's the same situation.
16:24:15 <arkeet> but you could generate infinitely many.
16:24:17 <Dodek> birthday problem asks how many i have generate to have 0.5 probability that some two will be the same
16:24:40 <arkeet> you know that's the same thing
16:24:40 <arkeet> :p
16:24:57 <Dodek> nah, it's not
16:25:00 <arkeet> yes it is
16:25:18 <Dodek> how's that?
16:25:29 <arkeet> no two are the same  =  all are different
16:25:40 <arkeet> 1 - 0.5 = 0.5
16:25:41 <arkeet> done
16:26:02 <arkeet> hm.
16:26:05 <Dodek> i don't want all of them to be different
16:26:10 <arkeet> you don't?
16:26:38 * arkeet thought that was the question
16:26:41 <Dodek> i asked how many i have to generate to have 0.5 probability that _after removing duplicates_ there will be at least 10 000 different numbers.
16:26:46 <evancz> does anyone know anything about nameservers or where I might go to learn such things
16:27:01 <arkeet> hm
16:27:04 <evancz> I recently got a .io domain, and I don't really know who to ask for help
16:27:07 <arkeet> why are you concerned with probability?
16:27:12 <arkeet> evancz: ##networking maybe?
16:27:28 <Dodek> arkeet: i'm a mathematician, and find this kind of questions interesting
16:27:47 <arkeet> Dodek: ok, I thought you just wanted a way to generate 10000 distinct random numbers.
16:28:08 <Dodek> arkeet: well, i also want that :)
16:29:02 <evancz> arkeet: okay, I'll check with them, thanks :)
16:35:29 <Maior> so I'm looking at using http://hackage.haskell.org/packages/archive/hedis/0.4.1/doc/html/Database-Redis.html but I'm possibly being dense - I really don't understand which bit of an  "Either Reply (Maybe (ByteString, ByteString))" might contain my data (specifically looking at blpop...)
16:38:30 <m3ga> Maior: an 'Either a b' by convention returns a correct result in 'Right b' or an error message in 'Left a'
16:38:51 <Maior> ah, ok, thanks
16:39:04 <Maior> that makes more sense
16:39:12 <haasn> (the reason being that Either a is conveniently a Functor, Applicative and Monad)
16:39:19 <augur> is there an interpretation of haskell from a lambda-mu perspective?
16:39:26 <haasn> with the semantics of ‘Left’ being the “failure-like” case
16:39:29 <Maior> haasn: ahhhh
16:39:31 * jfischoff mumbles something about hedis not needing nested monads
16:39:50 <Maior> haasn: ok that's cool
16:40:28 <augur> m3ga: i prefer using a proper error type, honestly. identical but better names
16:41:09 <augur> m3ga, Maior:  data Failable e a = Failure e | Success a
16:41:16 <m3ga> augur: yes, i agree, but Maior is dealing with a library that returns Either
16:41:22 <Maior> augur: that would appear more obvious to me, yes!
16:41:23 <augur> o
16:41:23 <augur> :(
16:41:43 <jfischoff> I don't see why the Redis monad can't deal with failure on its own there. Additionally I think RedisTx and Queued could be rolled together
16:41:50 <Maior> right, now to untangle this Maybe (ByteString, ByteString)
16:42:31 <Maior> (aka "Why isn't this a Maybe ByteString ?)
16:42:35 <Maior> +"
16:44:05 <jfischoff> which function is this?
16:44:12 <Maior> jfischoff: blpop
16:44:54 <Maior> oh my bad
16:45:01 <Maior> first is key, second is value, sorry
16:45:32 * jfischoff nods
16:46:54 <haasn> how good is GHC at optimizing something like  f (Const x) = Const x -- data Const a b = Const a ? is it equivalent to f = unsafeCoerce ?
16:49:46 <mhr> Would you advise Haskell as a first functional language? I'm teaching some kids at a programming club I founded, so I'm teaching them Python first, and then for those that won't to go the imperative route, they can learn C/C++/Java, and for the functional, they can learn Lisp or Haskell or OCaml. What's a good first functional language? I'm worried that the monads and the laziness will confuse people so much that they overlook the big pi
16:49:47 <mhr> ?
16:50:17 <mhr> *want to go the imperative route
16:50:30 <luite> your line got cut of at "overlook the big pi"
16:50:31 <shachaf> Your message was cut off at "overlook the big pi"
16:50:46 <jfischoff> Monads don't scare beginners that much i've found
16:50:50 <tabemann> OCaml can be programmed in as simply an imperative language with some nice features; if you actually want them to learn FP, Haskell'ls probably a better choice
16:50:51 <mhr> darn it."I'm worried that the monads and the laziness will confuse people so much that they overlook the big picture. What do you guys think?"
16:50:59 <jfischoff> everything is scary so there is much different
16:51:12 <shachaf> I don't think you should worry about laziness for a first language. It's pretty natural unless you have a reason to expect something else.
16:51:12 <mhr> hmm, okay. but then laziness.
16:51:28 <shachaf> And you don't even need to talk about "monads".
16:51:32 <mhr> they would have an expectation for eagerness, as they're coming from Python, shachaf.
16:51:33 <byorgey> mhr: laziness isn't confusing until you want to start reasoning about time and space usage.
16:51:33 <mhr> true
16:51:37 <luite> mhr: i don't think laziness is confusing, if they get confused by it you shouldn't have taught them python first ;)
16:51:39 <haasn> there's always helium if you're afraid of typeclass overloading scaring off first-timers
16:51:42 <jfischoff> laziness is not observable in most of the code beginners write
16:51:42 <mhr> haha
16:51:50 <haasn> and I'd introduce them to GHCi first
16:51:54 <haasn> without even touching IO and monads
16:51:58 <shachaf> mhr: What's an example where laziness is confusing?
16:52:14 <shachaf> Laziness will only make more programs run.
16:52:16 <monochrom> both laziness and eagerness are confusing
16:52:31 <shachaf> Yes. Many things are confusing.
16:52:37 <haasn> except monoids
16:52:40 <haasn> you should start with monoids
16:52:40 <tabemann> it's just the ways in which they are confusing are different
16:52:46 <monochrom> in fact, false dichotomy. presumption is confusing. people presume, therefore they confuse themselves.
16:52:55 * Maior is confused
16:52:59 <mhr> shachaf: it's just that I'd have to explain then what laziness vs. eagerness is, whereas in Python they took the execution order for granted
16:53:09 <shachaf> mhr: Why do you have to explain it?
16:53:15 <mhr> monochrom: good point.
16:53:15 <haasn> I don't think you have to explain to them what laziness is
16:53:27 <shachaf> Pretend Haskell is strict. It'll still work.
16:53:35 <Maior> mhr: honestly? I found it so much easier to explain FP to people once I realised _my_ assumptions were heavily ingrained
16:53:37 <haasn> oh, wait, you're teaching them python first? I wouldn't do that
16:53:42 <haasn> I mean, I don't want to start a language war
16:53:50 <haasn> but teaching them to entirely conflicting mental models is probably not a very smart thing to do
16:53:56 <Maior> mhr: because I could then do "hey, it's like maths"
16:54:00 <Maior> and, yeah, what haasn said
16:54:20 <byorgey> haasn: "don't do that thing you already did" is not very useful advice ;-)
16:54:25 * tabemann doesn't get the whole "python is easy" thing, e.g. with dynamic typing, there's all kinds of badness that can occur that will only be caught at runtime
16:54:54 <mhr> haasn: I don't want to teach Python, I want to teach Lisp. my co-founders are a C++ and Java guy, so Python was the best compromise where its an imperative/functional fusion kind of thing going on. plus it's OO.
16:54:59 <Maior> tabemann: "in some ways, it's easier to think about a magic list of instructions where you hope the edge cases occur than it is to think about maths"
16:55:02 <tabemann> whereas with *real* static typing (not the pseudo-static typing of the likes of Java and Scala), there's so many classes of errors that can be caught before the code ever runs
16:55:03 <shachaf> haasn: You're not very good at this "not starting a language war" thing, I think.
16:55:04 <acowley> The "python is easy" message is in part due to the availability of libraries
16:55:23 <Maior> tabemann: different sort of easy
16:55:25 <hpc> the "python is easy" message is mostly from not having to write correct programs
16:55:33 <Peaker> dynamic typing means the language is smaller.  racket is a smaller/simpler language than typed racket
16:55:33 <arkeet> haha
16:55:40 <hpc> in much the same way as mongodb gets to be fast by not writing your data to disk
16:55:41 <monochrom> some people presume eagerness; they will be confused. some other people presume laziness; they will be confused. discourage presumptions. encourage curiosity, exploration, empirical evidence, the scientific method.
16:55:45 <Maior> hpc: ooh that's a nice explanation
16:55:48 <sm> hpc: heh
16:56:01 <Peaker> it's easier to learn a smaller language to the degree where you can write small useful programs
16:56:09 <sm> better not to drag NOSQL into this I think
16:56:19 <mhr> haasn: and I think you're right, I don't need to explain what laziness or eagerness is, nor monads.
16:56:19 <Maior> sm: I'll stop asking about hedis :P
16:56:40 <Peaker> Typed languages require a beginner to learn all the type notation, at the very least
16:56:54 <hpc> can we talk about how nosql is the worst possible way of separating databases?
16:57:04 <jfischoff> Peaker: I am not seeing that
16:57:06 * arkeet ought to read that simplicial databases paper at some point
16:57:09 <haasn> “imperative/functional fusion kind of thing” sounds like Haskell
16:57:21 <hpc> i mean, i would rather use oracle than mongodb
16:57:29 <hpc> but i would also rather use acid-state than sqlite
16:57:39 <hpc> it's about how it functions as an actual database
16:57:55 <arkeet> acid-state is a database?
16:57:58 <mhr> haasn: I disagree, Haskell monads are supposed to abstract out the imperative
16:58:09 <jfischoff> Peaker: with my wife at least. She is writing Haskell without any type signatures, for better or worse.
16:58:18 <hpc> arkeet: it's a non-relational database
16:58:23 <arkeet> fine
16:58:24 <hpc> it stores a haskell data type
16:58:33 <hpc> sqlite is a relational non-database
16:58:37 <arkeet> haha
16:58:38 <Peaker> jfischoff: well, she has to read the error messages, written in type notation
16:58:38 <shachaf> Monads don't really have anything to do with "the imperative".
16:58:40 <arkeet> how so?
16:58:43 <Maior> hpc: why's sqlite a non-database?
16:58:47 <shachaf> But a monad war won't do this channel any good, either.
16:58:47 <tabemann> the only reason why one can't really write haskell code without type signatures is the goddamn monomorphism restriction
16:58:49 <hpc> it doesn't check types
16:58:50 <mhr> I'm just thinking that... writing a lazy program is a different way of thought compared to writing an eager program, at least it is for me. It's difficult to switch mindsets... what kinds of errors would appear by assuming everything is eager in Haskell?
16:58:54 <monochrom> here is an example where eager languages disappoint curious minds. try to define a function "joy" such that "joy c x y" behaves exactly as "if c then x else y". it is easy in Haskell. it requires cheating (butchering the question) in many other languages. this may guide you what to teach. do you want to teach disappointment?
16:58:54 <hpc> you can put a string in a numeric column
16:59:01 <hpc> and it doesn't have acid properties
16:59:06 <jfischoff> Peaker: kinda of. When I started I didn't "read" besides the line number
16:59:09 <hpc> try having two programs operate on the same file
16:59:10 <shachaf> mhr: No errors, other than performance considerations.
16:59:18 <haasn> mhr: you can write pretty imperative-looking code just fine in Haskell (a purely functional language): http://augustss.blogspot.de/2009/02/more-basic-not-that-anybody-should-care.html or for a non-esoteric example, modern code with lens+StateT
16:59:32 <mhr> hmm, didn't know that, cool ref
16:59:35 <jfischoff> Peaker: I agree with you that there is more to learn
16:59:36 <shachaf> mhr: Every program that evaluates to a value with strict evaluation evaluates to the same value with non-strict evaluation.
16:59:36 <hpc> or try performing a big sqlite operation and then having it crash
16:59:39 <shachaf> haasn: Oh, come on.
17:00:00 <haasn> shachaf: it's a joke, sure, but I think it serves a point
17:00:12 <arkeet> what point?
17:00:14 <jfischoff> but its not true you have to have a firm grasp on the type system before you can start writing code
17:00:15 <Peaker> jfischoff: I think you can probably teach a beginner scheme and he can probably write some small useful programs in a few hours
17:00:17 <mhr> haasn: haha looked at the actual link, wow....
17:00:17 <arkeet> that haskell syntax can be heavily abused?
17:00:18 <haasn> in the ‘Haskell is capable of letting you define your own control flow abstractions’ sense
17:00:19 * tabemann is always perplexed by people who think that writing imperative-type code is harder in Haskell - as it is *easier*, because now side-effects are first class!
17:00:23 <jfischoff> maybe you should, but that is another story
17:00:27 <hpc> haasn: entirely seriously, haskell is my favorite imperative language
17:00:33 <Peaker> whereas Haskell will take significantly longer because the language is so much bigger
17:00:33 <hpc> haasn: and my favorite functional language is perl
17:00:36 <haasn> hpc: lens is mine :)
17:00:50 <mhr> tabemann: it's not harder, it's just different compared to how "imperative" programming languages do it
17:00:54 <jfischoff> Peaker: but you don't teach them the whole language
17:00:57 <tabemann> yes - haskell is the best imperative language ever
17:01:13 <Peaker> tabemann: they're always first-class, slightly more cumbersome though (IO a   ~=   () -> a)
17:01:14 <jfischoff> I guess I don't have the write reference point
17:01:23 <Peaker> tabemann: in languages that hide their IO in the (->) type, that is
17:01:25 <shachaf> Haskell "best imperative language ever", reports #haskell
17:01:28 <jfischoff> I've thought point Haskell but not other languages so I don't really know
17:01:36 <arkeet> and then people ask you why they can't read a line and pass it to a function the same way and then they get confused because you didn't tell them about the IO type.
17:01:40 <jfischoff> I would be interested in observing the differences though
17:01:43 <mhr> if some kids want to learn C, then they can use what they know about imperative Python and apply it to C, and if some kids want to learn Lisp/Haskell/Something, they can take what they know about functional Python and apply it to Lisp/Haskell/Something
17:01:44 <ion> shachaf: I don’t see the problem, #haskell is unbiased.
17:01:49 <Peaker> jfischoff: I think even the subset they need to know is bigger
17:02:01 * jfischoff shrugs
17:02:07 <jfischoff> probably I don't know
17:02:17 <arkeet> what is functional Python?
17:02:22 <hpc> ion: "apple found guilty of ebook price fixing, penalty is they can't do it again for five years"
17:02:35 <tabemann> Python is functional like C# is functional....
17:02:37 <ion> FWIW, i also find first-class IO actions to result in a much better imperative language.
17:03:03 <hpc> i am a huge fan of loop $ \i -> do syntax
17:03:06 <mhr> okay, so I think you guys adequately answered my question, thanks, I'm going with Haskell...
17:03:30 <arkeet> well, haskell is a big language compared to, say, scheme.
17:03:32 <hpc> and async, which is just radsauce
17:03:34 <mhr> arkeet: hmm, I thought there's tail recursion in Python, I thought wrong. shit haha.
17:03:40 <arkeet> there sure isn't.
17:03:44 <hpc> perl has tail recursion!
17:03:48 <Peaker> ion: imperative languages generally have first class IO actions too, they just call them "functions"
17:03:48 <hpc> (via the goto keyword)
17:03:58 <arkeet> ruby spec leaves it implementation-defined, which is as good as not having it.
17:04:02 <hpc> Peaker: imperative languages like java!
17:04:48 <Peaker> Java is a pain, indeed :) but it is a strawman for imperative languages
17:04:57 <ion> peaker: So instead of being able to put print "hello"s to a list i’ll have to put (\() -> print "hello")s to a list and later apply what i choose to (). I find that much less appealing.
17:05:05 <Peaker> (and ironically, also a strawman for how bad static typing is, often)
17:05:12 <hpc> Peaker: imperative languages like C!
17:05:18 <tabemann> the problem with Java's static typing is that it isn't *real* static typing
17:05:22 <hpc> no wait, you have to do manual lambda lifting
17:05:30 <arkeet> subtyping =(
17:05:34 <arkeet> does anyone know how subtyping works
17:06:01 <hpc> arkeet: you take a set theorist, turn them inside out, and put them in an engineering department
17:06:04 <Peaker> ion: that's not a big deal, and the counter-point is that you have to do a lot less lifting and (>>=) to connect up your first-class IO actions
17:06:07 <hpc> then a miracle occurs and you get junit
17:06:40 <tabemann> subtyping is one of those things that sounds like a good idea, but it really isn't a good one at all in practice, with most implementations
17:07:14 <hpc> i wish hash types were more theoretically sound
17:07:26 <tabemann> implementation inheritance breaks modularity, and even just interface inheritance makes pattern matching impossible or at least very limited
17:08:11 <elliott> haskell has subtyping too.
17:08:27 <hpc> no, it has class constraints
17:08:56 <elliott> lens does subtyping. it is undeniably a complex subtyping hierarchy
17:09:11 <elliott> it is implemented with constraints because they are powerful enough to do this kind of subtyping
17:09:17 <Maior> could I get some input on https://gist.github.com/doismellburning/6531569 please?
17:09:39 <Maior> (it works, but this is probably the first Haskell I've written doing anything with Monads or Channels or other libraries or Stuff)
17:09:47 <mhr_> seems that Python has first-class functions, but that's about it... and it's lambda syntax is crummy... darn. oh well. thanks for answering my question, adios.
17:10:25 <jfischoff> existential quantification is a lot like upcasting
17:10:50 <hpc> "a lot like" is a pretty dangerous thing to say in programming...
17:11:35 <jfischoff> well I don't know the precise relationship but it I find it is helpful analogy
17:12:40 <hpc> monads are a lot like upcasting
17:12:43 <acowley> tibbe: Thanks for the quick cabal-install fix!
17:13:02 <haasn> if lens is subtyping, then ‘cloneTraversal’ etc. seem to do just that
17:13:33 <shachaf> Lenses are like one form of subtyping, and prisms are like another.
17:13:34 <jfischoff> hpc: how?
17:13:34 <elliott> those aren't quite upcasting, no.
17:13:46 <haasn> then I don't understand what upcasting is
17:16:27 <Maior> I feel my "meh, ditch the Error, just return Nothing" in ^ is probably a bit shonky
17:17:21 <tabemann> in most cases returning Either or Maybe is a better choice than raising an exception - which should be limited to things that are *truly* exceptional
17:19:22 * hackagebot postgresql-simple 0.3.7.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.7.0 (LeonSmith)
17:19:33 <Maior> right, forkIO time
17:46:06 <joe9> mapReader (TestLabel "label" . TestCase) :: Reader r Assertion -> Reader r Test -- I have this. I want a function to do: [Reader r Assertion] -> Reader r Test
17:46:16 <joe9> Any suggestions on how I can  get that , please?
17:48:39 <joe9> Isn't there some application that can tell the  functions involved if you give it the prototype?
17:49:18 <Maior> Hoogle
17:50:06 <Maior> but I don't know enough about the types you have there
17:50:27 <Maior> (do you have a [Assertion]->Assertion?
17:50:29 <Maior> )
17:50:39 <Maior> (or [Assertion]->Test?)
17:51:07 <joe9> Maior, no, let me get that.
17:53:34 <joe9> :t mapReader (TestLabel "label" . TestCase . msum)
17:53:35 <lambdabot> Not in scope: data constructor `TestLabel'
17:53:35 <lambdabot> Not in scope: data constructor `TestCase'
17:53:35 <ekipan> iirc his Assertion = IO ()
17:54:03 <joe9> can I use msum here?
17:54:48 <Maior> :t msum
17:54:49 <lambdabot> MonadPlus m => [m a] -> m a
17:54:52 <Maior> oh
17:55:03 <joe9> :t mapReader (TestLabel "label" . TestCase . sequence_)
17:55:04 <lambdabot> Not in scope: data constructor `TestLabel'
17:55:04 <lambdabot> Not in scope: data constructor `TestCase'
17:55:10 <joe9> :t sequence_
17:55:11 <lambdabot> Monad m => [m a] -> m ()
17:56:10 <Maior> joe9: I'd guess at: msum $ map $ mapReader stuff
17:56:17 <Maior> but suspect it can be reduced somewhat
17:56:52 <joe9> is msum similar to sequence_? ie. does it evaluate all functions from left to right?
17:57:02 <Maior> er, possibly s/map/fmap/
17:58:25 <enthropy> > msum (cycle Nothing)
17:58:26 <lambdabot>   Couldn't match expected type `[m0 a0]'
17:58:26 <lambdabot>              with actual type `Data....
17:58:45 <enthropy> > msum (cycle [Just 1, Nothing])
17:58:47 <lambdabot>   Just 1
17:59:10 <enthropy> > sequence_ (cycle [Just 1, Nothing])
17:59:11 <lambdabot>   Nothing
17:59:23 * hackagebot courier 0.1.0.5 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.5 (PhilHargett)
17:59:45 <enthropy> joe9: both didn't evaluate everything (cycle makes an infinite list)
18:00:16 <haasn> joe9: they can't possibly since there's no sane to implement [m a] -> m a -- with just a Monad constraint
18:00:41 <haasn> joe9: imagine :: [Identity Void] -> Identity Void
18:00:54 <haasn> :t [] :: [Identity Void] -- clearly a valid input
18:00:55 <lambdabot> [Identity Void]
18:01:05 <haasn> no sane way*
18:01:24 <enthropy> there are plenty of "insane" functions in the Prelude then
18:01:31 <haasn> yes.
18:01:32 <enthropy> one more wouldn't hurt
18:01:33 <haasn> like head
18:01:44 <haasn> :t head :: [Identity Void] -> Identity Void
18:01:45 <lambdabot> [Identity Void] -> Identity Void
18:01:55 <haasn> but ‘sequence_’ is completely sane
18:02:00 <haasn> sequence, even
18:03:41 <Maior> does `cabal build` not transitively resolve things in `build-depends`?
18:03:55 <enthropy> it doesn't
18:03:58 <enthropy> use cabal install
18:04:27 <Maior> thanks
18:04:34 <monochrom> "cabal install" or "cabal install --only-dependencies"
18:04:44 <Maior> woo
18:04:55 <Maior> sorry, doing my first Real Haskell Applicationthing
18:09:31 <joe9> http://codepad.org/b4PWfZR6 I cannot find a function that can do [Reader r IO () ] -> Reader r Test. I get Reader r [IO ()] -> Reader r Test.
18:09:37 <joe9> any thoughts, please?
18:12:45 <bscarlet> joe9: What do you mean by (Reader r IO ())?
18:13:26 <bscarlet> Do you mean (Reader r (IO ()))?
18:13:47 <Peaker> @type reader $ \r -> mapM_ (`runReaderT` r)
18:13:48 <lambdabot> (Monad m1, MonadReader r m) => m ([ReaderT r m1 b] -> m1 ())
18:14:43 <joe9>  http://codepad.org/2Fkhva0l is the program. I am trying to change toReaderTest to the one in line 111
18:15:38 <bscarlet> Ah. Do you mean ReaderT, not Reader, in your original question?
18:16:00 <joe9> bscarlet: Yes, I am sorry about that.
18:16:38 <haasn> that is *quite* some GHCi prompt, joe9
18:16:52 <haasn> you can set it with :set prompt
18:17:28 <joe9> :set +r +s +t -- http://haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
18:25:11 <bscarlet> joe9: perhaps you need mapReaderT, then?
18:25:32 <joe9> bscarlet: cool, thanks.
18:25:57 <bscarlet> It won't do it alone, but I think it's the element you're missing.
18:30:10 <bscarlet> joe9: I think the actual expression you're looking for is something like  (mapReaderT (Identity . TestLabel "label" . TestCase) . sequence_)
18:35:14 <blackdog> I've got a problem with my haskell crawler - I think some threads are dying, but I don't know why. Is there a way to get a stacktrace (or even just the current function) of all the threads in a program?
18:35:43 <haasn> ‘current function’ doesn't make much sense in this context, and neither does a stack trace, really
18:36:18 <haasn> are you catching exceptions manually or stuff? I guess usually if a thread dies unexpectedly it'd be due to an exception which if uncaught should halt your program
18:37:40 <hpaste> chexxor pasted “How to get N? - Sieve of Sundaram Point-free” at http://lpaste.net/92869
18:38:27 <chexxor> any tip? Is what I'm looking for impossible?
18:40:00 <chexxor> I am writing a point-free function, but I want to reference the input.
18:40:24 <Peaker> chexxor: everything can be made point-free, it's always possible (often undesirable)
18:41:25 <byorgey> chexxor: I don't even understand what you want.  what would be the non-point-free version?
18:41:28 <blackdog> haasn: that's not true, i think
18:41:52 <blackdog> haasn: for instance, https://gist.github.com/mwotton/6532217 will run forever.
18:42:09 <chexxor> well, if the input is n, I want to do [1..n], but I must use a function
18:42:30 <chexxor> is my method ok?  oneToN = reverse . takeWhile (>0) . iterate (\x -> x-1)
18:43:18 <blackdog> haasn: and current function does make sense - it's always got to be evaluating some thunk, and the thunk came from a point in the program. perhaps in compilation GHC has thrown that information away, I don't know.
18:43:19 <byorgey> chexxor: that is much more complicated than necessary, since there is already a standard library function to do that =)
18:43:23 <byorgey> chexxor: enumFromTo
18:43:30 <Peaker> chexxor: (\x -> x-1) is (subtract 1)
18:44:11 <byorgey> chexxor: oneToN is fine.  The part I don't understand is  n = length oneToN.
18:44:38 <chexxor> byorgey: nice!
18:44:52 <chexxor> byorgey: well, I need n in the function above it
18:45:00 <pavonia> length . oneToN?
18:45:23 <haasn> blackdog: you can use Debug.Trace to (unsafely) print some output whenever a certain thunk is hit; eg. foo x y z = "foo" `trace` {- body of foo a b c -}
18:45:59 <byorgey> chexxor: oh, you mean you're trying to make exclusionNumbers point-free?
18:46:24 <blackdog> haasn: problem is that i have many thunks in my program, and annotating all of them with trace statements is going to be a bit invasive.
18:46:27 <chexxor> byorgey: well, I have that function which returns a list
18:46:40 <chexxor> byorgey: I want to remove some elements, so I am using filter
18:46:41 <blackdog> it's a bit of an aggravating bug, i don't seem to be able to get it to manifest in a single process - usually only happens when 50 bots hit the server at once
18:47:07 <chexxor> byorgey: problem is, in the predicate, I need to generate a list of numbers from 1 to n
18:47:15 <chexxor> n being the original input
18:47:36 <byorgey> chexxor: if you need to duplicate an input (i.e. use it more than once) in a point-free function, use 'ap'
18:47:54 <byorgey> honestly I don't see the point of doing this point-free.
18:48:08 <haasn> edwardk: is there any actual documentation on the ermine language?
18:48:20 <edwardk> not much
18:48:27 <haasn> how do people use it? :P
18:48:29 <haasn> or is it just you
18:48:32 <chexxor> byorgey: it's a homework assignment for my self-learning :-/
18:48:33 <edwardk> i'll be doing a talk at CUFP about it though
18:48:53 <edwardk> we mostly use it in house. there are some folks poking at the compiler outside though
18:49:12 <byorgey> if you really really want to learn about point-free style, then you should (a) first get this program to work any way you can, then (b) read the article "The Reader Monad and Abstraction Elimination" from the Monad.Reader issue 17
18:49:14 <edwardk> mostly right now the haskell version of the compiler is serving as a reference compiler for various techniques I want to show people
18:49:27 <haasn> oh ok
18:49:27 <byorgey> chexxor: then (c) use what you learned in (b) to convert your function from (a) to point-free style
18:49:30 <haasn> so that one isn't used in practice?
18:49:51 <edwardk> right now the scala one i the one we "use in anger". the haskell one is a work in progress showcasing new techniques
18:50:30 <edwardk> the new runtime system that the haskell one will target is coming along at a pretty good clip though
18:50:56 <haasn> edwardk uses things in anger. shachaf uses them with disappointment :(
18:51:03 <edwardk> heh
18:51:16 <edwardk> @remember haasn edwardk uses things in anger. shachaf uses them with disappointment :(
18:51:16 <lambdabot> Done.
18:51:26 <chexxor> byorgey: maybe I should use foldr instead of filter...
18:51:58 <edwardk> sitting here trying to use generic programming to implement the third homomorphism law for zippers. head hurts
18:52:07 <haasn> edwardk: so your implementation doesn't actually do code-gen yet?
18:52:13 <haasn> or am I just bad at finding it
18:52:14 <byorgey> chexxor: either one will work.  I don't see why using foldr would make it easier though.
18:52:25 <edwardk> the haskell one is missing most of the typechecker still
18:52:26 <edwardk> =)
18:52:30 <edwardk> so not much code gen wise.
18:52:33 <haasn> ah
18:52:35 <edwardk> there is a bit in Ermine.Type.Inference
18:52:35 <Maior> might anyone be able to help me work out why https://github.com/doismellburning/hogstash/blob/master/hogstash/hogstash.hs (and https://github.com/doismellburning/hogstash/blob/master/hogstash/inputs/redis.hs) kicks off just fine, then spits out a tonne of `getAddrInfo: does not exist (nodename nor servname provided, or not known)` fail before sitting and blocking for fair chunks of time?
18:52:46 <edwardk> er Ermine.Inference.Type
18:53:10 <edwardk> that generates core as a witness that the type checked
18:53:37 <chexxor> byorgey: for some reason, the prof suggests using a cartesian product function...
18:53:38 <edwardk> when we're done we're going to packag those up in a format we've agreed to between the scala rts and the haskell compiler
18:54:00 <flebron> Hi. I'm trying to use UnboxedTuples. Is there an issue using them as elements of a list? I get "Expecting a lifted type" when I say [(# Int64, Int #)].
18:54:05 <edwardk> the rts has some reference modules for testing and can serialize them out/in
18:54:31 <edwardk> he old scala compiler on the other hand gets the lion share of our attention since it is in production.
18:55:14 <edwardk> we need to dump more regularly from the production version out to the ermine-legacy code base, but its hard, given that we don't have great separation in the code from the stuff they held back and the open source stuff
18:55:45 <Maior> hm
18:55:55 <arkeet> flebron: well yes, [] doesn't accept unboxed types.
18:56:16 <flebron> Ah, OK. What's the problem, implementation-wise? Can a thunk point to an unboxed type?
18:56:33 <haasn> edwardk: ah, okay
18:56:40 <S11001001> edwardk: nah
18:57:09 <edwardk> S11001001: nah to which part? =)
18:57:17 <S11001001> edwardk: dumping more regularly
18:57:23 <edwardk> fair nuff
18:57:48 <Maior> in !Haskell, I'd add printfs to see what's going on - is there an analogous thing?
18:58:02 <edwardk> well, i know josh had some stuff he wanted to push out at some point
18:58:03 <S11001001> edwardk: I don't want people to get the wrong idea, and the current story is "Legacy is fun to play with as a preview for the *real* implementation." That's pretty clear now; it would be less clear were legacy to receive updates
18:58:06 <edwardk> thats all
18:58:08 <arkeet> Maior: Debug.Trace ?
18:58:13 <edwardk> true
18:58:16 <Maior> arkeet: thanks
18:59:51 <Maior> playing the "argh why does my daemon not behave" game
19:00:14 <flebron> Do unboxed tuples not unify with type variables? I am getting "    Kind incompatibility when matching types:      a0 :: *      (# Integer, Integer #) :: # ".
19:01:30 <monochrom> right, unboxed tuples don't unify with type variables
19:01:30 <Maior> ok given https://github.com/doismellburning/hogstash/blob/master/hogstash/outputs/stdout.hs#L14 - if I put a `putStrLn "llama"` before that line, should I not expect an identical number of llamas as events?
19:01:59 <flebron> monochrom: Madness!
19:02:03 <Maior> or am I misunderstanding IO
19:02:22 <monochrom> it is pretty sane once you try to write a compiler/interpreter yourself
19:02:55 <arkeet> Maior: you should. what are you seeing?
19:02:56 <flebron> monochrom: Is there a way to say "An unboxed type", like type variables mean "a type"?
19:03:04 <monochrom> implementation technique of type-variable polymorphism is incompatible with implementation technique of unboxed tuple
19:03:49 <Maior> arkeet: after some getAddrInfo failure, many llamas, with rare scattered events
19:04:04 <monochrom> I don't know
19:04:36 <arkeet> Maior: are you using putStrLn, or Debug.Trace?
19:04:45 <Maior> arkeet: putStrLn
19:05:02 <Maior> (figured that I had IO anyway...)
19:05:10 <arkeet> my only guess is that eventToString event fails to get evaluated.
19:05:23 <arkeet> somehow.
19:05:31 <Maior> well, it's just show
19:05:43 <arkeet> sure, what about event though?
19:06:05 <Maior> arkeet: fairly trivial https://github.com/doismellburning/hogstash/blob/master/hogstash/event.hs#L3
19:06:08 <arkeet> oh, did you put the putStrLn after readChan?
19:06:47 <Maior> arkeet: yep
19:06:55 <arkeet> then I have no clue.
19:07:48 <Maior> heh ok, cheers
19:11:00 <romildo> How to write the expression (do x <- a; y <- b; f x y) in applicative style?
19:11:09 <arkeet> liftA2 f x y
19:11:11 <dpwright> Trying to cabal-install gtk I get an error in gtk2hsC2hs: "Lexical error! The character # does not fit here"
19:11:12 <arkeet> or f <$> x <*> y
19:11:14 <arkeet> er
19:11:16 <arkeet> a b, not x y
19:11:30 <dpwright> is this a common problem?  Is there something else I need to set up?
19:11:52 <dpwright> (line 1 of gtk.h)
19:11:54 <arkeet> @src liftM2
19:11:54 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:12:02 <arkeet> oh wait.
19:12:04 <arkeet> not quite.
19:12:19 <arkeet> :t \f x y -> f <*> x <*> y
19:12:20 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
19:12:29 <arkeet> hm, that's not it either.
19:12:30 <arkeet> ugh
19:12:37 <arkeet> oh right.
19:12:39 <arkeet> romildo: you can't.
19:12:39 <copumpkin> join
19:12:49 <copumpkin> join ..: liftA2
19:13:29 <Maior> right ok
19:13:59 <Maior> so https://github.com/doismellburning/hogstash/blob/master/hogstash/hogstash.hs#L13 seems to eventually cause `12/09/2013 03:11:07.987 hogstash[12149]: dnssd_clientstub deliver_request: socketpair failed 24 (Too many open files)
19:14:34 <romildo> @src join
19:14:34 <lambdabot> join x =  x >>= id
19:14:52 <Maior> despite http://hackage.haskell.org/packages/archive/hedis/0.4.1/doc/html/Database-Redis.html#t:Connection suggesting that I'm not doing a DNS lookup every time because, well, pool
19:15:40 <romildo> :t (..:)
19:15:41 <lambdabot> Not in scope: `..:'
19:16:06 <romildo> copumpkin, what do you mean by     join ..: liftA2     ?
19:16:28 <arkeet> (f ..: g) x y z = f (g x y z)
19:16:31 <arkeet> I think.
19:19:35 <copumpkin> yeah, I just made that up
19:19:47 <arkeet> but the point is that
19:19:53 <arkeet> it can't be done with only Applicative stuff.
19:20:12 <arkeet> @let romildo f a b = do { x <- a; y <- b; f x y }
19:20:13 <lambdabot>  Defined.
19:20:14 <arkeet> :t romildo
19:20:15 <lambdabot> Monad m => (t -> t1 -> m b) -> m t -> m t1 -> m b
19:20:26 <arkeet> :t romildo (const id)
19:20:28 <lambdabot> Monad m => m t -> m (m b) -> m b
19:20:39 <arkeet> :t romildo (const id) (return ())
19:20:40 <lambdabot> Monad m => m (m b) -> m b
19:20:55 <arkeet> you can write join with it, so it's more powerful than applicative.
19:23:10 <monochrom> I misread "f x y" for "return (f x y)"
20:12:49 <haasn> copumpkin: that's more widely known as (.::) isn't it?
20:12:59 <copumpkin> probably!
20:13:18 <haasn> don't idiom brackets have something for inserting ‘join’?
20:13:46 <haasn> I know know the silly Io oI trick which also lets you define ‘J’ and use that as join :)
20:13:55 <haasn> I only know*
20:14:28 <spaceships> when is it appropriate to use an irrefutable pattern match? (thanks for tolerating my questions these last few weeks)
20:14:32 * hackagebot posix-paths 0.1.1.1 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.1.1.1 (JohnLato)
20:15:08 <haasn> spaceships: I mainly know it being useful for laziness
20:15:19 <spaceships> haasn: another way to delay evaluation?
20:15:29 <haasn> consider
20:15:41 <haasn> > case undefined of (x,y) -> "foo"
20:15:42 <lambdabot>   "*Exception: Prelude.undefined
20:15:43 <haasn> > case undefined of ~(x,y) -> "foo"
20:15:44 <lambdabot>   "foo"
20:15:54 <haasn> evaluation of ‘undefined’ gets delayed until you force ‘x’ or ‘y’
20:16:25 <haasn> I remember one situation in which it was necessary to use an irrefutable pattern match to make a function work (it used backwards state passing and stuff)
20:16:38 <haasn> because without it, it got caught up in an infinite loop
20:16:44 <haasn> since the previous function was forcing the output of the next one
20:16:52 <spaceships> ah, cool
20:17:40 <spaceships> haskell is indeed a rich language, it is pleasant to study
20:23:07 <haasn> if only haskell had been such a rich person, he could have funded his namesake
20:24:29 <spaceships> is there a problem with funding?
20:25:10 <haasn> there's not nearly as much of it as there could be!
20:25:20 <haasn> for example, nobody gets paid to hack on ‘lens’ or ‘diagrams’
20:25:39 <edwardk> clearly i need to get in on this 'paid for lens' thing =)
20:28:27 <ReinH> spaceships: are you referring specifically to lazy patterns?
20:29:44 <spaceships> ReinH: i ran across the ~s in Control...Writer.Lazy, wondered why there were so many. but I guess they're largely what make it lazy?
20:30:03 <mmhelloworld> > show []
20:30:04 <lambdabot>   "[]"
20:30:05 <ReinH> spaceships: ~pat is a lazy pattern match, yes
20:30:12 <arkeet> was there some proposal to generalize Prelude functions like foldr, length, etc. to Foldables?
20:30:17 <ReinH> spaceships: http://www.haskell.org/tutorial/patterns.html#tut-lazy-patterns
20:30:17 <arkeet> or plan
20:33:05 <arkeet> http://www.haskell.org/pipermail/libraries/2013-July/020033.html
20:35:17 <arkeet> so, next year maybe.
20:52:09 <spaceships> ReinH: that's a nice explanation
20:53:34 <arkeet> > let fibs = 0 : 1 : [ a + b | (a,b) <- zip fibs (tail fibs) ] in fibs
20:53:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:53:47 <arkeet> > let fibs = 0 : 1 : [ a + b | (a,b) <- zip fibs (tail fibs) ] in fibs !! 1000
20:53:48 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
20:54:25 <arkeet> hm
21:01:49 <haasn> yes the Lazy Writer/State monads are pretty much exactly the use case I had as well, lazily matching on (,)
21:02:13 <haasn> > let fibs = scanl (+) 0 (1:fibs) in fibs !! 1000
21:02:14 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
21:02:39 <arkeet> oh yeah. that's what it was.
21:02:51 <arkeet> > fix $ \(a,b) -> (0:a,1:b)
21:02:58 <lambdabot>   mueval-core: Time limit exceeded
21:02:59 <arkeet> > fix $ \~(a,b) -> (0:a,1:b)
21:03:00 <lambdabot>   <hint>:1:7: parse error on input `\~'
21:03:03 <arkeet> > fix $ \ ~(a,b) -> (0:a,1:b)
21:03:04 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:03:10 <arkeet> something like that.
21:03:19 <haasn> oh I didn't know about that syntax trick
21:03:33 <haasn> > fix $ \(~(a,b)) -> (0:a, 1:b) -- is the ugly workaround I used to use :(
21:03:34 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:03:34 <arkeet> which trick?
21:03:36 <arkeet> ah
21:03:45 <arkeet> > let a \~ b = a+b in 1 \~ 2
21:03:46 <lambdabot>   3
21:03:53 <haasn> makes sense :)
21:12:29 <enthropy> > fix $ \( ~ ~(a,b)) -> (0:a, 1:b) -- a lazy lazy match
21:12:30 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:12:58 <haasn> > fix $ \( ~ ~ ~ ~ ~(a,b)) -> (0:a,1:b) -- added more laziness, TODO: bench
21:13:00 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:14:11 <enthropy> also as-patterns
21:15:08 <arkeet> > fix $ x@(a,b) -> (0:a,b)
21:15:09 <lambdabot>   <hint>:1:15: parse error on input `->'
21:15:11 <arkeet> > fix $ \x@(a,b) -> (0:a,b)
21:15:17 <arkeet> looks pretty not lazy.
21:15:18 <lambdabot>   mueval-core: Time limit exceeded
21:16:24 <arkeet> pattern bindings are lazy. @ is irrelevant.
21:16:54 <arkeet> > fix $ \x@(a:b) -> 1:x
21:17:01 <lambdabot>   mueval-core: Time limit exceeded
21:17:05 <arkeet> heh.
21:17:29 <shachaf> > (\ ~(!x) -> "hi") undefined
21:17:30 <lambdabot>   "hi"
21:17:37 <haasn> > fix $ over both (0:)
21:17:38 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:17:45 <arkeet> both is lazy.
21:17:46 <shachaf> haasn: both is lazy because of you. :-(
21:17:57 <shachaf> It ought to be strict.
21:18:00 <shachaf> Or maybe not.
21:18:02 <haasn> no that should be both'
21:18:04 <haasn> :)
21:18:05 <arkeet> no it shouldn't.
21:18:09 <shachaf> But that generates nicer Core!
21:18:10 <arkeet> haasn: I'm generalizing both anyway.
21:18:15 <haasn> arkeet: each
21:18:21 <arkeet> no, in a different direction.
21:18:22 <shachaf> arkeet: Generalizing both both and both'?
21:18:25 <haasn> hmm
21:18:30 <arkeet> to an arbitrary Bitraversable.
21:18:46 <haasn> > fix (over each (0:) :: (Int,Int) -> (Int, Int))
21:18:47 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[a0]'
21:18:53 <haasn> err
21:18:55 <arkeet> shachaf hasn't figured out mapBeside though, which is why it's not in yet.
21:19:03 <haasn> > fix (over each (0:) :: ([Int],[Int]) -> ([Int], [Int]))
21:19:05 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:19:43 <haasn> shachaf: yours may generate nicer core but mine generates nicer code!
21:19:51 <haasn> the ultimate conflict of interests..
21:34:16 <mstksg> ExitFailure 24?  there seems to be no output, it just seems to fail in the middle of compiling a package
21:34:25 <mstksg> anyone know what this error code means?
21:38:30 <mstksg> even running with verbose, it just stops after outputting that it's compiling module 2 of 21
21:42:10 <nh2> mstksg: sorry I don't get it, you get that when you do what?
21:42:29 <mstksg> sorry, i'm just to find a list of what the ExitFailures mean
21:43:15 <mstksg> i'm installing citeproc-hs-0.3.8 using cabal install -v, but i'm not sure how to give real instructions for duplication because it is only failing on my production server
21:43:35 <mstksg> so i thought maybe if i found out what the exitfailure means i might be able to know where to look
21:43:45 <mstksg> (cabal install citeproc-hs-0.3.8 --verbose)
21:48:09 <enthropy> mstksg: use -v3
21:48:25 <enthropy> that might get you more output than just --verbose
21:49:59 <mstksg> enthropy: thanks
21:51:17 <mstksg> you know what, i just tried updating cabal and i get the same error.  up until citeproc-hs i have had no problems installing anything. i am starting to think it is just my production server hitting its space limit
22:00:24 <mstksg> any way i can safely remove all packages installed by cabal so i can start afresh?
22:02:53 <nh2> mstksg: you can remove ~/.ghc and ~/.cabal if you like
22:03:06 <nh2> then all packages are gone
22:03:11 <mstksg> nh2: ah, thanks.  and nothing dramatic will break?
22:03:37 <nh2> mstksg: well all your packages and programs installed via cabal install will be gone
22:04:10 <nh2> mstksg: if you are not sure, just rename them, so that you can get them back
22:16:08 <jfischoff> is anyone familiar with data-reify?
22:17:01 <ReinH> edwardk: ^
22:17:02 <jfischoff> I'm reading through the paper and I'm getting to the Mu instance.
22:17:23 <ReinH> "Is anyone familiar with..." Yes, Edward Kmett.
22:17:36 <ReinH> "But you don't even know what I was going to..." It doesn't matter.
22:17:43 <jfischoff> is it fair to say that if you can express something with an explicit fix point you get a data reify instance for free?
22:18:14 <jfischoff> that and I don't really get the Mu instance yet :p
22:18:54 <jfischoff> this ties in with my attempt to deal with AST variable substitution efficiently
22:19:09 <shachaf> What paper?
22:19:18 <edwardk> jfischoff: yes
22:19:18 <jfischoff> http://www.cs.uu.nl/wiki/pub/Afp/CourseLiterature/Gill-09-TypeSafeReification.pdf
22:19:18 <shachaf> The link at http://hackage.haskell.org/package/data-reify is broken.
22:19:33 <edwardk> jfischoff: that is the easiest way to get a data-reify instance
22:19:34 <jfischoff> edwardk: cool
22:20:00 <edwardk> jfischoff: look at Kahn in 'ad' if you get stuck
22:20:34 <jfischoff> edwardk: do you ever data-reify a free monad version of a AST?
22:21:00 <jfischoff> your do you have other tricks up your sleeve :)
22:21:51 <edwardk> that is a pretty straightforward way to do things
22:22:03 * jfischoff nods
22:22:06 <edwardk> but free is just Mu with an extra coproduct layered in
22:22:12 * jfischoff nods
22:22:55 <jfischoff> I was sort of fumbling to the data-reify approach, but in a much crappier way
22:23:24 <jfischoff> I had something like type FreeF f a = f :+: K a; newtype FixRef s f = FixRef (STRef s (f (FixRef s f))); type Free' s f a = FixRef s (FreeF f a)
22:23:34 <edwardk> blech
22:23:41 <jfischoff> yeah
22:23:46 <edwardk> sounds like time traveling to write a compiler in the 80s
22:24:07 <edwardk> modulo some ST stuff, just references everywhere
22:24:13 <jfischoff> I think you have to struggle on your own first sometimes
22:24:24 <jfischoff> to appreciate when someone does it better :)
22:24:27 <edwardk> heh
22:24:46 <edwardk> i use meta/unification variables as just a value type and substitute them in and out using bound.
22:25:17 <jfischoff> I don't know what that means
22:25:35 <jfischoff> which is too bad because I have written a few unification algo recently
22:25:39 <jfischoff> so I feel like I could
22:25:50 <jfischoff> also I am familiar with bound :p
22:26:12 <shachaf> It's bound to come up when you talk to edwardk about this kind of thing.
22:27:11 <edwardk> i mean that i work with bound to deal with bound variables. then if i want to do unification on it then i work with something like Type (Meta …)    for some appropriate Meta variable type.
22:27:16 <edwardk> the one we use looks something like
22:27:44 <edwardk> data Meta s f a = Meta   { _metaValue :: a, _metaId :: !Int, _metaRef :: !(STRef s (Maybe (f (Meta s f a)))), _metaDepth :: !(STRef s Depth), _metaRank :: !(STRef s Rank) } | Skolem { _metaValue :: a, _metaId :: !Int }
22:27:56 <edwardk> but you don't need the depth and rank stuff unless you want to use all the tricks we do
22:28:00 <edwardk> that takes it down to
22:28:27 <edwardk> data Meta s f = Meta   { _metaId :: !Int, _metaRef :: !(STRef s (Maybe (f (Meta s f)))) }
22:28:38 <mstksg> hm server space issues doesn't seem to be the problem, i erased everything and reinstalled all of the packages and it stopped again on citeproc-hs, and then i erased it all and installed citeproc-hs on a fresh system the same ExitFailure24 showed up.
22:28:43 <mstksg> does anyone know what 24 means?
22:28:46 <carter> shachaf jfischoff : he's not got the repo on github
22:28:49 <carter> *now
22:29:08 <edwardk> so a meta variable has some Int id (because an STRef can't be put into a Set like construct easily) and it has an STRef to Maybe an f (Meta s f)
22:29:09 <jfischoff> edwardk: that looks familiar
22:29:13 <nkpart> Yo, are there flags I can add to "ghc --make SomeFile.hs" that will make it clean up the build products? (.o, .hi)
22:29:18 <edwardk> Type (Meta s Type)
22:29:23 <edwardk> that lets you have type variables
22:29:43 <edwardk> now you can mix that with bound and substitute for them, search for ones with a given Id, etc.
22:29:53 <edwardk> and you can do unification on them using the STRef
22:30:05 <edwardk> then pull them all out of the final type after zonking
22:30:17 <jfischoff> this is interesting
22:30:26 <jfischoff> I don't have the whole picture
22:30:38 <jfischoff> is this in ermine?
22:30:57 <edwardk> github.com/ermine-language/ermine look in Ermine.Unification.Meta
22:31:03 <jfischoff> great
22:31:21 <edwardk> and in Ermine.Unification.Kind to get an easy example
22:31:28 <pxqr> does hackage bot running on 32 bit machine?
22:31:28 <jfischoff> oh cool
22:31:40 <edwardk> the unifier in there has lots of wires hanging out as it was sort of a proof of concept as we went
22:31:53 <edwardk> and we were playing with lots of union by rank tricks i liked
22:31:56 <edwardk> etc
22:32:00 * jfischoff nods
22:32:34 <haasn> > maxBound :: Int
22:32:35 <lambdabot>   2147483647
22:32:38 <jfischoff> this looks cool
22:32:41 <haasn> oh, hackage bot - not lambdabot
22:33:46 <haasn> edwardk: do you always sort your language pragmas by length? :)
22:33:56 <edwardk> most times, not always =)
22:34:17 <edwardk> started as a joke
22:34:25 <haasn> I think in tables you're sorting in the reverse order
22:34:32 <edwardk> yeah
22:34:40 <pxqr> haasn: well, i have a CPP conditional which will not build on WORD_SIZE_IN_BITS != 64;
22:35:03 <haasn> pxqr: try it and see :)
22:35:07 * jfischoff starts installing ermine
22:35:26 <pxqr> haasn: I tried, hackage bot failing :)
22:35:47 <edwardk> jfischoff: note that haskell-based compiler is _very_ much a work in progress
22:36:00 <haasn> edwardk: I like to sort them alphabetically, then fit as many into a single pragma as I can within 80col. when I add or remove a pragma, it can cause quite an explosion in the resulting line-fitting work, though :)
22:36:30 <pxqr> that's good, because a bug was spotted
22:36:41 <edwardk> i tend to work at 2560x1600, so i can fit a lot of them on one line if i'm not careful ;)
22:37:08 <haasn> hence 80col!
22:37:12 <edwardk> blech
22:37:23 <jfischoff> edwardk: good to know. I've been main to mess with it. Plus I'm curious with "Typing A Haskell Like thing with Lenses" looks like :)
22:37:27 <haasn> edwardk's type signatures disagree with 80col
22:39:34 <haasn> edwardk: do you use ‘bound’ for it?
22:39:46 <edwardk> yeah
22:44:40 * hackagebot intset 0.1.0.1 - Pure, fast and memory efficient integer sets.  http://hackage.haskell.org/package/intset-0.1.0.1 (SamTruzjan)
22:58:39 <haasn> does anybody know how the Haswell transactional memory implementation relates to Haskell's STM, and more to the point, whether the latter can be optimized using the former?
22:59:57 <ion> IIRC it can’t, but i don’t remember the details.
23:00:38 <shachaf> Well, there's nothing like a direct correspondence. They're used for different things in different ways.
23:00:53 <haasn> ok
23:00:53 <shachaf> But it's possible that the former can help with implementing the latter.
23:07:25 <johnw> haasn: that's been discussed before: http://ircbrowse.net/browse/haskell?q=Haswell, but no conclusion.  I'll guess we'll have to wait and see
23:07:34 <haasn> johnw: thanks
23:08:14 <shachaf> Probably the opinions of the average #haskeller won't help you much. :-)
23:08:30 <shachaf> (Including me. I don't know much of anything about it.)
23:08:44 <haasn> might be a better question for #ghc
23:09:04 <johnw> i've had face-to-face discussions with people who convinced me that it wouldn't help, due to GHC managing custom data structures to implement STM, but I can't remember who, or what their reasoning was
23:14:12 <sclv> fryguybob is working on looking at haswell htm as a possible way to just optimize concurrency in the GHC runtime in general
23:14:26 <sclv> my understanding is that there's more low hanging fruit there than in the STM system specifically.
23:14:41 * hackagebot crypto-cipher-tests 0.0.6 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.6 (VincentHanquez)
23:19:10 <tpsinnem> can the code of the 'extensible effects' paper be found on hackage?
23:20:21 <carter> johnw haasn: fryguybob  is actually researching this :)
23:20:32 <carter> i think
23:22:49 <johnw> tpsinnem: not as such, to my knowledge
23:24:41 * hackagebot crypto-cipher-benchmarks 0.0.3 - Generic cryptography cipher benchmarks  http://hackage.haskell.org/package/crypto-cipher-benchmarks-0.0.3 (VincentHanquez)
23:31:06 <sp3ctum> how can I display a message such as this: "Current directory" ++ getCurrentDirectory
23:31:27 <joelteon> do { dir <- getCurrentDirectory; putStrLn $ "Current directory: " ++ dir }
23:31:52 <sp3ctum> yes. is there any elegant way to do so in a single statement+
23:31:53 <sp3ctum> ?
23:32:24 <joelteon> getCurrentDirectory >>= putStrLn . ("Current directory: " ++)
23:38:25 <carter> night all
23:39:06 <applicative> 'night, comrade
23:42:49 <sp3ctum> what about capturing the string in a variable? all I get are type errors.
23:43:08 <tpsinnem> what would i need to know/understand to judge between mtl, monads-tf and mtl-tf ?
23:46:15 <maxiepoo> > getCurrentDirectory
23:46:16 <lambdabot>   Not in scope: `getCurrentDirectory'
23:46:20 <Thulsadum> i guess monads are too simple to understand
23:47:25 <applicative> which string do you want to caputre in a variable sp3ctum ?
23:48:30 <sp3ctum> I'm trying something like msg <- return ("Current directory: " ++) =<< getCurrentDirectory
23:49:01 <sp3ctum> but it seems getCurrentDirectory returns a FilePath and ghci doesn't know how to "return" it
23:49:28 <applicative> msg <- fmap ("Current directory:" ++) getCurrentDirectory
23:49:32 <maxiepoo> FilePath is just an alias for string right?
23:49:37 <applicative> yes
23:49:40 <sp3ctum> yes it is
23:50:42 <sp3ctum> thanks applicative !
