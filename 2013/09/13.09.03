00:00:12 <_emm_> startling: sure, it's ok for scripts, but I don't believe in weakly-typed errors :)
00:00:56 <startling> sure.
00:01:17 <__jim__> ?
00:01:20 <Ghoul_> the regular exception module should export a catchAll
00:01:52 <Ghoul_> or something like that. I find myself doing a lot of really wierd things with anonymous bindings to fix ambiguous type errors at compile time IRT exceptions
00:03:01 <__jim__> hey guys, dumb question, but what is the best way to retrieve new lines from the console N number of times in Haskell? I'm pretty new to it
00:03:44 <shachaf> Perhaps: replicateM N getLine
00:03:49 <dibblego> replicateM n getLine
00:03:59 <startling> __jim__, do you want to do something n times on a line, or do you want to do something on n lines?
00:04:49 <__jim__> basically, I'm trying to build a list of lines strings input from the console
00:05:09 <startling> __jim__, then shachaf's code will do you well
00:05:23 <startling> :t replicateM 63 getLine
00:05:24 <lambdabot> IO [String]
00:05:52 <__jim__> do I need to import replicateM ?
00:05:58 <shachaf> @hoogle replicateM
00:05:58 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
00:05:58 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
00:05:58 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
00:06:42 <__jim__> ah, got it, thanks guys
00:08:17 <mroman> How can I lift something from the CGI Monad into StateT?
00:08:33 <mroman> StateT (CGIT IO) a that is
00:08:43 <zomg> mroman: with `lift` ?
00:08:58 <startling> mroman, what do you have? CGIT IO a or CGI a?
00:09:25 <mroman> oh
00:09:28 <mroman> lift seems to work
00:09:31 <startling> :)
00:09:32 <levi> Heh.
00:09:42 <mroman> I thought I tried that and I didn't work
00:09:46 <mroman> *it
00:09:52 <mroman> maybe I wrote liftM
00:09:54 <startling> it's easy to confuse things like that.
00:11:15 <mroman> hm
00:14:38 <[JJ]Albert> Well, thanks for the encouragement guys. I'll be around.
00:14:41 <[JJ]Albert> Later.
00:15:38 <mm_freak_> as a side note, replicateM 10000 will actually use 10000 times the memory and time
00:15:59 <mm_freak_> if you want stream-like behavior, just write a recursive function
00:29:25 * hackagebot DrIFT-cabalized 2.3.0 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-cabalized-2.3.0 (KiwamuOkabe)
00:29:27 * hackagebot xmlgen 0.6.2.0 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.6.2.0 (StefanWehr)
00:31:32 <edwardk> Sonarpulse: merged!
00:32:38 <DigitalKiwi> I see you rolling, patrolling, trying to catch me merging PR
00:33:14 <Sonarpulse> great!
00:33:27 <Sonarpulse> Thanks so much
00:33:58 <DigitalKiwi> mm_freak_: that's scary
00:34:20 <Sonarpulse> did you see what I said about SerializeHost above?
00:34:26 * hackagebot HTF 0.11.0.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.0.1 (StefanWehr)
00:36:21 <Sonarpulse> In my master branch I did that and additionally made other Generic classes + default instances for the endian specific classes
00:37:18 <Sonarpulse> edwardk: https://github.com/Ericson2314/bytes/compare/ekmett:master...master
00:38:34 <edwardk> Sonarpulse: what did you say. i must have missed it
00:39:04 <edwardk> adding the generic stuff is harmless. i recommend pushing it in
00:39:10 <Sonarpulse> ok
00:39:53 <Sonarpulse> I can send you another with that
00:40:15 <Sonarpulse> And I said before: using default instances (not in the conservative branch pull request) for SerialHost will pick up any hand rolled SerialBE or SerialLE instance, so I didn't see any risk there
00:42:41 <fylwind> is there a way to make writing export lists less tedious?
00:43:30 <Sonarpulse> fylwind: only in idris....
00:47:08 <edwardk> Sonarpulse: i've added you as a collaborator on the repository
00:47:28 <Sonarpulse> awesome!
00:47:33 <edwardk> feel free to push non-controversial changes directly, and use P.R.'s if you think i may have an issue with it ;)
00:47:38 <mm_freak_> DigitalKiwi: what's scary?
00:48:06 <DigitalKiwi> replicateM
00:48:11 <mm_freak_> why?
00:48:36 <eikke> edwardk: for your 'structures' lib, did you look into fractal trees?
00:49:02 <mm_freak_> it has one of the most straightforward monadic type signatures…  if you're looking for a scary example i can come up with a much better example ;)
00:49:24 <Sonarpulse> I'll push the generic stuff then
00:49:29 <edwardk> eikke: yes
00:49:42 <edwardk> eikke: but they are pretty far from a functional data structure
00:50:12 <edwardk> eikke: the nice thing about COLA (which is actually earlier work by bender and the other guys who went off to found toku) is that when i lobotomize it a bit, it becomes a functional data structure
00:50:36 <edwardk> in fact the original version of tokudb and the thing they used to call fractal trees at launch was just a cola!
00:50:47 <eikke> edwardk: actually we (i.e. research team I work at) figured out a way to have functional/append-only FT's (but we're not using the idea)
00:51:04 <DigitalKiwi> mm_freak_: I mean the memory and time complexity
00:51:05 <edwardk> since then its evolved into just gigantic b-tree nodes with messaging queues
00:51:07 <eikke> (append-only in case the thing is persisted to disk)
00:52:34 <edwardk> anyways the machinery i was working on in analytics was based on replacing the cola-parts with a bunch of wavelet trees and re-optimizing for efficient OLAP-style aggregates, so i became pretty familiar with all the cache oblivious b-tree analogues and alternatives out there
00:52:50 <eikke> heh, same here ;)
00:53:21 <eikke> (although we also have to take persistence into account)
00:53:32 <edwardk> with structures i'm just trying to see if i can get a COLA up to bar with Data.Map for some operations, since having an unboxed Data.Map even if limited to ephemeral use given the right asymptotics would be golden
00:53:34 <edwardk> sure.
00:54:20 <edwardk> in my case i'm looking at the map as the structure, i could use a vector type that was backed by foreign ptrs, and mmap the regions in, then say you can commit by pushing out the new cola blocks to disk
00:54:31 <edwardk> so you get a weird hybrid functional/offline storage model
00:54:52 <edwardk> since the nice thing about the cola is that each fragment is individually read-only
00:55:16 <mm_freak_> DigitalKiwi: that's not scary either…  it's natural
00:55:32 <edwardk> so getting a reference to the db would be using some kind of withDB block that worked like a region, inside that region you can use the database, use lenses into it, whatever on a consistent snapshot
00:55:42 <mm_freak_> if you want to process lines without accumulating them, you can use replicateM_, which is constant memory
00:55:49 <eikke> yup. which is what makes it easy to figure out an append-only version as well. using 1 'file' per 'level', and keeping track of the offsets in 'level' files for a given 'version' of the tree
00:56:05 <mm_freak_> DigitalKiwi: and i'm not sure how you can read n lines in less than O(n) steps anyway, so the time complexity is perhaps the most natural part ;)
00:56:30 <edwardk> another variant that is potentially interesting are CoW trees, which also build on a COLA foundation, but which push it more in a direction where i can't have easy transparent functional persistence
00:56:35 <DigitalKiwi> parallelize all the things
00:57:08 <edwardk> the cow trees are somewhat like what you mention, but offer mvcc
00:57:09 <eikke> I suppose you're familiar with Visser/Loh "Generic Storage in Haskell"?
00:57:54 <edwardk> i've seen it but not given it full attention
00:58:28 <edwardk> eikke: i'll go back and watch the presentation
00:59:24 <eikke> paper is certainly worth a read, I really liked it at least. Started to work with it a bit, should pick that up again
01:00:24 <edwardk> added to my todo list. i have tomorrow off to play with code so we'll see how it goes
01:01:08 <eikke> they use a GC'd heap in the paper, but it's easy to derive an append-only version, and there's a simple algorithm for GC'ing append-only data(structure) storage (although it's not completely generic), see http://blog.incubaid.com/2011/12/19/hole-punching-compaction-of-an-append-only-database/ (I'm the author of that piece)
01:01:29 <mm_freak_> const False :: forall a. a -> Bool  -- does that mean that Bool is a terminal object in Hask?
01:01:36 <eikke> we implemented that for an append-only b-tree (in ocaml), and it works out really well
01:02:27 <mm_freak_> it seems like every non-empty type is a terminal object in Hask
01:02:46 <edwardk> The main thing i was going for with the cola stuff was feature parity or approximation of the Data.Map API. Offline stuff is punted for it. I figure if we can get some decent cache oblivious data structures into Haskell, it'll be a nice place to think about the _other_ stuff I like too.
01:03:04 <eikke> hehe
01:03:11 <eikke> no hurry ;)
01:03:25 <edwardk> eikke: patches welcome. right now the COLA is pretty slow.
01:03:37 <eikke> I'll take a look
01:03:56 <Sonarpulse> time to sleep. Thanks again edwardk!
01:04:19 <edwardk> eikke: i wanted to get it functional and fast for inserts/lookups before i did anything with making it handle deletes, global record counts, etc. anything that would slow it down was punted.
01:04:24 <mm_freak_> type Terminal c b = forall a. c a b
01:04:32 <mm_freak_> type Initial c a = forall b. c a b
01:04:37 <mm_freak_> does that make sense?
01:04:54 <bitonic> what's the difference between the "intent" and "indentation" modes for Haskell?
01:05:00 <edwardk> right now its using a regular counter for the sizes, not a redundant one, because i have to amortize anyways to keep the Map api
01:05:16 <edwardk> that means it has the benefit of being stupid simple
01:05:46 <edwardk> the only real novelty is i borrowed one tool from my analytics work which is i don't store real forwarding pointers for the fractional cascading. i just use a bitvector with O(1) rank
01:06:02 <edwardk> and i use that to thin the storage for the stored values
01:07:13 <edwardk> eikke: i think it'd probably perform better if i removed the existing fusion machinery and just wrote something that did the fusion level by level, and maybe used a redundant binary counter to enable me to do those fusions in parallel. but if i do a redundant binary counter then i have to deal with non-functional updates to the forwarding pointers
01:08:40 <eikke> yup
01:09:15 <mm_freak_> where are all the CT guys this morning…  it's really a simple question, and i'm sure the answer is yes =P
01:10:08 <edwardk> mm_freak_: the distinction is that the arrow is canonical if its terminal
01:10:13 <edwardk> mm_freak_: thats what you're missing
01:10:32 <edwardk> I have at least 2 distinguishable arrows into Bool for all inputs
01:10:49 <edwardk> const False and const True are different
01:10:57 <mm_freak_> oh, precisely one morphism
01:10:58 <edwardk> and I can have more if the input is interesting!
01:10:59 <mm_freak_> i see
01:11:16 <mm_freak_> so the only terminal object is ()
01:11:24 <edwardk> or things isomorphic to it, yes
01:11:34 <mm_freak_> ok, thanks
01:19:15 <Zenol> Hum, what's the way to compose utilisation of setter. Ex : (field1 .~ val1) . (field2 .~ val2) $ def
01:21:31 <qwerty1793> hi, I've started writing code in Haskell and wondered if there was a convention used to enable you to tell the difference between when a period (.) is being used as a compose and as a qualifier? For example consider "compact.map C.ord.B.unpack.B.take 4.B.drop 4" is the capitialisation supposed to be the hint as to how to parse this?
01:22:39 <mauke> I don't understand the question
01:22:44 <wollw> I'm not sure myself, but you can compose constructors too
01:22:51 <wollw> so capitalization isn't it
01:22:53 <mauke> if you're trying to parse code, use the language grammar
01:23:04 <mauke> if you're writing code, put spaces around your operators
01:23:07 <Zenol> qwerty1793: I often put spaces around . when I'm composing functions, but don't know if it's a convention.
01:23:27 * wollw also puts spaces around periods for composition.
01:24:23 <edwardk> qwerty1793: Foo.x is a qualifier. the capitalization is key
01:24:41 <mauke> > True.id
01:24:42 <lambdabot>   Not in scope: `True.id'
01:25:05 <edwardk> mauke: yeah i used to think it'd work too
01:25:10 <edwardk> :t Right.id
01:25:11 <lambdabot> Couldn't find qualified module.
01:25:24 <quicksilver> you are forced to put spaces around the composition operation if composing constructors so some people find it more consistent to always do so
01:25:26 <fylwind> when I get " The following packages are likely to be broken by the reinstalls: ..." is there a way to get more info about it?
01:25:57 <wollw> :t Just . id
01:25:57 <lambdabot> b -> Maybe b
01:26:01 <wollw> :t Just.id
01:26:01 <lambdabot> Couldn't find qualified module.
01:26:21 <Zenol> fylwind: Hehe. The way I solv it is reinstalling all modules that can be broken. Adding them one by one.
01:26:22 <wollw> spaces required for constructor composition i guess
01:27:34 <Zenol> fylwind: Some one here gave me a good link to explain what's happening. I'm digging to my bookmarks.
01:27:54 <fylwind> Zenol: alright, let me know if you find something, thanks :)
01:28:28 <Zenol> fylwind: http://www.vex.net/~trebla/haskell/sicp.xhtml
01:29:26 <qwerty1793> ok so writing "f . G.h" instead of "f.G.h" appears to be the standard solution
01:30:00 <Zenol> fylwind: The main idea is don't force cabal install unless your exactly know what you are doing. (Like reinstalling the same package you just installed with the same version, same dependencies, etc, because you missed the shared library flag or profiling flag, etc.)
01:30:21 <mauke> I wouldn't write f.G.h in the first place
01:30:32 <mauke> also, did you mean f.G . h?
01:31:10 <fylwind> Zenol: i'm just trying to reinstall the packages I already have; I don't understand why it's reporting that it will break "haskell-platform-xxxx" and "cgi-xxx"
01:32:20 <Zenol> fylwind: Because the new package you wan't to install probably need to update one of the package you already installed. But doing so will break all packages already installed which depend also on this dependency.
01:33:20 <Zenol> fylwind: Anywy, to solv it, just add "haskell-platform" and "cgi" after your cabal install. And do it again until you have a huge list of package and it say "ok, let's recompile all this world".
01:35:17 <ibotty> qwerty1793: yes. that is how it should be done
01:35:21 <fylwind> Zenol: thanks, though I'm starting to wonder if I should just not bother with all this :(
01:49:02 <_emm_> idle question
01:49:15 <_emm_> (I don't really need to do this, but I'm curious)
01:49:53 <_emm_> say you have a file in custom format with users in it, and you want to abort the parsing if a user is not found in a database
01:50:07 <_emm_> you'd go for ParsecT, I suppose, and forgo Attoparsec?
01:51:54 <edwardk> _emm_: probably
01:53:00 <tomejaguar> I'm doing "ghc -rtsopts test2.hs", "./test2 +RTS -Ksize 1m -RTS" then I get "test2: error in RTS option -Ksize: size outside allowed range (4 - 4294967295)"
01:53:03 <tomejaguar> Any ideas?
01:53:24 <shiona> it's M
01:53:26 <tomejaguar> I've tried lots of things in place of "1m" like "1M", "1234", "1000000"
01:53:32 <shiona> oh
01:53:35 <shiona> ah
01:53:51 <shiona> of course, the same mistake I made. it's -K1M
01:54:03 <shiona> the "size" needs to be replaced with the actual size
01:54:20 <tomejaguar> Oh yeah
01:54:21 <tomejaguar> :*)
01:54:46 <shiona> It's quite misleading
01:54:48 <tomejaguar> Thanks shiona
01:55:01 <shiona> np
01:55:15 <tomejaguar> It would have been more obvious if there was a space between -K and size
01:55:19 <ibotty> edwardk: i read about a convenience function in lens lately that generates a record and its lenses but not its record get functions. what was the name again?
01:55:49 <ibotty> i did not find it in control.lens.th (well. i looked in the wrong way i suppose)
01:55:54 <shiona> tomejaguar: true, or some markings around it, like -K[size] or something
01:56:35 <arbn> -Kreplacethiswiththeactualsize
01:56:46 <shiona> arbn: could work
01:59:17 <edwardk> ibotty: not sure i parsed that
01:59:48 <wollw> I've been messing around writing a TicTacToe game as an exercise.  If anyone would like to look at it and give me any advice I'd appreciate it.
01:59:52 <wollw> https://github.com/Wollw/TicTacToe-HS
02:00:51 <cinimod> Is there a channel for cabal questions? Specifically I am working on cabal so is there a cabal-dev channel?
02:00:52 <wollw> I'm kinda at the point where I think I'm probably doing some things the 'wrong' way, but don't know any better.
02:01:21 <ibotty> sorry. you don't construct the record normally (with data A = A {_field :: T }), but somehow (i forgot the details) with data A = A {field :: T} within a template haskell function and it generated the lenses and the data type.
02:01:40 <edwardk> ibotty: on there is some declareLenses thing i think in lens HEAD
02:01:43 <edwardk> er oh
02:02:08 <edwardk> cinimod: no, but dcoutts is around here and usually responsive
02:02:09 <ibotty> ah. so it's not yet released.
02:02:14 <ibotty> that's why i did not find it
02:02:17 <ibotty> thank you
02:02:19 <edwardk> ibotty: pretty sure it was post 3.9
02:02:51 <_emm_> edwardk: thanks
02:03:20 <cinimod> I am trying to use cabal sandboxes to test cabal itself. Is this a bad idea?
02:03:29 <cinimod> @edwardk: thanks
02:03:30 <lambdabot> Unknown command, try @list
02:03:39 <cinimod> edwardk: thanks
02:04:06 <edwardk> cinimod: no idea =) i tend to live sandbox free, fast and loose
02:06:42 <cinimod> edwardk: :-)
02:08:50 <ibotty> cinimod: i did not really test cabal (other than  regularly using it) but i initially installed it from my linux package manager, then within cabal-dev, then with cabal sandboxes. works like a charm
02:09:49 <dcoutts_> cinimod: people were using cabal sandbox to hack on and test cabal at the hackathon the other day, seemed to work ok
02:10:22 <cinimod> dcoutts: cinimod == reverse dominic btw
02:10:30 <dcoutts_> cinimod: ah, hia :-)
02:10:46 <dcoutts_> cinimod: we usually use #ghc or #hackage
02:11:12 <cinimod> dcoutts: ok I will try #hackage
02:12:02 <mm_freak_> i would be really grateful, if someone could add the arithmoi modules to lambdabot
02:12:15 <elliott> @hackage arithmoi
02:12:15 <lambdabot> http://hackage.haskell.org/package/arithmoi
02:12:23 <mm_freak_> they would be very useful in another channel
02:12:37 <elliott> are they fully safe haskell?
02:12:46 <mm_freak_> let me check
02:13:12 <elliott> they look it
02:13:26 <elliott> can I just import them all qualified or do any of them take common names?
02:14:01 <mm_freak_> elliott: i think there are no name clashes, but qualified imports (maybe Ar) would do as well
02:14:20 <elliott> "The implementation modules provide some additional functions, in particular some unsafe functions which omit some tests for performance reasons."
02:14:27 <elliott> I assume these are only unsafe in the sense of giving wrong results?
02:14:53 <elliott> ok, I'll try installing
02:15:10 <mm_freak_> yes, wrong results
02:15:26 <mm_freak_> if you want, i can gather a collection of functions that are safe to import
02:17:18 <mm_freak_> apparently they are all safe in terms of side effects…  some of them will give wrong results
02:18:01 <mm_freak_> elliott: .Logarithms, .Moduli, .Powers and .Primes would be useful
02:18:18 <mm_freak_> just import them with a common qualified module name Ar or something
02:19:06 <elliott> I'll just import them all
02:20:39 <int-e> sigh. Powers.Cubes.isPossibleCube ... "The precondition @n >= 0@ is /not/ checked." and then it does  unsafeAt cubeRes837 (fromIntegral (n `rem` 837))  which will *probably* never crash.
02:21:09 <elliott> oh, yikes.
02:21:15 <mm_freak_> yes, i would not import the unsafe ones
02:21:35 <elliott> how is it Safe-Inferred?!
02:21:41 <mm_freak_> elliott: let me write a safe import list for you, which you can just copy
02:21:50 <elliott> I'm already writing it
02:21:52 <elliott> :p
02:22:02 <quicksilver> surely probably never is good enough for anybody?
02:22:26 <quicksilver> I have some great real estate to sell which will probably never sink into the swamp.
02:22:27 <int-e> though it's not exported from ...Powers.
02:22:36 <mm_freak_> elliott: isPossibleCube is not imported by .Powers
02:22:51 <elliott> @undefine
02:22:51 <lambdabot> Undefined.
02:22:53 <elliott> > 123
02:22:54 <lambdabot>   L.hs:128:1:
02:22:54 <lambdabot>      Math.NumberTheory.GCD: Can't be safely imported!
02:22:54 <lambdabot>      The ...
02:23:00 <elliott> mm_freak_: but the module with the unsafe stuff is listed as Safe-Inferred.
02:23:00 <elliott> ohhh
02:23:05 <elliott> it's that haddock bug thing.
02:23:14 <elliott> @undefine
02:23:14 <lambdabot> Undefined.
02:23:15 <elliott> > ()
02:23:16 <lambdabot>   L.hs:128:1:
02:23:16 <lambdabot>      Math.NumberTheory.Logarithms: Can't be safely imported!
02:23:16 <lambdabot>   ...
02:23:18 <elliott> eh
02:23:29 <elliott> mm_freak_: I don't think this will work unless the safe modules get Trustworthy annotations.
02:23:37 <elliott> haddock is just lying when it says they're Safe-Inferred
02:23:44 <mm_freak_> hmm, i see
02:23:47 <elliott> @undefine
02:23:48 <lambdabot> Undefined.
02:23:49 <mm_freak_> ok, i'll contact the author
02:23:52 <mm_freak_> thanks
02:23:55 <elliott> sorry :)
02:24:01 <elliott> it's a shame how bad safety support is :(
02:24:21 <mm_freak_> yeah, but i think it's reasonable in this case…  it uses a lot of primitive stuff for efficiency
02:25:03 <mm_freak_> powerMod is orders of magnitude faster than a regular Integer implementation
02:25:20 <elliott> yeah, I don't mind optimisation
02:25:34 <elliott> but it's a shame that, say, every package depending on hashable was unsafe by default until recently.
02:25:45 <elliott> and nobody noticed but me
02:28:08 <quicksilver> I suspect that most people don't have any reason to notice if their packages have the wrong safeness
02:28:53 <elliott> yeah
02:29:06 <elliott> I think it proves almost nobody is using Safe Haskell though :)
02:29:31 <adnap> elliott: Isn't Safe Haskell new?
02:31:22 <elliott> yeah but not that new
02:31:28 <elliott> by haskell standards anyway
02:32:02 <mroman> anybody now how to use runCGIT?
02:32:04 <mroman> *know
02:32:15 <mm_freak_> https://bitbucket.org/dafis/arithmoi/issue/3/safe-haskell
02:33:00 * mm_freak_ wonders if apfelbox_ is heinrich apfelmus
02:33:38 <apfelbox_> am not ;-)
02:33:46 <mm_freak_> ok =)
02:33:51 <adnap> mm_freak_: Not
02:33:53 <adnap> Hah
02:33:58 <adnap> mm_freak_: I asked the same thing
02:35:45 <mm_freak_> mroman: not sure whether that helps but i think you don't use runCGIT, but check out the various web server frameworks in haskell
02:36:06 <Kelet> What do you think is the main contributor to Haskell code being more expressive than $imperative_lang? I would say first-class functions and higher-order functions are a huge contributor but then most modern imperative languages have those (or atleast tend to emulate them) these days.
02:36:28 <Kelet> And by expressive I suppose I mean that you accomplish more in the same amount (character count) of effective code.
02:36:35 <mm_freak_> Kelet: the type system and lazy evaluation
02:36:50 <zomg> and composing functions
02:37:00 <mroman> mm_freak_: I need to run the program as if it were not a cgi program
02:37:02 <Eduard_Munteanu> I have a record type   data Foo f = Foo { fooBar :: f Bar, fooBaz :: f Baz, ... }   . Is there a way to make 'f' a true identity functor so I get those fields naked?
02:37:08 <mroman> but the usual runCGI does stuff it should not do
02:37:13 <mroman> like printing headers and stuff
02:37:21 <mm_freak_> type system example:  x^y could actually mean "x raised to y in group G using efficient square and multiply" in haskell
02:37:23 <Ghoul_> Kelet: its mostly lazy evaluation
02:37:44 <mm_freak_> laziness example:  map f = foldr (\x xs -> f x : xs) []
02:38:06 <Ghoul_> Would it be possible for laziness to be a completely compile-time thing?
02:38:16 <Ghoul_> (through, ie: flow analysis or something)
02:38:23 <mm_freak_> Ghoul_: what do you mean?
02:38:45 <Ghoul_> Well, there's probably enough information at compile time to not need thunks for lazy evaluation, I think
02:38:53 <Ghoul_> but it'd be a very complex thing to do
02:39:03 <mm_freak_> Ghoul_: GHC already has the awkwardly named strictness checker
02:39:45 <mm_freak_> Ghoul_: but most of the functions you use are in fact nonstrict
02:40:02 <Eduard_Munteanu> Ghoul_: if your language is total then strictness shouldn't matter semantically, and with codata you may be able to limit it to certain things
02:40:18 <mm_freak_> Ghoul_: even IO critically depends on nonstrict semantics
02:40:31 <Ghoul_> I just make that observation because under -O2 I still get like 30% gains everywhere by spewing out bang patterns left, right and center
02:41:09 <mm_freak_> Ghoul_: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
02:41:12 <Eduard_Munteanu> Ghoul_: sounds like you're doing some heavy lifting cpu-wise
02:41:35 <mm_freak_> Ghoul_: my code rarely contains even a single bang
02:42:04 <mm_freak_> you probably overuse explicit recursion that is not corecursion =)
02:42:13 <mroman> hm
02:42:16 <mroman> looks like I got it.
02:43:29 <mroman> neat
02:44:27 <mroman> http://codepad.org/6AOuZbfO
02:44:36 <mroman> let's hope that has no sideffects
02:50:45 <adnap> mm_freak_: I can barely understand that post. There's so much unfamiliar vocabulary :/
02:51:47 <mm_freak_> adnap: that means you have a bunch of stuff you can study in your spare time =)
02:52:06 <adnap> mm_freak_: Sort of. There aren't good references in the post to the definitions
02:52:22 <adnap> mm_freak_: It's also hard to find references that assume no prior knowledge
02:53:11 <adnap> I am really enjoying http://chimera.labs.oreilly.com/books/1230000000929 and one of the great things is that it teaches so much from the ground up
02:53:44 <mm_freak_> indeed
02:54:04 <mroman> would it be better to just implement a few set of builtins and then write the rest in the script language you're developing or just do everything as a built-in?
02:54:05 <mm_freak_> just yesterday i wrote a very interesting comparison between repa and accelerate =)
02:54:21 <mm_freak_> adnap: http://lpaste.net/92449, http://lpaste.net/92450
02:54:27 <mroman> builtins are almost certainly faster
02:54:33 <mroman> but it bloats up interpreter code.
02:55:09 <Ghoul_> mm_freak_: times?
02:56:25 <mm_freak_> adnap: same algorithm, pretty much same code (modulo lets, wheres and types), 6.7s on quadcore, 800ms on GPU
02:56:33 <mm_freak_> Ghoul_: ?
02:56:48 <adnap> mm_freak_: I onlu read the first parallel chapter. I'm more interested in concurrency right now, and I have read the first three chapters of the concurrency part of the book
02:57:05 <mm_freak_> ah
03:00:45 <Ghoul_> those were the numbers I wanted, thanks :)
03:00:48 <Ghoul_> and wow, accelerate is faaast.
03:04:30 * hackagebot haskell-updater 1.2.0.10 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.10 (AlexanderVershilov)
03:11:48 <Eduard_Munteanu> Are there any extensions that would allow something like  data Foo f = Foo (f Int)   type Id a = a   nakedFoo :: Foo Id    nakedFoo = Foo 3    ?
03:12:33 <mm_freak_> Eduard_Munteanu: no
03:12:50 <Eduard_Munteanu> :(
03:13:04 <mm_freak_> Eduard_Munteanu: the proper response should be ":)" =)
03:13:18 <Eduard_Munteanu> mm_freak_: oh, I do appreciate the answer :)
03:13:34 <mm_freak_> Eduard_Munteanu: not to the answer, to the lack of such an extension
03:13:41 <Eduard_Munteanu> Hm, why is that?
03:14:07 <Eduard_Munteanu> Agda makes that rather trivial.
03:14:12 <mm_freak_> Eduard_Munteanu: well, you probably don't want undecidable typechecking
03:14:37 <mm_freak_> agda has totality checking, which haskell lacks
03:14:56 <Eduard_Munteanu> I don't need to make instances with that though.
03:16:00 <Eduard_Munteanu> I was writing something like   Foo Parser   then hoping to "run" the parser and get plain stuff in there.
03:16:09 <Eduard_Munteanu> (where Foo is in fact a big record)
03:16:36 <tomejaguar> Yes this is an interesting question.  See "Identity" all over lens for example.
03:16:45 <tomejaguar> I've often been curious about such a thing.
03:17:34 <zeroXten> any particular reason why its /= instead of != ?
03:18:18 <Eduard_Munteanu> I suppose I can parametrise Foo by the entire field types though it kinda sucks.
03:18:29 <ski> zeroXten : proably to look somewhat more like `≠'
03:18:37 <Taneb> zeroXten, /= looks more like ≠
03:19:12 <zeroXten> ah right, fair enough
03:19:45 * zeroXten notices a bit of perl fall out of his left ear
03:23:58 <NNOTM> Sometimes I think it would make more sense to have := instead of = and = instead of ==
03:24:39 <zeroXten> really, why?
03:25:08 <zeroXten> well, i can imagine why
03:25:10 <NNOTM> because seems like it would be closer to the usual mathematical notation
03:25:34 <arbn> := makes me think of variable assignment in imperative languages. Pascal and such.
03:25:48 <NNOTM> It is somewhat similar. It's a constant assignment.
03:26:20 <NNOTM> In haskell
03:27:00 <Taneb> Or we could do what VB does and just use = for everything
03:27:01 * Taneb shot
03:28:07 <NNOTM> Yes, I'm not quite sure how significant the disadvantages of that would be, though
03:28:15 <NNOTM> probably not very significant
03:28:52 <Taneb> a = b = c
03:29:04 <Taneb> Is that defining the (=) function to be \_ _ -> c?
03:29:13 <Taneb> Or is it defining a to be b == c?
03:29:14 <NNOTM> Ah
03:29:15 <NNOTM> true
03:29:45 <ski> i think it makes sense to use `=' for definitions, because the definitions are actually true as statements (i.e. propositions, not in the sense of commands)
03:30:08 <Taneb> I don't think that it really matters that much
03:30:15 <ski> we can use the definitions of functions to *reason* about expressions, e.g. to refactor them, or to prove properties about them
03:30:33 <NNOTM> And I suppose it makes sense not to use = for ==, because that's actually a true statement, but a question...
03:30:44 <NNOTM> nnot a true statement*
03:30:51 <NNOTM> s/nn/n
03:31:37 <Taneb> We could use =?
03:31:59 <Taneb> Which would confuse everybody ever
03:32:13 <NNOTM> Yep. So many bad possibilities.
03:35:16 <tomejaguar> Treating = as a statement of equality.  In GHC, operationally  ... exp ... exp ... is not the same as let x = exp in ... x ... x ....  In fact operationally x = exp is actually quite close to the imperative idea of assigning a thunk to the name x.
03:35:19 <donri> idris uses ?= for "provisional definitions"
03:35:52 <ski> tomejaguar : but denotationally, it's the same
03:36:12 <donri> which IIUC let you write types that don't unify and then later a proof that they're equal
03:36:29 <ski> (and i'd not say it's close to imperative assignment, since assignment presupposes the ability to *re*assign)
03:36:49 <tomejaguar> i don't think assignment implies reassignment
03:37:26 <ski> well, then i'd suppose you'd say Prolog has assignment (?)
03:38:12 <quicksilver> the imperative semantics of "a = 5" clearly admits the possibility that a can be accessed before the assignment
03:38:14 <ski> donri : if `t0' and `t1' are types, is `t0 ?= t1' then also a type ?
03:38:33 <quicksilver> let-binding creates a new scope
03:38:51 <tomejaguar> well ok, /declaration/ if you like
03:39:04 <donri> ski: no i think this is syntax
03:39:08 <tomejaguar> what I said was "operationally x = exp is actually quite close to the imperative idea of assigning a thunk to the name x." which I do believe to be true
03:39:28 <tomejaguar> change it to "declaring the name x to refer to the thunk exp" if you like
03:39:32 <ski> donri : then i'm not sure how it would be used ..
03:39:35 <donri> ski: but it does also have a value-level = operator, which is actually type equality (and types are at the value level)
03:39:58 <ski> well, a declaration is very different from an imperative command
03:40:27 <ski> executing an imperative command has a side-effect (usually involving state, perhaps also some other side-effects)
03:40:28 <donri> yes. i'm not sure what you're trying to say though?
03:40:40 <ski> elaborating a declaration results in a set of new variable bindings
03:41:02 <ski> (and variable binding is very different from assignment to a mutable cell (which might be unnamed))
03:41:30 <donri> i was just making a random remark  because Taneb's =? reminded me of ?= (in fact i first thought it was also =?)
03:42:40 <donri> ski: page 37 if you were actually curious http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf
03:42:45 <tomejaguar> What's the difference between declaration and assignment-to-a-namewhere-the-compiler-never-lets-you-reassign?
03:44:40 <donri> = in haskell is a bit like named capture groups in regepx ;)
03:45:55 <ski> tomejaguar : well, in e.g. C, you could say that `int x = 0;' does two things : (a) it *binds* the name `x' to a mutable location; and (b) it *initializes* that mutable location to the value `0'
03:46:21 <ski> in this case, the variable name isn't bound to a value, but to a mutable location (a mutable cell)
03:46:46 <ski> however, in Haskell, using `let', a variable is bound to a value (since there's no assignment)
03:47:06 <ski> but a declaration can also bind a name to a type, or to a type class, &c.
03:47:46 <tomejaguar> Hmm, I suspect this depends on which way you look at things.  Since you could consider x to be immutably bound to a value, that is, the location of the cell.
03:47:53 <ski> i'm not sure how you would construe a binding-name-to-type or binding-name-to-mutable cell as an assignment (in the sense of `x = x + 1' in C)
03:48:24 <tomejaguar> x = x + 1 isn't changing x.  It's changing the value that x refers to.
03:48:27 <ski> tomejaguar : well, more or less. in C terminology, `x' is bound to an "lvalue" -- what i was calling values above is then "rvalues"
03:48:31 <ski> yes
03:48:56 <donri> but you can reassign what cell a name is bound to in C, can't you?
03:49:04 <tomejaguar> OK well, I don't think "x = exp" in Haskell is especially different from a constant reference.
03:49:08 <tomejaguar> donri: you can?
03:49:17 <ski> in e.g. SML, the equivalent would be `x := !x + 1', where `!' is an explicit mutable-cell-dereference operator
03:49:29 <ski> donri : nope
03:49:57 <donri> *int x; x++ // pointer arithmetic, no?
03:50:00 <donri> i've never really used C
03:50:07 <tomejaguar> but that's changing *x
03:50:09 <tomejaguar> not x
03:50:18 <tomejaguar> err
03:50:23 <tomejaguar> That's not what I meant.
03:50:41 <tomejaguar> If you have *int x then you can consider x to be a cell containing an int pointer
03:50:52 <tomejaguar> then ++x changes that pointer, not the cell that x refers to
03:51:07 <m3ga> '*int x;' is not valid C code
03:51:40 <ski> donri : in C++, if `int x; int a[2]; int &y; &y = x; &y = &(a[1]);' was possible, then this would reassign which cell `y' was bound to (but i think you can only use this sense of `&' when passing parameters to a function, not in any other place, so this is then invalid C++)
03:51:43 <donri> int *x? i don't speak C :p
03:52:02 <aiXu> Hello, can you help me with Haskell + Math problem, please?
03:52:19 <Dtgr> donri: either int* x; or int *x; :)
03:52:30 <ski> `int *x;' would declare `x' to be bound to a mutable cell which may contain values of type "pointer to `int'"
03:52:46 <ski> (cf. `x :: Ptr Int' in Haskell)
03:52:53 <tomejaguar> Dtgr: or int * x;
03:53:03 <Dtgr> yeah, or int    *   x;
03:53:32 <donri> oh i guess a pointer is itself stored in a memory location
03:53:45 <donri> (duh)
03:53:58 <mauke> int (*(x));
03:54:05 <ski> (hm, instead of `&y = x;' in the pseudo-C++, it ought to have been `&y = &x;' -- oh well)
03:54:17 <aiXu> How can i define function such as that: it takes starting point (x,y) width and height of recantgle and returns all points withing that reactangle like: f (1,1) 2 2 => [(1,1),(2,1),(1,2),(2,2)]?
03:54:52 <ski> > range ((1,1),(2,2))
03:54:53 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
03:55:26 <aiXu> ski: Whoa.
03:55:42 <ski> mostly to be used for array indices
03:55:46 <ski> @type range
03:55:47 <lambdabot> Ix a => (a, a) -> [a]
03:56:02 <ski> > range ('0',':')
03:56:03 <lambdabot>   "0123456789:"
03:56:33 <aiXu> ski: Thank you.
03:56:55 <ski> what do you want to use this for ?
03:57:43 <ski> > [(x,y) | y <- [1 .. 2] , x <- [1 .. 2]]  -- is otherwise how you can do this sort of thing manually
03:57:44 <tomejaguar> > ['0' .. ':']
03:57:45 <lambdabot>   [(1,1),(2,1),(1,2),(2,2)]
03:57:45 <lambdabot>   "0123456789:"
03:57:55 <aiXu> ski: For point on map creation. Every point is Int so it's perfect for me.
03:57:59 <ski> > range ('0','@')
03:58:00 <lambdabot>   "0123456789:;<=>?@"
03:58:15 <ski> aiXu : sounds reasonable
03:58:31 <ski> you'll have to decide whether you care about "row vs. column order"
03:58:33 <Tinned_Tuna> for half a second then, I was worried that what lambdabot sent back was a valid Haskell expression.
03:59:26 <tomejaguar> Tinned_Tuna: it's close
03:59:56 <tomejaguar> Get rid of the ; and it can be.
04:00:11 <tomejaguar> I suppose you have to put it in ()s
04:02:08 <arkeet> > liftA2 (,) [1,2] [1,2]
04:02:09 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
04:02:28 <arkeet> > liftA2 (,) "abc" "123"
04:02:30 <lambdabot>   [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c'...
04:11:10 <aiXu> > let f (x,y) w h = [(x, y) | y <- [y .. h + y - 1] , x <- [x .. w + x - 1]] in f (2,1) 2 2
04:11:11 <lambdabot>   [(2,1),(3,1),(2,2),(3,2)]
04:11:50 <aiXu> Point rect starting at x = 2, y = 1.
04:12:27 <aiXu> That -1 bugs me.
04:12:40 <aiXu> But it seems to work just fine.
04:13:56 <Ghoul_>  > let f (x,y) w h = [(x, y) | y <- [y .. pred $ h + y] , x <- [x .. pred $ w + x]] in f (2,1) 2 2
04:15:48 <sopvop> >let f (x,y) h w = [(x,y), (x+w, y), (x, y+h), (x+w, y+h)] -- there, I've shortened it a bit
04:18:37 <lpaste> adnap pasted “griding to a halt” at http://lpaste.net/92508
04:19:12 <adnap> Can someone explain why ^ prints 5, 42, 42, ..., and then nothing?
04:21:59 <sopvop> Dear #haskell, I just want to share my love of GHC.TypeLits and especially Symbol kinds. These are awesome.
04:24:24 <aiXu> How was that language similar to haskell but with dependent types called?
04:24:33 <Taneb> Agda, maybe?
04:24:36 <aiXu> Not theorem prover.
04:24:39 <aiXu> Taneb: Nope.
04:25:01 <Taneb> Idris?
04:25:09 <aiXu> Taneb: Exactly.
04:25:21 <aiXu> Thanks, somehow i've forgot it.
04:25:41 <tomejaguar> Is Idris not a theorem prover?
04:25:51 <aiXu> tomejaguar: Nope.
04:25:56 <quicksilver> all dependent type languages are theorem provers
04:26:06 <quicksilver> it's just a question of how well you hide it
04:26:17 <quicksilver> and how you choose to spin it
04:26:21 <aiXu> quicksilver: He-he.
04:26:32 <aiXu> Is there any interop between haskell and idris?
04:26:45 <aiXu> Besides haskell -> c -> indris?
04:26:54 <aiXu> It'll be great to hake haskell -> idris.
04:26:58 <aiXu> have*
04:28:18 <sopvop> Is Idris useful for anything "real world" right now?
04:28:35 <aiXu> Hm, it seems written is haskell.
04:28:51 <aiXu> http://hackage.haskell.org/package/idris But why on earth it depends on java?
04:29:25 <donri> possibly it can compile to java?
04:30:00 <opqdonut> "Experimental Java backend"
04:30:06 <opqdonut> says http://www.idris-lang.org/idris-0-9-8-released/
04:30:08 <sopvop> So you can write type safe SingletonProxyBaseFactoy
04:32:49 <Cale> http://www.youtube.com/watch?v=ABmRkWS3wIU :D
04:33:03 <Cale> chrisdone: Nice demo
04:41:09 <erisco> augur, good morning
04:43:25 <augur> erisco: morning
04:43:33 <raichoo> Idris is still a research language, keep that in mind.
04:44:46 <raichoo> If you want it to support a certain feature: write it.
04:45:20 <erisco> augur, I am realizing the effect is to have a class per operation on list-likes
04:45:46 <erisco> augur, so the signature for any function which operates on list-likes will have in it all algorithms it needs
04:46:05 <erisco> augur, I was thinking of calling this "transparent form" or "essential form". give it that ring of authority ;)
04:48:41 <augur> erisco: this is the price you pay for genericity
04:48:49 <erisco> this is no cost to me
04:48:53 <erisco> this is exactly what I want
04:50:12 <erisco> think about it: you can look at any function signature and have some idea of the computational/memory complexity involves
04:50:17 <erisco> not perfect, but a step towards that
04:50:48 <amindfv> is there an obvious reason why i'm seeing "<command line>: cannot satisfy -package ghc" when running "ghci -package ghc"?
04:50:49 <erisco> coupled with information that "this function calls stripPrefix O(n) times" you're really getting somewhere
04:51:35 <amindfv> it's my first time using (trying to use) GHC API, and i've got a pretty clean build of the haskell platform
04:51:35 <erisco> and think about how many intermediate data structures there are in a program. there can be quite a few... the Cartesian product algo I made had one
04:51:40 <amindfv> with ghc 7.4
04:51:59 <erisco> these data structures are arbitrary (ambiguous type) and so the compiler could do just as well picking one itself
04:52:26 <augur> erisco: im not sure what you're getting with all this, to be honest.
04:52:43 <tdammers> sounds like automatic complexity analysis embedded into a programming language
04:52:49 <tdammers> I missed part of the discussion though
04:52:49 <erisco> what criteria to use? if the programmer can prove complexities to the compiler, then the compiler can reason which ADT to use based on performance criteria
04:52:57 <augur> you want to write a nice algo for a list-like type. i dont see why you dont just use a list-like type. what does the genericity buy you
04:53:27 <erisco> augur, maybe I am all alone =\ that is okay
04:54:01 <augur> erisco: but i mean, its important to know the purpose of what you're writing
04:54:23 <augur> it would be silly to write all of this, and realize you were only ever going to use that one special type anyway, so none of this was useful
04:54:29 <erisco> yes, I know the purpose
04:54:38 <augur> well you could let me in on it, at least!
04:54:39 <augur> :P
04:55:37 <erisco> well, I just extrapolated on how this is a step towards having the compiler select ADTs based on performance criteria (time vs space)
04:56:00 <erisco> ambiguous types naturally arise in a system like this and so the compiler can choose anything
04:56:36 <erisco> secondly, you've already demonstrated how you can write an algorithm for list-likes that actually manipulate a binary tree
04:57:17 <erisco> in fact zipWith can take a "list with length" and a binary tree and zip them into an ordinary list, or another binary tree
05:00:18 <erisco> augur, a motivating factor in my case is that the parser I am working on only requires ordinary lists for almost everything. However, in cases of ambiguous grammars, I really need a list with O(1) length determination
05:00:56 <erisco> do I make my entire parser work with Seq or something? no, of course not. I make most of my code work against list-like things and then naturally it works on list-with-length type things
05:01:11 <erisco> list-with-length in, list-with-length out, no code changed, no type conversions, all good
05:01:19 <augur> erisco: all of this becomes vastly more powerful with dependent types, btw.
05:02:27 <augur> but, what you seem to be aiming for is representation independence of algorithms, which has been looked at a lot.
05:02:43 <erisco> what have been the failings?
05:03:01 <augur> erisco: its just tradeoffs.
05:03:05 <augur> one hopeful way would actually be to have the isos be specifiable, instead of the interfaces
05:03:43 <augur> and then you might be able to specify implementation choices for specific contexts somehow, and use the isos when necessary, perhaps in some optimized, and silent, way
05:04:09 <augur> but as often happens, such silence has a cost -- lack of control
05:04:12 <erisco> mm, well, there is certainly work that language designers and implementors can do regarding this
05:05:04 <augur> views -- which is more or less what we're dealing with here on the case-ing side of things -- are a pretty good tool for certain tasks tho
05:05:50 <augur> like when the algorithm is defined over a different sort of structure, or a different recursion schema or something, but not in a way that makes it quite an isomorphism
05:06:22 <augur> but i never run my programs anyway, so i dont care about efficiency ;p
05:06:27 <quicksilver> amindfv: I believe the GHC package is hidden
05:06:47 <merijn> Is there a way to avoid needing parenthesis if you have the S and K combinators?
05:06:48 <erisco> that is a true graduation point right there
05:07:24 <merijn> I was thinking of a RPN approach, but since you need partially applied combinators I think you'd need a third application combinator?
05:07:33 <augur> erisco: maybe someone else has insights into the possible solutions here -- how to write generic algorithms so that representations can be chosen for performance properties
05:08:09 <erisco> augur, well, we've domonstrated the generic algorithm part fairly well
05:08:27 <augur> yes, we've demonstrated two solutions so far
05:08:34 <bartavelle> what is the extension that let you write | and -> in type signatures ? I don't know how to read those
05:08:36 <augur> use isos, or abstract to an interface
05:08:41 <bartavelle> erm
05:08:43 <augur> but are there others? better ones? probably.
05:08:46 <bartavelle> class signatures probably
05:08:53 <tomejaguar> bartavelle: functional dependencies
05:08:53 <merijn> bartavelle: Functional Dependencies
05:08:56 <bartavelle> thanks
05:09:21 <augur> bartavelle: a convenience way to find out the extensions name is to write the program and see what GHC chokes on :)
05:09:31 <bartavelle> augur : good point
05:09:34 <augur> convenient*
05:09:36 <erisco> augur, isos was weaker
05:09:58 <augur> bartavelle: i usually just write programs and then add in the relevant extensions until GHC stops moaning
05:10:34 <bartavelle> well in that case I'd like to understand what this means
05:10:37 <erisco> trivial example, LenList goes into 'tail', tail isos to [], takes the tail, isos back to LenList. O(n) cost for recalculating the length
05:10:39 <amindfv> quicksilver: so, how can I get access to the GHC API?
05:10:43 <augur> erisco: well, weaker in that it requires isomorphism! some sort of natural transformation or section/retraction is preferable
05:11:09 <augur> bartavelle: what which means?
05:11:11 <erisco> whereas with the abstract algorithm (ie one that works on the interface) there is no information loss
05:11:21 <bartavelle> the | a -> b thingies
05:11:25 <augur> bartavelle: oh
05:11:26 <erisco> iso necessary loses any information that cannot be stored on the destination type
05:11:31 <bartavelle> I'm reading the wiki now
05:11:37 <bartavelle> I don't have code to compile
05:11:38 <quicksilver> amindfv: you can unhide it but I think I'm wrong
05:11:38 <augur> bartavelle: if you have a class definition like this:   class Foo a b | a -> b where ...
05:11:39 <amindfv> (i'm trying to follow instructions here: http://www.haskell.org/haskellwiki/GHC/As_a_library)
05:11:47 <quicksilver> amindfv: I think hidden packages don't give that error anyway
05:12:09 <augur> bartavelle: it means that you can define as many instances of Foo as you like, except, for any choice of a, there is at most one choice of b that has an instance defined
05:12:21 <bartavelle> ahhh
05:12:24 <donri> bartavelle: it means you can only have one instance with that "a" and that the "b" is always the same for that "a"
05:12:25 <augur> bartavelle: so no fair having instances for   Foo Int Int   and also   Foo Int Bool
05:12:25 <bartavelle> that makes sense, thanks
05:12:43 <augur> you can have    Foo Int Int   and   Foo Bool Int   however
05:12:46 <donri> bartavelle: (this also helps type inference)
05:12:51 <erisco> heck, ++ doesn't even touch the tail list, but with iso it would
05:13:04 <erisco> have to convert both into lists, do the ++, then convert all back
05:13:47 <augur> erisco: optimizations of isos could help here
05:14:32 <augur> erisco: but no, isos dont lose information. they're isos, after all. Tree a is not iso to [a], there is merely a nice relationship between them
05:15:04 <augur> namely, an injection   fromList :: [a] -> Tree a
05:15:22 <erisco> not lose information in that sense, no, but lose information in the sense that it has to be recalculated
05:15:27 <augur> actually there are lots of nice injections like that
05:15:45 <augur> yes, recalculated, indeed. sometimes true.
05:16:22 <augur> anyway, this sounds like a good question to ask when more people are on
05:16:30 <amindfv> hm, maybe there's an issue with using GHC-API with hsenv...?
05:16:32 <augur> or ask in the mailing list or on SO or something where there are clear topics
05:16:38 <erisco> than 1142? :)
05:16:51 <augur> erisco: anyway, im gonna sleep for a bit. see ya!
05:16:54 <erisco> have fun
05:19:22 <merijn> Where's all the combinator calculus fans I always see talking about SKI in here?
05:19:37 <hpc> over there -->
05:19:57 <merijn> hpc: What, the empty right hand of my screen?
05:20:07 <hpc> ;)
05:20:08 <merijn> hpc: irssi doesn't have a nick list :p
05:20:20 <merijn> At least not a permanent one on the right hand side
05:20:25 <donri> what, in my channel list?
05:20:55 <hpc> more seriously, i haven't seen any SKI talk in quite a while
05:21:26 <merijn> hpc: I remember something in the past week, I think
05:23:47 <quicksilver> ski is named after combinators but he isn't contractually required to talk about them all the time
05:24:40 <merijn> Someone should revise his contract, then! I have questions :p
05:24:54 * hackagebot DrIFT 2.4.0 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-2.4.0 (KiwamuOkabe)
05:25:56 <merijn> oh, the Cambridge University Press site is working again, maybe this Okasaki paper will answer my questions instead
05:33:48 <merijn> Aww, sad times. He cheats and introduces push and apply operations for a stack, rather than only using combinators :\
05:37:20 <hpc> merijn: that's even worse than cheating with ($)!
05:38:26 <Taneb> merijn, anything particular you want to know?
05:38:32 <merijn> Oh, the day is saved again
05:38:55 <elliott> merijn: keep reading, it's not cheating
05:38:58 <elliott> if I'm thinking of the same paper.
05:39:00 <merijn> Apparently I only need the X combinator for during completeness, which means I can define my 2nd combinator to be "apply" (push being trivially implicit)
05:39:07 <merijn> s/during/Turing
05:39:52 <merijn> Maybe not as "usable" as having S and K, but then again, I don't think usability was ever really going to happen
05:43:01 <fylwind> @pl f x = g x y
05:43:04 <lambdabot> f = id (fix (const (flip g y)))
05:43:04 <lambdabot> optimization suspended, use @pl-resume to continue.
05:43:18 <dwcook> merijn, how is X defined in terms of LC?
05:48:20 <fylwind> @pl f x = j x >>= u
05:48:21 <lambdabot> f = (u =<<) . j
05:48:26 <aiXu> Hello again. Is there typeclass for basic arithmetic?
05:48:33 <merijn> dwcook: The paper says: X = λh.h(λf.λg.λx.(fx)(gx))(λx.λy.λz.x)
05:48:44 <erisco> aiXu, such as Num?
05:49:16 <merijn> dwcook: Where K=XX and S=X(XX) and I=SKK
05:50:19 <aiXu> erisco: I think it should work for me thanks.
05:50:43 <erisco> :t (+)
05:50:44 <lambdabot> Num a => a -> a -> a
05:50:49 <erisco> aiXu, that is another way to find out
05:51:49 <aiXu> Erstarrung: Yeah, thats it, when i've tried to (+) my ADT it said that i should make Num instance for that.
05:56:05 <aiXu> erisco: Hm, Num requires abs/signum/fromInteger function implewmentation but for my (Point x y z) type these doesn't make any sense.
05:56:45 <aiXu> aiXu: Is there something more apropriate than Num for Point type?
05:56:58 <Iceland_jack> aiXu: That's really a mistake in Num's specification
05:57:21 <erisco> Iceland_jack, are undefineds appropriate? :o
05:57:24 <quchen> merijn: There's also https://en.wikipedia.org/wiki/Iota_and_Jot which seems related
05:57:28 <Iceland_jack> erisco: Sometimes, yes.
05:57:43 <quchen> merijn: And note that you can encode any string in unary, getting rid of unnecessary syntactic noise :-)
05:57:45 <merijn> aiXu, Iceland_jack: I will argue that Point is not a sensible Num instance
05:58:11 <merijn> aiXu: The more appropriate thing would be to define you own functions to work with Point
05:58:22 <quicksilver> I wouldn't try to make Points into a Num but I also don't think it matters much
05:58:33 <quicksilver> there are no far-reach consequences to having "bad" num instances
05:58:37 <Iceland_jack> I see the appeal to use (+) to add two points
05:58:47 <quicksilver> just put 'error' in the methods you don't want
05:58:56 <aiXu> Iceland_jack: Indeed, it's appealing:   (Point x y z) + (Point x' y' z') = Point (x + x') (y + y') (z + z')
05:58:59 <tomejaguar> quicksilver: and hope you never type them by accident?
05:59:05 <Iceland_jack> rather that something ugly like (p1 `pointerAdd` p1)
05:59:19 <quicksilver> tomejaguar: personally I don't type "signum" by accident very often.
05:59:33 <quchen> (+.) = addPoints  --  problem solved
05:59:39 <quicksilver> if I weirdly did then the error message would explain it pretty well
05:59:41 <Iceland_jack> In a perfect world Num would be split up into more type classes
05:59:46 <quicksilver> so I can't say I think this is big issue
05:59:53 <elliott> you can use linear.
05:59:54 <elliott> @hackage linear
05:59:55 <lambdabot> http://hackage.haskell.org/package/linear
06:00:02 <elliott> that way you get nice typeclasses to instantiate your points with.
06:00:04 <quicksilver> but, aesthetically, I would use different operators - ^+^ and ^-^ say - for vector addition
06:00:11 <elliott> and don't compromise your ethics
06:00:21 <Iceland_jack> elliott: Which ethics?
06:00:35 <tomejaguar> quicksilver: if you weirdly did you wouldn't get an error message until runtime
06:00:49 <quicksilver> yes indeed tomejaguar
06:00:55 <quicksilver> but it would be a pretty obvious one nonetheless
06:01:16 <quicksilver> there's all kinds of ways to use the type system to get more checked at compile time
06:01:22 <quicksilver> but this particular one doesn't excite me
06:01:27 <Iceland_jack> (^-^) and (^+^) look too similar to smileys to take them seriously..
06:01:37 <quicksilver> I don't like to take my code seriously
06:01:55 <hpc> i never take my code seriously
06:02:15 <Iceland_jack> You say that but I'm pretty sure most Haskellers do take their code very seriously :)
06:02:24 <fylwind> is it weird to liftA2 the <|> operator?
06:02:38 <quchen> No.
06:02:40 <erisco> :t liftA2 <|>
06:02:41 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:02:46 <erisco> :t liftA2 (<|>)
06:02:47 <lambdabot> (Applicative f, Alternative f1) => f (f1 a) -> f (f1 a) -> f (f1 a)
06:02:59 <latermuse> what is the best haskell server for maximum concurrent connections?
06:03:03 <quchen> fylwind: For example you might want to (<|>) two things that are created by IO.
06:03:18 <hpc> latermuse: main = system "tmux"
06:03:28 <hpc> er
06:03:31 <hpc> main = system "tux"
06:03:34 <t7> latermuse: warp?
06:03:36 <hpc> https://en.wikipedia.org/wiki/TUX_web_server
06:03:39 <hpc> ;)
06:03:48 <fylwind> quchen: I found it useful for expressing alternatives between two "a -> Maybe b" functions
06:04:05 <latermuse> im making a server that will need to handle upwards of a thousand concurrent connections a second
06:04:13 <latermuse> on average
06:04:23 <nObody52> pls join #lezbiyen
06:04:42 <quchen> fylwind: There's nothing wrong with liftA2-ing anything, it's a general purpose function. It's not uncommon to liftA2 (<*>) either, that's how you define an Applicative from two nested Applicatives.
06:06:17 <fylwind> quchen: I get this warm fuzzy feeling whenever I find a use for the (rather abstract) functions like lift's
06:06:54 <erisco> its complicated: it must be right!
06:06:56 <quchen> fylwind: Lifts are pretty common, don't be afraid of them.
06:07:32 <quchen> fylwind: liftA0 = pure, liftA1 = fmap, liftA2 = two arguments etc.
06:07:46 <quchen> fylwind: There's a whole lot of lifting around even when you're not using lifts. :-P
06:08:08 <ParaSa1lin> @src liftA2
06:08:08 <lambdabot> liftA2 f a b = f <$> a <*> b
06:08:45 <Hodapp> come at me bro, do you even...
06:09:12 <erisco> > (,) <$> [1,2,3] <*> [4,5]
06:09:13 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
06:09:37 <yopikh> :t (,)
06:09:38 <lambdabot> a -> b -> (a, b)
06:09:41 <tomejaguar> erisco: if it's complicated and it typechecks, it's probably right!
06:10:10 <quchen> tomejaguar:
06:10:12 <fylwind> quchen: that's why I like Haskell :D
06:10:15 <quchen> @quote shachaf length
06:10:15 <lambdabot> shachaf says: (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^
06:10:16 <lambdabot> 2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })  That's the best way to square all the elements of a list in Haskell, by far.
06:11:41 <Cale> haha
06:12:00 <JordiGH> If I want to write code that will take advantage of AES CPU instructions, can I do this in Haskell?
06:13:00 <t7> not really
06:13:06 <luite> JordiGH: not with only haskell
06:13:07 <t7> call a C function
06:13:19 <JordiGH> Well, I can't really do it in C either. I'll have to write assembly.
06:13:20 <Cale> JordiGH: You might be able to add support for them to Harpy.
06:13:26 <Cale> http://hackage.haskell.org/package/harpy
06:14:11 <Lethalman> JordiGH, seems like gcrypt has it, so just use some bindings in haskell
06:14:12 <Cale> It lets you generate assembly-level code at runtime and then call it. :)
06:14:23 <Hodapp> Cale: whaaaat? That's crazy.
06:14:43 <luite> perhaps llvm-general already has them
06:16:49 <JordiGH> Okay, so this was just more of a general question, if I wanted to be able to outsmart the Haskell compiler, is it at all possible?
06:16:54 <JordiGH> I guess Harpy is how I would do it?
06:17:00 <Cale> Well, it's one way
06:17:21 <bartavelle> JordiGH, you can directly write the compiled code in a CString if you don't need runtime specialization
06:18:20 <Cale> Generally, for this sort of thing where you either really care about performance or you need special things going on at a low level, you see people using Haskell as a metalanguage -- you'll have some library of stuff which is useful for writing programs that generate code to solve your problem.
06:18:56 <Cale> Atom is like that -- it's used to write programs that emit pre-scheduled realtime code for embedded applications.
06:19:44 <Cale> But there's also the option of just plain FFI with bits of C (perhaps with inline assembly), possibly with some unsafePerformIO use if what you write is actually pure.
06:19:58 <Cale> Or of course, adding facilities to GHC itself.
06:20:35 <JordiGH> Compiler code scares the crap out of me.
06:20:37 <Cale> (e.g. how GHC uses epoll/kqueue where available in place of select)
06:20:40 <JordiGH> Is ghc written in Haskell?
06:20:43 <Cale> yes
06:20:58 <JordiGH> So it *is* possible to low-level it down to assembly in pure Haskell?
06:20:59 <Cale> It's in Haskell, and the runtime system has some C
06:21:11 <Cale> yep
06:21:15 <JordiGH> The runtime, but the compiler itself knows how to emit asm?
06:21:20 <Cale> yes
06:21:32 <Cale> There's a native codegen, as well as an LLVM backend
06:21:35 <luite> JordiGH: yeah, though GHC calls an external assembler (or llvm) to write the actual machine code, but it's certainly not impossible to do it directly
06:24:27 <Cale> I'm not really the best person to help find how to modify GHC (I've never contributed a patch, but I have spent a little time looking at GHC code now and then), but if I was going to do it myself, I'd start by looking at how the primitive operations on Int# values were implemented.
06:24:43 <Cale> and probably mimicking things from there
06:25:28 <Cale> I recall at one point working out exactly how some floating point operations were compiled and not having too much difficulty tracking it down.
06:32:40 <aloiscochard> jon harrop just published some microbenchmark f#/ocaml/haskell for the one interested: http://flyingfrogblog.blogspot.co.uk/2013/09/hash-table-insertion-performance-f-vs.html
06:32:52 <JordiGH> Hm, alright.
06:34:42 <Cale> aloiscochard: It should be noted that he is in general, to put it lightly, a bit of a troll (though I haven't seen the post)
06:35:15 <aloiscochard> Cale: I think you are very kind to just say "a bit"
06:35:32 <Cale> It's unclear what these benchmarks are even comparing.
06:35:44 <bergmark> yeah a lot of details missing
06:35:51 <aloiscochard> Cale: I'll ask him to reveal the code
06:35:59 <aloiscochard> otherwise the competition is pointless
06:36:16 <Cale> I wouldn't put it past him to use Data.HashTable :P
06:36:26 <aloiscochard> oh I found it
06:36:28 <aloiscochard> http://flyingfrogblog.blogspot.co.uk/2009/04/f-vs-ocaml-vs-haskell-hash-table.html
06:36:34 <aloiscochard> he reuse it every year
06:36:35 <Cale> ahahaha
06:37:06 <Cale> Data.HashTable is deprecated and going to be removed in GHC 7.8 at least, so he won't be able to abuse it.
06:37:47 <Cale> The only reason it's there is that some bits of GHC used it. It's not a particularly good implementation, nor is it really attempting to be.
06:38:03 <aloiscochard> I would love giving a try at doing a proper haskell impl. to see some meaningful result
06:38:23 <Cale> Try using the unordered-containers package
06:38:42 <tomejaguar> "If only Haskell programmers could take some time away from writing Fibonacci functions perhaps they could also build some kind of adequate compiler."
06:38:52 * tomejaguar -> build some kind of adequate compiler
06:38:56 <tomejaguar> hey wait a minutes
06:39:00 <tomejaguar> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
06:39:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
06:39:07 <tomejaguar> wow, that's kind of cool ...
06:39:08 <aloiscochard> Cale: thanks I'll take a look once have some time
06:39:11 <aloiscochard> tomejaguar: lol
06:39:12 * tomejaguar is distracted
06:39:19 <aloiscochard> tomejaguar: where did you read this?
06:39:31 <tomejaguar> at the bottom of the second link you posted
06:39:33 <Cale> That's the standard implementation of fibs :)
06:39:50 <aloiscochard> tomejaguar: ty
06:40:26 <WraithM> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
06:40:29 <lambdabot>   354224848179261915075
06:42:14 <erisco> :t stripPrefix
06:42:15 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
06:44:42 <evancz> anyone around familiar with happstack?
06:44:59 <evancz> I am having very odd performance issues
06:45:04 <boothead> Afternoon all. Is there a way to express a shorthand for several class instances? I'm typing (Typable a, FromJSON a) a lot!
06:45:32 <evancz> performance is degrading enough to make it unusable/unstable
06:45:32 <erisco> >stripPrefix [] []
06:45:40 <erisco> > stripPrefix [] []
06:45:42 <lambdabot>   Just []
06:45:59 <tomejaguar> boothead: I believe someone here will tell you about "Constraint kinds"
06:46:41 <quchen> tomejaguar: Type-level lambda would be useful here.
06:47:08 <cinimod> @seen cinimod
06:47:08 <lambdabot> (IniMoD
06:47:43 <boothead> tomejaguar, ohh shiney!
06:50:01 <cinimod> ever
06:51:33 <erisco> @src tails
06:51:33 <lambdabot> tails []         = [[]]
06:51:33 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:58:33 <merijn> Shouldn't "tails [] = []"?
06:58:50 <erisco> no
06:59:10 <merijn> oh, I see
06:59:52 <erisco> merijn, at least it would make working with the result trickier for me =\
07:00:16 <erisco> how does Haskell do this
07:00:21 <erisco> > ['a','b','c']
07:00:22 <lambdabot>   "abc"
07:00:24 <erisco> > [1,2,3]
07:00:29 <lambdabot>   [1,2,3]
07:00:45 <erisco> are there cheat codes in the compiler?
07:00:49 <quchen> Yes.
07:00:53 <TallerGhostWalt> lol
07:00:55 <bergmark> erisco: that's just in the printing, strings are lists
07:01:04 <erisco> bergmark, I'm talking about the printing
07:01:05 <quchen> [] notation is a cheat code in the first place. "" is a cheat code for the cheat code. :-)
07:01:08 <hpc> erisco: there's two functions at work here, show and showList
07:01:15 <hpc> :t showList
07:01:16 <lambdabot> Show a => [a] -> ShowS
07:01:33 <hpc> (just pretend that's [a] -> String)
07:01:44 <hpc> so for most types, showList = show
07:02:01 <erisco> mm okay
07:02:06 <hpc> er
07:02:07 <hpc> hang on
07:02:09 <elliott> that's a bit misleading
07:02:13 <elliott> since show is defined in terms of showList there
07:02:31 <elliott> it's denotationally true though! just not a definition
07:02:39 <Jeanne-Kamikaze> cheat codes :D
07:02:40 <hpc> yeah, showList has a default definition that is the actual list code
07:02:44 <hpc> my bad
07:02:49 <hpc> anyhoo, so for lists, you have
07:02:59 <hpc> instance Show a => Show [a] where show = showList
07:03:07 <hpc> to continue cheating on the type
07:03:20 <quicksilver> **"for most types, showList = shows"**
07:03:26 <quicksilver> that extra 's' is quite important.
07:03:38 <hpc> for Char, showList is overridden
07:03:50 <hpc> to stringify the result
07:03:54 <erisco> any chance to override for custom types?
07:04:05 <erisco> for Show at least
07:04:11 <hpc> so when you do show [1,2,3] for [Int], it's calling showList for Int
07:04:18 <hpc> which is default
07:04:23 <erisco> I guess I'll convert to list then show :P
07:06:00 <hpc> anyhoo, the point is, you aren't going to get a string to show in a listy way by "converting to list" because it's already a list
07:06:28 <hpc> apparently showList__ is the function you want to call (for ghc at least)
07:06:33 <hpc> but i don't think it's exported
07:06:43 <erisco> no, I do not have a [], but there is a string I wish to show
07:06:47 <hpc> in conclusion, don't use Show for real logic
07:07:03 <erisco> so show . toList ... easy 'nuf
07:07:49 <elliott> erisco: String is the same thing as [Char].
07:08:06 <elliott> so no matter what toList is, I doubt it will do much
07:08:17 <erisco> "there is a string" -> "there is a data structure which can be converted into [Char]"
07:08:56 <geekosaur> someone's reading too much into the nonstandard isString?
07:09:01 <geekosaur> er, IsString
07:09:07 <quicksilver> [Char] will always show as ['a','b','c'] though erisco
07:09:16 <quicksilver> [Char] = String
07:09:29 <erisco> okay look, doesn't matter, it works. thanks :)
07:10:26 <bergmark> or do
07:10:32 <bergmark> newtype S = S String; instance Show S where show (S s) = '[' : (intercalate "," (map show s)) ++ "]"
07:12:36 <merijn> Testing question!
07:13:01 <merijn> What's the most convenient way to integrate testing at process/binary granularity into cabal?
07:13:36 <hpc> make a Test.hs and mark that as your test script in cabal
07:13:49 <hpc> at least, that's the only way i know
07:14:06 <ski> merijn : well, someone was now asking a question pertaining to Hilbert-style over in ##logic, which is basically the same thing
07:14:11 <hpc> i don't think the tests will run automatically, but "cabal test" will work
07:14:21 <ski> "Is there a way to avoid needing parenthesis if you have the S and K combinators?" -- i recall seeing such a paper, but i can't recall the name :/
07:14:35 * ski eyes hpc warily
07:14:37 <merijn> ski: Already found it
07:14:40 <merijn> ski: Sec
07:15:07 <merijn> ski: THEORETICAL PEARLS Flattening combinators: surviving without parentheses
07:15:10 <merijn> ski: By Okasaki
07:15:28 <satc> How should I go about rotating a ByteString. eg. (representing bytestring as list of word8 here) [0x01,0x02,0x03,0x04] `rotateR` 2 = [0x03,0x04,0x01,0x02] ?
07:15:34 <ski> perhaps it was that one, not sure
07:15:49 <merijn> ski: It cheats by introducing a third "apply" combinator for your stack based machine and then replace S and K with X to get back to two combinators (i.e. X and apply)
07:16:03 <merijn> Where S=X(XX) and K=XX
07:16:04 <quicksilver> satc: (drop n bs) `append` (take n bs)
07:16:24 <hpc> satc: cheating a bit and using list, rotate s n = (let l, r) = splitAt n s in r ++ l
07:16:31 <hpc> or drop/take
07:16:33 <merijn> hpc: The problem with that is that I'd need to start binaries from within Test.hs which seems like it'd get really messy quite soon :\
07:16:40 <satc> quicksilver: I want it to be fast.
07:16:43 <hpc> oh, eek
07:16:46 <quicksilver> satc: that is fast.
07:16:54 <quicksilver> satc: bytestring take/drop is zero-copy
07:16:55 <merijn> hpc: I guess I'll have to write my own wrappers using some form of subprocess thing from System
07:17:00 <hpc> yeah
07:17:01 <satc> quicksilver: I mean is that the fastest possible?
07:17:08 <satc> quicksilver: Oh. thanks
07:17:14 <quicksilver> satc: the append might or might not be zero-copy dependning which bytestring you use
07:17:20 <hpc> merijn: also, i found out the hard way that spawning processes the way you want doesn't work on windows
07:17:26 <quicksilver> I have no idea what is the fastest possible, feel free to test :)
07:17:26 <hpc> due to a very long-standing bug
07:17:39 <merijn> hpc: Ugh
07:17:40 <satc> quicksilver: What do you mean by which ByteString?
07:17:52 <quicksilver> satc: lazy or strict
07:17:53 <erisco> :t combine
07:17:54 <lambdabot> Not in scope: `combine'
07:18:02 <merijn> hpc: Although having non-functional tests on Windows won't be a big problem I guess
07:18:09 <satc> quicksilver: So it is zero copy in strict ?
07:18:46 <hpc> (at least, the way i was doing it was process-extras' bytestring variants)
07:19:01 <erisco> :t foldr
07:19:02 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:19:22 <quicksilver> satc: no, append is zero copy in lazy
07:19:36 <quicksilver> satc: in strict it copies everything (what else could it do?) but at least it's only the one copy.
07:20:14 <satc> quicksilver: Also I have to represent a state (for some algorithm) as some fixed number Word8? Should I use a fixed length ByteString or define a datatype to represent that? The operations I have to do is like `xor` , rotating etc.
07:20:36 <hpc> satc: probably ByteString
07:21:28 <satc> hpc: If that helps the algorithm is AES.
07:22:19 <satc> hpc: Right now I have it like 16 unpacked Word8
07:22:19 <ski> merijn : yes, istr it was something like that
07:22:34 <bartavelle> Vector has unpacked stuff
07:22:49 <hpc> satc: have you tried the existing AES implementations?
07:22:59 <Ghoul_> theres wrappers to C aes stuff, which is like 2000x faster than the fastest haskell ones
07:23:07 <Ghoul_> basically 1 or 2 machine instructions
07:23:07 <satc> hpc: Lets say I am trying implementing my own.
07:23:15 <hpc> ah, cool
07:23:24 <hpc> yeah, you probably want ByteString
07:24:22 <satc> Ghoul_: Yeah, I know. Performace is not a matter for now as I am focussing on correctness for now.
07:26:45 <thirsteh> Pardon the stupid question, but: If I do BC.putStrLn (where BC is Data.ByteString.Char8) followed by B.somethingElse, will that first action have removed non-ASCII characters from the ByteString, or does it only print the ASCII characters (and B.somethingElse will work as expected)? Also, is this the same behavior for the Lazy equivalents (i.e. when forcing a lazy bytestring with ByteString.Lazy.Char8)?
07:28:03 <Ghoul_> ByteString is only Char8 afaik
07:28:14 <Ghoul_> You need to use Data.Text for things that dont fit in a Char8
07:28:18 <merijn> Ghoul_: Char8 is not a thing
07:28:23 <merijn> Ghoul_: ByteString is just bytes
07:28:31 <thirsteh> bytestring is any sequence of bytes. I'm wondering if forcing one with a Char8 function removes non-ASCII bytes
07:28:39 <Ghoul_> Eh, my bad, I was just reading what he wrote
07:29:01 <elliott> thirsteh: values don't change. question answered :)
07:29:04 <merijn> thirsteh: The correct answer is: Don't use Data.ByteString.Char8
07:29:33 <geekosaur> it doesn;t remove them, IIRC, it truncates them
07:29:38 <merijn> It exists for only one reason: Simple interaction with C/network protocols abusing it's IsString instance for OverloadedStrings
07:29:39 <geekosaur> which is pretty much never what you want
07:29:45 <cschneid> merijn: the use of bytestring.char8 is when the algorithm is really a byte/bit based algo, and you're not thinking of the contents as strings?
07:29:56 <thirsteh> geekosaur: exactly. so B.somethingElse will effectively break after I've done BC.putStrLn for debugging purposes
07:30:09 <merijn> cschneid: No, the *only* value of BS.Char8 is the IsString instance
07:30:17 <thirsteh> elliott: I want to believe you, but is that really true for bytestrings?
07:30:21 <merijn> cschneid: It's *just* a ByteString
07:30:32 <thirsteh> merijn: I just wanna spit out the string without encoding to Text first, or unpacking to string
07:30:34 <cschneid> ahh, I get what you're saying, not the char8 version, just the normal ByteString
07:30:43 <merijn> cschneid: So the *only* usecase is specifying ByteString values as string literals
07:30:43 <elliott> thirsteh: it is true for every single value unless you use unsafe operations (and even then it's difficult to make a value actually change).
07:30:57 <thirsteh> elliott: I'm implying that bytestring uses unsafePerformIO/other unsafe array operations
07:30:59 <merijn> thirsteh: So just use the show instance?
07:31:01 <elliott> in other words, if you see a value changing in a Haskell program, either you're being naughty, or there is a bug somewhere.
07:31:14 <elliott> thirsteh: yes, but that does not mean the API it exports is unsafe
07:31:28 <elliott> it would be disowned if it did what you asked :)
07:31:38 <thirsteh> elliott: And I'm asking if that is really true when you have a BS with non-ASCII, and do BC.putStrLn followed by B.somethingElse that expects more than just ASCII
07:31:48 <thirsteh> if you are 100% sure it is, I'll be satisfied with that
07:31:53 <thirsteh> merijn: good point, hadn't thought of that
07:32:00 <thirsteh> but I assume that's just B.unpack?
07:32:02 <elliott> you could test, if you want to be absolutely sure :p
07:32:16 <merijn> thirsteh: Yes, although writing a pretty print for ByteString is trivial
07:36:27 <zeroXten> why is the Bool type a member of Enum?
07:37:01 <zeroXten> [True .. False] returns [] and succ True fails
07:37:03 <t7> because one can enumerate all of its values
07:37:11 <Cale> > [False..]
07:37:12 <lambdabot>   <hint>:1:9: parse error on input `]'
07:37:16 <Cale> > [False .. ]
07:37:17 <lambdabot>   [False,True]
07:37:22 <Cale> > [False, True]
07:37:23 <lambdabot>   [False,True]
07:37:28 <Cale> > fromEnum False
07:37:29 <lambdabot>   0
07:37:30 <Zenol> How should I do to re-export the ! operator from Data.Vector in my Stuff module ? (In first case, supposing I'm exporting everything defined in the module, and second case when I export only a part of the stuff defined.)
07:37:31 <Cale> > fromEnum True
07:37:32 <lambdabot>   1
07:37:48 <zeroXten> Cale: ah ok, makes sense I guess
07:37:55 <haasn> > (0::Word8) ^.. bits.from enum
07:37:56 <lambdabot>   [0,0,0,0,0,0,0,0]
07:37:57 <Cale> zeroXten: It's just the derived instance
07:38:03 <haasn> > (73::Word8) ^.. bits.from enum
07:38:04 <lambdabot>   [1,0,0,1,0,0,1,0]
07:38:12 <haasn> how cute
07:38:33 <cschneid> what, that word8 trickery is cool. Now if I only I understood lenses :)
07:38:43 <Cale> zeroXten: It's not particularly essential, but it's more or less 5 characters of additional code to have it in the Prelude and fromEnum at least can be useful at times.
07:38:55 <zeroXten> yeah
07:39:05 <zeroXten> and whats with needing spaces around ".."?
07:39:05 <levi> thirsteh: The truncation that occurs in ByteString.Char8 is only during *construction* if you make one from a string literal that contains non-ASCII characters.
07:39:32 <Cale> zeroXten: It's because . is also a module path separator, and False starts with an uppercase letter, so it looks like it could be a module name
07:39:42 <zeroXten> right
07:39:43 <Cale> > [False ..]
07:39:44 <lambdabot>   [False,True]
07:39:44 <zeroXten> thanks
07:40:25 <donri> > enumFrom minBound :: [Bool]
07:40:27 <lambdabot>   [False,True]
07:42:43 <quchen> > [()..] -- ♥
07:42:44 <lambdabot>   [()]
07:43:32 <saml> > succ ()
07:43:34 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
07:43:47 <saml> > [bottom]
07:43:49 <lambdabot>   Not in scope: `bottom'
07:47:29 <quchen> saml: succ maxBound undefined. And if you want to have bottom, use "let x = x in x" for example. Or "undefined".
07:48:04 <saml> > [undefined .. ] -- ♥
07:48:05 <lambdabot>   *Exception: Prelude.undefined
07:49:16 <RichyB> > map fromEnum "♥"
07:49:17 <lambdabot>   [9829]
07:50:57 <cschneid> @src bits
07:50:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:51:17 <cschneid> where does the `bits` function come from in this:  (73::Word8) ^.. bits.from enum
07:52:21 <levi> Data.Bits, maybe?
07:52:33 <cschneid> levi: yeah, I looked and it's not in that. hoogle didn't point me anywhere useful
07:52:44 <klugez> cschneid: Data.Bits.Lens
07:53:13 <levi> Ahh, yeah.
07:53:25 <cschneid> klugez: ahh cool
07:53:38 <cschneid> that's a fairly standard naming scheme, where lens helpers live under the data in a submodule .Lens?
07:54:09 <Iceland_jack> cschneid: Yes
07:55:33 <erisco> is there a profiling program that will evaluate my function with increasing input lengths and make a graph?
07:55:39 <thirsteh> levi: Okay, I think I understand that. So as long as I just have a B.ByteString, BC does nothing, but if it's ambiguous/type-inferred to BC.ByteString, or explicitly a BC.ByteString, I'll be in trouble
07:56:21 <thirsteh> in my case I'm using websockets which will return all kinds of bytestrings/texts, but from your description it sounds like I will be fine if I do s <- getTextData :: IO B.ByteString, then BC.putStrLn s and B.somethingElse s
07:56:31 <cschneid> erisco: if there isn't, that sounds cool. Lean on quickcheck's generating ability perhaps?
07:57:18 <Iceland_jack> erisco: You can check out Criterion and use the output of that to create data points?
08:00:08 <fylwind> @pl f x = g (q x) (h x)
08:00:08 <lambdabot> f = liftM2 g q h
08:02:09 <levi> thirsteh: If a ByteString is given to you from a network socket, it won't be constructed from a String literal in your program, and thus will not be truncated. ByteString.Char8 does not define its own type, it just defines a 'fromString' that truncates characters to Char8.
08:03:51 <erisco> well that all sounds too complicated so I just did it manually
08:03:54 <levi> thirsteh: When you write a string literal in your program and you're using -XOverloadedStrings, what actually gets put in your program is 'fromString "string literal"' and thus your string literals can be converted to other string-like types, much in the same way that numeric literals can get converted to various numeric types.
08:03:56 <quicksilver> levi: (and a different 'pack' and 'unpack' and possibly a couple of others)
08:03:58 <erisco> and counted the number of times the cursor counted on the terminal :)
08:04:03 <erisco> cursor flashed
08:04:30 <erisco> expecting O(n^2logn) and can at least see the O(n^2) part. logn is a bit invisible :P
08:04:45 <erisco> stupid sorts have to be nlogn
08:05:06 * hackagebot containers 0.5.3.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.3.0 (JohanTibell)
08:05:41 <Zenol> thanks to lens I can merge 20 LD opcode to only two functions ... \ o / Magic :)
08:06:22 <erisco> don't want to start counting longer than a minute though :(
08:06:26 <erisco> need more data pionts
08:07:04 <edwardk> Zenol: =)
08:07:44 <quicksilver> erisco: experimentally observing the logn part is very hard on real systems
08:07:59 <erisco> yeah
08:08:41 <erisco> with only a few data points a cubic curve fits better, but I'm fairly sure it is quadratic... guess I'll be spending the rest of the day trying to figure out how criterion works
08:09:37 <cschneid> erisco: please write a blog post when done?  I'd be rather interested
08:09:54 <erisco> I don't have a blog... and what is so exciting about bench marking?
08:10:03 <erisco> in fact I am rather scared if bench marking in haskell is this foreign
08:10:38 <erisco> imma just trying to make parsing faster
08:11:05 <thirsteh> levi: thanks, makes sense. websockets uses isstring, so I just have to add a B.ByteString type annotation
08:11:32 <mkramer> I'm trying to get an infinite stream of random Word32's. I just read System.Random, and it seem to be telling me that I need to roll my own instance of RandomGen…is that right?
08:11:35 <cschneid> erisco: the fact that it hasn't been talked about apparently. And generally I'm trying to learn haskell + the environment around it. This is one of those things you've gotta know eventually
08:11:50 <erisco> blogging takes too much time :(
08:13:44 <cschneid> erisco: yeah. I have a blog that I'm going to start documenting my learning of Snap on. It sure does take time to get going and do.
08:15:03 <merijn> blah
08:15:24 <merijn> Debug.Trace needs "traceM :: Monad m => String -> m ()"
08:17:17 <d3lxa> question: if I have a type MyT = A|B derving (Show,Read,Enum) then define an instance (Show a, Enum a) => ToJSON, why won't it be used for MyT, do I have to write deriving (ToJSON) or what?
08:18:17 <thirsteh> levi: I guess websockets never actually has a String representation like you said, but not sure what kind of magic goes on there if you expect a Char8 BS. Anyway, I get it now
08:20:42 <merijn> thirsteh: There is no such thing as a "Char8 BS"
08:20:48 <merijn> There is only "ByteString"
08:20:55 <merijn> (Well, lazy/strict versions, but anyway)
08:21:12 <ParahSailin> d3lxa: you might be able to do it by deriving (Generic)
08:21:22 <merijn> Data.ByteString.Char8 is just a module exporting evil functions that you should not touch
08:22:49 <merijn> Additionally it exports the vile IsString for ByteString that makes OverloadedStrings "work", the only valid usecase for that instance is working with C functions/network protocols where string literals are nice but that do not have an encoding (i.e. HTTP, FTP, SMTP, etc.)
08:23:38 <thirsteh> merijn: okay, I guess there's no chance truncation happens in my case then
08:23:41 <merijn> There is no such thing as a Char8 datatype and there is not other implementation of ByteString
08:23:51 <d3lxa> ParahSailin: is that the only way? shouldn't haskell use my instance without special things?
08:24:08 <thirsteh> if the truncation only ever happens in fromString (String -> ByteString)
08:24:23 <thirsteh> unless websockets does something very silly, which I doubt
08:27:08 <geekosaur> "websockets does something very silly" all the time... oh wait you meant the haskell interface :p
08:27:38 <merijn> geekosaur: Isn't the entire notion of websockets silly?
08:28:29 <geekosaur> not entirely. it's an inexplicable answer to a real question
08:29:19 <merijn> geekosaur: I posit that the question is silly in the first place
08:30:40 <exicer> How can I use cabal to view all of my installed packages ?
08:31:12 <bergmark> exicer: ghc-pkg list
08:31:16 <geekosaur> exicer, typicaly you don't. ghc-pkg list
08:31:29 <dcoutts_> exicer: it's not very good at that at the moment, have to use the lower level tool
08:31:34 <merijn> "ghc-pkg list" only shows installed libraries
08:31:35 <geekosaur> cabal isn't so much a package anager as an installation helper
08:31:53 <dcoutts_> exicer: that said, there is cabal list --installed
08:32:27 <dcoutts_> geekosaur: we were working on uninstall support at the hackathon :-)
08:33:07 <ParahSailin> d3lxa: just tried this: data Derp = Dorp | Hodor | Foo deriving (Typeable, Data); import Data.Aeson.Generic; toJSON Dorp gives you String "Dorp"
08:34:39 <exicer> So if I have a broken package using ghc-pkg check, what can I do ?
08:35:21 <ParahSailin> delete .ghc, re-do everything
08:35:43 <mroman> exicer: unregister it?
08:35:44 <bergmark> you can ghc-pkg unregister too
08:36:02 <mroman> I've just had to do that today to get Network.CGI to install
08:36:26 <mroman> something about parsec shadowing parsec
08:36:53 <exicer> Okay, cool. Seems like unregister works.. what does it actually do though ?
08:37:02 <exicer> Just remove it from the ghc's list  ?
08:37:12 <geekosaur> yes
08:37:18 <spaceships> what is (<$) used for?
08:37:26 <exicer> So if it was a thing installed by cabal, how can I remove the actual file /
08:37:28 <mroman> @type (<$)
08:37:29 <lambdabot> Functor f => a -> f b -> f a
08:38:12 <int-e> spaceships: in a parser you might do something like  Keyword <$ string "keyword"
08:38:17 <spaceships> steal somethings container?
08:38:29 <mroman> It's usually fmap . const
08:39:03 <ParahSailin> @src (<$)
08:39:03 <lambdabot> (<$) = (<$>) . const
08:39:46 <d3lxa> ParahSailin: thx, I'm looking if it works as I expect
08:39:50 <mroman> spaceships: i.e (<$) 3 (Just 5) overwrites the 5 with 3
08:40:12 * hackagebot module-management 0.17 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.17 (DavidFox)
08:40:12 <donri> `a <$ m` is a bit like `m >> return a`
08:40:25 <int-e> but the question was "what's it for", not "what does it do".
08:40:34 <spaceships> donri: oh, interesting
08:42:05 <geekosaur> think of it this way: in a parser, you may want to parse '(', expression, ')', return the expression. <$ lets you combine the expression parser with parsing the closing paren, while returning the result of the expression parser and without having to capture the expression parser's result separately
08:42:32 <ion> geekosaur: Are you thinking of (<*)?
08:42:36 <mkramer> Is there typeclass for "data that has a well-defined byte-length"? I.e., "things that sizeof() work work on in C?"
08:42:38 <geekosaur> maybe
08:42:53 <geekosaur> I think I have the concept, maybe not the literal application thereof
08:43:09 <erisco> geekosaur, I use <* and *> for this... not sure how the fmap helps =\
08:43:16 <spaceships> ah, very cool. thanks all for assistance
08:43:40 <geekosaur> mkramer, native haskell representations don't have that concept. Foreign.Storable does
08:44:28 <spaceships> there is an instance for Monad ((->) r) in Data.Functor: how do you use it?
08:44:35 <quicksilver> geekosaur: arguably bounded integral types have a natural notion of bit length, but we don't make it particularly accessible
08:44:49 <quicksilver> geekosaur: no doubt the bit field magic in lens can open it up
08:44:58 <mkramer> There's no way to ask Word how many bytes long it is?
08:45:02 <mkramer> @ geekosaur
08:45:14 <mkramer> Oh, yeah
08:45:15 <mkramer> Storable
08:45:18 <mkramer> that's the class I wanted! thanks
08:45:28 <quicksilver> mkramer: bitSize
08:45:42 <quicksilver> > bitSize (42 :: Word)
08:45:43 <lambdabot>   32
08:45:49 <quicksilver> > bitSize (42 :: Word8)
08:45:50 <lambdabot>   8
08:45:57 <quicksilver> > bitSize (42 :: Word64)
08:45:58 <lambdabot>   64
08:46:35 <geekosaur> which is from Data.Bits
08:46:58 <quicksilver> of course this is a *representational* promise
08:47:05 <quicksilver> (Word8s might still be stored in 64 bits of memory)
08:47:16 <donri> a <$ m = pure a <* m
08:47:19 <quicksilver> it's just about the values the type is allowed to hold
08:47:29 <geekosaur> I kinda don't think of those as truly native, so much as intended for interfacing with other stuff
08:47:43 <quicksilver> they're just a bunch of constants in the end
08:47:44 <fizbin> There's no way to get djinn to play nicely with things that are a functor, is there?
08:48:04 <quicksilver> although you could in fact do something by taking the base-2 logarithm of maxBound - minBound
08:48:05 <geekosaur> of course ultimately that leads to the rant over whether Int should exist :)
08:48:14 <merijn> ugh
08:48:33 <merijn> Not only does pipes-4 use a datatype called Void, it's actually exported from the main module >.<
08:48:44 <stelleg> I'm having an issue with two event threads interfering with eachother, despite trying both forkIO and forkOS with the -threaded ghc flag, anyone have any suggestions before I start digging in with threadscope?
08:48:51 <mkramer> thanks
08:49:00 <merijn> stelleg: Define "interfering with eachother"
08:49:18 <merijn> That's kinda the point of threads...
08:49:45 <haasn> edwardk: do we have an iso for Show/Read?
08:50:05 <stelleg> merijn: one is a v4l2 event listener and one is jack audio, and they work fine independently but when the v4l2 is running it kills the jack audio
08:50:05 <elliott> merijn: it's because void isn't in the platform apparently
08:50:10 <d3lxa> ParahSailin: I don't know but it seems it doesn't play well with Yesod TH, but I'm wondering why can't I write my general instance like this http://sprunge.us/KdIX ?
08:50:11 <elliott> despite the fact that pipes isn't either :p
08:50:18 <elliott> it was called X before but apparently clashing with void is better...
08:50:21 <merijn> elliott: I know, but then they should name it differently
08:50:36 <edwardk> haasn: there is a _Show prism in head
08:50:36 <stelleg> merijn: cant really say more until i start digging deeper
08:51:05 <merijn> stelleg: What does "kills the jack audio" mean?
08:51:30 <merijn> elliott: W00t!
08:51:31 <stelleg> merijn: jack zombifies it because it isn't responding
08:51:35 <merijn> elliott: Whining works!
08:51:46 <merijn> elliott: Just got this reply from Tekmo: "Alright, I will change it to use `Data.Void`.  Can you submit a pull request for this?"
08:53:17 <erisco> ffs
08:53:28 <erisco> on windows anything I compile immediately locks (the output binary)
08:53:34 <erisco> on ghc this means the linker always fails -.-
08:53:54 <erisco> no idea why
08:54:19 <edwardk> merijn: what wasn't using Void?
08:54:37 <merijn> edwardk: pipes-4
08:54:40 <mroman> weird folder security settings?
08:54:41 <edwardk> ah
08:54:48 <edwardk> had his own?
08:54:51 <merijn> edwardk: I think you warned about that
08:54:58 <merijn> oh, wait
08:55:08 <merijn> No, you warned about the potential problem of Proxy
08:55:13 <edwardk> yeah
08:55:29 <edwardk> personally i think the Proxy issue is going to bite him hard, but hey
08:55:32 <merijn> edwardk: Yeah, it used to have "data X" but changed to "data Void", which of course breaks all my stuff using Data.Void >.>
08:55:36 <edwardk> who uses Data.Typeable ;)
08:55:55 <merijn> edwardk: What's a sensible bound to pick for the void package?
08:56:04 <merijn> Just ">=0.6"?
08:56:07 <edwardk> they almost all work
08:56:13 <edwardk> the corner cases just got refined
08:56:25 <edwardk> yeah
08:56:40 <edwardk> it amazes me how many cases have been worth ironing out with void
08:57:07 <edwardk> i've been meaning to write up an article showcasing the ins and outs of maintaning the simplest possible package
08:57:10 <elliott> I opened up issues for both Proxy and Void but he closed both of them :p
08:57:11 <edwardk> holding up void as an example
08:57:18 <donri> merijn: what, does it also have a Data.Void module?
08:57:20 <edwardk> of a package that has one data type with no inhabitants
08:57:27 <ocharles> edwardk: what's the Proxy issue?
08:57:31 <elliott> edwardk: I like how the Show instance was terrible for ages
08:58:06 <edwardk> ocharles: just that Data.Proxy starts being exported (needlessly) by Data.Typeable, so anyone who imports Data.Typeable and his stuff will have a conflict. likely leading some users to leave off Typeable or have to deal with lots of qualified noise.
08:58:10 <merijn> donri: No, it defines "data Void" in Pipes.Core
08:58:17 <donri> merijn: so?
08:58:24 <edwardk> elliott: Void (Void (Void...
08:58:28 <merijn> donri: That collides if you use Data.Void anywhere
08:58:34 <donri> merijn: how?
08:58:42 <ocharles> edwardk: ah, ok
08:58:49 <merijn> donri: "Ambiguous occurrence `Void'"?
08:58:52 <edwardk> merijn: same name, same purpose, needless difference
08:58:52 <ocharles> edwardk: most users won't import Proxy
08:59:02 <ocharles> edwardk: that's now in Pipes.Core, which is more... specialist
08:59:03 <edwardk> ocharles: importing Data.Typeable brings it in
08:59:09 <edwardk> oh that one
08:59:10 <donri> merijn: oh, you want open and non-qualified imports :p
08:59:15 <tomejaguar> Surely there should still be an X type alias.  X was nice
08:59:17 <haasn> mapMOf_ _Left looks a bit disgusting
08:59:23 <haasn> I think void . _Left might be preferred :P
08:59:29 <edwardk> haasn: heh
08:59:40 <donri> hey let's make sure we can import all of hackage unqualified in a single module with no clashes
08:59:42 <edwardk> :t void _Left
08:59:43 <lambdabot> (Applicative f, Choice p) => p a (f b) -> ()
08:59:52 <haasn> :t void . _Left print
08:59:53 <lambdabot> Show a => Either a c -> IO ()
08:59:55 <haasn> that's what I meant
08:59:56 <edwardk> :t void . _Left
08:59:56 <lambdabot> (Functor (p (Either a c)), Applicative f, Choice p) => p a (f b) -> p (Either a c) ()
09:00:04 <merijn> ocharles: Proxy is exported from Pipes now, afaict
09:00:10 <haasn> :t void .: _Left
09:00:10 <lambdabot>     Not in scope: `.:'
09:00:11 <lambdabot>     Perhaps you meant one of these:
09:00:11 <lambdabot>       `.' (imported from Data.Function),
09:00:12 <haasn> :(
09:00:18 <merijn> ocharles: Not just Pipes.Core
09:00:18 <haasn> how long until we get .: into Control.Lens
09:00:24 <edwardk> haasn: after i die
09:00:28 <ocharles> merijn: oh, hmm
09:00:32 <haasn> edwardk: sounds like a plan!
09:00:33 <ocharles> merijn: that seem unnecessary
09:00:36 <edwardk> ack!
09:00:45 <haasn> where is _Show?
09:00:56 <ocharles> haasn: don't steal .: :(
09:01:00 <ocharles> lens already stole .>
09:01:05 * ocharles shakes a fist
09:01:10 <edwardk> haasn: Control.Lens.Proxy
09:01:20 <ciaranm> .: is fmap fmap fmap !
09:01:29 <haasn> I don't have that module
09:01:29 <erisco> whoo running criterion already :D
09:01:31 <haasn> I'm on HEAD
09:01:33 <haasn> what's wrong?
09:01:35 <edwardk> er
09:01:36 <edwardk> Prism
09:01:40 <erisco> will take an hour or so for the bench to complete I imagine
09:01:41 <edwardk> =)
09:01:41 <haasn> oh
09:01:47 <edwardk> sorry all this proxy talk primed me
09:01:55 <haasn> I still don't have _Show
09:02:21 <Eduard_Munteanu> It's unclear to me what "you can only call TH splices from another module" really means. Can module A call some helpers in module B, then feed the results to a TH function in B?
09:02:26 <shachaf> .: is usually a bad idea.
09:03:05 <ciaranm> what if someone put a Functor inside your Functor so you can Functor while you Functor?
09:03:14 <tomejaguar> What's .: in this case?
09:03:21 <shachaf> (.) . (.)
09:03:30 <ciaranm> fmap fmap fmap
09:03:41 <shachaf> concatMap = concat .: map, and so on
09:03:44 <tomejaguar> Why's it a bad idea?
09:03:49 <tomejaguar> I use it every day.
09:03:51 <Eduard_Munteanu> imagefmap :P
09:03:51 <int-e> @type (<<<)
09:03:52 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
09:03:53 <scshunt> Eduard_Munteanu: yes
09:03:57 <haasn> edwardk: I'm guessing we also don't have anything for words/unwords yet either do we?
09:04:04 <merijn> My new MO is to not have my code work around libraries, but just beat maintainers into modifying their libraries to suit me :)
09:04:06 <scshunt> Eduard_Munteanu: it refers to the actual module in which the splice occurs
09:04:20 <edwardk> haasn; best it can be is a fold unless you want unsafety
09:04:28 <Eduard_Munteanu> Ah.
09:04:30 <edwardk> there is one for that in Data.List.Split.Lens i think
09:04:33 <Eduard_Munteanu> Thanks.
09:04:39 <haasn> edwardk: I'm writing a (somewhat silly) function along the lines of:
09:04:41 <haasn> > "foo bar bat 0" & iso words unwords._last.prism' show readMaybe +~ 1
09:04:42 <lambdabot>   Not in scope: `readMaybe'
09:04:48 <haasn> yuck, but it returns "foo bar bat 1"
09:05:04 <haasn> @let readMaybe s = case reads s of [(a,"")] -> Just a; _ -> Nothing
09:05:05 <lambdabot>  Defined.
09:05:06 <haasn> > "foo bar bat 0" & iso words unwords._last.prism' show readMaybe +~ 1
09:05:12 <ocharles> haasn: doesn't 'words' throw away multiiple spaces?
09:05:13 <lambdabot>   "foo bar bat 1"
09:05:18 <haasn> ocharles: it does, it's not a true iso
09:05:20 <ocharles> > words "hello    world"
09:05:21 <lambdabot>   ["hello","world"]
09:05:23 <ocharles> ok
09:06:03 <haasn> ocharles: that aside, it's also not a true traversal either because you can eg. do (.~ "foo bar")
09:06:16 <haasn> even if you keep track of the number of spaces
09:06:27 <zeroXten> are there any efficieny gains in using _ rather than some random name?
09:06:38 <edwardk> no
09:06:40 <donri> tomejaguar: http://hackage.haskell.org/packages/archive/composition/1.0.1.0/doc/html/Data-Composition.html ;)
09:06:41 <zeroXten> k
09:06:43 <quicksilver> haasn: isn't there some kind of punishment for people who use 'iso' on things which aren't actual isos?
09:06:50 <zeroXten> didn't think so
09:06:50 <int-e> compilation might be a teeny bit faster ;)
09:06:52 <quicksilver> zeroXten: you avoid a warning about an unusual variable name, perhaps?
09:06:53 <edwardk> just no warning under Wall
09:06:57 <quicksilver> unused.
09:07:25 <donri> edwardk himself uses iso for things that aren't ;)
09:07:30 <edwardk> quicksilver: the lens police come for you. its 30 days community service writing lens documentation
09:07:44 * ocharles deletes his illegal Prisms
09:07:46 * ocharles whistles
09:07:51 <quicksilver> I call cruel and unusual punishment
09:07:53 <satc> Is there a zipWith for ByteString which returns a ByteString. I dont want to first generate [Word8] and then pack that to get a ByteString?
09:07:55 <zeroXten> i guess if it sees a variable is unused, it wouldn't allocate memory anyway or something
09:08:07 <ocharles> on that note, have you given adjunctions in lensanymore thought, edwardk?
09:08:12 <ocharles> i think it was adjunctions anyway...
09:08:25 <edwardk> ocharles: i've forgotten the context
09:08:28 <ocharles> Such as going from String -> MyData via parsec, and back with a formatter
09:08:28 <quicksilver> zeroXten: right, unusued variables generate no code even if they appear to be used
09:08:34 <edwardk> oh
09:08:36 <edwardk> improper lenses
09:08:40 <satc> @hoogle (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
09:08:40 <edwardk> on sided inverses
09:08:40 <lambdabot> No results found
09:08:41 <edwardk> yes
09:08:43 <erisco> never mind I don't know what criterion is doing at all :(
09:08:47 <ocharles> it's not quite a legal Prism unless the parsed string has already been pretty printed
09:08:53 <tomejaguar> donri: I know it.  I don't know why shachaf thinks it is usually a bad idea.
09:08:55 <edwardk> but we haven't added type aliases or documentation about them
09:09:08 <quicksilver> > let a = "no code generated"; b = a ++ " for me neither" in 0
09:09:09 <lambdabot>   0
09:09:15 <edwardk> i sent an email to snoyman that i may reformulate and put on the wiki about improper lens-likes
09:09:31 <ocharles> edwardk: oh, so lens has some support for this already?
09:09:40 <edwardk> ocharles: yes, operationally nothing goes wrong
09:09:47 <edwardk> you can use all the lens combinators with your improper lenses
09:09:57 <ocharles> oh right, so i just shouldn't care about the fact I break the laws
09:10:02 <edwardk> there are just two 'sub-families' of them, that if you mix you lose access to the second law completely
09:10:15 <edwardk> well, you should care, because it makes reasoning about fusion harder
09:10:22 <edwardk> but not for operational reasons
09:10:33 <ocharles> i see
09:11:45 <haasn> just wrote a trivial self-modifying algorithm using hint and lenses, excellent
09:11:45 <edwardk> we do everything in all our combinators in lens 'fully fused', so you may get some unexpected results if you expected some intermediate states that just don't happen
09:11:53 <edwardk> hah
09:12:07 <haasn> to expand on this idea though it would be great if we had lenses for Haskell source trees, eg. as parsed by haskell-src-exts
09:12:11 <edwardk> reminds me of screen clearing on a c64 back in the day ;)
09:12:13 <haasn> then we could *really* start using lenses to modify haskell code
09:12:35 <edwardk> haasn: i nominate you to write haskell-src-exts-lens
09:12:41 <donri> i recently used lenses to generate quickcheck tests for polymorphic properties using TH
09:12:45 <tomejaguar> edwardk: what do you mean by 'fully fused' here?
09:12:46 <haasn> so much effort :(
09:13:10 <scshunt> we need a lens-lift that lifts a lens to act on ASTs
09:13:17 <edwardk> tomejaguar: meaning we don't tend to call view, then use (.~) or something when we can merge that together into a (%~) in one pass
09:13:24 <scshunt> for TH
09:13:26 <lpaste> haasn pasted “self-modifying algorithm” at http://lpaste.net/92517
09:13:28 <ocharles> anyone know if Antoine Latter (aslatter) is on irc under another alias?
09:14:42 <haasn> ideally line 8 of this should read something like _LetBody._3._2._Literal +~ 1 -- or whatever for _2, _1, the idea here is that they represent the parameters of the application
09:14:51 <edwardk> haasn now turn that into a quine!
09:15:13 <haasn> a trivial transformation afaik
09:15:18 <edwardk> sure
09:15:25 <edwardk> but sexier
09:15:40 <erisco> blog says there is -k http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
09:15:42 <erisco> there is no -k
09:16:17 <haasn> edwardk: now I need to hack lensy fizzbuzz into it and post it as the wildest haskell fizzbuzz on the net :)
09:16:37 * quicksilver still finds _3, _2 etc ugly. Maybe absinthe would make my heart grow fonder.
09:17:19 <mkramer> Why is my C++ version of this function cleaner and easier to understand than my Haskell version? http://lpaste.net/92518
09:17:39 <haasn> I don't understand the C++ version of your function, so that's already subjective
09:18:27 <haasn> I don't even understand the Haskell version. :(
09:19:24 <erisco> mkramer, if your question is how to "select a type" in Haskell, then you can explicitly specify the type of an expression with '::'
09:19:29 <erisco> > maxBound :: Int
09:19:30 <lambdabot>   2147483647
09:19:32 <erisco> is an example
09:19:47 <bartavelle> what does "I can't live in the Get and Put monads of Data.Binary, because the file comes from a foreign system." mean ?
09:19:48 <Zenol> mkramer: I think you are looking after classes.
09:20:09 <erisco> if you need to get the variable from your function signature into your function definition, look at the scoped type variables extension
09:20:47 <erisco> there is no need to use a type inhabitant to do this
09:21:05 <mkramer> scoped type variables
09:21:06 <quicksilver> erisco: but he happens to have one and it's reasonably clear to use it.
09:21:09 <mkramer> It sounds promising
09:21:28 <erisco> maybe not to mkramer :)
09:21:34 <quicksilver> looks to me like that the main reason the C++ 'seems' simpler is because you're assuming the C++ ABI
09:21:44 <mkramer> Well, I don't want to say "0 :: Word32" when I really mean "Word32"
09:21:56 <quicksilver> in other words, because you are hardcoding the fact that the binary layout in the file is the same as the in-memory layout of a variable
09:22:13 <quicksilver> which is because you chose your file format to match the way your C++ compiler puts stuff in memory
09:22:24 <quicksilver> and that's why the reinterpet_cast<char*> works
09:22:43 <quicksilver> haskell forces you to be explicit about which order the bytes are laid out in the file
09:22:46 <mkramer> all true
09:22:50 <quicksilver> which makes you endian-independent.
09:22:56 <mkramer> also true
09:23:00 <bartavelle> and compiler / flags dependant
09:23:03 <bartavelle> (for padding)
09:23:17 <quicksilver> that little detail aside I think the two bits of code are pretty similar in complexity
09:23:22 <quicksilver> subjective, as someone said
09:24:01 <mkramer> So, passing a type inhabitant would be a normal way to do this?
09:24:01 <lpaste> merijn pasted “Tail recursion?” at http://lpaste.net/92519
09:24:07 <boothead> hi folks, can someone remind me how to express that then I (SomeClass a) => I mean it throughout the function for all as?
09:24:29 <boothead> scoped type variables?
09:24:31 <mkramer> bartavelle: it's not compiler/flags dependent
09:24:32 <merijn> Right, I'm assuming the example just pasted is rather inefficient, due to the lack of tail recursion, but is that actually right?
09:24:47 <merijn> And if so, is there a way to make it tail recursive in a way that doesn't suck?
09:25:13 <erisco> boothead, maybe?
09:25:26 <merijn> Or maybe not so much inefficient as it might cause stackoverflows
09:25:50 <Eduard_Munteanu> boothead: you'll just have to ensure you mean the same 'a', either with ScopedTypeVariables or asTypeOf.
09:25:55 <merijn> boothead: SCTV is the only way to refer to type variables in your main type signature, so probably that
09:26:02 <bartavelle> mkramer, structure packing, and even order of fields, is totally compiler/flags independant
09:26:07 <boothead> thanks guys
09:26:20 <bartavelle> mkramer, if you are using simpler stuff you are probably ok
09:26:27 <bartavelle> err
09:26:30 <bartavelle> dependant
09:27:01 <mkramer> really? A uint_32_t is allowed to have different memory representations in different compilers?
09:27:14 <bartavelle> a struct
09:27:16 <mkramer> I am/was pretty sure that it's well defined
09:27:26 <Zenol> mkramer: indieness is architecture dependent.
09:27:28 <merijn> mkramer: Also, yes
09:27:32 <mkramer> I know Endianness
09:27:41 <merijn> mkramer: Fun example, there exist platforms with 32bit char
09:28:02 <merijn> You wouldn't believe how much code crashes on *that* :)
09:28:24 <mkramer> I'm only planning to use this with fixed-width types
09:28:36 <geekosaur> different compilers can and do pack struct-s in different ways. this is why you'll often see #pragma pack(n) or equivalent in struct definitions in system headers to try to tell varios compilers how the OS expects the struct to work
09:28:45 <levi> merijn: I had a DSP-using coworker come to me with some really weird questions due to 32-bit chars. :)
09:28:48 <mkramer> Both the Haskell version and the C++ version choke on different endianness
09:29:07 <merijn> levi: Silly programmers that don't bother to read the C spec :p
09:29:17 <satc> Is there a monadic version of mapAccum ?
09:29:24 <mkramer> Heh, a 32-bit char is unbelievable
09:29:28 <mkramer> that's not even C++
09:29:34 <mkramer> that's just out of spec
09:29:37 <merijn> mkramer: It is not
09:29:38 <levi> mkramer: Uh, no.
09:29:48 <merijn> mkramer: The C spec only specifies that char is *at least* 8 bits
09:30:09 <levi> mkramer: The definitions of char and byte for the C language are not what you might think.
09:30:12 <merijn> mkramer: Some embedded systems can only address values at 4 byte word granularity
09:30:24 <merijn> The spec was designed with things like these in mind
09:30:44 <Zenol> merijn: silly proc designer which have 32bits char :p
09:30:46 <WraithM> satc: No, I don't think so.
09:30:48 * geekosaur sends mkramer a KL10... 9-bit "byte"s (depending on the compiler of course)
09:31:07 <mkramer> I had no idea
09:31:12 <levi> Zenol: They're not silly at all.
09:31:22 <Zenol> levi: I'm jocking.
09:31:35 <erisco> how is char a processor concept?
09:32:09 <merijn> mkramer: The spec doesn't even specify whether char is signed or unsigned
09:32:19 <levi> It's not, really, but the processor concept of 'smallest addressable memory unit' happens to define the meaning of 'byte' and 'char' in C.
09:32:23 <merijn> mkramer: Only that the ascii values are positive
09:32:35 <erisco> levi, I see
09:33:04 <erisco> levi, I guess you pay for definitions based on performance
09:33:14 <levi> This is why people who want to be precise tend to use words like 'octet' when referring to 8-bit quantities.
09:33:16 <mkramer> That I did know, so I don't find that suprising
09:33:33 <mkramer> In my mind, char == Word8, not Word
09:33:43 <erisco> levi, what is wrong with "byte"?
09:33:45 <mkramer> But no longer!
09:33:45 <levi> erisco: DSPs are rather specialized processors.
09:34:17 <levi> erisco: The problem with using 'byte' should be clear to you.
09:34:23 <erisco> no, it isn't
09:34:24 <merijn> mkramer: The more C you know, the less convinced you get that you actually know C! :)
09:34:43 <levi> erisco: Well, 'byte' doesn't always mean '8 bits'.
09:34:43 <eevar> am I right in assuming that the runtime doesn't like blocking ffi calls, and would be the thing interrupting them? unsafe vs. safe didn't seem to matter much, except adding 10s to my benchmarks
09:34:53 <erisco> if byte means smallest addressable unit, then sure, but byte = 8 bits is fine
09:35:03 <fizbin> If I have (a <$> b <$> pure st <*> c), is there any way to simplify that using properties of <$> and pure?
09:35:08 <erisco> levi, maybe in C land
09:35:09 <Sculptor> yo
09:35:28 <levi> erisco: It doesn't *always* mean 8 bits *anywhere*.  But 'octet' does always mean 8 bits.
09:35:33 <joelteon> :t \a b c d -> a <$> b <$> pure c <*> d
09:35:34 <lambdabot> Applicative f => (a2 -> a -> b) -> (a1 -> a2) -> a1 -> f a -> f b
09:35:41 <erisco> levi, who defined byte?
09:35:44 <merijn> eevar: The runtime doesn't preempt/unschedule threads that run foreign calls, they get moved to a a separate "foreign call" pthread
09:35:45 <joelteon> :t \a b c d -> a <$> b <$> c <$> d
09:35:46 <lambdabot> Functor f => (a2 -> b) -> (a1 -> a2) -> (a -> a1) -> f a -> f b
09:35:51 <joelteon> oh no, that isn't the same
09:36:10 <levi> erisco: I don't know. There exist *varying* definitions. Which is my point.
09:36:19 <erisco> mm
09:36:30 <Saizan> fizbin: f <$> pure x = pure (f x)
09:36:33 <ParahSailin> bytes for harddrive manufacturers is only 7.96 bits
09:36:34 <doomlord> byte  means 8bits for such a large % of software that other uses should be renamed :) i'm happy to lose char
09:36:37 <merijn> eevar: The nicer solution would be to use non-blocking calls and block inside the runtime, but if you can't then blocking is ok
09:36:39 <erisco> well b8 or bit8 then
09:37:04 <ParahSailin> > log 250 / log 2
09:37:06 <lambdabot>   7.965784284662087
09:37:17 <eevar> merijn: i'm receiving EINTR from somewhere. did find a workaround, using threadWaitRead/Write, but I'd like to know what is actually going on
09:37:19 <merijn> eevar: safe/unsafe informs the runtime whether it should consider functions to be "side-effecting" one of the two (I forget which) treats a function as pure and may result in less overhead when calling it
09:37:24 <Saizan> fizbin: in the end that's (a (b st) <$> d)
09:37:24 <joelteon> > log 256 / log 2
09:37:25 <lambdabot>   8.0
09:37:25 <quchen> 7.87! ParahSailin, don't try to fool us!
09:37:27 <doomlord> u8 s8  int8 i guess these are all same or less chars to write out
09:37:42 <quchen> (And that should've been a 9 there.)
09:37:45 <merijn> eevar: EINTR happens if you make a blocking OS call and the process receives a posix signal
09:37:46 <levi> erisco: If you look back at computing history, you'll see that the near-universal 8-bitness of bytes is a somewhat recent thing.
09:37:57 <fizbin> Saizan: Yeah, that's what I started with...
09:38:13 <merijn> eevar: I think the runtime uses SIGALRM for scheduling? (not 100% sure), the delivery of SIGALRM might interrupt blocking OS calls
09:38:20 <levi> erisco: Also, you should not confuse 'the majority of PC software' with 'the majority of software'.
09:38:21 <geekosaur> yes
09:38:32 <lpaste> oio pasted “Helo with thus” at http://lpaste.net/92520
09:38:40 <merijn> eevar: Any other signals like SIGINT, SIGUSR1/2, etc can do the same
09:38:47 <_oio_> someone help me with that ?
09:38:57 <levi> There's a *lot* of code written for embedded systems, where hardware varies a lot more than it does in PCs.
09:39:05 <merijn> eevar: That's basically the smae behaviour as you'd get when writing plain C
09:39:20 <eevar> merijn: think my strace contains a SIGVTALRM before the EINTR, yea
09:39:43 <Eduard_Munteanu> Hm... if a function takes Map A B it's guaranteed the A's are unique. If it takes Map A B and Map B C then A's are unique and the B's in the second map are unique. Any way to get A's and B's completely unique? Map A (Map B C) doesn't cut it.
09:39:43 <merijn> eevar: Well, there you go, then. The EINTR is a kernel thing, not a runtime thing
09:39:55 <quchen> _oio_: What do you want your program to do, what is the program output, what do you expect that snippet to do?
09:40:23 <eevar> merijn: okies, thanks
09:40:25 <quchen> Don't call your variables "nm" because that's not very easy to read ;-)
09:40:50 <_oio_> take random names from the tree
09:41:10 <merijn> I'm guessing this can stack overflow due to the lack of tail recursion: http://lpaste.net/92519 is there a nice way to make it tail recursive?
09:41:19 <merijn> eevar: For more details you might wanna read up on posix signals
09:41:20 <Eduard_Munteanu> Hm, I wonder about. Map (Map A B) C
09:41:28 <merijn> eevar: And/or interruptible system calls
09:41:59 <Zenol> merijn: getMessage :: [Message] -> Get Message ?
09:42:11 <eevar> merijn: it is kindof runtime related too, though, if the runtime depends on signals for scheduling?
09:42:24 <quchen> _oio_: That answers (presumably) one of my questions.
09:42:31 <quchen> There are two more.
09:42:31 <Eduard_Munteanu> Map A B is unique and A is unique, so B should be too. Well, assuming there's is a suitable and compatible Ord on maps.
09:42:59 <Zenol> merijn: err, Message -> Get Message,  and return $ getMessage (Message (val:ms) m) ?
09:43:02 <Eduard_Munteanu> Or maybe not. *overheats*
09:43:18 <Zenol> merijn: And you can rename getMessage getMessageAux and getMessage = getMessageAux []
09:43:22 <merijn> Zenol: And where does ms come from there?
09:43:44 <merijn> Zenol: Your approach reverses the list ordering
09:43:49 <eevar> merijn: either way, thanks
09:43:54 <merijn> Zenol: Or does an O(n) traversal of the list
09:44:09 <_oio_> quchen: is for study you have to remember the leafs of the branch
09:44:16 <merijn> eevar: Ok, a little bit of the runtime, then. But the runtime won't help you further understand how to deal with things ;)
09:44:26 <satc> How to convert unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a) to unfoldrNM :: monad m => Int -> (a -> m (Maybe (Word8, a))) -> a -> m (ByteString, Maybe a)
09:44:39 <Zenol> merijn: Oh. So concatenate at the over return, and just replace the second one by a getMessage call.
09:44:44 <_oio_> quchen: or the root of the branch
09:44:46 <Eduard_Munteanu> compare (M.fromList [(1, 'a')]) (M.fromList [(1, 'b')])
09:44:49 <Eduard_Munteanu> > compare (M.fromList [(1, 'a')]) (M.fromList [(1, 'b')])
09:44:50 <lambdabot>   LT
09:45:27 <merijn> Zenol: Yeah, but I was trying to figure out a nice way to do the concatenate
09:45:28 <Eduard_Munteanu> I guess that does.
09:45:38 <merijn> Zenol: I had an earlier attempt, but the code was horrifically unreadable
09:46:44 <Eduard_Munteanu> Actually not really, a map could be different if only some components in the "codomain" match.
09:47:09 <skypers> hey
09:47:16 <Eduard_Munteanu> Hi, skypers.
09:47:18 <skypers> does someone can test something for me?
09:47:26 <skypers> I’d like to know if jhc’s worth to install
09:47:30 <quchen> _oio_: We don't understand what your program does or should do, and you haven't told us what the problem is. It's very hard to give good advice based on that.
09:47:38 <skypers> I write small executables
09:47:44 <Eduard_Munteanu> skypers: depends on your purpose
09:47:45 <skypers> and it’s a pity I can’t use Haskell
09:47:54 <skypers> Eduard_Munteanu: I write 64k demo
09:47:58 <skypers> with GHC
09:48:02 <Eduard_Munteanu> skypers: you can do that
09:48:04 <monochrom> jhc is small. it should be worth to install.
09:48:11 <skypers> it’s just impossible to write an intro with it
09:48:13 <elliott> ajhc is more active than jhc proper these days, AIUI.
09:48:13 <skypers> seriously?
09:48:22 <skypers> I mean
09:48:25 <Eduard_Munteanu> skypers: mind GHC links things statically by default
09:48:34 <haasn> map (v:) . f . map tail -- can't this be done with lenses somehow?
09:48:37 <skypers> Eduard_Munteanu: I mean
09:48:38 <Eduard_Munteanu> With dynamic linking it should be a lot more reasonable.
09:48:43 <skypers> Eduard_Munteanu: yeah yeah but
09:48:47 <skypers> we need a RT lib
09:48:58 <skypers> for Haskell
09:49:07 <elliott> haasn: traverse._head or such
09:49:16 <Eduard_Munteanu> skypers: well you need a libc for C too, and that's big as well :)
09:49:25 <haasn> (note that (v:) . tail is an isomorphism here)
09:49:34 <skypers> yeah but libc is quite standard everywhere
09:49:43 <Eduard_Munteanu> Yeah.
09:49:45 <_oio_> quchen: takes a conceptual from a txt based on indentation converts that to Tree String from Data.Tree then it slects a random part from that tree the user has guess the leafs of the bracnh asked or the root of that branch
09:49:51 <skypers> the programs I wrote MUST be usable on a freshly installed OS
09:49:55 <haasn> elliott: well traverse._tail would do it if it was ‘map f’ and not f
09:49:59 <haasn> elliott: maybe partsOf (traverse._tail)
09:50:31 <haasn> yeah, indeed that's it
09:50:38 <merijn> Zenol: I guess my question can be generalised to "how do I use monadic actions to tail recursively build a list without my coding becoming unreadable?"
09:50:41 <skypers> Eduard_Munteanu: if ajhc adds a huge runtime library, it’s not worth it :(
09:50:51 <skypers> I want static linking, but small one
09:50:52 <Eduard_Munteanu> skypers: that sort of excludes Haskell solely on the reason it's not popular, because people don't complain about the Python interpreter being too big :)
09:51:01 <skypers> yeah
09:51:31 <elliott> ajhc makes small standalone executables, is my understanding
09:51:33 <elliott> but you should try it
09:51:50 <Eduard_Munteanu> JHC might do that but mind performance isn't on par with GHC by a long shot, IIRC.
09:52:37 <skypers> what do you mean?
09:52:42 <Zenol> merijn: they should be a datastructur wich allow "pushing on the tail" and can be easily converted to list, no?
09:52:47 <skypers> GHC is far away better in term of perf?
09:53:04 <Eduard_Munteanu> skypers: AFAIR it's the only option if you care a bit about speed :)
09:53:05 <lpaste> Zenol annotated “Tail recursion?” with “Tail recursion? (annotation)” at http://lpaste.net/92519#a92521
09:53:16 <skypers> arf
09:53:18 <skypers> :)
09:53:19 <Zenol> merijn: Is it still the same function?
09:53:21 <Eduard_Munteanu> Which may or might not be a problem.
09:53:27 <Eduard_Munteanu> *may not
09:53:44 <Eduard_Munteanu> skypers: what is your application?
09:53:53 <skypers> Eduard_Munteanu: a 64k intro
09:53:54 <joelteon> what happens if you install two libraries that provide the same module?
09:53:55 <skypers> I’m a demomaker
09:53:58 <skypers> for now
09:54:01 <skypers> I use C++
09:54:07 <skypers> sometimes ASM
09:54:09 <Eduard_Munteanu> skypers: mm, does it involve fancy graphics or... ?
09:54:14 <skypers> yeah
09:54:28 <skypers> and music :)
09:54:36 <skypers> I wrote two ones
09:54:37 <monochrom> joelteon: you will get ambiguity. unless you use options to tell ghc or ghci to suppress one library
09:54:41 <DaveS> Ahh good ol demoscene
09:54:46 <skypers> 2 minutes long
09:54:50 <skypers> 40kB
09:55:02 <skypers> so well
09:55:07 <monochrom> skypers: please press enter less often
09:55:07 <skypers> I’d love to write my intro in Haskell
09:55:12 <skypers> (yeah sorry)
09:55:23 <skypers> but Haskell runtime is far away to heavy for such a task
09:55:26 <DaveS> Haskell not really a good platform for that
09:55:27 <lpaste> haasn pasted “Radix sort with lenses” at http://lpaste.net/92522
09:55:41 <skypers> DaveS: unfortunately yeah…
09:56:07 <DaveS> Isn't the whole point of 64k intros to carefully craft each instruction or somesuch
09:56:31 <skypers> DaveS: kinda, but mor
09:56:31 <merijn> Zenol: Yeah, I guess I was hoping to do it without the reverse, though. OTOH, it might just not matter
09:56:31 <skypers> e
09:56:33 <erisco> this criterion library is buggy as all get out mang
09:56:34 <haasn> oh, the first case is unnecessary, neat
09:56:48 <Zenol> merijn: For the revers, I think you can use something else than list, and then use romList
09:56:51 <Eduard_Munteanu> skypers: lines count is a better and probably more fair target for just about any high-level language, rather than code size per se.
09:56:54 <merijn> Zenol: I'll just use the reverse one until I get around to benchmarking, I guess
09:57:26 <skypers> Eduard_Munteanu: sure
09:57:28 <skypers> but heh
09:57:32 <skypers> I don’t make rules :)
09:57:41 <merijn> anyhoo
09:57:43 <merijn> time to go home
09:58:32 <lpaste> haasn annotated “Radix sort with lenses” with “Radix sort with lenses (annotation)” at http://lpaste.net/92522#a92523
09:58:43 <Eduard_Munteanu> skypers: there's 'atom' which can be used to generate C code for embedded targets. Perhaps you can approach it that way.
09:58:44 <haasn> there, much cleaner. :) could be a one-liner if it fit into 80col
09:59:02 <skypers> EvilPenguin: Haskell to C ?
09:59:14 <Eduard_Munteanu> I guess you meant Eduard_Munteanu.
09:59:18 <skypers> yeah sorry :D
09:59:21 <Eduard_Munteanu> skypers: yes
09:59:26 <EvilPenguin> skypers: yes
09:59:27 <Zenol> aren't they any "reversed list" data structure in haskell? Something you append at the end, and that can be converted to a list efficiently ?
09:59:31 <Eduard_Munteanu> Heh.
09:59:36 <skypers> I’ll look forward for it for sure!
09:59:43 <skypers> Zenol: DList
09:59:44 <Eduard_Munteanu> Zenol: Seq
09:59:53 <skypers> Data.DList
09:59:57 <Eduard_Munteanu> Zenol: also a plain list
10:00:06 <Eduard_Munteanu> Zenol: reversing it once isn't a big deal
10:00:20 <skypers> Eduard_Munteanu: plain list are not the correct approach for that
10:00:27 <skypers> difference lists are
10:00:29 <skypers> so, DList
10:00:32 <Eduard_Munteanu> You can cons to it normally so it doesn't take the penalty every time.
10:00:36 <elliott> reversing a list is fine
10:00:41 <elliott> as long as you don't do it much.
10:00:59 <haasn> DList is when you need to be able to append to either side efficiently
10:01:06 <haasn> is useful*
10:01:07 <skypers> Zenol: http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html
10:01:14 <Eduard_Munteanu> Sort of what Seq does too.
10:01:20 <skypers> :)
10:01:23 <Eduard_Munteanu> (which is a tree in fact)
10:01:24 <DaveS> Is DList like a doubly-linked list?
10:01:28 <Eduard_Munteanu> No.
10:01:30 <skypers> no
10:01:36 <haasn> no, DList is like a list with all the (++) associated to the right
10:01:43 <skypers> it’s just a way to get a O(1) (++)
10:01:45 <haasn> DList a = [a] -> [a]
10:02:27 <haasn> roughly speaking
10:02:39 <haasn> toList $ (fromList a ++ fromList b) ++ fromList c
10:02:43 <haasn> = a ++ (b ++ c)
10:03:07 <skypers> isn’t it something like
10:03:15 <skypers> toList l = l []
10:03:30 <haasn> yes
10:03:35 <skypers> so tricky :)
10:03:38 <haasn> and fromList = (++)
10:03:51 <haasn> with (++) for DList being (.)
10:03:53 <ParahSailin> @src Dlist
10:03:53 <lambdabot> Source not found. There are some things that I just don't know.
10:04:42 <arkeet> @hoogle dlist
10:04:42 <lambdabot> Text.Html dlist :: Html -> Html
10:04:42 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
10:04:42 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
10:04:45 <arkeet> :|
10:04:47 <arkeet> @hoogle DList
10:04:47 <lambdabot> Text.Html dlist :: Html -> Html
10:04:47 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
10:04:47 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
10:05:44 <haasn> @hackage dlist
10:05:44 <lambdabot> http://hackage.haskell.org/package/dlist
10:05:46 <Zenol> Both Sequence and DList provide snoc / |>. So, which one would be better (used as snoc snoc snoc toList) than only one reverse? (none? ^^)
10:06:31 <erisco> never mind.... can't get this bench marking library to stay stable long enough to get any results
10:07:15 * arnsholt had to look up what snoc does *hangs head*
10:07:23 <arnsholt> Obvious, in retrospect
10:08:28 <yitz> arnsholt: even more obvious in tcepsorter.
10:08:48 <quchen> Zenol: DList works fairly well when you want a list, and the write/read phases are clearly separated.
10:08:56 <quchen> Zenol: Also it's just a lot simpler than Sequence.
10:12:54 <tisaro> Is it possible to tell if a network handle needs Windows-style newlines?
10:14:08 <lpaste> oio pasted “How can i make a tree out of this” at http://lpaste.net/92524
10:14:21 <thr33strikes> Is it possible to filter getDirectoryContents?
10:15:02 <tisaro> If that was directed at me, I'm afraid I don't see what the two have in common.
10:15:19 * hackagebot http-conduit 1.9.4.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4.5 (MichaelSnoyman)
10:15:23 <geekosaur> fmap a filter function over it?
10:15:59 <thr33strikes> geekosaur: was that response for me?
10:16:06 <geekosaur> yes
10:16:16 <thr33strikes> ok I'll give it a try
10:16:18 <thr33strikes> thanks
10:19:08 <mr413> Hello. I have a function f :: RegExp -> RegExp -> Maybe String, that takes two regexps and returns a string, that is valid for both regexps, or nothing. Any suggestions?
10:20:39 <Ankhers> Is it returning the entire string, or just a subset of it based on the regex?
10:20:50 <satc> Is there any advantage of using Builder to Build Strict ByteString from Building a list and then packing?
10:21:00 <geekosaur> you have, or you want someone to write for you? and had you considered that the general case is not actually possible?
10:21:03 <mr413> Ankhers: entire string
10:21:29 <mr413> geekosaur: I want to get some ideas, how to do that
10:22:35 <thr33strikes> geekosaur:  fmap and map are interchangeable right?
10:22:53 <geekosaur> not 100%, no; fmap is more general
10:23:02 <mr413> geekosaur: yes, i know about the halting problem
10:23:41 <geekosaur> thr33strikes, you cannot map over getDirectoryContents, map wants a list not an IO something
10:24:20 <geekosaur> you can use fmap anywhere you can use map, although it may be less convenient
10:24:28 <thr33strikes> ic
10:24:52 <thr33strikes> geekosaur: the goal is to actually filter getDirectoryContents
10:25:10 <thr33strikes> like for a specific file type
10:25:27 <geekosaur> yes.
10:25:59 <geekosaur> speaking very loosely, fmap lets you operate on the [FilePath] that getDirectoryContents promises to deliver
10:26:36 <geekosaur> so if you have something that operates on [FilePath] then fmap lets you apply it to an IO [FilePath] like getDirectoryContents produces
10:28:40 <geekosaur> thr33strikes, do you understand that you can neither "get the [FilePath] out of the IO [FilePath]" nor treat IO [FilePath] as if it were [FilePath]?
10:28:41 <Ankhers> mr413: How are you deciding when to stop attempting to create this string? I mean, technically speaking, your function could just return Nothing and it would be an accurate representation of what you asked for.
10:29:18 <thr33strikes> I think so
10:29:27 <thr33strikes> but not 100% sure
10:29:56 <thr33strikes> I set the value to another function and was going to manipulate the string that way
10:30:04 <thr33strikes> it's impossible to do in haskell?
10:30:14 <thr33strikes> becaues of the type?
10:30:17 <geekosaur> mr413, so the problem here is, either you do it naively and generate strings until you get something that passes both regex "filters", or you analyze the regexes and use that to either generate a string or recognize that no string can pass both. Except that potentially you can't determine the latter
10:30:36 <geekosaur> thr33strikes, have you read the section on IO in LYAH?
10:30:39 <geekosaur> @where lyah
10:30:39 <lambdabot> http://www.learnyouahaskell.com/
10:31:08 <geekosaur> I have told you how to "get at" the [FilePath], you seem to be confusing that with actually doing the filtering
10:31:28 <thr33strikes> yes exactly
10:31:40 <thr33strikes> I can display the contents of the directory
10:31:52 <thr33strikes> just can't filter them
10:32:01 <thr33strikes> I've tried looking at elem
10:32:07 <thr33strikes> and tail
10:32:15 <geekosaur> you really need to read the IO stuff in LYAH
10:32:21 <thr33strikes> yeah
10:32:35 <thr33strikes> I'll re-read it slower this time lol
10:32:36 <geekosaur> again: if you use fmap, you can "operate on" the [FilePath].
10:32:46 <haasn> how come Repa's B representation is a valid target? I want to serialize a repa array to a file, via ByteString
10:32:50 <haasn> isn't a valid*
10:33:12 <thr33strikes> earlier I was trying to use map and ran into the same issues you stated
10:33:20 <thr33strikes> didn't even know about fmap
10:33:40 <erisco> map is a mistake
10:33:59 <geekosaur> right, youre trying to treat an (IO thing) as a (thing), this will not work. but fmap will let you apply something to the (thing) "inside" (actually, promised by) the (IO thing)
10:34:19 <thr33strikes> going to get a drink and read now
10:34:21 <geekosaur> this is *independent of* the fact that what's promised is a list which you might use map or filter or some other list operation on
10:34:31 <thr33strikes> ok I'll check it out and let you know if I get stuck
10:35:04 <geekosaur> the fmap here applies *only* to the IO, it does not care about what's "inside" it
10:39:16 <wojtekM_> Hello, list.
10:39:30 <wojtekM_> Does GHC have macros to get current source location and function name?
10:40:17 * flebron usually prefers to think of monads in terms of functors with join, so (=<<) = (bind .) . fmap
10:40:19 <satc> @hoogle Word32 -> Word8
10:40:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:40:19 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
10:40:19 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:40:25 <flebron> err, (join .) . fmap :)
10:40:33 <arkeet> satc: fromIntegral
10:41:18 <geekosaur> wojtekM_, no. if you use {-# LANGUAGE CPP #-} then you can get __FILE__ and __LINE__ from that, but of course a C preprocessor does not know about Haskell functions
10:41:20 <flebron> wojtekM_: I wouldn't assume so, since GHC may well eschew functions altogether when compiling (see loop fusion, for instance)
10:45:02 <romanandreg> has anyone tried to proxy HTTP 1.0 servers with http-reverse-proxy
10:45:04 <romanandreg> ?
10:45:28 <satc> arkeet: Is there a good way to split Word32 into 4 * Word8 ? (I am doing that using lots of shiftR, shiftL and fromIntegral)
10:46:04 <Dodek> romanandreg: are there any http 1.0 servers live?
10:47:40 <arkeet> satc: I dunno.
10:48:07 <geekosaur> someone uses 1.0 still? do I hear any 0.9?
10:48:36 <c_wraith> I use 0.9 any time I hand-write an HTTP request
10:48:39 <wojtekM_> What I'm trying to achieve is parsec parser debugging. I hoped I could do this with little effort.
10:48:46 <donri> satc: binary/cereal maybe
10:49:08 <wojtekM_> Is there a way to trace what parsec is doing without writing too much code?
10:51:13 <satc> donri: What I want to do is to map over Word32 using function :: Word8 -> Word8
10:58:08 <wojtekM_> Nothing like in GNAT? http://www.radford.edu/~nokie/classes/320/std_lib_html/gnat-source_info.html
11:08:02 <Eduard_Munteanu> Is there a data structure that pairs a Set with a function? It would be different from a Map.
11:08:56 <Eduard_Munteanu> Some sort of total and injective Map would be nice too.
11:09:15 <satc> @pl \a b -> f a
11:09:16 <lambdabot> const . f
11:10:05 <arkeet> Eduard_Munteanu: what do you mean?
11:10:23 * hackagebot network-metrics 0.3.2 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.3.2 (BrendanHay)
11:11:32 <Eduard_Munteanu> arkeet: I'm trying to put some uniqueness constraints on some data. Certain fields or pairs of fields must be unique. So I'm ditching away lists for one thing. But Maps and Sets aren't enough.
11:12:02 <enthropy> Eduard_Munteanu: is (Set a, a -> b) going to give you something different from  Map a (() -> b)?
11:12:30 <enthropy> which you can make Map a b if you want sharing
11:12:47 <Eduard_Munteanu> enthropy: that isn't total in 'a'.
11:13:22 <Eduard_Munteanu> enthropy: it does guarantee the a's are unique though
11:13:38 <enthropy> so keep a 'b' around for when lookups in the Map fail
11:14:05 <Eduard_Munteanu> enthropy: I'd rather have the caller supply valid data
11:14:25 <Eduard_Munteanu> There's no easy choice of 'b' when the 'a' is missing.
11:14:34 <Eduard_Munteanu> (I'd also need the missing 'a'.)
11:14:47 <arkeet> so keep a (a -> b) around
11:14:52 <arkeet> ?
11:15:16 <Eduard_Munteanu> arkeet: yeah... hence (Set a, a -> b) :)
11:15:33 <arkeet> I don't know what the Set would do.
11:15:40 <arkeet> I could understand (Map a b, a -> b)
11:16:14 <Eduard_Munteanu> arkeet: the API I'm designing needs the a's.
11:16:54 <Eduard_Munteanu> You can in fact consider 'a' a type variable.
11:17:03 <arkeet> I don't get it.
11:21:00 <Eduard_Munteanu> arkeet: say I have a function f :: [(a, b)] -> [(b, c)] -> ... and I want all of a, b and c to be unique, or maybe I want a and (b, c) unique etc.. If I replace the assocs lists with a Map or function, the domain of each of those two is set-like so values are unique.
11:21:43 <Eduard_Munteanu> But if I only pass in functions I don't know values of the domain.
11:22:01 <Eduard_Munteanu> So I also pass in a Set.
11:23:08 <Eduard_Munteanu> Now I can say e.g. f :: Set a -> (a -> b) -> (a -> c) ...  to get unique a's and pairs (a, b) and (a, c).
11:23:33 <Eduard_Munteanu> I was wondering how / if I can generalize this thing to arbitrary uniqueness constraints.
11:23:37 <mebaran151> how do I read a string "0.2638" as a Rational
11:23:56 <arkeet> > read "0.2638" :: Rational
11:23:57 <lambdabot>   *Exception: Prelude.read: no parse
11:24:17 <mebaran151> arkeet: I tried that which is why I came here, all confused like :)
11:24:20 <Eduard_Munteanu> > toRational (read "0.2638")
11:24:21 <lambdabot>   *Exception: Prelude.read: no parse
11:24:23 <arkeet> :)
11:24:38 <arkeet> Eduard_Munteanu: that goes through Integer or something.
11:24:45 <mebaran151> I would prefer not to read it as a float because I want to maintain exact precision (this app deals with money)
11:24:49 <Eduard_Munteanu> I think that gets treated as a float value so it's definitely not Rational.
11:24:55 <Eduard_Munteanu> Rationals are supposed to be exact.
11:25:04 <mebaran151> I want the exactness
11:25:21 <arkeet> > 0.2638 :: Rational
11:25:22 <lambdabot>   1319 % 5000
11:25:24 <mebaran151> 0.2638 :: Rational
11:25:29 <mebaran151> yep that works
11:25:41 <Eduard_Munteanu> arkeet: is the above a bit more clear now? (just asking if it's clear)
11:25:52 <arkeet> mebaran151: have you seen Data.Decimal?
11:25:59 <arkeet> Eduard_Munteanu: sorry, I haven't really been following.
11:25:59 <mebaran151> I just need to a handle how GHC makes 0.2638 into a Rational
11:26:07 <Eduard_Munteanu> Oh, ok.
11:26:09 <mebaran151> arkeet: I've seen it
11:26:24 <mebaran151> I was hoping not to have to add another package to my build
11:26:36 <mebaran151> given that GHC knows how to parse rational correctly anyway .....
11:31:17 <Eduard_Munteanu> If I could have provably injective functions (or merely hard to work around) I could "propagate" uniqueness around.
11:32:21 <ReinH> edwardk: hai :)
11:32:24 <Eduard_Munteanu> Maybe I need to make my types more polymorphic so that injectiveness is obvious.
11:32:25 <haasn> > let sort = partsOf (traverse.partsOf (backwards bits)) %~ sort'; sort' = uncurry (flip (++)) . over both (partsOf (traverse._tail) %~ sort') . partition head in sort [234,241,162,203,147,81,80,232,53,99 :: Word8] -- edwardk
11:32:27 <lambdabot>   [53,80,81,99,147,162,203,232,234,241]
11:32:36 <haasn> now please forget I ever wrote that
11:32:41 <haasn> it's horrendeously ugly
11:32:43 <edwardk> haasn: obviously
11:32:46 <edwardk> heya ReinH
11:32:55 <edwardk> no i haven't finished your automata post yet ;)
11:33:05 <ReinH> haasn: are you sure there isn't an operator for that? ;)
11:33:08 <ReinH> edwardk: ok :)
11:33:10 <haasn> http://lpaste.net/92523 for a cleaner ver
11:33:18 <haasn> ReinH: I might have to add one to Data.Bits.Lens
11:33:31 <edwardk> ReinH: spent too much time yesterday making the mandelbrot code do adam7 interlacing ;)
11:33:42 <edwardk> also started work on folds
11:33:58 <edwardk> trying to get a better feel for why/how/why they work the way they do
11:34:05 <ReinH> edwardk: I'm still trying to work out a special case of the Floyd algo for 2d grids where Vector (Vector Bool) represents squares that are mutually reachable
11:34:30 <ReinH> if Grid a = Vector Vector a then I should be able to write shortestPaths :: Grid Bool -> Grid (Grid Weight)
11:34:48 <ReinH> and it should be simpler t han the adjaacency matrix version
11:35:12 <edwardk> sure
11:35:17 <edwardk> so compute a transitive closure
11:36:16 <ReinH> from what to what?
11:36:37 <roconnor> I have a blog post about that.
11:36:39 <roconnor> :P
11:37:09 <ReinH> roconnor: about what?
11:37:16 <edwardk> start with a grid x grid representing one step immediate neighbors. that you can get from x to y where y is next to x and not opaque
11:37:24 <edwardk> then transitively close it
11:37:27 <Yaniel> hmm physics homework has a bonus task "write a computer application that solves the equations in the previous task"
11:37:36 <Yaniel> guess what I'll write it in :P
11:37:56 <syntaxfree> Hi, I think I need infuriating amounts of hand-holding to get xmonad working on a remote/vps centos image. I'm going to -blah in case people are in the mood to humor me so not to disturb the more relevant discussion here.
11:37:59 <edwardk> Yaniel: bourne shell? LaTeX? Lazy K?
11:38:08 <danharaj> Unlambda
11:38:13 <danharaj> Minecraft
11:38:14 <Yaniel> nah
11:38:16 <edwardk> malbolge
11:38:20 <edwardk> should be extra credit
11:38:29 <ReinH> brainfuck please
11:38:29 <Yaniel> yeah it should :D
11:38:31 <danharaj> a quine in minecraft
11:38:39 <Yaniel> malbolge or maybe befunge
11:38:45 <ReinH> but you are allowed to use Haskell as a preprocessor ;)
11:38:54 <Yaniel> :D phew
11:39:04 <Yaniel> but I've been mostly needing an excuse to use haskell lately
11:39:10 <int-e> that's easy then, just write a compiler
11:39:45 <ReinH> edwardk: is that a version of dijkstra? It sounds like it.
11:40:08 <haasn> Malbolge was designed to be as difficult as possible to write a program in despite being easy to interpret. Is there a language that does the reverse, is easy to write code in but as hard as possible to interpret? I know befunge sort of goes into this direction specifically when it comes to compiling it to native code
11:40:18 <roconnor> @google a very general method of computing shortest paths
11:40:19 <edwardk> ReinH: its 'the dumbest thing that works' to compute path costs in a tropical semiring
11:40:22 <lambdabot> http://r6.ca/blog/20110808T035622Z.html
11:40:29 <roconnor> ReinH: ^^
11:40:29 <ReinH> edwardk: a tropical semiring... ok.
11:40:33 <ReinH> roconnor: thanks :)
11:40:39 <ReinH> roconnor: nice one
11:41:11 <edwardk> ReinH: roconnor's link explains exactly what i'm talking about.
11:41:17 <ReinH> edwardk: now the question is how do I write it to maximize sharing and leverage commutativity
11:41:21 <ReinH> edwardk: awesome :D
11:41:26 <edwardk> you can actually get away with _slightly_ weaker algebraic structures than he requires there though ;)
11:41:39 <ReinH> awesome :D
11:41:50 <roconnor> does that link work for you?
11:41:56 <ReinH> maaaaybe
11:42:08 <roconnor> I'm seeing a lot of spinning circles :(
11:42:18 <ReinH> roconnor: no :(
11:42:59 <edwardk> roconnor: loaded for me
11:43:07 <haasn> “an algorithm whose implementation is not very much longer than its name” [goes on for several pages]
11:43:11 <haasn> hey!
11:43:19 <haasn> that's not ‘not very much longer’ :(
11:43:28 <roconnor> okay, maybe it is slow for some reason.
11:43:34 <edwardk> http://db.cis.upenn.edu/DL/07/pods07.pdf covers omega-continuous semirings, which are strong enough to implement floyd-warshall derivatives
11:43:47 <edwardk> there are other links available as well in the analytics notes
11:43:53 <ReinH> edwardk: how do you know these things?
11:44:14 <edwardk> haasn: it has a very long name…
11:44:22 <edwardk> ReinH: osmosis
11:44:40 <haasn> edwardk: still shorter than lens type signatures
11:44:45 <ReinH> edwardk: er, what analytics notes?
11:44:45 <roconnor> when I design my undergrad CS course, kleene-algebras will be taught.
11:45:05 <erisco> I just thought he made bottles oO
11:45:08 <ReinH> roconnor: it's loading for me now
11:45:09 <roconnor> along with monoids and dioids.
11:45:21 <ReinH> erisco: hose bottles are stupid. I can't even drink out of them.
11:45:23 <ReinH> *those
11:45:23 <edwardk> ReinH: https://github.com/analytics/analytics/blob/master/notes/papers.md paper references for the work on analytics
11:45:31 <ReinH> ah
11:45:35 <ReinH> neat
11:45:41 <ocharles> that file is a little treasure trove :)
11:45:45 <edwardk> kleene != klein =)
11:45:54 <erisco> ReinH, maybe that is why he went into making algebras instead
11:45:56 <ReinH> edwardk: those notes are a gold mine
11:46:09 <ciaranm> not got a klein stein?
11:46:24 <ReinH> edwardk: I wanted to make the joke anyway
11:46:27 <ocharles> roconnor: i'll sign up!
11:46:35 <edwardk> ReinH: they pretty much cover 'what i didn't know about datalog and algorithms when i started analytics, or stuff i had to explain to everyone along the way'
11:47:59 <ReinH> edwardk: yeah, looks great
11:48:05 <ReinH> roconnor: " Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm" oh of course
11:48:21 <ReinH> I expected a Yoneda in there frankly and am somewhat disappointed
11:48:36 <roconnor> ReinH: every algorithm taught in CS is actually the same algorithm.
11:48:52 <ReinH> hah
11:50:26 <Lethalman> we studied datalog at my course :)
11:50:30 <haasn> every algorithm is just an heuristic attempt at partially solving the halting problem
11:50:38 <tel> CS is really just automata theory anyway, right?
11:51:36 <Dodek> tel: wrong
11:52:44 * tel /badjoke
11:54:34 <edwardk> tel: which brings it back to comonads, through store! =)
11:55:11 <tel> edward all roads lead to comonad!
11:55:17 <merijn> fix extend?
11:55:31 <merijn> :t fix extend -- Comonads all the way down...
11:55:33 <lambdabot> Not in scope: `extend'
11:55:35 <merijn> aww
11:55:41 <edwardk> :t fix Control.Comonad.extend
11:55:42 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = w0 b0
11:55:42 <lambdabot>     Expected type: (w0 a0 -> b0) -> w0 a0 -> b0
11:55:42 <lambdabot>       Actual type: (w0 a0 -> b0) -> w0 a0 -> w0 b0
11:55:46 <edwardk> sadly
11:56:02 <merijn> oh, duh, stupid "(a -> a)" type
11:56:09 <edwardk> loop f = iterate (tab . extend f ) . tab gets used a lot
11:56:23 <merijn> :t Control.Comonad.extend
11:56:24 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
11:56:27 <edwardk> :t Control.Comonad.wfix Control.Comonad.extract
11:56:27 <lambdabot>     Occurs check: cannot construct the infinite type:
11:56:28 <lambdabot>       a1 = (w0 a1 -> a0) -> a0
11:56:28 <lambdabot>     Expected type: w0 a1 -> (w0 a1 -> a0) -> a0
11:56:34 <edwardk> :t Control.Comonad.wfix
11:56:34 <lambdabot> Control.Comonad.Comonad w => w (w a -> a) -> a
11:58:44 <spaceships> what is (>=>) useful for in practice?
11:59:14 <tel> composing "monadic transformations"
11:59:23 <tel> like nested lookups
11:59:32 <tel> lookup "foo" >=> lookup "bar"
11:59:39 <spaceships> tel: ah, interesting, thanks
12:00:15 <tel> sometimes that's just a more natural way of expressing your monadic code
12:00:17 <tel> : )
12:00:25 <flebron> Hi. On a Haskell wiki page, I find "Don't do runST $ do .... It doesn't work (at the moment). The reasons are obscure, having to do with unification and higher-rank polymorphism. Do runST (do ...) instead.". I thought $ was just syntactic sugar (i.e. precedence), but otherwise was just simple parenthesis? (i.e. f $ x = f x)
12:01:13 <geekosaur> it's not syntactic sugar at all
12:01:26 <haasn> ($) is a normal function, with a normal (rank-1) type signature
12:01:26 <spaceships> tel: cool thanks
12:01:34 <geekosaur> it's a perfectly nromal operrator, with lowest precedence
12:01:37 <flebron> Well, f $ x = f x, so it's not doing much in terms of semantics.
12:01:44 <flebron> (That's what I call sugar)
12:01:47 <haasn> using it with something that's polymorphic would require instantiating it to a rank-2 type
12:01:50 <haasn> which GHC can't do automatically
12:01:52 <pseudolio> flebron: "runST $ do ..." actually works now.
12:02:00 <haasn> because rankn types cannot be inferred
12:02:03 <pseudolio> It's special-cased in the type checker.
12:02:16 <pseudolio> ($ is).
12:02:20 <haasn> pseudolio: unfortunately (.) still breaks it
12:02:25 <pseudolio> Yes.
12:03:53 <stelleg> so thats very strange, SDL.flip causes the JACK client in a different thread to "fail"
12:05:24 <stelleg> i wonder if there is some global IO manager issue
12:06:01 <merijn> flebron: The thing is, ($) *is* doing something in terms of semantics
12:06:25 <merijn> flebron: It's just not doing anything you can see in standard haskell as it only effects higher rank types
12:07:00 <merijn> stelleg: Are you using forkIO in your code?
12:07:04 <tel> merjin can you explain what the difference is.. I've always been confused as to why $ needed a special case
12:07:07 <stelleg> merijn: yes
12:07:15 <stelleg> merijn: although I've tried forkOS as well
12:07:20 <merijn> stelleg: Maybe SDL or JACK are using thread local storage?
12:07:21 <flebron> We have runST :: (forall s. ST s a) -> a. The issue is that a -> b cannot unify with that?
12:07:33 <merijn> :t ($)
12:07:34 <lambdabot> (a -> b) -> a -> b
12:08:02 <stelleg> merijn: I think if that was the problem forkOS would fix the issue
12:08:19 <FreeFull> $ is infix id
12:08:28 <flebron> (I'm using the term unify as if we were still in Hindley-Milner)
12:08:38 <FreeFull> > (+1) `id` 5
12:08:39 <lambdabot>   6
12:08:46 <stelleg> but even writing the image that would be SDL.flip 'd to stdout doesn't effect jack
12:08:46 <merijn> tel: hmm, I'm not sure I know the details well enough to explain
12:08:56 <kuribas> How can I evaluate "scanl1 (zipWith (+)) list" eagerly?
12:08:57 <ReinH> roconnor: you are blowing my mind right now
12:08:59 <merijn> FreeFull: Yes, which is true and also completely irrelevant to the conversation
12:09:07 <roconnor> ReinH: horray
12:09:09 <merijn> FreeFull: As id has the exact same problem
12:09:25 <pseudolio> Hindley-Milner doesn't even have types like (forall s. ST s a) -> a.
12:09:26 <FreeFull> Just a random remark
12:09:49 <flebron> right, hence why we're not there anymore :)
12:10:02 <pseudolio> Depending on your type system, a -> b can unify with (forall s. ST s a) -> a.
12:10:10 <FreeFull> Does HM even do typeclasses?
12:10:22 <merijn> tel: Right, follow pseudolio's explanation :)
12:10:33 <merijn> FreeFull: No, but tyou can trivially fake them with functions and records
12:10:39 <pseudolio> But, GHC's type system doesn't support things like that well.
12:11:15 <pseudolio> However, there's a hack in GHC such that 'e1 $ e2' is type checked exactly like '(e1) (e2)'.
12:11:26 <FreeFull> :t runST undefined
12:11:27 <lambdabot> a
12:11:37 <kuribas> Is there an eagler scanl?
12:11:40 <kuribas> eager
12:11:42 <FreeFull> pseudolio: Why does it unify there?
12:12:01 <pseudolio> Where?
12:12:15 <FreeFull> a with (forall s. ST s a)
12:12:38 <pseudolio> That is not the same problem.
12:13:21 <FreeFull> So how a unifies depends on the function arrow being there?
12:13:43 <pseudolio> There, runST expects an argument with type (forall s. ST s a). And you are supplying an argument with type (forall a. a). That works.
12:15:14 <pseudolio> It is difficult to explain why they work differently without getting into exactly how the type checking algorithm works.
12:15:17 <tel> pseudolio I guess it comes down to what the difference is between systems that "unify" (forall s. ST s a) -> b and a -> b
12:15:32 <totte> I'm trying to compile cabal-install from Hackage with these instructions: https://gist.github.com/totte/6412015#file-pkgbuild-L25-L32, but running execstack on the /usr/bin/cabal tells me it has an executable stack, which - for reasons I don't fully understand - is a bad thing. Is there a way to "disable" that with some options somehow?
12:15:33 <S_J> > foldl (.) id [(+7),(*4),(-3)]
12:15:34 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
12:15:35 <lambdabot>    arising from a use ...
12:15:38 <tel> which, yeah, I'm not sure I understand well enough
12:15:46 <S_J> > let fs = foldl (.) id [(+7),(*4),(-3)] in fs 5
12:15:48 <lambdabot>   No instance for (GHC.Show.Show a0)
12:15:48 <lambdabot>    arising from a use of `M698187601.sho...
12:15:56 <S_J> > let fs = foldl (.) id [(+7),(*4),(+3)] in fs 5
12:15:57 <lambdabot>   39
12:17:16 <pseudolio> However, in 'runST undefined' you are checking if two polymorphic things are compatible by instantiating the outermost quantifiers, leaving two types without quantifiers.
12:17:41 <merijn> S_J: Pretty sure the problem is "-3" which parses as the numer, not the slice
12:17:50 <merijn> S_J: You probably want subtract
12:17:59 <Okasu> > let fs = foldl (.) id [(+7),(*4),((-) 3)] in fs 5
12:18:00 <lambdabot>   -1
12:18:09 <elliott> ((-) 3) is not (\x -> x - 3)
12:18:20 <monoidal> note that
12:18:26 <merijn> subtract x == flip (-) 3
12:18:27 <monoidal> > (subtract 3 1, (-) 3 1)
12:18:28 <lambdabot>   (-2,2)
12:18:30 <pseudolio> Whereas '($) runST' involves unifying an open variable with a polymorphic type, which is part of a different algorithm.
12:19:07 <S_J> Has Peyton-Jones been involved with FSharp? So the motivation for FSharp is func programmong in .NET. But they also wanted to make it more accessible so they made it less haskell-ish?
12:19:51 <merijn> S_J: F# is more OCaml/SML inspired than Haskell
12:20:26 <merijn> S_J: And I'm about 99% sure SPJ has no involvement with F# other than maybe talking to some people that are involved with it
12:20:37 <pseudolio> So, 'check if forall b. b is compatible with forall s. ST s a' is an okay operation, but 'set b = forall s. ST s a' is not, basically.
12:21:35 <pseudolio> Some algorithms do better jobs with this, and worse jobs at other things.
12:21:38 <tel> pseudolio I'm beginning to see it now
12:24:16 <kuribas> I have "scanl1 (zipWith (+)) $ zipWith crunch a b", where I'd like crunch to evaluate all it's elements eagerly.  How do I do this?
12:24:32 <ReinH> roconnor, edwardk: http://i.imgur.com/sg017lt.gif
12:24:45 <merijn> ugh, 15 billion different testing libraries/frameworks wrapping hunit/quickcheck and only one supports running full programs >.>
12:24:55 <kuribas> with crunch :: Double -> Double -> [Double]
12:25:02 <ReinH> merijn: which one is that?
12:25:22 <merijn> ReinH: proctest seems to have at least some support for running executables
12:25:35 <ReinH> kuribas: bang patterns? crunch !i !j = ...
12:25:47 <edwardk> ReinH: which part caused your brain to explode? We need to know so we can tune our presentation in the future to maximize or minimize this effect
12:25:49 <ReinH> merijn: I wouldn't call that the responsibility of a unit testing framework
12:26:12 <ReinH> edwardk: haha! The ridiculous power of *-semirings in general
12:26:17 <merijn> ReinH: Who said I was looking for a unit testing framework?
12:26:18 <kuribas> ReinH: But will the generated list be eager?
12:26:36 <ReinH> merijn: most of those frameworks you're talking about are unit / tdd /bdd testing frameworks
12:26:45 <merijn> ReinH: Hence my complaint
12:26:58 <ReinH> merijn: so your complaint is that unit testing frameworks are unit testing frameworks? :p
12:27:17 <merijn> ReinH: No, my complaint is that all testing frameworks are unit testing frameworks
12:27:23 <ReinH> merijn: ah :)
12:27:36 <ReinH> merijn: I'd rather write something specifically for integration / acceptance testing
12:27:42 <ReinH> than try to shoehorn it into a unit testing framework
12:27:55 <ReinH> kuribas: no, your is and js will be strict :)
12:28:12 <ReinH> kuribas: if you want the list to be eagar you need your scanl to be strict
12:28:15 <merijn> ReinH: Who says I want that? I just want a nice integration/acceptance/sanity testing framework that integrates with cabal
12:28:36 <merijn> Unit tests are useless for complex IO behavior
12:28:47 <ReinH> merijn: well, you expressed disappointment that current frameworks, which are almost entirely unit testing frameworks, don't have this functionality
12:29:35 <merijn> ReinH: I expressed my disappointment that there is no framework for this and that everyone seems to busy inventing the umpteenth TDD/unit testing/bdd nonsense library for no good reason
12:29:40 <ReinH> merijn: the alternatives seem to be either adding it to them or creating a new one
12:29:49 <ReinH> I'm just saying I would prefer the latter
12:30:02 <merijn> I would to, but I would prefer not to have more yak shaving even more
12:30:09 <ReinH> sure
12:30:23 <merijn> Because I don't want to be writing a testing framework >.<
12:30:27 <ReinH> merijn: It is disappointing that there isn't more of a focus on integration/acceptance testing
12:30:41 <ReinH> I blame the "as long as it compiles" mentality ;)
12:30:47 <tel> ReinH++
12:30:56 <merijn> I think it's a more overarching problem with programmers
12:31:01 <ReinH> merijn: also that :)
12:31:03 <merijn> There seem to be two types of programmers
12:31:17 <merijn> Those who drink the TDD/unit testing koolaid and those who don't test at all
12:31:29 <ReinH> merijn: I should say that it is specifically exacerbated for Haskellers because of the "as long as it compiles" mentality :)
12:31:49 <merijn> integration/acceptance tests get a much better bang for the buck than unit testing in my experience
12:31:51 <ReinH> merijn: actualy my experience is the opposite: almost everyone is somewhere on the "eventual testing" continuum
12:32:01 <ReinH> very few people don't test at all and very people practice pure tdd
12:32:11 <ReinH> *very few
12:32:23 <ReinH> pure tdd requires a lot of discipline
12:32:27 <tdammers> that's because tdd only really works theoretically
12:32:34 <ReinH> tdammers: no so :)
12:32:37 <tdammers> in practice, you often don't know what you'll be building
12:32:40 <merijn> tdammers: Not even then
12:32:48 <ReinH> tdammers: that's a strawman
12:32:57 <merijn> TDD is a waste of engineering resources for people who don't know how to make trade-offs
12:32:59 <ReinH> you never know what you're going to be building in the future
12:33:11 <ReinH> that doesn't invalidate TDD in the slightest
12:33:19 <tdammers> no, I mean, you don't know what you need (at the unit level) until you've built it
12:33:28 <ReinH> tdammers: you do if you're doing TDD
12:33:29 <ReinH> that's the entire point
12:33:48 <tdammers> well, depending on what you're building, it may or may not work
12:33:56 <tdammers> I've had some decent success with a template compiler
12:34:01 <satc> Is there a way to show a Word (8,16,32,64) in hex instead of decimal? or I will have to write my own show instances for them?
12:34:01 <tdammers> did that completely tdd
12:34:09 <tdammers> the full red/green/refactor dance, religiously
12:34:12 <ReinH> tdammers: some things are more ammenable to TDD, sure
12:34:12 <tdammers> worked rather well
12:34:21 <ReinH> but more things are TDDable than people thing
12:34:23 <ReinH> think
12:35:01 <merijn> ReinH: My argument is different, I'm saying that the engineering/money to bugs prevented of ratio of TDD is terrible compared to other testing strategies
12:35:19 <ReinH> The things that are difficult to TDD are usually things like emergent behavior (game AIs) and such
12:35:36 <ReinH> but you can usually still find smaller units that are testable
12:35:49 <shoret> i find that writing tests before writing code saves engineering resources in the long run
12:35:54 <ReinH> merijn: if you think that's the only thing TDD is good for, sure
12:36:01 <ReinH> but I think that's a reductionist fallacy
12:36:19 <ReinH> merijn: TDD is a *design* technique
12:36:21 <ReinH> it says so right on the tin
12:36:49 <ReinH> The goal of TDD is not (just) to minimize bugs: it's to improve design.
12:36:55 <kuribas> Is there eager list construction?  for example: head [1, undefined, 2] = undefined
12:37:21 <tel> ReinH what do you think about frontloaded prototyping?
12:37:27 <kuribas> > head $! [1, undefined, 2]
12:37:28 <merijn> ReinH: I think TDD tends to make design actively worse by prematurely committing to a certain approach
12:37:28 <lambdabot>   1
12:37:40 <tel> I always say that you should prototype until you discover some invariants/expectations you have
12:37:45 <ReinH> merijn: then I would suggest that you do not understand TDD
12:37:46 <tel> then red/yellow/green
12:37:47 <ReinH> with respect
12:37:57 <tel> so that you've encoded those expectations
12:38:10 <ReinH> TDD embraces the "just in time, not just in case" mentality
12:38:19 <ReinH> you write tests for exactly what you need *right now*.
12:38:33 <ReinH> there is no need to commit yourself prematurely to anything
12:38:46 <shoret> merijn: that can happen, but from a too-fine granularity -- testing the internals instead of the behavior
12:39:20 <ReinH> tel: There's always a tradeoff between any kind of front-loaded design work and the ability to respond to change
12:39:44 <ReinH> tel: but front-loaded design that incorporates feedback (i.e. prototyping) is certainly far better than that which doesn't
12:39:54 <tel> ReinH I mean it more that people complain TDD is hard because they don't know proactively what the test ought to do
12:40:10 <tel> which I feel like calls for prototyping
12:40:19 <ReinH> tel: I totally don't understand that argument. You are about to write some code either way. How do you know what that code is going to do?
12:40:27 <shoret> tel: if they don't know what the test should do, they don't know what the code should do
12:40:33 <ReinH> If you know what that code is going to do then you know what the test is going to test.
12:40:52 <merijn> Anwyway, to get back to coding
12:40:52 <ReinH> If you don't know what the code is going to do then you can't write the code, much less the test
12:41:04 <shoret> and defining what the code should do is helped by writing the tests
12:41:11 <merijn> ReinH: Unless you write code to explore the possible approached to what you're going to do...
12:41:18 <tdammers> ReinH: as long as you stick with simulation / end-to-end tests, fine
12:41:21 <ReinH> merijn: sure, but you can test drive that code too
12:41:34 <tel> ReinH I suppose I'm not articulating the point well, it's sort of me trying to talk about unifying top down and bottom up design
12:41:41 <merijn> Does anyone know a clean way of making http://lpaste.net/92519 tail recursive or should I just settle for the "reverse" approach for now
12:41:46 <ReinH> tel: right
12:41:48 <tdammers> but going TDD at the unit level is harsh
12:42:01 <merijn> ReinH: And I'm saying that not bothering with all the tests while doing that saves a ton of engineering/money
12:42:20 <ReinH> tdammers: I use an outer and inner cycle, where higher-level acceptance tests drive a shorter inner cycle of unit tests
12:42:23 <S_J> merijn: so what do you prefer over unittests?
12:42:49 <ReinH> merijn: and I'm saying that that is a very short-sighted estimation of the total lifecycle cost of software development
12:42:56 <merijn> S_J: Who said anything about being against unit tests? I just said I was against TDD
12:42:58 <ReinH> of exactly the kind that causes so much of the poor software we currently experience
12:43:19 <ReinH> people generally make poor now vs later tradeoffs because of hyperbolic discounting
12:43:22 <ReinH> it's our psychology
12:43:30 <ReinH> anything, like TDD, that helps combat that is useful
12:43:31 <merijn> ReinH: Not really, you expand your test suite as you go along as you consider needed based on the code's complexity
12:43:40 <tdammers> merijn: TDD is a design strategy, not a testing strategy. You get the tests for free, which is nice, but you write them to drive the design, not primarily to make sure everything works.
12:44:17 <tdammers> a problem I've seen with TDD, though, is that it can lead to overspecification
12:44:18 <ReinH> merijn: you are operating under a false assumption about the goals of TDD and deriving faulty conclusions
12:44:24 <merijn> tdammers: Yes, someone mentioned that before and my response is that I consider TDD to be a terrible design strategy compared to, say, rapid prototyping, storyboarding, whiteboard sketching, etc.
12:45:07 <merijn> Anyway, I'd rather hear suggestions for my monadic list construction problem than more TDD arguments :\
12:45:09 <tdammers> merijn: IMO, TDD is a good design strategy when you have figured out roughly what it is you are building and how you'll get there
12:45:15 <tdammers> right
12:45:19 <ReinH> tdammers: or when you haven't :p
12:45:21 <tdammers> actual programming problems
12:45:43 <ReinH> but it's not like we're going to solve world hunger^W^W^W settle the TDD argument today
12:46:34 <ReinH> merijn: tell me about your list construction problem :)
12:46:40 <merijn> Basically both the non-tail recursive implementation and the reverse one are fairly readable, but both are flawed in terms of space consumption or complexity, but I'm not sure if there's a nicer way
12:46:52 <merijn> ReinH: Just linked it: http://lpaste.net/92519
12:47:22 <merijn> ReinH: The first one can stack overflow due to absence of tail recursion, the second adds an extra "reverse" pass at the end, which is also not very nice
12:47:39 <merijn> I'm wondering if there's a way to avoid both issues without making the code terribad
12:47:53 <d3lxa> how can I write my parseJSON using read, i'm stuck with http://sprunge.us/RWIL any idea? it's for enums, thus writing each constructor is not a solution
12:56:35 <kuribas> > let a = [1, undefined, 3, 4] in foldr1 seq a `seq` head a
12:56:38 <lambdabot>   *Exception: Prelude.undefined
12:56:43 <kuribas> That should do it...
12:57:37 <ReinH> merijn: hmm
12:58:29 <ion> foldr1 :-(
12:58:39 <ion> head :-(
12:59:01 <kuribas> It's safe, because the list has 4 elements.
13:00:01 <ion> If your list is constant, you can just replace the whole thing with the result. In this case, “undefined”.
13:00:30 <monoidal> > foldr1 (flip seq) [1,2,3]
13:00:33 <lambdabot>   1
13:00:40 <ReinH> kuribas: seq only evaluates to WHNF
13:01:04 <kuribas> What does that mean?
13:01:04 <dmwit> > head $!! [1, undefined, 3, 4]
13:01:06 <lambdabot>   Not in scope: `$!!'
13:01:06 <lambdabot>  Perhaps you meant one of these:
13:01:06 <lambdabot>    `$!' (imported from...
13:01:27 <ReinH> kuribas: http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
13:01:28 <kuribas> ion: In my code, I am sure my list will have more than one element.
13:01:54 <kuribas> ReinH: It's ok, because the elements are numbers.
13:02:04 <ReinH> kuribas: what do you mean?
13:02:11 <dmwit> kuribas: You might consider importing Control.DeepSeq and using head $!!
13:02:24 <ReinH> kuribas: I'm explaining why it seq doesn't evaluate the elements of the list
13:02:28 <ReinH> s/it //
13:02:36 <kuribas> ReinH: It does.
13:02:46 <ReinH> kuribas: no, it doesn't.
13:02:52 <ReinH> it evaluates the structure of the list
13:02:54 <dmwit> ReinH: For some numbers, WHNF is NF.
13:03:12 <kuribas> I mean if I write "foldr1 seq a".
13:03:23 <ReinH> kuribas: well yes, if you apply seq to each element of the list
13:03:34 <ReinH> or you could use DeepSeq
13:04:03 <kuribas> True.
13:04:09 <dmwit> d3lxa: Did you get an answer?
13:04:44 <kuribas> But in this case there isn't any advantage over DeepSeq, right?
13:04:54 <dmwit> d3lxa: Consider something like parseJSON (String t) = case reads (unpack t) of (v, ""):_ -> return v; _ -> fail "didn't parse"
13:05:15 <joelteon> > seq [undefined] ()
13:05:16 <lambdabot>   ()
13:05:25 <dmwit> or you might put a more relaxed condition on the remaining unparsed text than that it be empty. Up to you.
13:05:29 <joelteon> > rnf [undefined]
13:05:32 <lambdabot>   Not in scope: `rnf'
13:05:35 <joelteon> oh right
13:05:47 <dmwit> kuribas: The advantage of using DeepSeq is that you don't have to write any code.
13:06:49 <dmwit> kuribas: I'm going to have much more fun reading "head $!! xs" than I am reading "foldr seq () xs `seq` head xs".
13:07:06 <dmwit> or whatever
13:07:09 * elliott is inherently suspicious of doing foldr seq () on a list repeatedly
13:09:29 <kuribas> dmwit: "let list = [1..4] in list deepSeq list" is still much uglier than just [1..4].
13:09:54 <edwardk> i never did package up my little Once hack for deepseq'ing
13:10:17 <dmwit> list `deepseq` list looks like you don't know what you want out of your code.
13:10:20 <edwardk> deepseq tends to go through and force a lot of stuff you know is already forced
13:10:27 <dmwit> That is a smell if I've ever smelt one.
13:10:41 <c_wraith> it's not actually useless, though, unlike x `seq` x
13:10:55 <dmwit> I know.
13:10:59 <monoidal> kuribas: force x = x `deepseq` x
13:11:01 <kuribas> dmwit: I want all my list elements evaluated together.
13:11:09 <d3lxa> dmwit: I didn't had any answer expect yours, thx, I'll look at it now
13:11:10 <merijn> kuribas: Why?
13:11:10 <ReinH> kuribas: right, which is why you wouldn't write that
13:11:20 <kuribas> merijn: For performance.
13:11:22 <ReinH> you would think rationally about what your strictness requirements actually are
13:11:25 <c_wraith> Still, I've never been tempted to write x `deepseq` x.  I always have some bigger context it fits in.
13:11:41 <c_wraith> and yeah, the bigger context usually means "don't use deepseq"
13:11:47 <ReinH> kuribas: making things strict does not automatically make things faster
13:11:53 <ReinH> in fact it's often the opposite
13:12:09 <ReinH> deepSeq will often evaluate a lot of things you don't need to evaluate
13:12:37 <dmwit> edwardk: Does your hack involve unsafe*?
13:12:39 <ion> kuribas: You said you know you always have four elements. Why not make a data type of your own? You can also add strictness annotations to the data constructor if you really need it to behave like that.
13:12:45 <ReinH> if we had some idea of why you think you need the list to be evaluated to NF maybe we could offer you suggestions
13:12:46 <edwardk> no, its just a cute trick
13:12:53 <ReinH> rather than offering you different ways to evaluate the list to NF
13:13:07 <dmwit> Okay. Then I don't have a guess about what it does.
13:13:41 <edwardk> let me write it
13:13:49 <ReinH> why not make a strict data type?
13:13:50 <dmwit> kuribas: How about "join deepseq [1..4]"? =)
13:13:55 <dmwit> kuribas: That's not as ugly, right?
13:14:00 <monoidal> dmwit: force [1..4]
13:14:13 <dmwit> monoidal: Oh, even better.
13:14:17 <dmwit> Yay, I don't have to write code!
13:14:26 <kuribas> ReinH:  http://paste.lisp.org/display/138760
13:14:44 <kuribas> The code doesn't work still.
13:15:00 <ReinH> kuribas: can you be more specific than "doesn't work"?
13:15:02 <dmwit> monoidal: Last time you said it I didn't realize this function was already offered by Control.DeepSeq, sorry.
13:15:04 <edwardk> http://lpaste.net/92527
13:15:13 <kuribas> ReinH: It work in progress :)
13:15:18 <joelteon> :t deepseq
13:15:19 <lambdabot> Not in scope: `deepseq'
13:15:24 <joelteon> welp
13:15:40 <edwardk> dmwit: that captures the 'rnf' as a thunk waiting to happen.
13:15:45 <dmwit> edwardk: nice
13:15:49 <dmwit> I like it a lot.
13:15:58 <edwardk> then when you force it it forces it. if you force it again, nothing happens
13:16:07 <edwardk> if you deepseq a lot this makes a _massive_ difference in performance
13:16:13 <dmwit> Well. Something happens. But the something doesn't involve traversing the whole structure, which is nice.
13:16:43 <monoidal> kuribas: maybe you want the result to be a record, not a list?
13:16:51 <edwardk> i mentioned it to jaffacake at one point like 4 years back, but he kinda shrugged, so i don't think it really registered
13:17:17 <dmwit> Perhaps he believes that you shouldn't deepseq a lot. =)
13:17:35 <edwardk> he was complaining about deepseq costs at the time =P
13:17:57 <ReinH> kuribas: you want your bezier derivatives to be strict. Why not make a strict sum type for them?
13:18:24 <ReinH> maybe even unpack it
13:19:01 <kuribas> ReinH: Actually, I don't care so much about the bezier derivatives.  I want the temporary calculations to be strict, so I avoid having them in memory for no reason.
13:19:17 <kuribas> ReinH: And so they could be put in registers by the compiler.
13:19:26 <ReinH> kuribas: the bezier derivatives are the 4 element array you've been talking about the whole time
13:19:34 <ReinH> then yes, you want them to be strict and unpacked
13:19:38 <ReinH> http://www.haskell.org/haskellwiki/Performance/Data_types#Unpacking_strict_fields
13:19:48 <kuribas> ReinH: No, the result array is what I was talking about.
13:20:01 <kuribas> The 4 element array was just an example.
13:21:22 <kuribas> ReinH: I don't want the temporary calculations lying around as thunks in memory.
13:22:14 <kuribas> ReinH: They need to be evaluated anyway.  I am not sure if ghc is smart enough to figure that out.
13:23:54 <kuribas> Doesn't it make sense?
13:24:57 <S_J> so ML is not a purely functional language?
13:25:27 <hiptobecubic> here we go....
13:25:46 <dmwit> ask in an ML channel lol
13:25:48 <companion_cube> no it isn't
13:26:50 <ReinH> kuribas: your ability to reason about strictness is not being improved by the String Typing (everything is a list) in that snippet.
13:26:56 <d3lxa> dmwit: wow, it works =) thx, now I have to understand how you did that, seems you used the monad
13:27:32 <dmwit> d3lxa: IAMA Haskell hacker, AMA
13:27:37 <kuribas> ReinH: The list is convenient, because I can use (zipWith (+)) to sum the elements.
13:28:40 <kuribas> ReinH: So you suggest I make a separate type, and define a "add" operation on it?
13:29:58 <d3lxa> dmwit: the 'return' comes from the monadic Result, right?
13:30:21 <kuribas> ReinH: It just seems more cumbersome for no significant benefit.
13:30:30 <kuribas> ReinH: That I can see anyway.
13:30:46 <S_J> Just 5 >>= \r -> return $  r * 5
13:30:58 <dmwit> d3lxa: Hm. Parser is a Monad.
13:31:05 <S_J> > Just 5 >>= return . (* 5)
13:31:06 <lambdabot>   Just 25
13:31:06 <dmwit> d3lxa: I'm not sure if that answers your question or not.
13:31:31 <d3lxa> dmwit: yes it does =)
13:31:31 <dmwit> > (*5) <$> Just 5
13:31:32 <lambdabot>   Just 25
13:32:05 <ReinH> kuribas: I'm just saying that you're doing everything in terms of lazy, ad hoc data structures (lists) and then wondering why you're having problems making things as strict as you want them to be
13:32:27 <Okasu> > (*) <$> Just 5 <*> Just 5
13:32:28 <lambdabot>   Just 25
13:32:32 <arkeet> :t (=<<) . (return .)
13:32:33 <lambdabot> Monad m => (a -> b) -> m a -> m b
13:32:59 <kuribas> > liftM (* 5) $ Just 5
13:33:00 <lambdabot>   Just 25
13:34:41 <arkeet> > Just 25
13:34:42 <lambdabot>   Just 25
13:34:47 <S_J> @src (<$>)
13:34:47 <lambdabot> f <$> a = fmap f a
13:34:48 <mroman> @type (<$>)
13:34:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:35:02 <dyn> hi
13:35:15 <d3lxa> > fmap (5*) $ Just 5
13:35:16 <lambdabot>   Just 25
13:35:24 <dyn> I got stuck with http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html, with HandsomeSoup
13:35:25 <mroman> > (<$>) (const 1) (Just 2)
13:35:27 <lambdabot>   Just 1
13:35:28 <S_J> why obfuscate wtih <$>? fmap is clearer
13:35:36 <S_J> > fmap (*5) $ Just 5
13:35:37 <lambdabot>   Just 25
13:35:46 <arkeet> > mapped *~ 5 $ Just 5
13:35:49 <lambdabot>   Just 25
13:35:51 <mroman> > (<$>) (*2) (Just 2)
13:35:52 <lambdabot>   Just 4
13:35:54 <mroman> neat.
13:36:00 <dyn> I get "No instance for (Show (IOSLA (XIOState s0) a0 (Data.Tree.NTree.TypeDefs.NTree XNode)))" - can anyone drag me out of this please?
13:36:14 <mroman> looks like a shorthand version for fmap
13:36:18 <arkeet> it is.
13:36:32 <d3lxa> (<$>) = `fmap`, right?
13:36:38 <haasn> > 1 <$ Just 2
13:36:39 <lambdabot>   Just 1
13:36:41 <arkeet> no, (<$>) = fmap
13:36:54 <d3lxa> ok, I mean <$> = fmap, or (<$>) = `fmap`, sorry
13:37:00 <d3lxa> oh again
13:37:03 <haasn> <$> = `fmap`; (<$>) = fmap
13:37:03 <arkeet> no, you mean neither of those things ;)
13:37:14 <haasn> modulo fixity and associativity
13:37:20 <arkeet> > (0$0<$>)
13:37:22 <lambdabot>   The operator `Data.Functor.<$>' [infixl 4] of a section
13:37:22 <lambdabot>      must have lowe...
13:37:23 <d3lxa> sorry, my (very) bad
13:37:35 <arkeet> > (0$0`fmap`)
13:37:36 <lambdabot>   The operator `GHC.Base.fmap' [infixl 9] of a section
13:37:36 <lambdabot>      must have lower p...
13:37:43 <merijn> Yay! It's "resolve the damn cyclic import issue"-time again!
13:38:00 <mroman> I thought haskell can't resolve those?
13:38:26 <mroman> * ghc can't
13:38:55 <merijn> It can't, hence why I need to resolve it
13:39:08 <mroman> which always prevented me from making a nice module structure
13:39:15 <merijn> If GHC actually followed the report I would be fine >.>
13:39:34 <mroman> and prevents you to seperate functions into different modules depending on where they would belong
13:39:44 <mroman> and forces you to squish everything into a single file (:
13:40:02 <mroman> I really, really, really hate that.
13:40:37 <enthropy> dyn: you're missing a runX most likely
13:41:28 <dyn> enthropy: I was sure I brought my invisible coat with me
13:42:26 <dyn> hmmn correct
13:42:51 <dyn> enthropy: thank you
13:42:56 <enthropy> no problem
13:43:22 <ReinH> kuribas: at the very least you might consider Data.Vector instead of Data.List
13:43:44 <ReinH> it's the go to utility belt for numeric haskell imo
13:43:53 <d3lxa> why would anyone use reads where there are read* from Safe, these seem better to me except it's not "builtin", any opinion?
13:44:30 <merijn> d3lxa: Recent GHC's have readMaybe in Text.forgotthismodulename
13:44:39 <arkeet> why use read* from Safe when you have Text.Read
13:44:53 <merijn> Text.Read
13:45:08 <merijn> :t readMaybe
13:45:09 <lambdabot> Read a => String -> Maybe a
13:45:21 <merijn> > readMaybe "3" :: Maybe Char
13:45:27 <lambdabot>   Nothing
13:45:31 <merijn> > readMaybe "3" :: Maybe Int
13:45:35 <lambdabot>   Just 3
13:45:57 <arkeet> > readEither "3" :: Either String Char
13:45:58 <lambdabot>   Not in scope: `readEither'
13:45:58 <lambdabot>  Perhaps you meant one of these:
13:45:58 <lambdabot>    `readLitChar...
13:46:04 <kuribas> ReinH: Ok, but I doubt it will make a big difference.
13:46:05 <arkeet> ...
13:46:10 <edwardk> dmwit: https://www.fpcomplete.com/user/edwardk/snippets/once
13:46:10 <arkeet> @let import Text.Read
13:46:11 <lambdabot>  Defined.
13:46:12 <arkeet> > readEither "3" :: Either String Char
13:46:13 <lambdabot>   Left "Prelude.read: no parse"
13:46:23 <edwardk> dmwit: that puts the code somewhere once and for all so i can forget about it
13:46:25 <arkeet> does it ever say anything but no parse
13:46:44 <d3lxa> > say "anything but no parse"
13:46:45 <lambdabot>   Not in scope: `say'
13:46:51 <edwardk> arkeet: what if you get an ambiguous parse?
13:47:10 <arkeet> tbh I've never seen one.
13:47:14 <d3lxa> edwardk: http://stackoverflow.com/questions/8689560/in-what-scenarios-does-haskells-reads-return-more-than-one-list-item
13:47:30 <d3lxa> "None of the standard instances do so" << thus…
13:47:45 <edwardk> d3lxa: yes, but you could write one
13:48:04 <edwardk> if you have two alternatives that start with the same lexP call
13:49:44 <dmwit> > read "Just (3" :: Maybe Int
13:49:45 <lambdabot>   *Exception: Prelude.read: no parse
13:49:47 <kuribas> ReinH: In this case.  In many other cases I agree.
13:50:09 <dmwit> arkeet: Probably not. Where would the message come from?
13:50:21 <dmwit> edwardk: =)
13:51:18 <edwardk> dmwit: i'm trying to collect more of these little vignettes that i tend to go through on channel as posts =)
13:51:31 <dmwit> good idea
13:51:40 <ashnur> hi. may i ask something here which isn't strngly related to haskell? it should be a simple math/vector algebra algorithm but i am failing to find it :-S
13:51:58 <arkeet> what is it?
13:52:09 <dmwit> ?let data Ambiguous = Ambiguous; instance Read Ambiguous where reads _ = [(Ambiguous, ""), (Ambiguous, "")]
13:52:09 <lambdabot>  .L.hs:153:9: `reads' is not a (visible) method of class `Read'
13:52:32 <edwardk> you want readsPrec, i think reads is top level
13:52:41 <ashnur> i am trying to find out if a point is on a line in n-dimension
13:52:49 <dmwit> ?let data Ambiguous = Ambiguous; instance Read Ambiguous where readsPrec _ _ = [(Ambiguous, ""), (Ambiguous, "")]
13:52:50 <lambdabot>  Defined.
13:52:58 <dmwit> > read "" :: Ambiguous
13:52:59 <lambdabot>   No instance for (GHC.Show.Show L.Ambiguous)
13:52:59 <lambdabot>    arising from a use of `M1428...
13:53:02 <dmwit> ...of course
13:53:14 <dmwit> ?let deriving instance Show Ambiguous
13:53:14 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
13:53:19 <monoidal> > seq (read "" :: Ambiguous) ()
13:53:22 <lambdabot>   *Exception: Prelude.read: ambiguous parse
13:53:27 <dmwit> hooray
13:53:40 <dmwit> arkeet: There you go, then!
13:53:46 <arkeet> that's cheating =(
13:53:55 <edwardk> ashnur: take two points on your line, subtract the second from the first, now you have a vector. the target point is on the line if you can add some scalar multiple of that vector to the first pointt and get to your target point.
13:53:58 <ReinH> kuribas: at the very least you can make use of unboxed vectors and fusion
13:54:04 <ReinH> which might be quite helpful
13:54:12 <ReinH> and you might find that you don't need as much strictness as you thought you did
13:54:19 <edwardk> ashnur: if you work projectively you just need your point to be a linear combination of the two inputs
13:54:28 <ReinH> kuribas: Roman is better at optimizing things than we are :)
13:54:30 <roconnor> @type some
13:54:31 <lambdabot> Alternative f => f a -> f [a]
13:55:00 <roconnor> ReinH: some is some sort of kleene star like operation for Alternative in a way that I don't formally understand.
13:55:02 <arkeet> but because of rounding and stuff, I wouldn't want to check whether a point was *exactly* on the line.
13:55:15 <edwardk> ashnur: and take into account what arkeet said
13:55:15 <ReinH> roconnor: come again?
13:55:20 <ashnur> edwardk: i have to think on your second line a bit. i use the parametric approach as storing cartesian equations of lines in n dimension would be quite complicated :P
13:55:20 <ReinH> ah
13:55:27 <dmwit> arkeet: According to the Report, these two messages are the only two messages read will give you.
13:55:36 <arkeet> dmwit: I see that.
13:55:49 <ashnur> arkeet: I use bigintegers and rational points only
13:55:56 <arkeet> alright.
13:56:34 <roconnor> which reminds me that we need to find more uses for Alternative in the lens library.
13:56:42 <ReinH> edwardk: question for you about Data.Vector. I sometimes find that I want (x:xs) style pattern matching over vectors. Does this mean I'm doing something wrong?
13:56:50 <edwardk> ReinH: yes
13:56:53 <arkeet> ashnur: but yes, an easy way to see if a point P was on line AB, test whether AP is parallel to AB.
13:56:54 <ReinH> I thought so :)
13:56:56 <dmwit> ashnur: What is the data you have that defines your line?
13:56:58 <edwardk> ReinH: it means you are a bad person
13:57:02 <ReinH> hey now
13:57:11 <ReinH> ... I will think on what you have said.
13:57:17 <ashnur> dmwit: a point and an associated vector
13:57:35 <ashnur> so yeah, i think arkeet just said what i was missing.
13:57:40 <edwardk> ReinH: in practice though unconsing a vector isn't stupidly expensive, consing is
13:57:54 <ReinH> edwardk: if it's part of a recursion scheme I should probably be using a fold or such, right?
13:58:01 <ashnur> thanks
13:58:07 <donri> ReinH: maybe you want Seq
13:58:14 <ReinH> donri: do I
13:58:21 <donri> ReinH: i don't know :)
13:58:26 <edwardk> ReinH: yes, fold, map, spindle, mutilate
13:58:27 <ReinH> donri: :D
13:58:32 <ReinH> spindle?? huh
13:58:52 <haasn> recursion schemes are known for causing lots of mutilation
13:58:55 <edwardk> i need to add a spindle combinator to my folds package
13:59:01 <edwardk> mutilate sounds good too
13:59:48 <ReinH> edwardk: I can't find these combinators :(
13:59:49 <donri> ReinH: but presumably you could use headM with a view pattern for vector to imitate (x:xs)
14:00:04 <ReinH> donri: right, but I feel like that's a smell :)
14:00:17 <edwardk> @google fold, spindle, mutilate
14:00:17 <lambdabot> http://idioms.thefreedictionary.com/fold,+spindle,+or+mutilate
14:00:18 <lambdabot> Title: fold, spindle, or mutilate - Idioms - by the Free Dictionary, Thesaurus and E...
14:01:01 <ReinH> edwardk: oh it's a joke.
14:01:03 <ReinH> ha.
14:01:58 <edwardk> ReinH: i guess it is an age thing =)
14:02:57 <sclv_> http://design.osu.edu/carlson/history/PDFs/lubar-hollerith.pdf
14:04:52 <ReinH> edwardk: probably :)
14:05:06 <ReinH> edwardk: should I get off your lawn now?
14:05:16 <sclv_> cf the clip "o come all ye mindless" from here too: http://tapewrecks.blogspot.com/2012/12/oh-come-all-ye-mindless-conceptless-and.html
14:05:26 <sclv_> surprised i can't find it on youtube or something
14:07:50 <edwardk> sclv_: great link
14:21:20 <earthy> wow, great stuff.
14:41:54 <kuribas> ReinH: When I have time, I will test the performance of my code with different optimizations (unboxed vectors, etc...).
14:42:04 <Letchik> Is "isSeparator" the same predicate which is used in "words"?
14:42:29 <kuribas> ReinH: Right now, I want to finish the package and make it correct first :)
14:42:30 <donri> words uses isSpace, i think
14:43:40 <donri> yep
14:43:54 <Letchik> donri: ok, thanks
14:44:17 <Eduard_Munteanu> How do you quote typeclass names in TH? Does  ''  work?
14:44:35 <donri> Eduard_Munteanu: yes
14:44:57 <Eduard_Munteanu> Cool, thanks.
14:45:12 <donri> if you want a Name, [t||] if you want a Q Type
14:47:11 <pavonia> Why is it called Q, btw?
14:50:08 <donri> pavonia: quasi
14:50:21 <pavonia> ah
14:50:29 <Letchik> Does anybody here have experience with HEAT - The Haskell      Educational Advancement Tool?
14:50:39 <monoidal> pavonia: in the original paper, it's called quotation monad
14:50:56 <monoidal> I don't think it comes from Quasi, which is a separate class
14:51:13 <geekosaur> predates quasiquotes by quite some time, no?
14:51:47 <monoidal> the paper introduced both. AFAIR quasiquotes were implemented later. http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf
14:51:52 <monoidal> (6.10?)
14:52:10 <acowley> Q is for quotation
14:52:23 <acowley> Missed opportunity for a ST:TNG reference, but you can't win them all
14:53:00 <acowley> It's in section 6.1 of that paper, btw
14:53:25 <donri> the Q continuation monad
14:54:40 <ReinH> awwww where did roconnor go? :(
14:54:54 <ReinH> the Q continuum monad
15:05:59 <d3lxa> what can I do when I need a hidden class in a TH? cannot import, then what?
15:13:54 <donri> d3lxa: i think you can simply fully qualify it?
15:14:00 <donri> or what do you mean hidden
15:14:18 <donri> duno if you can get to non-exported classes
15:17:03 <ReinH> edwardk: holy crap I just realized something that might be useful to me
15:18:34 <ReinH> edwardk: if Grid !!! Coord does what you expect and Distances = Grid (Grid Distance) then Store (distances!!!) coord gives me the distances from any point in the grid
15:18:45 <ReinH> I'm not sure if I can do anything interesting with extend or duplicate though
15:19:28 <ReinH> well, experiment does
15:19:47 <ReinH> hmm, maybe
15:22:08 <d3lxa> donri: I mean like Data.Aeson.Types.Class.ToJSON but it won't
15:22:14 <enthropy> d3lxa: you might have to write the full name including the package
15:22:42 <Letchik> In the function "catMaybes" what is cat supposed to mean?
15:22:53 <enthropy> d3lxa: with makeNameG
15:22:54 <ParahSailin> concat
15:22:55 <monoidal> concatenate
15:23:07 <Letchik> ok thanks
15:23:16 <ReinH> edwardk: actually, shouldn't I be able to construct the "dijkstra map" for every point in the grid comonadically in a way that exploits sharing? (http://roguebasin.roguelikedevelopment.org/index.php?title=The_Incredible_Power_of_Dijkstra_Maps)
15:23:24 <arkeet> dogEithers
15:24:21 <ReinH> I will investigate
15:25:15 <d3lxa> enthropy: okay, but I don't see anywhere makeNameG, is there a typo?
15:25:26 <enthropy> it's in Language.Haskell.TH.Syntax
15:25:52 <enthropy> oh it's actually mkNameG
15:28:38 <ReinH> edwardk: yeah, you can construct a dijkstra map using cellular automata, can't you? Then you just need to find a comonadic fixed point?
15:28:50 <acowley> ReinH: distance fields are pretty expensive to compute
15:29:08 <d3lxa> enthropy: thank you
15:29:33 <ReinH> acowley: ah, but you only need to calculate them once
15:29:35 <acowley> ReinH: So I'd be wary of losing much performance in any machinery
15:29:54 <acowley> ReinH: That entirely depends on what you're doing. The game example suggests recomputing them every turn.
15:30:55 <ReinH> acowley: you can compute one for each level, assuming the level's reachability is immutable
15:31:14 <ReinH> on each turn you get the distance map for your current position
15:31:37 <S_J> so TDD. how much in advance are you supposed to write the test? i find this hard. i have a rough design but not down to functions. Ill usually just work it as I go. am I unprofessional?
15:31:53 <acowley> ReinH: Sure, but as that page you linked suggests, you may want to use these for dynamic items
15:32:08 <koala_man> S_J: you're not supposed to finish the tests before starting the code
15:32:19 <ReinH> acowley: right, but you can get a LOT of use out of the distance map of all single targets
15:32:27 <ReinH> acowley: you can use it for simple pathfinding, AI calculations, etc
15:32:38 <ReinH> the map of maps, that is
15:32:44 <acowley> ReinH: Sure! I use distance fields every day, so I'm certainly no trying to downplay the usefulness.
15:32:48 <ReinH> acowley: :D
15:32:54 <S_J> koala_man: really? i thought that was the whole point?
15:32:59 <ReinH> acowley: happen to have a haskell implementation lying around?
15:33:05 <ReinH> acowley: seems like repa would be good for this as well?
15:33:05 <jfischoff> S_J: start high level, at the application level.
15:33:08 <acowley> ReinH: http://hackage.haskell.org/package/DistanceTransform
15:33:20 <ReinH> acowley: aaand of course there's a package if you know what the thing is called :D
15:33:49 <S_J> How is it that the most critical software is written in the most dangerous language, C?
15:33:51 <acowley> ReinH: I'm not sure if that will meet your needs. My needs when writing it were rather particular.
15:34:04 <koala_man> S_J: you write some tests, then you write the code to make them pass. then repeat. what you're thinking of is more like automated acceptance testing
15:34:14 <ReinH> acowley: well it's certainly a good place to start
15:34:30 <S_J> How is it that the most critical software is written in the most dangerous language, C? I'm not saying C can be replaced totally but for example for medical device development, surely you could use a better language.
15:34:30 <ReinH> acowley: and I'm more interested in learning the algo than using a library, so if it isn't perfect that just means I'll learn more ;)
15:34:32 <acowley> ReinH: Absolutely! I also have an OpenCL version somewhere around here
15:34:56 <acowley> I should find a home for the OpenCL version as it's simpler than the Haskell one
15:35:05 <ReinH> acowley: I'm optimizing for acquiring learnings here ;)
15:35:26 <acowley> I optimize for hipsterity.
15:36:17 <ReinH> :D
15:39:10 <Cale> S_J: Are you sure it's true that most medical device software is written in C?
15:39:45 <arkeet> nah, they use fortran
15:40:37 <fredmorcos> hi, I'd like to write a small example parser, to better understand Functor, Applicative, Monoid, Monad and MonadPlus, what really escapes me is the type variable.
15:40:43 * hackagebot snappy-framing 0.1.0 - Snappy Framing Format in Haskell  http://hackage.haskell.org/package/snappy-framing-0.1.0 (KimAltintop)
15:40:44 <S_J> Cale: well they even try to avoid using software sometimes. What else would they use? I know a lot is written in C.
15:40:49 <Cale> fredmorcos: Which type variable?
15:40:51 <S_J> really, fortran?
15:40:52 <acowley> That C is often output from things like Simulink
15:41:17 <fredmorcos> As an example, I would have data ParserState = Running { ... } | Warning { ... } | Error { ... }
15:41:18 <ReinH> acowley: if I'm calculating a distance map for each point in a space, is there a way to do it that lets me share results across different points?
15:41:37 <ReinH> acowley: like if I've already calculated some of the map for a nearby point, couldn't that inform the calculation for the current point?
15:41:47 <fredmorcos> I think Running and Warning should probably be merged, and warning accumulated into a record
15:41:49 <acowley> ReinH: The fast algorithms are a bit complicated and loopy in nature. They do exactly that, but I don't know how to express it functionally
15:42:14 <fredmorcos> also, the records would be, line, col, result
15:42:19 <acowley> ReinH: They basically walk along each dimension of your space in each direction looking for the minimum distance
15:42:34 <fredmorcos> I don't really see how ParserState can be a Functor as an example.
15:42:36 <ReinH> acowley: right, I get that
15:42:40 <Cale> fredmorcos: It can't.
15:42:56 <ReinH> acowley: but what I want is to take, say, a roguelike map, and make a distance map *for each square* in the map
15:43:00 <ReinH> so a map of distance maps
15:43:02 <acowley> ReinH: Well, minimum squared distance, typically. So they're using the same intuition you are, but there's a sequential aspect to the computation
15:43:13 <koala_man> ReinH: so floyd-warshall?
15:43:29 <ReinH> koala_man: yes, but I can do some specific optimizations based on the structure of the graph
15:43:39 <Cale> fredmorcos: Perhaps it would help to see the implementation of a simple monadic parser library. Give me one sec so I can push a quick patch for work, and I'll give you a little tutorial on how to set up a very simple parsing library.
15:43:43 <fredmorcos> Cale, yes, but being a Functor is a prerequisite to being a Monad, and I think >>= and error would be really useful here
15:43:47 <ReinH> koala_man: basically fmap distanceMap level
15:44:04 <ReinH> but I want to do it in a way that maximizes sharing between different cells in the level
15:44:19 <Cale> fredmorcos: Basically, your type of computations must have a type parameter which is the type of results being produced.
15:44:48 <Cale> fredmorcos: e.g. a value of type Parser Integer would be a parser which consumes some of the input in order to produce an Integer.
15:44:58 <fredmorcos> Cale, wow, that would be really nice... but if you have something ready or know of a tutorial I could go through, I wouldn't want to waste your time
15:45:19 <arkeet> fredmorcos: he enjoys doing this.
15:45:20 <fredmorcos> Cale, OK, in my case then, something like [String] (list of tokens)
15:45:30 <fredmorcos> wow, okay :)
15:45:30 <ReinH> acowley: for roguelikes you can use the taxicab metric as well
15:45:55 <ReinH> and doing so should allow for a lot of sharing
15:46:25 <acowley> ReinH: The paper I cite in the package documentation does several metrics, iirc
15:46:32 <ReinH> acowley: cool :)
15:47:08 <acowley> Yeah, s/taxicab/Manhattan
15:47:33 <arkeet> L^1 metric
15:47:33 <Cale> fredmorcos: Okay, so come to #haskell-overflow and we'll go over something. I like to explain this in a customised way so that you can ask questions :)
15:47:38 <ReinH> acowley: right, same difference iirc
15:47:43 <Cale> (Though I really ought to write it down somewhere :)
15:48:25 <ReinH> acowley: if I am computing distances from x and reach x', a square that I've already generated a (partial) distance map for
15:48:48 <Cale> fredmorcos: still here? :)
15:48:56 <fredmorcos> Cale, yep :)
15:49:00 <ReinH> acowley: I can merge the two maps using min (d(x), d(x) + d(x') where d is distance
15:49:10 <ReinH> s/merge/zip
15:49:41 <ReinH> I should be able to use that to obtain some speedups in a parallelized iterative deepening algo, yes?
15:51:00 <acowley> ReinH: Something like that, yes. Check out the paper to see how to do it efficiently. It's really easy to write something slow.
15:51:04 <ReinH> zipWith (\x y -> min x (x+y)
15:51:09 <ReinH> acowley: awesome :D
15:51:42 <ReinH> that zipWith min is the essence of the Floyd algorithm, in fact
15:51:57 <ReinH> (is it faster to get there directly or through some intermediate node k?)
15:52:27 <ReinH> so maybe I just walt floyd ;)
15:52:31 <ReinH> *want
15:54:56 <ReinH> (Oh, I was thinking of L^inf.)
15:57:32 <ReinH> acowley: oh, this algorithm is brilliant
15:57:49 <acowley> ReinH: Yes!
15:58:18 <ReinH> the separate row and column scans
15:58:51 <acowley> ReinH: Do let me know if you'd want the OpenCL version so I have some motivation for pulling it out of its current home
15:59:07 <ReinH> acowley: I don't need it but if you want to then I can pretend that I do :D
16:03:33 <ReinH> acowley: wait, I can compute all distance maps over a grid in O(n^2) compared to Floyd's O(n^3), can't I?
16:03:52 <acowley> ReinH: Yeah
16:03:52 <ReinH> and probably with better average case performance if I can get some sharing to happen across maps
16:03:59 <ReinH> brilliant
16:04:38 <ReinH> possibly n log n best case? that's crazy.
16:05:06 <ReinH> best case being a grid where the all squares are reachable
16:06:18 <ReinH> acowley: I suspect there might be a way to lift this row and column scanning to operate across the map of maps but I am nowhere near smart enough to figure out how :)
16:06:51 <ReinH> but I'll certainly take O(n^2) even without speedups across maps
16:06:57 <acowley> ReinH: It is very scalable. My Haskell version supports any dimensional maps
16:07:08 <acowley> ReinH: Though I've only used it for 2D and 3D
16:07:22 <ReinH> acowley: hmm, could I compact the map of maps into a 3d map and then just scan that?
16:07:41 <ReinH> no
16:07:57 <ReinH> obviously not
16:08:20 <ReinH> acowley: I should figure this out and write a paper though
16:08:31 <ReinH> step 1: be smart enough to figure this out :(
16:08:32 <acowley> ReinH: Bear in mind that as you start adding Ds, you sweep the legs on the performance story
16:08:45 <ReinH> acowley: yeah, but I only need 2 Ds
16:08:51 <ReinH> so that's fine
16:08:56 <acowley> ReinH: It's actually kind of hard to find a venue for this stuff, ime
16:09:10 <ReinH> I actually don't care that much about publishing papers ;)
16:10:23 <ReinH> I am going to try to unpack the algorithm and see if I can repack it to work on maps of maps in a way that gives me some sharing though
16:11:25 <acowley> ReinH: I don't really follow your idea of map-of-maps. What are you computing the distance to? The distance to a particular origin point for each map?
16:11:26 <Yaniel> noobish question, is there a simple way to generate a list of floats with a step other than 1.0?
16:12:16 <startling> > iterate (+ 1.5) 0
16:12:17 <lambdabot>   [0.0,1.5,3.0,4.5,6.0,7.5,9.0,10.5,12.0,13.5,15.0,16.5,18.0,19.5,21.0,22.5,2...
16:12:30 <jfischoff> > [0.0, 0.1 .. 1.0]
16:12:31 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
16:12:56 <ReinH> acowley: sorry
16:13:01 <arkeet> > tail [0.0,0.1..1.0]
16:13:02 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
16:13:05 <arkeet> > last [0.0,0.1..1.0]
16:13:06 <lambdabot>   1.0
16:13:08 <ReinH> acowley: for each point in the space, compute its distance map
16:13:19 <arkeet> > last [0.0,0.01..1.0]
16:13:20 <lambdabot>   1.0000000000000007
16:13:29 <arkeet> > [0.0,0.3..1.0]
16:13:30 <jfischoff> heh
16:13:30 <lambdabot>   [0.0,0.3,0.6,0.8999999999999999]
16:13:35 <arkeet> hm
16:14:20 <ReinH> acowley: setting the distance to that space to zero to designate it as the "target" or "origin"
16:15:05 <startling> Yaniel, are you content with those answers to your question?
16:15:11 <Yaniel> yes, thanks
16:15:19 <startling> Yaniel: cool. :)
16:16:00 <ReinH> acowley: you can use this for, e.g., pathfinding: get the distance map for your destination and start walking "downwards" from your current location to its minimum neighbor
16:16:09 <ReinH> super useful for roguelike AI
16:16:23 <ReinH> since you're doing a lot of things in relation to the distance to the player
16:16:47 <ReinH> ranged monsters can attempt to keep their distance on the map at some fixed number, etc
16:17:02 <acowley> ReinH: Yeah, potential field navigation is another keyword for you. But the thing is that you don't typically need or want a map-of-maps
16:17:14 <ReinH> acowley: I want a lazy map of maps :D
16:17:23 <acowley> ReinH: If you are moving to a goal, you want a distance field to that goal, then you can use that map wherever you are.
16:17:31 <edwardk> ReinH: you should have acowley help you design your rogue-like. you could have some scary path finding logic based on real camera data taken from kinects convoluted with bubbles to extrude it so your monsters will know if they can fit through the tunnel to kill you
16:17:45 <ReinH> acowley: right, but a lazy map of maps will let me compute distances to any goal square and reuse them later
16:17:46 <acowley> ReinH: You only want the map-of-maps if you are expecting to navigate to, or away from, an entity at every possible map location.
16:17:59 <ReinH> acowley: this is not an unusual expectation for a roguelike game :)
16:18:04 <acowley> edwardk: That's not a bad idea....
16:18:07 <edwardk> acowley: we got the lookup thing to stop failing
16:18:26 <ReinH> edwardk: lmao awesome :)
16:18:35 <ReinH> I am not doing anything near the complexity of what acowley is doing :)
16:19:04 <startling> I should work on my roguelike thing again.
16:19:10 <ReinH> acowley: but a Store (distanceMaps!!!) coord gives me a lazy store of distance maps
16:19:12 <acowley> edwardk: Just by widening the window?
16:19:13 <startling> We should have a #haskell roguelike jam
16:19:22 <ReinH> (where !!! is indexing)
16:19:29 <edwardk> acowley: a bit more intelligent than that, but mostly =)
16:19:36 <acowley> edwardk: I've been watching the commits since I didn't have time to work on it myself :(
16:19:36 <edwardk> acowley: its wider in someplaces narrower in others
16:19:52 <edwardk> acowley: just added the chaselev deque that i was working on with ryan newton back in the day
16:19:55 <acowley> edwardk: I will dive into it as soon as I can. I'm still pretty excited by the promise.
16:20:09 <ReinH> well, not indexing into a map of maps, but the function that calculates a given map for a given coord
16:20:11 <edwardk> i updated it to use the optionally packed array format, so now we can do workstealing in data structures in there
16:20:50 <acowley> Now I'm jealous of what you're working on
16:21:00 <ReinH> acowley: and you could memoize it easily as well
16:21:03 <ReinH> acowley: anyway, thanks for the links!
16:21:33 <acowley> ReinH: The lazy map-of-maps is a good idea, but I'd worry about benefitting from both sharing *and* laziness simultaneously
16:21:47 <ReinH> acowley: well, I'd either get one or the other
16:21:48 <acowley> ReinH: But yeah, I think that paper is great.
16:21:54 <acowley> ReinH: right
16:22:07 <ReinH> if I want to compute when I generate the level, which might not be a bad idea, I would optimize for sharing
16:22:22 <ReinH> if I can actually approach n log n for common maps, that might be feasible
16:22:36 <acowley> I've spent some time trying to build maps of maps for planning for multiple agents. Never really cracked it.
16:22:54 <ReinH> acowley: well I'll let you know when I figure it out
16:22:58 <ReinH> probably later today /s
16:23:17 <acowley> hah
16:23:37 <ReinH> acowley: even without sharing across maps, this still seems like the best solution
16:23:40 <ReinH> so thanks very much
16:23:47 <ReinH> also the algo itself is beautiful
16:23:49 <acowley> ReinH: Yeah, keep me updated on how it goes
16:23:52 <ReinH> kk <3
16:24:26 <k0001> Ghoul_: I was looking at the ircbrowse.net tool and came across this http://ircbrowse.net/browse/haskell?id=16374736&timestamp=1378095261#t1378095261 -- could you elaborate a bit more? I'd like to improve whatever needs to be improved.
16:25:16 <JoergFritsch> I once read about a startup / commercial product that offers sort of an API Manager (like APIGee?) and is based on Haskell / written in Haskell. Does anybody know the name & website of this?
16:31:30 <Ghoul_> k0001: when I tried to use it I found that my transformer stack had to go like 5 deep just for a simple network thing with timeout and error disconnect handling
16:32:13 <Ghoul_> that was mostly because a lot of the functions all wanted to return *different* things to indicate an error and things like that. If they returned the same things the stack would be much smaller and more manageable
16:32:40 <Ralith> why didn't you just wrap them all?
16:32:44 <Ghoul_> also, I got afraid about how using such a large stack would hit on performance so in the end I just didn't bother trying to weave in all the rest of the transformers I needed for my actual application
16:33:04 <Ghoul_> Ralith: I did, and you'd cringe to know what it looks like
16:33:17 <arkeet> ContT :-)
16:33:45 <Ghoul_> haha
16:34:13 <Ralith> Ghoul_: if you did, and if that reolves the need for so many transformers, why did you have so many transformers?
16:34:30 <k0001> Ghoul_: Good points. I agree. I think I've fixed that now. Let me share the docs for you in case you want to check.
16:34:38 <Ghoul_> because I needed timeout, a disconnect error, a network state, an actual state
16:35:00 <Ghoul_> k0001: that would be very good :)
16:38:40 <k0001> Ghoul_: here http://monoid.k0001.org/haskell/pipes-network-0.6.0/html/index.html -- please let me know any thoughts you may have, I'm happy to improve this.
16:38:49 <Ghoul_> thanks, I'll take a look
16:42:49 <jfischoff> is it possible to pipe the result of `ghc -M …` to stdout instead of having it munge a Makefile?
16:42:56 <Ghoul_> k0001: the move to IOError's are well done. It looks much easier to use now :)
16:43:31 <Ghoul_> my only critique is that {from/to}Connect,{from/to}Serve are kind of strange function names
16:46:19 <k0001> Ghoul_: yeah, I picked those for consistency with {from,to}{Socket,Handle}. Previously I had names `serveWrite` and `serveRead`, but I think those are even worse: for one, the idea of `read` in Haskell (as in the `Read` typeclass) is quite different, and then the underlying socket functions are named “recv” and “send”, not “read” and “write”.
16:48:04 <Ghoul_> can't wait till it makes its way to hackage :)
16:49:44 <ReinH> acowley: quick q: did you implement the manhattan and cherbyshev metrics for DistanceTransform? Doesn't look like it? Should be easy?
16:50:13 <acowley> ReinH: I did not, and yes it should be easy. The problem is that the code is abysmal.
16:50:24 <k0001> Ghoul_: hopefully in the next days!! For what is worth, I've alrady pushed to Hackage the underlying `network-simple`, whose most significant change is that it embraces `MonadIO` and `MonadCatch`.
16:50:50 <k0001> Ghoul_: thanks for the feedback!
16:50:55 <Ghoul_> cool! :) no problem
16:51:18 <ReinH> acowley: heh :D
16:54:25 <duairc> asdf
16:55:36 <SrPx> I'm getting the following problem trying to install idris: idris-0.9.9 depends on llvm-general-3.3.5.0 which failed to install. Any idea how I can install it?
16:56:20 <geekosaur> find out why it failed. (often it's because you're missing the non-haskell stuff related to LLVM)
16:56:37 <SrPx> geekosaur: how!?
16:57:01 <geekosaur> if it's not in your scrollback then cabal install -v2 llvm-general-3.3.5.0
16:58:52 <arkeet> :t foldr mplus mzero
16:58:52 <lambdabot> MonadPlus m => [m a] -> m a
16:59:00 <arkeet> :t foldr (mplus . return) mzero
16:59:01 <lambdabot> MonadPlus m => [a] -> m a
17:01:41 <ReinH> acowley: yeah, the distance metric is threaded through a bit :)
17:03:17 <ReinH> acowley: I'll try to figure out how to factor the metric out so it can be passed
17:03:52 <acowley> ReinH: My earlier versions were more like that. But it become a kind of performance death march. I figured nobody would ever want to look at the code.
17:03:53 <_justjust> [f 1 | f <- [g,h], not $ null $ f 1] is f x called twice for every f?
17:04:10 <ReinH> acowley: heh :) they do if they want to use a different metric ;)
17:04:28 <ReinH> acowley: I can use euclidean but cherbyshev prints out so prettily ;)
17:04:48 <Ghoul_> k0001: is attoparsec or binary faster, for serializing my network packets?
17:04:53 <acowley> ReinH: I *really* didn't think anyone would want anything other than Euclidean distance
17:05:07 <acowley> ReinH: So you're proving me wrong on every question I answered when packaging the code up :P
17:05:23 <ReinH> acowley: :D :D
17:05:29 <arkeet> Ghoul_: attoparsec doesn't serialize.
17:05:38 <arkeet> it's a parser.
17:06:14 <Ghoul_> okay, that answers the question, never used it before
17:06:57 <Ghoul_> it does boast itself as a 'parser suitable for network traffic' though
17:07:10 <arkeet> yes, it's a parser
17:07:23 <ReinH> acowley: why not use a sum type to represent the available metrics and define methods for each of the actual metric calculation functions you need?
17:07:50 <arkeet> Ghoul_: but it's probably overkill for a simple binary protocol. one of the attoparsec examples is HTTP
17:07:59 <arkeet> which is something you probably don't want to do with binary ;)
17:08:21 <ReinH> genericdt :: Metric :: [Int] -> va -> vb; edt = genericdt Euclidean
17:08:44 <acowley> ReinH: No reason at all. I bet you could make the code much more flexible without killing performance. It will just take some TLC.
17:08:53 <ReinH> or if you want to get crazy, use a type class for ad hoc metrics ;)
17:08:58 <ReinH> acowley: well maybe I'll mess with it :D
17:09:10 <Ghoul_> heh, okay
17:09:24 <acowley> ReinH: That would be great! I hate the way that code turned out. I spent far too much effort trying to making nested loops look Haskelly.
17:09:32 <acowley> ReinH: In the end, it just made things confusing.
17:09:38 <ReinH> acowley: well it is relevant to my interests :)
17:10:00 <acowley> ReinH: You did see that it's on github, right? Collaboration is more than welcome.
17:10:09 <ReinH> acowley: yep already cloned :D
17:10:24 <k0001> Ghoul_: I don't really know how Attoparsec compares against Binary regarding parsing speed, but I guess anyway the answer depends mostly on the kind of data that you will be (de)serializing.
17:10:40 <acowley> ReinH: As it stands, it does 2D faster than Matlab's bwdist in some casual testing. The OpenCL version (on the CPU) is faster again.
17:10:49 <Ghoul_> Tekmo said a while back that binary is "too slow" for pipes
17:11:11 <ReinH> acowley: gdt m dims v = V.map (metric m) $ sedit m dims v ... and so on :)
17:11:22 <ReinH> shouldn't impose any perf penalties, metric can obv be inlined
17:11:30 <acowley> Yeah absolutely
17:11:33 <acowley> We need to add a benchmark
17:11:36 <ReinH> gdt :: HasMetric m =>
17:11:39 <ReinH> seems goo d:D
17:11:44 <acowley> I found doing 2D distance transforms on edge images to be fun
17:12:03 <acowley> I have some Lena benchmark code somewhere, but that pulls OpenCV in as a dependency, so is stupidly big.
17:12:08 <ReinH> hah
17:12:15 <acowley> It would be good to have a lighter weight cabal benchmark driver
17:12:25 <ReinH> acowley: let's take edwardk's recent SoH stuff and make blurryMandlebrot ;)
17:12:35 <acowley> Not a bad idea!
17:12:46 <ReinH> could even turn it into a SoH post itself :D
17:12:57 <acowley> Though the fractal generation probably impacts the benchmark :P
17:13:20 <ReinH> acowley: well we really just need a corpus of images
17:13:30 <ReinH> and to demarcate the benchmark on the part that we actually care about
17:13:55 <ReinH> we'll call it I'm In Ur Mandelbrotz Blurring Ur Pixelz
17:14:00 <ReinH> and it will be awesome
17:14:02 <acowley> ReinH: Let's not get carried away. I think ||corpus|| = 1 would be okay
17:14:06 <acowley> hahaha
17:14:08 <ReinH> acowley: ok :D
17:14:41 <ReinH> acowley: I mean, replicate 1000 (replicate 1000 0) is going to have different performance than a random image, right
17:14:42 <SrPx> http://pastebin.com/4RaXqdbh does anyone know why cabal fails to install idris?
17:14:44 <ReinH> it might be nice to test a few cases
17:14:46 <mauke> The paste 4RaXqdbh has been copied to http://lpaste.net/92530
17:15:05 <acowley> ReinH: Yeah, hence Lena.
17:15:10 <ReinH> acowley: ah righto
17:15:22 <k0001> Ghoul_: what he probably meant was that serialization could be way faster if you skip ByteString alltogether and write directly to a Handle. He mentioned that to me before, and he's right. I have no idea about how to solve that with pipes yet, but I'll look into it later.
17:15:42 <ReinH> acowley: well I'm going to have a bit of fun making this work for my roguelike ;)
17:15:50 <Ghoul_> yeah, he gave me the low level stuff to do that and that's what I've been working with right now
17:16:02 <Ghoul_> but then I ran into a laziness issue with IO and pipes is looking more appealing again
17:17:25 <k0001> Ghoul_: I think it should be feasible to write a `Consumer` that writes directly to a `Handle`, instead of a `Producer` or `Pipe` that just outputs a `ByteString` with the serializes bytes.
17:19:16 <Ghoul_> I played around with that low level pointer stuff a bit if you wanna see
17:19:35 <Ghoul_> although its mostly just changing the stuff gabriel gave me to work on my own hand rolled "Stream" type
17:19:37 <k0001> Ghoul_: however, if I recall correctly, I think the “slowness” he talked about is in the `binary` package itself. So I don't know, I really should look into it later.
17:19:58 <k0001> Ghoul_: yeah, that would be handy!
17:20:35 <Ghoul_> https://github.com/kvanberendonck/burrito/blob/master/src/Burrito/Network/Socket/Serialize.hs and https://github.com/kvanberendonck/burrito/blob/master/src/Burrito/Network/Socket.hs
17:20:54 <k0001> Ghoul_: oh, burritos!
17:21:16 <Ghoul_> `Socket` is really the closest thing to pipes, since it exposes a framework for requesting more stuff
17:21:32 <Ghoul_> thats where the similarity ends though. have fun heh :P
17:35:35 <Targen> What’s the nicest tool for conversions between XML and Haskell records?  I’m looking for something in the spirit of aeson’s ToJSON/FromJSON and the nice ways to avoid boilerplate either through TH or GHC.Generics, but for XML.
17:36:25 <Targen> xml-lens makes the boilerplate almost pleasant, but it’d be even nicer if it wasn’t there at all :)
17:38:44 <ReinH> acowley: my DistanceMaps comonad is quite nice :D
17:39:24 <acowley> ReinH: That's great! Got any pretty pictures or code?
17:39:41 * edwardk appears to have made a new comonad fanatic
17:40:03 <ReinH> acowley: yep, one sec :)
17:41:11 * hackagebot swish 0.9.0.6 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.6 (DouglasBurke)
18:03:17 <Ghoul_> whats a way to fully evaluate a list without laziness?
18:03:34 <Ghoul_> length doesn't work because it doesn't evaluate the thing its holding.
18:03:40 <_oio_> i am really bad at recursion could someone give me a hand at this
18:03:48 <startling> Ghoul_: why do you think you want to?
18:04:21 <startling> _oio_, what's the question?
18:04:27 <Ghoul_> because I wrote a silly benchmark to troll a C++ guy that haskell can do this thing 10,000 times in the time he can do his thing like 3 times
18:04:41 <Ghoul_> and now he wants to have a paralell benchmark, so I'm using parMap but getting beaten by laziness
18:04:54 <startling> Ghoul_, don't use a list
18:05:25 <startling> @hackage deepseq -- this is the other option
18:05:26 <lambdabot> http://hackage.haskell.org/package/deepseq -- this is the other option
18:05:54 <Ghoul_> ah, cheers!
18:05:58 <tabemann> don't you want to deepseq your parallel computations anyways, so the computation stays in its spark?
18:06:39 <tabemann> i.e. the strategy rdeepseq
18:07:21 <_oio_> that
18:08:19 <Ghoul_> I get a type error when I change the parMap strategy to rdeepseq and im not sure whu
18:08:32 <_oio_> this http://lpaste.net/92531
18:08:48 <_oio_> startling:
18:09:45 * applicative is finding _oio_ a little mysterious
18:09:54 <tabemann> Ghoul: you want parMap rdeepseq
18:10:07 <applicative> oh wait, i missed the paste
18:10:08 <tabemann> Prelude Control.Parallel.Strategies> :t parMap rdeepseq
18:10:08 <tabemann> parMap rdeepseq :: NFData b => (a -> b) -> [a] -> [b]
18:11:26 <latermuse> is there an irc channel for the scotty project?
18:12:03 <ystael> _oio_: i can't quite tell what you're trying to do, but it seems odd that toTree has guard clauses for the cases nu1 == 0, nu1 == n, nu1 > n, but none for the case 0 < nu1 < n
18:12:10 <ystael> is that intentional?
18:13:03 <_oio_> ystael: i am tryng to figure out .. just cant get my head around it
18:13:49 <tabemann> _oio_: the different guard cases in toTree have different types
18:14:35 <ReinH> acowley: here's a quick example https://gist.github.com/reinh/bbf7104730d2348db0e5
18:15:02 <tabemann> _oio_: lines 12 and 14 return a Node; line 13 returns a partial function
18:16:12 <_oio_> tabemann: know been fidiling around .... i think i dont know how
18:16:18 <applicative> _oio_: i'm not following yet, but you dont need to define 'nd', the Node constructor is already ND
18:17:33 <applicative> _oio_: like so http://lpaste.net/92535
18:19:06 <haasn> elliott: is there a copy of the current/live lambdabot source I can get anywhere and just magically run? I want access to the latest and greatest, with all lens features
18:19:30 <haasn> or do I still have to write my own L.hs
18:19:36 <_oio_> for this http://lpaste.net/92536
18:19:40 <pmade> Is there any reason that `send' in distributed-process would silently terminate the current Process?
18:19:52 <_oio_> applicattive:
18:22:44 <ReinH> You know what's awesome? fmap is awesome.
18:23:10 <ReinH> you know what else is awesome? DeriveFunctor
18:23:23 <shachaf> DeriveFunctor: "not so awesome"
18:23:24 <arkeet> DeriveTraversable is awesomer.
18:23:42 <shachaf> data List a = Nil | Cons a (List a) deriving Functor
18:24:04 <arkeet> what about it?
18:24:13 <shachaf> Guess what the complexity of fmap is.
18:24:18 <arkeet> uh
18:24:21 <joelteon> quadratic
18:24:29 <monoidal> shachaf: wasn't that fixed in head?
18:24:36 <shachaf> In HEAD, yes.
18:24:54 <arkeet> what is it?
18:25:01 <shachaf> What joelteon said.
18:25:04 <arkeet> why
18:25:05 <shachaf> Well, if you force the whole thing.
18:25:15 <shachaf> @google derived instances inefficient ghc
18:25:17 <lambdabot> http://ghc.haskell.org/trac/ghc/ticket/7436
18:25:18 <ReinH> shachaf: I'm using it on a nonrecursive data type so neener neener :p
18:25:18 <lambdabot> Title: #7436 (Derived Foldable and Traversable instances become extremely inefficien...
18:25:23 <shachaf> arkeet: ☝
18:25:41 <ReinH> arkeet: it is, but I don't need Traversable (yet)
18:25:56 <arkeet> ah.
18:26:09 <ReinH> I might later though
18:27:08 <shachaf> arkeet: Isn't that awful?
18:28:00 <arkeet> yes
18:28:05 <arkeet> and it's not fixed in 7.6.3, I take it.
18:28:10 <monoidal> compiling "data Link a = Link !(Link a)" in HEAD with -O hangs. does anyone remember if there was a ticket for this?
18:28:24 <arkeet> compiler hangs?
18:28:26 <monoidal> yes
18:28:31 <ReinH> I probably shouldn't expect the derived fmap for data Foo a = Foo (Vector a) to be as efficient as Vector.map, should I? :)
18:28:33 <arkeet> heh
18:29:02 <arkeet> ReinH: why not, if fmap = Vector.map for Vector?
18:29:05 <arkeet> you'd lose fusion I guess.
18:29:15 <ReinH> arkeet: it's the fusion I'm worried about, but mayb enot
18:29:21 <ion> monoidal: What is that type useful for, btw?
18:29:38 <ReinH> arkeet: Vector optimizations are still magical for me so I don't know what to expect
18:29:50 <monoidal> ion: it's a minified version of a bug
18:30:41 <ion> monoidal: ah
18:47:41 <startling> it's Fix Identity
18:47:42 <startling> duh
18:54:52 <haasn> edwardk: do we have an operator version of traverseOf_ ?
18:54:58 <haasn> ie %%~ but ignoring the result
18:55:49 <startling> :t (<$)
18:55:50 <lambdabot> Functor f => a -> f b -> f a
18:55:57 <startling> :t (() <$)
18:55:58 <lambdabot> Functor f => f b -> f ()
18:56:12 <arkeet> :t traverseOf_
18:57:15 <startling> haasn: I think traverseOf_ f g a is just () <$ f g a semantically
18:57:33 <startling> maybe "f (void . g) a"
18:57:43 <arkeet> startling: no.
18:57:46 <arkeet> traverseOf_ works with a Fold
18:57:53 <haasn> yeah
18:57:55 <haasn> it's more general
18:58:02 <startling> oh, interesting
18:58:03 <haasn> I'm using it with getters
18:58:11 <arkeet> :t traverse_
18:58:12 <lambdabot>     Not in scope: `traverse_'
18:58:12 <lambdabot>     Perhaps you meant one of these:
18:58:12 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
18:58:14 <arkeet> :t F.traverse_
18:58:15 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
18:58:17 <startling> :t folding
18:58:28 <tel> What's the syntax for LANGUAGE pragmas in literate files
18:58:44 <tel> I'm going to try this whole literate thing out :)
18:58:55 <arkeet> > {-# blah #-}, I'm pretty sure.
18:58:56 <lambdabot>   <hint>:1:13: parse error on input `,'
18:59:17 <haasn> I don't see why literate haskell would affect the way language pragmas work
18:59:37 <startling> :t \f a -> () <$ folding f a
18:59:38 <lambdabot> (Applicative g, Foldable f, Contravariant g) => (s -> f a) -> (a -> g b) -> s -> ()
18:59:53 <startling> :t folding
19:00:32 <startling> I guess that doesn't work in the Profunctor-wised general case
19:02:37 <ReinH> acowley: I am really confused right now.
19:02:53 <tel> arkeet ohh, they need to be birdtracked too.. that's fairly obvious in hindsight, oomph.
19:02:59 <acowley> ReinH: I am partially here, what's up?
19:02:59 <tel> thanks!
19:03:36 <ReinH> acowley: in the tests, you create a vector initialized to all 1's and then calculate the distance transform
19:03:49 <ReinH> acowley: but as far as I can tell, the elements of the vector don't matter
19:03:52 <acowley> ReinH: I probably have a backwards sense of "occupied"
19:04:05 <ReinH> it doesn't change the result at all if I put in 100 or 2^32 or whatever
19:04:30 <acowley> ReinH: I don't set one element to zero?
19:04:37 <ReinH> acowley: you set one element to 0
19:04:48 <ReinH> but it seems to assume that all the distances are 1?
19:05:09 <ReinH> am I misunderstanding what this is supposed to do?
19:05:21 <acowley> ReinH: I think it matters here https://github.com/acowley/DistanceTransform/blob/master/src/DistanceTransform/Euclidean.hs#L29
19:05:25 <ReinH> how do I say "this element is unreachable"?
19:05:42 <ReinH> oh. huh.
19:05:58 <acowley> So, zero marks your sources or your sinks, depending on your perspective
19:06:02 <acowley> The use of Ints is an abuse of types
19:06:02 <ReinH> so the vector is full of 0's and any Int that is not 0
19:06:08 <ReinH> right, that's what I'm realizing
19:06:17 <ReinH> so there's no way to say "this square is unreachable"
19:07:10 <acowley> If you wanted to compute distance from walls, or something like that, you'd mark walls as zeros
19:07:44 <acowley> And then you'd be left with a map that gives you the distance to the nearest wall for every cell
19:07:49 <ReinH> ok, so this is a "distances from x" where it assumes that all nodes are reachable from all neighbors
19:08:14 <ReinH> Which I can't use. But that's ok. I just didn't understand what it does.
19:08:28 <acowley> It's only using adjacency for neighbors
19:08:36 <acowley> if you have intervening walls, that will come out in the distance field
19:09:41 <ReinH> but I can't modify the adjacency information
19:09:52 <pmade> I'm not sure how to get around this warning: No explicit method or default declaration for `put'
19:09:59 <ReinH> it's assumed that every node can reach its neighbors
19:10:11 <pmade> The code compiles but put/get don't do anything
19:10:24 <ReinH> what I need to be able to do is say "these nodes have no in-edges", i.e., are walls
19:11:15 <ReinH> it seems like distance transforms are not going to be of use for that case
19:11:52 <ReinH> s/nodes/vertices
19:11:54 <startling> pmade, define "put"?
19:12:38 <acowley> ReinH: You can use potential functions like these to navigate environments with walls.
19:13:24 <ReinH> acowley: I guess I should keep reading the paper :)
19:13:34 <acowley> ReinH: It is more complicated
19:13:38 <acowley> sorry I'm splitting my attention here
19:13:46 <ReinH> acowley: no worries :)
19:13:54 <pmade> startling: well, it looks like I was using an older version of Data.Binary and that might have been causing my problems.
19:14:55 <startling> oh.
19:15:48 <acowley> ReinH: Okay, so the way you'd typically do this is to take a function that drives you away from walls, and then combine it with a function that drives you towards your goal.
19:16:03 <acowley> ReinH: If you want provable convergence and stability, you usually have to say something about the kinds of environments you can deal with.
19:16:14 <enthropy> are -XScopedTypeVariables not composable?
19:16:20 <ReinH> acowley: I see
19:16:29 <arkeet> enthropy: ??
19:16:34 <acowley> ReinH: In this case, the way that page you linked earlier was using things was to drive agents to, or away from, certain locations
19:16:41 <ReinH> acowley: right
19:16:48 <acowley> ReinH: For computing shortest paths, though, you're right
19:16:54 <enthropy> if I have a     f :: forall a b c d e. C a b c d e => ...; f =  (1 :: e)
19:17:06 <acowley> ReinH: But you can see the deep connection between what your build with a distance transform and the heap you maintain for A*
19:17:13 <ReinH> acowley: yes.
19:17:16 <acowley> You can look at things like D* for maintaining that search state
19:17:18 <enthropy> then I can't really fix the type variable `e' later on
19:17:30 <arkeet> what do you mean by fix?
19:18:41 <enthropy> maybe this example has the essential bit reduced out of it
19:19:16 <lpaste> enthropy pasted “scopedtypevariables woes” at http://lpaste.net/92537
19:20:03 <acowley> ReinH: You want to use this to cache partial path length computations?
19:20:52 <enthropy> arkeet: if I inline the definition of runConfig' I get the version on line 22
19:21:11 <ReinH> acowley: I just want to build what this page describes as a "Dijksta Map": a graph annotated with the minimum distance from each point to some set of goals
19:21:12 <acowley> The usual way to speedup general path planning is to do hierarchical planning, with a roadmap graph between regions of space. You navigate yourself onto the road, then it's a quick graph search to the exit nearest your destination
19:21:17 <ReinH> specifically the case for a single goal
19:21:31 <ReinH> acowley: I am hoping for something with better asymptotics than Floyd's but I can use that as well
19:21:46 <arkeet> enthropy: well that's to be expected, no?
19:21:48 <ReinH> (Floyd's would only work for one goal)
19:22:00 <arkeet> what if you provide a type annotation for X.defaultConfig?
19:22:09 <ReinH> acowley: I should be able to use a tropical *-semiring approach to get the dijkstra maps
19:22:10 * arkeet hasn't fully parsed the code
19:22:22 <enthropy> arkeet: that one is monomorphic
19:22:22 <acowley> Hm, maybe I didn't read the page thoroughly enough
19:23:28 <ReinH> acowley: their algorithm is a pretty simple breadth first walk
19:23:54 <arkeet> enthropy: I don't see why you'd expect the (l ~ ...) constraint to be magically propagated to runCOnfig'.
19:24:05 <arkeet> if that's what you're looking for.
19:24:17 <acowley> ReinH: I guess I'd try modifying the Meijster code to deal with impassible cells
19:24:27 <arkeet> I'm confused.
19:24:56 <acowley> ReinH: I think you could probably do it fairly cleverly, but I am not clever at this point of the night
19:25:02 <ReinH> acowley: :)
19:26:46 <acowley> ReinH: You can see the use of an "infinity" value, so I'd guess we could use that to indicate impassible cells
19:26:50 <lpaste> enthropy annotated “scopedtypevariables woes” with “scopedtypevariables woes (annotation)” at http://lpaste.net/92537#a92538
19:27:03 <ReinH> acowley: right, exactly
19:27:32 <acowley> ReinH: I guess the thing to do is just seed walls with that infinity value
19:27:39 <acowley> seed source/sink with 0
19:27:46 <acowley> Hmm, that's not quite right
19:28:09 <acowley> Or is it
19:28:18 <ReinH> acowley: I can use data Weight = Infinity | Weight Int, for instance
19:28:21 <ReinH> acowley: that *should* be right
19:28:36 <acowley> Yeah, for practical reasons we use a finite representation of infinity
19:28:40 <acowley> :P
19:28:41 <ReinH> you can also represent infinity as any number >= ||V||
19:28:46 <acowley> Exactly
19:28:51 <ReinH> which I tried ;)
19:29:14 <acowley> ReinH: The problem is in phase1
19:29:19 <acowley> p is the input array
19:29:22 <acowley> and we only look for zeros
19:29:22 <ReinH> acowley: basically I expected edt to take the value of each element as the weight to travel to that element from any neighbor :)
19:29:29 <acowley> v is the output array that we initialize with infinities
19:29:32 <ReinH> acowley: I see that. I will mess with it :)
19:30:06 <acowley> Except we don't memset v with infinity because we don't need to
19:30:15 <acowley> we put an infinity on the left, then drag it across to the right
19:30:34 <acowley> Maybe it's just a matter of strategically placed infinities
19:31:05 <acowley> Okay, I'm off for the night, but I'm hopeful that could be a way to do things
19:31:11 <ReinH> acowley: thanks :D
19:31:23 <acowley> I'll check in again tomorrow, and we should try to come up with a test case to make sure we're on the same page
19:31:38 <adnap> Is it possbile to "read" a value of type (forall a. a -> a)?
19:33:01 <enthropy> instance Read (a -> a) where read _ = id -- not what you're asking for I think
19:33:37 <geekosaur> I don;t think so
19:34:03 <geekosaur> (a) who gets to specify the type? (b) function types can't be read even without the forall
19:34:28 <geekosaur> (at least, not without a lot of work probably involving ghc-api or something)
19:34:57 <enthropy> geekosaur: hint isn't that much work
19:36:44 <adnap> Um...
19:37:44 <adnap> What if you have a phantom type, like Foo a b = Foo b. Can you read a value of type forall a. Foo a Integer?
19:38:03 <enthropy> actually you have to implement reads
19:38:32 <enthropy> or maybe it's readsPrec
19:39:51 <enthropy> instance (b ~ a, Read a) => Read (b -> a) where readsPrec _ str = map (\(a,b) -> (const a, b)) (reads str) -- adnap another option
19:39:56 <startling> adnap, I think so. you can write switch :: Foo a b -> Foo a' b and then switch . readMonomorphicFoo
19:40:03 <startling> if nothing else
19:40:14 <enthropy> lets you write things like    read "2" 1 ===> 2
19:40:26 * adnap is confused
19:41:01 <adnap> I'll just post the code I'm having trouble with
19:42:18 <lpaste> adnap pasted “forall problem” at http://lpaste.net/92539
19:42:33 <ReinH> edwardk: I have a new project :D
19:43:44 <adnap> Oh, I forgot to remove an old line...
19:44:18 <lpaste> adnap annotated “forall problem” with “forall problem (annotation)” at http://lpaste.net/92539#a92541
19:49:22 <adnap> Nevermind
19:54:18 <edwardk> ReinH: oh?
20:00:08 <adnap> :t unless
20:00:09 <lambdabot> Monad m => Bool -> m () -> m ()
20:24:21 <smith_> The answer is probably no, but given a data type with multiple data constructors, is there any way to write a function that takes one of the constructors and a value of the type and tells whether or not that value comes from that constructor?
20:24:33 <smith_> i.e. :: (f -> a) -> a -> Bool
20:24:59 <smith_> assuming all the constructors take a single argument of the same type
20:27:09 <enthropy> smith_: there's a class Data.Data.Data that ghc can derive, which has some methods that can tell you which constructor you have
20:27:39 <startling> smith_: one of the many problems is that your (f -> a) is not necessarily a constructor.
20:27:49 <enthropy> so you'd have something like   eqCon :: Data a => (f -> a) -> a -> Bool
20:28:14 <smith_> enthropy: that, yes.
20:28:30 <startling> Data.Data uses Constr to skirt around this issue.
20:28:45 <smith_> Looking at Data.Data now. Thanks!
20:29:05 <enthropy>  eqCon a b = on (==) toConstr (a undefined) b
20:32:09 <flebron> is there a built-in (i.e. base) way to compress something like [Integer]? as in, compress to a string, write to source code, decompress at runtime
20:33:11 <enthropy> flebron: you'll have to look beyond base I think
20:35:57 <startling> flebron, haskell code is sometimes a very efficient compressed representation of data.
20:36:45 <flebron> in this case it's for a programming competition, the data is list_i = (\prod_{k = 0}^i k!) `mod` p, p a prime
20:37:12 <flebron> the more i have the better, i'm only storing one out of every ten in the input range, due to source code limitations
20:37:21 <flebron> (but i suspect this is terribly boring :))
20:56:31 * hackagebot scotty-blaze 0.1.3 - blaze-html integration for Scotty  http://hackage.haskell.org/package/scotty-blaze-0.1.3 (WilliamCasarin)
20:57:16 <startling> Some time ago johnw mentioned an upcoming Haskell meetup in Chicago. I haven't found any corroboration for this on the wider internet and I fear I may have missed it. DOes anyone know?
20:58:47 <shachaf> There is https://groups.google.com/forum/#!forum/haskell-chicago
20:59:20 <shachaf> Something about Sep 14?
21:00:26 <startling> I think the mention was around then, and it went into my "distant future" planning bucket, so that seems wrong.
21:00:29 <startling> But I don't know.
21:05:50 <shachaf> chicagohaskell.com may be relevant also.
21:06:22 <startling> I can't find anything there but it may be because I do not have a G+ account.
21:06:32 * hackagebot henet 1.3.9.3 - Bindings and high level interface for to ENet v1.3.9  http://hackage.haskell.org/package/henet-1.3.9.3 (JohnEricson)
21:06:43 <shachaf> Well, there's at least a list of people there.
21:06:55 * thoughtpolice is thinking he should try to start a Haskell meetup
21:07:18 <shachaf> thoughtpolice: Can you start it here in the bay area?
21:07:51 <dibblego> I recommend not having a meetup that is language-specific e.g. "functional programming"
21:07:57 <shachaf> bahaskell hasn't happened for months.
21:08:25 <sclv> i'm planning to try to have some 'how to have a good meetup' discussion at icfp
21:08:39 <sclv> but the main answer is 'have a few people willing to really work to make it happen'
21:09:05 <sclv> like most things in the world
21:09:36 <dibblego> bfpg.org has 451 members, with about 50 arriving each month, in a city of a little over 2 million
21:12:04 <Cirdec> What would you call this type:? (Monad f) => f (a f) -> f (b f)
21:12:13 <Fuuzetsu> (Monad f) => f (a f) -> f (b f)
21:13:49 <sclv> a and b are of kind (* -> *) -> * ?
21:13:55 <Cirdec> The best name I can come up with for it is Constructor (for b), but it's not quite right.
21:14:01 <Cirdec> sclv: yes
21:14:04 <shachaf> Cirdec: That's an unusual type. What's a concrete instantiation?
21:14:53 <sclv> does it work with f (a h) -> f (b h) ?
21:14:59 <sclv> or does it need f == h ?
21:15:17 <Cirdec> shachaf: I don't have any one-two line examples.
21:15:25 <Cirdec> sclv: f == h
21:15:48 <shachaf> Cirdec: Well, can you say what types a/b might be in some specific case?
21:16:23 <sclv> a and b are higher functors of a sort
21:19:36 <Cirdec> shachaf: Sure. Let's say a is something like "data Input f = Input { someOtherThing :: f (SomeOtherThing f), someString:: f String }". b is something like "data Class f = Class { height :: f Int, someThing :: f (SomeOtherThing f)}"
21:23:19 <Cirdec> shachaf: And an interesting something might be: constructClassFromInput input = return Class { height = input >>= someString >>= (return . length), someThing = input >>= someOtherThing }
21:24:01 <Kelet> Hello, I'm trying to figure out what this means. Behavior a = Time -> a. It's basically saying a behavior maps time to a value continuously (FRP). What I don't get is what does the 'Behavior a' represent?
21:24:10 <Cirdec> The as and bs of (* -> *) -> * describe  data structures, but have no idea how the data structures are connected together.
21:24:20 <Kelet> I'm more used to seing a format like Behavior: Time -> a (I don't understand what the 'a' after behavior represents really)
21:25:06 <Cirdec> (Monad f) => f (a f) -> f (b f) is a function from one data structure to another, that has no idea how the data is hooked together or how the function is going to be run.
21:26:18 <vlitomsk> Hello
21:27:05 <scp> isn't f (* -> *)?
21:27:28 <shachaf> f :: * -> *. But a :: (* -> *) -> *
21:28:07 <Cirdec> scp: Exactly. A simple example would be Maybe.
21:28:18 <vlitomsk> http://lpaste.net/92545 i'm doing exercises from Real World Haskell now. is this enough 'functional' solution? and why  does lpaste say "Warning: avoid lambda"?
21:28:37 <shachaf> vlitomsk: Click on the hpaste warning.
21:28:38 <vlitomsk> description of exercise:Write a function splitWith that acts similarly to words but takes a predicate and alist of any type, and then splits its input list on every element for which the predicate returns False
21:29:15 <shachaf> Anyway, you should pretty much never write "if null ... then ... else ... (tail ...) ..."
21:29:17 <vlitomsk> shachaf, thanks
21:29:18 <shachaf> Use pattern matching.
21:29:36 <shachaf> Similarly, you can write (x,y) = ... rather than x = fst ...; y = snd ...
21:29:49 <shachaf> (But that's less bad than null/head/tail.)
21:30:30 <enthropy> instead of (\x -> not $ predic x), you can write  (not . predic)
21:30:48 <vlitomsk> enthropy, shachaf thanks
21:30:54 <vlitomsk> but how can i use pattern matching
21:31:00 <vlitomsk> in pre-calculated values?
21:31:16 <Cirdec> Kelet: Its the whole line perhaps "type Behavior a = Time -> a"?
21:31:22 <vlitomsk> like fpart and spart? they are not arguments of function
21:31:52 <Kelet> Cirdec, It's part of a pdf (not a program) on FRP, so it may not be written in Haskell or anything.
21:31:58 <enthropy> vlitomsk: there's a pattern to the left of the =
21:32:00 <Kelet> Although it's mainly about FRP in Haskell
21:33:41 <Cirdec> Kelet: The "a" is a type variable. They are saying, for example, that a "Behavior Int" is a function from "Time" to an Int.
21:34:18 <Kelet> Ah ok, sorry - quite new to Haskell and 'more expressive type systems' too. I get it now.
21:35:03 <Cirdec> Kelet: So then if you see "myHeightInCentimeters :: Behavior Int" it's saying that myHeightInCentimeters varies over time and returns a value that is an Int for each point in time.
21:35:15 <Kelet> thanks
21:36:30 <Haecceity> Hey. Is anyone here available to answer a question for a bit of a newbie to Haskell?
21:36:46 <Haecceity> (Hoping I'm asking through a proper channel :( )
21:36:47 <Fuuzetsu> @where justask
21:36:47 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
21:37:20 <BMeph_> vlitomsk: You should write, "if (xs == []) == True..."! (Only, don't please!)
21:38:58 <BMeph_> Fuuzetsu++
21:38:58 <vlitomsk> enthropy, BMeph_ is it better solution? i don't know how to write different usage of pattern matching http://lpaste.net/92548
21:39:25 <BMeph_> Fuuzetsu: Even if you didn't put it in, you used it, and promptly. Kudos to you, sir! :)
21:40:24 <BMeph_> vlitomsk: Sorry, just yanking your chain there. Don't do that. Ever. Seriously, it makes Baby Jesus cry...or, something. :)
21:40:47 <enthropy> @hackage split
21:40:47 <lambdabot> http://hackage.haskell.org/package/split
21:41:13 <BMeph_> enthropy: Hush, you! >:(
21:41:30 <startling> > fix (== True)
21:41:37 <lambdabot>   mueval-core: Time limit exceeded
21:41:38 <startling> > fix (True ==)
21:41:45 <lambdabot>   mueval-core: Time limit exceeded
21:42:13 <BMeph_> startling: It's still strict, whichever way you write that. ;)
21:42:41 <vlitomsk> BMeph_, you mean Haskell already has solution? but that's only exercise
21:42:49 <startling> I know! It just looked more like the code the second way.
21:44:12 <Cirdec> Oh-oh. I know I'm in trouble now, everything I'm finding that's similar is in packages like "category-extras" or has Edward Kmett's finger prints all over it some other way.
21:44:28 <Haecceity> >_> This is ridiculously long: I wrote a function called calcCostAll, as such:
21:44:28 <Haecceity> calcCostAll :: Float -> Int -> Int -> Float
21:44:28 <Haecceity> calcCostAll x y z = y * z * (calcCostOne x)
21:44:28 <Haecceity> calcCostOne is written as such:
21:44:28 <Haecceity> calcCostOne :: Float -> Float
21:44:29 <Haecceity> calcCostOne x = (5 + (5 * x) + (5 * 0.18)) + (8 + (8*x) + (8*0.18)) + (13 + (13 * x) + (13*0.18))
21:44:30 <Haecceity> This does not work. It returns the error: "Couldn't match expected type 'Float' with actual type 'Int' in the first argument of '(*)', namely 'y' in the first argument of '(*)', namely 'y * z' in the expression: 'y * z * (calcCostOne x)"
21:44:36 <Haecceity> The error goes away when calcCostAll is changed to calcCostAll: Float -> Float -> Float -> Float. I'm not sure what the issue is if a Float, an Int, and an Int are passed.
21:44:39 <Fuuzetsu> @where hpaste
21:44:40 <Haecceity> Oh geez. I didn't know it would show up like that >_>
21:44:40 <lambdabot> http://lpaste.net/new/haskell
21:45:00 <Haecceity> Ack. Sorry. I'm an awful person and I should feel bad.
21:45:06 <Fuuzetsu> I don't think it's viable to only use packages that don't have Edward's fingerprints on them.
21:45:28 <MitchellSalad> hi, is it possible to use runghc to compile and run more than one source file?
21:45:49 <Cirdec> Fuuzetsu: definitely not. The trouble is I'm going to find some better theoretical underpinning for this project and get distracted.
21:45:57 <enthropy> Haecceity: you need an explicit conversion of the Int -> Float
21:46:16 <vlitomsk> is there any better way of pattern matching (see `helper')? http://lpaste.net/92548
21:46:16 <enthropy> say by writing:  calcCostAll x y z = fromIntegral (y * z) * (calcCostOne x)
21:46:22 <BMeph_> vlitomsk: No worries. Just curious, but have you seen the 'take' and 'drop' functions yet? :)
21:46:42 <Haecceity> Enthropy: Does Haskell have issues with multiplying Ints with Floats? Or am I misunderstanding the issue.
21:46:48 <vlitomsk> BMeph_, yes, i used drop in previous version :)
21:46:58 <Haecceity> *?*
21:47:11 <enthropy> Haecceity: right, it doesn't know how to multiply Int with Float
21:47:55 <Haecceity> Enthropy: I suspected that that may have been the issue, but I think I'm probably awful at searching because I couldn't verify that. Thank you -so- much.
21:48:43 <enthropy> you could write a (*) that did the conversion, but that's not the version that comes with ghc
21:49:29 <MitchellSalad> i'm looking for a clean way to compile & run haskell code via readProcess, and runhaskell works great for a single module, but if I have to run module A which imports B, do I have to compile them with GHC, run the binary, and remove the .o and .hi files myself?
21:49:41 <MitchellSalad> (this is for a remote code execution webapp)
21:50:06 <BMeph_> vlitomsk: Oh? Why did you change it? Just curious.... :)
21:50:08 <Haecceity> Enthropy: Are there any guidelines on when to use Ints and Floats and when to mix them? It seems like if the language doesn't come by default with (*) defined to multiply the two, there's probably very good reason.
21:50:27 <startling> Haecceity, it's just that Haskell is strongly typed
21:50:27 <enthropy> MitchellSalad: runghc A.hs will look for a B.hs
21:50:42 <vlitomsk> BMeph_, because that version always add [] to the end of list
21:51:05 <MitchellSalad> enthropy: so it does :) Sorry!
21:51:17 <vlitomsk> http://lpaste.net/92550
21:51:25 <ParaSa1lin> @ty (*) . fromIntegral
21:51:26 <lambdabot> (Integral a, Num b) => a -> b -> b
21:55:31 <enthropy> Haecceity: I don't think you can write a type for a (*) that can take types (Int -> Float -> Float; Float -> Int -> Float), in addition to the ones it currently takes without some language extensions
21:56:09 <enthropy> which probably didn't exist at the time the Num class was first done
21:56:22 <Haecceity> Enthropy: Thank you. I guess I didn't understand the extent to which it was meant when I read that Haskell was strongly typed.
21:56:24 <BMeph_> vlitomsk: Always? Is it possible to change your base case to compensate for that? :)
21:56:39 <enthropy> and also those extensions aren't standardized today either (FunctionalDependencies or TypeFamilies)
21:56:53 <BMeph_> enthropy: Looks like an MPTC thing. :)
21:57:12 <enthropy> yeah, but just MPTCs are pretty unusable
21:58:11 <vlitomsk> BMeph_, it expands to similar construction with lot of 'where' and that 'if null xs ..' http://lpaste.net/92551
22:06:20 <BMeph_> vlitomsk: Can you think of a way to write it that doesn't need the 'if'? ;)
22:07:25 <Cirdec> I don't need a name for the type (Monad f) => f (a f) -> f (b f). It looks much more elegant without wrapping it in a data, and I have absolutely no reason to want to write instances for it.
22:09:40 <vlitomsk> BMeph_, you mean '|' guards?
22:10:17 <k0001> Ghoul_: a quick follow up, in case you care about this: http://monoid.k0001.org/haskell/pipes-binary-0.2.0/html/Pipes-Binary.html
22:10:24 <BMeph_> vlitomsk: No, I do not. ;)
22:11:10 <BMeph_> vlitomsk: That is a big, juicy hint: There is a way to write that recursive part without the 'if'.
22:14:53 <Cirdec> Is there a way to use GHC.Generics in place of Data.Typeable for building type dictionaries?
22:19:53 <vlitomsk> BMeph_, is that a good way to calculate lst=[*GOOD SOLUTION*, []] and do tail lst?
22:20:47 <Cirdec> I guess if you trusted module names and data type names, you could use the data from M1 D to build keys to types.
22:20:49 <vlitomsk> *not tail. init lst
22:23:22 <vlitomsk> BMeph_, is it OK? http://lpaste.net/92552
22:26:14 <edwardk> Cirdec: Data.Typeable will be getting a lot more trustworthy in 7.8, but nothing prevents illegal Generic instances.
22:40:13 <vlitomsk> does anyone know is there any elegant way to write this? splitWith predic xs = init $ splitWith' predic xs
22:40:24 <vlitomsk> without passing arguments
22:41:41 * hackagebot certificate 1.2.9 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.9 (VincentHanquez)
22:43:37 <Ghoul_> k0001: cool! You're rewriting that one too! :D
22:45:17 <Ghoul_> Returning an Either is really handy because it doesn't bloat the transformer stack
22:45:18 <Ghoul_> good job there
22:53:34 <k0001> Ghoul_: you can add or remove the `ErrorT` layer with `errorP` and `runErrorP` from `Pipes.Lift`, but of course it has some computational cost.
22:54:15 <k0001> Ghoul_: I'm upgrading all my pipes-* libraries for the grand Pipes 4 relase.
22:55:03 <Ghoul_> yay
22:56:43 * hackagebot afis 0.1.1 - Anti-forensic Information Splitter  http://hackage.haskell.org/package/afis-0.1.1 (VincentHanquez)
23:03:40 <adnap> In GHCI, if one sets a flag with :set -XFoo, how does one unset it? I tried :unset -XFoo and it doesn't work.
23:03:58 <enthropy> :set -XNoFoo
23:04:09 <Fuuzetsu> for a subset of flags
23:06:42 <adnap> enthropy: Thanks
23:11:43 * hackagebot ghc-mod 2.1.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.1.2 (KazuYamamoto)
23:16:43 * hackagebot cipher-des 0.0.2 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.2 (VincentHanquez)
23:51:39 <shachaf> kosmikus: Did that book/ToC ever get officially announced?
23:51:44 <mm_freak> given a function like this:  f x = … if p x then f (x - 1) else f x …
23:51:49 <mm_freak> does it pay off to use sharing here?
23:52:01 <mm_freak> like:  f x = fix $ \again -> … if p x then f (x - 1) else again …
