01:03:48 <CaptainK> @spell caffene
01:03:48 <lambdabot> caffeine coffee Geffen coffin Carlene
01:28:55 <zhen> hello, how can I install the package to the right directory in Windows? Its always in C:\.... while my haskell is installed in D:\...?
01:29:53 <zhen> using cabal...
01:30:43 <rtb> maybe it's a matter in which directory you start cabal?
01:31:02 <quchen> All the directories Cabal uses are in .cabal/config I think.
01:31:12 <zhen> from cmd
01:31:20 <zhen> and then    cabal install
01:31:28 <quchen> Did you move GHC around after installing it on C:?
01:31:52 <quchen> (I have no idea what the Windows installation process looks like.)
01:32:01 <zhen> I installed it on D:..
01:32:25 <quchen> And where does cabal install the libraries to?
01:33:16 <zhen> I changed the cofig file, but  Warning: C:\Users\zhen\AppData\Roaming\cabal\config: Unrecognized field prefix on line 65
01:33:58 <quchen> You may have to uncomment the $prefix line then.
01:33:58 <zhen> to:            Installing library in C:\Users\zhen\AppData\Roaming\cabal\repa-3.2.3.3\ghc-7.6.3
01:34:56 <zhen> yes, I uncomment the "--"
01:41:25 <zhen> ok.. add  a space before each line, indicating a nested command..
01:41:37 <zhen> thank you quchen~
01:42:26 <quchen> I'm not sure your old libraries still work when you change those directories though.
01:42:39 <quchen> You'll have to try that out. (I never encountered the problem)
01:43:37 <zhen> :)
01:48:57 <aleator> Supposed that you could teach only 5 different haskell datatypes to a beginner, which ones would those be?
01:49:34 <Taneb> (), Bool, Maybe, [], (->)
01:49:46 <Taneb> Maybe not ()
01:50:02 <m3ga> aleator: IO, Maybe, [], Bool
01:50:07 <petapetapeta> What's the best way of testing a lexer, parser and interpreter? Is there a best practice for doing it?
01:51:14 <aleator> Taneb, m3ga: Thanks. Any others near as important in your opinion?
01:51:47 <Taneb> StateT, maybe?
01:51:54 <m3ga> Either might also be worthwhile
01:52:08 <m3ga> StateT seems like a bit of a leap to me
01:52:22 <Taneb> m3ga, it shows you don't need IO to do imperative-style programming
01:52:27 <aleator> Well, StateT is something I plan on teaching 2 months afterwards.
01:52:33 <Taneb> And introduces the concept of monad transformers
01:52:38 <Taneb> Yeah, maybe not for a beginner
01:52:45 <quchen> RWST IO to ease transition from imperative languages.
01:53:07 <Taneb> quchen :(
01:53:20 <aleator> My own list included Data.Map since that seemed to allow writing beginner programs such as wordcount faster
01:53:45 <quchen> Performance shouldn't be a concern when doing your first steps.
01:53:45 <Taneb> Problem is Data.Map is very hard to explain as a not-black-box
01:53:55 <Taneb> Perhaps Tree?
01:53:58 <shachaf> preflex: seen tomejaguar
01:53:58 <preflex>  tomejaguar was last seen on #haskell 2 days, 20 hours, 9 minutes and 51 seconds ago, saying: -fno-code is extremely useful!  (Just thought I'd throw that out there)
01:54:18 <aleator> I don't know if it is a bad idea, but I thought I'd teach IO after introducing monads and just use shims like 'interact' in between.
01:54:49 <opqdonut> I've found teaching IO without teaching monads useful
01:54:53 <Taneb> Or even just use GHCi
01:55:02 <Taneb> But I'm no teacher
01:55:09 <aleator> Taneb: Well, for a beginner it can remain a black box for some time. Also, it makes for a good example later on.
01:55:11 <opqdonut> (of course starting with pure code in ghci)
01:55:29 <Taneb> Heck, Map is still pretty much a black box to me
01:55:42 <quicksilver> the problem with any reasonable way of teaching haskell incrementally is that the error messages will make no sense at all
01:55:55 <quicksilver> so you have to train people to ignore the messages or treat them as a magic code which means something else
01:56:07 <aleator> opqdonut: Do you just introduce do notation and statements without >> and >>=?
01:56:12 <opqdonut> aleator: yeah
01:56:31 <quchen> Anyone got a link to Monochrom's guide to installing GHC?
01:56:53 * shachaf wonders how much smaller Data.Map would be if most of it was written with alterF and traverseWithKey lens-style
01:56:54 <aleator> opqdonut: Tried this earlier, but couldn't figure out how to eliminate the endless confusion between Int and IO Int.
01:57:41 <aleator> shachaf: Or perhaps I should just pick the "beginners first five haskell operators" from Control.Lens ;)
01:57:54 <edwardk> if we were wiling to take the few percent speed hit, it'd be a hell of a lot smaller
01:57:59 <Ghoul_> is there some haskell formatting plugin for vim or something?
01:58:12 <Ghoul_> I'm looking at the ddc source code on hackage and the formatting is superhuman tier
01:59:07 <shachaf> edwardk: I ran a benchmark at one point and got strange results that were probably an artifact of the benchmarking code.
01:59:23 <aleator> quicksilver: True. No language can really be learned sequentially. Which makes teaching them.. interesting.
01:59:25 <shachaf> In a few cases alterF was a bit faster than the manual lookup code.
02:00:08 <shachaf> (And in a most cases a bit slower.)
02:01:54 <opqdonut> aleator: the difference is (almost) the same as between Maybe Int and Int
02:02:01 <opqdonut> aleator: at least that's what I thought
02:03:30 <opqdonut> aleator: IO is a good example of an opaque type operated on with a DSL
02:03:39 <opqdonut> aleator: those pop up in haskell continuously
02:03:48 <aleator> opqdonut: Except that in x <- getLine you don't get an explicit constructor, which is perhaps the source of the confusion I got earlier.
02:04:22 <opqdonut> well <- is new syntax anyway
02:05:24 <opqdonut> I do have to admit that students found the IO exercise set the most difficult one
02:05:24 <aleator> opqdonut: Sure. I just feel at loss at what to say when someone writes x <- "hello" ++ "world"..
02:05:43 <aleator> opqdonut: Which is really a shame, since there is no magick there.
02:05:56 <opqdonut> "what type does ++ produce? is the type IO something?"
02:06:28 <aleator> opqdonut: "but I want x to be a string.."
02:06:49 <opqdonut> "then the thing on the right of the <- needs to be an IO string"
02:07:07 <opqdonut> "if you just want to create a name for an existing value instead of running an action, consider let"
02:07:10 <aleator> I quess there is a reasonable way to teach this early on, but I still argue that it needs some thinking to find.
02:08:04 <opqdonut> IO is a bit ugly, yes. I'm not sure teaching monads first is a way around that ugliness though.
02:08:28 <opqdonut> in any case students need a couple of good concrete examples of monads before they can really grok the abstraction
02:08:38 <aleator> opqdonut: Well, I found it helpful since the things that combine IO actions into more complex IO actions are now explicit.
02:08:49 <opqdonut> right
02:08:53 <opqdonut> :t (>>=)
02:08:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:09:01 <opqdonut> ^ there are three hard things in that type signature
02:09:05 <opqdonut> - type classes
02:09:08 <opqdonut> - type constructors
02:09:18 <opqdonut> - higher order functions
02:09:41 <opqdonut> luckily these things can be taught first, but many haskell tutorials don't bother to
02:10:09 <opqdonut> I found students struggling even with (>>=) specialized to Maybe
02:10:36 <aleator> opqdonut: Also, the fact that >>= is an operator  not helping.
02:10:36 <opqdonut> maybe (>=>) would've been more natural
02:10:40 <opqdonut> right
02:11:10 <opqdonut> yeah I named my specialization >>? which was a bad idea I guess :)
02:11:41 <aleator> I did (<=<) first since it is so close to (.) I thing this was much better than teaching >>= first.
02:11:49 <aleator> thing = think
02:12:41 <aleator> I've got two courses to teach, and the first is pretty much just your above list of difficult things + recursion.
02:13:22 <aleator> Other pretty weird difficulties I've seen is that the syntax and parentheses are really hard for some. I'm still uncertain how to fix that.
02:13:39 <quchen> Is there a name for the phase before alpha, where you code and compile, but never run your program (due to placeholders that make it crash immediately etc.)?
02:13:59 <opqdonut> quchen: I'd call that a draft or outline
02:14:43 <merijn> opqdonut: Actually, I prefer covering IO quite late, just let them use the REPL + show to get feedback
02:15:32 <kloplop321> So, when implementing an instance of something like Data.Default.Class for something that is readable, does the method, which takes no parameters, run the `read "some stuff"` each time? Or is it considered a thunk that is only evaluated once?
02:15:45 <merijn> quchen: epsilon? :D If we consider 1.0 release and 0.0 the absence of program, it's as close to 0 as you can get!
02:16:19 <merijn> kloplop321: Wait, why are you implementing it as "read "some stuff""?
02:16:35 <quchen> merijn: I've been messing around with my pet project for a couple of weeks now, and I'm still in that phase. Epsilon is nice, but note that it's also greater than zero.
02:16:56 <petapetapeta> What's the best way of testing a lexer, parser and interpreter? Is there a best practice for doing it? I'm thinking about generating some test data with quickcheck, but I am unsure about how to approach it
02:16:56 <kloplop321> merijn: I don't know how to represent "2000-01-01 00:00:00 UTC" as a raw value for UTCTime
02:18:06 <edwardk> holy crap. my matrix code worked first time
02:18:17 <merijn> quchen: Well, you have code, so if 0.0 is no code, then you're greater than 0 :)
02:18:51 <merijn> kloplop321: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime
02:18:52 <Taneb> edwardk, congrats
02:19:02 <kloplop321> Yeah, I am looking at that now..
02:19:11 <edwardk> Taneb: takes forever to compile though
02:19:41 <Taneb> What if you use -O0 or whatever the no-optimization flag is
02:20:34 <kloplop321> merijn: after playing around with patterns and the constructor after reading it, in ghci, I get that 51544 is the number I want. Supposedly.
02:21:53 <kloplop321> So, I suppose, merijn, that I can do `UTCTime (ModifiedJulianDay 51544) 0`, though I'd prefer to have my code be meaningful if no inefficiency is brought upon that past the first execution.
02:22:04 <merijn> kloplop321: Altough I'm not sure a Default instance of UTCTime is going to be a good idea, esecially not one for 2000-01-01. You'll run into conflict if anyone else ever defines a Default instance of UTCTime in their library
02:22:43 <kloplop321> Okay, so suppose I just have a local non exported function, is it evaluated once? Since it can be considered a constant? Or what?
02:23:18 <merijn> kloplop321: If you define "startDate :: UTCTime; startDate = read "blah"", then yes, it will be evaluated only once
02:23:51 <kloplop321> So, even if I call `def` on my type, it won't re-execute it?
02:24:09 <kloplop321> that is, I call it a second time.
02:24:50 <kloplop321> I know in ghci, playing with unsafePerformIO to throw a print out on the screen, that it seems to only happen once. But I am not sure about when it is compiled. (I haven't tested there)
02:25:08 <merijn> kloplop321: I'm not sure that'll work the same as a Default instance, because of the polymorphism of def
02:25:29 <merijn> It might end up reading a new everytime
02:26:08 <merijn> I would recommend just defining a constant rather than Default, it 1) avoids any problems with overlapping Default instances and 2) guaranteed to only execute the read once
02:26:39 <kloplop321> Alright. But what about in a def of another thing? Say `def = Blah { someField = read "that special date" }` where Blah someField is of UTCTime
02:26:51 <kloplop321> is the def for that object, which contains that field, only evaluated once?
02:27:46 <merijn> kloplop321: Maybe, it depends on whether GHC will inline the Default typeclass dictionary or not
02:28:20 <kloplop321> lovely.
02:28:38 <kloplop321> Thanks for your help anyway. I'll just leave a comment in on the code to put in its place and things to import in case it comes up later.
02:33:44 <kloplop321> merijn: thanks also, for your advice to not make a Default UTCTime instance.
02:35:04 <elflord> hi all i'm using haskell for some shell scripting. one of the file i'm processing contains spaces in the filename, do i need to quote the spaces manually ?
02:36:00 <elflord> btw: i'm not using Shelly and i wonder if Shelly has features to quote filenames with spaces automatically
02:36:05 <donri> elflord: not unless you're passing the filename to a shell
02:36:16 <kloplop321> Usually you need some better form of delimiting. Perhaps you could use a regular expression if you know the formatting of other things, to parse it out. Though I don't have any haskell specific device for you, elflord
02:37:33 <elflord> say the bash shell command i want to run is: ebook-convert file1.epub . in my haskell program the file1 is a string with spaces
02:38:07 <elflord> when sent to the shell the spaces are not quoted automatically
02:38:10 <donri> elflord: http://hackage.haskell.org/packages/archive/process/1.1.0.2/doc/html/System-Process.html
02:38:27 <donri> elflord: if you use 'proc', you don't need any special quoting. if you use 'shell', you do
02:38:53 <elflord> i've used the function system
02:39:00 <elflord> from system.Cmd
02:39:12 <donri> that's like 'shell'
02:39:12 <mauke> why?
02:39:13 <elflord> ok let me take a look at system process
02:41:34 <edwardk> carter: it works
02:41:36 <donri> elflord: you could easily refactor that to use rawSystem
02:42:09 <donri> elflord: rawSystem "ebook-convert" ["file1.epub", "."]
02:42:49 <elflord> let me check
02:48:24 <donri> elflord: and yes shelly handles this for you. or rather it doesn't involve the shell so it works like rawSystem
02:48:45 <elflord> great
02:49:57 <donri> elflord: basically a shell is an interpreted language that translates to stuff similar to rawSystem, so calling out to the shell is a bit silly unless you have a specific reason to
02:50:30 <donri> elflord: it's a bit like doing web programming in haskell by generating a php program :p
02:50:50 <elflord> that's where Shelly comes in right ?
02:51:29 <elflord> Shelly makes us program in haskell instead of calling Shell command
02:51:31 <elflord> ?
02:52:06 <mauke> what do you mean by "shell command"?
02:52:57 <donri> shelly is just a monad that implements shell-style features
02:53:43 <donri> if you want to write "shell scripts" in haskell it might be nice. if you just need to spawn subprocesses it might be overkill.
02:57:13 <aloiscochard> hey guys, I'm porting some code from scala to haskell, and I'm having problem getting similar performance, what's the approach to optimization? is there something obvious in this code http://lpaste.net/91779 ? thanks!
02:58:35 <kloplop321> it may be helpful, aloiscochard, to provide the scala code as reference too.
02:58:50 <aloiscochard> kloplop321: sure! one sec
02:59:30 <kloplop321> I was going to reference http://www.haskell.org/haskellwiki/Performance/Integers but it seems you're using the right one..
03:00:45 <kloplop321> I am not all too experienced with Haskell, so I can't really give much advice past that. I don't see anything that sticks out to me.
03:02:10 <aloiscochard> here is the scala code (stripped in part) -> http://pastie.org/8229086 /cc kloplop321
03:03:00 <aloiscochard> the haskell implementation is 10 time slower than the scala one (when set was used for the scala version, when using bitset it's even bigger)
03:03:20 <merijn> aloiscochard: Are you compiling with -O2?
03:03:37 <merijn> (and are your libraries compiling with that? >.>)
03:04:25 <aloiscochard> merijn: so I tried this, but to be honest I'm not sure I did it write... I did "cabal-dev build -O2" but maybe I should add teh flag in the '.cabal' file?
03:04:33 <aloiscochard> sorry I'm really a noob with GHC
03:04:52 <merijn> aloiscochard: I would certainly add the flag in .cabal, just so you can be lazy and not type it all the time :)
03:05:09 <aloiscochard> merijn: ok :-) I'll double check this ty!
03:05:19 <aloiscochard> I think used 02 instead of O2
03:05:26 <merijn> aloiscochard: You'll want to use the "GHC-Options" field
03:05:45 <merijn> also, you need to "cabal clean" before recompiling with new options, else GHC won't rebuild
03:05:52 <aloiscochard> ohhh!!!
03:05:58 <supki> aloiscochard: you may want to try IntSet instead of BitSet Int
03:06:01 <aloiscochard> that's very good to know, ty merijn
03:06:05 <supki> for me it's like 10 times faster
03:06:18 <aloiscochard> supki: awesome, I'm pretty sure it's the bottleneck
03:06:37 <aloiscochard> thanks a lot hackers, I'll try all of these :-)
03:07:37 <donri> aloiscochard: and make sure any recursion is tail-recursive, and maybe look at not using lists
03:08:04 <donri> sprinkle some strictness all over
03:08:23 <kloplop321> hehe, you guys work together beautifully to help aloiscochard
03:08:29 <donri> read up on profiling with ghc, why guess when you can have it tell you
03:08:48 <aloiscochard> donri: I'm quite sure all of them are tail-recursive, is there a way to make sure of that in some way? and what's the alternative to list?
03:09:03 <aloiscochard> I tried profiling, but I got a 100% in Main
03:09:06 <donri> aloiscochard: i suck at identifying tail recursion :)
03:09:15 <aloiscochard> donri: hehe :-) all'right
03:10:33 <allsystemsarego> aloiscochard, if you manage to get the desired performance boost, why not write a blog post about the experience and submit it to /r/haskell ?
03:10:35 <donri> aloiscochard: alternatives to list depends on what you need it for... vector is good for arbitrary indexing, set is good for member testing, seq is good for general list purposes
03:11:20 <donri> aloiscochard: a good read is http://book.realworldhaskell.org/read/profiling-and-optimization.html
03:12:58 <aloiscochard> allsystemsarego: great idea! I will for sure! actually depending of the result I might even choose to use haskell for the whole project :-)
03:13:17 <klugez> Adding strictness annotations would be the first thing I'd try. data BitRing = Bitring !(BitSet Int) !Int !Bool
03:13:30 <aloiscochard> donri: cool, I started the book but haven't reached that part
03:14:06 <aloiscochard> klugez: mmm.. interesting, I should read about these stictness annotations, I didn't know it's possible
03:14:08 <klugez> Since I think the recursion in jump is going to build a huge thunk to represent the BitRing while it could just do it strictly in less space.
03:14:48 <donri> plus -funbox-strict-fields or UNPACK pragmas on the Int and Bool (since you might not want the bitset unpacked)
03:14:50 <klugez> And you should *always* compile with -O2 if performance is not irrelevant, because it can make a huge difference.
03:14:52 <aloiscochard> klugez: I see, that make lot of sense ty
03:15:17 <donri> -fllvm is known to help for some numerical programs
03:15:38 <aloiscochard> donri: does that prevent some form of boxing? my coworker told me it might be related to that as well
03:16:32 <quchen> klugez: I don't think O2 is necessary in most cases. -O is fine for testing purposes, -O2 often takes considerably longer to compile.
03:16:35 <donri> aloiscochard: you can only unbox strict fields and it's not done by default
03:17:05 <donri> aloiscochard: oh, misread. yes.
03:17:19 <imperative_progr> Is GHC useful as Haskell's reference implementation?
03:17:36 <klugez> quchen: Well, testing for correctness or something else, yes. But I don't think it's a waste of time to look at performance at anything else than -O2.
03:17:48 <klugez> Err, I *think* it's a waste of time.
03:18:27 <merijn> imperative_progr: GHC implements 99% of the Haskell standard, and the things it doesn't are minor nitpicks, so yes
03:18:32 <quchen> klugez: If you've got the time (or your lib is small) -O2 is fine, yes.
03:18:40 <merijn> imperative_progr: Although, keep in mind GHC also implements many things which are not in the standard
03:18:57 <quchen> klugez: But compare making GHC fully optimized with doing the quick build (which uses only -O in stage 1, and no -O in stage 2 I think)
03:19:32 <merijn> Specifically, the only two deviations from Haskell2010 that I'm aware of is that: 1) GHC doesn't support recursive imports 2) Show and Eq are not superclasses of Num in GHC
03:19:36 <quchen> klugez: I'm just saying "-O2 is not *always* the best way to go". Which may not be related to running numerical code, but I wanted to get it out there anyway. :>
03:19:54 <quchen> merijn: 2) was deliberately broken though, and not just "not implemented"
03:20:00 <merijn> quchen: Sure
03:20:20 <imperative_progr> Is it possible to write real-time strategy games and other real-time update apps in Haskell?
03:20:27 <quchen> Yes.
03:20:37 <merijn> imperative_progr: Yes, but be careful using that term
03:20:50 <donri> @faq Is it possible to write real-time strategy games and other real-time update apps in Haskell?
03:20:51 <lambdabot> The answer is: Yes! Haskell can do that.
03:20:52 <quchen> merijn: The "is it possible" term? :-)
03:21:02 <merijn> imperative_progr: "real time" means a very specific thing in programming, and things like strategy games are "soft realtime" at worst
03:21:10 <merijn> quchen: I'm thinking of "realtime"
03:21:29 <quchen> merijn: Oh, my client filters words that start with "real" to avoid distraction. ;-)
03:22:05 <merijn> imperative_progr: "hard realtime" means "missing a deadline is considered a complete system failure" (think airplane/reactor control software), you most certainly can't do hard realtime in haskell currently
03:22:47 <hpaste> bigstones pasted “precedence in expressions” at http://lpaste.net/91780
03:22:47 <merijn> imperative_progr: "soft realtime" means "missing a deadline/update is *really* annoying, but in the end not a big deal, just some lag" (think audio/video/games/etc), haskell can do *most* soft realtime things currently
03:23:10 <quchen> klugez: Even the GHC manual says "At the moment, -O2 is unlikely to produce better code than -O" - http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
03:23:26 <quchen> klugez: That page also lists which optimizations are turned on only by O2
03:24:01 <udevd> i have a question: when really are the input operations called? when i ask to print out data based on them, or exactly when i did put them in the code?
03:24:07 <imperative_progr> Is functional programming suitable for real-time apps?
03:24:47 <quchen> bigstones: "f a b c" parses as "(((f a) b) c)", so your code snippet calculates "succ max", which is the successor of the max function, which is not defined.
03:24:48 <merijn> udevd: You mean IO input operations?
03:24:52 <udevd> yes
03:25:11 <bigstones> hi all, it's like the second time I use IRC, so ... oh thanks quchen
03:25:30 <merijn> udevd: The only guarantee that you get about "when" is that in "x >>= f" the actions in x happen before f, it doesn't say anything about when
03:26:10 <klugez> quchen: Hmm, interesting. I admit defeat and accept thinking about performance with just -O, then. :)
03:26:20 <udevd> ... i don't get it :D
03:26:36 <udevd> but perhaps because i haven't slept for 20 hours
03:28:15 <merijn> udevd: Haskell doesn't specify anything about when IO is done, it just specifies that the *order* in which it is done follows the one in your code
03:28:27 <udevd> okay
03:28:56 <merijn> udevd: So "do { fooIO; barIO }" doesn't tell you when fooIO or barIO "happen", it just tells you that "*if* barIO happens, fooIO has happened at some point before it"
03:29:13 <udevd> cause my point is that if you'd read like 5 numbers and do nothing with them, then one number and print it out
03:29:27 <udevd> will then the first 5 reads really happen?
03:29:58 <udevd> but if IO are somehow queued then it's okay
03:30:55 <udevd> thanks :)
03:31:13 <bigstones> quchen++
03:31:27 <bigstones> (how does that work?)
03:31:50 <merijn> udevd: Yes, the IO monad guarantees that fooIO happens before barIO, *even* if you throw the result of fooIO away
03:35:44 <bigstones> \help
03:37:01 <exicer> Anyone got suggestions of where I can find good quality code to have a look at ? If it were focused around scraping/general web stuff, that would be a bonus!
03:46:37 <Gracenotes> the idea of monad typeclasses (and transformers, in particular) as dependency injection is interesting
03:47:04 <Gracenotes> I wonder if it's been extended to non-unit testing within Haskell.
03:47:13 <edwardk> apocalisp gave a talk about it in scala
03:47:51 <edwardk> http://functionaltalks.org/2013/06/17/runar-oli-bjarnason-dead-simple-dependency-injection/
03:48:16 <Gracenotes> (though, using it efficiently when there are e.g. tight loops seems to require killing some of the compositionality)
03:48:39 <Gracenotes> though then again so does the dynamic dispatch that normally accompanies dependency injection
03:49:02 <edwardk> my usual rue of thumb is to structure mys tack so the stuff i need in the tight loops can just be the lifted core of the stack
03:49:23 <Gracenotes> perhaps even runtime JIT is the solution to that, like in Java.
03:49:28 <Gracenotes> a solution, anyway.
03:51:00 * Gracenotes watches talk..
04:09:32 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
04:09:32 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
04:09:32 --- names: list (clog tunixman_ yacks nominolo_ Kaidevappy lukexi osa1 bondar talzeus lester_ hashcat jchild hiroakip oscarvarto kamatsu mno2 kennyd Zenol BitPuffin chuzz SonderbladeWork csakatoku augur AntiSpamMeta julmae tertl3 andares_ LK4D4 dschoepe hexagoxel ntus1017 nova_ dimday jj515 satshaba1 biscarch satshabad steshaw udevd dmwit fridim_ scottschecter boegel tuxit JaRoel|4d natte perspectival xexonixxexillion osnr simukis_ DMcGill ghorn__ kitallis paullik DolphR)
04:09:32 --- names: list (jcp morazow kuribas jophish mgaare _justjust MercurialAlchemi cronject jim0thy_ HugoDaniel erebe jobstijl jbracker SoupE saep Argue hsyl20 kludge` hape02 watermind exicer q66 kstuart cognominal counterstrike44 nominolo seschwar_ weie_ ts33kr jonkri lemao Franciman Kabaka roconnor_ PuercoPop utterglee petapetapeta supersym Kiryx m3ga whaletechno merijn allsystemsarego Dtgr donri vnz Alice3 mercwithamouth MindlessDrone quchen DexterLB nodeless Okasu Mon_Ouie)
04:09:32 --- names: list (no7hing dvyal Axman6 rtb Sebastien-L mbrock marr asQuirreL Mortomes_ jtanguy YoungFrog t7 jorick DavidT joneshf-laptop Neqoxec Palmik briennetheblue satc JohnBat26 threesome hkBst sopvop iol Beetny Taneb raichoo copumpkin sShintah benoit ioanel vijaykiran vk_ Draconx yitz bitonic harovali xl2 yfyf [[zz]] gautamc visof djcoin mak` isenmann orzo stevejb xinming ghorn ThomasLocke bogdanp yopikh sinclair|net structuralist yezariaely hive-mind danvet insejn)
04:09:32 --- names: list (shintah Tritlo Boney RayNbow`TU nneko001__ gnuvince- ibalrog sutabi latro`a_ mithsv Endeg zzing wormphlegm Philonous canissimia shesek edwardk otto_s_ shanse federkasten jascase901 simion314 MouseTheLuckyDog kcj Tarential yyyyy_ sclv dymatic wtw seanparsons rhodesd ormaaj kroll synonymous Haya JuanDaugherty mstksg sordina meretrix RichyB apaku dolio brainwash andrewsw pxqr fijimunkii xpika bytbox cmears Amadiro joachifm Excureo mannyv Jonno_FTW miloshadzic)
04:09:32 --- names: list (identity wooy fran otulp setmeaway Croms derekv shergill Sgeo cdidd rodrigovidal Shou c_wraith OlegYch dented42 gthorslund Twey SLi thorsten` dav desc|zenbook conehead mapreduce alpha123 pygospa Kuraitou parcs_ kakos jonsterling zoktar Vq Fubar^ fabjan profmakx Philippa Puffton melter brisbin Hafydd uu1101 Wizek Nahra pjstadig zenoli djahandarie dkordic mcbonz Sculptor hamishmack tavelram_ dkasak_ linux_noob_666 amatsu gbeshers purefn ozgura Darkflux)
04:09:32 --- names: list (sunfun MrWoohoo dlundy mmaruseacph2 sababa vili preflex mauke hellome sellout- Kyzza Arnoldz mshroyer k3VB6u4d mel- leifw mjrosenb jbauman mish4 mgsloan kekimmo DarkFox isomorphic ninegrid b2coutts KyleCloud gnuvince og fry cdk canta perlite Morgawr ruud waterlaz zq troydm barrucadu dysinger fikusz haasn vpm s00pcan dan64 destiny adnap maksbotan obiwanko xenophon message144 amathew DrCode zvrba xplat_ mceier Nshag lattenwald krakrjak_ xymox ktosiek_ _br_-)
04:09:32 --- names: list (kloplop321 tudalex ousado resure carter vk___ Athas jml_ obcode ismlages Pad^ ssttudder Krakarn Shin-LaC levi Ralith shelf benolee rsebastian janinge [mth] jeff_s1 maurer kaktus dropdrive ido pcapriotti ircbrowse jackhill junsuijin albel727 solution Fuco wting ahihi aunn davean benj_ jzl bscarlet WaffleCat Natch eyck asjo kubrat theorbtwo Internet13 n-dolio MoALTz noddy chrisdone iteratee MetaCosm stvc phienone tero- td123 FreeFull rfw blakesmith monochrom)
04:09:32 --- names: list (shachaf joogi araujo daniel-s ezrios tvaalen torkjak LordBrain c_14 jaimef de-Vri-es rmyers ecube k0ral cods MOMI cl_away daira Khisanth morolin burp b0c1 tauntaun ByronJohnson jssanders aloiscochard edkk scshunt milessabin ErkiDerLoony chirpsalot lpvb coeus lunarjar jang1 tadeo dabradley tehroflmaoer udoprog bartavelle aoh arnsholt Nik05 caleb_9 M-ou-se tomh- peddie_ ssbr mantovani cynick taruti sdx23 bduc arkx so dwierenga mokus Bwild fergusnoble tg)
04:09:32 --- names: list (aford brandonw Spaceghost doshitan peddie Igloo dreixel drbean gpampara plucas tsou smlgs Counter-Strike callen rasmusto epta jlaire zrot joefiorini Tinned_Tuna davidt_ ceii niko tensorpudding swistak35 simon eacameron anon123 Cerise idoru cheezey ccxCZ Tehnix machisuji felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid guerrilla iulian dpwright KitB tulcod osfameron sgso ivan` mlamari jlamothe adimit sirspazzolot)
04:09:32 --- names: list (alpounet dju marienz yam McManiaC epsylon dino- hape01 cajla Work_jack palmje mrshoe Ke FireFly tridactyla SegFaultAX pdxleif BigEndian Ycros jrslepak frontendloader yiannis_t dsantiago Maxdamantus wunki `0660 Jaxan vsayer Nimatek gereedy Enigmagic twn ethercrow dogmaT dexter1 tomejaguar centrinia adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o IanKelling leroux bobry demolithion brixen dyreshark mmathis)
04:09:32 --- names: list (gilbertw1 lambdabot Iceland_jack lenstr Will| mimi_vx PHO_ mikee Jello_Raptor vehk ab9rf idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer cschneid jml ParahSail1n Lemmih qz mietek lightquake solancile mjo mortberg Raynos tylergillies_ stepcut nik_89 raft reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson sajith KaneTW arkeet heath kloeri Odd_Bloke FUZxxl mxf knyppeldynan divarvel)
04:09:32 --- names: list (froztbyte _janne BMeph akraut etherfreak vvv drewr Erstarrung jrib zero7 sevvie zebr hdevalence|away flazz Raynes quicksilver bd__ dsirenko_ Bigcheese go|dfish pikhq d3lxa si14 alej stelleg nullcone Sabey upgrayeddd chexxor lopex bentrevor dcoutts pettter drdo qwandor hiyakashi tdammers Baughn_ ciaranm srcerer michaf etrepum spligak hpd seneca nitrodex _flow_ eL_Bart0 shutdown_-h_now wilfredh puzza007 chickenflu warpy Xorlev ortmage ps-auxw bbee akahn)
04:09:32 --- names: list (xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy joeyh kini Licenser hfaafb nwf jhh banjiewen dthibodeau mykhal blz37 palaga NeatBasis_ ggherdov mikecaruso Eridius|vacation gseitz sepeth farn yano aleator milli brett bcoppens Martty knz cmsd2 neurocyte ivan\ nonconvergent thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi Belgarion0 bezik edwtjo mero vvein)
04:09:32 --- names: list (levitation[A] koala_man JustAPerson apples nanothief_ maoe f8l Th0mas tomprince wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra dan_johnsin SaBer neektza1 zerokarmaleft myme1 ggreg otterdam ocharles ysuzuki aess saiam elgot mechairoi Valodim awruef hackagebot WhereIsMySpoon Svedrin `bps liori mlh kshannon h_chiro_ stiell alexander__b warpaint int-e sm dakrone Tribal sleepybug flux kaw ReinH joar bogner_ tych0 Deewiant tippenein)
04:09:32 --- names: list (Mayzie noam_ dustinswan zxq9 plhk saiam^ Phlogistique jmcarthur joshc ninzine phryk kryft \q Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc dario^CIP ion klugez gridaphobe wereHamster genisage ve TML pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra LeaChim dumbhat @ChanServ wavewave OrangeDuck tamiko n00dle Kinnison pnielsen sipa)
04:09:32 --- names: list (wagle geekosaur isomorphismes anders^^_ magicman Dybber mendez Clint sp3ctum cruxeternus birkenfeld seantallen pharaun ericmj bqp XMunkki_ poucet bergmark elliott deavid gbarboza MK_FG asante __main__ b52 caligula__ fryguybob tessier davd petekaz`` Ulrar mrd_ Starfire_ nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten Reisen jayne ccasin Walther)
04:09:32 --- names: list (ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert mikeplus64 lpsmith Draggor horlicks ParahSailin zeiris_ notdan pyykkis mononofu lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus killy9999 Yaniel ejls Watcher7 swook` dsp_ bgamari aformeny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid `^_^v)
04:09:32 --- names: list (zorzar pr aninhumer thetallguy ziman Razz mr- ryanakca thoughtpolice Gilly dilinger_ malorie_ pqmodn_ ttm kaol Soft CosmicRay mornfall schoppenhauer Ornedan jroesch hiredman ski_ joelteon briden vmeson liyang guymann supki Zariel smarter skypers flori shepheb Sourceless bind companion_cube ChongLi Yawgmoth_ bholst_ tswett mami_ ehamberg Boreeas statusfa1led mollerstrand ernst wchun shiona fayden jlouis thorsten1 Maior mviljamaa ofan hvr lispy Saizan luite)
04:09:32 --- names: list (saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside davorak_ othiym23 brainproxy rce brendan Cryovat Brando753 integral JPohlmann duairc jlewis geoffh BlastHardcheese ahf xplat a11235 mux bstrie s4msung SHODAN slobo_ deggis cow-orke1 kranius Gothmog_ kqr1 zaphar_p1 theDon schlumpi Elision thetallguy2 mixi Laney Jimi` gbluma_ MasseR akiress_ peltchu Hardolaf gemelen)
04:38:11 <aloiscochard> I'm still not convinced about runar/tony approach to doing DI with monads... looks better than the crappy cake better, but there must be a better way
04:38:18 <aloiscochard> s/better//
04:40:59 <donri> aloiscochard: any progress on the performance? :)
04:41:06 <osa1> so I compiled a libraryi with cabal and that library has some C code. after compilation I have two files one .a and one .o, which one has compiled C codes? I think it has to be in one of this two files(or maybe in both?)
04:41:45 <quicksilver> both
04:41:56 <quicksilver> a .a file is an archive of object code
04:42:20 <osa1> quicksilver: is it mentioned in GHC user manual?
04:42:29 <quicksilver> normally a .a file has multiple .o files in it but it may have just in a simple case
04:42:37 <quicksilver> I doubt it, this is down to your C compiler
04:42:55 <osa1> oh, I though that .a and .o files generated by GHc
04:43:09 <quicksilver> GHC doesn't compile C code
04:43:10 <aloiscochard> donri: I'm just waiting for the lunch break (which is now!) to try all suggestion! will let you know soon :-)
04:43:29 <osa1> quicksilver: I know but it links compiled C code with GHC code, or does ld do that?
04:43:45 <luite> osa1: you can unpack the with ar x to check :)
04:43:50 <donri> aloiscochard: cool :) haskell can be a bit funny because a naive implementation of some program can be horribly slow and then just some minor changes can change that dramatically
04:43:54 <osa1> luite: great idea, I was about to ask for this
04:43:57 <quicksilver> I thin GHC uses the system linker
04:44:21 <dcoutts> quicksilver: it does compile C code if you ask it to :-)
04:44:44 <osa1> dcoutts: how to ask for it?
04:45:09 <luite> osa1: just compile a c file, ghc -c x.c -o x.o
04:45:12 <dcoutts> osa1: yes, cabal will build any c files specified in c-sources (by calling ghc to compile them) and then link those .o files into the library .a, or the exe (depending on what you're building)
04:45:29 <quicksilver> dcoutts: only by invoking your systems C compiler
04:45:35 <donri> luite: does that just call out to [g]cc?
04:45:39 <luite> donri: yes
04:45:41 <dcoutts> quicksilver: sure, with various extra flags
04:45:43 <quicksilver> I can invoke my systems C compiler too but I wouldn't say that "I compile C code" ;)
04:45:46 <dcoutts> :-)
04:45:47 <osa1> dcoutts: thanks. I'm having trouble finding relevant text in GHC user manual, could you point me if you know where is it?
04:46:00 <osa1> heh :-)
04:46:40 <quicksilver> my point is that whether your system uses .o files or .q files or .dontlookatme files is a property of your system's C compiler (and possibly your system's linker) - GHC doesn't control those file extensions
04:46:57 <quicksilver> I believe win32 uses slightly different file extensions for at least some parts of this process
04:46:59 <luite> donri: i think you can configure the program it calls with platformConstants
04:47:05 <luite> the default one at least
04:47:17 <quicksilver> that's the only reason I was trying to draw the distinction
04:47:21 <donri> luite: well in any case it's not that ghc itself does any c compiling
04:50:06 <luite> donri: in any case it's annoying that ghc handles this ;) i spend the whole weekend hacking ghc+ghcjs to make it also handle .c and other files properly, without running the ghc executable from ghcjs (which is rather fragile)
04:50:16 <dcoutts> osa1: mm, yes it's not clear that compiling C code is documented in the user guide
04:50:31 <luite> in better news, i have the ghc api plugins/hooks extension that i wanted working now
04:50:50 <osa1> ah, too bad
04:50:53 <imperative_progr> In propotional fonts, indentation of code is not shown properly. How can I fix that?
04:51:05 <luite> use a fixed width font ;p
04:51:05 <dcoutts> osa1: but it's basically exactly the same
04:51:23 <imperative_progr> <proportional>
04:51:57 <dcoutts> luite: related to our plugins stuff?
04:51:57 <donri> imperative_progr: indentation should show correctly with proportional fonts. the problem is alignment.
04:52:08 <imperative_progr> Is there a script to convert indentation to braces?
04:52:21 <donri> imperative_progr: HSE might can do that
04:52:27 <donri> @hackage haskell-src-exts
04:52:28 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
04:52:46 <dcoutts> imperative_progr: seriously, don't do it, the code will be so ugly, even if you're using braces so it's correct, it'll just look ugly
04:52:58 <dcoutts> nobody uses proportional fonts for programming
04:53:12 <donri> i wish we could, though
04:53:16 <dcoutts> visual alignment is just so useful and nice
04:53:47 <dcoutts> donri: that said, lhs2TeX produces beautifully aligned output, with proportional fonts
04:53:56 <dcoutts> but I can't see how that'd work in an editor
04:53:59 <donri> cool
04:54:12 <donri> well i'm thinking a structural editor
04:54:29 <dcoutts> donri: best I can imagine is using proportional font in comments, much like good text editors can run the spell check only on the comments
04:54:45 <luite> dcoutts: i hope so, i haven't added Edsko's quasiquoting plugins yet (only things that let you customize the driver pipeline that i think Thomas needs, and for GHCJS some customization hooks for foreign calls), but that should be easy
04:54:47 <imperative_progr> dcoutts: I need that because indentation-sensitive syntax in proportional fonts isn't ugly, it's unreadable and ambiguous.
04:55:13 <donri> dcoutts: http://youtu.be/v2ypDcUM06U
04:55:18 <dcoutts> imperative_progr: sure but even if you switch to braces so that it's correct, it'll still be ugly
04:55:23 <dcoutts> it'd be ugly in C code
04:56:20 <dcoutts> donri: yeah, I've never been really convinced by these structure editors. Would have to actually try one for a while.
04:56:46 <luite> dcoutts: i wasted a bit too much time last week trying to integrate it with the existing plugins, can still be done to some extent, but those are loaded too late (for typechecking and th hooks at least) and it's rather hard to get around that without major changes
04:57:10 <dcoutts> mm
04:58:52 <luite> (since they're loaded/typechecked by adding them as a dependency of the module)
05:04:39 <arnsholt> How old is GHC 7.0.4, roughly?
05:04:50 <osa1> ok so I understand my C files are statically linked to my Haskell program, but is there an option to do the same but link the C library dynamically?
05:05:35 <luite> osa1: you can compile a dynamic library first and link to that
05:05:58 <luite> osa1: but ghc still allows you to build a dynamic lib with objects from C files, it just will be in the same .so as your haskell code
05:07:29 <osa1> luite: when I compile my library it generates two files, one is mylib-version.o and one is libMylib-version.a, I guess that .o files doesn't have C parts so I can dynamically link my programs against that C library if I can link my program with .o ?
05:08:07 <quicksilver> no, the .o file does have the C parts
05:08:10 <quicksilver> the .a file is an archive
05:08:16 <quicksilver> it contains exactly the same code as hte .o file
05:08:20 <quicksilver> but in a library archive
05:08:36 <Ghoul_> does anyone know how to cancel the line breaking thing a unix terminal does sometimes
05:08:49 <Ghoul_> where the line starts with '>' and it wants more input?
05:09:52 <kuribas> Ghoul_: Control-C ?
05:10:19 <Ghoul_> that wont run the command though
05:10:32 <Ghoul_> I want to run it without feeding more input. For some reason the very long cabal line I typed wants more input :(
05:10:43 <luite> Ghoul_: unclosed quotes?
05:10:56 <Ghoul_> oh, yeah, that was it. thanks
05:34:27 <aloiscochard> donri: changing from BitSet to IntSet ... going from 15seconds to less than 5s! :-)
05:34:38 <aloiscochard> donri: -fllvm do a small change as well, but the strict annotation... I don't see a diff
05:35:45 <hpaste> adas pasted “No more lazy” at http://lpaste.net/91784
05:35:49 <adas> could someone please tell me why ^^^ it run endlessly without end?
05:36:50 <mauke> because fib' is an infinite loop
05:36:50 <mauke> the last step of fib' is to run fib' again
05:37:43 <adas> mauke: but shouldn't fib' execute just enough to fetch me 10 numbers?
05:38:05 <adas> like with `take 10 $ [1..]`?
05:38:21 <mauke> it does
05:38:37 <mauke> but you're not building an infinite list
05:39:11 <mauke> you're building an infinite program that (each time through) takes the list, appends something to it (with ++), and replaces the list
05:39:31 <mauke> at each step you have a finite list
05:39:43 <quchen> adas: Also note that the "return ()" statement is redundant. Return doesn't jump out of do notation, it's something completely different than the imperative "return".
05:39:44 <mauke> at each step you completely replace that list
05:44:14 <adas> mauke: that seems like it makes sense. i think that codes makes infinite state monad values instead of building an infinite list? somehow i feel that intuition could be wrong
05:47:42 <aloiscochard> donri: so in a nutshell, I move from 10 times slower, to 2 times slower, which is not bad :-)
05:48:48 <Adeon> can I suppress ghc telling me about all the libraries it is loading when it encounters template haskell in my source files
05:48:59 <Adeon> they obstruct me from seeing warnings!
05:49:21 <quchen> -Werror ;-)
05:50:39 <Adeon> well, that works
05:50:40 <Adeon> kinda
05:51:52 <quchen> Have you tried only printing stderr?
05:52:04 <quchen> The module load messages are probably sent to stdout
05:53:30 <Adeon> yeah, it seems that the warnings go to stderr and everything else to stdout
05:59:15 <satc> Is there some function to perform standard input output on Ptr directly?
06:10:01 <merijn> satc: What does "standard input output on Ptr" mean
06:24:13 <Ghoul_> he might mean writing C strings
06:25:56 <alexander__b> uhm an exercise on typeclassopedia is to prove that pure f <*> x = pure (flip ($)) <*> x <*> pure f
06:26:01 <alexander__b> that's... a mouthful...
06:26:43 <quchen> alexander__b: Apply the Applicative laws to the longer side.
06:26:58 <byorgey> alexander__b: attempting to actually pronounce it is not recommended ;)
06:28:50 <quchen> alexander__b: For example, pure f <*> x = fmap f x
06:29:05 <quchen> And u <*> pure y = pure ($ y) <*> u
06:29:40 <Maior> anyone recommend a particular HTTP client lib?
06:31:09 <simukis_> HTTP.
06:31:45 <Maior> is that the same as Network.HTTP?
06:31:55 <simukis_> Yes.
06:32:16 <Maior> (I possibly need to read more about the differences between packages and modules; will do so shortly)
06:32:20 <Maior> ok, cool, thanks
06:32:47 <Maior> and for URL templates...?
06:33:36 <byorgey> Maior: Hackage contains packages.  packages contain (multiple) modules.
06:34:07 <byorgey> Maior: the name of a package and the name(s) of the module(s) it contains do not necessarily have anything to do with one another.
06:34:16 <Maior> byorgey: ah, excellent, thanks
06:37:13 <shanse> oooh, that Mio paper
06:37:27 <shanse> quite a good read
06:38:00 <Work_jack> shanse: Indeed, exciting times
06:41:27 <shergill> shanse: link?
06:43:16 <Work_jack> shergill: https://news.ycombinator.com/item?id=6198068, http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf?haskellworkshop
06:43:47 <shergill> Work_jack: thanks
06:44:46 <quchen> I just read the abstract and I'm excited.
06:45:42 <bartavelle> when I am in the (ErrorT String IO) monad, is there a way to run "some" on other computations of type (ErrorT String IO ()) ?
06:46:32 <Work_jack> bartavelle: "some"?
06:48:44 <bartavelle> like in Control.Applicative
06:49:04 <bartavelle> I have [ErrorT String IO ()] and would like to know if one of then return ()
06:49:20 <ekyo> hi, can someone explain to me the differences between:
06:49:20 <ekyo> fac n = product [2..n]
06:49:20 <ekyo>  
06:49:20 <ekyo> facs = scanl (*) 1 [1..]
06:49:22 <bartavelle> and stop computating as soon as possible
06:49:22 <applicative> ah, you want something else
06:49:23 <ekyo> fac' n = facs !! n
06:50:18 <applicative> bartavelle: so you do the actions til one of them doesn't make an 'error'
06:50:25 <bartavelle> yup
06:50:38 <bartavelle> I'd like to know if there is already a function for that
06:50:42 <supki> @ty F.asum
06:50:42 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:50:44 <bartavelle> it seemed*
06:50:51 <bartavelle> that "some" was what I wanted
06:51:22 <quchen> I need a circular data structure with the following properties: 1. thread safe, 2. efficiently searchable for contents. I'll be using it to setup a temporary cache of already processed messages, so I can ignore duplicate ones coming in.  --  The easiest solution is just using a TChan, but searching that one is very inefficient. TVar Map has slower addition, but much faster search. Any pointers?
06:51:23 <bartavelle> no it's not what I wanted
06:51:26 <bartavelle> (some)
06:51:32 <bartavelle> not sure why I thought that
06:51:35 * bartavelle looks at asum
06:52:21 <bartavelle> so that's part of my problem
06:52:34 <bartavelle> the other part is that I already am in "ErrorT String IO ()"
06:52:45 <bartavelle> so I suppose asum will kill this as soon as I run throwError
06:52:54 <bartavelle> or maybe I am wrong in that assumption ?
06:53:00 <supki> ?
06:53:05 <supki> can you show the code?
06:53:12 <bartavelle> well I'll just test and try to make more sense if it fails
06:53:23 <supki> sure
06:54:05 <Work_jack> bartavelle: So you have [ErrorT String IO ()] and you want to run each action until one succeds? Sounds like msum
06:55:39 <supki> yes, asum is msum but with reasonable type
06:56:14 <bartavelle> this doesn't work :) Ok, I'll paste something illustrating what I'd like to achieve
06:56:29 <quchen> supki: But ErrorT doesn't have an Alternative instance
06:56:37 <quchen> (Does it?)
06:56:47 <quchen> Oh. It has.
06:56:47 <supki> uh, really?
06:56:51 <quchen> I just looked in the wrong place.
06:56:58 <applicative> asum :: (Foldable t, Alternative f) => t (f a) -> f a
06:57:11 <quchen> (I thought it was one of those things that could have one but doesn't for some reason)
06:57:30 <applicative> this isn't so different from msum
06:58:20 <bartavelle> http://lpaste.net/91785
06:58:28 <bartavelle> I have used "asum", but this will always succeed
06:58:34 <petapetapeta> how do I generate an arbitrary random number using QuickCheck?
06:58:49 <Work_jack> petapetapeta: sample'?
06:59:13 <merijn> quchen: Seq in a TVar?
06:59:29 <applicative> bartavelle: will it 'always succeed' ?
06:59:37 <bartavelle> it seems to
06:59:42 <bartavelle> well the asum version
06:59:51 <byorgey> petapetapeta: can you elaborate a bit?  Why do you want to generate an arbitrary random number?  Is this part of implementing an Arbitrary instance?  Or you just want a random number for yourself? or...?
06:59:53 <applicative> if the actions all fail then you end up with a String, right
07:00:14 <bartavelle> it doesn't seem to happen, I just tested it and it just succeeded
07:00:26 <byorgey> petapetapeta: (i.e. what are you ultimately trying to accomplish?)
07:00:31 <bartavelle> perhaps I am missing something important
07:00:42 <quchen> merijn: Sequence doesn't have efficient lookup, does it?  hmm. Maybe if I sort it by (== findMe)?
07:01:16 <bartavelle> applicative: ah but you are right ! except it was not the string I was looking for, interesting
07:01:17 <bartavelle> thanks !
07:01:37 <applicative> somehow edwardk 's reason for preferring EitherT to ErrorT is a bit strange
07:01:38 <applicative> This is necessary for both theoretical and practical reasons. For instance an apomorphism is the generalized anamorphism for this Monad, but it cannot be written with ErrorT.
07:01:58 * applicative was so much wanting to write an ErrorT apomorphism
07:01:58 <quchen> applicative: ErrorT has these odd ties to String.
07:02:06 <applicative> yes of course
07:02:12 <Work_jack> bartavelle: It seems it uses the mzero when it fails
07:02:22 <bartavelle> well, mine is actually ErrorT Doc IO
07:02:30 <bartavelle> Work_jack, yes, I had an empty string
07:02:32 <quchen> applicative: I can only guess that edwardk's problems with it come from the overly restrictive "Error" type(class).
07:02:48 <applicative> I like EitherT ; its just the apomorphism argument
07:02:50 <petapetapeta_> sorry disconnected - I think I need a generator which only produces positive numbers
07:02:53 <petapetapeta_> bartavelle:
07:03:47 <petapetapeta_> byorgey:
07:04:02 <Work_jack> > msum (Left "HI")
07:04:03 <lambdabot>   Couldn't match expected type `[m0 a0]'
07:04:03 <lambdabot>              with actual type `Data....
07:04:07 <Work_jack> > msum [Left "HI"]
07:04:08 <lambdabot>   Left ""
07:04:27 <applicative> the best reason for using EitherT is that then you can use all the combinators exported by the errors package with 'import Control.Error'
07:05:02 <applicative> which includes all those in Safe for example
07:05:14 <supki> I use EitherT when the left thing is success, not failure
07:05:35 <quchen> applicative: If you want to add a label to Nothing, ErrorT is annoying. That's my main reason for not using it.
07:05:42 <merijn> quchen: TVar (Set a)? Unless you have a more limited behavior than "lookup in a shared data structure" you can't really do more efficient than TVar with a Set or Map
07:05:47 <bartavelle> the "asum" approach worked perfectly, thanks everyone
07:06:02 <bartavelle> I just had to add '<|> throwError "blah"'
07:06:20 <quchen> merijn: Yeah I thought that too, but #haskell surprised me often enough to ask :-)
07:07:41 <merijn> quchen: What's your specific use case?
07:07:48 <petapetapeta_> Shouldn't thins produce a positive generator: suchThat arbitrarySizedIntegral ((>) 0)
07:09:05 <quchen> merijn: I have a network where each node can send messages to the entire network. The network will be flooded with the message, so naturally nodes get the same message multiple times, but I want to process it only once of course.
07:09:14 <petapetapeta_> Sorry I mean a generator which produces random positive integers
07:09:41 <quchen> merijn: For that reason I need some database to store the last N received messages so I can see whether they already came in.
07:10:30 <merijn> Why would nodes get the same message multiple times?
07:13:41 <applicative> oh, i see; i can basically write a preprocessor inside a Setup.hs file.  Or so it seems.
07:14:08 <merijn> I assume this Mio IO stuff will end up in GHC at some point in the near future?
07:14:39 <tikhon> merijn: I understand it's coming in 7.8
07:14:49 <merijn> Nice :)
07:14:52 <Work_jack> merijn: It says so in the paper, GHC 7.8.1
07:15:02 <merijn> Work_jack: I only skimmed it so far :)
07:15:15 <applicative> but I take it it hasn't been applied in ghc-head?
07:15:22 <Work_jack> ...what is up with the MonadPlus instance for Either?
07:15:26 * applicative wouldn't know how to test it anyway
07:15:30 <Work_jack> > Just "IMPORTANT" `mplus` mzero
07:15:31 <lambdabot>   Just "IMPORTANT"
07:15:36 <Work_jack> ..
07:15:42 <merijn> Work_jack: What would you expect?
07:15:48 <Work_jack> This returns (Just "") on my computer, violating the laws
07:16:05 <applicative> > Just "IMPORT" <|> empty
07:16:06 <lambdabot>   Just "IMPORT"
07:16:12 <merijn> Work_jack: I suspect your computer is wrong :)
07:16:15 <Cale> Work_jack: That's not Either
07:16:17 <Work_jack> This is very weird.....
07:16:21 <bartavelle> that's Maybe
07:16:23 <Work_jack> oh
07:16:34 <Work_jack> > Left "hi" `mplus` mempty
07:16:35 <lambdabot>   No instance for (Data.Monoid.Monoid
07:16:35 <lambdabot>                     (Data.Either.Either...
07:16:39 <Work_jack> > Left "hi" `mplus` mzero
07:16:40 <lambdabot>   Left ""
07:16:42 <Work_jack> full of fails today
07:16:53 <Work_jack> Doesn't that violate the unit law?
07:17:28 <Work_jack> > msum [Left "Don't miss me!"] -- so if you have a list of errors, and msum them it returns mzero??
07:17:30 <lambdabot>   Left ""
07:17:30 <Cale> > mzero :: Either String String
07:17:31 <lambdabot>   Left ""
07:17:33 <quicksilver> it does unless you consider all Lefts equal
07:17:50 <quicksilver> the 'equality' implied by that particular instance does consider all lefts equal
07:17:53 <Cale> Where is that instance defined?
07:18:02 <merijn> I'm getting "No instance for (MonadPlus (Either String))"
07:18:05 <Work_jack> Control.Monad.Trans.Error
07:18:09 <tikhon> I don't like the idea of considering all lefts equal
07:18:09 <applicative> > asum  [Left "Don't miss me!"]
07:18:09 <lambdabot>   Not in scope: `asum'
07:18:09 <lambdabot>  Perhaps you meant one of these:
07:18:09 <lambdabot>    `F.asum' (imported...
07:18:10 <Work_jack> you can import Control.Monad.Error
07:18:13 <dschoepe> if you did it the other way around, you'd probably violate the other identity law, e.g. mzero `mplus` Left m may not be equal to Left m
07:18:18 <applicative> > F.asum  [Left "Don't miss me!"]
07:18:19 <lambdabot>   Left ""
07:18:52 <Work_jack> I would assume that if you use Either for errors (like is generally done), you would want to stop on the first error when using msum, not continue to the end and return mzero
07:18:56 <Work_jack> This is very strange to me.
07:19:05 <tikhon> I think the "right" answer would be to not make Either an instance of MonadPlus
07:19:06 <applicative> oh wait is this the result of instance Monoid m => Monoid (Maybe m) etc
07:19:34 <Cale> no
07:19:39 <applicative> no
07:19:47 <S11001001> Work_jack: what would mzero be in the "stop on first error" case?
07:19:56 <applicative> Im still confused
07:20:10 * applicative will wait till Work_jack figures it out.
07:21:09 <Work_jack> S11001001: Right..
07:21:10 <applicative> mzero has to be the same for every type
07:21:27 <arnsholt> Is it possible to build the platform without GL bindings?
07:21:42 <Cale> Work_jack: It's because it's trying to succeed.
07:21:43 <tikhon> Maybe Left a `mplus` Left b should be Left (a <> b)?
07:21:44 <applicative> arnsholt: well, by hand? it's just libraries
07:21:49 <Cale> instance (Error e) => MonadPlus (Either e) where
07:21:49 <Cale>     mzero            = Left noMsg
07:21:49 <Cale>     Left _ `mplus` n = n
07:21:49 <Cale>     m      `mplus` _ = m
07:21:58 <applicative> arnsholt: what platform are you on?
07:21:59 <Work_jack> So you need the Monoid context?
07:22:21 <tikhon> Work_jack: you'd need it anyhow
07:22:33 <arnsholt> My work machine has GHC 7.0.4, so I'd like to install the most recent platform instead
07:22:43 <Work_jack> tikhon: It's not used in Control.Monad.Trans.Error, i.e. the above definition provided by Cale
07:22:50 <tikhon> really?
07:22:51 <arnsholt> Sadly, some of the GL headers are missing
07:22:51 <tikhon> hmm
07:22:52 <Cale> Work_jack: It takes the first success.
07:23:05 <tikhon> oh, it uses noMsg
07:23:10 <dschoepe> How about Left m `mplus` _ = Left m?
07:23:13 <applicative> arnsholt: there are the various binary distributions ; you would just need to install cabal-install by hand. there rest is cabal installable
07:23:16 <quchen> arnsholt: The Platform is tailored to a specific GHC version, I don't think you can install it for older compilers.
07:23:27 <Work_jack> dschoepe: Then it wouldn't look for the next possible success
07:23:35 <applicative> arnsholt: I don't know about Windows thought, if thats the work machine
07:23:38 <dschoepe> Work_jack: oh, right
07:23:41 <tikhon> right, now I understand why people don't like ErrorT and stuff
07:23:57 <applicative> oh, sorry, I thought you were trying to get rid of ghc 7.0.4
07:24:14 <arnsholt> Oh, using cabal would be simpler
07:24:17 <quchen> arnsholt: You can of course install older versions of the packages manually and hope they don't actually need 7.6.x
07:24:22 <merijn> Work_jack: If you want to fail on the first error you want (>>) rather than mplus
07:24:31 <Cale> Yeah, the Error class and these instances are pretty sketchy
07:24:33 <jtanguy> Cale: a success should be in a Right, no not in a Left!?
07:24:37 <Work_jack> So sequence?
07:24:40 <applicative> arnsholt: you are trying to keep ghc-7.0.4
07:24:42 <Cale> jtanguy: that's right
07:24:42 <applicative> ?
07:24:42 <merijn> jtanguy: Yes
07:24:58 <arnsholt> applicative: Nah, I'd like to replace it with a more recent one in my homedir
07:24:59 <Work_jack> > sequence [Left "important message", Right 2, Left "please don't ignore!", Right 1, Right 42]
07:25:01 <lambdabot>   Left "important message"
07:25:02 <merijn> jtanguy: mplus succeeds if either of the two succeeds
07:25:03 <arnsholt> (On Linux, incidentally)
07:25:16 <jtanguy> oh i misread the MonadPlus instance
07:25:18 <merijn> jtanguy: (>>) fails if either side fails
07:25:19 <applicative> arnsholt: just use the bindist thing on the ghc page
07:25:35 <arnsholt> Right. I'll try that instead then
07:25:45 <applicative> arnsholt: its easier than any platform install, on condition that you dont have to worry about GL and co, which you don't
07:25:59 <arnsholt> Yeah, I don't care about GL
07:26:01 <applicative> there's one for random-linux or whatever
07:26:26 <arnsholt> This would be so much simpler if I had root on the damn thing >.<
07:26:42 <applicative> your old 'cabal' may work if you keep it
07:26:57 <Cale> I think the right thing to do probably would involve a monoid instance :)
07:27:02 <applicative> or anyway it may work well enough to do cabal install cabal-install
07:27:20 <quchen> arnsholt: You can install everything locally, no?
07:27:36 <arnsholt> quchen: That's the plan, pretty much
07:27:37 <Work_jack> But yes, so Either fails to satisfy the MonadPlus laws in this particular implementation
07:27:39 <applicative> arnsholt: yes, i only ever install ghc locally
07:27:54 <quchen> arnsholt: Local GHC isn't a problem, so if you get GL to run (or at least to not complain) you should be fine
07:28:02 <applicative> where is monochrom s page that's the first thing I should have mentioned arnsholt
07:28:06 <Cale> Work_jack: Yeah, pretty much regardless of what those laws actually are.
07:28:27 <quchen> I could offer my second-grade GHC installation file if you can't find Monochrom's page
07:28:32 <applicative> arnsholt: oh here http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
07:28:42 <Cale> Work_jack: a minimal expectation would just be that an instance of MonadPlus gives a monoid for each type it's applied to
07:28:51 <applicative> arnsholt: he is installing everything but the page has various good points
07:29:04 <applicative> arnsholt: but quchen 's script may be better
07:29:27 <quchen> Mine's written for myself and it omits some things Monochrom talks about -- https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md
07:29:35 <arnsholt> applicative: Cheers! That looks promising
07:29:35 <applicative> oh nice
07:29:48 <quchen> It was basically a walkthrough for myself which I converted to .md
07:31:15 <Cale> instance Monoid e => MonadPlus (Either e) where mzero = Left mempty; Left u `mplus` Left v = Left (u <> v); Left u `mplus` Right x = Right x; Right x `mplus` _ = Right x
07:31:19 <applicative> arnsholt: you will just want to add the prefix $HOME/wherever when you configure , as the readme and quchen & co say; then put $HOME/wherever in path
07:31:25 <Cale> That ought to give a monoid at least
07:31:31 <Work_jack> Cale: Right
07:31:43 <arnsholt> applicative: Definitely
07:31:51 <Work_jack> (I mean Left)
07:32:01 <applicative> arnsholt: if you end up installing cabal-install by hand, I cant recommend the dev version highly enough because of cabal sandbox
07:32:16 <arnsholt> What's the sandbox do?
07:32:17 <ion> http://hackage.haskell.org/packages/archive/either/3.4.1/doc/html/Control-Monad-Trans-Either.html has a MonadPlus instance.
07:32:38 <byorgey> petapetapeta_: if you need a generator for positive numbers, you can use the Positive newtyoe
07:32:41 <byorgey> *newtype
07:33:05 <byorgey> i.e. instead of   my_prop x y = ... x ... y ..., you can write    my_prop (Positive x) y = ... x ... y ...
07:33:10 <quchen> arnsholt: Note that the Platform installs cabal, but usually in a place that's not in $PATH. You'll have to enter that directory manually and update cabal-install to get cabal to .cabal/bin.
07:33:29 <Cale> arnsholt: I wouldn't bother with the platform. Just get a tarball of cabal-install from Hackage once GHC is installed, and run the bootstrap.sh script from that.
07:33:30 <quchen> That was one of the weirder things the Platform taught me.
07:33:53 <quchen> Or what Cale says
07:33:56 <Cale> arnsholt: You can then just cabal-install anything you happen to need from there, and you'll already have a reasonable collection of libraries.
07:34:02 <arnsholt> Yeah, it's a bit annoying that cabal installs stuff there. OTOH, it does make a bit of sense
07:34:19 <ion> What i do: “Installing GHC and Cabal under the home directory” https://gist.github.com/ion1/2815423
07:34:41 <quchen> Cale's approach also has the benefit of allowing docs to be built for the libraries contained in the Platform. (The Platform doesn't seem to allow this.)
07:34:53 <quchen> Just in case you wanna code in an airplane :-D
07:34:54 <petapetapeta_> byorgey: How do I use that when implementing an arbitrary instance? Do I use it inside the declaration?
07:34:57 <arnsholt> Docs are good
07:35:06 <Cale> There really ought to be a generic Linux binary version of Platform.
07:35:09 <Cale> But there isn't.
07:35:15 <arnsholt> (Which is annoying with Ubuntu: Everything's sliced into a million tiny pieces)
07:35:19 <Cale> Yes.
07:35:25 <byorgey> petapetapeta_: you could write e.g.      (Positive x) <- arbitrary; ... x ...
07:35:33 <quchen> Using Haskell from the repos is awful.
07:36:08 <Cale> I long ago stopped trusting the linux distributions to get anything related to Haskell right, and haven't seen any evidence that this was a poor decision on my part ;)
07:36:19 <byorgey> petapetapeta_: newtype Positive = Positive a, basically, with an instance   (Num a, Arbitrary a) => Arbitrary (Positive a)
07:36:26 <byorgey> which only generates positive numbers
07:36:32 <petapetapeta_> If I have this: http://pastebin.com/TZ8HbbYP
07:36:35 <mauke> The paste TZ8HbbYP has been copied to http://lpaste.net/91786
07:36:35 <quchen> Cale: My Linux distribution excels at creating folders when I enter mkdir. It's very suitable for Haskell.
07:36:52 <arnsholt> I end up installing more and more stuff from source
07:36:57 <petapetapeta_> So I simply run a newtype on for example the Source type?
07:37:10 <Cale> quchen: Aw, man, mine only makes directories. How do you get it to make folders?
07:37:14 <arnsholt> Or with tools that do it for me. TeXLive, Perl with perlbrew, and so on
07:37:21 <byorgey> petapetapeta_: digitGenerator is supposed to only generate positive numbers?
07:37:35 <petapetapeta_> byorgey: that's the thought, yes
07:37:45 <byorgey> petapetapeta_: "run a newtype on the Source type" does not really make sense, I am not sure what you mean
07:37:55 <quchen> Cale: sudo apt-get install folders :-P
07:38:14 <petapetapeta_> byorgey: Sorry I was being sloppy there. So I need to redeclare the source type with a newtype?
07:38:22 <byorgey> petapetapeta_: ah, no
07:38:47 <byorgey> petapetapeta_: you could write e.g.    liftM Source (liftM getPositive arbitrary)
07:39:03 <byorgey> petapetapeta_: see http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck-Modifiers.html#t:Positive
07:39:06 <merijn> Cale: Well,it's kinda hard to find any common set of libraries/tools to target for a linux binaryplatform
07:39:21 <applicative> i think things like the debian method of installing things like haskell-platform is good for things like keeping up with the dev version of pandocand so on, if you dont write haskell
07:39:22 <Cale> merijn: Well, make the same decisions that GHC makes.
07:39:39 <Cale> merijn: I guess there's a somewhat larger set of decisions.
07:39:41 <merijn> Cale: Not that I disagree with your analysis of the situation, I'm perfectly happy with my OSX binaries ;)
07:39:55 <petapetapeta_> byorgey: Ahh that makes sense :)
07:40:48 <petapetapeta_> byorgey: So in what use case would I use newtype positive?
07:41:13 <byorgey> petapetapeta_: liftM Source (liftM getPositive arbitrary) *is* using the Positive newtype!
07:41:34 <byorgey> petapetapeta_: in that code,  arbitrary :: Gen (Positive Integer)  (or Int or whatever)
07:41:54 <byorgey> petapetapeta_: getPositive :: Positive a -> a,  so  liftM getPositive arbitrary :: Gen Integer
07:42:05 <petapetapeta_> byorgey: Ahhh I see now! I missed the genPositive :: a part of the documentation
07:42:11 <petapetapeta_> that makes so much more sense!
07:42:15 <byorgey> great =)
07:42:27 <Tehnix> is there a general rule for when to use a strict vs a lazy data type? (like, a HashMap)
07:42:45 <petapetapeta_> I was really confounded with the Modifier documentation
07:42:54 <petapetapeta_> But it makes sense :D
07:42:56 <Cale> If I was ruler of the situation, I think I would cut platform down to something extremely minimal -- just what was required to get a working GHC and cabal-install, but it would be set to generate documentation and profiling versions of things by default, and there would be a generic Linux binary package which was similar in nature to the one for GHC.
07:42:57 <petapetapeta_> Thanks a lot
07:43:00 <byorgey> petapetapeta_: the magic is all in the Arbitrary instances
07:43:06 <byorgey> petapetapeta_: glad to help =)
07:43:30 <applicative> Tehnix: when both .Strict and .Lazy are offered you probably want .Strict, since otherwise it wouldn't exist -- to put it incredibly crudely
07:43:43 <applicative> Control.Monad.Trans.State.Lazy
07:43:53 <applicative> Its a little theoretical
07:43:53 <petapetapeta_> byorgey: Yeah I had a bright moment an hour ago when I realized how the Arbitrary instances work :)
07:44:16 <Tehnix> applicative: so, kinda default to using strict unless I have a reason for it to be lazy?
07:44:19 <Cale> Also, there would be some kind of requirement, if enforceable, that distributions not split it into smaller packages.
07:44:44 <Cale> (or at least an explicit recommendation)
07:45:25 <applicative> Tehnix: as a general rule about Haskell no, if that's what you mean; its just that the cases I know where theres a Blah.Strict and Blah.Lazy option like StateT, WriterT and so on, its Strict you want just if you think about what youre doing
07:46:17 <applicative> StateT and WriterT could do with Control.Monad.Trans.<X>.Strict.Very without (,) in fact
07:46:23 <Cale> I don't care about "Batteries Included", I'd just like people to be able to run one thing and reliably get GHC and cabal-install with a sane configuration for development.
07:47:42 <applicative> Tehnix: but I see tibbe doesnt give any general guidance http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.1/doc/html/Data-HashMap-Lazy.html
07:49:05 <Tehnix> applicative: hmm, I think I found somewhere that if the values were big, you'd wanna go with lazy, and if not, you'd settle on strict. Does that sound reasonable?
07:49:19 <Cale> Tehnix: The strict/lazy distinction here is about whether the values are always forced. The keys of course need to be forced in order to hash them and compare etc.
07:49:55 <applicative> Tehnix: Cale will have better advice ;) I think the strictness for the values will just be a mess if they are complicated recursive things
07:51:36 <merijn> applicative: I don't agree with "use strict if it's there"
07:51:37 <Tehnix> applicative, Cale: the case of the value being a simple string, there wouldn't be much sense in making in lazy, no? I see the point in functions etc though
07:51:52 <Tehnix> s/in/it
07:51:57 <merijn> If there is a chance you might not use the value and the computations are costly Lazy will be more efficient
07:52:14 <Cale> You use the lazy version if you want to be able to put unevaluated expressions in the HashMap, and strict if you want to be sure that those expressions get evaluated when inserting them. If you were, say, accumulating things into a HashMap by adding 1 to the values which were already in the HashMap over and over, that would be a good use case for Strict, because otherwise you construct big expressions like (...(((0 + 1
07:52:14 <Cale> ) + 1) + 1) ...) + 1
07:52:18 <merijn> Tehnix: That depends on which computation produces that simple string...
07:52:43 <Cale> Tehnix: In the case where the values are strings, then probably Lazy is just fine.
07:52:45 <Tehnix> merijn: a JSON object (from aeson) in this instance. Although, I'm interested in it in general
07:52:55 <merijn> Tehnix: I could have an hour long computation the returns a string, if I insert the result do I want it to be computed when I insert?
07:53:04 <merijn> eh, insert is the wrong term hee
07:53:08 <merijn> But you get what I mean
07:53:13 <Tehnix> merijn: yeah :)
07:53:42 <merijn> Tehnix: If there is a chance you won't look at the result, you probably want to be lazy so you don't compute for an hour for nothing
07:53:43 <Cale> But if you need strictness, the Strict version won't likely be strict enough -- you'll have to arrange for the entire String to be forced if you want that to happen -- the strict HashMap will only force the evaluation up to determining the topmost data constructor (probably (:) unless it's [])
07:53:50 <haasn> Cale: in the case of a string, though, would it just `seq` the top constructor?
07:53:50 <haasn> oh
07:54:05 <haasn> that answers my question then :)
07:54:06 <applicative> merijn: I think I'm taking it back, the original question was not about .Strict and .Lazy modules
07:54:23 <applicative> merijn: and my thought went to State and Writer.
07:54:43 <applicative> merijn: sorry, it was about .Strict and .Lazy modules in general
07:54:51 <Tehnix> applicative: I was more interested in lists, hashmaps etc (data types? data.. models?)
07:55:28 <Tehnix> this has cleared it up for me though, thanks all :=)
07:55:29 <Tehnix> :) *
07:56:12 <satc> Is there a sensible way to combine quickcheck properties and run them without using packages like test-framework.
07:56:34 <applicative> I was studying Writer.Strict vs Writer.Lazy a little while ago as pipes was trying to use them to express folds in general
07:57:04 <Cale> satc: Well, you can just write an IO action by hand which runs the lot of them.
07:57:10 <applicative> but even Writer.Strict wasnt strict enough to get a proper fold going
07:57:21 <opqdonut> satc: mapM_ quickCheck properties
07:57:36 <Cale> satc: There was also a script floating around which would locate all the prop_* things and run them.
07:57:55 <opqdonut> satc: but you need to use prop to make properties of different types fit into a list
07:58:14 <quchen> satc, opqdonut: You can also automate checking all prop_ forms with QC.All: http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck-All.html
07:58:15 <opqdonut> satc: see also quickCheckAll
07:58:23 <opqdonut> which is what quchen just pasted :)
07:58:27 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck-All.html
07:58:29 <Cale> oh, right
07:58:35 <quchen> Hattrick!
07:59:21 <satc> opqdonut: Is there a way to print the labels too
07:59:27 <quchen> (I'm still not sure why it uses TH instead of just allowing me to specify a list, but meh)
07:59:46 <Cale> haha, it actually uses TH to get the filename, and then reads the file itself separately.
08:00:26 <satc> opqdonut: Oh. nvm
08:02:42 <scooty-puff> is there a LCA <O(n), O(1)> implementation already on hackage?
08:03:14 <scooty-puff> *an? never know if its the l in lowest or the ell in the pronunciation of "l"
08:03:45 <scooty-puff> i saw the log(h) implementation using skew binary lists
08:04:33 <applicative> in his foldl package Tekmo exports these left folds like 'any' 'all' 'and' 'or' without realizing that these are completely insane in a strict context
08:05:49 <applicative> in theory you can do (,) <$> any even <*> product and foldl that over something. but it will check everything for even-ness
08:06:01 <applicative> of course
08:11:49 <solarus> 
08:11:49 <solarus> 
08:11:49 <solarus> 
08:11:56 <solarus> oops
08:26:42 <startling> is there anything that will help me pretty-print ASTs by knowing that e.g. application is left-associative?
08:26:57 <alexander__b> quchen: I think I'll do what you said on reddit a little while ago -- read lyah one more times (totalling in three), read rwh a couple of times, etc. :-P reading lyah twice was evidently not enough to do anything non-basic.
08:27:39 <quchen> alexander__b: You'll also need to write code.
08:27:50 <startling> yeah, that's the big thing I think
08:27:51 <quchen> alexander__b: Which is far more important than reading.
08:28:02 <quchen> alexander__b: Reading is bootstrapping help.
08:28:02 <alexander__b> quchen: yes this where my realisation that I am not able to do non-basic things stems from
08:28:04 <startling> there's only so far that dicking around with lists will ge you.
08:28:05 <Fuuzetsu> alexander__b: write for some actual projects, no better way to learn than to step outside of your comfort zone and see all the cool stuff people actually write
08:28:37 <alexander__b> Fuuzetsu: I mostly end up seeing a bunch of syntax that I'm sure I read about in LYAH but fail to reason beyond that.
08:28:52 <quchen> alexander__b: For a guided tour of non-"dicking around" Haskell you may want to look at Write Yourself a Scheme. I think it's a little too advanced to be read just after LYAH though.
08:29:19 <alexander__b> quchen: right now I thought I'd give a go at the haskell 99 problems and then look into RWH
08:29:51 <quchen> Those 99 problems are coding lists and trees and what not. I don't think they're too useful.
08:30:02 <quchen> ProjectEuler is the same but worse.
08:30:11 <Maior> I know the feeling
08:30:40 <alexander__b> quchen: well I originally started writing a rpn calculator but eventually sort of gave up when it came to the more advanced things
08:31:10 <zq> what's the name for "(*6)"? "partial"?
08:31:18 <quchen> zq: "section"
08:31:20 <applicative> section
08:31:44 <quchen> zq: There's also "partial application", not to be confused with "partial". Partial application of "add a b" is writing "add a".
08:31:54 <applicative> a 'partial' wouldn't be too bad a name I suppose; 'section' basically means the same
08:31:55 <quchen> "Partial function" is one that crashes for certain inputs.
08:32:11 <zq> quchen, applicative: thanks
08:32:13 <quchen> > head [] -- partial
08:32:14 <lambdabot>   *Exception: Prelude.head: empty list
08:32:25 <applicative> oh thats true, the other meaning of 'partial' is distracting
08:32:28 <quchen> :t (+) 2 -- partially applied (+) function
08:32:28 <lambdabot> Num a => a -> a
08:33:16 <quchen> :t (+ 2) -- partially applied (+) function written as an infix section
08:33:17 <lambdabot> Num a => a -> a
08:33:22 <zq> runghc var
08:33:50 <HugoDaniel> hi
08:33:54 <zq> all sections are partials but not the reverse
08:34:01 <gdoteof> http://pastie.org/8229811  on line 16 there; if i have the liftIO $ putStrLn e    then i get a type error, if i remove it (and the do) then it compiles fine
08:34:05 <quicksilver> pedants will sometimes argue about whether (+2) counts a partial application since it's the second argument you have applied
08:34:08 <HugoDaniel> is there any way to do gui's in haskell that work in all OS's ?
08:34:13 <quicksilver> depends how syntactic a view you're taking.
08:34:14 <gdoteof> not sure how to dump that there
08:34:31 <tikhon> HugoDaniel: I think wx works in any OS you would care about
08:34:38 <tromp_> :t (2+)
08:34:39 <lambdabot> Num a => a -> a
08:34:41 <quchen> quicksilver: And then there's also the `(2+) /= (\x -> 2+x)` discussion and all that.
08:34:42 <tikhon> also, you could use something web-based
08:34:44 <zq> :t map (- (sum samples)) samples
08:34:45 <lambdabot>     Not in scope: `samples'
08:34:45 <lambdabot>     Perhaps you meant one of these:
08:34:45 <lambdabot>       `sample' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
08:34:52 <zq> :t map (- (sum [1..23])) [1..23]
08:34:53 <lambdabot> (Enum (a -> b), Enum a, Num (a -> b), Num a) => [b]
08:35:19 <quchen> zq: (-) is the only operator you can't make sections of. (-2) stands for "negative 2", not for "subtract 2". For that, use `subtract 2`.
08:35:30 <quchen> > (subtract 3) 10 -- works
08:35:32 <lambdabot>   7
08:35:43 <quchen> > (-3) 10 -- shouldn't work but Lambdabot has a silly Num instance for functions
08:35:45 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
08:35:45 <lambdabot>    arising f...
08:35:53 <quchen> Oh
08:35:55 <quchen> Nevermind the comment.
08:36:12 <zq> quchen: no wonder. i ended up creating a partial ("((-) (sum [1..23]))") instead of a section.
08:36:32 <quchen> zq: That's the only special case though
08:38:16 <gdoteof> more generally, how can i put a debug statement inside a case output that is supposed to return something.  like let myVar = case foo of; This x -> myVarx; Badthing e -> liftIO $ do; putStrLn e; myDefault;
08:38:50 <quchen> gdoteof: If you're looking for "print debugging", then Debug.Trace is for you.
08:39:18 <quchen> (DO NOT use it in production code to get around purity. It's strictly for dirty debugging.)
08:39:44 <gdoteof> quchen: eh mroe generlaly i am just trying to print a message there and confused why i am getting a type error
08:40:06 <startling> print debugging a type error might be a little tricky. :)
08:40:14 <gdoteof> i thought i could just do whatever inside of a do statement as long as the last statement is of the correct type
08:40:24 <quchen> No, the types have to be right all the way.
08:40:33 <startling> gdoteof, putStrLn x isn't the right type
08:40:36 <kier> gdoteof: the case block isn't in the IO monad, so you can't do IO inside it
08:40:41 <quchen> Do notation isn't a magic ticket to anything, it's just a nice replacement for writing >>= all the time.
08:40:56 <gdoteof> kier: how would i go abotu doing what i am trying to do there
08:41:11 <startling> gdoteof, it's just for debugging? Debug.Trace.trace
08:41:28 <gdoteof> Debug.Trace.trace will magically be the right type?
08:41:38 <quchen> Sort of, yes.
08:41:40 <startling> :t Debug.Trace.trace
08:41:41 <lambdabot> String -> a -> a
08:41:50 <gdoteof> hrm alright
08:41:58 <quchen> trace will print the String, and then return the `a`.
08:42:06 <quicksilver> must be magic, I'd say.
08:42:08 <quchen> (No IO involved because it uses black magic.)
08:42:09 <kier> gdoteof: if you replace the "let response =" with "response <-", then the case block will be in IO. You'll then need to replace "response" and "("", "", 0)" (the two final values in the alternatives) with "return response" and "return ("", "", 0)"
08:42:24 <startling> gdoteof: you'd do 'trace "hello world" myDefault'
08:43:58 <gdoteof> startling: sweet. thanks
08:44:11 <alexander__b> quchen: I kind of see what you mean. some problems in now, and it's not very haskell-relevant thus far. I just recurse a bit and solve the problem...
08:44:53 <zq> recommended max width of lines of *.hs?
08:45:09 <zq> i've seen 72, 80, and 120
08:45:11 <bartavelle> ok, something is calling "tell" all the time with "mempty", and I can't place breakpoints on tell or mappend (as they are not interpreted) with ghci
08:45:16 <bartavelle> is there a trick to have them interpreted ?
08:45:32 <Fuuzetsu> you could wrap them?
08:45:40 <startling> when would "tell mempty" be noticeable?
08:45:41 <Fuuzetsu> mappend' = mappend
08:45:54 <bartavelle> startling, when it's called thousands of times
08:46:01 <startling> oh, heh
08:46:09 <bartavelle> Fuuzetsu, mappend is called thought the Monoid instance (because of tell), so I don't think I can do that
08:46:19 <Fuuzetsu> oh, that's right
08:47:05 <quchen> alexander__b: I'd at least try to somewhat understand the Parsec chapter in RWH, that opens up the door to so many things. Writing a simple chat program or webserver for example.
08:47:31 <quchen> alexander__b: Beautifying a CSV file. Stuff like that.
08:48:14 <startling> bartavelle, newtype TattleTale = TattleTale x; instance Monoid TattleTale where mappend a b = trace "mappending!" ...
08:48:47 <Saizan> preflex: seen danharaj
08:48:47 <preflex>  danharaj was last seen on #haskell 13 hours, 21 minutes and 50 seconds ago, saying: Don't tell me I have to reverse the list and add with carry like a prole :3
08:48:49 <quchen> zq: 80 characters is a pretty normal limit.
08:48:55 <danharaj> hello
08:48:59 <Saizan> hi
08:49:00 <bartavelle> startling, well I wrote the Monoid instance myself, so I did this (and noticed the behaviour), but it is in a library that is used by the program I am running thought ghci
08:49:19 <Saizan> danharaj: so, the Bound class is really about left-modules?
08:49:30 <bartavelle> I suppose I am asking for something futile, because there is no way it could be interpreted anyway
08:49:37 * bartavelle will do something else
08:49:39 <startling> bartavelle, does traceStack work?
08:49:44 <bartavelle> ah !
08:49:46 <bartavelle> didn't think of this
08:49:56 <startling> "In the current GHC implementation, the call stack is only availble if the program was compiled with -prof; otherwise traceStack behaves exactly like trace. Entries in the call stack correspond to SCC annotations, so it is a good idea to use -fprof-auto or -fprof-auto-calls to add SCC annotations automatically."
08:50:20 <zq> yeah but hask nests like a g6
08:50:45 <edwardk> carter: ping
08:51:17 <danharaj> Saizan: I'm not exactly sure. Usually with Bound you have a nested data type that you want to turn into a monad, and lifting from m a to m (g a) seems to have to be a left module if you want the monad laws to hold.
08:51:47 <quchen> zq: I don't know what a G6 is, but Haskell doesn't nest like it.
08:51:55 * hackagebot hemokit 0.4.1 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.4.1 (NiklasHambuechen)
08:52:26 <quchen> If you're over 4 levels of indentation chances are that you should refactor that piece of code.
08:53:18 <bartavelle> ok it is calling mappend *everywhere*
08:53:26 <startling> :/
08:53:35 <bartavelle> not sure how this is possible
08:54:16 <Saizan> danharaj: right, if we know that (t m) is a left-module of m then it should follow that you get a monad with the template instance for m, and vice versa
08:54:27 <gertc> how do i include a directorie named src-unix in .ghci ? -isrc -isrc-unix did not work?
08:54:41 <supki> bartavelle: well, every bind will call mappend?
08:55:18 <bartavelle> I'd say so, but I am not experienced enough to be sure
08:55:58 <bartavelle> hum seems like that's what RWS does
08:56:07 <danharaj> Saizan: I'm not sure I like this formulation though. I tend to want to think of nested data types as fix-points in (* -> *) -> (* -> *). Perhaps there is a way to formulate things so that we make a statement in the functor category and get a monad in *.
08:56:53 <danharaj> Saizan: On the other hand I think the idea of monad modules is cool and there must be some other cool applications of them elsewhere :)
08:57:18 <Saizan> danharaj: that's more the soeqlog style of things, it seems more natural to me too, but i wonder what the relation is
08:58:05 <danharaj> Saizan: That style I think is even better because it indexes the nesting of the data type with FinSet or whatever fancy index you want.
08:59:22 <Saizan> danharaj: you've quite a bit of freedom with left-modules too, depending on which category you use, i wonder how much though
08:59:49 <danharaj> Saizan: It seems to me that maybe modules could be an alternative formulation of monad transformers.
09:00:29 <danharaj> if t is a monad transformer, t m is a left module of m. or is it right? I have seen the definitions flipped in some places :P
09:01:03 <Saizan> yeah, it should be, does the reverse hold too?
09:02:11 <danilo2> Hi! I've got strange error whuile using uu-parsinglib (probably caused by me beeing a newbe in uu-parsinglib) - could somebody look at it please? (http://stackoverflow.com/questions/18191383/strange-uu-parsinglib-behavior) :)
09:06:08 <edwardk> hrmm. anyone feel like helping break my sparse linear algebra library? haddocks: http://comonad.com/sparse/Sparse-Matrix.html code: https://github.com/ekmett/sparse
09:06:11 <danharaj> Saizan: ah I think this is what I meant. If you have a monad m, and to it corresponds a transformer t, then you can make any other monad a left module of m via t.
09:06:31 <tswett> Ahoy. So I'm trying to install haskelldb, following these instructions: https://github.com/m4dc4p/haskelldb/blob/master/INSTALL
09:06:38 <edwardk> amazingly my weird little morton multiplier seems to have worked first time
09:06:39 <danilo2> Hi! does anybody know uu-parsinglib here? :> I would be very thankful for any help: http://stackoverflow.com/questions/18191383/strange-uu-parsinglib-behavior
09:06:47 <danharaj> Saizan: now if you have a natural way of making any monad a left module of another monad, that should give you a left module but that is just my guess.
09:06:57 * hackagebot hidapi 0.1.1 - Haskell bindings to HIDAPI  http://hackage.haskell.org/package/hidapi-0.1.1 (NiklasHambuechen)
09:06:59 * hackagebot hemokit 0.4.2 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.4.2 (NiklasHambuechen)
09:07:27 <tswett> First I installed haskelldb itself, and apparently that installed version 2.2.2. So then I went on to try to install driver-dynamic, and it said that it requires exactly version 0.11 of haskelldb.
09:07:38 <tswett> So, like, uh, what?
09:09:02 <Saizan> danharaj: ah, interesting
09:09:19 <danharaj> Saizan: maybe. I am eating lunch so most of my energy is in my gut, not my brain ;)
09:09:34 <gertc> how do you do -isrc-unix ?
09:10:37 <danharaj> Saizan: I have been wondering about how to characterize all functors FinSet -> *. The discussion we're having makes me think that maybe they correspond to nested data types of some sort.
09:11:52 <edwardk> example: >>> (ident 4 - fromList [(key 2 1, 1)]) * fromList [(key 2 3, 5), (key 3 4, 6)] :: Mat Data.Vector.Unboxed.Vector Int    ==> fromList [(key 2 3,5),(key 3 4,6)]
09:11:55 <gertc> tried -i"src-unix" -isrc\-unix
09:11:57 <satc> Is there a way to read from stdin to a Ptr?
09:12:32 <edwardk> matrices are implicitly any dimensional and sparse and forward and backwards multiplication of the same matrix should be comparable.
09:13:53 <danharaj> edwardk: I would love to help perhaps later tonight. Hopefully you don't fix *all* the bugs by then.
09:13:59 <startling> is there a thing somewhere to generate all possible lists consisting only of elements of a given list?
09:14:05 <edwardk> danharaj: i just can't find any =)
09:14:15 <danharaj> edwardk: that might be a bug!
09:14:40 <edwardk> danharaj: my wonderful little 'don't touch the indices' hack seems to have just magically worked
09:15:01 <edwardk> i've never seen this particular way of splitting before though
09:15:09 <danharaj> write a paper!
09:15:13 <satc> I am working with locked memory, I can allocate a ByteString with the ForeignPointer which is locked in the memory. Now I want to read some sensitive data from stdin to a locked ByteString. Does their exist some function to read input from some handle (like stdin) to a ForeignPtr or Ptr. I can always write a FFI to do that, but just to be sure before actually doing that.
09:15:22 <edwardk> i actually should. i find it amazingly elegant
09:15:40 <startling> i.e. I want ['a', 'b', 'c'...] -> ["a","b"..."aa", "ab", "ac"..."aaa", "aab"...]
09:15:45 <edwardk> as it turns matrix multiplication in morton order into handling 4 cases
09:16:14 <kier> > concatMap permutations $ subsequences "abc"
09:16:15 <lambdabot>   ["","a","b","ab","ba","c","ac","ca","bc","cb","abc","bac","cba","bca","cab"...
09:16:35 <edwardk> https://github.com/ekmett/sparse/blob/master/src/Sparse/Matrix.hs#L243 covers my entire recursion pattern
09:16:37 <startling> > "aaa" `elem` (concatMap permutations $ subsequences "abc")
09:16:38 <lambdabot>   False
09:16:54 <kier> touche.
09:16:58 * hackagebot hemokit 0.5 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.5 (NiklasHambuechen)
09:16:58 <edwardk> instead of doing the usual quadrant split i split on whatever the current biggest outstanding split in each morton order is
09:17:14 <edwardk> and when i go to stitch things back into the result matrix all the indices are just in the right place
09:17:32 <edwardk> i had the thought that it might work the other day, and was just flabbergasted when it did
09:18:44 <startling> > let each s = (:) <$> s <*> each s in each "abc"
09:18:45 <lambdabot>   *Exception: stack overflow
09:19:31 <danharaj> edwardk: have you benched it yet?
09:19:47 <kier> > [1..] >>= \l -> replicateM l "abc"
09:19:48 <edwardk> danharaj: nope. was hoping to get carter to do so as he seems to have a ton of examples
09:19:48 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
09:19:59 <startling> kier, aha
09:20:01 <edwardk> danharaj: its too elegant not to be fast though! =)
09:20:07 <kier> > [1..] >>= flip replicateM "abc"
09:20:08 <danharaj> edwardk: maybe you'll get to write a "Haskell is faster than C" sort of paper :P
09:20:08 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
09:20:59 <startling> :t [1..] >=> flip replicateM
09:21:00 <lambdabot>     Couldn't match expected type `a0 -> Int -> m0 a1'
09:21:00 <lambdabot>                 with actual type `[t0]'
09:21:00 <lambdabot>     In the first argument of `(>=>)', namely `[1 .. ]'
09:21:07 <startling> oh
09:22:47 <edwardk> danharaj: i'd just be happy being within a factor of 5 of a nice BLAS
09:22:51 <startling> :t (>>=) [1..] . flip replicateM
09:22:51 <lambdabot> [a] -> [[a]]
09:22:59 <edwardk> danharaj: this was a yak i was shaving in a parsing combinator library ;)
09:23:30 <danharaj> wait
09:23:35 <danharaj> matrices in a parsing combinator library?
09:24:02 <edwardk> was playing around with writing a valiant parser
09:25:40 <edwardk> using recovered sharing on an applicative grammar to obtain what is morally a 2NF grammar, then running the resulting parser. the valiant parser is then a bunch of matrix multiplication in a non-associative seminearring
09:26:11 <danharaj> weird and cool
09:26:26 <edwardk> where the matrices are square n*n matrices tabulating how you get from each input to each output and the accumulated parse trees so far
09:26:52 <edwardk> basically i want something like http://www.cse.chalmers.se/~bernardy/PP.pdf  but where you don't need to run bnfc and it 'just works'
09:27:30 <danharaj> So I take it your stuff can't handle infinite alternatives in an applicative expression
09:27:35 <edwardk> correct
09:27:40 <tikhon> I remember reading that CYK/earley and friends can all be expressed as operations over a semiring
09:27:42 <edwardk> it is limited to the finite use of applicative
09:27:59 <edwardk> tikhon: valiant is a slightly refactored CYK
09:29:56 <edwardk> the idea is that if you were to take something like my reducers package and add a special combinator for 'foo :: Reducer m a => m -> a -> m -> m '    -- we can execute that more efficiently than m `mappend` cons a n   for many monoids including matrix multiplication in the CYK case
09:30:25 <edwardk> so you factor your input into a binary tree with data at the nodes, then feed them through that 'foo' for your appropriate reducer, instead of through the mappend of the monoid
09:30:49 <edwardk> the reason is the monoidal value you inject 'a' into is often a special subset of all your monoidal values
09:31:00 <edwardk> in this case it is a nice diagonal matrix
09:31:11 <edwardk> so the matrices on either side factor through it very nicely
09:31:37 <edwardk> which leads to the polylogarithmic in practice slowdown from chart parsing these rather than the (n^3) of CYK
09:32:01 <danharaj> and yet it still can't parse C++
09:32:02 <edwardk> for the kinds of grammars i care about
09:32:18 <hcaulfield57> I have a list of a datatype that I was passing to getOpt, some of the data constructors accept arguments, some do not. Could someone help me figure out how to extract the arguments from the data constructors that take them. As in -> http://ideone.com/e4RRrm
09:32:30 <edwardk> danharaj: it can giv you a parse tree of all the ambiguous parses in c++, then you can capture all that ambiguity and pass it to your typechecker, letting it whittle down possible worlds
09:32:41 <edwardk> danharaj: elsa/elkhound do precisely this with c++ and a million extensions
09:32:50 <danharaj> edwardk: oh that is cool. I didn't realize CYK handled ambiguity like that.
09:33:11 <danharaj> When I think of parser I think "fails spectacularly on bad input"
09:33:51 <edwardk> i haven't decided if its worth trying to also track the 'try' nodes and see 'why' your parses failed and backtrack to build an explanation based on those
09:34:06 <edwardk> that seems to unfortunately turn too many of my zeroes into non-zeroes
09:34:09 <edwardk> but it may be worth doing
09:35:03 <satc> What is the use of annotating a foreign call as "safe" or "unsafe"? Does compiler performs some optimization with that?
09:36:59 * hackagebot persistent 1.2.3.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.3.0 (GregWeber)
09:37:01 * hackagebot persistent-mongoDB 1.2.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.3 (GregWeber)
09:39:17 <edwardk> i think i found my first bug
09:39:33 <edwardk> timesSingleton and singletonTimes can wind up out of order
09:46:27 <edwardk> using vector-algorithms makes compiling sparse take like 2 minutes though
09:47:22 <notdan> I am trying to solve the first excercise from the Origami programming paper, to prove the fusion law. But I fail to see why it doesn't hold for non-strict functions: http://lpaste.net/91787
09:47:31 <notdan> I don't think I ever use strictness in my argument
09:47:39 <Tehnix> :/ is there any syntax for a HashMap? like [] for lists
09:48:16 <bergmark> Tehnix: M.fromList [(a,b)], and i think there's automatic conversions from [(a,b)] in classy-prelude?
09:48:53 <Tehnix> bergmark: doesn't [(a,b)] restrict the types? like, I can't do [("hey", 2), ("there", "you")] ?
09:49:00 <edwardk> notdan: http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion talks a bit about it in section 3.1
09:49:26 <edwardk> Tehnix: nope. you wind up using fromList
09:49:44 <edwardk> there is some work on overloaded list literals though
09:49:54 <edwardk> which could be abused by some enterprising person to make the list sugar work
09:51:46 <edwardk> Tehnix: you can't make a hashmap out of ("hey",2)  and ("there","you") either
09:51:56 <notdan> edwardk: but it talks only about the totality of the function we are folding with
09:52:02 <notdan> sorry, I still don't get it:(
09:52:26 <Tehnix> edwardk: oh, so a hashmap has to have the same types, like a list?
09:52:30 <enthropy> hcaulfield57: if you look at the definition, you'll see ReqArg (String -> a) String
09:52:33 <edwardk> correct
09:52:41 <Tehnix> edwardk: then it makes more sense :)
09:53:19 <enthropy> hackagebot: so you have to supply a function that takes a String (probably the text that follows the --flag)
09:53:35 <enthropy> err, that's for hcaulfield57
09:54:00 <enthropy> so probably change  data Flag = Parents   to    data Flag = Parents String
09:56:53 <hcaulfield57> enthropy, what's the point of the last String in ReqArg (String -> a) String? I currently have http://ideone.com/ONENT6 it works, but it looks super ugly
09:57:13 <applicative> hcaulfield57: its like a variable thing for the help, no
09:57:14 <applicative>           , Option "m" [] (ReqArg Mode "MODE") []
09:57:21 <applicative> would be natural
09:59:03 <hcaulfield57> applicative: I'm not sure I understand, what purpose does the "MODE" serve?
09:59:43 <applicative> see the examples like Option ['L']     ["libdir"]  (ReqArg LibDir "DIR") "library directory"
10:00:02 <applicative> you are wondering about the role of DIR here
10:00:24 <applicative> or take
10:00:26 <applicative>  Option ['o']     ["output"]  (OptArg outp "FILE")  "output FILE"
10:01:05 <hcaulfield57> It's just documentation?
10:01:27 <carter> edwardk danharaj examples of whic?
10:01:59 <edwardk> carter: my multiplier works. now i want to test it
10:02:05 <edwardk> i figured you have benchmarks
10:02:12 <applicative> so the second argument of ReqArg just says how the type your looking for will look to the user
10:02:13 <applicative> yes
10:02:13 <applicative> similarly the last arg for Option
10:02:13 <carter> ohh
10:02:14 <carter> yes
10:02:16 <applicative> GetOpt is pretty hard; or ugly; or something
10:02:18 <edwardk> its pretty too
10:02:53 <carter> i've some benchmarks where I multiply all 1s matrices of varying sizes
10:02:55 <carter> vs blas
10:03:09 <luite> is there a way to automatically set --enable-executable-dynamic from a cabal file?
10:03:44 <dcoutts> luite: no, it's the person building the package that gets to decide things like that, not the package author
10:04:01 <dcoutts> or if those are the same person, then it's you in your role as the builder :-)
10:04:08 <edwardk> carter: great. feel like trying to add sparse to your suite and compare it off?
10:04:18 <carter> sure
10:04:20 <luite> dcoutts: hmm, that's a tad annoying since i want to decide it for them :p
10:04:22 <dcoutts> luite: just as it's the builder who decides where to install etc
10:04:30 <hcaulfield57> applicative: Okay, yea that makes sense, still seems odd to have it there. I wish I knew if there was a way to avoid the ugly getMode function I had to use.
10:04:41 <edwardk> with the exposed API you can even do a fast path test of Mat U.Vector ()     for the boolean matrix case you have there
10:04:42 <dcoutts> luite: that's tough, it's really up to them how/where they build it
10:04:50 <edwardk> to see how much carrying around the boxed/unboxed values matters
10:04:56 <dcoutts> luite: why btw?
10:05:18 <luite> dcoutts: (the problem is that the functionality of dynamically linked things that use the GHC API is different, it can load .so files, a static executable can't)
10:05:21 <carter> edwardk: is the newest one on hackage? or shoudl i just clone locally and install?
10:05:25 <edwardk> yeah
10:05:29 <edwardk> should be current
10:05:34 <carter> ok
10:05:39 <edwardk> only thing missing is i _just_ started a quickcheck suite
10:05:45 <carter> cool
10:05:47 <dcoutts> luite: for things where it requires give & take, we usually solve it with constraints specified by the author
10:05:53 <carter> sounds like something i'll be able to steal from
10:06:14 <dcoutts> luite: so that's an interesting one
10:06:35 <applicative> hcaulfield57: maybe optparse-applicative? http://hackage.haskell.org/package/optparse-applicative http://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html ?
10:06:35 <edwardk> right now i figured i'd just make a little code to test that the matrix multiplication yields the same result as linear
10:06:45 <carter> maekse sense
10:07:01 <applicative> hcaulfield57: myself, I always use the depraved readargs package ...
10:07:06 <edwardk> since we can use the Map Word32 (Map Word32 a)   sparse matrix in linear
10:07:09 <luite> dcoutts: perhaps i can detect it at runtime, and load static libs for template haskell, but that would probably require a bit of GHC API hacking
10:07:23 <carter> should be MUCH fster than containers
10:07:29 <edwardk> =)
10:07:40 <dcoutts> luite: is that new? We statically like our ghc api apps and they can load packages
10:07:48 <edwardk> i figured i'd wait until you woke up to tackle benchmarks, so i'm REALLY curious how it does
10:07:58 <carter> ok
10:07:59 <carter> thanks
10:08:09 <luite> dcoutts: statically linked GHC probably
10:08:14 <luite> so it loads the .a in ghci, not the .so
10:08:30 <edwardk> it does take its sweet time compiling though
10:08:50 <dcoutts> luite: and you can't do the same?
10:08:52 <edwardk> i'm also curious how much fllvm improves things
10:09:51 <luite> dcoutts: well the GHC API appears to choose, HEAD is built with dynamic programs by default, and it fails if ghcjs is linked statically and tries to run template haskell
10:10:06 <luite> perhaps it's possible to override, but i'd have to dig a bit :)
10:10:31 <dcoutts> luite: oh I think you just need to tell it to build static files, rather than only dyn_o
10:10:59 <hcaulfield57> applicative: Okay, I look in at some of the alternatives, there has to be a non stupid way to do it. Thanks for the help!
10:12:03 <hcaulfield57> It looks like getOpt passes "DIR" or whatever if you don't give a ReqArg an actual argument on the command line
10:12:25 <luite> dcoutts: oh it does build the .a file, just doesn't load it when template-haskelling
10:12:29 <carter> edwardk: i'll bench in the dense case
10:12:31 <banister> hcaulfield57: dont do anything phoney
10:12:36 <edwardk> carter: sounds good
10:13:05 <hcaulfield57> banister: My whole program is phony haha
10:13:18 <banister> hehe
10:13:33 <banister> damn, i knew something didnt look right about my spelling of phony
10:14:07 <hcaulfield57> banister: Yea, misspelling phony is one of the most depressing things, you wouldn't believe it
10:14:15 <dcoutts> luite: mm, you may be right then, that you can only do it now if the prog is dynamically linked, in which case I can see that it makes sense to want to be able to specify a constraint on only building the exe with dynamic linking
10:14:49 <dcoutts> luite: can you file a cabal ticket, we'll need to think about how to specify this and other similar somewhat platform-specific constraints
10:15:03 <luite> dcoutts: just printing an error (with some instructions) wouldn't be too bad in the short term though
10:15:12 <dcoutts> aye
10:15:23 <luite> ok, the official tracker is on github now?
10:17:12 <clahey> dmwit_, So, you pointed me to that HashLife article last week.
10:17:21 <clahey> dmwit_, Now I want to try implementing it for haskell practice.
10:18:02 <clahey> dmwit_, But I don't really understand how you would implement the hash bits.
10:18:31 <clahey> As I create new nodes, how do I check if the node already exists?
10:19:35 <clahey> More to the point, if I create a new node and it doesn't exist, how do I add it to the hash without side effects?
10:24:37 <carter> @tell edkwardk can't intall sparse cause theres a problem with lens
10:24:37 <lambdabot> Consider it noted.
10:24:43 <edwardk> wut
10:25:07 <edwardk> what happens?
10:25:13 <edwardk> is it that sparse wants 3.10?
10:25:18 <edwardk> or is there an issue in 3.9?
10:25:48 <carter> 3.9 issue
10:25:54 <edwardk> lpaste?
10:26:42 <carter> https://github.com/ekmett/lens/issues/324
10:26:54 <danr> any package to derive bi{functor,traversable} ?
10:27:09 <danharaj> oh we had that problem with lens and reflection at work
10:27:32 <danharaj> well, at least one of our .cabal's says we have that problem ;)
10:27:33 <carter> danr oh?
10:27:37 <edwardk> that one is new on me
10:27:39 <danharaj> I wasn't around for it personally.
10:27:53 <carter> all those deps just for sparse matrix mult toooo
10:27:55 <edwardk> if you reinstall reflection and cabal install --force lens does it happen?
10:27:56 <carter> :)
10:28:07 <edwardk> the package says its a playground
10:28:11 <edwardk> i didn't want to write fortran
10:28:15 <carter> :P
10:28:17 <edwardk> so i wrote code i wanted to read
10:29:08 <carter> fair
10:29:26 <carter> no dice
10:29:30 <carter> same problem
10:29:51 <edwardk> if you try to cap at an earlier version of reflection or lens?
10:29:59 <edwardk> i've got no idea what is happening to you there
10:30:10 <danharaj> it should work if you build with reflection<1.3
10:30:13 <edwardk> so i'm stuck trying to debug by proxy
10:30:47 <carter> so reflection 1.2.0.1 ?
10:30:52 <edwardk> danharaj: i would love a more detailed understanding of what the heck went wrong
10:31:06 <danharaj> edwardk: So would I. All I know is that in one of our cabals we have this line:
10:31:07 <Fuuzetsu> any good way to grab a bunch of packages off hackage? I need some source files.
10:31:07 <danharaj> -- WORKAROUND: constrains broken dependency of 'lens'. Can be removed when a fix is released.
10:31:07 <danharaj>     reflection < 1.3,
10:31:13 <danr> carter: I'm looking for such a package
10:31:21 <carter> what package?
10:31:28 <danr> a package to derive bifunctor and bitraversable
10:31:37 <carter> i'm the wrong person to ask
10:33:00 <carter> doh
10:33:01 <carter> lookupSymbol failed in relocateSection (relocate external)
10:33:11 <carter> lookupSymbol failed in relocateSection (relocate external)
10:33:11 <carter>  /Users/carter/Library/Haskell/ghc-7.6.3/lib/profunctors-3.3.0.1/lib/HSprofunctors-3.3.0.1.o: unknown symbol `_comonadzm3zi0zi2_ControlziComonad_zdfCategoryCokleisli_info'
10:33:57 <edwardk> carter: i'm going to go out on a limb here and say your whole environment is screwed up =P
10:34:01 <danr> carter: ok. you wrote `oh?' to me :)
10:34:06 <carter> nope
10:34:08 <jfischoff> _comonadzm3zi0zi2_ControlziComonad_zdfCategoryCokleisli_info that is a great name :)
10:34:17 <applicative> oh I keep that on all my symbol tables
10:34:26 <enthropy> preflex: zdec _comonadzm3zi0zi2_ControlziComonad_zdfCategoryCokleisli_info
10:34:26 <preflex>  _comonad-3.0.2_Control.Comonad_$fCategoryCokleisli_info
10:34:33 <edwardk> well, i don't do anything that can cause that sort of crap. =)
10:34:42 <carter> now to try doing it sandboxed
10:34:58 <applicative> edwardk, it has your paw prints all over it, that symbol
10:36:31 <k0ral> Hello, I'm looking for a f :: (Monad m) => Setter' a b -> (b -> m b) -> a -> m a ; it would behave like 'over', but with a monad m in the way; is there such a thing in lens, or should I write it myself ?
10:36:45 <edwardk> :t lifted
10:36:46 <lambdabot> (Monad m, Settable f) => (a -> f b) -> m a -> f (m b)
10:36:59 <edwardk> oh
10:37:01 <edwardk> sorry
10:37:05 <edwardk> :t mapMOf
10:37:06 <k0ral> (I guess I could have asked with Functor instead of Monad)
10:37:23 <haasn> edwardk: mapMOf ≈ id ?
10:37:33 <haasn> oh right, it does the WrappedMonad thing
10:37:34 <edwardk> actually, wait
10:37:46 <edwardk> you can't use a setter like that. it doesn't let you run a monadic effect.
10:37:54 <edwardk> you can use a traversal like that, that is what mapMOf does
10:37:56 <carter> if it works in sandbox, i'll wipe my user db
10:38:22 <k0ral> looking at mapMOf
10:38:58 <k0ral> @hoogle mapMOf
10:38:58 <lambdabot> No results found
10:39:11 <edwardk> :t mapMOf traverse
10:39:11 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
10:39:37 <edwardk> > mapMOf both (\x -> [x,x+1]) (1,2)
10:39:39 <lambdabot>   [(1,2),(1,3),(2,2),(2,3)]
10:39:45 <Rarrikins> Is there any way to have GHC set certain RTS options as defaults in a compiled program rather than needing to provide the switches to the executable each time?
10:39:55 <carter> yup
10:40:06 <haasn> edwardk: I wonder if there's a way to improve “xs & choosing id (_head._2).branches %~ (t:)”
10:40:26 <edwardk> haasn: blech
10:40:29 <carter> crazy theory: clang vs gcc
10:40:35 <danharaj> :t blech
10:40:35 <lambdabot> Not in scope: `blech'
10:40:38 <carter> i probably had some older codes that still used gcc for the asm
10:40:38 <danharaj> is that a new combinator?
10:40:41 <edwardk> carter: sounds plausible. so it was your enviornment?
10:40:53 <carter> does lens take a while to build?
10:40:54 <edwardk> danharaj: hahahaha
10:40:57 <haasn> edwardk: in particular, the %~ (t:) bit strikes me as ugly :)
10:41:16 <edwardk> let blech = choosing id (_head._2).branches ...
10:41:21 <haasn> isn't there some Cons thing that could do this?
10:41:34 <edwardk> not that you can use there
10:41:51 <k0ral> next question: what of f :: (Monad m) => Setter' a b -> (b -> m ()) -> a -> m a ? (I definitely need a to be returned to be able to compose functions)
10:42:43 <carter> ok
10:42:44 <carter> cool
10:42:46 <carter> it built
10:44:04 <haasn> k0ral: I could provide you a Setter' (Const () Void) Void and a (Void -> Const Void ()) and that would have you write me Const () Void -> Const Void Void
10:44:14 <haasn> so that can't be possible, in general
10:44:20 <haasn> sorry for confusing types
10:44:42 <edwardk> carter: it is just fun to play with from the repl
10:45:09 <haasn> or uh
10:45:11 <edwardk> the need for constant signatures is a bit annoying though
10:45:12 <haasn> Const Void (Const () Void) -- w/e
10:45:28 <k0ral> haasn: I'm not able to decrypt that :)
10:45:33 <haasn> k0ral: let me demonstrate
10:45:45 <fedvasu> hi guys
10:45:56 <fedvasu> a recommendation request
10:46:25 <fedvasu> did any of you guys looked into "Elements of programming " by stepanov
10:46:44 <fedvasu> how useful is this book for a budding CS undergrad
10:46:47 <fedvasu> ??
10:46:48 <edwardk> k0ral: Const a _ ~ a   so its 'Void' plus noise, so its uninhabited
10:47:01 <carter> edwardk: i'm going to go melt my laptop doing sandboxed installs of things
10:47:02 <fedvasu> is it worth giving it a shot??
10:47:03 <carter> brb in a bit
10:47:18 <edwardk> carter: kk
10:48:45 <carter> it might be simpler to just add the benchmark stuff to your code
10:49:03 <carter> than add your code to my benchmark suite
10:49:08 <edwardk> fedvasu: parts look interesting if you don't let the c++ warp your brain
10:49:19 <edwardk> carter: i'm okay with that if you have code you want to throw at me
10:50:02 <fedvasu> edwardk : shall I read it after or before types and programming languages by Pierce
10:50:07 <carter> i'll give you a version that lets you bench on you mac with no exernal deps
10:50:09 <carter> vs apple blas
10:50:14 <fedvasu> currently I have to decide between either
10:50:15 <edwardk> fedvasu: its very much in the style of 'weakest precondition' reasoning, which i confess almost burned me out on programming before i found haskell
10:50:19 <k0ral> I can use mapMOf with (b -> m ()), as long as I find some g :: (b -> m ()) -> b -> m b to intercalate
10:50:24 <edwardk> fedvasu: after
10:50:43 <fedvasu> edwardk: thank you!
10:50:47 <k0ral> @hoogle (a -> m ()) -> a -> m a
10:50:47 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:50:48 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:50:48 <lambdabot> Control.Seq withStrategy :: Strategy a -> a -> a
10:50:59 <carter> edwardk: is being able to bench on your mac good enough?
10:51:04 <edwardk> sure
10:51:06 <carter> ok
10:51:07 <carter> awesome
10:51:11 <carter> then i have codes for you soon
10:51:22 <edwardk> just feel free to toss it in the sparse repo if you want
10:51:30 <tikhon> weakest precondition? is that like the axiomatic semantics stuff?
10:51:48 <carter> sure thing
10:51:50 <carter> just chekcing first
10:51:55 <edwardk> tikhon: hoare logic/separation logic and what have you
10:51:58 <tikhon> aha
10:52:07 <tikhon> I didn't really like that very much when I learned about it
10:52:22 <tikhon> I mean, it makes sense, but it's just not very satisfying
10:52:36 <edwardk> yeah. like i said, it almost put me off programming for good in a fit of depression that that was the only tool i had for reasoning about code correctly in the future ;)
10:53:05 <tikhon> it's a very indirect way to talk about the meaning of a program
10:53:12 <edwardk> fortunately i found type theory immediately thereafter
10:53:27 <danharaj> Kleisli Arrows of Outrageous Fortune makes it fit neatly into monadic programming.
10:53:40 <haasn> k0ral: oh, wait, the Monad restriction is actually strong enough to prevent the kind of thing I was worried about
10:53:42 <danharaj> I bet with some type class magic you could have your preconditions inferred :P
10:54:12 <tikhon> danharaj: that sounds like undecidable type class magic to me (but I could be wrong)
10:54:21 <edwardk> actually it still makes me sad
10:54:29 <k0ral> haasn: I wouldn't have been able to understand your demonstration anyway :)
10:54:45 <edwardk> there is YNot for working with this sort of thing in Coq. and hoare type theory, etc.
10:54:50 <edwardk> its all terrible to use in practice
10:54:59 <tikhon> yeah
10:55:09 <tikhon> I learned about the basic cases with it, which were easy enough
10:55:18 <tikhon> but I understand that once you throw in pointers, it becomes a real mess
10:56:37 <Cho0fool> Hello, i'm quite a new to Haskell.
10:56:48 <edwardk> I figure the best example I can come up with was a NEPLS back in ~2008 or so. Greg Morisett and taken on both Adam Chlipala and Mattieu Sozeau as post-docs to work on YNot. Between them they were able to prove a very painfully simple web app was consistent if the database it talked to was and a million side-conditions held.. after several months in a complete waterfall development cycle
10:57:02 <edwardk> that is a LOT of brainpower devoted to such a task
10:57:49 <Cho0fool> And i want to build something usefull, actually i alreade have an idea what, but can you help me wqith libraries recomendations?
10:57:56 <edwardk> and the result is very much unsatisfying to me. i realize a good part of that time was building up the tools and vocabulary of YNot, but still
10:58:02 <b2coutts> Cho0fool: what do you want to build?
10:58:39 <edwardk> Cho0fool: sure
10:58:56 <Cho0fool> b2coutts: Git statistics tool.
10:59:25 <Cho0fool> First of all i need to get all commits from repo, quick googlign gave me this http://stackoverflow.com/questions/6609643/haskell-library-to-manipulate-a-git-repo .
11:00:02 <Cho0fool> And i'm not sure which library should i use.
11:00:28 <edwardk> Cho0fool: look at gitlib by johnw, and for statistics, there is an excellent statistics package from bos
11:00:50 <applicative> Cho0fool: i was gonna say, johnw is frequently around here so you might get some decent pointers.
11:00:51 <edwardk> but if you just want to summarize you probably don't need all the statistics stuff
11:00:51 <Cho0fool> edwardk: http://hackage.haskell.org/package/hlibgit2 That one?
11:01:05 <edwardk> Cho0fool: sounds right.
11:01:08 <applicative> gitlib
11:01:15 <edwardk> i just know it from talking to john, not from the code
11:01:15 <edwardk> =)
11:01:32 <applicative> Cho0fool: http://hackage.haskell.org/package/gitlib
11:01:58 <edwardk> Cho0fool: thats just part of the whole it seems. https://github.com/fpco/gitlib
11:02:05 <edwardk> see all the subprojects
11:02:37 <Cho0fool> applicative, edwardk, thank you guys!
11:03:05 <applicative> Cho0fool: oh here's the github repo, fwiw https://github.com/fpco/gitlib
11:03:11 <applicative> bah
11:03:24 <carter> tikhon edwardk : i worked on ynot one summer, got nothing done
11:03:28 <carter> that stuff is hard
11:03:57 <tikhon> more importantly--to me--it just doesn't seem fun
11:04:14 <tikhon> in the way that denotational semantics are fun, even if they're less immediately useful
11:05:03 <tikhon> also correctness in general is hard, especially if you try to prove a program correct instead of trying to construct a correct program in the first place
11:06:31 <tikhon> what did you do with YNot?
11:09:29 <clahey> edwardk, Any suggestions about what I was asking above about hash tables?
11:09:51 <clahey> Is this a case where you use State?
11:09:53 <carter> tikhon: agreed, wasn't fun
11:09:58 <carter> ilterally got nothing done
11:10:12 <carter> adam chlipala kept on automating away everything i got started on
11:10:17 <carter> super cool guy
11:10:20 <carter> but yeah
11:10:27 <clahey> Or anyone making a suggestion?
11:10:46 <carter> clahey: restate your question please
11:11:38 <clahey> carter, So, there's an algorithm I've found called HashLife.
11:11:48 <carter> ok
11:11:52 <clahey> It's a way to implement Life using some cool hash table stuffs.
11:11:52 <carter> link?
11:11:56 <carter> ok
11:12:03 * hackagebot scat 1.0.0.0 - Generates unique passwords for various websites from a single password.  http://hackage.haskell.org/package/scat-1.0.0.0 (RomainEdelmann)
11:12:04 <clahey> http://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478
11:12:06 <carter> don't you want morton order?
11:12:17 <clahey> What's morton order?
11:12:31 <carter> clahey: you may want to use edwark's new lib, sparse :)
11:12:43 <carter> it does the right neighbhood gridding
11:12:45 <carter> as a matrix
11:13:03 <carter> doesn't do the sharing that the dobbs article alludes to
11:13:03 <clahey> Perhaps.  I can look into it.
11:13:17 <clahey> But the question is about how you write a function with memoization.
11:13:26 <carter> depends on how you want to use it
11:13:35 <carter> is the most accurate short answer
11:14:04 <clahey> I want to have function :: a -> b   and if I call    function a + function a, for it to only compute one time.
11:14:23 <clahey> It's actually eventually going to be :: a -> b -> a, but that's a separate issue.
11:14:56 <clahey> Or maybe it's not, as that is quite close to the function type used for folding.
11:15:03 <carter> clahey: unsafeperformIO :)
11:15:05 <tikhon> there's a few nice libraries out there for memoization
11:15:12 <carter> tikhon yup
11:15:17 <carter> not familiar with them though :)
11:15:20 <tikhon> eh, unsafeperformIO is tricky
11:15:22 <clahey> carter, Ugh.
11:15:27 <tikhon> try memo-combinators or something
11:15:34 <carter> any of the good memoization libs
11:15:39 <carter> have to do unsafe perform io internally
11:15:48 <tikhon> for certain values of "good"
11:15:52 <danharaj> useful
11:15:58 <clahey> I'm fine with using libraries that use unsafe perform io internally.
11:16:00 <tikhon> also, if it's in a library written by somebody else, it's probably fine
11:16:29 <tikhon> I remember seeing benchmarks for different memoization strategies
11:16:31 <clahey> I suppose I could change the function to be :: a -> b -> State a, but I don't love it.
11:16:33 <gertc> how do you include a source directory in ghci named src-unix? tried -isrc-unix
11:16:34 <tikhon> lets see if I can find that file again
11:16:44 <clahey> tikhon, That would be great.
11:16:53 <carter> http://hackage.haskell.org/package/memoize-0.6 by jesse tov is probably solid
11:16:55 <carter> nice smart dude
11:17:12 <tikhon> ooh, it used to be on hpaste
11:17:20 <tikhon> and just changing the address to lpaste doesn't seem to work
11:17:25 <clahey> The other issue I have is that I'm not sure how to make the comparison and/or hash function that the memoization library probably requires fast.
11:17:33 <tikhon> wait, never mind
11:17:34 <clahey> But I will keep thinking about it.
11:17:37 <carter> clahey: benchmarking :)
11:17:51 <carter> clahey: i now favor one of the cooler edwardk engineering tricks
11:17:52 <tikhon> http://lpaste.net/70413
11:18:00 <carter> come up with 2-3 ideas, try them all , compare them
11:18:03 <tikhon> I don't know if these results are any good, but there you have it
11:18:39 <haasn> what's the canonical function to split a list into groups of length n?
11:18:54 <tikhon> haasn: there's chunks from Data.List.Split
11:18:59 <tikhon> but nothing nice in the standard library
11:19:07 <haasn> tikhon: thanks, that's the one I was looking for
11:19:44 <tikhon> oh, it's just chunk (not chunks)
11:19:56 <tikhon> also called splitEvery
11:20:50 <tikhon> honestly, not having this and splitOn is one of the most mysterious shortcomings of the standard library
11:21:13 <tikhon> we have the special cases words and lines but nothing else!
11:23:20 <haasn> hmm
11:23:23 <enthropy> unfoldr together with splitAt might be the shortest way to write it
11:23:32 <haasn> concatMap (view both) .: zip `on` chunksOf 80 -- I wonder if there's a cleaner way to write this :)
11:23:48 <enthropy> > unfoldr (\x -> case x of [] -> Nothing; _ -> Just (splitAt 5 x)) "hello world"
11:23:49 <lambdabot>   ["hello"," worl","d"]
11:29:21 <haasn> or (toListOf both) actually
11:32:12 <edwardk> clahey: can't find it in scrollback
11:33:27 <Orxata_> Hello
11:34:12 <clahey> edwardk, I was trying to figure out how to do memoization in haskell.
11:34:26 <clahey> In a pure fashion.
11:34:31 <clahey> I understand a little bit better.
11:34:43 <clahey> I see how to do it for fairly simple parameters.
11:35:06 <clahey> For use in implementing HashLife.
11:35:16 <clahey> But the parameters to the HashLife functions are fairly complicated.
11:35:35 <arkeet> the answer is monads, clearly.
11:35:48 <clahey> I think the answer might be to put it in a Monad.
11:35:55 <arkeet> :-)
11:35:57 <clahey> Either State or IO depending on how I want to implement the hash table.
11:36:09 <arkeet> IO? I thought you said pure.
11:36:09 <arkeet> :p
11:36:19 <clahey> I want to do it pure, of course.
11:36:27 <clahey> But who knows if it will happen.
11:38:13 <clahey> edwardk, So I was asking about writing such a pure function.  If there's a memoization library that uses unsafePerformIO with a hash table, I might use that.
11:38:17 <clahey> Or write one of course.
11:39:07 <edwardk> clahey: intern
11:39:11 <carter> clahey: we linked you to one
11:39:22 <clahey> carter, I looked at two, but neither seemed to do hash table stuffs.
11:39:26 <clahey> Maybe I misread one of them.
11:39:40 <carter> clahey: memoziation is unrelated to hashtables
11:39:41 <edwardk> also memo-combinators and representable-tries provide a purer memoization function
11:39:49 <carter> ish
11:40:01 <edwardk> clahey: lets take the easiest example of memoization
11:40:05 <edwardk> and work up from there
11:40:16 <edwardk> say you have a function from (Bool -> a) you want to memoize
11:40:18 <edwardk> how can you do it?
11:41:03 <clahey> edwardk, I believe I understand that one.
11:41:04 <edwardk> lets make a data type that is 'represented' by Bool. that is to say some f, such that f a ~ is isomorphic to (Bool -> a)  but where we have a place to put each of the 'a's for later perusal.
11:41:08 <edwardk> data Pair a = Pair a a
11:41:49 <clahey> Well, at least the way memocombinator does it.
11:42:04 * hackagebot MFlow 0.3.1.1 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.1.1 (AlbertoCorona)
11:42:07 <edwardk> tabulate :: (Bool -> a) -> Pair a; tabulate f = Pair (f False) (f True); index (Pair a b) False = a; index (Pair a b) True = b
11:42:19 <edwardk> then index . tabulate   memoizes the function it is given
11:42:32 <edwardk> by making up a place to hold each answer and looking there on subsequent evaluations
11:42:42 <edwardk> you can generalize this of course to any polynomial domain
11:43:25 <clahey> Polynomial domain/
11:43:27 <clahey> ?
11:43:32 <edwardk> intern uses a different approach to hash-cons values up from scratch so you ensure there only ever exists one value that compares for structural equality
11:43:57 <edwardk> clahey: things build up out of +, *, 0, 1    where + = Either, * = (,), 0 = Void, 1 = ()
11:44:01 <edwardk> Bool = 1 + 1
11:44:58 <clahey> I get how you can generalize that to any polynomial domain, but I believe that what I'm looking at isn't a polynomial domain.
11:45:17 <edwardk> the memo combinator approach can be viewed as just reading off the laws of algebra. using Bool -> a     as a^Bool, then trying to break a^(1+1)  into a^1 * a^1 = a * a = Pair a
11:45:39 <edwardk> sure, then you need to do bad things ;)
11:46:12 <edwardk> clahey: have you read: http://research.microsoft.com/en-us/um/people/simonpj/Papers/weak.htm ?
11:46:16 <clahey> I haven't actually written out the type until now, but I believe that it is :: Grid = Recurse Grid Grid Grid Grid | Base Bool Bool Bool Bool
11:46:39 <edwardk> clahey: and you want to ensure you have perfect sharing in grid parts?
11:47:07 <clahey> Yes.
11:47:09 <edwardk> you can get it a couple of ways
11:47:26 <edwardk> one is you can use something like intern, but that'll leaf over the entire life of your program, because it can't garbage collect ever
11:47:28 <clahey> And I want to memoize functions :: Grid -> Int -> Grid
11:47:40 <edwardk> another is to use data-reify to recover sharing in a particular Grid.
11:48:24 <clahey> Leaving around the memoization would not be the end of the world, as it is the entire point of the program.  Though that isn't terribly pretty.
11:48:37 * jfischoff is learning
11:48:50 <edwardk> are your grids cyclic or acyclic?
11:49:17 <clahey> Maybe memoize isn't the right word, but I want a function :: (Grid -> Int -> Grid) -> Grid -> Int -> Grid that is faster the second time it's called with the same values.
11:49:28 <edwardk> *nods*
11:49:34 <clahey> In the type system you mean, acyclic.
11:49:54 <edwardk> i mean will you have a grid that is a 'sub-grid'  of itself ever
11:50:04 <clahey> Yeah, acyclic.
11:50:09 <clahey> That's what I thought you meant.
11:50:11 <edwardk> x = Grid x x x (Base False False False Fase)
11:50:12 <edwardk> ah good
11:50:28 <edwardk> then intern can be used
11:50:31 <clahey> In fact, the depth is consistent across a grid.
11:50:49 <edwardk> heh did you see my reply about matrix grammars the other day?
11:51:08 <clahey> There's never even Grid (Base ...) (Grid ...) ...
11:51:17 <clahey> I don't remember it, no.
11:51:47 <edwardk> clahey: http://programmers.stackexchange.com/questions/207665/haskell-memory-efficiency-which-is-the-better-approach/207781#207781
11:51:54 <edwardk> that is almost exactly your problem
11:52:28 <edwardk> ou may want to look up the tunes.org log of the channel from yesterday or maybe the day before and look for a conversation between me and "Dennis".
11:52:39 <edwardk> it goes into a lot of detail about exactly what you want to do right now
11:52:52 <clahey> Sweet.
11:53:06 <edwardk> .. and amusingly right after that conversation i started writing 'sparse', my current toy obsession
11:53:35 <edwardk> and then spent a bunch of time trying to figure out how to multiply matrix grammars directly
11:53:44 <tertl3> i cant find any documentation for the ">>" operator in Parsec
11:53:53 <Cho0fool> Hello again, http://hackage.haskell.org/packages/archive/gitlib/2.0.1.0/doc/html/Git-Tutorial.html seems a bit outdated, can't figure out how to build that RepositoryFactory https://github.com/fpco/gitlib/blob/master/gitlib/Git/Types.hs#L108
11:53:55 <edwardk> where a matrix grammar is more or less your grid if you made the 'tree' more explicit
11:54:09 <edwardk> e.g. make it more obviously polynomial
11:54:40 <Cho0fool> I mean it's quite a large record, maybe i'm doing something wrond by trying to make it by hand?
11:54:49 <edwardk> you are interested in the part i was talking about when it comes to reifying the matrix into the grammar, rather than the grammar dennis is talking about
11:55:20 <edwardk> johnw: Cho0fool has some gitlib questions
11:55:35 <edwardk> figured it was best to ping him in case he's around
11:55:52 <Cho0fool> edwardk: Thank you.
11:56:16 <edwardk> tertl3: x >> y = x >>= \_ -> y
11:56:26 <edwardk> tertl3: its 'do this, then that'
11:56:46 <tertl3> ahh ok, ty edwardk
11:57:04 <pyrtsa> I wrote a few notes about my troubles with OS X, Clang Beta and Haskell Platform (or Cabal Install, or the text package), if anyone finds it relevant: https://gist.github.com/pyrtsa/6213784
11:57:34 <tertl3> just a small issue but the book tells me to check with each monad to see what it does in each edwardk
11:57:57 <pyrtsa> geekosaur, bscarlet, applicative ^
11:57:59 <tertl3> ahh well I think I understand
11:58:15 <edwardk> > [1,2] >> [3,4]
11:58:16 <lambdabot>   [3,4,3,4]
11:59:10 <tertl3> [1,1] >> [3,4]
11:59:34 <tertl3> > [1,1] >> [3,4]
11:59:35 <lambdabot>   [3,4,3,4]
11:59:42 <edwardk> > [ y | x <- [1,2], y <- [3, 4] ]
11:59:43 <lambdabot>   [3,4,3,4]
11:59:47 <edwardk> that is perhaps a bit more explicit
11:59:56 <tertl3> that is confusing :P
11:59:57 <edwardk> and you can see there that its just ignoring the x
12:00:27 <tertl3> ahh yes
12:00:30 <tertl3> makes sense now
12:00:31 <edwardk> > [1,2] >>= const [3,4] = concat [[3,4],[3,4]] = [3,4,3,4]
12:00:32 <lambdabot>   <hint>:1:23: parse error on input `='
12:01:08 <clahey> @src (>>)
12:01:09 <lambdabot> m >> k      = m >>= \_ -> k
12:01:43 <tertl3> i guess what he was saying that it depends on what m and k are
12:02:19 <clahey> In a parser, it usually parses m, ignoring the result, then parses k, returning the result.
12:02:29 <clahey> Actually, don't think of it as doing one and then the other.
12:02:41 <tertl3>  "In general, bind will have wildly different effects in different monads; it's intended as a general way to structure computations, and so needs to be general enough to accommodate all the different types of computations"
12:02:51 <ParahSailin> should i expect this ffi marshalling of a c struct to work? http://lpaste.net/91788
12:02:56 <tertl3> i think the "wildly" threw me
12:03:01 <ParahSailin> or is there additional code i have to write
12:03:20 <edwardk> tertl3: well, the [1,2] >> [3,4] example wildly violated your expectations ;)
12:03:37 <tertl3> #t
12:03:44 <clahey> It parses a string consisting of a string parsable by m followed by a string parsable by k, returning the result that would have been returned by k parsing the second part of the string.
12:03:51 <tertl3> ok im sorted :)
12:04:08 <heatsink> I don't think you can pass C structs by value to Haskell code
12:04:19 <heatsink> At least, I've never tried it
12:04:39 <c_wraith> heatsink: that's what the Storable class is for.
12:05:09 <c_wraith> heatsink: I mean, you have to use a pointer with Storable, but it gets you a copy of the data as a haskell type
12:05:29 <c_wraith> heatsink: which is all that you really care about when passing by value.
12:06:29 <heatsink> c_wraith, if you use a pointer, aren't you passing by reference?
12:07:00 <ParahSailin> c_wraith: is that pase above a complete use of storable to do this?
12:08:17 <c_wraith> ParahSailin: that's not going to work at all.  Storable is for *copying* the data.
12:08:25 <c_wraith> ParahSailin: it looks like you're trying to use it in-place
12:08:59 <c_wraith> ParahSailin: which will break whenever someone thinks they can use that same memory on the C side for...  anything at all.
12:09:18 <heatsink> It's being copied, c_wraith
12:09:40 <heatsink> The same as, if I have a C function int foo(int x) {return x;}, it returns a copy of x
12:10:05 <c_wraith> heatsink: on the stack. As soon as the stack space is re-used for something else, goodbye to that memory
12:10:38 <ParahSailin> c_wraith: so i should be allocating a pointer in haskell RTS and passing that to this foreign import?
12:10:46 <heatsink> If it's returned on the stack, the caller is responsible for allocating memory
12:10:54 <heatsink> yes ParahSailin
12:11:03 <c_wraith> ParahSailin: you should be using peek
12:11:04 <bscarlet> pyrtsa: you should talk to carter about your OS X issues.
12:11:31 <heatsink> There's a convenience function 'alloca' for that
12:12:03 <carter> eh?
12:12:05 * hackagebot clientsession 0.9.0.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.0.1 (MichaelSnoyman)
12:12:06 * hackagebot mime-mail 0.4.2.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.2.1 (MichaelSnoyman)
12:12:08 * hackagebot network-conduit-tls 1.0.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.1 (MichaelSnoyman)
12:12:11 * hackagebot resourcet 0.4.7.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.7.2 (MichaelSnoyman)
12:12:13 * hackagebot yaml 0.8.4.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.4.1 (MichaelSnoyman)
12:12:17 <carter> pyrtsa: for now just switch back to xcode 4.6
12:12:23 <carter> dl the cli tools again
12:12:26 <carter> and run the installer
12:12:51 <heatsink> ParahSailin: You can use alloca (\ret_ptr -> foreignCall ret_ptr arg1 arg2 >> peek ret_ptr)
12:13:09 <bscarlet> carter: look at the gist. pyrtsa already has a workaround.
12:13:14 <carter> Uyeah
12:13:22 <carter> oh
12:13:24 <carter> ok
12:13:29 <carter> nooo
12:13:30 <heatsink> and the foreign function should be changed to write its result to ret_ptr
12:13:30 <carter> thats bad
12:13:35 <carter> thats really bad
12:13:46 <bscarlet> carter: but you should share your knowledge of the larger fix situation
12:13:47 <carter> gcc doesn't know about os x specific things
12:13:51 <carter> yes
12:13:52 <carter> for now
12:13:56 <carter> don't install xcode 5
12:14:10 <carter> theres a nice fix if you use cabal HEAD
12:14:13 <carter> and cabal install head
12:15:22 <carter> i'll document the solution systematicly once cabal 1.18 is out
12:15:37 <kuribas> In the "Exposed-Modules" line in the cabal file, does a module include nested modules, or do they all need to be added manually?
12:16:28 <carter> bscarlet: you're right
12:16:29 <callen> yesod-platform-1.2.3 depends on language-javascript-0.5.7 which failed to
12:16:48 <callen> ^^ it's in an otherwise empty cabal-dev sandbox, what gives?
12:17:15 * hackagebot xml-conduit 1.1.0.6 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.6 (MichaelSnoyman)
12:17:17 * hackagebot wai-extra 1.3.4.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.3 (MichaelSnoyman)
12:17:19 * hackagebot warp 1.3.9.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.9.1 (MichaelSnoyman)
12:17:21 * hackagebot http-conduit 1.9.4.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4.2 (MichaelSnoyman)
12:23:21 <callen> Why does cabal still break all the damn time. In a fresh cabal-dev -> yesod-platform-1.2.3 depends on language-javascript-0.5.7 which failed to
12:23:52 <danharaj> that's yesod-platform breaking
12:24:05 <kuribas> So, do I need to list all modules in the exposed-modules line recursively?
12:25:56 <ParahSailin> this should not be a 404 http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html#t:ForeignPtr
12:26:04 <luite> callen: that's because language-javascript requires happy
12:26:15 <luite> callen: cabal doesn't track those programs
12:26:36 <Cho0fool> callen: I though you're huge Haskell hater.
12:26:56 <callen> luite: well how do I get it to compile?
12:27:05 <Cho0fool> callen: Install happy.
12:27:10 <luite> callen: cabal install happy
12:27:11 <callen> but not with cabal?
12:27:13 <callen> er...
12:27:20 <callen> why isn't that a dep in the project?
12:27:30 <luite> because it's not a library but an executable
12:27:44 <Cho0fool> I usually install it via distro's package manager.
12:27:48 <callen> what's absurd.
12:27:50 <byorgey> it IS a dep.  That's why you got an error about it.
12:27:51 <callen> that's*
12:27:56 <callen> why not just install it?
12:28:08 <monochrom> there is not enough money
12:28:09 <byorgey> because cabal can't possibly know whether it is installed.
12:28:09 <edwardk> :t Data.Void.absurd
12:28:10 <lambdabot> Data.Void.Void -> a
12:28:12 <luite> callen: unfortnately cabal cannot automatically install those executables, it can check that they exist though
12:28:17 <byorgey> also what monochrom said.
12:28:28 <elflord> how to escape from the Shelly Monad ? I have Shelly.find path, this will return Shelly.FilePath and all my String processing functions can not work on this type
12:28:53 <callen> luite: it's still failing after having installed happy.
12:29:06 <luite> callen: what's the error message?
12:29:06 <monochrom> check PATH
12:29:09 <callen> trying a global install of happy
12:29:10 <dcoutts> callen: it only does dep solving on a subset of the kinds of dependencies. It does dep solving only on library deps, but there are also other kinds of deps like deps on C libs, deps on programs etc.
12:29:10 <byorgey> elflord: use fmap or liftM to lift the function into the Shelly monad?
12:29:11 <elflord> I've already used <- to escape from the ShIO Monad
12:29:34 <byorgey> elflord: so the problem is just that the type Shelly.FilePath is not the same as String?
12:29:42 <byorgey> that has nothing to do with the Shelly monad
12:29:42 <dcoutts> callen: in principle it could handle them all, but it's just not implemented yet, it's a non-trivial amount of work
12:29:43 <elflord> yes
12:30:05 <elflord> byorgey: yes, ghci keeps complaint this
12:30:10 <byorgey> elflord: I don't know, you'll have to look at the Shelly documentation to see how to work with its FilePath type
12:30:39 <elflord> byorgey: I've driven crazy by this library
12:30:45 <byorgey> callen: by default cabal installs executables in ~/.cabal/bin
12:30:50 <elflord> byorgey, i have no solution
12:30:52 <callen> I know, I just added it to my path.
12:31:01 <callen> looks like the install is finishing now.
12:31:09 <callen> I'd dearly love to know why the Yesod documentation omitted that.
12:31:12 <dcoutts> monochrom, byorgey: btw, I just wrote a pile of patches to allow cabal to look in ~/.cabal/bin by default, even when it's not on the $PATH
12:31:16 <elflord> byorgey, i will give that liftM a try
12:31:27 <byorgey> elflord: liftM will not help.
12:31:27 <elflord> byorgey, i've alreayd used forM
12:31:39 <byorgey> elflord: http://hackage.haskell.org/packages/archive/shelly/1.3.0.7/doc/html/Shelly.html#g:13
12:31:51 <byorgey> you can convert between FilePath and Text
12:32:03 <monochrom> hrm! if I write "cabal install --prefix=/nondefault", will it also look in /nondefault/bin? :)
12:32:07 <byorgey> you can then convert between Text and String if you want, or better yet do your processing on Text values
12:32:14 <elflord> byorgey, but Text is not String
12:32:18 <dcoutts> monochrom: no, it's a setting in the ~/.cabal/config
12:32:23 <johnw> elflord: unpack . toTextIgnore
12:32:26 <johnw> will turn a FilePath to a String
12:32:38 <dcoutts> monochrom: which currently cannot contain $bindir or other template vars
12:32:45 <elflord> johnw, thx let's me check
12:33:02 <elflord> johnw, unpack  and toTextIgnore are both from Shelly ?
12:33:16 <johnw> toTextIgnore is a Shelly-defined wrapper around toText
12:33:22 <johnw> but neither toText nor unpack are from Shelly
12:33:24 <byorgey> callen: either because it is a global conspiracy to screw with you, or because people make mistakes.  I don't know which.
12:33:25 <dcoutts> monochrom: I had a go at allowing $bindir etc, but there's a bit of a recursive dependency because we don't know bindir 'til we decide which compiler we're using, but we cannot configure the compiler until we know where to look for it.
12:33:43 <clahey> edwardk, Is there an intern tutorial or example?
12:34:00 <FreeFull> I wouldn't be surprised if there was a better way to manipulate filepaths than as strings
12:34:17 <dcoutts> monochrom: do you think people would really want it to follow the $bindir? Since I'm not so sure they would.
12:34:20 <byorgey> FreeFull: well, prepare to be not surprised.
12:34:30 <edwardk> clahey: there is an example of using it for a syntax tree in the repo
12:34:35 <edwardk> maybe in the distribution as well
12:34:42 <dcoutts> monochrom: it's unclear to me if that'd be a feature or a bug
12:34:59 <monochrom> happy comes with Haskell Platform. some people may not like to "cabal install happy".
12:35:58 <joelteon> yeah, cabal can't really make you happy
12:36:20 <Cho0fool> Hm, i wonder if it possible to search hackage packages by dependencies...
12:36:24 <monochrom> anyway, to me, the most ridiculous thing in the world is that people don't put money (or generally resource) where their mouths are.
12:36:40 <Cho0fool> Just to take a look at some more or less modern use cases of gitlib.
12:36:50 <monochrom> yes, I'm over 40 and so I would have no brain if I didn't think capitalistically.
12:37:07 <Cho0fool> I'm quite stuck at the moment, can't figure out how to use gitlib.
12:37:50 <heatsink> I had a problem with missing packages when compiling GHC from source.  I edited the makefile to make the build system use both the bootstrap package database and the installed GHC's global package database during stage 1.  The problem went away, but I'm not sure I did the right thing.
12:37:57 <FreeFull> I don't have money
12:40:04 <heatsink> Should GHC and the boot libraries be configured and linked against the preexisting haskell libraries during stage 1?  How does it avoid ambiguity between imports of preexisting and boostrap libraries?
12:40:29 <carter> heatsink just follow the build directions on trac / dev wiki
12:40:34 <carter> also thats more a #ghc question :)
12:40:59 <heatsink> ah
12:41:19 <elflord> johnw, hi johnw, i got the Text type, but still my normal String functions can not operate on it
12:44:22 <johnw> elflord: you need to "unpack" your Text
12:46:26 <owen> what chapters of RWH should I read if I groked everything from LYAH?
12:46:42 <troydm> owen: mostly real world examples
12:46:49 <troydm> owen: and concurrency chapters
12:46:57 <troydm> owen: also chapter on parser is good
12:47:05 <elflord> johnw, i got this message: expect Text, actual type:Data.Text.Internal.Text
12:47:11 <troydm> *parsec*
12:47:18 <johnw> elflord: OK, you need to import both strict and lazy text
12:47:20 <johnw> here is what I do:
12:47:26 <johnw> import qualified Data.Text as T
12:47:39 <johnw> then: filePathToString = T.unpack . toStrict . toTextIgnore
12:47:56 <Cho0fool> johnw: Hello.
12:48:15 <Cho0fool> johnw: Can you, please, explain how to use libgit?
12:48:34 <johnw> Cho0fool: sure, come on over to #gitlib
12:48:42 <owen> thanks, troydm
12:48:56 <Cho0fool> johnw: Wonderfull, thank you.
12:51:49 <elflord> johnw, still no luck;says expect Text with actual type T.Text in the return type of toTextIgnore
12:52:17 <danilo2> Hi! What is the best way to simulate "lexer state" in Haskell using uu-parsinglib? I want for example to change the parsing rules after I see beginning of stirng literal (or as a simple example - parse the indentation level after the newline charavcter, but the simple example can be solved other way)
12:52:24 <johnw> elflord: what version of Shelly are you using?
12:52:31 <johnw> Shelly switched from lazy text to strict text in 1.x
12:53:25 <elflord> johnw, could you just show me two lines of code:one is find all files in any dir and then run ls on those file ?
12:53:26 <johnw> elflord: and is your code small enough to show me all the imports, and the function where you're using/writing this code?
12:53:34 <startling> danilo2, if your parser type is a monad transformer you can use StateT
12:53:45 <elflord> johnw, where can i show you ?
12:53:56 <elflord> johnw, it's very small
12:54:01 <arkeet> @where paste
12:54:01 <lambdabot> http://lpaste.net/new/haskell
12:54:18 <arkeet> elflord: ^
12:54:26 <elflord> got it
12:55:03 <hpaste> elflord pasted “Shelly code” at http://lpaste.net/91790
12:55:23 <danilo2> startling: So when using StateT I can change current state and check what is currenly selected state - ok its doable this way, but is there another, prettier way? (Maybe there is somewhere in uu-parsinglib suport for such thing but I dont know yet about it :) )
12:55:52 <elflord> the code is all messed up i changed it so many times i got lost
12:56:10 <johnw> elflord: print =<< shelly (ls ".")
12:56:17 <johnw> elflord: that's all you need to list files in a directory
12:56:42 <elflord> johnw, i actually want to find all epub books
12:56:49 <startling> danilo2, I don't know anything about uu-parsinglib
12:56:52 <johnw> reading your paste
12:56:56 <elflord> johnw, ive been testing it with ls
12:57:11 <absence> would an "instance Functor (Category r)" similar to "instance Functor ((->) r)" make sense? if so, is it implemented in a lib?
12:57:41 <danilo2> startling: Ok, thank you :) I'll ask here the second time though - maybe there is somebody who knows uu-parsinglib :)
12:57:43 <clahey> danilo2, Actually, that sounds quite pretty to me.
12:57:52 <elliott> absence: Category is a typeclass.
12:57:59 <elflord> johnw, my intention is very simple: find all epub books file and change their filename to txt
12:58:08 <clahey> Being able to use put and get in parsing construction sounds pretty awesome.
12:58:15 <johnw> elflord: https://gist.github.com/6214522
12:58:20 <elflord> johnw, i mean their extention
12:58:20 <johnw> but, your changeName is unnecessary
12:58:29 <danilo2> clahey: Ok :) I'll try it like that :)
12:59:16 <johnw> elflord: there is a function from Filesystem.Path.CurrentOS you can use called "replaceExtension"
12:59:21 <johnw> which operates on FilePath's
12:59:26 <exicer> So I've been playing around with Haskell for a bit now, and I like it. One thing I don't see much of, though, is people who use Haskell pointing out its weaknesses. What are they ?
12:59:35 <elflord> johnw, thanks man
12:59:42 <johnw> exicer: we lack enough people to point out or weaknesses
12:59:43 <elflord> johnw, let me try your code
12:59:48 <johnw> exicer: we try too hard to be perfect ;)
12:59:49 <startling> exicer: there's a lot of historical cruft in 'base'.
13:00:10 <startling> exicer, lots of cutting-edge haskell stuff uses nonstandard extensions
13:00:26 <startling> exicer, laziness sometimes bites you in the ass
13:00:43 <clahey> danilo2, Add in some lenses into your data and it gets even better.  :)
13:00:48 <johnw> exicer: yeah, understanding laziness is something that becomes necessary
13:00:49 <exicer> Is there a good reason that more people don't use it in production?
13:01:00 <exicer> Other than fear of functional programming :p
13:01:11 <johnw> exicer: the fact that lots of other people don't use it in production, I believe
13:01:14 <Fuuzetsu> fear of change
13:01:18 <startling> exicer, "not very many people use it in production" is a good reason
13:01:18 <startling> yeah
13:01:20 <johnw> exicer: it's a critical mass issue, not a technology issue
13:01:28 <elliott> Haskell has tons of problems. as much as any popular language, and they're usually less well-understood problems to boot.
13:01:43 <startling> it's completely rational to avoid using weird languages for production.
13:01:44 <danilo2> clahey: Hehe I cannot imagine lenses with uu-parsinglib right now, but maybe it is possible to mae it useful :D
13:01:52 <elliott> that shouldn't stop you from using it if it's useful to you, though.
13:01:57 <startling> sure.
13:01:57 <tromp_> another problem: dependency-hell
13:02:05 <elflord> johnw, it passed. I have to shew your code a bit more. Thank you very much !!!
13:02:06 <johnw> exicer: I am using Haskell in production, btw, and it's working great
13:02:11 <Fuuzetsu> also, not many people to maintain your stuff, Haskell programmers don't come in millions and cheap
13:02:18 <exicer> johnw: What sort of stuff are you doing ?
13:02:18 <absence> elliott: "instance Category c => Functor (c r)" then? or am i totally confused :)
13:02:23 <startling> oh, yeah, cabal sucks
13:02:24 <johnw> exicer: visit fpcomplete.com
13:02:24 <elliott> startling: erm, if that was a reply to me I wasn't replying to you :)
13:02:30 <elliott> absence: you can't write that
13:02:34 <johnw> exicer: every bit of that technology stack, even the Javascript code, is written in Haskell
13:02:38 <elliott> absence: you would need a way to go from (a -> b) to c a b, essentially
13:02:41 <startling> elliott, oh heh
13:02:50 <edwardk> exicer: it can be a little tricky reasoning about space usage in the presence of ubiquitous laziness. thats the major drawback to Haskell I know of.
13:03:11 <danilo2> Ok I've got another question to somebody, who knows UU-PARSINGLIB - Is it possible to write a parser combinator, that would return more than one token? I've got for example parser ombinator pEOL and pIndent and I want to combine them into pNewLine, which will return the EOL token and the Indent token.
13:03:22 <johnw> exicer: Haskell lets us get a LOT done with a small team, and once code works it keeps working; plus, refactoring (when it becomes necessary) is quite easy
13:03:24 <elflord> johnw, just for information: why do you use unpack ?
13:03:24 <exicer> How does Haskell end up working with people who learn it "just for work" ?
13:03:26 <edwardk> that is an emergent property of all the other good things you get though
13:03:34 <johnw> elflord: unpack converts Text to String
13:03:34 <sclv_> danilo2: liftM2 ?
13:03:53 <Fuuzetsu> exicer: I don't know any such people.
13:03:55 <sclv_> liftM2 (,) rather
13:03:59 <elflord> johnw, imagine i'm tomorrow in another Monad and there's another Text in that Monad, i should also use unpack ?
13:04:02 <exicer> Fuuzetsu: This is kinda what I thought
13:04:12 <johnw> elflord: unpack is unrelated to use of Monads, it's a pure function
13:04:14 <dcoutts> exicer: we teach people at companies for just that purpose, and they do quite well
13:04:15 <sclv_> oh there are such people
13:04:25 <pxqr> ci
13:04:29 <johnw> exicer: I should clarify: it's a function Text -> String, and does not rely on Monad in any way
13:04:29 <danilo2> sclv_: Am I wrong or it will return the tokens in a tuple? I would love to return them sequentially - like normal tokens
13:04:34 <dcoutts> exicer: we do in house training so have seen quite a few of these examples
13:04:40 <elliott> exicer: I turn away such people from #haskell and recommend they learn Python or something instead.
13:04:46 <sclv_> yep the stories i've heard are that its more enjoyable than learning another language for work, on the assumption you don't want to learn a language at all
13:04:52 <sclv_> but instead just do processing in your domain
13:04:58 <elliott> it's going to be a lot more profitable for someone who just wants to learn a language for work.
13:05:06 <sclv_> it depends if you are a programmer first
13:05:07 <edwardk> exicer: to be perhaps unnecessarily blunt i figure the kind of person who learns a language "just for work" works the kind of job that will be outsourced in 10 years, so I don't spend too much time thinking about them.
13:05:16 <dcoutts> exicer: they cope, and often rather enjoy it
13:05:16 <sclv_> or something else first, but you need to program
13:05:20 <sclv_> like a modeller or the like
13:05:29 <sclv_> if you "think in C" it could be irritating
13:05:39 <sclv_> but if you "think in equations" and never liked being forced to write them in C...
13:05:40 <johnw> edwardk++
13:05:41 <FreeFull> :t liftM2 (,)
13:05:41 <Fuuzetsu> I wonder if you can get teams of cheap Haskell ‘programmers’ in India
13:05:41 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
13:05:58 <edwardk> but to be a little more optimistic, we've had pretty good experience introducing haskell/scala to more traditional programmers here.
13:05:59 <exicer> I suppose it must be much harder to make mistakes, which has to help
13:06:00 <dcoutts> exicer: so don't believe that it's just for the leet programmers, it's not
13:06:25 <FreeFull> I think in what happens to the data
13:06:34 <exicer> dcoutts: Heh, well that is just it - you hear the stories of super productive haskellers, but have to guess that they would be as productive in almost anything
13:06:42 <S11001001> succ edwardk
13:06:46 <FreeFull> So Haskell, APL and concatenative languages are all good with me
13:06:55 <FreeFull> > succ "edwardk"
13:06:56 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
13:06:56 <lambdabot>    arising from a use of `...
13:07:02 <FreeFull> > map succ "edwardk"
13:07:03 <lambdabot>   "fexbsel"
13:07:09 <edwardk> exicer: i wrote code in c++/perl/python whatever for 15-20 years before I found Haskell. I was productive, but nowhere near as productive.
13:07:20 <alpha123> exicer: Not true. Some languages are easier to express ideas with, and that makes people more productive.
13:07:22 <dcoutts> exicer: probably, but then you want to take greatest advantage of those people, so you should give them great tools, not ones that'll slow them down and make them sad
13:07:46 <alpha123> exicer: Are you really saying that a really good Haskell programmer would be equally productive in
13:07:49 <alpha123> Java?
13:08:00 <johnw> exicer: I could not be as productive in Java, because I rely on Haskell's type system to help me out, which Java does not do (NullPointerException, anyone?).  I've written plenty of Java, and it usually took me much longer to get things working properly
13:08:05 <absence> elliott: ok, clearly i'm thinking about this the wrong way :) i read about fmap.fmap being "the same" as (.).(.) (Functor instance with fmap = (.)) and thought about the (.) in Category and started to wonder if a Functor instance with fmap = (Category..) made any sense
13:08:06 <exicer> alpha123: Well, maybe not equally - but pretty productive, none the less
13:08:18 <elliott> absence: it's unrelated to Category
13:08:28 <elliott> it's using just the (->) (.) there
13:08:33 <edwardk> The main thing I can say for Haskell is it is "stickier" than other languages. I find that I can write the general solution to a problem once and forall and move on to other things and get reuse, that holy grail of object oriented programming that God and everyone in the computer science community has been saying they want all along, but somehow can never realize within the OO-framework that purports to give it to them.
13:08:44 <dcoutts> exicer: so I don't agree they'd be as productive, I'm sure they'd still be well above their peers, but tools do make a difference
13:08:50 <elliott> absence: profunctors are the relevant concept here
13:08:58 <exicer> dcoutts: I can believe that
13:08:59 <elliott> or, well, maybe arrows.
13:09:01 <elliott> (ugh)
13:09:12 <evancz> does anyone have experience writing a type inference algorithm? I have a fairly specific problem regarding generalization and type annotations.
13:09:13 <alpha123> exicer: Perhaps more productive than your average Java programmer, sure. But Java makes it very difficult to express certain ideas that come easily in Haskell.
13:09:24 <elflord> johnw, i couldn't find replace extention in http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path-CurrentOS.html
13:09:26 <absence> elliott: yes, the ((->) r) instance is unrelated and uses (.) in Prelude. but couldn't there be an instance that uses (.) in Category instead? is that what profunctors are about?
13:09:40 <shergill> elliott: even including languages such as scala?
13:09:54 <johnw> elflord: it's documented in Filesystem.Path, but you import Filesystem.Path.Category
13:09:56 <johnw> CurrentOS
13:09:59 <pxqr> evancz: how do you check type annotations?
13:10:17 <elflord> johnw, ok
13:10:46 <evancz> pxqr: compare with the definition (simplified process :P)
13:10:55 <evancz> The issue is described here: https://groups.google.com/forum/?fromgroups#!topic/elm-discuss/SwUNgJRB8Po
13:11:06 <startling> edwardk: once ∧ ∀
13:11:10 <edwardk> exicer: A large part of the appeal of Haskell to me has to do with what linguist call the "Sapir-Whorf" hypothesis. That is that the language you think in guides the thoughts you can have. It was a statement about natural language, but it applies very well to programming languages in my experience. There are a lot of thoughts I can think in Haskell that have no analogue in other mainstream languages. Those thoughts let me name
13:11:10 <edwardk>  things and implement them as a library.
13:11:27 <evancz> It seems that I am making some variables rigid, but then *not* generalizing them later
13:11:41 <edwardk> a 'design pattern' is a made up word for a concept that the language isn't strong enough to express as a library feature 'once and forall'
13:11:49 <evancz> Bah, I don't really know how to ask a more specific question
13:12:09 <exicer> edwardk: Huh, interesting
13:12:10 <johnw> edwardk: it also makes people who know almost nothing about computer science feel like they know a whole lot about computer science
13:12:11 <evancz> It may come down to subtly misunderstanding the underlying algorethim
13:12:12 <edwardk> design patterns being so important in the java/oo ecosystem is a symptom of the paucity of the vocabulary
13:12:17 <ParahSailin> this one dies horribly, and unfortunately i seem to have to do all these ptr allocation and marshaling the unsafe ways: http://lpaste.net/91791
13:12:18 <dcoutts> exicer: so for example, we teach a 2-day crash course to Haskell for existing professional programmers. People can get the basics in that time. It's not as big an issue as people sometimes think.
13:12:45 <ParahSailin> i adapted the unsafeCStringLen stuff from ByteString.Unsafe
13:12:48 <egb3> diabel232 Hi!
13:13:02 <FreeFull> dcoutts: Can people get to typeclasses in that time?
13:13:06 <FreeFull> Or just the very basics?
13:13:11 <evancz> okay, here is the specific, does anyone recognize this kind of inferencer error?
13:13:44 <dcoutts> FreeFull: yes we cover type classes, including Monad, though not much on defining your own
13:13:55 <evancz> FreeFull: I've found it's easy to teach typeclasses
13:13:58 <pxqr> evancz: in general, you should infer type of expression and then check if inferred type is more general (or the same) as type in annotation, rigth?
13:14:30 <dcoutts> FreeFull: we first see type classes within the first 30min, along with unconstrained polymorphism
13:14:32 <exicer> How would the productivity increase from using haskell work along the distribution of programming ability ?
13:14:50 <exicer> eg are the bottom 5% going to do better than in Python or something ?
13:14:56 <exicer> or might they actually do worse
13:15:01 <johnw> edwardk: until discovering Haskell, I understood computer science about as much as a person who just turns on their car radio understands the world of HAM radio operators; it's shocking to me how far one can go in the "field" without knowing anything about its foundations, and without anyone telling you that you really know nothing yet
13:15:04 <dcoutts> exicer: and while most people attending such classes actively volunteer, we've certainly had people who were "volunteered" by their managers as it were, and they still do fine
13:15:19 <evancz> pxqr: I am using the approach from this paper (http://www.cs.cmu.edu/~rwh/courses/refinements/papers/PottierRemy04/hmx.pdf). I think it is a much more specific error than not checking annotations correctly. It only manifests in vary particular cases.
13:15:23 <dmwit> clahey: I suppose you'll need to use State or something like it.
13:15:42 <dcoutts> exicer: that's pretty hard to say, I don't think anyone has done sufficiently detailed studies
13:16:20 <exicer> dcoutts: Fair enough - just wondered if anyone had a feeling
13:16:22 <sclv_> evancz: you said "this kind of inferencer error" but didn't post the error?
13:16:40 <evancz> sclv_: https://groups.google.com/forum/?fromgroups#!topic/elm-discuss/SwUNgJRB8Po
13:16:52 <evancz> sclv_: sorry, posted in a separate comment!
13:16:56 <pxqr> evancz: I saw that paper, but didn't read yet :(
13:16:58 <FreeFull> I doubt Miranda is smaller and faster than irssi
13:17:15 <evancz> pxqr: it's the most accessible I have found, but still quite tough
13:17:15 <edwardk> exicer: well, there has been at least one study that showed people who were given a typed language and an untyped language they'd never seen before and a task, that more folks felt like they were making headway with the untyped one, but that more of the typed ones were correct.
13:17:52 <alpha123> FreeFull: Apparently MirandaIM is Windows-only, so I could see it being smaller and faster than other Windows software....
13:17:53 <dcoutts> exicer: it's certainly possible to have teams of mixed ability, the experts create abstractions and the others use them, that works well
13:17:59 <n-dolio> It was also a really easy problem that they were working on, I think.
13:17:59 <edwardk> so its a matter of whether you want to accept a jumbled mess of code that almost works that you are more likely to get or a piece of code that either does or doesn't work where success is much more modal
13:18:14 <edwardk> n-dolio: yeah it was, but it was at least _some_ study
13:18:32 <FreeFull> alpha123: Irssi does run under windows, although I'm not sure if cygwin is smaller than Miranda
13:18:35 <edwardk> i tend to like to find my bugs before i ship my code
13:18:50 <edwardk> as i don't like being awoken at 3am to fix a server bug
13:18:56 <evancz> edwardk: I like to exhaustively explore code paths after shipping :P
13:19:06 <sclv_> evancz: hmmm.. the weird part to me is that you have any rigid type variables there at all?
13:19:09 <edwardk> evancz: then python is the language for you! =)
13:19:14 <exicer> edwardk: Heh - I've heard good things about quickcheck, though I've not used it yet
13:19:15 <alpha123> FreeFull: Ah, didn't know. I use ChatZilla on Windows and irssi on Linux. I might have have to switch to irssi on Windows, except all the Windows terminal emulators are ugly as heck.
13:19:24 <johnw> @check x == x
13:19:28 <lambdabot>   mueval-core: Time limit exceeded
13:19:33 <FreeFull> I used to use Chatzilla
13:19:38 <FreeFull> But I completely forgot about it
13:19:40 <johnw> @check x + 2 == x + 1 + 1
13:19:43 <lambdabot>   mueval-core: Time limit exceeded
13:19:48 <johnw> hmm... I don't know @check very well
13:19:52 <solrize_> http://kentonv.github.io/capnproto/news/2013-08-12-capnproto-0.2-no-more-haskell.html
13:20:00 <FreeFull> @check \x -> x + 2 == x + 1 + 1
13:20:02 <evancz> sclv_: yeah, the ML algorithm will set things as rigid during generalization if they are not going to be used
13:20:04 <lambdabot>   +++ OK, passed 100 tests.
13:20:08 <johnw> FreeFull: thanks
13:20:24 <evancz> sclv_: so one of the intermediate variables that is created becomes rigid and then cannot be matched
13:20:58 <sclv_> i think it only needs to do that to handle weird subtyping constraint things?
13:21:09 <sclv_> like i don't see the cost in not setting those things rigid?
13:21:23 <sclv_> that said, it also looks like you shouldn't be "using" the variable anyway
13:21:50 <sclv_> so obv you're setting too much or the wrong thing rigid
13:22:06 * hackagebot hashable-extras 0.1.3 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.1.3 (EdwardKmett)
13:22:19 <evancz> yeah, I don't think it is too much though
13:22:35 <evancz> there is a decent amount of book-keeping needed to keep this in order
13:22:54 <evancz> so I suspect these generated type variables are somehow not getting registered
13:23:08 <sclv_> makes sense
13:23:22 <pxqr> polymorphism is awkward, it's simple to pass /\ around
13:23:30 <pxqr> * simpler
13:24:50 <scshunt> /\?
13:24:59 <pxqr> big lambda
13:25:08 <identity> okay. haskell is magic. I create an expression type, BinExp, UnExp, with some operators. Make it an instance of num. if I do 2^10 :: Expression, it automatically translates it to an expression tree of 2*2*2.. etc
13:25:09 <tikhon> Λ
13:25:12 <identity> i am just.. baffled.
13:25:16 <absence> elliott: oh right, now i see. the first argument to fmap can't be any Category of course
13:25:22 <osa1> I want to parse some html pages and look for some kind of links in them -- which library for that? (e.g. html parsing)
13:25:44 <tikhon> @src (^)
13:25:44 <lambdabot> x ^ 0            =  1
13:25:44 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:25:44 <lambdabot>   where f _ 0 y = y
13:25:44 <lambdabot>         f x n y = g x n
13:25:44 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:25:46 <identity> osa1: tagsoup
13:25:46 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:25:48 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:25:51 <evancz> hmmm, I probably need to talk through the code to figure out
13:26:13 <evancz> I'll go back to looking through and try to understand what I have missed
13:26:22 <evancz> thank you guys :)
13:26:22 <elliott> absence: if it helps, the more generalised notion of functor in category theory sort of allows the kind of thing you're talking about. (mumble mumble hom functor mumble)
13:26:49 <osa1> identity: thanks
13:27:10 <satc> For a function of type int foo (); in c if I write the foreign imported type as IO (). Will that result in any error or the haskell ffi will safely ignore any value returned from the c function?
13:27:11 <shergill> edwardk: haskell is more 'sticky' in your opinion than scala?
13:27:16 <edwardk> yes
13:27:26 <edwardk> i have to rewrite the same solution to a problem over and over and over in scala
13:27:34 <edwardk> consider monad transformers. they just work in haskell
13:28:44 <shergill> well. they kinda work, but i don't know a language where they work better
13:29:20 <edwardk> write them in scala and you can sit there and call pure[({type lambda[X] = StateT[S,M,X]})#lambda](12)   all over your code   or you can just rewrite your whole transformer stack to make a particular monad… up until that doesn't work because you need to traverse a list with more than 5000 elements and have to rewrite it trampolined or replace all the monads with imperative code
13:30:10 <edwardk> i find scala code to be highly non-"sticky" in that sense as i wind up having to rewrite the core implementation of things all the time to work around the incidental complexity of my environment rather than the essential complexity of my problem
13:30:12 <osa1> what has happened to this link http://hackage.haskell.org/packages/archive/tagsoup/0.13/doc/html/Text-HTML-Download.html ?
13:31:14 <identity> osa1: It never worked for me, and never could find anything about it.
13:31:18 <edwardk> This is a consequence of a number of knock-on effects of engineering decisions in the design of scala the language. I just don't particularly like the local optimum they find themselves in enough to enjoy working in it
13:31:28 <identity> Perhaps it may have been something he was working on and never really wrote, but had some documentation for or something like that
13:32:13 <osa1> yeah
13:33:02 <edwardk> e.g. non-positional arguments seem like they give you more power… but they make monad transformers suck. implicits seem like they give you more power, but they mean you lose canonicity in instance resolution and have to use slower algorithms and have lots of additional ways to reason about where the instance comes from. subtyping seems like it gives you more power, but it means the type inference works right up until the problem
13:33:02 <edwardk>  becomes interesting enough for type inference to be useful
13:33:06 <shergill> my annoyances with scala are mostly limited to a not-as-good type-checker and the quirks of the language (differential treatment in being able to be polymorphic over companion objects etc), but i wondered how much of that was because of me trying to force haskell into scala
13:34:29 <edwardk> i tried to write 'scala' in scala, not haskell in scala for a while, and it almost worked, right up until i was able to get the compiler to panic and start generating classes that still have abstract methods in them, but it thinks are complete… and was told that the bug was a wontfix.
13:34:29 <edwardk> at which point in time i realized i had better things to do with my time
13:34:54 <edwardk> there is a certain perverse beauty in some of the things you can say in scala
13:35:17 <FreeFull> You could always code in Idris
13:36:17 <edwardk> like when i was able to capture the notion of 'bounded' leibnizian equality, liskov substitubility, and evn equality as a subtype of substitutability, etc. that stuff was great.
13:36:21 <shergill> agreed regd subtyping and issues with implicits. though conversely i'm not entirely sure if it's necessary to be unable to import instances in haskell
13:36:32 <edwardk> FreeFull: back to the problem of not knowing when i have an error if its mine or the compiler's
13:36:40 * dcoutts is pleased with the new cabal repl
13:36:42 <dcoutts> handy
13:37:04 <edwardk> haskell rarely cries wolf. that is a wonderful testament to the capabilities of the ghc team and with that safety net underneath me i feel a lot happier on the high wires
13:37:31 <identity> dcoutts: cabal repl?
13:37:36 <edwardk> dcoutts: ooh shiny
13:37:55 <dcoutts> basically loads ghci with all the right flags
13:38:12 <dcoutts> (but also runs pre-processors, builds dependent components etc)
13:38:33 <shergill> yeah, with haskell the tools (in the past few years that i've used them) have been evolving towards a point i like. the issues i have with haskell/base etc are ones which are shared by others as well. that's more than what i can say about scala
13:39:05 <shergill> dcoutts: for real?
13:39:10 <dcoutts> yes
13:39:20 <dcoutts> I've been using it in anger today for the first time
13:39:29 <shergill> xmas just came early
13:39:56 <identity> Is anyone here familiar with Go? And did anyone else think of haskell's (Or is it really ghc's?) lightweight threads, and channels, when you saw goroutines and channels?
13:40:05 <identity> (Maybe channels aren't from haskell people?)
13:40:29 <tikhon> euh, I don't think most people here like Go very much
13:40:36 <FreeFull> edwardk: I guess you don't feel like working on the Idris implementation itself
13:40:59 <identity> tikhon: I don't really know Go. I just watched the tour of Go and such because my friend was selling it
13:41:38 <tikhon> the annoying bit is that it ignore basically all progress in PL design over the last several decades
13:41:42 <identity> and noticed similarities.
13:41:45 <tikhon> in favor of being a novel take on C
13:41:58 <tikhon> except without the low-level capabilities that make C at least somewhat worthwhile
13:42:06 * hackagebot http-conduit-downloader 1.0.8 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.8 (VladimirShabanov)
13:42:11 <carter> tikhon well said
13:42:13 <identity> tikhon: In what way?
13:42:24 <tikhon> ooh, lets not have parametric polymorphism
13:42:36 <tikhon> and lets encourage rampant type casting everywhere
13:42:37 <edwardk> FreeFull: i've got two half-finished compilers to hack on as it is ;)
13:42:38 <carter> except one special primop
13:42:42 <tikhon> and magical error handling
13:42:46 <tikhon> instead of variants
13:43:10 <carter> dcoutts whats pending between now and  1.18 released?
13:43:21 <edwardk> FreeFull: and i personally don't find the power to weight ratio of the dependent types to be worth it, but I would love to be proven wrong.. so long as someone else puts in the time to do the proving ;)
13:43:26 <dcoutts> carter: not a lot I hope
13:43:44 <carter> so i should start using it
13:43:49 <carter> updated my stale 1.17
13:43:54 <carter> so you can find stuff soon ;)
13:44:06 <dcoutts> please, testing is useful
13:44:39 <dcoutts> identity: certainly one can write that in style of concurrency in Haskell
13:45:20 <carter> ghc supports many nice styles of concurrency
13:45:28 <carter> and lets you choose the one thats right for you
13:45:35 <carter> with more coming every release :)
13:45:51 <dcoutts> identity: it's good that people are finally realising that lightweight threads are the right thing in so many cases, though as a counterweight to Go, there's Node.js which stubbornly refused to learn that lesson, even though it's specifically targeted at network services!
13:45:54 <tikhon> if you want an interesting new low-level language, you should take a look at Rust
13:46:06 <monochrom> sometimes new styles come in Haskell Platform, for example by adding the async lib
13:46:24 <tikhon> the async lib is particularly awesome because it's implementation is tiny and very readable
13:47:12 <carter> literally just one file
13:47:13 <carter> http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/src/Control-Concurrent-Async.html#async
13:47:15 <monochrom> yes. it is also very nice that a new style can happen as just a lib, not requiring fundamental language change.
13:47:21 <Kaini> @pl \(_,a) (_,b) -> compare a b
13:47:24 <lambdabot> ap (const (flip (ap . flip ((.) . const . compare) fst) snd) . fst) snd
13:47:24 <lambdabot> optimization suspended, use @pl-resume to continue.
13:48:39 <monochrom> Marlow's Skillmaster talk is an informative nutshell
13:49:00 <FreeFull> Kaini: That's   compare `on` snd
13:49:12 <FreeFull> Where on is in Data.Function
13:49:17 <FreeFull> :t compare `on` snd
13:49:18 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
13:49:21 <Kaini> ah
13:49:23 <Kaini> nice!
13:49:25 <monochrom> I didn't even know that Haskell Platform has async until the end of his talk "... and it's in Haskell Platform"!
13:49:28 <tikhon> @src on
13:49:28 <lambdabot> (*) `on` f = \x y -> f x * f y
13:49:56 <FreeFull> Why does on shadow *
13:49:59 <FreeFull> That's confusing =P
13:50:00 <tikhon> comparing ≡ (compare `on`)
13:50:07 <tikhon> :t comparing
13:50:08 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
13:50:12 <identity> I didn't know of async either :o
13:50:14 <tikhon> @src comparing
13:50:14 <lambdabot> Source not found. Are you on drugs?
13:50:24 <tikhon> !
13:50:29 <FreeFull> comparing is in Data.Ord
13:50:55 <tikhon> comparing f x y = compare (f x) (f y)
13:51:07 <tikhon> or comparing f = compare `on` f
13:51:13 <tikhon> or comparing = (compare `on`)
13:51:18 <identity> Hmm. Async reminds me of the small library one of the tutorials wrote
13:51:19 <tikhon> I like the middle version most
13:51:26 <identity> one of the authors of the tutorials*
13:51:30 <identity> maybe rwh
13:51:31 <identity> not sure
13:51:51 <tikhon> identity: there was a very nice description of how Async works floating around, written by Marlow
13:52:45 <tikhon> or maybe written by SPJ
13:53:08 <johnw> he even wrote a book about it :)
13:53:11 <johnw> (Marlow)
13:53:13 <carter> yeah
13:53:16 <johnw> async is a fantastic library
13:53:17 <carter> i got the book in the mail today!
13:53:28 <johnw> with async and STM, I feel that no concurrent programming is too hard
13:53:39 <dcoutts> heh
13:53:47 <tikhon> johnw: awfully optimistic
13:53:49 * dcoutts notes that concurrency is still hard
13:53:52 <johnw> tikhon: based on experience
13:53:53 <osa1> any shortcuts for `not . null . filter f` ?
13:53:54 <tac> johnw: Do you remember the URL for that one video on async?
13:53:57 <johnw> oh, I just said "too" hard :)
13:54:02 <monochrom> well, async is just part of the book. other parts include par.
13:54:04 <tac> I remember watching it a long time ago and loving it, but I havne't been able to find it :(
13:54:08 <johnw> tac: yes, I watched that
13:54:20 <solrize_> hey edward know anything about spark/ada style of verification as contrasted with something like coq?  particularly ada-2014, the new spark uses an SMT solver to verify properties
13:54:21 <luite> osa1: any f
13:54:27 <dcoutts> johnw: next time we have a problem with async exceptions we'll hand it over to you ;-)
13:54:29 <tikhon> osa1: any
13:54:31 <osa1> thanks
13:54:59 <solrize_> edwardk spark-2014 rather.
13:55:11 <monochrom> tac: http://skillsmatter.com/podcast/home/high-performance-concurrency
13:55:16 <identity> thanks!
13:55:20 <identity> i'd like to see that
13:56:29 <monochrom> solrize_: I only know Spec#, which is for C#
13:56:37 <FreeFull> I wonder
13:56:40 <FreeFull> > const id 3 4
13:56:41 <lambdabot>   4
13:56:44 <FreeFull> > flip const 3 4
13:56:45 <lambdabot>   4
13:56:49 <monochrom> P.S. I disbelieve in curry-howard
13:56:53 <FreeFull> const id === flip const
13:56:56 <shergill> johnw: could you elaborate what you meant when you said that exposure to haskell made you aware of a lot of cs fundamentals, which you weren't earlier aware of?
13:57:02 <shergill> ct?
13:57:29 <solrize_> monochrom interesting.  yeah i don't know anything about spec# except i remember it can check array bounds using quantifier elimination for presberger arithmetic as long as you don't multiply subscripts by each other
13:58:30 <tac> monochrom: thanks for the link
13:58:37 <monochrom> that is the limitation of the SMT solver used. there is also null check.
13:58:41 <johnw> dcoutts: actually, that would be interesting to me (async exceptions with concurrency)
13:58:50 <johnw> shergill: one sec
13:59:09 <dcoutts> johnw: I can tell you about it another time, but trust me it's tricky
13:59:52 <dcoutts> especially once you combine it with thunks and otherwise "safe" uses of unsafePerformIO
14:00:03 <monochrom> there are also data invariant check and loop invariant check. all up to the capability of the SMT solver, of course.
14:00:21 <FreeFull> I know a safe use of unsafePerformIO
14:00:27 <FreeFull> That will always be safe no matter what
14:00:34 <FreeFull> unsafePerformIO (return ())
14:01:02 <merijn> So, anyone here going to Mostly Functional in Edinburgh this month?
14:01:15 <edwardk> solrize_: wut?
14:01:36 <edwardk> solrize_: oh. just read back
14:01:43 <solrize_> oh sorry :)
14:01:48 <carter> spec# the language
14:02:02 <carter> not a special haskell constructor edwardk  and i somehow didn't know about ?
14:02:06 <monochrom> data invariant check is the most interesting one. it requires solving a difficult kind of frame problem: how do you know that another object has not changed?
14:02:12 <edwardk> i actually find the SMT solver approach to be fun to use. e.g. ESC/Haskell was great fun to play with. Not sure how well it scales though.
14:02:28 <isomorphismes> watching @bos31337's talk from strange loop 2011. Anybody here play Go? He says Go & Haskell go well together.
14:02:35 <monochrom> it scales better than curry-howard. my opinion anyway.
14:02:53 <tikhon> aha, another thing to dislike about Google Go: it shadows the existing identifier "Go"
14:03:01 <carter> yup
14:03:05 <carter> Go the game is ahrd to master
14:03:12 <carter> Go the language ….. meh
14:03:13 <carter> :)
14:03:15 <carter> anyways
14:03:17 <solrize_> Haskell — ESC Energy Systems - Biogas Treatment and …
14:03:21 <carter> we're not supposed to language bash :)
14:03:32 <edwardk> i loved it enough to obsess about it from 2008-2009 or so, but i never got anywhere with it. not sure if that says more about the SMT-based-refinement-type notion or me ;)
14:03:35 <solrize_> oh found it
14:03:39 <solrize_> Extended static checking for Haskell
14:03:42 <Demos_> still, it is funny that google's language is the most un-serchable thing ever
14:03:53 <solrize_> golang.org ?
14:04:10 <monochrom> ESC stands for "extended static checking". this acronym began with "ESC/Java" for Java, as far as I know
14:04:55 <edwardk> i guess there is LiquidHaskell or something taking up the torch in that space
14:05:20 <edwardk> and there is still some random repo i have marked on github where spj and some folks keep puttering with the ESC/Haskell/Static Contract Checking approach
14:05:41 <edwardk> but there was a paper a couple of years back that showed you can't get all the desirable properties of that approach and laziness in the same system
14:05:46 <edwardk> so i stopped thinking about it
14:06:07 <edwardk> proper blame assignment is really hard
14:06:33 <edwardk> because things can be correct so long as you don't force a thunk, so its a combination of 3 agents involved in blame assignment unlike in a strict setting
14:06:37 <monochrom> edwardk: in general, my opinion, all attempts of putting properties into types do not scale. reason: how would you state this property "joy . fun = id"? do you state it as "joy . fun = id"? or do you try to write "joy :: some-type; fun :: some-other-type"?
14:06:49 <solrize_> yeah it seems like spark mostly is about proving totality and haskell's approach to that is "meh"
14:07:07 * hackagebot http-conduit-downloader 1.0.9 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.9 (VladimirShabanov)
14:07:32 <edwardk> solrize_: the ESC/Haskell/SCC approach is about proving partial correctness. 'if this program terminates then this property holds'
14:07:38 <edwardk> rather than 'this property holds'
14:07:48 <edwardk> that lets them get away with a lot of cute abstract interpretation hacks
14:08:03 <edwardk> combined with something like terminator it could be turned into a total correctness tool
14:08:05 <solrize_> right, that's the haskell way
14:08:33 <solrize_> ada is more like "this code must not ever throw an exception ever, but if it gives a wrong answer that's better than nothing"
14:09:01 <pyrtsa> bscarlet, carter: Thanks for taking a look. I'm all ears for better solutions, but I'm really just getting started with Haskell development, couldn't find anything better so far.
14:09:18 <carter> pyrtsa: ifyou install cabal and cabal-install HEAD
14:09:20 <carter> theres a nicer solution
14:09:40 <pyrtsa> Ok, I'll have a look.
14:10:39 <carter> pyrtsa: https://gist.github.com/cartazio/5953772 are some fields cabal config understands if you're in 1.17  / soon head
14:11:00 <edwardk> monochrom: good point
14:11:15 <carter> pyrtsa: and basically, you'll want to use gcc for -pgmP
14:11:17 <carter> with all the right flags
14:11:21 <carter> but use clang otherwise
14:12:17 <u_> http://www.fit.vutbr.cz/study/courses/TJD/public/0708TJD-Peterka.pdf
14:12:20 <u_> on page twelve
14:12:37 <u_> the table with every combination of sort dependencies
14:12:40 <u_> is that really right?
14:12:51 <gertc> how do you include a source directory in ghci named src-unix? tried -isrc-unix -i"src-unix" -isrc\-unix
14:13:28 <carter> pyrtsa: you'll want to have it it say gcc-4.8 or whatever
14:13:31 <carter> rather than gcc
14:13:35 <u_> I could've sworn haskell was essentially Fw... according to the table haskell doesn't have polymorphism,
14:13:38 <carter> for obvious reasons
14:13:53 <u_> and cayenne lacking types on types, huh?
14:15:42 <merijn> u_: Haskell is based on F_omega, I thought? I can never remember properly
14:15:59 <u_> merijn right, by Fw i mean lowercase omega
14:16:07 <hpc> Fω
14:16:09 <n-dolio> Haskell and Hindley-Milner in general are not on the lambda cube.
14:16:51 <pyrtsa> carter: Ok, but was there a generic solution that works for people without GNU GCC installed too?
14:16:57 <merijn> u_: btw, on first glance, this papers seems to just be a rewrite of Barendregt's original lambdacube paper
14:17:00 <carter> pyrtsa not yet
14:17:05 <pyrtsa> Okay.
14:17:10 <carter> and per se, there may never be
14:17:20 <pyrtsa> Hmm, that would be a shame.
14:17:23 <u_> and the "examples" list that follows the table is confusing also, the examples don't seem to match the table
14:17:25 <monochrom> I would not say that Haskell is based on Fω. If you say, GHC internal is based on Fω, that may be true or close enough
14:17:27 <u_> right i'll just read that instead
14:17:27 <carter> pyrtsa the issue is clang CPP needed patches
14:17:28 <merijn> oh, no it has some more things
14:17:31 <carter> for things wot work
14:17:41 <n-dolio> Or maybe their (*,*) ([],[]) does it, I can't recall.
14:17:58 <pyrtsa> carter: I would think a separate CPP dedicated for preprocessed Haskell files would be a long term solution.
14:18:02 <carter> yes
14:18:04 <carter> but we dont' have that yet
14:18:09 <monochrom> but GHC internal needs to be that general because it supports so many type extensions
14:18:10 <carter> or at least one thats not GPL
14:18:27 <n-dolio> Depends whether you think (*,*) has variables at all, I guess.
14:18:57 <Fuuzetsu> GPL haters ;(
14:19:17 <carter> just paraphrase all the codes and make it bsd
14:19:18 <pyrtsa> Right. Ok, let's see if we can get that fixed in the near future. Thanks a lot. Time to get some sleep now.
14:20:06 <carter> pyrtsa yeah
14:20:10 <carter> just someone has to do it :)
14:21:22 <carter> pyrtsa but props of figuring it out quickly
14:21:24 <carter> took me a while at first
14:22:13 <johnw> shergill: yes, CT I'd never even heard of; or the relation between algebras and types/functions; monoids, denotational vs. operational semantics, the complexity of what it means to be "equal", boolean blindness, etc.
14:22:32 <n-dolio> u_: Whether that table works depends on whether you think 'a -> a' is a valid type in the simply typed lambda calculus (only *~>*).
14:22:46 <johnw> shergill: I may have known a lot about using languages and libraries, but I knew very little about how to reason about code
14:22:55 <n-dolio> Or whether it's actually 'forall a. a -> a' and requires some polymorphism.
14:23:13 <monochrom> gertc: -isrc-unix works. however, note a limitation of the semantics of -i, not specific to src-unix
14:24:14 <monochrom> if you have src-unix/Joy.hs and its content is "module Joy where...", then ":load Joy" works (module name), ":load Joy.hs" fails "file name". -i is just for looking for modules, not exactly files.
14:24:58 <gertc> hmm works in 7.6.3 also ?
14:25:01 <monochrom> corollary: if you have "src-unix/mymain.hs" and it is your main, there is no way you can get it to work
14:25:06 <evancz> sclv, pxqr, just wanted to check back in and say I figured it out :)
14:25:10 <monochrom> yes it's 7.6.3 I'm testing
14:25:14 <evancz> thanks for talking with me about it
14:25:33 <evancz> I was doing bad book-keeping during unification
14:25:45 <evancz> thanks again! :)
14:27:44 <gertc> https://github.com/acid-state/acid-state for example i does not find the file FileIO.hs when i try :set -isrc -idist/build/autogen/ -isrc-unix -itest -Wall -optP-include -optPdist/build/autogen/cabal_macros.h
14:28:45 <gertc> if i copy it in src it works
14:29:53 <shergill> johnw: gotcha. i came across those concepts in gradschool. it's interesting to see that haskell was the catalyst which had you exploring them. any idea why? i get the feeling you can probably use haskell while still being in the blind regd all of the above
14:31:09 <gertc> i use a .ghci config file
14:31:14 <johnw> shergill: well, I studied philosophy at uni, not math or compsci, so part of the blame is on me.  But what surprised me is that over 25 years of engineering, I never had any of the kinds of discussions with people that I have here.  The kinds of stuff edwardk thinks about on a regular basis opened me up a whole new world, of which programming is just one concrete expression
14:31:55 <shergill> so really, haskell → edwardk → pl theory
14:32:03 <shergill> :P
14:32:07 <monochrom> um, are you supposed to include so many things in one single :set ? :)
14:32:26 <johnw> edwardk/mauke/shachaf/dolio/Cale/Saizan/byorgey/etc.
14:32:41 <gertc> for acid-state i guess :)
14:33:00 <shergill> yeah haskell attracts an inordinate number of pl people
14:33:06 <djahandarie> Hey what about me!
14:33:13 <djahandarie> Just kidding I'm idle as hell these days
14:33:16 <johnw> etc. is a large group :)
14:33:32 <edwardk> djahandarie: you're just some security guy now, right? =)
14:33:52 <monochrom> actually, I just tried, works here. :load FileIO -> "Could not find module `Control.Exception.Extensible'". ok, I don't have Control.Exception.Extensible, but clearly it finds FileIO
14:34:26 <gertc> ? ok i am trying again one sec
14:34:31 <monochrom> it's :load FileIO -> "src-unix/FileIO.hs:23:8: Could not find module `Control.Exception.Extensible" so it knows src-unix/FileIO.hs
14:35:03 <djahandarie> edwardk, something like that. I definitely still consider myself a Haskell / PL person though, and I hope to see it adopted more heavily by people who want to run secure/safe systems.
14:36:03 <djahandarie> Currently I'm spending most of my free time learning about security stuff though. :P
14:36:12 <edwardk> djahandarie: now you do. in 3 years you'll be good for nothing more than asking whether or not that cookie over there is in plaintext. ;)
14:36:26 <djahandarie> Haha.
14:37:28 <thoughtpolice> djahandarie: having done the security thing before too, i hope to see PL stuff adopted more and more for secure systems
14:37:53 <thoughtpolice> i was pretty obviously the outlier in this regard in a lot of discussions i had :P
14:38:37 <gertc> monochrom: ok nevermind i guess i was doing ghci in /src instead of / doh X(
14:38:45 <monochrom> oh haha
14:39:02 <djahandarie> thoughtpolice, haha. Thankfully I ended up somewhere where everyone agrees with me. :P At least in my department.
14:39:54 <linziyi_> hi
14:40:03 * linziyi_ is a newbie
14:40:43 <linziyi_> Just want to ask
14:41:09 <linziyi_> if haskell is the wrong thing for a person who has very very little programming experience
14:41:24 <shanse> no
14:41:37 <ion> no
14:41:41 <b2coutts> no
14:41:49 <edwardk> in many ways haskell is an excellent place to start because you have no bad habits to unlearn.
14:41:49 <hpc> it's arguably the perfect thing for a person with very very little programming experience
14:41:54 <b2coutts> (it isn't the wrong thing, that is)
14:42:05 <edwardk> and because it is so good at not letting you do the wrong thing
14:42:15 <carter> thoughtpolice: aren't sergey and meredith in the pl tools camp?
14:42:30 <b2coutts> and yes, probably one of the main issues people have when learning haskell is that they're used to programming in other languages
14:42:46 <b2coutts> and this impedes them, because haskell forces you to think differently
14:42:56 <monochrom> do yourself justice. put in 10 hours of effort and decide for yourself. for yourself. don't generalize prematurely.
14:42:58 <tac> It's scary being the newbie again :)
14:43:14 <hpc> @where lyah
14:43:15 <lambdabot> http://www.learnyouahaskell.com/
14:43:52 <linziyi_> aha
14:43:58 <linziyi_> hank you
14:44:11 <linziyi_> I tried C and python before
14:44:17 <linziyi_> Thank you*
14:44:23 <monochrom> my opinion is that Haskell is compatible or incompatible with personaiity rather than compatible or incompatible with what you knew
14:44:32 <hpc> heh, C is a pisser of a first language
14:44:35 <linziyi_> but was just not thinking in that manner
14:44:36 <b2coutts> heh, I hadn't thought of it like that before
14:44:41 <b2coutts> monochrom++
14:44:42 <monochrom> and C too
14:45:14 <monochrom> my take is that control freaks find C direct and Haskell obscure
14:45:30 <monochrom> err, I guess s/obscure/obstructing/
14:45:47 <companion_cube> interesting idea, do people have innate "programming paradigm personalities"?
14:45:48 <hpc> monochrom: well, different kind of control freaks
14:45:49 <b2coutts> they also probably find it obscure :P
14:45:59 <companion_cube> can be performance freaks too
14:46:01 <hpc> the difference between "this is what i want to do" and "this is what i want others to do"
14:46:07 <monochrom> then again, on those few days when I am a control freak, even C is obstructing. can I get the carry flag of the CPU already?
14:46:21 <gertc> https://github.com/gertcuykens/acid-state/blob/master/src/Data/Acid/Abstract.hs I fideling with acid state and following the source code i end up at a function called downcast? 1) What does it do? 2) How can i stick a different type in it? for example RemoteState ?
14:46:44 <b2coutts> companion_cube: in my experience, most people strongly dislike functional programming when they're introduced to it
14:46:50 <monochrom> oh, hpc has it right :)
14:46:59 <johnw> b2coutts: I found it very odd, as I recall; now it feels more natural
14:47:12 <b2coutts> I'm not sure if this is because they were used to imperative already, or if it's more than that
14:47:31 <monochrom> programming is a dialectic class struggle between author and user :)
14:47:41 <b2coutts> johnw: haha yeah, for a long time I just thought functional programming was really cool, but I assumed I was still more adept at imperative programming because I was more used to it and it was less awkward
14:47:46 <hpc> monochrom: or perhaps more the difference between controlling "doing" vs "knowing"
14:47:46 <johnw> "dialectic class struggle"?
14:47:56 <b2coutts> it was only fairly recently that I realized that I'm much more at home with functional programming
14:48:14 <monochrom> just trying to parode Marxism :)
14:48:33 * johnw is sensitive to those who would malign the power of the dialectic :)
14:49:07 <b2coutts> I actually haven't programmed in C/C++ in a long time, and whenever I find myself programming in python or perl, I tend to write very functional code
14:49:16 <hpc> johnw: https://en.wikipedia.org/wiki/Dielectric
14:49:28 <b2coutts> where possible, anyway
14:49:41 <johnw> hpc: https://en.wikipedia.org/wiki/Dialectic
14:49:44 <hpc> b2coutts: perhaps you have heard my joke, that haskell is my favorite imperative language and perl my favorite functional language
14:49:53 <hpc> johnw: it was a joke :P
14:49:57 <johnw> ah :)
14:50:03 <b2coutts> haha
14:50:24 <b2coutts> I don't actually know how to program imperatively in haskell
14:50:29 <johnw> perl is naturally functional because it's write-only, so you can't observe mutations
14:50:30 <monochrom> I got inspired by a way to explain rank-N types. "fun :: forall a. a -> Joy" the user (of fun) chooses a, the author doesn't. "act :: (forall a. a -> Joy) -> Luck" the author chooses, the user doesn't.
14:50:30 <companion_cube> hpc: I have a good one too, php is my favorite programming language
14:50:32 <companion_cube> wait
14:50:43 <b2coutts> but perl's capacity for being a functional language is actually very good
14:50:53 <johnw> monochrom: yeah, I use that explanation too
14:51:01 <b2coutts> blocks make very nice lambdas sometimes
14:51:18 <tac> The biggest problem I have with "imperative" style in Haskell is that you have to name both your references and the values you take out of them.
14:51:32 <monochrom> it's always a tug war between author and user. author's freedom = user's nightmare. etc
14:51:53 <enthropy> tac: use name shadowing
14:52:01 <hpc> elegant solution: maximal restriction
14:52:01 <enthropy>  var <- readIORef var
14:52:05 <tac> enthropy: That sounds like a bad idea :<
14:52:07 <hpc> you have many static guarantees, and no users
14:52:34 * enthropy doesn't think it leads to issues
14:53:23 <enthropy> even if you're using  IORef (IORef A), most things you can do with the A are not going to work with the IORef (and the opposite)
14:53:25 <path[l]> hmm I knew someone called tac once, but he's now works at eth zurich I believe
14:53:26 <tac> No severe issues. It is perhaps a little unhygienic, though.
14:54:27 <enthropy> well it can't always work... sometimes you'll still need to access the IORef
14:56:38 <monochrom> johnw: and earlier than that, I wrote http://www.vex.net/~trebla/weblog/any-all-some.html . math-proof-intensive homework is a tug war between teacher and student :)
14:57:20 <tac> "One man's something is another man's everything".
14:57:28 <monochrom> haha
14:57:49 <gertc> import Data.Typeable ( Typeable1, gcast1, typeOf1 ) what does these things do?
14:58:12 <c_wraith> > typeOf1 (Nothing :: Maybe Int)
14:58:13 <lambdabot>   Maybe
14:58:30 <Fuuzetsu> :t typeOf1
14:58:31 <lambdabot> Typeable1 t => t a -> TypeRep
14:58:45 <gertc> and de gcast thing?
14:58:50 <osa1> can anyone point me a nice library to download a URL ?
14:58:54 <Fuuzetsu> > show (typeOf1 (undefined :: Int))
14:58:55 <lambdabot>   Couldn't match expected type `t0 a0'
14:58:55 <lambdabot>              with actual type `GHC.Typ...
14:58:57 <hpc> in newer ghc, i think that's all unified into a single polymorphic Typeable
14:58:57 <johnw> osa1: http-conduit
14:59:06 <Fuuzetsu> > show (typeOf1 (undefined :: Maybe Int))
14:59:07 <c_wraith> hpc: newer as in "unreleased"
14:59:07 <lambdabot>   "Maybe"
14:59:21 <hpc> c_wraith: somehow i thought it would be in 7.6
14:59:22 <Fuuzetsu> hpc: It is, which makes stuff not compile
14:59:55 <c_wraith> gertc: it's stuff for dealing with unknown types of kind * -> *
15:00:21 <c_wraith> gertc: the idea is that it doesn't allow converting types, but it prevents you from having to track what types actually are globally.
15:01:02 <osa1> johnw: um, without conduits? all I want is `readURL :: String -> Either SomeError String`
15:01:23 <hpc> osa1: http-conduit has that
15:01:34 <osa1> IO (Either SomeString String)
15:01:37 <hpc> http://hackage.haskell.org/packages/archive/http-conduit/1.9.4.1/doc/html/Network-HTTP-Conduit.html
15:01:46 <johnw> osa1: http "some URL" $$+- CL.consume
15:01:48 <gertc> c_wraith: i am thinking why i want to do that :)
15:01:53 <johnw> returns a list of strict ByteString chunks
15:02:05 <hpc> simpleHttp :: MonadIO m => String -> m ByteString -- This function will throwIO an HttpException for any response with a non-2xx status code (besides 3xx redirects up to a limit of 10 redirects).
15:02:06 <c_wraith> gertc: in general, it isn't necessary.
15:02:10 <johnw> ah, or that
15:02:25 <osa1> is it also a conduit function?
15:02:32 <osa1> ah just saw that
15:02:32 <c_wraith> gertc: but sometimes you know that something's correct, but proving to to GHC's satisfaction would be a huge pain.
15:02:41 <hpc> johnw probably has the better solution
15:03:17 <hpc> i don't learn libraries particularly fast :P
15:04:07 <johnw> the advantage to the Conduit version is if you don't actually need to download the whole page, but can find what you're looking for in the first chunk
15:04:51 <gertc> c_wraith: ok thx
15:04:55 <hpc> the disadvantage is that you can consume a little bit of page, then nothing for a while, and resources are held up
15:05:09 <hpc> lazy IO, buyers beware
15:05:23 <johnw> hpc: conduits specifically avoid the problems of lazy I/O
15:05:32 <osa1> ok, how to convert ByteString to String after reading with conduits?
15:05:37 <osa1> or wait
15:05:40 <osa1> maybe my parser accepts byte strings
15:05:49 <johnw> resources are controlled by the enclosing runResourceT around the $$+- call
15:06:00 <osa1> yeah, it accepts bytestrings, nice.
15:06:02 <hpc> oh, well
15:06:38 <monochrom> if possible, do not use String (it's [Char], bulky). keep as bytestring, or use Text (choose a decoding consciously)
15:06:57 <monochrom> well, if you use String, you still have to choose a decoding conciously
15:07:45 <alpha123> monochrom: I'm rather new to Haskell, are bytestrings sort of like Erlang's <<"string">>?
15:07:51 <alpha123> (Just curious)
15:07:56 <monochrom> I do not know Erlang
15:07:58 <c_wraith> alpha123: not really.
15:08:11 <monochrom> bytestring is an array of bytes
15:08:16 <c_wraith> alpha123: They're just packed byte arrays.
15:08:48 <c_wraith> There's nothing like erlang's pattern-matching on bit patterns.
15:08:52 <monochrom> lazy bytestring is a lazy list of arrays of bytes. each array is about 64K.
15:08:56 <alpha123> Okay. Thanks. Just wondering, Erlang's bitstrings are pretty handy.
15:09:24 <monochrom> the idea is that it is 64K-buffer lazy
15:09:58 <c_wraith> alpha123: Really? Seems like the domain in which they're useful is that of parsers for formats that should have libraries.
15:10:03 <monochrom> as someone once said, 64K ought to be enough for everybody
15:10:10 <c_wraith> alpha123: so they're really only valuable for writing those libraries
15:10:34 <alpha123> c_wraith: Perhaps. They're generally fairly useful for any sort of text manipulation that needs to be fast.
15:10:35 <test99> I have a hunch that I can use a "double map" to the equilvant of this `map (\(x,y) -> x*y) [(x,y) | x <- xs , y <- xs]` without list comprehension, but I cannot wrap my head around it. Can someone help me?
15:10:47 <alpha123> (Web frameworks are what I'm familiar with)
15:10:48 <tulcod> i am using TH (specfically data-flags) to generate a type with a constant name (ContextFlags). can I document this type with haddock?
15:10:59 <c_wraith> test99: you can do it without the map...
15:11:26 <elliott> test99: you wnt the ersulting list to contain x*y instead of (x,y), right?
15:11:30 <elliott> why not just write that?
15:11:37 <elliott> *resulting
15:11:52 <c_wraith> test99: but if you really mean "how do I apply a function to the cartesion product of two lists?" the answer is liftM2
15:11:56 <monochrom> ironically, to eliminate the comprehension and convert to map, first you should eliminate the map and convert to comprehension.
15:12:21 <c_wraith> > liftM2 (*) [1,2,3] [10,11,12]
15:12:22 <lambdabot>   [10,11,12,20,22,24,30,33,36]
15:12:37 <monochrom> your expression = [x*y | x <- xs, y <- xs]  (I am not done yet)
15:12:57 <monochrom> = xs >>= \x -> ys >>= \y -> return (x*y)
15:15:23 <lispy> or, if you extra precedence parens help: xs >>= (\x -> ys >>= (\y -> return (x*y))
15:15:23 <monochrom> = concat (map (\x -> ys >>= \y -> [x*y])) xs
15:15:44 <lispy> (I think I lost a paren at the end, sorry)
15:16:02 <monochrom> = concat (map (\x -> concat (map (\y -> [x*y]) ys))) xs
15:16:59 <monochrom> liftM2 is of course shorter :)
15:17:26 <werbitt> Hi, in this toy reverse polish calculator, https://gist.github.com/werbitt/6215806 , in the rpolish function, i know the accumulator in the foldl will always have at least 2 numbers in it if the token is a function. But if I don't deal with the case of an empty list or a list with a single item, then the pattern match in non-exhaustive. What are good ways of dealing with this?
15:18:33 <hpc> werbitt: make your calculator return a list of values
15:18:35 <monochrom> write a comment to say "I know it has at least 2 numbers"
15:18:35 <osa1> my problem with reading web page as ByteString, even though tagsoup can parse from ByteStrings, at some point I have to run a case insensitive word search on small strings but I can't do that because there's no toLower function for Word8. am I doing something wrong here?
15:18:55 <quchen> monochrom: Boo
15:19:08 <hpc> werbitt: for instance, rpn "3 2 + 6 5 *" returns "5 30", if someone wants to compute many things at once
15:19:39 <hpc> this leads nicely to things like saving an "answer buffer" and supporting list operations like sum or a difference engine
15:20:33 <monochrom> what has happened to unary operators? why are you discriminating against them? :)
15:21:59 <werbitt> That's reasonable in this case, but in the more general case of simple functions that you know don't have to be exhaustive, is there a best practice generally?
15:22:40 <hpc> werbitt: return an Either RPNError Result
15:22:46 <werbitt> for instance I could change rpolish to :: [Token] -> Maybe Integer
15:23:11 <werbitt> but if I assume I'm checking the input earlier in the program then that doesn't seem right
15:24:25 <werbitt> monochrom: I haven't implemented them yet, ha
15:25:19 <c_wraith> let me double-check..  negative position is arguments, positive position is the result?
15:25:56 <hpc> (neg -> pos)
15:26:01 <hpc> and double negation is positive
15:26:38 <tac> the final is also the only "strictly" positive position.
15:26:50 <tac> as a double negative is not positive when viewed under an intuitionistic lens
15:26:52 <werbitt> actually, i guess if I figure out what head does I'll have my answer
15:27:08 * hackagebot data-partition 0.2.0.1 - A pure disjoint set (union find) data structure  http://hackage.haskell.org/package/data-partition-0.2.0.1 (LukePalmer)
15:27:10 * hackagebot hspec 1.6.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.6.2 (SimonHengel)
15:27:37 <hpc> werbitt: head [] = error "Prelude.head: empty list"
15:31:35 <werbitt> I see, so I could put an error there, that would theoretically never get called. or as monochrom mentioned, I could just put a comment there.
15:32:06 <monochrom> it may be safest to do both
15:32:09 * hackagebot hspec-meta 1.6.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.6.2 (SimonHengel)
15:33:58 <c_wraith> hpc: interesting..  proxy and unproxy from the tagged library - they move the unused type variable back and forth between positive and negative position.  handy.
15:37:09 * hackagebot hlibgit2 0.18.0.10 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.10 (JohnWiegley)
15:37:11 * hackagebot elm-server 0.9.0.1 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.9.0.1 (EvanCzaplicki)
15:37:13 * hackagebot Elm 0.9.0.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.9.0.2 (EvanCzaplicki)
15:43:56 <enthropy> the cases where syb would be most helpful are always when there is no Data instance
15:45:11 <edwardk> talking about SYB reminds me i need to submit more 'virtual constructor' patches to various libraries like vector.
15:45:22 <edwardk> so that Data can stop silently bombing on people
15:46:12 <jfischoff> ?
15:46:35 <hpaste> manulari pasted “triggers Illegal polymorphic or qualified type” at http://lpaste.net/91793
15:47:26 <manulari> can anyone say if what i'm trying to do should not work or if i have just run into a limitation of ghc?
15:47:37 <manulari> (concerning the hpaste)
15:48:41 <manulari> (this doesn't of course do anything really useful at this stage, just tried to isolate where things first stopped working)
15:49:01 <edwardk> jfischoff: i had patches go in to change out the Data instances for containers a while back so they give you a virtual 'constructor' of 'fromList' rather than tell you you can't go any deeper.
15:49:09 <edwardk> jfischoff: the same thing can be done to vector, etc.
15:49:32 <c_wraith> manulari: you can't do that with type.  you need a data constructor.
15:49:33 <edwardk> it makes the world universally a better place for generic programming
15:50:00 <jfischoff> sounds interesting, I don't use Data that much though
15:50:52 <MingsPing> hello!
15:50:59 <Rarrikins> Hello.
15:51:22 <MingsPing> i've got a little question. is there a better solution for the following:
15:52:06 <MingsPing> (:) <$> return 2 <*> (IO list of ints)
15:52:37 <johnw> (2:) <$> (IO list of ints)
15:53:01 <MingsPing> ha right :-)
15:53:27 <MingsPing> lol sometimes i forget the simplest things (partial application of functions)
15:55:20 <MingsPing> thanks for the answer johnw, and very fast actually
15:55:32 <johnw> happy to help
15:55:39 <MingsPing> :-)
15:57:59 <carter> edwardk: ohyeah!
15:58:02 <carter> you were telling me about htis
16:03:59 <manulari> c_wraith: thanks! yeah, i think i have stumbled into that before... i was kind of hoping i could use constructions like the MyStringPair from my paste instead of ADTs. because i can do most things that i could do with ADTs with them and they have the added benefit (in my use case) that i get something resembling implicit type casting be declaring instances.
16:04:40 <manulari> i was hoping to use this kind of thing in a sort of dsl which i was hoping to make as terse as possible - hence the desire for the "invisible casting"
16:06:21 <manulari> adding a constructor in some places kind of defeats that purpose - any idea if anyone has played with something similar and come up with good ideas?
16:07:14 * hackagebot elm-server 0.9.0.2 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.9.0.2 (EvanCzaplicki)
16:12:47 <heatsink> manulari, that polymorphic type means that every time 'MyStringPair' is mentioned in the code, it can stand for a different type.  That's probably not what you want.
16:13:31 <manulari> heatsink: it is.. that is the exact point
16:16:49 <manulari> heatsink: it's for a thingy i'm writing for university. i talk about category theory. i wanted to have a dsl for building the latex expressions that describe e.g. a functor from some category to a functor category applied to some object of the first category, and then the result applied to something again (for example)
16:17:57 <manulari> so i want to have something that can either appear in the context where it should be a string (where it would print as just the name of the original functor) or that can appear in a context where it should be a function from some type to a string
16:18:02 <hpaste> enthropy pasted “Generic GenericPackageDescription!” at http://lpaste.net/91796
16:18:53 <manulari> or in a context where it should be a function C1 -> C2 -> String
16:19:29 <Nisstyre> manulari: you *may* want to look at Template Haskell
16:19:47 <heatsink> That sounds like an ADT.
16:20:07 <heatsink> Can you give me an example of a value of type MyStringPair?
16:20:35 <burz> hey guys, I'm trying to find out more information about what the "{-# LANGUAGE * #-}" construct does, but I'm having a bit of trouble finding documentation. Would anyone happen to know where it is?
16:20:37 <manulari> there's one in the hpaste: mkStr "a" "b"
16:21:01 <enthropy> burz: ghc's manual
16:21:05 <Fuuzetsu> :t (<$$>)
16:21:06 <lambdabot>     Not in scope: `<$$>'
16:21:06 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
16:21:14 <Fuuzetsu> Isn't there a flipped version of <$> somewhere?
16:21:17 <Nisstyre> burz: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
16:21:26 <Fuuzetsu> @hoogle (<$$>)
16:21:26 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
16:21:26 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
16:21:31 <heatsink> The Haskell language definition explains what LANGUAGE is for: http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3
16:21:31 <hpc> @. @hoogle @type fmap
16:21:31 <lambdabot> Plugin `compose' failed with: Unknown command: "@hoogle"
16:21:35 <burz> Thanks Nosstyre and enthroy
16:21:44 <hpc> @. hoogle type fmap
16:21:44 <lambdabot> Parse error:
16:21:44 <lambdabot>   Functor f => (a -> b) -> f a -> f b
16:21:52 <hpc> :(
16:22:31 <heatsink> GHC's language extensions are here http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
16:24:10 <MingsPing> i've got a second question: is there a built in function (or in data.list) which does the following:
16:24:11 <MingsPing> (take int xs) ++ drop (int+1) xs)
16:24:22 <burz> Is there some added benefit to using lambdabot as opposed to ghc? Why do people use it?
16:24:29 <heatsink> manulari, that's not a first-class value in Haskell.  When you pass 'ab' to a function, it does not have type 'MyStringPair'.
16:24:41 <c_wraith> burz: it's useful for communicating with other people.
16:24:42 <Fuuzetsu> MingsPing: You can use Hoogle to look for such functions: just look for the type of it
16:24:52 <heatsink> Instead, it gets instantiated to a value at some particular choice of 'a' and that value is passed to a function.
16:25:13 <enthropy> > splitAt 5 "MingsPing"
16:25:14 <lambdabot>   ("Mings","Ping")
16:25:21 <Fuuzetsu> burz: someone can always pitch in their idea to do something differently this way, or you just happen to be in the IRC window
16:25:25 <shachaf> Fuuzetsu: Hoogle will tell you a definite yes but not a definitive no, so that doesn't help MingsPing that much (since the answer is no).
16:25:49 <MingsPing> i searched for Int -> [a] -> [a]
16:25:58 <MingsPing> and it only shows drop and take
16:26:02 <burz> Ah, I see how it would be useful in explanations and discussions. Thanks.
16:26:25 <Iceland_jack> MingsPing: You might be interested in adjust (∷ (a → a) → Int → Seq a → Seq a) and update (∷ Int → a → Seq a → Seq a) in Data.Sequences
16:26:26 <MingsPing> (so i actually searched hoogle and hayoo before)
16:26:45 <shachaf> Iceland_jack: Neither of those does what they asked for...
16:26:55 <Fuuzetsu> Heh, I saw some poor chap reimplement most of Data.List because he thought the functions didn't exist yet. His implementation only differed by having the first two arguments fliped…
16:27:01 <shachaf> MingsPing: The answer is no, but you can make it with splitAt or something.
16:27:06 <Hafydd> "int" is an awful variable name.
16:27:14 <Hafydd> If it stands for what I think it does.
16:27:18 <MingsPing> okay thx shachaf
16:27:21 <hpaste> manulari pasted “type classes as ADTs” at http://lpaste.net/91797
16:27:29 <shachaf> MingsPing: However, if you're doing a lot of indexing, you probably shouldn't be using lists (or you shouldn't be doing a lot of indexing).
16:27:36 <adnap> Are there reasons to not use a number type like float, but where values of infinity an negative infinity are clamped to [float_min, float_max]? The fact that infinity * 0 = NaN is troublesome because it pollutes all further expressions, but 0 * float_max = 0.
16:27:44 <MingsPing> okay
16:27:45 <manulari> heatsink: i think it is, see the new hpaste
16:28:48 <manulari> that compiles for me and f ab gives "a,bab" in ghci
16:29:47 <manulari> heatsink: that is to say i think it is a first class value
16:30:05 <heatsink> Do you have RankNTypes enabled?
16:30:08 <manulari> yes
16:30:15 <manulari> sorry
16:30:19 <manulari> missed that in the paste
16:30:43 <manulari> was in the part of my editor window that wasn't visible
16:31:20 <c_wraith> is it acceptable to use OverlappingInstances to provide an instance for one particular type that has identical semantics to what it's overlapping, but a more efficient implementation?
16:31:22 <heatsink> That lets you pass polymorphic types to functions, but you still can't put a MyStringPair in a list.  That's enabled with ImpredicativeTypes, but type inference acts a little bit unpredictable if you turn it on.
16:31:33 <c_wraith> a little?
16:31:38 <heatsink> c_wraith, that's the usual use for OverlappingInstances
16:31:50 <c_wraith> ImpredicativeTypes makes inference *crazy* unpredictable
16:32:21 * adnap boop
16:32:48 <hpaste> manulari revised “type classes as ADTs”: “type classes as ADTs” at http://lpaste.net/91797
16:38:30 <heatsink> I think that ADTs are a better approach.  With an ADT, you can do the casting in the functions that operate on values, so you only have to cast when converting to/from the ADT
16:39:31 <heatsink> It will be more explicit than type classes, but only when values go in and out of the library.
16:40:31 <heatsink> You don't need that show instance, manulari, you just need an explicit type signature when you use 'show'.
16:42:15 <manulari> heatsink: the Show instance was only there as an example for trying to make MyStringPair (or any other pseudo-ADT) an instance of some typeclass
16:42:56 <structuralist> is there some way of doing arithmetic at the type level with actual "1+1" notation? I can't remember
16:43:24 <Nisstyre> structuralist: I think there is an extension for it
16:43:38 <Nisstyre> can't remember, someone else here knows
16:43:46 <manulari> but yes, trying to make a [MyStringPair] list and working with it i see what you mean, it wants more type signatures from me than i think reasonable
16:44:13 <manulari> i guess i'll abandon the approach i was trying here and go with simple ADTs like you said
16:44:55 <manulari> thank you
16:45:09 <heatsink> http://ghc.haskell.org/trac/ghc/wiki/TypeNats
16:45:18 <monochrom> manulari: the problem is that you are looking at "[forall a. TC a => a]" and "instance Show (forall a. TC a => a)". this is impredicative types. GHC can't do it. (an old version tried, not very successful)
16:46:01 <shachaf> The latter has a bigger issue than just impredicativity.
16:46:07 <heatsink> manulari, type class overloading on polymorphic types is ambiguous
16:46:27 <heatsink> It's like (show . read) in that the type in the middle is undetermined
16:48:03 <c_wraith> "No instance for (SingI Nat (10 + 5))"  Hmm.  That's a bit discouraging.
16:48:06 <monochrom> similarly, "Maybe (forall t. t->t)" can't be done
16:48:22 <arkeet> c_wraith: still no nat solver? =(
16:48:30 <shachaf> c_wraith: + -- and the whole natural thing -- pretty much doesn't work in 7.6.
16:48:39 <arkeet> does it work in HEAD?
16:48:43 <shachaf> I think so?
16:48:47 <arkeet> ok
16:48:52 <raisdead> Can this explicit recusion be expressed using higher order function? `foo f a = foo' f [] a; foo' f a [] = []; foo' f head (thx:abd) = (map (f thx) head, map (f thx) abd) : foo' f (thx:head) abd`. Appliction is the nBody problem using the all pairs method. `foo force particles`
16:49:18 <c_wraith> shachaf: they've worked for my needs in 7.6 - but I'm just statically tagging things, not doing arithmetic
16:49:47 <shachaf> Well, OK.
16:49:47 <arkeet> yeah, ghc 7.6 doesn't know any arithmetic.
16:50:14 <tabemann> haskell with (very limited) dependent types...
16:50:14 <shachaf> Not even simple "arithemtic" as in 2 being a successor of 1.
16:50:16 <arkeet> just expressions.
16:50:33 <c_wraith> Funny that it has the type families for arithmetic, but doesn't know what they resolve to
16:51:11 <hpc> raisdead: it looks like some kind of scanr
16:51:14 <hpc> :t scanr
16:51:15 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
16:51:25 <hpc> your thing :: (a -> a -> b) -> [a] -> [([b], [b])]
16:52:14 <hpc> or perhaps actually scanl
16:52:40 <hpc> > scanl (+) 0 [x, y, z] :: [Expr]
16:52:41 <lambdabot>   [0,0 + x,0 + x + y,0 + x + y + z]
16:52:51 <hpc> yeah, scanl
16:52:59 <manulari> heatsink: yes, i see what you mean. show ab in my example can mean a lot of things... i guess i didn't think about this long enough. thanks for helping :-) i'm usually relatively good at deciding whether something i'm writing has _some_ reasonable interpretation consistent with my model of what ghc-haskell is, but usually not so good at seeing immediately if the class of things it belongs to has a reasonable unambiguous interpretat
16:53:02 <arkeet> I think the nicer way would just be to generate a list of all pairs.
16:53:09 <arkeet> > join (liftA2 (,)) [a,b,c]
16:53:10 <lambdabot>   [(a,a),(a,b),(a,c),(b,a),(b,b),(b,c),(c,a),(c,b),(c,c)]
16:53:16 <raisdead> hpc: Thanks. Ill fill i the blanks
16:53:21 <arkeet> but maybe you don't want all those pairs.
16:53:50 <hpc> "Application is the nBody problem using the all pairs method."
16:54:06 <arkeet> > let pairs [] = []; pairs (x:xs) = map ((,) x) xs ++ pairs xs in pairs [a,b,c]
16:54:07 <lambdabot>   [(a,b),(a,c),(b,c)]
16:54:09 <manulari> and therefore my main problem is that i make up things that i think should work in ghc but which don't work because of ambiguity problems
16:54:30 <hpc> raisdead: do arkeet's suggestion first; digging into fold territory is bad enough, scans are even trickier to read
16:56:45 <meretrix> My local lambdabot has died.  Any idea what's wrong: "Unable to run lambdabot: fd:10: hFlush: resource vanished (Broken pipe)"?
16:57:03 <arkeet> @let tails' [] = []; tails' (x:xs) = (x,xs) : tails' xs
16:57:05 <lambdabot>  Defined.
16:57:22 <arkeet> > evalStateT (replicateM2 (StateT tails')) [1..4]
16:57:23 <lambdabot>   Not in scope: `replicateM2'
16:57:23 <lambdabot>  Perhaps you meant one of these:
16:57:23 <lambdabot>    `replicateM...
16:57:27 <arkeet> > evalStateT (replicateM 2 (StateT tails')) [1..4]
16:57:31 <lambdabot>   [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
16:57:44 <heatsink> np manulari, it's good practice for designing software
16:58:04 <arkeet> > evalStateT (replicateM 3 (StateT tails')) [1..4]
16:58:08 <lambdabot>   [[1,2,3],[1,2,4],
16:58:10 <arkeet> eh
16:58:12 <arkeet> > evalStateT (replicateM 3 (StateT tails')) [1..4]
16:58:15 <lambdabot>   [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
16:58:37 <arkeet> I love StateT
16:59:23 <shachaf> arkeet: That relies on State's tuple being swapped. :-(
16:59:53 <arkeet> I think it's the right way.
17:00:11 <arkeet> a -> State s b  ~  a -> s -> (b,s)  ~  (a,s) -> (b,s)
17:00:16 <shachaf> Do you think Writer's is the right way, too?
17:00:20 <arkeet> I have no idea.
17:00:26 <shachaf> Writer a b = (b,a)
17:00:50 <arkeet> in any case, if it was the other way around, I'd just swap the pairs in tails'
17:01:38 <arkeet> > tails' [1..4]
17:01:42 <lambdabot>   [(1,[
17:01:43 <arkeet> > tails' [1..4]
17:01:47 <lambdabot>   mueval-core: Time limit exceeded
17:01:48 <arkeet> =(
17:01:56 <arkeet> blelliott.
17:02:34 <elliott> thanks for the blessing
17:02:56 <tabemann> > tails' [1]
17:03:00 <lambdabot>   [(1,[])]
17:03:01 <arkeet> > tails' [1..4]
17:03:05 <lambdabot>   [(1,[2,3,4]),(2,[3,4]),(3,[4]),(4,[])]
17:03:13 <tabemann> strange
17:03:16 <arkeet> yes
17:03:19 <arkeet> blame elliott
17:03:38 <arkeet> I'll be honest, it's more fun to blame elliott than Cale
17:03:45 <shachaf> @quote blame
17:03:45 <lambdabot> lispy says: When in doubt, blame dons
17:03:48 <shachaf> @quote blame
17:03:48 <lambdabot> cmccann says: some people blame themselves, some people blame the language, but the people who really know what they're doing blame shachaf.
17:03:56 <shachaf> @quote blame.elliott
17:03:56 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
17:03:56 <arkeet> :)
17:04:15 <chrisdotcode> hello everyone :)
17:04:18 <shachaf> @quote blame
17:04:18 <lambdabot> ozone says: when in doubt, blame the GHC RTS
17:04:21 <shachaf> @quote blame
17:04:21 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
17:04:25 <shachaf> Hmm.
17:04:34 <arkeet> hmm
17:04:36 * cmccann deduces that the GHC RTS is actually shachaf in disguise.
17:05:33 <monochrom> arkeet sees what I see
17:05:38 <arkeet> ??
17:06:24 <monochrom> you need to pre-process with tails', before it fits scanl
17:06:55 <arkeet> you mean with pairs?
17:07:18 <raisdead> > scanl (+) 0 [x,y,z]
17:07:19 <lambdabot>   [0,0 + x,0 + x + y,0 + x + y + z]
17:07:21 <arkeet> also tbh I didn't really think about the original problem a lot.
17:07:30 <arkeet> I just saw someone wanting to do something with pairs of things.
17:08:06 <arkeet> @@ @let @where select
17:08:07 <lambdabot>  Defined.
17:08:24 <arkeet> > evalStateT (replicateM 2 (StateT select)) [1..4]
17:08:27 <lambdabot>   [[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]]
17:08:56 <raisdead> When I try `> scanl (+) 0 [x,y,z]` on my lambdabot I get not in scope '[Expr]'
17:09:15 <arkeet> x, y, z are from SimpleReflect
17:09:28 <arkeet> as is Expr
17:09:29 <arkeet> in lambdabot, anyway
17:10:13 <arkeet> @hackage show
17:10:13 <lambdabot> http://hackage.haskell.org/package/show
17:10:24 <arkeet> hm, no
17:10:38 <arkeet> @hackage simple-reflect
17:10:38 <lambdabot> http://hackage.haskell.org/package/simple-reflect
17:11:24 <raisdead> cabal says it is already installed
17:12:11 <arkeet> maybe you need to import it then
17:13:07 <pentace> Can anyone please help me to understand the result type of zipMatch from http://hackage.haskell.org/packages/archive/unification-fd/0.8.0/doc/html/Control-Unification.html#t:Unifiable ?
17:13:17 <pentace> E.g. what is a "one-level spine"?
17:33:05 <forkio> Hey, I'm using ‘mask’ to mask asynchronous exceptions but I'm not sure it's working: I run (do tid ← forkIO (mask_ (do threadDelay (10^6 * 2); putStrLn "DONE")); threadDelay (10^6); killThread tid; threadDelay (10^6 * 2)) and I expect mask_ to mask everything from asynchronous exceptions, yet (killThread tid) seems to kill the thread before printing DONE
17:33:09 <forkio> What am I missing?
17:33:49 <edwardk> aren't you supposed to mask before you fork?
17:33:54 <forkio> If I use ‘uninterruptibleMask_’ it works
17:34:06 <forkio> Oh, I am?
17:34:19 <forkio> Maybe I'm misunderstanding how to use mask
17:34:21 <edwardk> and that way the thread never becomes available to kill until you unmask it
17:34:33 <edwardk> the problem is until the mask_ executes i can kill it your way
17:34:52 <edwardk> but with mask_ (forkIO …)   the forked thread copies the mask state from the thread it is forked from
17:34:57 <edwardk> so it never was killable
17:35:18 <forkio> But I take care to sleep for one second before throwing the exceptions to the thread
17:35:25 <edwardk> and then the main thread immediately reverts to doing what it wants to do
17:35:26 <forkio> so that should be plenty of time to the mask to take effect no?
17:35:36 <forkio> *for the
17:35:49 <edwardk> reasoning that way is inherently race-condition inducing
17:35:55 <edwardk> i'm not sure of any other issues
17:36:03 <forkio> OK I tried reversing the order of forkIO and mask_
17:36:08 <edwardk> i'm merely pointing out the ordering of mask and fork you have there is a bad design ;)
17:36:09 <forkio> and it still doesn't print DONE
17:36:18 <forkio> That's a fair point :)
17:37:01 <forkio> I'm just trying to find the minimal example of mask_ so that I can see it working
17:37:05 <edwardk> w.r.t to the rest i'll leave you to someone who actually uses these primitives ;)
17:37:34 * hackagebot SVGFonts 1.3.0.1 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.3.0.1 (BrentYorgey)
17:38:53 <pentace> dolio: FYI, logict > 0.4.2 is not buildable with mtl-1.1.0.2 ("Control\Monad\Logic.hs:161:9: No instance for (F.Foldable Identity)"), although the dependencies suggest it is
17:39:40 <dolio> Hmm.
17:46:34 <raisdead> :t (. fst)
17:46:34 <lambdabot> (b -> c) -> (b, b1) -> c
17:47:34 * hackagebot sifflet-lib 2.2.0 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-2.2.0 (GregoryWeber)
17:47:36 * hackagebot sifflet 2.2.0 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-2.2.0 (GregoryWeber)
17:48:28 <raisdead> :t (. fst) . (==) . fst
17:48:29 <lambdabot> Eq b => (b, b2) -> (b, b1) -> Bool
17:48:38 <raisdead> :t (fst) . (==) . fst
17:48:39 <lambdabot>     Couldn't match type `b1 -> Bool' with `(c0, b0)'
17:48:39 <lambdabot>     Expected type: b1 -> (c0, b0)
17:48:39 <lambdabot>       Actual type: b1 -> b1 -> Bool
17:48:40 <edwardk> :t (==) `on` fst
17:48:41 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
17:48:59 <raisdead> :t on
17:49:00 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:49:07 <edwardk> point-free as a goal unto itself seems silly ;)
17:49:21 <timinlondon> hey!
17:49:42 <Ghoul_> :t zipWith
17:49:48 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:49:48 <edwardk> its great right up until its not ;)
17:51:24 <Ghoul_> > zipWith (+) [1..] [4..]
17:51:26 <lambdabot>   [5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55...
17:51:26 <timinlondon> anyone know a good tutorial that takes you through the basics? one they found particularly helpful
17:51:26 <c_wraith> @where lyah
17:51:26 <lambdabot> http://www.learnyouahaskell.com/
17:51:26 <timinlondon> tnks
17:53:40 * hackagebot storable-static-array 0.6.0.1 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.6.0.1 (CarlHowells)
17:54:22 <tdammers> sometimes, point-free code feels like extreme golfing in C
17:59:23 <edwardk> i love point-free for single arguments. when you can look at something like   cata f = f . fmap (cata f) . out        and compare it to ana g = In . fmap (ana g) . g  -- it just feels right
17:59:32 <edwardk> that you can turn around the pipeline and get the other definition
17:59:40 <edwardk> that is deeply illuminating
17:59:54 <edwardk> (. fst) . (==) . fst    is a science project ;)
18:00:00 <arkeet> :)
18:00:05 <arkeet> @unpl  (. fst) . (==) . fst
18:00:05 <lambdabot> (\ d j -> (fst d) == (fst j))
18:00:21 <arkeet> of course that would just be (==) `on` fst
18:08:29 <flazz> is there a way in ghci (or something else) to add parens to see the associativity of an expression i'm having a hard time reading?
18:12:16 <edwardk> flazz: not that i know
18:15:45 <shachaf> GHC does it with some errors.
18:16:30 <flazz> i just need to get good at making tactical errors
18:17:54 <levi> flazz: ghc-vis could show you the structure of the unevaluated thunks.
18:18:02 <levi> I think ghc-vis is the name of what I'm thinking of.
18:18:19 <shachaf> I think the question is much more syntactic than that.
18:21:03 <levi> Sure, it certainly wouldn't help if it didn't parse.
18:24:13 <levi> Maybe a round-trip through haskell-src-exts would help.
18:26:34 * flebron starts tomorrow teaching a new course in uni, where first year students of math and cs are first introduced to the notion of computation w.r.t. algebra (that is, they see topics in class and then implement them as programs). The language used will be Haskell :)
18:27:27 <Hafydd> What is "computation wrt algebra", again?
18:27:29 <levi> Nice.
18:27:58 <flebron> Hafydd: students see topics in class (algebra) and then implement them as progarms.
18:28:18 <flebron> So they see factorial, and immediately after, fac 0 = 1, fac n = n * fac (n - 1)
18:28:20 <Hafydd> Are they first year students of (maths and cs) or first year students of maths and first year students of cs?
18:28:42 <flebron> First year students. This is the first class they'll have.
18:29:00 <Hafydd> They're first year university students. Haven't they specialised a bit?
18:29:01 <flebron> And it'll be for students who are studying cs, and for students who are studying math.
18:29:08 <Hafydd> I see.
18:29:12 <flebron> Define specialize?
18:29:23 <Hafydd> Chosen a specific area to study. But you've answered that now.
18:29:31 <flebron> The first 2 courses they share, algebra and analysis. Then they diverge.
18:29:48 <Hafydd> Well, I suppose that's somewhat exciting.
18:29:57 <flebron> :)
18:30:08 <Hafydd> I wonder how the mathematics students will take to it...
18:30:17 <flebron> Math students previously could go the entire degree without really doing any computation.
18:30:31 <flebron> Which is quite strange - professional mathematicians use computers all the time.
18:31:12 <flebron> Or maybe they thought computers were just for the applied branch (so things like linear programming), and not for the pure branch, when there's ample stuff available to them (say, Sage).
18:39:15 <imperative_progr> >
18:39:51 <imperative_progr> {p3}
18:40:33 <solrize> math majors usually have to take a numerics class or two
18:42:13 <flazz> levi: thanks i'll check it out
18:43:06 <flebron> solrize: Unfortunately in our case that's only for the "applied" branch. Pure doesn't get it :(
18:43:34 <solrize> pure should have to prove theorems in coq ;)
18:45:00 <flebron> Pehraps we can slowly inch towards that, Haskell -> Agda -> Coq :)
18:46:09 --- mode: ChanServ set +o byorgey
18:47:57 <applicative> pleasantly maladjusted irc client wolfes
18:48:20 --- mode: byorgey set +b *!*wolfes@*.hsd1.ca.comcast.net
18:48:21 --- kick: wolfes was kicked by byorgey ("Fix your IRC client")
18:48:29 --- mode: ChanServ set -o byorgey
18:48:51 <applicative> how do I instruct my criterion Main.hs to make report.html
18:49:00 <liyang> Wait, why … Agda → Coq?
18:49:32 * applicative proposes Haskell -> Idris -> Haskell
18:51:57 <Cale> solrize: I didn't even take a course on differential equations, let alone numerics :)
18:52:36 * hackagebot linear 1.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.2 (EdwardKmett)
18:52:40 <solrize> wat?  how can you understand topology without studying DE's?  :)
18:52:46 <applicative> differential equations are good, as long as you dont have to solve them...
18:53:10 <Cale> solrize: As a generalisation of metric spaces?
18:53:59 <Ghoul_> @pl (\x l -> map (\(z,v) -> f z v) l)
18:53:59 <lambdabot> const (map (uncurry f))
18:54:14 <Hafydd> You need to solve DEs to find the ideal network topology.
18:54:58 <solrize> http://www.techempower.com/benchmarks/#section=data-r6&hw=i7&test=query          haskell :(
18:55:31 <sclv> the haskell code is not very optimized iirc
18:55:47 <sclv> and the snap team at least said explicitly they weren't going to spend any time working on cleaning it up
18:55:51 <sclv> so its up to volunteers
18:56:05 <sclv> and the people that would know how to optimize it, generally don't care
18:56:41 <sclv> they're dumb benchmarks mainly that don't tell you anything
18:56:53 <sclv> except to the extent they point to inefficiencies in our db bindings
18:57:07 <danharaj> it's a matter of fact that Haskell is plain faster than anything that isn't working at the level of C
18:57:26 <danharaj> Well, you know, ML variants can get close too but :P
18:57:47 <sclv> (our db bindings do have lots of inefficiencies)
18:57:51 <chexxor> I wonder if anyone here is familiar with the topic unbounded nondeterminism. I'm trying to understand this - http://what-is-computation.carlhewitt.info
18:58:09 <danharaj> sclv: if you can make the postgresql bindings super fast I will buy you a drink at the next NY meetup.
18:58:24 <chexxor> Actor Model vs Turing's Model, by Carl Hewitt
18:59:59 <flebron> as a point of info, i usually use haskell for competitive programming when the task is numeric in nature, and not something memory-heavy. even using ST and STUArray, I get nowhere near the performance of C using int[]. for numerics, however, gmp shines and you get the fastest dynamic language, by a large margin.
19:00:22 <chexxor> Here's the part that is unclear: http://lpaste.net/91799
19:00:59 <danharaj> flebron: you want to use Vector if you want fast code.
19:01:13 <danharaj> The trick to fast numeric code in Haskell isn't mutability, but stream fusion.
19:01:16 <flebron> unfortunately the version of ghc on SPOJ doesn't have Vector, but I would if I could :)
19:01:21 <danharaj> what
19:01:25 <danharaj> weird.
19:01:27 <flebron> STUArray is the fastest I can get
19:01:51 --- mode: ChanServ set +o byorgey
19:02:18 <sclv> danharaj: i can. where's my drink?
19:02:21 <applicative> dafis thinks STUArray is faster than Vector, but he seems not to use vector much; to go by his stackoverflow remarks
19:02:25 <sclv> oh, you want me to _do_ it
19:02:28 <danharaj> sclv: I need a constructive proof!
19:02:33 --- mode: byorgey set -b *!*wolfes@*.hsd1.ca.comcast.net
19:02:47 --- mode: byorgey set +b *!*wolfes@*.hsd1.ca.comcast.net$##fixyourconnection
19:02:50 <sclv> i can provide an algorithm for making it fast
19:02:56 <sclv> 1) give me two days
19:02:58 <danharaj> can you run it as well
19:03:02 --- mode: ChanServ set -o byorgey
19:03:03 <sclv> haha
19:03:12 <sclv> which bindings do you use?
19:03:23 <danharaj> postgresql-simple et al.
19:03:26 <danharaj> at work at least.
19:05:13 <sclv> i'm 90% certain the problem is in the type marshaling. it always is. http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.5.0/doc/html/src/Database-PostgreSQL-Simple-FromField.html#FromField
19:05:23 <sclv> and if it isn't that, then its because its not doing bulk ops
19:05:41 <danharaj> well atm we are io manager bound via snap
19:05:56 <danharaj> i.e. spinning up processes instead of threads gives us more performance
19:06:26 <sclv> ok then i bet its bulk ops
19:06:42 <sclv> (oh you mean snap is what bounds you, not postgres?)
19:06:50 <danharaj> well we don't know
19:07:09 <danharaj> it's some sort of overhead that occurs outside of haskell land
19:07:46 <danharaj> single threaded performance could always use a boost though.
19:10:22 <sclv> now i'm intreuged. you worried more about reads or writes? big reads or lots of little reads?
19:12:29 <djahandarie> danharaj, I assume you've seen the new IO manager paper?
19:12:35 <danharaj> djahandarie: indeed
19:12:46 <danharaj> sclv: it's not entirely clear, we should talk about it with ryan at the next meetup.
19:13:06 <sclv> sure. i spent some time banging on the hdbc stuff sometime ago
19:13:10 <sclv> haven't looked at the -simple bindings before
19:13:19 <djahandarie> Bang bang bang
19:14:01 <danharaj> sclv: if we could do a straight pipeline from Haskell to PostgreSQL without the foreign call overhead it would be hella sweet :P
19:14:14 <danharaj> I misplaced that blog post that explained how to write C functions that follow the GHC calling convention though
19:29:27 <thoughtpolice> danharaj: unsafe/prim calls don't always magically make things faster, they can easily make things far worse (because generally you'll 'lock' the whole capability on that call, so you can't reschedule, do GCs, etc.) for something like a foreign database call, that could be a huge loss i'd think.
19:29:44 <thoughtpolice> also, that blog post was an insane hack :P
19:30:21 <thoughtpolice> i presume you mean this one, at least: eaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/
19:31:36 <thoughtpolice> er, http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/
21:32:02 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
21:32:02 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
21:32:02 --- names: list (clog AfC joelb Grey_Fox2 Jesin stepkut ptc Haya silasm zoq bergmark cronject satc maxter wting nexx ntus1017 LevelOneDev jascase901 codesoup xl1 shanse xinming tac Philonous__ path[l] lukexi BobFunk seanparsons eldariof vmussa sidus Rarrikins yogurt_truck ludamad amathew Tritlo shrekster purefn1 lusory wtw_ federkasten LucasCampos dysinger LK4D4 vmeson Neqoxec mno2 chirpsalot Croms s00pcan pkrnj Khisanth Kuraitou MrRacoon iol amosr circle RichyB apples`)
21:32:02 --- names: list (glguy soulrain bbee solrize erochester apaku steshaw sclv Guest54726 Cerise dgpratt andares shesek rodrigovidal zRecursive Betal dreixel dimday shepheb predator117 brainwash xpika kcj lester_ lq biscarch miclorb cognominal tabemann kamatsu tavelram Ov3rload Sgeo gseitz burz _boegel_ insejn scottschecter fridim_ zbcm gentleben destiny Nshag cads dolio pseudolio amatsu rest Demos__ Hafydd dabradley dmwit jzelinskie iteratee mjo jeff_s1 chrisdotcode_ tiffany)
21:32:02 --- names: list (leifw` Guest95547 MoALTz_ liammcl parcs centrinia mgsloan OlegYch mceier m3ga voxpopuli h4199 copumpkin pentace ehaliewicz iemejia SLi manud tertl3 morolin mannyv nominolo tikhon lambdakind stelleg Mortomes_ edwardk absence hive-mind boothead gautamc julmae solrize_ coeus katis finity cdk_ Azel redjohn markov_twain pygospa nimish Fubar^ MK_FG tahu msieradzki Vq Tene wollw venice phienone eacameron1 kest10 wormphlegm jdoliner bananagram Shou erkin Twey u_)
21:32:02 --- names: list (otulp Belgarion0 waterlaz joneshf-work joaopizani Kabaka doomlord_ RageOfThou mephx bogdanp totos Fuuzetsu hashcat tommd fogus|out k3VB6u4d thunderrd akiress meretrix scooty-puff sclv_ yacks thomassgn isomorphic enthropy bbloom lunarjar gereedy tg reactormonk aford bduc sirspazzolot milessabin Sculptor ekyo Guest63538 Dtgr byorgey favonia schlumpi kwos algae Noldorin rgrinberg zoktar tpsinnem charlesofarrell_ tunixman augur AntiSpamMeta satshaba1 satshabad)
21:32:02 --- names: list (udevd JaRoel|4d natte osnr jcp mgaare SoupE saep kludge` watermind counterstrike44 roconnor_ whaletechno vnz DexterLB nodeless Axman6 Sebastien-L mbrock YoungFrog sShintah Draconx mak` isenmann orzo stevejb ghorn sinclair|net Boney sutabi latro`a_ canissimia otto_s_ MouseTheLuckyDog Tarential dymatic rhodesd ormaaj mstksg sordina andrewsw fijimunkii bytbox cmears Amadiro joachifm Jonno_FTW miloshadzic identity wooy derekv shergill cdidd dented42 gthorslund)
21:32:02 --- names: list (thorsten` dav desc|zenbook mapreduce kakos jonsterling fabjan profmakx Philippa melter brisbin uu1101 Nahra pjstadig zenoli djahandarie mcbonz dkasak_ linux_noob_666 gbeshers purefn Darkflux sunfun dlundy mmaruseacph2 sababa vili preflex mauke hellome Kyzza Arnoldz mshroyer mel- mjrosenb jbauman kekimmo DarkFox b2coutts KyleCloud gnuvince og fry canta perlite Morgawr zq troydm barrucadu fikusz haasn vpm dan64 adnap maksbotan obiwanko xenophon DrCode zvrba)
21:32:02 --- names: list (lattenwald krakrjak_ xymox ktosiek_ _br_- kloplop321 tudalex ousado resure carter Athas obcode Pad^ ssttudder Krakarn Shin-LaC levi Ralith shelf janinge [mth] maurer kaktus dropdrive ido pcapriotti ircbrowse jackhill junsuijin albel727 solution Fuco davean benj_ jzl bscarlet Natch eyck asjo kubrat theorbtwo Internet13 noddy chrisdone MetaCosm stvc tero- td123 FreeFull rfw blakesmith monochrom shachaf joogi araujo daniel-s ezrios tvaalen torkjak c_14 jaimef)
21:32:02 --- names: list (de-Vri-es rmyers ecube k0ral cods MOMI clahey daira burp b0c1 tauntaun ByronJohnson jssanders aloiscochard|off edkk scshunt ErkiDerLoony lpvb jang1 tehroflmaoer udoprog bartavelle aoh arnsholt Nik05 caleb_9 M-ou-se tomh- peddie_ ssbr mantovani cynick taruti sdx23 arkx so dwierenga mokus Bwild fergusnoble brandonw Spaceghost doshitan peddie Igloo drbean gpampara_off plucas tsou smlgs Counter-Strike callen rasmusto epta jlaire zrot joefiorini Tinned_Tuna)
21:32:02 --- names: list (davidt_ ceii niko tensorpudding swistak35 simon anon123 idoru cheezey ccxCZ Tehnix machisuji felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid guerrilla iulian dpwright KitB tulcod osfameron sgso ivan` jlamothe adimit alpounet dju marienz yam McManiaC epsylon dino- hape01 cajla Work_jack palmje mrshoe Ke FireFly tridactyla SegFaultAX pdxleif BigEndian Ycros jrslepak frontendloader yiannis_t dsantiago Maxdamantus wunki)
21:32:02 --- names: list (`0660 Jaxan vsayer Nimatek Enigmagic twn ethercrow dogmaT dexter1 tomejaguar adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o IanKelling leroux bobry demolithion brixen dyreshark mmathis gilbertw1 lambdabot Iceland_jack lenstr Will| mimi_vx PHO_ mikee Jello_Raptor vehk ab9rf idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer cschneid ParahSail1n Lemmih qz mietek lightquake solancile)
21:32:02 --- names: list (mortberg Raynos tylergillies_ stepcut nik_89 raft helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson sajith KaneTW arkeet heath kloeri Odd_Bloke FUZxxl mxf knyppeldynan divarvel froztbyte _janne BMeph akraut etherfreak vvv drewr Erstarrung jrib zero7 sevvie zebr hdevalence flazz Raynes quicksilver bd__ dsirenko_ Bigcheese go|dfish pikhq d3lxa si14 alej nullcone Sabey upgrayeddd chexxor lopex bentrevor dcoutts pettter drdo)
21:32:02 --- names: list (qwandor hiyakashi tdammers Baughn_ ciaranm srcerer michaf etrepum spligak hpd seneca _flow_ eL_Bart0 shutdown_-h_now wilfredh puzza007 chickenflu warpy Xorlev ortmage ps-auxw akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy joeyh kini Licenser hfaafb nwf jhh banjiewen dthibodeau mykhal blz37 palaga NeatBasis_ ggherdov mikecaruso Eridius|vacation sepeth farn yano aleator milli brett)
21:32:02 --- names: list (bcoppens Martty knz cmsd2 neurocyte ivan\ nonconvergent thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi bezik edwtjo mero vvein levitation[A] koala_man JustAPerson nanothief_ maoe f8l Th0mas tomprince wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra dan_johnsin SaBer neektza1 zerokarmaleft myme1 ggreg otterdam ocharles ysuzuki aess saiam elgot mechairoi Valodim hackagebot WhereIsMySpoon Svedrin)
21:32:02 --- names: list (`bps liori mlh kshannon h_chiro_ stiell alexander__b warpaint int-e sm Tribal sleepybug flux kaw ReinH joar bogner_ tych0 Deewiant tippenein Mayzie noam_ dustinswan zxq9 plhk saiam^ Phlogistique jmcarthur ninzine phryk kryft \q Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc dario^CIP ion klugez gridaphobe wereHamster genisage ve TML pi8029 finnrobi sunnavy_ prophile)
21:32:02 --- names: list (pfoetchen Rembane relrod Proteumus lulf mattp__ chrra LeaChim dumbhat @ChanServ wavewave OrangeDuck tamiko n00dle Kinnison pnielsen sipa wagle geekosaur isomorphismes anders^^_ magicman Dybber mendez Clint sp3ctum cruxeternus birkenfeld seantallen pharaun ericmj bqp XMunkki_ poucet elliott deavid gbarboza asante __main__ b52 caligula__ fryguybob tessier davd petekaz`` Ulrar mrd_ Starfire_ nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay)
21:32:02 --- names: list (tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten Reisen jayne ccasin Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert mikeplus64 lpsmith Draggor horlicks ParahSailin zeiris_ notdan pyykkis mononofu lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus killy9999 Yaniel ejls Watcher7 swook`)
21:32:02 --- names: list (dsp_ bgamari aformeny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid `^_^v zorzar pr aninhumer thetallguy ziman Razz mr- ryanakca thoughtpolice Gilly dilinger_ malorie_ pqmodn_ ttm kaol Soft CosmicRay mornfall schoppenhauer Ornedan jroesch hiredman ski_ joelteon briden liyang guymann supki Zariel smarter skypers flori Sourceless bind companion_cube ChongLi Yawgmoth_ bholst_ tswett mami_ ehamberg Boreeas)
21:32:02 --- names: list (statusfa1led mollerstrand ernst wchun shiona fayden jlouis thorsten1 Maior mviljamaa ofan hvr lispy Saizan luite saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside davorak_ othiym23 brainproxy rce brendan Cryovat Brando753 integral JPohlmann duairc jlewis geoffh BlastHardcheese ahf a11235 mux bstrie s4msung SHODAN slobo_ deggis cow-orke1 kranius Gothmog_ kqr1 zaphar_p1 theDon Elision thetallguy2 mixi Laney gbluma_ MasseR peltchu Hardolaf gemelen)
21:32:06 <tabemann> Twey: sounds fun
21:32:26 <haasn> Hafydd: I think it might be sigmoidal or something
21:32:54 <Hafydd> That's possible, too. I suppose there might be some fundamental limit to how quickly people are going to talk.
21:33:10 <haasn> at the very least, there's bound to be some upper cap after which humans simply cannot read/response quickly enough
21:33:17 <Hafydd> But I've seen people talking pretty quickly!
21:33:58 <haasn> but at the same time, exponential growth patterns make sense because each message reaches more people (who might themselves respond or contribute)
21:34:52 <haasn> this sounds similar to the question of how many people need to greet eachother on IRC to start a chain reaction :)
21:36:43 <Twey> haasn: It's probably related to conversations somehow.  Anecdotally, there are usually fewer than ten people involved in a conversation, and there may be up to about three separate conversations going on at a time in a channel
21:36:54 <Twey> Regardless of channel population
21:38:08 <haasn> Twey: conversation speed might be inversely proportional to the number of participants; eg. if we observe large forums or mailing lists
21:38:42 <tabemann> concurrent design question - when using STM, because STM can't protect non-STM resources, is thread-switch latency a factor that may discourage using a single thread that responds to requests on a TChan which then acts on a given resource, in situations where latency may be a factor?
21:39:15 <johnw> tabemann: I almost followed that
21:39:24 <tabemann> or does thread-switching with STM in GHC Haskell of low enough latency that that would not be a problem?
21:39:29 <Twey> tabemann: Thread-switch latency in GHC is *tiny*.
21:39:38 <johnw> yeah, it's not really STM-related
21:39:38 <Twey> And getting smaller.
21:39:50 <johnw> the STM question is whether there will be excessive transaction restarts
21:39:53 <Twey> I wouldn't generally consider it
21:40:12 <Twey> haasn: Oh, I thought we were just talking about IRC
21:40:43 <Twey> haasn: I was about to postulate that the limited size of a chat buffer and the mental energy required to sift through messages is an upper bound on channel activity
21:41:02 <haasn> Twey: my last message was sort of a deviation; I just considered what communication mediums typically have more than 10 users
21:41:08 <tabemann> I just wonder about thread-switch latency because in a test I did at a previous job, we were running into a wall at 1000 thread switches a second... but this was with pthreads, which has a completely different threading model from GHC
21:41:13 <Twey> Which obviously doesn't apply so much to slower communication media or those with threads
21:41:30 <Twey> tabemann: GHC's ‘threads’ are much, much lighter
21:41:36 <tabemann> Twey: I know
21:41:42 <johnw> tabemann: GHC can easily deal with millions of threads
21:41:56 <tabemann> I was wondering about latency, not about number of threads supported, though
21:42:03 <johnw> in fact, I don't even really think about it now, threading is almost just another control structure
21:42:15 <haasn> Twey: but you're right, the nature of how IRC clients tend to operate itself might be the determining factor in the scale IRC communications
21:42:33 <haasn> the scale of*
21:42:56 <satc> Is there a way to custom align pointers given by mallocBytes or  associated  function?
21:43:07 <tabemann> johnw: I still have to wrap my brain around threads *not* being expensive to have around
21:43:17 <johnw> tabemann: yeah, it was really a change to me too
21:43:22 <tabemann> (and switches between threads being slow)
21:43:26 <johnw> I had gotten into the habit of thinking of threads like processes
21:43:42 <johnw> processes with shared memory; but GHC is at the absolute other end of the spectrum
21:43:54 <johnw> threads are more like just multiple instruction pointers
21:43:57 <Twey> Heh
21:44:08 <Twey> ‘Process’ is a sadly abused term
21:44:08 <tabemann> the other part of me is wondering why aren't the rest of the world using M:N threads like GHC and Erlang if they've worked out so well for GHC and Erlang
21:44:42 <johnw> tabemann: maybe because locking is so expensive that they wouldn't see much performance benefit
21:44:45 <haasn> tabemann: my guess is that other languages store more context between threads that delay switching?
21:44:53 <Twey> tabemann: There are libraries for a lot of languages, but I believe the optimization is related to language design
21:45:23 <tabemann> Twey: I've seen the term process used for Erlang, to emphasize that it *isn't* a shared memory environment
21:46:53 <Twey> tabemann: Yeah.  ‘Process’ vs. ‘thread’ is supposed to be a no-shared-memory vs. shared-memory distinction, but because of popular OS implementations people have come to think of threads as ‘lightweight processes’.  GHC and Erlang both have processes (with message-passing), not threads, for example.
21:46:54 <tabemann> johnw: locking when done *correctly* doesn't have much performance impact... it's more a matter that it's so hard to get *right* and *fine-grained* that typically in big systems you have to choose between one or the other
21:47:23 <johnw> yeah, that's true
21:47:27 <johnw> I've even seen lockless queues in C++
21:48:19 <tabemann> Twey: umm doesn't GHC have threads
21:50:09 <tabemann> johnw: I've never actually worked with lockless data structures myself in C++, even though at times I would rely on the fact that a write of a single machine word would be atomic...
21:50:38 <tabemann> single *aligned* machine word, that is
21:51:08 <Twey> tabemann: Depends whether you consider MVars shared memory or message-passing, I suppose
21:51:31 <tabemann> well STM is definitely a matter of shared memory
21:51:53 <Twey> Aye, you're right.  I take it back.
21:52:12 <Saizan> atomicModifyIORef :)
21:56:47 * tabemann is kind of surprised that Microsoft is considering its implemention of STM for .NET a failure, when STM is so obviously a better solution than locking and condition variables-based concurrency control...
21:56:53 <solrize_> how does that work?   i half remember an stm-like CAS mechanism
21:57:08 <johnw> tabemann: STM is hard to do without purity and isolation of effects
21:57:12 <solrize_> .net stm failed because they wanted to do i/o inside transactions and it complicated everything til it fell over
21:58:12 <tabemann> johnw: at work I've been playing around with doing STM in Java, and there it's just "don't do IO or modify shared state inside a transaction!"
21:58:26 <haasn> launchMissiles >> retry
21:58:37 <tabemann> solrize_: and they should've known better than to try that
21:58:58 <tabemann> unless they were trying to set up some protocol to delay side-effecting operations until later, which *is* possible provided the proper support
21:59:06 <tabemann> (e.g. Clojure supports that)
21:59:32 <johnw> tabemann: yeah, like everyone is going to obey that :)
21:59:47 <haasn> tabemann: that would sort of just be ‘O’ then, not ‘I’, no?
21:59:56 <johnw> it took decades of saying global variables were bad for people to.... keep using global variables in every project I've ever seen
22:00:30 <tabemann> well that's why Haskell is good for STM - because it *forces* you to not do things that are bad for STM, at least accidentally
22:00:52 <tabemann> haasn: well of course
22:01:22 <haasn> do { launchMissiles; i <- observeConsequences; if isPositive i then return () else retry }
22:01:33 <tabemann> in theory you can do I too... but only if you do something like seek to a fixed point in a seekable file before reading inside a transaction, so that if you retry you'll seek to the same point again
22:01:35 <johnw> haha
22:02:50 <haasn> tabemann: the kind of stuff you could do by perform the necessary (lazy) IO before actually running the transaction, I suppose
22:03:28 <tabemann> hmm... yeah, you *could* do lazy IO inside a transaction
22:03:55 * tabemann still wonders why exactly they had to create unsafeIOToSTM, though
22:05:52 <haasn> curious indeed, the documentation doesn't list any clear use cases
22:07:30 <tabemann> they should make you do a pragma before letting you use that kind of thing
22:07:55 * hackagebot cipher-aes 0.2.1 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.1 (VincentHanquez)
22:08:06 <yan_> can anyone mention in a few words as to where existential types work when a, say, normal ADT fails?
22:08:33 <yan_> most examples i read about, the existential type can usually be replaced with an algebraic type
22:08:35 <tabemann> yan_: if you want to put multiple values of a given ADT in a data structure which are heterogeneous w.r.t the contained type
22:08:38 <haasn> “when you need existential types” ;)
22:08:52 <tabemann> and the contained type is unknown to that which forms the container
22:08:54 <yan_> haasn: i guess the very nature of my question involved a definition :)
22:08:58 <haasn> yan_: in some cases, it can be a performance thing
22:09:16 <haasn> yan_: eg. if storing some value directly is better for performance than storing an (equivalent) ADT representation of it
22:09:30 <tabemann> because with an existential type, it just has to be a member of a given class in typical uses
22:09:45 <solrize_> http://softtalkblog.com/2010/05/18/microsoft-discontinues-software-transactional-memory-experiment/
22:10:00 <yan_> haasn: i feel the type theoretic view is more important to understand first before the 'ET as an optimization' view
22:10:20 <glosoli> hmm what are some repl like packages for Haskell available in Emacs ?
22:11:09 <Twey> glosoli: There's an inferior Haskell mode; just hit C-c C-l in a Haskell buffer
22:11:12 <haasn> yan_: maybe Control.Exception can offer insights to a use case? I don't work with exceptions much myself but I know they use existential types for matching over exceptions and stuff
22:11:21 <yan_> tabemann: can't you have a purely generic type variable instead of having it be existential? not sure if my questions are making sense, but i guess in my head, types are well-defined sets of things and i fail to see the obvious use case for them
22:11:49 <tabemann> yan_: no, if you want to have a heterogeneous mixture of contained types in some container
22:12:14 <tabemann> because you can't have a type which is parameterized against a type class
22:12:22 <yan_> tabemann: so with ET, you willfully give up the type system for this specific use case?
22:12:39 <haasn> yan_: an example of the ‘optimization’ case is http://hackage.haskell.org/packages/archive/kan-extensions/3.1.1/doc/html/Data-Functor-Yoneda-Contravariant.html
22:12:40 <glosoli> Twey: Hmm wow man, thanks!
22:12:57 <tabemann> yan_: no, because you can specify that the existential type is of a given type class
22:13:05 <Twey> tabemann: It's not giving up the type system; it's just hiding the type from the outside world
22:13:08 <haasn> ‘Yoneda f a’ is completely equivalent to ‘f a’ (assuming we have a Functor f constraint)
22:13:10 <Twey> Er, yan_
22:13:12 <yan_> tabemann: but if you don't, then in effect that's what you're doing
22:13:28 <tabemann> yan_: well then you can't do anything with the type
22:13:29 <haasn> but the former allows O(1) fmap
22:13:31 <Twey> It's a kind of top type
22:14:13 <tabemann> having an existential type be a member of a type class enables you to use every function in that type class with the existential type
22:14:54 <yan_> tabemann: but that's what a type class /is/
22:15:18 <tabemann> what I mean is that is *necessary* for one to possible use an existential type for anything
22:17:46 <Twey> yan_: Existential types are the difference between saying ‘this returns whatever you like, so long as it has a Show instance’ and ‘this returns something; I'm not going to tell you what it is, but it has a Show instance’
22:18:15 <yan_> Twey: i understand conceptually, i just don't understand the nuance of that in practice
22:19:00 <Twey> yan_: What you get out of the first one is whatever type you specify, by usage or by annotation.  What you get out of the second is an *unknown* type; all you know about is that it has a Show instance.
22:19:00 <haasn> I've never come across a use case for existential types in practice myself, though I think I remember something on this topic from not too long ago
22:19:27 <Twey> The classic example is a list of show'able values
22:19:29 <yan_> haasn: their use in Scala is what got me trying to understand them well, but i always find type-related questions are much more straightforward to answer when applied to Haskell
22:20:31 <Twey> data ShowBox = ShowBox { unShowBox ∷ forall a. Show a ⇒ a }; myList ∷ [ShowBox]; myList = [ShowBox "foo", ShowBox 5, ShowBox ()]
22:21:05 <haasn> oh, the quote I was remembering was about Dynamic in particular, not existentials in general, ie. “2013-07-26 11:42:42  merijn haasn: It involves abuse of existentials, TypeFamilies, GADTs and phantom types, which let me encode stuff in the types that the compiler doesn't know, so you use Dynamic to force the compiler to do what you know is right”
22:21:40 <Twey> If you run unShowBox on an element of that list, what you get back has the existential type forall a. Show a ⇒ a: it could be a String, it could be an Int, or it could be unit, but the the only thing you know about it is that it implements Show
22:22:01 <haasn> Twey: I assume the point yan_ is raising here is that that's equivalent to [String]
22:22:09 <Twey> haasn: But it's not
22:22:51 <Twey> Show has more than just ‘show’ in it
22:23:34 <tabemann> show is only one example; one could have a list of Num a => a values, for instance
22:23:42 <Twey> And if it didn't it wouldn't be too hard to construct an example that did; you can, for example, do the same thing with two different type-classes at the same time, e.g. data ShowReadBox = ShowReadBox { unShowReadBox ∷ forall a. (Show a, Read a) ⇒ a }
22:26:24 <haasn> I'm still somewhat sure that you can represent that by some data ShowReadThing = { show' :: String, read' :: String -> ShowReadThing, ... }
22:28:21 <Twey> haasn: ShowReadThing doesn't make sense as the return type of read'
22:28:40 <Twey> The return type is a
22:28:50 <haasn> but you can't do anything with ‘a’ other than ShowRead things
22:29:11 <Twey> You could say that about anything
22:29:16 <haasn> ?
22:29:27 <Twey> You can apply any function to a that takes a Show
22:29:29 <tabemann> the difference is with existential types you could do a read into *any* contained type that has an instance for Read
22:29:37 <tabemann> and you don't know what it is ahead of time
22:30:01 <Twey> haasn: ‘You can't do anything with X other than <the set of functions defined on X>’
22:30:32 <Twey> Ergo there's no point in having functions, or indeed an X type in the first place; we might as well just store the return types of the functions instead :þ
22:31:12 <tabemann> okay, I need to get to bed now
22:42:56 * hackagebot gloss 1.8.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.8.0.1 (BenLippmeier)
22:42:58 * hackagebot gloss-raster 1.8.0.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.8.0.1 (BenLippmeier)
22:43:00 * hackagebot gloss-examples 1.8.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.8.0.1 (BenLippmeier)
22:43:02 * hackagebot crypto-cipher-types 0.0.2 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.2 (VincentHanquez)
22:47:56 * hackagebot crypto-cipher-tests 0.0.2 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.2 (VincentHanquez)
23:07:57 * hackagebot cryptocipher 0.5.1 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.5.1 (VincentHanquez)
23:15:42 <isomorphismes> http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ "∄ heroku for Haskell" ←how much harder is it to run things on EC2 with a load-balancer than heroku? (To anyone who's done it.) I chat thru EC2, that's easy. Is the rest of AWS much harder?
23:28:39 <zrathustra> hi, I'm a beginner haskeller, having read through LYAH and just finished write you a scheme
23:29:28 <zrathustra> I want to do a personal project (small 2d physics simulator with a pathfinder algorithm with gui), but I was wondering where I could learn standards for building larger software like this with haskell
23:30:24 <zrathustra> for example, in FP style I'd like to write the pathfinding function separately from IO, but would also like to show the paths that the agent is considering
23:30:28 <soulrain> working through LYAH and new myself so I have no idea
23:30:48 <zrathustra> is it possible to separate the two?
23:30:56 <scshunt> zrathustra: yes. I'd recommend using the Writer monad for something like that
23:31:09 <zrathustra> how would I go about doing so? (not specifically this case but in general as well)
23:31:43 <scshunt> zrathustra: basically, return a tuple containing the result and an IO object to display the progress. If the IO isn't "hooked up" to main, then it will be discarded
23:31:57 <scshunt> zrathustra: obviously this isn't the most efficient way, but it works fairly cleanly
23:32:13 <scshunt> http://learnyouahaskell.com/a-fistful-of-monads explains the Writer monad
23:32:25 <zrathustra> awesome, thanks!
23:32:48 <scshunt> oh wait, I lied
23:32:49 <scshunt> http://learnyouahaskell.com/for-a-few-monads-more
23:33:20 <zrathustra> is RWH redundant to LYAH/WYAS, or worth going over? should I just jump in and use SO/IRC to address specific questions?
23:33:30 <scshunt> zrathustra: RWH is worth going over
23:33:40 <edwardk> RWH is good if you want to go through the more systemsy side of haskell
23:33:49 <edwardk> and its good drill over all
23:33:51 <zrathustra> obviously my first project isn't mean to embody all standard practices but I would like to get off to a good start
23:37:32 <haasn> return all the information you want to display in a pure fashion, render this information out in a separate I/O component
23:47:58 * hackagebot repa-algorithms 3.2.4.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.4.1 (BenLippmeier)
