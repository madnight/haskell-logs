00:06:41 <jakening> does haskell use (==) at all in pattern matching?
00:07:09 <mauke> for numbers
00:07:18 <elliott> and strings with -XOverloadedStrings
00:07:20 <jakening> yeah
00:07:23 <jakening> ugh
00:07:31 <jakening> any way to have it not do that?
00:07:41 <elliott> what's your goal here?
00:07:46 <jakening> I'm using SBV
00:08:00 <jakening> and it's complaining that I should be using (.==) instead of (==)
00:08:23 <shachaf> RebindableSyntax will let you use a different (==)
00:08:29 <jakening> there currently are no (==) in my code, and I don't think any other functions are the issue
00:08:35 <elliott> SBV's (.==) doesn't return a Bool.
00:08:39 <elliott> so RebindableSyntax will be of no use.
00:08:40 <elliott> (AFAIK)
00:09:07 <jakening> yeah, returns an SBool
00:09:12 <shachaf> Oh, SBV is a code-generation thing.
00:09:23 <shachaf> You're presumably going to have trouble with pattern-matching in general, in that case.
00:09:31 <jakening> SMT solver, mostly
00:09:40 <jakening> but yeah, has all sorts of weird bindings
00:10:00 <jakening> I don't think pattern matching generally is an issue, but I might be wrong
00:12:10 <jakening> yup, just removed the pattern matches and the exception goes away
00:14:45 <jakening> annoying
00:14:50 <jakening> anyone used SBV much?
00:16:56 <jakening> I can't even compare the SBool to 'true'(::SBool)!
00:21:20 <zvrba> how to convert ByteString to Float or Double?
00:21:34 <zvrba> data is read in from a disk file in native format, so Data.Binary is not applicable
00:24:49 <joelteon> native?
00:24:56 <zvrba> yes, native.
00:24:59 <zvrba> little-endian, for example.
00:25:09 <zvrba> I have a C struct which I write directly to disk
00:26:39 <joelteon> so IEEE 754 then
00:26:45 <zvrba> yes
00:27:16 <joelteon> i actually did something similar recently
00:27:22 <zvrba> Data.Binary has its own serialization format (BE, not only raw data written to disk)
00:27:30 <joelteon> converted a string of bytes in a ByteString into a Word64, then unsafeCoerced it
00:27:31 <zvrba> bytestring has no functions for conversion
00:27:43 <joelteon> pretty sure unsafeCoerce is unsafe, but it works
00:28:53 <zvrba> and still I have to write a fold to convert bs to word32/word64
00:29:04 <joelteon> oh, yeah
00:29:06 <joelteon> dunno how to get around that
00:29:07 <zvrba> Foreign has functions to do conversions
00:29:16 <zvrba> but bs doesn't expose the underlying pointer to the buffer
00:29:36 <zvrba> and haskell is supposed to excel at composition :-P
00:29:54 <joelteon> Data.Binary.Get has getWord64{be,le}
00:30:07 <joelteon> {16,32,64}{be,le} i should say
00:30:31 <zvrba> mm. but I still need Float and Double.
00:30:49 <thoughtpolice> just don't use unsafeCoerce. use a package for it
00:30:52 <joelteon> unsafeCoerce but I can't in good faith recommend that to anyone
00:30:54 <thoughtpolice> @package data-binary-ieee754
00:30:55 <lambdabot> http://hackage.haskell.org/package/data-binary-ieee754
00:31:04 <joelteon> ooooooooorrrr that works.
00:32:34 <zvrba> hah
00:32:50 <zvrba> that one uses unsafePerformIO and does one allocation on each call
00:33:31 <zvrba> how many times should one say "I don't care about efficiency" before it starts to matter? The file is going to be at least 100MB
00:33:59 <thoughtpolice> this was never part of the criteria. that's your call, not mine.
00:34:17 <thoughtpolice> in any case, data-binary-ieee754 should provide a good starting point if you need something highly optimized
00:34:24 <zvrba> sure. I couldn't resist peeking into the implementation.
00:35:39 <zvrba> unsafeCoerce it is :p
00:37:49 <tetsuzan> Hello, I installed the game "Raincat" from Hackage but I don't know how to run it. Could you help me, please?
00:39:03 <shachaf> tetsuzan: Did it install a binary in ~/.cabal/bin/?
00:40:33 <notdan> It should install the 'raincat' executable according to the .cabal file
00:41:27 <tetsuzan> shachaf: Yes, it did. Thanks.
00:42:08 <tetsuzan> notdan: Thanks.
00:44:18 <epsilon__> hello!
00:44:23 <epsilon__> I have a question!
00:44:59 <shachaf> I'd ask what it is, but that'd put me on the spot for answering it.
00:45:16 <shachaf> So just ask the channel. There are a thousand people in here.
00:45:29 <epsilon__> okey dokey
00:45:54 <epsilon__> I couldn't find it using hoogle, but does anyone know of a function with the signature:
00:45:56 <epsilon__> [a] -> ((a->b)->[a]->[b]) -> ((a->b) ->[b])
00:46:52 <shachaf> That type sounds like it could be simplified a bit...
00:47:14 <epsilon__> I'm pretty new to haskell, and it's type system...
00:47:28 <shachaf> How did you end up with that type?
00:47:39 <sipa> a -> (b -> a -> c) -> (b -> c)
00:48:07 * shachaf was trying not to say that yet, but yes.
00:49:49 <maurer> I mean, on implementation of what epsilon__ asked for would be
00:49:53 <jakening> flip the second argument, and apply it to the first
00:50:04 <maurer> m xs _ f = map f xs
00:50:16 <maurer> the second argument looks largely irrelevant
00:50:29 <maurer> (unless what he really wanted was what sipa suggested)
00:50:34 <shachaf> maurer: Or m _ _ _ = []
00:50:54 <shachaf> But I was asking about it in order not to play the guessing game.
00:50:59 <dalaing1> the second argument could be rearranging the list, perhaps
00:51:43 <shachaf> I'd say something about parametricity except that the second argument isn't polymorphic (and it wouldn't be helpful anyway).
00:53:27 <dalaing1> epsilon__: what are you trying to do?
00:53:51 <epsilon__> I'm not describing it very well, but I wanted something that could make map look like a method of a list
00:56:21 <epsilon__> so like, [1..10] `func` map  (2*)
00:56:24 <epsilon__> I think..
00:56:58 <mauke> isn't that just id?
00:57:12 <mauke> well, no
00:57:14 <shachaf> mauke: flip id?
00:57:17 <mauke> yes
00:57:27 <mauke> > [1 .. 10] & map (2*)
00:57:29 <ooesili> EPSILON__
00:57:30 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
00:57:47 <epsilon__> oh
00:57:49 <epsilon__> hooray
00:58:00 <mauke> :t (&)
00:58:00 <lambdabot> a -> (a -> b) -> b
01:01:56 <jakening> ok, another sbv-related issue
01:02:36 <jakening> I have a function (SBV a -> SBV b) -> m a b
01:02:53 <jakening> I can't make tuples an instance of SBV
01:02:54 <jakening> nor functions
01:03:23 <jakening> but I have a binary operator on SBVs that I need to pass to that function
01:03:42 <jakening> so if I could partially apply things, I'd be golden
01:04:05 <jakening> but I don't know any of the values
01:04:10 <jakening> any way around it?
01:04:19 <jakening> thought about godelizing the tuple/function
01:04:51 <jakening> (SBV a, SBV b) -> SBV (2^a*3^b)
01:04:51 <epsilon__> mauke: btw how does one say "&" out loud and how come I don't see it in hoogle?
01:05:05 <jakening> but that seems insane
01:05:10 <mauke> sorry I am not a modem
01:06:10 <Saizan> jakening: how is SBV defined?
01:06:20 <jakening> it isn't exported
01:06:27 <jakening> http://hackage.haskell.org/packages/archive/sbv/2.10/doc/html/Data-SBV.html
01:06:43 <epsilon__> mauke: I don't get it the analogy?
01:06:47 <epsilon__> *get the
01:09:42 <edwardk> carter: do you have that morton interleaver handy?
01:10:51 <hpaste> LambdaDusk pasted “cabal error” at http://lpaste.net/91743
01:11:12 <LambdaDusk> anyone can help me with that error? http://lpaste.net/91743
01:14:59 <supki> LambdaDusk: I think you need the latest tagged installed
01:15:56 <LambdaDusk> supki: It's some dependency for some other lib...
01:16:43 <supki> well, alternatively you could try not-so-latest contravariant :]
01:17:08 <supki> or reinstall all the stuff that depends on tagged
01:19:45 <LambdaDusk> subki: how can I add it to my cabal to use 0.4.1?
01:25:02 <supki> LambdaDusk: well, like any other dependency: contravariant == 0.4.1; you can also use cabal install stuff --constraint='contravariant == 0.4.1' syntax
01:25:28 <LambdaDusk> supki: I can't put the constraint into the .cabal?
01:41:29 <supki> LambdaDusk: not really
01:46:57 <imperative_progr> Is it possible to write multiple statements in Haskell on one line?
01:48:12 <LambdaDusk>  imperative_progr: within "do", you can use ; not entirely unlike in C
01:48:30 <mauke> imperative_progr: sure, whitespace only matters in layout mode
01:48:40 <mauke> and layout is just syntactic sugar
01:49:19 <imperative_progr> mauke: but I can't use "let" in "do"
01:49:26 <mauke> yes, you can
01:50:26 <imperative_progr> Is Haskell indentation-sensitive?
01:51:05 <simukis_> imperative_progr: yes it is.
01:51:47 <mauke> imperative_progr: only in layout mode
01:58:02 <imperative_progr> Is there a script to convert indentation of Haskell code to braces?
02:35:02 * hackagebot heukarya 0.2.0.1 - A genetic programming based on tree structure.  http://hackage.haskell.org/package/heukarya-0.2.0.1 (HeChienTsai)
02:54:14 <turiya> hi
02:54:46 <turiya> i am trying to Data.Set for unordered tuples but Data.Set requires that
02:54:52 <turiya> I order the tuples
02:55:21 <turiya> can a consistent order be given for tuples i.e. (a,b)?
03:02:03 <imperative_progr> Is it possible to write an entire Haskell file on one line?
03:05:03 * hackagebot hdbi-postgresql 1.1.0 - PostgreSQL driver for hdbi  http://hackage.haskell.org/package/hdbi-postgresql-1.1.0 (AlekseyUymanov)
03:10:03 * hackagebot hdbi 1.1.0 - Haskell Database Independent interface  http://hackage.haskell.org/package/hdbi-1.1.0 (AlekseyUymanov)
03:10:05 * hackagebot hastache 0.5.1 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.5.1 (SergeyLymar)
03:10:07 * hackagebot hdbi-tests 1.1.0 - test suite for testing HDBI  http://hackage.haskell.org/package/hdbi-tests-1.1.0 (AlekseyUymanov)
03:12:27 <allsystemsarego> do this ih GHCi:
03:12:33 <allsystemsarego> > import qualified Data.Set as Set
03:12:33 <allsystemsarego> > let s = Set.empty
03:12:33 <allsystemsarego> > Set.insert (1,2) s
03:12:33 <allsystemsarego> fromList [(1,2)]
03:12:34 <lambdabot>   can't find file: L.hs
03:12:34 <lambdabot>   can't find file: L.hs
03:12:34 <lambdabot>   <hint>:1:1: parse error on input `import'
03:12:44 <allsystemsarego> does this not work as you expect?
03:13:08 <allsystemsarego> oh yeah, lambdabot forgot about him :P
03:13:40 <allsystemsarego> should have added some leading blanks
03:13:53 <allsystemsarego> turiya ^^
03:18:19 <turiya> allsystemsarego: fromList [(1,2),(2,1)] = fromList [(1,2)] = fromList[(2,1)]
03:18:31 <turiya> i want to ensure that
03:18:44 <turiya> i want to ensure the above
03:19:26 <turiya> i think Data.Set works correctly if a consistent order is imposed on the tuples
03:19:48 <turiya> but I could not construct a consistent order on tuples :(
03:24:35 <merijn> turiya: Write a newtype wrapper for tuple and define an instance of Ord for it?
03:24:51 <ocharles> where can I find a GHC head sources snapshot?
03:25:00 <ocharles> nixos has a link to http://haskell.org/ghc/dist/current/dist/ghc-7.7-src.tar.bz2
03:25:03 <ocharles> but that 404s now
03:25:03 * hackagebot hdbi-sqlite 1.1.0 - SQlite driver for HDBI  http://hackage.haskell.org/package/hdbi-sqlite-1.1.0 (AlekseyUymanov)
03:25:09 <ocharles> http://haskell.org/ghc/dist/current/dist/ghc-7.7-src.tar.bz2
03:25:18 <turiya> merjin: i tried that but the core problem of defining order for paris (a,b) remains
03:25:38 <merijn> turiya: You can't
03:26:04 * ocharles tries http://darcs.haskell.org/ghcBuilder/uploads/tn23/ghc-7.7.20130811-src.tar.bz2
03:26:12 <merijn> turiya: You can't compare tuples with arbitrary elements in arbitrary order in a sensible way
03:26:13 <gienah> ocharles: http://darcs.haskell.org/ghcBuilder/uploads/tn23/
03:26:29 <merijn> s/arbitrary elements/elements of arbitrary types
03:27:32 <turiya> hmm.. i only want to compare pairs
03:27:54 <pharaun> turiya: and are they of known type that you can compare?
03:28:12 <turiya> basically (Int,Int)
03:28:28 <turiya> say UTuple (Int,Int)
03:29:15 <turiya> basically it seems like prescribing an order on the complex numbers
03:29:29 <turiya> i am not sure if this is possible
03:30:06 <Saizan> turiya: you could use compare (a,b) (c,d) = sort [a,b] `compare` sort [c,d]
03:31:25 <Saizan> or, use the standard order but ensure through smart constructor that your tuples fields are always in-order
03:32:25 <turiya> Saizan: let me try that
03:35:04 * hackagebot parcom-lib 0.2.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.2.0.0 (TobiasDammers)
03:35:17 <turiya> Saizan: thanks, that seems to do the job
03:35:34 <hpaste> klrr pasted “klrr needs to get unbanned to ask questions” at http://lpaste.net/91745
03:35:42 <aristid> turiya: it's possible to prescribe an order on the complex numbers if it doesn't have to make sense under the arithmetic operations. e.g. lexicographic ordering :)
03:36:49 <turiya> aristid: i see.. thanks
03:37:44 <aristid> i believe that is also the default Ord instance for (a,b)
03:39:13 <turiya> Data.Set does not seem to respect my Eq instance but respects the compare in the Ord instance
03:40:06 <paolino> is there a way to define mapAccumM without writing it explicitly ?
03:40:34 <turiya> if a data type is an instance of Eq and Ord (both having a notion of equality) which is preferred?
03:43:14 <merijn> turiya: Your Ord and Eq instances should match
03:43:31 <merijn> turiya: Not doing so is grounds for being lynched by your fellow coders
03:44:39 <aristid> sadly GHC has no lynching feature integrated yet, so it has to rely on the fellow coders
03:44:48 <turiya> :). I was just trying to use the Data.Set
03:45:11 <merijn> @quote unsafeStab
03:45:11 <lambdabot> merijn says: If I could program with arbitrary real world side effects I'd use "unsafeStabComputerUser" if someone attempted that
03:45:13 <aristid> turiya: you can define your Eq instance in terms of your compare if you don't want to write everything twice.
03:45:43 <turiya> i see
03:46:30 <paolino> :i Ord
03:46:41 <paolino> @src Ord
03:46:41 <lambdabot> class  (Eq a) => Ord a  where
03:46:41 <lambdabot>     compare      :: a -> a -> Ordering
03:46:41 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:46:41 <lambdabot>     max, min         :: a -> a -> a
03:46:55 <paolino> haskell is so lazy
03:50:46 <paolino> @hoogle (a -> b -> m (a,b)) -> a -> [b] -> m (a,[b])
03:50:46 <lambdabot> No results found
03:52:57 <arkeet> paolino: what are you looking for?
03:52:57 <qz> heya.. anyone using vim+syntastic for haskell here? is there any way to stop hlint warnings like "warning| Top-level binding with no type signature" ?
03:53:22 <turiya> hpaste is no longer available?
03:53:27 <paolino> mapAccumM
03:53:49 <paolino> :t mapAccumR
03:53:49 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:53:53 <turiya> lpaste it is
03:54:05 <arkeet> turiya: lpaste is the new hpaste
03:54:43 <hpaste> turiya pasted “Unordered Tuples” at http://lpaste.net/91746
03:57:33 <turiya> I just realize that my UTuple type is redundant, I could have just used lists
03:58:02 <arkeet> :t \f l s -> runStateT (mapM (state . f) a) l
03:58:03 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Expr'
03:58:03 <lambdabot>     In the second argument of `mapM', namely `a'
03:58:03 <lambdabot>     In the first argument of `runStateT', namely `(mapM (state . f) a)'
03:58:21 <arkeet> :t \f l s -> runStateT (mapM (state . f) s) l
03:58:21 <lambdabot> Monad m => (a -> s -> (b, s)) -> s -> [a] -> m ([b], s)
03:58:28 <arkeet> er, whatever.
03:58:35 <arkeet> close enough.
03:58:40 <arkeet> no wait.
03:58:41 <paolino> it should be a foldM
03:58:50 <mietek> Any ideas how to use aeson with a JSON field which may or may not be present?
03:58:50 <arkeet> :t \f s l -> runStateT (mapM (StateT . f) s) l
03:58:51 <lambdabot> Monad m => (a -> s -> m (b, s)) -> [a] -> s -> m ([b], s)
03:58:54 <turiya> are lists slower than tuples
03:59:01 <turiya> ?
03:59:05 <arkeet> turiya: lists serve a different purpose from tuples.
03:59:37 <turiya> for representing pairs of numbers , are lists better than tuples?
03:59:45 <CaptainHaddock> @qz, can't you disable what warning hlint gives you, in some config file?
03:59:46 <lambdabot> Unknown command, try @list
03:59:46 <arkeet> no. if you want pairs, use pairs
04:00:18 <turiya> arkeet: why so?
04:00:24 <arkeet> turiya: because lists may not have length 2.
04:00:37 <turiya> i meant why are pairs better than lists of size 2
04:00:46 <CaptainHaddock> because pairs are exactly two items
04:00:49 <CaptainHaddock> no more, no less
04:00:50 <arkeet> because you can't encode "this list has size 2" in the type.
04:01:23 <paolino> arkeet, very nice, thanks
04:02:01 <turiya> i understand somewhat
04:02:06 <paolino> :t StateT
04:02:07 <lambdabot> (s -> m (a, s)) -> StateT s m a
04:02:14 <arkeet> :t \l f -> runStateT . l (StateT . f)
04:02:15 <lambdabot> ((a2 -> StateT s1 m1 a3) -> a -> StateT s m a1) -> (a2 -> s1 -> m1 (a3, s1)) -> a -> s -> m (a1, s)
04:02:22 <arkeet> looks lensy.
04:03:43 <arkeet> paolino: this might go left isntead of right, I'm not sure.
04:03:49 <edwardk> :t wrapped
04:04:24 <edwardk> :t wrapping StateT
04:04:25 <lambdabot> (Functor f, Profunctor p) => p (StateT s m a) (f (StateT s m a)) -> p (s -> m (a, s)) (f (s -> m (a, s)))
04:04:56 <edwardk> bit different
04:05:11 <arkeet> :t \f -> runStateT . traverse (StateT . f)
04:05:11 <lambdabot> (Monad m, Functor m, Traversable t) => (a -> s -> m (b, s)) -> t a -> s -> m (t b, s)
04:06:14 <CaptainHaddock> does anyone ever use ghci as an inferior emacs process?
04:07:23 <hvr> CaptainHaddock: yes
04:07:38 <mietek> cabal: ... Parse of field 'build-depends' failed.
04:07:45 <mietek> Thanks, cabal, that's very helpful
04:08:09 <CaptainHaddock> is there an easy way to make ghci autocomplete when you hit TAB, rather than it just sticking a tab in the buffer?
04:08:38 <CaptainHaddock> it's really an emacs question, but #emacs is a bit quiet
04:08:39 <hvr> CaptainHaddock: if you use the haskell-interactive mode repl, yes
04:08:56 <hvr> CaptainHaddock: for inf-haskell I haven't implemented it yet
04:09:19 <hvr> CaptainHaddock: http://www.youtube.com/watch?v=06q-sCoqwEY
04:10:52 <darinm_away> are there any resources with document the effect of different compiler options on generated code size? (versus performance would be interesting too)
04:12:20 <arkeet> :t \f -> runReaderT . traverse (ReaderT . f)
04:12:21 <lambdabot> (Applicative m, Traversable t) => (a -> r -> m b) -> t a -> r -> m (t b)
04:12:46 <arkeet> not that interesting, I suppose.
04:12:53 <arkeet> :t \f -> runWriterT . traverse (WriterT . f)
04:12:54 <lambdabot> (Applicative m, Traversable t, Monoid w) => (a -> m (b, w)) -> t a -> m (t b, w)
04:13:07 <arkeet> more interesting, perhaps
04:13:27 <arkeet> :t EitherT
04:13:27 <lambdabot> Not in scope: data constructor `EitherT'
04:14:42 <merijn> darinm_away: There was a nice post on using evolutionary algorithms to optimise performance of compiled code
04:15:07 <darinm_away> merijn: yeah. I saw that. Something similar wrt to code size would have been cool
04:15:23 <merijn> darinm_away: If your size concerns are due to the big size of GHC binaries, the answer is: GHC links statically by default, you can change this but you have to wonder if you really want to
04:15:24 <darinm_away> or even "here's the statistics of flags compiling most of hackage"
04:15:56 <darinm_away> merijn: right, I understand --enabled-shared and -dynamic
04:16:04 <darinm_away> code size isn't a huge concern per se
04:16:12 <darinm_away> oh and -split-objs
04:16:21 <merijn> darinm_away: See also dons' in depth investigation/explanation at: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
04:16:35 <darinm_away> merijn: yeah, read that one too :]
04:16:39 <darinm_away> but thanks
04:16:53 <darinm_away> it is helpful
04:16:54 <merijn> I'm not really aware of anything beyond that
04:17:10 <merijn> Maybe try asking on the ghc-users or haskell-cafe mailing lists?
04:17:14 <darinm_away> so for the setting I'm looking at, shared/dynamic is probably not going to be possible
04:17:21 <darinm_away> so I was looking for other ways
04:17:32 <merijn> darinm_away: Well, strip will certainly help
04:17:41 <darinm_away> true
04:18:00 <merijn> darinm_away: Do you have any specific size constraints you're worried about?
04:18:00 <darinm_away> may give the mailing list a try
04:18:13 <ocharles> argh, compiling ghc head keeps hitting oom-killer :(
04:18:17 <darinm_away> merijn: not particularly just that it probably has to be static
04:18:26 <darinm_away> so ofc that's big binaries
04:18:32 <darinm_away> would be nice to get them a bit smaller
04:18:32 <merijn> darinm_away: Yeah, for these sorts of open-ended specific question the mailing lists tend to be better
04:18:39 <darinm_away> but it's not hte end of the world if it can't be done well
04:20:05 * hackagebot heukarya 0.2.0.2 - A genetic programming based on tree structure.  http://hackage.haskell.org/package/heukarya-0.2.0.2 (HeChienTsai)
04:22:13 <darinm_away> merijn: thanks for the help anyway
04:23:01 <merijn> ocharles: A pox upon the oom-killer
04:23:12 <merijn> Linux lunacy >.<
04:23:40 <merijn> My main encounters with the oom-killer had it consistently killing sshd on a remote machine I was ssh-ing into >.>
04:24:14 <ocharles> haha
04:24:25 <ocharles> I have 1gb ram though, surely that's enough to compile GHC HEAD?
04:24:41 <merijn> Thank got for remote console access
04:26:24 <CaptainK> i need to get GHC compiled for my new machine:  http://en.wikipedia.org/wiki/ZX81
04:27:20 <ocharles> the things I'll do for -XTypeHoles
04:28:36 <Taneb> Silly ocharles, -XTypeHoles is for Simons!
04:29:16 <ocharles> amusingly, I'm working with free monads, which is exactly the motivating example
04:30:05 * hackagebot algebraic-classes 0.3.1 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.3.1 (SjoerdVisscher)
04:30:11 <merijn> ocharles: You forgot about closed type families!
04:30:45 <ocharles> pfft
04:31:01 <merijn> I can approximate holes with ImplicitParams, but closed type families == <3
04:31:23 <ocharles> (that's my "I'm actually totally stoked for closed type families" pfft)
04:33:10 <merijn> They're the main thing making me consider 7.8 as a min ghc version for my current code, rather than 7.6 :p
04:33:27 <ocharles> what oleg magic are you working on?
04:33:48 <merijn> ocharles: I really want to abuse my Restrict type family for some stuff, it's so neat!
04:34:10 <merijn> ocharles: Although I'll probably copy edwardk's advice and use an unexported typeclass constraint instead
04:34:26 <merijn> Not entirely sure whether that'll actually even work, though
04:34:48 <edwardk> i wonder if i recommended not following my advice if that would lead to a paradox
04:35:15 <merijn> edwardk: No, because my I follow a paraconsistent logic :)
04:35:36 <edwardk> you'd have to ask the me that always gives good advice what the me that always give bad advice would recommend and do the opposite
04:36:09 <hvr> edwardk: can't we define a macro for that?
04:38:04 <jophish> Yo yo yo
04:39:29 <jophish> OK, Imagine I'm writing a function to read and cache files, so getContents filename is pure, because once the file is loaded the cached version is always returned. Is it possible to expose this without the IO monad, without using unsafePerformIO?
04:41:09 <merijn> jophish: No
04:41:32 <jophish> yeah, I didn't think so
04:41:54 <jophish> Is this the kind of situation that unsafePerformIO was made for?
04:42:00 <merijn> jophish: You could use unsafePerformIO if you can indeed promise that that results in correct functionality
04:42:13 <merijn> jophish: Yes, you just have to be very careful
04:42:18 <merijn> @quote not.a.bug
04:42:18 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
04:42:21 <merijn> uh
04:42:30 <merijn> @quote my.program.acts.weird
04:42:30 <lambdabot> No quotes match.
04:42:36 <merijn> I suck at @quote
04:42:43 <Taneb> @quote weird
04:42:43 <lambdabot> Cin says: weird behaviour is weird
04:42:44 <FreeFull> @quote
04:42:44 <lambdabot> cjs says: I was trying to write a text-crunching program in Ruby, found it difficult to get it perfectly correct, and ended up writing it in Haskell instead.
04:42:56 <FreeFull> @quote FreeFull
04:42:57 <lambdabot> No quotes match.
04:43:11 <jophish> merijn: for a little context, this is for writing a C preprocessor, I'd like to pass a function into the Lexer which allows the lexer to get the string for a file after seeing an #include directive
04:43:12 <merijn> @quote I.don't.understand.why
04:43:12 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:43:36 <merijn> That's the one I wanted to warn you with :p
04:43:57 <jophish> Yup, I understand :)
04:45:44 <FreeFull> @quote unsafePerformIO
04:45:44 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
04:45:49 <FreeFull> @quote unsafePerformIO
04:45:49 <lambdabot> fasta says: unsafePerformIO is so nice. Everything that otherwise would require design can now just work :)
04:47:18 <dcoutts_> jophish: if you want to read files during lexing, then you need a monadic lexer, and that monad will have to be layered on top of IO
04:47:19 <merijn> jophish: You have to make sure that anything using unsafePerformIO is either not inlined (using the NOINLINE pragma) or, if it is inlined and evaluated multiple times, it always returns the same result
04:47:37 <dcoutts_> jophish: but doing so isn't hard
04:47:51 <merijn> jophish: Although, a transformer stack based on IO would probably be nicer
04:48:02 <dcoutts_> e.g. the lexer generator 'alex' has decent support for monadic lexers
04:48:25 <dcoutts_> and can use those lexers with either happy or parsec or whatever
04:48:38 <dcoutts_> lexer being monadic implies the parser is too
04:49:06 <jophish> It does seem as though a monadic lexer/parser would be best solution in the long run
04:50:05 * hackagebot free-functors 0.4.1 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.4.1 (SjoerdVisscher)
04:53:25 <yopikh> http://www.willamette.edu/~fruehr/haskell/evolution.html
04:54:08 <jophish> Although the parser wouldn't have to be monadic. All it does it take a list of tokens and transform that into an AST
04:59:19 <merijn> yopikh: Pfft, the "Static Haskell Programmer" needs more GADTs, DataKinds and TypeFamilies :p
05:00:28 <FreeFull> Don't parsers in Haskell tend to be mostly used with Applicative and Alternative rather than Monad?
05:01:26 <dcoutts_> FreeFull: it being monadic doesn't preclude using an applicative/alternative style
05:01:28 <paolino> is there a library for dynamic programming ?
05:02:02 <edwardk> FreeFull: you can make a parser do smarter things when the applicative fragment is in use, but most combinator libraries in haskell are able to support the monadic stuff too.
05:02:32 <dcoutts_> jophish: the point is that instead of taking a list of tokens, it takes a monadic 'getTok' that runs in the underlying lexer monad
05:02:45 <edwardk> paolino: 'sort of' the notion of histo and dynamorphisms came about from modeling dynamic programming in a functional setting
05:03:19 <jophish> dcoutts_: Wouldn't a lazy list be exactly that?
05:03:54 <FreeFull> dcoutts_: I know
05:04:14 <FreeFull> But I can imagine a parser doesn't necessarily have to be a valid monad
05:04:37 <FreeFull> And I know a Monad isn't necessarily an Alternative
05:04:53 <FreeFull> So there are things you can do with Alternative you can't do using just monad operations
05:08:00 <hpaste> merijn pasted “*Real* Static Haskell programmer factorial :p” at http://lpaste.net/91749
05:08:18 <merijn> May or may not require 7.7 :p
05:08:46 <merijn> FreeFull: The monadic equivalent of Alternative is MonadPlus
05:08:59 <merijn> For some value of equivalent
05:10:23 <FreeFull> merijn: I know
05:10:29 <FreeFull> And not all monads are monadplus
05:10:59 <FreeFull> I don't think IO is, although some argue IO isn't a monad
05:12:51 <edwardk> FreeFull: rather it is that if you only have to support the applicative operations then more things are capable of instantiating the interface
05:13:47 <FreeFull> Isn't Parsec where Alternative came from in the first place
05:14:08 <edwardk> no, applicative/alternative were defined originally for uu-parsinglib iirc
05:14:26 <edwardk> and then the idiom paper hit around that time
05:14:57 <FreeFull> Funny how there was something useful between Monad and Functor and people didn't realise until then
05:15:37 <dcoutts_> applicative was based on the observation that several libs were using some combinator that was superficially like monad bind but strictly less expressive
05:15:51 <dcoutts_> the uu parsing one had been around for several years
05:16:13 <edwardk> well, the way i tend to summarize it, applicative almost perfectly captures the notion of context free grammars, while monads capture context sensitivity. the former gives you no ability to choose what to do next based on your results so far, your path is fixed. the latter lets you make it up as you go along
05:16:20 <edwardk> arrow sits in the middle awkward and unloved
05:16:40 <dcoutts_> edwardk: yes, in retrospect it all makes perfect sense
05:16:54 <edwardk> sure. hindsight 20/20 and all that
05:17:04 <dcoutts_> both in the context of parsers/grammars, but then also in other areas
05:17:04 <isomorphismes> Is there a meaning for "virtual functions" in Haskell? Or is that only OO and since Haskell is a different approach that's meaningless?
05:17:34 * dcoutts_ had one of his undergrad papers cited in the applicative paper
05:17:42 <edwardk> FreeFull: there are several other points in the middle we can talk about as well, applicatives without pure (many comonads meet that, with an extra condition), monads without return (IntMap, Map k), etc.
05:17:42 * dcoutts_ was very excited about that at the time!
05:17:43 <FreeFull> What are virtual functions in OO?
05:17:43 * osfameron never understood what virtual functions were in OO...
05:18:21 <edwardk> isomorphismes: for us they are just members of typeclasses.
05:18:43 <isomorphismes> FreeFull: http://www.learncpp.com/cpp-tutorial/122-virtual-functions/
05:18:45 <FreeFull> I heard typeclasses are a bit like interfaces in OO
05:19:22 <edwardk> there its an operational concern about how things get implemented as function pointers in a vtable if they are virtual. a dictionary for a typeclass is like a vtable, but it gets made up as needed and passed in based on constraint solving, rather than slavishly glued to the object
05:19:52 <yesthisisuser> could someone explain how to use the -ddump-splices ghc flag to expand templated code
05:20:29 <yesthisisuser> i am trying ghc -ddump-splices hello.hs 2> somefile but it is not producing any output
05:20:33 <isomorphismes> edwardk: thanks
05:21:30 <merijn> I guess there's no way to combine this into a single import? "import Data.Map (Map)"
05:21:33 <merijn> import qualified Data.Map as M
05:22:05 <edwardk> merijn: nope. two lines unless you are willing to pay for import Data.Map as M   -- and then just qualify all the conflicting references
05:22:19 <merijn> I was afraid of that :\
05:23:51 <merijn> FreeFull: The differences between typeclasses and interfaces include (but aren't limited too, I might forget some things): 1) typeclasses can be defined over more than one argument type (i.e. MPTC) 2) typeclasses can define polymorphic values in addition to functions 3) typeclasses can be polymorphic in return value as well as arguments
05:24:35 <FreeFull> merijn: I never looked at interfaces
05:25:42 <edwardk> and you can make up new 'instances' for existing types ex-post-facto
05:26:04 <edwardk> also typeclasses carry code, interfaces just carry method names.
05:26:27 <FreeFull> Yeah, typeclasses can have default implementations
05:26:37 <edwardk> typeclasses are really a class-like notion, not an interface notion
05:29:06 <FreeFull> All I know is that I prefer functional to object-oriented
05:31:43 <kqr1> what is the recommended way to express numbers in binary in haskell code? i was thinking of a function that transforms [Int] or [Char] to a number, but i'm not sure this is the idiomatic way
05:32:01 <hpc> > 0b1101101
05:32:02 <lambdabot>   Not in scope: `b1101101'
05:32:16 <hpc> ^ i am so annoyed that syntax doesn't exist
05:32:37 <kqr1> yeah, it's real convenient when you're used to it
05:32:38 <hpc> kqr1: could you go from binary to hex and then 0xliteral?
05:33:01 <hpc> (or octal)
05:33:19 <paolino> edwardk, is it possible to have a lens where the structure is lazily evaluated on queries ? Where should I store the structure ?
05:33:33 <kqr1> hey i didn't know the 0x36 syntax existed. i guess that's the best i can do, then. i don't need it immediately, i was just curious
05:33:50 <hpc> 0x and 0o syntax exist
05:38:36 <hpc> kqr1: oh hey, if you don't mind TH this exists: http://hackage.haskell.org/packages/archive/binary-literal-qq/1.0/doc/html/Language-Literals-Binary.html
05:39:14 <kqr1> hpc, haha i just thought about that as an option. neat!
05:44:15 <Ghoul_> umm what on earth
05:44:24 <Ghoul_> I keep installing Haskell Platform for windows and it never installs cabal.exe
05:44:30 <Ghoul_> aren't I supposed to get one?
05:46:20 <Ghoul_> nevermind, its in libs/extralibs/bin
06:20:12 * hackagebot courier 0.1.0.3 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.3 (PhilHargett)
06:25:47 <notdan> Can somebody please explain what is the relation between Mu here: <https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L317> and fixed points?
06:26:36 <mietek> Is there a better way to deal with record name clashes than prefixes?
06:27:49 <haasn> qualified imports, Has*-style lenses
06:28:11 <mietek> haasn: for defining multiple records with name clashes in same module?
06:28:28 <haasn> then there's no way to avoid renaming
06:28:32 <mietek> Cheers
06:28:34 <haasn> at least for now
06:28:39 <haasn> it might be possible in the future :)
06:28:49 <donri> there's a gsoc this year
06:28:51 <mietek> Yeah, I thought I read something about that...
06:29:00 <mietek> Aha
06:29:39 <donri> https://www.google-melange.com/gsoc/project/google/gsoc2013/adamgundry/23001
06:29:48 <mietek> Hope it works out
06:36:59 <quchen> Wait, there's no broadcastChan in Base?!
06:39:27 <isomorphismes> LYAH says """where bindings aren't shared across function bodies of different patterns. If you want several patterns of one function to access some shared name, you have to define it globally.""" Is it also possible with inheritance to have something like namespaces?
06:40:12 <donri> isomorphismes: what do you mean inheritance?
06:40:27 <isomorphismes> donri: both i guess
06:40:32 <donri> what?
06:41:45 <isomorphismes> donri: I mean in other languages it might be possible to have classes inherit from each other (therefore the variables are passed forward) or to have two things share a namespace and therefore have non-global variables which can still be heard by anything that knows that namespace
06:43:08 <startling> isomorphismes: no, there's nothing like that
06:43:11 <donri> isomorphismes: haskell doesn't really have inheritance or mutable variables. closures are heavily utilized though
06:43:22 <mietek> parseJSON (Object o@(H.lookup "foo" -> Just _)) = WithFoo <$> o .: "foo"
06:43:23 <mietek> parseJSON (Object o@(H.lookup "bar" -> Just _)) = WithBar <$> o .: "foo"
06:43:26 <mietek> Any better way?
06:43:32 <mietek> This feels a bit awkward
06:43:47 <isomorphismes> donri: so closures can do the same thing then, yes? just thinking of environments in R
06:44:12 <donri> isomorphismes: i don't know R, sorry. and not sure what you want :)
06:45:02 <donri> isomorphismes: re the LYAH suggestion, you could simply move the pattern matching into the function with a case expression, then you can have a shared where clause
06:45:10 <startling> isomorphismes: one silly workaround is (a, b) = (f, g) where f = ...; g = ...'
06:45:43 <isomorphismes> donri: Maybe it is not the same "closure" http://www.lemnica.com/esotericR/Introducing-Closures/
06:46:15 <isomorphismes> startling: then both (a,b) would be able to access what's in (f,g) ?
06:47:02 <startling> isomorphismes, both f and g (in the where clause) can access other things in the where clause
06:48:29 <allsystemsarego> what is a good rule of thumb for when to use IORef vs. when to use STRef?
06:48:42 <k00mi> mietek: WithFoo /= WithBar?
06:49:23 <hpaste> startling pasted “silly thing” at http://lpaste.net/91751
06:49:34 <startling> isomorphismes: ^ check out that link
06:50:03 <k00mi> mietek: I suppose the "foo" at the end of the second line should be "bar"
06:50:35 <startling> isomorphismes: really the most popular thing to do is have the common thing be a top-level binding, though
06:50:48 <mietek> k00mi: it should be
06:51:31 <isomorphismes> To clarify, I'm thinking of three things. 1 in Perl I define mammal class and Walrus inherits from mammal. So $milk is defined in mammal and Walrus can get that property. 2 in C++ I define my own namespace (w/ a .h) for random number generation. Then using namespace myran I could call myran::genSeq or any functions I defined there. 3 in R it's similar to both, using either a package or an environment. base::as.Date means s
06:51:41 <mietek> Basically, how to conditionally use different constructors, depending on which fields are present in the JSON
06:52:09 <startling> isomorphismes: no, haskell has nothing like classes or inheritance at all
06:52:32 <k00mi> mietek: you could use the Monad instance for Parser
06:52:40 <startling> isomorphismes: (you got cut off after "base::as.Date means s" because irc sucks, btw)
06:53:08 <mietek> k00mi: do you have an example?
06:53:59 <isomorphismes> startling: oh. well, nevermind, it's not important. how do you do an API in haskell?  w closures?
06:54:01 <merijn> oh, oh, do I get a price if I have to chase a bug caused by sucky defaulting? >.<
06:54:25 <c_wraith> isomorphismes: usually with functions.
06:54:26 <merijn> isomorphismes: Eh, just use modules and exports?
06:54:56 <merijn> I'm not really sure I understand the question/problem?
06:55:22 <startling> isomorphismes, modules can export only specific things
06:55:32 <k00mi> mietek: do foo <- o .:? "foo"; maybe (WithBar <$> o .: "bar") (return . WithFoo) foo
06:55:41 <k00mi> assuming "foo" or "bar" must be present
06:57:47 <mietek> k00mi: uh
06:57:58 <mietek> k00mi: is the whole maybe line in the do block?
06:58:26 <k00mi> yep
06:58:34 <isomorphismes> merijn: say you have three functions f,g,h and want to share parameters a,b,c among them but not globally.
06:59:01 <isomorphismes> merijn: and/or let "user" (next programmer) access certain parts of a function but not all of it
06:59:09 <mietek> k00mi: a little confused how this works — does .:? return a Maybe value?
06:59:35 <k00mi> mietek: it returns a Parser (Maybe a)
06:59:46 <k00mi> so the foo is a Maybe
06:59:57 <merijn> isomorphismes: Do you have a concrete example?
07:00:22 <startling> isomorphismes, the user imported them from Some.Module. Some.Module only exports f, g, and h. the user can not use a, b, and c. the end.
07:01:18 <mietek> k00mi: right. And what if both cases should also have another field?
07:02:50 <k00mi> mietek: you mean a three possible fields where only one has to be present?
07:02:51 <startling> isomorphismes, I think you're overthinking this.
07:03:27 <mietek> k00mi: no, two cases: foo + quux | bar + quux
07:04:15 <k00mi> uh, I don't understand
07:05:12 <mietek> k00mi: two valid JSON blobs: {"foo":1, "quux":1}, {"bar":2, "quux":2}
07:05:14 <paolino> isomorphismes, you can use closures to mimic object state
07:05:37 <donri> allsystemsarego: whether you're in IO or not? :)
07:05:46 <startling> paolino: what? no you can't.
07:05:47 <mietek> k00mi: targets are:  WithFoo Int Int, WithBar Int Int
07:05:53 <k00mi> ah
07:06:03 <startling> well, immutable state, but that's hardly state.
07:08:02 <k00mi> mietek: bind the result from the "maybe ..." in the last do I showed you, then in the next line do res <$> o .: "quux"
07:09:37 <mietek> k00mi: thanks, this works
07:09:50 <mietek> I should make a slightly cleaner syntax
07:09:55 <k00mi> great, you're welcome =)
07:10:12 <paolino> startiling, have a record of functions, some of them computing a new record of the same type and you have a stateful object
07:10:56 <mietek> Actually
07:11:08 <mietek> Isn't there anything in Applicative which would sort of work like monadic maybe?
07:12:11 <k00mi> uh, you mean an Applicative instance for Maybe?
07:12:19 <startling> mietek,
07:12:25 <startling> perhaps <|>
07:15:13 <k00mi> yup: do foo <- o .:? "foo"; bar <- o .:? "bar"; let constructor = fromJust $ fmap WithFoo foo <|> fmap WithBar bar; constructor <$> o .: "quux"
07:15:58 <mietek> Sweet
07:16:20 <mietek> And, I think...
07:16:37 <startling> that fromJust looks strange
07:16:53 <startling> what does "foo" do?
07:17:22 <k00mi> startling: either "foo" or "bar" has to be present, so the result of foo <|> bar must be a Just
07:17:39 <startling> k00mi, sure. I'm just saying it looks like you have things organized strange.
07:17:49 <startling> "foo" is type ParserThing (Maybe a)?
07:18:02 <startling> it's probably better to let the ParserThing fail.
07:18:08 <mietek> k00mi: although using fromJust makes it more difficult to get a nice parser failure message, right?
07:18:09 <k00mi> right
07:18:27 <startling> in any case, if "foo" returns Nothing, fromJust will error
07:18:28 <k00mi> the fromJust would make the program crash...
07:18:28 <mietek> startling: how would you organise this?
07:18:56 <startling> mietek, make "foo" and "bar" ParserThing a rather than ParserThing (Maybe a)
07:19:30 <mietek> startling: the use case is parsing two flavours of JSON
07:19:40 <mietek> startling: one has a "foo" field, other has a "bar" field
07:19:40 <startling> mietek: that doesn't change anything.
07:19:49 <startling> this is aeson?
07:19:53 <mietek> Yeah, aeson
07:19:59 <k00mi> startling is right
07:20:12 <mietek> I'm sure, I just don't see it :)
07:20:17 <mietek> Just starting out with aeson
07:20:29 <mietek> And applicative in general...
07:20:50 <mietek> I wrote an ugly solution using view patterns
07:21:03 <startling> since ParserThing is an Alternative (which is the typeclass that defines <|>), it already encapsulates the possibility of failure.
07:21:20 <startling> you guys are using .:? somewhere?
07:21:28 <k00mi> yes
07:21:31 <epta> Is there a way to rewrite `f <$> a <*> b` shorter?
07:21:48 <startling> k00mi, mietek: you should use .:, which will just have that part of the parser fail
07:21:49 <mietek> startling: I couldn't find an example using Alternative
07:22:21 <k00mi> startling: at least one .:? is needed because "foo" can fail, but then "bar" should be present
07:22:30 <startling> k00mi, no
07:22:45 <startling> k00mi, .:? will always succeed
07:22:56 <startling> it just might sometimes succeed with a Nothing
07:23:27 <startling> <|> doesn't know anything about Maybe
07:23:41 <mietek> Oh dear
07:23:48 <mietek> It's just intuitively simple
07:23:57 <startling> paste your code and I can give more concrete advice.
07:24:05 <k00mi> right, and I don't want the entire Parser to fail if "foo" isn't present, I want to react to it and lookup "bar" and if that isn't present, then the Parser can fail
07:24:08 <mietek>   parseJSON (Object o) =
07:24:08 <mietek>     WithFoo <$> o .: "foo" <*> o .: "quux" <|>
07:24:09 <mietek>     WithBar <$> o .: "bar" <*> o .: "quux"
07:24:18 <startling> k00mi: the "entire parser" will not fail
07:24:22 <startling> only that part will
07:24:48 <startling> "a <|> b" says "if the parser 'a' fails, go back and try 'b' instead"
07:24:55 <startling> mietek, that looks right
07:24:58 <k00mi> oh
07:24:59 <mietek> <3
07:25:01 <k00mi> now I get it
07:25:03 <mietek> Thanks guys
07:25:05 <mietek> This is amazing
07:25:45 <startling> mietek: it is nice when Applicative/Alternative style gives you something so trivially easy-looking
07:25:57 <mietek> Yes!
07:26:12 <mietek> It mirrors the datatype definition so closely, it should be derivable
07:27:17 <mietek> Unfortunately, it isn't
07:27:48 <mr-> @src (.:)
07:27:49 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:28:48 <mietek> mr-: http://hackage.haskell.org/packages/archive/aeson/latest/doc/html/Data-Aeson.html
07:29:02 <mietek> https://www.fpcomplete.com/school/text-manipulation/json was helpful
07:29:34 <mr-> Ah, I thought it is one of those funky (function) combinators people have been using lately ;-)
07:31:19 <merijn> Want to buy: Type system that stops me from having to spend an hour tracking down a bug due to an inverted boolean condition :(
07:31:46 <mr-> Stop using bools? ;-)
07:33:22 <c_wraith> if you write your types sufficiently well, liquid haskell might help with that.
07:34:15 <startling> merijn: from conor mcbridge's homepage: "And yes, we know about the bug in the ML version of elem to be found in this draft: simple type systems have the property that you can replace any subexpression of a well-typed term by another of the same type!"
07:35:51 <startling> mietek: I think you might be able to derive it using the Generic whatsit
07:36:16 <startling> yeah. http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Generic.html
07:37:39 <Peaker> Trying to run "shake" built in parallel mode yields "openFile: resource busy (file is locked)" :-(
07:38:00 <Peaker> (this is a read file failure after "need"ing it caused another thread to write it (and according to prints, already finish))
07:38:22 <mietek> startling: I did try that
07:38:37 <mietek> startling: the resulting parser doesn't like my test JSON
07:39:10 <startling> mietek: weird.
07:41:38 <mietek> startling: Left "when expecting a sum (:+:), encountered Object instead"
07:42:13 <mietek> startling: the handwritten parser with <|> works fine
07:42:24 <startling> no idea. I don't know anything about Generic, alas.
07:42:34 <mietek> It's probably not Generic's fault
07:42:48 <mietek> But the generic fromJSON doesn't handle multi-constructor datatypes
07:44:11 <mietek> When using aeson's applicative interface, is there a way to just check that a field has a certain value?
07:45:16 <startling> that's not possible with applicative.
07:45:21 <mietek> parseJSON (Object o@(H.lookup "fooOrBar" -> Just "foo")) = WithFoo <$> o .: "quux"
07:45:24 <mietek> parseJSON (Object o@(H.lookup "fooOrBar" -> Just "bar")) = WithBar <$> o .: "quux"
07:45:33 <mietek> Here's what I came up with
07:45:43 <mietek> (Note these are different WithFoo/WithBar now)
07:45:43 <startling> you can do "thisParser >>= guard (== x)"
07:46:12 <mietek> erm
07:46:32 <mietek> How would that fit with actually extracting quux as well?
07:47:06 <startling> "thisParser >>= \quux -> guard (x == quux)" iirc?
07:47:21 <startling> oh, btw, that code two messages above this is wrong.
07:47:23 <mietek> No, that's not what I mean
07:47:48 <startling> mietek, what do you mean?
07:48:03 <mietek> Look, I pasted 2 lines just above
07:48:42 <S_J> which languages/platforms does haskellö competee with? .NET and Java?
07:48:44 <mietek> I look at the contents of the "fooOrBar" field, check if they're "foo" or "bar", and then return a value with the contents of the "quux" field
07:49:13 <mietek> So it's almost the same as the previous problem
07:49:35 <mietek> But I don't want to return the value of the "fooOrBar" field, as it's implicit in the constructor
07:49:38 <startling> mietek, what's wrong with parseJSON o@(Object x) = case H.lookup "fooOrdBar" o of Just "foo" -> firstThing; Just "bar" -> secondThing; ?
07:50:13 <startling> sorry, H.lookup "fooOrBar" x
07:50:14 <mietek> That's just getting rid of the view pattern
07:50:25 <startling> mietek, that's not what you're asking about?
07:50:30 <mietek> And now wee need to handle the case of no "fooOrBar" field explicitly in there
07:50:39 <mietek> No, I'm asking about the applicative way
07:50:52 <startling> the "applicative way" to do what?
07:51:11 <mietek> Well, this
07:51:57 <k00mi> to do different things depending on the parsed value, if I understand correctly
07:52:03 <k00mi> which is not possible
07:52:25 <mietek> Oh come on
07:52:28 <mietek> Of course it is possible
07:52:44 <startling> mietek: this is literally the thing that Monad does that Applicative does not
07:52:45 <FreeFull> S_J: Haskell is just a general-purpose language
07:52:52 <mietek> We just need a Parser which looks at the parsed value, compares it to an argument, and fails if it's not equal
07:53:05 <mietek> s/it's/they're/
07:53:29 <mietek> Instead of returning the value
07:54:32 <startling> mietek, you're being vague to the point where it's impossible to help you.
07:54:50 <mietek> startling: well, I appreciate your attempts
07:54:58 <mietek> I don't really think I am, though
07:55:46 <mietek> The two lines with view patterns show exactly what I want to do
07:56:08 <mietek> We were just able to translate a similar example to applicative a few minutes earlier
07:56:12 <k00mi> oh, it is possible
07:57:22 <k00mi> (\x -> if x == "foo" then WithFoo else WithBar) <$> o .: "fooOrBar" <*> o .: "quux"
07:57:33 <k00mi> if I understand correctly
07:59:19 <k00mi> mietek: what made the earlier example possible was Alternative, not Applicative
08:00:02 <Peaker> does anyone know how openFile interacts with file locking on Linux?
08:00:09 <mietek> k00mi: yeah
08:00:31 <Peaker> I seem to have a clear case of: "writeFile path foo >> ... >> readFile path" yielding an error about path being locked
08:01:12 <isomorphismes> startling: gotcha. merijn: I could make one but I don't think it's interesting for everyone else to continue the discussion and my Q is answered. paolino: thanks
08:01:24 <isomorphismes> c_wraith: thanks
08:04:02 <merijn> I can't boolean...
08:04:20 <merijn> So far this afternoon 3 bugs due to reversed conditions >.>
08:04:42 <startling> :D
08:05:31 <dmwit> merijn: switch2agda
08:05:43 <merijn> The good news is, it seems to work now! In far as I can determine without testing, which I can't >.>
08:06:29 <lingxiao> hey has anyone played with Control.Monad.Product?
08:06:36 <merijn> On account of my alternative ZMQ implementation being more up to date with the ZMQ RFCs than the actual ZMQ implementation >.>
08:07:53 <startling> whoops.
08:07:55 <S_J> how do I configure Cabal to run my exe?
08:08:32 <merijn> S_J: Cabal just builds executables, you run them by...well...running them
08:08:41 <applicative> S_J: make it test/Test.hs ?
08:08:57 <luite> S_J: if you add it as a test case, you can run cabal test
08:09:17 <S_J> yes but now it says" runt he configure command first"
08:09:24 <S_J> after I cleaned it
08:09:25 <applicative> or, write a test/Test.hs that shamelessly uses System.Process or whateer ...
08:09:46 <applicative> S_J: oh cabal configure --enable-tests if thats the hack youre considering
08:10:00 <S_J> i want to disable tests
08:10:11 <applicative> oh because you have actual tests too?
08:10:24 <S_J> yes i have a program and a testprogram
08:10:39 <luite> wait what should cabal run and why?
08:10:44 <startling> S_J, what's the executable you want to run?
08:10:56 <applicative> S_J: oh.  Well.... cabal configure --enable-benchmarks !!
08:11:21 <dmwit> luite++
08:11:28 <dmwit> too much advice flying around, not enough problem description
08:11:47 <S_J> I want to run my Main executable
08:11:51 <applicative> S_J: but I dont see why not just do > dist/build/...
08:11:54 <startling> S_J, why?
08:11:54 <S_J> not tests, not benchmarks
08:12:01 <S_J> not build my Main I mean
08:12:02 <startling> S_J, that's not something cabal should do
08:12:04 <luite> S_J: is that necessary for installing the program?
08:12:09 <S_J> no, build my Main I mean
08:12:16 <applicative> S_J: the reason this is doubtful is you often produce many executables
08:12:51 <applicative> startling: there's no reason there couldnt be cabal run myExecutable
08:12:53 <dmwit> If all you want to know is, "how do I ask cabal to build my executable?", then the answer is "cabal configure && cabal build".
08:13:10 <dmwit> This will put your executable in dist/build/executableName/executableName.
08:13:11 <applicative> cabal run is short of dist/build/
08:13:12 <merijn> dmwit: Or just "cabal build" if you have a new cabal :p
08:13:26 <dmwit> You will also need to have an executable block in your *.cabal file, of course.
08:13:53 <S_J> dmwit: ty
08:14:18 <applicative> ah, at last, i see the impediment.
08:15:20 <applicative> S_J: maybe if you look at the source for something like gloss-examples where theres a ton of executables?
08:15:42 <applicative> each is discussed separately in the .cabal file
08:16:21 <dmwit> I still don't believe we know what the impediment was.
08:16:48 <S_J> i got it already, ty
08:16:53 <applicative> I think we know that your previous three remarks solved it
08:18:13 <mietek> applicative: ohai
08:18:24 <applicative> hi!
08:18:27 <mietek> applicative: surely if anyone knows this, it's you
08:18:38 <applicative> hah
08:18:59 <mietek> applicative: have you used aeson?
08:19:07 <applicative> only a bit
08:19:13 <mietek> attoparsec?
08:19:16 <applicative> yes
08:19:21 <epta> @hoogle Either a b -> Maybe b
08:19:21 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
08:19:21 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
08:19:21 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
08:19:21 <applicative> whats wrong??!!
08:19:34 <dmwit> applicative: Nothing, he just wants to know if you used those libraries!
08:19:42 <dmwit> (And that's why you of all people would know!)
08:19:51 <applicative> dmwit: sorry, I'm always waiting for a type error
08:20:02 <mietek> I'm just building up to a quick climax
08:20:07 <merijn> epta: That function doesn't exist, there was a recent discussion on libraries@ to add it
08:20:22 <applicative> epta: have you seen the errors package on hackage? it has a number of cool either-maybe etc functions
08:20:35 <mietek> applicative: I need a parser which looks at the thing it's parsed, compares it to something, and fails if the comparison fails
08:21:15 <startling> mietek, >>= \v -> if whatever v then empty else pure v
08:21:31 <applicative> fmap (== 12) myParser
08:21:41 <S_J> I get a weird error when I compile. How can a type from another module accessed like RP.HttpOK compile but not a function RP.makeResponse? the function is spelled correctly. The error is "Not in scope"
08:21:44 <applicative> returns a bool
08:21:58 <epta> applicative: Control.Error.Util.hush:: Either a b -> Maybe b ?
08:22:03 <applicative> ah, startling's fits the description
08:22:09 <startling> mietek: the other way you can spell this is >>= guard . whatever
08:22:30 <Peaker> I have something like:   writeFile out (unlines bar) >> readFile out    and the readFile is throwing an exception that the file is locked. There is no other interaction with this file ("out")
08:22:33 <startling> epta, preview _Right from lens
08:22:49 <Peaker> this is only happening with threads enabled, and non-deterministically :(
08:22:50 <applicative> epto for example , see the equal and opposite note "NOTHING!" xx
08:22:53 <Dtgr> newbie question: http://lpaste.net/91752
08:23:07 <merijn> startling: guard return m ()
08:23:14 <startling> merijn: oh, right
08:23:30 <mietek> startling: I don't want to return v at all
08:23:36 <dmwit> S_J: Either makeResponse isn't exported from RP or it wasn't imported in the module using RP.
08:23:48 <startling> mietek: ok, then don't
08:23:51 <merijn> Dtgr: You want to use "maybe" or "fromMaybe"
08:23:57 <merijn> Dtgr: "fromJust" is evil
08:24:04 <dmwit> Well, to be precise: it wasn't imported in the module using RP, perhaps because it wasn't exported by RP.
08:24:30 <applicative> startling preview _Right !!!
08:24:46 <merijn> :t maybe
08:24:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:24:51 <merijn> :t fromMaybe
08:24:52 <lambdabot> a -> Maybe a -> a
08:24:59 <applicative> :t maybe Left
08:24:59 <startling> applicative: yeah! isn't that neat?
08:24:59 <lambdabot> (a -> a1 -> Either a1 b) -> Maybe a -> a1 -> Either a1 b
08:25:05 <applicative> opps
08:25:08 <Dtgr> but in that certain situation there's no way maybeAuth returns Nothing
08:25:09 <applicative> oops too
08:25:20 <Dtgr> so i thought using fromJust is fine
08:25:23 <S_J> dmwit: but i dont export functions I just have a module RequestParser and then I import it as import qualified RequestParser as R
08:25:39 <merijn> Dtgr: If it can't return Nothing, why do you have a Maybe?
08:25:40 <applicative> startling: yes actually, I just thought epto was looking for a ... smaller dependency
08:25:45 <dmwit> S_J: Post a minimal reproducing example to lpaste.
08:25:50 <startling> applicative: heh
08:25:50 <epta> startling: and how can I get Nothing from (Left 1) with (_Right)?
08:26:02 <startling> epta, preview _Right
08:26:10 <startling> :t preview _Right
08:26:11 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
08:26:25 <Dtgr> merijn: i'm using yesod. maybeAuth returns Nothing if a user is not logged in at the moment, but the function i'm in is executed only for logged users
08:26:33 <startling> :t preview _Right :: Either a b -> Maybe b
08:26:34 <lambdabot> Either a b -> Maybe b
08:26:55 <epta> startling: I thought that preview is not a function, thanks :)
08:27:35 <Dtgr> I just thought by looking at the code that the same could be done with one line only
08:27:55 <applicative> epta I just mention errors since import Control.Error puts all these nice Either/Maybe functions in scope, Data.Either, Data.Maybe, and on and on
08:28:05 <merijn> Dtgr: Well you could do "(Entity aid a) <- fmap fromJust maybeAuth"
08:28:07 <dmwit> Dtgr: Just (Entity aid a) <- maybeAuth
08:28:32 <merijn> oh, yeah, I guess that too :p
08:28:33 <hpaste> sj pasted “Not in scope” at http://lpaste.net/91753
08:28:38 <merijn> Both are rather evil, though
08:28:53 <dmwit> Dtgr: Bonus: when (not if) this goes wrong, the error reported will give the line with the erroneous pattern match instead of the line where fromJust is defined.
08:28:58 <egblu3> w/join #railspl
08:29:27 <Dtgr> dmwit merijn: thanks :) just what I needed
08:32:05 <dmwit> S_J: Could not reproduce. After deleting all lines mentioning StoreParser (since you didn't post that file), everything loads fine.
08:32:39 <dmwit> S_J: Are you sure the file on your disk and the file you're looking at in your editor are DEFINITELY the same?
08:33:49 <epta> Is there some <$> analog for 2 functor wrappers depth? Like :: (a -> b) -> f (g a) -> f (g b) ?
08:33:49 <hpaste> sj annotated “Not in scope” with “Not in scope (annotation) StoreParser” at http://lpaste.net/91753#a91754
08:35:40 <merijn> epta: Data.Functor.Compose
08:35:41 <dmwit> S_J: Still cannot reproduce. With the three files posted, Store.hs loads fine in ghci.
08:36:00 <merijn> epta: Require newtype wrapping/unwrapping, but fine other than that
08:36:01 <applicative> oh this is still a problem with the .cabal file
08:36:22 <S_J> dmwit: wow you were right, somehow I didnt save the file RequestParser. ty
08:36:51 <applicative> oh
08:42:04 <sm> morning all
08:42:24 <applicative> hey sm
08:42:27 <sm> what does it mean when you cabal install helm and "Cannot find gtk2hsC2hs" even though it's in your path ?
08:43:06 <dmwit> sm: Hm, strange.
08:43:14 <dmwit> sm: What does `which gtk2hsC2hs` say?
08:43:15 <startling> sm, how do you know it's in your path?
08:44:44 <startling> @hoogle Monad m => m Bool -> m ()
08:44:45 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
08:44:45 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
08:44:45 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
08:45:00 <applicative> well, my gtk2hsC2hs is in path, and cabal install helm works for me.
08:45:16 <startling> ^ I want to do an action over and over again until it gives me a False. Any ideas?
08:45:38 <monochrom> I would write it myself
08:45:47 <startling> it's /almost/ whileM in monad-loops, but not quite
08:46:09 <startling> monochrom: sure. it's trivial, I just thought it would be good to know if it's somewhere.
08:46:35 <sm> dmwit, startling: which says: gtk2hsC2hs is /Users/simon/.cabal/bin/gtk2hsC2hs
08:46:40 <satc> Is there any performance difference between using a wild card or a variable in patter matching?
08:46:48 <applicative> m Bool -> m () ?
08:46:55 <startling> oh, I guess it's orM . repeat.
08:46:56 <sm> and I can run it
08:47:09 <dmwit> satc: no
08:47:13 <startling> sm, then what's the problem?
08:47:35 <sm> I can run gtk2hsC2hs but apparently cabal install helm can't. Let me try -v3
08:47:44 <Peaker> bah, all this time I was stumbling on: http://ghc.haskell.org/trac/ghc/ticket/7646
08:47:59 <applicative> oh I see orM startling ; it seems it could just do with your function; I wonder what it should be called
08:48:02 <Peaker> what's an easy way to know if commit fbd4b4c2587636811d464040e349d81fac9e1121 is in 7.6.3?
08:48:08 <applicative> tillTrue or tillFalse
08:48:20 <dmwit> startling: iterateWhile id ?
08:48:32 <applicative> ha
08:48:45 <startling> oh, that works too.
08:49:08 <monochrom> wait, what? just calling close() does not release the lock?!
08:49:15 <sm> -v3 does not help. I expect it's not finding the gtk c libs and giving this misleading error
08:49:39 <sm> I wanted to make sure before going down a wild goose trail
08:50:00 <dmwit> sm: Hm. If the gtk libs are missing, it should make some reports about pkg-config, not gtk2hsC2hs.
08:50:16 <dmwit> sm: Could you paste the output for us, maybe?
08:50:26 <sm> hm. ok, one sec
08:50:34 <dmwit> Not that I'm likely to see anything you didn't, but...
08:51:40 <applicative> i see, it is trying to install cairo
08:52:20 * applicative was puzzled since it uses SDL
08:52:40 <applicative> sm, brew install cairo; cabal install cairo; cabal install helm
08:54:07 <sm> aha. Btw, is there a way to brew install --dry-run ?
08:54:16 <applicative> hm, good question
08:56:20 <sm> I assume cairo depends on the gtk+ or gtk+3 brew package, guess I'll know in a while
08:56:56 <monochrom> yes, it does
08:56:58 <sm> applicative: any idea why it gave that error though ? it's another of those roadblocks in the haskell gui story
08:57:58 <applicative> sm no, it isn't what should have happened
08:58:11 <applicative> i think you will need brew install cairo --universal
08:58:33 <sm> oh thx, maybe so
08:58:51 <applicative> you can look at the file with brew edit cairo
08:58:58 <Peaker> the bugfix I need in libraries/base is from Feb 13, 2013, and it's still not in 7.6.3 or base base-4.6.0.1 :-(
08:59:10 <applicative> we could do with cabal edit blah, not meaning really to edit necessarily
08:59:10 <sm> that keeps catching me out. I downloaded the 64 bit ghc but haven't dared switch yet
09:00:23 <lemao> could someone shed some light into the differences between pipes and FRP such as netwire?
09:01:28 <applicative> FRP involves explicit time for one thing
09:01:52 <dmwit> I don't think time is a fundamental part of FRP.
09:02:27 <dmwit> Maybe I should shut up on account of how little I actually know about FRP.
09:02:41 <danharaj> FRP usually has some way to change the topology of the network.
09:03:04 <lemao> danharaj: is that what is called switching?
09:03:47 <applicative> dmwit: oh, I decided to start with that since conal says, 1) continuous time 2) ...
09:04:16 <merijn> applicative: 2) denotational semantics :)
09:04:22 <applicative> basically yes
09:04:36 <dmwit> Conclusion: yes, I should definitely shut up.
09:06:09 <merijn> lemao: btw, if you ask conal he'll tell you netwire isn't FRP as he defined it
09:06:47 <danilo2> Hi! Is there in Haskell something like "default value"? I mean default value for Int would be 0, for string would be [] etc? I want to create datatypes which will have some kind of function "mkWithDefaultValues" and it should init all fields to their defaults.
09:06:57 <merijn> danilo2: Data.Default?
09:07:00 <cdk> danilo2: take a look at monoids
09:07:26 <Taneb> danilo2, Data.Default sounds like the way to go
09:07:29 <merijn> > def []
09:07:30 <lambdabot>   Overlapping instances for Data.Default.Class.Default ([a0] -> t)
09:07:30 <lambdabot>    arising...
09:07:31 <merijn> eh
09:07:36 <merijn> > def :: [Int]
09:07:37 <lambdabot>   []
09:07:41 <merijn> > def :: Int
09:07:42 <lambdabot>   0
09:07:48 <lemao> merijn: it is not clear to me what do I gain/loose by choosing pipes over netwire or a real FRP
09:08:12 <danharaj> lemao: yes that is what is called switching
09:08:15 <merijn> lemao: They attempt to solve completely different and orthogonal problems, you'd probably combine pipes with FRP
09:08:41 <danilo2> merijn, cdk, Taneb: Than you! I'm looking into it right now :)
09:08:54 <merijn> lemao: You're phrasing your question as an "either/or", which makes no sense as they are not mutually exclusive
09:09:52 <applicative> lemao: what are you doing that you want any of these things?
09:09:52 <lemao> merijn danharaj: the use case I am interested in is server side actor model receiving messages for one or more types, handling each message, then generating an event from it.
09:10:53 <sm> applicative: after brew install cairo, cabal still can't see it. There was a warning and I tried to adapt: https://gist.github.com/simonmichael/6205502
09:11:38 <merijn> lemao: FRP deals with "behaviour that changes over time", pipes deals with "handling input/output as a streaming process"
09:12:06 <lemao> applicative: the handler takes the input message and some local state (a record with N fields), perform some validation using values in this record, then generates an event. This event feeds back and updates the record and is published out
09:12:28 <merijn> lemao: You'd use pipes to parse your network traffic for example, but you could easily implementn the servers behaviour as something FRP based, getting input from pipes/conduits/whatever
09:12:32 <applicative> sm, hm.  I just have extra-include-dirs: /usr/local/include
09:12:34 <applicative> extra-lib-dirs: /usr/local/lib
09:12:39 <applicative> in my .cabal/config
09:12:53 <lemao> merijn: but why introduce FRP and not just use pipes?
09:13:31 <merijn> lemao: Because FRP does something completely different?
09:13:42 <lemao> merijn: the "behavior that changes over time" would be the local state (record that gets updated by the generated events)
09:13:50 <merijn> lemao: Not necessarily
09:13:55 <lemao> merijn: :-) yes, that is what I am after
09:14:00 <lemao> what is the diff
09:14:08 <merijn> lemao: pipes doesn't let you define "do X for 5s, then y"
09:14:29 <merijn> Or "do X until event y happens"
09:15:07 <sm> ah well.. I must drop it for now, thanks for the help applicative dmwit startling
09:15:29 <merijn> lemao: Have you read the Functional Reactive Animation paper?
09:16:14 <lemao> merijn: I didnt. Let me take a look
09:17:00 <merijn> lemao: http://conal.net/papers/icfp97/
09:18:07 <applicative> lemao: and on the other hand the pipes-concurrent tutorial. here's the new version https://raw.github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/4.0.0/src/Pipes/Concurrent/Tutorial.hs
09:23:50 <lemao> applicative: this is also helpful. After a quick scan, I see that pipes-concurrent overlaps with something like CloudHaskell
09:44:02 <lightquake> why isn't there a Foldable instance for Vector?
09:44:58 <elliott> would need the constraint for things like unboxed vectors, I think
09:45:01 <elliott> boxed ones should have an instance?
09:45:20 <applicative> they do
09:50:49 <mietek> Is it possible to have an operator with three arguments?
09:50:52 <lightquake> ah, yep, they do
09:51:00 <Iceland_jack> mietek: No
09:51:11 <Iceland_jack> You might be interested in Agda's mixfix operators though
09:51:57 <mietek> Iceland_jack: thanks, I actually am learning Agda, but not in this context
09:51:58 <applicative> mietek: sure as long as the operator goes between the first two arguments...
09:52:07 <mietek> applicative: hm, how?
09:52:17 <mietek> applicative: without defining additional functions?
09:52:34 <Iceland_jack> mietek: applicative means something like: (f !!! g) x
09:52:36 <applicative> > let (><) = foldr in (+) >< 0 $ [1..10]
09:52:37 <lambdabot>   55
09:53:22 <simukis_> why can't cabal rebuild all depending libraries not built with profiling support when I want to build some package which heavily depends on others with profiling support?
09:53:32 <simukis_> or rather why it doesn't?
09:53:59 <applicative> simukis_: it can, you just do do rm -r .ghc etc .. ;)
09:54:48 <S_J> I cant "return" froma  fucntion right? I need to call it with an extra arg and add anopther case for the function so runshell :: Bool -> IO () and then runshell False = return (); runshell True = doStuff; ?
09:54:48 <geekosaur> because to have it work reliably, you'd also have to rebuild the normal versions (otherwise the prof versions might not refer to the same things as the normal ones) and then rebuild everything dependent on those. because ghc's kinda stupid
09:54:58 <simukis_> applicative: well, that's not satisfactory solution at all 😊
09:55:09 <applicative> simukis_: just uncheck library profiling in your .cabal/config this is a major transition
09:55:15 <geekosaur> (well, not exactly stupid, it's the price of the cross-module inlining it does)
09:55:40 * merijn sighs
09:56:02 * merijn increments the "number of bugs this afternoon caused by wrong boolean conditions" to "at least 5"
09:56:02 <simukis_> applicative: that's exactly what I did now… but those increased build times for libraries I don't need profiling support for…
09:56:13 <applicative> simukis_: yes, it's no joke
09:56:23 <applicative> simukis_: do you know -j
09:56:29 <simukis_> sure I do.
09:56:42 <applicative> simukis_: you can reason about it, but that in my experience takes longer
09:56:54 <applicative> the other alternative is of course cabal sandbox init etc
09:57:35 <quchen> S_J: You can do "early returns" with Cont, but most of the time that is not the best solution.
09:57:52 <applicative> thought it occurs to me, I dont knw if it's easy to have your main stuff without -prof, but a sandbox with it
09:59:04 <joelteon> does hackage have an API to get the .cabal file of the most recent version of a package?
09:59:08 <applicative> simukis_: on reflection, maybe that would make the most sense; by hypothesis the stuff you want with profiling is stuff youre working on, not your 'user' .cabal material
09:59:36 <applicative> cabal get x ; edit x/x.cabal ?
09:59:46 <startling> what do people think of haskeline?
09:59:58 <applicative> startling: ghci uses it, so it must be good
09:59:59 <joelteon> applicative: I mean, programmatically
10:00:09 <startling> applicative, heh
10:00:25 <applicative> joelteon: I was just wondering what would go wrong with cabal edit blah
10:00:44 <applicative> which does what I just said, unpacking the source maybe in a temporary place.
10:01:16 <joelteon> ok
10:01:25 <joelteon> well, I'd rather not shell out to do that
10:01:28 <applicative> like pacman and homebrew and company.  it's probably a dumb idea
10:01:36 <joelteon> I'll go look at the cabal-install source and see what it does
10:02:54 <applicative> with the further desideratum that the editor opens at the line where upper bounds are stated ... ha
10:03:00 <S_J> There really should be a more beautiful way to comment your code in emacs/HAskell. Just making comments red make them look like errors, also the syntax is ugly. I t would be good to have red comments( i realize this is because of emacs) for things you want to change and then some nicer looking format for comments that are there to explain.
10:03:35 <joelteon> no, I mean, I just want to take a package name and use Distribution.PackageDescription.Parse to read the associated cabal file on hackage
10:03:52 <applicative> Oh i see.
10:04:09 <mietek> Is there a way to forcibly import a hidden module?
10:04:10 <applicative> Yes, I started adding the other stuff because I was thinking about it for another reason.
10:05:02 <applicative> mietek: you mean one not exposed by a package you're using?
10:05:07 <mietek> Yes
10:05:16 <mietek> That's what GHC calls a hidden module
10:05:17 * hackagebot c2hs 0.16.5 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.16.5 (IanRoss)
10:05:23 <applicative> right
10:05:26 <dmwit> S_J: I'm no emacs expert, but I bet it's easy to change what color comments are.
10:06:02 <applicative> mietek: I don't think so, it can be a sort of semantical feature that something is hidden
10:06:18 <merijn> mietek: afaik it's impossible
10:06:32 <mietek> Semantically preventing stuff to work, yes
10:06:35 <merijn> mietek: This is why packages like Pipes export "Pipes.Internal" in case you do need the internals
10:06:51 <merijn> mietek: What problem are you running into?
10:07:24 <applicative> mietek: hah, yes. I'm with the pipes / edwardk approach merijn suggested
10:07:24 <mietek> merijn: unfortunately, Data.Aeson doesn't
10:07:28 <mietek> Yeah.
10:07:39 <applicative> bos is emphatically not with the pipes edwardk approach
10:07:40 <startling> S_J: you can make emacs highlight "TODO"
10:08:14 <applicative> i find it extremely irritating that `text` does this, but I suppose he's right
10:08:18 <merijn> mietek: Which part of aeson do you need to get at?
10:09:58 <S_J> Is it arrogant to believe that the typesystem in Haskell make comments unnecessary? I geenrally dont believe som much in comments. A deisgn document does more for you than a lot of comments (and often comments are so poor anyway).
10:09:59 <mietek> merijn: just the Parser type, to define my own combinator
10:10:15 <mietek> merijn: I can define it without an explicit type declaration, though...
10:10:16 <startling> S_J, I think you're wrong.
10:10:29 <applicative> S_J have you considered doing .lhs files?
10:10:43 <hvr> startling: ...you mean the fixme-mode?
10:10:44 <startling> S_J, say you have a function Char -> Bool. what does it do?
10:11:06 <startling> hvr, there are a couple iirc
10:11:26 <merijn> mietek: You just need the type or the implementation too?
10:11:30 <applicative> S_J:  also, have you considered haddocking ??
10:11:37 <hvr> startling: I find the one with the fringes (see http://www.emacswiki.org/emacs/FixmeMode) nice
10:12:05 <mietek> merijn: I think just the type
10:12:14 <merijn> mietek: It's defined in Data.Aeson.Types
10:12:24 <merijn> mietek: http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Types.html
10:12:37 <applicative> this is different from comments narrowly speaking {-| Is the character upper case? -}
10:12:47 <applicative> S_J:
10:13:04 <merijn> mietek: Keep in mind that things like "Data.Aeson" don't necessarily export everything that's accessible
10:13:58 <mietek> merijn: right, I missed that, thanks
10:18:24 <danr> donri: ping?
10:18:37 <donri> danr: pong!
10:18:59 <tertl3> hello
10:20:17 * hackagebot cabal2nix 1.53 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.53 (PeterSimons)
10:21:08 <tertl3> i think there are some errors in the imports here http://jonathan.tang.name/files/scheme_in_48/code/listing10.hs
10:21:41 <geekosaur> not exactly errors, just changes
10:22:20 <geekosaur> the haskell98 flat namespace imports can't be used with more modern language versions
10:22:29 <geekosaur> Monad is Control.Monad now, for instance
10:22:40 <geekosaur> and IO is System.IO
10:24:07 <geekosaur> meanwhile Parsec was upgraded and the parsec3 modules are Text.Parsec instead of parsec2's Text.ParserCombinators.Parsec (there were also some changes to how the parser works, but parsec2-using code should be pretty compatible with parsec3 at this point aside from the module rename. it wasn't originally, which is why the rename happened)
10:24:34 <tertl3> ty geekosaur i will edit it since its a wiki
10:24:49 <tertl3> i remember it threw me when I first tryed it 6 mos ago
10:27:39 <S_J> How do I return a Map from a fucntion doing IO? like when I abort the function calling it like serverLoop mymap False = what do I return here?
10:29:05 <scshunt> S_J: return mymap ?
10:29:44 <edwardk> paolino: re lazily evaluated structure i don't follow
10:32:24 <S_J> scshunt: tried that but get:     Couldn't match expected type `()'
10:32:24 <S_J>                 with actual type `Data.Map.Map
10:32:24 <S_J>                                     String (StoreParser.DataType, String)'
10:33:09 <scshunt> S_J: well there's your problem. Your code is expecting the type to be IO ()
10:33:19 <scshunt> which is effectively saying it has no value associated
10:33:30 <scshunt> you would need a IO (Map ...)
10:34:10 <S_J> yes but how do I return an IO Map?
10:34:14 <S_J> how do i wrap it in return?
10:35:06 <pentace> Can you paste the relevant code parts?
10:35:16 <scshunt> S_J: return takes a value and wraps it in IO
10:35:35 <scshunt> so if mymap is of type Map String Foo, then return mymap is of type IO (Map String Foo)
10:35:49 <scshunt> we say that it has type a -> IO a
10:36:03 <ParahSail1n> :type return
10:36:08 <scshunt> (in the specialized IO case; return is actually slighly more general)
10:36:14 <ParahSail1n> @type return
10:36:15 <lambdabot> Monad m => a -> m a
10:42:57 <S_J> if i print something in a function i have to return IO ? it cant return a pure value?
10:44:17 <shiona> yes
10:44:21 <xplat> hm MaybeT in transformers but none in mtl?
10:45:09 <xplat> nevermind, left out the .Trans.
10:45:50 <monochrom> put back the .Trans, now you're back to transformers. it is really not in mtl
10:46:21 <xplat> well, i can use it with mtl, this is close enough
10:46:37 <monochrom> yeah
10:47:03 <scshunt> S_J: yes, it must return a value in IO
10:47:09 <scshunt> but you can wrap any value in IO
10:47:10 <danilo2> Is it possible in Haskell to group types into something simmilar to structures? I want for example to group G{a::String, b::Int} and then create var x :: G.a
10:47:20 <scshunt> "IO a" means "an IO computation with a value of type a"
10:47:29 <scshunt> S_J: does that make sense?
10:47:53 <scshunt> since () only has one value and it's pretty boring, it's generally used as a placeholder for "no value"
10:48:08 <xplat> if you just want a debug print you can use trace, but if you use that for real application logic it'll bite you in the ass
10:49:11 <xplat> @quote oasis
10:49:11 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
10:50:08 <pentace> danilo2: You're looking for record data types, I guess, see http://learnyouahaskell.com/making-our-own-types-and-typeclasses
10:52:32 <danilo2> pentance: No :) Maybe the question was not clear enough. I'm generating Haskell code in my compiler - I want to "group some types" to be able to get them by "alias names" like G{a::String, b::Int} and then get them like G.a, but I feel Haskell does not support somethingl ike that
10:53:18 <pentace> Ah, I misread
10:53:29 <DMcGill_> so I have some list comprehension of the form `out = [f x |  x <- input]'. I've decided that I'd like `out` and `input` to be Sets. It's easy enough to make input a Set but now I need to translate the list comprehension. Any suggestions?
10:54:01 <hpc> :t S.fromList
10:54:02 <lambdabot> Ord a => [a] -> S.Set a
10:54:07 <pentace> danilo2: something with type families and phantom types maybe
10:54:17 <hpc> :t S.toList
10:54:18 <lambdabot> S.Set a -> [a]
10:54:23 <DMcGill_> surely calling fromList and toList everywhere would be terriblly inefficient?
10:54:29 <DMcGill_> lots of marshalling back and forth
10:54:43 <xplat> DMcGill_: no more inefficient than iterating over the whole Set
10:55:00 <danilo2> Ive got another question connected to types. Can I make something like that: type t1 = (Int, String); t2 = (Vector, Scalar) AND NOW create a type declaration, which would be tuple of types (Int, Scalar), but I wantto create It by telling I want it to have the "first" type from t1 and the second from t2?
10:55:01 <pentace> danilo2: s/phantom types/types without value/
10:55:17 <xplat> DMcGill_: the lists should probably not be actually constructed, because of fusion
10:55:18 <hpc> if you know f has a few specific properties, there's an unsafe function that maps f directly over the set
10:55:24 <DMcGill_> ah, great
10:55:26 <hpc> but i wouldn't touch that
10:55:41 <danilo2> pentance: I'll look into it, I asked just a moment ago a second question - If it is possible it iwll solve my first one
10:55:42 <startling> DMcGill_, you can use some of the Data.Foldable functions if it makes you feel better
10:55:46 <DMcGill_> ah, my problem is more that I actually have [f x y | x <- in1, y <- in2]
10:56:06 <DMcGill_> I'm going to try toList and fromList
10:56:38 <pentace> danilo2: I think your second problem can be solved with type families as well, these are basically functions on the type level
10:56:44 <DMcGill_> and trust in the magic of fusion <3
10:57:06 <xplat> if it's a cartesian product like that i wouldn't be surprised if one of the lists is constructed, but the other should still not be
10:57:46 <DMcGill_> also, a little code golf:
10:57:47 <DMcGill_> -- sym [a,b,c] = [(a,a),(a,b),(a,c),(b,b),(b,c),(c,c)]
10:57:54 <DMcGill_> sym es@(e:es') = map (e,) es ++ sym es'
10:57:57 <danilo2> pentance: great! I'll read about them! If you know them, would you be so nice and post a sample code, which implements my simpel example?
10:57:58 <DMcGill_> sym [] = []
10:58:10 <DMcGill_> I'm sure that's a fold
10:58:16 <DMcGill_> or something
10:58:47 <elliott> Conor has a nice way of writing that, I think
10:59:09 <Fuuzetsu> a lot of things are folds... fold a map over it (and use <> to get rid of the sym [])
10:59:17 <S_J> What is the type of a function that does serverLoop m = do print m; doStuff m; return m; ?
10:59:42 <pentace> danilo2: Let my try, I haven't used them for a long time :P
10:59:57 <DMcGill_> serverLoop :: Show a => a -> IO a
11:00:02 <hpc> :t let doStuff = undefined; serverLoop m = do {print m; doStuff m; return m} in serverLoop
11:00:03 <lambdabot> Show b => b -> IO b
11:00:45 <startling> > let sym s = (,) <$> s <*> s in sym [a, b, c]
11:00:46 <lambdabot>   [(a,a),(a,b),(a,c),(b,a),(b,b),(b,c),(c,a),(c,b),(c,c)]
11:00:54 <startling> oh
11:02:02 <danilo2> pentance: I would be very thankful! :)
11:04:39 <S_J> cant you use when and return IO Map?
11:05:04 <xplat> according to my analysis, sym can't be turned into a single (non-nested) foldr without hiding another fold in an auxiliary function
11:05:45 <S_J> m (). what is that ?
11:05:50 <DMcGill_> it doesn't matter to me whether it's [] or Set if that makes any different
11:05:53 <DMcGill_> difference*
11:05:57 <DMcGill_> but thanks for looking
11:06:56 <merijn> ok, API opinion poll
11:07:22 <quchen> S_J: Your first question isn't clear enough to answer.
11:07:26 <hpaste> pentace pasted “type family projections” at http://lpaste.net/91755
11:07:27 <merijn> If I have an API that accepts string identifiers of at most 255 characters, what's the best way to enforce this?
11:07:36 <xplat> but you can do stuff like concatMap $ zipWith (\e -> map (e,)) es (tails es), and there is a lot of golfing you can do from there
11:07:43 <quchen> Concerning #2, yes, you can use return with IO Map, because IO is a monad and you can always use return with that.
11:07:47 <startling> merijn: is it actually 255 characters?
11:07:50 <merijn> Newtype it and have a "String -> Maybe Identifier" constructor? That seems rather cumbersome
11:07:50 <quchen> #3 It's a type.
11:07:52 <startling> merijn: or 255 bytes?
11:07:55 <pentace> danilo2: ^^^ foo shows that the correct types are selected
11:08:14 <merijn> startling: irrelevant to my question :)
11:08:22 <DMcGill_> also, are `map f . S.toList' and `S.toList . S.map f' the same due to fusion?
11:08:30 <quchen> merijn: Maybe sounds like the right thing for me here.
11:08:46 <merijn> quchen: Seems really cumbersome, though
11:08:54 <startling> merijn: data BS = BS { _1, _2, ..., _255 :: Word8 }
11:08:55 <merijn> How would you handle failure?
11:09:05 <DMcGill_> what other options are there? Crash or silently truncate
11:09:11 <merijn> Truncate or exception
11:09:12 <DMcGill_> or return Maybe and let the user crash
11:09:15 <quchen> merijn: Cumbersome?
11:09:25 <quchen> merijn: You'll have to replace some (.) with (>=>), but apart from that?
11:09:28 <danilo2> pentace: tahts exactly what I was trying to do! Thank you so much! I'm digging into Tpye families rightr now, but with your help its so easier now:) Thanks!
11:09:35 <joelteon> new-hackage isn't up to date :(
11:09:39 <merijn> quchen: If you write a string literal in your code how would you unmaybe it?
11:09:43 <pentace> danilo2: you're welcome
11:10:11 <xplat> DMcGill_: map f . S.toList should be faster because it doesn't have to police the results of f for collisions
11:10:13 <quchen> merijn: Depending on your API you could of course also yell and crash ("invalid syntax, fix it")
11:10:15 <startling> it sucks that OverloadStrings doesn't let you error.
11:10:46 <merijn> quchen: Well, that's kinda what I was polling, which is preferred by people here
11:10:48 <quchen> merijn: Silent truncation is ten levels of awful beyond anything "cumbersome", I really wouldn't go for that
11:11:48 <xplat> merijn: even silent mangling is better than silent truncation
11:12:13 <merijn> "setName :: Socket -> Identifier -> IO ()" combined with "stringToIdentifier :: String -> Maybe Identifier" is really annoying with literal identifiers
11:12:21 <merijn> xplat: How is mangling different from truncation?
11:13:16 <xplat> merijn: if the mangling is good enough people might naturally switch to a new library before they get bit by it.  truncation is definitely not a good enough mangling for that.
11:13:19 <startling> merijn, it's in IO? just error if it's over 256
11:14:01 <danilo2> pentance: I'm testing your code and I see only one problem: Is it possible to create 2 instances for Fst? (for tuples of different lengths?)
11:15:16 <merijn> xplat: long identifiers in this scenarion are ridiculous anyway, the proper response (if possible) would be unsafeStabUser as people shouldn't get close to it anyway
11:15:25 <danilo2> pentace: (I've misstyped your nick a moment ago): I'm testing your code and I see only one problem: Is it possible to create 2 instances for Fst? (for tuples of different lengths?)
11:15:34 <merijn> startling: Well, it will be something IO-ish
11:15:43 <startling> oh, another lie
11:15:56 <startling> :)
11:15:57 <merijn> The alternative would be like "createSocket :: Maybe Identifier -> IO Socket"
11:16:23 <xplat> that ... could cause an impedance mismatch
11:16:40 <merijn> xplat: ?
11:17:20 <xplat> accidentally feeding in a 'Maybe' that came from 'check if the identifier is too long' to a 'Maybe' input that means 'maybe i want a name, maybe i don't'
11:17:52 <merijn> xplat: Yes, I would probably use "Maybe String" there and throw an exception
11:17:58 <xplat> that would result in silently changing things with long names to anonymous things, which is probably not desired behaviour
11:19:26 <xplat> C is so verbose :(
11:19:29 <merijn> I'm not a big fan of the "String -> Maybe Identifier" anyway, as I expect identifiers to mostly be string literals, so how would you as a user sanely "unmaybe" a String literal
11:19:39 <danilo2> Lets say I've got a type family 'type family Select0 a :: *' Can I make somehow such instances: type instance Select0 (a) = a AND  type instance Select0 (a, b) = a?
11:20:06 <azm> if C is verbose then what is java
11:20:11 <merijn> danilo2: You can in 7.7! :)
11:20:16 <xplat> merijn: with fromMaybe __IMPOSSIBLE__
11:20:39 <danilo2> merijn: Great! when the 7.7 would be released out? Can I test it now?
11:20:43 <merijn> xplat: Which would essentially just be the same as throwing an exception :p
11:20:51 <xplat> azm: i'm porting a simple utility kind of thing and main.c alone is over 4k lines
11:20:56 <S_J> Weeeeehoooo! I have managed to write a key/value store in haskell! it is absolutely terrible compared to a real database but it works! Now off to 2 years of study before I can start writing an indutrial strength one!
11:20:58 <merijn> danilo2: 7.7 is not a "real" version, odd numbered ghc's are development branches
11:21:23 <merijn> danilo2: You can check out HEAD and build it to play with it
11:21:34 <xplat> merijn: why not supply a quasiquoter that errors out at compile time if you give it over 255 characters?
11:21:54 <danilo2> merijn: good to know that :) thank you :) I'll test it right now :)
11:22:01 <merijn> xplat: Would you as a user prefer that to just writing Strings?
11:22:10 <xplat> merijn: depends on the user
11:22:31 <merijn> xplat: No, I'm askng whether *you* personally would prefer that, that was the entire point of polling the channel
11:23:01 <xplat> i would definitely go with it if the limit was like 32 characters or something, 255 it might be better to just go with string literals and hope for the best
11:23:10 <danilo2> merijn: Is there a place where I can learn more about new things in 7.7 (or 7.8)?
11:24:09 <S_J> can you somehow get LOC from a cabal project?
11:24:27 <jmcarthur> cabal doesn't itself provide a way. there's always something like wc or sloccount
11:24:31 <xplat> upload it to github and let them figure it out?  :)
11:24:47 <merijn> danilo2: The GHC users mailing list, the GHC trac and GHC wiki are probably the best places
11:25:09 <S_J> I use emacs, I have tried the Eclipse mode but it felt to heavy and slow.
11:25:28 <merijn> danilo2: http://ghc.haskell.org/trac/ghc/wiki
11:25:36 <xplat> merijn: i guess i'd only go with the quasiquoter here if you expected a lot of java coders to try using your library
11:26:22 <merijn> xplat: That's what I suspected
11:26:37 <pentace> merijn: What are these overlapping type families called? I guess if they are new it's a new language extension
11:27:14 <merijn> pentace: Well, there's the syntax that was in older GHC 7.7's which may have been deprecated with the arrival of closed type families
11:27:22 <S_J> A key/value store, is that really only if you have an exploding amount of data and cant figure otu fast enough how to store it? so you just kind of shove it in there and your data has no structure?
11:27:41 <merijn> pentace: This syntax used to work: https://gist.github.com/merijn/6130082
11:28:01 <startling> I just tried sloccount. it thinks 23% of my haskell is sh.
11:28:04 <merijn> pentace: The latest 7.7's have closed type families completely implemented, I'm not sure whether that changed/broke this syntax
11:28:46 <pentace> Ah, "closed type families" was the term I've been looking for
11:29:21 <Kaini> @src fromIntegral
11:29:22 <lambdabot> fromIntegral = fromInteger . toInteger
11:30:11 <Kaini> @src fromInteger
11:30:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:30:47 <xplat> S_J: there are a few other reasons, like if you have a distributed store and so the physical organization of your data has to match the consistency guarantees you want
11:31:00 <merijn> pentace: Well, you can have overlapping open type families too, but a lot of sensible things won't work :)
11:31:28 <merijn> Kaini: fromInteger doesn't have one implementation, it has a different one for every instance of Num
11:31:49 <merijn> @src Int fromInteger
11:31:49 <lambdabot> Source not found. You speak an infinite deal of nothing.
11:31:57 <merijn> I didn't expect that to work :p
11:32:00 <pentace> merijn: Well,  the example danilo gave doesn't work for me, it gives an conflicting declaration error
11:32:05 <Kaini> yeah, i just found it in the Num class, but still I wonder how it works
11:32:18 <Kaini> Integer -> a looks like a very strange type signature for me
11:32:28 <startling> Kaini, why?
11:32:39 <merijn> Kaini: It's what's used to convert numeric literals
11:32:51 <merijn> Kaini: "5" is treated as "fromInteger 5"
11:33:05 <startling> it just means "every Num must provide a way to make it out of an integer"
11:33:43 <merijn> :t fromInteger 5 :: Float
11:33:44 <lambdabot> Float
11:33:47 <merijn> > fromInteger 5 :: Float
11:33:48 <lambdabot>   5.0
11:33:55 <merijn> Which happens to be the same as
11:33:58 <merijn> > 5 :: Float
11:33:59 <lambdabot>   5.0
11:34:11 <Kaini> Yeah, it's the same principle as read
11:34:15 <merijn> > 5 :: Fractional
11:34:16 <lambdabot>   Expecting one more argument to `GHC.Real.Fractional'
11:34:17 <merijn> eh
11:34:26 <merijn> > 5 :: Ratio -- ?
11:34:27 <lambdabot>   Expecting one more argument to `GHC.Real.Ratio'
11:34:32 <merijn> I suck at this :)
11:34:35 <xplat> > 99 "bottles of beer on the wall"
11:34:36 <lambdabot>   No instance for (GHC.Show.Show a0)
11:34:36 <lambdabot>    arising from a use of `M1490193093.sh...
11:34:41 <startling> > 5 :: Rational
11:34:42 <lambdabot>   5 % 1
11:34:46 <merijn> Ah, there we go
11:34:52 <xplat> well, that's new
11:35:01 <Kaini> But I just wonder how it is implemented for Float or Double
11:35:07 <merijn> xplat: There's no more caleskell numerics in lambdabot
11:35:15 <xplat> > 5 :: Ratio Double
11:35:16 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
11:35:16 <lambdabot>    arising from the li...
11:35:17 <Kaini> But I guess that's intrinsic
11:35:38 <startling> Kaini, it probably calls into GMP I guess
11:35:45 <xplat> > 5 :: Complex Double
11:35:46 <lambdabot>   5.0 :+ 0.0
11:35:54 <startling> ('Integer' is a GMP bigint in GHC)
11:36:07 <xplat> > 5 :: Complex (Ratio Int)
11:36:08 <lambdabot>   No instance for (GHC.Float.RealFloat
11:36:08 <lambdabot>                     (GHC.Real.Ratio GH...
11:36:19 <xplat> merijn: the error was still surprising
11:36:32 <startling> > 1 :: Ratio Rational
11:36:32 <lambdabot>   No instance for (GHC.Real.Integral
11:36:33 <lambdabot>                     (GHC.Real.Ratio GHC....
11:36:36 <startling> :(
11:36:41 <xplat> > 5 :: Complex CReal
11:36:42 <lambdabot>   5.0 :+ 0.0
11:37:12 <xplat> merijn: the exact message, i mean
11:37:13 <merijn> xplat: Why?
11:37:20 <danilo2> merijn: Thank you for the links :) I'll read them :)
11:37:33 <merijn> xplat: oh, the show thing
11:37:43 <merijn> xplat: Lambdabot has a show instance for functions now
11:37:45 <merijn> > id
11:37:46 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
11:37:46 <lambdabot>    arising from a use ...
11:37:47 <xplat> the appearance of 'M1490193093' for one
11:37:49 <merijn> oh, bah
11:37:53 <merijn> > ord
11:37:55 <lambdabot>   <Char -> Int>
11:38:07 <startling> 'id' is too polymorphic?
11:38:13 <merijn> startling: Probably
11:38:31 <startling> oh, I guess it probably uses Typeable to find the name of the type
11:38:39 <startling> surprising it doesn't default, though
11:38:48 <startling> > id :: Char -> Char
11:38:49 <lambdabot>   <Char -> Char>
11:38:52 <merijn> Kaini: It probably usses something along the lines of "ghcPrimIntToFloat#" or equally low level "don't touch this" name :)
11:39:43 <xplat> stop!  # time.
11:40:01 <merijn> Kaini: Basically, you're question is now at the same level of "How is the cast from int to double implemented in C?" and the answer is "some implementation specific function"
11:40:18 <merijn> Kaini: As the implementation obviously depends on the runtime representation of Integer and Float
11:40:18 * hackagebot cabal-audit 0.1.0.0 - Check how up-to-date your .cabal dependencies are.  http://hackage.haskell.org/package/cabal-audit-0.1.0.0 (JoelTaylor)
11:41:31 <Kaini> merijn, ya - but I learned, that in Haskell many things can be implemented in Haskell itself - it could have been that there is some magic behind this function as well
11:42:47 <merijn> Kaini: You could do it in haskell, but it'd be a whole lot less fast than the current GMP implementation :)
11:43:07 <startling> the GMP thing is kind of silly.
11:43:33 <merijn> startling: How so?
11:44:06 <startling> It just bugs me that there's no alternative, especially with the dodgy licensing issues
11:44:32 <merijn> Which licensing issues?
11:45:05 <applicative> the gmp is gpl'd
11:45:14 <startling> GMP is GPLed, so things are dynamically linked to GMP which may or may not be kosher
11:45:19 * hackagebot cabal-audit 0.2.0.0 - Check how up-to-date your .cabal dependencies are.  http://hackage.haskell.org/package/cabal-audit-0.2.0.0 (JoelTaylor)
11:45:28 <S_J> the way to achieve parametric polymorhpism is via typeclasses?
11:45:38 <geekosaur> there *is* an alternative, it's just not very good
11:45:38 <merijn> It's LGPL according to their site
11:45:41 <Fuuzetsu> dynamic linking does not fall under licensing I believe, only static
11:45:50 <startling> oh, right, it's LGPL
11:45:56 <applicative> it must be hard to implement, people have I think labored to get rid of it
11:45:56 <merijn> Even static linking is fine with LGPL
11:46:00 <geekosaur> S_J, typeclasses are ad-hoc polymorphism
11:46:13 <startling> merijn, are you sure about that?
11:46:14 <merijn> applicative: No, it's just that LGPL is just fine, so why bother?
11:46:15 <geekosaur> parametric polymorphism is like map
11:46:20 <applicative> people don't go quite as crazy with LGPL
11:46:20 <geekosaur> :t map
11:46:20 <lambdabot> (a -> b) -> [a] -> [b]
11:46:45 * applicative invents the NOTGPL license, and figures people will be still panic
11:47:15 <geekosaur> GMP apparently changed its license, if it's now LGPL
11:47:53 <applicative> oh, that's the licence of cpphs
11:48:01 <Fuuzetsu> MIT?
11:48:10 <merijn> Oh, wait, static linking is fine iff you provide a dynamic alternative
11:48:29 <startling> merijn: oh, that's not so bad
11:48:38 <merijn> That's not written like that in the license, but that's the only sensible interpretation
11:48:59 <startling> yeah, I remember there being some vagueness.
11:49:01 <DMcGill_> is there a function like `maybe' but that's cases are empty and nonempty lists? i.e. list :: b -> ([a] -> b) -> [a] -> b
11:49:03 <merijn> startling: Basically, LGPL requires that users can replace the version you used in your binary with their own version
11:49:58 <merijn> startling: i.e. it should be possible to swap out the LGPL component for one with a different implementation of the same interface. Clearly this is not possible if you statically link, but presumably no one will care if you also provide a dynamically linked version that is identical to your statically linked one
11:50:44 <merijn> In the end a judge will decide whether you violate the license or not and it seems unlikely a judge will rule that you are violating the license if you provide an identical dynamically linked version
11:51:02 <merijn> If you allow more features in the statically linked version you could be in trouble, though
11:51:18 <merijn> DMcGill_: listToMaybe?
11:51:21 <merijn> :t listToMaybe
11:51:22 <lambdabot> [a] -> Maybe a
11:51:32 <DMcGill_> isn't that safeHead?
11:51:50 <DMcGill_> I don't want to throw away the rest of the list. I've just defined it myself for now.
11:51:52 <merijn> DMcGill_: Yeah, it's not exactly that, but you can construct that using listToMaybe
11:52:03 <merijn> DMcGill_: I don't think it exists exactly as is
11:52:09 <DMcGill_> @src listToMaybe
11:52:09 <lambdabot> listToMaybe []        =  Nothing
11:52:09 <lambdabot> listToMaybe (a:_)     =  Just a
11:52:27 <supki> @ty \f -> foldr (const . f)
11:52:28 <lambdabot> (a -> b) -> b -> [a] -> b
11:52:47 <DMcGill_> it's a 1-line function, no big deal
11:52:54 <merijn> geekosaur: gmplib.org says "GMP is distributed under the GNU LGPL.", so if it used to be GPL, they did indeed change it
11:59:27 <applicative> it seems the gmp has used lgpl for years
12:01:51 <benzrf> @src seq
12:01:51 <lambdabot> Source not found. Whoa.
12:01:55 <benzrf> @src seqf
12:01:55 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:01:56 <benzrf> hm
12:08:21 <egb3> @type map
12:08:22 <lambdabot> (a -> b) -> [a] -> [b]
12:11:54 <merijn> I guess the easiest way to have a Map with case-insensitive String's as keys is to just lowercase all keys before looking up/inserting?
12:13:50 <byorgey> Twey: eh? what's this about my blog being replaced by a Tesco advert?
12:16:11 <S_J> if you have a: type X = M.Map String String. In your instances of typeclasses you re not allwoed to use X but msut use M.Map String String?
12:16:31 <byorgey> S_J: You can use X if you turn on the TypeSynonymInstances extension
12:26:43 <joelteon> does new-hackage not mirror hackage's package database?
12:26:49 <joelteon> I see a lot of the packages are fairly out of date
12:27:03 <byorgey> it is supposed to.  Not sure of the current status.
12:29:25 <merijn> The machines were recently migrated, I think dcoutts is still getting set up there?
12:29:43 <merijn> Or maybe the migration killed the mirroring and you're the first person to notice...
12:31:07 <geekosaur> someone else mentioned recently (I think on -cafe) that it claimed to be mirroring regularly but was out of date
12:31:24 <merijn> argh
12:31:47 <merijn> Once again I wish GHC would implement recursive imports :(
12:32:14 <hvr> merijn: you mean module import cycles?
12:32:21 <merijn> Yes
12:32:53 <thoughtpolice> technically, the new hackage server is located at http://new-new-hackage.haskell.org/
12:32:56 <hvr> yeah, those .hs-boot files are annoying
12:33:10 <thoughtpolice> which is sort of an artifact of the fact Galois still has new-hackage.haskell.org pointing to one of its machines, I think
12:33:23 <thoughtpolice> dcoutts hasn't got it set up yet apparently, though
12:33:31 <merijn> hvr: I don't have them, and I don't want to create them
12:33:53 <merijn> But any non-trivial package layout for me ends in a struggle trying to figure out how to define modules so I don't have cycles
12:44:35 <merijn> btw, am I really the only one that keeps needing a "Eq a => a -> Get a" and/or "(a -> Bool) -> Get a" function for binary/cereal?
12:45:35 <startling> thoughtpolice: but it says it works right there!
12:47:39 <S_J> byorgey: how do i do that?
12:48:04 <quchen> merijn: What is that function for?
12:48:17 <startling> I don't get it either.
12:48:23 <danr> me neither
12:48:28 <startling> I think you might be missing a constraint, merijn.
12:48:45 <S_J> How do I turn on TypeSynonymInstances?
12:49:00 <geekosaur> S_J: {-# LANGUAGE TypeSynonymInstances #-}
12:49:09 <quchen> ^ At the beginning of the file.
12:49:11 <startling> S_J, fwiw it might not do what you want
12:49:19 <merijn> quchen: Fail if the predicate doesn't match
12:49:34 <danr> and in ghci: :set -XTypeSynonymInstances
12:49:49 <danr> oh wait, you can use the pragma there too
12:50:11 <quchen> merijn: Ah, like a custom filtering expression, i.e. when what you want to get is an Int below 100
12:50:17 <merijn> quchen: i.e. rather than "getWord8 :: Get Word8" I want "word8 0 :: Get Word8"
12:50:37 <merijn> Which fails if the current word is *not* 0
12:50:43 <merijn> quchen: That type of thing, yes
12:50:49 <startling> merijn, yeah, you forgot a parameter
12:51:03 <startling> merijn, whatever >>= guard . (== x) ?
12:51:04 <merijn> startling: oh? Where?
12:51:19 <startling> "Eq a => a -> Get a"
12:51:28 <merijn> Where's the missing parameter?
12:51:39 <merijn> Well, I guess it needs a Serialize instance of a
12:51:45 <startling> oh, right.
12:52:30 <merijn> startling: Yeah, right now I have "satisfy f m = m >>= \x -> if f x then return x else empty"
12:52:44 <merijn> But it's not very pretty
12:54:06 <hpaste> merijn pasted “Ugly serialize code” at http://lpaste.net/91758
12:54:12 <merijn> You end up with a mess like that
12:54:18 <pxqr> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:lazy - it's like magic invisible data constructor, right?
12:54:57 <zomg> Anyone happen to know of a library to find and replace URIs in a string (eg. it contains other content besides uris as well)
12:55:24 <zomg> There's a couple of URI related libs on Hackage but none of them would actually seem to be able to find URIs in strings or such
12:55:40 <quchen> merijn: For what it's worth, you can also omit the if by fancy use of <$ there I think. And that is the most constructive thing I have to say about this. ;-)
12:55:47 <quchen> :t \f m -> m >>= \x -> x <$ guard (f x)
12:55:48 <lambdabot> (Functor m, MonadPlus m) => (b -> Bool) -> m b -> m b
12:56:06 <hpaste> sj pasted “typeclass instance type problem” at http://lpaste.net/91759
12:56:13 <quchen> (Hooray for trading readability for brevity)
12:56:16 <S_J> ^^ can some one help me?
12:57:14 <pxqr> how soon show gets :: Show a => a -> Text ?
12:58:23 <geekosaur> S_J: as the error message says, you need an extension because you're using all concrete types
12:58:27 <pxqr> now i'm going to hate String type again
12:59:00 <pentace> Also, can type classes be qualified?
12:59:21 <quchen> I think they can.
12:59:41 <merijn> quchen: heh, your functions is wrong
12:59:48 <quchen> merijn: But - it's short! :-(
13:00:19 <merijn> quchen: You function returns something with the type of x, where-as here I'm checking it matches a ByteString and then throwing the BS away and returning a constructor
13:02:47 <cschneid> can somebody help me figure out how to use a StateT, and mix in an IO action?  https://gist.github.com/cschneid/6924590b893712315608
13:03:12 <cschneid> this doesn't compile, since the `buildSocket` action is an IO, which I use liftIO on. But then inside of that, I want to continue using my state
13:04:41 <merijn> You can't access the state inside a pure IO action that you lift
13:05:05 <merijn> You could do "do { myState <- get; liftIO $ actionUsing myState; otherStuff }"
13:05:21 <cschneid> merijn: ok. How would I structure this then, since I want to act on the state inside an infinite loop inside that IO
13:05:43 <cschneid> merijn: ie, this is a server process that opens up a zero mq port, and then waits and reacts to the world
13:06:27 <startling> merijn is now the expert for anything even loosely related to zeromq!
13:06:38 <startling> cschneid, liftIO each action, not a block of them
13:07:12 <cschneid> startling: the issue is that making the context and socket are IO actions, and you need to work inside of it
13:07:13 <merijn> startling: I already was :p
13:07:27 <cschneid> let me see if theres a different call that makes a socket without forcing the callback style use of it
13:07:44 <merijn> cschneid: Yes, my annoyance with this library design is the main reason for me currently working on a pure haskell implementation of ZMQ :)
13:07:52 <cschneid> merijn: gimme.!
13:07:57 <merijn> cschneid: Don't hold your breath, though, it'll be ages before it's remotely usable
13:08:24 <cschneid> hah, damn.
13:08:34 <merijn> It doesn't even currently interoperate with anything, as I implemented ZMTP3.0 first, which isn't even working properly in libzmq yet :)
13:08:44 <quchen> merijn: Hm, I don't see the difference between our functions. (Apart from empty vs mempty)
13:09:00 <quchen> The types match, what did you mean with "returns something with the type of x"?
13:09:23 <cschneid> is there a way around my issue here? Some trick to both use state (and other transformers as I add a ReaderT or similar), and also the IO wrapped up callback structure of the zmq lib?
13:09:35 <merijn> quchen: "\f m -> m >>= \x -> x <$ guard (f x)" is the same as satisfy
13:09:46 <quchen> Yes.
13:09:54 <quchen> (I thought you said it wasn't)
13:09:54 <merijn> quchen: But if you look at my paste you'll see I'm <$'ing the result of satisfy
13:10:18 <quchen> Paste? I didn't look at a paste. Sorry for the confusion
13:11:17 <merijn> quchen: ah
13:11:25 <merijn> cschneid: Do the runState inside the context
13:12:05 <merijn> so "withSocket $ \socket -> runEnder foo socket" or whatever
13:12:07 <cschneid> merijn: alternately, I can use the manual open/close approach on socket & context, inside liftIOs, extracting the resulting socket out?
13:12:20 <cschneid> merijn: ahh, that may work too. Let me play with both and see if either works out well
13:13:28 <merijn> cschneid: btw, it helps to annotate your top level functions with their types, because otherwise no one here will have a freaking clue what your functions are supposed to do
13:13:48 <merijn> Normally I don't even bother looking at pastes without types
13:13:53 <cschneid> merijn: good call - lots of just experimenting I do before getting frustrated and asking. I'll be sure to annotate first next time
13:14:46 <startling> It's true. Working with dependent types has atrophied my inferer.
13:14:47 <shachaf> Someone asked me: "Regarding *in-depth* literature on existential types, what can you recommend?". What can I recommend?
13:24:03 <cschneid> merijn: sweet - inverting the IO & the transformer stack worked great. open socket, then run the work it uses. Not optimal for other apps maybe, but this is 100% about the socket anyway, so no biggie
13:25:28 <S_J> whats the efficient way of concatenating strings ? why isnt there such a fucntion in the prelude?
13:25:45 <Fuuzetsu> use Text
13:26:03 <S_J> class Prettyprint a where
13:26:03 <S_J>       prettyprint :: a -> IO () ------ How do I print a list, each item on a new row? I get type [IO] instead of IO
13:26:07 <S_J> if I use mapM
13:26:16 <Fuuzetsu> :t mapM_
13:26:17 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
13:27:01 <c_wraith> S_J: how do you define "efficient"?  (++) is as efficient as possible for the String data type, assuming you need the result immediately.
13:27:39 <c_wraith> S_J: everything that's more efficient uses either a different data type, or is designed for the case where you do many concatenations before consuming the result.
13:27:53 <S_J> it is quadratic...
13:27:58 <c_wraith> no, it's linear
13:28:20 <S_J> well if you use it with a list of strings the whole thing becomes quadratic
13:28:21 <c_wraith> (in the size of its first argument)
13:28:32 <S_J> yes
13:28:41 <Fuuzetsu> that's not how we measure complexity…
13:28:42 <c_wraith> Which is absolutely 100% as efficient as possible.
13:28:56 <c_wraith> The data type necessitates copying the entire first argument
13:29:05 <c_wraith> There's no way around that.
13:29:14 <cdk> @pl f m >> f n
13:29:15 <lambdabot> f m >> f n
13:29:33 <cdk> @pl \m n -> f m >> f n
13:29:36 <lambdabot> flip ((.) . (>>) . f) f
13:29:36 <lambdabot> optimization suspended, use @pl-resume to continue.
13:29:47 <Fuuzetsu> @pl f m n = f m >> f n
13:29:50 <lambdabot> f = id (fix (ap (flip . ((.) .) . ((>>) .)) id))
13:29:50 <lambdabot> optimization suspended, use @pl-resume to continue.
13:30:03 <Fuuzetsu> :t on
13:30:03 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:30:30 <cdk> i think liftM2 (>>) with Cont would work, since Cont a is just ($a)
13:30:52 <c_wraith> @pl \f m n -> f m >> f n
13:30:55 <lambdabot> ap (flip . ((.) .) . ((>>) .)) id
13:30:55 <lambdabot> optimization suspended, use @pl-resume to continue.
13:31:15 <S_J> > [1,2,3] ++ [4,5,6]
13:31:16 <lambdabot>   [1,2,3,4,5,6]
13:31:18 <c_wraith> ok, I give up.  Why is lambdabot giving complete answers *and* that message?
13:32:03 <applicative> the optimization method?
13:32:07 <applicative> message rather
13:32:13 <c_wraith> yeah
13:32:37 <c_wraith> :t \f -> liftM2 (>>) `on` f
13:32:38 <lambdabot> (Monad m, Monad m1) => (a -> m (m1 a1)) -> a -> a -> m (m1 a1)
13:32:58 <c_wraith> drat, I was hoping that'd work.
13:34:43 <Twey> c_wraith: I think it starts with a crappy version then searches for ways to make it better until it runs out of time, at which point it gives you the best it's got
13:34:58 <Twey> cdk: on (>>) f
13:35:08 <cdk> :t on (>>) f
13:35:09 <lambdabot> (Monad m, Show a, FromExpr (m a1)) => a -> a -> m a1
13:35:16 <cdk> Twey: awesome :)
13:35:39 <startling> c_wraith: someone mentioned that it was a bug
13:35:58 <Twey> @pl f m n = f m >> f n
13:36:01 <lambdabot> f = id (fix (ap (flip . ((.) .) . ((>>) .)) id))
13:36:01 <lambdabot> optimization suspended, use @pl-resume to continue.
13:36:03 <Twey> @pl-resume
13:36:09 <lambdabot> f = id (fix (ap (flip . ((.) .) . ((>>) .)) id))
13:36:09 <lambdabot> optimization suspended, use @pl-resume to continue.
13:36:21 <Twey> Hm, doesn't look like it goes any further
13:39:06 <joelteon> that's because f doesn't typecheck, I bet
13:39:24 <S_J> is there a splitOn function?
13:39:38 <S_J> @type String -> (String, String)
13:39:39 <lambdabot> parse error on input `->'
13:39:47 <S_J> @hoogle String -> (String, String)
13:39:47 <lambdabot> System.FilePath.Windows splitExtension :: FilePath -> (String, String)
13:39:48 <lambdabot> System.FilePath.Posix splitExtension :: FilePath -> (String, String)
13:39:48 <lambdabot> System.FilePath.Windows splitExtensions :: FilePath -> (FilePath, String)
13:40:13 <erider> > take 10 [10..]
13:40:14 <lambdabot>   [10,11,12,13,14,15,16,17,18,19]
13:40:14 <Twey> S_J: No; use the Data.List.Split package
13:40:40 <Twey> S_J: There's break, but that works only on functions on characters
13:40:42 <Twey> :t break
13:40:43 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:40:53 <Twey> :t break isUpper
13:40:54 <applicative> cabal install split , S_J though it comes with the haskell platform
13:40:54 <lambdabot> [Char] -> ([Char], [Char])
13:41:11 <Twey> Oh, is split with the Platform?  That's cool
13:49:12 <quchen> Twey: Since the last 2012 platform I think
13:50:21 * hackagebot restricted-workers 0.1.0 - Running worker processes under system resource restrictions  http://hackage.haskell.org/package/restricted-workers-0.1.0 (DaniilFrumin)
13:55:41 <S_J> when I print I get: "\"32\")" , How do I just print 32 ?
13:56:19 <S_J> and How do I just generate an empty line in the prompt?
13:56:31 <danharaj> > print "32"
13:56:32 <pentace> use putStrLn
13:56:32 <lambdabot>   <IO ()>
13:56:38 <danharaj> yes what he said
13:56:45 <S_J> @type putStrLn
13:56:46 <lambdabot> String -> IO ()
13:56:51 <danharaj> he/she
13:56:51 <S_J> @type print
13:56:52 <lambdabot> Show a => a -> IO ()
13:57:17 <pentace> > show "32"
13:57:18 <lambdabot>   "\"32\""
14:06:08 <S_J> damn it, I have a list of items, I want to print them one at a time to the command prompt. how do I do that with the type IO () and not [IO ()] ?
14:06:45 <apples> mapM_ ?
14:07:10 <thoughtpolice> :t sequence
14:07:10 <lambdabot> Monad m => [m a] -> m [a]
14:07:15 <thoughtpolice> @source mapM_
14:07:15 <lambdabot> Unknown command, try @list
14:07:21 <thoughtpolice> @src mapM
14:07:21 <lambdabot> mapM f as = sequence (map f as)
14:07:23 <Fuuzetsu> I told you to mapM_ it wayy up
14:11:21 <zomg> S_J: it's usually helpful to look at the functions in Control.Monad when dealing with IO or other monad related issues
14:11:27 <zomg> (you can find them in hackage)
14:18:18 * danharaj wish he knew you can build ghc with multiple cores the first time he did it
14:18:49 <joelteon> nice
14:21:51 <S_J> can you unstring something? ""hello""->"hello" ?
14:22:28 <pentace> > read "\"unstringed\"" :: String
14:22:28 <lambdabot>   "unstringed"
14:24:46 <joelteon> @pl f x = drop 1 (take (length x - 1) x)
14:24:49 <lambdabot> f = fix (const (drop 1 . ap (take . flip ((-) . length) 1) id))
14:24:49 <lambdabot> optimization suspended, use @pl-resume to continue.
14:25:52 <pentace> > tail . init $ "<Hello>"
14:25:53 <lambdabot>   "Hello"
14:26:12 <quchen> S_J: What you want is deleting '"'.
14:26:32 <joelteon> oh right, init
14:26:34 <joelteon> heh
14:27:20 <danharaj> edwardk: do you have anything awesome to explain to me while I wait for ghc to build? :P
14:27:39 <edwardk> hah
14:27:45 <quchen> joelteon: Careful, init crashes on empty input.
14:27:49 <alex20032> carter: Hey
14:27:55 <danharaj> edwardk: actually I'd like to know if you've github'd your hex natural numbers.
14:28:00 <edwardk> working on https://github.com/ekmett/sparse
14:28:02 <danharaj> Since I want to play with type level finite sets atm.
14:28:05 <alex20032> what is the channel for normal speaking?
14:28:11 <edwardk> @hackage type-int
14:28:11 <lambdabot> http://hackage.haskell.org/package/type-int
14:28:12 <Fuuzetsu> haskell-blah
14:28:21 <danharaj> edwardk: cheers!
14:28:22 <edwardk> http://hackage.haskell.org/packages/archive/type-int/0.5.0.2/doc/html/Data-Type-Hex.html
14:28:35 <Taneb> danharaj, be careful, he'll give you commit rights to a dozen of his packages if you pry too much!
14:28:50 <edwardk> the instance lists like http://hackage.haskell.org/packages/archive/type-int/0.5.0.2/doc/html/Data-Type-Hex-Stage2.html aren't for the faint of heart ;)
14:28:50 <danharaj> jokes on him, I don't contribute to anything.
14:29:01 <danharaj> edwardk: I take it this doesn't use the singletons library machinery.
14:29:12 <edwardk> this predated it by like 6 years
14:29:14 <danharaj> oh
14:29:16 <notdan> edwardk: hi! I wanted to ask you, while you are online, about some stuff in the recursion-schemes package. I don't understand what is Mu and how it is related to the fixed point of functors
14:29:20 <S_J> @type init
14:29:20 <lambdabot> [a] -> [a]
14:29:41 <edwardk> notdan: oh, how i distinguish between Fix, Mu and Nu?
14:29:46 <notdan> yes
14:29:55 <edwardk> they are all interconvertible in Haskell, but not in theory
14:29:57 <notdan> I understand the Fix very well, it's similar to regular fix
14:30:16 <edwardk> there exist categories for which they don't coincide, so it is useful to keep Mu and Nu separate in your head
14:30:42 <edwardk> basically its about whether its the least or greatest fixed point of the functor.
14:30:55 <edwardk> in haskell those are the same, so we can get away with calling it Fix (or Mu as is often done)
14:31:47 <edwardk> but in general you can _consume_ values of type Mu with a catamorphism, and produce values of type Nu, Mu is often 'smaller' than Nu, so that means that you can't always cata away what you ana'd up.
14:31:59 <edwardk> in Haskell, again, you can.
14:32:06 <edwardk> but when you look at the definition of cata
14:32:17 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a   -- right?
14:32:20 <notdan> Sorry, I completely fail to see how is Mu equivalent to Fix in Haskell
14:32:29 <edwardk> thats the usual definition
14:32:31 <edwardk> lets just start there
14:32:33 <notdan> I even have no idea how to construct values of type Mu f for my functor
14:32:44 <edwardk> notdan: don't worry i'll show you =)
14:32:57 <Fuuzetsu> you should worry now
14:32:58 <Zenol> Did someone used HDBC with PostgreSQL to write "bytea" fields with ByteString ?
14:33:09 <startling> are "cata" and "ana" named after the four-dimensional directions or do they have a common ancestor?
14:33:24 <danharaj> greek roots
14:33:27 <edwardk> cata f = f . fmap (cata f) . out  -- for the traditional newtype Mu f = In { out :: f (Mu f) }  -- that I call Fix in recursion-schemes
14:33:51 <edwardk> startling: they are so-named because lambert meertens fetishized greek/latin ;)
14:34:10 <edwardk> notdan: but lets just look at the signature
14:34:18 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a    -- and flip it
14:34:28 <danharaj> edwardk: I can't read these docs. Where is an efficient encoding of nats in this library or elsewhere :P
14:34:33 <edwardk> Mu f -> (forall a. Functor f => (f a -> a) -> a)
14:34:34 <danharaj> I'll translate it to singletons myself.
14:34:46 <startling> edwardk, darn, I was hoping someone was going to say there's a correspondence between Mu and four-dimensional spaces
14:34:58 <edwardk> the content of that right hand side is the definition of Mu in recursion-schemes!
14:35:13 <edwardk> its a common trick I use. take the law and just use it as the definition
14:35:30 <joelteon> what if the law isn't written
14:35:35 <joelteon> what do you do then, punk
14:35:36 <notdan> wait, which law is that?
14:36:01 <edwardk> that is the signature of catamorphism, Mu f comes about from the diagram of cata
14:36:34 <notdan> what exactly do you refer to as law in this case?
14:36:37 <notdan> law == signature?
14:37:08 <edwardk> you can take the right hand side which lets you pick any 'a', so when you pick a = Fix f , then that is a function from f (Fix f) -> Fix f   -- which is just 'In'
14:37:39 <edwardk> notdan: technically what i'm referring to is the 'universal property' involved here.
14:37:44 <edwardk> that is a googleable term
14:37:46 <cdk> @unmtl ReaderT r (StateT s) (Either a p)
14:37:47 <lambdabot> r -> (StateT s) (Either a p)
14:37:54 <cdk> @unmtl ReaderT r (State s) (Either a p)
14:37:54 <lambdabot> r -> (State s) (Either a p)
14:38:12 <notdan> Ah, the law that catamorphism exists for every F-algebra for that functor?
14:38:19 <edwardk> my point here is that Mu f is the type you get when you take the definition of a least fixed point and just write it down.    Fix f is the common translation
14:38:21 <notdan> (and it's unique)
14:38:21 <edwardk> yes
14:38:40 <edwardk> Mu f and (Fix f as a least fixed point) are isomorphic
14:38:57 <edwardk> the isomorphism follows from the universal property. Fix f wouldn't be a least fixed point if they weren't
14:39:20 <edwardk> it is an interesting exercise to write code to translate back and forth between Mu f and Fix f.
14:39:26 <danharaj> The fact that Mu f has a cata is usually called Lambek's lemma.
14:39:38 <S_J> > read "\"unstringed\"" :: String
14:39:39 <lambdabot>   "unstringed"
14:39:45 <edwardk> A similar exercise to translate back and forth between (Fix f as greatest fixed point) and (Nu f)
14:39:47 <notdan> fix2mu = flip cata?
14:40:13 <edwardk> and finally you can always translate from Mu f -> Nu f   in any category, but going Nu -> Mu  requires the least and greatest fixed points to coincide, which they do in haskell, but don't in say, agda.
14:40:50 <edwardk> the fact that Fix f is common ground is just a convenience made possible by our host language
14:41:04 <edwardk> but its useful to have the concepts of separate least/greatest fixed points
14:41:13 <edwardk> as they differ if you follow something like my rotten-bananas post
14:41:20 <edwardk> @google rotten bananas comonad
14:41:22 <lambdabot> http://comonad.com/reader/2008/rotten-bananas/
14:41:22 <lambdabot> Title: The Comonad.Reader » Rotten Bananas
14:41:41 <edwardk> there i work in a category where they don't coincide
14:42:09 <edwardk> and so when working with 'bananas in space', you can go from Mu to Nu but not back
14:42:22 <danharaj> comonad is back up?????
14:42:27 <edwardk> kinda
14:42:40 <hpaste> merijn pasted “Code marching to the right” at http://lpaste.net/91760
14:42:41 <edwardk> it is johnw's scraped mirror pasted into a repo on github and hosted there
14:42:44 <danharaj> ah
14:42:45 <edwardk> i can't add content easily
14:42:51 <edwardk> but people can read articles
14:42:59 <edwardk> and the comments are dead
14:43:00 <merijn> Does anyone have any suggestions to make that code less horrifyingly ugly?
14:43:26 <notdan> ok, thanks edwardk, I think I got a basic grip on what's going on
14:43:38 <edwardk> notdan: happy to help
14:45:22 * hackagebot crypto-totp 0.1.0.1 - Provides generation and verification services for time-based one-time keys.  http://hackage.haskell.org/package/crypto-totp-0.1.0.1 (JeffShaw)
14:45:30 <startling> merijn, I've done "case (start < 255, end == 0, majVersion < 3) of ...
14:46:49 <startling> oh, I guess that doesn't work.
14:47:11 <merijn> startling: That's exactly my problem :)
14:47:18 <notdan> edwardk: do you have any thought about recursion schemes for "higher-order functors" as described in the second part of this post: http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html ?
14:47:34 <edwardk> yes. read 'initial algebra semantics are enough'
14:47:43 <edwardk> er 'is'
14:47:43 <briennetheblue> could someone explain why this http://lpaste.net/7040773354717970432 doesn't work?
14:47:47 <briennetheblue> specifically why hangs hangs
14:47:58 <briennetheblue> i feel like it 'should' work and i don't really understand why it doesn't
14:48:06 <S_J> @src init
14:48:06 <lambdabot> init [x]    = []
14:48:06 <lambdabot> init (x:xs) = x : init xs
14:48:06 <lambdabot> init []     = undefined
14:48:14 <edwardk> most of the hacks at the end are implementable now once and for all for the most part due to polykinds. the rest will be implemented as soon as they are unbroken
14:48:16 <S_J> why not jsut init [] = [] ?
14:48:30 <danharaj> edwardk: that paper is only about nested types not gadts as well. same idea though.
14:48:37 <S_J> or init :: [a] -> Maybe [a] ?
14:48:38 <danharaj> I think they both use the same Lan trick to make things nice.
14:49:00 <notdan> thanks!
14:49:21 <edwardk> well, they also have "Foundations for Structured Programming with GADTs"
14:49:24 <edwardk> which does th same trick there
14:49:49 <startling> S_J: the people who wrote the prelude were allergic to Maybe, it seems
14:49:55 <danharaj> alas, not one for mixed variant datatypes
14:50:02 <arkeet> briennetheblue: does this not hang? [[a], b, ~[c]] = splitAts [1, a, 1] [2..5]
14:50:16 <edwardk> and the HFunctor vocabulary seems to indicate the author there at least read those papers
14:50:21 <DMcGill__> briennetheblue: the problem is `init (x:xs) = x : init xs'
14:50:29 <DMcGill__> you append the x to the front
14:50:34 <danharaj> edwardk: They cite Johann and Ghani at the end so I hope so.
14:50:37 <DMcGill__> whereas you really just want to call it recursively
14:50:37 <arkeet> DMcGill__: ???
14:50:41 <edwardk> heh fair enough
14:50:42 <hpaste> quchen annotated “Code marching to the right” with “merijn” at http://lpaste.net/91760#a91761
14:50:55 <danharaj> edwardk: Do you know of a 'state of the art' update of Bananas in Space?
14:50:55 <DMcGill__> oooh
14:50:56 <DMcGill__> I'm stupid
14:51:01 <edwardk> woot. i just realized i don't need to store the dimensions of my matrices!
14:51:02 <DMcGill__> incredibly
14:51:05 <danharaj> One that uses the Johann Ghani machinery to get folds and builds.
14:51:27 <edwardk> danharaj: see the rotten bananas post that links to weirich and washburn
14:51:31 <edwardk> h
14:51:32 <edwardk> no
14:51:33 <danharaj> edwardk: How do you stand the fact that you can't force GHC to align for numerical data in memory for cache deliciousness.
14:51:34 <quchen> merijn: That's at least my 1-minute-linting. Most of the variables you bind with <- are only used in a very small scope, so it's really easy to break code in half
14:51:38 <edwardk> nobody has bothered that i know of
14:51:42 <briennetheblue> thanks arkeet that does seem to work
14:51:49 <arkeet> briennetheblue: right.
14:51:50 <arkeet> that's because
14:51:53 <quchen> merijn: That plus more descriptive names than "else1" :-P
14:51:58 <merijn> :p
14:52:04 <briennetheblue> i thought the patterns in let were always irrefutable though, isn't that what ~ does?
14:52:11 <edwardk> danharaj: its all packed array stuff anyways, so i can align it as i will ;)
14:52:17 <S_J> is there anything mathematically wrong with init [] = [] ?
14:52:19 <merijn> briennetheblue: They're not always irrefutable
14:52:25 <quchen> S_J: No.
14:52:26 <edwardk> its sparse arrays packed using vectors
14:52:27 <arkeet> S_J: that's called "drop 1"
14:52:36 <danharaj> edwardk: ah but can you get GHC to output aligned SSE loads :P
14:52:41 <quchen> arkeet: No, init drops the last element.
14:52:44 <merijn> > let ~(Just x) = Nothing in 1
14:52:45 <lambdabot>   1
14:52:45 <arkeet> oh right.
14:52:47 <arkeet> dropFromEnd 1
14:52:48 <arkeet> =)
14:52:48 <merijn> > let (Just x) = Nothing in 1
14:52:49 <lambdabot>   1
14:52:53 <merijn> oh, the
14:52:56 <merijn> eh, duh
14:53:03 <edwardk> i'll wait for the geoffrey mainland stuff to go in for all that, and just hope for vector picking up the new composite stream fusion
14:53:04 <danharaj> oh it's sparse
14:53:16 <quchen> arkeet: Yes, which is easily implemented in terms of init, which errors completely arbitrarily on [] for whatever reason (I guess consistency with other crashy functions)
14:53:22 <arkeet> briennetheblue: the thing is that it's trying to match [c] too early.
14:53:27 <edwardk> sparse morton ordered matrices
14:53:40 <danharaj> edwardk: Can you explain how the HRC stuff from the Intel people blows GHC out of the water in so many benchmarks?
14:53:47 <danharaj> It made me feel inadequate :P
14:53:47 <arkeet> i.e. before it figures out a value for a
14:54:15 <edwardk> haven't gone into it in depth, but i suspect there is a fair bit of low hanging fruit given that they are whole-program optimizing
14:54:24 <briennetheblue> ok, i think i understand
14:54:28 <danharaj> I thought GHC does whole-program optimization
14:54:43 <edwardk> even my little tracing jit story can take massive advantage of that
14:54:43 <quchen> edwardk: I've also heard GHC doesn't do much low-level bit-shift magic, could that be a factor?
14:54:45 <briennetheblue> i just thought that's how patterns in a let always worked
14:54:52 <edwardk> quchen: probably
14:55:20 <arkeet> briennetheblue: only the whole pattern.
14:55:31 <edwardk> think of it this way, to evaluate an unknown unevaluated thunk in the STG requires two completely blind jumps, which means pipelines stall all the damn time
14:55:34 <briennetheblue> aha
14:55:49 <danharaj> oh gross I thought x86-64 could preload jumps
14:55:50 <briennetheblue> thanks arkeet :)
14:55:54 <edwardk> now, using dynamic pointer tagging cut out about 70% of that overhead, because we now rarely jump in blindly
14:56:05 <edwardk> danharaj: the issue is its an indirect jump
14:56:08 <edwardk> so they tend to suck
14:56:49 <danharaj> hmm
14:56:56 <edwardk> in a closed world you can know 'all the thunks for making a list used in this program' and can play games like jhc does specializing the evaluator to that
14:57:04 <edwardk> this is what supero did basically
14:57:10 <danharaj> supero?
14:57:27 <edwardk> ghc only does incremental compilation, it doesn't do a whole-program optimization pass once it has all the pieces
14:57:40 <edwardk> ndm's project
14:57:51 <edwardk> @google supero haskell
14:57:51 <lambdabot> http://community.haskell.org/~ndm/supero/
14:57:52 <lambdabot> Title: Neil Mitchell - Supero
14:58:15 <danharaj> is that based on the supercompilation work
14:58:18 <edwardk> yes
14:58:43 <edwardk> anyways, my point is, if you have the whole program, not just what you've seen so far, then you can do a lot more stuff to it
14:58:54 <danharaj> indeed
14:59:12 <edwardk> the ways to get that are to either be a whole program optimizing compiler like jhc/hrc or to be a jit like my work there or nominolo's
14:59:21 <danharaj> is ermine jitted?
14:59:27 <edwardk> no
14:59:32 <edwardk> ermine does the dumbest thing that can work
14:59:40 <danharaj> compile to STG
14:59:43 <danharaj> and then have GHC do the rest
14:59:43 <edwardk> it compiles to a simple core, then we have an interpreter for it
14:59:46 <danharaj> ah
14:59:46 <edwardk> not even stg
14:59:49 <edwardk> it has to run on the JVM
14:59:53 <danharaj> oh right yes
14:59:54 <danharaj> indeed.
15:00:14 * danharaj is surprised no one ever implemented the STG machine in java as a master's thesis or something
15:00:15 <edwardk> ermine core: http://comonad.com/ermine/Ermine-Syntax-Core.html
15:00:44 <edwardk> thats a little bit out of date, but close enough
15:01:00 <danharaj> HardCore. Good data name.
15:01:05 <edwardk> =)
15:01:24 <edwardk> HardCore are the Core terms that can be unified with structural equality
15:02:05 <edwardk> and yeah, the name was what prompted it. now by symmetry we have HardType HardKind, etc. but they aren't as awesome sounding
15:02:27 <danharaj> HardKandy
15:02:47 <edwardk> it originally popped up because it was all the stuff i could make Core[Nothing] in scala and provide default map implementations, etc.
15:03:06 <edwardk> so we had a lot of constructors be HardCore to simplify unifiers, etc.
15:03:22 <Hafydd> Hahah, HardCore.
15:03:25 <danharaj> edwad	
15:03:27 <danharaj> wow
15:03:33 <danharaj> good autocomplete
15:03:38 <oleo> 
15:03:53 <danharaj> edwardk: so does martin odersky have to worry about ermine obsoleting scala? :P
15:04:12 <edwardk> if dibblego has his way, maybe ;
15:04:46 <danharaj> ruthlessness is a good substitute for motivation
15:04:51 <edwardk> in practice its just something we can run on the jvm, expose to end users, is haskell like, that can talk to databases, and where we're not constantly obsessed with the damn java stack or leaking permgen space
15:05:22 * hackagebot uid 0.1.0.0 - Simple unique identifier datatype, serializable and encodable as base32  http://hackage.haskell.org/package/uid-0.1.0.0 (PhilHargett)
15:05:35 <edwardk> had there been a viable alternative when we started it, we might well have just used someone else's compiler
15:06:06 <seanparsons> Well the perm gen problem gets more complicated with Java 8.
15:06:18 <danharaj> edwardk: if ermine were mature about a year ago it may have ended up being in our tech stack :P
15:06:28 <danharaj> talking to databases is something Haskell is terrible at
15:06:35 <edwardk> if it was mature today, we'd use it in more of ours ;)
15:06:39 <danharaj> hehe
15:07:27 <edwardk> we're getting a lot of time to hack on it for the next couple of weeks, so hopefully we can get the haskell compiler into better shape
15:07:34 <danharaj> cool
15:08:12 <danharaj> My project for weekends is currently playing with category theory to find hella nice intermediate representations for languages like Core and STG.
15:08:30 <edwardk> sounds good. let me know when it works =)
15:08:40 <danharaj> edwardk: I could read that as encouraging or snarky ;)
15:08:46 <edwardk> seanparsons: well, we avoid it for now by interpreting
15:08:55 <edwardk> danharaj: can't it be both? =)
15:09:05 <danharaj> My first goal is at least well defined: get a representation of terms in context where unification is structurally recursive.
15:09:10 <danharaj> edwardk: yes, yes it can :P
15:09:31 <danharaj> I should asterisk that with *in haskell* because I know Conor McBride has a representation in Agda or something.
15:09:32 <seanparsons> Just reading up on ermine properly now.
15:10:00 <edwardk> seanparsons: there is a video runar captured and an #ermine channel of folks who are interested
15:10:10 <edwardk> http://www.youtube.com/watch?v=QCvXlOCBe5A
15:10:13 <danharaj> that video is a bit difficult to follow because it starts in media res
15:10:25 <Saizan> danharaj: with or without binders in the syntax?
15:10:27 <edwardk> sorry bout that. we didn't know runar was going to record
15:10:33 <danharaj> Saizan: with binders
15:10:35 <djahandarie> Is that a recording of the Boston Haskell presentation?
15:10:35 <edwardk> he just started up when it was obvious it was going to be interesting
15:10:39 <edwardk> yeah
15:10:53 <danharaj> edwardk: well he picked the absolute latest moment because the first sentence is quite interesting :P
15:10:55 <edwardk> we pretty much winged it
15:11:05 <Saizan> danharaj: ah, conor's without
15:11:11 <danharaj> oh
15:11:14 <danharaj> I was not aware.
15:11:14 <seanparsons> edwardk: "Watch later" punched for that one.
15:11:40 <danharaj> Saizan: I am hoping that Adam Gundry's thesis with its rather careful explanation of unification and partial type inference will serve as an illuminating guide in any case.
15:12:00 <edwardk> i mentioned there was a boston haskell the next night to josh, and asked in the same snarky but serious tone if he wanted to do a presentation.. and he said yes
15:12:33 <edwardk> so he rushed off and wrote all that erminecraft code over night at home and dan slapped together a little database demo
15:12:45 <djahandarie> Oh, speaking of which, there's another Boston Haskell this Wednesday isn't there.
15:12:46 <edwardk> and i stood up and did the MC thing to tie it together
15:13:04 <edwardk> third wednesday, so it'd be the 21st
15:13:39 <edwardk> I'm planning to do a more coherent (i hope) presentation on it at CUFP this year
15:13:51 <danharaj> I may be there to ask snarky questions
15:14:51 <djahandarie> Oh. Right. Can't read calendars.
15:15:18 <Saizan> danharaj: if you read agda this https://github.com/Saizan/miller could be interesting too, it's only code though
15:15:22 <derekv> How do I read "data Rank = N N | Face Face" , given N is "data N = Two | Three | Four " etc... and Face is "data Face = Jack | Queen | King | Ace"
15:15:38 <Peaker> anyone knows what's going on in http://www.techempower.com/benchmarks/ and why Haskell/yesod is showing poor performance?
15:15:55 <derekv> confused only by the "N N" and "Face Face"
15:16:11 <danharaj> Saizan: cool. I am not privy to higher order unification very much yet though.
15:16:39 <Saizan> derekv: types and values live in separate namespaces
15:16:41 <edwardk> derekv: data Foo = Bar Baz | Quux Quaffle..  -- lets start there
15:16:46 <danharaj> So I'll mostly be reading the papers you cite for a while.
15:17:04 <edwardk> the Bar and Quux there are 'values' -- they are data constructors that take arguments of type Baz and Quaffle respectively
15:17:25 <edwardk> here N is a data constructor that takes a value of type N
15:17:44 <edwardk> we often 'pun' the data constructor for a given type. data Foo a = Foo Int a  -- or something, but we don't have to
15:17:49 <danharaj> Saizan: I may have misunderstood your question about binders in the language over which unification is being done though. Could you elaborate on that?
15:18:11 <edwardk> data Literal = Int Int | Double Double  -- works because there is no data constructor named Int or Double in scope
15:18:29 <edwardk> so now you can have Int 2   or Double 4.0   as 'Literal's
15:18:54 <edwardk> in your Rank case it can be N Two, Face Jack, etc.
15:19:21 <edwardk> this is clearer when you use the other syntax for data.
15:19:35 <edwardk> data Rank where N :: N -> Rank; Face :: Face -> Rank
15:19:53 <Saizan> danharaj: i mentioned the higher-order unification stuff mostly because iiuc Gundry's thesis is about that one
15:19:58 <arkeet> I like how GADT syntax actually makes sense.
15:19:59 <edwardk> with the usual data Rank = … syntax the data constructors and the argument types all get jumbled together
15:20:23 * hackagebot uid 0.1.0.1 - Simple unique identifier datatype, serializable and encodable as base32  http://hackage.haskell.org/package/uid-0.1.0.1 (PhilHargett)
15:20:33 <edwardk> arkeet: so do i, but i like the concision of the traditional data syntax
15:20:33 <Saizan> danharaj: but yeah, i wanted to also ask what equivalence you want to use for your unification, just alpha-equiv, nothing like beta/eta?
15:20:48 <arkeet> of course.
15:20:57 <arkeet> I didn't know concision was a word.
15:21:40 <danharaj> Saizan: Well for starters I wanted to implement Algorithm W.
15:22:10 <danharaj> Since that is the kind of unification I most understand.
15:22:57 <Saizan> danharaj: ah, there you carefully avoid the binders in the object language, though of course unification variables are existentials in the meta
15:23:19 <Saizan> so yeah, conor's paper on first-order unification would fit
15:23:48 <danharaj> Saizan: Right but the only reason why I'm not thinking about more complicated schemes is because I am not familiar with a language that requires higher order unification. Eventually I would like to play with one.
15:24:07 <danharaj> My knowledge of unification is horribly spotty and mostly based on what I need to know in order to satisfy GHC's type errors ;)
15:24:39 <hpaste> sj pasted “Can this be cleaner?” at http://lpaste.net/91763
15:24:57 <S_J> ^^ Is it possible to clean this up?
15:25:11 <Saizan> danharaj: cool :)
15:25:17 <carter> edwardk I have an interleaver
15:25:19 <carter> do you still want it
15:25:22 <Fuuzetsu> S_J: well, to begin with I'd move the lines after case foo of UNDER the case to ease up on whitespace
15:25:42 <danharaj> Saizan: If you know of a nice treatment of unification that gets progressively elaborate I would enjoy it.
15:27:57 <arkeet> there's probably some way to make it prettier with EitherT or ContT or something.
15:28:20 <arkeet> but Fuuzetsu's suggestion is good.
15:32:27 <Zenol> Ok, I nead to convert something like "\\x7aecf2a2a7" in a bytestring to something like "z\236\242\162\167". Are they a standard way to do it?
15:33:36 <meretrix> >
15:35:11 <Peaker> S_J, don't let your code run off to the right of the screen, use some fixed indent instead
15:36:10 <Peaker> S_J, the type returned by executeRequest can probably be improved to help clean the code up
15:36:41 <edwardk> i had to rederive it anyways. now that i worked out the constants for a second time, switching between the BRISC version or the basic one is easy ;)
15:38:43 <Saizan> danharaj: i can't say that i've seen one, and some of the original papers come from the logic programming community
15:39:11 <joelteon> Zenol: i don't understand the format of the first string
15:39:18 <Saizan> though first-order unification is a standard topic of prolog textbooks :)
15:39:26 <hpaste> Peaker annotated “Can this be cleaner?” with “Can this be cleaner? (annotation)” at http://lpaste.net/91763#a91764
15:39:38 <Peaker> S_J, ^^
15:39:45 <Zenol> joelteon: It's hexadecimal value of each 'char' (0->255), prefixed by \x.
15:39:53 <Zenol> joelteon: 7a = z for example.
15:39:54 <joelteon> Zenol: i only see one \x
15:40:22 <joelteon> you want to convert 7aecf2a2a7?
15:40:30 <Zenol> yes
15:40:32 <joelteon> that shouldn't be too tough, there's a readHex somewhere, I think in Numeric
15:40:40 <joelteon> you just split the list into two-character chunks and map readHex
15:40:47 <Fuuzetsu> IIRC you need -package ghc but I'm unsure
15:40:54 <Zenol> joealteon: Ah, readHex, thanks :)
15:40:55 <joelteon> :t readHex
15:40:56 <lambdabot> (Eq a, Num a) => ReadS a
15:40:57 <Fuuzetsu> (yes it's in Numeric)
15:41:01 <joelteon> > readHex "7a"
15:41:02 <lambdabot>   [(122,"")]
15:41:32 <danharaj> Saizan: hehe. well I'm glad Adam Gundry published his thesis. When I skimmed that section it seemed like it was quite a good treatment of unification w.r.t. type inference.
15:41:33 <joelteon> :t chunksOf
15:41:34 <lambdabot> Int -> [e] -> [[e]]
15:41:36 <joelteon> neat
15:41:40 <joelteon> Zenol: here's what I'd do
15:42:53 <joelteon> @let fromHex s = map (ord . fst) $ readHex =<< chunksOf 2 s
15:42:53 <lambdabot>  .L.hs:145:31:
15:42:54 <lambdabot>      No instance for (Num Char) arising from a use of `readHex...
15:43:01 <joelteon> @let fromHex s = map (chr . fst) $ readHex =<< chunksOf 2 s
15:43:02 <lambdabot>  Defined.
15:43:05 <joelteon> > fromHex "7aec"
15:43:09 <lambdabot>   mueval-core: Time limit exceeded
15:43:17 <joelteon> ok, well, point is, that should work
15:43:57 <joelteon> Zenol: ^
15:44:45 <Philippa> danharaj: *nod* the whole "in context" thing is nice in general and there's piles more good stuff in there
15:46:06 <Saizan> danharaj: you keep reminding me i have lots of stuff to read!
15:46:24 <danharaj> Saizan: There is always more to read!
15:46:33 <scooty-puff> is there a Cofree'ish function to transform the `f` type to some `g`, something like (f <something> -> g <something>) -> Cofree f a -> Cofree g a?
15:46:55 <scooty-puff> or a type class representing this type of transform?
15:48:18 <scooty-puff> its coming up when transforming a location-annotated syntax tree
15:48:23 <Saizan> if HFunctor was standard you'd have hfmap :: (forall a. f a -> g a) -> forall a. Cofree f a -> Cofree g a
15:48:35 <Saizan> for HFunctor Cofree
15:49:40 <scooty-puff> k - that looks like its just what i need
15:51:17 <merijn> \o/
15:51:33 <Zenol> joelteon: Are they a Int -> Word8 instead of chr? :)
15:51:42 <joelteon> Zenol: fromIntegral
15:51:44 <merijn> The first interoperation message between my haskell implementation and ZMQ has finally succeeded :)
15:51:47 <joelteon> :t fromIntegral
15:51:48 <lambdabot> (Integral a, Num b) => a -> b
15:51:51 <Peaker> Saizan, Maybe Functor1, like Typeable1, etc?
15:52:13 <danharaj> Better to use polykinds to do it once and for all.
15:52:30 <danharaj> and grab some fmaps for non-endofunctors while we're at it
15:53:41 <Peaker> danharaj, how do you use polykinds to generalize fmap to hfmap?
15:54:13 <danharaj> You may have to use type families as well
15:55:51 <scooty-puff> does HFunctor go by another name outside of category-extras?
15:56:16 <edwardk> scooty-puff: IFunctor in the unreleased indexed package on my github account, and i think its in index-core
15:58:16 <S_J> can someone explain the difference between overloading and parasmetric polymorphism to me?
15:59:01 <merijn> S_J: overloading has different behaviour depending on the types
15:59:20 <merijn> S_J: parametric polymorphism always executes the same code, regardless of argument types
15:59:51 <merijn> S_J: Take "id :: a -> a" there is only one implementation of id, it uses the exact same code for all types
16:00:05 <S_J> yes i know now, i consulted wikipedia, should have done that ebfore asking :)
16:00:10 <merijn> S_J: Overloading is more like defining "id :: Int -> Int", etc.
16:00:23 <S_J> typeclasses->overloading
16:00:25 <Zenol> joelteon: Ah, thanks, I solved my issue with HDBC.PostgreSQL thanks to your help :D
16:01:23 <S_J> in C++ templates are parametric polymorphism and double add1(double d); and int add1(int i); are overloading...?
16:01:40 <merijn> S_J: Yes
16:01:55 <joelteon> Zenol: yaaay
16:02:51 <ciaranm> c++ templates aren't exactly parametric polymorphism
16:03:14 <merijn> ciaranm: hmm, true
16:03:19 <ciaranm> templates don't execute "the same code" in any reasonable sense
16:04:21 <S_J> hmm, well you write one function for it...
16:04:30 <S_J> to the programmer it is the same...
16:04:33 <Peaker> ciaranm, what if you ignore template specializations?
16:04:35 <ciaranm> which does completely different things!
16:04:51 <ciaranm> Peaker: it can still vary using overloading
16:05:18 <Peaker> ciaranm, that's a bit similar to varying due to type-classes
16:05:43 <ciaranm> mmmmmmmmmm. typeclasses are supposed to do "the same thing"
16:11:38 <Peaker> ciaranm, so are overloads
16:11:58 <yyyyy> if i'm using 'type' instead of 'data' and all my types have the same underlying type, why can't i declare multiple instances? (i'm using TypeSynonymInstances, FlexibleInstances and MultiParamTypeClasses, the last due to the types having instances for Data.Convertible)
16:11:58 <ciaranm> Peaker: not at all
16:12:32 <Peaker> ciaranm, well, that's a matter of style/convention more than language
16:13:33 <yyyyy> my goal is to mapM safeConvert on a query from HDBC, using the type classes instances as the transformers+validators for data. this is meant to be a quick and dirty etl.
16:13:42 <mauke> yyyyy: 'type' doesn't create new types
16:13:57 <mauke> it just gives new names to existing types
16:14:53 <yyyyy> mauke: i know, but i thought the language extensions would be enough to disambiguate.
16:15:20 <yyyyy> mauke: what do you recommend in this case?
16:15:27 <NemesisD> is it possible to define a datatype that restricts one of its members to a typeclass?
16:15:47 <byorgey> NemesisD: no
16:16:04 <danharaj> byorgey: not even with GADTs? I am not sure I understand the question.
16:16:06 <applicative> yyyyy: you mean you want different instances for the type according to what you call it??
16:16:10 <NemesisD> data Foo = Foo { bar :: Typeable a => a } or something? i thought there was an extension that did this
16:16:34 <byorgey> oh, I misunderstood the question.  Yes, you can do that with GADTs.
16:16:54 <byorgey> data Foo where  Foo :: Typeable a => a -> Foo
16:17:32 <byorgey> I thought the question was about something like   data Typeable a => Foo a where ...
16:18:04 <NemesisD> hmm, not sure what the distinction is there
16:18:39 <NemesisD> byorgey: with GADTs could i still have field names for my Foo
16:18:54 <byorgey> NemesisD: yes, I think so.  Not sure what the right syntax is off the top of my head.
16:18:54 <yyyyy> applicative: yes. i knew it was impossible without the extensions, but i thought they gave a way to match against the 'aliased type' - assuming the compiler kept a distinction up to the call.
16:20:01 <applicative> yyyyy: yes, I see; thats kind of what newtype is, though obviously it's more labor than you wanted
16:21:12 <NemesisD> hmm, yeah most tutorials i'm finding on GADTs are focused on ADTs without field names
16:21:43 <danharaj> edwardk: Is there a way to fake let bindings at the type level? I'm playing with closed type families :P
16:22:37 <Peaker> danharaj, (a ~ Int) => ... ?
16:23:01 <danharaj> Peaker: Can you have constraints in closed type family equations?
16:23:04 <NemesisD> maybe GADTs are too heavy handed
16:23:12 <danharaj> Also that would be more like pattern matching than let binding.
16:23:27 <danharaj> although I guess you could just do (a ~ whatever you are binding)
16:23:30 <Peaker> danharaj, I don't know
16:23:45 <danharaj> I would check, but GHC head hasn't finished compiling for me yet so going out on a gamble is dangerous.
16:25:01 <merijn> byorgey: That's not true, you can do it in 7.7! :)
16:25:17 <merijn> NemesisD: You can, using GADTs + type families, but whether you would want to is an open question
16:25:30 <merijn> NemesisD: Also, it only works in >7.7
16:25:34 <NemesisD> i'm trying to define a datatype for a log context like data LogCtx = LogCtx { ctxName :: ToLogStr a => a }, the reason being is because i have a function like writeLog :: ToLogStr a => ReaderT LogCtx m a
16:25:38 <scooty-puff> is it possible to use Cofree when using two structures to represent a syntax tree?  What i have now is something like Mono f a = Var a | f (Mono f a) :-> f (Mono f a); data Poly f a = Mono (Mono f a) | Forall ... (Poly f a)
16:26:13 <NemesisD> merijn: i want to prepend the ctxName to the ToLogStr a passed in, but LogStr itself has no monoid instance
16:26:22 <yyyyy> applicative: well, only as far as getting data in there from the HDBC call, but i suppose that's a quite cheap price to pay for the added type safety
16:26:42 <merijn> NemesisD: Why not convert the a into a log string before hand?
16:27:27 <NemesisD> so i'd like to do something like toLogStr $ mconcat [ logName, " ", userSupplied], but logName and userSupplied aren't necessarily the same type, they just are part of ToLogStr typclass
16:27:50 <derekv> edwardk: sorry, i got distracted and had to go afk.. thank you for explaining that makes it much clearer
16:28:11 <NemesisD> merijn: there isn't a monoid instance of LogStr, so i'd have to case of its internal structure and munge them together myself
16:28:16 <Peaker> NemesisD, just apply the method to them first?
16:28:23 <identity> excellent. want to get more comfortable using monad-par but wind up dealing with cabal hell
16:28:25 <merijn> NemesisD: If userSupplied and logName aren't the same type, then "[ logName, " ", userSupplied]" is a type error
16:28:30 <identity> what a way to spend the night
16:28:30 <Peaker> e.g: [show x, show y] when x/y are different types?
16:28:46 <Saizan> scooty-puff: you could try indexing the shape functor by a data Kind = Poly | Mono datakind
16:29:31 <NemesisD> man this is a disaster waiting to happen
16:29:46 <NemesisD> i think it might be easier to just to force all log strings to be Text within my app
16:29:49 <scooty-puff> that could actually be more convenient elsewhere, too
16:30:13 <Saizan> though i guess you want to control what kind the recursive case is
16:30:52 <Saizan> so you might need to have an indexed version of cofree too for this to work..
16:34:26 <S_J> Operations on a type restricted to that type vs type separated from the operations on it. The latter obv seems freer. Why choose the first option...?
16:36:00 <Peaker> S_J, you can only "separate" in very specific cases -- when the type appears as one of the arguments, iiuc
16:41:42 <edwardk> derekv: happy to help
16:46:06 <slack1256> What is the minimal setup for :make and :compiler work with ghc in vim?
16:49:12 <S_J> Peaker: I meant like in OO you have a type/class and the operatiosn are tied to it. Why not separate type and operations like in Haskell... The more I use Haskell object orientation just seems, well, idiotic...
16:50:09 <Philippa> S_J: do you understand Smalltalk?
16:50:46 <Philippa> (not that Smalltalk has types per se - but then, we took a long time to work out how to add them to Prolog too)
16:51:39 <S_J> phienone: i just downloaded that whole weird environment to program Smalltalk in and never got anywhere with it, so no unfortuneately.
16:51:54 <S_J> WHat was your point about smalltalk?
16:52:26 <Peaker> S_J, oh. I see.  Yes, the separate operations are much nicer in many ways (e.g: free up covariance/contravariance to work correctly).
16:52:36 <Philippa> for one: it's a notion of OO I'm willing to respect some even if I don't necessarily want to use it
16:52:54 <Peaker> S_J, have you heard of the "Expression Problem"?
16:52:58 <Philippa> for another, the idea in Smalltalk is that each object is effectively its own, separated computer-running-a-program
16:53:54 <Philippa> if you want to pursue that as a model, then within that model you /have/ to talk about what each individual machine understands (just as we do for individual monads or applicatives which have corresponding abstract machines)
16:56:32 <tertl3> hello
16:56:46 <tertl3> i have a paste with error
16:58:07 <geekosaur> @where hpaste
16:58:07 <lambdabot> http://lpaste.net/new/haskell
16:58:29 <geekosaur> also, don't ask to ask, just ask
16:59:18 <hpaste> tertl3 pasted “simple.hs” at http://lpaste.net/91766
17:00:29 <geekosaur> indentation matters in haskell
17:00:56 <tertl3> ok lemme try
17:01:15 <tertl3> i thought it was indentation but I gave up too early
17:01:53 <geekosaur> also you need parentheses around the args!!n expressions
17:02:02 <hpaste> geekosaur annotated “simple.hs” with “simple.hs (annotation)” at http://lpaste.net/91766#a91767
17:02:53 <nooodl> i don't think he needs parens?
17:03:05 <geekosaur> ghci thinks he does...
17:03:08 <nooodl> > let b = ["a"] in b!!0++b!!0
17:03:09 <lambdabot>   "aa"
17:03:32 <geekosaur> oh, no, my quick test was wrong, sorrt
17:04:04 <geekosaur> alternately you could have indented line 5 to start at the same column as "args <- getArgs"
17:06:33 <S_J> > [1,2,3] ++ [4,5,6]
17:06:34 <lambdabot>   [1,2,3,4,5,6]
17:09:56 <S_J> The Expression Problem is a new name for an old problem.[2][3] The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).
17:10:06 <S_J> what does it mean to define a type by cases?
17:12:49 <shachaf> A sum type?
17:12:50 <carter> blah, does anyone know of good website templates for hakyll?
17:13:46 <tertl3> i changed it and get the error: Not in scope: `getArgs'
17:14:31 <shachaf> Do you know what "Not in scope" means?
17:15:02 <tertl3> braodly speaking, yes
17:15:38 <S_J> you need to import System.IO or soemthing
17:15:44 <S_J> @hoogle getArgs
17:15:44 <lambdabot> System.Environment getArgs :: IO [String]
17:15:44 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
17:15:44 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
17:16:14 <S_J> import qualified System.Environment as SE //// SE.getArgs
17:16:48 <briennetheblue> or import System.Environment (getArgs)
17:16:56 <briennetheblue> then you won't have to change your code
17:17:11 <levi> I think that defining by cases, in that context, means that you can define separate distinct sub-types separately in code, but when you bring the code together they all work together as one type.
17:17:57 <levi> Using a sum type would be one way to do that aspect of the overall problem, but it would fail at other points in the problem.
17:19:14 <S_J> f you want to add a 'triangle' shape:
17:19:14 <S_J> the ObjectOrientedProgramming approach makes it easy (because you can simply create a new class)
17:19:14 <S_J> but FunctionalProgramming makes it difficult (because you'll need to edit every function that accepts a 'Shape' parameter, including 'area')
17:19:41 <levi> The problem is not limited to Haskell and similar languages, though; in the OO-world, you run into the same issue with object hierarchies and the Visitor pattern.
17:19:47 <S_J> well not necessarily...or maybe I do
17:20:07 <S_J> yes i get the problem now, it is interesting.
17:20:20 <S_J> and noone has solved this problem?
17:20:47 <shachaf> It is unsolvable.
17:21:02 <pentace> Isn't that when you use type classes?
17:21:06 <shachaf> Which is why I don't like calling it a problem. It's more of an "expression question" or "expression decision".
17:21:17 <shachaf> It has nothing to do with type classes. Observe:
17:21:34 <shachaf> data Shape = Circle Int Int | Rectangle Int Int
17:21:35 <levi> Well, there are a couple of potential solutions in Haskell, but they're not quite as elegant as the straightforward solutions that run into the expression problem.
17:21:36 <tertl3> geesh that was a circus
17:21:46 <shachaf> data Shape = Shape { area :: Int, perimeter :: Int }
17:21:46 <tertl3> moving on
17:22:11 <briennetheblue> does it work now?
17:23:03 <pentace> shachaf: But when you make Shape a type class the problem is solved, no?
17:25:09 <S_J> levi: how are they solutions to the expression problem if they run into it?
17:25:50 <geekosaur> pentace, no, because that introduces *other* complications
17:25:58 <geekosaur> it doesn't solve it, just moves it around
17:26:05 <shachaf> pentace: No, it's the same as the second data type.
17:27:03 <pentace> What other complications?
17:27:03 <levi> S_J: Sorry, my sentence was hard to parse into what I meant to say.
17:27:04 <S_J> But you could "solve" this by anticipating which way it is most likely needed to be extended, with new functions or new shapes.
17:28:06 <levi> You can choose a representation based on your most likely kind of extension, but that doesn't really solve the problem as stated.
17:29:04 <pentace> The only problem I can see is that you have to make the type or class as general as possible to cover all possible cases you may want to add later
17:29:13 <levi> What I meant as 'solutions' were the approach taken by the "Data types a la carte" paper and the approach taken by the "Finally tagless" paper.
17:30:18 <Philippa> yeah. There comes a stage where some of that complexity is inherent though
17:30:31 * hackagebot courier 0.1.0.4 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.4 (PhilHargett)
17:30:41 <Philippa> you /can't/ have a constant-space general solution, for example
17:31:02 <Philippa> (what you want is a way of quickly clarifying where and how it's bloody obvious)
17:31:04 <levi> The former makes heavy use of advanced type-level stuff, while the latter moves from an initial encoding of the data to a final encoding, which makes some uses of the data more awkward.
17:32:39 <levi> The authors of "Finally tagless" argue that the less straightforward case-handling during interpretation leads to code that is easier to reason about, but I think it makes coming up with the code in the first place a bit harder.
17:33:29 <danharaj> The finally tagless presentation is just church encoding put into a type class so you can stipulate that your representation's church encoding must have the right cases.
17:37:01 <levi> Well, not just 'a type class' but an extendable set of type classes that work together.
17:37:34 <startling> man, haskeline's API is a pain in the ass
17:37:58 <pxqr> startling: why?
17:39:45 <startling> pxqr, it uses this MonadException thing defined in haskeline, so I can't wrap the Input transformer in anything that doesn't have an instance.
17:39:52 <startling> (in other words, everything from mtl)
17:40:16 <derekv> I started with "I want to learn Haskell", and now I'm pretty much finished with LYAH but I ready it without really writing any code.  So I'm pretty much still at "I want to learn Haskell"
17:41:13 <zomg> derekv: time to start writing code then =)
17:41:16 <m3ga> derekv: time to actually write some code
17:42:25 <derekv> welp all the software I want to write is nontrivial so its like, back to more reading
17:43:16 <m3ga> derekv: no its not. carve it into smaller chunks and work on the chunks. figure out hwo to glue it all together later.
17:43:38 <pxqr> nontrivial is composed using trivial blocks, doesn't it?
17:43:40 <briennetheblue> derekv you could try writing solutions to the problems in www.reddit.com/r/dailyprogrammer/ that's what i'm doing :)
17:43:44 <S_J> derekv: what kind of software?
17:43:51 <derekv> i had an idea which I think boils down to a specific type of rule based system
17:44:39 <zomg> What I wanted to write was pretty much nontrivial as well
17:44:46 <startling> derekv, learn lens. :)
17:44:58 <zomg> I just started hacking at it and although it was hard at times I managed to learn stuff and actually get things done eventually =)
17:45:56 <geekosaur> derekv, also, look up Real World Haskell
17:46:02 <geekosaur> @where rwh
17:46:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:46:37 <pxqr> RWH has helpful exercises also
17:46:58 <derekv> startling: at least it has a video (yay!)
17:47:16 <derekv> geekosaur: I have that book only just cracked it however
17:48:46 <levi> derekv: You could try adding on to someone else's software, too.
17:49:14 <zomg> Blah
17:49:23 <zomg> Looks like I might just have to write a parser for this...
17:49:54 <zomg> I just want to look up some strings in some text and replace them using another function to determine the replacement
17:50:14 <zomg> Can usually do that with regexes but doesn't look like haskell's regex libs support that..
17:50:55 <zomg> hmm or maybe I can do two passes over it with regex, one to look up the strings, then generate the replacement, and another to again look up and also replace
17:50:58 <zomg> Meh :P
17:51:50 <solrize> m3ga "divide into chunks" doesn't really work with hassle, since major obstacles are in understanding how multi-layer chunks fit together.  e.g. seeing the transformer stack for a given problem, or using any of the enumerator libraries
17:52:55 <levi> derekv: Reading moderate-sized programs and really digging into how they work can be very helpful, too.
17:54:06 <derekv> kindof thought of having a rules system and I think I could get quite far on basically a set of "rules" (basically just functions, probably), that either refrence some static data that is known at the start of the evaluation, or refrence derived values (defined by other functions), and potentionally contribute some value to some set, which can in turn be refrenced by derived values (and thus other rules)
17:54:35 <derekv> levi: yea actually in some ways its cool its like learning to code all over again
17:55:57 <levi> So you want to make a language based on term-rewriting rules?
17:56:13 <m3ga> solrize: of course it does. all coding problems are about decomposing the whole task into more manageable chunks.
17:56:58 <derekv> So this implies some sort of evalutation dependancy ordering and it might be OK just to say any cycle is an error
17:57:45 <levi> Well, there's plenty of theory already hashed out in the space of term-rewriting systems.
17:57:53 <derekv> levi: I haven't thought about term-rewriting in a while
17:58:08 <m3ga> derekv: as a simple proxy for rule re-writing, maybe try re-writing arithmetic expressions first eg:    a (b + x) -> a b + a x
18:00:57 <pxqr> http://hackage.haskell.org/package/tau (i've just noticed it)
18:04:17 <derekv> I'm not sure if term rewriting applies
18:04:33 <derekv> or I don't understand it.
18:05:03 <derekv> maybe it does
18:05:37 <derekv> It started with just wondering if i could have a general system for describing turn based games
18:06:58 <derekv> You'd need some structure (data) to describe the game state.  You could then have two such states, and a set of rules that describe if it is a legal move
18:08:10 <derekv> in the case of chess, there's not much state involved... maybe you'd need to know remember 6 moves to determine a stalemate, but this could be stored in the game state itself
18:09:10 <ludamad> Until you have gigabyte transposition tables
18:09:20 <twoolie> chess is a highly constrained game. what happens when describing, say, DnD where the rules are more... fluid
18:09:22 <S_J> http://en.wikipedia.org/wiki/Parametricity <- seq is bad?
18:09:30 <S_J> @src seq
18:09:30 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
18:09:34 <S_J> @type seq
18:09:35 <lambdabot> a -> b -> b
18:09:43 <S_J> > seq 10 5
18:09:44 <lambdabot>   5
18:09:48 <S_J> > seq 1 3
18:09:49 <lambdabot>   3
18:09:52 <danharaj> @google fast and loose reasoning is morally correct
18:09:53 <lambdabot> http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/fast+loose.pdf
18:09:53 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
18:10:07 <derekv> but what if you want ot be able to write rules for your game like "if the target of the attack is two sizes larger than the player, and the player is a dwarf, then they get a +2 bonus on their attack"
18:10:13 <ludamad> twoolie: Define derived stats as a function of core stats etc, wrap stuff like inventory and whatnot in a state monad
18:10:16 <derekv> twoolie: =P
18:10:53 <twoolie> ludamad: oh god, i don't want to see your code that implements grapple
18:11:37 <ludamad> twoolie: Ha
18:11:51 <derekv> invetory can all be part of the game state I think (I just picture some sort of big tree type object)
18:12:02 * applicative 's little sandbox was nice and small til he decided to install criterion; grr
18:13:41 <carter> applicative: what are you benchmarking?
18:13:46 <carter> i have a wee template for criterion
18:14:35 <applicative> its just this pipes-4.0 business
18:15:09 <applicative> I think I could have told cabal to use the criterion that's not in my sandbox. Well maybe not
18:15:27 <carter> i have a nice template for nicer perf comparisons
18:15:58 <ludamad> twoolie: Can I just implement the hand-waving that I do in physical DnD sessions ? :-P
18:15:59 <carter> https://bitbucket.org/carter/multicriterion-templates
18:16:02 <applicative> oh where is it,
18:16:03 <applicative> oh
18:16:06 <ludamad> Never once did a 'proper' grapple
18:16:20 <carter> so the perf comparision bar charts
18:16:27 <carter> are per group
18:16:33 <carter> rather than all together
18:16:36 <carter> so the scalling makes sense
18:16:48 <carter> at some point i'll make it be haskell code instead of js stuff
18:17:39 <derekv> so far I just have this idea that you have intermediat values that in the end are all deterministically derived from the data.  for example,  there could be a set of defensive bonuses, which are "produced" buy other rules, and then in turn your total bonus would be derived from this set
18:18:27 <derekv> Keywords in the english rules are stuff like "you _have_" or "you _get_"
18:22:58 <derekv> without any kind of rule DSL or dynamic loading how could I do this statically in haskell ?
18:24:38 <derekv> simplified let say, i have a set of bonuses to AC, where bonus is some object that i can get a signed integer out of...  as long as each rule only effects one set, then each set could be just a set of functions, taking the game state data and returning a bonus
18:25:02 <derekv> as long as the rules don't refrence artifacts of other rules
18:25:11 <derekv> but at least that could be a start
18:28:39 <derekv> whats this whole thing about lenses? I'm trying to get away from getters and setters lol
18:32:00 <startling> > view (_1 . _2 . _3) (('d', ('a', 'b', 'c')), 'e')
18:32:01 <lambdabot>   'c'
18:32:37 <Twey> derekv: It's not entirely clear to me what you're trying to do
18:33:15 <Twey> What sort of a game are you talking about, here?  What does the board/gamestate look like?  What are the ‘moves’ going to look like?
18:33:21 <meretrix> If I install all packages with profiling enabled will my binaries be any slower/bigger when compiled without the '-prof' flag?
18:33:55 <LordBrain> meretrix, in cabal, you will compile everything twice
18:34:03 <LordBrain> if that is what you mean
18:34:05 <derekv> Twey: eventually, could I build a system that would allow someone to create a very wide variety of interesting games
18:34:15 <LordBrain> so you'll have 2 different binaries for all libs
18:34:18 <Twey> derekv: Of course you could
18:34:29 <dwcook> Haskell is such a system :)
18:34:36 <Twey> derekv: But the logical conclusion is just to give them a Haskell compiler
18:34:39 <Twey> Ha
18:34:47 <meretrix> LordBrain: Ok, so there will be one binary that is slow and has profiling and the other will still be fast?
18:35:21 <meretrix> I want to have the option to turn on profiling to debug something, but then just drop the flag and still have fast binaries.
18:35:31 <Twey> derekv: If you want to specify some easier or more domain-specific subset, you need to specify not what you want them to be able to do but what you want them to not be able to do
18:35:51 <startling> meretrix: that's my understanding.
18:36:06 <sordina> @seen tekmo
18:36:06 <lambdabot> tEKMO
18:36:16 <meretrix> Great, thanks.
18:36:18 <derekv> Twey: the meta-goal is to have an interesting, non-trivial problem to solve using haskell.  yes, eventually the concept is some narrow DSL
18:36:19 <LordBrain> meretrix,  yeah, you want library-profiling: True, but leave executable-profiling:False
18:36:22 <Twey> Then how you'd like them to interact with this — library?  Framework?  DSL?  Interpreter/compiler for a different language?
18:36:24 <dcoutts_> meretrix: you get two sets of libs, you only pay the runtime costs of profiling when you compile an exe for profiling (since that'll then use the prof versions of the libs)
18:36:53 <geekosaur> preflex: seen tekmo
18:36:53 <preflex>  tekmo was last seen on #haskell 5 days, 2 hours, 21 minutes and 59 seconds ago, saying: merijn: Yeah, both versions are right
18:36:54 <LordBrain> meretrix, then when you want a profiled version of a specific package, you tell it -prof on the command line, and it already has profling versions of the libraries to link against
18:37:08 <LordBrain> or -p, or whatever the switch is
18:37:09 <startling> @seen what
18:37:09 <lambdabot> What
18:37:14 <Twey> derekv: Yes, but before you can solve the problem you have to define it :þ
18:37:41 <sordina> thanks geekosaur :)
18:38:11 <LordBrain> so in general, it will only make 2 copies of every library, not the executables, but you can create profiled versions of the executables when you want you would just have to specify that is what you want.
18:38:31 <LordBrain> that's how my cabal is configured
18:38:57 <lemao> applicative: do you know if there are additional pipes 4 tutorials out there? I already looked at the main one. Although it is pretty good I am stuck trying to implement a specific pipe
18:39:09 <derekv> Twey: First I just thought I could break it into some far simpler goal, which would basically be, given two game states (represented as some sort of tree value), determine if it represents a 'legal move' according to the rules
18:39:48 <Twey> derekv: You might find it easier to reason about if you had some concrete example to implement in terms of your system
18:39:49 <LordBrain> if you already have cabal installed, it will create a bit of a mess when you change the setting, because now it will be missing all the profiling libraries, i worked thru that manually using ghc-pkg and cabal commands
18:40:46 <thoughtpolice> danharaj: cool link to Adam's thesis in that ticket. i was wondering what the final outcome of things like 'inch' would be
18:40:49 <LordBrain> i don't recall off-hand how i did that, you'll have to ask someone else or read their man pages.
18:41:11 <Twey> derekv: You probably want to restrict the states and rules (or your solution boils down to isValidMove checkValidMove x y = checkValidMove x y)
18:41:42 <danharaj> thoughtpolice: Everything in that vein is very exciting to me.
18:41:43 <Twey> (also known as isValidMove = id :þ)
18:42:14 <Twey> derekv: Maybe a good place to start would be in designing how you would like your user to specify the rules?
18:42:20 <thoughtpolice> zomg, this new Mio paper looks amazing too
18:42:31 <derekv> Twey: sure. i think it has more to do with how to organize a (potentially increasing) set of rules
18:43:01 <danharaj> thoughtpolice: Here I am sitting playing around with positional representations of type level nats and wishing * :: * so that I can stop thinking about a faux-kind level that is almost like type-level but not quite.
18:43:20 <thoughtpolice> "We also show that with Mio, McNettle (an SDN controller written in Haskell) can scale effectively to 40+ cores, reach a thoroughput of over 20 million new requests per second on a single machine, and hence become the fastest of all existing SDN controllers."
18:43:26 <startling> danharaj, dependent types yo
18:43:29 <thoughtpolice> THIS IS GOOD
18:43:43 <Twey> Ooo.
18:44:00 <danharaj> startling: There are a few proposals for dependent types in GHC that we are talking about.
18:44:11 <derekv> Twey: yea that'd be important
18:44:14 <Twey> danharaj: There are?!
18:44:19 <danharaj> yes
18:44:38 <Twey> derekv: More importantly, it will give you some idea as to how you want to do the rest of it (I'd imagine)
18:45:12 <Twey> danharaj: Would you mind linking me?
18:45:22 <startling> danharaj: not quite what I meant!
18:45:58 <danharaj> Twey: http://www.cis.upenn.edu/~eir/papers/2013/fckinds/fckinds-extended.pdf is one
18:46:06 <danharaj> https://personal.cis.strath.ac.uk/adam.gundry/thesis/
18:46:07 <danharaj> is another.
18:46:18 <Twey> Beautiful, thanks
18:46:23 <danharaj> thoughtpolice: oh wow is Mio in GHC Head?
18:46:33 <danharaj> Or is it even in 7.6.3?
18:46:54 <thoughtpolice> most of the work should be in HEAD, yes
18:47:19 <thoughtpolice> or all of it at this point, perhaps. i haven't seen any commits from Andreas fly into base in a little while
18:47:44 <thoughtpolice> so perhaps this describes extra improvements he'll have soon.
18:47:50 <danharaj> I remember there being a new io manager a few months ago
18:47:53 <thoughtpolice> last i heard the new I/O manager scaled up to about 32 cores easily
18:47:56 <danharaj> is this that, or is it a new new io manager?
18:48:01 <thoughtpolice> yes, this is that
18:48:20 <thoughtpolice> although the 40+ cores surprises me. perhaps there are some final optimizations he made
18:49:31 <danharaj> thoughtpolice: I have to read this paper because it is relevant to what we do at work. It'll be important for us to structure our I/O to take full advantage of the new manager.
18:52:19 <thoughtpolice> it looks extremely promising. i wonder what the latency numbers are...
18:53:19 <danharaj> thoughtpolice: I am concerned that some libraries that do IO, like db bindings might not be structured to scale well with the new manager. Do you know what I should look for to get a quick idea in someone else's code?
18:54:40 <thoughtpolice> danharaj: not off hand i'm afraid. the i/o manager is quite complex and has a lot of various interactions. i don't even know if there's a great write up describing its whole architecture
18:54:44 <thoughtpolice> well, besides this new paper perhaps
18:55:03 <danharaj> fair enough
18:56:04 <thoughtpolice> danharaj: oh, and it's probably worth reading the old-new I/O manager paper too, perhaps to contrast
18:56:08 <thoughtpolice> from Johan and Bryan: http://research.google.com/pubs/pub36841.html
18:56:28 <danharaj> ah that's the new io manager I thought was the new new one.
18:56:34 <danharaj> I guess it is the old-new one and this is just the new one.
18:56:37 <thoughtpolice> yes
18:56:43 <thoughtpolice> the original I/O manager just used select()
18:56:46 <thoughtpolice> for every platform
18:57:01 <thoughtpolice> Johan/Bryan made it more scalable, using epoll/kqueue and other stuff
18:57:20 <thoughtpolice> and now this is the third major revision
18:57:54 <LordBrain> being a noob here, what is the io manager? Part of the RTS i take it?
18:58:02 <danharaj> yes.
18:58:18 <danharaj> It is the part that manages talking to the OS on blocking requests while your program runs.
18:58:25 <thoughtpolice> LordBrain: yes. it controls the interaction between lightweight threads and the OS
18:58:48 <danharaj> Although since it uses epoll doesn't that mean it only manages files and sockets and whatnot?
18:59:25 <thoughtpolice> LordBrain: normally, certain blocking calls (like read) block a whole OS thread. for GHC, this is bad, because ghc threads aren't OS threads. they're multiplexed *on top of* OS threads.
18:59:33 <cschneid> given this library function, how can I tell what happens if it fails to read the file: http://hackage.haskell.org/packages/archive/yaml-light/0.1.4/doc/html/Data-Yaml-YamlLight.html#v:parseYamlFile
18:59:41 <thoughtpolice> so if one of your lightweight threads were to make a blocking call, it'd stop the whole OS thread, and any other lightweight threads
18:59:44 <thoughtpolice> which would be bad
18:59:46 <cschneid> presumably an ioerror? but that's just a guess right
18:59:56 <thoughtpolice> the I/O manager can intelligently handle scheduling things off to new OS threads in a threadpool it maintains
18:59:56 <danharaj> cschneid: you curse the author for using exceptions instead of a sensible error mechanism
19:00:13 <cschneid> danharaj: :) damn.  How should I catch the exception, I'm just going to turn it into a Maybe myself
19:00:22 <cschneid> first time needing to deal with exceptions
19:00:37 <danharaj> cschneid: Honestly I would just use another library.
19:00:44 <danharaj> But I have low tolerance for terrible design decisions ;)
19:01:01 <cschneid> danharaj: hah. Any suggestions on reading yaml?
19:01:10 <cschneid> this seemed like the lightest weight example.
19:01:10 <geekosaur> HsSyck?
19:01:40 <cschneid> geekosaur: nearly same type: http://hackage.haskell.org/packages/archive/HsSyck/0.50/doc/html/Data-Yaml-Syck.html#v:parseYamlFile
19:01:54 <cschneid> in fact, the one I'm using is a narrower interface on HsSyck
19:03:29 <danharaj> I am surprised a hacker as awesome as AudreyT doesn't handle errors at all in HsSyck.
19:03:32 <geekosaur> so looking at source, it does indeed throw an exception on failure
19:03:33 <danharaj> On the other hand that is some old school code.
19:03:44 <danharaj> 2006 is like 300 BC in Haskell years.
19:03:47 <cschneid> so. I should use tryIOError?
19:04:16 <cschneid> I don't really care, other than just having to pluck a few values out of yaml, and if anything goes wrong, putstrln something and use defaults
19:05:30 <cschneid> err, looks like catchIOError is what I want.
19:05:38 <cschneid> it's a function to run, then the handler for it?
19:06:43 <geekosaur> anyway looks to me like it's using C code for the parsing, and there's an error callback from the C code
19:06:47 <danharaj> :t catchIOError
19:06:47 <lambdabot>     Not in scope: `catchIOError'
19:06:47 <lambdabot>     Perhaps you meant `catchError' (imported from Control.Monad.Error)
19:06:48 <geekosaur> so somewhat painful to deal with
19:07:28 <geekosaur> in particular, can't just abort the parse from the C-callback-into-Haskell, so it's written to an IORef
19:07:48 <geekosaur> although I suppose it'd be better to use an Either there... no idea
19:09:01 <LordBrain> are exceptions just always a bad idea?
19:09:20 <levi> Not necessarily.
19:09:43 <levi> But opinions vary on when/where they should be used.
19:16:45 <LordBrain> so coding with exceptions is dissing someone else's mom?
19:17:05 <LordBrain> metaphorically
19:17:56 <kroll> LordBrain: what is an exception in haskell?
19:19:28 <applicative> > head []
19:19:29 <lambdabot>   *Exception: Prelude.head: empty list
19:19:30 <tertl3> hi geekosaur
19:20:45 <derekv> watching this bryan o'sullivan talk "running a startup on haskell"... missed this one
19:26:02 <danharaj> edwardk: What is a clever way to add digits that are stored in a list where the most significant digit is the head?
19:26:57 <danharaj> Don't tell me I have to reverse the list and add with carry like a prole :3
19:31:06 <owen> any one know why Control.Monad.Writer.Lazy doesn't import data constructer Writer?
19:32:13 <monochrom> there is no longer data constructor Writer
19:32:49 <applicative> owen it
19:32:51 <monochrom> Writer is just a type synonym of WriterT Identity
19:32:57 <applicative> isnt a constructor
19:33:02 <owen> oh
19:33:11 <applicative> so you can write 'write x' not 'Writer x'
19:33:25 <applicative> it's a little irritating it has to be a monad transformer, not a mere monad
19:33:42 <owen> thanks
19:34:01 <applicative> owen: i meant , writer blah, not Writer blh
19:34:14 <applicative> @type writer
19:34:14 <lambdabot> MonadWriter w m => (a, w) -> m a
19:34:26 <applicative> @type runWriter
19:34:27 <lambdabot> Writer w a -> (a, w)
19:34:41 <applicative> > runWriter $ writer ("hi", 3)
19:34:43 <lambdabot>   No instance for (Data.Monoid.Monoid w0)
19:34:43 <lambdabot>    arising from a use of `e_13'
19:34:43 <lambdabot>  Th...
19:34:50 <applicative> indeed
19:35:03 <applicative> wrong way round
19:35:11 <applicative> > runWriter $ writer (2,"hi")
19:35:12 <lambdabot>   (2,"hi")
19:36:57 <applicative> @type runWriterT
19:36:58 <lambdabot> WriterT w m a -> m (a, w)
19:37:11 <applicative> > runWriterT $ writer (2,"hi")
19:37:12 <lambdabot>   No instance for (GHC.Show.Show (m0 (a0, [GHC.Types.Char])))
19:37:12 <lambdabot>    arising from...
19:37:32 <applicative> right god forbid a show instance for Identity
19:37:47 <startling> I hate that.
19:38:13 <applicative> i've bumped into it surprisingly often. sounds like others have ...
19:56:30 <tswett> So I'm pondering databases in Haskell. My first problem is that I have a relation where tuples can be selected using either of two keys.
19:56:48 <startling> I want to parse html and easily find things like the contents of the first h1 and the contents of a datetime attribute of a time element with the 'pubdate' boolean attribute. What should I use?
19:57:10 <tswett> It looks like DSH and HaskellDB are both Haskelly instead of SQLy, and I like that idea.
19:57:49 <tswett> startling: well, there are certainly HTML parsers for Haskell, and I'm sure that one of them can do that easily. But I don't have enough experience to recommend one.
19:58:04 <startling> tswett: right, me neither.
19:59:58 <c_wraith> startling: with those constraints, one of the tagsoups is probably easiest
20:00:20 <startling> c_wraith: which one of the tagsoups is preferable?
20:01:33 <applicative> hm cabal repl ? golly "Open an interpreter session for the given target."
20:02:09 <c_wraith> startling: I'd go with http://hackage.haskell.org/packages/archive/tagsoup/ until you find a reason not to.
20:02:21 <startling> c_wraith: thanks!
20:04:30 <startling> someone needs to write a lensy (prismy?) html parser.
20:13:34 <c_wraith> has anyone done any work on capability-local storage in GHC?
20:17:03 <tswett> Hmm. So in Haskell, you can say that a monad represents a domain in which computation is augmented in its abilities.
20:17:25 <startling> not necessarily.
20:17:51 <tswett> An "IO a" is like an "a" that's allowed to access the real world. A "Maybe a" is like an "a" that's allowed to give up. A "[a]" is like an "a" that's allowed to split into pieces and/or vanish.
20:17:52 <dymatic> Not really, because Monads don't have to operate soley on their domain.
20:17:58 <c_wraith> Dunno.  I think the Kleisli category formation does look a lot like that..
20:18:17 <c_wraith> They're like functions, but augmented to do *something* extra.
20:18:51 <tswett> So I'm wondering if there's something akin to monads, where the thing represented is a domain in which a computation's abilities are *restricted*.
20:20:34 <tswett> In particular, not every function a -> b would correspond in a sensible way to a function t a -> t b.
20:21:07 <Cale> Perhaps an Arrow only without arr
20:21:21 <c_wraith> someone was doing a bunch of research on that abstraction
20:21:25 <c_wraith> they called it GArrow
20:21:28 <Cale> (Category + other things)
20:21:42 <c_wraith> http://www.cs.berkeley.edu/~megacz/garrows/  there
20:21:49 <Cale> Yeah, GArrow is pretty much exactly the same thing we came up with at iPwn too
20:22:09 <applicative> I hope you had a better name, Spear or something
20:22:20 <tswett> Hmm. Yeah, lemme look at GArrow.
20:22:21 <Cale> It's more or less the same data as a symmetric monoidal category.
20:22:39 <Cale> Our instance actually *did* have arr
20:23:04 <Cale> also, I dislike the naming scheme GArrow uses :P
20:23:26 <Cale> But it's the idea that counts :)
20:23:37 <applicative> Is there some mysterious new syntax in this paste http://lpaste.net/91749
20:23:45 <applicative> type instance where ...
20:23:50 <applicative> no it cant be.
20:24:00 <carter> applicative: closed type families
20:24:05 <applicative> oh wait
20:24:20 <carter> type level recursive pattern matching functions :)
20:24:26 <tswett> Yeah, I like GArrow.
20:24:29 <applicative> soon as I looked at it again, I thought what about those closed type families...
20:24:35 <carter> glad to help
20:24:52 <c_wraith> that is some funny syntax
20:24:59 <applicative> hm I wonder if I have it in my two-week old ghc head
20:25:06 <applicative> it is odd
20:25:09 <carter> whats od?
20:25:18 <carter> they had to make up a syntax for it
20:25:29 <c_wraith> that it doesn't actually say the name of the type family it's providing instances for until the body
20:25:45 <applicative> because the body is like a function definition
20:25:47 <applicative> still odd...
20:26:30 <c_wraith> I still want as-patterns for types. >_>
20:26:51 <startling> is there a convenience library that gives you "traverse all the files in this directory in IO"?
20:27:07 <c_wraith> @hackage directory-tree
20:27:07 <lambdabot> http://hackage.haskell.org/package/directory-tree
20:28:19 <applicative> oh well cant compile the close families
20:28:40 <startling> c_wraith: wow, it even has lenses. thanks.
20:30:19 <Orxata_> Hello.
20:30:34 <applicative> hi Orxata_
20:30:46 <Orxata_> Hi applicative
20:32:53 <applicative> startling: Tekmo had one but I dont know what version of pipes it works with https://github.com/Gabriel439/Haskell-DirStream-Library/blob/master/DirStream.hs
20:33:14 <applicative> startling: it really was astounding in using a tiny amount of space
20:33:54 <startling> applicative, "I dont know what version of pipes it works with" is why I've given up on pipes for now. :/
20:34:40 <MouseTheLuckyDog> Wow there is a programming language called Shakespear.
20:34:42 <applicative> startling: I don't blame, at least for the moment, ha
20:35:10 <applicative> startling: there was once a really heated dispute about writing such a function in Haskell, so it interested me
20:35:29 <applicative> startling: it looks like this one is worrying about space in the comments
20:37:30 <applicative> oh here it is. unusually interesting for a reddit tempest http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
20:43:05 <applicative> oh i see, the directory-tree package was inspired by this war, http://www.haskell.org/pipermail/haskell-cafe/2010-August/080448.html according to the announcement
20:46:34 <copumpkin> we need pattern antonyms
20:47:06 <c_wraith> "anything but (5:_)"
21:15:05 <c_wraith> "GHC’s RTS had a bug in which yield placed the thread back on the front of the run queue."  Hah.  oops.
21:16:21 <applicative> startling: here, i fiddled with it http://sprunge.us/jGcT?haskell
21:16:40 <applicative> it uses the going version, https://github.com/Gabriel439/Haskell-Pipes-Library
21:17:15 <cschneid> I have a SUPER SIMPLE format that I want to parse.  "ping x y z" == data Ping [x,y,z] for instance
21:17:31 <cschneid> what's the simplest approach there, I'd prefer to not have to pull in a real parsing lib yet
21:17:45 <c_wraith> really?  That's not simple at all when you have to refer to values in the current environment
21:18:00 <c_wraith> or were those meant to be standins for numeric literals?
21:18:15 <applicative> c_wraith: calm down! ;)
21:18:47 <applicative> pingParser = do string "ping" ; ...
21:19:00 <cschneid> applicative: what parser is that?
21:19:22 <cschneid> ie, shouldn't I be able to just match the prefix of a string with some pattern matching and call it good?
21:19:24 <applicative> cschneid: i'm just beginning my pingParser with the usual machinery
21:19:42 <c_wraith> applicative: which usual machinery is his question, I thinkk
21:19:46 <c_wraith> ..  typing is hard
21:20:15 <cmears> if it's really really simple could you use "words"?
21:20:34 <applicative> cschneid: well, there's  blah . splitAt 1 . words
21:20:40 <cschneid> so I guess, how do I pattern match on the first word of the string
21:20:54 <cschneid> because yes, words & head will pull off all I need for now
21:21:37 <cmears> > case words "ping x y z" of ("ping":rest) -> rest
21:21:38 <lambdabot>   ["x","y","z"]
21:21:42 <cmears> for example
21:22:08 <cschneid> ahh, so I can just case statement it? I tried doing top level pattern matching against whole strings, and that was a PITA
21:22:29 <cschneid> had to match against ('f':'o':'o':_) instead of ("foo":_)
21:22:34 <cmears> if you want to match whole strings like that, it's easy
21:23:09 <cmears> to match prefixes, perhaps "stripPrefix" is the way to go
21:23:44 <cmears> > case stripPrefix "hel" "hello world" of Just rest -> rest
21:23:45 <lambdabot>   "lo world"
21:24:37 <cschneid> cmears: I have 'ping', 'pub' and 'list' as my potential commands, and then the stuff after needs to be captured into my data type to be interpreted later.
21:25:33 <cschneid> I suppose I could chain the case statement you listed, on Nothing, do the next one
21:25:38 <cschneid> but that seems silly(ish)
21:26:25 <cmears> case words "list x y z" of { ("ping":rest) -> 1 ; ("list":rest) -> 2 }
21:26:50 <cmears> now just change 1 and 2 into the code that parses the "rest" of the command
21:26:58 <cmears> (and add your third case for "pub"
21:26:59 <cmears> )
21:27:05 <cschneid> ok, sweet.
21:27:11 <cschneid> might change words to a splitAt ' '
21:27:26 <hpaste> applicative pasted “recurse directories pipes 4.0” at http://lpaste.net/91774
21:27:26 <cschneid> which presumably would work the same, just make a two element list, as opposed to an N argument list
21:30:46 <cmears> or do it this way, which actually looks nice if it's not all on one line:
21:30:47 <cmears> let cmd = "ping x y z" in do { rest <- stripPrefix "list" cmd ; return ("l"++rest) } <|> do { rest <- stripPrefix "ping" cmd ; return ("p"++rest) }
21:31:30 <cmears> verily, there is more than one way to do it
21:32:20 <applicative> that is nice.
21:33:13 <cmears> you get the bonus there that pattern match failures just become a failed parse (i.e. Nothing)
21:33:50 <cmears> e.g. you can have "(x:xs) <- Just somelist" and it fails gracefully if somelist is empty
21:34:16 <cschneid> cmears: ahh, so that's a maybe monad there, combined with <|> (combines them, from what package though?)
21:34:27 <cmears> <|> is in Control.Applicative
21:34:28 <cschneid> applicative / alternative
21:34:39 <cschneid> ok. So Nothing <|> Just x is   Just x
21:35:22 <cmears> > Nothing <|> (Just 'x')   -- indeed
21:35:23 <lambdabot>   Just 'x'
21:36:36 <cschneid> sweet, didn't realize chaining do blocks like that is an option
21:36:41 <cschneid> that reads really nicely
21:39:55 <cschneid> cmears: you're awesome, thank you for helping a guy who has no idea what he's doing :)
21:42:28 <cmears> you're welcome; happy parsing!  (:
21:44:22 <elliott> parsec parsing
21:46:38 <gnuvince-> Is there a Regex lib that allows substitution?
21:47:29 <sutabi> If I have a signiture "gameloop :: World -> IO World" how do I turn "World" into an IO?
21:48:28 <Demos> return World
21:48:29 <m3ga> sutabi: 'gameloop world = return world' matches the type signature. or 'gameloop = return' (eta reduced)
21:49:35 <sutabi> m3ga: gah! thank you!
21:51:17 <beens_> Hi all. I want to create a sort of monadic tree. Where I have a child function (f :: x -> [IO x]). I want to lazily create this tree so that I can search it with my own search strategy. I also want the children to each have their separate effects. Do you have any pointers of how to go about doing this?
21:59:57 <pentace> gnuvince-: I'm pretty sure there's a function for that in one of the standard regex packages
22:02:55 <gnuvince-> pentace: I can't seem to find the function
22:03:40 <gnuvince-> pentace: http://hackage.haskell.org/packages/archive/regex-posix/0.95.2/doc/html/Text-Regex-Posix-ByteString.html
22:03:55 <gnuvince-> I can't see any function with a name like "replace" or "substitute"
22:04:34 <pentace> hmmm, one second
22:04:41 <NemesisD> is this possible/make sense? i've got [ReaderT r m a] and I want to run them all in a reader context, i think the type would be [ReaderT r m a] -> ReaderT r m a
22:06:01 <pentace> gnuvince-: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html
22:06:07 <pentace> only for String, though
22:06:32 <beens_> NemesisD: do you want sequence ?
22:06:56 <gnuvince-> pentace: ah, I was looking at other packages (regex-pcre, regex-tdfa)
22:07:15 <NemesisD> beens_: maybe sequence_, not sure if the types work out on that let me try
22:12:17 <clj_newb_2345> When I think of parsec, I think of parsing streams. Are there standard patterns for parsing trees and parsing directed acyclig graphs?
22:12:47 <cmears> you could flatten the tree into a stream (:
22:13:26 <sutabi> Is there any reason why this does not loop? I just get an empty line when I run it: https://gist.github.com/joseph-montanez/6208361
22:14:14 <joelteon> so hackage rejects packages with extensions: MultiWayIf, huh
22:14:53 <cmears> sutabi, you don't execute gameloop
22:15:08 <cmears> try changing it to "world <- gameloop $ World Running 0"
22:15:45 <cmears> (with the "let world = gameloop ..." version you have now, the IO action is assigned to "world" but is never run)
22:15:51 * hackagebot haxparse 0.1.0.0 - Readable HaxBall replays  http://hackage.haskell.org/package/haxparse-0.1.0.0 (JoelTaylor)
22:15:54 <sutabi> cmears: that was the first thing I tried, I get "<stdin>: hGetLine: end of file" and when ran, still a blank line
22:15:58 <NemesisD> man ghc's typechecker must be 2 phase
22:16:26 <NemesisD> i work for a while and finally get down to 1 error. i'm incredulous that my program will compile. i fix the error and it shows me 10 more
22:16:34 <cmears> sutabi, with that change it seems to work for me
22:17:18 <sutabi> cmears: hm.. okay weird, it didn't replace my executable. it is running correctly, sorry!
22:17:40 <cmears> no problem (:
22:17:52 <cmears> putting it in "paused" mode loops infinitely, by the way
22:19:12 <roboguy_> is the "RealWorld -> RealWorld" model of IO the best we have right now? it seems like it has some issues. I'm not sure if that causes practical problems though
22:19:17 <pentace> clj_newb_2345: Parsec has a Stream class with monadic result values, maybe that can be used on your structures
22:19:49 <k0001> 1y1
22:26:36 <NemesisD> i've got to get this transformer stack situation figured out. having to put lift in front of every IO action is no longer cute
22:27:20 <beens_> NemesisD: yeah, it can get annoying. Do you know about liftIO?
22:29:04 <applicative> define f // x = liftIO (f x) , just to make trouble, NemesisD
22:30:48 <structuralist> is it possible to have sections of type operators?
22:31:08 <structuralist> I want to write "Free F" as "F:*"
22:32:01 <applicative> instance Monoid a => Monad ((,) a) where ...
22:32:05 <structuralist> but I can't do something like "(F:*) :->: …." (where :->: is a natural transformation)
22:32:40 <Twey> NemesisD: I usually end up trying to group them together, then just lift'ing a do block
22:32:55 <applicative> hm, I guess not, you'd think TypeOperators might permit it.
22:33:06 <NemesisD> beens_: my inner monad is IO so there's no benefit
22:33:08 <haasn> structuralist: nope, seems to be a parse error despite TypeOperators and PostfixOperators
22:33:56 <NemesisD> Twey: yeah i did that a few times unfortunately, the outer monad is a logging monad so it is naturally interspersed
22:34:44 <structuralist> hmm
22:36:07 <Twey> NemesisD: You can always write your own logging functions that include lifting
22:36:52 * Twey scratches his head.
22:37:11 <applicative> structuralist: if its any consolation, you don't need the : with TypeOperators so you can have data x > y = x :> y
22:37:37 <Twey> Yeah, no, that's backwards, sorry :þ
22:37:50 <structuralist> applicative: oh cool :)
22:37:59 <Twey> chrisdone likes to define io = liftIO, which is less obtrusive to type
22:38:04 <roboguy_> Can you define a Functor that has constraints on the type variable? like an fmap that needs a type like (Ord a, Ord b) => (a -> b) -> Tree a -> Tree b?
22:38:12 <applicative> it came with DataKinds and so on, so they could do 1 + 3 'at the type level'
22:38:32 <tswett> Okay, so I'm abusing language extensions again. I have the TypeFamilies extension, and GHCi is claiming that the line "type family Dual a where" has a syntax error.
22:38:35 <hpaste> tswett pasted “Type family syntax error” at http://lpaste.net/91775
22:38:55 <beens_> roboguy_: You can't define a Control.Functor functor. This is the reason Set isn't a Functor
22:38:56 <tswett> Am I missing something obvious? This is 7.4.2.
22:39:10 <structuralist> applicative: does that work with type synonyms too? I'm getting an error
22:39:21 <roboguy_> beens_: that's what I mean. hmm
22:40:04 <Twey> tswett: You define type instances separately, no ‘where’
22:40:09 <NemesisD> holy crap
22:40:17 <applicative> structuralist: hm, I have type x >> y = (x,y)
22:40:27 <applicative> structuralist: with TypeOperators
22:40:55 <Twey> tswett: type family Dual a; type instance Dual (Times a b) = Par (Dual a) (Dual b); …
22:40:55 <tswett> Twey: http://www.haskell.org/haskellwiki/GHC/Type_families says that that's how you define a closed family; is it lying?
22:41:02 <Twey> Err
22:41:08 * Twey read something about closed families recently
22:41:13 <NemesisD> is shachaf from the seattle area?
22:41:15 <structuralist> applicative: that doesn't work for me, maybe I'm out of date
22:41:23 <structuralist> 7.4.2 ?
22:41:27 <haasn> tswett: it's an experimental change in GHC 7.7 and afaik not final
22:41:29 <NemesisD> he's attending the next haskell meetup in my area
22:41:32 <tswett> haasn: *nod*
22:41:33 <applicative> oh, yeah, it is pretty recent structuralist
22:42:17 <structuralist> applicative: is the current version of Platform recent enough? looks like I'm one behind
22:42:30 <applicative> structuralist: yes it has ghc-7.6
22:42:44 <applicative> thats what i'm using
22:43:26 <structuralist> hmm okay if I do the naive thing and download/install it will it likely break anything?
22:43:50 <structuralist> ghci is segfaulting every other time I run it too, so hopefully that'll stop
22:45:34 <shachaf> NemesisD: I'm in WA for a week. Will probably make it for at least some of the meeting.
22:47:10 <thoughtpolice> i should really make a haskell meetup here, so then shachaf can come to it too
22:47:42 <shachaf> thoughtpolice: I also lived here for ~8 years.
22:48:40 <thoughtpolice> shachaf: i like WA quite a lot, was up there a few months ago.
22:49:19 <NemesisD> shachaf: planning on speaking or anything?
22:50:06 <NemesisD> i would love it if this next meetup got into some practical haskel instead of just category theory
22:50:33 <mgsloan> lens talk! lens talk!
22:50:40 <edwardk> wut?
22:50:43 <arkeet> category theory for lenses!
22:51:05 <NemesisD> lenses would be cool
22:51:11 <kloplop321> functional reactive programming?
22:51:51 <mgsloan> edwardk: shachaf's coming to the seattle haskell group - and NemesisD was just mentioning the idea of having a talk orso
22:52:19 <NemesisD> got a $45 parking ticket at the last meetup. goddamn Kirkland Uncorked
22:52:47 <mgsloan> NemesisD: Me too, and Bartosz
22:53:35 <mgsloan> NemesisD: Lenses would be cool, but there're a fair number of attendees that're probably tired of hearing about them + a talk that got into details would probably be too technical
22:54:06 <stevejb> mgsloan: you are talking re: SEAHUG?
22:54:12 <mgsloan> stevejb: yup
22:54:21 <NemesisD> maybe. i really think the meetups would eventually benefit from breakout groups because of the wide experience disparity
22:55:03 <mgsloan> NemesisD: Yeah, that worked well before.  One room was category theory the other room was functor-applicative-monad
22:55:48 <stevejb> NemesisD, mgsloan: agreed, and perhaps some agenda for each of the breakout groups, e.g. how to set up a nice development environment for Haskell in emacs, something like that (that would help me as a relatively inexperienced attendee)
22:56:20 <shachaf> NemesisD: No clear plans at the moment. We'll see.
22:56:36 <mgsloan> Some practical haskelling would probably be good, though
22:57:02 <NemesisD> that's a good point. i've only recently arrived at a dev environment for haskell that i'm reasonably happy with
22:57:14 <mgsloan> stevejb: Yeah, that's a good idea!  Unfortunately I'm not an emacser myself.  In the past editors / plugins have been discussed a bit, though
22:58:02 <stevejb> mgsloan: perhaps a breakout into emacs, vim, and other :)
22:58:52 <mgsloan> stevejb: Yup, that'd work
22:59:33 <mgsloan> Maybe we ought to use the meetup discussion to let efrey know these ideas
23:00:56 <NemesisD> yeah. and i've mentioned it there but if we ever outgrow the globalsign offices, my offices in Mountlake Terrace are always available if anyone actually feels like driving that far
23:03:08 <stevejb> NemesisD: that is a good idea. I would also be happy to put up some space at UW - I could get a few classrooms
23:03:32 <NemesisD> posted on the meetup
23:04:11 <NemesisD> stevejb: have you been to the meetup? trying to remember who you might be
23:04:47 <stevejb> NemesisD: yes I have been. We had my code up on a screen for a bit last meet up, and then I had to sneak out early.
23:05:32 <NemesisD> ahh yeah i remember. how'd that refactoring go for you?
23:06:00 <stevejb> really well. I have learned a lot in the last month. I keep having these moments where I think "I could re-write the whole thing in half the code"
23:06:16 <stevejb> performance is really impressive. my advisor is pretty stoked.
23:06:23 <mgsloan> Nice :D
23:06:37 <stevejb> mgsloan: thanks!
23:08:17 <NemesisD> anyone read that paper about the new multicore io manager?
23:09:47 <Cale> Which one is that?
23:09:54 <NemesisD> sounds like it could lead to some crazy performance with haskell web servers
23:10:01 <NemesisD> http://www.reddit.com/r/haskell/comments/1k6fsl/mio_a_highperformance_multicore_io_manager_for/
23:10:17 <Cale> oh, this is new
23:10:31 <stevejb> NemesisD: sounds really interesting
23:11:01 <NemesisD> someone in that thread claims it will be in ghc 7.8.1
23:12:48 <shachaf> NemesisD: You're the one who just posted on my page?
23:12:49 <Cale> That's one of the nice things about abstraction, is that they can do this sort of work and all the concurrent Haskell programs run faster without needing to be modified :)
23:13:23 <NemesisD> shachaf: yeah
23:15:32 <thoughtpolice> Cale: the paper is very interesting. it's really about multicore scalability, and there's tons of juicy low-level stuff :D
23:15:46 <thoughtpolice> including an epoll bug in linux that was around for probably like 10 years
23:19:27 <structuralist> does haskell have any special use for the character @? I can't make it a type operator, though :@ and @@ are both fine
23:19:59 <Cale> @ is used in patterns
23:20:08 <structuralist> ohh I forgot about that
23:22:42 <shachaf> Hoogle will answer questions like that, by the way! It finds keywords and syntax and everything.
23:29:17 <structuralist> good to know, thanks
23:29:57 <structuralist> shachaf: although a search for "@" turned up nothing helpful
23:30:48 <structuralist> also now reading http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax I'm wondering what -<, >-, -<<, and >>- are for
23:31:08 <structuralist> none of them are in hoogle
23:31:17 <simon> http://stackoverflow.com/questions/18060029/suppress-certain-haskell-alex-happy-compilation-messages -- can someone tell me this?
23:34:25 <shachaf> structuralist: Oh, huh. I thought Hoogle had that.
23:35:39 <shachaf> structuralist: -< and -<< are used in arrow notation.
23:35:50 <structuralist> Is there another idiomatic name for free monad than "Free"? I have other free constructions I'd like to make
23:36:20 <shachaf> structuralist: But in general UnicodeSyntax translations can exist without being mapped to anything standard.
23:36:36 <shachaf> structuralist: Not really. :-( I wish there was, for the reason you said.
23:36:47 <structuralist> shachaf: as in you can extend UnicodeSyntax?
23:36:58 <shachaf> You should come up with a good one. Also one for Cofree (comonad).
23:37:31 <structuralist> If only type operator sections were possible!
23:37:45 <structuralist> then F* X would work beautifully
23:38:20 <shachaf> structuralist: No, as in it provides syntax that doesn't translate to any standard syntax and can just be rebound. Maybe. I'm actually not sure.
23:38:57 <shachaf> structuralist: And naturally X* would mean [X]?
23:39:01 <Twey> No, it's hard-coded
23:39:04 <elliott> structuralist: you can do (F *) I think.
23:39:06 <elliott> with recent enough GHC
23:39:10 <Twey> (I discovered today)
23:39:30 <shachaf> elliott: What, type-level PostfixOperators?
23:39:33 <elliott> data (*) f a = Pure a | Free (f (f* a)) should work, I think.
23:39:39 <structuralist> shachaf: F * X would be Free F X
23:39:40 <elliott> shachaf: I'm just guessing, admittedly.
23:39:59 <shachaf> Oh, not postfix, just regular. Ew.
23:40:26 <structuralist> elliott: the problem I thought is if I want to do something like (f *) ~> (g *) where (f ~> g) x = forall x. f x -> g x
23:40:32 <structuralist> then it ghc complains
23:40:33 <Twey> 7.6.3 doesn't do it
23:40:55 <Twey> (type-level PostfixOperators)
23:40:59 <structuralist> but that definition does work
23:41:51 <elliott> I guess you have to say (*) f and (*) g, yeah.
23:42:20 <elliott> I wonder if there's any good reason not to support (f *) and (g *), though.
23:42:43 <shachaf> Type-level operators are kind of awful in all sorts of ways, if I remember correctly.
23:43:00 <structuralist> in principle or the way they're implemented?
23:45:59 * hackagebot luautils 0.1.1.2 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.1.2 (AnupamJain)
23:46:06 <shachaf> In what happens in GHC right now.
23:48:28 <structuralist> considering using ℱ :P
