00:00:00 <shachaf> Warning: Useless warning enabled.
00:00:07 <dmj`> Gracenotes: The eval code is just so long. Since the grammar is not defined recursively, its like one big fall through. I wanted to use lenses but some of my cases were just strange
00:01:06 <steamboat> Thanks all
00:01:14 <Gracenotes> having a recursive grammar also means evaluation requires recursive meaning. that can get complex.
00:02:28 <Gracenotes> hm, lemme try my hand at a few
00:02:37 <dmj`> I wanted to use lenses but my records weren't embedded in a way that seemed conducive. Unless I just didn't know enough about the lens api.
00:02:48 <lpaste> dmj pasted “lensify?” at http://lpaste.net/92186
00:04:17 <dmj`> Gracenotes: the insertIntoTables function, exactly the wrong way to update a record. You have to pick the right db first, depending on user input, then eval the query (if the db exists), and keep drilling down. No easy way it seems.
00:06:21 <Gracenotes> dmj`: for instance, https://gist.github.com/gracenotes/6338707
00:08:17 <Gracenotes> some of the types of the functions in eval are (perhaps not shockingly!) ad hoc. If there are a bunch of error conditions that require action from anyone other than the use, use something like an enum for it, not a String.
00:08:27 <Gracenotes> in that case, only convert it to a String when showing the user.
00:09:11 <Gracenotes> the gist that I linked is not advice in any particular direction, just somewhat more idiomatic Haskell that does the exact same thing.
00:09:23 <Gracenotes> nevermind indentation etc.
00:09:41 <dmj`> Gracenotes: When you write compilers do you use all bytestrings
00:11:50 <Gracenotes> I haven't written a compiler in Haskell lately, but Text may be better for human-readable things. The main point of lexing is, get away from strings ASAP, convert to tokens as much as possible.
00:13:11 <Gracenotes> this is just a thing that cleans up your code a bit, probably helps performance. laziness is such that it's very easy to split up responsibilities and rely on the compiler to do things in the best order.
00:13:59 <dmj`> so you use parsec on tokens instead of strings?
00:14:51 <Gracenotes> this is one way to do it. for small languages, probably not, but it's still worthwhile consolidating code if that seems reasonable.
00:15:27 <dmj`> Gracenotes: do you have any compilers in haskell I could take a look at?
00:16:50 <Gracenotes> do I have any? no... one on an old hard drive, I think...
00:16:52 <dmj`> I have a simple vm translator, but it was before I was good at haskell. So I have all this string concatenation going on in the evaluator, should've used the state monad and a map to pass around the symbol table. Needs a serious rewrite.
00:17:12 <lamefun> is there a magical `id' thing in haskell that's number but not a number at the same time and can be used to identify things uniquely?
00:18:03 <Gracenotes> even reader monad can be reasonable for symbol table, depending on the language
00:18:38 <danr> lamefun: like python's id?
00:18:40 <Ralith> lamefun: why do you want it?
00:18:40 <dmj`> hmmm, but with reader monad you can't change it right? I guess you could, but then why not use state? It seems like state is just reader and writer combined.
00:18:58 <dmj`> without the monoid restriction
00:19:22 <Ralith> dmj`: combining reader with writer gives you an output that is unrelated to your input.
00:19:28 <Gracenotes> :t local
00:19:29 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
00:19:37 <dmj`> :t modify
00:19:38 <lambdabot> MonadState s m => (s -> s) -> m ()
00:19:57 <danr> lamefun: you have reallyUnsafePtrEquality# :)
00:20:06 <Gracenotes> Reader is a good way to traverse tree-like structures, with information flowing from root to leaves, but it is true that information flowing back up might better use State
00:20:36 <lamefun> for example I have a rocket that tracks target, it needs to identify target somehow, then target disappears, rocket should be able to tell. I've been suggested to use integers and never re-use them, but that'd defeat the purpose of garbage collector
00:21:25 <Gracenotes> stateful simulations are maybe not Haskell's most strong point.
00:21:35 <dmj`> Ralith: ah yes I see, took me a while to process
00:21:37 <Ralith> stateful simulations in haskell work just fine
00:21:53 <Ralith> lamefun: you do not need pointer comparison for that.
00:23:11 <lamefun> Ralith, I didn't say I need them
00:23:14 <lamefun> what can I use?
00:23:47 <Ralith> lamefun: you should not want pointer comparison for that.
00:23:49 * elliott doesn't see how assigning ID numbers defeats the purpose of the GC.
00:24:15 <lamefun> elliott, they'll become bigger and bigger and eventually crash
00:24:53 <dmj`> What is a good project to work on to get good haskell habits?
00:24:54 <elliott> lamefun: um, that's rather unlikely
00:25:23 <elliott> lamefun: if you generate so many objects that the identifier number of the latest one *can't fit into memory* then you've made a mindblowingly large number of objects :)
00:25:44 <danr> > maxBound :: Int
00:25:45 <lambdabot>   2147483647
00:25:49 <Gracenotes> too many 1-bits makes things heavy, harder for the GC to copy from generation to generation
00:25:53 <danr> > maxBound :: Int64
00:25:54 <lambdabot>   9223372036854775807
00:26:07 <danr> that's a lot of objects in your rocket simulation
00:26:13 <elliott> I was thinking Integer.
00:26:13 <johnw> databases use incrementing Ids, and the world has not exploded
00:26:23 <DigitalKiwi> how about a nic game of chess?
00:26:26 <DigitalKiwi> nice*
00:27:52 <Gracenotes> dmj`: hm, there are also some codebases that are quite nice to read
00:28:07 <dmj`> Gracenotes: which
00:28:34 <dmj`> darcs?
00:28:48 <dmj`> i tried reading through snap
00:28:54 <dmj`> server and core
00:28:56 <Gracenotes> trying to think :p
00:29:49 <Gracenotes> any suggestions, channel?
00:30:20 <johnw> dmj`: what are you looking to learn?
00:30:55 <elliott> xmonad
00:31:00 <elliott> oh, "work on"
00:31:16 <elliott> oh, Gracenotes said "read".
00:31:25 <elliott> also I haven't read that much of xmonad, just heard good things. but it's probably nice.
00:32:36 <johnw> maybe gitlib, but it depends on what you want to know
00:32:45 <johnw> i try very hard for code that is as beautiful as I have time to make it
00:32:52 <johnw> though I err on the side of poor documentation
00:33:11 <johnw> writing gitlib certainly taught me monad transformers
00:33:52 <dmj`> johnw: I guess just learning better general architecture of medium-large apps in haskell. Monad Transformers, better exception handling, template haskell (maybe).
00:34:01 <Gracenotes> one useful page, going a good way for idiomatic haskell: http://www.haskell.org/haskellwiki/Avoiding_partial_functions
00:34:05 <johnw> in that case, I do recommend gitlib!
00:34:27 <johnw> i've been working on it, combing it, for 10 months now, and it's being used actively in production
00:34:47 <johnw> stay away from gitlib-libgit2 if you don't want to know about FFI, though
00:35:36 <Gracenotes> http://www.haskell.org/haskellwiki/Data_structures_not_functions
00:35:42 <dmj`> gitlib hmmmm. yes, beautiful code is what I want. More declarative, less explicitly recursive.
00:35:51 <dmj`> ffi actually would be cool
00:36:25 <Gracenotes> http://www.haskell.org/haskellwiki/Obfuscation
00:36:52 <dmj`> Gracenotes: ha nice
00:37:37 <johnw> dmj`: feel free to ask design questions in #gitlib too
00:38:48 <dmj`> johnw: this is very cool
00:39:04 <dmj`> johnw: and you're doing the haskell binding specifically
00:39:44 <johnw> dmj`: how do you mean?
00:40:14 <dmj`> this https://github.com/fpco/gitlib
00:40:28 <johnw> I mean, when you said "you're doing the haskell binding specifically"
00:41:24 <dmj`> johnw: are you writing language bindings to gitlib with the ffi
00:41:36 <dmj`> or am i just confused
00:41:47 <johnw> hlibgit2 is a 1:1 FFI bindings library from Haskell -> the libgit2 C library
00:41:55 <johnw> gitlib is an abstraction of the Git data model
00:41:58 <johnw> gitlib-libgit2 marries the two
00:42:27 <johnw> in the near future, though, I'd like to write a gitlib-hit backend, allowing a 100% Haskell Git solution
00:47:45 <dmj`> johnw: ok I think I see now
00:48:02 <dmj`> http://hackage.haskell.org/package/gitlib-libgit2
00:48:24 <dmj`> taught you transformers
00:48:35 <dmj`> and ffi?
00:48:56 <dmj`> johnw: talk tomorrow, need sleep
00:49:06 <johnw> kk
01:02:13 <akegalj> hpaste is down?
01:02:20 <elliott> kinda.
01:02:21 <elliott> @paste
01:02:21 <lambdabot> Haskell pastebin: http://lpaste.net/
01:02:32 <akegalj> k, tnx
01:06:05 <zamomin> #join /osx
01:07:35 * hackagebot cipher-aes 0.2.4 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.4 (VincentHanquez)
01:14:24 <akegalj> in yesod, how to lift maybeAuth inside Widget? http://lpaste.net/3514421697929281536
01:19:52 <akegalj> oh i figured out, its "handlerToWidget" method.
01:20:14 <notdan> Added some more recent pearls to the wiki: http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls#Online
01:20:52 <mm_freak> which type classes generalize 'either'?  Bifoldable is a bit quirky
01:21:25 <mm_freak> geither :: (e -> b) -> (a -> b) -> p e a -> b
01:23:38 <mm_freak> it's fine if p has to be isomorphic to Either
01:38:02 <fylwind> i'm trying to use Parsec but for some reason it doesn't like it when I feed it lazy "Text" data; says I have to add an instance for (Stream Text Data.Functor.Identity.Identity Char)
01:38:28 <fylwind> but when I look at the docs it says Monad m => (Stream Text m Char) is already defined so I'm a bit puzzled here
01:40:00 <supki> fylwind: did you import Text.Parsec.Text.Lazy?
01:40:09 <supki> (or whenever that instance is defined)
01:41:13 <fylwind> oh I see, that worked; thanks!
01:41:37 <supki> :)
01:41:52 <supki> you can check instances in scope with  :i Stream  in ghci
01:44:21 <mstksg> will Traversable/Foldable's mapM/mapM_ ever become the default versions of those functions?
01:46:41 <johnw> yes!
01:46:45 <johnw> that's coming in 7.10 by all accounts
02:12:50 <mstksg> johnw: thanks! ... what kind of time frame are we talking about here?
02:13:57 <johnw> i'm hoping for apr 2014
02:14:27 <johnw> but maybe late summer
02:15:14 <mstksg> thanks :)
02:41:50 <mel-> Hi
02:43:34 <mel-> I have a weird problem. I am writing a game. For sound effects I am using the SDL-mixer package. Now.... occasionally (not really found a pattern here), a sound effect is somehow simply not played. the putStrLn debugging messages right before and right after the call to SDL-mixer are executed. But no sound. Other times (most of the time) it works.
02:43:48 <mel-> does this problem description ring any bells? I don't know where to search.
02:45:37 <elliott> it sounds more like an SDL problem?
02:45:41 <elliott> the bindings are fairly direct, I think
02:45:51 <elliott> so you could ask in some SDL place and get more expertise
02:46:25 <mel-> hmm, thanks for the hint. i'm kinda lost here.
02:47:00 <mel-> at first i was thinking that i might have hit some lazyness-related problems.
02:47:06 <mel-> but I think I can rule this out.
02:47:25 <elliott> yeah, unless you're using lazy IO stuff you write in IO is going to be pretty much what it says on the tin
02:56:34 <jmcarthur> mel-: fyi, #haskell-game is a thing
02:56:46 <jmcarthur> mel-: but i don't know an answer to your problem, unfortunately
02:57:30 <jmcarthur> mel-: probably everybody in #haskell-game is also in #haskell, but it's still nice because it means game dev is on topic all the time :)
03:05:41 <mel-> jmcarthur: thanks
03:06:07 <mel-> this is so weird. i can only trigger the bug When i name my users "Foo"  and "Bar". When I name them "1" and "2" i cannot trigger the bug. wtf.
03:11:54 <johnw> mel-: are you on Linux?
03:13:20 <mel-> yes
03:13:37 <johnw> just to rule somethingo ut, try running both under valgrind
03:13:47 <johnw> and see if the failing version reports something taht doesn't show up in the working version
03:14:23 <johnw> behavior that varies like you describe always makes me think of memory stompage in the FFI code or the C code
03:16:58 <mel-> i will check that. thanks.
05:11:52 <mikeplus32> @hoogle Maybe (IO ()) -> IO ()
05:11:53 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
05:11:53 <lambdabot> Test.QuickCheck.Test safely :: State -> IO () -> IO ()
05:11:53 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
05:12:57 <byorgey> @type  fromMaybe (return ())
05:12:58 <lambdabot> Monad m => Maybe (m ()) -> m ()
05:13:02 <byorgey> mikeplus32: ^^^ ?
05:13:23 <byorgey> @type  fromMaybe mzero   -- or this?
05:13:24 <lambdabot> MonadPlus m => Maybe (m a) -> m a
05:13:47 <byorgey> probably not, I don't know what mzero does for IO, but it can't be anything nice
05:14:12 <applicative> oh is there an mzero for io?
05:14:24 <mikeplus32> >>> mzero :: IO ()
05:14:25 <mikeplus32> *** Exception: user error (mzero)
05:14:26 <byorgey> @type  (mzero :: IO ())
05:14:27 <lambdabot> IO ()
05:14:38 <byorgey> yes, I guess it just throws a generic exception
05:14:44 <byorgey> ick
05:15:03 <applicative> byorgey: the async library has a wonderful alternative instance for a wrapped io
05:15:09 <byorgey> cool
05:15:14 <mikeplus32> byorgey: i kinda hoped there was something :: Foldable f => f (m ()) -> m ()
05:15:20 <applicative> forever $ threadDelay (maxBound :: Int)
05:15:32 <byorgey> applicative: haha, nice
05:15:55 <byorgey> the async library seems really nice, I hope I get an excuse to use it someday
05:16:48 <applicative> I think I've only used the simplest functions where you don't have subtle control; they're easier than Control.Concurrent
05:17:30 <byorgey> @type  Data.Foldable.foldr (>>) (return ())
05:17:31 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
05:17:37 <byorgey> mikeplus32: ^^^
05:17:43 <mikeplus32> there we go
05:18:15 <mikeplus32> aha
05:18:17 <mikeplus32> it's sequence_
05:18:54 <byorgey> it would be nicer if there were a standard wrapper type  Mobit m = Mobit { runMobit :: m () }  with an  instance Monad m => Monoid (Mobit m)
05:19:08 <byorgey> mikeplus32: ah, so it is
05:19:21 <byorgey> then you could   runMobit . foldMap Mobit
05:24:33 <mbrock> maybe even any monoid instead of ()
05:31:24 <erisco> why might ghci be saying "overlapping instances" and then give "two instances" on the same line in the same file?
05:33:48 <erisco> this certainly wasn't happening a day ago
05:34:16 <icarot> Anyone know if there's a way to treat a named function as a right-section? i.e., a syntax for the (psuedo-haskell) `subtract` 5
05:35:06 <icarot> I just want to be able to do map (`subtract` 5) xs
05:35:20 <mbrock> :t (`filter` "foo")
05:35:21 <lambdabot> (Char -> Bool) -> [Char]
05:35:31 <erisco> > map (subtract 5) [1,2,3]
05:35:34 <lambdabot>   [-4,-3,-2]
05:35:37 <supki> > map (`subtract` 5) [1..10]
05:35:38 <lambdabot>   [4,3,2,1,0,-1,-2,-3,-4,-5]
05:35:48 <erisco> > map (flip subtract $ 5) [1,2,3]
05:35:49 <lambdabot>   [4,3,2]
05:36:03 <erisco> icarot, either of those?
05:36:05 <icarot> erm.. oh. That works? Clearly I messed up badly.. Tried it and it didn't work.
05:36:07 <icarot> Thanks.
05:36:49 <icarot> wait
05:36:50 <icarot> No.
05:36:51 <elliott> flip subtract 5 can also be written (5 -)
05:37:11 <icarot> in "map (`subtract` 5) [1..10]
05:37:18 <icarot> that's a left section. I want a right.
05:37:31 <supki> > map (5 `subtract`) [1..10]
05:37:32 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
05:37:43 <icarot> oh.. heh.
05:37:46 <icarot> of course..
05:37:55 * hackagebot uuagc 0.9.50 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.50 (JeroenBransen)
05:38:00 <erisco> why does ghci hate me...
05:38:10 <byorgey> icarot: instead of  (5 `subtract`) you can just write   (subtract 5) .
05:38:28 <byorgey> that final . was a period, not a composition operator
05:38:50 <donri> if i have an unsafePerformIO in a where-clause it seems ghc shares this between calls. how safe is this, can it ever be GCd if needed?
05:38:58 <icarot> byorgey: Yeah. And somehow I missed that as well. It is too late at night.
05:39:29 <erisco> this is how ghci treats me... http://lpaste.net/92187
05:40:16 <mcstar> > map (+ (-5)) [1..10]
05:40:17 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
05:40:31 <icarot> > :t foldl (+) 1 [1..10]
05:40:33 <lambdabot>   <hint>:1:1: parse error on input `:'
05:40:51 <erisco> :t foldl (+) 1 [1..10]
05:40:52 <lambdabot> (Enum b, Num b) => b
05:41:05 <icarot> wat.
05:41:17 <icarot> oh
05:41:26 <icarot> :t foldl (+) 1 [1..10]
05:41:27 <lambdabot> (Enum b, Num b) => b
05:42:14 <pentace> erisco: Is Parser from another module or defined by you?
05:42:24 <erisco> pentace, defined by me
05:42:50 <pentace> Can you paste the code too, please?
05:42:53 <icarot> > map $ map $ map (+1) [[[1..10]]]
05:42:54 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[[[t0]]]'
05:42:54 <erisco> no
05:42:57 <icarot> damn.
05:43:08 <icarot> Thought I could be clever, that I did.
05:43:21 <pentace> erisco: Why not? :o
05:43:27 <erisco> top secret
05:44:04 <mcstar> the filename has play in it, he is joking
05:44:45 <erisco> mcstar, are YOU joking?
05:44:52 <erisco> because I'm not joking
05:44:58 <mcstar> me neither
05:45:20 <tikhon> > map (map (map (+1))) [[[1..10]]]
05:45:22 <lambdabot>   [[[2,3,4,5,6,7,8,9,10,11]]]
05:47:28 <pentace> erisco: Not even the instance definition?
05:47:40 <erisco> there is nothing special about it
05:47:49 <erisco> I am not joking http://lpaste.net/92188
05:48:48 <erisco> this seemingly is only happening on data types I introduce with ghci
05:50:02 <erisco> once I introduce a custom data type, I get the error message
05:50:05 <erisco> and the more data types I introduce
05:50:10 <erisco> the more the error message repeats
05:50:14 <pentace> Looks like a bug in GHC to me
05:50:39 <erisco> really? because I define plenty of data types and use them just fine in the source file I load
05:50:48 <erisco> hell breaks loose on the interactive shell though
05:51:02 <erisco> not that this isn't the first time ghci has crashed, or given wrong answers
05:51:35 <erisco> once I define a data type, I can't use any of the data types defined in the file anymore either
05:51:48 <erisco> but can before then
05:52:06 <byorgey> erisco: what version of GHC/ghci?
05:52:07 <elflord> i have a project folder, what program can list all the functions defined within this project ?
05:52:13 <byorgey> sounds like a bug to me too
05:52:17 <elflord> in other words, is there a code browser ?
05:52:20 <elflord> for haskell code
05:52:56 <erisco> byorgey, ghci 7.4.2, ghc 7.4.2
05:53:07 <byorgey> elflord: an IDE like leksah or EclipseFP can do that.
05:53:32 <pentace> elflord: You could build the haddock documentation which creates a function and data type index
05:53:33 <byorgey> erisco: can you give me some exact steps to reproduce?  I will try it on GHC 7.6
05:54:16 <byorgey> erisco: note that the ability to define data types at the ghci prompt was a brand-new features in 7.4, so it wouldn't surprise me if there were a few bugs
05:54:32 <erisco> uhh... currently this is 200 lines of code I can't post... but I will try and simplify the reproduction steps
05:55:22 <erisco> byorgey, give me a few minutes
05:55:28 <byorgey> OK
05:57:17 <mcstar> lol @ brian hurt, and his technical definition of 'an idiot programmer'
05:57:47 <erisco> byorgey, well that was easy
06:00:17 <erisco> byorgey, http://lpaste.net/92189
06:01:11 <haasn> I find myself using “import Control.Lens ((??))” often
06:01:13 <erisco> mcstar, see I'm not crazy
06:01:55 <mcstar> erisco: i never supposed you were...
06:03:26 <erisco> so solution in the meantime is to just define it in the source file, I guess
06:09:50 <mcstar> what would be the purpose of A0 <$> Foo 1 ?
06:10:06 <mcstar> it makes sense for $
06:10:32 <erisco> mcstar, ya know, I might have messed up, but it doesn't matter :P
06:10:41 <mcstar> do you want A0 applied to the 1 inside Foo?
06:10:44 <lpaste> byorgey pasted “testing erisco's bug on GHC 7.6” at http://lpaste.net/92190
06:10:58 <byorgey> erisco: looks like it was a bug in 7.4, which is fixed in 7.6
06:11:14 <byorgey> erisco: if you are able to upgrade, I strongly recommend it.  7.6 is what comes with the latest Haskell Platform.
06:11:43 <erisco> okay thanks
06:12:31 <pentace> erisco: Does it work if you use type-correct expressions?
06:13:21 <erisco> pentace, no
06:13:29 <edwardk> ReinH: i think you forgot to make your video public
06:13:31 <erisco> I goofed on the example, but it doesn't matter
06:13:40 <pentace> okay
06:27:02 <edwardk> haasn: heh, clearly i should have stuck to my guns and made that (?)
06:27:48 <haasn> edwardk: (what did it collide with?)
06:28:38 <edwardk> someone or other complained about the fact that they use ? a lot in their own code for foo ? (a,b)   boolean based if or something
06:28:46 <edwardk> and i didn't think it'd be useful enough
06:29:05 <haasn> I think “foo ?? x” is a really clean way to write “(`foo` x)”
06:29:11 <haasn> you just have to know the mnemonic for it
06:29:15 <haasn> ‘parameter goes here’
06:30:23 <haasn> I think the precedence could be a bit higher though
06:30:34 <haasn> since in that respect it's like function application
06:30:48 <haasn> but then again, ‘flip foo x’ works for cases where you need really high precedence
06:31:51 <Hafydd> That's a stupid and misleading mnemonic, in my opinion.
06:34:53 <bennofs> Why is it "data ReaderT r m a = ReaderT (r -> m a)" and not "data ReaderT r m a = ReaderT (m (r -> a))"?
06:35:26 <bennofs> All the other monad transformers seem to just embed their non-transformer version in m
06:35:58 <edwardk> bennofs: the representability of (r -> ) says you can always factor it out of any functor
06:36:44 <edwardk> bennofs: it has to do with limits vs. colimits. other functors use strength, the reader one uses the ability to pull (r -> ) out
06:36:56 <edwardk> er most other monads
06:37:11 <bennofs> edwardk: But can you also factor (r ->) "in" (opposite direction)?
06:37:33 <edwardk> no.
06:37:45 <edwardk> try to write (r -> m a) -> m (r -> a)
06:37:52 <apfelbox> How can I print a generic data structure (in the GhcMonad)?
06:38:09 <apfelbox> Ok, printing is clear to me, transforming to a string is not
06:38:11 <byorgey> no, because with (r -> m a) the effects might be different for each r; there's no way to do the effects first before you've seen the r value
06:38:28 <apfelbox> I tried  showSDoc dynFlags $ ppr pgm (pgm is of type ModGuts and I want to print it)
06:38:32 <edwardk> you can go m (r -> a) -> r -> m a  using foo mra r = fmap ($r) mra
06:39:04 <edwardk> but going the other direction requires picking a 'shape' for m independent of r
06:39:28 <edwardk> you can only do that when m is representable… which is to say that m itself must be isomorphic to (s -> ..)  for some s
06:39:46 <edwardk> which means (r -> s -> a) -> s -> r -> a)  would be how you'd distribute. which is flip
06:41:31 <quchen> apfelbox: There's a #ghc channel for questions specific to it, I think some GHC devs aren't watching #haskell as closely as #ghc. You may get your answer faster there.
06:42:00 <apfelbox> all right, thanks
06:45:40 <k00mi> bennofs: note that StateT is also s -> m (a, s)
06:48:40 <valyagolev> in which European universities people research haskell-related themes?
06:48:51 <valyagolev> are where any "centers"
06:49:02 <quchen> Utrecht has its own compiler
06:49:03 <Maior> valyagolev: MSR in Cambridge?
06:49:07 <applicative> utrecht for sure.
06:49:16 <Maior> (fsvo "European")
06:50:05 <valyagolev> thank you!
06:50:35 <liyang> CL in Cambridge too; Nottingham, Strathclyde, Oxfnord, York.
06:51:12 <liyang> Don't forget the 'burgh.
06:51:33 <applicative> no, in pittsburgh we do ML
06:51:36 <applicative> ;)
06:51:38 <srhb> Glasgow died?
06:51:47 <srhb> Ironical.
06:51:52 <valyagolev> is there something going on in ETH?
06:52:18 <valyagolev> or germany
06:52:40 <applicative> valyagolev you should probably improve your question to be something about functional programming and type theory
06:53:03 <valyagolev> applicative, you probably right, but wouldn't the answer be "everywhere"? :)
06:53:11 <applicative> hah
06:53:17 <mcstar> is ghc the microsoft haskell compiler now?
06:53:26 <quchen> mcstar: Out.
06:53:29 <quchen> :-P
06:53:47 <applicative> mcstar: i think windows integration would be a little more advanced
06:53:54 <liyang> srhb: left a Glorious legacy though.
06:54:03 <valyagolev> I hope I don't annoy you by this. I just feel that it's a good idea to choose a place to study by the research they do there, and I'm not quite sure how to find good places like that
06:54:26 <liyang> mcstar: not quite, but Intel has one these days.
06:54:33 <liyang> (to their name at least.)
06:56:23 <mcstar> i just googled it, isnt it 'just' a modification of ghc with simd extension?
06:56:44 <mr-> valyagolev: I think in Leipzig (where the last haskell user group meeting took place) there is some FP going on
06:56:50 <quchen> mcstar: No, it takes GHC Core and does its own thing from then on
06:56:53 <applicative> Uustalu and Vene are in Estonia valyagolev
06:56:54 <mcstar> hm, i had the pdf in my download folder already... i must be sleep-reading
06:58:37 <applicative> they are trying to put 'simd' material in vector and dph.
06:58:46 <valyagolev> oh, thank you, didn't think of baltics
06:59:31 <mcstar> it comes a little late though, im thinking of using haskell for opencl code generation
07:00:19 <bennofs> is "data ReaderT r m a = ReaderT (m (r -> a))" even a monad? (When m is only a monad)
07:01:02 <mcstar> (but simd is still useful, ofc, i welcome it)
07:02:41 <k00mi> valyagolev: I saw the head of the CS department at LMU (munich) posts to haskell mailing lists ;)
07:03:29 <mcstar> i just read 'dsl implementation in metaocaml, template haskell and c++' by czarnecki, odonnel, striegnitz, tana
07:03:38 <mr-> valyagolev: Also, I think, there is some type theory in Darmstadt
07:04:04 <valyagolev> every damn university has a course in Economics and Business Administration in english
07:04:17 <mcstar> it is nice to learn c++ template programming when you see the problem implemented in functional languages too
07:04:44 <mcstar> i didnt know you could represent the ast of c++ with templates
07:04:52 <valyagolev> have you heard about any research from russian universities?
07:05:17 <valyagolev> mr-, k00mi thank you, checking them out!
07:06:15 <mcstar> metaocaml is apparently a type safe macro language on top of ocaml, i wonder, why isnt there one for haskell?
07:06:34 <Hafydd> Is TH not one?
07:06:41 <mcstar> i think not
07:06:59 <valyagolev>  TH is not type-safe I believe
07:07:17 <mcstar> there are no static guarantees to the generated code
07:07:21 <delYsid> Is there a trick to use functions (like minBound) in a pattern?
07:07:33 <valyagolev> http://okmij.org/ftp/meta-programming/index.html Tagless-Staged: a step toward MetaHaskell (just had a tab opened)
07:07:46 <Hafydd> delYsid: using a guard
07:07:49 <mcstar> but it didnt lead to anything, afaict
07:07:54 <mcstar> re oleg
07:08:05 <rul> Hello. I'm inside the Update monad (http://hackage.haskell.org/packages/archive/ncurses/0.1/doc/html/UI-NCurses.html) and I need to do some IO. The problem is that Update is not an instance of MonadIO, so I can't liftIO the result of my IO. Any ideas? Thanks!
07:08:09 <valyagolev> delYsid http://ghc.haskell.org/trac/ghc/wiki/ViewPatterns ? :)
07:08:10 <delYsid> Hafydd: oh, of course, thanks.
07:08:11 <liyang> mcstar: wat. TH-generated code is typechecked.
07:08:37 <mcstar> liyang: thats not what a typesafe meta language guarantees
07:08:39 <k00mi> valyagolev: FAU in erlangen also does some research involving monads in programming languages
07:08:51 <mcstar> the question is, can you generate not well typed code or not
07:08:52 <valyagolev> k00mi erlangen :))
07:09:24 <liyang> mcstar: you could… but it won't compile? :-/
07:10:26 <mcstar> afaik TH expressions are all Q Exp, they are unityped(?)
07:10:29 <liyang> mcstar: I'm not sure what you mean in that case. Is that even possible?
07:10:52 <liyang> (In Haskell. Or anything else production-quality.)
07:11:16 <applicative> rul newtype Update a = Update { unUpdate :: ReaderT Window Curses a }
07:11:30 <applicative> rul: , Curses is MonadIO.
07:11:35 <scooty-puff> is it possibly to fuse in vector something comparable to concatMap, but with defined sizes of the produced "v b" in "a -> v b"?
07:12:02 <scooty-puff> something like [0..n] ++ [1..n] ++ [2..n] ++ ... ++ [n - 1..n] is what i'm going for
07:12:07 <tomejaguar> What's the benefit of a typesafe metalanguage, given that the code it produces will be type checked anyway?
07:12:17 <scooty-puff> comparable i guess to map f xs ++ map g xs maybe?
07:12:23 <tikhon> tomejaguar: it makes debugging your meta-program easier
07:12:50 <tomejaguar> tikhon: How?  By giving errors slighly earlier?
07:12:53 <byorgey> tomejaguar: better, earlier error messages (and hence what tikhon said).
07:13:04 <tomejaguar> Right
07:13:19 <scooty-puff> i.e. if a Stream's Step is replayed, will inefficiency result?
07:13:29 <mcstar>  liyang: 'MetaOCaml is a language with static types. Though code objects are generated and executed at run time, its type system guarantees the type correctness of run-time generated code at the time the program is compiled.'
07:13:29 <rul> applicative: yes, with Curses I can do IO without problems, but I have not clue on how to do IO _inside_ an Update monad
07:14:16 <mcstar> so, it provides the guarantee when you compiled your code generator
07:14:27 <applicative> @type lift
07:14:27 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:14:29 <valyagolev> rul, try unUpdating it to get a readerT on top of Curses
07:14:35 <mcstar> all the code it generates will type-check
07:14:36 <tomejaguar> Ah that's interesting.  So a typesafe metaprogramming system allows you to delay running the macros until compile time.
07:14:42 <valyagolev> @type lift . unUpdate
07:14:43 <lambdabot>     Not in scope: `unUpdate'
07:14:43 <lambdabot>     Perhaps you meant one of these:
07:14:43 <lambdabot>       `uniplate' (imported from Data.Data.Lens),
07:14:52 <edwardk> heh
07:14:53 <byorgey> tomejaguar: also, consider that the person writing the code generator and the person running it may be different
07:15:09 <tomejaguar> byorgey: That's a good point.
07:15:25 <rul> valyagolev: Ok, I'll try!
07:15:27 <byorgey> tomejaguar: you would much rather have the person writing it find out about type errors when they are writing it.
07:15:31 <tomejaguar> If you write a package you want to put it on Hackage confident that it will compile for everyone.
07:15:41 <applicative> no he wants liftToUpdate io = Update $ lift (liftIO io) or something
07:15:42 <byorgey> confident that it will generate code that compiles for everyone.
07:15:48 <haasn> I once saw an evil program where somebody write x86 opcodes as a String and did something naughty with unsafeCoerce etc. to execute it
07:16:01 <haasn> does anybody know what I might be thinking of?
07:16:12 <mcstar> yes
07:16:27 <mcstar> build a haskell function from instructions from a string
07:16:32 <mcstar> mauke has that
07:16:36 <applicative> rul: in "liftToUpdate io = Update $ lift (liftIO io) " liftIO makes the IO a Curses; lift makes it a ReaderT blah Curses blah; Update makes that an update
07:17:12 <mcstar> unsafeFunPtrFromAddress or something similar
07:17:17 <tomejaguar> refactor-bot says: liftToUpdate = Update . lift . liftIO
07:17:19 <haasn> mcstar: yes I seemed to remember mauke as the other, but where can I find it? :)
07:17:26 <mcstar> ask him
07:17:46 <applicative> rul: I might be leaving something out but thats what it looks like
07:17:49 <mcstar> his solution was much earlier, than the one from a blog post on the net that someone linked here
07:18:12 <rul> applicative: oh, that's very kind of you, I'll try it. Thanks!
07:18:54 <ajovanov> hello
07:19:08 <ajovanov> what is the levenstein distance between hello and halo?
07:19:25 <mcstar> OT?
07:19:29 <ajovanov> http://planetcalc.com/1721/ says it is 2 but I think it is 3. am I wrong
07:20:11 <Lethalman> ajovanov, it's 2: you edit e to a, and delete l
07:21:21 <rul> applicative: Mmmm, it seems that the library does not export Update constructor: "Not in scope: data constructor `Update'"
07:21:28 <ajovanov> Yes i get it. I thought you first deleted and then replaced. :)
07:21:36 <ajovanov> letters
07:22:24 <ajovanov> anyways what do you think of this not so perfect edit distance alghoritm that is wrong in "hello" "halo" case
07:22:30 <ajovanov> http://ideone.com/UOxi6a
07:23:15 <mcstar> it does not work
07:23:41 <ajovanov> I got that, other than that :)
07:24:22 <mcstar> the page, that defined the lev. distance, shouldnt it say the the distance is the `minimum` number of operations such that... ?
07:24:30 <mcstar> that the*
07:25:17 <ajovanov> Yes I got that once Lethalman told me why I was wrong. Oh well, back to recursion then :D
07:25:45 <mcstar> im just saying, the definition is incomplete
07:26:00 <haasn> mcstar: doesn't seem to be here =/ http://mauke.hopto.org/stuff/haskell/
07:28:10 * hackagebot pontarius-xmpp 0.3.0.0 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.3.0.0 (JonKristensen)
07:29:17 <mcstar> haasn: im grepping my haskell dir, lets see
07:29:57 <haasn> mcstar: thanks, I'd appreciate finding it :)
07:33:46 <valyagolev> so there's no way to use xmonad on mac os for native apps (browser, sublime, iterm) :(
07:34:06 <enthropy> valyagolev: probably not
07:34:35 <enthropy> there is somewhat related https://github.com/xmonad/osxmonad
07:34:52 <valyagolev> wow
07:34:58 <enthropy> but chances are that it doesn't work very well
07:35:17 <valyagolev> Brian McKenna
07:39:15 <mcstar> haasn: sr, im failing
07:39:43 <haasn> me too :(
07:41:09 <mcstar> @hoogle castPtrToFunPtr
07:41:52 <haasn> http://mainisusuallyafunction.blogspot.de/2010/09/executing-bytestring.html
07:41:54 <haasn> ah
07:42:07 <haasn> yes taht's the function it seems
07:42:09 <mcstar> yeah, just was about to paste
07:42:29 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
07:42:42 <mcstar> ?
07:43:04 <mcstar> lambdabot: were you taking a coffee break?
07:45:45 <haasn> mcstar: perfect, thanks :)
07:46:23 * byorgey is disturbed that no functions named  unsafe... show up anywhere in that blog post
07:46:45 <byorgey> I suppose  castPtrToFunPtr  is the unsafe bit
07:46:48 <DMcGill> ffi is inherently unsafe
07:46:52 <mcstar> the black hat haskell community is aware that those are unsafe
07:46:58 <byorgey> ok, fair enough.
07:48:38 <DMcGill> what would a "safe" ffi look like? You'd program your subset of C in a DSL inside Haskell?
07:48:54 <FreeFull> haasn: I only wish that the ASM in the comments used intel syntax
07:50:15 <pentace> In gtk2hs, how do you get the underlying model from a TreeModelSort if it's not a TreeModel but e.g. a ListStore?
07:50:21 <byorgey> DMcGill: well, you could require every ffi call to live in the IO monad.
07:50:42 <edwardk_> byorgey: Bleach
07:50:49 <edwardk_> Blech even
07:50:53 <byorgey> I am not actually advocating for this!
07:50:54 <DMcGill> you'd still be able to segfault and corrupt memory at will
07:51:06 <dcoutts> pentace: if you need the original specific model type then you just have to hold onto it, you cannot recover it by downcasting
07:51:17 <DMcGill> can you do that with IO at the moment?
07:51:36 <pentace> dcoutts: Oh, too bad. Is there a special reason for that?
07:51:41 <dcoutts> pentace: you can only get the generic TreeModel interface directly from the view or wrappers like TreeModelSort
07:51:44 <dcoutts> pentace: the type
07:52:20 <dcoutts> pentace: you can make a view or a wrapper like TreeModelSort using *any* TreeModel instance, and that fact is not reflected in the type of the view or the wrapper
07:53:26 <pentace> dcoutts: But couldn't treeModelSortGetModel return a TreeModelClass or something generic?
07:54:05 <dcoutts> pentace: which instance would it return?
07:54:28 <dcoutts> pentace: it could give you a TreeModel but not a ListStore
07:54:38 <pentace> the one of the infered type, I guess
07:54:50 <dcoutts> that would not be type safe
07:55:22 <dcoutts> pentace: generally it's not a big deal to just hold onto the model and the view
07:55:37 <mcstar> lol @ brian h. comparing implementing STM in
07:55:39 <DMcGill> Oh yeah, of course you can do anything you want inside IO by shelling out. Oops.
07:55:43 <mcstar> premature enter
07:55:53 <mcstar> ... c# vs. haskell
07:55:57 <pentace> dcoutts: Indeed. Thanks!
07:56:25 <DMcGill> wasn't STM originally designed for C# but the presence of side effects maybe retry unusable?
07:57:09 <dcoutts> pentace: actually gtk2hs does have some support for downcasting, but I think it doesn't actually work for the instances defined within Haskell like the ListStore etc
07:57:11 <mcstar> i read that the non-existence of IO made it impossible to impelment it
07:57:36 <dcoutts> pentace: the glade/builder support uses the downcasting (which obviously can fail at runtime)
07:57:42 <mcstar> any snippet could casue side effects, and those are not revokable...
07:58:00 <mcstar> but then, i dont understand why did they need 2 years an many developers to figure this out..
07:58:06 <mcstar> and*
07:58:14 <DMcGill> they tried making a non-IO subset of C# iirc
07:58:24 <DMcGill> but it was pretty impossible
08:01:20 <pentace> dcoutts: Perhaps you can answer another question too: Some of the TreeModel functions need TreePath *and* TreeIter arguments. Why is that? Because for custom models you have to define functions to convert one into the other
08:02:14 <dcoutts> pentace: it's a pita, the gtk+ C functions use a mix, the "fast" form is the iter, the persistent form is the path
08:02:48 <pentace> I see
08:04:25 <DMcGill> latest pet hate: in glfw-b, there is 'getCurrentContext' and 'makeContextCurrent'
08:04:37 <DMcGill> I mean it kind of makes sense if you think about it but it's still tripped me up several times
08:08:18 <pentace> dcoutts: And when is it safe to use a "stamp" of 0 for a TreeIter object?
08:08:48 <dcoutts> pentace: do you understand what the stamps are for?
08:09:11 <pentace> Not really
08:09:31 <dcoutts> you need to if you're implementing a new model, and then you'd know the answer to that Q
08:09:40 <mcstar> ok, so i learned, that haskell gives you working code sooner
08:09:49 <dcoutts> pentace: it's to detect the use of stale iters by clients like views
08:10:20 <mcstar> i wonder, if he counted in the time it takes to learn haskell, to actually create working code faster
08:10:44 <dcoutts> pentace: the model maintains a current stamp and all iters it hands out include that stamp. Then whenever the model needs to invalidate all outstanding iters it just increments its own internal stamp.
08:10:51 <quchen> mcstar: Did you count the time to learn C++ for the alternative?
08:11:08 <mcstar> i knew someone would bring it up
08:11:40 <dcoutts> pentace: iirc the thing gtk2hs gives you to help you implement your own models has a function for incrementing/invalidating the stamps
08:11:40 <quchen> Funny how good counter-arguments work.
08:11:53 <mcstar> still, haskell is much less commonplace than c++ for example, so ppl have working c++ knowledge with a higher probability
08:12:16 <dcoutts> pentace: and iirc, the stamps are also checked. So what's the answer to your question?
08:13:00 <pentace> dcoutts: I implemented a new model and made a mistake at first, i.e. not getting the stamp from the model but returning 0 which resulted in gtk errors.
08:13:21 <pentace> dcoutts: So i'm still a bit confused when returning 0 is okay and when it is not
08:13:38 <dcoutts> pentace: right, a stamp of 0 will be always wrong, as soon as you change the model
08:13:45 <haasn> “foldl' f z xs = xs `seq` foldl f z xs” my sides
08:14:44 <dcoutts> pentace: because once you increment the model's internal stamp, then it's >0 and so all outstanding iters that have stamp 0 are now invalid. If you hand out any new ones that have stamp 0 then they are invalid too.
08:15:17 <DMcGill> haasn: when you want to be REALLY sure that you're spine strict
08:15:17 <dcoutts> pentace: the rule is, hand out iters with the current stamp, and they'll be valid until the model next changes (and increments its internal stamp)
08:16:34 <pentace> dcoutts: ATM I return 0 in all functions of TreeModelIface and it works, although I think some of these functions should be called after the model has changed
08:17:09 <dcoutts> pentace: if you follow the rule, it'll work
08:18:17 <pentace> dcoutts: Okay, thanks for the help
08:26:04 <haasn> oh! A while ago, I stumbled across Elm again, remembering Ur and wondering why it was so different from what I remembered
08:26:06 <haasn> no wonder
08:26:19 <haasn> seems I mixed those two up
08:27:50 <lpaste> scooty-puff pasted “Fusible tails for Vector” at http://lpaste.net/92193
08:28:11 * hackagebot free-functors 0.5 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.5 (SjoerdVisscher)
08:34:50 <lpaste> scooty-puff annotated “Fusible tails for Vector” with “Fusible tails for Vector (annotation)” at http://lpaste.net/92193#a92196
08:40:59 <Eduard_Munteanu> I'm parsing some text table that's got a fixed number of columns, and I find myself working with 16-tuples and that sort of thing to preserve type safety. I guess that can be done more nicely with some TH, SYB or other things like that. What do you suggest?
08:42:19 <Eduard_Munteanu> Well, types are also polluted, I got something like  data Record  a b c d  e f g h  i j k l  m n o p  ...
08:43:25 <bennofs> Isn't using something like threepenny-gui (A GUI server library) potentially a security risk? If that application allows the user to load documents from the disk, then that application would allow ANYONE on the same machine to read the files of the user who started it. I'm not sure if that is a big problem through ...
08:43:57 <srhb> Eduard_Munteanu: If every column is that unique, and every row has relevant information that you want to parse, how would you get around the gargantuan 16-tuple or custom data type?
08:44:05 <srhb> Eduard_Munteanu: Or is that not what you're complaining about?>
08:44:47 <Eduard_Munteanu> srhb: the column types aren't fixed, they depend on what the first column is.
08:45:13 <ReinH> Argh, why is the video private :/
08:45:14 <srhb> Ah.
08:45:15 <Eduard_Munteanu> They're also optional (can be null).
08:45:21 <Eduard_Munteanu> Some of them at least.
08:45:23 * mcstar says type level heterogeneous lists
08:45:47 <srhb> That does sound abominable. :-)
08:45:53 <Eduard_Munteanu> In case you're wondering I'm writing a frontend for the so-called "machine-readable" gnupg output.
08:45:55 <bennofs> Eduard_Munteanu: what do you by "the column types aren't fixed" ?
08:46:19 <hape02> the first column determines the columns of payload
08:46:20 <Eduard_Munteanu> bennofs: a certain column can be a date or a string or an integer depending on what the first field says
08:46:44 <bennofs> Eduard_Munteanu: that means the types aren't specific until runtime?
08:46:45 <Eduard_Munteanu> The format is pretty bad IMO.
08:47:03 <srhb> Maybe a tree type with different leaf types is more fitting then, but yeah, I have no insights on the problem at hand.
08:47:04 <hape02> this format is quite often used
08:47:05 <Eduard_Munteanu> bennofs: for a given first column they are fixed / specific.
08:47:42 <Eduard_Munteanu> Hm, I have an idea.
08:47:59 <bennofs> Eduard_Munteanu: But you cannot have types that depend on runtime data in haskell (at least it's not simple)
08:48:00 <Eduard_Munteanu> Maybe I should first convert to a saner text format.
08:48:16 <mcstar> and lose typing?
08:48:29 <hape02> with algebraic data types you should get a representation of your file conent I guess
08:48:30 <Eduard_Munteanu> mcstar: what typing? The original text data isn't typed :)
08:48:41 <mcstar> ah ko
08:48:51 <mcstar> i didnt know it came from text
08:49:02 <mcstar> i was thinking of a database
08:49:08 <Eduard_Munteanu> bennofs: sure, but you can construct different data types depending on what the first column says
08:49:11 <srhb> I don't see what you'll gain by that.
08:49:22 <scooty-puff> how much sharing should stream fusion be expected to preserve?  if a stream is replayed, should the reyeilded be shared from the original yeilded values?
08:49:47 <srhb> It makes more sense to have an enclosing data type that represents a row, like data Row = Date FooStuff | Name BarStuff | ...
08:49:54 <bennofs> Eduard_Munteanu: Ok, so you're having something like data Row = FirstColumPossibility1 SomeRowType | FirstColumPosibilit2 ... ?
08:49:59 <Eduard_Munteanu> srhb: well that makes it simpler to parse if I shuffle stuff around and I know the type of each thing.
08:50:02 <srhb> And then have the corresponding types of the following fields in those included types.
08:50:28 <Eduard_Munteanu> bennofs: something like that, I have a bunch of GADTs though
08:50:31 <srhb> Eduard_Munteanu: Well you have to make a decision at some point anyway, why not do it right away? "ok, first field was a date, so we parse into Date FooStuff..."
08:50:42 <srhb> That's just me though. :-)
08:51:13 <srhb> Intermediate text formats seem like a lot of trouble for no real gain.
08:53:30 <Eduard_Munteanu> srhb: I don't mean that, I mean I should strip out the unneeded columns and decide types for the remaining ones before parsing the columns.
08:53:59 <Eduard_Munteanu> Still, I'll end up using (!!) and that sort of things.
08:54:10 <Eduard_Munteanu> Maybe I worry too much.
08:56:08 <Eduard_Munteanu> Hm, yeah, I probably want to do too much at the type level, too much considering the untypedness of the input.
08:58:37 <ReinH> morning all
08:58:46 <Eduard_Munteanu> ReinH: hi
08:59:15 <mcstar> hm, so a compiler is a partial evaluator of source code as static input
08:59:18 <mcstar> interesting
09:00:24 <monochrom> yes, isn't that idea fascinating? :)
09:04:24 <ReinH> tel: Glad you enjoyed the podcast :)
09:05:55 <tel> ReinH: Thanks for putting it together!
09:06:09 <tel> ReinH: I did
09:06:23 <ReinH> tel: np, edwardk is an awesome guest
09:06:38 <edwardk> i had a lot of fun
09:07:00 <edwardk> i was surprised at how coherent it sounded for the first part =)
09:07:18 <mcstar> what was the subject of the podcast?
09:07:18 <edwardk> ReinH++
09:07:22 <barrucadu> mcstar: monochrom: A somewhat different intuition of compilers that one of my lecturers gave me last year is that a compiler is a program which takes something expressed in one formal language and translates it into another
09:07:22 <edwardk> (and ChrisForno++)
09:07:26 <ReinH> edwardk: :D
09:07:38 <ReinH> He did a good job with the editing
09:07:39 <barrucadu> So now I look at lots of things and think "that's a compiler problem"
09:08:04 <edwardk> mcstar: Haskell in general, how I found it, code reuse, the haskell committees, cellular automata, comonads, laziness, etc.
09:08:15 <edwardk> mcstar: it is pretty broad ranging
09:08:20 <mcstar> barrucadu: that is a more 'trivial' observation imho
09:08:27 <ReinH> also lenses
09:08:29 <ReinH> :)
09:08:32 <edwardk> the middle bit tries to articulate why lenses/prisms work, which probably is a bit ambitious for the medium
09:08:47 <ReinH> edwardk: I learned something from it!
09:08:50 <edwardk> but i thought the start/end worked really well for a general audience
09:08:51 <mcstar> is it publicly available?
09:08:55 <ReinH> But I had to listen to it a couple times.
09:08:59 <ReinH> mcstar: haskellcast.com
09:09:03 <mcstar> ty
09:09:05 <ReinH> And on iTunes soon
09:09:12 <edwardk> mcstarhttp://www.haskellcast.com/episode/001-edward-kmett-on-lenses/
09:10:06 <mcstar> that would be an awesome way to address links ^
09:10:19 <ReinH> heh
09:10:25 <ReinH> mcstar://
09:10:35 <mcstar> :)
09:10:38 <ParahSailin> is proc and arrow do in ghc?
09:10:39 <ReinH> In the future, everyone will provide a REST API
09:11:50 <joeyh> yay, finally a podcast
09:12:23 <bergmark> PVP question, if an exported function type is generalized, can I do a D bump? I can't think of any way that could break dependents
09:12:39 <bennofs> Isn't using something like threepenny-gui (A GUI server library, spawns a server and pushes commands to JS Client) potentially a security risk? If that application allows the user to load documents from the disk, then that application would allow ANYONE on the same machine to read the files of the user who started it. I'm not sure if that is a big problem through ... (Link to threepenny:
09:12:39 <mcstar> barrucadu: what is your definition of an 'interpreter'?
09:12:41 <bennofs> https://github.com/HeinrichApfelmus/threepenny-gui)
09:13:48 <mauke> haasn: http://mauke.hopto.org/stuff/haskell/hell.hs
09:13:59 <bennofs> bergmark: It could perhaps break because of ambiguous type errors
09:14:00 <haasn> mauke: thanks!
09:14:25 <haasn> I wonder why I didn't recognize it when digging through that folder earlier
09:14:32 <bergmark> bennofs: ah, good point, thanks
09:14:59 <barrucadu> mcstar: I haven't really thought about it, but I guess a program which takes {source,byte}code and executes it
09:15:25 <notdan> ~Chris Forno makes nice videocasts about Haskell, IMO
09:15:42 <bergmark> this also contains a major feature that only resulted in a D bump otherwise, so feels good to do a bigger bump to signify the importance :)
09:16:23 <mcstar> barrucadu: would you consider something that turns source code into byte code a compiler?
09:17:26 <zq> how to make slice like (+1) but neg?
09:17:31 <zq> s/neg/subtract/
09:17:50 <zq> :t (-1) == Num a
09:17:51 <lambdabot>     Not in scope: data constructor `Num'
09:17:51 <lambdabot>     Perhaps you meant `Sum' (imported from Data.Monoid)
09:17:56 <zq> :t (-1)
09:17:57 <lambdabot> Num a => a
09:17:59 <bennofs> zq: Use subtract
09:17:59 <zq> :t (- 1)
09:18:01 <lambdabot> Num a => a
09:18:01 <mauke> :t subtract
09:18:01 <bennofs> :t subtract 1
09:18:02 <lambdabot> Num a => a -> a -> a
09:18:02 <lambdabot> Num a => a -> a
09:18:07 <zq> :t subtract
09:18:08 <lambdabot> Num a => a -> a -> a
09:18:08 <barrucadu> mcstar: I think I see where you're going with this. Yes.
09:18:13 <zq> :t subtract 1
09:18:14 <lambdabot> Num a => a -> a
09:18:26 <zq> > map (subtract 1) [1..10]
09:18:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
09:18:33 <mcstar> barrucadu: i dont even know where im going with this :) just asking questions..
09:18:34 <zq> bennofs: thanks
09:19:12 <mcstar> just thinking about the difference between interpreted and compiled languages
09:19:48 <mcstar> i know very little about compilers, in the CS sense, but thinking about learning some code generation skills
09:19:57 <barrucadu> mcstar: heh, I thought you were then going to point out that most people don't use the term compiler in that way, so my intuition is for a slightly different, but related, concept
09:20:35 <mcstar> barrucadu: you are right, but i was not making a point, just conversing
09:20:39 <geekosaur> this is a slippery slope. is javac a compiler? how about clang?
09:20:57 <zq> both are
09:21:07 <zq> the 'c' in javac denotes 'compiler'
09:21:13 <geekosaur> yet both generate bytecode
09:21:29 <hiptobecubic> compilerlang
09:21:36 <mcstar> right! you hit it! but it makes me wonder, what IS control?
09:21:38 <zq> technically clang generates an object file
09:21:40 <zq> and more
09:21:43 <geekosaur> (llvm generates native code from the bytecode; the java toolchain typically doesnt although see gcj)
09:22:08 <zq> just poll the dragon book for a semantic definition of compilation
09:22:17 <zq> s/semantic/precise/
09:22:22 <bennofs> I'd define a compiler as anything that produces output which has to be further evaluated to obtain the result.
09:22:38 <zq> i'd define compiler as anyting that builds a parse tree out of input
09:22:56 <mcstar> that is clearly wrong
09:22:59 <zq> (and produces some non-trivial output)
09:23:02 <geekosaur> (note that one of the points of llvm is that you can stop at the llvm bytecode phase to get soemthing which can be quickly "native-ized" for multiple targets in a heterogeneous cluster, so I'm not just talking about hidden internals that nobody ever cares about)
09:23:18 * hackagebot xmlhtml 0.2.2 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.2 (DougBeardsley)
09:23:35 <mcstar> llvm is awesome
09:23:36 <monochrom> "compiler" is better left ambiguous, like "computation"
09:23:51 <zq> lines get blurred
09:23:55 <zq> that's the most general definition
09:24:12 <scshunt> geekosaur: *sort of*
09:24:26 <scshunt> geekosaur: in practice, you can't do so in a useful manner
09:24:48 <scshunt> geekosaur: unless you really try hard to make sure you can
09:24:57 <scshunt> C, for instance, has integer widths that vary by platform
09:25:18 <mcstar> clearly, you shouldnt use integers if they are not portable
09:27:07 <chirpsalot> mcstar: none of the data types in C are portable.
09:27:09 <monochrom> joke but precise definition: a compiler is whatever process that gives you the license to http://xkcd.com/303/
09:28:11 <`Jake`> Since there is going to be a Typeable instance for every type in the future, what's going to happen if one tries "typeOf undefined"? Will ghc still say that there's no Typeable instance for a?
09:28:23 <geekosaur> and none of that is particlarly relevant unless the point is the desperation to make sure everything has hard and fast pigeonholes
09:28:35 <chirpsalot> The Haskell ints are machine dependent as well, no?
09:28:48 <mcstar> Int is i think
09:29:02 <mcstar> and Word
09:29:23 <edwardk> `Jake`: yes
09:29:26 <Sculptor> hello there
09:29:32 <`Jake`> thanks
09:29:39 <chirpsalot> mcstar: ah, yep! http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Data-Int.html
09:29:55 <edwardk> `Jake`: what we get is effectively a typeable instance for every concrete type, but you still need to pass the instance in for polymorphic type arguments if you want to use the information
09:30:10 <monochrom> hrm! I now see why "no Typeable instance for a" is right
09:30:15 <`Jake`> I see.
09:30:21 <edwardk> `Jake`: so no free theorems were harmed in the creation of this feature
09:30:46 <mcstar> lol
09:30:48 <`Jake`> That is good to know.
09:31:00 <elliott> my expensive theorem broke though.
09:31:05 * monochrom hugs his free theorem stuffed toy
09:34:09 <LambdaDusk> so what would you suggest for a GUI-based haskell program that should run on windows and linux?
09:34:52 <icarot> ls
09:34:53 <icarot> cd ~
09:34:53 <icarot> ls
09:34:56 <icarot> ls
09:35:17 <Taneb> LambdaDusk, I suggest running in terror :P
09:35:52 <Taneb> More seriously, I've heard good things about wx
09:36:14 <scshunt> wx is awful in C++
09:36:16 <scshunt> dunno about haskell
09:37:17 <mcstar> i'd suggest a finder like file manager
09:37:32 <mcstar> with many keyboard shortcuts
09:37:36 <spaceships> im surprised someone hasn't ported swing to haskell yet
09:37:50 <mcstar> he is looking for an application idea
09:37:55 <mcstar> not a toolkit
09:43:27 <LambdaDusk> wx doesn't really work on Linux, I have tried =/
09:43:37 <scshunt> LambdaDusk: It does
09:43:47 <scshunt> but there are a large number of caveats that are generally poorly documented
09:44:12 <scshunt> e.g. some function which says somewhere in the specification "input must not contain newlines" and if it does, it works fine on Windows but not on Linux
09:44:19 <LambdaDusk> and I am looking for a framework, as I already know what I wanna make - The gui is done in Scala, but the program part just refuses to work at all - which I have alrealy done in Haskell, though
09:44:33 <scshunt> (that actually happened, and took me probably several man-days to figure out)
09:47:59 <FreeFull> scshunt: It would be nice if there was some sort of compile-time or even runtime error/warning about that
09:49:01 <scshunt> FreeFull: This is why wx is a shitty library
09:49:42 <FreeFull> One could   newtype Line = Line String    and not export Line's constructor, and then have some function    String -> Maybe Line
09:50:18 <LambdaDusk> I wanted to try Gtk2hs but that beast is some weeks learning in itself
09:56:11 <pentace> LambdaDusk: How compley is your GUI? I find the basics can be learnt very quickly in gtk2hs. And even for more complicated things there are tutorials and many code examples
09:56:16 <pentace> *complex
09:57:14 <LambdaDusk> pentace: The usual input dialogs, plus some main window much like a chat room, with an input below and a main text component that's updated by an outside thread
09:59:05 <Fuuzetsu> edwardk: I didn't know you gave interviews.
09:59:30 <edwardk> Fuuzetsu: i'm generally pretty open to talking to folks
10:00:35 <pentace> LambdaDusk: That doesn't sound too complicated. If you can use glade, designing the GUI is even more easy
10:01:31 <mcstar> a tui goes a long way ^
10:01:57 <elliott> I'll interview edwardk about coming up with the puns for lens.
10:02:54 <ReinH> elliott: hah
10:04:43 <LambdaDusk> pentace: Is it possible to include the glade stuff into the binary or is an external file required?
10:06:09 <ReinH> edwardk: ping
10:06:34 <edwardk> pong
10:08:10 <ReinH> edwardk: so there was a post on /r/haskell recently about schwartzian transform-like things. It seems like there should be a generalize traversable(?) pattern for this (performing an expensive computation once over a structure and then using the result in a more more asymptotically complex operation)
10:08:17 <ReinH> *generalized
10:09:17 <ReinH> edwardk: iow a generalization of map snd . sortBy (comparing snd) . map (first f)
10:09:21 <ReinH> er
10:09:24 <ReinH> comparing fst
10:09:56 <edwardk> sure
10:09:58 <ReinH> the points that I can see that  might offer some generalization are map, sortBy, and comparing?
10:10:03 <ReinH> Is there anything interesting to be had here?
10:11:06 <hiptobecubic> why `map snd . sortBy (comparing snd)` ? Why not just `sort . map snd` ?
10:11:09 <ReinH> edwardk: I'm thinking about e.g. game tree evaluation. (I really want to get Haskell Live going again so I'm looking for ideas)
10:11:20 <edwardk> http://lukepalmer.wordpress.com/2009/07/01/on-the-by-functions/#comment-845 was the last time i talked about the schwartzian transform in haskell
10:11:42 <ReinH> of course you did
10:11:45 <ReinH> reading
10:12:02 <ReinH> hiptobecubic: because that was supposed to be `map snd . sortBy (comparing fst)`
10:12:11 <hiptobecubic> oh
10:12:25 <ReinH> whoops :)
10:12:54 <ReinH> "and nobody wants to talk about it right now on IRC" lol
10:13:21 <ReinH> btw the Ruby implementation of *_by (sort_by, min_by, etc) does a schwartzian transform
10:13:48 <ReinH> which is rather nicer than implementing it yourself
10:16:46 <joelteon> can cabal show the full dependency tree of a project?
10:23:21 * hackagebot Win32-services 0.2.2 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.2 (MichaelSteele)
10:27:01 <pentace> LambdaDusk: (Went afk, sorry) You usually load the .glade specification file from disk, but I don't know if there's a way to read it straight from a string argument
10:29:08 <DanielDiaz> I am running some old benchmarks. The HTML output file is indicated by -ofoo/bar/$benchmark.html, but they are all going to foo/bar/.html. I didn't change anything from... a long time. How do I get the same behavior as before?
10:29:33 <DanielDiaz> I want the name of the benchmark to appear where $benchmark.
10:30:10 <DanielDiaz> (using criterion, by the way)
10:30:54 <pentace> LambdaDusk: seems to be supported: http://hackage.haskell.org/packages/archive/gtk/0.12.4/doc/html/Graphics-UI-Gtk-Builder.html
10:31:06 <DMcGill> gtk is pretty horrible to build on windows
10:31:09 <DMcGill> but it is possible
10:31:29 <pentace> yeah
10:31:35 <DMcGill> you end up having to grab a binary from gimp
10:31:55 <DMcGill> or at least, that's the only solution I've even heard of working
10:32:25 <pentace> my main problem was finding a set of gtk libs working together
10:33:19 <hamishmack> DMcGill: I installed fedora and mingw32 gtk
10:34:09 <hamishmack> OpenSUSE and Fedora have the most complete set of windows gtk libraries even gtk3 and webkitgtk
10:35:12 <DMcGill> I shall have to remember that
10:35:14 <hamishmack> there is a python script you can apparently use on windows to download them directly, but I have not tried it yet
10:38:23 * hackagebot indian-language-font-converter 0.0 - Indian Language Font Converter  http://hackage.haskell.org/package/indian-language-font-converter-0.0 (AkashJagdhane)
10:39:30 <lingxiao> hey all, can some one answer a couple questions about properly using existentials?
10:40:53 <joelteon> sure
10:41:00 <`Jake`> :t (undefined :: Fractional a => a)
10:41:01 <lambdabot> Fractional a => a
10:41:28 <lingxiao> awesome, so let's say I have some `data Cor a b r`
10:41:50 <lingxiao> I then create a synonym, `type Core a b = forall r. Cor a b r`
10:42:46 <elliott> not an existential
10:43:39 <lingxiao> oops, what's the correct terminology?
10:44:10 <elliott> that's a regular forall
10:44:21 <elliott> you would write data Core a b = forall r. Core (Cor a b r) for an existential
10:44:23 <elliott> confused yet? :)
10:44:27 <valyagolev> have you seen that thing where someone converted German grammar to haskell? I'm not really sure that it means but I feel it wasn't a dream and I really seen this
10:45:38 <lingxiao> elliot: haha maybe :)  what's the semantic different between that and what I wrote
10:47:49 <`Jake`> valyagolev: Was the article or whatever it was in German or in English?
10:48:07 <lingxiao> ahhh.. I see your implementation let's me do something like: `f a b = Core (Cor a b 3) :: a -> b -> Core a b`
10:48:28 <lingxiao> which is exactly what I wanted, I wanted the `r` to drop out of the function signature when its value is predefined
10:49:17 <Taneb> Is the product of two monad transformers a monad transformer?
10:49:33 <tomejaguar> Taneb: what's the product?
10:49:41 <Taneb> ...good question
10:49:45 <Taneb> I'm thinking aloud
10:49:47 <Taneb> Hang on
10:50:02 <mcstar> a * a = a
10:50:15 <tomejaguar> If AT and BT are monad transformers, then BT m is a monad, so AT (BT m) is a monad
10:50:17 <Taneb> "data ProductT f g m a = (f m a, g m a)" or something
10:50:49 <mcstar> whats the property describing ^
10:50:56 <mcstar> idempotent?
10:52:09 <ReinH> mcstar: idempotent is f.f = f
10:52:22 <mcstar> yeah, * is function application
10:52:32 <mcstar> or composition :)
10:54:02 <byorgey> mcstar: a * a = a  is also called idempotent.
10:54:08 <`Jake`> @src Ratio
10:54:08 <lambdabot> data (Integral a) => Ratio a = !a :% !a
10:54:17 <mcstar> great, ty
10:54:17 <`Jake`> does that Integral a do anything?
10:54:31 <`Jake`> :t (undefined :: Ratio Float)
10:54:31 <lambdabot> Ratio Float
10:54:41 <mcstar> i was just thinking that the 'product' of two monad transformers should be idempotent, shouldnt it?
10:54:56 <valyagolev> `Jake` I think it was a github repository or a pdb paper, and I think the texts supplied with it were written in english
10:54:59 <edwardk> byorgey: we can of course carry on to talking about bands and tropical semirings in that vein ;)
10:55:06 <valyagolev> `Jake` pdf :)
10:55:21 <edwardk> mcstar: sadly no, you can pick up 'multiple' states that way
10:55:27 <byorgey> edwardk: indeed.  one of the many things I need to learn more about =)
10:56:39 <ReinH> byorgey: also known as a^2=a, which describes idempotent elements of (e.g.) rings
10:57:33 <mcstar> i guess i wasnt interpreting 'product of monad transformers' as stacking them
11:00:09 <`Jake`> valyagolev: I've looked if I have any luck with 2 or 3 quick google searches, but I didn't.
11:00:42 <osloairport> Hi y'all, is there a reason why “let x = e₁ in e₂” couldn't be “x = e₁; e₂” and “let x = e₁; e₂” in do-notation “x = e₁; e₂”
11:00:42 <osloairport> In regular expressions:
11:00:42 <osloairport>     function x =
11:00:42 <osloairport>       y = x^2
11:00:45 <osloairport>       y + y
11:00:48 <osloairport> and in do-notation:
11:00:52 <osloairport>     function x = do
11:00:55 <osloairport>       y = x^2
11:00:58 <osloairport>       z ← …
11:01:03 <osloairport> I personally find it more readable but not everybody may agree
11:01:03 <ReinH> osloairport: please don't paste code into the channel, see /topic
11:01:11 <mcstar> at least not this much
11:01:22 <byorgey> osloairport: no, there is no reason.
11:01:33 <osloairport> Sorry, I actually typed it all in at once but I will refrain from it in the future
11:02:17 <mcstar> x = e1; e2 looks wrong to me
11:02:39 <mcstar> ; looks like delimiting the scope of x
11:02:47 <osloairport> I generally prefer where-clauses to let because the “let … in” feels noisy to me
11:02:50 <mcstar> and where does it terminate?
11:02:58 <mcstar> let .. in is an expression
11:03:24 * hackagebot hslogger 1.2.3 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.3 (JohnGoerzen)
11:03:38 <osloairport> Sure, each variable is bound in each successive expression
11:03:39 <mcstar> also, ; introduces multiple bindings in 1d let
11:03:50 <mcstar> let a = 1; b = 2 in
11:03:51 <osloairport> How so mcstar?
11:04:05 <mcstar> > let a = 1; b = 2 in a + b
11:04:06 <lambdabot>   3
11:04:26 <osloairport> Right, but that is the same as (let a = 1 in (let b = 2 in a + b)) for non-recursive lets
11:04:40 <osloairport> so it could be: a = 1; b = 2; a + b
11:06:02 <mcstar> i like let ver much though, in haskell it is sane, not like in ocaml, where you can see the code from the let
11:06:09 <mcstar> cant see*
11:06:18 <osloairport> I mean do-notation already ellides the ‘in’ keyword (for reasons that have never been clear to me)
11:06:43 <mcstar> it is clear, if you rewrite do notation with bind, the scope becomes clear
11:07:29 <mcstar> the do block is clearly terminated with a } or indentation, so the scope ends there
11:07:43 <osloairport> I don't see how the scope is unclear though, (x = a; y = b; …) might expand to (let x = a in (let y = b in …)) with normal scope
11:07:56 <osloairport> I'm not trying to stir up trouble, just curious
11:08:17 <mcstar> so now, x = a is an expression?
11:08:34 <mcstar> y = (x = a)?
11:08:46 <osloairport> No that's not what I'm suggesting
11:09:02 <mcstar> it is just a side effect of what you are suggesting
11:09:22 <mcstar> (i dont want to sound too passionate about this though, but i really like let)
11:09:29 <osloairport> So “let a = b” is an expression in do-notation?
11:09:39 <dmwit> mcstar: wut
11:09:46 <mcstar> no, it isnt
11:09:52 <mcstar> dmwit: wut wut?
11:09:59 <dmwit> Nothing osloairport suggested sounded like it implied making (x = a) an expression to me.
11:10:16 <osloairport> If you must, you can read (x = e) as (x ≔ e) and think of it as being sugar for an ‘actual’ expression (let x = e in …)
11:11:04 <mcstar> my head hurts, i need to think slowly..
11:11:41 <ReinH> osloairport: I'm pretty sure that let is a loan from lambda calculus, not actually necessary
11:12:09 <mcstar> i just cant grasp, x = a floating in haskell code
11:12:12 <dmwit> You can pick any syntax you like. It's not important.
11:12:25 <osloairport> ReinH: Yeah I know (let … in …) has a history, I'm just wondering if it's necessary baggage or not
11:12:31 <ReinH> as in, f a = b = a; c = b; c could certainly work.
11:12:37 <osloairport> mcstar: Is that because you're used to let?
11:12:52 <mcstar> good question, i hope it has a deeper reason
11:12:52 <ReinH> I think it's actually clearer to say f a = let b = a; c = b in c, although this example is rather contrived
11:13:20 <mcstar> ok, go with this: f a = b = a
11:13:21 <osloairport> Of course arguably it wouldn't be ‘Haskell’ code, at least not Haskell98 code
11:13:23 <mcstar> what is this?
11:13:25 <b2coutts> osloairport: I think (let ... in ...) is more intuitive
11:13:26 * hackagebot Win32-services 0.2.2.1 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.2.1 (MichaelSteele)
11:13:26 <dmwit> osloairport: Lets are recursive in Haskell, though, so delimiting scope does matter for Haskell.
11:13:39 <dmwit> mcstar: syntax error
11:13:42 <mcstar> why?
11:13:47 <ReinH> osloairport: one advantage to let and where is that they set up expectations for how the code is structured
11:13:49 <osloairport> mcstar: That's just like “f a = b ← a”, an error
11:13:52 <mcstar> thats how you introduce binding int he 'new' syntax
11:13:57 <osloairport> *do b ← a
11:14:08 <b2coutts> osloairport: (let ...; ...) looks like imperative code, which is probably the intention, but is misleading wrt how let works and is used
11:14:08 <dmwit> mcstar: Because the syntax of equations includes a continuation, same reason "f a = let b = a in" is a syntax error. =)
11:14:30 <mcstar> f a = b = a;
11:14:42 <dmwit> same syntax error
11:14:43 <b2coutts> since (let a = 1 in a+4) is an expression, not two statements
11:14:44 <mcstar> now it seems like, whatever the value is, it is being dropped
11:14:49 <mcstar> like, ; would produce ()
11:14:55 <dmwit> No. That is a syntax error.
11:15:05 <osloairport> I mean, (f a = where b = e) is also an error
11:16:20 <dmwit> osloairport: (Do you understand why delimiting scope is important in Haskell? If so, I won't try to repeat this point.)
11:16:41 <mcstar> how could the parser decide if i was binding 'b' to 'a' or defining a function 'f' with argument 'a'?
11:16:55 <osloairport> I do, but it's only important for recursive let-definitions
11:17:09 <dmwit> mcstar: Because they occur at different places in the syntax tree.
11:17:21 <osloairport> In which case a special syntax could be used just like with recursive do
11:17:32 <dmwit> Yes, that's fine.
11:18:19 <dmwit> In any case, "where" is light-weight enough for me.
11:18:26 <mcstar> f a = g b = a; c = g a; c
11:18:27 <dmwit> One extra token. =)
11:18:35 <mcstar> look horrible though
11:18:37 <osloairport> I'm not totally happy with:
11:18:38 <osloairport>     succ (x = 5
11:18:38 <osloairport>           x + x)
11:18:38 <osloairport> instead of:
11:18:41 <osloairport>     succ (let x = 5 in x + x)
11:18:44 <osloairport> but it needn't supersede let's
11:18:52 <osloairport> Are we counting tokens now? :)
11:19:28 <dmwit> Isn't your complaint that "let" and "in" are too many extra tokens? =)
11:19:39 <osloairport> Well yes and no
11:19:42 <ReinH> heh
11:20:06 * mcstar thinks it aids readability, if there is no other benefit
11:20:11 <osloairport> It would be nice and symmetric to write:
11:20:11 <osloairport>     do x <- …
11:20:11 <osloairport>        y := x + x
11:20:11 <osloairport>        …
11:20:32 <osloairport> and for unicode syntax ← and ≔ or, ← and = with the same number of characters
11:20:34 <ReinH> I don't think := is an improvement over let
11:20:47 <osloairport> no no, that's just to satisfy my horrible obsessiveness
11:20:56 <osloairport> I like expressions to be aligned nicely
11:21:05 <profmakx> use spaces.
11:21:17 <mcstar> <- is probably the reasong ppl think they can pull stuff out of IO
11:21:29 <dmwit> Please don't get sidetracked by *which symbol* we're using for assignment and how to format code.
11:21:32 <dmwit> yeesh
11:21:48 <osloairport> dmwit: It's a different discussion :)
11:22:23 <dmwit> I almost never use let.
11:22:28 <dmwit> So I find the whole argument a bit specious.
11:22:46 <osloairport> I haven't found a nice way of formatting my multi-line (let … in …)'s, do you add another space after in or have the expressions misalign?
11:22:47 <mcstar> ill remember that word
11:23:03 <mcstar> huh, su-specious
11:23:17 <dmwit> Perhaps you should write your code in a way that doesn't require multi-line let-in's. ;-)
11:23:24 <osloairport> Perhaps!
11:23:46 <ReinH> like using a where :D
11:23:51 <osloairport> Where's are awesome
11:23:57 <ReinH> speaking of obsessive formatting
11:24:12 <dmwit> More to the point: like writing a function that does all those computations you're doing in the let.
11:24:13 <ReinH> In Marlow's parallel & concurrent book he has two styles of where formatting
11:24:14 <osloairport> but for tiny expressions it can be nicer to have them defined just before used
11:24:18 <ReinH> and it drives me insane
11:24:23 <osloairport> haha
11:24:51 <mcstar> where cant capture things from the defining scope, i.e. the scope extends only to function arguments
11:24:56 <osloairport> I started putting there ‘where’ keyword on the same line as the last expression for short expressions and I've never looked back
11:25:00 <mcstar> but let-in captures sanely, as i want
11:25:01 <osloairport> *the ‘where’
11:25:12 <b2coutts> osloairport: it looks to me like you're trying to make let look like imperative variable assignment
11:25:14 <dmwit> mcstar: Yes, this is why I suggested writing a function rather than translating to where. =)
11:25:17 <b2coutts> and I'm not sure why you're trying to do that
11:25:18 <ReinH> osloairport: that sounds terrible
11:25:33 <dmwit> ReinH: 'snot
11:25:54 <osloairport> b2coutts: I stated the reasons earlier, I think it looks nicer; ‘looking’ imperatived does not make it imperative
11:26:02 <`Jake`> so for multiline wheres, do you put the first definition on the same line as "where" or in the line below?
11:26:06 <osloairport> ReinH: Don't knock it!
11:26:08 <dmwit> I have a macro for "= undefined where\n\t". =)
11:26:14 <b2coutts> well it obscures the meaning of the code and leads to misunderstandings
11:26:33 <ReinH> dmwit: hmm.
11:26:35 <osloairport> I don't agree and I doubt we'll reach any agreement on that
11:26:36 <b2coutts> if a C programmer sees "let x=5; y=6; x+y", they are going to misinterpret what's happening
11:26:37 <tomejaguar> mcstar: what do you mean?
11:26:38 <haasn> ReinH: maybe you can help me figure out how to nicely format a ‘where’ that goes after a ‘do’ block
11:26:39 <ReinH> Marlow uses:
11:26:42 <ReinH> foo = bar
11:26:42 <dmwit> `Jake`: I find if I put it on the same line as the where, things get indented too deeply too quickly.
11:26:42 <ReinH>  where
11:26:44 <ReinH>   bar ...
11:26:49 <ReinH> single space indenting o_O
11:26:51 <mcstar> tomejaguar: what do i mean why what?
11:26:54 <mcstar> by
11:27:02 <tomejaguar> "where cant capture things from the defining scope"
11:27:03 <mcstar> brainfart
11:27:12 <haasn> ReinH: right now I have my ‘do’ block indented by 2 spaces, then I go back 1 for ‘where’ and forwards again for to 2 for its body
11:27:29 <ReinH> haasn: I use 4 and 2 right now
11:27:30 <dmwit> tomejaguar: You can't use "where" to replace the "let" in "do x <- foo; let y = g x; bar y".
11:27:32 <haasn> ReinH: but I don't like wasting a line on ‘where’
11:27:32 <osloairport>  
11:27:32 <osloairport>   fn x = loop x [] where
11:27:33 <osloairport>     loop ∷ Int → [Int] → IO ()
11:27:33 <osloairport>     loop …
11:27:33 <ReinH> but I might try this styke
11:27:35 <mcstar> tomejaguar: well, to say it correctly, read the stuff after the comma
11:27:45 <ReinH> osloairport: that's not so bad
11:27:48 <mcstar> tomejaguar: that part is not too correct, indeed
11:28:01 <`Jake`> that looks pretty unfamiliar, though
11:28:16 <haasn> ReinH: one of the things I really, really wish I could do is “where foo = do” and then have the next line aligned with the first ‘e’ of where
11:28:25 <haasn> I don't like going all the way to ‘f’, so much whitespace
11:28:26 * hackagebot restricted-workers 0.1.1 - Running worker processes under system resource restrictions  http://hackage.haskell.org/package/restricted-workers-0.1.1 (DaniilFrumin)
11:28:48 <ReinH> haasn: right
11:28:56 <mcstar> it is nice that everyone has their 2 cents on superficial things.. i feel like being in a pub, half drunk
11:29:00 <`Jake`> I don't like putting type declarations into wheres
11:29:14 <sirspazzolot> is the Carmack on Haskell video posted on HN worth watching?
11:29:20 <osloairport> mcstar: I may have more than 2…
11:29:30 <sirspazzolot> whoops, this isn't haskell-blah
11:29:32 <mcstar> ooh, now everything is clear :)
11:29:40 <osloairport> And I may be more than half-drunk :)
11:30:57 <ReinH> mcstar: no bikeshed has been repainted as many times as the coding style shed
11:31:57 <mcstar> lispers are smug, cause they can bikeshed wrt. lisp's sytax/coding style much
11:32:00 <mcstar> cant
11:32:18 <byorgey> is there a canonical location for  Proxy a = Proxy  ?
11:32:42 <osloairport> I happen to like Clojure's ‘let’ macro! CL and Scheme's not as much
11:33:01 <b2coutts> osloairport: http://lpaste.net/92198
11:33:24 <osloairport> gaah!
11:33:25 <osloairport> why
11:33:26 <dmwit> byorgey: there is... moment
11:33:32 <mcstar> osloairport: you can simulate bindings with lambdas though, did you know that?
11:33:38 <osloairport> Sure
11:33:43 <valyagolev> yeah, ((a b)) doesn't feel readable :(
11:33:48 <dmwit> ?hackage tagged
11:33:48 <lambdabot> http://hackage.haskell.org/package/tagged
11:33:50 <b2coutts> though, better practice would be to just declare the function outside of this function
11:33:51 <dmwit> byorgey:
11:34:31 <mcstar> wait, your name is oslo airport
11:34:57 <osloairport> b2coutts: The use case I was thinking of was rather for binding small expressions to variables with a syntax like in imperative languages, yes the I-word
11:36:11 <byorgey> ah, tagged, that's it
11:36:13 <b2coutts> osloairport: can you give an example of actual code you think would be made better with this syntax?
11:36:14 <byorgey> dmwit++
11:36:18 <osloairport> I've used functional programming languages for a long time but it just strikes me as being clutter-free every time I go back to imperative code, also I'm waiting at an airport for 10 more hours so sue me :)
11:36:46 <b2coutts> (this isn't about me hating imperative programming, but it's appropriate for functional code to look like functional code)
11:36:51 <byorgey> let me guess... the Stockholm airport?
11:36:55 <tomejaguar> Indeed an example would help.
11:36:58 <Eduard_Munteanu> Hmmm... I wish there were heterogenous maps in Haskell.
11:37:23 <osloairport> Sure:
11:37:23 <osloairport>     main = do
11:37:23 <osloairport>         line ← getLine
11:37:23 <osloairport>         final = printf "You entered: %s" line
11:37:26 <dmwit> Eduard_Munteanu: hlist? ;-)
11:37:26 <osloairport>         putStrLn final
11:37:42 <Eduard_Munteanu> dmwit: don't wanna go there :P
11:38:05 <dmwit> osloairport: In Haskell, that's just main = getLine >>= printf "You entered: %s\n"
11:38:25 <osloairport> dmwit: In Haskell there are many ways of writing it.
11:38:27 <tomejaguar> dmwit: No it isn't
11:38:35 <dmwit> tomejaguar: It isn't?
11:38:38 <tomejaguar> printf is not in IO
11:38:40 <mcstar> i dont think he should provide a long example here that doesnt look good without do notation
11:38:44 <dmwit> tomejaguar: Yes it is. =)
11:38:55 <dmwit> :t getLine >>= printf "You entered: %s\n"
11:38:55 <osloairport> b2coutts: Do you think do-notation looks like ‘functional code’? That quality sounds too vague to say much about it
11:39:02 <Eduard_Munteanu> I'm parsing this thing and accumulating properties for an object. I really don't like how it is going.
11:39:02 <tomejaguar> In that case putStrLn final is not right
11:39:10 <mcstar> it can do both
11:39:13 <dmwit> tomejaguar: It is right.
11:39:18 <lambdabot> IO b
11:39:18 <dmwit> tomejaguar: Think polymorphism, mate!
11:39:24 <`Jake`> :t printf
11:39:25 <lambdabot> PrintfType r => String -> r
11:39:31 <osloairport> You are getting hung up on totally the wrong things #haskell :)
11:39:46 <tomejaguar> Interesting
11:39:47 <osloairport> Obviously it's possible to write it in a shorter way, that wasn't the question
11:40:05 <tomejaguar> Anyway, osloairport it's not about shorter.  It's about more idiomatic.
11:40:08 <DanielDiaz> I can't manage to get cabal templates working. I run my benchmark with "cabal bench", using"--benchmark-options="-o$benchmark.html -g -s 100"". The output is written in a file called ".html". What am I doing wrong? The same thing worked just fine a while ago (March of this year, I think).
11:40:13 <dmwit> osloairport: No. The question was, how do you idiomatically write monadic code? My answer is not "use let".
11:40:16 <mcstar> osloairport: yes, we(I) get it, but it still looks horrible without the let...
11:40:21 <tomejaguar> If you have to do a lot of assignments there's probably a better way to write what you're writing.
11:40:21 <dmwit> osloairport: ...and I've been consistent about that answer, I think.
11:40:37 <mcstar> this is not assigment, it is a binding
11:40:39 <dmwit> tomejaguar++
11:40:39 <Eduard_Munteanu> Can SYB or generics help with accumulating "fields" from input to make a big record?
11:40:48 <tomejaguar> osloairport: you can do "final <- return $ printf ..." if you like
11:40:54 * osloairport shudders
11:40:57 <dmwit> tomejaguar: ugh
11:42:13 <dmwit> DanielDiaz: Perhaps you used the wrong quotation marks (seriously).
11:42:28 <dmwit> DanielDiaz: Probably your shell is expanding $benchmark because you used double-quotes instead of single-quotes.
11:42:42 <tomejaguar> If I were writing this I would do something like "main = (putStrLn . processLine) =<< getLine"
11:42:44 <dmwit> ...and since $benchmark isn't defined...
11:42:53 <tomejaguar> I much prefer that style to lists of imperative style assignments
11:43:16 <DanielDiaz> dmwit: ok, I will try with single-quotes and answer you back. Maybe because before I run this benchmarks in Windows I didn't have this problem.
11:43:27 <mcstar> it is not an assigment, it binds a value to a name (once)
11:43:35 <osloairport> I think numeric algorithms would benefit from this, but this is just a personal preference. I appreciate your comments about disagreeing with it:
11:43:36 <osloairport>   foo x = do
11:43:36 <osloairport>     rand ← randomIO
11:43:36 <osloairport>     y    = 5 * x
11:43:39 <osloairport>     z    = y + z * y
11:43:42 <osloairport>     return (1 + z + y + x + rand)
11:43:45 <tomejaguar> mcstar: Fair enough, but it's written that way *because* it looks like an assignment.
11:44:06 <tomejaguar> osloairport: move the pure part to its own function
11:44:08 <b2coutts> osloairport: it sort of does, and it makes be a little uneasy
11:44:09 <mcstar> no, it is written that way cause it is more like an equation
11:44:22 <monochrom> osloairport, the Haskell syntax for that just needs an additional "let". it doesn't even need an "in"
11:44:25 <b2coutts> but it makes more sense for do to be written that way than let
11:44:33 <tomejaguar> mcstar: I'm saying osloairport wants it that way because it looks like an assignment
11:44:51 <dmwit> osloairport: z = y + z * y looks a bit suspicious to me
11:45:05 <osloairport> hah, ignore the ‘z’ on the RHS
11:45:13 <mcstar> syntax error
11:45:16 <monochrom> change line 3, "let y = 5 * x", and change line 4's indentation. that is all.
11:45:18 <DanielDiaz> mdwit: thank you! it worked. Seriously, I was stuck with this for a while... I would have never thought about that.
11:45:19 <mcstar> z = y + * y
11:45:26 <b2coutts> thinking of a do block as being a series of commands is much more useful than thinking of let that way
11:45:31 <mcstar> hm, no not syntax error
11:45:33 <mcstar> type error
11:45:34 <osloairport> mcstar: :)
11:45:49 <`Jake`> :t 4 + * 8
11:45:50 <lambdabot> parse error on input `*'
11:45:50 <osloairport> I just may be failing the Turing test here
11:45:51 <dmwit> osloairport: Then do { rand <- randomIO; return (1 + 11 * x + rand) } looks pretty good to me. =)
11:46:05 <mcstar> hm?
11:46:17 <mcstar> `Jake`: were you expecting that?
11:46:22 <osloairport> Since I'm being taken so literally mcstar :)
11:46:25 <tomejaguar> Why even use do notation for that at all?
11:46:27 <tomejaguar> It's just an fmap.
11:46:42 <`Jake`> I don't know, I don't think about operator juxtaposition a lot
11:47:21 <mcstar> well, it probably makes sense not to place 2 infix operators besides each other...
11:48:03 <`Jake`> :t (4 +) * 8
11:48:03 <lambdabot> (Num (a -> a), Num a) => a -> a
11:48:15 <`Jake`> you won't get Num (a -> a), of course
11:48:16 <osloairport> tomejaguar: Geez, substitute an example that isn't just an fmap: the examples are /simplified/. I am aware that you can code golf these simple examples to death
11:48:26 <ReinH> `Jake`: but you could :p
11:48:27 <dmwit> > 3 :: Int -> Int
11:48:28 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
11:48:28 <lambdabot>    arising f...
11:48:32 <mcstar> lambdabot had
11:48:33 <tomejaguar> osloairport:
11:48:34 <`Jake`> Rfair enough
11:48:37 <`Jake`> dammit
11:48:38 <`Jake`> tab
11:48:46 <tomejaguar> osloairport: It's hard for us to understand your point without an explicit example
11:48:50 <`Jake`> ReinH: fair enough
11:48:51 <mm_freak> byorgey: note that receivers don't usually need 'tagged'
11:49:08 <valyagolev> @type (1+) <$> (11*) <$> randomIO
11:49:10 <lambdabot> (Num a, Random a) => IO a
11:49:14 <mm_freak> p x (instead of Proxy x) is fine
11:49:22 <tomejaguar> osloairport: Basically I think anything you come up with I'd be happy splitting into a more point-free style.  I might be wrong but the onus is on your to provide the example :)
11:49:28 <dmwit> osloairport: The point we are trying to make is that the things we are doing are not golf. They are how you *actually* write idiomatic code.
11:49:37 <ReinH> `Jake`: theoretically, at least, you can use a godel numbering :p
11:49:45 <osloairport> The examples are examples of syntax that are nice to read: just because I happen to use integer literals in them and you are able to perform constant folding isn't really a problem with the example imo
11:49:58 <`Jake`> :t ((4 +) * 8) undefined
11:49:58 <dmwit> osloairport: You split the pure computation out into its own function, and then use that as a conceptual chunk in your do-block.
11:49:59 <lambdabot> (Num (a -> a), Num a) => a
11:50:20 <osloairport> dmwit: Sure
11:50:55 <byorgey> mm_freak: what do you mean by "receivers"?
11:51:12 <dmwit> byorgey: Functions that use Proxy in a negative position.
11:51:22 <Eduard_Munteanu> More generally, my problem goes like this: given a record type with fields of different types, fill it up from a bunch of strings of the form "property = value". The most straightforward way seems to involve making a Map and deferring parsing the values as much as possible.
11:51:35 <dmwit> byorgey: ...can usually just use a type variable instead of "Proxy".
11:51:39 <tomejaguar> I like using do notation to quickly prototype.  When I'm done refactoring my do blocks are almost always very short.
11:51:41 <byorgey> ahhh, I see, nifty
11:51:54 * byorgey tries it
11:52:17 <Eduard_Munteanu> Now that seems to resist my attempts at parsing earlier or making things more typed.
11:52:22 <c_wraith> Tagged and Proxy are nice for moving type variables back and forth between positive and negative positions, depending on which is most convenient for your use.
11:52:43 <dmwit> Eduard_Munteanu: Yes, that's essentially the method that aeson uses. It's pretty nice. What seems bad to you?
11:54:46 <Eduard_Munteanu> dmwit: well, it's not exactly "prop=value", so I'll have to extract such assignments from the input. One problem I have with that is I touch the stuff twice and those things aren't neatly categorized in one place.
11:55:29 <dmwit> Yes, it does mean making two passes.
11:55:41 <bos> hackage seems to be dead or very slow.
11:55:59 <dmwit> bos: Seems to be working okay for me.
11:56:10 * lispy too
11:56:19 <bos> huh. i get infinite timeouts from it.
11:56:27 <dmwit> strange
11:57:15 <bos> the main page responds quickly with a redirect, then the redirected page never responds.
11:57:35 <bos> so i can talk to the server fine, it's just the actual hackage server that's not responding?
11:57:58 <bos> oh wait, it finally responded after ~30 seconds.
11:58:27 * hackagebot xmlhtml 0.2.3 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.3 (DougBeardsley)
11:58:29 <Eduard_Munteanu> dmwit: I was considering doing an early parse and extract properties to an ADT, putting all that into a list, sorting and extracting them back in a specific order (to detect missing properties). But it seems annoying without help from generics / the compiler.
11:59:47 <lispy> bos: does this happen to you frequently or just today?
12:00:02 <Eduard_Munteanu> I would effectively do something like  foo (a:b:c:d:...:[]) = Object { assign stuff here }
12:00:19 <bos> lispy: it's fairly common. hackage is terribly slow and flaky.
12:00:32 <bos> it's taking about a minute to serve a single page right now.
12:00:34 <lispy> bos: Interesting.
12:01:03 <djahandarie> I recall the last time I had an issue with that, it was due to reverse DNS lookups failing for my IP, and hackage was hanging on that.
12:01:18 <bos> djahandarie: oh, that's possible.
12:01:20 <lispy> bos: I think we need more data. Also, I don't think anyone knows that it's an issue for you (and others?). Would you mind emailing haskell-infrastructure to let them know?
12:01:20 <c_wraith> ugh.  misconfigured logger
12:01:23 <c_wraith> that's the best
12:01:28 <bos> djahandarie: reverse DNS lookups == failsauce.
12:01:34 <djahandarie> Yup, I agree.
12:01:44 <dmwit> Eduard_Munteanu: The aeson way is something like foo xs = Object <$> xs <!> "field1" <*> xs <!> "field2" <*> xs <!> "field3".
12:01:48 <c_wraith> bos: several http servers default to doing reverse DNS lookups for their access logs.  for some reason
12:01:55 <dmwit> Eduard_Munteanu: (It's not called <!> but I can't remember the right name at the moment.)
12:02:04 <bos> c_wraith: avoiding success at all costs, i assume.
12:02:07 <dmwit> Eduard_Munteanu: It's not too painful in the end.
12:02:10 <lispy> Oh, you mean on the hackage side
12:02:15 <c_wraith> lispy: yeah
12:02:16 <Eduard_Munteanu> Yeah, I think I'll do that after all.
12:02:26 <b2coutts> osloairport: the thing is, I tend to find that when what I'm doing in haskell is really awkward, it's because I'm doing it wrong
12:03:05 <b2coutts> that's why I asked for an example; I feel like if there's a situation in which you're using let and it's awkward/unreadable, there's probably a better way of doing it
12:05:19 <osloairport> b2coutts: After thinking about it for some time I guess that what you were really asking for is an example using (let … in …) and (let …)
12:05:35 <osloairport> especially one using many of them in a row
12:05:56 <b2coutts> osloairport: well, you said that you don't like the existing syntax and you're proposing an alternate syntax
12:06:20 <b2coutts> give a code sample where the code is better using your syntax than using existing haskell syntax
12:07:24 <osloairport> Yes, and when I gave an example which would've desugared to ‘let … in …’ people pointed out other (less readable in my opinion) solutions; the problem was really that you didn't agree with when to use ‘let … in …’
12:07:50 <elliott> bos: hi, some people were wondering if hpaste.org couldn't be pointed towards where lpaste.net goes now? I understand you own the domain
12:07:58 <osloairport> So if you ever use ‘let … in …’ in your code, that's a candidate: I mean it's not like it's a major syntactic change
12:08:13 <bos> elliott: i haven't heard anything from chrisdoner about this
12:08:21 <tomejaguar> osloairport: "the problem was really that you didn't agree with when to use ‘let … in …’"   This indeed may be the problem.  I tend to write pointfree as much as is reasonable, and use where otherwise.
12:09:03 <b2coutts> well that's the thing; your code was a weird way in which to use let
12:09:05 <arnsholt> For computing a pure function in the middle of a do-block, is one of "x <- return $ stuff" or "let x = stuff in ..." preferred?
12:09:17 <osloairport> Pointfree is nicer to prove theorems about, not always nicer for legibility
12:09:20 <elliott> bos: he says he emailed you about it but didn't get a response in two weeks or something
12:09:23 <dmwit> arnsholt: Don't use "x <- return $ stuff".
12:09:30 <elliott> bos: then it went to paste.tryhaskell.org and was going to to go paste.haskell.org but went to lpaste.net instead
12:09:37 <elliott> perhaps old email issues or such?
12:09:45 <dmwit> arnsholt: But then, you probably don't need to use "let x = stuff in", either (which is what we've been dicussing for the last hour or so =).
12:09:49 <b2coutts> I worry that you're using let due to an attachment to the imperative style, where you assign variables step-by-step until arriving at your answer
12:10:06 <elliott> bos: people were claiming you were AWOL and the domain was lost or something, I found that a bit implausible and suspected there was some misunderstanding going on :)
12:10:15 <osloairport> I have no attachment to imperative style, not more than people who use the do-notation
12:10:35 <osloairport> *no more
12:10:50 <arnsholt> b2coutts: Probably an accurate estimation. So far I've started out writing do-blocks and refactoring those into >>= and things once I get something working
12:11:27 <b2coutts> I'm not really against do-blocks; thinking of do blocks in an imperative sense is often useful
12:11:54 <bos> elliott: turned out he emailed me in june and i didn't see it.
12:12:06 <b2coutts> but if you're doing a bunch of lets in a row in monadic code, it's probably a sign that you could be writing a pure function
12:12:42 <elliott> bos: :) no worries
12:12:50 <elliott> just would be nice to get the hpaste.org links lying around everywhere unbroken
12:12:53 <osloairport> b2coutts: It wouldn't just be fore monadic code but I do agree with that
12:12:54 <b2coutts> in general, over the course of learning haskell, I've often found myself trying to write code in it and finding what I'm doing very awkward
12:13:16 <b2coutts> and every time I've had such a situation, I've found that I'm trying to shove a square into a circle hole, so to speak
12:13:30 <bos> elliott: dns bumped. thanks for poking me about this!
12:14:01 <osloairport> For very simple monadic functions, using do-notation is generally not needed
12:14:15 <elliott> bos: thanks!
12:14:28 <b2coutts> osloairport: it holds for pure code as well; earlier you mentioned an example of using where, then defining a function piecewise with a contract and everything
12:14:30 <osloairport> but when they get just a little real-worldy I don't want to see 5 (>>=)'s or (<=<) spread over it
12:14:37 <b2coutts> why not just define that function outside of your current function?
12:14:53 <b2coutts> I dunno, I think it's perfectly fine to use lots of do
12:14:59 <srhb> elliott: Thought he wanted to make the new domain canonical though.
12:15:00 <b2coutts> it results in nice, readable monadic code
12:15:04 <joelteon> I've been getting "unrecognized option `--sysconfdir=/Users/joelteon/.cabal/etc'" pretty frequently since switching to cabal-install 1.17.0
12:15:10 <joelteon> is that a deprecated option or something?
12:15:11 <srhb> elliott: Due to having control of the dns inside the haskell.org platform
12:15:13 <elliott> srhb: no reason to break old links, they can redirect if needs be
12:15:16 <tomejaguar> osloairport: on the contrary I love to see "f <=< g <=< h <=< i <=< j <=< k".  It means my code is very neatly factored.
12:15:21 <b2coutts> and I don't think do-clocks need to be reserved for only complex/long monadic code
12:15:22 <elliott> he gave up on haskell.org quicker than hpaste.org ;)
12:15:26 <srhb> Ah. :)
12:15:53 <osloairport> tomejaguar: That's a different case when they all line up, when you have as many anonymous functions as (>
12:16:03 <osloairport> tomejaguar: That's a different case when they all line up, when you have as many anonymous functions as the (>>=)'s then it's bad bad
12:16:28 <valyagolev> @type (<=<)
12:16:29 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
12:16:32 <tomejaguar> Agreed, but then I tend to name the functions :)
12:17:00 <valyagolev> that's . for kleisli right?
12:17:01 <ericmoritz> <=< is nice for building point free monadic actions
12:17:26 <osloairport> (a <=< b <=< … <=< z) is nice no doubt
12:17:40 <tomejaguar> valyagolev: yes
12:17:42 <osloairport> and simple stuff like (print =<< action that takes arguments) is nice as well
12:17:43 <lispy> bos: I emailed the infrastructure list
12:18:02 <b2coutts> osloairport: one reason I don't use let that often is because most of the time I need to use a function, either the function already exists in a library, it can be easily written point-free, or it warrants its own declaration
12:18:03 <lispy> bos: I'm not sure who has access to that machine to check the apache config, but someone should be able to look
12:18:16 <tomejaguar> osloairport: you probably have a good point, but I won't be able to understand it unless you paste a nice big example which is much better in your style
12:18:37 <b2coutts> really, the main reason I ever find myself using let is to format my code so it doesn't exceed 80 characters
12:18:43 <b2coutts> this may or may not be good practice
12:18:52 <ReinH> osloairport: also monad-loops can make a lot of typical do blocks very easy to write
12:19:12 <b2coutts> I had my IO/do block lightbulb moment yesterday
12:19:40 <bos> lispy: thanks. i emailed dcoutts directly, which is probably less effective :-)
12:19:54 <bos> lispy: i'd guess that it's the hackage program itself that's at fault, not apache.
12:19:54 <FreeFull> b2coutts: Which was?
12:19:56 <tomejaguar> b2coutts: what was your moment?
12:21:01 <b2coutts> I was just working on a piece of monadic code in my main block for a while, and trying to figure out how I'm supposed to handle control flow in a do block (in this case, if an argument is supplied, get input from the argument instead of from STDIN)
12:21:28 <osloairport> First ‘let’ I could find:
12:21:28 <osloairport>     xmonad initxmc = do
12:21:28 <osloairport>         installSignalHandlers
12:21:28 <osloairport>         xmc = initxmc { layoutHook = Layout $ layoutHook initxmc }
12:22:13 <b2coutts> it was basically when I wrote something like `arg <- if hasArg then getLine else return "argVal"`
12:22:40 <b2coutts> (which in retrospect isn't really the best way of doing it, but figuring out how that works felt like a big step)
12:22:50 <srhb> b2coutts: Definitely. :)
12:23:11 <dcoutts> bos: replied
12:23:28 * hackagebot bindings-nettle 0.0 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.0 (ClintAdams)
12:24:27 <dcoutts> bos: HostnameLookups Off
12:24:33 <dcoutts> bos: so I don't know what's going on
12:24:45 <bos> dcoutts: i believe it's the hackage server itself.
12:25:00 <bos> dcoutts: apache responds instantly.
12:25:15 <dcoutts> bos: you mean it's just being slow
12:25:22 <dcoutts> nothing to do with dns
12:25:23 <dmwit> osloairport: That can definitely be put in a where. It doesn't refer to anything bound earlier in the block.
12:25:31 <bos> dcoutts: that's possible, i suppose.
12:25:42 <dmwit> osloairport: The let two lines later is harder. =)
12:25:57 <dcoutts> bos: I'm not quite sure what you're suggesting/asking
12:26:03 <bos> dcoutts: actually, no, it's specific to the host that is doing the request.
12:26:15 <osloairport> I think this is nicer style dmwit, the definition itself is rather long so I prefer binding it before usage than having to scroll to the bottom to see the definition
12:26:17 <FreeFull> b2coutts: A big realisation would be that GHCi almost behaves like you are in a do block for the IO monad
12:26:30 <bos> dcoutts: if i hit the running hackage server from a machine with working reverse DNS, it responds reasonably quickly.
12:26:31 <osloairport> But here people are again arguing the use of *let* and not my syntax
12:26:43 <bos> dcoutts: if i do not, it takes a minute or so to respond.
12:26:57 <dcoutts> bos: odd, since apache has the lookup off
12:27:00 <b2coutts> osloairport: the issue is that you're using your syntax for non-conventional haskell code
12:27:00 <bos> dcoutts: but i have to be hitting an endpoint that is served by the hackage CGI script.
12:27:05 <dmwit> osloairport: If there is no let, the syntax of let does not matter. ;-)
12:27:30 <bos> dcoutts: what i am trying to tell you is that the hackage executable itself appears to be doing the reverse DNS lookup *after* apache has proxied to it.
12:27:30 <osloairport> b2coutts: Non-conventional Haskell code? XMonad?
12:27:37 <dcoutts> bos: ah
12:27:57 <dcoutts> bos: or apache is configured to do the dns lookup for cgi progs or something odd
12:27:58 <dmwit> osloairport: Anyway, I was never one of the ones claiming your proposed syntax was impossible or undesirable.
12:28:02 <dmwit> ...I think.
12:28:05 <osloairport> lol
12:28:06 <b2coutts> I could create a typeclass for all things that can behave like booleans and use it to deal with boolean values, then invent non-Haskell syntax that makes it simpler
12:28:14 <bos> dcoutts: that would explain why hitting the root hackage.haskell.org URL responds instantly, but anything handled by the CGI program does not.
12:28:19 <b2coutts> sure, for the code I'm writing, my changes would make it much more concise and better
12:28:20 <dmwit> osloairport: Only that the existing syntax wasn't too painful because it's not common.
12:28:21 <osloairport> How is that even remotely what I'm doing b2coutts?
12:29:05 <b2coutts> it isn't really, but I'm trying to make an analogy to show you what I mean; that if the code you're writing is worse than regular haskell code, than making a syntax change to improve it to something that's still worse than regular haskell code isn't necessarily a useful change
12:29:22 <osloairport> I suggested a syntax for (let … in …) and (let …), it's not like I added a new feature to the Haskell language and then proposed a new syntax for it
12:29:25 <dcoutts> bos: yes I see
12:29:45 <osloairport> b2coutts: Sometimes it's good to decouple definitions: yes or no?
12:30:11 <b2coutts> osloairport: rephrase that
12:30:34 <b2coutts> do you mean sometimes it's good to split up your definitions into multiple variables?
12:30:34 <Igloo> dcoutts, bos: I have a vague memory that the CGI package does a lookup to fill in an env var or something
12:30:37 <osloairport> Yes.
12:31:06 <b2coutts> I agree, but I don't agree that having multiple let statements in a row leads to the best code
12:31:13 <bos> dcoutts: i've asked for our reverse DNS to be fixed, but really hackage needs fixing too, as this affects an unknown number of other addresses on the intertubes.
12:31:22 <osloairport> I didn't say multiple let statements (expressions)
12:31:23 <bos> Igloo: i can believe that would be true.
12:31:25 <b2coutts> I think the better way is to write generic pure functions outside of the scope of the function you're writing
12:31:39 <b2coutts> ok, in general I agree that it's sometimes good to do this, then
12:32:33 <osloairport> So correct me if I'm wrong b2coutts, but you seem opposed to general usage of let which makes discussing an alternative syntax for let rather strenuous since the topic always goes back to whether the original let was needed in the first place
12:33:00 <dcoutts> bos: I'm just looking at the code to see if it does any lookup
12:33:09 <bos> dcoutts: i bet igloo is on the right track.
12:33:53 <luite> yeah REMOTE_HOST could be it
12:34:13 <b2coutts> osloairport: I don't think I'm opposed to the general usage of let
12:34:21 <dcoutts> bos: found REMOTE_HOST, but it depends on if apache sets it
12:34:33 <b2coutts> I just think that your syntax is an improvement in situations where let is being overused/misused
12:34:56 <dcoutts> bos: certainly our scripts do not use it
12:35:03 * dcoutts looks up apache docs
12:35:37 <b2coutts> and that the reason the resulting code is awkward/unreadable is not because of haskell syntax, but because of misuse of let
12:35:50 <b2coutts> and thus the solution is not to change haskell syntax, but to change how/if you're using let
12:36:05 <dcoutts> bos: "REMOTE_HOST: This will only be set if HostnameLookups is set to on (it is off by default)"
12:36:14 <dcoutts> and we have HostnameLookups off
12:36:57 <osloairport> For numeric code and code where you fiddle bits you often end up with a lot of ‘bindings’
12:37:48 <b2coutts> osloairport: I'm not convinced
12:38:11 <osloairport> and the legibility of code is not the same as the number of characters used to represent it: for example (do line ← readLine; process line) can be better than (process =<< readLine)
12:38:11 <b2coutts> which is why I and others have asked for code samples, since we can't think of such situations
12:38:26 <b2coutts> sure
12:38:33 * hackagebot aws-cloudfront-signer 1.0.0.0 - CloudFront URL signer  http://hackage.haskell.org/package/aws-cloudfront-signer-1.0.0.0 (ChrisDornan)
12:38:35 * hackagebot hscope 0.3.1 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.3.1 (BorisSukholitko)
12:38:37 * hackagebot aws-sign4 1.0.0.0 - Amazon Web Services (AWS) Signature v4 HTTP request signer  http://hackage.haskell.org/package/aws-sign4-1.0.0.0 (ChrisDornan)
12:38:51 <geekosaur> oooo
12:38:57 <b2coutts> but I still don't know of any concrete examples in which code written using your syntax is better than good code written in existing haskell
12:39:19 <Narvius> Does anyone know where I would find the definition of the Read instance for Char?
12:39:40 <osloairport> Narvius: Try Googling “instance Read Char where”?
12:39:46 <scshunt> Narvius: it's built in, I expect
12:40:10 <b2coutts> I'm also biased because I'm a huge fan of short, concise code, but I'll concede that longer code can be better than shorter code
12:40:29 <Narvius> Huh.
12:40:42 <Narvius> osloairport: Thanks. Didn't think of that. I never googled code directly. xD
12:40:54 <osloairport> Yeah ‘short, concise code’ is great in isolation
12:41:15 <osloairport> and almost never great in bigger systems, that has been my experience time and time again
12:41:31 <osloairport> It's bad with Haskell, worse than in other languages imo
12:41:53 <b2coutts> I can't really say as I haven't worked on a large haskell project with other people
12:41:58 <b2coutts> I can see how that might be the case
12:42:23 <[swift]> IMO short and concise is usually fine if it's idiomatic
12:42:26 <tomejaguar> "the legibility of code is not the same as the number of characters used to represent it" -- this I agree with
12:42:31 <[swift]> if you're doing something unusual, it's better to be more explicit
12:42:44 <osloairport> [swift]: Are we going to agree on what's ‘idiomatic’ in Haskell? :)
12:42:44 <tomejaguar> "do line ← readLine; process line) can be better than (process =<< readLine)" -- this I disagree with
12:42:53 <notdan> Narvius: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Read.html#Read
12:43:07 <notdan> Narvius: search for "instance Read Char" on that page
12:43:09 <b2coutts> (at the same time, I think that `countUppers = length . filter isUpper . concat` is a perfectly readable and nice way to write a function to count the number of upper-case letters in a list of strings)
12:43:18 <Narvius> Yeah, I found something already via google, but thanks. :)
12:43:19 <osloairport> Sure, and I would agree with you b2coutts
12:43:21 <[swift]> osloairport: heh, only to some degree i think
12:43:22 <b2coutts> and that this would be fine regardless of scale
12:43:33 * hackagebot aws-elastic-transcoder 0.1.0.0 - Haskell suite for the Elastic Transcoder service  http://hackage.haskell.org/package/aws-elastic-transcoder-0.1.0.0 (ChrisDornan)
12:43:34 <osloairport> But then maybe you want to tweak something
12:43:48 <b2coutts> osloairport: which thing?
12:43:59 <b2coutts> I think point-free is perfectly amenable to tweaks
12:44:01 <osloairport> take the output of one function and pass it to two functions
12:44:06 <osloairport> and then it starts getting messy
12:44:30 <osloairport> then you can use Control.Arrow and have it actually pass a tuple around but ugh
12:44:37 <dmwit> Narvius: (Actually, one of my biggest complaints about Haddock is that it's hard to find instance definitions. So you're not alone.)
12:44:48 <Narvius> :>
12:45:27 <tomejaguar> dmwit: Mine too.
12:47:07 <tomejaguar> osloairport: This argument is one I have heard before for less-than-concise code, so I am inclined to respect it, but I don't have enough experience to have a firm opinion.
12:47:18 <b2coutts> having just read the first bit of what arrows are, they look really cool
12:48:06 <dmwit> Arrows are an awesome tool for writing tuple-munging one-liners to show off in #haskell. =P
12:48:19 <tomejaguar> Arrows are great for writing relational queries :)
12:48:27 <osloairport> I remember a lot of clever^Wbad stuff the Common Lispers used to do
12:48:55 <osloairport> cute in isolation, brilliant concepts but when things started to go wrong and you needed to add new features to it: nightmare
12:49:45 <tomejaguar> osloairport: Could be.  I haven't come across that code in Haskell yet, but I'm hardly edwardk, bos or dcoutts.
12:50:15 <tomejaguar> Maybe they've experienced the same issues.  However, Haskell is the language most amenable to changes of any I've ever used.
12:50:24 <b2coutts> neither have I, and I'm almost dcoutts :P
12:50:55 <dcoutts> heh
12:50:58 <tomejaguar> Yeah, what's with your name?
12:51:27 <osloairport> Having a powerful language cuts both ways, it means you also need to know when not to use all the nifty features: that's my opinion anyway.
12:52:01 <Narvius> If I have a wrapper type for string (so I can define instances for it), but I want it to Read/Show like a regular string - the Show instance is trivial enough, but I'm not sure how to define the Read instance.
12:52:04 <osloairport> I have no idea how we got into that territory from a flippin' syntactic sugar but what ever
12:52:09 <dcoutts> tomejaguar: he really is a Coutts!  (no relation, at least afaik)
12:52:10 <Narvius> Alternatively, is some way around that altogether?
12:52:18 <Narvius> is there*
12:52:33 <tomejaguar> I think it's a fine point of view.  I certainly have it for certain language features, such as typeclasses.  Overreliance on those can be a nightmare.  However, I don't think the same holds for nice pointfree style.  It's not "golf", in a pejorative sense.
12:52:50 <osloairport> Pointfree can certainly become gold
12:53:00 <osloairport> *golf (nice lapsus there)
12:53:02 <dcoutts> osloairport: standard advice with point free is use it when it makes the code simpler/clearer, and not when it doesn't
12:53:11 <osloairport> Right
12:53:17 <b2coutts> funfact: if I had supplied my middle name to my university when I signed up, I would have been bdcoutts
12:53:27 <b2coutts> which would have been even more confusing here
12:53:32 <tomejaguar> Instead you supplied 2?
12:53:50 <b2coutts> well I would have just been bcoutts, but since there was already a bcoutts I'm b2coutts
12:53:58 <tomejaguar> Ah
12:54:03 * osloairport just sees ‘buttocks’
12:54:18 <tomejaguar> osloairport: Are you allowed to do that on public wifi?
12:54:22 <b2coutts> haha yeah, someone make a butt joke about my userid earlier today in another channel
12:54:32 <osloairport> tomejaguar: I'd like to see them try to stop me
12:55:16 <ReinH> osloairport: hiding your unconscious desire to pointfree everything?
12:55:45 <tomejaguar> Hey ReinH, I like your podcast.
12:55:48 <b2coutts> haha
12:55:50 <ReinH> tomejaguar: thanks! <3
12:56:26 <osloairport> Pointfree when used well can be super nice, I never said pointfree couldn't be great
12:56:48 <osloairport> I believe ‘super nice’ is what the kids say these days
12:56:58 <tomejaguar> Yes we do.
12:57:06 <Narvius> Generally, linearly chaining together a bunch of functions is rather clear, I think.
12:57:08 <osloairport> ‘Cool’.
12:57:15 <ReinH> osloairport: also, if lapsus clavis is "slip of the typewriter", what is the correct modern term for computer keyboards?
12:57:30 <osloairport> Lapsus digitorum
12:57:37 <tomejaguar> lapsus qwertus
12:57:37 <ReinH> perhaps
12:57:38 <osloairport> it's not the keyboard that made the mistake
12:57:41 <ReinH> tomejaguar: winner
12:57:53 <ReinH> osloairport: lapsus manus is "slip of the hand"
12:58:07 <osloairport> tomejaguar: How do you propose ‘qwertus’ decline?
12:58:13 <ReinH> osloairport: hilariously
12:58:33 <osloairport> That's not a valid declension
12:58:40 <b2coutts> this channel just got very surreal for me
12:59:09 <ReinH> osloairport: it's almost like jokes don't always have to make sense
12:59:20 <osloairport> Jokes?
12:59:29 <osloairport> I don't like them, irrational.
12:59:35 <ReinH> That much is evident.
13:00:14 <tomejaguar> Anyway, I don't use qwerty so when I make mistakes
13:00:18 <tomejaguar> it's Dvorak Attack
13:00:47 <osloairport> Lapsus Dvorakis?
13:01:04 <ReinH> osloairport: How do you propose 'Dvorakis' decline? :p
13:01:34 <geekosaur> methinks osloairport simply declines :p
13:01:38 <Narvius> "Dvorak" isn't the name of the keyboard itself, it's the name of the layout; So technically that would be if someone fudged up making an actualy Dvorak keyboard, not when you mistype using one.
13:01:50 <Narvius> actual*
13:02:15 <MortyPinkman> Dvorak represent
13:02:27 <ericmoritz> MortyPinkman: woot
13:02:28 <ReinH> I love how pedantic this channel is
13:02:32 <ReinH> I feel so at home
13:02:49 <osloairport> Dvorak, Dvorakis, Dvorakem, Dvorake, Dvoraki …
13:02:50 <donri> colemak represent :(
13:02:55 <b2coutts> I started to use dvorak for a while
13:03:01 <ReinH> osloairport: fair enough
13:03:11 <tomejaguar> I wonder how Haskell users vs Dvorak users breaks down.
13:03:13 <b2coutts> then decided that any advantages it has over qwerty aren't worth the inconvenience of using a non-standard layout
13:03:15 <ericmoritz> <- Dvorak user since 2005
13:03:34 <valyagolev> Dothraki?
13:03:40 <ReinH> I use vim, so dvorak is a nonstarter. Yes, I realize there are remappings.
13:04:10 <Narvius> Last thing I read is that Dvorak doesn't offer any real advantages and that it's really just a matter of preference.
13:04:13 <b2coutts> yeah, the moment I realized that I'd have to change vim to work with dvorak was when I made that decision
13:04:28 <b2coutts> I've heard good things about colemak
13:04:30 <donri> i use vim with colemak. hjkl is useless so i just retrofit them as free keys i didn't have before (if you use hjkl a lot in vim you're doing it wrong)
13:04:45 <b2coutts> well, they're still useful
13:04:49 <donri> the rest of vim's keys are mostly mnemonic anyway
13:04:54 <ericmoritz> ReinH, I switched to EMACS shortly after switching to Vim
13:04:55 <b2coutts> there are lots of situations where you just need to go down a line
13:05:09 <dmwit> I use vim. I didn't change any of the default keybindings. It works fine.
13:05:09 <ericmoritz> s/to Vim/to Dvorak/
13:05:11 <donri> b2coutts: not that useful :) there are many more mappings that do the same anyway
13:05:12 <b2coutts> and I use [count]j and [count]k _constantly_
13:05:29 <dmwit> (...and I use Dvorak.)
13:05:35 <[swift]> donri: not so sure i agree if you have relative line numbers on. j and k are pretty useful
13:05:42 <tomejaguar> I would have used Colemak if I knew it existed when I started learning Dvorak.
13:05:45 <b2coutts> sure, h and l may be less useful, but they're still often what you need for small movements
13:06:13 <ericmoritz> I prefer the EMACS movement keys for the sole reason that they're the same in readline
13:06:14 <osloairport> Have people stopped using ed?
13:06:33 <valyagolev> I saw a screencast on acme and loved it
13:06:36 <donri> [swift]: but you can also use C-n / C-p, -/+, Enter, C-m ...
13:07:11 <donri> [swift]: i mostly navigate by things like paragraphs though, }/{ etc
13:07:33 <b2coutts> donri: what is this, emacs? :P
13:08:03 <b2coutts> j and k are much, much stronger keys than those alternatives
13:08:10 <b2coutts> enter is fairly strong too I guess
13:08:15 <b2coutts> I should remap that to something more useful
13:08:39 <donri> b2coutts: i'm just saying i don't think they're important enough to warrant stealing four single-letter keys or being the deciding factor in using non-qwerty
13:09:10 <b2coutts> well, admittedly it's a bad reason not to use dvorak, since I'm sure there's just a thing you can set to rebind stuff to dvorak
13:09:29 <donri> personally i'm building my own keyboard though which will have arrow keys easily reachable
13:09:36 <b2coutts> I think j and k are absolutely important enough to have what are arguably the two strongest keys on the board
13:09:40 <tomejaguar> donri: how do you build a keyboard?
13:10:00 <b2coutts> h and l I could see being moved to weaker keys, but I think they still deserve having their own keys
13:10:03 <ReinH> donri: My problem is that my muscle memory is very ingrained after a decade or so of vim usage
13:10:07 <donri> tomejaguar: by soldering shit to a pcb :)
13:10:13 <ReinH> if w stopped being where it is I would be completely screwed, for instance
13:10:46 <donri> ReinH: i thought so too, turns out once i learnt the layout itself most vim keys were mnemonic for me
13:11:01 <donri> w is on the same key in colemak though :p
13:11:17 <tomejaguar> donri: Don't you have to make the physical part too?
13:11:31 <koala_man> ReinH: I had the same problem. I could type with dvorak just fine, but all my vim shortcut motions were broken
13:11:37 <donri> tomejaguar: i ordered the parts online
13:12:08 <ReinH> donri: what switches did you use?
13:12:13 <tomejaguar> donri: The IKEA of keyboards?
13:12:32 <enthropy> is there a way to convert between data HList l where HCons :: e -> (HList l) -> HList ((':) * e l); HNil :: HList ('[] *);  and the more lenient  data HCons a b; data HNil?
13:12:49 <aristid> tomejaguar: who? cherry?
13:13:10 <donri> ReinH: it'll be a mix of mostly blues, some greens and i'm trying to get a hold of some latching lock switches for modal keys, and i'm gonna replace the springs on some of the blues to weight them according to finger strength
13:13:12 <ericmoritz> I'm not sure if I would learn Dvorak again if I knew how dumb I'd look trying to type on someone else's keyboard
13:13:13 <tomejaguar> aristid: just wondering where you can get a self-assembly keyboard from.
13:13:23 <aristid> tomejaguar: ah
13:13:32 <ReinH> donri: well that's cool
13:13:43 <enthropy> more generally I'm trying to make http://code.haskell.org/HList/Data/HList/HSequence.hs work with the "better" DataKinds version
13:13:55 <tomejaguar> ericmoritz: almost never an issue in practice, I've found.
13:13:58 <enthropy> is this still #haskell?
13:14:06 <donri> tomejaguar: it's a ready-made kit ;) but you assemble it yourself https://www.massdrop.com/buy/ergodox/
13:14:22 <donri> although this round they added an assembly option
13:14:22 <aristid> enthropy: you are right, this should be in #haskell-blah
13:14:31 <donri> oh shi-- this is #haskell?
13:14:41 <enthropy> you're supposed to fix my problem XD
13:15:26 <dmwit> How do you search in github's issue tracker? -_-
13:15:27 <aristid> donri: yeah whenever there's off-topic talk here, i just assume it's #haskell-blah and don't notice it's actually #haskell :D
13:15:32 <enthropy> then again, oleg didn't update it either
13:16:01 <enthropy> so it might be impossible
13:16:25 <enthropy> dmwit: I couldn't figure it out either
13:17:01 <dmwit> github--
13:18:22 <donri> dmwit: search bar at the top when browsing a repo, then on the results page click issues on the left
13:19:05 <dmwit> donri: thanks
13:19:36 <dmwit> Double thanks; I was about to file a duplicate issue.
13:19:43 <donri> \o/
13:20:12 <enthropy> @karma shi
13:20:12 <lambdabot> shi has a karma of -8
13:20:42 <donri> haha
13:21:45 <aristid> @karma ski
13:21:45 <lambdabot> ski has a karma of 18
13:24:17 <b2coutts> oh
13:24:29 <b2coutts> donri: I often use h and l to delete parts of a word
13:24:46 <donri> b2coutts: not "x"?
13:25:00 <b2coutts> oh, I guess you could use x as well
13:25:07 <b2coutts> I often do things like 3cl though
13:25:13 <b2coutts> which has the nice effect of letting me use . to repeat it
13:25:44 <donri> b2coutts: 3s or 3c<Space>
13:26:08 <FreeFull> Writing merge sort in a language that doesn't have pattern matching really makes me realise how nice pattern matching is
13:26:33 <b2coutts> cool, I didn't know s could take a count
13:26:51 <donri> is there anything that can't? :p
13:26:55 <dmwit> My life changed when I learned about the "i"-motions.
13:27:01 <b2coutts> yeah
13:27:07 <donri> dmwit: text objects
13:27:15 <dmwit> text objects, mang
13:27:17 <donri> "a" is also nice there
13:27:39 <donri> i have like 15 custom text objects set up
13:28:12 <donri> and a bunch of custom operators, and it all just works together, that's nice
13:31:23 <ReinH> dmwit: now go find surround.vim
13:31:39 <n-dolio> Surround is essential.
13:31:54 <ReinH> I paired with tpope for a couple years
13:32:00 <ReinH> that was an interesting time in my vim education
13:32:24 <ReinH> we didn't get much done because I would stop him every 5 seconds and ask him what the hell he just did
13:33:12 <b2coutts> my favourite piece of vim magic is :[range]norm ...
13:33:16 <donri> some of my favorites are https://github.com/kana/vim-textobj-indent and https://github.com/coderifous/textobj-word-column.vim
13:34:25 <Narvius> Is there a more general version of words/lines that works for any (Eq a) => [a] and allows you to supply your own divisor element?
13:34:50 <tulcod> so about the functor monad superclass thing, is this something that in due time will be fixed? are there any plans whatsoever?
13:35:04 <b2coutts> Narvius: split
13:35:05 <b2coutts> @hoogle split
13:35:06 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
13:35:07 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
13:35:07 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
13:35:11 <b2coutts> hmm
13:35:17 <b2coutts> I think it was Data.String.Utils?
13:35:19 <Hafydd> Not in the standard library, Narvius, but there is a package called splitting.
13:35:30 <Hafydd> (or such)
13:35:34 <Narvius> Okay, thank you.
13:35:55 <Narvius> Data.List.Split, yes.
13:36:00 <b2coutts> @src lines
13:36:00 <lambdabot> Source not found. Do you think like you type?
13:36:07 <b2coutts> :(
13:36:22 <dmwit> tulcod: I think it's planned. There was some serious fuss on the mailing list last month.
13:36:36 <tel> tulcod: there's a living proposal, I think slotted for 7.10?
13:36:37 <geekosaur> tulcod: my understading is that it's already in ghc head
13:37:06 <geekosaur> or maybe not, definitely scheduled for an upcoming ghc but 7.8 may be too baked
13:37:13 <jfischoff> why are ghc's parse error messages so bad?
13:37:29 <dmwit> jfischoff: yeah =(
13:37:36 <jfischoff> why can't it say mismatched brace etc?
13:37:49 <Narvius> Because it's too smart for it's own good. >.>
13:38:49 <jfischoff> oh?
13:39:41 <Narvius> The amount of times I got mismatched type error message because of misplaced puntuation or a forgotten function somewhere. :/
13:40:21 <tomejaguar> GHC's error messages are so confusing.  I generally ignore everything except the line number and hit my code until it compiles.
13:40:42 <dmwit> GHC's error messages are usually quite good if you take the time to read them.
13:40:44 <dmwit> Except parse errors.
13:40:59 <tomejaguar> I get very confused about expected and actual types
13:41:02 <Narvius> Yeah, I usually at least read type signatures, if any.
13:41:03 <dmwit> I typically figure a parse error on line 500 means I have 500 lines to inspect.
13:41:12 <dmwit> Which sucks.
13:42:00 <tel> I just recompile things about every third word with -fdefer-type-errors and back up whenever I see 8 page type errors
13:42:03 <Saizan> tomejaguar: expected vs. actual is just topdown vs. bottomup
13:42:31 <tomejaguar> Yeah, I kind of get that, but it's often quite puzzling.
13:42:45 <Saizan> tomejaguar: one is the type the surrounding code would work with, the other is the type inferred about the expression itself
13:42:50 <tomejaguar> especially when you use . a lot
13:43:04 <Saizan> there's no guarantee either is the type you want it to be :)
13:43:28 <tomejaguar> Indeed
13:43:55 <tomejaguar> Lennart Augustsson had a video of Mu, which seems to have friendly type errors.
13:44:32 <jfischoff> @remember dmwit I typically figure a parse error on line 500 means I have 500 lines to inspect.
13:44:32 <lambdabot> Done.
13:45:04 <jfischoff> dmwit: I don't understand why the parser doesn't have any useful info?
13:45:18 <dmwit> I think it just doesn't get a lot of love.
13:45:29 <dmwit> Hacking on type systems is much more fun.
13:45:53 <jfischoff> interesting
13:48:35 * hackagebot xmonad-extras 0.12 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.12 (DanielWagner)
13:49:08 <jfischoff> I want that package just for the deps :)
13:49:12 <Hafydd> WaCkY dEpEnDeNcIeS
13:50:30 <dmwit> Yes, crazy dependencies like... PARSEC
13:50:33 <dmwit> dun dun dun!
13:51:08 <tomejaguar> extensible-exceptions seems to be the only dependency it has that xmonad-contrib doesn't
13:51:08 <lispy> dmwit: i've been sending simon marlow patches for happy to improve it. Perhaps there are things we can do with a shiny new happy that would improve the parse errors.
13:51:22 <lispy> dmwit: Do you have an example bad parse errors?
13:51:30 <dmwit> erm
13:51:42 <dmwit> No, I typically don't keep around source that doesn't parse. =P
13:51:50 <lispy> yeah, me either
13:51:56 <dmwit> But maybe jfischoff still remembers the error that caused his most recent complaints?
13:52:09 <jfischoff> all of them :)
13:52:28 <dmwit> I mean, I could try to cook some up.
13:52:38 <jfischoff> actually I no longer notice GHC's rough edges
13:52:55 <lispy> some parts of happy were written when I was 11...
13:53:05 <jfischoff> spinning up new engineers at work reminds me about the embarassing parts
13:53:06 <lispy> jfischoff: likewise
13:54:04 <lispy> Speaking of which, I have more patches queued up to give to simonMar
13:54:18 <lispy> I've been trying to trickle them in no faster than he merges them
13:54:21 <jfischoff> lispy: what about?
13:54:29 <dmwit> lispy: Perhaps http://stackoverflow.com/search?q=%5Bhaskell%5D+parse+error ?
13:54:35 <lispy> My first order of business was to clean up the sources
13:54:43 <lispy> Some modules had spaces AND tabs
13:54:56 <lispy> And happy predates do-notation
13:55:30 <lispy> jfischoff: my second order of business was to make it so that CLI options could be specified in the grammar file so that you can use those options with cabal
13:55:49 <jfischoff> grammar file?
13:55:55 <dmwit> I dunno. Seems that search turns up more people that just don't understand Haskell than it does genuinely bad error messages, though.
13:56:10 <lispy> jfischoff: and simonMar suggested that 'while you're in there' I could clean up symbol handling. That's turned out to be harder than I expected. Currently happy uses Int for all symbols.
13:56:24 <FreeFull> Narvius: Look at the split package on hackage
13:56:30 <lispy> jfischoff: happy is a parser generator
13:56:38 <lispy> jfischoff: grammar file == .y file
13:56:45 <jfischoff> lispy: any idea why happy can't report unmatched parens, braces etc?
13:57:02 <lispy> jfischoff: TBH, I'm not sure.
13:57:21 <lispy> Originally I was working on this because I wanted to use the GLR backend of happy and cabal wouldn't let me :)
13:57:58 <jfischoff> GLR?
13:58:08 <lispy> jfischoff: if bison/yacc can't do it then I wouldn't expect happy to have an easy way either
13:58:13 <lispy> generalized LR
13:58:25 <lispy> instead of getting back a single parse you get back a family of parses
13:58:29 <jfischoff> oh that would be a reason
13:58:35 * hackagebot memcache 0.0.0 - A memcached client library.  http://hackage.haskell.org/package/memcache-0.0.0 (DavidTerei)
13:58:36 <lispy> so it works well for grammars which are locally ambiguous (like C++)
13:59:06 <lispy> the GLR backend is not the default for happy
14:00:02 <lispy> GLR also does some nice sharing of parse prefixes so it's reasonably efficient
14:00:30 <jfischoff> does it have better error messages ;)
14:00:31 <dcoutts> lispy: great, glad you're adding the grammar type as a directive in the file
14:00:36 <tomejaguar> Hey lispy
14:00:46 <lispy> you're expected to look at the set of parses you get back and figure out if any of them are valid. And in a language like C++ you'd use things like type information to narrow down to a single right parse (or else it's a failure)
14:00:56 <tomejaguar> While we're on the subject, can you explain why happy is a parser generator and not a dsl?
14:01:28 <lispy> dcoutts: At the moment I just did it as a %options { <put whatever you want> }, but I'm thinking about going back and adding a %grammar glr directive a la your github issue
14:01:40 <lispy> tomejaguar: it is a dsl
14:01:56 <lispy> do you mean embedded dsl?
14:02:15 <tomejaguar> err yes :)
14:02:17 <lispy> We could turn it into an embedded DSL by making it a TH library
14:02:29 <lispy> (I would like to do that at some point, actually)
14:02:41 <tomejaguar> Yeah but I guess I really mean a runtime DSL like Parsec
14:03:00 <jfischoff> lispy: bnfcmeta sort of does that
14:03:02 <lispy> I don't see any reason it can't be used that way
14:03:14 <dmwit> I think the usual argument for being a not-embedded DSL is performance, right?
14:03:27 <dmwit> Like, happy the tool does some grammar analysis. Tools like Parsec don't.
14:03:30 <lispy> I would expect the types to get hairy
14:03:38 <tomejaguar> I was guessing the answers of: performance and applicative parsers hadn't been invented yet.
14:03:44 <lispy> dmwit: I would expect it to have a 'compile' phase even if it's dynamic
14:04:03 <dmwit> I see.
14:04:12 <lispy> tomejaguar: from my perspective, happy adequetaly solves some problems of monadic parsers
14:04:34 <lispy> tomejaguar: It allows for static analysis of the grammar (shift/reduce and reduce/reduce conflicts)
14:04:41 <lispy> and it's efficient
14:04:52 <tomejaguar> My lack of knowledge of parsing is letting me down.
14:04:59 <tomejaguar> I don't know what those things are.
14:05:10 <lispy> when parsing we usually want the longest parse
14:05:27 <lispy> and the state machine for LR parser use a "shift" to continue a production
14:05:32 <lispy> and a "reduce" to finish a production
14:06:01 <lispy> when the state machine can't tell if it should shift or reduce from a particular state given a specific input that creates a shift/reduce confilct.
14:06:08 <lispy> It will shift by default to get that longest parse
14:06:19 <tomejaguar> And it's hard to do this with haskell types?
14:06:21 <lispy> and a reduce/reduce conflict is worse because that means two productions match
14:07:08 <lispy> Ah, the types might get hairy because usually people have an AST in mind that goes with the parser. You could define the parser dynamically but the types for the AST would probably need to be defined at compile time, irght?
14:07:17 <lispy> unless you're parsing to a very general structure
14:08:12 <lispy> representing the parser with haskell types is not hard. And the static analysis is not hard either. But monad parsers are too general (in the computational sense) to do the static analysis.
14:08:19 <lispy> It would be undecidable for them
14:08:40 <lispy> Applicative parsers would allow for the static analysis
14:08:42 <lpaste> enthropy pasted “sequencing HLists” at http://lpaste.net/92200
14:08:43 <lispy> But none of them implement that
14:08:54 <enthropy> if anybody cares that's my solution above
14:09:02 <lispy> tomejaguar: does that help or am I just talking nonsense?
14:09:18 <Kevin-_-> If I declared a data type in my .hs file, how do I set up a variable that I can use later on?
14:09:43 <tomejaguar> lispy: that helps but I guess I have a lot to learn about parsing :)
14:10:15 <dmwit> Kevin-_-: What have you tried?
14:10:48 <levi> lispy: Some applicative parsers do some static analysis.
14:11:07 <lispy> tomejaguar: Well, happy is a great way to play with parsers if you want practical experience :)
14:11:08 <Kevin-_-> I have a data type for a BinTree.  I tried example :: BinTree, example = Node ...
14:11:14 <lispy> levi: Do you know which ones
14:11:15 <lispy> ?
14:11:25 <Kevin-_-> I got that from the haskell page under type
14:11:36 <adnap> > let x = Just [2] in (++) <$> x <*> (Just (return . length) <*> x)
14:11:37 <levi> lispy: There's an applicative regex parser, and then uu-parsinglib does a little bit of static analysis.
14:11:37 <lambdabot>   Just [2,1]
14:11:37 <dmwit> Kevin-_-: Okay. What went wrong?
14:11:56 <adnap> > let x = Just [2] in (++) <$> x <*> Just (return . length) <*> x
14:11:57 <lambdabot>   Couldn't match type `[a0]' with `[t0] -> b0'
14:11:57 <lambdabot>  Expected type: [a0] -> [a0] -...
14:12:12 <dmwit> Kevin-_-: Why don't you post a code snippet and the complete error message to lpaste.org?
14:12:21 <Kevin-_-> sure one second
14:12:26 <dmwit> Kevin-_-: Include enough code that we can reproduce the error ourselves.
14:13:26 <lispy> levi: ah yeah, the utrech's folks seem to be pretty savvy about parser theory (using attribute grammars and all that jazz)
14:13:50 <lispy> that's another thing happy supports that I'd like to play with. attribute grammars.
14:14:57 <levi> Their parser is actually a breadth-first, auto-repairing parser that allows mixing of applicative and monadic styles. Of course, it works best when you minimize the monadic style, since it represents a point where the analsyis can't see through.
14:16:01 <levi> I think it's easier to get started with than Parsec, but proabably a bit more difficult to customize.
14:20:56 <Kevin-_-> I thought it posted it once I submitted.  This is where I'm getting my error: http://lpaste.net/92201
14:21:29 <lispy> levi: my main experience with monadic parser libraries is Parsec (and a bit with attoparsec and the toy variants I've written). I see the appeal, but I keep coming back to yacc style generators.
14:22:06 <danharaj> edwardk: is there a library for taking a function that has a class constraint and turning it into an explicitly dictionary passing form?
14:22:25 <edwardk> @hackage constraints
14:22:25 <lambdabot> http://hackage.haskell.org/package/constraints
14:22:38 <tomejaguar> Kevin-_-: Try "example :: BinTree Int"
14:22:50 <raisdead> is there a better way to express `const.const.const.const $ 0`
14:23:04 <edwardk> that idea falls under the purview of constraints. if there isn't a combinator in there for what you want, write one and send me a patch
14:23:33 <Kevin-_-> that worked tomejaguar
14:23:47 <Kevin-_-> is there something I was doing wrong with that?
14:23:57 <monochrom> a better way is "(const.const.const.const) 0". my opinion anyway.
14:24:14 <danharaj> edwardk: So I have a class Foo that technically could be instanced at a particular type Bar, but that's logically unsafe for us to do so. I want to take functions (forall m. Foo m => …) and turn it into a function that taeks a Bar.
14:24:39 <tomejaguar> Kevin-_-: yes, you need to tell BinTree what type the leaves are
14:24:41 <danharaj> Since I know how to construct the proper dictionary.
14:24:56 <tomejaguar> Expecting one more argument to 'BinTree'
14:25:00 <tomejaguar> ^^ that's why it says that
14:25:19 <monochrom> Kevin-_-: because you called it "data BinTree a = ...", not "data BinTree = ...", therefore the types are "BinTree Int", "BinTree Char", etc, not "BinTree" alone.
14:25:23 <edwardk> danharaj: the problem is the m on the right hand side of the => doesn't sit in a position that is necessarily easy to abstract over to make a combinator
14:25:31 <edwardk> danharaj: you're describing a design pattern, not a library
14:25:58 <levi> lispy: I hate preprocessing build steps. I was perfectly happy with an embedded DSL that did parser generation at compile time, but having generated source code lying around just irks me.
14:26:17 <danharaj> edwardk: I was afraid so. I think I know how to do it with reflection and some scaffolding.
14:26:30 <Kevin-_-> ah I see
14:26:31 <Kevin-_-> thanks
14:27:19 <lispy> levi: so happy-TH would solve the problem for you?
14:27:25 <lispy> (not that it exists)
14:27:39 <Hari`> testing 1 2
14:29:11 <Hari`> hi, can you see me?
14:29:18 <levi> lispy: Possibly! Although I often want to parse loosely defined stuff that wouldn't be easy to express in limited-lookahead grammars.
14:30:00 <lispy> Hari`: yes
14:30:13 <Fuuzetsu> Has anyone ever used the Haddock LaTeX backend? I'm trying to make a pdf to eye the result and I hope to add some actual tests for it but I can't even create one. I believe I should be using the style file somehow.
14:30:20 <enthropy> levi: you know with a pragma {-# OPTIONS_GHC -F -pgmF happy #-} -- (or maybe some other program that wraps up happy) you won't see the intermediate files?
14:30:32 <monochrom> you ruined my experiment, lispy. I wanted to see what would happen if no one answered.
14:30:54 <Fuuzetsu> monochrom: #haskell would collapse upon itself
14:31:00 <lispy> monochrom: :)
14:31:14 <Hari`> thanks :)
14:31:39 <levi> enthropy: I haven't actually had the need to parse anything where I had a choice lately, but that's good to know.
14:31:43 <lispy> Has anyone here started using shake? I'm looking for experience reports.
14:31:55 <lispy> (I know neil has some posts about it)
14:32:38 <enthropy> lispy: I've used it once. It works
14:33:50 <lispy> enthropy: any thing that surprised you?
14:37:58 <enthropy> lispy: it is still easy to write ugly code: http://paste.lisp.org/display/138634
14:37:59 <deech> Hi all, can someone help me set up my .cabal file for a C++ binding library? Here's what I have: https://gist.github.com/deech/6346950. I already have the c bindings building using `configure`, but when I do `cabal configure` I get `WARNING: unrecognized options: --with-compiler, --with-gcc`.
14:38:02 <enthropy> but at least it works
14:38:07 <enthropy> *worked
14:38:28 <lispy> enthropy: thanks for the eaxmple!
14:40:20 <dcoutts> deech: you can ignore those warnings
14:40:36 <dcoutts> deech: it's just that cabal is calling ./configure and passing it flags that your ./configure script is ignoring
14:41:25 <dcoutts> deech: or you can make your ./configure use those options (if it's just C it can ignore the haskell compiler, but using the right gcc is handy)
14:41:56 <deech> dcoutts: Ah. And another question I had was that the C bindings are in the form of C++ files with a bunch of extern'd functions. Can I list those with c-sources?
14:42:07 <dcoutts> deech: yep
14:42:27 <deech> Awesome. Thanks!
14:42:36 <dmwit> lispy: Writing shake files is fun and easy. I miss having a make-like top-level command that I can Just Run, though.
14:43:08 <dmwit> There is a qualitative difference between "ghc -threaded shake.hs && ./shake" and "make".
14:43:24 <arkeet> runghc shake.hs ?
14:43:27 <lispy> dmwit: that's good to hear. I'm trying to decide if it's worth switching some code over to make (doing that while I wait on builds)
14:43:51 <dmwit> I don't think I'll ever go back to make without a fight.
14:44:01 <lispy> dmwit: I supose you could make a shell alias/function to make it shorter
14:44:03 <dmwit> make is an awful language.
14:44:09 <arkeet> make is a language? ;o
14:44:13 <dmwit> yes
14:44:17 <arkeet> ;o
14:44:27 <lispy> it's a DSL for graph building/traversal :)
14:44:42 <dmwit> lispy: Of course. But you don't always want to run ghc, and you sometimes want to pass options, and...
14:44:50 <dmwit> lispy: ...and there's always another and. =)
14:44:53 <lispy> but yeah, it suffers from the same issues that shells have (string interpolation and everything is a string, levels of quoting)
14:46:04 <enthropy> "everything is a string" for shells is as wrong as "everything is a function" for haskell
14:46:31 <lispy> enthropy: what would you say instead?
14:46:32 <dmwit> It's wrong about make, too. But writing functions in make is *very* fragile.
14:46:50 <dmwit> In general doing any kind of computation at all in makefiles just isn't pretty.
14:47:10 <dmwit> And yes, complicated build systems need to do computation from time to time.
14:47:52 <enthropy> fragile is a good word
14:48:35 <enthropy> on the other hand I think that shakefile I posted earlier typechecked (relatively) long before it worked correctly
14:48:36 * hackagebot patterns 0.1.1 - Common patterns in message-oriented applications  http://hackage.haskell.org/package/patterns-0.1.1 (TobiasSchoofs)
14:49:14 <dmwit> Oh, yes, I don't think shake tries to make the type system check that you're building your project correctly.
14:49:17 <dmwit> I mean, how could it?
14:50:00 <lispy> we just need a dependently typed file system? ;)
14:50:05 <dmwit> heh
14:50:35 <lispy> I bet πfs is up to the task! Just store the type in the metadata
14:50:50 <lispy> https://github.com/philipl/pifs
14:51:45 <enthropy> there are various things that have been done for web-apps to make sure you don't generate broken hyperlinks
14:52:03 <enthropy> maybe the same ideas apply to build systems too
14:52:46 <dmwit> Well. If you have a newsletter, I'd like to sign up. =)
14:53:50 <enthropy> soon we'll have 50 build systems written in haskell
14:54:00 <enthropy> or have we already passed that number?
14:55:42 <dmwit> Hm. cabal, hmk, shake, hake, redo... any others? =)
14:55:49 <dmwit> ghc --make, I guess
15:04:28 <lispy> the next 500 make systems
15:04:30 <lispy> I can see the talk now
15:07:00 <fylwind> what is the use of the "underlying monad" in Parsec? there is runParser uses the Identity monad, and runParserT which uses a custom monad --> so what would this monad be used for?
15:07:47 <dmwit> My answer *would* be State except that Parsec already builds in State.
15:08:01 <enthropy> IO is an option
15:08:53 <dmwit> I wonder whether using [] as the underlying monad "does the right thing" for nondeterministic parses.
15:08:54 <enthropy> it has to go on the bottom since there isn't an IOT that works properly
15:09:11 <enthropy> @unmtl StateT s [] a
15:09:12 <lambdabot> s -> [] (a, s)
15:10:02 <deech> Is there some way to have two different build phases using cabal? I'd like to run `make` to create a static library and then build my Haskell sources using Cabal.
15:10:08 <valyagolev> johnw ping?
15:10:29 <enthropy> you could have something like:     do s <- lift ["prefix1","prefix2"]; string s -- would be using that non-determinism
15:11:24 <enthropy> deech, maybe build-type: Custom, and then do those two steps in the Setup.lhs?
15:11:50 <enthropy> if you're re-using features already provided by Cabal, it won't take much code
15:12:04 <valyagolev> hmm can you run actual haskell code in fp complete? it shows only "new tutorial" and "new group" buttons
15:12:57 <enthropy> preflex zdec HListzm0zi3zi0_DataziHListziHList_zdWHNil_closure
15:12:57 <preflex>  HList-0.3.0_Data.HList.HList_$WHNil_closure
15:13:03 <deech> enthropy: Do you know of any existing package that does this?
15:13:19 <dmwit> X11 runs ./configure
15:14:16 <dmwit> deech: (That's in response to you.)
15:15:14 <deech> dmwit: I was looking at the X11 bindings :). Unfortunately the problem is that I'm writing C++ bindings so I need to build them first.
15:15:42 <jfischoff> deech!
15:15:46 <dmwit> Okay. Why is running "make" harder than running "./configure"?
15:16:15 <deech> jfischoff: Yo!
15:16:35 <enthropy> deech how are you generating these bindings?
15:17:10 <enthropy> (not that it matters for solving your problem, but for solving my problems :)
15:17:21 <deech> dmwit: Because I want to run `make` first to build the static library and then use cabal for the Haskell bindings. Here's what I'm working with: http://github.com/deech/fltkc
15:17:42 <levi> valyagolev: You have to have an account with access to the IDE to use the IDE. Otherwise, you can just run code inside the tutorial code boxes.
15:17:51 <dmwit> deech: I'm saying you can ask cabal to run make for you.
15:18:34 <dmwit> ...alternately, ask make to run cabal for you. =P
15:18:43 <deech> dmwit: And can I then have it run the `default` defaultMain (the one in Distribution.Simple)?
15:18:59 <dmwit> I'm not sure, but I don't see why not.
15:19:31 <valyagolev> levi hm, are they paid ones?
15:20:11 <dmwit> Oh, X11 isn't a good example because cabal has stuff built in to make using ./configure easier.
15:20:31 <dmwit> I thought X11 used build-type: Custom and ran configure itself.
15:20:39 <dmwit> Sorry for the misdirection there.
15:20:41 <deech> dmwit: I'm also looking at wxcore. They seem to have customized the build process quite a bit.
15:21:12 <levi> valyagolev: I don't really know their plans with regard to that. I know there was a 'register for an invite' beta at some point.
15:22:05 <dmwit> Yeah, I don't know of a good (and simple) example of running a program during the configure step.
15:22:15 <dmwit> All the examples I can think of are very much not simple. =)
15:22:34 <valyagolev> I see
15:23:01 <deech> dmwit: I'll keep digging. I think this is probably an essential thing to master for writing a binding.
15:23:30 <deech> dmwit: Thanks for you help!
15:23:41 <dmwit> deech: I can tell you all the packages that use build-type custom on Hackage as of a few months ago if that would be helpful to you.
15:24:25 <deech> dmwit: Yeah that'd be great. Also ones that have reverse dependencies on c2hs would be helpful. I tried using the reverse deps site and it couldn't find any.
15:26:20 <enthropy> http://hackage.haskell.org/package/ipopt-hs uses c2hs
15:26:25 <enthropy> can't say it's a good package
15:26:47 <lpaste> dmwit pasted “ack -il 'build-type:\s*custom'” at http://lpaste.net/92202
15:27:25 <lpaste> dmwit pasted “ack -il 'build-tools:\s*c2hs' > build-tools-c2hs” at http://lpaste.net/92203
15:27:49 <dmwit> deech:
15:28:10 <deech>  dmwit: Awesome. Thanks~
15:28:16 <deech> s/Thanks~/Thanks!
15:29:04 <Eduard_Munteanu> :t \c f g -> map (\xss@(x:_) -> c (f x) (map g xss)) . groupBy ((==) `on` f) . sortBy (comparing f)
15:29:05 <lambdabot> Ord a1 => (a1 -> [b1] -> b) -> (a -> a1) -> (a -> b1) -> [a] -> [b]
15:29:15 <Eduard_Munteanu> For some reason this seems an interesting combinator.
15:29:54 <Eduard_Munteanu> I wonder if it's defined somewhere or got a name.
15:31:55 <dmwit> The (map g xss) part strikes me as strange.
15:32:35 <Eduard_Munteanu> > let merging c f g = map (\xss@(x:_) -> c (f x) (map g xss)) . groupBy ((==) `on` f) . sortBy (comparing f) in merging (,) fst snd [(True, 11), (True, 12), (False, 24), (True, 7)]
15:32:37 <lambdabot>   [(False,[24]),(True,[11,12,7])]
15:32:41 <dmwit> (Like, why is it in this combinator rather than in the definition of c?)
15:33:09 <Eduard_Munteanu> Well, it's a generalization of the above.
15:33:47 <dmwit> Perhaps you will like fromListWith
15:33:51 <dmwit> :t M.fromListWith
15:33:51 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
15:34:17 <Eduard_Munteanu> Hm, yeah, I know you can do it with a Map instead.
15:34:43 <fylwind> @pl f x = [x]
15:34:46 <lambdabot> f = id (fix (const (: [])))
15:34:46 <lambdabot> optimization suspended, use @pl-resume to continue.
15:34:55 <fylwind> @pl-resume
15:35:01 <lambdabot> f = id (fix (const (: [])))
15:35:01 <dmwit> > let mergeKeys xs = M.fromListWith (++) [(k, [v]) | (k, v) <- xs] in mergeKeys [(True, 11), (True, 12), (False, 24), (True, 7)]
15:35:01 <lambdabot> optimization suspended, use @pl-resume to continue.
15:35:02 <lambdabot>   fromList [(False,[24]),(True,[7,12,11])]
15:35:50 <Eduard_Munteanu> Hm, it does seem a bit cleaner for the pair case.
15:37:32 <dmwit> > let mergeKeys k v xs = M.fromListWith (++) [(k x, [v x]) | x <- xs] in mergeKeys fst snd [(True, 11), (True, 12), (False, 24), (True, 7)]
15:37:33 <lambdabot>   fromList [(False,[24]),(True,[7,12,11])]
15:37:33 <S_J> is there any resources on the shrinking algorithm in quickcheck? i want to implement it in python
15:38:04 <dmwit> > let mergeKeys' f k v xs = f <$> M.fromListWith (++) [(k x, [v x]) | x <- xs] in mergeKeys sum fst snd [(True, 11), (True, 12), (False, 24), (True, 7)]
15:38:05 <lambdabot>   Not in scope: `mergeKeys'
15:38:05 <lambdabot>  Perhaps you meant mergeKeys' (line 1)
15:38:11 <dmwit> > let mergeKeys' f k v xs = f <$> M.fromListWith (++) [(k x, [v x]) | x <- xs] in mergeKeys' sum fst snd [(True, 11), (True, 12), (False, 24), (True, 7)]
15:38:12 <lambdabot>   fromList [(False,24),(True,30)]
15:38:23 <enthropy> S_J read the instances that implement it? There's probably a paper somewhere for quickcheck2
15:40:39 <dmwit> :t \f g xs -> M.fromListWith (<>) [(f x, g x) | x <- xs]
15:40:40 <lambdabot> (Ord k, Monoid a) => (t -> k) -> (t -> a) -> [t] -> M.Map k a
15:42:31 <Eduard_Munteanu> Hm.
15:43:12 <dmwit> :t let flSemigroup f g xs = M.fromListWith (<>) [(f x, g x) | x <- xs]; schwartz f = flSemigroup f return >=> M.elems in schwartz
15:43:12 <lambdabot>     Couldn't match type `[]' with `M.Map k0'
15:43:13 <lambdabot>     Expected type: M.Map k1 c0 -> M.Map k0 c0
15:43:13 <lambdabot>       Actual type: M.Map k1 c0 -> [c0]
15:43:37 * hackagebot language-ecmascript 0.15.1 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.15.1 (AndreyChudnov)
15:43:46 <Eduard_Munteanu> dmwit: which Schwartz is that? :O
15:44:07 <dmwit> :t let flSemigroup f g xs = M.fromListWith (<>) [(f x, g x) | x <- xs]; schwartz f = concat . M.elems . flSemigroup f return in schwartz
15:44:08 <lambdabot> Ord k => (a -> k) -> [a] -> [a]
15:44:31 <dmwit> Eduard_Munteanu: https://en.wikipedia.org/wiki/Schwartzian_transform
15:45:37 <Eduard_Munteanu> Hm, didn't know that had a name.
15:45:49 <dmwit> Yeah, it's pretty easy to invent independently.
15:47:10 <Fuuzetsu> :t Identity
15:47:11 <lambdabot> a -> Identity a
15:47:22 <dmwit> \f g -> M.fromListWith (<>) . map (f &&& g) -- probably a better spelling of flSemigroup
15:47:25 <Fuuzetsu> > Identity False <|> Identity True
15:47:26 <lambdabot>   No instance for (Control.Applicative.Alternative
15:47:26 <lambdabot>                     Data.F...
15:47:26 <bel3atar> how do I get these function to work in ghci? http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/haskell98-2.0.0.1/List.html
15:47:30 <Eduard_Munteanu> I think I've first thought of that as a way to stabilize a non-stable sort.
15:47:59 <dmwit> bel3atar: import Data.List
15:48:26 <dmwit> ...or Data.Foldable. ;-)
15:48:26 <Fuuzetsu> :t liftM2 (||)
15:48:27 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
15:49:07 <dmwit> Fuuzetsu: If you use that and expect short-circuiting, you're gonna have a bad time.
15:49:32 <Fuuzetsu> I don't.
15:49:55 <Fuuzetsu> I feel like this would be implemented somewhere already though…
15:50:33 <dmwit> monad-loops has orM :: [m Bool] -> m Bool
15:52:04 <dmwit> You know... I bet you can do something like this generically with teaspoon.
15:54:00 <dmwit> :t let teaspoon :: a -> Maybe a; teaspoon = undefined; unsafeInterleaveM2 op m1 m2 = do { v1 <- m1; case teaspoon (op v1 undefined) of Nothing -> op v1 <$> m2; Just result -> return result } in unsafeInterleaveM2
15:54:04 <lambdabot> (Monad m, Functor m) => (t -> a -> b) -> m t -> m a -> m b
15:54:18 <dmwit> It type-checks, ship it.
15:56:08 <epta> Could someone share pdf version of "parallel and concurrent programming"?
15:56:16 <bos_> epta: no. buy a copy.
15:56:53 <bos> this is not the right channel to ask people to help you steal stuff.
15:57:54 <djahandarie> (There is a free online version at http://chimera.labs.oreilly.com/books/1230000000929/index.html though, if you're okay with that)
15:58:35 <epta> djahandarie: great
15:58:50 <pentace> When you have an expression like "case e of { _ | p -> ...; ... }", is e evaluated if p is True?
15:59:13 <arkeet> e is never evaulated
15:59:31 <pentace> Never?
15:59:39 <dmwit> Never seems too strong.
15:59:42 <sipa> mind the ..., arkeet
15:59:45 <dmwit> But it is not evaluated when p is True.
15:59:46 <arkeet> unless it's in ...
16:00:00 <dmwit> > case undefined of _ | True -> 3
16:00:01 <pentace> okay
16:00:01 <lambdabot>   3
16:00:10 <dmwit> SCIENCE
16:00:13 <arkeet> but matching against _ does nothing.
16:00:33 <arkeet> well, if evaluating p evaluates e, then sure, e gets evaluated.
16:01:27 <ReinH> These are not the haskell trees I was expecting. http://haskelltree.com/
16:01:33 <FreeFull> You can always use Debug.Trace.trace to see when something gets evaluated
16:01:56 <quchen> FreeFull: Or :sprint.
16:02:02 <dmj`> At Haskell Tree Service, we are totally committed to the care and preservation of your trees.
16:02:14 <dmj`> ReinH: lol
16:03:38 * hackagebot bindings-DSL 1.0.17 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.17 (MauricioAntunes)
16:08:38 * hackagebot DistanceUnits 0.1.0.1 - A comprehensive distance library  http://hackage.haskell.org/package/DistanceUnits-0.1.0.1 (MattGambogi)
16:09:58 <sm> ooh http://www.haskellcast.com/ .. excellent
16:10:11 <dmwit> A mere 35 units? Hardly comprehensive!
16:12:05 <Tene> Care and preservation are good if you want your trees immutable
16:12:49 <arkeet> dmwit: but they're all isomorphic!
16:12:54 <arkeet> oh that kind of unit.
16:20:46 <ReinH> Is there a more elegant way to do this without using catMaybes?
16:20:47 <ReinH> nexts game = catMaybes [ update game move | move <- allMoves ]
16:21:14 <dmwit> well
16:21:32 <jmcarthur> why not use catMaybes?
16:21:37 <dmwit> yes =)
16:21:41 <ReinH> jmcarthur: I am using it, I was just wondering :)
16:21:50 <dmwit> Or turn update into a function that returns lists.
16:22:08 <ReinH> dmwit: right, then I could use >>=
16:22:10 <dmwit> then it's allMoves >>= update game
16:22:20 <arkeet> or use lens
16:22:27 <ReinH> arkeet: that's more what I was looking for :D
16:23:27 <arkeet> allMoves ^.. traverse . update game . traverse
16:23:28 <FreeFull> Or you could use maybeToList
16:23:28 <jmcarthur> ReinH: you could do something like    [ y | Just y <- [update game move], move <- allMoves ]
16:23:29 <arkeet> or something
16:23:33 <arkeet> where the last traverse is _Just
16:23:38 <arkeet> er
16:23:39 <jmcarthur> but catMaybes it nice. don't be afraid of it :)
16:23:39 <arkeet> to (update game)
16:23:41 <jmcarthur> *is
16:24:00 <arkeet> :t \f -> catMaybes . map f
16:24:01 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
16:24:08 <Peaker> arkeet: it's nice to use the _Just rather than traverse..
16:24:13 <arkeet> sure
16:24:32 <FreeFull> [ maybeToList $ update game move | move <- allMoves ] -- This should work
16:24:40 <arkeet> that won't.
16:24:45 <arkeet> you'll get a list of lists.
16:25:09 <ReinH> jmcarthur: I'm not afraid of it, just looking at my options to see if I can learn something :)
16:25:19 <jmcarthur> maybeToList . update game =<< allMoves
16:25:34 <dmwit> :t traverse
16:25:34 <ReinH> FreeFull: you'd have to join it
16:25:44 <arkeet> :t Data.Traversable.traverse
16:25:48 <arkeet> hmm
16:25:50 <dmwit> ?botsnack
16:25:50 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:25:53 <lambdabot> :)
16:27:18 <FreeFull> > [ [x] | x <- [4] ]
16:27:19 <lambdabot>   [[4]]
16:27:21 <arkeet> :t (=<<) . (maybeToList .)
16:27:22 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:27:34 <FreeFull> ReinH: Yeah, you're right
16:27:45 <FreeFull> join or concat
16:28:05 <FreeFull> Or use bind since it happens to be concatMap
16:28:50 <dmwit> > [x | Just x <- [Nothing]]
16:28:51 <arkeet> :t \f l -> l ^.. traverse . to f . _Just
16:28:51 <lambdabot>   []
16:28:52 <lambdabot> Traversable t => (s -> Maybe a) -> t s -> [a]
16:28:56 <dmwit> > [x | Just x <- [Just 3]]
16:28:57 <lambdabot>   [3]
16:29:00 <dmwit> =P
16:29:08 <arkeet> :t \f l -> l ^.. traverse . to f . traverse
16:29:09 <lambdabot> (Traversable t, Traversable t1) => (s -> t1 a) -> t s -> [a]
16:30:06 <arkeet> [ x | Just x <- map (update game) allMoves ]
16:30:23 <arkeet> but that's just a long way of writing catMaybes
16:31:48 <arkeet> :t foldMapOf
16:31:49 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
16:32:29 <arkeet> :t \f l -> l ^. traverse . to f . traverse . to pure
16:32:30 <lambdabot> (Applicative f, Traversable t, Traversable t1, Monoid (f s1)) => (s -> t1 s1) -> t s -> f s1
16:32:34 <arkeet> =)
16:33:22 <arkeet> :t \f -> traverse . to f . traverse . to pure
16:33:22 <lambdabot> (Applicative f, Applicative f1, Traversable t, Traversable t1, Contravariant f) => (s -> t1 s1) -> (f1 s1 -> f (f1 s1)) -> t s -> f (t s)
16:33:58 <arkeet> hm, why does t1 only appear once there
16:36:49 <arkeet> :t (^..)
16:36:49 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
16:38:44 <FreeFull> I don't tend to understand lens's types very well
16:39:10 <tabemann> lens scares me
16:39:38 <arkeet> well, it helps if you don't look at the fully general types.
16:39:39 <arkeet> :p
16:40:32 <joelteon> :t (^.) `asAppliedTo` ('a','b')
16:40:33 <lambdabot> (Char, Char) -> Getting a (Char, Char) a -> a
16:40:38 <joelteon> oh yeah, that doesn't help either
16:41:03 <ReinH> Well, this one isn't so bad
16:41:04 <ReinH> nexts game = allMoves >>= maybeToList . update game
16:44:27 <tabemann> good - my algorithm seems to work now when things are equal... but it fails with <<loop>> when things are not equal...
16:56:47 <haasn> What are the theoretical differences between Agda and Idris?
16:57:15 <tabemann> Idris doesn't make you make your code total
16:57:24 <tabemann> Idris has numeric types other than just natural numbers
16:57:43 <tabemann> Idris is strict
17:01:22 <haasn> ok
17:01:30 <haasn> I thought idris is total, though?
17:01:44 <haasn> isn't the reason it's strict precisely because there's no difference between strict and nonstrict in a total language?
17:03:32 <joelteon> ok so my cabal sandbox includes a source which is a fork of primitive with the version set to 0.6.0.1
17:03:43 <joelteon> inside the sandbox, cabal install primitive-0.6.0.1 fails because no such version exists
17:03:47 <joelteon> why is it ignoring the source?
17:05:06 <tabemann> haasn: idris is a language meant for "general purpose computing", though, which basically excludes totality
17:05:59 <tabemann> and even in a theoretically total language, strict versus lazy does matter, as they effect memory usage significantly, as you can have strict programs that would overflow available memory where their lazy equivalents would not, and vice versa
17:09:37 <haasn> tabemann: looks like idris has optional termination checking
17:10:06 <haasn> and yeah, it's a purely theoretical argument; based on the semantics of the program
17:10:09 * tabemann remembers on LtU basically discussing with someone how "totality" in the Agda sense isn't true *operational* totality, in that it doesn't prevent exhausting all the memory on the system, which of course is equivalent to bottom
17:10:12 <haasn> obviously no PL implementation is turing complete either
17:10:48 <haasn> tabemann: yeah I remember some discussion on that and also Ada
17:11:10 <Tene> You just need to run your programs on a computer that can manufacture more memory as needed.
17:11:31 <FreeFull> Tene: There still will be limits
17:12:15 <FreeFull> What you need is a universe where a turing machine can be made
17:13:11 <tabemann> there are ways to make languages where one can predict, statically, ahead of time whether it will run within the limits of the available memory... but they're restrictive
17:13:49 <tabemann> think only global and stack allocation, with fixed size arrays only, and no recursion
17:14:33 <nh2> bos: ping
17:19:47 <shachaf> haasn: Sure some PL implementations are TC.
17:19:58 <shachaf> Any compiler between TC languages, for instance.
17:21:25 <Jentrep> So everyone saw the Carmack on Hasekll video right?
17:21:47 <quchen> It's a hour-long video where he mentions Haskell, but yeah.
17:21:55 <Jentrep> Thoughts?
17:22:01 <tabemann> is this the Carmack I know of?
17:22:06 <Jentrep> Not sure if it sounds like he will ever use it
17:22:06 <hiptobecubic> there's only one
17:22:14 <haasn> shachaf: it gets hard to define ‘implementation’ at some point
17:22:14 <Jentrep> I mean in an actual product
17:22:24 <augur> john carmack is like immortals in highlander
17:22:30 <augur> there can be only one
17:22:43 <haasn> I was thinking in terms of an actual hardware machine (plus whatever software is running on it)
17:22:48 <shachaf> haasn: Especially when there are pedants around...
17:23:40 * hackagebot bindings-nettle 0.1 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.1 (ClintAdams)
17:23:57 <hiptobecubic> I don't blame him for not using haskell for what he does. Haskell is still in its infancy as far as writing games go. We can even decide on extreme high level ideas like "which programming models work.. at all?"
17:24:00 <nh2> Jentrep: from his talk I get the impression that he would like to, but I doubt it's easy to get a team together in his working environment
17:24:07 <hiptobecubic> People are just starting to have success with them
17:24:39 <haasn> Jentrep: I haven't, but I've read a short summary of it
17:24:48 <Jentrep> nh2: I imagine the cross-section for Haskell devs that are also experienced game devs is rather small
17:25:19 <haasn> unrelated: how possible would it be to mix Hint with unsafePerformIO to provide an Acme.Eval.eval :: Typeable a => String -> a -- ?
17:25:33 <haasn> or preferably also with unsafeCoerce to get rid of the Typeable constraint :)
17:28:24 <enthropy> seems rather possible, haasn
17:28:25 <tabemann> wouldn't eval require using the GHC bytecode compiler and runtime?
17:28:37 <joelteon> anybody had SHA install fail with a stack overflow?
17:28:50 <enthropy> that's what hint makes relatively easy to access
17:28:51 <haasn> tabemann: Hint uses GHC-as-a-library
17:29:26 <geekosaur> tabemann, that's where Hint comes in
17:29:53 * geekosaur are slow
17:31:21 <alkabetz> Has anybody written a library for writing REPLs?  I'm writing something like GHCi (for a different language), and I have a hard time believing this doesn't exist yet.
17:31:39 <tommd> alkabetz: haskeline
17:32:16 <alkabetz> tommd: I'm looking more for something to automate the REPL-level meta-commands (e.g., :help).
17:32:44 * tabemann looked for Hint on Hayoo, and couldn't find anything that fit
17:32:58 <enthropy> @hackage hint
17:32:58 <lambdabot> http://hackage.haskell.org/package/hint
17:33:52 <tabemann> neat
17:36:07 <tabemann> too bad Hint doesn't allow multiple runInterpreters at once... :-(
17:43:50 <johnw> valyagolev: hi
17:48:42 * hackagebot HaskellNet-SSL 0.1.0.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.1.0.0 (DanielWright)
17:56:58 <tolt> This has probably been asked a lot but does anyone have any good project idea? I've had a bit of use with Yesod but I'm wanting to get into a desktop based program.
17:59:09 <alkabetz> Are you looking for application ideas or library ideas?
18:00:08 <valyagolev> johnw hi, I'm having a trouble with cabal install git-monitor
18:00:19 <johnw> let's go to #gitlib
18:00:29 <Kevin-_-> hey guys I'm kind of confused about using the current element in a function.  I have this: http://lpaste.net/92204 and I want to add the current bst to the array returned.
18:00:57 <arkeet> Kevin-_-: (Node t1 x t2) isn't a list.
18:01:00 <tolt> Both I guess. Just something to better understand what management and organization is like in Haskell.
18:01:03 <arkeet> you probably want to put it in a list. :)
18:01:58 <Kevin-_-> yeah I wanted to add that bst to a list
18:02:01 <Kevin-_-> of bst's
18:02:15 <arkeet> Kevin-_-: well, how do you make a one-element list?
18:02:31 <Peaker> Kevin-_-: subtrees t1 and subtrees t2 are lists, so you can ++ them together. (Node t1 x t2) is not a list
18:04:28 <alkabetz> tolt: One library I've wanted to write for a while but have lacked the time for is an interface to one of the Bitcoin exchanges' APIs.  It would be cool to be able to get live Bitcoin quotes in Haskell.
18:04:49 <alkabetz> Of course, if Bitcoin isn't your thing, "pick your favorite Web service and write an API library" doesn't seem unreasonable
18:05:46 <tolt> Ahh. That's a pretty good idea. I never thought about making a API for a web service. I use them all the time though.
18:07:33 <valyagolev> I have a couple of apps running locally or deployed to heroku just giving me a better "interface" for some services, some data for which I'd have to open a lot of pages or something every time I want to see that
18:12:01 <Kevin-_-> arkeet: damn I get it now, the 1 element list helped.
18:13:18 <enthropy> ghc with -XPolyKinds confusingly forgets the :: when it prints types
18:13:39 <enthropy> so that   data X a; :info X  prints data X k a
18:14:54 <tertl3> hello
18:14:59 <Ghoul_> that feel when you write a huge library and get to the end and realize an oversight which invalidates 90% of your code :(
18:15:05 <tertl3> strange question here
18:15:42 <tertl3> is there a text editor that will highlight code that isnt in the standard library
18:16:29 <tertl3> like it would highlight functions that arent in the standard library
18:22:06 <byorgey> enthropy: that is not forgetting the :: .  X takes two arguments: the first argument is a kind and the second is a type.
18:22:17 <byorgey> though I agreee it is printed confusingly.
18:23:40 <byorgey> It would certainly be clearer if it were printed as e.g.  X k (a :: k)  or even  X (k :: BOX) (a :: k)  even though the latter is not valid Haskell syntax.
18:28:19 <tolt> tertl3, what text editor are you using?
18:28:46 <tertl3> sublime text
18:29:20 <tertl3> like Im using the parsec library
18:29:32 <tertl3> it would be cool if text editor knew that but I guess thats asking a lot
18:29:50 <tertl3> no worries
18:30:51 <tolt> hmm, I use emacs but I'm fairly new to Haskell. I use emacs with eclim for java things.
18:32:43 <nh2> tertl3: what would you get from that?
18:33:05 <nh2> I mean if you are using parsec and you know that, why should it tell you?
18:33:23 <tertl3> idk i guess it wasnt  a well thought out question
18:34:18 <enthropy> byorgey:  it wouldn't work to print as something like: X (a :: k)
18:35:34 <enthropy> it feels like an implementation detail that you have the kind variable as an argument
18:35:44 <enthropy> since it doesn't show up in the code that defines X
18:35:59 <nh2> tertl3: well the question of whether some editor can display it is thought out enough, but you must be thinking of some use case I guess
18:37:05 <tertl3> yeah I know it would be rediculous to assume that every hackage package would be covered
18:41:10 <byorgey> enthropy: yeah, I agree
18:46:42 <carter> tertl3 I read the haddocks for libraries
18:47:24 <joelteon> anybody know when cabal will support non-simple builds?
18:47:53 <scshunt> How do I use a local version of a hackage library, to test a patch?
18:48:32 <carter> scshunt install it
18:48:45 <monochrom> if you already have the patched source tree, cd to the source tree and "cabal install"
18:48:48 <carter> or use sandboxing
18:50:28 <Peaker> if you use monochrom's approach, it's important to bump the version number a bit, to prevent "cabal-install" from overriding your custom package install
18:51:00 <carter> ?
18:51:02 <tertl3> haddocks are just for certian libs though right?
18:51:11 <carter> all the libs should ahve haddocks
18:51:16 <carter> unless they have no documentation at all
18:51:31 <carter> not all haddocks are on hackage, because hackage doesn't have the right not haskell deps installed
18:51:38 <carter> hackage2 (coming really really soon) will fix that
18:51:59 <monochrom> coming zenoly soon
18:52:14 <Clint> carter: how's it going to fix that?
18:52:34 <carter> by having an api hook that lets you upload haddocks independently
18:52:45 <Clint> ah
18:53:10 <tertl3> oh i see carter, ty, i guess it doesnt help that Im using Parsec 2
18:53:37 <carter> dcoutts was explaining this earlier today
18:53:45 <carter> theres going to be some docs about this going out soon
18:53:53 <carter> tertl3 why not parsec3?
18:54:15 <tertl3> im doing the "write yourself a scheme in 48"
18:54:22 <tertl3> it uses parsec2
18:54:48 <tertl3> but I might just use parsec3 anyways
18:57:28 <carter> either's fine
18:57:39 <carter> parsec2 has haddocks too…..
18:57:51 <carter> also you should have haddocks locally for EVERY package you've installed
18:58:06 <carter> tertl3 in shell, type
18:58:11 <carter> cat ~/.cabal/config
18:58:20 <carter> and look at the directory they mention for haddocks
19:03:43 <red_> can I get a recommendation on a general article dealing with parallelism and haskell (or pure fp)?
19:04:21 <tabemann> red_: read Simon Marlow's book, Parallel and Concurrent Programming in Haskell
19:04:50 <tertl3> carter ok let me do it in my linux VM
19:05:11 <tabemann> the first part (basically half the book) basically covers parallel programming in Haskell, and later in the book they also cover distributed computing in Haskell
19:05:18 <red_> tabemann:  yeah that looks good .. i want it. i was just looking for an article
19:05:43 <carter> tertl3 you can also read the docs on hackage
19:05:46 <carter> @hackage parsec2
19:05:46 <lambdabot> http://hackage.haskell.org/package/parsec2
19:06:08 <red_> i don't really have a huge intuition as to why purefp is good for parallelization
19:06:29 <red_> other than my crude understanding of church-rosser
19:06:57 <tertl3> ah yes my mistake carter i didnt see the diferent versions at the top
19:07:21 <carter> don't worry about it
19:07:36 <carter> @hackage  parsec
19:07:36 <lambdabot> http://hackage.haskell.org/package/parsec
19:07:37 <carter> also works
19:07:39 <carter> probably
19:08:32 <tertl3> it does
19:08:50 <scshunt> :t maybe
19:08:50 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:12:36 <clj_newb_2345> I recently implemnted parsec for fun. Now, I'm interested in writing tool taht can convert [from: an infix description, with level precedence  + left/right associativity] to [a set of parsec rules]
19:12:42 <clj_newb_2345> what should I study for this?
19:14:52 <tertl3> :t Just
19:14:52 <lambdabot> a -> Maybe a
19:15:04 <carter> clj_newb_2345 you mean a parser generator?
19:15:45 <clj_newb_2345> [input:    "aexpr + aexpr" infix, level 10 ; "aexpr * aexpr" infix, level 2; ] -> output actual parsec
19:15:54 <clj_newb_2345> carter: Is taht what a "parser generator" does ?
19:16:28 <carter> well, why parsec for generating it?
19:16:39 * tabemann is relieved he got the algorithm (seemingly) working, finally
19:17:16 <carter> clj_newb_2345 check out CYK parsing
19:41:33 <tel> red_ immutability + controlled side effects means less shared memory/easier parallelization
19:47:11 <scshunt> why does cabal say that reinstalls are unsafe?
19:47:59 <enthropy> it's not safe to break packages
19:48:36 <geekosaur> ghc does some evil stuff with respect to inlining; this means that upgrading a package will almost always break every package that was built against it
19:48:43 <geekosaur> this can include ghc itself
19:48:56 <geekosaur> (although you'll only notice if you use ghc-as-a-library)
19:53:41 <monochrom> scshunt: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash . in fact, read the whole thing
20:06:25 <astronautaid_> hi guys, i just started working through learn you a haskell for great good… i was wondering what you guys you haskell for?
20:06:53 <astronautaid_> i want to learn it for reasons other than practical purposes, but i was just wondering what y'all use it for day to day
20:07:16 <ion> Mostly for computing the first few numbers of the Fibonacci sequence on IRC.
20:07:23 <alkabetz> *snerk*
20:08:40 <alkabetz> I wrote a compiler in it for school.  (We got to pick our language.)
20:09:27 <Makoryu> astronautaid_: Sometimes I use it for text processing and stuff. Right now I'm writing a game in it.
20:10:04 <Makoryu> astronautaid_: I've never had the opportunity to use it in a professional setting. I've heard interesting things about the places where those opportunities might arise.
20:10:06 <astronautaid_> i see. yeah, i think i'm also looking for a project to do with it, since that's the beset way to learn
20:10:59 <astronautaid_> best*
20:11:06 <alkabetz> Write a text adventure!  That's always fun.
20:11:30 <astronautaid_> good idea. or a game like Makoryu
20:11:57 <alkabetz> Or a Scheme interpreter.  That seems to be a fairly common early project for new Haskellers.
20:12:26 <Makoryu> A text adventure *is* a game
20:13:59 <astronautaid_> another type of game**
20:14:17 <Makoryu> All right
20:14:38 <Makoryu> Graphical games sort of stress the infrastructure though
20:14:51 <Makoryu> By which I mean
20:15:09 <Makoryu> You aren't given a clear path from an empty file to a tight game loop
20:15:23 <Makoryu> And people are still coming up with all kinds of crazy approaches to that
20:16:04 <astronautaid_> gotcha
20:16:10 <astronautaid_> scheme interpreter
20:16:32 <lispy> Makoryu: BTW, there is an IRC channel for Haskell folks that want to write games: #haskell-game (not implying you need to take this conversation there, just pointing out the channel)
20:16:46 <Makoryu> lispy: I'm on it
20:17:01 <Makoryu> That actually is where I want to be. Thank you
20:17:12 <lispy> Makoryu: several of the folks in there maintain libraries you might be using
20:17:18 <lispy> So it can be a good way to report bugs
20:18:13 * lispy starts to get his build shifted over to shake
20:18:29 <lispy> I have about 1% of the build converted. It's kind of nice to be able to use Haskell's abstractions
20:18:38 <lispy> Instead of make's macros
20:19:54 <thoughtpolice> what are you using it for?
20:23:52 <lispy> thoughtpolice: We have a project at work were we need to build some compiler stuff (and that requires a lot of special casing), and then to make sure it works we need to compile the same sources twice and run the program on sample inputs inbetween
20:24:05 <lispy> thoughtpolice: So the build process ends up kind of obnoxious
20:24:48 <thoughtpolice> 'build systems at work' (literally the place you work) are obnoxious almost all of the time, in my experience
20:25:02 <lispy> thoughtpolice: so it's like we compile somethinig. Then we compile something with the result of that. Run that thing. Take the output and compile the thing again. Then make sure that produces the right result.
20:25:28 <lispy> We have it all working with autoconf, make, and some bash
20:25:51 <lispy> I was upgrading some dependencies and had to change something in the build system and had to relearn the whole thing
20:26:05 <lispy> figured, might as well see if shake would work better
20:26:10 <thoughtpolice> OK, if i was to guess - cryptol?
20:26:17 <lispy> nope :)
20:26:21 <thoughtpolice> daw :(
20:26:35 <carter> lispy so you're liking shake a wee bit?
20:26:40 <thoughtpolice> that seemed too easy, anyway
20:26:57 <carter> lispy: some orther iarpa/darpa project?
20:27:06 <carter> *other
20:28:14 <carter> lispy thoughts on shake? i don't have any small project i can try shake out on presently
20:28:58 <lispy> carter: it doesn't allow patterns to overlap (kind of a bummer if you're used to exploiting that in make) but using Haskell's nice abstraction facilities means that you can work around it
20:29:14 <carter> i'm not familiar with make enough
20:29:21 <carter> what sort of patterns?
20:29:24 <AfC> Having to compile and then run a Haskell program to be the build system for something else seems... heavy.
20:29:38 <lispy> carter: Also, (converting from make) it's a bit of a pain to figure out the full environment that a rule was running in and then pass all those things to where they need to be
20:29:59 <lispy> carter: file name patterns, think shell globbing
20:30:51 <carter> i literally don't know enough about make to understand some of what youre saying
20:31:13 <carter> could you elaborate on the first remark?
20:31:27 <lispy> in make you can have a rule like %.o : %.c
20:31:35 <lispy> that means, *.o files depend on *.c files
20:31:49 <lispy> then you can still say thinger.o : thinger.c bar.c
20:31:57 <lispy> and make knows how to deal with that
20:32:01 <carter> ok
20:32:08 <lispy> shake will say, that you have an overlapping set of rules
20:32:40 <carter> ok
20:32:45 <lispy> so you kind of have to be careful about really generic rules
20:33:04 <carter> so you might instead have stuff like
20:33:26 <carter> prefix/*.o depends on prefix/*.c style rules?
20:33:27 <carter> or?
20:33:51 <lispy> Kind of. So another difference is that in make, when you say %.o : %.c, the %s are unified
20:33:56 <lispy> they are the same prefix
20:34:08 <carter> ok
20:34:10 <lispy> but with the globbing the *s don't have to be the same
20:34:28 <carter> makes sense
20:34:38 <lispy> So you tend to see shake rules that look more like *.c.o comes from *.c
20:35:05 <carter> ok….. explain more?
20:35:08 <lispy> And then if your linker needs to do something special with C files compare to, say, C++ files it can tell from the .o's file name
20:35:45 <carter> oh
20:35:46 <carter> ok
20:35:50 <lispy> "*.c.o" *> \out -> do {- something specific to C -} vs. "*.c++.o" *> \out -> do {- something specific to C++ -}
20:36:33 <lispy> make does a lot of implicit chaining. And to make that magic work out there are a lot of builtin rules about how to 'concatenate' things
20:36:34 <carter> thats saying "to get a *.c.o file, heres the action?"
20:36:42 <lispy> yes
20:37:32 <carter> ok cool
20:37:38 <lispy> Shake is pretty new and I have a hunch that a lot of the 'magic' that make does could be ported with some thought
20:37:51 <lispy> and I suspect some monoid instances...
20:37:52 <carter> also neils pretty responsive!
20:38:00 <carter> @hackage shake
20:38:00 <lambdabot> http://hackage.haskell.org/package/shake
20:38:11 <carter> need tor stare at the docs more
20:38:40 <lispy> yeah, maybe. I found that actually using it to build a few things helped more than the docs do
20:40:37 <lispy> neil's advice is to only use shake when cabal or ghc --make can't do the job. That's good advice, but if you actually want to learn shake you'll have to try it on those simple things :)
20:44:36 <carter> yeahhh
20:52:41 <carter> lispy: so you're saying i should use shake on a thing cabal could handle
20:52:49 <carter> to work through using it
20:52:50 <carter> ok
20:54:56 <lispy> carter: I'd start with C
20:55:00 <carter> oh
20:55:01 <lispy> carter: but yeah
20:55:03 <lispy> that's the idea
20:55:07 <lispy> something you understand
20:55:11 <lispy> and it's small
20:55:14 <lispy> hello world
20:55:21 <lispy> then add some random files
20:55:24 <lispy> and some deps
20:55:32 <lispy> see if you can figure out how the new stuff gits in
20:55:48 <carter> are you suggesting instead of doing some haskell code because its simpler/?
20:56:52 <lispy> yeah
20:57:11 <carter> i'd rather be able to rebuild and benchmark my code faster....
20:57:13 <lispy> I literally started with hello-world.c
21:03:28 <nh2> carter: I'm currently building something with shake (like right now). If you want a real project, look at https://github.com/ndmitchell/ghc-make/
21:03:39 <nh2> to try and compile Haskell with shake
21:03:51 <carter> nh2 wait, are you neil?
21:04:01 <nh2> no, I'm Niklas
21:04:04 <carter> ok
21:04:18 <nh2> if I was Neil I had my Shake thing already done :D
21:04:22 <carter> heh
21:04:43 <nh2> I've been working a lot on my branches of https://github.com/23Skidoo/ghc-parmake
21:04:55 <nh2> which uses the ghc -M / ghc -c approach to compile in parallel
21:04:59 <nh2> I got it working now
21:05:22 <nh2> Neil made that ghc-make that basically intends to do the same using shake as a library
21:05:39 <carter> ok
21:05:48 <nh2> there is one problem with it, which is that ghc -M cannot do certain things
21:06:55 <nh2> but if you run a ghc --make after your -M based parallel build, you can get a correct build
21:12:22 <tabemann> sigh... I feel like I need to *prove* my algorithm (a value comparison algorithm based on Brent's algorithm with its own backtracking algorithm) correct, but I frankly have no idea how to prove my way out of a wet paper bag
21:13:54 <PhineasRex> Well, suppose by way of contradiction that you are in a wet paper bag.
21:14:00 * hackagebot llvm-general-pure 3.2.8.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.8.0 (BenjaminScarlet)
21:14:02 * hackagebot llvm-general-pure 3.3.8.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.8.0 (BenjaminScarlet)
21:14:04 * hackagebot llvm-general 3.2.8.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.8.0 (BenjaminScarlet)
21:14:06 * hackagebot llvm-general 3.3.8.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.8.0 (BenjaminScarlet)
21:14:24 <alastor__> does this error message "Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'" mean: "I expected a list but got a function instead"?
21:15:00 <tabemann> alastor_: yes
21:15:26 <alastor__> tabemann: ty
21:15:31 <tabemann> PhineasRex: last time I proved anything was in high school, w.r.t. geometrical theorems
21:17:31 <PhineasRex> tabemann: I am quite rubbish at proofs myself. Perhaps it might be helpful to look at a proof of Brent's method.
21:18:08 <tabemann> Brent's algorithm itself is trivial
21:18:52 <tabemann> the problem is that I'm mapping it over every depthward path through an N-tree, and I need to backtrack after the rabbit meets the turtle such that I never end up in a cycle but also so I never miss any potential paths
21:19:16 <tabemann> i.e. I cannot just backtrack to the start of the cycle, as there are also *other* non-cyclical paths from within the cycle that I need to also traverse
21:20:15 <tabemann> I figured out that I needed to record the start of each cycle and never reenter it again, as I was running into a problem where it would get into nested cycles where it never recognized the outer cycle due to the cycle detection only working on the inner cycle
21:20:48 <tabemann> but I need to prove that I'm not missing nodes due to the backtracking and prevention of cycle re-entrance
21:21:09 <tabemann> and the backtracking isn't proven, as it's my own algorithm, not Brent's
21:21:55 <enthropy> it's easier to find counterexamples
21:24:36 <tabemann> enthropy: proving that it *doesn't* work, if it doesn't, seems harder than proving that it *does* work, which I have no idea about
21:25:30 <tabemann> s/harder/easier
21:26:05 <tabemann> as I only have to consider one case that it doesn't work with, whereas for the latter I need to consider *every* case
21:30:40 <tel> Does anyone have an example of extending STLC with built-ins with monadic effects?
21:31:30 <tel> Like if I include bools and integers and want a built-in && that can fail on bad types into Maybe
21:31:43 <tel> … so for this example, not STLC, just LC
21:50:06 <flazz> is there a terminology for talking about kinds? i've been informally saying kind-one for * and kind-two for *->*
21:50:20 <flazz> but it falls apart after that, but many cases kind-two is enough
21:51:03 <shachaf> Why not e.g. "star" and "star to star"?
21:53:03 <flazz> never thought of that
21:53:51 <flazz> what about * -> (*->*) -> *, star to push start to star pop to star?
21:55:17 <shachaf> However you pronounce "a -> (a -> a) -> a", do that.
21:55:25 <shachaf> It's the same sort of thing.
21:56:01 <dwcook> I usually insert strategic pauses. "a, onto a onto a, onto a" It works for less complex types at least.
21:57:00 * pharaun is pleased that he does not have this issue :)
21:57:20 <dwcook> Yeah, generally when I discuss Haskell, it's in a textual medium, so it rarely presents itself as a problem. :P
21:57:41 <dwcook> I imagine people like edwardk have solved this problem
21:57:42 <pharaun> ^ this or me signing :)
21:57:53 <pharaun> hence i don't have to worry about actually speaking it out :)
21:57:55 <dwcook> You sign the parens?
21:58:02 <pharaun> i don't speak at all :)
21:58:02 <pharaun> and yes
21:58:18 <dwcook> That's something you could do in speech too, theoretically.
21:58:22 <dwcook> It just sounds kind of awkward is all.
21:58:25 <pharaun> i sign it like "star" -> ( "star" -> "star" ) -> "star"
21:58:45 <pharaun> and i actually sign the symbol like -> and parens
21:58:57 <pharaun> its nice with mathy notation that you can sign/draw it out in the air
21:59:03 <dwcook> Indeed :D
21:59:11 <pharaun> i do feel sorry for the interpreters sometime having to voice it out
21:59:26 * tabemann doesn't really talk to anyone IRL about Haskell, so he doesn't have to worry about this
21:59:31 <PhineasRex> I usually just say "open paren"/"close paren".
21:59:52 <tabemann> when I do speak about code I tend to myself say "open paren" and "close paren" a lot
22:00:00 <pharaun> do people actually say "quote" blah blah "unquote" ?
22:00:06 <PhineasRex> Yes.
22:00:08 <dwcook> Sometimes.
22:00:09 <pharaun> really?
22:00:19 <pharaun> that seems like it would sound funny?
22:00:28 <dwcook> It does.
22:00:31 <pharaun> haha
22:00:37 <pharaun> how do you guys speak out complicated equations ?
22:00:39 <PhineasRex> Sometimes I prepend a statement with "in quotes".
22:00:51 <dwcook> Personally, I write down complicated equations. :)
22:00:51 * tabemann says "quote" and "unquote" when talking about code himself
22:01:14 <PhineasRex> But complex statements need the separate quote and unquote.
22:02:04 <PhineasRex> Pharaun: we mostly don't,
22:02:11 <pharaun> ahh i see
22:02:20 <pharaun> guess i'm a little spoiled in that i can air draw the equations
22:02:24 <PhineasRex> You get about five words in then you say "Hold on, let me write that out for you."
22:02:27 <pharaun> haha
22:02:29 <dwcook> Yeah, exactly.
22:02:53 <pharaun> tho fwiw i guess i do prefer a whiteboard as well :)
22:02:56 <pharaun> easier to keep in mind >_<
22:03:08 <dwcook> And when I'm talking to friends about Haskell, I generally have a computer conveniently nearby, where I can *write* code rather than simply speaking of it.
22:03:42 <pharaun> haha yeah
22:03:51 <pharaun> and then you can look things up as needed/etc its just nicer
22:04:34 <pharaun> anyway what did ya guys mean by edwardk having it solved?
22:04:42 <dwcook> edwardk gives talks about Haskell.
22:05:16 <pharaun> yeah i figured, heard that he does, never attended one, should some day, but i feel like the interpreter would be dead within 15 minutes in
22:06:13 <dwcook> I imagine there are usually visual aids, at least.
22:07:16 <scshunt> why are there no Lift instances for template haskell AST types :(
22:09:41 <pharaun> dwcook: i hope so! :)
22:09:53 <pharaun> guess i'll just have to attend one such talk one of these days
22:34:57 <erisco> @pl \a b -> b a
22:34:58 <lambdabot> flip id
22:35:05 <erisco> that isn't a useful result, I think
22:37:14 <begriffs> Can anyone point me to a good list of examples of applicative functors? Not a big explanation, but simply a list cool things they do? I want to absorb how they work by observing the patterns.
22:37:38 <erisco> > (+) <$> Just 1 <*> Just 2
22:37:39 <lambdabot>   Just 3
22:37:44 <erisco> there is my contribution :)
22:37:56 <monochrom> it's a good example
22:38:13 <erisco> :t (+) <$> Just 1
22:38:14 <lambdabot> Num a => Maybe (a -> a)
22:38:20 <tel> begriffs: conor's original paper is *kind of* like that
22:38:36 <erisco> > Just (1+) <*> Just 2
22:38:37 <lambdabot>   Just 3
22:38:48 <monochrom> of course, you won't be hardcoding "Just 1" for real. it's going to be some Maybe value that may also be Nothing
22:39:35 <erisco> > (+) <$> [1..10] <*> [100.110]
22:39:36 <lambdabot>   [101.11,102.11,103.11,104.11,105.11,106.11,107.11,108.11,109.11,110.11]
22:39:41 <PeterPiperPolloc> .
22:39:49 <erisco> whoops... but whatever
22:39:54 <GreatProgrammer> It has come to my attention that haskell is not compatible with javascript.  If this language wants to get out of the dirt it needs javascript + java support to push the boundarys of what we thought was possibly in computer science.
22:40:24 <erisco> GreatProgrammer, /nick GreatTroll
22:40:25 <erisco> :)
22:41:06 <PeterPiperPolloc> I thought it was
22:41:13 <GreatProgrammer> Haskell is a javascript clone and java
22:41:48 <begriffs> erisco: so in one case <*> combined Maybies, and in another it followed a function, can you give me other ways it can act?
22:41:48 --- mode: ChanServ set +o monochrom
22:41:58 <PeterPiperPolloc> You cant be a great programmer if you are in a haskell chat room
22:42:01 --- mode: monochrom set +b *!*@121.99.86.70
22:42:02 --- kick: GreatProgrammer was kicked by monochrom (GreatProgrammer)
22:42:48 <erisco> begriffs, (+) <$> Just 1  is  Just (1+)
22:42:52 <pharaun> hah
22:44:00 <erisco> begriffs, they were both doing the same thing :) Applicative is a type class, so each kind * -> * (such as Maybe) can have its own implementation
22:44:05 <erisco> but the interface remains common
22:44:07 --- mode: monochrom set +b *!*@122-59-82-97.jetstream.xtra.co.nz
22:44:07 --- kick: PeterPiperPolloc was kicked by monochrom (PeterPiperPolloc)
22:44:30 --- mode: monochrom set -o monochrom
22:44:36 <erisco> > (,) <$> "abc" <*> [1,2,3]
22:44:37 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
22:45:09 <erisco> begriffs, here you can see that <*> for the list applicative means cartesian product
22:45:09 <begriffs> GHCI doesn't like it when I enter Just (1+)
22:46:01 <begriffs> erisco: I didn't know (,) is itself a function! Mind = blown.
22:46:03 <erisco> begriffs, <$> is an alias for fmap, just to be clear
22:46:46 <begriffs> <$> is an infix fmap?
22:46:55 <erisco> begriffs, yes
22:48:36 <begriffs> Why doesn't this work? fmap (,) $ "abc" <*> [1,2,3]
22:50:00 <erisco> > (fmap (,) $ "abc") <*> [1,2,3]
22:50:01 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
22:50:01 <monochrom> because it is fmap (,) ("abc" <*> [1,2,3]). but you need (fmap (,) "abc") <*> [1,2,3]
22:50:20 <monochrom> this is why I don't use $, I use explicit parentheses
22:50:35 * erisco likes $
22:51:15 <shachaf> $ is the root of all evil.
22:51:22 <monochrom> also, (,) <$> "abc" <*> [1,2,3] is ((,) <$> "abc") <*> [1,2,3] by setting up the precedence of <$> and <*>, this is why it works
22:51:35 <dmj`> > zipWith (,) "abc" [1..3]
22:51:36 <lambdabot>   [('a',1),('b',2),('c',3)]
22:52:02 <dmj`> > [ (x,y) | x <- "abc", y <- [1..3] ]
22:52:03 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
22:54:04 * hackagebot postgresql-libpq 0.8.2.4 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.4 (LeonSmith)
22:56:34 <spaceships> i vaguely remember '!' and '~' in pattern matching being about forcing evaluation of arguments, but can someone clarify?
22:57:08 <shachaf> > let f ~(!x) = () in f undefined
22:57:09 <lambdabot>   ()
22:57:09 <shachaf> zomg
22:57:13 <erisco> what do you call functions of type a -> a -> a?
22:57:26 <joelteon> functions!
22:57:57 <erisco> yes but the types are important
22:57:57 <spaceships> shachaf: i dont get it
22:58:09 <shachaf> I didn't know that worked, that's all.
22:58:12 <MrRacoon> polymorphic?
22:58:18 <shachaf> I wasn't offering it as an explanation.
22:58:29 <spaceships> oh ok
22:58:31 <shachaf> I don't know where a good explanation is. Maybe try Hoogle?
22:58:39 <erisco> anyways, what I was going to say, and I don't know if it is entirely accurate, but if you have some function of type a -> a -> a, then it might be ideal for an Applicative interface
22:58:44 <shachaf> It has links to wiki pages for keywords.
22:59:24 <erisco> or Applicative implementation, I should say
22:59:29 <shachaf> spaceships: Look for the names "irrefutable" and "bang" patterns.
22:59:37 <spaceships> shachaf: okay, thanks.
23:04:46 <erisco> actually I should say  (a -> b -> c) -> f a -> f b -> f c   ... little closer to the mark :)
23:05:34 <shachaf> If you're saying Applicative has to do with liftA2, you're right.
23:05:37 <shachaf> Also with liftA0.
23:06:14 <erisco> shachaf, nah I'm just saying when I was trying to figure out applicative for myself, I had functions which looked like that
23:06:26 <erisco> and everyone was saying "just use Applicative man"
23:06:49 <erisco> where my f was []
23:06:57 <shachaf> class Functor f where lift1 :: (a -> b) -> f a -> f b
23:07:11 <shachaf> class Functor f => Applicative f where lift0 :: a -> f a; lift2 :: (a -> b -> c) -> f a -> f b -> f c
23:07:25 <begriffs> Would you guys be kind enough to add these applicative examples as comments on my article? I'd like to help myself and other people see the ways they can be used for real. http://blog.begriffs.com/2013/08/weird-symbols-in-their-native-tongue.html
23:09:02 <spaceships> > let f ~(Just x) = "HELLO" in f Nothing
23:09:04 <lambdabot>   "HELLO"
23:10:01 <shachaf> Last time you asked a question here, everyone told you things along the lines of "that's a bad idea, but if you insist on not listening, you can do it this way"
23:10:29 <begriffs> Is this question wrong too do you think?
23:10:31 <shachaf> Then you posted the "you can do it this way part" on your weblog without the discussion of why it's bad.
23:11:19 <begriffs> I guess it just seemed obvious that it was bad, or at least that if you want to do things with less type checking then you might as well do them in another language.
23:11:50 <begriffs> The whole question about faking a dynamic type was just to mess around and see how stuff works.
23:11:51 <erisco> shachaf, I wasn't there, but I don't see how begriffs decision of what to publish on his weblog matters
23:12:55 <erisco> and what does faking dynamic types mean? :o
23:13:07 <shachaf> Well, I don't want to be part of spreading misinformation and bad information.
23:13:24 <erisco> a dynamic type is just a types... a variant on all types :)
23:14:50 <begriffs> I was originally asking if I could make an equality operator that would return False if I tried comparing differently typed things, lika 1 == "hi" would be False and not a type error. Bad idea, but just for fun.
23:15:20 <erisco> begriffs, yes, of course, but not in a practical sense I don't think
23:15:34 <erisco> for Haskell anyways (but maybe some people here have some hackery)
23:16:11 <erisco> begriffs, but if you view a dynamic type as a type that is a variant on all other types, then it clearly wouldn't pose a problem
23:16:53 <begriffs> I actually couldn't do it with Prelude loaded because (==) :: Eq a => a -> a -> Bool
23:17:14 <begriffs> But I'm not trying to drag this room into all this stuff again. Sorry people.
23:17:25 <erisco> begriffs, Eq is a type class, so you'd be fine. how did you try?
23:18:16 <erisco> begriffs, I'm fine with discussing this
23:18:39 <begriffs> erisco: the gritty details are in another article. Sorry for spamming with links to my blog…not sure if this is bad etiquette. http://blog.begriffs.com/2013/08/tricking-haskell-into-being-dynamic.html
23:21:46 <erisco> begriffs, I don't see what problem you ran into exactly. seems to be as you'd expect
23:22:11 <begriffs> Well it only works for things deriving Show
23:23:32 <begriffs> I originally wanted any type to work. In fact even if a type didn't derive Eq I would have liked it to return false if I tried comparing it against another type.
23:23:53 <erisco> begriffs, okay so a couple things
23:24:04 <erisco> begriffs, first, I don't know why you wanted an existential type class
23:24:19 <erisco> begriffs, for example:  let eq a b = show a == show b    seems just fine
23:24:34 <erisco> :t \a b = show a == show b
23:24:34 <lambdabot> parse error on input `='
23:24:39 <erisco> :t \a b -> show a == show b
23:24:40 <lambdabot> (Show a, Show a1) => a -> a1 -> Bool
23:25:03 <erisco> > let eq a b = show a == show b in eq 5 "5"
23:25:04 <lambdabot>   False
23:25:37 <erisco> begriffs, secondly, you aren't being too clear on what you are after
23:25:41 <begriffs> Oh cool, it didn't restrict the arguments of eq except for them supporting Show
23:26:27 <erisco> begriffs, determining that type A is not type B is not the same as determining their values are equal
23:27:14 <erisco> begriffs, the compiler will barf when you have mismatched types, so that isn't a concern at compile time
23:27:36 <begriffs> OK, here's the full specification of the desired eq function. eq x y if and only iff a has the same type as b, that type supports Eq, and a == b.
23:27:51 <erisco> begriffs, if you want to compare their values, then saying "I want it to work for all types" doesn't make sense, because you need an actual implementation for how the values are compared
23:28:51 <begriffs> I think over all it's not something I really want to do, and thinking about it taught me some things so I'm happy moving on and learning more realistic Haskell coding.
23:30:06 <erisco> begriffs, you would need type information at runtime for your operation. Haskell doesn't have this (afaik)
23:31:14 <erisco> otherwise I can't think of what use such a function has
23:31:28 <begriffs> erisco: thanks for discussing it with me. I've gotta get going to bed.
23:33:26 <erisco> I can't think of a compelling compile time scenario where such an operation is useful ... but would be interested to see one
23:35:57 <erisco> in Haskell, I think the worst you'll come to is taking an argument of (a -> b -> Bool)
23:40:00 <mbrock> look at Data.Typeable
23:40:06 <mbrock> :t cast
23:40:07 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
23:40:12 <erisco> he's gone =\
23:40:20 <erisco> but someone gave him those suggestions already on his blog
23:40:43 <joelteon> > cast 1 :: Maybe Bool
23:40:44 <lambdabot>   Nothing
23:40:46 <mbrock> oh okay
23:42:34 <erisco> does Data.Dynamic use serialization or what?
23:42:58 <luite> no it uses Typeable
23:43:25 <luite> which means it keeps a signature of the actual type of every Dynamic around
23:43:44 <luite> so that when you convert it back, it first checks if the signature is correct, returns Nothing if it isn't
23:47:09 <erisco> luite, I don't get it
23:47:46 <erisco> Typeable is a class to get unique value identifiers for types, right
23:47:47 <erisco> ?
23:49:01 <erisco> :type cast
23:49:05 <erisco> :t cast
23:49:05 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
23:51:11 <luite> erisco: right, for every instance of Typable you can get a TypeRep
23:51:25 <erisco> > toDyn 5
23:51:26 <lambdabot>   <<Integer>>
23:51:35 <erisco> > fromDyn . toDyn $ 5
23:51:36 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
23:51:36 <lambdabot>    arising from a use ...
23:51:44 <luite> Dynamic stores a TypeRep, along with the original value
23:51:53 <erisco> how does it store the original value?
23:52:18 <luite> by unsafeCoercing it to Any
23:52:25 <erisco> ah ha
23:52:43 <erisco> see I was wondering where the loophole was
23:53:04 <erisco> :t Any
23:53:05 <lambdabot> Bool -> Any
23:53:35 <erisco> :t unsafeCoerce
23:53:35 <lambdabot> Not in scope: `unsafeCoerce'
23:55:27 <luite> erisco: Any is a special thing that's safe to unsafeCoerce any regular (not unboxed) haskell value to and from
23:55:53 <erisco> "not unboxed" what do you mean?
23:58:00 <luite> something that can be a thunk, GHC has unboxed values like Int#, that are stored as machine words, they cannot be a thunk and can't contain bottom
23:59:38 <erisco> I see
23:59:49 <erisco> (well, I still don't know what bottom is, but I get what you're saying there)
