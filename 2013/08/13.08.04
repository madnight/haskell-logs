00:04:24 <db81> do we have a modern alternative to System.Directory that uses Text and stuff?
00:04:33 <johnw> Filesystem
00:04:41 <johnw> from system-fileio and system-filepath
00:06:08 <db81> thanks
00:06:28 <johnw> i use both extensively, if you have questions
00:09:17 <pharaun> Filesystem is pretty nice :)
00:13:00 <MouseTheLuckyDog> Is it a requirement of monads that the unit/return function is injective?
00:19:08 <johnw> MouseTheLuckyDog: parametricity guarantees it
00:22:23 <elliott> wat
00:22:27 <MouseTheLuckyDog> johnw, while I can't think of a counterexample I don't see why that has to be so.
00:22:37 <johnw> consider return :: Monad m => a -> m a
00:22:40 <elliott> johnw: no
00:22:44 <elliott> data Foo a = Foo is a monad
00:22:50 <johnw> oh
00:22:54 <johnw> good counter-example, thanks
00:23:05 <johnw> i forget that "m a" might forget the a
00:26:46 <MouseTheLuckyDog> IS that like  a forgetful functor?
00:29:33 <johnw> i think so; then the adjoint would what, pick some distinguished element from a?
00:30:52 <MouseTheLuckyDog> elliot: If I understand correctly you are saying that a the rules of Haskell allow you define such a monad. But would you want to define monads to explictlky exclude such constructs?
00:32:02 <elliott> it is a monad in both the Haskell and the category theory sense, and is perfectly valid
00:35:32 <MouseTheLuckyDog> But from a programming sense? You don't want to lose information when you move to the equivalent monad value.
00:35:44 <johnw> return _ = Foo; _ >>= _ = Foo
00:35:55 <elliott> why not?
00:36:09 <elliott> I don't see where "equivalent" comes into it, really.
00:36:24 <elliott> Foo is as valid a monad as () is a data type
00:36:50 <mm_freak> MouseTheLuckyDog: functors (monads are functors) are often taken as arguments, and sometimes you want to pass the unit functor to say, "no functionality at all here"
00:37:02 <elliott> anyway, the free theorem of return gives you
00:37:08 <elliott> liftM f (return x) = return (f x)
00:37:20 <elliott> so in a sense return is always going to ignore its argument or "store it fully".
00:37:26 <elliott> but I don't really see why you'd care about this :P
00:37:28 <mm_freak> i think the best example is coroutines:  newtype Coroutine f a = Coroutine (Either (f (Coroutine f a)) a)
00:37:54 <mm_freak> Coroutine Unit is the monad for non-suspendable computations
00:37:55 <MouseTheLuckyDog> Well for one thing when you do a calculation then lift it into the monad and lose information  then you've wasted resources doing part of the calculation.
00:38:02 <elliott> that already has a name, y'know :/
00:38:23 <elliott> MouseTheLuckyDog: I don't quite understand
00:40:19 <mm_freak> elliott: yes, Coroutine is equivalent to Free
00:41:03 <mm_freak> sometimes though "Coroutine" highlights better the role of the "suspension functor"
00:41:19 <MouseTheLuckyDog> elliott: Because when it comes down to it, you want to do something with a program with as little effort as possible.  When you calculate stuff then lift into you Foo monad, then you are throwing away a lot of effort.
00:41:56 <elliott> MouseTheLuckyDog: then don't pick Foo?
00:42:22 <elliott> you can also do all your calculations and then run them through the function (\x -> const () $! x) and now you've wasted a lot of effort for nothing. should that function be banned?
00:42:33 <elliott> also, Foo's return is lazy, so in actual fact none of the wasted calculations will be done
00:43:01 <mm_freak> MouseTheLuckyDog: (Monad m) => m a -> m ()
00:43:12 <mm_freak> would you say that it's a waste to ever apply this function?
00:43:35 <mm_freak> after all you are forgetting the argument's result value
00:44:12 <MouseTheLuckyDog> mm_freak: That's almost identicle to elliott's Foo monad.
00:44:19 <c_wraith> :t void
00:44:20 <lambdabot> Functor f => f a -> f ()
00:44:39 <mm_freak> MouseTheLuckyDog: it's related, but not even close to identical =)
00:44:46 <Gracenotes> I'm not sure what the issue is. Foo is actually a useful type sometimes, and it happens to be the Monad, so wynaut
00:44:55 <mm_freak> MouseTheLuckyDog: let me give you an example though:
00:44:59 <mm_freak> :t forkIO
00:44:59 <lambdabot> Not in scope: `forkIO'
00:45:08 <mm_freak> forkIO :: IO () -> IO ThreadId
00:45:26 <mm_freak> you want to apply forkIO to c :: IO String
00:45:31 <mm_freak> but that's a type error
00:45:36 <mm_freak> what do you do?
00:47:04 <BMeph> MouseTheLuckyDog: As an aside, strict/eager eval systems throw away efforts as a matter of routine. :)
00:47:54 <BMeph> :t forever
00:47:55 <lambdabot> Monad m => m a -> m b
00:48:07 <mm_freak> BMeph: please don't spoil
00:48:27 <mm_freak> if you were going to =)
00:48:51 <BMeph> mm_freak: Sorry, I'll be good.... ;)
00:48:58 <BMeph> :t when
00:48:59 <lambdabot> Monad m => Bool -> m () -> m ()
00:49:20 <BMeph> mm_freak: Better? ;p
00:49:36 <mm_freak> you've now given another instance of the same problem =)
00:50:51 <MouseTheLuckyDog> Ah BMeph but they don't generally collapse the computation space.
00:53:51 <Gracenotes> not the entire space, but that's silly. people use compositionality of computational spaces all the time.
00:54:52 <Gracenotes> personally I can't think of any uses of instance Monad Foo, although Foo has its uses... yeah that is a bit silly.
00:55:19 <Gracenotes> but it's correct, and there's no ambiguity about its correctness
00:55:47 <mm_freak> Monad Foo is as useful as Monoid ()
00:57:32 <Gracenotes> (Foo is sometimes called Proxy, and there are more catty terms for it as well)
00:58:10 <MouseTheLuckyDog> I haven't looked at concurrency yet. I'll have to give  if some thought. All the examples mentioned are a reduction of the original type ( a in a->M a ) to one value. I'm worried about examples where for example for instances where the original type is reals , return maps all reals which have the same greatest int into the same value but all reals with different greatest int to different values.
00:58:41 <elliott> MouseTheLuckyDog: that is not possible.
00:58:48 <elliott> like I said, the free theorem for return prevents it
00:58:53 <mm_freak> example:  M m a, where M is a monad denoting functionality that may log stuff:  runM :: (Monad m) => M m a -> (a, m ())
00:58:56 <elliott> because liftM f (return x) = return (f x)
00:59:04 <mm_freak> if you don't want a log you use M Foo
00:59:04 <elliott> informally, either return ignores everything or nothing.
00:59:20 <mm_freak> and that also establishes the relationship between M Foo and Writer ()
00:59:24 <mm_freak> and thus Foo and ()
00:59:40 <mm_freak> so yes, you might actually use even Monad Foo
01:00:40 <Gracenotes> MouseTheLuckyDog: this blog post was recently posted. http://blog.tmorris.net/posts/identifier-names/index.html
01:00:40 <MouseTheLuckyDog> elliott sp what you are saying is that either return in injective or "degenerate".
01:00:44 <exicer> If anyone had a chance to look at this code review for me, that would be awesome :) http://codereview.stackexchange.com/questions/29363/how-can-this-be-improved
01:00:46 <Gracenotes> about parametricity
01:01:37 <elliott> MouseTheLuckyDog: well, I am saying that return cannot behave differently for the reals.
01:01:52 <elliott> parametricity means it must handle all types uniformly
01:02:18 <Gracenotes> if you have a Monad instance and something Monad m => m a, well, the person who wrote the instance for 'm' gets to choose the instance's behavior, but the person who uses the instance gets to choose 'a'.
01:02:29 <Gracenotes> This means that the person who wrote the instance knows nothing about 'a'
01:03:11 <mm_freak> (to be fair, the person writing the Monad instance often doesn't even get to choose the behavior)
01:04:53 <kryft> Where do cabal packages typically get installed if I want to read the source for something?
01:05:00 <mstksg> is there a shorthand for "let foo = bar" in ghci...some colon thing?
01:05:02 <Gracenotes> they can make semantics, at least, for auxiliary functions. (like get/put)
01:06:08 <Gracenotes> kryft: you can use cabal unpack for that purpose, at least
01:06:09 <mm_freak> kryft: the source isn't installed
01:06:39 <mm_freak> if you need the source for reference, first install hscolour and then cabal install --haddock-hyper
01:06:53 <MouseTheLuckyDog> elliot: SO instead of greatest int, would it be possilbe to make a monad where return maps values with different absolute values to the different values but the same absolute value to the same value.
01:06:54 <mm_freak> this gives you haddock docs with source code links
01:07:01 <mm_freak> other that that what Gracenotes said
01:07:55 <int-e> mstksg: if you have many lets you want to type you can open a block with :{, type 'let' on a single lines and then precede each  foo = bar  by a single space; close the block with :}. But you lose instant syntax and type checking
01:08:52 <Gracenotes> what'll that monad do for non-number types?
01:09:20 <mstksg> int-e: thanks
01:09:34 <MouseTheLuckyDog> Gracenotes, you can specify something.
01:09:54 <int-e> mstksg: (I rarely use :{ ; I tend to put declarations into a haskell source file that I :load instead, and reload with :r after changes)
01:10:13 <mm_freak> MouseTheLuckyDog: no, you can't
01:10:24 <Gracenotes> I'm not sure if you can. Someone might invent a type just to put it in your monad, and they might not even tell you first.
01:11:09 <mm_freak> MouseTheLuckyDog: try to write a function f :: a -> Int with f x = 3, if x is an Int and f x = 4 otherwise
01:12:00 <mm_freak> if you can do that, you can "specify something"
01:12:11 <kryft> mm_freak: Oh, thanks
01:12:35 <MouseTheLuckyDog> mm_freak: That's just a characteristic function.
01:12:42 <mm_freak> kryft: keep in mind that you need 'documentation: True' in your ~/.cabal/config for that to work
01:13:37 <kryft> mm_freak: I presume I just uncomment that in the config file
01:14:03 <kryft> mm_freak: Why hscolour?
01:14:04 <mm_freak> MouseTheLuckyDog: well, say you're inventing an AI (AlmostIdentity) monad, where return x = AI x, but if x is of type Int, then return x = AI (x + 1)
01:14:07 <mm_freak> MouseTheLuckyDog: possible?
01:14:26 <mm_freak> kryft: yes, and hscolour is used to highlight the source code
01:14:40 <mm_freak> you get pretty HTML source code just like in hackage documentations
01:15:08 <kryft> mm_freak: Ah
01:15:34 <Gracenotes> in Haskell, there's no notion of negating a type, or making a function a -> Either (¬¨b) b. .. probably not a useful explanation, that. But, yes, no excluded middle.
01:15:34 <MouseTheLuckyDog> Gracenotes: Just take the space of all values. Make a two-fold covering of the values. Then define the monad over the   the two fold covering and you have something similar to my absolute value argument.
01:15:44 <kryft> Just reading the plain source with an editor is probably more convenient in this case, but that's good to know
01:16:04 <Gracenotes> what's a two-fold covering, here?
01:16:25 * elliott is getting more confused by the second.
01:16:30 <mm_freak> MouseTheLuckyDog: whatever you do (i don't even understand what you're talking about), it will depend on you being able to write that function i asked you to write
01:17:03 <mm_freak> a :: a -> Int, such that f (x :: Int) = 3, but f (x :: SomethingElse) = 4
01:17:07 <mm_freak> f :: a -> Int, such that f (x :: Int) = 3, but f (x :: SomethingElse) = 4
01:17:29 <mm_freak> that's what elliott refers to as parametricity
01:17:48 <ClaudiusMaximus> is MonadRandom really this bad or is am I Doing It Wrong?  http://mathr.co.uk/tmp/Palette.svg heap profile output :/
01:17:55 <mm_freak> such a function is impossible in haskell‚Ä¶  maximum (full) polymorphism means minimum (zero) knowledge
01:18:18 <Lethalman> ClaudiusMaximus, it's that bad, I suggest using mersenne
01:18:31 <mm_freak> ClaudiusMaximus: i prefer (RandomGen g, MonadState g m) over (MonadRandom m)
01:18:50 <ClaudiusMaximus> ok
01:18:53 <ClaudiusMaximus> thanks :)
01:19:00 <mm_freak> ClaudiusMaximus: the heap profile you're getting is probably not the fault of MonadRandom though, rather of the RandomGen instance
01:19:16 <mm_freak> or the way you used it (build up a huge thunk, but never evaluate it)
01:21:28 <mstksg> is there a generalized way to check which value constructors are in a value of a data type?  kind of like isJust or isNothing
01:21:55 <mstksg> the only way i know of is to use a case statement for pattern matching but i am looking for somethjing i can put on one line
01:23:14 <mm_freak> mstksg: well, there are prisms in the lens package
01:23:43 <mm_freak> > Just 3 ^? _Just
01:23:45 <lambdabot>   Just 3
01:24:00 <mm_freak> > isJust (Left 3 ^? _Left)
01:24:01 <lambdabot>   True
01:24:05 <mm_freak> > isJust (Left 3 ^? _Right)
01:24:06 <lambdabot>   False
01:24:31 <mstksg> mm_freak: thanks, i'll look into prisms
01:24:38 <elliott> > has _Left (Just 3)
01:24:39 <lambdabot>   Couldn't match type `Data.Either.Either b0 c0'
01:24:39 <lambdabot>                with `Data.Ma...
01:24:42 <Gracenotes> mstksg: as long as it doesn't cause pattern matches later on to fail
01:24:45 <elliott> um.
01:24:49 <elliott> > has _Left (Left 3)
01:24:50 <lambdabot>   True
01:24:53 <elliott> > has (element 3) [1..]
01:24:55 <lambdabot>   True
01:24:56 <mm_freak> ah =)
01:25:11 <mm_freak> 'has' was the function i failed to recall =)
01:25:34 <mstksg> my use case is Pandoc's "Block" data type which has several value constructures (header, paragraph, block quote, etc.) and i'm looking for a quick boolean to tell me if a block is a para or a header, etc.
01:26:05 <mm_freak> yeah, prisms give you that, if you don't consider them overkill and you're ready to use makeLensesWith =)
01:26:18 <mm_freak> pandoc doesn't provide the prisms by itself
01:26:31 <mstksg> is there a lot of baggage/overhead that comes with prisms
01:26:47 <Gracenotes> yes. tons.
01:26:48 <mstksg> if i just need this in one place in my program maybe i should just make it a where
01:26:55 <mm_freak> there is a slight overhead that is due to van laarhoven lenses
01:27:29 <mm_freak> i'd just write a predicate
01:27:35 <mm_freak> or pattern-match
01:27:49 <mstksg> is there a way to do an inline pattern mach?
01:27:52 <mstksg> match
01:27:57 <mm_freak> case?
01:28:16 <mm_freak> > case Just 3 in Just x -> x; Nothing -> 5
01:28:17 <lambdabot>   <hint>:1:13: parse error on input `in'
01:28:19 <mstksg> there's an inline syntax for case? gotta look that up
01:28:22 <mm_freak> > case Just 3 of Just x -> x; Nothing -> 5
01:28:23 <lambdabot>   3
01:28:32 <mm_freak> wow, that was embarassing
01:28:46 <mm_freak> mstksg: what is an inline syntax?
01:28:48 <Gracenotes> 'where' is still nice because you can give it a name
01:28:57 <mstksg> it's just what you wrote
01:29:05 <mstksg> case without breaking it out into multi-line
01:29:10 <mstksg> but i think i'm going to break it out into a 'where'
01:29:15 <mstksg> give it a name
01:29:20 <mm_freak> > (case Just 3 of Just _ -> id; Nothing -> const "blubb") "blah"
01:29:21 <mstksg> make it easier on myself in a few months
01:29:21 <lambdabot>   "blah"
01:29:27 <mm_freak> > (case Nothing of Just _ -> id; Nothing -> const "blubb") "blah"
01:29:29 <lambdabot>   "blubb"
01:29:51 <mm_freak> there is nothing wrong with using multi-line case inline
01:30:06 <mm_freak> i do that with `if` regularly
01:31:46 <mstksg> it looks kind of ugly but that might just be my untrained eyes
01:32:14 <mm_freak> no, single-line case is ugly =)
01:32:45 <mstksg> oh i misread you
01:32:46 <mstksg> haha
01:33:52 <mstksg> i'm using it as the predicate of takeWhile
01:34:05 <mstksg> so i'm not sure how to make that cleanly multi-line
01:34:51 <mm_freak> mstksg: one simple and elegant way to do it is to map what you need to Maybe and fmap over it:  fmap f (paraOf x) <|> fmap g (headerOf x)
01:35:02 <mm_freak> then f and g can just assume that it was a para/header respectively
01:35:35 <mm_freak> if you need to be able to "go back" into Block, then a prism may indeed be what you need
01:35:36 <Gracenotes> with LambdaCase, there's also
01:35:38 <Gracenotes> > (\case { Just x -> const x; Nothing -> id }) (Just 5) 10
01:35:39 <lambdabot>   <hint>:1:3: parse error on input `case'
01:35:53 <Gracenotes> I still prefer 'case of' syntax, but it was not to be
01:36:18 <Gracenotes> not really any point to that, but it exists
01:36:50 <Ghoul_> I think `case of` is really ugly most the time
01:37:14 <mm_freak> mstksg: if you want to append "x" to headers and "y" to paragraphs and you have prisms _Header and _Para, you would simply do this:  (_Header . text <>~ "x") . (_Para . text <>~ "y")
01:37:16 <Ghoul_> I don't know why, but often the case of part hangs longer than the lines below and it makes me want to erase it and just rewrite it with guards or pattern matches..
01:37:30 <mstksg> ghc-mod/hlint is telling me to "use record patterns" in `case b of Header _ _ _ -> True`
01:38:14 <mm_freak> mstksg: Header {} -> True
01:38:15 <Gracenotes> I mean, literally 'case of'
01:38:22 <Gracenotes> without anytihng between 'case' and 'of'
01:39:32 <mstksg> mm_freak: ah thanks that's briliant.
01:39:54 <mstksg> are there other ways i can abuse record syntax in case statements?  like pattern match for a specific record?
01:39:58 <mstksg> i guess i could just test it out.
01:40:13 <seliopou> is there a way to include shell scripts in a cabal package?
01:40:25 <mm_freak> mstksg: that's not an abuse
01:40:45 <mm_freak> mstksg: you can pattern-match for fields:  Header { blah = 3 }
01:41:06 <Gracenotes> null [ () | Header{} <- things ]
01:41:08 <mm_freak> mstksg: and give them variable names:  Header { blah = x, blubb = y }
01:41:19 <Gracenotes> ^ someone mentioned abuse?
01:41:43 <mm_freak> mstksg: it means, there is blah with x and blubb with y, disregard all other fields
01:41:44 <mstksg> mm_freak: oh nice :)
01:41:58 <mstksg> was not aware of that bit of sugar
01:41:59 <mm_freak> then by extending that logic Header {} means:  disregard all fields =)
01:43:38 <mstksg> pretty handy
01:44:16 <elliott> Gracenotes: yikes.
02:39:46 <salllo> hi
02:40:36 <CADD> o/
02:40:55 <salllo> hi
02:41:22 <chrisdone> has anyone managed to make the haskell2010 report with the makefile?
02:41:32 <salllo> ya
02:41:41 <chrisdone> on ubuntu/debian?
02:42:59 <hpaste> chrisdone pasted ‚Äúlatex output‚Äù at http://lpaste.net/76662967210344448
02:43:50 <chrisdone> i'm afraid i don't have the esoteric experience required to understand latex's error messages. any ideas?
02:45:03 <hpaste> chrisdone annotated ‚Äúlatex output‚Äù with ‚Äúcomplete .log file‚Äù at http://lpaste.net/76662967210344448#a3129822529217101824
02:47:13 <chrisdone> if i hit return on those errors to 'ignore' them, it still outputs a PDF. but i don't want to do that every time i build it
02:48:27 <adimit_away> chrisdone: it probably has something to do with hyperref.
02:48:55 <adimit> you can try to see if it goes away if you just pass the [draft] option to hyperref.
02:49:55 <chrisdone> adimit: so change \usepackage[pdftex,bookmarks=true]{hyperref} to \usepackage[draft]{hyperref} ?
02:50:10 <adimit> chrisdone: you can (I think) leave the other arguments in there.
02:50:34 <chrisdone> hm, same error
02:50:37 <adimit> my hunch is that somewhere somehow it split a reference/citation between pages.
02:50:39 <adimit> damn
02:50:49 <adimit> :-\ LaTeX is weird.
02:51:05 <CADD> lol, tell me about it..
02:51:45 <chrisdone> yeah. had to write a service that would build people's latex stuff once. was so happy when that was finished. just things like re-running the same command n times until it really finishes killed me inside
02:52:21 <adimit> seems to have something to do with hyperref and the index, but I have little experience in building indices with hyperref.
02:53:10 <adimit> well, it's still the most beautiful typesetting we have by far. as much as it's still stuck in the 1970s
03:00:04 <chrisdone> nevermind, give up
03:31:06 <allsystemsarego> Hi all, why does import qualified System.IO.UTF8 as T followed by main = T.putStr '∑'
03:31:06 <allsystemsarego> output ¬∑ instead of just ∑ ?
03:31:44 <Peaker> allsystemsarego, terminal/editor encoding issues?
03:32:44 <HappyMelancholy> Hello everyone. I'm not sure if this is ther right chan to ask these questions. I am a person in program management whose been allocated a software engineer and asked to re-engineer and optimize an existing homegrown CRM(CRM-ish) tool. I want to be able to map the flow of information from one process (or task/tab) to another. Does anyone have any recommendations?
03:33:08 <Peaker> HappyMelancholy, how did you get to #haskell?
03:33:19 <allsystemsarego> Peaker, no, I'm just trying to output a utf8 character, but the available info is 3 years old, especially stackoverflow
03:33:52 <HappyMelancholy> I have started to learn Haskell. I wanted to learn one nice functional language since the majority of my programming experiences have been in C and Java
03:34:11 <Peaker> allsystemsarego, putStr wants a String, not a character, what exactly is your code?
03:34:43 <HappyMelancholy> That's how I am here, Peaker.
03:34:47 <allsystemsarego> oh wait, that's right, I was citing from memory
03:35:05 <allsystemsarego> let me come back with actual code
03:36:39 <allsystemsarego> import qualified System.IO.UTF8 as T
03:36:39 <allsystemsarego> main = T.putStrLn "∑"
03:36:51 <allsystemsarego> Peaker, ^^
03:37:54 <Peaker> allsystemsarego, when you run the program in a terminal, maybe it outputs the UTF8 encoding of "∑" but then the terminal decodes it incorrectly?
03:38:24 <Peaker> allsystemsarego, try comparing the hexdump "∑" in your .hs file with the hexdump of the output (e.g: pipe your program into hexdump)
03:38:52 <allsystemsarego> ok, let me do that and I'll come back
03:44:09 <hpaste> allsystemsarego pasted ‚ÄúUTF8‚Äù at http://lpaste.net/91513
03:44:33 <allsystemsarego> Peaker, it seems to be the case
03:47:45 <Peaker> allsystemsarego, there's a prefix ¬ in there, yeah
03:48:09 <allsystemsarego> inside of the hs file
03:48:12 <allsystemsarego> ?
03:48:46 <allsystemsarego> so I need to start looking at my environment variables, right?
03:49:58 <adimit> allsystemsarego: or your editor setup.
03:50:36 <allsystemsarego> I'm using vim
03:50:58 <allsystemsarego> my .vimrc looks pretty boring
03:52:32 <allsystemsarego> but my real question was: is this the idiomatic way to output utf8 strings in Haskell?
03:54:46 <Peaker> allsystemsarego, System.IO.UTF8 seems broken to me
03:54:59 <Peaker> allsystemsarego, I've never used it. I always just used String/Text without worrying about encoding
03:56:34 <pxqr> what is the purpose of System.IO.UTF8 ?
03:56:41 <startling_> allsystemsarego, encode Text into a ByteString and D.BS.putStr that bytestring
03:56:59 <startling_> pxqr: presumably to output UTF-8 on systems where the locale is not UTF-8.
03:58:34 <luite> allsystemsarego: Strings/Text have no encoding themselves, you can set the encoding for a handle with hSetEncoding
03:58:46 <Peaker> pxqr, reading its code, its purpose is to insert bugs into text encodings :P
03:59:52 <mauke> Peaker: broken how?
04:00:48 <Peaker> mauke, it has silly functions of type String->String which basically do: String->utf8->ByteString,  ByteString->Char8->String
04:01:14 <mauke> that's how you had to do it
04:01:29 <mauke> back when the IO system only did latin1
04:01:34 <Peaker> well, now it's broken -- as the Char8 repr of the String being printed is re-encoded as utf8
04:01:59 <Peaker> allsystemsarego has a simple program:  http://lpaste.net/91513
04:02:01 <mauke> it's only broken if your filehandle also encodes
04:02:34 <Peaker> well, if you're writing a list of code-points to a file handle, some conversion to a byte stream must take place.  Assuming that conversion is a Char8 one is bad
04:03:37 <Peaker> are there still any Handles that still do   String--Char8-->ByteString   as their conversion?
04:03:57 <Peaker> probably not, so pretty much any use of the functions in System.IO.UTF8 will be broken
04:04:50 <Peaker> allsystemsarego, so, the conclusion seems to be that System.IO.UTF8 was a workaround for really old limitations of GHC, and now that GHC does the right thing, the workaround is just corrupting your text
04:06:12 <Peaker> allsystemsarego, main = putStrLn "∑"    works fine :)
04:07:42 <adimit> Char8 is evil anyway..
04:10:04 <adimit> and I always liked how GHC (now) handles Unicode. Just avoid Char8, and you'll be fine with Text and String, allsystemsarego.
04:11:43 <allsystemsarego> ok, I'm back at the keyboard, thanks everyone
04:12:14 <Peaker> adimit, the thing is, you must avoid System.IO.UTF8 which has an innocuous name but hides Char8 within it
04:14:11 <adimit> Peaker: it's unfortunately not just System.IO.UTF8. Unfortunately, it's also otherwise nice libraries such as iteratee.
04:14:57 <adimit> there were others, but I can't remember. I particularly like parsing libs that make use of char8. Yay. Like that's a good idea. I guess it's fine if what you parse is fortran.
04:15:00 <Peaker> I'd say iteratee is deprecated by now by the pipes/conduit stuff?
04:15:18 <adimit> I liked iteratees!
04:15:41 <adimit> haven't gotten used to pipes & conduits yet, but I'll have to switch eventually, I guess.
04:16:04 <arkeet> pipes is pretty cool
04:17:51 <CADD> what is your guys opinion on machines?
04:21:46 <Peaker> arkeet, I wonder if pipes could use some syntactic trickery to reduce the number of type variables, something like:   Pipe (i1 :> o1) (o2 :< i2) ...    where (:>) and (:<) are type-level pairs, allowing the "upstream", "downstream" stuff to be grouped nicely
04:22:13 <arkeet> unfortunately, we don't have very good type-level pairs.
04:25:57 <Peaker> type family Input a ; type family Output a ;     data (a :> b) ; type instance Input (a :> b) = a ; type instance Output (a :> b) = b
04:26:22 <Peaker> data (b :< a) ; type instance Input (b :< a) = a ; type instance Output (b :< a) = b
04:26:40 <Peaker> type-level pair, yay
04:26:54 <arkeet> but it's not very good.
04:26:55 <CADD> so no opinion on machines vs pipes vs conduit?
04:27:21 <Peaker> haven't heard of machines yet, but edwardk is behind it, so probably worth studying :)
04:27:43 <CADD> yeah edwardk writes some amazing stuff.
04:30:32 <Peaker> http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Plan.html#t:Plan  <-- documentation mentions "i" which doesn't exist?
04:31:14 <tulcod> what do i need to do to define my own deriving(..) class?
04:31:25 <CADD> Peaker: do you mean in awaits?
04:31:37 <Peaker> "that reads inputs selected by k with types based on *i*"
04:31:45 <CADD> oh right
04:31:48 <donri> tulcod: can't be done with current ghc, but you can generate instances with templates or you can use generics
04:31:51 <CADD> huh
04:32:13 <Peaker> it says "intermediate results of type a" but "a" seems like the final result, and "o" is the intermediate
04:32:16 <CADD> i guess "i" is just used futher down in the page?
04:32:25 <tulcod> donri: well i'm seeing the data-flags package which seems to be doing this, and i don't think it's using exotic ghc features
04:32:29 <CADD> but right, its not used right there
04:32:56 <Peaker> CADD, I see older versions had "i" there
04:33:03 <donri> tulcod: it seems to be using GeneralizedNewtypeDeriving
04:33:16 <tulcod> donri: ah, that's the "magic bit"? :)
04:33:18 <donri> tulcod: that only works for newtypes and simply copies the instance from the "oldtype"
04:33:36 <tulcod> awesome, that makes total sense for this application
04:33:43 <CADD> Peaker: ah that makes sense
04:33:53 <tulcod> donri: thank you, i knew i was missing something :)
04:34:13 <donri> tulcod: it also seems to provide templates for normal data types in the .TH module
04:34:56 <Peaker> oh, "intermediate result" is used in a weird way here
04:35:28 <tulcod> donri: i think it's limited to simple wrappers
04:36:14 <tulcod> donri: though i'm failing to see any reference to GeneralizedNewtypeDeriving
04:37:01 <donri> tulcod: it would be used in user code, not needed in the library itself
04:37:05 <tulcod> "grep Generalized . -R" on the entire package returns nothing
04:37:14 <donri> tulcod: though the docs should mention it
04:37:26 <tulcod> ahhh, yeah that makes sense
04:37:29 <donri> that example code wouldn't work without it AFAIK
04:37:42 <tulcod> yeah that could be right, i have an example implementation which uses that
04:38:14 <tulcod> donri: thanks a million
04:38:47 <donri> tulcod: this package seems to be meant for writing ffi bindings? i think c2hs does the same thing and is maintained
04:40:11 <S_J> So I found both happstack and the other webframework to be a little too complicated. is there want of a very simple, decoupled webframework like Pythons haskell?
04:40:22 <donri> tulcod: or maybe not. not sure exactly
04:40:27 <S_J> Pythons Flask in Haskell. is what i meant
04:40:38 <tulcod> donri: it is intended for ffi, but i haven't found such a feature in c2hs
04:40:50 <donri> S_J: scotty maybe
04:41:32 <S_J> scotty?
04:41:40 <donri> S_J: i'd say snap is the most similar to flask thugh
04:41:41 <donri> though
04:43:01 <donri> @hackage scotty
04:43:01 <lambdabot> http://hackage.haskell.org/package/scotty
04:44:03 <Peaker> bah, haddock is choking if I try to give -- ^ parameter docs on the params of a field of a newtype
04:44:08 <donri> scotty is more like python's bottle, which flask isn't really that much alike anymore
04:45:40 <donri> Peaker: make sure there's a ticket for that, someone's doing a gsoc on haddock IIRC
04:46:04 <donri> and i think it included things like GADT support so your thing seems relevant
04:47:56 <S_J> i want to deploy on heroku
04:48:25 <S_J> snap is for unix
04:48:42 <CADD> S_J: there is always happstack-lite
04:48:43 <donri> heroku isn't?
04:48:46 <CADD> http://happstack.com/page/view-page-slug/9/happstack-lite-tutorial
04:48:59 <Peaker> donri, too deep in the mental stack ATM
04:49:22 <donri> you could probably deploy most haskell apps static on heroku
04:50:39 <Ghoul_> in my opinion pipes is better than conduits right now, even if pipes-binary and friends is seemingly impossible to integrate
04:52:06 <S_J> donri: well actually im gonan dev on my virutla machine/linux and not on windows so that is ok!
04:52:26 <Ghoul_> pipes transformers are a magnitude friendlier than trying to get anything to typecheck with conduit
04:52:37 <S_J> donri: static meaning just upload the exe?
04:52:46 <donri> S_J: yes
04:57:36 <S_J> donri: then what about databases?
04:59:49 <CADD> S_J: acid-state? HDBC?
04:59:59 <donri> S_J: does their postgre service require anything special? if you get a normal fs you could use acid-state
05:01:06 <Peaker> Ghoul_, doesn't conduit have a larger eco-system though?
05:01:26 <Ghoul_> Like?
05:02:01 <aristid> well stuff like http-conduit and aws i'd guess ;)
05:02:15 <Peaker> Ghoul_, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:conduit
05:02:18 <aristid> i would tend to agree that pipes 4.0 looks promising though
05:03:09 <aristid> Peaker: that list doesn't include the packages that just use conduit for other goals
05:03:40 <aristid> snoyman had a site where you can revdep lookup packages
05:03:42 <aristid> i forgot the name
05:04:17 <donri> http://packdeps.haskellers.com/reverse/conduit
05:04:24 <donri> http://packdeps.haskellers.com/reverse/pipes
05:04:28 <aristid> donri: thanks!
05:05:10 <aristid> ugh quite the bitrot
05:05:14 <donri> of course wai uses conduit so that includes anything that uses wai or warp
05:05:38 <aristid> all that red
05:07:16 <Ghoul_> pipes is faster than conduit too, by quite a large margin
05:07:22 <Ghoul_> but the difference is often negliable.
05:07:57 <donri> has pipes achieved feature parity with conduit yet?
05:08:00 <Ghoul_> because you end up talking about like 60ns
05:08:41 <donri> IIRC leftovers was the last missing feature and pipes-parse provides that?
05:08:56 <Ghoul_> I don't know a great deal about what conduit features you're talking about so I can't really answer that.
05:11:04 <aristid> Ghoul_: ah so as long as the conduit/pipe deals in large blocks the difference should be small i guess?
05:11:13 <aristid> in performance
05:11:40 <Ghoul_> its negliable anyway, since often the code that drives the pipeline uses much more than the machinery that powers it
05:11:41 <aristid> donri: well pipes-parse in the new revision isn't an actual pipe anymore :)
05:12:08 <aristid> donri: instead it's a StateT (Producer ...)
05:12:53 <Ghoul_> for my server though I actually ended up ditching everything because the types become too ridiculous with both conduit and pipes in my "real world" applications mhm
05:13:15 <aristid> Ghoul_: maybe it'd make sense to reevaluate with pipes 4.0
05:13:47 <Ghoul_> Im sure it would!
05:14:13 <aristid> Ghoul_: for my own little pipe-like thing i think i'll just end up handcrafting an ADT instead though
05:14:28 <Ghoul_> I dont think you can pull in 4.0 from hackage yet though
05:14:42 <aristid> well it's on github
05:15:08 <katla> http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
05:15:22 <katla> could you help me with this part
05:15:25 <katla> "
05:15:25 <katla> It'd be cool if this was a product in the usual categorical sense, but it isn't. There isn't a natural way to map to both f a and g a from f (g a) with the universal property of products. Instead it's a weaker type of product which is still a bifunctor."
05:16:40 <katla> i dont really get it
05:38:50 <S_J> Agda is not turing complete right? What is missing from turing compelteness?
05:38:53 * hackagebot squeeze 1.0.4.1 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.4.1 (AlistairWard)
05:40:05 <aristid> S_J: it's not so much missing as deliberately removed.
05:40:06 <S_J> Im into embedded programming. Not complex linux based embedded systems but rather very small, hard realtime, safety-critical, bare metal(no OS) applications. So thats why proving correctness rather than testing interests me.
05:40:23 <k00mi> S_J: you have to prove termination
05:40:31 <S_J> aristid: I understand that, Im trying to udnerstand what it means fro it not to be turing complete. waht can i not do?
05:40:49 <aristid> S_J: turing completeness relies on general recursion, which cannot be proven to halt (see: halting problem)
05:41:31 <S_J> k00mi: wyat do you mean i have to rpove termination?
05:41:34 <aristid> S_J: therefore you can only run programs in agda which you can prove to halt (unless you use some "tricks" to run programs that do not necessarily halt)
05:41:52 <allsystemsarego> the only thing still missing from Haskell that would make it Turing complete is infinite memory
05:41:54 <S_J> ok i see.
05:42:05 <aristid> allsystemsarego: hah
05:42:21 <S_J> allsystemsarego: so youre syaing no turing complete langs exist?
05:42:28 <allsystemsarego> exactly
05:42:33 <k00mi> garbage collection emulates infinite memory :P
05:42:39 <aristid> S_J: if you care about correctness that's probably not such a bad thing though, as infinite reaction times to a button press would be undesired ;)
05:42:59 <S_J> but proving to halt, i dont want to halt(program will run as long as machine is on). what does halt mean here exactly?
05:43:01 <aristid> S_J: note that the typical case of an infinite server loop is perfectly legal
05:43:43 <aristid> S_J: in your case that it will always react to any event, basically
05:45:43 <gertc> is Edward here?
05:45:55 <tom39291> Does anybody have a URL for a presentation relating to running Haskell in production? (It included descriptions of various libraries including hslogger, and a metrics library)
05:47:04 <adnap> katla: Read this: http://en.wikipedia.org/wiki/Categorical_product. f (g a) isn't a categorical product because there aren't morphisms pi_1 : f (g a) -> f a and pi_2 : f (g a) -> g a
05:47:25 <katla> so what is it instead?
05:47:30 <Zenol> @pl \x -> "\n" == x || "\r\n" == x
05:47:30 <lambdabot> liftM2 (||) ("\n" ==) ("\r\n" ==)
05:47:32 <adnap> A bifunctor
05:47:33 <tom39291> Ah, I was probably thinking of http://stackoverflow.com/questions/5808825/what-are-the-best-haskell-libraries-to-operationalize-a-program
05:48:14 <katla> alright, thanks
05:49:38 <gertc> (from dataMap.at k) ?= v why not let dataMap do the from thing so you get (dataMap.at k) ?= v
05:51:22 <gertc> $(makeIso ''dataMap)
05:51:47 <gertc> mean $(makeIso ''DataMap)
05:56:18 <hpaste> oscarvarto pasted ‚ÄúAlternative encodings? Polymorphism‚Äù at http://lpaste.net/91514
05:58:21 <Peaker> oscarvarto, you could use Foldable?
06:01:27 <oscarvarto> Hi! I'm pretty new with Haskell and would like to have your opinion. I figured out http://lpaste.net/91514 with some help from piron, and others here how to encode "Distance Measures". Lines 1-10 "work", but suppose you had to encode several measures: Minkowski (Euclidean distance is a special case of it), Mahalanobis, etc. In an Object Oriented Language (say Java), you would use an "interface" and then make several classes to implement that interface
06:01:27 <oscarvarto> (the "distance" method). I thought of a "Distance type class" with a "distance" method, and hence http://lpaste.net/91514 Would you mind giving me your thoughts?
06:05:34 <tulcod> oscarvarto: depends on the application - you could also consider them different functions
06:07:08 <tulcod> oscarvarto: also... i don't really get how "distance" is a monad, maybe you could hepl me?
06:07:47 <tulcod> ugh, scratch that
06:08:42 <oscarvarto> Peaker: Foldable? Maybe you are talking the implementation of Euclidean Distance? More important than implementation details of a specific Distance Measure, I would like to know your opinions about "encoding *several* measures in a *uniform* way"
06:09:17 <tulcod> oscarvarto: was that to me?
06:09:39 <Peaker> oscarvarto, Foldable lets you replace "class Distance"
06:10:01 <Peaker> @type F.toList
06:10:02 <lambdabot> Foldable t => t a -> [a]
06:10:02 <startling_> oscarvarto: I think you're overthinking this.
06:10:42 <tulcod> Peaker: i don't think that's what oscarvarto has in mind... a more appropriate name for the class would be Measurable
06:10:52 <startling_> oscarvarto: a better way would be Fractional a => (a -> a -> a) -> somethingElse, I think.
06:10:52 <Peaker> oscarvarto, you can then have various distance measures like:  someDistanceMeasure :: Fractional a => [a] -> a
06:10:55 <oscarvarto> tulcod: Sorry if I am saying something wrong (and please correct me then): I think not every type class has to be a monad, does it?
06:11:04 <hpaste> Placinta pasted ‚ÄúAmbiguous variable‚Äù at http://lpaste.net/91515
06:11:10 <startling_> oscarvarto: correct. tulcod is confused.
06:11:34 <tulcod> oscarvarto: yea no that was just my brainfart. what is the application of this?
06:11:57 <startling_> oscarvarto: if this parameterization-by-distance-function thing ends up being annoying, use a Fractional a => Reader (a -> a -> a)
06:12:02 <Peaker> oscarvarto, if your encoding was always a list of points, that would simplify matters
06:12:07 <Placinta> Hi. I defined a function that uses the persistent library to insert a value into a database. If the function isn't used anywhere, I get an ambigious error. As soon as I call it in main, the code compiles. Is there some way to make the error go away, without using it in main? http://lpaste.net/91515
06:12:54 <oscarvarto> tulcod: I read a very well written book some time ago: "Data Clustering in C++" and as a mean to learn haskell, I want to program some of those algorithms.
06:13:13 <hpc> Placinta: try giving it a type signature
06:13:20 <tulcod> oscarvarto: well sure, but why do you want to store different measures of distance?
06:13:32 <Placinta> hpc: How would I figure the type signature out?
06:13:52 <tulcod> oscarvarto: do you want to make a big list of "distance" functions and compare them? or do you just want to compute the result of 2 distance functions which you know upfront?
06:14:05 <Placinta> hpc: It looks to be some long monad transformer chain
06:14:05 <startling_> Placinta: try :set -XNoMonomorphismRestriction
06:14:06 <hpc> Placinta: use it in main, then open ghci and do :t whatever
06:14:33 <Placinta> startling_: I believe I've read somewhere that disabling that restriction is a bad thing?
06:14:44 <tulcod> oscarvarto: a big difference between haskell and most other programming languages is that you usually encode a lot more meaning in the types of things. that is why i am asking why you are storing different measures of "distance"
06:15:02 <simon> I've read http://stackoverflow.com/questions/3324801/how-do-we-keep-multiple-semantic-values-during-parsing-with-happy-haskell -- does anyone have any strong opinions about either of these approaches?
06:15:03 <startling_> Placinta: it's useful in GHCI for precisely this reason.
06:15:10 <Placinta> hpc: I've tried that, but because the persistent library uses TemplateHaskell, I can't seem to do all the relevant initialization
06:15:19 <hpc> hmm
06:15:56 <hpc> i assume insertValue is intended to be used something like (insertValue resource value)?
06:16:12 <hpc> you can eta-expand it, which makes ghc think it "looks like a function"
06:16:23 <Placinta> hpc: eta expand?
06:16:38 <hpc> eta-expand means (f = g . h) => (f x = (g . h) x)
06:16:43 <startling_> Placinta: the main thing about NoMonomorphismRestriction is that it sometimes inhibits sharing in evaluation/compiled code
06:16:48 <hpc> add back the parameters that you have made pointfree
06:16:53 <oscarvarto> startling_, Peaker, tulcod: Thank you very much for helping me. Sorry if I cannot answer everybody that quick.
06:17:15 <Placinta> hpc: The function is point free. It's just like it is shown.
06:17:36 <Placinta> startling_: sharing, as in the code generated by TH?
06:18:13 <hpc> Placinta: i mean, make it not pointfree
06:18:38 <startling_> Placinta: sharing as in "in 'let a = b + c in (a, a)', a is only computed once"
06:19:20 <Placinta> hpc: The function doesn't take any parameters anyway, it's hardcoded now. I don't see how you can not-point free it as it is.
06:19:21 <hpc> heh, ask a simple question, get a crash course in every haskell concept ever
06:19:29 <hpc> oh
06:19:32 <hpc> well, hmm
06:19:49 <Placinta> One moment, I'll try to load it in ghci one more time, maybe it will work
06:20:00 <hpc> in any event, you need to give that a type signature somehow; you should know the types of the things you are using
06:20:28 <Placinta> hpc: When you use a library, it usually has multiple internal types that aren't very straightforward
06:20:33 <Placinta> At least in my case
06:20:44 <oscarvarto> tulcod: I wasn't thinking of a specific use case. Just trying to find out some ways to do a more "generic" kind of programming. But it would be interesting to study how a simple change of "distance" notion makes clustering different. Just to start, the algorithms I'd like to program use "vectors" in R^n.
06:21:55 <oscarvarto> tulcod: Like using the same algorithm (say K Means), trying different "Distance Measures"
06:22:17 <tulcod> oscarvarto: i think you are thinking the wrong way about haskell. properly written haskell is already very generic, without having to make that explicit
06:22:47 <startling_> oscarvarto: the way to do things generically in haskell is to parametrize your functions by something.
06:22:55 <startling_> Reader is a convenient abstraction of this.
06:23:13 <tulcod> oscarvarto: so i don't think it would be very productive to introduce a Distance class... just make the distance function an argument of whatever functions have to compute distance
06:23:31 <oscarvarto> Maybe startling_ suggestion is more than enough, the algorithm could receive a "distance measure" (a Function) as an argument. The Reader Monad?
06:24:07 <hpaste> Placinta pasted ‚ÄúAmbiguous variable 2‚Äù at http://lpaste.net/91516
06:24:27 <Placinta> So the type is as above. Is it really the only way to add that huge type to the function?
06:25:01 <startling_> Placinta: is there a "MonadLogging" or something?
06:25:13 <klrr> writer monad?
06:25:16 <oscarvarto> startling_, tulcod: Awesome! Thanks again.
06:25:42 <Placinta> startling_:  MonadLogging is not present in any of my code.
06:25:43 <oscarvarto> I've got to go. It's been a pleasure gentlemen. Bye ;)
06:25:56 <Placinta> explicitly anyway
06:26:15 <Placinta> Can't i Just write something like insertValue :: SqlPersistT _
06:26:32 <Placinta> And let the compiler figure out the rest
06:27:48 <startling_> Placinta, usually it's better (and gives you cleaner code) to write that as "(MonadLogger m, MonadResource m) => SqlPersistT m (Key ... m)"
06:28:28 <startling_> the other nice thing about that is that you can run it as any MonadLogger instance that you want.
06:28:52 <Placinta> startling_: Does that mean I will have to write out the whole ... part in the key?
06:29:24 <startling_> Placinta: yes. I don't know enough about the libraries you're using to write that part.
06:30:03 <Placinta> startling_: I see. Thanks. I wonder when will haskell support incomplete type signatures...
06:30:52 <startling_> Placinta, I don't think an incomplete type signature would help you here. It'd still be ambiguous, I think.
06:31:16 <McManiaC> how do I read from the stderr handle?
06:31:39 <Placinta> startling_: okay. Well thanks nontheless.
06:31:50 <McManiaC> ie. i want to catch the stderr output from one of my function calls
06:32:47 <startling_> is stderr usually even readable?
06:32:59 <startling_> McManiaC: in any case I think you're thinking about this the wrong way
06:33:06 <McManiaC> it's usually not
06:40:00 <Zenol> Are they a short code exemple of how to create an XML tree with XHT?
06:43:55 <Placinta> Is it possible to build lambdabot on windows, if it depends on the unix package?
06:48:50 <CADD> Placinta: use cygwin
06:49:30 <Placinta> CADD: But will haskell be happy with cygwin compiled files given (I assume) ghc uses MinGW?
06:49:54 <CADD> i dont run windows, so im only going off of what i remember when i did
06:50:29 <CADD> tbh, there is really only one way to find out.. if you run into any difficulties #haskell isnt going anywhere
06:50:33 <CADD> Placinta: ^
06:50:55 <Placinta> Will try
06:53:17 <nexx> you can also install minGW on cygwin
06:57:44 <Placinta> nexx: That sounds even crazier
06:58:35 <nexx> I used it to compile FANN and use it with HFANN
07:00:02 <Placinta> nexx: I'm afraid that binary compatibility problems might appear. ghc is bundled with gcc 4.6.2, whereas the current version with cygwin is 4.7.x
07:04:14 <nexx> I think cygwin allows to install older versions!? It's some time ago that I did it. I remember that I spent quite some time on getting it to work
07:22:07 <lemao> is there a way to statically guarantee that a data type can only be constructed and read, and never updated?
07:31:08 <Placinta> nexx: Did you have trouble with cabal not seeing include and lib files?
07:34:07 <nexx> Placinta I think I had to adjust pkgconfig entries. Also the .pc file was installed in usr/local/lib/pkgconfig in which pkgconfig doesn't look by default
07:38:48 <klrr> haskells' record syntax feels very incomplete
07:39:10 <Clint> that's why people like lens
07:39:53 <klrr> Clint: lenses is made for key value datastrcuts?
07:40:08 <klrr> Clint: i got some "monads are burritos" 'ish explaination last time i asked
07:40:14 <Placinta> nexx: Sadly that doesn't seem to be the issue yet
07:42:05 <satc> Hey. Suppose I have a global variable in C and getter and setter functions for that. Does the value persist when I make ffi call from the haskell side
07:42:07 <nexx> uhm iirc cabal uses pkgconfig to locate include and lib files
07:43:27 <CADD> nexx: <3 FANN <3
07:44:00 * hackagebot thyme 0.2.4.1 - A faster time library  http://hackage.haskell.org/package/thyme-0.2.4.1 (LiyangHu)
07:44:30 <Trieste> I'm probably missing something obvious, but why do I get a "could not find module" error while trying to import System.Random in ghci?
07:46:08 <CADD> Trieste: cabal install random
08:00:43 <sm> chrisdone: http://ircbrowse.net/browse/haskell?events_page=461455 seems to have stopped logging events on 7/26 ?
08:01:06 <Trieste> CADD: cabal is a Haskell package manager, correct?
08:01:42 <Saizan> Trieste: a way to install packages from hackage, at least
08:01:46 <CADD> Trieste: yup
08:02:00 <CADD> Saizan said it best
08:02:17 <CADD> Trieste: get familiar with ghc-pkg too
08:02:30 <CADD> which manages already installed pkgs
08:02:54 <sm> Trieste: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/ . But.. yes.
08:03:08 <klrr> template haskell==hack?
08:03:41 <CADD> klrr: no
08:03:49 <CADD> klrr: is very useful
08:06:21 <Trieste> Ah, alright, thank you :)
08:06:45 <Placinta> *sigh* unix just doesn't want to compile on cygwin...
08:08:44 <S_J> what property of enqueueing and dequeing can be tested with randim input? i would say enqueue ordered elements makes more sense here?
08:08:48 <S_J> rather than random
08:12:18 <CADD> sm: neat article. thanks for the link
08:12:51 <startling_> nexx, cabal finds libraries however it says to in the .cabal file.
08:13:44 <startling_> the whole "cabal is not a package manager" thing annoys me. cabal /should/ be a package manager, or, alternatively, there should be a package manager for haskell packages.
08:13:55 <startling_> whether it is or not has no bearing.
08:14:30 <Clint> there are package managers for haskell packages
08:14:30 <CADD> startling_: right, it would be nice if it was a PM, but its not.. :) soon enough maybe?
08:14:33 <Clint> they're called things like "dpkg"
08:15:46 <DavidT_> Is there a good reason there's no version of await of type Consumer i m i (in the conduit package)?
08:16:19 <geekosaur> startling_, the more it becomes a package manager, the more it conflicts with your system package manager
08:16:19 <startling_> Clint, too bad I don't use debian.
08:16:34 <Clint> it is
08:16:35 <DavidT_> I have defined awaitJust = await >>= maybe awaitJust return and am using it loads, slightly surprised its not in the library
08:16:52 <startling_> geekosaur, the reality is that system package managers are always unsatisfactory in this regard.
08:17:41 <Clint> and yet that's what i use exclusively
08:18:12 <geekosaur> startling_, yes, and?
08:19:01 <geekosaur> yes, there are problems. lots of people think they have The Solution... and they've left a lot of wreckage behind
08:19:05 <donri> DavidT_: is that awaitForever?
08:19:39 <DavidT_> donri: not quite, I sometimes want to do something else; awaitForever keeps running the same function forever
08:19:41 <startling_> CLint, do you ever want multiple versions of a library installed? Afaik dpkg can't do things like that.
08:20:29 <startling_> Clint, do you package all your haskell packages yourself?
08:20:40 <Clint> startling_: no, and yes
08:20:40 <CADD> geekosaur: any examples? im always down for a little bit of archeology!
08:20:46 <donri> system package managers are good for system package management, not development
08:20:53 <monochrom> "it is not" has no bearing? surely it has bearing on here and now. "it should" has bearing on the future only, and it will take much time even if you start working now
08:21:08 <geekosaur> damn near the entire ruby ecosystem?
08:21:14 <CADD> geekosaur: HA!
08:21:17 <startling_> geekosaur, so there's a pain point in working with haskell. saying "cabal is not a package manager" does not help that.
08:21:18 <CADD> yup
08:21:25 <donri> there are good reasons not to use multiple versions of the same library on a system
08:22:23 <startling_> Clint: sounds like a pain.
08:22:31 <CADD> that and system packages for haskell are always a few versions behind.. and i use arch and gentoo!
08:23:19 <CADD> plus, cabal-dev makes your life a bit easier.
08:23:23 <donri> i rather think many of the pain points with cabal come from it actually trying to be a package manager
08:23:25 <Clint> startling_: yes, but it's worth it
08:25:26 <geekosaur> startling_, had it occurred to you that the reason is because there isn't a solution? and "cabal is not a package manager" (or cpan etc.) is really just an aknowledgement that there are unsolvable issues?
08:25:57 <geekosaur> no, it doesn't "help".. because nothing does
08:26:07 <CADD> donri: i dont know if cabal ever claimed to be a package manager. its just abit easier to explain to to people that way..
08:26:28 <CADD> donri: iirc its goal was to be a build system, and just that.
08:26:45 <startling_> CADD: "cabal install", then.
08:27:20 <donri> CADD: it does things like "hey i built this library let's install it in the package database" like a good package manager which gets in the way of its actual task of managing *builds*
08:28:22 <Placinta> How can I run runhaskell Setup configure locally instead of globally?
08:28:32 <startling_> Placinta: what does that mean?
08:28:34 <CADD> startling_: either way. cabal install is only grabs packages and builds them. but you are right it would be best if the tools were a bit more integrated and automated.
08:28:39 <monochrom> add "--user"
08:28:51 <Placinta> monochrom: thanks
08:28:52 <CADD> donri: i guess?
08:29:09 <Placinta> startling_: packages installed by cabal can be installed globally and locally
08:29:42 <donri> CADD: this results in the diamond problem with shared indirect dependencies
08:29:50 <gertc> supose you have a data map userid [groupid] and a data map groupid [userid] is there a way to merge this so you can lookup a userid or a groupid? Now i have a duplicate data map but just different indexed
08:31:01 <donri> gertc: sounds like you might want one of tables, data-store, ixset
08:31:01 <CADD> donri: right, and the nice thing is that haskell being statically typed is well posed to mitigate and warn you of such problems. not saying its perfect. but can you do better? :)
08:31:47 <donri> CADD: types doesn't enter into it. it's a problem of version bounds on dependencies
08:32:30 <gertc> donri: ok going to look at it thx
08:32:31 <CADD> donri: sorry you are right. but that is a problem that that is seen across platforms
08:32:33 <sm> my 2c: "cabal is/is not X" statements require clarification of what you mean by "cabal". These days the most common understanding of "cabal" is the cabal command line tool provided by the cabal-install package. To most users it's obviously a package manager, though a strangely limited one with part of it's functionality partitioned into a separate tool (ghc-pkg)
08:32:36 <donri> CADD: it's not a case of cabal building something that runs and crashes; it knows there's a problem and will refuse to build, or tell you it has to rebuild existing packages
08:32:59 <donri> ever seen the error about --force-reinstalls?
08:33:04 <CADD> duh
08:33:18 <CADD> sorry, not trying to be rude. but ive seen it plenty of times
08:33:43 <donri> CADD: this particular problem is solvable by not trying to be a package manager, is my point. :)
08:34:07 <CADD> donri: i dont think cabal ever tried to be a package manager, is my point
08:34:20 <CADD> donri: or cabal-install if you want to be precise
08:34:26 <startling_> donri, so what would you do? rename cabal-install?
08:34:29 <monochrom> no, the pain with cabal is trying to hide a technical detail that cannot be hidden: with GHC and likely a few other compilers, a lib binary depends on the exact binary (not just version bounds) of other lib binaries, and furthermore there are some uniqueness requirements
08:34:42 <donri> well in this case i suppose you could say it's ghc-pkg trying to be a package manager, not Cabal, not cabal-install
08:34:57 <CADD> sure, i guess.
08:35:03 <CADD> either way
08:35:07 <CADD> tons of room for improvement
08:35:17 <startling_> monochrom: that's fair.
08:35:31 <monochrom> and it also doesn't help that cabal feels free to add "new versions" of libs by default to break the uniqueness requirements
08:36:06 <monochrom> notice how this is a non-issue with interpreters. I always say, cabal with hugs does not have a problem.
08:37:03 <monochrom> cabal tries to say, "install haskell libs like you install C libs". cross-package inlining implies that this is a lie.
08:37:41 <startling_> that's a good point.
08:38:05 <donri> there isn't one single problem with cabal. there are multiple problems that cause the pain, some solvable some not
08:38:50 <donri> and the cabal developers understand the problems very well
08:39:18 <Saizan> it'd be fine if you could keep all the versions (differentiated by the abi) around, making sure there's a subset that works together and can be presented to tools like ghci and such, like NixOS profiles
08:39:45 <Saizan> and i think that's where the developement wants to go
08:42:12 <donri> there was a gsoc for that last year. or two even
08:42:48 <startling_> there's been a million cabal gsocs.
08:44:28 <donri> currently cabal/ghc-pkg only allows one build of a particular version to be recorded, but two builds of the same version can vary widely in incompatible ways
08:44:49 <startling_> Makes sense.
08:45:07 <donri> thus you have to "force reinstalls", breaking unrelated packages
08:45:09 <startling_> yeah.
08:56:06 <dwcook> Is it possible to write a generalized not :: (Alternative f) => f a -> f () that takes empty onto pure () and anything else onto empty? Perhaps some other constraints are necessary.
08:56:41 <dwcook> It could be done with Eq but I would like to use this on parsers, among other things
08:57:41 <donri> i imagine you need AND for that but alternative only provides OR?
08:58:18 <dwcook> Hmm, is there a typeclass that gives AND?
08:59:34 <enthropy> <*> is kind of like AND
08:59:34 <donri> or is *> AND? hm
09:01:07 <jmcarthur> :t \a -> if isNothing (traverse (const Nothing) a) then pure () else empty
09:01:09 <lambdabot> (Traversable t, Alternative f) => t a -> f ()
09:01:17 <jmcarthur> maybe not *exactly* what you want
09:01:52 <jmcarthur> but it is true that    traverse (const Nothing) empty == Nothing
09:02:18 <Saizan> > traverse (const Nothing) []
09:02:19 <lambdabot>   Just []
09:02:21 <jmcarthur> i present that without proof :)
09:02:25 <jmcarthur> poo
09:02:43 * jmcarthur wonders what he was thinking
09:02:54 <jmcarthur> oh, i was thinking that the result is empty-like if it's Just something
09:02:58 <dwcook> Doesn't have quite the right type
09:03:00 <jmcarthur> totally got mixed up
09:03:09 <dwcook> I want a not parser combinator
09:03:10 <Saizan> yeah, you inverted it
09:03:18 <dwcook> I can write one just for parsers, but was curious if it generalized well
09:03:51 <jmcarthur> :t \a -> if isJust (traverse (const Nothing) a) then pure () else empty
09:03:52 <lambdabot> (Traversable t, Alternative f) => t a -> f ()
09:03:56 <donri> if it was possible it would probably be in http://hackage.haskell.org/packages/archive/parsers/0.8.3/doc/html/Text-Parser-Combinators.html
09:03:58 <jmcarthur> still not to the spec
09:04:21 <jmcarthur> dwcook: i don't think you can implement it with the type you asked for, though
09:04:27 <dwcook> Oh neat, didn't notice that module
09:04:57 <dwcook> Oh well. I suspected it's not possible, just figured I might not have been clever enough. :) Thanks!
09:06:19 <jmcarthur> ... why did i use isNothing and isJust in an if expression?
09:06:56 <dwcook> Oh hey, notFollowedBy
09:06:59 <jmcarthur> :t fromMaybe empty . traverse (const Nothing)
09:07:00 <lambdabot> (Traversable f, Alternative f) => f a1 -> f a
09:07:05 <dwcook> :t notFollowedBy
09:07:06 <lambdabot> Not in scope: `notFollowedBy'
09:07:16 <donri> dwcook: special to the Parsing class though
09:07:20 <dwcook> Yeah
09:07:28 <dwcook> notFollowedBy :: (Monad m, Show a) => m a -> m ()
09:07:32 <startling_> is there a way I can represent an expression in the (typed) lambda calculus such that it can only be in normal form?
09:07:43 <dwcook> Interesting how it needs the Show
09:07:57 <startling_> it's for error-reporting, I think.
09:07:57 <dwcook> Oh, it's for error reporting
09:08:01 <enthropy> > let f m = join (liftM return m `mplus` return mzero) in (f Nothing, f (Just 4))
09:08:03 <lambdabot>   (Nothing,Just 4)
09:08:08 <jmcarthur> startling_: you could use a final encoding, but i get the feeling that isn't what you are looking for
09:08:35 <donri> dwcook: looks like it's used for a default implementation. not sure why DefaultSignatures isn't used though. edwardk?
09:08:36 <startling_> jmcarthur, what's a final encoding?
09:09:31 <jmcarthur> startling_: roughly, instead of using an ADT/GADT, you just use whatever type you ultimately intent to evaluate the expression to. to write different interpreters for the same expression you use type classes
09:10:14 <startling_> oh. no, that's not what I want.
09:10:25 <jmcarthur> startling_: so in this case you would just use functions as your constructors which assume the inputs are in normal form already and ensure that the output is in normal form
09:11:38 <jmcarthur> startling_: maybe instead of having application nodes you would just have nodes for applications with variables on either side?
09:11:58 <jmcarthur> startling_: that way you are forced to go ahead and perform the application if you try to apply a real lamba to an argument
09:12:12 <enthropy> @ty \f -> liftM Just f `mplus` return Nothing >>= maybe (return ()) (const mzero)
09:12:13 <lambdabot> MonadPlus m => m a1 -> m ()
09:12:42 <kryft> Does someone have experience with hackage's probability package?
09:12:53 <enthropy> > let inv f = liftM Just f `mplus` return Nothing >>= maybe (return ()) (const mzero) in [ f Nothing, f (Just 5) :: Maybe () ]
09:12:54 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
09:12:54 <lambdabot>                     (Dat...
09:13:01 <enthropy> > let inv f = liftM Just f `mplus` return Nothing >>= maybe (return ()) (const mzero) in [ inv Nothing, inv (Just 5) :: Maybe () ]
09:13:02 <lambdabot>   [Just (),Nothing]
09:13:03 <startling_> jmcarthur: oh, that's interesting.
09:13:19 <enthropy> dwcook: ^^ if you have MonadPlus m =>
09:13:46 <jmcarthur> startling_: ah, i guess you would only have such a node for when the variable is on the left. when the variable is on the right you can still do the application, of course
09:14:33 <startling_> right, there's no guarantee you don't have "fn (const 1 2)"
09:20:42 <S_J> > (+1) const 1 2
09:20:45 <lambdabot>   Could not deduce (GHC.Num.Num (a -> GHC.Integer.Type.Integer -> a))
09:20:45 <lambdabot>    aris...
09:20:50 <S_J> @type const
09:20:51 <lambdabot> a -> b -> a
09:20:58 <S_J> > (+1) $ const 1 2
09:20:59 <lambdabot>   2
09:21:11 <S_J> > ((+1) . const) 1 2
09:21:12 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
09:21:12 <lambdabot>    arising f...
09:21:23 <S_J> > ((+1) . const) $ 1 2
09:21:24 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
09:21:25 <lambdabot>    arising f...
09:21:33 <donri> > ((+1) . const 1) 2
09:21:34 <lambdabot>   2
09:21:52 <S_J> why is it called const? whats constant about it?
09:22:04 <donri> > const 1 92387
09:22:05 <lambdabot>   1
09:22:31 <donri> const 1 is a function that returns 1, regardless of the argument
09:22:32 <S_J> > let firstArg = const in (+1) $ firstArg 5 7
09:22:33 <lambdabot>   6
09:27:20 <moofy> ahoy
09:27:48 <moofy> I was wondering, is there a way to get some syntax highlighting in ghci while I'm learning haskell?
09:28:04 <Placinta> How can I get an Int64 from a PersistInt64?
09:28:20 <hpc> moofy: you should do your work in a file, then do "ghci file.hs"
09:28:31 <hpc> moofy: when you make a change to the file, type ":r" in ghci and it will reload your work
09:28:46 <hpc> #1 - you get syntax highlighting in the file, if you use a good editor
09:28:56 <Placinta> PersistInt64 is defined as data PersistValue = PersistInt64 Int64
09:29:01 <startling_> moofy, it's a hard problem that you're going to need to tinker with in any case
09:29:05 <donri> moofy: kind of for output, not really for input
09:29:16 <moofy> well i can poke at it in sublime then
09:29:17 <hpc> #2 - you are learning "real haskell", instead of the very subtly-different haskell that ghci makes you write
09:29:34 <enthropy> Placinta: \(PersistInt64 x) -> x
09:29:37 <moofy> or bite the bullet and actually try to use emacs without wanting to scream
09:29:51 <enthropy> or that pattern match could be somewhere else you're allowed to have a pattern
09:30:15 <hpc> moofy: i would suggest considering vim
09:31:02 <hpc> it defaults to an excellent set of colors for haskell, but it might be tricky to learn
09:31:19 <Placinta> enthropy: Thanks. I tried let unpersist PersistInt64 x = x, but I forgot paranthesis around the constructor
09:31:21 <moofy> yeah I've tried both emacs and vim but they've never stuck
09:31:34 <donri> the default haskell.vim syntax is kinda crappy
09:32:00 <enthropy> Placinta: if there are other constructors of PersistValue, you probably want to handle those ones too
09:32:26 <hpc> donri: the only complaint i have is that vim's low-level highlighting code has problems with multiline strings
09:32:51 <hpc> (i know it's low-level because i have had this problem in every language it highlights - haskell, perl, js, php, ...
09:32:54 <Placinta> enthropy: I'm pretty sure I will only get the one constructor. But for the sake of the argument, should i throw an exception?
09:33:16 <donri> hpc: that's probably a sync issue, which you can control yourself
09:33:31 <donri> hpc: :syn sync fromstart, but it can slow down rendering for large files considerably
09:33:32 <enthropy> you do throw an exception with that definition
09:33:49 <hpc> neat
09:34:13 <moofy> I'm really new to haskell, just thought it sounded interesting after watching John Carmack's speech at quakecon
09:34:53 <dwcook> enthropy, brilliant, that seems to do the trick.
09:36:45 <enthropy> Placinta: sometimes people will add another case     persist _ = error "persist: was only meant to handle PersistInt64 constructor"
09:37:44 <enthropy> but when you do get the wrong constructor, a pattern match failure gives you the line of source code which might be more useful than having an explanation
09:39:03 <Placinta> enthropy: I see
09:41:02 <S_J> Can you define all operations on a tree in properties? so that if all the properties are fulfilled, the program works. or are there some operations that are not properties?
09:41:13 <ReinH> edwardk: hai!
09:42:22 * scshunt grumbles at the mess of typeclasses in the standard libs
09:42:24 <ReinH> hpc: it's not "low level". These things are defined in syntax files.
09:42:56 <ReinH> there may be some constructions that vim doesn't provide good tools for, but multiline strings shouldn't be one of them
09:46:23 <ReinH> hpc, moofy: In fact you can :e in GHCi and it will load your editor ($EDITOR, I presume?). If this is set to vim then bob's your uncle.
09:47:06 <startling_> does Text.Printf.printf have a format character that uses show?
09:48:12 <raghu> test
09:48:26 <BMeph> raghu: FAIL
09:48:28 <startling_> raghu, it worked!
09:49:48 <S_J> for a function strip :: Char -> String -> String that removes all occurences of Char from String, what properties should this function have?
09:50:20 <seliopou> S_J: doesn't make the string longer
09:50:29 <startling_> S_J: gives the empty string on the empty string
09:50:51 <startling_> does nothing to strings not containing that character
09:51:18 <seliopou> difference between input length and output length is the number of occurrences of that character
09:52:13 <seliopou> does anybody know if and how you can include a non-haskell executable in a cabal package?
09:52:14 <enthropy> startling_: Text.Printf.Mauke has "%_" which is kind of like having    printf "%s" (show x)
09:52:29 <enthropy> except there's no show if x is already a String
09:52:30 <moofy> interesting
09:52:53 <taylorgb> Doesn't strip usually refer to the removing of leading or trailing instances of a particular character?
09:59:32 <S_J> startling: not longer and empty string are fairly useless to test with quikchceck though? since empty string is just one case really, or 2 if you test with strip '' "" and strip somechar "" since all chars would be the same
10:00:39 <donri> > ''
10:00:44 <lambdabot>   <hint>:1:3:
10:00:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
10:01:23 <donri> S_J: strip is just filter so you could model test against that
10:01:48 <donri> strip c s == filter (==c) s
10:02:59 <S_J> yes but that is pointless ... why should i test against the implementation? i should test against the definition
10:03:01 <S_J> strip c s = filter (/= c) s
10:04:58 <donri> S_J: model testing is useful if you're writing an alternative implementation. in this case strip is specialized to strings so maybe you have a more efficient implementation.
10:05:05 <donri> well probably not for string but maybe for text, say
10:16:37 <danpalmer> Is it possible to force cabal to get the most recent copy of a package from git? cereal got an update for ghc 7.6.3 a few weeks ago, but appears to be failing with the same issue that got fixed now?
10:18:37 <hpc> that feel when you solve a performance issue by changing a data structure and blindly fixing type errors for a few minutes
10:22:06 <applicativ> danpalmer:  if you have the repo you can do 'cabal install' from inside the main directory
10:22:54 <applicativ> danpalmer: but maybe that's not the issue?
10:24:33 <monochrom> cabal doesn't know git
10:25:19 <danpalmer> well is there a way to get it to use the latest source from wherever that may be?
10:26:06 <monochrom> yes, manually arrange for the source tree to appear on your disk, then cd to it and "cabal install", which is what applicativ said
10:26:10 <applicativ> danpalmer: somehow I feel that would lead to chaos
10:26:35 <danpalmer> applicativ: oh sorry, didn't see your messages
10:27:04 <danpalmer> applicativ: unfortunately the source just isn't compatible with 7.6.3 so I guess there's no other way?
10:27:24 <applicativ> danpalmer: oh wait, are you wanting to test it?
10:27:34 <applicativ> whats the incompatibility
10:27:42 <monochrom> wait what? you said "got an update for ghc 7.6.3" earlier
10:28:05 <danpalmer> monochrom: https://github.com/GaloisInc/cereal/commit/acc09a5d6fb0ee65af2b060cc12b14282c20725d
10:28:05 <monochrom> what do "an update for ghc 7.6.3" and "isn't compatible with 7.6.3" together mean?
10:28:30 <danpalmer> as far as I can tell from looking at the failing install, that is the fix I need, but cabal isn't using source that includes that commit
10:29:26 <S_J> besides GUI:s what is a desktop app that needs threads?
10:29:41 <danpalmer> yeah, that was the issue, just used the source direct from git and it compiled fine.
10:29:56 <applicativ> hm, the new patch to cereal was from audreyt
10:30:05 <monochrom> well then, problem solved?
10:30:45 <danpalmer> monochrom: that one, yes, I've been trying to install yesod and that was one of two failing packages.
10:31:18 <danpalmer> I think the issues all stem from the preprocessor changing, control-monad was the other one that's failing
10:33:17 <danpalmer> oh no, loads more packages failing to install. all of these issues seem to be various forms of 'syntax error' on lines with # symbols in, often mentioning the preprocessor.
10:33:39 <applicativ> hm, can it be you are using clang as the preprocessor?
10:33:42 <applicativ> or something else odd
10:34:20 <danpalmer> applicativ: that's what I thought the issue might be, I've been trying to get it to use a different preprocessor, but I'm not sure if it is or not
10:37:11 <danpalmer> applicativ: how are you supposed to specify the c compiler to use?
10:37:19 <danpalmer> *preprocessor
10:39:04 * hackagebot numeric-prelude 0.4.0.2 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4.0.2 (HenningThielemann)
10:39:28 <applicativ> there doesn't seem to be a flag for that, just --with-gcc=/blah/gcc
10:39:34 <applicativ> what operating system are you using danpalmer
10:39:37 <Res> lambdabot
10:39:55 <Res> @help
10:39:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:40:13 <applicativ> @type foldr
10:40:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
10:40:18 <applicativ> > 1 + 3
10:40:19 <lambdabot>   4
10:40:22 <Res> @help list
10:40:22 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:40:25 <Placinta> Is it possible to somehow prettyprint a tree structure?
10:40:51 <applicativ> Placinta: in Data.Tree there is a prettifier, fwiw; you can modify it for your tree?
10:41:32 <applicativ> Placinta: or do you mean, you just want something semi-readable inside ghci?
10:41:52 <danpalmer> applicativ: I'm using Mac OS 10.9. I've been looking for a way to specify an alternate preprocessor, and I have gcc-4.2 installed that should work I think.
10:42:25 <S_J> so a database stores things as a file somehow obv, but writing to a file is expensive. so does databases when running keep allr ecords in memory or does it use soem sort of cache?
10:42:50 <Res> @djinn String -> Either ParseError [[String]] -> IO String -> IO [[String]]
10:42:51 <lambdabot> Error: Undefined type String
10:42:51 <Placinta> applicativ: Not ghci, output via print. I have a custom Tree structure. I'll look into Data.Tree
10:44:05 <monochrom> Placinta: try Text.Prettyprint.PJ, comes with GHC, but you have to write some code and make some decisions, not automatic
10:44:51 <Placinta> monochrom: Thanks
10:44:53 <Res> djinn
10:44:55 <applicativ> yes, that the Correct Path.  I was mentioning Data.Tree as giving an outline of one idea
10:45:07 <Res> @djinn
10:45:07 <lambdabot> Cannot parse command
10:45:33 <Res> help
10:45:38 <applicativ> I was going to add, in a sense, all uses of Text.PrettyPrint that aren't trivial come down to custom printing of a Tree type
10:45:44 <Res> ?
10:46:22 <monochrom> yeah, all its goals assume an AST or algebraic type
10:46:29 <S_J> would haskell be a good fir for coding a key-value store? or would it be to slow?
10:46:34 <Res> @djinn a -> b
10:46:34 <lambdabot> -- f cannot be realized.
10:46:35 <scshunt> what instance of Fuctor is used in 'fmap fix return'?
10:46:49 <applicativ> danpalmer: I see, my 'gcc' is i686-apple-darwin11-llvm-gcc-4.2 and 'cpp' points to it
10:46:54 <monochrom> @type fmap fix return
10:46:55 <lambdabot> a -> a
10:47:02 <Res> @djinn a -> b -> a
10:47:03 <lambdabot> f a _ = a
10:47:17 <monochrom> probably the ((->) e) functor
10:47:31 <ReinH> hai folks :)
10:47:37 <applicativ> hey its ReinH
10:47:41 <ReinH> applicativ: <3
10:47:55 <scshunt> monochrom: oh, and the same monad, ok
10:48:04 <zomg> S_J: you could probably use acid-state as a key value store pretty easily =)
10:48:45 <danpalmer> applicativ: I *think* I got cabal to use my install of "i686-apple-darwin11-gcc-4.2.1" (from homebrew).
10:49:31 <ReinH> Does cabal respect CC?
10:49:45 <danpalmer> applicativ: to do that I used `cabal install monad-control --with-gcc /usr/local/bin/gcc-4.2 --with-cpp /usr/local/bin/gcc-4.2 --verbose`, although not sure if both with-gcc and with-cpp are both needed there, I can only see it looking for gcc.
10:50:37 <danpalmer> ReinH: I tried that, didn't seem to work.
10:50:47 <ReinH> danpalmer: ok, I had no idea :)
10:51:17 <applicativ> oh you gcc is in /usr/local
10:51:22 <applicativ> danpalmer , I mean
10:52:14 <applicativ> mine is in '/usr' or '/usr/bin' rather
10:52:18 <danpalmer> applicativ: yes, but that's just a symlink to homebrew
10:52:41 <applicativ> danpalmer: yeah, but I was thinking /usr/bin is ahead of /usr/local/bin in path
10:52:54 <danpalmer> my /usr/bin/gcc is "Apple LLVM version 5.0 (clang-500.1.58) (based on LLVM 3.3svn)" - thought that might be causing issues.
10:53:20 <applicativ> so it picks up the clang preprocessor when it just asks for a c preprocessor
10:53:22 <startling_> Is there a way to have a Prism s t a b as a member of a sum type? GHC is asking for RankNTypes and ImpredicativeTypes and then still erroring.
10:53:46 <danpalmer> yeah, by default, its finding /usr/bin/gcc (which is clang) as the system gcc install.
10:54:04 <danpalmer> applicativ: I assume that's what it's using for the preprocessing?
10:54:38 <applicativ> danpalmer: yes but if its the first gcc in $PATH its using it for other purposes too i guess
10:55:10 <applicativ> but clang is hopeless as a preprocessor , someone was saying it would be repaired
10:56:28 <applicativ> you might try putting export PATH=/usr/local/bin:$PATH in your ~/.profile to see if that works then reasoning from there?
10:59:04 <danpalmer> applicativ: /usr/local/bin is already before /usr/bin in my path
10:59:33 <applicativ> bah
10:59:38 <applicativ> grr
10:59:47 <danpalmer> applicativ: my last 4 hours
10:59:49 <moofy> sometimes it has to be .bashprofile
11:00:00 <moofy> or .bashrc
11:02:22 <applicativ> danpalmer: well, it seems like we know what the main problem is, what i dont see is why i dont have it.  I dont have a gcc from xcode or homebrew, but from the semi-new 'command line tools'
11:02:33 <hpaste> monochrom pasted ‚Äúfmap fix return‚Äù at http://lpaste.net/91519
11:02:55 <monochrom> scshunt: http://lpaste.net/91519  it's an interesting exercise, thanks
11:05:29 <roconnor> @src sum
11:05:30 <lambdabot> sum = foldl (+) 0
11:05:51 <monochrom> > fmap fix return 'x'
11:05:52 <applicativ> it's that not dumb surely
11:05:52 <lambdabot>   'x'
11:05:58 <monochrom> \‚à©/
11:07:11 <applicativ> hah, roconnor in the source for Data.List that is used but with the crucial preamble #ifdef USE_REPORT_PRELUDE
11:07:51 <roconnor> applicativ: what does it say otherwise?
11:08:24 <applicativ> sum     l       = sum' l 0   where   sum' []     a = a ;  sum' (x:xs) a = sum' xs (a+x)
11:08:47 <applicativ> i might have expected a strictness annotation on !a
11:09:00 <roconnor> .... how is that different from foldl?
11:09:09 <applicativ> that's what I'm wondering
11:09:52 <roconnor> maybe there is some circular module avoiding?
11:10:04 <roconnor> since ghc doesn't follow the report and let modules have cycles
11:10:57 <applicativ> oh wait, it's not as insane as I was thinking
11:11:07 <applicativ> there are SPECIALIZE pragmas for Int and Integer
11:11:27 <applicativ> so then presumably the compiler can see the available strictness
11:14:03 <applicativ> roconnor: oh i think i misunderstood something; i think lambdabot's definition is a dead letter, though the actual, general definition amounts to the same, but with the SPECIALIZE pragma, this one does the right thing for Int and Integer
11:15:19 <tshirtman> Hi there, i've been trying to teach myself haskell for a few days playing with string manipulations, and here i am, with a function that returns a string from a string and a char (it's a simple xor) and a function that returns a score for a string, i'm wondering in what structure to store the string, the char that produced it, and the score, so i can return the string with the best score and the
11:15:25 <tshirtman> char that produced it.
11:16:04 <applicativ> well, the really simpleminded answer is (String,Char,Int) or whatever, no
11:16:05 <applicativ> ?
11:16:44 <monochrom> (String, Char) for the final answer. (String, Char, Int) for intermediate states. quickly move beyond string. haskell has real data structures and types
11:17:25 <applicativ> theres nothing wrong with learning haskell by doing string manipulations
11:17:49 <applicativ> though there's nothing wrong with pointing out that there are better things than String, I concede
11:18:12 <tshirtman> i was wondering about the best way to address the list more like a dict, as i come from python maybe i have a bias about how to do things
11:18:38 <tshirtman> so i can get like, the char for the best score, then the string from the char
11:18:56 <tshirtman> but right, i forgot about just creating a type like this
11:19:39 <applicativ> wait so this all starts with Char, there's a function Char -> String
11:20:19 <applicativ> you could make a Map Char (Int,String) some other like combination?
11:21:00 <tshirtman> oh, such a Map seems nice
11:21:07 <tshirtman> thanks
11:21:19 <tshirtman> i thought about searching dict and hash, and not map :D
11:23:07 <applicativ> oh, then Data.Map is good. It should be imported qualified I think.  there's an often-better Data.HashMap in the unordered-containers package that has basically the same api
11:24:19 <applicativ> @type M.lookup
11:24:20 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
11:25:15 <tshirtman> ah, the dreaded maybe, but now i know how to manage it
11:25:18 <tshirtman> :)
11:25:26 <tshirtman> this was killing me at first
11:25:44 <monochrom> it is less dreadful than pervasive "null"
11:25:52 <tshirtman> oh, didn't get this one yet
11:26:07 <applicativ> case M.lookup x mymap of Nothing -> boo; Just x -> moo x
11:26:15 <hpaste> ocharles pasted ‚ÄúArrowLoop infinite recursion‚Äù at http://lpaste.net/91520
11:26:18 <tshirtman> (except in the dreaded java and the unforgiving C ^^)
11:26:31 <ocharles> any ArrowLoop/fix/mfix wizards around to know why the above paste doesn't terminate?
11:26:42 <ocharles> (cc mm_freak :))
11:26:59 <ocharles> from what I can see, b2 should never demand anything from b1 - but the whole computation seems to loop forever
11:28:56 <ocharles> if I change the definition of b2 to 'b2 <- pure (V0 0 0) . delay (V2 0 0) -< b1' it still fails to terminate
11:29:02 <ocharles> so I can't really grok what's going on :(
11:29:10 * hackagebot shakespeare 1.0.5.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.5.1 (GregWeber)
11:32:05 <monochrom> perhaps look elsewhere
11:32:43 <ocharles> hum, it works if I flip the ordering and define b2 first. maybe I should write this without arrow notation
11:33:30 <Zenol> I have an infinite "loop". How can I find the "cycle" of functions calling themselves infinitely. I tried a bit with ghci's :trace and :break but it doesn't help me a lot :/
11:33:58 <monochrom> Debug.Trace may help
11:34:06 <roconnor> applicativ: that makes more sense
11:34:42 <Zenol> monochrom: ok :( good old debuging messages.
11:36:30 <monochrom> insufficient money paid for debuggers
11:38:59 <Zenol> ok, I found it... by re-reading the code. They isn't any way to display the name of each function "call" while running ?
11:39:10 * hackagebot numeric-prelude 0.4.0.3 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4.0.3 (HenningThielemann)
11:39:27 <Zenol> something that launched with f = g;g = f will display "g, f, g, f, g, f ....".
11:40:12 <enthropy> Debug.Trace will do that
11:40:43 <enthropy> if you change your definitions to    f = Debug.Trace.trace "f, " g; g = Debug.Trace.trace "g, " f
11:41:14 <Zenol> enthropy: And when the function is defined in 6 lines? :/
11:41:25 <Zenol> I mean, 6 pattern matching.
11:41:35 <int-e> Hmm, lazy evaluation makes it all a bit tricky: head $ drop 10 $ [2..]  would  have a trace like  head drop enumFrom drop enumFrom enumFrom  and result in 3, ignoring all the arithmetic
11:42:22 <enthropy> Zenol: then add another equation at the very top:      f _ _ _ _ | Debug.Trace.trace "f, " False = undefined;  f _ _ _ _ _ = actual equations here
11:43:01 <monochrom> oh! the dons device
11:43:15 * enthropy isn't 100% sure if that works all the time
11:43:18 <Zenol> oooo O.O
11:44:20 <Zenol> looks like it works :o
11:44:47 <int-e> False is acting like a blocker lemming there, sending the thread of execution back to drop to the next level :))
11:45:11 <enthropy> Zenol: with -O2 here, the False gets evaluated once only
11:45:51 <enthropy> so main = print (f 1); print (f 2) -- gives me   "f,\n1\n2"
11:45:57 <enthropy>   main = do print (f 1); print (f 2) -- gives me   "f,\n1\n2"
11:46:23 <int-e> enthropy: then the trick is to make the 'trace' depend on some argument(s).
11:46:53 <enthropy> int-e: yep that does it
11:47:08 <enthropy> f x | trace "f, " (False `const` x) = undefined
11:47:24 <S_J> zomg: but would haskell be inefficient for a key value store? ( not usign acidstate)
11:47:27 <int-e> {-# NOINLINE noseq #-} noseq a b = b  ;-)
11:47:52 <int-e> (infixr the thing, then: x `noseq` y `noseq` False)
11:48:23 <Zenol> enthropy> runhaskell use -O2 ?
11:48:39 <enthropy>  ghc -O2 theFile; ./theFile
11:49:39 <enthropy> runghc doesn't want to take -O2
11:49:54 <piron> runghc does what ghci does
11:50:20 <Zenol> so it's fine.
11:50:41 <Zenol> soo many functions...
11:51:40 <enthropy> maybe there is / should be a preprocessor to do that
11:52:12 <enthropy> profiling is kind of like adding those annotations
11:52:37 <piron> hat?
11:53:15 <piron> I guess hat and the ghci debugger both require manual interaction, though.
11:54:20 <Zenol> yeh, it's exactly what does profiling, but I'm not sure I can do profiling an a program that don't terminate..
11:58:24 <Zenol> the last message displayed doesn't means that the loop is inside the call. Only that it needed to evaluate one level of the function (they are all working on lazy lists), right?
12:00:02 <S_J> is there a graph database on hackage?
12:00:07 <S_J> cant find anyone
12:01:16 <quchen> S_J: Have a look at http://new-hackage.haskell.org/package/fgl
12:01:43 <quchen> There's also the fgl-visualize package to convert the graphs to .dot
12:02:17 <NemesisD> anyone know how i could use runhaskell and specify -packagedb? it doesn't seem to want to take that flag
12:03:26 <monochrom> that is a bit tricky
12:03:48 <donri> how about GHC_PACKAGE_PATH in the env
12:03:57 <NemesisD> looks like -package-db --ghc-arg=whatever
12:04:43 <tshirtman> hm, so now i have my key -> (String, Int) map, and i would like to get key and/or String of the max Int value, Map only seems to provide a way to look up the max key, not sure how to tackle this, i guess (String, Int) should be defined in a way allowing to sort it depending on the Int value‚Ä¶
12:04:58 <monochrom> yeah, that's an example in GHC user's guide
12:06:15 <donri> tshirtman: with Map you'd have to traverse AFAIK
12:06:31 <geekosaur> tshirtman: that sounds like a psqueue to me, not a map
12:06:40 <donri> tshirtman: you could use something like tables or data-store and index on the int though
12:06:59 <carter> cool news everyone: hennings numeric prelude is bsd :) http://hackage.haskell.org/package/numeric-prelude
12:07:10 <tshirtman> indeed, Map may not be the best tool
12:07:30 <tshirtman> will look at psqueue and tables
12:07:58 <Zenol> WTF?!
12:08:02 <applicativ> tshirtman: if you are only checking for maximum Integer, then swapping to (Int,String) will give (a) right result , no?
12:08:13 <Zenol> the error comme from a show instace ...
12:08:22 <monochrom> I am in fact not convinced that a dict is relevant
12:09:10 <fluffynukeit> Hi all.  I am trying to statically link my Haskell program that uses FFI bindings.  I have tried every combination I can of -static, -optl-static, -optl-pthread, etc.  Every time, the exe comes out the same and requires the right DLLs.  I have the .dll and .lib files available.  This is on Windows.
12:09:31 <applicativ> carter: what trouble does this avoid, the bsd license?
12:09:34 <tshirtman> applicativ: you mean sorting on it would do what i want this way? it's possible yes
12:09:52 <carter> applicativ: it means other libraries can use the code withouth being gpl
12:09:55 <applicativ> tshirtman: yeah, thats all I was thinking.
12:10:01 <carter> gpl is bad for haskell because we like to statically link
12:10:04 <carter> lgpl is bad too :)
12:10:06 <applicativ> i see that
12:10:22 <carter> also means its procedurally ok to look at for good ideas :)
12:10:36 <donri> does lgpl prevent static linking as well?
12:10:47 <tshirtman> donri: yes
12:10:47 <carter> yes
12:10:54 <donri> but not dynamic?
12:11:17 <applicativ> i would have expected numeric prelude to be bsd that's why I'm confused
12:11:22 <carter> noo
12:11:25 <carter> its not a standard prelude
12:11:27 <carter> its a library
12:11:29 <Adeon> IIRC you can ship object files and then statically link with lgpl
12:11:31 <carter> thats an ALTERNATIVE
12:11:35 <Adeon> you just have to be able to change the lgpl parts
12:11:36 <carter> no
12:11:37 <tshirtman> i'm part of a python project that switched from lgpl to mit recently due to this, even if we like the idea of lgpl, it's too frightening for potential users, as we target platforms like android and ios
12:11:39 <carter> oh
12:11:46 <carter> yeah
12:11:47 <applicativ> oh I'll be darned, it was gpl'd
12:11:52 <carter> yeah
12:12:04 <Zenol> oooo
12:12:06 <carter> theres still the issue that the haddocks are unreadable because of how henning writes code
12:12:13 <carter> but the soruce has neat ideas i'll borrow for my stuff
12:12:15 <applicativ> it's quite bizarre
12:12:16 <Zenol> (==) a b        = trace "==3" $ a == b
12:12:22 <carter> applicativ what is/
12:12:24 <carter> ?
12:12:28 <applicativ> oh, the style
12:12:42 <Zenol> it's true, if i'm writing the Eq instance, I can't use it's Eq...
12:12:43 <carter> yeah
12:12:53 <applicativ> on the other hand it's not clear Byzantine.T is such a bad idea
12:12:54 <Modius> Is there some cases where a "where" var in haskell is kept around between successive calls when it's independent of the rest of the scope?  http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html  (search for "hasElfMagic") and surrounding kind of implies it.
12:13:18 <carter> applicativ: it means you always have to write in hennings style, else its unreadable
12:13:24 <carter> but haddocks can't render the qualified names
12:13:28 <carter> so thedocs will be unreadable
12:13:29 <Modius> Can "where" vars become runtime constants, and do they in practive?
12:13:32 <Modius> practice?
12:14:41 <applicativ> Modius: i'm not sure I follow, but if I do, that's a typical of where
12:15:24 <ezrios> Modius: not sure about "where" vars, but the values of "let" vars are stored and not recomputed
12:15:25 <applicativ> goo x y n = loop n where loop n = ... closing over x and y
12:15:25 <Modius> applicativ:  Any good reading for me to see this explained in detail?  (If it's the case that something in a "where" can become a persisting thing)
12:15:44 <Modius> Or am I mistaken and the where portion is recreated for each call?
12:16:17 <Modius> Or is it syntactic sugar for something precalculated and point-free-style boiled into the function in some way?
12:16:21 <clj_newb_2345> so I'm studying more parsec, adn wondering if there's any cool examples (i.e. functional pearls) of people parsing non-string objects with parsec? i.e. using parsec to "pattern match" on structured data
12:17:10 <carter> Modius you're making it more complicated
12:17:19 <carter> where's are just lets
12:17:32 <Zenol> clj_neb_2345: I don't know if this answer your question but there is a tutorial using parsec to produce a lisp interpreter. Write you a schemin in 48 with haskell I think, or something like that.
12:18:06 <Modius> carter:  In the code I pointed to, is that ByteString for ".elf" recreated for every call to hasElfMagic then?
12:18:19 <carter> i've not looked at your code
12:18:24 <S_J> how do I create a file?
12:18:34 <applicativ> clj_newb_2345: well, if Parsec is to apply there needs to be an instance of Stream, and thus a definition of uncons :: str -> Maybe (c,str)
12:18:34 <carter> link?
12:18:50 <S_J> and how do I catch exceptions? why doies openFile generate an exception and not Maybe Handle?
12:18:52 <clj_newb_2345> steam is not necessairly str, it's just list A right?
12:18:57 <clj_newb_2345> s/steam/stream
12:19:11 * hackagebot parconc-examples 0.3 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.3 (SimonMarlow)
12:19:29 <applicativ> clj_newb_2345: it can be all kinds of things, but they will be 'stream' like or one-after-another like or something
12:20:01 <applicativ> a list of A is an instance of Stream [A] A, to put it crudely
12:20:46 <applicativ> but there is an instance Stream Text Char for example
12:20:54 <applicativ> I'm omitting the monad nonsense in the middle
12:20:58 <donri> so simon calls his book "parconc" for short eh
12:21:25 <applicativ> look it up in parconc!
12:21:56 <donri> see what "simon says"!
12:22:10 <applicativ> hah
12:22:31 <applicativ> simon says, add a strictness annotation!
12:23:36 <monochrom> clj_newb_2345: see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
12:23:51 <applicativ> the reading for today is parconc 1:3
12:28:18 <kryft> Real World Haskell mentions that the exception system changed just when the book went to print; what would be a good up-to-date introduction?
12:28:52 * Zenol just learned what is an orphan instance by writing it's first one
12:29:49 <monochrom> I find Control.Exception's doc perfectly adequate
12:30:21 <tomejaguar> I recall some lensy things that have type variables "p s t a b"
12:30:38 <tomejaguar> Can someone remind me what these are.  I want to find out what the p was.
12:30:43 <tomejaguar> I've a feeling it was some sort of category
12:31:05 <applicativ> kryft: if youre using ghc-7.6 youre already using it.
12:31:31 * tshirtman tries to print the result of max my_map, and doesn't really understand the error‚Ä¶ " No instance for (Show (Map Int (Int, String) -> Map Int (Int, String))) arising from a use of `show'"
12:31:41 <elliott> tomejaguar: a profunctor
12:31:44 <applicativ> kryft: the docs are fairly straightforward xhttp://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
12:31:47 <elliott> but it's actually more like p f s t a b for us
12:31:51 <geekosaur> tshirtman, you'r trying to show a function
12:32:05 <startling_> :t max
12:32:08 <lambdabot> Ord a => a -> a -> a
12:32:10 <tshirtman> hm, so i'm calling the function wrong
12:32:12 <tomejaguar> elliott: ah right.  Can you show me where that is in the docs?
12:32:21 <elliott> tomejaguar: I don't know that we actually document this stuff :)
12:32:22 <tomejaguar> I couldn't find it in the Control.Lens hackage page.
12:32:23 <startling_> tshirtman: no
12:32:33 <applicativ> its in profunctor
12:32:35 <elliott> the essential realisation is that (forall p. Profunctor p => p a b -> p s t) is an isomorphism
12:32:40 <startling_> tshirtman: you're calling it fine, but then it's trying to print it out to show you the result.
12:33:04 <startling_> the result is a function, and functions can't be printed in haskell
12:33:21 <ion> Œª> not
12:33:22 <ion> [(False,True),(True,False)]
12:33:29 <geekosaur> :p
12:33:41 <applicativ> Œª> (||)
12:33:50 <ion> [(False,[(False,False),(True,True)]),(True,[(False,True),(True,True)])]
12:33:58 <tshirtman> putStrLn (showTree (decoded)) this shows my map fine, putStrLn (show $ max decoded) this bork, i though max would return the max value in the map, hopefully
12:34:07 <Twey> Œª> sin
12:34:40 * applicativ likes this ion bot
12:34:57 <ion> Interesting. Please tell me more about likes this ion bot
12:35:08 <Twey> I don't know, it's kind of unresponsive.
12:35:11 <monochrom> haha
12:35:15 <kryft> applicativ: Ok, thanks
12:35:41 <dwcook> Œª> not
12:35:51 <dwcook> Oh, somebody did that already
12:36:03 <dwcook> Also it seems to have died?
12:36:25 <FreeFull> > max 0 0
12:36:27 <lambdabot>   0
12:36:35 <FreeFull> > max maxBound maxBound
12:36:36 <lambdabot>   ()
12:36:54 <simukis_> dwcook: I really doubt it was actually a bot.
12:37:38 <geekosaur> I think that's not a bot, it's ion cut & pasting from their ghci. dmwit had a bot "goodfellow" with the same package installed for a while (see http://hackage.haskell.org/package/universe I think)
12:37:54 <dwcook> That would explain why the response to applicativ made no sense
12:38:33 <tomejaguar> elliott: I was thinking of Overloaded
12:38:34 <tomejaguar> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Type.html#g:5
12:38:43 <ion> Yes, because English discussion by bots always makes sense.
12:39:02 <tomejaguar> elliott: Has anyone looked into use cases for this with p an arrow instance?
12:39:11 <tomejaguar> I think this would be quite useful to me now
12:39:12 * geekosaur confused. if you meant the response for (||), it makes sense if you know how to read it
12:39:14 <dwcook> ion, it's certainly not out of the realm of possibility that you're a bot that someone is also speaking through. But I am no longer convinced you are a bot. :P
12:39:14 <tomejaguar> so I'm going to investigate
12:39:59 <dwcook> geekosaur, you're right, I misread.
12:41:04 <hpaste> dmj pasted ‚Äúparsing user-agent‚Äù at http://lpaste.net/91522
12:42:15 <dmj`> any parsing gurus out there?
12:42:19 <geekosaur> dwcook, people can have bots hooked into their IRC clients too
12:44:34 <carter> unless theres an IETF RFC on user agent strings, you're out of luck
12:44:40 <carter> need a grammar to write a parser :)
12:44:54 <elliott> tomejaguar: sort of
12:45:08 <elliott> tomejaguar: we ended up recreating something kind of like Arrow when working out pure profunctor lenses
12:45:15 <elliott> we found the result quite awful though, and it wasn't exactly the same as Arrow
12:45:22 <elliott> basically we found out Arrow is wrong :P
12:46:50 <tomejaguar> AH
12:46:58 <tomejaguar> What did you find out about Arrow?
12:47:04 <tomejaguar> I am using them a lot now, so it would be useful to know.
12:48:11 <dmj`> carter: all rfc2616 says is: User-Agent = "User-Agent" ":" 1*( product | comment ) :/
12:48:25 <carter> dmj` theres a messy history of user agent strings for compatbility
12:51:01 <dmj`> carter: knew there was something wrong when a MSDN doc said, "For historical reasons, Internet Explorer identifies itself as a Mozilla browser"
12:51:31 <FreeFull> dmj`: Almost everything identifies itself as Mozilla
12:52:21 <carter> yeah
12:52:29 <carter> user-agent strings aren't very valuable
12:53:05 <HexSquid> Every browser "I'm Spartacus"
12:53:52 <mel-> good evening! I'm trying to write an application with gtk2hs. at some point (inside an event handler) i have the following problem. I have a value of type 'EventM EKey String'. So, somehow there's a string encapsulated in that value. how can I use putStrLn to print out this string value? Thanks
12:55:24 <Modius> Okay, I've verified that at least GHC optimizes out any "where" to a higher-level let if it's not dependent on any variables, e.g. foo x = x * 2 + y where y = ...     y is only calculated once if independent of x.  Is this documented or discussed under any specific terminology?  Do people worry about this if "y" is an intermediate thing of extreme size that has now become a permanent leak/fixture perhaps unintentionally?
12:55:58 <carter> Modius whats the question?
12:56:08 <tomejaguar> Modius: yes, I think this is the full laziness transformation
12:56:16 <carter> Modius: how new are you to ghc / haskell?
12:56:19 <Modius> carter:  I wanted to know if this is discussed anywhere I can research people discussing the corners
12:56:31 <carter> what corners?
12:56:41 <carter> you can look at some SPJ and simon marlow papers
12:56:43 <Modius> carter:  I mean, the ramifications of the behavior.  Gotchas, guidelines
12:56:47 <danharaj> sometimes -fno-full-laziness is used
12:56:58 <carter> the guidlines are: usually its fine
12:56:59 <Modius> carter:  Should probably consider me fairly new, although I've been failing at haskell for a long time :)
12:57:07 <geekosaur> there's a discussion in the ghc users manual
12:57:08 <S_J> if i have project/ and uinder there is filesystem/ store/ and test/ , how does the test/ stuff import the other stuff so it can test it?
12:57:10 <carter> i just write really strict code :)
12:57:26 <carter> when it matters
12:57:29 <carter> and lazy when it doesnt
12:57:43 <tomejaguar> Modius: does this thread help?  http://www.haskell.org/pipermail/haskell-cafe/2013-February/105201.html
12:59:09 <Modius> carter:  Don't get me wrong, I see how most of the time the capture/persistence of these values will be desired behavior.
12:59:26 <carter> yeah
12:59:42 <Modius> tomejaguar:  Thanks I'll look down from this link, I won't twiddle away from default settings; but people disussing their rationale will provide insight.
12:59:48 <carter> so you're wondering about how to deal with when theres too much sharing?
13:00:46 <Modius> carter:  Not really, in other languages I do this explicitly through a connstant or point-free style; but the "where" situation caught me by surprise - unlike the other cases it's not following the choice made through structure of the code or use of constructs; but the independence of the "where" on outer variables.
13:01:02 <carter> i'm not understanding your words
13:01:06 <tomejaguar> I agree with you Modius.  I found this behaviour very surprising.
13:01:16 <carter> explain with different words please
13:01:29 <carter> where is jus like let‚Ä¶. right?
13:01:34 <Modius> carter:  Basically, I'm used to explicitly doing let around it for this, and was only confused by the compiler being smart with "where"
13:01:42 <Modius> I get where is like let
13:01:46 <carter> smart hw?
13:02:00 <tomejaguar> It is to do with where the let is placed in relation to the lambda
13:02:18 <Modius> If the where uses a variable to the function, it won't (obviously) share.
13:02:29 <Modius> In, say, F#, I can "share" but do so only explicitly.
13:02:41 <carter> oh you mean share between invocations?
13:02:43 <Modius> Not complaining just commenting, fishing for insight
13:02:45 <Modius> carter:  YEah
13:03:10 <carter> huh
13:03:11 <tomejaguar> Modius: check this out too http://www.haskell.org/pipermail/haskell-cafe/2013-July/107979.html
13:03:21 * geekosaur wonders if MonoLocalBinds figures into this
13:03:30 <carter> would be easy to prevent the sharing
13:03:32 <Modius> My haskell surprises tend to be pleasant; but they remain surprises.
13:03:40 <Modius> carter:  Sure, now that I know to look for it.
13:03:55 <carter> dummy comptuations for the win
13:03:56 <tomejaguar> carter: unforutunately at -O you can't avoid this
13:04:07 <tomejaguar> unless you explicitly disable it with the appropriate -f
13:04:16 <carter> tomejaguar {-#NOININE#-}
13:04:22 <carter> *NOINLINE
13:04:25 <tomejaguar> pah
13:04:27 <Modius> tomejaguar:  I assume avoid here would mean forcibly defining a lambda or something, completely restating the function?
13:04:32 <FreeFull> In order for something to be "memoized", it has to be a monomorphic non-function
13:04:43 <FreeFull> So for example [Double]
13:04:52 <tomejaguar> It's not about memoization, it's about ghc's thunks.
13:04:59 <carter> yeah
13:05:01 <tomejaguar> (Which are of course rather /like/ memoization)
13:05:05 <carter> theres no memoization
13:05:18 <carter> just space leaks or clever precomputation :)
13:05:24 <carter> sometimes both
13:05:26 <carter> sometimes neither
13:05:33 <tomejaguar> Modius: there is no way to avoid it.  You just have to disable the optimization (as far as I know, anyway)
13:06:47 <FreeFull> fibs = 0 : 1 : zipWith (+) fibs . drop 1 $ fibs     "Memoized" list of fibbonacci numbers given the right type signature
13:06:47 <Modius> tomejaguar:  myfun x = x : hugehugehugeResource where hugeHugeHugeResource = ....                  <-- no way to spin that around such that I can name hugeHugeHugeResource and still not have it shared?  Maybe just not give it a name at all?
13:07:20 <Modius> tomejaguar:  worst case I guess myFun x = x : ...  <-- Or is the heavy optimizer even smart enough to share ... regardless?
13:07:34 <carter> ghc can estimate compute cost
13:08:06 <tomejaguar> Modius: My understanding is that "myfun x = x : hugehugehugeResource where hugeHugeHugeResource = ...." is fine with at optimization level 0.  If you use -O or above you have to disable the full laziness "optimization" to avoid sharing
13:09:34 <Modius> tomejaguar:  What about if there is not hugeHugeResource variable at all - does it even share the unnamed ... itself?
13:09:45 <tomejaguar> Modius: not sure, but I don't think so
13:10:10 <tomejaguar> "myfun x = let h = ... in x : h" is "myfun = \x -> let h = ... in x : h"
13:10:18 <tomejaguar> With full laziness this is "optimized" to
13:10:19 <FreeFull> Wait, will hugehugehugeResource be shared for all possible x?
13:10:36 <Modius> FreeFull:  If ... doesn't contain x, it seems so yes.
13:10:36 <carter> i don't think so
13:10:40 <tomejaguar> "myfun = let h = ... in \x -> x : h"
13:10:42 <carter> i think it depends
13:10:52 <carter> has to be heuristically "ok"
13:11:01 <FreeFull> So, if you have   myFun 3  and   myFun 5, will it be shared between the two?
13:11:04 <tomejaguar> do you see the operational difference between the two definitions of myfun
13:11:21 <tomejaguar> FreeFull: when the "let h =" is outside the lambda, it will be shared
13:12:26 <FreeFull> tomejaguar: Yeah, I can see that
13:12:35 <carter> if you can manufacture an example where it'll be slow reliably, and it shoudln't be, please file a ghc ticket
13:12:44 <S_J> if i have project/ and under there is filesystem/ store/ and test/ , how does the test/ stuff import the other stuff so it can test it? do I need to add to my path? my haskell path?
13:13:02 <carter> S_J is this a cabal quesetion?
13:13:11 <tomejaguar> carter: it's not to do with speed it's to do with memory consumption
13:13:17 <carter> yes
13:13:18 <carter> same idea
13:13:25 <carter> those are related
13:13:33 <carter> :)
13:13:45 <tomejaguar> Well see here: http://www.haskell.org/pipermail/haskell-cafe/2013-February/105199.html
13:13:45 <carter> the fastest code has no memory usage :)
13:13:49 <tomejaguar> it's not considered a bug, apparently
13:13:54 <pflaume> I don't get how fix :: (a -> a) -> a; fix f = let x = f x in x works.... since x is returned, x has to be of type a. ... however, x is defined by f x...!?! where does x come from?
13:14:09 <tomejaguar> pflaume: x is a thunk
13:14:22 <tomejaguar> not a value
13:14:28 <tomejaguar> f x is a thunk
13:14:29 <tomejaguar> not a value
13:14:31 <joelteon> it will be a value, someday
13:14:32 <joelteon> but not yet
13:14:35 <tomejaguar> maybe!
13:14:37 <tomejaguar> if you're lucky!
13:14:43 <danharaj> just expand the definition
13:14:44 <joelteon> it might be a value
13:14:51 <danharaj> f (f (f (f ....
13:14:56 <tomejaguar> not in the definition of fix f it's not
13:16:11 <danpalmer> right, it's been 6 hours and I still don't have a working ghc/cabal install. there's got to be an answer for this.
13:16:18 <pflaume> so is f ( f( ... infinitely long? when does a value get passed to f?
13:16:36 <tomejaguar> pflaume: x is a thunk.  It's a like a box you can open
13:16:41 <tomejaguar> When you open it you see "f x"
13:16:46 <danpalmer> "error: invalid preprocessing directive    '#-}'"
13:16:48 <danharaj> pflaume: It's a definition, you just expand the definition until you get a value.
13:16:55 <S_J> what kind of automata is Parsec? if you were to count the occurences of the sequence :$: in  a string, would you write a function for it or use Parsec?
13:17:03 <joelteon> pflaume: usually the fix terminates at a const, like
13:17:04 <tomejaguar> you don't necessarily need to open x again to get something out of that
13:17:09 <tomejaguar> you can start taking stuff out of x
13:17:11 <tomejaguar> sorry
13:17:13 <tomejaguar> out of f
13:17:16 <joelteon> > fix \f x -> if x == 1 then x else f (x - 1)
13:17:16 <lambdabot>   <hint>:1:5: parse error on input `\'
13:17:23 <joelteon> > fix (\f x -> if x == 1 then x else f (x - 1)) 3
13:17:24 <lambdabot>   1
13:17:24 <FreeFull> @src cycle
13:17:24 <lambdabot> cycle [] = undefined
13:17:24 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:17:33 <S_J> carter: not a cabal question. if i run ghci, how does it find modules in other dirs?
13:17:41 <joelteon> > fix const 1
13:17:42 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = b0 -> t0
13:17:42 <lambdabot>  Expected t...
13:17:44 <joelteon> whoops
13:17:48 <FreeFull> > fix $ const 1
13:17:49 <lambdabot>   1
13:17:55 <carter> S_J cabal has some work in progress for that :)
13:17:56 <carter> ithink
13:17:57 <joelteon> > fix (1:)
13:17:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:18:14 <carter> ghci naively only works if your directory structure is your module structure
13:18:21 <FreeFull> You can implement any recursive function using fix and a non-recursive function
13:21:17 <pentace> FreeFull: How would you implement map non-recursive?
13:22:36 <pflaume> joelteon: why did you supply fix with a function which takes 2 arguments?
13:22:52 <joelteon> :t fix
13:22:53 <lambdabot> (a -> a) -> a
13:22:54 <pflaume> and what is f for in there?
13:23:00 <joelteon> because fix takes a function that takes an argument
13:23:16 <pflaume> one argument, why are there two then?
13:23:24 <joelteon> in >fix \f x -> ..., f is the function being applied over and over, x is the initial value
13:23:46 <hpaste> oscarvarto pasted ‚ÄúNumeric Prelude basics‚Äù at http://lpaste.net/91524
13:23:46 <joelteon> @src fix
13:23:46 <lambdabot> fix f = let x = f x in x
13:25:05 <tomejaguar> pentace: let map = fix map' where map' mapagain f xs = case xs of [] -> []; (y:ys) -> f y : mapagain f ys
13:25:56 <pentace> > let map = fix map' where map' mapagain f xs = case xs of [] -> []; (y:ys) -> f y : mapagain f ys in map succ [2,4,6]
13:25:57 <lambdabot>   [3,5,7]
13:26:27 <oscarvarto> Hi! Trying to figure out how can I add a correct type signature http://lpaste.net/91524 I am trying to use root from Number.Root (first days with haskell‚Ä¶)
13:26:57 <tomejaguar> pentace: if you have "f x y z = ... f ... x ... y ... z ..." replace it with "f fagain x y z = ... fagain ... x ... y ... z ..." and then take "fix f"
13:27:41 <pentace> That seems like magic, trying to wrap my head around that ...
13:28:20 <Zenol> are they any HaTex guy here?
13:29:55 <tshirtman> it's funny how i write tons of code and delete most of it when i finally grok how to do what i want, the code very often ends up being a nice one-liner
13:30:15 <tomejaguar> tshirtman: yeah me too
13:31:17 <danr> pentace: well every occurence of fagain will be replaced with fix f, which is f (fix f), right? and fix f = fagain... see? :)
13:33:18 <pentace> Yes, but still tricky
13:36:12 <roboguy_> is there a circular list that's a Traversable and a Comonad?
13:36:25 <pentace> > let fib fib' n | n < 2 = n | otherwise = fib' (n - 1) + fib' (n - 2) in fix fib 10
13:36:26 <lambdabot>   55
13:36:42 <S_J> so ghci does not check the windows path or anything? and there is no way to give ghci the directories at startup?
13:36:46 <pentace> Once you know the pattern it's pretty simple
13:36:47 <danr> roboguy_: do you mean if there is an implemented one?
13:36:57 <roboguy_> danr: yeah
13:37:02 <tomejaguar> pentace: nice! :D
13:37:34 <danr> roboguy_: oh, not that I know of actually!
13:38:06 <monochrom> pentace: see my http://www.vex.net/~trebla/haskell/fix.xhtml
13:38:12 <danr> I never find myself wanting one, do you mind sharing what you are going to use it for?
13:38:26 <roboguy_> danr: I think I'm pretty close to implementing one, but I'm having some issues. I think the main problem I'm having is getting it to traverse in the rotation I want
13:38:40 <tomejaguar> oh monochrom you are albert?
13:38:46 <roboguy_> danr: well, I'm trying to implement something that plays the board game Mancala
13:38:48 <monochrom> yes
13:39:27 <tomejaguar> I never knew.
13:39:40 <tomejaguar> Oh maybe I did and forgot :)
13:39:45 <tomejaguar> Thanks again for your cabal page!
13:39:46 <danr> monochrom: excellent article!
13:40:11 <roboguy_> danr: effectively, you have a bunch of holes with stones in them in a circle. you take all the stones out of one of them and you go counterclockwise, placing one stone in each hole until you run out. there are other details, of course, but that's the part I'm working on representing right now
13:40:23 <pentace> monochrom: Is that "You could have re-invented ... too" some kind of series? I think I read that about monads a while ago O.o
13:40:38 <monochrom> no, there is no series
13:41:33 <danr> pentace: sigfpe wrote that one
13:41:47 <pflaume> thank you ! I will repeat thinking about fix tomorrow... :)
13:41:52 <danr> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:42:04 <ReinH> monochrom: needs more coalgebra
13:42:21 <tomejaguar> ReinH: coalgebra?
13:42:41 <danr> in some recent blog post sigfpe explains were he got the "you could have invented ..." title from, but I cannot remember from where :)
13:43:57 <ReinH> tomejaguar: in this case, just a joke about how popular co-whatever (categorical duals) has become in the Haskell world of late.
13:44:07 <ReinH> tomejaguar: I don't actually think it needs more coalgebra. ;)
13:44:10 <danr> roboguy_: ah, right! yeah that could perhaps be appropriate to use doubly-linked lists for
13:44:46 <tomejaguar> ReinH: ok :)
13:44:55 <roboguy_> danr: right now I have it implemented as a zipper, which is sort of similar
13:45:55 <monochrom> perhaps you're looking for cofix :: a -> (a->a), cofix a0 a1 = a0. a nice law relating cofix with fix: fix (cofix a0) = a0
13:46:52 <lykos> hello! I have a quick question: in my Main.hs, I keep getting a lot of compile errors that say "Not in scope: data constructor"
13:47:19 <lykos> I figure it's from not including type information when making a function
13:47:31 <geekosaur> @where hpaste
13:47:31 <lambdabot> http://lpaste.net/new/haskell
13:47:36 <tomejaguar> lykos: It means you need to import the data constructor from somewhere
13:47:41 <tomejaguar> or you've spelled it wrong
13:47:47 <apples_> oscarvarto: R.root 3 $ fromNumber 27, perhaps?
13:47:52 <lykos> tomejaguar: for functions I've defined?
13:48:12 <tomejaguar> No for the data constructor
13:48:13 <geekosaur> are you perhaps trying to mix case?
13:48:29 <tomejaguar> Anyway geekosaur is right.  Paste your code on http://lpaste.net/new/haskell
13:50:13 <oscarvarto> apples_: Thanks for helping. The output is Cons 3 27. I was trying to get toNumber to work ;)
13:50:36 <lykos> tomejaguar: okay, one sec
13:50:46 <ReinH> roboguy_: It's frustrating that "ring" means something else too
13:52:30 <hpaste> Lykos pasted ‚Äú"not in scope"‚Äù at http://lpaste.net/91526
13:53:04 <tomejaguar> lykos: you need to make commaSpace start with a lowercase letter
13:53:21 <lykos> ah, okay
13:53:32 <lykos> I didn't know that was required syntax
13:53:43 <lykos> what is the uppercase reserved for?
13:53:48 <tomejaguar> Constructors and types
13:53:59 <tomejaguar> Admittedly the error message is confusing
13:54:04 <tomejaguar> but CommaSpace x = insert 50 '\n' (Prelude.reverse ( insert 3 ',' (Prelude.reverse (show(x)) )))
13:54:12 <tomejaguar> could actually be a definition of x!
13:54:21 <hpc> or to make slightly more accurate what tomejaguar said, value and type constructors
13:54:28 <hpc> value and type variables are all lower case
13:54:32 <mel-> is there something like an 'empty IO action'? i.e. a value of type IO () which, when executed, does simply nothing?
13:54:42 <tomejaguar> mel-: return ()
13:54:53 <tomejaguar> it's the empty anymonad action!
13:55:04 <tomejaguar> feel free to use it wherever you like
13:55:10 <lykos> hey, thanks everyone
13:55:14 <mel-> ah, so I can cast this to IO (), thanks
13:55:15 <tomejaguar> it will do nothing everywhere
13:55:21 <lykos> I'd heard the haskell community was very helpful, I'm glad that's true :)
13:55:28 <hpc> mel-: you don't cast it
13:55:29 <tomejaguar> lykos: cool, you're welcome :)
13:55:40 <hpc> there's no such thing as a type cast in haskell
13:55:49 <hpaste> oscarvarto pasted ‚Äúroot from Number.Root‚Äù at http://lpaste.net/91527
13:56:12 <pentace> Zenol: Btw, what was your HaTeX qustion?
13:56:21 <mel-> hpc: what's the correct name then for doing something like: return () :: IO () ?
13:56:27 <lykos> out of curiousity: I use the "Just" built in command, but since it's upercase does that mean it's actually a constructor or something?
13:56:38 <danharaj> it is a constructor
13:56:38 <oscarvarto> apples_: I could not make something like that on the REPL (ghci): http://lpaste.net/91527
13:56:40 <danharaj> :t Just
13:56:41 <lambdabot> a -> Maybe a
13:56:44 <tomejaguar> lykos: yes it's a constructor of the Maybe datatype
13:57:46 <lykos> tomejaguar: okay, cool. I definitely want to learn more haskell, I'm still definitely new to it
13:58:04 <lykos> tomejaguar: I just started a snap web server, I figure it's a good way to learn haskell quickly
13:58:10 <apples_> oscarvarto: i'm not sure what you mean
13:58:27 <apples_> you don't have to print it explicitly if you're in the REPL
13:58:37 <tomejaguar> lykos: nice, well i hope you'll come back here with more questions when you have them
13:58:42 <hpc> mel-: giving a type signature
13:58:45 <tomejaguar> or feel free to /msg me
13:58:53 <hpc> mel-: which you probably don't need to do anyway, and it will be inferred
13:59:05 <oscarvarto> apples_: I meant lines 5--7
13:59:13 <tomejaguar> hpc: yeah but there's something particular about restricting the type signature.  dunno if it actually has a nice
14:00:58 <apples_> oscarvarto: oh, you're getting an error on the type signature line? you might want to inline that, i.e. x = R.root 3 $ R.fromNumber 27 :: R.T Double
14:02:16 <roboguy_> ReinH: yeah I know. I'm just calling it Zipper right now, but I'd probably change it to CircularZipper or something. it would be nice if there was something less wordy that wasn't already a math concept meaning something totally different
14:03:45 <oscarvarto> apples_: Thanks man! ;)
14:03:58 <apples_> oscarvarto: no prob
14:04:13 * hackagebot processing 1.0.1.0 - Web graphic applications with Processing.  http://hackage.haskell.org/package/processing-1.0.1.0 (DanielDiaz)
14:04:19 <oscarvarto> apples_: It's hard starting new stuff. But I'll keep going with Haskell
14:04:31 <apples_> it takes a while to get used to everything
14:14:04 <lykos> Are there any good terminal haskell editors for linux?
14:14:20 <tomejaguar> I use emacs.  Others like vim.
14:14:26 <tomejaguar> They both have decent haskell modes.
14:14:46 <lykos> I'm currently using nano
14:14:59 <wto> I use vim.
14:15:07 <lykos> out of emacs and vim, which do you think is better for haskell?
14:15:10 <tomejaguar> lykos: yeah that's probably gonna be awkward
14:15:17 <S11001001> lykos: try both of tomejaguar's suggestions; you will like one a lot more than the other.
14:15:21 <tomejaguar> lykos: they are both exactly equal.
14:15:27 <tshirtman> i use vim, and i found the plugins are nice
14:15:29 <S11001001> lykos: Never ask that :)
14:15:29 <wto> I agree with S11001001
14:15:31 <quchen> Editor wars are undecidable.
14:15:39 <startling_> I use vim, but I think emacs has better haskell support.
14:17:03 <tomejaguar> I use emacs, but I think vim has better haskell support.
14:17:31 <lykos> Fair enough ;)
14:17:35 <lykos> Thanks for the input though
14:19:38 <petantik> I have used both.
14:19:49 <petantik> I feel more comfy in vim
14:20:13 <lykos> tomejarguar: I'm having some new problems with my code. I just tried adding some explicit type definitions for my functions, and I'm getting a lot of type errors
14:20:24 <tomejaguar> lykos: ok paste the code again :)
14:21:07 <lykos> tomejarguar: doing that now, 1 sec :)
14:21:17 <lykos> this pastebin is brilliant!
14:21:33 <tomejaguar> yes it is
14:21:40 <lykos> is it using a haskell web server?
14:22:50 <tomejaguar> Based on the source I guess it uses snap https://github.com/chrisdone/lpaste
14:22:52 <pharaun> lpaste? yes
14:22:53 <tomejaguar> just like you :)
14:22:55 <lykos> alright, here my code it (it's messy, I know. Still, I want to untangle these types to understand them better)
14:23:31 <lykos> http://lpaste.net/91528
14:24:32 <tomejaguar> lykos: What do you expect answer to do?
14:25:06 <tomejaguar> I guess your type signature for commaSpaces is not general enough
14:25:10 <tomejaguar> did you mean commaSpace :: [Char] -> [Char]
14:25:12 <tomejaguar> err
14:25:17 <tomejaguar> I mean
14:25:22 <tomejaguar> commaSpace :: Show a => a -> [Char]
14:25:24 <lykos> 1 sec
14:25:32 <tomejaguar> i.e. convert anything that can be shown to a string
14:25:56 <tomejaguar> Also I would suggest replacing [Char] with String
14:26:02 <tomejaguar> they have the same meaning, but String is clearer
14:26:05 <lykos> well I'm just using it as a wrapper for the function it has in it
14:26:19 <lykos> bad form probably
14:26:59 <tomejaguar> Did you realise that product [1..100000]
14:27:02 <tomejaguar> is enormous?
14:27:13 <tomejaguar> 100,000 factorial
14:27:14 <lykos> yep :)
14:27:17 <tomejaguar> ok
14:28:21 <tomejaguar> so change the commaSpace type signature as I suggested
14:28:24 <tomejaguar> and see if that works
14:28:27 <lykos> will do
14:28:53 <lykos> I was using [Char] to make it clear that Strings are just lists of [Chars], but I could see string as being clearer
14:29:15 <tomejaguar> That one is completely up to you.
14:29:27 <lykos> 1 sec
14:31:24 <lykos> so what does the  => mean exactly in the type definition?
14:31:24 <tomejaguar> firstly: did it work?
14:31:41 <monochrom> it is a separator between typeclass constraints and the rest of the type
14:31:43 <lykos> commSpace takes 1 argument and returns 1 value, so why the multiple definitions?
14:31:55 <lykos> ah, I didn't try it yet, trying to understand it first I'll go check!
14:32:07 <tomejaguar> Better to try to understand it when we know it works :)
14:32:45 <anthezium> hey I'm trying to understand RankNTypes.  here: http://www.haskell.org/haskellwiki/Rank-N_types it says that universal quantifiers can be floated out of the right-hand side of ->, but not the left.  Mechanically I can accept that, but I don't understand why it's the case.
14:33:36 <lykos> still got one error:
14:33:38 <lykos> src/Main.hs:56:39:
14:33:38 <lykos>     Couldn't match expected type `[Char]' with actual type `Integer'
14:33:38 <lykos>     In the return type of a call of `fact'
14:33:38 <lykos>     In the first argument of `justBSCommaString', namely
14:33:38 <lykos>       `(fact (fst (fromJust (readInteger (fromJust (param))))))'
14:33:39 <lykos>     In the third argument of `maybe', namely
14:33:41 <lykos>       `(justBSCommaString
14:33:43 <lykos>           (fact (fst (fromJust (readInteger (fromJust (param)))))))'
14:34:25 <tomejaguar> fact returns an Integer
14:34:27 <monochrom> "f :: forall t. Int -> t" and "f :: Int -> (forall t. t)" both say: caller of f chooses t. therefore, they have the same semantics.
14:34:53 <tomejaguar> justBSCommaString expects a [Char]
14:34:56 <lykos> ah,yep, I see it now
14:35:06 <lykos> I was thinking it was saying that fact was being passed the wrong type
14:35:08 <tomejaguar> you can use Show a => a -> [Char] for justBSCommaString too
14:35:35 <tomejaguar> When you've made that change I'll show you something cool
14:35:55 <lykos> k
14:36:26 <anthezium> monochrom: Yeah but why is "f :: forall a b. a -> b" not the same as "f :: forall b. (forall a. a) -> b"?
14:36:27 <lykos> well, that wont work for justBSC
14:36:40 <lykos> because it returns a Maybe ByteString
14:36:44 <mhitza> is there a way I can tell cabal to keep the source code locally when downloading packages?
14:36:59 <lykos> I could obviously just call show on fact before I pass it to justBSC
14:37:01 <tomejaguar> lykos: ah yes
14:37:08 <monochrom> in "f :: forall b. (forall a. a) -> b", caller chooses b, callee chooses a.
14:37:14 <tomejaguar> Show a => a -> Maybe ByteString
14:37:15 <lykos> but is there some way to use Show in the type defintion of justBSC?
14:37:41 <tomejaguar> justBSCommaString :: Show a => a -> Maybe ByteString
14:37:43 <lykos> in which a is guarenteed to be a string inside the function?
14:37:44 <tomejaguar> that was my mistake
14:37:54 <lykos> I caught it though before even trying ;)
14:37:59 <lykos> I'm learning :D
14:38:00 <tomejaguar> cool :)
14:38:04 <tomejaguar> so what's your quesiton?
14:38:41 <tomejaguar> basically if you do Show a => a -> ...
14:38:48 <tomejaguar> then a is guaranteed to be something you can "show"
14:38:51 <tomejaguar> i.e. convert to a string
14:38:55 <kloplop321> I was told it is looked down upon to put typeclass constraints on data constructors, why is this so?
14:39:50 <lykos> tomejaguar: that's definitely powerful! is that the cool thing you said you'd show me?
14:39:55 <tomejaguar> no
14:40:03 <tomejaguar> you get the cool thing once your code compiles :)
14:40:29 <anthezium> like when (forall a. a) is the explicit parameter, a's type is resolved in terms of the types in the body of f, not the types at the call-site?  don't those always have to be unified anyway?
14:41:05 <lykos> oh, it compiles :) it actually compiled before, but I wanted to get a clean compile. Sadly, still some warnings
14:41:53 <monochrom> a is chosen by the body of f, yes. unify with whom?
14:42:11 <lykos> I mean compiled before at a certain point, it's being working/breaking a lot :P
14:42:28 <anthezium> the caller and callee
14:42:54 <monochrom> perhaps f decides to unify a with Int in one branch, and with Bool in another branch? now what can the caller do?
14:43:41 <quchen> kloplop321: A typeclass provides functions that can act on the types that are an instance of it. If you constrain type definitions using classes, you restrict any possible use of your type to that class, whether it's needed or not. For example, if you wanted to encode ordered lists, you might invent "data OList a = Ord a => OList [a]" (or whatever the syntax is, I don't even know). However, you might want to act on an ordered list in a way
14:43:41 <quchen> that doesn't use the fact that it's ordered - `head` for example would necessarily require Ord, but it doesn't need order at all.
14:44:21 <monochrom> there is no unification between caller and callee
14:44:24 <kloplop321> I see.
14:44:25 <quchen> kloplop321: The short version is that you should always add the restriction where it is necessary for a function to work, and not on the datatype.
14:44:35 <kloplop321> Thank you quchen
14:45:26 <quchen> GHC even calls it stupid [sic] in its source do do it ;-)
14:45:28 <tomejaguar> lykos: the cool thing is that you can write "commaSpace = insert 50 '\n' . Prelude.reverse . insert 3 ',' . Prelude.reverse . show"
14:45:40 <tomejaguar> Also you don't need to qualify Prelude
14:45:45 <tomejaguar> so you can just do
14:45:48 <tomejaguar> commaSpace = insert 50 '\n' . Prelude.reverse . insert 3  ',' . Prelude.reverse . show
14:45:51 <tomejaguar> err...
14:46:04 <tomejaguar> commaSpace = insert 50 '\n' . reverse . insert 3 ',' . reverse . show
14:46:06 <tomejaguar> ^^ is what i meant
14:46:35 <lykos> ah yes, composition! thanks for suggesting that, my code has had a lot of parentheses (and nano doesn't have matching)
14:46:48 <tomejaguar> yeah i hate parentheses
14:46:53 <tomejaguar> i love composition
14:46:53 <lykos> as for reverse, reverse is also definted in Data.BtyeString.Char8
14:46:57 * tshirtman loves . and $
14:46:58 <lykos> I added it when I got a conflict
14:47:07 <tomejaguar> ah sorry
14:47:09 <tomejaguar> you're right
14:47:17 <lykos> is there any way to make it so I can just use "reverse"?
14:47:26 <lykos> some definition or something?
14:47:29 <tomejaguar> if you do "import qualified Data.BtyeString.Char8"
14:47:38 <tomejaguar> then you have to qualify Data.ByteString.Char8.reverse
14:47:41 <tomejaguar> but not Prelude.reverse
14:47:53 <quchen> Eww, BS.Char8 - why not use actual ByteStrings?
14:47:57 <lykos> well I tried just reverse and it gave an error
14:48:03 <quchen> (And do the encoding explicitly)
14:48:26 <lykos> (quchen: I'm using snap server, new to the bytestring stuff)
14:49:12 <S_J> Would it be terrible to create a database (key-value store) that works like this: 1. read all data from a file at startup; 2. parse data into a Map key value; 3. keep all data in RAM while running. 4. on shutdown, write to file again. //// inefficient? backwards? how is it normally done?
14:49:16 <kloplop321> quchen: because it makes prototyping easier when playing with ghci
14:49:50 <lykos> tomejaguar: I got my insert function online, and I admittedly don't understand it. I'm getting a "shadowing" warning, how could I resolve it? I understand the concept of shadowing, just not sure which xs's are which in this function?
14:50:25 <tomejaguar> lykos: the ones that are shadowed are the ones in the definition of countdown
14:50:32 <tomejaguar> you could change them to ys
14:50:57 <enthropy> you could put it in a
14:51:05 <enthropy> module that's compiled without warnings
14:51:23 <monochrom> that is head-in-sand
14:51:28 <lykos> change which ones to ys?
14:51:36 <lykos> perhaps I don't really understand shadowing in haskell
14:51:51 <tomejaguar> countdown 0 xs = ... etc.
14:52:03 <tomejaguar> all of them in the definition of countdown in the where clause
14:52:33 <kloplop321> S_J: I am currently using hashtables for at least some of that. Perhaps you could use unsafePerformIO to load the stuff in. But I have absolutely no idea how to accomplish save on shutdown. The only thing I could think of is forking another thread that saves periodically (inefficient)
14:52:35 <monochrom> shadowing just means: you have an outer guy called "xs", and an inner guy called "xs" again.
14:52:44 <mhitza> when installing packages with cabal, can I specify to it to keep the source locally?
14:52:50 <lykos> called or defined?
14:52:57 <lykos> shadowing is a scoping issue, right?
14:53:01 <monochrom> defined
14:53:02 <tomejaguar> yes
14:53:10 <lykos> I see it now
14:53:14 <tomejaguar>    countdown 0 xs = y:countdown n xs -- reset to original n
14:53:14 <tomejaguar>    countdown _ [] = []
14:53:14 <tomejaguar>    countdown m (x:xs) = x:countdown (m-1) xs
14:53:14 <monochrom> FSVO of defined
14:53:18 <tomejaguar> you can change all those xs to ys
14:53:25 <tomejaguar> well, I wouldn't use ys
14:53:27 <lykos> I don't really understand the where syntax
14:53:28 <tomejaguar> because you've already got a y
14:53:30 <tomejaguar> maybe zs
14:53:32 <tomejaguar> or as
14:53:33 <tomejaguar> or something
14:53:37 <monochrom> a formal parameter xs counts as "define xs" for this purpose
14:53:57 <tomejaguar> lykos: what don't you understand about it?
14:54:01 <kloplop321> lykos: the where is like a let but after the fact.
14:54:41 <monochrom> yeah, it means local definitions
14:55:23 <S_J> kloplop321: youd start the database and load it and nwhen the program shuts own it xloses, so jsut once
14:55:27 <lykos> tomejaguar: well, understand that usage of it, but I don't understand the different countdown definitions. Polymorphic?
14:55:42 <kloplop321> S_J: I didn't misunderstand your desire. I just don't know how to do that.
14:55:47 <tomejaguar> lykos: do you mean why there are three lines in the definition?
14:55:51 <S_J> ok
14:55:52 <kloplop321> S_J: if this were C++, I could help you.
14:56:08 <lykos> tomejaguar: yeah.
14:56:22 <tomejaguar> Well how did you ever write this function then? :)
14:56:29 <monochrom> :)
14:56:34 <lykos> I found it online :P
14:56:36 <tomejaguar> ah
14:56:45 <tomejaguar> well its because you are pattern matching
14:56:51 <anthezium> monochrom: so (forall a. a) in a parameter means "a can be any type that could unify with the body of the callee", while (forall b. b) in the return type means "b can be any type that unifies with the body of the caller", and this is not the same set of (a,b) as "forall a b. a -> b", as those (a,b) are "a and b could be any types that unify with the body of the caller"?
14:56:53 <lykos> I've heard about that before
14:57:05 <monochrom> it means 3 branches, choose which branch depending on actual parameters
14:57:09 <tomejaguar> when countdown n xs is called it first checks whether n is 0, and if so runs the first line
14:57:20 <tomejaguar> if not it checks if xs is [] and if so runs the second line
14:57:23 <tomejaguar> if not it runs the third line
14:57:24 <tomejaguar> see?
14:58:46 <monochrom> that's right anthezium
15:00:17 <quchen> lykos, kloplop321: The problem with BS.Char8 is that it (silently!) truncates all Chars to the first byte.
15:00:37 <kloplop321> Oh, well that's something I did not know!
15:00:42 <monochrom> and the solution is "I'm using ASCII"
15:00:49 <tomejaguar> quchen: why is it even on hackage.  people complain about it all the time
15:00:50 <dmj``> there a more elegant way to drop last two elements of a list besides (init . init) xs or reverse . drop 2 . reverse $ xs
15:01:04 <lykos> quchen: meaning exactly?
15:01:21 <kloplop321> Isn't it part of bytestring? Not as something else on top?
15:01:29 <lykos> tomejaguar: okay, that's really useful. And I can do that for any function? what's the _ mean? and what is (x:xs)?
15:01:42 <kloplop321> _ usually means "I don't care what goes here"
15:01:44 <monochrom> it went on hackage before the haskell community awakened to unicode and internationalization
15:01:46 <quchen> lykos: Unicode is a multi-byte encoding. If you have a valid String that contains stuff like "‚àÄ" and `unpack.pack` it, you won't get the original string again.
15:01:50 <tomejaguar> _ means it matches anything and you don't care what it is because you'll never use it in the body of the function
15:02:01 <tomejaguar> (x:xs) means match a list whose first element is x and whose tail is xs
15:02:22 <quchen> lykos: If you want to serialize a String to a BS so you can send/store it easily, not getting your data out again is the worst case scenario.
15:02:53 <lykos> quchen: although I've I'm using 8 byte ascii, it should be fine? I would prefer to use one compatible with unicode though. What are the alternatives?
15:02:54 <quchen> tomejaguar: It's sometimes convenient for awful-level dirty hacks.
15:03:07 <tomejaguar> quchen: it should have a big warning on it then
15:03:08 <quchen> lykos: You should never assume you're using 8-byte ASCII.
15:03:10 <monochrom> GHC began its unicode awareness some 10 years after windows, linux, and irc clients had unicode awareness
15:03:20 <quchen> tomejaguar: It has a little note in the docs if that counts :-S
15:03:32 <tomejaguar> haha
15:03:35 <monochrom> therefore, bytestring written at that time could assume "everyone is latin-1"
15:03:56 <monochrom> afterall, GHC couldn't do anything else at that time anyway
15:03:58 <kloplop321> Isn't that like one of the mysql defaults?
15:04:11 <quchen> lykos: If you have an encoding library that violates `unpack.pack /= id` that's a *very* bad thing. Similarly, you could argue that it's not bad that some library has a non-commutative (*) operation because it works alright for numbers under 100.
15:04:14 <monochrom> also, ASCII is merely 7 bits :)
15:04:24 <quchen> monochrom: Plus sign! :-P
15:04:44 <quchen> Ignore that rubbish comment, I regretted it immediately after hitting enter
15:05:27 <monochrom> I don't understand the comment, but I understand the :-P part and like it :)
15:05:37 <Modius> Thoughts:  If you were doing up a web utility to help people coming from a Visual Studio/C# perspective get to Haskell, would you start them off with Emacs/GHC-mod?  I've found the ability to check types from the editor invaluable; but despite the learning curve for emacs wonder if there's anything any lower impedance.
15:05:38 <lykos> tomejaguar: what if you want something to match with anything and you DO want to use it in the function in the body? simply use a variable?
15:05:45 <Modius> I mean, a blog/guide
15:05:45 <quchen> lykos: If you're *sure* you're using 8-Bit ASCII, why not encode it as a [Word8], which you can encode properly using normal BS? :-)
15:05:47 <tomejaguar> lykos: yes
15:05:56 <monochrom> oh wait, a sign bit? haha
15:05:59 <lykos> tomejaguar: would [countdown m (x:xs) = x:countdown (m-1) xs ]
15:06:22 <tomejaguar> lykos: what do you mean?
15:06:25 <quchen> monochrom: Yeah, sign bit.
15:06:41 <tomejaguar> inverse video bit?
15:06:49 <lykos> tomejaguar: be the same as countdown m xs = (head xs):countdown (m-1) (tail xs)
15:06:52 <monochrom> anyway, I'm fine with a toy program going Char8. but it must stay a toy.
15:07:01 <quchen> monochrom: It's like the ASCII creators anticipated the invention of UTF-8 :-D
15:07:13 <tomejaguar> lykos: kind of
15:07:41 <tomejaguar> if you substituted that in this case it would work
15:07:43 <quchen> monochrom: Things I've learned never to assume: 1. You're the only one reading your code. 2. You'll never reuse this piece of code. 3. This code is self-explanatory and doesn't need comments.
15:07:43 <tomejaguar> and do the same
15:08:04 <tomejaguar> but the benefit of using pattern matching is that in the body of your function you are guaranteed to have the expected form of variables in the pattern
15:08:07 <lykos> tomejaguar: I'm just trying to understand the (x:xs) more. is it basically taking one argument, a list, and binding the head to variable x and tail to variable xs?
15:08:18 <tomejaguar> yes
15:08:23 <tomejaguar> however, not all lists have a head
15:08:29 <tomejaguar> so you also need the [] pattern
15:08:33 <tomejaguar> when you define your function
15:08:39 <monochrom> ohh!!!
15:08:49 <kloplop321> as per quchen's notification, I've removed .Char8 from one of my things. :)
15:08:57 <monochrom> lykos: see also my http://www.vex.net/~trebla/haskell/crossroad.xhtml
15:09:20 <lykos> quchen: I see what you're saying about encoding, but I want to focus on some other stuff right now. Thanks for the heads up though! Do you have a package name I can investigate in the future as an alternitive to Char8?
15:09:35 <quchen> lykos: Yes, BS without Char8.
15:09:50 <quchen> It uses Word8 and is not tied to any meaning of the bytes.
15:10:00 <quchen> i.e. the normal ByteString library
15:10:01 <tomejaguar> Why's it not called Char7
15:10:19 <lykos> tomejaguar: I get it, matches assuming that not []
15:10:19 <monochrom> "it" = ?
15:10:21 <tomejaguar> Oh it is full 8 bit
15:10:21 <quchen> Char8 isn't really a thing. It's a version of Word8 that hints that there's something Char-y going on.
15:10:30 <lykos> tomejaguar: what if length == 1 though?
15:10:40 <lykos> tomejaguar: would xs be []?
15:10:41 <monochrom> yeah, a byte has 8 bits
15:10:44 <tomejaguar> quchen: What's a Word8 anyway?
15:10:54 <quchen> tomejaguar: Unsigned 8-bit integer
15:10:54 <monochrom> a number type of 8 bit
15:11:00 <tomejaguar> quchen: oh ok
15:11:08 <tomejaguar> lykos: i'm not sure what you mean
15:11:15 <lykos> quchen: I come from a c background, I have a certain affinity for chars ;)
15:11:17 <quchen> tomejaguar: "UInt8" might have been a better name in retrospect
15:11:21 <monochrom> > [254, 255, 256] :: [Word8]
15:11:22 <lambdabot>   [254,255,0]
15:11:38 <quchen> lykos: What's a char in C?
15:11:59 <quchen> lykos: sugarcoated uint or something?
15:11:59 <tomejaguar> quchen: yes I think it would
15:12:26 <tomejaguar> quchen: C char is guaranteed to have sizeof 1
15:12:27 <lykos> quchen: no, just 8 bytes. C is quite low level in some areas, and strings in c are simply null terminated arrays of chars.
15:12:40 <quchen> Ah.
15:12:40 <lykos> quchen: 1 byte I mean :P
15:12:47 <lykos> quchen: 8 bits
15:12:52 <djahandarie> > map (fromIntegral . ord) "„ÇÑ„Å∞„ÅÑ"
15:12:53 <lambdabot>   [12420,12400,12356]
15:12:55 <lykos> quchen: plain old aski
15:12:55 <djahandarie> > map (fromIntegral . ord) "„ÇÑ„Å∞„ÅÑ" :: [Word8]
15:12:56 <lambdabot>   [132,112,68]
15:12:59 <tomejaguar> Well, the C standard doesn't guarantee /that/
15:12:59 <lykos> quchen: plain old ascii*
15:13:02 <tomejaguar> but it must have at least 8 bits
15:13:17 <lykos> true
15:13:21 <lykos> and in most implementations it is
15:13:26 <quchen> ASCII isn't 8 bit, like Monochrom said earlier.
15:13:37 <tomejaguar> I can't remember whether the standard says it should be signed or unsigned
15:13:40 <quchen> "Most implementations" is not a good assumption for writing code.
15:14:05 <quchen> / Compile using GCC, might do something completely unrelated with other compilers because I abused arbitrary choices GCC developer made
15:14:11 <quchen> Hm.
15:14:20 <quchen> Also XChat swallowed a "/" there.
15:14:22 <tomejaguar> C is not a good assumption for writing code 8D
15:14:41 <lykos> quchen: I honestly don't know much about the c standard on chars
15:14:51 <monochrom> the standard says, implementation chooses signed vs unsigned. in all compilers I have used, they chose signed.
15:15:22 <Clint> lucky you
15:15:29 <monochrom> yeah! :)
15:16:06 <quchen> Clint: Funny you say that, I always read your name as "CInt" on first sight for some reason haha
15:16:21 <lykos> anyhow
15:16:44 <monochrom> perhaps c long int
15:17:25 <S_J> I want to parse like this: 1. Get chars until DELIM is found. 2. split on DELIM -> (matched form, rest of string). but how is that achieved in Parsec?
15:17:32 <lykos> tomejaguar: if I called countdown as such: countdown 0 [1]
15:17:32 <S_J> I know how to parse and find the string I want
15:17:40 <lykos> it would use the first defintion of countodwn
15:17:41 <S_J> but now how to split the string
15:17:43 <lykos> right?
15:17:54 <tomejaguar> lykos: right
15:18:09 <tomejaguar> the first one matches
15:18:11 <tomejaguar> so it uses that
15:18:21 <lykos> and countdown (Maybe Ninja) [] would use the second
15:18:29 <Zenol> djahandari: You write such kawaii haskell :)
15:18:35 <tomejaguar> lykos: yeh well kinda
15:18:37 <lykos> Although honestly, it's always ninja. Always.
15:18:48 <lykos> wouldn't it? if _ matches everything
15:18:53 <tomejaguar> lykos: Maybe Ninja is a type not a value
15:19:02 <lykos> yeah, I know
15:19:14 <lykos> lets say a
15:19:19 <lykos> where a :: Maybe Ninja
15:19:25 <tomejaguar> right well again kinda
15:19:26 <lykos> anyhow, it matches anything passed?
15:19:34 <tomejaguar> you can only pass an Int as the first argument
15:19:38 <tomejaguar> it matches any int
15:19:42 <tomejaguar> but it has to be an Int
15:19:44 <lykos> why?
15:19:50 <lykos> where is that defined?
15:19:51 <monochrom> static typing
15:20:00 <tomejaguar> ah
15:20:06 <tomejaguar> sorry it doesn't have to be an Int
15:20:13 <tomejaguar> err
15:20:17 <tomejaguar> yes it has to be an int
15:20:23 <monochrom> it has to be some kind of number
15:20:35 <tomejaguar> because insert takes an Int and passes it to countdown
15:20:44 <monochrom> make it 1, will you? countdown 1 []
15:21:00 <lykos> hmm
15:21:10 <lykos> lets forget insert for a sec
15:21:17 <lykos> and just say we have countdown defined by itself
15:21:21 <monochrom> if you define "ninja = 1" somewhere, you can also say "countdown ninja []", if you insist on ninja
15:21:21 <lykos> in those three lines
15:21:43 <tomejaguar> ok, you'll need a y defined somewhere too, so let's assume that is
15:21:48 <tomejaguar> Then if you don't give a type
15:21:56 <monochrom> the "0" in the pattern forces a number type on that parameter position.
15:21:59 <tomejaguar> the compiler will infer
15:22:05 <lykos> okay
15:22:25 <tomejaguar> Num a => a -> [b] -> [b] I believe
15:22:25 <lykos> fair enough
15:22:32 <tomejaguar> so it has to be a Num
15:22:41 <lykos> and xs would be [a]?
15:22:46 <tomejaguar> yes
15:22:48 <tomejaguar> no
15:22:49 <tomejaguar> [b]
15:22:54 <lykos> ?
15:22:57 <lykos> y = a?
15:23:12 <lykos> I thought that [a] was arbitrary?
15:23:17 <tomejaguar> Well this is complicated because we haven't specified what the type is for y
15:23:30 <monochrom> perhaps make it "Num c => c -> [a] -> [a]" so you don't have to keep changing names
15:23:45 <lykos> okay
15:24:05 <tomejaguar> Anyway, _ will match anything
15:24:07 <monochrom> Num ninja => ninja -> [a] -> [a]
15:24:20 <tomejaguar> but your program won't compile unless the argument that it is ignored is of the right type
15:24:28 <tomejaguar> so in that sense it can't take "anything"
15:24:33 <tomejaguar> because not everything will compile
15:24:33 <lykos> I get it
15:24:44 <lykos> sidetrack: can you explain => in a bit more depth?
15:24:50 <lykos> hey, thanks guys, I'm learning a lot here
15:24:52 <tomejaguar> OK
15:24:54 <tomejaguar> Num a =
15:24:56 <tomejaguar> err...
15:25:01 <tomejaguar> Num a => a -> whatever
15:25:03 <startling_> lykos, it's a typeclass constraint.
15:25:14 <tomejaguar> means it takes any type a, as long as that type a is an instance of Num
15:25:18 <monochrom> it is punctuation between typeclass constraints ("Num ninja") and the rest of the type
15:25:45 <lykos> how is that different than   Num -> whatever?
15:25:54 <tomejaguar> Num is not a type
15:26:01 <tomejaguar> it's a typeclass
15:26:02 <lykos> okay
15:26:05 <monochrom> Num is not a type. "type -> type" required
15:26:05 <lykos> like Show?
15:26:09 <tomejaguar> Types like Int, Double can be instances of Num
15:26:19 <monochrom> furthermore, "Num ninja" is still not a type
15:26:22 <tomejaguar> Show is also a typeclass
15:26:39 <lykos> what are some other typeclasses?
15:26:48 <tomejaguar> Monad
15:26:50 <tomejaguar> Functor
15:26:56 <lykos> okay
15:27:02 <lykos> I like haskell, it's very ordered
15:27:02 <monochrom> it is always "constraint => rest of type"
15:27:18 <tomejaguar> lykos: it is ordered, but the order is not always correct :)
15:27:34 <monochrom> (Show ninja, Num ninja) => ninja -> [a] -> [a]  is another example
15:28:22 <ion> Ah, the classic example of useful Haskell.
15:28:49 <monochrom> "Num ninja" allows you to do arithmetic. "Show ninja" allows you to call "show"
15:29:00 <lykos> tomejaguar: and it's still developing, which I like :)
15:29:11 <monochrom> if you need to call "==", add an extra "Eq ninja"
15:29:18 <lykos> tomejaguar: I'm planning on going to grad school, possibly something involving some haskell
15:29:18 <tomejaguar> lykos: yeah we're converging on the correct order
15:29:28 <c_wraith> ok...  I feel like the ghc docs are lying to me when they tell me that ScopedTypeVariables are always available in RULES pragmas. I couldn't refer to a type bound in the LHS from the RHS at all.
15:29:31 <tomejaguar> lykos: that would be fantastic!
15:29:46 <lykos> tomejaguar: I saw a really cool thesis recently on AI and typeclass inference
15:30:15 <lykos> tomejaguar: I'm leaning to going into AI right now, and haskell could be good for that
15:30:19 <lykos> anyhow
15:30:20 <monochrom> onoes, skynet will infer our types
15:30:25 <lykos> exactly! :D
15:30:44 <tomejaguar> lykos: are you named after a defunct search engine?
15:30:53 <monochrom> perhaps unsafeLaunchMissiles will have type (forall a. a) afterall
15:31:00 <Adeon> he can infer types 1000 times better than any human
15:31:05 <lykos> lykos: no, although I recently found that out when I tried to register the domain name
15:31:08 <monochrom> oh! I remember lycos, yeah
15:31:15 <lykos> lykos: greek word for Wolf, I found it cool
15:31:51 <monochrom> ah! no wonder that vampire-vs-werewolf movie talks about "lykas" all the time
15:32:06 <lykos> monochome: doomsday :: NukeCode -> World -> Nothing
15:32:21 <tomejaguar> lol
15:32:37 <monochrom> we have a type called Void
15:32:39 <tomejaguar> Unfortunately Nothing is not a type
15:32:58 * tomejaguar is still laughing at the type signature
15:33:08 <c_wraith> 'Nothing is a type.  of kind 'Maybe a
15:33:23 <c_wraith> ...  I've been working too much with DataKinds
15:33:33 <lykos> exatly
15:33:37 <lykos> exactly*
15:33:51 <tomejaguar> c_wraith: 'Nothing is the same as ()?
15:33:56 <lykos> As in "Maybe a civilization will rise from the dust, but probably not"
15:33:57 <c_wraith> tomejaguar: not at all
15:33:58 <tomejaguar> c_wraith: and 'Just a is a?
15:34:08 <tomejaguar> c_wraith: oh, ok can you explain what it is?
15:34:09 <c_wraith> tomejaguar: there's a value of type (), it's ()
15:34:16 <c_wraith> tomejaguar: there are no values of type 'Nothing
15:34:39 <c_wraith> tomejaguar: in fact, there are no values of any DataKinds-promoted type
15:34:44 <monochrom> just use Void
15:34:51 <c_wraith> Void is appropriate here.
15:34:55 <tomejaguar> c_wraith: so there are no values of 'Maybe a
15:35:22 <tomejaguar> well DataKinds still confuse me
15:35:30 <c_wraith> tomejaguar: well, 'Maybe a is a kind. There are types of that kind.  There are no values of types with kind 'Maybe a)
15:36:04 <c_wraith> Get very comfortable with the distinction between types and kinds, and then DataKinds will make way more sense
15:36:30 <quchen> Since it's been brought up many times in the last weeks, I wrote down some thoughts on BS.Char8 here: https://github.com/quchen/articles/blob/master/fbut.md
15:36:45 <tomejaguar> c_wraith: I don't understand how a kinds whose types have no inhabitants can be useful.
15:36:49 <quchen> I imagine there are many other things to be added to that file, but I can't recall any of them right now.
15:37:22 <lykos> if I called countdown 10 [1,2] it would use the third definition (third pattern? what's the common phrasing here), with x being 1 and xs being 2?
15:37:32 <lykos> well, I guess xs being [2]?
15:37:39 <tomejaguar> lykos: yes
15:37:51 <tomejaguar> and m being 10
15:38:03 <tomejaguar> (xs is bound to [2])
15:38:14 <lykos> okay, and countdown 10 [1] would be
15:38:16 <lykos> m = 10
15:38:18 <lykos> x = 1
15:38:20 <lykos> xs = []?
15:38:25 <tomejaguar> exactly!
15:38:47 <lykos> okay. any way to have a pattern m > 8, say?
15:38:53 <S_J> Any Parsec gurus in here? If you have a file that looks like :key:actual_key:value:actual_value:endkeyvalue::key:etc... I know the basics of Parsec but how do you parse a key/value pair, store it in a Map and then continue parsing the rest of the string? Can I get (parsed out key/value pair, rest of string) from Parsec and then continue with that?
15:39:11 <tomejaguar> lykos: hmm well kind of
15:39:14 <monochrom> lykos: "the 3rd equation" or "the 3rd branch"
15:39:15 <tomejaguar> lykos: but I would suggest using a guard
15:39:20 <c_wraith> tomejaguar: they're useful for type-level programming.  I don't think they actually enable anything you couldn't do before, but they make the syntax a lot cleaner.
15:39:37 <tomejaguar> c_wraith: as constraints?
15:39:55 <tomejaguar> c_wraith: I can see how its useful to use them for phantom types
15:39:55 <c_wraith> tomejaguar: like, if you've ever seen the use for a phantom type argument, you're on your way to seeing why other types that don't have associated values are handy
15:39:58 <lykos> tomejagar: guard being |, right? Are guards better than pattern matching? I'm starting to quite like pattern matching :P
15:40:13 <lykos> tomjagar: very modular, seems to work very well with branching
15:40:16 <tomejaguar> lykos: I very rarely use guards myself
15:40:28 <c_wraith> If both are an option, you should pattern match
15:40:36 <c_wraith> Only use guards for expressions you can't pattern match on
15:41:11 <tomejaguar> lykos: In my current codebase I have two functions defined using guards out of 3.5kloc
15:41:36 <quchen> S_J: keyValueRest = (,,) <$> parseKey <* char ':' <*> parseValue <*> parseRest
15:41:44 <tomejaguar> c_wraith: but can you actually tie the phantom type to the value in a typesafe way?
15:42:05 <lykos> tomejaguar:3.5k codebase? what have you been programing?
15:42:09 <quchen> S_J: A more precise data format description would be helpful though :-)
15:42:20 <carter> hehe: phantom types come up a lot in my code
15:42:27 <lykos> btw for anyone who missed it, here's the code I'm talking about:
15:42:37 <tomejaguar> c_wraith: I've used phantom types a lot to sort of guarantee my list is of a certain size
15:42:40 <hpaste> lykos pasted ‚Äúsource code‚Äù at http://lpaste.net/91530
15:42:55 <tomejaguar> by using nested tuples of the same length in the phantom type argument
15:43:03 <carter> lykos whats this mini web app for?
15:43:16 <lykos> carter: just for fun. teaching myself
15:43:20 <carter> cool
15:43:27 <tomejaguar> lykos: my code is a relational database api and some reports based on it for my client
15:43:31 <carter> all those fromJusts could be don as a do notation
15:43:49 <carter> use the Maybe monad
15:44:01 <carter>  writeBS (do ....)
15:44:11 <carter> decent code though
15:44:16 <quchen> S_J: and  parseRest = manyTill anyToken eof
15:44:29 <carter> lykos do you see what i'm saying?
15:44:32 <lykos> yep!
15:44:35 <carter> yay
15:44:42 <carter> glad i could help with so little effort
15:44:48 <lykos> most of the code was auto-generated
15:44:50 <carter> ah
15:44:51 <tomejaguar> carter: you are nothing if not effective
15:44:55 <lykos> I know a lot of my code is messy :P
15:44:59 <carter> its ok
15:45:01 <lykos> I've been working on understanding, not clarity.
15:45:06 <carter> good
15:45:11 <carter> i'm bad at doing just one at a time
15:45:12 <lykos> and doing it all over ssh using nano
15:45:16 <carter> it makes me quite slow
15:45:18 <c_wraith> tomejaguar: the simplest cases for DataKinds are when you want to restrict a type variable.  Like what Repa does with many different representations that are reflected in the type.  The set of representations the library knows how to use is fixed - So you could promote an enumeration to use for that type variable.
15:45:18 <carter> WHY
15:45:27 <carter> c_wraith : repa is awesome research work
15:45:32 <lykos> for my server
15:45:37 <carter> i'm using a generalized REPA style api
15:45:43 <carter> for my own library writing
15:45:43 <c_wraith> tomejaguar: I'm not sure Repa actually *does* that.  But it's something it could do
15:45:50 <lykos> tomejaguar: that's cool about the database api
15:45:58 <carter> c_wraith: its an open universe deliberately
15:46:04 <tomejaguar> c_wraith: I have a lot to learn about these things ...
15:46:19 <carter> c_wraith: though i do have some type level parameters i'm making closed
15:46:25 <c_wraith> carter: that doesn't surprise me.  There are a lot of advantages to open representation
15:46:35 <lykos> carter: I honestly know nothing about monads :P I'm way over my head here. But for whatever reason, this is how I learn best
15:46:40 <carter> lykos awesome
15:46:42 <carter> keep it up
15:46:45 <tomejaguar> I agree
15:46:47 <carter> and you're doing it right
15:46:52 <tomejaguar> the first haskell code I wrote was rubbish
15:46:57 <tomejaguar> but it was a way to learn
15:47:14 <lykos> I learned from my dad, he's the head of the math/cs department at my college, and a total genius
15:47:17 <quchen> tomejaguar: I kept all of it. It's a fun thing to look around in my playground folder. Also very cringeworthy :-)
15:47:25 <lykos> taught half my programming classes, and he's a math phd :P
15:47:26 <carter> lykos awesome
15:47:43 <carter> university or earlier?
15:47:55 <c_wraith> Now, to see if my RULES-hackery actually worked...
15:47:55 <lykos> university
15:48:02 <tomejaguar> quchen: In some of the first Haskell code I wrote I was so confused that I could define a data constructor called "Maybe" and not have it clash with the type constructor :)
15:48:08 <carter> cool
15:48:19 <lykos> the first haskell program I wrote was for class
15:48:23 <lykos> my programing languages class
15:48:40 <lykos> and I ended up using it to make system calls to a win32 program I wrote
15:48:46 <carter> hehe
15:48:52 <lykos> although now I'm free from windows, been using linux all summer :)
15:49:18 <lykos> stayed up all night a few nights this week doing terrible, wonderful thing to my partition structure and hardrive i/o queue :P
15:49:29 <tomejaguar> lol
15:49:44 <tomejaguar> that's one thing worth staying up for
15:49:46 <c_wraith> According to ghc-core, my RULES did not fire.  Hmm.  Is there any wisdom for debugging this out there?
15:50:08 <lykos> hint: repartitioning your entire harddrive structure just so it looks better in gparted is not advisible. But I'd do it again.
15:50:31 <lykos> carter: can you explain more about the maybe/do notation?
15:50:35 <carter> was thatsure
15:50:36 <carter> sure
15:50:53 <carter> do you know the monad type class
15:50:54 <carter> it has
15:51:01 <carter> bind (ie >>=)
15:51:08 <carter> and return
15:51:13 <carter> right?
15:51:19 <carter> :t (>>=)
15:51:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:51:21 <tomejaguar> be careful carter, this guy is clever.  He's not going to take your answer and go away for several days to understand it.  He's just going to ask another one.
15:51:26 <carter> yeah
15:51:27 <carter> well
15:51:37 <carter> i can nerd snipe him quiet in a bit :)
15:51:45 <carter> lykos with me so far?
15:51:48 <lykos> I got ya
15:51:50 <carter> ok
15:51:52 <carter> so
15:51:55 <lykos> although I don't understand either of those functions
15:51:58 <carter> its ok
15:51:59 <Ghoul_> do-notation lets you evaluate monadic things and easily use them in calculations like an imperative language.
15:52:06 <lykos> but part of the Monad typeclass
15:52:08 <carter> Ghoul_ : shhh, let me xplain this one
15:52:09 <carter> :)
15:52:23 <Ghoul_> by doing stuff for you behind the scenes. It's sugar. /me throws carter out of the room
15:52:32 <carter> Ghoul_: you're not explaining it right
15:52:34 <carter> shh
15:52:36 <carter> :)
15:52:41 <carter> lemme finish first
15:52:44 <carter> then you can correct me
15:52:59 <lykos> carter: (got the XKCD refrence, btw)
15:53:07 <carter> oh?
15:53:09 <carter> nerd sniping?
15:53:10 <tomejaguar> Is there nothing lykos cannot get.
15:53:11 <lykos> carter: yep
15:53:24 <monochrom> don't explain at all. we have just settled: trying actual code is a better way to learn than reading all of your explanations
15:53:36 <lykos> carter: well, except calculating ohm of an infinite grid
15:53:56 <haasn> maybe we should introduce carter to a few of the edwardk libraries for which ‚ÄúHow do I use it?‚Äù is still an ongoing unanswered question
15:54:05 <carter> haasn: edwardk  explained them to me
15:54:08 <carter> its really cool
15:54:14 <lykos> carter: okay, so bind (>>=) and return are part of the monad tpyeclass
15:54:18 <carter> yes
15:54:18 <quchen> I'm with monochrom on this one. Explaining do notation to someone who doesn't know anything about Monad isn't very useful. "do is for imperative-style syntax" should be sufficient.
15:54:23 <edwardk> haasn: which ones?
15:54:32 <carter> quchen i'm epxlaining monads
15:54:33 <lykos> nah, I want more ;)
15:54:41 <carter> lykos: bind is "apply"
15:54:52 <Ghoul_> Have you heard about transformers!? Ooooh boy, let's talk about that
15:54:55 <carter> :t flip (>>=)
15:54:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:55:00 <haasn> edwardk: trifecta :D
15:55:04 <edwardk> =P
15:55:19 <Ghoul_> trifecta is a parsing library, no?
15:55:21 <lykos> :t 5
15:55:22 <lambdabot> Num a => a
15:55:22 <ion> ghoul: And category theory! And homotopy type theory!
15:55:28 <Ghoul_> But it gives awesome clang-like errors which I absolutely adore
15:55:38 <lykos> :t "I'm a lamda bot"
15:55:39 <lambdabot> [Char]
15:55:40 <edwardk> Ghoul_: yeah its parsec with clang-style diagnostics
15:55:43 <monochrom> on the other hand, explaining Monad is the best treatment for the pain of learning.
15:55:47 <haasn> the strength of a parsing library lies in the quality of its error messages
15:55:58 <monochrom> "you must vent it out on somebody"
15:56:03 <carter> lykos: you can do :t in ghci too
15:56:05 <quchen> While we're talking about fancy packages, does anyone remember the name of the one with the 3-line type signatures (in HTML, mind you)?
15:56:09 <S_J> quchen: what does (,,) stand for? And the format is just :key:actual_key:value:actual_value:endkeyvalue: and then continues like that with neyx key
15:56:19 <haasn> quchen: lens, clearly
15:56:25 <Ghoul_> quchen: I know what you're talking about
15:56:26 <haasn> they're a bit more general than HTML, though
15:56:29 <Ghoul_> but It's coming too my slow.
15:56:30 <lykos> carter: so what do you mean, apply?
15:56:36 <quchen> > (,,) 1 "hello" 2.3 --  S_J: Triple constructor.
15:56:37 <lambdabot>   (1,"hello",2.3)
15:56:42 <Ghoul_> *to me
15:56:55 <carter> :t \f val -> f val
15:56:56 <lambdabot> (t1 -> t) -> t1 -> t
15:56:59 <ion> @type undefined :: (,,) Integer String Double  -- On type level as well
15:57:00 <lambdabot> (Integer, String, Double)
15:57:00 <lykos> > [1..10]
15:57:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:57:05 <lykos> this is rather cool
15:57:06 <haasn> carter: = id
15:57:16 <quchen> S_J: And what's the data structure you want to create? Map ActualKey ActualValue?
15:57:25 <carter> :t id
15:57:26 <lambdabot> a -> a
15:57:29 <carter> not quite :)
15:57:40 <lykos> >let ninja = "behind you"
15:57:42 <carter> well
15:57:46 <S_J> quchen: yes
15:57:47 <carter> you can use id for apply
15:57:55 <carter> and it works
15:57:58 <lykos> >"watch out " : ninja
15:58:00 <carter> but thats not what i'm illustrating
15:58:09 <haasn> carter: (\f val -> f val) x y = id x y
15:58:11 <quchen> S_J: Well, parse it to a list of (Key, Value) pairs, then make a Map out of that
15:58:11 <carter> yes
15:58:11 <haasn> oh
15:58:17 <haasn> you're illustrating something
15:58:19 <haasn> carry on :)
15:58:25 <carter> i'm point out
15:58:27 <carter> the bind
15:58:29 <carter> *that bind
15:58:30 <edwardk> i should do some kind of lens-aeson style xml dom manipulation lib, but i can't bring myself to care about xml
15:58:35 <carter> can be read as
15:58:38 <ReinH> haasn: stand back, I'm going to try pedagogy
15:58:43 <lykos> okay, so bind, i.e. (>>=) means apply?
15:58:44 <quchen> S_J: I wouldn't let Parsec handle the Map part
15:58:47 <carter> yes
15:58:49 <carter> as in
15:58:51 <sipa> :t ap
15:58:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:58:56 <carter> "evalue a monadic expression to a value"
15:58:59 <haasn> let's all shout seemingly helpful things at the same time
15:59:12 <carter> and apply a function (t-> M b)
15:59:13 <lykos> (haasn: hehe)
15:59:13 <quchen> haasn: BOOL HAS THREE VALUES
15:59:15 <carter> to the evaluated value
15:59:21 <Ghoul_> someone should dig into making a pure haskell AES implementation because I've found none that don't just foreign import C.
15:59:27 <S_J> quchen: ok but what would parseRest do? I mean it is the same again and agai, i dotn get the loop part
15:59:29 <ReinH> haasn: at least I'm shoulding obviosly unhelpful things?
15:59:31 <lykos> can you give a more concrete example?
15:59:39 <carter> Ghoul_: better to just use the intel instruction
15:59:44 <ReinH> *shouting
15:59:45 <Ghoul_> except if you're on amd
15:59:51 <quchen> S_J: parseRest isn't a good idea to use, I just wrote that because you wanted to have "the rest of the input somewhere".
15:59:56 <carter> well, then you should just use the C version :)
15:59:58 <carter> for now
15:59:59 <haasn> edwardk: make a lens for xml <-> json
16:00:05 <haasn> edwardk: use the power of composition
16:00:18 <quchen> S_J: You should parse Input ---> [(Key, Value)], and then convert that list to a Map.
16:00:23 <monochrom> edwardk: make a lens-based AES lib :)
16:00:29 <carter> that'd be slow
16:00:39 <carter> really bad idea
16:00:40 <S_J> quchen: yes
16:00:42 <ReinH> haasn: We need an Iso for xml <-> json
16:00:47 <carter> Ghoul_: you should write an aes implemention in Cmm :)
16:00:54 <ReinH> then you can do anything you want ;)
16:01:10 <haasn> ReinH: that's what I'm saying!
16:01:17 <monochrom> I'll also bug copumpkin to write AES in Agda :)
16:01:25 <S_J> quchen: but i dont get how to continue when i have parsed one field. parseRest, how do I replace it?
16:01:26 <ReinH> if only they were actually isomorphic...
16:01:39 <ReinH> I guess you can define some JSON representation of XML as an isomorphism
16:01:39 <carter> lykos: do
16:01:48 <monochrom> copumpkin: make a lens-based AES lib in Agda! :)
16:01:50 <haasn> ReinH: I guess you could do a prism?
16:01:53 <ReinH> but there isn't an obviously correct one
16:01:56 <quchen> S_J: Parsec has combinators for parsing the same thing multiple times, see http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-Parsec-Combinator.html
16:02:11 <haasn> I know next to nothing about JSON and even less about XML, but I guess json -> xml should be doable
16:02:13 <quchen> S_J: All of those "endBy" and "manyTill" functions apply parsers repeatedly and gather the results
16:02:16 <Ghoul_> carter: funny you say that. Not quite cmm, but I was looking at the primops the other day for vectorization and tried to convert that very very fast vectored asm into haskell primops (but apparently 7.6.3 doesn't have them)
16:02:16 <ReinH> haasn: I mean, there isn't a "canonical" isomorphism between the two
16:02:22 <ReinH> but you could probably define your own
16:02:26 <haasn> yeah
16:02:29 <Ghoul_> I'd trust llvm to generate near the same code if the primops are rolled carefully
16:02:34 <haasn> isn't actual XML like really complicated and stuff
16:02:37 <haasn> with schemas and whatnot
16:02:52 <ion> Parsing the same thing multiple times? Control.Applicative.{many,some}, Control.Monad.replicateM
16:03:04 <ReinH> haasn: yeah and things like UTF16 keys with very not simple validity rules iirc
16:03:04 <S_J> quchen: but how do I acumulate those into one datastructure? One [(key,val)]
16:03:12 <xplat> haasn: schemas are complicated, but they don't make the xml itself any more complicated than it already is
16:03:16 <carter> Ghoul_ yup, doesn't have them
16:03:20 <lykos> carter: so how's do work?
16:03:27 <Ghoul_> will HEAD have them?
16:03:31 <carter> Ghoul_ does have them
16:03:32 <carter> already
16:03:34 <carter> for a while
16:03:42 <carter> Ghoul_: but only for llvm :)
16:03:52 <carter> so you're shit out of luck, unless you solved your llvm problem
16:03:57 <Ghoul_> I found a solution!
16:04:06 <Ghoul_> In fact, I should bother someone about it
16:04:07 <carter> lykos: first you must understand bind and return :)
16:04:12 <carter> Ghoul_ what was the problem
16:04:13 <Ghoul_> the windows ghc build doesn't have something configured right
16:04:18 <carter> Ghoul_ oh?
16:04:25 <ReinH> haasn: iirc libxml (used to?) store the validity rules as 8kb bitmaps or something
16:04:26 <Ghoul_> I had to do this in mingw to make ghc work with llvm on path;
16:04:27 <carter> or was your machine configured weird?
16:04:36 <Ghoul_> No, it's ghcs fault, my friend has the same problem
16:04:39 <carter> ok
16:04:44 <carter> Ghoul_ : open a trac ticket
16:04:46 <carter> documenting it
16:04:50 <carter> not "bug someone"
16:04:56 <carter> open a trac ticket
16:04:57 <lykos> lykos: okay, so bind applies a moadix expression to a value
16:05:05 <techtangents> Hi, all. Does anyone know this function:
16:05:06 <techtangents> (a -> c) -> (b -> d) -> (a, b) -> (c, d)
16:05:16 <carter> lykos jah
16:05:26 <carter> and gives you a new monadic expression
16:05:37 <carter> "expression" is a lie, it can be a concrete value
16:05:39 <carter> but for now
16:05:51 <tomejaguar> techtangents: \f g -> first f *** second g
16:05:54 <bscarlet> techtangents: look in Control.Arrow
16:06:10 <lykos> cater: and bind's operator is (">>="), infix binary?
16:06:10 <techtangents> I thought it might have been *** or &&& but didn't know how to use it. Thanks!
16:06:24 <carter> yes
16:06:25 <techtangents> #haskell kicks ass.
16:06:53 <tomejaguar> actually I was wroing
16:07:00 <tomejaguar> it's first f >>> second g
16:07:01 <bscarlet> :t (***)
16:07:02 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:07:06 <lykos> okay, takes a monadic expression and gives another one
16:07:13 <tomejaguar> but anyway, it's a Control.Arrow kind of thing
16:07:20 <tomejaguar> and now I should really go to bed
16:07:42 <ReinH> techtangents: I would probably just use f g (x,y) = (f x, g y)
16:07:43 <tomejaguar> err it's exactly ***
16:07:44 <hpaste> quchen pasted ‚Äú@S_J Parsec outline‚Äù at http://lpaste.net/91531
16:07:48 <lykos> carter: but what exactly is a monadic expression?
16:07:51 <tomejaguar> clearly going to bed would be a good idea right about now ...
16:07:55 <carter> depends on the monad instance
16:08:02 <Ghoul_> carter: can you gist your ghc --info ?
16:08:06 <quchen> S_J: That's a very crude draft of what the result would look like.
16:08:08 <carter> Ghoul_ i'm on a mc
16:08:09 <carter> mac
16:08:25 <Ghoul_> ah. The culprit is that my ghc --info reads "llvm opt command: ''" and such as empty
16:08:26 <carter> Ghoul_ can you gist yours?
16:08:30 <carter> ohh
16:08:32 <carter> thats editable
16:08:34 <ReinH> techtangents: huh, fgl has that as the >< operator http://hackage.haskell.org/package/fgl-5.4.2.4
16:08:40 <carter> ohhh
16:08:43 <carter> you can fix that
16:08:49 <Ghoul_> my solution was this: alias ghc-llvm="ghc -pgmlo opt -pgmlc llc -fllvm"
16:08:51 <Ghoul_> and it fixed
16:08:55 <snja> Would it be easy to rewrite in Haskell a GUI programmed in Qt5 and C++?
16:09:01 <carter> Ghoul_ theres a more systematic way
16:09:02 <carter> hangon a sec
16:09:15 * hackagebot stemmer 0.5 - Haskell bindings to the Snowball stemming library.  http://hackage.haskell.org/package/stemmer-0.5 (BenGamari)
16:09:25 <Ghoul_> Seems that the ghc in the haskell platform was shipped that way or something
16:09:29 <Ghoul_> but it wasn't like that in 7.4
16:09:35 <carter> Ghoul_: STOP
16:09:37 <carter> i have a solution
16:09:39 <carter> thats better
16:09:51 <carter> though its worth reproting this
16:09:55 <haasn> techtangents: it's bimap!
16:09:58 <carter> did you use haskell  platform or ghc hq build?
16:10:06 <carter> Ghoul_: haskell platform or ghc hq?
16:10:48 <lykos> carter: let me know when you're able to explain monads more? No rush at all, I'm gonna go clean up my code a bit :)
16:11:00 <carter> i'm the wrong person to expain monads
16:11:02 <Ghoul_> Both the 32-bit from HP and the 64-bit from ghc hq seem to have the problem
16:11:06 <carter> ok
16:11:13 <carter> Ghoul_: worth reporting to both projects
16:11:13 * haasn likes http://www.haskell.org/haskellwiki/Typeclassopedia 's section on Monad
16:11:14 <carter> as tickets
16:11:19 <carter> ooo
16:11:22 <carter> good call haasn
16:11:29 <carter> i wanna focus on my numerical codes again :)
16:11:39 <Ghoul_> should I be making a ghc bug, or trying the HP tracker instead?
16:11:48 <carter> Ghoul_ both
16:11:50 <carter> if both lack it
16:11:59 <carter> Ghoul_: heres a work around though
16:12:00 <carter> thats better
16:12:18 <carter> Ghoul_ : 1) install cabal / cabal-install HEAD
16:12:47 <ReinH> lykos: the best way to learn monads is to try to use them to do stuff
16:13:09 <lykos> haasn: I like the Euclid quote ;)
16:13:57 <lykos> ReinH: any suggestions what to start with?
16:14:08 <ReinH> lykos: maybe write some simple command line tools
16:14:10 <haasn> IO?
16:14:29 <ReinH> lykos: like how would you write `wc -l` in Haskell?
16:14:32 <carter> Ghoul_: then you can add the following to your cabal config
16:14:33 <carter> https://gist.github.com/cartazio/5953772
16:14:40 <carter> and put in your own custom ghc options
16:14:40 <haasn> ReinH: I think having a theoretical understanding is a prerequisite for that, because it's easy to look at do-sugar'd code and get misconceptions about how they operate
16:14:47 <carter> for any cabal related happenings
16:14:58 <haasn> ReinH: especially if the reader is familiar with other languages
16:15:02 <carter> that said, do notation does compile well :)
16:15:11 <ReinH> haasn: imo there isn't a much better way to figure out do notation than to go from do { x <- getArgs; execute x} to getArgs >>= execute (and vice versa)
16:15:12 <carter> i have a cute StrictIdentity monad trick :)
16:15:38 <Ghoul_> oh cool
16:15:38 <haasn> ReinH: I thought this was about monads, not do notation per se
16:15:44 <carter> Ghoul_ yeah!
16:15:50 <carter> i was really really really happy
16:15:54 <carter> about that feature in head
16:15:55 <ReinH> haasn: right, I'm responding to your "look at do-sugar'd code and get misconceptions" :)
16:16:06 <lykos> haasn: ReinH: that's the main thing, I want to learn it right. I saw an article called "do notation considered harmful recently" and want to learn monads the right way, not just as some "imperative feature" in haskell
16:16:27 <carter> being able to set all the ghc options  once and for all + sandboxing = christmas, but a gift that i can use every day
16:16:32 <ReinH> lykos: that's good. I would suggest learning it by writing things in do notation and then transforming them into non-sugared versions manually
16:16:37 <ReinH> and vice versa
16:16:41 <haasn> do notation is a great tool and it makes certain styles of code a lot simpler
16:16:54 <ReinH> lykos: once you actually do the process yourself the do sugar becomes less magincal
16:16:59 <haasn> I certainly wouldn't call it harmful
16:17:09 <carter> its lots of nested lambdas
16:17:12 <lykos> ReinH: carter: I'm making a website with snap. If either of you have time, would you care to look at the code I have (a lot of it was autogenerated) and help explain how some things work?
16:17:23 <jmcarthur> i think do notation is slightly harmful for beginners, but beneficial to though who understand it
16:17:28 <carter> jmcarthur true
16:17:34 <jmcarthur> *those who
16:17:49 <elliott> I think do notation is good for beginners. just treat it as that thing that creates IO actions.
16:17:58 <hpaste> lykos pasted ‚Äúcode‚Äù at http://lpaste.net/91532
16:18:02 <sipa> do notation is so convenient, that it's seducing to use for things that aren't actually monads
16:18:07 <elliott> you can explain all that without any reference to what it desugars to or monads, and it introduces the concept of "actions as values" nicely.
16:18:25 <applicativ> snja: there arent usable qt bindings I dont think if thats what you were wondering
16:18:26 <elliott> in comparison, writing IO programs with (>>=) and return is... not beginner-friendly, IMO.
16:18:28 <jmcarthur> elliott: encouraging that kind of thinking is precisely why i think it's harmful for beginners
16:18:28 <lykos> can everything written with do be written without it?
16:18:32 <ReinH> elliott: for me the desugaring was necessary for understanding
16:18:46 <jmcarthur> elliott: i think it is more beneficial to make it visible that IO actions are just normal values composed in fairly normal ways
16:18:48 <ReinH> lykos: yes
16:19:04 <jmcarthur> elliott: do notation makes it look like "statements"
16:19:13 <ReinH> lykos: all do notation is transformed (desugared) by a very small set of rules.
16:19:18 <lykos> ReinH: could you maybe "de-sugar" my echoHandler function?
16:19:22 <elliott> jmcarthur: of course, normal values.
16:19:31 <ReinH> lykos: link?
16:19:37 <elliott> jmcarthur: but I think it's OK for do notation w/ IO to be treat as magical.
16:19:40 <elliott> after all, getChar is magical.
16:19:41 <lykos> http://lpaste.net/91532
16:20:01 <Clint> @undo do param <- getParam "echoparam"; maybe (writeBS "must specify fact/param in URL") writeBS param
16:20:02 <lambdabot> getParam "echoparam" >>= \ param -> maybe (writeBS "must specify fact/param in URL") writeBS param
16:20:10 <jmcarthur> getChar is no more special than any other value
16:20:19 <jmcarthur> it's just not very well specified
16:20:25 <techtangents> ReinH: Trying to pointfree for practice.
16:20:36 <elliott> shrug
16:20:49 <techtangents> Actually, I think I need:
16:20:50 <techtangents> (a -> x -> a') -> (b -> x -> b') -> (a, b) -> x -> (a', b')
16:21:15 <jmcarthur> @@ @pl @djinn (a -> x -> a') -> (b -> x -> b') -> (a, b) -> x -> (a', b')
16:21:18 <lambdabot>  f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . liftM2 (,)) .)
16:21:18 <lambdabot>  optimization suspended, use @pl-resume to continue.
16:21:26 <jmcarthur> okay don't do that
16:21:30 <techtangents> :)
16:21:40 <ReinH> techtangents: ah, fair play then
16:22:17 <jmcarthur> :t liftA2 (***)
16:22:18 <lambdabot> (Applicative f, Arrow a) => f (a b c) -> f (a b' c') -> f (a (b, b') (c, c'))
16:22:21 <pharaun> is there a good way to do a no-op function other than undefined?
16:22:29 <lykos> Could someone express [getParam "echoparam" >>= \ param -> maybe (writeBS "must specify fact/param in URL") writeBS param ] as spoken language?
16:22:41 <lykos> I find that's a good way to understand the logical structure
16:22:51 <Clint> pharaun: id?
16:23:03 <pharaun> Clint: yeah i did try that
16:23:08 <hpc> return ()?
16:23:13 <pharaun> indexList :: (ArrowXml a) => a XmlTree (String, (String, String))
16:23:40 <pharaun> when i did id it just returned a xmlTree which does not match the type
16:23:53 <Clint> so by no-op you mean what
16:23:55 <applicativ> pharaun: goo x | blah x = Just whatever; otherwise = Nothing
16:24:00 <pharaun> this is for records, a couple of fields are no-op for certain records
16:24:07 <pharaun> i think i may need to restructure the records somehow
16:24:11 <Ghoul_> carter: turns out there is a ticket for it, so I've put up /a/ solution http://ghc.haskell.org/trac/ghc/ticket/7143#comment:8
16:24:14 <applicativ> o
16:24:15 * hackagebot hsprocess 0.3 - The Haskell Stream Processor command line utility  http://hackage.haskell.org/package/hsprocess-0.3 (MarioPastorelli)
16:24:26 <Ghoul_> hopefully someone will see that and push a fix before we get the next haskell platform D:
16:24:31 <carter> Ghoul_ thats not a solution, thats a workaround
16:24:55 <pharaun> applicativ: yeah if i was defining it i would do those :) but this is records, i guess i could just do a root record with all of the func defined to undefined
16:25:03 <carter> Ghoul_: you can config your ghc to have those flags
16:25:13 <carter> Ghoul_: where is your ghc installed
16:25:21 <pharaun> then fill what is needed but it does feel non-safe so i think i need to figure out a better way to represent this without having "no-op" functions hanging around for certain record types
16:25:24 <Ghoul_> But then I have to compile everything haskell on my computer with llvm
16:25:30 <ReinH> lykos: what is the type of getParam?
16:25:42 <carter> Ghoul_ NOPE
16:25:44 <carter> thats false
16:25:50 <carter> it just means ghc knows the names
16:26:00 <Ghoul_> Oh, actually, that's true.
16:26:05 <Ghoul_> I can drop the -fllvm
16:26:07 <lykos> ReinH: getParam :: MonadSnap m => ByteString -> m (Maybe ByteString)
16:26:07 <carter> you have to explicitly use -fllvm to make things llvm
16:26:08 <carter> yup
16:26:10 <pharaun> i guess undefined will do for now, its... non-ideal :)
16:26:14 <carter> Ghoul_ where is your ghc installe
16:26:32 <Ghoul_> haskell platform default, and the 64-bit one in Program Files
16:26:38 <carter> ok
16:26:40 <carter> so
16:26:44 <carter> WHERE Is it installed
16:26:45 <carter> look there
16:26:48 <carter> and look for a config file
16:26:49 <carter> and open it
16:27:01 <dobblego> would anyone by any chance know where the source code is to Simon Marlow (Parallel & Concurrent Haskell: Server Applications) http://community.haskell.org/~simonmar/slides/cadarache2012/5%20-%20server%20apps.pdf
16:27:15 <carter> http://hackage.haskell.org/package/parconc-examples-0.3 ?
16:28:01 <Ghoul_> is it "settings" ?
16:28:16 <carter> yes
16:28:17 <carter> that one
16:28:22 <carter> sorry
16:28:30 <carter> you can add the names there
16:30:23 <ReinH> lykos: and what is the type of: \ param -> maybe (writeBS "must specify fact/param in URL") writeBS param
16:31:44 <Ghoul_> aha carter I just edited my ticket, I didnt realize you added the other fix
16:31:51 <Ghoul_> I'll un-edit it and confirm it works (it does)
16:31:57 <carter> Ghoul_ stop doing things :)
16:32:15 <carter> reply to my remark
16:32:20 <carter> edits don't appear on the ticket emailing list
16:33:14 <lykos> ReinH: I'm not quite sure. What does the "\" mean? This is my full code:
16:33:27 <lykos> http://lpaste.net/91532
16:33:37 <Ghoul_> imho they should ship HP with a working llvm binary but that'll never happen.
16:33:57 <Ghoul_> sec, downloading 2.9, the one everyone else is using, and just confirming that works. I've been using 3.4svn
16:34:15 <carter> Ghoul_ nope
16:34:19 <carter> theres reasons why thats daft for now
16:34:23 <carter> 2.9?
16:34:29 <carter> why 2.9?
16:34:34 <ReinH> lykos: http://www.haskell.org/haskellwiki/Anonymous_function
16:34:34 <carter> you hsould use 3.1
16:34:39 <Ghoul_> The others dont seem to work on my system
16:34:42 <Ghoul_> they just crash
16:34:43 <carter> oh
16:34:43 <carter> ok
16:34:46 <carter> well
16:34:46 <lykos> ah, of course
16:34:51 <Ghoul_> not sure why, but happens if you use the rubenv mingw environments
16:34:55 <Ghoul_> which are the 64-bit ones
16:34:58 <carter> rubenv?
16:35:11 <carter> why are you using ruby to manage the path?
16:35:34 <Ghoul_> "rubenvb" sorry, is the name of the guy who does the builds
16:35:42 <carter> why are you using them?
16:35:47 <carter> is tht the "standard one"
16:35:51 <carter> or whats different?
16:36:03 <lykos> ReinH: Ah, of course. So do "de-sugaring" do notation involves lamda functions?
16:36:10 <Ghoul_> because he provides gcc 4.8 and friends in his mingw builds rather than the heavily outdated default one
16:36:15 <Ghoul_> lots of people use them
16:36:20 <ReinH> lykos: no, anonymous functions are just an easy way to present the function inline
16:36:26 <ReinH> lykos: without a let binding
16:36:42 <carter> shh
16:36:49 <carter> could you try the outdated one? :)
16:36:51 <carter> hehe
16:36:52 <lykos> ReinH, ah okay
16:36:58 <carter> might be the root of your problems
16:37:05 <lykos> did you see my source code?
16:37:14 <lykos> I don't understand the non-do notation
16:37:16 <carter> lykos: me?
16:37:17 <carter> or who?
16:37:19 <lykos> or the do notation for that matter
16:37:24 <carter> (i'm too busy right now :) )
16:37:35 <lykos> I meant ReinH, you saw it before didn't you carter?
16:37:44 <carter> sure
16:37:46 <lykos> carter: it's fine, keep doing what you're doing :)
16:37:47 <carter> i think i did
16:37:57 <ReinH> lykos: what type do you get for that anonymous function when you ask ghci?
16:37:58 <carter> you'll be glad you said that in a few months
16:38:12 <Ghoul_> 2.9 works perfectly with the fix out of the box
16:38:15 <carter> i'm infamously distractable
16:38:16 <carter> cool
16:38:19 <carter> Ghoul_ report that! :)
16:38:51 <lykos> <interactive>:1:27:
16:38:51 <lykos>     Couldn't match expected type `ByteString' with actual type `[Char]'
16:38:52 <lykos>     In the first argument of `writeBS', namely
16:38:52 <lykos>       `"must specify fact/param in URL"'
16:38:52 <lykos>     In the first argument of `maybe', namely
16:38:52 <lykos>       `(writeBS "must specify fact/param in URL")'
16:38:54 <lykos>     In the expression:
16:38:56 <lykos>       maybe (writeBS "must specify fact/param in URL") writeBS param
16:39:05 <ReinH> lykos: please don't paste multiple lines :)
16:39:05 <elliott> please don't paste long things
16:39:13 <elliott> see topic for pastebin link
16:39:30 <ReinH> ah, it things the strings are [Char]
16:39:30 <lykos> ah, okay. I thought that was short enough to post, sorry :)
16:39:38 <ReinH> my bad
16:40:13 <ReinH> lykos: :set -XOverloadedStrings and try again :)
16:40:50 * carter Ghoul_ confirm the fix works 
16:41:03 <carter> ie report that as a new comment on the ticket
16:41:10 <Ghoul_> carter: sec, I'm about tooo
16:41:23 <lykos> MonadSnap m => Maybe ByteString -> m ()
16:41:59 <ReinH> lykos: and what's the type of getParam "echoparam" ?
16:42:03 <lykos> (so the XOVerLoaded Strings overloads the parser to recognize string literals as strings or bytestrings?)
16:42:13 <Ghoul_> ghc64 gives heaps of assembler errors I've never seen before
16:42:29 <ReinH> lykos: yes, or Text
16:42:33 <carter> for what
16:42:37 <Ghoul_> probably signifying 2.9 is reaching the end of its lifetime
16:42:47 <Ghoul_> oh, I started noticing them when I swapped to llvm 2.9
16:42:48 <lykos> MonadSnap m => m (Maybe ByteString)
16:43:02 <carter> so remark it finds GHC 2.9, but 2.9 has others problem
16:43:07 <carter> Ghoul_ use llvm 3.1
16:43:14 <carter> but note that this solves the cant find llvm bit
16:43:32 <ReinH> lykos: and the monad here is Snap
16:43:38 <lykos> yep
16:44:11 <lykos> ReinH: thanks for your help. I pretty much completely new to monads, but this helps
16:45:41 <carter> great
16:45:53 <carter> 3.4 doesn't work with 7.6‚Ä¶. does it?
16:46:01 <ReinH> lykos: so let's plug all of those types in
16:46:14 <Ghoul_> carter: it does!
16:46:17 <carter> huh
16:46:29 <Ghoul_> it gives a warning it's much newer than expected, but things build fine
16:46:45 <carter> ohhh yeah, the only issue with 3.4 or 3.3 is you don't want to build ghc -fllvm way
16:48:19 <ReinH> lykos: https://gist.github.com/anonymous/f1bfb2710b8cb5bd8ad2
16:48:45 <ReinH> lykos: so... getParam takes a ByteString and returns a Snap (Maybe ByteString)
16:49:04 <piron> :t \f g -> flip f *** flip g
16:49:05 <lambdabot> (a -> b -> c) -> (a1 -> b1 -> c1) -> (b, b1) -> (a -> c, a1 -> c1)
16:49:06 <ReinH> (well it returns a MonadSnap m => m (Maybe ByteString) but let's simplify
16:49:23 <lykos> okay
16:49:24 <piron> :t \f g x -> flip f x *** flip g x
16:49:25 <lambdabot> (a -> b -> c) -> (a1 -> b -> c1) -> b -> (a, a1) -> (c, c1)
16:49:37 <ReinH> lykos: now you have that anonymous function \param -> maybe ...
16:49:41 <piron> ?pl \f g x -> flip f x *** flip g x
16:49:41 <lambdabot> (. flip) . ap . ((***) .) . flip
16:49:49 <ReinH> that takes a Maybe ByteString and gives a Snap ()
16:50:09 <ReinH> lykos: which means that it does some action inside the Snap monad and then returns void
16:50:21 <ReinH> in the IO monad that action might be putStr, so something similar for Snap
16:50:31 <ReinH> lykos: but the problem is
16:50:56 <ReinH> you have a Snap (Maybe ByteString) but you need param to be a Maybe ByteString
16:51:06 <ReinH> so that's where >>= comes in
16:51:09 <ReinH> :t >>=
16:51:09 <lambdabot> parse error on input `>>='
16:51:13 <ReinH> sorry
16:51:15 <ReinH> :t (>>=)
16:51:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:51:41 <ReinH> you have a Snap (Maybe ByteString) and a function from Maybe ByteString -> Snap (), so you need to use >>= to connect them
16:51:57 <ReinH> to get the Maybe ByteString "out of" the Snap monad and pass it to the anonymous function as param
16:52:03 <Ghoul_> hmm carter I still get these assembler errors using llvm 3.1
16:52:08 <ReinH> lykos: does that make sense?
16:52:08 <Ghoul_> http://pastie.org/private/uldsgn5ybpgb96pdfqpiq
16:52:10 <carter> Ghoul_ gist them
16:52:14 <carter> gist them
16:52:22 <carter> that other site you use is hard to use
16:52:36 <carter> gist.github.com
16:52:41 <Ghoul_> carter: https://gist.github.com/kvanberendonck/6152556
16:52:44 <carter> thanks
16:52:50 <lykos> ReinH: honestly I'm having a little difficulty following. I think the "Maybe"s are tripping me up a bit
16:53:00 <ReinH> lykos: ok, let's use a simpler example
16:53:01 <carter> Ghoul_ You need to try 3.2 or 3.1
16:53:05 <ReinH> :t getChar
16:53:06 <lambdabot> IO Char
16:53:10 <ReinH> :t putStr
16:53:11 <lambdabot> String -> IO ()
16:53:23 <ReinH> sorry
16:53:24 <Ghoul_> this is with 3.1
16:53:24 <piron> :t putChar
16:53:25 <lambdabot> Char -> IO ()
16:53:27 <Ghoul_> I should try 3.2?
16:53:27 <carter> ok
16:53:31 <ReinH> piron: yeah
16:53:32 <carter> sure....
16:53:36 <ReinH> or :t getLine
16:53:36 <carter> might be the same problem
16:53:38 <ReinH> anyway
16:53:47 <carter> or maybe its just an api change
16:53:54 <ReinH> lykos: getLine gives you an IO String, that is a String "inside" the IO monad
16:53:57 <carter> does it build  successfully
16:54:00 <carter> or just bail out?
16:54:01 <Ghoul_> I dont get it with 32-bit ghc
16:54:05 <carter> ok
16:54:07 <Ghoul_> no
16:54:09 <ReinH> lykos: but putStr wants the String itself, not the string "inside" the IO monad
16:54:14 <carter> ok
16:54:22 <carter> worth opening a new ticket on track
16:54:35 <ReinH> lykos: so >>= takes the String "out of" the IO monad and passes it to putStr
16:54:43 <carter> build failures with llvm on windows 64bit
16:54:45 <carter> or something
16:54:56 <carter> does the error happen with a hello world?
16:54:58 <ReinH> lykos: but the monad laws say that >>= must be used with a function that returns the value back into the monad
16:55:13 <ReinH> lykos: so putStr is String -> IO (), it can't just be String -> () or w/e
16:55:15 <ReinH> as that wouldn't typecheck
16:55:21 <piron> (Just the type of (>>=) says that, the monad laws are separate.)
16:55:27 <ReinH> piron: right sorry
16:55:35 <Ghoul_> carter: I'm compiling "main = print "Hello""
16:55:37 <lykos> Ah, and that's what allows for monads to keep state, right?
16:55:41 <Ghoul_> There's literally nothing in the file ;)
16:55:41 <carter> ok
16:55:48 <carter> great
16:55:49 <carter> just checking
16:55:57 <ReinH> lykos: so the type of >>= ensures that you start with something in a monad and end up with something else in a monad
16:56:06 <lykos> okay
16:56:15 <carter> jah
16:56:21 <carter> "cooties is a monad"
16:56:22 <lykos> what exactly does "in a monad" mean though? I'm following along in ghci
16:56:24 <ReinH> lykos: in this case you start with IO String and end with IO ()
16:56:32 <carter> :)
16:56:42 <ReinH> lykos: so "in a monad" is a very imprecise and wrong way to say
16:57:28 <ReinH> lykos: that you have some type and some structure that defines how to chain or sequence "operations" of that type
16:57:37 <ReinH> the structure is often thought of as "being around" the type
16:57:39 <ReinH> but strictly it isnot
16:58:01 <lykos> okay
16:58:14 <lykos> ReinH: I thought you started with a String, not an IO string? putStr takes a String, right?
16:58:14 <ReinH> so it's strictly wrong to say "a String in the IO monad", but people do it anyway :)
16:58:28 <ReinH> lykos: yes, but getLine gives an IO String
16:58:36 <lykos> so it's a string taken from the IO monad and returned back into it?
16:58:39 <ReinH> so you need some way to "get at" the string that's "inside" the IO monad
16:59:03 <piron> I find this discussion slightly disturbing.
16:59:06 <ReinH> and >>= is what lets you temporarily ignore the monad structure and just use the value
16:59:20 <ReinH> as long as you reapply the monad structure when you're done
16:59:24 <piron> You're not taking a String out of IO ever. You're teaching your function that knows how to consume a String a way to consume IO String's instead.
16:59:35 <ReinH> piron: that's a better way to say it
16:59:48 <ReinH> I guess I should go the other way from join
17:00:29 <ReinH> lykos: piron is right, you can't really "get at" the value, but >>= makes the function you provide work within the monad structure
17:00:41 <lykos> hmm.. I have an idea, I want to see if this would work
17:00:57 <lykos> lets say I have a function, lengthOf
17:01:05 <lykos> that simply is this:
17:01:25 <S_J> I can use ParSec.manyTill with Parsec.eof but not with my own parser. does a parswr has to return soemthing to be successful?
17:01:30 <lykos> lengthOf xs = length xs
17:01:51 <lykos> lengthOf :: String -> Int
17:02:13 <lykos> if I changed the type defintion as such:
17:02:34 <piron> S_J: Post some code, say what you do, what you expect to happen, and what happens instead.
17:02:39 <Modius_> A: is it idiomatic to split a large haskell project into sub-libraries (with their own cabal files) that don't go on hackage, B: should those .cabal files be in subdirectories of the project, and C: is there a project I could look at somewhere that's doing that?
17:03:23 <lykos> lengthOf :: IO xs => xs -> Int, is that kind of right?
17:03:45 <mauke> lykos: no, that makes no sense
17:03:47 <ion> IO is not a class
17:03:48 <lykos> (I'm not quite sure how to do this all in GHCI, as opposed to a compiled/interpreted file)
17:03:48 <mauke> IO is not a class
17:03:51 <piron> It is idiomatic to split a large project into sub-libraries with their own cabal files. It is not idiomatic to keep those off of Hackage. gtk2hs is an example of a project with a repository that tracks multiple packages.
17:03:54 <lykos> ah, okay
17:04:41 <ion> length :: [a] -> Int; fmap length :: IO [a] -> IO Int
17:04:47 <lykos> how could I go about "teaching your function that knows how to consume a String a way to consume IO String's instead." like you said, piron?
17:04:49 <Ghoul_> carter: I made a ticket about it
17:05:04 <ReinH> lykos: you use >>= to do that
17:05:09 <mauke> or fmap
17:05:09 <piron> lykos: The (>>=) and fmap functions teach.
17:05:17 <ReinH> lykos: (>>== putStr) is like putStr but it takes an IO String instead of a String
17:05:27 <ReinH> s/==/=
17:05:34 <carter> Ghoul_: great ticket
17:05:34 <carter> thanks
17:05:43 <piron> (=<<) :: (a -> IO b) -> (IO a -> IO b)
17:05:49 <piron> fmap :: (a -> b) -> (IO a -> IO b)
17:06:02 <mauke> upgrading functions, fuck yeah
17:06:11 <hpaste> S_J pasted ‚ÄúParsec manyTill ‚Äù at http://lpaste.net/91533
17:06:21 <S_J> ^^ help please
17:06:48 <lykos> okay. This is a lot of information, but I like it.
17:06:58 <ReinH> lykos: let's call your \param -> maybe ... function f
17:07:13 <ReinH> f :: Maybe ByteString -> Snap ()
17:07:29 <ReinH> but you have a Snap (Maybe ByteString), not a Maybe ByteString
17:07:40 <piron> S_J: Factor your grammar so that not both parseKey and storeEnd can begin with a :.
17:07:42 <ReinH> lykos: so (>>= f) is Snap (Maybe ByteString) -> Snap ()
17:08:31 <lykos> Aha!
17:08:33 <lykos> I get it
17:08:37 <piron> S_J: There may be other problems, too; I stopped after finding one.
17:08:47 <lykos> in this case, echoparam is an internal state in the Snap() monad
17:08:55 <ReinH> lykos: (>>= f) transforms f into a function that expects an m (Maybe ByteString) rather than just a Maybe ByteString
17:09:01 <lykos> whos state was defined by the "passed" parameter earlier
17:09:03 <ReinH> and m in this case is your Snap monad
17:09:16 <ReinH> lykos: yes
17:09:21 <lykos> where m is an arbitrary monad type
17:09:36 <piron> Actually, no.
17:09:43 <lykos> well, Snap() in this case
17:09:53 <lykos> because I'm dealing with the snap monad
17:09:55 <ion> Not Snap (), just Snap
17:10:10 <S_J> piron: ty that works. but it should be possible to use ':' for the storestart and storeend as well right? mustbe. anyway easier not to...
17:10:11 <lykos> what's the () mean anyhow?
17:10:21 <ReinH> lykos: Snap a is the monad: it takes an a and puts it in the Snap context
17:10:22 <piron> ?src ()
17:10:22 <lambdabot> data () = ()
17:10:38 <ion> reinh: No, Snap is the monad.
17:10:42 <piron> Snap, together with its implementation of (>>=) and return, is the monad.
17:10:43 <ReinH> ion: ok
17:11:06 <piron> lykos: It's a zero-tuple. ;-)
17:11:18 <piron> > (1,2,3,4)
17:11:19 <lambdabot>   (1,2,3,4)
17:11:20 <piron> > (1,2,3)
17:11:21 <lambdabot>   (1,2,3)
17:11:23 <piron> > (1,2)
17:11:24 <lambdabot>   (1,2)
17:11:25 <piron> > (1)
17:11:26 <lambdabot>   1
17:11:27 <piron> > ()
17:11:28 <lambdabot>   ()
17:11:33 <lykos> okay
17:11:39 <piron> Okay, (1) is a bit different from the rest. But you get the idea.
17:11:41 <ReinH> piron: one of these things is not like the other :p
17:11:55 <piron> yes
17:11:55 <lykos> I get it ;)
17:12:04 <lykos> Snap a is the monad
17:12:13 <lykos> otherwise refered to as Snap ()
17:12:16 <lykos> right?
17:12:25 <piron> @@ Luckily, we have @hackage OneTuple to fill the gap of (1). :)
17:12:25 <lambdabot>  Luckily, we have http://hackage.haskell.org/package/OneTuple to fill the gap of (1). :)
17:12:45 <piron> lykos: Snap, together with its implementation of (>>=) and return, is the monad.
17:12:52 <ReinH> lykos: no, I messed you up there
17:12:57 <ReinH> my bad
17:13:08 <lykos> so what is Snap?
17:13:17 <ReinH> a monad *rimshot*
17:13:19 <ion> reinh: If you think of the types as (a,b,c) = a √ó b √ó c, (a,b) = a √ó b, a = a, () = 1, it *is* like the others. :-P
17:13:22 <piron> It is a type (constructor) defined in a library.
17:13:28 <piron> You can look up its source, if you like.
17:13:32 <ReinH> ion: I will allow it ;)
17:14:57 <lykos> okay, so Snap, together with it's implementation of (>>=) and return is the monad?
17:14:58 <piron> lykos: Q: What is Snap? A: http://hackage.haskell.org/packages/archive/snap-core/0.9.4.0/doc/html/src/Snap-Internal-Types.html#Snap
17:15:16 <piron> Hey! That sentence looks pretty precise. I like it.
17:15:17 <piron> :P
17:16:01 <nooodl> what is OneTuple useful for?
17:16:10 <piron> nooodl: consistency
17:16:22 <piron> nooodl: It adds a bottom in a similar way to the other tuple types.
17:16:24 <lykos> So Snap is some sort of datatype, given the monad status by it's >>= and return implementations?
17:16:28 <lykos> :t (>>=)
17:16:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:16:33 <piron> lykos: Right!
17:16:36 <lykos> :t (<<=)
17:16:37 <lambdabot>     Not in scope: `<<='
17:16:37 <lambdabot>     Perhaps you meant one of these:
17:16:37 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
17:16:43 <piron> :t (=<<)
17:16:43 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:16:50 <piron> ?src (=<<)
17:16:50 <lambdabot> f =<< x = x >>= f
17:16:59 <lykos> is that part of what makes snap a Monad?
17:17:03 <lykos> (=<<)
17:17:07 <lykos> :t Snap
17:17:08 <lambdabot> Not in scope: data constructor `Snap'
17:17:08 <piron> no
17:17:12 <piron> Not really.
17:17:12 <lykos> ah
17:17:25 <lykos> :t Snap ()
17:17:26 <lambdabot> Not in scope: data constructor `Snap'
17:17:29 <lykos> :t Snap a
17:17:30 <lambdabot> Not in scope: data constructor `Snap'
17:17:35 <lykos> :t IO
17:17:36 <lambdabot>     Not in scope: data constructor `IO'
17:17:36 <lambdabot>     Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:17:44 <piron> :k IO
17:17:44 <lambdabot> * -> *
17:17:50 <lykos> O.o
17:17:50 <ion> :t undefined :: IO a
17:17:51 <lambdabot> IO a
17:18:03 <piron> (Snap also has kind * -> *.)
17:18:06 <ion> ‚Äú:t‚Äù takes a value, IO is a type-level thing.
17:18:07 <lykos> :k Snap
17:18:08 <lambdabot> Not in scope: type constructor or class `Snap'
17:18:18 <lykos> okay
17:18:24 <piron> :k IO Int
17:18:24 <lambdabot> *
17:18:29 <lykos> what is :k?
17:18:31 <mauke> kind
17:18:33 <piron> :k Maybe
17:18:33 <lambdabot> * -> *
17:18:46 <mauke> :k Int ()
17:18:47 <lambdabot>     `Int' is applied to too many type arguments
17:18:47 <lambdabot>     In a type in a GHCi command: Int ()
17:18:48 <piron> lykos: terms are classified by types; types are classified by kinds
17:18:55 <lykos> I thought Maybe was a typeclass, not a monad?
17:19:04 <c_wraith> Maybe is a type
17:19:05 <mauke> Maybe is not a class
17:19:07 <piron> Maybe is a type constructor. It is not a type class. It is a Monad.
17:19:14 <mauke> :k Maybe Maybe
17:19:15 <lambdabot>     Expecting one more argument to `Maybe'
17:19:15 <lambdabot>     In a type in a GHCi command: Maybe Maybe
17:19:34 <piron> :k Maybe (Int ~ Bool)
17:19:35 <lambdabot> *
17:19:39 <piron> hehehe
17:19:40 <mauke> er
17:19:45 <mauke> ‡≤†_‡≤†
17:19:51 <piron> I think it must be a bug.
17:19:54 <lykos> Okay, so lets see if I get this right:
17:20:13 <lykos> this function:
17:20:13 <lykos> getParam "echoparam" >>= \ param -> maybe (writeBS "must specify fact/param in URL") writeBS param
17:20:42 <lykos> is an example of using the >>= to bind a Snap Monad state of type Maybe ByteString
17:21:25 <piron> I think... the idea is right, but the terminology may still be a bit off. But that's okay with me.
17:21:28 <lykos> to the variable param in the anonymous function on the right
17:21:54 <ion> lykos: When you see ‚Äúf a‚Äù the value, you know f has the type ‚ÄúA -> B‚Äù for some types A and B (if f takes exactly one parameter), i.e. it takes a value parameter and returns a value. When you see ‚Äúg b‚Äù the type, you know g has the kind ‚Äú* -> *‚Äù (if g takes exactly one parameter), i.e. it takes a type parameter and returns a type.
17:22:44 <piron> well... you know g has the kind "A -> B" for some kinds A and B
17:22:47 <ion> lykos: ‚Äúf a‚Äù may be ‚Äúshow 42‚Äù and ‚Äúg b‚Äù may be ‚ÄúSnap Integer‚Äù, for instance.
17:23:17 <ion> piron: true
17:23:44 <lykos> prion: you said the terminology might be a bit off, could you restate my statement with the correct terminology? I want to get this right :)
17:24:21 <piron> Okay, great. =)
17:25:34 <piron> I guess may main complaint is calling 'getParam "echoparam"' a Snap monad state.
17:26:21 <piron> Primarily because I just have never heard "monad state" used as a technical term, though you're free to invent a meaning for it. :)
17:26:53 <piron> So maybe, "...is an example of using >>= to bind a Snap (Maybe ByteString) value..."
17:26:57 <lykos> monad state: half totaltarian/half anarchy
17:27:03 <lykos> it's a confusing social structure
17:27:10 <piron> :D
17:27:50 <lykos> but what *is* a Snap (Maybe ByteString)?
17:28:16 <lykos> OH!
17:28:18 <lykos> Wait
17:28:23 <piron> Well, up to newtype wrappers, it's a StateT SnapState (Iteratee ByteString IO) (SnapResult (Maybe ByteString)). Does that help? :P
17:28:25 <c_wraith> It's a Snap action that may produce a ByteString
17:28:35 <lykos> so.. the anon function "\ param -> maybe (writeBS "must specify fact/param in URL") writeBS param "
17:28:43 <lykos> implicitly returns()
17:28:49 <lykos> it's value
17:29:11 <lykos> which is back-propagated "through" >>= into the Monad
17:29:30 <lykos> the meta-level snap monad has then, throughout this line of code
17:29:44 <lykos> kept an internal state, "maybe bytestring"
17:30:16 <c_wraith> Maybe sort of, but that's not the most useful way to think of it.
17:30:21 <piron> err...?
17:30:41 <lykos> I guess what I mean is that earlier
17:30:44 <c_wraith> Snap actions may or may not "contain" anything.
17:30:53 <lykos> 1 sec, gotta look back in chat:
17:31:31 <lykos> awhile ago ReinH said "but the monad laws say that >>= must be used with a function that returns the value back into the monad"
17:32:04 <lykos> does that mean the function on the right side of the >>= implicitly (or explicitly) calls return() to put some value back into the Snap monad?
17:32:13 <ReinH> lykos: which is misleading, what I should have said is: the type of >>= implies that you must start and end with a monadiv value
17:32:20 <ReinH> *monadic
17:32:25 <piron> lykos: Not necessarily, no.
17:32:33 <lykos> okay, what exactly is a "monadic value"?
17:32:46 <piron> lykos: The function on the right side must have a Snap-y type, but it need not explicitly use return.
17:33:08 <lykos> but it will at least implicitly return a snap-y type, right?
17:33:17 <ion> A monadic value is anything of type ‚Äúm a‚Äù for some m and some a where m is an instance of Monad.
17:33:18 <dwcook> v :: (Monad m) => m a is a monadic value
17:33:29 <piron> It will have a Snap-y type. Haskell doesn't have a way to return types.
17:33:30 <dwcook> m there is a monad
17:33:40 <ReinH> lykos: v :: Monad m => m a, v is a ... never mind
17:33:42 <tikhon> lykos: be careful not to get confused by the *function* return and the act of returning a value
17:34:16 <lykos> okay, I understand the distinction :)
17:34:18 <lykos> thanks
17:34:19 <ReinH> lykos: a monad is a type constructor and some structure (provided by return and >>=)
17:34:33 <hpaste> enthropy pasted ‚Äúquestion on overloading / simplification of types‚Äù at http://lpaste.net/91534
17:35:06 <lykos> Okay
17:35:07 <ReinH> lykos: a monadic value is what you get when you apply the type constructor to a value, so Monad m => m a is an a with whatever structure the monad m provides
17:35:18 <arkeet> you don't apply type constructors to values :|
17:35:36 <arkeet> (you apply them to types)
17:35:39 <ReinH> yes
17:35:46 <ion> Many monadic values of type ‚Äúm a‚Äù don‚Äôt contain a value of type ‚Äúa‚Äù. For instance:
17:35:48 <ion> @quote /bin/ls
17:35:48 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:36:31 <dwcook> Nothing :: Maybe a doesn't actually contain an a
17:36:40 <ion> A value of type ‚ÄúMaybe Integer‚Äù contains zero to one values of type Integer.
17:36:59 <lykos> do all monads use maybe?
17:37:14 <tikhon> no
17:37:22 <tikhon> Maybe is just a simple example of a monad
17:37:33 <ReinH> arkeet: sorry, I need to be more careful
17:37:34 <piron> erm
17:37:38 <piron> It's possible the question is a bit confused.
17:37:58 <lykos> okay
17:37:59 <piron> All monads m can wrap Maybe values; e.g. m (Maybe Int) is a fine type for any Monad m.
17:38:10 <arkeet> what's the question?
17:38:18 <lykos> okay
17:38:20 <lykos> I see
17:38:36 <piron> But the implementation of a particular Monad m need not refer to Maybe anywhere.
17:38:42 <lykos> okay
17:38:54 <lykos> but it seems like a highly useful monad
17:39:01 <lykos> hence why it's used in the Snap monad
17:39:12 <ReinH> lykos: it isn't used in the Snap monad
17:39:46 <ReinH> lykos: Snap (Maybe ByteString) is in effect a way to execute something using snap that might provide a bytestring value
17:39:58 <lykos> it's.. wrapped by the snap monad?
17:40:03 <ReinH> in this case it's asking the snap "context" for the value of a param
17:40:17 <piron> enthropy: I would add a type family ATTInverse with clauses a -> b = Int and Double = Double.
17:40:24 <lykos> Okay..hmm
17:40:36 <enthropy> piron: so then it does the same as the MPTC version?
17:40:46 <lykos> ReinH: what do you mean, the snap "context" for the value param?
17:40:53 <piron> enthropy: Hm, probably, yeah.
17:41:01 <ReinH> lykos: the snap context is what's defined by the Snap type constructor and the behavior of >>= and return
17:41:11 <semithinking> Hi everyone :)
17:41:22 <semithinking> I'm new here
17:41:28 <ReinH> lykos: in this case it involves web request and response state and IO
17:41:51 <lykos> ReinH: okay
17:41:56 <piron> enthropy: wait, no
17:41:59 <ReinH> lykos: you can tell because the Snap type constructor is a newtype alias for a state transformer (StateT) that has IO at the base
17:42:05 <piron> enthropy: The type family version gives you a bit more than the MPTC version.
17:42:17 <tikhon> semithinking: are you learning Haskell, or just new to the channel?
17:42:28 <piron> enthropy: Because as soon as you know the polymorphic function takes two arguments, you know it's the Int -> Int -> Int instance.
17:42:31 <ReinH> lykos: and the state in question deals with SnapRequest and SnapResponse
17:42:34 <semithinking> tikhon: I'm new to the channel and haskell
17:42:38 <piron> enthropy: Let me double check my intuition, though.
17:42:42 <lykos> so the "context" of a Maybe ByteString here is as maybe a param was passed earlier to snap?
17:42:57 <ReinH> lykos: so from the type definition I can expect that when I do something with Snap it will involve managing that state or performing IO
17:43:17 <c_wraith> Snap is not the best example, by the way - it does two or three totally independent things.
17:43:18 <ReinH> getParam works on the SnapRequest part of the state
17:43:26 <semithinking> tikhon: I've been reading Learn You a Haskell ...
17:43:36 <tikhon> it's a nice book
17:43:49 <semithinking> It's quite entertaining at the same time :)
17:43:53 <tikhon> but I really suggest working on a little project of some sort
17:43:54 <lykos> okay
17:43:54 <c_wraith> It carries the request state, it carries a partially constructed response, it allows shortcutting execution, and it allows executing arbitrary IO
17:44:05 <tikhon> otherwise things stop making sense after a little while
17:44:30 <ReinH> lykos: right, and because you need to keep that monadic structure around, you get back a Snap (Maybe ByteString) from getParam rather than just a Maybe ByteString
17:44:39 <semithinking> well my background is in math ... so i think i should be able to handle the cat theory
17:44:51 <ReinH> lykos: if it just gave a Maybe ByteString then there's no snap "context" to use to manipulate the response any more
17:44:57 <semithinking> but you're right...i might lose how it will apply to real world problems
17:45:02 <tikhon> the tricky bit isn't the theory itself‚Äîwhat Haskell uses is very simple
17:45:02 <lykos> c_wraith: and I'm accessing what state exactly with >>= in this function?
17:45:08 <ReinH> If I'm wrong again someone please correct me ;)
17:45:23 <lykos> wait..
17:45:23 <tikhon> are you interested in programming language stuff, perchance?
17:45:23 <c_wraith> lykos: >>= doesn't access anything.  it composes things.
17:45:24 <lykos> Oh
17:45:26 <ReinH> lykos: you aren't accessing the state
17:45:28 <lykos> wait
17:45:43 <semithinking> a little bit :)
17:45:44 <lykos> is >>= passing the entire snap Context to the function on the right?
17:45:49 <ReinH> lykos: >>= composes something that gives an m a with something that just wants an a
17:45:53 <c_wraith> no
17:45:54 <lykos> thus maintaing it's state
17:46:03 <tikhon> there are some very good, small, self-contained PL projects to try
17:46:13 <lykos> it pases a Snap( a )
17:46:14 <ReinH> getParam gives a Snap (Maybe ByteString) but the function you call next just wants a Maybe ByteString
17:46:14 <semithinking> PL standing for ...
17:46:20 <tikhon> programming languages
17:46:23 <c_wraith> It *combines* the state from the let argument with the result of the function that's its right argument
17:46:27 <tikhon> there is a tutorial called "Write Yourself a Scheme in 48 Hours"
17:46:32 <ReinH> lykos: so >>= has the effect of threading the Snap structure through the composition
17:46:36 <c_wraith> That's why I said it's composition
17:46:37 <tikhon> I found it a good way to ground my Haskell knowledge when I was just starting out
17:46:46 <tikhon> another fun option is to write a Prolog interpreter
17:46:58 <tikhon> it's much simpler than you would imagine, especially if you don't bother with the cut operator
17:47:24 <lykos> ah.. okay
17:47:46 <semithinking> hmmmm
17:47:57 <c_wraith> what exactly goes on in that combining is the part that >>= hides
17:48:02 <semithinking> this looks like a good tutorial too
17:48:08 <semithinking> I'm just looking at that wikibook
17:48:15 <tikhon> yeah, that's the place
17:48:16 <c_wraith> You know that it combines them according to a few rules (the monad laws), but you don't care about the details.
17:48:35 <tikhon> it was a good way to see the things I was learning about in action
17:48:41 <tikhon> also quite fun
17:48:46 <semithinking> :)
17:48:55 <lykos> actually, I kind of care about the details c_wraith :)
17:48:57 <semithinking> i was also looking at the latex library
17:49:01 <tikhon> but I'm somwehat biased because I really like programming languages‚ÄîI probably found it more fun than most people
17:49:03 <lykos> it uses category theory, right?
17:49:09 <ReinH> lykos: remember that writeBS takes a ByteString and gives a Snap ()
17:49:12 <tikhon> HaTeX?
17:49:19 <semithinking> yes ...
17:49:22 <semithinking> there is that
17:49:23 <c_wraith> lykos: you shouldn't care about the details.  That's the whole point of abstraction.  If you had to keep the details in your head, you'd go insane.
17:49:27 <ReinH> lykos: this is very similar to putStr which takes a String and gives an IO ()
17:49:33 <tikhon> what did you think?
17:49:34 <semithinking> but i was looking at how to generate TikZ code
17:49:38 <carter> hey tikhon , are you still in nyc?
17:49:43 <tikhon> carter: yeah
17:49:47 <carter> cool
17:49:51 <lykos> c_wraith: I like the details. Monads are a whole way of abstracting state from a functional language
17:50:02 <lykos> c_wraith: the more I understand, the better I can use it
17:50:07 <lykos> right?
17:50:10 <c_wraith> lykos: well.  That's a job Monads can do.  But it's not what they're for.
17:50:43 <lykos> okay
17:51:09 <semithinking> tikhon ... are you CS student?
17:51:14 <carter> tikhon: btw: have you had a look see at llvm-general?
17:51:36 <lykos> okay
17:51:51 <tikhon> semithinking: yeah
17:52:01 <lykos> ReinH: so writeBS takes a Bytestring and.. translates it to a Snap context?
17:52:06 <tikhon> carter: just superficially
17:52:11 <ReinH> lykos: what does putStr do?
17:52:26 <carter> k
17:52:38 <c_wraith> ReinH: writeBS actually is fundamentally different from putStr in an important way.
17:52:43 <ReinH> c_wraith: ok
17:52:52 <carter> worth staring at, tis nice and getting nicer
17:53:16 <tikhon> yeah, I'm certainly going to look closer when I want to use the LLVM
17:53:22 <ReinH> c_wraith: My point, which might still stand, is that putStr takes a String and gives a monadic action
17:53:29 <c_wraith> that much is the same
17:53:41 <semithinking> tikhon: thanks for your advice ... I'm going to read through that wiki right now :)
17:53:48 <carter> like‚Ä¶ pretty much every api hook that has a maintained sane C++ interface, bscarlet is on track to add it seem :)
17:53:53 <carter> though he can speak best for himself :)
17:54:17 <bscarlet> I wouldn't say every C++ interface...
17:54:28 <ReinH> lykos: so putStr take a String and gives a monadic action that "does something with IO" and must eventually return ()
17:54:29 <carter> ok
17:54:35 <carter> which ones aren't you  not going ot add :)
17:54:43 <bscarlet> Though any I haven't gotten to is fair game for feature requests‚Ä¶ :-)
17:54:45 <c_wraith> writeBS returns an action that updates the response stored in the context, appending the ByteString passed in to the body that will later be written out.  There's an extra level of indirection.
17:54:50 <ReinH> lykos: similarly, writeBS takes a ByteString and gives a monadic action that "does something with Snap" and must eventually return ()
17:54:51 <carter> :)
17:55:02 <ReinH> where "does something with snap" is defined by the implementation
17:55:40 <piron> enthropy: Okay, this is annoying.
17:55:44 <lykos> Okay, and putStr returns an action in which the IO monad writes something to stdout?
17:55:47 <carter> i rest my case :)
17:55:59 <lykos> or does putStr do the writting to stdout?
17:56:11 <ReinH> lykos: well, technically the IO monad is the action and this is executed by the runtime
17:56:11 <piron> piron: I can get GHC to give \x y -> tf x y the type TF (t1 -> t) => I (t1 -> t) -> t1 -> t
17:56:16 <ReinH> er
17:56:19 <piron> enthropy: That was at you, not me. :P
17:56:24 <ReinH> the IO () that is given by putStr is the action
17:56:33 <piron> enthropy: And I can get GHC to compute :k! TF (t1 -> t) = Int
17:56:48 <ReinH> lykos: putStr gives a value, it just happens that that value is the execution of "print the string"
17:56:50 <piron> enthropy: And I can get GHC to observe that \x -> tf (x :: Int) has type Int -> Int -> Int.
17:57:04 <lykos> Okay! That makes sense ReinH
17:57:05 <piron> enthropy: But I can't get it to put all the pieces together at once and conclude that \x y -> tf x y has type Int -> Int -> Int...
17:57:14 <ReinH> lykos: it's actually up to the runtime to decide when that monadic action is executed
17:57:26 <piron> enthropy: Which may be worth a feature request on Trac. In any case I'll show you my code.
17:57:40 <lykos> so for Snap() or IO() or Monads in general
17:57:52 <lykos> the functions using the monad (through >>=)
17:58:02 <lykos> return a value to the monad
17:58:05 <ReinH> lykos: similarly, writeBS takes a ByteString and gives a monadic action that, when executed by the runtime, writes to the snap response
17:58:12 <lykos> they don't interact with the outside world or maintain state
17:58:24 <lykos> they give a value to the monad, and the monad "executes" it in runtime
17:58:28 <enthropy> piron: that works for the mptc one though
17:58:52 <piron> enthropy: Which bit works for mptc?
17:58:58 <ReinH> lykos: the monad doesn't execute, the monadic value is the thing that is executed
17:59:17 <lykos> "writes to the snap response", snap response being the http of the outside world, or being a state in Snap()?
17:59:25 <enthropy> piron: :t let f x y = mptc x y in f
17:59:34 <lykos> monadic value is executed, okay
17:59:34 <enthropy> gives: let f x y = mptc x y in f :: Int -> Int -> Int
17:59:47 <lykos> give an example of a monadic value in this context?
17:59:59 <ReinH> lykos: the response in this case is a value of type SnapResponse that is managed by the state monad (StateT actually) that Snap encapsulates
17:59:59 <lykos> I feel like I really understand this a *lot* more, thanks again
18:00:38 <ReinH> lykos: and in general, m () is a monadic action that does something with the monadic "context" but doesn't have a meaningful value to return afterwards
18:00:38 <ReinH> like putStr
18:00:40 <lykos> okay.
18:01:06 <piron> enthropy: Oh, strange! let f x y = mptc x y in f gets a different type than \x y -> mptc x y
18:01:19 <piron> enthropy: And let f x y = tf x y in f seems to get the good type Int -> Int -> Int, too.
18:01:35 <piron> enthropy: Okay, so what's left, then? mptc does everything you want, and I have a type-families version that does, too.
18:01:37 <piron> (right?)
18:01:47 <ReinH> lykos: whereas m a is a monadic action that, when executed, "returns" (as in `return`) an a
18:02:03 <ReinH> lykos: so getLine is an IO action that, when executed, returns a String
18:02:23 <piron> enthropy: (By the way, my type families version doesn't require undecidable instances. :)
18:03:00 <lykos> okay
18:03:21 <ReinH> lykos: and when you say do { line <- getLine }, you are "binding" line to the value. But because you can only obtain that value by doing IO, it must be a IO String not just a String
18:03:37 <lykos> so the difference is if the monad is changing the outside world, m ( )
18:03:47 <ReinH> lykos: m a can still change the outside world
18:03:59 <lykos> ah okay
18:04:02 <ReinH> lykos: the difference is that it also returns a value that might be useful later on in the monadic execution
18:04:17 * hackagebot parsers 0.9 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.9 (EdwardKmett)
18:04:19 * hackagebot storable-static-array 0.5.0.1 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.5.0.1 (CarlHowells)
18:04:24 <ReinH> so IO String interacts with IO to get you a String that you can use later as long as you use it while doing IO
18:04:36 <lykos> not just later on in the monadic execution though, right? just later on in execution?
18:04:50 <ReinH> lykos: you can only get to that string from within the monadic context
18:05:10 <lykos> yeah, but I mean, if you're writting a haskell program
18:05:16 <ReinH> lykos: which is why putStr, which takes a String, must be composed with >>= to give you (>>= putStr), which takes an IO String
18:05:20 <lykos> you could use the monad just to get a string, then do do something else?
18:05:27 <ReinH> lykos: right, and that's what you do
18:05:48 <lykos> okay
18:05:59 <ReinH> lykos: within the do block, line <- getLine binds a value to line that is used as if it were just a String
18:06:08 <piron> enthropy: I mean, which thing were you hoping it could infer but it failed to infer for mptc?
18:06:10 <dwcook> Some monads give you a means of getting values out of them, like how you can get the head and tail of a list. But those are specialized to the monad in question. IO in particular you're supposed to keep everything within the IO action.
18:06:17 <ReinH> lykos: the point is that you must be within the do block (within the monadic action) to have access to the string
18:06:30 <dwcook> +non-empty
18:06:33 <lykos> okay
18:07:02 <lykos> :t getLine
18:07:03 <lambdabot> IO String
18:07:06 <ReinH> lykos: this is why main :: IO ()
18:07:07 <enthropy> piron: well the two-argument case doesn't always simplify
18:07:11 <lykos> so getLine :: IO string
18:07:16 <ReinH> lykos: everything that happens inside main is a monadic action
18:07:27 <lykos> :t getLine
18:07:28 <lambdabot> IO String
18:07:29 <piron> enthropy: Yeah, I think that would make a good GHC feature request.
18:07:32 <lykos> :t putStr
18:07:33 <lambdabot> String -> IO ()
18:07:43 <ReinH> lykos: that monadic action does stuff with IO and returns ()
18:07:58 <lykos> ReinH: what about everything in functions main calls?
18:08:03 <lykos> are they still in the monad, or not?
18:08:09 <ReinH> lykos: but because monadic actions are composable using >>=, your whole program is a single monadic IO action composed of a bunch of smaller ones
18:08:14 <piron> piron: But you can actually see that it knows how to simplify. There are four things to try: mptc `asTypeOf` (undefined :: a -> Double), and the same with undefined having the types a -> b -> c, Double -> a, and Int -> a.
18:08:23 <piron> argh
18:08:28 <lykos> :t (>>= putStr)
18:08:29 <lambdabot> IO String -> IO ()
18:08:30 <piron> dunno why I keep typing piron instead of enthropy
18:08:42 <piron> enthropy: Anyway, it gets the right answer for all four of those, and I can't imagine hoping for much more than that.
18:08:42 <cschneid> is there a way to simply tell the main thread of haskell to wait for all forkIOs to finish? I don't have any data to report back, just don't want to quit app until side work is done
18:08:54 <ReinH> lykos: if I say do { line <- getLine; putStr (reverse line) }
18:09:04 <ReinH> lykos: reverse :: String -> String, so you know reverse can't do anything with IO
18:09:09 <ReinH> there's no monadic action involved
18:09:26 <lykos> okay
18:09:41 <ReinH> that's how the pure parts of your code are separated from the parts that do IO
18:09:43 <lykos> I don't fully understand that example though
18:09:49 <lykos> because I actually don't know do notation
18:09:52 <enthropy> piron: can you paste your version with -XTypeFamilies?
18:09:58 <tabemann> cschneid: there's ways to do it, but none built-in
18:10:07 <piron> enthropy: So, to put it crisply, my feature request would be to get the same output from ":t \x y -> mptc x y" as I get from ":t mptc `asTypeOf` (undefined :: a -> b -> c)".
18:10:07 <dwcook> do { line <- getLine; putStr (reverse line) } just means getLine >>= putStr . reverse
18:10:09 <piron> enthropy: Sure, one second.
18:10:09 <lykos> could you explain do notation, in the context of >>=?
18:10:12 <cschneid> tabemann: ok, so MVar approach looks simplest? Just using it as a lock
18:10:13 <ReinH> dwcook: right
18:10:16 <lykos> I think I'm starting to understand the basic idea
18:10:34 <ReinH> or, to add a point, getLine >>= \line -> putStr (reverse line)
18:10:41 <startling_> lykos, do { a <- m; f a; } is "m >>= \a -> f a"
18:10:57 <dwcook> Yeah, woops, accidentally reduced in my head
18:11:08 <ReinH> dwcook: yep :)
18:11:11 <hpaste> piron pasted ‚Äútype families‚Äù at http://lpaste.net/91535
18:11:15 <tabemann> cschneid: I was actually thinking off doing it as a TVar, starting at 0, and incrementing it when each thread finishes, with the main thread waiting for the count to reach four, retrying if it has not reached it yet
18:11:42 <cschneid> tabemann: well, honetly the threads will never complete.  It'd like to wait until the user hits ctrl-c :)
18:11:45 <ReinH> lykos: so, for any f :: String -> String, you can say getLine >>= line . f
18:11:45 <cschneid> so any lock is fine
18:11:56 <dwcook> There's also do { foo; bar }, which means foo >> bar
18:12:10 <ReinH> er
18:12:15 <ReinH> getLine >>= putStr . f
18:12:24 <enthropy> piron: constraints like (a ~ O (I a)) => were illegal in the first releases of GHC that had -XTypeFamilies?
18:12:28 <tabemann> cschneid: if you're really just waiting for the program to terminate, then it sounds like you want something like forever $ threadDelay 1000000 in your main thread....
18:12:38 <ReinH> lykos: so (putStr . f) :: String -> IO (), which means it takes a String and returns an IO action
18:12:39 <cschneid> ahh, that'll work. :)
18:12:41 <piron> enthropy: I think they were legal but required UndecidableInstances.
18:12:52 <lykos> getLine >>= line . reverse
18:12:55 <piron> not totally sure of that
18:12:56 <cschneid> tabemann: it's a daemon that just pushes data into a queue. So the worker threads to their thing, but just want to hang out forever.
18:13:04 <lykos> " Not in scope: `line'"
18:13:04 <ReinH> lykos: that's wrong, sorry
18:13:10 <ReinH> getLine >>= putStr . f
18:13:23 <piron> enthropy: gotta run now
18:13:28 <ReinH> :t getLine >>= putStr
18:13:29 <lambdabot> IO ()
18:13:37 <piron> enthropy: I think you have essentially the best solution you can have. I hope it's good enough for you.
18:13:46 <ReinH> lykos: so that's an IO action composed of two things: get a line, print the line
18:14:05 <ReinH> lykos: if I instead wrote it as: getLine >>= \line -> putStr line
18:14:09 <ReinH> lykos: then what is the type of line?
18:16:00 <lykos> 1 sec
18:16:35 <enthropy> not supported by ghc612 http://lpaste.net/91535
18:18:14 <carter> someone still uses 6.12?!??!
18:18:24 <monochrom> hehe
18:20:32 <tikhon> I don't know about 6.12, but we only have 7.0.4 at work :P
18:21:36 <lykos> >getLine >>= \line -> putStr( reverse line  ++ "\n")
18:21:40 <lykos> hello?
18:21:46 <lykos> ah, lamdabot doesn't like IO :(
18:21:49 <lykos> but it works in GHCI
18:21:52 <mauke> > getLine >>= \line -> putStr( reverse line  ++ "\n")
18:21:52 <ReinH> lykos: hi.
18:21:53 <lambdabot>   <IO ()>
18:21:54 <lykos> (I was testing some stuff out)
18:22:12 <ReinH> lykos: let me put it this way
18:22:15 <lykos> >getLine >>= \line -> putStr( reverse line  ++ "\n") < "hello"
18:22:26 <ReinH> :t getLine
18:22:27 <lambdabot> IO String
18:22:31 <ReinH> :t putStr
18:22:31 <lambdabot> String -> IO ()
18:22:33 <lykos> ReinH: it's starting to make more sense
18:22:40 <ReinH> lykos: I want to get a line and then print it
18:22:45 <ReinH> lykos: why can't I just do this:
18:22:50 <ReinH> let line = getLine in putStr line
18:23:01 <lykos> (what does in mean here?)
18:23:09 <mauke> lykos: "> ", not ">"
18:23:10 <geekosaur> because getLine :: IO String
18:23:16 <geekosaur> not getLine :: String
18:23:17 <ReinH> geekosaur: I know.
18:23:24 <ReinH> geekosaur: I want lykos to answer )
18:23:26 <ReinH> :)
18:23:55 <ReinH> lykos: let x = 1 in x is a way to bind x to the value 1
18:24:07 <mauke> > let x = 42 in [x + 1, x + 2]
18:24:07 <lambdabot>   [43,44]
18:24:24 <lykos> ah
18:24:28 <ReinH> lykos: in other words, why can't I take what getLine gives me and pass it to putStr?
18:24:28 <mauke> > (let x = 1 in x) + (let x = 2 in x)
18:24:29 <lambdabot>   3
18:24:47 <ReinH> lykos: work it out using the types
18:25:08 <lykos> > let v = 10 in [x * v| x < [1..5]]
18:25:09 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
18:25:09 <lambdabot>              w...
18:25:20 <lykos> > let v = 10 in [x * v| x <- [1..5]]
18:25:21 <ReinH> lykos: don't get distracted :p
18:25:21 <lambdabot>   [10,20,30,40,50]
18:25:26 <lykos> ;)
18:25:27 <NihilistDandy> > return "hello" >>= \line -> putStr( reverse line  ++ "\n")
18:25:28 <lambdabot>   <IO ()>
18:25:51 <ReinH> lykos:
18:25:53 <ReinH> :t getLine
18:25:53 <lambdabot> IO String
18:25:54 <ReinH> :t putStr
18:25:55 <lambdabot> String -> IO ()
18:25:59 <ReinH> why can't I just plug those together?
18:26:20 <lykos> plug them together how?
18:26:28 <lykos> because the types don't match
18:26:39 <monochrom> "getLine >>= putStr" just plugs them together
18:26:59 <ReinH> lykos: one is IO String but the other wants a String?
18:26:59 <mauke> ReinH: your approach is doomed to fail in public
18:27:05 <ReinH> mauke: yeah :/
18:27:22 <augur_> NihilistDandy!
18:27:24 <ReinH> mauke: it works better with a white board
18:27:26 <NihilistDandy> augur_:
18:27:27 <lykos> by transforming String -> IO() to IO String -> IO()
18:27:28 <lykos> I get it
18:27:30 <ReinH> mauke: and drawings of monsters
18:27:48 <lykos> >>= wraps the right hand side in the monadic context
18:28:04 <ReinH> lykos: you need a function that takes an IO String and gives a String, but...
18:28:09 <ReinH> lykos: that's not enough because then you'd lose the IO context
18:28:13 <ReinH> lykos: so that's why
18:28:16 <ReinH> :t (>>=)
18:28:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:28:32 <ReinH> lykos: where m in this case is IO and a is String and b is ()
18:28:48 <lykos> :t putStr
18:28:48 <lambdabot> String -> IO ()
18:28:50 <ReinH> lykos: >>= needs both the monadic action (m a) and a function from an a to a new monadic action (m b)
18:29:01 <ReinH> lykos: it needs both because it needs to know how to preserve the monadic context
18:29:10 <lykos> I actually get it :)
18:29:13 <ReinH> ok :D
18:29:16 <ReinH> I will shut up :D
18:29:30 <lykos> the "in" syntax awhile ago just threw me for a loop
18:29:35 <ReinH> my bad :)
18:29:37 <ReinH> ok gotta run
18:29:39 <lykos> and I'm feeling light-headed from not eating enough today :P
18:29:42 <ReinH> sorry for spamming everyone else
18:30:01 <lykos> no need to appologize for anything, thanks so much for your help!
18:30:11 <lykos> if you saw what I was doing in ghci, you'd see I get it :)
18:30:39 <lykos> Thanks, you helped me learn the basics of monads in a night :P
18:30:43 <lykos> they make a *lot* more sense now
18:31:15 <ReinH> lykos: well, I made some stupid mistakes that my betters corrected, but thanks :)
18:31:28 <lykos> ReinH: you actually made it all click earlier
18:31:59 <lykos> I actually wrote it down, when you said
18:32:05 <lykos> f :: Maybe ByteString -> Snap ()
18:32:13 <lykos> so (>>= f) is Snap (Maybe ByteString) -> Snap ()
18:32:42 <lykos> which is what pretty much what you were asking for a moment ago with putStr/getLine
18:32:52 <lykos> but I was too light-headed to think clearly. I need to go eat :P
18:32:56 <ReinH> lykos: bingo :)
18:33:09 <ReinH> and if I can explain it to someone else maybe that means I understand it too :D
18:33:31 <lykos> Other people did a good job in explaining some aspects, but you made it all click
18:33:33 <lykos> thanks :)
18:33:54 <ReinH> I stand on the shoulders of giants or some such
18:34:06 <lykos> 1 more quick question if you have a sec?
18:34:09 <ReinH> kk
18:34:19 <lykos> in do statements there's often many lines
18:34:27 <lykos> how does that correspond to >>= notation?
18:34:30 <lykos> simply composition?
18:34:32 <BMeph> lykos: Are you familiar with '=<<', the "flipped version of '>>=' ?
18:34:49 <lykos> BMeph: nope, just got familiar with >>=. What's =<<?
18:35:11 <ReinH> lykos: this walks through the transformation: http://en.wikibooks.org/wiki/Haskell/do_Notation
18:35:20 <BMeph> lykos: Well, as all of these other Haskell gurus say, let's look at the type! ;p
18:35:21 <startling_> =<< doesn't matter, does it?
18:35:30 <BMeph> :ty (=<<)
18:35:33 <ReinH> lykos: it's a purely mechanical rewriting
18:35:36 <startling_> lykos, each line in do notation corresponds to a call to >>=
18:35:45 <mlamari> Looking at gtk2hs's .cabal file, what about it gets the sub-library cabal files from the local copies rather than going to hackage for versions?  Does cabal build search the subdirectories for a library before going to .cabal ?
18:35:49 <startling_> well, half of a call
18:36:23 <lykos> ReinH: Thanks! I should let you go now. You've been a great help :)
18:36:31 <ReinH> lykos: ok ttfn
18:36:40 <ReinH> and you're welcome
18:36:42 <lykos> :t (=<<)
18:36:42 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:36:43 <BMeph> startling_: No, it doesn't matter, but I found the re-arranging of the arguments helped to understand how to use the thing, so I wanted to see if it helped lycos as well. :)
18:36:54 <lykos> ReinH: yep, see ya around
18:37:03 <BMeph> Er, that should be *lykos. :)
18:37:29 <lykos> ?
18:38:17 <lykos> *lykos?
18:38:30 <BMeph> lykos: Ah, yes, you got it. So, one way to thing of the flipped version of it, is that it takes a function of type (a -> m b), and makes one of type (m a -> m b).
18:38:44 <ion> lykos: Dereferencing the pointer.
18:38:50 <lykos> Ah :)
18:39:02 <Radvendii> can I use guards in a function contained in a where block?
18:39:03 <cschneid> can somebody help me understand why the first call to startMetronome seems to set stuff up right, but the second doesn't?  https://gist.github.com/cschneid/8d2cd2d82c683aaec8ea
18:39:07 <lykos> I havn't been thinking in c mode :P
18:39:16 <levi> mlamari: I'm not sure exactly what you were asking, but are you familiar with ghc-pkg?
18:39:41 <cschneid> Specifically, the second call certainly calls into the code, sets up the socket, but never actually connects and sends info
18:39:55 <ion> radvendii: yes
18:39:56 <mlamari> levi:  Really in a roundabout way I'm wondering how a big project with a primary .cabal file for the .exe can refer to other .cabal files in the same set of directories.
18:40:22 <Radvendii> ion: but it's telling me "parse error on input |"
18:40:30 <lykos> BMeph: can you give an example of (=<<) in action?
18:41:09 <mauke> putStr =<< getLine
18:41:47 <BMeph> lykos: So, you could take a function like putStr (of type String -> IO ()), and make yourself a function that is (IO String -> IO ()). See mauke's example. :)
18:42:11 <levi> mlamari: Ah, I am not entirely sure about that, although I think most 'finding packages' tasks involve the package databases that ghc-pkg allows you to manipulate.
18:42:28 <monochrom> "print . length =<< getLine" allows you to read right-to-left throughout
18:43:11 <lykos> getLine >>= putStr   is the same as putStr =<< getLine?
18:43:16 <BMeph> lykos: ...and monochrom is showing us why you'd want to use such a thing. :)
18:43:17 <monochrom> yes
18:43:25 <mauke> @src (=<<)
18:43:25 <lambdabot> f =<< x = x >>= f
18:44:48 <lykos> any purpose for it besides synactic sugar?
18:45:18 <tabemann> since when is syntactic sugar necessarily a bad thing?
18:45:20 <NihilistDandy> It looks more like function composition, I guess, which might be comforting
18:45:23 <lykos> Never said it was bad :)
18:45:40 <NihilistDandy> *er, application
18:45:45 <lykos> Just wondered if it served another purpose
18:45:46 <BMeph> lykos: ...uh, yeah, what NihilistDandy said. :)
18:47:15 <lykos> I'll be back in a bit. I'm lightheaded from very little food and very much monads :P
18:47:23 <lykos> gtg eat
18:47:27 <BMeph> lykos: Also, there are certain mathematical papers/texts that introduce the 'bind' function (the name we have for '>>=') in that flipped form.
18:47:47 <NihilistDandy> I found that actively not thinking about monads for a long time made it much easier to understand monads
18:47:51 <lykos> BMeph: is bind a product of catagory theory?
18:47:51 <BMeph> lykos: Enjoy some good digestion, then, both physical and mental. ;)
18:49:31 <pentace> Can you make @pl list the transformations it did?
18:50:49 <BMeph> lykos: Yes. As are monads themselves (which, the more mathy folks will tell you, are not the same as "Monads"). ;)
18:51:29 <NihilistDandy> pentace: Unfortunately, no. You could probably read the source of pointfree on Hackage, though, to get an idea of what it's up to
18:51:48 <BMeph> pentace: If you rewrite the program, you can. I don't believe anyone has that as an option yet - you could be the first! ;)
18:52:13 <NihilistDandy> I'll bet there's a fold in there that you could turn into a scan
18:52:29 <mstksg> is there any way to run a .hs file through the TH preprocessor and see the resulting source code?
18:53:06 <pentace> NihilistDandy, BMeph: In particular, my problem is to conclude "f. f'" from "\x -> (return . f') x >>= f"
18:53:30 <geekosaur> mstksg, it's not really a preprocessorm it'ds run *during* compiling and can change the internal state of the compiler to some extent
18:54:06 <pentace> (if possible by applying the laws of Monad/Functor)
18:54:17 <mstksg> geekosaur: hm. then can i at least see what methods it defines and their type signatures?
18:54:18 <geekosaur> there is a preprocessor on hackage (zeroth), it can only handle a subset of TH and I'm not sure if it works with recent ghc. and don't think it handles things like quasiquoters
18:57:28 <geekosaur> one of the compiler debugging options lets you see what ghc has at a point after where it has evaluated TH (but also after it's done a number of other things, since TH is not a separate pass). there's also -ddump-splices which shows the AST (and an approximation of the source that might have generated it) resulting from a TH expression
18:58:11 <mstksg> geekosaur: hm thanks, i'll lok into those
18:59:32 <NihilistDandy> pentace: Okay, so I think a decent first step is to observer that (return . f') x is equivalent to return (f' x)
19:00:12 <NihilistDandy> Which gives us \x -> return (f' x) >>= f = f (f' x)
19:00:41 <NihilistDandy> Then the reduction is trivial
19:00:42 <NihilistDandy> *observe that
19:01:48 <NihilistDandy> Also, wow, I've never done anything like that, so if I'm wrong or I left out an important step please someone correct me
19:02:51 <pentace> Okay, that's not too hard to understand when you know what bind actually does. But can you conclude that only from the monad/functor laws?
19:03:15 <BMeph> NihilistDandy: I would spend more time on why "return (f' x) >>= f = f (f' x)", as well as separate that part from the "\x ->" part. :)
19:03:53 <BMeph> Or rather, "return (f' x) >>= f == f (f' x)"
19:04:08 <NihilistDandy> Right
19:04:29 <BMeph> pentace: The above is an application of one of the monad laws, BTW. :)
19:04:45 <NihilistDandy> return a >>= k  =  k a
19:05:01 <BMeph> ^^ That one, yes. ;p
19:05:24 <pentace> Oh heh, I missed that one :D
19:05:30 <pentace> thanks!
19:11:20 <NihilistDandy> pentace: If you need convincing of the left identity law, it's fairly straightforward if you understand do notation
19:11:54 <NihilistDandy> Though I suppose it's more correct to use Kleisli composition
19:13:50 <c_wraith> not more correct, but way easier to understand
19:15:52 <pentace> No no, I'm convinced that it's true :P
19:15:56 <jj_4> anyone used the cereal library with the FFI before?  Is there any straight forward way to make a Serializable instance into a Storable?
19:18:20 <mstksg> yesodweb down again?
19:18:48 <carter> jj_4: the lz4 library has some examples
19:19:33 <pentace> NihilistDandy: But I'm wondering if there are any laws about application of inverse function (if that even make sense in Haskell)
19:22:01 <NihilistDandy> Those should just be algebraic laws. If you satisfy the group axioms, that should be enough to guarantee inverse functions
19:22:08 <NihilistDandy> Actually, I think a semigroup is sufficient
19:24:29 <NihilistDandy> Well, no. I guess that's more of a special case. So you'll want to go with a group. So basically you just want to add a notion of inversion to a Monoid
19:25:18 <NihilistDandy> And then you get the cancellation property and all sorts of nice stuff falls out from there
19:27:56 <NemesisD> data-store's complexity estimates are crazy
19:28:31 <pentace> NihilistDandy: So you can say the set of all Haskell functions and (.) form a group?
19:29:47 <NihilistDandy> I wouldn't say all. A certain well-behaved set, but definitely not all
19:33:27 <pentace> I guess reading http://en.wikibooks.org/wiki/Haskell/Category_theory will answer much of my questions
19:33:56 <NihilistDandy> If you have questions about some of the category theory you can leverage in Haskell, sure
19:34:00 <NihilistDandy> :D
19:34:11 <NihilistDandy> It certainly can't hurt
19:37:37 <ReinH> NihilistDandy: (Redirected from Abstract Nonsense)
19:37:50 <NihilistDandy> Hahaha
19:38:14 <NihilistDandy> If you want the real abstract nonsense, read the HoTT book
19:38:30 <NihilistDandy> Though I am actually really liking that book
19:38:38 <Zenol> 'night
19:38:47 <ReinH> NihilistDandy: but it's so univalent...
19:39:23 <NihilistDandy> My poor valence
19:39:40 <pharaun> man arrows are neat
19:39:46 <ReinH> man
19:39:48 <ReinH> "In mathematics, in the branch of complex analysis, a holomorphic function on an open subset of the complex plane is called univalent if it is one-to-one."
19:39:53 <ReinH> Yeah, yeah, I know some of those words.
19:39:54 <pharaun> but i'm not as sure they're helping with readability on this code :)
19:40:15 <Nisstyre> pharaun: I tried reading the paper on arrows but fell asleep
19:40:20 <Nisstyre> it's like 30 pages long
19:40:20 <NihilistDandy> pharaun: I still need to get better with arrows. They feel a lot like magic sometimes
19:40:26 <ReinH> oh that's what holomorphic means
19:40:29 <ReinH> that's actually not that bad
19:40:34 <ReinH> I should learn more math
19:40:46 <NihilistDandy> Math is the best
19:40:53 <pharaun> NihilistDandy: heh yeah i'm using hxt so its not too bad, but yeah some of the more deeper parts are still a bit sticky for me but i'm getting a handle of it
19:41:00 <leroux> Nisstyre: Which paper is that?
19:41:19 <pharaun> Nisstyre: hehe yeah some of the papers can be a bit... hard to read, when it comes to those i usually falls back to playing with the concept and going from there
19:41:19 <ReinH> leroux: http://homotopytypetheory.org/2013/06/20/the-hott-book/ ?
19:41:23 <leroux> Oh.
19:41:24 <ReinH> oh sorry
19:41:26 <Saizan> the weird thing about hxt's arrows is that they are all kleisli ones
19:41:27 <leroux> ?
19:41:33 <Nisstyre> leroux: this one http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
19:41:33 <ReinH> leroux: my mistake
19:41:36 <ReinH> disregard
19:41:37 <leroux> That's fine.
19:41:37 <Nisstyre> and it's 56 pages long
19:41:39 <leroux> No problem.
19:41:49 <leroux> Nisstyre: Thanks.
19:42:06 <Nisstyre> leroux: the wikipedia page on arrows cites it
19:45:32 <leroux> Nisstyre: Yeah, I need to learn more math.
19:45:37 <leroux> Real math.
19:46:43 <NihilistDandy> Proofs are the best
19:48:33 <bb010g> \msg lambdabot @botsnack
19:50:15 <NihilistDandy> @botsnack
19:50:15 <lambdabot> :)
20:20:28 <chrisdone> those concepts are all really nice, injection, surjection, bijection, image, domain, codomain, etc. for talking about functions. not really CT, basic set theory, i suppose
20:28:08 <NihilistDandy> Yeah
20:29:05 <NihilistDandy> A decent understanding of foundational set theory and algebra make most Haskell things easier to at least get a handle on
20:30:34 <kamatsu> Looking at the average CS curriculum, I'd expect most CS graduates to be fairly competent at set theory, algebra, discrete mathematics, logic etc.
20:30:48 <kamatsu> but from my experience teaching CS undergrads, I don't think that's true at all
20:30:59 <NihilistDandy> Java == math, right?
20:31:43 <kamatsu> trying to explain rule induction is quite painful if they have never even heard of induction before.
20:32:00 <NihilistDandy> Yeah, that seemed to be a big stumbling block in the PL class I took
20:32:52 <kamatsu> Programming should be a much more mathematical exercise. This was not exclusively the purview of Haskell in the past.
20:33:17 <kamatsu> Imperative languages have excellent mathematical treatments, but OOP seems to be the unrigorous goop that has poisoned that
20:34:06 <NihilistDandy> Agreed. I was rather disappointed in my algorithms class because we just glossed over the math parts and wrote toy Java. I ended up writing proofs for a lot of things to entertain myself. The bonus points were good, at least
20:36:20 <kamatsu> Proofs of complexity or correctness?
20:39:38 <NihilistDandy> Some of both.
20:40:10 <NihilistDandy> Usually correctness. We only had to work out complexity a few times, unfortunately
20:40:27 <NihilistDandy> And the correctness proofs weren't necessary, they just saved me writing some code
20:41:30 <kamatsu> Interestingly, the course I'm teaching now is on concurrent semantics and verification for imperative languages.
20:41:51 <kamatsu> Notably, you can't use a typical (initial state, final state) denotation for those languages because the states in between matter as well.
20:42:42 <NihilistDandy> That sounds interesting. Is there a text you're using?
20:42:58 <kamatsu> I wonder if anyone has come up with a good treatment of that in a monadic context. I suspect concurrency is one of the semantic hacks in the IO monad that doesn't have a good formal treatment.
20:43:13 <kamatsu> We're using principles of concurrent and distributed programs by ben-ari but it's not comprehensive of the course content.
20:43:42 <NihilistDandy> Well, if you end up publishing lecture notes or anything like that, I'd certainly be interested to read them
20:43:57 <kamatsu> In particular viewing IO a as some state transformer on the world assumes that the IO program is the only thing affecting the world.
20:44:15 <kamatsu> and that there are no other (concurrent) programs doing the same.
20:48:02 <chrisdone> kamatsu: isn't that what a denotational semantics of the imperative language would offer? converting it into a state transformer?
20:49:42 <cschneid> I'm trying to have two threads work together, but they don't seem to go back & forth: https://gist.github.com/cschneid/3862b33c29a803be7848
20:50:06 <cschneid> why would my forkOS calls not then cooperate together?  I even threw in an explicit `yield` call, to no effect
20:50:27 <kamatsu> chrisdone: an imperative language without concurrency, sure
20:50:47 <chrisdone> right
20:51:10 <chrisdone> what about emulation of concurrency e.g. with continuations?
20:51:30 <kamatsu> but with concurrency, you have to map the program to a (w.l.o.g infinite) sequence of states, each transition of which is observable to the outside
20:52:07 <kamatsu> chrisdone, that's cooperative threads, which can be modelled a bit more simply.
20:53:15 <kamatsu> however even with cooperative threads, if you don't want to reason about the scheduler you have to assume it's nondeterministic.
20:53:36 <kamatsu> throw in shared memory, and you probably still get the same problems.
20:55:18 <kamatsu> basically each state transition is a bit more coarse, but they're still there.
20:55:26 <kamatsu> and still observable from the outside.
20:56:55 <kamatsu> I suppose the solution is to not use shared memory, and rely on process calculi which are much more functional in flavour.
20:57:15 <chrisdone> right, if you don't want to reason about the scheduler i guess no assumptions can be made there
20:57:18 <kamatsu> I'm not an expert in this field though so there's probably a lot of research I'm missing.
20:59:02 <kamatsu> I doubt IO as it stands could be given any kind of proper semantics. Most of the denotations used by haskellers assume sequential composition works abstractly.
20:59:52 <chrisdone> what do you mean by abstractly? as opposed to what?
21:00:04 <kamatsu> sorry, i mean, such that the intermediate states are not observable.
21:00:14 <chrisdone> ah, gotcha
21:00:53 <kamatsu> It'd be nice to have a good model though, for "fast and loose" reasoning. Right now we have great equational reasoning for deducing what IO program is produced
21:01:08 <kamatsu> but the semantics of that IO program are basically a mixture of muddled ideas.
21:03:53 <chrisdone> so you mean, e.g. getLine >>= putStrLn in haskell is no different to writing Bind GetLine PutStrLn :: IO' (), in a (g)adt, but that the runIO' :: IO' () -> RealWorld intrepreter doesn't have any clear semantics?
21:04:04 <kamatsu> basically, yes.
21:04:26 <kamatsu> or rather, runIO' can't have the type:: IO' () -> RealWorld -> RealWorld
21:04:41 <kamatsu> (which most Haskellers assume)
21:05:06 <kamatsu> it must have a type like IO' () -> RealWorld -> [RealWorld] or some stream of worlds like that
21:06:37 <clahey> Does anyone know why this wouldn't cause my main loop to exit when the window is closed:
21:06:51 <clahey>    Gtk.onDelete wind (const (Gtk.mainQuit >> return False))
21:07:09 <kamatsu> The exact transformations to the world are not specified either, but that's pretty much impossible to do seeing as we have no idea what a World actually is.
21:07:17 <tabemann> I'm tend to rather prefer the interpretation that (>>=) as implemented by IO doesn't *do* anything aside from compose an imperative computation that is returned to the Haskell runtime and then executed
21:07:47 <startling> well, it gives you the result.
21:07:50 <clahey> That is in the IO for my window creation and the window shows up when I execut Gtk.mainGUI
21:08:26 <clahey> tabemann, Well, the result isn't necessarily executed.
21:08:52 <kamatsu> tabemann: right, but I'm saying the "executed" part is left intentionally vague
21:09:16 <kamatsu> and the semantic model of IO execution that Haskellers tend to use is actually not right
21:09:17 <clahey> Is there a better place to ask about gtk bindings?
21:09:27 <kamatsu> clahey: sorry, I'm not familiar with Gtk2Hs
21:09:28 <tabemann> well of course it is, as a given Haskell thread has no control over much of what happens in the outside world
21:09:51 <kamatsu> tabemann: sure, but even assuming that your Haskell program is a master of its own universe
21:09:56 <clahey> kamatsu, What is the semantic model of IO execution the Haskellers tend to use?
21:10:01 <clahey> that(
21:10:02 <tabemann> the idea that talking to the outside world can be given *any* denotational semantics assumes complete control of the machine and all hardware attached to it (i.e. you can't have things like network IO)
21:10:03 <clahey> *
21:10:10 <kamatsu> clahey: a sequential state transformer of RealWorld.
21:10:50 <clahey> Except that RealWorld can change state without executing any IO, so that can't be right.
21:10:56 <tabemann> I've heard some people naively use that model, but then I've heard many others use the model that I prefer
21:11:19 <startling> clahey, every action does nondeterministic things before it gets executed
21:11:39 <kamatsu> tabemann: Your model is equivalent, you're just moving the state transformer into the Haskell runtime.
21:11:39 <clahey> startling, I suppose.
21:11:49 <startling> but yeah, the RealWorld model never clicked with me either
21:11:51 <kamatsu> tabemann: At some point, your IO program has to be executed.
21:12:00 <startling> its an especially bad pedagogical device.
21:12:05 <tabemann> kamatsu: no it isn't, because I'm not making any assumptions about the semantics of said imperative computation
21:12:17 <clahey> I think of the IO Monad as a Monad to generate an imperative program.
21:12:34 <startling> a Writer of function calls
21:12:38 <kamatsu> tabemann: Surely you want to reason about what effects the IO computation has?
21:12:45 <clahey> startling, Right.
21:13:09 <kamatsu> tabemann: You want to reason about the mutable state used in your IO program?
21:13:17 <tabemann> kamatsu: but I *can't* reason about it, due to shared memory (between threads), shared filesystems (between threads and processes), and shared networks (between me and the outside world)
21:13:20 <clahey> It is true that it'd be nice to reason about things like IOArray and IORef.
21:13:58 <kamatsu> tabemann: Right, but in order to believe yourself that you've written a program that does what you want, you'll have to use some approximate semantic model that convinces you.
21:14:46 <tabemann> the closest thing I can believe I do have control over is the threads in a given process, but even then things are necessary to actually wring any useful semantics out of them, such as STM or, failing that, MVars
21:15:57 <clahey> I'm thinking of writing a function :: (a -> (a, Bool)) -> a -> IO a that returns either the value of a after the given function returns (a, False) or the value of a after 100 ms.
21:16:03 <clahey> Or possibly 10ms.
21:16:22 <kamatsu> clahey, a while ago i looked at a library called Orc that was really good for that sort of thing
21:16:27 <elliott> clahey: should be (a -> Maybe a)?
21:16:33 <elliott> seems more elegant
21:16:46 <clahey> elliott, You want the return value at the end.
21:16:47 <kamatsu> elliott: Maybe a is not isomorphic to (a, Bool)
21:16:52 <elliott> I know it's not isomorphic
21:16:57 <elliott> but you can go both ways (with a little overhead).
21:17:01 <elliott> and the Maybe form seems more idiomatic.
21:17:10 <clahey> So, yeah, you could do that and your function would just have to keep the old version.
21:17:32 <clahey> I suppose it would be closer since usually when the function returns False, it will probably return the passed in value.
21:17:46 <clahey> elliott, I would point out that you can rewrite my type.
21:17:55 <clahey> :: State a Bool -> a -> IO a
21:17:56 <chrisdone> yeah, i don't quite get the RealWorld transformer model as a reasoned model for IO, but i can see its uses for implementation (i.e. ensuring sequence and as a way to have thunks that never get updated)
21:18:31 <clahey> I think that's right.  I haven't looked at the definition of State in a while.
21:18:58 <kamatsu> chrisdone: The RealWorld state-transformer thing is often used as a semantics for imperative programs too
21:19:40 <kamatsu> Obviously in the case of imperative programs it's much more necessary because we have no other tools at our disposal
21:20:03 <kamatsu> can't write any pure functions with clean(er) denotations there.
21:20:25 <kamatsu> But, as I mentioned, it falls down as soon as you have to observe intermediate states.
21:20:41 <clahey> Then my function is just calling runState until the return value is False or time runs out.
21:21:41 <bb010g> clahey: Have you thought of using Either instead of (a,Bool)?
21:21:52 <kamatsu> clahey: could you use async or orc?
21:22:00 <clahey> bb010g, That wouldn't be useful.
21:22:11 <clahey> bb010g, No different from Maybe.
21:22:19 <clahey> bb010g, And there is no extra data to return.
21:22:26 <clahey> kamatsu, I'm looking at Orc right now.
21:23:14 <bb010g> clahey: You could use Right a instead of (a,False), and Left a instead of (a,True).
21:23:29 <clahey> bb010g, Oh, Either a a?
21:23:30 <chrisdone> i tried modelling javascript with a type system with effects so that all impure functions became transformers of one or more variables (e.g. ‚Äú(function(x){x.y=1;return x}) : (!x,{x:Int}) -> (!x,{x:Int})‚Äù where !x is (improvised) syntax for implicit effecting type variables), but Conor McBride ruined my shit when he asked how HOFs would work. not easy this type theory stuff, is it? almost like it requires a degree in type theory or
21:23:31 <chrisdone> something ;p
21:23:46 <bb010g> clahey: Yes. *derp*
21:24:29 <clahey> bb010g, I think using State a Bool is much closer to the concept being mapped which is a stateful computation.
21:24:46 <clahey> a -> Either a a isn't as simple as State a Bool.
21:28:05 <pentace> chrisdone: What does "(!x,{x:Int})" denote in that type?
21:29:00 <pentace> Or should it be {y : Int}?
21:29:26 <chrisdone> pentace: apologies for the improvised syntax, i meant that {x:Int} is a record containing one field, type-variabled as `x', and that the function returns a tuple of two values, that record, and a new value of the field `x' of said record
21:29:48 <chrisdone> (maybe i should've written (!y,{y:Int}))
21:30:43 <chrisdone> e.g. hPutChar :: Handle -> Char -> IO (), could instead by styled as hPutChar :: Handle -> Char -> (Handle,())
21:30:49 <clahey> kamatsu, So, it looks like Orc might be useful.  I'm not sure.
21:31:21 <elliott> clahey: I don't believe the State based form elucidates the matter.
21:31:53 <chrisdone> (as long as Handle is inclusive of other states, i suppose)
21:32:43 <pentace> Hhm, I don't understand what the other type-variable "x" denotes :S
21:33:20 <clahey> elliott, Is one of the other suggestions better?
21:33:37 <elliott> I liked my suggestion :P
21:33:38 <clahey> So, it looks like Orc is a lot like [] as a Monad.
21:33:50 <clahey> a -> Maybe a.
21:33:54 <clahey> Right.
21:34:28 <clahey> That is a pretty reasonable solution, but I'm enamored with mine since it means I can use all the Monad tools.
21:34:49 <clahey> Though I suppose you could write a Monad for (a -> Maybe a)?
21:35:17 <clahey> But there's a bunch of code that's already built to support State.
21:35:38 <elliott> I really don't think you'll find State very useful there.
21:35:48 <elliott> I suspect you'll always just do get and put all the time.
21:35:58 <elliott> but feel free to try.
21:36:05 <clahey> elliott, Lenses have a bunch of built in support for State is one thing.
21:36:27 <elliott> sure. tehy also have a bunch of built in support for functions
21:36:35 <elliott> you can write mine as ReaderT a Maybe a, if you want, fwiw
21:36:59 <clahey> But right now I'm thinking Maybe it's a -> IO (Maybe a)
21:37:16 <clahey> Or a -> MaybeT IO a?
21:37:56 <clahey> That way I could do any calculations in there that I want.
21:38:04 <clahey> I could use IOArray.
21:38:44 <kamatsu> chrisdone: Have you seen disciple?
21:38:54 <chrisdone> pentace: hm. so if i can improvise: function(x){return x} : a -> a, function(x,y){ return x } : (a,b) -> a, function(x){ return x.y } : {a:a'} -> a', function(x){ return {foo:x.y+x.z} } : {a:Int,b:Int} -> {c:Int}
21:38:55 <chrisdone> pentace: and let's say if i want to be concrete: function(x){return x.foo} : {Foo:a} -> a
21:39:09 <chrisdone> kamatsu: i did see a brief description. does it have fine-grained effect typing?
21:39:12 <kamatsu> yes
21:39:19 <chrisdone> cooooll
21:39:41 <clahey> kamatsu, Is there a description somewhere of Orc with less jargon?
21:39:55 <kamatsu> I only know of the Orc paper, which I read a year ago.
21:40:26 <kamatsu> is that what you're looking at?
21:41:02 <chrisdone> haha, woah, so it does!
21:41:09 <kamatsu> bias: I know the lead developer of Disciple (he works at the same university) and I'm looking at doing some projects relating to it.
21:41:19 <kamatsu> but it seems like something very similar to what you want
21:41:21 <clahey> kamatsu, I found slides, but a paper sounds better.
21:41:38 <chrisdone> -- | Print out all Nats in a list
21:41:38 <chrisdone> dumpNats [r1 r2 : Region]
21:41:38 <chrisdone>         (xx : List r1 (Nat r2)) { Read r1 + Read r2 + Console | Use r1 + Use r2 }
21:41:38 <chrisdone>         : Unit
21:41:43 <chrisdone> that's awesome
21:42:00 <kamatsu> yeah, right now he's working on the core language, for which there exists a prototype compiler
21:42:08 <chrisdone> pentace: so disciple is pretty much doing what i meant, but with clever things like rigor and brains
21:42:15 <kamatsu> eventually this core language is hoped to become a sort of universal core for a variety of functional languages.
21:42:45 <kamatsu> disciple (the source language) will be equipped with an equally powerful, but less verbose type system, it's hoped.
21:42:47 <chrisdone> right, very cool indeed
21:42:52 <chrisdone> nod
21:43:10 <chrisdone> no one would want to write out all those types every time, but definitely fine for a Core-like language
21:43:23 <chrisdone> what does this mean for garbage collection?
21:44:02 <chrisdone> it seems like it could work without a garbage collector
21:44:05 <pentace> chrisdone: Ah, somewhat clearer now, thanks for explaining
21:44:06 <kamatsu> so it's possible to use region typing to obviate garbage collection entirely, but Ben hasn't gotten that far yet, he will include a garbage collector I think, but possible eliminate most uses of it.
21:44:40 <kamatsu> I'm not certain about that though, I think he's changed views on that issue a few times
21:45:02 <chrisdone> hm, right. certainly if there is a GC it will be very well informed =)
21:45:07 <pentace> Oh wait, now I get the "implicit " part
21:45:27 <kamatsu> When haskell-type-exts is done, I'm going to write a DDC core backend for Haskell
21:45:55 <h4199> So disciple would be like LLVM IR for functional languages? Or did I miss something?
21:46:10 <kamatsu> part of his approach lately has been to make the effect/closure/region typing part an orthogonal layer in the type system, so it should be easy enough to compile it to a "pure" version of DDC core
21:46:26 <kamatsu> h4199, yes, a universal system F-whatever, I guess.
21:46:36 <h4199> Very neat
21:46:52 <chrisdone> kamatsu: is the ghc api insufficient for the type information you need?
21:47:04 <kamatsu> rather, I want a compiler based on the haskell-suite front-end
21:47:15 <chrisdone> fair enough
21:47:22 <kamatsu> too many Haskell compilers rely on GHC's infrastructure and too many other Haskell tools rely on haskell-src-exts
21:47:34 <kamatsu> the result is the inconsistencies between the two make for headaches using or writing any tools
21:47:51 <chrisdone> i'm writing a core->js compiler at present, btw =p
21:48:01 <h4199> for Fay?
21:48:03 <kamatsu> If a good haskell compiler exists for haskell-suite, it will encourage feature parity and cooperation between those two projects.
21:48:42 <kamatsu> that said, it seems to be taking quite a long time to write an OI(X) type-checker for h-src-exts that works, so maybe it's not viable
21:48:52 <chrisdone> mm, it has been a while
21:49:25 <chrisdone> h4199: as an alternative. fay is lead by bergmark who wants to keep it using haskell-suite
21:50:14 <kamatsu> right now an LLVM backend exists for ddc-core, I suspect that others would be supported as well in future (perhaps JS? would be nice)
21:50:26 <chrisdone> kamatsu: apparently spj was asked about haskell-suite and fay and what he thought about the feasiblity of implementing haskell's type system, and he said "i've been writing it all my life, so‚Ä¶ it's not easy =)"
21:50:49 <kamatsu> yeah, so I have implemented an OI(X) type-checker in the past, for a small core language, using Agda.
21:50:57 <h4199> mmm, haskell has suddenly gotten more options wrt JS compilation than I can explore in my spare time, this is a good thing I suppose
21:51:04 <kamatsu> it took me about half a year to write..
21:51:08 <chrisdone> haha
21:51:18 <chrisdone> though, in agda, that's nice
21:51:18 <lykos> hmm
21:51:29 <kamatsu> The goal was to prove soundness of type inference
21:51:34 <kamatsu> but i never got that far
21:52:00 <chrisdone> what does the ‚ÄúOI(X)‚Äù phrase mean?
21:52:04 <kamatsu> outsideIn(X)
21:52:11 <kamatsu> it's the name of the Haskell type inference algorithm
21:52:19 <kamatsu>  / system
21:52:22 <chrisdone> ahh
21:52:32 <kamatsu> or rather, the GHC inference system
21:52:39 <kamatsu> because it supports GADTs (in fact that's the point)
21:53:04 <kamatsu> For H98 you can get away with HM with some tweaks
21:53:05 <chrisdone> otherwise it would merely be HM?
21:53:08 <chrisdone> right
21:55:13 <kamatsu> the tweaks come in because of type-classes
21:55:34 <kamatsu> elaborating to System Fc not just System F
21:57:15 <kamatsu> my Agda implementation took a long time though because I had to deal with a lot of issues that are complicated in Agda, but less complicated in a compiler.
21:58:04 <kamatsu> e.g, the best way to represent variable names took huge amounts of my time
21:58:45 <kamatsu> also, in most type inference algorithms, they magically produce a "fresh" unifiable type variable from nowhere, but obviously in Agda I'm using de bruijn indices for unification variables and things get more complicated..
21:59:54 <chrisdone> heh, was it a fast compiler? +p
22:00:33 <chrisdone> well, inferencing algorithm
22:00:38 <chrisdone> / implementation
22:00:54 <chrisdone> h4199: https://github.com/chrisdone/fore
22:01:17 <kamatsu> no, it was hella slow
22:04:04 <Riccardo> is there any known problems in cabal/haddock with the use of "--executables" and "--internal" together? "--executables" works, but "--internal" has no effect
22:04:20 <h4199> chrisdone: you seem to be having fun with that documentation
22:05:48 <NihilistDandy> "using de bruijn indices for unification variables" -> "hella slow". I love #haskell
22:08:07 <chrisdone> h4199: yeah =)
22:09:43 <Ghoul_> ddc is really cool
22:09:47 <Ghoul_> kamatsu: are you working on that?
22:10:29 <h4199> chris: did you just move it? I got  a 404 suddenly.
22:10:31 <NihilistDandy> chrisdone: 404?
22:10:35 <NihilistDandy> Yeah, same
22:12:04 <chrisdone> oh, i made it private again, thought you were finished looking =p
22:12:28 * chrisdone publicizes for a while
22:13:49 <NihilistDandy> Oh, that looks cool
22:16:12 * NihilistDandy begins using in production immediately. Take that JS developers
22:16:41 <chrisdone> ;)
22:17:00 <zrathustra> hi everyone! I'm student attempting to learn Haskell via the Write You a Scheme in 48 hours and I was stuck on an exercise and was hoping to get a quick answer regarding monads (I know, I know) and the parsec library
22:17:12 <NihilistDandy> Shoot
22:17:28 <zrathustra> would anyone mind answering a quick question?
22:17:45 <path[l]>  dont ask to ask, just ask :)
22:17:49 <NihilistDandy> Just go ahead and ask. I'm sure you'll get a few :)
22:20:24 <NihilistDandy> chrisdone: The output.js is definitely a lot nicer than the example in the README :D
22:20:57 <chrisdone> NihilistDandy: did you scroll to the bottom? =p
22:21:01 <Riccardo> i got it to work by passing --haddock-options="--ignore-all-exports", since i could see cabal was not appending "--ignore-exports" when supplied with "--internal"
22:21:06 <NihilistDandy> chrisdone: Agh
22:21:13 <zrathustra> I'm trying to parse escaped characters such as \n or \", and return that as a single character, or just match any other character other than \" (i.e. noneOf "\"")
22:21:16 <NihilistDandy> Well, up until that point, it's pretty nice :D
22:21:18 <chrisdone> NihilistDandy: haha
22:21:31 <zrathustra> but the former requires matching a string and the latter requires matching a character
22:21:39 <Riccardo> is it a bug? it doesn't really make sense to do nothing on a flag. other unknown flags throw an error
22:21:52 <zrathustra> how would I cast a Parser Char action to Parser String?
22:24:11 <chrisdone> zrathustra: to "cast" (we don't use that terminology, but i'm going along with it), you could use: fmap (\x -> [x]) theThingToCast
22:24:40 <zrathustra> what's the proper terminology?
22:24:59 <zrathustra> also, is there a good in-depth explanation of monads in general anywhere?
22:25:04 <NihilistDandy> Really you're just deconstructing the String (a list of Chars) into the constituent Chars
22:25:15 <zrathustra> everywhere I've tried has been very handwavy
22:25:22 <chrisdone> what about LYAH?
22:25:27 <zrathustra> and not helpful to my understanding of it
22:25:29 <chrisdone> @lyah
22:25:29 <lambdabot> Unknown command, try @list
22:25:32 <chrisdone> @where lyah
22:25:32 <lambdabot> http://www.learnyouahaskell.com/
22:26:01 <chrisdone> http://learnyouahaskell.com/a-fistful-of-monads
22:26:09 <zrathustra> thanks
22:26:22 <zrathustra> is another source from the mathematical point of view?
22:26:40 <chrisdone> wadler's original paper, perhaps
22:26:42 <NihilistDandy> zrathustra: Monads are not as complicated as they're made out to be. I found applicatives more complicated, really, but once I got those monads weren't much trouble
22:26:48 <johnw> zrathustra: Awodey's book on Category Theory, or Wadler's paper
22:26:50 <chrisdone> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
22:26:54 <NihilistDandy> Also, just learning the monad laws may help
22:27:34 <zrathustra> I prefer to think mathematically about programming (haskell is a godsend in this sense) rather than just trying to convert C programming paradigms to convoluted metaphors in trying to explain it
22:27:37 <chrisdone> anything by wadler is pretty much awesome, if i were starting from fresh, i'd read his papers, as they were written in a culture that didn't already know what monads were
22:27:39 <zrathustra> awesome, thanks!
22:31:20 <h4199> zrathustra: I you are still confused later you can post your problem code on lpaste and someone may be able to  point you in the right direction
22:31:27 <h4199> if*
22:31:36 <zrathustra> ok, thanks!
22:31:59 <zrathustra> I think I'm going to dig into lyah and the monad paper(s) before I proceed with any more copy pasta coding
22:32:57 <mercuryrising> is there anything for haskell like bpython, where when you start typing and all the options that fit are presented?
22:34:24 <mercuryrising> (something like this - http://bpython-interpreter.org/screenshots/)
22:35:16 <NihilistDandy> mercuryrising: Tab completion will do some of that (say import Data.<Tab> and it will list items), but the argument stuff not so much
22:35:20 <kamatsu> Ghoul_: I'm not working on it at the moment, but I know it fairly well
22:35:23 <Ghoul_> the ddc compiler stuff is really cool
22:36:01 <Ghoul_> kamatsu: is there a haskell frontend for ddc + its llvm compiler?
22:36:19 <kamatsu> no, that's a project I wish to undertake in the future
22:36:37 <kamatsu> when ddc core's new orthogonal semantics are more well cooked and haskell src exts gets a robust typechecker.
22:37:44 <kamatsu> Repa-plugin already translates ghc core to ddc core internally to optimise using series expressions, thats where this idea started
22:38:13 <carter> Ghoul_: llvm-general has more powah though :)
22:41:55 <Ghoul_> carter: :P just checking if there was somewhere to jump ship to!
22:42:25 <carter> ddc is the wrong boat, though tis definitely a cool tool / research endeavor
22:43:35 <Ghoul_> what do you mean by "wrong boat"?
22:43:57 <carter> "jump ship"
22:43:59 <carter> wrong boat
22:44:00 <carter> :)
22:44:02 <Ghoul_> I got that part
22:44:04 <Ghoul_> but what makes it wrong?
22:44:27 <Ghoul_> is it rotted? dead? abandoned? designed wrong?
22:44:37 <carter> not a 2am topic
22:44:42 <carter> its a cool project
22:44:48 <carter> but its not the sequel :)
22:45:41 <kamatsu> carter: why not?
22:46:11 <carter> lets frame it in the converse: why?
22:46:35 <carter> convince me why i should invest in making ddc the successor to ghc/haskell
22:46:46 <carter> i'm intrigued by say, idris
22:47:02 <carter> and i think it gives me a lot of the nice bits of ddc
22:47:05 <carter> plus a lot more
22:47:45 <kamatsu> How do idris and ddc overlap at all?
22:47:55 <carter> both are strict
22:48:04 <kamatsu> that's hardly the nicest part of ddc.
22:48:06 <carter> and have interesting models for tracking sets
22:48:09 <carter> whats the nice part?
22:48:15 <carter> educate me
22:48:17 <kamatsu> effect typing, region inference
22:48:29 <carter> region ionference for doing ___
22:48:42 <carter> memory allocation?
22:49:05 <kamatsu> partly, but also as a way of restricting aliasing
22:49:24 <carter> ok
22:49:27 <kamatsu> which allows for a number of useful optimisations, even in a functional setting
22:49:31 <carter> and thats cool
22:49:32 <kamatsu> *non-
22:49:36 <carter> but
22:49:41 <kamatsu> e.g you can do deforestation in the presence of certain effects
22:49:45 <Ghoul_> shhh
22:49:47 <Ghoul_> I didn't mean this.
22:49:52 * Ghoul_ gives everyone a beer
22:50:07 <carter> kamatsu : you're giving great reasons why DDC is a cool / valuable research engineering endeavor :)
22:50:09 <carter> and props!
22:50:23 <kamatsu> then I fail to understand what makes it not a valuable sequel
22:50:36 <carter> this is great compiler tech
22:50:48 <carter> but that doesn't tell me why i should switch to programming there :)
22:50:56 <carter> and thats fine
22:51:02 <carter> :)
22:51:17 <kamatsu> uh, to take advantage of the optimisations, and the reasoning benefits of finer control of effects?
22:51:23 <kamatsu> Haskell lumps all effects into the IO sin bin
22:51:29 <carter> kamatsu: i have my own plans on that :)
22:51:41 <carter> yes
22:51:57 <carter> but for my perf sensitive code, i've an even better optimizor
22:51:58 <carter> :)
22:52:00 <carter> me
22:52:15 <carter> lets ignore the HPC segment
22:52:21 <carter> i'm writing normal math code
22:52:26 <carter> or a computer algebra system
22:52:27 <carter> or something
22:52:34 <carter> what does DDC let me do in my engineering
22:52:42 <carter> ignoring performance
22:52:59 <carter> i agree, a finer grained Effects_{set of effects}
22:53:01 <carter> is valuable
22:53:35 <kamatsu> I'm not sure what you're asking for here
22:53:43 <kamatsu> what criteria would you consider sequel-worthy?
22:54:17 <carter> hrmm
22:54:39 <Ghoul_> the ability to mash ctrl+space and have it write what Im thinking
22:54:48 <kamatsu> as far as I can see, the main pain points of haskell are: insufficiently powerful type system to express invariants, overly coarse handling of effects, and poor handling of destructive updates
22:55:04 <kamatsu> DDC assists, but does not completely solve, all of those problems.
22:55:15 <zvrba> kamatsu: poor in what way?
22:55:33 <carter> kamatsu: hence why i think in a few years Idris will be intriguing
22:55:49 <carter> it lets me do both the things you're pointing at DDC for
22:56:12 <carter> and dependenttypes with totality+soundness when i really care
22:56:23 <carter> or am I not understanding you well
22:56:24 <NihilistDandy> carter: Agreed. Idris has serious potential
22:56:28 <kamatsu> I agree that dependent types and totality checking are great.
22:56:37 <kamatsu> (but there's nothing in DDC that precludes them!)
22:56:48 <carter> yes, aside from not having them yet
22:57:01 <carter> and it really seems that adding that post facto gets hard
22:57:18 <kamatsu> I disagree with that hardness assessment
22:57:24 <carter> subtle
22:57:27 <carter> then
22:57:39 <kamatsu> sure
22:57:46 <carter> subtle things tend to be hard :)
22:57:50 <kamatsu> but Idris in turn lacks proper effect or region management.
22:57:57 <carter> true
22:58:03 <kamatsu> adding those would be equally subtle
22:58:07 <carter> ineed
22:58:11 <carter> so its a race :)
22:58:13 <carter> but
22:58:20 <carter> but does the regions let me do enough?
22:58:37 <kamatsu> do enough‚Ä¶what?
22:58:46 <carter> my main interest in regions is for suppporting distributed systemsm programming
22:58:59 <carter> "where is the memory loclation"
22:59:00 <carter> *location
22:59:09 <carter> what does regions let me do better
22:59:21 <carter> when i'm writing pretyt high level code
22:59:33 <carter> there definitely some neat use cases
22:59:46 <carter> like, helping statically manage some memory life times
23:00:40 <carter> perhaps give me more context: whats your work on ddc?
23:00:43 <Ghoul_> 8 space tabs and nesting keywords in the whitespace
23:00:48 <Ghoul_> is honestly really really pretty
23:00:58 <kamatsu> Plus being able to do things like write programs (via distinctness witnesses) that destructively update variables while still being provably safe from well-typedness
23:01:22 <kamatsu> I don't work on ddc, as I mentioned earlier
23:01:24 <carter> oh
23:01:27 <kamatsu> but I am quite familiar with it
23:01:28 <carter> i miss heard
23:01:39 <kamatsu> (and i know its primary author)
23:01:42 <carter> whats the safety of updated example
23:01:45 <carter> show me
23:01:47 <carter> :)
23:01:49 <carter> edumacate me
23:02:36 <kamatsu> depends on what domain-specific notion of safety you want
23:02:59 <kamatsu> but, typically, you want to know that if i update variable x, it doesn't change variable y
23:03:03 <kamatsu> if you look at a c program like
23:03:14 <carter> yes
23:03:16 <kamatsu> foo (int* x, int* y) { *x = 10; return y }
23:03:32 <kamatsu> it's impossible to say whether y will be changed or if it will be overwritten with 10.
23:03:37 <carter> yes
23:03:43 <carter> unless you just compare pointers
23:03:49 <carter> or have Restrict qualifiers
23:03:51 <carter> or such
23:03:55 <kamatsu> restrict qualifiers?
23:04:08 <carter> you can tell the c compiler (C99 or newer)
23:04:15 <carter> "i swear these guys don't alias"
23:04:22 <kamatsu> right, but there's no checking
23:04:22 <carter> using the restrict type qualifier
23:04:30 <carter> true
23:04:37 <carter> but this is more so a matter of optimization
23:04:48 <carter> than of writing correct code
23:04:50 <kamatsu> disciple lets you demand that x and y do not alias and will ensure that this is the case using witnesses.
23:05:02 <carter> ok
23:05:13 <kamatsu> no, because pointer aliasing affects correctness
23:05:14 <carter> so discipline would be awesome for mobile / embedded dev :)
23:05:27 <carter> kamatsu only if the optimizer does it wrong
23:05:36 <kamatsu> the optimizer has nothing to do with it
23:05:37 <carter> the C compiler assumes everything aliases unless it can prove otherwise
23:05:38 <carter> yes
23:05:39 <carter>  it does
23:05:45 <kamatsu> you want to prove a property about your program
23:05:47 <carter> yes
23:05:50 <carter> so i can optmize it
23:05:52 <wunki> when I have a value of the type (Either String Thumbnail). How can I get to the value of Thumbnail with `>>=`
23:05:59 <kamatsu> no, so you know what values it results in
23:06:03 <carter> yes
23:06:07 <carter> so i can optimize it
23:06:10 <carter> :)
23:06:17 <kamatsu> nothing to do with optimization, let me finish.
23:06:22 <carter> nope
23:06:29 <carter> it has everything to do with optimization
23:06:48 <kamatsu> your precondition for correctness, assuming that you don't want y to be changed, is that {x /= y}
23:06:56 <carter> why
23:06:57 <carter> thats shitty
23:07:06 <carter> no code should depend on that
23:07:08 <kamatsu> so, you should encode such a precondition in the type
23:07:16 <carter> i understand all this
23:08:02 <carter> well, better yet, not have your code depend on that invariant
23:08:07 <carter> because thats terrible code if i needs that
23:08:20 <carter> but i understand your example
23:08:24 <carter> but for me
23:08:29 <carter> that exmaple is about optmization
23:08:38 <carter> for the work i do
23:08:38 <kamatsu> the example is just something I could fit in one line
23:08:45 <carter> fair
23:08:48 <carter> but my point being
23:09:09 <carter> for the software i'm writing, there are certainly pointer where i care about aliasing for correcntess
23:09:12 <kamatsu> any algorithm that relies on destructive update typically needs these properties within their sequential composition.
23:09:25 <carter> *points where I care about aliasing for correcness
23:09:32 <carter> but they really come up in parallel cases
23:09:35 <kamatsu> Right, so you can use region typing in those circumstances.
23:09:43 <carter> i can't
23:09:48 <carter> the types are complex enough as is
23:09:51 <carter> it would be unusuable
23:09:58 <kamatsu> that's pure conjecture
23:10:01 <carter> nope
23:10:04 <carter> i'm writing this code
23:10:26 <carter> the types i have alraeady make smart people go cross eyed
23:11:15 <carter> i can make the code safe by internally doing an extra copy if need be
23:11:35 <carter> actually thanks
23:11:42 <carter> didn't think about that corner case till just now :)
23:11:51 <carter> g2g
23:11:52 <carter> cheers
23:15:10 <piron> wunki: That's a trick question to answer.
23:15:44 <h4199> if*
23:15:57 <h4199> oops ignore that
23:16:28 <wunki> piron: I also think my question was wrong. Let me rephrase. I'm using this: http://hackage.haskell.org/packages/archive/thumbnail/0.7/doc/html/Graphics-Thumbnail.html
23:16:47 <wunki> mkThumbnail returns `IO (Either String Thumbnail)`
23:17:01 <wunki> so I get the (Either String Thumbnail) with `<-`
23:17:15 <wunki> but now I want to supply `Thumbnail` value to a function
23:17:34 <piron> The simplest thing to do is to just pattern match on the Either with case.
23:17:56 <wunki> is the "idiomatic" way to do it with `>>=`?
23:18:05 <piron> That depends.
23:18:30 <piron> If the function you are calling also returns an Either, and it makes sense to think of the thing it does as having some kind of exceptions, it is idiomatic to use (>>=).
23:19:22 <kamatsu> you could also fmap
23:19:36 <wunki> ah, the function doesn't return Either, it get's the ByteString of the thumbnail and uploads it to S3.
23:19:50 <kamatsu> so it's Thumbnail -> IO ()
23:19:51 <kamatsu> ?
23:20:01 <kamatsu> in that case I'd just use case
23:20:39 <wunki> this is the code: https://gist.github.com/wunki/6153836#file-main-hs-L78
23:21:29 * piron feels validated
23:21:41 <chrisdone> would be accurate to say all haskell values have two types, some a and _|_?
23:22:02 <kamatsu> chrisdone: The _|_ type only has one inhabitant, _|_
23:22:12 <kamatsu> or, in a total language, it's empty
23:22:14 <wunki> piron: so, `case` it is? :)
23:22:17 <chrisdone> kamatsu: right, but boxed values can all be _|_
23:22:58 <piron> wunki: That's what I would use. =)
23:22:59 <kamatsu> Right, but it's more a matter of all Haskell types containing _|_ than all values having both _|_ and T
23:23:02 <chrisdone> kamatsu: undefined :: Int is an Int, but the value is _|_
23:23:12 <chrisdone> sure
23:23:13 <kamatsu> sure, but Int contains _|_
23:23:16 <wunki> piron: ok, thank you for your help
23:23:22 <kamatsu> If I go data Void
23:23:23 <piron> chrisdone: Maybe you should reread your question and make sure you asked it right.
23:23:27 <kamatsu> and then go (3 :: Void), that's invalid
23:23:48 <kamatsu> so 3 doesn't have type _|_
23:24:07 <elliott> chrisdone: this seems to be confusion between type level and value level _|_?
23:24:14 <elliott> which are fairly different (only indirectly related)
23:24:17 <chrisdone> kamatsu: but from what i read there is no _|_ value, it's the complete lack of a value, it's like data Void, so it seems like you can only have a type of _|_, not a value?
23:24:33 <elliott> _|_ is a value
23:24:37 <elliott> for instance undefined is _|_
23:24:40 <elliott> and let x = x in x is _|_
23:24:45 <johnw> you just can't evaluate _|_
23:24:49 <elliott> every type has _|_
23:24:52 <elliott> johnw: sure you can
23:24:57 <elliott> it'll just either never finish or produce an error
23:24:57 <chrisdone> hmm
23:25:04 <johnw> well, that's kind of what I meant :)
23:25:05 <kamatsu> if you remove _|_ from the language, you remove turing completeness.
23:25:08 <chrisdone> it seems like a broad definition of "value"
23:25:16 <elliott> chrisdone: it's the denotational semantics definition
23:25:27 <kamatsu> yeah, so, "value" as in, things that are judged to be of a type
23:25:29 <elliott> Integer contains all the integers and _|_, for example
23:25:45 <elliott> if x :: Integer then we say x is a value of type Integer
23:25:50 <chrisdone> well, Int# doesn't have bottom, for example
23:25:52 <elliott> but of course x can be _|_. so this should convince you that _|_ is a value
23:26:01 <elliott> well, Haskell doesn't have Int# :)
23:26:13 <kamatsu> chrisdone: Int# also has bottom.. let x :: Int# = x works, right?
23:26:36 <chrisdone> hmm, not sure. maybe
23:26:38 <kamatsu> bottom is not null.
23:26:45 <chrisdone> no
23:26:46 <chrisdone> You cannot bind a variable with an unboxed type in a recursive binding.
23:26:55 <kamatsu> oh, i didn't realise that
23:27:22 <chrisdone> (http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html#glasgow-unboxed)
23:27:25 <kamatsu> hm, so it's possible that if you program in entirely unboxed types you have a total language, but that aside, all other haskell types have _|_
23:27:38 <chrisdone> nod
23:28:09 <kamatsu> not only that, but some haskell types have even more funny bottom values
23:28:15 <chrisdone> http://en.wikipedia.org/wiki/Bottom_type ‚Üê this page doesn't mention any bottom value, it specifically says that any type of _|_ cannot return a value, hence my confusion
23:28:18 <kamatsu> e.g Maybe has Just _|_ as well as _|_
23:28:27 <elliott> I suggest not using Wikipedia as your source
23:28:28 <kamatsu> chrisdone: that's the type, not the value
23:28:44 <elliott> anyway, _|_ is used to refer to both a type and a value because they're both bottoms of various kinda-(semi)lattices
23:28:45 <kamatsu> Bottom types are types that contain nothing.. but in a turing complete language, they still contain something, that is _|_
23:28:50 <chrisdone> it says it's a "subtype of all types", so hence my question "are all haskell values of type _|_ as well as their other type?"
23:28:53 <elliott> it's a happy coincidence that _|_ happens to contain only _|_ in Haskell.
23:29:15 <elliott> chrisdone: it's a subtype in that every other type is bigger than it
23:29:18 <elliott> (or isomorphic)
23:29:23 <elliott> similarly Int is a subtype of Integer in this sense.
23:29:31 <chrisdone> yeah
23:29:37 <elliott> Haskell does not do this kind of automatic subtyping though. so it's not true to say what you did
23:30:10 <kamatsu> It is true that you can write a function absurd :: forall a. Bottom -> a though, which is your "upcast" for the subtyping
23:30:38 <piron> Even if Haskell had subtyping, giving a value type X would not imply that it also had type _|_.
23:30:41 <kamatsu> (this corresponds to the logical rule that says you can prove anything if you prove that false is true)
23:30:55 <piron> It would imply that it also had type T (or however you want to ASCII-ize "\top").
23:30:55 <kamatsu> yes, it's the other way around
23:31:14 <kamatsu> anything that had type _|_ would have any other type, but not anything of any type would have type _|_
23:31:16 <zRecursive> :
23:31:33 <kamatsu> man, that was a confusing sentence, i apologize
23:31:41 <chrisdone> i got the point =)
23:40:32 <Ghoul_> @pl (\s -> hGetBuf $ handle s)
23:40:35 <lambdabot> (hGetBuf $) . handle
23:40:35 <lambdabot> optimization suspended, use @pl-resume to continue.
23:40:54 <kamatsu> what's this @pl thing?
23:41:02 <kamatsu> oh, pointless
23:41:08 <kamatsu> gotcha
23:41:17 <johnw> huh?  why isn't that just hGetBuf . handle
23:41:31 <Ghoul_> Yeah I ended up just using hGetBuf . handle
23:41:36 <Ghoul_> idk what lambdabot is smoking today
23:41:38 <kamatsu> yeah, do a @pl-resume, Ghoul_
23:41:43 <Ghoul_> @pl-resume
23:41:49 <lambdabot> (hGetBuf $) . handle
23:41:49 <lambdabot> optimization suspended, use @pl-resume to continue.
23:41:52 <kamatsu> hm
23:41:53 <kamatsu> strange
23:42:16 <kamatsu> @pl (\s -> hGetBuf (handle s))
23:42:16 <lambdabot> hGetBuf . handle
23:42:21 <kamatsu> how strange
23:43:03 <hpaste> Justin pasted ‚ÄúMonadic to Applicative‚Äù at http://lpaste.net/91542
23:50:58 <mstksg> can anyone help me turn `foo` from a two-line do block into a one-line statement using applicative style?
23:51:01 <mstksg> http://lpaste.net/91542
23:51:25 <kamatsu> you could just go foo = genList >=> mapM genA
23:51:29 <kamatsu> I think that'd work
23:51:38 <kamatsu> it's not applicative though
23:51:43 <mstksg> kamatsu: that works as well
23:51:49 <kamatsu> alternatively
23:51:50 <mstksg> i was just sure there was a way to make it on one line
23:52:10 <kamatsu> foo a = genA <$> genList a
23:52:28 <kamatsu> that uses functor, but not applicative.
23:53:06 <mstksg> that second one doens't seem to be working for me
23:53:15 <kamatsu> sorry
23:53:16 <kamatsu> i misread
23:53:35 <kamatsu> mapM genA <$> genList a
23:53:37 <kamatsu> er wait
23:53:41 <kamatsu> no that doesn't work either
23:53:44 <kamatsu> yeah, you want the first one
23:54:38 <zRecursive> :t (<$>)
23:54:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:54:54 <mstksg> kamatsu: yeah, the first one works :) `>=>` is a new beast to me and i guess i should learn to use it more.
23:55:04 <kamatsu> it's composition of kleisli arrows
23:55:25 <zRecursive> :t (>=>)
23:55:25 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:55:26 <kamatsu> where kleisli arrows are just functions a -> m b where m is a monad
23:55:47 <kamatsu> the traditional composition order is actually (<=<)
23:55:56 <kamatsu> so you could equivalently write mapM genA <=< genList
23:56:07 <kamatsu> which may or may not be easier for you to read
23:57:05 <mstksg> it works. still can not grasp my mind around it but i think i'll read a few essays.
23:57:11 <mstksg> thank you for your help
23:57:17 <kamatsu> no worries
