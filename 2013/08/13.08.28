00:05:31 <lispy> how is haskell.org down
00:05:36 <lispy> hackage is up
00:09:16 <srhb> lispy: They could be different servers?
00:10:23 <lispy> srhb: sorry, it was more of an exclamation and not an actual question :)
00:10:54 <srhb> :)
00:36:05 <Ghoul_> is there a tutorial for coding using primops anywhere?
00:36:16 <Ghoul_> particularly, the vector ones
00:48:55 <fylwind> @pl qName pred = pred . rootLabel t
00:48:59 <lambdabot> qName = id (fix (const (. rootLabel t)))
00:48:59 <lambdabot> optimization suspended, use @pl-resume to continue.
00:59:21 <Taneb> What's the protocol for getting lambabot to join another channel?
01:02:26 <fylwind> is haskell.org down?
01:02:35 <Lethalman> Taneb, isn't it a configuration file?
01:03:32 <fylwind> @pl f x = True
01:03:32 <lambdabot> f = const True
01:04:10 <notdan> fylwind: does seem like so to me
01:06:46 <Kneiva> something wrong with haskell.org?
01:07:38 <Kneiva> ah, should read back before asking =P
01:08:26 <basvandijk> It's down for me. Which is annoying just before ZuriHac 2013.
01:16:54 <Iceland_jack> basvandijk: I went to haskell.org to read up on ZuriHac 2013 *facepalm*
01:28:20 <fylwind> man, great time to have Hoogle down :(
01:28:29 <johnw> fpcomplete.com/hoogle
01:28:47 <fylwind> awesome, thanks!
01:30:15 <johnw> also, having hoogle run on your local machine is pretty trivial
01:31:28 <fylwind> hrm I guess I can look into that
01:33:06 <johnw> http://newartisans.com/2012/09/running-a-fully-local-hoogle/
01:41:50 <supki> johnw: what's bootstrap.sh?
01:41:56 <supki> oh, cabal thing
01:42:43 <supki> I think it's easier to backup cabal binary somewhere than remove it and then bootstrap :)
01:42:49 <johnw> you don't strictly need to do that
01:45:53 <johnw> here's the script I run these days: https://gist.github.com/6363683
01:46:36 <supki> now I wonder that would happen if someone uploads package called world
01:46:50 <johnw> hehe
01:55:33 <fylwind> man, I tried to make a polymorphic function that accepts an 1 to 3 arguments ... and totally failed :(
01:57:57 <notdan> fylwind: what have you tried?
01:58:00 <lurkorg> fylwind: you could wrap the second and third arguments in Maybe
01:58:09 <notdan> what's the type of the function you want to write?
01:59:02 <johnw> fylwind: http://www.haskell.org/haskellwiki/Varargs
01:59:04 <johnw> once it's back up :)
01:59:27 <fylwind> it was kind of a waste of time, but basically I just wanted to write a "parse" function that accepts some "input", and optionally a "name", and also optionally a "state" (wrapped around Parsec essentially)
01:59:58 <notdan> http://webcache.googleusercontent.com/search?q=cache:-_n4CZMTV6oJ:www.haskell.org/haskellwiki/Varargs&client=firefox-a&hs=TSI&hl=en&gl=ru&strip=1
02:00:08 <fylwind> it would've been fine if not for the fact that I need to somehow build a rather complex contraint (Stream s Identity t) into the function signature
02:01:13 <fylwind> when it got to the point where I had to use UndecidableInstances I realized that I should probably turn back before it's too late :/
02:01:33 <notdan> hm, yeah that doesn't sound right
02:02:58 <notdan> I don't know what's that Stream you are using but what you are trying to do sounds like a legitimate case for Maybe
02:03:34 <fylwind> Maybe. :) anyway, I just decided it was less frustrating to write 3 overloads with slightly different names
02:03:51 <supki> well, UndecidableInstances is okay as long as compilation terminates
02:09:10 <basvandijk> Yay! haskell.org is online again!
02:15:18 <Zplay> Hi, I have a problem install "gitit", when using cabal install gitit or cabal install in gitit source folder, I have a problem with dependnecies : http://pastebin.ca/2439842
02:24:05 <notdan> Zplay: sounds like some of the packages that you usually get bundled with ghc (process, hpc) are quite old. What version of ghc are you using?
02:24:27 <notdan> Also you can try "cabal install . 'zip-archive ==0.1.3.3'"
02:24:29 <supki> paste says ghc-6.12.1
02:24:29 <Zplay> notdan, I'm using the ghc6 package from debian, I think it's too old too, I'm going to install ghc7 by hand
02:27:42 * hackagebot Chart 1.0 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.0 (TimDocker)
02:27:44 * hackagebot Chart-cairo 1.0 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.0 (TimDocker)
02:27:46 * hackagebot Chart-gtk 1.0 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.0 (TimDocker)
02:27:48 * hackagebot Chart-diagrams 1.0 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.0 (TimDocker)
02:35:41 <Placinta> Does an expression like (+).(-) make any sense?
02:37:14 <Kinnison> Only if you have a Num a => Num (a -> a) instance
02:38:04 <Placinta> I don't
02:39:02 <Kinnison> Then no :-)
02:39:26 <arkeet> @let import Data.NumInstances
02:39:27 <lambdabot>  Defined.
02:39:32 <arkeet> :-)
02:39:37 <arkeet> :t (+).(-)
02:39:38 <lambdabot> Num a => a -> (a -> a) -> a -> a
02:39:49 <arkeet> > (+).(-) $ 1 2 3
02:39:50 <lambdabot>   <(Integer -> Integer) -> Integer -> Integer>
02:40:00 <arkeet> > ((+).(-)) 1 2 3
02:40:07 <lambdabot>   0
02:40:12 <arkeet> > ((+).(-)) x y z
02:40:18 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
02:40:18 <lambdabot>                ...
02:40:20 <arkeet> err
02:40:21 <arkeet> > ((+).(-)) x f z
02:40:22 <lambdabot>   x - z + f z
02:40:34 <arkeet> please don't use that instance.
02:40:36 <arkeet> it's awful.
02:40:37 <arkeet> > 2 3 4
02:40:39 <lambdabot>   Could not deduce (GHC.Num.Num t)
02:40:39 <lambdabot>    arising from the ambiguity check for `e...
02:40:49 <arkeet> er
02:40:55 <arkeet> that used to not happen.
02:41:01 <arkeet> ok bye
02:44:59 <nkpart> Hey, an Mac OS Mavericks users around? I'm having trouble getting anything to cabal install
02:45:32 <fylwind> note to self: many (many (...) ) = infinite loop
02:51:28 <Kneiva> nkpart: what kind of trouble?
03:07:43 * hackagebot hprotoc 2.0.15 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.15 (DavidFeng)
03:09:10 <totte> What would the disadvantages of building GHC and the libraries I use with --enable-library-profiling be? I don't use it, but I suppose it could come in handy once I've learned more.
03:10:16 <donri> totte: one obvious disadvantage is compiling everything twice
03:10:39 <donri> totte: but if you don't, you have to reinstall everything later (which can be messy)
03:11:42 <totte> donri: I'd rather do it once than having to rebuild stuff later... It'll just add a "profiling-copy" of each library, I assume?
03:12:21 <totte> So it takes more time and space, nothing else?
03:25:13 <ibotty> hi, i have a problem with cabal (0.14 as well as 0.18 from today's git)
03:25:51 <ibotty> it says it cannot find a package although it is in ~/.cabal/packages/hackage.haskell.org/00-index.tar
03:26:03 <ibotty> (it's xml-conduit)
03:26:18 <ibotty> cabal list conduit finds a few packages but not that one
03:26:25 <ibotty> hwo can i debug that further?
03:28:01 <donri> totte: you'd add profiling: True to ~/.cabal/conf
03:28:04 <donri> config
03:28:17 <donri> library-profiling: True
03:28:54 <totte> donri: Okey, thanks.
03:33:28 <kryft> If I have try A <|> B, shouldn't the parser end up trying B even if A fails because of calling parserFail?
03:33:34 <kryft> (Parsec 3)
03:34:49 <ibotty> (afaik) it does only lookaheads for a few chars, so if A is using too many chars, it won't work
03:36:35 <kqr1> kryft, if it A is a partial fit it will count that as "having succeeded with A" even though A fails later on... or something like that. it was a while since i toyed with it
03:36:41 <kryft> ibotty: So you mean that 'try A' won't necessarily fail without consuming input if I call parserFail
03:36:42 <kqr1> kryft, s/it//
03:37:15 <kryft> kqr1: Oh, ok, hmm
03:37:32 <ibotty> kryft: as kqr1 said.
03:37:48 * hackagebot free-game 0.9.3.5 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3.5 (FumiakiKinoshita)
03:38:23 <kryft> Ok, thanks
03:38:25 <ibotty> you might be able to use `try`. but i have no idea whether that will work. and it might be slow
03:38:38 <ibotty> ehm: will be slow
03:38:44 <kqr1> kryft, so if you have the option to, the best bet is to define a grammar that's not ambiguous in that sense
03:39:17 <kqr1> kryft, afaik that'll give you the best performance as well, even though you are able to solve your problem with the existing grammar (i know it's doable, I just don't remember how to)
03:57:55 * hackagebot TCache 0.10.1.0 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.1.0 (AlbertoCorona)
04:15:40 <mbrock> "Cross-platform GUI library based on free monads"
04:15:55 <mbrock> interesting, my first guess was that is was a game based on free monads
04:16:27 <mbrock> like every Functor gives rise to a particular real-time strategy game
04:57:51 <d3lxa> is there a way to extract declaration type after compilation into .hi or .o? or an other way if GHCi cannot load them (because I don't use the same extension as with Cabal, it won't find the correct types and throw error)?
05:03:15 <danr> d3lxa: ghc --show-iface <...>.hi
05:04:05 <d3lxa> danr: that's awesome, thank you! =)
05:04:11 <danr> np :)
05:07:45 <totte> Reading http://www.haskell.org/ghc/docs/6.6/html/Cabal/builders.html#simple-paths, I use --libsubdir="$compiler/site-local/$pkgid" but $compiler and $pkgid won't expand unless I use \ instead of ", how come and is it possible to use " anyway somehow?
05:08:13 <totte> I tried with ${compiler} as well, no luck.
05:25:29 <jophish> Yo yo yo
05:25:43 <jophish> has anyone noticed, most of the links to the mailing list are broken from the wiki
05:27:03 <nogeddaf> yes, I think there was some discussion about that on the mailing list some time ago
05:28:26 <merijn> JPohlmann:
05:28:28 <merijn> eh
05:28:41 <jophish> nogeddaf: perhaps it's worth linking to that from the wiki... oh
05:28:43 <merijn> stupid typo, why does ctrl-j send text in irssi >.>
05:28:44 <jophish> :)
05:29:01 <nogeddaf> :)
05:29:10 <merijn> jophish: They broke during the migration to a new server, we haven't figured out how to fix them yet
05:30:21 <mauke> merijn: because ctrl-j is '\10'
05:32:51 <t4nk782> hey all! if i have a list of char like "dddegef" and I want to get rid of all the 'e'  how would i do that. I thought about \\ and delete but I can't get it to work with map any ideas?
05:33:23 <ibotty> use filter
05:33:33 <t4nk782> tried that too
05:33:37 <ehamberg> > filter (/='e') "dddegef"
05:33:38 <lambdabot>   "dddgf"
05:33:53 <t4nk782> ah
05:33:59 <applicative> ehamberg is too fast for me
05:34:03 <t4nk782> i must have done the wrong syntax ;)
05:34:09 <t4nk782> thanks buddy!
05:34:11 <ehamberg> t4nk782: :-)
05:34:42 <applicative> > [x | x <- "dddegef", x /= 'e']
05:34:43 <lambdabot>   "dddgf"
05:35:12 <t4nk782> ah yeah that was, i tried filter but if I try and get rid of two characters I couldn't get it to work
05:35:24 <t4nk782> filter (/="ef") "dddegef"
05:35:31 <merijn> t4nk782: That's a type error
05:35:32 <applicative> right that wont work
05:35:39 <merijn> :t filter
05:35:40 <lambdabot> (a -> Bool) -> [a] -> [a]
05:35:54 <merijn> :t filter (/="ef")
05:36:01 <lambdabot> [[Char]] -> [[Char]]
05:36:02 <merijn> :t filter (/='e')
05:36:06 <lambdabot> [Char] -> [Char]
05:36:13 <merijn> Spot the difference
05:36:27 <t4nk782> ah
05:36:27 <applicative> whats a good way to remove subsequences of a given shape?
05:36:59 <applicative> t4nk782: or did you want to get rid of all e's and all f's or just all 'ef's
05:37:18 <t4nk782> yeah, just the ef's when they are next to each other
05:37:37 <applicative> yes, thats a bit more labor
05:37:46 <t4nk782> ah
05:38:47 <merijn> t4nk782: There's some hackage packages for that type of stuff, but I forgot their name
05:39:45 <supki> lens?
05:39:59 <ibotty> everything is in lens :D
05:40:04 <supki> > "abecdefghfij" ^. splittingOn "ef" folded
05:40:07 <lambdabot>   "abecdghfij"
05:40:17 <applicative> hah
05:40:40 <t4nk782> brilliant
05:40:41 <applicative> Data.List.Split has nice functions for this t4nk782
05:40:58 <applicative> it comes with the Haskell Platform http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
05:41:16 <drayevarg> :t splittingOn
05:41:41 <supki> @ty Data.List.Split.Lens.splittingOn
05:41:42 <lambdabot> (Eq a, Applicative f, Contravariant f) => [a] -> Getting (Endo [a]) s a -> ([a] -> f [a]) -> s -> f s
05:41:56 <drayevarg> supki: thanks :)
05:42:05 <ibotty> > concat $ splitOn "ef" "abcdefgh"
05:42:06 <lambdabot>   "abcdgh"
05:42:21 <ibotty> splitOn is in data.list.split
05:42:21 <applicative> this would be concat $ splitOn "ef" "adasdef"
05:42:30 <applicative> oh ibotty youre too fast for me too
05:42:32 <haasn> > "abcdefghjik" ^.. splittingOn "ef" folded
05:42:33 <ibotty> hehe
05:42:33 <lambdabot>   ["abcd","ghjik"]
05:42:34 <ibotty> :D
05:42:39 <haasn> oh
05:42:45 <haasn> you wanted to remove those
05:42:52 <haasn> yeah then ‘view’ is fine
05:43:39 <applicative> oh i didn't realize the split package was in scope or somewhat in scope for lambdabot
05:44:47 <kittymorphism> am i here?
05:45:01 <t4nk782> guys that for all this help this was great!
05:45:07 <t4nk782> *thanks
05:45:14 <t4nk782> I'm sleepy still ;)
05:45:16 <applicative> the lens splittingOn functions are just the split functions plus lens boilerplate it seems
05:45:26 <ibotty> kittymorphism: yes
05:45:42 <t4nk782> gonna get back to it, cya folks!
05:47:36 <haasn> lens boilerplate is best boilerplate
05:51:17 <applicative> splittingOn s l f = coerce . traverse f . splitOn s . toListOf l
05:52:32 <applicative> folded = conjoined folded' (indexing folded')
05:54:30 <applicative> folded' f = coerce . getFolding . foldMap (Folding #. f)
05:55:04 <applicative> indexing l iafb s = snd $ runIndexing (l (\a -> Indexing (\i -> i `seq` (i + 1, indexed iafb i a))) s) 0
05:55:13 <applicative> it makes so much sense really
05:56:47 <niteria> :t coerce
05:56:48 <lambdabot> (Functor f, Contravariant f) => f a -> f b
05:57:28 <applicative> :t fmap unsafeCoerce
05:57:29 <lambdabot> Not in scope: `unsafeCoerce'
05:58:50 <niteria> Contravariant somehow tells that it's ok to do that?
05:59:01 <supki> no
05:59:04 <applicative> coerce a = absurd <$> contramap absurd a
05:59:11 <supki> (Functor f, Contravariant f) tells that
06:01:59 <leroux> How can I represent hex in a haskell string?
06:02:17 <leroux> I'm trying to send some hex over the network.
06:04:31 <quicksilver> why would you want to represent it in a string?
06:04:43 <quicksilver> I feel some part of your question is poorly formed.
06:05:00 <quicksilver> what does it mean to "send hex" over the network? Are you just sending numbers as bytes?
06:05:05 <leroux> Yes.
06:05:18 <leroux> quicksilver: I just want to send some numbers over.
06:05:21 <quicksilver> then strings should not really enter the picture
06:05:27 <leroux> Bytestrings then?
06:05:30 * quicksilver nods
06:05:35 <leroux> Okay.
06:05:36 <kittymorphism> :t 4
06:05:37 <lambdabot> Num a => a
06:05:38 <quicksilver> pack [0xFF,0xA0]
06:05:47 <quicksilver> there is literal notation for hex numbers
06:05:53 <quicksilver> and pack will turn a [Word8] into a ByteString
06:06:59 <arianvp> Anyone familair with the `bound` library? Trying to digest an example and am a bit stuck
06:07:28 <leroux> quicksilver: Thanks.
06:08:10 <arianvp> edwardk:  In your   Simple example in the bound library (https://github.com/ekmett/bound/blob/master/examples/Simple.hs)  why is Lam defined  | Lam (Scope () Exp a) instead of  | Lam (Scope Int Exp a)
06:08:12 <arianvp> ?
06:14:41 <applicative> so far the boilerplate is splittingOn "ef" l  = fmap absurd . contramap absurd . traverse  (conjoined (conjoined folded' (indexing folded')) gunk) . toListOf l  where gunk iafb s = snd $ runIndexing  (fmap absurd . contramap absurd . getFolding  . foldMap (Folding #. f) $ (\a -> Indexing (\i -> i `seq` (i + 1, indexed iafb i a))) s) 0))
06:20:59 <Ghoul_> is there a way to eat an exception pointlessly?
06:21:43 <Mortomes|Uni> Passed my retake exam \o/
06:21:51 <Ghoul_> err, I'l rephrase. I want to execute a filesystem thing but ignore any exceptions
06:22:45 <merijn> Ghoul_: Just "handle (\(SomeException _) -> return ())"?
06:23:49 <Ghoul_> thanks
06:38:30 * hackagebot Workflow 0.8.0.7 - Workflow patterns over a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.7 (AlbertoCorona)
07:05:21 <applicative> oh man I hadn't noticed simon pj will be giving a lens tutorial too...
07:05:42 <beaky> hello
07:05:47 <applicative> hello
07:05:50 <beaky> what is the english name of the <*> operator
07:05:51 <edwardk> applicative: =) his is going to be very very general audience. e.g. to folks who are only passingly acquainted with haskell
07:05:54 <edwardk> beaky: ap
07:05:58 <merijn> edwardk's delegation has reached the point where he can have the language implementor explain his libraries...
07:05:59 <erisco> f :: ((b -> a) -> (a -> a)) -> a       g :: ((a -> b) -> (b -> b)) -> b      hrm, how might I apply 'f' as to get the return 'a'?
07:06:03 <beaky> :t ap
07:06:03 <danharaj> I want to hear SPJ talk all hyper-technical to me.
07:06:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:06:06 <beaky> ah
07:06:10 <danharaj> Most of his talks are introductor :(
07:06:11 <danharaj> y*
07:06:13 <applicative> edwardk: still, it is cool he is meditating on the matter
07:06:18 <beaky> but isnt ap for monads while <*> for functors?
07:06:18 <edwardk> @remember merijn edwardk's delegation has reached the point where he can have the language implementor explain his libraries...
07:06:18 <lambdabot> It is forever etched in my memory.
07:06:28 <erisco> f (\ba -> g (\ab -> ba . ab) ....    kinda stuck
07:07:13 <edwardk> beaky: (<*>) and ap are logically the same operation
07:07:13 <edwardk> danharaj: it is really good for the community that he is able to pitch to that level. when i try to make super general audience talks i tend to come across condescending
07:07:33 <merijn> edwardk: I need to start learning from you, I could be so productive if I didn't attempt to do the actual work associated with it ;)
07:08:18 <erisco> might not be the right way to try and do things :P
07:08:23 <edwardk> merijn: heh, well, all you have to do is run an ISP/phone company long enough to learn how to delegate, decide you had managing people and go do all the work yourself, until you slowly let the delegation through apathy/burnout back into your life ;)
07:08:33 <edwardk> er decide you hate
07:08:39 <applicative> peyton jones really has the magic touch as a sensible speaker
07:08:43 <haasn> personally I prefer in-depth with appropriate links to more information; if you limit yourself to the superficial bits then there's no motivation or incentive to ‘go deeper’, as it were
07:09:30 <haasn> you also have to find a middle ground between boring people who're familiar with the subject and alienating people who aren't, which is hard :(
07:10:05 <edwardk> haasn: that is kind of how i try to give talks. hit the audience with about 80% of it, but aim 20% of it at the top 20%, which hopefully inspires some fraction of the 80% towards joining that clique
07:10:50 <haasn> you need to stop giving talks in a linear fashion and organize them in a fractal manner; prerecord a hologram of all the possible paths
07:10:57 <applicative> peyton jones has a different device; if he figures you already understand what he's going to say, he calls you a double dyed haskell hacker and basically doesn't bother with you....
07:11:09 <edwardk> haasn: sounds good. get me the recording mechanism
07:11:37 <haasn> [spoiler]it's based on lenses and prisms[/spoiler]
07:13:05 <edwardk> haasn: sweet. i can go back to michigan and set up my old basement holography sand table ;)
07:13:47 * hackagebot http-conduit 1.9.4.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4.4 (MichaelSnoyman)
07:13:53 * applicative keeps his holography sand out of old basements
07:13:56 <niteria> @pl (\x -> not $ isLetter x || isNumber x)
07:13:57 <lambdabot> not . liftM2 (||) isLetter isNumber
07:14:49 <edwardk> the only thing i ever used it for was rendering flames to motorized conical bases to put under miniatures for miniature war gaming. it was a bit of overkill.
07:15:01 <niteria> @pl \x -> (not $ a x) || b x
07:15:01 <lambdabot> ap ((||) . not . a) b
07:15:08 <applicative> @type liftM2 (/=) even odd
07:15:09 <lambdabot> Integral a => a -> Bool
07:15:39 <applicative> hm
07:16:11 <niteria> @type liftM2 (||) (not . a) b
07:16:11 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `Expr'
07:16:12 <lambdabot>     In the second argument of `(.)', namely `a'
07:16:12 <lambdabot>     In the second argument of `liftM2', namely `(not . a)'
07:16:15 <haasn> how long until we get (||) and (&&) overloaded to arbitrary boolean algebras? :(
07:16:26 <haasn> isLetter || isNumber)
07:16:37 <edwardk> haasn: i'd go for it. it is frustrating that i have to hide them in my EDSLs ;)
07:16:39 <niteria> that's what I wanted to write
07:16:57 <applicative> (| isLetter || isNumber |)
07:17:11 <haasn> edwardk: with an extra defaulting rule to default Boolean to Bool, it seems like it could even work without breaking anything
07:17:31 <quicksilver> it wouldn't break anything except error messages and the set of accepted programs
07:17:37 <edwardk> probably, but it'd be a prtty big proposal. i figure we have bigger fish to fry ;)
07:17:39 <quicksilver> which is the usual problem with adding more overloading :-(
07:17:55 <niteria> @type \a b -> liftM2 (||) (not . a) b
07:17:56 <lambdabot> (a -> Bool) -> (a -> Bool) -> a -> Bool
07:18:08 <haasn> yes but as long as the set of accepted programs is a strict superset of the old one, it should be fine, no?
07:18:13 <haasn> I'm not sure if that is the case here
07:18:19 <haasn> but my suspicion was that it is
07:18:22 <tomejaguar> hashcat: Which boolean algebra instances did you want?
07:18:23 <edwardk> join the core libraries committee in a couple of years and push to do it then, once the dust has settled from the current changes
07:18:28 <applicative> niteria: all you need is a buggy preprocessor for (| isLetter || isNumber |) http://lpaste.net/91687
07:18:32 <tomejaguar> haasn: ^^ oops wrong auto complete!
07:18:49 <niteria> why don't we have idiom brackets?
07:18:53 <haasn> tomejaguar: Boolean a => Boolean (r -> a) -- among other instances for Applicatives
07:19:08 <tomejaguar> haasn: Do you also want Num a => Num (r -> a)?
07:19:12 <haasn> tomejaguar: sometimes
07:19:15 <haasn> tomejaguar: but that can be done
07:19:25 <haasn> I don't mind importing a phantom instance for it
07:19:39 <haasn> eg. (sin + cos)
07:19:39 <applicative> niteria: well, i'll help you implement them if you like ;)
07:19:49 <edwardk> haasn: what breaks is code where it incurs a non-single-constructor constraint on the data type, and defaulting leads to some warnings
07:20:21 <quicksilver> haasn: I'm not saying it's a bad idea, but broadening the set accepting programs is a potential issue
07:20:34 <quicksilver> haasn: it means that things which were previously typos or bugs are now accepted.
07:20:40 <haasn> edwardk: hmm ok
07:20:54 <danilo2> Hi! Is it possible in Haskell to get current module name as a String in code?
07:21:00 <quicksilver> (and presumably surprising, to the person that typed them)
07:21:02 <haasn> quicksilver: yeah I can see a problem with too much generality at least from a practical point of view
07:21:22 <edwardk> quicksilver: i'm generally okay with broadening the set in sane ways. lens is not the best example of my most sane thoughts on this subject ;)
07:21:28 <haasn> this is something we can sort-of work around via custom Prelude
07:21:33 <quicksilver> the most extreme example is ocaml's -rectypes which makes just about every lexically correct code type-check.
07:21:36 <haasn> since it's just a library change and not a language change
07:21:43 <haasn> I mean, adding this
07:21:44 <quicksilver> which means you never get type errors
07:21:50 <quicksilver> which is a shame because type errors are useful.
07:22:00 <edwardk> quicksilver: well, for the longest time basically everything typechecked if you went through a record type anyways
07:22:05 <applicative> danilo, easy thisModule = "Data.Danilo2.Strict"
07:22:08 <haasn> the most ‘extreme’ case is the lambda calculus
07:22:09 <niteria> applicative: I wouldn't know where to start
07:22:11 <haasn> where type errors don't exist
07:22:14 <haasn> but your program may make no sense
07:22:14 <edwardk> i don't think anyone is advocating for a no-occurs-check =)
07:22:28 <lingxiao> hey could someone explain to me why `m a -> n a` is a monad morphism
07:22:32 <danilo2> applicative: I want an automatic method (using TemplateHaskell) or anythin other :)
07:22:33 <lingxiao> but `m a -> n b` is not?
07:22:35 <quicksilver> edwardk: sure, and it's always a tradeoff, and overloaded booleans would be pretty useful.
07:22:40 <edwardk> lingxiao: (forall a. m a -> n a)
07:22:46 <haasn> applicative: :)
07:22:54 <quicksilver> on the other hand, how hard is it to standardise on an operator for your "superboolean" and use that?
07:23:00 <quicksilver> ||| and &&& spring to mind.
07:23:06 <lingxiao> what is the purpose of `forall a.` in this expression?
07:23:21 <edwardk> lingxiao: start with the notion of a natural transformation. w want fmap f . eta = eta . fmap f        to work for every function f.
07:23:25 <tomejaguar> quicksilver: already taken for Arrow
07:23:29 <haasn> quicksilver: those conflict with profunctors
07:23:40 <haasn> (or arrows, whatever :)
07:23:46 <edwardk> that means it has to take m a -> n a   but f might be a -> b, so it also has to take m b -> n b
07:24:00 <edwardk> so to get a type that can work with both it has to be (forall x. m x -> n x)
07:24:04 <quicksilver> those operators have always annoyed me because they're really about tuples
07:24:10 <quicksilver> but yes.
07:24:14 <haasn> daily reminder that (&&&) should be liftA2 (,)
07:24:16 <edwardk> then the free theorem for that allows fmap to slide over the natural transformation
07:24:35 <edwardk> lingxiao: a monad homomorphism is a natural transformation that _also_ preserves the meaning of return and (>>=) in nice ways
07:24:52 <tomejaguar> haasn: Recently someone here suggested to me that Arrow should just be (family of) Applicative and Category.
07:24:57 <haasn> tomejaguar: yeah
07:25:04 <haasn> they're perfectly equivalent iirc
07:25:08 <applicative> x &&& y should be (|x,y|)
07:25:22 <tomejaguar> I haven't verified it for myself, but if so, that's cool.
07:25:31 <edwardk> lingxiao: in particular eta . return = return
07:25:31 <haasn> applicative: even better :)
07:25:34 <tomejaguar> applicative: is there a semantics for applicative brackets somewhere?
07:25:47 <quicksilver> alternatively Arrow could just be ditched :)
07:25:55 <quicksilver> it's not really clear it's a useful abstraction to me.
07:26:01 <edwardk> lingxiao: and you can loop up the rule for join/(>>=) but it just fmaps to apply eta twice
07:26:21 <tomejaguar> quicksilver: I am finding Arrow very useful to represent relational queries.
07:26:23 <applicative> do they say much in the paper, I cant remember. Its obvious mcbride made a lot of choices in the preprocessor, e.g. about join and about alternative
07:26:42 <lingxiao> edwardk: wait may I ask you if f is a -> b why does "it" take m b -> n b?
07:26:51 <applicative> oh and the one about *> and <* is awesome, tomejaguar
07:27:02 <haasn> tomejaguar: http://bpaste.net/show/127059/
07:27:19 <edwardk> eta . join = join . eta . fmap eta = join . fmap eta . eta   -- of course the equivlence of the two right hand sides is from eta being a natural transformation
07:27:20 <niteria> she has idiom brackets
07:27:29 <haasn> tomejaguar: if you look closely you'll find that foo/bar are equivalent to <*>/pure for Applicative (a b)
07:27:30 <edwardk> lingxiao: it was the monad homomorphism lets look at the types for a sec
07:27:43 <Sculptor> hi
07:27:46 <haasn> tomejaguar: I'm not entirely sure on the laws, though
07:27:52 <applicative> hi Sculptor
07:27:55 <haasn> tomejaguar: it might be that Arrow imposes more laws than Category/Applicative alone
07:28:32 <tomejaguar> haasn: I don't understand what you're showing me.
07:28:47 <niteria> shouldn't idiom brackets be doable in template haskell?
07:28:58 <applicative> check out http://lpaste.net/91688 line 11 tomejaguar for <* and co
07:29:09 <haasn> tomejaguar: a redefinition of class Arrow; the two new operations ‘foo’ and ‘bar’ allow you to implement ‘arr’ and ‘first’ which is the minimal complete definition of the (current) Arrow
07:29:13 <edwardk> eta :: forall x. m x -> n x        f :: a -> b        ma :: m a    -- now we can fmap f ma :: m b       then eta to get eta (fmap f ma) :: n b     but we could instead choose to eta ma :: n a    and then fmap f to get fmap f (eta ma) :: n b    -- both of these paths get us to the same result, that is what naturality tells us
07:29:33 <tomejaguar> haasn: Oh I see.
07:29:36 <edwardk> lingxiao: a monad homomorphism is a just natural transformation 'with extra stuff'
07:29:37 <quicksilver> haasn: you need to assume some new laws about how the category and applicative instances are supposed to interoperate with each other
07:29:44 <quicksilver> haasn: they are quite 'natural-seeming' laws.
07:29:50 <edwardk> eta  was the 'it' in that sentence, not f
07:29:52 <haasn> quicksilver: ok
07:30:01 <applicative> niteria: there is a template haskell implementation of some of it somewhere
07:30:06 <quicksilver> haasn: cdsmith (formerly of this parish) set out the situation in http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
07:30:10 <haasn> quicksilver: thanks
07:30:22 <quicksilver> the previous article http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/ is also worth a read if you're interested in this
07:30:24 <edwardk> eta there is a natural transformation from m to n
07:30:28 <applicative> has cdsmith left the church?
07:30:44 <niteria> applicative-quoters
07:30:48 <applicative> ah
07:31:27 <applicative> niteria: but mcbrides preprocessor predictably has a number of other witty curlicues
07:31:39 <tomejaguar> Instead of (| ... x1 ... x2 ... xn ... |) I'm perfectly happy with liftMn (\y1 y2 ... yn -> ... y1 ... y2 ... yn ... |) x1 x2 ... xn
07:31:56 <quicksilver> applicative: echelon says so.
07:31:58 <quicksilver> applicative: http://ircbrowse.net/nick/cdsmith?recent=false
07:32:06 <edwardk> lingxiao: if you restricted eta to m a -> n b  or m b -> n c   you could only apply it in one of those two places and you wouldn't have a natural transformation
07:32:33 <quicksilver> I don't entirely believe that. In my memory cdsmith was not entirely absent in the years 2008-2011
07:32:35 <edwardk> lingxiao: you would have no guarantee that it didn't care about the argument type in effect
07:32:37 <quicksilver> maybe he changed nick
07:32:54 <applicative> or just not using irc? maybe.
07:33:09 <quicksilver> I meant not entirely absent from irc
07:33:13 <quicksilver> however, my memory could also be wrong
07:33:18 <applicative> yeah
07:34:02 <edwardk> http://ircbrowse.net/nick/cdsmithus?recent=false
07:34:12 <quicksilver> there you go
07:34:18 <quicksilver> edwardk++ # a better echelon
07:34:29 <edwardk> @karma edwardk
07:34:29 <lambdabot> You have a karma of 28
07:34:49 <quicksilver> we keep losing the lambdabot database :)
07:34:52 <quicksilver> or :( rather
07:34:55 <applicative> ah, right cdsmithus
07:36:10 <niteria> (&&&) always felt like such a special case
07:36:16 <quicksilver> cdsmithus's verbosity graph is really peculiar
07:36:22 <applicativus> @type (&&&)
07:36:23 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:36:35 <quicksilver> how does he manage such a sharp spike at 8 words per line
07:36:53 <applicativus> edward's verbosity graph is exponential, have you noticed ;)
07:37:11 <lingxiao> edwardk: Ahh i get it... and just to be sure `eta` is the monad homorphism
07:37:17 <applicativus> beats the rest of us going exponential, i'd think
07:37:42 <applicativus> oh i see. misunderstood quicksilver
07:38:06 * haasn attributes the drop in edwardk's 2013 activity to ‘lens’
07:38:43 <applicativus> quicksilver: yes that is weird, maybe he's secretly partial to some deviant haiku like principle
07:39:32 <quicksilver> edwardk briefly burnt out at the point where the two graphs "problems lens can solve" and "problems lens has created" crossed over.
07:39:47 <quicksilver> however he's back and fighting.
07:40:12 <applicativus> haasn: no, edwardk get's really pedagogical late in the year
07:40:15 <applicativus> gets rather
07:41:47 <mbrock> woah, i can see myself chatting back in 2004 on that ircbrowse site
07:41:58 <mbrock> nostalgic!
07:42:21 * haasn keeps IRC logs for that
07:43:06 <niteria> @pl (\x -> if x == 'T' then 'U' else x)
07:43:09 <lambdabot> ap (flip (if' . (== 'T')) 'U') id
07:43:09 <lambdabot> optimization suspended, use @pl-resume to continue.
07:43:12 <mbrock> i might have those in a backup inside another backup on some hard drive in the attic
07:43:25 <niteria> first time I saw lambdabot do that
07:43:35 <haasn> blame elliott, it's the hip thing to do
07:44:31 <mescalinum> does haskell just ignores overlapping patterns in functions?
07:44:38 <haasn> it'll warn you
07:44:41 <Ghoul_> :t if'
07:44:42 <lambdabot>     Not in scope: if'
07:44:43 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
07:44:50 <geekosaur> if you have warnings on, at least
07:44:51 <haasn> well, it warns you if there are patterns that will never be reached
07:44:55 <Ghoul_> Why does lambdabot emit if's ?
07:45:10 <mescalinum> would it be possible to modify the language to consider those overlaping patterns?
07:45:13 <Ghoul_> or, rather, if''s
07:45:15 <geekosaur> it's cheating
07:45:23 <geekosaur> since there's no way to make an if pointfree
07:45:34 <Ghoul_> Bugger
07:45:37 <mescalinum> for example, if I want to have functions with backtracking ?
07:45:37 <geekosaur> (without extensions, and @pl doesn't know about lambdacase)
07:45:41 <Ghoul_> I always wanted bool in prelude :|
07:46:08 <Ghoul_> lens has a cool thing like it -- the C/C++ unary operator
07:46:14 <Ghoul_> but it feels kinda blegh in haskell
07:48:08 <Hafydd> C has more than one unary operator.
07:48:19 <geekosaur> you mean ternary?
07:49:00 <Hafydd> This it is demonstrated that "ternary operator" is a stupid think to call it.
07:49:06 <Hafydd> *h
07:49:36 <applicativus> @type (,,)
07:49:37 <lambdabot> a -> b -> c -> (a, b, c)
07:49:46 <haasn> let True ? (t:_) = t; False ? (_:f) = f
07:49:47 * haasn ducks
07:50:15 <tel> what's the lensy ternary operator?
07:50:18 <applicativus> that wont typecheck, i'm getting occurs check
07:50:22 <haasn> applicativus: yea
07:50:29 <Hafydd> @_@ Haskell already has that built into the language. It's called if..then..else.
07:50:30 <lambdabot>  Haskell already has that built into the language. It's called if..then..else.
07:51:07 <applicativus> @_@ hi, lambdabot here
07:51:07 <lambdabot>  hi, lambdabot here
07:51:22 <Hafydd> I see \bot agrees with me.
07:51:29 <haasn> @@ optimized
07:51:31 <lambdabot>  optimized
07:51:35 <edwardk> :t failing
07:51:43 <edwardk> tel you can probably write it with failing
07:51:52 <edwardk> :t filtered
07:52:07 <edwardk> :t Control.Lens.failing
07:52:08 <lambdabot> Applicative f => Traversing (->) f s t a b -> Traversing (->) f s t a b -> Over (->) f s t a b
07:52:10 <quicksilver> mescalinum: guards give you a kind of limited backtracking.
07:52:16 <edwardk> :t Control.Lens.filtered
07:52:17 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Overloaded' p f a a
07:52:39 <niteria> @pl \x -> maybe x id (x `lookup` [('T', 'U')])
07:52:42 <lambdabot> ap (flip maybe id) (`lookup` [('T', 'U')])
07:52:43 <lambdabot> optimization suspended, use @pl-resume to continue.
07:53:08 <niteria> if then else wins
07:53:21 <edwardk> :t Control.Lens.failing (_1.filtered (const True)) _2 $ (1,2)
07:53:22 <lambdabot>     Couldn't match expected type `b0 -> f0 b0'
07:53:22 <lambdabot>                 with actual type `(t1, t2)'
07:53:22 <lambdabot>     In the second argument of `($)', namely `(1, 2)'
07:53:40 <edwardk> :t (1,2) & Control.Lens.failing (_1.filtered (const True)) _2 +~ 1
07:53:41 <lambdabot> Num t => (t, t)
07:53:46 <edwardk> > (1,2) & Control.Lens.failing (_1.filtered (const True)) _2 +~ 1
07:53:48 <lambdabot>   (2,2)
07:53:52 <edwardk> > (1,2) & Control.Lens.failing (_1.filtered (const False)) _2 +~ 1
07:53:53 <lambdabot>   (1,3)
07:53:56 <edwardk> there you go
07:54:04 <edwardk> so much nicer than if
07:54:50 <merijn> edwardk: Approaching Poe's law there :p
07:54:50 <tel> huh, :)
07:54:54 <quicksilver> edwardk: _1.filtered(const is a bit cumbersome?
07:55:23 <tel> is failing news? I can't seem to find it in ghci
07:55:23 <supki> @ty Control.Lens.ignored
07:55:24 <lambdabot> Applicative f => pafb -> s -> f s
07:55:25 <tel> new*
07:55:41 <erisco> tel, hey
07:55:46 <edwardk> tel: it may be
07:55:52 <haasn> > ("true", "false") ^. if True then _1 else _2 -- best of both worlds
07:55:53 <supki> > (1, 2) & Control.Lens.failing (_1.ignored) _2 +~ 1
07:55:55 <lambdabot>   "true"
07:55:56 <tel> erisco hi :)
07:55:56 <lambdabot>   (1,3)
07:55:57 <edwardk> tel: it was added late 3.9 or early 3.10
07:56:10 <mescalinum> quicksilver: I thought guards admin at most one solution
07:56:15 <tel> cabal update … la la
07:56:26 <mescalinum> quicksilver: I mean one branch where condition holds
07:56:27 <quicksilver> mescalinum: but if the guards fail they backtrack to other patterns
07:56:39 <edwardk> > ("true","false")^.(True ? (_1,_2))
07:56:40 <conjunctivitis> tel it was added after the Council of Nicea to guard against Arian excesses
07:56:40 <quicksilver> mescalinum: including possibly overlapping ones
07:58:16 <erisco> is there a composition type class?
07:58:33 <lambdabot>   Not in scope: `?'
07:58:33 <mescalinum> quicksilver: I meant if it is possible to have nondeterministic computation
07:58:33 <mescalinum> quicksilver: i.e. a function with two overlapping patterns, both of them could give you a result
07:58:41 <PudgePacket> Hey guys, I was writing my own Prime number generator function and found quite different performance when using functional style vs list comprehension, I was wondering if someone could point out why :) ! primes1 3000 takes about 4 seconds, while primes2 3000 takes about 1.4, almost 3 times faster! http://pastebin.com/i7QVhH32
07:58:42 <mauke> The paste i7QVhH32 has been copied to http://lpaste.net/92244
07:58:47 * applicative proposes a theological use of lens to explain the Trinity to savages
07:59:16 <quicksilver> mescalinum: why would you add nondeterminism to the language?
07:59:23 <supki> erisco: what kind of composition?
07:59:28 <quicksilver> mescalinum: that rather defeats the point of function meaning function.
07:59:31 <erisco> :t (.)
07:59:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:59:34 <erisco> that kind
07:59:37 <quicksilver> mescalinum: if you simply want to model nondeterminism, that's what the list monad does.
07:59:41 <supki> Category then
07:59:50 <erisco> but    f (b -> c) -> f (a -> b) -> f a -> f c
08:00:40 <tel> applicative okay, I'm done wikiing whatever the council of nicea could have possibly done
08:00:50 <mescalinum> quicksilver: sometimes it easier to constrain the solution(s of a nondeterministic program) to satisfy certain property, rather than to code the deterministic version
08:01:19 <erisco> how does name resolution work for (.) on category? :s
08:01:22 <mescalinum> quicksilver: I'll look at that list monad thing...
08:01:29 <tel> erisco you have to hide Prelude's (.)
08:01:37 <erisco> suppose that'd be alright
08:02:48 <applicative> whats the answer to PudgePacket 's question, hm
08:03:38 <erisco> that is odd... I was expecting Category to be bizarre and confusing but alas
08:03:40 <erisco> never looked
08:04:13 <PudgePacket> applicative, i was thinking something to do with the the lazyness taking advantage of the fact that the filter and the map in isPrime2 is broken up so perhaps not as many operationsw need to be performed but i'm not quite sure, perhaps the list comprehension exhausts the list while the filter doesn't?
08:04:19 <quicksilver> PudgePacket: not sure really; quirk of the optimiser or the code generator?
08:04:33 <quicksilver> PudgePacket: when I compile with -O2 I see primes2 faster for 3000
08:04:45 <quicksilver> PudgePacket: but when I go up to 60000 they're pretty much the same speed (4 seconds each)
08:04:53 <erisco> why do they have you define id?
08:05:22 <tel> erisco it's not a category without id. You need both composition and "home arrows" like a x x
08:05:26 <PudgePacket> quicksilver, i was just running in ghci so i'm assuming there are no optimisations being performed
08:05:41 <erisco> ah okay I see... it has to satisfy laws with (.)
08:06:19 <Lethalman> :t id.id
08:06:19 <lambdabot> c -> c
08:06:20 <erisco> Category is of kind * -> * -> * ?
08:06:36 <PudgePacket> :t null
08:06:37 <lambdabot> [a] -> Bool
08:06:57 <quicksilver> PudgePacket: correct.
08:07:03 <quicksilver> PudgePacket: running in ghci is not a good test of speed really
08:07:06 <tel> erisco yup and *instances* of Category are
08:07:31 <erisco> tel, this doesn't quite seem what I was hoping for then...
08:07:33 <PudgePacket> quicksilver, thanks for your input
08:07:40 <applicative> PudgePacket: yes, with -O2 i'm not seeing much of a difference.
08:08:05 <PudgePacket> quicksilver, which approach would you prefer? to me the list comprehension is more readable
08:08:30 <tel> erisco what were you looking for?
08:08:36 <erisco> tel, I suppose I could define a new type
08:08:50 <erisco> well I've got this composition-like operator hanging around on my Applicative type
08:08:58 <erisco> and that seemed odd
08:09:07 <erisco> so I guess what I need to do is define a new type
08:09:13 <erisco> and lift it into the category
08:09:17 <applicative> PudgePacket: to me the comprehension is more readable; at some point complexity overtakes them though
08:09:40 <erisco> tel, does that sound sane?
08:09:48 <quicksilver> PudgePacket: I'd probably write filter (\x -> n `rem` x == 0) [2..(n-1)]
08:10:45 <tel> erisco Possibly—sometimes it's not worth newtyping or juggling parameters to get things to fit into instances. It might be a fun exercise, but it'll become difficult to use in practice
08:10:55 <erisco> I've got    f (b -> c) -> f (a -> b) -> f (a -> c)   where 'f' is my Applicative type
08:10:59 <tel> erisco so better to just leave a comment that it has said property
08:11:07 <erisco> tel, I suppose
08:11:35 <tel> erisco oh!
08:11:38 <tel> > liftA2 (.)
08:11:40 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
08:11:40 <lambdabot>    arising from a use ...
08:11:46 <tel> :t liftA2 (.)
08:11:47 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
08:11:48 <erisco> tel, no it isn't like that
08:11:50 <PudgePacket> quicksilver, ah, lambda makes that approach much more readable, thanks.
08:12:34 <erisco> tel, the functions stored on the applicative type are just fluff (well, meaningful, but not the point)
08:12:45 <tel> erisco hm, well, if you newtype X a b = f (a -> b) then X ought to form a category module the newtypes
08:12:59 <tel> modulo
08:13:09 <erisco> tel, the point is that my function, (.>) gives a specific implementation of what to do with the underlying data in the type
08:13:18 <erisco> it isn't just composing the functions on the surface
08:13:41 <erisco> if that makes sense
08:14:37 <tel> erisco Hm, yeah. I suppose check to see if that X type can satisfy the laws. If so, then there's a category in there even if X is useless
08:14:55 <erisco> tel, so basically I could liftA2 (.) and although the types would check out, no actual work would be done :)
08:15:28 <erisco> tel, yeah but as you said, might not be worth. I dunno I'll try, I guess
08:15:36 <bearophile> Hello, I'd like to try to use the llvm back-end
08:15:41 <bearophile> I have read this page: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/code-generators.html
08:16:07 <erisco> tel, if I can neatly tuck away the boxing and unboxing...
08:16:09 <bearophile> I have installed GHC 7.6.1
08:16:32 <applicative> do you have the llc executable bearophile
08:16:37 <applicative> that comes with llvms?
08:16:42 <Tinned_Tuna> owch, poor soul on eduroam...
08:17:03 <tel> erisco the compiler throws away newtypes anyway—it's mostly a matter of how annoying it is to get your type to be kind (* -> * -> *) against the convenience of using (.) and id
08:17:20 <bearophile> I have I have copied the Windows version of clang 3.2
08:17:24 <erisco> tel, well yeah, compile time boxing and unboxing
08:17:29 <erisco> type boxing? whatever
08:17:39 <bearophile> And I have added its bin directory to the path
08:17:58 <tel> erisco ha, yeah
08:17:59 <applicative> bearophile: hm, can you find if it has this llc executable somewhere.  when you do ghc -O2 -fllvm myfile.hs, it calls llc
08:17:59 <bearophile> I don't know what llvms us
08:18:01 <bearophile> is
08:18:43 <bearophile> It doesn't find it, giving: Warning: Couldn't figure out LLVM version!
08:19:01 <erisco> tel, what I could do is use my (.>) operator anyhow, and have it do the boxing, and it calls to the underlying (.)
08:19:07 <bearophile> If I run llc from any shell it is found
08:19:18 <bearophile> Despite it gives an error
08:19:25 <erisco> tel, at least the instance has been made so the properties are clear
08:20:09 <bearophile> Perhaps I have to install llvm 3.1 instead?
08:20:29 <erisco> looking at the laws for morphism, identity and associativity, what is the difference with Monoid?
08:20:58 <erisco> I'm just a bit confused with the terminology going on
08:21:11 <applicative> bearophile: if ghc can find llc my experience is that it complains if it doesnt like the version number but actually goes ahead and tries
08:21:12 <tel> erisco Monoid has only one type parameter, so (m -> m -> m) but Category has two so (a -> b) -> (b -> c) -> (a -> c) has to have the a's and b's and c's match up
08:21:43 <tel> in fact, you can happily define a monoid to be a category with just one object
08:22:10 <tel> so that category composition looks like (a -> a) -> (a -> a) -> (a -> a) i.e. is the Endo monoid
08:22:58 <danilo2> Hi Could anybody tell me why this code does not work (catching exceptions): http://lpaste.net/92245 (it is exactly the same as in the documentation: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
08:23:18 <danilo2> I mean - it does NOT COMPILE
08:23:20 <applicative> bearophile: hm, maybe study this, which seems to have a solution? http://ghc.haskell.org/trac/ghc/ticket/7143
08:23:25 <erisco> tel, okay thanks for your help :)
08:25:07 <tel> erisco np :)
08:25:09 <bearophile> OK
08:26:12 <applicative> bearophile: he seems, as a first hack, to call ghc with 'ghc -pgmlo opt -pgmlc llc -fllvm -O2 myfile.hs'
08:26:28 <bearophile> Right, I am about to try that
08:27:09 <bearophile> Good, now GHC finds it
08:27:27 <applicative> oh great.
08:27:44 <bearophile> But the LLVM 3.2 package is broken on Windows, so I'll try llvm 3.1
08:27:53 <bearophile> Thank you for the help and see you later.
08:28:01 <bearophile> llvm 3
08:28:03 <quicksilver> danilo2: if you ask a question like that you should also put the error message in the paste.
08:28:31 <bearophile> llvm 3.3 doesn't even have a windows binary package... :-)
08:30:02 <danilo2> quicksilver: Ok I will next time. Right now I solved my problem! It was caused by aditional import "Control.Error", which exports other "tryJust" than "Control.Exception" :)
08:30:25 <mroman> Under what circumstances does parsec decide that "many . noneOf" shall not work?
08:30:56 <mroman> I know that many $ noneOf ".:," generally works.
08:31:18 <mroman> however, under some circumstances parsec says that "many" is applied to a parser that accepts an empty string.
08:32:49 <geekosaur> you just answered your own question. if the parser can succeed without consuming any input then it would spin forever accepting nothing
08:33:06 <quicksilver> mroman: 'noneOf' always consumes exactly one Char
08:33:08 <geekosaur> basically it means "this parser must be capable of failing at some point"
08:33:11 <quicksilver> so it can't be a problem with many.
08:33:30 <quicksilver> (if it succeeds, I mean)
08:33:52 <geekosaur> and yes, we'd have to see actual code since noneOf will parse a Char or fail
08:33:53 <quicksilver> maybe you have an alternative
08:34:01 <geekosaur> cannot succeed parsing nothing
08:34:08 <quicksilver> (noneOf "abc" <|> something else important)
08:34:38 <danilo2> How can I catch any exception and convert it to EITHER <exception type> <result type> ? Is there any standard way of doing this?
08:35:47 <supki> danilo2: Control.Exception.try
08:36:05 <quicksilver> note that people who use exceptions generally consider that a bad idea.
08:36:42 <mroman> quicksilver: and when wouldn't it succeed?
08:36:48 <erisco> tel, I'm just trying to debate if .> or .< makes more sense :P
08:36:51 <mroman> end of input?
08:37:03 <quicksilver> mroman: it wouldn't suceed if the char is not one of the ones on the list
08:37:08 <erisco> tel, .> is the order of dependency, <. is the flow of computation... *shrug*
08:37:20 <quicksilver> mroman: so (noneOf "abc") will fail if the char is 'd'
08:37:29 <mroman> Yes
08:37:39 <quicksilver> mroman: but that's fine - the restriction on many is about succeeding whilst consuming no input, not about failing.
08:37:41 <mroman> which means it should parse aabcacad as aabcac and stop at the d
08:37:53 <mroman> I mean, I use many $ noneOf all over my code
08:38:03 <mroman> and it works except in one case
08:38:32 <quicksilver> it's always safe to combine many with noneOf. we need to see your code to help you.
08:40:43 <danilo2> supki: Thank you! I've tried it right now but have got some further problems while compiling a simple example: http://lpaste.net/92249
08:41:08 <applicative> yes, you need to mark the excpetion type
08:41:18 <applicative> an unpleasant feature of extensible exceptions..
08:41:41 <mroman> quicksilver: http://codepad.org/Ihr8lOrL
08:41:55 <mroman> if you call that in a <|> chain it breaks everything
08:42:05 <mroman> no matter at what position it is inside the <|> chain
08:42:37 <mroman> I assumed that in a <|> b "b" would not be tried if a succeeds.
08:42:42 <quicksilver> mroman: inside a many, I presume.
08:42:55 <quicksilver> inside a many inside a <|> that should indeed cause problems.
08:42:59 <tel> erisco You know, you may want to look at the Arrow class too. It might make that X newtype worth it
08:43:09 <geekosaur> parseIdent itself casn succeed matching nothing (maybe you want some instead of many)
08:43:10 <mroman> yeah
08:43:19 <quicksilver> I thnk you want many1
08:43:23 <erisco> tel, sure I'll do sometime. honestly my deadline will prevent me for now
08:43:26 <erisco> :(
08:43:26 <mroman> I do parse (many $ parseIdent <|> parseNumber)
08:43:31 <quicksilver> it's not the many you've pasted it's complaing about
08:43:32 <geekosaur> yes
08:43:35 <quicksilver> it's that outer many
08:43:41 <tel> erisco and yeah, no guarantee it'll be valuable—oh well
08:43:44 <quicksilver> because parseIdent can match empty string
08:43:50 * hackagebot http-reverse-proxy 0.2.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.2.1 (MichaelSnoyman)
08:43:50 <geekosaur> you probably have the same issue in parseNumber
08:43:52 <lpaste> applicative annotated “Catching exception problem” with “Catching exception problem (annotation)” at http://lpaste.net/92249#a92251
08:44:01 <mroman> oh yeah
08:44:04 <mroman> many1 for ident
08:44:11 <mroman> thanks :)
08:44:31 <quicksilver> also, it's parser smell to put the optional spaces inside a terminal like that
08:44:41 <applicative> danilo2: something like that ^^^
08:44:41 <quicksilver> put the optional spaces in the lexing layer :)
08:45:01 <quicksilver> s/terminal/nonterminal/;
08:48:56 <danilo2> applicative: Ah, than you! I wans thinking that Haskell knows that it will be the "SomeException" type excpetion. Thanks :)
08:53:11 <haasn> main = trying id $ Env.getEnv "TESTENVVAR" >>= print -- ;)
08:53:46 <haasn> or putStrLn, really
08:54:02 <applicative> hey, i thought we were leaning about excpetions
08:54:06 <applicative> exceptions too
08:55:00 <haasn> still, isn't it preferred to use ‘handle/handling’ instead of try/trying + pattern matching?
08:55:35 <applicative> oh, i see, I dont know
08:57:35 <applicative> this is certainly more pleasant than handle
08:58:51 * hackagebot TCache 0.10.2.0 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.2.0 (AlbertoCorona)
08:59:36 <lingxiao> edwardk : can I ask you another question about "Data.Machine.Is"?
08:59:40 <lingxiao> if you are on that is...
08:59:45 <squimmy> is there a version of splitAt that takes a predicate rather than an index?
09:00:00 <quicksilver> squimmy: break
09:00:02 <quicksilver> @type break
09:00:03 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
09:00:09 <squimmy> quicksilver: awesome. thank you
09:00:26 <quicksilver> > break (>5) [1..10]
09:00:28 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
09:00:39 <quicksilver> naturally it breaks at the first time it's true
09:00:57 <danr> @src span
09:00:57 <lambdabot> span _ xs@[]                     =  (xs, xs)
09:00:57 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
09:00:57 <lambdabot>                   | otherwise    =  ([],xs)
09:01:43 <quicksilver> > break (>0) (map ((-1)^) [1..10])
09:01:44 <lambdabot>   ([-1],[1,-1,1,-1,1,-1,1,-1,1])
09:02:27 <lingxiao> or in general, does anyone know somethin gabout witnessed type equality?
09:02:28 <shachaf> lingxiao: Note that HEAD machines doesn't use Is nearly as much as the released version.
09:02:35 <shachaf> But yes, you should just ask your question.
09:02:41 <shachaf> Lots of people know about Is.
09:02:58 <lingxiao> oh ok awesome...could someone explain to me what it is? How it is used? what are its benefits?
09:03:13 <lingxiao> I tried searching for it... but nothing came up
09:04:02 <Clint> what's a better way to do \n f iv -> foldM (const . f) iv [1..n]
09:04:12 <shachaf> If you have a value (x :: Is a b) then it means that the types a and b are equal.
09:04:16 <shachaf> (And can be unified.)
09:05:17 <Saizan> but you have to pattern match on it to make that information avalailable to the typechecker, in the scope of the match
09:06:13 <shachaf> Right.
09:06:35 <shachaf> (And in Haskell it might be _|_, in which case what I said isn't really true.)
09:06:51 <akegalj> in yesod, how to use methodOverride https://github.com/sordina/wai/blob/master/wai-extra/Network/Wai/Middleware/MethodOverride.hs    for simulating PUT and DELETE? I cant figure out
09:06:56 <quicksilver> and you can pass around nifty objects which witness more complex statements about equality, like (Either (Is a b) (Is a c))
09:07:24 <quicksilver> this is a great tool for ugly and unidiomatic code! \o/
09:07:28 <shachaf> Of course, with GADTs you can just define a type for that directly.
09:07:51 <shachaf> Released machines does that: http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Tee.html
09:08:22 <shachaf> Oh, that's not the same, actually.
09:09:24 <lingxiao> shachaf: so it's a way to force two unequal types to be equal?
09:09:32 <shachaf> No, they're equal.
09:09:39 <lingxiao> and what does unified mean? is it case specific?
09:10:00 <PatrickRobotham> Hi shachaf :)
09:10:02 <shachaf> Hmm, you should learn about unification in general before learning about GADTs, probably.
09:10:05 <shachaf> hi PatrickRobotham
09:10:20 <shachaf> Do you know how Typeable works?
09:10:30 <PatrickRobotham> No. Could you teach me?
09:10:41 <shachaf> I was asking lingxiao in this case.
09:10:59 <shachaf> Here's something which is a bit like cast: eq :: (Typeable a, Typeable b) => Maybe (Is a b)
09:11:02 <lingxiao> shachaf: no I do not :(
09:11:12 <shachaf> Ah, OK.
09:11:18 <squimmy> > break (>100) [1..10]
09:11:19 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[])
09:11:42 <quicksilver> ignoring the _|_ issue, "Is" lets you pass around facts about types which  you can prove in one bit of code
09:11:47 <quicksilver> to another bit of code where they can be used
09:12:13 <shachaf> PatrickRobotham: The Typeable documentation is pretty straightforward, I think.
09:12:30 <shachaf> class Typeable a where typeRep :: Proxy a -> TypeRep
09:12:37 <lingxiao> ok so I should read Data.Typeable and Control.Unification
09:12:45 <lingxiao> before trying to understand witness equality?
09:13:00 <shachaf> No, no real need to understand Typeable. It was just an example.
09:13:06 <shachaf> And I don't even know what Control.Unification is.
09:13:20 <lingxiao> oh..i did a search for unification haskell, and that came up
09:13:28 <lingxiao> but I guess I assumed too quickly
09:13:30 <shachaf> https://en.wikipedia.org/wiki/Unification_(computer_science)
09:13:31 <PatrickRobotham> What does {-# UNPACK #-} mean?
09:13:36 <alej> hi friends - i have a file that compiles fine (i.e. cabal build...) but complains that a particular instance declaration is missing (which is plainly there) when i load it in ghci. has anyone seen a similar problem before?
09:13:41 <shachaf> Unboxed field.
09:13:53 <PatrickRobotham> What's unboxed field?
09:14:00 <shachaf> It's an implementation detail, not semantic.
09:14:18 <shachaf> It means the memory layout has one fewer indirection.
09:14:20 <squimmy> is anyone able to confirm my suspicions that rstrip takes linear time?
09:14:32 <shachaf> :t rstrip
09:14:33 <lambdabot> Not in scope: `rstrip'
09:14:38 <shachaf> That depends on what it is.
09:14:41 <lingxiao> quicksilver: is there an article/blog/paper that does a fair intro to witnessed type equality? and expand on what you just asaid?
09:14:46 <lingxiao> said*
09:14:50 <alej> i should probably ask in #ghc
09:15:00 <squimmy> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html#v%3Arstrip
09:15:07 <shachaf> alej: #ghc is more for GHC development than for user questions.
09:15:12 <alej> oh i see
09:15:17 <quicksilver> I don't know of one, lingxiao, I think you'll find lots of stuff about it in general but not haskell specific
09:15:17 <shachaf> (See the topic.)
09:15:21 <squimmy> :t Data.String.Utils.rstrip
09:15:22 <lambdabot> Couldn't find qualified module.
09:15:26 <squimmy> :[
09:15:47 <quicksilver> haskell's system of type variables and in particular GHC's system Fc and GADTs have their own quirks
09:15:48 <squimmy> oh. the source is right here
09:15:56 <shachaf> Sigh, MissingH.
09:16:16 <quicksilver> squimmy: any operations on the right hand end of a string will be linear time, yes.
09:16:16 <shachaf> Anyway, "takes linear time" is a bit complicated in a lazy language, but in general the answer is yes.
09:16:34 <quicksilver> the best you can hope is to incur a lower cost if you never actually inspect that end
09:16:46 <shachaf> Haskell lists are linked lists so you have to traverse all the way to the end.
09:16:53 <squimmy> is reverse . dothing . reverse doubly slow? or do you gain some benefit from lazyness?
09:17:10 <shachaf> "doubly" is still linear. :-)
09:17:22 <lingxiao> quicksiler: "and you can pass around nifty objects which witness more complex statements about equality, like (Either (Is a b) (Is a c))"
09:17:28 <squimmy> shachaf: good point
09:17:30 <lingxiao> could you explain what it means please?
09:17:32 <shachaf> Data.Text has stripEnd but of course that one's going to copy the whole Text.
09:17:43 <lingxiao> sorry last question
09:18:17 <napping> speaking of linear time, is there any way to do a typecase with something like Data.Typeable in less than linear time?
09:19:27 <erisco> (don't shoot me, I spent hours and hours coming up with a type safe equivalent, but it is cumbersome)
09:19:49 <erisco> that said.   a -> b   to    Dynamic -> Maybe Dynamic   ... function already around to lift that?
09:20:07 <erisco> I see dynApply, not sure that is what I'm looking for
09:20:36 <quicksilver> lingxiao: that would mean that either a is the same type as b, or it's the same type as c.
09:21:13 <erisco> mmkay will write it then
09:21:42 <napping> I only see fromDyn/cast/etc that let you try one type
09:22:49 <erisco> wait what?!? why does Typeable only have typeOf :: a -> TypeRep?
09:22:55 <erisco> mm guess it would be hard to put it in the type class...
09:23:00 <erisco> but... well damn
09:23:36 <lingxiao> ahh ok thanks
09:23:39 <quicksilver> @type let eriscoApp f x = fmap (toDyn . f) (fromDynamic x) in eriscoApp
09:23:39 <lambdabot> (Typeable b, Typeable a) => (a -> b) -> Dynamic -> Maybe Dynamic
09:23:43 <quicksilver> erisco: ^^
09:23:44 <lingxiao> that would make sense haha
09:23:49 <erisco> > typeOf (undefined :: Int)
09:23:50 <lambdabot>   Int
09:23:54 <erisco> thank you
09:23:56 <erisco> whew
09:24:07 <erisco> thought I'd actually need a value
09:24:46 <erisco> well take the fun out for me geez :)
09:24:50 <erisco> thanks though
09:24:55 <lingxiao> what's a good primer on unification?
09:24:58 <Saizan> napping: TypeRep is Ord, so it's possible with some unsafeCoerce
09:24:59 <ericmoritz> has anyone used Applicative to compose asynchronous tasks?
09:25:22 <napping> oh, that would help
09:25:29 <lingxiao> a search for "unification GADT" turns up this paper: " Simple Uniﬁcation-based Type Inference for GADTs"
09:25:35 <lingxiao> which isn't really a primer
09:25:40 <napping> why would you need unsafeCoerce?
09:26:17 <napping> well, aside from the kind that's already in Dynamic
09:26:24 <ericmoritz> i.e. (concat <$> downloadList url1 <*> downloadList url2) that will download the two lists concurrently and then concat them?
09:26:30 <erisco> quicksilver, the (->)e functor? bleh
09:26:39 <quicksilver> erisco: no, that was the Maybe functor
09:26:45 <erisco> oh
09:26:50 <quicksilver> erisco: I was fmapping through the 'Just'
09:26:54 <erisco> shows what I know
09:26:56 <quicksilver> which you get out of fromDynamic
09:27:06 <quicksilver> in the case that your x is the wrong type, you're going to get Nothing
09:27:09 <quicksilver> and not actually apply the function f
09:27:15 <erisco> correct
09:27:18 <lingxiao> – Uniﬁcation is the task to make two terms equal, i.e., given two terms s, t,
09:27:18 <lingxiao> which contain variables (in some sense), ﬁnd replacements for these variables,
09:27:18 <lingxiao> such that s and t are equal after the replacement. This task arises in several
09:27:19 <lingxiao> settings, for free ﬁrst order terms [Her30,MM82,Hue76] for terms together
09:27:21 <lingxiao> with an equational theory [Plo72,Sie89] and for terms in sorted signatures
09:27:23 <quicksilver> that's what the fmap does
09:27:24 <lingxiao> [Wal88,SS89,SNMG89]
09:27:25 <lingxiao> – Uniﬁcation in λ-calculus [Hue75,SG89] is the task given two λ-expressions
09:27:27 <lingxiao> with free variables, ﬁnd λ-expressions that substituted for these variables
09:27:29 <erisco> quicksilver, coolio. thanks
09:27:29 <lingxiao> make the two expressions equal after application of reduction rules.
09:27:32 <lingxiao> does this sound about right...
09:27:43 <geekosaur> don't paste into channel, please.
09:27:48 <quicksilver> yes, it does, but please don't paste like that
09:27:52 <Saizan> napping: yeah, that kind, you'd have to implement your own fromDymanicN directly and so you'd need unsafeCoerce for that
09:29:05 <erisco> @pl \f x -> fmap (toDyn . f) (fromDynamic x)
09:29:06 <Saizan> lingxiao: unification is basically the process of solving equations between terms or more specifically types in this case
09:29:09 <lambdabot> flip ((.) . fmap . (toDyn .)) fromDynamic
09:29:09 <lambdabot> optimization suspended, use @pl-resume to continue.
09:29:11 <erisco> standard procedure
09:29:14 <napping> Probably best for performance once you've already checked the TypeRep, but why not use the ord instance to find the right one and then call fromDyn as usual?
09:29:47 <Saizan> napping: ah, i guess that works too
09:29:57 <erisco> quicksilver, was going to call it "liftDyn". fairly suitable?
09:31:05 <napping> Saizan: okay, as long as there's not some mysterious reason it would break. I was wondering how well the union type from Oleg's recent effects paper would work for a Data Types a-la-Carte style ast
09:31:49 <ericmoritz> nevermind, I found it http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
09:32:47 <Saizan> napping: ah, cool
09:33:28 <Saizan> napping: would be interesting to benchmark against direct pattern matching
09:33:47 <lmt> i'm actually using haskell in the real world!
09:33:58 <lmt> i'm using the Real World Haskell book as a support for my monitor
09:33:58 <lingxiao> saizan: ahh ok
09:34:00 <MrRacoon> lmt: doing what?
09:34:01 <Saizan> cheers!
09:34:10 <MrRacoon> arg..
09:34:19 <lingxiao> saizan: thanks! :)
09:38:01 <lingxiao> so as an application of witnessed type equality.. can I create a situation where I have some monad `m`, and a specific primitive `prim :: m Int`
09:38:52 <lingxiao> and then to build some larger action from a sequence of primitives, I could have `large = prim >> prim :: m Int`
09:39:24 <lingxiao> but then if for some really perverse reason, if I want to annotate `large` with a different type, ie `large = prim >> prim :: m String`
09:40:10 <lingxiao> obviously this wouldn't type check, but if I constructed teh original monad in a different way using witnessed type equality, the above perverse example would type check?
09:40:27 <shachaf> String is never equal to Int, if that's what you mean.
09:40:46 <shachaf> Only types that are actually equal can have an equality witness.
09:41:32 <PatrickRobotham> What's an equality witness?
09:41:45 <lingxiao> ah ok so the above is not a valid way to use it... I guess I'm just confused about how it's used in machines
09:42:44 <lingxiao> or just in general, what are some use cases
09:42:51 <shachaf> Well, you can take some concrete example and look at it.
09:42:55 <Saizan> lingxiao: right, for types without type variables in them it's not going to be very helpful, because either the typechecker already knows they are equal or your witness, even if you manage to build one, is bogus
09:43:01 <shachaf> But note that HEAD machines does something different, like I said.
09:43:40 <Saizan> but if you have type variables it's another story
09:43:59 <shachaf> data Step k o r = Stop | Yield o r | forall t. Await (t -> r) (k t) r
09:44:20 <shachaf> What does this become when k=Is q?
09:44:24 <lingxiao> saizan: ahh but if you have `m a` and `m b`, the type check have no way of knowing a and b are equal, in fact they wouldnt be
09:44:26 <chrisdone> haskelloids
09:44:37 <ocharles> chrisdoneoids
09:44:41 <lingxiao> but with some construct `Is a b`, then those two are equal?
09:44:46 <chrisdone> `sup`?
09:45:01 <lingxiao> so if you have some function `m a -> m a -> m a`, then you can use it with `m a` and `m b`?
09:45:01 <ocharles> 'enjoying' being a devops person with ruby and chef :|
09:45:08 <shachaf> Await becomes forall t. Await (t -> r) (Is q t) r, i.e., Await (q -> r) r
09:45:12 <joelteon> hey, chef isn't that bad
09:45:12 <shachaf> OK, that's just confusing.
09:45:16 <joelteon> well, I lie, it's absolutely awful
09:45:17 <chrisdone> ocharles: there's some chef in our repo. what is it?
09:45:18 <Saizan> lingxiao: yeah, if you pattern match on your Is a b value then in the context of that you can do that stuff
09:45:22 <ocharles> joelteon: it is when you run nixos ;)
09:45:24 <shachaf> Also you need to understand existential types for that.
09:45:30 <erisco> @pl \f -> f x
09:45:30 <lambdabot> ($ x)
09:45:31 <lingxiao> shachaf: I'm sorry I guess I'm just really confused about what HEAD machines is, I'm looking at version  0.2.3.1
09:45:33 <joelteon> or if you run centos
09:45:36 <lingxiao> does HEAD just mean the latest?
09:45:44 <shachaf> lingxiao: The unreleased version uses a completely different mechanism.
09:45:54 <shachaf> Yes.
09:45:59 <ocharles> chrisdone: machine configuration management stuff
09:46:08 <chrisdone> ah
09:46:22 <Saizan> lingxiao: HEAD means the one in the repository, hosted on github in this case
09:46:56 <Saizan> https://github.com/ekmett/machines
09:48:15 <lingxiao> Saizan: ahh that's a new idiom I didnt know, thanks for teaching me
09:48:16 <lingxiao> !
09:48:54 <lingxiao> Saizan: ahh cools thanks for clearing things up, a lot less confused now
09:49:09 <shachaf> Really we should call it master when we use git.
09:49:20 <shachaf> But HEAD is traditional here.
09:49:34 <lingxiao> shachaf: so even in the HEAD version, I'm seeing this: `type Process a b = Machine (Is a) b` , in Process.hs
09:49:51 <shachaf> Hmm.
09:50:15 <lingxiao> yeah I'm rather noobish and have yet to grow into this forum..
09:50:18 <lingxiao> :\
09:50:34 <shachaf> Maybe I'm just mixed up.
09:51:18 <shachaf> I don't know. Someone who knows what they're talking about with machines can probably help you.
09:51:34 <lingxiao> yeah meh it's alright, I'm more concerned about finding use case, which ever version is like water under the bridge
09:51:40 <shachaf> Oh, maybe I'm thinking of another branch?
09:51:50 <lingxiao> but thanks for answering all my questions though! I'm like baraging you
09:52:08 <lingxiao> a use case *
09:52:14 <shachaf> There's "experimental" and "unified", which are more recent.
09:52:34 <shachaf> And don't use Is.
09:52:40 <shachaf> But I don't know.
09:52:49 * shachaf leaves.
09:52:53 <chrisdone> i'm making a simple twitter-like app with yesod in the fpco ide, but one for real microblogging. ate this, did n pushups, etc. i plan to do simple textual scanning of it to produce statistics over time. e.g. "pushups 1 set 12 reps" vs "pushups 2 sets 8 reps" i can track as separate workout configurations
09:53:35 <mcstar> what happened to oleg's 'lightweight monadic regions'? is it too obsolete now? or doesnt solve all the problems with resource management?
09:54:28 <mcstar> chrisdone: dont forget to exercise your legs too
09:55:13 <lingxiao> yeah leg day is best day :)
09:57:39 <chrisdone> mcstar: every day is leg day =p
09:59:00 <chrisdone> i go running in the evenings with a podcast on my ipod. last time it was (yay!) a haskell podcast
09:59:11 <Sonarpulse> is there any pragma to unbox strict fields just within a certain module?
09:59:30 <deggis> chrisdone: is there a haskell podcast i'm not aware of?
09:59:31 <chrisdone> i suppose you could just set it in the module with OPTIONS
09:59:40 <Sonarpulse> oh yeah, duh
09:59:44 <Sonarpulse> forgot about OPTIONS pragma
10:00:01 <chrisdone> deggis: http://www.haskellcast.com/episode/001-edward-kmett-on-lenses/ !!!!!
10:00:03 <chrisdone> :D
10:00:25 <deggis> chrisdone: nice!
10:00:44 * chrisdone -> meeting
10:04:32 <jfischoff> are there any tricks to speeding up cabal do nothing builds?
10:05:07 <dcoutts> jfischoff: latest cabal lets you pick specific targets
10:05:22 <dcoutts> and has repl which is quick for small/no changes
10:05:43 <dcoutts> jfischoff: and configuring with -O0 would help
10:06:10 <jfischoff> The problem I have is running cabal on our buildbot takes 2 minutes even when there is nothing to compile
10:06:40 <jfischoff> Part of that is because the machine is weak
10:06:50 <dcoutts> jfischoff: is that just "cabal build", or also doing configure etc etc?
10:07:03 <jfischoff> configure and than build
10:07:08 <dcoutts> what is it spending most of its time doing?
10:07:23 <dcoutts> jfischoff: it'll usually re-configure automatically if it needs to
10:07:37 <jfischoff> yeah
10:08:05 <jfischoff> I think it is preprocessing
10:08:05 <dcoutts> is it spending most time in configure, ghc --make, or in linking?
10:08:09 <dcoutts> oh
10:08:21 <jfischoff> but I'm not sure
10:08:23 <dcoutts> that is odd, since that does have proper no-change tests
10:08:29 <dcoutts> jfischoff: you can tell with -v
10:08:41 <jfischoff> alright I'll see if I can clearer picture
10:08:43 <jfischoff> brb
10:10:16 <b0bbi10> hi
10:10:58 <b0bbi10> Python has its Standard Library and Java has its API as documentation. which is the equivalent to Haskell? The Libraries Documentation or the GHC API?
10:11:17 <geekosaur> libraries doc
10:11:26 <haasn> haddock
10:11:30 <geekosaur> thwe ghc api is about using the compiler as a library, which is not usually what you want
10:11:31 <haasn> or what do you mean
10:11:57 <b0bbi10> haasn: haven't heard of haddock yet
10:12:10 <b0bbi10> I mean the "standard library" of Haskell
10:12:18 <haasn> haddock is the de facto standard way to generate documentation (in HTML format) of your libraries
10:12:21 <haasn> oh
10:12:21 <b0bbi10> so I think it's the libraries doc then
10:12:21 <mcstar> haddock is a documentation generation system, isnt it? he needs the Documentaion
10:12:34 <geekosaur> b0bbi10, http://lambda.haskell.org/platform/doc/current/frames.html
10:12:35 <b0bbi10> ok, thanks guys :)
10:12:39 <haasn> well, there are haddock files available for the ‘standard libraries’ (the ones that come with GHC, the platform, or both)
10:12:54 <haasn> yes, geekosaur gave such a link :)
10:13:01 <geekosaur> mcstar, the documentation generated by haddock is also often referred to as 'haddocks'
10:13:29 <haasn> geekosaur: you can also find documentation for most of the libraries available on hackage (the de facto standard haskell package repository), and you can search them using hoogle or hayoo
10:13:33 <haasn> sorry, b0bbi10 ^
10:13:35 <mcstar> http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/index.html haskell.org is up
10:13:55 <mcstar> geekosaur: but they are just html...
10:14:00 <b0bbi10> don't worry about it haasn :)
10:14:01 <ReinH> morning
10:14:22 <poglesbyg> wow this is a popular hangout
10:14:27 <geekosaur> the docs mcstar just pointed to are for the "boot libraries", those that come with the compiler. it's a minimal library. the Platform is the "standard batteries-included library"
10:14:30 <haasn> it is a popular language :)
10:14:52 <poglesbyg> yeah i've just started learning it for a master degree class
10:14:58 <geekosaur> mcstar, don't argue with me, I did not decree that people commonly refer to them as haddocks, I just report what *is*
10:15:21 <poglesbyg> fun stuff
10:15:31 <mcstar> geekosaur: argue?
10:15:48 <haasn> geekosaur: what is ‘lens’ in that analogy?
10:17:57 <geekosaur> if the platform is batteies included, lens is a full fledged transformer robot included :)
10:18:08 <edwardk> heh
10:19:10 <zq> anyone tried building llvm/llvm-base off 3.4svn? getting a config error about LLVMStructType not being found, despite the symbol being clearly visible via objdump
10:19:16 <mcstar> i didnt become any more skillfull after watching the podcast...
10:19:26 <edwardk> mcstar: the haskellcast one?
10:19:27 <mcstar> in regard of lens
10:19:30 <mcstar> yep
10:19:32 <edwardk> mcstar: sorry =)
10:19:37 <ReinH> mcstar: did you really expect to?
10:19:40 <mcstar> it was still educational :)
10:19:45 <edwardk> mcstar: heh
10:19:53 <ReinH> mcstar: or did you think you might have to... you know... work at it... a bit? ;)
10:20:01 <edwardk> it was really a pretty general discussion that happened to dive deep into lens at one point
10:20:04 <mcstar> ReinH: i expected something more tutorial-y, but that was my fault :)
10:20:15 <ReinH> mcstar: the podcast is definitely not a tutorial :) There are lots of those
10:21:07 <mcstar> ReinH: also, i imagined, you were listening to some great beats during the interview, thats why the quality headphones, right?
10:21:39 <ReinH> mcstar: I do use them for music, yes
10:22:54 <edwardk> thoughtpolice++ # being on top of the whole haskell.org thing
10:24:25 <thoughtpolice> edwardk: thanks
10:24:37 <thoughtpolice> it's more like literally every time something goes wrong, i'm somehow awake at that hour
10:25:07 <thoughtpolice> which is nice on one hand :P
10:25:08 <edwardk> thoughtpolice++  # the reflection tutorial is pretty sweet too
10:25:48 <edwardk> it lets me delete the created but completely unpopulated one i have locked on the site ;)
10:25:56 <ReinH> reflection tutorial?
10:25:58 <thoughtpolice> lol
10:26:01 <haasn> edwardk: does geometric algebra have an elegant solution for ‘is a point a contained within a triangle given by (x,y,z)’ ?
10:26:04 <thoughtpolice> thanks again :)
10:26:07 <edwardk> ReinH: https://www.fpcomplete.com/user/thoughtpolice/using-reflection
10:26:14 <ReinH> ty
10:26:24 <edwardk> haasn: sort of
10:26:59 <edwardk> haasn: actually let me point you to a more advanced version of the topic from a thesis of mine
10:27:18 <haasn> edwardk: I need to be able to understand it :)
10:27:50 <mcstar> dont worry, his theis is heavily commented
10:27:50 <edwardk> http://comonad.com/thesis.pdf has a draft of my first thesis, it covers oriented projective geometry and stabbing line problems assuming no more than basic linear algebra understanding and a willingness to wade through a sea of definitions
10:28:28 <ReinH> haasn asks an offhand question. edwardk wrote a thesis on it.
10:28:34 <haasn> that was fast!
10:28:36 <edwardk> that draft is a bit off from the real version of the thesis after i _think_ around 11.4
10:28:40 <ReinH> This is why I love #haskell
10:29:09 <roconnor> haasn: presumably you can check that the signed distance between each of the 3 lines is positive.
10:29:20 <edwardk> but you can follow along through there. if you need any of the material later in the thesis after that, i don't think anyone but my advisors ever waded through it that far, then i can explain it in person
10:29:49 <roconnor> (or is all the same sign if you have unoriented triangles)
10:30:08 <edwardk> but in general we can view 'stabbing' a polygon with a line segment as using the underlying bilinear form for the plucker quadric to test sided-ness, but this requires adding orientation to your projective geometry/geometric algebra
10:30:27 <haasn> roconnor: makes sense
10:30:36 <roconnor> haasn: the textbook on GA is really good.
10:30:43 <edwardk> roconnor: thats basically the thing i was suggesting =)
10:30:58 <haasn> edwardk: yeah that's sort of what I was guessing
10:31:01 <jfischoff> dcoutts: it was split-objs. So question, will anything bad happen if I disable it?
10:31:03 <haasn> I saw your Plucker.hs
10:31:07 <edwardk> check that the signed distance to the point for all 3 lines has the same sign assuming the line segments are all oriented head-to-tail
10:31:15 <dcoutts> jfischoff: your binaries will get bigger
10:31:38 <jfischoff> dcoutts: 2x, 10x, 100x roughly?
10:31:51 * roconnor had not considered triangles with randomly oriented edges.
10:31:54 <edwardk> the signed distance is the underlying bilinear form for the plucker quadric
10:31:59 <haasn> roconnor: is that even possible?
10:32:10 <haasn> they're either counter-clockwise or clockwise
10:32:20 <edwardk> haasn: in 3d space i may want to 'stab' the triangle from the front or the back
10:32:37 <roconnor> haasn: if you are really really bad at geometry you can take points A B C and make edges AB AC BC.
10:32:39 <haasn> edwardk sure likes s t a bbing
10:32:50 <jfischoff> dcoutts: nv
10:32:51 <edwardk> but if i don't know if they are going around my point clockwise or counterclockwise i have to check the signs and see if they all agree, that tells me we pass each other in space consistently clockwise or counterclockwise
10:32:52 <roconnor> haasn: rather than edges AB BC CA.
10:33:00 <Kaini> Why does "curl" (the cabal package) want to load curl.dll, while the library is in fact called libcurl-4.dll (Built with mingw/msys)? Where would I tell cabal or curl to use this filename instead? (Of course I could rename libcurl-4.dll to curl.dll but this is somewhat ugly.)
10:33:50 <edwardk> haasn: the thesis goes through all that stuff from raw linear algbra. sadly i was prevented from using geometric algebra by my advisor. i wrote a 15 page version of the thesis that assumes GA ;)
10:34:02 <edwardk> geometric algebra is a very powerful tool
10:34:06 <haasn> heh
10:34:12 <haasn> yeah but a bit mind-boggling
10:34:16 <edwardk> haasn: did you see my module of code for geometric 'coalgebra'?
10:34:28 <haasn> yeah
10:34:34 <edwardk> http://hackage.haskell.org/packages/archive/algebra/3.1/doc/html/Numeric-Coalgebra-Geometric.html
10:34:50 <edwardk> i still need to use that in anger
10:34:51 <haasn> I remember something about inner and outer products, and blades
10:34:53 <haasn> that's about it
10:34:58 <c_wraith> Kaini: In general I recommend against the curl bindings anyway. They have some stability issues, especially when ssl and concurrency are involved
10:35:01 <dcoutts> Kaini: because it has no way of knowing that the dll is called that. You can edit the package registration to tell is that for ghci it should use curl-4
10:36:09 <Kaini> c_wraith, what would you recommend - I require SSL support (that's the reason i don't use Network.HTTP)
10:36:47 <edwardk> basically i can do a lot of calculations in geometric coalgebra 'backwards' from how i'd do them in geometric algebra, leading to avoiding the need to consolidate 2^n answers, but instead just diffuse information to those places, which means if i don't consume them later i can safe work proportional to 2^dimensionality of my space.. which may be a lot of work if that dimensionality is infinite! =)
10:37:26 <c_wraith> Kaini: http://hackage.haskell.org/package/http-streams or http://hackage.haskell.org/package/http-conduit depending on which api you like better
10:38:02 <Kaini> dcoutts, in fact i thought it's the duty of the configure script to find out the name
10:38:21 <edwardk> @remember ReinH haasn asks an offhand question. edwardk wrote a thesis on it.
10:38:21 <lambdabot> It is forever etched in my memory.
10:38:24 <dcoutts> Kaini: it checks that it can link against the lib, which it can
10:38:55 <dcoutts> Kaini: but ghci has to load the library differently, it has to LoadLibrary dynamically, rather than calling the system linker
10:39:12 <Kaini> c_wraith, thanks for the hints, I'll take a look at these
10:39:34 <dcoutts> Kaini: the system linker looks for curl.lib or libcurl.a, and that's fine
10:40:15 <Kaini> dcoutts, I think i get it. And I guess, libcurl.a does not know how its "partner" - the dll file - is called
10:40:35 <dcoutts> Kaini: the real difficulty is that the curl.lib/libcurl.a contains inside it the info to tell the runtime linker to look for libcurl-4.dll, but only the system linker knows this, nobody else. So ghci has no idea that it should LoadLibrary("libcurl-4.dll")
10:41:05 <dcoutts> Kaini: our workaround is that you can tell ghci to load a different set of libs. That's in its package registration info.
10:41:17 <Kaini> dcoutts, why doesn't ghc use the system linker?
10:41:32 <dcoutts> it does when it's linking an executable
10:41:45 <dcoutts> but ghci is not linking a .exe
10:42:31 <Kaini> dcoutts, so ghci does some "magic" to achive
10:42:46 <Kaini> dcoutts, so ghci does some "magic" to simulate the system linker, and it fails in this case
10:43:04 <ReinH> edwardk: aaaaand now I understand prisms https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
10:43:18 <geekosaur> Kaini, you can't use the sysme linker to load code into a running program
10:43:42 <geekosaur> it takes objects and libraries and emits a new executable. not code in an existing program's address space
10:43:51 <geekosaur> s/existing/running/
10:43:52 <dcoutts> Kaini: it's not doing magic, it calls the Win32 LoadLibrary()  API
10:44:09 <dcoutts> Kaini: which is the system dynamic linker, but how does it know what dll file to use?
10:44:53 <dcoutts> answer, it's saved in the package registration, what libs to link with, and we use the same for linking .exe files as for ghci with LoadLibrary
10:45:07 <dcoutts> but when those are different, then we have a problem
10:45:33 <dcoutts> Kaini: here's an example:
10:45:53 <dcoutts> ghc-pkg describe zlib
10:45:57 <dcoutts> extra-libraries: z
10:45:57 <dcoutts> extra-ghci-libraries:
10:46:19 <dcoutts> Kaini: when extra-ghci-libraries: is empty, we use the normal extra-libraries. These ones come straight from the .cabal file.
10:46:31 <dcoutts> Kaini: when extra-ghci-libraries: is non-empty then ghci uses those instead
10:46:54 <dcoutts> Kaini: e.g. for curl you'd want something like: extra-libraries: curl;  extra-ghci-libraries: curl-4
10:47:41 * dcoutts added this feature to ghc several years ago because we had this exact problem with the Gtk+ C dlls
10:48:54 <Kaini> dcoutts, ok, I understand the problem and the (possible) solution
10:48:57 <dcoutts> for gtk2hs we had some magic in the Setup.hs to set the extra-ghci-libraries field automatically.
10:49:00 * applicative hadn't remembered how informative ghc-pkg describe is
10:49:05 <dcoutts> but in general it's not easy to solve
10:49:09 <Kaini> thanks for the elaboration!
10:49:11 <dcoutts> because only the system linker really knows
10:49:17 <dcoutts> and it will not tell us
10:51:07 <dcoutts> __username__: using Haskell at work? :-)
10:53:29 <edwardk> @remember JaffaCake children are automatically killed if their parents die for any reason
10:53:30 <lambdabot> I will remember.
10:53:49 <monochrom> yikes
10:54:00 <edwardk> (from async)
10:55:59 <edwardk> @remember geekosaur if the platform is batteries included, lens is a full fledged transformer robot included :)
10:55:59 <lambdabot> Nice!
10:56:13 <litb> guys
10:56:21 <litb> > 10 != 20
10:56:22 <lambdabot>   Not in scope: `!='
10:56:22 <lambdabot>  Perhaps you meant one of these:
10:56:22 <lambdabot>    `!' (imported from D...
10:56:25 <litb> why doesn't that work
10:56:28 <edwardk> > 10 /= 20
10:56:29 <lambdabot>   True
10:56:32 <edwardk> we use /= not !=
10:56:57 <Yaniel> just like lua uses ~=
10:57:05 <haasn> /= looks like a lens operator to me
10:57:11 <haasn> what has the world come to
10:57:16 <b2coutts> it looks like an unimpressed face to me
10:57:22 <chrisdone> != looks like assignment
10:57:28 <beaky> why not !=
10:57:34 <edwardk> looks more like ≠
10:57:34 * chrisdone old Scheme programmer
10:57:38 <litb> oops
10:57:41 <haasn> =/=
10:57:55 <litb> sorry that was a basic question
10:58:07 <edwardk> litb: no problem. it tripped me up at first too =)
10:58:22 <chrisdone> basic questions are fine if they have basic answers =p
10:58:23 <monochrom> it didn't trip me up
10:58:48 <geekosaur> some of us started before C-derivatives became The Only Real Prgramming Languages and are not surprised when not-equal isn't C's !=
10:58:58 <haasn> LYAH included an example on /= so I guess I never even had to guess
10:58:59 <chrisdone> edwardk: you know if they plan on doing any more haskell podcasts soon? the first one was good!
10:59:11 <edwardk> litb: little things being gratuitously renamed in the various posix interop modules generally drove me nuts when i got here. i mean i'd been hacking on unix flavors forever so the old names were drilled into me
10:59:16 <b2coutts> != does make sense, though
10:59:19 <monochrom> I read the gentle introduction
10:59:24 <edwardk> chrisdone: my understanding is they may get marlow for november, not sure whats before then
10:59:36 <b2coutts> well, I guess haskell doesn't have the concept of ! being NOT anyway
10:59:41 <DanielDiaz> is there a reason for a module to take "forever" to compile? I am compiling one since 20 minutes ago... still waiting.
10:59:53 <chrisdone> edwardk: cool!
10:59:54 <litb> > let prime n = all (\c -> (n `mod` c) /= 0) [3, 5 .. truncate (sqrt n)]
10:59:55 <lambdabot>   not an expression: `let prime n = all (\c -> (n `mod` c) /= 0) [3, 5 .. tru...
10:59:57 <geekosaur> right, that's a C-ism
10:59:59 <litb> what's wrong with that ?
11:00:02 <b2coutts> DanielDiaz: depends on the module and the machine
11:00:04 <chrisdone> edwardk: i was confused when they didn't know what an isomorphism was, but then i thought that's good for a broad audience on the first episode
11:00:08 <b2coutts> dependencies as well
11:00:09 <litb> when i say "prime 10", it gives me all errors
11:00:32 <litb> that there is an ambiguity for "a0"
11:00:35 <geekosaur> litb, lambdabot is not the inside of a `do`, your let must be a let .. in expression
11:00:53 <geekosaur> oh
11:01:09 <litb> i was trying it inside ghci
11:01:11 <edwardk> yeah. i lost track of the audience a little bit in the middle and dove a bit too deep on lens, but i'm pretty happy with the general format. jekor and ReinH were just great to sit down and have a conversation with
11:01:30 <haasn> litb: I think you want a fromIntegral in there somewhere
11:01:34 <haasn> for the sqrt
11:01:38 <monochrom> "sqrt n" and "n `mod` c" is a conflict
11:01:39 <geekosaur> ^^
11:01:50 <geekosaur> sqrt takes a Floating, mod takes an Integral
11:01:50 <litb> oh
11:01:51 <edwardk> we just hopped on google hangout and chatted for a couple of hours and they made it pretty easy.
11:01:51 <haasn> litb: `mod` is only defined on Integral types, and sqrt is only defined on Floating types, which sort of exclude eachother
11:01:55 <chrisdone> nod. i wasn't familiar with some of the lens stuff, but i could follow it with interest
11:01:59 <haasn> fromIntegral can convert from any Integral type to any Num type, eg. Double
11:02:01 <litb> i wanna be able to call it with  prime 10
11:02:03 <barrucadu> edwardk: It was a very good first episode
11:02:05 <litb> and with prime 10.0
11:02:31 <litb> i guess it makes no sense to accept floats though
11:02:35 <chrisdone> i wonder if spj would do an episode. it's difficult to do enthusiastic arm waving on an audio podcast =D
11:02:37 <haasn> yeah
11:02:54 <edwardk> we recorded the local audio streams with audacity, but iirc, they never used mine, ReinH and jekor spent a lot of time cleaning up the audio though
11:02:57 <edwardk> hahaha
11:03:20 <haasn> chrisdone: you didn't see the video?
11:03:49 <chrisdone> nope! i saw that was added fairly soon afterwards. i actually scooped up the audio as soon as it was put online and went for a walk with it on my ipod =)
11:04:38 <litb> > let prime n = all (\c -> (n `mod` c) /= 0) [3, 5 .. truncate (sqrt $ fromIntegral n)] in prime 10
11:04:39 <lambdabot>   True
11:04:43 <chrisdone> i can be a little difficult to visualise types when read out verbally, but i could follow the gist
11:04:44 <haasn> ah, okay; it was pretty fun to watch ReinH and jekor start smiling whenever edwardk joked about lenses, heh
11:04:46 <litb> looks like it doesn't work :)
11:04:54 <litb> but it looks all good
11:04:56 <haasn> I was pretty much that doing that myself
11:05:39 <monochrom> because you forgot to try 2
11:05:52 <chrisdone> i've often thought an audio version of haskell weekly news could be nice
11:06:10 <DanielDiaz> b2coutts: it is only one module, 285 lines... lot of lines are comments. And it is still compiling.
11:06:11 <monochrom> haha
11:06:11 <chrisdone> with the hosts chatting about the topics of the week that were of interest to them
11:06:14 <litb> monochrom: ah good point. but 5 should also have worked
11:06:15 <haasn> clearly work needs to be done on this fractal audio recorder
11:06:19 <mauke> litb: 5 > 3
11:06:24 <litb> ohh no it is greater than square. right xD
11:06:26 <monochrom> 5 is skipped. sqrt 10 is 3.something
11:06:43 <litb> i just was confused because I have it in my list comprehension
11:06:52 <scshunt> oh, hey litb
11:06:56 <scshunt> long time no see
11:07:02 <litb> ah coppro right
11:07:04 <DanielDiaz> b2coutts: I will try removing the last function I added.
11:09:26 <DanielDiaz> interesting, if I remove the definition of that particular function, the module compiles just fine
11:10:23 <scshunt> DanielDiaz: pardon me, but what's the issue?
11:11:13 <DanielDiaz> scshunt: since I added a function to a module, it takes forever to compile
11:11:39 <DanielDiaz> scshunt: with "forever" I mean "I waited 25 minutes and didn't compile so I stopped it"
11:11:42 <scshunt> DanielDiaz: interesting. Can you paste the function?
11:11:48 <DanielDiaz> scshunt: so I am doing
11:12:07 <chrisdone> @lpaste -- it's dangerous to go alone, use this!
11:12:07 <lambdabot> Haskell pastebin: http://lpaste.net/
11:12:15 <ReinH> haasn: :)
11:12:17 <lpaste> DanielDiaz pasted “Function” at http://lpaste.net/92254
11:12:33 <ReinH> edwardk: iirc yours recorded with all the audio so we couldn't use it
11:12:39 <litb> how to go backwards with a list comprehension?
11:12:44 <ReinH> although maybe we should have since your voice would have been clearest on it
11:12:52 <litb> if i first create it forwards and then reverse it, it looks like that is inefficient
11:13:23 <ReinH> chrisdone: hiya :) I know what an iso is but I got a little lost...
11:13:37 <DanielDiaz> of course, there are some types there that are defined in the rest of the module.
11:13:40 <ReinH> there were a lot of words flying around and I got dizzy...
11:13:54 <chrisdone> ReinH: understandable =)
11:14:13 <chrisdone> ReinH: what do you think about maybe checking out the "weekly news" as a thing?
11:14:44 <ReinH> chrisdone: what, like go over the top /r/haskell submissions? ;)
11:15:01 <raichoo> ReinH: I like the fact that you ask no matter if you know something or not. That way people who don't know what something means can learn :)
11:15:07 <chrisdone> ReinH: yeah or http://haskellnews.org/grouped
11:15:15 <ReinH> chrisdone: or haskell planet, etc
11:15:22 <ReinH> chrisdone: I like the idea
11:15:31 <ReinH> raichoo: :) I try not to be afraid to ask stupid questions
11:15:52 <chrisdone> yeah that's good for a podcast
11:16:05 <ReinH> chrisdone: honestly until recently I didn't connect my knowledge of isomorphisms to their use in lens
11:16:16 <ReinH> now I understand how Prism, etc, are based on isos
11:16:59 <ReinH> `au` was pretty useful as an intuition pump
11:16:59 <chrisdone> ReinH: you mean you were asking "what's an ismorphism in terms of lens?"
11:17:05 <ReinH> chrisdone: right
11:17:09 <chrisdone> ah, ok
11:17:16 <ReinH> like, I understand bijections :)
11:17:33 <chrisdone> gotcha
11:17:41 <c_wraith> hey, is there documentation for the proposed record changes in ghc 7.10 somewhere?
11:17:55 <chrisdone> still, it only took a couple seconds to mention what an isomorphism is in general terms, so it's good
11:17:59 <ReinH> yep
11:18:10 <ReinH> edwardk was very patient :)
11:18:36 <ReinH> chrisdone: also I figure, if I don't understand and I've been doing haskell for years, probably someone else won't understand
11:18:39 <ReinH> so I should speak up
11:19:12 <ReinH> not that I'm a particularly advanced haskeller, but maybe slightly more advanced than our target audience
11:19:15 <ReinH> which is EVERYONE :)
11:19:43 <chrisdone> i listen to Dan Carlin's Hardcore History, he aims at a general history enthusiast audience but often explains things that people might be expected to know but might actually not. soemtimes i'm like "yeah, yeah, i know what that is" other times i'm like "i didn't actually know that despite it being common knowledge", so i appreciate verbosity, i have a lot of patience for that on a podcast
11:19:52 <erisco> :t interleave
11:19:52 <lambdabot> Not in scope: `interleave'
11:20:13 <chrisdone> ReinH: yep
11:20:41 <ReinH> chrisdone: back to your question, a weekly news thing would certainly be easier to produce than an interview. Might be a good way to keep the podcast more regular without scheduling more interviews than we can handle
11:20:49 <ReinH> or drying up the pool of potential interviewees
11:20:52 <ReinH> either of which would be bad
11:21:12 <chrisdone> right
11:21:14 <ReinH> which is to say, there are lots of people we'd love to interview, but we can only reach a finite amount of them at a time
11:21:32 <ReinH> not that there aren't many interesting haskellers :)
11:22:05 <ReinH> I'll throw it by Chris and see what he thinks.
11:22:18 <chrisdone> cool =)
11:22:21 <ReinH> other Chris
11:22:31 <ReinH> .. obviously
11:22:49 <beaky> i like haskell
11:22:57 <ReinH> :t intercalate -- erisco ?
11:22:58 <lambdabot> [a] -> [[a]] -> [a]
11:23:20 <beaky> is haskell the state of the art in functional programming?
11:23:23 <chrisdone> ReinH: yeah at the end of the podcast "thanks chris" i thought "you're welcome"
11:23:42 <ReinH> beaky: there are a number of different states of the art, but Haskell is probably one of them :)
11:23:48 <ReinH> lmao
11:24:12 <erisco> ReinH, no :)
11:24:18 <ReinH> erisco: ok :)
11:24:23 <nopcode_> hey
11:24:41 <nopcode_> does pure functional programming ever get in the way of using advanced efficient datastructures / algorithms?
11:24:41 <erisco> > intercalate [1,2,3] [[4,5,6],[7,8,9]]
11:24:42 <lambdabot>   [4,5,6,1,2,3,7,8,9]
11:24:44 <nopcode_> was just wondering about that
11:25:03 <erisco> > intercalate "," ["hey","how","are","you"]
11:25:04 <lambdabot>   "hey,how,are,you"
11:25:14 <chrisdone> nopcode_: sometimes, some algorithms don't work purely, like an in-place sort
11:25:33 <ReinH> nopcode_: Many algorithms that depend on mutability need to be traded for functional algorithms
11:25:39 <ReinH> nopcode_: but there are lots of efficient functional algorithms
11:26:25 <edwardk> nopcode_: let me give you an example from er.. well just last night
11:27:02 <edwardk> nopcode_: i started porting bender et al's cache oblivious lookahead array into haskell http://supertech.csail.mit.edu/papers/sbtree.pdf
11:27:28 <ReinH> edwardk: maaaaaybe talk about finger trees first ;)
11:27:50 <ReinH> lol
11:27:50 <nopcode_> "A streaming B-tree is a dictionary that efï¬ciently implements insertions and range queries"
11:27:57 <nopcode_> how is that differnt from regular b-trees?
11:28:09 <ReinH> nopcode_: it's streaming. ;)
11:28:13 <ReinH> it says it right there...
11:28:21 <nopcode_> what does that even mean in this context? ;)
11:28:21 <edwardk> nopcode_: it is a b-tree you don't have to pick a block size for
11:28:24 <erisco> nopcode_, try inserting something into a tree without mutating anything
11:28:29 <edwardk> nopcode_: in particular this means it is optimal for all caches
11:28:30 <ReinH> nopcode_: I don't know. I was playing around. :)
11:28:48 <nopcode_> edwardk: i know what cache-oblivious means, i was just wondering about "streaming"
11:28:52 <nopcode_> so that means its functional?
11:29:05 <edwardk> nopcode_: streaming means that it works by continuous writes
11:29:10 <edwardk> the core algorithm is functional
11:29:23 <edwardk> but they then do a bunch of improvements to it to turn its bounds from amortized to worst case
11:29:41 <edwardk> i can get a nice functional version of the core algorithm (and have, and am working on finishing it up and benchmarking)
11:29:53 <edwardk> but i can't get the deamortization trick to work and retain a nice pure API
11:30:00 <nopcode_> ah so since it writes continuously, if you append something the whole thing is the "mutated" tree and if you truncate it to the previous length you get the previous content?
11:30:05 <ReinH> Man I wish I could read some of these for less than 20 quid :/ http://www.cs.ox.ac.uk/people/richard.bird/publications
11:30:09 <ReinH> I have his pearls book but still
11:30:36 <nopcode_> i want to learn some interesting language... consider haskell and erlang right now
11:30:46 <ReinH> nopcode_: both are interesting!
11:30:52 <nopcode_> do you know any fancy even higher level paradigm implementations?
11:30:54 <edwardk> so it should be something faster than, say, Data.Map, smaller than Map (~4n+o(n) bits overhead per entry) capable of being fully unboxed for some key/value types, that is cache oblivious, but it'd have more expensive asymptotics if used in a non-ephemeral manner
11:31:24 <edwardk> nopcode_: agda/coq are in some sense higher level
11:31:28 <ReinH> edwardk: can you define ephemeral there? That's the second time I've heard you use it in that context.
11:32:04 <monochrom> it means you don't use old values
11:32:10 <ReinH> nopcode_: Haskell and Erlang are about as dissimilar as two functional languages can get. I'd recommend learning both.
11:32:26 <edwardk> ReinH: it means that the asymptotics only hold if you consider any one 'use chain' generating new structures from old. i may have something that costs O(n) all in one step, but have paid it down by credits earned by earlier steps. that kind of analysis works in a setting where you only use the structure once
11:32:42 <ReinH> edwardk: ah
11:32:46 <beaky> how do i make my haskell code faster
11:33:08 <nopcode_> oh hey i mean "higher level" not in "more complicated to understand"
11:33:09 <ReinH> beaky: just like any other code: find slow things and make them less slow.
11:33:12 <nopcode_> as in
11:33:17 <edwardk> ReinH: but if you were to take something that was about to require an O(n) step for, say, the next cons or insert, and used it once, and then went back to the version that was still on the cusp and did it again you may have to pay the O(n) twice, and the 'credits you earned' earlier for not paying for the costs would be being spent twice
11:33:39 <Placinta> What is an example of a product type in haskell?
11:33:47 <beaky> (Int, Int)
11:33:48 <ReinH> edwardk: gotcha thanks
11:34:02 <edwardk> ReinH: so when i say the asymptotics hold for ephemeral usage i mean that it gets away with fast operations by 'paying for them in advance', but if you reuse the intermediate structures you may double dip on that analysis and make the asymptotics much worse than you expect
11:34:06 <chrisdone> beaky: use -O11 =p
11:34:08 <monochrom> (Bool, Char) and "data Joy = Ctor Bool Char"
11:34:25 <beaky> wow i thought it goes as far as -O2
11:34:27 <mcstar> what's the new pastebin?
11:34:30 <chrisdone> @lpaste
11:34:30 <lambdabot> Haskell pastebin: http://lpaste.net/
11:34:33 <ReinH> chrisdone: this one goes to 100
11:34:35 <ReinH> to 11
11:34:37 <edwardk> so in this case being functional requires me to give up the deamortization
11:34:38 <ReinH> wtf is wrong with my fingers
11:34:48 <chrisdone> beaky: just joking. it's an old spinal tap joke =p
11:34:50 <Placinta> If I have data MyType = Ctor1 Int Char | Ctor2 Char Int is that a combination of product and sum?
11:34:55 <ReinH> chrisdone: that's one more than 10
11:34:59 <chrisdone> ReinH: xD
11:35:07 <lpaste> mcstar pasted “point contained in triangle” at http://lpaste.net/92255
11:35:09 <ReinH> Placinta: yes.
11:35:17 <monochrom> yes, think of it like Int*Char + Char*Int
11:35:17 <beaky> how do you find out what is the slower part of a haaskell program
11:35:29 <ReinH> beaky: by profiling it.
11:35:32 <mcstar> who wanted to test if a point is inside a triangle?
11:35:48 <ReinH> beaky: for example, http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/profiling.html
11:35:49 <chrisdone> mcstar: i've wanted to do that a bunch of times
11:36:11 <beaky> ah thanks
11:36:17 <mcstar> hm, i didnt use my types, ignore those
11:36:21 <ReinH> beaky: there are other tools as well. Google knows where they are.
11:36:36 <chrisdone> for rendering word clouds and computer vision, that's useful
11:36:46 <ReinH> chrisdone: rendering word clouds... sigh
11:36:47 <beaky> my code is quite long
11:36:54 <beaky> and it does a lot of io
11:37:00 <nopcode_> whats the best haskell implementation for osx?
11:37:09 <mcstar> probably it is not as efficient or elegant than edwardk's, based on hypergeometric endomorphisms
11:37:10 <monochrom> ghc for osx
11:37:16 <mcstar> as*
11:37:16 <ReinH> nopcode_: download the Haskell Platform. It's a binary.
11:37:26 <ReinH> nopcode_: http://www.haskell.org/platform/
11:37:34 <chrisdone> ReinH: hey… word clouds are awesome, and you're just jealous because i've been talking to hot babes all day
11:37:42 <monochrom> Haskell Platform includes ghc
11:37:44 <ReinH> You can install via homebrew but the binary is easier.
11:37:59 <ReinH> monochrom: confirm, I assumed he meant "thing I can install to use Haskell" rather than "compiler" :)
11:38:08 <nopcode_> does haskell support multithreading / paralellization on multiple cores?
11:38:14 <ReinH> nopcode_: yes
11:38:17 <mcstar> haasn: take a look at my paste, maybe you can use it, idk
11:38:26 <ReinH> nopcode_: automatically, in most cases
11:38:29 <nopcode_> ReinH: how transparently?
11:38:32 <nopcode_> wtf?
11:38:33 <chrisdone> ReinH: my first ever word cloud! http://img155.imageshack.us/img155/6853/stmwordcloudhb0.png worked first time, naturally. haskell++
11:38:36 <monochrom> Haskell Platform is certain more complete and preferred. I just wasn't thinking.
11:38:55 <ReinH> nopcode_: which is to say, any parallelized code will automatically be scheduled across available cores
11:39:03 * hackagebot hscope 0.4 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.4 (BorisSukholitko)
11:39:06 <chrisdone> other algorithms http://imageshack.us/a/img514/9206/algosxh9.png
11:39:12 <nopcode_> ReinH: oh. i thought the old problem of auto-paralellization was finally solved ;)
11:39:20 <nopcode_> ReinH: is there like a parallel-map?
11:39:22 <ReinH> nopcode_: assuming that you allow this by running with -N or -Nx where x is the number of cores you want to use
11:39:54 <ReinH> nopcode_: here is a free ebook on parallel and concurrent haskell by Simon Marlow http://chimera.labs.oreilly.com/books/1230000000929
11:39:57 <ReinH> it is new and amazing
11:40:52 <mcstar> chrisdone: just a thought: smaller fonts should use lighter colors, to aid readability
11:41:02 <ReinH> nopcode_: in many cases you can parallelize something like a map simply by specifying a parallelization strategy
11:41:28 <ReinH> nopcode_: it does not parallelize automatically, no, but it does automatically schedule any parallelized operations across available cores
11:41:48 <ReinH> nopcode_: although you can specify thread afinity should you need to
11:41:55 <nopcode_> can i uninstall the haskell platform?
11:42:01 <ReinH> nopcode_: sure.
11:42:13 <ReinH> nopcode_: not sure why you would want to ;)
11:42:16 <nopcode_> SSD.
11:42:19 <nopcode_> not that much space
11:42:23 <Lethalman> nopcode_, this is interesting enough: http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
11:42:25 <chrisdone> mcstar: yeah, if you want them to be readable. alas, these pics are three years old now
11:42:26 <ReinH> nopcode_: just kidding :)
11:42:31 <nopcode_> got a lot of libs, compilers, stuff on my mbp already
11:42:52 <levi> chrisdone: What library did you use for the graphics generation in those word clouds?
11:42:58 <chrisdone> levi: gd
11:43:19 <chrisdone> not sure what i'd use these days, there's so much more choice! =)
11:43:46 <ReinH> nopcode_: once you go Haskell, you never go back. Or something.
11:44:25 <nopcode_> ReinH: i'm not that unhappy with c++ python and go
11:44:53 <ReinH> nopcode_: I don't blame you. Well, maybe for C++...
11:44:54 <chrisdone> i don't know many people that wrote their first 10k lines of haskell and abandoned it
11:45:01 <ReinH> chrisdone: shhhhh
11:45:06 <nopcode_> well i just don't know what to do in haskell
11:45:07 <levi> chrisdone: I've been doing a bit of playing with diagrams, but text layout isn't currently one of its strengths.
11:45:08 <nopcode_> that's the problem
11:45:29 <mcstar> anything you would do in the others except gui
11:45:37 <ReinH> or also gui
11:46:09 <nopcode_> so, opengl?
11:46:20 <mcstar> i dont consider it gui
11:46:28 <chrisdone> levi: yeah for this project it was just a trivial "render this string" and "give me the width×height of this string if it were rendered", not much more support than that. and it was bitmap. diagrams is scalable, right?
11:46:33 <mcstar> but certainly, you can use it for such purposes
11:46:40 <ReinH> mcstar: I wouldn't say gui programming is a main strength, no
11:47:08 <levi> chrisdone: Yes, it's all high-level vector specification of what you want to draw.
11:47:17 <ReinH> mcstar: It's probably not much worse than go for gui
11:47:27 <mcstar> idk about that at all
11:47:50 <ReinH> mcstar: Haskell at least has a package that claims to provide win32 bindings ;)
11:47:56 <mcstar> heh
11:48:01 <levi> chrisdone: It does have some text features, but from what I gather, a reliable way to get font metrics across the different backends is one of the issues with text.
11:48:02 <ReinH> mcstar: go is definitely not gui oriented
11:48:35 <ReinH> unless you consider web apps to be guis, which is probably how I'd write a gui in Haskell too if pressed.
11:49:03 * hackagebot bindings-nettle 0.1.1 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.1.1 (ClintAdams)
11:49:19 <chrisdone> levi: ah, gotcha. yeah i've found that text libraries in general just *SUCK*. i wanted a way to get a vector of points for a given glyph or string of gylphs including kerning, and i couldn't find any way to do it
11:49:33 <ReinH> It'd be neat to wrap up a (say) Yesod app and a webkit frame into a native OS X app...
11:49:50 <mcstar> yeah, i think it is correct to consider graphical web apps guis, they are just not desktop guis
11:50:00 <levi> chrisdone: Brent Yorgey has a Functional Pearl on the use of monoids in diagrams. It's worth reading if you haven't read it.
11:50:01 <ReinH> mcstar: but they could be! see ^ ;)
11:50:05 <chrisdone> levi: the only way i could think to do it was render onto a canvas and then literally scan the canvas to find the glyph boundaries. even the freetype lib *has* that vector of coordinates, but doesn't expose it, and the c code is really hard to decompose
11:50:08 <mcstar> ReinH: i was thinking about that actually
11:50:16 <ReinH> mcstar: I know a number of native mac apps that are secretly html/css/js, at least
11:50:21 <ReinH> limechat, for example
11:50:22 <mcstar> yeah
11:50:30 <edwardk> i really liked brent's paper
11:50:36 <mcstar> (i mean, i know they exist, dont know osx apps)
11:50:36 <nopcode_> chrisdone: so how does ftgl get the coordinates?
11:50:59 <chrisdone> nopcode_: dunno?
11:51:27 <nopcode_> i think it's based on freetype
11:51:28 <mcstar> edwardk: do you think operationally the 'signed distance' solution would be more efficient than calculating triangle areas 4 times?
11:52:20 * Lethalman would use haskell for anything but gui
11:53:45 * b2coutts would avoid gui regardless of language choice
11:53:57 <levi> Lethalman: That kind of attitude is why we don't have many nice Haskell gui abstractions! ;)
11:54:03 * mcstar hopes he would never need to write 'commercial' applications again
11:54:31 <chrisdone> http://chrisdone.com/panel.png  ← the panel at the top is a haskell using webkit
11:54:35 <mcstar> it would be nice to use haskell for hpc code generation
11:54:50 <Lethalman> levi, or because all the haskell gui libraries try to use an underlying imperative library
11:55:15 <mcstar> chrisdone: xmonad trickery?
11:55:15 <chrisdone> i just make my xmonad open a gtk window and attach a webkit to it =)
11:55:16 <Lethalman> or something like that, user interaction is more imperative than functional
11:55:28 <levi> mcstar: Lots of people seem to be looking at that.
11:55:31 <chrisdone> mcstar: trickery indeed. the panel is detached
11:56:12 <chrisdone> (or 'unmanaged' by xmonad, so it stays there on every workspace)
11:56:19 <levi> Lethalman: There's no reason you couldn't put a layer of FRP over an imperative GUI library.
11:56:20 <mcstar> im blessed with i3, was making a plasmoid workspace switcher for it (i3 has special requirements in that regard) but hasnt finished it
11:56:30 <Clint> what's a better way to do \n f iv -> foldM (const . f) iv [1..n] ?
11:56:37 <Lethalman> levi, because I don't like frp :)
11:56:53 <Clint> also whom do i harass about pkg-config libs on hackage?
11:56:56 <Lethalman> levi, I'd rather use an imperative language for writing the gui, and haskell for the logic
11:57:03 <Lethalman> but not haskell directly for the gui
11:57:13 <chrisdone> mcstar: what's i3?
11:57:28 <mcstar> the best window manager i have tried so far, imho
11:57:30 <levi> Lethalman: Well, whatever works for you! That's why we have hundreds of programming languages at our disposal.
11:57:36 <arkeet> ion3?
11:57:41 <mcstar> nope
11:57:49 <Lethalman> levi, in fact, it's because I don't think haskell is well suited for gui :)
11:57:54 <Clint> it's a different tiling wm
11:57:58 <arkeet> why can't things use googleable names :p
11:58:07 <chrisdone> it was called ion3, but they thought it would be confused with ion3, so they changed it to i3
11:58:09 <ReinH> arkeet: tell me about it
11:58:09 <mcstar> i3.wm.org or something :)
11:58:09 <zomg> Lethalman: sounds like the problem is just a lack of an amazing library for GUI ;)
11:58:26 <Lethalman> zomg, or finding the right pattern, probably frp is not the best
11:58:58 <chrisdone> the best gui library i've seen is still CLIM
11:59:05 <mcstar> cl ftw
11:59:17 <clahey> cl?
11:59:19 <chrisdone> but it's a whole system, not just an approach or toolkit
11:59:23 <ReinH> Lethalman: Consider that basically every GUI layer was written with imperative langauges in mind.
11:59:37 <zomg> I think something where you could declare a gui a bit similar to how HTML works might be good + being able to do some kind of two way data-binding
11:59:40 <ReinH> It makes sense that it's easier to interface with them from an imperative langauge, but that doesn't mean that Haskell is bad at GUI per se.
11:59:44 <mcstar> clahey: common lisp, some disease you can catch
11:59:54 <Lethalman> zomg, data binding is another thing I don't like
11:59:56 <clahey> mcstar, Oh god, I had that once.
12:00:02 <chrisdone> every component is reactive, but every component also has separation between model and presentation, and everything can interact with everything else or be presented in different ways
12:00:05 <zomg> Lethalman: why's that? in my experience it just makes things a lot simpler :)
12:00:10 <Lethalman> zomg, lately in ghcjs I'm developing a non-mvc single-page framework
12:00:16 <chrisdone> it's a shame no OS ever implemented it, computing would be a lot different today if it were
12:00:24 <ReinH> Lethalman: data binding is a less reasonable version of reactivity
12:00:36 <Lethalman> zomg, because I find it very limiting... good for making simple calculators
12:00:40 <ReinH> see also every Javascript data binding library that is not reactive
12:01:03 <levi> CLIM is a pretty nifty system.  Would be great for exploratory programming.
12:01:12 <chrisdone> yeah
12:01:22 <chrisdone> a haskell REPL in CLIM would be omg
12:01:48 <zomg> Lethalman: well at least in my experience it's pretty useful when you can say "ok this is a list, and this is how you render a list item." and then just give it a list and it'll figure out the rest
12:02:39 <Lethalman> zomg, yes, as said it's good for todo lists
12:03:08 <Lethalman> more complex stuff involve dependencies between data
12:03:41 <zomg> So then you have the ability to define the binding to something that needs to be evaluated
12:04:01 <zomg> solves it pretty well I think
12:04:16 <levi> Lethalman: You've expressed a lot of abstract discontent with current functional approaches, but not a lot of clear ideas about specifically what's wrong with them or what kind of approach is better.
12:04:26 * erisco has despised every GUI tookit/library/whatever he has ever worked with, regarding it as a filthy, steaming lump of... hopelessness
12:04:41 <Lethalman> levi, can you give me a complex application written with frp that I can use on my desktop?
12:05:03 <tomboy64> i'm looking for a variation of "takeWhile" that lets me include the equality ... e.g. takeWhile (/= 30) [1..]
12:05:08 <erisco> Lethalman, how about that FPS?
12:05:21 <tomboy64> (==30) is no option since the comparisons are a bit more complex
12:05:21 <levi> Lethalman: That's more abstract discontent.
12:05:29 <chrisdone> at fp complete in the IDE we use reactive "vars" and "signals" for pretty much everything
12:05:32 <erisco> mmm there was a grad project a few years ago. not sure where it's at now
12:05:33 <zomg> I've written some complex web based things which used declarative data binding and I had literally the easiest time I've ever written a web based GUI
12:05:36 <levi> "I don't like it because no one has developed it into what I want!"
12:05:36 <zomg> =)
12:05:57 <Lethalman> chrisdone, what particular frp library are you using?
12:06:06 <chrisdone> the main problem i see is haskell's record system isn't structural, like elm's, so it sucks a bit more
12:06:14 <erisco> levi, isn't that why we all build our own castles?
12:06:19 <Lethalman> zomg, I'd be interested in what kind of application you have written
12:06:29 <chrisdone> Lethalman: our own, it's in Fay (Haskell subset compiled to JavaScript)
12:06:39 <levi> erisco: Sure, I'm just curious if Lethalman has any interesting castle-building ideas, or is just expressing discontent.
12:06:50 <chrisdone> we kind of copy the Ref/MVar approach, but make a set of reactive vars, and then define widgets in terms of those
12:07:15 * erisco can't get over the confusion that people aren't actually in shock even though they start their sentence with "zomg"
12:09:21 <chrisdone> it's tricky to do any clever abstractions without type classes
12:10:01 <levi> Yeah.
12:10:36 <zomg> Lethalman: well as an example, one was basically a system which would let you edit a product and update a preview on the side of the editor live as you changed values. It had many interdependencies between attributes, like the currency affecting how it was rendered in the preview etc.
12:11:06 <zomg> plus in order for the currency box to render to begin with, you would need to have a certain other set of attributes selected and so on
12:11:08 <chrisdone> (not impossible, just, more annoying, less rewarding)
12:12:57 <ibotty> chrisdone: i liked your xmonad setup and saw your repo and was totally confused. now i might have figured some things out. is it right that dom.hs, ecma.hs, etc are just leftovers from before you factored that out into suave?
12:13:15 <chrisdone> ibotty: ah, maybe, yeah
12:13:47 <levi> BTW, there are languages such as Lustre that are essentially synchronous functional-reactive languages that are used extensively for highly-reliable embedded systems programming, such as flight-control systems.
12:13:53 <chrisdone> ibotty: might hold off on that, i had some trouble with webkit's javascript engine. the redundancy of fay doesn't seem to get gabrage collected as reliably as in v8 or firefox
12:14:14 <ibotty> chrisdone:  well. it all makes sense now. (well, what's your .i3status.conf?)
12:14:16 <chrisdone> ibotty: i'm currently using the version a few commits back where it's all in the xmonad repo only. that seems reliable. the fay version eats up memory and freezes after a few hours
12:14:21 <chrisdone> ibotty: sure i'll paste it
12:14:28 <ibotty> :D
12:14:46 <chrisdone> http://lpaste.net/3490493219647520768
12:14:49 <chrisdone> ymmv
12:14:50 <ibotty> thx
12:15:13 <edwardk> mcstar: i find that solving things with geometric algebra is usually very elegant and simultaneously very slow ;)
12:15:27 <ibotty> ah, i c. i wondered what magic you made for these icons
12:15:28 <ibotty> :D
12:15:42 <chrisdone> yeah it's using the fontawesome font in the css =)
12:15:50 <levi> There are a lot of interesting things in industry that don't show up as more than a blip in the pop-culture of internet programming groups.
12:15:50 <edwardk> mcstar: you can find a number of old flipcode forum posts on how to do triangle intersection testing efficiently and accurately. turns out these come at pretty drastic tradeoffs
12:16:01 <Lethalman> let's take for example the xchat I'm using now, what would be the hardest limit hit by frp?
12:16:01 <chrisdone> ibotty: hold up, i'll check exactly which version of my xmonad i'm using presently
12:16:14 <mcstar> edwardk: i just read a solution, that expresses the coordinates of the point to be tested, in a new bases, formed by 2 sides of the triangle, so simple, i feel stupid now :(
12:16:19 <Lethalman> or it's all doable without any problem
12:16:25 <edwardk> as a grown up i tend to just try to avoid doing the check. its like how i stopped trying to bsp everything and switched to kd-trees and my 2-fat trees just to avoid having to deal with non-axis aligned plane testing
12:16:30 <Lethalman> because then I'm indeed missing something
12:16:58 <edwardk> occasionally i still need to do it, but its surprising how often you can just refactor the issue away ;)
12:18:16 <mcstar> edwardk: the condition to be inside the tr, is simply (u >= 0) && (v >= 0) && (u + v < 1), where u and v are the new coordinates of the point
12:19:02 <edwardk> mcstar: yeah thats pretty common as a test when texturing
12:19:03 <levi> Lethalman: What do you mean by the 'hardest limit'?
12:19:19 <Lethalman> levi, something that is not natural to write in frp
12:19:36 <edwardk> you want to be careful because of 'shear' though to pick the two sides that form the 'rightest' angle to minimize numerical error iirc
12:19:57 <Lethalman> but maybe I picked the wrong example
12:21:00 <chrisdone> ibotty: ah, turns out the one i was using that was fine is indeed using fay, but works fine. so the commit is…
12:21:03 <levi> Lethalman: I haven't tried, so I couldn't tell you. It's not as if 'FRP' is a single library that you can include in a project and look up the haddocks for. It's more a design/architectural style.
12:22:04 <ibotty> chrisdone:  ah i see suave is using scotty. nice and clean :D
12:22:08 <chrisdone> ibotty: 53d776b5d6de2dc80d7cad288e74b74dc78ae1c6
12:22:19 <chrisdone> ibotty: hehe
12:22:46 <ibotty> it's right before you used suave.. i see :D
12:23:07 <chrisdone> yeah, suave is just moving the code out. but something at some point became bad =o
12:23:23 <chrisdone> i didn't investigate it much, got too busy and just wanted a working panel =p
12:23:38 <ibotty> i can sympathize with that :D
12:23:59 <ibotty> i'd have just restarted the panel every twenty minutes.. ehm
12:24:16 <chrisdone> lol that's what i was doing
12:24:19 <ibotty> (automatically, of course)
12:24:41 <ibotty> kind of the java way though
12:24:54 <chrisdone> is that commit working on your system?
12:25:16 <ibotty> i did not try yet. i'll have to integrate it into my setup first...
12:25:18 <chrisdone> you can check the fay code is generated at http://localhost:8888/
12:25:22 <chrisdone> ah ok
12:25:31 <mcstar> 404
12:25:34 <ibotty> hehe
12:25:35 <ibotty> :D
12:25:53 <ibotty> maybe http://example.com:8888 will work better
12:26:12 <jfischoff> what does 02 do that 0 does not?
12:26:15 <ReinH> edwardk: Do I have any really interesting options for representing a game tree other than Data.Tree?
12:26:21 <ReinH> I figured you might know of something
12:26:23 <chrisdone> i mean once you're running your xmonad should host on that port
12:28:57 <Lethalman> levi, I find it hard to think of a way to dynamically add content to a gui
12:29:04 <Lethalman> levi, for example: let's say I have only a button
12:29:18 <Lethalman> levi, then I want to create a box parent of that button that contains another button
12:30:14 <Lethalman> the code that does that is something at the top level of the program, not any point of the program I guess, is that right?
12:31:02 <Lethalman> but then, what happens to the circuit displaying that button
12:31:08 <Lethalman> I can't get my head around that
12:31:53 <Lethalman> as long as it's: change the label of the button, it's ok... but I'm unable to think of a way to achieve what I asked
12:33:16 <S_J> Is there a bible on multithreading?
12:33:49 <ReinH> S_J: I'm not sure if it's considered a bible, but Marlow's new book is great
12:34:26 <Lethalman> all the examples I found of frp was with static content that changed positioning, labels, etc... nothing very dynamic like adding/removing/moving widgets in the gui hierarchy for example
12:34:52 <Lethalman> if anybody knows of something more complex that can point to me, so that I give it a another try
12:35:44 <scriptor> ReinH: parallel and concurrent programming?
12:35:50 <arkeet> yes
12:35:52 <ReinH> Lethalman: if the GUI is some structure, like a tree of widgets, it shouldn't be difficult to rewrite that structure, for instance replacing (Button "foo") with (Box (Button "foo") or w/e
12:35:57 <ReinH> scriptor: yes
12:36:30 <ReinH> Lethalman: Haskell has plenty of tools for traversing such structures
12:39:02 <levi> Lethalman: If you view your signal structure as static, than I see why it would be difficult to model interesting GUIs. But there is no reason that the reaction to a signal can't be a change in the structure of your signal network.
12:39:31 <ReinH> levi: You could have a machine that takes signals and emits structure modifying traversals, etc
12:40:47 <Lethalman> mh
12:41:01 <Lethalman> real world example: splitting an editor (like emacs... or screen)
12:41:10 <Lethalman> I'm really stuck at how I could do such a thing
12:41:30 * Lethalman is still very limited in this kind of thinking
12:41:31 <mcstar> can reactive-banana change a compiled network description?
12:41:46 <mcstar> or what reactive lib are you talking about explicitely?
12:42:31 <Lethalman> ReinH, so... you mean I could use a "variable" to store the whole structure of the gui....
12:42:38 <Lethalman> mh
12:42:46 <litb> here's my 4th euler problem code in haskell: http://codepad.org/7yaUVW2A is there something i can improve with it?
12:43:01 <Lethalman> that is when some data structure changes, I rebuild the whole gui?
12:43:32 <ReinH> Lethalman: not necessarily "the whole" gui. The traversal can be more efficient than that.
12:45:08 <tomboy64> litb: is it problem #4?
12:45:16 <ReinH> Lethalman: but consider that changing the structure of a GUI is similar to AST rewriting.
12:45:21 <litb> tomboy64: yea
12:45:31 <Lethalman> mh :S
12:45:50 <mcstar> but which reactive gui library allows that?
12:46:11 <ReinH> mcstar: any GUI library uses an algebraic structure for its "widgets"? :p
12:47:01 <mcstar> i just looked at the reactive-banana documentation (since i only tried that before) and i dont see a way of building a dynamic gui
12:47:10 <monochrom> I know one. it's on top of gtk2hs, for easy coding of widget composition
12:47:35 <monochrom> I forgot its name. will take a while to find.
12:47:39 <ReinH> You could probably even do it with vtk
12:47:49 <ReinH> or vtk-ui at least
12:48:43 <mcstar> cant find on hackage
12:48:44 <ReinH> mcstar: I'm also trying to refute the general argument that "Haskell is bad at GUIs" as opposed to the more specific argument that "Haskell libraries are bad at GUIs" :)
12:49:28 <ReinH> I doubt any GUI library written before the existence of multiplates is going to be designed around GUI structure traversal and rewriting, for instance
12:49:58 <monochrom> I can't find it
12:51:12 <mcstar> i just have the feeling as if Lethalman's issue was a done deal, a triviality, but in fact you cant point to a lib. that is able to do it, no offense, just stating it
12:51:38 <levi> No one claimed that there was a library that could do it.
12:51:55 <ReinH> mcstar: I wasn't trying to make the claim that anything is trivial about it
12:52:02 <tomboy64> litb: start out with a list that simply contains the products, like [ x*y | x <- [1..999], y <- [x..999]]
12:52:11 <solirc> I'm currently thinking about configuration management for cabal packages
12:52:22 <tomboy64> litb: then reverse the list and filter non-palindromes. head is your solution.
12:52:35 <solirc> Is there already something that gives me all transitive dependency of a package?
12:53:00 <tomboy64> litb: frankly i have no idea why your code is so long :-}
12:53:39 <levi> mcstar: Earlier, I specifically said that 'FRP' is not a library as much as it is a design/architectural strategy for interactive programs. It's also an open area of research.
12:53:52 <tomboy64> > reverse [ x*y | x<-[1..999], y<-[x..999]]
12:53:53 <lambdabot>   [998001,997002,996004,996003,995006,994009,995004,994008,993012,992016,9940...
12:54:01 <geekosaur> dunno about all dependencies but the packdeps package poweers http://packdeps.haskellers.com
12:54:21 <litb> tomboy64: hm i've just starting with haskell again after a few years of silence
12:54:22 <mcstar> levi: yeah, i know that it is a research topic, with no clear winner yet
12:54:27 <levi> Haskell does not have a particularly wonderful GUI story right now, but I don't think that's a fundamental thing so much as it is a merely difficult thing. :)
12:54:39 <litb> so, this is my second day doing haskell. i've solved 4 problems with it ^^
12:54:53 <Taneb> litb, :)
12:54:56 <litb> tomboy64: i guess it can all be written much shorter
12:54:58 <tomboy64> litb: congrats ;)
12:55:07 <litb> thanks xD
12:55:12 <monochrom> litb: there is such a thing as "div x y", you don't have to fromIntegral and then truncate...
12:55:33 <litb> looks like i'm abusing list comprehensions
12:55:38 <poglesbyg> NOOB question. I'm trying to install the "strings" library. How do i use it in ghci?
12:55:46 <litb> monochrom: ah i had no idea
12:55:52 <chrisdone> has gui stuff isn't great, but ime it's no worse than the usual
12:56:03 <ibotty> poglesbyg: install it with cabal and import it in ghci
12:56:11 <monochrom> litb: in fact, even better, there is "divMod" and does both mod and div
12:56:16 <poglesbyg> okay how do i import in ghci?
12:56:17 <tomboy64> poglesbyg: huh? did you try import Data.String?
12:56:49 <poglesbyg> i thought i did, is it differenct from ":l ..." command
12:56:50 <b2coutts> :t divMod
12:56:51 <lambdabot> Integral a => a -> a -> (a, a)
12:56:55 <b2coutts> cool
12:57:16 <dmwit> poglesbyg: :m, import, and :l are all subtly different, yes
12:57:25 <tomboy64> poglesbyg: :l is to load your own code. if you want to import libraries, use import
12:57:29 <poglesbyg> i know :l is load
12:57:46 <litb> monochrom: ah excellent
12:57:49 <monochrom> it's Data.Strings. with an ending s. but yeah, import Data.Strings or :module +Data.Strings
12:58:10 <poglesbyg> thanks
12:58:23 <monochrom>  :load is for when you have *.hs files
13:01:29 <poglesbyg> works now :P
13:01:37 <litb> monochrom: works fine: http://codepad.org/UxZYNA2t
13:01:56 <litb> didn't know one can use patterns with "let"
13:03:34 <linduxed> do pretty much all of the haskell projects use camelcase?
13:03:36 <litb> tomboy64: i thought that it would be faster to start with the list of palindroms, than to start with the factors. guess i was wrong
13:04:15 * hackagebot language-ecmascript 0.15.2 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.15.2 (AndreyChudnov)
13:04:43 <b2coutts> litb: oh, it's that problem
13:05:09 <b2coutts> I remember coming either to here or ##math a while ago expressing distaste for the fact that there didn't seem to be a "nice" way of doing it that was also efficient
13:06:21 <litb> oh
13:07:12 <ReinH> which euler problem is that?
13:07:13 <lpaste> edwardk pasted “towards cache oblivious lookahead arrays in haskell” at http://lpaste.net/92256
13:07:29 <b2coutts> ReinH: find the largest palindrome which is the product of two 3-digit numbers
13:07:43 <ReinH> ah
13:08:22 <b2coutts> I tried for a while to find some sort of ordering such that I could iterate over the tuples, and the first one whose product was a palindrome would be the answer
13:08:42 <b2coutts> but iterating through them in such an order is nontrivial
13:09:05 <b2coutts> in decreasing order of the tuples' product, that is
13:09:39 <litb> to me it doesn't matter how long it computes as long as it gives the correct answer and the code looks clean :D
13:09:54 <b2coutts> I think I ended up settling for iterating by order of their sum, then checking the relatively small space of tuples that hadn't been checked yet but could have a larger product
13:09:59 <ReinH> b2coutts: you should be able to order them as: [(999,999),(999,998),(998,998),(999,997),...]
13:10:19 <ReinH> so that the palindromes are pre-ordered
13:10:32 <b2coutts> ReinH: this was my fist intuitition
13:10:54 <b2coutts> ReinH: sadly that orders them by sum
13:11:00 <ReinH> well shit :)
13:11:02 <b2coutts> but they need to be ordered by product
13:11:07 <b2coutts> haha pretty much
13:11:42 <ReinH> b2coutts: you should at least be able to make some generalizations
13:11:58 <dmwit> :t sortOn
13:11:59 <lambdabot>     Not in scope: `sortOn'
13:11:59 <lambdabot>     Perhaps you meant one of these:
13:11:59 <lambdabot>       `BSC.sort' (imported from Data.ByteString.Char8),
13:12:17 <ReinH> I mean, it's obvious that 9xx * 9xx is going to be larger than 1x * 1x
13:12:21 <lpaste> F pasted “network-multicast” at http://lpaste.net/1566376668795240448
13:12:43 <ReinH> b2coutts: so you should be able to separate the problem into alternates
13:12:58 <dmwit> ?let sortOn f xs = concat . M.elems . M.fromListWith (++) $ [(f x, [x]) | x <- xs]
13:12:59 <lambdabot>  Defined.
13:13:25 <dmwit> > sortOn (uncurry (*)) [(x, y) | x <- [100..999], y <- [x..999]]
13:13:30 <lambdabot>   [(100,100),(100,101),(100,102),(101,101),(100,103),(101,102),(100,104),(101...
13:13:39 <ReinH> b2coutts: as in: maybeMaxPalindrome class1 <|> maybeMaxPalindrome class2 <|> ...
13:13:41 <dmwit> Problem solved?
13:13:46 <b2coutts> ReinH: well, the issue is that unless you can absolutely iterate in order of product, you can't just iterate until you find a palindrome and be done
13:13:53 <forth> Hi, I'd like to use network-multicast but can't install it
13:13:59 <edwardk> dmwit: is that missing the undo for the schwartzian transform?
13:14:00 <b2coutts> you can sort of approximate, and that's kind of what I did
13:14:11 <forth> here is the message from cabal http://lpaste.net/1566376668795240448
13:14:20 <ReinH> b2coutts: I'm saying that you can definitely know that a certain range of values will always yield larger product than another range
13:14:20 <dmwit> edwardk: don't think it's missing anything =)
13:14:29 <ReinH> *products
13:14:30 <dmwit> :t sortOn
13:14:31 <lambdabot> Ord k => (a -> k) -> [a] -> [a]
13:14:39 <dmwit> type looks okay
13:14:58 <ReinH> b2coutts: I'm trying to figure out a way to classify them that doesn't involve touching all of them first though :)
13:15:56 <ReinH> b2coutts:  you could also use the ordering I presented above, which is an approximation of product order, and do a heuristic search
13:16:14 <ReinH> i.e. return the highest palindrome seen to a confidence interval of x
13:16:15 <b2coutts> that approximation gets quite bad as you go forward
13:16:41 <ReinH> wah wah
13:16:49 <dmwit> > sortOn (negate . uncurry (*)) [(x, y) | x <- [100..999], y <- [x..999]]
13:16:55 <lambdabot>   [(999,999),(998,999),(998,998),(997,999),(997,998),(996,999),(997,997),(996...
13:17:08 <b2coutts> you can obtain a large tuple by iterating by sum and taking the first palindrome you find
13:17:13 <b2coutts> say that tuple is (x,y)
13:17:36 <b2coutts> then, you can check all tuples whose coordinates aren't strictly less than x and y
13:17:43 <ReinH> > take 20 $ sortOn (negate . uncurry (*)) [(x, y) | x <- [100..999], y <- [x..999]]
13:17:49 <lambdabot>   [(999,999),(998,999),(998,998),(997,999),(997,998),(996,999),(997,997),(996...
13:17:53 <ReinH> well fine.
13:18:05 <b2coutts> visually, you have a rectangle of tuples, and the set of those tuples you don't have to check are a rectangle, with one corner at (x,y)
13:18:18 <ReinH> b2coutts: right
13:18:22 <b2coutts> when you consider that (x,y) will be pretty high, you cut out a very large amount of computation right there
13:18:42 <b2coutts> you can also do further ricing (i.e., you don't need to keep checking (999,x) tuples when x is below 200)
13:18:57 <b2coutts> and also you don't have to check tuples you alreader iterated over by sum
13:19:04 <b2coutts> I don't think I did that last step
13:19:19 <b2coutts> bottom line, you have to do some pretty ugly things to solve this question efficiently
13:19:36 <b2coutts> which made me sad and I spent a decent amount of time trying to prove otherwise
13:20:07 <ReinH> heh
13:28:47 <mcstar> looks kind of hideous http://i.imgur.com/FmfFqK9.png
13:36:06 <monochrom> hmm, it looks like s->(v,s) and then CPS-transform (v,s) to (s->v->w)->w
13:38:01 <mcstar> it is supposed to be a cps monad for code generation (metaocaml)
13:38:37 <c_wraith> Does the trick in https://www.fpcomplete.com/user/thoughtpolice/using-reflection fail the Data.Set test?
13:39:30 <c_wraith> Oh, I guess not, due to the precise type signature - that test can't even apply.
13:40:07 <c_wraith> It still looks like it should be problematic, though
13:45:38 <ReinH>  /win 26
13:45:40 <ReinH> er
13:45:54 <c_wraith> that's a lot of windows
13:46:15 <monochrom> /win vista
13:48:06 <ReinH> c_wraith: confirm, I am bad at irc housekeeping
13:48:36 <elliott> I went from over 70 windows to 20 once.
13:49:29 <b2coutts> haha
13:49:41 <b2coutts> a ton of channels or a ton of PMs?
13:51:05 <elliott> one-off junk /queries mainly, but also a few channels
13:51:48 <mcstar> let me try this new command
13:54:08 <forth> i'm using ghc 7.4.2 on openbsd 5.2 amd64 and trying to test git-annex but network-multicast won't install
13:57:21 <Eduard_Munteanu> How do you match a char and return a value in Parsec nicely? const Foo <$> char 'f'  is rather lengthy
13:58:16 <Eduard_Munteanu> :t (<$)
13:58:17 <lambdabot> Functor f => a -> f b -> f a
13:58:31 <Eduard_Munteanu> Nevermind, I just remembered that ^^.
13:59:24 <Sonarpulse> All over base, there are uses of Int were only natural numbers are valid, wouldn't Word be better?
14:00:00 <Sonarpulse> (relatedly, is fromIntegral :: Word -> Int compiled to a no-op?)
14:00:50 <ibotty> isn't word limited in size though? int is not
14:00:57 <Sonarpulse> Integer is bignum
14:01:01 <Sonarpulse> Int and Word aren't
14:01:16 <Sonarpulse> I think at least
14:01:35 <ibotty> you are right
14:01:43 <ibotty> http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Data-Int.html
14:02:00 <Sonarpulse> there should be Bignum for natural numbers though
14:03:23 <Taneb> Sonarpulse, "Wordeger"
14:03:33 <Sonarpulse> nice
14:03:36 <ibotty> :D
14:04:20 <Sonarpulse> though wouldn't Natural be a more approprate name?
14:04:42 <Sonarpulse> Nat4 Nat8 .. I think would be better too
14:04:50 <edwardk> :t Natural
14:04:51 <lambdabot> Not in scope: data constructor `Natural'
14:04:51 <Taneb> (Wordeger is just my silly joke)
14:05:03 <edwardk> > 4 :: Numeric.Natural.Natural
14:05:04 <lambdabot>   Not in scope: type constructor or class `Numeric.Natural.Natural'
14:05:05 <Taneb> There's edwardk's nats package
14:05:12 <edwardk> aw, no nats on lambdabot
14:05:12 <Taneb> @let import Numeric.Natural
14:05:13 <lambdabot>  Defined.
14:05:18 <edwardk> > 4 :: Numeric.Natural.Natural
14:05:18 <Taneb> > 4 :: Natural
14:05:19 <lambdabot>   4
14:05:19 <lambdabot>   can't find file: L.hs
14:05:28 <Taneb> > (-1) :: Natural
14:05:29 <lambdabot>   Ambiguous occurrence `Natural'
14:05:29 <lambdabot>  It could refer to either `Data.Number.Natur...
14:05:36 <Taneb> > (-1) :: Numeric.Natural.Natural
14:05:37 <lambdabot>   *Exception: Natural.(-): negative result
14:05:50 <Sonarpulse> does GHC still use GMP for Integer?
14:05:54 <edwardk> yep
14:05:58 <danharaj> edwardk: is the 'using' magic combinator in thoughtpolice's reflection tutorial available? I can't find it in constraints.
14:06:01 <burp> anyone familiar with persistent? I have a model with a field "categories [Text]" and want to select all with category "test", so I try selectList [ModelCategories <-. ["test]], it fails with No instance for (IsString [Text]). Is it possible at all to construct such queries with persistent out of the box?
14:06:12 <edwardk> the Natural stuff just uses Integer under the hood, not all the unsigned gmp machinery
14:06:35 <edwardk> danharaj: its in an example from reflection, but not in a module given to users
14:06:40 <edwardk> its in examples/*
14:06:51 <danharaj> oh
14:06:59 <danharaj> well it is hella cool and I want it standardly :P
14:07:10 <edwardk> Sonarpulse: we have an integer-simple fallback implementation for those for whom the GPL infection is too bad an issue
14:07:17 <edwardk> danharaj: hah
14:07:30 <edwardk> i might be talked into adding it to constraints if it isn't in there
14:07:38 <Sonarpulse> edwardk: I saw the wikipage
14:07:47 <Sonarpulse> but didn't know how up to date it was
14:07:47 <edwardk> rather i might be talked into taking a patch. let me rephrase =)
14:08:07 <edwardk> Sonarpulse: the pure implementation doesn't really try to be fast though
14:08:09 <danharaj> when I'm off company hours I'll put it together :P
14:08:16 <edwardk> danharaj: heh
14:08:30 <danharaj> edwardk:  so that's two GHC implementors evangelizing for your libraries ;) aiming for more?
14:08:40 <edwardk> danharaj: yes
14:08:45 <Sonarpulse> ok. I'd imagine it makes for a pretty frequent GPL violation as probably not many people know about the implementation
14:09:08 <edwardk> danharaj: gotta catch them all, then add some new ones
14:09:12 <Sonarpulse> edwardk: you are chairman of the core libraries commitee, right?
14:09:25 <chrisdone> this talk http://vimeo.com/72870861
14:09:26 <edwardk> Sonarpulse: i am
14:09:29 <geekosaur> hm, didn't they specifically permit the case where it's not directly exposed? or is that gone now?
14:09:30 <chrisdone> hilarious, and fascinating
14:09:54 <c_wraith> edwardk: That using magic allows you to break anything that depends on confluence, right?
14:10:07 <edwardk> Sonarpulse: including any documentation about that would be more of a ghc hq issue though
14:10:28 <Sonarpulse> Cool
14:10:56 <Sonarpulse> I guess standardizing a Natural package isn't too big a deal
14:11:05 <edwardk> c_wraith: absolutely. its a hack
14:11:21 <Sonarpulse> but what about changing functions like length and whatnot to use Word instead of Int?
14:11:35 <edwardk> Sonarpulse: nats is a dependency of semigroups. i'm perfectly happy to have it outside of the platform
14:11:45 <edwardk> Sonarpulse: it'd be more correct but way more painful for users
14:12:12 <Sonarpulse> Ok. nats is the name of your Natural package?
14:12:25 <edwardk> anyone who has written a lot of code manipulating arrays in c using unsigned lengths has run into problems where they subtracted two of them and then screwed themselves because they compared by checking if the result was < 0
14:12:38 <edwardk> Sonarpulse: sounds right
14:12:40 <edwardk> @hackage nats
14:12:44 <danharaj> edwardk: is there a way to desecrate constraints to replace monads other than reader?
14:12:54 <lambdabot> http://hackage.haskell.org/package/nats
14:13:13 <Sonarpulse> ah that's true, no bounds checking with Word_
14:44:28 * hackagebot karver 0.1.1 - A simple template engine, inspired by jinja2  http://hackage.haskell.org/package/karver-0.1.1 (JeremyHull)
15:03:57 <ReinH> Is (x.&.y == x) already defined anywhere?
15:04:10 <enthropy> has it been done somewhere to encode the idea that the two fundeps here are there (or not there?) in:   class C f a b | f a -> b, f b -> a where c :: f -> a -> b
15:04:56 <enthropy> I can have   type family FromA f a = b; type family FromB f b = a
15:05:24 <enthropy> then use ConstraintKinds to have abbreviations for the case where you have a FromA; FromB as well as FromA+FromB
15:05:49 <enthropy> but then that's 4 different constraints to name
15:06:11 <enthropy> maybe my question is how should those 4 constraints be named to make sense
15:06:16 <Sonarpulse> FFI can handle newtypes, right?
15:06:25 <Sonarpulse> what about newtypes with phantom type variables?
15:07:00 <donri> enthropy: maybe don't do an mptc with type families?
15:07:22 <enthropy> I want to share implementations though
15:07:25 <donri> enthropy: class C f where type A f; type B f
15:07:29 <enthropy> so you only define c once
15:08:18 <enthropy> donri: I have some cases which are  class C f a b where c :: f -> a -> b
15:08:22 <enthropy> sorry if that wasn't clear
15:08:40 <donri> enthropy: c :: f -> A f -> B f
15:10:59 <deech> Hi all, is there any way to check if the `extra-libs` specified in my .cabal file exist in my Setup.hs?
15:11:15 <dcoutts> deech: that's done automatically
15:12:32 <arianvp> What the actual hell
15:12:42 <arianvp> I have a project:  module Main where  main = putStrLn "Hello World"
15:12:49 <arianvp> and if I do "cabal install "
15:12:51 <arianvp> I get ExitFailure 1
15:12:53 <arianvp> .-.
15:12:57 <arianvp> what am I missing?
15:13:18 <lpaste> enthropy pasted “donri's suggestion” at http://lpaste.net/92258
15:13:35 <geekosaur> `ExitFailure 1` by itself is nigh-on meaningless
15:13:44 <geekosaur> use -v to get some details
15:14:00 <donri> enthropy: can't answer without seeing your original version :)
15:14:01 <deech> dcoutts: Within my build process I'm using make to build a statically linked C/C++ library which my Haskell files depend on. Am I save running make in the `preBuild` hook if I specify the library as a dependency?
15:14:30 <deech> dcoutts: s/save/safe
15:14:37 <arianvp> geekosaur: There doesnt seem to be any errors
15:15:05 <elliott> I don't believe that the only line cabal printed out was "ExitFailure 1"
15:15:44 <dcoutts> deech: the check for the `extra-libs` existing is done in configure
15:15:52 <lpaste> enthropy annotated “donri's suggestion” with “donri's suggestion (the original / work in progress)” at http://lpaste.net/92258#a92259
15:16:06 <arianvp> http://lpaste.net/92260
15:16:09 <dcoutts> deech: building a separate C lib within a cabal package is a bit tricky
15:16:39 <arianvp> is it because LICENSE is missing?
15:16:49 <enthropy> beyond line 153 is irrelevant I think
15:16:51 <arianvp> that´ s the only `error ` i see
15:16:53 <dcoutts> deech: it's set up to build C code into the same lib, or if using an external lib to have that pre-installed
15:17:09 <dcoutts> deech: it's plausible to do what you're asking for, but would need a bit of Setup.hs hacking
15:17:30 <arianvp> im clueless
15:17:36 <geekosaur> arianvp, yes per lines 53--54
15:17:52 <donri> enthropy: too much ;) but basically just move a and b from the instance C X a b to the type A type B
15:18:00 <arianvp> lmao oops
15:18:16 <arianvp> happens to the best I guess
15:18:29 <dcoutts> arianvp: if your .cabal file specifies a license file, and that doesn't exist, then it will fail during install
15:18:49 <deech> dcoutts: Ah. Would the `preConf` hook be a good place for this? Also is there a part of the Cabal source where it checks that the `extra-libs` exist?
15:19:06 <dcoutts> deech: it's not recommended to build during the configure step
15:19:25 <dcoutts> deech: but you can prevent the lib check, it's done in the postConf, so just override that and make it do nothing
15:19:39 <enthropy> donri: the `a' and `b' are not concrete types though
15:19:50 <deech> dcoutts: Awesome. Thanks!
15:20:53 <enthropy> if they were, there would be no point in writing this instance anyways
15:21:17 <enthropy> (Apply0 in the annotation, or C at the top)
15:22:51 <danilo2> Hi! Is there any GHC flag, that I can write on top of my file (between {-# and #-}}, which will couse the compiler to ignore that file? I simply want the compiler to behave like if I would change the extension of this file to something not known.
15:23:06 <donri> enthropy: then how would you write it as an mptc?
15:23:07 <monochrom> @pl \p -> run p k
15:23:07 <lambdabot> flip run k
15:23:39 <enthropy> donri: it's kind of there with the  Apply0 (mptc) and Apply' (constraintkind/type)
15:23:51 <enthropy> just I have 2 other combinations to name
15:25:01 <enthropy> it probably too messy to say  ApplyTypesAreBijective f a b => ...; ApplyTypesAreInjective f a b =>  ... ; whatever else those other ones are called
15:26:17 <enthropy> type ApplyTypesAreBijective f a b = (Apply0 f a b, a ~ FromB f b, b ~ FromA f a) -- doesn't really seem like a shortcut at all
15:26:18 <darthdeus> hey guys, this is probably a stupid question, but i wanted to compile a most basic .dylib from a haskell file and it doesn't seem to take my -no-hs-main into account, here's the source and the command i'm using https://gist.github.com/darthdeus/30587f5149a8ef9c76d5
15:26:32 <darthdeus> is there something fundamental that i'm missing?
15:29:55 <chrisdone> donri: !!!
15:30:23 <deech> dcoutts: `checkForeignDeps` appears to be the function I'm looking for. Thanks again!
15:33:33 <donri> chrisdone: wat
15:35:04 <darthdeus> (sadpanda)
15:39:15 <geekosaur> darthdeus, you also need to specify a module id so it doesn't become module Main (which must have a main function of some stripe)
15:39:24 <geekosaur> module Derp where
15:41:44 <darthdeus> geekosaur: perfect :) now i'm getting a different error though, but i guess that's just me passing wrong flags, i'll read some more docs
15:48:31 <darthdeus> hm seems like i'm stuck with a derp.o ... i guess that's not the same derp.o i would get from compiling a C program, right? (fyi i'm reading http://www.haskell.org/haskellwiki/FFI_complete_examples) there doesn't seem to be that much explanation
15:49:27 <darthdeus> i wish there was a book that explains all of this static/dynamic linking both in C and ideally in haskell as well, and how all of these compilers fit together
15:49:34 <geekosaur> um
15:49:44 <geekosaur> why are you using -static when you want a dylib?
15:50:18 <darthdeus> sorry for being confusing, i did this ➤ ghc -c -dynamic -fPIC derp.hs
15:50:35 <darthdeus> and got only derp.o, derp.hi and derp_stub.h
15:51:21 <napping> what did you expect?
15:51:42 <geekosaur> ok, so you have a PIC object. I'm not sure if ghc should even have the plumbing to turn that into a dylib; -c will always give you a .o as dylib is a link output thing and -c means don't run any link phase
15:51:44 <napping> sounds reasonable so far, you probably need to link the .o into a library yourself
15:52:03 <geekosaur> `man ld` to see how you generate a dylib
15:52:21 <geekosaur> (it requires a fair number of options to do it right)
15:53:50 <darthdeus> okay, i'll check it out ... btw can i use something like cmake that would "automate" this, or does haskell have it's own ecosystem of tools?
15:54:19 <donri> @where cabal
15:54:19 <lambdabot> http://www.haskell.org/cabal
15:54:19 <darthdeus> and yes, i'm such a noob that i don't know the difference between cmake, make, ghc, gcc, ld ... :P but it feels hard to learn other way than reading manpages
15:54:54 <geekosaur> ghc comes from a world where there are individual tools that each do one or a small number of things and you combine them together appropriately into a toolchin
15:54:57 <geekosaur> *toolchain
15:55:32 <jfischoff> my template haskell code is taking a huge amount of ram when compiling with profiling
15:55:59 <jfischoff> Should I be looking for spaceleaks?
15:56:14 <jfischoff> or is that expected behavior
15:59:31 * hackagebot bindings-gsl 0.2.1 - Low level bindings to GNU GSL.  http://hackage.haskell.org/package/bindings-gsl-0.2.1 (MauricioAntunes)
16:05:12 <tomboy64> grrrr
16:05:38 <tomboy64> why can't head and tail behave at least remotely sensible and at least give a line-number when erroring out!
16:05:58 <arkeet> what line number would they give?
16:06:13 <elliott> @where rts-cv
16:06:13 <lambdabot> I know nothing about rts-cv.
16:06:14 <elliott> @where rts-xv
16:06:14 <lambdabot> I know nothing about rts-xv.
16:06:15 <elliott> argh.
16:06:16 <elliott> @where rts-xc
16:06:16 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
16:06:37 <arkeet> or just don't use head or tail.
16:06:51 <tomboy64> arkeet: the line-number where they find the empty list
16:07:34 <arkeet> ??
16:07:41 <shachaf> arkeet: 58, obviously.
16:07:42 <arkeet> anyway, try elliott's suggestion.
16:07:43 <tomboy64> elliott: gonna try that
16:07:48 <arkeet> shachaf: alright.
16:07:50 <shachaf> https://raw.github.com/ghc/packages-base/master/GHC/List.lhs
16:17:29 <tomboy64> elliott: how do i run the -xc flag in ghci?
16:17:54 <elliott> dunno.
16:18:17 * tomboy64 sighs
16:18:20 <tomboy64> okay
16:18:20 <lispy> shachaf: there is a issue on github to stop treating .lhs files as markdown but I guess they still haven't fixed it?
16:19:10 <enthropy> @where xc
16:19:10 <lambdabot> I know nothing about xc.
16:19:14 <enthropy> @where -xc
16:19:15 <lambdabot> I know nothing about -xc.
16:19:24 <lispy> tomboy64: I guess the lesson here is that stack traces are not the way people diagnose crashes in Haskell programs
16:19:27 <arkeet> @where rts-xc
16:19:27 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
16:19:50 <arkeet> lispy: what is, then?
16:20:14 <lispy> Debug.Trace ?
16:20:24 <enthropy> tomboy64: you can load compiled code into ghci (if you first run ghc, then :load MyModule), so maybe it'll do something if you first compile with the above flags
16:20:27 <lispy> use that in place of printf style debugging
16:20:43 <lispy> arkeet: another technique is to avoid partial functions
16:20:47 <arkeet> but that *is* printf-style debugging.
16:20:58 <arkeet> lispy: and when some IO exception blows up your program?
16:21:01 <niteria> filter (== expensiveComputation x), will expensiveComputation be performed for each element?
16:21:32 <lispy> arkeet: try to locate the line some other way :)
16:21:35 <arkeet> niteria: why don't you test!
16:22:01 <arkeet> niteria: Debug.Trace is handy for these types of experiments.
16:22:19 <shachaf> lispy: I guess.
16:22:28 <enthropy> it might change with optimizations
16:23:27 <niteria> I'm pretty sure it isn't, but good point about Debug.Trace, I will try it
16:24:24 <arkeet> I'm pretty sure it isn't too.
16:24:58 <arkeet> but being pretty sure about something doesn't teach you anything.
16:26:34 <niteria> Debug.Trace confirms, I just hope it isn't optimization dependent
16:26:56 <arianvp> woohoo
16:27:03 <arianvp> my EDSL works (Y)
16:27:18 <arianvp>  nf (let_ [("x", Int 3), ("y", Int 5)] $ V"x" :+ V"y")
16:27:20 <arianvp> > Int 8
16:27:21 <lambdabot>   Not in scope: data constructor `Int'
16:27:21 <lambdabot>  Perhaps you meant one of these:
16:27:21 <lambdabot>    `I...
16:27:58 <alastor__> hi. I've set up a new data type like this: data NestedList a = Elem a | List [NestedList a] . so far so good but, when i start writing the function body, i try to do someFunc :: NestedList -> NestedList but i'm told by the compiler that "Expecting one more argument to `NestedList' .   In the type signature for `someFunc':"
16:28:37 <sipa> alastor__: yes, NestedList is not a type on itself
16:28:44 <sipa> alastor__: it takes a type parameter
16:28:52 <sipa> ('a' in your definition)
16:29:04 <alastor__> sipa: but haven't i just defined it via 'data' ?
16:29:17 <sipa> if your function works for _any_ NestedList, some :: NestedList a -> NestedList a
16:29:32 <sipa> but you could just as well write one that only takes a NestedList of Int's for example
16:29:41 <sipa> some :: NestedList Int -> NestedList Int
16:30:18 <sipa> or one that takes a NestedList Int, an returns a NestedList String
16:30:58 <alastor__> but how is it that we can use types on their own in signatures like this: length' :: [a] -> Int ?
16:31:19 <sipa> 'Int' in a type
16:31:25 <sipa> 'a' is a type
16:31:33 <sipa> [] is a type constructor
16:31:38 <sipa> NestedList is a type constructor
16:31:53 <sipa> NestedList Int is a type
16:31:57 <alastor__> hmmm
16:32:10 <sipa> [a] is a type
16:32:20 <sipa> '[a] -> Int' is a type
16:32:59 <_justjust> @pl f a b = g a b && h a b
16:32:59 <lambdabot> f = ap (ap . ((&&) .) . g) h
16:33:06 <sipa> (note that '[a]' is the same as '[] a')
16:33:10 <_justjust> is there something nicer?
16:33:54 <alastor__> ok i'll read your examples again and see if i can get my head around this. thanks sipa
16:34:33 <sipa> types are very much like values, really
16:34:41 <sipa> 5 is a value
16:35:02 <sipa> Just is a constructor
16:35:06 <sipa> Just 5 is a value
16:35:17 <monochrom> alastor__: because you define "data NestedList a = ..." not "data NestedList = ...", you have to say "NestedList Int" or "NestedList Char" etc but not "NestedList" alone
16:38:32 <alastor__> monochrom: oh so if I just wanted a NestedList without specifying what's in it I would just use "data NestedList" with no type variable afterwards?
16:38:38 <alastor__> does that make sense?
16:39:48 <monochrom> but you're forced to specify what's in it
16:39:54 <alastor__> i see i see
16:40:13 <alastor__> could i say it is a composite type?
16:40:20 <monochrom> no
16:40:47 <alastor__> hmm.. ok i'll eventually get this hehe thx for helping
16:44:42 <geekosaur> alastor__, consider thatthere's no reason you have to specify a concrete type when using it
16:44:47 <geekosaur> the same way as when you declsred it
16:44:50 <geekosaur> *declared
16:53:38 <implementation> @pl f (a,_,c) = (a,c)
16:53:38 <lambdabot> (line 1, column 5):
16:53:38 <lambdabot> unexpected ","
16:53:38 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
16:53:59 <implementation> @pl f (a,b,c) = (a,c)
16:53:59 <lambdabot> (line 1, column 12):
16:53:59 <lambdabot> unexpected " "
16:53:59 <lambdabot> expecting operator
16:54:06 <implementation> o_O
16:54:15 <Fuuzetsu> Any Hoogle maintainers on?
16:54:52 <enthropy> > (view _1 &&& view _3) (a,b,c)
16:54:53 <lambdabot>   (a,c)
16:55:02 <thoughtpolice> Fuuzetsu: unless you're talking about the webserver, Neil doesn't get on IRC very much. but he's very responsive by email
16:55:09 <implementation> thx enthropy ^^
16:55:11 <thoughtpolice> so i'd suggest doing that
16:55:38 <Fuuzetsu> thoughtpolice: I'll probably e-mail him then, thanks.
16:55:51 <joelteon> how do you do ORs in cabal files?
16:56:06 <joelteon> in the build-depends field
16:56:16 <amyers> Has anyone had problems with haskell-mode in emacs where loading a file just hangs emacs until you kill it with C-g?
16:56:32 <Fuuzetsu> joelteon: I don't think it makes sense to have an or.
16:56:43 <Fuuzetsu> amyers: do you mean loading into interpretter?
16:56:46 <joelteon> well, hackage says "OR"
16:56:47 <Fuuzetsu> interpreter*
16:57:05 <amyers> Fuuzetsu: Yeah, start interpreter with C-C C-b
16:57:15 <amyers> then C-c C-l
16:57:17 <Fuuzetsu> amyers: you probably have a custom prompt, that's causing a problem
16:57:28 <amyers> Fuuzetsu: I do have a custom prompt, not allowed?
16:57:40 <Fuuzetsu> You can hack it up http://stackoverflow.com/questions/7961786/emacs-hangs-in-haskell-mode-with-inferior-haskell-load-file-call
16:58:32 <implementation> enthropy: where the hell did you take "view" from? o_o
16:58:44 <enthropy> @hackage lens
16:58:44 <lambdabot> http://hackage.haskell.org/package/lens
16:58:54 <implementation> thx
16:59:11 <enthropy> and &&& is from Control.Arrow
16:59:45 <enthropy> if your code is making up the (a,b,c), you might be better off creating something like  (b,(a,c)) instead
17:01:02 <implementation> well, but at another point i need (a,b,c)->(a,b), then (b,(a,c)) isn't perfect, neither
17:01:16 <shachaf> You can just write: (\(a,b,c) -> (a,c))
17:01:45 <implementation> shachaf, well indeed i did that, but i wanted to see if there are other ways ^^
17:04:28 <joelteon> why do people use LANGUAGE pragmas in their source files, rather than extensions in the cabal file?
17:05:05 <enthropy> there's no 'cabal interactive' yet
17:05:10 <joelteon> there's cabal repl
17:05:15 <joelteon> oh wait, but that's in HEAD
17:05:50 <amyers> Fuuzetsu: Thanks, that worked
17:05:52 <shachaf> implementation: (view _1 &&& view _3) is pretty ad-hoc
17:05:54 <enthropy> also you might use some other tools (HLint?) that might not look at the cabal file
17:06:24 <S11001001> @ty (|||)
17:06:25 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
17:06:34 <Fuuzetsu> joelteon: aren't cabal extensions project wide?
17:06:41 <Fuuzetsu> I wouldn't want OverloadedStrings everywhere.
17:06:55 <c_wraith> Yeah, minimizing the scope of extensions is also handy
17:07:09 <c_wraith> especially for things like CPP or TH that cause significant grammar changes
17:11:45 <implementation> omg, i should really have a deeper look into lens o.o
17:11:58 <joelteon> I see
17:12:00 <arkeet> lens is cool
17:12:14 <arkeet> implementation: if you have questions or whatever, feel free to come to #haskell-lens
17:12:17 <arkeet> :)
17:12:38 <implementation> arkeet: thanks :)
17:12:39 <BMeph> If your tools don't look at your cabal file, I'm blaming the tools, not your files. :\
17:13:18 <ReinH> My list cofree comonad game tree works! I can minimax search it! Woo.
17:13:51 <BMeph> implementation: lens is The Future of Haskell...Join Us! (Join Us...join us...) ;)
17:16:08 <erisco> not convined by this ghci "upgrade"
17:16:21 <erisco> isn't letting me abort hanging programs
17:16:48 <erisco> still has some kind of bug evaluated my expressions (though might be ghc)
17:18:24 <erisco> > undefined :: [undefined]
17:18:25 <lambdabot>   *Exception: Prelude.undefined
17:18:41 <erisco> but the list is defined, just not the elements of, correct?
17:19:04 <mm_freak_> haskell & future .~ lens
17:19:07 <Nisstyre> > take 2 $ [1,2,undefined]
17:19:08 <lambdabot>   [1,2]
17:19:18 * tabemann from reading Okasaki's book wonders if there is any standardish implementation of radix tries in Hackage (even though Okasaki himself leaves the implementation of radix tries up to the reader)
17:19:27 <erisco> maybe not. what do I know :(
17:19:42 <c_wraith> tabemann: how do they differ from PATRICIA tries?
17:19:49 <c_wraith> tabemann: (which is what IntMap is)
17:20:11 <tabemann> c_wraith: a radix trie shortens paths where a node has only one child by merging nodes
17:20:21 <tabemann> so it is more compact
17:20:31 <c_wraith> Uh.  IntMap does that too
17:21:12 <fl00r> fwiw wikipedia claims that patricia trie is another name for it
17:21:25 <c_wraith> That'd make sense, then
17:22:21 <tabemann> I'm thinking partially of the mapping with string keys, which obviously IntMap doesn't do
17:22:36 <tabemann> and hashing a string to feed it into an IntMap defeats the whole point of having a trie
17:22:59 <tabemann> (and loses properties like being able to get all values with common key prefixes)
17:24:29 <c_wraith> There's a package for tries of anything that implement Bits
17:24:53 <c_wraith> though that doesn't describe your use case
17:24:58 <c_wraith> there's also bytestring-trie
17:25:29 <c_wraith> bytestring-trie claims to also be a patricia tree
17:26:03 <Sonarpulse> tabeman: If collections-package data structrues besides IntMap use a radix/patricia tree
17:26:05 <lilred> Hey, I was thinking about a functional equivalent to the builder pattern that would involve immutable datatypes, does such a thing already exist and where can I find a reference implementation?
17:26:24 <Sonarpulse> I agree the underlying radix tree should be factored out
17:26:29 <lilred> It basically boils down to a partial function that can receive an arbitrary number of arguments before being forced to produce a value as a result
17:26:41 <tabemann> c_wraith: the only problem with that is if you have a unicode string, you've got the expense of converting it into a ByteString
17:27:09 <Sonarpulse> lilred: pretty sure builder-pattern is just poor-man's currying
17:27:47 <arkeet> lilred: have you heard of difference lists?
17:28:20 <lilred> arkeet: I'm looking at it right now, not sure how that ties into my question though
17:28:43 <arkeet> maybe I don't understand what builder pattern means.
17:28:48 <lilred> Sonarpulse: currying takes a fixed number of arguments of predefined types, I'm looking for something that accepts a union of possible types, and does so a variable number of times
17:29:04 <c_wraith> arkeet: I think it means like StringBuilder in java
17:29:12 <lilred> arkeet: basically, building a value step by step, like c_wraith said
17:29:13 <arkeet> that was my first assumption.
17:29:25 <arkeet> wikipeda says something different for builder pattern.
17:29:31 <tabemann> lilred: and a difference list operation, provided you can deconstruct that into the action of some kind of cons-like operation, will support that
17:29:36 <Sonarpulse> lilred: see Data.Printf for a way to do var args
17:29:40 <tabemann> "builder pattern" means some sort of OO design pattern to me
17:29:49 <arkeet> yeah
17:30:00 <arkeet> Sonarpulse: printf isn't nice =(
17:30:09 <arkeet> shachaf: where's your monoidy printf-y thing
17:30:50 <tabemann> but yeah; it really sounds like lilred wants something that is a monoid that can then be fed into some function to give a result
17:30:52 <Sonarpulse> lilred: I know with google's guava, the builders are mutable for immutable data structures, which makes some sense
17:31:10 <lilred> tabemann: actually that's pretty much it, thanks for the insight!
17:31:22 <arkeet> I don't understand what tabemann just said.
17:31:46 <arkeet> oh that's what you mean.
17:34:22 <shachaf> @let now m k d = k (\m' -> d (m <> m')); later am k d a = k (\m' -> d (am a <> m')); run l = l ($ mempty) id
17:34:23 <lambdabot>  Defined.
17:34:25 <shachaf> That?
17:35:01 <arkeet> shachaf: yeah that
17:35:28 <arkeet> > run (now "hello " . later id . now " :-)") "shachaf"
17:35:32 <lambdabot>   "hello shachaf :-)"
17:35:38 <mm_freak_> i'm always irritated when reading "associative array"
17:35:57 <mm_freak_> it's such a nonsense technobabble term…
17:36:15 <arkeet> lol
17:36:23 <tabemann> to me "associative array" is just like "associative list", except you're storing the pairs in array rather than a list
17:36:32 <arkeet> next we'll be talking about commutative stacks.
17:36:44 <tabemann> wait
17:36:45 <c_wraith> I prefer non-associative coalgebroids
17:36:47 <arianvp> woot. implemented lazy evaluation for my toy-language .-.
17:36:48 <mm_freak_> tabemann: the "associative" is what irritates me
17:36:55 <arianvp> so now it's 2:30 am. time for sleep
17:37:01 <mm_freak_> arianvp: cool =)
17:37:12 <mm_freak_> arianvp: interpreted or compiled?
17:37:28 <arianvp> interpreted. And I didnt really implement it. Just messing with the `bound` library :P
17:37:39 <mm_freak_> yeah, bound is very useful =)
17:37:50 <shachaf> c_wraith: What's an associative coalgebroid?
17:38:04 <mm_freak_> if you're ever out of pain/depression, write a compiler for a lazy functional language
17:38:06 <arkeet> shachaf: we know what those are. but what's a non-associative one?
17:38:33 <arianvp> mm_freak_:  I'm a total noob. Im happy that I got static scoping to work
17:38:41 <mm_freak_> hehe ok
17:38:44 <arianvp> mm_freak_: And quite amazed too
17:38:56 <arianvp> I guess being sleepy really helps to get you into the zone
17:39:00 <arianvp> cant rememmber I wrote half this code
17:39:09 <mm_freak_> yeah, i can confirm that
17:39:17 <arianvp> YET it works
17:39:48 <arianvp> Hmm. Lets see if I can do anything fun with F-algebras in my toy language tomorrow
17:39:52 <arianvp> good night, y'all
17:40:01 <mm_freak_> have fun and good night =)
17:40:09 <arianvp> I always have fun(ctional)
17:41:20 <c_wraith> shachaf: technobabble
17:41:56 <c_wraith> (for the #haskell crowd)
17:42:24 <mm_freak_> (for anyone who has learned what "associative" means in school)
17:43:05 <mm_freak_> "key/value array" is shorter and correct
17:43:19 <arianvp> but what if my function is associative? ;)
17:43:25 <arkeet> association array.
17:43:41 <arianvp> I read : In haskell. instead of "in school"
17:43:45 <arianvp> i guess im really too tired
17:43:45 <mm_freak_> "dictionary"
17:43:51 <arkeet> "map"
17:43:58 <mm_freak_> "F"
17:44:02 <arkeet> ""
17:44:09 <arianvp> bottom
17:44:10 <fl00r> ''
17:44:14 <arkeet> ugh, arianvp wins
17:44:15 <mm_freak_>  
17:44:29 <fl00r> is it a space?
17:44:49 <arkeet> 
17:44:58 <arkeet> did that go through?
17:45:01 <fl00r> yep
17:45:04 <mm_freak_> is it ether?
17:45:20 <arianvp> Either Sleep Work
17:45:31 <arianvp> Maybe Sleep
17:45:34 <arianvp> I want to Just Code
17:45:45 <mm_freak_> arianvp: right now Work is probably uninhabitated
17:46:01 <arkeet> > cycle [sleep,work]
17:46:02 <arianvp> 2:45AM. yeh...
17:46:04 <lambdabot>   [sleep,work,sleep,work,sleep,work,sleep,work,sleep,work,sleep,work,sleep,wo...
17:46:14 <arianvp> cycle [eat, sleep, rave, repeat]
17:46:20 <arianvp> That song is banger.
17:53:06 <Sonarpulse> http://hackage.haskell.org/packages/archive/bitset/1.4.7/doc/html/Data-BitSet-Generic.html
17:53:42 <Sonarpulse> Bitset is a newtype with one type variable being that actual type, and the other a phantom type
17:54:10 <Sonarpulse> because newtypes of "basic types" can be used with the C FFI
17:54:13 <Sonarpulse> I would have hoped
17:54:34 <Sonarpulse> Bitset <sum-enum> Word8 would also be a valid type for an FFI variable
17:54:38 <Sonarpulse> but GHC seems to reject it
17:56:27 <c_wraith> the FFI variable corresponding to that should roughly be CUChar
17:57:10 <Sonarpulse> My guess is this has something to do with haskell not specializing parametric datatypes
17:57:54 <Sonarpulse> but if newtypes advertise "the runtime representation of the underlying type is the same"
17:58:28 <Sonarpulse> I feel newtype should be specialized even if normal datatype aren't
17:58:38 <danilo2> Is it possible n haskell to have some circular references in let block? I mean something like "let{a = f b; b = f a}" Is it even possible in any case?
17:58:51 <Sonarpulse> danilo2: always possible
17:59:08 <c_wraith> > let x = 0 : y ; y = 1 : x in x
17:59:09 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
17:59:31 <Sonarpulse> let { a = b; b = a } in a
17:59:52 <c_wraith> well, I was providing a somewhat more useful example than an infinite loop.  I hoped. :)
18:00:05 <begriffs> Question about monads. I wrote two very similar functions and wondering if there's a way to combine them into one more general function. First function: let prev = \x -> if x > 0 then return (x-1) else Nothing
18:00:09 <Sonarpulse> Just wanted to demonstrate bottom
18:00:12 <danilo2> Sonarpulse: I wanted to see any usefull example, but c_wraith has written a veryy good one :) - Thank you!
18:00:15 <begriffs> second function: let listprev = \x -> if x > 0 then return (x-1) else []
18:00:16 <Sonarpulse> but I guess a better example would be:
18:00:31 <Sonarpulse> let { a = b; b = a ; c = 500 } in c
18:00:49 <Sonarpulse> to illustrate the laziness too
18:00:56 <Sonarpulse> *better example than my old one
18:00:57 <danilo2> Sonarpulse: the examples you give are correct, but not useful I thin - am I wrong?
18:01:05 <Sonarpulse> yes
18:01:09 <begriffs> The only thing that differs in my two functions is the "empty" result, not sure how to express it in general.
18:01:14 <Sonarpulse> C_wraith is the most practicle
18:01:51 <Sonarpulse> danilo: if  you do another non-terminating in a strict+dynamic language, you might get a null ptr
18:01:53 <arkeet> begriffs: replace Nothing with mzero
18:01:58 <Sonarpulse> rather than bottom/infinite loop
18:02:07 <Sonarpulse> that is all I wanted to say
18:02:31 <arkeet> begriffs: you can actually use applicative instead of monad: pure instead of return, and empty instead of mzero.
18:02:40 <arkeet> or rather, Alternative instead of MonadPlus.
18:02:47 <danilo2> Sonarpulse, c_wraith: Do you imagine any example of such circullar "reference" (correct me If I name it wrong), which could NOT be done using simple function recursion?
18:02:54 <begriffs> arkeet: when I try mzero I get an error. Not in scope: `mzero'. I have Control.Applicative only included.
18:03:03 <arkeet> begriffs: mzero is in Control.Monad
18:03:22 <arkeet> but you should use Applicative stuff instead ;)
18:03:36 <arkeet> most likely, anyway.
18:03:40 <mm_freak> begriffs: s/mzero/empty/
18:03:47 <c_wraith> danilo2: only in operational terms.  a recursive let binding can result in sharing where a recursive function would not.
18:03:54 <Sonarpulse> danilo2: not sure what you mean.. there are combinators to do recursion short hand
18:04:06 <c_wraith> danilo2: the example I gave? That's actually a cyclic linked list in memory.
18:04:25 <begriffs> arkeet: what's a better example of a good use of monads? I just made this one up to try bind/return out.
18:04:42 <arkeet> it doesn't seem like an example of use of monads but ok.
18:04:47 <mm_freak> begriffs: also minor style note:  let listprev x | x > 0 = … | otherwise = …
18:04:49 <c_wraith> danilo2: if you were emulating that with a recursive function, the naive approach would destroy sharing, making it actually take space relative to how much of you use
18:04:55 <arkeet> yes, guards are good
18:05:08 <arkeet> begriffs: don't worry about monads too hard.
18:05:29 <erisco> c_wraith, what kind of sharing? how is it special?
18:05:30 <c_wraith> danilo2: You can recover the sharing without using let explicitly - but it looks kind of awkward.
18:05:40 <danilo2> c_wraith: could you tell me more about sharing please? I didnt saw this term before
18:05:50 <mm_freak> begriffs: forcing yourself into using monads won't really help your understanding…  a better way is to just write a small, but real application
18:06:00 <arkeet> @wiki sharing
18:06:00 <lambdabot> http://www.haskell.org/haskellwiki/sharing
18:07:04 <begriffs> mm_freak: sounds like a good idea.
18:07:14 <begriffs> Thanks for the help guys!
18:10:42 <danilo2> lambdabot, c_wraith: Ok so If I understand it good, If I'll transform c_wraith example to functions I can destroy the shring and the functions will be recomputed a lot of times instead of once per request on new element?
18:12:41 <c_wraith> danilo2: well, it depends on exactly how you write it as functions.  My point was that the naive way destroys sharing.  You can get it back, but it requires more thought.
18:13:04 <c_wraith> danilo2: since let blocks are explicitly about naming expressions, they're automatically shared.
18:13:36 <danilo2> c_wraith: Ok, so If I write these functions using let ... in - the sharing will not be destroyed?
18:14:14 <arkeet> any non-function binding is shared.
18:14:51 <Ghoul_> IRT the referential transparency issue, I'd just make it undefined to operate above int maxbounds
18:14:56 <c_wraith> danilo2: well, you have to be careful. The important part is functions.  Applying a function to a value (nearly) always results in a new value being computed, because function applications aren't shared.  (usually)
18:15:04 <Ghoul_> irt the wiki, just a side comment :P
18:15:23 <arkeet> c_wraith: not always?
18:15:34 <danilo2> c_wraith: Ok, so taking the example "let x = 0 : y ; y = 1 : x in x" - how can I transfer it to recursive function calls that ARE shared?
18:15:40 <c_wraith> arkeet: GHC does common subexpression elimination in limited cases.
18:15:50 <arkeet> right.
18:15:59 <lpaste> enthropy pasted “possible to parameterize instances based on constraints?” at http://lpaste.net/92261
18:16:05 <timUK> Hi all! anyone know how the syntax should be for this    showGFLoat (Just 3) [[1.1, 2.2, 3.3],[4.4, 5.5]]
18:16:06 <arkeet> danilo2: hm?
18:16:16 <arkeet> timUK: hm?
18:16:23 <timUK> can't get it to work though I could stick map infront
18:16:29 <arkeet> syntax is fine. what are you trying to do?
18:16:45 <arkeet> oh, showGFloat is a thing.
18:17:03 <arkeet> ShowS is a fancy name for String -> STring.
18:17:13 <arkeet> > showGFloat (Just 3) 1.1 ""
18:17:14 <lambdabot>   "1.100"
18:17:28 <timUK> just can't get it to work when its in a list 8(
18:17:33 <danilo2> c_wraith: Ok thank you :) I understand there is no easy method to know when GHC will make this optimizations?
18:17:35 <enthropy> > printf "%g.3" 1.1 :: String
18:17:36 <lambdabot>   "1.1.3"
18:17:43 <arkeet> > map (\x -> showGFloat (Just 3) x "") [1.1,2.2]
18:17:44 <enthropy> > printf "%.3g" 1.1 :: String
18:17:44 <lambdabot>   ["1.100","2.200"]
18:17:45 <lambdabot>   can't find file: L.hs
18:18:23 <timUK> oh that was easy !
18:18:27 <timUK> was trying for ages
18:18:31 <c_wraith> danilo2: well, start with the naive form.  What's that even look like as the result of a call to a recursive function?  (there are actually hundreds of answers - I just want to see what formulation you're thinking of)
18:18:39 <arkeet> if you want to go two lists deep, use (map . map)  :)
18:18:58 <timUK> ah no wonder i haven't learnt this yet!
18:19:02 <arkeet> and then you are well on the way to understanding lens.
18:20:17 <shachaf> I prefer to understand one len at a time.
18:21:43 <c_wraith> I'm still working on .
18:21:51 <c_wraith> I feel like there's more to it than I realize yet.
18:23:16 <timUK> arkeet: did you meant something like map . map (\x -> showGFloat (Just 3) x "") [1.1,2.2]
18:23:16 <danilo2> c_wraith: I was thinking about something like: http://lpaste.net/92262  (I know the code is "ugly", but I simulate the generated code - I'm generating Haskell code)
18:23:51 <arkeet> timUK: no
18:23:55 <timUK> ops i meant map . map (\x -> showGFloat (Just 3) x "") [[1.1,2.2]]
18:24:05 <arkeet> I put the parentheses in what I said for a reason.
18:24:09 <arkeet> ;)
18:24:13 <arkeet> (map . map) f = map (map f)
18:24:24 <arkeet> (think about it)
18:24:36 <timUK> hmm...  mulling over...
18:25:40 <erisco> :t map . map
18:25:41 <lambdabot> (a -> b) -> [[a]] -> [[b]]
18:25:56 <arkeet> use the types, Luke.
18:26:21 <arkeet> @@ @free @type map.map
18:26:22 <lambdabot>  Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:26:26 <arkeet> @@ @free f :: @type map.map
18:26:27 <lambdabot>  h . k = p . g => $map ($map h) . f k = f p . $map ($map g)
18:26:35 <arkeet> @@ @free map.map :: @type map.map
18:26:36 <lambdabot>  Extra stuff at end of line
18:26:40 <arkeet> erh
18:26:42 <arkeet> @@ @free mapmap :: @type map.map
18:26:43 <lambdabot>  g . h = k . f => $map ($map g) . mapmap h = mapmap k . $map ($map f)
18:26:48 <c_wraith> danilo2: ah, interesting.  In that case, you still get the sharing - the names a and b in main are shared, and they make up the (:) constructors in the list.
18:27:15 <timUK> ah okay got it sort of, what does the . do in that though?
18:27:19 <arkeet> function composition.
18:27:24 <arkeet> (f . g) x = f (g x)
18:27:46 <c_wraith> danilo2: in fact, your f and g are just f = (0:) and g = (1:)...  The fact that you're applying functions that wrap the list constructors doesn't really matter at all.
18:29:59 <timUK> thanks for the help all, cya!
18:32:21 <danilo2> c_wraith: Ok, so how can I destory the sharing? How do you know that in this case the sharing is preserved?
18:35:39 <c_wraith> danilo2: I was talking about producing the same value via non-let recursion..  let me give an example
18:36:08 <c_wraith> > let f x y = x : f y x in f 0 1
18:36:09 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
18:36:37 <c_wraith> danilo2: That's the same value, an infinite alternating list of 0s and 1.  But there's no sharing in it.
18:36:58 <danilo2> c_wraith: Ah of course, now I see your point! Thank you very much!
18:37:10 <c_wraith> you're welcome
18:37:35 <c_wraith> though I'm technically wrong.  each 0 is the same thunk.  each 1 is the same thunk.
18:37:46 <c_wraith> that would matter if they were complicated expressions instead of literals. :)
18:37:54 <c_wraith> But the list constructors aren't shared at all
18:38:05 <c_wraith> so it still takes memory proportional to the amount of it you consume
18:38:27 <danilo2> c_wraith: Ok :) I feel I have to read more about the sharing now. Thank you for your help :)
18:47:47 <flebron> Hi guise. Am I right in thinking that the concept of (a, b) -> c being isomorphic to a -> b -> c (i.e. the curry function) is one offshoot of the Curry-Howard isomorphism, with the type A ^ B being nonempty iff A and B are nonempty iff a tuple of (A, B) exists iff (A, B) is nonempty?
18:48:47 <flebron> Also, is there any other free theorem other than "x :: a => x is bottom" and "f :: a -> a => f is either id or const bottom" that a student may find reasonable to think of?
18:52:10 <applicative> arent you sort of complicating 'curry-howard isomorphism', the correspondence is between (a,b)->c and P & Q -> R on the one hand; and a -> b -> c and P -> Q -> R on another hand; and above all between curry :: ((a, b) -> c) -> a -> b -> c
18:52:27 <applicative> and the entailment P & Q -> R |- P -> Q -> R
18:53:13 <flebron> right, the thing that allows one to go from types to logic is said iso
18:54:37 <enthropy> there is a concrete type T that will have no effect when used with ~ ?
18:54:57 <enthropy> as in    (T ~ a) => a -- would be the same as just `a'
18:55:15 <geekosaur> I doubt it
18:55:44 * enthropy tries GHC.Prim.Any
18:55:51 <monochrom> so that (T~Int)=>Int is Int, and (T~Char)=>Char is Char?
18:56:07 <tel> flebron I don't know how comfortable you feel with it, but I found that reading the original Theorems for Free paper and working all the steps on a simple example is really informative
18:56:12 <enthropy> monochrom: exactly
18:56:15 <tel> (a -> a) is good
18:56:37 <monochrom> so that T~Int and T~Char are both true?
18:56:51 <tel> so is (Functor f => fmap id = id ===> fmap (f . g) = fmap f . fmap g)
18:57:07 <enthropy> yes
18:57:17 <flebron> tel: alright, i'll give that a shot :) i'm teaching algebra with a computational bend to it, so we're introducing students to haskell. as a fun piece of info when we were looking into type variables, i told them about x :: a and f :: a -> a
18:57:43 <monochrom> so that, because ~ is symmetric and transitive, Int~Char is also true?
18:57:44 <flebron> (also as a way to tell them "types are really really cool. please type your variables.")
18:58:28 <flebron> tel: isn't that kind of trivial since Functor f <=> fmap id == id && fmap (f . g) == fmap f . fmap g?
18:59:03 <applicative> wow, GHC.Prim.Any is kinda creepy
18:59:12 <applicative> what is it meant for
18:59:16 <Fuuzetsu> @package ghc
18:59:16 <lambdabot> http://hackage.haskell.org/package/ghc
18:59:19 <tel> flebron yeah, they're both the laws. I wrote it down wrong. It's more "any function fmap :: (a -> b) -> (f a -> f b) that has fmap id = id also has fmap (f . g) = fmap f . fmap g"
18:59:44 <monochrom> IIRC Data.Dynamic is implemented with the help of Any
18:59:45 <applicative> Any [], Any Int, Any '[] all have kind 'k'
19:00:09 <applicative> Any Either ...
19:00:41 <applicative> it makes anything of any kind into something of any kind
19:00:51 <applicative> ok its making sense to me now.
19:01:01 <flebron> tel: oh that's kind of cool :)
19:01:02 <monochrom> nevermind, probably a different Any
19:01:26 <elliott> Any :: k, that's all.
19:01:29 <elliott> same Any.
19:01:42 <monochrom> yikes
19:02:33 <tel> flebron I don't know how "teachable" the proof is—it uses a tricky representation of types as relations… I feel like if you stared at it long enough and abandoned the generality of it there'd be a really great simple statement in it, though
19:03:57 <tel> flebron actually I wish I had the time right now to look at it again. It's been over a year since I read that paper last.
19:04:00 <applicative> Any is not to be confused with AnyK :: BOX
19:04:39 <applicative> elliott: they kind of Any is indeed k, but it can take an argument
19:04:58 <applicative> its as if it were of kind k -> l so to speak
19:05:23 <enthropy> monochrom: ah I guess that's a dead end
19:05:53 <applicative> i think it sort of outdoes the :k query, :k Any Either Maybe is ... k
19:06:03 * monochrom is a cold-hearted logician
19:06:37 <applicative> Any Either Maybe '[] [] :: k
19:07:38 <applicative> Any Either Maybe '[] [] 1 Nothing "hi" :: k
19:07:49 * enthropy had an idea for solving http://lpaste.net/92261, but it apparently needs an inconsistent ~
19:08:16 <applicative> Any Any Any :: k
19:08:18 <monochrom> is k a kind such that: for all kind x, k x = k?
19:08:48 <monochrom> or perhaps it is not so much a property of k, but rather of Any
19:09:06 <applicative> seems like it must specialize to recieve any argument, but then yields whatever kind you like, so it can take more arguments similarly
19:09:39 <geekosaur> k unifies with any kind like x :: a unifies with any type?
19:09:43 <applicative> in Any Int, Any:: k specializes to (* -> k) or does that make sense
19:10:30 <applicative> geekosaur: yes its seeming like that, no? we have "undefined 12"
19:10:45 <applicative> in which case undefined specializes to Int -> * ?
19:10:47 <applicative> i guess
19:11:01 <geekosaur> yeh, that's certainly what it looks like
19:11:05 <geekosaur> undefined on the kind level
19:11:10 <geekosaur> or maybe the type level
19:11:26 <geekosaur> and AnyK is the kind level one
19:12:13 <applicative> ah indeed AnyK :: BOX and, of course, BOX :: BOX
19:12:25 <applicative> i'm a little behind with this ever advancing kind system...
19:17:49 <monochrom> https://www.dropbox.com/s/4sferqlnqmfhg7g/nu.txt
19:19:13 <_justjust> is there something for [(a,[b])] -> [(a,b)] already? like [(1,[1,2]), (2,[3,4])] -> [(1,1),(1,2),(2,3),(2,4)]
19:20:29 <enthropy> > concatMap (\(a,b) -> map (a,) b) [(1,[1,2]), (2,[3,4])]
19:20:31 <lambdabot>   Illegal tuple section: use -XTupleSections
19:20:52 <applicative> that's not very nice of lambdabot
19:20:52 <enthropy> > concatMap (\(a,b) -> map (\b -> (a,b)) b) [(1,[1,2]), (2,[3,4])]
19:20:53 <lambdabot>   [(1,1),(1,2),(2,3),(2,4)]
19:21:24 <tel> it ought to be something like (>>= strength)
19:21:28 <_justjust> thank you!!
19:21:31 <arkeet> > [(1,[1,2]), (2,[3,4])] >>= _2 id
19:21:32 <lambdabot>   [(1,1),(1,2),(2,3),(2,4)]
19:21:37 <arkeet> or strength
19:21:38 <tel> not that that's built in
19:21:38 <arkeet> yeah
19:21:43 <applicative> @pl f (a,b) = map (\c -> (a,c)) b
19:21:43 <lambdabot> f = uncurry (map . (,))
19:21:46 <tel> >>= uncurry strength
19:22:32 <arkeet> > [(1,[1,2]), (2,[3,4])] >>= sequence
19:22:33 <lambdabot>   Couldn't match type `[[a0]]' with `(t0, [t1])'
19:22:33 <lambdabot>  Expected type: (t0, [t1]) -...
19:22:35 <arkeet> oops
19:22:42 <arkeet> > [(1,[1,2]), (2,[3,4])] >>= sequenceA
19:22:43 <lambdabot>   Not in scope: `sequenceA'
19:22:43 <lambdabot>  Perhaps you meant one of these:
19:22:43 <lambdabot>    `T.sequenceA'...
19:22:45 <arkeet> > [(1,[1,2]), (2,[3,4])] >>= T.sequenceA
19:22:46 <lambdabot>   [(1,1),(1,2),(2,3),(2,4)]
19:22:53 <arkeet> there's something frmo base.
19:22:55 <arkeet> from*
19:22:55 <applicative> ah excellent
19:23:03 <tel> nice
19:23:17 <_justjust> thanks! :D
19:24:01 <tel> that's actually quite nice in a post-apocalyptic Applicative => Monad world kind of way
19:24:12 <applicative> :t concatMap $ uncurry (map . (,))
19:24:13 <lambdabot> [(a, [a1])] -> [(a, a1)]
19:24:33 <arkeet> tel: well, T.sequence would have worked too.
19:24:40 <applicative> > concatMap (uncurry (map . (,))) [(1,[1,2]), (2,[3,4])]
19:24:41 <lambdabot>   [(1,1),(1,2),(2,3),(2,4)]
19:25:26 <tel> arkeet yeah, actually, there's no benefit to weakening to sequenceA since it's the same functor taking the monad constraint
19:25:51 <arkeet> but there is if you switch [] for something else ;)
19:25:59 <tel> yeah
19:26:05 <tel> m (t (m a)) -> m (t a)
19:26:21 <arkeet> heh.
19:28:12 <applicative> :t join . liftM (uncurry (liftM . (,)))
19:28:13 <lambdabot> Monad m => m (a, m a1) -> m (a, a1)
19:29:32 <tabemann> dammit why am I implementing a *naive* cycle-detecting value comparison - oh yeah, because I need to be able to compare two data structures without relying on my *efficient* cycle-detecting value comparison...
19:30:03 <arkeet> tel: well the thing here is that for pairs, we don't even need an Applicative.
19:30:05 <arkeet> Functor will do.
19:30:07 <arkeet> because _2 is a Lens ;)
19:30:11 <arkeet> :t _2 id :: Functor f => (a,f b) -> f (a,b)
19:30:12 <lambdabot> Functor f => (a, f b) -> f (a, b)
19:32:00 <tel> arkeet ooh
19:32:21 <tel> arkeet hm, is there a type class for join without return?
19:32:28 <tel> because we'd need join too
19:32:42 <tel> > join . fmap (_2 id)
19:32:43 <lambdabot>   No instance for (Control.Lens.Tuple.Field2 a1 a0 (m0 b0) b0)
19:32:44 <lambdabot>    arising fro...
19:32:46 <tel> :t join . fmap (_2 id)
19:32:47 <lambdabot> (Monad m, Functor m, Field2 a1 a (m b) b) => m a1 -> m a
19:32:55 <arkeet> not that I know of.
19:32:59 <arkeet> there's Apply for Applicative.
19:33:08 <arkeet> but it's not terribly useful I guess.
19:33:33 <tel> Flattenable
19:38:38 <elliott> applicative: undefined :: a; undefined 1 2 3 :: a
19:38:44 <elliott> Any :: k; Any Either Int :: k
19:38:48 <elliott> I don't see much of a surprise
19:39:02 <elliott> it's been like this for quite a while btw iirc
19:41:24 <applicative> elliott: yes, we've been through this by now at some length
19:43:38 <applicative> what confused me above is that Any is declared explicitly as data Any a in GHC.Prim, that is, with an argument place.
19:44:42 <applicative> this bit has no similarity with the definition of 'undefined' in GHC.Err
19:45:01 <dpwright> I uploaded my first package to Hackage the other day, and it's reporting a build failure
19:45:15 <dpwright> http://hackage.haskell.org/package/HaskellNet-SSL-0.1.1.0
19:45:24 <dpwright> needless to say it builds locally
19:47:01 <dpwright> It seems to be complaining about a package which is a dependency of a dependency of my package
19:47:53 <dpwright> (cryptocypher-0.3.1, pulled in via tls/tls-extra from connection, which my package depends on)
19:48:04 <dpwright> does anybody have any clues about how to resolve this sort of dependency issue?
19:49:40 <dpwright> (cryptocipher, rather).  I notice it isn't a dependency in newer versions of the tls package
19:51:12 <mstksg> is there a reason why we can't target the architecture that the arduino microprocessors work on so we can compile arbitrary haskell code for it?
19:52:59 <geekosaur> http://www.haskell.org/haskellwiki/Arduino ?
19:53:00 <arkeet> mstksg: have you looked at ajhc? ;)
19:53:06 <zeiris_> Generating assembly for resourse constrained environments is an interesting problem. Haskell makes very different tradeoffs than you want for something with kilobytes of RAM.
19:53:08 <geekosaur> and yes, ajhc
19:53:40 <zeiris_> EDSLs are extremely interesting for those environments, though - look at everything to do with Atom.
19:54:26 <arkeet> hm, I can't tell if ajhc can target AVR.
19:54:32 <mstksg> geekosaur: did look at that, coudn't find any leads
19:55:06 <geekosaur> I don't think anyone has seriously targeted a haskell runtime for the arduino, as mentioned it's a bit too small memory-wise
19:55:11 <Cale> mstksg: Did you see the link to http://hackage.haskell.org/package/hArduino ?
19:55:11 <arkeet> yeah
19:55:37 <arkeet> Cale: I don't see anything there about compiling AVR code.
19:55:57 <arkeet> ajhc can certainly target ARM.
19:56:07 <zeiris_> The C generated by Atom should work fine for Arduino. Although Atom's purpose is completely different from Arduino's :)
19:56:14 <mstksg> Cale: yeah, i saw harduino a while ago; but i'm looking to be able to compile straight to the board instead of a remote controller
19:56:29 <arkeet> hm neat.
19:56:37 <zeiris_> What is the goal of Haskell on AVR? Because if it's making AVR development easier than it already is for beginners, that's probably barking up the wrong tree.
19:56:40 <Cale> mstksg: You want to run Haskell code on a machine with less than a megabyte of program memory?
19:56:50 <arkeet> zeiris_: haha :)
19:57:06 <geekosaur> ajhc is the only current compiler that has any hope of targeting a microcontroller. before that, nhc98 claimed to target such embedded systems, but usually the memory constraints were too tight
19:57:49 <Cale> It might be possible to do something, but I would consider a metaprogramming approach to be much more practial.
19:57:52 <Cale> practical*
19:58:15 <Cale> i.e. Write a Haskell library for generating AVR code.
19:58:18 <zeiris_> Retargeting the standard compiler isn't what you realistically want, anyway. You want to embed a language that lets you reason about memory and timing in hard ways.
19:58:35 <zeiris_> (With all the benefits of the type system.)
19:58:40 <Cale> Something like Atom.
19:58:50 <elliott> try ajhc.
19:59:01 <elliott> I hear they ran that on something with very little RAM.
19:59:11 <elliott> failing that, atom or copilot or something.
19:59:17 <mstksg> i just figured that if it's compiled to native binary it wouldn't be as bad as carrying around an entire runtime environment like java or other scripting languages
19:59:21 <arkeet> there are some demos of it running on a Cortex-M3
19:59:22 <arkeet> fwiw
19:59:27 <levi> There's 'very little RAM', and then there's tiny microcontrollers.
19:59:30 <Cale> http://hackage.haskell.org/package/atom
19:59:40 <mstksg> and that it wouldn't be too far from the native machine code that C would generate
19:59:42 <arkeet> but arduino is even smaller ;)
19:59:46 <zeiris_> The AVR is significantly below the ARMs targeted by ajhc in resourses.
20:00:06 <Cale> mstksg: At the very least, you have a garbage collector and a thread scheduler.
20:00:25 <mstksg> ah yeah, didn't realize that
20:00:30 <levi> Cortex-M3 has a wide range of capabilities, but its low end is pretty big compared to the Arduino-class AVR.
20:01:22 <levi> The M3/M4 family is a really nice platform for bare-metal coding, though, if you ever want to try that.
20:01:25 <zeiris_> There was an interesting Haskell-inspired and implemented language specifically for embedded devices whose name I forget. It was "inspiration" or something - it used some typechecked shtick for tracking memory access.
20:02:59 <mstksg> guess i'll put away the idea for now.
20:03:26 <mstksg> now if only there was a way for me to compile fortran for arduino.
20:04:19 * applicative demands a ghc flr his wrist watch
20:04:25 * applicative demands a ghc for his wrist watch
20:04:40 <Fuuzetsu> do you meant haskell-watch package?
20:04:43 <Fuuzetsu> mean*
20:04:47 <levi> The M3 has a built-in nested vectored interrupt controller, and the vector essentially stores function pointers rather than being a list of jump targets that you have to fill with jump instructions. The upshot is that you can program the thing entirely in C.
20:05:06 * applicative then demands idris for the microwave
20:05:14 * pharaun demands applicative's wrist watch
20:05:32 <zeiris_> It's a really interesting idea. It just needs a very strange mix of skills to tackle - functional programming combined with understanding of real-world embedded constraints.
20:05:35 * hackagebot HaskellNet-SSL 0.1.1.1 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.1.1.1 (DanielWright)
20:05:42 <geekosaur> someone's working on a wristwatch-factor android box, so that reduces to a previously unsolved problem :p
20:05:52 <pharaun> ooo nice
20:06:13 <zeiris_> There's the MSP430-based TI Chronos watch.
20:06:18 * geekosaur wonders what happened to that kickstarter
20:06:19 <zeiris_> They come with radio bits, I think.
20:06:22 <joefiorini> anyone have experience with the riak client? trying to query a bucket in GHCI, can't quite figure out the right way to do it
20:06:39 <levi> zeiris_: Synchronous functional reactive languages are big in some embedded areas. There's a lot of French research in that area, and Airbus uses it for their flight computers.
20:07:57 <levi> I've not looked into those languages in detail, but I imagine they're rather different in feel that Haskell.
20:08:11 <zeiris_> levi: ooh! Getting FRP to be useful for embedded code generation has to be easier than doing the same with actual code :D
20:08:13 <tabemann> about trying to put Haskell on embedded, wouldn't it be better to have a Haskell DSL generating code that we can then statically verify qualities like, that it operate in constant memory space
20:08:25 <geekosaur> that'd be Atom
20:08:30 <tabemann> s/operate/can operate
20:09:10 <levi> zeiris_: It's not quite the same as FRP as used in Haskell GUIs.
20:10:29 <tabemann> sigh.. the naive comparison is not catching all the equals cases as the non-naive comparison in the not-equals test, meaning there's a bug in one or the other... and it naturally is much more likely to be in the non-naive comparison just due to it being far more complex than the naive one... sigh
20:11:10 <levi> There are also sets of tools that allow you to design your system in a UML dialect and compile it down to embedded code. :P
20:11:28 * tabemann cringes at the thought of compiled UML
20:11:50 <zeiris_> Cringing is the first reaction, but I wonder if there's cases where that makes sense.
20:14:10 <tabemann> it's pretty much like programming your device in Java... except with drawing *lots* of lines and filling in lots of boxes (i.e. far less efficient than simply entering code as text)
20:15:23 <tel> Does anyone know of any other good DSL exposition papers such as "Composing Contracts"?
20:18:36 <tabemann> zeiris_: what makes more sense is the sort of programming that they do in industrial controllers, which is graphical but is more like FRP than it is like UML
20:18:58 <arkeet> lpaste should support https.
20:19:36 <arkeet> I guess for that you'd want a proper SSL cert unless you want to bother people with self-signed certs.
20:19:37 <levi> tabemann: There are a number of visual languages that are essentially functional dataflow model builders. Are those what you're referring to?
20:19:45 <tel> tabemann I've always wanted to see a comparison between FRP and Labview
20:20:02 <tel> I did a lot of Labview in undergrad and it always, always, turned into a rats nest
20:20:05 <tel> rat's
20:20:11 <arkeet> :)
20:20:15 <levi> UML has a *lot* of stuff in it now, it's not just high-level object descriptions anymore.
20:20:38 <levi> Especially when you get into dialects like SysML.
20:21:24 <joelteon> if I want to parse Text efficiently, should I use attoparsec or parsec?
20:21:30 <joelteon> parsec doesn't have any natively-Text combinators
20:21:55 <Fuuzetsu> joelteon: Attoparsec does
20:22:04 <joelteon> yeah, I know, and that's why I'm asking
20:22:04 <Makoryu> Doesn't a recent version of Parsec introduce Text support
20:22:11 <tabemann> levi: I'm referring specifically for the kind used for industrial controllers of a sort whose name I can't remember at the moment
20:22:14 <joelteon> well, it has a Stream type with Text involved
20:22:21 <joelteon> but all the combinators return Chars or Strings
20:22:27 <mstksg> tel: i think he's trying to draw an analogy as programming java compared to native programming is like drawing lines and circles instead of using fonts/text
20:22:44 <tabemann> programmable logic controllers, that's what I mean
20:22:46 <mstksg> er, maybe i'm wrong
20:22:56 <mstksg> he can speak for himself
20:23:34 <levi> joelteon: Attoparsec makes faster/more efficient parsers, last I saw, but is less helpful in the face of malformed input and parser debugging.
20:23:48 <levi> tabemann: Ah, like FPGAs and whatnot?
20:24:01 <tel> tabemann Is Labview in that class? I used it to do FPGA coding
20:24:17 <levi> My coworkers that do FPGAs largely do it in Verilog.
20:26:00 <monochrom> Haskell Weekly News!
20:26:34 <tel> levi I've always wanted to play with Verilog
20:26:59 <mahonii> so it does exist
20:27:13 <tabemann> levi: PLCs aren't FPGAs; they are just small embedded systems designed for controlling industrial systems
20:27:31 <levi> tabemann: Ahh, ok.
20:27:58 <tabemann> they're typically programmed in a visual manner that is kinda FRP-like because PLCs replaced hard-wired electrical systems and the language(s) used to program them are designed to emulate the logical structure of such electrical systems
20:28:15 <Fuuzetsu> is Cabal and cabal-install versioned separately? ‘cabal --version’ shows 1.17 but cabal list shows ‘Cabal’ as 1.18 and I'm pretty sure that's what I'm using (by GHC HEAD). I want to file a bug with the Cabal guys but not before I confirm that their fix that was supposed to make it into 1.18 actually doesn't work.
20:29:36 <geekosaur> they used to be quite out of sync version-wise
20:30:34 <tabemann> levi: okay, the name of the general sort of language used is "ladder logic"
20:30:57 <Fuuzetsu> How do I confirm that I'm on 1.18?
20:31:04 <tabemann> note that there are languages that aren't strictly ladder logic that have evolved from it, but which fit similar needs
20:31:20 <enthropy> Fuuzetsu: cabal --version gives you a version for Cabal and a version for cabal-install
20:31:23 <enthropy> right?
20:31:47 <Fuuzetsu> oh, you're right… it says 1.17 for both… I'll snoop around.
20:31:51 <Fuuzetsu> Can't believe I missed it.
20:35:02 <levi> tabemann: Yeah, I've been poking around looking at PLC information. It's like a weird little microcosm of programming. The primary difference from standard tiny microcontrollers seems to be hardening for industrial use rather than anything fundamentally different about the chips. There's just an entirely different programming culture around them.
20:35:59 <levi> From what I understand, Ladder Logic just simulates the sort of mechanical relay structures the PLCs replaced.
20:36:06 <geekosaur> yes
20:36:55 <geekosaur> and if you hunt around you can hear the old timers grump about how the relay-based stuff worked instantaneously but the new PLCs are emulated on CPUs and have to scan (hence slight delays even given they're hard realtime)
20:37:16 <Fuuzetsu> Hmm, I think what I need is cabal-install HEAD
20:39:10 <joelteon> @pl \x -> if f x then Just x else Nothing
20:39:13 <lambdabot> flip (ap (if' . f) Just) Nothing
20:39:13 <lambdabot> optimization suspended, use @pl-resume to continue.
20:40:01 <arkeet> :t \x -> guard (f x) >> x
20:40:02 <lambdabot>     Could not deduce (FromExpr Bool) arising from a use of `f'
20:40:02 <lambdabot>     from the context (Show (m b), MonadPlus m)
20:40:02 <lambdabot>       bound by the inferred type of
20:40:08 <arkeet> :t \f x -> guard (f x) >> x
20:40:09 <lambdabot> MonadPlus m => (m b -> Bool) -> m b -> m b
20:40:15 <arkeet> this ought to be a thing.
20:40:32 <arkeet> :t \f x -> (x >>= guard . f) >> x
20:40:32 <lambdabot> MonadPlus m => (b -> Bool) -> m b -> m b
20:40:41 <arkeet> that looks suspiciously like filter.
20:41:00 <ezrios> @hoogle filterM
20:41:01 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
20:41:01 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
20:41:08 <arkeet> no that's something else.
20:41:12 <ezrios> evidently
20:41:34 <geekosaur> :t when
20:41:35 <lambdabot> Monad m => Bool -> m () -> m ()
20:41:39 <geekosaur> mm, nope
20:43:22 <ParaSa1lin> @ty guard
20:43:23 <lambdabot> MonadPlus m => Bool -> m ()
20:45:45 <tabemann> how much would it take to pull "fail" out of Monad and then move it to MonadPlus?
20:46:21 <tabemann> and make non-pattern matches in Monads that are not also MonadPlus just raise an exception always
20:46:31 <monochrom> actually, put it in a new class MonadFail
20:47:07 <arkeet> fail shouldn't even take an argument, I think :(
20:47:23 <arkeet> well I guess it would for error reporting.
20:47:23 <tabemann> that might be a good idea, if you can find a MonadPlus where you want mzero to not indicate failure
20:47:24 <arkeet> but ugh
20:47:37 <monochrom> well, people want precise error messages
20:48:37 <tabemann> the problem is that there's monads where you want to be able to trap pattern match failure as *not* an error, so this should be separated from "fail" for any old error
20:48:39 <tabemann> e.g. []
20:49:04 <tabemann> so you might want both fail and failPattern
20:49:16 <tabemann> so you can make them behave differently
20:50:57 <Cale> tabemann: Well, what Haskell 1.4 did was just to induce a MonadZero constraint whenever you matched against a pattern which involved a constructor of a type with more than one data constructor (i.e. a failable pattern)
20:51:42 <tabemann> now that I think of it, having separate MonadPlus and MonadFail is probably a good idea
20:52:04 <tabemann> e.g. in the STM monad mzero = retry, but you probably want pattern match failures to escape a given transaction as exceptions rather than to cause retrying
20:52:19 <Cale> If right now we moved fail out into its own class, GHC's translation of the do-notation would actually do the right thing -- it's actually more compliant with Haskell 1.4 than it is with Haskell 98/2010
20:52:24 <tel> ha, "Haskell is sometimes referred to as a DSL for denotational semantics" ~ Hudak
20:52:41 <Cale> (you can discover this fact if you use a custom Prelude)
20:54:21 <Cale> I *also* think it would be a good idea to re-split MonadZero/MonadPlus and perhaps also have a MonadElse (indicating the difference in behaviour between Maybe/List with regard to mplus)
20:54:34 <ParaSa1lin> wit what would failing pattern match in do notation do if fail wasnt part of monad?
20:55:06 <Fuuzetsu> seems my base is too new for HTTP which in turns blocks new cabal-install…
20:55:17 <Cale> ParaSa1lin: Patterns which *might* fail to match would induce a MonadFail constraint.
20:56:03 <ParaSa1lin> cale, you could decide that bases on static analysis?
20:56:12 <tabemann> Cale: the problem is that at least with the [] monad you can use patterns that can fail naturally as part of how you express nondeterminism with it
20:56:21 <Cale> yes -- you just check if any of the data constructors are from types which have more than one constructor
20:56:22 <geekosaur> ParaSa1lin, more or less the same way using (==) induces an Eq constraint, using fail would induce whatever typeclass provided it
20:56:23 <tabemann> so you don't want to necessarily break that behavior
20:56:30 <monochrom> e.g., "\m -> do { Just x <- m; return x }" would have type MonadFail m => m (Maybe a) -> m a
20:56:44 <Makoryu> Cale: And if there's no instance available should it be a warning (because it could leave out "fail" and write an irrefutable pattern match regardless) or a type error
20:56:56 <geekosaur> including the implicit one that's inserted when it's needed (and probably only then)
20:56:57 <Cale> tabemann: Right, and you wouldn't -- you'd have a MonadFail instance for lists.
20:57:36 <Cale> Yeah, if your monad isn't in MonadFail and you want to be able to write a possibly-failing pattern match anyway, you can always stick a ~ on the front of the pattern.
20:57:56 <monochrom> yikes, that's sneaky
20:57:59 <Cale> which perhaps isn't semantically *exactly* the same as Haskell 98, but probably a good idea in most cases.
20:58:12 <Cale> Or of course, you could use an explicit case
20:58:15 <monochrom> but I guess it's no worse than Maybe a -> a :)
20:59:23 <tabemann> Cale: oh yeah; I just misread what you said for a sec
20:59:29 <Cale> (In case anyone's unfamiliar, putting a ~ on the start of a pattern makes the match go through regardless, without checking if the pattern matches until one of the bound variables is evaluated.)
20:59:35 <monochrom> @quote monochrom String
20:59:35 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
20:59:35 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
20:59:44 <monochrom> @quote monochrom IO.String
20:59:44 <lambdabot> monochrom says: How do I extract the IO out of IO String?
21:00:17 <tabemann> Cale: but yeah; that's probably a good idea
21:00:57 <tabemann> actually, forcing one to use ~ with pattern matches that can fail (outside of MonadFail) in general might be a good idea, to make the user mark the cases where they really do want to have a partial pattern match
21:01:21 <tel> tabemann ~ changes semantics though
21:01:27 <Cale> Well, the downside is that this might cause space leaks
21:01:37 <Cale> In some probably quite rare cases.
21:01:45 <tabemann> okay
21:01:56 <tabemann> what we really need is something else to explicitly mark partial patterns
21:02:06 <Cale> Matching against a pattern with ~ on the front of it doesn't do any evaluation.
21:02:13 <tabemann> (but Haskell already has so much syntax to begin with, what do we choose without breaking something else...)
21:02:33 <Cale> So, you might fail to reduce an expression which is retaining lots of memory that way.
21:02:56 <tabemann> yeah, ~ isn't the solution here
21:03:06 <tel> tabemann _ -> error "impossible" is a crowd favorite, isn't it? : )
21:03:14 <Cale> Well, no solution is probably just fine.
21:03:24 <tabemann> tel: but that one isn't good because it produces a less specific exception than a partial pattern
21:03:33 * erisco impossibru!!!
21:03:47 <tel> tabemann I agree, I just… "love" whenever I get one of those errors
21:03:52 <tel> usually it's right and it's somehow my fault
21:04:04 <Cale> Note also that you could just avoid do-notation altogether in a case where you want error-call failure.
21:04:07 <tabemann> which is why in my own code I typically *do* use partial patterns *a lot*, where the omitted matches are specifically impossible cases and are supposed to raise exceptions
21:04:39 <tabemann> (yes, I know it'll cause warnings with -Wall, but i don't use -Wall)
21:04:54 * erisco problem fixed
21:04:54 <Cale> > (\(Just x) -> x + 5) Nothing
21:04:55 <lambdabot>   *Exception: <interactive>:3:2-19: Non-exhaustive patterns in lambda
21:05:25 <Cale> ^^ you could always use >>= directly without do-sugar, if you *really* wanted to avoid the MonadFail constraint
21:05:33 <tabemann> yeah, that's a much nicer exception than "impossible"
21:06:48 <Cale> Actually, one of the idioms in the code-base at my job is to use failing patterns in the IO monad just to obtain exceptions with line numbers if some assumption gets broken
21:07:16 <tel> > let f e | isJust e = fromJust e + 5
21:07:17 <lambdabot>   not an expression: `let f e | isJust e = fromJust e + 5'
21:07:26 <tel> > let f e | isJust e = fromJust e + 5 in f (Just 3)
21:07:27 <lambdabot>   8
21:08:17 <tabemann> Cale: what we really need is a version of "error" that adds line numbers and all to the exception text
21:08:26 <tabemann> without having to have -prof set
21:08:39 <tabemann> wait
21:08:43 <tabemann> it couldn't be a function
21:08:47 <Cale> Yeah, that couldn't be a function, it would have to be an expression form.
21:08:49 <tabemann> it would have to be syntax
21:08:55 <tel> monadloc?
21:09:09 <Cale> However, istr there was a pragma...
21:09:14 <monochrom> consider Control.Exception.assert
21:09:46 <lispy> hello people of #haskell, how are you?
21:09:49 <Cale> Maybe I'm remembering incorrectly.
21:11:02 <Cale> oh, cute
21:11:06 <Fuuzetsu> tabemann: I think solirc is going to be attempting to hack this into GHC in the near future but I don't know too much about it.
21:11:07 <Cale> They did make it a "function" :)
21:11:24 <tabemann> monochrom: assert has access to source file and line number?
21:11:27 <tabemann> without -prof?
21:11:30 <monochrom> yes
21:11:35 <lispy> :t assert
21:11:36 <lambdabot> Bool -> a -> a
21:11:44 <Fuuzetsu> Well, IIRC it was wrapping exception throwing functions with such functionality
21:11:46 <lispy> > assert False "Monkies"
21:11:48 <lambdabot>   "*Exception: <interactive>:3:1-6: Assertion failed
21:11:51 <erisco> lispy, droopy after 24 hours of consciousness
21:11:56 <erisco> lispy, how abouts you? :)
21:12:03 <geekosaur> there was a variant of error running around on hackage that includes it (probably via either TH or CPP magic)
21:12:14 <geekosaur> (since CPP gives you __FILE__ and __LINE)
21:12:14 <lispy> erisco: That's not the recommended awake-to-sleep ratio!
21:12:18 <geekosaur> er __LINE__
21:12:19 <lispy> erisco: I'm doing well, thank you
21:12:32 <Cale> It would be nice if there were a variant of assert which was similar to error and took a String message which it would add that line information to.
21:12:32 <tabemann> so "assert" isn't a normal function?
21:12:35 <tel> geekosaur monadloc :)
21:12:42 <Cale> tabemann: Yeah, it's implemented by a primitive.
21:12:49 <monochrom> assert gets some compiler support
21:13:08 <Cale> assert :: Bool -> a -> a
21:13:08 <Cale> assert _pred r = r
21:13:10 <lispy> Cale: also, IIRC, assert can be 'turned off' at either compile or run-time
21:13:33 <lispy> so even if someone used it in production code (where you most want the stack trace) it might be disabled :(
21:13:42 <tabemann> Cale: that looks like it's getting magically replaced by the compiler
21:13:47 <Cale> yes
21:14:35 <lispy> It is possible to run haskell programs in gdb
21:14:39 <lispy> And you can learn something
21:14:58 <tabemann> what we really need is a primitive like that that returns the source file and line number of the caller automatically, so that we can then do whatever we like with it
21:14:59 <lispy> The biggest hurdle is actually that normally ghc ships without the debug symbols as far as I can tell
21:15:00 <Cale> lispy: Ah, yeah there's -fignore-asserts and I think it might even be turned on by -O
21:15:02 <tabemann> without having to use CPP
21:15:59 <lispy> (also inferring what part of the user code is executing from the RTS's stack trace is not very friendly for users)
21:16:40 <Cale> Welp, I think it's time to try to try installing Mint 15 Cinnamon, seeing as Google Chrome has decided to implode while updating. (New version requires libraries not available on this old Ubuntu.)
21:17:02 <lispy> upgrading ubuntu is not an option?
21:17:03 <Fuuzetsu> Wouldn't happen on rolling release ;)
21:17:17 <Cale> lispy: Gnome 3 / Unity
21:17:26 <tabemann> use Debian
21:17:27 <Cale> are both not options for me
21:17:40 <monochrom> consider xubuntu
21:17:41 <lispy> Cale: you can disable them and use other things
21:17:44 <lispy> I thought
21:17:49 <Cale> Well, yes.
21:17:51 <geekosaur> of course cinnamon is just a theme for gnome3
21:17:55 <tabemann> (the only bad part about Debian is that if you're using stable or testing you're stuck with GHC 7.4.1)
21:18:07 <Cale> The question is about how much work I need to do to make the desktop tolerable
21:18:18 <Cale> Otherwise, most distributions are isomorphic.
21:18:48 <Cale> I don't know if I'll like Cinnamon, I tried an earlier version and hated it, but maybe it'll be okay now.
21:18:53 <lispy> Which reminds me, I need to see if I can install osx in a VM :)
21:18:54 <shachaf> Cale: Equivalent, at least.
21:19:02 <geekosaur> consider the MATE spin instead
21:19:05 <lispy> shachaf: univalence!
21:19:17 <lispy> shachaf: isomorphism is equivalence or however it goes?
21:19:34 <Cale> Yeah, I'm using MATE on one of our other machines (the one we use for the TV), and it's semi-okay.
21:19:40 <monochrom> distro irrelevance :)
21:19:42 <shachaf> No, equivalence is weaker than isomorphism (equality is stronger).
21:19:48 * tabemann eschews desktop environments and uses fluxbox instead without one (he's considering trying xmonad, but its tiling isn't very compatible with his habit of making *lots* overlapping windows, especially browser windows)
21:20:07 <Cale> I'm addicted to Gnome 2's particular set of panel applets.
21:20:14 <monochrom> what is MATE? or rather, how to google it accurately?
21:20:14 * geekosaur is using mint, xfce, and xmonad on the personal linux...
21:20:21 <Cale> and so I'll probably be annoyed in any case
21:20:24 <geekosaur> it's a supported fork of gnome2
21:20:44 <lispy> shachaf: is that really true?
21:20:45 <geekosaur> since the gnome folks have officially EOLed gnome2
21:20:51 <tabemann> Cale: with fluxbox you can have apps that attach to its little tray that you can put on a side of the screen; e.g. I have gkrellm as such
21:20:57 <adnap> Is there a better way of thinking of ($) than "puts parentheses around what follows"?
21:20:59 <monochrom> thanks
21:21:07 <geekosaur> http://mate-desktop.org/
21:21:11 <shachaf> lispy: Is it not?
21:21:14 <lispy> shachaf: in particular, I think of equivalence as partitioning but isomorphism is about correspondence
21:21:27 <Cale> In particular, I like the clock applet which you can click on to get a calendar, a picture of where there's daylight/night, and a configurable set of global clocks with weather reports.
21:21:31 <shachaf> lispy: I'm thinking of equivalence as in equivalent categories.
21:21:56 <Cale> I'm not sure why they removed that functionality, but most of the new DEs just have a basic clock :P
21:22:09 <tabemann> because they're the GNOME people and they do shit like that
21:22:24 <tabemann> it seems like those people have been obsessed with taking features *away* from the user
21:22:28 <elliott> (to -blah, maybe?)
21:22:35 <Cale> The other really essential one for me is being able to have multiple volume control applets
21:22:42 <Cale> yeah, sorry about this :)
21:22:59 <lispy> shachaf: okay. I'm not familiar with equivalent categories but I think I have a vague idea what they might be. Categories that have a correspondence defined by an equivalence relation?
21:23:16 <lispy> shachaf: or is it a category equipped with an equivalence relation between objects?
21:23:21 <adnap> Nothing
21:23:29 <erisco> this ghci man
21:23:43 <erisco> :t liftA   hangs... I interrupt, says "interrupted"
21:23:44 <lambdabot> parse error on input `,'
21:23:56 <erisco> now when I ask  ":t liftA", it immediately reports back "interrupted"
21:24:17 <erisco> :t liftA
21:24:18 <lambdabot> Applicative f => (a -> b) -> f a -> f b
21:24:48 <monochrom> adnap: "puts parentheses around what follows" is in fact the worse way. the best way is simply "f $ x = f x" but mind precedence when f or x are compound expressions.
21:24:51 <shachaf> lispy: I don't think it's either one.
21:25:33 <adnap> monochrom: That doesn't seem different.
21:26:12 <monochrom> well, for one thing, you also need to put parentheses around what precedes.
21:26:20 <shachaf> Is it true that two categories are equivalent iff there's an adjunction between them where the natural transformations are natural isomorphisms?
21:26:30 <monochrom> a + b $ c + d = (a + b) (c + d)
21:27:04 <adnap> monochrom: I don't usually, because the left hand side usually... it automatically binds this way?
21:27:15 <monochrom> for another thing, f $ x is syntax sugar for ($) f x. this holds for all infix operators
21:27:22 <adnap> monochrom: I don't think it will for the infix "a + b" though
21:29:24 <adnap> monochrom: What I meant is that most functions written in prefix style are left-associative, so parentheses around a partial application of these functions is not necessary.
21:32:18 <adnap> monochrom: If I thought ""f $ x = f x" but mind precedence when f or x are compound expressions", then ($) would seem totally useless.
21:32:46 <_justjust> map (flip makeMove f) $ allPossibleMoves f hLint says 'Use section' but how?
21:32:50 <monochrom> it becomes useful when map ($ 0) [sin, cos, tan]
21:33:11 <adnap> monochrom: That's interesting
21:33:52 <adnap> monochrom: I can also write "sin $ x + 2" instead of "sin (x + 2)", which I think is useful.
21:33:54 <shachaf> _justjust: Maybe hlint means: map (`makeMove` f) (allPossibleMoves f)
21:34:18 <monochrom> however, I disdain "sin $ x + 2". I prefer "sin (x + 2)".
21:34:40 <_justjust> shachaf: thanks
21:34:52 <_justjust> don't know what i like more
21:35:02 <tabemann> I for some reason like using $ a lot, even though these days I've been trying to use, say, foo . bar $ baz instead of foo $ bar $ baz
21:35:03 <shachaf> I don't like flip.
21:35:28 <tabemann> (even though there are special cases that that doesn't work, because there is special typing magic with ($) that isn't apparent from its type signature)
21:35:31 <geekosaur> shachaf flips out over flip?
21:35:40 <monochrom> I also completely ignore hlint
21:35:41 <adnap> tabemann: I often write foo . bar $ baz
21:35:43 * hackagebot monoid-subclasses 0.3.2 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.2 (MarioBlazevic)
21:35:43 <Fuuzetsu> tabemann: like?
21:35:51 <adnap> tabemann: And foo . bar if I can
21:36:13 <geekosaur> Fuuzetsu, it has some hacks so it will work with runST
21:36:14 <tabemann> Fuuzetsu: you can use "runST $ do ...", which wouldn't work if ($) were a normal function due to runST having a rank-2 type
21:36:38 <adnap> I use $ to avoid typing ( and ). I don't understand why people like monochrom don't like that.
21:37:52 <tabemann> i.e. you *can't* do runST . return $ foo because (.) doesn't have that magic
21:37:53 <monochrom> the real issue: do you like parentheses or not.
21:38:37 <monochrom> to your consolence, people such as me who like parentheses and dislike $ are in the minority. you are not threatened.
21:39:26 <BMeph> tabemann: No, you can't do that, because return doesn't have the right type for runST. in the "runST $ do..." scenario, runST is appied to "$" not the other way around. :)
21:39:42 <monochrom> the majority of people like to go out of their way to eliminate parentheses. to them, I have a perfect proposal.
21:40:07 <monochrom> for each operator, prepare 9 version to correspond to the 9 precedence levels.
21:40:43 <geekosaur> where's my RPN dialect of Haskell? :p
21:41:11 <lispy> monochrom: I disliked ($) when I started haskelling, get used to it, and now I'm trending back towards avoiding it.
21:41:21 <monochrom> for example: for (+), have (+) for level 9 (highest, tightest), (.+.) for level 8, (..+..) for level 7, etc
21:42:01 * lispy watches as monochrom constructs an essay that should be in the satire category for haskell articles :)
21:42:08 <monochrom> so you can write x + y .*. z to eliminate the parentheses in (x+y)*z
21:42:33 * BMeph thinks monochrom is BRILLIANT!!!!!!!
21:42:34 <mahonii> im used to java/C and now because of my course VB.NET. Haskell is quite a bit different to get used too.
21:42:35 <shachaf> monochrom: I suggest using font sizes instead.
21:42:49 <Fuuzetsu> id . ........+........ . id $ 5
21:42:57 <lispy> mahonii: yes
21:43:08 * BMeph thinks shachaf is BRILLIANTER!!!!!!!
21:43:12 <monochrom> the dots space out the lower-precendence operators so you can eye-ball who binds tighter, who binds looser
21:43:53 <mahonii> didnt know syntax could be so different, funny enough it was the haskell talk from Carmack that made me have a look.
21:44:04 <tabemann> BMeph: umm... how doesn't return have the right type for runST?
21:44:10 <spaceships> why not use parens instead of dots
21:44:16 <spaceships> for the ultimate in irony
21:44:31 <monochrom> I would if I could, spaceships
21:44:31 <geekosaur> :t runST . return
21:44:32 <lambdabot>     Couldn't match type `m0 a0' with `forall s. ST s c0'
21:44:32 <lambdabot>     Expected type: a0 -> forall s. ST s c0
21:44:32 <lambdabot>       Actual type: a0 -> m0 a0
21:44:34 <geekosaur> nope
21:44:36 <geekosaur> heh
21:44:38 <spaceships> oh right
21:45:06 <geekosaur> anyway put exactly that way, you're trying to apply return to the things after the $, then apply that to runST
21:45:11 <geekosaur> :t runST
21:45:12 <lambdabot> (forall s. ST s a) -> a
21:45:27 <monochrom> guess what, maybe I could
21:45:40 <tabemann> the problem is the rank-2 type
21:45:43 <spaceships> .((((+)))).?
21:45:59 <geekosaur> hm, I think you get into trouble somewhere but I'm too tired to work through rank-N stuff
21:46:17 <levi> geekosaur: Have you heard of the Joy language?
21:46:29 <tabemann> :t runST $ return "foo"
21:46:30 <lambdabot> [Char]
21:46:39 <tabemann> :t runST . return $ "foo"
21:46:40 <lambdabot>     Couldn't match type `m0 [Char]' with `forall s. ST s c0'
21:46:40 <lambdabot>     Expected type: [Char] -> forall s. ST s c0
21:46:40 <lambdabot>       Actual type: [Char] -> m0 [Char]
21:48:36 * geekosaur pokes. forth and j apparently had a secret love child...
21:49:16 <levi> It's a purely functional language, although it is dynamically typed.
21:51:45 <monochrom> GHC fails me. U+FF08 （ is supposed to be legal in infix operators, sanctioned by Haskell 2010
21:55:44 * hackagebot incremental-parser 0.2.3.1 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.3.1 (MarioBlazevic)
21:58:10 <levi> geekosaur: Then there's Cat, which is similar but statically-typed.
22:10:02 <lispy> monochrom: does it fail at lexing or parsing?
22:10:09 * lispy is too lazy to try
22:10:48 <lispy> > let a （b = 1 in 1 （2
22:10:49 <monochrom> it probably fails at lexing. "lexical error at character '\65288'"
22:10:49 <lambdabot>   <hint>:1:7: lexical error at character '\65288'
22:11:21 <shachaf> > generalCategory '（'
22:11:21 <lispy> monochrom: agda also uses alex for lexing but they do a clever thing to get around enumerating all of the unicode points
22:11:22 <lambdabot>   OpenPunctuation
22:11:33 <shachaf> monochrom: I don't think OpenPunctuation is allowed, is it?
22:11:56 <lispy> monochrom: they map all the unicode characters (those beyond ascii or so) to z or + depending on what character class it's in
22:14:05 <lispy> it allows them to give a conscise lexical definition using regular expressions
22:14:43 <monochrom> symbol -> uniSymbol (except special, _, ", ')
22:15:05 <monochrom> special -> a couple of purely ascii characters such as (
22:15:06 <tabemann> nice - got a comparison failure (where my naive algorithm disagrees with my non-naive algorithm) for a set of only six nodes - I might be able to think through the path the non-naive algorithm takes to traverse this by hand...
22:15:19 <monochrom> uniSymbol -> any Unicode symbol or punctuation
22:15:37 <monochrom> this wording does not seem to exclude open punctuations
22:16:29 <monochrom> a million other subclasses of punctuations are allowed, so why not the subclasses open and close
22:18:47 <lispy> tabemann: did you use quickcheck (or one of the equivalents like smallcheck or smartcheck) to help you find a failing test case?
22:20:19 <tabemann> lispy: I wrote my own random network generator, and rewrote my algorithm with a naive algorithm I knew worked (even though it scales horribly), which I could then compare results with
22:21:11 <tabemann> so I'm in my not-equals test flagging cases where the naive algorithm says a given pair of networks are not equals but the non-naive algorithm is saying they are equals
22:22:39 <tabemann> I *could* use QuickCheck, but then I'd just have to do more work to integrate my random network generator into it
22:22:51 <lispy> tabemann: Ah. So tools like smartcheck can help with that. They still need you to specify the generator (you did that) and a property to check (in this case that both implementations agree), but they add an ability to in finding small cases that break
22:22:58 <lispy> yeah
22:23:29 <joelteon> I don't understand how quickcheck's shrink works
22:23:46 <kxra> is there any haskell network of mentors/mentees like railsmentors?
22:24:35 <lispy> kxra: I've never heard of railsmentors (so I don't know what it is) but I'm fairly confident the answer is: no
22:24:46 <lispy> kxra: Are you offering to start it? :)
22:25:06 <tabemann> lispy: how I made it catch cases that break it more easily is that I made the pair generator used in the not-equals check generate networks that were *mostly* equal (like 90% of nodes are the same), but then using the naive implementation to filter cases where the randomly generated networks are actually equal
22:25:12 <kxra> lispy: the closest thing i have seen is http://www.haskellers.com/ but that seems to be aimed at hiring / looking for work
22:25:18 <tabemann> so as to avoid false negatives
22:25:28 <kxra> lispy: i'd start it if i could get mentored in haskell enough to start it =P
22:26:20 <lispy> kxra: we have a haskell-beginners mailing list
22:26:29 <lispy> kxra: and folks here like helping
22:26:44 <kxra> lispy: that sounds good, but i'm more looking for a place to find a personal mentor
22:26:48 <kxra> slash maybe even a paid mentor
22:26:48 <shachaf> And monoids.
22:27:05 <lispy> yes, shachaf likes the monoids. All of them.
22:27:25 <monochrom> I don't like monoids. I'm too lazy.
22:28:26 <johnw> whenever I picture monoids in my head, it kind of looks like a big atom
22:28:47 <johnw> one object with all these endomorphisms going out and back in, tons of them
22:29:04 <lispy> data ShachafLikesIt = Yes | No; shachaf :: forall m. Monoid m => m -> ShachafLikesIt; shachaf = const Yes
22:29:17 <shachaf> Boolean blindness. :-(
22:29:53 <johnw> data ShachafLikesIt = ShachafDoesLikesEveryMonoid | ShachafDoesNotLikesNoMonoids
22:29:57 <lispy> shachaf: I couldn't think of a suitable witness :)
22:30:36 <dmj`> kxra: did you try learnyouahaskell.com or http://book.realworldhaskell.org ?
22:30:38 <johnw> in a case like these dealing with a universal, do you need a witness?
22:31:47 <shachaf> johnw: That doesn't really solve the problem.
22:32:37 <johnw> shachaf: i may be unclear as to exactly what boolean blindness is (did read the article twice), can you clarify?
22:34:16 <lispy> johnw: I think I found the article you're talking about. I'm not sure that's a good introduction.
22:34:18 <sclv> boolean blindness is when you throw away what the bool represents
22:34:26 <lispy> johnw: I learned about the idea from the agda tutorial.
22:34:30 <tabemann> yeesss fixed the bug
22:34:46 <sclv> let isNull xs = null xs in if null xs then head xs else default
22:34:51 <lispy> johnw: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
22:35:17 <sclv> if you pattern match directly you can see through the code and tell if your function is total directly as well as its behavior
22:35:31 <sclv> flags should contain the information they represent exists
22:35:34 <johnw> ok, i'll look for those ideas in the tutorial
22:35:36 <lispy> johnw: the idea is that if you have something like a predicate, instead of returning True or False, you return a term that provides evidence for what the predicate learned
22:36:18 <sclv> in a pervasively lazy language the extra evidence is cheap enough you might as well always provide it
22:36:18 <kxra> djahandarie: yes, i'm familiar with the learning resources, but for many people a mentor/tutor is invaluable
22:36:19 <lispy> johnw: be prepared to learn agda if you want to read enough of that tutorial to really get it :)
22:36:31 <tabemann> sclv: the only thing then is then we can argue that div should return a Maybe
22:36:33 <johnw> i've read that tutorial twice
22:36:36 <lispy> kxra: agreed
22:36:40 <johnw> I found it a little bit horrible at introducing Agda though
22:36:48 <lispy> kxra: how does railsmentor work?
22:37:00 <kxra> lispy: i can try to recruit a mentor through the beginners list though
22:37:03 * tabemann has yet to wrap his brain around things as simple as function composition in Agda
22:37:16 <kxra> lispy: you can sighn up for an account, iirc, as a mentor or mentee
22:37:22 <lispy> tabemann: you mean dependent function composition?
22:37:23 <kxra> list skills desired or offered
22:37:32 <sclv> well arguably div should return a maybe
22:37:39 <sclv> in general partial code is to be avoided
22:37:45 <kxra> i wonder if there's a language agnostic version actually...
22:37:48 <sclv> or it should take a provably nonzero argument :-)
22:38:10 <tabemann> lispy: yeah
22:38:20 <lispy> kxra: it sounds like starting a haskellmentors website wouldn't actually require haskell knowledge :)
22:38:50 <tabemann> sclv: the thing is that we cannot avoid partial functions, simply because we cannot determine statically how much memory code will use given Haskell's runtime model
22:38:55 <johnw> lispy, sclv: for isNull, what would the evidence be?  the original list?
22:39:02 <lispy> kxra: you might also check the haskell tag on stackoverflow. Some of those folks might be available as mentors.
22:39:08 <sclv> in the case there, the head
22:39:14 <sclv> just use pattern matching directly!
22:39:16 <tabemann> what's the difference between returning bottom explicitly or exhausting all the memory on the system
22:39:18 <johnw> ah, I see
22:39:21 <sclv> don't use it once to detect if its null, then again later
22:39:22 <johnw> the head is proof that it isn't null
22:39:25 <sclv> its more efficient too :-)
22:39:39 <sclv> tabemann: denotationally, a world of difference
22:39:45 <sclv> arguably though we can always loop
22:39:48 <johnw> then, any monoid is itself proof that shachaf likes it
22:39:48 <shachaf> No, the proof is in your head.
22:40:11 <sclv> nonetheless, using "potentially total" functions is still better than using explicitly partial ones
22:40:24 <sclv> i.e. functions that don't diverge _unless_ their arguments diverge
22:40:33 <sclv> the proof of that totality isn't in the type system necessarily
22:40:40 <sclv> but you can still tell, typically.
22:41:42 <lispy> johnw: look at the list membership examples in the tutorial.
22:41:46 <johnw> ok
22:41:50 <johnw> thanks, lispy!
22:41:56 <lispy> johnw: the here/there stuff (or is that idris terminology?)
22:42:32 <tabemann> the thing is that Haskell simply isn't a total language; while it may be a good practice to avoid writing partial functions, one can only assume that anything we evaluate may evaluate to bottom, non-terminate, or summon the OMM killer
22:42:36 <lispy> johnw: you could define list membership to return true or false. Instead they make a version that says the element is here (at the head) or there (in the tail).
22:43:18 <lispy> johnw: later when you check for membership you get back this here/there term. By casing on that you can add constraints to the types such that agda is convinced that you have the thing and the proof moves on.
22:43:35 <kxra> lispy: true, but i don't have enough skill in another language either [=
22:43:41 <lispy> johnw: if instead you got the bool back you'd still have to traverse the list or something to figure out _where_
22:43:42 <kxra> http://www.codementor.io/ seems interesting maybe
22:44:27 <lispy> johnw: if you are interested in actually learning agda you might look at this as an alternative tutorial: http://oxij.org/note/BrutalDepTypes/
22:45:06 <lispy> johnw: and I highly recommend implementing the 'typing haskell in haskell' paper if you have any interest in understanding how type inference and type checking works.
22:45:25 <lispy> (which is sort of assume for a system like agda where you need to get unification to do what you want)
22:45:46 * lispy looks at codementor
22:46:51 <johnw> lispy: added to my queue
22:51:30 <lispy> I think the codementor website crashed chrome which locked up my whole computer? I had to power off
22:52:17 <kxra> lispy: muahahahaha
22:52:32 * lispy tries a different browser
22:52:36 <kxra> but that's actually strange. a website shouldn't be able to do that.
22:52:39 <kxra> which browser?
22:52:51 <lispy> i tried chrome before
22:55:24 <lispy> ah, so it's probably my other pet theory. I think I have a bad ram module
22:57:00 <johnw> memtest86!
22:57:22 <johnw> i had a bad ram module in a NAS box once; that was a tricky thing to track down
23:00:41 <joelteon> is it generally a bad idea to control API contents with ifdefs
23:01:19 <joelteon> yeah I feel like it is
23:01:50 <adnap> I want to write a program that constantly renders graphics in a window and reads input from standard in. I want the input to affect the graphics. The only thing I know regarding concurrency in Haskell is forkIO. I could create a thread which reads input and pass an IORef to both threads, where one writes into the IORef and the other reads from it...
23:02:33 <johnw> the latency would be bad in that case, if your input comes in quickly
23:02:40 <johnw> better to use a TChan
23:03:27 <adnap> The input in a toy program could just be a number corresponding to a polygon with n sides to be drawn
23:03:39 <johnw> ah, then MVar is fine
23:03:42 <johnw> (not IORef)
23:04:10 <adnap> johnw: Can you advise me on how to learn about these things?
23:04:26 <johnw> if you want to know lots, Marlow's recent book on Concurrency is a great resource
23:04:30 <johnw> otherwise, let me google a bit
23:04:43 <adnap> I want to start programming right away.
23:04:45 <johnw> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
23:04:48 <johnw> that's a good intro
23:04:49 <kxra> if anyone wants to help me gain access to a codementor, you can sighn up for an invite with my referal link... http://www.codementor.io/?rid=4506073984
23:05:00 <johnw> especially "Simple communication between threads"
23:05:29 <adnap> johnw: Thanks. Are there other models of concurrency in Haskell where two processes can communicate?
23:05:52 <johnw> Cloud Haskell is designed for that
23:06:12 <johnw> an easy way to do it on UNIX is with a named pipe
23:06:28 <adnap> I want to write a single program
23:06:35 <adnap> Not two programs that communiacte
23:06:38 <johnw> or just a simple socket
23:06:42 <johnw> oh, you said "processes"
23:06:47 <adnap> I just mean...
23:06:48 <johnw> STM is the other model
23:06:52 <adnap> two "things" of execution
23:06:59 <adnap> Two computations happening at once
23:07:10 <adnap> Not a UNIX process
23:07:11 <johnw> the async library
23:07:19 <johnw> that's full of good stuff for that
23:07:32 <johnw> if you're talking about running pure computations in parallel, there are even more models
23:07:37 <johnw> the Par and Eval monads
23:07:47 <tabemann> you should really read Marlow's book
23:07:48 <tabemann> really
23:07:58 <adnap> Can I read it online?
23:08:02 <adnap> Can I get a PDF?
23:08:07 <johnw> so, forkIO+MVar, STM and the async library (which is based on those two), are about concurrency; the Par and Eval monads, Repa, Accelerate, etc., are about parallelism
23:08:08 <adnap> Or read a website
23:08:18 <mstksg> is there a way to cabal install only specific executables, instead of all of the ones specified in the cabal file?
23:08:25 <tabemann> it has been online at times, but I'm not sure if it's online now
23:08:28 <johnw> adnap: http://community.haskell.org/~simonmar/par-tutorial.pdf
23:08:37 <tabemann> there is an ebook that you can get in epub and PDF formats
23:08:46 <johnw> if you like that PDF, I highly recommend the full ebook
23:08:56 <adnap> johnw: So, is this a sample?
23:09:05 <adnap> johnw: Also, is this a good starting place?
23:09:07 <johnw> it looks like an earlier version of the content
23:09:19 <adnap> What is the book called?
23:09:23 <johnw> anything done by Marlow is a good starting place for this subject :)
23:09:24 <adnap> Where can I get the whole thing?
23:09:36 <tabemann> Parallel and Concurrent Programming in Haskell
23:09:39 <johnw> http://chimera.labs.oreilly.com/books/1230000000929
23:09:43 <tabemann> it's published by O'Reilly
23:09:53 <adnap> Oh, I can read it all online!
23:09:54 <johnw> or go to http://shop.oreilly.com/home.do and search for it
23:09:54 <adnap> Cool
23:09:58 <mstksg> great book
23:10:06 <johnw> it's well written too
23:10:19 <johnw> adnap: lastly, there is a video of a talk he gave on this material too
23:10:22 <adnap> Does the book talk about MVar and STM?
23:10:25 <johnw> yes
23:10:29 <johnw> is great detail
23:10:35 <johnw> s/is/in
23:10:36 <adnap> Okay, cool. So it should give me some choices.
23:10:51 <johnw> http://skillsmatter.com/podcast/home/high-performance-concurrency
23:11:05 <tabemann> okay, should go to bed
23:11:54 <adnap> I hope I can start programming stuff soon. I tend to lose motivation when I can't apply something
23:12:11 <johnw> adnap: when I'm setting out to write concurrent code, my order of picking is: async package, then straight STM, then forkIO/MVar if necessary
23:12:41 <johnw> async basically packages up some of the most common use cases in a nice API
23:12:41 <adnap> johnw: Does the book cover async? I forgot to ask about this one specifically
23:12:44 <johnw> yes
23:12:47 <johnw> Marlow wrote async
23:12:51 <adnap> Okay
23:14:28 <johnw> if you want even a little higher level than that, for the special of communicating threads, there are several actor libraries on Hackage
23:14:56 <johnw> that will let you spawn a thread that loops forever listening for "messages".  if both threads do that, then they can just keep talking to each other until they run out of things to say
23:15:39 <johnw> Cloud Haskell is an implementation of this model that works both "in-process" (in a single executable), cross-process, and cross-host
23:15:56 <johnw> and his book covers that too :)
23:16:21 <blackdog> heh, so that was fun. if you start a process using runInteractiveCommand, then kill it with terminateProcess, it only seems to kill the shell that got started, not the child processes.
23:16:29 <blackdog> very confusing for a bit.
23:16:50 <johnw> so it's not sending the signal to the process gorup?
23:18:33 <adnap> johnw: Can I download the code examples in the book somewhere?
23:18:54 <adnap> johnw: Nevermind. I found it
23:20:39 <johnw> have you done much concurrent programming in other languages?
23:21:21 <Vertue> Hi, I am trying to figure out how to create a bytestring of 16 zero bytes...
23:22:13 <Vertue> need it to be exact as it is a key
23:22:18 <johnw> Vertue: you can use a ByteString builder to do that
23:22:26 <johnw> see the function `word8'
23:22:38 <Vertue> having a quick look now.
23:23:04 <Vertue> johnw see it
23:23:18 <adnap> johnw: I did a little in C with pthreads and mutexes in an Operating Systems class. That's about it
23:23:45 <johnw> > toByteString $ word8 0 <> word8 0
23:23:47 <lambdabot>   Not in scope: `toByteString'Not in scope: `word8'
23:23:47 <lambdabot>  Perhaps you meant one of...
23:24:30 <johnw> adnap: ah, then I'm envious; Haskell does concurrency very, very well
23:25:08 <adnap> johnw: I don't know why you would be envious. Is it because you had to unlearn some things?
23:25:18 <joelteon> > let myShow :: forall a. Show a => a -> String; myShow m = show (m :: a) in myShow 1
23:25:20 <lambdabot>   "1"
23:25:27 <joelteon> how does lambdabot make that typecheck?
23:25:41 <joelteon> I get "could not deduce (a1 ~ a)" despite the fact that the two a's should be the same
23:25:43 <Vertue> johnw: Thanks, will try that
23:25:49 <joelteon> which extension am I missing?
23:25:51 <johnw> adnap: it's like I learned how to drive on a horse buggy, and you're starting out with a Ferrari
23:26:03 <blackdog> johnw: doesn't seem so - i start a python process, call terminateProcess on the resulting process handle, and the python process is left alive afterwards.
23:26:45 <adnap> johnw: Hehe
23:26:50 <adnap> johnw: I might wreck it!
23:27:53 <Vertue> johnw: For some reason I cannot import Data.ByteString.Builder
23:28:36 <johnw> are you using GHC 7.4?
23:29:10 <Vertue> I am
23:29:32 <Vertue> and Data.ByteString imports fine
23:30:14 <Dodek> hey, do any of you know guy named Ertugrul Söylemez?
23:30:49 <Dodek> i'm trying to get in touch with him, but emails to him bounce back.
23:31:08 <lispy> name rings a bell, but I don't know how to contact him
23:31:18 <edwardk> Dodek: yes
23:31:49 <adnap> johnw: I'm using 7.6.3
23:31:55 <adnap> johnw: I'm not sure if you were asking me
23:32:01 <edwardk> dodek: es@ertes.de
23:32:02 <edwardk> ?
23:32:08 <elliott> preflex: seen mm_freak
23:32:08 <preflex>  mm_freak was last seen on #haskell 5 hours, 26 minutes and 18 seconds ago, saying: begriffs: forcing yourself into using monads won't really help your understanding…  a better way is to just write a small, but real application
23:32:22 <edwardk> Dodek: hrmm his site seems down
23:32:25 <Dodek> edwardk: i send mail to es@ertes.de, and it bounced back
23:32:27 <johnw> Vertue: hmm
23:32:53 <johnw> Vertue: maybe you're using an older Haskell Platform?
23:32:58 <johnw> Builders are in bytestring-0.10.20
23:33:00 <Dodek> edwardk: ertes.de returns NXDOMAIN
23:33:06 <edwardk> Dodek: i have no other means to contact him. maybe google+ or something
23:33:15 <edwardk> let me see if i have him there
23:33:27 <edwardk> preflex: xsen ertes
23:33:30 <edwardk> preflex: xseen ertes
23:33:30 <preflex>  Sorry, I haven't seen ertes
23:34:41 <edwardk> Dodek: https://plus.google.com/102807976086549374002/posts should be him
23:34:56 <Vertue> johnw: seems like that was the problem, old version of bytestring
23:35:08 <Dodek> edwardk: great, thanks
23:35:23 <Vertue> johnw: wierd as I have the latest haskell platform installed
23:35:52 <johnw> Vertue: what I do is this
23:36:11 <johnw> in ~/.cabal/config, put: https://gist.github.com/6374855
23:36:20 <johnw> this will prevent cabal from upgrading or downgrading any of the HP packages
23:36:47 <johnw> that way, it's easier for me to know whether the code I'm writing works against HP, because all of the HP libraries on my system always have the same version as the distribution
23:37:04 <Vertue> good tip
23:37:11 <Vertue> thanks...
23:39:10 <elliott> edwardk: ertes = mm_freak
23:39:19 <elliott> (was what I was trying to show with the preflex query)
23:39:24 <elliott> unless I'm wrong. but I don't think I am.
23:39:28 <edwardk> elliott: thanks. i was blanking on the nick but knew i knew it =)
23:39:32 <elliott> /whois agrees with me at least
23:40:39 <Vertue> johnw: I got it compiling but not too familiar with the moniod syntax
23:40:42 <enthropy> is it possible to write (>>=) for types Just and Nothing?
23:40:55 <Vertue> what does word8 <> word8 do?
23:41:03 <johnw> word8 0 <> word 8 0
23:41:07 <johnw> creates a word16 0
23:41:10 <opqdonut> enthropy: yes, that's what the Monad Maybe instance is
23:41:13 <enthropy> I am running into an issue regarding 'Type synonym "foo" should have 2 arguments, but has been given 1'
23:41:14 <johnw> think of it as an append
23:41:43 <opqdonut> @src Maybe (>>=) -- enthropy
23:41:43 <lambdabot> Source not found.
23:41:48 <Vertue> ok so that give me a 16bit word...
23:41:49 <lpaste> enthropy pasted “bind maybe datakinds” at http://lpaste.net/92269
23:42:08 <opqdonut> oh, weird, that just worked in a /query
23:42:10 <johnw> Vertue: foldr (<>) mempty $ replicate 10 (word8 0)
23:42:12 <ReinH> johnw: how would word8 <> word8 create a word16?
23:42:16 <opqdonut> @src Maybe (>>=)
23:42:16 <lambdabot> (Just x) >>= k      = k x
23:42:16 <lambdabot> Nothing  >>= _      = Nothing
23:42:22 <ReinH> aren't monoids closed under their binary operator?
23:42:22 <johnw> ReinH: this is the ByteString builder
23:42:26 <ReinH> oh
23:42:30 <ReinH> never mind :)
23:42:36 <opqdonut> enthropy: oh now I see
23:43:00 <enthropy> I think it might work if I use data instead of type
23:43:14 <Vertue> johnw: that would give me 10 * 8 bytes ?
23:43:18 <johnw> yes
23:43:23 <johnw> a Builder representing 10 0 bytes
23:43:29 <johnw> then just pass that to toByteString, and there yo ugo
23:43:32 <Vertue> ok think I got it thanks
23:43:38 <enthropy> at least with more normal code you can have data and newtype being partially applied
23:43:43 <johnw> actually, foldr (<>) mempty = mconcat
23:43:45 <johnw> so you can simplify
23:44:00 <enthropy> but there's an issue that associated data types are not injective
23:44:12 <enthropy> or something like that sound like it could make for some problems
23:45:04 <Vertue> monoid laws stuff
23:45:22 <Vertue> read it four times now, still struggling :-(
23:45:49 <johnw> Vertue: you mean, a*1=a, 1*a=a, a*(a*a)=(a*a)*a?
23:45:56 <enthropy> the laws are short so it won't take long to read a couple more times
23:46:02 <ReinH> Vertue: try with a simpler Monoid like String
23:46:50 <Vertue> Sure - the examples seem simple enough for + and : and * but struggling with generalising
23:48:59 <yitz> johnw: really? you can put constrainst into .cabal/config? interesting.
23:49:13 <johnw> sure, it brought sanity to my world
23:49:18 <yitz> johnw: you can't put them into a regular cabal file. i thought they could only be on the command line.
23:49:37 <johnw> in a regular cabal file, you contrain the dependencies directly
23:49:43 <yitz> johnw: that could have other uses too - to make up for the inconvenience of not having them in cabal files
23:50:23 <yitz> johnw: that's often not good enough. in particular, sometime you need to specify flag values, which can only be done in a constraint.
23:50:33 <johnw> ah, hmm
23:51:41 <yitz> johnw: also, a constraint is global to the build process, whereas a version range only applies to the package that directly contains that dependency.
23:51:58 <yitz> johnw: that affects the order that cabal's solver looks at things
23:53:44 <lpaste> enthropy annotated “bind maybe datakinds” with “bind maybe datakinds (solved)” at http://lpaste.net/92269#a92270
23:53:53 <enthropy> opqdonut: ^^ if you're interested
23:56:47 <yitz> johnw: one thing that's really hard to do with cabal is repeatable builds - specifying complete information to guarantee that cabal will do exactly the same thing even in the future when arbitrary additional packages have been uploaded to hackage.
23:56:49 <ReinH> Some Monoid instances are more fun than others
23:57:14 <ReinH> > ala Sum foldMap [1,2,3]
23:57:15 <lambdabot>   6
23:57:19 <ReinH> kind of fun
23:57:28 <ReinH> > ala First foldMap [Nothing, Just 1, Just 2]
23:57:30 <lambdabot>   Just 1
23:57:31 <ReinH> more fun
23:57:37 <yitz> johnw: hopefully, the coming "hermetic builds" feature in cabal will address that. but in the meantime, you need constrainsts. and those cannot be specified in a cabal file. :(
23:57:40 <Driscoll> sorry to bug you guys with a noob question, but if i want to make a copy of an array, with one element changed, what's the most elegant way to do so?
23:57:53 <enthropy> @type (//)
23:57:54 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
23:58:02 <Driscoll> ty
23:58:04 <ReinH> Endo is even more fun but I have no idea how to write anything that uses it without a ridiculous number of parens
23:58:08 <so-rude> سمَـَّوُوُحخ ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
23:58:20 <yitz> @where ops
23:58:20 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
23:58:20 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:58:50 <ReinH> > (appEndo $ (Endo (+1)) <> (Endo (+2))) 1
23:58:51 <lambdabot>   4
23:58:52 <ReinH> too many parens
