00:00:02 <aleator> Fernandos: instead of --force it eventually pays to just remove the offending packages with ghc-pkg, or reinstalling them by adding them to the same cabal command
00:02:07 <Fernandos> I have run ghc-pkg check it produced a lot of output: http://hastebin.com/xidogirune.vhdl
00:02:33 <arkeet> congrats, you should probably nuke everything and start over
00:03:29 <Fernandos> arkeet: I only used my package manager
00:03:48 <arkeet> never used cabal-install?
00:03:53 <Fernandos> arkeet: no
00:03:53 <arkeet> what package manager?
00:03:57 <Fernandos> emerge
00:04:14 <arkeet> I thought gentoo was supposed to be alright at haskell stuff
00:04:43 <supki> it is
00:04:46 <arkeet> (I use gentoo myself, but I get all my haskell packages via cabal)
00:04:58 <supki> Fernandos: you should ask in #gentoo-haskell I think
00:05:05 <arkeet> that's probably advisable.
00:05:31 <Fernandos> thank you, for your help!
00:05:37 <Zenol> or an other solution is to forgive about emerge, remove haskell packages, and then install them in ~/.cabal as a normal user? :)
00:05:51 <arkeet> that's what I do. :)
00:05:56 <Zenol> That's what I do with archlinux.
00:06:09 <NihilistDandy> My vote goes there, too
00:06:11 <Zenol> They have some haskell pacages but some are outdated, some libs aren't packages, etc.
00:06:14 <Fernandos> Zenol: would existing packages know if that haskell package is installed or not?
00:06:24 <arkeet> it's just kind of a hassle to get packages that aren't in portage or are too old in there. I know hackport exists, but that's bothersome.
00:06:28 <NihilistDandy> Just install haskell-platform with emerge, then cabal install everything els
00:06:30 <NihilistDandy> *else
00:06:39 <arkeet> or ghc
00:06:54 <arkeet> well, it still should just work
00:07:19 <Zenol> yap, GHC package and then install all your stuff with cabal. You'll be sure to have the last version of the lib.
00:07:46 <Zenol> Also, take care of your config file. If you are developing, you would like to avec the flash --shared and --prof always on while instaling new libraries.
00:08:04 <Fernandos> ghc package? sorry.. I never haskell before :-) not sure I understand what you say
00:08:21 <Zenol> Fernandos: GHC is the name of the haskell compiler. Like GCC for c :)
00:08:38 <arkeet> well, get the haskell platform.
00:09:36 <Zenol> Fernandos: You'd better just follow what arkeet says, I'm still a haskell newbee.
00:10:08 <arkeet> how did all that stuff end up there anyway?
00:10:21 <arkeet> did you just install everything under dev-haskell? :-)
00:10:28 <Zenol> xmonad?
00:10:32 <arkeet> hmm
00:10:44 <Ghoul_> I really recommend setting local documentation too
00:10:49 <Ghoul_> the local documentation index is amazing
00:11:04 <NihilistDandy> Yeah
00:11:06 <Zenol> Ghoul_: What is it?
00:11:19 <Ghoul_> its a huge list of every package namespace you have installed
00:11:24 <Ghoul_> with clickable links to their docs
00:11:28 <Fernandos> arkeet: how would I remove all haskell packages from emerge and verify if they're removed cleanly?
00:11:39 <c_wraith> if nothing else, enabling local documentation means "cabal haddock" will generate links to other packages you have installed correctly, so you can verify you didn't typo the docs..
00:11:43 <Ghoul_> so if you need to find help on a package, you open it up and ctrl+f the namespace
00:11:56 <Ghoul_> additionally, it also generates one huge page with every function from every namespace on it
00:11:57 <Fernandos> I guess I have to use --nodeps to even be able to do that..
00:12:03 <Ghoul_> so you can just ctrl+f there to find where something is from
00:12:20 <Zenol> Ghoul_: It would be better than always trying to get the right package version on hackage.
00:12:25 <arkeet> Fernandos: well, that's a gentoo question.
00:12:30 <Ghoul_> agreed
00:12:40 <Fernandos> ok
00:12:49 <Ghoul_> if you're on windows though, you'll need to pull cabal from git
00:12:57 <Ghoul_> I found a bug in it that got fixed 2-3 days ago :)
00:13:48 <Zenol> Ghoul_: documentation in ~/.cabal/config ?
00:14:15 <arkeet> yes
00:14:28 <arkeet> it's too bad not every command-line option is settable in there. :(
00:14:51 <Zenol> Let me hope I won't have to reinstall the whole world to have the doc...
00:14:52 <arkeet> like hscolour and stuff
00:14:55 <arkeet> you would.
00:15:02 <arkeet> while you're at it, turn on profiling if you haven't.
00:15:12 <Zenol> I'v --prof and --shared.
00:15:23 <arkeet> why --shared?
00:15:38 <Zenol> because I need the .so files?
00:15:47 <arkeet> you do?
00:15:59 <Zenol> I don't recall why xD
00:16:08 <Zenol> maybe something with snap
00:16:22 <arkeet> anyway, you can just set those in .cabal/config
00:16:27 <arkeet> e.g. library-profiling: True
00:16:46 <Zenol> arkeet: They are already since many weeks ;)
00:16:49 <arkeet> fine.
00:17:02 <Zenol> except for documentation.
00:17:34 <Zenol> so.. if I want the doc, I have to cabal --reinstall 'world' ?
00:17:50 <arkeet> something like that.
00:17:55 <Zenol> err
00:18:02 <Zenol> world is broken in my cabal directory :/
00:25:15 <Dextr> hi
00:27:57 <Zenol> arkeet: Hum, the doc shouldn't be stored in .cabal/share/doc/libname/ ?
00:28:13 <arkeet> it isn't.
00:28:37 <arkeet> wait, it is.
00:30:40 <Zenol> hum, should I do something after modifying the ~/.cabal/config? like cabal update ?
00:30:58 <Dextr> is there any production-ready db written in haskell?
00:30:59 <arkeet> no
00:31:22 <Zenol> Dextr: db or sgdb api ?
00:31:46 <Dextr> db, as in dbms ... not necessarily an sql one though
00:31:50 <Dextr> what is sgdb?
00:32:12 <Zenol> arkeet: Oh. The GHC version is 7.7.20130711 but haddock is using GHC version 7.6.3 :$
00:32:52 <arkeet> you should fix that!
00:32:57 <Zenol> Dextr: You want a library to read / write to/from a database like mysql, postgresql, or sqlite?
00:33:09 <Zenol> arkeet: Yeh, I should, but you know, I'm lazy... :p
00:33:25 <Dextr> no, I'm interested in whether there is a database written in haskell
00:33:52 <evancz> Saizan: that did the trick! Thanks again! That would have taken me ages to figure out.
00:33:53 <Zenol> Dextr: sorry, I can't help you.
00:34:18 <Dextr> what is sgdb?
00:34:19 <NihilistDandy> Dextr: There's acid-state. It's not strictly a database, I guess, but the idea's similar
00:34:41 <NihilistDandy> http://hackage.haskell.org/package/acid-state
00:35:05 <NihilistDandy> Well, I guess it's a database, but not how you might normally think of one
00:35:21 <Zenol> Dextr: oh sorry, it's not the right english word. RDBMS.
00:36:03 <Dextr> NihilistDandy that's close enough I guess, thanks!
00:39:42 <Zenol> arkeet: It might be because the haddock I compiled with 7.7 isn't the one in /usr/bin/ ... Don't know if I wan't to remove this one...
00:40:02 * hackagebot storable-static-array 0.6.0.0 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.6.0.0 (CarlHowells)
00:40:08 <arkeet> yeah, I'm pretty sure haddock has to be compiled with the same ghc versions
00:40:10 <arkeet> version
00:40:20 <NihilistDandy> Yep
00:41:18 <Zenol> arkeet: Yep, but I compiled it when I compiled GHC.
00:41:35 <arkeet> what ghc did you use to compile it? :-)
00:41:38 <Zenol> arkeet: actualy, I compiled ghc because I wanted to compile haddock.
00:41:42 <arkeet> :-(
00:41:48 <arkeet> you shouldn't ever have to compile ghc.
00:42:00 <arkeet> unless you're like a ghc dev.
00:42:05 <Zenol> arkeet: I should, 7.6 wasn't compatible with the head of haddock..
00:42:34 <Zenol> arkeet: I'm not good enougth to hack on ghc.
00:42:38 <NihilistDandy> Where do you even get the head of haddock?
00:42:51 <NihilistDandy> I've never found a repo for it
00:43:02 <NihilistDandy> I just use the one from the ghc bindists
00:43:38 <dcoutts_> NihilistDandy: hackage page for it links to the repo
00:44:07 <NihilistDandy> Oh, I guess I never thought about it long enough to actually check the hackage page :D
00:44:13 <arkeet> Zenol: well why were you trying to compile haddock head? :-)
00:45:43 <dcoutts_> NihilistDandy: or if you already had a copy of the code, you could look in the .cabal file
00:46:02 <NihilistDandy> Also true
00:46:21 <Zenol> arkeet: I wanted to write a manpage backend. But I didn't have the time yet.
00:47:01 <arkeet> well, you still shouldn't have to compile ghc.
00:47:03 <arkeet> there are nightlies.
00:47:20 <Zenol> NihilistDandy: Probably from the haskell wiki :p
00:48:43 <Zenol> NihilistDandy: http://darcs.haskell.org/haddock.git
00:48:55 <Zenol> thats what says my local git repository :p
01:00:02 * hackagebot sandi 0.2.3 - Data encoding library  http://hackage.haskell.org/package/sandi-0.2.3 (MagnusTherning)
01:22:07 <Zenol> lots of peaples are pushing lots of stuff on hackage those days.
01:22:11 <tornado> ciao
01:22:15 <tornado> !list
01:22:15 <monochrom> tornado: http://okmij.org/ftp
02:05:03 * hackagebot MHask 0.3.0.0 - The category of monads  http://hackage.haskell.org/package/MHask-0.3.0.0 (DanBurton)
02:23:24 <Neqoxec> I liked that zipWith fibonacci thing on the wiki, so here's a factorial version:
02:23:27 <Neqoxec> factorials = 1 : zipWith (*) [2..] (factorials)
02:27:55 <mstksg> does laziness mean that a <- f :: m a0 won't be evaluated unless I use a somewhere?  assume f does not affect the monad state
02:28:50 <quchen> mstksg: That depends on how >>= is implemented I think.
02:29:05 <quchen> i.e. whether successive binds depend on previous actions
02:29:27 <quchen> (Is that what you meant by "monad state"?)
02:32:37 <hpaste> quchen pasted ‚Äúmstksg: Identity skipping binds‚Äù at http://lpaste.net/91587
02:41:53 <merijn> quchen, mstksg: a won't be evaluated, but the effects of producing a will be
02:43:17 <merijn> If there are no effects, because you used return/pure or something, then obviously nothing will happen
02:43:36 <dpwright_> I had some function types which I wanted to simplify, so I did, for example, "type OpenFunc = CInt -> IO CInt"
02:43:42 <merijn> For some value of "nothing" and "will happen"
02:43:51 <dpwright_> but, some of those functions (these are all FFI wrappers) take a parameter
02:44:15 <merijn> dpwright_: What do you mean by "take a parameter"? You mean they have type variables?
02:44:16 <dpwright_> "type Read = CInt -> Ptr a -> CInt -> CInt -> IO CInt" doesn't work, because there is no type parameter "a"
02:44:23 <dpwright_> that is probably what I mean, yes
02:44:29 <dpwright_> type variable, sorry
02:44:36 <merijn> dpwright_: You can write "type Read a = CInt -> Ptr a -> ..."
02:44:47 <adnap> Can I write a literal with value infinity and type Float?
02:45:08 <adnap> Or is Float not strictly an IEEE float?
02:45:08 <merijn> adnap: I don't think so?
02:45:12 <merijn> > 0/0
02:45:13 <lambdabot>   NaN
02:45:15 <merijn> eh
02:45:18 <merijn> hmm
02:45:21 <merijn> > 1/0
02:45:22 <lambdabot>   Infinity
02:45:42 <tshirtman> there, you broke the universe
02:45:43 <adnap> > (read "Infinity") :: Float
02:45:44 <lambdabot>   Infinity
02:46:02 <merijn> adnap: Float should follow IEEE, but I don't think you can write Infinity/NaN as literals, you can read them or compute them by division, though
02:46:17 <adnap> > let x = (read "Infinity") :: Float in x + 1
02:46:18 <lambdabot>   Infinity
02:46:21 <merijn> Might want to do "inf = read "Infinity"" or something
02:46:47 <adnap> Are there any issues with Infinity?
02:46:57 <adnap> That could cause a program to crash?
02:47:37 <merijn> adnap: I don't think so? Might want to check IEEE734 and the haskell report to be sure?
02:47:43 <adnap> > 1e400 :: Float
02:47:44 <lambdabot>   Infinity
02:48:32 <adnap> > (0 / 1e400) :: Float
02:48:33 <lambdabot>   0.0
02:48:56 <adnap> > (0 / 0) :: Float
02:48:57 <lambdabot>   NaN
02:49:12 <adnap> > (1e400 / 1e400) :: Float
02:49:13 <lambdabot>   NaN
02:49:45 <adnap> I
02:49:57 <adnap> I'm surprised there's no inf :: Float function in Prelude or something
02:52:25 <quchen> As far as I know Infinity is a valid Float just like 1.0 is.
02:52:37 <quchen> There shouldn't be any crashes.
02:52:49 <adnap> I want some help...
02:55:33 <adnap> I have xs :: [(a, a -> [a] -> b)] and I want [b] by taking every a and applying its paired function on the a and all the other a's excluding the current one. Hopefully that makes sense. Is there a good pattern for this?
02:56:17 <simukis_> adnap: something like zippers?
02:56:37 <adnap> Oh, I thought of a way to do it with a fold
02:57:05 <adnap> Where the accumulator has two lists with one being everything up to the current a, and the other being everything after the current a
02:57:22 <adnap> And the accumulator also has the current list of b's
02:58:02 <adnap> simukis_: I don't know about zippers. I know it is a section in LYAH. Maybe I should start there if you think that is a good way to do this
02:58:43 <simukis_> adnap: well, zippers are almost what you described ([a], a, [a])
02:58:54 <hpaste> quchen pasted ‚Äú@adnap‚Äù at http://lpaste.net/91588
03:00:04 <simukis_> where [a] are already visited and not yet visited lists.
03:00:06 <adnap> quchen: That is wrong
03:00:21 <adnap> quchen: aaa contains all the a's, and I want to exclude the current a when applying the function
03:01:15 <adnap> simukis_: Sounds good. I'm reading the LYAH chapter on them now
03:01:32 <adnap> simukis_: I'm hoping zippers will be more efficient than my fold idea
03:01:58 <quchen> In that case zippers are probably the way to go.
03:03:06 <adnap> Could lens help here? >:P
03:03:35 <adnap> "In this chapter, we'll see how we can take some data structure and focus on a part of it in a way that makes changing its elements easy and walking around it efficient. Nice!" from the LYAH on zippers made me thing of lenses
03:05:38 <chrisdone> why isn't eitherToMaybe defined anywhere?
03:06:04 <quchen> chrisdone: Propose it?
03:06:19 <quchen> I remember reinventing it many times
03:06:29 <quchen> And while you're at it, mapLeft would be cool too
03:07:08 <mstksg> quchen, merijn: thanks
03:07:59 <adnap> mapLeft :: Functor f => (a -> c) -> f (a, b) -> f (c, b) ?
03:08:40 <chrisdone> he means mapLeft :: Either a b -> (a -> c) -> Either c b or w/e
03:09:22 <merijn> quchen: That sounds like type level flip
03:09:28 <adnap> Oh
03:09:43 <adnap> "Type level flip"...
03:09:45 <quchen> mapLeft f (Left x) = Left (f x); mapLeft f r = r
03:09:48 <adnap> :t (??)
03:09:49 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:10:20 <quchen> merijn: Sort of, yes. I'd rather have it without type magic though.
03:11:35 <chrisdone> @let mapLeft f = either (Left . f) Right
03:11:36 <lambdabot>  Defined.
03:11:48 <chrisdone> @let eitherToMaybe = either Just (const Nothing)
03:11:49 <lambdabot>  Defined.
03:12:19 <quchen>  @let chrisdone write libraries@haskell ;-)
03:12:34 <chrisdone> actually, i suppose my version isn't the expected version
03:12:43 <chrisdone> as i want the left value, hehe
03:13:14 <quchen> let flipEither (Either a b) = Either b a
03:13:15 <quchen> :-P
03:14:05 <simukis_> rehtie a b = Either b a
03:14:07 <chrisdone> ahh
03:14:21 <chrisdone> leftToMaybe, rightToMaybe, perhaps
03:14:34 <quchen> That sounds intuitive.
03:14:53 <quchen> Although conceptually Right -> Just is better.
03:15:16 <quchen> If you really want to make the Left a Just then you should probably make that very explicit.
03:15:27 <quchen> (Maybe call it unsafeLeftToJust) :-)
03:15:32 <chrisdone> why?
03:15:46 <adnap> > (+2) $ 40
03:15:47 <lambdabot>   42
03:15:49 <chrisdone> leftToMaybe :: Either a b -> Maybe a
03:15:50 <chrisdone> rightToMaybe :: Either a b -> Maybe b
03:15:53 <chrisdone> both legimate use-cases
03:16:00 <chrisdone> Left isn't always "error"
03:16:10 <chrisdone> in my case it's just one of two values
03:16:10 <simukis_> Uhum, I would prefer if Right was error :)
03:16:41 <adnap> simukis_: Noo!
03:16:42 <merijn> quchen: mapLeft is just "either f id", though
03:16:56 <quchen> merijn: Plus constructors.
03:16:58 <merijn> :t either
03:16:59 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:17:04 <merijn> oh
03:17:10 <merijn> No it's not >.>
03:17:12 <chrisdone> as i wrote above, mapLeft f = either (Left . f) Right
03:17:36 <quicksilver> there is a polymorphism difference isn't there?
03:17:58 <merijn> quchen: Actually, even simpler
03:18:01 <merijn> :t left
03:18:02 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
03:18:05 <quicksilver> quchen's version is less polymorphic than chrisdone's
03:18:11 <merijn> :t left succ
03:18:12 <lambdabot> Enum a => Either a d -> Either a d
03:18:24 <merijn> quchen: learn2arrow ;)
03:18:38 <chrisdone> quicksilver: yeah. given that fmap lets you change type, i figured so should mapLeft
03:19:17 <quchen> merijn: Pff. Arrows should probably be removed and put in Data.Tuple, and now Data.Either. :P
03:19:32 * quchen ducks
03:20:13 <Zenol> :t .
03:20:13 <lambdabot> parse error on input `.'
03:20:17 <Zenol> :t (.)
03:20:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:20:31 <Zenol> oh, I was expecting something else from lambdabot :p
03:20:53 <quchen>  :t (Control.Category..)
03:21:30 <Zenol> quchen: yes :p
03:21:44 <quicksilver> chrisdone: yours is also more polymorphic on the right
03:21:57 <quicksilver> or is it
03:22:03 <quicksilver> nope
03:22:20 <Zenol> :t Data.Category.(.)
03:22:21 <lambdabot> Couldn't find qualified module.
03:22:37 <chrisdone> :t Control.Category.(.)
03:22:38 <lambdabot> Couldn't find qualified module.
03:23:04 <chrisdone> quicksilver: had me wondering then =p
03:23:06 <Zenol> what's the difference with http://hackage.haskell.org/packages/archive/data-category/latest/doc/html/Data-Category.html#v:. ?
03:23:16 <quchen> :t (Control.Category..) -- chrisdone
03:23:17 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
03:23:32 <quchen> quicksilver: Why is my version limited to (a -> a)?
03:23:41 <quchen> I don't see it.
03:23:53 <chrisdone> quchen: because you pass the right value as-is and the type of it doesn't change
03:24:33 <quchen> Oh, tricky.
03:25:05 <quchen> Minimal mail from chrisdone haha
03:25:33 <chrisdone> =p
03:27:16 <merijn> Zenol: That uses GADTs it seems, which implies it uses less portable GHC tricks
03:27:25 <quchen> Maybe we should collect some changes in the Wiki and then propose all of them at once. edwardk's Void proposal is pretty small as well.
03:27:42 <quchen> And I've got this file saying "ZipList needs Show" and "sClose has wrong documentation"
03:28:23 <quchen> On the other hand, ^ isn't really something that needs discussion I geuss.
03:31:15 <chrisdone> donri: Dang, Hold Them All!
03:31:43 <chrisdone> quchen: ime most everything i propose is rejected so i don't waste much time on it
03:31:54 <merijn> quchen: I'm pretty sure I submitted a patch for the ZipList show instance a few weeks ago
03:32:04 <merijn> quchen: I remember I got much cheering from lazy people in -blah
03:36:13 <Zenol> merijn: Ok :)
03:36:42 <merijn> quchen: Yeah, it was patched 7 weeks ago, so I guess the next release should have it \o/
03:38:09 <Zenol> merijn: Is ghc using darc?
03:42:56 <sordina1> Hey guys.
03:43:22 <sordina1> I'm getting some very strange slow performance for the following code: http://lpaste.net/91590
03:44:06 <sordina1> There seems to be a constant slowdown for ~0.3 seconds for any handle redirection program of this style.
03:44:31 <sordina1> I'm not sure why this is as it really should be a lot faster... I'm guessing.
03:45:19 <sordina1> I came across this when writing a pandoc program to pass off processing of code-blocks to an external program.
03:49:01 <sordina1> Ahh never mind was forgetting to close the handle
03:54:47 <merijn> Zenol: GHC is using git nowadays
04:05:53 <amosr> there seem to be a few lens packages. is 'lens' the most recent, coolest and hippest?
04:06:22 <ocharles> amosr: pretty much
04:06:29 <ocharles> it's not everyone's cup of tea
04:06:37 <ocharles> (but it is certainly mine)
04:06:52 <Fernandos> hi, I'm back with a clean system
04:07:01 <amosr> ocharles: okay, thanks. I'll give it a go
04:08:13 <merijn> amosr: It's certainly the most recent and most absurdly general
04:08:19 <Yuu-chan> Data.Time.toGregorian :: Day -> (Integer, Int, Int) wasn't Int enough?
04:08:25 <Fernandos> Now I want to install the haskell-platform with USE="doc", but the build it too slow. Isn't there a way to let ghc build things in parallel? like settings MAKEOPTS="-j16 -s" for make?
04:09:37 <Fernandos> I won't use cabal for that, because that messed up my system when I ran it as root as suggested her
04:09:56 <Yuu-chan> As my coworker said ó "Haskell will live eternally, robots with Haskell firmware will observe the death of the Solar system, knowing exactly what day it is"
04:10:20 <Ghoul_> does anyone know how to generate a deb for the haskell platform when custom built?
04:10:22 <Fernandos> Yuu-chan: that's a joke, right?
04:10:31 <Ghoul_> I would like to install with apt
04:11:09 <Fernandos> Ghoul_: the way to go is to use launchpad.net for that, for debian/ubuntu systems
04:11:48 <Yuu-chan> Fernandos: the type signature is real...
04:12:16 <Fernandos> Ghoul_: otherwise building deb packages requires more work than necessary.. you can look for tools for that, but there's a channel for that..
04:12:52 <Ghoul_> Fernandos: thanks for giving me that link
04:13:12 <Fernandos> Yuu-chan: not sure what you mean. Haven't used haskell yet except passively, because it was required by pandoc
04:14:39 <Yuu-chan> Fernandos: see my first message about toGregorian function which returns year as an unbounded integer. That was a rhetoric question :)
04:15:01 <Fernandos> Yuu-chan: Haven't seen that..gotcha
04:15:57 <FreeFull> STM is pretty amazing
04:15:58 <Fernandos> Yuu-chan: Btw. the only thing that will live almost eternaly is someone's dna, because that can 10: live in harsh enviroments, including space for very long and then seed other planets. goto :10
04:16:11 <FreeFull> Also, I was scrolled way up
04:16:50 <stupid> "test.png:1:1: lexical error (UTF-8 decoding error" any ideas how to fix this?
04:17:20 <Fernandos> so is there a way to build in parallel or not?
04:17:20 <Ghoul_> Dependency not met; ghc >= 7.6.3
04:17:21 <Ghoul_> doh!
04:17:40 <chrisdone> is this or something equivalent around anywhere? Monad m => Bool -> m a -> m (Maybe a)
04:19:11 <Fernandos> searching if parallel builds are possible returned only one thread where one guy sabotaged someone else's patch, by monkey-patching cabal to allow quasi parallel builds. meh..
04:19:15 <Fernandos> the internet..
04:19:24 <hpc> you mean \b m -> if b then (m >=> (return . return)) else (return Nothing)?
04:19:35 <merijn> Fernandos: cabal should support a "-j n" flag for parallel builds
04:19:50 <dcoutts> Fernandos: it supports parallel builds but only for independent packages at the moment
04:20:04 <dcoutts> still useful if you're installing one of the web stacks
04:20:06 <chrisdone> hpc: yup
04:20:17 <Fernandos> merijn: nice, but I don't use cabal and that -j n flag doesn't build in paralell unless I run: cabal install package-one package-two
04:20:23 <FreeFull> hpc: I'm sure there is a simpler way to write that
04:20:45 <Fernandos> merijn: that's my knowledge according to my websearch though, I know nothing about haskell :)
04:20:48 <FreeFull> @hoogle Bool -> a -> Maybe a
04:20:49 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
04:20:49 <lambdabot> Control.Exception assert :: Bool -> a -> a
04:20:49 <lambdabot> Control.OldException assert :: Bool -> a -> a
04:21:06 <hpc> chrisdone: i don't think it exists in any library
04:21:37 <FreeFull> Let's hayoo
04:21:53 <Fernandos> merijn: so it's not possible?
04:21:56 <Ghoul_> I tried looking for it in hayoo
04:22:47 <FreeFull> There is a non-monadic version
04:23:20 <hpc> chrisdone: i think typically, what would happen is you would use some combination of guard
04:23:28 <datura> chrisdone: no monad necessary here, a functor should be enough, right?
04:23:36 <FreeFull> Sadly there doesn't seem to be a  (a -> b -> c) -> a -> m b -> m c
04:24:18 <donri> Fernandos: there's two current gsocs about intermodule compilation parallelism
04:24:33 <datura> where's Bool -> a -> Maybe a in haskell?
04:25:16 <Ghoul_> :t maybe
04:25:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:25:45 <quchen> :t \p x -> x <$ guard p -- datura
04:25:46 <lambdabot> (Functor f, MonadPlus f) => Bool -> a -> f a
04:26:17 <merijn> Fernandos: How would you compile any haskell package without cabal?!
04:26:18 <Maior> so, er, anyone looking for work? (is there any convention/ruling on job ads in here?)
04:26:29 <Ghoul_> Data.Maybe.HT.toMaybe
04:26:55 <merijn> Maior: As long as you keep down the volume (like maybe ask once or twice a day or something) I think it's no problem
04:26:58 <Fernandos> donri: sorry I don't know what you want to say by that.
04:27:04 <donri> Fernandos: https://github.com/23Skidoo/ghc-parmake but it's not really faster than sequential builds due to lack of caching
04:27:09 <merijn> Maior: haskellers.com and haskell-cafe are also good places
04:27:13 <Maior> merijn: cheers
04:27:15 <Fernandos> donri: ahh
04:27:18 <merijn> Maior: (Incidentally, yes, I am ;))
04:27:35 <donri> Fernandos: gsoc = google summer of code. there's two projects this year about adding parallel cabal build / ghc -c
04:27:55 <donri> Fernandos: (that aim to solve the problem i mentioned for ghc-parmake)
04:28:00 <Fernandos> merijn: I don't use cabal because I need to install it systemwide, doing that with cabal messes up the system
04:28:48 <chrisdone> datura: i think you need a return somewhere
04:28:51 <merijn> Fernandos: Wouldn't it be an option to just use "cabal build -j n" i.e., not cabal install and then do the install manually?
04:29:11 <donri> merijn: i don't think build accepts -j yet
04:29:13 <chrisdone> datura: to return the Nothing
04:29:19 <merijn> donri: oh, sad times :(
04:29:20 <Fernandos> donri: interesting. I thought it was already there, but got rejected, because cabal can do "quasi  parallel" builds. ThaT's what I found on that websearch
04:29:48 <Fernandos> donri:  see: http://ghc.haskell.org/trac/ghc/ticket/910#comment:21
04:29:58 <donri> Fernandos: cabal install can build dependencies in parallel depending on the dependency graph
04:30:06 * hackagebot CSPM-CoreLanguage 0.3.0.3 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.3.0.3 (MarcFontaine)
04:30:08 * hackagebot CSPM-FiringRules 0.4.2.0 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.4.2.0 (MarcFontaine)
04:30:20 <stupid> http://lpaste.net/91593 any ideas what's wrong? using helm and lenses
04:30:27 <stupid> get some weird ass error
04:30:50 <dcoutts> Fernandos: I think many people thing the right place to put parallel build is not into ghc --make, but into the build tool
04:30:58 <datura> chrisdone: i think you just need to map over some a -> Maybe a
04:31:16 <dcoutts> Fernandos: ghc is sadly rather stateful so parallel build within ghc is actually rather hard
04:31:20 <hpc> stupid: s ^. padL :: Double, apparently
04:31:23 <chrisdone> datura: like what?
04:31:27 <Fernandos> when I first tried to install the haskell-platform I got a circular dependancy, that's with a clean system. Just because I added USE="doc", xhtml had to be compiled with USE="-doc" first to fix it.
04:31:34 <hpc> stupid: you probably want some sort of rounding function
04:31:40 <hpc> floor/ceil/something
04:32:05 <hpc> :t fromIntegral
04:32:06 <lambdabot> (Integral a, Num b) => a -> b
04:32:11 <hpc> :t round
04:32:12 <lambdabot> (Integral b, RealFrac a) => a -> b
04:32:51 <hpc> stupid: er, actually, i think you can just get rid of fromIntegral in that expression and it will work
04:32:54 <Fernandos> dcoutts: idk, I just learned about haskell. isn't statefullness a huge advantage and would even help to make it scale to n cores?
04:33:11 <stupid> hpc: okey
04:33:19 <donri> Fernandos: i think you're thinking of state*less*ness?
04:33:20 <dcoutts> Fernandos: you mean state*less* right?
04:33:29 <stupid> hpc: thanks, sry for idiotic questions
04:33:37 <hpc> nah, type errors are sometimes tricky
04:33:46 <Tinned_Tuna> Fernandos: having state can actuall make scaling very difficult
04:33:50 <Tinned_Tuna> *actually
04:33:55 <hpc> especially in numeric code, where no other language is so picky
04:34:12 <dcoutts> Fernandos: ironically for a compiler for a pure FP language, GHC isn't completely devoid of mutable variables internally
04:34:15 <FreeFull> When I get a type error, I just figure out what the type is supposed to be, what the type actually is, and the fix it
04:34:18 <FreeFull> then*
04:34:23 <Fernandos> dcoutts: no, statefullness. Having state, given the premise that states can be distributed allows easier scalabliity afaik.
04:34:49 <dcoutts> Fernandos: it's much easier to parallelise code that has no mutable state
04:34:57 <Fernandos> Tinned_Tuna: I thought the complete opposite is the case.. hmm
04:35:07 * hackagebot CSPM-Frontend 0.9.2.0 - A CSP-M parser compatible with FDR-2.91  http://hackage.haskell.org/package/CSPM-Frontend-0.9.2.0 (MarcFontaine)
04:35:09 * hackagebot CSPM-ToProlog 0.5.1.0 - some modules specific for the ProB tool  http://hackage.haskell.org/package/CSPM-ToProlog-0.5.1.0 (MarcFontaine)
04:35:11 * hackagebot CSPM-Interpreter 0.6.1.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.6.1.0 (MarcFontaine)
04:35:13 * hackagebot CSPM-cspm 0.7.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.7.0.0 (MarcFontaine)
04:35:25 <dcoutts> Fernandos: which is why Haskell is usually in a good place for writing parallel code, no mutable state by default
04:35:26 <Tinned_Tuna> Fernandos: no mutable state means that you can run most things in parallel without them interfering.
04:35:48 <FreeFull> I wonder if in the future, updates to packages on Hackage will be so common hackagebot will have to be turned off
04:36:31 <Tinned_Tuna> FreeFull: on the one hand, I hope so, on the other hand, a very fast moving "almost-standard-library" can be a hard thing to develop with.
04:36:59 <lykos_> Fernandos: Some of the most serious issues with parallel processing are deadlocks and race conditions. Those are because of state. Think about this: if you have two processors using the same data, say a text file, then they have to basically "fight" over the recourse (or slow down and wait when the other thread is using the resource)
04:37:05 <Fernandos> dcoutts: when you build a rdbms yourself with states and rollback etc. (acid) then you chunk states into commits, isn't haskell similar?
04:37:35 <lykos_> Fernandos: Basically, stateless computations allow each thread to go at "full speed" without having to wait for global resources.
04:37:46 <dcoutts> Fernandos: well now you're talking about something rather specific, about updating persistent state on disk
04:37:54 <Tinned_Tuna> Fernandos: no, I think what you're referring to is STM. There's a library for that, but it's not the default behavior. In haskell, there is (usually) no shared state.
04:38:16 <Tinned_Tuna> http://hackage.haskell.org/package/stm
04:38:31 <donri> Fernandos: those are tools to make scaling mutable state bearable :p
04:38:34 <Tinned_Tuna> STM is the default behaviour (I think) in Clojure for their "mutable variables"
04:38:48 <Tinned_Tuna> but they tend to eschew it in favour of immutability
04:38:51 <donri> Fernandos: *because* it's not a trivial problem
04:39:15 <Fernandos> Tinned_Tuna: yes, you got what I mean. Oh, I thought you mean a state-machine when you said stateful
04:39:32 <Fernandos> donri: indeed.
04:39:43 <Tinned_Tuna> no, but you can do statemachines in Haskell quite easily ;-)
04:39:53 <FreeFull> Tinned_Tuna: It's not that packages would be updated more often, but just that there would be more packages to get updated
04:40:45 <Tinned_Tuna> FreeFull: that's good, unless lots of people are working on the same "thing" in different packages.
04:40:46 <donri> but it's not that it can't be done [purely functional, parallel-friendly compilation], but understand that ghc is the oldest haskell program in existence
04:41:18 <Tinned_Tuna> GHC scares me, and the fact that we only really have one Haskell compiler running the show also worries me...
04:41:50 <Tinned_Tuna> it's not GHC's fault, it's just that we need competition in our lives ;-)
04:42:27 <donri> at least it's usually mostly obvious when code is ghc-specific (based on imports and language pragmas)
04:43:11 <lykos_> Tinned_Tuna: One of the best things about haskell is that it is unified. So many other languages lost momentum and community because of so many splits offshoots.
04:43:20 <Adeon_> at least ghc is good
04:43:26 <Maior> so, got a friend looking for someone with decent haskell / linux / analytics-y experience to work in Singapore
04:43:47 <chrisdone> at standard charter?
04:44:55 <Fernandos> Tinned_Tuna: crazy idea ‚Üí How about writing haskell code that uses reflection to generate a compiler? The resulting code would be very parallel friendly, when it's true what you said earlier. Then you would "just" need to convert the produced haskell haskell-compiler into C using llvm
04:44:59 <donri> Maior: https://github.com/analytics/analytics/graphs/contributors :p
04:46:22 <Maior> donri: interesting, I wonder if he meant that...!
04:46:48 <Fernandos> donri: hmm wouldn't the one with least code have the best program?
04:47:02 <donri> Fernandos: no
04:47:29 <Fernandos> donri: care to explain?
04:47:31 <stupid> :t undefined
04:47:32 <lambdabot> a
04:47:41 <stupid> ?src undefined
04:47:42 <lambdabot> undefined =  error "Prelude.undefined"
04:47:48 * Ghoul_ really likes the idea that something ddc-related might sprout in the next few years
04:47:48 <mstksg> does anyone here use persistent?  does anyone know how i can sort on an Enumeration by the Ord of the data type and not alphabetically?
04:48:38 <Fernandos> donri: ah k.. well they'd have to be sovling the same problem in order to be comparable.. forgot that...
04:48:41 <donri> Fernandos: lines of code is a horrible measure of code quality in either direction
04:48:55 <mstksg> i guess technically only the string of the enumeration is in the database so there's no way the backend would be able to even know
04:49:47 <donri> Fernandos: a bit like judging art by the number of brush strokes. yes there is minimalist art and it has its place but it's not the only worthwhile art form.
04:50:50 <donri> Fernandos: for some it's an obsession that becomes a thought-terminating cliche
04:51:07 <Fernandos> donri: hmm not sure, but I see code not so much as art, but more as an efficiency problem. It would be real art if it wasn't dependant on the architecture I think, but that's too meta now :)
04:52:33 <donri> Fernandos: code is rarely made more efficient by reducing the number of lines. you want to reduce the number of instructions, and that often takes more lines of code.
04:53:43 <Tinned_Tuna> donri: even then, if we take, for example, a piece of code on x86 which uses the XCHG instruction, you'll probably kill the performance of it. if you restructure the program to avoid that instructions (often by *adding* other instructions) you can often get a faster, equivalent program
04:53:59 <Tinned_Tuna> especially where the xchg happens in the middle of a performance-critical loop
04:54:28 <Tinned_Tuna> but, "a sufficiently smart compiler" etc.
04:54:44 <donri> yes, that seems like a compiler problem to me :)
04:54:56 <barrucadu> I always read XCHG as "X Chug", which I guess isn't totally wrong
04:55:54 <Tinned_Tuna> donri: it is a compiler problem, unless you're writing in asm ;-)
04:56:30 <donri> quite
04:56:57 <donri> which was sort of my point: only in asm does "line" correspond to "instruction", and even then...
04:57:11 <Tinned_Tuna> Fernandos: parallel haskell, once you get reasonably handy with Haskell: http://shop.oreilly.com/product/0636920026365.do
04:58:07 <Tinned_Tuna> Fernandos: as a more general overview, I quite like this, although it's use is limited if you don't work in a Java house: http://pragprog.com/book/vspcon/programming-concurrency-on-the-jvm
04:59:03 <Tinned_Tuna> All throughout the JVM book, it's quite adamant that mutability is a hinderance.
04:59:30 <Fernandos> far from it, I only needed haskell due to pandoc, which again was required because I wanted to use https://github.com/suchow/dissertate
05:05:13 <Tinned_Tuna> Quick, random question, does anyone know of any libs on hackage to help distribute computation(s) over a cluster of machines, rather than just cores on a CPU?
05:05:29 <Tinned_Tuna> I had a look at things like hactors, but it seems to have reasonably limited docs.
05:06:03 <Ghoul_> Tinned_Tuna: cloud-haskell ?
05:06:23 <Ghoul_> or maybe accelerate, but im not 100% sure if theres a backend for accelerate for that
05:06:49 <Tinned_Tuna> Ghoul_: isn't accelerate for GPU programming?
05:07:12 <donri> Tinned_Tuna: distributed-process
05:07:26 <Tinned_Tuna> Ghoul_: this cloud-haskell thing looks quite good, I'll have a dig into the docs :-)
05:07:48 <merijn> pipes v4 looks rather minimal compares to huge swath of modules of pipes v3
05:08:22 <quchen> pipes 4 is out?
05:08:26 <merijn> Anyone know how different the APIs are?
05:08:30 <merijn> quchen: No, I was looking at github
05:08:34 <quchen> Ah :-(
05:08:53 <donri> Tinned_Tuna: distributed-process is the latest incarnation of cloud haskell and it has a chapter in marlow's new book
05:11:08 <merijn> Relatedly, is there a library that combines a binary/attoparsec? I'm not seeing any ByteString producers in obvious places
05:11:15 <Tinned_Tuna> donri: I guess I haven't got that far yet, I always thought that the parallelism in haskell was a work in progress. Marlow's book thinks differently, and I'm looking forward to trying it out ^.^
05:11:36 <donri> Tinned_Tuna: chapter 14
05:12:04 <zomg> I always thought parallelism in haskell was pretty easy in comparison to most languages, and certainly not a work in progress =)
05:12:23 <zomg> I never actually tried using it though :p
05:12:31 <Tinned_Tuna> me -> afk
05:12:42 <exicer> So I'm trying to understand typeclasses and stuff. Is it correct to say that a list is a type constructor in the same was that maybe is ?
05:12:59 <quchen> zomg: My first steps were very disappointing: it worked out of the box and I was done. I reserved a whole afternoon and then this.
05:13:24 <zomg> quchen: hehe :)
05:13:35 <quchen> zomg: On the serious side, distributed programming and graphics-based processing are nontrivial in any case.
05:14:15 <merijn> exicer: You can think of the type "[a]" as being syntactic sugar for "[] a" or "List a"
05:14:20 <zomg> quchen: yeah
05:14:28 <quchen> Basic parallelism/concurrency is quite easy in Haskell, but the advanced stuff becomes difficult for technical reasons. On graphics cards, you need code specifically tailored to be run on them for example. You can't just "put something on there".
05:14:30 <merijn> exicer: Which, indeed, is pretty similar to "Maybe a"
05:14:50 <pxqr> how to remove-source from cabal-dev?
05:14:57 <quchen> zomg: For distributed processes, you need to make sure the distribution overhead isn't more than the calculations you're running elsewhere.
05:15:07 <quchen> Timing issues etc. It can get quite nasty.
05:15:16 <pxqr> for e.g. if someone want to use hackage instead of local repo
05:15:17 <exicer> merijn: Hmm, okay. Thanks.
05:15:31 <merijn> exicer: If it helps, you can think of list notation as being sugar for the following "data [a] = [] | a : [a]" -> "data List a = Nil | Cons a (List a)"
05:15:36 <pxqr> grep cabal-dev gives nothing
05:16:50 <exicer> merijn: Is there a way to define your own syntactic sugar ?
05:17:09 <merijn> exicer: No, unless you count Template Haskell's quasiquoters
05:18:01 <exicer> Right - not that I know what they are :p
05:18:06 <quchen> Well, CPP can arguably be used for sugar.
05:18:12 <quchen> Translated during compile time etc.
05:18:24 <quchen> But it's, well, CPP. Not pretty, not fun to debug.
05:18:55 <quchen> GHC frequently uses macros like "STRICT_2_OF_3" to automatically generate strictness annotations for functions.
05:19:17 <exicer> quchen: I will avoid anything that complicated for some time, I should think :)
05:19:43 <quchen> CPP isn't complicated, it's like duct tape.
05:19:55 <quchen> CPP = #define stuff
05:20:03 <exicer> I don't know Haskell or CPP well enough to start mixing the two
05:20:06 <merijn> exicer: You can forget abot them for now, they're more of an advaned use case
05:20:37 <haasn> CPP :(
05:20:43 <exicer> merijn: Heh, yeah. I haven't even tried to understand the infamous monad yet.
05:20:44 <merijn> exicer: The basic answer is "there are some limited ways you coul conceivably define syntactic sugar, but as a beginner you almost certainly shouldn't" :)
05:20:54 <exicer> Hehe, sounds sensible
05:21:04 <merijn> exicer: pfft, they're overhyped
05:21:07 <pxqr> ok, to remove-source we need to just remove corresponding line in cabal-dev/packages/00-index.cache
05:21:27 <exicer> merijn: That is kinda what I suspected - but as I said, haven't even tried yet :P
05:21:31 <merijn> exicer: The big problem is that people try to "figure out this mystical thing" without understanding typeclasses and types and get confused
05:21:41 <haasn> merijn: I blame Haskell for giving them special treatment via IO/do-sugar
05:21:55 <haasn> then again, we get arrow syntax and nobody gets hung up over ‚Äúunderstanding the mystical Arrow‚Äù ;)
05:21:57 <merijn> exicer: I'd recommend focussing on being comfortable with types and understanding typeclasses and the they'll mostly be obvious
05:22:03 <exicer> I've just read about functors, which seem much simpler than I was lead to belive
05:22:22 <haasn> exicer: I find that almost everything in mathematics is simpler than people are lead to believe
05:22:27 <haasn> led*
05:22:34 <merijn> exicer: Right, monads are just "slightly more powerful functors", i.e. they allow you to a few more operations
05:22:45 <haasn> merijn: if by slightly you mean significantly :)
05:22:56 <merijn> exicer: Which means that every monad is also a functor, but not all functors can be monads
05:23:00 <exicer> haasn: The big problem I have in maths is that my background is very scattered, and no one seems to use consistent definitions of things (which is fair enough)
05:23:19 <haasn> exicer: you don't need a lot of background to learn Haskell, fortunately
05:23:37 <merijn> haasn: Well, only two more
05:23:38 <quchen> Related: http://www.reddit.com/r/programming/comments/1jsv8d/programming_haskell_doesnt_require_any_category/
05:23:45 <exicer> haasn: Yeah. The university I'm at has some courses on category theory, which I might try and take next year
05:23:48 <merijn> haasn: It's just that those two are very useful :)
05:23:54 <exicer> I suspect it will be very far above my head
05:23:59 <merijn> exicer: Hah, I still know jack all about category theory :)
05:24:12 <exicer> I've basically only done applied maths
05:24:35 <haasn> exicer: category theory is also overhyped when it comes to Haskell imo
05:24:42 <SamanthaD> \o
05:25:17 <exicer> haasn: Heh, I can also believe this. It keeps being mentioned around interesting topics though, so it might be good to try and learn
05:25:22 <exicer> eg quantum computing
05:25:41 <haasn> exicer: re: some earlier discussion on syntactic sugar, you'll find that the built-in haskell syntax lets you do a lot of things that resemble syntactic sugar in other languages, via custom operators and do syntax
05:26:30 <exicer> haasn: Yeah I just saw about that infixr stuff
05:27:33 <haasn> somebody's even written a library that allows you to write syntactically legal BASIC code using Haskell ;-)
05:27:52 <haasn> or in Haskell, rather
05:28:35 <zomg> haasn: sounds like a good idea!
05:31:17 <SamanthaD> Is there a way I can flag memory in Haskell so that the operating system won't page it to swap? I'm working on a program that handles cyphers and it would be a good idea not to allow the decrypted keys to ever touch the disk platter.
05:33:14 <merijn> SamanthaD: Not inpure haskell, it can be done using the FFI (I've thought about this, but not locked into implementing it yet)
05:33:47 <SamanthaD> merijn: Thank you! That's what I needed to know!
05:33:50 <quchen> Concerning sugar, there's the popular example of how to define the ternary operator in Haskell: http://lpaste.net/91601
05:34:27 <merijn> SamanthaD: The mlock C function lets you prevent the OS from swapping memory, you'd have to use that plus pointers to safely store the
05:35:02 <merijn> SamanthaD: Of course that still doesn't guarantee that the code using that memory (potentially containing  copy) doesn't get swapped out
05:35:07 <merijn> SamanthaD: It's a hard problem
05:35:32 <SamanthaD> merijn: Indeed... Perhaps the most prudent way of doing it would be to call the OpenSSL libraries via the FFI
05:35:33 <Eduard_Munteanu> Why would the code matter?
05:36:22 <donri> not that RAM is all that volatile either
05:36:44 <merijn> Eduard_Munteanu: If you have something like "withKey :: UnswappablePtr a -> (a -> IO b) -> IO b" then what's stopping that "a -> IO b" from being swapped to disk after the a has been passed in?
05:36:52 <merijn> Eduard_Munteanu: Thus leaking a, despite all your effort
05:37:06 <merijn> SamanthaD: Might want to look into NaCl too
05:37:17 <Eduard_Munteanu> Oh, just don't handle the sensitive data at all on the Haskell side, then.
05:37:35 <merijn> SamanthaD: (Depending on whether you're starting from scratch or not)
05:37:38 <Eduard_Munteanu> E.g. deal with filenames of encrypted data
05:38:00 <SamanthaD> merijn: I'm not familiar with NaCl?
05:38:01 <merijn> SamanthaD: Alternative lazy solution, encrypt your swap
05:38:08 <Eduard_Munteanu> Or fds perhaps.
05:38:16 <merijn> SamanthaD: http://nacl.cr.yp.to/
05:38:31 <Eduard_Munteanu> But then you have to be careful with coredumps etc. :)
05:38:41 <SamanthaD> merijn: Ha! If I were the only person to use the program I wouldn't even be worried about swap
05:38:45 <merijn> SamanthaD: It's a new, simple, high performance and side channel free crypto library by djb and some others
05:40:12 <SamanthaD> merijn: Excellent. I'll read up on this. And yes, I'm starting from scratch. I've got a loose description of the protocol and how the modules are supposed to work together and right now I'm trying to figure out what language I want to write the various modules in
05:40:34 <merijn> SamanthaD: ok, from scratch you should definitely look into and/or use NaCl
05:41:20 <merijn> SamanthaD: The design assumption is "programmers shouldn't be allowed to choose crypto primitives, because they'll screw it up" so the API is just things like "create_key" "encrypt_and_sign_data_with_key", etc.
05:41:30 <Maior> merijn: haha love it
05:42:21 <adnap> Hey
05:42:37 <SamanthaD> merijn: That sounds like a great idea!
05:42:58 <SamanthaD> merijn: I'll look into that. My other plan was to use OpenSSL.
05:43:13 <SamanthaD> or GPG
05:43:14 <merijn> SamanthaD: NaCl should have a significantly simpler API than openssl
05:43:51 <adnap> I read the LYAH on zippers. Evidently, a list zipper is just ([a], [a]). Is there a standard zipper library, or do people just write their own?
05:43:59 <SamanthaD> sounds good... I suppose I'll just have to write the client software in C then.
05:44:38 <merijn> SamanthaD: I think there are some Haskell bindings for it, but they might not handle the key securely, not sure
05:45:00 <adnap> I'm not sure how zippers would solve my problem more elegantly than a fold.
05:45:18 <haasn> lens is the new ‚Äòstandard zipper library‚Äô
05:45:31 <adnap> Well, here's my problem:
05:45:35 <quchen> Especially the zipper part of Lens.
05:45:37 <edwardk> with 3.10 we're breaking the zippers out into a separate 'zippers' package
05:45:39 <SamanthaD> merijn: Thanks. Now that I know where I stand I can figure out where to go. Much obliged!
05:46:00 <haasn> lens is also the new ‚Äòstandard fold library‚Äô, incidentally
05:46:03 <edwardk> mostly because there is some tension in the design between 3.8 (3.7?) style zippers and the zippers in 3.9
05:46:13 <haasn> edwardk: what changed?
05:46:18 <adnap> I have [(a, a -> [a] -> b)] and I want to produce [b] by applying each a's paired a -> [a] -> b on the a and all the other a's excluding "the a"
05:46:53 <haasn> sounds suspiciously like some sort of comonad
05:46:55 <edwardk> it lets us take better names for the zipper combinators because they don't get exported by default, and it lets us provide both simple (list derivative) and complex (magma-based) zippers
05:47:20 <haasn> doesn't the comonad instance for zipper let you do this? adnap
05:47:26 <Taneb> Geothermal zippers
05:47:51 <adnap> I don't know anything about comonad. I just read the LYAH on zippers; that's all I know
05:48:17 <edwardk> adnap: google for the pointed set comonad. i describe that comonad there
05:48:29 <edwardk> http://comonad.com/reader/2008/the-pointed-set-comonad/
05:48:43 <Taneb> Comonad.com is back up?
05:48:48 <edwardk> Taneb: sort of
05:49:04 <edwardk> if is a dead static mirror, but at least it has 95% of the content
05:49:07 <adnap> Please define "comonad"
05:49:08 <edwardk> er it is a
05:49:36 <Taneb> adnap, "like a monad but backwards" is an awful way of defining one
05:49:45 <edwardk> a monad m is defined by having return :: a -> m a     and (>>=) :: m a -> (a -> m b) -> m b  right with 3 laws.
05:50:15 <edwardk> a comonad w is defined by having extract :: w a -> a    and extend :: (w a -> b) -> w a -> w b with 3 laws
05:50:36 <edwardk> consider (,) e       -- write extract :: (e, a) -> a
05:50:52 <edwardk> and extend :: ((e, a) -> b) -> (e, a) -> (e, b)
05:50:57 <edwardk> both are pretty easy to write
05:51:01 <eikke> anyone familiar with the 'bed-and-breakfast' library?
05:51:20 <adnap> Oh, someone told me about this once regarding some image library
05:52:30 <adnap> How do you get w b from (w a -> b), w a, and (w a -> a) ?
05:53:38 <merijn> adnap: That depends on the comonad
05:54:44 <adnap> extract = snd. extend f c = (,) (fst c) (f c)
05:56:22 <merijn> Is there any tutorial on how to deal with left over data in pipes?
05:57:31 <adnap> I don't know what the hell http://comonad.com/reader/2008/the-pointed-set-comonad/ is talking about. "derivative of a list". "a * [a]" WTF
05:59:36 <hashcat> eikke: I played with it before
06:00:09 * hackagebot standalone-haddock 1.1.2 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.2 (RomanCheplyaka)
06:00:20 <amosr> adnap: I don't know about derivative, but I'm guessing "a*[a]" means "(a, List a)"
06:00:46 <eikke> hashcat: I'm seeing strange/unexpected non-referential-transparency when playing with it in ghci
06:00:53 <datura> adnap: derivative just like in school maths :)
06:01:43 <hashcat> eikke: what's the problem?
06:04:07 <eikke> hashcat: this: https://gist.github.com/NicolasT/4018f796d23e1b5ca53e
06:04:41 <adnap> datura: So, lim h -> 0 ((f(b) - f(a)) / h) ?
06:05:01 <adnap> datura: How does this work for a list, and how is the derivative a cycle?
06:05:05 <exicer> So with this example from lyah: http://lpaste.net/91602 how would you define eg a function that adds two people together  ? (eg just adding the names and age)
06:05:16 <exicer> that expects two peopel
06:06:17 <eikke> exicer: 'adding' as in (add "foo" "bar") == "foobar" ?
06:06:17 <quchen> exicer: First, create the two Persons you want to add.
06:06:26 <datura> adnap: no limes involvedm think symbolic derivation of polynoms.
06:06:28 <exicer> eikke: Yes
06:06:39 <adnap> add (Person f1 l1 a1) (Person f2 l2 a2) = Person (f1 ++ f2) (l1 ++ l2) (a1 + a2)
06:06:41 <exicer> concatenating or whatever
06:06:46 <hashcat> eikke: that's really silly. let me give it a try
06:06:54 <eikke> ^^ what adnap said :)
06:06:55 <hpaste> merijn annotated ‚Äúdata example‚Äù with ‚Äúdata example (annotation)‚Äù at http://lpaste.net/91602#a91603
06:07:01 <exicer> How would the type signature look ?
06:07:11 <eikke> exicer: Person -> Person -> Person
06:07:15 <merijn> exicer: "Person -> Person -> Person"?
06:07:23 <quchen> Pasting the full solution multiple times is always a good way of teaching new things.
06:07:32 <datura> adnap: you are familiar with sum and product types i guess
06:07:32 <exicer> Ahh okayy
06:07:35 <eikke> hashcat: ghc 7.4.2 (F19), fwiw
06:07:44 <arcatan> Badger -> Badger -> Badger -> Badger -> Badger -> Mushroom
06:08:07 <exicer> yeah that actually makes perfect sense. Awesome, thanks!
06:08:52 <adnap> > getProduct . mconcat . map Product $ [1..5]
06:08:53 <lambdabot>   120
06:09:53 <merijn> quchen: To be fair, my full solution was syntactically different!
06:10:27 <haasn> > ala Product foldMap [1..5]
06:10:29 <lambdabot>   120
06:10:39 <adnap> :t ala
06:10:52 <haasn> ala :: Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
06:11:01 <adnap> Lens crap I don't understand
06:11:03 <haasn> the first parameter is ignored, the Wrapped instance is used to wrap/unwrap
06:11:16 <eikke> > ala Sum foldMap [1..5]
06:11:18 <lambdabot>   15
06:11:40 <eikke> how does it find out about getSum?
06:11:51 <edwardk> eikke: the Wrapped instance
06:12:08 <haasn> > getProduct $ [1..5]^.wrapped
06:12:09 <eikke> ah, right, missed that part
06:12:10 <lambdabot>   [1,2,3,4,5]
06:12:13 <haasn> oh
06:12:46 <haasn> > getProduct $ [1..5]^.traverse.wrapped
06:12:47 <eikke> not sure whether to call this clever or evil :)
06:12:47 <lambdabot>   120
06:13:09 <edwardk> > au (iso Product getProduct) foldMap [1..5]
06:13:10 <lambdabot>   120
06:13:18 <adnap> If a zipper definition depends on the underlying data structure, does that mean that the "zipper comonad"'s definition of extract and extend do as well?
06:13:36 <ocharles> ala auf and au look like something I probably use a lot but write myself
06:13:39 <edwardk> wrapping Product = iso Product getProduct
06:13:42 <ocharles> must keep them in mind
06:14:40 <edwardk> adnap: there is no actual zipper comonad instance lying around. some zippers admit one though.
06:14:58 <edwardk> the notion that a zipper forms a comonad is more of a formal thing formalized by uustalu and others
06:15:55 <hashcat> eikke: I find det return different values
06:15:56 <adnap> But a zipper doesn't have a single definition, right? How can you say "zipper forms a comonad" in general?
06:16:12 <exicer> Generally, when should you use foldl vs foldr?
06:16:28 <eikke> hashcat: thing is, the first thing it returns (60) isnt even the correct answer, by far
06:16:40 <merijn> exicer: foldl never, foldl' if you're reducing to a single value, foldr if you need to work with infinite lists
06:16:46 <edwardk> e.g. in the list zipper the comonad is data Zipper a = Zipper [a] a [a] -- which is more or less equivalent to Store Int a -- if you realize that the left [a] is actually data and not codata and so must have finite length if this is a real zipper
06:16:52 <hashcat> eikke: I just try det many times. even silly more here
06:16:59 <exicer> I've not seen foldl' before
06:17:07 <haasn> edwardk: with some Zipper, there's no way to traverse over the entire current level, is there?
06:17:19 <merijn> exicer: foldl' is just foldl, but strict in the combination function
06:17:29 <eikke> guess I won't be using bed-and-breakfast in my code :P
06:17:30 <edwardk> adnap: you can show that for every polynomial data type 't' there exists a construction. that is uustalu's result. it doesn't result in a Comonad with a capital C instance though.
06:17:38 <haasn> edwardk: eg. :: IndexedTraversal' i (Zipper h i a) a
06:17:41 <adnap> :t extend
06:17:42 <lambdabot> Not in scope: `extend'
06:17:45 <edwardk> haasn: go up a level and use the traversal
06:17:47 <exicer> merijn: Uhh, what does that mean ?
06:17:53 <edwardk> and then come back down in
06:17:59 <haasn> edwardk: yeah but what if I don't know the traversal that was used to go into the current level?
06:18:02 <merijn> > foldl f z [a,b,c]
06:18:03 <lambdabot>   f (f (f z a) b) c
06:18:08 <adnap> What is a "polynomial data type"?
06:18:11 <quchen> extend :: Comonad w => (w a -> b) -> w a -> w b -- adnap
06:18:19 <hashcat> eikke: "det $ fromList [[1,2],[3,4]]" returns 4646340147544064 at first time
06:18:24 <merijn> exicer: Basically, "f z a" and "f (f z a) b" are not evaluated
06:18:36 <merijn> exicer: So you end up with a huge stack of unevaluated computations
06:18:37 <haasn> edwardk: it seems like it should be possible to provide a (possibly not legal) implementation of duplicate' with this
06:18:42 <eikke> hashcat: ah, didnt try it that way. that's painful
06:18:43 <merijn> exicer: Possibly causing an overflow
06:18:57 <exicer> I'm sorry - I don't quite see why they are not evaluated
06:18:58 <edwardk> then you're out of luck. you can writ some combinator to move left until you can't move left any more, count how many steps you took, move left to right through it and then go back home, like sliding the head of an old-school typewriter, but i didn't write it
06:19:00 <merijn> exicer: foldl immediately reduces "f z a" to a single values, before doing the rest
06:19:02 <amosr> adnap: so list a is "data List a = Nil | Cons a (List a)", which you can write as "List a = () + (a * List a)"
06:19:12 <merijn> exicer: Well, they're evaluated, the question is *when*
06:19:12 <edwardk> you can't change out the types in the traversal
06:19:30 <exicer> Hmm - I don't suppose there is any way I can see this ?
06:19:32 <haasn> ah
06:19:37 <hashcat> eikke: and then ghci suddenly shutdown
06:20:02 <adnap> extend f (Zipper bs x es) = f bs ++ f [x] ++ f es ?
06:20:14 <adnap> Oops
06:20:18 <edwardk> adnap: a polynomial data type is made up out of void (0) sums (+ / Either) , products (*/ (,)) , variables (a) and units (1, ())
06:20:18 <haasn> yeah that makes sense, it'd be impossible to update the type if the parent traversal is something monomorphic, even if you could traverse the entire current level at once
06:20:23 <hashcat> eikke: I'll take a look at source later. bye
06:20:24 <eikke> hashcat: it's strange. I looked up the implementation, and although I didnt check the algorithm is correct, it doesnt seem to *do* anything fishy
06:20:30 <haasn> eg. fromWithin bits
06:20:37 <edwardk> adnap: 1 + 1 ~ Either () ()  ~ data Foo = Quux | Quaffle
06:21:08 <adnap> extend f (Zipper bs x es) = Zipper (f bs) (head . f $ [x]) (f es) ?
06:21:25 <merijn> exicer: Let's say we have "foldl (+) 0 [1,2,3]" then we get "foldl (+) (0 + 1) [2,3]" -> "foldl (+) ((0 + 1) + 2) [3]" -> "foldl (+) (((0 + 1) + 2) + 3) []" -> "(((0 + 1) + 2) + 3)" -> sum, etc.
06:21:30 <adnap> No
06:21:33 <edwardk> adnap: f needs a whole zipper
06:21:45 <hashcat> eikke: It's possible to have side effect without monad by unsafe operation
06:21:50 <edwardk> it is much easier to write extend for the Store Int version of the zipper
06:22:00 <adnap> I don't know what a Store is
06:22:02 <hashcat> eikke: I have to go now bye
06:22:03 <exicer> merijn: Yes, okay.
06:22:05 <edwardk> data Store s a = Store (s -> a) s
06:22:13 <adnap> I'm so lost. There are like 5 things I don't understand right now
06:22:15 <edwardk> extract (Store f s) = f s
06:22:26 <edwardk> adnap: keep track of a list and work through them
06:22:31 <merijn> exicer: In case of foldl' we get "foldl' (+) 0 [1,2,3]" -> "foldl' (+) (0 + 1) [2,3]" -> "foldl' (+) 1 [2,3]" -> "foldl' (+) (1 + 2) [3]" -> "foldl' (+) 3 [3]"
06:22:39 <merijn> exicer: See the difference?
06:22:52 <haasn> edwardk: what about exponents (^, ->) ?
06:23:15 <edwardk> haasn: those would be 'exponential' not 'polynomial'
06:23:21 <edwardk> adnap: http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
06:23:23 <edwardk> start there
06:23:29 <eikke> hashcat: thanks :) bye
06:23:34 <exicer> merijn: Ohh, yes yes
06:23:38 <eikke> (and I'm aware you can use unsafe*, but the code doesnt)
06:23:52 <exicer> merijn: Okay, so why does the non-strict foldl even exist ?
06:23:58 <merijn> exicer: As a result foldl will consume massive amounts of space for long lists, whereas foldl' doesn't
06:24:06 <merijn> exicer: Because laziness is the haskell default
06:24:24 <adnap> edwardk: I didn't understand your definition of polynomial data type. What is a "void"? What is a "sums"? I don't understand any of those things
06:24:31 <exicer> Right, makes sense
06:24:35 <exicer> Okay thanks!
06:24:44 <adnap> I will start reading this blog post
06:25:39 <edwardk> adnap: we make up data types in haskell using data types like data Foo a = Bar a (Foo a) | Quux | Quaffle   right?
06:25:53 <adnap> edwardk: Yeah
06:25:55 <edwardk> replace | with +   and multiple fields with * and you get something like an equation.
06:26:09 <edwardk> Foo a = (a * Foo a) + 1 + 1
06:26:44 <adnap> edwardk: Why would you do that?
06:26:59 <edwardk> we can reason about these in ways you would expect. Bool = 2, Either () () = 1 + 1 = 2   so Bool and Either () () are interchangeable
06:27:20 <haasn> the interpretation that helps me understand this is to think of how many values a data type has; () has only one, (), thus making its size ‚Äò1‚Äô; Void has none, thus it is 0.  (x, y) has one for every combination of ‚Äòx‚Äô and ‚Äòy‚Äô, or x*y
06:27:31 <haasn> and Either x y has all of x and all of y, or x+y
06:27:42 <haasn> (all of this is ignoring ‚ä•)
06:27:55 <adnap> A Quux is a 1?
06:28:04 <sclv> yep
06:28:05 <edwardk> (a,a) = a*a     and we can know that x -> a  = a^x, so Bool -> a = a^2 is isomorphic to (a,a)
06:28:08 <adnap> This is weird
06:28:33 <sclv> its very powerful once you get used to it
06:28:38 <adnap> Either () () = Left () | Right ()
06:28:46 <adnap> How is Left () a 1?
06:28:49 <FreeFull> And you differentiate to get a zipper
06:28:53 <sclv> () is the same as Quux
06:29:05 <sclv> its a 1, right
06:29:10 <edwardk> () = 1
06:29:13 <adnap> But
06:29:19 <adnap> Then it would be Left 1, right?
06:29:22 <haasn> (x -> a) = a^x has some other interesting interpretations, first of all we know that x^2 eg. is x*x, x^3 = x*x*x; so in general x^n is an n-tuple of x's. for something like ‚ÄúBool -> Int‚Äù we can see that this is equivalent to two Ints, with either being returned depending on whether you pass True or False
06:29:23 <adnap> Like a * Foo a
06:29:43 <adnap> Not a * a
06:29:48 <sclv> but how many inhabitants have a Left constructor and then a value of type () ?
06:29:52 <sclv> Only one!
06:30:03 <edwardk> adnap: here i've pulled a dirtyish trick on you and actually substituted in the contents using rules i haven't explaine
06:30:04 <adnap> What is an "inhabitant"?
06:30:06 <edwardk> er explained
06:30:19 <sclv> inhabitant is the same as "distinct value of the proper type"
06:30:22 <edwardk> adnap: values can you write that have that type
06:30:29 <edwardk> er values you can write that have that type
06:30:45 <edwardk> Either () ()  -- has two inhabitants Left ()  and Right ()
06:30:46 <tikhon> () is a little confusing: the type () has one inhabitant which is also written as ()
06:30:47 <Work_jack> adnap: 'a' is an inhabitant of Char
06:30:49 <edwardk> Bool has two inhabitants True and False
06:30:58 <tikhon> for this discussion, it would probably help to explicitly differentiate between the type () and the value ()
06:31:02 <edwardk> () has one inhabitant (), hence () = 1
06:31:25 <haasn> tikhon: I propose calling the type 1 ;-)
06:31:27 <sclv> so if you think of Either as the "+" operator you can see that Either Bool Bool = 2 + 2
06:31:51 <danr> similarly, (,) is multiplication and (->) exponentiation
06:32:03 <adnap> Either is not +. edwardk said | is +
06:32:04 <edwardk> [a] = 1 + a * (1 + a * (‚Ä¶))
06:32:13 <sclv> because you can have (Left True or Left False, i.e. 2) OR (Right True or Right False, i.e. 2)
06:32:15 <tikhon> adnap: either is like | reified as a type
06:32:20 <haasn> Either Bool Bool has four possibilities, Left False, Left True; Right False, Right True -- 2 on each side, hence 2 + 2 = 4
06:32:24 <adnap> What does "reified" mean?
06:32:31 <sclv> so you sum the possibilities that go into Left with the ones that go into Right
06:32:32 <edwardk> adnap: Either a b = Left a | Right b  -- it has no structure other than the (|) to it
06:32:32 <tikhon> embodied
06:32:36 <exicer> Is it generally ok to define a "wrapper" function if you want to curry (this might be the wrong term) on the second argument ?
06:32:48 <exicer> Uh, I mean not on the last argument
06:33:25 <sclv> "reify" comes for the latin "res" for "thing"
06:33:32 <sclv> so it means "thingified" or "made into a think"
06:33:36 <sclv> "a thing" rather
06:33:48 <sclv> a think made into a thing!
06:33:57 <danr> sclv: oh that's nice
06:34:05 <merijn> reify means "to make unabstract"
06:34:09 <adnap> 08:28 < edwardk> (a,a) = a*a     and we can know that x -> a  = a^x, so Bool -> a = a^2 is  isomorphic to (a,a)
06:34:26 <adnap> How do you know that "x -> a = a^x"?
06:34:30 <haasn> adnap: If we only have (,) and Either and no way to make our own versions of these, we could still define every data type: data List a = Either () (a, List a)   -- contrast data List a = Nil | Cons a (List a)
06:34:31 <merijn> Or "to make concrete"
06:34:49 <tikhon> adnap: count the number of possible functions for that type
06:35:04 <tikhon> for example, how many functions () ‚Üí () are there?
06:35:13 <adnap> 1
06:35:16 <tikhon> right
06:35:22 <tikhon> and what about () ‚Üí Bool?
06:35:32 <edwardk> adnap: how many distinguishable 'a's  are there in (Bool -> a)?  you can apply the function to False or to True, giving you an a each time, but thats it.
06:35:35 <donri> haasn: ok now use that to define () and Void ;)
06:36:08 <edwardk> this pattern holds in general. if there are 3 inhabitants of Foo and you have (Foo -> a) then you get 3 as out, a*a*a
06:36:16 <b2coutts_> why do data constructors begin with a capital letter? is there really any difference between them and regular functions?
06:36:28 <tikhon> b2coutts_: you can pattern match on them
06:36:32 <b2coutts_> ah, right
06:36:34 <edwardk> b2coutts_: pattern matching
06:36:42 <haasn> adnap: a function always has the same output for the same input, so if there are only n possible input values, there can only be n possible output values
06:36:46 <adnap> edwardk: What if the value of the a's are the same? Does that matter?
06:37:11 <edwardk> doesn't matter for the sake of this discussion
06:37:16 <adnap> f True = (), f False = ()
06:37:31 <adnap> f True = 1, f False = 1
06:37:38 <adnap> f True = 5, f False = 5
06:37:40 <edwardk> there are interesting equations you can write when you restrict them to be distinguishable, all sorts of fun math gets involved
06:38:12 <haasn> edwardk: like unordered pairs?
06:38:13 <edwardk> adnap: the point is that 'in general' you can store 2 a's worth of information in (Bool -> a)
06:38:26 <adnap> Okay
06:38:45 <haasn> donri: ah, I meant to assume we have ()/Void and also (->) as well
06:38:48 <adnap> so a^x
06:38:54 <adnap> I get it
06:39:14 <donri> haasn: i know; teasing ;)
06:39:18 <edwardk> this notion of polynomial data types is just convenient to work with because it lets you track 'how much information' is described by a data type (in the finite case)
06:39:31 <haasn> it gets interesting for infinite types; eg. a ^ Nat -- as in Nat -> a; is equivalent to an infinite number of ‚Äòa‚Äôs, or a never-ending list
06:39:33 <haasn> as in Stream a
06:40:00 <edwardk> adnap: in http://comonad.com/reader/2008/generatingfunctorology/ I talk a bit about it in the recursive setting
06:40:40 <haasn> how long until we get to T^7 = T ?
06:40:43 <adnap> Okay
06:41:09 <edwardk> haasn: you need to be careful when extending to infinite types because the generating function no longer fully describes the behavior
06:41:10 <adnap> edwardk: I never see anyone talking like you in here. It seems like what you are saying is nonsense at first
06:41:21 <edwardk> adnap: usually it is ;)
06:41:48 <haasn> edwardk: how so?
06:43:11 <adnap> Maybe x = 1 + x because Maybe x = Nothing | Just x = 1 + x
06:43:32 <edwardk> haasn: well consider a list. you can view a list as exists n : Conat. (a^n) -- where Conat is the one point compactification of the natural numbers. (it adds an extra infinity, but you can't distinguish infinity from any other nat in finite time)  but the generating function only describes the behavior of the container for finite numbers of 'a's
06:43:32 <adnap> So this is a "polynomial functor"
06:43:33 <haasn> adnap: yes
06:43:38 <edwardk> adnap: exactly
06:43:48 <adnap> No one says "polynomial functor"!
06:43:51 <adnap> This is weird!
06:44:03 <adnap> I never hear anyone talking about polynomial functors in here
06:44:22 <adnap> It almost sounds like nonsense unless you know of this type to polynomial scheme
06:44:43 <FreeFull> What about [a]?
06:44:49 <edwardk> haasn: data Foo a = Foo a (Foo a)   and data Bar a = Bar a (Bar a) (Bar a)  both have a generating function that is 0 for all finite numbers of as, but have different structures.
06:44:58 <adnap> FreeFull: Infinite?
06:45:00 <edwardk> FreeFull: [a] = 1 + a * [a]
06:45:47 <edwardk> which is the formal power series for [a] = 1 / (1 - a)
06:45:50 <haasn> edwardk: (aren't Foo and Bar isomorphic?)
06:46:00 <adnap> List a = Empty | Cons a (List a)
06:46:02 <edwardk> [a] = 1 + a + a^2 + ...
06:46:09 <adnap> 1 + a * [a]
06:46:27 <edwardk> there is exactly one way to represent any given number of a's in a list.
06:46:31 <edwardk> compare with trees
06:47:04 <edwardk> when you work out Tree a = 1 + a * (Tree a) * (Tree a)  -- you can work out the coefficients for each 'a^x' for a generating function
06:47:11 <edwardk> 1 + x + 2x^2 + 5x^3 + 14x^4 + 42x^5 + ...
06:47:19 <edwardk> the different coefficients are the catalan numbers
06:47:40 <edwardk> @oeis 1, 2, 5, 14, 42
06:47:42 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
06:48:01 <haasn> I prefer ‚Äòcat numbers‚Äô
06:48:21 <utterglee_> zomg and Apocalisp are my favorite names in the room
06:48:32 <edwardk> C(n) represents the number of ways to shape a binary tree with n leaves.
06:48:54 <Apocalisp> Thanks, utterglee_, we aim to please.
06:49:26 <utterglee_> :) :)
06:49:40 <FreeFull> > recSeq 10 sum [1..10]
06:49:41 <lambdabot>   Not in scope: `recSeq'
06:49:41 <lambdabot>  Perhaps you meant `recSec' (line 150)
06:49:49 <FreeFull> > recSec 10 sum [1..10]
06:49:52 <lambdabot>   mueval-core: Time limit exceeded
06:50:04 <haasn> :t recSec
06:50:05 <lambdabot> Int -> ([a] -> a) -> [a] -> [a]
06:50:08 <FreeFull> recSec probably needs to be optimised
06:50:21 <edwardk> adnap: the nice thing about reasoning about this stuff in polynomial form is it lets you kind of quotient out a lot of implementation details in your head
06:50:25 <FreeFull> > recSec 2 sum [0,1[
06:50:26 <FreeFull> > recSec 2 sum [0,1]
06:50:26 <lambdabot>   <hint>:1:19:
06:50:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
06:50:30 <lambdabot>   mueval-core: Time limit exceeded
06:50:37 <FreeFull> > recSec 2 sum [0,1]
06:50:41 <lambdabot>   mueval-core: Time limit exceeded
06:50:44 <FreeFull> > 3
06:50:45 <lambdabot>   3
06:50:52 <FreeFull> > take 4 $ recSec 2 sum [0,1]
06:50:56 <lambdabot>   [0,1,1,2]
06:51:15 <haasn> lambdabot really needs to stop evaluating more than it can display in #haskell
06:51:21 <haasn> unless you message it privately
06:52:21 <adnap> edwardk: What do you mean by "quotient out"?
06:52:52 <edwardk> adnap: i mean you can ignore a lot of the concerns of how you chose to represent the structure, what your constructors were named, etc.
06:52:59 <adnap> The only useful thing I understood is determining the "information capacity" of a type
06:53:08 <adnap> edwardk: Oh
06:53:09 <xiaq> Hi, is there a Haskell equivalent to http://www.4clojure.com/ ?
06:53:30 <haasn> well, the fact that every polynomial data type can be reduced to combinations of these forms means you can recursively prove things about them
06:53:43 <edwardk> there is a more formal way to describe that. you can talk about quotient types, but i used it informally
06:53:50 <haasn> eg. the existence of a zipper (and even how to create them automatically)
06:53:59 <merijn> xiaq: Not really, but try these
06:54:02 <merijn> @where exercises
06:54:02 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
06:54:03 <adnap> "recursively prove things"...
06:54:10 <haasn> inductively I mean
06:54:18 <adnap> Oh
06:54:41 <adnap> O
06:54:44 <haasn> iirc epigram essentially does this in order to auto-derive zippers for your data types
06:54:44 <adnap> I'm reading http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
06:55:11 <adnap> I abandoned http://comonad.com/reader/2008/the-pointed-set-comonad/
06:55:14 <edwardk> basically a quotient type is where you take some equivalent relationship and make sure you can't distinguish between elements that are the same under the equivalence relationship
06:55:38 <xiaq> merijn: ah ok. knew these before, not as fun as 4clojure... :-|
06:55:40 <edwardk> er equivalence
06:56:07 <adnap> That didn't really make any sense. It was vague
06:56:29 <edwardk> http://www.inf.ed.ac.uk/publications/online/0046/b191.pdf
06:56:37 <Work_jack> What's the best free blog service that gives you decent markup?
06:56:38 <roconnor> hmm, edwardk has a different colour on my client than normal. ... imposter perhaps?
06:56:44 <roconnor> :P
06:57:04 <edwardk> my goal was to try to give intuition. figuring you can google the formal definitions
06:57:04 <xiaq> Work_jack: github.io? ;)
06:57:08 <Work_jack> heh
06:57:09 <benzrf> making monad instances for things that aren't really monads so that you can use do notation for dsls is ok, right?
06:57:13 <edwardk> roconnor: =P
06:57:22 <edwardk> you've found me out
06:57:24 <roconnor> benzrf: nope
06:57:29 <benzrf> roconnor: huh
06:57:35 <adnap> roconnor: Do you use nickcolor.pl?
06:57:36 <benzrf> what do you recommend, then
06:57:42 <adnap> roconnor: Are you using irssi?
06:57:45 <roconnor> benzrf: making it a monad
06:57:54 <benzrf> erm... explain?
06:58:05 * Clint claps.
06:58:30 <applicative> benzrf: people like roconnor are certain to sneer at it ;)
06:58:34 <benzrf> hmm
06:58:40 <benzrf> what about things like hakyll
06:58:48 <applicative> benzrf: the important package that does this is blaze
06:58:58 <benzrf> hmm
06:59:01 <applicative> benzrf: right, he decided not to listen to roconnor
06:59:03 <roconnor> benzrf: I don't know exactly what your data type is, but if you are using do notation it probably isn't far from being a proper monad.  Just make it a proper one.
06:59:20 <applicative> benzrf: this decision against roconnor was also correct.
06:59:28 <roconnor> benzrf: for example, codensity will turn any functor into a monad.
06:59:49 <roconnor> IIRC
07:00:03 <Hugh_> hi - in the hackage docs what does 'Subject to fusion' mean
07:00:10 <Hugh_> eg: O(1) Tests whether a Text is empty or not. Subject to fusion.
07:00:11 <applicative> goodness
07:00:27 <applicative> Hugh_: if you compose two things subject to fusion they fuse
07:00:27 <Hugh_> Data.Text.null
07:00:42 <tikhon> Hugh_: if you use a bunch of functions like that in a row, they might get combined into one pass
07:00:43 <applicative> god willing
07:00:49 <applicative> and the intermediate text or vector is not built
07:00:53 <roconnor> benzrf: also, you could use rebindable syntax to use do notation and not have to lie about you having a monad.
07:00:56 <Work_jack> Hugh_: It means it may fuse intermediate values away
07:01:08 <Hugh_> so it is the '.' operator such that f.(g.h) == (f.g).h
07:01:08 <roconnor> benzrf: not as good as making a proper monad, but acceptable.
07:01:16 <quchen> Hugh_: `map f . map g   ===>   map (f . g)` is a classical example of fusion. The first one requires two passes over the list (one for each map), the second one just one.
07:01:16 <benzrf> roconnor: uhhh
07:01:22 <benzrf> roconnor: what is rebindable syntax?
07:01:32 <roconnor> benzrf: it's a GHC extention, ... let me find it
07:01:41 <tikhon> benzrf: a syntax extension that lets you change what if/then/else desugars to
07:01:42 <applicative> benzrf: hakyll is a dsl and is basically a complaint that you have to use the extremely dangerous rebindable syntax
07:01:48 <Hugh_> got it. Thanks
07:02:03 <p_l> is there any way to force Cabal to pass certain flags to everything it compiles? (namely to compile everything with -fPIC when passing to GCC)
07:02:13 <applicative> if you want to avoid the illusory dangers of just declaring it a monad even though foo () is all thats constructable
07:02:18 <merijn> p_l: Yes, lemme check
07:02:30 <exicer> Are there any plotting/graphing libraries in Haskell that anyone could recommend ?
07:02:43 <tikhon> if you don't need anything fancy, I like "chart"
07:02:56 <applicative> RebindableSyntax lets you use do notation using whatever (>>) and (>>=) are in scope
07:03:04 <tikhon> http://hackage.haskell.org/package/Chart
07:03:12 <merijn> p_l: Wait, do you mean on the command line or in your cabal file?
07:03:16 <Tinned_Tuna> I would've thought that re-using the do-notation for non-monadic things would cause Very Bad Things to happen
07:03:16 <benzrf> applicative: you can rebind them?
07:03:17 <applicative> it makes fake monad instances look safe
07:03:21 <tikhon> I use it whenever I just want to throw some data up and don't care about exactly how it'll look
07:03:22 <p_l> merijn: in ~/.cabal/config
07:03:30 <exicer> tikhon: And when you do care about how it looks ?
07:03:45 <tikhon> loaded question: I never care about how it looks :P
07:03:45 <roconnor> benzrf: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html#rebindable-syntax
07:03:46 <Tinned_Tuna> e.g. if whatever it is you're pretending is a monad doesn't satisfy the monad laws, and GHC uses the Monad laws to make an optimisation, you're in trouble
07:03:48 <applicative> benzrf: yes, do {let (>>) = (++); "hello"; "world"}
07:03:50 <exicer> I'm assuming I'll have to just use matplotlib or something in python
07:03:54 <benzrf> oh, ok
07:03:58 <roconnor> benzrf: but just fixing your data type so it is a proper monad is better.
07:03:58 <exicer> Haha, fair enough : p
07:04:02 <luite> Chart is also getting some major updates this summer (GSoC) to make base it on diagrams, so it will be easier to install and probably more flexible
07:04:02 <applicative> benzrf: will be "worldworldworld.."
07:04:02 <tikhon> I've only ever needed charts for my own consumption
07:04:06 <Tinned_Tuna> or am I misunderstanding ?
07:04:07 <merijn> p_l: hmm, I dunno then
07:04:14 <tikhon> there are bindings for gnuplot as well
07:04:22 <exicer> tikhon: Ah, awesome.
07:04:23 <tikhon> http://hackage.haskell.org/package/gnuplot
07:05:01 <roconnor> Tinned_Tuna: I can't imagine GHC optimizing using the monad laws when you have rebound the do notation to some other function.
07:05:11 <p_l> ok, nuking whole haskell ecosystem on my machine and reinstalling because GHC can't link anything...
07:05:21 * hackagebot FunGEn 0.4.1 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4.1 (SimonMichael)
07:05:46 <tikhon> is anyone planning to do the ICFP contest thing?
07:06:08 <quchen> I don't think GHC uses the Monad laws.
07:06:13 <Tinned_Tuna> roconnor: I was assuming the case of rebound the notation, I was assuming the case where you declare a non-monadic structure to be a monad through instance Monad ...
07:06:36 <Tinned_Tuna> quchen: so you're safe, right up until someone tells a compiler to use the monad laws?
07:06:41 <applicative> Tinned_Tuna: no, thats when you dont rebind >> and >>= but pretend you have a good Monad instance instead
07:06:44 <roconnor> Tinned_Tuna: yes, that would be bad.  GHC still probably won't screw around with it, but I don't think it is good to count on it.
07:06:56 <applicative> roconnor is surely right
07:07:09 <applicative> the trouble is that RebindableSyntax is no good
07:07:22 <quchen> Tinned_Tuna: It probably won't for some time.
07:07:41 <quchen> Tinned_Tuna: The problem is that Haskell doesn't enforce the Monad laws, it just recommends them.
07:07:45 <roconnor> benzrf: at the very very least, you likely can to turn your DSL into a free monad (unless you have some crazy callback-like primitives) and then write an interpreter to do whatever you want to your dsl.
07:07:49 <tikhon> RebindableSyntax is a poor compromise for not having macros
07:07:54 <Tinned_Tuna> quchen: unfortunately, for software in production, "some time" comes sooner than you expect ;-)
07:07:57 <benzrf> ~_~
07:08:00 <applicative> some frequent users of this channel can give completely devastating illustrations of the depravity of RebindableSyntax
07:08:03 <benzrf> I don't know what that means, roconnor
07:08:04 <Tinned_Tuna> but right after everyone's forgotten about it.
07:08:06 <benzrf> I'm pretty new
07:08:28 <applicative> roconnor: the one important case cannot even be made a functor
07:08:40 <roconnor> benzrf: a, free monad is basically a tree where each node of the tree is a command and then you have a branch for every possible result of said command.
07:08:49 <augur> has anyone ever done any statistics on haskell source code?
07:09:18 <FreeFull> You know, swapping true and false isn't as easy in Haskell as in other languages
07:09:25 <roconnor> applicative: oh, did I miss the description of the DSL?
07:09:26 <quchen> Tinned_Tuna: I'm not sure what the future might bring here. Applicative => Monad would allow pretty good new optimizations (such as rewriting liftM to fmap) for example. On the other hand, it's questionable whether that is ever implemented, because stupid baggage.
07:09:28 <FreeFull> Due to pattern matching
07:09:45 <quchen> Tinned_Tuna: The rewriting, that is, not Applicative => Monad. :-)
07:09:58 <tikhon> at least all our new code can look better
07:10:06 <roconnor> benzrf: then you also have a Leaf :: a -> MyTree a constructor that is used for return.
07:10:21 <Tinned_Tuna> quchen: that's assuming that GHC is always the only compiler on the block. There could always be a challenger in much the same way that clang challenged gcc :-)
07:10:35 <applicative> roconnor: here is the 'functor' and 'monad' http://hackage.haskell.org/packages/archive/blaze-markup/0.5.1.5/doc/html/Text-Blaze-Internal.html
07:10:41 <applicative> MarkdownM
07:10:47 <Tinned_Tuna> and it could hinge on the improvements allowed by exploiting various assumed laws.
07:10:57 <Fernandos> Tinned_Tuna: openbsd consideres changing to clang
07:11:05 <quchen> Tinned_Tuna: Even a new competitor would need to implement things like that in order to compile as much of Hackage as possible.
07:11:08 <roconnor> oh good, let me look
07:11:10 <Tinned_Tuna> Fernandos: I know ^.^
07:11:17 <applicative> the exported constructors only permit the construction of MarkdownM () though with the monad instance you can of course get around this
07:11:29 <applicative> and the functor instance for that matter
07:11:47 <roconnor> applicative: by Markup do you mean Markdown?
07:12:02 <roconnor> er
07:12:09 <roconnor> by Markdown you mean Markup?
07:12:13 <Tinned_Tuna> quchen: you never know, Debian is using clang to tell off their package maintainers -- they've been recompiling their entire package repository with clang and harassing any developers whose build fails in clang and not gcc for silly reasons (e.g. -O99)
07:12:28 <applicative> roconnor: the fundamental type hakyll is using is http://hackage.haskell.org/packages/archive/blaze-markup/0.5.1.5/doc/html/Text-Blaze-Internal.html#t:MarkupM
07:12:50 <roconnor> return _ = empty -- oh god
07:12:56 <applicative> indeed
07:13:09 <applicative> roconnor: but the purpose, if I understand is just to have a monoidal do
07:13:27 <applicative> which should be given us with "do monoid; ..."
07:13:31 <quchen> Tinned_Tuna: I like to be one of those people that stand by and laugh "should've done it right the first time". In that sense, I don't have to know. :-P
07:13:50 <applicative> it is a complete waste of time that do notation is fused to monads
07:14:05 <tikhon> eh
07:14:28 <quchen> Tinned_Tuna: If you can't rewrite code you've written with `liftM -> fmap` and `ap -> <*>` your code is crap. Avoid crap.
07:14:34 <tikhon> I think the solution would be to have some method of introducing new syntax as a library, and taking do-notation out of the language itself
07:14:39 <roconnor> applicative: rebindable syntax isn't appropriate because this is meant to be used by a library user?
07:14:54 <applicative> yes its for the dsl
07:14:56 <augur> edwardk: we should do some statistical analysis of haskell programs
07:15:07 <edwardk> augur: for?
07:15:10 <applicative> I think you are not registering how EXTREMELY DANGEROUS rebindablesyntax is
07:15:35 <applicative> it makes fraudulent monad instances look very good
07:15:55 <quchen> applicative: Got any pathological examples?
07:16:12 <applicative> quchen: i think mauke is the master of them
07:16:40 <haasn> I think I would be fine with an imposter Monad instance if the laws only hold up to isomorphism, but I haven't really thought about it much
07:17:15 <augur> edwardk: to find the most common code patterns, and see if any good optimizations could be designed
07:17:19 <mr-> yay, 2-monads :-)
07:17:20 <applicative> the most twisted involve do { (<<) <- x; y; (=<<) <- w; a <- q; f a}
07:17:39 <Tinned_Tuna> applicative: holy what the
07:17:41 <applicative> in which the succession of lines are an incoherent melange of interpretaions
07:17:42 <edwardk> augur: knock yourself out ;)
07:17:51 <augur> edwardk: this reddit thread on the `sum [1..1000000000]` got me thinking
07:17:53 <quchen> applicative: Reminds me of those ASM self-modifying programs.
07:17:53 <applicative> Tinned_Tuna: yes, dont listen to monad instance lunatics
07:18:03 <edwardk> sum should really be built with foldl'
07:18:04 <augur> someone asked if it makes sense for ghc to not optimize such a common pattern
07:18:12 <Work_jack> edwardk: Why isn't it?
07:18:15 <roconnor> okay, so MarkupM is a monstrosity.  If you really want a monad, you should make a Writer Monad out of this monad.  Then you can wrap all your primitives with tell.
07:18:16 <augur> edwardk: yeah well, the example actually does
07:18:17 <applicative> quchen: the answer is a bunch of do's
07:18:18 <augur> but its still slow
07:18:32 <edwardk> Work_jack: because you might have a lazy nat type where the current definition is the right one
07:18:32 <quchen> edwardk: Well, sum is for any Num, so the seq would be weird there. Maybe a sum' would be useful.
07:18:47 <quchen> Or make it sum/genericSum
07:18:47 <augur> but i thought to myself, is that REALLY a common pattern?
07:18:52 <edwardk> Work_jack: in practice that is the exception, not the rule
07:18:53 <roconnor> oh, benzrf left ...
07:18:56 <applicative> roconnor: this guy knows 10000 times as much about optimization as either of us will ever know
07:19:12 <haasn> applicative: especially when you start getting things like _ <- f  /=  f
07:19:12 <applicative> the construction of a sort of writer monad is actually part of the purpose.
07:19:13 <Work_jack> Exactly, something like sum' seems like a reasonable solution
07:19:23 <edwardk> Work_jack: sure
07:19:31 <Tinned_Tuna> hmm, maybe running such a large sum was a bad idea...
07:19:42 <roconnor> applicative: benzrf?
07:19:43 <edwardk> :t sumOf
07:19:44 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
07:19:45 <applicative> roconnor: it's just moralism, the objections; the solution is an alteration of the language
07:19:56 <applicative> roconnor: jaspervdj
07:20:02 <edwardk> that one is implemented via the foldl' equivalent
07:20:02 <edwardk> > sum [1..100000]
07:20:04 <lambdabot>   5000050000
07:20:07 <edwardk> > sumOf folded [1..100000]
07:20:09 <lambdabot>   5000050000
07:20:13 <roconnor> applicative: I thought we were talking about benzrf's DSL.
07:20:13 <applicative> roconnor: and s meier
07:20:16 <edwardk> > sumOf folded [1..1000000]
07:20:18 <lambdabot>   500000500000
07:20:19 <edwardk> > sumOf folded [1..10000000]
07:20:23 <lambdabot>   mueval-core: Time limit exceeded
07:20:28 <edwardk> > sum [1..1000000]
07:20:30 <lambdabot>   *Exception: stack overflow
07:20:38 <applicative> roconnor: benzrf 's dsl was the hakyll one which is built on this nonsense
07:20:51 <roconnor> oh
07:21:07 <haasn> I don't actually get a stack overflow when running ‚Äúsum [1..1000000]‚Äù (even if I add 1-2 more 0's) on my local GHCi instance. What gives?
07:21:18 <ocharles> Woohoo, my FRP Haskell asteroids clone is almost finished!
07:21:18 <haasn> oh, I do now
07:21:29 <haasn> guess my stack was just significantly larger
07:21:32 <ocharles> Now it has scoring, ship destruction, and it restarts when the screen is cleared
07:21:49 <p_l> what would be needed to make GHC compile everything with -fPIC?
07:22:05 <haasn> edwardk: it's scary when ‚ÄúsumOf folded‚Äù actually runs faster on my machine than ‚Äúsum‚Äù
07:22:16 <ocharles> haasn: sum has a space leak, iirc
07:22:20 <edwardk> haasn: lens aims to please ;)
07:22:25 <quchen> :-P
07:22:34 <roconnor> applicative: why do they want to use do notation? What's wrong with <> ?
07:22:52 <Tinned_Tuna> p_l: it seems that no one in here knows the answer to that question.
07:23:08 <quchen> {-# RULES forall xs. sum xs = sumOf folded xs #-}  --  Put that in Lens :-D
07:23:17 <edwardk> hah
07:23:28 <Tinned_Tuna> p_l: have you tried a longer running q/a format, like stack overflow or similar?
07:23:33 <Work_jack> groan
07:23:37 <roconnor> p_l: or maybe #ghc
07:23:37 <ocharles> https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs For those who are Netwire-curious
07:23:38 <applicative> roconnor: you cant use $ for one thing
07:23:53 <FreeFull> > foldl' (+) [1..1000000]
07:23:59 <roconnor> applicative: ...
07:24:03 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
07:24:03 <lambdabot>    arising from a use ...
07:24:10 <luite> quchen: and add a rule for the sum of [1..n]
07:24:10 <applicative> roconnor: half of haskell syntax is devoted to getting around the fact that a b c d is ((a b) c) d
07:24:20 <FreeFull> > foldl' (+) [1..1000000] :: Integer
07:24:22 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
07:24:22 <lambdabot>              with a...
07:24:26 <quchen> luite: Good point. That would make that sum benchmark a lot more performant.
07:24:31 <FreeFull> > foldl' (+) 0 [1..1000000] :: Integer
07:24:33 <lambdabot>   500000500000
07:24:41 <FreeFull> That's not too slow
07:24:46 <quchen> luite: > let sum xs = let l = last xs in (l * (l+1)) `quot` 2 in sum [1..10000000]
07:24:50 <applicative> roconnor: error is MUCH more likely with a long sequence of complex terms joined by <>
07:24:53 <p_l> Tinned_Tuna: The reason I asked on irc is that I need the answer now, because borked system environment :/
07:25:01 <b2coutts_> FreeFull: that was faster than I would have expected
07:25:06 <roconnor> applicative: how about using lists and mconcat?
07:25:09 <haasn> edwardk: okay, foldl' (+) 0 -- is significantly faster still ;)
07:25:10 <b2coutts_> I suppose there's fancy optimization going on in the background
07:25:12 <applicative> roconnor: exactly
07:25:13 <luite> quchen: hehe well that one doesn't look sound :p
07:25:28 <applicative> roconnor: that's what I consider the better alternative
07:25:31 <Tinned_Tuna> p_l: that's fair enough, but it looks like no one who knows the answer is around now, so a longer lived area (or more appropriate channel) might give better results :-)
07:25:34 <quchen> luite: Shame I can't pattern-match on [x..y]
07:25:49 <luite> quchen: doesn't it desugar to enumFromTo for the rules?
07:25:52 <roconnor> applicative: you can even alias mconcat to a short name.
07:25:59 <roconnor> mo
07:26:09 <quchen> luite: Yeah it should
07:26:15 <applicative> roconnor: but keep in mind this is one of the brilliantly optimized systems of libraries on hackage; part of it is now in the bytestring package, thought not this part
07:26:19 <ooesili> quchen: you can use guards with head and tail
07:26:34 <applicative> roconnor: as soon as lists enter every optimization goes to pieces
07:26:38 <quchen> luite: I guess you could actually make some rewrite rule for this, yes.
07:26:53 <quchen> luite: Not that that would be very useful, but at least it would shut the sum thread up :-P
07:27:06 <applicative> roconnor: whereas do a b c -> a <> b <> c -> some amazing builder
07:27:25 <roconnor> applicative: right
07:27:45 <applicative> it's a drag the decision is unpleasant
07:28:01 <applicative> but it's all waiting for an improved rebindable syntax
07:28:25 <applicative> for example 'monoid notation'
07:28:39 <haasn> when do we get applicative brackets
07:28:40 <roconnor> still, it seems one ought to be able to preform the horrible iI   Ii hack and it would still be better.
07:28:46 <applicative> haasn: implement them!
07:29:06 <haasn> applicative: via TH?
07:29:16 <applicative> haasn: no just start hacking ghc!
07:29:24 <applicative> everyone's doing it!
07:29:35 <haasn> hmm not sure if that would work, TH expressions type-check before they get passed to the preprocessor, don't they?
07:29:36 <roconnor> haasn: you can already have idom brackets with the horrible iI  Ii hack
07:29:45 <haasn> roconnor: what hack is this?
07:29:47 <applicative> haasn or she, see https://github.com/michaelt/her
07:29:56 <applicative> its on the wiki somewhere
07:30:04 <haasn> yeah I'm aware of she but I don't have her in GHCi
07:30:23 <roconnor> http://www.haskell.org/haskellwiki/Idiom_brackets
07:30:32 <applicative> http://www.haskell.org/haskellwiki/Idiom_brackets
07:30:39 <applicative> oh
07:30:46 <tikhon> SHE doesn't work with GHCi?
07:30:58 <applicative> oh it wouldn't work inside ghci
07:31:03 <applicative> the brackets wont
07:31:15 <haasn> applicative: interesting
07:31:22 <haasn> tikhon: it's just a preprocessor for .hs files, isn't it?
07:31:35 <roconnor> the same trick seems like it should work for monoid brackets.
07:31:41 <applicative> of course she has all kinds of stuff, DataKinds etc do some of it
07:31:47 <roconnor> and you should be able to play nice with the optimizer
07:31:58 <haasn> roconnor: interesting trick
07:32:04 <roconnor> @quote stack-calculator
07:32:05 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:32:20 <roconnor> if we can do a stack calculator we don't need a horrible monoid hack.
07:32:28 <applicative> roconnor: you keep forgetting that every single feature of haskell syntax is devoted to getting rid of the nightmare of bracketting the underlying idea makes necessary
07:32:35 <haasn> roconnor: what's the drawback? ugly syntax? If we could create mixfix operators or similar that could be worked around
07:32:45 <applicative> roconnor: you might as well say, who needs infix operators?
07:32:55 <Work_jack> applicative: Indeed!
07:33:14 <applicative> haskell would totally unwritable AND DANGEROUS without these things
07:33:31 <applicative> for the simple reason that we wouldn't be able to parse things at a glance
07:33:56 <applicative> 90% of Turners genius was devoted to this
07:33:57 <roconnor> applicative: I guess you are right.
07:34:30 <Tinned_Tuna> applicative: you called?
07:34:42 <applicative> hah
07:34:44 <roconnor> applicative: so something like Coq style notation mechanism?
07:34:57 <Tinned_Tuna> applicative: to clarify, I share the name, but not the genius ;-)
07:35:03 <applicative> i wonder about that?
07:35:12 <applicative> Tinned_Tuna: i figure that out
07:35:26 <applicative> not the second part of your conjunction
07:35:50 <Tinned_Tuna> applicative: well, it's more for the logs anyways -- would hate for people to think that I'm a genius ;-)
07:35:57 <applicative> roconnor: yes, I was thinking something like 'notation' but I wonder how fragile that is
07:36:34 <roconnor> applicative: well, it certainly has the potential to make code obsucre, but perhaps one doesn't need notation to do that if that is one's goal.
07:37:01 <applicative> i was thinking it is more powerful (and thus probably fragile) than what's needed
07:37:01 <roconnor> applicative: also elaboration really helps in conjuction with Notiation.
07:37:17 <haasn> this conversation is so difficult to follow, Tinned_Tuna applicative and roconnor have the same color in my IRC client
07:37:20 <roconnor> applicative: possibly, but it isn't all that powerful.
07:37:51 <applicative> I was thinking it was a bit of a hack but I haven't anything to do with it for a while
07:38:10 <roconnor> applicative: I've only used it to draw ascii art of plots.
07:38:21 <applicative> hah
07:38:56 <roconnor> applicative: the Math Components use it to rearrage order of things and hind the crazy crazy implict arguments used for magical inference.
07:39:01 <roconnor> *hide
07:39:33 <applicative> notation x = y _ _ _ _ _ _ _
07:39:48 <applicative> or something
07:40:04 <applicative> notation x = y _ _ _ 17 _ _ _
07:40:34 <roconnor> usually more parameters to x, but yes.
07:41:07 <applicative> part of the problem with something to hand like that is it would be local to the file and so not immediately readable like e.g. a dedicated 'monoidal do' sort of thing
07:41:18 <roconnor> there is some recurisve notation for bracketing that lets you do the monoidal thing
07:41:44 <applicative> that there are not too many possibilites of syntactic fanciness is good too; it's strange how much judgment is involved in something like miranda-haskell
07:43:16 <roconnor> Notation "\sum_ ( i 'in' A | P ) U" :=
07:43:17 <roconnor>   (\big[addv/0%VS]_(i in A | P) U%VS) : vspace_scope.
07:44:00 <roconnor> Notation "\1" := (@id_lfun _ _) : lfun_scope.
07:44:40 <JuanDaugherty> http://docs.gstreamer.com/display/GstSDK/Installing+on+Linux doesn't appear to have abandonded 0.10, that's what it says it's setup for debian download currently
07:44:55 <JuanDaugherty> is that something with no relation to the dot org?
07:47:18 <roconnor> Notation "[ ~: A1 , A2 , .. , An ]" :=
07:47:19 <roconnor>   (commutator .. (commutator A1 A2) .. An) : group_scope.
07:47:37 <JuanDaugherty> sorry
07:49:24 <roconnor> applicative: Not to belittle Turner's outstanding contributions, but what did Turner do that ML didn't?
07:49:57 <applicative> syntax?
07:50:07 <roconnor> yes, syntax wise
07:50:18 <applicative> ML is a giant step forward from everythign else
07:50:32 <roconnor> indeed
07:51:01 <roconnor> and still is :)
07:51:31 <applicative> I take it as read that Milner was a master
07:58:02 <roconnor> applicative: okay, but you said that (part) of Turner's genius was his syntax, but it seems that essentailly all of Haskell's/Miranda's syntax comes from ML.
07:58:27 <roconnor> so I'm wondering if there is some part of Minranda's syntax that I'm not thinking about.
08:03:31 <StahlGrau> anyone have any experience with fourier transforms?
08:03:55 <Yaniel> not mucch besides that they are awesome :D
08:04:11 <tshirtman> s/aw/gru/
08:05:06 <StahlGrau> haha well I guess that's good to hear. My friend wants to use c/c++ to run transforms on some analog input and I was thinking of trying to find information about haskell implementations
08:05:36 <Yaniel> well FFT is all about recursion.. :P
08:06:10 <eikke> Yaniel: there are bindings to fftw
08:06:12 <haasn> StahlGrau: http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/Numeric-FFT.html a pure-Haskell implementation
08:06:28 <haasn> not sure if bindings should count :P
08:07:02 <StahlGrau> ok that looks pretty sweet
08:07:06 <StahlGrau> thanks
08:07:33 <StahlGrau> what did you search to find that? pure haskell fourier transform?
08:07:46 <haasn> I searched for ‚Äòfft‚Äô on hoogle
08:07:50 <eikke> http://en.pk.paraiso-lang.org/Hackage/what-is-the-fastest-dft-in-haskell/main
08:08:01 <haasn> looks like there are a lot more packages that are probably way more optimized
08:08:50 <StahlGrau> this is what my friend was looking at: http://www.drdobbs.com/cpp/a-simple-and-efficient-fft-implementatio/199500857?pgno=2
08:09:12 <haasn> eikke: very interesting, is there an example of the results anywhere?
08:09:29 <eikke> haasn: its linked on the top of the page. notice some dispute in the comments though
08:09:41 <haasn> oh okay
08:10:03 <eikke> StahlGrau: why would you write your own fft implementation? you most likely wont beat fftw, and there's the vector-fftw bindings to use them
08:10:39 <StahlGrau> eikke: we're not writing our own per say, but rather adapting one for our own application/purpose
08:11:20 <StahlGrau> also, although I'm technically an electrical and computer engineer, I never quite got the hang of transforms
08:11:52 <StahlGrau> I'm just trying to find the easiest and fastest solution, hence me coming here for some opinions and advice :)
08:12:30 <eikke> dont take anything I said as advice: I never used the FFT in a Haskell app
08:13:15 <StahlGrau> no worries
08:14:22 <haasn> if I'm reading this report correctly, vector-fftw was faster than the cpp version?
08:17:16 <StahlGrau> haha im not even sure how to read that
08:17:21 <yaxu> Hi all, I'm trying to decide which library to use to make a GUI. It'll be quite unconventional, but all I need to do is create and edit bits of text, move them around the screen, and draw lines between them, like this: http://www.youtube.com/watch?v=5KtFlGEVFGE
08:17:55 <merijn> I have N lists of monoidal values, I want to combine the first entry of each list, then the second entry of each list, etc. Is there a nice library function for that?
08:18:03 <yaxu> I did that with libclutter in C, but the Haskell bindings for clutter are not up to date
08:18:17 <NihilistDandy> yaxu: wxHaskell might work
08:18:49 <dino-> Wondering if anyone here has worked with distributed-process lately. I'm trying to build distributed-process-demos-0.1.0.0 as downloaded from Well-Typed's website. I had to hack the base ==4.5.* deps in the cabal file to >=4.5 to get it to configure..
08:19:16 <dino-> And when I try to build I get a cryptic message: cabal: Package distributed-process-demos-0.1.0.0 can't be built on this
08:19:20 <dino-> system.
08:19:41 <dino-> Verbosity switches are not giving me any more info. Does this look familiar to anyone?
08:20:01 <dino-> My ghc is same as the current Platform, 7.6.3
08:20:38 <dcoutts> dino-: oh it's the flags
08:20:44 <augur> is there a haskell library that parsers haskell source to a haskell ADT?
08:20:53 <donri> augur: haskell-src-exts
08:21:04 <augur> donri: ill check it out! :D
08:21:20 <dcoutts> dino-: you'll probably want -fuse-simplelocalnet -f-use-azure
08:21:41 <dino-> dcoutts: OH! I have to give is _some_ flag
08:21:44 <augur> people dont like my answer on the sum thread :(
08:21:44 <dcoutts> dino-: also, patches to fix stale deps accepted: https://github.com/haskell-distributed/distributed-process-demos
08:21:49 <augur> well, lots of people like it, lots hate it
08:21:58 <augur> ignoring me, its 11 up 11 down lol
08:22:32 <NihilistDandy> link?
08:22:49 <dcoutts> dino-: in principle no, if you cabal install it should hopefully decide to install the distributed-process-simplelocalnet, but it it cannot do that for some reason then technically speaking it's an optional dep, but that can leave you with 0 buildable demos
08:23:08 <dino-> dcoutts: I should have seen that, it says plainly buildable: False
08:23:17 <yaxu> NihilistDandy: thanks I'll have a look
08:24:01 <dino-> ok, I see
08:24:18 <augur> NihilistDandy: who me?
08:24:23 <augur> NihilistDandy: http://www.reddit.com/r/haskell/comments/1jrj7o/sum_11billion_in_haskell/cbht08v
08:24:44 <merijn> Is there like a Data.List.Zip with fancy zips?
08:25:12 <haasn> merijn: fancy zips?
08:25:16 <sutabi> Anyone know why "main" is having problems determining the type of gameloop? https://gist.github.com/joseph-montanez/6165459
08:25:42 <haasn> sutabi: main needs to be :: IO a -- for some a
08:25:52 <haasn> sutabi: gameloop returns something of type World; so that's a type error
08:26:27 <sutabi> so if I add putStrLn "", then its a reason why it works -_-
08:26:30 <merijn> haasn: Like "zipWithN :: (a -> a -> a) -> [[a]] -> [a]"
08:26:48 <haasn> sutabi: you won't get any output that way, making your program rather useless. Are you sure that's what you want?
08:27:13 <n-dolio> @type foldr1 . zipWith
08:27:14 <lambdabot> (a -> a -> a) -> [[a]] -> [a]
08:28:44 <dino-> dcoutts: thank you, made a note of git url above
08:29:01 <merijn> :t zipWith
08:29:02 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:29:15 <merijn> n-dolio: Nice thinking :)
08:30:32 <augur> vecZipWith : forall {A B C n} -> (A -> B -> C) -> Vec A n -> Vec B n -> Vec C n
08:30:46 <sutabi> haasn: there is more to it but I am just trying to get anything simple to work. https://gist.github.com/joseph-montanez/6165530 is my end result but I don't even unstand why those are happening so I figured try sometime easier,
08:31:02 <augur> vecZipWith f xs ys = vapp (vapp (vec f) xs) ys
08:31:04 <augur> :D
08:31:23 <augur> no thats probably too cheeky
08:31:45 <augur> vecZipWith f [] [] = [] ; vecZipWith f (x :: xs) (y :: ys) = f x y :: vecZipWith f xs ys
08:31:49 <Apocalisp> Is is possible to supply a specialized fmap in the case where the types `a` and `b` in `(a -> b) -> f a -> f b` are the same?
08:31:59 <augur> and that cant possibly error!
08:32:24 <augur> Apocalisp: sure, it would look like this:
08:32:41 <augur> apocamap :: (a -> a) -> f a -> f a
08:32:45 <merijn> Apocalisp: Just do "blah :: Functor f => (a -> a) -> f a -> f a; blah = fmap"
08:32:49 <augur> apocamap = ?
08:32:55 <augur> fill in for ?
08:32:57 <augur> :)
08:33:08 <lykos> quick question, I keep getting "Parse of field 'build-depends' failed." in cabal
08:33:16 <augur> actually you might do well to include a Functor constraint on f
08:33:22 <haasn> augur: vapp?
08:33:34 <haasn> oh is that like <*>
08:33:37 <augur> haasn: vector application
08:33:50 <augur> ... -> Vec (A -> B) n -> Vec A n -> Vec B n
08:33:52 <lykos> I tried cabal-install earlier, but it told me I had a hidden package. Every time I try to add a package in my .cabal file I get that error, "Parse of field 'build-depends' failed."
08:34:04 <haasn> so like <*> :)
08:34:17 <augur> haasn: its the <*> for the Vec applicative, yes :)
08:34:23 <augur> but not the same as the list applicative!
08:34:28 <pmade> lykos: paste your cabal file on hpaste.  Maybe you're missing a comma, or have one too many?
08:34:29 <haasn> augur: vec :: a -> Vec a n -- this isn't possible in Haskell, is it?
08:34:30 <augur> there are two list applicatives, of course
08:34:35 <augur> haasn: not without using SHE
08:35:12 <haasn> augur: there's more than one list applicative ;-)
08:35:16 <Apocalisp> Basically, when I say `fmap id`, I want my specialized fmap to be selected instead of a more general one.
08:35:23 <augur> haasn: yes, but theres a standard one
08:35:31 <augur> and thats the one thats most sensible for lists
08:35:46 <augur> the zippy applicative is bad for lists because lists shouldnt be zipped!
08:35:48 <hpaste> lykos pasted ‚Äú.cabal‚Äù at http://lpaste.net/91605
08:35:49 <augur> you lose information
08:35:50 <augur> naughty naughty
08:35:55 <merijn> Apocalisp: Why? what could you avoid with that?
08:36:00 <augur> conor jokes about this actually at one point
08:36:19 <lykos> pmade: it compiles as it, but when I try to add a line under stap-server, it doesn't compile
08:36:20 <augur> he says he could imagine that you could get some really nasty bugs from zipping lists of different lengths unintentionally
08:36:33 <diabel232> what is the most correct way to install haskell on mac
08:36:36 <haasn> augur: heh, yeah
08:36:38 <diabel232> via brew or via website installer
08:36:41 <lykos> pmade: I've tried various syntaxes. How should I add a package?
08:36:41 <augur> and that he recalled that some programs had already experienced this, hm what were they
08:36:48 <augur> oh yes the Agda type checker
08:36:49 <augur> :)
08:36:55 <diabel232> hi lykos
08:37:00 <merijn> diabel232: I always just install the platform binary on OSX
08:37:13 <NihilistDandy> diabel232: Use the Haskell Platform installer at haskell.org/platform
08:37:13 <lykos> diabel232: hey :) How's it going?
08:37:14 <stelleg> how can I use a mutable unboxed array in STM monad? the TArray is too slow for my needs, and I'm trying to avoid unsafeIOToSTM
08:37:17 <diabel232> ok thanks :)
08:37:28 <diabel232> fine fine must finish 1 website for tomrrow
08:37:33 <NihilistDandy> It sets up all sorts of good defaults
08:37:53 <sirspazzolot> would a question about the sieve of eratosthenes be more suited to a math channel?
08:38:02 <lykos> what website?
08:38:08 <haasn> sirspazzolot:  are you trying to implement it in Haskell? :)
08:38:16 <NihilistDandy> Depends on the motivation of the question, sirspazzolot
08:38:18 <diabel232> for some window cleaning company :d
08:38:31 <geekosaur> lykos, if you're matching indentation and you add a comma after the snap-server line to match the other lines, that should work. unless you're running into some unix vs. windows line ending confusion or something
08:38:37 <sirspazzolot> haasn: that's my endgame, but this particular question is about the algorithm itself
08:38:39 <lykos> cool, what are you writing it in?
08:38:42 <geekosaur> (which a pastebin won't show very well)
08:39:10 <diabel232> php but dont tell anyone in future i rewrite it to haskell web f
08:39:10 <diabel232> :D
08:39:30 <lykos> geekosaur: Ah, I forgot the comma. I didn't really notice it on the other lines.
08:39:35 <haasn> you could port it to Prelude.PHP as an intermediate step
08:39:36 <lykos> geekosaur: thanks!
08:40:14 <diabel232> haasn site must be done fast i will do it with modx framwork which is in php but i dont like this solution :/
08:40:21 <Apocalisp> merijn: I want to modify Data.Set.Monad to be more efficient. If I can call `run` in `fmap` whenever the domain and codomain are the same, I can go from exponential time to linear in that specific case.
08:41:20 <lykos> diabel232: good luck!
08:41:26 <diabel232> thanks :)
08:41:28 <sutabi> if a function uses "getLine" must i add IO to my return type?
08:41:44 <geekosaur> yes
08:42:55 <sutabi> geekosaur: even if I don't need to return the string I got from getLine?
08:43:08 <geekosaur> you are doing IO
08:43:46 <geekosaur> unless you are returning the IO action itself (in which case you still need IO in the result type, but you don't need to be in the IO monad directly)
08:45:13 <NihilistDandy> Apocalisp: :t fmap id gives me Functor f => f b -> f b
08:45:22 <NihilistDandy> Is that not what you're after?
08:45:53 <augur> man
08:46:02 <augur> i should be writing some sort of thing
08:47:17 <Apocalisp> NihilistDandy: Not exactly. I want to give two implementations of fmap, one for (a -> a) and another for (a -> b).
08:47:33 <augur> Apocalisp: a different implementation of fmap?
08:47:38 <geekosaur> ummmm
08:47:40 <augur> or the same one, just specialized in type?
08:47:56 <NihilistDandy> Just call the specialized one fmap', I guess?
08:48:11 <haasn> he wants to optimize a particular Functor instance by using a more efficient algorithm where applicable
08:48:18 <haasn> if I understood it correctly
08:48:27 <Apocalisp> that's right
08:48:39 <haasn> though I'm not sure how the type would factor into it
08:48:49 <augur> haskell doesnt have type directed dispatch of that sort
08:49:08 <augur> so youll have to write a completely separate function
08:49:15 <Apocalisp> fair enough
08:49:32 <augur> like i said
08:49:45 <augur> apocamap :: (a -> a) -> f a -> f a
08:49:52 <augur> apocamap f x = ?
08:49:52 <augur> fill in x
08:49:52 <augur> er, ?
08:50:01 <augur> thats the best you get
08:50:07 <augur> and you have to use it explicitly in those places where its usable
08:50:07 <haasn> ow, that's a naughty Monad instance
08:50:23 <haasn> (or Functor, whatever)
08:50:46 <p_l> ... another cabal issue - anyone else has the problem where cabal can't download package list (because it hangs after downloading some part of it?)
08:51:12 <haasn> augur: unless something else specifically relies on a Functor instance, where apocamap doesn't help you much -- this is where lenses come in!
08:53:18 <augur> haasn: i know
08:57:18 <enthropy> Apocalisp: do SPECIALIZE pragmas work for that case?
08:58:06 <cschneid> are there any language extensions which are obviously useful to most everybody? I'm getting more comfortable with haskell, but haven't ventured that direction.
08:58:13 <cschneid> or are they mostly situational?
08:58:30 <Work_jack> cschneid: take a look at ViewPatterns
08:59:04 * enthropy doesn't think those are very popular
08:59:09 <haasn> it would be an interesting project to figure out which language extensions are most used, eg. on hackage or github
08:59:10 <c_wraith> cschneid: that's really hard to answer.  There are lots of perfectly safe extensions with some utility, but..  What does it mean to be useful to most everybody?
08:59:16 <enthropy> -XPatternGuards are the pointful version of those
08:59:17 <Cale> They're all *somewhat* situational.
08:59:30 <quchen> cschneid: The usual ones, BangPatterns, LambdaCase, MultiWayIf, ScopedTypeVariables, TupleSections
08:59:45 <c_wraith> cschneid: I mean, I guess the existence of ST is useful to everyone, and ST depends on RankNTypes
09:00:27 <haasn> I don't like having ScopedTypeVariables on by default
09:00:27 <Cale> I definitely like PatternGuards, but ViewPatterns I'm less sure about. If used *tastefully*, ViewPatterns can be good :)
09:00:27 <cschneid> c_wraith: well, extensions are going above & beyond haskell official standard right? So it's both the realm of experiments and of solid useful ideas that played out well.
09:00:28 <cschneid> or am I misinterpreting extensions status?
09:00:28 <haasn> cschneid: no that seems correct
09:00:39 <quchen> Extensions are whatever GHC devs seem fit to be added to the compiler.
09:00:50 <Cale> cschneid: Well, some extensions are considered standard now
09:00:50 <c_wraith> most extensions are situationally useful.  Somewhat fewer of them are always safe.
09:00:56 <Cale> and LANGUAGE pragmas are part of the standard :)
09:01:19 <cschneid> c_wraith / Cale: yeah - is there a guide to hunt down which are awesome and which are more iffy, and which are just risky (or easy to screw up or whatever)?
09:01:20 <haasn> oh, are they?
09:01:34 <merijn> Is there an isNan/isInfinity for Doubl?
09:01:39 <Cale> cschneid: Most of them are not so iffy.
09:01:43 <Cale> :t isNaN
09:01:43 <lambdabot> RealFloat a => a -> Bool
09:01:45 <haasn> seems odd to have them in the first place, at least for ones that are 1. perfectly safe and 2. don't collide with anything else
09:01:47 <Cale> :t isInfinite
09:01:48 <lambdabot> RealFloat a => a -> Bool
09:02:01 <merijn> Cale: In hindsight that should've been obvious :)
09:02:39 <merijn> c_wraith: I think the majority is safe actually, in that they can't produce ill-typed code
09:02:55 <Cale> cschneid: GADTs are really cool, even if you probably won't get to use them every day.
09:03:11 <haasn> cschneid: I seem to remember a good stackoverflow thread asking basically exactly this but I can't seem to find it
09:03:15 <merijn> Cale: All my code seems to involve GADTs nowadays
09:03:30 <Cale> cschneid: NewtypeDeriving is on the more useful end of the spectrum, though there have been some bugs in GHC's handling of it.
09:03:33 <c_wraith> merijn: except that lots of people get tricked into thinking they want overlappinginstances by ghc error messages
09:03:51 <nabilhassein> is there anything similar to Data.List.Split's chunksOf, but for ByteStrings? http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html#g:3
09:03:51 <merijn> cschneid: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
09:03:55 <c_wraith> and overlappinginstances is one that should be avoided unless you know exactly what you're doing
09:04:01 <cschneid> cool - so I should look at the list of them, and generally stick with the ones I see others using?
09:04:05 <Cale> (however, you have to work hard to make NewtypeDeriving do anything evil)
09:04:07 <merijn> c_wraith: That is a bug with the error, not with "most" extensions
09:04:10 <cschneid> I've needed BangPatterns before (well, "need").
09:04:40 <haasn> cschneid: http://stackoverflow.com/questions/10830757/is-there-a-list-of-ghc-extensions-that-are-considered-safe
09:04:43 <merijn> cschneid: You can always ask here, for details on specific ones
09:04:49 <c_wraith> Cale: lots of people are willing to do that hard work. :)
09:05:23 * hackagebot fixed-vector 0.5.1.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.5.1.0 (AlexeyKhudyakov)
09:06:44 <Cale> OverlappingInstances is awkward, but UndecidableInstances is usually totally okay if you need it (it just removes some heavy-handed checks which prevent instance resolution from ever being nonterminating)
09:07:34 <c_wraith> GHC is sometimes silly about UndecideableInstances.  It told me I needed it for an instance for (n :: Nat) for a kind-polymorphic class.
09:07:42 <haasn> I find the need to use FlexibleInstances also from time to time
09:07:43 <NihilistDandy> OverloadedStrings seems pretty innocuous
09:07:56 <c_wraith> actually, OverloadedStrings is relatively evil, in the way it's used
09:08:05 <haasn> NihilistDandy: it can be a pain in the arse though due to some instances being more or less broken
09:08:09 <Cale> and FlexibleInstances is uncontroversial -- in fact it didn't even have a name for a long time, and was just default on, even though it's technically an extension.
09:08:14 <haasn> but that's not the extension's fault
09:08:30 <c_wraith> While it's true that (n :: Nat) doesn't have a constructor at the head, it can't be recursive!
09:09:50 <Cale> There are more and less evil ways to use OverloadedStrings. I would consider it okay to use them for Text, and perhaps even Data.ByteString.Char8.
09:09:56 <FreeFull> c_wraith: Can you explain OverloadedStrings evilness?
09:10:20 <Cale> FreeFull: You can define IsString instances for datatypes which aren't strings, and do some kind of parsing.
09:10:21 <FreeFull> I wouldn't consider Data.ByteString.Char8 a good thing
09:10:34 <FreeFull> Cale: Ah, and the parsing can fail
09:10:36 <c_wraith> Char8 is a defensible thing, if not exactly good.
09:10:38 <typoclass> c_wraith: OverloadedStrings is evil? my word, how? i cannot see any problem with it. specifically with those IO instances that i once tried, which allowed stuff like ¬´do "grep -v"; "ls" ["-l"]¬ª
09:10:38 <haasn> Cale: you can define illegal Monad instances too
09:11:02 <haasn> Cale: that doesn't make the class Monad bad, it just means people who define bad instances should feel bad about themselves :(
09:11:06 <Cale> haasn: yeah, it's much trickier to define evil instances of Monad though :)
09:11:07 <typoclass> c_wraith: (just kidding ;-) i wasn't serious with the whole thing to start with, and abandoned it when the error messages got terminally confusing)
09:11:35 <Cale> Or, it's harder to do it and get away with it.
09:11:37 <c_wraith> typoclass: that's actually kinda funny.  But I'm glad it was unusable in practice. :)
09:11:46 <Cale> Though, I suppose ListT is a good example :P
09:11:46 <FreeFull> You could declare a list monad instance that swaps two of the elements if the list is of a certain length
09:12:04 <Cale> ListT m isn't a monad for most monads m
09:12:16 <FreeFull> ListT Identity
09:12:42 <Cale> It's basically just for Identity and Reader, and few others.
09:12:46 <c_wraith> FreeFull: yes, but people tend to yell at you if you introduce broken monad instances.  much less so for broken IsString instances
09:13:00 <cschneid> so overridable strings is pretty common if you're interfacing with a lib that works exclusively with ByteString or friends?
09:13:02 <c_wraith> Though I'm still not convinced shelly's monad instance isn't broken
09:13:25 <cschneid> I have a bit of code I wrote recently that packs pretty much everything I do String -> ByteString style.
09:13:25 <blochchain> is there any way in GHCi to test if a type belongs to a type class?
09:13:34 <Cale> blochchain: :info TypeName
09:13:51 <FreeFull> c_wraith: There are quite a few libraries out there with monad instances that don't obey the rules
09:13:55 <blochchain> thanks Cale
09:14:15 <c_wraith> Sadly, :info only shows a class if all of the type, the class, *and* the instance are in scope
09:14:36 <typoclass> cschneid: for Text i think an OverloadedStrings instance is helpful. you can write ¬´theFunction "abc"¬ª which is translated into something like ¬´theFunction $ Text.pack "abc"¬ª, given theFunction :: Text -> ... and pack :: String -> Text
09:14:41 <haasn> I'd prefer wrapping ‚Äòascii :: String -> ByteString‚Äô in front of every literal, with proper ‚Äòerror‚Äô where the source contains non-ascii characters
09:14:52 <haasn> if that's what you're after
09:15:16 <haasn> for Text I definitely endorse it
09:15:35 <Cale> blochchain: Qubitcoins?
09:15:56 <cschneid> I've not used the Text data type yet. What's it's role (as opposed to String & ByteString)? [string is a list of chars, so linked-list problems], [bytestring is... ] and text is [....]?
09:16:11 <haasn> :t () :: Num Integer => ()
09:16:12 <lambdabot>     Non type-variable argument in the constraint: Num Integer
09:16:12 <lambdabot>     (Use -XFlexibleContexts to permit this)
09:16:12 <lambdabot>     In an expression type signature: Num Integer => ()
09:16:14 <haasn> oh
09:16:17 <blochchain> Cale, what?
09:16:20 <dmwit> ByteString is for sequences of bytes, and Text is for sequences of Char.
09:16:22 <typoclass> cschneid: but the ByteString instance for OverloadedStrings is highly dubious in my opinion. it ignores non-ascii parts of your String afaik and doesn't even give an error message. so that's a bit of a special case and i'd avoid it. i'd just do ¬´p = ByteString.pack¬ª and use ¬´theFunction (p "something")¬ª explicitly. it's much clearer and safer
09:16:23 <haasn> how appropriate for this discussion!
09:16:24 <Cale> blochchain: Your nick :)
09:16:43 <blochchain> ah, yes Cale, it is bitcoin related. I'm not sure of the qubit reference tho :P
09:16:50 <dmwit> String is also for sequences of Char, but isn't as performant as Text for most situations.
09:16:52 <Cale> blochchain: http://en.wikipedia.org/wiki/Bloch_sphere
09:16:56 <haasn> well, anyway, if you had FlexibleContexts enabled, you could test if certain constraints are satisfied that way -- blochchain
09:17:16 <cschneid> dmwit: ahh, interesting. So ByteString should be "these are bytes", and Text is "this is a readable thing with characters"?
09:17:27 <dmwit> yes
09:17:28 <cschneid> so xor makes sense on ByteString, but probably not Text for instance.
09:17:44 <blochchain> if i wanted to set my GHCi prompt to a lambda without copy-pasting, how do I do that? i tried \U+03BB but it didn't work
09:17:56 <Cale> cschneid: Right.
09:18:01 <dmwit> I suppose. It's not clear to me that xor makes 100% sense on *sequences* of bytes, though it makes perfect sense on bytes.
09:18:37 <Cale> ghci> :set prompt "Œª> "
09:18:37 <Cale> Œª>
09:18:59 <blochchain> but is there any way to convert the lambda's unicode number to its char?
09:18:59 <dmwit> blochchain: Use Haskell String syntax.
09:18:59 <arkeet> :set prompt "\x03bb> "
09:19:04 <dmwit> ...what arkeet said
09:19:07 <blochchain> ah thanks
09:19:19 <arkeet> it's ordinary haskell.
09:19:28 <arkeet> syntax.
09:19:59 <Cale> You can also just type a lambda if you happen to have your input mode set up to let you type Greek letters. I have my left Windows key set up to switch to a Greek keyboard layout while held :)
09:20:15 <dmwit> Perhaps he would like his .ghci file to be encoding-agnostic.
09:20:28 <dmwit> Well, I guess that's not really possible.
09:20:33 <dmwit> So forget that.
09:20:46 <dmwit> Perhaps he would like his .ghci file to be ASCII. =)
09:22:37 <typoclass> cschneid: String and Data.Text are conceptually equivalent, and differ only in performance. some people swear it's significant, but i've also heard that Text is in general not really helping much, unless you have very specific circumstances. who knows. (Data.Text is not to be confused with the modules named Text.Read and such. they are fairly recent and afaik have nothing to do with Data.Text)
09:23:01 <lykos> is there some way to change default ghci settings?
09:23:07 <Cale> Oh, cschneid, you should also be aware that the GHC User's Guide gives a pretty good overview of all the extensions which are available, and it doesn't take too long to read through them :)
09:23:09 <lykos> that lamda is pretty awesome.
09:23:11 <cschneid> typoclass: cool - I figure they're different underlying representations. String is just [Char] and Text is probably something else. Obviously they may behave different.
09:23:24 <NihilistDandy> lykos: Just add lines to your .ghci file
09:23:35 <lykos> where is the .ghci file?
09:23:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
09:23:38 <cschneid> Cale: yeah, just worried about the kind of throwaway thing like: "Ohh yeah, the OverloadedStrings instance for ByteString silently throws away data" type gotchas.
09:24:01 <NihilistDandy> lykos: In your home directory on UNIX-like systems. I dunno where it lives on Windows
09:24:06 * haasn likes :set prompt "Œª "
09:24:14 <haasn> Œª already looks like a >, sort of
09:24:19 <Zenol> typoclass: Notice that Text export Text.Encoding.decodeUtf8, .decodeUtf16, .decodeUtf32 .decodeLatin1 :)
09:24:20 <typoclass> lykos: yes, just put lines into the file ~/.ghci (your home directory). i have a bunch of often-used imports in there (import Data.Maybe and so on), and also ":set prompt ..." and ":set -XNoMonomorphismRestriction"
09:24:37 <NihilistDandy> lykos: haasn: You can also put import statements in your .ghci if there are libraries you like to use
09:24:42 <lykos> I'm in my home directory (I'm on Linux), but it's not there.
09:24:44 <NihilistDandy> I usually put Control.Monad in mine
09:24:56 <typoclass> Zenol: oh interesting. what package is that?
09:25:15 <haasn> NihilistDandy: my .ghci is quite huge by now
09:25:16 <lykos> I obviously checked for hidden folders :)
09:25:16 <typoclass> lykos: if it doesn't exist, create it
09:25:21 <lykos> ah, okay
09:25:38 <lykos> any special syntax needed?
09:25:38 <haasn> NihilistDandy: http://bpaste.net/show/120521/
09:25:44 <lykos> can it be plain text?
09:25:44 <NihilistDandy> haasn: Haha, yeah, I've accrued some things over the years
09:25:45 <Zenol> typoclass: Data.Text. They are ByteString -> Text. http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Encoding.html
09:25:56 <NihilistDandy> haasn: Wow, no joke
09:25:57 <typoclass> lykos: no, just normal lines as you would type them in ghci at the prompt
09:26:04 <typoclass> Zenol: oh i see. right
09:26:39 <lykos> *** WARNING: ghci is writable by someone else, IGNORING!
09:26:42 <lykos> that's interesting
09:26:48 <lykos> I'll just change the permissions
09:26:59 <Zenol> typoclass: But saddly, you can latin1->utf8, but can't utf8->latin1 :(
09:26:59 <lykos> I assume it's there to not make some security risk?
09:27:04 <cschneid> can I define functions in my ghci if that's helpful? It just evals whatever's in there?
09:27:08 <JoeyA> WARNING: ghci was implemented by someone else.
09:27:12 <haasn> lykos: yeah .ghci gets evaluated whenever you load up ghci so you can put bad stuff in there
09:27:29 <haasn> and it would run as that user
09:27:38 <NihilistDandy> cschneid: Yeah, you can define pretty much anything
09:27:55 <FreeFull> haasn: I wonder why .bashrc doesn't get that sort of protection
09:28:08 <lykos> what chmod removes other users w/r permissions?
09:28:22 <haasn> FreeFull: bash doesn't check the current folder for .bashrc, does it?
09:28:32 <Hafydd> chmod o-wr
09:28:34 <FreeFull> haasn: No, only ~/
09:28:34 <typoclass> lykos: try chmod 644 (read-write for you, read-only for everyone else)
09:28:44 <haasn> FreeFull: well yeah there's a pretty substantial difference already
09:28:59 <JoeyA> Is there an efficient nub on Hackage (that doesn't expect the list to be sorted) ?
09:29:08 <lykos> typoclass: worked like a charm, thanks
09:29:27 <haasn> FreeFull: with ghci, if you don't have dotfiles visible and/or constantly check for .ghci, you could accidentally end up running somebody else's code simply by loading up ghci in some directory (eg. of haskell code that you want to test out)
09:29:30 <lykos> anyone here pretty familiar with snap?
09:29:44 <Cale> JoeyA: If you don't mind changing the order of the elements in the list, map head . group . sort is an appropriate idiom.
09:30:09 <JoeyA> Cale: true, but it's a little sad that it has to consume the whole list first.
09:30:20 <FreeFull> haasn: True
09:30:23 <dmwit> JoeyA: It doesn't.
09:30:26 <dmwit> oh
09:30:27 <dmwit> Well, it does.
09:30:37 <dmwit> It doesn't have to *sort* the whole list first, though.
09:30:47 <Cale> JoeyA: true... it's really not so hard to write one which doesn't affect the order of the list
09:30:49 <dmwit> If you want a stable nub, then you have to work a tiny bit harder.
09:30:50 <Cale> and which accumulates, say, a Data.Set as it walks along
09:31:01 <JoeyA> I've written one.  I'm just wondering if anyone's put functions like that on Hackage yet.
09:31:09 <JoeyA> If not, maybe I'll put something together.
09:31:13 <Cale> Of course, anything better than Data.List.nub will have to have an Ord constraint
09:31:39 <FreeFull> I should look at various DSLs written in Haskell
09:31:46 <JoeyA> And maybe some other operations like LINQ's Join (though with a different name).
09:31:56 <FreeFull> I wonder how many there are that deal with graphics
09:32:54 <Zenol> lykos: I tried it once. But ask, maybe some one else with answer you.
09:33:28 <FreeFull> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages#Graphics  This seems to be relevant to me
09:35:28 <Cale> FreeFull: You must check out Diagrams and Gloss.
09:35:58 <dmwit> JoeyA: Hayoo suggests http://hackage.haskell.org/packages/archive/yhccore/latest/doc/html/Yhc-Core-Internal-General.html#v:ordNub and http://hackage.haskell.org/packages/archive/buildwrapper/latest/doc/html/Language-Haskell-BuildWrapper-Base.html#v:nubOrd
09:35:58 <Cale> http://projects.haskell.org/diagrams/
09:36:19 <Cale> http://gloss.ouroborus.net/
09:36:32 <dmwit> JoeyA: But the latter seems to be Set.toList . Set.fromList, so not stable and has the same drawbacks as map head . group . sort.
09:36:51 <JoeyA> dmwit: thanks for looking.
09:37:25 <dmwit> And yhccore is probably a pretty heavy-weight dependency for this function... =P
09:37:25 <JoeyA> Here's a Haskell translation of LINQ's Join: innerJoin :: Eq k => [a] -> [b] -> (a -> k) -> (b -> k) -> (a -> b -> r) -> [r]
09:37:45 <JoeyA> Though the equality comparison used by LINQ also supports hashing, so this isn't O(m*n)
09:38:02 <JoeyA> It'd be like adding a hash function to the Eq class.
09:38:09 <dmwit> You might like Data.Map.fromListWith.
09:38:53 <Cale> The YHC one is the one you probably are going to want.
09:38:58 <JoeyA> You can implement a stable nub using a hashmap, by the way.
09:38:59 <dmwit> :t \f xs -> M.fromListWith (++) [(f x, [x]) | x <- xs]
09:39:00 <lambdabot> Ord k => (a -> k) -> [a] -> M.Map k [a]
09:42:00 <cschneid> is there a way to do dynamic imports for ghci? ie a .ghci alias for "hey, pull in these 10 modules"
09:42:04 <cschneid> I don't always want them loaded
09:42:08 <dmwit> :t let putInMap xs f = M.fromListWith (++) [(f x, [x]) | x <- xs] in \as bs fa fb combine -> M.intersectionWith (liftM2 combine) (putInMap as fa) (putInMap bs fb)
09:42:08 <lambdabot> Ord k => [a1] -> [a2] -> (a1 -> k) -> (a2 -> k) -> (a1 -> a2 -> r) -> M.Map k [r]
09:42:10 <cschneid> but when I do, they go together.
09:42:16 <dmwit> JoeyA: There you go. =)
09:42:28 <xplat_> zomg, so many delicious-looking papers at icfp, don't know where to start
09:42:29 <dmwit> oops, needs some post-processing!
09:42:46 <xplat_> unfortunately several of them are 'no preprint found'
09:43:08 <dmwit> :t let putInMap xs f = M.fromListWith (++) [(f x, [x]) | x <- xs] in \as bs fa fb combine -> concat . M.elems $ M.intersectionWith (liftM2 combine) (putInMap as fa) (putInMap bs fb)
09:43:09 <lambdabot> Ord k => [a1] -> [a2] -> (a1 -> k) -> (a2 -> k) -> (a1 -> a2 -> a) -> [a]
09:43:13 <typoclass> cschneid: i would put the imports in a file Stuff.hs and import that when needed
09:43:40 <monochrom> cschneid: write a "module GetSmart where import Control.Rod; Data.Ltr.Cmdr", then load it or not load it
09:44:14 <gertc> >>= \set -> (5 `member` set) >>= return What type signiture does it return ? I was thinking Monad m => m Bool ?
09:44:14 <xplat_> the balabonski, and the garcia, and the 4japanese guys + hu really sound interesting
09:44:15 <cschneid> cool, I was playing with UnitTyped earlier, and it has like 8 modules to fully import it.
09:44:15 <typoclass> monochrom: i love that module name, but it should be Data.Lt.Cmdr
09:44:27 <monochrom> oh oops
09:44:56 <typoclass> import Data.And.His.Cat
09:45:10 <Cale> gertc: That's not a complete expression...
09:45:43 <Cale> gertc: But one of the monad laws is that  x >>= return  =  x
09:45:55 <gertc> So just a normal Bool then ?
09:46:26 <gertc> it has to be somting in a Monad right?
09:46:28 <Cale> This looks like a type error, unless member produces a result whose type is in some monad.
09:46:37 <dmwit> If they're equal, and you thought the previous one had a certain type, you should think the later one had that same type.
09:47:10 <typoclass> gertc: what cale meant is that you can simplify your code. you can leave out ">>= return" because it does nothing
09:47:20 <Cale> Perhaps you meant to write (\set -> return (5 `member` set))
09:48:50 <josephle> what happened to haskell.org?
09:49:10 <Cale> (Can't contact the database server: Too many connections (localhost))
09:49:23 <Cale> hm!
09:49:26 <typoclass> josephle: hm, seems down for me as well
09:49:42 <gertc> is   ...>>= (\set -> return (5 `member` set))  also the same as    ...>>= (\set -> (5 `member` set))
09:49:47 <Cale> no
09:50:06 <Cale> return :: a -> m a  constructs an action which does nothing except to produce the given value as its result.
09:50:30 <Cale> i.e. return v is an action which does nothing except to return v :)
09:51:02 <Cale> I don't know what type member has in this code, but chances seem good that it doesn't construct an action.
09:51:16 <gertc> ok so with out return i return a Bool instead of a m Bool?
09:51:19 <ReinH> would (>>= \set -> (5 `member` set)) typecheck? The RHS has to be a -> m b, not a -> b
09:51:45 <Cale> If 5 `member` set :: Bool, then it won't typecheck.
09:52:03 <Cale> (without the return)
09:52:16 <gertc> ok testing somthing
09:52:31 <ReinH> you probably just want fmap?
09:53:00 <kuribas> I am making a metafont implementation in haskell.  Should I put the bezier math stuff (outline, intersection, etc...) in  a separate library?
09:53:01 <Cale> If you write x >>= f then f should be a function that given the result of executing x, produces another action to run.
09:53:21 <Cale> kuribas: Seems like that would be useful :)
09:53:24 <ReinH> so you get a function m a -> m Bool
09:53:45 <Cale> kuribas: I wonder if you could even extend diagrams with the additional stuff that you need.
09:55:02 <Cale> kuribas: It already has some support for cubic splines.
09:55:52 <kuribas> I'll look at it.
09:56:05 <dmwit> I'm sure byorgey would be happy to split some of the computational code out into its own package that both you and diagrams could depend on.
09:56:14 <dmwit> If he hasn't already. =P
09:56:57 <ReinH> kuribas: at some point you need an error that says "failure to reticulate splines"
09:57:34 <ParahSailin> whats the deal with the mu dialect of haskell, i can't find any info on that
09:58:27 <kuribas> dmwit: That would be great.
09:58:38 <gertc> is this the same? ...>>= (\set -> return (5 `member` set))   ...>>= (\set -> (5 `member` set)) >>= \x -> return x
09:58:48 <Cale> no
09:58:57 <Cale> The latter is probably a type error.
09:59:36 <Cale> The former is equivalent to  fmap (5 `member`) ...
10:00:40 * hackagebot tagsoup 0.13 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.13 (NeilMitchell)
10:00:47 <Cale> The result of the function which is the right hand parameter to >>= must be an action.
10:01:08 <Cale> If we assume that 5 `member` set :: Bool, then it's not an action, and so doesn't belong as the result of such a function.
10:01:36 <Cale> However, you can apply return to it to get a trivial action which does nothing except to produce 5 `member` set as its result.
10:01:50 <byorgey> kuribas: diagrams doesn't have much in the way of bezier math stuff yet.
10:02:04 <byorgey> kuribas: if you split it into a separate package that would be great.
10:02:37 <Riccardo> I had some code working with ReaderT/withReaderT
10:02:51 <Riccardo> now i've stacked a StateT on top of ReaderT
10:02:58 <gertc> a wait i need a m Bool before i can ship it with >>= right?
10:03:11 <Riccardo> and it broke
10:03:19 <Cale> gertc: What monad specifically are you using?
10:03:27 <byorgey> kuribas: take a look at http://hackage.haskell.org/package/typography-geometry
10:03:32 <arkeet> :t (>>=)
10:03:32 <Cale> gertc: It would be nice to be able to speak in concrete terms here.
10:03:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:03:38 <byorgey> kuribas: that may already have some of what you need
10:03:38 <arkeet> read the types :-)
10:03:48 <arkeet> also, (>>= \x -> return x) = id
10:03:53 <Riccardo> i think because withReaderT returns a  ReaderT r m a
10:04:08 <Riccardo> but now i need to return a StateT s (ReaderT r m a)
10:04:25 <arkeet> surely you mean StateT s (ReaderT r m) a
10:04:34 <Riccardo> yup sorry
10:04:35 <arkeet> :t lift
10:04:35 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:06:15 <gertc> ok so this should work then :) ...>>= (\set -> return True) >>= \x -> return x
10:06:26 <Cale> gertc: it'll *work*...
10:06:48 <Cale> gertc: though >>= \x -> return x is totally redundant
10:07:02 <Riccardo> but now it seems that the function inside the readerT can't use the StateT
10:07:21 <arkeet> indeed
10:07:22 <Cale> by eta contraction, it's equivalent to  >>= return  and then by the monad law, it can be removed altogether :)
10:07:25 <Riccardo> i guess I could swap the reader and the state and make the reader the outermost
10:07:31 <arkeet> you could
10:07:36 <Riccardo> but this only works because they happen to be commutative
10:07:46 <Riccardo> what happens if next time i get stuck with, say, reader and error?
10:07:48 <arkeet> no, they don't
10:07:53 <arkeet> which is precisely why you can do it one way and not the other
10:07:56 <kuribas> byorgey: I looked at it, but it isn't enough.
10:08:01 <byorgey> ok.
10:08:03 <gertc> Cale: ok thx i forgot i needed a m Bool before i can use >>=
10:08:18 <arkeet> @unmtl RWST r w s m a
10:08:18 <lambdabot> r -> s -> m (a, s, w)
10:08:29 <Riccardo> sorry, i eman that the stacking order is commutative
10:08:40 <arkeet> I don't know what you mean by that, but no.
10:08:45 <Riccardo> i get the same "monadic effect"
10:08:49 <Cale> gertc: It's also worth noting that  x >>= (\v -> return (f v)) is the same as  fmap f x
10:09:01 <Riccardo> my functions get to modify a state and read an argument without passing it around
10:09:04 <Riccardo> that's what i mean
10:09:06 <arkeet> @unmlt StateT s (ReaderT r m a)
10:09:06 <lambdabot> Maybe you meant: unpl unmtl
10:09:11 <arkeet> @unmtl StateT s (ReaderT r m) a
10:09:11 <lambdabot> s -> (ReaderT r m) (a, s)
10:09:20 <arkeet> uhh
10:09:24 <Riccardo> if you have say, state and error, then in one case the error throws away the state, in the other it is preserved
10:09:28 <arkeet> @unmtl ReaderT r (StateT m) a
10:09:29 <lambdabot> r -> (StateT m) a
10:09:32 <arkeet> uhh
10:09:36 <Riccardo> no? :D
10:09:52 <arkeet> I thought unmtl was smarter than that.
10:10:49 <arkeet> I guess they're the same :s
10:11:12 <arkeet> s -> r -> m (a,s) and r -> s -> m (a,s)
10:11:25 <n-dolio> @unmtl ReaderT r (StateT s m) a
10:11:25 <lambdabot> r -> (StateT s m) a
10:11:32 <arkeet> =(
10:11:37 <arkeet> @unmtl r -> (StateT s m) a
10:11:37 <lambdabot> r -> (StateT s m) a
10:11:43 <n-dolio> The parens confuse it, I think. Not sure when that started.
10:11:54 <arkeet> @unmlt StateT s ReaderT r m a
10:11:54 <lambdabot> Maybe you meant: unpl unmtl
10:11:56 <arkeet> @unmtl StateT s ReaderT r m a
10:11:56 <lambdabot> Plugin `unmtl' failed with: `ReaderT (r, s)' is not applied to enough arguments, giving `/\A B. r -> s -> A B'
10:12:10 <ClaudiusMaximus> @@ @unmtl @unmtl ReaderT r (StateT s m) a
10:12:10 <lambdabot>  r -> (StateT s m) a
10:12:15 <Riccardo> but then why did you tell me to get the reader as the outermost, if you believe you can't change the stack order without other side effects?
10:12:17 <arkeet> n-dolio: when this hallens, I just blame elliott.
10:12:29 <Riccardo> to get -> that you could put*
10:12:29 <arkeet> happens.
10:12:41 <arkeet> Riccardo: I don't know what you mean by side effects.
10:12:42 <gertc> Cale: ok got it
10:12:48 <Riccardo> sorry
10:12:51 <arkeet> but it turns out that it doesn't matter which order you put ReaderT and StateT.
10:12:51 <Riccardo> wrong term in haskell :D
10:13:06 <Riccardo> so we do agree :-)
10:13:15 <arkeet> but we're just lucky.
10:13:17 <Riccardo> except for the fact that I get to use StateT inside withReaderT
10:13:26 <arkeet> if it was ReaderT and WriterT, things would be different.
10:16:18 <Riccardo> i guess I'll figure out how to get withReaderT to access the outermost monad automatically if i ever need to :-)
10:16:46 <Riccardo> actually it's impossible
10:16:58 <Riccardo> but it could be possible to write a withReaderT that behaves nicely with the outermost monad
10:17:04 <Riccardo> monads* actually
10:26:31 <arkeet> Riccardo: well, maybe you want  local  then
10:27:30 <Riccardo> hmmm
10:29:05 <Riccardo> so the reason why it's not playing nicely with the rest of the stack is not because the type of withReaderT is not 'm1 ReaderT  r m2 a', but rather because I am trying to change r in to r'?
10:29:10 <Riccardo> i don't think that's the case
10:29:35 <Riccardo> because my function is a -> a, so the type system should figure out that local and withReaderT are equivalent here
10:29:43 <arkeet> withReaderT only works with ReaderT, not more general MonadReaders.
10:29:47 <arkeet> local is part of the MonadReader class
10:29:49 <Riccardo> (but yes, it seems i should be using local)
10:29:55 <Riccardo> oh
10:29:58 <Riccardo> i see
10:30:05 <Riccardo> so it might be that
10:30:10 <Riccardo> let me try
10:31:57 <isomorphismes> I defined factorial (usual way) in Ubuntu 12.04 package Haskell with 378MB free RAM and it killed the ghci process. Has that happened to anyone else?
10:32:37 <joelteon> isomorphismes: usually processes get killed on VPSes if they consume too much ram
10:34:12 <isomorphismes> joelteon: how could factorial 5 consume so much RAM?
10:34:21 <joelteon> depends on how you defined it
10:34:59 <isomorphismes> I'm using GHCi, version 7.4.1. let factorial 0 = 1; let factorial n = factorial (n-1); factorial 5
10:35:13 <geekosaur> that is NOT the usual way
10:35:22 <geekosaur> each "let" in ghci is an independent definition
10:35:31 <geekosaur> so you lost your base case
10:35:41 <joelteon> yeah
10:35:57 <joelteon> you just did factorial (factorial (factorial ...)) until it died
10:36:28 <isomorphismes> geekosaur: ohhhhhhhhhhhhhhh. joelteon
10:36:32 <geekosaur> (also you seem to be missing an n*
10:36:38 <Riccardo> arkeet: it works, thanks
10:36:46 <isomorphismes> geekosaur: thanks that was my typo. but either way it's the problem you stated.
10:37:02 <Riccardo> still new at this haskell thing :-)
10:37:11 <joelteon> > let factorial = fix \f n -> f (n - 1) in factorial 5
10:37:12 <lambdabot>   <hint>:1:21: parse error on input `\'
10:37:12 <isomorphismes> thank you geekosaur joelteon
10:37:13 <typoclass> > let fac 0 = 1; fac n = fac (n-1) in fac 5 -- isomorphismes: here is a solution, note that this has only one "let" (not two)
10:37:14 <lambdabot>   1
10:37:15 <joelteon> whoops
10:37:17 <geekosaur> let factorial 0 = 1; factorial n = n * factorial (n - 1)
10:37:21 <joelteon> > let factorial = fix $ \f n -> f (n - 1) in factorial 5
10:37:25 <lambdabot>   mueval-core: Time limit exceeded
10:37:28 <joelteon> boom, killed
10:37:30 <typoclass> isomorphismes: (there is still another problem with it)
10:37:35 <geekosaur> those are part of the same let and therefore should work
10:38:07 <joelteon> > (fix $ \f n -> if n == 1 then 1 else n * f (n - 1)) 5
10:38:09 <lambdabot>   120
10:38:19 <isomorphismes> thank you all. joelteon I'm doing LYAH and the \f is unfamiliar to me. What does that mean?
10:38:27 <joelteon> that's a lambda
10:38:29 <joelteon> anonymous function
10:38:38 <joelteon> > (\x -> x + 1) 3
10:38:39 <lambdabot>   4
10:38:46 <isomorphismes> I still don't totally understand what "let" is doing then. But I can intuitively see how it might cause a problem (as joelteon said expanding the characters)
10:39:21 <typoclass> isomorphismes: you can always put your code in a .hs file and use ":load file.hs", then whenever you changed it, use ":r" to reload it. it's pretty common to have a ghci window open, and next to it an editor
10:39:25 <isomorphismes> typoclass: What is the other problem? The one-line version of geekosaur worked.
10:39:49 <isomorphismes> joelteon: I'm unfamiliar with the $ as well. on ch 3 of LYAH
10:40:03 <joelteon> oh, $ is a thing you use to avoid using parentheses
10:40:03 <geekosaur> let { fac 0 = 1; fac n = n * fac (n - 1) } -- with explicit braces
10:40:13 <joelteon> > succ $ 1 + 2 + 3 + 4
10:40:14 <lambdabot>   11
10:40:17 <joelteon> instead of succ (1 + 2 + 3 + 4)
10:40:25 <typoclass> isomorphismes: well, factorial of 5 isn't really 1 :-) the term 'factorial' as used in math would mean it's 5*4*3*2*1
10:40:29 <isomorphismes> joelteon: re $. thanks. would you mind providing another example?
10:40:30 <Cale> f $ x = f x, but $ has really low precedence
10:40:33 <johnw> if I'm evaluating a thunk and an asynchronous exception occurs, it just leaves the rest of the thunk unevaluated, yeah?  unless synchronous exceptions from pure code which replace the thunk with the exception?
10:40:33 <joelteon> yeah
10:40:38 <joelteon> f $ x is MOSTLY like (f) (x)
10:40:45 <johnw> s/unless/unlike
10:41:07 <joelteon> > head $ tail $ [1..10]
10:41:09 <lambdabot>   2
10:41:13 <joelteon> although that case is discouraged
10:41:15 <isomorphismes> typoclass: point taken, what we are interested in is recursion. factorial is just an example with a pre defiend operator.
10:41:26 <isomorphismes> Cale: thanks
10:41:30 <joelteon> people generally do something like head . tail $ [1..10], or just head (tail [1..10])
10:41:36 <joelteon> it's a stylistic preference really
10:41:44 <Cale> johnw: Yeah. It *might* wait until the next garbage collection to actually trigger, I forget the details.
10:41:50 <typoclass> isomorphismes: i don't think it's necessary or very useful at this stage to understand the "fix $ \f ..." line. i think you can basically ignore that and continue with lyah, and go back to fix later, if you want
10:42:04 <Cale> But yes, the expression is left unevaluated, and if it's resumed later, it can pick up where it left off.
10:42:12 <isomorphismes> joelteon: thanks, your lambda example makes sense.
10:42:27 <joelteon> oh yeah, sorry about the fix example. that wasn't meant for your eyes
10:42:46 <isomorphismes> How is Œª better than PHP's $$$var ?
10:42:52 <isomorphismes> Maybe that's a stupid / overly broad question.
10:43:01 <joelteon> wait, what
10:43:07 <ezyang> Hey guys, this code requires UndecidableInstances: http://lpaste.net/91608
10:43:20 <isomorphismes> joelteon: thanks for th ehead $ tail $ example. I was trying to come up with a good test example to ask what that answered.
10:43:25 <typoclass> isomorphismes: how do you mean, lambda is better than $$$var?
10:43:25 <ezyang> How would you go about making it not need UndecidableInstances/is it an acceptable use of UndecidableInstances?
10:43:35 <ezyang> isomorphismes: They're not comparable.
10:43:45 <joelteon> right, they're not analogous
10:43:59 <Cale> isomorphismes: Lambda *roughly* corresponds to PHP's "function"
10:44:01 <c_wraith> ezyang: use typefamilies
10:44:02 <joelteon> $$$var is a form of eval, which haskell doesn't (readily) have
10:44:12 <joelteon> and lambdas are just functions that aren't bound to a name
10:44:12 <ezyang> OK, that's what I thought
10:44:26 <joelteon> I think new PHP has something like $lambda = function($arg) { ... }
10:44:38 <joelteon> which would be like let lambda = \arg -> ... in haskell
10:44:38 <zomg> joelteon: yes, it has had it for a while now
10:44:40 <Cale> i.e. (\x -> y) is vaguely similar to function ($x) { return y ; }
10:44:40 * typoclass has no idea bout php
10:44:46 <joelteon> i wrote PHP for awhile
10:44:48 <typoclass> *about
10:44:48 <joelteon> dark days
10:45:16 <zomg> As most things in PHP, anonymous functions are super clunky
10:45:16 <isomorphismes> typoclass: joelteon: <? $a = 'hello'; $$a = 'world'; echo "$a ${$a}" ?>
10:45:23 <joelteon> right
10:45:23 <c_wraith> ezyang: class Monad m => MonadError m where type Error m :: * ; throw :: Error m -> m a
10:45:29 <joelteon> but what do those have to do with lambdas, isomorphismes
10:45:33 <zomg> isomorphismes: I think most people who do PHP frown upon using variable variables
10:45:45 <zomg> I've never seen anyone actually think using them was a good idea except beginners =)
10:45:59 <isomorphismes> > head . tail $ [1..10]
10:46:01 <lambdabot>   2
10:47:48 <isomorphismes> Cale: thanks. ezyang joelteon zomg
10:48:01 <Cale> > let add x = (\y -> x + y); addFive = add 5 in addFive 10
10:48:02 <lambdabot>   15
10:48:54 <Cale> > let add x y = x + y; addFive = add 5 in addFive 10 -- of course, Haskell curries like this by default
10:48:55 <lambdabot>   15
10:49:03 <isomorphismes> zomg: joelteon Maybe nothing. I learnt of variable variables several years ago whilst doing a PHP project. Var vars seemed like the solution to something I had had trouble with in VBA (even more years before that).
10:49:27 <zomg> Yeah I think it might have some legitimate uses
10:49:29 <geekosaur> even php has better solutions (hashes) than vba does
10:49:36 <zomg> but I've never needed it during the 10+ years I've built web applications in PHP
10:49:52 <isomorphismes> PHP is great for what it is (i.e., expand the acronym)
10:50:14 <Cale> isomorphismes: But one point about lambda is that because the functions which are constructed capture the values of variables which are in scope when they're created, you can construct genuinely new functions at runtime, rather than simply referring to different statically defined functions by name.
10:50:48 <isomorphismes> Cale: I think you are getting at the heart of what I'm asking even though I'm not saying it well. I'm trying to think of how you would write e.g. Ackermann in lambda versus variable variables.
10:51:11 <isomorphismes> Cale: Or more generally anything that is classically known to "want" lambdas.
10:51:19 <Cale> For example, here's a list of functions, which add different amounts to their argument [(\x -> t + x) | t <- [1..10]]
10:51:47 <Cale> We can map ($ 10) over that list in order to apply each of the functions to the argument 10
10:51:56 <Cale> > map ($ 10) [(\x -> t + x) | t <- [1..10]]
10:51:57 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
10:52:14 <Cale> ($ 10) f = f $ 10 = f 10
10:53:10 <isomorphismes> Cale: These are great examples but I don't understand the syntax (->, <-). Great energy in this chatroom
10:53:23 <Cale> isomorphismes: Well, the -> is part of the syntax of lambdas
10:53:37 <Cale> (\x -> y) is the function which has x as a parameter and produces y as its result
10:53:40 <isomorphismes> Cale: So far I've only seen it with types e.g. f :: a->a->a->
10:53:43 <Cale> > (\x -> x + 5) 10
10:53:44 <lambdabot>   15
10:53:53 <Cale> > (\x -> x^2) 5
10:53:53 <typoclass> isomorphismes: a lambda always has the form \ ... -> ..."
10:53:54 <lambdabot>   25
10:54:17 <Cale> The other notation I used was list comprehension syntax
10:54:28 <Cale> > [x^2 | x <- [1..10]]
10:54:29 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:54:41 <Cale> This is the list of values of x^2 where x is chosen from the list [1..10]
10:55:39 <isomorphismes> Cale: thank you
10:55:40 <Cale> > [x + y | x <- [1,2,3], y <- [10,20,30]] -- we can pick from more than one list, and it will enumerate all the possibilities
10:55:41 <lambdabot>   [11,21,31,12,22,32,13,23,33]
10:56:59 <typoclass> > map (\x -> x ^ 2) [1..10] -- equivalent to cale's [x^2 | x <- [1..10]]. arguably it's a little simpler because i bet lyah discusses the map function before it discusses list comprehensions
10:57:01 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:57:05 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2] -- we can also add conditions which must be satisfied
10:57:06 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
10:58:25 <Cale> If you're familiar with set comprehensions in mathematics, this should be somewhat familiar
10:58:28 <isomorphismes> typoclass: hehe. nope =) list comprehensions in ch 1 and map not until later. Map seems like a really great tool. Like this Scott Locklin piece that went onto HN the other day discussing why apply() should replace loops.
10:58:48 <Cale> Lists are directly analogous to loops
10:59:15 <Cale> Just as a loop either doesn't occur at all (because its precondition isn't met, for instance), or consists of a single iteration followed by another loop
10:59:28 <typoclass> "a list is a loop that hasn't happened yet" ... :-)
10:59:35 <typoclass> isomorphismes: oh, alright
10:59:36 <Cale> A list either has no elements, (i.e. it is []) or consists of a single element followed by another list (i.e. it is (x:xs))
11:00:13 <isomorphismes> Cale: typoclass: Lists are "linked lists" correct? I.e. they are ordered
11:00:17 <Cale> yeah
11:00:19 <johnw> it always strikes me as odd for some reason that a list is isomorphic to a single element plus a list
11:00:42 <Cale> johnw: *or* an empty list of course :)
11:00:54 <johnw> sure, i'm thinking of possibly empty lists when I say that
11:00:56 <isomorphismes> johnw: What is odd about that? Just the length difference?
11:00:59 <Cale> oh
11:01:02 <johnw> List a ~ Cons a (List a)
11:01:25 <Cale> List a ~ 1 + a * List a
11:01:29 <isomorphismes> Is there a way I can ?Cons in ghci?
11:01:31 <johnw> right, exactly that
11:01:40 <Cale> isomorphismes: Cons is just what we call (:)
11:01:51 <Cale> > 1 : [2,3,4,5]
11:01:52 <lambdabot>   [1,2,3,4,5]
11:02:11 <Cale> Every list is built up from [] and (:)
11:02:21 <ijp> except the infinite ones
11:02:27 <johnw> in fact, [1,2,3] is just sugar for 1:2:3:[]
11:02:29 <Cale> Well, the infinite ones don't use []
11:02:50 <Cale> Yeah, and that's right associating, so 1 : (2 : (3 : []))
11:03:36 <isomorphismes> johnw: I think this is inherent to "interesting isomorphisms". Like the currying. Two things that are not obviously the same are shown to be "equivalent in some way". Baez/Dolan: "The least interesting equals sign is the truest one: x=x"
11:04:47 <isomorphismes> > 'zing' Cons ['boop', 'clang', 'bash', 'drip', 'fwrrrrrr']
11:04:48 <lambdabot>   Syntax error on 'zing'
11:04:48 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
11:04:55 <gdoteof> can someone help me with my monad/type problems in trying to generate a randomIP? http://pastie.org/8212266
11:05:26 <monochrom> wait, the coarsest one (for all x,y: x=y) is also least interesting
11:05:31 <Cale> gdoteof: You're going to want to *execute* rand255 four times
11:05:51 <geekosaur> haskell is not shell/perl/python, you can't use '' around String-s, only individual Char-s
11:05:55 <Cale> gdoteof: The most basic way to do this using do notation would be to write (somewhat tediously)
11:05:56 <typoclass> > "zing" : ["boop", "clang"] -- fixed
11:05:57 <lambdabot>   ["zing","boop","clang"]
11:06:08 <S_J> 1. what features of haskell demand garbage collection? 2. What makes the runtime so big?
11:06:37 <typoclass> > 'a' -- as opposed to "abc", here is a single Char. it's not allowed to have 'abc'
11:06:38 <lambdabot>   'a'
11:07:04 <Cale> do x1 <- rand255; x2 <- rand255; x3 <- rand255; x4 <- rand255; return (intercalate "." [x1,x2,x3,x4])
11:07:22 <isomorphismes> johnw: Cale: ~ is the == sign of other languages?
11:07:27 <isomorphismes> monochrom: Good point!
11:07:45 <Cale> isomorphismes: It's what GHC Haskell uses for type level equality
11:07:56 <isomorphismes> Cale: thank you
11:07:56 <Cale> isomorphismes: and we're using it somewhat informally
11:08:02 <c_wraith> S_J: the only thing demanding garbage collection is that programmers expect to not run out of memory.
11:08:26 <c_wraith> S_J: did you want to ask what precludes manual memory management instead?
11:08:46 <Cale> gdoteof: Of course, that's tedious, so we would hope to have some way to say "run this action n times and give me a list of the results". If this didn't already exist in the libraries, we could write it:
11:08:59 * geekosaur wonders what S_J is really trying to ask
11:09:07 <Cale> times 0 x = return [] -- running something 0 times will give an empty list of results
11:09:44 <S_J> c_wraith: ok, what precludes it?
11:09:48 <gdoteof> Cale: okay, thanks.  i am still running into type issues though; ic an't get it to compile, even giving me the same 4 triads
11:09:51 <Cale> times n x = do v <- x; vs <- times (n-1) x; return (v:vs) -- running something n times will run it once, and then run it n-1 more times, and collect the results into a list
11:10:10 <Cale> oh, did the code I wrote not work for some reason?
11:10:28 <gdoteof> cale, let me see.  i will rewrite and show error one sec
11:10:29 <c_wraith> S_J: iterate f x = x : iterate f (f x)
11:10:47 <Cale> gdoteof: This 'times' is available in Control.Monad as replicateM
11:11:14 <c_wraith> S_J: are you familiar with haskell's execution model?  How that function works?
11:11:17 <Cale> So you could also write  do ns <- replicateM 4 rand255; return (intercalate "." ns)
11:11:25 <isomorphismes> ijp: Can you give an example of how you would write an infinite list in Haskell? Let's say continuous functions which pass through origin.
11:11:45 <Cale> Or if you want to be fancy, that's the same as  fmap (intercalate ".") (replicateM 4 rand255)
11:12:07 <c_wraith> isomorphismes: infinite lists in haskell are still conceptually indexed by integers. They can't be continuous.
11:12:24 <typoclass> > [0..] -- isomorphismes: here is an infinite list. lambdabot (of course) will print only a bit at the beginning
11:12:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:12:57 <isomorphismes> c_wraith: bummer!!!
11:12:57 <sirspazzolot> why are Enum and Ord distinct typeclasses? I'd think enum implies ord and ord implies enum, wouldn't you?
11:13:17 <monochrom> I am not convinced that Ord implies Enum.
11:13:22 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
11:13:23 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:13:24 <S_J> c_wraith: no?
11:13:34 <S_J> lazily?
11:13:42 <Cale> ^^ the infinite list of primes :)
11:14:13 <sirspazzolot> monochrom: what could have orderings but no sequence? aren't those synonyms, really?
11:14:13 <gdoteof> error: http://pastie.org/8212291    code: http://pastie.org/8212297
11:14:17 <gdoteof> Cale: ^^
11:14:38 <n-dolio> > [[1] .. [3]]
11:14:39 <lambdabot>   No instance for (GHC.Show.Show t0)
11:14:39 <lambdabot>    arising from a use of `M974879997.sho...
11:14:44 <monochrom> before I answer that, do you have a sketch proof for "Ord implies Enum"?
11:14:51 <alkabetz> gdoteof: Ah, you need -XOverloadedStrings (or put {-# LANGUAGE OverloadedStrings #-} at the top of your file)
11:14:53 <n-dolio> Well, that's great.
11:15:18 <alkabetz> gdoteof: (There are other problems, too, but that‚Äôs the first)
11:15:20 <mirari> :t Ord
11:15:21 <lambdabot> Not in scope: data constructor `Ord'
11:15:23 <gdoteof> alkabetz: sorry i have that
11:15:28 <gdoteof> missed it in the copy
11:15:46 <Cale> gdoteof: can I see your current code?
11:15:48 <sirspazzolot> monochrom: no, I'm just reading through lyah and got confused. but I think I get it
11:15:55 <gdoteof> if i remove the IO from the rand255 and randIp i get: http://pastie.org/8212302
11:15:58 <Cale> oh, I missed the second link
11:16:05 <monochrom> then consider the rational numbers
11:16:12 <alkabetz> gdoteof: No, you definitely want the 'IO' in there.
11:16:15 <typoclass> mirari: Ord is a typeclass, not a type, therefore :t won't work
11:16:15 <c_wraith> S_J: well, yes, lazily. But more than that, it defers execution a bunch. The very first thing it does is construct a thunk for the application (f x).  Then it constructs a thunk for the application (iterate f (f x {- this is the thunk created previously -})). Then it applies the constructor (:) to x and the last thunk, and returns the value.  At no point is either x or (f x) actually evaluated.
11:16:24 <Cale> Yeah, your problem now is that t1 ++ "." ++ t2 ++ ... ++ t4 isn't an IO action
11:16:30 <Cale> and you want to return that
11:16:32 <sirspazzolot> monochrom: I was thinking lists, but yeah rational numbers are a better counter-example
11:16:35 <sirspazzolot> thank you!
11:16:49 <Cale> return (t1 ++ ... ++ t4) should work
11:16:55 <mirari> typoclass: is there any way to print information about it?
11:17:30 <Cale> gdoteof: Each line of the do block has to be an action (in the same monad, which in this case is IO)
11:17:31 <typoclass> mirari: you can look it up in the haddock, and also:
11:17:33 <typoclass> @instances Ord
11:17:34 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:17:42 <alkabetz> mirari: You can also do :i Ord or :k Ord
11:17:58 <n-dolio> > [1%5 .. 11%5]
11:17:59 <lambdabot>   [1 % 5,6 % 5,11 % 5]
11:18:15 <mirari> typoclass, alkabetz, thanks that is very useful :)
11:18:21 <isomorphismes> sirspazzolot: en.wikipedia.org/wiki/Poset
11:18:35 <gdoteof> Cale: okay; that changed my errors at least; thanks.  one sec
11:19:03 <Cale> btw, there's no good reason to be using unsafePerformIO like that
11:19:08 <isomorphismes> sirspazzolot: Maybe you are confusing "order" with "total order"? Or think rock papers scissors where trans. is violated i.e. A>B>C>A
11:19:30 <monochrom> Ord is total order
11:19:48 <isomorphismes> well nevermind then =)
11:19:57 <isomorphismes> I just think posets are nifty =)
11:20:03 <c_wraith> S_J: so the expression (take 5 $ (iterate (+1) 0)) is going to look something like (0 : 0+1 : 0+1+1 : 0+1+1+1 : 0+1+1+1+1 : []) in memory (abstractly).  Which is all well and good when 0 and 1 are constants.  But what if it was (iterate (+y) x)?
11:20:13 <sirspazzolot> rock paper scissors is another good way to think. I'll read the poset article tonight, but I at least have to pretend I'm productive at work right now
11:21:08 <Cale> c_wraith: It's worth pointing out that each element of that list will point at the previous one when you view it as a graph
11:21:28 <isomorphismes> sirspazzolot: Enum shouldn't imply Ord in my opinion because if every list is indexed by integers then it is enumerable but clearly not every list has a unique order (numbers by alphabetical sort vs numbers by numerical sort)
11:21:51 <c_wraith> Cale: true, but doesn't actually change the point I'm heading towards. :)  S_J: note Cale's comment above
11:22:00 <monochrom> use "boss mode" to pretend to be productive. it means the screen displays just "C:\>". it is provided by many DOS games. :)
11:22:17 <sirspazzolot> isomorphismes: good point
11:22:20 <c_wraith> S_J: So if you had (let x = 2; y = 5 in take 5 $ iterate (+y) x) - you can't deallocate x and y just because the expression has been evaluated.
11:22:57 <c_wraith> S_J: you need to wait until all references to either of them are no longer needed
11:23:01 <Cale> (okay, I was missing some context on that thread of conversation :)
11:23:37 <c_wraith> S_J: and as code gets a bit more sophisticated, that becomes an *incredible* amount of overhead to keep track of, if you're responsible for freeing all memory yourself.
11:24:30 <Cale> Garbage collectors these days tend to do a better job of freeing and compacting memory than humans manage to do by hand in real projects.
11:24:40 <c_wraith> S_J: It becomes easier to say "this is a ton of tedious bookkeeping.  You know what's good at tedious bookkeeping?  Computers!  I'll let the computer take care of it for me."
11:25:25 <S_J> c_wraith: I really would like a better C. Type safety, equational functions, dividing functions into pure and unpure.
11:25:33 <c_wraith> S_J: look at Rust, then
11:25:46 <c_wraith> S_J: that's exactly what Rust is aiming for.  Haskell is meant to be higher-level
11:25:53 <isomorphismes> typoclass: I tried @instances Ord in my ghci (am working thru everyone's examples just above) but @instances Ord doesn't work. :info Ord does something else.
11:25:55 <S_J> If you have a lang that is not turing complete, like agda. what can you not do then? what about a communication stack?
11:26:01 <c_wraith> Well, Rust doesn't divide into pure and impure
11:26:32 <typoclass> isomorphismes: oh, try ":i Ord". in general, the syntax of ghci is somewhat different from the syntax of lambdabot
11:26:37 <alkabetz> S_J: Wait, Agda‚Äôs not Turing complete‚ÄΩ
11:26:41 <c_wraith> But it's got a solid type system that tracks ownership of memory, meaning that whether you're allowed to modify memory is clearly marked in the types of the functions
11:27:00 <c_wraith> alkabetz: it's not turing complete unless you disable the termination checker
11:27:17 <josephle> alkabetz: in general, total languages are not turing complete as we lost the Y-combinator
11:27:20 <isomorphismes> typoclass: thanks. is there a place i can look this up? I appreciate everyone's great examples of these basics.
11:27:51 <c_wraith> But that's ok.  You don't actually *want* Turing completeness.  You want all of your algorithms to terminate.
11:28:04 <alkabetz> c_wraith, josephle: Can‚Äôt you model nontermination using codata?
11:28:25 <c_wraith> alkabetz: of a sort.  You can model "did some work, here's the rest of the computation"
11:28:38 <typoclass> isomorphismes: for ghci commands, try ":help". for lambdabot commands, i think the best documentation is this channel
11:28:45 <c_wraith> alkabetz: you can't model "and by the way, I can prove the computation will finish after some number of steps"
11:29:38 <josephle> c_wraith: does the termination checker allow the use of coinductive types?
11:29:41 <monochrom> isomorphismes: the GHC user's guide may already be on your hard disk
11:30:08 <c_wraith> josephle: sure.  corecursion over codata terminates when you return a constructor.
11:32:06 <josephle> c_wraith: this is true
11:33:15 <Cale> isomorphismes: My view on Enum is that it should *only* be what is required to define the enumerated list syntax, i.e. it should include enumFrom (which defines [x..]), enumFromTo (which defines [x..y]), enumFromThen (which defines [x,y..]) and enumFromThenTo (which defines [x,y..z]). The other stuff doesn't really belong -- and certainly not at type Int.
11:34:16 <johnw> sigh, I woke up today thinking that Async could be a Comonad, but then realized it's Async a -> IO a, of course
11:34:53 <c_wraith> johnw: yeah, anything that wraps IO is going to have trouble being a Comonad. :)
11:35:08 <johnw> I was thinking you could "extend" an async computation by tacking on further async computations; but it appears that Async is already a pretty decent Functor, and it extends the computation by fmap'ing the underlying STM action
11:35:09 <Cale> johnw: Par could be.
11:35:28 <johnw> true, Par could be!
11:35:33 <johnw> thanks Cale
11:35:44 <johnw> I was thinking of Eval at first, but Par might be a better toy to play with
11:35:55 <isomorphismes> Cale: Maybe this is the difference between "Enumerable" and "Enumerated"?
11:35:58 <Cale> (though I'm not sure how useful its duplicate would be)
11:36:30 <johnw> Cale: I kind of ruled out Par at first because Marlow says nested runPar's kill performance
11:36:34 <Cale> isomorphismes: Well, this would be a way to avoid most of the expectations which people have when they see the current operations in the class.
11:37:44 <ReinH> johnw: have you read his new Parallel and Concurrent Programming  in Haskell?
11:38:17 <johnw> ReinH: yes, just finished it this past weekend
11:38:28 <Cale> I've skimmed it and it looks good, especially good for beginners who have finished their first tutorial and are prepared to learn something about performance of Haskell programs.
11:38:47 <ReinH> johnw: it's great
11:38:53 <johnw> ReinH: in fact, it inspired me to write this: http://hackage.haskell.org/packages/archive/stm-conduit/2.1.1/doc/html/Data-Conduit-Async.html
11:39:20 <ReinH> johnw: oh, excellent, now we can talk about backpressure!
11:40:21 <ReinH> johnw: "In general you should be able to replace any use of $$ with $$& and suddenly reap the benefit of concurrency"
11:40:42 <ReinH> nice, and I assume the & is borrowed from the shellism?
11:40:59 <rookie_haskell> hello everyone :)
11:41:05 <ReinH> rookie_haskell: hi
11:41:05 <johnw> yep
11:41:09 <ReinH> johnw: nice
11:41:18 <Cale> hello!
11:41:41 <ReinH> is it just me or has #haskell gotten friendlier than when I first started coming here? :D
11:41:54 <rookie_haskell> haha :D
11:41:55 <Cale> It's always been pretty friendly
11:42:02 <rookie_haskell> im totally new to Haskell
11:42:10 <ReinH> Cale: I think I was just intimidated :)
11:42:15 <Cale> There might be some differences based on the time of day and who is watching :)
11:42:21 <rookie_haskell> can someone help me with some syntax problem
11:42:28 <ReinH> rookie_haskell: I envy you. You have so much awesome stuff to learn.
11:42:37 <Cale> rookie_haskell: sure, use lpaste.net to paste your code
11:43:04 <rookie_haskell> i think it's not require
11:43:11 <rookie_haskell> since it's really small
11:43:13 <Cale> okay
11:43:16 <typoclass> ReinH: possibly. i kinda thought in the last 1-2 years there was a phase of being less friendly, but that seems to be over. we seem to be back to normal levels since several months ago. so if you joined during that phase ...
11:43:35 <rookie_haskell> if i see -> * in type signature
11:44:13 <rookie_haskell> like 'data X :: Y -> * -> *
11:44:25 <Cale> That is a kind signature
11:44:29 <rookie_haskell> the star means?
11:44:30 <Cale> kinds are the types of types
11:44:38 <Cale> * is the kind of all types which have values
11:44:50 <rookie_haskell> so it's a general type?
11:44:54 <Cale> * -> * is the kind of type constructors
11:44:59 <Cale> For example, Maybe :: * -> *
11:45:05 <Cale> Integer :: *
11:45:07 <rookie_haskell> ummm
11:45:13 <Cale> and so Maybe Integer :: *
11:45:24 <rookie_haskell> haha
11:45:28 <typoclass> rookie_haskell: i think as a beginner, you don't usually need to worry about kinds very much. types and values are enough worries :-)
11:45:35 <alkabetz> Yeah, where are you seeing this code?
11:45:46 <S_J> Is HARD realtime not possbile to do with garbage collection?
11:45:50 <rookie_haskell> so i can fill in any type i wish?
11:46:28 <c_wraith> S_J: no, actually.  You can do hard realtime with GC.  Let me see if I can find that paper..
11:46:29 <Cale> rookie_haskell: Yeah, this means that X is a type constructor, which takes a parameter of kind Y (whatever that is), and a parameter of kind * (which is an ordinary type), and produces a type.
11:46:52 <rookie_haskell> cool :)
11:46:54 <rookie_haskell> thanks
11:47:01 <c_wraith> S_J: http://michaelrbernste.in/2013/06/03/real-time-garbage-collection-is-real.html
11:47:23 <c_wraith> S_J: however, it does force the constraint upon the programmer that they allocate at a rate lower than what the GC can collect.
11:47:24 <johnw> S_J: If you have real-time constraint for an algorithm, you could always postpone garbage collection until after that algorithm
11:47:44 <johnw> though I'm not sure if GHC offers a way to pause the GC...
11:47:58 <c_wraith> GHC does not.
11:48:33 <Cale> If you want to do hard realtime stuff with Haskell, you probably want to use Haskell as a metalanguage / static scheduler.
11:48:41 <Cale> See Atom, for an example of that approach.
11:49:08 <johnw> it seems odd to me now that we can postpone delivery of async exceptions, but not postpone GC...
11:49:20 <typoclass> S_J: it depends on what you mean by hard realtime, and for what you plan to use it
11:49:21 <Cale> (that has nothing to do with the question of GC though)
11:49:57 <johnw> S_J: http://stackoverflow.com/questions/1263711/using-haskell-for-sizable-real-time-systems-how-if
11:57:54 <S_J> well hard means not soft. i see haskell for soft but def not hard
11:58:43 <Cale> S_J: It would probably be possible to construct a Haskell runtime which satisfied *some* hard realtime constraint, but GHC Haskell doesn't.
11:59:10 <typoclass> S_J: well, if you have a requirement that the process guarantees to respond within 100 ms, just design a garbage collection algorithm that is guaranteed to run in less than 100 ms
11:59:17 <c_wraith> The thing is, hard realtime GC is *slow*.  Most of the time, you care about throughput much more.
11:59:26 <c_wraith> and so that's where all the development work goes
12:02:11 <luite> c_wraith: hmm, you need incremental marking and incremental evacuation, that both seems reasonably doable with ghc's runtime. what are the other problematic points?
12:03:16 <c_wraith> luite: well, there's a semantic concern too.  If you're hard-realtime, it's quite possible you'll allocate faster than you collect, and the program will eventually run out of memory even though the working set size is bounded.
12:03:39 <c_wraith> luite: and I don't see *any* automated way of dealing with that.
12:05:44 <luite> c_wraith: right, but i think failure is acceptable there, then the system is just not powerful enough for the requirements (similar to when your computatiosn takes too many cycles or too much memory bandwidth)
12:07:31 <c_wraith> luite: oh, one technical issue - you would have to change when the GC runs.
12:08:20 <luite> ah that's right
12:09:36 <c_wraith> All of this is clearly feasible engineering work.  There are known techniques.  But it's a lot of work adding and maintaining another runtime.
12:10:18 <luite> yeah i was just wondering if you had thought or read about specific issues. i quickly googled but only found a paper from 1999
12:11:01 <c_wraith> Not something I've ever studied.  The article I linked above got me thinking about it, but there's a lot I don't know.
12:11:20 <merijn> luite: If failure is acceptable, then the system would probably be soft real time to begin with
12:11:43 <luite> merijn: i mean failure as in abort everything
12:11:50 <merijn> luite: Yes, I know
12:12:12 <merijn> luite: How is aborting everything different from saying "oh, screw it, we'll just miss a deadline"?
12:12:19 <Zenol> c_wraith: Thanks for the link :)
12:12:50 <S_J> if my database is an .exe, how would i communicate with it? process to process? via sockets?
12:13:15 <luite> merijn: with soft realtime not all deadlines need to be met, failure means degraded quality not shutdown
12:13:30 <merijn> luite: The definition of hard realtime is that missing a deadline is considered a complete systems failure, usually, because missing some deadline has hard, real world consequences, think nuclear control systems, airplane systems, etc.
12:13:33 <ReinH> luite: I think merijn is saying that's a difference of degree, not kind
12:13:57 <ReinH> from the perspective of hard realtime, a failure is a failure
12:13:58 <merijn> luite: I cannot think of a single system where hard realtime is important, but complete system failure is considered tolerable
12:14:40 <luite> merijn: i didn't say it was tolerable
12:14:43 <merijn> luite: i.e. obtaining hard realtime by introducing complete system failure is a case of out of the frying pan, into the fire
12:14:48 <ReinH> Also almost every real-world system is on a continuum between hard and soft, so the dichotomy isn't always a useful way of understanding systems
12:15:11 <ReinH> almost every system tolerates some amount of failure
12:15:33 <ReinH> I should say "most" because "almost every" has a mathematical meaning I don't intend.
12:15:39 <johnw> unlike that build of GHC which deleted your source code in the presence of type errors? :)
12:15:47 <merijn> ReinH: No, you are thinking of faults, lemme check up on the exact terminology
12:15:51 <S_J> in Cabal, under other-modules, do I need to list them all?
12:16:01 <dcoutts> S_J: yes
12:16:10 <S_J> How do I make 2 different build options? one for test and one for the actual program?
12:16:16 <johnw> S_J: use flags
12:16:19 <merijn> ReinH: There is a concrete difference between the notion of fault, error and failure, in the reliable computing/engineering world
12:16:26 <johnw> define it like so:
12:16:28 <johnw> flag dev
12:16:28 <johnw>     default: False
12:16:28 <dcoutts> S_J: or use a test-suite, which is a special kind of exe
12:16:34 <johnw> then later use if flag(dev)
12:16:43 <johnw> then you can: cabal install -fdev ...
12:16:46 <merijn> ReinH: https://vikashazrati.wordpress.com/2008/10/30/fault-failure-error/
12:16:55 <dcoutts> S_J: ie make it it's own separate program, but in the same .cabal file
12:17:02 <johnw> yeah, or two separate executables
12:17:04 <johnw> dcoutts: hello!
12:17:08 <dcoutts> hia :-)
12:17:08 <S_J> but you mean if flag in the application? that is bad? i want to give it to cabal. cabal build test or cabal build program
12:17:15 <ReinH> merijn: if those are the terms then yes.
12:17:24 <S_J> dcoutts: yes but how?
12:17:33 <johnw> dcoutts: cabal has been causing me much sorrow of late
12:17:39 <merijn> ReinH: A system that suffers failure is no system. You are right that most real world system can and should tolerate a certain amount of errors/faults, though
12:17:48 <dcoutts> S_J: see the user guide about test-suites, or look at an example
12:18:21 <merijn> Or rather, of course systems can suffer failure, but by definition of the term failure, that is something to be avoided at all costs :)
12:18:30 <ReinH> merijn: actually, that's not my reading
12:18:43 <ReinH> merijn: my reading is that a fault is a *potential failure*.
12:18:50 <bergmark> S_J: example: https://github.com/faylang/fay/blob/master/fay.cabal
12:18:55 <ReinH> A fault is "An incorrect step, process, or data definition in a computer program"
12:19:02 <luite> ReinH: it does give a definition of failure in the second point
12:19:05 <ReinH> that "... lead to a failure when the exact scenario is met."
12:19:06 <dcoutts> S_J: basically it's the same as an executable, but use test-suite and list type: exitcode-stdio-1.0
12:19:10 <Zenol> it woul be fantastic if irc conversations of a cannal could be regrouped as short-lived thread, so that you can read them more easily :/
12:19:14 <luite> and i still think it's a valid failure
12:19:32 <dcoutts> johnw: new release due soon with sandboxing and repl support! :-)
12:19:38 <johnw> dcoutts: eagerly awaited!
12:19:48 * typoclass finds the writing in that blog post pretty confusing. and it's not a good sign that he's not giving any links to sources
12:19:51 <johnw> dcoutts: my problems came from trying to make use of a C++ library that was being built by Cabal
12:20:04 <dcoutts> johnw: c++ is a pita
12:20:06 <merijn> ReinH: A system that suffers failure after a fault, does not conform to the specs and is thus wrong
12:20:07 <ReinH> merijn: by analogy to security, a fault is a vulnerability; a failure is an exploited vulnerability.
12:20:15 <dcoutts> johnw: the linking especially
12:20:20 <ReinH> merijn: my reading is that a fault is not an event
12:20:37 <ReinH> it's an "inherent weakness", not an event in the system
12:20:41 <johnw> dcoutts: in the end I had to break my project up into 4 separate cabal projects in order to make it all work (part of my pain involved template haskell loading shared libraries which depended on objects file built by my cabal file!)
12:20:50 <ReinH> I think it's quite clear, actually:
12:20:50 <ReinH> "It is an inherent weakness of the design or implementation which might result in a failure."
12:20:58 <dcoutts> johnw: ugg
12:21:00 <merijn> ReinH: Did you read the definition of failure?
12:21:31 <merijn> ReinH: Your specs you should specify how big and which faults you tolerate. Failure on a fault within those ranges means the system is wrong
12:21:32 <dcoutts> johnw: sounds like you'd benefit from "private" libs
12:21:35 <luite> merijn: if you allocate a lot the rts has to dedicate more and more cpu time to the gc to keep up. the only way to avoid (or probably in most cases slightly postpone) failure is to let the gc run behind. that's something that you can check in simulation an debugging, find out that the hardware is just not adequate
12:21:50 <johnw> dcoutts: oh, haven't heard of those...
12:21:56 <luite> merijn: doesn't seem to me that failing there makes it a non-hard-realtime system
12:22:14 <Igloo> johnw: Are you using GHC HEAD with the released Cabal?
12:22:19 <merijn> luite: What if you can't proof whether it will run behind until a certain runtime input?
12:22:24 <dcoutts> johnw: it's not implemented, but it's a feature idea, multiple libs in a .cabal file, but all the other ones are private, used by the main lib or by exes in the same package
12:22:32 <johnw> Igloo: 7.4.2 with Cabal 1.16.0.3
12:23:10 <ReinH> merijn: yes, a failure is what happens when the running system encounters a fault from which it cannot recover
12:23:11 <Igloo> johnw: Oh...so those shared libraries aren't Haskell libraries, then?
12:23:25 <ReinH> (within specified performance requirements)
12:23:30 <johnw> Igloo: no
12:23:34 <merijn> luite: I know people doing worst case execution time analysis in embedded systems, they even account for caches being evicted by other operations, etc. to guarantee the worst case execution time can be met
12:23:43 <ReinH> merijn: what were we arguing about again? :)
12:23:47 <johnw> Igloo: I'm building C++ client code which is intended to make up part of the executable which will make use of the shared library
12:24:07 <merijn> luite: If you told them "just run a simulation and cross your fingers that you run into the worst case" will not be accepted :)
12:24:11 <merijn> luite: Thank god
12:24:27 <johnw> I ended up also needing a fairly complex Setup.hs to hack options that you can't control from within the Cabal file (there is another issue open about this too)
12:24:57 <dcoutts> johnw: I'd really need to see an explanation of the overall organisation of the dependencies of this thing
12:25:21 <johnw> dcoutts: if you're really interested, I'd be happy to chat with you voice so that I can lay it all out; but it may be more information than you're interested in
12:25:26 <merijn> ReinH: You were saying that every system is a continuum of between hard and soft and I was saying that hard/soft is a discrete line, the continuum is in the size of faults to be tolerated
12:25:40 <dcoutts> johnw: you can post it to cabal-devel as a use case
12:25:59 <luite> merijn: but this doesn't make it impossible to prove this, does it? a garbage collector makes it more complex, but it can still have upper bounds for the amount of work that has to be done for each allocation
12:26:01 <johnw> it involves using gSOAP (a C++ library) to build a SOAP client in Haskell (via FFI and extern "C" functions)
12:26:24 <ReinH> merijn: what is the difference between hard and soft real time?
12:26:31 <merijn> luite: Sure, by having a deterministic allocator, but do you have any clue how *hard* that is to proof?
12:26:42 <johnw> ok, but it may be a while before I post.  I want that pain behind me for the time being, and it would take a bit of effort to convey it all in a sensible fashion for the ML
12:26:48 <luite> merijn: not very hard if you don't really care about tight upper bounds ;)
12:26:51 <ReinH> merijn: isn't it that hard means missing a deadline constitutes a failure
12:26:53 <merijn> luite: We're not even close to having a GC that's good enough for that
12:27:39 <ReinH> merijn: whereas in a soft system a missed deadline results in a reduced quality of service but not a failure?
12:27:51 <ReinH> not quite.
12:28:05 <merijn> ReinH: hard means that missing a deadline is considered a complete system failure, so if your system is to conform to specs it should be impossible to miss deadline within the input/event constraints of the spec
12:28:21 <ReinH> merijn: there is only one kind of failure: complete system failure
12:28:26 <ReinH> everything else is a recovered fault.
12:28:45 <ReinH> using the terms as defined
12:28:46 <merijn> ReinH: Yes, I'm mixing my terminology from different fields :>
12:28:52 <ReinH> merijn: this is why it's hard :)
12:28:56 <dcoutts> johnw: I see, sure
12:28:59 <ReinH> pun not intended
12:29:57 <merijn> ReinH: In soft real time there is flexibility in how many deadlines you can miss before it's considered a failure, maybe you could even miss all and still conform to spec
12:30:05 <ReinH> merijn: not quite...
12:30:17 <ReinH> well yes but there is a further distinction to be made
12:30:42 <ReinH> in soft real time results decrease in utility after their deadline
12:30:48 <ReinH> in 'firm' real time systems, results are useless after their deadline
12:30:54 <ReinH> but the system can still recover from a number of missed deadlines
12:31:32 <ReinH> soft real time systems generally experience missed deadlines as reduced QoS, not failure
12:31:45 <ReinH> (up to some upper bound)
12:31:46 <merijn> Yes, that's what I just said, no? :)
12:32:02 <ReinH> merijn: that was more of a "yes and" than a "no but" :)
12:32:03 <merijn> Albeit in significantly less words :p
12:32:07 <ReinH> merijn: :p
12:32:50 <luite> -blah?
12:33:12 <ReinH> merijn: my main experience with real time systems is DSP
12:33:20 <ReinH> and Haskell can do DSP
12:33:30 <ReinH> (hard real time, that is)
12:33:38 <danilo2> Hi! Could you tell me please, if I want to create a "shared" TypeClass between some libraries, do I have to put it in a separate library, or is there a way to tell Haskell, that these libraries are using the same module and the same TypeClass? (more detailed question, I've posted here: http://stackoverflow.com/questions/18087398/external-module-available-for-libraries-in-haskell) Than you :)
12:33:40 <ReinH> but can it do it in real time?
12:34:48 <haasn> danilo2: there's no way to define a data type in two separate places but have GHC treat them identically, if that's what you're asking
12:35:00 <monochrom> danilo2: yes, put it in a separate library
12:35:00 <ReinH> danilo2: The more correct answer is that only one library can define the typeclass
12:35:06 <merijn> ReinH: Haskell, maybe (although probably not without huge amounts of effort), GHC haskell almost certainly not
12:35:25 <ReinH> danilo2: one library can define the typeclass and some instances and the other library can add more instances, but you cannot define the typeclass in both
12:35:42 <haasn> danilo2: (the same answer goes for type classes)
12:35:44 <ReinH> danilo2: it's pretty common to see packages like foo and foo-extras, where foo-extras defines more instances for a typeclass Foo
12:36:01 <haasn> but beware of orphan instances
12:36:18 <ReinH> (I guess that's usually called foo-instances)
12:36:31 <danilo2> haasn, monochrom, ReinH: Than you :)
12:36:47 <monochrom> orphan instances won't happen if you put "data DA = ..." and "instance X DA ..." in the same file
12:37:20 <danilo2> monochrom: I know - I know about orphan instances and I know that when you're carefull they will not hurt you :)
12:37:39 <monochrom> orphan instance is iff "data DA", "class X", "instance X DA" are in 3 separate files.
12:38:07 <monochrom> "orphan instance is a 3-body problem" :)
12:38:45 <c_wraith> psh. exact general solutions are known for the 3-body problem.  They're just slow. :)
12:38:51 <monochrom> also, orphan instance is only a compiler-performance problem
12:39:07 <danilo2> monochrom: I know, but if the file in which instance is defined imports and reexports the module in which datatype is defined (and you always use this file) than orphjan instances are nothing wrong - of course such desing is a mess - but we are talking no completely thoretically :)
12:40:06 <danilo2> monochrom: did you tell that orphan instances cause lower performance?
12:40:19 <monochrom> yes
12:40:31 <merijn> monochrom: Well, also a "someone could add this instance and then your code will break" thing (which doesn't really apply in the case of providing a foo-instances module)
12:40:36 <danilo2> monochrom: could you please tell more about it?
12:40:47 <monochrom> the compiler has to recompile more files
12:41:15 <danilo2> monochrom: ahh ok, so you are talking about the peformance of compilation process, noit the final application?
12:41:22 <monochrom> yes
12:41:28 <haasn> danilo2: the way I see it, either ‚ÄòX‚Äô has something to do with either ‚ÄòA‚Äô or ‚ÄòB‚Äô, meaning it would be fair to put it one of the libraries, or it has nothing to do with those in particular, in which case it would be fair to make it a seperate library
12:42:54 <gdoteof> i have randKey :: IO Text
12:42:54 <gdoteof> randKey = return $ pack $ take 8 $ randomRs ('a','z') $ unsafePerformIO newStdGen
12:42:56 <danilo2> haasn: I've got here a little more complex case. Lets say I want to define set of 10 functions, that would be common for datatypes defined in different libraries (by different users). So the simplest solution here is to put it in separate library i think :
12:43:17 <gdoteof> however i am only getting one randKey :: Text per run/compile
12:43:27 <monochrom> since you have decided on "IO Text", why still unsafePerformIO?
12:43:27 <gdoteof> further calls to randKey keep giving me the same random text
12:43:40 <merijn> gdoteof: Please tell me that is not for any form of crypto
12:43:41 <monochrom> and yes that's what you get for unsafePerformIO
12:43:42 <merijn> Also
12:43:48 <merijn> @quote is.not.a.bug
12:43:49 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
12:44:00 <gdoteof> monochrom: eh cus noob; prob.
12:44:07 <gdoteof> merijn: it is the basis for haskellCoin ;-)
12:44:15 <gdoteof> no, it is just place holder text
12:44:42 <haasn> the proper solution would of course be to provide lenses and then generalize the combinators you need to accept all lenslikes ;)
12:44:52 <merijn> gdoteof: Ok, just realise that that is pretty much horribly unsafe for any form of crypto
12:45:01 <merijn> gdoteof: Furthermore, you are probably wanting fmap
12:45:03 <merijn> :t fmap
12:45:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:45:14 <merijn> :t randomRs
12:45:15 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
12:45:38 <optimus`> what does this mean
12:45:39 <merijn> :t fmap (randomRs ('a','z'))
12:45:40 <lambdabot> (Functor f, RandomGen a) => f a -> f [Char]
12:45:41 <optimus`> Program error: Prelude.!!: index too large
12:45:52 <merijn> optimus`: The argument to !! is bigger than your list
12:45:52 <haasn> instance Functor IO where fmap f = return . f . unsafePerformIO
12:46:04 <optimus`> thanks
12:46:24 <haasn> (oh, I'm kidding, don't take that line seriously gdoteof)
12:46:38 <gdoteof> ok o.o
12:46:40 <merijn> gdoteof: Basically, rather than trying to get your StdGen out of IO, you should be using "fmap" to put the non-IO functions inside the IO
12:48:20 <gdoteof> merijn: sorry i am not quite understanding how to do that here.
12:49:11 <haasn> gdoteof: you should probably forget ‚ÄòunsafePerformIO‚Äô exists
12:49:19 <monochrom> (pack . take 8 . randomRs ('a','z')) `fmap` newStdGen
12:49:45 <merijn> gdoteof: "fmap :: Functor f => (a -> b) -> f a -> f b" IO happens to be a Functor, so you can read it as "fmap :: (a -> b) -> IO a -> IO b"
12:50:15 <gdoteof> ah; okay.
12:50:25 <monochrom> do { x <- newStdGen; return (pack $ take 8 $ randomRs ('a','z') x }
12:50:38 <gdoteof> i can also:  g <- newStdGen; return (...) randomRs ('a','z') g
12:50:39 <monochrom> err
12:50:42 <monochrom> do { x <- newStdGen; return (pack $ take 8 $ randomRs ('a','z') x) }
12:50:46 <haasn> pack . take 8 . randomRs ('a','z') <$> newStdGen
12:50:46 <monochrom> yes
12:52:36 <haasn> I can't think of a very elegant lensy way to do this :(
12:53:56 <gdoteof> okay; how can I make randomRs just give me alphanumeric?
12:54:17 <ParahSailin> :t randomRs
12:54:18 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
12:54:54 <haasn> by writing your own Random instance I guess
12:54:54 <haasn> or uh
12:54:54 <gdoteof> haasn: okay
12:55:11 <S_J> IO (Maybe [(String, String, String)]) How do I apply a function to the list?
12:55:14 <haasn> actually I would just use randomR (0, 36) -- and convert that to base 36 ;-)
12:56:02 <monochrom> put alphanumerics in an array. do what hasan says and the array
12:56:11 <haasn> or (0,35)
12:59:38 <carter> chrisdone : is the css used for the demo theming somehwere?
12:59:38 <geekosaur> S_J: fmap . fmap ?
12:59:38 <haasn> > mkStdGen 0 ^. to (randomRs (0,35)).traverse.re (base 36)
12:59:38 <lambdabot>   "hbl0yp3j70b46y87k9fu4ion4bwxnm52nqymwghjrmk7d9dpn8fl6c6p1kp9y842x9hwphb33c...
12:59:38 <ReinH> haasn: nice
12:59:38 <haasn> geekosaur: fmap . fmap . fmap
12:59:38 <haasn> oh
12:59:40 <haasn> to the list, not to each element
12:59:42 <haasn> nvm
12:59:46 <S_J> Dont think i got an answer before: if my database is an .exe, how would i communicate with it? process to process? via sockets?
13:00:19 <ReinH> haasn: well just fmap.fmap then
13:00:28 <haasn> ReinH: yeah geekosaur already gave that answer :)
13:00:45 <haasn> I could make myself non-useful by suggesting ‚Äúover (mapped.mapped)‚Äù
13:00:46 <ReinH> oh
13:00:46 <ReinH> S_J: that doesn't give us enough info to give you an answer
13:00:49 <geekosaur> S_J: don;t think anyone can answer just from knowing it's an .exe
13:00:50 <haasn> perhaps ‚Äúover (mapped._Just)‚Äù for some extra type safety ;)
13:01:03 <ReinH> S_J: it's equivalent to saying "if my database is a process, how do I communicate with it?"
13:01:14 * byorgey is not even sure what it means for a database to be an .exe
13:01:18 <ReinH> S_J: and the answer can be: using whatever IPC interface the database provides. Socket? etc.
13:01:28 <ReinH> *can only be
13:01:37 <haasn> byorgey: it might mean that the values are stored in the PE's data sections
13:01:50 <ReinH> S_J: the fact that it's a .exe vs some other process isn't relevant, what's relevant is what interface(s) the database provides
13:01:53 <haasn> byorgey: but I doubt that :)
13:01:58 <byorgey> haasn: there are quite a few things it *might* mean.
13:02:29 <josephle> most obvious one: the .exe is the database server
13:02:30 <byorgey> it could also mean that S_J only thinks it's a database, but really it's a virus.
13:04:14 <ReinH> haasn: is that the same as  \f -> mapped._Just %~ f ?
13:04:32 <haasn> ReinH: yes
13:04:40 <ReinH> I remember a lens operator!
13:04:44 <haasn> good job :)
13:04:45 <ReinH> self high five
13:06:41 <S_J> geekosaur, ReinH: ok. well im writing a key-value store but not having much of a clue :). i try to find info on a suitable filesystem. should i load the whole database into RAm etc. any tips?
13:06:44 <haasn> oh nice, I just noticed ‚Äòover‚Äô accepts any compatible profunctor as its second parameter
13:07:01 <ReinH> S_J: I'm not sure what you're asking.
13:07:10 <ReinH> haasn: profunctors ftw
13:07:22 <geekosaur> insufficient data for meaningful answer
13:09:47 <haasn> > "hello world" & traversed %~ Indexed (,)
13:09:49 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9...
13:10:41 <flux0r> i have no idea what a profunctor but that was awesome
13:10:42 <haasn> > "hello world" ^.. traversed.withIndex
13:10:44 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9...
13:11:12 <haasn> flux0r: just a fancy way of writing ‚Äúzip [0..]‚Äù :)
13:11:39 <cschneid> > zip "hello world" [0..]
13:11:40 <lambdabot>   [('h',0),('e',1),('l',2),('l',3),('o',4),(' ',5),('w',6),('o',7),('r',8),('...
13:11:49 <cschneid> well, flipped.
13:11:59 <flux0r> right
13:12:07 <flux0r> still really cool
13:12:12 <haasn> :t Map.fromList
13:12:13 <lambdabot> Couldn't find qualified module.
13:12:16 <haasn> :t M.fromList
13:12:17 <lambdabot> Ord k => [(k, a)] -> M.Map k a
13:12:26 <cschneid> haasn: where's traversed coming from? What's the library?
13:12:29 <cschneid> hoogle didn't pop it up
13:12:41 <haasn> > M.fromList [(3, "hello"), (7, "world")] ^.. traversed.withIndex
13:12:43 <lambdabot>   [(0,"hello"),(1,"world")]
13:12:46 <haasn> oh
13:13:51 <S_J> if i have a file filesystem/SimpleFile.hs how do I import it from Main? if main is above filesystem/ ?
13:14:34 <haasn> > M.fromList [(3, "hello"), (7, "world")] ^.. itraversed.withIndex
13:14:36 <lambdabot>   [(3,"hello"),(7,"world")]
13:14:37 <haasn> there we go :)
13:15:53 <typoclass> cschneid: it's the lens library. the swiss army chainsaw of haskell
13:16:15 <cschneid> typoclass: is it worth learning lens right away? Seems like it's the hotness.
13:16:19 <haasn> yes!!
13:16:32 <cschneid> assumption: I otherwise don't know wtf I'm doing with haskell :)
13:16:35 <ReinH> haasn: a rube goldberg id if I ever saw one
13:16:38 <haasn> lens will make your life easier and broaden your horizons (depending on how far down the rabbit hole you go)
13:16:52 <ReinH> cschneid: lens is pretty great
13:16:58 <haasn> ReinH: not an id ;)
13:17:13 <haasn> ReinH: more of a sortBy fst
13:17:27 <ReinH> haasn: ah, ordered, ofc
13:17:39 <haasn> cschneid: okay maybe you should know the basics :)
13:17:40 <typoclass> cschneid: i would first get the basics sorted out. work your way through lyah before attacking lens
13:17:45 <haasn> yeah LYAH first
13:19:23 <merijn> cschneid: Lens is neat, but you can write a lot of useful haskell without knowing lens
13:19:26 <supki> > M.fromList [(3, "hello"), (7, "world")] ^@.. ifolded
13:19:28 <lambdabot>   [(3,"hello"),(7,"world")]
13:19:51 <merijn> cschneid: The lens code/types are also...notoriously intimidating...so if you're not yet comfortable with haskell you might want to avoid them for now
13:20:53 <haasn> ^
13:21:08 <haasn> supki: nice!
13:21:17 <haasn> I keep forgetting about that combinator :)
13:21:20 <haasn> ‚Äúcombinator‚Äù
13:21:32 <ReinH> combinator has become a fancy word for function...
13:21:42 <haasn> or operator, at least
13:21:43 <ReinH> I remember when words used to mean something. Get off my lawn.
13:21:47 <typoclass> (why is the input the same as the output ...)
13:21:51 <johnw> well, at least a fancy word for higher-order function
13:21:51 <typoclass> (... again ...)
13:22:08 <johnw> i always forget exactly what a true combinator is
13:22:15 <typoclass> ReinH: broadly yes. it's more or less a synonym for (higher order) function
13:22:16 <johnw> i think of it now as "functions that make other functions"
13:22:16 <ReinH> johnw: I think there are two meanings
13:22:24 <haasn> ReinH: ($) is a combinator, it combines a function with its parameter!
13:22:26 <merijn> johnw: There is no real definition other than "combines multiple things"
13:22:43 <typoclass> haasn: no, it combinators the function with the parameter
13:22:44 <ReinH> the narrow definition is: a function or definition with no free variables
13:22:46 <haasn> I tend to think of a combinator as something :: a -> a -> a
13:22:54 <ReinH> ah here it is http://www.haskell.org/haskellwiki/Combinator
13:23:18 <johnw> Combinator: "That which means something different from anything people in #haskell use it to mean"
13:23:42 <haasn> that definition goes for a lot of words
13:23:44 <ReinH> johnw: we need a Devil's Dictionary for Haskell terms
13:24:12 <ReinH> combinator, n: a function that may or may not combine things
13:24:18 <cschneid> merijn: are the types difficult, but using them is simple, or does a full groking of the lens types necessary to use them right
13:24:52 <S_J> filesystem/SimpleFile.hs, is that not how I list things under other-modules?
13:25:09 <merijn> cschneid: Using lens is fairly simple, but the types are *really* intimidating :p
13:25:09 <ReinH> cschneid: using them is simple if there are good examples to help guide you
13:25:15 <haasn> ReinH: clearly we need to revise Control.Lens.Combinators to fit this definition; eg. (??) fmap ($) fab a = fmap ($ a) fab
13:25:15 <ReinH> and the docs are improving in that regard
13:25:32 <johnw> cschneid: lens types form their own vocabulary, and it can be very hard to "read" a lens composition correctly without knowing that vocabulary
13:25:34 <ReinH> cschneid: I should say, using them for relatively trivial things is simple. More complex things will require more understanding of the underlying types.
13:25:53 <johnw> at the very least, the type errors you'll get from using ^. when you should have used ^.. require some understanding of the lens types
13:25:54 <typoclass> cschneid: the basics are not difficult to grok. the core is accessors (getters and setters) for lots of haskell data structures https://github.com/ekmett/lens/wiki/Examples
13:26:15 <haasn> ReinH: (or the other way round, rather; proper usage would be eg. (f ?? x) fmap ($))
13:26:17 <ReinH> johnw: even words, some understanding of the construction of the lens types
13:26:20 <cschneid> ReinH / johnw / haasn / merijn: you're all fans, so might as well check it out - typoclass just linked examples - any other tutorial/example code I should go read?
13:26:25 <cschneid> ideally with walkthrough of wtf is happening :)
13:26:40 <ReinH> johnw: GHC is pretty bad at groking and reporting the best type synonyms
13:26:47 <ReinH> *even worse
13:26:57 <haasn> cschneid: re: your earlier question; depends on whether or not experiencing type errors is part of ‚Äúusing them‚Äù ;)
13:27:01 <ReinH> cschneid: lens.github.com
13:27:08 <johnw> cschneid: well, also: http://newartisans.com/2012/11/getting-started-with-lenses/
13:27:32 <ReinH> lens.github.io, actually, but it will redirect
13:27:37 <haasn> if you're interested in the internal workings I started with http://r6.ca/blog/20120623T104901Z.html
13:27:47 <haasn> but you can use the library without concerning yourself too much with them, as mentioned
13:28:06 <ReinH> The bit on derivation at lens.github.io is good too
13:28:09 <cschneid> haasn: nope, not interested in internals of libraries. Not to that point of my haskell career yet :)
13:28:45 <johnw> cschneid: have you watched edwardk's NYC presentation on lenses?
13:28:49 <cschneid> nope.
13:28:52 <ReinH> do that.
13:28:56 <johnw> that does a good job of presenting the functorial interpretation of lenses
13:29:16 <cschneid> http://www.youtube.com/watch?v=cefnmjtAolY --- this?
13:29:18 <johnw> i mean, a "lens" is anything isomorphic to a function pair of getter+setter
13:29:31 <johnw> the lens library is a few steps removed from the simple Lens (a -> b) (a -> b -> a)
13:29:32 <haasn> (cschneid: have you read LYAH yet?)
13:29:50 <haasn> johnw: lenses are so boring
13:30:04 <johnw> lenses, or lens? :)
13:30:11 <haasn> lenses :) traversals are where it's at
13:30:17 <ReinH> biplates dude
13:30:21 <ReinH> get you some
13:30:27 <haasn> :t biplate
13:30:28 <cschneid> haasn: yep, and RWH. And have written small real programs, although relatively small
13:30:41 <ReinH> and prisms
13:30:42 <johnw> right, biplate is freakishly awesome
13:30:54 <johnw> > ("Hello","World",["Neat","!!!"]) & partsOf (biplate.filtered isLower) %~ (L.reverse :: String -> String)
13:30:55 <lambdabot>   Not in scope: `L.reverse'
13:30:56 <lambdabot>  Perhaps you meant one of these:
13:30:56 <lambdabot>    `P.reverse' (...
13:30:59 <johnw> > ("Hello","World",["Neat","!!!"]) & partsOf (biplate.filtered isLower) %~ (reverse :: String -> String)
13:31:00 <lambdabot>   ("Htaed","Wlroo",["Nlle","!!!"])
13:31:14 <johnw> even just thinking of how to write that algorithm without lens hurts
13:31:31 <ReinH> johnw: yeah, also tree annotation / rewriting is going to be so much easier
13:31:45 <ReinH> johnw: I need to get back on the Haskell Live wagon and do the game tree evaluation that way
13:31:47 <haasn> johnw: oh god, that example is even more mind-blowing than what I was about to write due to the isLower
13:31:59 <cschneid> ReinH: yes, I want to see the rest of your chess program please.
13:32:03 <ReinH> cschneid: me too!
13:32:06 <cschneid> those two you made were excellent
13:32:09 <ReinH> cschneid: thanks!
13:32:10 <cschneid> so.. uhh... get on that!
13:32:19 <ReinH> I'm getting back into producing Haskell content again
13:32:23 <ReinH> so yay
13:32:54 <haasn> > zipper (Just "Hello", [Left "wo", Right (), Left "rld"]) & fromWithin biplate & focus .~ 'J' & rightmost & focus %~ toUpper & rezip
13:32:55 <lambdabot>   Not in scope: `zipper'Not in scope: `fromWithin'Not in scope: `focus'
13:32:55 <lambdabot>  Perh...
13:32:58 <haasn> oh no :(
13:33:03 <haasn> elliott!!
13:33:32 <ReinH> I can see how to do naive negmax search pretty clearly but I'm not sure how to do ab pruning and iterative deepening versions...
13:33:41 <haasn> should return ‚Äú(Just "Jello",[Left "wo",Right (),Left "rlD"]‚Äù
13:33:42 <ReinH> Guess I'll just try thinking really hard and see if that works
13:34:25 <cschneid> ReinH: the part I really liked was the iterative nature. Looking at finished code doesn't really hint at how it grew to get there.  I almost don't care what you aim for feature-wise, just be sure to show how you get there :)
13:34:45 <tikhon> hey, is anyone planning to do the ICFP contest?
13:35:07 <ReinH> cschneid: cool :D
13:35:17 <elliott> haasn: that one is entirely edwardk's fault for taking zipper out of lens
13:35:26 <ReinH> tikhon: last time I did one was 2010 iirc but it was so much fun.
13:35:28 <elliott> I don't think zippers exists enough yet to install
13:35:33 <ReinH> heh
13:35:35 <haasn> oh, I didn't realize you were on HEAD
13:35:37 <hpaste> S_J pasted ‚Äúcabal parse fail‚Äù at http://lpaste.net/91609
13:36:02 <hpaste> S_J annotated ‚Äúcabal parse fail‚Äù with ‚Äúcabal parse fail (annotation)‚Äù at http://lpaste.net/91609#a91610
13:36:14 <S_J> ^^ can anyone have a look?
13:36:19 <dcoutts> S_J: those are files, not module names
13:36:53 <S_J> o remove the .hs, but the dir is ok?
13:36:56 <haasn> edwardk: btw, it's confusing that ‚Äòtraverse‚Äô is a Traversal but ‚Äòitraverse‚Äô is not; the traversal being ‚Äòitraversed‚Äô
13:36:58 <carter> woooot, clang dev preview HEAD works
13:37:04 <dcoutts> S_J: no, dir is not part of the module name
13:37:06 <edwardk> :t traversed
13:37:11 <mstksg> is there a type of mapM but for functors?  (a -> m b) -> f a -> m (f b)
13:37:25 <tikhon> mstksg: no
13:37:25 <edwardk> we export traversed for consistency and that one is an indexed traversal, but we're forced to that model
13:37:29 <johnw> mstksg: I think you want "traverse", for Applicatives
13:37:31 <S_J> dcoutts: ok, so how does cabal no where to look?
13:37:37 <c_wraith> :t traverse
13:37:58 <dcoutts> S_J: the hs-source-dirs
13:38:04 <dcoutts> S_J: which defaults to .
13:38:08 <dcoutts> if not specified
13:38:15 <edwardk> itraverse = traverseWithKey -- itraversed is the indexed traversal that you use with the combinators
13:38:16 <haasn> edwardk: I think ‚Äúiover itraverse‚Äù (where itraverse = itraversed) would be clean enough to take the role that ‚Äòitraverse‚Äô has now
13:38:44 <edwardk> the issue is that it is often easier to define the instance in terms of traverseWithKey which the libraries provide
13:38:50 <haasn> ieverything is the new coeverything
13:39:11 <edwardk> your solution requires a lot more boilerplate for all instances
13:39:27 <edwardk> and then there is no 'itraverse' ;)
13:39:32 <edwardk> iover only works with mapping
13:39:48 <haasn> I was suggesting renaming ‚Äòitraversed‚Äô to ‚Äòitraverse‚Äô and finding a new name for the current ‚Äòitraverse‚Äô, in case that wasn't clear enough
13:40:18 <edwardk> i understand your suggestion, but it isn't consistent with the other ifoo combinators
13:40:25 <haasn> fair enough
13:40:49 <edwardk> ifoldMap, iwhatever are the indexed combinators. itraverse would fail to be combinator you use to use the default indexed traversal.
13:41:07 <edwardk> itraversed on the other hand is consistent with traversed, folded, mapped, ...
13:41:28 <edwardk> and the current approach has the benefit that it is easier to instantiate
13:42:11 <edwardk> the remaining itraverse isn't a traversal wart seems a small price to pay for the other consistencies
13:42:20 <haasn> I guess I just need to stop using ‚Äòtraverse‚Äô and start using ‚Äòtraversed‚Äô
13:42:33 <haasn> you're right, that is more consistent with other -ed lenslikes
13:43:10 <edwardk> yeah 'traverse' doesn't fit the surrounding naming conventions
13:43:32 <edwardk> so using itraverse to match it as if it were ifoldMap, etc. struck me as the lesser of evils
13:43:45 <mstksg> johnw: thanks for the hint, i found it in Data.Traverse's mapM, which is just a generalized Control.Monad's mapM
13:43:57 <haasn> clearly we have Data.Traversable to blame for not making ‚Äòtraverse‚Äô accept any Indexable Int p !
13:44:10 <edwardk> note: those would up as ifoo rather than fooWithKey mostly to avoid conflicts with the names on import
13:44:16 <edwardk> hah
13:44:23 <edwardk> well, traverse is more efficient than traversed
13:44:30 <edwardk> if you don't use the index, use traverse
13:44:50 <edwardk> i conjoin the definition of traversed, but that is not good enough to remove all overhead from it
13:45:01 <johnw> mstksg: and someday soon, thanks to our buddy edwardk, aka chair of the libraries committee, the generalized mapM will become the default mapM
13:45:27 <edwardk> soon will probably be about september of next year
13:45:44 <johnw> as long as it's before 2022 ;)
13:45:44 <edwardk> heh
13:45:58 <johnw> i mean, I can live with "import Data.Traversable" for another year
13:46:03 <edwardk> likewise with http://ro-che.info/ccc/21.html
13:46:07 <danharaj> you mean import Control.Lens
13:46:24 <johnw> actually, I'm going to lensify a library I'm writing right now for our production code
13:46:30 <johnw> simply because it will make the interface easier to use
13:46:49 <johnw> in that I have a deep structure and want my caller to be able to mutate bits of it
13:46:55 <edwardk> johnw: hopefully with the way the gsoc project is going, you'll be able to all but just use field accessors as lenses soon enough.
13:46:56 <ocharles> http://i.imgur.com/KujQgG2.png - who says functional programming has to be boring?
13:47:00 <haasn> lenslike interfaces remove a surprising amount of boilerplate functions from eg. Data.Map
13:47:01 <ocharles> asteroids in <400 LOC
13:47:06 <ocharles> yay for netwire!
13:47:08 <haasn> it's really quite astounding
13:47:16 <haasn> ocharles: nice!
13:47:19 <johnw> edwardk: I really hope so
13:47:23 <haasn> ocharles: what's the backend? gloss?
13:47:31 <johnw> someday soon someone is going to create reactive lenses
13:47:32 <haasn> oh, SDL
13:47:33 <edwardk> ocharles: nifty!
13:47:36 <ocharles> haasn: "raw" SDL
13:47:40 <johnw> i mean, they're already comonads...
13:47:44 <ocharles> edwardk: thanks for linear, too ;)
13:47:45 <haasn> ocharles: I wonder if gloss would be smaller
13:47:50 <edwardk> ocharles: needs more lens
13:47:57 <johnw> linear was just too brilliant not to happen
13:48:13 <haasn> oh, linear is the package that provides V2 and stuff (eg. for diagrams)?
13:48:17 <ocharles> edwardk: it does indeed
13:48:24 <ocharles> https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs suggest more lens places!
13:48:35 <johnw> haasn: and sparse too
13:48:43 <ocharles> haasn: iirc gloss didn't give me a usable interaction model, but i'll look again now
13:48:44 <johnw> it lets you manipulate any "vector space"
13:49:03 <haasn> what do you mean by a usable interaction model? I've experimented with gloss+netwire fwiw
13:49:04 <ocharles> haasn: yea, i'm using linear for 2d vectors and rotation matrices
13:49:08 <edwardk> you can put a lens to get the center of a circle/point for bounds
13:49:09 <haasn> wrote one half of a pong game
13:49:11 <haasn> (what else?)
13:49:27 <ocharles> edwardk: yea, I thought about making all those objects R2 to get _x _y
13:49:29 <edwardk> for that matter a bullet or ship. so they can all share one lens to get the position
13:49:44 <edwardk> yeah the R2 instance would be easy enough
13:49:52 <c_wraith> half of a pong game.  What's that mean? One paddle, half the board, the ball just disappeared on the other side??
13:50:17 <ocharles> haasn: oh, do you have that online anywhere?
13:50:28 <haasn> edwardk: it would be interesting if you had _yz and stuff as well
13:50:40 <haasn> vector munging would almost feel like opengl :)
13:50:47 <ocharles> the next thing I want to do is use netwire for my chunky 8bit sound "chip" :)
13:50:52 <haasn> s/opengl/glsl/
13:51:17 <edwardk> Set.insert k keysDown  -- can be -- keysDown & contains k .~ True   reducing the need for qualified import noise
13:51:18 <ocharles> exploin = fadeOver 2 . gate 0.7 . random -- i can't wait for that
13:51:30 <edwardk> not all of these are good ideas, just thoughts
13:51:47 <ocharles> exploin = explode, that is
13:51:56 <haasn> edwardk: oh, never mind, diagrams defines its own R2
13:52:00 * zRecursive i am thinking that if haskell can gain compiling speed same as OCaml ...
13:52:11 <merijn> Any Pipes users? I'm not sure how to fit the ReaderP transformer into my consumer/producer types
13:52:12 <edwardk> likewise when astPos becomes a lens you can get rid of some 'to astPos' machinery.
13:52:14 <haasn> and uses vector-space's VectorSpace
13:52:29 <ocharles> edwardk: oh, i wasn't too big on the whole contains True thing, but being able to just import Data.Set (Set) is nicer
13:52:37 <edwardk> haasn: we have _xy and _xyz   but not all permutations
13:52:53 <haasn> ocharles: I don't right now, it's on my netbook somewhere; let me see if I can dig it out for you
13:52:57 <edwardk> ocharles: sure. i figured that one wasn't a huge win, but that i should mention it
13:53:04 <carter> does anyone have ghc HEAD installed on their mac?
13:53:11 <haasn> ocharles: it's probably not very nice code fwiw, I still have no idea how to use netwire effectively
13:53:12 <merijn> carter: For some value of HEAD
13:53:20 <carter> merjin: recent?
13:53:26 <carter> like from the past monthish
13:53:35 <merijn> carter: hmm, maybe, let me check
13:54:02 <merijn> carter: Last commit I see in my git checkout is "Sat Jun 15 21:54:22"
13:54:05 <carter> ok
13:54:06 <carter> hrmm
13:54:14 <carter> actually the right test is to build ghc HEAD with apple clang
13:54:18 <ocharles> haasn: I'll probably blog about this project. or maybe try a screencast and talk through the code
13:54:20 <jophish_> Yo yo yo
13:54:35 <carter> merijn: have an ticket wiht apple to make sure they backported some stuff to their xcode 5 clang
13:54:38 <haasn> ocharles: sounds good
13:54:46 <carter> so that GHC head / 7.8 and xcode 5 can be friends
13:55:11 <merijn> carter: Is that the mountain lion xcode?
13:55:22 <carter> merijn: the dev preview
13:55:22 <edwardk> a lot of the filter (not . colliding (map fst asteroids) . fst) bullets  -- kind of code can be cleaned up with filtered, etc.
13:55:45 <jophish_> It seems as though the high level LLVM bindings aren't really suitable for writing a compiler (I'd love to be shown otherwise). The big problem being that LLVM types are generated directly from Haskell types. As far as I can tell it's not possible to determine types of values at run time.
13:55:52 * hackagebot clay 0.8 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.8 (SebastiaanVisser)
13:56:05 <carter> jophish_: use llvm-general
13:56:17 <ocharles> haasn: looking at gloss again it does look like it should work fine
13:56:20 <carter> @hackage llvm-general
13:56:20 <lambdabot> http://hackage.haskell.org/package/llvm-general
13:56:33 <edwardk> overall its pretty clean if a bit noisy in the drawing parts and wire code
13:56:41 <carter> ie (more likely, someone else) will be writing a high level api for llvm-general
13:56:50 <edwardk> but it is pretty easy to follow the code
13:56:54 <carter> jophish_: but the "basic" llvm-general api is quite nice
13:57:19 <jophish_> carter: llvm-general looks really nice, How have I not found this before!
13:57:22 <jophish_> thank you
13:57:58 <merijn> carter: hmm, what exactly were you curious about? Because I'm still on Lion and my Xcode is only...lemme check
13:58:23 <carter> merijn: i have an open ticket with APPLE to make sure they backported all of thoughpolices work
13:58:31 <carter> to make clang and GHC head/7l.8 friends
13:58:52 <merijn> Xcode 4.3 apparently
13:58:56 <carter> ok
13:59:00 <carter> don't mind me then
14:00:00 <merijn> Anyone with help on how ReaderP fits into my pipes type signatures?
14:00:20 <carter> i'll figure out doing the testing myself
14:00:26 <hpaste> haasn pasted ‚ÄúUgly netwire pong attempt‚Äù at http://lpaste.net/91611
14:00:28 <haasn> ocharles: ^
14:00:30 <carter> jophish_: llvm-general only got public 2 months ago
14:00:41 <carter> jophish_: theres also #haskell-llvm
14:00:43 <carter> :)
14:00:44 <haasn> here's the experiment I wrote a while ago (with no internet access at the time, iirc); take with a grain of salt
14:02:19 <ocharles> haasn: ooo, thanks!
14:02:22 <haasn> it doesn't actually do a lot, but if you hold down space it resets the ball and increments the score, and you can control the paddle
14:02:24 <haasn> that's about it
14:02:46 * haasn has a weird affinity for pong, lens, gloss and combinations thereof
14:02:54 <ocharles> "NOTE: I think these are illegal, actually" you'd be able to know that if I finished by damn lens-laws library
14:03:06 <jophish_> carter: Are there any examples on llvm-general? Is it worth taking a look at the LLVM.General.Test?
14:03:15 <haasn> ocharles: ooh, what library is that? something quickcheckesque?
14:03:20 <carter> jophish_: sure, or idris has an llvm backend
14:03:24 <carter> also
14:03:28 <carter> read the linked haddocs
14:03:32 <carter> they're really readable
14:04:29 <carter> like
14:04:42 <carter> in some respects, easier to understand than the llvm(the c++ lib) docs :
14:04:46 <jophish_> ah, I completely missed those.
14:04:49 <carter> yeah
14:04:53 <jophish_> Thanks again, I'll look at those and idris
14:04:56 <carter> i pestered bscarlet  into adding those :)
14:05:00 <ocharles> haasn: yea, quickcheck
14:05:02 <carter> (the haddock links)
14:05:11 <johnw> carter: what should I read for simple "hello world" llvm-general example?
14:05:13 <ocharles> i started it a while ago, and ekmett recently reminded me to finish it
14:05:15 <johnw> the linked haddocks are a bit hard to digest
14:05:22 <carter> johnw HRMM
14:05:33 <carter> i think that'll require some writing
14:06:02 <carter> i'll look into rollling a toy example in a day or so
14:06:03 <johnw> I mean, I know how to generate a hello world program using C++, now I want to see how llvm-general makes it easier and type-safe, and removes some of the SSA requirement headaches
14:06:20 <carter> johnw: ummm, llvm-general doesn't hide the ssa requirement
14:06:28 <carter> some lib on top, may
14:06:31 <johnw> it doesn't make phi nodes easier to manage?
14:06:36 <banister> was 'return' used for monads because it accentuates the illusion that code inside the IO monad is imperative?
14:06:38 <carter> it makes it a haskell ast
14:06:41 <carter> instead of a C++ one
14:06:51 <carter> so you could *build* a lib on top that lets you do a more direct style
14:06:59 <carter> but it, itslef, still requires the phi nodes
14:07:06 <johnw> banister: return means: give me a value, and I'll return you a computation in my monad that will yield that value
14:07:17 <carter> yup
14:07:22 <carter> its literally just "return this value"
14:07:29 <haasn> ocharles: actually yeah they're obviously illegal; view val (set val 5 0) = 0 -- should be 5
14:07:34 <carter> johnw: sclv and I have discussed doing a layer as you suggest
14:07:36 <haasn> ocharles: so don't use them :)
14:07:39 <Tekmo> 'return' does not change the flow of computation
14:07:47 <johnw> Tekmo!!!
14:07:47 <carter> its just a matter of someone writing it :)
14:07:48 <haasn> ocharles: but the alternative boilerplate would have been so ugly~
14:07:49 <Tekmo> Hi!
14:07:53 <johnw> the moons have aligned
14:07:55 <Tekmo> Haha
14:08:00 <johnw> great to see you here
14:08:07 <Tekmo> You, too! :)
14:08:13 <banister> johnw: i knokw
14:08:17 <johnw> Tekmo is the author of 'pipes', for those who don't recognize him by handle yet
14:08:28 <Tekmo> I'm actually on because I had a question, but I have a policy of waiting a bit before asking to answer some questions first, for balance
14:08:41 <kier> Does anyone have any tips on how to get Happstack's serveDirectory and web-routes to play nice together?
14:09:09 <banister> johnw: but im curious why 'return' specifically was used, what's the name in category theory? but, when you see code in the IO monad and it's written in an imperative style the use of 'return' seems to reinforce that illusion it's imperative. Is there nothing in that, is it just a coincidence?
14:09:16 <johnw> then I'll ask you question: any decision yet on async exception handling in pipes-safe?
14:09:35 <johnw> banister: the name is category theory is Œ∑
14:09:51 <Tekmo> I'm going to listen to the mailing list and not run in a masked background
14:10:00 <johnw> I think that's right, personally
14:10:06 <Tekmo> Yeah, I think so, too
14:10:14 <Tekmo> It's also easier to implement, so that's a plus
14:10:19 <johnw> I wasn't going to chime in on the ML because I'm not an active pipes user, so I don't feel that my opinion should count there
14:10:30 <Tekmo> Everybody's opinion counts! :)
14:10:39 <johnw> Tekmo: ok then, what's your question?
14:11:03 <carter> which mialing list?
14:11:10 <Tekmo> Oh, I was trying to come up with a useful Consumer for the tutorial and I wanted to use James's idea of a `stdout` consumer that terminates on broken pipe
14:11:13 <Tekmo> haskell-pipes mailing
14:11:19 <Tekmo> https://groups.google.com/forum/#!forum/haskell-pipes
14:11:29 <sclv_> banister: hmm. wadler's 92 paper still uses "unit" instead of "return"
14:11:34 <sclv_> not sure when the change happened
14:11:52 <Tekmo> Yeah, 'doNothing' would probably have been a more descriptive name for 'return'
14:11:59 <johnw> sclv_: well, unit kind of implies a value (viz a viz Monoid), rather than a function
14:12:16 <haasn> what's wrong with ‚Äòpure‚Äô
14:12:17 <merijn> Tekmo: Actually, I have a high level question for you, I have some code which I just realised is essentially a really barebones implementation of my own pipes type thing. I was thinking of rewriting it using pipes, BUT! pipes-safe seems to only support mask (in the form of bracket)
14:12:17 <mel-> Hi, i'm relatively new to both, Haskell and Gtk2hs. I'm currently writing a game application with Gtk2hs. I have found a few introductory texts on this subject and often it is recommended to use something like Data.IORef for maintaining/updating a 'global state' from within Gtk event handlers. I don't understand how this method of doing things is _not_ having side-effects. I have a rough idea of the IO monad
14:12:19 <haasn> so much Applicative hate in prelude :(
14:12:19 <mel-> and how you can _model_ side-effects with the IO Monad. But when I picture that an event handler is executed and from within that I change an IORef and later on I see the updated version -- how is this not a side effect? Maybe I simply don't understand the program flow here.
14:12:24 <sclv_> unit is the typical categorical name that isn't in greek
14:12:36 <johnw> sclv_: that is true...
14:12:49 <banister> sclv_: but (and im sorry to keep hammering on at this) someone chose it to further the 'IO monad' looking imperative?
14:12:52 <sclv_> haasn: nothing's wrong with any of these names! i'm just doing some linguistic archaeology
14:12:59 <sclv_> banister: i don't know yet!
14:13:03 <sclv_> i need to look at more papers!
14:13:07 <merijn> Tekmo: I have some resource acquisitions that are potentially blocking, so I need to ensure I run in uninterruptibleMask to make resource acquisition atomic, any hints on how I'd deal with that in pipes-safe?
14:13:08 <sclv_> i can't even tell you who chose it!
14:13:10 <sclv_> much less why
14:13:15 <zRecursive> what's the usage of llvm-general ?
14:13:16 <johnw> banister: I would doubt that, since most people bemoan the choice of return since we now have to constantly explain that it's nothing like C's return
14:13:28 <ocharles> oh hey tekmo
14:13:37 <Tekmo> merijn: The new `pipes-safe` will have a way to run actions with an optional mask
14:13:48 <ocharles> nice to see you finally on IRC :)
14:13:50 <Tekmo> merijn: It's not going to not run in a masked background by default and you will selectively opt in to masking
14:13:53 <Tekmo> Thanks :)
14:13:57 <zRecursive> @package llvm-general
14:13:57 <lambdabot> http://hackage.haskell.org/package/llvm-general
14:14:08 <johnw> Tekmo: nice work with the streaming folds, btw
14:14:14 <carter> zRecursive yes?
14:14:15 <Tekmo> johnw: Thanks!
14:14:23 <johnw> Tekmo: I was wondering if the idea was related in any way to edwardk's reducers library?
14:14:38 <Tekmo> Thank James (xplat), too.  He was the one who prompted that line of inquiry on the haskell-pipes mailing list
14:14:43 <banister> johnw: yeah i agree they do now, but it's kind of analogous to a C return some ways (if you squint hard enough) and i wondered whether phil wadler & co were just being cute
14:14:50 <ocharles> oh, James is xplat? smart fella
14:14:52 <zRecursive> carter: seems it is not relative to application development
14:14:52 <ocharles> i've been learning lots :)
14:14:56 <Tekmo> I don't know how to use `reducers`
14:15:07 <carter> well, yeah, its relevant to compiler writing :)
14:15:11 <carter> zRecursive: so i don't understand
14:15:15 <carter> your remark
14:15:24 <zRecursive> k
14:15:26 <zRecursive> ok
14:15:27 <johnw> banister: C's return is an implicit goto, while Haskell's return is a value embedding that by definition has no side-effect
14:15:42 <ocharles> johnw: reducers is more a generalised map-reduce framework
14:15:48 <Tekmo> I think the best parallel that Yves pointed out to me was the "Essence of Iteration" (forgot the exact name) paper
14:15:54 <merijn> Tekmo: Ooh, neat, I would actually recommend supporting an API that takes a restore action. That way it'd be possible to forkIO a pipe while masked and only unmask when the pipe starts running, avoiding some nasty shenanigans with async exceptions arriving before the pipe starts properly (in case I want the pipe to do some resource cleanup)
14:16:02 <johnw> ocharles: I was wondering if the "reduce" part of the framework was not similar to streaming folds
14:16:09 <ocharles> Tekmo: essence of the iterator pattern, it's one of my favourites :)
14:16:29 <banister> johnw: i know i know :) but when you're writing a ream of IO monad code it can look a lot like a C return, even though it's clearly not and shouldn't be confused but nonetheless the designer's haskell thought it would be cute
14:16:53 <Tekmo> merijn: Ok, I will try to make sure the new `mask` function passes a `restore` function to the enclosed block
14:17:18 <slack1256> hassn: has anybody answered you? if not I know the standard answer
14:17:37 <Tekmo> ocharles: The only thing I don't like about traversals is their poor memory performance when you use them to collect results from some sort of action
14:17:55 <merijn> Tekmo: i.e. I'd want to write something along the lines of "mask $ \restore -> forkIO (runPipeWithRestore restore myPipe)", I'm not too picky about the actual API for it
14:18:09 <slack1256> mel: has anybody answered you? if not I know the standard answer
14:18:16 <slack1256> sorry wrong message hassn :S
14:18:21 <Tekmo> merijn: Yeah, I understand what you mean.  You want a `mask` action lifted to work with `pipes-safe`
14:18:32 <Tekmo> merijn: Complete with the restore argument passed to the block
14:18:38 <merijn> Tekmo: Yeah, pretty much
14:18:43 <sclv_> banister: don't claim that the designers of haskell thought anything about it yet
14:18:50 <sclv_> because you don't know what they thought or why!
14:18:55 <sclv_> i'm looking at papers now because i'm curious
14:19:02 <sclv_> somewhere between 93 and 95 the name changed
14:19:13 <banister> sclv_: yeah i should have put a question mark in there somewhere
14:19:14 <sclv_> but i have no idea why, and nor do you
14:19:17 <ReinH> Tekmo: hai
14:19:19 <slack1256> the IORef update in the IO monad is a side effect, you change the variable. but that is presicely the meaning of the IO monad
14:19:20 <sclv_> :-)
14:19:23 <schell> anyone know of a good screen capture tool that exports gifs? (for mac)
14:19:24 <Tekmo> ReinH: Hi!
14:19:43 <carter> schell: i use Shift+Command+4
14:19:45 <slack1256> to mark where side effects occur. in that sense only the IO monad is impure.
14:19:49 <carter> you can probabl convert that to a git
14:19:51 <carter> *figt
14:19:55 <carter> *gif
14:20:02 <johnw> sclv_: when did the shift from explaining monads in terms of generalized list comprehensions switch to explaining them as imperative computations?
14:20:16 <schell> right - but that's one static image, i'm looking for animation ;) thanks tho
14:20:32 <carter> johnw there was never such a swithc, unless you're talking about monad tutorials
14:20:35 <sclv_> johnw: in being lazy w class i think it says do notation preceeded generalized list comprehensions
14:20:51 <johnw> ah, I need to ready lazy w/ class again
14:20:54 <sclv_> the very earliest monad stuff in haskell was on treating them as imperative computations
14:20:56 <carter> they were also being explored as a way of composably building interpreters
14:20:59 <Tekmo> I agree that a sequence of instructions is a more intuitive metaphor
14:21:05 <schell> i've seen some github readme's that have gifs lately
14:21:10 <carter> building GHC head so i can test nice things
14:21:13 <sclv_> the first wadler paper was state and exceptions
14:21:17 <sclv_> then with spj it was IO
14:21:26 <carter> schell i'm meh about how much gifs are turning up on github
14:21:32 <carter> its like 4chan or something
14:21:45 <carter> at least, i've not seen gifs that are explainatory
14:21:48 <carter> but those would be nice
14:21:49 <schell> haha - right? i can get on board with that
14:22:00 <blochchain> what's the best way to test if a string exists in a list of strings?
14:22:09 <schell> this is for uploading bug recreation flow to jira
14:22:17 <Tekmo> blochchain: elem
14:22:19 <Tekmo> :t elem
14:22:19 <lambdabot> Eq a => a -> [a] -> Bool
14:22:35 <Tekmo> Just pretened that the `a` is a `String`
14:22:42 <Tekmo> elem :: String -> [String] -> Bool
14:22:43 <carter> schell if you do explanatory  gifs, awesome
14:22:48 <carter> schell cool, for what project/
14:22:54 <carter> if you figure that out, it'd be handy for me
14:22:56 <schell> carter: work work
14:23:05 <carter> so please share any solution you cook up
14:23:24 <schell> carter: it's a backbone single page app :/
14:23:29 <schell> wrong face
14:23:32 <schell> :?
14:23:38 <carter> for doing the gif screen capture?
14:23:42 <schell> don't know the face i want
14:23:43 <schell> oh!
14:24:14 <sclv_> banister: the first reference to return I can find is a 94 paper by launchbury and spj on "lazy functional state threads"
14:24:21 <carter> :)
14:24:26 <haasn> > ["hello", "world"]^.contains "hello" -- ;)
14:24:27 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[GHC.Types.Char]'
14:24:27 <lambdabot>  Expected type:...
14:24:29 <sclv_> there it doesn't introduce "return" by analogy to C, but just because it "returns" a value
14:24:29 <haasn> oh no
14:24:35 <schell> carter: no - i'm working on an app for work and need to explain a bug and i thought it would be cool to upload a gif showing the process
14:24:40 <carter> yeh
14:24:42 <carter> that'd b enice
14:24:44 <johnw> sclv_: for posterity: https://github.com/ekmett/ekmett.github.com/tree/master/pdf
14:24:52 <johnw> your 3 excellent articles on applicative algebras
14:25:03 <sclv_> oh, excellent
14:25:09 <carter> neat
14:25:10 <sclv_> now at some point i should get around to the rest :-)
14:25:18 <schell> carter: but later on if it's proper i could use gifs in readme's as long as it doesn't look like myspace glitter
14:25:25 <carter> yeah
14:25:33 <johnw> actually, because of your articles I actually use an Applicative composite to good effect in one of my libraries
14:25:41 <carter> i've a few gui flows lots of people will be doing where a gif based "gui walk through"
14:25:43 <sclv_> :-)
14:25:45 <carter> would be handy
14:25:57 <quchen> @botsnack
14:25:57 <lambdabot> :)
14:26:00 <johnw> the type is newtype Fuzz a = Fuzz (Compose Gen (Product (Const [String]) Identity) a)
14:26:14 <banister> sclv_: cool, i'm impressed you're researching this ;)
14:27:25 <johnw> it led me to realize that Applicatives are rather under-appreciated
14:27:47 <johnw> the fact that they form a category should be a big deal!
14:28:06 <Tekmo> You mean applicative composition?
14:28:10 <johnw> yes
14:28:31 <sclv_> i have "applicatives are closed functors" sort if sketched in my head but not written
14:28:45 <sclv_> banister: also, note that use of the name "return" preceeds do notation being implemented. so there wasn't a "c-like" syntax for return to correspond to
14:28:57 <johnw> what is the algebraic structure of which Haskell types form a part again?  It's not a field...
14:29:06 <johnw> is it a ring?
14:29:19 <Tekmo> I thought it was a semiring
14:29:23 <johnw> ah yes
14:29:25 <Tekmo> But I always get this wrong
14:29:41 <johnw> anyway, applicatives have the same structure
14:29:55 <banister> sclv_: oh, that's the end of it then :)
14:29:57 <banister> sclv_: thanks
14:30:05 <sclv_> it was a fun question to dig into
14:30:08 <haasn> I just had visions of a strange alternate world where every basic library function like ‚Äòelem‚Äô, ‚Äòlength‚Äô etc. was generalized to the lens versions, but the lenses weren't passed as explicit parameters but as implicit type constraints or something; and the correct lens is defaulted from the types involved where applicable/not specified
14:30:10 <blochchain> what's the best way to apply a value to a list of partially applied functions?
14:30:24 <haasn> I wonder if it would be possible to do that with reflection / magic!
14:30:40 <alkabetz> blochchain: map ($42) [f1, f2, ...]
14:30:41 <Tekmo> blochchain: map ($ val)
14:33:13 <haasn> johnw: is ‚Äúcommutative semiring‚Äù a term? ie. when (*) commutes as well
14:33:17 <zRecursive> :t ($17)
14:33:17 <lambdabot> Num a => (a -> b) -> b
14:33:31 <applicative> hey Tekmo you left out that 'Fold's are independent of the interpreter http://lpaste.net/91612
14:33:50 <applicative> of these only the 'vector' one is of interest
14:33:57 <johnw> haasn: yes
14:33:58 <ReinH> blochchain: see also the "swing" combinator: swing f x = f ($ x) http://www.reddit.com/r/haskell/comments/1i2zmq/a_useful_function_om/cb0nb0d
14:34:05 <johnw> "A commutative semiring is one whose multiplication is commutative. An idempotent semiring (also known as a dioid) is one whose addition is idempotent"
14:34:44 <Tekmo> applicative: You mean that you can pattern match on the resulting fold and use the components in a way other than the provided 'fold' function?
14:35:01 <Tekmo> applicative: I wonder if it's appropriate to call it a "free" fold
14:35:01 <ReinH> > let swing f x = f ($ x) in swing map 42 [(+1), (*2)]
14:35:02 <lambdabot>   [43,84]
14:35:09 <haasn> johnw: I wonder what the inclusion of GADTs means for this type structure, btw
14:35:10 <applicative> Tekmo: I was thinking so, Fold has nothing to do with lists
14:35:15 <Tekmo> applicative: Right
14:35:24 <Tekmo> applicative: Actually, that was the original motivation behind that post
14:35:34 <Tekmo> applicative: I wanted to use it for a `pipes`-based general-purpose fold
14:35:42 <applicative> thats what i figured, actually, it was just left out
14:35:48 <Tekmo> applicative: Yeah, I completely forgot about that
14:36:13 <applicative> I think the vector one(s) might be worth including if you aren't avoiding vector
14:36:21 <Tekmo> applicative: I already made it work with `Foldable`s
14:36:32 <merijn> Ugh, why does Data.Binary not have support for strict ByteStrings? :((
14:36:37 <Tekmo> applicative: Although I don't know if that will be less efficient than direct vector integration
14:36:53 <Tekmo> applicative: But you're right that bytestring integration requires additional machinery
14:36:58 <Tekmo> applicative: Foldable wouldn't work for that
14:37:06 <applicative> Tekmo: oh i forgot to add, Vector.Unboxed isn't Foldable
14:37:12 <Tekmo> applicative: Oh yeah, you're right
14:37:19 <ReinH> blochchain: although as a comment suggests, you can also do:
14:37:21 <ReinH> > > [(+1), (*2)] <*> pure 42
14:37:22 <lambdabot>   <hint>:1:1: parse error on input `>'
14:37:26 <ReinH> woops
14:37:26 <Tekmo> applicative: My only concern is the existential quantification
14:37:27 <ReinH> > [(+1), (*2)] <*> pure 42
14:37:28 <lambdabot>   [43,84]
14:37:47 <Tekmo> applicative: I'd really like something like this to get into the platform, but that extension is the main roadblock to this being widely used
14:38:30 <Tekmo> applicative: If it got into the platform then it could be made into a dependency of other packages safely
14:38:44 <applicative> Tekmo: I don't the idea is good. It's been around, but no one seems to have taken it up properly
14:38:48 <haasn> data Fold i o = forall m. Monoid m => Fold (i -> m) (m -> o) -- ?
14:38:54 <haasn> I mean, is that equivalent
14:39:07 <Tekmo> That's the formulation in the post
14:39:24 <Tekmo> The one on Github uses a left fold formulation instead
14:39:46 <Tekmo> One possibility is parametrizing the type on `m`
14:39:56 <Tekmo> But then that makes the Applicative instance trickier
14:39:58 <ReinH> blochchain: but you can also do this, which is fun: [(+1), (*2)] <*> [42, 43]
14:40:04 <haasn> I'm not sure how left/right factors into this, considering mappend is associative it shouldn't matter right?
14:40:24 <Tekmo> The left fold has one nice property that I've been unable to recreate with the foldmap version
14:40:25 <schell> carter: think this might work? https://gist.github.com/dergachev/4627207
14:40:58 <Tekmo> With the left fold internal implementation, you can directly encode a left fold with the type and folds derived from the applicative instance still stream in constant space
14:40:59 <carter> schell no clue, lemme know if it does!
14:41:06 <schell> carter: i will :)
14:41:19 <TIHan> ok, monads are starting to click, not quite there yet
14:41:25 <Tekmo> Edward and Sjoerrd tried to do something similar with the foldmap version and they got isolated left folds to work, but then they lose the streaming property when you combine them using Applicative style
14:41:36 <carter> http://www.lcdf.org/gifsicle/ neat
14:41:36 <haasn> ah okay
14:41:36 <Tekmo> Let me find Edward's code
14:41:45 <banister> Tekmo: can you explain how this magic works? map ($ val)
14:41:48 * haasn has no idea about performance and internal workings and stuff, hence the confusion
14:41:58 <Peaker> Tekmo, hey, did you try minimizing the amount of type variables in pipes via some type-level pairs (for the upstream/downstream directions)?
14:42:10 <haasn> banister: ($ x) is an operator section; ($ x) = (\f -> f $ x) = (\f -> f x)
14:42:15 <applicative> > map ($ 1) [(+1),(*3)]
14:42:16 <lambdabot>   [2,3]
14:42:23 <applicative> > map ($ 2) [(+1),(*3)]
14:42:23 <haasn> banister: so map (\f -> f x) -- goes through the list, and maps each function f to (f x)
14:42:24 <lambdabot>   [3,6]
14:42:27 <banister> haasn: haha that's clever
14:42:33 <Tekmo> Here's Edward's foldmap code: http://lpaste.net/91613
14:42:43 <Tekmo> I'll answer banister and then Peaker
14:42:47 <Peaker> Tekmo, e.g: like:  data (a :> b) ; type family Input a ; type family Output a ; type instance Input (a :> b) = a ; .. Output .. = b    and similarly for (:<) or such, indicating whether its upstream/downstream
14:42:59 <Tekmo> banister: ($ val) is equivalent to: \f -> f $ val
14:43:19 <Tekmo> banister: And `f $ val` is equivalent to `f val`
14:43:27 <ion> > sequence [(+1),(*3)] 2
14:43:27 <Tekmo> banister: So ($ val) is equivalent to \f -> f val
14:43:28 <lambdabot>   [3,6]
14:43:32 <ion> > [(+1),(*3)] <*> pure 2
14:43:33 <lambdabot>   [3,6]
14:43:43 <Tekmo> When you map that over the list, you apply `($ val)` to each element of the list, which looks like this:
14:43:59 <ReinH> ion: beat you :p
14:44:17 <Tekmo> map ($ val) [f1, f2, f3] = [($ val) f1, ($ val) f2, ($ val) f3] = [f1 $ val, f2 $ val, f3 $ val] = [f1 val, f2 val, f3 val]
14:44:21 <ion> reinh: Oh, sorry, missed it.
14:44:51 <Tekmo> banister: Any time you syntax of the form (OPERATOR x) in haskell, where OPERATOR is some operator, that is called section notation
14:44:59 <Tekmo> For example, this is valid Haskell: (+ 1)
14:45:05 <Tekmo> That's a function that adds 1 to something
14:45:18 <Tekmo> map (+ 1) [2, 3, 4] = [3, 4, 5]
14:45:42 <Peaker> Tekmo, could be nicer (if less portable) to have:   Foo (a :> b) (c :< d) i o      than     Foo a b c d i o.   Also, (a :> b) can be passed as a whole, making it: Foo up down i o
14:46:03 <elliott> Any still gets in the way of that
14:46:07 <ReinH> ion: heh no worries, also you can do [f, g, h] <*> [x, y, z]
14:46:09 <elliott> same problem as with lens
14:46:10 <ReinH> which is fun
14:46:11 <Tekmo> Peaker: I would really love type level pairs to simplify the types, but I try to keep the library extensions to a minimum
14:46:28 <elliott> also I think it would have to be ':> and ':< at least
14:46:33 <ReinH> Peaker: Something somewhere has to have a type of E i e i o, right?
14:46:39 <Tekmo> lol
14:46:40 <monochrom> haha
14:46:44 <haasn> > [(+1),(*3)] ?? 2 -- shamelessly stolen
14:46:45 <lambdabot>   [3,6]
14:46:54 <Tekmo> Didn't Twan write up something about this?
14:46:55 <ReinH> haasn: ahhhh :)
14:47:07 <Peaker> ReinH, only if McDonald is writing it
14:47:09 <monochrom> E i e IO ()
14:47:33 <Tekmo> lol
14:47:39 <Tekmo> That's too perfect
14:47:44 <applicative> Tekmo: is there that much to be said now against a one-directional pipe and two direction proxy, and a generalize function?
14:48:01 <banister> Tekmo: is there any awy to express $x as one of the monadic functions ? pure(x) would just be \_ -> x   but is ther ea built in function (aside from ($)) that does that too?
14:48:02 <applicative> I guess the answer is too complicated
14:48:12 <Tekmo> Found it: http://twanvl.nl/blog/haskell/categories-over-pairs-of-types
14:48:29 <ReinH> > map ($x) [(+1), (*2)]
14:48:30 <lambdabot>   [x + 1,x * 2]
14:48:30 <haasn> banister: well, it's ‚Äúflip id‚Äù for what it's worth
14:48:43 <Tekmo> banister: Yes: `return` for `Cont` does exactly this
14:48:48 <applicative> darnit ReinH I was trying to get that to work
14:48:50 <Tekmo> banister: Except you'd have to use `runCont`
14:49:03 <ReinH> > [(+1), (*2)] <*> [x, y]
14:49:04 <Peaker> Tekmo, do you know edwardk's machines package? or how it compares to pipes?
14:49:05 <lambdabot>   [x + 1,y + 1,x * 2,y * 2]
14:49:08 <Tekmo> banister: return x = Cont $ \k -> k x
14:49:12 <ReinH> applicative: :D
14:49:26 <Peaker> (it seems to have less type variables, but also seems to cover less ground, I'm not sure)
14:49:38 <Tekmo> applicative: You mean provide a specialized `Pipe` type now that I have generalize?
14:49:43 <Tekmo> Peaker: I do know his package
14:49:55 <banister> Tekmo: cool
14:50:17 <applicative> Tekmo, I was thinking, yes. generalize would take you Pipe i o m a -> Proxy x i x' o m a
14:50:29 <Tekmo> Peaker: Before pipes-4.0 his had some extra power with the ability to do the Tee and Wye stuff, whereas `pipes` forced you to go through the `Proxy` type class which didn't expose enough power for that
14:50:47 <Tekmo> Peaker: But now that the type is concrete and type class is gone those are all implementable
14:50:48 <applicative> machines just hasnt kept up Peaker ;)
14:51:17 <Peaker> did "machines" somehow manage to allow the same compositions with less type parameters or less type-level complexity?
14:51:31 <carter> Tekmo oh?
14:51:36 <carter> whats the newest design?
14:51:38 <applicative> Peaker: the type parameters are really independent of this
14:51:39 <Tekmo> applicative: I have to think about this some more, but the first problem that comes to mind is that there is no way to seal off the upstream end of a unidirectional pipe
14:51:46 <carter> i'm out of date
14:51:46 <Tekmo> carter: It's much simpler!
14:51:59 <carter> is there a blog post  somehwere on the new stuff?
14:52:03 <Tekmo> carter: It's not on Hackage yet, but you can find it on Github
14:52:04 <Tekmo> No
14:52:06 <ReinH> > map ($x) [f, g, h] :: [Expr] -- applicative
14:52:07 <lambdabot>   [f x,g x,h x]
14:52:07 <applicative> Tekmo: oh, we cant just use X and ()
14:52:08 <carter> link?
14:52:09 <applicative> ?
14:52:12 <Tekmo> https://github.com/Gabriel439/Haskell-Pipes-Library
14:52:23 <carter> faster too i hope?
14:52:25 <Tekmo> The basic summary is that the proxy transformer system is obsolete and gone now
14:52:33 <carter> i really want things to be fast in the not io bound case
14:52:34 <Tekmo> and I've done a lot of work on simplifying the types
14:52:41 <carter> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Core.hs ?
14:52:42 <applicative> carter: I'm cleverly keeping the various pipes repos  built with cabal sandbox
14:52:43 <Tekmo> carter: They are already really fast in the pure case, too
14:52:43 <aristid> it's all unidirectional again ;)
14:52:59 <Tekmo> carter: One of the important changes is that `pipes-4.0.0` also enables more efficient idioms, too
14:53:05 <mstksg> is there a reason to decide between Int and Integer besides performance?  if I know my number will always be in int bounds
14:53:07 <Tekmo> For example, `for` loops produce very efficient pure code
14:53:10 <Peaker> are there any public benchmarks comparing conduits and pipes with IO/pure compositions?
14:53:24 <aristid> Tekmo: what was your original motivation for the bidirectionality actually?
14:53:28 <applicative> it would be nice to figure out some decent benchmarks
14:53:50 <Tekmo> aristid: Modeling servers in an RPC style
14:54:03 <ocharles> i think bidirectionality is still going to be necessary for really efficient code in some cases when it comes to IO
14:54:12 <Tekmo> aristid: Then I saw that it produced more symmetric code, which was the reason I kept it
14:54:12 <ocharles> there's no point folding n bytestreams if you can just ask for one large one
14:54:18 <carter> does look simplers
14:54:22 <Tekmo> aristid: Really, the symmetry is the more compelling reason to keep it
14:54:24 <carter> and it still has the upstream powers?
14:54:30 <Tekmo> carter: yes
14:54:33 <ocharles> (but there may also be no point in asking continuously for large bytestrings if you later aren't consuming much of it)
14:54:38 <carter> which is goodo
14:54:45 <carter> whats the innovation / new insight?
14:54:50 <ocharles> likewise for skippable streams and being to send "Skip" upstream
14:54:50 <Tekmo> ocharles is right: you can also parametrize requests for input like requesting a specific number of bytes
14:55:39 <Tekmo> applicative: If you have a unidirectional pipe the Await constructor cannot be forbidden because it has this shape:
14:55:45 <Tekmo> Await (a -> Pipe a b m r)
14:56:00 <Tekmo> applicative: There is no choice of `a` that makes that constructor uninhabited
14:56:09 <Tekmo> applicative: That's why unidirectional pipes can't seal off their upstream ends, but bidirectional ones can
14:56:22 <applicative> hm
14:57:08 <applicative> this seems like a pretty huge cost for this feature
14:57:08 <Tekmo> Buuuut.... I can do what I did in `pipes-1.0` and make setting `a` to `()` the way to seal it off
14:57:32 <sclv_> isn't Void arguably better?
14:57:33 <applicative> I see, so run :: Pipe () () m a -> m a
14:57:46 <ReinH> applicative: btw if you're super into dollar signs, ($x) <$> [f,g,h] :)
14:57:47 <Tekmo> sclv_: I don't want to depend on the `void` package until it gets into the platform
14:58:15 <Peaker> Something I remember disliking a lot about conduit was the way to run them arbitrarily required to have two components, x $$ y  so you reduce everything from N to 2. Rather than 1. Weird.
14:58:34 <aristid> void is an edwardk package no? hasn't he more or less given up the platform dance?
14:58:39 <Peaker> run taking 1 composition-of-everything seems nicer
14:58:49 <applicative> I think it will have to be widely used before it gets in the platform, and bidirectionality is an impediment
14:58:53 <Tekmo> aristid: That's the problem
14:59:09 <aristid> Peaker: i think the underlying types of conduits actually would allow that just fine
14:59:12 <Tekmo> aristid: As an application writer I have no problem depending on Edward's packages, but as a library writer I avoid them
14:59:19 <aristid> Peaker: but the exposed abstractions don't
14:59:48 <aristid> Tekmo: as long as you don't try to get your package into the platform it should be unproblematic ;)
14:59:57 <Tekmo> aristid: I do want to get it into the platform!
14:59:58 <Peaker> aristid, IIRC, it is possible to write your own "run" that takes a single composition, it's just very weird to have 2 compositions as the canonical way to run conduits
14:59:59 <carter> Tekmo: void is in GHC in head
15:00:00 <aristid> i guess for pipes that is the goal though
15:00:05 <carter> :)
15:00:08 <merijn> Tekmo: Would you advise using pipes-3.x for now or switch to pipes-4 for new libraries?
15:00:14 <ReinH> Tekmo: that's kind of a shame... I'd really like to see lens leveraged into the cool libraries it could enable
15:00:16 <aristid> merijn: 4!!
15:00:19 <Tekmo> merijn: Use `pipes-4`
15:00:23 <ocharles> merijn: 5!
15:00:24 <ocharles> err
15:00:25 <applicative> void in the sense of Data.Void, carter?
15:00:26 <haasn> Tekmo: make your own data Cap or so?
15:00:26 <ReinH> same with is other libraries
15:00:28 <elliott> pipes doesn't belong in the Platform, anyway. really out of scope, I think.
15:00:28 <Tekmo> merijn: But don't switch until pipes-safe-2.0 is done
15:00:29 <carter> so yes
15:00:31 <ReinH> *his
15:00:33 <aristid> ocharles: deviant!
15:00:37 <carter> thats the only Void
15:00:38 <Tekmo> merijn: That's the remaining incomplete piece
15:00:52 <Tekmo> merijn: It actually compiles and works right now, but that is not the final API
15:00:53 <aristid> elliott: what _is_ the platform's scope?
15:00:53 <zRecursive> There are many kinds of packages in Hackage. which packages are canonical so that they can be used in production development ?
15:01:05 <ReinH> pipes 3! == pipes 6. I'm just saying.
15:01:10 <Tekmo> ReinH: Note that I do use `lens` for `pipes-parse`
15:01:17 <applicative> zRecursive: well, the platform ones. for the rest you ask for advice
15:01:18 <Tekmo> ReinH: If you guys haven't seen it yet, `pipes-parse` is really elegant now
15:01:22 <ReinH> Tekmo: awesome :D
15:01:25 <quchen> ReinH: Right, because that parses as (pipes 3)! :-P
15:01:26 <Peaker> elliott, ideally, there would be consensus on the one-way-to-compose-streaming-IO-to-rule-them-all, and that was put into the platform. currently, lazy I/O is in the platform! :(
15:01:34 <Tekmo> ReinH: It uses a really cool trick with isomorphisms and lenses to zoom into stream subsets
15:01:37 <applicative> zRecursive: do you know the reverse dependencies page. it helps with this
15:01:43 <Tekmo> ReinH: YOu can even implement codecs this way and zoom into them
15:01:52 <applicative> zRecursive: http://packdeps.haskellers.com/reverse
15:01:55 <Peaker> I guess as long as the world of streaming IO is being overhauled every 3-4 months, the platform should wait before
15:01:56 <zRecursive> applicative: thx
15:02:00 <ReinH> quchen: I was thinking pipes (3!) but ok
15:02:03 <banister> i read somewhere that monadic 'do' notation was invented after monads were discovered to be useful to haskell, do you think monads would still be practical/used if do-notation had not been invented?
15:02:03 <Tekmo> So I've given up on `pipes-parse` getting into the platform but that's still the goal for `pipes`
15:02:14 <haasn> > let fac = product . enumFromTo 1 in fac (fac 4) -- aristid's ambitions are high
15:02:15 <lambdabot>   620448401733239439360000
15:02:21 <ocharles> banister: absolutely, i write lots of code using monadic combinators over do notation
15:02:24 <Tekmo> My plan is to let `pipes-4` sit for half a year before proposing it for the platform
15:02:28 <ocharles> (>>, >>=, >=>, mapM, etc)
15:02:35 <Tekmo> If I can go half a year without changing it then it's stable
15:02:36 <ReinH> banister: you can do lots of useful monadic stuff without do notation
15:02:38 <sclv_> by definition they'd be useful without do notation
15:02:40 <Peaker> banister, definitely.. "do" notation isn't even a huge improvement over direct lambdas
15:02:46 <aristid> haasn: yeah i tried that but miscounted my own ! and 4!!! took too long to compute:D
15:02:48 <sclv_> since they were decided to be useful *before* do notation
15:02:58 <sclv_> by construction rather
15:02:59 <applicative> this pipes-parse is really opaque at the moment, but i haven't studied too much...
15:03:06 <banister> Peaker:  but using the IO monad would be a complete pain, wouldn't it?
15:03:11 <sclv_> no
15:03:14 <merijn> Tekmo: Well, atm my own library is essentially 90% air, so I figure by the time I get anywhere pipes-safe will be done
15:03:26 <applicative> do notation is a massive win over direct lambdas
15:03:27 <sclv_> there's a style of "desugared" "do-less" notation that's very straightforward
15:03:30 <aristid> applicative: it's just State (Producer ...) basically i think:)
15:03:38 <sclv_> you put all your (>>=) at the end of each line
15:03:47 <sclv_> and \v ->  at the start of the following one
15:03:47 <ocharles> which in turn means that parser pipes are basically automaton
15:03:49 <Peaker> banister, lots of languages use explicit semicolons.  If (>>) was used in place of explicit semicolon, and >>= \name ->   in place of   "name <-"   (and a bit more parenthesizing) it wouldn't be that bad
15:03:55 <applicative> aristid: it's more how one would actually use it
15:03:55 <S_J> for a pure function can I chain results like with >>= ? instead of applying before like f1( f2 data ) ?
15:03:56 <sclv_> and ot "looks like do notation" sans noise
15:04:01 <blochchain> is there a fold function that starts with an empty list?
15:04:08 <blochchain> as the accumulator, by default
15:04:13 <applicative> ocharles: thus pipes are really a kind of enclave within FRP?
15:04:15 <carter> Tekmo: void is in ghc HEAD, thats a stronger property than in platform
15:04:18 <Peaker> applicative, why is it a massive win? It saves some parenthesis and a bit of noise
15:04:27 <Tekmo> carter: Is it?  I didn't know that
15:04:31 <carter> yes
15:04:36 <carter> or maybe i'm mixing things up
15:04:52 <carter> i could be
15:04:58 <ocharles> applicative: maybe not pipes in general, but i'm starting to see pipes-parse a bit more like that
15:05:01 <ReinH> banister: not really. There are some really useful things in monad-loops and such, like:
15:05:08 <elliott> S_J: (.)
15:05:11 <applicative> all haskell syntax is devoted to avoiding parentheses which would otherwise be everywhere, and by destroying the capacity for direct parsing on sight by the writer or reader, lead to error
15:05:12 <ReinH> input <- untilJust $ charToInput `liftM` getChar
15:05:13 <sclv_> you don't even pay a parenthesis cost
15:05:15 <Tekmo> applicative: Yes, `pipes` are another way to implement FRP
15:05:23 <Tekmo> applicative: See `pipes-concurrency` which takes this idea to its logical conclusion
15:05:30 <Tekmo> Technically not "functional" reactive programming
15:05:33 <sclv_> because the lambdas and operators give you proper precedence really
15:05:35 <Tekmo> I know sclv will correct me on this
15:05:49 <banister> getLine >>= \a -> getLine >>= \b -> putStrln (a ++ b)      ?
15:05:53 <haasn> S_J: (&) -- from Control.Lens, or roll your own
15:05:57 <applicative> pardon characteristic bad typing Peaker
15:06:00 <sclv_> right. but just insert linebreaks after each >>=
15:06:01 <Tekmo> applicative: I haven't developed this line of `pipes` yet, but it's my next priority after fleshing out text/bytestring support
15:06:07 <sclv_> and it looks much nicer
15:06:16 <ocharles> Tekmo: me and mm_freak are interested in pipes-concurrency and netwire
15:06:19 <ReinH> banister: it can actually be pretty educational to refactor do notation into something simpler using monad combinators
15:06:20 <banister> Peaker: oh you're right
15:06:27 <ocharles> so happy to help with that line of research :)
15:06:33 <banister> Peaker: if i dont need to add extra () into that, that's not bad
15:06:36 <banister> ReinH: cool
15:06:57 <aristid> Tekmo: will the text/bytestring contain an actual splitting pipe? :P
15:07:02 <Tekmo> ocharles: The things I really want to do are to port graphics and mouse/keyboard to `pipes`
15:07:17 <blochchain> is there a break/span function that includes the border case in the first list?
15:07:19 <aristid> well i guess not as it'd probably have to be a parser
15:07:23 <ReinH> banister: Jekor has a good Haskell From Scratch episode on this, Refactoring Monads http://www.youtube.com/watch?v=xUfLvh0jE64
15:07:24 <Tekmo> aristid: Yes, but it would have this signature
15:07:25 <carter> g2g for a bit
15:07:37 <Tekmo> aristid: Producer ByteString m r -> Free (Producer Bytestring m) r
15:07:39 <Peaker> applicative, I think in practice, the >>= and >> have low-enough precedence that not many parenthesis would be needed
15:07:39 <carter> Tekmo: Void is the right type though
15:07:41 <carter> () is wrong
15:07:47 <carter> i can construct a Unit
15:07:50 <applicative> Peaker: you cant use $
15:07:51 <aristid> Tekmo: wait why the Free
15:07:57 <aristid> Tekmo: this is relevant to my interests
15:07:58 <Tekmo> carter: Which type variable in the type signature are you referring to?
15:07:59 <carter> i can't construct a void
15:08:07 <zRecursive> :t ($)
15:08:08 <lambdabot> (a -> b) -> a -> b
15:08:09 <carter> your () vs Void
15:08:21 <zRecursive> :t ($!)
15:08:22 <lambdabot> (a -> b) -> a -> b
15:08:23 <Tekmo> aristid: Because `Free` forces you to consume the first stream of bytes before retrieving the next one
15:08:42 <Tekmo> aristid: while still letting you stream in constant space
15:08:43 <applicative> Peaker: programmer error is exponential in the number of parentheses
15:08:44 <Peaker> applicative, Right, that would incur a bit of extra parens indeed. not sure how bad that would be
15:08:53 <Peaker> applicative, That sounds ridiculous :)
15:09:03 <carter> Tekmo i'll try and concoct a motivating example later :)
15:09:05 <haasn> programmer pain is exponential in the number of parentheses
15:09:07 <Tekmo> aristid: If you split in the naive way by concatenating bytestrings together that has the potential to not straem
15:09:09 <carter> but i can definitely do so
15:09:11 <sclv_> but remember a -> b === b ^a, and if we take void = 0, then we still have e.g. 2^0 which is 1
15:09:14 <aristid> Tekmo: i think i'll need an example to understand that. not now though it's sleepy time for me i'm afraid
15:09:17 <applicative> it's my deep wisdom of today, a bit doubtful, but I affirm it!
15:09:17 <sclv_> so you still have an inhabitant
15:09:24 <sclv_> because you don't need to _match_ on the void
15:09:26 <Tekmo> aristid: Alright, then ask me later
15:09:37 <ocharles> edwardk: glad you found the code readable, thanks for giving it a glance :)
15:09:41 <Tekmo> carter: Note that the Proxy type gets this right
15:09:43 <carter> ok
15:09:46 <aristid> Tekmo: maybe i'll just ask on the list if you're not on the ircs :D
15:09:47 <carter> i'll take a look
15:09:55 <Tekmo> carter: The proxy type sets the output type on the upstream end to `X` (i.e. Void)
15:09:55 <carter> sclv_ so my concern is a none issue semantically?
15:10:02 <carter> i'll look in a little bit
15:10:04 <sclv_> no void is better
15:10:04 <carter> thanks
15:10:05 <Peaker> applicative, btw, it could be nice to have a more generalized un-paren notation that puts parens the way "do" does, but doesn't put any operators, so you could use >>= or <> or such with it
15:10:06 <carter> ok
15:10:08 <sclv_> its just not "good enough"
15:10:08 <Tekmo> carter: This prevents the pipe from requesting anything because it cannot manufacture an `X`
15:10:21 <ReinH> banister: that getLine could be done with putStrLn =<< (++) <$> getLine <*> getLine
15:10:21 <carter> i'l  have to look
15:10:22 <sclv_> interesting question -- how many inhabitants does Void -> Void have?
15:10:25 <S_J> what are Lenses? combinators for pure functions?
15:10:31 <edwardk> n-dolio: the rift story is quite easy given f -| g    the fact that we can use f (Rift f k) ~> k is easy to spot once we use the shape of all left and right adjoints. f ~ (,) e  so its effectively: (e, e -> k a) -> k a
15:10:32 <carter> ttyl all
15:10:44 <banister> ReinH: cool
15:10:49 <banister> i was just thinking about that
15:10:58 <Tekmo> S_J: The simplest use of lenses are to perform operations on a subset of a data structure, sort of like an accessor, except more powerful
15:11:09 <ReinH> banister: which I think is cleaner than the do notation version, modulo groking applicative operators
15:11:21 <Tekmo> Have you read either of my two lens posts?  I think they can help motivate the use of lenses for you?
15:11:23 <edwardk> S_J: a lens is a functional getter/setter pair bundled up into something you can pass around and compose
15:11:47 <Tekmo> Try this one: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
15:11:56 <edwardk> S_J: something that can get a b out of an a  (a -> b)   and something that given a new b, can give you an updated a:   a -> b -> a
15:11:56 <Tekmo> That post introduces Edward's `lens` package
15:12:01 <applicative> > (('a','b'),'c') ^. _1 . _1
15:12:02 <ReinH> Tekmo: I think it might help to say perform operations on a subset *while maintaining the context of the whole*
15:12:02 <lambdabot>   'a'
15:12:05 <S_J> elliott: (.) is not nwhat i wanted since (f . g) would mean first g then f, I want f then g
15:12:11 <ReinH> it's pretty easy to operate on a subset if you don't care about throwing away the rest of the set :)
15:12:12 <haasn> lenslikes in general are composable ways of accessing data structures
15:12:21 <Tekmo> ReinH: Right.  Lenses ignore the parts of the data structure they don't interact with
15:12:22 <banister> ReinH: woudl that be the same as: putStrLn $ liftA2 (++) getLine getLine
15:12:26 <haasn> (prisms notably also allowing you to construct them)
15:12:32 <edwardk> the lens package represents those in a funny way that lets it interoperate with lots of different not-quite- or more-than- lens-like constructions
15:12:38 <applicative> haasn is clearly a convert
15:12:44 <ReinH> banister: try it
15:12:50 <Cale> banister: putStrLn wants a String
15:13:05 <Cale> banister: but you're giving it an IO String
15:13:06 <haasn> the difference between a lens, traversal, fold, getter/setter etc. is generally either how many targets you have, and whether or not you can get/set them
15:13:15 <elliott> S_J: (g . f)
15:13:19 <Cale> banister: you might want to replace $ there with =<<
15:13:20 <ReinH> banister: you want: putStrLn =<< liftA2 (++) getLine getLine
15:13:24 <banister> Cale: this seems tow ork putStrLn =<< liftA2 (++) getLine getLine
15:13:25 <elliott> or (f >>> g) with Control.Category, but that is worse.
15:13:25 <banister> yeah
15:13:26 <haasn> S_J: did you see my reply?
15:13:26 <banister> :P
15:13:42 <S_J> haasn: yes, ty
15:13:47 <banister> that's pretty cool
15:14:08 <applicative> (| putStrLn (| getLine ++ getLine |) @ |)
15:14:15 <ReinH> now do a version with `ap`
15:14:20 <ReinH> applicative: what sorcery is this?
15:14:35 <Tekmo> Idiom brackets
15:14:36 <applicative> nonexistent ideal idiom bracketts
15:14:41 <ReinH> ah
15:14:44 <ReinH> vapoursyntax
15:14:46 <ReinH> love it
15:15:00 <haasn> {-# LANGUAGE VapourSyntax #-} -- at the top of every one of my files
15:15:06 <ocharles> applicative: what's the @?
15:15:16 <ReinH> the brackets, they do nothing
15:15:18 <haasn> ocharles: join?
15:15:24 <Tekmo> lol
15:15:41 <applicative> vapor!
15:15:46 <applicative> ocharles: join
15:16:05 <applicative> ReinH: here's a gutted she preprocessor in one file https://raw.github.com/michaelt/her/master/script/her
15:16:10 <Tekmo> It would be more appealing if `$` were sugar for `=<<`
15:16:23 <applicative> $ is a menace
15:16:42 <haasn> iI putStrLn (iI (++) getLine getLine Ii) J Ii -- so would this work?
15:17:17 <haasn> Ji even
15:18:08 <applicative> ReinH: if you have that file in the same directory with the file to be compiled you can use mc brides idiom brackets still, with {-# OPTIONS_GHC -F -pgmF ./her #-}
15:18:29 <blochchain> if i call the same pure function twice in the same line, does it actually get executed twice?
15:18:46 <Tekmo> blochchain: It depends
15:18:47 <ReinH> "her", "she"?
15:18:50 <applicative> haasn: I think they didn't embed iI &co
15:18:58 <ReinH> blochchain: maybe.
15:19:02 <bb010g> Can all instances of Foldable be made instances of Traversable also?
15:19:07 <Tekmo> blochchain: GHC may share the work or duplicate depending on some heuristics
15:19:11 <cschneid> so when would I want to declare my own monad, as opposed to simply writing functions that use existing monads?  What pushes you in that direction?
15:19:30 <Tekmo> blochchain: If you want to explicitly force sharing, then just write: let x = ... in f x x
15:19:31 <ocharles> cschneid: monad transformer stacks have a cost
15:19:43 <ocharles> cschneid: sometimes you don't want to pay for that, and then it's worth writing your own monad
15:19:50 <Tekmo> cschneid: If you're monad transformer stack is really deep and you reuse the same stack over and over again
15:19:58 <applicative> ReinH: okay, its nonsense i agree
15:20:00 <Peaker> sometimes you discover a new kind of thing that's not already coded as an existing transformer
15:20:06 <ocharles> that too
15:20:44 <Peaker> cschneid, it's very common to use a newtype around a monad transformer stack -- to abstract away the monads inside it
15:21:16 <cschneid> Peaker: right, but that's not really implementing my own monad. Trying to figure out when I'd want to make a new bit of data implement the typeclass.
15:21:31 <ReinH> cschneid: e.g., the Snap monad
15:21:32 <haasn> applicative: I test it, works if you add a type signature to the inner iI Ii
15:21:35 <Tekmo> cschneid: There are a few circumstances were implementing `Monad` helps
15:21:36 <haasn> eg. :: IO String
15:21:58 <Tekmo> cschneid: 1) YOu get `do` notation.  2) All the combinators in `Control.Monad` work with your monad, 3) Monad transformers can extend your monad
15:22:00 <applicative> haasn, ah I misrembered
15:22:03 <ReinH> cschneid: it's often easier to compose a monad from existing building blocks than to write your own. That's why monad transformer stacks are so common.
15:22:28 <cschneid> I've been playing with a ZMQ library: https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ3/Monadic.hs#L189
15:22:33 <isomorphismes> What does mu in mueval-core mean?
15:22:40 <ReinH> You don't have to worry about how your monad manages state transformations because you use StateT and not your own impl, etc.
15:22:42 <cschneid> they implement both a function style, and a monad style interface.
15:23:01 <cschneid> ReinH: right, using monad transformer stacks makes sense.
15:23:17 <ReinH> cschneid: ZMQ is a transformer stack: newtype ZMQ z a = ZMQ { _unzmq :: ReaderT ZMQEnv IO a }
15:23:27 <cschneid> ReinH: ohh, sure enough.
15:23:29 <Peaker> cschneid, someone discovers that probability trees form monads (much like the list monad, but with probabilities attached to each position) --> new monad type
15:23:44 <ReinH> the other nice thing about them is I can look at that and go: Ok, the ZMQ monad is about reading some value and doing IO
15:23:53 <ReinH> and I know that it does exactly those two things and nothing else.
15:23:58 <isomorphismes> Also I tried joelteon's 17:34 (fix $ \f n -> ....) and ghci says ‚àÑ fix
15:24:01 <ReinH> and I know how it does those two things.
15:24:13 <joelteon> ghci says what?
15:24:20 <applicative> import Data.Function
15:24:25 <applicative> ^^^ isomorphismes
15:24:30 <joelteon> let fix f = let x = f x in x
15:24:30 <ReinH> cschneid: monad transformers are a great example of code reuse in practice imo.
15:24:34 <Peaker> cschneid, someone discovers that ASTs with type-parameterized variables are monads --> new data type gets a monad instance
15:24:34 <Tekmo> cschneid: My rule of thumb is to write a tutorial with a lot of example code and then you'll know which style feels more natural to use
15:24:37 <isomorphismes> joelteon: "fix" i snot in scope
15:24:45 <Peaker> ReinH, also a bit of a horror show :)
15:24:46 <isomorphismes> thanks applicative
15:24:50 <ReinH> Peaker: shhhhh
15:24:54 <merijn> Tekmo: Any plans to provide MonadReader/MonadState/etc instances for Proxy?
15:24:59 <Tekmo> merijn: Yes
15:25:02 <Peaker> ReinH, contravariance and monad transformers dislike each other
15:25:03 <ReinH> Peaker: implementation detail :p
15:25:03 <merijn> \o/
15:25:07 <zRecursive> awful monad transformer when seeing the layout signature in xmonad ?!
15:25:07 <cschneid> ReinH: ok, so it sounds like the answer is: "rarely define your own monad from scratch" and instead is more like: "sometimes wrapping up a transformer stack makes sense"
15:25:18 <Tekmo> merijn: I'm thinking of strengthening the `transformers` dependency to `mtl` to add those
15:25:24 <ReinH> cschneid: Yeah, I first look for a stack that gives me what I need.
15:25:26 <isomorphismes> thanks joelteon
15:25:27 <merijn> Tekmo: ok, I'll just live with lift until that point
15:25:29 <joelteon> yep
15:25:36 <ReinH> cschneid: and that's usually as far as you need to go.
15:25:53 <cschneid> ReinH: is the pattern in that ZMQ library common, write a stack, then newtype it to be easier to use or hide the underlying stackiness of it?
15:26:04 <merijn> cschneid: Fairly common, yes
15:26:04 <ReinH> cschneid: yes, you see it all over the place
15:26:08 <Peaker> cschneid, there are many many interesting monads and we've probably not discovered them all.  But there are not that many very-useful monads that cover a lot of use cases, and these ones are already in libraries, so you rarely have to write your own monad instances for your own data types
15:26:21 <ReinH> cschneid: the Snap monad http://hackage.haskell.org/packages/archive/snap-core/0.8.0.1/doc/html/src/Snap-Internal-Types.html#runSnap
15:26:24 <ReinH> etc
15:26:39 <haasn> Peaker: ‚Äòprobably‚Äô :)
15:26:55 <haasn> Peaker: edwardk seems to have discovered them all, he just hasn't gotten round to writing a package for each of them
15:27:00 <isomorphismes> I notice with applicative's solution fix :: (a -> a) -> a whereas with joelteon's fix :: (t -> t) -> t. This is just a cosmetic differenc, correct?
15:27:06 <cschneid> ReinH: ie, the `newtype Snap` part of that, where it is a StateT + stuff.
15:27:23 <Peaker> well, IME, ReaderT, WriterT, StateT, MaybeT, EitherT, ListT, ContT, have me covered almost all of the time
15:27:32 <joelteon> yeah
15:27:33 <ReinH> Peaker: for sufficiently small values of interesting, etc
15:27:47 <josephle> haasn: is edwardk now the Chuck Norris of Haskell?
15:27:48 <joelteon> isomorphismes: ghci picks t, fix is defined as :: (a -> a) -> a in Data.Function
15:27:52 <ReinH> cschneid: right, and then the convenience functions that help access the different parts of the stack
15:27:55 <ReinH> cschneid: writeBS, etc
15:28:19 <joelteon> if you said let fix :: (a -> a) -> a; fix f = ... you'd get the same result
15:28:20 <ReinH> cschneid: they hide the impl of the stack (which layer is which transformer) so you don't have to worry about how to lift into the monad you want
15:28:32 <ReinH> is the state lift or lift.lift? etc
15:28:43 <cschneid> ReinH: ahh, cool. So the full detail of the stack can stay in this module, and users can just call this module's api
15:28:52 <Tekmo> cschneid: Right
15:28:57 <ReinH> cschneid: so the newtype + the convenience methods are what encapsulate and hide the implementation
15:28:58 <cschneid> sweet. I like that.
15:29:02 <Tekmo> cschneid: And if you change the underlying stack later it is transparent to your users
15:29:09 <ReinH> yep
15:29:42 <haasn> isomorphismes: the technical term is alpha equivalence :)
15:29:54 <tdammers> it's fairly common for all kinds of types, not just monads
15:30:06 <edwardk> haasn: just found a few more.
15:30:11 <ReinH> haasn: his handle is "isomorphismes"...
15:30:19 <zRecursive> @unmtl StateT s m r
15:30:19 <lambdabot> s -> m (r, s)
15:30:28 <haasn> ReinH: I was trying to work in a pun based on that
15:30:40 <ReinH> :)
15:30:43 <haasn> edwardk: dualize them
15:30:56 <cschneid> cool, I understand the idea of transformer stacks, but gotta go actually try them I think.
15:30:57 <edwardk> haasn: sadly doesn't work, there are more monads than comonads in HAsk
15:30:57 <cschneid> to fully grok
15:31:19 <edwardk> every comonad gives rise to a monad-transformer, but not every monad is a monad-transformer
15:31:20 <haasn> edwardk: doesn't matter, there are more comonads than monads in Cohask so it works out
15:31:21 * applicative is amazed that edwardk has counted all the monads
15:31:24 <Tekmo> cschneid: Have you read "Monad transformers - step by step"?
15:31:38 <cschneid> Tekmo: don't think so. the RWH example was pretty clear
15:31:47 <Tekmo> cschneid: Ok
15:31:53 <cschneid> it's at the point where I need a problem that pushes me that direction, and then implement them myself.
15:32:01 <edwardk> applicative: i only had to count to infinity twice. it took me a couple of hours
15:32:04 <cschneid> I'll check that tutorial though, thanks
15:32:09 <applicative> ha
15:32:10 <Tekmo> You're welcome
15:32:26 <merijn> There's no way to scope a where clauses over multiple function patterns, right?
15:32:31 <c_wraith> I hear that if you zip them, you can count to infinity twice in the same amount of time as counting to infinity once.
15:32:35 <Tekmo> merijn: Use case instead
15:32:52 <applicative> cschneid: they are much easier to grasp at first if you're in some environment where they're part of the style, like conduits i guess
15:33:07 <ReinH> I don't even know what cohask would be.
15:33:20 <ReinH> I realize you're joking but is that actually a meaningful concept?
15:33:33 <applicative> the arrows A -> B are functions from B to A
15:34:06 <cschneid> applicative: that sounds scary. :) I'll just try to put a reader on top of things for a config value. And see how that goes :)
15:34:24 <haasn> edwardk: don't we get a comonad for free from any monad?
15:34:29 <ReinH> c_wraith: but can you count to infinity an infinite number of times in the same amount of time as counting to infinity once?
15:34:44 <ReinH> I guess it depends on which alephs we're talking about
15:34:51 <c_wraith> ReinH: yes it does
15:34:56 <ReinH> and whether I decide to accept CH today
15:35:18 <edwardk> haasn: sadly it doesn't work that way. the comonad-to-monad transformer can be stated one of two ways, one is that you can 'sandwich' a monad in between any adjunction. so if you have f -| g, then gf is a monad, but so is gmf for any monad m in the category the adjunction 'travels through'
15:35:20 <applicative> ReinH: this is all aleph-0 for crying out loud
15:35:22 <c_wraith> I mean, you can consider NxN to be infinity infinities, and it's still enumerable.
15:35:34 <isomorphismes> haasn: What does alpha equivalence mean? It's the isomorphism of (letter.1 -> letter.2) onto (letter.3 -> letter.4) ? or more generally letter.seq.Œ± onto letter.seq.Œ≤?
15:35:44 <edwardk> so if you have an adjunction that 'travels through' hask^op, then m there should be a comonad in hask.
15:36:08 <ReinH> c_wraith: right, |N2| = |N|, I know
15:36:17 <haasn> isomorphismes: I'm not sure what that's supposed to mean but in general you can swap any bound variable for any other bound variable (assuming none conflict) and the meaning will be unchanged
15:36:17 <edwardk> an example of such an adjunction is the adjunction for (-> r) with itself that gives rise to Cont
15:36:31 <ReinH> I was just trying to make a joke about the continuum hypothesis :(
15:36:36 <c_wraith> ReinH: N2 = N^2?
15:36:43 <edwardk> another way to view it is to take the right kan lift along a comonad, then you get forall r. w (a -> r) -> r     for some comonad w.
15:36:44 <isomorphismes> haasn: just making the analogy that ABCDE has the same # of permutations as 12345
15:36:51 <applicative> ReinH: ;)
15:36:54 <ReinH> c_wraith: yes
15:36:57 <edwardk> and that forms a monad
15:37:25 <ReinH> an old coworker of mine likes to joke that he accepts the axiom of choice on alternate days
15:37:36 <ReinH> I think I was the only one who actually got the joke
15:37:45 <ReinH> (accepts or rejects it, that is)
15:37:51 <haasn> edwardk: hask^op ?
15:38:12 <ReinH> I like to time how long it takes edwardk to completely lose me in the maths.
15:38:16 <ReinH> Usually it's about 3 lines.
15:38:22 <ReinH> right kan lift. OH OF COURSE.
15:38:40 <ReinH> I even read his kan library. Still have no idea.
15:38:55 * applicative imagines he's up to four lines, but it's probably an illusion
15:38:55 <ReinH> well, skimmed
15:38:57 <edwardk> because we can break w up into its adjunction f -| g, so that w ~ fg and we get f (g (a -> r) -> r   which we can move right through the adjunction to get g (a -> r) -> g r.
15:39:07 <edwardk> and we can make the monad for that
15:39:10 <S_J> Did someone answer this? I'm writing a key-value store but not having much of a clue :). i try to find info on a suitable filesystem. should i load the whole database into RAM etc. any tips?
15:39:23 <edwardk> ReinH: i'm mostly "explaining" this one for myself
15:39:27 <ReinH> S_J: that doesn't sound like a Haskell question...
15:39:29 <ggherdov> [OT] just in case anybody wants to compete in the ICFP programming contest next w/e, deadline for registration is 90 minutes from now. Look: http://research.microsoft.com/en-us/events/icfpcontest2013/
15:39:30 <edwardk> since i'm still in the process of writing this library ;)
15:39:39 <edwardk> and i'm in the process of figuring out what to put in the haddocks
15:39:43 <ReinH> heh
15:39:43 <Tekmo> S_J: YOu mean a library for interacting with the filesystem?
15:39:50 <haasn> edwardk: just copy this IRC transcript in there
15:39:59 <edwardk> http://hackage.haskell.org/packages/archive/kan-extensions/3.4/doc/html/Data-Functor-KanLift.html covers right kan lifts a bit
15:40:05 <haasn> documentation should be done that way in general ;)
15:40:42 <edwardk> ggherdov: wow they are requiring early reg? that'll cut _way_ down on entrants
15:40:49 <ReinH> applicative, c_wraith: see, it's funny because the axiom of choice does not apply when you have a selection rule.
15:41:01 <ReinH> Whatever, I thought it was funny.
15:41:03 <haasn> edwardk: does every comonad arise from an adjuction or just some?
15:41:03 <applicative> ggherdov: this does sound like a terrible idea
15:41:05 <edwardk> ggherdov: i usually don't bother to register til the day of the event and then only if it turns out to be interesting
15:41:05 <ReinH> :p
15:41:06 <ggherdov> edwardk: I have no idea, and I am pretty annoyed too
15:41:25 <cschneid> ggherdov: is there a list of previous year's problems? Sounds interesting as ideas to play with.
15:41:27 <edwardk> haasn: every monad and very comonad arises from an adjunction
15:41:36 <applicative> ReinH: yes I was thinking, he believes it on some days but not on others; but couldn't tell us which
15:41:45 <ggherdov> cschneid: http://en.wikipedia.org/wiki/ICFP_Contest
15:42:00 <cschneid> ggherdov: ya, but with full descriptions?
15:42:17 <ggherdov> cschneid: i think you'll find link to the tasks from that wp page
15:42:32 <edwardk> that adjunction may not be an adjunction 'from Hask to Hask', and there are often several adjunctions you can use, given that the adjunction to/from the eilenberg-moore category and the kleisli categories are initial/terminal versions of that adjunction and there can be others in between, like the one for state in terms of (,) e -| (->) e
15:42:47 <ggherdov> each year is hosted at a different university, so they're spread all across the internet :)
15:43:04 <isomorphismes> Is Œª substitution and . composition?
15:43:28 <ggherdov> cschneid: see "External links"
15:43:54 <cschneid> ggherdov: yeah, there we go. I can probably grab a few off that.
15:44:24 <haasn> edwardk: I still have no real intuition for what it means for something to be adjoint; other than vaguely knowing what the types and laws look like
15:44:38 <haasn> is there some sort of interpretation, perhaps in Haskell, that could help me internalize them?
15:44:52 <ReinH> edwardk: I know some of these words http://www.reactiongifs.com/wp-content/uploads/2011/09/mind_blown.gif
15:46:42 <S_J> how do i add two maybe values the cleanest way?
15:46:50 <haasn> ‚Äòadd‚Äô?
15:47:25 <lightquake> > liftM2 (+) (Just 8) (Just 20)
15:47:26 <lambdabot>   Just 28
15:47:29 <lightquake> > liftM2 (+) (Just 8) Nothing
15:47:29 <lambdabot>   Nothing
15:47:33 <S_J> Just 5 + Nothing = Just 5; Just x + Just y = Just  x+y)
15:47:41 <josephle> > Just 8 `mappend` Just 20
15:47:42 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
15:47:42 <lambdabot>    arising from a use of `e_1820'
15:47:42 <lambdabot>  ...
15:47:45 <lightquake> oh you want *that* semantics
15:48:22 <elliott> > Just (Sum 5) <> Just (Sum 3)
15:48:23 <lambdabot>   Just (Sum {getSum = 8})
15:48:29 <haasn> > (getSum . mappend `on` fmap Sum) (Just 3) Nothing
15:48:30 <lambdabot>   Couldn't match type `Data.Maybe.Maybe (Data.Monoid.Sum a0)
15:48:30 <lambdabot>                 ...
15:48:31 <cschneid> Œª sum $ catMaybes [Just 5, Nothing]
15:48:32 <cschneid> 5
15:48:32 <cschneid> Œª sum $ catMaybes [Just 5, Just 2]
15:48:33 <cschneid> 7
15:48:50 <elliott> cschneid: cute, but you can't distinguish Just 0, Just 0 from e.g. Nothing, Nothing
15:48:56 <elliott> (presuming the latter should be Nothing)
15:49:00 <ReinH> > getSum <$> Just (Sum 4) <> Just (Sum 5)
15:49:00 <ocharles> How do i write a 'Ptr a' into a ByteString?
15:49:01 <lambdabot>   Just 9
15:49:03 <cschneid> elliott: damn.
15:49:20 <ocharles> I may of course be going about this the wrong way...
15:49:20 <johnw> elliott: wait, why not?
15:49:23 <ion> ocharles: In what format?
15:49:27 <johnw> isn't Just () equivalent to 1, and Nothing to 0?
15:49:31 <blochchain> https://github.com/plsql/Haskell-Snippets/blob/master/Readability.hs     can anyone spot the logic bug in this? it's printing 1
15:49:38 <elliott> johnw: Just ()?
15:49:50 <johnw> oh, Just 0
15:49:55 <johnw> my font makes those too similar
15:50:03 <ion> ‡≤†_‡≤†
15:50:04 <elliott> anyway, getSum (fmap Sum x <> fmap Sum y) works, but I bet you can make that nicer.
15:50:07 <johnw> you're saying Nothing is an effective zero
15:50:14 <edwardk> haasn: an adjunction is a relationship between of the 'simplest/most efficient solution for a problem' and 'the most complex problem for which that is a solution'. Perhaps a more useful way to think of it is to say that two functors are adjoint (f -| g) when   forall x y.   (f a -> b)  is isomorphic to (a -> g b)   (for arrows in the appropriate categories)
15:50:14 <ocharles> ion: I need to construct a pointer to a http://jcatki.no-ip.org:8080/SDL_mixer/SDL_mixer_85.html#SEC85
15:50:19 <johnw> elliott: I wonder if you can do something with ala there
15:50:29 <ocharles> ion: I have a ByteString that is the abuf, which I made into a Ptr with useAsCString
15:50:46 <ocharles> ion: so then I thought I could just pack [] another ByteString together and use that as a CString to get another Ptr
15:50:50 <elliott> :t ala Sum foldMap
15:50:52 <lambdabot> (Num s, Foldable t) => t s -> s
15:51:06 <elliott> :t ala Sum (foldMapOf both)
15:51:06 <edwardk> left adjoints (f) and right adjoints (g) in that (f -| g) relationship act very differently.
15:51:06 <lambdabot> Num a => (a, a) -> a
15:51:12 <elliott> :t ala Sum (foldMapOf (both._Just))
15:51:13 <lambdabot> Num a => (Maybe a, Maybe a) -> a
15:51:15 <edwardk> a common example is that (,) e -| (->) e
15:51:16 <elliott> hmm
15:51:18 <edwardk> so what does that mean?
15:51:22 <ocharles> ion: I just have no idea how to get the Ptr as bytes to pack into my bytestring
15:51:47 <edwardk> that means we should expect that ((e, a) -> b) is isomorphic to a -> e -> b
15:51:48 <elliott> edwardk: can we get f (Just x) (Just y) = Just (x+y); f Nothing y = y; f x Nothing = x nicely with ala and Sum?
15:51:53 <haasn> edwardk: hang on I'm trying to figure out a nicer way to write this Sum/mappend stuff
15:52:01 <edwardk> :t uncurry flip
15:52:02 <lambdabot> (a -> b -> c, b) -> a -> c
15:52:04 <haasn> edwardk: isn't there some function in lens for this?
15:52:31 <Tekmo> Could (^?) do this?
15:52:31 <edwardk> haasn: what is th problem statement?
15:52:42 <ion> ocharles: I happen to be converting from ByteString to ForeignPtr and vice versa in <https://gist.github.com/ion1/6029868#file-check-hs-L25>, perhaps that‚Äôs useful.
15:52:42 <Tekmo> (^? traverse . traverse)?
15:52:56 <Tekmo> ... assuming the input is a list of [Maybe a]
15:53:14 <ocharles> ion: thanks, i'll take a look
15:54:00 <haasn> edwardk: prettify fmap getSum .: (mappend `on` fmap Sum) :: Num b => Maybe b -> Maybe b -> Maybe b
15:54:13 <haasn> I'm thinking something like ‚Äòala‚Äô or similar could come in handy to do the wrapping/unwrapping automatically
15:54:44 <edwardk> lens generally gives you very little for walking multiple structures at the same time
15:54:55 <Tekmo> :t (<>~)
15:54:56 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
15:55:06 <danharaj> tadpole operator
15:55:11 <Tekmo> :t (traverse <>~)
15:55:12 <lambdabot> (Traversable t, Monoid a) => a -> t a -> t a
15:55:17 <blochchain> https://github.com/plsql/Haskell-Snippets/blob/master/Readability.hs     can anyone spot the logic bug in this? it's printing 1
15:55:20 <elliott> well, [Maybe a] -> Maybe a or such would work too
15:55:24 <elliott> or (Maybe a, Maybe a) -> Maybe a using both
15:55:43 <Tekmo> :t (^? both . traverse)
15:55:44 <lambdabot> Traversable t => (t a, t a) -> Maybe a
15:55:49 <edwardk> haasn: where you want Nothing one of the inputs is missing? or to treat it as 0?
15:55:57 <Tekmo> :t (^? both . _Just)
15:55:58 <lambdabot> (Maybe b, Maybe b) -> Maybe b
15:56:00 <Tekmo> There, that's it
15:56:18 <haasn> edwardk: as 0, like mappend
15:56:29 <merijn> Tekmo: I have a "Producer a (StateT s (ReaderT i IO)) r" that I want to turn into a "Producer a (ReaderT i IO) r", I thought I could just do "evalStateP initState . forever $ myPipe", but then I seem to be unable to lift get into getting the state value out?
15:57:03 <ReinH> now uncurry fmap and go to town
15:57:05 <Tekmo> merijn: You mean to get the state from the return value?
15:57:33 <Tekmo> merijn: What's the ideal signature you have in mind?
15:57:42 <johnw> merijn: you'd have to lift, get the StateT's state, lift.lift to get into ReaderT, and then return a Producer action using that state, and then re-run it from somewhere else I believe
15:57:43 <edwardk> :t au (mapping (wrapping Sum))
15:57:44 <lambdabot> Functor f => ((f t -> f (Sum t)) -> e -> f (Sum t)) -> e -> f t
15:58:03 <merijn> johnw: I know, but "lift get" gives a type error
15:58:03 <edwardk> :t au (mapping (wrapping Sum)) foldMap
15:58:03 <lambdabot> (Functor f, Foldable t1, Monoid (f (Sum t))) => t1 (f t) -> f t
15:58:11 <johnw> merijn: pastie?
15:58:15 <haasn> :t ala Sum foldMap
15:58:16 <lambdabot> (Num s, Foldable t) => t s -> s
15:58:18 <edwardk> :t au (mapping (wrapping Sum)) foldMap [?x,?y]
15:58:18 <lambdabot> Not in scope: `?'
15:58:19 <lambdabot>     A section must be enclosed in parentheses thus: (? x)
15:58:19 <lambdabot> Not in scope: `?'
15:58:30 <edwardk> :t \x y -> au (mapping (wrapping Sum)) foldMap [x,y]
15:58:31 <lambdabot> (Functor f, Monoid (f (Sum t))) => f t -> f t -> f t
15:58:35 <Tekmo> merijn: Where are you using the `get`?
15:58:46 <merijn> Tekmo: Basically, I have a "Consumer a (ReaderT i IO) r" and "Producer a (StateT s (ReaderT i IO)) r" that I want to tie together
15:58:47 <edwardk> not recommended for public consumption ;)
15:58:48 <haasn> edwardk: oh, interesting
15:58:58 <haasn> :t mapping
15:59:02 <edwardk> :t \x y -> au (mapping (wrapping Sum)) (foldMapOf both) (x,y)
15:59:03 <lambdabot> (Functor f, Monoid (f (Sum t))) => f t -> f t -> f t
15:59:22 <Tekmo> merijn: evalStateP p1 >-> p2
15:59:34 <Tekmo> merijn: evalStateP p1 initialState >-> p2
15:59:41 <S_J> > read "5"::Int
15:59:42 <lambdabot>   5
15:59:43 <Tekmo> Ack, that's backwards
15:59:49 <Tekmo> merijn: evalStateP initialState p1 >-> p2
16:00:27 <hpaste> merijn pasted ‚Äúpipes‚Äù at http://lpaste.net/91614
16:00:37 <merijn> Basically, I have something like that
16:01:03 <merijn> Except that "lift get" and "lift (put r)" seem to be type errors
16:01:47 <Tekmo> merijn: Let me check
16:02:35 <merijn> Which is odd, as when I replace "get" with undefined, ghc-mod tells me that the type of the undefined has to be "StateT ByteString (ReaderT Handle IO) ByteString"
16:02:46 <merijn> Which seems like it should match get?
16:03:46 <blochchain> https://github.com/plsql/Haskell-Snippets/blob/master/Readability.hs     can anyone spot the logic bug in this? it's printing 1
16:03:56 <haasn> edwardk: au (mapping (wrapping Sum)) is pretty much exactly what I was looking for, thanks
16:04:15 <Tekmo> merijn: Yeah, it looks correct so far.  I'm digging into this
16:04:28 <Tekmo> OH!
16:04:38 <hpaste> merijn annotated ‚Äúpipes‚Äù with ‚Äúcomplete example‚Äù at http://lpaste.net/91614#a91615
16:04:47 <Tekmo> Turn the evalStateP to not use composition
16:04:54 <Tekmo> evalStateP BS.empty $ forever ...
16:05:38 <blochchain> (i changed main, it no longer prints 1, obviously)
16:05:55 <FreeFull> I know BS is ByteString but I always see it as bulls
16:06:17 <johnw> i just use B, because they are not strings!! ;)
16:06:43 <merijn> Tekmo: Then I get a type error on forever?
16:06:54 <quchen> FreeFull: In `BS.Char8` the BS is bullshit. ;-)
16:06:58 <Tekmo> merijn: I just type-checked your code with that fix
16:07:07 <FreeFull> johnw: They are a substitute for strings of bytes
16:07:14 <Saizan> blochchain: one safeTail too much
16:07:17 <johnw> That's how you know you live in a mortal world: when doing something forever gives you a type error.
16:07:20 <Saizan> *many
16:07:22 <FreeFull> Although I guess ByteList would be better
16:07:51 <johnw> FreeFull: they're strings in the mathematical sense, but in the sense anyone usually means here
16:07:54 <quchen> FreeFull: It's a list of vectors internally I think.
16:07:57 <johnw> ^not
16:08:06 <Tekmo> merijn: I fixed it.  See my annotation
16:08:16 <blochchain> Saizan, what do you mean by that?
16:08:43 <FreeFull> quchen: It doesn't matter what it is internally, what matters is that it's a replacement for [Word8]
16:08:55 <FreeFull> Or whatever it was
16:09:05 <quchen> Yeah, [Word8] is right
16:09:13 <merijn> Tekmo: You just changed the $ into ., right?
16:09:17 <Tekmo> merijn: Right
16:09:18 <Saizan> blochchain: on line 11, it seems like safeTail is just discarding stuff
16:09:22 <blochchain> ah i see
16:09:25 <Tekmo> merijn: Wait, the other way around
16:09:28 <Tekmo> merijn: . into $
16:09:37 <mel-> Hi, I can make ghc crash with 4 lines of code: http://lpaste.net/91617 -- anyone knows how I can workaround this bug and/or if this fixed in recent versions?
16:09:40 <merijn> Tekmo: That still errors for me
16:10:12 <Tekmo> merijn: You need to use a strict state monad
16:10:20 <Tekmo> merijn: Control.Monad.Trans.State.Strict
16:10:46 <merijn> oh >.<
16:10:57 <Saizan> mel-: line 2 is not enough?
16:10:58 <merijn> Tekmo: Thanks!
16:11:02 <Tekmo> merijn: You're welcome!
16:11:18 <haasn> mel-: fixed in 7.6 iirc
16:11:21 <merijn> On semi-related note, a pox upon all these strict/lazy variants!
16:11:39 <quchen> haasn: What was the bug?
16:11:44 <haasn> quchen: deriving (read)
16:11:47 <haasn> lowercase, with parentheses
16:11:49 <mel-> Saizan: no
16:11:49 <haasn> the combination caused a crash
16:12:04 <quchen> haasn: That sounds like an odd special case. It should just be a syntax error, no?
16:12:15 <haasn> it should be, yes
16:12:17 <merijn> Tekmo: It was actually just the Strict thing, changing that and turning $ back into . still type checks
16:12:34 <haasn> quchen: or ‚ÄúIllegal deriving item `read'‚Äù apparently
16:12:59 <Tekmo> merijn: That's weird that it type checks
16:13:02 <mel-> quchen, haasn: I'm not sure... are you discussing my problem or something else?
16:13:09 <quchen> mel-: Yes, your problem.
16:13:17 <merijn> Tekmo: Why?
16:13:39 <mel-> quchen: so you are  saying i have case problem?
16:13:41 <Tekmo> merijn: I'm pretty sure that the version with $ is the correct one, and the version with . will just infinitely loop
16:14:03 <quchen> mel-: haasn said that the "(read)" causes the trouble, and it's been fixed in 7.6. (Which I can confirm, it won't compile because illegal deriving.)
16:14:10 <Tekmo> merijn: Infinitely loop in the wrong way (i.e. do nothing)
16:14:18 <merijn> Tekmo: "f . g $ x" should be identical to "f $ g $ x"
16:14:23 <haasn> mel-: the ‚Äòr‚Äô needs to be upper-case, as in Read :)
16:14:23 <Tekmo> merijn: Oh wait
16:14:26 <Tekmo> merijn: Never mind
16:14:29 <Tekmo> merijn: You're right
16:14:30 <quchen> mel-: (read) should be a syntax error there, because you can only derive typeclasses, and those start with capital letters.
16:14:35 <mel-> aaah, thanks!
16:14:36 <Tekmo> merijn: I missed the second `$`
16:14:41 <merijn> Tekmo: :)
16:14:43 <Tekmo> merijn: That was what was confusing me
16:14:47 <haasn> mel-: (that doesn't change the fact that GHC crashing is a bug which has been fixed)
16:14:54 <Tekmo> merijn: Yeah, both versions are right
16:15:44 <mel-> haasn: okay, good. i didn't realize that the bug is 'that' trivial to work around  (i.e. by fixing the code ;-)
16:18:08 <haasn> I think it may have been fixed in 7.4.2 even, why are you still using 7.4.1?
16:18:26 <mel-> i didn't update my fedora 18 yet.
16:18:50 <mel-> and 7.4.1 is probably the version in the repository.
16:23:21 <haasn> isomorphismes: thanks for the link, I'm afraid it loses me fairly quickly though :)
16:24:25 <Guest75343> > 2 * 2
16:24:26 <lambdabot>   4
16:27:16 <S_J> :t read
16:27:17 <lambdabot> Read a => String -> a
16:27:25 <haasn> edwardk: is there a relationship between Adjunction f g and forall a. f (g a) -> g (f a) -- ?
16:27:35 <S_J> :t show
16:27:36 <lambdabot> Show a => a -> String
16:28:45 <haasn> well, the latter can obviously be derived from the former, but what about the reverse?
16:28:54 <scshunt> http://www2.macleans.ca/2013/08/06/to-justin-trudeau-and-chrystia-freeland-re-the-middle-class/
16:28:59 <scshunt> err, wronng channel
16:29:00 <scshunt> sorry :(
16:32:01 <edwardk> haasn: well. every right adjoint g : C -> Set is (co)representable, which means it is isomorphic to a function (->) x    so that is f (x -> a) -> x -> f a   -- which is easily implemented with \fxa x -> fmap ($x) fxa
16:32:17 <edwardk> plus the use of the isomorphism in each direction
16:33:08 <edwardk> notice that that is a stronger claim. that says that if you have f -| g, then you can take g a out of _any_ functor h, not just f.
16:33:21 <edwardk> also if you have f -| g, then you can push f into _any_ functor h, not just g.
16:34:00 <haasn> what does that last one look like?
16:34:15 <edwardk> if f is left adjoint to a functor g : C -> Set, then f is isomorphic to (,) x, so we can use the strength of the functor h, to move the product inside
16:34:45 <edwardk> \ e ha -> fmap (,e) ha
16:36:13 <edwardk> there are more fundamental statements about right adjoints preserving limits and left adjoints preserving colimits that give you another way to talk about this, but the above is sufficient for this task
16:40:30 <haasn> makes sense
16:45:22 <ehaliewicz> just a curious question, can anyone tell me how the performance of haskell compiled to C usually relates to ghc's native output?
16:46:00 <haasn> edwardk: this is ‚Äòdistribute‚Äô then?
16:46:06 <edwardk> yep
16:46:16 <hpc> ehaliewicz: completely seriously, "pretty good"
16:46:28 <edwardk> distribute and strength respectively
16:46:56 <geekosaur> ehaliewicz, ghc doesn't compile haskell to C. and arguably it didn't before (well, it was "C" but rather strange C compiled to assembler and then postprocessed by a script commonly called the "evil mangler")
16:47:04 <hpc> ehaliewicz: for casual code, you'll probably get around 5-10x slowdown by using ghc; you can optimize down to same-speed or 2x
16:47:19 <hpc> ehaliewicz: which is still a damn sight better than you get from an interpreted language
16:47:33 <geekosaur> there is a porting mode (which I think is currently broken) which produces portable ANSI C but the result is *very* slow and only suitable for bootstrapping a new platform
16:48:07 <Demos_> that said haskell is not very good for real time applications
16:48:08 <geekosaur> on the other hand, jhc can do a pretty good job of compiling Haskell (standard + a few simple extensions) to ANSI C
16:48:11 <haasn> :t distribute -- do we have this here?
16:48:12 <lambdabot>     Not in scope: `distribute'
16:48:12 <lambdabot>     Perhaps you meant `distrib' (imported from Control.Lens)
16:48:35 <ehaliewicz> ok thanks
16:48:39 <edwardk> :t Data.Distributive.distribute
16:48:39 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
16:48:46 <edwardk> :t Data.Distributive.collect
16:48:47 <lambdabot> (Functor f, Data.Distributive.Distributive g) => (a -> g b) -> f a -> g (f b)
16:48:51 <hpc> Demos_: you really have to specify what level of real-time you are talking about
16:49:04 <fi4o> is there a way to access an out of scope binding inside a do notation, i.e. x <- f (\_ -> ... x ...)?
16:49:11 <ehaliewicz> i read about a -C option for ghc, and I was curious what level of performance you could expect from it
16:49:14 <edwardk> Every distributive functor is representable and every representable functor is a right adjoint (in Hask)
16:49:17 <hpc> there's "this has a delay of 5 microseconds, this program is worthless"
16:49:20 <haasn> edwardk: I like how (??) is essentially distribute
16:49:20 <Demos_> this is true, I am talking about like "if this takes a 3ms pause people will die
16:49:22 <ehaliewicz> if it's just for porting, it makes sense there's been little work done on optimization
16:49:28 <haasn> and hence ‚Äòflip‚Äô
16:49:29 <edwardk> :t (??)
16:49:29 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:49:29 <ReinH> Demos_: haskell is plenty good for lots of real time applications
16:49:33 <ReinH> just not hard real time
16:49:41 <Demos_> yeah, that is what I am saying
16:49:59 <hpc> ehaliewicz: if it's speed you really want, the magic flags are -O2 -fllvm
16:50:01 <edwardk> (??) is the the 'strength' one i mentioned before. pretty much the opposite
16:50:05 <geekosaur> fi4o, there is a recursive do notation, but you should understand it before using it. (it also varies depending on ghc version; it was mdo in older ghc and it's do rec in newer ones, and in both cases must be enabled by an extension)
16:50:07 <ReinH> (which is to say, GHC isn't good at hard real time. Haskell the langauge could be good but it would require quite a different implementation)
16:50:09 <edwardk> it is the ability to move 'a' into the Functor f.
16:50:13 <Demos_> anyway I am going to disconnect now because I am tired and just want to sleep
16:50:52 <hpc> ehaliewicz: keep in mind you will never ever ever beat C in cpu performance, so try and make up the difference in programmer performance
16:51:07 <tabemann> ReinH: wouldn't the first thing be that the garbage collector would have to be incremental, so time spent GCing could be controlled, rather than stop-the-world?
16:51:25 <hpc> fi4o: if you don't want fancy syntax, mfix will do the trick
16:51:39 <haasn> edwardk: instance Distributive ((->) e) where distribute a e = fmap ($e) a -- this is the definition of (??) from Control.Lens.Combinators
16:51:57 <fi4o> geekosaur: thanks. i tried using mvars, but then the whole inner function must be in the IO monad, i was wondering if there's some trick wrt laziness or something
16:51:58 <hpc> fi4o: which is what recursive do notation eventually turns into
16:52:05 <ReinH> tabemann: that's necessary but not sufficient
16:52:06 <tabemann> one could argue that the increased *correctness* of GC definitely makes up for any loss in performance
16:52:19 <ReinH> tabemann: the runtime would have to guarantee that memory is released at least as quickly as it is acquired at all times
16:52:23 <edwardk> haasn: yep
16:52:24 <monochrom> has anyone asked how fi4o will actually use whatever you suggest?
16:52:53 <fi4o> hpc: yes, that's what i'm looking for, is there an example somewhere?
16:53:03 <edwardk> due to the adjunction i guess you can see it either way =P
16:53:17 <geekosaur> I didn't ask but I hinted at "make sure you know what you're doing and why"...
16:53:20 <edwardk> as pushing 'a' under or pulling the representable functor out
16:53:30 <tabemann> ReinH: that's if you wanted it to operate in constant memory space, which is something that *is* necessary for some applications, but for realtime itself it is time characteristics and not memory characteristics that matter
16:53:46 <haasn> edwardk: I guess because all haskell functors are strong
16:53:50 <hpc> fi4o: not that i know of; to appease monochrom i will suggest that you find some way on your own that works, and then lpaste it so someone in channel can suggest improvements
16:53:50 <tabemann> and I'm not sure if ensuring operating in constant memory space is possible
16:53:53 <edwardk> haasn: yep
16:54:11 <tabemann> (actually, it isn't)
16:54:14 <ReinH> tabemann: memory characteristics matter as much as time
16:54:17 <ReinH> assuming finite space
16:54:23 <fi4o> hpc: thanks, will do :)
16:54:28 <edwardk> which is why you can always push the something under the functor and the ability to cancel that something meaningfully with the functor underneath comes from it being representable.
16:54:46 <tabemann> the problem is that there's nothing in the language that stops someone from constructing a single huge list and holding one end of it, so it's never GCed
16:55:06 <tabemann> i.e. you can't design constant memory space into the language implementation
16:55:20 <ehaliewicz> hpc: no, i'm just curious.  there's a criminal lack of haskell in my code directories
16:55:27 <ReinH> tabemann: you can't do that with C either
16:55:54 <ReinH> but the point is that the developer needs to be able to guarantee that some system will operate in constant (or at least bounded) space
16:55:57 <ReinH> not that every system will
16:56:38 <hpc> ehaliewicz: if you are past the stage of "oh god, must learn everything", start by just writing small utility programs with it
16:56:42 <tabemann> it *might* be possible to design a runtime that guarantees that *unreachable* memory will be GCed at the rate that memory is allocated, provided unreachable memory is available
16:56:52 <hpc> ehaliewicz: one i did was to parse the ghc manpage and generate a bash completion file
16:57:02 <hpc> http://hackage.haskell.org/package/ghc-man-completion
16:57:12 <ehaliewicz> hpc: im at the stage where i wish i knew haskell immediately so i could write the fun programs
16:57:20 <monochrom> use "real-time embedded system" to indicate "I only have 10 milliseconds and 640 bytes"
16:57:25 <hpc> tiny useful things are something hackage is lacking
16:57:32 <hpc> (there is no shortage of edwardk though)
16:57:51 <ReinH> monochrom: it doesn't matter what the time and space constraints are
16:57:53 <ReinH> only *that* they are :p
16:58:06 <tabemann> to me when one is talking about hard realtime, we are talking about deadlines in the scales of milliseconds or even hundreds of microseconds, but what do I know
16:58:11 <monochrom> yeah, I made up the numbers :)
16:58:48 <ReinH> tabemann: a hard real time system is any system with deadlines *where missing a deadline is considered a total system failure*
16:58:57 <tabemann> (I have coworkers working on a project where they're literally apportionating out microseconds, with tolerances measured in them)
16:59:09 <ReinH> But generally the interesting ones have deadlines on the order of milliseconds, not petaseconds ;)
16:59:27 <edwardk> tabemann: look into 'metronome'
16:59:31 <edwardk> @google metronome gc
16:59:32 <lambdabot> http://researcher.watson.ibm.com/view_project_subpage.php?id=175
16:59:32 <lambdabot> Title: Metronome - Metronome GC
16:59:37 <tabemann> strictly speaking yes - but a deadline in petaseconds is much easier to meet than a deadline in microseconds
16:59:54 <ReinH> tabemann: yes, but that is merely a difference of degree ;)
17:00:00 <ReinH> for sufficiently pedantic values of "merely"
17:00:16 <edwardk> they are steadily working on getting gc pause times down to about 250 _micro_seconds
17:00:29 <monochrom> use "high-frequency trading" to indicate "the requirements are insane" :)
17:01:17 <edwardk> not that i'd be in a hurry to use anything garbage collected in a high frequency trading scenario
17:01:18 <tabemann> high-frequency trading is insane
17:01:53 <ReinH> tabemann: as a middle-of-the-road example, anti-lock breaking systems are hard real time systems (not breaking by the deadline is a total system failure)
17:02:03 <ReinH> but deadlines are significantly longer than microseconds :)
17:02:11 <tabemann> ReinH: the difference is that over long time scales one can amortize out things like GC pauses, at small time scales one can't
17:02:16 <ReinH> (braking, argh)
17:02:35 <ReinH> tabemann: absolutely, I'm just enjoying a moment of pedantry, feel free to ignore me
17:04:34 <tabemann> I've heard people propose that we might as well use refcounting if we want to support realtime... but then I've heard other people point out that even that can have poor performance in certain circumstances (due to dereferencing chains and cache misses)
17:05:37 <tonyday567> Couldn't match expected type `bytestring-0.10.0.2:Data.ByteString.Internal.ByteString' with actual type `ByteString' - anyone help me with this?
17:05:51 <hpaste> tonyday567 pasted ‚ÄúByteString Compile Error‚Äù at http://lpaste.net/91618
17:06:01 <tabemann> (of course refcounting wouldn't work well in plenty of Haskell code, due to the commonality of self-referencing data structures therein)
17:06:08 <hpc> tabemann: you should read up on ghc's generational gc
17:06:18 <hpc> it's rather brilliant
17:06:26 <geekosaur> tonyday567, that almost always means something wants a strict ByteString but you gave it a lazy one, or vice versa
17:06:35 <geekosaur> oh, hm
17:06:36 <geekosaur> actually
17:06:44 <tonyday567> Network.Socket.ByteString is importing Data.ByteString
17:06:44 <geekosaur> bytestring-0.10.0.2:
17:06:46 <ReinH> geekosaur: you sit on a throne of lies
17:06:56 <geekosaur> suggests that you have multiple versions of ByteString installed
17:07:03 <tabemann> I'm aware of the general principles of generational GC, but haven't read too specifically about GHC's generational GC itself
17:07:03 <geekosaur> and they're conflicting
17:07:35 <monochrom> whenever you see version numbers in mere type errors, it's really bad
17:07:40 <hpc> tabemann: one of the things it does is schedule a small gc on every block allocation (i think that's the term)
17:07:41 <tonyday567> Nope.  Only have one bytestring package on the system
17:07:56 <hpc> tabemann: so it allocates a couple of megs, then quickly fills it with new data
17:08:07 <monochrom> how do you know?
17:08:10 <hpc> before it allocates the next block, it does a gc over just the new stuff
17:08:30 <geekosaur> if so then it's strict vs. lazy. but really, the fact that it needed to give you a version strongly suggests that means there's also a different version
17:08:43 <hpc> tabemann: so making lots of young garbage data is effectively free
17:08:51 <tabemann> yeah
17:09:37 <tonyday567> yes, so if Network.Socket.ByteString is importing Data.ByteString then that means it only supports lazy?
17:11:15 <geekosaur> Data.ByteString is strict, Data.ByteString.Lazy is lazy
17:11:36 <tabemann> from what I've gathered, the GHC GC is really good at GCing huge amounts of data very fast (I've read on the order of 1 GB per sec), but it's still stop-the-world
17:12:03 <hpc> tabemann: not anymore, i don't think
17:12:25 <hpc> it's more like "stop the country"
17:12:38 <hpc> threads get stopped for gc but the rest of the program spins on
17:12:45 <geekosaur> I think there is still a stop-the-world phase but it's very short?
17:13:02 <jmcarthur> huh?
17:13:03 <tonyday567> The examples on haddock have the same compile message
17:13:05 <jmcarthur> no
17:13:06 <tonyday567> http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket-ByteString.html#v:recv
17:13:10 <jmcarthur> it stops the whole world still
17:13:30 <jmcarthur> they had worked on a concurrent gc, but the results didn't seem worth the complexity, if i recall correctly
17:13:34 <geekosaur> tonyday567, well then I suggest you verify again that you really have only one ByteString library installed
17:13:41 <geekosaur> using ghc-pkg list
17:13:51 <tonyday567> excellent advice.  ghc-pkg list right?
17:13:54 <hpc> jmcarthur: that's unfortunate
17:14:17 <geekosaur> one in each half is still more than one. multiple copies of the same version is, unfortunately, still more than one
17:14:54 <tabemann> what I'd like to see is incremental GC, but I'm not sure what the technical aspects of implementing that would be in GHC
17:14:59 <hpaste> tonyday567 pasted ‚ÄúNetwork.Socket.ByteString‚Äù at http://lpaste.net/91619
17:15:05 <blackdog> is there a way to get GHC to use the dynamic C libs on the system?
17:15:12 <blackdog> i'm trying to intercept getsockname and not having a lot of luck.
17:15:39 <jmcarthur> my experiences with an incremental GC in ocaml have made me not like it much, to be honest.
17:15:41 <tabemann> I'm pretty sure that you can link dynamic C libraries with GHC
17:15:52 <tabemann> jmcarthur: what about it?
17:16:46 <blackdog> tabemann: you can, but I'm trying to work out how I'd get the low-level network package to build things that way
17:17:08 <jmcarthur> supposedly the latencies are lower than a stop-the-world gc, but my experiences haven't reflected that. worse, in fact. (although this is only one incremental GC that i've used extensively and so might not be representative). in the end, the only observable difference i can see is that it's harder to determine whether a slowdown is attributable to the GC...
17:17:52 <jmcarthur> that is, higher allocations end up resulting in more overall slowness that is difficult to explain
17:18:21 <blackdog> jmcarthur: i thought that was the point - trading efficiency for low latency
17:18:52 <jmcarthur> blackdog: sure, but my point is just that so far i have not seen the low latency benefit, and there is a cost other than efficiency
17:18:53 <geekosaur> blackdog, ghc usually uses the dynamic C libs in my experience?
17:19:04 <jmcarthur> blackdog: which is that it's hard to decide whether you are slow due to GC or due to something else
17:20:21 <tabemann> the big thing is that bandwidth is typically easier to come by than lower latency, so it might as well be worth it to trade some latency for more *predictable* latency, especially if what one is doing is not CPU-bound
17:20:47 <blackdog> geekosaur: https://gist.github.com/mwotton/6170141
17:20:47 <tabemann> and that it's making it harder to figure out the source of the slowness means it's doing exactly what it's intended to do
17:21:41 <tabemann> whopos
17:21:42 <jmcarthur> tabemann: not exactly, since the latency attributable to each slice is still pretty big and unpredictable (still has to adjust in proportion to the rate of allocation)
17:21:42 <geekosaur> blackdog, the host command uses a separate resolver which is part of the bind client suite
17:21:53 <tabemann> s/trand some latency/trade some bandwidth
17:21:55 <tabemann> s/trand/trade
17:21:57 <jmcarthur> tabemann: big, at least, when the heap is big
17:22:02 <geekosaur> if you want to use that then you will have to build ghc *against the bind9 client suite* and not against glibc's resolver
17:22:11 <blackdog> geekosaur: hm. so ghc just uses the one in libc?
17:22:16 <geekosaur> yes
17:22:40 <geekosaur> and that uses the name service switch (nss) to implement getaddrinfo and friends
17:23:09 <geekosaur> one of the reasons host uses a separate library is so that it can make sure it's *only* using DNS and not any other nss-configured sources
17:23:13 <jmcarthur> tabemann: the only actual benefit i've seen is that it smooths out the hiccups, but it's not as great as it sounds if it still makes latency higher and makes the cost model more complicated and lowers your throughput
17:23:17 <geekosaur> because it's a DNS diagnostic tool
17:23:39 <blackdog> geekosaur: ok. so, if i run that little program under strace, i can see the getsockname call
17:24:18 <tabemann> and if what you're doing relies on having not necessarily *low* latency, but *predictable* latency, that would be a plus (compared with lower latency most of the time but big, unpredictable latencies every so often)
17:24:32 <jmcarthur> tabemann: of course, i good incremental collector probably would make your latency lower instead of higher, as it is designed to... but even then i don't think it is generally worth it for a default
17:24:42 <blackdog> however, i can't seem to replace it using an LD_PRELOAD trick
17:24:46 <blackdog> (annotated the gist)
17:24:51 <jmcarthur> tabemann: right, but i don't think an incremental collector can guarantee predictable latency at all
17:25:24 <jmcarthur> tabemann: if it has to slow my program to a crawl just to keep each slice small enough not to notice, i still fail at real time
17:25:51 <cmears> Can anyone explain why summing a list of integers might be faster than taking the length of the list? (see https://gist.github.com/cmears/6170163)
17:26:24 <jmcarthur> tabemann: especially consider that the slowness is still unpredictable!
17:26:45 <tabemann> so then there should be some way to configure the exact tradeoff being made, i.e. bandwidth versus latency, as which you really care about depends a lot on the application
17:26:55 <tabemann> note how, say, Java has "client" and "server" modes for that reason
17:27:18 <jmcarthur> cmears: i bet it's still generating the list when you take the length and then it's all ready to compute the sum fast after that
17:27:30 <jmcarthur> cmears: try computing the length twice in a row. i bet it will be faster the second time
17:27:31 <geekosaur> cmears, because of cache effects in the OS's memory management? you need more than one run of each and you need to either make multiple runs or figure out how to flush the OS caches between runs, to contorl those cache effects
17:27:34 <cmears> jmcarthur, I only do one or the other
17:27:38 <jmcarthur> oh
17:27:43 <jmcarthur> ah, i missed the case
17:27:59 <jmcarthur> in this case i don't know. would have to see the core
17:28:16 <geekosaur> if you really want to time this stuff, use something like criterion
17:28:34 <geekosaur> you have way too many confounding variables in running an executable multiple times
17:29:02 <cmears> It seems pretty consistent across multiple runs
17:29:14 <tabemann> still, you should use criterion
17:29:30 <blackdog> geekosaur: any thoughts? it works fine with the linked C file, but i can't seem to intercept the call with the ghc-built file
17:29:33 <geekosaur> blackdog, you might want to use LD_DEBUG to see what ld.so (linux-vdso) is up to
17:29:36 <jmcarthur> i don't think this recommendation to use criterion is so important...
17:29:55 <jmcarthur> criterion is great and all, but if the benchmark is big enough it's not going to be a big deal
17:30:00 <dwcook> Is it habitual to define the Alternative methods in terms of the MonadPlus ones?
17:30:12 <dwcook> (i.e., if both are implemented for a given type constructor)
17:30:20 <jmcarthur> dwcook: i typically go the other direction. it doesn't really matter
17:30:41 <dwcook> Ah, yeah, meant to include that in my question as well
17:30:42 <cmears> Thanks for the advice, everyone; I think I will have to go core-digging
17:30:44 <blackdog> geekosaur: thanks, i'll have a dig
17:31:26 <dwcook> Let me rephrase: Is it unusual to have Alternative and MonadPlus instances that don't behave the same way?
17:31:35 <geekosaur> btw if you want to compare what dynamic libs are used for glibc lookups, you want to look at getent, not host
17:32:24 <cmears> Ah, the length version is doing squillions of GC
17:33:12 <tabemann> but why would the summing not do squillions of GC
17:33:25 <cmears> Yes, the difference I cannot explain
17:33:26 <tabemann> there must be something different you are doing other than just what operation you're doing on the list
17:33:30 <tabemann> okay
17:33:40 <tabemann> are you still holding the start of the list when you do the summing
17:33:41 <blackdog> geekosaur: hrm. very, very odd. you can see that getsockname is being invoked by the haskell app, and LD_DEBUG shows it in the C file, but there's nothing at all in LD_DEBUG when i run the haskell app.
17:33:48 <tabemann> but then letting it go when you do the length?
17:34:04 <jmcarthur> the length and sum happen in different runs of the program
17:34:07 <jmcarthur> i made that mistake too
17:34:22 <cmears> tabemann, it's really just switching "length" for "sum" (https://gist.github.com/cmears/6170163)
17:34:30 <blackdog> geekosaur: the c should be doing the same thing, given that it's calling getsockname directly, right?
17:35:15 <geekosaur> blackdog, that seems .. odd. I suppose it's possible that the haskell network library linked statically to libc for some reason, although in general it's a bad idea to statically link stuff using nss
17:35:50 <geekosaur> ...wait, it can't link statically, if it's a static library itself
17:35:54 <geekosaur> it has no control over that
17:36:32 <geekosaur> if libHSnetwork is dynamic then it's conceivable that that is in turn static linked against glibc, but that's fragile on ARM and 64bit Intel and highly risky
17:37:17 <ppseafield> The link to the slides for the Lens, Folds, and Traversals video (http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf) gives a 404. Anyone know where else I can find it?
17:37:35 <blackdog> geekosaur: trying to work out how to interpret ldd output
17:37:49 <adu> one would think we would have solved the dynamic/static debate by now
17:38:02 <geekosaur> oh crap, right, your ldd shows it *is* dynamic
17:38:42 <geekosaur> you might ldd just libHSnetwork-2.4.1.2-ghc7.6.2.so and verify that it is dynamically linked against libc.so.6
17:38:46 <blackdog> geekosaur: when it shows linux-vdso.so.1 as a hex value without a file?
17:38:54 <blackdog> (uh, what does that mean)
17:38:55 <geekosaur> and not statically (which would cause this and also would be risky)
17:38:59 <blackdog> ok
17:39:00 <geekosaur> it's "magic:
17:39:18 <geekosaur> basically linux-vdso.so is the "interpreter" for an executable
17:39:34 <geekosaur> it's not linked in in the same way that shared libs are
17:39:52 <adu> I personally believe that everything should be static, and shared/dynamic things should be turned into kernelspace stuff
17:40:08 <geekosaur> instead the kernel loads and invokes it directly, and it's up to linux-vdso.so to link in everything else
17:40:11 <blackdog> geekosaur: annotated the gist, looks like it's dynamic.
17:41:03 <blackdog> so i am confused.
17:41:16 <geekosaur> so am I, at this point
17:41:31 <tabemann> hmm... I can reproduce the performance characteristics of cmears' code, even though I'm just using time to measure program execution time...
17:44:06 <tabemann> hmm... from looking at the code it *looks* as if *length* should be faster, not *sum*
17:44:15 <tabemann> especially as we're summing Integers here
17:44:25 <blackdog> geekosaur: ldd of the c shows it's definitely only linking to libc, so we definitely know that getsockname is being sourced from libc.
17:45:04 <johnw> hpc: I find your assertion that you can never beat C rather suspect
17:45:16 <blackdog> geekosaur: ah well. i'l have a walk and think about it, ping me if anything occurs to you?
17:45:19 <tabemann> question - what does {-# SPECIALIZE #-}
17:45:20 <tabemann> do
17:45:56 <tabemann> because I notice that before sum there's a a couple {-# SPECIALIZE #-} clauses, including one for [Integer] -> Integer
17:46:04 <c_wraith> tabemann: it's an older version of what rewrite rules and the INLINEABLE pragma get you now.
17:46:06 <geekosaur> tabemann, tells ghc to create code for a polymorphic function, instantiated at some particular type
17:47:48 <ReinH> tabemann: length doesn't have to evaluate the list elements; sum obviously does.
17:48:10 <jmcarthur> hpc: your explanation of what i assume was about minor collections is kind of weird
17:48:29 <ReinH> this seems like it should make length faster but I don't know how the differences in the heap will affect GC, etc
17:48:31 <tabemann> ReinH: but the question is why is sum *faster* then
17:48:44 <ReinH> tabemann: length is leaving a lot more thunks on the heap for instance
17:48:46 <jmcarthur> hpc: it doesn't allocate a new block for the minor heap like that
17:49:09 <ReinH> tabemann: didn't you say that length spent most of its extra time in gc?
17:49:17 <tabemann> cmears said that
17:49:41 <tabemann> but why would evaluating a thunk and then GCing the resulting value be faster than just GCing the thunk without evaluating it
17:49:46 <ReinH> try a strict length
17:49:49 <ReinH> see if that changes it
17:51:12 <Zenol> 'night.
17:51:21 <jmcarthur> maybe it has something to do with the PRNG (i haven't checked the core for this and am just stabbing in the dark)
17:51:41 <jmcarthur> the sum might force more PRNG state or something
17:51:48 <tabemann> Reinh: nope
17:52:04 <ReinH> tabemann: I don't know, I'm just pointing out a material difference in the execution context and speculatingt about what that might do to the runtime
17:52:05 <jmcarthur> and that could be especially helpful if the list generation is getting inlined into the length/sum stuff
17:52:14 <jmcarthur> again, totally guessing
17:53:16 <Kaidelong> if you had SPECIALIZE as the default behavior would you end up with the behavior of C++ templates?
17:53:26 <Kaidelong> particular wrt binary size
17:54:37 <ReinH> tabemann: what if we use StrictList a = !a :$ !(StrictList a) | Empty instead of [] ?
17:54:51 <ReinH> or some other strict data structure
17:54:55 <ClaudiusMaximus> cmears: http://mathr.co.uk/tmp/Mers/sum.png http://mathr.co.uk/tmp/Mers/length.png  (ghc -O2 -rtsopts Mers.hs ; ./Mers +RTS -s -h )
17:55:37 <cmears> ClaudiusMaximus, so it is something to do with strictness?
17:55:42 <ReinH> ClaudiusMaximus: and sum?
17:55:52 <tabemann> I implemented a strict list library (even though I didn't put it in Hackage), I *could* use that....
17:55:55 <ClaudiusMaximus> cmears: looks like it
17:56:29 <ReinH> ClaudiusMaximus: that just shows that most of the space is taken up by the list, though...
17:56:36 <ReinH> did you already post sum?
17:56:46 <ClaudiusMaximus> there's two links
17:56:52 <ReinH> argh
17:56:55 <ReinH> reading, how does it work
17:56:58 <jmcarthur> also that's not the list
17:57:00 <jmcarthur> those are thunks
17:57:09 <ClaudiusMaximus> also note the vertical axis
17:57:25 <ReinH> well that makes sense then
17:57:34 <ReinH> jmcarthur: I was looking at sum by mistake
17:58:03 * jmcarthur sighs and grabs the code to look at himself
17:58:06 <ReinH> oh duh
17:58:11 <ReinH> sum is lazy
17:58:13 * ReinH facepalms
17:58:14 <ReinH> obv
17:58:29 <ReinH> it creates thunks at need and then immediately evaluates them
17:58:36 <jmcarthur> shouldn't matter. strictness analyzer should be fine. also, it's working fine
17:58:41 <jmcarthur> it's length that's being troublesome
17:58:49 <ReinH> whereas length is just keeping around the entire unevaluated list
17:59:00 <jmcarthur> i don't think that explanation makes any sense
17:59:05 <ReinH> jmcarthur: why not?
17:59:22 <tabemann> I implemented a strict length that actually evaluated each head in the list, and it didn't make a difference
17:59:36 <ReinH> tabemann: hmm
17:59:42 <ReinH> we are looking at a space plot, not a time plot...
17:59:45 <jmcarthur> ReinH: because the list hanging around wouldn't be attributable to thunks
17:59:56 <jmcarthur> ReinH: this is more in keeping with length being inappropriately lazy (and sum not)
18:00:16 <tabemann> but then my strict length should be have like sum
18:00:26 <jmcarthur> installing appropriate deps
18:00:32 <cmears> Hmm, I just tried a strict length that evaluates each element as it goes, and it was very fast
18:00:40 <jmcarthur> that
18:00:50 <jmcarthur> now it's just a matter of figuring out why the other length is failing
18:00:58 <jmcarthur> cmears: is this your own implementation of length or the standard one?
18:01:11 <ReinH> cmears: it should be, yes
18:01:23 <jmcarthur> cmears: the code you pasted is the whole program?
18:01:28 <hpaste> tabemann pasted ‚ÄúThis length *should* be strict...‚Äù at http://lpaste.net/91621
18:01:31 <cmears> my own, I just added it
18:01:40 <cmears> (to https://gist.github.com/cmears/6170163)
18:02:35 <jmcarthur> ah, indeed the standard length function is displaying this behavior for me
18:02:40 <ReinH> jmcarthur: yes, length is more lazy in that way, but I meant something slightly different
18:03:20 <cmears> So I guess it's something about forcing the state in the RNG that does it
18:03:26 <ReinH> and after reconsidering, what I actually meant is that sum is more strict
18:04:03 <tabemann> why isn't my strict length strict enough then?
18:04:24 <ClaudiusMaximus> you can write a function to strictify the list elements
18:04:24 <jmcarthur> tabemann: maybe it needs to be strict in the list elements?
18:04:26 <ClaudiusMaximus> strictly [] = []
18:04:26 <ClaudiusMaximus> strictly (x:xs) = x `seq` (x : strictly xs)
18:04:32 <tabemann> got it
18:04:44 <tabemann> when I switched to using `seq` it worked
18:04:46 <ReinH> tabemann: uh, isn't it spine strict?
18:04:49 <jmcarthur> i am strongly leaning toward this being related to the PRNG
18:05:04 <ReinH> jmcarthur: well let's replace it with take 10**7 [1..] or whatever
18:05:04 <cmears> tabemann, I had to change mine to be element-strict to make it fast
18:05:05 <jmcarthur> and i think it doesn't make sense for the PRNG to have laziness in it at all
18:05:13 <johnw> tabemann: a pattern match of ![] is no different from []
18:05:28 <hpaste> tabemann pasted ‚ÄúFast strict length‚Äù at http://lpaste.net/91622
18:05:34 <tabemann> johnw: i know
18:05:34 <jmcarthur> ReinH: yeah, i'll give that a shot
18:05:35 <johnw> in both cases it will evaluate enough to determine whether the argument is []
18:05:57 <tabemann> cmears: I found that I could just use ! on the element, I had to actually `seq` it
18:06:02 <tabemann> s/could/couldn't
18:06:05 <johnw> also, you are using !x in an argument, but then not using x
18:06:11 <jmcarthur> indeed, without the PRNG, length is faster than sum
18:06:11 <johnw> which is also the same as just saying x
18:06:21 <tabemann> johnw: that I'll have to remember
18:06:44 <johnw> i think what you wanted then was x `seq` ...
18:06:45 <jmcarthur> johnw: really?
18:06:53 <edwardk> ppseafield: i can probably find and upload that to the github repo
18:06:59 <jmcarthur> johnw: i thought !x just desugared to seq anyway
18:07:03 <tabemann> stuff like this sometimes make me wish that Haskell could just be strict whenever I wanted it to be (and not when I didn't want it to be)...
18:07:05 <johnw> jmcarthur: I'm only _pretty_ sure
18:07:10 <cmears> Well, I've definitely learnt a new thing today; thanks to everyone who helped!
18:07:16 <jmcarthur> i have a feeling you are wrong
18:07:18 <tabemann> jmcarthur: that's what I thought to
18:07:24 <johnw> but if the compiler sees that you never reference x, why wouldn't it just optimize it away?
18:07:24 <tabemann> s/to/too
18:07:32 <jmcarthur> because you said it must be strict
18:07:35 <johnw> since there are no side-effects, evaluation of x wouldn't matter
18:07:39 <jmcarthur> it does matter
18:07:42 <jmcarthur> it could fail to terminate
18:07:43 <ppseafield> edwardk
18:07:52 <johnw> well, yes
18:07:54 <johnw> let me test this theory
18:07:56 <tabemann> switching !x to x `seq` ... actually made a difference to me
18:07:57 <ppseafield> edwardk: I would appreciate it. :)
18:08:04 <jmcarthur> tabemann: code?
18:08:19 <tabemann> I pasted both my code with ! and my code with `seq1
18:08:28 <jmcarthur> okay looking
18:08:28 <tabemann> s/`seq1/`seq`
18:09:09 <johnw> jmcarthur: hmm.. you seem to right
18:09:31 <jmcarthur> tabemann: surprising
18:10:13 <tabemann> to me it looks like it really is not evaluating it if you use !x and not use the x, and this on GHC 7.4.2 (because Debian is stupid and is perpetually behind the times on things)
18:10:15 <johnw> > let foo !x = 10 in foo undefined
18:10:16 <lambdabot>   Not in scope: `foo'
18:10:16 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversa...
18:10:35 <johnw> tabemann: i just tested with 7.6.3
18:10:40 <johnw> let me try 7.4.2
18:10:59 <johnw> my test: https://gist.github.com/6170374
18:11:02 * hackagebot ar-timestamp-wiper 0.1.0 - Wipes time stamps from .a files (like ar -D)  http://hackage.haskell.org/package/ar-timestamp-wiper-0.1.0 (NiklasHambuechen)
18:11:04 * hackagebot bits 0.3.2 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.3.2 (EdwardKmett)
18:11:11 <jmcarthur> tabemann: they compile to exactly the same core here
18:11:12 <johnw> foo throws an undefined exception for both 7.4.2 and 7.6.3
18:11:34 <jmcarthur> tabemann: i think you simply screwed up your benchmarking somehow
18:11:37 <edwardk> ppseafield: try now
18:11:44 <johnw> so, !x must really mean "evaluate argument to WHNF before evaluating the function body"
18:12:11 <jmcarthur> johnw: it shouldn't be requiring any particular evaluation order of the argument relative to the body, actually
18:12:22 <tabemann> johnw: okay, in GHCi it does throw an exception
18:12:32 <jmcarthur> johnw: it just means that when the body is forced then the argument must be forced. before or after is not specified
18:12:36 <ppseafield> edwardk: Thanks!
18:12:45 <johnw> jmcarthur: oh?  unlike seq?
18:12:51 <jmcarthur> johnw: seq is the same
18:12:53 <tabemann> jmcarthur: I was just using time ./Foo {sum|length}, and it made a difference of about 0.9 s when I made that change
18:12:57 <johnw> ah, then pseq is the ordering one
18:12:58 <jmcarthur> johnw: pseq has a specified evaluation order
18:12:59 <johnw> thanks for clarifying
18:13:00 <jmcarthur> yeah
18:13:05 <edwardk> np. if anyone else finds dead links on comonad.com, please feel free to let me know. its just a scraped mirror sitting on github right now
18:13:25 <jmcarthur> tabemann: i still stand by my claim that you probably screwed something up and will have trouble reproducing that result
18:14:10 <edwardk> tabemann: re being strict as you want and lazy as you want, sounds like you want Mu ;)
18:14:31 <hpaste> tabemann pasted ‚ÄúTIme difference‚Äù at http://lpaste.net/91623
18:15:12 <edwardk> well, that admittedly sounds like it has worst case semantics that are neither strict nor lazy but rather "who cares, this optimization works well and is strict and that one works well, but needs non-strictness, so lets do both!"
18:15:18 <tabemann> the first was with !x, the second was with x `seq` ...
18:17:02 <tabemann> I don't think I like the "just optimize for whatever is better in a given case", as a lot of the behavior I like about either has nothing to do with sheer performance
18:17:34 <jmcarthur> woah, i was wrong
18:17:37 <jmcarthur> the core is different
18:18:13 * tabemann remembers how in Okasaki's book he basically added laziness to SML, except that unlike laziness in Haskell all the laziness was basically explicitly declared
18:19:15 <jmcarthur> tabemann: i don't like the way laziness works on ocaml, for one. it's very awkward and second class
18:19:27 <jmcarthur> tabemann: nobody really uses it
18:19:44 <tabemann> I never used laziness in OCaml myself
18:19:44 <jmcarthur> *in ocaml
18:19:59 <tabemann> the thing is how to make *both* laziness and strictness first-class
18:21:19 <jmcarthur> i am very confused about why ghc is generating such blatantly different core for these functions
18:21:21 <Cale> Most of laziness' benefit can only occur in a culture of nonstrict programs
18:21:56 <jmcarthur> using the bang pattern, ghc generates core that does *not* force the argument at all...
18:22:06 <jmcarthur> with seq it forces it
18:22:18 <Cale> jmcarthur: interesting
18:22:21 <tabemann> Cale: tis true; and trying to make the two work together, as I did with my strict list library, is *painful*
18:22:50 <tabemann> is this a GHC bug, or just an undocumented feature?
18:23:00 * jmcarthur tries using it with some _|_ inputs
18:24:32 <tabemann> the question is that if !x without using x doesn't evaluate x, why then does, at least in GHCi, let foo !x = 0, and then foo undefined = _|_?
18:25:43 <jmcarthur> wow
18:25:48 <jmcarthur> it actually doesn't force the element
18:25:57 <jmcarthur> i just passed it [undefined] and got 1 back
18:26:06 <jmcarthur> even with a bang pattern on the element in the pattern
18:26:32 <jmcarthur> the version using seq is _|_ as i would expect
18:26:53 <cdk> jmcarthur: I believe using a bang on a list just forces it to be evaluated to (_:_)
18:27:08 <jmcarthur> cdk: this is of the form   (!x : xs)
18:27:20 <Cale> jmcarthur: are you sure about the precedence?
18:27:27 <Cale> try ((!x) : xs)
18:27:30 <Cale> just to be safe
18:27:34 <jmcarthur> ah, good call. let's see
18:27:43 <jmcarthur> that's it
18:27:48 <tabemann> yep
18:28:02 <jmcarthur> not the most intuitive precedence, IMO...
18:28:06 <Cale> heh, that's a bit silly, yeah
18:28:11 <tabemann> potential silent bug in code there
18:28:18 <Cale> It should really bind tighter than anything else
18:28:32 <jmcarthur> now i have to go through all my strict code and look for this :(
18:28:36 <johnw> yes, I was fooled by that precedence too
18:28:46 <Cale> Because you usually want to apply it only to a variable, as applying it to a constructor is obviously pointless.
18:28:47 * tabemann was completely unaware of this until now
18:28:56 <jmcarthur> exactly
18:29:09 <tabemann> and shit, I can just imagine all the code written with (!x : xs) in it where people thought it would do what we thought it would do
18:29:30 <Cale> well... most of the time
18:29:39 <jmcarthur> haha, the documentation only show nested bang patterns with tuples
18:29:43 <jmcarthur> *shows
18:29:44 <Cale> You can turn let into case with bang patterns because of the wonky translation.
18:30:14 <jmcarthur> i actually use the let ugliness in my code sometimes
18:30:28 <tabemann> this should be a language design bug, actually, as it really shouldn't do what it is doing
18:30:59 <Cale> I kind of wish they stuck with the original straightforward translation, even if it meant that bang patterns at the top level in pattern bindings were kind of pointless.
18:31:18 <Cale> (because pattern bindings all implicitly get a ~)
18:33:17 <tabemann> hmm... if a ticket was made for changing the precedence of !, would it end up in something other than the _|_ release?
18:33:39 <jmcarthur> i think such a proposal would be taken pretty seriously
18:33:40 <tabemann> changing the precedence of ! shouldn't *break* anything
18:34:03 <jmcarthur> it could break things in theory, but in practice i think it wouldn't
18:34:17 <c_wraith> does ~ bind the same way?
18:34:19 <jmcarthur> it would just change the semantics to be what people probably expected in the first place
18:34:24 <c_wraith> If so, it probably should be considered, too
18:34:27 <tabemann> yeah
18:34:46 <jmcarthur> hmm... how to test...
18:34:56 <jmcarthur> (~ True : _) i guess
18:35:53 <applicative> foo (~(!(~x)):xs)
18:35:55 <jmcarthur> umm...
18:36:07 <jmcarthur> yeah i actually can't figure out a good test
18:36:12 <jmcarthur> applicative's suggestion scares me
18:36:28 <c_wraith> > case (~True:_) of [] -> "stuff"
18:36:29 <lambdabot>   Pattern syntax in expression context: ~TruePattern syntax in expression con...
18:36:31 * tabemann blinked a few times at seeing applicative's example
18:36:40 <c_wraith> > case (~ True:_) of [] -> "stuff"
18:36:41 <lambdabot>   Pattern syntax in expression context: ~TruePattern syntax in expression con...
18:36:46 <jmcarthur> okay, ~ doesn't work this way
18:37:06 <jmcarthur> let f (~ True : _) = "foo"   is different from   let f ~(True : _) = "foo"
18:37:17 <jmcarthur> > let f (~ True : _) = "foo" in f undefined
18:37:17 <lambdabot>   "*Exception: Prelude.undefined
18:37:20 <jmcarthur> > let f ~ (True : _) = "foo" in f undefined
18:37:21 <lambdabot>   "foo"
18:37:37 * applicative attempts to imprint this
18:38:05 <tabemann> the only place I can say I've ever actually seen anyone use ~ is old code using stream IO
18:38:14 <jmcarthur> i have used it in places
18:38:51 <jmcarthur> i tend to use it on tuples and such the most
18:38:51 <johnw> tabemann: you may have written the thing that ~ expands to more often that you'd think :)
18:39:29 <johnw> foo ~(a,_) = a  is like writing foo = fst
18:40:03 <tabemann> oooo the whole partial application acting differently from eta expansion thing
18:40:16 <copumpkin> johnw: not sure that's a particularly good example
18:40:18 <jmcarthur> foo ~(a, _) = a   is the same as   foo (a, _) = a
18:40:24 <copumpkin> wrap it in something
18:40:29 <johnw> jmcarthur: it is?
18:40:45 <copumpkin> > let foo ~(a, _) = Just a in foo undefined
18:40:45 <jmcarthur> johnw: consider forcing the result in both cases
18:40:46 <johnw> I thought the whole point of ~ there is that it's deferring destruction of the argument as a tuple
18:40:46 <lambdabot>   Just *Exception: Prelude.undefined
18:40:51 <copumpkin> > let foo (a, _) = Just a in foo undefined
18:40:52 <lambdabot>   *Exception: Prelude.undefined
18:40:56 <jmcarthur> johnw: there are cases where they are different, but this is not one
18:41:00 <johnw> ah, ok
18:41:04 <johnw> i seem to always get this point wrong
18:41:20 <copumpkin> the thing is, if you're even calling foo, you are forcing its result
18:41:22 <jmcarthur> > let foo (a, b) = (b, a) in foo undefined
18:41:22 <copumpkin> which means you need it
18:41:23 <lambdabot>   *Exception: Prelude.undefined
18:41:25 <jmcarthur> > let foo ~(a, b) = (b, a) in foo undefined
18:41:26 <lambdabot>   (*Exception: Prelude.undefined
18:41:44 <copumpkin> johnw: so when I added a level of indirection you observed the difference
18:41:48 <johnw> > let foo = fst in foo undefined
18:41:49 <lambdabot>   *Exception: Prelude.undefined
18:42:00 <copumpkin> the Just can produce something without looking at the a
18:42:07 <johnw> copumpkin: I saw them both resulting in _|_
18:42:11 <copumpkin> look more carefully
18:42:16 <johnw> ahh
18:42:18 <johnw> i see now
18:42:26 <copumpkin> > let foo (a, _) = Just a in isJust (foo undefined)
18:42:26 <lambdabot>   *Exception: Prelude.undefined
18:42:29 <copumpkin> > let foo ~(a, _) = Just a in isJust (foo undefined)
18:42:30 <lambdabot>   True
18:42:32 <johnw> g/otcha
18:42:57 <johnw> when I call foo undefined with ~(a,_) = a, then I'm evaluating the result of foo which is the same as not using ~
18:43:19 <johnw> but with a wrapper, like Just, WHNF evaluation of "foo undefined" does not evaluate what the Just is holding
18:43:26 <jmcarthur> right
18:43:31 <johnw> that's clear, thanks!
18:43:59 <copumpkin> things start getting unintuitive (at least according to my "obvious" intuition) when you get nested patterns
18:44:06 <tabemann> so let foo (a, _) = Just a forces a?
18:44:18 <jmcarthur> no
18:44:23 <tabemann> oh wait
18:44:25 <tabemann> I got it
18:44:33 <copumpkin> tabemann: it's defined such that it needs to force the (,) before it can produce anything
18:44:43 <copumpkin> the ~ is telling it to calm down
18:44:46 <jmcarthur> > let foo (a, _) = Just a in isJust $ foo (undefined, _)
18:44:47 <lambdabot>   Pattern syntax in expression context: _
18:44:49 <jmcarthur> > let foo (a, _) = Just a in isJust $ foo (undefined, undefined)
18:44:50 <lambdabot>   True
18:44:57 <jmcarthur> > let foo (!a, _) = Just a in isJust $ foo (undefined, undefined)
18:44:58 <lambdabot>   <hint>:1:10:
18:44:58 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
18:44:58 <lambdabot>      ! a
18:45:02 <jmcarthur> aw
18:45:08 <applicative> thats crazy
18:45:19 <jmcarthur> @set {-# LANGUAGE BangPatterns #-}
18:45:25 <jmcarthur> hmm
18:45:27 <jmcarthur> > let foo (!a, _) = Just a in isJust $ foo (undefined, undefined)
18:45:28 <lambdabot>   <hint>:1:10:
18:45:28 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
18:45:28 <lambdabot>      ! a
18:45:32 <copumpkin> @set -XBangPatterns
18:45:33 <copumpkin> maybe?
18:45:39 <tabemann> so let foo ~(a, _) = Just a is making a Just foo where foo, when evaluated, will force (,) to get a
18:45:39 <jmcarthur> > let foo (!a, _) = Just a in isJust $ foo (undefined, undefined)
18:45:39 <lambdabot>   <hint>:1:10:
18:45:39 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
18:45:39 <lambdabot>      ! a
18:45:40 <jmcarthur> nope
18:45:46 <applicative> :(
18:45:57 <jmcarthur> tabemann: right
18:46:10 * tabemann took a moment to wrap his strictly-evaluating brain around that
18:46:37 <jmcarthur> let foo ~(a, _) = Just a    is the same as    let foo a = Just (fst a)
18:47:01 <johnw> which was the example johnw was trying to think of
18:47:09 <tabemann> now I see
18:47:50 <tabemann> the question is, aside from stream IO and its craziness, what specific use cases would one really not want to force a tuple, except when one wants to make a point of making a difference between (_, _) and _|_?
18:48:16 <jmcarthur> tabemann: for one, it means you might be able to avoid the work necessary to generate the tuple's constructor, which could be arbitrarily huge
18:48:47 * edwardk contemplates how much bloodshed would ensue were he to rename "Contravariant" to "Presheaf"
18:49:08 <tabemann> jmcarthur: okay, that *is* a use case
18:50:04 <jmcarthur> tabemann: it also lets you do overly clever things like this lazier foldl http://lpaste.net/91109
18:50:13 <geekosaur> yeh, pattern matching is the normal way to force stictness, but sometimes you don't want the strictness because it's only used in one code path or something
18:50:21 <jmcarthur> tabemann: (might take a minute to wrap your head around that)
18:50:29 <geekosaur> and you don't want to pay for strictness you don't need
18:50:31 <johnw> Actually, foo ~(a, _) = a is the same as fst, isn't it?  It's just that fst _|_ = _|_
18:50:45 <jmcarthur> johnw: yes. and foo _|_ = _|_, too
18:50:48 <copumpkin> johnw: yes, that's why I said it was a bad example, not that it was wrong
18:50:50 <copumpkin> :P
18:50:56 <copumpkin> it doesn't show the distinction between ~ and non-~
18:51:07 <johnw> Ah, cool I feel the comprehension flowing in
18:51:49 * tabemann is trying to wrap his brain around the lazier foldl at the moment (he's used to liking his foldls strict himself)
18:52:04 <JoeyA> "... what specific use cases would one really not want to force a tuple ..." I think span and break do this.
18:52:05 <JoeyA> @src span
18:52:06 <lambdabot> span _ xs@[]                     =  (xs, xs)
18:52:06 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
18:52:06 <lambdabot>                   | otherwise    =  ([],xs)
18:52:11 <jmcarthur> tabemann: i don't claim that it's very useful
18:52:32 <monochrom> (\~(a,_) -> a) does not exhibit any extra non-strictness because of "-> a"
18:52:38 <JoeyA> The recursive call allows span to be lazy in the first result list.
18:52:56 <JoeyA> > span (==1) $ repeat 1
18:52:57 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:53:29 <monochrom> (\~(a,b) -> (a, b)) would exhibit more non-strictness and is the same as (\x -> (fst x, snd x)) if you want "fst" to appear
18:53:41 <jmcarthur> (worth pointing out that JoeyA's example is taking advantage of the fact that let is kind of implicitly using ~)
18:54:05 <copumpkin> > let foo (a, b) = (a, b) in foo undefined
18:54:06 <lambdabot>   *Exception: Prelude.undefined
18:54:09 <copumpkin> > let foo ~(a, b) = (a, b) in foo undefined
18:54:10 <lambdabot>   (*Exception: Prelude.undefined
18:54:41 <applicative> thats somehow much more awesome than Just *Exception ...
18:54:46 <tabemann> I've written a reasonable amount of code that looked like than span impl., without realizing that lets like that were special at all....
18:55:26 <jmcarthur> tabemann: and yet you probably would have been pretty unhappy with the stricter behavior!
18:55:38 <tabemann> well I actually expected lazy behavior there
18:55:43 <jmcarthur> right
18:55:51 <tabemann> as I was writing to code to convert strict lists into lazy lists, lazily
18:56:15 <jmcarthur> well, then you have basically used ~
18:56:30 <JoeyA> How do I get the current GHC version from the command line, in the format used for the package database?  (e.g. i386-linux-7.6.2)
18:57:41 <tabemann> jmcarthur: now the question is how do you determine when these implicits ~s are added, or is it something where you probably ought to add ~ to your code just to be on the safe side?
18:58:04 <jmcarthur> tabemann: it's semantically meaningful, so you shouldn't do it without knowing what you are doing
18:58:20 <jmcarthur> tabemann: an inappropriately placed ~ can screw up your assumptions
18:58:35 <jmcarthur> > let f ~True = "it was true!" in f False
18:58:36 <lambdabot>   "it was true!"
18:58:48 <JoeyA> :D
18:58:56 <tabemann> I mean in the specific pattern let (x, y) = foo z in ....
18:59:24 <jmcarthur> tabemann: again, it depends. in that case, it depends on if x or y will definitely be forced
18:59:39 <jmcarthur> tabemann: if they will, might as well just force the tuple up front
19:00:11 <tabemann> I mean, of course, if you are doing something like constructing lists with x and y in them, like that span example
19:00:12 <jmcarthur> tabemann: or perhaps this will be in a loop and you want to force the tuple to avoid some allocations along the way even if you might not need that result in the end
19:00:59 <tabemann> what I'm specifically asking is when does GHC add implicit ~, just so, when I really want ~, I won't add it extraneously
19:01:35 <jmcarthur> tabemann: let implicitly uses it (for non-function bindings, that is) unless you explicitly use a bang pattern
19:01:55 <tabemann> that's what I was wondering about
19:02:05 <jmcarthur> tabemann: also, pattern matching on a newtype constructor kind of behaves this way if you squint
19:02:20 <tabemann> I'm aware of the newtype behavior
19:02:28 <jmcarthur> that's basically all i can think of
19:03:09 <jmcarthur> time to go
19:03:21 <tabemann> somehow the newtype thing doesn't sound like something one should rely upon, just from a software design standpoint (as who's to say that, if it's someone else's newtype, that it won't be changed to data in the future and break your code)
19:04:18 <elliott> you should absolutely rely on newtype's runtime representation properties.
19:04:23 <elliott> they are specified and the whole point
19:05:55 <copumpkin> scala went out of its way to add something like newtype that is a lot less awesome
19:06:03 <tabemann> scala is a lot less awesome
19:06:23 <copumpkin> I'm saying it's a desirable pattern, though
19:07:13 <EpicOut> hi
19:08:05 * tabemann recants partially on what he said, as long as one can trust that the particular newtype will stay a newtype
19:08:39 <EpicOut> anyone has got a good tutorial for learn to haskell ?
19:08:46 <tabemann> @where lyah
19:08:46 <lambdabot> http://www.learnyouahaskell.com/
19:08:56 <ahill-89> This is the canonical answer.
19:10:18 <black_joe> EpicOut: Learn you a Haskell, and Real World Haskell once you are a bit more confident in it.
19:10:26 <tabemann> @where rwh
19:10:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:10:41 <tabemann> I agree - read both, but LYAH first
19:11:04 <EpicOut> okay thanx dudes
19:35:33 <enthropy> is it possible to convert this Doc http://hackage.haskell.org/packages/archive/ansi-wl-pprint/0.6.6/doc/html/Text-PrettyPrint-ANSI-Leijen.html#t:Doc into Html?
19:36:15 <enthropy> or perhaps going back earlier, maybe it is possible to get the error messages from a trifecta parser as html?
19:37:04 <enthropy> it seems like this should be possible... after all trifecta depends on blaze-html, and provides some instances for Text.Blaze.ToMarkup
19:49:43 <edwardk> i'm happy to take fixes that restore trifecta's ability to generate html markup. i just haven't needed it since i had to switch to ansi-wl-pprint
19:56:07 <ezrios> to what purposes are continuations commonly employed?
19:57:11 <c_wraith> writing code, usually.
19:57:26 <c_wraith> Sometimes CPS style makes something more efficient.
19:57:38 <c_wraith> Sometimes it makes it possible to express control flows that are hard otherwise
19:57:57 <c_wraith> But if you don't see a place you need to use it yet, don't worry
19:59:01 <ezrios> c_wraith: hm, thanks. I think continuations are way over my head at this point
20:04:42 <tabemann> back when I played around with Scheme, I used continuations to implement cooperative multithreading
20:05:24 <tabemann> you can also implement things like coroutines and exception mechanisms (mind you at least in Scheme that they've added them in more recent times) with them
20:07:19 <c_wraith> One of the coolest things I saw was wrapping a callback-based interface with ContT to provide what looked like a straight-ahead interface.  It used continuations to pull the thread of control back from the callbacks - in some sense.
20:09:55 <tabemann> hmm, I should probably play around with Cont sometime (having played around with Scheme continuations in the past)
20:11:44 <cdk> it always feels morally wrong to use mutable references like MVar or TVar as the environment of ReaderT...
20:13:41 <tabemann> it's better than having to manually thread your MVars or TVars through all your code
20:14:15 <tabemann> especially since top-level IO-created things are verboten (and the performIO hack is bad)
20:14:21 <geekosaur> cdk, there is at least one use case for a ReaderT holding a reference to mutable state: GUI callbacks in wxhaskell / gtk2hs
20:16:11 * tabemann wouldn't be surprised if doing that with ReaderT were actually a relatively common use case
20:17:08 <leroux> Does anyone here use Coq? I'm trying to simplify this lemma further. https://gist.github.com/leroux/6170868#file-basics-v-L883
20:19:17 <tabemann> (Coq is one of those things that I probably should learn but am afraid that I won't be able to wrap my brain around it)
20:20:04 <tabemann> (same with Agda)
20:22:11 <leroux> tabemann: I just started today.
20:22:26 <Cale> tabemann: I recently discovered that I already knew how to program in Coq.
20:22:30 <chexxor> Want to share a feeling quick - OMG, RWH Chapter 3 (Defining Types, Streamlining Functions) is so intimidating! I've never seen so many new concepts on one page before. This is exciting.
20:22:54 <leroux> Cale: How so? Did you do some ML before?
20:23:03 <leroux> And you also know how to write proofs.
20:23:19 <Cale> leroux: Well, I've been programming in Haskell for over a decade and I have a degree in pure mathematics.
20:23:30 <leroux> Ahh, I see.
20:23:45 <leroux> I have no degree in math. Not even college yet. =\
20:23:51 <leroux> I try to study from books.
20:24:00 * tabemann spent the last ten or so years programming in OCaml, but has little mathematics background
20:24:09 * danharaj pretends to program in Haskell
20:24:25 * tabemann hsa no clue as to how to write proofs
20:24:28 <tabemann> s/hsa/has
20:26:34 <bwr> w 3
20:27:38 <Cale> tabemann: tbh, you can mostly get by just thinking of it as Haskell or ML with some rather fancy type system extensions. :)
20:28:13 <tabemann> for some reason in the case of Agda I'm tempted to view it from the point of view of programming rather than theorem proving, and then it feels limiting (no generalized recursion and only natural numbers!)
20:28:26 <tabemann> I don't want to give up integers just so I can have dependent types
20:28:33 <Cale> tabemann: The tactic based proofs are a little bit weird at first, but they're kind of like the most baroque syntax for the lambda calculus ever (with some fancy machinery to automatically construct terms)
20:29:00 <Cale> I'm pretty sure the integers are definable in Agda ;)
20:29:45 <Cale> But yeah, it's not really very practical as a day-to-day programming language for the most part.
20:29:57 <Cale> However, it is fun :)
20:30:33 <tabemann> and that's what I like about Idris, from looking at it, as it looks like a dependently typed language that *can* be used for day-to-day programming (but now, having switched over to Haskell, I question why it uses strict evaluations...)
20:31:03 <zRecursive> @google Idris
20:31:05 <lambdabot> http://www.imdb.com/name/nm0252961/
20:31:05 <lambdabot> Title: Idris Elba - IMDb
20:31:22 <Cale> Well, that's what it's trying to be anyhow. It's pretty young still, and doesn't really have everything it would need to be very practical quite yet.
20:31:32 <Cale> btw, Luther is a great show
20:31:33 <elliott> Idris also has "strings" almost as bad as C's.
20:31:34 <enthropy> edwardk: the alternative I'm settling for is to call on https://github.com/theZiz/aha/blob/master/aha.c
20:31:40 <elliott> not yet day-to-day.
20:31:54 <elliott> I say almost because I think they can include NUL bytes.
20:32:20 <tabemann> okay, I've never looked closely at its strings...
20:32:27 <Cale> I won't be completely satisfied until there's a language suitable for everyday programming which is founded on homotopy type theory :)
20:32:59 <zRecursive> Cale: how about OCaml ?
20:33:06 <Cale> (and of course, there's a computational interpretation of univalence)
20:33:18 <Cale> zRecursive: I want higher inductive types
20:33:41 <Cale> (which no language yet implements, and it's still a research project how to do it ;)
20:33:51 <tabemann> OCaml is what you want if you want a functional language and A) can't wrap your brain around laziness and/or purity or B) want objects really bad or C) want parameterized modules really bad
20:33:58 <tabemann> it's not bad if you want an impure, strict language
20:34:14 <zRecursive> I am using OCaml to do script thing instead of CL :)
20:35:08 <Cale> "agda-system-io: a library for streaming I/O with semantics as a lax braided monoidal category" :D
20:35:16 <BMeph> Cale: Maybe you could write one in Haskell; call it Hilton, even..."that's HoTT!" ;p
20:35:28 <edwardk> cale: Hrmm, but my obsession for the last week or so has been playing with Kan lifts‚Ä¶ and the 2-morphisms in the description of a kan lift aren't in general invertible. How can i represent those nicely in homotopy type theory where they all are? =)
20:35:43 <Cale> BMeph: http://en.wikipedia.org/wiki/Peter_Hilton
20:35:49 * tabemann brain explodes at that library description
20:36:15 <tabemann> and this is why I'm a programmer and not a mathematician...
20:36:19 <zRecursive> Just adding the shebang "#! /bin/sh\n # (*\n exec ocaml "$0" "$@"\n *)" , the ocaml program can run directly ...
20:36:55 <ezrios> "Control.Applicative This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor)."
20:36:59 <ezrios> ;_;
20:37:03 <leroux> zRecursive: CL as in Common Lisp?
20:37:11 <zRecursive> leroux: yeah
20:37:17 <Cale> edwardk: Well, you wouldn't directly encode them as 2-equivalences/2-equalities of course.
20:39:37 <tabemann> CL... as for Lisps, CL doesn't appeal to me much... but Scheme is honestly a little too small for doing anything with other than implementing an nth time...
20:39:52 <Cale> ezrios: The monoidal functor bit is specifically treating Hask as a monoidal category under (,) (pairing) and ().
20:39:57 <Cale> :t liftA2 (,)
20:39:58 <lambdabot> Applicative f => f a -> f b -> f (a, b)
20:40:06 <Cale> :t uncurry (liftA2 (,))
20:40:07 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
20:40:18 <ezrios> Cale: my category-fu is quite weak, sorry
20:40:39 <danharaj> A monoidal category is one which has a 'product' of some sort.
20:40:41 * tabemann has no category-fu
20:40:54 <danharaj> With appropriate coherence laws that are analagous to associativity and identity.
20:41:06 <Cale> A product on objects
20:41:16 <tabemann> or rather, my entire knowledge of category theory is limited to what is necessary to (attempt to) understand Monad, Monoid, Applicative, and Functor
20:42:26 <ezrios> :hoogle (,)
20:42:29 <Cale> If you look at http://en.wikipedia.org/wiki/Monoidal_functor and ignore almost everything on the page except for the lines giving:
20:42:32 <ezrios> D;
20:42:43 <nbouscal> i think the amount of category theory actually necessary to understand monad, monoid, applicative, and functor is zero
20:42:59 <Cale> œÜ_A,B: FA * FB -> F (A * B)
20:43:02 <nbouscal> a lot of it is useful but i don't think any is necessary
20:43:08 <Cale> you can see how that kind of resembles the type of:
20:43:11 <Cale> :t uncurry (liftA2 (,))
20:43:11 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
20:43:21 <Cale> and
20:43:41 <tabemann> nbouscal: exactly
20:43:53 <ezrios> jesus
20:43:58 <nbouscal> but if you do learn the category theory you get to look at pretty diagrams
20:44:03 <ezrios> I wasn't even aware half the stuff on this page was mathematical notation
20:45:05 <Cale> œÜ: I_D -> F I_C resembles the type of (\() -> pure ()) :: () -> f ()
20:45:16 <nbouscal> wait so are all of the lift functions natural transformations?
20:45:37 <nbouscal> i think that i just had an understanding
20:45:49 <hpaste> chexxor pasted ‚ÄúPattern match non-exhaustive‚Äù at http://lpaste.net/91624
20:46:04 <ezrios> Cale: I think I will continue my studies in algebra before looking at any deep category theory
20:46:10 <ezrios> this is still greek to me
20:46:14 <Cale> nbouscal: Polymorphic functions are usually natural transformations
20:46:25 <chexxor> anyone have a minute to answer my question about non-exhaustive pattern matching? I pasted above
20:46:26 <danharaj> Cale: Only in *!
20:46:31 <Cale> ezrios: Yeah, actually understanding what's going on will require lots of work :)
20:46:33 <danharaj> other categories get tricky.
20:47:18 <tabemann> chexxor: I missed the paste
20:47:45 <tabemann> oh there it is
20:47:51 <chexxor> cool
20:48:49 <edwardk> cale: i was mostly being facetious, but it struck me as interesting
20:48:55 <tabemann> basically, with the guards, there is no way for GHC to know that you've covered all the cases
20:49:05 <tabemann> unless you explicitly state True
20:49:13 <nbouscal> chexxor: I don't think this is the problem, but your guards are nonexhaustive in the [x] case. you're missing when x = 10
20:49:26 <tabemann> oh that too
20:49:38 <tabemann> change the last of the guards for each to just "otherwise"
20:50:06 <tabemann> "otherwise" evaluates to True but looks nicer in a guard
20:50:12 <chexxor> tabemann: ah! brilliant idea!
20:51:05 <chexxor> tabemann: so, if I use guards, I should always use "otherwise"?
20:51:16 * hackagebot llvm-general 3.2.6.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.6.1 (BenjaminScarlet)
20:51:18 * hackagebot llvm-general 3.3.6.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.6.1 (BenjaminScarlet)
20:51:20 * hackagebot monoid-subclasses 0.3.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.1 (MarioBlazevic)
20:51:38 <tabemann> it's good practice
20:51:45 <tabemann> there is one case where you don't though
20:51:51 <chexxor> tabemann: or should I have used clauses for those?
20:52:02 <tabemann> which is if you explicitly want to fall through to following pattern matches and their guards
20:52:25 <tabemann> but for each possible pattern it's a good idea if the last guard it ends up matching with is otherwise
20:52:35 <tabemann> except in cases where you explicitly want to cause an exception in those cases
20:52:58 <tabemann> (as pattern match failure exceptions contain line numbers and all)
20:55:54 <tabemann> actually
20:56:16 * hackagebot kan-extensions 3.5 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.5 (EdwardKmett)
20:56:18 * hackagebot kan-extensions 3.5.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.5.1 (EdwardKmett)
20:56:30 <tabemann> you shouldn't put catch-all cases that just raise an exception with "error" at the bottom of pattern matches, because the exceptions created with "error" contain less information
20:57:38 <edwardk> i tend to avoid putting catch-all cases because then when i add constructors to a data type i don't get warned about not handling them properly
21:02:23 <tabemann> oh that was fun... (writing a UTF-8 parser that acts on Scheme data types... but then implementing one in Scheme, which I'm not as proficient with as Haskell, would probably have been more fun...)
21:02:39 <tabemann> (lots and lots of "readArray" and "writeArray"...)
21:03:05 <leroux> I haven't done anything serious in haskell yet..sadly.
21:03:32 <leroux> Only somewhat cool thing I wrote in haskell is a brainfuck interpreter. And it's pretty lame.
21:03:46 <leroux> https://github.com/leroux/bf-interpreter/blob/master/bf.hs
21:03:59 <chexxor> length . hanoi 0 "a" "b" "c" -- hanoi returns list of pairs or strings
21:04:06 <chexxor> why does this not work?
21:04:20 <leroux> chexxor: Which week are you on?
21:04:26 <leroux> Are you doing CIS194?
21:04:44 <chexxor> leroux: yeah, week 1, hw01
21:05:31 <chexxor> afaik, '.' will pass function results to next function
21:05:39 <mstksg> leroux: no need to put down yourself man
21:05:45 <mstksg> er, put yourself down
21:05:46 <geekosaur> chexxor, not exactly
21:05:50 <leroux> chexxor: (length . hanoi 0 "a" "b") "c"
21:05:56 <leroux> So...
21:05:57 <ezrios> @h guard
21:05:57 <lambdabot> Maybe you meant: hackage haskellers help hitchcock hoogle hoogle+ v @ ? .
21:05:57 <tabemann> nice to hear of Haskell being used in school (when I was in school I just had to work in Java, C, and of all things, MIPS assembly)
21:05:59 <leroux> Don't do that.
21:06:00 <ezrios> @hoogle guard
21:06:01 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
21:06:01 <lambdabot> Language.Haskell.TH.Syntax data Guard
21:06:01 <lambdabot> Language.Haskell.TH data Guard
21:06:03 <leroux> 0.o
21:06:24 <leroux> tabemann: I'm hoping that whatever university I go to uses it...
21:06:26 <geekosaur> there is a big difference between length . hanoi "a" "b" "c" and length (hanoi 0 "a" "b" "c")
21:06:28 <leroux> That's next year.
21:06:29 <mstksg> you might recognize '.' from mathematics -- you see f(g(x)) being written as (f dot g) x
21:06:32 <mstksg> it's just function composition
21:06:41 <ezrios> leroux: you are more likely to encounter lisp I think
21:06:48 <ezrios> learning lisp is a Good Thing (tm)
21:06:51 <leroux> I've never enjoyed the parens much.
21:06:57 <leroux> I've done a bit of Racket.
21:07:02 <ezrios> ooh racket
21:07:02 <leroux> But not much.
21:07:16 <leroux> Just implemented CPS stuff with it last week.
21:07:17 <tabemann> apparently in the past a good few schools taught Scheme for intro CS, but apparently the number has fallen over time
21:07:36 <tabemann> (e.g. MIT pulled their class in it and replaced with goddamn Python)
21:07:47 <leroux> I don't understand why MIT would do that...
21:07:55 <chexxor> ok... I'm not familiar with '.' in math either... I'll try to find this in those ebooks
21:08:02 <leroux> Were they getting alot of feedback that they should teach a more "practical" lang?
21:08:19 <leroux> :t (.)
21:08:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:08:28 <tabemann> practical schmractical... you can learn a "practical" language once you already know how to program
21:08:34 <leroux> tabemann: Exactly.
21:08:42 <tabemann> actually, if you've learned how to program well, you should be able to learn *any* language
21:08:57 <levi> leroux: It's a shared course between the EE and CS tracks, and they wanted to bring in more EE-oriented material.
21:08:58 <newsham> ?hoogle (a -> b) -> (b -> c) -> a -> c
21:08:59 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:08:59 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:08:59 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
21:09:03 <leroux> tabemann: What should I do next in haskell?
21:09:14 <leroux> I was planning on reading some of Simon Marlow's book.
21:09:15 <ReinH> tabemann: python is a pretty good pragmatic choice but imo a pretty bad pedagogic choice
21:09:40 <tabemann> leroux: by Simon Marlow's book do you mean his concurrency book?
21:09:43 <leroux> Yes.
21:09:46 <levi> I think they still offer the SICP course, it's just no longer required.
21:09:55 <Cale> leroux: It looks really good, I'd recommend that :)
21:10:07 <ReinH> it's pretty easy to teach fundamental CS principles in a language with one syntax rule and 7 functions
21:10:08 * tabemann downloaded the ebook, and the dead tree version is in the mail
21:10:22 <ReinH> python is too inconsistent to be a good basis for a formal approach to CS imo
21:10:36 * BMeph prefers Lua
21:10:36 <ahill-89> My university started us with C.
21:10:38 <leroux> Especially it's duck typing...
21:10:38 <newsham> do they use it for formal programming language theory?
21:10:39 <ReinH> tabemann: yeah, Marlow's book is good.
21:10:45 <tabemann> ReinH: it is
21:10:45 <levi> As I said, it's not supposed to be a 'formal approach to CS' class anymore.
21:10:48 <newsham> i thought it was used more for intro to programming type stuff
21:11:07 <ezrios> levi: hm, that's a shame
21:11:14 <newsham> lambda still the ultimate TA for formal programming language theory ;-)
21:11:24 <levi> It's now an 'introduction to programming and electronics via python and robots' which actually sounds pretty fun.
21:11:25 <tabemann> beginning programmers *should* learn a formal approach to CS....
21:11:44 <ReinH> the good news is that you can still watch all the old SCIP lectures for free online
21:11:47 <newsham> tabemann: why?  beginning english speakers dont need to learn formal grammar.
21:11:48 <ReinH> and read the courseware
21:11:49 <ezrios> tabemann: I am of the opinion that beginning programmers should start with something they find fun
21:11:50 <ReinH> which is awesome
21:12:01 <ezrios> but if you are going to a higher institute of learning they should throw some theory into the mix
21:12:02 <ReinH> *SICP
21:12:03 <tabemann> robots are neat... but how are you supposed to learn how to program in terms of things like algorithms and data structures from them
21:12:21 <newsham> i think it depends entirely on what their end goal is..  if they're going to move on to formal programming theory then starting with scheme makes some sense
21:12:23 <leroux> tabemann: I'd guess that it's to get the students interested.
21:12:26 <levi> I'm sure there's still plenty of places to get your CS theory at MIT. :P
21:12:38 <newsham> but for some students they're never going to spend a lot of time learning PL theory
21:13:06 <levi> If Gerald Sussman is okay with the switch, it's probably not that bad.
21:13:06 <tabemann> newsham: because without things like understanding the basics of the theory, how can you do things like, say, choose between algorithms or data structures based on how they scale in different use cases?
21:13:10 <ezrios> levi: I think first year is a critical time for instilling good programming habits
21:13:17 <newsham> tabemann: seems like lots of opportunities for data structures and algorithsm to me
21:13:23 <leroux> What's a good university to go to for Haskell-esque stuff?
21:13:29 <leroux> US.
21:13:41 <newsham> tabemann: complexity is pretty much an entirely diff field than PL theory
21:13:42 <tabemann> I honestly wouldn't choose universities based just upon whether they offer Haskell or not
21:13:51 <newsham> you can do complexity just fine in python
21:13:52 <ezrios> tabemann: ditto
21:13:52 <tabemann> newsham: it was just an example
21:13:55 <leroux> tabemann: Just a question.
21:14:01 <leroux> Not that I'll choose that one.
21:14:06 <tabemann> and I don't know the answer to that question
21:14:06 <levi> ezrios: You can have good programming habits in Python.
21:14:20 * tabemann liked UW Madison despite their curriculum being mostly Java and C based
21:14:40 <ezrios> levi: true. Learning to think in terms of pure functions and to minimize state is best practiced in a functional paradigm I'd think though
21:15:09 <newsham> ezrios: and why does an intro programming course even need to discuss that at all?
21:15:19 <tabemann> even though in the "real world" you'll almost certainly run into state, it probably is a good idea to know how to minimize or, better yet, eliminate state and then only add state as forced to by the outside world
21:15:30 <ezrios> newsham: teaching students to program without relying on excessive global state?
21:15:39 <ezrios> that sounds like a rather good habit to learn early on
21:15:47 <newsham> ezrios: thats hwo most programmers in the world learn hwo to program.
21:16:04 <levi> ezrios: That's not the only valid or useful way to think about programming, though.
21:16:11 <newsham> i'm not saying its the best way, but i dont think its all that detrimental either
21:16:14 <tabemann> learning to eliminate state is useful for many "real" things, aside from programming in Haskell, e.g. good concurrent programming practices
21:16:36 <ezrios> levi: maybe it's not. Perhaps I'm just biased, I would never have taken to functional programming if I was never exposed to it in first year.
21:16:54 <ahill-89> I came around to it in the opposite direction.
21:17:05 <ahill-89> First year was C. Then they taught us Java.
21:17:16 <levi> Witnessing the difficulties that shared state has caused brings plenty of people around to functional progrmaming.
21:17:17 <ahill-89> One class in my senior year was taught in SML.
21:17:33 * tabemann came to functional programming, in the form of OCaml, all on his own, without ever hearing of it in school
21:17:37 <ahill-89> I instantly fell in love with functional languages.
21:17:57 <mapreduce> I was heading towards functional programming but doing it in the wrong languages.
21:18:10 <ezrios> ahill-89: I also started with imperative style languages
21:18:11 <mapreduce> Now I'm still doing functional programming and still doing it in the wrong languages.
21:18:16 <leroux> mapreduce: xD
21:18:24 <ezrios> I probably would have stayed within the imperative paradigm if I hadn't learned lisp
21:18:25 <leroux> I'm guessing JS or python.
21:18:37 <mapreduce> leroux: Mostly Java.
21:18:40 <tabemann> mapreduce: don't tell me you're a functional JavaScript or Python programmer
21:18:49 <levi> I have yet to figure out how to practically do functional programming in C. :P
21:18:50 <mapreduce> no, that would be too easy.
21:18:53 <leroux> Ahh, well, they are introducing FP in Jave 8, right?
21:19:03 <mapreduce> leroux: lambdas and method references
21:19:04 <ezrios> leroux: I think there is a C++ library for FP, Phoenix?
21:19:04 <leroux> Oh wait...they changed versioning scheme to 1.8..
21:19:06 <leroux> =\
21:19:10 <tabemann> they're introducing closures and lazy streams in Java 8
21:19:27 <leroux> ezrios: Not sure.
21:19:29 <ezrios> there is a quantum monad in Perl
21:19:45 * tabemann finds it amusing that mainstream imperative languages are slowly taking on bits and pieces of stuff that is done (much better) in functional languages these days
21:19:48 <ezrios> oh wait nevermind, it's not a monad ._.
21:19:56 <tabemann> and then you have languages that are trying to be functional (and failing) like Scala
21:19:58 <leroux> tabemann: How's F#? never used it.
21:20:04 <ezrios> there is a Haskell quantum monad though
21:20:07 <tabemann> F# is basically .NET's version of OCaml
21:20:25 <tabemann> minus things like parameterized modules
21:21:14 <leroux> Does anything exist in the Haskell core libs that does reverse compositon? Like this https://gist.github.com/leroux/5988483
21:21:43 <leroux> I'm not sure about the downsides of doing something like that.
21:22:10 <mapreduce> tabemann: Be sure to take things like scalaz and shapeless into consideration before you judge Scala to fail.
21:22:11 <leroux> Sometimes it's easier to thing in terms of starting with some initial data and transforming it by chaining.
21:22:33 <tabemann> leroux: that's exactly what people do, except they traditionally do it right to left, rather than left to right
21:23:08 <mapreduce> tabemann: i.e., the language lets you do a lot (but doesn't stop you from doing too much) but the standard libraries are a bit lacklustre, hence these two and others that improve things.
21:23:12 <leroux> Is there any particular reason why? Other than it looks imperative.
21:23:31 <leroux> It's basically looks like the bind operators.
21:24:04 <tabemann> leroux: there is actually a flipped bind operator, (=<<), that people use for this very purpose
21:24:13 <leroux> Ahh, that's what I was looking for.
21:24:18 <leroux> :t (=<<_
21:24:19 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:24:20 <leroux> :t (=<<)
21:24:21 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:24:49 <ahill-89> :t (<=<)
21:24:50 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
21:25:06 <tabemann> mapreduce: I was just reading a book on Scala, mostly out of boredom, and I got the impression from it that it really was a better Java, but not really thinking beyond the Java way of doing things
21:25:42 <ahill-89> I understand that it's constrained by the JVM, in a lot of ways.
21:31:17 * hackagebot kan-extensions 3.6 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.6 (EdwardKmett)
21:31:30 <tabemann> I missed everything after <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
21:32:11 <tabemann> mapreduce: I was just reading a book on Scala, mostly out of boredom, and I got the impression from it that it really was a better Java, but not really thinking beyond the Java way of doing things
21:32:20 <leroux> 00:25 < ahill-89> I understand that it's constrained by the JVM, in a lot of ways.
21:32:30 <tabemann> leroux: yeah, I got that impression
21:32:53 <leroux> And then a bunch of join/part stuff.
21:32:57 <leroux> That's all.
21:33:08 <tabemann> like, e.g. Scala is limited by type erasure (for a language that ought to have better reflection capabilities), and that Scala on .NET was artificially constrained to *also* have type erasure to match it, even though .NET doesn't have it
21:35:21 <tabemann> you can do a better job for a JVM language, though; e.g. Clojure, which seems far less limited except that it lacks true tail call optimization (it only allows self-tail recursion and trampolining)
21:36:17 <newsham> 10 kan extensions, 10 kan lifts, two reps of yonedas, followed by some kan stretches and a monad massage
21:36:33 <tabemann> hah
21:46:58 <mstksg> leroux: i asked a similar question some time ago. i think the main thing i settled on was that doing it reverse obscures what's actually going on. and that after a while your eyes get used to it
21:47:26 <mstksg> still getting used to map (f . g . h . i . j . k . l) xs though
21:47:29 <leroux> mstksg: I'm find with composition style right now.
21:47:34 <leroux> s/find/fine
21:52:10 <tabemann> well...
21:52:30 <tabemann> I'm not sure if one would typically *recommend* stringing things like that together in particularly long series
21:52:42 <tabemann> as code like that *can* get rather fragile and hard to maintain
21:53:13 <tabemann> usually if I'm stringing more than, say, three things together, it's probably too long and should be refactored to be more readable
21:53:41 <mstksg> tabemann: true, it was kind of exaggerated for effect
21:54:40 <boothead> what's the most likely reason for ghc-pkg list <package> not showing anything when I've just done cabal install <package> and its executable is in ~/.cabal/bin?
21:54:43 <tabemann> honestly, I tend to find others' code like that rather unreasable
21:54:56 <tabemann> s/unreasable/unreadable
21:57:19 <geekosaur> boothead: ghc-pkg list only shows libraries. not all executables come with useful libraries
21:57:43 <geekosaur> (for example, "cabal install happy" won't add anything to the library database)
22:00:00 <geekosaur> note that if you're installing programs, you may need to do something with your shell to make them available (specifically adding $HOME/.cabal/bin to $PATH; don't use ~, it doesn't do what you think!)
22:00:48 <tabemann> okay, done with implementing UTF-8, on to actually binding it to Scheme tomorrow...
22:02:15 <tabemann> (why must I have designed a Scheme binding API that is *painful* to use...)
22:04:13 <tabemann> (well, maybe it's not the API but that, let's say, for a function that takes 1-3 arguments, two of which need to be bounds-checked against the first argument, I need to type-check all of the arguments for each possible number of arguments, and then bounds check two of them, and handle all the possible error cases correctly...)
22:04:17 <tabemann> (forgive my blathering)
22:08:01 <boothead> geekosaur, ahhh. That's a shame! Can you think of another way offhand to detect if such a package has been installed? the thing I'm using is running ghc list --simple-output <package> and is failing in the case you mentioned (for hsenv and hdevtools in this case)
22:08:22 <geekosaur> just look in ~/.cabal/bin
22:08:45 <geekosaur> ghc-pkg is specifically a library manager, there's no way for it to deal with executables
22:09:12 <geekosaur> (this is a significant part of why cabal can't be a full package manager, since it has to defer to ghc-pkg for everything and ghc-pkg is limited)
22:09:21 <boothead> geekosaur, All I will have is the package name, I don't think that necessarily maps 1 to 1 to executables
22:09:51 <geekosaur> I don't think there's a solution to that, sadly
22:10:23 <boothead> it's a provisioning script https://github.com/trskop/hsansible/blob/master/examples/cabal.hs and the ghc-pkg step is how it figures out if it need to run cabal install or now
22:11:22 <boothead> I could ls ~/.cabal/packages/hackage.haskell.org | grep hsenv I suppose...
22:17:21 <leroux> tabemann: This looks very wrong... https://gist.github.com/leroux/6171397
22:17:40 <leroux> Any idea what I can do to remedy this incomplete proof?
22:17:50 <johnw> ask in #coq?
22:18:18 <leroux> Alright...
22:19:21 <tabemann> can't help you there (don't have a clue about Coq)
22:19:50 <leroux> =\
22:20:06 <leroux> It seems that this problem wasn't included in the course that used SF.
23:09:28 <johnw> is there a monoid like First, but which doesn't use Maybe?
23:09:39 <johnw> for scenarios where there is always at least one element
23:13:34 <lightquake> what's the 'right' way to get libgmp.so.3 on a Debian machine?
23:14:12 <leroux> lightquake: libgmp-dev?
23:14:15 <Cale> lightquake: apt-get install libgmp3c2
23:14:20 <Cale> (or similar)
23:14:27 <johnw> ah, now I see why First uses Maybe: memepty
23:14:37 <johnw> i need a semigroup to do use my Only value
23:15:04 <lightquake> excellent, ty
23:15:44 <johnw> ah, there it is: the First that wanted is in the semigroups package
23:19:09 <bergmark> johnw: :) yeah it sounded like it could be in there
23:43:08 <fragamus> I got a job offer from a company working in Scala. I wish it was haskell.
23:43:17 <johnw> in lens, how do I indicate that I don't want to insert a new record in a map, but just change an existing one?
23:43:35 <edwardk> 'ix'
23:43:46 <johnw> grazie
