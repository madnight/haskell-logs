00:08:32 <BMeph> jtbandes: Right, NM, carry on. :)
00:09:10 <jtbandes> BMeph: actually, "mapM (\x -> (x++)...<$>(someFunc x)) aList" does work... though I was hoping for something with do notation I suppose
00:27:27 <jtbandes> "cereal-0.3.5.2 failed during the building phase" :(
00:33:52 * hackagebot citation-resolve 0.3.0.3 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.3.0.3 (TakayukiMuranushi)
00:42:55 <adnap> Didn't know about ($!) until now
00:43:24 <ibotty> adnap: then you might like (.!) from pointless
00:44:03 <adnap> ibotty: Composition?
00:44:18 <ibotty> $ is to . as $! is to .!
00:44:21 <ibotty> :)
00:53:12 <aiguu>  ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
00:53:58 <aiguu>  ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
00:55:28 <thoughtpolice> can we ban people who do what aiguu did please?
00:56:11 <thoughtpolice> it's funny and all, 'lol apple', but it's a real asshole move.
00:56:40 <[swift]> yeah, i get tired of restarting my irc client because of the Magic Words =)
00:56:53 <thoughtpolice> to give context: there was a recently discovered - quite bad - bug in one of OSX's fundamental rendering libraries that cause arabic characters that aiguu posted to crash the browser
00:56:58 <[swift]> with great power comes great responsibility
00:57:10 <thoughtpolice> on OS X, and iOS, pretty much everything uses WebKit, so this is kind of a problem
00:57:29 <thoughtpolice> s/the browser/the WebKit rendering engine/
00:57:33 <[swift]> its actually an issue in CoreText, which means that even my irc client is affected =\
00:57:36 <lattenwald> funniest thing is crashing skype when it tries to recover chat history
00:57:38 <thoughtpolice> ah, right
00:57:45 <thoughtpolice> lattenwald: yes, it'll do the same for stuff like iMessages
00:57:54 <thoughtpolice> or Safari if you don't clear your history, even
00:58:04 <[swift]> i'm thankful that znc feels i've viewed the text and doesn't replay it for me
00:58:20 <mauke> I have a shorter version that I'd like to test
00:58:29 <mauke> but I don't think I'll find any volunteers :-)
00:59:11 <[swift]> you can msg it to me, whatever, i already restarted my irc client twice in the last 5 minutes
01:00:22 <thoughtpolice> i'm sure ##apple or whatever is probably having a blast today
01:00:34 <ibotty> searching for these strings lead me to that very nice cat video. enjoy.https://www.youtube.com/watch?v=htY54AMwoi0
01:01:01 <lattenwald> I think this bug was discovered not that recently. June, perhaps
01:01:43 <mauke> https://twitter.com/daken_/status/303784082599456768 - february
01:09:47 <adnap> lattenwald: Discovered in June and still not fixed?
01:10:00 <lattenwald> in february
01:11:22 <adnap> Oh, that's incredible
01:12:12 <elliott> thoughtpolice: thanks for the information
01:12:41 <elliott> thoughtpolice: I saw someone do it earlier but figured one line of random Unicode noise wasn't worth the additional noise of banning for, but now I see what it's for I agree it's inappropriate
01:12:46 <augur> byorgey: grad and div for types make sense, but does curl? it seems like something Joyal wouldve mentioned
01:13:58 <augur> or maybe bergeron et al. ill check there. maybe its specialized to certain kinds of differentiable things
01:14:58 <agocorona> hi
01:18:23 <zomg> That arabic text thing is funny in Irssi
01:18:38 <zomg> Only thing it seems to do is it flips around the timestamp of the message so it reads from right to left =)
01:19:05 <blackdog> zomg: hm, i'm using irssi and don't see that behaviour.
01:19:55 <haasn> > 0 & taking 10 bits .~ True
01:20:02 <lambdabot>   mueval-core: Time limit exceeded
01:20:03 <haasn> how come this doesn't work? shouldn't the taking make it a finite traversal?
01:20:59 <haasn> oh, no, it still can't reassemble the rest, can it
01:21:20 <zomg> blackdog: it seems it might be related to putty too
01:21:32 <augur> haasn: you should ping edwardk, or ask in -lens as well
01:43:16 <merijn> zomg: Actually my irssi on OSX renders that code just fine and the timestamp is still right too
01:43:35 <haasn> augur: I worked around it by just hacking together my own fromBits :: [Bool] -> Integer; since I don't think it's possible with this model of lens at least
01:43:45 <haasn> and that function isn't exactly complicated either
01:44:12 <augur> haasn: still, it might be worth bringing up
01:44:28 <haasn> yeah; I'm sure this topic has arisen in #haskell a number of times fwiw
01:44:57 <augur> haasn: still, it might be worth bringing up :P
01:45:21 <haasn> @tell edwardk it would be really cool if we could some day get 0 & taking 10 bits .~ True -- to work for Integer
01:45:21 <lambdabot> Consider it noted.
01:45:33 <zomg> merijn: probably putty then
01:45:39 <haasn> augur: done :)
01:45:45 <zomg> I had a few guys who use putty confirm it reversed the timestamp
01:46:02 <zomg> I'm guessing there's the UTF8 RTL trigger char somewhere in there (didn't really bother looking at it more intensively)
01:55:34 <knz> hi all
01:56:32 <knz> question: I want to make a RGB typeclass with two parameters: d (data structure) and n (numeric data types). I would like to say "class RGB c n where Num n and red :: c -> n
01:56:36 <knz> however that does not work
01:57:05 <knz> for now I have "class RGB c where red :: c num -> num" but then I need to explicitly say both "(RGB c, Num cn) -> c cn" in my uses
01:57:11 <knz> is there any shorter form?
01:58:06 <luite> knz: you could make Num a superclass of RGB
01:58:12 <thoughtpolice> what you want is 'class Num n => RGB c n where red :: c -> n'
01:58:29 <knz> aha
01:58:35 <luite> yep that :)
01:58:47 <luite> greetings from zurihac everyone :)
01:59:03 <bergmark> woop woop
01:59:07 <bergmark> luite: http://www.reddit.com/r/haskell/comments/1ldqav/thoughts_on_uhc_vs_haste_vs_fay/
02:00:20 <knz> hum
02:00:27 <luite> hehe tnx peoples for promoting ghcjs :p
02:00:27 <knz> luite thoughtpolice: thanks, it compiles
02:00:40 <knz> now I have another problem
02:01:01 <knz> how does ghc decide which Num instance to use?
02:02:06 <knz> never mind, found it
02:02:06 <knz> thx
02:37:54 <sopvop> So, haskell-src-exts does not understand kind ( t :: Symbol). is sad, no stylish-haskell
02:38:14 <haasn> edwardk: is there some sort of lens thing that will replace a fold by another if it's empty?
02:41:16 <haasn> oh, failing
02:42:04 <simon> @pl \a b -> abs $ fst a - fst b
02:42:07 <lambdabot> (id abs .) . (. fst) . (-) . fst
02:42:07 <lambdabot> optimization suspended, use @pl-resume to continue.
02:44:17 <haasn> edwardk: is there a helper for to . const? :)
02:44:28 <edwardk> nope
02:44:40 <edwardk> @let as = to . const
02:44:41 <lambdabot>  .L.hs:145:6:
02:44:41 <lambdabot>      No instance for (Contravariant f0) arising from a use of `...
02:44:51 <edwardk> @let as x = to (const x)
02:44:52 <lambdabot>  Defined.
02:45:00 <edwardk> > "hello
02:45:02 <lambdabot>   <hint>:1:7:
02:45:02 <lambdabot>      lexical error in string/character literal at end of input
02:45:08 <edwardk> > "hello"^..traverse.as 1
02:45:14 <lambdabot>   [1,1,1,1,1]
02:45:15 <edwardk> not a serious suggestion =P
02:45:21 <haasn> heh
02:45:35 <haasn> would be useful for my super-optimized, genearlized lensy fizzbuzzOf
02:45:47 <edwardk> re taking for Integer, i don't see it happening
02:47:23 <augur> edwardk: you've got mail
02:47:29 <augur> ~~1995~~
02:47:40 <lpaste> haasn pasted “fizzbuzz, lens style” at http://lpaste.net/92311
02:47:43 <haasn> edwardk: ^
02:47:44 <augur> (by mail i mean lambdabot msggsss)
02:47:57 <haasn> I want to improve this :(
02:47:59 <haasn> it's so ugly
02:51:48 <ibotty> simon: (abs .) . ((-) `on` fst)
02:52:07 <edwardk> augur: i do?
02:52:12 <edwardk> ah
02:52:13 <edwardk> @messages
02:52:13 <lambdabot> You don't have any messages
02:52:37 <augur> how weird
02:52:46 <augur> haasn left you a message and lambdabot acknowledged
02:52:55 <haasn> augur: and edwardk already replied :)
02:53:04 <augur> what where
02:53:10 <haasn> edwardk │ re taking for Integer, i don't see it happening
02:53:21 <augur> oh ok
02:53:30 <augur> just before i told him about it XD
02:53:58 <edwardk> > let fizzBuzz x = M.fromList [(3, "fizz"), (5, "buzz")] ^. failing (itraversed.indices (\n -> x `rem` n == 0)) (to . const $ show x) in fizzBuzz 3
02:54:00 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
02:54:01 <lambdabot>              with actua...
02:54:15 <edwardk> > let fizzBuzz x = M.fromList [(3, "fizz"), (5, "buzz")] ^. failing (itraversed.Lens.indices (\n -> x `rem` n == 0)) (to . const $ show x) in fizzBuzz 3
02:54:16 <lambdabot>   "fizz"
02:54:19 <edwardk> > let fizzBuzz x = M.fromList [(3, "fizz"), (5, "buzz")] ^. failing (itraversed.Lens.indices (\n -> x `rem` n == 0)) (to . const $ show x) in fizzBuzz 4
02:54:20 <haasn> edwardk: is there a package that implements flat projective planes (in ℝ^n)?
02:54:21 <lambdabot>   "4"
02:54:49 <edwardk> haasn: i just use linear or algebra for that sort of thing
02:55:05 <haasn> yeah, I'm looking at linear right now
02:55:08 <ibotty> simon: what about: abs .: (-) `on` fst
02:55:13 <edwardk> algebra's geometric coalgebra is sufficient for me to implement k-flats, etc.
02:55:35 <edwardk> > let fizzBuzz x = M.fromList [(3, "fizz"), (5, "buzz")] ^. failing (itraversed.Lens.indices (\n -> x `rem` n == 0)) (to . const $ show x) in fizzBuzz <$> [1..10]
02:55:37 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz"]
02:58:24 <osfameron> surely [1..15] to test that it actaully works for all cases?
02:59:45 <haasn> edwardk: I'm not exactly sure how to work with it, though; say I wanted to test if the point represented by (x,y) in P² intersects with a some polygon in ℝ³
03:01:27 <edwardk> > length "let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing (ifolded.Lens.indices (\n->rem x n==0)) (to.const $ show x) in fizzBuzz<$>[1..100]"
03:01:38 <lambdabot>   139
03:01:42 <edwardk> woot tweetable
03:01:58 <haasn> you can chop off lots of whitespace
03:02:06 <edwardk> i just got rid of most of it
03:02:18 <edwardk> > length "let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing(ifolded.Lens.indices (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]"
03:02:20 <lambdabot>   136
03:02:23 <haasn> and Lens.indices doesn't really count either :)
03:02:30 <edwardk> > length "let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing(ifolded.indices (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]"
03:02:31 <lambdabot>   131
03:02:40 <haasn> one more before (\n->rem
03:02:54 <edwardk> > let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing(elements (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]
03:02:55 <lambdabot>   <hint>:1:130:
03:02:55 <lambdabot>      lexical error in string/character literal at end of input
03:03:11 <haasn> you forgot to remove the \
03:03:20 <edwardk> > let fizzBuzz x=M.fromList[(3,"fizz"),(5,"buzz")]^.failing(elements (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]
03:03:21 <lambdabot>   Ambiguous occurrence `elements'
03:03:21 <lambdabot>  It could refer to either `Control.Lens.Tra...
03:03:28 <edwardk> > let fizzBuzz x=M.fromList[(3,"fizz"),(5,"buzz")]^.failing(Lens.elements (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]
03:03:30 <lambdabot>   ["*Exception: divide by zero
03:03:33 <edwardk> shucks
03:03:45 <haasn> huh..
03:03:49 <edwardk> > let fizzBuzz x=M.fromList[(3,"fizz"),(5,"buzz")]^.failing(each.Lens.indices (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]
03:03:51 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
03:04:03 <edwardk> > length "let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing(each.indices (\n->rem x n==0))(to.const $ show x)in fizzBuzz<$>[1..100]"
03:04:04 <lambdabot>   128
03:04:10 <haasn> oh, because elements indices with [0..
03:04:23 <haasn> ‘ielements’? :)
03:04:30 <haasn> for an IndexedTraversable t
03:04:30 <edwardk> :t ielements
03:04:31 <lambdabot>     Not in scope: `ielements'
03:04:31 <lambdabot>     Perhaps you meant one of these:
03:04:31 <lambdabot>       `elements' (imported from Control.Lens),
03:04:35 <haasn> it was a suggestion
03:04:37 <edwardk> =)
03:05:02 <edwardk> sadly we replaced the old version of that stuff with the new traversal.indices thing
03:05:05 <augur> that is an incomprehensible widget
03:05:12 <edwardk> augur: sure
03:05:21 <edwardk> augur: code golf usually is
03:05:49 <edwardk> > length "let fizzBuzz x=M.fromList[(3,\"fizz\"),(5,\"buzz\")]^.failing(each.indices (\n->rem x n==0))(to.const.show$ x)in fizzBuzz<$>[1..100]"
03:05:50 <lambdabot>   127
03:06:23 <supki> it should be \\n I think
03:06:28 <augur> im sure it would make more sense if i knew what any of these things were doing
03:07:08 <edwardk> supki: true
03:07:14 <haasn> > let fizzBuzz x=fromMaybe(show x)$["fizz"|x`rem`3==0]<>["buzz"|x`rem`5==0]in fizzBuzz<$>[1..100]
03:07:15 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
03:07:15 <lambdabot>            ...
03:07:21 <dmwit> cabal files let you specify a tag in source-repository this. Is there something like tag: $version so I don't have to remember to update the version number in two places every time?
03:07:27 <haasn> should work with MonadComprehensions
03:07:29 <edwardk> i'm likely to expand it a bit before tweeting
03:07:41 <haasn> this one is shorter either way
03:07:44 <edwardk> dmwit: not afaik
03:07:56 <haasn> but less lensy, so it doesn't score as many points :)
03:08:16 <dmwit> edwardk: Okay, time for a feature request. =)
03:09:24 <edwardk> > [1..100]<&>\x->M.fromList[(3,"fizz"),(5,"buzz")]^.failing(each.Lens.indices (\n->rem x n==0))(to.const $ show x)
03:09:26 <lambdabot>   <hint>:1:14: parse error on input `->'
03:09:36 <edwardk> > [1..100] <&> \x->M.fromList[(3,"fizz"),(5,"buzz")]^.failing(each.Lens.indices (\n->rem x n==0))(to.const $ show x)
03:09:38 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
03:10:32 <edwardk> now to clean up the map
03:12:31 <haasn> [1..100] <&> \x->(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.Lens.indices (\n->rem x n==0))(to.const$show x)
03:12:35 <haasn> > [1..100] <&> \x->(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.Lens.indices (\n->rem x n==0))(to.const$show x)
03:12:36 <lambdabot>   <hint>:1:28: parse error on input `,'
03:12:36 <edwardk> > (1,2)^@..ix 1
03:12:38 <lambdabot>   [(1,2)]
03:12:53 <haasn> > [1..100] <&> \x->[(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.Lens.indices (\n->rem x n==0))(to.const$show x)
03:12:54 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
03:13:14 <mcstar> how relevant is the 'lightweight monadic regions' paper? i guess it would be educational to fully understand the technique, anyway, but im asking if it is used in practice, or better methods are available to encode resource lifetime guarantees in the type system
03:13:15 <haasn> > comparing length "M.fromList" ".itraversed"
03:13:15 <edwardk> shucks the only key/value stuff i can think of for pairs is ix
03:13:16 <lambdabot>   LT
03:13:21 <haasn> edwardk: itraversed works
03:13:26 <haasn> but it's longer :)
03:13:35 <edwardk> ah yes
03:13:46 <haasn> Map here is overkill either way
03:13:51 <haasn> since we only traverse it in order
03:13:59 <edwardk> > [1..100] <&> \x-> [(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.indices (\n->rem x n==0))(to.const $ show x)
03:14:00 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
03:14:00 <lambdabot>              with actua...
03:14:11 * hackagebot universe 0.4.0.3 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4.0.3 (DanielWagner)
03:14:13 <edwardk> > [1..100] <&> \x-> [(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.Lens.indices (\n->rem x n==0))(to.const.show$ x)
03:14:15 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
03:14:38 <haasn> it would be cool if we could write fooo `failing` bar  -- here
03:14:43 <haasn> or perhaps some other combinator, but ^. is already fairly high
03:14:47 <haasn> and it would need to be lower than (.)
03:14:53 <haasn> which doesn't seem possible
03:14:56 <elliott> > (1,2,3)^@..ieach
03:14:57 <lambdabot>   Not in scope: `ieach'
03:14:57 <lambdabot>  Perhaps you meant `each' (imported from Control.Lens)
03:14:58 <elliott> > (1,2,3)^@..each
03:14:59 <lambdabot>   [(0,1),(1,2),(2,3)]
03:15:02 <elliott> hm
03:15:10 <elliott> can we go from (x,y,z) -> ((0,x),(1,y),(2,z))?
03:15:49 <edwardk> probably with iover   using (,)
03:15:56 <edwardk> > iover each (,) (1,2,3)
03:15:58 <lambdabot>   ((0,1),(1,2),(2,3))
03:15:59 <elliott> > (1,2,3) %@~ (,)
03:16:00 <lambdabot>   Couldn't match type `(t1, t2, t3)'
03:16:01 <lambdabot>                with `Control.Lens.Intern...
03:16:06 <elliott> > (1,2,3) & each %@~ (,)
03:16:08 <lambdabot>   ((0,1),(1,2),(2,3))
03:16:11 <elliott> cool.
03:16:13 <elliott> I guess.
03:16:30 <elliott> we should give that a name. "iannotate" or something
03:16:33 <mcstar> edwardk: i dont want to intrude on your lens exposition, but could you comment on my question?
03:16:35 <elliott> ilabel
03:17:14 <haasn> toListOf each
03:17:18 <haasn> itoListOf*
03:17:39 <edwardk> > [1..100] <&> \x-> [(3,"fizz"),(5,"buzz")]^.failing(each.itraversed.Lens.indices (\n->rem x n==0))(to$ \_ -> show$ x)
03:17:41 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
03:17:41 <haasn> but yeah it sounds useful
03:18:37 <edwardk> well, keep in mind for thinsg like maps that'll make a whole new data structure with extra indices in it before you can proceed to modify them, etc.
03:19:17 <lpaste> haasn annotated “fizzbuzz, lens style” with “fizzbuzz, lens style (clean)” at http://lpaste.net/92311#a92313
03:19:20 <haasn> here's my cleaned up version
03:19:30 <haasn> this is the one I will give to job interviews :)
03:19:33 <elliott> haasn: it is not toListOf
03:19:42 <haasn> > itoListOf each (1,2,3)
03:19:44 <lambdabot>   [(0,1),(1,2),(2,3)]
03:19:49 <elliott> [] is not the same thing as ()
03:19:56 <haasn> oh!
03:20:17 <edwardk> haasn: heh
03:20:24 <elliott> e.g. you can annotate a Map and get a Map back.
03:20:25 <haasn> > over each withIndex (1,2,3)
03:20:28 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Indexable i p0)
03:20:28 <lambdabot>    arising ...
03:20:29 <haasn> err
03:21:13 <haasn> yeah I guess yours is the shortest
03:21:46 <elliott> :t withIndex
03:21:49 * haasn just realized he missed a few messages earlier, including edwardk's
03:22:09 <elliott> ilabel = iover ?? (,). I guess it fails edwardk's favourite threshold
03:23:37 <haasn> (what threshold is that?)
03:26:04 <simon> is there a paramorphism function in Haskell's library?
03:26:29 <simon> i.e. a fold whose operand is (a -> [a] -> b -> b)
03:27:22 <arkeet> @hoogle (a -> [a] -> b -> b) -> b -> [a] -> b
03:27:23 <lambdabot> No results found
03:27:23 <notdan> simon: not in base there is
03:27:28 <elliott> haasn: fairbairn
03:27:34 <notdan> simon: http://hackage.haskell.org/packages/archive/recursion-schemes/3.0.0.2/doc/html/Data-Functor-Foldable.html there is one in recursion-schemes tho
03:27:38 <notdan> called 'para'
03:27:52 <arkeet> elliott: I never found a good reference for that threshold.
03:27:57 <notdan> it's generalized for folds over arbitrary data structures though
03:28:05 <arkeet> I kept finding mailing list archives with edwardk in them.
03:28:08 <elliott> arkeet: I found one by googling just now. it's a broken link.
03:28:13 <elliott> oh, that's what i meant.
03:28:18 <elliott> nobody but edwardk talks about it ever :P
03:28:18 <edwardk> :t paraOf
03:28:19 <lambdabot> Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r
03:28:27 <elliott> wtf, since when does paraOf exist?
03:28:38 <notdan> lens wizardy
03:28:45 <simon> notdan, thanks!
03:28:51 <edwardk> that one was stolen from uniplate actually
03:28:57 <edwardk> :t paraOf plate
03:28:58 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
03:29:12 <edwardk> its a little funny terminologically iirc
03:29:26 <edwardk> but i kept it for compatibility
03:30:14 <elliott> yeah it looks a bit off
03:30:24 <notdan> edwardk: while you are here, may I ask you a question about typeclasses? Judging from your code you seem to prefer the former way of declaring instances: https://gist.github.com/co-dan/6351495
03:30:36 <elliott> arkeet: http://article.gmane.org/gmane.comp.lang.haskell.libraries/5322
03:30:36 <notdan> and I was wondering why is that?
03:30:46 <edwardk> notdan: they are each useful
03:30:52 <edwardk> but they have very different meanings
03:31:29 <edwardk> the former says 'hey compiler, if you can figure out that the outside is D.QDiagram, even if you don't know a b and c you can now assume they are D.SVG, D.R2, and Any respectively
03:31:34 <elliott> "If someone knows what they want to do (and already knows the word), then they might well check to see if there's a function called intercalate in the libraries, which again is a slight advantage.
03:31:39 <elliott> "
03:31:40 <elliott> file under wishful thinking
03:31:58 <edwardk> the latter says, if you can figure out the entire type (D.QDiagram D.SVG D.R2 Any)  then here is an instance
03:32:18 <edwardk> the latter generally performs poorly in the presence of inference on any of the parameters of D.QDiagram.
03:32:19 <elliott> interesting that the threshold was first used in an argument against adding a function which now exists
03:32:47 <haasn> notdan: (roughly speaking) when the type variables are fixed both instances will work, but when the type variables are ambiguous; the second one will just throw an ambiguous type error; while the first one will fix them
03:33:19 * haasn is accidentally swapping , and ; again
03:33:28 <elliott> http://article.gmane.org/gmane.comp.lang.haskell.libraries/5296 haha, this is a good thread
03:33:42 <elliott> @let concatIntersperse = intercalate
03:33:43 <edwardk> I use the (a ~ Char) => IsString [a]   instances when I know i don't want any other instances for different types than 'a' when the other parameters in th instance head are fixed.
03:33:43 <lambdabot>  Defined.
03:33:51 <notdan> edwardk: what do you mean it performs poorly?
03:34:11 * hackagebot hsemail 1.7.7 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.7 (PeterSimons)
03:34:29 <edwardk> notdan: i mean that it'll fail to fire. If you only know you hav D.QDiagram D.SVG D.SVG x    then the former instance works and the second one requires a type annotation
03:34:38 <edwardk> er D.SVG D.R2
03:34:56 <edwardk> notdan: i'm generally allergic to requiring my users to provide type annotations for anything
03:35:20 <edwardk> unless they really need to plumb some type around and its deep magic
03:35:21 <notdan> I see
03:35:26 <notdan> thanks
03:35:43 <edwardk> i feel that forcing type annotations on users is generally a sign of bad library design practice in haskell
03:36:03 <edwardk> unless you absolutely need some feature like rank-n types for correctness
03:43:18 * elliott sighs at data Foldr a b = forall r . Foldr (a -> r -> r) r (r -> b)
03:43:31 <elliott> we need a Useless Use of Existential Data Types award.
03:43:33 <elliott> oh, wait.
03:43:38 <elliott> maybe it isn't actually useless there?
03:43:53 <elliott> it is for the foldl version, at least
03:46:53 <hari_> Can anybody let me know how to make this shorter. in particular the gameplay function  http://lpaste.net/92314
03:48:07 <Iceland_jack> hari_: You may want to consider using ‘printf’ from Text.Printf for printboard
03:48:46 <Iceland_jack> also you can write: checkgameover = notElem 0
03:49:31 <notdan> elliott: is that from Tekmo's library?
03:49:53 <hari_> thanks
03:50:18 <elliott> notdan: from an SO answer.
03:51:03 <Iceland_jack> the gameplay/{player,computer}move are particularily hairy and it's hard to find simple recommendations from a quick glance
03:51:14 <hari_> Yes, using ++ to join so many lists
03:51:25 <hari_> printf seems a good idea
03:51:25 <mcstar> you can make it shorter by eliminating `computermove`, thats like 80 lines
03:51:53 <elliott> mcstar: not helpful.
03:52:46 <mcstar> no, it is not helpful to 'unroll' an algorithm, so you need to un-unroll it
03:53:05 <Iceland_jack> hari_: You can also note that ‘gameplay’ follows similar logic whether ‘ch == 1’ or not, what does the ‘Int’ stand for? You may want to create a new datatype for that
03:53:23 <mcstar> (maybe for speed, you would do it in some cases)
03:53:25 <Iceland_jack> also write the types /directly/ above the functions
03:53:35 <hari_> yes, it was to decide which player to move -computer or human player
03:53:54 <Iceland_jack> data Player = Computer | Human ?
03:54:36 <Iceland_jack> Don't use 1 and (-1) to represent that in Haskell
03:54:42 <hari_> OK thanks... I need to delve deeper into data and types
03:54:58 <mcstar> also, you could actually pattern match on the board itself, instead of writing that much ==
03:55:04 <Iceland_jack> Yes
03:55:17 <hari_> iceland_jack: I agree. It was a quick program. Still learning much
03:55:29 <Iceland_jack> No problem hari_, these are just suggestions
03:55:48 <Iceland_jack> Also (choice == "Y" || choice == "y") might be written as (choice `elem` ["Y", "y"]) especially if you want to add more options
03:55:56 <hari_> I thought of pattern matching the board, but how can I check all cases
03:56:03 <mcstar> or just turn input into lowercase
03:56:32 <Iceland_jack> mcstar: Or that, my suggestion is more beneficial for adding additional cases
03:56:41 <hari_> Thanks. I am sometimes trapped in imperative mode.
03:56:55 <nooodl> i wonder what a good representation for the board might even be here
03:57:17 <mcstar> 2d array, i would think, at first glance
03:57:19 <nooodl> one cell would be Maybe Piece where Piece = X | O, i guess
03:57:32 <hari_> I found a few tictactoe examples in haskell, but found them all too confusing
03:57:42 <mcstar> or, maybe just a tree, with filled in squares as nodes
03:57:44 <nooodl> but then how do you make sure your board's exactly a 3x3 collection of Pieces
03:57:59 <mcstar> or just use a proper game tree, and algorith-mize `computermove`
03:58:13 <Iceland_jack> hari_: Since the board is so small you could make:
03:58:14 <Iceland_jack>     data Row = Row Piece Piece Piece
03:58:14 <Iceland_jack>     data Board = Board Row Row Row
03:58:14 <Iceland_jack> Which makes sure that the board is always 3×3
03:58:37 <blackdog> hari_: dibblego has a course up on that problem: https://github.com/NICTA/course/tree/master/projects/TicTacToe
03:58:43 <hari_> thank you.
03:58:44 <nooodl> i considered data Row = R1 | R2 | R3; data Col = C1 | C2 | C3
03:58:47 <mcstar> i think it would be better if you had considered an NxN board..
03:58:50 <blackdog> just the readme in there, but it's food for thought at least.
03:58:51 <nooodl> and then your Board is a Map (Row, Col) Piece
03:59:03 <hari_> I read about minimax algorithm but it seems too complicated for my level of undersanding.
03:59:31 <blackdog> ah, there we go, there's a solution at https://github.com/tonymorris/course/tree/master/projects/TicTacToe/haskell/src/Data/TicTacToe
03:59:32 <Iceland_jack> also hari_, the ‘rep’ function is really a Show instance
03:59:47 <mcstar> you could still come up with a brutefoce search, without writing out every possible scenario
04:00:09 <Iceland_jack> Something like:
04:00:09 <Iceland_jack>     instance Show Piece where
04:00:09 <Iceland_jack>         show X = "X"
04:00:09 <Iceland_jack> 	show O = "O"
04:00:12 <Iceland_jack>  
04:00:39 <HugoDaniel> http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS <- does this actually work ?
04:01:48 <hari_> At this stage, I was actually happy when my program compiled properly. :)
04:02:35 <Iceland_jack> hari_: If you do represent the board as a you do now, you can write something like [ take 3 (drop (3*i) board) | i ← [0,1,2] ] to get all the rows
04:03:21 <arkeet> why not just Data.List.Split.chunksOf 3
04:03:30 <hari_> Ok
04:03:44 <Iceland_jack> Or that, he may not have the split library installed or want to add dependencies
04:04:00 <Iceland_jack> Or you can represent it as a list of lists, where checking the rows /and/ columns is as simple as: all checkRows board && all checkColumns (tranpose board)
04:04:23 <arkeet> well you could just write your own.
04:04:29 <arkeet> :t splitAt
04:04:30 <lambdabot> Int -> [a] -> ([a], [a])
04:05:18 <hari_> Actually not yet fully comfortable with specific data types in Haskell. Lists seem easiest.
04:05:32 <Iceland_jack> Which data types do you feel uncomfortable with?
04:05:46 <hari_> Creating my own data types.
04:06:23 <Iceland_jack> Did what I suggested earlier seem difficult?
04:06:24 <Iceland_jack>     <Iceland_jack> data Player = Computer | Human ?
04:06:26 <Zenol> hari_: Play with it in GHCi, once you get used, you'
04:07:04 <hari_> Is that similar to enum in C
04:07:10 <Zenol> you'll find using your own datatypes more powerfull (you limit the number of piece to exactly 3, no more, not less. Also, you add a sementic value. You now know that you handle not a list of piece, but a Row).
04:07:45 <Iceland_jack> hari_: Not quite, but you can think of it like that
04:08:14 <Iceland_jack> The data type Player contains two values: Computer and Human
04:08:29 <Iceland_jack> So (Computer :: Player) and (Human :: Player)
04:08:41 <hari_> OK. I have been also playing with Data types some time back
04:08:48 <Zenol> hari_: It's kind of enhenced enum. for example struct S{int a; int b; int c} would be data S = S Int Int Int.
04:09:07 <mauke> data S = S{ a :: Int, b :: Int, c :: Int }
04:09:33 <mcstar> contains two values or inhabited by two values?
04:09:35 <hari_> I now recollect the concept
04:09:36 <Zenol> mauke: (I don't want to efraid him with record syntax)
04:10:05 <Zenol> hari_: And typedef enum {A, B, C} E; would be data E = A | B | C
04:10:06 <notdan> mcstar: what's the difference?
04:10:13 <hari_> yes, I actually wrote a vcard creator using the record syntax in haskell.
04:10:24 <Iceland_jack> hari_: You can then pattern match on your newly created datatype:
04:10:24 <Iceland_jack>     whoseMove ∷ Player → String
04:10:24 <Iceland_jack>     whoseMove Computer = "It's the computer's move! *beep boop*"
04:10:24 <Iceland_jack>     whoseMove Human    = "Step aside tincan!"
04:10:26 <Zenol> hari_: The good thing is that you can mix 'enum' and 'struct'.
04:10:30 <mcstar> notdan: the first seems odd to me, if it is correct, than alright
04:10:30 <mauke> data E = A | B | C deriving (Eq, Ord, Bounded, Enum);
04:10:34 <mcstar> then*
04:10:49 <notdan> mcstar: idk myself :)
04:11:04 <mcstar> i dont think a type 'contains' any value
04:11:32 <mcstar> but 2 values, Human,Computer exist with type Player
04:11:42 <wavewave> hi
04:12:03 <hari_> my memory is just rusty, but it's coming back to me now, after reading some of my earlier programs
04:12:11 <Iceland_jack> mcstar: Sloppy terminology, but it helps to explain types in terms of elements in a set for people unfamiliar with type theory
04:12:30 <Zenol> mcstar: If you think about the "category" of types, tehn types contains values (as ensemble contains elements). No?
04:12:41 <hari_> I should get down my RWH book and refresh
04:15:30 <hari_> Which is more important to master first - data types or monads
04:15:37 <hari_> for beginners
04:15:46 <Iceland_jack> Master for beginners? :)
04:15:51 <hari_> I mean learn
04:15:56 <Iceland_jack> Try to get a good grasp on data types
04:15:57 <srhb> hari_: You need to understand data types before you can really grasp monads.
04:16:19 <benj_> and understand type classes in general, before you understand monads
04:16:22 <Iceland_jack> and don't focus on monads, you use them in your programs
04:18:42 <hari_> from what I've read monad is simply a way used in funfctional language to write imperative code? or rather to chain together actions?
04:19:17 <Iceland_jack> hari_: ‘Don't worry about it at this moment’ is what I'd say
04:19:43 <sipa> hari_: for now, assume monads don't exist
04:20:06 <sipa> hari_: they're a generalization you don't need before you understand what they are generalizing
04:20:09 <srhb> hari_: That's inaccurate / a lie / true / you shouldn't worry about it. :-)
04:20:41 <hari_> OK
04:21:04 <mcstar> or you could read what they say about it on the haskell wiki
04:21:18 * mcstar waits for the rocks to hit him
04:21:45 <srhb> mcstar: Someone cleaned the floor here recently. :-<
04:22:52 <hari_> I will read the wiki on the topic, thanks
04:26:00 <mcstar> in the 'typing haskell in haskell' paper, for the type Type, why dont they encode Id and Kind directly in the TVar and TCon constructors?
04:26:38 <mcstar> also, i think Fig.1 contains a typo
04:29:59 <hari_> My doubt is , suppose I want to refer to an expression by means of a name, should I use let or where? Which is appropriate in which situations?
04:30:54 <mauke> .oO( indian? )
04:31:37 <Saizan> hari_: sometimes you have no choice because you are in the middle of an expression and have to use let
04:32:09 <mcstar> you can promote that to a function
04:32:17 <mcstar> but probably not worth it
04:32:22 <Saizan> hari_: otherwise it's just up to what reads better, i find where more tidy but i guess sometimes it's best to put definitions before their use
04:33:04 <hari_> I know let is used in do blocks - but I am not sure how it works.
04:33:05 <Iceland_jack> hari_: You'll develop an intuition or preference for which is better quickly enough
04:33:16 <Saizan> where spans over all the guards for the same pattern though, so that's a context in which it has an advantage
04:33:22 <Iceland_jack> They both have their uses
04:33:57 <mauke> hari_: do { let v = X; ... } ==> let v = X in do { ... }
04:34:30 <hari_> In the second, will the name be accessible in the entire do block?
04:34:36 <Iceland_jack> yes
04:35:02 <hari_> OK, so that's why let fails to work when used inside if or then condition
04:35:16 <hari_> I mean not accessible outside
04:36:28 <hari_> so in C, I can write "if (a == b) result = 1; else result = 0;
04:36:36 <dmwit> hari_: Correct, bindings in the A of "let A in B" are only visible in "B".
04:36:47 <mcstar> let result = if a==b then 1 else 0
04:36:49 <mauke> result = a == b ? 1 : 0;
04:37:00 <mauke> result = a == b;
04:37:22 <mauke> let result = unsafeCoerce (a == b) :: Int
04:37:31 <hari_> thank you
04:37:33 <mcstar> wtf
04:37:42 <hari_> that seems the answer to my question
04:37:56 <mauke> mcstar: problem, officer?
04:38:09 <phka> i'm trying to write some ST code, but i can't seem to be able to get the types right
04:38:12 <phka> http://lpaste.net/92316
04:38:17 <Iceland_jack> hari_: When you use 0 or 1 it feels like you're using it to model something that you should use your own data types for, or simply Bool
04:38:21 <mcstar> you could start by explaining what you meant by 'indian?' :)
04:38:30 <mcstar> mauke: ^
04:38:39 <donri> if a == b then result .= 1 else result .= 0 -- yay lenses
04:38:56 <dmwit> phka: You cannot return references from ST.
04:39:18 <hari_> iceland_jack: I know. I just wanted an example.
04:39:19 <mauke> mcstar: the use of "doubt" instead of "question" is common on the internets and I was wondering whether it was a typically indian thing, or rather whether hari_ was from india
04:39:24 <dmwit> phka: (And the types are set up to enforce this.)
04:39:33 <hari_> I am from India :-)
04:39:33 <dmwit> phka: (...as your seem to be noticing. =)
04:39:48 <Iceland_jack> hari_: OK :) I just wanted to reiterate the point since it felt similar to your use of 1 and (-1) for players
04:39:54 <dmwit> s/your/you/
04:40:07 <mauke> I like geolocating people based on what they write
04:40:19 <hari_> i write British mixed with Indian english
04:40:43 <merijn> ji geolocates to native English locale :p
04:40:43 <phka> dmwit: so i can't have a STRef in a datatype? i'm trying to implement a mutable tree, how would i go about doing this without stepping into the IO monad?
04:40:46 <mauke> e.g. if someone's mistyping ? as ß, you're talking to a german (probably)
04:40:54 <dmwit> phka: That is not what I said.
04:40:56 <donri> phka: either stay in ST, or use another mutable type, or make it immutable
04:41:01 <mcstar> mauke: ok, i see, but what made you think he was indian? i didnt notice such thing, and wondering what that might be
04:41:20 <mauke> mcstar: <hari_> My doubt is
04:41:26 <mauke> also seen as "I have a doubt"
04:41:28 <dmwit> phka: You can't return an STRef from ST. But you can store and munge STRefs *inside* ST with no problem.
04:41:28 <hari_> Probably my semi-formal writing style
04:41:37 <mauke> when it should be "I have a question"
04:41:46 <mcstar> oh
04:42:12 <dmwit> phka: e.g. if you remove "runST" from your implementation and make the return type "ST s (Container s a)", I suspect your code will work fine.
04:42:18 <merijn> dmwit: You can return STRef, you just can't do anything useful with it :p
04:42:20 <hari_> We also use many old British words not used even in Britain
04:42:21 <donri> phka: the whole point of ST is local mutation. the moment you step out of ST (runST) you can't do any mutation anymore.
04:42:24 <merijn> dmwit: At least according to the ST paper
04:42:35 <phka> donri: ideally, i would wanna have something like insert :: a -> Tree a -> Tree a, mutate the nodes, and then go back to pure code
04:42:45 <phka> dmwit, donri: is this at all possible?
04:42:46 <mauke> hari_: such as "needful"!
04:42:55 <hari_> And "latrine" :)
04:43:01 <mauke> also, "kindly" instead of "please"
04:43:02 <zomg> I figured he was indian because his nick is hari :P
04:43:02 <donri> phka: yes, if you copy the tree :)
04:43:18 <dmwit> phka: Yes. Inside, this will look like making a mutable copy of the tree, mutating it, and returning an immutable copy of the newly mutated tree.
04:43:22 <mcstar> the only hari i know is badr hari, and he is from morocco
04:43:29 <mauke> hari_: that's not unique enough (e.g. it's used in german) :-)
04:43:53 <merijn> mauke: Is it common in german?
04:43:56 <zomg> mcstar: yeah suppose it's a name in other countries too but most haris I've met were indian :)
04:43:57 <donri> phka: it would defeat purity if you could mutate the original tree outside ST
04:44:06 <merijn> mauke: It's valid Dutch but you'd look really peculiar/old-fashioned for using it
04:44:13 <dmwit> phka: If you're not allergic to "unsafe", you can skip the second copy. But you need to be careful and I don't recommend it given the experience level I infer from the questions you're asking at the moment.
04:44:15 <haasn> edwardk: the formulas you use in http://hackage.haskell.org/packages/archive/linear/1.2/doc/html/src/Linear-Plucker.html seem completely inconsistent with the ones given in http://tog.acm.org/resources/RTNews/html/rtnv10n3.html#art11
04:44:50 <haasn> and using yours I don't seem to get any sensible results (it tells me every line stabs intersects other line I've tested, even for ones where this is trivially false); whereas the definitions given on the second page give me the expected results
04:44:52 <hari_> Which is the preferred GUI toolkit for haskell? especially for cross platform use
04:44:52 <haasn> what gives?
04:45:26 <dmwit> hari_: I think the usual advice is to use bindings to the toolkit you already know how to use well.
04:45:46 <mcstar> haasn: are you sure you are working in euclidean space?
04:46:18 <dmwit> hari_: My personal (biased) recommendation is gtk2hs. I think there's good bindings to OpenGL, SDL, wxWidgets, and possibly even Qt as well.
04:46:23 <donri> phka: you might want to take a look at packages like vector and hashtables for some inspiration on ST based API design
04:46:28 <phka> dmwit, donri: but wouldn't making a copy of the original tree defeat the purpose of using the ST monad? i'm precisely trying to avoid that, i.e. i don't want to recreate all parent nodes whenever i change a value in a node
04:46:34 <hari_> I am familiar with Qt and GTK
04:46:41 <dmwit> phka: Then you will need to stay in ST.
04:46:56 <haasn> mcstar: yes; I'm testing with the unit vector in the X direction and the unit vector in the Y direction (translated by 1 each in x/z)
04:47:06 <dmwit> phka: If your algorithm needs to do mutation -- even somewhere deep inside -- the whole thing must be in ST. Sorry. Deal with it.
04:47:10 <donri> phka: that depends, but often yes. that might be why non-ST structures are more common in haskelland :)
04:47:10 <haasn> these should fairly trivially be skew
04:47:16 <mauke> merijn: it's not very common. I think I've only seen it in a military context
04:47:22 <hari_> Will go through some tutorials on getting started with those then
04:47:49 <dmwit> hari_: I can send you a link to a particularly good gtk2hs tutorial, one moment...
04:48:07 <dmwit> Oh, well, it's also the first hit on Google for "gtk2hs tutorial". =)
04:48:11 <dmwit> http://muitovar.com/gtk2hs/index.html
04:48:40 <phka> dmwit, donri: i see, that makes sense, thinking about it now. thanks :)
04:48:55 <hari_> bookmarked
04:50:22 <hari_> I generally use Glade to design UI so I will also look at the glade bindings
04:50:43 <donri> phka: ST can be useful if say, you have some expensive operation for computing a one-off structure that isn't commonly updated later
05:04:18 * hackagebot multext-east-msd 0.1.0.4 - MULTEXT-East morphosyntactic descriptors  http://hackage.haskell.org/package/multext-east-msd-0.1.0.4 (JanSnajder)
05:04:22 <_oio_> are there alternative to case of ?
05:05:08 <kranius> guards ?
05:05:29 <donri> _oio_: let/where/top-level bindings
05:06:49 <merijn> _oio_: What are you trying to do?
05:07:13 <_oio_> trying to
05:08:11 <_oio_> func = map xxx where xxx '1' = One
05:08:33 <_oio_> i dont like to have
05:08:47 <_oio_> xxx '2' = Two
05:08:58 <_oio_> xxx '3' = etc
05:09:05 <_oio_> write xxx everytime
05:09:28 <merijn> heh, HUnit is hosted on sourceforge?
05:09:31 <dmwit> xxx = \case '1' -> One; '2' -> Two
05:09:55 <dmwit> or even func = map (\case '1' -> One; '2' -> Two) -- =)
05:11:52 <ibotty> _oio_: and when you have an enum instance of your One, Two, etc. data type, you might pull some mathic (ehem...) to derive them automatically
05:12:30 <dmwit> Oh, good idea. xxx c = lookup c [('1', One), ('2', Two)]
05:13:08 <ibotty> it's getting worse, right?
05:13:09 <ibotty> :D
05:13:33 <ibotty> case is pretty clear, isn't it?
05:13:33 <merijn> That returns Maybe, though
05:14:00 <ibotty> fromMaybe (error "Told you not to")
05:14:13 <ibotty> or simply fromJust
05:14:15 <dmwit> merijn: I will be sad if _oio_ doesn't have enough programmer in him to deal with that.
05:14:17 <merijn> What testing framework do I want for tests are the binary level? (i.e. testing entire programs)
05:14:45 <_oio_> i just thought case of seem hacky
05:15:07 <_oio_> also iits syntax i dont like it
05:15:32 <dmwit> And you don't like \case better?
05:16:07 <_oio_> i was thinking multiways ?
05:17:37 <dmwit> I don't understand your last question.
05:19:31 <_oio_> are multiways useful for what i am trying to do _
05:19:52 <dmwit> I have no idea. What are multiways?
05:20:07 <srhb> Think multiway ifs is the question
05:20:34 <_oio_> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html
05:21:21 <dmwit> Multiway if does not do pattern matching.
05:21:26 <donri> using Eq for this is the hack, not pattern matching
05:21:44 <donri> what's wrong with case..of?
05:22:50 <Lethalman> donri, what's wrong with multiway :)
05:23:08 * Lethalman uses multiways often
05:23:19 <donri> Lethalman: not heralding layout for one
05:24:25 <dmwit> Nothing is wrong with multiway if. It's just a completely different use case.
05:24:30 <joachifm> _oio_: mapMaybe (flip lookup tbl) xs where tbl = [('1', One), ('2', Two),...] ?
05:24:35 <dmwit> case is for patterns; multiway if is for booleans.
05:25:08 <Lethalman> well, case _ of ...
05:25:16 <Lethalman> in fact, multiways if desugar to case iirc
05:25:54 <_oio_> ok thanks all
05:26:32 <_oio_> good answers
05:27:23 <merijn> No testing suggestions?
05:40:03 <mcstar> lol @ SPJ wearing the same sweater in the 2007 talk as back in the 1992 photo
05:40:23 <hiptobecubic> :)
05:41:48 <ijp> why not? I hope to still be wearing my favourite cardigan in 2020
05:44:06 * t7 wonders if SPJ gets really sick of functional programming
05:44:29 <zomg> he's probably secretly a PHP programmer at heart
05:45:40 <ibotty> spj prototypes ghc extensions in php to see whether they work out
05:47:04 <zomg> SPJ facts
05:47:27 <t7> where are the novelty twitter SPJ accounts?
05:47:41 <mauke> @quote OlegFacts
05:47:41 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
05:47:51 <mauke> @quote OlegFacts
05:47:52 <lambdabot> OlegFacts says: Oleg's latest project is re-writing Emacs... in the type system.
05:48:06 <zomg> haha :P
05:49:39 <zomg> The type system cannot represent Chuck Norris. The only thing Chuck Norris allows to represent himself are his fists
05:51:36 <merijn> mauke: You seem the type of person to appreciate the Schneier facts, if you didn't already know them :p
05:51:53 <merijn> http://www.schneierfacts.com/
05:52:11 <mauke> I did
05:54:40 <chrisdone> messing around a bit compiling from core to js http://lpaste.net/5332270355467730944 Google Closure always performs well
06:04:52 <mcstar> is that the guy from RSA?
06:05:51 <mcstar> nope, thats shamir
06:06:19 <dmwit> Right, Schneier is not the S in RSA.
06:06:29 <mcstar> also, i have an article in one of my open tabs on security written by the same schneier, i recognize now him from the long haired photo
06:07:26 <mcstar> hm, it is probably in my other browser
06:10:10 <mcstar> omg, my chromium session is gone :(
06:13:05 <sj4nz> Argh, so annoying to see SPJ all the time. (I share the same initials, LOL)
06:20:55 <Zenol> What is a prism?
06:21:14 <donri> Zenol: (a -> b, b -> Maybe a)
06:21:30 <companion_cube> looks like an injection
06:22:04 <mauke> like a lens for enums
06:22:55 <Zenol> like a lens for enums?
06:23:13 <Zenol> have you an example?
06:23:19 <haasn> _Left
06:23:45 <donri> (Left, safeFromLeft)
06:23:59 <haasn> _Left :: Prism (Either a x) (Either b x) a b
06:24:34 <mauke> lenses are for tuples/records
06:24:48 <mauke> prisms are for variants
06:25:17 <haasn> lenses are to record fields as prisms are to constructors
06:25:56 <Eduard_Munteanu> Are type-level nats supported in any GHC release yet?
06:26:11 <donri> Zenol: you can always put a value in Left (that's a -> b) and you can maybe lift out the value of Left in an either (that's b -> Maybe a)
06:26:34 <Eduard_Munteanu> I'm on 7.4.2, I don't see any extension with that name.
06:26:44 <Zenol> donri: Ok, thanks :)
06:26:58 <Zenol> And how should I rea the _Left type signature?
06:27:01 <Zenol> *read
06:27:34 <Zenol> Eduard_Munteanu: 7.4 is old.
06:28:20 <Zenol> Eduard_Munteanu: http://ghc.haskell.org/trac/ghc/ticket/4385 ?
06:28:29 <haasn> Eduard_Munteanu: 7.6 has them
06:28:34 <haasn> but they aren't very well ‘supported’
06:28:50 <Eduard_Munteanu> Thanks.
06:28:52 <haasn> there's no inductive type family you can use to pattern match on them, for example
06:29:00 <donri> Zenol: Prism' (Either a b) a
06:29:01 <Eduard_Munteanu> Hm.
06:29:33 <haasn> this changes in 7.7 and 7.8 (which I haven't seen the patch notes for yet)
06:30:19 <donri> Zenol: the rest is just noise to let you change the types. like, over _Left show :: Show a => Either a b -> Either String b
06:31:26 <danilo2> Hello :) Does anybody know how can I read the current position (line and column) in Parsec?
06:31:40 <Eduard_Munteanu> Actually I just want types dependent on an enumeration.
06:32:14 <Eduard_Munteanu> Do I get that without type-level nats?
06:34:52 <ollehar> hello! installed idris with cabal, but still get "command not found". is there an init function of some kind that should be run?
06:35:18 <ibotty> do you have your cabal bin dir in your path?
06:35:25 <danilo2> Ah I found it! (the postion getter in Parsec) - sorry for such straightforwar d question :)
06:35:47 <ibotty> (i assume you are on unix):
06:35:47 <ibotty> export PATH=$PATH:~/.cabal/bin
06:35:52 <apfelbox> how do I import a data constructor?
06:35:59 <apfelbox> data T = T Int
06:36:10 <apfelbox> import Test.T (T) seems to only import the type?
06:36:27 <ibotty> import Test.T (T(..))
06:36:31 <ollehar> ibotty: yeah, that did it, thanks!
06:37:02 <donri> or T(T) to be fully explicit
06:37:04 <apfelbox> Does that import both the type with all constructors?
06:37:11 <donri> yes
06:37:30 <apfelbox> Ah, so the syntax is T(list of constructors) or ".." for all?
06:37:36 <donri> yes
06:37:39 <apfelbox> Nice, thansk!
06:37:42 <apfelbox> thanks*
06:37:51 <donri> same for classes and its methods
06:41:42 <deech> Hi all I have a some C++ bindings I'm bundling with a Haskell project. In the setup process I compile them in to a static library and then build the Haskell wrappers. I would like the resulting static library to include the bindings library without having to publish it. Is there a way of doing this?
06:43:34 <merijn> deech: Sure, just build your library for all platforms you want to support and ship the binary...
06:44:10 <deech> merijn: By the binary do you mean just the Haskell wrappers?
06:44:34 <edwardk> haasn: my formulas for plucker could be either a.) wrong or b.) using a change of basis to study coordinates. i don't remember which. I happened to just rattle them off there from memory, but i can't say i tested it
06:45:09 <merijn> deech: I meant the C++ binary, you might be able to distribute the haskell library, anyway it'll be a bit of a hassle and you'll have to build it for a ton of different system configurations
06:45:24 <haasn> edwardk: well, have a look at http://hub.darcs.net/nand/ray/browse/Ray3D.hs  <- using the definitions of ‘plucker‘ and (><) at the bottom of this file generates pretty output, but switching to yours makes it all blank
06:47:16 <edwardk> haasn: iirc, acowley found a similar issue. i think there is a branch of linear with them switched
06:47:58 <edwardk> yes, mine appear likely to be wrong
06:48:22 <haasn> you must have implemented it after a good night's sleep
06:48:26 <carp> Hi, let me know a good time to have a little noob questions session
06:48:30 <edwardk> haasn: feel free to update the linear package with the version of the bilinear form that works ;)
06:48:45 <merijn> carp: Just ask whenever
06:48:45 <edwardk> that'd let you shorten your raytracer way down ;)
06:49:06 <ocharles> haasn == nand?
06:49:09 <haasn> heh, ok; It's hardly a ray tracer though :)
06:49:18 <haasn> nothing fancy yet
06:49:35 <mcstar> `nand` iirc
06:49:38 <ocharles> were you previously known as nand here?
06:49:42 <haasn> ocharles: what mcstar said
06:49:44 <ocharles> oh!
06:50:02 <mcstar> im surprised too :)
06:50:45 <carp> Im going through the Learn you a haskell tutorial, Ive found an example to be too big a step for me in one go...
06:50:47 <carp>     calcBmis :: (RealFloat a) => [(a, a)] -> [a]       calcBmis xs = [bmi w h | (w, h) <- xs]           where bmi weight height = weight / height ^ 2
06:50:48 <merijn> Annoying people that keep switching nicks :p
06:51:06 <merijn> carp: Might want to use lpaste.net for multiline things
06:51:14 <haasn> merijn: shachaf kept complaining about the `. I won't do it again, I swear :(
06:51:14 <beaky> hello
06:51:33 <edwardk> ocharles: he gave himself away with his instant lens expertise a while ago ;)
06:51:53 <carp> http://lpaste.net/92321
06:52:00 <beaky> does Data.Vector make a copy of itself everytime you change a field?
06:52:01 <dmwit> For once it's right to blame shachaf.
06:52:06 <ocharles> edwardk: well that's what confused me
06:52:15 <ocharles> "who is this smart haasn guy?!"
06:52:18 <dmwit> beaky: All immutable data structures behave that way.
06:52:23 <beaky> ah
06:52:28 <merijn> carp: ok, so where do you lose the thread of what's going on?
06:52:35 <beaky> so it's okay to do it that way?
06:52:43 <beaky> or are copies like that bad
06:52:53 <dmwit> At the moment, your question is not objective enough to answer.
06:53:05 <beaky> ah so it depends on context?
06:53:32 <dmwit> Where's monochrom when you need him?
06:53:36 <dmwit> The answer depends on the question.
06:53:41 <haasn> carp: you can understand line 3 in isolation from line 2
06:54:11 <beaky> since I read somewhere that purely functional data structures like lists and trees use a sharing structure such that an update will retain the original structure (without copying it gain)
06:54:15 <beaky> again*
06:54:22 <beaky> i wonder if arrays are same
06:54:54 <dmwit> In GHC, "copy" almost always means "pointer copy", yes.
06:55:10 <beaky> ah i love pointer copy
06:55:18 <beaky> it is very efficient
06:55:21 <dmwit> Copying an array will copy one pointer per element of the array.
06:55:29 <beaky> ah that is inefficient :(
06:55:32 <carp> so i think bmi is the name of a function, and wieght and height are its parameters.
06:55:43 <dmwit> Well, that's not precise.
06:55:44 <t7> chrisdone: from scratch?
06:55:46 <merijn> carp: Correct
06:55:54 <srhb> dmwit: How does that work if it's unboxed?
06:55:57 <merijn> carp: "where" introduces a local function declaration
06:56:03 <srhb> dmwit: Or does that have nothing to do with it?
06:56:06 <dmwit> Copying an array copies one pointer. Creating a new array that differs from the old one copies one pointer per identical element.
06:56:18 <beaky> ah
06:56:20 <beaky> that is good
06:56:33 <dmwit> srhb: Unboxing does indeed change things a lot.
06:56:41 * srhb nods
06:57:16 <srhb> Seems to me boxed arrays are more rarely used than unboxed arrays or some more functional structure.
06:57:30 <dmwit> Okay, that's a fair point.
06:57:56 <srhb> Impressive, I'm mostly talking out my arse because I'm interested.
06:58:03 <edwardk> beaky: arrays generally lack that property. but there are structures that are more array-like that get you bigger regions of contiguous memory while trying to manage the cost of updates, etc.
06:58:24 <haasn> edwardk: is the secret to optimization just slapping {-# INLINE #-} on every single function? That's all I see in your libraries :P
06:58:37 <edwardk> haasn: there is a bit more thought to put into it than that.
06:58:48 <beaky> so arrays are not very good as functional data structures?
06:58:52 <edwardk> but its a reasonable first order approximation to the strategy ;)
06:59:01 <srhb> beaky: I think that's very hard to make a general statement about.
06:59:13 <srhb> beaky: Since data structure talks is so use-case dependent.
06:59:18 <beaky> ah right
06:59:29 <beaky> I want to write tetris in haskell
06:59:31 * hackagebot matchers 0.10.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.10.0.0 (OmariNorman)
06:59:45 <srhb> beaky: Coordinates? Map! :P
06:59:57 <srhb> At least that's my goto.
07:00:06 <edwardk> srhb: in general arrays get little use in haskell because thy come at the cost of a complete rewrite for any edits. this can be mitigated if you tend to build something up all at once, with something like accumArray, then consume it though
07:00:17 <srhb> edwardk: aye, thanks.
07:00:18 <carp> on line 2, bmi is called. it asks for 2 parameters: w and h
07:00:26 <merijn> carp: yup
07:01:00 <merijn> carp: Are you familiar with list comprehensions? I guess the notation for that may be confusing you?
07:01:19 <edwardk> vector gets used as it makes a 'better array' that can avoid constructing many of the intermediate results. the rewrite rules it uses can go through and make it so that if you zip u several of them and take 30 on one, concatenate a bunch of others, that all of that may be able to be done without making any temporary vectors at all
07:01:22 <carp> the vertical line is called a pipe symbol? it represents the start of a guard which is basically an if statement
07:01:40 <merijn> carp: Do you happen to know python?
07:01:52 <srhb> carp: It's often pronounced "for which it is true that"
07:01:57 <srhb> carp: Or something similar
07:02:01 <edwardk> srhb: i'm currently concocting a 'cache oblivious lookahead array' which is basically Data.Map built out of vectors in a tricksy arrangement that gives you B-Tree asymptotics
07:02:14 <merijn> srhb: I usually pronounce it "with"
07:02:15 <beaky> ok i will use Data.Map
07:02:19 <srhb> edwardk: That sounds very interesting.
07:02:21 <edwardk> srhb: so not everyone has given up on arrays in haskell =)
07:02:29 <mroman> @undo do { foo; bar; }
07:02:30 <lambdabot> foo >> bar
07:02:32 <srhb> edwardk: Oh, I definitely didn't mean to imply that. :D
07:02:40 <mroman> ic
07:02:48 <edwardk> srhb: github.com/ekmett/structures has it in there, but its far from working. i just started the project the other day
07:02:52 <srhb> edwardk: And I have high hopes in the vague "Fortran-killer" direction.
07:03:04 <srhb> I'll have a look.
07:03:24 <edwardk> srhb: mainland's stuff for working with SIMD primitives goes a long way in that direction
07:03:54 <edwardk> with 7.8 i'm hoping to get a huge speed boost to the kind of low level systems code i used to love to write but haven't been able to think about since coming to haskell
07:04:16 <carp> i am not familiar with list comprehensions particularly. i have been learning python for 8 months but im very nooby at it.
07:04:31 * hackagebot multiarg 0.20.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.20.0.0 (OmariNorman)
07:04:39 <srhb> edwardk: I guess it's great that you can write stuff like that - I've looked at some of your optimizations discussion on School of Haskell.
07:04:50 <beaky> there's a haskell school?
07:05:04 <srhb> @where school of haskell
07:05:04 <lambdabot> I know nothing about school.
07:05:07 <merijn> carp: Do you understand this python code? [bmi(w,h) for (w,h) in xs]
07:05:11 <srhb> https://www.fpcomplete.com/school/
07:05:14 <beaky> wow
07:05:19 <carp> nope
07:05:21 <edwardk> beaky: fpcomplete.com/user/edwardk
07:05:31 <edwardk> beaky: there are other accounts on there with more content though =)
07:06:03 <beaky> yes there was one explaining comonads and comonoids
07:06:03 <haasn> edwardk: http://bpaste.net/show/127747/
07:06:05 <merijn> carp: Aw, to bad. Ok so "[x | x <- xs]" says "Create a list of every element in xs"
07:06:09 <srhb> edwardk: It also scares me a bit because it's "taking Haskell in a direction" that looks frighteningly like C. :-)
07:06:16 <edwardk> beaky: the nice thing about it is users can run the haskell snippets on the site: https://www.fpcomplete.com/user/edwardk/cellular-automata try clicking run on the last couple of code examples
07:06:18 <mcstar> [bmi(*wh) for wh in xs]
07:06:23 <srhb> (Which I can't write, hence the scariness)
07:06:41 <dmwit> ?where report
07:06:41 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:06:45 <edwardk> srhb: well, my way of thinking about it is we start with the hideous, but if you look at, say, part 6 of my matrix multiplication post i've abstracted all the bit twiddling away
07:06:49 <valyagolev> what are the interesting code-generating DSLs based on Haskell? I want to take a look
07:06:53 <merijn> carp: Now, "[f x | x <- xs]" says "Create a list of every element in xs with f applied to it" (i.e. it's "map f")
07:07:03 <srhb> edwardk: I haven't gotten that far in the series yet, that's very comforting.
07:07:03 <edwardk> srhb: similarly the COLA itself looks like 'Map k v' when presented to an end user =P
07:07:06 <carp> [x | x <- xs]  this is already too hard for me, oh dear
07:07:11 <srhb> Oh happy day!
07:07:16 <dmwit> carp: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
07:07:36 <edwardk> srhb: its just a Map k v with different constraints on k and v than Data.Map, because it needs to know how to make a vector out of them
07:07:38 <srhb> carp: construct a list of x with every x is drawn from the list xs]
07:08:03 <edwardk> so you wind up with insert :: (Ord k, Arrayed k, Arrayed v) => k -> v -> Map k v -> Map k v
07:08:13 <srhb> edwardk: What constraints are necessary there that aren't necesary on Map? Is it the boxed/unboxed idea again?
07:08:14 <carp> the tutorials seemed to have skipped the part where they explain what ->  means. and other symbols
07:08:19 <edwardk> which basically says we can COLA things we can make a vector out of
07:08:21 <haasn> carp: do you understand this?  map (\x -> 2*x) xs
07:08:22 <srhb> Arrayed sounds weird.
07:08:31 <carp> i dont haasn
07:08:54 <dmwit> carp: "\x -> e" is a function which takes x as an argument and evaluates to e. Similar to "let f x = e in f", but without the "f".
07:08:56 <mcstar> lets start with [1,2,3] is a list of 3 elements
07:09:06 <edwardk> if you have an unboxed vector type for your data you can use instance Arrayed YourType; if you don't, then use instance Arrayed YourType where type Arr YourType = Data.Vector.Vector
07:09:16 <srhb> Aye.
07:09:19 <edwardk> srhb: i needed Array, Arr and a third related name ;)
07:09:26 <edwardk> it used to be Vectored
07:09:32 * hackagebot prednote 0.16.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.16.0.0 (OmariNorman)
07:09:33 <srhb> Arraying was taken? :-(
07:09:36 <edwardk> but that made Array needlessly collide
07:09:36 * srhb is kidding
07:09:42 <ocharles> IArrayable, duh
07:09:49 <edwardk> ocharles: =P
07:09:57 <edwardk> Arrayified
07:09:59 <srhb> Haha
07:10:24 <edwardk> srhb: basically the cola uses data.vector to do all of its heavy lifting
07:10:30 <srhb> Right.
07:10:56 <edwardk> i have a cheap 'indexed dictionary' that is a bit vector that supports efficient 'rank': counting the number of True bits up to a given point
07:11:32 <edwardk> that guy lets me then implement the COLA itself as newtype Map k v = Map (Array k) BitVector (Array v) (Map k v) | Nil
07:11:54 <edwardk> which means it is a linked list of arrays, subject to some normalization criterion, and using the bitvector in a funny way
07:12:30 <edwardk> the bitvector is the same length as the array of keys, and when the bit vector is true the key isn't in this map, but is just logically a "forwarding pointer".
07:12:41 <danharaj> Cale: boop
07:12:58 <dmwit> carp: Are you on board with anonymous functions (re: what "->" means) now or do you need more explanation? If you need more, people are happy to give it. But you have to ask for it.
07:13:02 <edwardk> that means it has no associated 'a' value
07:13:03 <srhb> Sorry, you lost me. How can the BitVector be of the same length as the array of keys if it contains more than binary information for each key?
07:13:12 <srhb> Or did I misunderstand its purpose?
07:13:34 <edwardk> data BitVector = BitVector !Int (Array Bit) (U.Vector Word64)
07:13:40 <srhb> Oh.
07:13:52 <edwardk> its an array of bits, packed as Word64s and it carries an extra U.Vector of the prefix sums up to each word
07:14:00 <srhb> Aye, okay.
07:14:06 <edwardk> logically it is represented by the information in the Array of Bits
07:14:12 <Zenol> donri: Thanks
07:14:15 <edwardk> but it has the supplemental data to make calculating rank O(1)
07:14:17 <carp> i think -> means evaluates to?
07:14:25 <dmwit> carp: not quite
07:14:36 <dmwit> carp: Are you comfortable with the definition "f x = x*2"?
07:14:53 <carp> whats the f for?
07:15:03 <danharaj> it's a name
07:15:04 <carp> do something to x
07:15:05 <dmwit> carp: We're defining a function named "f". It doubles its argument.
07:15:18 <applicative> double x = x * 2
07:15:27 <edwardk> so what we can do is search our outer array, but when we go to access the values, what we need to do is take the rank from our bitvector and subtract it off from the index into the vector of values
07:15:34 <applicative> > let double x = x * 2 in double (double (double 2))
07:15:41 <edwardk> hat way we don't bother to store values for forwarding pointers
07:15:42 <lambdabot>   mueval-core: Time limit exceeded
07:15:49 <edwardk> and our overhead is just 2n+o(n) bits per entry
07:15:52 <srhb> edwardk: Clever trick.
07:16:10 <applicative> > let double x = x * 2 in double (double (double 2))
07:16:13 <lambdabot>   16
07:16:16 <edwardk> srhb: thanks thats one of my variations on the original design. its also one of the things that makes wavelet trees go =)
07:16:38 <srhb> edwardk: *brain explodes*
07:16:40 <edwardk> the rank structure i use is simpler than an optimal one, but its 'good enough' i think
07:16:44 <danharaj> edwardk: have you considered writing a followup to okasaki's book ;)
07:17:06 <edwardk> danharaj: i'd want jim apple to do it, he's better at most of these than i am
07:17:13 <danharaj> really?
07:17:16 <danharaj> will he be at icfp?
07:17:19 <danharaj> can I steal his brain?
07:17:22 <edwardk> dunno
07:17:41 <dmwit> The modern zombie makes its first appearance.
07:17:42 <edwardk> he's mostly concerned with the actual 'made out of ADTs' side of data structures
07:18:04 <applicative> wavelet trees? hm...
07:18:17 <edwardk> i care more about can i make it cache oblivious, lock-free/wait-free, succinct, etc.
07:18:31 <carp> f x = x*2            so the function is called f, the parameter is x and what the function does is double x. yep i got it
07:18:35 <edwardk> those properties together to me represent the 'right' way to think about data as we add more cores
07:18:37 <srhb> carp: Right.
07:18:48 <danharaj> edwardk: well those are hella important and okasaki doesn't cover them
07:19:06 <danharaj> we need a high powered functional data structures reference that covers all the modern structures we have discovered and also how to make them blazing fast and concurrent.
07:19:10 <dmwit> carp: Cool. Now, suppose we wanted to use this function, but didn't want to name it?
07:19:34 <edwardk> cache-oblivious makes it easy to move to new architectures, lock-free/wait-free makes it easy to scale and let you deal with contention, succinct takes the space usage down to 'just above entropy' and as Knuth once stated, in offline storage space usage is close to time usage.
07:19:53 <edwardk> danharaj: well right now, i'm focused on making them fast and concurrent ;)
07:19:55 <Zenol> what is a Getter ?
07:19:55 <dmwit> carp: The way we can do that is with an alternative syntax for functions: we introduce them with "\" (which is supposed to look like a Greek letter lambda, for historical reasons) and separate the arguments from the function body with "->".
07:19:59 <edwardk> then i'll figure out the pedagogy ;)
07:20:18 <dmwit> carp: So, we could write "f = \x -> x*2" if we wanted to keep the name or we could just write "\x -> x*2" wherever we wrote f before.
07:20:20 * Zenol is in it's "what is" day.
07:20:23 <edwardk> Zenol: a getter is a cps'd function put into a form suitable using with the lens combinators
07:20:29 <edwardk> > "hello"^.to length
07:20:37 <lambdabot>   mueval-core: Time limit exceeded
07:20:38 <edwardk> to takes a function and makes it a getter
07:20:40 <edwardk> > "hello"^.to length
07:20:42 <dmwit> carp: For example, compare the next two code snippets that I send to lambdabot.
07:20:44 <lambdabot>   5
07:20:53 <dmwit> > let f x = x*2 in f 7
07:20:57 <danharaj> edwardk: forget pedagogy, I want a brain dump ;)
07:21:09 <applicative> carp, "\x -> x * 2" can be read: the function that takes x and multiplies it by two
07:21:10 <edwardk> danharaj: thats why i'm writing the matrix multiplication series
07:21:10 <dmwit> > (\x -> x*2) 7
07:21:18 <lambdabot>   14
07:21:18 <lambdabot>   can't find file: L.hs
07:21:20 <danharaj> edwardk: waiting for the next installment!
07:21:25 <edwardk> danharaj: i figure its forcing me to get some of this out of my head and code fragments and into outer people's
07:21:37 <edwardk> danharaj: yeah i'm waiting for some benchmark work from carter ;)
07:21:42 <dmwit> carp: Now I encourage you to complain about the first word I wrote that you didn't understand.
07:21:43 <Zenol> edwardk: Oh, so to create a Getter (CPS) from a simple s -> a function ?
07:21:50 <edwardk> Zenol: yeah
07:21:57 <Zenol> edwardk: Ok, thanks :)
07:22:11 <edwardk> to f = \ g -> coerce . g . f
07:22:18 <haasn> edwardk: oh, btw; do you want me to create pull requests for the patches I've sent you over the past few days? I'd have to figure out how to use github again
07:22:25 <haasn> or can you just apply them locally
07:22:29 <edwardk> haasn: yes
07:22:29 <edwardk> without a PR i never notice
07:24:34 <carp> ok i follow that part.
07:25:16 <dmwit> carp: Okay, does this mean you also understand how
07:25:19 <haasn> edwardk: sent
07:25:22 <dmwit> > map (\x -> x*2) [1,2,3,4,5]
07:25:23 <edwardk> danharaj: i'll likely push out the next installment this weekend. i'm trying to figure out if i can get the COLA thing working first, because i'm trying to work about an installment and a half ahead of what i've written
07:25:24 <lambdabot>   [2,4,6,8,10]
07:25:25 <dmwit> works?
07:25:46 <edwardk> that way i have enough of an idea of what i'm saying that i don't jump around as much as i did at the start
07:25:49 <haasn> now I just have to figure out how to delete my lens fork
07:27:46 <carp> map is a function that takes two parameters, a rule and a list. it applies the rule to each element in the list.
07:27:47 <haasn> ah, it seems maybe I don't have to
07:27:54 <haasn> s/rule/function/
07:27:55 <srhb> haasn: Indeed, no need
07:28:17 <edwardk> haasn: don't delete it til the PRs go through =)
07:28:24 <haasn> srhb: doing it this way is just slow because now I have to upload a few megabytes worth of upstream lens changes to my own repository
07:28:35 <haasn> edwardk: I meant the old lens fork I still had lying around from a year ago, I wanted to delete and re-fork it so I'd be up to date
07:28:59 <haasn> hmm, the eta is a few minutes
07:29:00 <haasn> that's not good
07:29:01 <haasn> isn't there a faster way to do this?
07:29:54 <applicative> carp, map takes a rule/function from as to bs and turns it into a rule/function from lists of as to lists of bs -- to put it another way...
07:30:02 <haasn> I guess I could do it from a different PC, if I add the SSH key
07:30:18 <edwardk> haasn: you know you can just 'git pull origin master' right ? =)
07:30:31 <dmwit> carp: Okay. If you are still confused about something, it may be time for you to say where you want help next. =)
07:31:03 <haasn> edwardk: I ran ‘git pull https://github.com/ekmett/lens.git’ which I guess is the same thing
07:31:10 <carp> thankyou for all the help so far. so if i go back to this little snippet: http://lpaste.net/92322
07:31:40 <danilo2> Is there any nice and easy method to apply each function from a list to a variable? I mean something like a -> [a->a] -> a  ?
07:31:52 <dmwit> err... no lambdas in that snippet.
07:31:58 <srhb> danilo2: map ($) ?
07:32:03 <carp> calcBmis is a function with a single parameter called xs
07:32:05 <srhb> er...
07:32:06 <dmwit> danilo2: foldr (.) id ?
07:32:23 <ziman> :t flip (foldr (.) id)
07:32:26 <lambdabot> c -> [c -> c] -> c
07:32:44 <danilo2> srhb, dmwit, ziman: heh - I've got to be tired - of course :) thank oyu :)
07:33:05 <dmwit> :t sequence `asAppliedTo` [id]
07:33:06 <lambdabot> [a -> a] -> a -> [a]
07:33:14 <srhb> I did mean something like foldr ($) of course.. :<
07:33:29 <danilo2> shrb: I know :D
07:33:37 <dmwit> srhb: sequence is cooler
07:33:41 <srhb> It is
07:33:43 <srhb> And makes more sense.
07:33:44 <srhb> :P
07:33:52 <carp> calcBmis is a function with a single parameter called xs        (correct?)
07:34:02 <dmwit> carp: right!
07:34:02 <srhb> carp: Yes
07:35:27 <carp> calcBmis then calls a function called bmi which has 2 parameters, w and h     (correct?)
07:35:37 <dmwit> maybe =)
07:35:57 <carp> cus of lazy evaluation
07:36:02 <dmwit> It definitely defines such a function. Whether it's called or not depends on whether there are any elements in xs.
07:36:07 <mcstar> no, it contains a list comprehension, which calls bmi on each element of the list
07:36:46 <dmwit> I wasn't really going to harp on the laziness thing. Even if the result of calcBmis is fully forced, bmi may never get called.
07:37:03 <danilo2> dmwit: I'm trying to figure out how to replace "foldr ($)" by "sequence"? What is asAppliedTo?
07:37:05 <srhb> carp: map foo xs is pretty much [foo x | x <- xs] -- does that help?
07:37:18 <dmwit> danilo2: sequence does something different
07:37:37 <dmwit> danilo2: It's not a replacement for foldr (.), but for srhb's not-quite-right map ($).
07:37:46 <haasn> edwardk: there; uploaded the patches from my server - that was much faster :)
07:37:50 <srhb> I did mean map ($val) xs
07:37:54 <srhb> :<
07:37:56 <carp> ok, my language is incorrect, i should have used the word 'defines'rather than calls.
07:38:19 <haasn> srhb: xs ?? val
07:38:21 <danilo2> dmwit - ah ok :)
07:38:26 <srhb> :t (??)
07:38:30 <srhb> Wat.
07:38:44 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:38:44 <carp> i dont follow that yet srhb
07:39:10 <mcstar> thats not for you, i think
07:39:15 <srhb> carp: Is this just list comprehension syntax confusing you?
07:40:33 <carp> well, i think the tutorials skipped the part where <- and -> and => and other stuff was explained. But i am a nooby programmer, where as the tutorials are for people with more experience in another language i thnk
07:40:36 <srhb> carp: [x*2 | x <- [1,2,3]] = [2,4,6]. So the left hand side of | tells us what each value in the resulting list will be (twice of x) and the right hand side tells us where we get our x'es from, in this case the list [1,2,3]
07:40:41 <carp> i tried to fight through it but its hard for me haha
07:41:11 <srhb> carp: Double x for each x in the list [1,2,3]
07:41:36 <srhb> carp: I guess you can read <- as "drawn from"
07:42:02 <mcstar> thats how i look at that
07:42:08 <mcstar> but ofc, draw from in order
07:42:12 <srhb> Ah, yes.
07:42:18 <srhb> carp: Does that make sense?
07:42:28 <haasn> I read ‘<-’ as ‘taken from’ personally
07:42:39 <srhb> Same same but different. :-)
07:42:44 <applicative> <- can be read as ∊ if you like
07:43:03 <carp> ah brilliant yes.
07:43:04 <srhb> That has set connotations and makes the ordering bit worse, I think.
07:43:11 <srhb> carp: Good! So now do you understand your snippet?
07:43:35 <srhb> But I guess "drawn from" sounds like combinatorics, which is bad too.
07:43:39 <mcstar> > [ x | x <- x:[]]
07:43:41 <lambdabot>   [x]
07:43:43 <carp> well its funny cus it was in a section where he is explaining guards. and the | refers to basically an if statement
07:43:53 <srhb> carp: Uh, that does make it confusing
07:43:59 <srhb> carp: Those are different |s
07:44:05 <srhb> carp: Which tutorial is this?
07:44:08 <valyagolev> srhb since x <- xs, y <- ys in combinatorical, I think it makes sense
07:44:11 <carp> learn u a haskell
07:44:18 <carp> http://learnyouahaskell.com/syntax-in-functions
07:44:25 <valyagolev> shrb *is
07:44:55 <srhb> carp: | in guards and | in list comprehensions are not the same
07:45:00 <JordiGH> Is it safe to think of "global" variables as functions that take no arguments?
07:45:13 <valyagolev> JordiGH for which purposes?
07:45:15 <mroman> No.
07:45:16 <srhb> JordiGH: global what?
07:45:28 <mroman> Unless you mean "constants".
07:45:31 <JordiGH> If I just put "foo = 2" in some file.
07:45:46 <srhb> JordiGH: Why would you think of it as a function? It's clearly a non-function value
07:45:47 <dmwit> There are people that will complain about thinking of them that way.
07:45:49 <dmwit> I am not one of them.
07:45:52 <dmwit> But there are some.
07:45:52 <srhb> JordiGH: There's no (->) in its type
07:45:52 <mcstar> it's safe to think of it as a CAF
07:46:00 <danharaj> CAF is an operational detail
07:46:03 <srhb> dmwit: What does it gain you though?
07:46:10 <JordiGH> I don't know, I guess this question doesn't really make sense. I'm just kinda being duped by the syntax for function and variable definition being pretty much the same.
07:46:13 <dmwit> It gains you not having a special case for 0.
07:46:21 <srhb> JordiGH: Tends to not bother folks in math. :-)
07:46:22 <dmwit> Which as a computer scientist you should embrace whole-heartedly.
07:46:27 <danharaj> (well no, but I hardly ever see it used outside of describing GHC's workings)
07:46:44 <valyagolev> JordiGH there's no variables, these all are constants
07:46:47 <mroman> JordiGH: Don't bother about that
07:46:54 <mroman> think of them as constants
07:46:57 <JordiGH> valyagolev: yeah, constants.
07:47:06 <JordiGH> But pure functions are also "constants".
07:47:07 <mauke> a b = c is syntactic sugar for a = \b -> c
07:47:14 <valyagolev> they are
07:47:28 <danharaj> a variable is just a name
07:47:32 <dmwit> srhb: Technically, functions in Haskell take exactly one argument. Period. Practically, if somebody says "function of two arguments" nobody has trouble understanding what they mean. Why should you get confused when they say "function of zero arguments" instead?
07:47:52 <dmwit> mauke: well...
07:47:57 <mauke> dmwit: because then it's no longer useful
07:47:59 <valyagolev> mauke doesn't it have some (implementation-detail-y) difference?
07:48:05 <srhb> dmwit: I'm not sure what you're getting at. One is convenient and almost true, the other is irrelevant and a lie?
07:48:11 <mauke> valyagolev: yes, the monomorphism restrictions and more complex patterns
07:48:16 <mroman> JordiGH: Is f(x) = x + 1 a constant function?
07:48:20 <dmwit> A lie? No, no lie.
07:48:37 <srhb> dmwit: How is foo = 2 a function?
07:48:37 <carp> thankyou for all the help so far. so if i go back to this little snippet: http://lpaste.net/92322
07:48:37 <mauke> dmwit: a function of two arguments takes at least 2 arguments
07:48:45 <srhb> carp: Yes, what?
07:48:56 <mauke> dmwit: a function of 0 arguments would take at least 0 arguments, i.e. it's a random value
07:49:10 <mcstar> random?
07:49:11 <mauke> it no longer distinguishes between anything
07:49:17 <mauke> arbitrary
07:49:23 <valyagolev> if you think about what arity is, arity = 0 makes sense
07:49:29 <applicative> functions dont take arguments at all in haskell; application takes two arguments though. ;)
07:49:29 <dmwit> srhb: I define "function of n arguments" by induction: a function of (n+1) arguments has an arrow from something to a function of (n) arguments. What should the base case be? Why?
07:49:42 <shachaf> As further evidence, I submit that an IRC channel of 0 arguments has yet to be discovered.
07:49:43 <valyagolev> e.g. one can say "a value dependent on no other values"
07:49:49 <srhb> shachaf: ++
07:50:06 <srhb> dmwit: Induction is a lie! :O
07:50:06 <valyagolev> applicative !!
07:50:16 <mcstar> go to a new channel anytime, and be by yourself, no argument there
07:50:23 <dmwit> mauke: 2 takes at least 0 arguments.
07:50:28 <Zenol> If I have to select to choose a function (b->c) from a lot's of them (~256 exactly). Is it better (more eficient) to pattern match on a, like dispatch a = dosomething or to lookup in something like [(a, b -> c)] ?
07:50:35 <valyagolev> or arity is a maximum number of applications the value can suffer
07:50:38 <dmwit> > 2 -- see, I applied 2 to 0 arguments here
07:50:39 <lambdabot>   2
07:50:51 <srhb> dmwit: I get what you're saying but I don't see it's smarter than saying there are function types with arrows, and there are non-function types that have no arrows.
07:51:05 <edwardk> @where pi10
07:51:05 <lambdabot> I know nothing about pi10.
07:51:07 <edwardk> @where pi11
07:51:07 <lambdabot> I know nothing about pi11.
07:51:09 <valyagolev> no, arity is a number n, such that you can do at least n applications
07:51:11 <edwardk> =(
07:51:21 <mcstar> dmwit: but what forced the evaluation of 2? you didnt call it with 0 argument, yet, ir was evaluated :S (j/k partly)
07:51:23 <mauke> dmwit: yes
07:51:24 <dmwit> srhb: Well, now *that* is a lie. I can write a type with no arrows that (can be instantiated as) a function. =)
07:51:40 <mauke> dmwit: but why say "function of 0 arguments" when you can say "value"?
07:51:47 <mcstar> you can pass an n-ary(/=0) function around wo evaluated
07:51:53 <dmwit> mauke: Not the question. The question is "why not say it"?
07:51:56 <mcstar> but you always evaluate a 0-ary function
07:52:08 <dmwit> mcstar: no
07:52:14 <mauke> dmwit: because it's not useful
07:52:27 <dmwit> "Can I think of it this way?" "yes"
07:52:38 <srhb> I get that we can start saying that everything is a function that is at least nullary, but I find it confusing and irrelevant.
07:52:48 <dmwit> That was the real top-level question. Apologies for mutating it into the "why not say it" form and changing its intent.
07:52:54 <shachaf> Why don't you practice some http://ncatlab.org/nlab/show/negative+thinking and tell us what a function of -1 arguments is.
07:53:13 <dmwit> That would be fun. =)
07:53:23 <dmwit> A thing that spontaneously emits values... =P
07:53:54 <shachaf> Sometimes it's better to say "don't" rather than "yes, if you really want to, but it'll confuse you, so you shouldn't".
07:53:58 <mcstar> a function of -1 argument is () because it was a function, f, that consumed itself, thereby resulting in ()
07:54:04 <shachaf> E.g. "can I think of a monad as a container?"
07:54:30 <srhb> shachaf: I'll submit to that.
07:54:31 <dmwit> I disagree.
07:54:38 <valyagolev>  if "addition" (on arities) of f and g is an operation which takes all arguments to a and all arguments to b and produces, hmm, maybe (foldr ($) a aargs, foldr ($) b bargs)
07:54:39 <applicative> yes, like most scholarly treatments do
07:54:40 <dmwit> I think thinking about things as many ways as you can is good for your soul.
07:55:33 <shachaf> Some ways of thinking about some things considered harmful some times.
07:55:42 <mcstar> hm, my definition of 'negative thinking' was a whole lot different from the link's, i have to revise mine
07:55:49 <dmwit> shachaf: =)
07:55:50 <edwardk> considered harmful considered harmful
07:55:51 <srhb> mcstar: :-)
07:55:56 <applicative> you don't seem to have an example yet shachaf
07:56:16 <srhb> There's a lot of "yes, but don't" in this channel already - I think because people realize on a lot of points that it's not very pedagogic.
07:56:36 <dmwit> humbug
07:56:42 <srhb> dmwit: :O
07:56:59 <dmwit> I like where I am with Haskell, and I got here through all those same "incorrect" ways of thinking.
07:57:04 <valyagolev> http://mathoverflow.net/questions/56077/positive-negative-arity
07:57:09 <dmwit> You can't appreciate why it's wrong until you live with it for a while.
07:57:18 <mcstar> fortunately, ghc doesnt care about how feeble human minds interpret things... it just does its magnificient job
07:57:35 <srhb> Being trapped in "a monad is like a burrito" was not productive for me. I still don't understand the metaphor.
07:57:38 <shachaf> valyagolev: It was a joke. :-(
07:57:51 <srhb> (Nor do I want to)
07:57:56 <valyagolev> so the function of -1 arity is apparently "\x -> _|_"
07:58:07 <valyagolev> if I understand what negation is
07:58:13 <carp> calcBmis is a function with xs as the single parameter. we know that xs has to be a tuple because later on line 2, xs 'is taken from' the tuple (w, h)       (correct?)
07:58:21 <srhb> carp: Correct
07:58:29 <mcstar> now thats not a nice function there ^
07:58:36 <srhb> carp: And because the type signature says so.
07:58:41 <carp> can calcBmis be given a list of tuples?
07:58:51 <srhb> carp: It must be, if you want to give it an argument
07:58:58 <srhb> carp: Anything else will be a type error.
07:59:20 <carp> u can give it a tuple or a list of tuples  ??
07:59:23 <mcstar> xs is never a tuple
07:59:23 <dmwit> carp: no
07:59:28 <srhb> carp: Moreover, it needs to be a list of tuples where each tuple element's type has an instance of RealFloat
07:59:32 <dmwit> carp: Your original claim (that xs has to be a tuple) is incorrect.
07:59:33 <mcstar> and xs is not taken from the tuple (w,h)
07:59:33 <srhb> Oh sorry
07:59:37 <srhb> I misready
07:59:57 <srhb> carp: xs MUST be a list of tuples.
08:00:06 <simon> hej srhb :)
08:00:11 <srhb> simon: Hej Simon.
08:00:24 <mcstar> 2-tuple, of the same type `a`
08:01:25 <mcstar> carp: also, do you understand type variables? what is `a` there?
08:01:38 <haasn> what's that programming challenge thing called that regularly gives out interesting puzzles? I can't think of how to describe it better
08:01:43 <haasn> but I remember it being all the rage in #haskell
08:01:55 <klugez> haasn: Project Euler?
08:01:56 <geekosaur> which one?
08:01:57 <carp> the list of tuples is represented in the type signature by [(a, a)]       (correct?)
08:01:57 <srhb> haasn: There are a lot of those. One is that new thing on github
08:01:57 <shachaf> It's called edwardk.
08:02:09 <srhb> carp: Yes
08:02:13 <haasn> nah none of those.. hmm
08:02:13 <dmwit> srhb: (...and in particular, I found thinking about how Reader and State were like containers -- and not like containers -- quite enlightening.)
08:02:19 <haasn> I think the last one was something about a game, like pushing blocks around?
08:02:25 <mcstar> carp: yes, but there are n-tuples, n>1
08:02:26 <haasn> or the one before that, at any rate
08:02:36 <srhb> dmwit: I will agree with that. But I think it's on a case-by-base basis.
08:02:42 <valyagolev> srhb what's the new thing on github?
08:02:59 <mcstar> carp: also, each 'part' of the tuple(position) can be of any type
08:03:02 <mcstar> in general
08:03:09 <srhb> valyagolev: Let me just dig through my history
08:03:41 <dmwit> haasn: The ICFP PC?
08:03:48 <geekosaur> haasn, with some twistingt hat might be icfp2012
08:03:59 <Ankhers> http://www.reddit.com/r/dailyprogrammer/ ?
08:04:02 <carp> i dont know how to explain this part          (Realfloat a)
08:04:03 <geekosaur> (pushing blocks around)
08:04:07 <kier> I'm looking for a package providing a cryptographically secure PRNG, does anyone have any suggestions?
08:04:17 <srhb> valyagolev: I think this is it: http://exercism.io/ -- I haven't checked it out yet!
08:04:22 <mcstar> carp: that is a typeclass constraint on the type variable `a`
08:04:30 <haasn> dmwit/geekosaur: yes! thanks
08:04:50 <mcstar> :t (/)
08:04:50 <lambdabot> Fractional a => a -> a -> a
08:04:53 <carp> does the =>  mean typeclass restraint ??
08:04:55 <srhb> carp: It means that a must have an instance of Realfloat, that is, implement the methods in the Realfloat type class.
08:04:57 <srhb> carp: Yes
08:05:00 <mcstar> :t (^)
08:05:00 <lambdabot> (Integral b, Num a) => a -> b -> a
08:05:01 <srhb> carp: Well, more or less.
08:05:08 <geekosaur> although it's RealFloat
08:05:24 <valyagolev> srhb hmm I think I've seen it, but I thought is' for learning langs, maybe they pivoted, or I've seen something really similar, with same PLs
08:05:40 <srhb> valyagolev: That may be. Have you seen reddit.com/r/dailyprogrammer ?
08:05:40 <mcstar> :t (\x y -> x / y ^ 2)
08:05:41 <lambdabot> Fractional a => a -> a -> a
08:05:49 <dmwit> ?src RealFloat
08:05:49 <lambdabot> Source not found. Where did you learn to type?
08:06:01 <dmwit> oh, it's a nasty big class
08:06:03 <mcstar> so, basically the RealFloat would be inferred instead as Fractional
08:06:41 <dmwit> It seems RealFloat implies Fractional. I suspect this is just a (minor) bug in the tutorial.
08:06:49 <applicative> kier: whats wrong with http://hackage.haskell.org/packages/archive/crypto-api/0.3.1/doc/html/Crypto-Random.html
08:07:07 <valyagolev> srhb not yet, thank you! I was doing project euler (111 problems) but not it's more of a dailypaper for me. also, matasano <3
08:07:17 <valyagolev> s/now/not/
08:07:25 <valyagolev> the other way round
08:07:57 <dmwit> s;w/not;t/now;
08:08:05 <mcstar> lol
08:08:09 <byorgey> augur: I don't know, I've never heard of anyone talk about curl for types
08:08:25 <byorgey> augur: but then again I don't even know what it means for real-valued functions.
08:08:36 <valyagolev> :)
08:08:41 <srhb> valyagolev: It's not automated at all, but sometimes i just feel like I need inspiration
08:09:07 <kier> applicative: aha thanks :)
08:09:21 <valyagolev> srhb after years of contests and everything I found bourbon is the best inspiration
08:09:41 * hackagebot multiarg 0.22.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.22.0.0 (OmariNorman)
08:09:43 * hackagebot ofx 0.4.0.0 - Parser for OFX data  http://hackage.haskell.org/package/ofx-0.4.0.0 (OmariNorman)
08:09:46 <srhb> valyagolev: Too expensive. :(
08:10:04 <carp> ok so,    line 1 reads        calcBmis is a function that takes a list of tuples of type a (and these must both be realfloats). it then evaluates to a list, also of type a
08:10:16 <srhb> carp: Bingo.
08:10:28 <mcstar> a list of type [a]
08:10:57 <beginning> hello! I'm running ghci , how do I define a local funciton and invoke it?
08:11:00 <srhb> Ugh, balancing precision with "yeah, you understood it" is hard. :<
08:11:06 <dmwit> srhb++
08:11:14 <mcstar> well, xs is the list and xs :: [a]
08:11:16 <srhb> beginning: let foo x = 2*x; foo 2
08:11:24 <srhb> beginning: ; being "next line"
08:11:25 <beginning> I tried: let x= x + 3  and then x 4 but it results in an error
08:11:26 <dmwit> mcstar: that's not precise
08:11:34 <beginning> ha i see
08:11:39 <beginning> i forgot to name the function!
08:11:46 <mcstar> dmwit: wo the typeclass
08:11:55 <srhb> beginning: you can do anonymous functions like so: (\x -> x*2) 2
08:11:59 <geekosaur> beginning:
08:12:01 <applicative> > let beginning x = x + 3 in beginning 4
08:12:01 <geekosaur> @where lyah
08:12:02 <lambdabot> http://www.learnyouahaskell.com/
08:12:02 <lambdabot>   7
08:12:11 <dmwit> mcstar: Still not precise. =P
08:12:12 <beginning> srhb: thanks a lot that worked :)
08:12:23 <valyagolev> srhb 50ml is actually more than enough for me sometimes. with 100$ for a 750ml bottle it's 6.66$ (oh man) for one dose of inspiration. man do I feel like a satan preacher now
08:12:28 <geekosaur> `let x = x + 3` does not do what you think! (in fact it will give you a massive headache...)
08:12:35 <dmwit> mcstar: (xs is the input list, and is a list of tuples...)
08:12:36 <applicative> beginning: if you don't want to name it you use a lambda ;)
08:12:37 <mcstar> dmwit: pls explain
08:12:44 <applicative> > (\x -> x + 3) 4
08:12:45 <lambdabot>   7
08:12:47 <mcstar> dmwit: ah right, not the output
08:12:52 <cschneid> hundred dollar bourbon?
08:12:54 <srhb> valyagolev: I'm a big fan of alcohol -> ideas, but bourbon.. There are cheaper ways. At least for a student. :-)
08:13:08 <cschneid> you live in the wrong places. 25 dollar bourbon is quite excellent.
08:13:14 <srhb> Yes.
08:13:28 <valyagolev> srhb I see:) I have a neighbouring bar where they sometimes treat me for free, on the worst days haha
08:13:47 <srhb> ... I need to move.
08:14:16 <valyagolev> cschneid how much does Old Fitzgerald cost in your place? here it's 66-80 usd
08:14:27 <mcstar> i hate that drinking alcohol is the only irl way for me to socialize
08:14:48 <dmwit> #-blah, maybe
08:14:56 <srhb> Sorry, my bad.
08:15:04 <cschneid> is that the off-topic channel?
08:15:07 <srhb> Yes.
08:15:24 <cschneid> well, sorry for cluttering things up here. Back to functions plz.
08:15:28 <carp> so in line 1 there are three  letter a's . Two in [(a, a)]  and one in [a]         All 3 of these have to be realfloats.    (correct?)
08:15:40 <valyagolev> I've posted some sciency link there
08:16:14 <srhb> carp: They are exactly the same type, yes
08:16:15 <dmwit> carp: Even better: they all get instantiated to the *same* type, no matter what.
08:16:22 <hoverbear> Hey all, is it true you can't remove packages with cabal?
08:16:43 <dmwit> carp: Or, a more snarky way of answering your question is: there are not three a's. =)
08:16:43 <srhb> carp: The type may be any type that implements RealFloat, though. The caller decides that.
08:16:50 <srhb> dmwit: *shakes fist*
08:17:04 <dmwit> srhb: Okay, I'll let you answer from now on. =)
08:17:17 <srhb> dmwit: It's fine. I just feel like I'm "doing it wrong!!!"
08:17:20 <srhb> I'll shut up instead :P
08:17:25 <dmwit> hoverbear: Hm. It is true that you can't remove packages with the executable named cabal.
08:17:27 <applicative> hoverbear: not the stuff in .cabal, you just do the obvious deletions
08:17:27 <mcstar> remember, that dmwit started to teach carp...
08:18:14 <dmwit> mcstar: uh
08:18:20 <hoverbear> dmwit: Just remove from .cabal/ ?
08:18:22 <dmwit> I mean, it's not like there's a monopoly on teaching.
08:18:26 <carp> thankyou all so much. i really needed to talk to sum1 after 4 weeks of just reading tutorials haha.
08:18:32 <mcstar> dmwit: :)
08:18:33 <dmwit> hoverbear: Removing things in ~/.cabal is a fool's errand.
08:18:36 <carp> line 1 i understand now hehe.
08:18:39 <srhb> carp: Glad we were helpful / confusing / etc.
08:18:41 <dmwit> hoverbear: You'll like poking around in ~/.ghc much more.
08:18:57 <carp> mind if i carry on asking noob questions?
08:18:59 <monochrom> hoverbear: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove . in fact, read the whole thing
08:19:05 <mcstar> dmwit: i thought it would somehow reflect on your pension
08:19:08 <srhb> carp: Please do.
08:19:09 <applicative> hoverbear: you can remove both .cabal and .ghc but that's unnecessarily radical
08:19:09 <dmwit> carp: Phew! Just two more lines to go. =)
08:19:41 * hackagebot tasty 0.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.3 (RomanCheplyaka)
08:19:43 * hackagebot tasty-quickcheck 0.3 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.3 (RomanCheplyaka)
08:20:09 <hoverbear> monochrom: Why is there no remove feature? It seems like it would be easy enough to implement.
08:20:24 <bennofs> there is:
08:20:25 <dmwit> Appearances can be deceiving.
08:20:25 <applicative> hoverbear: if you use cabal sandbox , you will have cabal sandbox delete
08:20:28 <bennofs> @hackage cab
08:20:28 <lambdabot> http://hackage.haskell.org/package/cab
08:20:31 <monochrom> I do not know or want to know.
08:20:36 <epta> http://adambard.com/blog/top-github-languages-for-2013-so-far/ could someone explain how prolog beats haskell here?
08:20:41 <mcstar> > map (\(w,h) -> w/h^2) [(91,180)]
08:20:42 <hoverbear> applicative: Ok, that's interesting.
08:20:43 <lambdabot>   [2.808641975308642e-3]
08:20:52 <mcstar> > map (\(w,h) -> w/h^2) [(91,1.80)]
08:20:53 <lambdabot>   [28.086419753086417]
08:21:16 <monochrom> actually, I know. not enough money paid for it.
08:21:20 <applicative> hoverbear: but it won't be as convenient as if you cabal install things in the usual way of course
08:21:20 <bennofs> 'cabal sandbox delete' deletes the whole sandbox, or is there an option to only delete part of it?
08:21:27 <bennofs> @hackage cab
08:21:27 <lambdabot> http://hackage.haskell.org/package/cab
08:21:41 <bennofs> cab has an "uninstall" command afaik
08:21:42 <applicative> bennofs: there is cabal sandbox hc-pkg <whatever>
08:22:12 <bennofs> (And as much as I tested it, cab also deletes packages dependend on the removed package)
08:22:26 <hoverbear> bennofs: That's a good link, thanks. :)
08:23:16 <hoverbear> Anyone familiar with the "proper" way to do Haskell on Arch Linux? I'm reading about and apparently it's a huge fustercluck.
08:23:35 <dmwit> Did you read SICP?
08:23:44 <mcstar> hoverbear: i just install ghc, and every other thing with cabal
08:23:50 <srhb> hoverbear: I generally find that not using the package manager is the way to go
08:23:54 <srhb> hoverbear: On almost any distribution.
08:23:59 <hoverbear> mcstar: Yeah, that's what I've been reading to.
08:24:12 <mcstar> so what is fustercluck-y there?
08:24:16 <applicative> hoverbear: probably the best plan is to forget about the package manager; get the ghc from the ghc webpage and install it in ~/myghcstuff and forget about arch
08:24:17 <mcstar> it works(TM)
08:24:24 <hoverbear> mcstar: The AUR, etc, all have different ways.
08:24:30 <mcstar> forget the AUR
08:24:33 <applicative> forget about pacman i mean
08:24:41 * hackagebot algebraic-classes 0.4 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.4 (SjoerdVisscher)
08:24:52 <hoverbear> Holy moly, GHC installed size is 735 mb.
08:25:03 <applicative> is that too small?
08:25:07 <mcstar> now look at the download size
08:25:13 <hoverbear> applicative: That's bigger then my entire OS. Heh.
08:25:29 <hoverbear> mcstar: A delightful 62 mb
08:25:35 <mcstar> 64MB
08:25:48 <mcstar> well, i dont round properly..
08:25:55 <applicative> hey, it *includes profiling libraries* hoverbear , and *documentation* ...
08:26:40 <hoverbear> applicative: Docs I can google, profiling I doubt I'll care about. :-P
08:26:46 <mcstar> lol
08:26:50 <mcstar> wrong, you will care
08:26:57 <mcstar> heap profiling, especially
08:27:00 <applicative> oh, well then you save a couple mb ...
08:27:30 <hoverbear> mcstar: Currently I'm looking at Haskell mostly for Xmonad and ghci. So maybe. :-P
08:27:52 <applicative> hoverbear: compile a hello world and see how big it is...
08:28:00 <hoverbear> applicative: Huge right?
08:28:12 <mcstar> no, just big
08:28:19 <applicative> i think the defaults make it not so bad as it once was
08:29:14 <applicative> the jhc makes a nice minute hello world
08:29:32 <applicative> of course, it's hard to compile anything else with jhc
08:29:50 <bennofs> hello world is 1,1M
08:29:52 <mcstar> i will close CalcBmis now
08:30:01 <monochrom> one cause of big object code is inlining
08:30:06 <carp> http://lpaste.net/92322       so on line 1 we know that calcBmis is going to make a list...
08:30:13 <carp> oh no mcstar 1 sec loinger haha
08:30:22 <applicative> not much to inline in 'putStrLn "hello world"' or am i wrong
08:30:35 <mcstar> opened again :)
08:30:49 <srhb> mcstar: What is this close/open thing?
08:31:02 <carp> on line 2 calcBmis is going to be defined and it takes a list of tuples (which we alos know just from line 1)
08:31:18 <carp> (we know that fact i mean)
08:31:24 <mcstar> srhb: ah, i get it, your browser is persistent right? once you visit something it will stay forever that way
08:31:43 <mcstar> mine is imperative, i can erase tabs
08:31:50 <donri> say, just how much more unsafe is unsafeDuplicatePerformIO over unsafePerformIO? is it "safe" for thread-safe IO?
08:31:58 <monochrom> you are somewhat wrong. use -O -ddump-simpl -dsuppress-all to see a high-level overview
08:32:01 <donri> eh, Dupable
08:32:04 <bennofs> -O0 and -O2 makes exactly 0 bytes difference for hello world :p
08:32:51 <mcstar> carp: calcBmis is defined starting from line 2
08:33:08 <applicative> ah indeed jhc hello world is 25832 ; ghc 1462696
08:33:13 <mcstar> and your are correct, proceed
08:33:52 <dmwit> bennofs: try strip
08:34:11 <bennofs> still no difference, but smaller :)
08:34:20 <monochrom> but here is what I found out recently. I wrote something like "let n=m+2 in case y of { Nothing -> ... n ...; Just z -> ... n ... }". it got compiled to "case y of { Nothing -> ... m+2 ...; Just z -> ... m+2 ... }"
08:34:21 <bennofs> 760K
08:34:51 <mcstar> monochrom: thats a common optimization called something-lifting
08:35:05 <applicative> strip takes off 1/3 of my ghc helloworld
08:35:05 <carp> its going to be a list of 'whatever bmi does with w and h'    |   and we get w and h by looking at xs
08:35:07 <mcstar> expression lifting?
08:35:09 <mcstar> idk
08:35:44 <mcstar> wait, isnt that the inverse of the optimization?
08:36:06 <Eduard_Munteanu> Hmm... misusing GADTs as typeclasses feels a bit like Agda.
08:36:19 <applicative> is that good or bad Eduard_Munteanu
08:36:30 <Eduard_Munteanu> I'd say good. :)
08:36:41 <dmwit> carp: right
08:37:24 <mcstar> carp: well, the type fixes what the inputs and the outputs are to calcBmi, but inside, bmi can do whatever with those value, you could write a typesig for bmi too
08:37:46 <mcstar> so, what you see on line 1 does not fix what bmi does
08:38:36 <Zenol> Are DiffUArray usable?
08:38:44 <monochrom> not very
08:39:08 <haasn> wait what? https://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
08:39:14 <haasn> I can write actual linux kernel modules in HAskell?
08:39:30 <monochrom> haha neat
08:39:32 <carp> I dont know if its just me being a major noob but i think things would be easier to comprehend if there was some sort of convention where all functions were in bold and all parameters were in italics or something lol
08:39:42 * hackagebot penny 0.28.0.0 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.28.0.0 (OmariNorman)
08:39:59 <applicative> Zenol: http://stackoverflow.com/questions/14344338/how-use-diffarray-in-haskell-how-make-more-strict-this-code
08:40:29 <mcstar> carp: the type of something tells you mostly, if its a function or not
08:40:35 <Zenol> haasn: Looks like he was using a modified GHC in 2009 :s
08:40:38 <applicative> carp the functions are in camelCase and the parameters are a b c xs ys z etc
08:40:47 <applicative> carp, sort of
08:40:54 <mcstar> if it has an arrow in the type, it is a function, ofc, you can write a type synonyme for that..
08:40:55 <haasn> Zenol: :(
08:41:05 <monochrom> carp: what if the same thing is both a function and a parameter?
08:41:14 <haasn> this needs to be updated to 2013 and 3.10.9 :)
08:41:23 <haasn> I want to get hacking on device drivers in Haskell!
08:41:30 <mr-> monochrom: yeah.. it's super annoying!
08:41:35 <Zenol> haasn: But I'm pretty sure that if you really want you could be able to.
08:41:51 <dmwit> monochrom: bold italic, obviously
08:41:55 <mcstar> also, it doesnt really matter what's what, imho
08:42:04 <mcstar> if it typechecks, its ok then
08:42:23 <mcstar> i just see names, not contants and functions
08:42:29 <dmwit> The real question is: when I write "undefined", should it be bold?
08:42:37 <mcstar> RED
08:42:39 <valyagolev> it should also be red
08:42:48 <dmwit> Whether it should be red wasn't the question. =)
08:42:58 <monochrom> what mcstar says
08:43:00 <geekosaur> <blink>
08:43:01 <Eduard_Munteanu> Should also rm -rf your entire project if it ever executes. :)
08:43:13 <zett_zelett> Why is it remarkable that you can write linux kernel modules in haskell?
08:43:20 <carp> I just want to say a big thankyou to everyone for helping me there. Really appreciate it :)
08:43:38 <dmwit> zett_zelett: Generally speaking, because Haskell implementations do GC and that's sort of frowned on in OS stuff.
08:43:45 <dmwit> Well, that would be why I would be surprised. =)
08:43:49 <monochrom> what you really care about is types. but there are more types than there are typefaces. typeface schemes don't scale.'
08:43:53 <Eduard_Munteanu> zett_zelett: because GHC's RTS is the sort of thing unwelcome into the Linux kernel :)
08:44:36 <monochrom> at the end you settle for what Peaker does. a fancy editor that attaches types to names
08:44:45 <valyagolev> you can also represent all data as functions, e.g. Church numerals and stuff, if your Caps Lock ever gets stuck
08:44:51 <mcstar> also, that article states, that the module will leak mermoy
08:44:56 <Sculptor> hi
08:44:56 <mcstar> memory
08:46:01 <monochrom> oh! you suppress GC to get a linux module? :)
08:46:07 <valyagolev> monochrom I googled for peaker haskell and only found some guy
08:46:11 <applicative> hi Sculptor
08:46:37 <monochrom> Peaker is a regular in this channel
08:46:39 <bennofs> valyagolev: look @ github of that guy
08:46:46 <monochrom> preflex: seen Peaker
08:46:47 <preflex>  Peaker was last seen on #haskell 3 days, 13 hours, 56 minutes and 18 seconds ago, saying: if you use monochrom's approach, it's important to bump the version number a bit, to prevent "cabal-install" from overriding your custom package install
08:46:51 <applicative> valyagolev: https://github.com/Peaker
08:46:52 <valyagolev> monochrom bennofs , ah I got it
08:46:58 <applicative> oh as bennofs says
08:47:05 <valyagolev> thanks
08:50:06 <Zenol> applicative: Oh, so it's vector that I should use? :)
09:08:40 <applicative> Zenol: vector is a very current library
09:09:06 <Eduard_Munteanu> Is there a concept describing pointwise sum / product types? E.g. (a, b) ->_p (c, d) ~= (a ->_p c, b ->_p d)
09:10:09 <applicative> Zenol: Data.Vector.Unboxed and Data.Vector.Unboxed.Mutable are basically a miracle
09:11:41 <Eduard_Munteanu> For pointwise tupling it's much like a typelevel transpose of sorts... transpose ((a, a', a''), (b, b', b''), (c, c', c'')) = ((a, b, c), (a', b', c'), (a'', b'', c''))
09:13:22 <mcstar> applicative: how do you mean?
09:14:03 <applicative> you write haskell like you just read lyah and its blazingly fast, for example?
09:15:01 <mcstar> you mean, by using the high level vector interface?
09:15:08 <applicative> yeah
09:15:22 <mcstar> i thought they are like a miracle, because they were so hard to implement, or something
09:15:54 <applicative> well yes, when you study how it works, its that much more wonderful
09:16:40 <mcstar> hm, clearly my intuitive understanding of its internals are wrong then
09:17:15 <applicative> well, okay; maybe its a matter of taste
09:22:27 <Eduard_Munteanu> Actually I'm not sure how to define the other pointwise thing... (->)_p (a -> b) (c -> d) ~ (b^a) ^. (d^c) ~ (d^b) ^ (c^a) ~ (a -> c) -> (b -> d)   seems reasonable
09:22:56 <Eduard_Munteanu> It's still some sort of transposition.
09:24:17 <Athas> I really wish 'for = flip map' was a standard function.
09:24:49 * hackagebot network-data 0.5.1 - Library for network data structures and their serialization.  http://hackage.haskell.org/package/network-data-0.5.1 (ThomasDuBuisson)
09:24:58 <mkramer> What is the term of art for types that can be parameterized over other types?
09:25:20 <Eduard_Munteanu> mkramer: type functions?
09:26:10 <applicative> mkramer: do you mean like Maybe?
09:26:27 <mcstar> type constructor
09:26:44 <mkramer> Any type constructor that takes type arguments
09:27:24 <applicative> mkramer: for some reason they call them type constructors as mcstar says; Int they don't call that. the jargon seems a little lame
09:27:30 <mkramer> nullary type constructors are what most languages have, Haskell extends that with _______, which provides the concept of paramterized types
09:27:34 <Eduard_Munteanu> Pretty much the idea of System F omega.
09:27:39 <applicative> the kind system gives accurate names for all these things
09:28:11 <mkramer> we need words for things
09:28:12 <applicative> @kind Maybe
09:28:13 <lambdabot> * -> *
09:28:19 <applicative> @kind Either
09:28:20 <lambdabot> * -> * -> *
09:28:56 <applicative> all the english words for this sort of stuff seem really lame by contrast
09:29:10 <Eduard_Munteanu> Don't they call stuff in * concrete types?
09:29:12 <cschneid> so Data Foo = Foo has kind *?
09:29:22 <applicative> @kind ()
09:29:23 <lambdabot> *
09:29:40 <cschneid> are there kinds that aren't made up of *s
09:29:45 <applicative> yes
09:29:52 <Eduard_Munteanu> cschneid: any inhabited type has kind * normally
09:30:15 <applicative> * can sensibly be pronounced 'type', but that crosses some usages
09:30:42 <n-dolio> There are also #, (#), ? and ?? in GHC.
09:31:04 <Eduard_Munteanu> Also BOX, Constraint and probably others too IIRC
09:31:05 <applicative> to say nothing of Nat , [Nat]
09:31:25 <Eduard_Munteanu> (or is BOX a sort?)
09:31:38 <applicative> @kind BOX
09:31:39 <lambdabot> Not in scope: type constructor or class `BOX'
09:31:41 <applicative> hah
09:31:45 <applicative> BOX : BOX
09:31:46 <n-dolio> Yeah, but types with kind Constraint don't have (visible) values.
09:32:19 <mkramer> Ok, what do you call a constrained type, like (Integral a)
09:32:42 <applicative> @kind Integral
09:32:42 <lambdabot> * -> Constraint
09:32:54 <Eduard_Munteanu> mkramer: you can think of it as a subkind of *, I think
09:33:08 <Eduard_Munteanu> (as in subtypes)
09:33:10 <mkramer> I know, but I want words to say
09:33:29 <mkramer> People come and ask me questions in my office because I am the Haskell guy (hah…as if)
09:33:41 <Eduard_Munteanu> Oh, just use "typeclass constraints".
09:33:41 <applicative> mkramer: that's whats irritating; you will just end up following some dogmatic school of word-meisters
09:33:46 <mkramer> and I flubber around trying to describe how Haskell generalizes types
09:34:57 <mkramer> It doesn't hurt calculus that the thing you can do to find the formula for the tangent line of a curve at a point has a short and concise name
09:35:13 <mkramer> it only hurts if people don't agree on the meanings of things
09:35:35 <Hafydd> What's an example of a "dogmatic school of word-meisters"?
09:35:50 <mkramer> strong vs weak typing
09:35:53 <mkramer> "dynamic" languages
09:36:06 <cschneid> @kind Maybe Integer
09:36:07 <lambdabot> *
09:36:08 <mkramer> no one knows what that shit means
09:36:10 <geekosaur> dogmatic school of word-meisters sounds like L'Academie Française
09:36:30 <Eduard_Munteanu> I wonder... do those pointwise sum/product types have anything to do with linear types? It seems those would be the actual (->) and (,) if Hask was a vector space, but I'm unsure that sort of linearity has anything to do with linear types.
09:36:31 <cschneid> so that's just * because I bound the unknown second arg to an actual value: `Integer`
09:36:42 <applicative> yes
09:36:49 <applicative> @kind Maybe
09:36:50 <lambdabot> * -> *
09:36:52 <applicative> @kind Int
09:36:53 <lambdabot> *
09:36:56 <applicative> @kind Maybe Int
09:36:57 <lambdabot> *
09:37:15 <cschneid> sure, it's basically like currying/partial application of functions, except at the level of types.
09:37:58 <mkramer> types are functions
09:38:42 <Eduard_Munteanu> You mean type functions are functions? :)
09:39:13 <Eduard_Munteanu> We usually don't consider nullary functions as true functions because then that's a synonym for values. :)
09:39:21 <mkramer> @kind Integral a
09:39:22 <lambdabot> Not in scope: type variable `a'
09:39:42 <Eduard_Munteanu> @kind Integral Int
09:39:43 <lambdabot> Constraint
09:39:46 <applicative> @kind forall a. Integral a -- probably wont work
09:39:47 <lambdabot> Constraint
09:40:00 <applicative> @kind forall a. Integral a => a -- probably wont work
09:40:01 <lambdabot> *
09:40:26 <cschneid> ok, what does a forall do.
09:40:31 <cschneid> I've seen it a few times, but haven't figured that out
09:40:42 <cschneid> I understand the constraint like (Integral a)
09:40:48 <applicative> it just makes the generality of id :: a -> a explicit
09:41:06 <applicative> once it is explicit, you can embed it in new ways
09:41:10 <joelteon> in "forall a. Integral a => a" it's not very useful because the forall is already implicitly added
09:41:24 <joelteon> but yeah in some cases it is helpful
09:41:37 <joelteon> data Showable = forall a. Show a => Showable a
09:41:37 <Eduard_Munteanu> cschneid: it only makes a difference with unconstrained rank-n/existential types and ScopedTypeVariables.
09:41:43 <applicative> that the forall is implicitly added is a dogmatic assertion
09:41:43 <n-dolio> It's useful in that it says explicitly how the variable is quantified.
09:41:56 <cschneid> Eduard_Munteanu: so you have to start getting a bit fancy to require it? So I can safely not understand for a while?
09:42:06 <n-dolio> Lots of people mistake 'Integral a => a' for something like 'exists a. Integral a => a' at first.
09:42:27 <Eduard_Munteanu> cschneid: it's much like a lambda binder for type variables
09:42:35 <Eduard_Munteanu> Like \a -> ...
09:42:44 <absence> when haskell gets the functor/applicative/monad dependencies sorted out, will the old list functions be made more general, or is that too invasive? i just realised zipwith "=" liftA2 :)
09:43:14 <haasn> zipWith is not liftA2
09:43:23 <Eduard_Munteanu> Except you don't normally need it because type variables get implicitly quantified.
09:43:24 <haasn> the type is the same, but the semantics are different
09:43:24 <n-dolio> zipWith is only liftA2 if you use ZipList.
09:43:27 <carp> Heres a question. Im asked to define a function that gives us a cylinder's surface area based on its height and radius. So I start with  cylinder :: a -> a        (good start?)
09:44:06 <cschneid> carp: takes height, radius, and returns a surface area
09:44:24 <cschneid> so X -> X -> X. where they are three, maybe different types.
09:44:24 <absence> haasn: it seems to work for f=[], but i'll admit i haven't done thorough tests
09:44:25 <micahcowan> cylinder :: Fractional a => a -> a     ?
09:44:26 <applicative> with 'zippy' applicative instances, liftA2 is zipWith; with 'ap' applicative instances, it isn't
09:44:28 <Eduard_Munteanu> carp: if you're asked to redefine 'id'  maybe :)
09:44:54 <micahcowan> er, probably a -> a -> a
09:45:05 <Saizan> > liftA2 (,) [1,2] [3,4]
09:45:06 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
09:45:08 <cschneid> carp: when you say 'a', you mean for it to work on anything. Which severely resitrcts the things you can do, probably too far to actually solve the problem you stated.
09:45:10 <haasn> > zipWith (,) "hello" [1,2,3,4,5] -- absence
09:45:12 <lambdabot>   [('h',1),('e',2),('l',3),('l',4),('o',5)]
09:45:17 <haasn> > liftA2 (,) "hello" [1,2,3,4,5] -- absence
09:45:18 <lambdabot>   [('h',1),('h',2),('h',3),('h',4),('h',5),('e',1),('e',2),('e',3),('e',4),('...
09:45:21 <acomar> absence: there are two valid applicative instances for list -- the usual one and ZipList. You might be getting them confused
09:46:22 <cschneid> carp: so then you can restrict 'a' down like micahcowan did, saying "the a here must be fractional" - cylinder :: Fractional a => a -> a -> a "Take two fractional values, and return a third."
09:46:22 <applicative> the applicative instance for lists is kind of dull unless you think of lists as 'expressing non-deteminism' etc
09:46:34 <Saizan> absence: anyhow i believe a bunch of Prelude functions are going to get generalized from [] to Foldable/Traversable in the near future
09:47:07 <carp> cylinder :: (RealFloat a) => a -> a -> a               this is whats in the tutorial, but i dont understand why there are 3 a's  because I thouught -> means 'evaluates to'
09:47:21 <Zenol> Hum, how should I use lens operator on a State Data _ where Data has lenses (thanks to makeLenses) ? Let's say, for st <- gets ; st ^. (cpu . registers . a)
09:47:44 <cschneid> carp:   a constant function looks like: three :: Int ...  three = 3
09:48:01 <absence> haasn: yikes! seeing that makes me wonder how my toy lzw decoder works at all. i'll have to look into this, thanks for the enlightenment :)
09:48:04 <cschneid> carp: a function that takes an integer and adds three would be   addThree :: Int -> Int
09:48:07 <micahcowan> carp, It does, but it's sometimes easier to think of only the very final "-> a" as the function's return, and the others as arguments.
09:48:09 <applicative> Zenol: do you want to change the state?
09:48:10 <cschneid> carp: addThree x = x + 3
09:48:21 <absence> Saizan: cool :)
09:48:22 <micahcowan> So a -> a-> a means it takes two args and returns one, and they're all the same type.
09:48:26 <Zenol> applicative: Yes. Like adding 1 to a register :)
09:48:32 <Sonarpulse> I am making FFI bindings for a library
09:49:02 <carp> a -> a -> a         what does that mean?
09:49:07 <Sonarpulse> C library. It already has support to give it a fun pointer for malloc and free
09:49:21 <micahcowan> carp, I just said what it means.
09:49:40 <Sonarpulse> I can give it a no-op for free and haskell's GC dynamic allocate
09:49:46 <applicative> Zenol if the lens for the register is reg, then reg += 1 , no?
09:49:49 * hackagebot ctrie 0.1.0.0 - Non-blocking concurrent map  http://hackage.haskell.org/package/ctrie-0.1.0.0 (MichaelSchroeder)
09:49:51 <applicative> or is it =+
09:49:52 <micahcowan> carp: A function that takes two arguments and returns a value, where both args and the value are all the same type.
09:50:09 <carp> ah sorry i missed one of ur replies
09:50:10 <Sonarpulse> Is this a good idea?
09:50:21 <Zenol> applicative: I don't know. So If I'm in a state monad, I don't have to do anything to say I'm talking about the current state?
09:50:51 <applicative> Zenol: right, you name the lens you want to change and use the appropriate operator with = in it, to put it crudely
09:51:17 <applicative> the lens on the position you want to change, rather.
09:52:03 <applicative> @type (+=)
09:52:04 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
09:52:42 <carp> a -> a -> a  -> a -> a -> a -> a              (i can just go on and on right? all except the last represent arguments and the last one represents the output?)
09:53:07 <aztek> Is it possible to define monad transformer for Monad ((->) r)?
09:53:17 <applicative> > runState (_1 += 1) (1,1)
09:53:19 <lambdabot>   ((),(2,1))
09:53:32 <applicative> > runState (_1 += 1; _2 += 1) (1,1)
09:53:33 <lambdabot>   <hint>:1:18: parse error on input `;'
09:53:37 <applicative> ah
09:53:49 <applicative> > runState (do {_1 += 1; _2 += 1]) (1,1)
09:53:50 <lambdabot>   <hint>:1:31: parse error on input `]'
09:53:57 <applicative> > runState (do {_1 += 1; _2 += 1}) (1,1)
09:54:10 <mkramer> Can anyone think of an example of a user-defined monad in which it makes since not to define any functions that escape from it? Or has anyone ever made one?
09:54:13 <Zenol> applicative: I get it :) Wonderfull.
09:54:23 <lambdabot>   ((),(2,2))
09:54:27 <c_wraith> mkramer: all the time.
09:54:36 <applicative> the state use of lenses is especially amazing
09:54:58 <mkramer> Any easily digestible examples?
09:55:20 <carp> micahcowan: a -> a -> a -> a -> a -> a -> a              (i can just go on and on right? all except the last represent arguments and the last one represents the output?)
09:55:27 <c_wraith> mkramer: take a look at any of the probability monads, for instance.  They don't have a single result.  They have probability fields of results.
09:55:36 <cschneid> carp: sorta, but yes.
09:55:48 <micahcowan> carp, that's right. The notation comes from the fact that, thanks to partial application, you can always just give only one of the arguments, and the return value from that will be a function that takes the next argument, which returns a function that takes the next argument, until finally the last argument is received and the final result is returned.
09:55:52 <mkramer> Oh, interesting
09:56:01 <cschneid> carp: you can take something like    add :: Int -> Int -> Int which is just add x y = x + y
09:56:08 <mkramer> functions that take pdfs as arguments must return pdfs
09:56:10 <cschneid> carp: and then say  add3 = add 3
09:56:20 <cschneid> carp: add3's type would be Int -> Int
09:56:31 <micahcowan> carp, but it's usually easier to think in terms of a single function that takes a bunch of args, and spits one return value.
09:56:44 <c_wraith> mkramer: this isn't to say you can't work with the values outside of monadic contexts - of course you can.  But you can't just "get a result" out
09:57:04 <micahcowan> And that's how most function definitions are described as well, in terms of their multiple arguments (assuming pointed style)
09:57:19 <Dveim> hello
09:57:25 <Dveim> i have a question
09:57:32 <micahcowan> Can someone tell me where @pl's if' comes from?
09:57:38 <Zenol> applicative: And if I want only a view (For example, I want to get the value of f = (+ 5) applied to _1 in your example, and return it.
09:57:39 <micahcowan> ("if-prime")
09:57:43 <Dveim> for example, i have to storage some tree's height
09:57:45 <shachaf> if' b x y = if b then x else y
09:57:48 <shachaf> Not defined anywhere.
09:57:53 <Dveim> what is the most elegant way to do that?
09:58:05 <micahcowan> shachaf, "roll your own", then? :)
09:58:16 <Dveim> assuming that it may change during adding new nodes
09:58:16 <micahcowan> Thought maybe there was a pointfree utils package that included it, something like that.
09:58:35 <shachaf> micahcowan: More like "you probably shouldn't use it".
09:58:46 <carp> parameter/argument   same thing right? oh man learning programming makes me feel like im 12 years old again haha
09:59:05 <cschneid> carp: yeah. Go play in ghci with my add example, and using :t to see the types of various things along the way
09:59:35 <micahcowan> shachaf, probably not. I had in mind something more like "choose a b c = if c then a else b", since that'd avoid a heluvalot of "flips" and such in typical use cases...
09:59:36 <S11001001> Dveim: if it grows by one you can add 1 to each node you visit walking back up the tree during rebuild
09:59:47 <micahcowan> Though choose is probably a poor word, since it means something else in math...
10:00:22 <shachaf> There's "bool"
10:00:48 <shachaf> I don't remember the order that goes in. I think it's bool x y False = x; bool x y True = y?
10:01:13 <carp> thankyou for the help
10:01:36 <micahcowan> shachaf, defined where?
10:01:44 <cschneid> carp: no problem - keep asking questions here, then going to play with stuff & read, then coming back to ask questions. I'm getting to the end of "total newbie" myself, and this channel has gotten me there
10:01:44 <shachaf> Nowhere.
10:01:50 <shachaf> (There's a bit of a pattern here.)
10:02:06 <micahcowan> Ah. But this is a common idiom, or something? :)
10:02:33 <shachaf> It's a fold for Bool.
10:02:48 <Dveim> S11001001 i have a very big list of nodes that i add to tree with some rules. For performance, i don't want to recount height every time
10:03:21 <S11001001> Dveim: you can put data at each node.  Put the height at each node.
10:04:06 <pentace> shachaf: Where is bool defined?
10:04:13 <shachaf> pentace: See above.
10:04:29 <Dveim> S11001001: but how can i storage height? Is foldl good enough?
10:04:43 <pentace> Ah, sorry
10:06:24 <S11001001> Dveim: you are the one defining the tree structure, right?
10:06:39 <Dveim> S11001001: yes
10:08:12 <Dveim> S11001001: in simple languages, i could write my_tree.height += 1 when new node's height > current one. But have do i do that in Haskell?
10:08:56 <acomar> dveim: what does your tree type look like?
10:10:07 <simon> Dveim, assuming you have a datatype, data Tree = Tree { height :: Int } deriving (Show, Eq), you can do: t = Tree 5   and   growTree t = t { height = height t + 1 }
10:10:16 <mcstar> the only worse thing, is when you have to translate the terms to your native language....
10:11:07 <simon> Dveim, but the significant difference is that this tree is immutable, so where your 'my_tree.height += 1' operation changes the height value in-location, this function merely returns a new tree with an increased height.
10:11:07 <Dveim> acomar: in fact, it is not tree. It is something like tetris' field. Adding new nodes is similar to tetris, but they don't fall but "grow up" if enought space. Nodes are ranges, e.g. (1, 5)
10:12:41 <ocharles> mm_freak_: so, I wanted to ask you what you thought of the way I dealt with dynamic sets.
10:12:51 <ocharles> because my whole "reified" wire stuff is questionable
10:12:54 <ocharles> let me get a link to some code
10:12:57 <acomar> Dveim: add a height field to the tree, and make sure to update it as appropriate it. If you're in the state monad, you can actually get the height += 1 notation (requires lens).
10:13:04 <mm_freak_> ocharles: i've read the code
10:13:30 <ocharles> mm_freak_: ok, well I had to refresh myself :)
10:13:33 <ocharles> https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs#L498 it's that part
10:13:47 <bennofs> Why is it bad to use Read/Show for data serialization?
10:14:10 <bennofs> (If you keep the format valid haskell?)
10:14:36 <ocharles> it works and makes sense why it works, but it just seems a little odd to have the step function produce "now" (a value) and the "future" (a wire)
10:15:06 <mm_freak_> ocharles: netwire 4 still has the problem that it exposes discrete time, so you may just as well use discrete collections of wires for now, but semantically it's non-sense of course
10:15:09 <micahcowan> bennofs, I'm a newbie here, but I think the right question may be more "when" than "why"...
10:15:17 <mm_freak_> ocharles: this particular combinator style will not be possible in netwire 5 anymore
10:15:21 <micahcowan> IOW, sometimes Read/Show is a perfectly valid choice.
10:15:22 <ocharles> mm_freak_: interesting
10:15:52 <Dveim> acomar: well, i'll try that, but i'm not very experienced with state monad - learning it atm. Thanks for answers
10:15:57 <ocharles> mm_freak_: so netwire 5 removes the ability to plumb things around inside an instant?
10:15:58 <micahcowan> But it's text/human-readable-oriented, which can be inefficient, etc.
10:16:22 <mm_freak_> ocharles: only based on instants…  it will be possible to do it using events
10:16:45 <acomar> dveim: then don't worry about it for now, just use the normal record update syntax.
10:17:43 <Dveim> acomar: can you give some usage examples?
10:17:56 <mm_freak_> ocharles: in general you won't be able to observe individual instants anymore
10:18:24 <Dveim> acomar: i mean links
10:19:24 <ocharles> mm_freak_: i'll grab this code soon and have a play, i'm very interested
10:19:58 <mm_freak_> ocharles: i noticed that continuous (!) inhibition itself is not a good paradigm for discrete (!) events, so i added an actual (opaque) event type, which you can convert to inhibition in a well-defined manner
10:20:15 <ocharles> mm_freak_: yea, I just got to that bit, and I'm very interested to see how it plays out
10:20:18 <mm_freak_> like "as soon as", "as long as", "when event, for three seconds", etc.
10:20:31 <ocharles> the events in netwire 4 make sense, but didn't seem to work out quite as one would expect
10:20:49 <mm_freak_> ocharles: no, that's the problem, they don't make sense =)
10:21:10 <mm_freak_> they are completely incompatible with this notion:  type Event a = [(Time, a)]
10:21:10 <ocharles> mm_freak_: :)
10:21:43 <acomar> dveim: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html -- this will get you started
10:22:00 <acomar> dveim: or do you mean examples of record updates?
10:22:11 <Sonarpulse> I asked earlier but no responces. I am making FFI bindings, if I can easily make the library use GHC's GC malloc / the haskell heap, is it a good idea to do so?
10:22:53 <Dveim> acomar: that is what i need, thanks =)
10:22:58 <mm_freak_> ocharles: the next major version will make an explicit distinction between application developers and framework developers…  the latter will be the ones with access to the internals of Event and also who can observe discrete time
10:23:11 <mm_freak_> application developers will not be able to observe or construct discrete time in any way
10:23:20 <Sonarpulse> Can I make strict data structures in Haskell which conform to the C API? and therfore don't need to be coppied when given to C?
10:23:23 <ocharles> and asteroids would probably be an application?
10:23:54 <mm_freak_> ocharles: yeah…  based on an SDL/OpenGL framework
10:24:01 * ocharles nods
10:24:04 <micahcowan> Sonarpulse, my understanding of your last question, is yes, at least in GHC.
10:24:20 <Sonarpulse> with UNPACK and ! ?
10:24:20 <Jeanne-Kamikaze> are you sure about the no need to copy ?
10:24:26 <shachaf> The answer to Sonarpulse's question -- or the question they probably meant to ask -- is no.
10:24:35 <Jeanne-Kamikaze> yeah, you can't avoid the copying afaik
10:24:42 <micahcowan> Don't have a link, Sonarpulse, but GHC's list of language extensions had that somewhere in there. They had a special syntax, I think types beginning with @ or something? that referred to such "raw" types
10:25:10 <Sonarpulse> you mean magic hash? like Int# ?
10:25:17 <micahcowan> That's what I was thinking of, yeah
10:25:29 <Jeanne-Kamikaze> but isn't that for primitives only ?
10:25:37 <micahcowan> Yup.
10:25:43 <Jeanne-Kamikaze> so the answer to his question is no
10:25:45 <shachaf> GHC has unboxed types. They don't do what Sonarpulse is asking for.
10:25:51 <Sonarpulse> yeah
10:26:08 <Sonarpulse> GHC pointers with the magic bit and all seem pretty unavoidable
10:26:08 <mcstar> # is only convention though, afaik
10:26:32 <Sonarpulse> ^ True
10:26:39 <mm_freak_> Sonarpulse: you probably want Storable
10:26:51 <Jeanne-Kamikaze> but Storable won't get you rid of the copying
10:27:03 <Jeanne-Kamikaze> ?
10:27:07 <micahcowan> I guess "primitives" don't qualify as "data structures" maybe...
10:27:17 <Sonarpulse> Yes Storable is not super interesting
10:27:32 <mm_freak_> Jeanne-Kamikaze: Storable has nothing to do with that
10:27:42 <shachaf> There is also no ABI guarantee -- that's a completely separate matter.
10:27:55 <mm_freak_> Jeanne-Kamikaze: for example ByteString can be passed to C without copying
10:28:03 <mm_freak_> Data.Vector.Storable can be passed without copying
10:28:09 <Sonarpulse> Bytesring is a ForeignPtr under the hood
10:28:13 <Sonarpulse> http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/
10:28:25 <mm_freak_> Sonarpulse: and that's exactly what you need
10:28:27 <Jeanne-Kamikaze> but then can you read without copying ?
10:28:29 <Sonarpulse> ^ This type of stuff keeps on enticing me
10:29:01 <ocharles> mm_freak_: so how far have you got? :)
10:29:14 <mm_freak_> ocharles: with netwire 5?
10:29:14 <Sonarpulse> manual parse byte strings? yes
10:29:30 <Sonarpulse> the ironic thing, is if you have a bytestring allocated in C, and you get it haskell
10:30:01 <ocharles> mm_freak_: yea
10:30:06 <Sonarpulse> you cannot give it back to C if it puts it in a C struct because C's free will be called by GC via the finalizer
10:30:33 <mm_freak_> ocharles: close to a release…  this weekend either release or stabilize the API
10:30:43 <Sonarpulse> On the other hand, if I give C haskell's malloc, then C can do whatever it wants because it will be stored inthe C heap
10:30:49 <Sonarpulse> * Haskell heap
10:30:56 <Sonarpulse> and GC will work correctly
10:31:02 <mm_freak_> ocharles: right now i'm changing Wire to have a bunch of constructors for efficiency…  also i'm removing the switching combinators
10:31:22 <Sonarpulse> but then I can't use unsafe imports, because C will call back for every malloc.
10:32:12 <mm_freak_> ocharles: netwire 3 easily achieved almost a few ten million FPS…  i want to bring that back in netwire 5 =)
10:32:29 <mm_freak_> s/almost//
10:33:08 <ocharles> mm_freak_: eh, as long as it can do 60 i'm happy :)
10:33:46 <mm_freak_> ocharles: one intended application is game servers…  you still get 60 FPS, but you want one F to be as cheap as possible given a possibly giant game world =)
10:33:47 <Sonarpulse> I dunno. I suspected the coppying was inevitable. But even so, I am paralized unable to choose between the different ways to write the FFI. If somebody could just make all the design decisions for me, that would be great :)
10:34:40 <mm_freak_> ocharles: the point is to make the FRP layer as lightweight as possible
10:35:29 <Sonarpulse> mm_freak_: is wire the FRP library used to make frag, the quake clone?
10:35:38 <mm_freak_> Sonarpulse: no, that one used yampa
10:35:55 <mm_freak_> netwire's Wire is similar to yampa's SF though
10:36:00 <mm_freak_> just a lot more powerful =)
10:36:03 <ocharles> mm_freak_: yea, i support speed
10:36:23 <Sonarpulse> Ok. Is Yampa still actively developed?
10:36:29 <mm_freak_> from what i see yes
10:36:47 <Sonarpulse> Ok. So does that make Wire, Yampa, and Reactive-Bannana the big 3 FRP libraries?
10:36:59 <mm_freak_> pretty much
10:37:07 <Sonarpulse> cool
10:37:12 <mm_freak_> elerea is also used, but i don't like it
10:37:37 <Sonarpulse> never heard of it. I had heard of Wire however :)
10:38:07 <mm_freak_> then there is elm, which isn't a haskell library, but a haskell-like language for making reactive web pages
10:38:10 <MileyCyrus> hi
10:38:22 <ocharles> mm_freak_: I need to try elerea, just to decide if i like it or not
10:39:07 <mm_freak_> ocharles: elerea has discrete time semantics and separates object creation from object combination
10:39:25 <mm_freak_> i.e. it has "signal generators" and "signals"
10:39:31 <mm_freak_> i didn't like it
10:46:38 <lpaste> callen pasted “No title” at http://lpaste.net/92333
10:47:04 <callen> okay, fresh haskell platform install, getting the above error for an attempt at installing cabal-dev. :|
10:54:56 * hackagebot lens 3.9.0.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.9.0.3 (EdwardKmett)
10:58:11 <Zenol> pcS <- gets $ _pc._registers._cpu is a bit ugly. I would like to write tomething using cpu.registers.pc to acess the value :/
10:59:44 <ion> Then do that. :-P You can control how the accessor names are formatted.
10:59:56 <ion> That is, if you’re the one providing the accessors.
11:00:00 <ion> If not, perhaps email the author.
11:00:18 <Zenol> ion: I use makeLenses to generate cpu, registers and pc.
11:00:43 <Zenol> ion: They should be something in lens but I started using it today :p
11:01:03 <supki> pcS <- use $ cpu.registers.pc
11:01:05 <edwardk> Zenol: makeLenses or makeClassy?
11:01:29 <edwardk> with makeclassy you can probably simplify that to pcS <- use $ registers.pc    or even use pc !
11:01:55 <Zenol> edwardk: makeLenses. So I should use makeClassy? :)
11:01:56 <edwardk> because you can makeClassy ''Registers    and instance HasRegisters ''CPU where registers = cpuRegisters
11:02:07 <edwardk> Zenol: very likely. if you have a paste of the code i can give tips
11:04:35 <lpaste> Zenol pasted “makeLenses or makeClassy?” at http://lpaste.net/92334
11:04:53 <edwardk> Zenol: great! lets start at the top
11:04:56 * hackagebot GLUtil 0.6.6 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.6 (AnthonyCowley)
11:04:58 <edwardk> makeClassy ''Registers instead of makeLenses
11:05:06 <Zenol> edwardk: MakeClassy create conflict because I have field named _stuff of type Stuff :s
11:05:09 <edwardk> same with Clock
11:05:15 <edwardk> Zenol: we'll fix that
11:05:16 <edwardk> one sec
11:05:35 <edwardk> in cpu change _registers and _clock to _cpuRegisters and _cpuClock
11:05:40 <edwardk> and makeClassy CPU too
11:06:13 <edwardk> this will break all the code below but don't worry about it yet
11:06:46 <edwardk> now after makeClassy ''CPU   -- instance HasRegisters CPU where registers = cpuRegisters; instance HasClock CPU where clock = cpuClock
11:06:57 <edwardk> now all the lenses for register and clock just work when applied to a CPU!
11:07:48 <edwardk> when you makeClassy ''MMU and makeClassy ''VM; instance HasMMU VM where mmu = vmMmu; instance HasCPU VM where cpu = vmCpu
11:08:01 <edwardk> you can use the registers by name directly as members of the VM itself
11:08:12 <edwardk> no cpu.registers.a     just 'a'
11:10:27 <joelteon> why can't you reupload versions to hackage?
11:10:41 <edwardk> joelteon: global consistency
11:10:57 * Zenol now understand why you should prefix record syntax fields by the type name.
11:10:59 <edwardk> joelteon: with hackage 2.0 you get the ability to at least put it in a playpen, and test it before showing the world
11:11:03 <edwardk> Zenol: =)
11:11:08 <joelteon> oh, cool
11:11:20 <joelteon> this is my first package with INLINE pragmas, I feel like a pro
11:11:30 <lispy> INLINE all the things!
11:11:46 <lispy> (and SPECLIALIZE as needed)
11:11:52 <lispy> SPECIALIZE even
11:12:08 <monochrom> next achievement: REWRITE rules
11:12:56 <joelteon> yeah, someone make an achievements system for writing packages
11:13:40 <joelteon> oh, specialize is for polymorphic functions
11:14:20 <watermind> isn't ghc smart enough to decide most INLINES?
11:14:45 <edwardk> joelteon: as a completionist that would be dangerous.   but … now you're saying i _have_ to use IncoherentInstances!? noooooo!
11:14:56 * hackagebot damnpacket 0.1.0.1 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.0.1 (JoelTaylor)
11:15:01 <edwardk> watermind: within a module, yes
11:15:20 <edwardk> watermind: across modules it only puts small bodies in the .hi files
11:15:33 <edwardk> watermind: unless you explicitly ask for them to be INLINEABLE or INLINE
11:15:49 <watermind> edwardk: oh I see, I didn't expect that
11:15:53 <edwardk> watermind: this is usually what you want, but some of us write things like lens where the unoptimized case is _awful_
11:15:55 <joelteon> yes watermind, but I get an achievement for writing INLINE
11:16:01 <joelteon> err I mean
11:16:06 <Eduard_Munteanu> I'm parsing some data and it's not in the best shape. I was looking at Data.Data and it seems I might be able to map record fields to parsers. Can lens also do something like that?
11:16:57 <watermind> I was thinking that SPECIALIZE is something I can see being very useful, because if you compile a standalone library, it won't know which specializations may be useful
11:17:11 <tel> edwardk what's the performance ratio with and without INLINE? out of curiousity
11:17:18 <Eduard_Munteanu> I'm trying to avoid parsing and binding things to names in one big function before creating the record.
11:17:21 <edwardk> > (1,2) & upon fst .~ 10
11:17:23 <lambdabot>   (10,2)
11:17:37 <Eduard_Munteanu> I'd also like to get a bit more type safety.
11:17:50 <watermind> but for INLINE I couldn't tell the rational because I expected it to look at other modules when compiling
11:17:56 * haasn shivers every time he looks at ‘upon’
11:18:37 <Zenol> edwardk: Thanks, it works with use :) What do you mean by " no cpu.registers.a     just 'a'" ?
11:19:24 <Eduard_Munteanu> Actually it would be nice to define a record containing parsers then use TH/Data/etc. to create the actual record with values from it.
11:19:28 <edwardk> Zenol: makeClassy ''Registers make a class for you
11:20:11 <edwardk> Zenol: it made    class HasRegisters t where registers :: Lens' t Registers; a :: Lens' t Word8; a = registers.a; ...
11:20:41 <edwardk> Zenol: when we make instance HasRegisters CPU where registers = cpuRegisters;    we get the a ,b, c, pc… members for free
11:20:59 <edwardk> so you can now 'use pc'  directly on your cpu without needing use (registers.pc)
11:21:07 <edwardk> we can chain this though
11:21:57 <edwardk> instance HasCPU VM where cpu = vmcpu; insance HasClock VM where clock = cpu.clock; instance HasRegisters VM where registers = cpu.registers; instance HasMMU VM where mmu = vmmmu
11:22:15 <edwardk> now you can use all the lenses for those 'substructures' directly on the VM!
11:22:32 <Zenol> edwardk: O.O Awesome!
11:23:29 <edwardk> Zenol: lens lets you compose lenses when you have to. the 'classy' lens style lets you avoid having to compose nearly so many. merely disambiguate when you have, say, multiple cpus or somthing in your machine
11:24:18 <edwardk> lens makes pretty emulator code. i've seen at least a half dozen emulators done with it so far =)
11:24:33 <joelteon> quite
11:24:38 <applicat1ve> callen i think you need a github cabal-dev maybe; by why bother install the dev-cabal so to speak, which has most of the same powers built in https://github.com/haskell/cabal/
11:25:30 <joelteon> I can verify that cabal sandbox is very useful
11:26:06 * applicat1ve is a believer
11:27:53 <callen> applicat1ve: you appear to not understand what cabal-dev is.
11:28:17 <callen> I need cabal-dev for per project library scoping and it's not installing.
11:28:48 <joelteon> cabal sandbox does that
11:29:09 <callen> Can someone please help me with this? This is fucking ridiculous. the first thing I went to do after installing Haskell platform was install cabal-dev and it failed http://lpaste.net/92333
11:29:39 <callen> joelteon: http://hackage.haskell.org/package/cabal-dev
11:29:51 <callen> so am I just fucked or what?
11:30:37 <lpaste> marai pasted “permutation function” at http://lpaste.net/92335
11:30:50 <applicat1ve> callen: cabal-dev is not a regular package; don't get it from hackage
11:31:08 <applicat1ve> callen: i know quite well what cabal-dev is
11:31:23 <donri> i just misread O(log n) as Oleg(n)
11:31:38 <JordiGH> There's something I don't understand here. Is this code ok? Isn't this testing over and over whether the same numbers are prime or not? Does each prime really only get tested once? http://codepad.org/HLkdZ2ix
11:32:12 <callen> applicat1ve: building it directly from source fails too.
11:32:21 <callen> so hackage and cloning the repo both fail.
11:32:32 <JordiGH> It seems to me that to generate primes !! 10, you have to first test if 2 is prime, which means generating the list for 2, then test if 3 is prime, which means generating the list up to 2, which means testing again if 2 is prime ...
11:32:38 <tromp__> yes, each number is tested once
11:32:51 <JordiGH> tromp__: Why? Is there some invisible memoisation going on?
11:33:00 <geekosaur> yes
11:33:02 <applicat1ve> callen: yes, i don't think its advisable to use it at all. use cabal sandbox
11:33:05 <tromp__> it's very visible
11:33:16 <tromp__> it's the primes list
11:33:26 <callen> applicat1ve: that's fine, but builds break all the fucking time with Haskell so I'd like to know, in terms of general principles, how to solve this problem.
11:33:34 <geekosaur> "invisible" if you're not aware of how Haskell evaluates `primes`
11:33:35 <monochrom> callen, I cannot reproduce your problem, builds and installs fine here. also just Haskell Platform.
11:33:36 <JordiGH> tromp__: It's pretty invisible to someone who is learning Haskell. Why isn't the primes list not regenerated each time?
11:33:38 <callen> because I'm just going to have to figure it out for the next package.
11:34:06 <tromp__> because it's a top-level definition; a so-called constant applicative form
11:34:43 <geekosaur> top level definition without parameters
11:34:55 <applicat1ve> callen: its very simple, install the github Cabal and the github cabal-install mentioned above; use cabal sandbox and you will never have these complaints again
11:35:03 <ski> JordiGH : each named thing (and more generally, each argument to a function) is cached, so as to not recompute it again, if referred to by its name (or by the variables bound by the pattern matched with it in the corresponding function definition)
11:35:12 <JordiGH> What's a plain constant? Is that the same as a constant applicative form?
11:35:16 <callen> applicat1ve: I'm not installing the github Cabal, I have haskell platform installed. I'm not fucking with it.
11:35:31 <callen> applicat1ve: if the Haskell platform can't build cabal dev and doesn't have sandbox, then I'm dead in the water.
11:35:42 <ski> JordiGH : strictly speaking, Haskell the language doesn't guarantee this caching, but all (major at least) implementations do this
11:36:09 <JordiGH> Alright.
11:36:34 <applicat1ve> callen: why do you even believe cabal-dev exists? the apparent package called by that name has *never* been properly maintained
11:36:51 <joelteon> alright
11:36:54 <joelteon> best of luck, then, callen
11:37:02 <ski> JordiGH : if you want more info, monochrom's <http://www.vex.net/~trebla/haskell/lazy.xhtml> might be useful
11:37:12 <monochrom> \∩/
11:37:14 <Sonarpulse> edwardk, I saw your bytes package. Is it eventually supposed to replace both cereal and binary?
11:37:25 <Sonarpulse> damn he left again
11:37:49 <JordiGH> Is "⊥ " read as "bottom" like is usual in logic?
11:37:56 <joelteon> yes
11:37:56 <monochrom> yes
11:38:07 <mcstar> "bottom space"
11:38:16 <ski> it's read as "bottom", but it's not to be interpreted as a logical constant connective of falsity/absurdity
11:38:20 <monochrom> although, does not mean "false" here, unlike in logic
11:38:26 <joelteon> ⊥
11:38:29 <ski> think "least element of a partial order"
11:38:35 <joelteon> gotta love weechat's completions
11:38:51 <Sonarpulse> Is there a deep reason why that's also the perpendicular symbol?
11:38:58 <monochrom> nice, what did you type in weechat?
11:39:03 <ski> Sonarpulse : i suspect not
11:39:05 <JordiGH> Sonarpulse: Because it's upside down of T which looks like "true" and is read "top".
11:39:07 <joelteon> i type bottom and press tab
11:39:12 <joelteon> and it goes ⊥
11:39:16 <joelteon> same with ∀
11:39:19 <monochrom> nice
11:39:32 <Sonarpulse> ok. A being...
11:39:48 <JordiGH> Sonarpulse: "All".
11:39:51 <ski> Sonarpulse : universal quantification, "for all/each/every"
11:40:19 <monochrom> ⊥ contains a pair of perpendicular lines. now, of course, + does too, but that's already taken
11:40:23 <Sonarpulse> you mean ∀ is forall.\
11:40:30 <ski> yep
11:40:31 <JordiGH> For all, two words.
11:40:42 <Sonarpulse> ....to much rankNtypes....
11:40:52 <JordiGH> Unless Haskell has its own forall function or something (not forAll?)
11:40:52 <applicat1ve> callen: http://article.gmane.org/gmane.comp.lang.haskell.cabal.devel/9636
11:41:04 <Sonarpulse> so then what is A?
11:41:08 <applicat1ve> callen: just do cabal install http://johantibell.com/files/Cabal-1.18.0.tar.gz http://johantibell.com/files/cabal-install-1.18.0.tar.gz from the command line and have done with it
11:41:08 <monochrom> unfortunately, ⊥ also has a line at the bottom, and so it's also apt for "bottom"
11:41:15 <Fuuzetsu> It's a letter…
11:41:21 <JordiGH> Sonarpulse: Capital letter A. There's no quantifier that's usually used with that symbol.
11:42:06 <Sonarpulse> Ok. "<joelteon> same with ∀" < I thought this was implying something other pun thing
11:42:17 <Fuuzetsu> applicat1ve: does it compile with GHC HEAD without any manual changes yet?
11:42:20 <monochrom> and now! in my thesis, I use my supervisor's notation, so ⊤and ⊥ are already taken for the booleans, and I need to choose another symbol for bottom.
11:42:21 <mcstar> reading fpcomplete's reflection, how is `reflect :: proxy s -> a` correct?
11:42:25 * applicat1ve is busily overwriting his cabal-install to prove its that simple
11:42:41 <applicat1ve> Fuuzetsu: oh i dont know
11:42:50 <monochrom> after a few minutes of search, I decided upon ⊡. for two reasons:
11:43:00 <Sonarpulse> monochrom: _||_ is it sometimes down like that?
11:43:37 <Fuuzetsu> It's sometimes _|_.
11:43:39 <hiptobecubic> why not T and F?
11:43:41 <monochrom> 1. the way I use bottom, it is more like "unused" or "hole". ⊡ looks close enough to a hole
11:43:55 <monochrom> T and F are not visually dual
11:44:15 <hiptobecubic> is that actually important for some reason?
11:44:23 <mcstar> i mean, is it possible to have a type parameter, `proxy` of kind * -> *, and that take a type parameter, `s` ?
11:44:26 <ski> JordiGH : a fun alternative is to define a list of the composites as multiples of primes with integers greater than one, and define primes simultaneously as the integers greater than one that are not primes
11:44:40 <monochrom> also, T and F are too close to just one interpretation of boolean algebra, "true" and "false". boolean algebra is more general than that.
11:44:41 <applicat1ve> callen: there, just did cabal install http://johantibell.com/files/Cabal-1.18.0.tar.gz http://johantibell.com/files/cabal-install-1.18.0.tar.gz and i have a shiny new cabal, overwritten by itself
11:45:33 <monochrom> anyway, 2. imagine a square with a verticle peg at the centre. if you look at it sideways, it's ⊥. if you look at it from above, it's ⊡. :)
11:45:39 <ski> er .. define primes simultaneously as the integers greater than one that are not *composites*
11:46:00 <applicat1ve> callen: oooo and now i have the new 'cabal repl' command
11:46:12 <tel> mcstar yeah, it is
11:46:38 <tel> mcstar I don't know if I understand the core well enough to be sure about this, but it might actually be necessary for it to be `proxy` not `Proxy`.
11:47:07 <mcstar> aok
11:47:29 <applicat1ve> wow this cabal repl is already seeming like a dream
11:47:32 <ski> mcstar : afaiu, `Proxy' would be ok, but `proxy' is more general
11:47:50 <tel> applicat1ve does anyone know how to get it working with emacs?
11:47:51 <elliott> Proxy would be fine
11:48:12 <tel> elliott ah, that's what I had thought but couldn't be sure
11:48:18 <ski> (and `proxy s' works since there can be at most one way of decomposing a type `t' into `t0 t1' -- which is sortof strange, but how it works in Haskell)
11:48:39 <haasn> ‘proxy’ lends itself to cute tricks, like using ([] :: [Int]) instead of importing Data.Proxy
11:49:42 <thoughtpolice> yes, i think 'proxy' makes it slightly easier to work with and shows the outer type constructor isn't really relevant anyway. i touched over this in the tutorial, maybe i should rearrange it and put the 'proxy s' part in another section
11:49:52 <thoughtpolice> since a few people have asked this
11:50:03 <applicat1ve> tel, dunno
11:50:20 <monochrom> what does "cabal repl" do?
11:50:27 <tel> Would it be possible to use Identity ~ proxy and have reflection change out the actual value you have?
11:50:47 <tel> I'm guessing yes, since it, ah, desugars to const
11:50:54 <thoughtpolice> monochrom: it starts GHCi on your Cabal project. does all the nice stuff; runs preprocessors, Paths_ stuff, etc etc
11:51:06 <shachaf> You can use Maybe, in general.
11:51:08 <geekosaur> ooh, that's finally in!
11:51:11 <thoughtpolice> basically what 'cabal-dev ghci' did (i think, i never used cabal-dev)
11:51:12 <shachaf> Either you have a value, or you don't.
11:51:26 <turiya> is there a function which can give me a sorted list and the permuted indices?
11:51:37 <haasn> thoughtpolice: wooh!
11:52:13 <ski> turiya : `sortBy (comparing snd) . zip [0 ..]' ?
11:52:28 <applicat1ve> monochrom: i'm trying to figure it out; cabal repl --help is not too awesome.
11:52:29 <mcstar> thoughtpolice: it is my VERY bad habit to try to understand something when im stuck, and not skip over it, i know its stupid
11:52:48 <ski> > (sortBy (comparing snd) . zip [0 ..]) (words "This is a dream")
11:52:49 <lambdabot>   [(0,"This"),(2,"a"),(3,"dream"),(1,"is")]
11:52:53 <turiya> ski: i will try that.. at first glance i dont understand what it does..
11:53:48 <adnap> thoughtpolice: "does all the nice stuff" huh?
11:53:51 <ski> `comparing' is a simple tool that allows you to "focus" on some part of the values that you'd like to `compare'
11:53:57 <ski> @type compare
11:53:58 <lambdabot> Ord a => a -> a -> Ordering
11:53:59 <ski> @type comparing
11:53:59 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:54:10 <applicat1ve> monochrom: but for example, if you are in a cabalized directory and just type cabal repl, a ghci will all the exposed modules will open ... which may be a bit much
11:54:19 <thoughtpolice> adnap: Cabal has to do certain things for projects like run preprocessors, generate Paths_ files, and generally making GHCi do this itself (or doing it manually) sucks and is error prone
11:54:45 <thoughtpolice> projects tend to make slight hacky shell scripts to load their project into GHCi instead. cabal repl just makes that all go away
11:54:55 <Zenol> No instance for (HGB.Types.HasRegisters CPU) arising from a use of `pc' :(
11:54:57 * hackagebot set-cover 0.0 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  http://hackage.haskell.org/package/set-cover-0.0 (HenningThielemann)
11:55:03 <turiya> thanks, where is comparing defined?
11:55:04 <monochrom> nice, thanks thoughtpolice
11:55:17 <mcstar> @hoogle comparing
11:55:18 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:55:40 <adnap> thoughtpolice: I did not know my projects run in GHCI when I run cabal
11:55:46 <turiya> nice
11:55:53 <Sonarpulse> if you make two ForeignPtrs from same Ptr? will the object be collected when either goes out of scope or when both go out of scope
11:55:55 <newbie_> hello. I have a function in :: (Double, Double) -> (Double, Double) -> Bool that takes two pair of points and returns true, if these lines intersects. How can i implement it?
11:56:57 <applicat1ve> those are two points, not two lines, or am i in a muddle?
11:57:08 <adnap> newbie_: Two points specifies one line
11:57:18 <newbie_> adnap: yes
11:57:34 <adnap> newbie_: You need two lines to test for intersection of lines
11:57:37 <mcstar> ah, ok `reify :: forall a r. ` the forall is not necessary here, since it is always implied
11:57:45 <newbie_> adnap: again yes
11:57:58 <adnap> newbie_: So, your function needs four points
11:58:19 <mcstar> two not coinciding points always form a line
11:58:24 <applicat1ve> maybe three points
11:58:34 <applicat1ve> are they collinear
11:58:49 <adnap> Two lines can intersect at a point, so three points wont always work
11:59:02 <adnap> Also, degenerate points will screw up even a 4-point function
11:59:16 <applicat1ve> i was just thinking of another function to bring out the trouble
11:59:28 <mcstar> Double trouble, even
11:59:34 <adnap> I prefer to represent a line as a point and a vector
11:59:40 <monochrom> Sonarpulse: that sounds like a pseudo-question. when the first ForeignPtr goes out of scope, its finalizer will be run later. when the second ForeignPtr goes out of scope, its finalizer will be run later. so far, nothing says what's wrong with that, or what's right with that, or even what that has to do with the Ptr for that matter. it depends on what you actually do in those two finalizers.
11:59:43 <adnap> But you can make the vector by subtracting two points
11:59:43 <Zenol> With makeClassy, should I create the instances of HasType myself?
12:00:02 <newbie_> adnap: or two pair of points. What do i want : (1, 2) and (4, 5) -> True (no intersect), (1, 4) and (2, 5) -> False
12:00:33 <adnap> newbie_: Are these lines in 1-d or something?
12:00:40 <newbie_> adnap: y
12:00:44 <adnap> Oh
12:01:07 <mcstar> i think he writes axis intersections
12:01:20 <mcstar> whats that called?
12:01:25 <newbie_> it is much simplier
12:02:05 <ski> oh, it appears newbie_ aren't talking about lines, but about line segments ?
12:02:14 <mcstar> intercepts!
12:02:16 <adnap> He is talking about 1-d intervals
12:02:19 <ski> (or "intervals", if you prefer)
12:02:24 <mcstar> oh
12:02:27 <mcstar> sure?
12:02:31 <applicat1ve> ski: yes intervals its becoming clearer
12:02:32 <newbie_> yea
12:02:37 <ski> mcstar : see the last example
12:03:07 <applicat1ve> but now, how do we write it
12:03:11 <ski> newbie_ : and how about `in (1,2) (2,3)' then ?
12:04:00 <applicat1ve> True ... or *False*?
12:04:08 <ski> yes
12:04:28 * applicat1ve pleas for False somehow
12:04:43 <newbie_> ski: can you write full definition please?
12:04:48 <ski> also, what about `in (0,3) (4,2)' ?
12:04:48 <mcstar> > isect (a,b) (c,d) = c <= b
12:04:49 <lambdabot>   <hint>:1:19: parse error on input `='
12:04:57 * hackagebot hsbencher 1.3.9 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.3.9 (RyanNewton)
12:05:04 <mcstar> > isect (a,b) (c,d) = c <= b in isect (1,4) (2,5)
12:05:05 <ski> newbie_ : not unless i know what behaviour the function should have in such corner cases
12:05:05 <lambdabot>   <hint>:1:19: parse error on input `='
12:05:10 <applicat1ve> newbie_: hey, that *your* exercise, ski is just framing things for you ,... ;)
12:05:11 <mcstar> > let isect (a,b) (c,d) = c <= b in isect (1,4) (2,5)
12:05:12 <lambdabot>   True
12:05:21 <adnap> @define intersect (x_0, x_1) (y_0, y_1) = y_0 < x_1 && x_0 <= y_1
12:05:22 <lambdabot>  Defined.
12:05:28 <monochrom> ski: toss a coin for corner cases :)
12:05:34 <newbie_> uh, sorry
12:05:40 <applicat1ve> we dont do that in haskell, monochrom
12:05:43 <adnap> > intersect (1,4) (2,5)
12:05:44 <lambdabot>   Ambiguous occurrence `intersect'
12:05:44 <lambdabot>  It could refer to either `L.intersect', d...
12:05:46 <ski> monochrom : or perhaps appeal to the axiom-of-choice :)
12:05:49 <adnap> > L.intersect (1,4) (2,5)
12:05:53 <Sonarpulse> monochrom: asumming the finalizer actually deallocate the object, no reference counting or anything
12:05:54 <lambdabot>   True
12:06:09 <adnap> > L.intersect (1,4) (4,5)
12:06:09 <newbie_> misunderstood. When (1, 2) and (2, 3) -> True (no intersect)
12:06:12 <lambdabot>   False
12:06:40 <adnap> > L.intersect (1,4) (-2,1)
12:06:42 <monochrom> well then, deallocating the 2nd time is bad, but it happens when both ForeignPtrs go out
12:06:43 <lambdabot>   True
12:06:45 <ski> newbie_ : and `in (0,3) (4,2)' ?
12:06:56 <adnap> > L.intersect (0,3) (4,2)
12:06:59 <lambdabot>   False
12:07:20 <newbie_> ski: assuming that second arg in tuple is always greater then first
12:07:21 <applicat1ve> this ski character is cruel!
12:07:23 <Sonarpulse> I guess the better question is does the GC realize both references refer to the same memory
12:07:31 <ski> applicat1ve : ty
12:07:38 <monochrom> applicat1ve: you can toss a coin yourself at program-writing time
12:07:49 <applicat1ve> oh ok monochrom
12:07:51 <adnap> @undefine
12:07:51 <lambdabot> Undefined.
12:07:56 <adnap> @define intersect (x_0, x_1) (y_0, y_1) = y_0 <= x_1 && x_0 <= y_1
12:07:56 <lambdabot>  Defined.
12:08:03 <monochrom> you know, that xkcd reference about "random number" and whatnot
12:08:09 <ski> newbie_ : so `in (3,5) (4,4)' is also inadmissible then, yes ?
12:08:09 <adnap> > L.intersect (1,4) (4,5)
12:08:13 <lambdabot>   True
12:08:22 <newbie_> ski: yes
12:08:23 <adnap> > L.intersect (1,4) (-2,1)
12:08:26 <lambdabot>   True
12:08:32 <Sonarpulse> monochrome: oh, didn't see your second answer. So all finalizers are run, but only after all ForeignPtrs to the same memory are dead?
12:08:37 <Sonarpulse> *monochrom
12:08:46 <adnap> newbie_: The above works. I assume you want the intervals to be inclusive
12:09:00 <monochrom> no. each finalizer is run after each ForeignPtr is dead
12:09:01 <jophish> Yo yo yo
12:09:23 <Sonarpulse> Ok.
12:09:43 <ski> newbie_ : it may help if you draw some example couple of intervals on a piece of paper, trying to cover all cases. then try to convert that into code (perhaps first writing pure math, instead of Haskell, if you prefer), checking all your examples then that they give the expected result
12:09:51 <Sonarpulse> I'm just adding some documentation then that after you make the ForeignPtr, you should not use the original ptr value then, because it is not safe.
12:09:56 <Sonarpulse> Thanks so much!
12:10:16 <jophish> I have a data X = X Bool, I'd really like to enforce that this bool is always True, Is there an idiomatic way of doing this? (My example is a little more complicated, but is the same scenario)
12:10:52 <Sonarpulse> jophish: what are you really trying to do?
12:11:08 <Sonarpulse> you can hide the X constructor
12:11:10 <newbie_> ski: i just want to look at working example to understand logic and syntax, it is not the final task for me.
12:11:22 <jophish> a better fit for my example would be: data Y = A Bool | B; data X = A Bool
12:11:24 <ski> newbie_ : you may consider different cases like "the left endpoint of the first interval can either be lesser than, equal to, or greater than the left endpoint of the second interval" -- then proceed for each of those cases by also considering all the possible relations with the other endpoints
12:12:10 <Sonarpulse> You want like some sort of subtyping thing?
12:12:23 <jophish> Sonarpulse: I'm using llvm-general, I'd like to make a data type which holds onto a FunctionType, instead of any Type: http://bscarlet.github.io/llvm-general/3.3.8.0/doc/html/llvm-general-pure/LLVM-General-AST-Type.html
12:12:37 <adnap> > map (uncurry L.intersect) [ ((x_0, x_0 + 1), (1, 2)) | x_0 <- [-5..5] ]
12:12:41 <lambdabot>   [False,False,False,False,False,True,True,True,False,False,False]
12:12:48 <Sonarpulse> getting a 503 error
12:13:05 <mcstar> you still need your pairs to be ordered though
12:13:21 <ski> jophish : "Error 503 Backend is unhealthy  Backend is unhealthy  Guru Meditation:  XID: 1704124062"
12:13:32 * ski smiles at the guru
12:13:43 <jophish> hmm, seems to be a github error. I'll find another page
12:14:02 <jophish> https://github.com/bscarlet/llvm-general/blob/master/llvm-general-pure/src/LLVM/General/AST/Type.hs
12:14:11 <newbie_> ski: in simple language it is like: def (x0, y0, x1, y1): not ((x1 < x0 < y1) and (x1 < y0 < y1))
12:14:16 <simukis_> is [1..5] in some sense a Coalgebra?
12:14:26 <adnap> newbie_: intersect (x_0, x_1) (y_0, y_1) = y_0 <= x_1 && x_0 <= y_1
12:14:34 <ski> newbie_ : ok. in Haskell, `and' for booleans is `&&', and `not' is just `not'
12:14:37 <S11001001> jophish: put Type [Type] Bool in your data constructor
12:14:47 <Zenol> Ooooh, makeClassy transforms CPU into cPU in HasCPU :/
12:14:54 <ski> newbie_ : you can't say `a < b < c', but you can say e.g. `a < b && b < c'
12:14:54 <turiya> ski: after several glances, I finally understand!
12:15:04 <ski> turiya : yay :)
12:15:21 <jophish> S11001001: That seems to be just duplicating the code from llvm-general
12:15:31 <S11001001> jophish: FunctionType is not a "subtype" of Type.
12:15:38 <jophish> sure, I understand taht
12:15:52 <ski> newbie_ : i hope you know the basic syntax of function definition, yes ?  like `square x = x * x'
12:15:53 <jophish> I'm wondering about the idiomatic way of doing that I want
12:16:08 <newbie_> adnap: that works, thanks a lot
12:16:09 <mcstar> > 1 < 2 < 3
12:16:10 <lambdabot>   Precedence parsing error
12:16:10 <lambdabot>      cannot mix `GHC.Classes.<' [infix 4] and `GHC...
12:16:26 <mcstar> i wonder why is this a parse error, since i'd say its a type error
12:16:31 <newbie_> ski: i read some therory, but crashed on practice
12:16:33 <adnap> lol
12:16:37 <jophish> another example would be to define a function which only takes FunctionType objects, instead of any Type
12:16:59 <mcstar> > 1 + 2 + 3 -- works
12:17:00 <lambdabot>   6
12:17:03 <ski> jophish : simplest is perhaps to say `data X = FunctionType {resultType :: Type,argumentTypes :: [Type],isVarArg :: Bool}', or something similar
12:17:14 <Sonarpulse> FunctionType currentl is just a date constructor
12:17:21 <newbie_> ski: i know what do i want to do, i can write that on paper, but i cant turn that into Haskell /=
12:17:27 <Sonarpulse> not it's own type. Which I think you get
12:17:27 <ski> mcstar : parsing is completed before typing begins
12:17:30 <Sonarpulse> ski is write
12:17:38 <Sonarpulse> nothing better than duplicating the code
12:17:40 <S11001001> jophish: the idiomatic way is ski's suggestion
12:17:49 <mcstar> ski: ok, but what's different between < and + ?
12:18:00 <mcstar> :i (+)
12:18:03 <jophish> alrighty then
12:18:06 <ski> mcstar : generally, it simplifies understanding parsing, to know that it's not affected by typing
12:18:13 <jophish> thanks S11001001, Sonarpulse, ski
12:18:36 <Sonarpulse> relatedly, I wonder what Haskell would be like with only tuples, unions, and newtype
12:18:37 <ski> mcstar : `+' is `infixl' (left-associative), but `<' is `infix' (non-associative)
12:18:43 <mcstar> ski: isnt the problem is that + is infixl, and < is infix?
12:18:45 <simukis_> mcstar: because GHC has some trouble constructing an AST with same precedence functions I think (not sure).
12:18:49 <mcstar> ok
12:19:23 <ski> newbie_ : so what do you have so far ?
12:19:24 <monochrom> eh, + is at 6, < is at 4, not even on the same level, why are you comparing?
12:19:39 <WraithM> mcstar: that's what ski said.
12:19:43 <mcstar> the exact level of precendence does not matter
12:19:48 <mcstar> precedence*
12:19:53 <Sonarpulse> eh wouldn't work if two unioned tuples have same type
12:19:56 * ski . o O ( s/ki/he/ )
12:20:02 <mcstar> WraithM: i read what ski said after i pressed enter
12:20:32 <WraithM> mcstar: :) All good
12:20:36 <monochrom> oh! you're comparing a+b+c and a<b<c. I see now.
12:20:42 * ski nods
12:21:11 <newbie_> ski: i want to implement some well-known algorithms, started from basic Haskell code.
12:21:50 <monochrom> well-known algorithms are biased towards anti-Haskell
12:22:27 <newbie_> monochrom: even graphs and trees?
12:22:34 <monochrom> yes absolutely
12:23:05 <ski> newbie_ : do you understand how `square x = x * x' corresponds to `f(x) = x·x' ?
12:23:06 <DanBurton> you could define your own data ComparisonChain a = Failed | Currently a. Failed < a = Failed; Currently a < Currently b = if (a `numericLessThan` b) then Currently b else Failed, and toBool Failed = False; toBool (Currently a) = True
12:23:13 <newbie_> ski: yes
12:24:05 <ski> newbie_ : then how far have you come with expressing in Haskell this function that determines whether two intervals (in your sense) intersects ?
12:24:15 <newbie_> ski: in my book, i have read up to monads, but those are hard nut
12:24:18 <monochrom> to be fair, it is possible to write anti-Haskell in Haskell, too. but the result is not remotely basic-Haskell.
12:24:18 <ski> could you perhaps show the code you have, so far ?
12:24:26 <ski> monads shouldn't be required for this
12:24:37 <ski> @paste
12:24:37 <lambdabot> Haskell pastebin: http://lpaste.net/
12:24:41 <ski> e.g.
12:25:39 <newbie_> ski: i'm just learning. And seems like i ll need monad later, to implement some states
12:25:47 <adnap> Is there a way to take a value and convert it to the String given by :t in GHCI?
12:26:22 <ski> DanBurton : istr some variant where `a < b' either gave a least (or greatest ?) value, or one of the arguments (for further comparision)
12:26:59 <kier> adnap: there might be something providing that in the syb package / Data.Generics module
12:27:53 <ski> newbie_ : yes, you're learning. it would be good if you could show us the code you have so far (correct or incorrect), so that we can suggest improvements on it, and to discuss potential problems with it, perhaps also explaining some issues in your understanding that it possibly makes apparent
12:27:55 <adnap> kier: I think there is something in Data.Typeable
12:28:10 <dreixel___> adnap: yes, I think show . typeOf
12:28:25 <adnap> dreixel: Yes
12:28:27 <Zenol> instance HasCpu Vm where cpu = vmCpu -> I have to write it by hand? :/
12:28:36 <adnap> > show . typeOf $ 3
12:28:37 <lambdabot>   "Integer"
12:28:52 <ski> newbie_ : `def (x0, y0, x1, y1): not ((x1 < x0 < y1) and (x1 < y0 < y1))' is one example of such a snippet of code -- but if you have something closer to real Haskell, that would be better
12:28:55 <adnap> > show . typeOf $ pure 3
12:28:56 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
12:28:56 <lambdabot>    arising from a use ...
12:29:01 <TallerGhostWalt> show . typeOf
12:29:07 <TallerGhostWalt> show . typeOf  3.0
12:29:11 <kier> adnap: mhmm, for some reason I was thinking that the Data & Typeable classes were (still) defined in syb
12:29:15 <adnap> > show . typeOf $ (pure 3 :: [Int])
12:29:16 <lambdabot>   "[Int]"
12:29:28 <dreixel> nope, Data is in Data.Data, and Typeable in Data.Typeable
12:29:33 <mcstar> > typeOf (show . typeOf)
12:29:34 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:29:34 <lambdabot>    arising from a use ...
12:29:38 <adnap> When is auto-deriving Typeable going to happen?
12:29:46 <ski> newbie_ : in any case, forget about monads for the time being
12:29:50 <adnap> In the sense that one wont even have to "deriving Typeable"
12:29:54 <newbie_> ski: i have wrote only 6 lines, including intersecting. There are nothing to show yet, but thanks for an suggestion
12:30:03 <turiya> ski: is there something simple for the reverse permutation?
12:30:09 <dreixel> adnap: 7.8, September
12:30:20 <dreixel> -XAutoDeriveTypeable
12:31:16 <adnap> dreixel: Okay. I also am waiting for... something to do with DynFlags
12:31:26 <ski> newbie_ : well, even your "nothing to show yet" code may be helpful for us to look at, to suggest improvements, and so that we can easier tell what you appear to be having trouble with
12:31:29 <jfischoff> does anyone have an example make file for a haskell project I could checkout?
12:31:52 <monochrom> comparing two intervals does not need monad. it's just a lot of < > = || &&
12:31:53 <ski> newbie_ : we are not mind-readers, you have to provide some info for us to work on
12:31:54 <adnap> jfischoff: ghc --make usually works
12:31:59 <amyers> jfischoff: Why not use cabal?
12:32:21 <jfischoff> no -j
12:32:29 <adnap> jfischoff: I was using a Makefile where the main rule was pretty much ghc --make
12:32:32 <ski> turiya : not sure if there's anything simpler available than retagging with new indices, and then sorting on the old ones
12:32:55 <jfischoff> adnap: not what I am looking for
12:33:24 <adnap> jfischoff: http://pastebin.com/06db04mH
12:33:28 <mauke> The paste 06db04mH has been copied to http://lpaste.net/92337
12:33:53 <monochrom> the GHC user's guide has a section on using make, with a sample makefile. section 4.7.10. it's somewhere on your hard disk.
12:34:24 <ski> newbie_ : what do you say, won't you show your in-progress code ? you don't need to be shy
12:34:30 <jfischoff> monochrom: yeah, but I was looking for more examples
12:34:36 <monochrom> I see
12:35:16 <newbie_> ski: yes, but i have to do some stuff yourself, for better learning. When i meet something incomprehensible, sure, i ll ask here =)
12:35:29 <newbie_> going to code all night long
12:36:04 <ski> newbie_ : well, as long as you continue making progress ..
12:36:22 <turiya> ski: not quite sure what you meant
12:38:53 <ski> > (sortBy (comparing snd) . zip [0 ..]) (words "This is a dream")
12:38:54 <lambdabot>   [(0,"This"),(2,"a"),(3,"dream"),(1,"is")]
12:38:56 <ski> > let sorted = (sortBy (comparing snd) . zip [0 ..]) (words "This is a dream") in (map (\(i,(_,x)) -> (i,x)) . sortBy (comparing (fst . snd)) . zip [0 ..]) sorted
12:38:57 <lambdabot>   [(0,"This"),(3,"is"),(1,"a"),(2,"dream")]
12:39:02 <ski> turiya : like that
12:39:34 <ski> (and `\(i,(_,x)) -> (i,x)' is `second snd', if you prefer)
12:39:56 <turiya> ski: thanks, I will study this
12:40:38 <ski> it's simply adding new indices on the sorted list, then sorting again on the old indices (restoring the original ordering), then (as a convenience) removing the original indices
12:40:57 <ski> there's possibly a better way of doing this than re-sorting
12:42:06 <turiya> i see, i belive there should be
12:42:42 <sm> jfischoff: you'll find a lot of wacky makefiles in my repos at http://hub.darcs.net/simon
12:42:53 <jfischoff> thanks
12:48:00 <JohnTerryCFC791> Hello!
12:48:03 <JohnTerryCFC791> Wanted to share a new programming forum/community: http://thedevshed.net/forum/ :)
12:48:08 <monochrom> w00t http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
12:48:11 <JohnTerryCFC791> Feel free to join!
12:49:18 <mm_freak_> i'd love something like that for android
12:49:36 <mm_freak_> throughout the years of haskell experience i lost my ability to get anything done in java
12:49:45 <monochrom> to be fair, it was commercially funded
12:50:06 <mm_freak_> which is great
12:51:06 <monochrom> there is a bit of commercial interest in "haskell on iOS" i.e. iPwn Studio. there is still no commercial interest in "haskell on Android"
12:51:37 <monochrom> this is why I'm over 40 and I'd better believe in capitalism
12:52:09 <ski> re newbie_
12:52:30 <monochrom> at least, today, there are kickstarter and the like, unlike 40 years ago
12:56:12 <sclv> monochrom: ipwn is no more
12:56:25 <monochrom> ah hrm
12:56:26 <sclv> and i think the "last 90%" was done post ipwn
12:56:34 <monochrom> I see
12:56:36 <sclv> although they did the "first 90%"
12:56:55 <c_wraith> blackh did say that most of the iOS work they've done is applicable to android, too.
12:57:02 <monochrom> it's more 90%s all the way down :)
12:57:11 <sclv> in general its about multi-target cross compiler stuff
12:57:13 <c_wraith> Which I assume is just things like ARM support and cross-compiling
12:57:18 <sclv> so the improvements go towards all teh backends
12:58:12 <LazinCajun> I guess this is asking a biased audience, but do you guys buy all the talk that functional programming is really the way of the future with hardware trends allowing for more parallelism etc?
12:58:38 <mm_freak_> LazinCajun: yes, since i use it
12:59:09 <c_wraith> eh. laziness seems to make parallelism a lot harder. I prefer to talk about things like correctness and abstraction
12:59:27 <acomar_> lazincajun: that's a very loaded question...
12:59:32 <LazinCajun> i'm aware :)
12:59:47 <LazinCajun> i was just curious what kind of responses I'd get.  I'm not going to hold anybody accountable
12:59:56 <tiffany> lazin: FP makes safe concurrency easier
12:59:58 * hackagebot monoid-extras 0.3.2.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.2.0 (BrentYorgey)
13:00:06 <mm_freak_> c_wraith: laziness makes concurrency harder, not parallelism
13:01:34 <c_wraith> mm_freak_: no, it makes parallelism harder too.  It's easy to write code that does absolutely nothing in the parallelism because the evaluation strategy isn't right.
13:01:35 <haasn> it's hard to imagine something like rpar even existing in a strict language
13:01:49 <haasn> if arguments get strictly evaluated before they ever reach ‘rpar’
13:02:03 <haasn> err, par
13:02:05 <haasn> not rpar
13:02:13 <c_wraith> mm_freak_: in fact, doing so is a relatively common thing for people to ask about in here.  "why didn't this get a speedup when I used par?"
13:02:25 <Zenol> how should be writen byte "<- fmap rb $ use mmu" ?
13:02:25 <simon> haasn, what is rpar?
13:02:28 <mm_freak_> c_wraith: there is a theoretical possibility, but it didn't happen to me, despite my heavy use of parallel strategies
13:02:32 <monochrom> I don't buy "is the way of the future". I buy "is the way now, in fact last year too, and I'm already using it"
13:02:45 <mm_freak_> c_wraith: one thing to note is that you need to understand haskell to understand how to get parallelism right
13:02:50 <haasn> simon: http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html#v:rpar
13:02:57 <c_wraith> mm_freak_: it's hardly theoretical.  I've seen people asking about it a bunch of times.
13:03:02 <monochrom> as for the future, it'd better be even better than functional programming
13:03:38 <donri> obviously the future is a dependently typed lisp that runs on GPUs, duh!
13:03:58 <monochrom> that would be not too shabby
13:04:29 <c_wraith> There were some interesting ideas in Tony Morris's thread on the future of programming languages in the scala newsgroup.
13:05:01 <monochrom> anyway I don't understand people who speak like "lexical scoping is the way of the future"
13:05:30 <applicative> regular expressions are the way of the future
13:05:46 <c_wraith> One of those ideas was the functions are too inherently linear to be the basis of really parallel programming.  It made me think.  And that's a good sign.
13:06:32 <applicative> what is the alternative to functions that is not linear? associative 2 place functions?
13:06:42 <mm_freak_> i liked heinrich apfelmus' recent article about denotational semantics
13:06:54 <monochrom> mm_freak_: w00t, where where?
13:06:55 <mm_freak_> it's not directly related, but it extends into that area as well
13:07:25 <mm_freak_> http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
13:07:32 <applicative> LazinCajun: i think the usual Haskell story line is that purity makes parallelism easier
13:07:59 <monochrom> hrm, that is not my interpretation (pun!) of that article
13:08:11 <mm_freak_> monochrom: hehe
13:08:18 <applicative> i could do with more denotational semantics like that
13:08:20 <c_wraith> applicative: one of the examples was base a language on pi calculus explicitly.
13:08:29 <adsfd> http://www.dukascopy.com/tradercontest/?action=blog&trader=Grizzly
13:08:31 <monochrom> in fact my interpretation is "denotational semantics is not enough"
13:08:44 <mm_freak_> monochrom: exactly
13:09:06 <mm_freak_> in fact denotational semantics says nothing about parallelism
13:09:10 <dgpratt> what's the more correct (in terms of attribution) term for currying? schonkelfinkersomething?
13:09:21 <applicative> schonfinkelization
13:09:32 <dgpratt> applicative, thanks :)
13:09:43 <ski> Schönfinkelization
13:09:58 <ski> or `oe' instead of `ö', if you don't like umlauts
13:10:00 <applicative> yes my alt-umlauter isn't working in irssi
13:10:01 <mm_freak_> schönfinkelisation
13:11:28 <niteria> it would be nice if space invariants were encoded in the type
13:11:41 <applicative> dgpratt: http://www.cynic.net/tsac.html vs. http://www.starling-software.com/en/tsac.html
13:13:14 <applicative> "The TSAC should not be confused with the Tokyo Society for the Application of Currying, who very mistakenly refer to Schönfinkelisation as currying. "
13:13:56 <applicative> maybe we should introduce shoenfinkelize and unschoenfinkelize for strict pairs?
13:13:59 <mm_freak_> niteria: what would that look like?
13:14:23 <applicative> surely Moses Schoenfinkel didn't believe in lazy tuples!
13:14:30 <ski> dgpratt : also see <http://en.wikipedia.org/wiki/Stigler%27s_law_of_eponymy>
13:14:31 <resnik> git c_wraith: can you link us to that tony morris thread?
13:14:41 <tel> I'd totally use `schoen`/`unschoen`
13:15:01 <tel> (not actually true)
13:15:06 <mm_freak_> niteria: Func (x : A) (Complexity x) B?
13:15:20 <applicative> unschoen would actually be really useful
13:15:32 <mm_freak_> unschoen =)
13:15:42 <niteria> mm_freak_: I have no idea, I've seen some attempts at having complexity in the types, it even worked with amortization
13:16:36 <dgpratt> thanks for the references, applicative
13:16:37 <applicative> unschön would be quite schön on reflection
13:16:50 <dgpratt> ski, lol, I hadn't heard of that before
13:16:55 <tel> applicative++
13:17:05 <ski> `(a : A) -> B in O(..a..)' mayhaps
13:20:20 <ibotty> great discussion. i have never heard of schönfinkelization. it sounds very useful. and what's the difference to curry again? (for haskell!)
13:22:33 <aristid> ibotty: it's the exact same thing.
13:22:42 <applicative> its subtle, like the difference between the T.S.A.C. and TSAC http://www.cynic.net/tsac.html
13:23:04 <tel> ibotty nothing, really, unless you define schönfinkelization to work on strict pairs instead of lazy (,)s
13:23:11 <tel> but that's not conventional or anything
13:23:23 <applicative> thats what we were imagining above, aristid
13:23:42 <aristid> applicative: but?
13:23:45 <applicative> after I define StrictPair or whatever I always end up with kurry and unkurry
13:24:03 <aristid> fortunately unicode is allowed in haskell
13:24:09 <applicative> but these should be schoen and unschoen; so i resolve.
13:24:10 <aristid> so schönfinkelise it is.
13:24:41 <applicative> yes, but alt-u isn't working in my terminal :(
13:24:41 <Cale> ibotty: Schönfinkel was another person responsible for the concept (who Curry attributed it to) so some have suggested that "currying" should instead be called "schönfinkeling".
13:24:47 <tel> they should go the opposite way, too, just to ensure you're paying attention. schoen :: (a -> b -> c) -> (P a b -> c)
13:24:56 <Cale> But apparently it had been used by Frege even before that.
13:24:59 <aristid> applicative: just use alt-p
13:24:59 * hackagebot GLUtil 0.6.7 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.7 (AnthonyCowley)
13:25:05 <applicative> yes Frege had currying
13:25:11 <tel> fregging
13:25:28 <tel> fregate/unfregate
13:25:51 <ibotty> well. fregen it should be then. he was german after all
13:25:56 <applicative> if we named everything Fregean after Frege we'd have too much overloading
13:26:05 <ibotty> :D
13:26:11 <Cale> and so almost nothing ends up named after him
13:27:24 <applicative> {-#LANGUAGE ExistentialFregeanization#-} for starters
13:27:58 * chrisdone gets a bier from the frege
13:28:29 <tel> hahah
13:28:38 <ibotty> aristid: as you are here. are you in the mood to speak about aws?
13:28:40 <tel> that actually succeeds in making that extension even scarier sounding
13:28:57 <ibotty> applicative, chrisdone: :D
13:29:01 <aristid> ibotty: well, sure.
13:30:14 <ibotty> so, as i kind of told in the bug report you answered, i am writing some mws functionality. it's the first time i use aws, so i'm not yet into it.
13:30:30 <ibotty> each request to mws should include a sellers id header
13:30:53 <ibotty> should that header now be part of SignedQueries sqOtherHeaders?
13:31:20 <aristid> ibotty: i believe so, yes
13:31:44 <mcstar> Haskell didnt like his name
13:32:54 <Fuuzetsu> Haskell featured on Computerphile today https://www.youtube.com/watch?v=sqV3pL5x8PI
13:33:02 <chrisdone> i bet *alonzo* loved his
13:33:22 <chrisdone> is that the spanish version of alan, i wonder?
13:33:54 <aristid> ibotty: i think you should first try to get a straight-forward mapping of the REST API calls in mws to request/response type pairs, and only then worry about the higher-level stuff you were talking about
13:34:42 <mcstar> 'The compiler then manually plumbs around the correct dictionaries at the call site of lorem' oooh
13:35:02 <aristid> chrisdone: wiktionary says it's a variant of Alfonso
13:35:48 * applicative remembers a document in which it is revealed that he was called Bunzeo and 'Bunzeo-just-the-same' as a child...
13:35:57 <aristid> chrisdone: so Alonzo/Alfonso apparently have a germanic root, and the root of Alan is celtic.
13:37:15 <ski> Cale : hm, any idea which work by Frege ?
13:37:58 <Cale> ski: I'm not sure
13:39:31 <ski> i wonder if it might be "Über Funktion und Begriff" -- though i don't recall seeing the concept in there
13:39:34 <ibotty> aristid: that's what i did (for the feeds part of mws). afaict the requests will serialize to the right thing. i don't really know for sure though, because i'm just writing the infrastructure around it. i'm not yet on higher level api :).
13:40:29 <ski> (though, iirc, he has some higher-order function example)
13:42:22 <mcstar> omg, around 2006 #haskell had 3000 nicks?
13:43:05 <ski> not that i recall
13:43:17 <Cale> mcstar: More like around 300
13:43:21 <WraithM> Source?
13:43:31 <mcstar> SPJ presentation, there's a bar-chart
13:43:38 <Cale> The nick counter has only gone up
13:43:48 <mcstar> its hard to understand what he says
13:44:27 <mcstar> 'at any moment there was a couple hundred users logged in' thats what he says
13:44:27 <Cale> oh, maybe 3000 unique nicks, rather than concurrent
13:44:36 <Zenol> Is use c >>= (\b' -> b .= b') simplifiable?
13:44:49 <mcstar> for the whole year, ok
13:45:07 <Cale> Well, you could write (b .=) =<< c
13:45:36 <Cale> Not sure if clearer
13:45:43 <Eduard_Munteanu> It's a bubble. :P
13:45:56 <Zenol> er, yeh. I was hopping there was on operator so that i can write c ???? b :/
13:46:07 <Cale> Well, what's .=?
13:46:24 <ski> Zenol : define `c ???? b = (b .=) =<< c' ?
13:46:40 <Zenol> Cale: Len's .= operator (.~ but in a state monad)
13:47:31 <Cale> Oh, right. I tend to not use lens' infix operators.
13:47:51 <Cale> I wouldn't be too surprised if it had something for that...
13:48:41 <Cale> There is <~
13:49:20 <Cale> (<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
13:49:59 <Cale> So perhaps  b <~ c  is what you want.
13:50:05 <Zenol> Cale:  (b <~ use c) yeh, thanks :D
13:50:07 <Cale> yeah
13:51:10 <monochrom> 3000 nicks is a lot of nicks :)
13:52:48 <Cale> Many of them were a secret bot run by dons to occasionally join the channel with a nick that hadn't appeared before. ;)
13:53:21 <Cale> But yeah, it's interesting to see how many non-idlers there are.
13:53:30 <thr33strikes> is there a command in haskell that will let me manipulate the names of files that is not OS specific?
13:53:54 <Cale> renameFile :: FilePath -> FilePath -> IO ()
13:54:02 <sm> from the filepath package
13:54:04 <Cale> In System.Directory
13:54:14 <Cale> Which is in directory
13:54:16 <sm> oh, and the directory package
13:54:37 <thr33strikes> I thougth that was OS specific?  I'll re-read thanks for the info
13:54:51 <Cale> Everything in System.Directory is OS agnostic
13:54:56 <monochrom> module System.FilePath is fairly OS-independent. the package name is filepath. comes with Haskell Platform.
13:54:57 <sm> which is awesome
13:55:01 <Cale> Which is why the module is a little anemic
13:55:12 <monochrom> example: </> does the right thing
13:55:13 * sm loves OS agnostic
13:55:37 <Eduard_Munteanu> Am I supposed to use Parsec for arranging input / doing a first pass over data, like splitting things into lines and fields?
13:56:03 <Cale> Eduard_Munteanu: You certainly can, and it wouldn't be too much of an abuse
13:56:22 <Cale> Eduard_Munteanu: For anything more complicated than what you can handle easily with lines/words
13:56:27 <Eduard_Munteanu> I see... would I just call 'parse' again on the result for the next pass though?
13:56:31 <monochrom> I don't know about "supposed". it is your call, not mine.
13:56:45 <Eduard_Munteanu> Yeah, it is more complicated after that.
13:57:19 <Eduard_Munteanu> Bah, I want HList. :)
13:57:52 <Eduard_Munteanu> Or dependent types.
13:57:57 <Cale> Eduard_Munteanu: It's up to you whether to nest your use of parsec like that. Parsec is capable of handling streams of tokens of an arbitrary type if you want to tokenise first, though many people will avoid a separate tokenising pass.
13:58:38 <monochrom> "the solution depends on the problem"
13:59:40 <Eduard_Munteanu> I'm parsing records with colon-separated fields. The first field dictates the type of what follows, but any given field can have different stuff in it depending on that.
14:00:20 <Riccardo> I'm using "cabal-dev ghci" to try out a few functions from my haskell project. I also have some extra imports in ~/.ghci for stuff that i often and up using (e.g. monads, pretty print). however, cabal-dev wants me to put the related packages in build-depends. can I avoid that?
14:00:22 <Eduard_Munteanu> Also the order of the records (lines/rows) is important.
14:00:28 <tdammers> hmm, you could probably split the input into "tokens" (fields) easily without parsec
14:00:40 <Sonarpulse> what do you all think the chances are that Haskell gets dependant types within the next decade?
14:00:43 <Eduard_Munteanu> tdammers: that's what I first did, yeah
14:00:45 <mm_freak_> http://hackage.haskell.org/package/acme-schoenfinkel
14:00:47 <mm_freak_> i had to =)
14:00:57 <Kinnison> You're a bad person.
14:01:00 <monochrom> two-pass maximizes programmer sanity. one-pass maximizes execution efficiency. choose your poison.
14:01:23 <Eduard_Munteanu> I have to group lines into logical units before parsing.
14:01:40 <mm_freak_> but it's actually a type class:  class (Category cat) => Schoenfinkel cat
14:01:43 <Ralith> with sufficiently clever abstractions you can write one-pass as if it were two-pass
14:01:51 <Eduard_Munteanu> Anyway my concern is I need a big function calling a bunch of parsers, and then fill a record type.
14:01:58 <mm_freak_> schoen :: cat (a, b) c -> cat a (cat b c)
14:02:00 <haasn> mm_freak_: I like these names, they're pretty (sorry)
14:02:08 <Cale> Well, you don't lose *much* sanity avoiding the tokenising pass with a parser combinator library, because you build parsers for each of your tokens, and then use those.
14:02:09 <mm_freak_> they're schön =)
14:02:12 <Eduard_Munteanu> Ralith: maybe it does do fusion
14:02:26 <monochrom> haha mm_freak_
14:02:39 <haasn> mm_freak_: but why ‘oe’? :)
14:02:51 <haasn> this is an acme-package, after all
14:03:02 <Cale> haasn: Because ö is a little hard to type, I guess.
14:03:15 <Cale> (unless you have a keyboard layout which has it directly)
14:03:16 <Eduard_Munteanu> It's a bit annoying because I have to map certain properties to certain fields of a certain record
14:03:22 <mm_freak_> haasn: there are unicode variants if you prefer
14:03:36 <mm_freak_> that's why it needs ConstraintKinds
14:03:41 <mm_freak_> type Schönfinkel = Schoenfinkel
14:03:41 <mm_freak_> =)
14:03:45 <monochrom> yeah, it comes with both schoen and schön
14:03:47 <haasn> heh
14:03:55 <haasn> awesome
14:04:24 <monochrom> BUT! it doesn't have Control.Category.Schönfinkel
14:04:31 <haasn> schön/hässlich
14:04:36 <mm_freak_> it even comes with a test suite to show that curry = schoen =P
14:04:56 <haasn> in this model, schön should be uncurry
14:04:58 <haasn> clearly
14:05:00 * hackagebot acme-schoenfinkel 0.1.0 - Proper names for curry and uncurry  http://hackage.haskell.org/package/acme-schoenfinkel-0.1.0 (ErtugrulSoeylemez)
14:05:01 <haasn> I mean uh
14:05:03 <haasn> curry
14:05:09 <mm_freak_> monochrom: i didn't want to mess up the file system of people =P
14:05:39 * Kinnison notes that hub.darcs.net doesn't set the encoding to utf8 on the pages it sends
14:05:46 <Eduard_Munteanu> I keep wishing to design a combinator to take a field number and parse it into various types.
14:05:50 <Kinnison> ""SchÃ¶nfinkelization""
14:05:53 <monochrom> iso-8859-1 die die die
14:06:27 <Eduard_Munteanu> I think I should do a more extensive first-pass.
14:06:37 * monochrom told firefox to default to utf-8
14:06:42 <haasn> Kinnison: the page is actually set to UTF-8 for me
14:06:48 <haasn> it looks like an encoding error server side, oh no
14:07:01 <Kinnison> oh well, oops
14:07:04 <mauke> WTF-8
14:07:09 <Eduard_Munteanu> Heh.
14:07:58 <haasn> or perhaps a client-side error on mm_freak_'s end?
14:08:13 <monochrom> the http header has "Content-Type: text/html; charset=utf-8" alright
14:08:34 <lispy> Also, I like that the unicode charaters break the syntax highlighting
14:08:38 <lispy> http://hub.darcs.net/ertes/acme-schoenfinkel/browse/Control/Category/Schoenfinkel.hs
14:08:40 <monochrom> emphasis: the http header, I do not mean the html code
14:08:51 <haasn> http://hub.darcs.net/nand/test-repo
14:08:53 <haasn> works fine for me
14:09:29 * monochrom hugs his home-brew program based on the HTTP library
14:09:52 <mm_freak_> sm: -highlight-
14:10:30 <haasn> (oh, I've made the repo public now so you can access it and confirm it works for you too)
14:10:38 <mm_freak_> http://hackage.haskell.org/package/acme-schoenfinkel
14:10:43 <mm_freak_> includes 'hässlich' now
14:10:49 <mm_freak_> and tests the unicode versions as well
14:11:06 <monochrom> you are to be congratulated! XD
14:11:35 <haasn> great, now I can use it without moral issues
14:11:47 <monochrom> remember to update the bounds on base when a future GHC comes out!
14:12:03 <sm> mm_freak_: ?
14:12:29 <mm_freak_> sm: darcshub does not handle unicode properly via SSH
14:12:49 <tdammers> darcshub doesn't handle unicode properly via http either
14:12:55 <mm_freak_> sm: ssh ertes@hub.darcs.net init acme-schoenfinkel "Schönfinkelization package: proper names for curry and uncurry."
14:13:00 <turiya> how do I remove an element at a specific location in a list? Does using take and drop copy the list twice unnecessarily?
14:13:02 <ibotty> tdammers: i noticed as well
14:13:11 <mm_freak_> i fixed it now via web interface
14:13:21 <tdammers> also, I'd like to see `häßlich` as well
14:13:26 <monochrom> darcs was written when GHC did not support utf-8. can't be helped.
14:13:32 <sm> rats.. patches welcome
14:13:33 <mm_freak_> tdammers: that's no longer proper german =)
14:13:34 <haasn> http://hub.darcs.net/nand/test-repo2 confirm
14:13:41 <tdammers> it was in the days of good Moses
14:13:50 <ski> turiya : `take n &&& drop n = splitAt n'
14:14:13 <mm_freak_> turiya: it doesn't copy twice, but it traverses twice
14:14:15 <joelteon> @pl \n -> take n &&& drop n
14:14:18 <lambdabot> liftM2 (&&&) take drop
14:14:18 <lambdabot> optimization suspended, use @pl-resume to continue.
14:14:27 <ski> @botsmack
14:14:27 <lambdabot> :)
14:14:45 <ibotty> @pl-resume
14:14:46 <monochrom> turiya: it will copy the first portion of the list, but should be just once if you do it right. also, use splitAt, it will traverse the list just once, but same amount of copying
14:14:50 <dmwit> turiya: Answer: you don't remove an element at a specific location in a list.
14:14:51 <lambdabot> liftM2 (&&&) take drop
14:14:52 <lambdabot> optimization suspended, use @pl-resume to continue.
14:14:53 <ibotty> (what should it do?)
14:14:58 <joelteon> ibotty: @pl is fucked atm
14:15:00 * hackagebot acme-schoenfinkel 0.1.1 - Proper names for curry and uncurry  http://hackage.haskell.org/package/acme-schoenfinkel-0.1.1 (ErtugrulSoeylemez)
14:15:02 * hackagebot xmlgen 0.6.0.0 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.6.0.0 (StefanWehr)
14:15:18 <monochrom> for better results, consider using a different approach altogether
14:15:29 <dmwit> ibotty: It should not claim it got suspended.
14:15:51 <dmwit> Oh, that Ertugrul. Such a joker.
14:16:03 <ibotty> joelteon: what about splitAt
14:16:07 <mm_freak_> dmwit: that's me =P
14:16:18 * dmwit waves
14:16:22 <lispy> monochrom: I thought the real problem with darcs and unicode is that storing arbitrary text content is not 100% compatible with encodings.
14:16:32 <applicative> omg this is awesome. i want it in base!
14:16:34 <lispy> monochrom: I'm trying to tihnk of how to explain...
14:16:58 <dmwit> Storing text content in your RCS when the filesystem only knows bytes is a recipe for disaster, yes.
14:17:03 <monochrom> do you mean, darcs cannot know which encoding you want to use, for each file?
14:17:08 <lispy> monochrom: Maybe this example helps, someone creates a file in one encoding and someone submits a patch in a different encoding (but for that existing file)
14:17:35 <mm_freak_> does darcs even need to know for text files?
14:17:36 <dmwit> s/is a recipe/seems like a recipe/
14:17:40 <Kinnison> anything other than utf8 should just be banned (for interchange)
14:17:43 <lispy> Also, unix path names don't have encoding info stored anywhere
14:17:47 <tel> applicative aw, I'm not sure if I like the new name for generalization purposes or wish it dependended on strict pair
14:17:47 <dmwit> mm_freak_: It does patches by line. So yes.
14:18:00 <mm_freak_> dmwit: it does patches by line, so no
14:18:05 <Heffalump> dmwit: not really, because a line break is a line break
14:18:09 <Heffalump> it needs to know for metadata
14:18:11 <dmwit> mm_freak_: You're not thinking big enough. =)
14:18:11 <applicative> tel I agree, of course people complain about the use of lazy pairs for Arrow too.
14:18:30 <applicative> tel: so mm_freak_ is just repeating all the old mistakes ;)
14:18:35 <mm_freak_> dmwit: if my acme-schoenfinkel package proves anything, it is that i do think big enough =P
14:18:38 <tel> ha
14:18:41 <dmwit> When I write my file in UTF-32 I'll be laughing at your UTF-8 based line detection into my sleeve.
14:18:51 * monochrom has a cunning plan!
14:18:58 <mm_freak_> schoen :: (Schoenfinkel cat) => cat (a, b) c -> cat a (cat b c)
14:18:59 <mm_freak_> =P
14:19:07 <Kinnison> dmwit: I don't want your steenky patches
14:19:10 <monochrom> mm_freak_: for each function, provide both a strict version and a non-strict version :)
14:19:13 <applicative> Control.Category.Schoenfinkel.Strict
14:19:17 <mm_freak_> lol
14:19:17 <tel> bahaha
14:19:20 <dmwit> err
14:19:22 * monochrom has a more cunning plan!
14:19:27 <dmwit> That's a rooky error. I meant UCS-32 of course.
14:19:28 <tel> or overload it on Field1 and Field2?
14:19:39 <applicative> tel, that's it!
14:19:40 <Kinnison> dmwit: that's more like it
14:19:44 <dmwit> UCS-4?
14:19:44 <tel> yessss
14:19:48 <dmwit> crap, I'm really making a hash of it
14:19:50 <monochrom> mm_freak_: for each function, add a Bool parameter for strictness :)
14:19:55 <Kinnison> UCS-32 sounds awesome
14:20:07 <tel> monochrom oh. that's.
14:20:08 <mm_freak_> feel free to send patches or do pull-requests =P
14:20:10 <Kinnison> 256 bit character codes
14:20:16 <tel> monochrom geniusterrible
14:20:16 <lispy> UCS-32: File encodings bloat edition :)
14:20:25 <Kinnison> One character SHA-256 hashes :-)
14:20:46 <lispy> We should have unicode points for x86 instructions
14:20:50 <applicative> i give up on the Field2 plan, it's too horrifying
14:20:52 <dmwit> Heffalump: I'm not 100% sure I understood your point.
14:21:01 <mm_freak_> WrappedSchoenfinkel does make a point, though =)
14:21:08 <lispy> so you could embed instructions in plaintext (yay?!)
14:21:15 <mm_freak_> every ArrowApply is a Schoenfinkel
14:21:42 <Heffalump> I did jump into the middle of the conversation, but I thought you were talking about darcs and encoding
14:21:45 <mm_freak_> should rename it to WrappedArrowApply though
14:21:55 <dmwit> Heffalump: Yes, I think we were. And so?
14:22:18 <ibotty> something different: i like to use GOA in ghci, is it possible to use it even within cabal repl or cabal-dev ghci? without installing in the cabal sandbox, that is
14:22:23 <Heffalump> so I was saying that I don't think the encoding matters for detecting line-endings
14:22:34 <dmwit> I think it does.
14:22:57 <tel> :t f <$> view _1 <*> view _2
14:22:58 <lambdabot> (Show b1, Show b2, Applicative f, MonadReader s f, Field2 s s b2 b2, Field1 s s b1 b1, FromExpr b) => f b
14:23:02 <tel> ooh
14:23:05 <dmwit> To be somewhat obtuse about it, I choose EBCDIC as my encoding.
14:23:06 <lispy> I thought droundy told me that there are some pathelogical normalization cases for line-endings but that he deemed them sufficiently esoteric(?) to ignore them?
14:23:11 <gordon_> hello!
14:23:22 <gordon_> I've got a question about some IDE for haskell
14:23:27 <gordon_> what are you guys using ?
14:23:29 <Heffalump> dmwit: ah, ok
14:23:36 <lispy> gordon_: I use vim and emacs
14:23:41 <lispy> gordon_: not IDEs exactly
14:23:48 <dmwit> Heffalump: But not even being obtuse, UTF-16 is weird enough that it probably matters.
14:23:51 <Heffalump> I'm with droundy on that :-)
14:23:52 <gordon_> lispy: something more IDE-like ?
14:23:52 <haasn> mm_freak_: oh god
14:23:53 <shanse> vim and emacs?
14:23:59 <gordon_> ok..
14:24:01 <lispy> gordon_: FPcomplete is making an IDE. It's web based. I think it's in a closed beta.
14:24:03 <Heffalump> dmwit: hmm, point
14:24:06 <acowley> gordon_: emacs with ghc-mod
14:24:06 <tel> applicative there's no way to write schoen with Field1 Field2, right? Because we need the two constraints together to make a prism
14:24:06 <lispy> gordon_: eclipseFP?
14:24:14 <haasn> mm_freak_: this bug goes all the way back to SSH.Util, which has fromLBS :: LBS.ByteString -> String; fromLBS = map (toEnum . fromIntegral) . LBS.unpack
14:24:35 <mm_freak_> haasn: that information may be useful to sm
14:24:39 <mm_freak_> sm: -highlight again-
14:24:40 <lispy> gordon_: http://eclipsefp.github.io/install.html
14:24:45 <gordon_> lispy: I'm not quite fan of eclipse
14:24:54 <gordon_> it likes to freeze after while
14:24:55 <tel> haasn whoa
14:24:56 <lispy> gordon_: You're making this difficult :)
14:25:03 <lispy> gordon_: what do you mean by IDE
14:25:08 <gordon_> lispy: well it's hard to beat intellij you know...
14:25:12 <lispy> gordon_: what would be your ideal IDE?
14:25:20 <gordon_> lispy: intellij for haskell :)
14:25:23 <lispy> hmmm
14:25:25 <gordon_> or qt creator
14:25:25 <ibotty> whut?
14:25:45 <gordon_> but now I'm looking for something fast
14:25:52 <gordon_> with some kind of code completion
14:25:55 <lispy> gordon_: have you tried tihs? https://code.google.com/p/ideah/
14:26:03 <sm> haasn: that would be great to drop in an issue at http://hub.darcs.net/simon/darcsden/issues
14:26:18 <lispy> vim has completeion
14:26:22 <haasn> sm: sure thing
14:26:24 <lispy> (so does emacs)
14:26:28 <gordon_> hm
14:26:31 <sm> as for rendering of unicode, that may be a highlighting-kate issue
14:26:41 <gordon_> I will use vim then
14:26:42 <mm_freak_> sm: that actually works
14:26:51 <gordon_> since I'm using it as text editor
14:27:12 <sm> mm_freak_: I did see the color changing unexpectedly at non-ascii chars
14:27:21 <mm_freak_> gordon_: intelli* is difficult in haskell
14:27:40 <mm_freak_> sm: oh ok…  at least in the README.md it works
14:27:48 <gordon_> mm_freak_: this is why I asked here
14:28:01 <gordon_> I would like to learn something functional
14:28:11 <gordon_> I will probably use scala in the end
14:28:20 <gordon_> but haskell is somehow 'pure functional'
14:28:30 <joelteon> heh, scala
14:28:32 <gordon_> so would like to learn good practices
14:28:43 <mm_freak_> gordon_: scala and haskell have little in common actually
14:29:00 <mm_freak_> haskell actually ruined me for scala =)
14:29:02 <lispy> if you're just learning the basics then hopefully the choice of ide/editor doesn't matter yet
14:29:02 <monochrom> good practice regarding which editor to use?!
14:29:05 <gordon_> mm_freak_: it's about paradigm
14:29:11 <gordon_> monochrom: nah
14:29:17 <sm> thanks haasn
14:29:21 <monochrom> ok that's better
14:29:35 <mm_freak_> gordon_: start with something that doesn't get in the way of your learning experience
14:29:44 <lispy> notepad.exe
14:29:52 <mm_freak_> in other words, don't waste your time trying to find a "good IDE", because there is none
14:29:52 <gordon_> mm_freak_: this is what I'm looking for
14:29:58 <mm_freak_> most of us just use a text editor like emacs or vim
14:29:59 <applicative> here's a typical passage of frege that people like van heijenoort associate with currying http://www.scribd.com/doc/118467145/gottlob-frege-m-furth-translator-the-basic-laws-of-arithmetic-exposition-of-the-system#page=155
14:30:00 <dmwit> lispy: ...run in Wine
14:30:08 <gordon_> ok
14:30:12 <gordon_> so I will get kate ;0
14:30:13 <gordon_> ;)
14:30:27 <monochrom> throw a die to choose between Haskell, OCaml, F#, Scala, whatever you think up. or learn them all.
14:30:38 <dmwit> "go with your heart"
14:30:42 <mm_freak_> gordon_: that's fine…  all you really need is an editor with a built-in command to trigger compilation =)
14:30:53 <mm_freak_> IIRC kate has that
14:30:59 <ibotty> but hdevtools integration is great
14:31:04 * lispy uses split windows/tmux and has a shell in one window and vim in the other
14:31:08 <mm_freak_> what is hdevtools?
14:31:19 <ibotty> ghcmod, but faster
14:31:24 <mm_freak_> what is ghcmod?
14:31:28 <ibotty> :D
14:31:31 <monochrom> well, dmwit, in this case, due to lack of information, the heart says nothing. when this happens, I go with the die instead. it's in fact probabilistically better than asking stranger's opinion
14:31:31 <lispy> full screen terminals. I use the finest that the 1970s had to offer.
14:31:38 * applicative uses pico-mod
14:31:46 <ibotty> ghc running in the background, constantly compiling your code
14:31:48 <ibotty> :D
14:31:51 <applicative> and hdev-nano
14:31:55 <mm_freak_> ah
14:32:09 <mm_freak_> what's that good for?
14:32:14 <dmwit> heart... runs on information?
14:32:29 <ibotty> it's great. an instance after saving, i see type errors
14:32:43 <mm_freak_> i see…  that would probably slow me down =)
14:32:43 <monochrom> like, until the day your brain has a USB 3.0 port and you can upload your brain for a full analysis, my opinion of what you should do is pretty irrelevant to what's best for you. seriously.
14:32:49 <mm_freak_> i often write pages of code before compiling
14:33:22 <haasn> monochrom: if a die is better than asking a stranger's opinion then just ask a stranger's opinion and do the opposite of what they suggest?
14:33:36 <donri> mm_freak_: in vim hdevtools can be used for inspecting types of [sub]expressions, inspect the :info of an identifier, get compilation errors and warnings on save next to the line numbers
14:33:41 * applicative hadn't realized there'd been *so much work* on haskell.nanorc lately! https://github.com/serialhex/nano-highlight/blob/master/haskell.nanorc
14:33:56 <dmwit> haasn: Does that work when there are more than two choices?
14:34:01 <mm_freak_> donri: thanks, that sounds much more useful
14:34:04 <donri> mm_freak_: the type inspection is particularly cool
14:34:10 <ibotty> it's the same that ghci uses, so no
14:34:15 <donri> mm_freak_: especially with -fdefer-type-errors
14:34:30 <mm_freak_> i think i've never used that flag
14:34:43 <dmwit> haasn: ...hm, I guess rolling a die among the choices not suggested by a stranger is still better than rolling a die among all choices.
14:34:46 <donri> mm_freak_: yeah it's much less usable without editor integration
14:35:06 <mm_freak_> what i'd really like is something like agda's emacs mode
14:35:34 <donri> yeah, can't wait for vim support for type holes, although i guess they're far from what agda provides
14:35:37 <mm_freak_> with holes, case splitting, inference, etc.
14:36:15 <tel> vim is getting type holes?
14:36:31 <dmwit> No, GHC is.
14:36:32 <tel> I would jump the emacs ship in a second
14:36:33 <mm_freak_> vim already has a bit type hole i think =P
14:36:35 <tel> oh, yes
14:36:43 <mm_freak_> s/bit/big/
14:36:48 <tel> ha
14:37:11 <tel> every time I use agda mode and then go back to Haskell I find myself C-c C-c'ing cases
14:37:19 <tel> that's easily my favorite
14:37:51 <mm_freak_> mine is C-c C-l together with holes
14:38:13 <mm_freak_> combined with C-c C-f and C-c C-a
14:39:03 <danilo2> What would you use to achive this effect: I've got a list of Strings and a Monad State function "getName" (we can use it like: newname <- getName). And I want to "zip" this string list with new generated names, so it would be something like [("a", "name1"), ("b", "name2"), ...]. Is there any simple and nice method to do it?
14:39:21 <tel> agsy is nice, but I tend to feel it only ever has me by about 3 seconds
14:39:34 <tel> either I can give enough information for myself to figure it out or agsy can't either
14:39:42 <tel> but it does type for me
14:41:42 <monochrom> danilo2: I may write my own recursion. if forced to not write my own recursion (but why?), I may absue zipWithM
14:43:04 <monochrom> zipWithM (\a _ -> do{b<-getName; return(a,b)} ) the_string_list (repeat ())
14:43:06 <tel> danilo2 mapM (Data.Traversable.sequence . (return . id &&& getName))
14:43:31 <monochrom> oh, mapM is simpler
14:43:32 <tel> or monochrom's it's much actually simpler
14:43:36 <tel> haha
14:43:47 <gordon_> ok guys
14:43:50 <gordon_> thanks for help
14:43:55 <gordon_> may come back later
14:43:58 <gordon_> take care
14:44:01 <monochrom> mine is more complicated due to (repeat ()) only to ignore it
14:44:09 <tel> okay, use mapM and don't use control arrow tricks, that'd be my actual suggestion ; )
14:44:15 <danilo2> monochrom, tel: Thank you. I'm going to try it :) monochrom: I wanted simply to know the easiest solution. I do not want to create my own recursions if there is a solution ;)
14:44:51 <tel> danilo2 gl :)
14:44:51 <monochrom> yeah, combine mapM with my lambda adapted. mapM (\a -> do{b<-getName; return(a,b)})
14:44:57 <tel> nice
14:45:24 <danilo2> tel, monochrom: Ok I will :) btw - what is "&&&" ?
14:45:27 <tel> I do like control arrow tricks a lot
14:45:45 <monochrom> &&& helps you make tuples from functions
14:45:47 <tel> danilo2 "fanout", it takes to functions like (a -> b) and (a -> c) and turns them into (a -> (b, c))
14:45:51 <tel> :t (&&&)
14:45:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:46:05 <mm_freak_> :t liftA2 (,)
14:46:06 <lambdabot> Applicative f => f a -> f b -> f (a, b)
14:46:10 <monochrom> > (sin &&& abs) (-4.1)
14:46:11 <lambdabot>   (0.8182771110644103,4.1)
14:46:25 <mm_freak_> > liftA2 (,) sin abs (-4.1)
14:46:26 <lambdabot>   (0.8182771110644103,4.1)
14:46:58 <danilo2> Oh, thats nice :) Thank you :)
14:47:01 <mm_freak_> works better in theses cases:  arr (unschoen f) . (g &&& h)
14:47:06 <mm_freak_> liftA2 f g h
14:47:41 <tel> mm_freak_ unschoen. : )
14:47:48 <tel> it makes me happy
14:47:52 <mm_freak_> =)
14:49:19 <applicative> (|sin,abs|) (-4.1)
14:49:37 <mm_freak_> suggested by someone named applicative =)
14:49:57 <applicative> i'm still worried about these lazy pairs!
14:50:17 <monochrom> use a Bool parameter to control strictness
14:50:18 <tel> we could at least write unshoen f as f <$> view _1 <*> view _2
14:50:40 <tel> I'm still plugging away at how to get schoen from it
14:50:50 <applicative> @type \f ->  f <$> view _1 <*> view _2
14:50:51 <lambdabot> (Applicative f, MonadReader s f, Field2 s s b2 b2, Field1 s s b1 b1) => (b1 -> b2 -> b) -> f b
14:51:07 <mm_freak_> monochrom: that's blind
14:51:10 <applicative> :(
14:51:15 <mm_freak_> data Strict = Strict | Nonstrict
14:51:30 <mm_freak_> newtype Strict = Strict { runStrict :: Bool }
14:51:31 <monochrom> oh, that's better
14:51:40 <applicative> hah
14:51:48 <tel> :)
14:52:08 <monochrom> in fact, why don't I suggest this:
14:52:12 <tel> :t \f -> f <$> view _1 <*> view _2
14:52:12 <lambdabot> (Applicative f, MonadReader s f, Field2 s s b2 b2, Field1 s s b1 b1) => (b1 -> b2 -> b) -> f b
14:52:14 <applicative> the newtype associates strictness with truth
14:52:15 <tel> @type \f -> f <$> view _1 <*> view _2
14:52:15 <lambdabot> (Applicative f, MonadReader s f, Field2 s s b2 b2, Field1 s s b1 b1) => (b1 -> b2 -> b) -> f b
14:52:20 <mm_freak_> a more serious note i do sometimes use Alternative+Foldable as a Bool replacement
14:52:29 <monochrom> use an Int parameter to control strictness. now you really have no clue which number means what :)
14:52:43 <mm_freak_> monochrom: do you have a clue with Bool?
14:52:53 <tel> monochrom I think we should keep with the theme and use the german words for strict/unstrict
14:52:57 <applicative> strict, very strict , very very strict
14:52:58 <tel> or true/false
14:53:03 <tel> whichever is more clear
14:53:08 <monochrom> no, but Bool means fewer experiments to discover the meaning
14:53:39 <mm_freak_> the bits in the Int may specify the strictness on particular arguments
14:53:54 <mm_freak_> f 3 ⊥ x = ⊥
14:53:56 <tel> data Strictly = StrictA | StrictB | Strict2
14:54:27 <tel> then use Maybe Strictly
14:54:35 <mm_freak_> f 3 ⊥ y = f 3 x ⊥ = ⊥
14:54:42 <mm_freak_> f 1 ⊥ y = ⊥
14:54:49 <mm_freak_> f 2 x ⊥ = ⊥
14:54:55 <monochrom> this is excellent
14:55:12 <mm_freak_> use Integer for functions with more than 30 arguments
14:55:48 <applicative> the german for 'lazy evaluation' seems to be 'lazy evaluation'
14:56:00 <applicative> Bedarfsauswertung
14:56:13 <mm_freak_> applicative: faule auswertung
14:56:13 <tel> nicht strikt
14:56:20 <mm_freak_> tel: no, that's not the same thing
14:56:46 <tel> I don't know german, I just like the rhyme :)
14:56:48 <applicative> i was thinking we would translate 'call by value' as something like
14:56:58 <applicative> Wertauswertung
14:57:08 <tel> ooh
14:57:10 <applicative> making a hash of this...
14:57:45 <haasn> I just use “lazy Evaluation”. I don't write very good german
14:57:53 <mm_freak_> tel: it's not a rhyme in german =)
14:58:03 <tel> aw
14:58:27 <mm_freak_> applicative: aufruf mit/durch/via wert
14:58:40 <monochrom> I don't know German. I'm too lazy.
14:59:04 <monochrom> (Ich bin über lazy?)
14:59:11 <mm_freak_> ubarlazy
14:59:15 <monochrom> (Ichbinüberlazy?)
15:00:45 <absence> does haskel have a bit scan / find first 0/1 function somewhere in the libs? (like the bsf/bsr x86 instruction)
15:00:51 <absence> haskell*
15:01:44 <monochrom> anyway, Oleg et al's "extensible effects" is pretty mind-blowing. but it has a drawback. you now have to write like "v :: Int <- ask" or other ways of really nailing the type of v to Int, or whatever type you want. because the type of "ask" is too general to tell the type-inferrer
15:02:24 <mm_freak_> absence: no, but you can define it easily in terms of Data.Bits combinators
15:02:50 <monochrom> in fact, it gets better. local ((1::Int) +) (do .. v::Int <- ask ...)  both type annotations are necessary
15:03:37 <ParahSailin> absence: yes i did something with those instructions
15:06:29 <ParahSailin> my mistake, that was the popcnt primop that is in there
15:06:55 <chrisdone> monochrom: what do you think of Disciple?
15:07:11 <chrisdone> and its effect typing
15:07:12 <monochrom> I don't know. haven't looked.
15:08:56 <absence> ParahSailin, mm_freak_: ok no problem, i'll define my own. thanks!
15:09:11 <chrisdone> monochrom: dude it's ace
15:09:40 <haasn> > lengthOf (takingWhile not bits) 512
15:09:41 <lambdabot>   9
15:09:52 <monochrom> can a free monad be made a MonadFix? what restriction on the functor is sufficient? or is it hopeless?
15:10:11 <bootcode> g'night
15:10:12 <haasn> absence: like this? ^
15:10:58 <applicative> "If the intel bsf and bsr instructions ever become GHC primops, this code should be reimplemented using these."
15:11:06 <applicative> says Data.IntSet
15:11:13 <bootcode> i have plain text + some line/col based regions, which I would like to convert to fancy highlighted html. Anyone aware of a suitable library?
15:11:57 <ParahSailin> absence: here's how you make a primop http://ghc.haskell.org/trac/ghc/ticket/5413
15:11:57 <ski> `bsf' ?
15:12:00 <chrisdone> bootcode: how do you want to highlight the plain text?
15:12:17 <mm_freak_> monochrom: pretty much hopeless
15:12:38 <mm_freak_> the proper answer is:  we don't know how to do it
15:12:42 <applicative> bit scan forward
15:12:44 <bootcode> chrisdone: with custom spans with ids, will plug some js in them
15:12:46 <newbie_> a question about lens. In http://pastebin.com/QThQMd1s, how do i use strike?
15:12:52 <mauke> The paste QThQMd1s has been copied to http://lpaste.net/92340
15:13:05 <ski> applicative : so `bsr' isn't "branch to subroutine" then ?
15:13:11 <Th0mas> I'm having a bit of trouble understanding the functioning of (>>). What determines that it executes the first argument before the second? I can understand why this works with (>>=) where the second argument depends on the return value of the first, but with (>>) it doesn't. Could anyone explain?
15:13:14 <chrisdone> bootcode: so what does f "hello world" output?
15:13:14 <applicative> I'm not seeing a lot of progress on that one ParahSailin
15:13:32 <applicative> > f "hello world"
15:13:33 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
15:13:33 <lambdabot>    arising from a us...
15:13:35 <newbie_> i mean, execStateT strike initialState must be modified to take new arg
15:13:56 <Heffalump> Th0mas: there's no particular guarantee, it just depends on the monad
15:14:05 <monochrom> Th0mas: it depends on the monad. for IO, it executes left-to-right because IO says so
15:14:18 <Heffalump> m1 >> m2 is no different from m1 >>= \_ -> m2, in any case
15:14:44 <Heffalump> but consider the Maybe monad
15:14:48 <Th0mas> Hm, alright, but how is that implemented inside of IO then?
15:14:53 <monochrom> for examples of right-to-left, see my http://lpaste.net/41790/ and http://lpaste.net/63925
15:14:57 <Chousuke> Th0mas: magic :p
15:15:07 <Heffalump> that will also force left->right evaluation at least to the point of checkign that the left-hand argument is None or Some.
15:15:08 <bootcode> chrisdone: assuming I have regions A:[0,3) and B:[6,8) it outputs "<span id="A">hel</span>lo <span id="B">wo</span>rld"
15:15:17 <Heffalump> I mean Just or Nothing (sorry, too much F#...)
15:15:27 <applicative> i assume >> is separately implemented for IO, so that it can mean approximately, "and then"
15:15:27 <ski> Th0mas : `IO' is a primitive, just like `Int' or `Float'
15:15:29 <monochrom> IO is implemented by the compiler making up object code
15:15:54 <monochrom> and the compiler obviously chooses to invent object code that does left-to-right
15:16:05 <bootcode> chrisdone: I don't have problem implementing it, just though worth a question to deduplicate effort
15:16:23 <chrisdone> bootcode: hm, nope, don't know of such function
15:16:31 <Cale> applicative: It wouldn't have to be separately implemented, but it might be
15:16:44 <bootcode> chrisdone: np, thanks
15:17:01 <applicative> Cale: of course. iobind is implemented so as to mean 'and then, with the result...'
15:17:02 <Cale> applicative: Even with the hacky implementation that GHC uses, the data dependencies will keep things straight.
15:17:49 <chrisdone> bootcode: that might be a nice function to package =) applyTransformations :: [(Int,Int,Text -> Text)] -> Text -> Text
15:17:58 * applicative only believes in the ajhc's implementation of io since it's guaranteed to be truly opaque 
15:18:05 <Th0mas> ski, monochrom, Heffalump: Ah alright, kinda makes sense. So are there more of these magic monads? I assume you can't do this with monads implemented in Haskell?
15:18:15 <monochrom> ST
15:18:19 <chrisdone> applicative: 'believe in'?
15:18:32 <monochrom> STM (unrelated to ST)
15:18:56 <monochrom> if you write your own monad, you can make it do whatever you want
15:19:26 <applicative> chrisdone: what, you believe in Hugs' IO?
15:19:34 <monochrom> including left-to-right, right-to-left, and there-and-back-again
15:19:39 <Th0mas> monochrom: Even if you implement it in Haskell? Doesn't it all boil down to some piece of "magic" in the end?
15:19:41 <chrisdone> applicative:  i don't know, it depends what 'believe in' means
15:19:46 <mm_freak_> out-and-back-in
15:19:58 <haasn> Identity
15:20:02 <monochrom> (indeed, logicT is there-and-back-again. it is exactly for trying and backtracking)
15:20:18 <applicative> http://ogi.altocumulus.org/~hallgren/Programatica/tools/pfe.cgi?Hugs.Prelude#tIO
15:20:19 <chrisdone> applicative: is it like Luke, I believe in you, or like I believe in Santa Claus, or what?
15:20:49 <applicative> chrisdone: I mean, I avoid these disputes by pointing out that there are diverse implementations
15:20:56 <mm_freak_> Free, Coroutine and ContinueT are out-and-back-in
15:20:59 <monochrom> no, a lot of monads are just very complex pure functions. they are still pure functions. they are just complex enough you want to put a simpler monadic face in front
15:21:03 <applicative> ghc, I believe in you!
15:21:36 <monochrom> for example Control.Monad.State.Strict (left-to-right) and Control.Monad.State.Lazy (right-to-left).
15:21:50 <mm_freak_> ContT can also do mark-and-return
15:21:52 <tel> Th0mas Usually there end up being roughly two steps—you build the monad that models whatever kind of effect you want and then you interpret it into whatever magic monads have the runtime effects you want
15:22:00 <monochrom> guess what, they're both s -> (s, a). (or s -> (a,s), I forgot which, doesn't matter)
15:22:24 <mm_freak_> monochrom: memorize "sas" =)
15:22:30 <mm_freak_> s -> (a, s)
15:22:39 <Th0mas> monochrom: Interesting, still can't quite bend my mind around it though, I'll look into those definitions
15:22:39 <chrisdone> monochrom: we need named tuples like trex =)
15:22:44 <mm_freak_> or check random's type
15:22:46 <mm_freak_> :t random
15:22:47 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
15:22:50 <Cale> applicative: It *looks* like they're doing something similar, though I'm entirely unfamiliar with ajhc: https://github.com/ajhc/ajhc/blob/arafura/lib/jhc-prim/Jhc/Prim/IO.hs
15:22:53 <chrisdone> s -> (state::s,value::a)
15:23:28 <tel> Th0mas try reading about free monads, http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
15:23:29 <mm_freak_> random's interface is almost made for state monads
15:23:58 <Cale> It would be nice to see a compiler which attempted a representation of IO actions which didn't rely on polluting the meaning of type level (->)
15:24:11 <ski> applicative : "ajhc" ?
15:24:15 <monochrom> the problem with "mnemonic: sas" is: why is it not "mnemonic: ssa" :)
15:24:29 <Cale> ski: http://ajhc.metasepi.org/
15:24:34 <Th0mas> tel: Thanks, will read that
15:24:52 <applicative> ski i was just fiddling with it earlier https://github.com/ajhc/ajhc
15:25:08 <applicative> amazingly it builds without a hitch
15:25:15 <chrisdone> cale: https://github.com/chrisdone/fore#translating-to-javascript =p
15:25:48 <applicative> ski: it makes a very nice, small 'hello world' which i'm sure you were much asking after
15:26:20 <chrisdone> cale: https://github.com/chrisdone/fore/blob/master/js/instances.js#L68
15:26:23 <applicative> did mm_freak_ say ssa or sas?
15:26:28 <mm_freak_> monochrom: because it fits with other things =)
15:26:33 <bos> lenses. zomg.
15:26:39 <ski> applicative : hm, not sure that i was asking after anything ?
15:26:40 <applicative> @type unfoldr
15:26:41 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:27:22 <ski> monochrom : the way to recall `s -> (s, a)' vs. `s -> (a,s)' is that it's the wrong one
15:27:29 <applicative> bos they're great just stick to the main three combinators
15:27:48 <bos> applicative: i have no idea how i'd figure out what the main combinators are
15:27:49 <c_wraith> I still think unfoldr is an incredibly awkward type!
15:28:21 <ski> chrisdone : Trex :)
15:28:32 <mm_freak_> > unfoldr (Just . randomR (0, 9)) (mkStdGen 0)
15:28:33 <chrisdone> ski: yay someone else who likes it =)
15:28:33 <lambdabot>   [5,5,5,0,2,9,3,3,3,8,5,2,4,2,6,7,2,3,7,4,4,8,2,7,8,1,2,1,3,2,9,4,5,6,2,2,2,...
15:28:36 <Cale> (,) s is itself a functor, and so it would be much nicer to use s -> (s,a), but for whatever reason, mtl doesn't.
15:28:39 <FreeFull> :t state random
15:28:45 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
15:29:06 <applicative> > (True,False) ^. _1
15:29:08 <lambdabot>   True
15:29:10 <ski> chrisdone : now if only we could have lightweight variants as well (OCaml calls them "polymorphic variants") or at least positional variants ..
15:29:15 <applicative> there's one combinator bos ^^^
15:29:25 <chrisdone> ski: what's that?
15:29:25 <mm_freak_> Cale: s -> (s, a) would be more sensible, but then you would have to swap everything else all the time
15:29:39 <Cale> mm_freak_: You mean, in existing code
15:29:51 <mm_freak_> Cale: in existing libraries
15:29:54 <mm_freak_> for example 'random'
15:29:59 <mm_freak_> :t state random
15:29:59 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
15:30:01 * hackagebot hspec-expectations 0.3.3 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.3 (SimonHengel)
15:30:07 <applicative> > _1 .~ "California" $ (1,2)
15:30:08 <lambdabot>   ("California",2)
15:30:13 <applicative> theres the other ^^ bos
15:30:15 <Cale> right, well, it's obviously in the wrong order in random as well
15:30:26 <ski> chrisdone : so you can say `foo :: Blah -> (forward :: X | back :: Y | stay :: Z)' or whatever
15:30:35 <bos> applicative: i'm trying to figure out how to use lenses from a state monad to transform part of the state
15:30:53 <applicative> easy
15:30:53 <donri> bos: the "=" operators
15:30:58 <tel> applicative bos or for the combinator shy: view and set
15:31:03 <donri> :t (.=)
15:31:04 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
15:31:07 <ski> chrisdone : when you don't want to either use `Either's (possibly nesting them, or say `Either3',&c.) nor having to define a new type for a one- or two-off use case
15:31:11 <chrisdone> ski: as a sum type?
15:31:14 <ski> yes
15:31:15 <chrisdone> ski: nice =)
15:31:16 <applicative> > runState (_1 += 1 ) (1,"California")
15:31:17 <lambdabot>   ((),(2,"California"))
15:31:27 <chrisdone> ski: that would indeed be cool
15:31:53 <bos> applicative: ah, found http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
15:31:54 <Cale> chrisdone: That's pretty reasonable-looking
15:32:01 <ski> chrisdone : see <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#toc36> for OCaml's take on that (including some subtyping stuff as well)
15:32:03 <applicative> > runState (_1 += 1 ; _2 %= reverse ) (1,"California")
15:32:04 <lambdabot>   <hint>:1:19: parse error on input `;'
15:32:08 <applicative> uho
15:32:18 <applicative> > runState (do {_1 += 1 ; _2 %= reverse }) (1,"California")
15:32:19 <lambdabot>   ((),(2,"ainrofilaC"))
15:32:22 <chrisdone> cale: although i suppose it's based on GHC, so the (->) abuse already happened by this point
15:32:25 <bos> applicative: ver' nice
15:32:50 <donri> bos: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
15:32:51 <tel> bos the Pong example is pretty nice for state updating lenses
15:32:53 <applicative> > runState (do {_1 += 1 ; _2._1 %= reverse }) (1,(True,"California"))
15:32:54 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `[a0]'
15:32:54 <tel> donri :)
15:32:57 <applicative> oops
15:33:05 <chrisdone> ski: so much cool stuff in ocaml
15:33:06 <applicative> > runState (do {_1 += 1 ; _2._2 %= reverse }) (1,(True,"California"))
15:33:08 <lambdabot>   ((),(2,(True,"ainrofilaC")))
15:33:20 <bos> donri: thanks
15:33:25 <tel> checkBounds uses (^.) (%=) (+=) (*=)
15:33:34 <ski> chrisdone : yeah, i try to keep an eye on the MLs (and Scheme)
15:33:40 * monochrom needs a backtracking monad to search in github source trees
15:33:46 <applicative> yes that pong of haasn s is better than most tutorials
15:34:06 <ski> monochrom : the `Back' button doesn't work ?
15:34:13 <ski> monochrom : try the `Clone' button ?
15:34:13 <donri> chrisdone: did you see https://www.google-melange.com/gsoc/project/google/gsoc2013/adamgundry/23001
15:34:15 <chrisdone> ski: i also saw a while back the partially applied named function arguments which was interesting
15:34:30 <ski> chrisdone : what was that ?
15:34:46 <FreeFull> > flip runState (mkStdGen 0) $ sequence . repeat 10 $ state random
15:34:48 <lambdabot>   Couldn't match expected type `m0 a2
15:34:48 <lambdabot>                                -> [Cont...
15:35:02 <monochrom> the 'back' button works
15:35:36 <leroux> Is there anything like <$> but for allow IO?
15:35:42 <chrisdone> donri: nope
15:35:45 <ski> leroux : with what type ?
15:35:52 <leroux> Umm, so a Maybe.
15:36:01 <monochrom> Hug's IO is cool, it's almost Codensity of the free monad you expect, except for this Obj type
15:36:09 <FreeFull> > flip runState (mkStdGen 0) . sequence . replicate 10 $ state random
15:36:10 <lambdabot>   ([2092838931,-2143208520,2034827062,-1587933427,-1272503422,316817438,20070...
15:36:20 <ski> @type (<$>) :: (a -> b) -> (IO a -> IO b)
15:36:21 <lambdabot> (a -> b) -> IO a -> IO b
15:36:31 <tel> leroux IO is a Functor, so read <$> getLine works
15:36:38 <ski> leroux : do you want `(a -> Maybe b) -> (IO a -> IO (Maybe b))' ?
15:36:46 <chrisdone> ski: i don't remember the syntax, but it was something like: let f :: foo:Int -> bar:Char -> () = …;  and then f bar:'a' would have type foo:Char -> ()
15:37:02 <chrisdone> ski: similar to keyword args in lisp, but you could partially apply them
15:37:21 <leroux> Umm. I need `(a -> IO b) -> Maybe a -> b`.
15:37:24 <leroux> Something like that.
15:37:25 <FreeFull> leroux: You can do all possible IO using <$> and join
15:37:30 <leroux> I can do thsi with cases.
15:37:31 <FreeFull> Ah
15:37:43 <FreeFull> No, you can't do that
15:37:43 <leroux> I did, but I'd rather find a better way to do it.
15:37:49 <leroux> Oh.
15:37:54 <leroux> So, just stick with using a case?
15:37:55 <FreeFull> You could if it was IO b at the end
15:38:03 <leroux> Sure, IO b at the end.
15:38:06 <leroux> I'm doing this in a do.
15:38:09 <leroux> Sorry about that.
15:38:23 <augur> byorgey: :)
15:38:31 <FreeFull> What do you want to happen if the function is given Nothing?
15:38:40 <leroux> I need to it return Nothing.
15:38:42 <chrisdone> donri: i quite liked spj's proposal, good to see this guy is going to do that
15:38:42 <monochrom> my question too. what if Nothing
15:38:54 <leroux> I'll paste my code, one sec.
15:39:25 <chrisdone> ski: (i really don't know ocaml, so sorry if that syntax is completely ass-backwards)
15:39:32 <mm_freak_> (a -> IO b) -> Maybe a -> IO (Maybe b)
15:39:41 <FreeFull> mm_freak_: I just wrote that
15:40:02 <mm_freak_> FreeFull: didn't see it
15:40:09 <FreeFull> mm_freak_: I didn't send it before you did
15:40:15 <mm_freak_> ah =)
15:40:18 <mm_freak_> haha =P
15:40:24 <FreeFull> =P
15:40:58 <FreeFull> :t fmap (undefined :: a -> IO b) Nothing
15:40:59 <lambdabot> Maybe (IO b)
15:41:04 <FreeFull> Hmm
15:41:15 <leroux> mm_freak_: Yeah, I need that.
15:41:29 <leroux> (a -> IO b) -> Maybe a -> IO (Maybe b)
15:41:36 <mm_freak_> :t T.traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
15:41:36 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
15:41:45 <leroux> Ahh, cool.
15:41:51 <monochrom> God
15:41:53 <mm_freak_> import Data.Traversable (traverse)
15:41:55 <FreeFull> mm_freak_: There probably is some other way too
15:42:24 <myname_> what libraries do you prefer for data crunching on large text files? PCRE? ByteString? FFI?
15:42:43 <mm_freak_> myname_: depends on the type of data crunching
15:42:55 <myname_> just big text files with floats and ints in them
15:43:06 <mm_freak_> myname_: that doesn't really answer the question
15:43:14 <myname_> i mean in the general sense
15:43:18 <myname_> let's say
15:43:34 <lpaste> leroux pasted “No title” at http://lpaste.net/92341
15:43:37 <myname_> i want to add some numbers that start with a particular string
15:43:43 <chrisdone> the general sense is the problem, the choice depends on the particular
15:43:46 <myname_> and multiply with some other string
15:44:01 <leroux> FreeFull: mm_freak_: http://lpaste.net/92341
15:44:05 <mm_freak_> myname_: this is really two steps:  the parsing and the handling
15:44:17 <leroux> Going to try traverse now.
15:44:21 <myname_> yes, for parsing, i can simply use String with regular expr
15:44:27 <myname_> but that is very slow
15:44:56 <myname_> or i can use ByteString's, but in the end the code looks too cluttered
15:45:06 <bos> ok, code converted to lenses and StateT in not too much time, whew
15:45:13 <mm_freak_> myname_: for a small command line application it's easiest to use a lazy Text
15:45:15 <myname_> i was wondering if other people had experience
15:45:16 <chrisdone> if it's binary, or near binary, it can be ByteString with parsec with binary, cereal or attoparsec, or bytestring-based regexps. if it's text, you can use parsec with Text
15:45:34 <mm_freak_> attoparsec is fine if the grammar is more complicated than that
15:45:56 <myname_> i realized bytestring has integer parsing
15:45:58 <myname_> but not float parsing
15:46:08 <mm_freak_> ByteString is a bad idea for text
15:46:09 <myname_> what would be easiest to parse floats?
15:46:23 <mm_freak_> the "easiest" in the literal sense is 'read'
15:46:33 <mm_freak_> > read "1.5e10" :: Double
15:46:34 <chrisdone> the text package has various number parsers
15:46:34 <lambdabot>   1.5e10
15:46:36 <myname_> definitely, but "read" is very slow
15:46:37 <chrisdone> http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text-Read.html
15:46:44 <myname_> on text
15:46:57 <myname_> if the text had integers
15:47:07 <myname_> i would definitely use bytestring, which is significantly faster
15:47:18 <myname_> but with floats in them, do i have to write my own parser?
15:47:19 <mm_freak_> myname_: first find a good package for parsing numbers…  then my personal way would be to embed the parser in a pipes Pipe
15:48:06 <myname_> is there a reason why bytestring doesn't support float parsing?
15:48:06 <bos> myname_: if you need to parse doubles very efficiently, use the double-conversion package
15:48:09 <mm_freak_> myname_: and no, ByteString is not significantly faster than Text
15:48:21 <myname_> i've tried several things
15:48:24 <bos> myname_: parsing doubles is very very complicated
15:48:25 <myname_> it worked pretty fast for me
15:48:26 <mm_freak_> it's slightly faster and the difference will be shadowed by I/O speed
15:48:30 <myname_> about 5x
15:48:48 <mm_freak_> 5x compared to what?
15:49:02 <shachaf> bos: Is that a UPS pun of some sort?
15:49:04 <myname_> read with regular strings
15:49:13 <bos> shachaf: what?
15:49:13 <mm_freak_> myname_: again, i'm talking about Text, not String
15:49:21 <shachaf> "double conversion". I guess not.
15:49:25 <monochrom> String is known to be fat and slow
15:50:57 <applicative> can i tell "ghc -e" to bring a module in scope?
15:51:08 <myname_> i hadn't seen Text in use before!
15:51:17 <myname_> is it as general as String
15:51:20 <chrisdone> yes
15:51:32 <chrisdone> everyone serious uses text these days
15:51:39 <mm_freak_> myname_: strict Text is not, but lazy Text is
15:51:55 <myname_> with Double, Int parsing, and support for regular expression libraries?
15:51:59 <mm_freak_> i think lazy Text and String are isomorphic
15:52:14 <myname_> nice
15:52:17 <mm_freak_> myname_: not sure what library to use for Double parsing, but otherwise yes
15:52:38 <chrisdone> i suppose it depends on the doubles in question
15:52:39 <bos> mm_freak_: text
15:53:06 <chrisdone> if you know that the format ahead of time is trivial in all cases, your parser can be straight-forward
15:53:09 <mm_freak_> Data.Text.Read
15:53:10 <mm_freak_> hah!
15:53:13 <mm_freak_> bos: thanks =)
15:53:15 <myname_> so is there no function that would do: read :: String -> Double
15:53:26 <myname_> oh the read
15:53:29 <myname_> ok
15:53:41 <chrisdone> i kinda linked that above
15:53:42 <applicative> https://github.com/bos/text/blob/master/Data/Text/Read.hs
15:53:43 <shachaf> mm_freak_: Nearly.
15:53:52 <shachaf> Well, it depends on what you mean by isomorphic.
15:54:05 <shachaf> There's a bijection, of course, but Text can't hold the same Chars as String.
15:54:20 <shachaf> (In particular a String can have the invalid UTF-16 codepoints like U+D800.)
15:54:23 <bos> that's because String and Char are in a state of sin
15:54:37 <mm_freak_> shachaf: can it?  how?
15:54:41 <shachaf> > '\xd800'
15:54:42 <lambdabot>   '\55296'
15:54:43 <myname_> are there any tutorials on Text on the wikis?
15:54:44 <shachaf> bos: Agreed.
15:54:54 <mm_freak_> > T.singleton '\xd800'
15:54:55 <lambdabot>   Not in scope: `T.singleton'
15:54:55 <lambdabot>  Perhaps you meant one of these:
15:54:55 <lambdabot>    `M.singleto...
15:54:58 <bos> "sortamorphic"
15:55:00 * applicative had not thought Char had undone so many
15:55:01 <mm_freak_> > Data.Text.singleton '\xd800'
15:55:02 <lambdabot>   Not in scope: `Data.Text.singleton'
15:55:03 <chrisdone> myname_: the documentation is insufficient?
15:55:09 <myname_> i saw many on regular String's and some for performance on ByteStrings but not for Text
15:55:25 <shachaf> lambdabot doesn't import Text. :-(
15:55:27 <bos> myname_: it has almost the same API
15:55:43 <mm_freak_> shachaf: that's accepted here in GHCi
15:55:43 <shachaf> Anyway, Text uses UTF-16, so it can't directly represent these.
15:55:48 <shachaf> mm_freak_: "accepted" how?
15:55:59 <mm_freak_> it gives nonsense back though
15:56:04 <mm_freak_> "\65533"
15:56:13 <shachaf> Right.
15:56:16 <bos> that's not nonsense, it's the unicode replacement character
15:56:18 <myname_> is it as similar as simply replacing ":: String" with ":: Text"?
15:56:30 <monochrom> applicative: I tried a few things unsuccessfully. you probably have to make do with the like of ghc -e "Data.Char.chr 120"
15:56:36 <mm_freak_> myname_: not really…  you use Text almost like you use ByteString
15:56:38 <chrisdone> bos: text's is 3x nicer because it has fromStrict/toStrict
15:56:46 <mm_freak_> import qualified Data.Text as T
15:57:02 <applicative> with {-#LANGUAGE OverloadedStrings #-} and the usual qualified imports its'a little like that myname_
15:57:03 <lispy> I thought ByteString had thos enow
15:57:20 <applicative> it does
15:57:23 <lispy> @hoogle fromStrict
15:57:23 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
15:57:23 <lambdabot> Data.ByteString.Lazy.Char8 fromStrict :: ByteString -> ByteString
15:57:23 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
15:57:28 <shachaf> Pray, Mr. O'Sullivan, if you put into the Text wrong figures, will the right answers come out?
15:57:29 <chrisdone> oh, seems that bytestring has them
15:57:29 <mm_freak_> myname_: to make your life easier follow applicative's suggestion and also use the Monoid interface
15:57:33 <chrisdone> yeah
15:57:42 <mm_freak_> > "abc" <> "def"
15:57:42 <lambdabot>   "abcdef"
15:57:45 <mm_freak_> works with Text as well
15:57:57 <bos> the "<>" operator is pronounched "fishsticks"
15:57:57 <myname_> ok, i guess i'll need to try a few examples
15:58:01 <monochrom> haha shachaf
15:58:01 <lispy> > text "abc" <> text "def"
15:58:02 <lambdabot>   abcdef
15:58:07 <myname_> thanks!
15:58:09 <mm_freak_> :t text
15:58:10 <lambdabot> String -> Doc
15:58:16 <myname_> so how do i upvote again?
15:58:20 <bos> we need a "><>" operator too
15:58:22 <chrisdone> lispy: it used to kill me inside using fromChunks/toChunks
15:58:26 <leroux> How should I simplify this? http://lpaste.net/92341
15:58:28 <mm_freak_> myname_: nickname++
15:58:30 <myname_> mm_freak_++
15:58:41 <mm_freak_> @karma c
15:58:42 <lambdabot> c has a karma of 1
15:58:43 <lispy> chrisdone: Yeah, and it was poorly motivated
15:58:50 <myname_> applicative++
15:58:53 <mm_freak_> c++ hasn't been written?
15:58:55 <mm_freak_> @karma c
15:58:55 <lambdabot> c has a karma of 1
15:58:58 <Iceland_jack> bos: Yes we need more operators whose function cannot be inferred by their names! :)
15:59:00 <mcstar> i bet bos deserves a ++ too
15:59:00 <lispy> chrisdone: It was an intentional omission to get people to not ping-pong between the two
15:59:32 <mm_freak_> myname_: most of us don't really care about virtual karma though =)
15:59:38 <FreeFull> bos: I always pronounced <> mappend
15:59:44 <chrisdone> lispy: understandable
15:59:56 <monochrom> bos++
16:00:01 <mm_freak_> mm_freak_--
16:00:03 <mm_freak_> mm_freak++
16:00:27 <applicative> 'mappend' is so horrible i'll take any operator
16:00:31 <lispy> at one point java++ was an easter egg that would decrease your karma :)
16:00:41 <lispy> ?karma c
16:00:41 <lambdabot> c has a karma of 1
16:01:02 <mm_freak_> @karma C++
16:01:02 <lambdabot> C++ has a karma of -2
16:01:04 <mm_freak_> @karma C
16:01:04 <lambdabot> C has a karma of 1
16:01:07 <mm_freak_> lol
16:01:09 <applicative> i used to write (<>)=mappend; o = mempty but of course it was untenable
16:01:27 <mm_freak_> how come C++ has a lower karma than C?
16:01:39 <lispy> mm_freak_: have you used it? :)
16:01:46 <applicative> hahahahaha
16:01:46 <mm_freak_> lispy: sure
16:01:57 <applicative> lispy++
16:02:21 <monochrom> applicative: consider ^|{-><< :)
16:02:37 <mm_freak_> while both are a pain, C++ is less of a pain than C =)
16:02:39 <monochrom> err, I have an invalid { there. nevermind
16:03:20 <lispy> mm_freak_: I'd rather use C sparingly and when I need it and then skip over C++ for some proper high level language when I don't actually need C
16:03:33 <applicative> 'unterminated {-' is the error ...
16:03:42 <lpaste> chrisdone annotated “No title” with “leroux” at http://lpaste.net/92341#a92343
16:04:03 <chord> why isn't haskell dominating against erlang, clojure, lisp, etc.
16:04:15 <applicative> it crushes them all
16:04:16 <monochrom> why do I care
16:04:29 <lispy> chord: please elaborate
16:04:36 <applicative> chord: have you ever looked at any erlang???
16:04:41 <Iceland_jack> No please don't, we don't need a language war
16:04:42 <leroux> chrisdone: Thanks! I got it down to 4 lines with traverse... but now I'll use what you pasted.
16:04:45 <monochrom> but to answer: it surely dominates. in my home directory.
16:04:51 <leroux> chrisdone++
16:04:59 * chrisdone beams
16:05:21 <chord> you guys agree theres going to be a revival of functional programming because of multicore?
16:05:27 <chord> so which language will riseL?
16:05:37 <chrisdone> a revival implies there was a death
16:05:47 <chrisdone> and some kind of life in the past
16:05:47 <monochrom> I declare this off-topic.
16:05:51 <lispy> I think the revival has already started and I don't think multicore will play the role that has been hyped
16:06:08 <lispy> good point, #haskell-blah?
16:06:36 <mcstar> #haskell-functional-revival
16:06:37 <fylwind> nominolo: thanks for creating the account :)
16:06:39 <applicative> chord: anyway we love those other languages you mention.
16:07:47 <chord> if you need high multicore performance which language do you use
16:07:57 <mcstar> c++ + openmp
16:08:08 <lispy> I have friends that code in erlang and they're good people. Very hard working.
16:08:17 <chrisdone> lispy: lol
16:08:19 <c_wraith> lispy: that sounds like an insult
16:08:36 <chrisdone> lispy: "i'm not languagist, hell, some of my _friends_ are erlang programmers!"
16:08:36 <chord> mcstar really we still sticking with C++?
16:08:43 <mcstar> i am
16:08:44 <lispy> chrisdone: :)
16:09:55 <applicative> chord, I use erlang then http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=erlang&data=u64q
16:10:29 <chord> mcstar give me an answer that doesn't requier c++ pain
16:11:21 <mcstar> pain?
16:11:41 <chord> you like C++ ?
16:11:44 <fylwind> it is kinda painful after using a language like haskell
16:11:54 <mcstar> yes, more or less
16:11:59 <chord> WOW
16:12:03 <applicative> dunno that c++ is looking pretty good, its like almost 3x as fast as haskell and oh so safe http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp&data=u64q
16:12:08 <lispy> I've given up on explaining why I use haskell in terms of technical reasons. These days I simply tell people, "I enjoy programming in Haskell." Yes, it's that simple. Programming with haskell is enjoyable.
16:12:20 <applicative> it's beautiful
16:12:42 <applicative> it's unbelievable, really.
16:12:53 <mm_freak_> lispy: problem is that you can't use haskell everywhere
16:13:04 <mm_freak_> when i have a choice between C and C++, i choose C++
16:13:13 <lpaste> chrisdone annotated “No title” with “golfing” at http://lpaste.net/92341#a92344
16:13:43 <lispy> mm_freak_: When it comes down to C or C++ for me I usually don't get to choose :)
16:13:47 <mcstar> i really think the 'one language to rule them all' attitude is counterproductive
16:13:53 <[swift]> i find that a conversation about the benefits and drawbacks of haskell is not much fun unless the other person is familiar with some sort of ML-like language or at least some sort of lisp
16:14:16 <applicative> one idris to rule them all
16:14:21 <mm_freak_> mcstar: but haskell currently rules them all, as long as you can compile it to the target architecture =P
16:14:22 <Sonarpulse> ^ YES
16:14:26 <Sonarpulse> idris
16:14:28 <chrisdone> idchris
16:14:32 <chrisdone> :3
16:14:46 <lispy> idchris :: Chris -> Chris
16:14:48 <mm_freak_> idris has the potential to rule them all, but it doesn't yet =)
16:14:51 <chrisdone> :p
16:14:52 <FreeFull> Lisp is very far from the ML world
16:15:17 <Sonarpulse> I asked earlier, do you all think Haskell will have dependant types in 10 years?
16:15:21 <chrisdone> lisp belongs in the python, ruby camp
16:15:22 <chord> so why do people choose lisp or erlang over haskell?
16:15:27 <mm_freak_> Sonarpulse: unlikely
16:15:33 <chrisdone> chord: they do?
16:15:39 <applicative> they do??
16:15:41 <mcstar> 'who knows such things? only the Oracle'
16:15:47 <mm_freak_> chord: erlang has a problem domain haskell currently doesn't solve
16:15:54 <FreeFull> chrisdone: Lisp isn't really like python or ruby either
16:15:58 <Sonarpulse> distributed process?
16:15:59 <mm_freak_> but why people choose lisp?  no idea
16:16:02 <mm_freak_> ask paul graham
16:16:15 <fylwind> do you include "scheme" under lisp?
16:16:23 <chrisdone> Sonarpulse: i presume you mean full dependent types, not limited or some subset. it could have them today, but do you want full dependent types?
16:16:30 <Sonarpulse> I feel idris and agda and epigram will pull haskell in that direction
16:16:32 <mm_freak_> fylwind: i referred to common lisp
16:16:32 <lispy> It was fun to have abit of off-topic discussion, but we should probably get back to Haskell.
16:16:33 <chirpsalot> mm_freak_: if you want to implement a language lispy ones are great :P
16:16:41 <Sonarpulse> lest Haskell go the fate of OCaml
16:16:49 <mm_freak_> chirpsalot: eager/strict lispy ones are
16:16:51 <fylwind> mm_freak_: ah, the uglier of the siblings :)
16:16:52 <FreeFull> Scheme is more lisp than lisp
16:16:54 <mcstar> ppl just want to program their algorithms, irrespective or typing, and they dont care much about ahead-of-time verfication
16:17:03 <mcstar> of*
16:17:05 <thr33strikes> just installed cabal and did an update, will that alone give me access to the module System
16:17:08 <chrisdone> FreeFull: lisp is far more similar to python and ruby than ml
16:17:11 <chord> mcstar until it deletes your harddrive
16:17:21 <mcstar> haskell can do that too
16:17:27 <applicative> emacs --execute "(print (+ 1 2 3))"
16:17:30 <lispy> thr33strikes: You mean access to hackage?
16:17:37 <mm_freak_> in fact GHC used to delete your source file when you had a type error
16:17:38 <FreeFull> chrisdone: I'd say it simply stands on its own
16:17:42 <chrisdone> FreeFull: dynamically, strongly typed, imperative, interpreted culture
16:17:51 <mm_freak_> http://www.reddit.com/r/haskell/comments/127emo/brian_osullivans_favorite_bug_in_ghc/
16:17:58 <thr33strikes> does hackage include the System module?
16:18:05 <chrisdone> FreeFull: the only differences i can think of is the syntax and macrology culture. can you think of other differences?
16:18:17 <applicative> thr33strikes: I think you are looking at an old tutorial?
16:18:20 <mm_freak_> thr33strikes: there is no System module
16:18:28 <FreeFull> thr33strikes: System was part of haskell 98 but isn't in the newer standard
16:18:34 <chirpsalot> mm_freak_: it was just so offended that you would feed it such an ill-typed program :).
16:18:42 <thr33strikes> what took it's place?
16:18:43 <lispy> thr33strikes: ah, I misunderstood your question.
16:18:49 <mm_freak_> =)
16:18:53 <applicative> thr33strikes: I think it's broken up
16:19:00 <lispy> thr33strikes: what thing do you need from System? We can use hoogle to find it
16:19:03 <lispy> ?hoogle getArgs
16:19:03 <lambdabot> System.Environment getArgs :: IO [String]
16:19:03 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
16:19:03 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
16:19:07 <leroux> chrisdone: How can I change it from [a] to a?
16:19:10 <applicative> thr33strikes: if you specify haskell 98 it will understand you
16:19:11 <leroux> I don't need that forM...
16:19:18 <chrisdone> leroux: `it'?
16:19:22 <leroux> Uhh.
16:19:24 <leroux> http://lpaste.net/92341#a92343
16:19:26 <wavewave> hi
16:19:42 <applicative> thr33strikes: what is the module your are looking at, that imports System? can you paste it?
16:19:43 <leroux> file is a Maybe FilePath
16:19:48 <chrisdone> leroux: ?
16:19:51 <applicative> hi wavewave
16:19:53 <chrisdone> mhm
16:20:00 <mm_freak_> leroux: if you need a specific piece of functionality it is always a good idea to write its type first
16:20:05 <mm_freak_> is [a] -> a what you want?
16:20:14 <wavewave> applicative: hi hi
16:20:16 <chrisdone> @djinn [a] -> a
16:20:16 <lambdabot> Error: Undefined type []
16:20:22 <chrisdone> bah, always forget about that
16:20:27 <chrisdone> djinn, learn some more stuff
16:20:37 <mm_freak_> let him figure out himself what's wrong with the type =)
16:20:44 <mcstar> :t head
16:20:44 <lambdabot> [a] -> a
16:20:49 <mcstar> thats a nice one
16:20:52 <leroux> Not head...
16:20:57 <mm_freak_> mcstar: call "spoiler alert" first
16:21:00 <chrisdone> mm_freak_: “that is why you will fail”
16:21:02 <mcstar> oh
16:21:04 <Sonarpulse> chrisdrone: does idris have "full dependent types"
16:21:06 <lispy> Tip for anyone using chrome: You can make a shortcut so that tying 'h foo' in the address bar does a hoogle search. In settings manage search engines and add an entry like this: http://www.haskell.org/hoogle/?hoogle=%s
16:21:12 <mm_freak_> Sonarpulse: yes
16:21:14 <applicative> Sonarpulse: !!!!
16:21:15 <thr33strikes> I was trying to use System.Directory
16:21:22 <Sonarpulse> just checking....
16:21:27 <geekosaur> thr33strikes, you already have it, but it's not accessible by default. You can force the comp-iler into haskell98 mode and then you'd have System. But then you'll have trouble using modern Haskell modules
16:21:49 <alexander__b> stephan boyer's functional programming intro with "fython" are quite nice
16:21:54 <applicative> ah, so you figured it out thr33strikes ?
16:22:12 <alexander__b> implements Maybe, List and Writer in a python-like language to help you understand them (and monads in general). I approve.
16:22:16 <fylwind> there's a quirk with the chrome search: if you type a search with the wRonG cAsing once, chrome will remember it and use it every time
16:22:22 <geekosaur> yeh
16:22:37 <chrisdone> Sonarpulse: there's a tension between the type system being powerful and not requiring you to provide it with proofs
16:22:44 <Sonarpulse> Sure
16:22:53 <thr33strikes> I'd like to stay modern but I was looking for a portable way to rename files within a directory
16:23:13 <Sonarpulse> I would say keep "System F Haskell" and "System FC Haskell"  as langauge subsets
16:23:20 <Sonarpulse> for those that really care about type inference
16:23:21 <thr33strikes> I could sit here and hack away at it but I'm sure it's an easy lib command
16:23:26 <lispy> fylwind: heh
16:23:28 <mm_freak_> my experience with agda is that you don't really have to /write/ type signatures…  you only tell, "here is the type signature, figure out its content", and most of the time it works
16:23:33 <lpaste> leroux pasted “filePerms” at http://lpaste.net/92345
16:23:40 <applicative> thr33strikes: you can just give the modules the name of the files and they will compile together thr33strikes
16:23:44 <mm_freak_> idris might follow a similar path as soon as we have a good emacs mode for it =)
16:23:56 <chrisdone> don't tempt me
16:23:57 <leroux> chrisdone: If you could, take a look at filePerms.
16:24:13 <lispy> mm_freak_: you put holes in the type signatures?
16:24:20 <lispy> mm_freak_: is that what you mean?
16:24:22 * applicative started using idris first to escape emacs
16:24:29 <mm_freak_> lispy: either that or this:  f : _ → _ → _
16:24:35 * applicative then realized it was better anyway
16:25:00 <mm_freak_> depending on whther i'm planning to write the type signature or just leave it with placeholders
16:25:28 <lispy> mm_freak_: oh, I hadn't thought of using wild cards. So then can you C-c C-. f <RET> to find out the type of f?
16:25:36 <mm_freak_> applicative: depending on what you mean by "better"
16:25:41 <mm_freak_> agda is better for theorem proving
16:25:44 <fl00r> is there a way to zip two lists but keep the rest of the longer one?
16:25:46 <Sonarpulse> Did the idris people ever plan on forking GHC instead of writing their own compiler?
16:25:49 <thr33strikes> seemed like the System.Directory was easy to use already,  I'm sure there is a good reason why it was removed.  I'm just too new to know why, can anyone answer?
16:26:14 <applicative> agda does have any 'theorem proving' support
16:26:17 <applicative> doesnt
16:26:24 <chord> you guys need to work on GHC to make it generate code that beats C++ in the benchmarks
16:26:34 <mm_freak_> lispy: what does that command do?
16:26:42 <mcstar> 't <== f means "apply f with arguments such that it returns a value of type t"' omg, witchcraft
16:26:48 <applicative> Sonarpulse: the compiler is totally different; it already writes java javascript you name it
16:27:00 <Sonarpulse> as target langauge?
16:27:07 <Sonarpulse> interesting
16:27:16 <applicative> mm_freak_: idris is *way* better for actual 'theorem proving'
16:27:23 <Sonarpulse> well my point is there if Idris does become the one lanague to rule them all
16:27:25 <ion> java{,script}
16:27:28 <applicative> i don't actually see any use for agda at all
16:27:37 <Sonarpulse> it would be a shame to throw away all the work that went into GHC
16:27:45 <applicative> except for -without-K
16:27:57 <mm_freak_> applicative: does it allow coinductive proofs?
16:28:30 <mm_freak_> i mean proper coinduction using codata or guards…  coinduction that doesn't allow you to prove false
16:28:34 <lispy> mm_freak_: Isn't that the command that normalizes a term?
16:28:52 <applicative> codata are built into idris from the bottom up
16:28:53 <mm_freak_> lispy: i don't know…  the set of commands i use is very limited =)
16:29:10 <mm_freak_> applicative: that's not the question
16:29:11 <lispy> mm_freak_: what I'm trying to ask is: if you do that trick with _ then is there a way to ask agda to tell you what it inferred?
16:29:20 <mietek> Failed to install cryptocipher-0.3.1
16:29:26 <mietek> Anyone else?
16:29:38 <mm_freak_> lispy: good question…  i don't think so
16:29:44 <mm_freak_> well, yes
16:29:47 <mm_freak_> you can ask for the type of f
16:30:07 * lispy should just try it
16:30:38 <mm_freak_> lispy: agda2-infer-type-toplevel
16:30:46 <mm_freak_> but it seems like it's not bound by default
16:30:49 <mietek> http://hackage.haskell.org/packages/archive/cryptocipher/0.3.1/logs/failure/ghc-7.4
16:30:57 <mietek> I'm in cabal hell again
16:31:05 <applicative> mm_freak_: define a function Stream a -> Stream a, where codata Stream a = Cons a (Stream a)
16:31:22 <mietek> And this time, it's due to trying to install git-annex from a completely blank slate
16:32:44 <lispy> mm_freak_: C-c C-d
16:32:53 <lispy> but it's just telling me f's type is metavariables
16:33:44 <thr33strikes> am I forced to use the old System.Directory if I need to manipulate directory names
16:35:24 <mm_freak_> applicative: (xs : Stream Nat) -> AllEven xs -> AllEven (map (+ 2) xs)
16:35:32 <mm_freak_> would you trust such a proof in idris?
16:35:38 <geekosaur> thr33strikes, you were a little unclear before. System.Directory is current
16:35:47 <geekosaur> everything used to be jumbled into System before
16:36:18 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/directory-1.2.0.1/System-Directory.html
16:36:26 <thr33strikes> thanks
16:36:35 <jfischoff> what steps does cabal take to build with profiling when there is template haskell? I need to recreate the logic in make, anyone have an example make file that does a profiling build?
16:38:19 <monochrom> I think cabal just calls ghc with -prof -fauto-prof etc
16:38:30 <geekosaur> use cabal -v3 to watch what it does?
16:38:54 <monochrom> but yeah use cabal -v3 or maybe -v2 or -v1 to see for real
16:39:39 <chrisdone> @let zipRemainder f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span (uncurry (on (&&) isJust)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just))
16:39:40 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
16:39:55 <chrisdone> :t let zipRemainder f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span (uncurry (on (&&) isJust)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) in zipRemainder
16:39:56 <lambdabot> (a1 -> a1 -> a) -> [a1] -> [a1] -> ([a], [a1])
16:40:14 <chrisdone> fl00r: behold, my creation
16:40:18 <chrisdone> ψ(｀∇´)ψ
16:40:20 <fl00r> holy...
16:40:22 <jfischoff> cool thanks guys
16:40:25 * applicative is working on AllEven but must go, mm_freak_ 
16:40:35 <monochrom> you are to be congratulated. what does it do anyway? :)
16:40:35 <arkeet> you're a monster
16:40:45 <arkeet> > zipRemainder (,) [1,2] [3,4,5,6]
16:40:45 <mm_freak_> applicative: i'm not asking whether you can write the proof in idris — you can
16:40:46 <lambdabot>   Not in scope: `zipRemainder'
16:40:52 <chrisdone> > curry ((catMaybes.map(uncurry (liftM2 (,)))***catMaybes.takeWhile isJust.map snd) . span (uncurry (on (&&) isJust)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) [1,2,3] [1,2,3,4,5]
16:40:52 <mm_freak_> applicative: i'm asking whether you can /trust/ the proof
16:40:53 <lambdabot>   ([(1,1),(2,2),(3,3)],[4,5])
16:41:00 <mm_freak_> applicative: because you can certainly prove false in idris
16:41:09 <arkeet> chrisdone: now make it work with two different input types
16:41:25 <fl00r> it's going to take me 2 hours to figure what it's doing
16:41:26 <fl00r> haha
16:41:38 <fl00r> impressive
16:41:52 <applicative> mm_freak_: oh, thats what you're worried about; i would hope it wasn't so conservative you couldn't prove false every few minutes
16:41:53 * monochrom likes the tone of "this software looks awesome! what problem does it solve anyway?"
16:42:04 <arkeet> @let import Data.These
16:42:05 <lambdabot>  .L.hs:102:1:
16:42:05 <lambdabot>      Failed to load interface for `Data.These'
16:42:05 <lambdabot>      Perhaps you...
16:42:06 <arkeet> =(
16:42:28 <monochrom> Perhaps you mean: Data.This, Data.That, Data.Those
16:42:41 <fylwind> what's ψ(｀∇´)ψ for?
16:42:46 <mm_freak_> applicative: idris requires you to enable the termination checker, which is very conservative
16:42:57 <mm_freak_> applicative: my fear is that it may not handle coinductive proofs properly
16:42:59 <chrisdone> this is a common problem, there must be a zipWithRemainder thingie somewhere
16:43:15 <arkeet> chrisdone: check out Data.Align
16:43:25 <applicative> mm_freak_: the track record of agda and coq can hardly be better ;)
16:43:44 <arkeet> not quite the same, perhaps
16:43:52 <mm_freak_> applicative: the difference is that idris doesn't even try ;)
16:43:56 <arkeet> alignWith :: (These a b -> c) -> f a -> f b -> f c
16:44:02 <applicative> mm_freak_: i have *much* more confidence in the principal developer
16:44:09 <mm_freak_> if you can prove false in agda, it's a major bug
16:44:23 <mm_freak_> in fact it will immediately become the highest priority bug
16:44:47 <mm_freak_> that's basically the difference between a "proof assistant" and a "programming language with dependent types" =)
16:44:48 <chrisdone> :t let zipRemainder f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span ((\(x,y) -> isJust x&&isJust y)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) in f
16:44:48 <lambdabot> FromExpr a => a
16:44:55 <chrisdone> :t let zipRemainder f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span ((\(x,y) -> isJust x&&isJust y)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) in zipRemainder
16:44:56 <lambdabot> (a1 -> a2 -> a) -> [a1] -> [a2] -> ([a], [a2])
16:45:03 * hackagebot kevin 0.10.0 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.10.0 (JoelTaylor)
16:45:11 <arkeet> now what if I have more a1s than a2s
16:45:15 <applicative> mm_freak_: this is truly absurd but I must go
16:45:19 <chrisdone> arkeet: the same-type restriction acme from the on (&&) isJust
16:45:23 <monochrom> there hasn't been a prove-false incident for a long time, isn't that right?
16:45:35 <mm_freak_> monochrom: as far as i know, yes
16:45:37 <mm_freak_> applicative: have fun =)
16:45:42 <fl00r> i feel less embarrassed that i couldn't figure out how to do it now
16:45:58 <mcstar> it is way easier than chrisdone suggests
16:46:03 <mcstar> you should just write it yourself
16:46:04 <monochrom> that's good to hear and more than good enough for me
16:46:38 <mm_freak_> i think the last bug was because of a collapsed universe
16:46:41 <mm_freak_> i.e. Type : Type
16:46:55 <mm_freak_> or rather Set : Set in agda terms
16:47:16 <chrisdone> fl00r: yeah i'm just messing around. a simple fold or basic recursion would give you the solution in short time
16:47:38 <fl00r> ok cool
16:47:45 <fl00r> thanks!
16:48:00 <deech> Hi all, I'm trying to get my Haskell library to statically link against a C library but so far have been unsuccessful. The output of `cabal build` is here: https://gist.github.com/deech/6395316
16:48:29 <mm_freak_> fl00r: what would be the type of such a function anyway?
16:48:40 <mm_freak_> because "keep the longer suffix" doesn't seem to make sense to me
16:49:01 <tel> arkeet isn't it just `partitionThese . align`?
16:49:03 <mcstar> ([(a,a)],[a])
16:49:47 <fl00r> well i was thinking something like [a] -> [b] -> ([(a, b)], [a], [b])
16:50:02 <chrisdone> @data These a b = This a | That b | These a b
16:50:02 <lambdabot> Unknown command, try @list
16:50:03 * hackagebot damnpacket 0.1.0.2 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.0.2 (JoelTaylor)
16:50:12 <chrisdone> what was the syntax
16:50:20 <arkeet> fl00r: that is (partitionTHese .) . align
16:50:20 <jmcarthur> fl00r: might as well be   [a] -> [b] -> ([(a,b)], Either [a] [b])
16:50:34 <geekosaur> "@let data ..."
16:50:40 <chrisdone> @let data These a b = This a | That b | These a b
16:50:41 <lambdabot>  Defined.
16:50:43 <chrisdone> kewl
16:51:01 <mm_freak_> :t \xs ys -> let zs = zip xs ys; n = length zs in (zs, drop n xs, drop n ys)
16:51:02 <lambdabot> [a] -> [a1] -> ([(a, a1)], [a], [a1])
16:51:10 <mm_freak_> write it properly though =)
16:51:13 <tel> arkeet I'm getting non-exhaustive patterns in partitionThese though
16:51:21 <arkeet> @let align xs [] = This <$> xs; align [] ys = That <$> ys; align (x:xs) (y:ys) = These x y : align xs ys
16:51:22 <lambdabot>  Defined.
16:51:37 <arkeet> tel: that's a bug!
16:51:46 <tel> !!
16:51:51 <fl00r> awesome...definitely will be able to figure it out now
16:51:55 <fl00r> thanks, everyone
16:51:57 <tel> this was just pulled from hackage
16:51:59 <chrisdone> mm_freak_: eww named variables =p
16:52:02 <arkeet> it's a bug in these!
16:52:10 <tel> arket :(
16:52:14 <tel> arkeet :(
16:52:16 <mm_freak_> chrisdone: eww arrows ;)
16:52:19 <chrisdone> needs moar golf
16:52:34 <jmcarthur> this is commonly desired enough that there should be a standard function for some variant of this
16:52:43 <mm_freak_> chrisdone: the named variables are for sharing
16:52:43 <arkeet> partitionTHese [] = ([],([],[])); partitionThese (These x y:xs) = first ((x, y):) $ partitionThese xs; partitionThese (This x :xs) = second (first (x:)) $ partitionThese xs; partitionThese (That y:xs) = second (second (y:)) $ partitionThese xs
16:52:47 <arkeet> @let partitionTHese [] = ([],([],[])); partitionThese (These x y:xs) = first ((x, y):) $ partitionThese xs; partitionThese (This x :xs) = second (first (x:)) $ partitionThese xs; partitionThese (That y:xs) = second (second (y:)) $ partitionThese xs
16:52:48 <lambdabot>  Defined.
16:52:51 <arkeet> oh crap.
16:52:51 <arkeet> I can't type.
16:52:53 <arkeet> @Undefine
16:52:53 <lambdabot> Undefined.
16:52:54 <tel> hah, I was just doing that
16:52:56 * chrisdone golf claps to get everyone in the mood
16:52:57 <chrisdone> https://www.youtube.com/watch?v=sTHHjTV5PL0
16:52:57 <arkeet> @let partitionTHese [] = ([],([],[])); partitionThese (These x y:xs) = first ((x, y):) $ partitionThese xs; partitionThese (This x :xs) = second (first (x:)) $ partitionThese xs; partitionThese (That y:xs) = second (second (y:)) $ partitionThese xs
16:52:58 <lambdabot>  .L.hs:143:17: Not in scope: data constructor `These'
16:52:58 <lambdabot>  
16:52:58 <lambdabot>  .L.hs:145:17: Not in...
16:53:03 <arkeet> @let partitionThese [] = ([],([],[])); partitionThese (These x y:xs) = first ((x, y):) $ partitionThese xs; partitionThese (This x :xs) = second (first (x:)) $ partitionThese xs; partitionThese (That y:xs) = second (second (y:)) $ partitionThese xs
16:53:03 <lambdabot>  .L.hs:143:17: Not in scope: data constructor `These'
16:53:04 <lambdabot>  
16:53:04 <lambdabot>  .L.hs:145:17: Not in...
16:53:09 <arkeet> ooops.
16:53:22 <arkeet> @let data These a b = This a | That b | These a b deriving (Eq,Show)
16:53:23 <lambdabot>  Defined.
16:53:25 <geekosaur> heh
16:53:27 <arkeet> @let align xs [] = This <$> xs; align [] ys = That <$> ys; align (x:xs) (y:ys) = These x y : align xs ys
16:53:27 <lambdabot>  Defined.
16:53:30 <arkeet> @let partitionThese [] = ([],([],[])); partitionThese (These x y:xs) = first ((x, y):) $ partitionThese xs; partitionThese (This x :xs) = second (first (x:)) $ partitionThese xs; partitionThese (That y:xs) = second (second (y:)) $ partitionThese xs
16:53:31 <lambdabot>  Defined.
16:53:38 <arkeet> :t (partitionThese.).align
16:53:39 <lambdabot> [a] -> [a1] -> ([(a, a1)], ([a], [a1]))
16:53:43 <tel> @let (.:) = (.).(.)
16:53:44 <lambdabot>  Defined.
16:53:48 <tel> partitionThese .: align
16:53:51 <tel> :t partitionThese .: align
16:53:51 <lambdabot> [a] -> [a1] -> ([(a, a1)], ([a], [a1]))
16:53:52 <tel> :P
16:54:15 <arkeet> :t \f -> first (fmap f) . (partitionThese.) . align
16:54:15 <lambdabot>     Couldn't match type `(f0 a0, d0)'
16:54:16 <lambdabot>                   with `[a10] -> ([(a1, a10)], ([a1], [a10]))'
16:54:16 <lambdabot>     Expected type: ([a10] -> ([(a1, a10)], ([a1], [a10])))
16:54:21 <chrisdone> poor fl00r. i asked #haskell and all i got was this lousy lambdabot tshirt
16:54:26 <tel> > (partitionThese .: align) [1,2,3] [1,2]
16:54:29 <lambdabot>   ([(1,1),(2,2)],([3],[]))
16:54:29 <fl00r> haha
16:54:35 <arkeet> :t \f -> (first (fmap f) . partitionThese .) . align
16:54:36 <lambdabot>     The operator `.' [infixr 9] of a section
16:54:36 <lambdabot>         must have lower precedence than that of the operand,
16:54:36 <lambdabot>           namely `.' [infixr 9]
16:54:38 <arkeet> afggh
16:54:45 <arkeet> :t \f -> (first (fmap f) . partitionThese) .: align
16:54:46 <lambdabot> ((a, a1) -> b) -> [a] -> [a1] -> ([b], ([a], [a1]))
16:54:55 <mm_freak_> ok, this is annoying…  i'm returning to my editor =)
16:54:57 <arkeet> :t \f -> (first (fmap $ curry f) . partitionThese) .: align
16:54:58 <lambdabot> (((a, a1), b) -> c) -> [a] -> [a1] -> ([b -> c], ([a], [a1]))
16:55:01 <arkeet> nope.
16:55:03 * hackagebot damnpacket 0.1.0.3 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.0.3 (JoelTaylor)
16:55:07 <arkeet> :t \f -> (first (fmap $ uncurry f) . partitionThese) .: align
16:55:07 <lambdabot> (a -> a1 -> b) -> [a] -> [a1] -> ([b], ([a], [a1]))
16:55:29 <chrisdone> arkeet: take your fail to /msg lambdabot, only great success may be displayed herein =p
16:55:35 <arkeet> but I'm done.
16:55:51 <chrisdone> that's what she said
16:55:55 <jmcarthur> but you named f
16:55:57 * chrisdone regrets
16:56:06 <jmcarthur> chrisdone: fail
16:56:08 <chrisdone> jmcarthur: hahaha
16:56:24 <chrisdone> @unpl \f -> (first (fmap $ uncurry f) . partitionThese) .: align
16:56:24 <lambdabot> \ f -> (\ c -> first (fmap (uncurry f)) (partitionThese c)) .: align
16:56:29 <chrisdone> @pl \f -> (first (fmap $ uncurry f) . partitionThese) .: align
16:56:32 <lambdabot> (.: align) . flip ((.) . first . (fmap $) . uncurry) partitionThese
16:56:33 <lambdabot> optimization suspended, use @pl-resume to continue.
16:56:50 <arkeet> @let zipRemainder f = (partitionEithers .) . zipWIth (\a b -> maybe (Left b) (Right . (f ?? b)) a) . (++ repeat Nothing) . map Just
16:56:51 <lambdabot>  .L.hs:160:7:
16:56:51 <lambdabot>      Not in scope: `zipWIth'
16:56:51 <lambdabot>      Perhaps you meant one of thes...
16:56:54 <arkeet> ....
16:56:58 <chrisdone> arkeet: no fail!
16:56:59 <arkeet> @let zipRemainder f = (partitionEithers .) . zipWith (\a b -> maybe (Left b) (Right . (f ?? b)) a) . (++ repeat Nothing) . map Just
16:57:00 <lambdabot>  Defined.
16:57:02 <arkeet> :P
16:57:04 <arkeet> :t zipRemainder
16:57:05 <lambdabot> (a -> a1 -> b) -> [a] -> [a1] -> ([a1], [b])
16:57:22 <jmcarthur> ...
16:57:25 <jmcarthur> fail
16:57:27 <jmcarthur> try again
16:57:30 <jmcarthur> elsewhere
16:57:31 <arkeet> no
16:57:31 <chrisdone> yeah, that only takes the second list
16:57:38 <chrisdone> only an idea would make a function taht does that
16:57:40 <chrisdone> <_<
16:57:44 <arkeet> chrisdone: and I suppose yours did something else.
16:57:45 <chrisdone> > _>
16:57:46 <lambdabot>   <hint>:1:3:
16:57:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
16:57:53 <ezrios> hah
16:58:49 <arkeet> @let zipRemainder' f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span ((\(x,y) -> isJust x&&isJust y)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just))
16:58:49 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
16:59:14 <arkeet> er?
16:59:48 <arkeet> > let zipRemainder' f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span ((\(x,y) -> isJust x&&isJust y)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) in zipRemainder' (,) [1,2] [3..6]
16:59:50 <lambdabot>   ([(1,3),(2,4)],[5,6])
17:00:06 <arkeet> > let zipRemainder' f = curry ((catMaybes.map(uncurry (liftM2 f))***catMaybes.takeWhile isJust.map snd) . span ((\(x,y) -> isJust x&&isJust y)) . uncurry zip . ((++repeat Nothing).map Just *** (++repeat Nothing).map Just)) in zipRemainder' (,) [1..4] [5..6]
17:00:07 <lambdabot>   ([(1,5),(2,6)],[])
17:00:19 <arkeet> yeah, same as mine.
17:00:20 <chrisdone> i like that you had to run it to be sure =)
17:00:35 <mcstar> > let zipret xs ys = (zip (take m xs) (take m ys), if d > 0 then drop d xs else drop d ys) where l1 = length xs; l2 = length ys; d = l1-l2; m = min l1 l2 in zipret [1,2,3] [4,3,5,4,3,2]
17:00:36 <lambdabot>   ([(1,4),(2,3),(3,5)],[4,3,5,4,3,2])
17:00:37 <arkeet> well, I didn't even try to understand it except by looking at the type.
17:00:49 <arkeet> eww, length
17:01:04 <arkeet> eww, Int
17:01:24 <nooodl> isn't that supposed to return ([(1,4),(2,3),(3,5)],[4,3,2])
17:01:41 <arkeet> he got d wrong.
17:01:58 <mcstar> (negate d)
17:01:59 <arkeet> perhaps if he used abs...
17:02:19 <mcstar> sry, its late
17:02:58 <arkeet> but still, length =(
17:03:11 <mcstar> i didnt want to write out a recursive function
17:03:32 <arkeet> you could have used lazy nats
17:03:38 <mcstar> thats fl00r's homework :)
17:03:46 <arkeet> where length = void, (-) = (\\), and so on
17:04:01 <arkeet> take = zipWith (const id)
17:04:19 <arkeet> min = zipWith const, as well.
17:04:22 <fl00r> i didn't know data.these existed...there's some cool stuff in there
17:04:26 <chrisdone> drop = unsafePerformIO (system "xeyes&killall life")
17:04:34 <arkeet> haha
17:04:47 <nooodl> http://codepad.org/RuUhDEKN is this valid
17:05:02 <chrisdone> hehe, that url sounds like a street fighter move
17:05:04 * hackagebot handa-gdata 0.6.7 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.7 (BrianBush)
17:05:58 <chrisdone> nooodl: pretty fly for a nooodl guy
17:06:37 <monochrom> I love xeyes
17:06:38 <mcstar> 2 am, bb
17:06:53 <edwardk> chrisdone: hah!
17:06:54 <chrisdone> monochrom: me2
17:07:14 <chord> you guys ever make a game with haskell?
17:08:06 <arkeet> ok, sent a pull request for these.
17:08:06 <ski_> chrisdone : yeah, that's OCaml's labels, described at the same page as the polymorphic variants link i mentioned above
17:08:34 <chrisdone> aha
17:08:55 <edwardk> Arkeet good it'll fix those haddocks too!
17:09:31 <arkeet> ??
17:09:55 <chrisdone> elliott: wonder if we can get `these' in lambdabot =]
17:10:03 <edwardk> The ones on hackage were built back when haddock had a bug/ bad interaction w GHC API
17:10:03 <arkeet> ^
17:10:11 <arkeet> edwardk: ah, so just a new upload will fix it.
17:10:22 <edwardk> Yeah
17:10:23 <elliott> chrisdone: one second, have to deal with something else first.
17:10:44 --- mode: ChanServ set +o elliott
17:10:47 --- mode: elliott set +b *!*322f530e@*.50.47.83.14
17:10:47 --- kick: chord was kicked by elliott (chord)
17:10:50 <chrisdone> elliott: didn't mean immediately, just a suggestion for your `copious free time' =)
17:10:53 --- mode: elliott set +b chord!*@*
17:10:55 --- mode: elliott set -o elliott
17:11:01 <elliott> okay, now I'll start considering it.
17:11:02 <arkeet> hm, what did chord do?
17:11:11 <arkeet> or was he one of those persistent trolls
17:11:16 <elliott> arkeet: get banned for doing exactly what you see in /lastlog chord
17:11:17 <elliott> twice.
17:11:21 <elliott> or more.
17:11:31 <Fuuzetsu> edwardk: what Haddock bug?
17:11:36 <monochrom> elliott has long memory :)
17:11:36 <arkeet> ah, I see.
17:11:41 <arkeet> the name sounds familiar anyway.
17:11:48 <elliott> edwardk was too reasonable for chord the first time so they had to troll about bitcoin or something to finally get banned :p
17:12:03 <chrisdone> documentation of trollery http://ircbrowse.net/browse/haskell?q=chord
17:12:27 <monochrom> chrisdone + elliott = big brother is watching you! :)
17:12:35 <tel> kill them with kindness..?
17:12:49 <monochrom> Departments of Truth and Love :)
17:12:54 <edwardk> Fuuzetsu: It was including lots of 'administrative' instance requirements in the haddocks, making them scary
17:12:57 <elliott> you don't need kindness for ban evasion :)
17:13:00 <chrisdone> 2+2=5
17:13:09 <chrisdone> (…with the appropriate Num instance)
17:13:21 <edwardk> Things that it already had, so the instances looked way worse than they were
17:13:30 <monochrom> (or just hide Prelude's (+) and define your own)
17:13:42 <c_wraith> > let 2 + 2 = 3.997 in 2 + 2
17:13:43 <lambdabot>   3.997
17:14:07 <Fuuzetsu> edwardk: Is it fixed? Is there a ticket?
17:14:08 <chrisdone> monochrom: import O'Brien ((+))
17:14:19 <edwardk> Long fixed, and there was
17:14:23 <tel> monochrom does that go into the whole "How to Write Maintainable Haskell Code" bit?
17:15:02 <elliott> chrisdone: looks like these fails to be Safe Haskell going by the haddocks
17:15:10 <chrisdone> ah
17:15:13 <elliott> though that may be the fault of a dependency and upload time and not true if I installed it now
17:15:19 <arkeet> huh hmm.
17:15:23 <arkeet> I'm looking at the lenses in these.
17:15:32 <elliott> it goes to show how little people care about Safe Haskell that everything is broken in it
17:15:49 <arkeet> why isn't here = _This and there = _That, and havit be a type-changing prism?
17:16:07 <edwardk> Safety is a nice goal, but overrated
17:16:08 <arkeet> oh wait never mind...
17:16:10 <monochrom> Safe Haskell is fairly new. people need time to adapt.
17:16:18 <arkeet> because These.
17:16:33 <edwardk> That and it is too easy to screw up
17:16:57 * arkeet considers what the Monad instance for These is
17:16:57 <edwardk> I wish saying Trustworthy was setting a floor rather than lowering Safe to Trustworthy
17:17:00 <elliott> monochrom: I tend to see support for Safe HAskell regressing :/
17:17:19 <chrisdone> edwardk: i really want to spend a weekend porting ndm's `catch' to ghc
17:17:39 <monochrom> but I predict: in the long run, more people will care about Safe Haskell than about getting more Haskell libs to work on Windows!
17:17:52 <edwardk> Sounds fun, chrisdone
17:17:56 <chrisdone> monochrom: ha
17:18:16 <arkeet> yeah, I guess it's what I expected.
17:18:16 <edwardk> They already do
17:18:47 * arkeet ponders whether it's lawful
17:20:46 <Sonarpulse> edwardk, is bytes supposed to eventually replace binary and serial?
17:21:47 <edwardk> Sonarpulse: It is so I can avoid duplicating code to work with both
17:22:02 <edwardk> Also it let me avoid the annoying list encodings in each
17:22:54 <Sonarpulse> ok
17:23:25 <Sonarpulse> The fact it does both so nicely is great evidence how redundant they are
17:23:57 <glguy> binary is converging with cereal
17:24:08 <tel> glguy is one slated to eat the other?
17:24:15 <glguy> I don't think so
17:24:17 <Sonarpulse> crossing fingers...
17:24:23 <edwardk> glguy: Well, bytes is just a thin compatibility shim over both
17:24:34 <ski_> leroux : .. did you manage to get something working ?
17:24:35 <glguy> I'm just explaining why they are so similar now
17:24:40 <edwardk> Yeah
17:25:14 <leroux> ski_: http://ghc.haskell.org/trac/ghc/attachment/ticket/2184/0001-Fix-2184.-findExecutable-checks-if-the-file-actually.patch
17:25:22 <tel> Is there any guidance on how to pick between them even? I once thought it was a lazy/strict thing, but I think even that's been equilibriated?
17:25:29 <Sonarpulse> the overlap between those two just makes me feels so OCD
17:25:49 <edwardk> Tel: it's lazy vs strict still
17:25:50 <glguy> f.s.v.o OCD
17:25:59 <tel> ok
17:26:12 <glguy> You can run binary on strict stuff now with the incremental run functions
17:26:26 <glguy> and cereal's "Put" functionality isn't different from binary's
17:27:28 <edwardk> I'm not wedded to keeping bytes if binary has fully subsumed the other. It came about pragmatically I needed both instances for stuff in the old analytics code base
17:28:28 <ski_> leroux : the last lines looks like an instance of `(>>=)' for `Maybe'
17:29:02 <glguy> the only thing I'm aware of that binary is missing that cereal has is "isolate" and "label"
17:29:13 <leroux> ski_: You're right.
17:29:37 <tel> glguy what does label even do?
17:29:54 <glguy> labels a sub parser to help you figure out parse errors
17:30:04 <glguy> you get a stack trace when something goes wrong
17:30:06 <tel> oh
17:30:32 <edwardk> What'll probably happen is when I tackle semi indexed binary, I'll do that in bytes.
17:31:45 <tel> edwardk do you have semi-indexed json somewhere already? or was that just a joke on reddit?
17:32:07 <edwardk> It's not a joke, but it isn't on hackage yet
17:32:19 <tel> ah
17:32:31 <tel> very cool :)
17:32:42 <glguy> What is "semi-indexed"?
17:33:05 <edwardk> It needs more succinct indexed dictionary code than I have now. Ddarius volunteered to help With that
17:33:18 <edwardk> @google semi indexed semi structured
17:33:20 <tel> glguy partial indexing of serialized data
17:33:21 <lambdabot> http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf
17:33:21 <lambdabot> Title: Semi-Indexing Semi-Structured Data in Tiny Space
17:33:32 <edwardk> That describes a version for Jason
17:33:36 <edwardk> Er json
17:33:48 <tel> edwardk ipad is like a foreign accent
17:34:35 <edwardk> Yeah
17:36:23 <thr33strikes> I'm trying to use this command to list things in a directory,  listDirectory :: FilePath -> IO [FilePath]
17:36:25 <edwardk> glguy: Build an index that is ~3-5% of the document size that you can build fast enough to accelerate a query you're doing on the fly rather than parse and query, but which you can also store
17:37:04 <thr33strikes> I have it written in a file with ext .hs
17:37:06 <glguy> You compute the index structure once and store it?
17:37:10 <edwardk> glguy: I have a variant that covers data.binary as well which makes it so you only pay to deserialize the parts you look at via mmap
17:37:13 <edwardk> You can
17:37:20 <thr33strikes> why won't it run?
17:37:22 <edwardk> But even on the fly it is a win
17:37:37 <edwardk> And you can compress the doc chunk wise after indexing
17:38:04 <tel> thr33strikes can you put your code up on a paste site like http://lpaste.net/
17:38:14 <edwardk> Take say a 340k json doc to a 10k index and 42k block store that queries 2-3x faster than the original
17:38:21 <thr33strikes> sure
17:39:17 <ski_> leroux : `return (perms >>= \p -> guard (executable p) >> return p)', i suppose
17:39:52 <lpaste> thr33strikes pasted “Newbie” at http://lpaste.net/92350
17:40:32 <edwardk> glguy: With the binary variant you can make a lazy expression that jumps around the index on the binary in succinct extra space
17:41:04 <FreeFull> thr33strikes: Where are you getting listDirectory from? I can't find it, but there is getDirectoryContents with the same type signature in System.Directory
17:41:08 <glguy> edwardk: do you need a class of non-failing parsers for it to work out?
17:41:15 <edwardk> Now O(1) to get to your nth child for an ADT
17:41:43 <thr33strikes> from system-fileio
17:41:48 <edwardk> no you can semi index a parser too! But it works well for Binary given the unfailing aspect
17:42:21 <tel> thr33strikes you should try using it in an interpreter like ghci, what you've written is only the type, not a program that will run
17:43:02 <edwardk> with parsing it is particularly interesting because the recognizer builds the semi index, which i can flesh out with an AST
17:43:18 <levi> edwardk: You haven't happened to have written a reversible binary protocol parser suitable for context-sensitive packet decoding, have you?
17:43:55 <edwardk> Normally parsing blows up memory usage e.g. 20x, this way it blows up 1.1x, then you pay for what you look at
17:44:10 <edwardk> levi: Not recently
17:44:24 <thr33strikes> my ghci has prelude> is that ok?
17:44:30 <FreeFull> thr33strikes: A full program using that module would be something like       import Filesystem; main = mapM_ print (listDirectory ".")
17:44:56 <FreeFull> In GHCi, you can do   import Filesystem       and then     listDirectory "your directory"
17:45:06 <FreeFull> "." is the current directory
17:45:07 <levi> edwardk: Old stuff that's out there somewhere is fine with me, even if it's bitrotted. But if there's nothing handy, that's fine too.
17:46:00 <edwardk> levi: Nothing handy/usable
17:48:10 <thr33strikes> Freefull I just tried what you said and the module loaded but when I called list.Directory i received a not in scope error
17:48:57 <tel> anyone have any recommended reading for DSEL examples? I'm thinking of Hudak's stuff, the diagrams/monoids paper, financial contracts, &c.
17:49:22 <glguy> edwardk: and is any of this on your github?
17:49:37 <levi> edwardk: Having done it before, do you have a 1-sentence summary of the approach you used?
17:49:37 <edwardk> Not yet
17:50:08 <edwardk> Levi at the time I cared about protocol recognition from fragments while losing surrounding context often
17:53:01 <levi> I don't have that problem at the moment; I'm mostly just wishing for a nice way to write protocol parsers/printers. I have some vague ideas and some inspiration to work from, but meanwhile I just have a mess of Data.Binary instances.
17:54:14 <edwardk> I leave protocols to a former life. I never want to sit there staring at packets again ;)
17:54:59 <danharaj> edwardk: would you know how I can use parametricity to guarantee quantified functions on GADT-defined functors are natural?
17:55:09 <danharaj> I am not good with free theorem
17:55:49 <enthropy> are people aware of a cleaner/better way to propagate type information when pretending that polymorphic functions are first-class?
17:55:49 <edwardk> danharaj: Let me talk about that at a computer later :)
17:55:50 <enthropy> http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-FakePrelude.html
17:55:56 <danharaj> ok cool
17:56:29 <danharaj> I finally have all the pieces of understanding I need and now I need to make parametricity do all the dirty work for me ;)
17:57:51 <danharaj> edwardk: the key to all of it is that FinSet -> * is the free cartesian monoidal closed category generated from 1 object. It inherits a cartesian product from FinSet^Op via Day Convolution but also gets a nonsymmetric monoidal structure from its free object status as it is isomorphic to its own endofunctor category. This second monoidal structure is what variable substitution is all about.
17:59:16 <danharaj> A monoid object in that category is a cartesian operad, and also gives rise to a relative monad on *. I'm sure the relation to left modules and Maybe on * will fall out when I implement all this jazz formally in detail.
18:00:02 <mm_freak> could anyone tell me how i go from Exp Int to Exp DIM2 in accelerate?  i want to duplicate the given coordinate
18:00:09 <mm_freak> 15 -> Z :. 15 :. 15
18:01:18 <lpaste> thr33strikes revised “Newbie”: “Baby Step” at http://lpaste.net/92350
18:01:30 <levi> I know what *almost* all those words meant now, at least at a surface level.
18:01:42 <levi> What they meant together... that's another story.
18:02:05 <qz_> is there any idiomatic way to process sequences with lookahead/skip? say i have list of strings and need to merge strings starting with 'A' with next string
18:03:14 <mm_freak> qz_: one way is foldr on tails
18:03:44 <mm_freak> qz_: otherwise it's probably easiest to just write a recursive function
18:04:00 <qz_> mm_freak: i can do merging this way, but how to skip then?
18:04:18 <mm_freak> qz_: f (x:xs) | not (p x) = f xs
18:04:52 <mm_freak> with the fold:  f x xs | not (p x) = xs
18:05:40 <mm_freak> accelerate is a bit hard to work with =/
18:06:20 <qz_> uh, accelerate is overkill for that
18:06:51 <mm_freak> qz_: no, that wasn't related to your question =)
18:07:00 <qz_> oh
18:07:09 <mm_freak> i'm trying to write a simple accelerate program, but right now can't figure out even simple things
18:15:55 <k00mi> mm_freak: marlow's book has a section on accelerate
18:17:54 <lpaste> thr33strikes pasted “Works in ghci but not as a script file...” at http://lpaste.net/92352
18:18:20 <arkeet> thr33strikes: yeah, tha'ts not a complete program
18:18:24 <arkeet> :p
18:18:36 <arkeet> ghci lets you evaluate expressions
18:18:42 <arkeet> .hs files have to contain declarations
18:19:00 <ski_> thr33strikes : `main = print =<< getCurrentDirectory'
18:19:03 <arkeet> e.g. main = getCurrentDirectory >>= putStrLn
18:19:46 <thr33strikes> ghci makes it so easy
18:20:43 <arkeet> I don't know what you were expecting.
18:21:30 <arkeet> ghci takes expressions (or IO actions), evaluates (or runs) them, and prints the results.
18:21:33 <arkeet> that's particular to ghci.
18:21:50 <arkeet> i.e. it's a REPL
18:21:51 <ski_> thr33strikes : (simplifying somewhat) in a Haskell source file you write declarations, in the interactor (GHCi,Hugs,&c.) you write expressions
18:21:58 <monochrom> did you know: just a year ago, "import System.Directory" was illegal in ghci
18:22:12 <arkeet> monochrom: it was? I'm pretty sure I used ghci a year ago and that worked fine.
18:22:21 <monochrom> then make it 2 years
18:22:25 <arkeet> or 2.
18:22:34 <monochrom> then make it 3 years
18:22:34 <arkeet> but I believe that at some point it didn't work.
18:22:40 <ski_> make it `n' years ago, for `n' a natural number
18:22:46 <thr33strikes> lol
18:22:59 <FreeFull> monochrom: What about :m System.Directory
18:23:10 <ski_> FreeFull: always worked (afaik)
18:23:14 <monochrom> that has always existed
18:23:17 <arkeet> thr33strikes: anyway, the stuff that you type into ghci and the stuff that goes into a .hs file are different.
18:23:18 <heatsink> Bullies were tazing her?!
18:23:23 <ski_> (in GHCi, i.e. -- doesn't work in Hugs)
18:23:24 <heatsink> nm, wrong window
18:23:32 <arkeet> thr33strikes: something like LYAH should explain the difference.
18:24:35 <ski_> thr33strikes : in a source file you mostly put things you tell the computer (definitions), in the interactor you mostly put things you ask the computer (expressions to evaluate, expressions to ask what type they have,&c.)
18:24:59 <ski_> (incidentally, the same pattern is true of common Prolog systems)
18:25:27 <monochrom> I understand your expectation from elsewhere. in both Python and SML, the input to REPL and the input to editor can be identical.
18:25:28 <FreeFull> thr33strikes: Have you ever used any other programming language?
18:25:52 <ski_> monochrom : true
18:25:55 <monochrom> you can ask, so why not ghc too. and I can answer: you didn't pay enough money to make it happen.
18:26:14 <heatsink> Isn't GHCI's prompt supposed to be a do block?
18:26:23 <ski_> heatsink : sortof, yes
18:26:25 <arkeet> sort of.
18:26:35 <FreeFull> sort of, in IO
18:26:35 <arkeet> 5 isn't the kind of statement you'd put in a do block, though
18:26:39 <monochrom> even "import MMM" in ghci was a recent Google SoC project IIRC
18:26:43 <heatsink> oh, right
18:26:51 <arkeet> there's an implicit "print" then
18:27:05 <FreeFull> I assume data and such came along with import
18:27:25 <monochrom> yeah, a bunch of declarations were from that project
18:27:30 <thoughtpolice> i think 'import Foo.Bar' happened in like 7.0, and full GHCi declaration syntax happened in 7.2
18:27:39 <thoughtpolice> because 'import' i know for a fact was supported first
18:27:56 <thoughtpolice> and before that we just had :m+
18:28:00 <geekosaur> import was added in 7.4, data in 7.6, IIRC
18:28:09 <joelteon> I remember when import was added
18:28:10 <geekosaur> and 7.4.1's import was a bit buggy
18:28:11 <monochrom> thoughtpolice follows GHC development closely. trust him more than me
18:28:13 <thoughtpolice> ah, maybe that was it
18:28:13 <joelteon> those were dark days
18:28:59 <FreeFull> Next step, make pragmas work
18:29:05 <thoughtpolice> geekosaur: ah, we're both wrong!
18:29:21 <thoughtpolice> the full top-level declaration syntax was actually 7.4.1, it seems
18:29:24 <enthropy> there's some multi-line input support too
18:29:33 <enthropy> but probably nobody uses it
18:29:37 <ski_> yea, `:{ ... :}'
18:29:45 <arkeet> or :set +m
18:30:02 <arkeet> and -m
18:30:12 <thoughtpolice> hvr uses it :)
18:30:12 <FreeFull> :{ :}  is only useful for .ghci files
18:30:26 <arkeet> er...
18:30:29 <thoughtpolice> i speculate it may tie into some emacs mode functionality, though
18:30:36 <thoughtpolice> he's submitted a few patches for multiline recently
18:30:41 <FreeFull> Since the code still ends up parsed as it if was on one line
18:30:47 <arkeet> yeah.
18:30:52 * enthropy thought the line-editing was better
18:31:09 <enthropy> FreeFull: a long time ago it used to be
18:31:23 <FreeFull> When did it change?
18:31:51 <FreeFull> Because for me it still is as if it was on one line
18:31:54 <thr33strikes> Freefull: I was learning Python but stopped because I thought Haskell was more interesting
18:32:03 <tel> there needs to be a nice way to define a type and an implementation separately
18:32:04 <thoughtpolice> it changed when full top level syntax was added to GHCi. you can do ":{\ndata Foo\ndata Bar:}" for example which would otherwise be a parse error
18:32:05 <ski_> hm, i recall in the OCaml GUI toplevel, you'd send input by `C-RET', and you could edit previous rows of unsent input
18:32:13 <enthropy> FreeFull: I have a patch dated "Thu Apr 29 13:02:46 EDT 2010"
18:32:18 <FreeFull> thr33strikes: Well, Haskell is more interesting
18:32:21 <ski_> tel : how do you mean ?
18:32:22 <enthropy> http://ghc.haskell.org/trac/ghc/ticket/3984
18:32:41 <FreeFull> enthropy: Which still isn't in current ghc stable
18:32:49 <tel> ski_ I want to be able to let-define fns with constrained types
18:33:21 <arkeet> let f :: ...; f ... = ...
18:33:21 <ski_> tel : like `let idBool :: Bool -> Bool; idBool b = b' ?
18:33:33 <mm_freak> k00mi: i've read that one
18:33:38 <FreeFull> enthropy: Nevermind, it didn't work because I didn't use a do
18:33:41 <tel> ooh.
18:34:00 <mm_freak> k00mi: it doesn't explain how to solve my current problem though
18:34:01 <tel> I wasn't aware that worked—
18:34:19 <ski_> tel : also with `{'s and `}'s, if you really want to
18:34:22 <thr33strikes> I was told that for some learning a functional language from the beggining would be easier because I wouldn't have bad habits
18:34:27 <enthropy> the line-editing didn't get done because haskeline didn't/doesn't? support that very well
18:34:44 <tel> ski_ I'd been trying with multiline mode, but didn't know how to do the lets
18:34:46 <ski_> tel : and of course you can separate multiple defining equations for `idBool' with `;'
18:34:51 <monochrom> not so much bad habits as prejudice
18:34:59 <thr33strikes> ic
18:35:04 <FreeFull> thr33strikes: .hs files behave differently from the GHCi prompt
18:35:13 <FreeFull> As others have already said
18:35:31 <thr33strikes> I read that earlier today but didn't remember exactly what the book was trying to get at
18:35:37 <tel> nifty
18:35:55 <tel> is it possible to do that with :{ :}
18:36:20 <thr33strikes> with python I learned a lot more when I just jumped in and tryied to build something
18:36:36 <ski_> @let idBool :: Bool -> Bool; idBool b = b; idBool _ = error "unhandled case in `idBool'"
18:36:37 <lambdabot>  .L.hs:153:1: Warning:
18:36:37 <lambdabot>      Pattern match(es) are overlapped
18:36:37 <lambdabot>      In an equat...
18:36:53 <thr33strikes> I know now I need to go back and look at some of the syntax a little more when using the .hs files
18:36:55 <ski_> heh
18:37:03 <arkeet> thr33strikes: you should get used to using .hs files :)
18:37:12 <thr33strikes> yea lol
18:37:23 <arkeet> it's good to put a bunch of declarations into a .hs file, and then load that into ghci
18:37:26 <arkeet> to poke around
18:37:27 <tel> thr33strikes I usually write my ideas in a .hs file and load them in ghci with :r
18:37:32 <tel> yeah, what arkeet said
18:37:33 <tel> : )
18:37:36 <FreeFull> ski_: I wonder if there is any case where the pattern matches overlap, but not completely
18:37:44 <arkeet> much easier than trying to write a big function definition within ghci.
18:38:02 <thr33strikes> writing for me is slow now because I'm trying to learn VIM as well
18:38:10 <ski_> thr33strikes : typically one edits the source file a bit, then tries to load it into the interactor, going back to fix type errors if any, then try out some example uses of the definitions in the source from the interactor, then back again
18:38:17 <FreeFull> ski_: That is, there are values that only match one of the two, for both, but there are some that match both
18:38:28 <monochrom> I am totally not thrilled about being able to write a whole program in a REPL. I mean, you are welcome to do it, but I couldn't care less. what happens if I'm 90% done and someone pulls the plug?
18:39:16 <thr33strikes> that's what I was originally doing but I got stuck with trying to use the System.Directory library
18:39:23 <ski_> thr33strikes : while something like vim or emacs may be quite helpful in the long run, it may perhaps be a bit much to both learn it and Haskell. if you have a favorite text editor, you could use it for the while, while learning the basics of Haskell
18:39:29 <monochrom> therefore, I always type into a file and save anyway. then try a few tests in REPL. advanced REPL features are irrelevant.
18:39:30 <tel> monochrom I mostly do it when I've loaded some intermediate data that I'm playing along with
18:39:31 <FreeFull> monochrom: There isn't a convienient way to save the code you write into ghci anyway
18:39:39 <tel> because repl reloads kill local state
18:39:50 <monochrom> speaking of which, Python's REPL of reloading/refreshing sucks
18:39:54 <ski_> FreeFull : `(True,_)' vs. `(_,True)' ?
18:39:59 <arkeet> monochrom: heh.
18:40:00 <FreeFull> monochrom: But it is nice to have advanced features when you are just messing around because you don't know what exactly to do yet
18:40:06 <tel> monochrom yesss..
18:40:11 <tel> ugh
18:40:14 <FreeFull> ski_: That would work
18:40:22 <thr33strikes> I'm getting the hang of vim but I think of it as the first time I started actually typing
18:40:35 <thr33strikes> it was brutal for me then but after a while it became second nature
18:40:39 <FreeFull> > case (True, True) of (True,_) -> 'a'; (_,True) -> 'b'
18:40:40 <lambdabot>   'a'
18:40:49 <FreeFull> ski_: Seems it doesn't warn on that
18:40:55 <ski_> @let por True _ = True; por _ True = True; por False False = False
18:40:56 <lambdabot>  Defined.
18:40:56 <thr33strikes> everyday I learn a little more
18:41:12 <ski_> FreeFull : well, it ought to
18:41:19 <monochrom> FreeFull: I mess around with the help of a file. it's even better, the file is a log of all things I try
18:41:22 <thr33strikes> I equate it to video games lol and anything to do with muscle memory
18:41:35 <thr33strikes> repetition is best for me
18:42:25 <FreeFull> monochrom: Usually I am actually writing something so I have a file loaded into ghci anyway
18:42:27 <ski_> FreeFull : one thing that i appreciate about the MLs is that overlapped patterns is an error and inexhaustive patterns is a noisy warning
18:42:34 <tel> thr33strikes I definitely find that to be the case with vim and emacs. They're quite complex, but when you learn them well their way of thinking gets "in your fingers"
18:42:36 <FreeFull> And test in the REPL as I write
18:43:14 <monochrom> yes that's what I do too
18:43:19 <ski_> thr33strikes : of course it's your call whether to try both at the same time or not. just mentioning the option
18:43:23 <FreeFull> > case (True, True) of (True,_) -> 'a'; (True,True) -> 'b'
18:43:24 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
18:43:28 <thr33strikes> I haven't tried emacs yet
18:43:53 <thr33strikes> I don't mind the advice
18:43:57 <thr33strikes> that's why I'm here
18:44:09 <monochrom> the point is: you totally don't need "REPL can accept complete program raw" for real work
18:44:12 <thr33strikes> just think of me as putty to be molded lol
18:44:34 <arkeet> vim is good :)
18:44:54 <monochrom> it's a much overrated gimmick for beginners who use such gimmick for maybe 2 weeks
18:45:02 <FreeFull> monochrom: There is a context switch between the REPL and the editor, people don't like that
18:45:14 <FreeFull> I guess that's why some people work with the REPL built into their editor
18:45:27 <ski_> thr33strikes : i find emacs relatively nice, but i hear vim is good as well
18:45:46 <thr33strikes> have any of you used a different keyboard layout I have a friend who like dvorky, or something like that
18:46:05 <FreeFull> monochrom: Sometimes you want to do a one-off thing to test something and don't want to make a file only to delete it afterwards
18:46:24 <ski_> thr33strikes : .. oh. i first read your "putty" as "PuTTY"
18:46:28 <ski_> @wn putty
18:46:29 <lambdabot> *** "putty" wn "WordNet (r) 3.0 (2006)"
18:46:29 <lambdabot> putty
18:46:29 <lambdabot>     n 1: a dough-like mixture of whiting and boiled linseed oil;
18:46:29 <lambdabot>          used especially to patch woodwork or secure panes of glass
18:46:30 <lambdabot>     v 1: apply putty in order to fix or fill; "putty the window
18:46:31 <lambdabot>          sash"
18:47:00 <thr33strikes> better word would have been clay
18:47:11 <FreeFull> arkeet: What do you think about emacs + evil?
18:47:38 <ski_> FreeFull : with GNU Screen, the context switch is only a `^A^A' away (or `^A^I' if you display both interactor and editor at the same time)
18:47:42 <thr33strikes> arkeet: evil?
18:48:10 <ski_> @google emacs evil
18:48:11 <lambdabot> http://www.emacswiki.org/emacs/Evil
18:48:11 <lambdabot> Title: EmacsWiki: Evil
18:48:35 <FreeFull> ski_: Don't forget having to reload the repl too, and potentially losing your repl-local definitions
18:48:52 <ski_> thr33strikes : it's an Emacs "mode" for emulating some of the basic keybindings of vi, iiuc
18:49:04 <ski_> FreeFull : true
18:50:33 <FreeFull> ski_: I think it does a lot more than basic keybindings
18:50:55 <ski_> thr33strikes : re different keyboard layout, i happen to have moved my `0' key to the left of the `1' key ..
18:51:08 <ski_> FreeFull : probably. i don't know details
18:52:31 <thr33strikes> can anyone recommend a great beginners haskell books?  The ones I've been finding go more into the explanation of functional programming vs the hands on coding.
18:53:16 <arkeet> thr33strikes: LYAH
18:53:18 <arkeet> @where lyah
18:53:18 <lambdabot> http://www.learnyouahaskell.com/
18:53:20 <ski_> (and also i have moved my left `Ctrl' key to the left of the `a' key, as i believe is common amongst Emacs users)
18:53:37 <arkeet> ski_: I did that and I'm not an emacs user.
18:53:44 <ski_> thr33strikes : ooc, which ones have you been finding ?
18:54:06 <FreeFull> ski_: Apparently doesn't do ex mode though
18:54:34 <ski_> arkeet : well, i didn't say "only" :) -- may i inquire as to your reasons ?
18:54:42 <ski_> FreeFull : which ?
18:54:53 <thr33strikes> I was actually reading that today
18:55:09 <arkeet> ski_: well, a couple.
18:55:14 * ski_ has chatted some with someone who uses `ex' to code
18:55:20 <thr33strikes> it was the best of the bunch
18:55:27 <arkeet> it's generally easier to reach, the real left ctrl key on my laptop is tiny, and I hate accidentally pressing caps lock.
18:55:54 <haasn> I'm randomly getting mandelbrot: thread blocked indefinitely in an MVar operation when working with repa-devil
18:56:18 <haasn> I have absolutely *no* idea what causes it. It seems to either happen, or not, depending on arbitrary changes I make to the code
18:57:11 <thr33strikes> ski: not sure what you're asking
18:57:13 <monochrom> "the devil is in the MVars" :)
18:57:20 <slack1256> heh
18:57:35 <haasn> http://bpaste.net/show/127922/
18:57:39 <haasn> maybe somebody can figure out what's wrong?
18:57:49 <arkeet> step 1: use lpaste
18:57:50 <arkeet> ;)
18:57:53 <haasn> I used the exact same ‘render’ function, with one minor change (V2 instead of a tuple) in another program
18:57:55 <haasn> and it worked fine
18:58:01 <arkeet> what's the problem?
18:58:06 <ski_> thr33strikes : which Haskell beginner books you had been finding (that go more into the explanations of functional programming than hand-on-coding)
18:58:08 <arkeet> step 0: include the error message
18:58:14 <haasn> arkeet: “<<loop>> thread blocked indefinitely in an MVar operation”
18:58:19 <haasn> I just said that
18:58:20 <FreeFull> ski_: evil
18:58:28 <arkeet> oh.
18:58:37 <arkeet> oh, I don't know anything about repa-devil.
18:58:51 <arkeet> sounds like a bug.
18:58:52 <haasn> I'll try another repa representation
18:58:59 <haasn> I can't think of any other explanation for it
18:59:07 <haasn> if I remove the (x `seq`) bit it works
18:59:21 <Ralith> haasn: because your weirdass /. operator is a loop, probably
18:59:23 <thr33strikes> Ski_: Programming in Haskell by Graham Hutton
19:00:08 <thr33strikes> Ski_: it just be me though because I'm new
19:00:13 <monochrom> oh! is it because /. wants non-strict but you make trivial too strict?
19:00:39 <ski_> thr33strikes : if you're new to functional programming, such explanations may also be helpful. that being said, you could come back later to that when you know the basics of the language
19:00:56 <thr33strikes> Ski_:yes I was thinking the same thing
19:01:16 <haasn> monochrom: maybe? heh; I tried adding ! to both arguments of /. and now I just get a good old endless loop
19:01:21 <haasn> no <<loop>> even
19:01:54 <thr33strikes> Ski_: I jumped into Perarls of functional Algoriths by Richard Bird and that was definitely over my head
19:02:16 <ski_> thr33strikes : different people learn best in different ways, and different people may have different goals. if you fell LYAH is more helpful atm, go for it. just keep in mind that there may be deeper lessons that may be harder to grasp, but that may still be worthwhile to grok
19:02:23 <haasn> hmm; I changed the type to :: Int -> Int -> Double -- and got the same error as before, <<loop>>
19:02:25 <ski_> thr33strikes : *nod*
19:02:35 <haasn> this is really weirding me out right now. nothing makes sense
19:02:42 <haasn> the sky is falling etc.
19:02:59 <Ralith> haasn: your /. is defined as a loop. How many times do I need to repeat myself?
19:03:06 <haasn> oh!
19:03:12 <Ralith> :P
19:03:20 <haasn> I typo'd / as /.
19:03:23 <ski_> FreeFull : ok
19:03:26 <arkeet> haha
19:03:26 <Ralith> thought that might be it
19:03:37 <monochrom> oh damn. I missed that too
19:04:14 <monochrom> so, keep the seq, fix /.
19:04:41 <thr33strikes> Ski_: The more I go over the harder subjects eventually I usually have an ahhhaaa moment and it just clicks
19:04:48 <monochrom> also, answer: as many times as /. loops? :)
19:04:54 <tel> Is there a package with a lazy sorted data type?
19:04:55 * ski_ nods
19:05:21 <Ralith> tel: how would that be distinct from sorting a list?
19:05:28 <thr33strikes> I'll just be laying in bed or doing something and its like a light comes on
19:05:40 <thr33strikes> may take days but it's great when it happens
19:05:44 * ski_ knows the feeling
19:05:46 <arkeet> thr33strikes: may take weeks
19:05:47 <tel> I want to get out the smallest thing before the whole list is sorted
19:05:54 <arkeet> tel: then
19:05:58 <arkeet> just do that
19:05:59 <arkeet> sort is lazy
19:06:03 <arkeet> iirc
19:06:09 <tel> oh
19:06:48 <tel> I figured it would be some kind of quicksort thing—where I just need bubble
19:07:01 <arkeet> hm, maybe not
19:07:07 <monochrom> eventually I will have to show you how, e.g., "maximum (sort xs)" is linear time because of some laziness
19:07:13 <thr33strikes> this is a hobby for me so my "goal" in a sense is to reach those ahhaa moments
19:07:23 <monochrom> err, sorry, "take 1 (sort xs)"
19:07:37 <arkeet> for which implementation of sort?
19:07:39 <FreeFull> tel: fold with min
19:07:46 <monochrom> for the one that comes with GHC
19:08:09 <monochrom> or generally most merge sorts
19:08:32 <FreeFull> tel: Will be O(n) rather than O(n log n)
19:08:34 <tel> I didn't expect that to hold! interesting
19:08:46 <thr33strikes> did any of you have to read LYAH more than once?
19:08:55 <ski_> i remember reading chapter after chapter of "Haskell: The Craft of Functional Programming", thinking "hm, how i can do anything without loops and assignment. .. hm, ok, i can do simple things, but more complex stuff ? .. ok, but surely I/O ? .." -- and also other lights lit up in the process
19:09:08 <arkeet> monochrom: it doesn't seem to be lazy enough here.
19:09:11 <FreeFull> thr33strikes: I mixed things up for myself
19:09:22 <arkeet> head (sort [1..10000000]) is as expensive as length
19:09:32 <arkeet> 7.4.2 though
19:09:34 <thr33strikes> Freefull: how so?
19:09:45 <monochrom> that is linear, and I did promise linear
19:09:52 <arkeet> length of sort, I mean.
19:10:09 <arkeet> one sec
19:10:09 <FreeFull> thr33strikes: There are other materials than LYAH out there. I personally tend to read documentation and articles about things
19:10:11 <monochrom> oh, then I will have to investigate later
19:10:23 <FreeFull> And eventually you'll be advanced enough that LYAH won't be useful anymore
19:10:38 <FreeFull> It is great to get you started though
19:10:55 <tel> hm, there's a wealth of information in the source it turns out
19:12:12 <thr33strikes> Ski: that's pretty much how I feel, my big question is how is the code structured, it seems like it's easy to create spaghetti code.  I know you'll all educate me in that regard as to why its not though.
19:12:15 <leroux> thr33strikes: https://gist.github.com/leroux/6395804
19:12:20 <FreeFull> monochrom: I wonder if  take 1 . sort    would be linear with my homegrown mergesort
19:12:43 <monochrom> it most likely will be. this one is very hard to screw up :)
19:13:23 <arkeet> yeah, same result in 7.6.3
19:13:32 <arkeet> ghc screwed it up; so can you!
19:13:57 <thr33strikes> Leroux thanks
19:14:22 <leroux> I should probably add a few of those to the haskell-wiki.
19:14:25 <tel> hah
19:14:30 <monochrom> at some point, they switched the sorting algorithm. it was merge sort years ago. the current algorithm is faster in practice, but looks less like merge sort, I still don't exactly know what it is
19:14:48 <tel> monochrom yeah.. I'm trying to figure it out
19:14:57 <tel> probably ought to take a look at the paper referenced
19:14:57 <monochrom> try going back to 6.12 :)
19:15:16 <arkeet> I don't have that :)
19:16:55 <ski_> thr33strikes : it's possible to write unreadable code, yes. one tries to fight that partially by abstracting out common patterns (refactoring is simplified by the absence of side-effects)
19:17:34 <ski_> thr33strikes : though it's possibly to go overboard with abstraction that isn't warranted by either existing code or code that one would otherwise have to write
19:18:22 <ski_> thr33strikes : still, there are certain patterns of structuring code that are common
19:20:16 <ski_> monochrom : is it still a merge sort, or something else ?
19:20:26 <thr33strikes> ski_: I haven't written or seen enough code to recognize them though
19:20:27 <ski_> (if merge sort, bottom-up or top-down ?=
19:20:29 <ski_> )
19:21:26 <ski_> thr33strikes : a quite common one is to write a "wrapper" function that is responsible for any "initialization" ior "finalization" of a "worker" function that does the main work
19:21:52 <haasn> wait, why does instance Num (Complex a) require RealFloat a!?
19:22:04 <monochrom> with merge sort, you can reason like this approximately: take 1 (mergesort xs) ends up looking like a single-elimination tournament.
19:22:05 <haasn> As far as I can tell there are no operations being used in the instance that would require such a heavy constraint
19:22:08 <haasn> it excludes, for example, Fixed
19:22:15 <haasn> ah, http://hackage.haskell.org/package/complex-generic
19:22:51 <thr33strikes> ski_: I've understood that to be a OOP type pattern, it holds true for functional programming as well?
19:23:02 <ski_> and writing such a worker in accumulator-passing-style isn't that uncommon (though it's more common in the strict FPLs. due to non-strictness, Haskell can often get away (efficiently) with non-tail-recursive formulations where a strict language would want tail-recursion, usually by accumulator)
19:23:05 <thr33strikes> ski_: Can you explain why?
19:23:15 <ski_> thr33strikes : why what ?
19:23:28 <FreeFull> How do I make sure my sort' gets evaluated without using its output?
19:23:44 <ski_> FreeFull : `seq' ?
19:24:04 <ski_> FreeFull : or, if in `IO' monad, try `evaluate'
19:24:28 <ski_> @type Control.Exception.evaluate
19:24:28 <lambdabot> a -> IO a
19:24:44 <FreeFull> ski_: seq stops on the first outermost constructor it finds so it wouldn't do
19:24:46 <monochrom> must you avoid using its output? because, frankly, seq and evaluate count as using its output, too
19:24:53 <thr33strikes> I've understood that to be a OOP type pattern, it holds true   . `^_^v
19:24:54 <thr33strikes>                          | for functional programming as well?
19:25:13 <FreeFull> monochrom: Well, I basically don't want the data to leave the program because that's slow
19:25:16 <monochrom> and "evaluate (length (sort' xs))" counts as using even more
19:25:40 <ski_> FreeFull : then either try something like `rnf', or write a custom forcer ?
19:25:56 <monochrom> "evaluate (rnf (sort' xs))" is also good
19:26:15 <monochrom> let me just say I don't understand your definition of "use"
19:26:22 <FreeFull> I want to compare the speed difference between     sort' xs    and    take 1 . sort xs'
19:26:25 <monochrom> mathematical definition
19:26:44 <arkeet> FreeFull: for benchmarking, you may be interested in criterion :)
19:26:47 <FreeFull> monochrom: By use I meant write to a file or to the screen
19:26:48 <thr33strikes> ski: so you're saying there are patterns in functional programming just like there are in other pardigms.
19:26:57 <monochrom> then "evaluate (rnf (sort' xs))" and "evaluate (rnf (take 1 (sort' xs]"
19:26:58 <ski_> thr33strikes : hm, i wasn't aware that worker-wrapper was that common in OOP (any language ?), but ok
19:27:11 <ski_> thr33strikes : to some extent, yes
19:27:13 <monochrom> where ] is the lisp ] hehe
19:28:15 <ski_> thr33strikes : however, to some extent, patterns in OOP will in some cases not be needed in (typical) FP. iow those OOP patterns exist because of inabilities to abstract or express more directly what is desired
19:28:36 <thr33strikes> ic
19:28:40 <ski_> monochrom ;)
19:28:52 <monochrom> or you can say, those patterns are used in FP more often but with trivial syntax, even no syntax
19:29:24 <thr33strikes> ski_: what was the hardest concept for you to grasp when you initially started learning FP?
19:29:39 <monochrom> "mapM_ c xs" can be described as either "uses the Command pattern" or "eliminates the Command pattern"
19:29:55 <ski_> hm, hard to say (was more than 10 years ago)
19:30:30 <ski_> thr33strikes : the pervasive use of recursion is certainly a common stumbling-block, though
19:31:38 <shachaf> monochrom: How do I use the Comonad pattern?
19:31:56 <monochrom> I don't know yet
19:31:56 <thr33strikes> when you say pervasive do programmers unwittingly use recursion too much or not enough?
19:32:33 <FreeFull> Ok, I tried it out, and with take 1 it is measurably faster than without
19:32:39 <FreeFull> Noticeably even
19:32:41 <monochrom> \∩/
19:32:43 <arkeet> I think he just means figuring out how to write things using recursion.
19:32:59 <arkeet> instead of e.g. loops like you would in some other languages.
19:33:01 <ski_> thr33strikes : programmers who (solely) use imperative programming languages tend to under-use recursion (of course there are exceptions, people who understand the benefits and costs of it)
19:34:02 <FreeFull> shachaf: extract and extend your code
19:34:19 <arkeet> I guess beginner FPers might have a tendency to do explicit recursion instead of e.g. using a fold
19:34:59 <ski_> which i think is helpful for later understanding the point of recursion combinators like folds
19:35:09 <arkeet> sure.
19:35:47 <ski_> (just like using some `goto's or `jmp's/`bne's could be useful to better appreciate structured programming constructs=
19:35:54 <ski_> )
19:36:38 <FreeFull> I don't understand anymore how people can make new programming languages where you don't have simple lambdas
19:36:45 <FreeFull> By simple I mean easy
19:37:34 <thr33strikes> is it mandatory that I learn lambda calculus to fully grasp FP?
19:37:46 <FreeFull> thr33strikes: Nope
19:37:57 <arkeet> there's not much to learn about lambda calculus.
19:38:12 * ski_ . o O ( "Sacrificing the calf of flexibility on the altar of reliability" by Peter J. Denning in 1976 at <http://dl.acm.org/citation.cfm?id=807704> )
19:38:46 <FreeFull> thr33strikes: If you really want you could learn about System F, but I wouldn't do that until you're an advanced haskeller
19:38:59 * arkeet hasn't learned about System F
19:39:12 <arkeet> I should probably pick up a copy of TaPL at some point.
19:40:06 <thr33strikes> it's almost 5am here
19:40:15 <thr33strikes> goodnight all and thanks for the info
19:40:18 <FreeFull> Almost 4am here
19:40:25 <FreeFull> We really should go to bed earlier =P
19:40:27 <thr33strikes> I'll be back tomorrow after some readying and coding
19:40:48 <FreeFull> I should have been asleep hours ago
19:40:54 <FreeFull> This isn't good for my health
19:41:56 <edwardk> FreeFull: bah. i'm still walking around. you'll be fine ;)
19:41:58 <haasn> Ralith/monochrom: Runs fine now http://hub.darcs.net/nand/mandelbrot/browse/mandelbrot.hs  and the output is beautiful http://hub.darcs.net/nand/mandelbrot/raw/mandelbrot.png :)
19:42:03 <haasn> runs in about 0.130ms on my machine
19:42:04 <FreeFull> ski_: Sometimes when you're writing C, goto is the best thing to use
19:42:14 <haasn> edwardk: I have a lensy version of the mandelbrot function but it's like 5x slower ;)
19:42:24 <FreeFull> edwardk: Humans are meant to be diurnal =P
19:42:40 <edwardk> haasn: sad
19:42:50 <FreeFull> haasn: Make it faster
19:42:56 <ski_> FreeFull: yes, partly because of not getting guarantees about tail-calls (though GCC gives you some with `-fsibling-calls', at least=
19:42:58 <edwardk> haasn: link?
19:43:00 <ski_> )
19:43:00 <edwardk> oh
19:43:12 <ski_> here's a quote from the above paper :
19:43:15 <haasn> edwardk: iterate (\z -> z^2+c) ^? taking 100 folded.filtered diverges.asIndex
19:43:23 <FreeFull> ski_: I meant for handling failure
19:43:26 <haasn> returns the number of steps until it diverges, if any
19:43:27 <ski_>   The term “flexibility” is usually used to denote the existence of a range of choices available to a programmer or implementor -- the more choice, the better the flexibility. Flexibility is sometimes referred to as “generality”. Because it is frequently presented in the desirable terms, “delaying the binding of virtual objects to their realisations”,
19:43:29 <haasn> capped at 100 arbitrarily
19:43:44 <ski_>   increased flexibility has generally been considered a fatted calf of great succulence, sought voraciously and in the hope that the increased complexity that invariably attends it can be kept under control. In recent years, the wisdom of this quest has been called into question, for flexibility without discipline appears contrary to the plans of the god of reliability.
19:43:50 <haasn>   where diverges (r:+i) = r^2 + r^2 > 4 -- or diverges = (>2) . magnitude
19:43:50 <ski_>   (An automobile with independent steering mechanisms for both front wheels is more flexible but less disciplined than an ordinary one. It is mainly of metaphysical interest, offensive to the god of safe highways.)
19:43:58 <edwardk> haasn: i wonder if i could get that to run on fpcomplete
19:44:08 <haasn> the repa stuff?
19:44:13 <edwardk> haasn: yeah
19:44:48 <FreeFull> ski_: Believe it or not, there is some C code that is actually better with goto than with any looping/conditional construct or recursion
19:45:11 <tibbe> edwardk: is mapM = traversable going to become a reality in 7.8?
19:45:13 <ski_> FreeFull : i believe it
19:45:20 <arkeet> traverse*
19:45:23 <FreeFull> The Linux kernel makes good use of goto
19:45:37 <ski_> FreeFull : C being a "portable assembler" is a long way from the truth
19:45:40 <arkeet> I like having the _option_ to use goto.
19:45:46 <haasn> arkeet: Data.Traversable.mapM I'd guess; then again, we have Applicative => Monad now right?
19:45:49 <edwardk> tibbe: i think the plan was for 7.8 to just include warnings if you don't have Applicative instances for your Monads, then 7.10 to make the jump with a bunch of other stuff
19:45:58 <FreeFull> ski_: Nothing to do with assembler
19:45:59 <edwardk> or did we already get the refactoring patch in for 7.8?
19:46:00 <haasn> oh, right, 7.10
19:46:04 <tibbe> edwardk: ah
19:46:06 <FreeFull> Just the goto being the cleanest thing
19:46:10 <tibbe> edwardk: not sure, I thought we did
19:46:22 <edwardk> tibbe: i haven't run HEAD since it would have gone in if it is
19:46:32 <ski_> FreeFull : it has to do with it, due to the lack of flexible (and preferably compsable) ways of expressing what you want
19:46:34 <tibbe> edwardk: but the warning is probably good, but then we should fix mapM for 7.10 (if I'm right to believe that it doesn't break any code)
19:46:34 <edwardk> tibbe: i should get more on top of this
19:46:49 <tibbe> edwardk: me too, too little time as usual
19:47:11 <FreeFull> ski_: Well, sure, in Haskell you could just have some higher level thing that handles failure
19:47:26 <edwardk> tibbe: it'll be fine. 7.10 is going to do a lot of generalization. replacing the old mapM in Prelude, etc.
19:47:29 <ski_> FreeFull : the control flow of logic programming languages can't easily be encoded in plain C, e.g.
19:47:48 <edwardk> tibbe: minimizing the constraints is pretty much the least worrying thing on the radar
19:47:56 <tibbe> edwardk: that would be neat I think (given that we're doing Applicative => Monad)
19:47:59 <edwardk> the main concern is ensuring we don't lose foldr/build fusion
19:48:18 <elliott> is foldr itself getting generalised?
19:48:18 <tibbe> edwardk: I realized a while back that a strict mapM (or traverse) needs Monad though. I was a bit surprised at first.
19:48:20 <elliott> that iwll be so weird.
19:48:20 <edwardk> once we have that niggling concern out of the way, the rest of it is pretty much 'do the obvious stuff'
19:48:23 <elliott> *will
19:48:43 <tibbe> edwardk: who will make sure that fusion etc still works with generalized foldr?
19:48:47 <edwardk> tibbe: yeah i have a <$!> combinator for strict fmap that needs monad.
19:49:00 <tibbe> edwardk: me too (in cassava)
19:49:30 <tibbe> edwardk: I went on a crush-all-the-thunks bash one day to get the memory usage down to the absolute minimum needed to hold the result
19:49:34 <ski_> edwardk,tibbe : hm, how does strictness here entail monads ? (related to the strictness monad in any way ?)
19:49:39 <edwardk> tibbe: well, we're going to try to plug the committee in a bit better into the mainline ghc dev process with 7.9, especially now that simon and igloo have moved on
19:49:46 <tibbe> edwardk: you can get quite a few thunks with the standard fmap, traverse, etc combinators
19:50:00 <tibbe> ski_: you need to look at the value to force it
19:50:23 <tibbe> ski_: monad has (a -> m b) so you can force it before the next action
19:50:41 <tibbe> edwardk: sounds good
19:50:43 <edwardk> so once 7.9 ramps up we'll try to get a version of things running with full AMP + Foldable/Traversable/Monoid generalization as early as possible, and see if any of the concerns about foldr/build are founded
19:51:00 <ski_> tibbe : and when is it useful ?
19:51:01 * tibbe needs to make a hashable, unordered-containers, containers, cabal, and cassava release the next few weeks
19:51:11 <tibbe> ski_: if you don't want thunks
19:51:15 <tel> foldable/traversable/monoid generalization is also slated for 7.10?
19:51:18 <edwardk> At least half the committee will be in Boston for ICFP. Dan and I live here, byorgey is nearby, etc.
19:51:23 <edwardk> tel: yeah
19:51:35 <tel> nice!
19:51:46 <tibbe> edwardk: I will be at haskell symposium and the haskell symposium
19:52:00 <ski_> tibbe : are you talking about `mapM'/`mapA' in some cases being strict like this, or a separate combinator (perhaps named `mapM') ?
19:52:08 <tibbe> edwardk: I took 2.5 months off work and I can't take another full week for icfp
19:52:26 <tibbe> ski_: I made a separate strict mapM and fmap for that purpose
19:52:32 <ski_> ok
19:52:34 <edwardk> tibbe: btw- i've been working on trying to get a usable "cache oblivious lookahead array" -- which will give us an 'unboxed array-like Data.Map with amortized B-Tree asymptotics' haven't gotten the insert performance down to Map times yet though
19:52:47 <tibbe> ski_: this was in the context that we can now have mapM = traverse with only an Applicative constraint
19:53:01 <tibbe> edwardk: interesting
19:53:12 <ski_> tibbe : ok. i'm not seeing how that relates to the strictness, though
19:53:13 <tibbe> edwardk: what do you think about <$!>, traverse', etc in base btw?
19:53:14 <edwardk> tibbe: its not a Data.Map plug-in replacement though, it'd be very much its own beast, but it does have the benefit of being completely cache oblivious
19:53:26 <tibbe> ski_: try to write a strict mapM with only an Applicative constraint
19:53:41 <tibbe> edwardk: we should write a type class for maps
19:53:43 <edwardk> I'd be in favor of <$!> easily.   traverse' is an interesting prospect. i'd want to sit down and do some laws
19:53:57 <tibbe> edwardk: so both Data.Map, Data.HashMap can be an instance. We can do it with constraint kinds I think.
19:54:09 <tibbe> edwardk: that'd be great
19:54:10 <ski_> tibbe : so the strict version of `mapM' needs `Monad' -- anything else ?
19:54:16 <tibbe> edwardk: instead of everyone rolling their own
19:54:22 <tibbe> ski_: just Monad
19:54:22 <edwardk> the hell of such a typeclass is that you have to choose what to put in it, and the type extensions are sad =(
19:54:22 <elliott> I don't think you need ConstraintKinds, just MPTCs
19:54:31 <elliott> well, maybe ConstraintKinds is less fiddly.
19:54:34 <tibbe> ski_: I was initially surprise about this insight (that you need Monad)
19:54:41 <elliott> huge typeclasses are horrifying though
19:54:47 <ski_> tibbe : i mean, anything else being the lesson/point of this, than that realization ?
19:54:54 <tibbe> elliott: you need the type class constrain in there somewhere
19:55:23 <edwardk> tibbe: the strictness-needs-a-monad thing has been the only reason i've been considering something like a monadic traversal for lens
19:55:27 <tibbe> a benefit of such a type class would be that you can create new containers without writing 100 functions (many can be given for free with default impls)
19:55:31 <arkeet> I don't know how you'd do it with MPTCs.
19:55:33 <FreeFull> edwardk: Mathematical laws are so much nicer than legal laws
19:55:35 <edwardk> because that seems to be the only 'correct' monadic travrsal
19:55:35 <tibbe> edwardk: ah
19:55:49 <tibbe> edwardk: right
19:55:59 <elliott> tibbe: it can go in the instance if you use an mptc
19:56:08 <elliott> but I guess key-polymorphic stuff gets a little uglier
19:56:24 <tibbe> elliott: I haven't seen a design with MPTC that I liked
19:56:29 <ski_> @remember FreeFull Mathematical laws are so much nicer than legal laws
19:56:29 <lambdabot> I will remember.
19:56:38 <edwardk> elliott: the main thing i don't want to lose is the ability to have polymorphic recursion through a map.
19:56:43 <FreeFull> @quote FreeFull
19:56:43 <lambdabot> FreeFull says: Mathematical laws are so much nicer than legal laws
19:56:46 <FreeFull> @quote FreeFull
19:56:46 <lambdabot> FreeFull says: Mathematical laws are so much nicer than legal laws
19:56:51 <ski_> @quote
19:56:52 <lambdabot> EvanLaforge says: Then we can tell them about how we had to walk in the snow both ways uphill fighting space leaks with bare hands while they just have to read about it.
19:56:54 <edwardk> i use that all over the place
19:56:57 <FreeFull> I swear there was a different quote with me
19:56:57 <arkeet> I wouldn't mind if traverse' laws only gave definedness relations instead of actual equality
19:57:24 <edwardk> tibbe: i suppose if we do traverse' then fmap' is also in order
19:57:26 <arkeet> <= is almost as good as =
19:57:35 <FreeFull> Seems not
19:58:01 <FreeFull> arkeet: < is almost as good as <=
19:58:02 <edwardk> arkeet: ah for reasoning in the presence of bottoms?
19:58:11 <arkeet> yes
19:58:22 <tibbe> edwardk: yeah
19:58:36 <FreeFull> 4 am, sleep time
19:58:42 <ski_> night, FreeFull
19:58:58 <arkeet> FreeFull: no, = => <= but <= =/> <
19:59:25 <arkeet> =>
19:59:29 <edwardk> tibbe: remind me if i don't bring up the topic again after 7.9 starts up, because i want to make sure i remember and we haven't set up a core libraries committee issue tracker. either that or email core-libraries-committee@haskell.org about this issue.
19:59:49 <tibbe> edwardk: file a ticket! :)
19:59:52 <edwardk> tibbe: but i think the strict traversals are a very good idea
19:59:54 <tibbe> edwardk: CC both of us
19:59:57 <edwardk> heh
20:00:14 <tibbe> edwardk: file it on the ghc tracker for now
20:00:15 <FreeFull> arkeet: But   x <= y  ==  x < succ y
20:00:27 <tibbe> edwardk: my memory is terrible
20:00:31 <edwardk> likewise ;)
20:00:37 <edwardk> who are you again? =)
20:00:52 <arkeet> FreeFull: (a) that's only true of like integers, and (b) I'm talking about a different <=
20:01:17 <FreeFull> I might be talking about a different succ
20:01:36 <arkeet> ok, so what's succ on the rational numbers?
20:01:40 <ski_> there is no generic `succ' in domain theory
20:01:55 <arkeet> or, well, a partial order
20:02:03 <edwardk> tibbe: also did you see the post in the matrix multiplication series that talked about a bit twidling hack that may make some operations in IntMap go faster?
20:02:10 <FreeFull> arkeet: Clearly adding an infinitinessal
20:02:18 <tibbe> edwardk: hehe
20:02:22 <FreeFull> For rationals
20:02:28 <edwardk> tibbe: i've had zero time to benchmark it, but from a logical perspective it can pay off
20:02:30 <arkeet> FreeFull: I give you a poset {a,b,c} defined by a < b and a < c
20:02:33 <arkeet> what is succ a?
20:02:36 <tibbe> edwardk: I didn't see it but someone mentioned it
20:02:38 <edwardk> https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-4
20:02:43 <tibbe> edwardk: haven't had time to look I'm afraid
20:02:56 <FreeFull> arkeet: Well, that's a good point
20:02:56 <edwardk> basically it replaces the Prefix/Mask combo with the pair of the least and greatest entries in the map
20:03:19 <FreeFull> arkeet: succ a is some x such that a < x
20:03:24 <edwardk> and then uses the fact that a < b && a < xor a b    can be used to compare two integers by the position that their msb is at, rather than their full value.
20:03:25 <arkeet> which one?
20:03:37 <edwardk> that is enough to tell you which of the 6 cases intmap ever deals with you're in.
20:03:48 <arkeet> anyway, my point is that usually <= is more useful.
20:03:51 <edwardk> but now you have not only the msbs, but more information about the rest of the bits
20:04:01 <FreeFull> arkeet: I can't really dig my way out of this one
20:04:07 <arkeet> :p
20:04:14 <ski_> FreeFull : `succ a' ought to be the unique `b' such that there is no `x' with `a < x /\ x < b' -- but such a `b' needn't exist -- and there may also be more than one such `b'
20:04:16 <edwardk> so you can quickly reject things that are outside of the range when searching or deleting
20:04:26 <arkeet> or no such b
20:04:36 <ski_> (which i said :)
20:04:40 <tibbe> edwardk: interesting, would be worth a benchmark
20:04:40 <arkeet> oh.
20:04:45 <edwardk> it gives faster rejections for deleting things that are missing or failed lookups, because it can happen way up the tree
20:04:46 <arkeet> > succ True
20:04:47 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
20:04:54 <edwardk> and you get easy access to the minimum and maximum key in the intmap
20:05:05 <FreeFull> > succ Eq
20:05:06 <lambdabot>   Not in scope: data constructor `Eq'
20:05:06 <lambdabot>  Perhaps you meant `EQ' (imported from ...
20:05:09 <FreeFull> > succ EQ
20:05:09 <edwardk> which means the common 'max key + 1' operations for IntMap become cheaper
20:05:10 <lambdabot>   GT
20:05:18 <arkeet> > iterate succ LT
20:05:20 <lambdabot>   [LT,EQ,GT,*Exception: Prelude.Enum.Ordering.succ: bad argument
20:05:41 <tibbe> edwardk: I'm ashamed to say that I user pointer equality in unordered-containers to avoid allocation altogether if nothing was deleted
20:05:43 <edwardk> tibbe: i posted it with a call for benchmarks but nobody has descended into the criterion mines yt ;)
20:05:50 <FreeFull> There ought be a typeclass for circular orderings
20:06:04 <edwardk> tibbe: i'm not above that. i'd be willing to see it in Data.Map too =P
20:06:44 <monochrom> FreeFull: lambda is intrinsically hard with: (take a breath, it's mouthful) mutable variables where both lvalue and rvalue use the same name. example: var v; ... (\x -> x+v)  do you want that "v" to refer to "the value at the time this lambda is built" or "do the dereference when the lambda is used"?  at the end, it's a bikeshed colour debate, or you have to add extra syntax to disambiguate.
20:06:52 <edwardk> lens is pushing 130 or so unsafe coerces at this point. i can't stand on moral high ground =P
20:07:01 <tibbe> edwardk: we could do it there, haven't gotten around to it. It makes delete >2x faster for misses
20:07:16 <tibbe> edwardk: as there is no allocation
20:07:19 <edwardk> yeah
20:07:22 <haasn> does anybody know if gpipe still works? (ie. with updated packages / 7.6) I would be interested in writing pixel shaders using it
20:07:34 <haasn> maybe write a toy media player using it and hs-ffmpeg or whatever :P
20:08:03 <FreeFull> monochrom: I didn't think of mutability
20:08:03 <edwardk> so if i were to hypothetically head off and bang out a patch for it, you'd be favorably inclined?
20:08:19 <FreeFull> monochrom: Pure programming languages are making me forget
20:08:20 <ski_> monochrom : whence ?
20:08:36 <FreeFull> Anyway, SLEEP
20:08:43 <FreeFull> Maybe I'll dream of Haskell
20:08:45 <monochrom> now, look at Haskell. you have to first do "p <- v". now you have two names. you can write either (\x -> x+p) or (\x -> ... v ... too lazy to write). you know what the code wants at a glance.
20:09:05 <arkeet> monochrom: I think the former is the only one that makes sense.
20:09:11 <arkeet> the one where it captures the value.
20:09:15 <arkeet> :c
20:09:35 <monochrom> SML is a similar story, with a different notation.
20:09:45 <tibbe> edwardk: sure
20:09:54 <tibbe> edwardk: you can look at unordered-containers
20:10:00 <FreeFull> arkeet: It captures a value either way
20:10:09 <edwardk> anyways the main things i'd expect my msb comparison trick to pay off for would be hedge unions, false deletes and false searches, it otherwise turns a couple of masks and ands and compares into 2-3 xors and compares
20:10:10 <arkeet> the value at the time the lambda is made.
20:10:10 <tibbe> edwardk: where I have ptrEq = reallyUnsafePtrEquality ;)
20:10:16 <edwardk> heh
20:10:25 <tibbe> edwardk: much shorter
20:10:31 <tibbe> edwardk: gotta go I'm afraid, ttyl
20:10:42 <edwardk> i'll keep chasing after getting the COLA down to something fast enough to compete with you
20:10:50 <tibbe> cool
20:10:55 <edwardk> right now its 3x slower but contiguous storage for inserts, searches should be faster though
20:12:55 <Ralith> haasn: congrats
20:22:18 <joelteon> why doesn't hClose happen immediately?
20:22:30 <joelteon> it returns but the handle isn't *actually* closed
20:22:34 <joelteon> until someone tries to write to it
20:23:23 <m3ga> joelteon: that is just one of the many problems with lazy I/O
20:23:36 <joelteon> well, can I force it?
20:24:48 <m3ga> joelteon: not possible to force it as far as i know. solution is to use one of iteratee/enumerator/conduit/pipe/stream-io/machines libraries
20:25:14 <m3ga> i prefer conduit myself, mainly because it is used in yesod.
20:25:18 <Cale> joelteon: The handle will be closed automatically when the entire file is finished being read, or when the garbage collector collects it.
20:25:57 <Cale> You give up direct control over the handle when you apply hGetContents.
20:26:23 <Cale> (I'm assuming you're talking about hGetContents)
20:26:46 <ski_> joelteon : you should not `hClose' a handle passed to `hGetContents'
20:27:08 <arkeet> lazy IO =(
20:27:11 <Cale> If you want direct control over the handle, don't use lazy hGetContents. One of the easiest ways to avoid using lazy hGetContents is just to use the strict one from Data.Text or Data.ByteString
20:27:18 <joelteon> oh, I use hGetChar
20:27:30 <joelteon> does that count?
20:27:35 <Cale> If you're using hGetChar, you're allowed to apply hClose yourself.
20:28:04 <joelteon> Right, well, the question was how do I make it close the handle when hClose returns
20:28:17 <Cale> That... that's what hClose does.
20:28:20 <ski_> Cale : i'd expect the strict ones apply `hClose' themselves as well ?
20:28:57 <Cale> ski_: yeah
20:29:03 <joelteon> ok
20:29:08 <joelteon> well that's the source of my question then
20:29:27 <Cale> joelteon: The only thing that hClose does is to close the handle it's applied to.
20:29:28 <arkeet> why do you think it doesn't close?
20:29:37 <joelteon> ok, everybody just hang on a minute
20:30:17 * hackagebot bytes 0.11.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11.1 (EdwardKmett)
20:30:32 <joelteon> aha
20:30:33 <ski_> (imo, applying `hClose' to a handle that has been passed to `hGetContents' should either be an error, or do nothing)
20:30:34 <geekosaur> I didn;t think the lazy I/O thing had anything to do with it...
20:30:36 <joelteon> oh, hClose is actually hanging
20:30:40 <joelteon> it's not returning
20:30:51 <joelteon> I had it at the end of a do block so I didn't realize
20:31:14 <ski_> perhaps some code would be in order at this point
20:31:14 <geekosaur> what do you have open on the handle?
20:31:30 <joelteon> a connection to an IRC client
20:31:58 <joelteon> hClose returns when the client attemps to send a PING command (after a few seconds)
20:32:37 <arkeet> are you actually waiting for input?
20:32:39 <geekosaur> I am tempted to say something has the socket locked in the I/O manager
20:32:54 <arkeet> code would be good.
20:33:00 <geekosaur> ^^
20:33:02 <joelteon> this is a pretty complex app
20:33:06 <joelteon> so I'll try to make a simplified version
20:47:01 <edwardk> haasn: iterate (\z -> z^2+c) ^? taking 100 folded.filtered diverges.asIndex   can probably use iterated
20:47:03 <edwardk> :t iterated
20:47:13 <edwardk> :t Control.Lens.iterated
20:47:14 <lambdabot> (Applicative f, Contravariant f) => (a -> a) -> (a -> f a) -> a -> f a
20:47:30 <edwardk> so then you can move that over to the right
20:48:12 <edwardk> taking 100 (iterated $ \z -> z^c+c).filtered diverges.asIndex
20:51:38 <joelteon> here we go
20:51:40 <joelteon> https://gist.github.com/joelteon/6396126
20:52:01 <joelteon> I'm guessing it's because the reading thread is blocking it
20:54:49 <joelteon> -threaded doesn't help
20:59:06 <ski_> edwardk : contravariant applicative ?
20:59:23 <edwardk> contravariant + applicative = monoid
20:59:30 <edwardk> the argument is necessarily phantom
20:59:47 <ski_> `Contravariant' being contravariant functor ?
20:59:52 <edwardk> :t contramap absurd
20:59:53 <lambdabot> Not in scope: `absurd'
20:59:59 <edwardk> :t fmap Data.Void.absurd
21:00:00 <lambdabot> Functor f => f Data.Void.Void -> f b
21:00:03 <edwardk> :t contramap Data.Void.absurd
21:00:04 <lambdabot> Contravariant f => f b -> f Data.Void.Void
21:00:10 <edwardk> :t contramap Data.Void.absurd . fmap Data.Void.absurd
21:00:11 <lambdabot> (Functor f, Contravariant f) => f Data.Void.Void -> f Data.Void.Void
21:00:18 <edwardk> :t fmap Data.Void.absurd . contramap Data.Void.absurd
21:00:19 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
21:00:30 <shachaf> :t contramap (const ()) . fmap (const ())
21:00:32 <joelteon> don't all empty data decls have inhabitants?
21:00:33 <lambdabot> (Functor f, Contravariant f) => f a1 -> f a
21:00:35 <edwardk> so the argument can be freely changed to anything you want
21:00:37 <joelteon> zero* inhabitants
21:00:55 <edwardk> joelteon: the logic works here even if you invert and go to () instead.
21:01:01 <shachaf> () is just as valid as Void there.
21:01:02 <edwardk> going through Void is just clearer
21:01:10 <joelteon> yeah, but I mean the existence of Void itself
21:01:19 * shachaf sighs at multi-second latency.
21:01:32 <joelteon> is Void just a package that exports an empty data declaration and some helpers?
21:01:41 <edwardk> joelteon: we often 'pretend' when playing with haskell as a category. we use Void as the placeholder for the uninhabited data type that would exist if we didn't have all the other nice things
21:01:46 <edwardk> joelteon yes
21:01:55 <joelteon> ohhhhhhhhhhhhhhhhhhhhhhhh
21:02:12 <joelteon> ok, I thought it was doing some deep type-level magic or something
21:02:29 * ski_ used `killThread :: SystemM Void' in a monad for cooperative threads
21:02:35 <edwardk> joelteon: Void is a placeholder for a canonical uninhabited data type. we often need a name for it, so it gives you a canonical one to pick
21:02:42 <joelteon> ok neat
21:02:44 <edwardk> its like saying () is the unit data type
21:02:50 <joelteon> that makes much more sense
21:03:01 <edwardk> we could make our own data Unit = Unit  -- but it'd be tedius and cripple interoperability
21:03:50 <edwardk> i tend to return things like 'IO a' for absurd results, and when i accept them accept Foo Void when i require that it not give me any
21:04:06 <edwardk> that way i don't have to cast with 'absurd' administratively.
21:04:42 <shachaf> In edwardkland _|_ is a "nice thing"
21:05:14 <edwardk> shachaf: fix is nice, hylo is nice, etc.
21:05:20 <ski_> (hm, "kland" sounds mildly dutch in my ears ..)
21:07:08 <ski_> edwardk : and similarly accept things like `IO a' for trivial (monadic) inputs, while return things like `IO ()' for trivial results ?
21:07:19 <edwardk> yep
21:08:12 <edwardk> it avoids similar administrative () <$ 's
21:08:29 <ski_> hm .. i wonder whether one could state any similar rules-of-thumb for `(,)' and `Either'
21:10:37 <ski_> instead of `IO (Either a b)', return `forall c. (a -> IO c) -> (b -> IO c) -> IO c' or what ?
21:11:14 <ski_> or perhaps just `forall c. (a -> c) -> (b -> c) -> IO c'
21:13:08 <ski_> edwardk : though i think i wouldn't overly mind having to do `() <$ ...' (or `_ <- ...') for actual results being ignored
21:14:09 <joelteon> also, does anyone have an idea as to how to solve my problem?
21:19:19 <edwardk> ski_: i don't like the operational performance aspect of it, and its quite annoying in a parser to have to choose between having common leaf level parsers for keywords or chars having to return a useful result or not
21:21:03 <edwardk> () <$ is only free if the compiler knows the exact monad/functor being used and has a place to insert the change
21:21:43 <ski_> or can do something `CoYoneda'-like i suppose
21:22:19 <ski_> (not following the keywords vs. chars, though)
21:22:45 <ski_> monochrom : re "mutable variables where both lvalue and rvalue use the same name", how about "Work with pointers is simple, no need to dereference or getting address, all this is automatically inserted. Example: $int** ptrptr; $int i = ptrptr; - here in i = ptrptr; is automatical double dereferencing a pointer." at <http://ya-lang.com/> ?
21:27:02 <monochrom> answer: Dunning-Kruger effect on people who invent languages
21:27:50 <joelteon> oh hey, pipes-safe fixes the problem
21:31:00 <monochrom> joelteon: I am not impressed with one thread doing hgetchar and another thread doing hclose. IMO no one is supposed to do that. in any case, currently, hclose hangs because hgetchar starts first and is in progress. I call it "not meant to be solved".
21:31:14 <joelteon> ok
21:31:16 <joelteon> what should I do instead
21:31:31 <monochrom> use killThread first
21:33:38 <monochrom> Handle uses MVars to store its states precisely because you people abuse it like this
21:34:01 <monochrom> IOW hgetchar has acquired a lock and hclose is waiting on it
21:34:22 <monochrom> I feel really offended. irrationally. don't mind me.
21:52:00 <joelteon> o_o
21:54:56 <Sonarpulse> Is there anyways to do an existentail type like
21:55:20 * hackagebot cryptohash 0.10.0 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.10.0 (VincentHanquez)
21:55:35 <Sonarpulse> data X Constraint = forall a. Constraint a => X a
22:00:29 <ski_> Sonarpulse : try with `constraint' instead of `Constraint' ?
22:00:41 <Sonarpulse> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
22:00:43 <Sonarpulse> relevant?
22:00:51 <Sonarpulse> if so, I think i got it
22:01:09 <ski_> or else try `data X constraint where MkX :: constraint a => a -> X constraint'
22:01:23 <ski_> yes, you need the constraint kind extension
22:07:28 <Sonarpulse> thanks ski_
22:40:22 * hackagebot crypto-random 0.0.1 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.1 (VincentHanquez)
22:40:55 <jfischoff> are there any functor like type classes that work with types of kind: (* -> *) -> (* -> *) -> * -> * ?
23:06:46 <bootcode> is there a way to set a type context on an associated type synonym?
23:07:58 <bootcode> class HasLength a where type Length a ... -- want to have constraint Num (Length a)
23:14:47 <dmwit> bootcode: You can put it in the context of the instance declaration.
23:14:51 <mm_freak> Data.Data.Data allows to extract values, right?
23:15:15 <dmwit> bootcode: ...or the class declaration if you want.
23:15:26 <dmwit> class Num (Length a) => HasLength a where type Length a
23:15:38 <mm_freak> which requires FlexibleContexts
23:15:48 <dmwit> Hm, does it? =)
23:15:52 <mm_freak> yeah
23:16:04 <dmwit> okay =)
23:16:17 <dmwit> If you've gone all the way to TypeFamilies, though, FlexibleContexts shouldn't bother you.
23:16:18 <mm_freak> type families, despite being elegant, are often awkward to work with
23:16:24 <mm_freak> sometimes so awkward that i go back to fundeps
23:17:12 <mm_freak> well, associated types, not type families in general
23:17:34 <dmwit> associated types are GHC's greatest lie =P
23:20:37 <bootcode> dmwit: thank you
23:26:57 <mm_freak> what's a good, ideally short english word for "continuous event"?  like an explosion, which stretches over a time interval
23:27:13 <joelteon> o_o
23:28:00 <fylwind_> transition?
23:28:18 <bootcode> dmwit: if I have context (HasLength a) on a function, it won't automatically take up the (Num (Length a)) constraint? Error message seems to indicate this.
23:29:17 <mm_freak> ok, think of a real function defined only for a finite interval
23:29:23 <dmwit> ?quote dmwit first.three
23:29:23 <lambdabot> dmwit says: Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
23:29:32 <mm_freak> like the half circle: \x -> sqrt (1 - x^2)
23:29:45 <mm_freak> and now consider the horizontal axis to be time
23:29:53 <mm_freak> is there a good short name for those kinds of functions?
23:29:57 <dmwit> bootcode: But that's just a guess. Post your code and error and we'll check if that's really the problem.
23:31:19 <mm_freak> or think of morse code, which is not discrete blips, but continuous peeps
23:31:34 * ski_ is only thinking of "wavelet"
23:32:05 <mm_freak> it may be Time -> Maybe String instead of Time -> Maybe Double =)
23:32:54 <mm_freak> Event is appropriate, but already used =/
23:32:59 <bootcode> dmwit: That property needs some study from me indeed. The error was caused by having the fun take (Length a) as arg, but I didn't specify the HasLength context.
23:33:25 <bootcode> dmwit: Thought the context is kind of implicit, given that `Length a` doesn't have an actual value otherwise
23:35:10 <dmwit> bootcode: Yes, the problem is that knowing what type "Length a" is doesn't tell you anything about what type "a" is.
23:37:33 <Sonarpulse> If you don't need isEmpty, unGet, or multiple readers (and fairness), which is better: TChan or Chan?
23:38:17 <dmwit> bootcode: ...and, not to put too fine a point on it, one must know what type "a" is to know how to construct the "Num" dictionary for "Length a" (in GHC's implementation of type classes).
23:39:16 <dmwit> Sonarpulse: TChan has all the advantages of STM. Chan has all the advantages of no STM.
23:40:05 <Sonarpulse> I am making a game (including engine)
23:40:10 <dmwit> Advantages of STM: everything is composable. Advantages of no STM: no transaction overhead, different wakeup policy might be exploitable.
23:40:19 <Sonarpulse> ok
23:40:39 <Sonarpulse> my plan is to have a graphics, networking, input, and sound loop/master thread/ sort of act
23:40:52 <Sonarpulse> each has a FIFO inbox, like an actor
23:41:09 <Sonarpulse> but also access to a big glob of shared state
23:41:25 <Sonarpulse> some of which uses STM, some of which is just wild west IORefs
23:41:59 <Sonarpulse> No idea if this is a good plan, but it sounds kinda neat and symmetrical.
23:42:27 <Sonarpulse> I guess CHan is better. the master threads might delegate to worker threads, and then fairness is probably good
23:42:31 <u_> what's a good explanation of huet's higher-order unification alg?
23:42:37 <Sonarpulse> thanks
23:42:57 <dmwit> Hrm. Is fairness one of Chan's promises?
23:43:03 <dmwit> Doesn't sound right.
23:45:09 <dmwit> Okay. Fairness probably comes about anyway from MVar's FIFO promises.
23:45:30 * hackagebot set-cover 0.0.1 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  http://hackage.haskell.org/package/set-cover-0.0.1 (HenningThielemann)
