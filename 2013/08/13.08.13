00:21:44 <dibblego> https://gist.github.com/tonymorris/6218636 what are arguments for foldMx/foldMy such that they produce a different outcome?
01:19:05 <scshunt> What is the technical reason for exceptions only being catchable in IO?
01:19:36 <shachaf> "exceptions" is a big thing. You mean things like error?
01:22:06 <scshunt> Control.Exception
01:24:08 <johnw> scshunt: those kinds of exceptions are a behavior of the Haskell runtime.  Even though you can call "throw" in pure code, the thunk may be evaluated in another location entirely
01:24:56 <quchen> scshunt: Due to Haskell's unspecified evaluation order, when evaluating "a + b", a or b could be evaluated in any order, and also throw exceptions in any order. Therefore, which exception is actually thrown depends on the mood of the runtime, i.e. is impure.
01:25:12 <scshunt> quchen: ah, thanks
01:25:17 <quchen> Also what johnw said.
01:26:19 <johnw> scshunt: edwardk has a library, called "exceptions", which will let you model exceptional behavior using the same interface in pure code, via a Catch monad (and CatchT transformer)
01:26:46 <quchen> scshunt: I don't recommend using IO-catchable exceptions in pure code anyway. It's a little like using "goto error". Consider using Maybe and friends first.
01:26:52 <johnw> but you cannot deal with regular exceptions using that interface, it is just for managing monads like EitherT using the same interface
01:27:31 <johnw> quchen: my personal recommendation for that is the failure package
01:37:15 <supki> I don't see the point of failure
01:37:29 <supki> abstracting over Maybe/Either/[] _and_ IO does not seem useful
01:38:00 * hackagebot monad-par 0.3.4.4 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.4 (SimonMarlow)
01:38:05 <Cho0fool> Hello, how can i rewrite it using =<< ?   ref <- resolveReference $ pack "HEAD"; traverseObjects_ processCommit $ fromJust ref
01:38:45 <johnw> supki: consider a Maybe monad computation, which chains five computations.  If it returns Nothing, you have no way of knowing which part of the computation failed, or why.  Failure is about letting the library author maintain as much information as possible, and the user to decide how they want to consume that informatino
01:38:55 <Cho0fool> traverseObjects_ processCommit $ fromJust =<< resolveReference $ pack "HEAD" -- Doesn't work for some reason
01:38:55 <t7> @do { ref <- resolveReference $ pack "HEAD"; traverseObjects_ processCommit $ fromJust ref }
01:38:55 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
01:39:14 <Cho0fool> @do do { ref <- resolveReference $ pack "HEAD"; traverseObjects_ processCommit $ fromJust ref }
01:39:14 <lambdabot> do { ref <- resolveReference $ pack "HEAD"; traverseObjects_ processCommit $ fromJust ref}
01:39:22 <Cho0fool> @help do
01:39:22 <lambdabot> do <expr>
01:39:22 <lambdabot> Translate Monad operators to do notation.
01:39:30 <Cho0fool> @undo do { ref <- resolveReference $ pack "HEAD"; traverseObjects_ processCommit $ fromJust ref }
01:39:30 <lambdabot> resolveReference $ pack "HEAD" >>= \ ref -> traverseObjects_ processCommit $ fromJust ref
01:39:53 <johnw> Cho0fool: please ask in #gitlib
01:39:54 <t7> you probably don't wanna use fromJust
01:40:27 <Cho0fool> johnw: Okay. :)
01:40:31 <johnw> it would have to be: traverseObjects_ processCommit . fromJust =<< resolveReference (pack "HEAD")
01:40:47 <johnw> but fromJust should be avoided always
01:43:22 <supki> johnw: is there an example where it's useful?
01:43:45 <johnw> supki: sure, one sec
01:44:15 <t7> if you want to crash the runtime
01:48:30 <johnw> supki: https://gist.github.com/6219164
01:49:41 <johnw> supki: the idea here is that the author of safeDiv doesn't have to decide how the user is going to handle failure in their program.  Now, if the user prefers Maybe, they can use Maybe; if they are using EitherT, everything just works; and if they want to catch exceptions or onException, again it just works for them.  It defers the question of error representation to the user, while the library writer just uses the Failure interface
01:49:58 <johnw> plus, it carries information about which errors may occur in the type signature
02:00:35 <supki> I think you need deep monad transformer stack for that to become useful? Otherwise I'd just use prisms/whatever on Either to get the representation I want.
02:01:12 <johnw> you mean, always use Either and then use prisms to convert the value?
02:01:18 <supki> yep
02:01:29 <johnw> and if you actually want exceptions, manually throw them?
02:04:23 <supki> yes
02:04:43 <johnw> fair enough
02:18:15 <GGYY> run chrome http://www.sikat.me
02:18:16 <GGYY> http://www.sikat.me
02:29:03 <merijn> This FP Complete Competition seems like a tempting way to try and squeeze money out of libraries/programs I was gonna develop anyway :p
02:40:05 <elflord> when do people use String and when do they choose Text ?
02:43:19 <donri> i use text when i want text
02:44:44 <donri> string tries to do everything in one type (text, filepaths, bytes...) and ends up not being good at anything
02:45:06 <AfC> donri: heh
02:46:50 <osa1> so looks like tagsoup parser requires a String for parsing, but it's not specified in it's documentation and parser instead gets a parameter `StringLike`, which is an interface for ByteString, Text etc. but they all get converted to String before passing to parser. now the problem is, I'm reading an URL as ByteString, and since I don't know what tagsoup parser really wants, I'm passing ByteString to it but internally my program also needs a String to work on.
02:46:52 <osa1> so I'm converting ByteString to String twice, just because it's not specified in tagsoup parser. after looking it's source and seeing this I fixed that. not sure what to think this, just want to share.
02:47:13 <elflord> donri, so when do you need text and when do you need String ?
02:48:31 <donri> elflord: not sure i ever 'need' string unless some library requires it
02:48:48 <osa1> about this text talk, I recently converted all strings to texts and get significant performance improvement in my programming language interpreter. if I remember correctly HashMap lookups(using text as key) got significant improvement in performance.
02:49:40 <chrisdone> anyone got a hostname parser in haskell?
02:51:42 <hpaste> klrr pasted “random error :s” at http://lpaste.net/91803
02:52:02 <merijn> elflord: Basically, String is almost never right
02:52:28 <merijn> elflord: String is a linked list of Char, Text is tightly packed unicode text
02:52:29 <Kinnison> Beyond 'early learning' String isn't terribly useful
02:53:12 <merijn> elflord: Basically, keep in mind that String takes approximately 16-20 bytes per character, whereas Text probably uses about 1-3 byte per character plus some constant overhead
02:54:04 <merijn> elflord: You really only use String for simple debugging/messing around stuff and small constants. For anything else, especially when dealing with files/network you want text
02:55:01 <merijn> elflord: Hope that answers your questions :)
02:55:34 <osa1> merijn: what about ByteString? looks like conduit etc. uses ByteString for networking stuff
02:56:36 <donri> osa1: they're for completely different use cases. that's one of the problems with string, that it tries to do both
02:57:36 <donri> bytestring is for literal bytes, basically [Word8], text is for unicode characters decoded from bytes
02:57:55 <quchen> Can I somehow parse multi-option fields with optparse-applicative? I'd like something of sorts [--verbosity=Debug|Normal|Quiet]
02:57:59 <merijn> osa1: ByteString has nothing to do with String and everything with Byte
02:58:10 <donri> it's like the difference between a parse tree for an XML document, and its textual representation
02:58:23 <merijn> osa1: ByteString is a string of bytes, no encoding information, etc.
02:59:19 <merijn> osa1: Text on the other hand is unicode text, the usual way to get Text is to obtain a ByteString from the network/disk and decode it with a specific decoding, resulting in Text
02:59:23 <merijn> See Text.Encoding
02:59:47 <merijn> osa1: The Text/ByteString difference is the same as the Python3 unicode/bytes difference
03:00:27 <elflord> merijn, thanks man ! this stuff is not explained "offically" in any textbook
03:00:52 <elflord> merijn, plus there are many prelude functions working with String
03:01:02 <donri> quchen: should be easy with e.g. readMaybe
03:01:12 <elflord> merijn, so people will naturally get the idea of using String over other stuff
03:01:23 <quchen> donri: But there's no built-in combinator I'm overlooking at least
03:01:38 <quchen> … that's where the question came from
03:01:56 <arkeet> they should rename it to ByteArray to avoid confusion.
03:02:06 <arkeet> or something
03:02:18 <donri> quchen: nullOption (reader readMaybe)
03:03:28 <merijn> elflord: I think RWH covers this type of stuff, but I'm not sure
03:03:37 <quchen> donri: Aaaah, thanks, that helped
03:03:46 <donri> quchen: uh it's Either now. i use the errors package: nullOption (reader (note ShowHelpText . readMaybe))
03:04:32 <merijn> elflord: Yeah, many of the same functions are exported from Data.Text/Data.ByteString, though
03:04:39 <merijn> :t takeWhile
03:04:40 <lambdabot> (a -> Bool) -> [a] -> [a]
03:04:47 <merijn> :t Data.ByteString.takeWhile
03:04:48 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> BSC.ByteString
03:04:52 <donri> quchen: also this is the 'auto' reader in optparse
03:04:55 <merijn> :t Data.Text.takeWhile
03:04:56 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
03:05:00 <donri> quchen: nullOption (reader auto)
03:05:16 <donri> quchen: which is the same as simply: option
03:05:20 <donri> so, yeah.
03:05:41 <donri> (in my case i'm not actually using read, thus the need for more code)
03:05:59 <osa1> can anyone recommend me a library to join URLs ? some examples: join "http://a.com" "http://b.com" -> "http://b.com", join "http://a.com" "style.css" -> "http://a.com/style.css"
03:06:19 <quchen> donri: I'm not a fan of Read either. Anyway, I know where to dig now. :-)
03:06:24 <osa1> basically I want to follow some links in some URLs
03:06:34 <quchen> donri: Had a little trouble with the docs it seems.
03:06:35 <merijn> elflord: I think the problem is that LYAH doesn't really cover this, because it focuses on the very basics and most people try to start coding straight after LYAH, before reading anything else, thus getting confused when they trip over these things
03:07:36 <imperative_progr> Indentation of Haskell code is not displayed properly in proportional fonts. What should I do other than using monospaced fonts?
03:08:05 <Hafydd> Use monospaced fonts.
03:08:09 <merijn> arkeet: Hell, just Bytes would work, but changing it now is nearly impossible
03:08:17 <elflord> merijn, anyway thanks !
03:08:29 <merijn> imperative_progr: I think it'll be almost impossible to get Haskell layout properly in a proportional font
03:08:40 <donri> imperative_progr: haskell is optimized for fixed width fonts, not much you can do
03:09:04 <donri> imperative_progr: not without adding more structure, which you don't have in a plain text editor
03:09:24 <Hafydd> Programming in variable-width fonts sounds pretty demented.
03:09:27 <arkeet> merijn: Bytes sounds better
03:09:28 <merijn> Well, he could use braces and semicolons, but that's not gonna make you popular in the community
03:09:29 <arkeet> =)
03:09:34 <arkeet> but yeah, we're stuck with what we've got =(
03:10:11 <Work_jack> merijn: I tried writing a project using as many braces in Haskell as possible and I was surprised how much I liked it :)
03:11:09 <merijn> Work_jack: You sound like a candidate for https://github.com/kien/rainbow_parentheses.vim :)
03:11:42 <Work_jack> I'm no vim user!
03:11:57 <merijn> pffft
03:12:03 <Work_jack> Well I happen to dislike braces in C/Java so it came as quite a shock to me ;)
03:12:05 <merijn> Better fix that than!
03:12:25 <arkeet> merijn: that sounds like something I could use!!
03:12:32 <merijn> arkeet: It's awesome
03:12:36 <arkeet> as in, something I never knew I couldn't live without
03:12:45 <arkeet> thanks.
03:12:45 <Work_jack> merijn: I might when vim gets a package manager and a music player
03:12:53 <danr> merijn: doesn't it get... too colourful?
03:12:59 <arkeet> Work_jack: pathogen works pretty alright for the former
03:13:02 <Dtgr> rainbow parentheses was a must when I did some clojure
03:13:08 <merijn> arkeet: I try to occasionally pimp fun plugins like that because not many people know it :)
03:13:15 <arkeet> merijn: do it more often!
03:13:19 <arkeet> especially when I'm around.
03:13:25 <Work_jack> (and is configurable with lisp)
03:13:33 <osfameron> s/pathogen/Vundle these dys
03:13:41 <merijn> danr: I have the default colour set to my normal text colour so you don't get too many colours unless you nest ridiculously deep
03:13:42 <simukis_> arkeet: so does vundle.
03:13:55 <arkeet> ah, well, pathogen works for me.
03:14:01 <arkeet> can't be bothered to switch
03:14:01 <merijn> osfameron: ugh, this sounds like the "brew > ports" all over again
03:14:25 <merijn> "Switch to the new hotness!" 'why?' "it's better!" 'how, specifically?' "It just is!"
03:14:43 <simukis_> merijn: well… in case of pathogen vs. vundle… vundle is just more automatic.
03:14:46 <osfameron> hehe.  though brew is really a totally different thing to ports.  I'm sure pathogen is fine, not worth *switching* but worth checking Vundle if you were starting anew
03:14:49 <Dtgr> simukis_: agreed
03:14:51 <merijn> simukis_: More automatic than what?
03:14:55 <simukis_> pathogen.
03:14:56 <Dtgr> than pathogen
03:15:09 <merijn> What the hell would you possibly want to automate?!
03:15:16 <merijn> "dump repo in folder, done"
03:15:29 <Dtgr> add repo url to .vimrc, done
03:15:44 <merijn> Dtgr: Sounds like a good way to get backdoored
03:16:05 <merijn> Compromise 1 github repo, compromise every single user of the plugin
03:16:36 <Dtgr> how does it differ from cloning the repo manually?
03:16:53 <merijn> Dtgr: If the repo is compromised after I clone I'm safe
03:17:19 <Dtgr> and so am I
03:17:30 <simukis_> well, vundle doesn't do updates by itself too…
03:17:36 <merijn> Wait, so it doesn't even update?
03:17:37 <simukis_> you do vim +UpdateBundles +all…
03:18:00 <simukis_> I mean it doesn't do so automatically, without you telling it to do them.
03:18:14 <merijn> heh, So basically all it saves is one "git clone ..." gets replaced with "edit .vimrc with repo url"
03:18:52 <osfameron> simukis_: it does update automatically?  at least I've got it set up to
03:18:53 * merijn goes back to a grumpy old curmudgeon with his pathogen
03:19:25 <simukis_> hmm, you can put your vimrc to another system and then running a single vim command is sufficient to get all your plugins installed? But well, I'm not forcing anybody into using something else, do I?
03:19:34 <Dtgr> merijn: how do you set up pathogen to a new machine?
03:19:38 <merijn> arkeet: Speaking of vim plugins to pimp: https://github.com/merijn/haskellFoldIndent :p
03:19:43 <Dtgr> do you need to clone all the repos again
03:19:43 <osfameron> simukis_: yeah, that's a lovely thing
03:20:20 <merijn> Dtgr: No, I have a script that duplicates my entire environment to a new machines
03:20:20 <arkeet> merijn: cool
03:20:33 <Dtgr> ok
03:20:54 <Dtgr> whatever is your cup of tea, imho vundle is simpler
03:21:00 <merijn> arkeet: Could use some more polishing, but fairly usable already :)
03:22:34 <osa1> does anyone know a url join function for Haskell? like urlparse.urljoin of Python
03:23:47 <simukis_> osa1: Which package are you using for your URI manipulation?
03:24:09 <osa1> simukis_: I'm looking for a package to use for URI manipulation
03:24:16 <simukis_> osa1: every one of them should have one (for example: http://hackage.haskell.org/packages/archive/uri/0.1.6.1/doc/html/Text-URI.html#v:mergeURIs)
03:24:37 <osa1> well Text.URL doesn't have one
03:24:53 <simukis_> I linked directly to the function, didn't I?
03:24:53 <osa1> ops, Network.URL
03:24:59 <osa1> yes
03:26:43 <t7> someone port GLM to haskell,
03:26:49 <t7> i will crowd fund :3
03:27:42 <dalaing1> merijn: that looks like a might fine plugin
03:44:50 <mjo_> Hi, can I ask a question about foldr and space ?
03:45:12 <Work_jack> Don't ask to ask :)
03:45:13 <arkeet> just ask :-)
03:45:25 <arkeet> meanwhile good night
03:45:40 <mjo_> OK, I have a trivial program at http://lpaste.net/91804
03:46:30 <arkeet> why is cfr2 so slow?
03:46:43 <arkeet> because it's destroying and reconstructing the tuple 5 million times.
03:46:45 <mjo_> It just copies a list into another list with foldr and it works fine. If instead I copy the list into the first half if a tuple it blows up. I think one runs in constant space, but the other doesn't
03:47:07 <arkeet> try foldr (\a ~(bs,_) -> ...
03:47:17 <mjo_> What does the ~ do ?
03:47:20 <arkeet> lazy pattern match.
03:47:47 <arkeet> maybe this got lost in the netsplit <arkeet> because it's destroying and reconstructing the tuple 5 million times.
03:48:04 * hackagebot hostname-validate 1.0.0 - Validate hostnames e.g. localhost or foo.co.uk.  http://hackage.haskell.org/package/hostname-validate-1.0.0 (ChrisDone)
03:48:06 <arkeet> destructing.
03:48:11 <mjo_> So why don't I need that in the case where I just make a list ?
03:48:23 <arkeet> because bs already matches anything.
03:48:37 <arkeet> it doesn't need to be inspected for you to know that the output is a list that starts with a
03:49:11 <arkeet> anyway, does that work?
03:49:41 <mjo_> Hmmm I still don't see it. I think I'm missing something. Hang on, I'll check
03:50:27 <mjo_> Yes that does work. Thanks. I'll go away and evaluate a few steps by hand...
03:50:50 <arkeet> the ~ is a http://www.haskell.org/haskellwiki/Lazy_pattern_match
03:51:42 <arkeet> it's needed because we don't "know" that the output of the lambda in the previous recursive step is a (_,_)
03:52:00 <arkeet> the ~ lets us assume it is, and worry about it later.
03:52:19 <mjo_> Yes, I half see it now. Thanks
03:52:26 <arkeet> without it, it'll have to traverse the entire list before it can even start constructing anything, blowing the stack.
03:53:14 <mjo_> Yes I worked out that it was doing that, and not doing it in the simple case. It was more a question of why
03:53:15 <arkeet> btw, you have a lot of unneeded parenthese there ;)
03:53:28 <killy9999> ((fun *** fun) tupple)
03:53:29 <arkeet> cfr2 = foldr (\a (bs,_) -> (a:bs, [])) ([],[])
03:53:38 <killy9999> can this be done in a shorter way?
03:53:43 <killy9999> without repeating fold
03:53:46 <mjo_> Yes, I know. As you probably realize I'd cut this down from a bigger example
03:53:49 <arkeet> join (***) fun
03:53:52 <killy9999> *** is from Control.arrows
03:54:01 <arkeet> over both fun  (if you have lens)
03:54:23 <arkeet> (and you don't mind being less polymorphic)
03:54:24 <killy9999> I don't have lens..
03:54:28 <arkeet> then, join (***) fun
03:54:34 <killy9999> oh, fold ahs to be polymorphic
03:54:40 <arkeet> ??
03:54:43 <killy9999> s/ahs/has/
03:54:52 <killy9999> it has polymorphic parameter a
03:54:55 <arkeet> well sure.
03:55:00 <arkeet> but does the tuple have two different types in it?
03:55:03 <killy9999> and each component of the tuple instantiates it to sth else
03:55:06 <killy9999> yes
03:55:10 <arkeet> ok, then you can't do any better.
03:55:18 <arkeet> unless you enjoy rank-2 types or something.
03:55:38 <arkeet> (and then it would just get ugly.)
03:55:46 <killy9999> sure
03:56:02 <killy9999> then I guess I'll do with repeating folg
03:56:03 <killy9999> fold
03:56:05 <killy9999> thanks
03:56:13 <arkeet> in other words, the two 'fun's there are different, so you can't avoid repeating them. (without rank-2 types or whatever)
03:56:59 <killy9999> why would rank-2-types make it ugly?
03:57:07 <killy9999> I mean I already need a type signature
03:58:05 <killy9999> (which I believe I could remove if I used NoMonoLocalBinds)
03:58:38 <arkeet> I mean you'd need a rank-2 version of \f -> f *** f
03:59:09 <arkeet> and it's hard to say what type you really want to give that
03:59:35 <arkeet> ugly.
03:59:48 <arkeet> it can't require anything more polymorphic than your fun already is.
04:03:02 <int-e> you could write (forall a. a -> a) -> (a,b) -> (a,b) ... but it's fairly close to  const id  :)
04:03:22 <lukleh> hi, can't figure out why "print []" works in in GHCI but does not compile with runhaskell with show instance missing. any clues?
04:03:59 <int-e> lukleh: ghci has some extended defaulting rules, so [] (which has type [a] for any type a) defaults to [()] in ghci.
04:04:14 <int-e> but not when compiling the code. print ([] :: [()]) will work in compiled code.
04:05:03 <osa1> is there a way to run GHCi in some kind of "server mode" ? i.e. it listens port 1234 for commands and sends responses back in a TCP connection or something like that
04:05:13 <lukleh> int-e: I see, thank you. but what if I need to print a fuction result that may return [] ?
04:06:15 <int-e> lukleh: that's not an issue, provided that the list elements (when the function returns a non-empty list) have a Show instance.
04:06:31 <int-e> lukleh: (It depends on the type, not the value.)
04:06:34 <Work_jack> Is the Data.Ix typeclass used much in Haskell?
04:06:46 <Work_jack> I hardly ever see it used
04:07:08 <int-e> It's used for indexing arrays.
04:07:28 <Work_jack> I know what it's for
04:08:28 <lukleh> int-e: the signature is "flatten :: NestedList a -> [a]", that is ok. but again, this can return empty list.
04:08:38 <int-e> Work_jack: what do you mean by "used" then? When I write  a ! (1,2) (a being an array) then I'm using the Ix type class.
04:09:49 <Work_jack> In wondering if they're "used much" rather whether it's possible to use them :)
04:15:45 <Bob____> In the Text.XML package, how do I create a FilePath for use with the readFile function? It doesn't seem to be a synonym for String.
04:16:01 <lukleh> int-e: it works if I force it: print (flatten (List []) :: [()]) but this feels odd as one cannot rely on printing an empty list... :(
04:17:24 <int-e> lukleh: that's the point really - once you have code that does not always produce the empty list, that will fix the element type and the problem will likely disappear.
04:19:17 <lukleh> int-e: but I do have code that _can_ produce empty list. example print fn 1; print fn 2; if fn 1 returns [1, 2] and fn 2 returns [] it will still break
04:20:27 <hpc> lukleh: it won't break; your [] and [1, 2] will be the same type
04:20:33 <tulcod> when can i consider a library ready for uploading to hackage?
04:20:40 <hpc> specifically, Num a => [a]
04:20:52 <hpc> which defaults to [Integer] if you don't do any weird languagey things
04:21:10 <hpc> > let fn 1 = [1, 2]; fn 2 = [] in show (fn 2)
04:21:11 <lambdabot>   "[]"
04:25:21 <lukleh> hpc: here it shows my point http://codepad.org/EWZtvh4T without line 12 ":: [()]" it does not compile
04:26:09 <lukleh> hpc: but I can't always know if a function will return [] and add the corresponding type
04:26:55 <lukleh> hpc: or do I have to manually add this type every single time this is needed?
04:26:57 <opqdonut> lukleh: the problem is not returning [], the problem is ghc won't know the type of the [] you use to construct
04:27:15 <opqdonut> try :t List [] and you'll see
04:27:31 <int-e> lukleh: The type of  List []   is  Nestedlist a, for any a. The element type is unknown.
04:28:10 <hpc> lukleh: http://codepad.org/QDQ5lGNr -- is this what you mean by "function returning []"?
04:30:21 <hpc> er, http://codepad.org/bqvdRNqv -- forgot the last list was flattened
04:30:25 <hpc> that code works
04:30:54 <hpc> foo :: Num a => NestedList a
04:31:16 <hpc> er, Num a => Int -> etc
04:31:28 <int-e> confusingly, foo :: (Num a, Num b) => a -> NestedList b
04:31:36 <hpc> yeah, that
04:31:38 <hpc> it's early here
04:31:44 <lukleh> hpc: no. but anyway this http://codepad.org/88iZS6Ho works fine ....
04:32:27 <int-e> and it works for the same reason that hpc's code does.
04:32:39 <hpc> lukleh: the magic word you are looking for is unification
04:33:05 <hpc> types in (ghc) haskell are checked and inferred by building a giant system of equations
04:33:26 <hpc> which has such benefits as the transitive property
04:34:28 <hpc> so when you print (foo 3), it's looking all the way back to the type of foo, which looks at the first two cases which constrain the type to something it can resolve unambiguously
04:41:52 <lukleh> hpc: I don't get it, http://codepad.org/bqvdRNqv works fine, but foo N shoudl not affect the rest of the code
04:46:25 <quchen> Does Binary serialize every Int to the same output length, or does maxBount possibly use more data than 0?
04:46:32 <quchen> s/bount/bound
04:48:18 <startling> quchen, the former
04:48:55 <quchen> startling: Excellent.
04:48:57 <lukleh> hpc: sorry guys, I just can't crack why the "foo" workaround works and the original code has to be manually tweaked http://codepad.org/EWZtvh4T :( are there some webpages to read?
04:49:21 <quchen> startling: I assume it just writes the whole Int to a ByteString, and doesn't add "this output is X bytes long" to the message then?
04:49:28 <quchen> Because that was what I was worried about
04:49:49 <notdan> quchen: depends on what you use to serialize thought. Not mentioning the difference between 64bity and 32bit machines there are different functions you can use: http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Builder.html#g:4
04:50:03 <notdan> but if you stick to one encoding it should be the same
04:50:11 <quchen> notdan: I just used Int as a simplification there. My program runs Int64.
04:50:22 <startling> quchen, are you thinking of Integer?
04:50:29 <notdan> Yeah it should be the same size then
04:50:55 <quchen> startling: No, it really is Int64. For Integer the encoding length is of course dependent on the size.
04:51:03 <quchen> But then I wouldn't have asked about maxBound above ;-)
04:51:36 <startling> quchen: right. yes, your understanding (Int is not length-prefixed) is also my understanding.
04:51:57 <quchen> So what I'm doing is I'm reading a network stream (ByteString).
04:52:07 <quchen> However, the data is (much) shorter than a BS chunk.
04:52:24 <quchen> For that reason, I need to use "hGet <size in bytes of the input>", and for that I prefix the actual data with a size.
04:52:35 <quchen> And that size prefix is an encoded Int64.
04:52:53 <startling> sure.
04:53:01 <quchen> (Not that 2^64 bytes would ever be in a package, but I've got the memory so why not)
04:53:04 <lukleh> hpc: int-e: now I am getting somewhere, just added signature foo :: Int -> [a] to this http://codepad.org/88iZS6Ho and it breaks, complete code http://codepad.org/orYzzbH7
04:53:29 <danilo2> Hi! Is there any pretty way to write a parser combinator (in UU-PARSINGLIB), which will match any character excluding a group of them? something like (in regexp) [^a,b,c]
04:53:32 <quchen> startling, notdan: Alright, thanks for your help. Also thanks Binary for not doing weird things with IntX.
05:00:10 <startling> danilo2: if you've got a "satisfy" combinator, it's something like "satisfy (`notElem` "abc")"
05:00:20 <startling> this is usually called "noneOf"
05:02:18 <danilo2> starlibg: while using Satisfy combinator I should apply an Insertion instance, like (pNoneOf sysm = pSatisfy (`notElem` sysm) (Insertion ('_') t 100)) - but this is not straightforward, because I have to search a Unicode character, which could be inserted in this place, when this combinator is not satisfied - and because of that I was looking for an implemented way, not to do it myself
05:02:27 <danilo2> startling: ^
05:02:48 <startling> danilo2: this library you're using sounds kind of strange
05:03:07 <lukleh> int-e: so the final word is that I have to specifi the type, for example "flatten (List []) :: [Int]" even if the value of (List []) is []
05:03:50 <lukleh> int-e: one would thought that empty list is always empty list.....
05:04:11 <danilo2> startling: I was looking for several parser combinator libraries and I've found out that uu-parsinglib has some very cool features (like it allows you to automatically fix typing erros and check further the program to check if there are other erros)
05:04:30 <danilo2> startling: It is very simmilar to parsec but it seems to have more features for me
05:05:36 <danilo2> startling: here is a small discussion about its features: http://stackoverflow.com/questions/18028220/haskell-parser-combinators
05:08:01 <int-e> > show ([] :: [Int -> Int])
05:08:02 <lambdabot>   "[]"
05:08:09 <int-e> grrrrrr.
05:08:27 <int-e> > show ([] :: [IO ()])
05:08:28 <lambdabot>   "[]"
05:08:45 <int-e> So what's a type that does *not* have a Show instance in lambdabot?
05:09:08 <startling> > return () :: Identity ()
05:09:13 <lambdabot>   mueval-core: Time limit exceeded
05:09:24 <quchen> > ZipList [1]
05:09:26 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a0))
05:09:26 <lambdabot>    arising...
05:09:35 <startling> > Identity ()
05:09:39 <lambdabot>   mueval-core: Time limit exceeded
05:09:42 <startling> ????
05:09:49 <int-e> > show ([] :: [Identity ()])
05:09:50 <lambdabot>   can't find file: L.hs
05:09:55 <startling> haha
05:10:01 <quchen> > Identity ()
05:10:04 <lambdabot>   Identity {runIdentity = ()}
05:10:11 <quchen> startling: See, that's how it's done.
05:10:12 <quchen> :>
05:14:17 <int-e> lukleh: You really have to look at the types. A value of type [Int] can be printed; a value of type [Int -> Int] (usually, lambdabot is weird) can't, because its elements are functions. The confusing bit is that there are some values--- [] is one of them---that have polymorphic type. [] can be used as a value of type [Int], but also as a value of type [Int -> Int], or any other type [a] where 'a' is any type. It's always an...
05:14:23 <int-e> ...empty list, but in one case it can be printed, and in the other case it can't.
05:16:14 <int-e> @type []
05:16:15 <lambdabot> [a]
05:16:35 <lukleh> int-e: thanks, I think I got the point. Trying now to add Show instance for List [], but can't figure it out :(
05:17:08 <int-e> lukleh: the instance head will be instance (Show a) => Show NestedList a where ....
05:17:42 <int-e> (and ... contains a definition of show (or, if you feel adventurous, showsPrec)
05:17:47 <int-e> )
05:19:27 <int-e> lukleh: (again, the instance will be for a type, not for some value.)
05:19:28 <lukleh> int-e: looks ok but not sufficient instance (Show a) => Show (NestedList a) where show (List []) = show []
05:19:38 <lukleh> int-e: ahhh :(
05:19:57 <lukleh> int-e: will continue after lunch
05:31:54 <quchen> Is there a name in Haskell for what RAII is in other languages? Is it the same? "Bracketing"?
05:34:22 <Y_Less> Haskell is both lazy and garbage collected - declaring something doesn't mean it will be executed, and stopping using something doesn't mean it will be cleaned up.  I don't think RAII makes any sense in that context.
05:34:43 <mauke> Y_Less: see 'bracket'
05:35:37 <merijn> Y_Less: It does if you allocate things in IO, like file descriptors
05:36:40 <quchen> Using 'bracket' feels like RAII at least.
05:36:47 <quchen> You create stuff and it won't leak.
05:37:00 <quchen> Apart from the pathological examples merijn (I think) posted here a while ago
05:37:37 <dalaing1> linear types and monadic regions might be of interest
05:38:28 <elflord> how to understand this code:   Chunk {-# UNPACK #-} !T.Text Text
05:38:34 <elflord> it's in a data defnition
05:38:48 <elflord> What is that exclamation mark for ?
05:39:12 <quchen> BangPatterns language extension. It saves you from writing "seq" too often, basically.
05:39:14 <Saizan> stricy field
05:39:27 <Saizan> *strict
05:39:41 <Saizan> it means the constructor is going to be strict in that argument
05:39:54 <elflord> Saizan, what is strict ?
05:40:03 <Saizan> sso that Chunk undefined x == undefined
05:40:48 <elflord> Saizan, ok let me google it
05:40:50 <supki> quchen: strict fields are standard
05:41:18 <Saizan> elflord: a function is strict if when applied to a value that doesn't terminate or produces an exception its result will do the same
05:41:38 <Saizan> such values are often called bottoms, or _|_ in simbols
05:41:42 <Saizan> *symbols
05:41:45 <startling> elflord, it's a way to improve performance that slightly changes semantics. Don't worry about it if understanding strictness isn't your goal.
05:41:50 <adnap> Is there a number type like Float where all operations are clamped to a finite range, and there are no Infinity values?
05:41:52 <quchen> supki: Oh, I didn't know that.
05:41:56 <Saizan> so f is strict if f _|_ == _|_
05:42:11 <startling> adnap, Float?
05:42:23 <startling> oh
05:42:50 <quchen> adnap: Not a standard one at least.
05:43:03 <Saizan> adnap: if you can also do with fixed precision there's Data.Fixed
05:43:52 <adnap> Is it easy to define what I want?
05:44:02 <merijn> quchen: BangPatterns are for ! in pattern matches
05:44:17 <elflord> startling, Saizan , thanks i found a good explanation on stackoverflow
05:44:28 <quchen> merijn: I thought all ! were from BangPatterns. But yeah, there's no pattern in defining a data constructor.
05:44:46 <adnap> I guess Float and types based off of it are members of many classes. I wonder if using a nonstandard type would cause many problems.
05:45:37 <Saizan> their API is pretty much just members of those classes, so porting the code shouldn't be much of a problem
05:46:22 <adnap> Another question: Is there a language extension that let's me type : instead of :: in type signatures?
05:46:36 <quchen> No.
05:46:42 <quchen> inb4 CPP
05:46:56 <adnap> That sucks!
05:47:14 <udevd> adnap: what do you need it for?
05:47:34 <merijn> hmm, is there a convenient way to have Map.fromList combine duplicate entries?
05:47:35 <adnap> udevd: Unclear antecedent
05:48:28 <udevd> adnap: why do you need it?
05:48:34 <startling> merijn, fold over the list and insert each thing rather than using Map.fromLit?
05:48:37 <adnap> udevd: The type like Float or the extension to support : instead of ::?
05:48:45 <supki> merijn: fromListWith?
05:48:46 <quchen> Bikeshedding. That's what you need ":" over "::".
05:48:49 <udevd> the extention
05:49:02 <udevd> tf* extentsion
05:49:09 <ParaSa1lin> it seems like the arrows in hxt are really just monads
05:49:10 <udevd> oh shit, you know what i mean
05:49:16 <merijn> supki: I guess that'd work if I do "map (second pure)" first
05:49:19 <adnap> udevd: To save typing and satisfy my minimalism aesthetics
05:49:39 <udevd> adnap: you know that (:) is actually a function used everywhere?
05:49:59 <adnap> udevd: Yeah
05:49:59 <merijn> ParaSa1lin: How so?
05:50:20 <ParaSa1lin> well, they're all instances of ArrowApply for one
05:50:38 <merijn> ParaSa1lin: Monads are all arrows by definition
05:50:42 <adnap> udevd: I don't think it would be difficult to distinguish in type signatures at least
05:50:45 <merijn> :t Kleisli
05:50:46 <lambdabot> (a -> m b) -> Kleisli m a b
05:51:08 <ParaSa1lin> merijn, right, so im not seeing what the arrow formalism gets you in that library
05:51:09 <quchen> merijn: Well, monadic functions are.
05:51:57 <startling> ParaSa1lin, Arrow in general seems like a mediocre abstraction
05:51:58 <merijn> ParaSa1lin: The possibility to neatly combine using things lie first/second (***) and (&&&)? (Keep in mind I only looked at the docs for like 5s)
05:52:22 <ParaSa1lin> startling, yeah, i've been searching for a useful arrow
05:52:32 <startling> (->)
05:52:44 <quchen> Some FRP libraries make use of Arrow (apparently).
05:53:49 <ParaSa1lin> i mean a useful arrow that is not a functor or monad
05:54:14 <merijn> ParaSa1lin: Why the no functor requirement?
05:54:24 <adnap> I don't understandy why...
05:54:27 <merijn> That seems an odd and silly requirement
05:54:52 <ParaSa1lin> ok just monad then?
05:55:01 <startling> "an Arrow where the Arrow interface is notably more useful then the Functor and Monad interfaces"
05:55:16 <merijn> ParaSa1lin: netwire arrows aren't monad I think
05:56:06 <quicksilver> there are very few interesting arrows outside of kleisli arrows
05:56:08 <merijn> The problem with Arrows is not the abstraction, but the requirement that "arr :: Arrow a => (b -> c) -> a b c"
05:56:21 <quicksilver> there is the swierstra-duponcheel parser
05:56:27 <quicksilver> but that turned out to be even better as an applicative.
05:56:29 <startling> merijn: oh, that might be true
05:56:41 <merijn> i.e. the ability to lift arbitrary functions need to be liftable kills the abstraction
05:56:50 <quicksilver> I would interpret that slightly different.
05:56:57 <quicksilver> the problem with Arrows is *precisely* the abstraction.
05:57:06 <quicksilver> "arr" shows that it is the wrong abstraction.
05:57:16 <quicksilver> (..for lots of interesting structures)
05:57:29 <quicksilver> embedding functions is boring and not introspectable
05:58:27 <merijn> Data.Map has no polymorphic adjustWithKey ? :(
05:58:35 <merijn> I guess I need to go grab lens for that?
05:58:49 <quchen> Polymorphic?
05:58:50 <merijn> I'm sure someone in here an write that in 3 or so functions
05:59:09 <merijn> adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
05:59:22 <quchen> Oh, you mean with k -> a -> b
05:59:24 <merijn> oh
05:59:29 <merijn> I guess it only updates one
05:59:32 <merijn> That makes sense then
05:59:47 <merijn> Yeah, I want mapWithKey
06:00:19 <quchen> I only I got a Euro every time I look something up and someone else beats me to it ;-D
06:01:49 <merijn> Well, I noticed the "k" value, so I thought adjust would map
06:07:54 <adnap> I don't understand the second result is not 0:
06:08:06 <adnap> > ((1e38 :: Float) * 0, (read "Infinity" :: Float) * 0)
06:08:07 <lambdabot>   (0.0,NaN)
06:08:54 <adnap> *why the
06:09:31 <simukis_> adnap: because you get a complex number, I suppose?
06:09:59 <adnap> simukis_: How?
06:10:07 <simukis_> oh, not a complex number, indeterminate.
06:10:49 <adnap> simukis_: I don't understand.
06:11:04 <tulcod> adnap: because 1/0=NaN
06:11:18 <tulcod> adnap: so then 0*1/0 would be 0
06:11:23 <int-e> ?
06:11:24 <shiona> http://www.philforhumanity.com/Zero_Times_Infinity.html
06:11:27 <int-e> > 1/0.0
06:11:29 <lambdabot>   Infinity
06:11:34 <merijn> tulcod: 1/0 is Infinity
06:11:37 <tulcod> adnap: err, because 1/0=Infinity
06:11:48 <tulcod> so then 0*Infinity=0, thus 0=0*1/0
06:11:54 <adnap> Why is 1/0 Infinity and not NaN?
06:11:56 <tulcod> either way, math would break
06:12:11 <tulcod> adnap: well, that kinda works on the riemann sphere
06:12:24 <int-e> adnap: 0 is understood to be positive in IEEE 754 floating point
06:12:34 <merijn> adnap: Because that's what IEEE754 says
06:12:36 <int-e> > 1/-0.0
06:12:37 <lambdabot>   Not in scope: `/-'
06:12:37 <lambdabot>  Perhaps you meant one of these:
06:12:37 <lambdabot>    `-' (imported from P...
06:12:44 <int-e> > 1/(-0.0)
06:12:46 <lambdabot>   -Infinity
06:12:52 <tulcod> okay that is just wrong
06:13:33 <merijn> Everyone here should just go and read http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
06:13:39 <tulcod> darned engineers
06:13:43 <merijn> If you find anything that doesn't match that, file a bug
06:13:53 <merijn> Else, stop thinking you know floating points
06:13:54 <adnap> tulcod: What is that?
06:13:55 * int-e agrees with merijn
06:14:06 <tulcod> adnap: what is what?
06:14:06 <adnap> Er...
06:14:10 <merijn> Or, even better
06:14:14 <merijn> Stop using floating points
06:14:15 <adnap> merijn: What is that?
06:14:33 <merijn> adnap: You could read it and see?
06:14:44 <int-e> merijn: But they're so fluffy!
06:14:58 <merijn> @quote mantissa
06:14:58 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
06:14:58 <lambdabot> will stab you in the back with a mantissa
06:15:44 <int-e> <Infinity> does this exponent make me look fat?
06:16:12 <merijn> int-e: tbh, I can never remember all the details, so I just operate on the assumption that I know nothing about Float :p
06:16:14 <adnap> merijn: Before I read all of this, will you tell me what you would suggest one use instead of Float?
06:16:21 <quchen> 1/0 doesn't break math, because 1, /, 0 don't have types. "Let 1, 0 be reals and / be real division, then 1/0=something breaks math".
06:16:35 <merijn> adnap: Fixed precision arithmetic, rationals or ints
06:16:46 <int-e> merijn: I'm just glad I don't do serious numerical work :)
06:16:54 <merijn> quchen: It doesn't break math ever, it's just undefined
06:16:58 <merijn> quchen: Sometimes
06:17:07 <quchen> merijn: Let something /= undefined in my sentence.
06:17:18 <adnap> I remember all the details. 32-bit float has 1 sign bit, a 7-bit exponent, and a 23-bit mantissa.
06:17:51 <adnap> merijn: For physics simulation?
06:17:54 <merijn> If you think those are all the detals, I'm sorry but please don't ever write numerical code :(
06:18:02 <tulcod> merijn: i disagree - the riemann sphere can cope with 1/0 just fine, but you need to be careful when dealing with the almighti infinity.
06:18:21 <merijn> adnap: If you need to do physical simulation, read that document, I linked it for a reason
06:18:25 <quchen> The Riemann sphere is neither R nor C.
06:18:38 <tulcod> riemann... circle?
06:18:40 <merijn> tulcod: I qualified by saying it's undefined *sometimes*
06:18:47 <tulcod> merijn: ah yes :)
06:19:05 <merijn> Obviously I can invent an arbitrary algebra where x/0 is well defined
06:19:08 <quchen> Also if you take the compactification of C (which is the Riemann sphere) it's not a field anymore, so that solves the problem at the cost of introducing anotherone.
06:19:10 <merijn> And many people do
06:19:21 <adnap> merijn: I think the only other details are the special values NaN, Infinity, -Infinity, and -0
06:19:30 <adnap> merijn: What else is there?
06:19:54 <quchen> Those aren't details.
06:19:56 <merijn> adnap: Stop thinking, start reading, I'm not a personalised lecture and I provided you a perfectly fine and complete explanation
06:20:02 <quchen> That's like calling "1" a detail.
06:20:39 <adnap> You're right. The details are the representations of those numbers.
06:21:16 <arnsholt> No, the details are all the horrible things that can happen if you use floating point numbers incorrectly
06:21:21 <arnsholt> Much are manifold and variegated
06:21:32 <adnap> What does that have to do with the format?
06:21:33 <tulcod> adnap: out of interest, what are you using floats for?
06:21:35 <arnsholt> s/Much/Which/ # No idea how that typo happened...
06:21:38 * merijn sighs
06:21:45 <adnap> tulcod: Physics simulation
06:22:00 <merijn> I'm done with this discussion
06:22:29 <tulcod> adnap: then i'm pretty sure you'll want to read up on the details of rounding errors of floating point
06:22:40 <adnap> tulcod: Okay
06:22:55 <merijn> ...
06:23:01 <adnap> merijn: Don't pout. :/
06:23:01 <tulcod> adnap: unless you're going for a "if it works it works" approach, which for some simple projects might be sufficient
06:23:30 <tulcod> or rather, simple physics simulations
06:23:43 <adnap> tulcod: No, I want everything to be "airtight"
06:23:56 <tulcod> adnap: then you will definitely want to read a book about it
06:24:17 <quchen> > 0.1 + 0.2 -- airtight!
06:24:18 <lambdabot>   0.30000000000000004
06:24:43 <tulcod> adnap: from a mathematical perspective, you are numerically solving a differential equation... there are tons of theories about how to do that with minimal error
06:24:51 <adnap> I feel like I am being picked on.
06:25:22 <adnap> I am currently using RK4 and I know about the concept of roundoff error
06:25:58 <tulcod> adnap: knowing the concept isn't quite sufficient. you need to e.g. know if RK4 is stable for your DE
06:26:11 <tulcod> adnap: additionally, the order in which you add and multiply floats matters... sometimes a lot
06:26:57 <adnap> tulcod: In a simulation where the values are unknown ahead of time, I can't do much I think
06:27:19 <tulcod> adnap: the fact that you think that tells me that you need to read a book about it
06:27:56 <adnap> I'm going to read what merijn linked.
06:28:05 <tulcod> that's a good start, but far from sufficient
06:28:26 <adnap> Stop telling me to "read a book" over and over unless you're going to make a suggestion
06:28:30 <quchen> adnap: Sorry, that was not my intention. Just notice that things as simple as addition can have unexpected results using floats.
06:29:08 <adnap> quchen: Yeah, I'm familar with that
06:29:10 <tulcod> adnap: search for "numerical analysis" books. i don't know which is the best because i read dutch lecture notes
06:29:32 <adnap> tulcod: I have read one before. I have a Numerical Analysis textbook
06:29:49 <adnap> I will consider rereading it
06:35:01 <navaati> hi guys
06:35:33 <Krakarn> hello
06:38:13 * hackagebot float-binstring 0.1 - C99 printf "%a" style formatting and parsing  http://hackage.haskell.org/package/float-binstring-0.1 (AntonNikishaev)
06:38:59 <merijn> ok, I have "Map Int [a]" and I want to basically have a zip that, for every key, take the first element from the list and concatenate that. If the list is empty it should use a default element, repeat until all lists are empty
06:39:26 <merijn> Any recommendations on how to do this best?
06:40:24 <startling> merijn: what do you mean "take the first element from the list and concatenate that"? concatenate it to what?
06:40:29 <t7> doesnt map have fold?
06:40:38 <startling> t7, yeah.
06:40:47 <merijn> t7: Yes, but I would need to repeatedly do it
06:41:44 <quchen> merijn: You're basically looking to transpose your `Map a [b]`. Does sequenceA do the right thing maybe?
06:41:56 <merijn> startling: Suppose if have "fromList [(1, [a,b,c]), (2,[d,e,f]), (3, [g,h])]" I want to get "[[a,d,g], [b,e,h], [c,f, x]]" where x is the default element
06:42:38 <t7> transpose . values
06:43:13 <navaati> merijin, i'd say it's a fold of a fold, but don't ask me to think more :)
06:43:41 <merijn> t7: Doesn't transpose cut all lists short?
06:43:46 <t7> yeah
06:43:52 <merijn> No good then
06:45:32 <quchen> "Cut lists short"?
06:45:34 <quchen> > transpose [[1,2],[3]]
06:45:35 <lambdabot>   [[1,3],[2]]
06:46:16 <tikhon> @src transpose
06:46:16 <lambdabot> transpose []             = []
06:46:16 <lambdabot> transpose ([]   : xss)   = transpose xss
06:46:16 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:46:42 <merijn> > transpose [[1,2,3], [4,5], [6]]
06:46:43 <lambdabot>   [[1,4,6],[2,5],[3]]
06:46:49 <merijn> hmm
06:46:51 <merijn> That might work
06:47:15 <b2coutts> yeah, you could start by mapping something over the keys to put default values where needed
06:47:15 <merijn> > transpose [[1,2,3], [4,5], [6], [7,8,9]]
06:47:16 <lambdabot>   [[1,4,6,7],[2,5,8],[3,9]]
06:47:32 <tikhon> > transpose [[],[],[],[]]
06:47:33 <lambdabot>   []
06:47:57 <merijn> Actually, no
06:48:09 <merijn> That won't work, I won't know where to insert the default elements
06:48:23 <b2coutts> yeah but if you insert them before transposing
06:48:32 <merijn> True
06:48:48 <nooodl> merijn: you want all lists to be padded with default elements until they're as long as the longest list, right?
06:48:56 <startling> transpose . values . fmap (++ repeat x)
06:49:03 <merijn> startling: Nope
06:49:10 <merijn> repeat will make all of them infinite
06:49:38 <t7> yeah you need   maximum (map length)
06:49:45 <startling> right
06:50:08 <merijn> ok, I can see no matter how, this is going to suck, so better get coding
06:50:28 <mbrock> a straightforward programming problem as they say
06:50:29 <startling> :D
06:50:32 <b2coutts> you could do takeWhile (any (/= x)) . transpose ...
06:50:39 <alexander__b> I'm trying to write an rpn calculator but my haskell newbness is shining through
06:50:59 <alexander__b> I have everything working in my last commit, but now I wanna use pretty printing of trees, so I need to convert to using trees. here's my current code: http://bpaste.net/show/hdQFUk4ycN4j3NbJMysk/
06:51:00 <mbrock> merijn: might be helpful: map snd . Data.Map.toAscList
06:51:10 <alexander__b> the problem is that... solve and the *Op functions need drastic changing.
06:51:39 <alexander__b> I'm not even sure what. all I know is that when invoked with "2 2 + 5 -" I want to print a pretty tree of the operation going on in addition to the answer
06:51:55 <b2coutts> @let mermap = fromList [(a,[1,2,3]),(b,[4]),(c,[5,6,7,8])]
06:51:56 <lambdabot>  .L.hs:143:10:
06:51:56 <lambdabot>      Not in scope: `fromList'
06:51:56 <lambdabot>      Perhaps you meant one of th...
06:52:00 <alexander__b> so I need to somehow construct a tree to represent this neatly
06:52:04 <b2coutts> @let mermap = Map.fromList [(a,[1,2,3]),(b,[4]),(c,[5,6,7,8])]
06:52:04 <lambdabot>  .L.hs:143:10:
06:52:05 <lambdabot>      Not in scope: `Map.fromList'
06:52:05 <lambdabot>      Perhaps you meant one o...
06:52:08 <b2coutts> eh screw it
06:52:23 <mbrock> alexander__b: the same kind of fold you use for solving should be able to construct a tree
06:52:51 <alexander__b> right now what's going on is if I start it with "2 2 +" it does lookup + ops, finds binOp (+), does binOp (+) 2 2, which returns (+) 2 2 which returns 4, and so in my foldl I'll get [4] and I map print to [4].
06:53:12 <alexander__b> (actually in that code putStrLn . drawVerticalTreeWith, but that doesn't work in the current version)
06:53:21 <alexander__b> mbrock: yes I'm just a bit at a loss to how/what to do
06:53:34 <alexander__b> I think I need to "just modify" solve quite a bit
06:53:51 <alexander__b> my other thought was add a new function that does solve, but also keeps history...
06:54:05 <mbrock> alexander__b: perhaps you can use an algebraic data type instead of (*), (+) and so on
06:54:12 <b2coutts> this is how I'd do it; add a parameter to solve which is a binary tree
06:54:20 <alexander__b> and make Solution [Double, Tree String], where Double will be the solution (-1) and Tree String will be a tree of the history (2 2 + 5 -)
06:54:31 <b2coutts> alternatively you could maybe use the Writer monad
06:54:41 <b2coutts> but the rpn chapter in lyah is before monads so maybe not
06:55:01 <mbrock> alexander__b: then binOp would know not only which function to apply, but also have a description of which operation was performed
06:55:37 <alexander__b> b2coutts: I have read it in its entirety a couple of times but am having trouble groking the more advanced things. I certainly don't know Writer... so I thought maybe try to keep those things to a minimum, and then later try to read up and make my program more idiomatic and pretty and so on.
06:56:05 <alexander__b> mbrock: I don't understand what you mean by "use an algebraic data type", sorry.
06:56:09 <b2coutts> alexander__b: whatever works for you; this could also be an opportunity to try to wrap your head around Writer/monads in general
06:56:35 <alexander__b> mbrock: but your latter post sounds like something I'd like to achieve
06:57:04 <alexander__b> b2coutts: I'd like to not learn them right now. i.e. achieve my desired functionality for my program. THEN I want to try to grok Writer/monads more properly, if that makes sense.
06:57:15 <mbrock> alexander__b: as in data Operation = OpTimes | OpPlus | ..., though I guess the string representation you already have might be sufficient
06:58:02 <alexander__b> oh, like that... I was thinking once I got my functionality in place I could do class op, which has a "member" (don't remember haskell terminology for this) called 'arity'.
06:58:45 <b2coutts> alexander__b: fair enough
06:58:51 <alexander__b> but right now I'm just trying to figure out the easiest/least difficult way to make this tree business actually work.
06:59:08 <b2coutts> sometimes doing so requires you to substantially refactor your program, but that doesn't mean this isn't a good way to learn haskell
06:59:41 <alexander__b> b2coutts: my thoughts was in fact that the substantial refactoring would be a great way to learn it.
06:59:46 <alexander__b> s/was/were
07:00:48 <alexander__b> mbrock: OK so you would make the *Op functions return "history" in addition to result?
07:01:22 <mbrock> alexander__b: that was my first thought, to record the history in the place where you currently perform the computation, but I haven't really thought it through
07:01:25 <alexander__b> and this history would be... a Tree String, which could be a Node in the final tree I'll print at the end of the program? if I'm following you.
07:01:55 <mbrock> alexander__b: it might even be easier to just construct the tree first, and then define evaluate :: Tree -> Number
07:02:03 <alexander__b> mbrock: myself I was thinking either that, or make a function that does solve and returns both the history and the solution.
07:02:55 <alexander__b> do you mean construct the tree, then have a function that takes the tree and solves the equation and returns the solution, then at the end print the tree and the solution?
07:02:55 <b2coutts> alexander__b: unrelated: there are fun things you can do to extend your RPN calculator when you're done
07:03:06 <alexander__b> b2coutts: please don't. :-P
07:03:07 <b2coutts> i.e., add the if function to it
07:03:11 <b2coutts> haha
07:03:45 <b2coutts> indeed, you could extend it to a turing-complete language!
07:03:46 <mbrock> yeah, exactly.  so the first step is a kind of parse step, and the second step is a natural recursive evaluation thing
07:04:09 <alexander__b> b2coutts: I have had a lot of suggestions, and I have a lot of them of my own. if I can get pretty printing done, I'm satisfied with the functionality of clac 1.0. then refactor to grok monads. then make it replace Java as an industry standard. :-P
07:04:24 <b2coutts> haha
07:04:26 <b2coutts> one step at a time
07:04:40 <alexander__b> mbrock: OK so 1. parse input to make a tree. 2. try to solve tree. 3. print solution (or error) and tree.
07:05:14 <alexander__b> mbrock: thanks for the feedback. you've given me some things to consider while I now go eat dinner. :-)
07:05:16 <b2coutts> remember: the way to make haskell the industry standard is to stubbornly refuse to program in any other language and get others to do the same :P
07:05:30 <mbrock> alexander__b: alright, good luck and enjoy :)
07:05:40 <dmwit> alexander__b: I think that's a grand plan, but find it kind of funny because the whole reason postfix notation was invented was so that parsing was unnecessary.
07:06:15 <b2coutts> heh
07:06:28 <b2coutts> maybe he'll end up extending it to a scheme interpreter :P
07:06:40 <dmwit> (Depending on where you draw the line between parsing and lexing, I guess.)
07:07:47 <mbrock> I feel slightly curious about how lazy evaluation would affect the parse function
07:08:04 <b2coutts> how do you mean?
07:08:29 <b2coutts> the parse function itself should just be a String -> String function, with the IO handled elsewhere
07:08:35 <b2coutts> er
07:08:39 <b2coutts> a String -> Something function
07:09:19 <dmwit> mbrock: The easiest way to write a parser is strict: it must parse the entire text before it knows whether to return a "didn't parse" or "did parse" constructor.
07:09:57 <mbrock> that makes sense
07:10:18 <b2coutts> interesting; I wrote my parser differently
07:10:39 <dmwit> Well, for this specific task maybe not the easiest way.
07:10:49 <b2coutts> in that it just takes a String, tries to pry something off the beginning, and append it to the result of parsing the rest of the string
07:10:53 <dmwit> Let's say "parser generators like Parsec" instead, so that it's a more precise claim.
07:11:40 <mbrock> even if the parser were somehow lazy, say you do something like (evaluate . leftBranch . parse), you can't avoid parsing the whole string, right? :)
07:12:01 <b2coutts> not sure what leftBranch there does
07:12:01 <dmwit> I think b2coutts is proposing pushing the errors into the AST.
07:12:15 <dmwit> e.g. each part of the "tree" (actually a list in this case) can contain an error.
07:12:16 <b2coutts> nah, I just use error in the parser itself
07:12:40 <dmwit> b2coutts: Whether you use "error" or "Nothing" isn't really relevant to the discussion of laziness, I think.
07:12:46 <danharaj> can someone tell me how to read this new cabal error?
07:12:47 <danharaj> http://lpaste.net/91812
07:12:53 <b2coutts> I mean, I use the haskell error function
07:13:04 <dmwit> b2coutts: I know what you mean, and my reply stands.
07:13:06 <mbrock> given "1 2 + 3 *" I only really want to evaluate 1 + 2, but of course the root of the tree is the end of the string, so as usual my curiosity leads nowhere
07:13:16 <b2coutts> well, if it just appends-
07:13:33 <b2coutts> oh, I see, I thought you meant appending Nothing to the result of the rest of the parse
07:13:42 <dcoutts> danharaj: backend requires template-haskell==2.8.*
07:13:51 <b2coutts> as opposed to just returning Nothing and not recursive any further
07:13:51 <dmwit> b2coutts: The difference between [a] with undefineds in and [Maybe a] is not so big in the context of our current discussion.
07:13:57 <dmwit> right
07:14:12 <b2coutts> dmwit: you mean Maybe [a]?
07:14:13 <dcoutts> danharaj: and you also need the ghc package, but ghc needs template-haskell==2.9.0.0 (the existing installed instance)
07:14:18 <dmwit> b2coutts: I don't mean that.
07:14:31 <danharaj> dcoutts: ah ok, so the left side of => is what demands a constraint and the right side is the constraint.
07:14:39 <dcoutts> danharaj: yes
07:14:55 <dmwit> b2coutts: Maybe [a] is exactly the kind of thing I was talking about before. It has to be strict, because it can't announce "Nothing" or "Just" until it's completely finished with the parse.
07:14:56 <danharaj> dcoutts: thanks. it is quite a nice format actually.
07:14:58 <banister> damnit, this http://en.wikibooks.org/wiki/Haskell/Arrows   cut off just as it wsa getting interesting
07:15:01 <chrisdone> dcoutts: what was that editor you use?
07:15:07 <banister> anyone want to continue on from where it left off? :P
07:15:10 <dcoutts> chrisdone: hmm?
07:15:13 <b2coutts> dmwit: my parser would announce that there is an error before finishing the parse
07:15:21 <dcoutts> danharaj: most people think it's incomprehensible :-)
07:15:23 * dmwit sighs
07:15:25 <chrisdone> dcoutts: it's something that looks similar to emacs, but not
07:15:33 <b2coutts> so if the string given to the program began with a &, it would throw an error and stop before looking any further
07:15:47 <enthropy> banister: have you read the ghc manual section on arrows?
07:16:06 <banister> enthropy: no, i figured that would be much too tough for me, i liked the slow pacing of this article
07:16:12 <dmwit> b2coutts: Yes, but that particular claim is irrelevant. What's more interesting is that if the program began with "2 &", your plan would return a "2", and *then* error. That is what makes it lazy.
07:16:33 <dmwit> b2coutts: I understand your plan, and am trying to make a concise description of the difference between your plan and the standard, e.g., Parsec plan.
07:17:20 <chrisdone> dcoutts: don't you use an obscure editing environment for hacking?
07:17:21 <b2coutts> oh, sure
07:17:25 <dmwit> b2coutts: And what I'm claiming is that whether it errors out by using the "error" function or by returning an element of the list whose label is "Nothing" isn't really an interesting part of the difference between the two plans.
07:17:29 <Peaker> the Mio thing seems like awesome progress. was it commonly known that GHC scales poorly on many cores? GHC's scalability was repeatedly emphasized, so I had assumed it scales well
07:17:56 <dcoutts> Peaker: this was specifically IO, not scaling cpu intensive things
07:18:08 <dcoutts> chrisdone: nothing special
07:18:22 <Peaker> dcoutts, ok, but was it common knowledge that GHC scales poorly in the IO case?
07:18:29 <enthropy> banister: the approach there is that arrows are ugly to work with, so there is a notation that translates into the >>> and *** etc.
07:18:40 <b2coutts> dmwit: ok, right, I understand what you were trying to describe now
07:19:07 <Peaker> dcoutts, on the one hand, progress is awesome.  OTOH, I find it a bit discouraging that until now, GHC had such awful single-mutex serialization-of-everything...  What else is extremely suboptimal in there?
07:19:11 <danharaj> I am not a fan of upper bounds on constraints in packages.
07:19:21 <dcoutts> Peaker: yes, for very high levels of I/O activity, so in practice it only affects network services doing lots and lots of small I/O and not much cpu time
07:19:52 <dcoutts> Peaker: it was only a mutex on I/O submission
07:20:14 <dcoutts> so not as if it serialised all I/O
07:20:15 <tikhon> of course, network services seem to be getting more and more important for Haskell
07:20:41 <Peaker> dcoutts, and on the scheduling of haskell threads on capabilities
07:20:59 <Peaker> (or rather, scheduling was done only in one core)
07:25:30 <danharaj> ok seriously
07:25:33 <danharaj> I HATE upper bounds.
07:27:05 <quchen> Bounds should be fuzzier. Something like "known to work from … to", "known not to work above/below …" would be nice.
07:27:12 <danharaj> yeah
07:27:18 <applicat1ve> cabal install --scrap-upper-bounds pony
07:27:24 <danharaj> wait is that a thing
07:27:28 <applicat1ve> haha
07:27:50 <applicat1ve> i have a suspicion that's a patch they wouldn't accept
07:28:03 <danharaj> cabal install --fuck-the-police
07:28:21 <maurer> I would absolutely love that flag
07:28:30 <maurer> The number of times that I have to download a package
07:28:32 <maurer> then remove the upper bound
07:28:35 <maurer> bump the version number
07:28:37 <maurer> and install it
07:28:39 <maurer> is too damn high
07:28:51 <danharaj> dcoutts: what is your opinion on the matter :P
07:29:09 <donri> i sort of would like --constraint to allow going outside constraints in build-depends
07:29:54 <chrisdone> Peaker: if anything it makes me more inclined to dig more into the internals of ghc
07:29:55 <applicat1ve> oh interesting, that's a different way of thinking about it
07:30:33 <applicat1ve> --constraint<∞
07:31:24 <mbrock> cabal install --just-make-sure-it-type-checks
07:31:35 <quchen> cabal install --make-sure-it-halts
07:31:35 <donri> thing about upper bounds is that you don't notice when they *help*, so most people think they're just in the way
07:31:59 <dcoutts> Peaker: no, scheduling is done on each core
07:33:49 <danharaj> donri: imo if a package on hackage doesn't build with the latest versions of its dependencies, that's a bug.
07:34:12 <donri> alternatively you could say, the problem often isn't that package X has an upper bound on dependency Y, it's that another package Z has a *lower* bound on the same dependency Y
07:34:20 <Peaker> dcoutts, there was something in the Mio paper about scheduling also being a bottleneck on one core or such (unless I misunderstood)
07:34:47 <quchen> The mailing list is awkward sometimes. You'd think we've run out of synonyms for "crash" in the Haskell libraries, and now someone proposes ExceptT.
07:35:08 <dcoutts> Peaker: I don't think they said scheduling
07:35:18 <dcoutts> there was another thing though yes
07:35:34 <dcoutts> they did mention pinned allocations
07:35:39 <Peaker> chrisdone, my one digging into ghc internals -- was when jdh trolled about poor IntMap/hash performance in Haskell.. So I wrote a C hash table, and had to use GHC StablePtrs to interface to it.  StablePtr was *extremely* slow.   I patched GHC RTS to get 3 times better performance from StablePtrs, and my hash table beat all the other mapping structures (including the jdh one in F#, heh)
07:36:10 <mbrock> quchen: kind of an exception that proves the rule, groan
07:36:10 <alexander__b> dmwit: the irony was not lost on me when I laid this plan. however when I design software I think about the user, not the developer/myself. the user still doesn't have to parse anything. ;-) besides, as I learn more haskell I can probably make the code/implementation better.
07:36:13 <Peaker> I think the RTS hash table implementation is pretty poor compared to my hash table, too,   one day maybe I shall try to replace it
07:36:32 <quchen> mbrock: Exceptions prove the existence of a rule, not the rule itself.
07:36:36 * chrisdone golf claps Peaker =p
07:36:39 <dcoutts> Peaker: that'd be good
07:36:55 <Peaker> dcoutts, the dispatcher thread is what they were talking about
07:36:55 <hiptobecubic> chrisdone, :D
07:37:00 <danharaj> edwardk: tagged failed to install with GHC head. :3
07:37:11 <donri> danharaj: i don't know what to say to that. you seem to either be suggesting that packages should never break backwards compatibility or that everyone needs to instantly port their packages to every new version of every recursive dependency, non-stop.
07:37:27 <Peaker> chrisdone, heh :)
07:37:41 <danharaj> donri: I try to rely on maintainers who keep on top of things :P
07:37:51 <chrisdone> Peaker: i guess that's the win of many eyeballs on a compiler. if you're just staring at a hash table implementation you can really make it good, but if you're looking at a forest you just want something that works. i bet there's a bunch of fruit like that
07:38:21 <dmwit> alexander__b: I like your attitude.
07:38:39 <Peaker> dcoutts, though I'm not sure I understood what the dispatcher thread is exactly, and how it was a bottleneck
07:38:44 <dmwit> alexander__b++
07:39:08 <Peaker> chrisdone, I think the RTS needs more intrusive data structures (virtually all C code in the world does).  Also less locks, more distributing stuff locklessly between cores
07:39:13 <alexander__b> dmwit:     parse error (possibly incorrect indentation or mismatched brackets)
07:39:27 <quchen> ^ needs code
07:39:49 <mbrock> alexander__b: btw, it might also be interesting to investigate making your own instance of Num
07:39:56 <mbrock> alexander__b: that's a fun way to do symbolic computation
07:40:20 <alexander__b> mbrock: I had someone told me that I shouldn't do Double. to which I said "uggggggh" and put it on my TODO list. :-P
07:40:22 <dmwit> =)
07:40:49 <mbrock> alexander__b: with a symbolic implementation of Num, you could just reuse your solve function without modification :)
07:41:02 <alexander__b> mbrock: ohhh that is a fair point
07:41:27 <donri> danharaj: do you honestly need every little package to be the absolutely latest version? plus hackage is about as stable as installing from HEAD ...
07:42:00 <danharaj> donri: No I don't, but I need them all to at least build with the latest versions of packages like base.
07:42:43 <danharaj> and most packages have upper bounds on such packages for no reason: they build with the upper bound incremented. that wastes my time.
07:42:48 <donri> danharaj: core packages are quite a different story
07:43:07 <chrisdone> .hs → harlem shake file
07:43:52 <quchen> I'm going to slowly fill up my autoreplace DB with stuff #haskell posts. λ
07:43:55 <donri> i think *any* bounds on core packages is mostly pointless because shit will break even if you do install a different version. it's mostly useful for saying "you need this ghc version to build me"
07:44:04 <chrisdone> Peaker: haven't looked in there yet. i'm tempted, but trying to restrain myself in the interest of health. i know as soon as i build ghc from source and open up the code, i'll start changing all sorts of stuff
07:44:13 <mbrock> alexander__b: er, I mean Floating, not Num :)
07:44:18 <chrisdone> Peaker: atm i read it on github from a distance =p
07:44:25 <danharaj> donri: right. it probably should also extend to very basic packages like containers.
07:44:29 <mbrock> alexander__b: you can even overload pi!
07:45:49 <donri> danharaj: i would say it's a problem if a package doesn't build on the latest haskell-platform... i wouldn't say "bug" though but ok :p
07:46:00 <donri> that includes lower bounds though
07:46:05 <danharaj> I don't use the haskell-platform.
07:46:09 <danharaj> It does not update fast enough.
07:46:22 <danharaj> often, rather
07:46:28 <donri> it's a useful "standard"
07:47:27 <Peaker> chrisdone, It's terrible to build&work on, unfortunately.  a bunch of silly scripts that have to be run in the right order (or else you get undescriptive failures later), manual files to copy&edit, ...
07:47:49 <Peaker> chrisdone, and it takes ages, and you can't trust it to rebuild what's necessary, IME, requiring too much cleaning to be done, on a slow-to-begin-with system
07:48:04 <danharaj> honestly it's only useful on windows because it is hell to install anything on windows
07:48:16 <Peaker> I think one of the best possible contributions to ghc is streamlining its build system and CLI to be sane
07:53:01 <chrisdone> Peaker: sounds pretty sucky
07:53:18 <applicat1ve> chrisdone: ghc hacking is childs play.  http://sprunge.us/NaXe What more do you want?
07:53:18 <Peaker> chrisdone, yeah, but it is well documented, at least
07:53:41 <applicat1ve> chrisdone: i learned *all* about it from lispy's tutorial
07:54:55 <applicat1ve> maybe i should change that to haskell2010; back in half an hour ;)
07:57:47 <alexander__b> BTW any of you used that haskell school/tutorial things on fpcomplete?
07:58:12 <alexander__b> I heard a lot of people complain that it was terrible, but I glossed over it at the airport because I only had my phone up and was bored, and honestly it looked pretty nice.
07:58:12 <edwardk>  danharaj: there has been some thrashing on Data.Proxy being in base and having all the instances. the goal was to make tagged detect ghc 7.7 and disable the export of Data.Proxy
07:58:56 <edwardk> danharaj: you just caught us in the window between them adding it and us removing it =)  if you wanted to patch up the cabal file to not export Proxy i'd take the patch
08:01:15 <banister> alexander__b: a lot of the fpcomplete tutorials seem to be written by people who dont have english as a first language
08:01:22 <banister> alexander__b: as a result they're kind of weird...
08:02:03 <banister> but not bad, i've read better ones though, the 'adit' guy has some great content complete with diagrams
08:02:03 <tikhon> I think the idea of making interactive tutorials is neat, but I'm convinced the current implementation realizes the advantages very well
08:03:22 <tikhon> I would love to see it turn into something like a comprehensive codecademy-style site for Haskell
08:04:27 <alexander__b> banister: I only glanced at them. they were OK for "consumption" at the airport. :-)
08:04:48 <alexander__b> very bad organisation (or rather, lack thereof) though.
08:05:07 <lispy> applicat1ve: heh
08:05:21 <lispy> applicat1ve: Actually, I agree with Peaker about the ghc build system :)
08:06:10 <applicat1ve> lispy: well, yeah, i'm still waiting to see if my revision for 'haskell 2010' type checks...
08:06:35 <lispy> hehe
08:06:36 <Guest68184> How does one get their package on new Hackage?
08:07:36 <lispy> Fuuzetsu: does this page work for you? http://new-hackage.haskell.org/packages/upload
08:07:56 <lispy> Fuuzetsu: note: I haven't tried to upload to new-hackage, so I don't know if it *should* work
08:08:04 <lispy> if it doesn't work, what error do you get?
08:08:20 * hackagebot clientsession 0.9.0.2 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.0.2 (MichaelSnoyman)
08:08:22 * hackagebot doccheck 0.1.0.0 - Checks Haddock comments for pitfalls and version changes.  http://hackage.haskell.org/package/doccheck-0.1.0.0 (MateuszKowalczyk)
08:08:28 <applicat1ve> well lispy I did it, patched my patch http://sprunge.us/BSbe
08:09:01 <lispy> applicat1ve: cool. That actually seems like a reasonable bug fix given the change in standard
08:09:10 <applicat1ve> now I just need to add like blinking lights for **Haskell 2010**
08:09:29 <alexander__b> mbrock: this might be a stupid question but is there a nice one-liner I could do to build the tree?
08:10:08 <alexander__b> I use "(>>= words) <$> getArgs" to get the input, so I guess I need to... add something there to make it a tree
08:11:12 <alexander__b> mbrock: if you remember the source I do equation <- getInput; case equation of [] -> printHelp; _ -> mapM_ (putStrLn . drawVerticalTreeWith 3) $ solve equation
08:11:33 <alexander__b> so I want to add a "asTree" or "buildTree" or something, so solve (asTree equation).
08:11:35 <Fuuzetsu> lispy: it just rejects my login details
08:11:44 <alexander__b> I think. maybe. oh I don't know. :-D
08:11:46 <Fuuzetsu> whereas I managed to use these with old hackage just fine
08:12:51 <lispy> Fuuzetsu: ask in #hackage?
08:13:03 <Fuuzetsu> alright
08:13:55 <mbrock> alexander__b: if you changed all the (*) and (+) etc in the definition of ops into constructors of a data type, e.g. OpMultiply, then I think your "solve" function would magically become a tree-building function
08:14:11 <alexander__b> mbrock: that's my other route option
08:14:24 <alexander__b> mbrock: I'm not sure how to... start that though
08:14:29 <Fuuzetsu> well, I guess ‘Note: we are mirroring packages from the old server (currently every 30min) so it is suitable to use as your main hackage server’ will do it
08:15:10 <bergmark> mbrock: .o/
08:15:19 <mbrock> bergmark: hello! :)
08:17:23 <mbrock> alexander__b: maybe if you start with a data AST = Number Float | OpTimes AST AST | ..., then change numberP to return an AST, then hack until it typechecks, haha :P
08:18:48 <mbrock> I gotta go but it should be potentially straightforward
08:18:57 <mbrock> :P
08:19:44 <lispy> Fuuzetsu: Ah, yes it does mirror (or it should). So maybe they intentionally disabled uploading to new-hackage
08:20:23 <Fuuzetsu> Well, I was advised to just sit tight and it will eventually be up so I'll do just that.
08:28:25 <udevd> does anyone know tutorial to bed-and-breakfast (linear algebra library)
08:28:38 <udevd> google shows me things like > Bed breakfast inns in Haskell, TX - Yellowpages.com
08:28:42 <udevd> xD
08:30:33 <alexander__b> hm. what's a sane way to do this: print a and f a? to be more specific, I have output . solve . parse $ input, but really I want to send two things to output -- both the result of parse input, and the result of solve (parse input).
08:30:43 <exicer> I don't understand (+) <$> (+3) <*> (*100) $ 5
08:30:45 <alexander__b> what's the briefest way of achieving that?
08:30:53 <exicer> Could someone explain ?
08:32:01 <donri> > (+) <$> (+a) <*> (*b) $ c
08:32:02 <lambdabot>   c + a + c * b
08:32:32 <udevd> alexander__b: output (parsed)+how you want to concat it+(solved) where parsed= parse input
08:32:42 <donri> > (-) <$> (+a) <*> (*b) $ c
08:32:43 <lambdabot>   c + a - c * b
08:32:55 <alexander__b> udevd: using "where" is what I'm currently doing
08:33:00 <chrisdone> valid perl code
08:33:09 <donri> :)
08:33:11 <alexander__b> udevd: I was just wondering if haskell had some mind blowing syntax sugar to do it even more briefly
08:33:11 <exicer> > (+a) <*> (*b) $ c
08:33:12 <lambdabot>   Couldn't match type `Debug.SimpleReflect.Expr.Expr'
08:33:13 <lambdabot>                with `De...
08:33:14 <int-e> > (+) <$> [1,2] <*> [10,20]
08:33:15 <lambdabot>   [11,21,12,22]
08:33:21 <exicer> Why is that not valid ?
08:33:29 <dmwit> alexander__b: print (a, f a) -- ?
08:33:41 <ParahSailin> @ty (<*>)
08:33:41 <int-e> @type (<*>)
08:33:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:33:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:33:43 <udevd> > "do i have rights to do so?"
08:33:44 <lambdabot>   "do i have rights to do so?"
08:33:46 <udevd> :3
08:33:58 <donri> > (+) <*> (*b) $ c
08:33:59 <lambdabot>   c + c * b
08:34:01 <int-e> exicer: our 'f' here is  f a = r -> a  for some r.
08:34:11 <alexander__b> dmwit: yes but in practice that's not an option if f and a are really really long to type and are chains of several functions. :-P
08:34:28 <dmwit> alexander__b: let a = long; f = long in print (a, f a)
08:34:32 <exicer> Ahh
08:34:39 <int-e> exicer: and  (f <*> g) r = f r (g r).
08:34:45 <alexander__b> dmwit: yes let and where is what I know of
08:34:51 <tromp_> what is the name of the ((->) r) monad?
08:34:53 <dmwit> Okay, then what's the problem? =)
08:34:55 <exicer> int-e: Okay, cool
08:34:56 <int-e> (and (f <$> g) r = f (g r))
08:35:05 <dmwit> tromp_: reader
08:35:06 <alexander__b> dmwit: I was just wondering if you cloud syntax sugar and then ZOMG WHAT HAPPENED and then it works. I find that is the case sometimes in haskell. :-P
08:35:09 <donri> exicer: you need a function inside a functor. function itself is the functor here, so we need a (a -> (b -> c)) and (+3) is the wrong type
08:35:11 <alexander__b> s/cloud/could
08:35:12 <int-e> tromp_: reader
08:35:22 <dmwit> alexander__b: Well, there's always
08:35:27 <dmwit> ?pl \f a -> print (a, f a)
08:35:28 <lambdabot> (print .) . ap (,)
08:35:32 <dmwit> alexander__b: =)
08:35:45 <alexander__b> ehh
08:35:47 <mbrock> or some arrow combonator
08:35:48 <alexander__b> yes... like that...
08:35:49 <dmwit> :t (print .) . (id &&& f)
08:35:50 <lambdabot>     Couldn't match type `(a1, c'0)' with `a0 -> b0'
08:35:50 <lambdabot>     Expected type: a1 -> a0 -> b0
08:35:50 <lambdabot>       Actual type: a1 -> (a1, c'0)
08:36:07 <dmwit> :t \f -> print . (id &&& f)
08:36:08 <lambdabot> (Show a, Show c') => (a -> c') -> a -> IO ()
08:36:09 <ParahSailin> @src (->) (<*>)
08:36:09 <lambdabot> (<*>) f g x = f x (g x)
08:36:35 <mbrock> yrah that one :)
08:36:39 <ParahSailin> @src (->) (<$>)
08:36:39 <lambdabot> Source not found. I am sorry.
08:36:42 <dmwit> :t (print .) . (id &&&)
08:36:43 <lambdabot> (Show a, Show c') => (a -> c') -> a -> IO ()
08:36:48 <dmwit> alexander__b: :3
08:36:49 <tromp_> i can see Reader r being equivalent, but not identical to ((->) r)
08:36:59 <alexander__b> dmwit: :3
08:37:00 <int-e> @src (->) fmap
08:37:00 <lambdabot> fmap = (.)
08:37:03 <dmwit> tromp_: right
08:37:23 <dmwit> tromp_: That's why I called it the "reader" monad, not the "Reader" monad. ;-)
08:37:30 <tromp_> so there's no good name for  ((->) r) to distinguish it?!
08:37:37 <int-e> tromp_: they are isomorphic; it's the same monad. :)
08:37:46 <dmwit> Not really. People use lots of names like "function monad", "environment monad", "reader monad".
08:38:22 <dmwit> (Without knowing what naturally isomorphic really means, I bet they're even that!)
08:38:56 <Adeon> mo-nad
08:39:10 <dmwit> monads, moproblems
08:39:20 <ludamad> dmwit, haha
08:39:38 <Adeon> I've thought how exactly I should pronounce monad if I ever talk about them to someone
08:39:45 <Adeon> perhaps I should unnaturally emphasize the mo part
08:40:08 <int-e> we could call it the pointless monad (--> @pl)
08:40:34 <int-e> @pl \x -> x x
08:40:34 <lambdabot> join id
08:41:13 <udevd> @pl \x _ -> succ x
08:41:13 <lambdabot> const . succ
08:41:27 <udevd> it doesn't work :<
08:41:45 <int-e> udevd: I believe it only becomes monadic when you duplicate arguments
08:41:49 <dmwit> Adeon: Best way I can think of to transmit something aural via IRC is by pointing you at a YouTube video with a pronunciation. Try the catsters videos, for example.
08:41:57 <int-e> @pl \x y -> f y x y x
08:41:58 <lambdabot> flip =<< join . flip f
08:42:34 <kier> @pl \x -> f x x x x x
08:42:34 <lambdabot> join (join (join (join f)))
08:42:40 <dmwit> :t fix return
08:42:40 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = m0 a0
08:42:41 <lambdabot>     Expected type: a0 -> a0
08:42:41 <lambdabot>       Actual type: a0 -> m0 a0
08:42:50 <dmwit> :t fix . return
08:42:51 <lambdabot> a -> a
08:43:08 <dmwit> :t fix <$> return
08:43:08 <lambdabot> a -> a
08:43:20 * hackagebot DeepArrow 0.4.0 - Arrows for "deep application"  http://hackage.haskell.org/package/DeepArrow-0.4.0 (ConalElliott)
08:43:30 <udevd> also, had anyone used linear algebra library in haskell?
08:43:36 <udevd> i could not find any tutorial
08:43:48 <chrisdone> it would be awesome to get notification  from hackage that the package documentation has been built
08:43:50 <ayegill> :t fix
08:43:51 <lambdabot> (a -> a) -> a
08:43:51 <joneshf-laptop> @help
08:43:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:44:09 <chrisdone> because the package isn't worth linking to anyone until the docs are built
08:44:14 <dmwit> udevd: I've used hmatrix a little bit. I found the documentation sufficient.
08:44:28 <udevd> okay, thanks :3
08:46:07 <identity> Google hasn't been much help yet, so I figured I'd ask here: Is there an existing haskell tool/library that generates haskell data types from sql databases?
08:46:28 <chrisdone> haskelldb does
08:46:39 <chrisdone> but, it's its own record system
08:47:55 <leroux> cabal install elm
08:47:59 <leroux> Woops, sorry.
08:48:24 <Zenol> What is "bottom" here : http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#cite_note-1
08:48:26 <identity> chrisdone: I see
08:48:31 <identity> I guess I'll manage without
08:48:39 <tikhon> leroux: playing around with FRP?
08:48:47 <leroux> tikhon: Going to start right now.
08:48:53 <leroux> I remember seeing Elm a few months ago.
08:48:54 <Kaini> @pl \(x, _, _) -> x
08:48:55 <lambdabot> (line 1, column 9):
08:48:55 <lambdabot> unexpected "_"
08:48:55 <lambdabot> ambiguous use of a non associative operator
08:48:55 <tikhon> starting with Elm?
08:48:56 <leroux> But I never tried it.
08:48:58 <tikhon> hmm
08:49:05 <leroux> tikhon: Yes, should I be doing something else?
08:49:09 <Kaini> @pl \(x, y, z) -> x
08:49:10 <lambdabot> (line 1, column 9):
08:49:10 <lambdabot> unexpected "z"
08:49:10 <lambdabot> ambiguous use of a non associative operator
08:49:16 <Zenol> They say "Bool is the set {True, False, ⊥} ".
08:49:19 <tikhon> I don't know—I personally really liked Reactive Banana
08:49:23 <udevd> ...but apparently hmatrix don't want to build
08:49:28 <udevd> :D
08:49:58 <udevd> >Checking foreign libraries... FAIL *** Sorry, I can't link GSL.
08:50:16 <tikhon> Elm seemed too eager to sacrifice nice semantics for implementation reasons, but maybe I'm just biased
08:50:28 <identity> wat @ mac absolute time
08:50:31 <identity> are these guise serious?
08:50:38 <dmwit> udevd: You'll need to install some C libraries. The documentation can tell you which packages to install for the most common Linux distros.
08:50:57 <tikhon> of course, running in the browser is *much* nicer than struggling with Haskell's native GUI toolkits!
08:51:12 <udevd> okay
08:51:14 <Zenol> chrisdone: You can still ask cabal to build the doc from the package if you can wai
08:51:27 <Zenol> t from hackage. Maybe it's usefull to some ones?
08:53:18 <dmwit> Zenol: I'm with chrisdone. Hackage's page is useless until it has the documentation.
08:53:20 * hackagebot haxparse 0.2.0.0 - Readable HaxBall replays  http://hackage.haskell.org/package/haxparse-0.2.0.0 (JoelTaylor)
08:55:12 <Cale> Zenol: _|_ represents nontermination. Because Haskell has general recursion, it does nothing to stop you from writing something that typechecks as Bool but whose computation doesn't terminate. You can also apply the error function to get a value which doesn't terminate (but faster), crashing the program with an error message.
08:55:32 <tikhon> @ty fix id
08:55:33 <lambdabot> a
08:55:48 <Cale> > let x = not x in x
08:55:52 <lambdabot>   mueval-core: Time limit exceeded
08:55:54 <tikhon> vòilà
08:56:03 <quicksilver> Cale: quick nontermination. My favourite kind. If I'm going to wait forever I want to at least move fast.
08:56:17 <Zenol> Cale: Hum, so I don't understand why "[forall a. a]" is a "list of bottom".
08:56:41 <Cale> forall a. a is a type with only one value, which is _|_
08:56:43 <tikhon> because the type forall a. a does not have any values except for ̱⊥
08:57:12 <tikhon> for example, imagine the type data Void which has no constructors
08:57:23 <tikhon> we can't make anything of this type normally
08:57:38 <haasn> [forall a. a] is perhaps not to be confused with [exists a. a] and certainly not forall a. [a]
08:57:40 <Cale> :t let x = x in x
08:57:41 <lambdabot> t
08:58:05 <Cale> Interesting that it doesn't print forall t. t
08:58:13 <haasn> that changed a while ago
08:58:19 <Zenol> 'forall a. [a] is the type of ..'  ... '(and therefore this too is a list of bottoms)'.
08:58:21 * hackagebot reducers 3.0.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0.2 (EdwardKmett)
08:58:41 <haasn> Zenol: “forall a. [a]” has a valid value: []
08:58:42 <Zenol> not really clear.
08:58:52 <udevd> hm
08:58:58 <tikhon> @ty []
08:58:59 <lambdabot> [a]
08:59:05 <dmwit> haasn: [] is a fine value of type [forall a. a], too
08:59:07 <Cale> Zenol: If something could have any type at all, it must be undefined.
08:59:13 <haasn> dmwit: yeah good point
08:59:17 <udevd> what if hmatrix fails to run some tests, can i still use it in simple program?
08:59:19 <tikhon> hmm, lambdabot used to always insert foralls into types
08:59:30 <udevd> it compiled, but hmatrix-test package didn't...
08:59:32 <haasn> tikhon: it's a simple flag in GHCi iirc
08:59:36 <udevd> i must hacke broken lapack or so
08:59:50 <udevd> ...which worked in GEANT, strange
09:00:00 <Cale> :t [undefined, undefined, undefined]
09:00:01 <lambdabot> [t]
09:00:06 <Cale> > length [undefined, undefined, undefined]
09:00:07 <lambdabot>   3
09:00:25 <haasn> :t [] :: [forall a. a]
09:00:26 <Cale> Note: undefined is a prelude definition whose value is semantically _|_
09:00:27 <lambdabot>     Illegal symbol '.' in type
09:00:27 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
09:00:27 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
09:00:30 <haasn> ow
09:00:44 <Cale> I wonder why RankNTypes is off.
09:00:54 <tikhon> I guess lambdabot got somehow reset, or something
09:01:00 <Cale> I blame elliott ;)
09:01:08 <Cale> hehe
09:01:09 <haasn> >
09:01:13 <tikhon> does it have lens imported?
09:01:15 <tikhon> :t lens
09:01:21 <haasn> > length ([] :: [forall a. a])
09:01:22 <lambdabot>   <hint>:1:24:
09:01:22 <lambdabot>      Illegal symbol '.' in type
09:01:22 <lambdabot>      Perhaps you intended -XRa...
09:01:24 <tikhon> @ty lens
09:01:31 <edwardk> actually the one that bugs me is the loss of ImplicitParams
09:01:34 <edwardk> > ?foo 1 2
09:01:35 <lambdabot>   <hint>:1:1: parse error on input `?'
09:01:54 <tikhon> do you ever use ImplicitParams for anything?
09:02:03 <Cale> tikhon: It's useful when asking for the types of things
09:02:08 <haasn> (when the types of implicit params are inferred, can they be inferred to be polymorphic? no, right?)
09:02:12 <Zenol> haasn: Illegal polymorphic or qualified type: forall a. a Perhaps you intended to use -XImpredicativeTypes
09:02:15 <Cale> tikhon: The types of the implicit params will show up in the context
09:02:26 <Cale> like (?foo :: ...) => ...
09:02:30 <tikhon> aha
09:02:34 <edwardk> tikhon: poor man's holes
09:02:41 <dmwit> haasn: How polymorphic?
09:02:44 <tikhon> I've only ever used them to make my testing code less repetitive
09:02:48 <dmwit> Prelude> :t ?x
09:02:48 <tikhon> and was not very happy with it
09:02:48 <dmwit> ?x :: (?x::t) => t
09:02:48 <lambdabot> Maybe you meant: v @ ? .
09:02:56 <dmwit> haasn: Polymorphic enough for you?
09:03:02 <haasn> dmwit: :t (?x (), ?x "foo")
09:03:18 <osa1> is there a way to say "skip n characters" in parseTime's format string?
09:03:20 <dmwit> haasn: Right, not that polymorphic.
09:03:22 <edwardk> and with constraint kinds they form an extensible record system of sorts ;)
09:03:43 <edwardk> Dict (?x :: Int, ?y :: Double)    has named fields x and y
09:03:46 <edwardk> =)
09:03:46 <haasn> dmwit: so in general, nothing is lost by simply using a lambda with the appropriate arguments in the place of implicit params?
09:04:00 <evan_> Silly question: why does 0:1:[] work and 0:1 does not?
09:04:00 <dmwit> haasn: Naming is lost.
09:04:10 <dmwit> evan_: Because 1:[] is a list and 1 isn't.
09:04:18 <Zenol> Hum, I understand what I can do with a forall a. [a], a [forall a . a] , and a [forall a. Show a=> a], but there is something really strange with those explanations about bottom.
09:04:29 <edwardk> evan_:   (:) isn't as symmetric as it looks. it takes a value on the left and a list on the right
09:04:33 <edwardk> 1 isn't a list
09:04:36 <haasn> evan_: (:) prepends a value to a list; in the case of 0:1:[] that's actually 0 : (1 : [])
09:04:37 <edwardk> (1 : []) is a list
09:04:39 <evan_> ahh, I see
09:04:42 <haasn> which is 0 : [1], which is [0,1]
09:04:47 <evan_> thanks
09:05:14 <Zenol> For me, there seams to be something different in the botoms allowed in [forall a . a] and [forall a. Show a => a].
09:05:39 <haasn> Zenol: it actually runs if you enable the extension it suggest :P but either way, that's trivial to resolve by just packing the forall a. away inside a newtype or something
09:06:15 <Cale> There really isn't much difference. forall a. Show a => a  also doesn't have many values.
09:06:23 <Cale> (Specifically, it only has bottom)
09:06:45 <dmwit> [forall a. Num a => a] has more than just bottom, though. =)
09:06:47 <haasn> Zenol: instance Show Void where show _ = "oh no" -- is a valid instance
09:06:52 <dmwit> like [fromInteger 3]
09:07:03 <Cale> Indeed
09:07:26 <ayegill> :t [3]
09:07:27 <lambdabot> Num t => [t]
09:08:07 <Zenol> Hum. Does "have value" are related to the constructor you can match on?
09:08:36 <dmwit> "have value" is a metatheory property.
09:08:37 <haasn> more like the ways you can construct it in the first place
09:08:51 <dmwit> It's about what terms you can write that have that type.
09:08:58 <haasn> (which, of course, is the same as the ways you can match on)
09:09:21 <dmwit> The ways to construct a type and the ways to destruct a type are not at all necessarily connected.
09:09:26 <Zenol> so if something is really a list of bottom, it means I won't be able to put anything else than bottoms in this list.
09:09:28 <dmwit> So I find your "of course" not to be so clear. =)
09:09:37 <dmwit> Zenol: That's the idea.
09:09:39 <haasn> dmwit: s/of course/as we know/ ?
09:09:46 <Zenol> (really means I exclude dwit's Num a :p)
09:09:57 <Zenol> *dmwit.
09:09:59 <dmwit> haasn: I guess I know less than you. =)
09:10:20 <dmwit> haasn: e.g. how do I match (\x -> x)? Not the same way I construct it, for sure.
09:10:33 <Cale> Zenol: Well, you can have lists of other types which just happen to be lists of bottoms
09:10:38 <Cale> For example,
09:10:51 <haasn> dmwit: you're right; I forgot to include functions in my reasoning
09:10:54 <Zenol> [undefined] :: [Int] ?
09:10:59 <Cale> yes
09:12:26 <Zenol> Hum, and in data V = forall a. V a, forall a still means "intersecting the types (if I see a type as a set of value where _|_ is always a memeber)" ?
09:13:04 <haasn> how evil is ImpredictiveTypes either way? ie. using [3,4,5] :: [forall a. Num a => a] -- vs newtype AnyNum = N (forall a. Num a => a); [N 3, N 4, N 5] :: [AnyNum]
09:13:19 <Cale> Zenol: It means unioning if it's outside the data constructor like that
09:13:49 <pseudolio> haasn: It's 'evil' in that the GHC isn't very good at checking it anymore.
09:14:22 <Cale> Zenol: i.e. V :: forall a. a -> V when you write that
09:14:25 <dmwit> I think ImpredicativeTypes aren't really supported any more?
09:14:27 <Zenol> Cale: That's what's puzzling me. Why using the forall keyword for union ? :/
09:14:38 <dmwit> Like, the extension is there but all the special type-checking code was ripped out in the name of simplicity.
09:14:43 <Cale> Zenol: If you write  data W = W (forall a. a)
09:14:47 <Cale> then that's quite different
09:14:49 <haasn> Zenol: think of the ‘forall’ as being on the constructor
09:14:50 <dmwit> Zenol: It's a bad choice of keyword.
09:14:56 <haasn> Zenol: like the signature Cale gave
09:14:57 <Cale> W :: (forall a. a) -> W
09:14:57 <pseudolio> I think if you put enough type annotations on stuff, you can get it to pass the type checker.
09:15:05 <dmwit> Zenol: It was chosen to avoid creating yet another keyword, I think.
09:15:05 <pseudolio> It might be a lot of annotations for some things, though.
09:15:18 <Cale> Well, not only to avoid creating another keyword.
09:15:22 * haasn remembers a good stackoverflow answer on this topic
09:15:26 <Cale> It actually does make sense, because of how it's positioned.
09:15:39 <Zenol> but (forall a. a) should be bottom?
09:15:44 <Zenol> (In W's ::)
09:15:54 <Cale> forall a. a is a type, the only value of that type is bottom
09:16:03 <pseudolio> There would be oddities if exists were introduced for the purpose of existential types.
09:16:09 <Cale> The type itself isn't bottom
09:16:17 <Zenol> so W take a bottom and construct a W?
09:16:24 <Cale> Well, yeah
09:16:29 <Cale> This isn't really a great example :P
09:16:31 <pseudolio> Like 'data V = V (exists a. a)' I can use exists, but only inside a data constructor.
09:16:37 <haasn> http://stackoverflow.com/questions/10753073/whats-the-theoretical-basis-for-existential-types
09:16:41 <haasn> found it
09:16:41 <Zenol> but W 5  would works?
09:16:46 <Cale> no, it wouldn't
09:16:50 <pseudolio> And it doesn't make a lot of sense with multiple constructor arguments like the current syntax does.
09:17:02 <Cale> Because 5 :: forall a. a  doesn't typecheck
09:17:09 <Cale> > 5 :: forall a a
09:17:10 <lambdabot>   No instance for (GHC.Num.Num (forall1 a1 a1))
09:17:10 <lambdabot>    arising from the literal `...
09:17:10 <Cale> > 5 :: forall a. a
09:17:11 <lambdabot>   <hint>:1:14:
09:17:11 <lambdabot>      Illegal symbol '.' in type
09:17:11 <lambdabot>      Perhaps you intended -XRa...
09:17:21 <Cale> damn it elliott
09:18:10 <Cale> Anyway, the error message we'd get if this were valid syntax is:    No instance for (Num a1) arising from the literal `5'
09:18:58 <Cale> data N = N (forall a. (Num a) => a)  is a somewhat more interesting type.
09:19:42 <Zenol> Oh sorry, I thought about data V = forall a. V a
09:19:46 <Cale> A value of type N is a wrapped up polymorphic number, which can later be unwrapped and interpreted as any particular kind of number you choose.
09:19:49 <startling> "more interesting" in that you can use 'abs', 'signum', and 'negate' on the inner number.
09:20:05 <haasn> Zenol: yes ‘V 5’ is valid (but you can't really do anything with it :) )
09:20:10 <haasn> hmm
09:20:27 <haasn> where data W = W (forall a. a) -- is equal to ⊥, I guess data V = forall a. V a -- is equal to ()
09:21:02 <tikhon> I don't think it's fair to say that data W = W (forall a. a) is ⊥
09:21:09 <tikhon> forall a. a is ⊥
09:21:19 <tikhon> so any value of W is W ⊥
09:21:29 <Cale> forall a. a isn't _|_, but a type whose only value is _|_
09:21:30 <haasn> s/data/newtype/ :)
09:21:43 <haasn> oh, I meant “is equal to Void”
09:21:46 <tikhon> but if you never inspect the value *inside* the W constructor, you're fine
09:21:52 <pseudolio> It is also the bottom of an induced subtyping hierarchy.
09:21:53 <Cale> data W = W (forall a. a) is a type with two values, _|_ and W _|_
09:22:10 <haasn> yes I meant newtype not data
09:22:13 <tikhon> W ⊥ is strictly "more defined" than ⊥
09:22:34 <Cale> Zenol: Anyway, I wanted to contrast this N...
09:22:42 <Cale> data N = N (forall a. (Num a) => a)
09:22:43 <Cale> with
09:22:50 <Cale> data M = forall a. (Num a) => M a
09:22:57 <Cale> These are very different types
09:23:03 <tikhon> newtype shouldn't change anything, should it?
09:23:39 <Zenol> Cale: Ok, I think I see now :)
09:23:42 <enthropy> there is a way to take a   ReaderT (IORef a) and make it behave like StateT with some safe uses of unsafePerformIO?
09:23:47 <Cale> I can apply the data constructor M to any type of number. For example, I can apply it to something which is explicitly a Double. When I later unpack the value, I won't know what type it was originally, apart from the fact that it was some instance of Num
09:24:24 <Cale> i.e. the data constructor M "forgets" the types of things it's applied to
09:24:57 <haasn> tikhon: newtype W = W (forall a. a) -- has only one value, W ⊥; there's no distinction between W ⊥ and ⊥
09:24:57 <Cale> while the data constructor N won't accept being applied to any specific type of number -- only *polymorphic* expressions which could be any type of number
09:25:11 <haasn> > case undefined of Identity _ -> ()
09:25:12 <lambdabot>   ()
09:25:42 <Cale> and when I unpack the value pattern matching on the N constructor, I'll be allowed to *choose* which type of number to interpret the contents as
09:26:17 <Cale> whereas with M, I don't get to choose and I also don't get to know.
09:26:47 <Cale> It may also be helpful to write these types in GADT syntax
09:27:11 <Cale> data N where N :: (forall a. (Num a) => a) -> N
09:27:23 <Cale> data M where M :: forall a. (Num a) => a -> N
09:27:56 <Zenol> ok :)
09:28:20 <Cale> er, sorry
09:28:24 <Cale> data M where M :: forall a. (Num a) => a -> M -- of course :)
09:31:14 <Cale> M isn't a very useful type, because there's not a whole lot you can do with something that you know is a number, but you don't know which type of number it is. You can't add it to anything other than itself, for example.
09:31:49 <Cale> So when you unpack the contents of the M constructor, you're left with something that you're not allowed to do a whole lot with.
09:31:59 <enthropy> you should be able to add numbers like 5 to it
09:32:16 <Cale> Oh, that's true actually.
09:32:33 <Cale> You can do things to it which you could do to an arbitrary sort of number.
09:33:02 <Cale> But if you have two of these values unpacked from different M constructors, you couldn't add them, because you can't know whether the types match.
09:36:08 <gs> Hi, I was wondering what my options for game programming in Haskell would be at the moment. I had a look at http://www.haskell.org/haskellwiki/Applications_and_libraries/Games#Game_Engines_and_Libraries but it's hard to gauge which ones are actually active and somewhat mature. I'm not specifically interested in FRP, but if that's the way to go, I'd be happy to take a closer look. Can anyone share her/his experiences?
09:37:34 <gs> (On a sidenote, I suppose no one bothered to do a library for sdl2 yet, right?)
09:37:54 <tikhon> wasn't that released just now?
09:38:12 <Fuuzetsu> sounds like we have a volunteer
09:39:05 <gs> heh
09:39:07 <applicative> gs that page has a lot of out of date stuff, but also mentions helm, which is new; it uses elerea frp
09:39:08 <shajra> kind of a silly question, do people really say "mobit" to differentiate between the monad instance?
09:39:22 <shajra> I read that in one of the wiki pages, and never saw it again.
09:39:28 <applicative> shajra: no, it's a witticism
09:39:41 <tikhon> what would that even mean?
09:39:53 <gs> tikhon: yeah, the sdl2 RC has been around for some time and I've seen some preliminary bindings in other languages, that's why I asked
09:40:03 <applicative> tikhon: it means a value coming under a monadic type
09:40:14 <applicative> thus, eg. [1,2,3] is a mobit, since
09:40:22 <applicative> > [1,2,3] >>= show
09:40:23 <shajra> I think it's intended to deal with the idea that "List isn't a monad.  It has a monad type class instance."
09:40:24 <lambdabot>   "123"
09:40:26 <applicative> makes sens
09:40:55 <applicative> no, shajra "list is a monad' makes sense, '[1,2,3] is a monad' doesn't; it is a 'mobit' though
09:41:19 <applicative> shajra: the trouble is a lot of people call 'readFile "a.txt"' a 'monad'
09:41:28 <gs> applicative: true; thanks, I'll take another look
09:41:46 <applicative> gs let me thing about the others; not that i know much
09:42:14 <applicative> gs oh, gloss, which helm sort of emulates, has a very simple game interface, not too configurable
09:42:33 <applicative> gloss is very restricted but top notch as far as it goes gs
09:43:08 <shajra> applicative: okay, sounds good.  I was just saying "List is monadic" rather than pinning it to the noun "monad"
09:43:19 <tikhon> I think it's fair to call List a monad
09:43:21 <applicative> gs free-game is fairly new too, but I don't know anythinga bout it
09:43:24 <shajra> because I was never really sure what diction was authoritative.
09:43:39 <applicative> shajra: well you could legitimately call [1,2,3] monadic
09:43:44 <shajra> I want to speak clearly if it's possible.
09:43:51 <tikhon> pedantically, it's not 100% correct, I suppose, but everyone will understand you and it isn't exactly *wrong* either
09:44:03 <applicative> shajra: you can't go wrong if youre talking about the (*->*) thing, ie IO , [], Maybe
09:44:16 <shajra> applicative: right, makes sense.
09:44:21 <applicative> its putChar'a', "a" and Just 'a' people have trouble with
09:44:40 <applicative> shajra: i suspect you arent having the difficulty mobit is supposed to solve
09:44:47 <shajra> right, there's no monad instance for for anything *.
09:45:21 <applicative> myself, i dont think there's much to be said against calling [1,2,3] a monad, but the argument is complex, linguistic and somewhat tiresom
09:45:31 <Peaker> reading Java is paging through pages upon pages of code that does almost nothing at all :(
09:45:41 <tikhon> calling [1,2,3] a monad is like calling 10 a group
09:46:18 <applicative> it arises naturally somehow. LYAH at first called [1,2,3] a functor, since 'a functor is something you can map over', then the supposedly knowledgeable people clobbered him, as if they knew anything he didn't
09:46:19 <startling> or introducing myself as "species"
09:46:47 <identity> What options do I have if I want to add a number of seconds (Int) to UTCTime?
09:46:55 <Peaker> applicative, "A Functor is a type whose values you can map over", I guess
09:47:11 <identity> Or basically, given a a date, add seconds to it, and receive another date?
09:47:16 <applicative> tikhon: there's more too it than that; that we are in a typesystem means there are other hooks for words to catch onto, mathematicians have no place for a concept like 'mobit' which really is a clear concept
09:47:20 <Peaker> applicative, precise terminology is important, it's not pedantry IMO
09:47:48 <applicative> Peaker: that involves calling (*->*) types, which is completely controversial
09:48:04 <Peaker> applicative, you're right I should be more precise :)
09:48:09 <tikhon> is that really controversial?
09:48:16 <applicative> exactly this goes on forever
09:48:31 <tikhon> why is it controversial?
09:48:49 <applicative> [Int] is a type
09:48:51 <Peaker> applicative, I think it is actually confusing to talk about "x" and "m a" as though they were the same thing (in "x :: m a")
09:48:58 <Peaker> applicative, or "x" and "m"
09:49:09 <Peaker> (actually, the latter is even more confusing, and what is commonly done)
09:49:11 <tikhon> [Int] is certainly a type, yes
09:49:30 <applicative> if you insist that [] is a type, you immediately lose a concept
09:49:34 <tikhon> but that hardly invalidates the idea that [] is also a type
09:49:45 <tikhon> what concept do you lose?
09:49:55 <applicative> if a usage destroy a clear concept, the objection is pretty good
09:50:03 <applicative> tikhon, type?
09:50:05 <tikhon> I do not see what you mean here
09:50:16 <applicative> thing not of some kind (k -> l)
09:50:17 <nicoo> tikhon: Basically, [] doesn't have constant arity anymore.
09:50:22 <Peaker> you can still say "a type which isn't a type constructor"
09:50:25 <nicoo> (So not well-kinded)
09:50:46 <tikhon> what do you mean by that?
09:50:52 <applicative> oh what's not well-kinded, []?
09:50:54 <startling> [] is a type the same way isUpper is a Bool
09:51:05 <tikhon> the syntax of [] is confusing here
09:51:13 <applicative> @kind []
09:51:14 <lambdabot> * -> *
09:51:16 <tikhon> I'm talking about [] like [] Int
09:51:18 <applicative> totally clear
09:51:21 <tikhon> not the value
09:51:27 <nicoo> identity: Of course
09:51:30 <tikhon> maybe Maybe is a better example
09:51:37 <nicoo> tikhon*
09:51:39 <tikhon> and I see no reason not to call Maybe a type
09:51:42 <applicative> there are three things, [], [Int] and [1]
09:51:44 <tikhon> just like Maybe Int is a type
09:51:50 <shajra> not calling things of kind (* -> *) seems inaccurate to me. . . kind of like insisting that functions can't unify with constants.
09:51:59 <tikhon> exactly
09:52:00 <applicative> tikhon: yes, but [] what is that?
09:52:03 <nicoo> tikhon: Why would you make type constructor types ?
09:52:17 <shajra> meant "not calling them 'types'"
09:52:34 <tikhon> same reason you make functions values, I suppose...
09:52:40 <tikhon> they're just types with different kinds
09:53:07 <applicative> tikhon this shows that by 'type' you mean 'kinded'
09:53:19 <shajra> tikhon: I see it this way, but evidently someone with linguistic chops or a deeper understanding might have a counterargument.
09:53:21 <tikhon> no, I mean 'type', like it's used in type theory
09:53:54 <shajra> tikhon: right, because I like the idea that "every type has a kind"
09:53:56 <applicative> there are a lot of type theories out there but we are making distinctions in relation to a specific language
09:54:07 <applicative> every type has a kind
09:54:09 <shajra> rather than "types" are things with kinds of (*).
09:54:13 <applicative> on any view that makes sense of kinds
09:54:15 <nicoo> tikhon: Yet, 'stuff with different kinds' is *exactly* 'kinded' : the concept you want is already there
09:54:27 <tikhon> it's also 'type'
09:54:31 <applicative> but tikhon do you think 'kind' in this context has a use in every type theory
09:54:38 <tikhon> we have a simple heirarchy: values have types and types have kinds
09:54:51 <applicative> types are things of kind k
09:54:57 <applicative> for any k
09:55:34 <shajra> applicative: when I hear the last few points you're making, I'm having a hard time finding the discrepancy with what tikhon is saying.
09:55:51 <applicative> ah, that's wrong, what i said
09:55:52 <applicative> bah
09:55:56 <k00mi> applicative: so is (k -> l) a kind?
09:56:07 <applicative> mcbride uses type for * in connection with haskell
09:56:18 <tikhon> if you want to talk about types of kind *, you can say "type of kind *" or "concrete type"
09:56:19 <applicative> k00mi: yeah, that was the nonsense
09:56:49 <applicative> tikhon: but why bother
09:57:16 <tikhon> to make everything more uniform
09:57:24 <tikhon> simpler
09:57:26 <applicative> this is just a verbal decision
09:57:48 * shajra was just hoping this was all resolved, rather than still debated.
09:57:55 <applicative> it isn't simpler, since it imports distinction from extremely fancy type systems into the description of e.g. haskell 98
09:57:59 <tikhon> I've never seen anyone use 'kinded' before
09:58:09 <tikhon> extremely fancy?
09:58:16 <tikhon> simpler type systems, even
09:58:25 <applicative> the report distinguished e.g. types, [Int], [a]  and type constructors []
09:58:40 <applicative> there is no possible objection to this
09:58:58 <applicative> not that I see
09:59:53 <applicative> in general a usage of 'type' where you don't contemplate a corresponding value is a very recent decision in type theory, which is over 100 yrs old
10:01:10 <tikhon> it seems like an especially odd distinction given how similarly they're declared
10:01:16 <tikhon> data Foo = ... vs data Foo a = ...
10:01:26 <tikhon> the syntax is just like functions vs values
10:01:47 <applicative> but data Foo a covers Foo Int Foo Char etc, which are the types declared
10:01:47 <tikhon> with type Foo = ..., you couldn't even figure it out until you followed all of the aliases
10:01:57 <applicative> if Foo were a type given by data Foo a = Foo a
10:02:08 <applicative> then we would decare it data Foo = ...
10:02:10 <nicoo> torkjak: I don't see why calling kinded stuff 'types' and separating 'types' that have values 'concrete types' any better than having 'types' and 'kinded stuff'
10:02:27 <applicative> this argument is hardly decisive of course
10:02:50 <applicative> i'm opposing people forcing things the read about that post date the haskell report, on the language
10:03:21 <tikhon> the report is well behind the times given how many extensions people use
10:03:44 <applicative> people don't usually call numbers 'things', but they call boats and rocks things; now we object, saying, no boats are 'concrete things'
10:03:57 <applicative> but of course 'thing' in English, 'how many things' means concrete things
10:04:17 <applicative> this dispute has as much profundity as one over 'concrete things' vs 'things
10:04:25 <dmj`> whats the best way to convert a Char to an Int in haskell? like '1' to 1
10:04:36 <applicative> char in Data.Char
10:04:42 <applicative> chr?
10:04:44 <tikhon> chr
10:04:47 <applicative> > chr 2
10:04:47 <tikhon> ord
10:04:48 <lambdabot>   '\STX'
10:04:54 <applicative> > chr 212
10:04:55 <lambdabot>   '\212'
10:05:02 <applicative> ord! grrr
10:05:44 <applicative> left and right; positive and negative charge how do people keep this stuff straight!
10:05:46 <tikhon> That seems like an odd analogy, especially because I (and, presumably, people I know) would certainly classify numbers as "things"
10:06:25 <dmj`> applicative: thanks, digitToInt
10:06:37 <danilo2> Hello :) I've got a little problem with parser combinator architecture - I've written a lexer (wich have "pLex" combinator, which produces a list of tokens) and now I want to create parser, which consumes tokens and builts AST. The problem is - how should I connect them together? Shoudl I parse the list of tokens once again using different "parser" or connect somehow combinators?
10:06:45 <danilo2> (More detailed question: http://stackoverflow.com/questions/18214179/combining-lexer-and-parser-in-a-parser-combinator)
10:06:53 <applicative> dmj`: oh i was double mixed up.
10:08:03 <dmj`> applicative: Data.Char was key, right ball park
10:08:04 <tikhon> I haven't used uu-parsinglib, but I remember the Parsec documentation's having some nice examples of using a custom lexer
10:08:12 <tikhon> maybe that'll help
10:08:22 * hackagebot ewe 0.1.0.15 - An language to teach a programming  http://hackage.haskell.org/package/ewe-0.1.0.15 (JuanFranciscoCardonaMcCormick)
10:09:21 <Peaker> tikhon, a bit of a scrollup, but you said "values have types and types have kinds" -- under this view "Maybe" is not described as a type yet (it's not described at all)
10:10:16 <Peaker> Though I agree that it makes sense to call "Maybe" a type, otherwise with polymorphic kinds, we can have a type variable that is either a "type constructor" or a "type", and calling it a "kinded thing" is weird. "type" is nicer
10:10:49 <tikhon> just because values have types does not mean all types have values
10:11:49 <Peaker> that's what I meant by "not described at all" -- that sentence is only about types of values, not entities like "Maybe"
10:12:01 <Peaker> (so a bit weird in a discussion about what to call things like "Maybe")
10:14:05 <tikhon> for what it's worth, the Haskell report seems to use "type" to cover different kinds, at least in section 4.1
10:14:19 <tikhon> or, at the very least, "type expression"
10:14:55 <applicative> right, type expression would cover all cases, but sounds too linguistic
10:15:53 <tikhon> It also says things like "The *function type* is written as (->) and has kind * -> * -> *".
10:16:03 <applicative> a kind system is a machine for producing the desired terms
10:16:10 <startling> what a boring conversation
10:16:19 <applicative> this is not haskell 98
10:16:24 <applicative> startling: indeed
10:16:39 <tikhon> erm, isn't it?
10:17:16 <tikhon> eh, less boring than no conversation, which is the main alternative
10:17:40 <startling> I disagree.
10:17:58 <tikhon> and certainly less boring and more relevant than this meta conversation
10:19:15 <applicative> tikhon: startling is just making an inarticulate contribution
10:19:38 <isomorphismes> Sorry folks I keep having these really elementary language questions. Appreciate everyone who has helped me so far. in LYAH ch 3 he writes calcBmis xs = [bmi | (w,h) <- xs, let bmi = w/h/h]
10:19:55 <startling> tikhon, is the metaconversation a conversation?
10:20:00 <isomorphismes> What confuses me about this is fn param = [... | ... <- param]
10:20:10 <Fuuzetsu> param is just a list
10:20:16 <tikhon> honestly, the general confusion about what exactly a monad and functor was really made understanding the ideas difficult when I was just learning Haskell
10:20:20 <tikhon> it is important to get it straight
10:20:23 <Fuuzetsu> it takes one element at a time from it
10:20:59 <applicative> > let foo xs = [x+1| x <- xs] in foo [1]
10:21:00 <lambdabot>   [2]
10:21:17 <applicative> isomorphismes: 'param' is the same as 'xs' there ^^
10:21:22 <Fuuzetsu> applicative: I was literally writing the same example right now…
10:21:26 <tikhon> and yes, the metaconversation is a conversation, although allowing that no doubt permits horrible paradoxes
10:21:28 <applicative> hah
10:21:33 <isomorphismes> applicative: right.
10:21:40 <tikhon> but there's nothing wrong with horrible paradoxes
10:21:53 <tikhon> the spice of life
10:21:56 <tikhon> or something
10:22:27 <tikhon> hmm, Haskell doesn't have anything akin to OCaml's bitmatch, does it?
10:23:23 <tikhon> things like that make me envy Camlp4
10:23:27 <maurer> tikhon: I don't think so, I normally use something similar to attoparsec for that
10:23:39 <maurer> tikhon: If you really wanted it you could probably add it with TH
10:23:52 <tikhon> yeah, probably, but it'd look a bit more awkward
10:24:09 <isomorphismes> …so…x is defined "hypothetically" in [x+1 … then after | it gets its actual values from x<-xs which I'm reading as "x gets" or "x reads in values from xs" (…which was mentioned before the = already…kind of confusing…) and then this is all resolved to a specific calculation in foo [list containing just one element with value 1]
10:24:10 <tikhon> and I'm mostly using it for the convenience and readability at the moment
10:24:22 <tikhon> all I really want to do is basically unpack a little C struct—very simple
10:24:30 <startling> quasiquotation would be the thing
10:24:41 <maurer> tikhon: If you're trying to unpack a C-struct, I actually made a thing you can use
10:24:57 <maurer> tikhon: http://hackage.haskell.org/package/c-storable-deriving
10:24:58 <tikhon> well, I'm currently doing this in OCaml and just lamenting the fact that it would be somewhat more awkward in Haskell
10:25:02 <maurer> Oh
10:25:05 <maurer> Not really
10:25:07 <startling> tikhon: you can do it pretty easily wit binary/cereal
10:25:11 <tikhon> hmm
10:25:14 <maurer> The package I have up there makes it so that if you lay out the struct the same way
10:25:22 <maurer> it will just generate a thing that can blit it to and from memory
10:25:26 <maurer> as though it were a c struct
10:25:28 <tikhon> oh, it's somebody else's struct
10:25:32 <maurer> yes
10:25:35 <maurer> You just lay it out the same
10:25:38 <tikhon> or do you mean lay out a Haskell record?
10:25:44 <dmwit> isomorphismes: Have you seen the desugaring rules for list comprehensions? It might make "how things work" a bit more clear.
10:25:48 <dmwit> ?where report
10:25:48 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
10:25:49 <isomorphismes> if I tried reading calcBmis xs = [bmi | (w,h) <- xs] in English I would say "the function calcBmis (taking a list of x's) is the set of all bmi's where the pair (w,h) gets values from the list of x's"
10:25:51 <danilo2> Hi! Does anybody knows UU-PARSINGLIB and could help me with the following problem: http://stackoverflow.com/questions/18214179/combining-lexer-and-parser-in-a-parser-combinator
10:25:52 <maurer> Yeah, order of fields matters, only use storable or C types underneath
10:25:59 <maurer> so yeah, lay out haskell record to match c record
10:26:00 <tikhon> aha
10:26:04 <tikhon> that actually looks pretty nice
10:26:28 <tikhon> still, the OCaml version with bitmatch is also very slick, and lets me skip defining an intermediate type
10:26:34 <dmwit> isomorphismes: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
10:27:15 <tikhon> of course, OCaml compromises all this by having really annoying behavior like mutable strings
10:27:17 <isomorphismes> thanks dmwit
10:27:17 <tikhon> mutable strings!
10:27:35 <startling> danilo2, I think you're not getting very much help because not many people use uu-parsinglib
10:27:47 <isomorphismes> what does → mean? same as ->?
10:27:54 <tikhon> yeah
10:28:04 <danilo2> startling: So maybe I should move over Parsec ... :/
10:28:05 <tikhon> if you actually want to use it in your code, you'd have to enable an extension though
10:28:16 <tikhon> danilo2: probably; Parsec is awesome
10:28:23 * hackagebot snaplet-acid-state 0.2.4 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.4 (DougBeardsley)
10:28:31 <startling> "trifecta" is nice
10:28:38 <dmj`> attoparsec is awesome
10:28:41 <applicative> danilo2: there is the advantage that people are more familiar with parsec and attoparsec
10:28:59 <chrisdone> used attoparsec for the first time today, seems nice enough
10:29:03 <tikhon> attoparsec and parsec are awesome for different things
10:29:16 <dmwit> isomorphismes: No, it is a production rule in Haskell's formal grammar.
10:29:23 <danilo2> tikhon: Does Parsec allows you to suggest correct results to the user or allows you to parse the tokens "in realtime" - make some action before all the input is read?
10:29:37 <chrisdone> danilo2: yeah
10:29:37 <dmwit> isomorphismes: as in EBNF
10:29:41 <tikhon> I don't know about online parsing
10:29:50 <chrisdone> online parsing is possible in parsec, i've done it
10:29:56 <tikhon> but it does have very good—and configurable—error messages
10:30:03 <dmwit> isomorphismes: But I think you can ignore the EBNF for the purposes of the questions you've asked so far.
10:30:32 <danilo2> chrisdone: good to know - did you had any problems with it? Does parsec allows you to write infull aplicative style ? :>
10:30:32 <chrisdone> i implemented a language that had macros that could hook into the parser, using parsec's monad transformer
10:30:51 <tikhon> yeah, Parsec support Applicative style well
10:31:05 <chrisdone> danilo2: yeah it has an applicative instance. it kind of predates applicative, so it defines the exact same combinators
10:31:28 <tikhon> oh yeah, the conflicts with <|> and such are actually a little annoying, but hardly insurmountable
10:31:31 <chrisdone> but i tend to just import and hide those and use Control.Applicative
10:32:37 <danilo2> Ok so the last question - is it possible in Parsec to automatically fix errors? I mean - uu-parsinglib allows you to write a grammar where you wait for lets say 0-9. and if user inputs "009343a0" it automatically deletes "a" , prints a wanring and fix the input for you
10:33:26 <chrisdone> parsec is also a monad so you have complete control to look at stuff and use or ignore things, or even look at and mess with the parse state
10:34:32 <startling> danilo2, sure, but that sounds crazy.
10:34:48 <c_wraith> danilo2: parsec really isn't built for that.
10:34:52 <chrisdone> startling: eh it's common for user-facing input
10:34:58 <danilo2> Ok, so maybe its tme to move over Parsec :) Ok - if I will write this in pParsec - and I'll write a lexer producing list of tokens - could you please tell me how can i write (in Parsec) a parser consuming these tokens? Should it be a new parser, that will eat each element form the token list or shpould it be some jind of combinator ?
10:35:26 <startling> chrisdone: oh, that's true. I was thinking about programming languages.
10:35:32 <dmj`> danilo2: This parsec tutorial is pretty good: http://legacy.cs.uu.nl/daan/parsec.html
10:35:47 <dmj`> this too: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
10:36:22 <tikhon> that sort of behavior is also what makes HTML so exciting
10:36:27 <chrisdone> danilo2: parsec is generic upon the token, so you get its common combinators for free. you forget its string-based combinators and implement a couple for your token type
10:36:55 <chrisdone> danilo2: so you can write both the lexer and the parser in parsec, or just do it one one go, as preferred
10:37:12 <tikhon> or you could write the lexer using something else and just stream the tokens to Parsec
10:37:27 <tikhon> although I'm not 100% sure about how to preserve lexical information (like line/character numbers)
10:37:38 <geekosaur> you'd include it in the token
10:37:42 <chrisdone> i've used parsec with tagsoup and s-expressions
10:38:06 <danilo2> chrisdone: I would love to write both in it. I dont like the idea of writing lexer in Alex. But I understand that the lexer should output a list of tokens and then the aprser should consume them and buit AST? Is it possible to create online parser with such design ?
10:38:21 <chrisdone> danilo2: sure!
10:38:28 <chrisdone> hold up, i have an example
10:38:38 <startling> danilo2, it's not uncommon to skip the lexer completely
10:38:49 <tikhon> hmm, if you're going to write both parts in Parsec, you may as well just do it in one pass
10:38:58 <tikhon> that's what I do for my own code; it seems to be the easiest option
10:39:05 <dmwit> Something is strange: "[1360/2143] (91%)"
10:39:09 <danilo2> startline: I know, but I've got pretty big grammar - something like Java, so I'll keep the elxer :)
10:39:14 <dmwit> This progress report doesn't seem right. =P
10:39:17 <dmwit> > 1360/2143
10:39:18 <lambdabot>   0.6346243583761083
10:39:27 <tikhon> eh, Java's not too bad
10:39:40 <tikhon> also, Parsec has a module for lexing common programming languages which might be useful
10:39:49 <carter> applicative: glad I could help
10:39:59 <tikhon> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html
10:40:14 <tikhon> erm, you might want to look at the general Parsec documentation first though
10:40:37 <chrisdone> danilo2: here's an example of an online parser: https://github.com/chrisdone/z/blob/master/src/Z.hs -- see i have the type ParsecT String () Z a, meaning i can run actions in the Z monad during parsing
10:40:38 <donri> dmwit: http://chrisdone.com/posts/darcs
10:40:56 <chrisdone> danilo2: and here's an example of using a custom token type: http://hackage.haskell.org/packages/archive/tagsoup-parsec/0.0.8/doc/html/Text-HTML-TagSoup-Parsec.html
10:41:19 <applicative> oh hi carter
10:41:48 <dmj`> danilo2: You can evaluate your AST by passing a symbol table dictionary in a state monad. Avoid string concatenation, trust me. Also you could use a reader monad to reference your AST as you traverse it
10:41:49 <chrisdone> donri :D
10:41:55 <donri> ^_^
10:42:02 <carter> applicative: do you like how different bench groups are compared seperately? :)
10:42:24 <applicative> carter: yes it's much clearer
10:42:40 <carter> yay
10:42:41 <chrisdone> danilo2: i kinda planned on writing a parsec tutorial that showed off these two cool features of parsec (online and token-agnostic parsing). there doesn't seem to be a tutorial out there for it
10:42:49 <carter> i had to pester an expert in JS to figure out how to do it
10:43:04 <applicative> the html files are huge; or i guess just benched more nonsense than i was realizing
10:43:05 <carter> at some point i want to do a nicer version that doesn't require js but still lets me share teh benches
10:43:10 <danilo2> chrisdone, startling, dmj`: Thank you all for the help - I'll look into the materials right now :) I see that Parsec is very widely used so It could be good move. I've heard that Parsec 3 is "slow" - whatever that means - I understand It has simmilar perdformance to uu-parsinglib or other parser generators?
10:43:12 <chrisdone> danilo2: for your basic   parsec, this is a good tutorial https://www.fpcomplete.com/school/text-manipulation/attoparsec
10:43:13 <carter> yeah
10:43:26 <carter> it actually does all the computation in the html doc with js :)
10:43:56 <carter> a nicer solution would be to have a haskell script that does the tabulations, then generates some latex and runs pdf tex
10:44:00 <tikhon> It's fast enough for user-generated input or programming language stuff
10:44:03 <chrisdone> danilo2: yeah, i think it depends on what you're parsing and why
10:44:06 <danilo2> I do not want to use attoparsec, because I want to have good error handling system - to say user very nice what he did wrong
10:44:20 <chrisdone> for user-entered stuff it's probably sufficient
10:44:22 <tikhon> I think the speed is more a problem for things like various communication protocols and other auto-generated data
10:44:31 <applicative> no you don't want attoparsec
10:44:33 <chrisdone> for megs of data you're more likely to succeed with attoparsec
10:44:36 <dmj`> danilo2: This too, was an enormous help for me. http://www.haskell.org/haskellwiki/Parsing_a_simple_imperative_language
10:45:41 <ekyo> haskell noob trying to learn here, kinda confused by bind and liftM
10:46:27 <ekyo> for example if I do, within do notation
10:46:30 <danilo2> Thank you all :) I'll look into Parsec right now :) I think with all the materials it would be pretty straigthforward :P)
10:46:52 <ekyo> txt <- getLine
10:46:52 <ekyo> putStrLn $ txt
10:46:55 <chrisdone> danilo2: “good, now, get it done by sunrise or i'll cut your balls off!”
10:47:06 <chrisdone> =p
10:47:09 <carter> applicative: what are you benching?
10:47:13 <danilo2> chrisdone: I'll do it! :D
10:47:18 <ekyo> how would I replace that with liftM ?
10:47:22 <chrisdone> carter: do u even liftM?
10:47:35 <carter> benchmarks :)
10:47:36 <startling> ekyo, you wouldn't
10:47:39 <dmj`> ekyo: liftM is the same as fmap, just within a monadic context.
10:47:48 <carter> i unsafePerformIO in some of my benchmarks so they work correctly :)
10:47:54 <donri> danilo2: could also look at trifecta, should be bit faster than parsec with possibly even better error reporting (with console coloring and carets and all that) plus can double as a syntax highlighter for your grammar
10:48:10 <ekyo> hmm then any example of where I'd use liftM ?
10:48:29 <chrisdone> ekyo: when you can't be bothered to write: do x <- m; return (f x)
10:48:35 <chrisdone> ekyo: you just write liftM f m
10:48:43 <startling> ekyo, you could have 'join (liftM putStrLn getLine)' but that's kind of silly
10:48:49 <donri> ekyo: any time you want fmap without Functor constraint but you already have a Monad constaint. this won't matter in future GHC though
10:48:54 <applicative> > liftM (+ 2) (Just 0)
10:48:55 <lambdabot>   Just 2
10:48:56 <startling> ekyo: the better way to write it would be "getLine >>= putStrLn"
10:49:03 <dmwit> ekyo: (Is there a question to go with this code snippet?)
10:49:17 <dmwit> ekyo: Never mind, ignore me, I just don't understand how to use my IRC client.
10:49:18 <ekyo> oh thx
10:49:22 <chrisdone> @src liftM
10:49:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:49:27 <applicative> (| putStrLn getLine @|)
10:49:28 <donri> startling: putStrLn =<< getLine -- better!
10:49:31 <carter> chrisdone :P
10:49:42 <startling> donri: I disagree.
10:49:53 <donri> applicative: is that some kind of monad idioms in SHE?
10:50:08 <dmj`> ekyo: suppose you wanted to read an integer from the command line.
10:50:25 <dmwit> :t readLn
10:50:25 <chrisdone> i couldn't really decide why i find f =<< m so unsettling
10:50:26 <lambdabot> Read a => IO a
10:50:31 <dmj`> ekyo: you could use fmap or liftM to lift "read" into the IO monad
10:50:36 <dmj`> main' = do { num <- liftM read getLine; print (num :: Int) }
10:50:44 <dmwit> chrisdone: It's unsettling because m's effects happen before f's.
10:51:02 <donri> dmwit: doesn't that depend on the monad?
10:51:10 <dmwit> Not really?
10:51:12 <applicative> yeah, donri, here's my gutting version for local use http://lpaste.net/91687
10:51:18 <applicative> gutted version, rather
10:51:31 <ekyo> makes a bit more sense now ;) thx gotta experiment with it some more now so it sticks
10:51:33 <startling> "effect" is defined by (>>=) anyway.
10:51:35 <dmwit> Different monads just have a different definition of "effect". Or possibly "before". ;-)
10:51:39 <chrisdone> i think i'm just used to reading "actions" in order that they happen
10:51:58 <dmwit> chrisdone: right
10:51:58 <chrisdone> most monads do follow a sensible x >>= y ordering
10:52:02 <dmj`> ekyo: fmap, liftA, liftM, same operation, different contexts.
10:53:00 <donri> > const Nothing =<< undefined
10:53:01 <lambdabot>   *Exception: Prelude.undefined
10:53:09 <donri> alright
10:53:38 <dmwit> I wonder what monad that picked.
10:53:38 <chrisdone> isn't one of the monad  laws m >>= return = m?
10:53:50 <dmwit> chrisdone: yes
10:54:01 <isomorphismes> ok. So it's func(argument) = returns a list of [ calculated.values where | (intermediate1, intermediate2) read in values from <- function's argument, now to calculate calculated.values let calculated.values = intermediate.1 / intermediate.2 / intermediate.2 ]
10:54:02 <applicative> chrisdone: what about nonsense like cat $(which ghc)
10:54:02 <donri> dmwit: Maybe?
10:54:07 <applicative> why cant i do that in haskell
10:54:23 <danilo2> Why on the official site of Parsec there is information about the Parsec2, while Parsec3 is out for couple of years? (http://legacy.cs.uu.nl/daan/parsec.html)
10:54:25 <chrisdone> applicative: was that aimed at me?
10:54:36 <dmwit> donri: derp, yes
10:54:38 <carter> applicative what are you benching?
10:54:41 <carter> *benchmarking :)
10:54:45 <applicative> chrisdone: oh, i was reading where you said you want the effects in the order they happen
10:55:07 <applicative> carter: I was fiddling with tekmo's foldl library
10:55:11 <carter> oh
10:55:31 <carter> i really want to get edwardk's machines lib in nice shape at some opint
10:55:35 <applicative> there seem to be several strategies to keep it from various disasters
10:55:46 <carter> which disasters?
10:56:26 <applicative> the obvious ones of getting the compiler to see we want a very-strict-left-fold from these 'Foldl' expressions
10:57:38 <carter> multipass seems liek a nicer solution
10:57:44 <carter> albeit a bit more machinery
10:57:55 <applicative> this idea has been around a while 'beautiful folding' but i think it didn't take partly because no one looked into the proper optization
10:58:06 <danilo2> donri: I'm afraid trifecta is not widely used and I'll have the same problems as with uu-parsinglib - nobody would be able to tell me how to solve an issue :(
10:58:19 <carter> eh?
10:58:41 <chrisdone> danilo2: that's the spirit!
10:58:43 <donri> danilo2: shrug, they're all just applicative/monadic combinators
10:58:47 <applicative> danilo2: edwardk is often around; he tutored dylukes on trifecta when he was implementing something
10:58:59 <isomorphismes> thanks applicative dmwit Fuuzetsu
10:59:05 <carter> i'm just saying that the multipass approach should be able to support the applicative notation if it doesn't alredy
10:59:19 <applicative> danilo2: donri s point is the main one; it's true you don't want attoparsec
10:59:29 <danilo2> But how is thrifecta "better" than Parsec - could you please tell a bit more about it?
10:59:40 <carter> awesomer user error messages
10:59:42 <carter> and things
10:59:46 <carter> and modern tricks
10:59:48 <carter> and thigns
10:59:49 <donri> STUFF. that's what.
10:59:54 <carter> yesss
11:00:01 <applicative> carter: maybe, I haven't studied multipass. It is exactly getting the applicative notation not to spoil everything that I was trying to figure out
11:00:03 <chrisdone> if that doesn't convince you, i don't know what will
11:00:15 <tikhon> does trifecta have a broadly similar interface to Parsec?
11:00:21 <carter> roughly
11:00:23 <carter> its really nice
11:00:33 <chrisdone> we are all parsec
11:00:47 <carter> and parsec is us?
11:00:56 <tikhon> hmm, might be worth a try next time I'm parsing stuff in Haskell
11:00:58 <carter> all the parser combinator libs have largely the same interfaces
11:01:02 <startling> we have found the parsec and he is us.
11:01:04 <danilo2> So if everything is Parsec, why to use trifecta? :D
11:01:12 <startling> danilo2, nicer error messages
11:01:14 <carter> beause tis more parsec than parser
11:01:16 <carter> yes
11:01:16 <carter> that
11:01:24 <carter> it has A LOT of machinery
11:01:31 <carter> for supporting you giving your end application user
11:01:31 <tikhon> hmm
11:01:32 <isomorphismes> Weirdly, this makes much more sense to me: f args = [out | (p,q) <- args, let out = p/q/q] … than his example with BMI's.
11:01:32 <applicative> the main interface of all of them is nicely capture here https://github.com/ekmett/parsers/blob/master/src/Text/Parser/Combinators.hs
11:01:35 <carter> better error messages
11:01:44 <tikhon> does trifecta expose a monadic interface?
11:01:48 <tikhon> or just applicative?
11:01:51 <startling> tikhon, both
11:01:54 <tikhon> ah
11:02:04 <chrisdone> to be fair, you're not helping the guy by recommending something and giving awful descriptions of it
11:02:07 <donri> tikhon: it uses a generic class that even works with parsec
11:02:10 <startling> there are some combinators that only work with parsers that are also monads.
11:02:12 <donri> @hackage parsers
11:02:12 <lambdabot> http://hackage.haskell.org/package/parsers
11:02:17 <tikhon> hmm
11:02:18 <donri> @hackage parsec-parsers
11:02:18 <lambdabot> http://hackage.haskell.org/package/parsec-parsers
11:02:23 <tikhon> interesting
11:02:36 <danilo2> startling: could you please a "little" more about it? How can it have better errors? I understand it susggest fixing erros to the user (as PArsec or uu-parsinglib does) - what else?
11:02:36 <startling> isomorphismes, that's the exact same thing
11:02:48 <donri> so you can write a parser that works with either trifecta or parsec. attoparsec is apparently a bit trickier
11:02:55 <startling> danilo2, have you ever used clang?
11:03:11 <danilo2> startling: Yes, I have
11:03:25 <carter> yeah, attoparsec has different failure / backtracking sematncis
11:03:27 <carter> clang is nice
11:03:27 <startling> danilo2, it has clang-style parser error messages with carets and things
11:03:31 <carter> yesss
11:03:43 <carter> thats actually a good way of explaining it
11:04:03 <chrisdone> it seems to me that the "parsers" library only parses characters
11:04:11 <danilo2> startling: Oh, that's nice - does trifecta is as fast as Parsec ? I dont want to use something I'll have to change in thew near future :D
11:04:18 <donri> chrisdone: it's an interface, it doesn't parse shite :p
11:04:31 <isomorphismes> startling: I know, it's just the inputs and outputs are easier for me to tell which comes from where.
11:04:40 <startling> chrisdone, CharParsing is the class for parsers parsing Char
11:04:56 <applicative> oh i forgot about the carets in trifecta
11:04:57 <startling> danilo2, it's fast enough not to matter
11:05:17 <carter> parsers + trifecta are needed together
11:05:24 <danilo2> ok so nowvery important question to me: does trifecta allows for online parsing ?
11:06:20 <startling> I don't really know what online parsing is.
11:06:23 <chrisdone> it seems not to be a monad transformer
11:06:35 <chrisdone> startling: doing things like IO or other monads inside the parser
11:06:36 <donri> danilo2: trifecta supposedly is a bit faster than parsec
11:06:42 <danilo2> donri, carter: does really "parsers" supprt the all the generic features I will need? Because parsec and trifecta can differ (I dont know them, so I'm not sure about that)
11:06:50 <applicative> whats' not a monad transformer
11:06:51 <donri> chrisdone: it's a class, not a concrete type
11:06:54 <carter> they are the same
11:07:03 <startling> chrisdone, they're classes for things, some instances of which can be monad transformers
11:07:08 <carter> you use them together
11:07:13 <startling> chrisdone: consider MonadState vs StateT.
11:07:21 <startling> chrisdone: sure.
11:07:24 <isomorphismes> startling: if you replace it all with ABC then the structure without [|<-,] is ABCABC, which I think makes it hard to tell which part is input, which is intermediate, which is output. Anyway just my 2p.
11:07:25 <chrisdone> i don't see any classes, just a concrete type
11:07:37 <startling> chrisdone, where are you looking?
11:07:53 <chrisdone> danilo2: anyway, parsec does what you want. i don't know why these guys are being so tight-lipped on details
11:08:04 <startling> chrisdone: oneOf :: CharParsing m => [Char] -> m Char
11:08:18 <startling> chrisdone: endBy1 :: Alternative m => m a -> m sep -> m [a]
11:08:34 * chrisdone sighs
11:08:48 <startling> chrisdone: where is this concrete type?
11:08:55 <danilo2> chrisdone: Ehhh and now I'm choosing between Parsec and Trifects :/
11:09:02 <danilo2> *trifecta
11:09:28 <donri> danilo2: just use parsec. easy enough to port later, and you'll learn the "original parser combinator library" that guided all the others.
11:09:29 <chrisdone> you'll get more concrete information comparing them yourselves, i don't think anyone here has used trifecta apart from the author
11:09:32 <carter> yeah
11:09:39 <carter> use parsec for now
11:09:40 <carter> :)
11:09:45 <carter> esp if you're still learning
11:09:56 <carter> and has more docs
11:10:18 <danilo2> heh :) Ok :) Than you :)
11:10:21 <applicative> "Parsec : An Industrial Strength Parser Combinator Library"
11:10:25 <applicative> for the enterprise
11:10:46 <danilo2> applicative: But its not very maintained as far as I see :)
11:10:57 <applicative> parsec if fine
11:10:59 <donri> @faq does haskell have combinators for parsing industrial strengths?
11:10:59 <lambdabot> The answer is: Yes! Haskell can do that.
11:10:59 <applicative> is fine
11:11:14 <carter> danilo2 its a very very stable lib
11:11:24 <applicative> danilo2: if it weren't maintained, everything would break
11:11:24 <carter> its been around in one form or another for 10-15 years
11:11:36 <carter> its probably one of the most stable libs on hackage
11:11:43 <danilo2> Ok, I see for now the only way is Parsec :)
11:11:49 <danilo2> thank you for all the help :)
11:12:00 <applicative> there was a huge crisis in the move from parsec 2 to 3 it ws still going on when i was first learning haskell
11:12:10 <carter> oh yeah
11:12:11 <carter> that sucked
11:12:24 <carter> meant i couldn't have parsec3 and pandoc at the same time for a while
11:12:31 <donri> quickcheck 1 is still maintained innit? :)
11:12:42 <applicative> hah, yes that was part of the crisis.
11:12:51 <applicative> parsec3 was slower at first
11:13:11 <carter> then attoparsec happened and people stopped caring + they figured out how to make it fast again
11:13:55 <carter> i'm editorializing
11:14:04 <carter> so don't take anything i say too seriously
11:14:23 <donri> first there was Text.ParserCombinators.Parsec, then there was Text.Parsec, now people are starting to ditch these top hierarchies - when can I import Parsec?
11:14:46 <applicative> it should just be Parsec
11:14:47 <carter> when you fork it :)
11:15:13 <donri> that reminds me, i have a planned package for this
11:15:53 <applicative> donri can just put a parsec-donri on hackage with module Parsec (module Text.Parsec, module ...) where import ...
11:15:54 <carter> eh?
11:15:55 <donri> i'm calling it anarchy and it simply re-exports modules from popular packages in the top level
11:16:08 <carter> trollllllllollll
11:16:10 <carter> :)
11:16:46 <donri> not trolling! nice for ghci and app dev
11:16:52 <donri> import qualified Lens  -- done
11:17:11 <applicative> import Anarchy as Donri; mysum = Donri.foldl' (+) 0
11:17:14 <donri> pipes 4 does this
11:17:20 <carter> huh
11:17:29 <donri> it's just "Pipes"
11:17:42 <carter> i should do that with my stuff :)
11:17:43 <applicative> yes, it's the way to go, i'm really in favor of the pipes approach. it isn't completely new
11:17:52 <donri> quite
11:17:55 <carter> i really need to stare at machines :)
11:17:59 <applicative> Control.Blah, Data.Blah, grrrrrr
11:18:00 <donri> i started anarchy before pipes 4 ;)
11:18:09 <donri> Data.Data.Data
11:18:16 <carter> it seems like you could have a neat analogue of pipes api with machines inside
11:18:20 <carter> @hackage machines
11:18:20 <lambdabot> http://hackage.haskell.org/package/machines
11:18:32 <applicative> goo :: Data.Data.Data -> Data.Data.Data
11:19:33 <carter> ohhh, machines doesn't have the sending stuff back up
11:19:55 <applicative> well youre interface will have to drop that certainly
11:20:21 <kaiko> how to use printf if you don't know your arguments count? I tried "foldl (\ agg arg -> agg arg) (printf format) args
11:20:34 <kaiko> but gch says to me: Occurs check: cannot construct the infinite type: a0 = [Char] -> a0
11:20:50 <ion> kaiko: What are you trying to achieve?
11:20:53 <carter> applicative whos interface drop what?
11:20:54 <donri> kaiko: don't use printf :)
11:20:57 <applicative> it would be interesting to work out a simple class PipeyConduityMachiney :: (* -> * -> (* -> *) -> * -> *) ->Constraint
11:21:28 <applicative> kaiko: don't use foldl either
11:21:35 <isomorphismes> startling: stated more clearly: since I dont understand =>[|,<-], if the variables are named input, intermediate1, intermediate2, output, it's easier to understand the flow of the keywords and symbols.
11:21:36 <ekyo> hmm just to validate if I understood, liftM f m is equivalent to x >>= return . f
11:21:36 <kaiko> I have my own template engine and I'd like to provide printf functionality for my system users.
11:21:37 <ekyo> right?
11:21:49 <applicative> kaiko: use foldr or foldl'
11:21:57 <donri> @src liftM
11:21:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:22:08 <startling> isomorphismes: OK
11:22:39 <applicative> carter: I thought you were envisaging formulating an 'interface'
11:22:46 <carter> oh
11:22:49 <carter> maybe
11:22:55 <kaiko> applicative: foldl' didn't help
11:22:57 <carter> not thinking that far ahead right now :)
11:23:13 <donri> @. undo src liftM
11:23:13 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1);
11:23:29 * hackagebot singletons 0.8.6 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8.6 (RichardEisenberg)
11:24:06 <applicative> kaiko: I just meant that foldl is a bad function in general.
11:24:17 <dmj`> ekyo: yes you're right, your version is eta-reduced
11:24:36 <dmj`> kaiko: I think the issue is with your lambda expression
11:25:27 <dmj`> kaiko: with printf you don't need to know your arg count, it used template haskell I believe
11:25:32 <dmj`> uses*
11:25:50 <dmj`> > printf "%s %s" "hey"
11:25:51 <lambdabot>   No instance for (Text.Printf.PrintfType a0)
11:25:51 <lambdabot>    arising from a use of `e_1'
11:25:51 <lambdabot> ...
11:26:01 <ekyo> thanks a lot, finally starting to grasp a bit of Haskell syntax ;)
11:26:21 <kaiko> ok, I ask this way: if I have arguments in array then how can I use printf?
11:26:30 <dmj`> printer :: String -> String
11:26:30 <ekyo> still don't get the type signatures tough
11:26:34 <dmj`> printer xs = printf "hey" xs xs
11:26:44 <dmj`> printer xs = printf "%s %s" xs
11:27:01 <dmj`> should duplicate your string
11:27:12 <dmj`> ekyo: which signature?
11:27:42 <ekyo> well just having trouble in general with more complex type signatures for example
11:27:49 <ekyo> (Monad m) => (a1 -> r) -> m a1 -> m r
11:27:57 <ekyo> I don't know how to read this yet, it's all
11:28:00 <applicative> @type liftM
11:28:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:28:18 <applicative> the a1 and r are pretty hideous...
11:28:32 <arkeet> Monad m => (a -> b) -> (m a -> m b)
11:28:37 <applicative> ekyo: how about (a -> b) -> ...
11:28:41 <applicative> what arkeet says
11:28:53 <arkeet> it's fmap, for Monads
11:29:06 <ekyo> a function taking a and b returning '...' ?
11:29:16 <applicative> ekyo: read it putting 'list of' for m
11:29:19 <arkeet> do you understand map?
11:29:20 <arkeet> :t map
11:29:21 <lambdabot> (a -> b) -> [a] -> [b]
11:29:56 <arkeet> when you put m = [], liftM is the same as map
11:29:59 <ekyo> oh
11:30:18 <arkeet> but you could also put other things for m, like Maybe or IO or ...
11:30:19 <ekyo> so the arg is a function taking a returning b, applied to an array to return an array?
11:30:31 <applicative> ekyo: the m variable is filled with words like Maybe, IO , []
11:30:42 * applicative is echoing arkeet 
11:30:44 <arkeet> :t liftM :: (a -> b) -> [a] -> [b]
11:30:46 <lambdabot> (a -> b) -> [a] -> [b]
11:30:48 <arkeet> :t liftM :: (a -> b) -> IO a -> IO b
11:30:48 <lambdabot> (a -> b) -> IO a -> IO b
11:30:55 <arkeet> :t liftM :: (a -> b) -> Maybe a -> Maybe b
11:30:55 <lambdabot> (a -> b) -> Maybe a -> Maybe b
11:31:18 <arkeet> (it's usually preferable to use fmap instead of liftM, since it's more general)
11:31:43 <arkeet> > liftM (+5) [1,2,3]
11:31:44 <lambdabot>   [6,7,8]
11:31:47 <arkeet> > liftM (+5) (Just 8)
11:31:47 <applicative> i like liftM when i have a monad and a functor together, just to keep things straight
11:31:48 <lambdabot>   Just 13
11:31:57 <applicative> FreeT f m a invites using both
11:32:04 <arkeet> heh
11:32:17 <arkeet> I only really use liftM when writing monad-generic code.
11:32:26 <arkeet> to avoid introducing a Functor constraint.
11:32:43 <ekyo> I think I get it now ;) not enough to explain it yet, but enough to figure out how to call a function
11:33:12 <arkeet> in ghci, maybe try something like
11:33:19 <arkeet> liftM ("hello " ++) getLine
11:33:23 <arkeet> for an IO example.
11:34:39 <arkeet> although again in practice, usually it's better to use fmap
11:36:36 <dmj`> ekyo: have you taken a look at the typeclassopedia?
11:36:58 <dmj`> how do I use lambda bot to get the typeclassopedia link?
11:37:05 <arkeet> @where typeclassopedia
11:37:05 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:37:17 <dmj`> arkeet: ah thanks
11:37:33 <ekyo> nope, started haskell this morning, but just looked that up and knowing that a Monad is a Functor helps a lot ;)
11:37:38 <monochrom> I can't even spell "typeclassopedia" reliably
11:38:07 <ekyo> that lambdabot is quite useful
11:38:11 <dmj`> can lambda bot do spell check?
11:38:15 <Orxata_> Hi
11:38:28 <dmj`> @spellcheck
11:38:28 <lambdabot> Unknown command, try @list
11:38:38 <arkeet> @commands
11:38:39 <lambdabot> Unknown command, try @list
11:38:43 <arkeet> or whatever.
11:38:47 <arkeet> @list
11:38:47 <lambdabot> What module?  Try @listmodules for some ideas.
11:38:51 <arkeet> ugh
11:38:55 <arkeet> elliott: =(
11:38:57 <ekyo> @listmodules
11:38:57 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
11:38:57 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
11:39:04 <arkeet> you can do that in private
11:39:05 <arkeet> with lambdabot
11:40:42 <c_wraith> why aren't there IArray instances for UArray with the C types? :(
11:41:41 <mstksg> is "read" safe to run on unsanitized user input?
11:41:44 <jfischoff> is there a way to configure yesod to cancel a request if it takes too long?
11:42:21 <c_wraith> mstksg: it can throw exceptions, but it shouldn't execute code unless they also provided a read instance that you're using.
11:43:28 <c_wraith> mstksg: one thing to note is that read's behavior is controlled by the type you're expecting as the result. So you have full control there.
11:44:32 <applicative> instance Read PerlProgram where read ...
11:45:16 <arkeet> it's usually better to use something total like readMaybe.
11:45:27 <arkeet> because then you can catch failures.
11:45:37 <arkeet> (without going to IO.)
11:45:37 <applicative> instance Read Pandoc where read = readMarkdown defaultReaderOptions
11:45:42 <applicative> that's total
11:46:33 <carter> because the result type has a maybe :)
11:46:45 <applicative> @type read
11:46:45 <lambdabot> Read a => String -> a
11:47:11 <applicative> every unicode string is valid markdown
11:47:21 <carter> hehe
11:47:29 <carter> pandoc is an augmented markdown though :)
11:47:38 <applicative> valid pandoc too
11:47:48 <applicative> maybe its different now; i havent been following
11:51:23 <applicative> try cat /usr/share/dict/words | pandoc -r markdown -w native | HsColour
11:57:28 <applicative> hah, cat Data/Vector/Unboxed.hs | pandoc -r markdown -w latex -s -o a.tex gives valid tex, or anyway with warings only
12:00:01 <troydm> So i'm trying to find reason why yesod devel isn't working in my OpenIndian so i came to this line in verbose runghc output http://pastebin.com/dWHGf2pK is it okey?
12:00:06 <mauke> The paste dWHGf2pK has been copied to http://lpaste.net/91824
12:02:59 <geekosaur> that's a kinda useless snippet
12:04:14 <troydm> geekosaur: i can paste full output if you want to look through it
12:05:43 * geekosaur can't do a whole lot of looking right now, but pastebin the whole thing and hopefully someone can look through it
12:07:05 <troydm> suddenly pasting whole thing on lpaste and i get fd:16: commitBuffer: resource vanished (Broken pipe)
12:07:57 <troydm> does it have some limit on file paste?
12:08:22 <dmj`> troydm: try pastebin.com
12:08:44 <geekosaur> or gist.github.com
12:08:51 * geekosaur doesn't like pastebin.com much
12:09:01 <tikhon> yeah, GitHub is a much better option than pastebin
12:09:12 <troydm> pastebin.com seems have 500kb limit
12:10:07 <dymatic> Is there a limit to how much RAM Haskell objects can take up? I am trying to make a list of 60,000 strings in one source file, and I want to make sure it will work before I invest the time to do it.
12:10:13 <troydm> https://www.refheap.com/5fe71f376e6ae0155ca14eaa6
12:10:26 <troydm> and application exists after last line
12:10:40 <tikhon> dymatic: you might want to use a type other than String in this case
12:11:18 <geekosaur> dymatic, the only limit is what the OS will let your process have; but String is not exactly a compact data type
12:11:58 <dymatic> Thanks, I'll look into other text types. I remember hearing things about fast and byte strings.
12:12:12 <geekosaur> for Unicode strings you want to use Data.Text
12:12:28 <geekosaur> ByteStrings are best for octet strings as used by network protocols
12:13:07 <dmj`> string represents each char as 32-bits right? bytestrings use ascii as 8-bit chars by default. text uses unicode which uses 8-bits for english characters (same as ascii), and scales up for other countries
12:13:08 <dymatic> Alright, that sounds like a better idea than my brute-force list one.
12:13:53 <iteratee> dmj`: Bytestrings will represent 8-bit ascii if your import Data.ByteString.Char8 (or there's a lazy version)
12:14:11 <geekosaur> each character in a String is a 32-bit character + 32-bit(?) constructor + 32 or 64-bit link to the next character node
12:14:34 <dmj`> iteratee: What about just data.bytestring? Word8's are 8bit chars as well? Such a misnomer, Word8
12:15:04 <tikhon> wait, how is Word8 a misnomer?
12:15:22 <iteratee> dmj`: No Word8 is not an 8 bit character. It's an 8 bit word. You have to supply all values numerically.
12:16:21 <acowley> I think Word8 is a pretty good name for an 8-bit word.
12:16:29 <geekosaur> Char8 is the misnomer, since Haskell doesn't have a Char8, it just truncates Char-s indiscriminately
12:16:32 <startling> dmj`, ByteStrings do not use know anything about encoding
12:16:49 <dmj`> iteratee: Oh, good, clarity :) I assumed it was 8-bits per Char in a ByteString
12:16:57 <WraithM> This might be a dumb question, but is there a library that handles a lens of a GADT? Is that even a sensible question?
12:17:01 <tikhon> oh yeah, Char8 I could see as confusing, but not Word8
12:17:19 <arkeet> Char8 should be avoided.
12:18:13 <iteratee> arkeet: I view Char8 as a convenience when specifying protocols or parsers.
12:19:17 <WraithM> Nevermind. Dumb question.
12:20:01 <monochrom> Char8 was invented at a time when GHC's IO only did latin-1
12:20:20 <tikhon> WraithM: not really a dumb question—I think it's a fairly common source of confusion
12:20:47 <tikhon> I remember seeing something very similar on StackOverflow recently
12:23:08 <dmj`> Ok I'm curious now and still hazy on this. When reading a file with Data.ByteString.readFile. It can bloat memory (right?), since it's strict and has to read everything in at once. So using Data.ByteString.Lazy.readFile would be better, but this could break referential transparency (causing pure functions to perform IO), so we use iteratees instead? Which allow you to stream data in constant space. Is this thought process c
12:23:49 <tikhon> dmj`: seems reasonable
12:26:49 <Da1l> Hi, i saw "Data.HashTable will be removed in GHC 7.8. Please use an alternative, e.g. the hashtables package," when i've imported Data.HashTable.
12:27:27 <arkeet> indeed
12:27:29 <Da1l> But after looking at http://hackage.haskell.org/package/hashtables i've quickly noticed "mutable" word.
12:27:43 <arkeet> nothing wrong with controlled mutability.
12:27:48 <geekosaur> Data.HashTable is mutable as well, isnt it?
12:28:07 <monochrom> has always been mutable and stuck in IO or ST
12:28:08 <applicative> yes
12:28:09 <tikhon> In general, I think hash tables are more suitable for mutable computation
12:28:16 <geekosaur> yeh, it's all in IO
12:28:22 <arkeet> or ST
12:28:30 <tikhon> if you don't want mutability, use some sort of tree-based structure instead
12:28:59 <arkeet> Data.HashTable works in IO, too
12:29:05 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/i-tSKXkj9/
12:29:07 <arkeet> it doesn't even give you the option of ST
12:29:17 <geekosaur> yes, that's what I was referring to
12:29:24 <applicative> Da1l: there are things like hashmap and so on with lookup and delete and whatever all
12:29:35 <arkeet> hashmap.
12:29:36 <arkeet> =)
12:30:35 <Da1l> Hm, i'm not sure which datastructure to use, i though using hashes for my task was natural. I have to perform some statisitcs and store results in something and then easily access data in that something by say name like "totalStuff" "medianStuff" etc
12:30:38 <monochrom> unordered-containers. comes with Haskell Platform
12:31:18 <geekosaur> hashes are far from the only suitable structure for that. they're just the only one many languages provide
12:31:30 <ParahSailin> use hashtables, it will be good learning experience for ST monad
12:31:53 <Da1l> Using records for that seems a bit tedious since i may have quite a lot these "totalStuff".
12:32:35 <monochrom> it's kind of like Kleenex. you grow up in USA and you're used to saying "I'm sneezing, please pass me the Kleenex"
12:32:50 <monochrom> and then you go to Hong Kong and you find that it's Tempo there.
12:33:10 <Da1l> Maybe something like this: [(String,Int)]...
12:33:23 <Da1l> monochrom: Do you mean that hashes is Kleenex?
12:33:29 <geekosaur> you'll have to provide more detail on what you're doing
12:33:31 <monochrom> yes
12:33:31 <Da1l> What is Tempo then?
12:33:41 <dmj`> I'm still confused, I can see how to fit a Char into 8-bits, ord a == 97. But how do we fit a word (multiple chars) into 8-bits. Sorry if this is painful for some :) Using the Word8 type.
12:33:43 <monochrom> Kleenex and Tempo are both facial tissue paper
12:33:50 <maurer> Da1l: You're going to need to say what you want, but I suspect what you want is "Map String Int"
12:33:53 <geekosaur> your comment aout records implies that there's more than you are doing but we have no idea what
12:34:22 <monochrom> hash tables and search trees are both dictionaries
12:34:42 <maurer> Da1l: If you are trying to return a record of stats, then defining a record might make more sense than hashing strings
12:34:49 <Da1l> maurer: Yes, exactly, Data.Map seems to be what i want.
12:34:50 <ParahSailin> @hoogle Char -> Word8
12:34:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:34:51 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:34:51 <lambdabot> Prelude error :: [Char] -> a
12:34:58 <maurer> Da1l: Are you sure it is?
12:35:10 <maurer> Da1l: As I read up your scrollback I realized you seem to know the strings at compile time
12:35:18 <maurer> Which would suggest that a record might be more appropriate
12:35:18 <startling> monochrom: and then you're a little amused every time you read about applying computable functions to their source code?
12:36:15 <monochrom> I don't understand the connection. but yes.
12:36:32 <Da1l> maurer: Yes, Map should be okay, i'm not sure how many of these strings i will end up with. And it'll be conveniet to have ability to traverse all keys or all values or whatever.
12:36:56 <arkeet> use Map unless you know you'll need something else
12:36:59 <b2coutts> I blame perl for making people think hash table <=> dictionary
12:37:08 <Da1l> arkeet: Ha-ha, shure.
12:37:20 <maurer> arkeet: My worry here is that he's using a map to store properties, which is kind of wasteful
12:37:41 <geekosaur> b2coutts, poerl only picked it up from awk
12:37:50 <b2coutts> oh, I haven't used awk
12:37:54 <b2coutts> I blame awk too then
12:38:19 <geekosaur> awk is what everyone used for this before perl or python existed :)
12:38:32 <arkeet> ok sure, it might make less sense if you know the keys in advance.
12:38:52 <startling> Da1l: this sounds like the place to define a record, yeah
12:38:59 <arkeet> I didn't read the problem description.
12:39:09 <maurer> arkeet: Yeah, I am unsure of his exact situation, but if he knows the keys in advance he should be applying recordmoed
12:39:29 <Da1l> Is it possible to encode records in say JSON?
12:39:47 <scshunt> Da1l: see aeson
12:39:48 <Ralith> dmj`: you can't fit a char into 8 bits.
12:39:50 <ParahSailin> it is possible to parse json to records
12:40:02 <ParahSailin> and the reverse
12:40:22 <Da1l> Okay, thank you guys, i have to think a little about records vs maps.
12:41:12 <ParahSailin> dont use a map if its two pieces of data
12:41:16 <nooodl> how can i make ghci "forget" about an earlier "let" statement?
12:41:26 <ParahSailin> if its like 15 maybe dont use a record
12:41:29 <scshunt> nooodl: in a do block?
12:41:30 <nooodl> or ideally, redefine a value
12:41:31 <arkeet> nooodl: you can't.
12:41:37 <arkeet> if you want to redefine one, just do it
12:41:45 <arkeet> and it'll shadow the old definition
12:42:19 <arkeet> > do {let a = 1; let a = 2; [a]}
12:42:20 <lambdabot>   <hint>:1:30: parse error on input `}'
12:42:33 <arkeet> oh.
12:42:54 <arkeet> > do {let {a = 1}; let {a = 2}; [a]}
12:42:55 <lambdabot>   [2]
12:43:03 <nooodl> oh, i see why it wasn't working now
12:43:08 <arkeet> =)
12:43:37 <nooodl> i'd done something like, let a = 1; let a = a + 1... trying to reference the earlier definition of 'a'
12:43:52 <monochrom> too bad
12:43:54 <arkeet> aha.
12:43:59 <arkeet> yes, let is recursive.
12:44:01 <monochrom> would work in ocaml :)
12:44:23 <monochrom> and oleg was lamenting that haskell isn't like ocaml :)
12:44:24 <kakos> What editor/IDE does everyone here use for Haskell?
12:44:31 * arkeet vim
12:44:35 <soulrain> vim
12:44:38 <bscarlet> emacs
12:44:43 <luite> everyone uses leksah
12:44:49 <monochrom> I use emacs. sometimes nano. and notepad++ when in windows
12:45:19 <kakos> Notepad++ supports haskell?
12:45:33 <kakos> Nice
12:46:13 <nooodl> what do you mean by "supports"
12:46:29 <hvr> cat
12:46:32 <nooodl> i mean, notepad.exe "supports" haskell, you can save .hs files with it!
12:46:33 <arkeet> dog
12:46:40 <monochrom> every newbie complains about being unable to install leksah. http://dorinlazar.ro/haskell-platform-windows-crippled/
12:46:47 <Adeon> I'm sure if the colors aren't right, it won't compile
12:46:53 <Adeon> therefore you need an editor that supports the correct colors
12:47:47 <kakos> nooodl: Syntax highlighting, proper indentation, etc.
12:48:20 <kakos> Leksah installed just fine. Just wondering what people use as a matter of curiosity
12:48:36 <monochrom> oh, lucky you
12:49:15 <danr> vim with vim2hs
12:50:05 <dmj`> long live visual haskell, http://research.microsoft.com/apps/pubs/default.aspx?id=67496
12:50:26 <kakos> dmj`: I was actually wondering about that. Is there any place it can actually be downloaded?
12:51:04 <Ralith> kakos: if, as is likely, it hasn't been updated, you are unlikely to be able to get it to run on a recent environment
12:51:16 <dmj`> kakos: You can find the source probably, won't be an easy find. Prob only works on old ghc
12:51:30 <kakos> Ralith: Well, was hoping to find the source and perhaps update it if I had the free time
12:51:56 <dmj`> was probably written in vb.net :)
12:52:12 <dmj`> here's the paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.75.2332&rep=rep1&type=pdf
12:52:40 <Ralith> kakos: the source for a visual studio extension? Licensing might be an issue.
12:53:12 <monochrom> I forgot. there is manatee.
12:55:30 <shajra> okay, so another programming community is debating what it means to pass or not pass monad laws.
12:56:05 <shajra> the monad laws do not presume that all input functions are total functions, right?
12:56:07 <Twey> dmj`: ‘Word’ just means an unsigned integer of the specified size with overflow.  Word8 is equivalent to a usual ‘unsigned char’.  Char is *not* like a C ‘char’: it represents a Unicode code-point, which means it's bigger than eight bits.
12:56:26 <Cale> shajra: I would only require them to hold on totally-defined data.
12:56:29 <shajra> if a function throws an exception, then we should expect equational reasoning to hold?
12:56:49 <Cale> shajra: But you can analyse whether or not they hold in a more general way
12:56:56 <Twey> > [maxBound :: Word8, maxBound + 1]
12:56:57 <lambdabot>   [255,0]
12:57:42 <shajra> Cale: the problem is that we have monad implementations for something like an Either that are swallowing exceptions to the left side.
12:57:43 <Twey> > [maxBound :: Char, succ maxBound]
12:57:45 <lambdabot>   "\1114111*Exception: Prelude.Enum.Char.succ: bad argument
12:58:19 <LambdaDusk> is it possible to include the .a or entire C-source of a necessary library in a cabal lib?
12:58:32 * hackagebot cipher-aes 0.2.2 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.2 (VincentHanquez)
12:58:36 <dcoutts> LambdaDusk: .c files yes, .a no
12:58:59 <Cale> shajra: return = Right; Left e >>= f = Left e; Right x >>= f = f x -- yes?
12:59:00 <dcoutts> LambdaDusk: for pre-compiled things, it's expected to be already installed on the system
12:59:05 <shajra> Cale: and people either say "monad laws are fine, because all bets are off when an exception is thrown" and others expect errors the remain consistent through the substitution model.
12:59:32 <LambdaDusk> dcoutts: But I can include c-source that comes with a .configure
12:59:48 <dcoutts> LambdaDusk: only with custom code in Setup.hs
13:00:16 <Cale> shajra: Can you give an example of an exception which is eaten?
13:00:22 <LambdaDusk> dcoutts: Any docs on that
13:00:36 <shajra> Cale: it's in another language, I can probably transpose to Haskell.
13:00:38 <Cale> shajra: I suppose  Left e >>= undefined  would result in Left e
13:00:39 <dcoutts> LambdaDusk: Cabal user guide, and Cabal api docs
13:00:51 <dcoutts> LambdaDusk: and examples of custom Setup.hs on hackage
13:01:07 <Cale> shajra: Which language?
13:01:13 <shajra> Cale: it's Scala.
13:01:16 <Cale> ah, okay
13:01:21 <affa> hey, is there an elegant way to make [Either a b] -> Either a [b]?
13:01:26 <shajra> but I'm trying to keep that aspect of the discussion beyond the scope.
13:01:30 <Twey> affa: mapM
13:01:31 <shachaf> affa: sequence
13:01:31 <Cale> affa: sequence
13:01:31 <Fuuzetsu> :t sequence
13:01:32 <shajra> it's true that it's strict.
13:01:32 <lambdabot> Monad m => [m a] -> m [a]
13:01:36 <Twey> Er, sequence.  T_T
13:01:44 <LambdaDusk> dcoutts: I was looking there, but Build-type: configure is not exactly well documented
13:01:48 <Cale> :t mapM return
13:01:49 <lambdabot> Monad m => [b] -> m [b]
13:01:53 <Cale> er
13:01:56 <Cale> :t mapM id
13:01:57 <lambdabot> Monad m => [m b] -> m [b]
13:01:57 <Twey> :t mapM id
13:01:58 <lambdabot> Monad m => [m b] -> m [b]
13:01:59 <Twey> Yeah
13:02:13 <affa> sweet, thanks
13:02:14 <dcoutts> LambdaDusk: oh you can use that too, it just runs ./configure during the configure phase, and that can do whatever it likes
13:02:44 <LambdaDusk> dcoutts: So I could just copy the lib's configure? What about windows?
13:02:57 <shajra> Cale: perhaps the fact that this is a strict language is actually very important.
13:03:12 <shajra> especially when it comes to bottom.
13:03:13 <dcoutts> LambdaDusk: ./configure scripts will not work on windows for most users (only those using mingw etc)
13:03:39 <Twey> LambdaDusk: How is your C library supposed to be compiled on Windows?
13:03:42 <Cale> shajra: Well, in a strict language, you tend not to even discuss bottom as a value.
13:03:52 <kuribas> Is there a function that tests if a number is between two other numbers?
13:04:11 <shajra> Cale: okay, so this is kind of interesting.
13:04:19 <byorgey> kuribas: not in the standard libraries.
13:04:25 <kuribas> byorgey: ok
13:04:29 <shajra> that bottom is a value in a non-strict language, but not in a strict one.
13:04:46 <LambdaDusk> dcoutts, twey: Ok, the background is I wanna write SDL 2.0 bindings. The old SDL bindings are a HUGE pain on windows (i.e. never got it run even once), and I thought I could include SDL sources like GLFW does
13:04:48 <shajra> that assymmetry seems suspicious to me, though.
13:05:01 <Cale> shajra: Well, the reason being that you kind of need nonstrict semantics for anything interesting to happen with respect to bottom at all.
13:05:15 <Cale> In a strict language, you know that f _|_ = _|_ for every function f.
13:05:23 <dcoutts> LambdaDusk: right, makes sense. I do the same for zlib on Windows, but zlib doesn't need any ./configure script.
13:05:42 <shajra> Cale: well, that's exactly what we're violating.
13:05:47 <Cale> and that includes data constructors
13:05:50 <shajra> we're not getting that result for a particular abstraction.
13:05:55 <Cale> How are you violating it?
13:06:01 <LambdaDusk> dcoutts: I don't know if it -needs- a ./configure but it has to find out if windows and such
13:06:02 <Twey> LambdaDusk: Most Windows users aren't going to have a C compiler installed, I'd guess
13:06:16 <LambdaDusk> Twey: They do, it comes with ghc
13:06:25 <Twey> gcc does?
13:06:25 <dcoutts> LambdaDusk: if it's that simple, you can do it with just the .cabal file
13:06:44 <LambdaDusk> Twey: yes
13:06:45 <dcoutts> LambdaDusk: if os(windows) { cc-options: -DBlah }
13:06:55 <Twey> Oh, okay.  Cool.
13:07:10 <Cale> You can't violate it in a strict setting, because you always evaluate the arguments first, and if they're nonterminating, you have no way to escape.
13:07:26 <LambdaDusk> dcoutts: So I just have to find out with .c are in the windows build and add them to the c-sources of cabal?
13:07:26 <luite> should enabling TypeFamilies make local let-bound functions less polymorphic?
13:07:47 <Fuuzetsu> IIRC yes
13:07:48 <shajra> is we have an errant f :: Int -> Try Int such that f 0 = ⊥, then we have implicit exception handling such that f 0 = Failure
13:07:52 <dcoutts> LambdaDusk: take a look at the zlib package for an example
13:07:52 <shajra> if we...
13:08:18 <Cale> Oh, your monad instance uses catch?
13:08:20 <shajra> Cale: this debate has surfaced repeatedly.
13:08:21 <shajra> yup.
13:08:27 <Cale> Oh, that's obviously derpy.
13:08:47 <thoughtpolice> luite: no, but GADTs will
13:09:01 <thoughtpolice> well, at least I *think* GADTs is the only thing that implies MonoLocalBinds
13:09:03 <shajra> yeah, so I'm just checking with this community that derpy is derpy is derpy, regardless of languages.
13:09:21 <Fuuzetsu> thoughtpolice: I thought TypeFamilies affected it too… http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
13:09:29 <luite> thoughtpolice: hmm, oh i though the local binds policy was changed regardless of extensions
13:09:36 <Fuuzetsu> >The flags -XGADTs or -XTypeFamilies, or the corresponding LANGUAGE pragmas, imply the (new) flag -XMonoLocalBinds.
13:09:39 <thoughtpolice> Fuuzetsu: ah, you're right
13:09:42 <thoughtpolice> i misremembered
13:09:48 <luite> ok tnx
13:09:51 <LambdaDusk> dcoutts: Ah I see... it looks for zlib if not on windows
13:09:57 <Cale> Even from a totally pragmatic perspective, that's terrible, because you'll lose exception information.
13:10:17 <dcoutts> LambdaDusk: people prefer using the system lib on linux
13:10:23 <luite> i'll just add some type sigs then :)
13:10:41 <LambdaDusk> dcoutts: Yes, I know, but as I said, SDL was a pain on windows
13:10:48 <Cale> and you might actually want to be able to signal an exception to a wider scope than is being managed by the Either
13:10:53 <Cale> (or Try)
13:11:07 <dcoutts> LambdaDusk: right, so that's why we use the bundled one on windows for zlib
13:11:27 <shajra> Cale: I'm simplifying the example, the exceptional information is maintained in the Failure case.
13:11:40 <Cale> shajra: What if it's the wrong type?
13:11:43 <LambdaDusk> dcoutts: Though there's this SDL_main.a business on Windows that necessary
13:11:55 <shajra> Cale: the JVM has this thing called Throwable. . . that sucks.
13:12:07 <Cale> Oh, so this is like Either Throwable?
13:12:11 <shajra> yup.
13:12:13 <Cale> hmm
13:12:19 <shajra> with an implicit try-catch.
13:12:31 <Cale> Yeah, I'm not sure that's really the right thing even so.
13:12:59 <Cale> It's slightly more reasonable than otherwise, I suppose.
13:13:13 <shajra> barely in the single-threaded case.
13:13:26 <shajra> my thought experiment is when we have multiple threads.
13:14:02 <shajra> if a thread throws an exception, we have hung threads on the JVM, but that's absolutely unacceptable.
13:14:05 <Cale> Catching exceptions from what ought to be pure code is bad practice though, imo.
13:15:01 <shajra> Cale: I think my attempts to "keep the Scala" out of the discussion failed.
13:15:05 <Cale> (throwing exceptions is a bit bad too, but at least you can semantically consider them nontermination)
13:15:24 <Cale> If you catch exceptions, then you can violate referential transparency.
13:15:31 <shajra> yup.
13:15:35 <LambdaDusk> dcoutts: zlib is a good example, SDL is under zlib license, can I just include it like that?
13:15:44 <Cale> So, if it can be avoided, I think it should be.
13:16:06 <dcoutts> LambdaDusk: I'm not sure what you're asking precisely
13:16:22 <shajra> in practice, we're avoiding Try, but it's in the standard library.
13:16:29 <shajra> Cale: by the way, thanks for the chat on this.
13:16:40 <LambdaDusk> dcoutts: am I allowed to steal SDL source for my project and include it?
13:16:40 <Cale> You could always throw in something like  try :: a -> Try a  which catches the exception and promotes it to a value, but would be used explicitly.
13:17:08 <shajra> Cale: right, but people want their monad sugar to be non-monadic.
13:17:15 <shajra> which gets to a larger discussion.
13:17:15 <dcoutts> LambdaDusk: you can distribute the SDL sources as long as you comply with its license
13:17:21 <Cale> Of course, in Haskell, that'd be:
13:17:22 <Cale> :t try
13:17:23 <lambdabot> Exception e => IO a -> IO (Either e a)
13:17:35 <dcoutts> LambdaDusk: I believe the zlib package complies with the zlib C source code's license
13:18:39 <shajra> Cale: one source of defects from this is really clear.
13:18:52 <shajra> the number of places handling needs to be placed is now in two places.
13:19:17 <shajra> first on functions that naturally bottom out, and secondly on Try expressions.
13:19:29 <Cale> Well, that's fine.
13:19:36 <Cale> Those are two quite different things.
13:19:39 <shajra> one or the other is ommitted, then the program has a defect.
13:19:43 <Cale> (In my opinion)
13:20:00 <shajra> not if we're using monads that presume a unit law, right?
13:20:23 <Cale> In Haskell, we tend to use error (bottoming out) for cases where the program is entirely garbage and we want to die and not catch the failure.
13:20:41 <shajra> right, that makes sense too.
13:20:57 <Cale> and we use Either for the cases which we definitely want to handle
13:21:03 <Cale> IO exceptions fall somewhere in between
13:21:29 <FreeFull> Maybe for the cases where you want to handle it and don't care about why the error occured
13:21:44 <shajra> I think one reason that all this ends up being a spiralling debate is because at this point of the program, everything is so unrecoverable, we're really just arguing about how to be wrong the right way.
13:22:38 <shajra> by not programming with total functions, the Scala community has set themselves up for something awkward.
13:22:42 <Cale> Well, kind of. I would expect computations in the monad to eventually be run in a context which does handle the failing case -- in fact, perhaps the "failure" isn't even a failure, but a representation of how to proceed.
13:24:03 <LambdaDusk> dcoutts: On GHC, I can assume most C standard libs are present?
13:24:08 <Cale> But if you bottom out in that code, it means you don't want the error handled, you just want to die.
13:24:30 <Cale> LambdaDusk: What do you mean by that?
13:25:04 <LambdaDusk> Cale: checking for malloc, math.h, etc within the ./configure...
13:25:08 <shajra> Cale: right, but Try gives us the illusion of something between success and failure.
13:25:34 <kuribas> Can I rely on (1/0) returning Infinity?
13:25:48 <Cale> kuribas: when the type is Float or Double, yes.
13:25:59 <kuribas> Ok.
13:26:07 <FreeFull> I think the floating point standard might guarantee that
13:26:14 <Cale> :t isInfinite
13:26:15 <lambdabot> RealFloat a => a -> Bool
13:26:28 <Kaini> @src isInfinite
13:26:28 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:26:34 <Cale> It's a class method
13:26:49 <Kaini> Bah :P
13:27:02 <int-e> > isIEEE 0.0
13:27:03 <lambdabot>   True
13:27:13 <shajra> Cale: thanks again for the chat; I think I'm walking away with some similar opinions, but they're getting more rigid.
13:27:34 <FreeFull> :t isIEEE
13:27:35 <lambdabot> RealFloat a => a -> Bool
13:27:46 <kuribas> > 1 / (-0)
13:27:47 <lambdabot>   -Infinity
13:27:53 <FreeFull> > 0/0
13:27:54 <lambdabot>   NaN
13:28:09 <FreeFull> > read "NaN" :: Float
13:28:10 <lambdabot>   NaN
13:28:13 <Cale> shajra: Yeah, if it were up to me, I'd just mimic what  Either SomeException  would behave like in Haskell.
13:28:51 <Cale> shajra: and implement bind in the simple referentially transparent way which doesn't involve catch.
13:29:49 <Cale> and then implement something like try which would explicitly promote exception-throwing general computations to ones which we're treating with our Try monad.
13:30:17 <Cale> That would give you lots of control over exactly which exceptions you're attempting to deal with.
13:31:35 <shajra> Cale: I agree, but people are just trying to make the Scala equivalent of do-sugar address "DSLs" for non-monadic use.
13:32:12 <shajra> Cale: for Try, this seems like a net loss.
13:33:46 <shajra> or at least in the noise.
13:35:50 <dagano> beginner question : i have fcn 'return' defined in my .hs and i want to use it at the end of a do-block, why is ghci freaking out that return is defined in my file but also in GHC.base?  I am coming from a world of overloading and namespaces that probably doesn't apply here
13:36:35 <donri> dagano: you need to write a Monad instance for your type
13:36:55 <donri> dagano: or side-step the implicit prelude import
13:37:00 <donri> (not recommended)
13:37:13 <FreeFull> dagano: If you want to use your own functions that overlap with functions declared in typeclasses, you have to use the full module name
13:37:30 <dagano> right .. i guess i could exclude 'return' with a qualified import ..but yeah that doesn't seem very principled
13:37:51 <dagano> i am just using :l file.hs
13:37:56 <greg`> i want to create a range from a divided number like [1..n/2]
13:37:58 <dagano> shoudl I use :module?
13:38:00 <greg`> how can i do that
13:38:13 <donri> dagano: why do you want to use 'return'?
13:38:55 <dagano> well ... 'my file' is somebody else's file ... specifying a parser and some basic parser primitives
13:38:59 <dagano> and return is there
13:39:00 <dagano> :)
13:39:52 <h4199> greg: do you want a list of Ints?
13:40:15 <donri> dagano: return is standard, you don't need to add it
13:41:07 <greg`> yes
13:41:17 <greg`> h4199: yes
13:41:29 <dagano> @donri . ok thanks .. i'll think about that
13:41:29 <lambdabot> Unknown command, try @list
13:41:44 <FreeFull> greg`: Try [1..n`div`2]
13:42:01 <h4199> > let n = 10 in [1..div n 2]
13:42:01 <greg`> thanks
13:42:02 <lambdabot>   [1,2,3,4,5]
13:42:07 <FreeFull> greg`: div is for integer division, / is for fractional/floating division
13:42:53 <greg`> thanks
13:44:24 <greg`> also its a bit annoying that i cant generate a list counting down withouth specifying two leading numbers
13:44:37 <greg`> so im trying to create a huge list but in reverse
13:44:55 <greg`> and i cant do [99992193919321..1]
13:45:01 <greg`> thats annoying
13:45:15 <dagano> greg . specify the one before it
13:45:19 <c_wraith> you just have to give it a hint
13:45:22 <dagano> [10,9..1]
13:45:32 <greg`> i have to do [8989389218391898,8989389218391897..1]
13:45:40 <donri> it's weird that it can't figure that out though when it does it just fine forwards
13:45:40 <oleo> 
13:45:41 <greg`> thats a pain in the butt
13:45:45 <oleo> lol
13:45:50 <dmj`> > take 4 $ iterate (\x -> x - 1) 100
13:45:51 <lambdabot>   [100,99,98,97]
13:46:02 <acowley> > take 3 $ iterate (subtract 500062) 999992193919321
13:46:04 <lambdabot>   [999992193919321,999992193419259,999992192919197]
13:46:12 <arkeet> > takeWhile (>0) . iterate (subtract 1) $ 100
13:46:14 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
13:46:30 <arkeet> > takeWhile (>0) . iterate pred $ 100
13:46:31 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
13:46:38 <acowley> So many options!
13:46:42 <dagano> hahah
13:46:45 <greg`> hmmmm ok
13:46:50 <dmj`> > take 4 $ iterate ((-)1) 100
13:46:51 <lambdabot>   [100,-99,100,-99]
13:46:53 <greg`> will look at this iterate business
13:46:59 <dmj`> oops
13:46:59 <greg`> is iterate lazy?
13:47:01 <arkeet> with a number as large as 99992193919321, you won't ever hit the end of the list, so no need for takeWhile either ;-)
13:47:03 <Cale> greg`: yes
13:47:04 <arkeet> yes
13:47:36 <c_wraith> donri: "figure it out" is quite a lot to ask.  Maybe you passed in constants and wanted it to go backwards.  maybe you passed in variables and wanted an empty list if end was higher than start.  It can't know the difference.
13:47:42 <FreeFull> donri: If it did make backwards lists by default, stuff like   fact n = product [2..n]    wouldn't work right
13:47:42 <greg`> thanks again
13:47:43 <Cale> > (\x -> [x,x-1..1]) 99992193919321
13:47:44 <lambdabot>   [99992193919321,99992193919320,99992193919319,99992193919318,99992193919317...
13:47:50 <Cale> You could always do that
13:48:00 <donri> good points
13:48:11 <Cale> Or of course, let x = ... in [x,x-1..1]
13:48:15 <donri> needs moar dependent types
13:48:17 <c_wraith> err, if the start was higher than the end.
13:48:30 <dagano> what is 'pred'?
13:48:35 <arkeet> predecessor
13:48:38 <dagano> ahh
13:48:39 <h4199> :t pred
13:48:39 <arkeet> inverse of succ
13:48:39 <dagano> durr
13:48:39 <lambdabot> Enum a => a -> a
13:48:40 <donri> > pred True
13:48:41 <acowley> : pred
13:48:41 <lambdabot>   False
13:48:45 <acowley> :i pred
13:48:54 <acowley> d'oh, no :info on lambdabot
13:49:06 <arkeet> it's in the ENum class
13:49:11 <arkeet> er, Enum.
13:49:12 <acowley> > pred False
13:49:13 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
13:49:14 <acowley> :(
13:49:17 <h4199> > pred '2'
13:49:17 <lambdabot>   '1'
13:49:18 <FreeFull> > succ False
13:49:18 <lambdabot>   True
13:49:23 <FreeFull> > pred False
13:49:24 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
13:49:27 <FreeFull> > pred True
13:49:28 <lambdabot>   False
13:49:47 <dagano> pred false does that .. booo ..
13:51:03 <dagano> :t iterate
13:51:04 <lambdabot> (a -> a) -> a -> [a]
13:51:07 <dagano> > :t iterate
13:51:08 <lambdabot>   <hint>:1:1: parse error on input `:'
13:51:15 <dagano> urrmmmm
13:51:20 <kuribas> Why isn't there a elseif syntax?
13:51:24 <FreeFull> > iterate id 2
13:51:25 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
13:51:29 <arkeet> kuribas: there is else if
13:51:38 <Twey> kuribas: There is also case
13:51:39 <hpc> kuribas: use guards
13:51:45 <arkeet> but yes, you probably should be using something else
13:51:46 <johnw> kuribas: also, if/else/if chains are almost always the wrong pattern
13:51:46 <arkeet> :)
13:51:46 <hpc> or case-of
13:52:03 <k00mi> or MultiWayIf!
13:52:11 <arkeet> @src iterate
13:52:11 <lambdabot> iterate f x =  x : iterate f (f x)
13:52:12 <Twey> case () of () | ifthis → thenthis | elseifthis → thenthat | otherwise → dothis
13:52:23 <donri> @hackage cond ;)
13:52:23 <lambdabot> http://hackage.haskell.org/package/cond ;)
13:52:25 <arkeet> I like  iterate f x = x : map f (iterate f x)
13:52:28 <kuribas> johnw: I don't see why.  It's like COND in LISP.
13:52:30 <arkeet> but that's not as good
13:52:42 <arkeet> kuribas: well, haskell can do better ;)
13:53:08 <dagano> arkeet : is there an @src equivalent in ghci?
13:53:17 <arkeet> dagano: @src is really dumb, it just looks up a fixed database
13:53:18 <arkeet> @where src
13:53:19 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
13:53:29 <Twey> kuribas: Haskell isn't CL; the designs are significantly different.  Haskell prioritizes functions more, so a solution involving functions is preferable (e.g. a monad, or some kind of eliminator)
13:53:36 <FreeFull> > iterate id 2 :: [Expr]
13:53:37 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
13:53:41 <shachaf> Or, y'know, pattern-matching.
13:53:45 <arkeet> ^
13:53:51 <FreeFull> > iterate (+1) 0 :: [Expr]
13:53:52 <lambdabot>   [0,0 + 1,0 + 1 + 1,0 + 1 + 1 + 1,0 + 1 + 1 + 1 + 1,0 + 1 + 1 + 1 + 1 + 1,0 ...
13:54:06 <FreeFull> Ok, that doesn't really make it clear
13:54:07 <shachaf> @where boolean-blindness
13:54:08 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:54:09 <FreeFull> > iterate f 0 :: [Expr]
13:54:10 <lambdabot>   [0,f 0,f (f 0),f (f (f 0)),f (f (f (f 0))),f (f (f (f (f 0)))),f (f (f (f (...
13:54:15 <arkeet> > case () of _ | False -> 1 | True -> 2 | False -> 3
13:54:17 <lambdabot>   2
13:54:20 <donri> question should be "why is there if" [rather than bool :: a -> a -> Bool -> a]
13:54:23 <Twey> shachaf: Pattern-matching being some kind of eliminator :þ
13:54:31 <shachaf> Twey: But not a function.
13:54:47 <shachaf> Haskell is pretty value-oriented.
13:54:59 <arkeet> can I have first-class patterns yet
13:55:08 <acowley> Oh how I long for bool to be in the prelude
13:55:10 <shachaf> arkeet: lenses and prisms hth
13:55:11 <donri> arkeet: prisms! yay!
13:55:12 <arkeet> and don't say prism
13:55:13 <arkeet> :D
13:55:24 <arkeet> it would be cool to have a nicer syntax for them.
13:55:25 <donri> arkeet: view patterns!
13:55:27 <kuribas> With all respect, but writing a function only to use guards, or (ab)using a case construct is more ugly.
13:55:31 <arkeet> maybe!
13:55:41 <FreeFull> Maybe edwardk is part of the NSA
13:56:05 <Twey> kuribas: The underlying advice is to prefer encoding your ‘conditional’ in the data-type, rather than performing a series of boolean tests
13:56:07 <donri> maybe lens is really written by that other edward?
13:56:27 <kuribas> Twey: Which datatype?
13:56:40 <Twey> kuribas: Whatever data-type you're using
13:56:50 <shachaf> I suppose no one read that boolean-blindness link above.
13:57:00 <Twey> I was just about to re-link it :þ
13:57:03 <donri> kuribas: recent GHC has multi-way if anyway
13:57:09 <kuribas> Twey: I am just testing some doubles.
13:57:20 <arkeet> multi-way if is just abbreviating "case () of _" to "if"
13:57:48 <donri> https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/basic-syntax-extensions#multiwayif
13:57:51 <Twey> kuribas: If we knew more about your program we might be able to show you a better way of representing it
13:58:01 <donri> IIRC it's broken though
13:58:11 <arkeet> > case Right 3 of Just a <- preview _Right -> a
13:58:12 <lambdabot>   <hint>:1:24: parse error on input `<-'
13:58:17 <arkeet> er
13:58:18 <monochrom> if you want to use a chain of if-then-else's, go ahead, I do it too
13:58:21 <donri> i think it isn't a layout herald so it breaks nesting
13:58:30 <arkeet> I forget how view patterns work.
13:58:45 <Twey> arkeet: (function → identifier)
13:58:49 <arkeet> > case Right 3 of preview _Right -> a -> a
13:58:50 <lambdabot>   <hint>:1:17: Parse error in pattern: preview
13:58:57 <kuribas> Twey: Ok, just a minute
13:58:58 <Twey> With brackets
13:58:59 <arkeet> > case Right 3 of (preview _Right -> a) -> a
13:59:00 <lambdabot>   Illegal view pattern:  preview _Right -> a
13:59:00 <lambdabot>  Use -XViewPatterns to enable vi...
13:59:00 <donri> arkeet: (f -> p) applies f and pattern matches on p
13:59:04 <arkeet> =(
13:59:08 <Twey> Heh
13:59:46 <arkeet> > case Right 3 of x | a <- preview _Right x -> a
13:59:48 <lambdabot>   Just 3
13:59:52 <arkeet> oops
13:59:57 <arkeet> > case Right 3 of x | Just a <- preview _Right x -> a
13:59:59 <lambdabot>   3
14:00:32 <Twey> λbot allows pattern guards but not view patterns?  What madness is this?
14:00:33 <elliott> > case Right 3 of (preview _Right -> Just a) -> a
14:00:35 <lambdabot>   Illegal view pattern:  preview _Right -> Just a
14:00:35 <lambdabot>  Use -XViewPatterns to enab...
14:00:44 <donri> Twey: Haskell2010?
14:00:54 <Twey> Did view patterns not make the cut?
14:00:58 <monochrom> pattern guard is squarely in Haskell 2010
14:01:02 <Twey> How sad
14:01:49 <c_wraith> I'm mildly annoyed cabal disables haskell 2010 by default.
14:02:24 <donri> i think there was talk of adding default-language:Haskell2010 to cabal init
14:02:58 <donri> and by talk i mean tibbe mentioning it in passing on IRC to dcoutts
14:03:25 <dcoutts> donri: cabal init now asks you
14:03:32 <dcoutts> What base language is the package written in:
14:03:32 <dcoutts>  * 1) Haskell2010
14:03:32 <dcoutts>    2) Haskell98
14:03:32 <dcoutts>    3) Other (specify)
14:03:37 <donri> ah cool
14:03:41 <c_wraith> It does?  oh!  in new versions of cabal.  that I don't have yet.
14:03:49 <dcoutts> c_wraith: we couldn't change it, or we'd break all the old packages
14:04:02 <c_wraith> psh, you'd break some old packages.  Not all of them
14:04:03 <c_wraith> :)
14:04:07 <donri> dcoutts: is this HEAD or .16?
14:04:12 <dcoutts> head I think
14:04:18 <kuribas> Twey: https://github.com/kuribas/cubicbezier/blob/master/Geom2D/CubicBezier/Curvature.hs
14:04:39 <dcoutts> c_wraith: also, we now force you to decide
14:04:46 <dcoutts> * Packages using 'cabal-version: >= 1.10' must specify the 'default-language'
14:04:46 <dcoutts> field for each component (e.g. Haskell98 or Haskell2010). If a component uses
14:04:46 <dcoutts> different languages in different modules then list the other ones in the
14:04:46 <dcoutts> 'other-languages' field.
14:04:53 <johnw> if `f` is a strict operator, does foldl' has the advantage over foldr by being tail-recursive?
14:04:59 <dcoutts> c_wraith: is the warning you get
14:05:09 <c_wraith> Oh, I like that approach.
14:05:17 <dcoutts> c_wraith: ie if you opt-in to using a later Cabal spec
14:05:37 <dcoutts> packages using older Cabal spec versions keep the same semantics
14:05:45 <c_wraith> makes sense.
14:05:47 <dcoutts> so we don't break things
14:06:32 <kuribas> Twey: In the last function (findRadius).
14:06:34 <dcoutts> johnw: yes
14:09:05 <johnw> is there a use case for foldl?
14:09:25 <shachaf> Yes.
14:09:48 <shachaf> @google foldr foldl foldl'
14:09:54 <johnw> ok, thanks
14:10:00 <shachaf> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
14:10:22 <shachaf> Hmm, a simpler use case than that wiki page mentions is "last".
14:11:24 <startling> > foldl (const . Just) Nothing [1, 2, 3]
14:11:37 <shachaf> Yes, well, no lambdabot.
14:11:49 <startling> I was wrong anyway. :(
14:11:57 <b2coutts> also, head
14:12:05 <shachaf> ?
14:12:20 <shachaf> Anyway:
14:12:21 <shachaf> λ> foldl (\_ x -> x) (error "last: empty list") [1,undefined,3]
14:12:22 <shachaf> 3
14:12:22 <shachaf> λ> foldl' (\_ x -> x) (error "last: empty list") [1,undefined,3]
14:12:22 <shachaf> *** Exception: Prelude.undefined
14:12:34 <quchen> I think head might be better implemented using foldr, b2coutts.
14:12:41 <johnw> thanks very much, shachaf, that's quite clear
14:12:49 <quchen> Or even better, head might not be implemented.
14:12:56 <b2coutts> oh, I kind of just saw the url and assumed all were fair game
14:13:33 * hackagebot hspec 1.7.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.7.0 (SimonHengel)
14:15:03 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#haskell2010
14:16:56 <kuribas> Twey: never mind
14:17:22 <monochrom> I can sympathize with defaulting to haskell98. for fear of obsoleting some valuable old packages on hackage
14:22:26 <startling> cabal init is so nice. it's too bad you can only do it once.
14:23:39 * hackagebot hspec-smallcheck 0.0.0 - SmallCheck support for the Hspec testing framework  http://hackage.haskell.org/package/hspec-smallcheck-0.0.0 (SimonHengel)
14:24:23 <hpc> startling: imagine how awesome it would be if you had to do it more than once :P
14:27:48 <monochrom> to do it more than once, do it in a new branch, then merge.
14:28:32 <startling> heh
14:28:45 <startling> that's almost as much work as writing all the packages and versions, though
14:35:06 <PuercoPop> Oi if I'm doing a case over an integer how do I specify multiple values (Like 2 or 3) as the 'match' expr
14:35:17 <monochrom> sorry, can't
14:35:38 <monochrom> unless you accept: "f x | x==2 || x==3 = joy"
14:35:39 <PuercoPop> hmm, then what should I be trying to do instead?
14:36:25 <monochrom> you can mix that with "f 1 = happy", i.e., you can use both lines
14:37:02 <PuercoPop> I'm trying to do a literal case: https://gist.github.com/PuercoPop/a47c688f079231501803
14:37:44 <startling>  PuercoPop, if whatever `elem` [2, 3] then ... else ..
14:37:45 <monochrom> um, where does x come from?
14:37:46 <arkeet> case ... of x | x == 2 || x == 3 -> ...
14:37:46 <mebaran151> hey all, what would be the best way to parse a string in the format of "50%; 1,000,000" -> (0.5, 1000000)
14:37:50 <arkeet> and so on
14:37:56 <arkeet> monochrom: list comprehension
14:38:05 <arkeet> oh yeah, use a different letter in the case
14:38:08 <arkeet> :p
14:38:27 <arkeet> yeah, x `elem` [2,3] is shorter.
14:38:31 <arkeet> and easier to expand
14:38:34 <monochrom> actually, what I mean: where is the formal parameter of nextStatus?
14:38:38 <mebaran151> I have a feeling this is a great use case for parse combinators
14:38:46 <arkeet> heh.
14:38:57 <quchen> mebaran151: Indeed.
14:39:16 <mebaran151> quchen: any good tutorial?  I have never actually used one yet
14:39:38 <PuercoPop> ahh I see, you are pointing out I forgot to include an argument for nextstatus right monochrom?
14:39:43 <arkeet> yes
14:39:43 <monochrom> yes
14:39:52 <mebaran151> the strings are pretty short so I'd preferably just like to split on ; and drop anything that isn't a number
14:39:57 <quchen> mebaran151: RWH has a chapter on Parsec, I think that's everyone's first parser.
14:39:58 <startling> mebaran151, if you want to learn how parsers usually work in haskell, http://eprints.nottingham.ac.uk/223/1/pearl.pdf is really good
14:40:43 <monochrom> "2 `or` 3 -> Alive" becomes "n | n==2 || n==3 -> Alive" or "n | n `elem` [2,3] -> Alive"
14:40:51 <[swift]_> so i have some code in my project that links to C++ and therefore can't run within GHCi. it's in a separate executable from most of the project, though. i recently tried to get ghc-mod working on my project, and was frustrated to find that i couldn't use it even on the parts that don't link to C++, because ghc-mod tries to load every package any part of the project depends on. is there a good solution for this?
14:41:25 <arkeet> this might be a case for Bool. let n = length ... in if (n == 2 or n == 3) then Alive else Dead
14:41:26 <[swift]_> (my current hack is to use a flag which defaults to False to disable the building of that executable, and then use a makefile to actually build which enables the flag)
14:41:35 <arkeet> er, || instead of or
14:41:49 <arkeet> I guess the parentheses aren't necessary.
14:41:57 <acowley> [swift]_: ghc-mod doesn't work even if you move the C++-using part to another package that you then depend upon?
14:42:11 <monochrom> yeah, if-then-else is not bad either
14:43:16 <arkeet> btw
14:43:24 <arkeet> instead of that big list in the length,
14:43:25 <arkeet> why not
14:43:27 <[swift]_> acowley: i haven't gone that far, yet. (can i have multiple packages in one cabal file?) the C++-using part is just in a separate executable. my project has one library and several executables that use the library.
14:43:35 <arkeet> length (filter isAlive (getNeighbourPositions))
14:43:36 <monochrom> oh hehe
14:43:49 <PuercoPop> arkeet: Is this what you meant? https://gist.github.com/PuercoPop/a47c688f079231501803
14:44:02 <dcoutts> [swift]_: yes, one lib and several exes in one package is fine
14:44:04 <shachaf> arkeet: That would compute more than necessary of the list. :-(
14:44:14 <arkeet> shachaf: but it already does.
14:44:29 <arkeet> PuercoPop: that's a syntax error.
14:44:42 <acowley> [swift]_: I try to keep my C++ pieces in tiny wrapper packages that I then depend on in the larger package
14:44:45 <arkeet> I'm pretty sure if you just copied what we wrote then it would be fine.
14:45:31 <monochrom> I showed exact replacements
14:45:37 <acowley> [swift]_: Admittedly, it is a pain how various things like ghc-mod can't deal with FFI very robustly
14:45:56 <shachaf> arkeet: OK, I didn't read the original code or anything.
14:46:07 <[swift]_> acowley: in reality the C++ stuff is already in a separate package, but one of the executables depends on that package and thus ultimately links to it. this stuff is not easy to work around =\
14:46:34 * [swift]_ can't wait for the day when ghci uses the system linker
14:46:36 <acowley> Oh, huh
14:46:42 <acowley> I would have thought that would be okay
14:46:48 <monochrom> there is hope that the list has length at most 9
14:47:21 <[swift]_> acowley: any linking to C++ anywhere in the dependency tree is poisonous, it seems =(
14:47:46 <acowley> [swift]_: that's not right
14:48:09 <acowley> [swift]_: The very code I'm working on right now depends on a package that has a C++ component
14:48:22 <monochrom> if you have *.o files, ghci can load them
14:49:13 <monochrom> but it's a bit technical. they have to be loaded when ghci begins. "ghci joy.o pearl.o" etc
14:49:48 <[swift]_> monochrom: ghc-mod and template haskell both seem to break, though
14:50:07 <monochrom> for GHC API, I think this means you have to specify them at parseDynamicFlags and setSessionDynamicFlags time
14:50:43 <[swift]_> monochrom: also, this just sucks =\ i'd rather not expose that implementation detail to the user (here speaking of the developer making use of the library as the user)
14:51:07 <acowley> In my case, I have a Makefile that builds some C++ to a .a, then I have that and a dylib in extra-libraries in the .cabal file. Then I depend on that package elsewhere.
14:52:02 <acowley> I did spend pretty much a full day trying combinations of make and cabal to get things working
14:52:11 <[swift]_> acowley: did you use ghc to build the C++ code?
14:52:16 <acowley> [swift]_: No
14:52:25 <acowley> [swift]_: I couldn't get that to work right
14:52:36 <[swift]_> acowley: i couldn't either.
14:52:44 <acowley> [swift]_: So I build the C++ code with make, then link the result of that with cabal
14:53:06 <[swift]_> acowley: so ghci and TH work in code that depends on this code?
14:53:13 <[swift]_> acowley: is this up on github or something? i'd love to see it
14:53:14 <acowley> [swift]_: Yes!
14:53:18 <acowley> [swift]_: No!
14:53:21 <acowley> :/
14:53:23 <[swift]_> =(
14:53:31 <thoughtpolice> GHC should be able to single-shot compile a C or C++ file
14:54:20 <monochrom> GHC just calls gcc, not g++. therefore, it's missing out some -I's and -l's you may need if your C++ goes like "#include <functional>"
14:54:27 <acowley> thoughtpolice: I couldn't make it work when I was setting this project up a few months ago (7.6.1)
14:54:37 <thoughtpolice> acowley: were you just producing object files?
14:55:05 <acowley> thoughtpolice: I was trying to just mention the C++ file in my .cabal file, but I don't remember exactly how far I got it.
14:55:07 <acowley> It's not a fond memory
14:55:11 <thoughtpolice> oh, that's cabal then
14:55:19 <acowley> Oh, yes, sorry.
14:55:22 <thoughtpolice> Cabal separately runs the compiler on c-sources or whatnot
14:55:39 <[swift]_> acowley: http://ghc.haskell.org/trac/ghc/ticket/3333
14:55:44 <thoughtpolice> i'd be surprised if it didn't detect C++ though
14:55:45 <[swift]_> that's the bug that i'm experiencing
14:55:58 <[swift]_> i'm honestly quite puzzled that you don't hit it
14:56:05 <tdammers> I'm wondering if it would be easier to wrap the C++ code in a C library and glue the whole thing together with a good old Makefile
14:56:23 <acowley> [swift]_: I'm using clang, if that makes a difference
14:56:39 <thoughtpolice> i've also loaded C++ files into GHCi successfully, without the dynamic linker
14:56:46 <acowley> tdammers: That's basically the approach I ended up with using my make/cabal combo.
14:56:52 <thoughtpolice> i did this in my 'salt' project, since there was a tiny bit that linked to libstdc++
14:56:55 <[swift]_> acowley: so am i
14:57:16 <shachaf> Speaking of NaCl...
14:57:17 <thoughtpolice> perhaps i'm lucky enough to have simple cases though
14:57:24 <[swift]_> thoughtpolice: i'll go look for that. i'd love to see how you did it
14:57:27 <thoughtpolice> 7.8.1 will at least be dynamic by default on Linux/OSX
14:57:43 <[swift]_> yeah, i think dynamic by default will fix this
14:57:50 <luite> thoughtpolice: did it have global initializers?
14:57:54 <acowley> 7.8.1 will make finger sandwiches and give foot rubs if I'm understanding the hype right
14:57:57 <[swift]_> the problem is that ghci doesn't correctly load weak symbols
14:57:59 <thoughtpolice> luite: probably not, hence 'lucky enough'
14:58:09 <luite> right
14:58:20 <thoughtpolice> shachaf: i know :(
14:58:24 <luite> so you just loaded the .o files ignoring the weird sections?
14:58:30 <tdammers> acowley: right... I actually include a little makefile with just one rule that calls cabal-dev in most of my projects
14:58:41 <tdammers> acowley: just to be able to do :make in vim... :x
15:00:20 <thoughtpolice> luite: i did nothing special. i just realized that i was missing libstdc++ in my extra-libraries, added it, and i could run in GHCi
15:00:24 <acowley> [swift]_: I'm sorry I don't have a small example/test project to experiment with C++ things. Do you have a minimal example of things not working?
15:00:27 <thoughtpolice> let me find the bug that was filed
15:00:42 <[swift]_> acowley: not minimal, heh
15:00:42 <thoughtpolice> https://github.com/thoughtpolice/salt/issues/12
15:01:07 <[swift]_> acowley: the library i'm depending on is libclang. i would not call it minimal =)
15:02:42 <flux0r> is there a type class for things that are unconsable?
15:02:54 <[swift]_> acowley: http://haskell.1045720.n5.nabble.com/Unknown-symbol-dso-handle-with-Template-Haskell-and-wxHaskell-td3318375.html
15:03:02 <[swift]_> that's the exactly issue i have
15:03:34 <startling> flux0r, not one that's used very often
15:03:37 <acowley> Just ended up writing a function \f g -> (f .) . (<*>) . (flip g <$>)
15:03:47 <acowley> :t \f g -> (f .) . (<*>) . (flip g <$>)
15:04:00 <startling> flux0r: there's http://hackage.haskell.org/package/ListLike but it's kind of silly
15:04:03 <[swift]_> thoughtpolice: seems like a different problem, alas. i wonder if this is platform-specific behavior? i'm on OS X here; possibly things work differently on linux
15:04:09 <flux0r> yeah that's what i was looking at
15:04:17 <flux0r> ok cool...thanks
15:04:21 <acowley> I'm on OS X, too
15:06:15 <thoughtpolice> [swift]_: i think at the time i was working on both OS X and linux. either way the whole thing is pretty fidgety
15:06:23 <thoughtpolice> i look forward to the day i can rm -rf the homegrown linker
15:06:25 <thoughtpolice> if at all possible
15:06:58 <pentace> @pl \f g -> (f .) . (<*>) . (flip g <$>)
15:07:06 <acowley> thoughtpolice: Isn't there still a problem of distributing executables with dynamic linking?
15:07:55 <acowley> thoughtpolice: Is there an easy way of packaging all that stuff up for distribution? I sympathize with those who like just copying a bulky executable all around.
15:08:25 <luite> you can find the dynamic deps with ldd, dunno if there's something that automates it
15:08:55 <thoughtpolice> acowley: yeah, static is nice in this case. really we'd like a tool to do that for us, i think.
15:09:42 <acowley> I guess it's a pain how it will be so platform dependent
15:10:38 <luite> it's all just system linking though, it must've been solved already on all platforms (in multiple horrible ways probably) :)
15:10:58 <[swift]_> i think someone said it earlier, but after some investigation into __dso_handle, i suspect the problem is that the code i'm linking to has global objects. perhaps that explains why it works in some cases but not in my case
15:13:59 <thoughtpolice> acowley: on an unrelated note, i should have more time to work on GHC/ARM shortly! and hopefully get a real buildbot up for a while
15:14:32 <acowley> thoughtpolice: Awesome! Paid work?
15:22:31 * xenocons [paid][work][haskell] alert system activated
15:23:37 <pentace> I want to parse and evaluate expressions that are very much like simple Haskell expressions but with a bit more additional syntax. Is there a way to achieve that easily without re-implementing half of a GHC?
15:24:52 <startling> pentace, in general it's hard to extend parsers without literally copy-pasting code.
15:25:59 <pentace> Actually, my main concern is the evaulation part
15:26:28 <acowley> pentace: Does http://hackage.haskell.org/package/haskell-src-exts help?
15:27:03 <xenocons> does this related at all to quasiquotations?
15:27:10 <startling> pentace, you could compile to haskell I guess
15:27:32 <startling> evaluating haskellish languages isn't so hard, though. it's the type-checking and unification that'll getcha
15:28:07 <xenocons> is haskells unification more complex than basic ML style unification (guessing yes)
15:28:21 <pentace> acowley: I guess I can re-use that for the parsing
15:28:41 <pentace> startling: Aww, I haven't even thought of that :S
15:29:01 <dmwit> It's often possible to use GADTs as a way of reusing GHC's unification for your own type checker/inferencer.
15:29:14 <xenocons> nice
15:29:15 <dmwit> It's sort of a prerequisite that your language be E, though.
15:29:25 <xenocons> 'E'?
15:29:38 <dmwit> embedded
15:29:44 <dmwit> a little joke about EDSLs =)
15:29:46 <startling> pentace: the first part of this paper might be helpful (but don't read it all the way or you'll decided to write a dependently-typed language): http://www.andres-loeh.de/LambdaPi/
15:29:53 <xenocons> ah, sorry
15:29:57 <acowley> That's a seriously inside joke :/
15:30:36 <startling> xenocons: I think it's just hindley-milner with typeclasses
15:30:45 <dmwit> I apologize for nothing.
15:30:58 <xenocons> startling: hmm k
15:31:04 <acowley> Nothing
15:32:25 <pentace> startling: Thanks, I'll read
15:33:46 <acowley> Okay, I can't figure out how to adapt http://www.reactiongifs.com/chicken-regret-nothing/ to Haskell.
15:34:49 <dmwit> acowley: heh
15:35:57 <monochrom> then don't adapt :)
15:36:07 <xenocons> not like http://torso.me/chicken ?
15:36:52 <edwardk> dolio: it worked
15:37:08 <dolio> It?
15:37:18 <ciaranm> sssh! you said it!
15:37:19 <acowley> edwardk: The chicken regrets nothing?
15:37:36 <dolio> Ni.
15:38:34 <edwardk> You can decompose the A or the B matrices independently based on which has the most significant most significant differing bit. Yielding Y in two halves in Morton order.
15:39:14 <edwardk> The sub problems take the right form and everything
15:40:15 <dolio> Nice.
15:40:52 <edwardk> Splitting A yields 3 sub matrices. Then Y_L = V(A22,X_L,B), and you pull Y_L into the def for Y_H like before
15:41:09 <edwardk> Much simpler recursive scheme actually
15:41:45 <edwardk> valiant is then 2 steps of my scheme alternating between A and B
15:42:21 <edwardk> Heh I should call it a Variant parser ;)
15:43:40 <edwardk> It also only involves one nested matrix multiply at each recursive step
15:51:48 <Ghoul_> @pl (\(s, a) -> socketToHandle s ReadWriteMode
15:51:49 <Ghoul_>    >>= handleConnection . flip TCPSocket a)
15:51:59 <Ghoul_> @pl (\(s, a) -> socketToHandle s ReadWriteMode >>= handleConnection . flip TCPSocket a)
15:52:10 <Ghoul_> damnit.
15:52:16 <Ghoul_> lambdabot is dead :(
15:52:34 <Ghoul_> I spent 45 minutes on the train trying to figure out the answer to that, and I was really looking forward to it
15:53:25 <dmwit> ?botsnack
15:53:55 <Ghoul_> I dont think hes in the channel at all
15:54:05 <dmwit> yaaaay
15:54:08 <Ghoul_> :D
15:54:12 <Ghoul_> @pl (\(s, a) -> socketToHandle s ReadWriteMode >>= handleConnection . flip TCPSocket a)
15:54:19 <lambdabot> uncurry ((. ((handleConnection .) . flip TCPSocket)) . (>>=) . flip socketToHandle ReadWriteMode)
15:54:22 --- mode: ChanServ set +o elliott
15:54:31 --- mode: elliott set -b *!*wolfes@*.hsd1.ca.comcast.net$##fixyourconnection
15:54:43 --- mode: elliott set -o elliott
16:16:06 <Sagi> wow, I'm so happy! I just bought Marlow's new book from kobo with some random coupon code giving me 50% off.
16:16:59 <Sagi> I was pondering whether to buy it now, save it for later or save for other things, but for 9 euro's there wasn't much point in thinking about it...
16:18:54 <Ghoul_> You know how you can do this; ReaderT $ \s -> .....
16:19:05 <Ghoul_> is there a shorthand like that which works for StateT?
16:19:16 <Sagi> for later reference, the code was up on retailmenot
16:19:52 <startling> Ghoul_, isn't that "lift"?
16:19:55 <hpc> Ghoul_: that trick isn't recommended for either ReaderT or StateT
16:20:00 <startling> oh, not quite
16:20:05 <hpc> use lift and ask/get/put
16:20:36 <hpc> startling: it's (ask >=> lift), or something like that
16:20:55 <Ghoul_> mmk
16:20:56 <startling> :t reader >=> lift
16:20:57 <lambdabot> (Monad m, MonadReader r (t m), MonadTrans t) => (r -> m c) -> t m c
16:21:09 <startling> :t state >=> lift
16:21:09 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> (m c, s)) -> t m c
16:21:11 <hpc> :t reader
16:21:11 <lambdabot> MonadReader r m => (r -> a) -> m a
16:21:25 <hpc> :t ask >=> lift
16:21:26 <lambdabot> (Monad (t m), Monad m, MonadTrans t) => t m (m c) -> t m c
16:21:32 <hpc> o.O
16:21:51 <startling> hpc, ask is not usually a function
16:22:06 <startling> (unless it's the (->) a instance)
16:22:36 <startling> > ask 1
16:22:37 <lambdabot>   1
16:23:23 <ParahSail1n> @src (->) ask
16:23:23 <lambdabot> ask = id
16:24:23 <xenocons> > id 1
16:24:24 <lambdabot>   1
16:24:45 <startling> is there an op here? Xochipilli is messaging me with some hateful spam; I can paste it somewhere but I'd rather not give it more exposure than is necessary.
16:24:56 <hpc> i got it too
16:25:07 <Sagi> me too
16:25:11 <xenocons> can confirm
16:25:14 <xenocons> i also recieved
16:25:16 <solrize_> hpaste.org is down ?
16:25:50 <hpc> solrize_: it is now lpaste, because terrible domain names are a good way to avoid success
16:25:57 <solrize_> ic
16:25:59 <solrize_> thans
16:26:01 <solrize_> thanks
16:26:11 <solrize_>       
16:26:12 <solrize_>       
16:26:12 <solrize_>       
16:26:12 <solrize_>       
16:26:12 <solrize_>       
16:26:12 <solrize_>         
16:26:12 <hpc> :P
16:26:14 <solrize_>         
16:26:16 <solrize_>           Firefox can't find the server at www.lpaste.org.
16:26:34 <hpc> @where hpaste
16:26:34 <lambdabot> http://lpaste.net/new/haskell
16:26:36 <djahandarie> It's lpaste.net. Also careful with your pasting.
16:26:39 <solrize_> oops
16:27:13 <nooodl> solrize_: might wanna pastebin those 7 lines of whitespace!
16:27:37 <solrize_> weirdly i pasted what looked like only one line from the browser
16:27:48 <solrize_> aha it's lambdapaste... they could have just called it that...
16:28:21 <djahandarie> solrize_, try copying and pasting the command on http://thejh.net/misc/website-terminal-copy-paste into a textbox.
16:28:34 <hpc> @ask chrisdone is there any plan to get hpaste.org as an alternate domain for lpaste?
16:28:34 <lambdabot> Consider it noted.
16:29:28 <Ghoul_> :t runStateT
16:29:28 <lambdabot> StateT s m a -> s -> m (a, s)
16:30:51 <startling> :t (state >=> lift) `asTypeOf` StateT
16:30:52 <lambdabot>     Occurs check: cannot construct the infinite type: s0 = (c0, s0)
16:30:52 <lambdabot>     Expected type: (s0 -> (m0 c0, s0)) -> StateT s0 m0 c0
16:30:52 <lambdabot>       Actual type: (s0 -> (m0 c0, (c0, s0)))
16:31:22 <startling> aw
16:31:55 <startling> oh, I see. the tuple is lifted.
16:32:03 <Xochipilli> negroids suck
16:32:08 <Xochipilli> what do you guys think?
16:32:10 <startling> Xochipilli, fuck off
16:32:22 <Xochipilli> you can't do shit startling
16:32:23 <startling> @ops
16:32:23 <lambdabot> Maybe you meant: pl oeis docs
16:32:27 <Xochipilli> check your pm dude
16:32:30 <arkeet> @where ops
16:32:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
16:32:30 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:32:30 <Xochipilli> great place
16:32:40 --- mode: ChanServ set +o dcoutts
16:32:40 --- mode: ChanServ set +o geekosaur
16:32:40 --- mode: ChanServ set +o elliott
16:32:41 --- mode: ChanServ set +o shachaf
16:32:42 --- mode: elliott set +b *!*Xochipill@187.153.54.*
16:32:42 --- kick: Xochipilli was kicked by elliott (Xochipilli)
16:32:45 <elliott> I win!
16:32:47 <geekosaur> heh
16:32:50 --- mode: geekosaur set -o geekosaur
16:32:50 <startling> yay!
16:32:52 <dcoutts> damn!
16:32:52 --- mode: elliott set -o elliott
16:32:56 --- mode: ChanServ set -o dcoutts
16:32:58 <arkeet> well, dcoutts wins for opping first.
16:32:59 --- mode: shachaf set -o shachaf
16:32:59 <arkeet> =)
16:33:26 <dcoutts> elliott: I'll get you next time!  ;-)
16:33:34 <elliott> next time you'll ban me
16:33:39 <dcoutts> heh
16:33:44 * dcoutts shoots, hits own foot
16:33:55 <hpc> this channel needs more +o spam :D
16:33:57 <elliott> just need a client script that ops yourself and deops everyone else to get ahead in the race.
16:34:08 <dcoutts> ah, cunning
16:52:28 <startling> is there a "get a unique english word" thing in a library somewhere?
16:53:05 <startling> (ideally it would prefer shorter words)
16:54:27 * travisb just got his dead tree copy of the Marlow book today
16:54:50 <travisb> (why the hell did it take O'Reilly a full week to ship it?)
16:54:56 <hpc> startling: pipe in /usr/share/dict/words and do some magic to it
16:55:49 <startling> hpc, well, I'd like to avoid needing IO everywhere.
16:56:25 <hpc> i don't think there's a pure list of english words anywhere on hackage
16:56:34 <elliott> startling: you can use TH to load the dictionary at compile time
16:56:49 <hpc> (you should add one, and then refuse to maintain it, for lols)
16:57:36 <travisb> (and on that note, why does GHC Haskell get not nearly as much attention for concurrency as Erlang, when it performs just as well, and for that matter has more general concurrency (Erlang is limited to actors), and has extensive support for parallelism (which has to be manually built on top of actors in Erlang?)
16:58:51 <startling> hpc, haha
16:59:01 <startling> elliott: oh, that's an interesting idea
16:59:21 * travisb finds it alarming that TH can make *GHC* launch missiles
16:59:32 <startling> "find the 100 shortest words in a file" might be kinda intensive for compile-time though.
16:59:47 <monochrom> what elliott says :)
17:00:08 <elliott> startling: just load [String] at compile time
17:00:14 <elliott> process it at runtime
17:00:16 <monochrom> also, use runIO to play movies :)
17:00:23 <elliott> also, maybe best to bundle the dictionary file with your package
17:00:26 <elliott> so it's not dependent on the OS etc.
17:00:45 <startling> this is a lot of work for pretty-printing lambdas. :(
17:00:57 <monochrom> use HList to raise the dictionary to the type level :)
17:01:24 <travisb> startling: it does certainly sound like overkill for that
17:01:34 <monochrom> wait, you need an English dictionary to pretty-print lambdas?
17:01:54 <shachaf> monochrom: Oh, I was going to do something like that once.
17:02:03 <startling> > (>>=) [1..] . flip replicateM $ ['a'..'z'] -- right now I'm just using this
17:02:04 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
17:02:14 <startling> > drop 30 . (>>=) [1..] . flip replicateM $ ['a'..'z']
17:02:15 <lambdabot>   ["ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap","aq","ar","as"...
17:02:27 <startling> but that's /boring/.
17:02:47 <startling> edwardk, can I add a pure list of english words to 'bound'?
17:02:49 <shachaf> Alpha-renaming unreadable Core identifiers like x_wA4n to readable identifiers like "apple" and "norway".
17:02:50 <monochrom> I see, you want to do it like, choose fresh variable names from a sequence of English words such as ["joy", "fun", "delight", "awesome" ...]
17:03:18 * travisb understands now
17:03:42 * hackagebot ligature 0.1.0.0 - Expand ligatures in unicode text  http://hackage.haskell.org/package/ligature-0.1.0.0 (JosefSvenningsson)
17:03:47 <cmears> > map (\n -> "x" ++ replicate n '\'') [0..]  -- primes are all you need
17:03:48 <lambdabot>   ["x","x'","x''","x'''","x''''","x'''''","x''''''","x'''''''","x''''''''","x...
17:03:54 <travisb> you could program in some basic English spelling and phonological rules, and make it automatically generate (usually fake) English words
17:04:11 <startling> travisb: well, an advantage is readability
17:04:58 <monochrom> that was done to generate a lot of passwords. don't worry, the passwords were for guest accounts and good for only one day
17:05:18 <monochrom> (and also the guest could change passwords)
17:05:25 <shachaf> > map ('x:') (inits (repeat '\''))
17:05:26 <lambdabot>   <hint>:1:10: parse error on input `)'
17:05:35 <shachaf> > map ('x':) (inits (repeat '\''))
17:05:36 <lambdabot>   ["x","x'","x''","x'''","x''''","x'''''","x''''''","x'''''''","x''''''''","x...
17:06:07 <travisb> passwords generated that way would certainly have the advantage of being more memorable on the user's part, but at the same time one would have to combine multiple words or words and numbers or like to avoid dictionary attacks
17:06:20 <cmears> > iterate (++"'") "x"
17:06:21 <lambdabot>   ["x","x'","x''","x'''","x''''","x'''''","x''''''","x'''''''","x''''''''","x...
17:06:54 <travisb> whereas you don't have to worry about dictionary attacks with autogenerated identifiers for prettyprinting
17:08:24 <startling> turns out most english words are boring
17:08:46 <startling> @wn aal
17:08:47 <lambdabot> No match for "aal".
17:08:54 <startling> @wn aam
17:08:55 <lambdabot> No match for "aam".
17:08:57 <travisb> at least most dictionaries aren't going to contain, for the most part, things like grammar words, which would probably wouldn't want to use
17:09:06 <arkeet> > fix show
17:09:07 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:09:35 <arkeet> > map ('x':) (iterate ('\'':) "")
17:09:35 <lambdabot>   ["x","x'","x''","x'''","x''''","x'''''","x''''''","x'''''''","x''''''''","x...
17:09:50 <startling> travisb, every time I see your nick I briefly think someone let a travis-ci bot loose in here.
17:10:53 <tabemann> I normally go by this name in here
17:11:20 <tabemann> travisb is a name I use on a different IRC net, which for some reason xchat was stupid enough to use on this net instead of the name I normally use here
17:11:41 <startling> ha
17:12:20 <tabemann> (keeping separate IRC nets separate is slightly broken in xchat)
17:13:02 * startling considers unsafePerformIO for random numbers in a Show instance ...
17:13:48 <tabemann> bad! bad!
17:14:04 <tabemann> well
17:14:27 <tabemann> how safe is netStdGen inside an unsafePerformIO in concurrent code?
17:14:38 <tabemann> s/net/new
17:15:00 <scshunt> startling: why...
17:15:01 <tabemann> if you kept around your own StdGen that you stored somewhere
17:15:14 <arkeet> tabemann: I'm pretty sure it wouldn't interact with anything else.
17:15:17 <startling> tabemann, it's a Show instance
17:15:20 <tabemann> you would need to use the unsafePerformIO hack to create an MVar containing the StdGen
17:15:24 <startling> oh, I see what you mean.
17:15:59 <tabemann> well, you are already using unsafePerformIO... but the unsafePerformIO hack isn't guaranteed to be safe, even though people use it anyways
17:16:28 <scshunt> yeah, if you're using unsafePerformIO anyways, it seems pretty trivial
17:16:48 <tabemann> but not all uses of unsafePerformIO are equally unsafe
17:17:06 <startling> what would unsafe behavior do in this case?
17:17:29 <tabemann> the problem with the unsafePerformIO hack is more theoretical than anything - there is no guarantee that it is evaluated before main is
17:18:29 <tabemann> as for accessing an MVar from within an unsafePerformIO, that can be done in ways so it is safe even in the case of an asynchronous exception
17:18:44 <tabemann> provided
17:18:52 <tabemann> one doesn't do a recursive show
17:19:34 <startling> anyway, how does one read a file with template haskell?
17:19:42 <tabemann> so in cases that show can invoke other show instances, you have to make sure that you leave the MVar in a safe state at that time
17:20:27 <tabemann> dunno - never used TH, much the less done IO in TH
17:20:35 <luite> qRunIO
17:20:38 <scshunt> TH is pretty sweet
17:21:11 <tabemann> TH feels like lisp macros, but far more complex and brittle
17:21:35 <tabemann> at least from what I've read about it
17:22:07 <startling> that's the impression I have, too.
17:22:17 <startling> (aha: http://hackage.haskell.org/packages/archive/file-embed/0.0.4.9/doc/html/Data-FileEmbed.html )
17:22:52 <luite> startling++ for proper space usage around a url
17:23:07 <startling> :D
17:23:40 <WraithM> @pl \x y -> (++) <$> x <*> y
17:23:40 <lambdabot> (((++) <$>) .) . (<*>)
17:29:40 <bscarlet> :t liftA2 (++)
17:29:41 <lambdabot> Applicative f => f [a] -> f [a] -> f [a]
17:29:58 <bscarlet> :t \x y -> (++) <$> x <*> y
17:29:59 <lambdabot> Applicative f => f [a] -> f [a] -> f [a]
17:30:04 <Ghoul_> is there something like 'forever' that's strict in each repetition?
17:30:58 <Ghoul_> a problem i have is in my server I do `forever $ do p <- decode ... ` and then handle it, but nothing gets processed until the client disconnects
17:31:05 <Ghoul_> To me it looks like laziness maybe..
17:31:41 <tabemann> forever doesn't touch any data you are getting from the server though
17:32:44 <Ghoul_> good point. maybe I just need bang patterns
17:32:49 <tabemann> you might need to add ! or seq somewhere... but don't use deepSeq when you're using lazy IO and you could load an arbitrarily large amount of data into memory...
17:33:28 <tabemann> well, only use deepSeq if you know the size of the data you'll be getting
17:33:43 <tabemann> (and aren't just trusting the other end to give you a given amount of data)
17:41:52 <Ghoul_> well, BangPatterns doesn't seem to make a difference. Maybe I did it wrong? https://github.com/kvanberendonck/burrito/blob/master/src/Burrito/Network.hs
17:42:10 <Ghoul_> I also tried changing return $ to return $! :/
17:48:11 <tabemann> actually
17:48:13 <tabemann> another thought
17:48:28 <tabemann> if decode is returning a string, ! will only evaluate the first character for you
17:49:00 <tabemann> but unless your guaranteed a maximum amount of data, you don't want deepSeq either
17:49:02 <Ghoul_> oh, it returns a Packet which is one of PacketTypeOne... PacketTypeTwo etc
17:49:19 <Ghoul_> and then I just print it out to see if its working, but I dont get any console output until I disconnect the client
17:49:21 <Ghoul_> its kinda wierd.
17:49:46 <tabemann> this makes me wonder if any kind of buffering is going on
17:50:05 <tabemann> you might need to set the underling Handle to have no buffering
17:50:09 <tabemann> *underlying
17:50:20 <Ghoul_> thats a good idea actually, I'll do it just to make sure
17:51:09 <edwardk> @tell WraithM GADT lenses are sensible, but don't compose well or let me write combinators for them
17:51:10 <lambdabot> Consider it noted.
17:51:30 <tabemann> :t hSetBuffering
17:51:31 <lambdabot> Not in scope: `hSetBuffering'
17:52:09 <Ghoul_> hmm, OK so I just tried that and it hasn't changed anything
17:52:10 <tabemann> oh of course lambdabot wouldn't know it
17:52:20 <danharaj> edwardk: is that a limitation of type inference? it seems like GADT lenses should compose if you move to functor categories.
17:54:03 <edwardk> its a type inference thing
17:55:05 <tabemann> fuck yeah thread switching is fast with GHC Haskell (just did a test and latency in each step for two threads contending over a TMVar is about 0.000000363216s per step... whereas in C++ with pthreads for basically the same thing I was running into a wall at 0.002 per step!)
17:57:04 <edwardk> 2-fat decomposition is really proving to be a useful tool
17:57:04 <danharaj> edwardk: do you think a type inference algorithm like HML would fare better?
17:57:04 <edwardk> no
17:57:04 <danharaj> aw
17:57:06 <edwardk> we use a variant of hmf here and no love )
17:57:24 <danharaj> no love for it?
17:57:24 <danharaj> or it does not love you enough
17:57:29 <tabemann> Ghoul
17:57:30 <tabemann> just thought of something
17:57:33 <edwardk> both
17:57:38 <edwardk> we've agreed to tolerate one another
17:57:41 <danharaj> :P
17:57:50 <edwardk> you know, for the good of the application
17:57:55 <danharaj> edwardk: It must be better than boxy though.
17:58:07 <edwardk> if we hadn't spawned applications together we would have broken up by now
17:58:16 <tabemann> if you're doing lazy IO on a String read from a Handle, if you get to the end of the String, you'll hang until you actually disconnect, where only then it will evaluate the last value in the String to []
17:58:47 <tabemann> that has nothing to do with buffering modes
17:59:29 <danharaj> edwardk: Oh is HMF the one where you have to annotate some let bindings
17:59:30 <tabemann> I really can't say, though, as I can't see the code for decode in your paste
17:59:50 <edwardk> and when things come into scope in lambdas
18:00:09 <danharaj> ah, and HML is the one where you only need to annotate polymorphic arguments.
18:00:17 <danharaj> and MLF is the one I don't understand.
18:00:43 <tabemann> Ghoul_: also, seq and deepSeq won't help here either
18:01:44 <edwardk> e.g. In ermine we use what is morally: newtype IO a = IO (forall r. (a -> r) -> (forall i. (i -> r) -> (Throwable -> r) -> FFI i -> r) -> (Throwable -> r) -> r)
18:01:50 <tabemann> could you paste your code for decode?
18:01:51 <edwardk> to type check (>>=) w need to use:
18:02:16 <edwardk> (>>=) m f = IO (kp (kf : some r. K r) ke -> runIO m (a -> runIO (f a) kp kf ke) kf ke)
18:02:30 <Ghoul_> tabemann: im not dealing with strings though
18:02:34 <edwardk> which uses the type alias type K r = forall i. (i -> r) -> (Throwable -> r) -> FFI i -> r
18:02:52 <edwardk> to talk about part of that continuation, due to the forall i. in the type of IO
18:03:06 <Ghoul_> oh yeah, decode is here;
18:03:12 <edwardk> some isn't an existential
18:03:24 <Ghoul_> https://github.com/kvanberendonck/burrito/blob/master/src/Burrito/Network/Socket/Serialize.hs
18:03:53 <danharaj> gross
18:04:09 <edwardk> er and you should read the IO (kp (…) -> ...)  as IO (\kp (…) -> ..)
18:04:16 <edwardk> we don't use \ in our lambdas
18:04:30 <danharaj> makes sense
18:04:38 <edwardk> its one of those things that was good enough that we never felt the need to go revisit it
18:04:42 <danharaj> clearly you can use \ for other sorts of binders ;)
18:04:54 <edwardk> \ gets used elsewhere i just forget where
18:05:59 <danharaj> edwardk: is some ~ can be instantiated to?
18:06:00 <Ghoul_> its pretty strange - I added print "recieving some..." into recv for the socket typeclass, and it doesn't even appear until the client disconnects -- and it's at the top of the function
18:06:23 <danharaj> or something like that?
18:06:27 <edwardk> that might be a way to phrase it
18:06:32 <edwardk> its a quirk of HMF
18:06:49 <Ghoul_> and then for some reason it prints 5 times when its only receiving a Word8! (wth? laziness?)
18:06:58 <Ghoul_> (when the client disconnects)
18:08:15 <danharaj> ooohhhh
18:08:42 <danharaj> HMF is NOT the same thing as HML^F
18:08:42 <danharaj> I thought it was some sort of sugar for flexible types from that system.
18:09:06 <edwardk> yeah its its own thing
18:09:10 <elliott> I like some
18:09:18 <elliott> you can use it to partially specify a type and stuff
18:09:19 <edwardk> pretty much the dumbest thing that gets you higher rank types in a usable form
18:09:26 <elliott> and get the rest inferred
18:09:34 <elliott> at least that's what I managed to do when playing with this stuff
18:09:45 <danharaj> edwardk: so I take it 'some' handled impredicative instantiation perhaps
18:09:53 <edwardk> yeah
18:10:18 <edwardk> and even there i'm not so sure we even care about the ImpredicativeTypes side other than for higher rank functions.
18:10:43 <edwardk> we used to care, but then all the code that needed it is gone
18:10:46 <elliott> I should figure out that lensy type system I was thinking about.
18:10:55 <danharaj> I am sort of guessing because I haven't read about HMF, I just read about HML and HML^F this evening on the train.
18:10:55 <danharaj> I believe you pushed those papers onto my stack like a year ago :P
18:11:47 <danharaj> edwardk: I am slowly working through Adam Gundry's thesis and it seems to be a pretty solid foundation for building complicated type inference algorithms.
18:12:00 <danharaj> edwardk: how do you guys do constraint solving with your db types btw? I bet that's in the video somewhere.
18:12:23 <edwardk> its a complete and total hack
18:12:33 <hpaste> tabemann pasted “Strange performance patterns” at http://lpaste.net/91826
18:12:43 <edwardk> we wrote a paper with some inference rules. they seemed to work. we kept patching them to cover the rest of the cases we could think of
18:13:06 <edwardk> when it breaks dan thinks really hard and we plug the hole
18:13:22 <danharaj> I wish we could rely on our dan to solve problem like that :(
18:13:40 <danharaj> In a few weeks I'm going to be the programmer of last resort. And also the programmer of first resort.
18:14:26 <tabemann> does anyone know just why no -threaded would behave *so* differently performance-wise (as in multiple orders of magnitude difference) from -threaded with +RTS -N1?
18:14:53 <tabemann> with -threaded with +RTS -N1 being substantially worse than no -threaded
18:15:08 <danharaj> tabemann: The -threaded runtime has some major components that are different from the unthreaded runtime. The IO manager for example.
18:15:09 <danharaj> tabemann: A severe degradation in performance sounds like a bug though.
18:15:37 <danharaj> Some programs run *faster* with 1 capability on the threaded runtime as opposed to the regular runtime.
18:15:59 <tabemann> I'm using GHC 7.4.2 myself; hopefully this is something they've fixed since then...
18:16:17 <dolio> There's one rule that still isn't turned on, because it's buggy, and I couldn't figure out what was wrong with it.
18:16:34 <danharaj> tabemann: oh almost certainly.
18:16:50 <Ghoul_> tabemann: hahaha I threw a print "Hello" right after the forever $ and it never prints
18:16:59 <Ghoul_> looks like I've got a funnier issue at hand :S
18:17:31 <tabemann> maybe it's something with socketToHandle?
18:18:00 <Ghoul_> its probably because handleConnection is void'ed
18:18:13 <Ghoul_> so I bet haskell is going like "Oh, he doesn't need a result from that, so I won't even bother"
18:18:56 <danharaj> Every stable release of GHC tends to be faster better harder stronger
18:20:11 <tabemann> but void is just fmap (const ()), so it shouldn't affect the IO context, though
18:20:23 <Ghoul_> oh.
18:20:43 <tabemann> stilll
18:20:46 <tabemann> try taking the void out
18:21:03 <tabemann> danharaj: first time I've run into an obvious GHC bug
18:21:19 <danharaj> tabemann: now you're a real haskell programmer
18:21:41 <Ghoul_> tabemann: I run this now; http://lpaste.net/91827
18:22:00 <Ghoul_> "An iteration.." doesn't come up until after the client quits.
18:22:25 <tabemann> oh want
18:22:25 <edwardk> void shall soon be known as "(() <$) the inscrutable"
18:22:26 <tabemann> *wait
18:23:34 <tabemann> can -threaded with +RTS -N1 create two OS threads, even though it has only one capability?
18:24:24 <danharaj> *shrug*
18:24:31 <Ghoul_> :( outta battery.
18:24:35 <Ghoul_> I'll solve this later, thanks for the help
18:25:25 <tabemann> it's obvious why +RTS -N4 would be slower, because putting the two threads on different OS threads means that either OS thread switching (if they are on the same core) or interprocessor synchronization (if they are on different cores) becomes a bottleneck in this example
18:26:15 <tabemann> whereas no -threaded forces both Haskell threads to execute in a single OS thread, meaning that the GHC RTS can enable extremely fast thread switching
18:28:23 <tabemann> okay, Debian unstable is now up to 7.6.3... time to apt-get update; apt-get upgrade
18:28:36 <tabemann> s/upgrade/dist-upgrade
18:28:52 <tabemann> s/Debian/GHC in Debian
18:30:27 <danharaj> edwardk: so tell me more about this seminearring parsing shenanigans. I'm about to chomp down on those posts posted on reddit.
18:30:42 <edwardk> =)
18:31:05 <edwardk> so did you follow the sparse matrix stuff i've been rambling about the last 2-3 days?
18:32:13 <danharaj> edwardk: vaguely
18:32:59 <danharaj> I picked up that there is a connection between CYK parsers and matrix arithmetic in some module
18:33:02 <edwardk> basically I have a shiny new matrix multiplication algorithm
18:33:25 <edwardk> that started out as a sub-problem in parsing and now is its own thing
18:33:39 <edwardk> so i'm currently trying to make that thing stupidly fast, because it is beautiful
18:33:58 <danharaj> that's pretty awesome
18:34:21 <edwardk> the idea for it stems from morton ordering
18:34:29 <edwardk> which is to just interleave the bits of two keys
18:34:40 <edwardk> so far so good?
18:34:56 <edwardk> now, lets consider a simple case. a matrix that is 2^n * 2^n.
18:35:03 <danharaj> ok
18:35:12 <edwardk> if i do that then breaking my matrix into quadrants breaks it up into contiguous ranges of my morton order
18:35:19 <danharaj> so morton ordering is z-ordering I take it
18:35:29 <edwardk> look at the image on http://en.wikipedia.org/wiki/Z-order_curve#cite_note-12
18:35:39 <edwardk> and note the quadrants are contiguous sub-ranges
18:35:59 <danharaj> indeed
18:36:12 <edwardk> yes
18:36:12 <edwardk> that was somthing i'd known but hadn't really processed until carter reminded me on friday
18:36:27 <danharaj> I didn't realize that either.
18:36:35 <danharaj> it's obvious
18:37:00 <edwardk> so my observation is this. if i multiply two matrices  i'm taking keys in morton ordered values ijijijijijijijij * jkjkjkjkjkjkjk  and removing the js, and spitting out ikikikikikikikik
18:37:02 <edwardk> right?
18:37:18 <danharaj> yeah
18:37:45 <edwardk> and if i want the result matrix to be in morton order what i should so is look at both of my input matrices and then figure out which one has the most significant most significant difference.
18:37:49 <edwardk> what i mean by that is this
18:38:08 <edwardk> if we take a sequence of keys ascending in morton order, (say i preshuffled them, so they are just an Int!)
18:38:15 <edwardk> (er Word64)
18:38:34 <danharaj> come again
18:38:43 <danharaj> ah yes ok
18:38:49 * hackagebot logict 0.6.0.1 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.6.0.1 (DanDoel)
18:38:55 <edwardk> then i take the least and the greatest key in my matrix by morton order.  (e.g. say i stored them as a Vector (Key, a) sorted by Key   and just took the head and tail of the Key sub-vector)
18:39:21 <edwardk> if i exclusive or the two keys together the most significant bit where they differ is the most significant bit of that result
18:39:48 <danharaj> hold on I have to think about that last part
18:40:11 <edwardk> remember the keys we have are in ascending order
18:40:23 <edwardk> and all the bits you agree on will xor away to 0
18:40:28 <danharaj> right
18:40:29 <edwardk> so its just differing bits
18:40:38 <edwardk> and i includes necessarily the most significant difference
18:40:47 <edwardk> smearing it turns it into a mask of 'relevant' bits
18:40:56 <danharaj> ok what do you mean by smearing
18:41:19 <edwardk> smear x finds y = 2^n-1 such that y is the least such number >= x
18:41:33 <danharaj> ah
18:41:44 <edwardk> that is to say take x, and .|. it with itself shifted right one place, then .|. that with itself shifted right 2 places...
18:41:54 <edwardk> now i have a mask
18:42:12 <edwardk> if i shift that right one and xor it with itself i get the 'critical bit' as a mask
18:42:32 <edwardk> so i can binary search by vector for where the critical bit goes high (or i can store it in a more intelligent fashion)
18:42:47 <danharaj> ah yes I think I get it now
18:42:52 <edwardk> that is where i split
18:43:21 <edwardk> it splits a matrix with some number of non zeroes (nnz) >= 2  into two matrices each with at least 1 non-zero entry
18:43:44 <edwardk> so what i want to do is get out a result in ikikikik order.
18:45:03 <edwardk> so i look at (least x `xor` greatest x) .|. (least y `xor` greatest y) and smear that instead.
18:45:11 <danharaj> hmm
18:45:11 <edwardk> that gives me the mask for both matrices together.
18:45:23 <edwardk> and i can play a game to try to see if the product of these matrices will be trivially zero
18:45:30 <edwardk> the game is based on that mask
18:45:53 <edwardk> what i want to know is, do the known bits of 'j' agree?
18:47:05 <edwardk> ijijijij??????   and jkjkjk??????       so i know some of the bits of j that prefix every value in x and every value in y
18:47:12 <edwardk> so if they disagree the result will necessarily be 0!
18:47:22 <danharaj> ah
18:47:33 <edwardk> x i j * y j k can never give a non zero answer if the js will never match
18:47:53 <danharaj> uh
18:48:06 <edwardk> that gets a little tricky because you need to do so in an even aligned version of the mask
18:49:14 <edwardk> so once i've done that fast rejection, its just a matter of figuring out which of the x matrix or the y matrix has the most significant contribution to y. in terms of which one has the most significant most significant difference.
18:49:25 <danharaj> hold on, I think I lost the thread.
18:49:26 <edwardk> then if its the x matrix that difference may be on an even or an odd bit
18:49:35 <edwardk> and if its on the y matrix that difference may be on an even or an odd bit
18:49:38 <edwardk> we don't get to choose
18:49:48 <edwardk> so we just have to deal with all 4 cases
18:50:18 <danharaj> ok I have regained the thread
18:50:37 <edwardk> x i j * y j k = z i k        when its on 'i' that we split, then we just do the two sub-matrices and then literally concatenate them to get z
18:50:45 <edwardk> bcause the result will be correctly in morton order
18:51:06 <edwardk> when its on j we split we have to solve the two multiplications and then merge them since the both overwrite the same 'range'
18:51:36 <edwardk> and on y if its j we have to solve both multiplications and merge, while if its on k, magically its already in the right order to build the new matrix.
18:51:40 <danharaj> what do you mean by most significant difference
18:52:15 <edwardk> (min x `xor` max x) >= min y `xor` max y
18:52:22 <danharaj> ah
18:52:52 <edwardk> ctually its better to use if the x matrix splits on the most significant bit position we have a difference on in the result
18:52:53 <danharaj> so which one occupies a larger range
18:53:00 <edwardk> within a factor of two
18:53:06 <edwardk> because remember its in morton order
18:54:16 <danharaj> are you describing a highly optimized version of the strassen algorithm to me :P
18:54:19 <edwardk> so i can have a matrix with entries at (0,0) and i = 5 x  j = 6  matrix, but 1 0 1 and 1 1 0  interleave to get 110110, , so we compare the minimum entry 000000  and 110110  and get an xor of 110110
18:54:24 <edwardk> it should be
18:54:31 <edwardk> this is strassen, but we split on one axis
18:54:34 <edwardk> not both
18:54:37 <danharaj> ah
18:54:42 <edwardk> and i don't go down one bit at a time
18:54:45 <edwardk> i go to the _next_ split
18:54:49 <edwardk> no matter where it is
18:55:00 <edwardk> skipping all the bits we agree on
18:55:15 <edwardk> and the splits aren't even
18:55:19 <edwardk> they are 2-fat
18:56:08 <edwardk> the 2-fattest number in [a..b) is the number in that range that has the largest number of trailing 0's in its binary representation
18:56:11 <edwardk> that is what we split on
18:56:18 <danharaj> so you are optimizing for sparse matrices or matrices that fit into compact ranges of a morton ordering
18:56:32 <edwardk> this is all about sparse matrices, yes
18:56:44 <edwardk> i don't care about where the data goes just so long as nnz << n^2
18:57:26 <edwardk> but unlike strassen i'm not regularly splitting into quadrants, i'm saying split one of A or B, but don't tell me which, or which direction
18:57:37 <edwardk> =)
18:57:54 <danharaj> that's kinda brilliant
18:58:01 <edwardk> and its splitting the matrix that is the 'right' matrix to make sure that it can assemble C in the right order
18:58:14 <edwardk> thank you =)
18:58:28 <edwardk> in many ways it is better to not call this splitting
18:58:32 <edwardk> because splitting implies i renumber
18:58:39 <edwardk> i'm 'thinning' the matrices
18:58:46 <edwardk> i'm leaving the indices where they were
18:58:51 <edwardk> but replacing half the matrix with 0s
18:59:06 <edwardk> that is really really important to how it all fits together
19:00:06 <edwardk> so its replacing A with (A_{i < 2 fattest split} + A_{i >= 2 fattest split})   and then using the commutativity of addition
19:00:37 <joelteon> anybody happen to know whether you can configure indent depth in vim2hs?
19:00:55 <edwardk> and the 2 fat splits of the result matrix are like ley lines or something, they run through your matrix somewhere, you always have the 'brightest' ley line you can split on
19:01:11 <edwardk> the 2-fattest number in a range is unique
19:02:06 <danharaj> edwardk: I wonder how your technique compares to other sparse matrix multiplication algorithms?
19:02:09 <edwardk> but once we do the split, we get a nice property. i just cut my matrix somewhere in the middle of the range, the new matrices have at least one element each.
19:02:19 <danharaj> have you looked at Yuster-Zwick?
19:03:07 <edwardk> well, this version implemented directly seems to wind up with O(nnz log nnz + log n)    vs. O(nnz + n) traditionally
19:03:49 <edwardk> i haven't done a good literature search
19:03:58 <edwardk> i wasn't planning on inventing something
19:04:06 <edwardk> i was planning on implementing a fairly standard matrix multiply
19:04:14 <edwardk> then i kept simplifying because i didn't like the recursion pattern
19:04:48 <danharaj> and now you have something that sounds fast and hella cache coherent
19:05:06 <edwardk> yeah
19:05:18 <edwardk> especially given that the result is being reassembled by a series of merge steps
19:05:32 <edwardk> so there should be a cache oblivious way to run the merge tree
19:05:52 <danharaj> edwardk: now how would you parenthesize chained multiplication based on calculating masks?
19:05:54 <edwardk> one should be able to kill the log nnz factor
19:06:40 <edwardk> well, i just finished working out that i can similarly decompose valiant's upper triangular transitive closure algorithm using the same trick
19:06:52 <danharaj> ah
19:07:02 <edwardk> it showed me that valiant's algorithm is 2 steps of my simpler one, but by splitting the steps i usually don't have to take both!
19:08:49 <danharaj> edwardk: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.159.7650&rep=rep1&type=pdf#page=229
19:08:55 <danharaj> this looks very similar to your reasoning
19:09:01 <edwardk> vaiant's algorithm works with some upper triangular matrix, lets say it has components [ A X , 0 B ], so A in the upper left, X upper right, 0 lower left, B lower right.
19:09:02 <edwardk> so given W = [ A X, 0 B ] we want C = C^2 + W the transitive closure
19:09:03 <ubikation> what's a good project to learn about high performance disk io?
19:09:03 <danharaj> … why am I doing a literature search now
19:09:06 <danharaj> what did you do to meeeeee
19:11:09 <edwardk> valiants algorithm notes that if you break that up, you get C = [ A' X', 0 B' ] = [ A' X', 0 B' ] [ A' X', 0 B' ] + [A X, 0 B].. solving for components gives you A' = A' A' + A    -- which is a recursively smaller subproblem, recurse.  same for B'  but X' = A'X' + X'B' + X   -- rename and you get Y = AY + YB + Y as the thing you need to solve for
19:11:14 <edwardk> er
19:11:19 <edwardk> Y = AY + YB + X
19:12:01 <edwardk> so we want Y = V(A,X,B) some function of its inputs, and then we can use that recursively
19:12:11 <danharaj> ok
19:12:31 <edwardk> normally you break Y up into quarters and do the some reassociating
19:12:51 <edwardk> but if you break Y up into either two columns or two rows you can derive my variant of valiant's algorithm
19:12:59 <edwardk> then you say you don't get to choose...
19:13:06 <edwardk> and its the same construction as matrix multiplication!
19:13:12 <danharaj> surprise
19:13:31 <gambogi> alright so I have a question, and I can't seem to find an answer online
19:13:33 <edwardk> and then valiant's algorithm is my optimized form but here you slavishly choose to subdivide A then B
19:13:40 <edwardk> regularly at each step
19:13:55 <gambogi> is it possible to define a custom toFloat function?
19:13:55 * hackagebot husk-scheme 3.12 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.12 (JustinEthier)
19:14:05 <edwardk> where as i am choosing the subdivision in the order that spits out my result perfectly in morton order
19:14:25 <danharaj> quite good
19:14:29 <gambogi> for a newtype that wraps float
19:14:44 <edwardk> letting the most significant most significant difference in A, B or X guide the splitting of Y
19:15:06 <danharaj> edwardk: why do you seem to be repeating "most significant" every time
19:15:11 <edwardk> splitting A horizontally yields a top half and a bottom half of Y
19:15:27 <edwardk> because i have the most significant difference in X   and the most significant difference in Y.
19:15:32 <danharaj> ah yes
19:15:38 <edwardk> and i'm in the most sigificant difference between those differences
19:15:39 <danharaj> my brain was eliding that
19:15:47 <edwardk> er i'm interested in
19:16:20 <edwardk> so i'm choosing based on the 2-fat decomposition of the possible entries in the result matrix
19:17:12 <edwardk> and favoring splitting on that rather than the traced out dimension
19:17:49 <edwardk> because when its on a 'real result dimnsion i don't have to merge streams, i just concatenate
19:17:59 <edwardk> but when its a split on the trace i have to merge
19:18:20 <edwardk> see https://github.com/ekmett/sparse/blob/master/src/Sparse/Matrix.hs#L354
19:18:40 <edwardk> `add` is used when its a split on 'j' and fby is used when its on i or k
19:18:54 <danharaj> two letter variables??
19:18:57 <enthropy> haskell-src-exts (in an unreleased version) has things like GHC § 7.6.3.4 Does that actually mean GHC ≥ 7.6.3.4?
19:19:09 <edwardk> started running out and didn't feel like greek ;)
19:19:36 <edwardk> read them like subscripts. i do ;)
19:19:37 <danharaj> makes my last reddit comment particularly relevant ;p
19:19:50 <danharaj> yeah that's how I write my indexed variables
19:20:01 <danharaj> I took you for a partisan though
19:21:00 <edwardk> i use x:xs too
19:21:03 <bscarlet> edwardk: have you or are you going to write this stuff up somewhere for those of us who can't quite follow along at full speed for lack of background?
19:21:04 <edwardk> i'm not a purist ;)
19:21:46 <edwardk> bscarlet: i'm thinking about doing something, maybe on the school of haskell if i can bring myself to learn their tools
19:22:01 <danharaj> edwardk: it's either that or resurrect comonad reader
19:22:09 <edwardk> i started this friday, so i'm still feeling my way along
19:22:10 <enthropy> > let f (x:(reverse -> sx)) = x : sx in f "hello world" -- that's worse?
19:22:11 <lambdabot>   Illegal view pattern:  reverse -> sx
19:22:11 <lambdabot>  Use -XViewPatterns to enable view pat...
19:22:20 <danharaj> view patterns?
19:22:23 <danharaj> in my GHC?
19:22:28 <enthropy> used to be legal
19:22:44 <edwardk> enthropy: i think elliott turned off a lot of things
19:22:57 <edwardk> elliott: i'd like to petition for the return of ImplicitParams to lambdabot
19:23:22 <enthropy> probably extensions don't slow it down nearly as much as having heavy packages imported
19:23:27 <elliott> bit busy now but I can fix that later tonight -- it's an upstream problem but I can hack around it
19:23:41 <startling> ImplicitParams isnice, especially since you can use it for pseudo-holes
19:25:00 <danharaj> edwardk: well now I don't think I can context switch from matrices to anything else before I get to sleep :P
19:25:40 <edwardk> =)
19:25:42 <edwardk> good
19:25:54 <edwardk> send me more references, benchmarks, code, thoughts. ideas =)
19:26:07 <edwardk> lest i fall out of this rather productive vein =)
19:26:44 <gambogi> anyone have any ideas?
19:27:07 <startling> gambogi, sure
19:27:20 <startling> toFloat (MyCustomThing f) = f
19:28:32 <enthropy> gambogi: where is toFloat? Maybe you mean fromRational?
19:30:12 <danharaj> edwardk: I wonder if your approach can be fused because of how well it interacts with morton ordering?
19:30:15 <gambogi> enthropy: no, I want a function with this type
19:30:22 <gambogi> :: MyType -> Float
19:30:44 <gambogi> toFloat was just a name I picked out of the air
19:30:50 <enthropy> you can use startling's definition then
19:31:04 <edwardk> well matrix multiplication is a bit of a fusion blocker in general, but i do have stream fusion combinators in a tree
19:31:07 <danharaj> edwardk: would need a bit of extra metadata than just the stream of matrix entries
19:31:09 <k3VB6u4d> I’ve read that it’s possible to use a Unicode symbol for a function identifier, is that true? I’ve tried “÷ x y = x / x,” but the interpreter throws “parse error on input `÷'.”
19:31:16 <enthropy> a 'shortcut' is to define     newtype MyCustomThing = MyCustomThing { toFloat :: Float }
19:31:34 <edwardk> in practice it may be better for me to come up with my own fusion construction though that adds things to a k-ary merge
19:31:48 <danharaj> hm
19:31:52 <startling> k3VB6u4d: you need {-# Language UnicodeSyntax #-} at the top of your file
19:32:03 <edwardk> so given the binary merge tree it'd build the right cache oblivious merge or fixed k-ary merge tree
19:32:07 <enthropy> k3VB6u4d: also:   x ÷ y = x / y
19:32:15 <enthropy> k3VB6u4d: also:   (÷) x y = x / y
19:32:38 <danharaj> edwardk: can the new bundle-of-streams framework accommodate that?
19:32:41 <edwardk> so accumulate the promises to add the results of the nested matrix multiplies into a bag of 'results to be added' and then merge them all together
19:32:51 <edwardk> i think its distinct
19:33:05 <k3VB6u4d> startling, enthropy: Amazing. Thank you!
19:33:14 <edwardk> because here we're relying on the fact that we're only doing merges of merges of merges, so we have a merge tree
19:33:20 <edwardk> and its about how to productively pump a merge tree
19:33:28 <edwardk> which is a well studied cache oblivious algorithm,
19:33:37 <edwardk> after all most of them descend from funnelsort
19:34:12 <edwardk> but the bundle of streams trick is about being able to spew out blocks of data at a time SSE style
19:34:20 <edwardk> the interleaving would be all out of whack and piecewise
19:34:25 <danharaj> hmm
19:34:27 <edwardk> so i don't anticipate that stuff working at all
19:34:34 <danharaj> I thought of the bundle of streams trick as bundling different request patterns
19:34:51 <edwardk> sure
19:34:55 <danharaj> and if I kept requesting your algorithm's request pattern it'd be able to hold on to everything until we force it, and then it could do the merge algorithm
19:35:01 <edwardk> but here we always give you a crappy request pattern
19:35:16 <edwardk> because each of them is going to b competing to give you a bunch of records
19:35:26 <gambogi> enthropy, startling, thanks guys, that's been giving me issues for a week :p
19:36:00 <edwardk> if i had actually streamed _out_ the intermediate results there might be some room for playing some game with one of erik demaine's tricks for optimal set unions
19:36:09 <edwardk> but online there isn't much i can do
19:36:25 <danharaj> ah
19:40:57 <danharaj> oh, cool. Leijen did some work with type inference with existential types.
19:42:17 <danharaj> I was beginning to think no one cared about that :P
19:42:36 <startling> leijen wrote a pretty OK pretty-printing library, too
19:43:17 <danharaj> is pretty-printing where you output a json object that then gets turned into html
19:44:59 <tabemann> a ha!
19:45:25 <tabemann> just read in the Marlow book that using the main thread heavily with -threaded, due to it being a bound thread, can be slow
19:46:09 <danharaj> that's good to know
19:46:11 <danharaj> thanks
19:46:20 <startling> danharaj: not quite
19:47:33 <tabemann> I just changed my code so that both my producer and consumer threads where in unbound threads, and it got much faster with -threaded and +RTS -N1
19:47:51 <tabemann> but interestingly enough, it got somewhat slower without -threaded
19:48:37 <tabemann> this does mean that, if one is using the main thread with other threads, one might just want to put one's code inside a big forkIO, to avoid this
19:52:05 <danharaj> tabemann: or just use -N2
19:52:19 <danharaj> (I think)
19:52:45 <tabemann> -threaded and +RTS -N2 is significantly slower than -threaded and +RTS -N1
19:52:56 <danharaj> really? I clearly don't know what I'm talking about.
19:53:05 <tabemann> interestingly it's also *far* less consistent in its performance than +RTS -N1
19:54:31 <tabemann> the reason is most likely that with +RTS -N1 it is just the GHC RTS quickly switching between threads within the same OS thread, but in +RTS -N2 it is synchronization between OS threads that are likely (but not necessarily) on different cores (and with OS context switches being involved in waiting)
19:55:23 <startling> is there a Monad instance for this? https://gist.github.com/startling/912acff234a23080927a
19:55:57 <tabemann> testing stuff like this does make me feel horrified that I ever wrote concurrent code in, say, C++ with pthreads, and actually tried to performance-dependent things with that
20:00:20 <tabemann> hmm... all the cases of deriving (Monad) I can find online appear to be actually GeneralizedNewtypeDeriving
20:01:18 <danharaj> GHC can derive Functor with -XDeriveFunctor but I do not know about monad.
20:01:40 <startling> it definitely can't.
20:01:46 <startling> or doesn't, at least.
20:02:13 <startling> tabemann: Free is a little like being able to derive Monad, though, depending on what your type looks like.
20:02:14 <roboguy_> startling: what sort of constraints are you looking for on f? just Functor?
20:02:46 <startling> roboguy_: I don't know, I can't see what I would need.
20:07:02 <roboguy_> startling: I have a feeling you would need Applicative and Comonad but I'm not sure
20:09:24 <roboguy_> startling: if I were trying to make a Monad instance for that, I'm thinking I would define it in terms of join and return
20:11:22 <tabemann> question
20:11:28 <tabemann> can you derive Applicative?
20:11:40 <Xochipilli> pm tabemann
20:11:43 <tabemann> as if you can derive Applicative, you can derive return (= pure)
20:12:22 --- mode: ChanServ set +o elliott
20:12:26 --- mode: elliott set +b Xochipilli*!*@*
20:12:30 --- kick: Xochipilli was kicked by elliott (Xochipilli)
20:12:39 <tabemann> good
20:12:42 --- mode: elliott set +b $a:Xochipilli
20:12:46 --- mode: elliott set -o elliott
20:13:06 <tabemann> so then the question is how does one derive join
20:13:10 <scshunt> The reason that Functor is derivale is because it's unique
20:13:11 <isomorphismes> foldr is awesome
20:13:24 <scshunt> The same is not true for more complex typeclasse
20:13:34 <tabemann> oh yeah, Applicative isn't unique
20:14:27 <tabemann> so then I doubt that Monad is derivable
20:15:40 <tabemann> oh yeah, it can't be
20:15:47 <tabemann> e.g. Either can have two different monads
20:16:29 <scshunt> it can have many
20:16:32 <tabemann> yeah
20:16:44 <roboguy_> tabemann: all monads have applicative instances, so because applicative isn't unique neither is monad
20:16:49 <scshunt> because there's no guarantee that a Left value is preserved
20:17:03 <tabemann> roboguy_: that's what I'm thinking
20:17:10 <roboguy_> tabemann: especially because of ap
20:17:31 <scshunt> (Left _) >>= f = Left undefined
20:17:33 <scshunt> for instance
20:17:55 <haasn> roboguy_: it's possible that only one applicative instance may be extended into a legal monad; I don't know
20:18:25 <roboguy_> haasn: hmm, good point
20:18:28 <haasn> consider [] which has at least two applicative instances but only one monad instance that I know of; I don't know if it's unique but it certainly could be
20:18:33 <tabemann> no
20:18:39 <tabemann> e.g. Either can have at least two monads
20:18:47 <roboguy_> scshunt: but if we allow that, wouldn't we say that Functor doesn't have a unique instance
20:19:09 <tabemann> because even in the trivial case, one can swap the left and right hand sides for Either, in how an Either monad would behave
20:19:17 <enthropy> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
20:19:17 <lambdabot> f a b c = b (a c) c
20:19:41 <enthropy> so that's (>>=) for Reader
20:19:52 <enthropy> Reader r
20:19:59 <tabemann> wait
20:20:00 <tabemann> no
20:20:09 <tabemann> one can't, because there's no flip for types
20:20:10 <sclv> no either doesn't have two monads
20:20:14 <sclv> unless it has two functors
20:20:19 <sclv> monad instances are unique upto iso
20:20:25 <tabemann> forget my comment
20:20:30 <sclv> just like functor instances
20:20:58 <sclv> but i don't think there's a general way to derive monad instances
20:21:10 <tabemann> has someone proved that monad instances are unique?
20:21:19 <sclv> yes
20:21:50 <sclv> its a special case of classic categorical knowledge iirc
20:22:27 <cdk> so someone (tibbe I think?) wrote a new parallel IO manager that scales better than the 7.6 version, and now mio has further improved upon that?
20:22:29 <scshunt> ok, I have actually concluded only one actual thing from this conversation
20:22:32 <scshunt> and that is that I'm tired
20:22:43 <tabemann> wait
20:22:45 <tabemann> what about this
20:22:52 <scshunt> sclv: [citation needed] on monads unique
20:22:56 <sclv> cdk: yes
20:23:05 <tabemann> two different monads, both of which increase an internal counter with each >>=
20:23:14 <tabemann> except one increases it by a factor of one
20:23:22 <haasn> tabemann: not a monad
20:23:22 <tabemann> and the other increases it by a factor of two
20:23:27 <haasn> tabemann: x >>= return  = x
20:23:28 <sclv> breaks teh monad laws
20:23:35 <tabemann> forgot about that
20:24:16 <haasn> sclv: I wonder what kind of deep relationship the fact that Functor/Monad instances are unique but Applicative instances are not represents
20:24:22 <cdk> sclv: do you know where the IO manager stuff lives in the github repo?
20:24:46 <tabemann> but what about this
20:25:00 <sclv> monads are unique for totally different reasons than functors i think
20:25:15 <tabemann> a state monad, which along with the state with each put stores a value increasing by one
20:25:22 <sclv> again breaks the laws
20:25:24 <sclv> the same way
20:25:34 <sclv> oh wait on puts only
20:25:50 <tabemann> and the other which increases it by a value of two
20:25:56 <sclv> but put isn't part of the monad definition!
20:26:01 <haasn> ^
20:26:01 <sclv> that's an additional set of laws
20:26:17 <sclv> >>= fmap and return are still the same
20:26:45 * tabemann was confusing "monad" with "instance of Monad" there
20:26:49 <haasn> on a related note, it certainly seems possible to write a DeriveMonad extension that derives monad instances for types which are free monads
20:27:20 <sclv> haasn: oh good point. its pretty easy to figure out if a type is a free monad
20:27:30 <sclv> you could probably help it to handle other straightforward algebraic cases too
20:28:05 <sclv> but i don't think that you could e.g. figure out something like list
20:28:10 <sclv> without some additional thought
20:28:45 <tabemann> okay, another stupid question
20:29:31 <sclv> or the cont monad
20:29:48 <tabemann> forget it
20:30:06 <dolio> I don't know. Cont is probably easy to figure out automatically.
20:30:16 <dolio> @djinn a -> Cont r a
20:30:16 <lambdabot> Error: Undefined type Cont
20:30:25 <dolio> @djinn a -> (a -> r) -> r
20:30:25 <lambdabot> f a b = b a
20:30:56 <dolio> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
20:30:56 <lambdabot> f a b c = a (\ d -> b d c)
20:31:17 <dolio> Of course, it's a totally different procedure.
20:31:32 <tabemann> okay, what if you have a >>= that is like that for an existing monad, except it *never* calls the supplied function, and returns the first value passed to it (so what monad law am I breaking here?)
20:31:52 <sclv> haha dolio i like that idea -- just autoderiving using djinn
20:31:56 <dolio> return x >>= f = f x
20:32:24 <sclv> except then what if there are many things of the right type but only one satisfies the laws
20:32:36 <dolio> Except in some trivial cases, you have to call f.
20:32:39 <sclv> that's why cont is easy for djinn i suppose -- there's only "one way" to do it
20:32:44 <haasn> sclv: djinn+quickcheck
20:32:45 <roboguy_> tabemann: I don't think that would type check would it?
20:32:46 <haasn> =)
20:32:46 <dolio> Right.
20:33:10 <tabemann> roboguy_: oh yeah
20:33:46 <tabemann> oh wait
20:34:12 <tabemann> you make the "contained" value in the monad be undefined
20:35:15 <sclv> on the "monad instances are unique" tip dolio might have a better source
20:35:17 <roboguy_> tabemann: ?
20:35:25 <dolio> I do not.
20:35:28 <sclv> but i just checked and it looks like its in moggi's notions of computation and monads
20:35:29 <sclv> http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
20:35:39 <sclv> but that is heavy categorical lifting
20:36:04 <tabemann> roboguy_: what I mean is, instead of >>= returning the value passed to it, it returns undefined, which then can typecheck, as the function (a -> m b) will match bottom (as bottom can be any type)
20:36:29 <tabemann> or rather it returns a container of some type containing undefined
20:36:33 <roboguy_> tabemann: wouldn't that also break the law return x >>= f x?
20:36:38 <sclv> i think the intuitive way to approach it is to come from the fact that given a left (resp right) adjoint the corresponding functor is uniquely determined
20:36:47 <apples> i'm trying to model a simple language using GADTs. i have variable binding, so i need to pass around some map from strings to values of the GADT. but Map String (F a) won't work, right? because it requires all 'a's to be the same, when they could be F Int, or F Bool, or whatever
20:37:09 <sclv> so therefore the monad is necessarily unique
20:37:13 <tabemann> roboguy_: but return x would return a container containing undefined too
20:37:22 <dolio> I don't know if that works.
20:37:45 <roboguy_> hmm
20:37:50 <sclv> returning undefined breaks all the laws
20:38:15 <dolio> Like, it's not obvious that you couldn't have two monad structures on the same functor, with them factoring to adjunctions between different categories.
20:38:37 <sclv> dolio: right, its just a start i think
20:38:39 <dolio> Since if they were two different monads, the categories of algebras could be different.
20:40:09 <sclv> i'm suddenly surprised i don't know the source for this claim which i've 'always' known
20:40:14 <tabemann> sclv: somehow the monad laws don't seem to anticipate the possibility that one can create a monad whose value a in m a is always internally undefined, and which never evaluates f in x >>= f (but will still typecheck, as undefined will typecheck against any parameterized type)
20:40:16 <roboguy_> sclv: actually would it if return x = undefined and m >>= f = undefined?
20:40:40 <sclv> once you introduce undefined you can't talk about monad laws typically
20:40:49 <dolio> That doesn't work.
20:40:55 <dolio> return x >>= f = f x
20:40:56 <sclv> because we do our work in the unlifted domain
20:41:11 <dolio> It can't be undefined unless f x is undefined.
20:41:15 <tabemann> but wait
20:41:20 <tabemann> f x must return undefined anyways
20:41:31 <sclv> but you can't force that!
20:41:33 <tabemann> so return x >>= f must equal f x as f x must be undefined itself!
20:41:35 <sclv> f is any function
20:41:40 <sclv> you don't get to pick what f is
20:41:43 <tabemann> but f x must return m a, and any value m a is undefined
20:41:47 <roboguy_> tabemann: what if you have direct access to the constructor?
20:42:06 <sclv> throw out undefined and you get the () monad
20:42:06 <dolio> For what monad is every value of m a undefined?
20:42:21 <sclv> which is perfectly legit
20:42:21 <dolio> And what are your two different monad structures on m?
20:42:29 <roboguy_> tabemann: then you could construct a function "a -> m b" for some a and b that isn't undefined
20:42:36 <sclv> and the () monad trivially has a unique monad instance
20:42:37 <tabemann> what if you have, say, not undefined but [undefined]
20:42:48 <tabemann> so all values of m a are [undefined]
20:42:56 <dolio> What type is that?
20:43:05 <tabemann> [undefined] can be any [a]
20:43:16 <dolio> No.
20:43:23 <dolio> What type has [undefined] as its only value?
20:43:30 <dolio> That's what you're saying.
20:43:42 <tabemann> newtype UndefinedMonad a = [a]
20:43:53 <dolio> Wrong.
20:44:21 <dolio> What about [undefined,undefined].
20:44:32 <dolio> Or [5,6] if a = Integer.
20:44:38 <dmj`> anyone get lambdabot installed on OSX? having issues with regex-pcre
20:45:04 <roboguy_> tabemann: for example, let f x = UndefinedMonad [x+1] in return 50 >>= f
20:45:36 <hpaste> tabemann pasted “Undefined list monad” at http://lpaste.net/91829
20:45:38 <roboguy_> that would be undefined, but it should be f 50
20:46:13 <hpaste> tabemann revised “Undefined list monad”: “Undefined list monad” at http://lpaste.net/91829
20:47:46 <ion> length (f [1,2,3]) == length (return [1,2,3] >>= f)?
20:49:03 <tabemann> that return x >>= f == f x works, because f x must be [undefined]; x >>= \y -> return y == x works, because both x and return y must be [undefined]; x >>= \y -> y >>= z == (x >>= y) >>= z works because both must always evaluate to [undefined]
20:49:18 <tabemann> but being [undefined] allows it to be any [a], so the types work out
20:49:28 <ion> What dictates f x must be [undefined]?
20:49:36 <haasn> that's not even a valid data type declaration
20:49:37 <roboguy_> tabemann: we can make functions without using the monad operations though
20:50:02 <tabemann> because f x must have type m a, and all values of type m a must be [undefined], because both >>= and return always return values of [undefined]
20:50:36 <roboguy_> tabemann: this function has that type and is not undefined: f _ = UndefinedMonad [10]
20:51:27 <hpaste> tabemann revised “Undefined list monad”: “Undefined list monad” at http://lpaste.net/91829
20:51:51 <haasn> tabemann: UndefinedList [1,2,3] >>= return  ≠  UndefinedList [1,2,3] -- violated
20:52:28 <tabemann> I should have put a module definition in there to indicate that the internal state of UndefinedList was hidden
20:52:50 <roboguy_> tabemann: but that's missing the point. the point is that kind of function *can* exist
20:53:36 <tabemann> okay, so should we say that one can only make one monad type for *any given external interface*?
20:53:53 <tabemann> that is doesn't count as a [a] because I'm hiding it behind UndefinedList
20:53:53 <dolio> If you're hiding everything about the implementation, then you've created the constantly one-element monad.
20:54:13 <dolio> With a peculiar internal representation.
20:54:42 <dolio> It is not the same type as the implementation you are hiding.
20:55:16 <haasn> this reminds me of the moral debate of “is it okay to write an illegal Monad instance if the exported API doesn't let you observe the crime?”
20:55:21 <tabemann> so the "every type has only one monad" applies not to the internal representation but to the external interface
20:55:52 <c_wraith> haasn: I think that has been answered with a "yes, pragmatically - but don't screw up."
20:56:50 <tabemann> so then
20:57:05 <dolio> If I implement the natural numbers by representing them as integers, but only exposing an interface that lets you see natural numbers, is the type the natural numbers, or the integers?
20:57:06 <haasn> tabemann: either way, if you're considering external interfaces only, then I would only consider two Monad instances different if the external API lets you distinguish between them
20:57:43 <tabemann> so you could have a single internal representation for two different ADTs, with two different sets of different functions that act on them with different semantics, and have two different monad instances for those
21:01:19 <roboguy_> tabemann: well, all data is represented as bytes internally (in a typical computer).
21:01:47 * haasn prefers to represent all bytes as ‘data’ internally (in a typical language)
21:02:43 <haasn> c_wraith: if you screw up, the lambdacat will come after you
21:03:34 * tabemann wonders that, if one is implementing monads in Agda, whether it can *force* you to *prove* you follow the monad laws....
21:04:11 <haasn> roboguy_: I guess that's the same as saying all concrete types are isomorphic to some subset of the natural numbers
21:04:59 <c_wraith> I'm not scared of lambdacats: http://spl.smugmug.com/Humor/Lambdacats/i-MHs3MKC/1/M/i%20kant%20haskell%20today%20i%20has%20the%20dumb-M.jpg
21:06:09 <tabemann> that's the first time I've seen "haskell" used as a verb myself
21:06:59 <sclv> tabemann: yes
21:07:04 <sclv> i've seen it done
21:07:10 <sclv> w r t agda
21:18:36 <haasn> c_wraith: http://spl.smugmug.com/Humor/Lambdacats/i-GRjswk9/2/L/bitestring-L.jpg the mental image will not escape my head now :(
21:23:48 <black_13> is there a channel for functional programming in general
21:25:34 <NemesisD> hey guys. my program seems to be spamming the disk really hard at idle. As soon as i start it my disk light is solid. i tried monitoring it with strace and i see *tons* of FUTEX_WAIT_PRIVATE spam
21:25:57 <NemesisD> my program does use acid state but it shouldn't be doing anything to write the state at idle
21:53:11 <tabemann> question I should know the answer to
21:53:36 <tabemann> with cabal, how do you force rebuilding everything? (I know I've answered, and forgotten, this before)
21:59:15 <torwegia> How can I get a type error saying something expects a ByteString and the actual type given was ByteString?
21:59:41 <ion> torwegia: One is probably Data.ByteString.ByteString and the other is Data.ByteString.Lazy.ByteString.
22:00:46 <torwegia> Thanks, didn't think of that haha
22:02:16 <tabemann> it's just wonderful that Haddock will generate HTML that has stuff like ByteString -> ByteString in it, where one can only tell which ByteString is strict and which is lazy by mouse-over-ing
22:03:15 <enthropy> probably that issue isn't so easy to fix
22:03:50 <enthropy> since probably everybody who could fix it has probably been annoyed by it at least a bit
22:05:05 <edwardk> @tell startling the f (Maybe n) feels a little like bound. if you take the fixed point of that through f you get a monad. so you'd probably want some embedding of Open f n -> f n or to look at the conditions on an ideal monad, as OReference is a 'separated' type, so your monad is of the ideal   a + f' a form
22:05:05 <lambdabot> Consider it noted.
22:06:07 <edwardk> @tell startling which tells me that if it does exist, then your monad should have coproducts with other ideal monads
22:06:07 <lambdabot> Consider it noted.
22:06:38 <NemesisD> how would i i troubleshoot high disk usage from a program?
22:06:44 <NemesisD> would threadscope give me that?
22:08:26 <tabemann> I somehow suspect that threadscope wouldn't help there
22:08:36 <NemesisD> guess it doesn't matter. threadscope doesn't even build
22:10:40 <NemesisD> tabemann: when i strace the executable i see tons of FUTEX_WAIT_PRIVATE, though i don't know that that would hit the disk, but that's about all that's happening
22:11:47 <tabemann> is there thread contention over access to IO?
22:13:16 <NemesisD> there could be some contention. i have some threads waiting on tmvars as signals. i compiled with -threaded. you don't have to specify the thread count anymore with rts flags right?
22:15:06 <NemesisD> the program doesn't really do anything most of the time though. it is waiting on HUP/INT signals and runs an IO thread every 5 seconds or so
22:15:10 <tabemann> you still have to do +RTS -Nx where x is the number of capabilities (OS threads running Haskell), or +RTS -N if you want a capability for each core
22:15:20 <tabemann> otherwise it still will run Haskell in only one OS thread
22:17:06 <NemesisD> i'm curious as to why that isn't a default but either way, specifying an N still lights up my disk
22:18:24 <NemesisD> tabemann: it doesn't make sense to me that a futex wait loop would hit the disk
22:18:55 <tabemann> if there are multiple threads trying to access a shared Handle that the RTS is multiplexing between them...
22:18:59 * hackagebot tagged 0.7 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.7 (EdwardKmett)
22:20:34 <NemesisD> not sure what that shared handle would be. after having trouble with logging from multiple threads, i moved to piping all log messages through a TMChan and a single worker that writes it to disk with fast-logger
22:21:17 <tabemann> you could have contention over the TMChan
22:21:35 <NemesisD> those are implemented as a handle to something on disk though?
22:23:29 <NemesisD> i guess in general: rather than speculating on contention, are there any tools i could learn to get some insight to what is going on?
22:23:49 <tabemann> no no TMChan is implemented on top of TVar, which is an STM thing
22:28:59 * hackagebot yesod 1.2.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.2 (MichaelSnoyman)
22:29:01 * hackagebot yesod-auth 1.2.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.1 (MichaelSnoyman)
22:29:03 * hackagebot yesod-bin 1.2.2.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.2.1 (MichaelSnoyman)
22:29:05 * hackagebot yesod-core 1.2.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.4 (MichaelSnoyman)
22:29:07 * hackagebot yesod-form 1.3.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.1 (MichaelSnoyman)
22:29:32 <pentace> What does an asterisk denote in a class instance, e.g. "Functor (Proxy *)"?
22:30:10 <c_wraith> pentace: it indicates the type (Proxy, in this case) was compiled with the PolyKinds extension enabled
22:30:32 <c_wraith> pentace: and the * is telling you the kind of the type variable.
22:30:50 <c_wraith> pentace: (the type variable is unfortunately implicit in that definition)
22:31:11 <pentace> Okay. There are so many GHC extensions lately ...
22:31:59 <c_wraith> any instance of functor is going to require that the final (missing) type variable has kind *, so it's not actually informative in any way.
22:32:06 <c_wraith> It's kind of noise in this case.
22:34:09 * hackagebot yesod-test 1.2.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1 (MichaelSnoyman)
22:34:59 <NemesisD> figured out my problem. had something in a loop that didn't have a delay when it was meant to
22:35:05 <NemesisD> was beating up on the acid state handle
22:35:57 <NemesisD> anyone know if there's any plan for making threaded haskell executable automatically use the same number of capabilities as there are processors?
22:36:15 <tabemann> note that there is code that performs *worse* on more than one core
22:36:34 <tabemann> I actually coded up an example today that performs badly on -N2 relative to its performance with -N1
22:37:09 <NemesisD> which is more common
22:38:20 <tabemann> code that can effectively take advantage of parallelism would benefit from more cores; code that relies on extremely fast switches between threads but less on overall bandwidth would be better on one core
22:39:39 <NemesisD> right now the burden is on the former crowd to configure their executable. i'm just curious why that is the default and not the other way
22:39:49 <carter> edwardk: stilll up/
22:41:26 <tabemann> it might be better if defaults can be set into the executable at compile time
22:41:33 <zRecursive> Anybody here still uses Hugs which seems not maintained ?
22:44:59 <NemesisD> tabemann: ah yes that would be perfect
22:45:12 <NemesisD> seems like it is almost always dependent on the executable
22:45:32 <NemesisD> surprised that's not something you can configure in cabal
22:48:48 <tabemann> currently you have to do something like run your Haskell program from a shell script to force particular RTS settings
22:50:59 <tabemann> cabal question
22:51:24 <tabemann> how do you make cabal find the newest version of each package installed and reinstall them all, including downloading any new dependencies?
22:51:55 <tabemann> I just updated my GHC, and when I did cabal update; cabal install world --force-reinstalls, it said a lot of stuff would likely be broken
22:55:04 <Ghoul_> tabemann: I dont think you need to do that
22:55:16 <Ghoul_> doesn't it detect the newer ghc version, and hence, cabal install world should /just work/ ?
22:55:42 <tabemann> it's saying that a number of different things would likely be broken
22:55:51 <tabemann> and it's forcing me to use --force-reinstalls
22:56:11 <Ghoul_> your best bet might be to just delete .cabal and .ghc
22:56:35 <Ghoul_> I do it once a month. It's healthy and speeds up TH loading :P
22:57:07 <tabemann> okay, after I did cabal install semigroupoids it did it when I did cabal install world again
22:57:11 <carter> tabemann: sometimes tis good to wipe you ghc things
22:57:20 <carter> in your ~/.ghc dir
22:57:28 <carter> and cabal install anew :)
22:58:44 <tabemann> okay, just wiped everything
22:58:51 <carter> cabal update
22:58:58 <carter> and then cabal install your favorie things
22:59:01 <tabemann> even though there's a few things I know I will want to reinstall
22:59:06 <tabemann> such as quickcheck and criterion
22:59:13 <carter> for individual projects, sandboxing is a godsend
22:59:21 <carter> use cabal-install head and know joy :)
22:59:22 <tabemann> random question
22:59:30 <carter> pseudorandom answer
23:00:04 <tabemann> in your cabal settings, if you set it to build libraries as with profiling turned on, will that force *all* executables you build with them to one core, or only executables that you also set to build with profiling?
23:00:56 <carter> I don't undestand your question
23:01:05 <carter> lib profiling means you can CHOOSE to have profiling
23:01:18 <carter> you still by default get normal libs
23:01:30 <tabemann> okay
23:01:44 <carter> reasonable worry
23:01:48 <carter> if that was the case
23:01:51 <carter> it'd be a bug :)
23:06:13 <tabemann> shit
23:06:30 <tabemann> why is cabal installing my libs under */ghc-7.4.1 ?!
23:07:04 <tabemann> (well, I need to get to bed, so I'll fix that tomorrow)
23:23:16 <sordina> Hey Guys. Does anyone know a combinator to emit a single pure value with Netwire, then inhibit?
23:24:07 <sordina> Once doesn't seem to do what I want, since it inhibits the value being split into multiple values, only allowing the first of the split values to be emitted.
23:24:28 <sordina> (I could very well be misunderstanding how netwire is meant to work :))
23:36:00 <Javran> are all functions enclosed by graves left-associative?
23:36:40 <supki> Javran: by default, yes
23:36:50 <supki> Javran: you can use fixity annotations to change that
23:37:42 <Javran> supki: thanks for help!
23:45:51 <roboguy_> is there a way to get cabal to uninstall and then reinstall all the packages I currently have installed?
23:48:04 <cmears> roboguy_, maybe something like "cabal install --reinstall world --dry-run" is what you want
23:48:13 <cmears> (take away the --dry-run if it looks good)
23:48:27 <roboguy_> cmears: I'll take a look at that, thanks
23:48:46 <roboguy_> I changed cabal to automatically install profiling libraries and I think that broke everything
23:49:07 <roboguy_> *changed the cabal config file
23:49:10 <cmears> it complains that the already-installed dependencies weren't compiled with profiling?
23:50:33 <roboguy_> cmears: it says that it can't find modules that appear to be installed. I assume it's because they weren't installed with profiling
23:50:58 <roboguy_> and it's hard to reinstall them one at a time without breaking a bunch of stuff, apparently, so I think I need something to reinstall everything
23:51:05 <cmears> yeah, I've been there (:
23:51:25 <roboguy_> yeah, I guess this is the infamous cabal hell I keep hearing about haha
23:51:56 <cmears> "cabal hell" I think is more about multiple versions
23:52:02 <cmears> this is just cabal tedium
23:52:02 <roboguy_> ahh, right
23:52:33 <roboguy_> cmears: hmm, I'm getting some errors with that command
23:54:02 <roboguy_> stuff like "cabal: Could not resolve dependencies: trying: lambdabot-4.3" [...]
