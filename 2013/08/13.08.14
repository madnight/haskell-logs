00:08:26 <pxqr> why does cbits directory called so?
00:08:41 <Gracenotes> bits of C?
00:09:10 <pxqr> well, why 'bits' then? :)
00:10:10 <carter> its a tradition at this point
00:10:17 <carter> no deep reason
00:10:37 <carter> though haskell's performant enough, that you should only need a teeny bit of c :)
00:10:43 <carter> so
00:10:50 <carter> its for those rare low level things
00:11:19 <shachaf> There are many non-performance reasons to have C code.
00:11:38 <carter> true
00:11:47 <carter> like having a memory map function
00:11:52 <carter> or ffiing to a nice c libs
00:12:00 <carter> or
00:12:07 <Sculptor> or inlining asm
00:12:07 <carter> what else?
00:12:09 <Sculptor> lol
00:12:18 <carter> yeah, if you're using the CPU counter
00:12:21 <cads2> hey guys, has anyone here used the haskore library?
00:12:22 <carter> or something
00:12:28 <carter> not in years
00:13:07 <cads2> I'm wondering if it can be used to easily answer such questions as  "which scales contain the notes  {E A D G B}?"
00:13:58 <carter> ummmmmmmmm, why don't you read the code?
00:14:06 <cads2> according to my research there are 3;  D, and I think F, and G#
00:15:30 <carter> wikipedia might be a better resource
00:15:59 <roboguy_> cads2: well, what do you mean by "scale?" there are different kinds of scales
00:17:49 <cads2> robbert: Right, it would be nice to define a family of scales, which might include the greek harmoniai
00:18:37 <cads2> but in general might include the blues scales, or other arbitrary scales
00:20:04 <cads2> I think for western 12 tone music, a generalized scale might be a function that takes a pitch and returns a subset of the 12 pitches.
00:22:24 <roboguy_> cads2: it looks like that's what the scales in Haskore.Basic.Scale are like (they use absolute pitches though)
00:27:36 <cads2> neat
00:32:08 <cads2> the absolute pitches starting from 0 aren't bad
00:37:19 <tero-> I'm trying to debug a memory leak in a program archiving rows from postgresql database
00:38:29 <tero-> the main module code is at http://lpaste.net/91834
00:38:54 <tero-> it seems to hold all the results in memory as the memory usage grows to several gigabytes
00:40:06 <tero-> I'll try to profile what is being held, but if it is plain obvious what is causing the leak, I'm happy to hear :)
00:41:46 <Cale> It's a little hard to say with important bits of the code off in another module... :)
00:42:07 <platzhirsch> I am writing a birthday card, what is the most complex theoretical topic in Haskell you can think of?
00:43:58 <cads2> :)
00:44:00 <adnap> Can I wrap a number type, specifically Float, so that non-negative and non-zero values cannot be constructed?
00:44:15 <cads2> platzhirsch: I wonder what answers we'll see
00:44:45 <adnap> Homotopy Type Theory?
00:44:45 <johnw> platzhirsch: i'm still having trouble groking the use of singletons to simulate dependent typing
00:45:00 <platzhirsch> johnw: that sounds nice
00:45:06 <cads2> platzhirsch: I know arrows are complicated enough I don't really understand them, and lenses seem to have some really abstract theory too
00:45:08 <johnw> just write Oleg and a bunch of links
00:45:25 <platzhirsch> Oleg already did it, yay
00:45:32 <cads2> or better yet just Write "OlegOlegOlegOlegOlegOlegOlegOlegOleg.."
00:45:49 <cads2> starts to sound like you're saying "lego"
00:46:07 <levi> zygohistomorphic prepromorphisms?
00:46:11 <johnw> Oleg would write a birthday card that writes another birthday card when you open it
00:46:11 <tero-> Cale: http://lpaste.net/91835 http://lpaste.net/91836 http://lpaste.net/91837
00:46:26 <tero-> those should be the relevant modules
00:46:36 <levi> (not the most complicated, really, but has the craziest-sounding name)
00:46:48 * cads2 has a solemn admission: he doesn't actually know who this mythical Oleg guy is
00:46:53 <adnap> So... anyone know?
00:47:07 <adnap> (The answer to my question)
00:47:09 <cads2> despite hearing about his amazing talent for years now :)
00:47:39 <edwardk> cads2: http://okmij.org/ftp/
00:47:45 <edwardk> Oleg Kiselyov
00:48:00 <edwardk> one of the smartest people i've ever met
00:48:41 <levi> I think he must be an alien.
00:51:35 <cads2> I've looked him up before but prefer the fantasy that he's a figment of the community's imagination ;)
00:51:49 <cads2> Like Bourbaki
00:53:46 <carter> tero-:  have you seen the protobuf lib on hackage?
00:53:55 <carter> i sortah met him once
00:54:01 <carter> at popl2012
00:54:07 <carter> didn't get a chance to talk with him
00:54:16 <carter> @hackage protobuf
00:54:17 <lambdabot> http://hackage.haskell.org/package/protobuf
00:54:23 <carter> tis a very very very haskelly protocol bufffers libs
00:55:02 <Cale> tero-: Shot in the dark: What if you replace the return in the parameter to foldLogdEvents with Control.Exception.evaluate?
00:55:04 <tero-> carter: I think I used http://code.google.com/p/protobuf-haskell/ to generate those files
00:55:08 <carter> ah
00:55:15 <carter> tero-: you might like protobuf :)
00:55:23 <carter> its really really neat
00:55:27 <tero-> carter: thanks for the tip. I'll definitely have a look
00:55:32 <carter> like
00:55:41 <carter> you just write an annotated haskell datatype
00:55:52 <carter> and that specifies the protocol buffere format
00:56:08 <tero-> I'm assuming there a ton of TH doing the heavy lifting
00:56:14 <tero-> Cale: let's give it a shot
00:56:16 <carter> https://github.com/alphaHeavy/protobuf/blob/master/tests/Main.hs#L282
00:56:21 <carter> nope
00:56:23 <carter> no TH :)
00:56:30 <carter> just monoids
00:56:34 <carter> and type level nats
00:56:44 <carter> shoudl build with ghc even7.4
00:57:49 <Cale> tero-: Also, silly question, but you are compiling with optimisations, yes?
00:58:13 <tero-> ghc-options: -Wall -O2 -rtsopts
00:58:15 <carter> strictness is your friend when debugging perf
00:58:27 <ousado> uhm, protobufs don't support ADTs, right?
00:58:54 <carter> ousado?
00:58:57 <carter> hrmm
00:59:13 <carter> i think this lib is strictly more general than the normal spec :)
00:59:15 <tero-> Cale: testing. this takes a while because there are quite some rows in the database
00:59:31 <carter> if your alternatives have different field numbers
00:59:36 <carter> probably fine
00:59:42 <carter> idk
00:59:48 <carter> thats a VERY good question
01:00:06 <ousado> protobufs themselves don't
01:00:21 <ousado> just C-style enums
01:00:48 <carter> capnproto, the sequel, has them I think
01:00:49 <carter> http://kentonv.github.io/capnproto/language.html
01:01:08 <tero-> okay, it archived one month and now the memory usage is 271 MB
01:01:52 <levi> capnproto needs some new haskell love, since its author abandoned haskell for C++.
01:02:01 <carter> yeah
01:02:12 <carter> who has the time
01:02:24 <carter> the protobuf lib actually may be a good substrate to start wtih
01:02:56 <carter> granted, theres some compute things in capnproto
01:03:19 <carter> woahhh, it has RPC baked in
01:03:20 <carter> thats crazy
01:03:53 <levi> His initial idea, apparently, was capability-based secure RPC.
01:04:10 <tero-> it moved to the next unit and archived two months. the memory usage is now 422 MB. it seems to grow
01:04:22 <tero-> I'll try to profile now
01:04:32 <DireWombat> hi, I'm trying to get my head around the Proxy library (apparently Pipes is deprecated)
01:04:48 <carter> DireWombat its the same lib
01:04:51 <DireWombat> and my trivial function isn't passing the typechecker
01:05:23 <carter> DireWombat: have you read the tutorial in the haddocks?
01:05:26 <carter> @hackage pipes
01:05:26 <lambdabot> http://hackage.haskell.org/package/pipes
01:05:41 <carter> http://hackage.haskell.org/packages/archive/pipes/3.3.0/doc/html/Control-Proxy-Tutorial.html
01:06:03 <carter> a pipe is just a specialization of the proxy type
01:06:05 <DireWombat> yeah, I've been dumbing that down even more
01:06:14 <hpaste> DireWombat pasted “Trivial Proxy” at http://lpaste.net/91838
01:06:16 <carter> levi huh, neat
01:06:39 <tero-> uh, I need to profiling versions of all libraries
01:06:42 <carter> respond :: Monad m => b -> p a' a b' b m b'
01:06:42 <DireWombat> I get a kind mismatch
01:07:18 <DireWombat> so the Proxy type thingy takes 6 type parameters
01:07:43 <DireWombat> but I get complaints about too many type arguments after the first
01:09:05 <carter> yes
01:09:09 <carter> just use the Pipe type
01:09:44 <hpaste> DireWombat pasted “Alternative Trivial Proxy” at http://lpaste.net/91839
01:09:47 <carter> it needs to be Server Proxy (other stuff)
01:09:58 <carter> DireWombat: you're mssing the p param
01:10:29 <carter> if you look at the definitions for the simpler types
01:10:33 <carter> theres a parameter P
01:10:39 <carter> put Proxy there
01:13:14 <tero-> cabal-dev does not want to install profiling libraries because it cannot install profiling libraries for package 'base'
01:13:43 <levi> DireWombat: You might want to look at the pipes-4.0 stuff instead. It's got a much simpler tutorial and interface in general.
01:13:54 <tero-> time to fire up vagrant
01:15:29 <Saizan> tero-: the profiling version of base should have been shipped with your ghc, some distros like to split it in another package though
01:15:50 <DireWombat> levi - I was initially successful with Pipes
01:16:02 <DireWombat> but it told me I should use Proxy instead
01:16:07 <Saizan> tero-: you can't ask cabal to build them because base is too tied to ghc
01:16:20 <tero-> Saizan: I see. I'll see what package has them in Ubuntu 12.04
01:16:28 <DireWombat> I know my way around type classes and kinds so I didn't think it would be too hard
01:16:43 <levi> DireWombat: Yeah, that's why you want to ignore the Pipes/Proxy 3.x stuff and look at the 4.0 version on GitHub instead.
01:16:52 <DireWombat> gahh
01:17:08 <DireWombat> so Pipes 4 is the new stuff?
01:17:23 <DireWombat> not superceded by Proxy?
01:17:28 <merijn> DireWombat: Yes
01:17:48 <merijn> DireWombat: pipes 4 is the new version of pipes and has a simplified implementation
01:18:01 <merijn> DireWombat: It still uses Proxy internally, but the API is a lot cleaner
01:18:04 <DireWombat> I feel simultaneously very happy and very sad
01:18:14 <merijn> Why sad?
01:18:29 <DireWombat> because I spent a couple of hours trying to get a 1 line function to typecheck
01:18:38 <levi> I think it's still got Proxy under the covers, but you can do most of the things you'd typically want to do without resorting to Proxy.
01:18:52 <merijn> DireWombat: Story of my life
01:18:58 <DireWombat> lol
01:19:09 <DireWombat> I still don't know why the kinds didn't match up though...
01:20:52 <DireWombat> hmm, so I got it typechecking
01:21:27 <DireWombat> by using "(Proxy p) => p Void etc" instead of "Proxy Void etc"
01:21:58 <DireWombat> the proxy tutorial might be a bit off
01:22:53 <levi> Well, like I said, the 4.0 version will be hitting hackage soon and is much easier to follow.
01:23:13 <DireWombat> I look forward to it
01:23:47 <DireWombat> so pre-Pipes 4, is Proxy the library to use for Haskell deterministic file IO?
01:24:02 <levi> Probably not.
01:24:09 <DireWombat> I heard that we don't like lazy IO anymore
01:24:18 <DireWombat> so I wanted to learn this new-fangled stuff
01:25:06 <levi> One of the Enumerator/Iteratee libraries was the thing to do, and then there were Conduits, which see a reasonable amount of use thanks to Yesod, and then there's io-stream
01:25:14 <DireWombat> oof
01:25:18 <haasn> then there's machines, which is basically pipes 4
01:25:52 <DireWombat> so it's not really standardised pre Pipes 4?
01:25:56 <levi> Well, machines is *there*, but is anyone using it?
01:26:03 <haasn> I don't think so
01:26:17 <levi> DireWombat: I'm not sure why you think Pipes 4 will make everyone suddenly standardize on it.
01:26:51 <DireWombat> well, most languages have standard IO libraries
01:27:02 <DireWombat> if lazy IO is not the thing to do anymore
01:27:15 <levi> IO is the standard IO library. :)
01:27:21 <DireWombat> I want to learn the standard deterministic IO approach
01:27:31 <levi> There is none.
01:27:40 <DireWombat> oof
01:27:57 <DireWombat> that's unfortunate
01:27:57 <Cale> You can always just use strict IO directly, without fancy iteratee libraries.
01:28:03 <DireWombat> sure
01:29:01 <DireWombat> haskell tends to take a while to do something that's "basic" in an impure language, but comes up with nicer abstractions
01:29:07 <merijn> DireWombat: Also, if you're just messing around to learn haskell, there;s not a lot wrong with lazy IO
01:29:26 <DireWombat> I know haskell pre-funky new stuff
01:29:50 <merijn> DireWombat: Anyway, you can also just grab the new pipes of github and install to play with it
01:29:56 <DireWombat> just want to be on top of the "best practice" stuff
01:29:58 <merijn> The haddocks are mostly done
01:30:17 <merijn> Just have to make sure you build the docs locally
01:30:23 <DireWombat> okay
01:30:26 <klugez> DireWombat: If you want to look at conduit, start here: https://www.fpcomplete.com/school/advanced-haskell-1/conduit-overview
01:31:17 <DireWombat> thanks - I read conduits is focused more on perf/practical-use, whereas pipes is more about elegance?
01:31:31 <levi> DireWombat: The warp/wai/yesod ecosystem uses conduit; snap is moving to io-streams; happstack's maintainers are planning on moving to pipes-4.0
01:32:18 <DireWombat> oh wow
01:32:25 <levi> And a bunch of stuff, like current snap and happstack and various other things, are still using iteratee libraries, which work just fine.
01:32:41 <levi> Plus, they are Oleg-approved!
01:33:00 <DireWombat> haha
01:33:15 <DireWombat> every time I try to read an Oleg post my brain explodes
01:33:45 <klugez> It's a shame the split is just getting worse.
01:34:16 <klugez> Hopefully pipes 4 manages to be simple enough and "wins".
01:34:16 <levi> Well, he invented the iteratee thing, which made lots of brains explode, thus all the other libraries.
01:34:23 <DireWombat> skimming the iostreams docs - it's not iteratee-based is it, it's just strict stuff in the IO monad
01:34:56 <johnw> levi: I think the iteratee thing fell out of all the work he was doing with delimited continuations
01:35:15 <klugez> Because it sure would be easier, if you wouldn't have to learn a new streaming concept when you switch a library.
01:35:19 <DireWombat> klugez: from my little bit of reading I was hoping the same
01:35:49 <DireWombat> and at the very least if I want to learn the iteratee concept, I'd pick the most elegant library :)
01:36:43 <johnw> the iteratee concept shows up in other languages quite simply; much of the complexity is understanding how it works in a pure, lazy language like Haskell
01:37:26 <DireWombat> johnw - is that really so? don't you have to plumb on-demand computations yourself in other languages?
01:37:53 <johnw> DireWombat: what I mean is that when you encounter the concept in, say, Python, it's a built-in so you never have to learn how it works underneath
01:37:56 <DireWombat> it seems that iostreams does what other languages do - shove everything into the IO monad and make operations strict
01:38:15 <DireWombat> so you have to program the laziness yourself
01:38:25 <johnw> what's cool about Oleg's original trick is that you can get the same behavior with just a library
01:38:49 <DireWombat> haskell is good that way (like how lens is just a library)
01:38:51 <Cale> What's Python for (/>/)? ;)
01:39:20 <johnw> Cale: I was just thinking of the await/yield core, I'm not able to say that Python replicates all of Pipes
01:39:21 <DireWombat> filtering good Java programmers
01:39:25 <johnw> Pipes is a maturation of the concept, for sure
01:40:17 <DireWombat> I think there's a Reactive library in .net (ported elsewhere too) that may do something similar
01:40:18 <levi> DireWombat: I'm not sure I'd characterise io-streams as 'just throw it in IO and make it strict'
01:40:38 <DireWombat> levi - that's from my quick skim of docs - does it add more structure?
01:41:32 <DireWombat> I see "3 fundamental IO primitives: read, unread, write"
01:41:57 <DireWombat> which produce IO actions, on the InputStream and OutputStream types
01:43:15 <levi> It's still basically automata-based. It's in IO mainly to simplify resource management, AFAICT.
01:44:35 <DireWombat> interesting - digging around, I see "connect" and "supply" functions
01:44:55 <DireWombat> which are presumably like >-> and <-< in Proxy
01:45:01 <DireWombat> and <+< in Pipes
01:45:38 <levi> Gabriel Gonzales wrote System.IO.Streams.Tutorial, so he's clearly not too down on it.
01:47:19 <DireWombat> it's a real shame there's a schism here
01:47:39 <Cale> I don't think so. I don't think that any of these libraries are obviously the right thing.
01:47:54 <DireWombat> what do people teach haskell newbies?
01:47:57 <levi> It's not really a schism. It's a healthy ecosystem where ideas in a relatively new design space are being explored.
01:47:57 <DireWombat> lazy IO?
01:48:09 <Cale> Yeah, lazy or strict IO.
01:48:43 <DireWombat> I suppose it's early days for this abstraction
01:48:57 <levi> Or, if they want to do web programming, whatever their chosen framework picked.
01:49:20 <Cale> In fact, I have up to this point always preferred direct style IO to using one of these, though I've taken a fair amount of time to understand how these libraries work and what they do.
01:49:28 <DireWombat> really?
01:49:30 <Cale> I don't like how cluttered they are at the type level.
01:49:41 <DireWombat> yeah, Proxy has 6 type parameters...
01:49:49 <Cale> (Well, maybe not so much io-streams)
01:50:11 <shachaf> Proxy has one type parameter. Maybe pipes:Control.Proxy.Proxy has six.
01:50:27 <shachaf> But the name canonically means something else.
01:50:55 <Cale> shachaf: Yeah, this is a discussion about pipes.
01:51:28 <DireWombat> I'm hoping that Haskell will birth the "right way" to do deterministic IO the way that monads are the "right way" to abstract side effects
01:52:00 <Cale> Pipes is I think the nicest of the libraries at the term level, but all the ones which try to be abstract at all end up a mess at the type level. I think if we had some better type-level data structures, it might be okay.
01:52:37 <DireWombat> the siren call of dependent types!! :O
01:52:39 <Cale> Even just tupling together the types nicely and adding some type-level functions to pick out the components would probably go a good ways.
01:52:55 <merijn> Cale: I think the type aliases of pipes 4 actually makes it rather nice on the type level too
01:53:11 <merijn> Although the choice to have non-polymorphic aliases by default is a bit unfortunate
01:53:15 <johnw> DireWombat: "effect systems" are still an active research topic, Monads are certainly the right way if there's only one type of effect
01:53:34 <shachaf> A way, anyway.
01:53:52 <Cale> merijn: Where is this?
01:54:08 <Cale> merijn: The types still look messy to me in the pipes 4 that I found
01:54:37 <levi> I read Guy Steele's paper describing his experience with Haskell and Monadic programming. Was an interesting piece, especially considering the ancient Haskell dialect.
01:54:51 <johnw> levi: link?
01:55:08 <levi> I don't have a link handy, sorry. Google should be able to find it.
01:55:15 <Cale> merijn: Oh, you mean the type synonyms, all this Effect/Producer/etc.
01:55:16 <johnw> looing...
01:55:33 <merijn> Yeah
01:56:04 <johnw> levi: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.9009&rep=rep1&type=pdf
01:56:06 <johnw> is that the one?
01:56:07 <merijn> If you do need to use Proxy I agree it's a bit messy, but the majority of the cases I've used Effect/Producer/Consumer/Pipe are sufficient
01:56:20 <Cale> merijn: I think that might actually be worse, because it's hard to tell how types match in the presence of them.
01:56:22 <merijn> (or their polymorphic equivalents Effect'/Producer'/etc)
01:56:48 <aloiscochard> hi guys, I'm wondering why in the haskell base lib, same method name are not used between `List` and `NonEmpty`, why having `neHead` vs `head`? would that create some ambiguity? how so?
01:57:18 <aloiscochard> is that to help inference? (by having the function defined only on a given type)
01:57:25 <aloiscochard> s/same method/same function/
01:57:39 <levi> johnw: That looks like it.
01:57:40 <Cale> aloiscochard: Any given function can only have one type.
01:57:50 <DireWombat> well, thanks for the answers and discussion guys
01:58:02 <DireWombat> I think I'll put deterministic IO on the backburner for now
01:58:27 <aloiscochard> Cale: but I can have a function named `map` in my `Foo` module? so is it a way to avoid having to do `List.map` or `NonEmpty.map`?
01:58:29 <DireWombat> and learn Lens in the meantime
01:58:41 <tero-> eh, "Dynamic linking required, but this is a non-standard build (eg. prof). You need to build the program twice..."
01:58:47 <Cale> aloiscochard: Of course, you can put functions in different modules, and the function can have a polymorphic type...
01:59:03 * hackagebot nondeterminism 1.0 - A monad and monad transformer for nondeterministic computations.  http://hackage.haskell.org/package/nondeterminism-1.0 (AndreiBarbu)
01:59:05 * hackagebot csp 1.0 - Discrete constraint satisfaction problem (CSP) solvers.  http://hackage.haskell.org/package/csp-1.0 (AndreiBarbu)
01:59:05 <Cale> aloiscochard: Yeah, probably.
01:59:45 <Cale> aloiscochard: I'm from the old days, and I still kind of prefer the time when people were more careful about not creating name conflicts between modules.
01:59:49 <levi> There are tons of common modules that have names that conflict with Prelude names.
02:00:06 <Cale> It used to be that you could just import a bunch of stuff unqualified and not have any problems :P
02:00:25 <Cale> Data.Map and Data.Set kind of changed that :)
02:00:42 <aloiscochard> Cale: so, what's the reasoning behing the choose of the name `neMap`, in other words...  as a good practice, should I prefix my function with my module arconym if they clash with Prelude?
02:00:52 <Cale> Before those, there was FiniteMap, which had names like mapFM, insertFM, etc.
02:01:06 <Cale> aloiscochard: It's a matter of taste
02:01:27 <Cale> aloiscochard: The module system is there, and you can certainly use it to disambiguate.
02:02:01 <aloiscochard> Cale: I see, I'll probably go that way, thanks for the answers :-)
02:02:05 <Cale> Of course, in the case of map specifically, you should probably just write an instance of Functor
02:02:14 <aloiscochard> oh yeah, indeed
02:02:25 <pxqr> when I try to run ghci I get 'ByteCodeLink: can't find label... blah-blah' which says that it can't find object files for c sources listed in cabal 'C-sources' field.
02:02:32 <merijn> levi: But thank god the proposal to put Traversable and Foldable in Prelude has been accepted, so that should remove the need for a lot of them!
02:02:44 <aloiscochard> mmm... I see, usually for this kind of very generic method, you create an instance of a type class
02:02:46 <pxqr> 'cabal-dev ghci -Ldist/build/cbits/mylib.o' doesn't help
02:02:56 <tero-> okay, I give up, vagrant upping now
02:03:17 <levi> merijn: I hadn't heard about that one. Nice!
02:03:31 <Cale> hmm
02:03:45 <Cale> I'm not certain how happy I am about that.
02:04:01 <Cale> Traversable is fine
02:04:15 <Cale> I'm not 100% convinced about Foldable
02:04:21 <merijn> Why's that?
02:05:24 <levi> aloiscochard: A lot of the algebraic type classes have very useful functionality that you can take advantage of as long as you can write conforming instances.
02:06:00 <Cale> Well, it's a little hard to articulate. I guess it might be a good thing overall. Foldable is complicated enough to not be obviously the right thing always all the time.
02:06:20 <Cale> But worse things have made it into the Prelude
02:07:03 <Cale> I guess this means we also get Monoid in the Prelude?
02:07:19 <Cale> That would probably be a good thing.
02:08:00 <benj_> morning, aloiscochard :)
02:12:22 * benj_ is going to get a working EclipseFP on Ubuntu. One day...
02:20:34 <aloiscochard> benj_: oh! I'm uncovered!
02:20:37 <aloiscochard> benj_: hi mate :-)
02:20:54 <aloiscochard> benj_: started learning haskell one week ago, I don't know how I could have wait so long!
02:21:10 <aloiscochard> levi: I see, I like that approach
02:22:19 <levi> Hey, I found the paper that introduced 'constructor classes' in gofer and the Functor class. It was another modular interpreter paper, a bit later than Steele's.
02:25:22 <levi> Heh, they hadn't come up with newtype yet.
02:27:24 <levi> "Monad Transformers and Modular Interpreters" by Liang, Hudak, and Jones is the paper I'm referring to.
02:29:04 <benj_> aloiscochard, I have been trying to find time to learn for months, I only recently got enough traction to actually start writing useful code
02:30:01 <benj_> aloiscochard, one day we will finally bump into each other at London Haskell. One day... ;)
02:31:09 <aloiscochard> benj_: same for me, I was starting a new project in scala... wrote a data-structure, and then I thought "What about porting it to haskell, just to see" ... and now I want to do the whole project in haskell ;-)
02:31:21 <aloiscochard> benj_: I'm sure we will! when the universe will be ready for that!
02:32:02 <aloiscochard> benj_: next time I'll go there I'll have time for the pub session ;-)
02:33:52 <benj_> I am confused by a "reinstalls are always dangerous" warning when building something with cabal-dev. I thought it was supposed to be sandboxed - how is a clean sandboxed install involving reinstalls?
02:34:31 <johnw> it was an empty environment?
02:35:08 <benj_> empty in that I'd previously rm -rf'd the cabal-dev directory for that project
02:35:36 <Taneb> byorgey, may I make a feature request for monoid-extras?
02:36:25 <benj_> oh, I think I see what is going on. My dependencies depend on different versions of syb
02:37:40 <Taneb> (actually, I want this in base, but it makes sense in monoid-extras)
02:38:14 <quchen> Taneb: You may also make a feature request for Base.
02:38:20 <Taneb> newtype Endo' k a = Endo' {appEndo' :: k a a}; instance Category k => Monoid (Endo' k a)
02:39:07 <Taneb> (modulo names)
02:40:22 <benj_> is there a way to find out which of the dependencies of a cabal package depend on a particular package? (in this case haskell-src-meta)
02:43:46 <Saizan> benj_: i don't think there's a cabal command for that, but there might be some hackage package to display dependency graphs of installed packages
02:45:50 <benj_> Saizan, I see, thanks
02:49:33 <aloiscochard> benj_: I must admit I'm a bit disappointed with cabal, looks like no language have a good build system :-(
02:51:22 <johnw> build systems are generally great at what their author designed them for
02:56:28 <levi> aloiscochard: What were you expecting from cabal that it's let you down about?
02:56:52 <aloiscochard> johnw: hehe :-) indeed
02:57:18 <aloiscochard> levi: I was quite surprised about the sandboxing thing, but it's probably related to the fact that I'm not used compiling to native
02:57:28 <aloiscochard> levi: then the cabal-dev vs hsenv thing
02:57:49 <aloiscochard> levi: the fact that I have to do "cabal install cabal-install" ... was a WTF moment
02:58:22 <aloiscochard> on the other hand, I'm quite impressed by VI integration :-)
02:58:23 <johnw> you could cabal-dev install cabal-dev, for another one :)
02:58:33 <aloiscochard> johnw: no please! stop that :-D
02:58:36 <benj_> aloiscochard, in fairness this is no less WTF than SBT's bootstrap process
02:58:43 <aloiscochard> benj_: agreed
02:59:17 <donri> VI integration?
02:59:23 <levi> aloiscochard: What are you comparing cabal to? Anything in particular?
02:59:43 <aloiscochard> donri: I mean hdevtools is quite cool
02:59:52 <aloiscochard> donri: and work correctly with cabal-dev
02:59:54 <donri> yep
03:00:12 <aloiscochard> levi: not really, most buid tool I used in the past were JVM based
03:00:14 <MercurialAlchemi> cabal could certainly use some improvements
03:00:18 <aloiscochard> levi: they where crap as well :-)
03:00:29 <MercurialAlchemi> like being able to recompile in profile mode without insulting you
03:00:44 <aloiscochard> levi: I don't think cabal is specially worst than other build tool... it's just that build tool sucks
03:00:48 <aloiscochard> in general
03:01:15 <Ralith> aloiscochard: cabal sucks because its installation procedure involves a funny command?
03:01:36 <MercurialAlchemi> aloiscochard: the .cabal format sucks compared to many build tools, for one
03:01:45 <aloiscochard> MercurialAlchemi: yeah that as well
03:01:46 <merijn> How's that?
03:01:53 <merijn> I kinda like the .cabal format
03:02:06 <aloiscochard> Ralith: you might have missed some of my arguments
03:02:32 <aloiscochard> anyway I'm not blaming it... I'm just complaining out loud about the general bad state of build tool in this universe ;-)
03:02:33 <johnw> .cabal beats most formats I interact with
03:02:40 <merijn> johnw: Word.
03:02:56 <merijn> As far as build tools go, cabal is by far the most pleasant and reliable tool I've used
03:03:09 <aloiscochard> I can't say yet about the format honestly, I haven't used it enough in depth
03:03:11 <Ralith> aloiscochard: perhaps you'd elaborate on them?
03:03:12 <aloiscochard> it look simple at least
03:03:17 <levi> aloiscochard: If you think the Java and Cabal situation is bad, you have led a very sheltered life with respect to build tools.
03:03:17 <johnw> I find it pleasant 95% of the time, and then those 5% are incredibly unpleasant
03:03:35 <MercurialAlchemi> merijn: well, let's put that way, once you have a library, an executable and tests in your .cabal, you've put the same dependencies three times
03:03:36 <aloiscochard> levi: yeah I know ;-) I did some make/ant at some point...
03:03:39 <levi> GNU autotools
03:03:47 <johnw> MercurialAlchemi: there's a way around that
03:03:48 <merijn> johnw: Unlike autohell, which is "not painful" 5% of the time and incredibly painful for 95% :)
03:03:52 <johnw> I've just forgotten how to do it
03:03:59 <aloiscochard> Ralith: isn't what I did since last 10min or so? :-)
03:04:00 <johnw> yeah, autohell can truly be a nightmare
03:04:04 <johnw> cmake is pretty good, but arcane
03:04:16 <benj_> levi, we hold the haskell ecosystem to higher standards than, say, the javascript one, which we expect to be terrible
03:04:26 <MercurialAlchemi> it could be make a lot better by switching to something like YAML
03:04:27 <aloiscochard> any scons? ;-)
03:04:29 <merijn> MercurialAlchemi: Really, as far as build tools go, that one doesn't even rate as "discomfort" for me
03:04:32 <MercurialAlchemi> since you can repeat sections
03:04:35 <Ralith> aloiscochard: I must have missed it.
03:05:06 <Ralith> johnw: does cmake have documentation yet?
03:05:17 <johnw> Ralith: man cmake is pretty comprehensive
03:05:19 <aloiscochard> Ralith: no worries, anyway I need to spend more time with cabal to have a real definitive opinion, I'm just scratching the surface atm I suppose
03:05:21 <johnw> and then there's the cmake book
03:05:26 <MercurialAlchemi> merijn: it makes me groan every time I have to update it
03:05:29 <Ralith> oh, there's a book
03:05:31 <Ralith> that explains some
03:05:39 <johnw> I never had to struggle with cmake, and I've used it a fair bit
03:05:51 <Ralith> ...huh
03:05:55 <donri> MercurialAlchemi: you should make your exe and tests depend on your library and only write the exe/test specific dependencies in those sections
03:06:02 <Ralith> it never occurred to me to look in the manpage for a detailed language spec.
03:06:09 <donri> MercurialAlchemi: if you don't do this you're recompiling your source tree three times
03:06:12 <MercurialAlchemi> donri: hm, sure, how do you do that?
03:06:14 <Ralith> man, that's huge
03:06:27 <merijn> MercurialAlchemi: Just put the package as dependency for the executable in your package
03:06:27 <donri> MercurialAlchemi: build-depends: name-of-this-project
03:06:28 <Ralith> almost a MB
03:10:00 <donri> MercurialAlchemi: also i don't think you need to repeat bounds, since it will take the library bounds into account anyway
03:10:15 <MercurialAlchemi> I could swear that I tried that at some point and it didn't work
03:10:19 <MercurialAlchemi> brilliant
03:10:42 <donri> it doesn't work if your lib and exe/test has the same hs-source-dirs which by default is the same (the project root)
03:11:04 <donri> it's good practice to put lib sources under src/
03:11:58 <MercurialAlchemi> donri: I have done that...
03:12:10 <MercurialAlchemi> donri: but the Main.hs should be in the root directory?
03:12:24 <donri> MercurialAlchemi: i usually put it under bin/ named like the exe
03:14:30 <donri> MercurialAlchemi: (but ./Main.hs should be fine)
03:14:38 <merijn> MercurialAlchemi: I actually have a project like this root directory with a "client" for client sources, "server" for server sources and "shared" for sources of the library that's shared between both
03:14:55 <donri> MercurialAlchemi: obviously you need to export-modules anything in the library that the exe/tests needs
03:14:57 <merijn> MercurialAlchemi: Then I just have the client and server executables depend on the library in the same package
03:15:18 <donri> merijn: fay? :)
03:16:03 <merijn> donri: No, just client and server code?
03:16:08 <donri> okies
03:16:22 <merijn> I refuse to indulge this web nonsense!
03:16:35 <johnw> merijn: gets his news through gopher
03:16:51 <MercurialAlchemi> merijn: it sort of works, but you still need to specify base and other stuff you import from the exe
03:16:52 <merijn> No, through IRC :p
03:17:01 <MercurialAlchemi> er, import in the exe
03:17:20 <donri> MercurialAlchemi: obviously
03:17:55 <merijn> MercurialAlchemi: Sure, but ideally if all (or most) your functionality is in the library (which you'd want anyway) the exe just needs to import UI related dependencies which should change independently from the library
03:18:59 <MercurialAlchemi> right
03:19:04 <donri> you know it's perfectly possible to have an exe that is independent of the library
03:19:22 <MercurialAlchemi> ok, thanks for the tip, this will certainly simplify maintenance
03:20:10 <MercurialAlchemi> donri: yes, but it would make sense to say "depending on library X means acquiring all of X's dependencies"
03:21:03 <MercurialAlchemi> donri: with the option of overriding a given dependency if you do something funky and need a different lower bound for instance
03:46:50 <donri> MercurialAlchemi: that's already the case transitively but you need to specify which packages to "expose" for imports
03:48:11 <donri> MercurialAlchemi: the exe might need to import module X from package Y but it's also in transient dependency Z
03:48:28 <donri> probably not a common problem though, and indicative of bad code arguably
03:48:30 <donri> shrug
03:58:43 <benj_> ghc-pkg check gives me a tonne of problems. It seems every package I have installed has a bunch of files missing. What can I do to try to fix this?
04:00:06 <m3ga> benj_: what OS? are you mixing eg linux package management and cabal install?
04:03:02 <benj_> m3ga, I installed haskell-platform from the ubuntu repository, then ran cabal install cabal-install
04:04:33 <m3ga> benj_: probably a bad idea to mix packages and cabal installed stuff. i'm on debian and i install ghc, alex, happy and cabal-install from packages. everything else is cabal installed.
04:05:03 <benj_> so are you saying it's a bad idea to install haskell-platform?
04:07:02 <benj_> these errors are all related to my user ~/.cabal, anyway - I don't use that, I either install things globally, or use cabal-dev when building things
04:14:27 <aloiscochard> benj_: for what is worth, I didn't took the haskell-platform path, and just installed ghc/cabal
04:15:25 <merijn> benj_: It depends on your platform, some linux distros really break the platform by splitting it up again
04:16:57 <benj_> I just deleted everything in .cabal and .ghc to shut it up :/
04:18:36 <linduxed> benj_: aaah, the good old "nuke it all and start over"-method
04:18:44 <linduxed> benj_: has worked for me many a time
04:19:05 <benj_> yes, except I've done this about 5 times in the last 2 days :(
04:20:17 <benj_> I just want to install the tools for EclipseFP (buildwrapper etc), and I'm struggling to do that without ending up with something broken
04:21:34 <Work_jack> Hm... I like Elm's syntax for "as" matching:
04:21:34 <Work_jack>     step input (World mario goombas bricks as world) = ...
04:21:34 <Work_jack> rather than:
04:21:34 <Work_jack>     step input world@(World mario goombas bricks) = ...
04:27:44 <linduxed> Work_jack: i'm not entirely convinced either way
04:27:48 <simukis_> What could cause `runProcess … >>= waitForProcess` throw “waitForProcess: does not exist (No child processes)”?
04:29:34 <Work_jack> linduxed: As-patterns tend to Haskell code a bit golfy, especially when nested
04:29:49 <Work_jack> so while it's a minor change I think it definitely looks neater
04:30:25 <linduxed> yeah, maybe
04:30:40 <linduxed> i think i'd need to see a decent amount of code to make up my mind
04:30:40 <Work_jack> *tend to make
04:31:10 <Work_jack> Fair enough, it looks even nicer with records imo:
04:31:11 <Work_jack>     move time ({x,y,vx,vy} as object) = ...
04:31:14 * linduxed has been hopping between languages lately so he's got his preferences messed up
04:33:19 <aloiscochard> what would you guys recommend for streaming things, I've seen Iteratee and Machines, what's are the tradeoff?
04:36:12 <quicksilver> Work_jack: does haskell support nested as-patterns anyway?
04:36:50 <quicksilver> > let xs@(x:(xxs@xx:xxxs)) = [1,2,3,4] in (x,xs,xxs,xx,xxxs)
04:36:51 <lambdabot>   (1,[1,2,3,4],2,2,[3,4])
04:36:56 <quicksilver> apparently so.
04:37:06 <quicksilver> I've certainly never used one, though, are you sure it's a good idea? :)
04:37:35 <quicksilver> > let xs@(x:(xxs@(xx:xxxs))) = [1,2,3,4] in (x,xs,xxs,xx,xxxs)
04:37:36 <lambdabot>   (1,[1,2,3,4],[2,3,4],2,[3,4])
04:37:46 <quicksilver> that's actually what I was aiming for. not that it matters.
04:37:52 <Work_jack> They're useful for writing compilers I've found, or anything dealing with AST's
04:38:18 <mauke> > let a@b@c = 2 in a+b+c
04:38:20 <lambdabot>   6
04:38:23 <Work_jack> heh
04:39:14 <quicksilver> Work_jack: well, you can always leave the node entire and deconstruct it later
04:39:29 <quicksilver> I suppose I'd need to see examples to be convinced that nested 'as' is the clearest one
04:39:32 <Work_jack> Sure and I often did do that
04:39:55 <Work_jack> I can't remember the exact bases but there are times when it makes sense: especially with ViewPatterns
04:40:11 <t7> >let a@(b, c)@d = (1, 2) in [a, b, c, d]
04:40:24 <Work_jack> eval e@(eval → e'@(Just (IfThenElse ...))) = ...
04:40:26 <t7> > let a@(b, c)@d = (1, 2) in (a, b, c, d)
04:40:27 <lambdabot>   <hint>:1:13: parse error on input `@'
04:40:35 <t7> interdasting
04:40:47 <Work_jack> Fairly contrived example but it does have its uses
04:41:19 <mauke> > let a@d@(b, c) = (1, 2) in (a, b, c, d)
04:41:21 <lambdabot>   ((1,2),1,2,(1,2))
04:42:12 <Work_jack>     eval e@(eval → e'@(Just (IfThenElse ...))) = ...
04:42:12 <Work_jack> vs.
04:42:12 <Work_jack>     eval (eval → (Just (IfThenElse ...) as e') as e) = ...
04:42:30 <Work_jack> But I tend to avoid as-patterns anyway
04:46:49 <simukis_> What could cause `runProcess … >>= waitForProcess` throw “waitForProcess: does not exist (No child processes)”?
05:04:35 <merijn> simukis_: Process has exited so fast that the pid is dead before waitForProcess gets called
05:05:20 <quchen> async (ioAction) >>= wait    <-- Async doesn't do that.
05:06:12 <quchen> That is to say you should maybe fork the process handler using an Async, and then using that one to wait for results.
05:09:07 * hackagebot creatur 3.0.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-3.0.0 (AmyDeBuitleir)
05:09:46 <fjeeer> http://www.fjeer.me FREE SMS Worldwide!
05:09:47 * fjeeer http://www.fjeer.me
05:09:49 <fjeeer> http://fjeer.me
05:10:06 * benj_ resolves to stay away from preprocessors in his projects for now
05:13:22 <Zenol> @pl (\s -> s=="a" || s=="b")
05:13:25 <lambdabot> ap ((||) . ("a" ==)) (== "b")
05:13:25 <lambdabot> optimization suspended, use @pl-resume to continue.
05:14:39 <quchen> :t \s -> (||) `on` (s ==) -- Zenol
05:14:40 <lambdabot> Eq a => a -> a -> a -> Bool
05:14:58 <quchen> Wait, that's not very pointfree.
05:15:29 <merijn> quchen: It's also wrong :)
05:15:39 <merijn> quchen: Yours has different semantics
05:16:18 <quchen> Anyway, what you should use in cases like these is `any (== s) ["a", "b"]`, or `elem s ["a", "b"]`
05:16:25 <quchen> merijn: It does?
05:16:43 <Zenol> oh yes, `elem`... thanks.
05:17:34 <merijn> quchen: Yes, unless you add more parameters
05:17:46 <quchen> ..?
05:17:52 <quchen> You mean the "a" and "b" were missing?
05:17:57 <quchen> Or something less pedantic :s
05:18:00 <merijn> quchen: yours would be "foo s c1 c2"
05:18:15 <merijn> eh
05:18:25 <merijn> "foo s "a" "b"" to make it more concrete
05:19:09 <merijn> So yours can't be turned into Zenol's function without changing it to "\a b s -> (||) `on` (s ==) $ a b"
05:19:16 <merijn> Which kinda defeats the point :)
05:20:40 <quchen> Okaaaay.
05:22:22 <quchen> :t liftA2 (||) (== "a") (== "b") -- For you, merijn ♥
05:22:23 <lambdabot> [Char] -> Bool
05:31:09 <simukis_> merijn: I don't think that could be possible… what I'm trying to launch is ghc with -fforce-recomp.
05:32:55 <merijn> simukis_: It could be if ghc is exiting with an error :)
05:34:08 * hackagebot grid 7.3 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.3 (AmyDeBuitleir)
05:39:08 * hackagebot som 6.4 - Self-Organising Maps  http://hackage.haskell.org/package/som-6.4 (AmyDeBuitleir)
05:40:39 <simukis_> merijn: but ghc works fine (output of the program properly shows compilation of modules, linking and then the aforementioned error)… well I've already hacked myself another solution… but I'm still interested why such situation could happen at all…
05:51:11 <tero-> hmm.. when I'm profiling the memory usage, it does not leak memory anymore
05:52:23 <tero-> Cale: https://www.dropbox.com/s/2p9tdxf71uyd2j0/archive-events.pdf
05:55:30 <byorgey> @tell Taneb of course! The easiest way is to file a feature request at https://github.com/diagrams/monoid-extras/issues
05:55:30 <lambdabot> Consider it noted.
05:59:22 <tero-> let's try if good old rm -rf .cabal .ghc helps
06:23:46 <sclv> @remember psygnisfive Seminearring is the task of giving seminars.
06:23:46 <lambdabot> Done.
06:25:01 <datatim> hi, i want to create a data structure: i have a MxN dim complex matrix but i want to extend it periodically. so i only want to store the MxN matrix but if i take an element m,n>M,N it should give the correct element according to the periodic extension
06:25:09 <datatim> can somebody give me a hint how to do that?
06:26:14 <b2coutts> datatim: you could define a lookup function for your matrix that first checks if the given indices are beyond your matrix
06:26:34 <b2coutts> and if they are, reduce them modulo M or N before looking them up in the data structure
06:29:13 <datatim> b2coutts: thx, that was my first thought, too. my code would look cleaner if i could put it into the data structre so i havent to write the special lookup everywhere
06:30:14 <merijn> datatim: No, he's suggesting wrapping the lookup function with your own function and then only using the wrapped one
06:30:21 <b2coutts> ^
06:31:06 <b2coutts> for example, if you're putting this data structure in Matrix.hs, instead of just exporting the data declaration, you would also export lookup :: Int -> Int -> Value
06:31:08 <tero-> Cale: the memory leak is gone without doing anything. maybe it just wanted some attention..
06:31:35 <b2coutts> and then use Matrix.lookup to find the value of a particular entry in the matrix
06:31:49 <datatim> ah i see
06:32:19 <datatim> thank you :)
06:32:28 <datatim> this was an easy one... :) im still learning
06:37:34 <merijn> Is there like an "unwordsWith :: String -> [String] -> String"? I guess maybe intersperse?
06:37:48 <merijn> > intersperse 1 [2..10]
06:37:50 <lambdabot>   [2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10]
06:37:59 <merijn> oh, exactly right :)
06:38:58 <mauke> intercalate
06:39:32 <timinlondon> hi all! Anyone can help me with the syntax?
06:39:44 <merijn> :t intercalate
06:39:45 <lambdabot> [a] -> [[a]] -> [a]
06:39:52 <timinlondon> I want to get out the value of x before the word bang or boom
06:40:09 <timinlondon> [if x < 10 then x "boom" else "bang" | x<-[1..20], odd x]
06:40:18 <merijn> mauke: Yeah, but I'd be fine just using "unwords . intersperse s"
06:40:49 <merijn> timinlondon: What does "before" mean? You mean prefixed to the string?
06:40:51 <tikhon> timinlondon: are you trying to print x?
06:40:52 <Work_jack> timinlondon: Why are you applying x to "boom" (x "boom")
06:40:53 <timinlondon> I thought I might be able to do something like [if x < 10 then [(x), ("boom")] else "bang" | x<-[1..20], odd x]
06:41:00 <quchen> > [show x ++ if x < 10 then "boom" else "bang" | x<-[1..20], odd x] -- timinlondon
06:41:01 <lambdabot>   ["1boom","3boom","5boom","7boom","9boom","11bang","13bang","15bang","17bang...
06:41:11 <timinlondon> yeah
06:41:26 <merijn> timinlondon: no, because [x, "boom"] is [(Int, String)], "boom" is String
06:41:49 <merijn> timinlondon: All arguments in the list must be the same type
06:41:57 <timinlondon> ah i see thought i could make a tuple or something
06:42:09 <Work_jack> timinlondon: You may want to try to do what you want to do one element at a time or by constructing your lists by hand before using list comprehensions
06:42:11 <merijn> timinlondon: You can, but only if the entire list is tuples
06:43:02 <merijn> > [ if x< 10 then (x, "boom") else (-1, "bang") | x <- [1..20], odd x]
06:43:03 <lambdabot>   [(1,"boom"),(3,"boom"),(5,"boom"),(7,"boom"),(9,"boom"),(-1,"bang"),(-1,"ba...
06:43:34 <geekosaur> [(Maybe Int,String)]?
06:43:50 <Work_jack> geekosaur: That's probably overkill
06:43:59 <merijn> timinlondon: You can put whatever you like in lists, as long as elements are the same type, which means that "if b then x else y" x and y must be the same type here
06:44:18 <merijn> timinlondon: In fact, the then and else clause if an if/then/else expressions must *always* be the same type
06:44:19 <timinlondon> thanks for all this info
06:44:27 <Work_jack> You're welcome timinlondon
06:44:37 <timinlondon> lots of stuff for me to play around with now
06:45:02 <timinlondon> cya guys and thanks
06:54:00 <dmwit> At http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html#v:need, the links to "cmd" and "command" point to the anchors "t:cmd" and "t:command" instead of "v:cmd" and "v:command".
06:54:05 <dmwit> Who should I complain to?
07:06:57 <aloiscochard> dmwit: you should probably do a PR on the original repo: http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/src/Development-Shake-File.html#need
07:08:14 <dmwit> PR?
07:08:24 <quchen> Pull request?
07:08:34 <aloiscochard> dmwit: https://github.com/ndmitchell/shake
07:08:41 <dmwit> The source looks correct to me. It's the generated documentation that's incorrect.
07:08:53 <dmwit> I just want to know whether I should complain to the haddock folks or the Hackage folks.
07:10:21 <bscarlet> dmwit: does it generate the incorrect doc if you build the docs yourself?
07:10:31 <dmwit> Good question. I'll give it a shot.
07:11:05 <dmwit> No, it's incorrect.
07:11:13 <dmwit> So haddock folks, then.
07:11:23 <bscarlet> do you know where the incorrect part is coming from?
07:11:29 <dmwit> don't
07:12:12 <dmwit> Let's try the newest haddock first, though.
07:12:13 <bscarlet> I guess I mean: what does the t: or v: mean or where does it come from?
07:12:36 <dmwit> t: means type-level, v: means value-level
07:12:54 <dmwit> (to disambiguate between constructors)
07:13:07 <dmwit> (...and just general headings)
07:13:26 <bscarlet> That certainly sounds like it might need a newer haddock.
07:14:07 <quchen> Speaking of Haddock: How do I get the link to something out of the docs? My current approach is crunching the source and looking for the corresponding anchor …
07:14:46 <dmwit> quchen: For values and types, I just told you how. =)
07:15:09 <dmwit> modulo making operator names safe for URLs
07:15:10 <quchen> dmwit: True, but that requires thinking ;-)
07:15:27 <bscarlet> quchen: How do I get the link so (something out of the docs)? or How do I get (the link to something) out of the docs?
07:15:29 <quchen> Headlines have the "table of contents" in the top-right corner
07:16:04 <dmwit> quchen: You could visit the index linked at the top-right corner of every page.
07:16:43 <dmwit> Okay, it's broken with the newest haddock, too.
07:16:45 <dmwit> I think.
07:16:58 <dmwit> If I "cabal install haddock", is that enough for cabal to use the new haddock when building new documentation?
07:17:41 <joneshf-laptop> ooohh, just what i was trying to do
07:17:52 * joneshf-laptop reads the backlogs
07:19:29 <dmwit> Seems it's a known bug after all: http://trac.haskell.org/haddock/ticket/228
07:22:51 <aloiscochard> dmwit: oh sorry. I didn't understood it's a haddock bug :-s
07:36:25 <bartavelle> anybody knows how to get a more explicit error message for ghcmod ? (I get ghcmod#command#type: Cannot guess type)
07:48:54 <bartavelle> nvm
07:56:08 <chrisdone> has anyone got the ghc ticket for adding a warning for incomplete lazy patterns?
07:56:54 <chrisdone> hpc: no
08:04:21 * hackagebot lens-time 0.1.0.0 - lens for Data.Time  http://hackage.haskell.org/package/lens-time-0.1.0.0 (TatsuyaTouma)
08:06:30 <Zenol> What's different beetween EintherT and ErrorT ?
08:07:20 <merijn> Zenol: The libraries@ mailing list has been having an elaborate argument about that this month :)
08:07:22 <ion> zenol: “EitherT is a version of ErrorT that does not require a spurious Error instance for the Left case.” http://hackage.haskell.org/packages/archive/either/3.4.1/doc/html/Control-Monad-Trans-Either.html
08:09:01 <danr> dan burton: ping ping?
08:09:11 <danr> I cannot remember his handle
08:11:36 <bscarlet> Zenol: it looks to me like fail in EitherT hands the failure down the transformer stack, while ErrorT has the additional constraints on the left type to allow it go the other way, handling "fail"ures with the left case of the Either.
08:19:19 <flo1> I saw happy has a build in lexer. But many people recommend to use alex with happy. What is the difference between the build in happy lexer and alex?
08:21:17 <edwardk> flo1: dunno, but i figure the same guy wrote both and advocates for using the one in alex ;)
08:22:18 <Franciman> hey anybody familiar with haskell language specification?
08:23:23 <Hafydd> Honestly, I recommend using a lexer/parser that isn't a clone of a tool written for C.
08:23:59 <flo1> Hafydd: me to, but that isn't the question ;-)
08:24:06 <Work_jack> It absolutely depends on what you're planning on parsing
08:24:24 <Saizan> Franciman: better to just ask the question
08:24:30 <Franciman> ok :P
08:24:40 <Franciman> I am a bit confused about qvar and company
08:25:05 <Franciman> in the lexical specification for example qvarid is defined as: [ modid . ] varid
08:25:17 <apfelbox> Hi, I have a problem with creating a GHC plugin
08:25:19 <Franciman> so this implies that the modid. is not mandatory
08:25:24 <Franciman> right?
08:25:27 <flo1> Work_jack: why? it is both a lexer so there shouldn't be that big difference between using happy lexer + happy parser and alex + happy parser
08:25:28 <Saizan> yeah
08:25:59 <Franciman> but later in the syntax specification both varid and qvarid appear. Should I consider qvarid when modid. is present and varid otherwise?
08:26:00 <Franciman> or what?
08:26:04 <Zenol> "For instance an apomorphism is the generalized anamorphism for this Monad" apocowhatphism? x)
08:26:20 <Work_jack> flo1: Sorry, I must've misread the question
08:26:31 <Saizan> Franciman: qvarid allows for the modid part to be there, varid doesn't
08:27:07 <Franciman> Zenol it's the categorical dual of paramorphism
08:27:07 <Franciman> according to wikipedia :P
08:27:49 <Zenol> Franciman, Ok, I put it just after "read a book on categorical theory". :)
08:27:53 <Saizan> Franciman: so when you see varid you're sure the modid isn't there, when you see qvarid it might or might not be
08:28:12 <Franciman> and when they're both in the same production as alternative?
08:28:15 <Saizan> Zenol: it's actually a notion most category theorists wouldn't know about
08:28:42 <Saizan> i guess varid doesn't matter there? dunno
08:29:22 * hackagebot scat 1.0.1.0 - Generates unique passwords for various websites from a single password.  http://hackage.haskell.org/package/scat-1.0.1.0 (RomainEdelmann)
08:29:24 <Saizan> Zenol: an apomorphism is an unfold that allows you to give the whole tail at once if you want
08:29:37 <Saizan> Zenol: anamorphism is the plain unfold instead
08:30:10 <Franciman> ok, thanks for the help
08:32:13 <Saizan> Zenol: but they are generalized unfolds, so basically given newtype Fix f = Fix (f (Fix f)), you have apomorphism :: Functor f => (a -> Either (Fix f) (f a)) -> a -> Fix f
08:32:15 <Franciman> Saizan apparently my mistake. There is no such a case so fare
08:32:34 <Franciman> *far
08:33:28 <fibred-dolio> Is the either on the outside or inside?
08:34:12 <Saizan> i was unsure, but figured it doesn't matter much
08:34:31 <Saizan> though i guess for a general f it does
08:35:14 <Saizan> it's inside
08:35:28 <n-dolio> Okay.
08:35:33 <Saizan> (a -> f (Either (Fix f) a))
08:37:22 <Saizan> so that we can build Fix (Void ->) :)
08:38:30 <Zenol> Saizan:  Fix f = Fix (f (Fix f)) ?
08:39:15 <Saizan> Zenol: yeah, the fixed point of f
08:39:22 * hackagebot uniplate 1.6.11 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.11 (NeilMitchell)
08:39:40 <Saizan> Zenol: it's a way to talk about recursive types generically
08:40:04 <Saizan> you factor out the recursion into this "Fix" combinator
08:40:19 <apfelbox> should I ask questions regarding ghc plugins here or in #ghc ?
08:49:08 <apfelbox> How do I create a local cabal package, which I can use in another local project?
08:49:23 <apfelbox> I successfully cabal build-ed it. Where should I copy the files now?
08:49:32 <Clint> cabal install?
08:50:47 <apfelbox> (sorry, I am quite new, so have patience with me :D )
08:50:54 <apfelbox> I have 2 projects and want to build one and use it in the other.
08:51:54 <taylorgb> You can just run cabal install and it'll be installed into the package cache and you can refer to it in your other project
08:52:06 <bergmark> apfelbox: cabal install package1/ package2/
08:53:03 <apfelbox> Or is there no need to create a package when trying to get simple ghc plugin to work? Somehow I get a strange error ("module `DoNothing.Plugin' (./DoNothing/Plugin.hs) imports itself") and the only step I skipped was "Provided you compiled this plugin and registered it in a package"
08:55:26 <saml> > [27/77,12/86,30/159,27/203,54/224]
08:55:27 <lambdabot>   [0.35064935064935066,0.13953488372093023,0.18867924528301888,0.133004926108...
08:59:21 <apfelbox> Ok, this was actually the issue
08:59:49 <apfelbox> So.. for every update while developing the GHC plugin I have to do cabal configure && cabal build && cabal install ?
09:00:40 <byorgey> apfelbox: just cabal install, that will automatically do the configure and build steps
09:00:41 <apfelbox> ah, ok, thanks
09:00:41 <byorgey> apfelbox: also, I strongly recommend using an hsenv sandbox for this
09:00:42 <byorgey> @package hsenv
09:00:42 <lambdabot> http://hackage.haskell.org/package/hsenv
09:02:36 <joelteon> meh, i hate when people use base-unicode-symbols
09:09:23 * hackagebot SVGFonts 1.3.0.2 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.3.0.2 (BrentYorgey)
09:24:23 * hackagebot TV 0.5.0 - Tangible Values -- composable interfaces  http://hackage.haskell.org/package/TV-0.5.0 (ConalElliott)
09:26:50 <byorgey> oooh, a reboot of TV!
09:47:42 <danilo2> Hi! I know almost anybody uses UU-PARSINGLIB, but if there is anybody, which could help me I would be VERY thankful, because for over few hours I'm stuck in one place: http://stackoverflow.com/questions/18237578/correctly-parsing-line-indentations-in-uu-parsinglib-in-haskell
09:52:28 <resnik> #join angularjs
09:53:25 <Work_jack> Huh, is angularjs a monadic value?
09:53:42 <resnik> whoops brain fart
09:53:45 <Work_jack> @ty let { angularjs :: Monad m => m a; angularjs = undefined } in join angularjs
09:53:45 <lambdabot> Monad m => m a
09:54:19 <dmwit> That's a deceptive type signature!
09:54:28 <maurer> Work_jack: am I forgetting something? I thought join :: Monad m => m (m a) -> m a
09:54:35 <Work_jack> Yes so did I!
09:54:38 <dmwit> maurer: You're forgetting that a unifies with m a.
09:54:43 <dmwit> Hence my comment about deceptive. =)
09:54:59 <Work_jack> ah :)
09:55:10 <maurer> dmwit: why does a end up unifying with m a?
09:55:32 <dmwit> maurer: Do you understand this one?
09:55:46 <dmwit> ?ty let { angularjs :: a; angularjs = undefined } in join angularjs
09:55:46 <lambdabot> Monad m => m a
09:56:03 <maurer> Oh hurr
09:56:05 <Work_jack> Hm, is there a way to state that "a" is not monadic?
09:56:05 <maurer> nevermind, I see
09:56:10 <Work_jack> or is there no value in that
09:56:12 <dmwit> maurer: Yeah, sneaky, huh? =)
09:56:37 <maurer> In summary, we don't know that angularjs is joinable
09:56:55 <maurer> but given that it is, we unify a and m a
09:57:13 <dmwit> Well, it's more like we don't know that angularjs is not joinable, so it might as well be joinable.
09:57:42 <dmwit> What we know is that angularjs claims it can be a really lot of different things, and we get to choose which of those things it is.
09:57:46 <dmwit> So we choose one that's joinable.
09:58:04 <cschneid> how many people do web stuff with haskell? Seems like it could be a really cool backend business logic & json server behind something like angular.
09:58:20 <Maior> cschneid: exactly my plan
09:58:23 <zomg> cschneid: it is =)
09:58:29 <tikhon> there are a bunch of nice web frameworks
09:58:31 <Maior> cschneid: (looking at Happstack / Yesod for just that)
09:58:36 <dmwit> People do web stuff. Check out snap, yesod, happstack, etc.
09:58:42 <tikhon> you could also use something happy like Ur/Web instead of Angular :)
09:58:43 <cschneid> yeah, the big ones like happstack, the small ones like ... uhh... scotty
09:58:49 <Work_jack> cschneid: Webdevelopment isn't Haskell's forte but there are plenty of good libraries
09:59:10 <FreeFull> I wonder how long there is a Haskell SDL2 library
09:59:19 <dmwit> Work_jack: I can't think of a way to say that "a" is not monadic.
09:59:41 <Work_jack> dmwit: Except implementing it in a way that wouldn't unify?
09:59:43 <zomg> I'm sorta building a SaaS thing and doing the backend in Haskell. We'll see what comes out of it, whether I end up regretting not doing it in Rails where there's pretty much a library for everything already :p
09:59:47 <tikhon> dmwit: what about using those closed type families I keep hearing about?
10:00:00 <dmwit> tikhon: Yeah, I was thinking about those. But I still can't think of a way to do it.
10:00:07 <dmwit> Because I can't think of a way to negate a class constraint.
10:00:14 <tikhon> hmm
10:00:18 <cschneid> zomg: what kinds of functions are you missing?  common business logic stuff I'd assume? ("attach a picture", "log in", etc.?)
10:00:22 <zomg> On the other hand doing it in Haskell will let me sleep better since I know it won't perform like shit and there's at least some safety to what it does =)
10:00:24 <tikhon> I remember seeing a demo using essentially booleans at the type level
10:00:38 <dmwit> (I've been careful to say "I can't think of a way" rather than "it's not possible" this whole time, though. =)
10:00:41 <tikhon> I don't remember the exact syntax though
10:00:53 <dmwit> tikhon: Yes, I can think of a way to negate the ~ constraint. But not class constraints.
10:00:56 <Work_jack> tikhon: Was that embedding booleans or actually negating other constraints?
10:01:06 <zomg> cschneid: well it just seems a bit less established in general, so if I was to need something a bit less common it might not exist
10:01:08 <tikhon> just embedding booleans, I think
10:01:15 <zomg> cschneid: I haven't actually really ran into that - yet
10:01:53 <cschneid> zomg: I'm interested. Web dev is my field (rails is day-job), and I really like haskell's safety as I write code.  But I'm not sure about the ecosystem around it
10:02:07 <zomg> Yeah
10:02:13 <cschneid> zomg: so keep me updated :) It'd be cool to get a webdev cookbook of sorts: "so you want to make a json server, here's an easy way"
10:02:29 <dmwit> tikhon: The thing is that class constraints are open, and closed type families... aren't. =)
10:02:34 <Work_jack> Would there be much use for that anyway? Something like "can'tShow :: Not Show a => a -> ...?"
10:02:34 <tikhon> yeah
10:02:34 <zomg> Yeah there's a few articles if you google for "haskell web development"
10:02:44 <zomg> address some of the common tasks
10:02:58 <dmwit> Work_jack: Can't think of a use. You're the one that asked for it! =D
10:03:06 <Work_jack> I know, I know!
10:03:18 <Work_jack> But I never dismiss ideas just because they seem pointless
10:03:45 <Work_jack> http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables ← relevant?
10:04:04 <dmwit> Not relevant. I can tell you how to negate ~
10:04:22 <Work_jack> Hm
10:04:35 <dmwit> (Using new, as-yet-unreleased GHC features.)
10:04:59 <Work_jack> ...I just might be interested!
10:05:03 <Zenol> Is it ok if I feel better usig =<< instead of >>= ? :/
10:05:34 <ion> zenol: That’s what =<< is there for.
10:05:35 <Work_jack> Zenol: it doesn't matter much, I prefer =<< when binding to print
10:05:37 <tikhon> if anything, =<< is probably better just for consistency
10:06:11 <dmwit> Work_jack: Basically, type family IsNotInt a where instance IsNotInt Int = False; instance IsNotInt a = True
10:06:21 <Zenol> ok :)
10:06:33 <dmwit> Then to express (a /~ Int) you write (IsNotInt a ~ True).
10:07:04 <Work_jack> Wait, type families are of course released: could you explain what's new?
10:07:17 <dmwit> Work_jack: Those two instances overlap. =)
10:07:22 <Work_jack> Aah
10:07:25 <dmwit> (And the output of the overlapping cases don't match.)
10:08:44 <Work_jack> It's amazing watching Haskell approach dependent types while (almost) maintaining inference
10:09:00 <dmwit> It's pretty cool, yeah.
10:09:14 <dmwit> Someday GHC and Agda will meet in the middle, and on that day everybody wins. =)
10:09:43 <Work_jack> And it won't be used by the majority of programmers until 50 years later :)
10:10:23 <cschneid> is there a "live" editor for haskell, like LightTable?
10:10:51 <cschneid> I have vim doing live type checking, but would be cool to have a faster edit/run cycle against individual functions
10:11:05 <FreeFull> I tend to mostly work in ghci
10:11:12 <dmwit> poke Peaker, chrisdone (I think?), and look at that FP complete thing that's all in the cloud
10:11:15 <cschneid> FreeFull: what's your workflow look like?
10:11:27 <bergmark> and check out ghc-mod too
10:11:43 <FreeFull> Load file in ghci, edit, make changes, go back to ghci to test
10:11:45 <Work_jack> cschneid: True, one problem with such solutions is that it's coupled to a specific editor/environment
10:11:47 <cschneid> bergmark: yeah, that enables the vim integration. Tells me types & does a syntax/compile check each time I save
10:12:00 <bergmark> but i use ghci mostly
10:12:03 <bergmark> cabal-dev ghci
10:12:28 <cschneid> bergmark: and you continually redefine functions until you like them, then "freeze" them into your editor?  or is there something slicker?
10:12:30 <bergmark> a bit of a pain when you are developing in multiple packages though, need to look into making that nicer
10:12:33 <Work_jack> dmwit: There is one thing I haven't heard mentioned so I want to make sure I'm not mistaken, is it safe to call single-parameter type classes ‘predicates’ on types, multi-parameter classes ‘relations’ on types and functional dependencies/type families ‘functions’ on types?
10:12:52 <dmwit> Work_jack: I think that's a very fine set of analogies to use.
10:12:52 <bergmark> cschneid: i make changes in my editor and hit :r in ghci
10:13:00 <cschneid> ahh, then play with it
10:13:01 <cschneid> sure.
10:13:06 <FreeFull> I run my editor from ghci using :e
10:13:20 <dmwit> Work_jack: I myself use that terminology from time to time.
10:13:31 <dmwit> I think it may not actually be quite precise. Because the things are "too big" to be sets.
10:13:42 <dmwit> But it's a very good source of intuition.
10:13:52 <Work_jack> Sure
10:14:22 <Work_jack> Do you know if that was the plan from the start (e.g. with Wadler and type classes) or later or maybe not at all?
10:14:41 <dmwit> I don't.
10:14:50 <Work_jack> Because if that wasn't the intention then I guess it just shows how fundamental those concepts are
10:16:09 <FreeFull> I wonder if I should change my xmonad.hs to change volume directly rather than call amixer each time
10:17:01 <FreeFull> I don't know if that's possible though
10:19:12 <byorgey> FreeFull: why? is it slow?
10:20:08 <byorgey> otherwise, I don't see why it matters.
10:20:36 <drayevarg> i've always used xbindkeys to change the amixer volume
10:25:15 <danilo2> Does anybody know answer on this question? I would be very thankful for any hint :) http://stackoverflow.com/questions/18237578/correctly-parsing-line-indentations-in-uu-parsinglib-in-haskell
10:28:16 <dgpratt> I vaguely recall a discussion that came up here a while back about the conceptual differences between Monads and Applicatives
10:28:35 <dgpratt> I seem to recall that one of the primary differences was that in the case of Applicatives, the associated side-effect of each individual computation necessarily happens, not necessarily so in the Monad case (i.e. Monad computations might 'short-circuit')
10:28:44 <dgpratt> does that sound right?
10:31:22 <Work_jack> dgpratt: Well you can't change the structure of a computation with applicatives having it depend on the value of previous results etc.
10:40:20 <dgpratt> thanks for the response, Work_jack, I'm still pondering the implications of your statement and how it relates to my question
10:40:37 <dmwit> dgpratt: Yes, I think your formulation sounded right.
10:41:18 <dmwit> Work_jack's formulation is similar: "short-circuiting" means having differing amounts of computation depending on the values of previous results.
10:41:29 <Work_jack> Well if an action depends on the value of a previous action then it may “short-circuit”
10:41:43 <Work_jack> You can't implement an “applicative” if expression
10:41:52 <dmwit> (So Work_jack's formulation is a generalization of yours.)
10:41:59 <dgpratt> dmwit, makes sense, thanks
10:46:16 <FreeFull> byorgey: It is slow to spawn a process every time I want to change volume
10:47:58 <dmwit> FreeFull: http://hackage.haskell.org/package/alsa-mixer if you use ALSA; maybe http://hackage.haskell.org/package/pulse-simple if you use pulse? (haven't tried it before)
10:48:39 <dmwit> pulse-simple doesn't look appropriate
10:49:27 <dmwit> So if you use pulse and don't want to spawn a process, maybe it's time to write some bindings. =)
10:49:46 <dmwit> Alternately: fork a pacmd process and send messages to it from your other threads, maybe.
10:51:06 <Work_jack> Spawn a worker process that waits on a (data Cmd = Raise Double | Lower Double | ToggleMute) value with distributed-haskell, obviously
10:54:42 <dmwit> That said, I've been using a variant of http://dmwit.com/volume/ for a while and haven't noticed spawning a process being particularly slow.
11:04:31 <wolfnn> Hello, I've got a very simple problem that I'd be interested in solving in point free style
11:04:42 <wolfnn> I simply want to fold a list of strings adding slashes in between
11:04:49 <dmwit> :t intercalate
11:04:50 <lambdabot> [a] -> [[a]] -> [a]
11:05:03 <wolfnn> ideally, this would work: ...
11:05:06 <sipa> @src intercalate
11:05:06 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
11:05:08 <wolfnn> let me see
11:05:41 <sipa> @pl \xs xss -> concat (intersperse xs xss)
11:05:41 <lambdabot> (join .) . intersperse
11:06:19 <dmwit> The impulse to make intercalate's source point-free instead of just using intercalate strikes me as a bit odd.
11:06:33 <wolfnn> hmm I was thinking: foldl1 (++ "/" ++) ["a","b","c"]
11:06:35 <wolfnn> would work
11:06:52 <wolfnn> I'm trying to figure out your answers
11:07:10 <dmwit> Well, it would probably be okay except for the fact that Haskell doesn't quite do *that* much syntax sugar.
11:07:21 <dmwit> > foldl1 (\x y -> x ++ "/" ++ y) ["a", "b", "c"]
11:07:22 <wolfnn> yeah, I noticed :)
11:07:23 <lambdabot>   "a/b/c"
11:07:39 <dmwit> But it's a bit silly that it dies on empty lists, when there's a perfectly good answer to give there.
11:07:39 <wolfnn> dmwit: yeah, but that's more verbose than what I wanted
11:07:48 <dmwit> > intercalate "/" ["a", "b", "c"]
11:07:50 <lambdabot>   "a/b/c"
11:07:58 <wolfnn> ok, thanks
11:08:14 <dmwit> > foldr (\x y -> x ++ "/" ++ y) "" ["a", "b", "c"]
11:08:14 <lambdabot>   "a/b/c/"
11:08:19 <dmwit> hm =)
11:09:54 <S11001001> is (??? :: forall f m. (Foldable f, Monoid m) => m -> f m -> m) "/" ["a", "b", "c"] = "a/b/c" defined anywhere?
11:09:57 <wolfnn> oh, I forgot that a string was a list; that's why I didn't understand the definition of intercalate... derp
11:10:18 <Hafydd> > foldr (\x y -> x ++ "/" ++ y) "" ["http:", "", "www.youtube.com", "watch?v=DFvl7_q51ew"]
11:10:19 <lambdabot>   "http://www.youtube.com/watch?v=DFvl7_q51ew/"
11:10:30 <S11001001> Hafydd: trailing
11:10:42 <Hafydd> It still works in Firefox.
11:10:54 <S11001001> that's an artifact of youtube
11:11:04 <S11001001> or firefox
11:12:00 <shachaf> Hmm, intercalate should be generalized to Monoid m => m -> [m] -> m
11:12:07 <shachaf> That type is both clearer and more general.
11:13:43 <shachaf> Or maybe it should also be generalized to Foldable.
11:13:48 <shachaf> Like you said.
11:15:01 <FreeFull> Ok, seems I have what I need
11:15:25 <dmwit> FreeFull: What did you end up deciding to do?
11:19:37 <dmwit> S11001001: I smell a libraries proposal.
11:21:26 <shachaf> Putting it in Data.List is kind of silly.
11:21:42 <shachaf> ...But not that silly given that Data.List is planned to reëxport half of Foldable anyway.
11:21:57 <S11001001> dmwit: point me where :)
11:23:39 <RichyB> shachaf, "reëxport".
11:23:55 <S11001001> dmwit: or I can apply basic internet skills and find it myself. :]
11:24:06 <aristid> RichyB: shachaf always does that.
11:24:30 <RichyB> Nice word. Excellent diaeresis.
11:24:39 <shachaf> S11001001: I think dmwit is suggesting that you libraries-proposalize it yourself.
11:24:49 <S11001001> shachaf: yeah
11:25:30 <shachaf> Oh, you're asking about the process? http://www.haskell.org/haskellwiki/Library_submissions
11:26:08 <S11001001> thanks
11:30:03 <simukis_> Is there any use case for -fforce-recomp?
11:30:37 <S11001001> @ty foldr1
11:30:38 <lambdabot> (a -> a -> a) -> [a] -> a
11:30:54 <bergmark> useful if you wan't to make sure you didn't miss any warnings
11:31:54 <dmwit> shachaf: Data.Foldable seems like the natural place to put it.
11:32:12 <dmwit> Also, thanks for pointing at the proposal process guidelines.
11:32:59 <enthropy> simukis_: you might be depending on files that ghc doesn't check for modification
11:33:15 <enthropy> maybe if you had a custom preprocessor
11:37:04 <simukis_> Yes. Both valid use cases. Thanks :)
11:38:07 <S11001001> hmm foldr1 not so great
11:38:28 <enthropy> surprisingly, having a #include "file" makes ghc check "file" when deciding to re-compile the .hs file
11:39:12 <merijn> enthropy: By surprising you mean "properly designed", right? :p
11:39:58 <satc> Quick question: Given list suppose [a1,a2,a3...] (not an infinite list but sorted in order), and an element ai, I want to merge (merge function is given) it with it predecessor and successor if they satisfy certain predicate. Can this be done in one pass of the list. There are lots of corner cases.
11:42:37 <dmwit> satc: I don't see why not.
11:44:42 <satc> dmwit: Yeah, I know. But my function (which is implementing it directly) is getting really messy. I could write that using a foldl and then a foldr, but I suppose that will be two passes.
11:45:11 <dmwit> :t map (take 3) . tails
11:45:11 <lambdabot> [a] -> [[a]]
11:45:19 <dmwit> > map (take 3) . tails $ [1..5]
11:45:20 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
11:46:16 <S11001001> satc: (x : x2 : xs) is a pattern
11:47:56 <dmwit> :t \ai merge xs -> [if b == ai then merge a b c else b | (a:b:c:_) <- tails xs]
11:47:57 <lambdabot> Eq t => t -> (t -> t -> t -> t) -> [t] -> [t]
11:48:40 <dmwit> :t \pred merge a b c -> foldr1 merge (filter pred [a,b,c])
11:48:40 <lambdabot> (a -> Bool) -> (a -> a -> a) -> a -> a -> a -> a
11:48:43 <satc> dmwit: I think I stated it wrong. There merge of a and b, and b and c are independent of each other
11:49:08 <dmwit> satc: See my second snippet. =)
11:49:11 <satc> dmwit: and the predicate test is on a and c.
11:49:31 <quchen> An example would help, satc. dmwit's solution is what I would have written.
11:49:36 <dmwit> satc: For producing the (t -> t -> t -> t) kind of merge from the (t -> t -> t) and (t -> Bool) kind. =)
11:50:52 <dmwit> I guess I'm still playing funny games with the first and last element of the list, though.
11:51:08 <enthropy> merijn: yep, it's not something I would have dependened on without testing out first
11:51:11 <dmwit> It's fixable.
11:51:34 <FreeFull> @pl \a b p -> floor $ p * (b-a) / 100 + a
11:51:37 <lambdabot> (((floor $) .) .) . ap (flip . (flip .) . (((+) .) .) . flip (flip . (flip .) . (((/) .) .) . (flip (*) .) . subtract) 100) id
11:51:38 <lambdabot> optimization suspended, use @pl-resume to continue.
11:51:41 <satc> eg. [a,b,c,d] and if item given is say c. then output will be, if pred b and not pred d then  [a, merge b c, d], if not pred b and pred c then [a, b, merge c d], if pred b and pred c then [a, merge (merge b c) d], if none then [a,b,c,d]
11:51:44 <FreeFull> Oh damn that's ugly
11:52:13 <dmwit> satc: I see.
11:52:51 <quchen> satc: Aaaaah. Way clearer. (Note that "pred" is already taken in Haskell, we typically call our predicates "p". "pred" stands for "predecessor".)
11:52:57 <quchen> dmwit: Your turn :>
11:53:27 <satc> sorry for the naming :)
11:54:29 <dmwit> So, my strategy would be to make a zipper pointing at the element of choice, do your local updates to the zipper, and flatten the zipper.
11:55:33 <satc> That was my first though, but looked overkill rather that defining a function which I am reconsidering now :)
11:55:43 <FreeFull> lambdabot isn't actually that good at making things pointfree
11:56:18 <satc> Is there a notation of minimum pointfree form of a function
11:57:22 <FreeFull> @pl f a b = floor . (+a) . (/ 100) . ((b-a)*)
11:57:26 <lambdabot> f = ((floor .) .) . ap ((.) . (.) . (+)) ((((/ 100) .) .) . ((*) .) . subtract)
11:57:26 <lambdabot> optimization suspended, use @pl-resume to continue.
11:57:59 <FreeFull> Shorter but still overly long
11:58:01 <FreeFull> @pl-resume
11:58:07 <lambdabot> f = ((floor .) .) . ap ((.) . (.) . (+)) ((((/ 100) .) .) . ((*) .) . subtract)
11:58:08 <lambdabot> optimization suspended, use @pl-resume to continue.
12:10:02 <hpaste> dmwit pasted “funny local merges” at http://lpaste.net/91846
12:10:29 <dmwit> satc: Probably easier with a zipper library or something, but hey, writing code from scratch is always fun. =)
12:14:00 <mhitza> how could I write my program so that it detaches itself from the shell when invoked?
12:27:51 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:27:51 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
12:27:51 --- names: list (clog edwardk k00mi_ tharper rtb copumpkin NemesisD lester___ nwf elediaz mannix azm eacameron riffm boegel pantsman banister mhitza tiripamwe martinalex purefn1 jophish_ blume flebron skarrmann Reite s4muel Krakarn jssanders Rarrikins apples xinming venice kerrick JaRoel|4d janua DMcGill nabilhassein poppingtonic lambdakind nimish pentace merijn satc yacks mjhoy twanvl milli Azel sferry Mon_Ouie PHO_ message144 quchen cajuina hiroaki joachifm oscarvarto)
12:27:51 --- names: list (jrslepak chunkt danharaj1 aegis__ ParahSailin paullik dgpratt Paprikac_ conehead insejn Nisstyre sxn maurer alszar__ path[l] milessabin_ c_wraith Puffton alpha123 ptc mizu_no_oto edtsech skeet70 arpunk resnik mmaruseacph2 kitallis u_ thealanwattsriot Velpoman OlegYch mrsolo alanz michael_ agjacome d_arcy PatrickRobotham dolio sclv_ Kaini c-rog geekosaur oleo idnar watermind erkin icasperzen m1001 tommd s4msung flux0r DrCode yepyep resttime bamboo descender)
12:27:51 --- names: list (ericmathison jchild Demos kcj thunderrd litherum knsd osa1 ioanel ijp adnap threesome sykora derelm jfischoff joehillen jamestastic iol Kiryx zentrification mhooge apfelbo__ yogurt_truck dubsg nadirvar_ Alice3 nominolo perspectival mgile marr tiffany Arkantos scottschecter seschwar algae Pip simukis_ drayevarg S11001001 zhulikas EvilPenguin bos raichoo ghorn kakos donri CaptainLex dgvncsz0f bananagram Noldorin wolfnn glosoli BeardedCoder phienone ekyo)
12:27:51 --- names: list (wormphlegm kobain go|dfish federkasten [[zzz]] nooodl Aerathis sellout kevinqcs scriptor finity jesyspa Zamarok_ h4199 Geison_Bequer noam fijimunk1i n-dolio YoungFrog WraithM cfricke Mortomes_ eyck pmade dysinger jbauman hashcat niklasb Mowah sleepynate LuxuryMode JobV1 amathew uniquenick BitPuffin kwos paintcan _d3f Neqoxec lambdanaut Wuzzy Pullphinger fxrh gg7_ Banistergalaxy guampa erochester ubikation Eduard_Munteanu idoru guest82 xplat_ linux_noob_666)
12:27:51 --- names: list (jvrmaia skago shreesh amyers Wizek gienah zomg cads mlh Jesin kofno Belgarion0 DT`` MindlessDrone Zenol wchun hive-mind supersym FunkyDrummer alexsdutton kstuart Work_jack mannyv kludge` fikusz lemao allsystemsarego q66 DolphR augur chrisdotcode fryguybob jonkri hiptobecubic SHODAN dsantiago nexx tero- Polarina k4nar SoupEvil mellum Philonous danvet threesteps gautamc Jonno_FTW Twey tuxit m3ga zammy Khisanth shachaf caligula yitz ravenvz cognominal pterygota)
12:27:51 --- names: list (Fuuzetsu simion314 otulp sidus frontendloader latro`a totimkopf case1 zvrba lunarjar enthropy jml_ isenmann n00dle maxter torwegia sclv xexonixxexillion araujo shanse preflex mauke wtw Deewiant wilfredh bentrevor chexxor Vertue kennyd idnaria Xorlev Shin-LaC seanparsons_ cdidd Philippa amosr nullcone alszar asjo apaku doomlord ninzine Iceland_jack epsylon jeff_s1 plucas nodeless zrot RichyB predator217 Excureo dwierenga doshitan julmac bytbox markov_twain)
12:27:51 --- names: list (lambdabot brainwash ParahSail1n xye machisuji mikee _flow_ Shou Jaxan maksbotan mimi_vx ktosiek crs_ coeus perlite PuercoPop vpm plhk McManiaC dsirenko_ tudalex popx [swift]_ mgsloan dmwit wooy miloshadzic ninegrid waterlaz Darkflux troydm dymatic morolin mithsv sbahra etabot Vorpal bergey shajra maximumsteve MoALTz ecube brandonw thetallguy DexterLB Athas niko mlamari dju saml parcs zxq9 yriw mee leifw srh_ IbnFirnas smarter_ foxnorth Soft ggherdov Sabey)
12:27:51 --- names: list (kubrat Gilly bscarlet destiny zebr jaimef ciaranm killy9999 jroesch ski_ jmcarthur Phlogistique sleepybug aleator sajith Lemmih osfameron ssbr udoprog joogi barrucadu fry mjrosenb mel- identity rgrinberg MK_FG gseitz wting rfw tych0 lpvb mjo_ carter fourOfTwelve mshroyer_ mapreduc1 cheezey orzo_ hfaafb caleb_9_ ggreg_ nik_89_ nonconve1gent flori_ cdk aford mantovan1 kloplop321 WhereIsMySpoon_ Bynbo7 jobstijl Kuba _br_ purefn biscarch amatsu pygospa folone)
12:27:51 --- names: list (xenocons ahihi ofan \rs joneshf-laptop nilg sanjoyd hamishmack MrWoohoo jzl fran xplat stepkut bergmark lusory vmeson chirpsalot s00pcan Kuraitou MrRacoon circle soulrain bbee Guest54726 Cerise dreixel shepheb tavelram Nshag Hafydd dabradley jzelinskie iteratee mjo chrisdotcode_ mceier iemejia SLi tertl3 tikhon stelleg absence katis redjohn Fubar^ tahu Vq Tene wollw jdoliner joneshf-work joaopizani Kabaka doomlord_ mephx k3VB6u4d akiress thomassgn isomorphic)
12:27:51 --- names: list (bbloom gereedy tg reactormonk bduc sirspazzolot Sculptor Guest63538 Dtgr byorgey schlumpi charlesofarrell_ tunixman AntiSpamMeta satshaba1 satshabad udevd natte osnr jcp mgaare saep counterstrike44 whaletechno vnz mbrock sShintah Draconx mak` stevejb Boney canissimia otto_s_ MouseTheLuckyDog Tarential rhodesd mstksg sordina andrewsw cmears Amadiro derekv shergill thorsten` jonsterling fabjan profmakx melter uu1101 pjstadig zenoli djahandarie mcbonz dkasak_)
12:27:51 --- names: list (sunfun dlundy sababa vili hellome Kyzza Arnoldz kekimmo DarkFox b2coutts KyleCloud gnuvince og canta Morgawr zq haasn dan64 obiwanko xenophon lattenwald krakrjak_ xymox ousado resure obcode Pad^ ssttudder Ralith shelf janinge kaktus dropdrive ido pcapriotti ircbrowse jackhill junsuijin albel727 solution Fuco davean benj_ Natch theorbtwo Internet13 noddy MetaCosm stvc td123 FreeFull blakesmith monochrom tvaalen torkjak c_14 de-Vri-es rmyers k0ral cods MOMI)
12:27:51 --- names: list (clahey daira burp b0c1 tauntaun ByronJohnson aloiscochard edkk scshunt ErkiDerLoony jang1 tehroflmaoer bartavelle aoh arnsholt Nik05 M-ou-se tomh- peddie_ cynick taruti sdx23 arkx so mokus Bwild fergusnoble Spaceghost peddie Igloo drbean gpampara_off tsou callen rasmusto epta jlaire joefiorini Tinned_Tuna davidt_ ceii tensorpudding swistak35 simon anon123 ccxCZ Tehnix felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid)
12:27:52 --- names: list (guerrilla iulian dpwright KitB tulcod sgso ivan` jlamothe adimit alpounet marienz yam dino- hape01 cajla palmje mrshoe Ke FireFly tridactyla SegFaultAX BigEndian Ycros yiannis_t Maxdamantus wunki `0660 vsayer Nimatek Enigmagic twn ethercrow dogmaT dexter1 tomejaguar adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o IanKelling leroux bobry demolithion brixen dyreshark mmathis gilbertw1 lenstr Will| Jello_Raptor)
12:27:52 --- names: list (vehk ab9rf stass Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer cschneid qz mietek lightquake solancile mortberg Raynos tylergillies_ stepcut raft helgikrs inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson KaneTW arkeet heath kloeri Odd_Bloke FUZxxl mxf knyppeldynan divarvel froztbyte _janne BMeph akraut etherfreak vvv drewr Erstarrung jrib zero7 sevvie hdevalence flazz Raynes quicksilver bd__ Bigcheese pikhq d3lxa si14 alej)
12:27:52 --- names: list (upgrayeddd lopex dcoutts pettter kryft Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc dario^CIP ion klugez gridaphobe wereHamster genisage ve TML pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra LeaChim dumbhat @ChanServ wavewave OrangeDuck tamiko Kinnison pnielsen sipa wagle isomorphismes anders^^_ magicman Dybber mendez Clint sp3ctum)
12:27:52 --- names: list (cruxeternus birkenfeld seantallen pharaun ericmj bqp XMunkki_ poucet elliott deavid gbarboza asante __main__ b52 tessier davd Ulrar mrd_ Starfire_ nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten Reisen jayne ccasin Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert mikeplus64 lpsmith Draggor horlicks zeiris_ notdan pyykkis)
12:27:52 --- names: list (mononofu lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus Yaniel ejls Watcher7 swook` dsp_ bgamari aformeny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid `^_^v zorzar pr aninhumer ziman Razz mr- ryanakca thoughtpolice dilinger_ malorie_ pqmodn_ ttm kaol CosmicRay mornfall schoppenhauer Ornedan hiredman joelteon)
12:27:52 --- names: list (briden liyang guymann supki Zariel skypers Sourceless bind companion_cube ChongLi Yawgmoth_ bholst_ tswett mami_ ehamberg Boreeas statusfa1led mollerstrand ernst shiona fayden jlouis thorsten1 Maior mviljamaa hvr lispy Saizan luite saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside davorak_ othiym23 brainproxy rce brendan Cryovat Brando753 integral JPohlmann duairc jlewis geoffh BlastHardcheese ahf a11235 mux bstrie slobo_ deggis cow-orke1 kranius)
12:27:52 --- names: list (Gothmog_ kqr1 zaphar_p1 theDon Elision thetallguy2 mixi Laney gbluma_ MasseR peltchu Hardolaf gemelen phryk saiam^ dustinswan Mayzie tippenein bogner_ joar ReinH kaw flux Tribal sm int-e alexander__b stiell h_chiro_ kshannon liori `bps Svedrin hackagebot Valodim mechairoi elgot saiam aess ysuzuki ocharles otterdam myme1 zerokarmaleft neektza1 SaBer dan_johnsin kxra mlinksva thirsteh nxorg8 averell thorkilnaur__ noplamodo linduxed wto tomprince Th0mas f8l maoe)
12:27:52 --- names: list (nanothief_ JustAPerson koala_man levitation[A] vvein mero edwtjo bezik vobi earthy newsham BrianHV electrogeek bogner petantik arbn s_quark thebnq ivan\ neurocyte cmsd2 knz Martty bcoppens brett yano farn sepeth Eridius mikecaruso NeatBasis_ palaga blz37 mykhal dthibodeau banjiewen jhh Licenser kini joeyh DrSyzygy ehd gdeest xrl jodaro_ Ghoul_ vivekrai kav shennyg talzeus_ chrisbuchholz lokydor xorox90_ akahn ps-auxw ortmage warpy chickenflu puzza007)
12:27:52 --- names: list (shutdown_-h_now eL_Bart0 seneca hpd spligak etrepum michaf srcerer Baughn_ tdammers hiyakashi qwandor drdo)
12:28:10 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:28:10 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
12:28:10 --- names: list (clog edwardk k00mi_ tharper rtb copumpkin NemesisD lester___ nwf elediaz mannix azm eacameron riffm boegel pantsman banister mhitza tiripamwe martinalex purefn1 jophish_ blume flebron skarrmann Reite s4muel Krakarn jssanders Rarrikins apples xinming venice kerrick JaRoel|4d janua DMcGill nabilhassein poppingtonic lambdakind nimish pentace merijn satc yacks mjhoy twanvl milli Azel sferry Mon_Ouie PHO_ message144 quchen cajuina hiroaki joachifm oscarvarto)
12:28:10 --- names: list (jrslepak chunkt danharaj1 aegis__ ParahSailin paullik dgpratt Paprikac_ conehead insejn Nisstyre sxn maurer alszar__ path[l] milessabin_ c_wraith Puffton alpha123 ptc mizu_no_oto edtsech skeet70 arpunk resnik mmaruseacph2 kitallis u_ thealanwattsriot Velpoman OlegYch mrsolo alanz michael_ agjacome d_arcy PatrickRobotham dolio sclv_ Kaini c-rog geekosaur oleo idnar watermind erkin icasperzen m1001 tommd s4msung flux0r DrCode yepyep resttime bamboo descender)
12:28:10 --- names: list (ericmathison jchild Demos kcj thunderrd litherum knsd osa1 ioanel ijp adnap threesome sykora derelm jfischoff joehillen jamestastic iol Kiryx zentrification mhooge apfelbo__ yogurt_truck dubsg nadirvar_ Alice3 nominolo perspectival mgile marr tiffany Arkantos scottschecter seschwar algae Pip simukis_ drayevarg S11001001 zhulikas EvilPenguin bos raichoo ghorn kakos donri CaptainLex dgvncsz0f bananagram Noldorin wolfnn glosoli BeardedCoder phienone ekyo)
12:28:10 --- names: list (wormphlegm kobain go|dfish federkasten [[zzz]] nooodl Aerathis sellout kevinqcs scriptor finity jesyspa Zamarok_ h4199 Geison_Bequer noam fijimunk1i n-dolio YoungFrog WraithM cfricke Mortomes_ eyck pmade dysinger jbauman hashcat niklasb Mowah sleepynate LuxuryMode JobV1 amathew uniquenick BitPuffin kwos paintcan _d3f Neqoxec lambdanaut Wuzzy Pullphinger fxrh gg7_ Banistergalaxy guampa erochester ubikation Eduard_Munteanu idoru guest82 xplat_ linux_noob_666)
12:28:10 --- names: list (jvrmaia skago shreesh amyers Wizek gienah zomg cads mlh Jesin kofno Belgarion0 DT`` MindlessDrone Zenol wchun hive-mind supersym FunkyDrummer alexsdutton kstuart Work_jack mannyv kludge` fikusz lemao allsystemsarego q66 DolphR augur chrisdotcode fryguybob jonkri hiptobecubic SHODAN dsantiago nexx tero- Polarina k4nar SoupEvil mellum Philonous danvet threesteps gautamc Jonno_FTW Twey tuxit m3ga zammy Khisanth shachaf caligula yitz ravenvz cognominal pterygota)
12:28:10 --- names: list (Fuuzetsu simion314 otulp sidus frontendloader latro`a totimkopf case1 zvrba lunarjar enthropy jml_ isenmann n00dle maxter torwegia sclv xexonixxexillion araujo shanse preflex mauke wtw Deewiant wilfredh bentrevor chexxor Vertue kennyd idnaria Xorlev Shin-LaC seanparsons_ cdidd Philippa amosr nullcone alszar asjo apaku doomlord ninzine Iceland_jack epsylon jeff_s1 plucas nodeless zrot RichyB predator217 Excureo dwierenga doshitan julmac bytbox markov_twain)
12:28:10 --- names: list (lambdabot brainwash ParahSail1n xye machisuji mikee _flow_ Shou Jaxan maksbotan mimi_vx ktosiek crs_ coeus perlite PuercoPop vpm plhk McManiaC dsirenko_ tudalex popx [swift]_ mgsloan dmwit wooy miloshadzic ninegrid waterlaz Darkflux troydm dymatic morolin mithsv sbahra etabot Vorpal bergey shajra maximumsteve MoALTz ecube brandonw thetallguy DexterLB Athas niko mlamari dju saml parcs zxq9 yriw mee leifw srh_ IbnFirnas smarter_ foxnorth Soft ggherdov Sabey)
12:28:10 --- names: list (kubrat Gilly bscarlet destiny zebr jaimef ciaranm killy9999 jroesch ski_ jmcarthur Phlogistique sleepybug aleator sajith Lemmih osfameron ssbr udoprog joogi barrucadu fry mjrosenb mel- identity rgrinberg MK_FG gseitz wting rfw tych0 lpvb mjo_ carter fourOfTwelve mshroyer_ mapreduc1 cheezey orzo_ hfaafb caleb_9_ ggreg_ nik_89_ nonconve1gent flori_ cdk aford mantovan1 kloplop321 WhereIsMySpoon_ Bynbo7 jobstijl Kuba _br_ purefn biscarch amatsu pygospa folone)
12:28:10 --- names: list (xenocons ahihi ofan \rs joneshf-laptop nilg sanjoyd hamishmack MrWoohoo jzl fran xplat stepkut bergmark lusory vmeson chirpsalot s00pcan Kuraitou MrRacoon circle soulrain bbee Guest54726 Cerise dreixel shepheb tavelram Nshag Hafydd dabradley jzelinskie iteratee mjo chrisdotcode_ mceier iemejia SLi tertl3 tikhon stelleg absence katis redjohn Fubar^ tahu Vq Tene wollw jdoliner joneshf-work joaopizani Kabaka doomlord_ mephx k3VB6u4d akiress thomassgn isomorphic)
12:28:10 --- names: list (bbloom gereedy tg reactormonk bduc sirspazzolot Sculptor Guest63538 Dtgr byorgey schlumpi charlesofarrell_ tunixman AntiSpamMeta satshaba1 satshabad udevd natte osnr jcp mgaare saep counterstrike44 whaletechno vnz mbrock sShintah Draconx mak` stevejb Boney canissimia otto_s_ MouseTheLuckyDog Tarential rhodesd mstksg sordina andrewsw cmears Amadiro derekv shergill thorsten` jonsterling fabjan profmakx melter uu1101 pjstadig zenoli djahandarie mcbonz dkasak_)
12:28:10 --- names: list (sunfun dlundy sababa vili hellome Kyzza Arnoldz kekimmo DarkFox b2coutts KyleCloud gnuvince og canta Morgawr zq haasn dan64 obiwanko xenophon lattenwald krakrjak_ xymox ousado resure obcode Pad^ ssttudder Ralith shelf janinge kaktus dropdrive ido pcapriotti ircbrowse jackhill junsuijin albel727 solution Fuco davean benj_ Natch theorbtwo Internet13 noddy MetaCosm stvc td123 FreeFull blakesmith monochrom tvaalen torkjak c_14 de-Vri-es rmyers k0ral cods MOMI)
12:28:10 --- names: list (clahey daira burp b0c1 tauntaun ByronJohnson aloiscochard edkk scshunt ErkiDerLoony jang1 tehroflmaoer bartavelle aoh arnsholt Nik05 M-ou-se tomh- peddie_ cynick taruti sdx23 arkx so mokus Bwild fergusnoble Spaceghost peddie Igloo drbean gpampara_off tsou callen rasmusto epta jlaire joefiorini Tinned_Tuna davidt_ ceii tensorpudding swistak35 simon anon123 ccxCZ Tehnix felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid)
12:28:10 --- names: list (guerrilla iulian dpwright KitB tulcod sgso ivan` jlamothe adimit alpounet marienz yam dino- hape01 cajla palmje mrshoe Ke FireFly tridactyla SegFaultAX BigEndian Ycros yiannis_t Maxdamantus wunki `0660 vsayer Nimatek Enigmagic twn ethercrow dogmaT dexter1 tomejaguar adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o IanKelling leroux bobry demolithion brixen dyreshark mmathis gilbertw1 lenstr Will| Jello_Raptor)
12:28:11 --- names: list (vehk ab9rf stass Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer cschneid qz mietek lightquake solancile mortberg Raynos tylergillies_ stepcut raft helgikrs inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson KaneTW arkeet heath kloeri Odd_Bloke FUZxxl mxf knyppeldynan divarvel froztbyte _janne BMeph akraut etherfreak vvv drewr Erstarrung jrib zero7 sevvie hdevalence flazz Raynes quicksilver bd__ Bigcheese pikhq d3lxa si14 alej)
12:28:11 --- names: list (upgrayeddd lopex dcoutts pettter kryft Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc dario^CIP ion klugez gridaphobe wereHamster genisage ve TML pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra LeaChim dumbhat @ChanServ wavewave OrangeDuck tamiko Kinnison pnielsen sipa wagle isomorphismes anders^^_ magicman Dybber mendez Clint sp3ctum)
12:28:11 --- names: list (cruxeternus birkenfeld seantallen pharaun ericmj bqp XMunkki_ poucet elliott deavid gbarboza asante __main__ b52 tessier davd Ulrar mrd_ Starfire_ nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten Reisen jayne ccasin Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert mikeplus64 lpsmith Draggor horlicks zeiris_ notdan pyykkis)
12:28:11 --- names: list (mononofu lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus Yaniel ejls Watcher7 swook` dsp_ bgamari aformeny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid `^_^v zorzar pr aninhumer ziman Razz mr- ryanakca thoughtpolice dilinger_ malorie_ pqmodn_ ttm kaol CosmicRay mornfall schoppenhauer Ornedan hiredman joelteon)
12:28:11 --- names: list (briden liyang guymann supki Zariel skypers Sourceless bind companion_cube ChongLi Yawgmoth_ bholst_ tswett mami_ ehamberg Boreeas statusfa1led mollerstrand ernst shiona fayden jlouis thorsten1 Maior mviljamaa hvr lispy Saizan luite saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside davorak_ othiym23 brainproxy rce brendan Cryovat Brando753 integral JPohlmann duairc jlewis geoffh BlastHardcheese ahf a11235 mux bstrie slobo_ deggis cow-orke1 kranius)
12:28:11 --- names: list (Gothmog_ kqr1 zaphar_p1 theDon Elision thetallguy2 mixi Laney gbluma_ MasseR peltchu Hardolaf gemelen phryk saiam^ dustinswan Mayzie tippenein bogner_ joar ReinH kaw flux Tribal sm int-e alexander__b stiell h_chiro_ kshannon liori `bps Svedrin hackagebot Valodim mechairoi elgot saiam aess ysuzuki ocharles otterdam myme1 zerokarmaleft neektza1 SaBer dan_johnsin kxra mlinksva thirsteh nxorg8 averell thorkilnaur__ noplamodo linduxed wto tomprince Th0mas f8l maoe)
12:28:11 --- names: list (nanothief_ JustAPerson koala_man levitation[A] vvein mero edwtjo bezik vobi earthy newsham BrianHV electrogeek bogner petantik arbn s_quark thebnq ivan\ neurocyte cmsd2 knz Martty bcoppens brett yano farn sepeth Eridius mikecaruso NeatBasis_ palaga blz37 mykhal dthibodeau banjiewen jhh Licenser kini joeyh DrSyzygy ehd gdeest xrl jodaro_ Ghoul_ vivekrai kav shennyg talzeus_ chrisbuchholz lokydor xorox90_ akahn ps-auxw ortmage warpy chickenflu puzza007)
12:28:11 --- names: list (shutdown_-h_now eL_Bart0 seneca hpd spligak etrepum michaf srcerer Baughn_ tdammers hiyakashi qwandor drdo)
12:28:11 -adams(freenode.net)- [freenode-info] please register your nickname...don't forget to auto-identify! http://freenode.net/faq.shtml#nicksetup
12:31:54 <dmwit> mhitza: Seems you will want to compile with -rtsopts=none on recent GHCs.
12:32:30 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#idp40393712
12:35:10 <mhitza> dmwit, that's great, thanks for the help
12:43:01 <troydm> just a quick noobie ghc-pkg related question
12:43:11 <troydm> i have two versions of some module installed
12:43:21 <troydm> when i do ghc-pkg find-module process
12:43:27 <troydm> i get two pathes outputed
12:43:37 <troydm> how do i uninstall one version?
12:45:05 <mhitza> troydm, ghc-pkg unregister package-version ?
12:45:19 <troydm> mhitza: but which version will it unregister?
12:45:31 <troydm> mhitza: i mean both are same version
12:45:31 <mhitza> you specify it after the dash (-)
12:45:39 <troydm> but installed in different directories
12:45:44 <troydm> one is system wide install
12:45:51 <troydm> the other one is in .cabal directory
12:45:53 <mhitza> oh, idk
12:46:35 <pentace> Do --user or --global flags work?
12:47:12 <byorgey> troydm: you can use the --package-db flag to specify which package DB it should look in
12:49:28 <simon> @pl liftM concat (mapM m x)
12:49:28 <lambdabot> fmap join (mapM m x)
12:50:12 <simon> any neater way to make concatMapM?
12:51:55 <shachaf> (fmap concat . mapM f) seems about as nice as you could want to describe that operation.
12:51:59 <troydm> byorgey: there is no such option for ghc-pkg unregister
12:53:20 <sclv_> oh byorgey btw i was wondering if you had a citation
12:53:30 <sclv_> for the fact that every data type in haskell admits at most one monad instance
12:53:32 <sclv_> up to iso
12:53:33 <byorgey> troydm: You have to do  ghc-pkg unregsiter --package-db=/some/path  or else   -f /some/path
12:53:43 <sclv_> its one of those things i just 'know'
12:53:58 <sclv_> i think the moggi paper had that proof in it
12:54:06 <sclv_> but its sorta dense so i'm not sure :-)
12:54:10 <byorgey> sclv_: did it?  I don't know
12:54:18 <byorgey> sclv_: I know a reference for  s/Monad/Functor/
12:54:25 <troydm> byorgey: my ghc-pkg seems to ignore --package-db option
12:54:35 <sclv_> which is that?
12:54:58 <sclv_> (it has a few proofs of uniqueness of stuff involving monads in it, but i didn't read through in enough detail to see if the right uniqueness was being proved)
12:55:23 <byorgey> sclv_: some mailing list post by roconnor, it's linked from the Typeclassopedia (though it's quite possible it was published somewhere before that and I'm not aware of it)
12:56:06 <byorgey> sclv_: yeah, re: uniqueness of monads, it's one of those folklore things and I don't think I've ever actually seen a proof
12:56:21 <sclv_> it surprised me when i realized i didn't know where it came from
12:59:10 <elliott> I've never seen a proof that fmap id = id implies fmap (f . g) = fmap f . fmap g, either. I've seen one that proves that *if* what you're defining fmap on is a Functor, that's true (for any function with the type of fmap), but that isn't quite the same thing, even though I totally believe the stronger version.
12:59:35 <elliott> s/Functor/Hask -> Hask functor/ etc.
13:00:00 <sclv_> can't you get there from free theorems?
13:00:15 <elliott> sclv_: that's what the proof of the weaker statement that I've seen does
13:00:21 <dmwit> elliott: Why isn't that the same thing?
13:00:28 <elliott> I'm sure you can prove the stronger version -- it's "obvious" -- but I've never seen such a proof.
13:00:54 <elliott> dmwit: let's say you have F :: * -> * such that there is no law-abiding Functor instance for F. then you can imagine a world in which you can have fmap :: (a -> b) -> F a -> F b such that fmap id = id
13:01:03 <elliott> the standard proof I have seen does not then give you fmap (f . g) = fmap f . fmap g, AFAICT
13:01:20 <sclv_> actually wait i don't know if its true
13:01:26 <sclv_> we have both listed as functor laws!
13:01:27 <elliott> I don't believe such an (F,fmap) pair exists, but I don't know of a proof that it doesn't
13:01:29 <sclv_> identity and composition
13:01:36 <sclv_> if one implied the other, then we wouldn't need both
13:01:48 <elliott> sclv_: not convincing. we list redundant laws fairly often
13:01:54 <elliott> especially when they're not redundant in the most general setting
13:01:57 <elliott> (i.e. outside of Haskell)
13:02:08 <sclv_> right they're certainly not redundant outside of haskell
13:02:20 <sclv_> but i also strongly suspect they're not redundant in haskell
13:02:24 <dmwit> elliott: I think what you said there is just a restatement of your claim, not (yet) an explanation of why it isn't the same thing.
13:02:24 <elliott> again, I believe in the stronger statement, and the stronger statement is usually how it is stated, but the proof I have seen is for the weaker statement
13:02:35 <dmwit> e.g. what assumption are you saying the free-theorem-proof uses that it shouldn't, and where?
13:02:46 <satc> Does somebody know how to allocate a
13:02:54 <satc> Ptr with the given alignment
13:03:00 <elliott> dmwit: I don't remember. :) I seem torecall it involves equational rewriting with the presumed "real fmap" of F (what @free calls $map_F) or such.
13:03:09 <elliott> *to recall
13:04:03 <byorgey> http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
13:04:42 <dmwit> Okay. Reviewing the proof, I understand the objection.
13:05:14 <shachaf> That objection sounds familiar..
13:05:18 <shachaf> s/$/./
13:05:34 <shachaf> I think ddarius wrote about it a while ago.
13:05:43 <byorgey> sclv_: is  return = Nothing; _ >>= _ = Nothing  a valid Monad?
13:05:49 <dmwit> Unfortunately, I don't understand free theorems enough to understand whether the objection is a sensible one. Probably it is. =P
13:05:59 <dmwit> byorgey: nope
13:06:06 <dmwit> return x >>= f = f x is violated
13:06:17 <byorgey> oh, of course.
13:06:17 <dmwit> (because f can return Just something)
13:06:39 <byorgey> ddarius got that one wrong: http://lambda-the-ultimate.org/node/1276#comment-14214
13:07:05 <byorgey> (in 2006, presumably he is now much more enlightened)
13:07:21 <djahandarie> He should have known that if he's writing that it's trivial that he in fact introduced an error somewhere in the preceeding line.
13:07:29 <byorgey> hehehe
13:07:31 <shachaf> Enlightened enough not to show up in #haskell, certainly.
13:07:34 <shachaf> So more than any of us.
13:08:17 <shachaf> Anyway, multiple Monad instances for the same Functor are certainly possible.
13:08:25 <shachaf> Just not in this case.
13:09:22 <elliott> shachaf: the objection is familiar because you pointed it out to me.
13:09:38 <byorgey> sclv_: anyway, it would be a good question to send to the TYPES mailing list (don't know if you're subscribed)
13:09:51 <sclv_> yes i am but it is incredibly intimidating
13:10:00 <byorgey> shachaf: are they?
13:10:08 <byorgey> shachaf: can you give an example?
13:10:15 <shachaf> byorgey: Sure, just like multiple Monoid instances are possible.
13:10:17 <sclv_> (except for this sad discussion that broke out last year)
13:10:24 <shachaf> In fact, with Writer, those are the same thing.
13:10:32 <byorgey> shachaf: oh, good point.
13:10:53 <dmwit> Cool! So this answers the question neatly, then.
13:10:55 <byorgey> sclv_: well, never mind, shachaf just disproved your "folklore"
13:10:57 <dmwit> Monad instances are not unique.
13:11:01 <sclv_> oh i see so instance Monad (,1)
13:11:05 <elliott> the Writer thing seems sort of artificial though.
13:11:10 <elliott> it is the only example of this I can think of.
13:11:13 <sclv_> or (Int,) rather
13:11:17 <byorgey> right
13:11:22 <sclv_> wait no that's not true!
13:11:25 <elliott> perhaps there is some kind of (vague) "naturality" condition you can place
13:11:27 <sclv_> the _monad_ is the same
13:11:31 <sclv_> the algebraic operations
13:11:34 <sclv_> like "tell" differ
13:11:34 <elliott> so that all things "parameterised" have to be grouped
13:12:10 <sclv_> but the defns for >>= and etc are the same
13:12:18 <elliott> sclv_: that seems dubious.
13:12:19 <elliott> the definition for return differs
13:12:19 <sclv_> modulo different values for mempty
13:12:20 <shachaf> sclv_: join (n,(m,x)) = (n+m,x) vs. (n*m,x) ?
13:12:20 <sclv_> but that's upto iso!
13:12:20 <elliott> return = (0,) vs. return = (1,)
13:12:20 <shachaf> Or that.
13:12:20 <sclv_> absent "tell"
13:12:21 <elliott> you can distinguish it using just the instance
13:12:21 <sclv_> then (0,) and (1,) are upto iso
13:12:21 <elliott> who cares about tell? (,) exists.
13:12:28 <elliott> if you ignore the fact that (,) has a constructor, well then yeah duh, it's different.
13:12:48 <shachaf> If you expose nothing about the type except fmap/join/return then your monad is automatically very boring.
13:13:00 <sclv_> lies!
13:13:05 <sclv_> list and cont aren't boring
13:13:15 <dmwit> List and Cont expose more than just fmap/join/return.
13:13:20 <shachaf> Yes they are, without runCont and looking at the list structure.
13:13:21 <tikhon> list, at least, would be boring without (:) or (++) or something
13:13:26 <dmwit> List exposes (:) and []; Cont exposes runCont and stuff like that.
13:13:33 <sclv_> true enough, i guess
13:13:45 <shachaf> elliott: There are also those dubious backwards state monads.
13:13:47 <sclv_> but anyway the claim is that there's a unique definition for the monad typeclass upto iso
13:13:56 <sclv_> not about individual algebraic operations
13:14:10 <shachaf> I'm not sure what you mean.
13:14:12 <tikhon> hmm
13:14:12 <dmwit> Wait, for the *typeclass*? Not for instances?
13:14:20 <sclv_> for instances of the typeclass
13:14:33 <elliott> sclv_: I think either you're confused or I am. the things you are saying seem contradictory to me.
13:14:35 <sclv_> the fact that we can write the Writer monad instance once and forall
13:14:41 <sclv_> instead of once per monoid
13:14:50 <sclv_> is witness to exactly the "upto iso" property i'm talking about
13:14:50 <shachaf> The Writer instance *depends* on the Monoid instance.
13:15:03 <dmwit> sclv_: Product Int and Sum Int are not isomorphic as monoids.
13:15:11 <dmwit> even Product Integer and Sum Integer
13:15:18 <sclv_> as long as you only use mempty and not mappend then they are
13:15:20 <shachaf> data Foo a = Foo Int a; instance Monad Foo where ...
13:15:27 <dmwit> irrelevant
13:15:46 <sclv_> because i can witness a transformation from running one to running the other
13:15:48 <tikhon> if you only had mempty and <>, you would only be able to construct mempty
13:15:56 <elliott> sclv_: I suggest forgetting monoids exist.
13:16:06 <elliott> data Hello a = Hello Int a
13:16:08 <sclv_> sure that makes it even easier
13:16:18 <elliott> instance Monad Hello where return = Hello 0; join (Hello m (Hello n x)) = Hello (m+n) x
13:16:23 <elliott> instance Monad Hello where return = Hello 1; join (Hello m (Hello n x)) = Hello (m*n) x
13:16:28 <elliott> same type. two different instances. checkmate?
13:16:32 <sclv_> oh, hm
13:16:37 <elliott> both observably different, both law-following
13:16:39 <Zenol> zHave you a EnvT example of use?
13:16:46 <S_J> How would Haskell do for soft realtime communication? 1. for writing a testtool? 2. for use in an embedded system? how big are haskell exe? Does it need a big runtime apart from the exe?
13:16:48 <sclv_> i may relent!
13:16:50 <elliott> you can "refactor" this so that the instances are writers of two different monoids
13:16:56 <kekimmo> I'm trying to install wxHaskell from https://github.com/wxHaskell/wxHaskell and wxc installs fine, but wxcore fails with "* Missing C library: wxc"
13:16:58 <sclv_> darn folklore
13:16:59 <elliott> but that's a rewrite you're consciously making :)
13:17:19 <sclv_> oh wait no i don't relent
13:17:22 <geekosaur> kekimmo, cabal can't install C-side libs for you
13:17:33 <sclv_> because precisely that if you just have mempty and <> then its still upto iso
13:17:37 <geekosaur> use your package manager to install the wxWindows devel libraries
13:17:49 <kekimmo> oh right, it's talking about a different wxc?
13:17:53 <kekimmo> thanks
13:18:04 <dmwit> sclv_: Monad morphisms and monoid morphisms are *explicitly* allowed to observe non-monadic and non-monoidal structure.
13:18:10 <sclv_> i can transport Hello and Hello2 to one another with no information loss
13:18:24 <dmwit> sclv_: So when you say "up to isomorphism, assuming only monadic structure" you are doing something nobody cares about.
13:18:47 <sclv_> oh its a weaker claim
13:18:52 <sclv_> but i think it still is useful
13:18:56 <geekosaur> actually I would think that the haskell wxc binding should also fail without the C/C++ wxc around, but I'm not that familiar with how wxwindows/wxhaskell works
13:19:21 <geekosaur> ut "Missing C library" means it's a native library and not a Haskell package that's missing
13:19:34 <sclv_> because it says "if you can write something that obeys the monad laws and has the signature then either A) it is the only thing you can write or B) anything else you can write can be transported from it"
13:19:47 <dmwit> No, it is not saying that.
13:19:52 <shachaf> elliott: Does data Pair a = Pair a a also have two monad instances?
13:20:00 <sclv_> for some squiggly definition of transport
13:20:02 <shachaf> I mean, you can pick the diagonal.
13:20:23 <sclv_> introducing other algebraic laws breaks the symmetry
13:20:47 <sclv_> it is an explicit justification for "follow the types"
13:20:59 <sclv_> whereas if you "follow the types" for an applicative you might end up in two _very_ different places
13:21:02 <elliott> shachaf: hm. maybe so
13:21:32 <Zenol> S_J: THe "runtime" stuff needed to do lazy evaluating and all is the RTS http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/runtime-control.html and it's linked with the .exe / elf binary.
13:21:33 <sclv_> wait can you pick the diagonal
13:21:42 <shachaf> I'm not sure.
13:21:44 <sclv_> if you "flip" on join
13:21:49 <sclv_> then you end up screwing up the monad laws
13:21:59 <xplat> anyone know how to turn off 'warning: missing terminating ' character [enabled by default]' from cpp?
13:22:18 <shachaf> Yes, I think it doesn't really work.
13:22:18 <Zenol> S_J: So, once compiled, you can run it as if it was writen in C++, C, ASM, etc.
13:22:55 <shachaf> I'd believe it because (Bool->) should have a unique monad instance.
13:23:10 <shachaf> (Since Bool has a unique Comonoid instance!)
13:23:38 <xplat> yes, Pair a = Pair a a should have a readerlike (diagonal) instance
13:23:42 <xplat> of Monad
13:25:39 <shachaf> Right, but you can't take the other diagonal after all.
13:25:43 <dmwit> sclv_: I'm still not sure I understand what you're claiming.
13:26:41 <xplat> oh, yeah, the nonprincipal diagonal won't work
13:27:46 <dmwit> sclv_: If your claim is that the language "X ::= mempty | mappend X X" is boring, then I agree, but additionally claim that the claim is boring.
13:27:57 <sclv_> i claim you are boring ! :-P
13:28:05 <shachaf> This sentence is boring.
13:28:07 <dmwit> And you're not the first! =D
13:28:10 <sclv_> my claim has nothing to do with monoids
13:28:15 <sclv_> they just happen to have been thrown in
13:28:34 <shachaf> A Monad instance for (w,) is the same thing as a Monoid instance for w.
13:29:24 <sclv_> but those monoid instances are the same upto iso.
13:29:35 <sclv_> so that claim is indeed boring
13:29:36 <dmwit> If your claim is that the language "X ::= return v | fmap f X | join X" is boring, then I agree, but additionally claim that the claim is boring.
13:29:47 <shachaf> Do you mean that the underlying sets are isomorphic?
13:30:07 <dmwit> sclv_: Again: Product Integer and Sum Integer are not the same up to isomorphism.
13:30:25 <sclv_> as long as your only ints are those you get from mempty they are!
13:30:27 <dmwit> (monoid isomorphism!)
13:30:53 <dmwit> sclv_: And now we're back at saying that the language "X ::= mempty | mappend X X" is boring. Which is true, but not interesting.
13:31:06 <dmwit> If you want something interesting, you have to allow yourself operations outside of the monoid(/monad) interface.
13:31:09 <shachaf> dmwit: It's even more boring when you enforce the monoid laws.
13:31:16 <dmwit> right
13:31:39 <shachaf> "mempty" is a bad name, by the way.
13:31:55 <tikhon> yeah, we should just call it 0
13:32:02 <elliott> no, we should call it 1.
13:32:02 <tikhon> which would be especially fun for Product :)
13:32:03 <shachaf> No, we should call it 1.
13:32:05 <elliott> multiplication is inherently better.
13:32:06 * shachaf sighs.
13:32:11 <sclv_> they're the same
13:32:12 <sclv_> upto iso
13:32:24 <dmwit> sclv_: Define isomorphism, please.
13:32:28 <tikhon> sclv_: that sounds suspicious
13:32:35 <dmwit> Because you are not using the same definition that I am.
13:32:47 <sclv_> dmwit: isomorphism is just like bijection
13:32:49 <sclv_> upto iso
13:32:55 <tikhon> multiplication seems to have strictly more structure
13:33:24 <elliott> you really sound nutty right now sclv_ :p
13:33:59 <dmwit> Okay. There is a bijection between Product Integer and Sum Integer, that's true.
13:34:13 <dmwit> But the monoid operations (and hence the associated monad operations) do not preserve that bijection.
13:34:14 <shachaf> You mean between the underlying sets?
13:34:17 <arkeet> hi
13:34:20 <dmwit> e.g. 2+3 /= 2*3
13:34:23 <arkeet> what's this about bijections?
13:34:25 <shachaf> hi arkeet
13:34:29 <arkeet> hi shachaf
13:34:30 <S_J> if a communication test tool can be written in python it would also work in haskell inregard to performace right?
13:35:02 <arkeet> clearly we should just call the identity e
13:35:15 <shachaf> I am the Clover who walks by himself, and all monads are alike to me.
13:35:23 <dmwit> Hence the result of join (Hello 2 (Hello 3 ())) is different between the two monads, even though 2 and 3 are "the same" (in the identity bijection) in the two monads.
13:38:02 <sclv_> yeah i'm backed into a corner a bit
13:38:06 <sclv_> i'll rethink
13:38:07 <tikhon> S_J: you could write a Haskell version that was as fast as the Python one, most likely
13:38:14 <arkeet> or faster =)
13:38:29 <sclv_> its just maddening because its something that i've seen floating around as folklore forever
13:38:32 <sclv_> and there's some utility to it
13:38:33 <tikhon> but there's some chance that the most naïve Haskell program would be slower
13:38:34 <shachaf> What is?
13:38:37 <sclv_> but its better to recover that
13:38:49 <sclv_> than to get in a silly argument about what 'isomorphism' means
13:39:07 <sclv_> shachaf: the claim that while applicatives admit multiple instances, monads admit only one instance
13:39:09 <arkeet> isomorphism means exactly what it means. a morphism with an inverse.
13:39:28 <shachaf> This sentence is implying exactly what this sentence is implying.
13:39:53 <dmwit> sclv_: Where have you seen this claim?
13:39:54 <sclv_> this sentence is false if shachaf is telling the truth
13:40:01 <sclv_> dmwit: on every mailing list virtually forever
13:40:11 <sclv_> henning just made it in the libraries debate today
13:40:13 <sclv_> agian
13:40:15 <arkeet> it's easy to have different (even nonisomorphic) monad instances on the same type.
13:40:26 <sclv_> its harder than you think!
13:40:26 <dmwit> sclv_: Then perhaps you should disabuse him of this notion. =)
13:40:33 <sclv_> the example we have is Writer
13:40:36 <arkeet> e.g. take two different Monoid structures on some type X, and then you get two different monads for (,) X
13:40:39 <arkeet> yes
13:40:43 <quicksilver> sclv_: the addition monoid is different from the multiplication monoid. They are not isomorphic. They are quite distinct monoids on Z.
13:40:55 <quicksilver> maybe you've already got past that bit I only skimmed scrollback.
13:40:57 <sclv_> quicksilver: oh i agree
13:41:26 <sclv_> i was trying to modulate that claim by pointing out that since the monad operations themselves only introduce 'zero' and 'sum'
13:41:35 <sclv_> then they remain isomorphic
13:41:41 <arkeet> that doesn't make sense.
13:41:52 <shachaf> All monads are isomorphic!
13:42:14 <quicksilver> it sounds like you were pointing out that free structures are unique up to iso
13:42:14 <arkeet> all initial monads are isomorphic!
13:42:14 <sclv_> well the 'only value' you get in the 'writer' slot is mzero, ever
13:42:14 <arkeet> that's basically what you're saying.
13:42:15 <sclv_> right -- that's the problem
13:42:15 <quicksilver> that's true, certainly
13:42:15 <sclv_> so that way of modulating the claim falls down
13:42:41 <shachaf> How do you catch a unique isomorphism?
13:42:43 <arkeet> the stuff you can see in any blah only by using the axioms of blah are exactly the things in the initial blah.
13:42:49 <arkeet> where blah = monad, monoid, group, whatever
13:42:49 <sclv_> right
13:42:57 <sclv_> that claim is too weak
13:43:04 <sclv_> but obv the 'only one monad' claim is too strock
13:43:07 <sclv_> strong
13:43:21 <sclv_> but is there no claim that is just right?
13:43:40 <arkeet> I don't understand where we're trying to go.
13:43:57 <quicksilver> well the true claim is "all X-homomorphisms factor through the free X"
13:44:03 <quicksilver> is that what you're after?
13:44:05 <sclv_> i'm trying to preserve the useful intution, if it so exists, from the 'only one monad' claim
13:44:07 <shachaf> Identity is initial, right?
13:44:14 <dmwit> sclv_: Could you link me? Henning seems to appear many times in the libraries@ archives, and I don't see an obvious way to sort by date.
13:44:16 <sclv_> yeah that's a different route
13:44:33 <arkeet> shachaf: uh, maybe.
13:44:35 <quicksilver> all monoid homomorphisms can be expressed by their effect on the generators which means they factor through the free monoid on those generators.
13:44:43 <shachaf> arkeet: I'm pretty sure Maybe isn't initial. hth
13:44:56 <arkeet> shachaf: initiality is preserved by free functors, so uh
13:45:03 <arkeet> (initial = coproduct of nothing)
13:45:26 <arkeet> uh
13:46:03 <sclv_> hm i think he made a weaker claim
13:46:09 <n-dolio> Oh yes. I should have come up with that one.
13:46:10 <sclv_> i coulda sworn this was folklore
13:46:22 <shergill> sclv_: i've only skimmed the backlog, but is what you're trying to say related to the concept of free monads?
13:46:27 <sclv_> probably not
13:46:34 <sclv_> but the things we _can_ say turn out to be
13:46:48 <sclv_> because the things we _can_ say are way more boring than the thing i _want_ to say but is sorta, uh, false
13:47:05 <dmwit> heh
13:48:01 <shergill> lol
13:48:48 <sclv_> ok so the interesting thing with writer is sure, there are different instances for (Int,)
13:48:54 <sclv_> but we also have a way of writing them "once and for all"
13:49:18 <sclv_> with instance (Monoid a) => Monad ...
13:49:41 <arkeet> that's called a functor. (from the category of monoids to the category of monads)
13:50:31 <sclv_> so is there a claim we can make about any type admitting multiple instances for monad in fact being related to some other algebra
13:50:42 <sclv_> that "determines" the monad
13:50:53 <arkeet> ???
13:51:17 <sclv_> i.e. is there always some way to "factor out" the distinction between different monad instances on the same type
13:51:25 <sclv_> such that we get one monad instance and a 'leftover'
13:51:43 <arkeet> not really
13:51:51 <sclv_> ok can you give a counterexample?
13:51:53 <kekimmo> regarding my earlier question about wxcore install failing: I'm pretty sure wxc library it's talking about is the one installed by the wxc package from cabal (libwxc.so)
13:52:10 <arkeet> sclv_: no, what you're asking for doesn't really make sense
13:52:17 <sclv_> no it makes sense to me
13:52:17 <dmwit> Is it okay if we factor m into m :*: Void and demand that m have the algebraic structure known as "monad"? =)
13:52:29 <sclv_> dmwit: haha sure i see the problem there :-)
13:52:52 <n-dolio> You mean :+:?
13:53:00 <n-dolio> Or ()?
13:53:05 <arkeet> sclv_: the only thing that makes sense of "factoring out" differences between
13:53:08 <dmwit> err, :+:, yes
13:53:10 <arkeet> monads just leaves you with a functor.
13:53:12 <arkeet> no monad anymore
13:53:26 <sclv_> not any two monads arkeet, just any two monads on the _same_ type
13:53:33 <kekimmo> but I still have no idea why wxcore install can't find it
13:53:36 <sclv_> so (Int,) has many monads. two being product and sum
13:53:38 <arkeet> differences between monads with the same underlying functor, I Mean.
13:53:48 <arkeet> such as that.
13:54:12 <sclv_> but Monoid a => (a,) has only one monad
13:54:38 <arkeet> there's only one natural way to make (a,) a monad for *every* monoid a
13:54:51 <shachaf> No, you can also flip (<>).
13:54:53 <edwardk> nah it has two. you could run the monoid backwards. ;)
13:54:55 <arkeet> fine.
13:54:57 <edwardk> heh
13:55:02 <sclv_> right but that's equiv to flipping the monoid
13:55:06 <merijn> Boom! Lawyered!
13:55:08 <sclv_> so we can sort of quotient it out
13:55:13 <arkeet> no
13:55:20 <arkeet> =(
13:55:28 <arkeet> no good can come of this.
13:55:43 <dmwit> sclv_: I think you will find that by the time you work out a way to ask this question precisely, there will not be any question left.
13:55:48 <sclv_> this may well be
13:55:49 <quicksilver> Free (a,) is something like ([a],) isn't it?
13:55:54 <edwardk> is this the 'there should only be one monad up to isomorphism thing?
13:56:00 <sclv_> yeah, but there isn't really
13:56:01 <sclv_> because writer
13:56:07 <shachaf> quicksilver: Yep.
13:56:07 <sclv_> so i'm trying to recover sense from that
13:56:12 <quicksilver> although the actual representation uses nested Frees not (:)
13:56:21 <shachaf> quicksilver: It behaves a bit differently in the infinite case.
13:56:32 <dmwit> The gist of the question being, "am I a savvy enough mathematician to notice the shared algebraic structure between this particular class of monads?".
13:56:33 <tikhon> edwardk: yeah, that's what they're trying to figure out
13:56:34 <shachaf> (Because Free ought to be data, not codata. Or something like that.)
13:57:17 <tikhon> to me it sounds a bit suspicious, but I'd really have to think about it
13:57:31 <dmwit> Maybe you are, maybe you aren't. But it's not really a statement most mathematicians will care about. =)
13:57:33 <leroux> Is it possible to create and instance of Show of some type?
13:57:46 <edwardk> i'd be somewhat suspicious as well
13:57:46 <timinlondon> hey guys! Wondering if someone can help me with the correct syntax. I want to put a 'show' in or something so I can see what the values of n-1 and n-2 are:
13:57:47 <arkeet> yes. instance Show Foo where ...
13:57:48 <dmwit> leroux: Yes.
13:57:48 <leroux> Soem type that I've defined as `type blah = ...`.
13:57:49 * shachaf has no idea what the question being discussed is anymore.
13:58:01 <leroux> dmwit: Do you need to add some lang extension?
13:58:02 <shachaf> leroux: No, that's not a real type, it's just a synonym.
13:58:03 <tikhon> leroux: yes, but you probably don't want to
13:58:03 <timinlondon> here is my lne of code   let {fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2)}
13:58:11 <tikhon> leroux: instead, use newtype
13:58:14 <leroux> Okay.
13:58:29 <tikhon> the difference is that in type Foo = Bar Foo and Bar are *exactly* the same type
13:58:46 <tikhon> so if you have a function foo :: Bar -> ..., you could pass it a Foo and vice-versa
13:58:57 <dmwit> timinlondon: You might like Debug.Trace, possibly. But don't get used to it.
13:58:57 <tikhon> with newtype, the representation is the same but the types are different
13:59:09 <S_J> > let (<|>) a b = a < 0 && b < 0 in (<|>) 3 (-1)
13:59:10 <lambdabot>   False
13:59:10 <leroux> So, will I need to add any lang extensions now?
13:59:13 <drayevarg> does anybody happen to know if xmonad's reflectHoriz is all i need to make new tiled windows spawn on the right instead of left? i'm left-handed so i go counter-clockwise ;D
13:59:16 <S_J> > let (<|>) a b = a < 0 && b < 0 in (<|>) (-3) (-1)
13:59:17 <lambdabot>   True
13:59:25 <leroux> Nevermidn.
13:59:26 <tikhon> leroux: using newtype? no
13:59:26 <drayevarg> or uh, reverse that statement
13:59:27 <leroux> I got it.
13:59:29 <leroux> Thanks.
13:59:32 <tikhon> awesome
13:59:46 <timinlondon> thanks dmwit I'll look into it
13:59:48 <sclv_> maybe the weaker claim is "structures like X admit only one monad instance"
13:59:59 <elflord> nums = [if x < 10 then '0': show x else show x | x <- [1..15]] why this code give me an error: no instance for num from  the literal 1
14:00:04 <sclv_> and then we have representables, and maybe a few others
14:00:10 <tikhon> hmm
14:00:16 <elflord> it works inside ghci
14:00:17 <timinlondon> so i can't stick a sow in anywhere or anything like that?
14:00:17 <dmwit> drayevarg: /join #xmonad
14:00:21 <timinlondon> show
14:00:23 <tikhon> I guess part of the confusion is because thinking about isomorphism is difficult
14:00:24 <elflord> but not inside a file
14:00:57 <sclv_> not all strictly positive types, because writer certainly is that.
14:01:12 <drayevarg> dmwit: oops, thanks
14:01:36 <dmwit> elflord: Probably because of extended type defaulting. Give it a type signature.
14:01:50 <sclv_> but at least some notion of a 'unique monad toolkit' and the we can derive some sort of notion of the things that cause this property to go away.
14:01:52 <elflord> how to give it a type signature
14:02:04 <xplat> sclv_: it is not true that given an underlying, fixed functor, that there is only one possible monad (and hence one possible Monad instance)
14:02:15 <elflord> dmwit, how to give it ?
14:02:18 <dmwit> elflord: ...x <- [1 :: Integer ..15]... -- for example
14:02:19 <sclv_> right, that's what we've been discussing
14:02:27 <xplat> sclv_: this is true for a lot of specific functors, but by no moans all functors
14:02:30 <sclv_> exactly
14:02:36 <elflord> dmwit, OK we can do it like that !
14:02:43 <sclv_> so there's some folklore that is wrong
14:02:54 <sclv_> but vague folklore
14:03:03 <dmwit> I am not yet convinced it is folklore.
14:03:11 <sclv_> maybe i just made it up :-)
14:03:23 <tikhon> even if it wasn't folklore before, it's folklore now
14:03:24 <elflord> dmwit, it works thanks !
14:03:29 <dmwit> \o/
14:03:37 <tikhon> at least based on the definition of folklore I got by taking a folklore class :P
14:03:53 <n-dolio> sclv_: Your question seems to be, does every endofunctor that can be equipped with multiple monad structures have those structures as the image of a single functor from some other monoidal category.
14:03:55 <tikhon> (they try to define it as broadly as possible to claim as much territory for their discipline as they can)
14:03:58 <xplat> sclv_: but it's also true that generically Applicative has more instances than Monad, because a Monad instance gives two Applicative instances automatically, and generically those are different
14:04:02 <quicksilver> it is folklore in the sense that it has been discussed for years and people often try to theorise it to be true
14:04:03 <n-dolio> But I don't really see why that would be true.
14:04:12 <quicksilver> it's not folklore in the mathematical sense.
14:04:28 <tikhon> what is the mathematical sense of folklore?
14:04:45 <quicksilver> (mathematical folklore tends to mean - things which actually are true but not everyone appreciate the details or the reasons)
14:05:08 <tikhon> aha
14:05:14 * shachaf mumbles something about instance Monad ZipList
14:05:16 <arkeet> http://en.wikipedia.org/wiki/Mathematical_folklore
14:05:17 <tikhon> the wikipedia page on mathematical folklore was very useful
14:05:22 <tikhon> yeah, that one
14:05:25 <dmwit> I've definitely heard the term "folklore" used to describe things which were generally believed to be true but nobody had bothered to sit down and write a proof out.
14:05:38 <sclv_> yeah but occasionally they turn out not to be true
14:05:47 <sclv_> in this case i think that its never been assumed by ppl writing actual papers
14:05:53 <sclv_> because they know better
14:06:14 <tikhon> ooh, I have to go to a lecture on Black Scholes—have fun talking about monads and isomorphisms :)
14:06:28 <dmwit> Oh, the Wikipedia page mentions this sense of the term.
14:07:27 <sclv_> ok at this point i think i can refine the question to be: what distinguishes those functors which admit multiple monad instances from those that do not
14:07:38 <xplat> sclv_: also, the monads based on a specific functor make up a category, but that category isn't always isomorphic (or even equivalent) to some nice category you've heard of elsewhere like it is in the case of Writer a
14:08:36 <sclv_> i think there's got to be a notion of 'extra' information that's combined
14:08:46 <sclv_> i mean writer has it trivially
14:09:00 <sclv_> it just has 'extra stuff'
14:10:14 <sclv_> is it 'can be written as a functor containing two constructors with the same signature'?
14:10:27 <arkeet> ??
14:10:38 <quchen> I just looked at the Binary instance of Map, and noticed that it just converts the Map to a list for serialization. Am I right to assume that the de-serialized Map has the same entries, but not necessarily the same structure as the original map? (Just wondering, no practical reason for asking this)
14:10:40 <sclv_> any functor with such a property admits multiple monad instances, maybe.
14:10:47 <S_J> couldnt >>= and return be implemented for just about any type? so just about any typoe is a monad? or am i missing something.
14:11:05 <sclv_> like here's a degenerate case. data Two a = One | Two
14:11:05 <quchen> S_J: return and >>= have to obey the monad laws.
14:11:08 <startling> quchen, yeah
14:11:30 <dmwit> sclv_: Any instance will fail the return x >>= f = f x law.
14:11:31 <arkeet> S_J: e.g. Const m can never be a legal Monad, unless m ~ ()
14:11:42 <sclv_> oh right.
14:11:43 <lispy> quchen: I read S_J question as more of "are Types monads?"
14:11:47 <quchen> S_J: Also, type constructors that can be monads have to have kind `* -> *`. You can't make a monad out of Int, for example.
14:11:52 <S_J> quchen: but you cannot implement them so they dont...
14:12:03 <arkeet> and sometimes, you can't even write the monad instance (legal or not), e.g. you can't write return for Const Void
14:12:28 <sclv_> anyway thanks for beating some dumb ideas out of me all
14:12:28 <arkeet> unless you like bottom
14:12:39 <S_J> is it only type constructors with one argument that can be monads?
14:12:49 <arkeet> :k Monad
14:12:50 <lambdabot> (* -> *) -> Constraint
14:12:58 <dmwit> sclv_: I look forward to watching you wield your new clue-by-four in the future. =D
14:13:00 <merijn> S_J: Those and partially aplied type constructors, yes
14:13:03 <S_J> what * -> * mean?
14:13:08 <arkeet> * -> * is a type constructor with one argument.
14:13:12 <sclv_> dmwit: nah i'm more likely to get hung up on my current question
14:13:15 <merijn> S_J: Example "Either e" is a Monad, but Either is not
14:13:16 <quchen> S_J: Yes. Maybe is an instance of Monad. (Either a) is an instance of Monad (for all a).
14:13:18 <arkeet> or rather, it is the kind of such.
14:13:23 <S_J> So SomeType String String String cant be a monad?
14:13:24 <merijn> S_J: * is the "type of a type"
14:13:35 <arkeet> deepnds on whether SomeType String String String accepts one more argument.
14:13:40 <monochrom> () is not a monad. nor Monad instance.
14:13:40 <merijn> S_J: i.e. "1 :: Int" and "Int :: *"
14:15:11 <monochrom> but you could say, "newtype U a = U ()". then U is a monad and Monad instance. but it's boring, and also Moggi has an objection to it.
14:15:28 <merijn> S_J: So "Maybe :: * -> *" (it takes a type and returns a type) and "Maybe Int :: *"
14:15:47 <merijn> S_J: "Either :: * -> * -> *", "Either Char :: * -> *" and "Either Char Int :: *"
14:16:07 <dmwit> monochrom: What is Moggi's objection?
14:16:23 <quchen> (What is Moggi?)
14:16:26 <monochrom> Moggi imposes more requirements than we usually do. one of them is: return should be injective. x!=y implies return x != return y. U breaks this.
14:16:32 <merijn> quchen: Who is Moggi, you mean
14:16:38 <quchen> (Who is Moggi?)
14:16:38 <dmwit> quchen: Moggi is the guy that introduced monads to computer scientists.
14:16:44 <quchen> Ah.
14:17:00 <dmwit> (introduced computer scientists to monads?)
14:17:01 <merijn> quchen: https://en.wikipedia.org/wiki/Eugenio_Moggi
14:17:02 <S_J> so data X = ...; can never be a monad? it has to be a data X a = ...?
14:17:09 <dmwit> (is "introduced" symmetric?)
14:17:10 <merijn> S_J: Correct
14:17:20 <merijn> S_J: Take a look at the type of >>=
14:17:23 <c_wraith> monochrom: how does he recommend determining equality for things like State?
14:17:32 <merijn> S_J: "Monad m => m a -> (a -> m b) -> m b"
14:17:35 <lunch> So...
14:17:39 <monochrom> Moggi's paper: http://www.disi.unige.it/person/MoggiE/ftp/lc88.pdf
14:17:41 <notasi> :t (>>=)
14:17:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:17:44 <merijn> S_J: The m takes an a and b as argument in that type
14:18:08 <dmwit> c_wraith: Perhaps you are worried about *deciding* equality. I doubt Moggi is, though.
14:18:15 <monochrom> well, State Int a is Int->(a,Int). use equality of Int->(a,Int)
14:18:32 <c_wraith> dmwit: oh.  Proving equality can be done intensionally.  right.
14:18:42 <xplat> c_wraith: almost any sensible equality on State, decidable or not, makes return injective
14:19:00 <monochrom> then again, Moggi uses monad for a particular purpose. he adds his requirements for that purpose. you need not obey.
14:19:39 * hackagebot strictly 1.0.0.0 - Combinators for strictifying functions  http://hackage.haskell.org/package/strictly-1.0.0.0 (DanBurton)
14:20:34 <monochrom> and yeah, when a mathematician adds an axiom, do not think "how would you use a computer to check that axiom?". it's beside the point.
14:21:18 <lunchtime> What's the practical application of haskell? Can it be used in web technologies?
14:21:32 <monochrom> there are infinitely many monoids for which you can't use a computer to check that they are monoids.
14:21:33 <lunchtime> Such as web APIs, or integrate w/ phython kind of deal?
14:21:33 <maurer> monochrom: I mean, you can say "How can you use a computer to search for whether this axiom is inconsistent"
14:21:34 <dmwit> Yes, see snap, yesod, happstack, scotty, etc.
14:21:36 <c_wraith> the practical application of haskell is writing software
14:21:38 <lunchtime> Or is it used strictly for problem solving?
14:21:42 <dmwit> It can integrate with Python via C.
14:21:49 <lunchtime> hmmm
14:21:54 <dmwit> It is used strictly for problem solving, yes. What's your problem?
14:21:54 <c_wraith> (the non-practical application of haskell is everything it does other than writing software)
14:22:30 <lunchtime> I'll take a peek in to it. I'm just wondering if it'd be suitable for web app development.
14:22:39 <lunchtime> Suppose I'll figure that out by some research eh.
14:22:50 <lunchtime> If anyone has some cool demos to share, that'd be awesome!
14:22:55 <c_wraith> The company I work at sort of happens to serve hundreds of requests per second with haskell
14:23:07 <cschneid> lunchtime: you can do arbitrary code in it. There are web frameworks.
14:23:10 <Adeon> I'm using happstack to implement a web interface to one of the projects I'm working on
14:23:22 <lunchtime> happstack, and thx cschneid
14:23:35 <lunchtime> It must be pretty powerful if there's 1200 of you in here haha
14:23:37 <dmwit> http://www.haskell.org/haskellwiki/Web/Frameworks
14:23:46 <lunchtime> thx dmwit
14:23:56 <lunchtime> Ah, yeah. all those things you mentioned are on here
14:24:02 <monochrom> "web app" is a special case of "strictly problem solving". at least ideally.
14:24:10 <S_J> how do i declare data Quiza = Solo x | Nada as an instance of Monad?
14:24:20 <lunchtime> social problem solving maybe, monochrom ? :P
14:24:27 <Hafydd> Hahah.
14:24:27 <monochrom> (what is "not strictly problem solving" anyway? is it "problem causing"?)
14:24:28 <c_wraith> S_J: you don't
14:24:29 <dmwit> S_J: What is "x"?
14:24:48 <c_wraith> S_J: Quiza has the wrong kind of be a monad.
14:25:05 <monochrom> "social problem solving" is still a special case of strictly problem solving
14:25:12 <lunchtime> hah
14:25:20 <Adeon> @faq can I use haskell to cause problems?
14:25:20 <lambdabot> The answer is: Yes! Haskell can do that.
14:25:27 <monochrom> you know, "if you aren't part of the solution, you're part of the problem"
14:25:29 <dmwit> I agree. The question sucks. Nobody uses anything except for problem solving.
14:25:45 <dmwit> My problem: not enough problems.
14:25:53 <monochrom> I would like to believe that Haskell is strictly part of the solution, not part of the problem.
14:26:20 <monochrom> I would hope that Python etc are, too, but apparently some people want the opposite.
14:26:20 <c_wraith> dmwit: that's not true.  edwardk has mentioned using haskell to explore theoretical spaces in the past.  That's not the same as actually solving a problem.
14:26:32 <lunchtime> As an avid python user, am I going to enjoy haskell?
14:26:47 <lunchtime> hmmm..
14:26:52 <lunchtime> exploring theoretical spaces..
14:26:54 <monochrom> that cannot be determined
14:27:13 <monochrom> it depends on you, not on whether you know python
14:27:16 <c_wraith> I was once an avid python user.  I like haskell.  So it's possible.
14:27:20 <dmwit> c_wraith: I find your classification of theoretical problems as "not problems" disturbing.
14:27:41 <lunchtime> Anyone w/ experience / knowledge on Haskell's ability to produce 3D models based on data?
14:27:41 <c_wraith> dmwit: well, the goal wasn't to solve anything.  That's the distinction I was trying to make.
14:27:42 <monochrom> you may as well ask, "I wear jeans, will I enjoy haskell?"
14:27:48 <nexx> As a haskell user, I don't enjoy pthon much
14:27:49 <lunchtime> Hahaha
14:27:53 <nexx> +y
14:27:56 <Hafydd> SJ: presumably, you mean: data Quiza a = Solo a | Nada; instance Monad Quiza where { return = Solo; Nada >>= _ = Nada; (Solo x) >>= f = f x }
14:28:11 <dmwit> c_wraith: Problem: I don't understand this theoretical space as much as I would like to.
14:28:19 <ParahSailin> i used python before haskell
14:28:31 <lispy> lunchtime: I'm not sure what you mean by 3D model. You want 3D printing?
14:28:50 <lunchtime> Umm, lispy, more like 3d visual to datasets
14:28:55 <lunchtime> thinking vector algebra
14:28:58 <lispy> ah
14:29:12 <dmwit> There are some fine vector algebra libraries, and there are bindings to OpenGL.
14:29:12 <lispy> There are opengl bindings and quite a few linear algebra libraries
14:29:14 <lunchtime> I see it's based on llambda calculus, so I suppose it's within it's ability lol
14:29:23 <lunchtime> Sweet, thanks guys.
14:29:29 <lunchtime> I'm officially intruiged and installing now.
14:29:46 <ParahSailin> the expressive type system of haskell makes it really easy to get answers in irc for what you're doing wrong
14:29:52 <lispy> ?faq Can Haskell capture lunchtime's interest?
14:29:52 <lambdabot> The answer is: Yes! Haskell can do that.
14:29:59 <lunchtime> haha
14:30:54 <Adeon> @where LYAH
14:30:54 <lambdabot> http://www.learnyouahaskell.com/
14:31:00 <lispy> ?faq Can Haskell make a Monad so big that Haskell can't lift it?
14:31:01 <lambdabot> The answer is: Yes! Haskell can do that.
14:31:08 <WraithM> @where RWH
14:31:08 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:31:21 <lunchtime> sweet links
14:31:30 <dmwit> ?where tutorials
14:31:31 <lambdabot> http://haskell.org/haskellwiki/Tutorials
14:31:40 <WraithM> @where where
14:31:40 <lambdabot> ^^^^^^
14:31:43 <WraithM> lol
14:31:55 <nexx> @where ASAP
14:31:55 <lambdabot> I know nothing about asap.
14:32:10 <dmwit> Wait, lambdabot is back to putting no space in front of ?where results?
14:32:35 <dmwit> ?where test-scary
14:32:35 <lambdabot> I know nothing about test-scary.
14:32:38 <Adeon> unthinkable
14:32:39 <dmwit> ?where+ test-scary ?scary
14:32:39 <lambdabot> It is forever etched in my memory.
14:32:42 <dmwit> ?where test-scary
14:32:42 <lambdabot> ?scary
14:32:53 <dmwit> ?where- test-scary
14:32:53 <lambdabot> Maybe you meant: where+ where
14:33:10 <dmwit> ?where+ test-scary I know nothing about test-scary.
14:33:10 <lambdabot> It is stored.
14:33:11 <dmwit> =P
14:33:37 <Taneb> dmwit, may be better with a second bot
14:33:47 <startling> ?where+ when preflex: seen lambdabot
14:33:47 <lambdabot> I will remember.
14:33:50 <Taneb> By better I of course mean much much worse
14:33:50 <startling> @where when
14:33:50 <lambdabot> preflex: seen lambdabot
14:33:51 <preflex>  lambdabot was last seen on #haskell 3 seconds ago, saying: I will remember.
14:33:53 <lispy> ?where+ test-quit /quit
14:33:53 <lambdabot> Good to know.
14:34:00 <lispy> ?where test-quit
14:34:00 <lambdabot> /quit
14:34:12 <lunchtime> lol
14:34:12 <dmwit> Taneb: Doesn't require a second bot to know whether it's scary or not. =)
14:34:15 <lunchtime> that would've been sneaky
14:34:19 <lunchtime> but I think /part is what you're lookin' for
14:34:47 <Taneb> lunchtime, /part leaves the channel, /quit exits the server
14:34:49 <dmwit> /quit and /part aren't part of the IRC spec. They're just something a lot of clients do.
14:35:17 <lispy> dmwit: good point
14:35:29 <lispy> dmwit: what would be a IRC command?
14:35:35 <Taneb> ?where+ test-quit aaaah
14:35:35 <lambdabot> It is forever etched in my memory.
14:35:35 <Taneb> QUIT
14:35:41 <Peaker> dmwit, does the IRC spec have no way to leave a channel?
14:35:42 <Taneb> Bah
14:35:44 <koala_man> lispy: privmsg #haskell :Hello world
14:35:44 <Taneb> Foiled again
14:35:53 <dmwit> lispy: Doesn't matter; by the time you get to the part you get to write with ?where, it's all bytes until a \r
14:35:56 <Taneb> Peaker, it's the / syntax that's not in the spec
14:36:01 <lispy> dmwit: gotcha
14:36:24 <Taneb> Saying something here would really be "PRIVMSG #haskell foo"
14:36:32 <Taneb> foo
14:36:39 <Taneb> Or something
14:36:51 <dmwit> I don't know for sure but I suspect it's hard to get an \r into lambdabot's where database. =P
14:36:51 <startling> Yeah, the only problem I can see is a botflood
14:37:16 <startling> @where when
14:37:16 <lambdabot> preflex: seen lambdabot
14:37:17 <preflex>  lambdabot was last seen on #haskell 1 minute and 41 seconds ago, saying: It is forever etched in my memory.
14:37:32 <lispy> ?where+ test-where @where
14:37:32 <lambdabot> Okay.
14:37:45 <lispy> @@ where where
14:37:46 <lambdabot>  where where
14:37:51 <hpc> Taneb: it's "PRIVMSG #haskell :foo"
14:37:53 <lispy> @@ @where where
14:37:53 <lambdabot>  ^^^^^^
14:37:59 <Taneb> hpc, I was clsoe
14:38:00 <Taneb> *close
14:38:14 <Taneb> When it takes me two tries to spell "close", I think I can have some leeway
14:38:16 <hpc> Taneb: and then on the receiving end, ":Taneb!foobar@foobar.foobar.x.com PRIVMSG #haskell :foo"
14:38:21 <Taneb> Also, we are dangerously off-topic
14:38:26 <hpc> heh
14:39:13 <lispy> Welcome to #meta-haskell
14:39:17 <Taneb> Earlier I submitted a pull request adding a version of Endo that takes its category as a parameter to monoid-extras
14:39:31 <lispy> We send well-formed IRC strings containing well-formed IRC strings to each other
14:39:49 <quchen> What would be the best way to getting a random element out of a TVar (Set a)? Random number generation is easily done in IO (performance is not really a concern), but I can't mix STM and IO. Split the standard generator and pass it to STM? Generate random number and use it as a seed for a new (pure) generator in STM?
14:39:51 <startling> we /have/ had multiple lambdabots in here. it should probably be fixed.
14:40:15 <hpc> quchen: you would probably do that last option
14:40:19 <startling> elliott, lambdabot should probably put a space before @where results
14:40:20 <dmwit> quchen: Have a TVar StdGen?
14:40:26 <hpc> probably even putting the... what dmwit said
14:40:33 <quchen> dmwit: Oh right
14:40:51 <quchen> Talk about overlooking the obviously best solution
14:41:06 <S_J> how does STM map do database transactions? if writing a database engine. could it be used efficiently or something?
14:41:21 <monochrom> why not factor the randomness out of the transaction? it's just a parameter
14:41:22 <dmwit> Easy: STM does not do database transactions.
14:41:39 <Peaker> quchen, you could also make an infinite stream of random numbers (randoms :: Random a, RandomGen g => g -> [a])
14:41:39 <elliott> startling: I suggest people just not botloop. the spaces are neither ubiquitous nor sufficient for someone dedicated.
14:41:40 <hpc> database transactions might hypothetically be implemented with STM
14:41:50 <elliott> like any spam problem, it can be solved by operators
14:41:52 <Cale> S_J: STM is similar in nature to database transactions, but for thread communication rather than disk storage.
14:41:54 <startling> elliott: that's fair
14:42:16 <dmwit> Oh, I thought S_J's question was about how to interface with databases from within STM.
14:42:27 <S_J> dmwit: but transactions, could that be used in an efficient threading model for a database?
14:42:28 <quchen> Peaker: Right, that's also a solution. I'll try them both and see which one I like better. Thanks
14:42:33 <satc> For the FFI gurus out there: Does unsafeForeignPtrToPtr is guaranteed to return the same Ptr used with newForeignPtr_?
14:43:05 <monochrom> do { r <- randomIO; atomically (do { s <- readTVar setvar; ... obtain and delete the r'th element of s; writeTVar setvar s1 })
14:43:12 <dmwit> Dunno. STM makes an implementation assumption (that transactions rarely step on each other) that probably isn't accurate for people with a real need for a database.
14:43:33 <hpc> satc: use the docs; also, when in doubt, unsafe* promises nothing
14:43:55 <quchen> I picture STM as a large group of first-graders trying to get through the same door. You better only let one or two of them try at the same time. :-)
14:43:59 <luite> satc: yes it's the same, but you risk the finalizer being run too early
14:44:27 <Cale> satc: It won't, if I understand what you mean.
14:44:31 <Cale> er
14:44:37 <c_wraith> quchen: they're only trying to get through the same door if you have contention on a single TVar.  Works much better if there are lots of doors. :)
14:44:40 * hackagebot bytes 0.10 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.10 (EdwardKmett)
14:44:46 <Cale> Well, which way around are we composing these things :)
14:44:48 <Cale> ?
14:45:18 <quchen> c_wraith: More doors only mean that you have a bigger school with more children. :P
14:45:26 <satc> luite: Thanks. The implementation source seems to say the same thing.
14:45:53 <Cale> If you make a new ForeignPtr with newForeignPtr_ and then unsafeForeignPtrToPtr on it, it will give you back the same Ptr you put in.
14:46:50 <Cale> But if you go the other way around, getting a Ptr from a ForeignPtr using unsafeForeignPtrToPtr, and then use newForeignPtr_ on that, you absolutely won't get the same ForeignPtr you started with.
14:46:57 <satc> Cale: Yeah. But is that guaranteed to be future proof, as that is not mentioned anywhere. It just saves me one call to unsafeForeignPtrToPtr as I have original Ptr lying around which I used while creating the ForeignPtr
14:47:35 <luite> satc: the original Ptr is just as unsafe as the one you get from unsafeForeignPtrToPtr though :)
14:47:45 <c_wraith> It seems either pointless or dangerous to create multiple ForeignPtrs for the same Ptr
14:47:46 <Cale> Why are you using unsafeForeignPtrToPtr?
14:48:15 <Cale> (rather than withForeignPtr)
14:48:17 <c_wraith> So if you're doing anything with it that isn't 100% pointless, it's probably dangerous.
14:48:24 <luite> satc: perhaps you should use more withForeignPtr instead
14:48:31 <satc> luite: Yeah, I know. I need the Ptr to pass to the Finalizer, for which should I use the original Ptr I used to create ForeignPtr with or again call unsafeForeignPtrToPtr ?'
14:48:35 <luite> ack too late :)
14:48:52 <monochrom> sounds like an XY problem
14:49:28 <Cale> satc: What are you actually trying to do. It shouldn't be necessary to use unsafeForeignPtrToPtr at all under ordinary circumstances.
14:49:33 <satc> luite: I can't. I am working on some kind of garbage collector for locked memory. I need to return the Ptr I allocated.
14:49:40 * hackagebot bytes 0.10.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.10.1 (EdwardKmett)
14:50:25 <luite> satc: perhaps ForeignPtr is not the right thing then (which is a Ptr with finalizers). why do you need ForeignPtr?
14:50:34 <hpc> satc: "some kind of"? are you hacking on an existing one?
14:50:56 <satc> Cale: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Concurrent.html My Finalizer action here (IO ()) in addForeignPtrFinalizer require Ptr.
14:51:48 <danilo2> Hi! I know that uu-parsinglib is not widely used, but if somebody of you knows it, I would be thankful for heliping me figure this out: http://stackoverflow.com/questions/18237578/correctly-parsing-line-indentations-in-uu-parsinglib-in-haskell :)
14:51:49 <satc> hpc: No. I am still not sure about the design. Its like a way of keeping track of locked memory.
14:52:10 <satc> luite: Locked memory require finalizer like to wipe it before unlocking it.
14:52:19 <Cale> satc: When you have an operation which needs to act on the underlying Ptr of a ForeignPtr, you use withForeignPtr (\ptr -> ...)
14:52:42 <luite> but the finalizer is already called with the underlying Ptr
14:52:50 <luite> since it's a FunPtr (Ptr a -> IO ())
14:52:58 <satc> luite: Not here http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Concurrent.html
14:53:18 <luite> satc: oh there the finalizer is just an IO ()
14:53:25 <satc> luite: Ghc was complaining about using this instead of the original one.
14:53:32 <luite> ih wait what
14:53:38 <luite> oh yeah
14:54:01 <monochrom> so don't use Foreign.Concurrent. use Foreign.Ptr.Safe
14:54:06 <Cale> I'm not sure I understand the purpose of this module, but also, when you write your IO action, you should be able to use the ForeignPtr in the same way.
14:54:26 <Cale> Just use withForeignPtr in your finalizer.
14:54:40 * hackagebot bytes 0.10.2 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.10.2 (EdwardKmett)
14:54:41 <monochrom> "addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()" where "type FinalizerPtr a = FunPtr (Ptr a -> IO ())"  use this
14:55:32 <monochrom> all XY problems are caused by depth-first search
14:55:38 <S_J> Has noone tried to compile C code so you can test it with quickcheck? Like what Joh nHughes did with Quviq...
14:55:39 <Eridius> I can't compile Pandoc with the latest Haskell Platform? Is this to be expected? The Pandoc Installing page suggests that using the Haskell platform is an appropriate way to install
14:56:02 <Peaker> Eridius, what error are you getting?
14:56:11 <satc> monochrom: Not in http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Concurrent.html
14:56:17 <monochrom> so don't use Foreign.Concurrent. use Foreign.Ptr.Safe
14:56:26 <Eridius> Peaker: in Parsing.hs, 2 instances of "error: universal character name refers to a control character" referring to a \u0080 in a regexp
14:56:27 <dmwit> Yes, better to ask how to fix it than to ask whether it's supposed to be broken. Obviously it's not supposed to be broken.
14:56:55 <Eridius> dmwit: not "supposed to be", but "expected", as in "known to be" :P
14:57:04 <luite> Cale: hmm, can't the finalizer keep the ForeignPtr alive that way? it seems a bit risky
14:57:07 <Peaker> Eridius, ah, weird, sounds like a ghc version incompatibility?
14:57:09 <dmwit> still not the property you care about
14:57:10 <satc> monochrom: Is that different from Foreign.ForeignPtr?
14:57:15 <Eridius> this is a brand new Haskell Platform install (64-bit OS X), and the very first thing I tried to install was pandoc, so it's basically a fresh environment
14:57:32 <monochrom> yes. Foreign.ForeignPtr no longer exists.
14:57:45 <Cale> luite: hmm
14:57:48 <satc> Thanks.
14:58:17 <Eridius> Peaker: Beign a GHC version incompatibility is what I'm afraid of, but if it doesn't compile with the latest haskell platform, then why do the install instructions suggest using the haskell platform?
14:58:22 <dmwit> Eridius: You should paste the exact error somewhere online for us to look at.
14:58:23 <Eridius> also, what's wrong with using
14:58:38 <Eridius> err using \u0080? Who cares that it's a control character? It's still a valid unicode codepoint
14:58:49 <Eridius> dmwit: https://gist.github.com/kballard/6236083
14:59:35 <Cale> What the heck...
14:59:40 <Eridius> there's also a lot of -Winvalid-pp-token warnings (but since they're warnings I'm ignoring them)
15:00:06 <dmwit> That's not even in a String...
15:00:10 <dmwit> it's complaining about a comment!
15:00:12 <dmwit> WTF?
15:00:38 <Eridius> hmm, maybe the warnings aren't so benign after all. Maybe it's actually parsing wrong
15:00:46 <Clint> maybe it thinks it's doctest
15:00:51 <Eridius> the warnings look like https://gist.github.com/kballard/6236095
15:00:58 <Cale> Is there a preprocessor being run on that code?
15:01:43 <luite> Cale: ah the docs say that finalizers don't keep weak refs alive
15:01:44 <Cale> Eridius: Those don't seem like GHC error messages to me.
15:01:49 <quicksilver> that's an error from GCC's cpp
15:02:00 <quicksilver> the -Winvalid-pp-token error, I mean
15:02:07 <Cale> ah
15:02:11 <quicksilver> so looks like the C preprocessor is being run
15:02:11 <Eridius> well what do you know, this all is preceeded with "Preprocessing library pandoc-1.11.1..."
15:02:16 <dmwit> Default-Extensions: CPP
15:02:27 <dmwit> So yes, there's a preprocessor being run.
15:02:34 <Cale> Maybe the cpp on OSX is misbehaving.
15:02:35 <Eridius> hrm
15:02:44 <Cale> Though I don't know why that would be
15:03:06 <luite> because the clang CPP is a lot more picky than gcc?
15:03:51 <quicksilver> well CPP is only really designed to work on languages with C's lexical syntax
15:03:58 <quicksilver> aren't there various hacks to get it to run over haskell code?
15:04:13 * quicksilver has never used it
15:04:17 <dmwit> I always figured GHC just shipped with its own variant of CPP. =P
15:04:19 <luite> it's annoying that haskell multiline strings interfere with CPP
15:04:49 <hpc> CPP is the annoying one
15:05:07 <Cale> I could have sworn at one point there was a version of CPP which was specifically designed for Haskell code, and that it was distributed with GHC, but I took a look at old copies of GHC and wasn't able to find it, so maybe I dreamt it.
15:05:18 <hpc> even in C you have such fun troubles as jerks who #define lowercase macros to shadow your functions
15:05:33 <hpc> Cale: you mean TH? :P
15:05:33 <luite> cppHs?
15:05:47 <Cale> (i.e. to work around the string gap issue and things like that)
15:05:50 <luite> is the only problem with cppHs the license? or does it not work well enough?
15:05:57 <quicksilver> there is cpphs, it's not shipped with ghc though
15:07:15 <Eridius> is there some way I can ask cabal to leave the build dir around so I can look at it?
15:07:27 <satc> @pl \f (a,b) -> (f a,b)
15:07:30 <lambdabot> flip (ap . flip ((.) . ((,) .)) fst) snd
15:07:30 <lambdabot> optimization suspended, use @pl-resume to continue.
15:07:41 <xplat> w00t, finished porting main() from xzgv from C to Haskell
15:07:50 <dcoutts_> Eridius: cabal unpack, and then build it from that local tree
15:08:10 <Eridius> dcoutts_: thanks
15:08:14 <arkeet> > over _1 f (a,b)
15:08:15 <lambdabot>   Ambiguous occurrence `a'
15:08:15 <lambdabot>  It could refer to either `L.a', defined at L.hs:1...
15:08:19 <S_J> > let (@) (a,b) = a b in (@) (Just,5)
15:08:20 <arkeet> uhm
15:08:20 <lambdabot>   <hint>:1:6: parse error on input `@'
15:08:21 <arkeet> @undefine
15:08:21 <lambdabot> Undefined.
15:08:23 <arkeet> > over _1 f (a,b)
15:08:23 <xplat> it was so much work, though, that i think it might be best after all to automate the process
15:08:24 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr
15:08:24 <lambdabot>                      (p...
15:08:32 <arkeet> > over _1 f (a,b) :: (Expr,Expr)
15:08:33 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
15:08:34 <lambdabot>                     (p0 ...
15:08:39 <arkeet> =(
15:08:43 <dmwit> :t over _1 f (a,b)
15:08:43 <lambdabot> (Indexable Int p, FromExpr (p Expr b)) => (b, Expr)
15:08:46 <quicksilver> it's a bit odd though because I can't google up any cases of other people havig that error with pandoc
15:09:02 <quicksilver> and it's quite a popular piece of software...
15:09:03 <dmwit> That p looks hard to instantiate.
15:09:24 <xplat> or at least, to automate more than i already have
15:09:28 <arkeet> what's wrong with what I wrote? =(
15:09:36 <dmwit> arkeet: The "p" is ambiguous.
15:09:39 <dmwit> can't nail itdown
15:09:42 <arkeet> ah.
15:09:49 <xplat> is there a way to get clang to dump a symbol table with types/prototypes?
15:09:51 <Eridius> quicksilver: it's possible that this is because I have the development version of Xcode installed, which means my `ghc` is actually clang in disguise, which means I may have a different CPP than expected
15:09:51 <dmwit> because it doesn't appear to the right of =>
15:09:52 <arkeet> > over _1 (f :: Expr->Expr) (a,b)
15:09:53 <lambdabot>   (f a,b)
15:10:11 <xplat> maybe a PP symbol table too?
15:10:28 <arkeet> I suppose it would have been an ambiguous type error.
15:10:29 <Eridius> it's likely that `cpp` with current shipping Xcode is still GCC, but my installed Xcode has `cpp` as clang
15:10:36 <arkeet> we should make (->) a default.
15:11:03 <dmwit> It would be nice to have a more flexible defaulting system.
15:11:07 <arkeet> very
15:11:10 <dmwit> Not that I know what it would look like.
15:11:18 <S_J> which chars can be used as functionnames? not @ but why can @@ ?
15:11:27 <dmwit> ?where report
15:11:27 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
15:11:43 <arkeet> > over (upon fst) f (a,b)
15:11:44 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
15:11:44 <lambdabot>                     Debug....
15:11:55 <arkeet> > over (upon fst) (f::Expr->Expr) (a,b)
15:11:56 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
15:11:56 <lambdabot>                     Debug....
15:11:58 <arkeet> oh well.
15:12:07 <hpc> S_J: certain identifiers are "off limits" for syntax
15:12:14 <arkeet> > over (upon fst) (+1) (6,7)
15:12:16 <lambdabot>   (7,7)
15:12:21 <arkeet> it's still disgusting how this works.
15:12:22 <hpc> S_J: for the same reason you can't have a function named "case"
15:12:30 <dmwit> (The real question is not "why @@?", but "why not @?". And the answer is "because that's part of the pattern syntax".)
15:12:55 <hpc> S_J: relatedly, (-->) is a legal identifier, but not (--) -- exercise to the reader as to why
15:12:56 <Eridius> is there any way to make the CPP extension use cpphs?
15:13:04 <S_J> :t upon
15:13:07 <S_J> :t over
15:13:08 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:13:11 <dmwit> > let a@(b:c) = [1,2,3] in (a, b, c) -- S_J
15:13:12 <lambdabot>   ([1,2,3],1,[2,3])
15:13:19 <arkeet> upon :: forall p f s a. (Indexable [Int] p, Applicative f, Data s, Data a) => (s -> a) -> p a (f a) -> s -> f s
15:14:48 <dmwit> Eridius: --with-PROG=PATH looks nice (from "cabal help install")
15:15:08 <dmwit> never used it myself, though
15:15:08 <Eridius> dmwit: I tried --with-cpphs=$(type -p cpphs) already, but it still used cpp
15:15:24 <dmwit> Eridius: Well, I'm sure cabal doesn't call it cpphs.
15:15:47 <Eridius> dmwit: the `cabal help install` page actually lists cpphs as one of the things you can use with --with-PROG
15:15:50 <Eridius> and doesn't list cpp
15:16:15 <dcoutts_> in any case, it's ghc that calls cpp, you'd have to tell ghc to use it
15:16:30 <dmwit> Huh, my cabal help install doesn't say that. =(
15:16:42 <dcoutts_> --ghc-options="-pgmc ...
15:17:22 <Eridius> crap. --ghc-options="-pgmPcpphs -optP--cpp" worked. But now I get a real GHC error
15:17:38 <Eridius> 9 instances of https://gist.github.com/kballard/6236219
15:18:01 <dmwit> oooo, that's an annoying one =P
15:18:26 <dmwit> Strange, I don't get that, and I have a new enough GHC to have Data.Monoid.<>
15:18:48 <dmwit> Eridius: What version of pandoc is cabal trying to install?
15:18:53 <Eridius> 1.11.1
15:18:54 <arkeet> hide <> from pandoc?
15:18:57 <dmwit> same here
15:19:07 <Eridius> GHC 7.6.3
15:19:13 <dmwit> same here =)
15:19:16 <arkeet> ah, pandoc has an ifdef
15:19:36 <arkeet> well, #if
15:20:32 <dmwit> Maybe your cunning preprocessor plan didn't work as well as hoped. =(
15:21:04 <dmwit> Should be easy to open up Pretty.hs and just rip out the wrong branch of the #if by hand, though.
15:21:13 <arkeet> maybe cpphs doesn't understand defines on the command line.
15:21:13 <dmwit> Keep the branch that says -- (<>) is defined in Data.Monoid
15:21:49 <dmwit> (around line 128)
15:22:09 <Eridius> :/
15:22:13 <dmwit> Also, when we're all done you should file a bug against pandoc saying what all you had to do. =)
15:22:29 <arkeet> are you sure it's not just a problem with cpphs?
15:23:33 <dmwit> Ideally things would Just Work with OSX's cpp and cpphs wouldn't enter the picture.
15:23:39 <arkeet> true!
15:23:40 <Eridius> any way I can see the invocation that ghc made to gcc and cpphs?
15:23:53 <dmwit> hrm
15:23:55 <arkeet> that was also my next question.
15:23:56 <Eridius> dmwit: yeah, the problem is that OS X is migrating from GCC to Clang
15:24:06 <dmwit> perhaps --with-ghc-opts=-vvvvvvvv
15:24:09 <xplat> cpphs understands defines on the command line
15:24:10 <arkeet> lol
15:24:31 <arkeet> or maybe it's not smart enough to figure out #if MIN_VERSION_base(4,5,0)
15:24:43 <xplat> but it has syntax incompatible with real cpp unless you put a special option in front of all your other options
15:24:50 <xplat> (no i don't know why)
15:24:57 <arkeet> yes, he gave -optP--cpp
15:25:06 <arkeet> which I assume is it.
15:25:09 <Eridius> arkeet: that's what the cpphs page suggested
15:25:15 <Eridius> I have no idea what the heck that's actually doing
15:25:50 <arkeet> maybe it does nothing.
15:25:51 <Eridius> ooh that passes --cpp as a flag to the preprocessor
15:26:03 <Eridius> and appaerntly is required
15:26:04 <arkeet> that's what I was assuming.
15:26:31 <Eridius> if I remove it I get "Unknown option -x, for valid options try cpphs --help". Wish I could see the invocation
15:26:43 * dmwit . o O ( pass cabal the option that tells ghc to tell cpp that it should act normal )
15:27:11 <Eridius> ahh --cpp is supposed to be followed by a value which are options given to standard cpp
15:29:38 <Eridius> here's the invocation: https://gist.github.com/kballard/6236302
15:30:59 <dmwit> looks like '-include' 'dist/build/autogen/cabal_macros.h' is the load-bearing bit
15:31:52 <Eridius> dmwit: oh sweet, if I try and use those flags on a tiny file that resolves MIN_VERSION_base(4,5,0) I get "Warning: Can't find file "dist/build/autogen/cabal_macros.h" in directories ..."
15:32:11 <Eridius> although now that I think about it, that may be a cwd issue
15:32:17 <arkeet> likely
15:32:44 <Eridius> nope, same issue if I run that from the pandoc-1.11.1 dir
15:32:52 <dmwit> Well... there isn't a -I. in the command line.
15:32:56 <dmwit> Perhaps there should be.
15:33:00 <Eridius> dmwit: . is listed already
15:33:04 <Eridius> err in the list of dirs
15:33:09 <Eridius> I seem to have dist/build, but no dist/build/autogen
15:33:16 <arkeet>   args <- return $ if "--cpp" `elem` args then convertArgs args else args
15:33:19 <arkeet> lol
15:33:26 <dmwit> Eridius: is it?
15:33:30 <arkeet> I guess.
15:33:43 <Eridius> dmwit: yes. here's the full output: https://gist.github.com/kballard/6236338
15:34:16 <Eridius> (I asked it to preprocess ../test/foo.hs)
15:34:41 <dmwit> okey
15:35:11 <dmwit> Well, I do have a dist/build/autogen after a successful build here, FWIW.
15:35:14 <arkeet> and cabal_macros.h does exist, right?
15:35:32 <Eridius> oh there we go. Had to re-run `cabal install`.
15:35:44 <Eridius> I think I may have re-unpacked or something, though that doesn't explain the partial dist folder
15:35:52 <satc> @hoolge IO a -> IO (Maybe a) -> IO a
15:35:52 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:35:52 <lambdabot> Data.Generics.Aliases ext1 :: (Data a, Typeable1 t) => c a -> (forall d. Data d => c (t d)) -> c a
15:35:52 <lambdabot> Data.Generics.Aliases ext1R :: (Monad m, Data d, Typeable1 t) => m d -> (forall e. Data e => m (t e)) -> m d
15:35:53 <Eridius> now the cpphs output is: test: (  (4) <  4 ||   (4) == 4 && (5) <  6 ||   (4) == 4 && (5) == 6 && (0) <= 0)
15:35:55 <arkeet> you should cabal unpack and cabal configure, maybe.
15:35:57 <arkeet> instead of install
15:36:04 <arkeet> satc: what do you want it to do?
15:36:26 <satc> arkeet: Similar to fromMaybe
15:36:28 <arkeet> :t liftA2 fromMaybe
15:36:29 <lambdabot> Applicative f => f c -> f (Maybe c) -> f c
15:36:39 <arkeet> or liftM2, I suppose
15:36:43 <Eridius> ok I think cpphs is just evaluating that conditional wrong
15:36:57 <arkeet> that will run both actions you give it, anyway
15:37:17 <Eridius> because if I use #if MIN_VERSION_base(4,5,0) it goes to the else branch even though I can see that the logic should evaluate the then branch
15:37:34 <arkeet> what does the relevant code in cabal_macros.h look like?
15:37:35 <hpaste> tippenein pasted “global restraint cabal” at http://lpaste.net/91851
15:37:40 <arkeet> out of curiosity
15:37:53 <Eridius> arkeet: I can check, but the evaluated output of MIN_VERSION_base(4,5,0) clearly should evaluate to true
15:37:59 <arkeet> clearly.
15:38:13 <Eridius> arkeet: https://gist.github.com/kballard/6236380
15:38:18 <dmwit> tippenein: gloss depends on a newer base than you have; install an older gloss or a newer GHC
15:38:37 <dcoutts_> tippenein: 'gloss => base==4.6.*' this is saying that gloss needs base 4.6.*
15:38:44 <tippenein> I had to install this gloss, so I'll need a newer ghc
15:38:57 <arkeet> tippenein: you'll need at least ghc 7.6, or an older version of gloss.
15:39:12 <tippenein> do I do that from ghc source?
15:39:15 <tippenein> or pm?
15:39:15 <dcoutts_> tippenein: and you have 4.5, and cabal cannot install a new base for you (that's what the "global constraint requires installed instance" thing is about)
15:39:43 <monochrom> there is no need to build ghc from source
15:40:07 <dmwit> Install from the GHC download page.
15:40:13 <dmwit> Grab a binary.
15:40:19 <arkeet> or, use your package manager.
15:40:20 <monochrom> consider http://www.haskell.org/ghc/download
15:40:22 <S_J> so, knowing some sort of structure forms a group, what can you use this for programatically? does haskell support this concept somehow?
15:40:50 <satc> arkeet: liftA2 fromMaybe, runs the first action despite of what the second action does.
15:40:54 <dmwit> S_J: Yes, I'm sure e.g. the numeric prelude has a Group type class.
15:40:55 <arkeet> satc: yes.
15:41:03 <monochrom> for specific advice, state specifics of your computing platform
15:41:20 <arkeet> satc: I don't know of anything that runs the second action first, and then runs the first only if the result is Nothing.
15:41:25 <dmwit> satc: Yes, and additionally there is no good, generic way to lift short-circuiting operations into a monadic context. You'll have to code it up yourself.
15:41:26 <Peaker> when will ghc change the default to be -threaded ?
15:41:27 <arkeet> you could write it yourself.
15:41:53 <dmwit> Peaker: That would be nice.
15:42:12 <dmwit> I haven't heard any mumbling about doing it, though, so I wouldn't hold my breath.
15:42:20 <arkeet> I have. just now. :-)
15:42:26 <dmwit> You could start mumbling yourself... =)
15:42:46 <monochrom> for consolation, ghci has defaulted to -threaded for years
15:43:05 <arkeet> Eridius: what if you just manually change it to #define MIN_VERSION_base(major1,major2,minor) 1 ?
15:44:15 <leroux> dmwit: I used FlexibleInstances instead of newtype, how is that looked upon?
15:44:19 <Eridius> arkeet: that causes my foo.hs to produce the then branch. But that's not a solution for installing pandoc via `cabal install` since it will just auto-regen the file
15:44:23 <satc> arkeet: I cameup with something complex
15:44:25 <S_J> dmwit: the numeric prelude?
15:44:32 <arkeet> Eridius: of course it's not a solution.
15:44:43 * Eridius is currently installing darcs, so he can fetch cpphs, to see if he can identify the logic error
15:44:44 <dmwit> S_J: http://hackage.haskell.org/package/numeric-prelude
15:45:01 <dmwit> leroux: FlexibleInstances and FlexibleContexts are two of the least controversial extensions.
15:45:07 <satc> arkeet: fromMaybe a1 . fmap return =<< maybeAction
15:45:11 <arkeet> :t \x y -> y >>= maybe x return
15:45:11 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
15:45:16 <leroux> dmwit: Okay, thanks.
15:45:50 <arkeet> the argument order seems strange, though, since it always runs the second argument first.
15:45:54 <dmwit> fromMaybe x . fmap f = maybe x f
15:45:58 <monochrom> ghci using -threaded has funny consequences. for example, your program forgets to close a file. if compiled, you do get the bad consequences of forgetting to close the file. if run in ghci, you don't get them. because with -threaded, when idling, GC happens and closes your file.
15:46:05 <dmwit> :t \x f -> fromMaybe x . fmap f
15:46:06 <lambdabot> c -> (a -> c) -> Maybe a -> c
15:46:09 <dmwit> :t maybe
15:46:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:46:52 <arkeet> :t let x `or` y = x >>= maybe y return in or
15:46:53 <lambdabot> Monad m => m (Maybe b) -> m b -> m b
15:47:23 <arkeet> this order makes more sense.
15:47:24 <zrathustra> this probably gets asked a lot, but what is the best/most maintained GUI library for FRP?
15:47:56 <monochrom> I think Yampa
15:47:56 <Adeon> what are the bad consequences of forgetting to close a file
15:48:02 <Adeon> won't the garbage collector eventually finalize the handle and close it? or was this about something else
15:48:07 <arkeet> monochrom: for gui?
15:48:10 <monochrom> "eventually"
15:48:18 <dmwit> bad consequences: other programs don't get to do as much stuff with that file
15:48:25 <Adeon> ah, I see
15:48:27 <dmwit> and even s/programs/threads/
15:48:39 <arkeet> the OS will eventually close it when your program quits, so what's the problem? :-)
15:48:49 <monochrom> heh
15:49:11 <monochrom> arkeet: for the conjunction of GUI and FRP
15:49:25 <monochrom> which is the context, as it should be
15:49:46 <arkeet> I didn't know there was a nice yampa gui solution.
15:50:22 <monochrom> well, I guess I exploit the broadness of "GUI"
15:51:14 <dmwit> I feel like Yampa is not a very maintained library, but I don't know enough to suggest an alternative that is both more maintained and also best.
15:51:25 <arkeet> I only know of reactive-banana-wx
15:51:43 <monochrom> anyway, the "file" could be a socket instead. the other side may be waiting for EOF. EOF happens when your side closes. so it is important to close promptly. -threaded plus a bit of idling closes promptly enough, covering up your bug.
15:52:30 <dmwit> Yaaaay, GHC fixes my bugs!
15:52:48 <arkeet> I wish a compiler would fix all of my bugs =(
15:53:16 <tuxit> a compiler can't read your mind, it is just a machine
15:53:26 <tippenein> I'm having troubles building this base 4.6 package? I don't see a way to configure
15:53:28 <monochrom> be careful what you wish for. if a compiler fixes all your bugs, what will your employment value be? what will your purpose of existence be?
15:54:01 <monochrom> (therefore, I understand that some programmers have incentives to not just "strictly solve problems", but also cause problems)
15:54:05 <geekosaur> ummm
15:54:09 <geekosaur> tippenein, you can't build it yourself? it's part of the compiler/runti,e
15:54:18 <dmwit> tippenein: You do not build base. You install a newer GHC.
15:54:34 <monochrom> yes, bloody get a suitable GHC version. please don't make us say the same thing 3 times.
15:55:00 <monochrom> why do people bloody make me repeat myself?
15:55:07 <dmwit> tippenein: (...which is why I said "install an older gloss" or "get a newer GHC" but not "install a newer base")
15:55:20 <tippenein> I didn't know how ghc versions equated to base versions
15:55:57 <monochrom> that is not really the point
15:56:33 <tippenein> my package manager doesn't have a recent enough ghc (as far as I can tell)
15:56:47 <arkeet> base is part of ghc.
15:57:09 <monochrom> <dmwit> Install from the GHC download page. <dmwit> Grab a binary.
15:57:11 <arkeet> maybe you'd be satisfied with an older version of gloss.
15:57:13 <monochrom> <monochrom> consider http://www.haskell.org/ghc/download
15:57:14 <hape01> GHC 7.6.3 is linked to base 4.6.0.1
15:57:19 <monochrom> did you not read those?
15:57:36 <arkeet> 1.7.7.201204.1 is the last one to support 7.4
15:58:29 <tippenein> hape01: thanks
15:58:41 <monochrom> I guess I should just go do something more worthwhile than answering and then caring whether my answers are read
15:59:07 <tippenein> monochrom: I didn't read your link because I received 5 other answers at the same time
15:59:12 <tippenein> calm down
15:59:55 <monochrom> you used none of those 5 other answers either
16:00:39 <tippenein> I did. But I used the info in the wrong way. apologies
16:00:45 <dmwit> Actually, you received 2 other answers at the same time, and one of them was also to visit haskell.org/ghc/download.
16:01:57 <tippenein> I see 4 total, but that's besides the point
16:02:08 <tippenein> thanks for the links, I've got it now
16:03:29 <timinlondon> hey!
16:03:35 <applicative> hi timinlondon
16:04:22 <timinlondon> any can answer a quick question I'm I've been knocking at this for ages but can't figure it out - wondering if I can store the result of recursive function in a list?
16:04:41 <dmwit> Sure, why not?
16:04:51 <timinlondon> coo ;)
16:04:53 <timinlondon> l
16:06:20 <timinlondon> any ideas how?
16:06:40 <dmwit> Why don't you show us what you tried that didn't work?
16:06:57 <timinlondon> well I got the recurssive list bit working
16:07:11 <timinlondon> let {fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2)}
16:07:32 * dmwit doesn't see any lists there
16:07:34 <Cale> timinlondon: Well, "store" is a bit of a funny way to put it. The result of a recursive function can *be* a list.
16:07:59 <timinlondon> yeah im getting tired
16:08:00 <applicative> timinlondon: do you mean, you want to memoize this
16:08:00 <Cale> Or I suppose the elements of a list can be the results of applying a function.
16:08:23 <timinlondon> what i mean is i want result from each time the recurrsive function and store that in a list
16:08:28 <Cale> fibs = map fib [0..]
16:08:39 <monochrom> what do you want the list to contain? show examples.
16:08:59 <dmwit> monochrom++
16:09:23 <timinlondon> yeah just the fibonacci sequence
16:09:48 <koala_man> timinlondon: iterate?
16:09:53 <Cale> > let fib
16:09:54 <lambdabot>   <hint>:1:8:
16:09:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
16:09:57 <Cale> oops
16:10:12 <Cale> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2) in take 10 $ map fib [0..]
16:10:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:10:21 <Cale> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2) in map fib [0..]
16:10:24 <lambdabot>   mueval-core: Time limit exceeded
16:10:25 <timinlondon> oh cool
16:10:25 <hape01> > let h = 1:h
16:10:26 <lambdabot>   not an expression: `let h = 1:h'
16:10:29 <Cale> ... might be too slow for that :)
16:10:31 <hape01> > h = 1:h
16:10:32 <lambdabot>   <hint>:1:3: parse error on input `='
16:10:41 <notasi> > let fib = (1:1:zipWith (+) fib (tail fib)) in take 10 fib
16:10:42 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:10:43 <lambdabot>   can't find file: L.hs
16:10:43 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
16:10:47 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:10:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:10:52 <applicative> > let h = 1:h in h
16:10:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:11:00 <hape01> applicative:   :-)
16:11:26 <Rembane> :D
16:11:35 <hape01> > let h = 1:h in take 5 h
16:11:36 <lambdabot>   [1,1,1,1,1]
16:11:55 <notasi> > take 10 [1,1..]
16:11:56 <hape01> > let h = 1:h in reverse $ take 5 h
16:11:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
16:11:57 <lambdabot>   [1,1,1,1,1]
16:12:28 <notasi> take 7 $ (reverse . reverse) [1..]
16:12:30 <timinlondon> this was great btw just what i was looking for
16:12:31 <yitz> > fix $ (0:) . (1:) . (zipWith (+) <*> tail)
16:12:31 <notasi> > take 7 $ (reverse . reverse) [1..]
16:12:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:12:35 <lambdabot>   mueval-core: Time limit exceeded
16:12:45 <hape01> :-)
16:23:05 <S_J> :t either
16:23:06 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:25:30 <S_J> > let mapEither _ _ [] = []; mapEither f g xs = f x : mapEither g f xs; in mapEither (+1) (*-1) [1..10]
16:25:31 <lambdabot>   Not in scope: `*-'
16:25:31 <lambdabot>  Perhaps you meant one of these:
16:25:31 <lambdabot>    `-' (imported from P...
16:25:42 <S_J> > let mapEither _ _ [] = []; mapEither f g xs = f x : mapEither g f xs; in mapEither (+1) (*(-1)) [1..10]
16:25:43 <lambdabot>   [x + 1,x * negate 1,x + 1,x * negate 1,x + 1,x * negate 1,x + 1,x * negate ...
16:26:10 <S_J> > let mapEither _ _ [] = []; mapEither f g (x:xs) = f x : mapEither g f xs; in mapEither (+1) (*(-1)) [1..10]
16:26:11 <lambdabot>   [2,-2,4,-4,6,-6,8,-8,10,-10]
16:26:20 <c_wraith> Where's the Either?
16:26:23 <S_J> > let mapEither _ _ [] = []; mapEither f g (x:xs) = f x : mapEither g f xs; in mapEither id (*(-1)) [1..10]
16:26:24 <lambdabot>   [1,-2,3,-4,5,-6,7,-8,9,-10]
16:26:37 <S_J> > let mapEither _ _ [] = []; mapEither f g (x:xs) = f x : mapEither g f xs; in mapEither id (*(-1)) [1..9]
16:26:38 <lambdabot>   [1,-2,3,-4,5,-6,7,-8,9]
16:27:28 <Hafydd> That name is a bit misleading, since it has nothing to do with Either.
16:27:52 <ReinH> hai
16:28:18 <applicative> hey ReinH
16:28:25 <ReinH> applicative: <3
16:29:24 <quchen> S_J: `either` is the deconstructor for `Either`. You can picture `either f g` as replacing every Left it encounters with f, and every Right with g.
16:29:29 <applicative> can I build criterion benchmarks with -threaded and so on?
16:30:13 <ReinH> Why not:
16:30:20 <ReinH> > zipWith ($) (cycle [id, (*(-1))]) [1,2,3,4] -- S_J
16:30:20 <lambdabot>   [1,-2,3,-4]
16:30:27 <ReinH> zipWith ($) is fun
16:30:59 <FreeFull> I prefer negate over (*(-1)) although it is longer by one character
16:31:08 <ReinH> FreeFull: sure :)
16:31:09 <FreeFull> Actually, it isn't even longer
16:31:26 <ReinH> ok, please replace all instances of the former with the latter and reevaluate :p
16:31:41 <FreeFull> > length "negate" - length "(*(-1))"
16:31:42 <lambdabot>   -1
16:31:52 <ReinH> FreeFull: I prefer it because it's easier to read
16:32:05 <FreeFull> ReinH: Shorter and easier to read
16:32:06 <ReinH> character count is not a very important part of my heuristic
16:32:14 <ReinH> but easier to read is a good reason
16:32:37 <FreeFull> On the other hand, I'd rather have (+1) over succ
16:33:00 <FreeFull> Ignoring that the types are different
16:33:06 <ReinH> aanyway, the point is let mapEither f g = zipWith ($) (cycle [f,g])
16:33:14 <ReinH> now you just need a better name than mapEither
16:33:31 <FreeFull> mapAlternating
16:33:34 <ReinH> sure
16:33:36 <ReinH> works for me
16:34:07 <ReinH> also you can generalize: mapAlternating fs = zipWith ($) (cycle fs)
16:34:20 <c_wraith> mapCyclic?
16:34:27 <FreeFull> zipWith ($) is the same as ap I think
16:34:38 <ReinH> which is then mapCyclic = zipWith id . cycle
16:34:42 <ReinH> which is rather elegant imo
16:34:44 <c_wraith> FreeFull: Not for normal lists
16:34:56 <FreeFull> c_wraith: Ah, right
16:34:59 <FreeFull> Only for ZipLists
16:35:02 <c_wraith> yep
16:35:17 <S_J> are natural number s implemented i haskell?
16:35:55 <tabemann> dammit... so much for debian testing having GHC 7.6.3 yet - it turns out debian *unstable* has it, but debian testing is still on 7.4.1
16:35:58 <applicative> every few minutes S_J
16:36:06 <FreeFull> You can define your own naturals and there is probably a bunch of libraries for it
16:36:13 <tabemann> there are libraries for it
16:36:26 <tabemann> even though to have naturals all you need is data Natural = Z | S Natural
16:36:40 <ReinH> e.g. http://hackage.haskell.org/packages/archive/nat/0.2/doc/html/Data-Number-Nat.html
16:36:41 <applicative> data N = Z | S N is shorter
16:37:11 <geekosaur> "Chartreuse!" "Burnt orange!" "Lime green!"
16:37:24 <applicative> S_J: but they are implemented in base, *at the type level* ...
16:37:34 <Hafydd> data Chartreuse = BurntOrange | LimeGreen Chartreuse
16:38:14 <tabemann> they really want (GHC) Haskell to be a dependently typed language, don't they
16:38:21 <FreeFull> applicative: You can do    data Z = Z; data S n = S n;   and then the naturals will have the same type as their value
16:38:30 <applicative> instance Num Chartreuse where ...
16:38:48 <ReinH> applicative: that is bad and you should feel bad :p
16:39:24 <monochrom> tabemann: consider http://www.haskell.org/ghc/download_ghc_7_6_3
16:39:48 <applicative> fromInteger 0 = BurntOrange ; fromInteger n = LimeGreen (fromInteger (n-1))
16:40:03 <tabemann> sigh - I want to keep on using Debian packages, because mixing the Debian world with outside-downloaded-and-installed code is painful
16:40:06 <S_J> In the natural bubers: what is 0-1?
16:40:24 <tabemann> e.g. Debian upgrades can update libraries that outside code needs and break them
16:40:56 <applicative> S_J: it's fix LimeGreen of course
16:41:15 <monochrom> well, then consider Ubuntu, which seems more stable than Debian stable
16:41:31 <flux0r> S_J: (BurntOrange, LimeGreen BurntOrange)
16:41:42 <Hafydd> instance bub Chartreuse where ...
16:41:49 <tabemann> Ubuntu means 1) reinstalling the OS on my machine and 2) having to deal with stuff like Unity and Wayland or whatever-the-fuck it is now
16:41:58 <FreeFull> applicative: With that implementations, all negative numbers are infinity
16:42:13 <tabemann> I'll take fluxbox and x.org thank you
16:42:23 <FreeFull> I use xmonad
16:42:27 <FreeFull> That is the haskell way
16:42:35 <Demos> xmonad is pretty frekin sweet
16:42:44 <Peaker> I wanted to use xmonad, but couldn't get it to stop focus thieves
16:42:51 <Peaker> and focus stealing drove me nuts
16:42:54 <Adeon> I'm jealous of xmonad users who have long configuration files
16:42:58 <Adeon> mine is puny
16:42:59 <Hafydd> "infinity"? I think you mean _|_.
16:43:07 <tabemann> I've been using basically the same fluxbox setup for most of the last decade...
16:43:12 <monochrom> one day, a friend using Debian stable said, "just did apt-get upgrade and things broke". I said, "Debian stable is supposed to be robust, no? I do that all the time to Ubuntu and nothing happens". she replied, "yeah, Debian is well-known for this"
16:43:16 <Demos> although it was crashing whenever I touched the screen with xinerama, but that was likely just xinerama and the touch screen drivers interacting
16:43:17 <Peaker> Hafydd, infinity = S infinity ; and is not bottom
16:43:41 <tabemann> Debian stable is too painfully conservative to use to boot
16:43:42 <Peaker> and I hate the xmonad config API -- twiddling 3 record fields to add some extension is a terrible API
16:43:47 <Demos> actually I am using KDE on arch atm
16:43:51 <Demos> kde is getting better fast
16:43:58 <FreeFull> It's not bottom because you continuously get constructors
16:44:07 <Hafydd> Evaluating fromInteger (-1) will give _|_.
16:44:15 <FreeFull> Hafydd: Nope
16:44:23 <dmj`> > fromInteger (-1) == undefined
16:44:23 <pentace> But it should be bottom
16:44:24 <lambdabot>   *Exception: Prelude.undefined
16:44:32 <FreeFull> It's like an infinite list
16:44:35 <Peaker> Hafydd, case _|_ of <any constructor at all> -> ... should always yield _|_.  If it doesn't, it isn't bottom
16:44:35 <Hafydd> undefined is _|_!
16:44:40 <FreeFull> Or are infinite lists bottoms to you too?
16:44:54 <tabemann> Demos: I... just don't like desktop environments
16:44:57 <monochrom> S ⊥ ≠ ⊥ because S is non-strict
16:45:13 <Peaker> Hafydd, infinity = S infinity ;   case infinity of S _ -> "Not bottom!"   will evaluate to "Not bottom!"
16:45:47 <FreeFull> Hafydd: Haskell allows you to make something like   data Stream a = Cons a (Stream a)
16:45:48 <monochrom> therefore, the limit S (S (S ...)) is non-trivial
16:45:54 <Peaker> tabemann, you mean stuff like task-bars, pagers, app menus?
16:45:54 <Demos> tabemann, yeah, I know the feeling and linux is a little backward in the desktop environment area
16:46:17 <Peaker> tabemann, or a desktop-icons app thing?
16:46:32 <FreeFull> @let data N = Z | S N deriving (Show, Eq, Enum)
16:46:33 <lambdabot>  .L.hs:142:28:
16:46:33 <lambdabot>      Can't make a derived instance of `Enum N':
16:46:33 <lambdabot>        `N' mus...
16:46:39 <FreeFull> @let data N = Z | S N deriving (Show, Eq)
16:46:40 <lambdabot>  Defined.
16:46:44 <tabemann> Peaker: everything, except a little window-bar at the bottom of my screen, and a pane that pops out on the right side that displays gkrellm when I move my cursor all the way to the right
16:46:45 <Hafydd> Oh, excuse me; I did misapprehend something.
16:46:48 <monochrom> tabemann: consider Ubuntu Server :)
16:47:17 <FreeFull> > let infinity = S infinity in case infinity of S _ -> "Not bottom!"
16:47:20 <lambdabot>   mueval-core: Time limit exceeded
16:47:25 <FreeFull> > let infinity = S infinity in case infinity of S _ -> "Not bottom!"
16:47:28 <monochrom> actually, you may like xubuntu
16:47:29 <lambdabot>   mueval-core: Time limit exceeded
16:47:32 <FreeFull> Dammit lambdabot
16:47:56 <FreeFull> It works in ghci
16:48:04 <Fuuzetsu> worksonmymachine
16:48:17 <Peaker> > 1+1
16:48:17 <lambdabot>   2
16:48:22 <FreeFull> > let infinity = S infinity in case infinity of S _ -> "Not bottom!"
16:48:25 <lambdabot>   "Not bottom!"
16:48:29 <FreeFull> There we go
16:48:36 <satc> @hoogle Maybe a -> (a -> IO b) -> Maybe b
16:48:37 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
16:48:37 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:48:37 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
16:48:43 <tabemann> aside from conservativeness, the thing that *does* piss me off about debian is that in their efforts to be free-software-purity-purity-pure, they do shit like not including network driver firmware in their on-disk distribution, that results in major catch-22s when trying to actually install!
16:48:46 <FreeFull> > let infinity = S infinity in infinity
16:48:49 <lambdabot>   S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (...
16:49:04 <satc> @hoogle (a -> IO b) -> Maybe a -> Maybe b
16:49:04 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:49:04 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
16:49:04 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:49:17 <tabemann> well, they may have reversed themselves on that
16:49:23 <satc> @hoogle (a -> IO b) -> Maybe a -> IO (Maybe b)
16:49:24 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:49:24 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
16:49:24 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:49:36 <Fuuzetsu> tabemann: funnily enough, it's not listed on the GNU endorsed list of distros because it makes installing non-free packages easy
16:50:02 <tabemann> as the latest time I installed Debian I didn't run into that problem, but the time before I did... but after my latest apt-get upgrade it told me my firmware *wasn't installed even though it was installed before*, and I had to manually install it
16:50:03 <joelteon> :t S
16:50:04 <lambdabot> N -> N
16:50:10 <joelteon> :t N
16:50:10 <lambdabot> Not in scope: data constructor `N'
16:50:18 <Peaker> tabemann, that catch-22 may be a good thing -- encouraging buying of less shitty hardware :)
16:50:39 <FreeFull> joelteon: data N = Z | S N deriving (Show, Eq)
16:51:00 <applicative> :t Z
16:51:01 <lambdabot> N
16:51:03 <Peaker> tabemann, equating non-free software with difficult-to-use software is nice when your goal is discouraging non-free software (and you have more benefits than drawbacks in general)
16:51:10 <tabemann> but when you're buying motherboards on newegg, you don't necessarily know ahead of time the *exact* networking chipset used, and whether that chipset has firmwere dubbed non-free by Debian!
16:51:39 <FreeFull> I use Arch
16:51:43 <FreeFull> Everything is up to date
16:51:46 <Peaker> tabemann, surely there are some compatibility lists
16:51:49 <Demos> strangely I find FOSS drivers to be of average higher quality than closed ones
16:51:55 <Demos> if they exist
16:52:02 <tabemann> if anything I'm concerned far more by Microsoft's efforts to try to lock Linux out of machines coming with Windows than by whether my network drivers are free or not
16:52:06 <FreeFull> Propertiary software isn't put in second place just because it is propertiary
16:52:10 <Demos> and if the driver in question is not for a printer
16:52:31 <applicative> everything's up to date in arch, the Kansas City of linux distributions
16:52:31 <Peaker> Demos, hardware drivers developed by software enthusiasts tends to be better than drivers developed by 9-to-5 drones who hate their driver-writing jobs :P
16:52:35 <FreeFull> Demos: The FOSS drivers for my graphics chip have slower 3D
16:52:43 <Demos> tabemann, well secureboot is "supposedly" to prevent hypervisor malware, but if you mawnage to get a hypervisor virus you are screwed anyways
16:52:45 <FreeFull> Definitely less crashy though
16:52:55 <tabemann> Peaker: the part of the drivers that isn't free is the firmware itself that is loaded onto the chip
16:53:22 <monochrom> look what I started :)
16:53:22 <tabemann> it's not the Linux-side drivers
16:53:46 <monochrom> I have a cunning plan! I know how to get us out of this...
16:54:09 <tabemann> Demos: of course it is supposed to help us...
16:54:31 <monochrom> tabemann: consider using a virtual machine to run a more robust linux distro and GHC :)
16:54:40 <Demos> yeah, my cell phone has secureboot, I think someone cracked it, but there are other issues
16:54:50 <tabemann> FreeFull: but what do you gain out of making it hard to use proprietary firmware except making things *very* difficult for users in some situations
16:55:02 <tabemann> specifically with network chipset firmware
16:55:19 <Demos> tabemann, if you are a hardened/verified distro than I could see it
16:55:41 * applicative hadn't realized tabemann was a distro at all
16:55:50 <tabemann> i.e. if you have only one machine one can freely use, and one installs Debian on it, but it happens to not have the firmware for your networking chipset, you're basically fucked
16:56:09 <monochrom> tabemann isn't a distro. look at the "if" there :)
16:56:41 <tabemann> monochrom: then I have to basically manage *two*, nested machines...
16:56:47 <monochrom> if monochrom is a windows version, then the king of france is bald
16:57:05 <tabemann> and install everything from ground up in the VM to get it into a usable state
16:57:06 <monochrom> oh, you already use a virtual machine? neat
16:57:16 <tabemann> no, I don't use a VM except at work
16:57:21 <Hafydd> Do you know that the King of France is not bald?
16:57:34 <monochrom> I don't know
16:57:47 <monochrom> but I know what I know
16:58:05 <Hafydd> And you know what you know about what you know, apparently.
16:58:19 <Adeon> know all the things except the things that you don't
16:58:50 <applicative> monochrom: http://en.wikipedia.org/wiki/Louis_Alphonse,_Duke_of_Anjou his hair looks fabulous
16:58:51 <shachaf> monochrom: What does a windows version know?
17:05:02 <monochrom> I know everything known to everyone who know everything I know
17:05:23 <monochrom> (look for a Galois adjunction there!)
17:08:05 <tabemann> pthread question that probably isn't appropriate for this channel:
17:08:22 <tabemann> what happens if you pthread_mutex_lock a mutex in one thread and pthread_mutex_unlock it in another?
17:08:38 <tabemann> for a normal, i.e. not recursive, mutex
17:08:44 <shachaf> Is it related to Haskell?
17:08:58 <tabemann> I'm writing a test in C to compare with code I've already written in Haskell
17:09:48 <troydm> tabemann: that's a bug
17:10:10 <troydm> tabemann: considered bug, innapropriate use of mutex
17:10:34 <troydm> tabemann: you can't unlock a mutex in a thread which hasn't previously locked it
17:10:40 <tabemann> what I really want is a maximum-one semaphore, actually, but pthreads doesn't provide those
17:12:12 <dcoutts_> tabemann: can't you just make a semaphore with an initial count of 1?
17:12:32 <tabemann> (this was easy to do in Haskell, with MVars and, in STM, with TMVars, and to do in Java, with BlockingQueues and, with Multiverse STM, with TxnQueues with a maximum of 1
17:13:58 <tabemann> the problem with a normal semaphore, though, is that it doesn't block if the number is smaller than zero *or* greater than one
17:14:17 <tabemann> s/greater than/is
17:16:28 <dcoutts_> I didn't think you could get it below zero, isn't that kind of the point?
17:17:38 <tabemann> I mistated that slightly
17:17:55 <tabemann> what i mean is I basically need a semaphore that blocks on decrementing if zero and that blocks on incrementing if one
17:18:27 <FreeFull> Maybe you should forget writing concurrent things in C
17:19:03 <tabemann> FreeFull: what I'm doing is trying to measure the thread-switching latency based on a producer and consumer thread sharing a construct equivalent to an MVar
17:19:28 * tabemann used to work on *big* programs that were highly concurrent in C++... and the code had major problems...
17:19:49 <dcoutts_> tabemann: well, that'll be fun, it's a totally unfair test :-)
17:19:57 <tabemann> (I seriously considered just rewriting the whole damn thing based on an event-based model, but there was too much code that would have been totally rewritten)
17:20:13 <tabemann> dcoutts: I know it's unfair :)
17:20:16 <dcoutts_> :-)
17:20:18 <Demos> tabemann, +1 for synchronized events
17:21:31 <dcoutts_> tabemann: glad to hear you like MVars, they're a very nice way of packaging classic locks/mutexes protecting a var
17:21:36 <tabemann> the reason why I'm doing this is we basically had this very situation in our code on the big project I worked on at NASA, and it turned out to be a horrible horrible performance bottleneck
17:22:04 <tabemann> dcoutts_: actually, my Haskell test was using TMVars, but in my Java tests I used both STM and lock-based versions
17:23:15 <dcoutts_> tabemann: so this is fine of course unless you want lots of real parallelism, then you inevitably have cross-core communication and not just scheduling lightweight threads on one core
17:23:16 <tabemann> in the NASA code it was actually pairs of threads sharing buffers, but because each thread took items off and put items on the buffers one-by-one, in practice it turned out like they were just sharing MVars
17:23:57 <tabemann> IIRC we ran into a performance bottleneck where we really couldn't push the system beyond 500 put-take pairs per second
17:24:29 <tabemann> dcoutts_: it is a pathological case, yes
17:24:46 <dcoutts_> tabemann: you see what I mean right? you can get loads of lightweight thread switches so long as you're happy with running those threads on the same core
17:24:57 <tabemann> producer/consumer pairs doing blocking operations over a construct functionally equivalent to an MVar means practically no parallelism
17:25:05 <dcoutts_> once you have them running on different cores to get some parallelism, then you're back to the same issue
17:25:24 <tabemann> dcoutts_: I already noticed that my Haskell test ran far better with +RTS -N1 than with +RTS -N2
17:25:34 <dcoutts_> right
17:26:28 <dmwit> Whoa, cool distinction. Not one I'd think about.
17:26:39 <tabemann> what the C++ code *should* have done is had the producer fill a buffer one by one, and the consumer empty the *entire* buffer all at once, but changing our code to do this effectively would have required changing *many* modules individually
17:26:41 <dmwit> Maybe I'm glad I didn't know enough to think about that. =P
17:26:57 <dcoutts_> tabemann: right
17:27:19 * dcoutts_ was just looking at the man page for semop and discovers they're much more complicated than he though semaphores were
17:28:28 <tabemann> dmwit: I didn't really realize this before last night, and it does have significant implications for code that is A) highly concurrent but B) not parallel at all, with heavy interthread communication and blocking
17:31:08 <tabemann> dcoutts_: I was looking at the semaphores in semaphore.h, and they certainly were much simpler than this
17:33:28 <tabemann> that semop call seems like it is a rather clunky way of doing what should really be done with STM, with TVars and retry
17:33:57 <markstos> Hello, I'm having trouble getting darcs to build with 'cabal', and I think the issue I'm having has more to do with 'cabal' than darcs, so I hope this is an appropriate place to ask for help. The error I'm getting is "setup: Most RTS options are disabled. Link with -rtsopts to enable them.", but I don't know how to "Link with -rtsopts". I'm not a Haskell dev-- I don't get much beyond "cabal install". Thanks!
17:34:11 <tabemann> except that STM only works within a single process
17:34:31 <dcoutts_> tabemann: ah, semop is the SysV semaphores, the posix ones are simpler
17:34:38 <markstos> A bit more detail i is here, including my exact command run, and the GHC version: http://bugs.darcs.net/issue2337
17:35:09 <dcoutts_> tabemann: see man sem_open or sem_wait or man sem_overview
17:35:57 <lingxiao> hey guys, how do I generate a list of () of length n?
17:36:09 <tabemann> dcoutts_: yeah, I was reading about POSIX semaphores before, and they seemed too simple to do what I wanted them to do... but SysV semaphores, for their being more complex, still don't seem like they'll do what I need
17:36:14 <lingxiao> ie `gen 3 () = [(),(),()]`
17:36:32 <lingxiao> sorry to pollute the channel with such a basic question
17:36:36 <tabemann> oh I thought of it!
17:37:03 <lingxiao> wait NO NVM!
17:37:06 <lingxiao> hoogled it...
17:37:13 <lingxiao> sorry..
17:37:26 <dcoutts_> tabemann: so actually you've noticed an interesting point which I've seen before, but it's not often highlighted, which is that MVars give you more than a mutex, because an MVar can block in both "directions", where as a mutex can only do so in one "direction"
17:37:28 <tabemann> no, that won't work
17:37:44 <dcoutts_> tabemann: so I think you actually need two to emulate an MVar
17:38:02 <tabemann> I was just thinking of using two
17:38:41 <tabemann> hmm
17:39:03 <Eridius> hmm, why the heck does Haskell pass `-x c` when running the preprocessor? It's not C code
17:39:09 <Eridius> and without that, clang's cpp doesn't throw those errors
17:39:33 <dcoutts_> Eridius: probably to persuade gcc's cpp to do what we wanted
17:40:07 <cdk> > replicate 3 () -- lingxiao
17:40:08 <lambdabot>   [(),(),()]
17:40:10 <tabemann> the hard part is to make an implementation that avoids missed wakeups (if condition variables are used), one thread being able to "skip ahead" if the other thread isn't scheduled immediately, and of course deadlock
17:40:10 <applicative> markstos: is this the result of 'cabal install darcs' ?
17:40:41 <markstos> I'm getting help now in #darcs  @applicative. I think they may have solved it there.
17:40:52 <lingxiao> cdk : thanks :) ! I don't know why I didn't just hoogle it to begin with
17:41:30 <tabemann> this is why asking whether two different threads can lock and unlock the same mutex before, because then the two-mutex solution becomes trivial
17:42:05 <applicative> markstos: ah i see; there is a -threaded option that defaults to true i see
17:42:17 <dcoutts_> tabemann: there's a number of interesting variations on the producer/consumer stuff you can do with MVars or STM, with different capabilities and different performance characteristics for multiple producer, or multiple consumer etc
17:43:05 <tabemann> oh just thought of a solution
17:43:15 <tabemann> two different threads share a single mutex and a single condition variable
17:43:25 <tabemann> no that won't work
17:43:42 <dcoutts_> tabemann: that sounds like a solution that Simon Marlow told me works, but I don't recall the exact details
17:44:16 <tabemann> the problem with that solution is that there will be gaps where each thread can signal the condition but the other thread won't be waiting yet
17:44:39 <tabemann> wait
17:45:04 <tabemann> only one thread can actually hold the mutex, so the other thread *must* be waiting at that time
17:45:13 <tabemann> no that won't work
17:45:30 <tabemann> because after signaling the condition you need to let go of the mutex momentarily to allow the other thread to wake up
17:45:32 <tabemann> and that provides a gap
17:46:36 <tabemann> hmm that might work for a *triangle* of threads
17:47:09 <tabemann> no that won't work either
17:47:16 <tabemann> (don't mind my rambling)
17:47:53 <markstos> applicative: My problem was that I had set 'GHCRTS=' to a value in my .bashrc, which I need for darcs. but 'cabal' was responding to the environment variable as well, and dying with a diagnostic that I didn't undestand was related. The solution was to prefix my 'cabal' command with: GHCRTS=
17:48:00 <tabemann> damn even simple concurrency problems are hard when all you have are locks (and variations thereupon, i.e. r-w locks and simple semaphores) and condition variables
17:48:33 <dcoutts_> tabemann: we're spoiled here :-)
17:48:54 <tabemann> even Java concurrency is much nicer, as they give you things like blocking queues and whatnot
17:49:39 <tabemann> okay, this might be a solution
17:49:46 <tabemann> there are two locks, and two condition variables
17:49:46 <dcoutts_> right, and an MVar is a 1-place blocking queue
17:50:46 <tabemann> each thread is either having one mutex locked or is waiting on it, and it when it is not waiting for it locking the other mutex, signaling the matching condition variable, and then unlocking it
17:50:57 <tabemann> and vice versa
17:51:56 <tabemann> this solution works because it forces each condition variable to be signaled only when the other thread is waiting on it (as otherwise the other thread would have the corresponding mutex locked, and waiting on a condition variable and releasing the corresponding mutex is an atomic operation)
17:54:47 * hackagebot kevin 0.9.0 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.9.0 (JoelTaylor)
17:55:49 <tabemann> that feels... overly complex to do something so simple
17:56:00 <startling> welcome to concurrency? :)
17:56:20 <tabemann> startling: I'm getting too used to concurrency in Haskell already
18:04:28 <monochrom> I have a cunning plan!
18:05:11 <monochrom> if you want to use a haskell synchronization mechanism in C, use haskell FFI :)
18:05:16 <arkeet> shachaf has a punning clan.
18:05:28 <hpc> oooooh
18:05:39 <hpc> market the FFI as an actual concurrency library for C
18:05:42 * monochrom refuses to say "concurrency primitive" for synchronization primitive
18:05:44 <arkeet> haha
18:06:05 <shachaf> arkeet: Who's in it, other than you?
18:06:07 <arkeet> now make it work
18:06:11 <arkeet> shachaf: =(
18:06:20 <hpc> MVar in particular is a thing that needs to happen in C
18:06:58 <arkeet> if you can get threading to work!
18:08:44 <ion> FWIW, i’m going to use Haskell for exactly that in a project. ;-) I implemented reading I²C sensors in C <https://github.com/ion1/drone/tree/master/i2c-sensors> and i’ll probably implement calculations based on them in C, but i want it to run certain things in parallel, interact with gpsd, provide a trivial web server that exports information in JSON etc. All of that will be in Haskell.
18:15:44 <danharaj> edwardk: I want to think about functors FinSet -> *. They seem to be related to nested data types.
18:16:06 <edwardk> sounds fun
18:18:27 <danharaj> edwardk: Indeed. What I'm thinking is that you take a functor * -> * and then you write a nested type that encodes the relationships between (F^n a) and (F^m a).
18:19:05 <danharaj> For example, lambda terms ala nested types have Abstraction : F^(n+1) a -> F^n a, where F is Maybe.
18:20:07 <danharaj> edwardk: well not exactly but I am just spitballing right now :P
18:25:06 <tabemann> well this confirms it - pthread thread switching is *slow*:
18:25:21 <tabemann> 1000000 producer cycles too 15.621609 s (0.000016 s per cycle)
18:25:21 <tabemann> 1000000 consumer cycles too 15.621614 s (0.000016 s per cycle)
18:26:52 <tabemann> (whereas in Haskell with STM and +RTS -N1 I was getting cycle times of ~400 ns, in Java with BlockingQueues cycle times of ~5 ms, and in Java with Multiverse STM cycle times of ~8 ms)
18:26:52 <lunchtime> that's unacceptable
18:27:53 <tabemann> (this was Java on Windows on a different machine, so it might not be directly comparable)
18:28:31 <carter> hpc: i think lukexi may be slightly doing that :)
18:28:51 <tabemann> s/too/took
18:28:57 <geekosaur> pthreads are always OS threads, no? Haskell and (modern) Java are N:M
18:29:05 <tabemann> geekosaur: yeah
18:29:09 <carter> still
18:30:21 <tabemann> I wonder why anyone even uses 1:1 threads these days, as it is painfully obvious that they can't scale to many threads
18:31:04 <carter> theres probably some cases where you want partial 1:1
18:31:18 <carter> like in a system that needs constant monitoring
18:31:27 <carter> or some sort of hard real time piece?
18:31:30 <carter> idk
18:31:57 <tabemann> that's only when you want to take advantage of hard real time capabilities that are provided by a kernel
18:32:21 <tabemann> otherwise the only reason to have (in Haskell terminology) bound threads is shitty APIs that force you to keep everything in one thread due to per-thread state
18:32:57 <tabemann> per-*OS* thread state, I mean
18:33:03 <carter> so : probaby not :)
18:34:08 <tabemann> okay, gonna go eat now
18:37:17 <tabemann> wait
18:37:32 <tabemann> above when I said "ms" I really meant "us" - but that should have been obvious
18:39:14 <carter> for which ?
18:39:18 <carter> oh
18:39:28 <carter> jvm \mu rather than m
18:39:31 <carter> µ
18:42:22 <Polarina> Anyone has any experience mixing STM and FRP somehow? Pondering here...
18:44:12 <carter> they're different things...
18:44:17 <carter> you could check out Pipes STM
18:44:20 <carter> might be slightly relevant
18:45:30 <Polarina> I was more of thinking of using STM and FRP at the same time. Maybe that's just nonsensical. I at least can't think of a use case myself.
18:45:39 <Polarina> carter, I'll take a look at that, thanks.
18:45:59 <carter> theyre' sort of orthogonal things
18:46:03 <carter> you can use them together
18:46:12 <carter> but….
18:46:14 <carter> idk
18:47:23 <Polarina> Of course we "can", we are all keyboard-bound maniacs after all.
18:54:16 <MouseTheLuckyDog> Anyone here familir with Baker's META for "pragmatic parsing"?
18:55:47 <startling> MouseTheLuckyDog: I know a little about OMETA, which I think might be inspired by it. what's up?
18:56:05 <startling> in my experience, parser combinators turn out much nicer.
19:00:42 <MouseTheLuckyDog> I don't think it is. I could never figure out Baker's paper but there was a version written for Dylan which seemed readable. I'm just curious how it compares to combinaters.
19:10:17 <udevd> hi, i'm having problems with splitting infinite list by every k elements
19:10:39 <udevd> http://hastebin.com/bebowasika.coffee it's how my current code looks life
19:11:05 <arkeet> you can't take the length of an infinite list.
19:11:14 <udevd> but apparently for infinite lists computation does not stop when i do for example > take 10 . splitByN 10 [1..]
19:11:28 <udevd> hm
19:11:34 <udevd> this makes sense
19:11:38 <startling> > length [1..] -- udevd
19:11:42 <lambdabot>   mueval-core: Time limit exceeded
19:11:53 <udevd> okay
19:11:55 <udevd> thanks :)
19:12:13 <arkeet> btw, the length == k case isn't needed. ;)
19:12:24 <arkeet> wait.
19:12:27 <arkeet> yeah.
19:12:33 <udevd> without it it generates [] at the end
19:12:46 <udevd> when k divides length
19:12:54 <udevd> but hm
19:13:00 <arkeet> well maybe your [] case is wrong then ;)
19:13:14 <cschneid> can a normal bytestring store utf characters? specifically, I'm looking at a bit of code that uses overloadedstrings, and just imports Data.ByteString. Do any chars I want go in those?
19:13:20 <arkeet> cschneid: bytestrings store bytes.
19:13:41 <udevd> is there a way to check if list is finite? i know it's not in almost all cases, but perhaps haskell knows that list has been made to be infinite
19:13:42 <cschneid> arkeet: sure. But many libraries (snap is what I'm looking at) use them as strings
19:13:50 <arkeet> I hope not!
19:13:52 <dmwit> udevd: No, there isn't.
19:14:00 <startling> udevd, there's a way to check if it's finite, but it only terminates if it's finite. :)
19:14:15 <udevd> startling: i supposed i will get such answer
19:14:15 <udevd> xD
19:14:20 <ReinH> hai folks
19:14:32 <startling> > let isFinite [] = True; isFinite (c:cs) = isFinite cs; isFinite [1, 2, 3]
19:14:33 <lambdabot>   <hint>:1:74:
19:14:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
19:14:39 <ReinH> Can someone suggest a refactor for this do block? https://gist.github.com/reinh/d0a67107b9d0f7172b34
19:14:58 <arkeet> udevd: what if you splitAt no matter what, and see whether the second list is empty?
19:15:14 <udevd> yeah, this is what i came up to now
19:15:49 <udevd> i just didn't realized that it computes length :D
19:15:55 <arkeet> =)
19:16:08 <startling> ReinH: U <$> liftM randoms newStdGen <*> (randomIO :: IO Bool) <*> liftM randoms newStdGen
19:16:12 <arkeet> there's another way to make it work using a different length function and lazy naturals...
19:16:18 <ReinH> startling: oh yeah ofc
19:16:21 <dmwit> udevd: Alternately, use genericLength and lazy naturals.
19:16:25 <dmwit> oh arkeet
19:16:27 <startling> ReinH: (you need to import Control.Applicative)
19:16:28 <arkeet> =)
19:16:28 <dmwit> you clever dog
19:16:31 <ReinH> startling: indeed
19:16:41 <arkeet> protip: [()] is lazy naturals.
19:16:52 <arkeet> and length is void.
19:17:20 <dmwit> ReinH: Why not (ls, x, rs) <- randomIO; return (U ls x rs)?
19:17:27 <arkeet> (and fromInteger = (`replicate` ()) )
19:17:38 <arkeet> :t replicate
19:17:38 <dmwit> err
19:17:39 <lambdabot> Int -> a -> [a]
19:17:43 <arkeet> oh, that takes an Int.
19:17:43 <arkeet> =(
19:17:45 <dmwit> ReinH: Ignore me.
19:17:48 <ReinH> startling: having fun with comonadic cellular automata, Sierpinski triangles, and rule 90
19:17:51 <ReinH> dmwit: ... ok :)
19:18:04 <dmwit> ReinH: But you really shouldn't make fresh StdGen's that way. You might like "split" instead.
19:18:15 <udevd> okay, it works
19:18:17 <udevd> thanks :)
19:18:17 <arkeet> :t randoms
19:18:18 <lambdabot> (RandomGen g, Random a) => g -> [a]
19:18:20 <ReinH> dmwit: yeah I figured I would use split at some point
19:18:25 <startling> ReinH: have you seen that one article on the "A Neighborhood of Infinity" blog?
19:18:32 <ReinH> startling: oh yes.
19:18:45 <arkeet> dmwit: I just understood why your thing wouldn't work. =)
19:18:56 <startling> ReinH: thought it looked familiar. :)
19:19:24 <dmwit> ReinH: You can do it without split and without newStdGen, but it becomes very easy to leak memory. =P
19:19:50 <arkeet> does it perhaps involve unsafeInterleaveIO?
19:19:51 <orzo_> anyone use cmdtheline ?
19:19:57 <dmwit> arkeet: nope, none of that
19:19:59 <arkeet> =)
19:20:01 <orzo_> i'm having a hard time with it
19:20:22 <ReinH> startling: https://gist.github.com/reinh/6eb1c81340a283032b49
19:20:29 <orzo_> the multi-command functionality is not sufficiently documented
19:20:37 <dmwit> arkeet: In fact, it can be written in the form fmap aFunctionThatWouldBeAcceptedBySafeHaskell getStdGen
19:20:47 <arkeet> sure
19:20:48 <orzo_> i'm trying to get certian positional arguments to be required fro one command but for another
19:20:51 <arkeet> I was thinking the same.
19:21:26 <arkeet> generate x first, and then interleave generating ls and rs, right?
19:21:43 <startling> ReinH: neat. I was driven to write an infinite comonadic roguelike but I never got raytracing to work right.
19:21:52 <ReinH> startling: was just thinking about that
19:22:12 <ReinH> rule 90 is the simplest non-trivial rule
19:22:20 <ReinH> it's just left xor right
19:22:24 <dmwit> arkeet: right
19:22:48 <ReinH> turns out it creates a Sierpinski triangle when you start with a single live cell
19:22:56 <startling> sure.
19:22:59 <arkeet> ah yes, that would do more work than you want if you go too far in one direction.
19:23:07 <dmwit> arkeet: right
19:23:47 <startling> ReinH: the other thing I bashed my head against was saving/loading states
19:24:17 <udevd> dmwit: and how actually genericLength would help me here?
19:24:22 <dmwit> startling: you need some observable sharing =)
19:24:35 <dmwit> Let's see what lambdabot has in scope here...
19:24:37 <dmwit> > 3 :: Nat
19:24:38 <lambdabot>   Not in scope: type constructor or class `Nat'
19:24:51 <dmwit> > 3 :: Natural
19:24:51 <ReinH> which is pretty cool
19:24:52 <lambdabot>   3
19:24:53 <startling> dmwit, what do you mean?
19:24:57 <dmwit> eeeeexcellent
19:24:58 <udevd> i have ghci just terminal to the left, so
19:25:02 <udevd> okay
19:25:03 <udevd> :3
19:25:04 <Hafydd> > (-1) :: Natural
19:25:04 <lambdabot>   *Exception: Natural: (-)
19:25:06 <ReinH> startling: probably kind of hard in an infinite universe...
19:25:07 <dmwit> > genericLength [1..] > (3 :: Natural)
19:25:08 <lambdabot>   True
19:25:14 <dmwit> udevd: Look, it magically returned!
19:25:21 <udevd> dmwit: how does it compute it?
19:25:24 <dmwit> > genericLength [1..] < (5 :: Natural)
19:25:25 <lambdabot>   False
19:25:31 <arkeet> udevd: the trick is in the Natural type.
19:25:38 <shachaf> Lazy naturals are the only justification for genericLength.
19:25:55 <startling> > genericLength [1..] < genericLength [2..]
19:25:56 <lambdabot>   *Exception: stack overflow
19:25:57 <dmwit> udevd: Think of "Natural" as being "[()]". "genericLength = map (const ())", and "(<)" just walks the spine to see which one kicks up a [] first
19:26:13 <dmwit> shachaf: pretty much, yup =)
19:26:32 <shachaf> If you're not using Nat, it's so inefficient that you should just not use it.
19:26:34 <startling> udevd, think about it this way: if you have two lists and at least one is finite, you can easily figure out which is shorter
19:26:42 <udevd> dmwit: it's the pseudo-von Neumann natural number model?
19:26:43 <dmwit> udevd: Since 5 = [(), (), (), (), ()] kicks up a [] pretty fast and [1..] never does, well, it can tell which one is shorter
19:26:45 <shachaf> > genericLength ['\0'..] :: Int
19:26:46 <lambdabot>   *Exception: stack overflow
19:26:51 <arkeet> @instance Num [()] where fromInteger x = replicate (fromInteger x) (); (+) = (++); (-) = (\\); (*) = liftA2 (\x y->()); abs = id; signum = take 1
19:26:51 <lambdabot> Maybe you meant: instances instances-importing
19:26:55 <dmwit> udevd: It's Peano numerals.
19:26:55 <arkeet> @let instance Num [()] where fromInteger x = replicate (fromInteger x) (); (+) = (++); (-) = (\\); (*) = liftA2 (\x y->()); abs = id; signum = take 1
19:26:56 <lambdabot>  Defined.
19:26:58 <udevd> okay
19:26:59 <arkeet> > 5 :: [()]
19:27:02 <lambdabot>   [(),(),(),(),()]
19:27:17 <arkeet> > genericLength [1..] :: [()]
19:27:20 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
19:27:21 <dmwit> arkeet: ...oh cute
19:27:52 <udevd> thanks :)
19:27:58 <arkeet> :t genericReplicate
19:27:59 <lambdabot> Integral i => i -> a -> [a]
19:28:03 <arkeet> I could have used that.
19:28:06 <arkeet> oh well.
19:28:08 <startling> @check \x -> genericLength (x :: [()]) == x
19:28:11 <lambdabot>   +++ OK, passed 100 tests.
19:28:57 <arkeet> > 2 * 3 :: [()]
19:29:00 <lambdabot>   [(),(),(),(),(),()]
19:29:11 <arkeet> @let inf = repeat ()
19:29:12 <lambdabot>  Defined.
19:29:14 <arkeet> > inf * 0
19:29:18 <lambdabot>   mueval-core: Time limit exceeded
19:29:19 <arkeet> heh.
19:29:20 <arkeet> > 0 * inf
19:29:23 <lambdabot>   []
19:29:26 <dmwit> arkeet: (*) = (>>) is more clever
19:29:31 <arkeet> oh I could have done that.
19:29:32 <dmwit> > 2 >> 3
19:29:33 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
19:29:33 <lambdabot>    arising from the ambiguity check f...
19:29:37 <dmwit> > 2 >> 3 :: [()]
19:29:38 <lambdabot>   No instance for (GHC.Num.Num [a0]) arising from the literal `2'
19:29:38 <lambdabot>  The type v...
19:29:40 <startling> > 0 >> inf
19:29:41 <lambdabot>   No instance for (GHC.Num.Num [a0]) arising from the literal `0'
19:29:41 <lambdabot>  The type v...
19:29:50 <arkeet> but mine is lazier =)
19:29:55 <dmwit> > (2 :: [()]) >> (3 :: [()])
19:29:58 <lambdabot>   [(),(),(),(),(),()]
19:30:05 <arkeet> > [undefined] >> [()]
19:30:06 <lambdabot>   [()]
19:30:09 <startling> > (0 :: [()]) >> inf
19:30:12 <lambdabot>   []
19:30:15 <arkeet> > [()] >> [undefined]
19:30:16 <lambdabot>   [*Exception: Prelude.undefined
19:30:22 <arkeet> > 1 * [undefined::()]
19:30:24 <startling> > inf >> (0 :: [()])
19:30:26 <lambdabot>   mueval-core: Time limit exceeded
19:30:27 <lambdabot>   mueval-core: Time limit exceeded
19:30:29 <arkeet> > 1 * [undefined::()]
19:30:33 <lambdabot>   mueval-core: Time limit exceeded
19:30:34 <startling> arkeet, jinx
19:30:35 <arkeet> huh
19:30:43 <arkeet> > 1 * [undefined::()]
19:30:46 <lambdabot>   [()]
19:30:58 <startling> udevd: oops, was your question answered? we're easily distracted
19:31:01 <arkeet> :D
19:31:12 <dmwit> Yes, yours is a tad lazier. But then it oughta be [Void] anyway, and then the question of element-laziness is moot. ;-)
19:31:23 <arkeet> no, it shouldn't be [Void].
19:31:26 <udevd> startling: it was, thanks
19:31:27 <arkeet> [Void] only has one (total) value
19:31:27 <udevd> :)
19:31:35 <dmwit> peef peef
19:31:50 <arkeet> I want to be fast and loose.
19:31:51 <arkeet> :c
19:32:09 <udevd> i actually didn't expected that all these models of naturals do have some application
19:32:11 <dmwit> I like where this thread is going...
19:32:24 <roconnor> > mapM (const [(),(),()]) [(),()]
19:32:25 <lambdabot>   [[(),()],[(),()],[(),()],[(),()],[(),()],[(),()],[(),()],[(),()],[(),()]]
19:32:44 <startling> udevd, the ordinary model of Nat does the same thing (in haskell)
19:32:48 <arkeet> roconnor: hah
19:32:59 <udevd> > [(),()] :: Int
19:33:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:33:00 <lambdabot>              with actual type ...
19:33:06 <roconnor> > concat $ mapM (const [(),(),()]) [(),()]
19:33:07 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
19:33:16 <roconnor> > concat $ mapM (const [(),()]) [(),(),()]
19:33:17 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
19:33:33 <arkeet> I'm a little confused now how that works.
19:33:34 <udevd> > 2 :: [()]
19:33:37 <roconnor> I think I've done this wrong
19:33:37 <lambdabot>   [(),()]
19:33:50 <dmwit> f 3 2 = 18; f 2 3 = 24?
19:33:52 <dmwit> What is f?
19:33:53 <arkeet> you're trying to do exponentiation, right?
19:33:58 <roconnor> arkeet: yes
19:34:14 <arkeet> dmwit: looks like f x y = (x^y) * y maybe?
19:34:20 <dmwit> f a b = a^b * b ?
19:34:30 <dmwit> arkeet: yeah
19:34:35 <roconnor> > mapM_ (const [(),(),()]) [(),()]
19:34:36 <lambdabot>   [(),(),(),(),(),(),(),(),()]
19:34:39 <arkeet> that's the onel.
19:34:41 <arkeet> l.
19:34:51 <roconnor> > mapM_ (const [(),()]) [(),(),()]
19:34:51 <dmwit> aaaah
19:34:52 <lambdabot>   [(),(),(),(),(),(),(),()]
19:34:55 <dmwit> Now I understand.
19:34:57 <arkeet> =)
19:34:58 <roconnor> that looks better
19:35:04 <arkeet> that's cute.
19:35:14 <dmwit> I mean, I understand where the (*b) part came from. =)
19:35:18 <dmwit> Yeah, it's cute.
19:35:51 <udevd> >cute in this meaning
19:35:51 <ezrios> > repeat ()
19:35:52 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
19:35:54 <ezrios> woo
19:36:19 <arkeet> > inf^0
19:36:22 <lambdabot>   [()]
19:36:24 <arkeet> =)
19:36:27 <Hafydd> O_O
19:36:28 <dmwit> udevd: clever, short, unexpected, elegant
19:36:30 <ezrios> now that is something
19:36:39 <dmwit> udevd: some or all of these together is cute =)
19:36:46 <arkeet> so (^) = mapM_ . const
19:36:55 <roconnor> > mapM_ (const (repeat ())) []
19:36:55 <lambdabot>   [()]
19:37:02 <udevd> so you consider some proofs as cute :D?
19:37:06 <arkeet> yes
19:37:07 <dmwit> definitely!
19:37:11 <arkeet> hint: programs = proofs
19:37:18 <dmwit> Have you seen that twitter account that proves things in 140 characters...?
19:37:27 <arkeet> I have not!
19:37:43 <udevd> didn't knew that meaning of >cute yet... :D
19:37:47 <dmwit> https://twitter.com/tinyproof
19:37:55 <hpaste> bb010g pasted “JuicyPixel Type Error” at http://lpaste.net/91852
19:38:16 <ezrios> dmwit: that's incredible
19:38:54 <arkeet> aww, fairly low activity
19:39:02 <bb010g> I'm getting a weird type error, even though manually using withImage with f and img substituted in works. Know why?
19:39:56 <startling> "2⁽1/n) is irrational for n≥3. Proof (Schultz, 2003): Assume 2⁽1/n) = p/q; then pⁿ = qⁿ + qⁿ, contradicting Fermat's Last Theorem."
19:40:03 <startling> oops
19:40:12 <dmwit> bb010g: Did you really mean to do the IO (readImage) in there?
19:40:38 <startling> 2^(1/n) is irrational for n≥3. Proof (Schultz, 2003): Assume 2^(1/n) = p/q; then p^n = q^n + q^n, contradicting Fermat's Last Theorem.
19:40:39 <udevd> startling: using fermat's last theorem in such thing...
19:40:40 <startling> cheeky
19:40:50 <dmwit> bb010g: If so, you'll need to say so in the type signature.
19:41:02 <arkeet> startling: and it wasn't a proof before 2003!
19:41:13 <startling> arkeet, that's the best part.
19:41:41 <udevd> i wonder how long was schultz paper
19:41:46 <udevd> schultz's
19:41:47 <udevd> *
19:42:05 <dmwit> Hah!
19:42:13 <arkeet> hehe https://twitter.com/AntonioRoLe/status/332148605546815488
19:42:16 <dmwit> I wouldn't be surprised if the Schultz paper showed a few other things, too.
19:42:23 <bb010g> dmwit: *derp* But IO (Either String a) still doesn't work...
19:42:24 <arkeet> hmm, this sounds like a -blah topic now.
19:43:21 <dmwit> bb010g: I wonder; what type does GHC infer for withImage if you leave the type signature off?
19:43:28 <arkeet> :t either (pure.Left) Right
19:43:29 <lambdabot> Either a (Either a b) -> Either a1 (Either a b)
19:43:31 <arkeet> oops.
19:44:20 <arkeet> :t traverse
19:44:24 <arkeet> that's the one.
19:45:29 <arkeet> :t either (pure.Left) (fmap Right)
19:45:31 <lambdabot> Applicative f => Either a (f b) -> f (Either a b)
19:45:37 <hpaste> bb010g revised “JuicyPixel Type Error”: “JuicyPixel Type Error” at http://lpaste.net/91852
19:45:41 <bb010g> dmwit: It fails.
19:45:57 <dmwit> arkeet: "I want to see the classification of finite simple groups"?
19:46:07 <roconnor> costrength
19:46:33 <arkeet> dmwit: basically =)
19:47:46 <arkeet> oh that's a cute fermat's little theorem. https://twitter.com/tinyproof/status/329590281974476800
19:48:07 <dmwit> Yes, I remember thinking that one was particularly nice.
19:48:10 <ezrios> arkeet: I noticed that one as well
19:48:39 <arkeet> and lagrange's theorem that follows, I suppose.
19:48:54 <arkeet> well, part of it.
19:49:02 <dmwit> bb010g: don't know much about JuicyPixels, sorry
19:49:09 <applicative> wImage f = readImage >=> either putStrLn f
19:49:17 <arkeet> well, whatever.
19:49:26 <arkeet> to -blah!
19:51:14 <roboguy_> does Data.Sequence fuse?
19:52:44 <meretrix> I doubt this is possible, but is there any way to use cereal serialization to share data with C++?
19:52:50 <hpaste> tabemann pasted “This was painful to write” at http://lpaste.net/91854
19:53:18 <hpaste> tabemann pasted “This was not” at http://lpaste.net/91855
19:54:53 <dmwit> tabemann: 1/3 lines is imports =P
19:55:27 <dmwit> meretrix: Why do you doubt it's possible?
19:55:30 <tabemann> that's because I like naming each individual function, type, and constructor I'm importing
19:55:54 <ezrios> tabemann: and here I was about to ask if learning concurrency in Haskell would be sane for someone who's never used it (heavily) before
19:56:18 <tabemann> concurrency in Haskell is wonderful
19:56:23 <arkeet> there ought to be something that will automatically create explicit import lists for you.
19:56:41 <tabemann> especially if you use STM
19:57:04 <ReinH> dmwit: would you mind showing me how to use split here properly? https://gist.github.com/reinh/d0a67107b9d0f7172b34
19:57:06 <tac> ezrios: The sanity that purity brings to concurrency probably outweighs the insanity of the purity itself.
19:57:07 <ReinH> sorry for being slow today
19:57:08 <arkeet>  well, that example could have been done just with MVars
19:57:09 <ezrios> tabemann: have you any resources on learning concurrency in haskell?
19:57:24 <ezrios> tac: that is actually very true
19:57:30 <meretrix> dmwit: Well I should clarify: "possible without writing my own implementation".
19:57:53 <tabemann> ezrios: Simon Marlow's book, Parallel and Concurrent Programming in Haskell
19:57:59 <tabemann> it's great
19:58:02 <ezrios> sounds spot on
19:58:14 <johnw> it is a really good book
19:58:15 <ReinH> tabemann: +1
19:58:18 <johnw> on more than just concurrency, too
19:58:21 <dmwit> meretrix: You cannot communicate with C++ without writing any code, no.
19:58:23 <ezrios> zomgs and it's free
19:58:50 <udevd> wow, there were computers using ternary logic :o http://en.wikipedia.org/wiki/Setun
19:58:50 <dmwit> meretrix: (Or what does "without writing my own implementation" mean?)
19:58:57 <meretrix> dmwit: Well I'm currently using MessagePack with ZeroMQ, which was fine until I ran into some bugs with MessagePack.
19:59:15 <tabemann> arkeet: yes, that example could have been done with MVars, I know
19:59:28 <tabemann> I should make an MVar version just to compare the performance
19:59:33 <dmwit> ReinH: I wouldn't mind at all.
19:59:36 <startling> udevd, haskell uses ternary logic!
19:59:51 <startling> (Bool has three values)
20:00:01 <startling> (True, False, and undefined)
20:00:10 <arkeet> True, False, and "who knows"
20:00:21 <udevd> it's actually not so surprising
20:00:26 <startling> True, False, and "not yet"
20:00:33 <arkeet> True, False, and "let me get back to you on that"
20:00:37 <arkeet> (maybe)
20:00:50 <udevd> ...as if would have only True and False, we could solve stop problem
20:00:58 <dmwit> ReinH: Something like this: randomUniverse = do { g <- getStdGen; let (gl, g') = split g; (gr, g'') = split g'; ls = randoms gl; rs = randoms gr; (x, g''') = random g'' in putStdGen g'''; return (U ls x rs) }
20:01:00 <udevd> halting problem*
20:01:48 <ReinH> dmwit: gotcha
20:01:50 <dmwit> udevd: right =)
20:02:06 <dmwit> ReinH: There are monads that abstract all that g' g'' g''' nonsense, of course.
20:02:35 <ReinH> MonadRandom, etc
20:02:51 <arkeet> StateT StdGen
20:02:59 <arkeet> :t state split
20:02:59 <lambdabot>     Couldn't match type `[a1] -> [[a1]]' with `(a0, Splitter a1)'
20:03:00 <lambdabot>     Expected type: Splitter a1 -> (a0, Splitter a1)
20:03:00 <lambdabot>       Actual type: Splitter a1 -> [a1] -> [[a1]]
20:03:01 <arkeet> hm
20:03:03 <arkeet> wrong split
20:03:09 <startling> :t split
20:03:10 <lambdabot> Splitter a -> [a] -> [[a]]
20:03:25 <startling> what's that?
20:03:38 <arkeet> it's from Data.List.Split
20:03:49 <dmwit> :t System.Random.split
20:03:49 <lambdabot> RandomGen g => g -> (g, g)
20:04:01 <arkeet> :t state System.Random.split
20:04:02 <lambdabot> (MonadState a m, RandomGen a) => m a
20:04:02 <udevd> also, i tried to implement von Neumann naturals model in Haskell, where (0)={} (empty set), (n+1)={{n},n}
20:04:20 <udevd> but actually it didn't worked, as it could not construct infinite type [a]->[[a]]
20:04:26 <tabemann> okay
20:04:28 <udevd> is there a solution for this?
20:04:59 <arkeet> don't use von Neumann naturals. =)
20:05:36 <dmwit> udevd: Recursive types are allowed, but must have a constructor in between. Use newtype or data.
20:05:42 <tabemann> implemented MVarSpeedTest to match TMVarSpeedTest, and MVarSpeedTest takes roughly 0.166 the time per cycle vis-a-vis TMVarTest
20:05:50 <arkeet> or sure, you could do that.
20:05:53 <udevd> mhm
20:06:05 <TallerGhostWalt> Howdy
20:06:16 <arkeet> newtype Nat = Nat [Nat]
20:06:22 <TallerGhostWalt> Anyone know a tool similar to flay for haskell?
20:06:27 <arkeet> but a lot of values of that type won't be the things you want.
20:06:31 <arkeet> also, note that lists are ordered
20:06:47 <tabemann> with a cycle time of roughly 80 ns
20:06:54 <arkeet> TallerGhostWalt: what's flay?
20:06:57 <tabemann> with -threaded and +RTS -N1
20:07:27 <TallerGhostWalt> https://github.com/seattlerb/flay
20:08:29 <t4nk144> Hi, I have a newbie question about hmatrix library. How do I get the length of vector which type is (STVector s Double)
20:08:44 <tabemann> its performance degrades spectacularly with +RTS -N2, with a cycle time of 7 us
20:09:12 <udevd> t4nk144: dim?
20:09:22 <tabemann> and this was with making sure to not use the main thread for much beyond setup too (as it has poor performance due to being a bound thread)
20:09:29 <udevd> i don't know how STVector, i am working with Vectors right now
20:09:34 <applicative> TallerGhostWalt: haskell-src-exts has some of this
20:09:36 <t4nk144> function length is defined only for (Vector Double) but not for mutable vectors
20:10:05 <TallerGhostWalt> thanks I will check it out
20:10:13 <TallerGhostWalt> there is also flog
20:10:23 <applicative> TallerGhostWalt: I don't think anyone has made an executable like flay out of it.
20:10:29 <udevd> t4nk144: length :: MVector s a -> Int -- Length of the mutable vector.
20:10:32 <udevd> hm
20:10:38 <TallerGhostWalt> but Honestly, figuring out what haskell code is overly complex is pretty easy
20:10:55 <udevd> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Mutable.html i've found this here
20:10:58 * tabemann wonders right now if there's a way to tell the GHC RTS to *group* multiple threads on the same HEC, to avoid behavior like this
20:11:01 <t4nk144> in hmatrix there is no such function
20:11:15 <t4nk144> for STVector s a
20:11:45 <t4nk144> can I convert STVector s a to Vector a
20:11:57 <arkeet> t4nk144: the vector package has lots of types called Vector in different modules.
20:11:58 <applicative> TallerGhostWalt: hah, flog is pretty good; it's an outrage it wasnt written for haskell first ...
20:12:02 <arkeet> anyway, you might want length from Data.Vector.MVector
20:12:25 <TallerGhostWalt> applicative: agreed
20:12:36 <udevd> t4nk144: there is >dim
20:12:47 <arkeet> uh, or Data.Vector.Generic.Mutable
20:12:55 <udevd> but wait--
20:13:06 <t4nk144> well, what I really need is the number of rows of (STMatrix s a)
20:13:17 <arkeet> I guess they're the same.
20:13:26 <tabemann> a ha - there's forkOn, which *does* allow explicit Haskell thread to capability mapping
20:13:28 <applicative> t4nk144: freeze
20:13:56 <applicative> runST (freeze mymutablestvector)
20:14:11 <arkeet> applicative: he wants the length.
20:14:32 <applicative> length only applies directly to pure ones, right?
20:14:39 <t4nk144> to applicative: I think about this, but can not cope with s type variables :)
20:14:49 <t4nk144> yep, only to pure
20:15:06 <applicative> they're great t4nk144 , but maybe there's G.length like arkeet says?
20:15:25 <t4nk144> there is no generic interface in hmatrix
20:15:31 <arkeet> no, from Vector
20:15:39 <arkeet> er, vector
20:15:43 <t4nk144> well, but I have a matrix
20:15:47 <arkeet> but you have a STVector
20:15:48 <applicative> class MVector v a where basicLength :: v s a -> Int
20:15:56 <arkeet> use length, not basicLength.
20:15:57 <arkeet> as it suggests
20:16:11 <t4nk144> STMatrix s a from Data.Packed.ST
20:16:24 <applicative> oh, this is a vector version of hmatrix?
20:16:24 <arkeet> STVector is from vector
20:16:30 <arkeet> I think.
20:16:30 <t4nk144> yep
20:16:33 <arkeet> unless hmatrix has its own thing.
20:16:45 * tabemann wishes he had learned about forkOn before
20:16:48 <arkeet> agh it does.
20:16:52 <t4nk144> for vectors I think they use Data.Vector
20:17:02 <t4nk144> but with matrixes I have this problem
20:17:10 <scshunt> RealWorld is scary
20:17:15 <arkeet> oh, it does.
20:19:03 <applicative> i see this hmatrix a nightmare
20:19:12 <xenocons> is BNF still the prefered way for describing a grammar, or ADT syntax?
20:19:40 <xenocons> (in documentation)
20:20:12 <applicative> I see, so the underlying 'Vector' type is Data.Vector.Storable
20:21:27 <t4nk144> to applicative: yes regarding vector
20:21:38 <applicative> it's really confusing; hmatrix Vector = vector Vector.Storable
20:21:52 <applicative> hmatrix STVector /= vector STVector
20:21:55 <t4nk144> but matrix'es have completely different type and no generic interface from Data.Vector
20:21:56 <applicative> it's just his own newtype
20:22:13 <t4nk144> yes :)
20:22:24 <tabemann> okay, is there any package that contains any kind of abstraction over forkOn, e.g. allows defining "thread groups" whose members are guaranteed to be on the same capability, and which attempts to evenly distribute these over available capabilities?
20:22:50 <t4nk144> I'm contemplating something with runSTMatrix but can not get rid of escaping s variable :)
20:23:20 <t4nk144> this is because of my newbieness probably
20:23:22 <applicative> i see, Matrix t is a record; one component is a (vector package) Vector
20:24:37 <cdk> tabemann: you could work out the thread groups on capabilities using resource-pool, you'd probably have to implement the distribution over capabilities though.
20:26:51 <tabemann> cdk: well the key thing is that I'd like, say, newThreadGroup :: IO ThreadGroup, and forkThreadGroup :: ThreadGroup -> IO a -> IO ThreadId, and ThreadGroup is basically newtype ThreadGroup = ThreadGroup Int, where the Int is a randomly generated capability number, or one that is specifically chosen to distribute groups even (but that would required top-level mutable state, and hence the unsafePerformIO hack)
20:28:54 <applicative> omg this repa plugin imports the entire disciple compiler for use with ghc?
20:29:08 <tabemann> the reason for this is that explicitly choosing capability numbers with forkOn isn't modular (as what is stopping different independent pieces of code from choosing the same numbers), and using randomR explicitly is clunky
20:29:26 <applicative> http://hackage.haskell.org/package/repa-plugin
20:30:02 <applicative> can {-#LANGUAGE Disciple#-} be far behind?
20:30:55 <tabemann> (dammit why can't Haskell have top-level mutable state without that damn hack?)
20:30:56 <cdk> tabemann: I'm going to play around with resource-pool and see if anything nice comes up
20:32:58 <tabemann> hmm
20:33:09 <tabemann> from looking at resource-pool, I would like something sort of like it
20:33:33 <tabemann> but one which maintains an *ordering* of CPUs, ordered by how many active threads are on it
20:34:08 <tabemann> and when creating a group, the CPU with the least threads on it is chosen, and as more threads are added to the group, the ordering is reordered
20:34:19 <cdk> A threadgroup could contain a priority queue for each core
20:34:34 <cdk> with key values as the number of workers currently using the CPU core
20:35:02 <tabemann> actually, I would order by *both* threads on cores and groups assigned by core
20:35:24 <tabemann> with cores being first sorted by thread count, and after that sorted again for cores with equal numbers of threads by number of groups
20:35:44 <tabemann> so if a bunch of groups are created at once, before any threads are created as members, they are still evenly distributed over cores
20:36:23 <tabemann> the only problem with this
20:36:46 <tabemann> is you have to pass around an object representing the state of all the cores
20:36:53 <tabemann> or you have to use the unsafePerformIO hack
20:37:22 <tabemann> the first isn't very modular, the second is just bad
20:38:00 <tabemann> hmm
20:38:02 <tabemann> even still
20:38:06 <tabemann> maybe I should create this
20:38:57 <tabemann> well
20:39:30 <tabemann> it still works if two different pools are created in different places - the two pools just don't know about each other in their distributing of threads and groups across cores
20:42:02 <tabemann> hmm... what would be good names for this... Control.Concurrent.Group?
20:44:01 <tabemann> (forgive the rambling)
20:46:05 <atticus> exit
20:46:19 <joneshf-work> anyone been through htcofp that i could pick their brain?
20:47:33 <tabemann> hmm
20:47:37 <tabemann> what would be a better name
20:47:42 <tabemann> CapabilityPool
20:47:44 <tabemann> or CorePool
20:47:56 <tabemann> CapabilityPool is more accurate, but is also more long-winded
20:47:56 <cschneid> from what I'm reading, acid state is a haskell-specific "db" of sorts? And it's not what I want if I just want to talk with postgres or friends?
20:51:33 <haasn> acid state is just for providing ACID guarantees on memory structures
20:51:57 <haasn> it's not really a db
20:52:18 <haasn> you can use it as one, but your entire data will be in memory
20:52:25 <tabemann> hah - you *can* change the number of capabilities from within Haskell
20:54:56 <tabemann> question
20:55:27 <cschneid> haasn: ok, postgres simple is what I'm after then, thanks :)
20:55:28 <tabemann> what is the most *well maintained* (not necessarily fast, scalable, or efficient) priority queue implementation for Haskell
20:56:19 <edwardk> just posted https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-1  I'd appreciate any feedback on typos or content errors before it gets blasted out to too wide an audience ;)
20:56:49 <cdk> tabemann: some of them have different asymptotic complexities, and support different functions
20:57:45 <tabemann> cdk: well this is going to be a priority queue which on most systems will likely have no more than 32 members, and on *most* systems for that matter will in the near future have no more than 8 or 12 members
20:58:12 <cdk> so complexity wont matter much anyways
20:58:21 <tabemann> I looked at the fingertree package, but its last update date is 2009, which discourages me
20:58:28 <cdk> I've used pqueue and its pretty nice
20:58:38 <cdk> last updated 2012
20:59:04 <edwardk> tabemann: fingertree is perfectly supported, but needs nothing from the ecosystem and is otherwise perfect
20:59:34 <edwardk> it is one of those 'deeply fundamentally right' packages that just doesn't change much
20:59:56 * hackagebot multiarg 0.18.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.18.0.0 (OmariNorman)
21:00:33 <silasm> edwardk: is this what you were talking about the other day? Awesome, I joined in the middle of that conversation and was wondering what it was. Probably won't be able to contribute much, but looking forward to it.
21:00:51 <tabemann> edwardk: so how would I choose between pqueue and fingertree
21:00:59 <edwardk> silasm: its the start of it at any rate. it'll be a several post series most likely
21:01:08 <edwardk> and it'll probably get gory by the end
21:01:31 <edwardk> but i want to introduce some more of the vocabulary for that space to the folks in this space so i have more people to talk to =)
21:02:40 <tabemann> fingertree definitely feels more complex to use than pqueue
21:02:40 <silasm> edwardk: awesome. I only got my first taste of optimizing Haskell a month or two ago when I first used ST and loved it, so this should be fun for me.
21:04:55 <edwardk> tabemann: pqueue is easy. fingertree is powerful when you need to extend your queue with a bunch of stuff, but it'll be 10x slower than any other priority queue
21:05:07 <edwardk> otoh, it can give you a perfectly fair queue and other properties in exchange for that 10x slowdown
21:05:14 <edwardk> but most domains don't need that fairness
21:06:07 <tabemann> hmm
21:06:11 <tabemann> maybe I'll just use pqueue
21:06:37 <carter> @hackage pqueue
21:06:37 <lambdabot> http://hackage.haskell.org/package/pqueue
21:06:59 <carter> @hackage fingertree
21:06:59 <lambdabot> http://hackage.haskell.org/package/fingertree
21:11:33 <haasn> edwardk:   showsPrec d w = case unshuffle w of -- you mean unkey
21:11:53 <edwardk> ah yeah i renamed it in the presentation above
21:12:20 <edwardk> fixed
21:12:49 <edwardk> fpcomplete++ # the school of haskell is a pretty nice place to work
21:13:29 <johnw> good to hear!
21:14:24 <johnw> I @-remembered that in my own heart :)
21:14:45 <applicative> tabemann: fingertree was last updated in June
21:20:18 <nuttycom> Hey, all. I'm trying to get started with Snap and am running into an early stumbling block - 'cabal install snap' is failing for me trying to build securemem-0.1.2:
21:20:19 <nuttycom> Preprocessing library securemem-0.1.2...
21:20:19 <nuttycom> [1 of 1] Compiling Data.SecureMem   ( Data/SecureMem.hs, dist/build/Data/SecureMem.o )
21:20:19 <nuttycom> Data/SecureMem.hs:33:40:
21:20:19 <nuttycom>     Module `GHC.ForeignPtr' does not export `ForeignPtrContents(..)'
21:20:43 <nuttycom> Any suggestions on how to work around and/or fix this?
21:20:58 <arkeet> post the whole build log somewhere
21:20:59 <arkeet> @where lpaste
21:20:59 <lambdabot> http://lpaste.net/new/haskell
21:21:17 <johnw> nuttycom: what version of GHC are you using?
21:21:42 <nuttycom> johnw: 7.4.1
21:22:05 <haasn> edwardk: looks cool but where's the n-dimensional implementation? :)
21:22:28 <edwardk> haasn: trivial once you follow the next post
21:22:41 <edwardk> =)
21:23:16 <hpaste> nuttycom pasted “'cabal install snap' failure” at http://lpaste.net/91856
21:23:54 <arkeet> maybe securemem only works on 7.6, hmm
21:24:49 <arkeet> yeah
21:25:04 <arkeet> but snap is still supposed to support 7.4
21:25:30 <johnw> arkeet: even now that HP is 7.6?
21:25:39 <nuttycom> I can get a more modern ghc, that's no big deal.
21:25:47 <dmj`> I don't see securemem as a dependency on snap's hackage page
21:25:47 <nuttycom> Thanks!
21:25:52 <applicative> arkeet: yeah, its clear that it wont build with ghc 7.4
21:25:52 <arkeet> it's indirect, probably
21:26:02 <dmj`> nuttycom: try cabal install securemem
21:26:18 <ReinH> edwardk: hai dude
21:26:22 <nuttycom> dmj`: same deal
21:26:30 <applicative> nuttycom: i think you are in for a world of trouble with 7.4
21:26:35 <arkeet> snap depends on clientsession depends on cipher-aes depends on securemem
21:26:42 <applicative> securemem is a new package
21:26:53 <arkeet> you could install cipher-aes-0.1.8
21:26:59 <arkeet> which is the latest to not require securemem
21:27:08 <applicative> ah, thats the answer
21:27:21 <dmj`> arkeet: ah
21:27:44 <nuttycom> Meh, I'll be causing myself headaches by trying to keep using something old and janky. I'll just upgrade ghc.
21:27:50 <arkeet> then bug the securemem maintainer to depend on base >=4.6
21:28:05 <applicative> i still think there will be trouble similar to this; the bytestring-0.9 is a frequent cause of this kind of mixup.
21:28:07 <arkeet> but it might be too late for that.
21:28:12 <arkeet> yeah
21:28:19 <arkeet> 7.6 is cool =)
21:28:24 <edwardk> heya ReinH
21:28:31 <ReinH> edwardk: how would I use something like data ListZipper a = ListZipper [a] a [a] with Control.Lens.Zipper?
21:28:46 <edwardk> Control.Lens.Zipper _is_ something like ListZipper
21:28:49 <ReinH> ah
21:29:23 <ReinH> so I want a zipper over a doubly infinite list
21:29:45 <ReinH> edwardk: I've been messing with comonads
21:29:50 <haasn> doubly infinite?
21:29:59 <ReinH> infinite in both directions from the point
21:30:05 <haasn> ah
21:30:12 <edwardk> the problem is i'm going to go down to the left in 'fromWithin'
21:30:12 <ReinH> I don't know the term
21:30:18 <edwardk> which will suck in your case
21:30:19 <edwardk> i never get there
21:30:23 <ReinH> right
21:30:29 <edwardk> 'no, left' =)
21:30:34 <ReinH> RIGHT
21:30:58 <ReinH> edwardk: I have a pretty reasonable zipper right now but I don't get any lens-y goodness with it :(
21:31:24 * applicative has found edwardk 
21:31:28 <applicative> s new screed
21:31:40 <edwardk> yeah you're basically hosed because everything for working with a traversal wants a finite lhs
21:31:43 <edwardk> applicative: the one on fp complete?
21:32:03 <ReinH> edwardk: right, no worries
21:32:05 <haasn> it seems pretty impossible to write zipper' :: [a] -> ListZipper a
21:32:09 <ReinH> edwardk: https://gist.github.com/reinh/4b3a39281f3f88c4046c
21:32:11 <haasn> I mean
21:32:18 <haasn> to have it work for doubly infinite zippers
21:32:34 <applicative> edwardk: yes.
21:32:41 <ReinH> edwardk: https://gist.github.com/reinh/6eb1c81340a283032b49/raw/ada453612c2f88b77b5b1ff1bd6dd53c67025d6d/gistfile2.txt
21:32:44 <edwardk> ReinH: sure.
21:32:45 <ReinH> cellular automata are fun
21:33:17 <applicative> ooo deluxe interactive haskell in the tutorial
21:33:27 <edwardk> Note: you can get slightly better random access if you use some kind of skew binary random access list in each direction then you can get log time indexing
21:33:45 <ReinH> edwardk: neat
21:34:12 <ReinH> edwardk: now I need to create rules from wolfram codes
21:34:19 <ReinH> so I can say rule 90 instead of rule90
21:34:46 <edwardk> ReinH: yeah i pasted something here for it a couple years back when someone asked how they worked but i have _long_ since lost it ;)
21:34:55 <ReinH> I suspect there's a pretty elegant formulation of that but I can't quite see it
21:35:38 <ReinH> edwardk: maybe you can give me a hint: what should be the type of rule?
21:36:03 <arkeet> Int -> (your current type of rule90)
21:36:13 <arkeet> or maybe Word8 instead of Int
21:36:23 <edwardk> ReinH; you need to look in your comonad at the 3 neighbors and determine the next bit from them, right?
21:36:42 <edwardk> ten its all 8 combinations giving you a bit
21:36:51 <ReinH> so for U (l:ls) x (r:rs) I need to look at l x and r
21:36:58 <edwardk> so you want to have all functions Bool -> Bool -> Bool -> Bool
21:37:02 <ReinH> right
21:37:30 <ReinH> edwardk: or I could have rule :: Int -> U Bool -> Bool
21:37:31 <edwardk> and that there are 3 inputs, 2^3 = 8 bits   2^8 = 256 rules, right?
21:37:48 <ReinH> so evolve rule = iterate (extend rule)
21:37:52 <edwardk> sure
21:38:06 <ReinH> edwardk: that's correct
21:38:23 <edwardk> what i was going to suggest is writing the function that takes a rule and gives you a cokleisli action on your sequence
21:38:46 <ReinH> "a cokleisle action on your sequence"
21:38:53 <ReinH> what is the type of a cokleisle action?
21:38:53 <edwardk> type Rule = Bool -> Bool -> Bool -> Bool       ; Rule -> U Bool -> Bool
21:39:04 <edwardk> where U Bool -> Bool is the cokleisli arrow in question
21:39:10 <ReinH> right, so a "comonadic action"
21:39:12 <edwardk> extend that to get U Bool -> U Bool
21:39:14 <edwardk> yes
21:39:24 <edwardk> kleisli ~ a -> m b
21:39:24 <ReinH> which is what rule90 currently is
21:39:31 <edwardk> cokleisli ~ w a -> b
21:39:31 <ReinH> edwardk: yep, makes sense
21:39:42 <ReinH> I think I'm starting to get it! :D
21:39:50 <edwardk> and then you can write the rule :: Word8 -> Rule
21:40:07 <ReinH> I just wanted to make sure that cokleisli arrow is what I've been calling "comonadic action" ;)
21:40:09 <edwardk> which just says what the answer is by looking at the bit of your Word8
21:40:14 <arkeet> (Bool,Bool,Bool) -> Bool
21:40:18 <arkeet> er
21:40:25 <arkeet> blah
21:40:49 <edwardk> you could also just look at you and your neighbors directly in rule and make rule :: Word8 -> U Bool -> Bool
21:41:45 <arkeet> that would give you more general automata.
21:42:22 <ReinH> arkeet: I'm trying to go up one abstraction at a time ;)
21:42:34 <ReinH> I'm happy right now to generalize from rule90 to rule 90
21:42:44 <edwardk> :t bits
21:42:47 <arkeet> tell that to edwardk =)
21:42:56 <ReinH> arkeet: I am not Edward Kmett.
21:43:00 <edwardk> :t partsOf bits
21:43:01 <lambdabot> (Functor f, Num t, Bits t) => LensLike f t t [Bool] [Bool]
21:43:07 <ReinH> ooh
21:43:15 <edwardk> > 0 & partsOf bits .~ [True,False,False]
21:43:19 <lambdabot>   mueval-core: Time limit exceeded
21:43:24 <edwardk> > 0 & partsOf bits .~ [True,False,False] :: Word8
21:43:25 <lambdabot>   1
21:43:28 <edwardk> > 0 & partsOf bits .~ [True,False,False] :: Int
21:43:29 <lambdabot>   1
21:43:32 <edwardk> > 0 & partsOf bits .~ [True,True,False] :: Int
21:43:33 <lambdabot>   3
21:43:38 <edwardk> now we can play
21:43:59 <ReinH> wait, what just happened
21:44:14 <johnw> what does this syntax mean: let ideStaticInfo = IdeStaticInfo{..}
21:44:14 * ReinH looks up partsOf
21:44:31 <edwardk> rule w (U (l:_) m (r:_)) = testBit w (0 & partsOf bits .~ [l,m,r])
21:44:32 <arkeet> partsOf turns Traversal' s a into Lens' s [a]
21:44:34 <arkeet> :t partsOf
21:44:39 <johnw> what are the record wildcards accessing in that case?
21:44:45 <johnw> oh, I get
21:44:52 <johnw> it compiling a new record based on the wildcards in scope
21:45:01 <edwardk> johnw: yeah
21:45:01 <ReinH> edwardk: woah.
21:45:17 <edwardk> ReinH: that short enough? =)
21:45:28 <ReinH> uh. once I unpack it and fit that into my brain, yes
21:45:39 <ReinH> edwardk: now how would a mere mortal derive that? ;)
21:45:52 <ReinH> while that is super awesome, I kinda don't want the answer just handed to me if you know what I mean
21:46:04 <edwardk> ReinH: partsOf can be used to get all the targets of a traversal as a lens
21:46:22 <edwardk> you aren't _supposed_ to change the vector length but if you make something too short it just leaves the rest unchanged
21:46:30 <edwardk> > (1,2) & partsOf both %~ reverse
21:46:31 <ReinH> heh
21:46:31 <lambdabot>   (2,1)
21:46:37 <johnw> ReinH: there is a paper called "lens is to functor as applicative is to biplate", which demystifies a lot of the partsOf magic
21:46:38 <arkeet> and if you make something too long it just ignores the excess
21:46:48 <ReinH> johnw: yeah I need to read that
21:46:53 <ReinH> so I grok the plated magic
21:47:04 <ReinH> this will give me more context to hang it on too
21:47:05 <ReinH> which is good
21:47:06 <edwardk> bits is a traversal of all of the bits in a Bits instance.
21:47:14 <ReinH> of which Word8 is one
21:47:14 <edwardk> > (12 :: Word8)^..bits
21:47:15 <ReinH> makes sense
21:47:16 <lambdabot>   [False,False,True,True,False,False,False,False]
21:47:19 <ReinH> ahhhhhh
21:47:21 <ReinH> fucking duh
21:47:25 <ReinH> that's beautiful
21:47:29 <edwardk> here the bits instance i'm using is for Int actually =)
21:47:36 <arkeet> > (12 :: Integer) ^.. bits
21:47:38 <lambdabot>   [False,False,True,True,False,False,False,False,False,False,False,False,Fals...
21:47:41 <arkeet> nice
21:47:51 <edwardk> arkeet: you can _read_ from an Integer, but you can't finish building it ;)
21:47:52 <arkeet> > (0 :: Integer) & bits .~ True
21:47:55 <arkeet> aw.
21:47:56 <lambdabot>   mueval-core: Time limit exceeded
21:47:57 <edwardk> its strict
21:48:11 <edwardk> never knows you're done with the infinite sequence of effects
21:48:13 <arkeet> > (0 :: Integer) & partsOf bits .~ [True]
21:48:17 <lambdabot>   mueval-core: Time limit exceeded
21:48:18 <arkeet> make this work!
21:48:20 <haasn> > let l = partsOf bits in view l (set l [True, False, True] 0) -- such shameful violation of the lens laws :(
21:48:23 <lambdabot>   mueval-core: Time limit exceeded
21:48:32 <ReinH> did I mention that holy fuck I love Haskell?
21:48:36 <haasn> oh?
21:48:39 <arkeet> haasn: defaults to Integer
21:48:51 <arkeet> and then set never terminates
21:48:58 <edwardk> ReinH: now, i use the bits for the Integer, to turn the three booleans into an Int that is the offset into your Word8
21:48:58 <satc> @pl \b -> a >>= lift b
21:49:01 <lambdabot> (a >>=) . lift
21:49:01 <lambdabot> optimization suspended, use @pl-resume to continue.
21:49:04 <edwardk> which if the 8 bits in your Word8 did you want?
21:49:06 <ReinH> edwardk: ok, so I can traverse the bits of my rule
21:49:13 <edwardk> rule w (U (l:_) m (r:_)) = testBit w (0 & partsOf bits .~ [l,m,r])
21:49:19 <haasn> oh, I mussed have missed that in edwardk's earlier demonstration
21:49:33 <xenocons> :t splitOn
21:49:35 <lambdabot> Eq a => [a] -> [a] -> [[a]]
21:49:38 <arkeet> edwardk: I don't think that's right.
21:49:41 <edwardk> so we built an Int, with l as the lsb, m as the second and r as the third bit.
21:49:43 <xenocons> now where is that defined...
21:49:57 <edwardk> arkeet: why not?
21:49:59 <haasn> for a moment I thought set on ‘partsOf’ was deeply magical and didn't modify the elements after my list ends
21:50:05 <arkeet> we're confusing the 3 bits of the U with the 8 bits of the rule number.
21:50:08 <edwardk> haasn: it is
21:50:09 <haasn> :t partsOf
21:50:12 <ReinH> edwardk: l as the lsb? er?
21:50:33 <ReinH> oh duh
21:50:35 <xenocons> ah i see, Data.List.SPlit
21:50:39 <arkeet> unless I'm horribly confused.
21:51:00 <arkeet> I don't think I am.
21:51:02 <haasn> edwardk: wait, you're right; I'm confused now, how come it doesn't work for Integer?
21:51:12 <arkeet> haasn: Integers have infinitely many bits.
21:51:14 <haasn> oh, right, because Integer is trict
21:51:15 <arkeet> you can't set them all.
21:51:16 <haasn> strict*
21:51:17 <arkeet> yes
21:51:19 <edwardk> the 3 bits of U tell me the, which rule i want. the rules for a wolfram automaton are numbered 0..255. 2^8 rules
21:51:19 <haasn> or something
21:51:35 <edwardk> you have 3 inputs, and in response to the 3 inputs you do something
21:51:41 <arkeet> oh never mind.
21:51:44 <arkeet> I misunderstood testBit
21:51:54 <edwardk> :t testBit
21:51:54 <arkeet> so I _was_ horribly confused.
21:51:54 <lambdabot> Bits a => a -> Int -> Bool
21:52:01 <edwardk> the first arg is the word8
21:52:08 <arkeet> for some reason I was mixing it up with bitwise &
21:52:12 <edwardk> the second is the int we built to index it that falls in the range 0..7
21:52:34 <edwardk> nah, its & with 2^n
21:52:35 <arkeet> (maybe because of the "test" x86 instruction or something)
21:52:38 <arkeet> yeah.
21:54:00 <ReinH> edwardk: right, the index is [l,m,r], duh
21:54:14 <haasn> arkeet: I wonder how easy it would be to write instance Bits LazyNat
21:54:25 <edwardk> ReinH: and thats all there is to it
21:54:36 <edwardk> sorry for skipping to the punchline, but it was too fun not to write it ;)
21:54:38 <arkeet> haasn: it would probably be awful, and not what you want to do anyway.
21:54:46 <arkeet> assuming LazyNat is peano naturals.
21:55:13 <edwardk> and when you extend that you get the full rule implementation over the entire zipper
21:55:34 <haasn> I was thinking of peano first but come to think of it isn't there a lazy nat definition somewhere based on lists of.. something?
21:55:34 <ReinH> edwardk: this is what I got from that http://24.media.tumblr.com/tumblr_lmcwc72ai91qixmlpo1_500.jpg
21:55:36 <edwardk> if you wanted to just do this with Store, you can tweak the definition a bit
21:55:41 <edwardk> :t Store
21:55:41 <lambdabot> Not in scope: data constructor `Store'
21:55:41 <edwardk> :t StoreT
21:55:41 <lambdabot>     Not in scope: data constructor `StoreT'
21:55:41 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
21:55:41 <arkeet> haasn: we have [Bool]
21:55:44 <arkeet> or Stream Bool
21:55:49 <haasn> arkeet: http://hackage.haskell.org/packages/archive/nat/0.3/doc/html/Data-Number-Nat1.html#t:Nat1
21:56:04 <arkeet> that's [Bool]
21:56:08 <haasn> yes
21:56:14 <edwardk> rule w (Store f s) = testBit w $ 0 & partsOf bits .~ [f (s - 1),f s,f (s + 1)]
21:56:18 <haasn> arkeet: (almost)
21:56:23 <arkeet> hm, how does 0 get encoded?
21:56:27 <ReinH> edwardk: wait, where does bits live?
21:56:35 <haasn> arkeet: data Nat = Zero | Pos Nat1
21:56:35 <edwardk> Data.Bits.Lens
21:56:50 <edwardk> it has some siblings hiding in there
21:56:53 <arkeet> oh, hence teh 1.
21:57:12 <haasn> arkeet: this implementation quite specifically doesn't allow eg. [False, False, False, ...]
21:57:21 <haasn> so for finite naturals, you can always fully evaluate them
21:57:22 <arkeet> of course.
21:57:31 <arkeet> well it allows O (O (O (...)))
21:57:41 <arkeet> but it really is [Bool]
21:57:51 <arkeet> where O = (False:), I = (True:), and IHi = []
21:57:52 <arkeet> ;)
21:58:03 <haasn> fair enough :)
21:58:12 <haasn> arkeet: I guess this allows different kinds of infinity though?
21:58:19 <arkeet> how so?
21:58:36 <haasn> fix O  vs fix I -- both are larger than any finite number by comparison
21:58:54 <arkeet> I argue that the ordering is wrong in that case.
21:59:04 <arkeet> or doesn't make sense.
21:59:04 <arkeet> :p
21:59:10 <haasn> (I think? I don't know the implementation)
21:59:15 <tabemann> hah - got thread groups already implemented and working
21:59:41 <haasn> arkeet: I checked, my assumptions were right
21:59:41 <arkeet> but that's very close to 2-adic integers.
22:00:39 <haasn> and fix O `compare` fix I = _|_
22:00:45 <ReinH> edwardk: so... rule works
22:00:46 <ReinH> wat
22:00:48 <arkeet> and 2-adic integers aren't ordered.
22:00:51 <ReinH> fucking aliens
22:00:54 <arkeet> haha
22:01:14 <edwardk> ReinH: =)
22:01:27 <ReinH> edwardk: ok I will probably spend a few days parsing this conversation and that line of code
22:01:38 <edwardk> ReinH: did you ever post the audio?
22:02:06 <ReinH> edwardk: I'm going to give it to Chris in a couple days.
22:02:06 <edwardk> should have checked before i nerd sniped you with lens code =)
22:02:12 <ReinH> haha
22:02:26 <tabemann> hmm... this feels like it should be useful... but it feels too *small* to bother putting into Hackage...
22:02:35 <johnw> edwardk: where is the version of your NYC talk that has fixed video?
22:02:44 <johnw> i meant, fixed audio
22:03:00 <ReinH> so what's the most pragmatic way to paint some pixels onto the screen or into a file on OS X?
22:03:04 <edwardk> youtube
22:03:07 <johnw> k
22:03:18 <ReinH> just write a bitmap file or something?
22:03:21 <edwardk> http://www.youtube.com/watch?v=cefnmjtAolY
22:03:23 <johnw> http://www.youtube.com/watch?v=cefnmjtAolY
22:03:30 <edwardk> yep
22:03:35 <edwardk> you probably want the hd version
22:03:42 <johnw> i always youtube-dl everything
22:03:51 <edwardk> so weird seeing me with long hair
22:04:12 <ReinH> maybe just http://hackage.haskell.org/packages/archive/bmp/1.2.5.2/doc/html/Codec-BMP.html ?
22:04:34 <haasn> ReinH: there's something involving repa, and also something involving JuicyPixels
22:04:47 <ReinH> haasn: http://hackage.haskell.org/packages/archive/repa-io/1.1.0.0/doc/html/Data-Array-Repa-IO-BMP.html ?
22:04:50 <haasn> and something involving both, apparently
22:04:58 <haasn> ReinH: http://hackage.haskell.org/packages/archive/repa-devil/0.3.2.2/doc/html/Data-Array-Repa-IO-DevIL.html
22:05:03 <ReinH> nice
22:05:10 <dolio> edwardk: I don't think the long hair makes nearly as much of a difference as the beard.
22:05:11 <arkeet> edwardk has short hair now?
22:05:31 <haasn> ReinH: http://hackage.haskell.org/packages/archive/repa-devil/0.3.2.2/doc/html/Data-Array-Repa-IO-DevIL.html
22:05:31 <johnw> indeed he does
22:05:55 <carter> and i think you can probably hear me interject at some point no doubt
22:06:03 <carter> as I do in every talk i attend, everywhere
22:06:04 <carter> ever
22:06:17 <haasn> carter: what you are referring to as Linux is actually ...
22:06:17 <carter> thats the nyc talk right?
22:06:37 <carter> haasn i have no idea what you're talking about
22:06:40 <carter> :)
22:06:51 <carter> was thinking about this http://www.youtube.com/watch?v=cefnmjtAolY
22:07:01 <ReinH> building repa, see you guys tomorrow...
22:07:11 <carter> ReinH: in a month repa will be passe :)
22:07:13 <carter> ish
22:07:24 <ReinH> I just want to write a greyscale bitmap...
22:07:27 <haasn> carter: http://www.lurkmore.com/wiki/GNU/Linux_interjection
22:07:40 <carter> nope
22:07:49 <carter> i actually don't do neckbeard things
22:08:01 <haasn> right. I was just being silly :)
22:08:15 <carter> i really dislike the gnu / fsf / gpl subculture
22:08:45 <carter> but thats a rant for another time :)
22:08:58 <arkeet> you're not the only one
22:09:09 <haasn> I tend to dislike GNU software. I don't really care about the moral crusade bit
22:09:23 <carter> the software is sometimes ok
22:09:36 <carter> but they can be controlling as a community / org
22:09:47 <ReinH> oh well that's pretty convenient, JuicyPixels has a float representation for greyscale
22:10:02 <ReinH> where 0..255 maps onto 0..1
22:10:05 <ReinH> convenient
22:10:53 <haasn> ReinH: I don't think juicypixels is that smart, actually
22:11:04 <haasn> I think it just writes the data to the disk in that representation
22:11:28 <haasn> oh, I could have just checked the haddock :)
22:11:47 <ReinH> haasn: ok :)
22:12:07 <ReinH> I don't care about smart, I just want to paint some pixels on my screen in the most pragmatic way possibler
22:12:25 <haasn> ReinH: nvm, it uses greyScaleToStandardDef :: Image PixelF -> Image Pixel8 internally
22:12:36 <Hafydd> GNU Haskell Compiler
22:12:55 <ReinH> I basically want to go from [[Bool]] to painting black or white pixels on my screen or into a file and I don't much care how I do it
22:13:11 <Polarina> Hafydd, it's not part of the GNU project.
22:13:20 <haasn> ReinH: it would be super cool if you could hack something together with diagrams
22:13:31 <haasn> by spacing out dots or squares or something onto a grid
22:13:35 <ReinH> haasn: ooh :)
22:13:37 <ReinH> that might be good
22:13:39 <Hafydd> Then why is it called GNU Haskell Compiler?
22:13:51 <Polarina> Hafydd, it is not called that.
22:13:52 <carter> Glasgow
22:13:56 <carter> or glorious
22:14:02 <carter> gnu can suck a lambda
22:14:04 <ReinH> I had forgotten about diagrams
22:14:04 <haasn> Glorious Glasgow Haskell Complication System
22:14:14 <haasn> ReinH: diagrams is often the best way to “get something on the screen” :)
22:14:18 <haasn> or “into a file”
22:14:19 <ReinH> nice :)
22:14:24 <ReinH> native SVG output
22:14:25 <haasn> or “onto a web browser”
22:14:27 <haasn> or anything else, really
22:14:29 <Hafydd> I wasn't talking about Glasgow Haskell Compiler; I was talking about GNU Haskell Compiler.
22:14:29 <ReinH> seems good
22:14:31 <haasn> ReinH: PNG too
22:14:33 <Hafydd> I don't know what gave you that idea.
22:14:33 <ReinH> nice
22:14:37 <haasn> ReinH: and Gtk, and lots more
22:14:41 <haasn> heck probably even OpenGL by now
22:14:49 <carter> true
22:14:52 <carter> haasn excellent points
22:14:58 <ReinH> haasn: badass
22:15:00 <ReinH> thanks!
22:15:06 <haasn> ReinH: another alternative to get something onto the screen effortlessly is gloss
22:15:14 <haasn> but that's even more limited than diagrams :)
22:15:22 <ReinH> I'll start with diagrams
22:15:23 <ReinH> seems good
22:16:50 <carter> diagrams is nice
22:17:15 <haasn> Hafydd: how misleading :)
22:19:08 <haasn> ReinH: seems like there's still no progress on https://github.com/diagrams/diagrams-povray
22:21:12 <haasn> ReinH: oh, there's a LaTeX backend too so it's also the easiest way to get it “on a paper” ;)
22:25:54 <ReinH> povray o_O
22:26:02 <ReinH> haasn: holy crap :)
22:26:05 <haasn> ReinH: whoa, this also seems useful https://github.com/mgsloan/diagrams-ghci/blob/master/screenshots/2012-08-05-150541_1280x800_scrot.png
22:27:31 <ReinH> haasn: omg I made a circle
22:30:47 <haasn> ReinH: foldr (|||) empty . map (foldr (===) mempty . map (\c -> unitSquare # color' c) -- for some appropriately defined color'
22:30:50 <haasn> seems like it should do the trick
22:30:58 <haasn> also wow that's ugly
22:31:06 <ReinH> haasn: hah I was just looking at that :)
22:31:27 <haasn> wait there are helper functions for that aren't there?
22:31:32 <ReinH> I wonder if they provide some nice convenience folds
22:31:42 <ReinH> foldVertical, w/e
22:31:44 <ReinH> ?
22:31:49 <haasn> hcat . map (vcat . map render)  where render c = unitSquare # color' c -- much better already
22:34:12 <ReinH> hcat and vcat, duh
22:38:59 <haasn> from the diagrams source code... newtype DUALTree d u a l = ...
22:39:14 <haasn> this library really is just as awesome as lens
22:39:29 <cmears> wait until you get a type error
22:40:04 <haasn> oh, come to think of it, that ‘DUAL’ is just initials of the d/u/a/l parameters; not ‘dual’ :(
22:40:27 <haasn> cmears: with great power comes great type errors
22:41:08 <cmears> "sorry, you need an additive affine space with HasBasis"
22:42:27 <cmears> yes, Down, Up, Annotation and Leaf, IIRC
22:50:56 <scshunt> is there a package with property definitions (for e.g. QuickCheck) of common typeclass laws?
22:51:04 <arkeet> why can't I derive Data.Default =(
22:51:31 <shachaf> You can GeneralizedNewtypeDerive it!
22:51:51 <Ghoul_> curl should just be deleted from hackage
22:52:02 <Ghoul_> im sick of people thinking its OK to use curl with haskell
22:52:20 <scshunt> Ghoul_: why isn't it?
22:52:28 <scshunt> also, ClassLaws appears to be roughly what I want
22:52:49 <Ghoul_> its near impossible to build on windows and then its near impossible to get cabal to make the thing you build link with the haskell
22:53:06 <Ghoul_> (I hear everyone in the room sigh at the mention of the word, windows)
22:53:55 <ReinH> haasn: working but it's a bit slower than I would like. Will dig into it.
22:55:28 <Ghoul_> maybe thats a good project for someone
22:55:37 <ReinH> edwardk: btw I need to reverse my bits to match the expected output
22:55:48 <ReinH> right now it's flipped left to right
22:56:19 <edwardk> ReinH: well, it was one way or the other ;)
22:56:45 <ReinH> yep :)
22:56:53 <ReinH> trying to figure out how I stick a reverse in there
22:57:00 * haasn .oO( partsOf (reversing bits) )
22:57:05 <ReinH> ah
22:57:43 <ReinH> wait what
22:58:13 <haasn> oh, no, that isn't an actual combinator
22:58:14 <edwardk> [r,m,l]
22:58:31 <ReinH> heh
22:58:43 <ReinH> ok fine
22:58:45 <shachaf> It would be nice if you could modify with bits on an Integer.
22:59:01 <edwardk> it makes me sad you can't
22:59:30 <haasn> edwardk: clearly, the lens library is a failure
22:59:59 <edwardk> yep
23:00:07 <ReinH> confirm
23:00:08 <edwardk> why do you think i'm reduced to playing with matrices now
23:00:23 <shachaf> edwardk: By the way, should we have a version of bits that uses bitSize?
23:00:32 <lispy> Ghoul_: I've had some pretty obnoxious problems with the curl library. They might have been solaris specific. Never could tell.
23:00:35 <shachaf> Rather than the silly complementing trick it uses right now.
23:00:39 <haasn> is there anything that strictly goes against a function which would take a traversal and yield the same traversal but backwards?
23:01:02 <shachaf> haasn: Nope. It's called backwards.
23:01:12 <shachaf> > [1,2,3] ^.. backwards traverse
23:01:14 <lambdabot>   [3,2,1]
23:01:17 <haasn> oh, right
23:01:24 <haasn> then ReinH: partsOf (backwards bits) -- :)
23:02:03 <edwardk> haasn: not what you want though
23:02:07 <Ghoul_> lispy: curl and gtk are the bane of cabal on windows right now
23:02:15 <edwardk> because backwards bits will stop at the top of the Int
23:02:23 <Ghoul_> 90% of projects I can build here perfectly nad have it run out of the box, and Ilove it.
23:02:24 <edwardk> and you still want the 3 lsbs
23:02:25 <lispy> Ghoul_: anything with a non-trivial C dependency is
23:02:26 <haasn> edwardk: oh, right
23:02:48 <lispy> Ghoul_: I like to make sure my packages build on windows, so I know how frustrating windows can be for haskell :(
23:02:57 <Ghoul_> lispy: :)
23:03:09 <Ghoul_> and we all love you for it
23:03:14 <lispy> hehe
23:03:57 <lispy> I think I'm subscribed to all the windows specific bugs in the ghc trac. I never get emails :(
23:04:11 <lispy> I guess that means I need to roll up my sleeves...
23:04:22 * haasn .oO( fromIntegral :: Word3 -> Int )
23:04:40 <ReinH> haasn: :p
23:04:50 <lispy> alright, that's enough #haskell for on day
23:04:54 <lispy> see you folks later
23:05:31 <edwardk> partsOf (backwards (taking 3 bits))  is clearly the right solution
23:05:51 <haasn> perfect
23:06:12 <edwardk> then you can even morally replace them without breaking laws
23:07:04 <ReinH> edwardk: next up: my first experience optimizing lenses for performance :D
23:07:30 <edwardk> heh, usually the generated code isn't so bad. here? no idea
23:07:59 * haasn wonders how much slower partsOf (backwards (taking 3 bits)) .~ [a,b,c]  would be vs.  partsOf bits .~ [c,b,a]
23:08:02 <Ghoul_> lispy: bye
23:08:12 <edwardk> haasn: benchmark!
23:08:30 <haasn> edwardk: I'm not on a machine that runs haskell at the moment :(
23:08:55 <scshunt> Hmm
23:09:08 <scshunt> I wonder how using lenses with a database library would work >:D
23:09:19 <edwardk> scshunt: did you see tables?
23:09:25 <haasn> there are lenses for json stuff too
23:09:58 <scshunt> edno
23:10:06 <scshunt> *edwardk: no
23:10:48 <edwardk> foo & with FooId (>=) 12.with FooBar (<=) 34.rows.fooField +~ 12
23:10:54 <haasn> a gloriously elegant but probably not very practical solution would be acid-state+tables+lenses
23:12:17 <edwardk> i wrote it to 'fast forward' and see what an unapologetic lens based api would look like
23:12:34 <haasn> edwardk travels to the future by writing it
23:12:35 <edwardk> on where it was willing to play a little fast and loose with the laws for a better user experience
23:14:14 <edwardk> >>> test^@.. group (head.fooBar).to count
23:14:14 <edwardk> [('F',2),('O',1),('T',2)]
23:15:22 <scshunt> edwardk: what are the stab types again, in Lens?
23:16:28 <edwardk> lets look at how they flow through
23:16:38 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
23:17:11 <edwardk> so you give me (a way to get an f full of b's given an a), and an s, and i'll give you an f full of ts
23:17:18 <edwardk> now, the only way i can do that
23:17:37 <haasn> (a good way demonstration I find is _2 :: Lens (x,a) (x,b) a b  )
23:17:43 <edwardk> since i all i know is that you gave me some functor f and i know nothing about f other than that it is a Functor, all i ca do is fmap over it to build that f.
23:17:49 <edwardk> so i have to call your function with some 'a'
23:17:57 <edwardk> which means i must have some way to find an 'a' in my 's'
23:18:28 <edwardk> give it to you, get an 'f b'   and turn it into an 'f t'
23:18:29 <edwardk> which i do by 'mapping the remaining parts of the 's' under the functor and wrapping them around the b to get a 't'
23:18:45 <edwardk> so with that, a lens is effectively a function 's -> a' that gets the part out of the whole  and
23:19:04 <edwardk> some function 's -> b -> t' that takes the other parts of the s wraps them around the b, giving me a new value of type 't'
23:19:21 <edwardk> now, s and t should be related, and a and b should be related
23:19:26 <edwardk> the laws talk about that
23:19:54 <edwardk> as for what they stand for, a and b are the things that unify with a and b in the definition of traverse
23:19:56 <edwardk> :t traverse
23:20:25 <edwardk> traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:21:02 <edwardk> and s and t are chosen so that when we look at the type of something that manipulates state, like +=, the s parameter (and usually the 't') are both the state parameter
23:21:20 <edwardk> so the names were chosen to minimize the amount of alpha renaming you had to do in your head for their common usecases
23:21:23 <ReinH> edwardk, haasn: https://dl.dropboxusercontent.com/u/632742/rule110.svg
23:21:37 <edwardk> probably the most thought put into 1 letter variable name choices evar ;)
23:21:45 <ReinH> (broken in stable Safari, works in Chrome and WebKit nightly)
23:21:50 <edwardk> ReinH: nice.
23:22:06 <edwardk> ReinH: you (we?) should write a blog post or article or something
23:22:14 <edwardk> but very pretty
23:22:24 <haasn> ReinH: it's pain and suffering in firefox
23:22:28 <haasn> ReinH: please render a .png next time =P
23:22:50 <haasn> my browser is about halfway through rendering it
23:24:09 <haasn> ReinH: or better yet, use the diagrams/ghcjs/whatever thing to render it out directly via webgl or whatever
23:24:23 <haasn> and let users input the rule to use from a form box or something
23:24:29 <haasn> update in realtime :)
23:25:15 <ReinH> haasn: oh is that a thing?
23:25:49 <haasn> I think so, but I'm not sure if it was just experimental/theoretical or actually serviceable
23:26:03 <scshunt> edwardk: I assumed it was something clever, coupled with being able to get away with "Lens stab"
23:26:33 <ion> s(ource), t(arget) are a good mnemonic.
23:26:53 <johnw> even though that's not where they came from :)
23:27:01 <ion> yep
23:27:05 <haasn> ReinH: maybe byorgey knows
23:27:53 <haasn> ReinH: https://github.com/ghcjs/diagrams-ghcjs
23:27:55 <ReinH> haasn: installing XQuartz just for you
23:27:55 <edwardk> s = state, t as target always bugged me, but its the easy one off the tip of your tongue, though it doesn't mean much
23:28:02 <edwardk> 'a' is really the 'target' of the lens
23:28:06 <ReinH> yeah Canvas would be the way to go...
23:28:11 <sordina> Hey does anyone know any Netwire?
23:28:13 <edwardk> t is maybe the 'transformed' version
23:28:27 <ReinH> if you want to do it "life"
23:28:29 <haasn> ReinH: I have no idea what that is
23:28:29 <ReinH> "live"
23:28:54 <ReinH> XQuartz is X11 for OS X
23:29:00 <ReinH> which satisfies the dependency for cairo
23:29:13 <edwardk> ReinH: what did you use to make the svg?
23:29:22 <ReinH> edwardk: diagrams built-in svg rendering
23:29:24 <haasn> ReinH: ah
23:29:30 <edwardk> sexy
23:29:43 <haasn> it's not actually built-in, I think, but a separate package, diagrams-svg
23:30:13 <ReinH> right but it's bundled with the default install
23:30:21 <ReinH> diagrams vs diagrams-core
23:30:46 <haasn> ReinH: https://github.com/ghcjs/diagrams-ghcjs/blob/master/src/Diagrams/Backend/GHCJS.hs looks like it should work
23:32:46 <ion> In the case of applying l %~ f to a value, i find the names “source” and “target” appropriate enough, and that *can* be a good mnemonic even though it only covers a small subset of what lens does. The point was just to remember what the s, t, a and b were.
23:33:19 <ion> But sure, “state” and “transformed” may be good, too.
23:33:31 <ReinH> eh I need to install gtk for cairo so I'll save that for tmw
23:35:48 <ReinH> man I just love the lensified version of wolfram coding
23:35:50 <edwardk> re the target mnemonic, i hear it from everyone so i assume it is natural.  ;) i just feel it is beneficial for the learning process to point out that really its 'a' that is the closest analogue to a target being viewed
23:35:52 <ReinH> edwardk: high five
23:38:24 <haasn> I think it may be more important to distinguish s/t from a/b; rather than s from t (and a from b) -- the only mnemonic I really know is that the arguments appear in the same order as you compose lenses to go into the structure, eg. x^.foo.bar.bat -- foo :: Lens' a b; bar :: Lens' b c; bat :: Lens' c d
23:39:32 <scshunt> edwardk: I don't understand the relationship between a and b and c and d :(
23:39:36 <scshunt> err, s and t
23:39:58 <haasn> I guess in this sense, s/t could be the ‘(st)ructure’, with a/b being the field
23:42:30 <scshunt> edwardk: in particular, 'view' constrains s = t and a = b, no?
23:42:45 <scshunt> and since this is a lens law, doesn't this constrain the Lens type generally?
23:43:10 <edwardk> scshunt: ideally there would be some notion of two type families involved in the definition of each and every lens
23:43:23 <haasn> view doesn't care about t/b are
23:43:34 <edwardk> you'd have some type family Outer i :: *   and type family Inner i :: *   for some indexing type i common to both
23:43:34 <haasn> over l :: (a -> b) -> s -> t
23:43:38 <edwardk> then we could read that as
23:43:53 <edwardk> (Inner i -> f (Inner j) -> Outer i -> f (Outer j)
23:44:02 <edwardk> but ghc's type system doesn't let me express that family structure
23:44:33 <aoeu> Does anyone have equerience with Haskell and Graph database/Linked Data/RDF?
23:44:41 <edwardk> the assertion that view works comes down to saying that we have to be able to pick i = j
23:45:15 * hackagebot cblrepo 0.9.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.9.0 (MagnusTherning)
23:45:38 <edwardk> scshunt: so your question is very well posed, but i'm doing something hinky to work around a limitation of the type system, so a lens has an implicit family structure we can only talk about informally
23:45:39 <haasn> oh, I was wrong. view *does* set s ~ t and a ~ b
23:45:51 <edwardk> haasn: it used to not
23:45:59 <edwardk> but that let to lots of pain
23:46:03 <edwardk> er led
23:46:13 <haasn> ah
23:46:43 <edwardk> play games with ToJSON and FromJSON constraints on something like, say a Prism.
23:46:58 <scshunt> edwardk: right, but I can't think of any valid Lens instance where s !~ t since or a !~ b because of the lens laws and the constraint on view
23:47:03 <edwardk> if you don't constrain the input and the output to be equal you wind up with an unconstrained requirement for a FromJSON class
23:47:16 <haasn> edwardk: makes sense
23:47:34 <edwardk> scshunt: think of the lens as being the full polymorphic function, not just the instantiation of it to some type
23:47:52 <scshunt> edwardk: oh right, ow
23:47:59 <edwardk> :t let _2 f (a,b) = (,) a <$> f b in _2
23:48:00 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
23:48:01 <haasn> scshunt: _2 :: Lens (x,s) (x,t) a b -- this has a ~ b in concrete cases
23:48:05 <haasn> can have*
23:48:07 <edwardk> see the types differing there?
23:48:31 <edwardk> you mean (x,a) (x,b) a b
23:48:41 <haasn> oops, yes
23:49:09 <haasn> I got it right earlier. Must be my decreasing mental health as a function of increasing time since last sleep :)
23:49:29 <haasn> speaking of which, I should really sleep
23:49:32 <edwardk> asically i have to be able to take s apart into a and 'some other crap' but when i wrap 'that other crap' around a fresh b i may get a new type t, but if i wrapped it around the same a, i would expect to be able to get back s
23:49:40 <scshunt> ah ok
23:50:04 <scshunt> edwardk: makes sense, thanks :)
23:51:26 <edwardk> a traditional 'isomorphism lens' style lens is type Lens s a = exists b. such that s is isomorphic to (a, b)
23:52:07 <edwardk> here we break that isomorphism up a bit s -> (a, b)   (c, b) -> t    allowing you to change out the type a = Inner i, for c = Inner j giving t = Outer j
23:52:30 <scshunt> ok
23:53:21 <scshunt> hmm
23:53:42 <scshunt> if I want to wrap the computations in a monad, the entire lens must be in the monad, right?
23:53:56 <edwardk> what computation?
23:54:03 <scshunt> the lens
23:54:15 <scshunt> such as a lens to, say, the contents of some file
23:54:36 <edwardk> we have 'actions' but no 'monadic lenses' in lens
23:54:51 <edwardk> i find them to be an ill-posed point in the design space i can't reason about
23:55:07 <edwardk> i used to say that about traversals but roconnor showed me a way to think about them
23:55:24 <edwardk> but i don't think the monadic lens injunction will break in my brain any time soon ;)
23:55:43 <edwardk> there are other packages that provide them, and which are much much smaller than lens
23:56:02 <edwardk> but they have no notion of type changing, and really just give getters/setters and no laws
23:57:55 <scshunt> as usual, I'm drowning in types and complex instances like Effective when I try to read the docs for Action :)
23:58:16 <edwardk> scshunt: actions are a weak idea that doesn't extend well
23:58:30 <edwardk> i view them as a failed experiment, but insofar as they go they are sound
23:58:47 <scshunt> can you elaborate on what exactly they do and why they are failed?
23:58:49 <edwardk> they were my first foray towards monadic lenses in the lens framework
23:58:56 <edwardk> what they are is a monadic 'getter
23:59:03 <edwardk> you can run an action with ^!
23:59:10 <edwardk> and it'll give you its monadic effect.
23:59:20 <edwardk> read it like ^. with an extra effect, hence the !
23:59:24 <scshunt> heh
23:59:34 <edwardk> now, an action can compose with other getters
23:59:51 <edwardk> :t act print
23:59:52 <lambdabot> (Show s, Conjoined p, Effective IO r f) => p () (f ()) -> p s (f s)
